diff --git a/gcc/calls.c b/gcc/calls.c
index cff26c41e..7ce935478 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -5700,5 +5700,23 @@ must_pass_in_stack_var_size_or_pad (machine_mode mode, const_tree type)
   return false;
 }
 
+/* Return true if FIELD is the C++17 empty base field that should
+   be ignored for ABI calling convention decisions in order to
+   maintain ABI compatibility between C++14 and earlier, which doesn't
+   add this FIELD to classes with empty bases, and C++17 and later
+   which does.  */
+
+bool
+cxx17_empty_base_field_p (const_tree field)
+{
+  return (TREE_CODE (field) == FIELD_DECL
+	  && DECL_ARTIFICIAL (field)
+	  && RECORD_OR_UNION_TYPE_P (TREE_TYPE (field))
+	  && DECL_SIZE (field)
+	  && integer_zerop (DECL_SIZE (field))
+	  && TYPE_SIZE (TREE_TYPE (field))
+	  && !integer_zerop (TYPE_SIZE (TREE_TYPE (field))));
+}
+
 /* Tell the garbage collector about GTY markers in this source file.  */
 #include "gt-calls.h"
diff --git a/gcc/calls.h b/gcc/calls.h
index df5817fe7..eaefef59f 100644
--- a/gcc/calls.h
+++ b/gcc/calls.h
@@ -39,5 +39,6 @@ extern bool reference_callee_copied (CUMULATIVE_ARGS *, machine_mode,
 				     tree, bool);
 extern void maybe_warn_alloc_args_overflow (tree, tree, tree[2], int[2]);
 extern bool get_size_range (tree, tree[2]);
+extern bool cxx17_empty_base_field_p (const_tree);
 
 #endif // GCC_CALLS_H
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index 4e94be3b0..8b9c2f116 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -10526,9 +10526,19 @@ aarch64_conditional_register_usage (void)
    If *MODEP is VOIDmode, then set it to the first valid floating point
    type.  If a non-floating point type is found, or if a floating point
    type that doesn't match a non-VOIDmode *MODEP is found, then return -1,
-   otherwise return the count in the sub-tree.  */
+   otherwise return the count in the sub-tree.
+
+   The AVOID_CXX17_EMPTY_BASE argument is to allow the caller to check whether
+   this function has changed its behavior after the fix for PR94384 -- this fix
+   is to avoid artificial fields in empty base classes.
+   When called with this argument as a NULL pointer this function does not
+   avoid the artificial fields -- this is useful to check whether the function
+   returns something different after the fix.
+   When called pointing at a value, this function avoids such artificial fields
+   and sets the value to TRUE when one of these fields has been set.  */
 static int
-aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)
+aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep,
+			 bool *avoid_cxx17_empty_base)
 {
   machine_mode mode;
   HOST_WIDE_INT size;
@@ -10601,7 +10611,8 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)
 	    || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)
 	  return -1;
 
-	count = aapcs_vfp_sub_candidate (TREE_TYPE (type), modep);
+	count = aapcs_vfp_sub_candidate (TREE_TYPE (type), modep,
+					 avoid_cxx17_empty_base);
 	if (count == -1
 	    || !index
 	    || !TYPE_MAX_VALUE (index)
@@ -10638,7 +10649,18 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)
 	    if (TREE_CODE (field) != FIELD_DECL)
 	      continue;
 
-	    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep);
+	    /* Ignore C++17 empty base fields, while their type indicates
+	       they do contain padding, they have zero size and thus don't
+	       contain any padding.  */
+	    if (cxx17_empty_base_field_p (field)
+		&& avoid_cxx17_empty_base)
+	      {
+		*avoid_cxx17_empty_base = true;
+		continue;
+	      }
+
+	    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep,
+						 avoid_cxx17_empty_base);
 	    if (sub_count < 0)
 	      return -1;
 	    count += sub_count;
@@ -10670,7 +10692,8 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)
 	    if (TREE_CODE (field) != FIELD_DECL)
 	      continue;
 
-	    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep);
+	    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep,
+						 avoid_cxx17_empty_base);
 	    if (sub_count < 0)
 	      return -1;
 	    count = count > sub_count ? count : sub_count;
@@ -10780,10 +10803,26 @@ aarch64_vfp_is_call_or_return_candidate (machine_mode mode,
     }
   else if (type && composite_p)
     {
-      int ag_count = aapcs_vfp_sub_candidate (type, &new_mode);
-
+      bool avoided = false;
+      int ag_count = aapcs_vfp_sub_candidate (type, &new_mode, &avoided);
       if (ag_count > 0 && ag_count <= HA_MAX_NUM_FLDS)
 	{
+	  static unsigned last_reported_type_uid;
+	  unsigned uid = TYPE_UID (TYPE_MAIN_VARIANT (type));
+	  int alt;
+	  if (warn_psabi
+	      && avoided
+	      && uid != last_reported_type_uid
+	      && ((alt = aapcs_vfp_sub_candidate (type, &new_mode, NULL))
+		  != ag_count))
+	    {
+	      gcc_assert (alt == -1);
+	      last_reported_type_uid = uid;
+	      inform (input_location, "parameter passing for argument of type "
+		      "%qT when C++17 is enabled changed to match C++14 "
+		      "in GCC 10.1", type);
+	    }
+
 	  if (is_ha != NULL) *is_ha = true;
 	  *count = ag_count;
 	}
