diff --git a/Makefile.in b/Makefile.in
index 4b9913915..52643f440 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -1573,7 +1573,6 @@ install-info-target: maybe-install-info-target-libgo
 install-info-target: maybe-install-info-target-libtermcap
 install-info-target: maybe-install-info-target-winsup
 install-info-target: maybe-install-info-target-libgloss
-install-info-target: maybe-install-info-target-libffi
 install-info-target: maybe-install-info-target-libjava
 install-info-target: maybe-install-info-target-zlib
 install-info-target: maybe-install-info-target-boehm-gc
@@ -1651,7 +1650,6 @@ install-pdf-target: maybe-install-pdf-target-libgo
 install-pdf-target: maybe-install-pdf-target-libtermcap
 install-pdf-target: maybe-install-pdf-target-winsup
 install-pdf-target: maybe-install-pdf-target-libgloss
-install-pdf-target: maybe-install-pdf-target-libffi
 install-pdf-target: maybe-install-pdf-target-libjava
 install-pdf-target: maybe-install-pdf-target-zlib
 install-pdf-target: maybe-install-pdf-target-boehm-gc
@@ -1729,7 +1727,6 @@ install-html-target: maybe-install-html-target-libgo
 install-html-target: maybe-install-html-target-libtermcap
 install-html-target: maybe-install-html-target-winsup
 install-html-target: maybe-install-html-target-libgloss
-install-html-target: maybe-install-html-target-libffi
 install-html-target: maybe-install-html-target-libjava
 install-html-target: maybe-install-html-target-zlib
 install-html-target: maybe-install-html-target-boehm-gc
@@ -1807,7 +1804,6 @@ installcheck-target: maybe-installcheck-target-libgo
 installcheck-target: maybe-installcheck-target-libtermcap
 installcheck-target: maybe-installcheck-target-winsup
 installcheck-target: maybe-installcheck-target-libgloss
-installcheck-target: maybe-installcheck-target-libffi
 installcheck-target: maybe-installcheck-target-libjava
 installcheck-target: maybe-installcheck-target-zlib
 installcheck-target: maybe-installcheck-target-boehm-gc
@@ -2402,7 +2398,6 @@ install-target:  \
     maybe-install-target-libtermcap \
     maybe-install-target-winsup \
     maybe-install-target-libgloss \
-    maybe-install-target-libffi \
     maybe-install-target-libjava \
     maybe-install-target-zlib \
     maybe-install-target-boehm-gc \
@@ -2500,7 +2495,6 @@ install-strip-target:  \
     maybe-install-strip-target-libtermcap \
     maybe-install-strip-target-winsup \
     maybe-install-strip-target-libgloss \
-    maybe-install-strip-target-libffi \
     maybe-install-strip-target-libjava \
     maybe-install-strip-target-zlib \
     maybe-install-strip-target-boehm-gc \
diff --git a/config.rpath b/config.rpath
index 4dea75957..863ce0dcc 100755
--- a/config.rpath
+++ b/config.rpath
@@ -438,7 +438,7 @@ case "$host_os" in
   bsdi4*)
     ;;
   cygwin* | mingw* | pw32*)
-    shrext=.dll
+    shrext=.dll.a
     ;;
   darwin* | rhapsody*)
     shrext=.dylib
diff --git a/gcc/ada/a-intnam-cygwin.ads b/gcc/ada/a-intnam-cygwin.ads
new file mode 100644
index 000000000..eb516d5f4
--- /dev/null
+++ b/gcc/ada/a-intnam-cygwin.ads
@@ -0,0 +1,168 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   A D A . I N T E R R U P T S . N A M E S                --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--          Copyright (C) 1991-2005, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNARL; see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is a Cygwin version of this package but really it's a copy of the
+--  Linux version, so the below comments are probably irrelevant:
+
+--  The following signals are reserved by the run time (FSU threads):
+
+--  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,
+--  SIGALRM, SIGVTALRM, SIGUNUSED, SIGSTOP, SIGKILL
+
+--  The following signals are reserved by the run time (LinuxThreads):
+
+--  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,
+--  SIGUSR1, SIGUSR2, SIGVTALRM, SIGUNUSED, SIGSTOP, SIGKILL
+
+--  The pragma Unreserve_All_Interrupts affects the following signal(s):
+
+--  SIGINT: made available for Ada handler
+
+--  This target-dependent package spec contains names of interrupts
+--  supported by the local system.
+
+with System.OS_Interface;
+--  used for names of interrupts
+
+package Ada.Interrupts.Names is
+
+   --  Beware that the mapping of names to signals may be many-to-one. There
+   --  may be aliases. Also, for all signal names that are not supported on the
+   --  current system the value of the corresponding constant will be zero.
+
+   SIGHUP : constant Interrupt_ID :=
+     System.OS_Interface.SIGHUP;      --  hangup
+
+   SIGINT : constant Interrupt_ID :=
+     System.OS_Interface.SIGINT;      --  interrupt (rubout)
+
+   SIGQUIT : constant Interrupt_ID :=
+     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)
+
+   SIGILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)
+
+   SIGTRAP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)
+
+   SIGIOT : constant Interrupt_ID :=
+     System.OS_Interface.SIGIOT;      --  IOT instruction
+
+   SIGABRT : constant Interrupt_ID := --  used by abort,
+     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future
+
+   SIGFPE : constant Interrupt_ID :=
+     System.OS_Interface.SIGFPE;      --  floating point exception
+
+   SIGKILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)
+
+   SIGBUS : constant Interrupt_ID :=
+     System.OS_Interface.SIGBUS;      --  bus error
+
+   SIGSEGV : constant Interrupt_ID :=
+     System.OS_Interface.SIGSEGV;     --  segmentation violation
+
+   SIGPIPE : constant Interrupt_ID := --  write on a pipe with
+     System.OS_Interface.SIGPIPE;     --  no one to read it
+
+   SIGALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGALRM;     --  alarm clock
+
+   SIGTERM : constant Interrupt_ID :=
+     System.OS_Interface.SIGTERM;     --  software termination signal from kill
+
+   SIGUSR1 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR1;     --  user defined signal 1
+
+   SIGUSR2 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR2;     --  user defined signal 2
+
+   SIGCLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCLD;      --  child status change
+
+   SIGCHLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD
+
+   SIGWINCH : constant Interrupt_ID :=
+     System.OS_Interface.SIGWINCH;    --  window size change
+
+   SIGURG : constant Interrupt_ID :=
+     System.OS_Interface.SIGURG;      --  urgent condition on IO channel
+
+   SIGPOLL : constant Interrupt_ID :=
+     System.OS_Interface.SIGPOLL;     --  pollable event occurred
+
+   SIGIO : constant Interrupt_ID :=   --  input/output possible,
+     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)
+
+   SIGSTOP : constant Interrupt_ID :=
+     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)
+
+   SIGTSTP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTSTP;     --  user stop requested from tty
+
+   SIGCONT : constant Interrupt_ID :=
+     System.OS_Interface.SIGCONT;     --  stopped process has been continued
+
+   SIGTTIN : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTIN;     --  background tty read attempted
+
+   SIGTTOU : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTOU;     --  background tty write attempted
+
+   SIGVTALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGVTALRM;   --  virtual timer expired
+
+   SIGPROF : constant Interrupt_ID :=
+     System.OS_Interface.SIGPROF;     --  profiling timer expired
+
+   SIGXCPU : constant Interrupt_ID :=
+     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded
+
+   SIGXFSZ : constant Interrupt_ID :=
+     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded
+
+   SIGUNUSED : constant Interrupt_ID :=
+     System.OS_Interface.SIGUNUSED;     --  unused signal
+
+   SIGSTKFLT : constant Interrupt_ID :=
+     System.OS_Interface.SIGSTKFLT;     --  stack fault on coprocessor
+
+   SIGLOST : constant Interrupt_ID :=
+     System.OS_Interface.SIGLOST;       --  Linux alias for SIGIO
+
+   SIGPWR : constant Interrupt_ID :=
+     System.OS_Interface.SIGPWR;        --  Power failure
+
+end Ada.Interrupts.Names;
diff --git a/gcc/ada/g-soccon-cygwin.ads b/gcc/ada/g-soccon-cygwin.ads
new file mode 100644
index 000000000..f0f94fd99
--- /dev/null
+++ b/gcc/ada/g-soccon-cygwin.ads
@@ -0,0 +1,196 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--               G N A T . S O C K E T S . C O N S T A N T S                --
+--                                                                          --
+--                                 S p e c                                  --
+--                                                                          --
+--          Copyright (C) 2000-2007, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This package provides target dependent definitions of constant for use
+--  by the GNAT.Sockets package (g-socket.ads). This package should not be
+--  directly with'ed by an applications program.
+
+--  This is the version for Cygwin
+--  This file is generated automatically, do not modify it by hand! Instead,
+--  make changes to gen-soccon.c and re-run it on each target.
+
+package GNAT.Sockets.Constants is
+
+   --------------
+   -- Families --
+   --------------
+
+   AF_INET            : constant :=           2; --  IPv4 address family
+   AF_INET6           : constant :=          23; --  IPv6 address family
+
+   -----------
+   -- Modes --
+   -----------
+
+   SOCK_STREAM        : constant :=           1; --  Stream socket
+   SOCK_DGRAM         : constant :=           2; --  Datagram socket
+
+   -------------------
+   -- Socket errors --
+   -------------------
+
+   EACCES             : constant :=          13; --  Permission denied
+   EADDRINUSE         : constant :=         112; --  Address already in use
+   EADDRNOTAVAIL      : constant :=         125; --  Cannot assign address
+   EAFNOSUPPORT       : constant :=         106; --  Addr family not supported
+   EALREADY           : constant :=         120; --  Operation in progress
+   EBADF              : constant :=           9; --  Bad file descriptor
+   ECONNABORTED       : constant :=         113; --  Connection aborted
+   ECONNREFUSED       : constant :=         111; --  Connection refused
+   ECONNRESET         : constant :=         104; --  Connection reset by peer
+   EDESTADDRREQ       : constant :=         121; --  Destination addr required
+   EFAULT             : constant :=          14; --  Bad address
+   EHOSTDOWN          : constant :=         117; --  Host is down
+   EHOSTUNREACH       : constant :=         118; --  No route to host
+   EINPROGRESS        : constant :=         119; --  Operation now in progress
+   EINTR              : constant :=           4; --  Interrupted system call
+   EINVAL             : constant :=          22; --  Invalid argument
+   EIO                : constant :=           5; --  Input output error
+   EISCONN            : constant :=         127; --  Socket already connected
+   ELOOP              : constant :=          92; --  Too many symbolic lynks
+   EMFILE             : constant :=          24; --  Too many open files
+   EMSGSIZE           : constant :=         122; --  Message too long
+   ENAMETOOLONG       : constant :=          91; --  Name too long
+   ENETDOWN           : constant :=         115; --  Network is down
+   ENETRESET          : constant :=         126; --  Disconn. on network reset
+   ENETUNREACH        : constant :=         114; --  Network is unreachable
+   ENOBUFS            : constant :=         105; --  No buffer space available
+   ENOPROTOOPT        : constant :=         109; --  Protocol not available
+   ENOTCONN           : constant :=         128; --  Socket not connected
+   ENOTSOCK           : constant :=         108; --  Operation on non socket
+   EOPNOTSUPP         : constant :=          95; --  Operation not supported
+   EPFNOSUPPORT       : constant :=          96; --  Unknown protocol family
+   EPROTONOSUPPORT    : constant :=         123; --  Unknown protocol
+   EPROTOTYPE         : constant :=         107; --  Unknown protocol type
+   ESHUTDOWN          : constant :=         110; --  Cannot send once shutdown
+   ESOCKTNOSUPPORT    : constant :=         124; --  Socket type not supported
+   ETIMEDOUT          : constant :=         116; --  Connection timed out
+   ETOOMANYREFS       : constant :=         129; --  Too many references
+   EWOULDBLOCK        : constant :=          11; --  Operation would block
+
+   -----------------
+   -- Host errors --
+   -----------------
+
+   HOST_NOT_FOUND     : constant :=           1; --  Unknown host
+   TRY_AGAIN          : constant :=           2; --  Host name lookup failure
+   NO_DATA            : constant :=           4; --  No data record for name
+   NO_RECOVERY        : constant :=           3; --  Non recoverable errors
+
+   -------------------
+   -- Control flags --
+   -------------------
+
+   FIONBIO            : constant := -2147195266; --  Set/clear non-blocking io
+   FIONREAD           : constant :=  1074030207; --  How many bytes to read
+
+   --------------------
+   -- Shutdown modes --
+   --------------------
+
+   SHUT_RD            : constant :=           0; --  No more recv
+   SHUT_WR            : constant :=           1; --  No more send
+   SHUT_RDWR          : constant :=           2; --  No more recv/send
+
+   ---------------------
+   -- Protocol levels --
+   ---------------------
+
+   SOL_SOCKET         : constant :=       65535; --  Options for socket level
+   IPPROTO_IP         : constant :=           0; --  Dummy protocol for IP
+   IPPROTO_UDP        : constant :=          17; --  UDP
+   IPPROTO_TCP        : constant :=           6; --  TCP
+
+   -------------------
+   -- Request flags --
+   -------------------
+
+   MSG_OOB            : constant :=           1; --  Process out-of-band data
+   MSG_PEEK           : constant :=           2; --  Peek at incoming data
+   MSG_EOR            : constant :=          -1; --  Send end of record
+   MSG_WAITALL        : constant :=           8; --  Wait for full reception
+   MSG_NOSIGNAL       : constant :=          32; --  No SIGPIPE on send
+   MSG_Forced_Flags   : constant :=           0;
+   --  Flags set on all send(2) calls
+
+   --------------------
+   -- Socket options --
+   --------------------
+
+   TCP_NODELAY        : constant :=           1; --  Do not coalesce packets
+   SO_REUSEADDR       : constant :=           4; --  Bind reuse local address
+   SO_REUSEPORT       : constant :=          -1; --  Bind reuse port number
+   SO_KEEPALIVE       : constant :=           8; --  Enable keep-alive msgs
+   SO_LINGER          : constant :=         128; --  Defer close to flush data
+   SO_BROADCAST       : constant :=          32; --  Can send broadcast msgs
+   SO_SNDBUF          : constant :=        4097; --  Set/get send buffer size
+   SO_RCVBUF          : constant :=        4098; --  Set/get recv buffer size
+   SO_SNDTIMEO        : constant :=        4101; --  Emission timeout
+   SO_RCVTIMEO        : constant :=        4102; --  Reception timeout
+   SO_ERROR           : constant :=        4103; --  Get/clear error status
+   IP_MULTICAST_IF    : constant :=           9; --  Set/get mcast interface
+   IP_MULTICAST_TTL   : constant :=          10; --  Set/get multicast TTL
+   IP_MULTICAST_LOOP  : constant :=          11; --  Set/get mcast loopback
+   IP_ADD_MEMBERSHIP  : constant :=          12; --  Join a multicast group
+   IP_DROP_MEMBERSHIP : constant :=          13; --  Leave a multicast group
+   IP_PKTINFO         : constant :=          19; --  Get datagram info
+
+   -------------------
+   -- System limits --
+   -------------------
+
+   IOV_MAX            : constant :=        1024; --  Maximum writev iovcnt
+
+   ----------------------
+   -- Type definitions --
+   ----------------------
+
+   --  Sizes (in bytes) of the components of struct timeval
+
+   SIZEOF_tv_sec      : constant :=           4; --  tv_sec
+   SIZEOF_tv_usec     : constant :=           4; --  tv_usec
+
+   ----------------------------------------
+   -- Properties of supported interfaces --
+   ----------------------------------------
+
+   Need_Netdb_Buffer  : constant :=           0; --  Need buffer for Netdb ops
+
+   ----------------------
+   -- Additional flags --
+   ----------------------
+
+   Thread_Blocking_IO : constant Boolean := True;
+   --  Set False for contexts where socket i/o are process blocking
+
+end GNAT.Sockets.Constants;
diff --git a/gcc/ada/indepsw-cygwin.adb b/gcc/ada/indepsw-cygwin.adb
new file mode 100644
index 000000000..4e324838e
--- /dev/null
+++ b/gcc/ada/indepsw-cygwin.adb
@@ -0,0 +1,69 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                              I N D E P S W                               --
+--                                                                          --
+--                                 B o d y                                  --
+--                            (Windows version)                             --
+--                                                                          --
+--            Copyright (C) 2004 Free Software Foundation, Inc.             --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the Windows version
+
+package body Indepsw is
+
+   Map_Switch : aliased constant String := "-Wl,-Map,";
+
+   -------------
+   -- Convert --
+   -------------
+
+   procedure Convert
+     (Switch   : Switch_Kind;
+      Argument : String;
+      To       : out String_List_Access)
+   is
+   begin
+      case Switch is
+         when Map_File =>
+            To := new Argument_List'(1 => new String'(Map_Switch & Argument));
+      end case;
+   end Convert;
+
+   ------------------
+   -- Is_Supported --
+   ------------------
+
+   function Is_Supported (Switch : Switch_Kind) return Boolean is
+   begin
+      case Switch is
+         when Map_File =>
+            return True;
+      end case;
+   end Is_Supported;
+
+end Indepsw;
diff --git a/gcc/ada/initialize.c b/gcc/ada/initialize.c
index 783f8af5b..96fa03a60 100644
--- a/gcc/ada/initialize.c
+++ b/gcc/ada/initialize.c
@@ -347,6 +347,39 @@ __gnat_initialize (void *eh ATTRIBUTE_UNUSED)
 {
   __main ();
 }
+#elif defined (__CYGWIN__)
+
+/***************************************/
+/* __gnat_initialize (Cygwin Version) */
+/***************************************/
+
+extern void __main (void);
+
+void
+__gnat_initialize (void *eh ATTRIBUTE_UNUSED)
+{
+#ifdef IN_RTS
+  /* We must call __main to run the static ctors, or DW2 EH, amongst
+     other things, will fail.  */
+  __main ();
+#endif
+   /* Initialize floating-point coprocessor. This call is needed because
+      the MS libraries default to 64-bit precision instead of 80-bit
+      precision, and we require the full precision for proper operation,
+      given that we have set Max_Digits etc with this in mind */
+   __gnat_init_float ();
+
+   /* Note that we do not activate this for the compiler itself to avoid a
+      bootstrap path problem.  Older version of gnatbind will generate a call
+      to __gnat_initialize() without argument. Therefore we cannot use eh in
+      this case.  It will be possible to remove the following #ifdef at some
+      point.  */
+#ifdef IN_RTS
+   /* Install the Structured Exception handler.  */
+   if (eh)
+     __gnat_install_SEH_handler (eh);
+#endif
+}
 
 #else
 
diff --git a/gcc/ada/mlib-tgt-cygwin.adb b/gcc/ada/mlib-tgt-cygwin.adb
new file mode 100644
index 000000000..c60fa0f92
--- /dev/null
+++ b/gcc/ada/mlib-tgt-cygwin.adb
@@ -0,0 +1,160 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                    M L I B . T G T . S P E C I F I C                     --
+--                            (Cygwin  Version)                             --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--          Copyright (C) 2002-2009, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --
+-- http://www.gnu.org/licenses for a complete copy of the license.          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the Windows version of the body. Works only with GCC versions
+--  supporting the "-shared" option.
+
+with Opt;
+with Output; use Output;
+
+with MLib.Fil;
+with MLib.Utl;
+
+package body MLib.Tgt.Specific is
+
+   package Files renames MLib.Fil;
+   package Tools renames MLib.Utl;
+
+   --  Non default subprograms
+
+   procedure Build_Dynamic_Library
+     (Ofiles       : Argument_List;
+      Options      : Argument_List;
+      Interfaces   : Argument_List;
+      Lib_Filename : String;
+      Lib_Dir      : String;
+      Symbol_Data  : Symbol_Record;
+      Driver_Name  : Name_Id := No_Name;
+      Lib_Version  : String  := "";
+      Auto_Init    : Boolean := False);
+
+   function DLL_Ext return String;
+
+   function DLL_Prefix return String;
+
+   function Is_Archive_Ext (Ext : String) return Boolean;
+
+   function Library_Major_Minor_Id_Supported return Boolean;
+
+   function PIC_Option return String;
+
+   No_Argument_List : constant String_List := (1 .. 0 => null);
+   --  Used as value of parameter Options or Options2 in calls to Gcc
+
+   ---------------------------
+   -- Build_Dynamic_Library --
+   ---------------------------
+
+   procedure Build_Dynamic_Library
+     (Ofiles       : Argument_List;
+      Options      : Argument_List;
+      Interfaces   : Argument_List;
+      Lib_Filename : String;
+      Lib_Dir      : String;
+      Symbol_Data  : Symbol_Record;
+      Driver_Name  : Name_Id := No_Name;
+      Lib_Version  : String  := "";
+      Auto_Init    : Boolean := False)
+   is
+      pragma Unreferenced (Symbol_Data);
+      pragma Unreferenced (Interfaces);
+      pragma Unreferenced (Lib_Version);
+      pragma Unreferenced (Auto_Init);
+
+      Lib_File : constant String :=
+                   Lib_Dir & Directory_Separator &
+                   DLL_Prefix & Files.Append_To (Lib_Filename, DLL_Ext);
+
+   --  Start of processing for Build_Dynamic_Library
+
+   begin
+      if Opt.Verbose_Mode then
+         Write_Str ("building relocatable shared library ");
+         Write_Line (Lib_File);
+      end if;
+
+      Tools.Gcc
+        (Output_File => Lib_File,
+         Objects     => Ofiles,
+         Options     => No_Argument_List,
+         Options_2   => Options,
+         Driver_Name => Driver_Name);
+   end Build_Dynamic_Library;
+
+   -------------
+   -- DLL_Ext --
+   -------------
+
+   function DLL_Ext return String is
+   begin
+      return "dll";
+   end DLL_Ext;
+
+   ----------------
+   -- DLL_Prefix --
+   ----------------
+
+   function DLL_Prefix return String is
+   begin
+      return "cyg";
+   end DLL_Prefix;
+
+   --------------------
+   -- Is_Archive_Ext --
+   --------------------
+
+   function Is_Archive_Ext (Ext : String) return Boolean is
+   begin
+      return Ext = ".a" or else Ext = ".dll";
+   end Is_Archive_Ext;
+
+   --------------------------------------
+   -- Library_Major_Minor_Id_Supported --
+   --------------------------------------
+
+   function Library_Major_Minor_Id_Supported return Boolean is
+   begin
+      return False;
+   end Library_Major_Minor_Id_Supported;
+
+   ----------------
+   -- PIC_Option --
+   ----------------
+
+   function PIC_Option return String is
+   begin
+      return "";
+   end PIC_Option;
+
+begin
+   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;
+   DLL_Ext_Ptr               := DLL_Ext'Access;
+   DLL_Prefix_Ptr            := DLL_Prefix'Access;
+   Is_Archive_Ext_Ptr        := Is_Archive_Ext'Access;
+   PIC_Option_Ptr            := PIC_Option'Access;
+   Library_Major_Minor_Id_Supported_Ptr :=
+                                Library_Major_Minor_Id_Supported'Access;
+end MLib.Tgt.Specific;
diff --git a/gcc/ada/s-gloloc-cygwin.adb b/gcc/ada/s-gloloc-cygwin.adb
new file mode 100644
index 000000000..e30a9b8de
--- /dev/null
+++ b/gcc/ada/s-gloloc-cygwin.adb
@@ -0,0 +1,113 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                  S Y S T E M . G L O B A L _ L O C K S                   --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 1999-2007, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This implementation is specific to NT
+
+with System.Task_Lock;
+
+with Interfaces.C.Strings;
+with System.OS_Interface;
+
+package body System.Global_Locks is
+
+   package TSL renames System.Task_Lock;
+   package OSI renames System.OS_Interface;
+   package ICS renames Interfaces.C.Strings;
+
+   subtype Lock_File_Entry is OSI.HANDLE;
+
+   Last_Lock  : Lock_Type := Null_Lock;
+   Lock_Table : array (Lock_Type range 1 .. 15) of Lock_File_Entry;
+
+   -----------------
+   -- Create_Lock --
+   -----------------
+
+   procedure Create_Lock
+     (Lock : out Lock_Type;
+      Name : String)
+   is
+      L : Lock_Type;
+
+   begin
+      TSL.Lock;
+      Last_Lock := Last_Lock + 1;
+      L := Last_Lock;
+      TSL.Unlock;
+
+      if L > Lock_Table'Last then
+         raise Lock_Error;
+      end if;
+
+      Lock_Table (L) :=
+        OSI.CreateMutex (null, OSI.BOOL (False), ICS.New_String (Name));
+      Lock := L;
+   end Create_Lock;
+
+   ------------------
+   -- Acquire_Lock --
+   ------------------
+
+   procedure Acquire_Lock
+     (Lock : in out Lock_Type)
+   is
+      use type OSI.DWORD;
+
+      Res : OSI.DWORD;
+   begin
+      Res := OSI.WaitForSingleObject (Lock_Table (Lock), OSI.Wait_Infinite);
+
+      if Res = OSI.WAIT_FAILED then
+         raise Lock_Error;
+      end if;
+   end Acquire_Lock;
+
+   ------------------
+   -- Release_Lock --
+   ------------------
+
+   procedure Release_Lock
+     (Lock : in out Lock_Type)
+   is
+      use type OSI.BOOL;
+
+      Res : OSI.BOOL;
+   begin
+      Res := OSI.ReleaseMutex (Lock_Table (Lock));
+
+      if Res = OSI.False then
+         raise Lock_Error;
+      end if;
+   end Release_Lock;
+
+end System.Global_Locks;
diff --git a/gcc/ada/s-osinte-cygwin.ads b/gcc/ada/s-osinte-cygwin.ads
new file mode 100644
index 000000000..bfb34b968
--- /dev/null
+++ b/gcc/ada/s-osinte-cygwin.ads
@@ -0,0 +1,952 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--             Copyright (C) 1991-1994, Florida State University            --
+--          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNARL; see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is a GNU/Linux (GNU/LinuxThreads) version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by children of System.
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Interfaces.C;
+with Interfaces.C.Strings;
+with Ada.Unchecked_Conversion;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   subtype int            is Interfaces.C.int;
+   subtype char           is Interfaces.C.char;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function errno return int;
+   pragma Import (C, errno, "__get_errno");
+
+   EAGAIN    : constant := 11;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   EPERM     : constant := 1;
+   ETIMEDOUT : constant := 110;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 63;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 7; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGUSR1    : constant := 10; --  user defined signal 1
+   SIGUSR2    : constant := 12; --  user defined signal 2
+   SIGCLD     : constant := 17; --  alias for SIGCHLD
+   SIGCHLD    : constant := 17; --  child status change
+   SIGPWR     : constant := 30; --  power-fail restart
+   SIGWINCH   : constant := 28; --  window size change
+   SIGURG     : constant := 23; --  urgent condition on IO channel
+   SIGPOLL    : constant := 29; --  pollable event occurred
+   SIGIO      : constant := 29; --  I/O now possible (4.2 BSD)
+   SIGLOST    : constant := 29; --  File lock lost
+   SIGSTOP    : constant := 19; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 20; --  user stop requested from tty
+   SIGCONT    : constant := 18; --  stopped process has been continued
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGUNUSED  : constant := 31; --  unused signal (GNU/Linux)
+   SIGSTKFLT  : constant := 16; --  coprocessor stack fault (Linux)
+   SIGLTHRRES : constant := 32; --  GNU/LinuxThreads restart signal
+   SIGLTHRCAN : constant := 33; --  GNU/LinuxThreads cancel signal
+   SIGLTHRDBG : constant := 34; --  GNU/LinuxThreads debugger signal
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   Unmasked    : constant Signal_Set := (
+      SIGTRAP,
+      --  To enable debugging on multithreaded applications, mark SIGTRAP to
+      --  be kept unmasked.
+
+      SIGBUS,
+
+      SIGTTIN, SIGTTOU, SIGTSTP,
+      --  Keep these three signals unmasked so that background processes
+      --  and IO behaves as normal "C" applications
+
+      SIGPROF,
+      --  To avoid confusing the profiler
+
+      SIGKILL, SIGSTOP,
+      --  These two signals actually cannot be masked;
+      --  POSIX simply won't allow it.
+
+      SIGLTHRRES, SIGLTHRCAN, SIGLTHRDBG);
+      --  These three signals are used by GNU/LinuxThreads starting from
+      --  glibc 2.1 (future 2.2).
+
+   Reserved    : constant Signal_Set :=
+   --  I am not sure why the following two signals are reserved.
+   --  I guess they are not supported by this version of GNU/Linux.
+     (SIGVTALRM, SIGUNUSED);
+
+   type sigset_t is private;
+
+   function sigaddset (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigaddset, "sigaddset");
+
+   function sigdelset (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigdelset, "sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "sigfillset");
+
+   function sigismember (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigismember, "sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "sigemptyset");
+
+   type union_type_3 is new String (1 .. 116);
+   type siginfo_t is record
+      si_signo : int;
+      si_code  : int;
+      si_errno : int;
+      X_data   : union_type_3;
+   end record;
+   pragma Convention (C, siginfo_t);
+
+   type struct_sigaction is record
+      sa_handler   : System.Address;
+      sa_mask      : sigset_t;
+      sa_flags     : unsigned_long;
+      sa_restorer  : System.Address;
+   end record;
+   pragma Convention (C, struct_sigaction);
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   type Machine_State is record
+      eip : unsigned_long;
+      ebx : unsigned_long;
+      esp : unsigned_long;
+      ebp : unsigned_long;
+      esi : unsigned_long;
+      edi : unsigned_long;
+   end record;
+   type Machine_State_Ptr is access all Machine_State;
+
+   SA_SIGINFO  : constant := 16#04#;
+
+   SIG_BLOCK   : constant := 0;
+   SIG_UNBLOCK : constant := 1;
+   SIG_SETMASK : constant := 2;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   type timespec is private;
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timeval is private;
+
+   function To_Duration (TV : struct_timeval) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timeval (D : Duration) return struct_timeval;
+   pragma Inline (To_Timeval);
+
+   function gettimeofday
+     (tv : access struct_timeval;
+      tz : System.Address := System.Null_Address) return int;
+   pragma Import (C, gettimeofday, "gettimeofday");
+
+   function sysconf (name : int) return long;
+   pragma Import (C, sysconf);
+
+   SC_CLK_TCK          : constant := 2;
+   SC_NPROCESSORS_ONLN : constant := 84;
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_OTHER : constant := 0;
+   SCHED_FIFO  : constant := 1;
+   SCHED_RR    : constant := 2;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t is new unsigned_long;
+   subtype Thread_Id        is pthread_t;
+
+   function To_pthread_t is new Ada.Unchecked_Conversion
+     (unsigned_long, pthread_t);
+
+   type pthread_mutex_t     is limited private;
+   type pthread_cond_t      is limited private;
+   type pthread_attr_t      is limited private;
+   type pthread_mutexattr_t is limited private;
+   type pthread_condattr_t  is limited private;
+   type pthread_key_t       is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+
+   -----------
+   -- Stack --
+   -----------
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  This is a dummy procedure to share some GNULLI files
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   procedure pthread_init;
+   pragma Inline (pthread_init);
+   --  This is a dummy procedure to share some GNULLI files
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait (set : access sigset_t; sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill (thread : pthread_t; sig : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   type struct_sched_param is record
+      sched_priority : int;  --  scheduling priority
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import
+     (C, pthread_attr_setschedpolicy, "pthread_attr_setschedpolicy");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "sched_yield");
+
+   ---------------------------
+   -- P1003.1c - Section 16 --
+   ---------------------------
+
+   function pthread_attr_init
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   CPU_SETSIZE : constant := 1_024;
+
+   type bit_field is array (1 .. CPU_SETSIZE) of Boolean;
+   for bit_field'Size use CPU_SETSIZE;
+   pragma Pack (bit_field);
+   pragma Convention (C, bit_field);
+
+   type cpu_set_t is record
+      bits : bit_field;
+   end record;
+   pragma Convention (C, cpu_set_t);
+
+   function pthread_setaffinity_np
+     (thread     : pthread_t;
+      cpusetsize : size_t;
+      cpuset     : access cpu_set_t) return int;
+   pragma Import (C, pthread_setaffinity_np, "__gnat_pthread_setaffinity_np");
+
+   -------------------
+   -- Win32 compat  --
+   -------------------
+
+   -------------------
+   -- General Types --
+   -------------------
+
+   type DWORD is new Interfaces.C.unsigned_long;
+   type WORD  is new Interfaces.C.unsigned_short;
+
+   --  The LARGE_INTEGER type is actually a fixed point type
+   --  that only can represent integers. The reason for this is
+   --  easier conversion to Duration or other fixed point types.
+   --  (See Operations.Clock)
+
+   type LARGE_INTEGER is delta 1.0 range -2.0**63 .. 2.0**63 - 1.0;
+
+   subtype PSZ   is Interfaces.C.Strings.chars_ptr;
+   subtype PCHAR is Interfaces.C.Strings.chars_ptr;
+
+   subtype PVOID is System.Address;
+
+   Null_Void : constant PVOID := System.Null_Address;
+
+   type PLONG  is access all Interfaces.C.long;
+   type PDWORD is access all DWORD;
+
+   type BOOL is new Boolean;
+   for BOOL'Size use Interfaces.C.unsigned_long'Size;
+
+   -------------------------
+   -- Handles for objects --
+   -------------------------
+
+   type HANDLE is new Interfaces.C.long;
+   type PHANDLE is access all HANDLE;
+
+   subtype Win32_Thread_Id is HANDLE;
+
+   ------------------------
+   -- System Information --
+   ------------------------
+
+   type SYSTEM_INFO is record
+      dwOemId                     : DWORD;
+      dwPageSize                  : DWORD;
+      lpMinimumApplicationAddress : PVOID;
+      lpMaximumApplicationAddress : PVOID;
+      dwActiveProcessorMask       : DWORD;
+      dwNumberOfProcessors        : DWORD;
+      dwProcessorType             : DWORD;
+      dwAllocationGranularity     : DWORD;
+      dwReserved                  : DWORD;
+   end record;
+
+   procedure GetSystemInfo (SI : access SYSTEM_INFO);
+   pragma Import (Stdcall, GetSystemInfo, "GetSystemInfo");
+
+   ---------------------
+   -- Time Management --
+   ---------------------
+
+   procedure Sleep (dwMilliseconds : DWORD);
+   pragma Import (Stdcall, Sleep, External_Name => "Sleep");
+
+   type SYSTEMTIME is record
+      wYear         : WORD;
+      wMonth        : WORD;
+      wDayOfWeek    : WORD;
+      wDay          : WORD;
+      wHour         : WORD;
+      wMinute       : WORD;
+      wSecond       : WORD;
+      wMilliseconds : WORD;
+   end record;
+
+   procedure GetSystemTime (pSystemTime : access SYSTEMTIME);
+   pragma Import (Stdcall, GetSystemTime, "GetSystemTime");
+
+   procedure GetSystemTimeAsFileTime (lpFileTime : access Long_Long_Integer);
+   pragma Import (Stdcall, GetSystemTimeAsFileTime, "GetSystemTimeAsFileTime");
+
+   function SetSystemTime (pSystemTime : access SYSTEMTIME) return BOOL;
+   pragma Import (Stdcall, SetSystemTime, "SetSystemTime");
+
+   function FileTimeToSystemTime
+     (lpFileTime   : access Long_Long_Integer;
+      lpSystemTime : access SYSTEMTIME) return BOOL;
+   pragma Import (Stdcall, FileTimeToSystemTime, "FileTimeToSystemTime");
+
+   function SystemTimeToFileTime
+     (lpSystemTime : access SYSTEMTIME;
+      lpFileTime   : access Long_Long_Integer) return BOOL;
+   pragma Import (Stdcall, SystemTimeToFileTime, "SystemTimeToFileTime");
+
+   function FileTimeToLocalFileTime
+     (lpFileTime      : access Long_Long_Integer;
+      lpLocalFileTime : access Long_Long_Integer) return BOOL;
+   pragma Import (Stdcall, FileTimeToLocalFileTime, "FileTimeToLocalFileTime");
+
+   function LocalFileTimeToFileTime
+     (lpFileTime      : access Long_Long_Integer;
+      lpLocalFileTime : access Long_Long_Integer) return BOOL;
+   pragma Import (Stdcall, LocalFileTimeToFileTime, "LocalFileTimeToFileTime");
+
+   function QueryPerformanceCounter
+     (lpPerformanceCount : access LARGE_INTEGER) return BOOL;
+   pragma Import
+     (Stdcall, QueryPerformanceCounter, "QueryPerformanceCounter");
+
+   function QueryPerformanceFrequency
+     (lpFrequency : access LARGE_INTEGER) return BOOL;
+   pragma Import
+     (Stdcall, QueryPerformanceFrequency, "QueryPerformanceFrequency");
+
+   -------------
+   -- Threads --
+   -------------
+
+--   type Win32_Thread_Body is access
+--     function (arg : System.Address) return System.Address;
+--   pragma Convention (C, Thread_Body);
+
+--   function Win32_Thread_Body_Access is new
+--     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   procedure SwitchToThread;
+   pragma Import (Stdcall, SwitchToThread, "SwitchToThread");
+
+   function GetThreadTimes
+     (hThread        : HANDLE;
+      lpCreationTime : access Long_Long_Integer;
+      lpExitTime     : access Long_Long_Integer;
+      lpKernelTime   : access Long_Long_Integer;
+      lpUserTime     : access Long_Long_Integer) return BOOL;
+   pragma Import (Stdcall, GetThreadTimes, "GetThreadTimes");
+
+   -----------------------
+   -- Critical sections --
+   -----------------------
+
+   type CRITICAL_SECTION is private;
+
+   procedure InitializeCriticalSection
+     (pCriticalSection : access CRITICAL_SECTION);
+   pragma Import
+     (Stdcall, InitializeCriticalSection, "InitializeCriticalSection");
+
+   procedure EnterCriticalSection
+     (pCriticalSection : access CRITICAL_SECTION);
+   pragma Import (Stdcall, EnterCriticalSection, "EnterCriticalSection");
+
+   procedure LeaveCriticalSection
+     (pCriticalSection : access CRITICAL_SECTION);
+   pragma Import (Stdcall, LeaveCriticalSection, "LeaveCriticalSection");
+
+   procedure DeleteCriticalSection
+     (pCriticalSection : access CRITICAL_SECTION);
+   pragma Import (Stdcall, DeleteCriticalSection, "DeleteCriticalSection");
+
+   -------------------------------------------------------------
+   -- Thread Creation, Activation, Suspension And Termination --
+   -------------------------------------------------------------
+
+   subtype ProcessorId is DWORD;
+
+   type PTHREAD_START_ROUTINE is access function
+     (pThreadParameter : PVOID) return DWORD;
+   pragma Convention (Stdcall, PTHREAD_START_ROUTINE);
+
+   function To_PTHREAD_START_ROUTINE is new
+     Ada.Unchecked_Conversion (System.Address, PTHREAD_START_ROUTINE);
+
+   type SECURITY_ATTRIBUTES is record
+      nLength              : DWORD;
+      pSecurityDescriptor  : PVOID;
+      bInheritHandle       : BOOL;
+   end record;
+
+   type PSECURITY_ATTRIBUTES is access all SECURITY_ATTRIBUTES;
+
+   function CreateThread
+     (pThreadAttributes    : PSECURITY_ATTRIBUTES;
+      dwStackSize          : DWORD;
+      pStartAddress        : PTHREAD_START_ROUTINE;
+      pParameter           : PVOID;
+      dwCreationFlags      : DWORD;
+      pThreadId            : PDWORD) return HANDLE;
+   pragma Import (Stdcall, CreateThread, "CreateThread");
+
+   function BeginThreadEx
+     (pThreadAttributes    : PSECURITY_ATTRIBUTES;
+      dwStackSize          : DWORD;
+      pStartAddress        : PTHREAD_START_ROUTINE;
+      pParameter           : PVOID;
+      dwCreationFlags      : DWORD;
+      pThreadId            : PDWORD) return HANDLE;
+   pragma Import (C, BeginThreadEx, "_beginthreadex");
+
+   Debug_Process                     : constant := 16#00000001#;
+   Debug_Only_This_Process           : constant := 16#00000002#;
+   Create_Suspended                  : constant := 16#00000004#;
+   Detached_Process                  : constant := 16#00000008#;
+   Create_New_Console                : constant := 16#00000010#;
+
+   Create_New_Process_Group          : constant := 16#00000200#;
+
+   Create_No_window                  : constant := 16#08000000#;
+
+   Profile_User                      : constant := 16#10000000#;
+   Profile_Kernel                    : constant := 16#20000000#;
+   Profile_Server                    : constant := 16#40000000#;
+
+   Stack_Size_Param_Is_A_Reservation : constant := 16#00010000#;
+
+   function GetExitCodeThread
+     (hThread   : HANDLE;
+      pExitCode : PDWORD) return BOOL;
+   pragma Import (Stdcall, GetExitCodeThread, "GetExitCodeThread");
+
+   function ResumeThread (hThread : HANDLE) return DWORD;
+   pragma Import (Stdcall, ResumeThread, "ResumeThread");
+
+   function SuspendThread (hThread : HANDLE) return DWORD;
+   pragma Import (Stdcall, SuspendThread, "SuspendThread");
+
+   procedure ExitThread (dwExitCode : DWORD);
+   pragma Import (Stdcall, ExitThread, "ExitThread");
+
+   procedure EndThreadEx (dwExitCode : DWORD);
+   pragma Import (C, EndThreadEx, "_endthreadex");
+
+   function TerminateThread
+     (hThread    : HANDLE;
+      dwExitCode : DWORD) return BOOL;
+   pragma Import (Stdcall, TerminateThread, "TerminateThread");
+
+   function GetCurrentThread return HANDLE;
+   pragma Import (Stdcall, GetCurrentThread, "GetCurrentThread");
+
+   function GetCurrentProcess return HANDLE;
+   pragma Import (Stdcall, GetCurrentProcess, "GetCurrentProcess");
+
+   function GetCurrentThreadId return DWORD;
+   pragma Import (Stdcall, GetCurrentThreadId, "GetCurrentThreadId");
+
+   function TlsAlloc return DWORD;
+   pragma Import (Stdcall, TlsAlloc, "TlsAlloc");
+
+   function TlsGetValue (dwTlsIndex : DWORD) return PVOID;
+   pragma Import (Stdcall, TlsGetValue, "TlsGetValue");
+
+   function TlsSetValue (dwTlsIndex : DWORD; pTlsValue : PVOID) return BOOL;
+   pragma Import (Stdcall, TlsSetValue, "TlsSetValue");
+
+   function TlsFree (dwTlsIndex : DWORD) return BOOL;
+   pragma Import (Stdcall, TlsFree, "TlsFree");
+
+   TLS_Nothing : constant := DWORD'Last;
+
+   procedure ExitProcess (uExitCode : Interfaces.C.unsigned);
+   pragma Import (Stdcall, ExitProcess, "ExitProcess");
+
+   function WaitForSingleObject
+     (hHandle        : HANDLE;
+      dwMilliseconds : DWORD) return DWORD;
+   pragma Import (Stdcall, WaitForSingleObject, "WaitForSingleObject");
+
+   function WaitForSingleObjectEx
+     (hHandle        : HANDLE;
+      dwMilliseconds : DWORD;
+      fAlertable     : BOOL) return DWORD;
+   pragma Import (Stdcall, WaitForSingleObjectEx, "WaitForSingleObjectEx");
+
+   function SetThreadIdealProcessor
+     (hThread          : HANDLE;
+      dwIdealProcessor : ProcessorId) return DWORD;
+   pragma Import (Stdcall, SetThreadIdealProcessor, "SetThreadIdealProcessor");
+
+   Wait_Infinite : constant := DWORD'Last;
+   WAIT_TIMEOUT  : constant := 16#0000_0102#;
+   WAIT_FAILED   : constant := 16#FFFF_FFFF#;
+
+   ------------------------------------
+   -- Semaphores, Events and Mutexes --
+   ------------------------------------
+
+   function CloseHandle (hObject : HANDLE) return BOOL;
+   pragma Import (Stdcall, CloseHandle, "CloseHandle");
+
+   function CreateSemaphore
+     (pSemaphoreAttributes : PSECURITY_ATTRIBUTES;
+      lInitialCount        : Interfaces.C.long;
+      lMaximumCount        : Interfaces.C.long;
+      pName                : PSZ) return HANDLE;
+   pragma Import (Stdcall, CreateSemaphore, "CreateSemaphoreA");
+
+   function OpenSemaphore
+     (dwDesiredAccess : DWORD;
+      bInheritHandle  : BOOL;
+      pName           : PSZ) return HANDLE;
+   pragma Import (Stdcall, OpenSemaphore, "OpenSemaphoreA");
+
+   function ReleaseSemaphore
+     (hSemaphore     : HANDLE;
+      lReleaseCount  : Interfaces.C.long;
+      pPreviousCount : PLONG) return BOOL;
+   pragma Import (Stdcall, ReleaseSemaphore, "ReleaseSemaphore");
+
+   function CreateEvent
+     (pEventAttributes : PSECURITY_ATTRIBUTES;
+      bManualReset     : BOOL;
+      bInitialState    : BOOL;
+      pName            : PSZ) return HANDLE;
+   pragma Import (Stdcall, CreateEvent, "CreateEventA");
+
+   function OpenEvent
+     (dwDesiredAccess : DWORD;
+      bInheritHandle  : BOOL;
+      pName           : PSZ) return HANDLE;
+   pragma Import (Stdcall, OpenEvent, "OpenEventA");
+
+   function SetEvent (hEvent : HANDLE) return BOOL;
+   pragma Import (Stdcall, SetEvent, "SetEvent");
+
+   function ResetEvent (hEvent : HANDLE) return BOOL;
+   pragma Import (Stdcall, ResetEvent, "ResetEvent");
+
+   function PulseEvent (hEvent : HANDLE) return BOOL;
+   pragma Import (Stdcall, PulseEvent, "PulseEvent");
+
+   function CreateMutex
+     (pMutexAttributes : PSECURITY_ATTRIBUTES;
+      bInitialOwner    : BOOL;
+      pName            : PSZ) return HANDLE;
+   pragma Import (Stdcall, CreateMutex, "CreateMutexA");
+
+   function OpenMutex
+     (dwDesiredAccess : DWORD;
+      bInheritHandle  : BOOL;
+      pName           : PSZ) return HANDLE;
+   pragma Import (Stdcall, OpenMutex, "OpenMutexA");
+
+   function ReleaseMutex (hMutex : HANDLE) return BOOL;
+   pragma Import (Stdcall, ReleaseMutex, "ReleaseMutex");
+
+   ---------------------------------------------------
+   -- Accessing properties of Threads and Processes --
+   ---------------------------------------------------
+
+   -----------------
+   --  Priorities --
+   -----------------
+
+   function SetThreadPriority
+     (hThread   : HANDLE;
+      nPriority : Interfaces.C.int) return BOOL;
+   pragma Import (Stdcall, SetThreadPriority, "SetThreadPriority");
+
+   function GetThreadPriority (hThread : HANDLE) return Interfaces.C.int;
+   pragma Import (Stdcall, GetThreadPriority, "GetThreadPriority");
+
+   function SetPriorityClass
+     (hProcess        : HANDLE;
+      dwPriorityClass : DWORD) return BOOL;
+   pragma Import (Stdcall, SetPriorityClass, "SetPriorityClass");
+
+   procedure SetThreadPriorityBoost
+     (hThread              : HANDLE;
+      DisablePriorityBoost : BOOL);
+   pragma Import (Stdcall, SetThreadPriorityBoost, "SetThreadPriorityBoost");
+
+   Normal_Priority_Class   : constant := 16#00000020#;
+   Idle_Priority_Class     : constant := 16#00000040#;
+   High_Priority_Class     : constant := 16#00000080#;
+   Realtime_Priority_Class : constant := 16#00000100#;
+
+   Thread_Priority_Idle          : constant := -15;
+   Thread_Priority_Lowest        : constant := -2;
+   Thread_Priority_Below_Normal  : constant := -1;
+   Thread_Priority_Normal        : constant := 0;
+   Thread_Priority_Above_Normal  : constant := 1;
+   Thread_Priority_Highest       : constant := 2;
+   Thread_Priority_Time_Critical : constant := 15;
+   Thread_Priority_Error_Return  : constant := Interfaces.C.long'Last;
+
+   function GetLastError return DWORD;
+   pragma Import (Stdcall, GetLastError, "GetLastError");
+
+private
+
+   type sigset_t is array (0 .. 127) of unsigned_char;
+   pragma Convention (C, sigset_t);
+   for sigset_t'Alignment use unsigned_long'Alignment;
+
+   type pid_t is new int;
+
+   type time_t is new long;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type struct_timeval is record
+      tv_sec  : time_t;
+      tv_usec : time_t;
+   end record;
+   pragma Convention (C, struct_timeval);
+
+   type pthread_attr_t is record
+      detachstate   : int;
+      schedpolicy   : int;
+      schedparam    : struct_sched_param;
+      inheritsched  : int;
+      scope         : int;
+      guardsize     : size_t;
+      stackaddr_set : int;
+      stackaddr     : System.Address;
+      stacksize     : size_t;
+   end record;
+   pragma Convention (C, pthread_attr_t);
+
+   type pthread_condattr_t is record
+      dummy : int;
+   end record;
+   pragma Convention (C, pthread_condattr_t);
+
+   type pthread_mutexattr_t is record
+      mutexkind : int;
+   end record;
+   pragma Convention (C, pthread_mutexattr_t);
+
+   type struct_pthread_fast_lock is record
+      status   : long;
+      spinlock : int;
+   end record;
+   pragma Convention (C, struct_pthread_fast_lock);
+
+   type pthread_mutex_t is record
+      m_reserved : int;
+      m_count    : int;
+      m_owner    : System.Address;
+      m_kind     : int;
+      m_lock     : struct_pthread_fast_lock;
+   end record;
+   pragma Convention (C, pthread_mutex_t);
+
+   type pthread_cond_t is array (0 .. 47) of unsigned_char;
+   pragma Convention (C, pthread_cond_t);
+
+   type pthread_key_t is new unsigned;
+
+   -------------------
+   -- Win32 private --
+   -------------------
+
+   type CRITICAL_SECTION is record
+      DebugInfo      : System.Address;
+      --  The following three fields control entering and
+      --  exiting the critical section for the resource
+      LockCount      : Long_Integer;
+      RecursionCount : Long_Integer;
+      OwningThread   : HANDLE;
+      LockSemaphore  : HANDLE;
+      Reserved       : DWORD;
+   end record;
+
+end System.OS_Interface;
diff --git a/gcc/ada/s-taprop-cygwin.adb b/gcc/ada/s-taprop-cygwin.adb
new file mode 100644
index 000000000..0d13c308a
--- /dev/null
+++ b/gcc/ada/s-taprop-cygwin.adb
@@ -0,0 +1,1339 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --
+--                                                                          --
+--     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --
+--                                                                          --
+--                                  B o d y                                 --
+--                                                                          --
+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNARL; see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is a GNU/Linux (GNU/LinuxThreads) version of this package
+
+--  This package contains all the GNULL primitives that interface directly
+--  with the underlying OS.
+
+pragma Polling (Off);
+--  Turn off polling, we do not want ATC polling to take place during
+--  tasking operations. It causes infinite loops and other problems.
+
+with Interfaces.C;
+--  used for int
+--           size_t
+
+with System.Task_Info;
+--  used for Unspecified_Task_Info
+
+with System.Tasking.Debug;
+--  used for Known_Tasks
+
+with System.Interrupt_Management;
+--  used for Keep_Unmasked
+--           Abort_Task_Interrupt
+--           Interrupt_ID
+
+with System.OS_Primitives;
+--  used for Delay_Modes
+
+with System.Soft_Links;
+--  used for Abort_Defer/Undefer
+
+--  We use System.Soft_Links instead of System.Tasking.Initialization
+--  because the later is a higher level package that we shouldn't depend on.
+--  For example when using the restricted run time, it is replaced by
+--  System.Tasking.Restricted.Stages.
+
+with System.Storage_Elements;
+with System.Stack_Checking.Operations;
+--  Used for Invalidate_Stack_Cache and Notify_Stack_Attributes;
+
+with Ada.Exceptions;
+--  used for Raise_Exception
+--           Raise_From_Signal_Handler
+--           Exception_Id
+
+with Ada.Unchecked_Conversion;
+with Ada.Unchecked_Deallocation;
+
+package body System.Task_Primitives.Operations is
+
+   package SSL renames System.Soft_Links;
+   package SC renames System.Stack_Checking.Operations;
+
+   use System.Tasking.Debug;
+   use System.Tasking;
+   use Interfaces.C;
+   use System.OS_Interface;
+   use System.Parameters;
+   use System.OS_Primitives;
+   use System.Storage_Elements;
+   use System.Task_Info;
+
+   ----------------
+   -- Local Data --
+   ----------------
+
+   --  The followings are logically constants, but need to be initialized
+   --  at run time.
+
+   Single_RTS_Lock : aliased RTS_Lock;
+   --  This is a lock to allow only one thread of control in the RTS at
+   --  a time; it is used to execute in mutual exclusion from all other tasks.
+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List
+
+   ATCB_Key : aliased pthread_key_t;
+   --  Key used to find the Ada Task_Id associated with a thread
+
+   Environment_Task_Id : Task_Id;
+   --  A variable to hold Task_Id for the environment task
+
+   Unblocked_Signal_Mask : aliased sigset_t;
+   --  The set of signals that should be unblocked in all tasks
+
+   --  The followings are internal configuration constants needed
+
+   Next_Serial_Number : Task_Serial_Number := 100;
+   --  We start at 100 (reserve some special values for using in error checks)
+
+   Time_Slice_Val : Integer;
+   pragma Import (C, Time_Slice_Val, "__gl_time_slice_val");
+
+   Dispatching_Policy : Character;
+   pragma Import (C, Dispatching_Policy, "__gl_task_dispatching_policy");
+
+   --  The following are effectively constants, but they need to be initialized
+   --  by calling a pthread_ function.
+
+   Mutex_Attr   : aliased pthread_mutexattr_t;
+   Cond_Attr    : aliased pthread_condattr_t;
+
+   Foreign_Task_Elaborated : aliased Boolean := True;
+   --  Used to identified fake tasks (i.e., non-Ada Threads)
+
+   --------------------
+   -- Local Packages --
+   --------------------
+
+   package Specific is
+
+      procedure Initialize (Environment_Task : Task_Id);
+      pragma Inline (Initialize);
+      --  Initialize various data needed by this package
+
+      function Is_Valid_Task return Boolean;
+      pragma Inline (Is_Valid_Task);
+      --  Does executing thread have a TCB?
+
+      procedure Set (Self_Id : Task_Id);
+      pragma Inline (Set);
+      --  Set the self id for the current task
+
+      function Self return Task_Id;
+      pragma Inline (Self);
+      --  Return a pointer to the Ada Task Control Block of the calling task
+
+   end Specific;
+
+   package body Specific is separate;
+   --  The body of this package is target specific
+
+   ---------------------------------
+   -- Support for foreign threads --
+   ---------------------------------
+
+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;
+   --  Allocate and Initialize a new ATCB for the current Thread
+
+   function Register_Foreign_Thread
+     (Thread : Thread_Id) return Task_Id is separate;
+
+   -----------------------
+   -- Local Subprograms --
+   -----------------------
+
+   subtype unsigned_long is Interfaces.C.unsigned_long;
+
+   procedure Abort_Handler (signo : Signal);
+
+   function To_pthread_t is new Ada.Unchecked_Conversion
+     (unsigned_long, System.OS_Interface.pthread_t);
+
+   procedure Get_Stack_Attributes
+     (T    : Task_Id;
+      ISP  : out System.Address;
+      Size : out Storage_Offset);
+   --  Fill ISP and Size with the Initial Stack Pointer value and the
+   --  thread stack size for task T.
+
+   -------------------
+   -- Abort_Handler --
+   -------------------
+
+   procedure Abort_Handler (signo : Signal) is
+      pragma Unreferenced (signo);
+
+      Self_Id : constant Task_Id := Self;
+      Result  : Interfaces.C.int;
+      Old_Set : aliased sigset_t;
+
+   begin
+      if ZCX_By_Default and then GCC_ZCX_Support then
+         return;
+      end if;
+
+      if Self_Id.Deferral_Level = 0
+        and then Self_Id.Pending_ATC_Level < Self_Id.ATC_Nesting_Level
+        and then not Self_Id.Aborting
+      then
+         Self_Id.Aborting := True;
+
+         --  Make sure signals used for RTS internal purpose are unmasked
+
+         Result :=
+           pthread_sigmask
+             (SIG_UNBLOCK,
+              Unblocked_Signal_Mask'Access,
+              Old_Set'Access);
+         pragma Assert (Result = 0);
+
+         raise Standard'Abort_Signal;
+      end if;
+   end Abort_Handler;
+
+   --------------
+   -- Lock_RTS --
+   --------------
+
+   procedure Lock_RTS is
+   begin
+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);
+   end Lock_RTS;
+
+   ----------------
+   -- Unlock_RTS --
+   ----------------
+
+   procedure Unlock_RTS is
+   begin
+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);
+   end Unlock_RTS;
+
+   -----------------
+   -- Stack_Guard --
+   -----------------
+
+   --  The underlying thread system extends the memory (up to 2MB) when needed
+
+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is
+      pragma Unreferenced (T);
+      pragma Unreferenced (On);
+   begin
+      null;
+   end Stack_Guard;
+
+   --------------------
+   -- Get_Thread_Id  --
+   --------------------
+
+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is
+   begin
+      return T.Common.LL.Thread;
+   end Get_Thread_Id;
+
+   ----------
+   -- Self --
+   ----------
+
+   function Self return Task_Id renames Specific.Self;
+
+   ---------------------
+   -- Initialize_Lock --
+   ---------------------
+
+   --  Note: mutexes and cond_variables needed per-task basis are
+   --  initialized in Initialize_TCB and the Storage_Error is
+   --  handled. Other mutexes (such as RTS_Lock, Memory_Lock...)
+   --  used in RTS is initialized before any status change of RTS.
+   --  Therefore rasing Storage_Error in the following routines
+   --  should be able to be handled safely.
+
+   procedure Initialize_Lock
+     (Prio : System.Any_Priority;
+      L    : not null access Lock)
+   is
+      pragma Unreferenced (Prio);
+
+      Result : Interfaces.C.int;
+
+   begin
+      Result := pthread_mutex_init (L, Mutex_Attr'Access);
+
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result = ENOMEM then
+         Ada.Exceptions.Raise_Exception (Storage_Error'Identity,
+           "Failed to allocate a lock");
+      end if;
+   end Initialize_Lock;
+
+   procedure Initialize_Lock
+     (L     : not null access RTS_Lock;
+      Level : Lock_Level)
+   is
+      pragma Unreferenced (Level);
+
+      Result : Interfaces.C.int;
+
+   begin
+      Result := pthread_mutex_init (L, Mutex_Attr'Access);
+
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result = ENOMEM then
+         raise Storage_Error;
+      end if;
+   end Initialize_Lock;
+
+   -------------------
+   -- Finalize_Lock --
+   -------------------
+
+   procedure Finalize_Lock (L : not null access Lock) is
+      Result : Interfaces.C.int;
+   begin
+      Result := pthread_mutex_destroy (L);
+      pragma Assert (Result = 0);
+   end Finalize_Lock;
+
+   procedure Finalize_Lock (L : not null access RTS_Lock) is
+      Result : Interfaces.C.int;
+   begin
+      Result := pthread_mutex_destroy (L);
+      pragma Assert (Result = 0);
+   end Finalize_Lock;
+
+   ----------------
+   -- Write_Lock --
+   ----------------
+
+   procedure Write_Lock
+     (L                 : not null access Lock;
+      Ceiling_Violation : out Boolean)
+   is
+      Result : Interfaces.C.int;
+   begin
+      Result := pthread_mutex_lock (L);
+      Ceiling_Violation := Result = EINVAL;
+
+      --  Assume the cause of EINVAL is a priority ceiling violation
+
+      pragma Assert (Result = 0 or else Result = EINVAL);
+   end Write_Lock;
+
+   procedure Write_Lock
+     (L           : not null access RTS_Lock;
+      Global_Lock : Boolean := False)
+   is
+      Result : Interfaces.C.int;
+   begin
+      if not Single_Lock or else Global_Lock then
+         Result := pthread_mutex_lock (L);
+         pragma Assert (Result = 0);
+      end if;
+   end Write_Lock;
+
+   procedure Write_Lock (T : Task_Id) is
+      Result : Interfaces.C.int;
+   begin
+      if not Single_Lock then
+         Result := pthread_mutex_lock (T.Common.LL.L'Access);
+         pragma Assert (Result = 0);
+      end if;
+   end Write_Lock;
+
+   ---------------
+   -- Read_Lock --
+   ---------------
+
+   procedure Read_Lock
+     (L                 : not null access Lock;
+      Ceiling_Violation : out Boolean)
+   is
+   begin
+      Write_Lock (L, Ceiling_Violation);
+   end Read_Lock;
+
+   ------------
+   -- Unlock --
+   ------------
+
+   procedure Unlock (L : not null access Lock) is
+      Result : Interfaces.C.int;
+   begin
+      Result := pthread_mutex_unlock (L);
+      pragma Assert (Result = 0);
+   end Unlock;
+
+   procedure Unlock
+     (L           : not null access RTS_Lock;
+      Global_Lock : Boolean := False)
+   is
+      Result : Interfaces.C.int;
+   begin
+      if not Single_Lock or else Global_Lock then
+         Result := pthread_mutex_unlock (L);
+         pragma Assert (Result = 0);
+      end if;
+   end Unlock;
+
+   procedure Unlock (T : Task_Id) is
+      Result : Interfaces.C.int;
+   begin
+      if not Single_Lock then
+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);
+         pragma Assert (Result = 0);
+      end if;
+   end Unlock;
+
+   -----------------
+   -- Set_Ceiling --
+   -----------------
+
+   --  Dynamic priority ceilings are not supported by the underlying system
+
+   procedure Set_Ceiling
+     (L    : not null access Lock;
+      Prio : System.Any_Priority)
+   is
+      pragma Unreferenced (L, Prio);
+   begin
+      null;
+   end Set_Ceiling;
+
+   -----------
+   -- Sleep --
+   -----------
+
+   procedure Sleep
+     (Self_ID  : Task_Id;
+      Reason   : System.Tasking.Task_States)
+   is
+      pragma Unreferenced (Reason);
+
+      Result : Interfaces.C.int;
+
+   begin
+      pragma Assert (Self_ID = Self);
+
+      if Single_Lock then
+         Result :=
+           pthread_cond_wait
+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);
+      else
+         Result :=
+           pthread_cond_wait
+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);
+      end if;
+
+      --  EINTR is not considered a failure
+
+      pragma Assert (Result = 0 or else Result = EINTR);
+   end Sleep;
+
+   -----------------
+   -- Timed_Sleep --
+   -----------------
+
+   --  This is for use within the run-time system, so abort is
+   --  assumed to be already deferred, and the caller should be
+   --  holding its own ATCB lock.
+
+   procedure Timed_Sleep
+     (Self_ID  : Task_Id;
+      Time     : Duration;
+      Mode     : ST.Delay_Modes;
+      Reason   : System.Tasking.Task_States;
+      Timedout : out Boolean;
+      Yielded  : out Boolean)
+   is
+      pragma Unreferenced (Reason);
+
+      Base_Time  : constant Duration := Monotonic_Clock;
+      Check_Time : Duration := Base_Time;
+      Abs_Time   : Duration;
+      Request    : aliased timespec;
+      Result     : Interfaces.C.int;
+
+   begin
+      Timedout := True;
+      Yielded := False;
+
+      if Mode = Relative then
+         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;
+      else
+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);
+      end if;
+
+      if Abs_Time > Check_Time then
+         Request := To_Timespec (Abs_Time);
+
+         loop
+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;
+
+            if Single_Lock then
+               Result :=
+                 pthread_cond_timedwait
+                   (Self_ID.Common.LL.CV'Access,
+                    Single_RTS_Lock'Access,
+                    Request'Access);
+
+            else
+               Result :=
+                 pthread_cond_timedwait
+                   (Self_ID.Common.LL.CV'Access,
+                    Self_ID.Common.LL.L'Access,
+                    Request'Access);
+            end if;
+
+            Check_Time := Monotonic_Clock;
+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;
+
+            if Result = 0 or else Result = EINTR then
+
+               --  Somebody may have called Wakeup for us
+
+               Timedout := False;
+               exit;
+            end if;
+
+            pragma Assert (Result = ETIMEDOUT);
+         end loop;
+      end if;
+   end Timed_Sleep;
+
+   -----------------
+   -- Timed_Delay --
+   -----------------
+
+   --  This is for use in implementing delay statements, so we assume the
+   --  caller is abort-deferred but is holding no locks.
+
+   procedure Timed_Delay
+     (Self_ID : Task_Id;
+      Time    : Duration;
+      Mode    : ST.Delay_Modes)
+   is
+      Base_Time  : constant Duration := Monotonic_Clock;
+      Check_Time : Duration := Base_Time;
+      Abs_Time   : Duration;
+      Request    : aliased timespec;
+
+      Result : Interfaces.C.int;
+      pragma Warnings (Off, Result);
+
+   begin
+      if Single_Lock then
+         Lock_RTS;
+      end if;
+
+      Write_Lock (Self_ID);
+
+      if Mode = Relative then
+         Abs_Time := Time + Check_Time;
+      else
+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);
+      end if;
+
+      if Abs_Time > Check_Time then
+         Request := To_Timespec (Abs_Time);
+         Self_ID.Common.State := Delay_Sleep;
+
+         loop
+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;
+
+            if Single_Lock then
+               Result := pthread_cond_timedwait
+                           (Self_ID.Common.LL.CV'Access,
+                            Single_RTS_Lock'Access,
+                            Request'Access);
+            else
+               Result := pthread_cond_timedwait
+                           (Self_ID.Common.LL.CV'Access,
+                            Self_ID.Common.LL.L'Access,
+                            Request'Access);
+            end if;
+
+            Check_Time := Monotonic_Clock;
+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;
+
+            pragma Assert (Result = 0 or else
+              Result = ETIMEDOUT or else
+              Result = EINTR);
+         end loop;
+
+         Self_ID.Common.State := Runnable;
+      end if;
+
+      Unlock (Self_ID);
+
+      if Single_Lock then
+         Unlock_RTS;
+      end if;
+
+      Result := sched_yield;
+   end Timed_Delay;
+
+   ---------------------
+   -- Monotonic_Clock --
+   ---------------------
+
+   function Monotonic_Clock return Duration is
+      TV     : aliased struct_timeval;
+      Result : Interfaces.C.int;
+   begin
+      Result := gettimeofday (TV'Access, System.Null_Address);
+      pragma Assert (Result = 0);
+      return To_Duration (TV);
+   end Monotonic_Clock;
+
+   -------------------
+   -- RT_Resolution --
+   -------------------
+
+   function RT_Resolution return Duration is
+   begin
+      return 10#1.0#E-6;
+   end RT_Resolution;
+
+   ------------
+   -- Wakeup --
+   ------------
+
+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is
+      pragma Unreferenced (Reason);
+      Result : Interfaces.C.int;
+   begin
+      Result := pthread_cond_signal (T.Common.LL.CV'Access);
+      pragma Assert (Result = 0);
+   end Wakeup;
+
+   -----------
+   -- Yield --
+   -----------
+
+   procedure Yield (Do_Yield : Boolean := True) is
+      Result : Interfaces.C.int;
+      pragma Unreferenced (Result);
+   begin
+      if Do_Yield then
+         Result := sched_yield;
+      end if;
+   end Yield;
+
+   ------------------
+   -- Set_Priority --
+   ------------------
+
+   procedure Set_Priority
+     (T                   : Task_Id;
+      Prio                : System.Any_Priority;
+      Loss_Of_Inheritance : Boolean := False)
+   is
+      pragma Unreferenced (Loss_Of_Inheritance);
+
+      Result : Interfaces.C.int;
+      Param  : aliased struct_sched_param;
+
+      function Get_Policy (Prio : System.Any_Priority) return Character;
+      pragma Import (C, Get_Policy, "__gnat_get_specific_dispatching");
+      --  Get priority specific dispatching policy
+
+      Priority_Specific_Policy : constant Character := Get_Policy (Prio);
+      --  Upper case first character of the policy name corresponding to the
+      --  task as set by a Priority_Specific_Dispatching pragma.
+
+   begin
+      T.Common.Current_Priority := Prio;
+
+      --  Priorities on Cygwin follow Win32 standards, we use the
+      --  MinGW conversion table.
+
+      Param.sched_priority := Interfaces.C.int (Underlying_Priorities (Prio));
+
+      if Dispatching_Policy = 'R'
+        or else Priority_Specific_Policy = 'R'
+        or else Time_Slice_Val > 0
+      then
+         Result :=
+           pthread_setschedparam
+             (T.Common.LL.Thread, SCHED_RR, Param'Access);
+
+      elsif Dispatching_Policy = 'F'
+        or else Priority_Specific_Policy = 'F'
+        or else Time_Slice_Val = 0
+      then
+         Result :=
+           pthread_setschedparam
+             (T.Common.LL.Thread, SCHED_FIFO, Param'Access);
+
+      else
+         Param.sched_priority := 0;
+         Result :=
+           pthread_setschedparam
+             (T.Common.LL.Thread,
+              SCHED_OTHER, Param'Access);
+      end if;
+
+      pragma Assert (Result = 0 or else Result = EPERM);
+   end Set_Priority;
+
+   ------------------
+   -- Get_Priority --
+   ------------------
+
+   function Get_Priority (T : Task_Id) return System.Any_Priority is
+   begin
+      return T.Common.Current_Priority;
+   end Get_Priority;
+
+   --------------------------
+   -- Get_Stack_Attributes --
+   --------------------------
+
+   procedure Get_Stack_Attributes
+     (T    : Task_Id;
+      ISP  : out System.Address;
+      Size : out Storage_Offset)
+   is
+      function pthread_getattr_np
+        (thread : pthread_t;
+         attr   : System.Address) return Interfaces.C.int;
+      pragma Import (C, pthread_getattr_np, "pthread_getattr_np");
+
+      function pthread_attr_getstack
+        (attr : System.Address;
+         base : System.Address;
+         size : System.Address) return Interfaces.C.int;
+      pragma Import (C, pthread_attr_getstack, "pthread_attr_getstack");
+
+      Result : Interfaces.C.int;
+
+      Attributes : aliased pthread_attr_t;
+      Stack_Base : aliased System.Address;
+      Stack_Size : aliased Storage_Offset;
+
+   begin
+      Result :=
+        pthread_getattr_np
+          (T.Common.LL.Thread, Attributes'Address);
+      pragma Assert (Result = 0);
+
+      Result :=
+        pthread_attr_getstack
+          (Attributes'Address, Stack_Base'Address, Stack_Size'Address);
+      pragma Assert (Result = 0);
+
+      Result := pthread_attr_destroy (Attributes'Access);
+      pragma Assert (Result = 0);
+
+      ISP  := Stack_Base + Stack_Size;
+      Size := Stack_Size;
+   end Get_Stack_Attributes;
+
+   ----------------
+   -- Enter_Task --
+   ----------------
+
+   procedure Enter_Task (Self_ID : Task_Id) is
+   begin
+      if Self_ID.Common.Task_Info /= null
+        and then
+          Self_ID.Common.Task_Info.CPU_Affinity = No_CPU
+      then
+         raise Invalid_CPU_Number;
+      end if;
+
+      Self_ID.Common.LL.Thread := pthread_self;
+
+      Specific.Set (Self_ID);
+
+      Lock_RTS;
+
+      for J in Known_Tasks'Range loop
+         if Known_Tasks (J) = null then
+            Known_Tasks (J) := Self_ID;
+            Self_ID.Known_Tasks_Index := J;
+            exit;
+         end if;
+      end loop;
+
+      Unlock_RTS;
+
+      --  Determine where the task stack starts, how large it is, and let the
+      --  stack checking engine know about it.
+
+      declare
+         Initial_SP : System.Address;
+         Stack_Size : Storage_Offset;
+      begin
+         Get_Stack_Attributes (Self_ID, Initial_SP, Stack_Size);
+         System.Stack_Checking.Operations.Notify_Stack_Attributes
+           (Initial_SP, Stack_Size);
+      end;
+   end Enter_Task;
+
+   --------------
+   -- New_ATCB --
+   --------------
+
+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is
+   begin
+      return new Ada_Task_Control_Block (Entry_Num);
+   end New_ATCB;
+
+   -------------------
+   -- Is_Valid_Task --
+   -------------------
+
+   function Is_Valid_Task return Boolean renames Specific.Is_Valid_Task;
+
+   -----------------------------
+   -- Register_Foreign_Thread --
+   -----------------------------
+
+   function Register_Foreign_Thread return Task_Id is
+   begin
+      if Is_Valid_Task then
+         return Self;
+      else
+         return Register_Foreign_Thread (pthread_self);
+      end if;
+   end Register_Foreign_Thread;
+
+   --------------------
+   -- Initialize_TCB --
+   --------------------
+
+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is
+      Result : Interfaces.C.int;
+
+   begin
+      --  Give the task a unique serial number
+
+      Self_ID.Serial_Number := Next_Serial_Number;
+      Next_Serial_Number := Next_Serial_Number + 1;
+      pragma Assert (Next_Serial_Number /= 0);
+
+      Self_ID.Common.LL.Thread := To_pthread_t (-1);
+
+      if not Single_Lock then
+         Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,
+           Mutex_Attr'Access);
+         pragma Assert (Result = 0 or else Result = ENOMEM);
+
+         if Result /= 0 then
+            Succeeded := False;
+            return;
+         end if;
+      end if;
+
+      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,
+        Cond_Attr'Access);
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result = 0 then
+         Succeeded := True;
+      else
+         if not Single_Lock then
+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);
+            pragma Assert (Result = 0);
+         end if;
+
+         Succeeded := False;
+      end if;
+   end Initialize_TCB;
+
+   -----------------
+   -- Create_Task --
+   -----------------
+
+   procedure Create_Task
+     (T          : Task_Id;
+      Wrapper    : System.Address;
+      Stack_Size : System.Parameters.Size_Type;
+      Priority   : System.Any_Priority;
+      Succeeded  : out Boolean)
+   is
+      Attributes : aliased pthread_attr_t;
+      Result     : Interfaces.C.int;
+
+   begin
+      Result := pthread_attr_init (Attributes'Access);
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result /= 0 then
+         Succeeded := False;
+         return;
+      end if;
+
+      Result :=
+        pthread_attr_setstacksize
+          (Attributes'Access, Interfaces.C.size_t (Stack_Size));
+      pragma Assert (Result = 0);
+
+      Result :=
+        pthread_attr_setdetachstate
+          (Attributes'Access, PTHREAD_CREATE_DETACHED);
+      pragma Assert (Result = 0);
+
+      --  Since the initial signal mask of a thread is inherited from the
+      --  creator, and the Environment task has all its signals masked, we
+      --  do not need to manipulate caller's signal mask at this point.
+      --  All tasks in RTS will have All_Tasks_Mask initially.
+
+      Result := pthread_create
+        (T.Common.LL.Thread'Access,
+         Attributes'Access,
+         Thread_Body_Access (Wrapper),
+         To_Address (T));
+      pragma Assert (Result = 0 or else Result = EAGAIN);
+
+      Succeeded := Result = 0;
+
+      --  Handle Task_Info
+
+      if T.Common.Task_Info /= null then
+         if T.Common.Task_Info.CPU_Affinity /= Task_Info.Any_CPU then
+            Result :=
+              pthread_setaffinity_np
+                (T.Common.LL.Thread,
+                 CPU_SETSIZE / 8,
+                 T.Common.Task_Info.CPU_Affinity'Access);
+            pragma Assert (Result = 0);
+         end if;
+      end if;
+
+      Result := pthread_attr_destroy (Attributes'Access);
+      pragma Assert (Result = 0);
+
+      Set_Priority (T, Priority);
+   end Create_Task;
+
+   ------------------
+   -- Finalize_TCB --
+   ------------------
+
+   procedure Finalize_TCB (T : Task_Id) is
+      Result  : Interfaces.C.int;
+      Tmp     : Task_Id := T;
+      Is_Self : constant Boolean := T = Self;
+
+      procedure Free is new
+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);
+
+   begin
+      if not Single_Lock then
+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);
+         pragma Assert (Result = 0);
+      end if;
+
+      Result := pthread_cond_destroy (T.Common.LL.CV'Access);
+      pragma Assert (Result = 0);
+
+      if T.Known_Tasks_Index /= -1 then
+         Known_Tasks (T.Known_Tasks_Index) := null;
+      end if;
+      SC.Invalidate_Stack_Cache (T.Common.Compiler_Data.Pri_Stack_Info'Access);
+      Free (Tmp);
+
+      if Is_Self then
+         Specific.Set (null);
+      end if;
+   end Finalize_TCB;
+
+   ---------------
+   -- Exit_Task --
+   ---------------
+
+   procedure Exit_Task is
+   begin
+      Specific.Set (null);
+   end Exit_Task;
+
+   ----------------
+   -- Abort_Task --
+   ----------------
+
+   procedure Abort_Task (T : Task_Id) is
+      Result : Interfaces.C.int;
+   begin
+      Result :=
+        pthread_kill
+          (T.Common.LL.Thread,
+           Signal (System.Interrupt_Management.Abort_Task_Interrupt));
+      pragma Assert (Result = 0);
+   end Abort_Task;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize (S : in out Suspension_Object) is
+      Result : Interfaces.C.int;
+
+   begin
+      --  Initialize internal state (always to False (RM D.10(6)))
+
+      S.State := False;
+      S.Waiting := False;
+
+      --  Initialize internal mutex
+
+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);
+
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result = ENOMEM then
+         raise Storage_Error;
+      end if;
+
+      --  Initialize internal condition variable
+
+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);
+
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result /= 0 then
+         Result := pthread_mutex_destroy (S.L'Access);
+         pragma Assert (Result = 0);
+
+         if Result = ENOMEM then
+            raise Storage_Error;
+         end if;
+      end if;
+   end Initialize;
+
+   --------------
+   -- Finalize --
+   --------------
+
+   procedure Finalize (S : in out Suspension_Object) is
+      Result : Interfaces.C.int;
+
+   begin
+      --  Destroy internal mutex
+
+      Result := pthread_mutex_destroy (S.L'Access);
+      pragma Assert (Result = 0);
+
+      --  Destroy internal condition variable
+
+      Result := pthread_cond_destroy (S.CV'Access);
+      pragma Assert (Result = 0);
+   end Finalize;
+
+   -------------------
+   -- Current_State --
+   -------------------
+
+   function Current_State (S : Suspension_Object) return Boolean is
+   begin
+      --  We do not want to use lock on this read operation. State is marked
+      --  as Atomic so that we ensure that the value retrieved is correct.
+
+      return S.State;
+   end Current_State;
+
+   ---------------
+   -- Set_False --
+   ---------------
+
+   procedure Set_False (S : in out Suspension_Object) is
+      Result : Interfaces.C.int;
+
+   begin
+      SSL.Abort_Defer.all;
+
+      Result := pthread_mutex_lock (S.L'Access);
+      pragma Assert (Result = 0);
+
+      S.State := False;
+
+      Result := pthread_mutex_unlock (S.L'Access);
+      pragma Assert (Result = 0);
+
+      SSL.Abort_Undefer.all;
+   end Set_False;
+
+   --------------
+   -- Set_True --
+   --------------
+
+   procedure Set_True (S : in out Suspension_Object) is
+      Result : Interfaces.C.int;
+
+   begin
+      SSL.Abort_Defer.all;
+
+      Result := pthread_mutex_lock (S.L'Access);
+      pragma Assert (Result = 0);
+
+      --  If there is already a task waiting on this suspension object then
+      --  we resume it, leaving the state of the suspension object to False,
+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves
+      --  the state to True.
+
+      if S.Waiting then
+         S.Waiting := False;
+         S.State := False;
+
+         Result := pthread_cond_signal (S.CV'Access);
+         pragma Assert (Result = 0);
+
+      else
+         S.State := True;
+      end if;
+
+      Result := pthread_mutex_unlock (S.L'Access);
+      pragma Assert (Result = 0);
+
+      SSL.Abort_Undefer.all;
+   end Set_True;
+
+   ------------------------
+   -- Suspend_Until_True --
+   ------------------------
+
+   procedure Suspend_Until_True (S : in out Suspension_Object) is
+      Result : Interfaces.C.int;
+
+   begin
+      SSL.Abort_Defer.all;
+
+      Result := pthread_mutex_lock (S.L'Access);
+      pragma Assert (Result = 0);
+
+      if S.Waiting then
+
+         --  Program_Error must be raised upon calling Suspend_Until_True
+         --  if another task is already waiting on that suspension object
+         --  (RM D.10(10)).
+
+         Result := pthread_mutex_unlock (S.L'Access);
+         pragma Assert (Result = 0);
+
+         SSL.Abort_Undefer.all;
+
+         raise Program_Error;
+      else
+         --  Suspend the task if the state is False. Otherwise, the task
+         --  continues its execution, and the state of the suspension object
+         --  is set to False (ARM D.10 par. 9).
+
+         if S.State then
+            S.State := False;
+         else
+            S.Waiting := True;
+            Result := pthread_cond_wait (S.CV'Access, S.L'Access);
+         end if;
+
+         Result := pthread_mutex_unlock (S.L'Access);
+         pragma Assert (Result = 0);
+
+         SSL.Abort_Undefer.all;
+      end
+      if;
+   end Suspend_Until_True;
+
+   ----------------
+   -- Check_Exit --
+   ----------------
+
+   --  Dummy version
+
+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is
+      pragma Unreferenced (Self_ID);
+   begin
+      return True;
+   end Check_Exit;
+
+   --------------------
+   -- Check_No_Locks --
+   --------------------
+
+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is
+      pragma Unreferenced (Self_ID);
+   begin
+      return True;
+   end Check_No_Locks;
+
+   ----------------------
+   -- Environment_Task --
+   ----------------------
+
+   function Environment_Task return Task_Id is
+   begin
+      return Environment_Task_Id;
+   end Environment_Task;
+
+   ------------------
+   -- Suspend_Task --
+   ------------------
+
+   function Suspend_Task
+     (T           : ST.Task_Id;
+      Thread_Self : Thread_Id) return Boolean
+   is
+   begin
+      if T.Common.LL.Thread /= Thread_Self then
+         return pthread_kill (T.Common.LL.Thread, SIGSTOP) = 0;
+      else
+         return True;
+      end if;
+   end Suspend_Task;
+
+   -----------------
+   -- Resume_Task --
+   -----------------
+
+   function Resume_Task
+     (T           : ST.Task_Id;
+      Thread_Self : Thread_Id) return Boolean
+   is
+   begin
+      if T.Common.LL.Thread /= Thread_Self then
+         return pthread_kill (T.Common.LL.Thread, SIGCONT) = 0;
+      else
+         return True;
+      end if;
+   end Resume_Task;
+
+   --------------------
+   -- Stop_All_Tasks --
+   --------------------
+
+   procedure Stop_All_Tasks is
+   begin
+      null;
+   end Stop_All_Tasks;
+
+   ---------------
+   -- Stop_Task --
+   ---------------
+
+   function Stop_Task (T : ST.Task_Id) return Boolean is
+      pragma Unreferenced (T);
+   begin
+      return False;
+   end Stop_Task;
+
+   -------------------
+   -- Continue_Task --
+   -------------------
+
+   function Continue_Task (T : ST.Task_Id) return Boolean is
+      pragma Unreferenced (T);
+   begin
+      return False;
+   end Continue_Task;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize (Environment_Task : Task_Id) is
+      act     : aliased struct_sigaction;
+      old_act : aliased struct_sigaction;
+      Tmp_Set : aliased sigset_t;
+      Result  : Interfaces.C.int;
+
+      function State
+        (Int : System.Interrupt_Management.Interrupt_ID) return Character;
+      pragma Import (C, State, "__gnat_get_interrupt_state");
+      --  Get interrupt state.  Defined in a-init.c
+      --  The input argument is the interrupt number,
+      --  and the result is one of the following:
+
+      Default : constant Character := 's';
+      --    'n'   this interrupt not set by any Interrupt_State pragma
+      --    'u'   Interrupt_State pragma set state to User
+      --    'r'   Interrupt_State pragma set state to Runtime
+      --    's'   Interrupt_State pragma set state to System (use "default"
+      --           system handler)
+
+   begin
+      Environment_Task_Id := Environment_Task;
+
+      Interrupt_Management.Initialize;
+
+      --  Prepare the set of signals that should be unblocked in all tasks
+
+      Result := sigemptyset (Unblocked_Signal_Mask'Access);
+      pragma Assert (Result = 0);
+
+      for J in Interrupt_Management.Interrupt_ID loop
+         if System.Interrupt_Management.Keep_Unmasked (J) then
+            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));
+            pragma Assert (Result = 0);
+         end if;
+      end loop;
+
+      Result := pthread_mutexattr_init (Mutex_Attr'Access);
+      pragma Assert (Result = 0);
+
+      Result := pthread_condattr_init (Cond_Attr'Access);
+      pragma Assert (Result = 0);
+
+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);
+
+      --  Initialize the global RTS lock
+
+      Specific.Initialize (Environment_Task);
+
+      Enter_Task (Environment_Task);
+
+      --  Install the abort-signal handler
+
+      if State
+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default
+      then
+         act.sa_flags := 0;
+         act.sa_handler := Abort_Handler'Address;
+
+         Result := sigemptyset (Tmp_Set'Access);
+         pragma Assert (Result = 0);
+         act.sa_mask := Tmp_Set;
+
+         Result :=
+           sigaction
+           (Signal (Interrupt_Management.Abort_Task_Interrupt),
+            act'Unchecked_Access,
+            old_act'Unchecked_Access);
+         pragma Assert (Result = 0);
+      end if;
+   end Initialize;
+
+end System.Task_Primitives.Operations;
diff --git a/gcc/ada/sysdep.c b/gcc/ada/sysdep.c
index bfe7bce32..6818bc473 100644
--- a/gcc/ada/sysdep.c
+++ b/gcc/ada/sysdep.c
@@ -311,7 +311,7 @@ getc_immediate_common (FILE *stream,
 {
 #if defined (linux) || defined (sun) || defined (sgi) \
     || (defined (__osf__) && ! defined (__alpha_vxworks)) \
-    || defined (__CYGWIN32__) || defined (__MACHTEN__) || defined (__hpux__) \
+    || defined (__CYGWIN__) || defined (__MACHTEN__) || defined (__hpux__) \
     || defined (_AIX) || (defined (__svr4__) && defined (i386)) \
     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
     || defined (__GLIBC__) || defined (__APPLE__)
@@ -592,6 +592,16 @@ rts_get_nShowCmd (void)
 }
 
 #endif /* WINNT */
+
+#ifdef __CYGWIN__
+#include <malloc.h>
+size_t _msize(void *memblock)
+{
+  return (size_t) malloc_usable_size (memblock);
+}
+
+#endif /* __CYGWIN__ */
+
 #ifdef VMS
 
 /* This gets around a problem with using the old threads library on VMS 7.0. */
diff --git a/gcc/ada/system-cygwin.ads b/gcc/ada/system-cygwin.ads
new file mode 100644
index 000000000..3dca1fa72
--- /dev/null
+++ b/gcc/ada/system-cygwin.ads
@@ -0,0 +1,199 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                            (Cygwin  Version)                             --
+--                                                                          --
+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.01;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 32;
+   Memory_Size  : constant := 2 ** 32;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := Low_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := False;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_64_Bit_Divides    : constant Boolean := True;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := True;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := True;
+   GCC_ZCX_Support           : constant Boolean := True;
+
+   ---------------------------
+   -- Underlying Priorities --
+   ---------------------------
+
+   --  Important note: this section of the file must come AFTER the
+   --  definition of the system implementation parameters to ensure
+   --  that the value of these parameters is available for analysis
+   --  of the declarations here (using Rtsfind at compile time).
+
+   --  The underlying priorities table provides a generalized mechanism
+   --  for mapping from Ada priorities to system priorities. In some
+   --  cases a 1-1 mapping is not the convenient or optimal choice.
+
+   type Priorities_Mapping is array (Any_Priority) of Integer;
+   pragma Suppress_Initialization (Priorities_Mapping);
+   --  Suppress initialization in case gnat.adc specifies Normalize_Scalars
+
+   Underlying_Priorities : constant Priorities_Mapping :=
+     (Priority'First ..
+      Default_Priority - 8    => -15,
+      Default_Priority - 7    => -7,
+      Default_Priority - 6    => -6,
+      Default_Priority - 5    => -5,
+      Default_Priority - 4    => -4,
+      Default_Priority - 3    => -3,
+      Default_Priority - 2    => -2,
+      Default_Priority - 1    => -1,
+      Default_Priority        => 0,
+      Default_Priority + 1    => 1,
+      Default_Priority + 2    => 2,
+      Default_Priority + 3    => 3,
+      Default_Priority + 4    => 4,
+      Default_Priority + 5    => 5,
+      Default_Priority + 6 ..
+      Priority'Last           => 6,
+      Interrupt_Priority      => 15);
+   --  The default mapping preserves the standard 31 priorities of the Ada
+   --  model, but maps them using compression onto the 7 priority levels
+   --  available in NT and on the 16 priority levels available in 2000/XP.
+
+   --  To replace the default values of the Underlying_Priorities mapping,
+   --  copy this source file into your build directory, edit the file to
+   --  reflect your desired behavior, and recompile using Makefile.adalib
+   --  which can be found under the adalib directory of your gnat installation
+
+   pragma Linker_Options ("-Wl,--stack=0x2000000");
+   --  This is used to change the default stack (32 MB) size for non tasking
+   --  programs. We change this value for GNAT on Windows here because the
+   --  binutils on this platform have switched to a too low value for Ada
+   --  programs. Note that we also set the stack size for tasking programs in
+   --  System.Task_Primitives.Operations.
+
+end System;
diff --git a/gcc/config.gcc b/gcc/config.gcc
index c7f892a3a..67f0aca41 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -1427,7 +1427,7 @@ i[34567]86-*-cygwin*)
 	xm_file=i386/xm-cygwin.h
 	tmake_file="${tmake_file} i386/t-cygming t-slibgcc"
 	target_gtfiles="\$(srcdir)/config/i386/winnt.c"
-	extra_options="${extra_options} i386/cygming.opt"
+	extra_options="${extra_options} i386/cygming.opt i386/cygwin.opt"
 	extra_objs="winnt.o winnt-stubs.o"
 	c_target_objs="${c_target_objs} msformat-c.o"
 	cxx_target_objs="${cxx_target_objs} winnt-cxx.o msformat-c.o"
diff --git a/gcc/config/i386/cygwin.h b/gcc/config/i386/cygwin.h
index 5cf7f9cf5..24a3dd3b3 100644
--- a/gcc/config/i386/cygwin.h
+++ b/gcc/config/i386/cygwin.h
@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see
 #define EXTRA_OS_CPP_BUILTINS()  /* Nothing.  */
 
 #undef CPP_SPEC
-#define CPP_SPEC "%(cpp_cpu) %{posix:-D_POSIX_SOURCE} \
+#define CPP_SPEC "%(cpp_cpu) %{posix:-D_POSIX_SOURCE} %{pthread: } \
   -D__CYGWIN32__ -D__CYGWIN__ %{!ansi:-Dunix} -D__unix__ -D__unix \
   %{mwin32:-DWIN32 -D_WIN32 -D__WIN32 -D__WIN32__ %{!ansi:-DWINNT}} \
   %{!nostdinc:%{!mno-win32:-idirafter ../include/w32api%s -idirafter ../../include/w32api%s}}\
@@ -72,6 +72,7 @@ along with GCC; see the file COPYING3.  If not see
 #undef LIB_SPEC
 #define LIB_SPEC "\
   %{pg:-lgmon} \
+  %{pthread: } \
   -lcygwin \
   %{mwindows:-lgdi32 -lcomdlg32} \
   -ladvapi32 -lshell32 -luser32 -lkernel32"
@@ -115,7 +116,9 @@ along with GCC; see the file COPYING3.  If not see
   %{shared: --shared} %{mdll:--dll} \
   %{static:-Bstatic} %{!static:-Bdynamic} \
   %{shared|mdll: --enable-auto-image-base -e __cygwin_dll_entry@12} \
-  --dll-search-prefix=cyg -tsaware"
+  --dll-search-prefix=cyg \
+  %{rdynamic: --export-all-symbols} \
+  %{!shared: %{!mdll: --large-address-aware --tsaware}}"
 
 /* Binutils does not handle weak symbols from dlls correctly.  For now,
    do not use them unnecessarily in gthr-posix.h.  */
diff --git a/gcc/config/i386/cygwin.opt b/gcc/config/i386/cygwin.opt
new file mode 100644
index 000000000..4c6950948
--- /dev/null
+++ b/gcc/config/i386/cygwin.opt
@@ -0,0 +1,27 @@
+; Cygwin-specific options.
+
+; Copyright (C) 2005, 2007, 2009, 2010, 2011 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+pthread
+Driver
+
+rdynamic
+Driver
+
+; Retain blank line above
diff --git a/gcc/cppdefault.c b/gcc/cppdefault.c
index 99c4c8814..994bdf974 100644
--- a/gcc/cppdefault.c
+++ b/gcc/cppdefault.c
@@ -35,6 +35,8 @@
 # undef NATIVE_SYSTEM_HEADER_DIR
 #else
 # undef CROSS_INCLUDE_DIR
+# undef CROSS_INCLUDE_DIR_1
+# undef CROSS_INCLUDE_DIR_2
 #endif
 
 const struct default_include cpp_include_defaults[]
@@ -85,6 +87,14 @@ const struct default_include cpp_include_defaults[]
     /* One place the target system's headers might be.  */
     { CROSS_INCLUDE_DIR, "GCC", 0, 0, 0, 0 },
 #endif
+#ifdef CROSS_INCLUDE_DIR_1
+    /* One more place the target system's headers might be.  */
+    { CROSS_INCLUDE_DIR_1, "GCC", 0, 0, 0, 0 },
+#endif
+#ifdef CROSS_INCLUDE_DIR_2
+    /* One more place the target system's headers might be.  */
+    { CROSS_INCLUDE_DIR_2, "GCC", 0, 0, 0, 0 },
+#endif
 #ifdef TOOL_INCLUDE_DIR
     /* Another place the target system's headers might be.  */
     { TOOL_INCLUDE_DIR, "BINUTILS", 0, 1, 0, 0 },
diff --git a/gcc/testsuite/gcc.target/i386/pr25993.c b/gcc/testsuite/gcc.target/i386/pr25993.c
index b079e257f..c30eaf546 100644
--- a/gcc/testsuite/gcc.target/i386/pr25993.c
+++ b/gcc/testsuite/gcc.target/i386/pr25993.c
@@ -1,5 +1,5 @@
 /* { dg-do assemble } */
-/* { dg-skip-if "" { "*-*-darwin*" "*-*-mingw*" } { "*" } { "" } } */
+/* { dg-skip-if "" { "*-*-darwin*" "*-*-mingw*" "*-*-cygwin*" } { "*" } { "" } } */
 /* { dg-options "-std=c99 -x assembler-with-cpp" } */
 
 #ifndef __ASSEMBLER__
diff --git a/libgcc/config/i386/cygming-crtbegin.c b/libgcc/config/i386/cygming-crtbegin.c
index 322b61780..70d014ad6 100644
--- a/libgcc/config/i386/cygming-crtbegin.c
+++ b/libgcc/config/i386/cygming-crtbegin.c
@@ -70,8 +70,7 @@ static EH_FRAME_SECTION_CONST char __EH_FRAME_BEGIN__[]
 
 static struct object obj;
 
-/* Handle of libgcc's DLL reference.  */
-HANDLE hmod_libgcc;
+static void *  (*deregister_frame_fn) (const void *) = NULL;
 #endif
 
 #if TARGET_USE_JCR_SECTION
@@ -99,13 +98,16 @@ __gcc_register_frame (void)
 
   if (h)
     {
-      /* Increasing the load-count of LIBGCC_SONAME DLL.  */
-      hmod_libgcc = LoadLibrary (LIBGCC_SONAME);
       register_frame_fn = (void (*) (const void *, struct object *))
 			  GetProcAddress (h, "__register_frame_info");
+      deregister_frame_fn = (void* (*) (const void *))
+	                    GetProcAddress (h, "__deregister_frame_info");
+    }
+  else
+    {
+      register_frame_fn = __register_frame_info;
+      deregister_frame_fn = __deregister_frame_info;
     }
-  else 
-    register_frame_fn = __register_frame_info;
   if (register_frame_fn)
      register_frame_fn (__EH_FRAME_BEGIN__, &obj);
 #endif
@@ -131,16 +133,7 @@ void
 __gcc_deregister_frame (void)
 {
 #if DWARF2_UNWIND_INFO
-  void *  (*deregister_frame_fn) (const void *);
-  HANDLE h = GetModuleHandle (LIBGCC_SONAME);
-  if (h)
-    deregister_frame_fn = (void* (*) (const void *))
-			  GetProcAddress (h, "__deregister_frame_info");
-  else 
-    deregister_frame_fn = __deregister_frame_info;
   if (deregister_frame_fn)
      deregister_frame_fn (__EH_FRAME_BEGIN__);
-  if (hmod_libgcc)
-    FreeLibrary (hmod_libgcc);
 #endif
 }
diff --git a/libitm/Makefile.am b/libitm/Makefile.am
index e754ccc77..94ad53f57 100644
--- a/libitm/Makefile.am
+++ b/libitm/Makefile.am
@@ -53,8 +53,8 @@ libitm_version_info = -version-info $(libtool_VERSION)
 # Force link with C, not C++.  For now, while we're using C++ we don't
 # want or need libstdc++.
 libitm_la_DEPENDENCIES = $(libitm_version_dep)
-libitm_la_LINK = $(LINK) $(libitm_la_LDFLAGS)
-libitm_la_LDFLAGS = $(libitm_version_info) $(libitm_version_script)
+libitm_la_LINK = $(CXXLINK) $(libitm_la_LDFLAGS)
+libitm_la_LDFLAGS = $(libitm_version_info) $(libitm_version_script) -no-undefined -bindir $(bindir)
 
 libitm_la_SOURCES = \
 	aatree.cc alloc.cc alloc_c.cc alloc_cpp.cc barrier.cc beginend.cc \
diff --git a/libitm/Makefile.in b/libitm/Makefile.in
index f44fd70b9..e833869a5 100644
--- a/libitm/Makefile.in
+++ b/libitm/Makefile.in
@@ -328,8 +328,8 @@ libitm_version_info = -version-info $(libtool_VERSION)
 # Force link with C, not C++.  For now, while we're using C++ we don't
 # want or need libstdc++.
 libitm_la_DEPENDENCIES = $(libitm_version_dep)
-libitm_la_LINK = $(LINK) $(libitm_la_LDFLAGS)
-libitm_la_LDFLAGS = $(libitm_version_info) $(libitm_version_script)
+libitm_la_LINK = $(CXXLINK) $(libitm_la_LDFLAGS)
+libitm_la_LDFLAGS = $(libitm_version_info) $(libitm_version_script) -no-undefined -bindir $(bindir)
 libitm_la_SOURCES = aatree.cc alloc.cc alloc_c.cc alloc_cpp.cc \
 	barrier.cc beginend.cc clone.cc eh_cpp.cc local.cc query.cc \
 	retry.cc rwlock.cc useraction.cc util.cc sjlj.S tls.cc \
diff --git a/libitm/configure.tgt b/libitm/configure.tgt
index b68c86b05..695f73f3d 100644
--- a/libitm/configure.tgt
+++ b/libitm/configure.tgt
@@ -131,7 +131,7 @@ case "${target}" in
   *-*-gnu* | *-*-k*bsd*-gnu \
   | *-*-netbsd* | *-*-freebsd* | *-*-openbsd* \
   | *-*-solaris2* | *-*-sysv4* | *-*-irix6* | *-*-osf* | *-*-hpux11* \
-  | *-*-darwin* | *-*-aix*)
+  | *-*-darwin* | *-*-aix* | *-*-cygwin*)
 	# POSIX system.  The OS is supported.
 	;;
 
diff --git a/libjava/boehm.cc b/libjava/boehm.cc
index 855d23cb0..33455a870 100644
--- a/libjava/boehm.cc
+++ b/libjava/boehm.cc
@@ -747,7 +747,7 @@ _Jv_GCAttachThread ()
   // The registration interface is only defined on posixy systems and
   // only actually works if pthread_getattr_np is defined.
   // FIXME: until gc7 it is simpler to disable this on solaris.
-#if defined(HAVE_PTHREAD_GETATTR_NP) && !defined(GC_SOLARIS_THREADS)
+#if defined(HAVE_PTHREAD_GETATTR_NP) && !defined(GC_SOLARIS_THREADS) && !defined(GC_WIN32_THREADS)
   GC_register_my_thread ();
 #endif
 }
@@ -755,7 +755,7 @@ _Jv_GCAttachThread ()
 void
 _Jv_GCDetachThread ()
 {
-#if defined(HAVE_PTHREAD_GETATTR_NP) && !defined(GC_SOLARIS_THREADS)
+#if defined(HAVE_PTHREAD_GETATTR_NP) && !defined(GC_SOLARIS_THREADS) && !defined(GC_WIN32_THREADS)
   GC_unregister_my_thread ();
 #endif
 }
diff --git a/libjava/classpath/configure b/libjava/classpath/configure
index a25f5f75a..5adec0418 100755
--- a/libjava/classpath/configure
+++ b/libjava/classpath/configure
@@ -3172,7 +3172,7 @@ case "$host_os" in
 	cp_module=""
 	;;
 	*)
-	cp_module="-module"
+	cp_module="-module -avoid-version"
 	;;
 esac
 
diff --git a/libjava/classpath/configure.ac b/libjava/classpath/configure.ac
index 49bd66776..e5d71ff64 100644
--- a/libjava/classpath/configure.ac
+++ b/libjava/classpath/configure.ac
@@ -64,7 +64,7 @@ case "$host_os" in
 	cp_module=""
 	;;
 	*)
-	cp_module="-module"
+	cp_module="-module -avoid-version"
 	;;
 esac
 
diff --git a/libjava/classpath/examples/gnu/classpath/examples/awt/HintingDemo.java b/libjava/classpath/examples/gnu/classpath/examples/awt/HintingDemo.java
index 5ba44f6d9..068b59659 100644
--- a/libjava/classpath/examples/gnu/classpath/examples/awt/HintingDemo.java
+++ b/libjava/classpath/examples/gnu/classpath/examples/awt/HintingDemo.java
@@ -211,7 +211,7 @@ public class HintingDemo extends JFrame {
 
   HintingDemo()
   {
-    File file = new File("/usr/share/fonts/truetype/freefont/FreeSans.ttf");
+    File file = new File("/usr/share/fonts/TTF/Vera.ttf");
     loadFont(file);
     setLayout(new BorderLayout());
     chooser = new Chooser();
diff --git a/libjava/classpath/gnu/java/awt/peer/ClasspathDesktopPeer.java b/libjava/classpath/gnu/java/awt/peer/ClasspathDesktopPeer.java
index fd4f498aa..2935a5a90 100644
--- a/libjava/classpath/gnu/java/awt/peer/ClasspathDesktopPeer.java
+++ b/libjava/classpath/gnu/java/awt/peer/ClasspathDesktopPeer.java
@@ -58,7 +58,7 @@ public class ClasspathDesktopPeer
     implements DesktopPeer
 {
   /** This is the fallback browser, if no desktop was detected. */
-  protected static final String _DEFAULT_BROWSER = "firefox";
+  protected static final String _DEFAULT_BROWSER = "xdg-open";
 
   /** gnu.java.awt.peer.Desktop.html.command */
   protected static final String _BROWSE = "html";
diff --git a/libjava/classpath/gnu/java/awt/peer/ClasspathFontPeer.java b/libjava/classpath/gnu/java/awt/peer/ClasspathFontPeer.java
index 96677a4af..101a85f47 100644
--- a/libjava/classpath/gnu/java/awt/peer/ClasspathFontPeer.java
+++ b/libjava/classpath/gnu/java/awt/peer/ClasspathFontPeer.java
@@ -158,6 +158,8 @@ public abstract class ClasspathFontPeer
 
   protected static boolean isLogicalFontName(String name)
   {
+    return false;
+/*
     String uname = name.toUpperCase ();
     return (uname.equals ("SANSSERIF") ||
             uname.equals ("SERIF") ||
@@ -165,6 +167,7 @@ public abstract class ClasspathFontPeer
             uname.equals ("DIALOG") ||
             uname.equals ("DIALOGINPUT") ||
             uname.equals ("DEFAULT"));
+*/
   }
 
   protected static String logicalFontNameToFaceName (String name)
diff --git a/libjava/classpath/resource/gnu/java/awt/font/fonts.properties b/libjava/classpath/resource/gnu/java/awt/font/fonts.properties
index 4fc0b10b8..1370469cf 100644
--- a/libjava/classpath/resource/gnu/java/awt/font/fonts.properties
+++ b/libjava/classpath/resource/gnu/java/awt/font/fonts.properties
@@ -36,20 +36,20 @@
 # exception statement from your version.
 
 # List of available fonts.
-FreeMono/p=/usr/share/fonts/truetype/freefont/FreeMono.ttf
-FreeMono/b=/usr/share/fonts/truetype/freefont/FreeMonoBold.ttf
-FreeMono/bi=/usr/share/fonts/truetype/freefont/FreeMonoBoldOblique.ttf
-FreeMono/i=/usr/share/fonts/truetype/freefont/FreeMonoOblique.ttf
+FreeMono/p=/usr/share/fonts/TTF/VeraMono.ttf
+FreeMono/b=/usr/share/fonts/TTF/VeraMoBd.ttf
+FreeMono/bi=/usr/share/fonts/TTF/VeraMoBI.ttf
+FreeMono/i=/usr/share/fonts/TTF/VeraMoIt.ttf
 
-FreeSans/p=/usr/share/fonts/truetype/freefont/FreeSans.ttf
-FreeSans/b=/usr/share/fonts/truetype/freefont/FreeSansBold.ttf
-FreeSans/bi=/usr/share/fonts/truetype/freefont/FreeSansBoldOblique.ttf
-FreeSans/i=/usr/share/fonts/truetype/freefont/FreeSansOblique.ttf
+FreeSans/p=/usr/share/fonts/TTF/Vera.ttf
+FreeSans/b=/usr/share/fonts/TTF/VeraBd.ttf
+FreeSans/bi=/usr/share/fonts/TTF/VeraBI.ttf
+FreeSans/i=/usr/share/fonts/TTF/VeraIt.ttf
 
-FreeSerif/p=/usr/share/fonts/truetype/freefont/FreeSerif.ttf
-FreeSerif/b=/usr/share/fonts/truetype/freefont/FreeSerifBold.ttf
-FreeSerif/bi=/usr/share/fonts/truetype/freefont/FreeSerifBoldOblique.ttf
-FreeSerif/i=/usr/share/fonts/truetype/freefont/FreeSerifOblique.ttf
+FreeSerif/p=/usr/share/fonts/TTF/VeraSe.ttf
+FreeSerif/b=/usr/share/fonts/TTF/VeraSeBd.ttf
+FreeSerif/bi=/usr/share/fonts/TTF/VeraSeBd.ttf
+FreeSerif/i=/usr/share/fonts/TTF/VeraSe.ttf
 
 # List of aliases.
 Dialog/a=FreeSans
diff --git a/libjava/gnu/java/nio/channels/natFileChannelPosix.cc b/libjava/gnu/java/nio/channels/natFileChannelPosix.cc
index e05904c50..0a2569cef 100644
--- a/libjava/gnu/java/nio/channels/natFileChannelPosix.cc
+++ b/libjava/gnu/java/nio/channels/natFileChannelPosix.cc
@@ -386,7 +386,7 @@ FileChannelImpl::available (void)
 
 #if defined (FIONREAD)
   r = ::ioctl (fd, FIONREAD, &num);
-  if (r == -1 && errno == ENOTTY)
+  if (r == -1 && (errno == ENOTTY || errno == EINVAL))
     {
       // If the ioctl doesn't work, we don't care.
       r = 0;
diff --git a/libjava/include/posix.h b/libjava/include/posix.h
index c49da05eb..805ed14cf 100644
--- a/libjava/include/posix.h
+++ b/libjava/include/posix.h
@@ -47,11 +47,17 @@ details.  */
 #include <java/util/Properties.h>
 
 // Prefix and suffix for shared libraries.
+#ifdef __CYGWIN__
+#define _Jv_platform_solib_prefix "cyg"
+#else
 #define _Jv_platform_solib_prefix "lib"
+#endif
 #if defined(__APPLE__) && defined(__MACH__)
 #define _Jv_platform_solib_suffix ".dylib"
 #elif defined(HPUX) && defined(HP_PA)
 #define _Jv_platform_solib_suffix ".sl"
+#elif defined(__CYGWIN__)
+#define _Jv_platform_solib_suffix ".dll"
 #else
 #define _Jv_platform_solib_suffix ".so"
 #endif
diff --git a/libjava/java/net/natVMURLConnection.cc b/libjava/java/net/natVMURLConnection.cc
index 0a30a2197..810e0455b 100644
--- a/libjava/java/net/natVMURLConnection.cc
+++ b/libjava/java/net/natVMURLConnection.cc
@@ -32,7 +32,11 @@ void
 java::net::VMURLConnection::init ()
 {
 #if defined (HAVE_MAGIC_T) && defined (HAVE_MAGIC_H) && defined (USE_LTDL)
+#ifdef __CYGWIN__
+  lt_dlhandle handle = lt_dlopenext ("cygmagic-1.dll");
+#else
   lt_dlhandle handle = lt_dlopenext ("libmagic.so");
+#endif
   if (!handle)
     return;
 
diff --git a/libstdc++-v3/config/os/mingw32/os_defines.h b/libstdc++-v3/config/os/mingw32/os_defines.h
index f82e25c76..6ab0a7bd5 100644
--- a/libstdc++-v3/config/os/mingw32/os_defines.h
+++ b/libstdc++-v3/config/os/mingw32/os_defines.h
@@ -72,4 +72,10 @@
 #define _GLIBCXX_CDTOR_CALLABI __thiscall
 #endif
 
+#ifdef _DLL
+#define _GLIBCXX_IMPORT __attribute__((dllimport))
+#else
+#define _GLIBCXX_IMPORT
+#endif
+
 #endif
diff --git a/libstdc++-v3/config/os/newlib/os_defines.h b/libstdc++-v3/config/os/newlib/os_defines.h
index e5a19d958..95d6b66f9 100644
--- a/libstdc++-v3/config/os/newlib/os_defines.h
+++ b/libstdc++-v3/config/os/newlib/os_defines.h
@@ -35,6 +35,8 @@
 
 #ifdef __CYGWIN__
 #define _GLIBCXX_GTHREAD_USE_WEAK 0
+#define __GXX_MERGED_TYPEINFO_NAMES 0
+#define __GXX_TYPEINFO_EQUALITY_INLINE 0
 
 #if defined (_GLIBCXX_DLL)
 #define _GLIBCXX_PSEUDO_VISIBILITY_default __attribute__ ((__dllimport__))
@@ -47,6 +49,13 @@
 
 // See libstdc++/20806.
 #define _GLIBCXX_HAVE_DOS_BASED_FILESYSTEM 1
+
+#ifdef _DLL
+#define _GLIBCXX_IMPORT __attribute__((dllimport))
+#else
+#define _GLIBCXX_IMPORT
+#endif
+
 #endif
 
 #endif
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index b64249582..ebf977ae5 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -45520,7 +45520,7 @@ $as_echo "#define HAVE_TLS 1" >>confdefs.h
 	;;
     esac
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu | *-cygwin*)
 
   # All these tests are for C++; save the language and the compiler flags.
   # The CXXFLAGS thing is suspicious, but based on similar bits previously
diff --git a/libstdc++-v3/crossconfig.m4 b/libstdc++-v3/crossconfig.m4
index 361ed0b86..bc25b04c3 100644
--- a/libstdc++-v3/crossconfig.m4
+++ b/libstdc++-v3/crossconfig.m4
@@ -141,7 +141,7 @@ case "${host}" in
 	;;
     esac
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu | *-cygwin*)
     GLIBCXX_CHECK_COMPILER_FEATURES
     GLIBCXX_CHECK_LINKER_FEATURES
     GLIBCXX_CHECK_MATH_SUPPORT
diff --git a/libstdc++-v3/include/backward/strstream b/libstdc++-v3/include/backward/strstream
index 7e18a359c..49412fa9f 100644
--- a/libstdc++-v3/include/backward/strstream
+++ b/libstdc++-v3/include/backward/strstream
@@ -62,7 +62,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   // Class strstreambuf, a streambuf class that manages an array of char.
   // Note that this class is not a template.
-  class strstreambuf : public basic_streambuf<char, char_traits<char> >
+  class _GLIBCXX_IMPORT strstreambuf : public basic_streambuf<char, char_traits<char> >
   {
   public:
     // Types.
@@ -124,7 +124,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   };
 
   // Class istrstream, an istream that manages a strstreambuf.
-  class istrstream : public basic_istream<char>
+  class _GLIBCXX_IMPORT istrstream : public basic_istream<char>
   {
   public:
     explicit istrstream(char*);
@@ -141,7 +141,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   };
 
   // Class ostrstream
-  class ostrstream : public basic_ostream<char>
+  class _GLIBCXX_IMPORT ostrstream : public basic_ostream<char>
   {
   public:
     ostrstream();
@@ -158,7 +158,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   };
 
   // Class strstream
-  class strstream : public basic_iostream<char>
+  class _GLIBCXX_IMPORT strstream : public basic_iostream<char>
   {
   public:
     typedef char                        char_type;
diff --git a/libstdc++-v3/include/bits/basic_ios.tcc b/libstdc++-v3/include/bits/basic_ios.tcc
index 8ac6bfdbe..3adf0f137 100644
--- a/libstdc++-v3/include/bits/basic_ios.tcc
+++ b/libstdc++-v3/include/bits/basic_ios.tcc
@@ -176,10 +176,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_ios<char>;
+  extern template class _GLIBCXX_IMPORT basic_ios<char>;
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_ios<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_ios<wchar_t>;
 #endif
 #endif
 
diff --git a/libstdc++-v3/include/bits/c++config b/libstdc++-v3/include/bits/c++config
index e76e74230..5aa684528 100644
--- a/libstdc++-v3/include/bits/c++config
+++ b/libstdc++-v3/include/bits/c++config
@@ -225,6 +225,9 @@ namespace __gnu_cxx
 # define _GLIBCXX_END_NAMESPACE_VERSION
 #endif
 
+#ifndef _GLIBCXX_IMPORT
+#define _GLIBCXX_IMPORT
+#endif
 
 // Inline namespaces for special modes: debug, parallel, profile.
 #if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL) \
diff --git a/libstdc++-v3/include/bits/codecvt.h b/libstdc++-v3/include/bits/codecvt.h
index f485c170d..666f4eae6 100644
--- a/libstdc++-v3/include/bits/codecvt.h
+++ b/libstdc++-v3/include/bits/codecvt.h
@@ -479,7 +479,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class codecvt_byname<char, char, mbstate_t>;
+  extern template class _GLIBCXX_IMPORT codecvt_byname<char, char, mbstate_t>;
 
   extern template
     const codecvt<char, char, mbstate_t>&
@@ -490,7 +490,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     has_facet<codecvt<char, char, mbstate_t> >(const locale&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
+  extern template class _GLIBCXX_IMPORT codecvt_byname<wchar_t, char, mbstate_t>;
 
   extern template
     const codecvt<wchar_t, char, mbstate_t>&
diff --git a/libstdc++-v3/include/bits/fstream.tcc b/libstdc++-v3/include/bits/fstream.tcc
index 3d5ca62ad..92bc43edc 100644
--- a/libstdc++-v3/include/bits/fstream.tcc
+++ b/libstdc++-v3/include/bits/fstream.tcc
@@ -965,16 +965,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_filebuf<char>;
-  extern template class basic_ifstream<char>;
-  extern template class basic_ofstream<char>;
-  extern template class basic_fstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_filebuf<char>;
+  extern template class _GLIBCXX_IMPORT basic_ifstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_ofstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_fstream<char>;
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_filebuf<wchar_t>;
-  extern template class basic_ifstream<wchar_t>;
-  extern template class basic_ofstream<wchar_t>;
-  extern template class basic_fstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_filebuf<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_ifstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_ofstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_fstream<wchar_t>;
 #endif
 #endif
 
diff --git a/libstdc++-v3/include/bits/ios_base.h b/libstdc++-v3/include/bits/ios_base.h
index ace307cba..359bdd34a 100644
--- a/libstdc++-v3/include/bits/ios_base.h
+++ b/libstdc++-v3/include/bits/ios_base.h
@@ -198,7 +198,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  people will only see @c ios_base when they need to specify the full
    *  name of the various I/O flags (e.g., the openmodes).
   */
-  class ios_base
+  class _GLIBCXX_IMPORT ios_base
   {
   public:
 
@@ -208,7 +208,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
      *
      *  27.4.2.1.1  Class ios_base::failure
      */
-    class failure : public exception
+    class _GLIBCXX_IMPORT failure : public exception
     {
     public:
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
@@ -532,7 +532,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // Used to initialize standard streams. In theory, g++ could use
     // -finit-priority to order this stuff correctly without going
     // through these machinations.
-    class Init
+    class _GLIBCXX_IMPORT Init
     {
       friend class ios_base;
     public:
diff --git a/libstdc++-v3/include/bits/istream.tcc b/libstdc++-v3/include/bits/istream.tcc
index 9055c31ce..ec78a38a4 100644
--- a/libstdc++-v3/include/bits/istream.tcc
+++ b/libstdc++-v3/include/bits/istream.tcc
@@ -1039,7 +1039,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_istream<char>;
+  extern template class _GLIBCXX_IMPORT basic_istream<char>;
   extern template istream& ws(istream&);
   extern template istream& operator>>(istream&, char&);
   extern template istream& operator>>(istream&, char*);
@@ -1062,10 +1062,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   extern template istream& istream::_M_extract(long double&);
   extern template istream& istream::_M_extract(void*&);
 
-  extern template class basic_iostream<char>;
+  extern template class _GLIBCXX_IMPORT basic_iostream<char>;
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_istream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_istream<wchar_t>;
   extern template wistream& ws(wistream&);
   extern template wistream& operator>>(wistream&, wchar_t&);
   extern template wistream& operator>>(wistream&, wchar_t*);
@@ -1084,7 +1084,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   extern template wistream& wistream::_M_extract(long double&);
   extern template wistream& wistream::_M_extract(void*&);
 
-  extern template class basic_iostream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_iostream<wchar_t>;
 #endif
 #endif
 
diff --git a/libstdc++-v3/include/bits/locale_classes.h b/libstdc++-v3/include/bits/locale_classes.h
index 4beca40d3..ae03d5af8 100644
--- a/libstdc++-v3/include/bits/locale_classes.h
+++ b/libstdc++-v3/include/bits/locale_classes.h
@@ -61,7 +61,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  This library supports efficient construction and copying of locales
    *  through a reference counting implementation of the locale class.
   */
-  class locale
+  class _GLIBCXX_IMPORT locale
   {
   public:
     // Types:
@@ -69,9 +69,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     typedef int	category;
 
     // Forward decls and friends:
-    class facet;
-    class id;
-    class _Impl;
+    class _GLIBCXX_IMPORT facet;
+    class _GLIBCXX_IMPORT id;
+    class _GLIBCXX_IMPORT _Impl;
 
     friend class facet;
     friend class _Impl;
@@ -337,7 +337,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *
    *  Facets may not be copied or assigned.
   */
-  class locale::facet
+  class _GLIBCXX_IMPORT locale::facet
   {
   private:
     friend class locale;
@@ -435,7 +435,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  cannot be used in a locale.  The locale::id ensures that each class
    *  type gets a unique identifier.
   */
-  class locale::id
+  class _GLIBCXX_IMPORT locale::id
   {
   private:
     friend class locale;
@@ -474,7 +474,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 
   // Implementation object for locale.
-  class locale::_Impl
+  class _GLIBCXX_IMPORT locale::_Impl
   {
   public:
     // Friends.
diff --git a/libstdc++-v3/include/bits/locale_classes.tcc b/libstdc++-v3/include/bits/locale_classes.tcc
index c796e0eaa..f50061d7c 100644
--- a/libstdc++-v3/include/bits/locale_classes.tcc
+++ b/libstdc++-v3/include/bits/locale_classes.tcc
@@ -265,8 +265,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class collate<char>;
-  extern template class collate_byname<char>;
+  extern template class _GLIBCXX_IMPORT collate<char>;
+  extern template class _GLIBCXX_IMPORT collate_byname<char>;
 
   extern template
     const collate<char>&
@@ -277,8 +277,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     has_facet<collate<char> >(const locale&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class collate<wchar_t>;
-  extern template class collate_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT collate<wchar_t>;
+  extern template class _GLIBCXX_IMPORT collate_byname<wchar_t>;
 
   extern template
     const collate<wchar_t>&
diff --git a/libstdc++-v3/include/bits/locale_facets.h b/libstdc++-v3/include/bits/locale_facets.h
index dc95f5a75..8d73081f8 100644
--- a/libstdc++-v3/include/bits/locale_facets.h
+++ b/libstdc++-v3/include/bits/locale_facets.h
@@ -673,7 +673,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  optimizations as well.
   */
   template<>
-    class ctype<char> : public locale::facet, public ctype_base
+    class _GLIBCXX_IMPORT ctype<char> : public locale::facet, public ctype_base
     {
     public:
       // Types:
@@ -1174,7 +1174,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  __ctype_abstract_base<wchar_t>.
   */
   template<>
-    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
+    class _GLIBCXX_IMPORT ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
     {
     public:
       // Types:
diff --git a/libstdc++-v3/include/bits/locale_facets.tcc b/libstdc++-v3/include/bits/locale_facets.tcc
index 80bda15ac..e19723313 100644
--- a/libstdc++-v3/include/bits/locale_facets.tcc
+++ b/libstdc++-v3/include/bits/locale_facets.tcc
@@ -1277,11 +1277,11 @@ _GLIBCXX_END_NAMESPACE_LDBL
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class numpunct<char>;
-  extern template class numpunct_byname<char>;
-  extern template class _GLIBCXX_NAMESPACE_LDBL num_get<char>;
-  extern template class _GLIBCXX_NAMESPACE_LDBL num_put<char>;
-  extern template class ctype_byname<char>;
+  extern template class _GLIBCXX_IMPORT numpunct<char>;
+  extern template class _GLIBCXX_IMPORT numpunct_byname<char>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_NAMESPACE_LDBL num_get<char>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_NAMESPACE_LDBL num_put<char>;
+  extern template class _GLIBCXX_IMPORT ctype_byname<char>;
 
   extern template
     const ctype<char>&
@@ -1316,11 +1316,11 @@ _GLIBCXX_END_NAMESPACE_LDBL
     has_facet<num_get<char> >(const locale&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class numpunct<wchar_t>;
-  extern template class numpunct_byname<wchar_t>;
-  extern template class _GLIBCXX_NAMESPACE_LDBL num_get<wchar_t>;
-  extern template class _GLIBCXX_NAMESPACE_LDBL num_put<wchar_t>;
-  extern template class ctype_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT numpunct<wchar_t>;
+  extern template class _GLIBCXX_IMPORT numpunct_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_NAMESPACE_LDBL num_get<wchar_t>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_NAMESPACE_LDBL num_put<wchar_t>;
+  extern template class _GLIBCXX_IMPORT ctype_byname<wchar_t>;
 
   extern template
     const ctype<wchar_t>&
diff --git a/libstdc++-v3/include/bits/locale_facets_nonio.tcc b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
index fbf700535..9f8467551 100644
--- a/libstdc++-v3/include/bits/locale_facets_nonio.tcc
+++ b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
@@ -1216,19 +1216,19 @@ _GLIBCXX_END_NAMESPACE_LDBL
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class moneypunct<char, false>;
-  extern template class moneypunct<char, true>;
-  extern template class moneypunct_byname<char, false>;
-  extern template class moneypunct_byname<char, true>;
-  extern template class _GLIBCXX_NAMESPACE_LDBL money_get<char>;
-  extern template class _GLIBCXX_NAMESPACE_LDBL money_put<char>;
-  extern template class __timepunct<char>;
-  extern template class time_put<char>;
-  extern template class time_put_byname<char>;
-  extern template class time_get<char>;
-  extern template class time_get_byname<char>;
-  extern template class messages<char>;
-  extern template class messages_byname<char>;
+  extern template class _GLIBCXX_IMPORT moneypunct<char, false>;
+  extern template class _GLIBCXX_IMPORT moneypunct<char, true>;
+  extern template class _GLIBCXX_IMPORT moneypunct_byname<char, false>;
+  extern template class _GLIBCXX_IMPORT moneypunct_byname<char, true>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_NAMESPACE_LDBL money_get<char>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_NAMESPACE_LDBL money_put<char>;
+  extern template class _GLIBCXX_IMPORT __timepunct<char>;
+  extern template class _GLIBCXX_IMPORT time_put<char>;
+  extern template class _GLIBCXX_IMPORT time_put_byname<char>;
+  extern template class _GLIBCXX_IMPORT time_get<char>;
+  extern template class _GLIBCXX_IMPORT time_get_byname<char>;
+  extern template class _GLIBCXX_IMPORT messages<char>;
+  extern template class _GLIBCXX_IMPORT messages_byname<char>;
 
   extern template
     const moneypunct<char, true>&
@@ -1291,19 +1291,19 @@ _GLIBCXX_END_NAMESPACE_LDBL
     has_facet<messages<char> >(const locale&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class moneypunct<wchar_t, false>;
-  extern template class moneypunct<wchar_t, true>;
-  extern template class moneypunct_byname<wchar_t, false>;
-  extern template class moneypunct_byname<wchar_t, true>;
-  extern template class _GLIBCXX_NAMESPACE_LDBL money_get<wchar_t>;
-  extern template class _GLIBCXX_NAMESPACE_LDBL money_put<wchar_t>;
-  extern template class __timepunct<wchar_t>;
-  extern template class time_put<wchar_t>;
-  extern template class time_put_byname<wchar_t>;
-  extern template class time_get<wchar_t>;
-  extern template class time_get_byname<wchar_t>;
-  extern template class messages<wchar_t>;
-  extern template class messages_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT moneypunct<wchar_t, false>;
+  extern template class _GLIBCXX_IMPORT moneypunct<wchar_t, true>;
+  extern template class _GLIBCXX_IMPORT moneypunct_byname<wchar_t, false>;
+  extern template class _GLIBCXX_IMPORT moneypunct_byname<wchar_t, true>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_NAMESPACE_LDBL money_get<wchar_t>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_NAMESPACE_LDBL money_put<wchar_t>;
+  extern template class _GLIBCXX_IMPORT __timepunct<wchar_t>;
+  extern template class _GLIBCXX_IMPORT time_put<wchar_t>;
+  extern template class _GLIBCXX_IMPORT time_put_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT time_get<wchar_t>;
+  extern template class _GLIBCXX_IMPORT time_get_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT messages<wchar_t>;
+  extern template class _GLIBCXX_IMPORT messages_byname<wchar_t>;
 
   extern template
     const moneypunct<wchar_t, true>&
diff --git a/libstdc++-v3/include/bits/ostream.tcc b/libstdc++-v3/include/bits/ostream.tcc
index c0dce6a23..91a9f6eb4 100644
--- a/libstdc++-v3/include/bits/ostream.tcc
+++ b/libstdc++-v3/include/bits/ostream.tcc
@@ -358,7 +358,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_ostream<char>;
+  extern template class _GLIBCXX_IMPORT basic_ostream<char>;
   extern template ostream& endl(ostream&);
   extern template ostream& ends(ostream&);
   extern template ostream& flush(ostream&);
@@ -381,7 +381,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   extern template ostream& ostream::_M_insert(const void*);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_ostream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_ostream<wchar_t>;
   extern template wostream& endl(wostream&);
   extern template wostream& ends(wostream&);
   extern template wostream& flush(wostream&);
diff --git a/libstdc++-v3/include/bits/sstream.tcc b/libstdc++-v3/include/bits/sstream.tcc
index 89b9a547c..58855ce99 100644
--- a/libstdc++-v3/include/bits/sstream.tcc
+++ b/libstdc++-v3/include/bits/sstream.tcc
@@ -271,16 +271,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_stringbuf<char>;
-  extern template class basic_istringstream<char>;
-  extern template class basic_ostringstream<char>;
-  extern template class basic_stringstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_stringbuf<char>;
+  extern template class _GLIBCXX_IMPORT basic_istringstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_ostringstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_stringstream<char>;
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_stringbuf<wchar_t>;
-  extern template class basic_istringstream<wchar_t>;
-  extern template class basic_ostringstream<wchar_t>;
-  extern template class basic_stringstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_stringbuf<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_istringstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_ostringstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_stringstream<wchar_t>;
 #endif
 #endif
 
diff --git a/libstdc++-v3/include/bits/streambuf.tcc b/libstdc++-v3/include/bits/streambuf.tcc
index 6cb85fc18..f2ee23a86 100644
--- a/libstdc++-v3/include/bits/streambuf.tcc
+++ b/libstdc++-v3/include/bits/streambuf.tcc
@@ -147,7 +147,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_streambuf<char>;
+  extern template class _GLIBCXX_IMPORT basic_streambuf<char>;
   extern template
     streamsize
     __copy_streambufs(basic_streambuf<char>*,
@@ -158,7 +158,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			  basic_streambuf<char>*, bool&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_streambuf<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_streambuf<wchar_t>;
   extern template
     streamsize
     __copy_streambufs(basic_streambuf<wchar_t>*,
diff --git a/libstdc++-v3/include/ext/concurrence.h b/libstdc++-v3/include/ext/concurrence.h
index 18a38368d..2f96ce8a5 100644
--- a/libstdc++-v3/include/ext/concurrence.h
+++ b/libstdc++-v3/include/ext/concurrence.h
@@ -65,7 +65,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   // NB: As this is used in libsupc++, need to only depend on
   // exception. No stdexception classes, no use of std::string.
-  class __concurrence_lock_error : public std::exception
+  class _GLIBCXX_IMPORT __concurrence_lock_error : public std::exception
   {
   public:
     virtual char const*
@@ -73,7 +73,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return "__gnu_cxx::__concurrence_lock_error"; }
   };
 
-  class __concurrence_unlock_error : public std::exception
+  class _GLIBCXX_IMPORT __concurrence_unlock_error : public std::exception
   {
   public:
     virtual char const*
diff --git a/libstdc++-v3/include/std/iostream b/libstdc++-v3/include/std/iostream
index 7c71ba493..6bc15a824 100644
--- a/libstdc++-v3/include/std/iostream
+++ b/libstdc++-v3/include/std/iostream
@@ -58,16 +58,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  linked to above.
   */
   //@{
-  extern istream cin;		/// Linked to standard input
-  extern ostream cout;		/// Linked to standard output
-  extern ostream cerr;		/// Linked to standard error (unbuffered)
-  extern ostream clog;		/// Linked to standard error (buffered)
+  extern _GLIBCXX_IMPORT istream cin;		/// Linked to standard input
+  extern _GLIBCXX_IMPORT ostream cout;		/// Linked to standard output
+  extern _GLIBCXX_IMPORT ostream cerr;		/// Linked to standard error (unbuffered)
+  extern _GLIBCXX_IMPORT ostream clog;		/// Linked to standard error (buffered)
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern wistream wcin;		/// Linked to standard input
-  extern wostream wcout;	/// Linked to standard output
-  extern wostream wcerr;	/// Linked to standard error (unbuffered)
-  extern wostream wclog;	/// Linked to standard error (buffered)
+  extern _GLIBCXX_IMPORT wistream wcin;		/// Linked to standard input
+  extern _GLIBCXX_IMPORT wostream wcout;	/// Linked to standard output
+  extern _GLIBCXX_IMPORT wostream wcerr;	/// Linked to standard error (unbuffered)
+  extern _GLIBCXX_IMPORT wostream wclog;	/// Linked to standard error (buffered)
 #endif
   //@}
 
diff --git a/libstdc++-v3/include/std/stdexcept b/libstdc++-v3/include/std/stdexcept
index 2cbf207df..ee439d993 100644
--- a/libstdc++-v3/include/std/stdexcept
+++ b/libstdc++-v3/include/std/stdexcept
@@ -53,7 +53,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  program runs (e.g., violations of class invariants).
    *  @brief One of two subclasses of exception.
    */
-  class logic_error : public exception 
+  class _GLIBCXX_IMPORT logic_error : public exception
   {
     string _M_msg;
 
@@ -72,7 +72,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   /** Thrown by the library, or by you, to report domain errors (domain in
    *  the mathematical sense).  */
-  class domain_error : public logic_error 
+  class _GLIBCXX_IMPORT domain_error : public logic_error 
   {
   public:
     explicit domain_error(const string& __arg);
@@ -80,7 +80,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   };
 
   /** Thrown to report invalid arguments to functions.  */
-  class invalid_argument : public logic_error 
+  class _GLIBCXX_IMPORT invalid_argument : public logic_error 
   {
   public:
     explicit invalid_argument(const string& __arg);
@@ -89,7 +89,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   /** Thrown when an object is constructed that would exceed its maximum
    *  permitted size (e.g., a basic_string instance).  */
-  class length_error : public logic_error 
+  class _GLIBCXX_IMPORT length_error : public logic_error
   {
   public:
     explicit length_error(const string& __arg);
@@ -98,7 +98,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   /** This represents an argument whose value is not within the expected
    *  range (e.g., boundary checks in basic_string).  */
-  class out_of_range : public logic_error 
+  class _GLIBCXX_IMPORT out_of_range : public logic_error
   {
   public:
     explicit out_of_range(const string& __arg);
@@ -110,7 +110,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  the program executes.
    *  @brief One of two subclasses of exception.
    */
-  class runtime_error : public exception 
+  class _GLIBCXX_IMPORT runtime_error : public exception
   {
     string _M_msg;
 
@@ -128,7 +128,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   };
 
   /** Thrown to indicate range errors in internal computations.  */
-  class range_error : public runtime_error 
+  class _GLIBCXX_IMPORT range_error : public runtime_error
   {
   public:
     explicit range_error(const string& __arg);
@@ -144,7 +144,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   };
 
   /** Thrown to indicate arithmetic underflow.  */
-  class underflow_error : public runtime_error 
+  class _GLIBCXX_IMPORT underflow_error : public runtime_error
   {
   public:
     explicit underflow_error(const string& __arg);
diff --git a/libstdc++-v3/libsupc++/exception b/libstdc++-v3/libsupc++/exception
index 94a0bcbc6..df493e783 100644
--- a/libstdc++-v3/libsupc++/exception
+++ b/libstdc++-v3/libsupc++/exception
@@ -59,7 +59,7 @@ namespace std
    *  your own %exception classes, or use a different hierarchy, or to
    *  throw non-class data (e.g., fundamental types).
    */
-  class exception
+  class _GLIBCXX_IMPORT exception
   {
   public:
     exception() _GLIBCXX_USE_NOEXCEPT { }
@@ -72,7 +72,7 @@ namespace std
 
   /** If an %exception is thrown which is not listed in a function's
    *  %exception specification, one of these may be thrown.  */
-  class bad_exception : public exception
+  class _GLIBCXX_IMPORT bad_exception : public exception
   {
   public:
     bad_exception() _GLIBCXX_USE_NOEXCEPT { }
diff --git a/libstdc++-v3/libsupc++/new b/libstdc++-v3/libsupc++/new
index 1c258002e..a932323c2 100644
--- a/libstdc++-v3/libsupc++/new
+++ b/libstdc++-v3/libsupc++/new
@@ -53,7 +53,7 @@ namespace std
    *
    *  @c bad_alloc (or classes derived from it) is used to report allocation
    *  errors from the throwing forms of @c new.  */
-  class bad_alloc : public exception 
+  class _GLIBCXX_IMPORT bad_alloc : public exception
   {
   public:
     bad_alloc() throw() { }
diff --git a/libstdc++-v3/libsupc++/typeinfo b/libstdc++-v3/libsupc++/typeinfo
index f0382d64f..9b78973bc 100644
--- a/libstdc++-v3/libsupc++/typeinfo
+++ b/libstdc++-v3/libsupc++/typeinfo
@@ -87,7 +87,7 @@ namespace std
    *  The @c type_info class describes type information generated by
    *  an implementation.
   */
-  class type_info
+  class _GLIBCXX_IMPORT type_info
   {
   public:
     /** Destructor first. Being the first non-inline virtual function, this
@@ -186,7 +186,7 @@ namespace std
    *
    *  If you attempt an invalid @c dynamic_cast expression, an instance of
    *  this class (or something derived from this class) is thrown.  */
-  class bad_cast : public exception
+  class _GLIBCXX_IMPORT bad_cast : public exception
   {
   public:
     bad_cast() _GLIBCXX_USE_NOEXCEPT { }
@@ -203,7 +203,7 @@ namespace std
    *  @brief Thrown when a NULL pointer in a @c typeid expression is used.
    *  @ingroup exceptions
    */
-  class bad_typeid : public exception
+  class _GLIBCXX_IMPORT bad_typeid : public exception
   {
   public:
     bad_typeid () _GLIBCXX_USE_NOEXCEPT { }
diff --git a/libstdc++-v3/testsuite/lib/libstdc++.exp b/libstdc++-v3/testsuite/lib/libstdc++.exp
index abb92bf35..cca95d0c3 100644
--- a/libstdc++-v3/testsuite/lib/libstdc++.exp
+++ b/libstdc++-v3/testsuite/lib/libstdc++.exp
@@ -146,6 +146,9 @@ proc libstdc++_init { testfile } {
         set gccdir [file dirname $gccdir]
 	append ld_library_path_tmp ":${gccdir}"
     }
+    if { [string match "*-*-cygwin*" $target_triplet] } {
+	append ld_library_path_tmp ":${blddir}/../libgcc"
+    }
     v3track gccdir 3
 
     # Locate libgomp. This is only required for parallel mode.
