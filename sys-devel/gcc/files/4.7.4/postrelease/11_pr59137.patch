diff --git a/gcc/reorg.c b/gcc/reorg.c
index dfc9747c5..99a02ab91 100644
--- a/gcc/reorg.c
+++ b/gcc/reorg.c
@@ -1249,6 +1249,7 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,
   int used_annul = 0;
   int i;
   struct resources cc_set;
+  bool *redundant;
 
   /* We can't do anything if there are more delay slots in SEQ than we
      can handle, or if we don't know that it will be a taken branch.
@@ -1289,6 +1290,7 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,
     return delay_list;
 #endif
 
+  redundant = XALLOCAVEC (bool, XVECLEN (seq, 0));
   for (i = 1; i < XVECLEN (seq, 0); i++)
     {
       rtx trial = XVECEXP (seq, 0, i);
@@ -1310,7 +1312,8 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,
 
       /* If this insn was already done (usually in a previous delay slot),
 	 pretend we put it in our delay slot.  */
-      if (redundant_insn (trial, insn, new_delay_list))
+      redundant[i] = redundant_insn (trial, insn, new_delay_list);
+      if (redundant[i])
 	continue;
 
       /* We will end up re-vectoring this branch, so compute flags
@@ -1343,6 +1346,12 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,
 	return delay_list;
     }
 
+  /* Record the effect of the instructions that were redundant and which
+     we therefore decided not to copy.  */
+  for (i = 1; i < XVECLEN (seq, 0); i++)
+    if (redundant[i])
+      update_block (XVECEXP (seq, 0, i), insn);
+
   /* Show the place to which we will be branching.  */
   *pnew_thread = first_active_target_insn (JUMP_LABEL (XVECEXP (seq, 0, 0)));
 
@@ -1406,6 +1415,7 @@ steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx seq,
       /* If this insn was already done, we don't need it.  */
       if (redundant_insn (trial, insn, delay_list))
 	{
+	  update_block (trial, insn);
 	  delete_from_delay_slot (trial);
 	  continue;
 	}
@@ -3479,6 +3489,7 @@ relax_delay_slots (rtx first)
 	 to reprocess this insn.  */
       if (redundant_insn (XVECEXP (pat, 0, 1), delay_insn, 0))
 	{
+	  update_block (XVECEXP (pat, 0, 1), insn);
 	  delete_from_delay_slot (XVECEXP (pat, 0, 1));
 	  next = prev_active_insn (next);
 	  continue;
@@ -3596,6 +3607,7 @@ relax_delay_slots (rtx first)
 	      && redirect_with_delay_slots_safe_p (delay_insn, target_label,
 						   insn))
 	    {
+	      update_block (XVECEXP (PATTERN (trial), 0, 1), insn);
 	      reorg_redirect_jump (delay_insn, target_label);
 	      next = insn;
 	      continue;
diff --git a/gcc/testsuite/gcc.target/mips/pr59137.c b/gcc/testsuite/gcc.target/mips/pr59137.c
new file mode 100644
index 000000000..898650656
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/pr59137.c
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+/* { dg-options "-mno-plt" } */
+
+extern void abort (void);
+
+struct lispstruct
+{
+  int e;
+  int t;
+};
+
+struct lispstruct Cnil_body;
+struct lispstruct Ct_body;
+int nvalues;
+
+struct lispstruct * __attribute__ ((noinline))
+fLlistp (struct lispstruct *x0)
+{
+  if (x0 == &Cnil_body
+      || (((unsigned long) x0 >= 0x80000000) ? 0
+	  : (!x0->e ? (x0 != &Cnil_body) : x0->t)))
+    x0 = &Ct_body;
+  else
+    x0 = &Cnil_body;
+  nvalues = 1;
+  return x0;
+}
+
+int main ()
+{
+  if (fLlistp ((struct lispstruct *) 0xa0000001) != &Cnil_body)
+    abort ();
+  return 0;
+}
