diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 84551de5bb2..4f762310920 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,200 @@
+2009-01-31  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* config/pa/fptr.c: Revert license to GPL 2.
+	* config/pa/milli64.S: Likewise.
+
+2009-01-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/linux.h (DBX_REGISTER_NUMBER): Delete.
+	* config/sparc/linux64.h (DBX_REGISTER_NUMBER): Likewise.
+	* config/sparc/sysv4.h (DBX_REGISTER_NUMBER): Likewise.
+
+2009-01-20  Joseph Myers  <joseph@codesourcery.com>
+
+	PR other/38758
+	* longlong.h: Update copyright years.  Use soft-fp license
+	notice.
+
+2009-01-07  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* pa.c (output_call): Relocate non-jump insns in the delay slot of long
+	absolute calls when generating PA 2.0 code.
+
+2008-12-25  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR bootstrap/37295
+	Backport from mainline:
+	2007-08-23  Brian Sidebotham  <brian.sidebotham@gmail.com>
+
+        * configure.ac (leb128): Modify sed statement to work with any
+	binutils version string.
+	* configure: Regenerate
+
+2008-12-04  Eric Botcazou  <ebotcazou@adacore.com>
+            Gary Funck  <gary@intrepid.com>
+
+	* cse.c (lookup_as_function): Delete mode frobbing code.
+	(fold_rtx_subreg): Re-implement it there for SUBREGs.
+
+2008-11-30  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/38287
+	* config/sparc/sparc.md (divsi3 expander): Remove constraints.
+	(divsi3_sp32): Add new alternative with 'K' for operand #2.
+	(cmp_sdiv_cc_set): Factor common string.
+	(udivsi3_sp32): Add new alternative with 'K' for operand #2.
+	Add TARGET_V9 case.
+	(cmp_udiv_cc_set): Factor common string.
+
+2008-11-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.c (TARGET_ASM_OUTPUT_DWARF_DTPREL): Define
+	only if HAVE_AS_SPARC_UA_PCREL is defined.
+
+2008-11-17  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/27574
+	* gcc/cgraph.c (cgraph_remove_node): Do not remove the body of
+	  abstract functions. It might be useful to emit debugging
+	  information. This is a patch from Ian Lance Taylor.
+	* cgraphunit.c (cgraph_optimize): Do not cry when bodies of abstract
+	  functions are still around. They are useful to output debug info.
+
+2008-11-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.c (function_arg_vector_value): Remove 'base_mode'
+	parameter.  Use DImode for computing the number of registers.
+	(function_arg): Adjust for above change.
+	(function_value): Likewise.
+
+2008-11-13  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2008-06-06  Uros Bizjak <ubizjak@gmail.com>
+
+	PR rtl-optimization/36438
+	* cse.c (fold_rtx) [ASHIFT, LSHIFTRT, ASHIFTRT]: Break out early
+	for vector shifts with constant scalar shift operands.
+
+2008-11-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38007
+	* c-common.c (c_common_signed_or_unsigned_type): Remove C++
+	special casing.
+
+2008-11-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2008-11-10  Ralph Loader  <suckfish@ihug.co.nz>
+
+	PR middle-end/37807
+	PR middle-end/37809
+	* combine.c (force_to_mode): Do not process vector types.
+
+	* rtlanal.c (nonzero_bits1): Do not process vector types.
+	(num_sign_bit_copies1): Likewise.
+
+2008-11-06  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	PR bootstrap/33100
+	* config.gcc (i[34567]86-*-solaris2*): Include i386/t-crtstuff
+	only with GNU ld.
+
+2008-10-31  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/37909
+	Backport from mainline:
+	* config/sh/sh.c (untangle_mova): Return -1 when NEW_MOVA has
+	no address.
+
+2008-10-25  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline:
+	* config/sh/t-sh: Use $(MULTILIB_CFLAGS) when compiling to
+	unwind-dw2-Os-4-200.o.
+
+2008-10-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2008-10-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR middle-end/37731
+	* expmed.c (expand_mult): Properly check DImode constant in
+	CONST_DOUBLE.
+
+2008-09-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/36575
+	* fold-const.c (div_and_round_double) <ROUND_DIV_EXPR>: Fix typo.
+
+2008-09-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2008-09-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/37544
+	* regrename.c (maybe_mode_change): Exit early when copy_mode
+	is narrower than orig_mode and narrower than new_mode.
+
+2008-08-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2008-08-14  Christophe Saout  <christophe@saout.de>
+		    Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/37101
+	* config/i386/sse.md (vec_concatv2di): Remove movlps alternative.
+
+2008-08-06  Aldy Hernandez  <aldyh@redhat.com>
+
+	PR middle-end/35432
+	* gimplify.c (gimplify_modify_expr): Do not optimize
+	zero-sized types if want_value.
+
+2008-07-04  Alan Modra  <amodra@bigpond.net.au>
+
+	PR target/36634
+	* config/rs6000/rs6000.md (call, call_value): Don't arrange for
+	pic_offset_table_rtx to be marked as used here.
+	(call_nonlocal_sysv, call_value_nonlocal_sysv): Add split for
+	TARGET_SECURE_PLT to "use" pic_offset_table_rtx.
+	(call_nonlocal_sysv_secure, call_value_nonlocal_sysv_secure): New insn.
+	(sibcall_nonlocal_sysv, sibcall_value_nonlocal_sysv): Assert
+	!TARGET_SECURE_PLT.
+
+2008-06-05  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	* config/mips/mips.c (mips_emit_loadgp): Return early if
+	there is nothing do to, otherwise emit a blockage if
+	!TARGET_EXPLICIT_RELOCS || current_function_profile.
+	* config/mips/mips.md (loadgp_blockage): Use SI rather than DI.
+
+2008-05-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-nested.c (check_for_nested_with_variably_modified): Fix typo.
+
+2008-05-23  Marius Strobl <marius@FreeBSD.org>
+
+	* gthr-posix.h (__gthread_active_p): Use the Solaris implementation
+	for FreeBSD as well.
+	* gthr-posix95.h: Likewise.
+
+2008-05-20  Adam Nemet  <anemet@caviumnetworks.com>
+
+	PR middle-end/36194
+	* combine.c (check_conversion): Rename to check_promoted_subreg.
+	Don't call record_truncated_value from here.
+	(record_truncated_value): Turn it into a for_each_rtx callback.
+	(record_truncated_values): New function.
+	(combine_instructions): Call note_uses with
+	record_truncated_values.  Change name of check_conversion to
+	check_promoted_subreg.
+
+2008-05-20  Joseph Myers  <joseph@codesourcery.com>
+
+	* doc/install.texi2html: Generate gcc-vers.texi in $DESTDIR not
+	$SOURCEDIR/include.
+
 2008-05-19  Release Manager
 
 	* GCC 4.2.4 released.
@@ -2600,7 +2802,7 @@
 	* config/rs6000/rs6000.c (rs6000_function_value): Look at bit size
 	instead of precision.
 
-2007-03-08  Volker Reichelt  <reichelt@netcologne.de>
+2007-03-08  Volker Reichelt  <v.reichelt@netcologne.de>
 
 	PR c++/30852
 	* c-common.c (fold_offsetof_1): Handle COMPOUND_EXPR.
diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
index 13b22a90e13..a8baed44b24 100644
--- a/gcc/DATESTAMP
+++ b/gcc/DATESTAMP
@@ -1 +1 @@
-20080519
+20090330
diff --git a/gcc/c-common.c b/gcc/c-common.c
index 3f17b1b2d11..3a5e8e5b4b7 100644
--- a/gcc/c-common.c
+++ b/gcc/c-common.c
@@ -1843,7 +1843,7 @@ c_common_signed_or_unsigned_type (int unsignedp, tree type)
 
 #define TYPE_OK(node)							    \
   (TYPE_MODE (type) == TYPE_MODE (node)					    \
-   && (c_dialect_cxx () || TYPE_PRECISION (type) == TYPE_PRECISION (node)))
+   && TYPE_PRECISION (type) == TYPE_PRECISION (node))
   if (TYPE_OK (signed_char_type_node))
     return unsignedp ? unsigned_char_type_node : signed_char_type_node;
   if (TYPE_OK (integer_type_node))
@@ -1873,10 +1873,7 @@ c_common_signed_or_unsigned_type (int unsignedp, tree type)
     return unsignedp ? unsigned_intQI_type_node : intQI_type_node;
 #undef TYPE_OK
 
-  if (c_dialect_cxx ())
-    return type;
-  else
-    return build_nonstandard_integer_type (TYPE_PRECISION (type), unsignedp);
+  return build_nonstandard_integer_type (TYPE_PRECISION (type), unsignedp);
 }
 
 /* Build a bit-field integer type for the given WIDTH and UNSIGNEDP.  */
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index b7029d91445..0031893cc99 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -593,6 +593,14 @@ cgraph_remove_node (struct cgraph_node *node)
 	      && (TREE_ASM_WRITTEN (n->decl) || DECL_EXTERNAL (n->decl))))
 	kill_body = true;
     }
+  /* We don't release the body of abstract functions, because they may
+     be needed when emitting debugging information.  In particular
+     this will happen for C++ constructors/destructors.  FIXME:
+     Ideally we would check to see whether there are any reachable
+     functions whose DECL_ABSTRACT_ORIGIN points to this decl.  */
+  if (DECL_ABSTRACT (node->decl))
+    kill_body = false;
+ 
 
   if (kill_body && flag_unit_at_a_time)
     {
diff --git a/gcc/cgraphunit.c b/gcc/cgraphunit.c
index 5e860052630..4d88148db82 100644
--- a/gcc/cgraphunit.c
+++ b/gcc/cgraphunit.c
@@ -1609,7 +1609,10 @@ cgraph_optimize (void)
       for (node = cgraph_nodes; node; node = node->next)
 	if (node->analyzed
 	    && (node->global.inlined_to
-		|| DECL_SAVED_TREE (node->decl)))
+		|| DECL_SAVED_TREE (node->decl))
+            /* Abstract functions are needed to output debug info,
+               so don't complain about them if they are still around.  */
+            && !DECL_ABSTRACT (node->decl))
 	  {
 	    error_found = true;
 	    dump_cgraph_node (stderr, node);
diff --git a/gcc/combine.c b/gcc/combine.c
index 4667b236461..14bac70e58d 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -430,7 +430,7 @@ static rtx gen_lowpart_for_combine (enum machine_mode, rtx);
 static enum rtx_code simplify_comparison (enum rtx_code, rtx *, rtx *);
 static void update_table_tick (rtx);
 static void record_value_for_reg (rtx, rtx, rtx);
-static void check_conversions (rtx, rtx);
+static void check_promoted_subreg (rtx, rtx);
 static void record_dead_and_set_regs_1 (rtx, rtx, void *);
 static void record_dead_and_set_regs (rtx);
 static int get_last_value_validate (rtx *, rtx, int, int);
@@ -447,7 +447,8 @@ static int insn_cuid (rtx);
 static void record_promoted_value (rtx, rtx);
 static int unmentioned_reg_p_1 (rtx *, void *);
 static bool unmentioned_reg_p (rtx, rtx);
-static void record_truncated_value (rtx);
+static int record_truncated_value (rtx *, void *);
+static void record_truncated_values (rtx *, void *);
 static bool reg_truncated_to_mode (enum machine_mode, rtx);
 static rtx gen_lowpart_or_truncate (enum machine_mode, rtx);
 
@@ -819,7 +820,12 @@ combine_instructions (rtx f, unsigned int nregs)
 	    {
 	      /* See if we know about function return values before this
 		 insn based upon SUBREG flags.  */
-	      check_conversions (insn, PATTERN (insn));
+	      check_promoted_subreg (insn, PATTERN (insn));
+
+	      /* See if we can find hardregs and subreg of pseudos in
+		 narrower modes.  This could help turning TRUNCATEs
+		 into SUBREGs.  */
+	      note_uses (&PATTERN (insn), record_truncated_values, NULL);
 
 	      /* Try this insn with each insn it links back to.  */
 
@@ -6902,6 +6908,10 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,
       && (GET_MODE_MASK (GET_MODE (x)) & ~mask) == 0)
     return gen_lowpart (mode, x);
 
+  /* The arithmetic simplifications here do the wrong thing on vector modes.  */
+  if (VECTOR_MODE_P (mode) || VECTOR_MODE_P (GET_MODE (x)))
+    return gen_lowpart (mode, x);
+
   switch (code)
     {
     case CLOBBER:
@@ -11138,13 +11148,15 @@ reg_truncated_to_mode (enum machine_mode mode, rtx x)
   return false;
 }
 
-/* X is a REG or a SUBREG.  If X is some sort of a truncation record
-   it.  For non-TRULY_NOOP_TRUNCATION targets we might be able to turn
-   a truncate into a subreg using this information.  */
+/* Callback for for_each_rtx.  If *P is a hard reg or a subreg record the mode
+   that the register is accessed in.  For non-TRULY_NOOP_TRUNCATION targets we
+   might be able to turn a truncate into a subreg using this information.
+   Return -1 if traversing *P is complete or 0 otherwise.  */
 
-static void
-record_truncated_value (rtx x)
+static int
+record_truncated_value (rtx *p, void *data ATTRIBUTE_UNUSED)
 {
+  rtx x = *p;
   enum machine_mode truncated_mode;
 
   if (GET_CODE (x) == SUBREG && REG_P (SUBREG_REG (x)))
@@ -11153,11 +11165,11 @@ record_truncated_value (rtx x)
       truncated_mode = GET_MODE (x);
 
       if (GET_MODE_SIZE (original_mode) <= GET_MODE_SIZE (truncated_mode))
-	return;
+	return -1;
 
       if (TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (truncated_mode),
 				 GET_MODE_BITSIZE (original_mode)))
-	return;
+	return -1;
 
       x = SUBREG_REG (x);
     }
@@ -11166,7 +11178,7 @@ record_truncated_value (rtx x)
   else if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)
     truncated_mode = GET_MODE (x);
   else
-    return;
+    return 0;
 
   if (reg_stat[REGNO (x)].truncated_to_mode == 0
       || reg_stat[REGNO (x)].truncation_label < label_tick
@@ -11176,23 +11188,30 @@ record_truncated_value (rtx x)
       reg_stat[REGNO (x)].truncated_to_mode = truncated_mode;
       reg_stat[REGNO (x)].truncation_label = label_tick;
     }
+
+  return -1;
 }
 
-/* Scan X for promoted SUBREGs and truncated REGs.  For each one
-   found, note what it implies to the registers used in it.  */
+/* Callback for note_uses.  Find hardregs and subregs of pseudos and
+   the modes they are used in.  This can help truning TRUNCATEs into
+   SUBREGs.  */
 
 static void
-check_conversions (rtx insn, rtx x)
+record_truncated_values (rtx *x, void *data ATTRIBUTE_UNUSED)
 {
-  if (GET_CODE (x) == SUBREG || REG_P (x))
-    {
-      if (GET_CODE (x) == SUBREG
-	  && SUBREG_PROMOTED_VAR_P (x)
-	  && REG_P (SUBREG_REG (x)))
-	record_promoted_value (insn, x);
+  for_each_rtx (x, record_truncated_value, NULL);
+}
 
-      record_truncated_value (x);
-    }
+/* Scan X for promoted SUBREGs.  For each one found,
+   note what it implies to the registers used in it.  */
+
+static void
+check_promoted_subreg (rtx insn, rtx x)
+{
+  if (GET_CODE (x) == SUBREG
+      && SUBREG_PROMOTED_VAR_P (x)
+      && REG_P (SUBREG_REG (x)))
+    record_promoted_value (insn, x);
   else
     {
       const char *format = GET_RTX_FORMAT (GET_CODE (x));
@@ -11202,13 +11221,13 @@ check_conversions (rtx insn, rtx x)
 	switch (format[i])
 	  {
 	  case 'e':
-	    check_conversions (insn, XEXP (x, i));
+	    check_promoted_subreg (insn, XEXP (x, i));
 	    break;
 	  case 'V':
 	  case 'E':
 	    if (XVEC (x, i) != 0)
 	      for (j = 0; j < XVECLEN (x, i); j++)
-		check_conversions (insn, XVECEXP (x, i, j));
+		check_promoted_subreg (insn, XVECEXP (x, i, j));
 	    break;
 	  }
     }
diff --git a/gcc/config.gcc b/gcc/config.gcc
index a997172294b..66661e0fb14 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -1,6 +1,6 @@
 # GCC target-specific configuration file.
-# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
-# Free Software Foundation, Inc.
+# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
+# 2008 Free Software Foundation, Inc.
 
 #This file is part of GCC.
 
@@ -1207,7 +1207,10 @@ i[34567]86-*-solaris2*)
 	*-*-solaris2.1[0-9]*)
 		tm_file="${tm_file} i386/x86-64.h i386/sol2-10.h"
 		tm_defines="${tm_defines} TARGET_BI_ARCH=1"
-		tmake_file="$tmake_file i386/t-crtstuff i386/t-sol2-10"
+		tmake_file="$tmake_file i386/t-sol2-10"
+		if test x$gnu_ld = xyes; then
+			tmake_file="$tmake_file i386/t-crtstuff"
+		fi
 		need_64bit_hwint=yes
 		# FIXME: -m64 for i[34567]86-*-* should be allowed just
 		# like -m32 for x86_64-*-*.
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 0055acdbc08..440934a9277 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -3576,20 +3576,19 @@
    (set_attr "mode" "TI,V4SF,V2SF")])
 
 (define_insn "*vec_concatv2di"
-  [(set (match_operand:V2DI 0 "register_operand"     "=Y,?Y,Y,x,x,x")
+  [(set (match_operand:V2DI 0 "register_operand"     "=Y,?Y,Y,x,x")
 	(vec_concat:V2DI
-	  (match_operand:DI 1 "nonimmediate_operand" " m,*y,0,0,0,m")
-	  (match_operand:DI 2 "vector_move_operand"  " C, C,Y,x,m,0")))]
+	  (match_operand:DI 1 "nonimmediate_operand" " m,*y,0,0,0")
+	  (match_operand:DI 2 "vector_move_operand"  " C, C,Y,x,m")))]
   "TARGET_SSE"
   "@
    movq\t{%1, %0|%0, %1}
    movq2dq\t{%1, %0|%0, %1}
    punpcklqdq\t{%2, %0|%0, %2}
    movlhps\t{%2, %0|%0, %2}
-   movhps\t{%2, %0|%0, %2}
-   movlps\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssemov,ssemov,sselog,ssemov,ssemov,ssemov")
-   (set_attr "mode" "TI,TI,TI,V4SF,V2SF,V2SF")])
+   movhps\t{%2, %0|%0, %2}"
+  [(set_attr "type" "ssemov,ssemov,sselog,ssemov,ssemov")
+   (set_attr "mode" "TI,TI,TI,V4SF,V2SF")])
 
 (define_expand "vec_setv2di"
   [(match_operand:V2DI 0 "register_operand" "")
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index 1abbe49355b..ff020bf9349 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -6709,13 +6709,16 @@ mips_emit_loadgp (void)
       offset = mips_unspec_address (addr, SYMBOL_GOTOFF_LOADGP);
       incoming_address = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);
       emit_insn (gen_loadgp (offset, incoming_address));
-      if (!TARGET_EXPLICIT_RELOCS)
-	emit_insn (gen_loadgp_blockage ());
       break;
 
     default:
-      break;
+      return;
     }
+  /* Emit a blockage if there are implicit uses of the GP register.
+     This includes profiled functions, because FUNCTION_PROFILE uses
+     a jal macro.  */
+  if (!TARGET_EXPLICIT_RELOCS || current_function_profile)
+    emit_insn (gen_loadgp_blockage ());
 }
 
 /* Set up the stack and frame (if desired) for the function.  */
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index f22043416b4..6a940d53ad1 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -4037,12 +4037,11 @@
 }
   [(set_attr "length" "8")])
 
-;; The use of gp is hidden when not using explicit relocations.
 ;; This blockage instruction prevents the gp load from being
 ;; scheduled after an implicit use of gp.  It also prevents
 ;; the load from being deleted as dead.
 (define_insn "loadgp_blockage"
-  [(unspec_volatile [(reg:DI 28)] UNSPEC_BLOCKAGE)]
+  [(unspec_volatile [(reg:SI 28)] UNSPEC_BLOCKAGE)]
   ""
   ""
   [(set_attr "type"	"unknown")
diff --git a/gcc/config/pa/fptr.c b/gcc/config/pa/fptr.c
index d8f6ab103b1..af207a3b850 100644
--- a/gcc/config/pa/fptr.c
+++ b/gcc/config/pa/fptr.c
@@ -6,7 +6,7 @@ This file is part of GCC.
 
 GCC is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free
-Software Foundation; either version 3, or (at your option) any later
+Software Foundation; either version 2, or (at your option) any later
 version.
 
 In addition to the permissions in the GNU General Public License, the
@@ -24,8 +24,9 @@ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 for more details.
 
 You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.  */
 
 /* WARNING: The code is this function depends on internal and undocumented
    details of the GNU linker and dynamic loader as implemented for parisc
diff --git a/gcc/config/pa/milli64.S b/gcc/config/pa/milli64.S
index 638b51aa07a..1b302c2a9fb 100644
--- a/gcc/config/pa/milli64.S
+++ b/gcc/config/pa/milli64.S
@@ -8,7 +8,7 @@ This file is part of GCC.
 
 GCC is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free
-Software Foundation; either version 3, or (at your option) any later
+Software Foundation; either version 2, or (at your option) any later
 version.
 
 In addition to the permissions in the GNU General Public License, the
@@ -26,8 +26,9 @@ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 for more details.
 
 You should have received a copy of the GNU General Public License
-	along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.  */
 
 #ifdef pa64
         .level  2.0w
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
index 5d3689cad3c..91ec2dc3c2b 100644
--- a/gcc/config/pa/pa.c
+++ b/gcc/config/pa/pa.c
@@ -7462,7 +7462,9 @@ output_call (rtx insn, rtx call_dest, int sibcall)
 	  if (seq_length != 0
 	      && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN
 	      && !sibcall
-	      && (!TARGET_PA_20 || indirect_call))
+	      && (!TARGET_PA_20
+		  || indirect_call
+		  || ((TARGET_LONG_ABS_CALL || local_call) && !flag_pic)))
 	    {
 	      /* A non-jump insn in the delay slot.  By definition we can
 		 emit this insn before the call (and in fact before argument
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index 865690d10ab..eab399b228f 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -10379,25 +10379,6 @@
 
   operands[0] = XEXP (operands[0], 0);
 
-  if (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT
-      && flag_pic
-      && GET_CODE (operands[0]) == SYMBOL_REF
-      && !SYMBOL_REF_LOCAL_P (operands[0]))
-    {
-      rtx call;
-      rtvec tmp;
-
-      tmp = gen_rtvec (3,
-		       gen_rtx_CALL (VOIDmode,
-				     gen_rtx_MEM (SImode, operands[0]),
-				     operands[1]),
-		       gen_rtx_USE (VOIDmode, operands[2]),
-		       gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (SImode)));
-      call = emit_call_insn (gen_rtx_PARALLEL (VOIDmode, tmp));
-      use_reg (&CALL_INSN_FUNCTION_USAGE (call), pic_offset_table_rtx);
-      DONE;
-    }
-
   if (GET_CODE (operands[0]) != SYMBOL_REF
       || (DEFAULT_ABI == ABI_AIX && !SYMBOL_REF_FUNCTION_P (operands[0]))
       || (DEFAULT_ABI != ABI_DARWIN && (INTVAL (operands[2]) & CALL_LONG) != 0))
@@ -10449,28 +10430,6 @@
 
   operands[1] = XEXP (operands[1], 0);
 
-  if (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT
-      && flag_pic
-      && GET_CODE (operands[1]) == SYMBOL_REF
-      && !SYMBOL_REF_LOCAL_P (operands[1]))
-    {
-      rtx call;
-      rtvec tmp;
-
-      tmp = gen_rtvec (3,
-		       gen_rtx_SET (VOIDmode,
-				    operands[0],
-				    gen_rtx_CALL (VOIDmode,
-						  gen_rtx_MEM (SImode,
-							       operands[1]),
-						  operands[2])),
-		       gen_rtx_USE (VOIDmode, operands[3]),
-		       gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (SImode)));
-      call = emit_call_insn (gen_rtx_PARALLEL (VOIDmode, tmp));
-      use_reg (&CALL_INSN_FUNCTION_USAGE (call), pic_offset_table_rtx);
-      DONE;
-    }
-
   if (GET_CODE (operands[1]) != SYMBOL_REF
       || (DEFAULT_ABI == ABI_AIX && !SYMBOL_REF_FUNCTION_P (operands[1]))
       || (DEFAULT_ABI != ABI_DARWIN && (INTVAL (operands[3]) & CALL_LONG) != 0))
@@ -10726,7 +10685,7 @@
   [(set_attr "type" "jmpreg,jmpreg,jmpreg,jmpreg")
    (set_attr "length" "4,4,8,8")])
 
-(define_insn "*call_nonlocal_sysv<mode>"
+(define_insn_and_split "*call_nonlocal_sysv<mode>"
   [(call (mem:SI (match_operand:P 0 "symbol_ref_operand" "s,s"))
 	 (match_operand 1 "" "g,g"))
    (use (match_operand:SI 2 "immediate_operand" "O,n"))
@@ -10746,17 +10705,51 @@
 #else
   if (DEFAULT_ABI == ABI_V4 && flag_pic)
     {
-      if (TARGET_SECURE_PLT && flag_pic == 2)
-	/* The magic 32768 offset here and in the other sysv call insns
-	   corresponds to the offset of r30 in .got2, as given by LCTOC1.
-	   See sysv4.h:toc_section.  */
-	return "bl %z0+32768@plt";
-      else
-	return "bl %z0@plt";
+      gcc_assert (!TARGET_SECURE_PLT);
+      return "bl %z0@plt";
     }
   else
     return "bl %z0";
 #endif
+}
+  "DEFAULT_ABI == ABI_V4
+   && TARGET_SECURE_PLT && flag_pic && !SYMBOL_REF_LOCAL_P (operands[0])
+   && (INTVAL (operands[2]) & CALL_LONG) == 0"
+  [(parallel [(call (mem:SI (match_dup 0))
+		    (match_dup 1))
+	      (use (match_dup 2))
+	      (use (match_dup 3))
+	      (clobber (match_dup 4))])]
+{
+  operands[4] = operands[3];
+  operands[3] = pic_offset_table_rtx;
+}
+  [(set_attr "type" "branch,branch")
+   (set_attr "length" "4,8")])
+
+(define_insn "*call_nonlocal_sysv_secure<mode>"
+  [(call (mem:SI (match_operand:P 0 "symbol_ref_operand" "s,s"))
+	 (match_operand 1 "" "g,g"))
+   (use (match_operand:SI 2 "immediate_operand" "O,n"))
+   (use (match_operand:SI 3 "register_operand" "r,r"))
+   (clobber (match_scratch:SI 4 "=l,l"))]
+  "(DEFAULT_ABI == ABI_V4
+    && TARGET_SECURE_PLT && flag_pic && !SYMBOL_REF_LOCAL_P (operands[0])
+    && (INTVAL (operands[2]) & CALL_LONG) == 0)"
+{
+  if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)
+    output_asm_insn ("crxor 6,6,6", operands);
+
+  else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)
+    output_asm_insn ("creqv 6,6,6", operands);
+
+  if (flag_pic == 2)
+    /* The magic 32768 offset here and in the other sysv call insns
+       corresponds to the offset of r30 in .got2, as given by LCTOC1.
+       See sysv4.h:toc_section.  */
+    return "bl %z0+32768@plt";
+  else
+    return "bl %z0@plt";
 }
   [(set_attr "type" "branch,branch")
    (set_attr "length" "4,8")])
@@ -10781,7 +10774,7 @@
   [(set_attr "type" "jmpreg,jmpreg,jmpreg,jmpreg")
    (set_attr "length" "4,4,8,8")])
 
-(define_insn "*call_value_nonlocal_sysv<mode>"
+(define_insn_and_split "*call_value_nonlocal_sysv<mode>"
   [(set (match_operand 0 "" "")
 	(call (mem:SI (match_operand:P 1 "symbol_ref_operand" "s,s"))
 	      (match_operand 2 "" "g,g")))
@@ -10802,14 +10795,50 @@
 #else
   if (DEFAULT_ABI == ABI_V4 && flag_pic)
     {
-      if (TARGET_SECURE_PLT && flag_pic == 2)
-	return "bl %z1+32768@plt";
-      else
-	return "bl %z1@plt";
+      gcc_assert (!TARGET_SECURE_PLT);
+      return "bl %z1@plt";
     }
   else
     return "bl %z1";
 #endif
+}
+  "DEFAULT_ABI == ABI_V4
+   && TARGET_SECURE_PLT && flag_pic && !SYMBOL_REF_LOCAL_P (operands[1])
+   && (INTVAL (operands[3]) & CALL_LONG) == 0"
+  [(parallel [(set (match_dup 0)
+		   (call (mem:SI (match_dup 1))
+			 (match_dup 2)))
+	      (use (match_dup 3))
+	      (use (match_dup 4))
+	      (clobber (match_dup 5))])]
+{
+  operands[5] = operands[4];
+  operands[4] = pic_offset_table_rtx;
+}
+  [(set_attr "type" "branch,branch")
+   (set_attr "length" "4,8")])
+
+(define_insn "*call_value_nonlocal_sysv_secure<mode>"
+  [(set (match_operand 0 "" "")
+	(call (mem:SI (match_operand:P 1 "symbol_ref_operand" "s,s"))
+	      (match_operand 2 "" "g,g")))
+   (use (match_operand:SI 3 "immediate_operand" "O,n"))
+   (use (match_operand:SI 4 "register_operand" "r,r"))
+   (clobber (match_scratch:SI 5 "=l,l"))]
+  "(DEFAULT_ABI == ABI_V4
+    && TARGET_SECURE_PLT && flag_pic && !SYMBOL_REF_LOCAL_P (operands[1])
+    && (INTVAL (operands[3]) & CALL_LONG) == 0)"
+{
+  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)
+    output_asm_insn ("crxor 6,6,6", operands);
+
+  else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)
+    output_asm_insn ("creqv 6,6,6", operands);
+
+  if (flag_pic == 2)
+    return "bl %z1+32768@plt";
+  else
+    return "bl %z1@plt";
 }
   [(set_attr "type" "branch,branch")
    (set_attr "length" "4,8")])
@@ -11025,10 +11054,8 @@
 
   if (DEFAULT_ABI == ABI_V4 && flag_pic)
     {
-      if (TARGET_SECURE_PLT && flag_pic == 2)
-	return \"b %z0+32768@plt\";
-      else
-	return \"b %z0@plt\";
+      gcc_assert (!TARGET_SECURE_PLT);
+      return \"b %z0@plt\";
     }
   else
     return \"b %z0\";
@@ -11079,10 +11106,8 @@
 
   if (DEFAULT_ABI == ABI_V4 && flag_pic)
     {
-      if (TARGET_SECURE_PLT && flag_pic == 2)
-	return \"b %z1+32768@plt\";
-      else
-	return \"b %z1@plt\";
+      gcc_assert (!TARGET_SECURE_PLT);
+      return \"b %z1@plt\";
     }
   else
     return \"b %z1\";
diff --git a/gcc/config/sh/sh.c b/gcc/config/sh/sh.c
index 43efeb3f744..ac2ab5c2cf5 100644
--- a/gcc/config/sh/sh.c
+++ b/gcc/config/sh/sh.c
@@ -3477,6 +3477,10 @@ untangle_mova (int *num_mova, rtx *first_mova, rtx new_mova)
 
   if (optimize)
     {
+      /* If NEW_MOVA has no address yet, it will be handled later.  */
+      if (INSN_ADDRESSES_SIZE() <= (unsigned) INSN_UID (new_mova))
+	return -1;
+
       n_addr = INSN_ADDRESSES (INSN_UID (new_mova));
       n_target = INSN_ADDRESSES (INSN_UID (XEXP (MOVA_LABELREF (new_mova), 0)));
       if (n_addr > n_target || n_addr + 1022 < n_target)
diff --git a/gcc/config/sh/t-sh b/gcc/config/sh/t-sh
index 3ebc09d6e3c..6190b1399c9 100644
--- a/gcc/config/sh/t-sh
+++ b/gcc/config/sh/t-sh
@@ -99,7 +99,7 @@ $(T)sdivsi3_i4i-Os-4-200.o: $(srcdir)/config/sh/lib1funcs-Os-4-200.asm $(GCC_PAS
 $(T)udivsi3_i4i-Os-4-200.o: $(srcdir)/config/sh/lib1funcs-Os-4-200.asm $(GCC_PASSES)
 	$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $@ -DL_udivsi3_i4i -x assembler-with-cpp $<
 $(T)unwind-dw2-Os-4-200.o: $(srcdir)/unwind-dw2.c $(srcdir)/unwind-generic.h unwind-pe.h unwind.inc unwind-dw2-fde.h unwind-dw2.h $(CONFIG_H) coretypes.h $(TM_H) $(MACHMODE_H) longlong.h config.status stmp-int-hdrs tsystem.h $(GCC_PASSES)
-	$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) $(vis_hide) -fexceptions -Os -c -o $@ $<
+	$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) $(LIBGCC2_CFLAGS) $(INCLUDES) $(vis_hide) -fexceptions -Os -c -o $@ $<
 OBJS_Os_4_200=$(T)sdivsi3_i4i-Os-4-200.o $(T)udivsi3_i4i-Os-4-200.o $(T)unwind-dw2-Os-4-200.o
 $(T)libgcc-Os-4-200.a: $(OBJS_Os_4_200) $(GCC_PASSES)
 	$(AR_CREATE_FOR_TARGET) $@ $(OBJS_Os_4_200)
diff --git a/gcc/config/sparc/linux.h b/gcc/config/sparc/linux.h
index 343f1422898..aae07fbb28e 100644
--- a/gcc/config/sparc/linux.h
+++ b/gcc/config/sparc/linux.h
@@ -148,10 +148,6 @@ along with GCC; see the file COPYING3.  If not see
   "%{V} %{v:%{!V:-V}} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Wa,*:%*} -s \
    %{fpic|fPIC|fpie|fPIE:-K PIC} %(asm_cpu) %(asm_relax)"
 
-/* Same as sparc.h */
-#undef DBX_REGISTER_NUMBER
-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)
-
 #undef ASM_OUTPUT_ALIGNED_LOCAL
 #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
 do {									\
diff --git a/gcc/config/sparc/linux64.h b/gcc/config/sparc/linux64.h
index 4dffc9721cf..4562b884dae 100644
--- a/gcc/config/sparc/linux64.h
+++ b/gcc/config/sparc/linux64.h
@@ -284,10 +284,6 @@ along with GCC; see the file COPYING3.  If not see
 %{mlittle-endian:-EL} \
 %(asm_cpu) %(asm_arch) %(asm_relax)"
 
-/* Same as sparc.h */
-#undef DBX_REGISTER_NUMBER
-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)
-
 #undef ASM_OUTPUT_ALIGNED_LOCAL
 #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
 do {									\
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 836096470cb..fc1d13f3677 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -546,7 +546,7 @@ static bool fpu_option_set = false;
 #undef TARGET_HANDLE_OPTION
 #define TARGET_HANDLE_OPTION sparc_handle_option
 
-#if TARGET_GNU_TLS
+#if TARGET_GNU_TLS && defined(HAVE_AS_SPARC_UA_PCREL)
 #undef TARGET_ASM_OUTPUT_DWARF_DTPREL
 #define TARGET_ASM_OUTPUT_DWARF_DTPREL sparc_output_dwarf_dtprel
 #endif
@@ -5026,15 +5026,13 @@ function_arg_union_value (int size, enum machine_mode mode, int slotno,
    Return an expression valid as a return value for the two macros
    FUNCTION_ARG and FUNCTION_VALUE.
 
-   SIZE is the size in bytes of the vector.
-   BASE_MODE is the argument's base machine mode.
+   SIZE is the size in bytes of the vector (at least 8 bytes).
    REGNO is the FP hard register the vector will be passed in.  */
 
 static rtx
-function_arg_vector_value (int size, enum machine_mode base_mode, int regno)
+function_arg_vector_value (int size, int regno)
 {
-  unsigned short base_mode_size = GET_MODE_SIZE (base_mode);
-  int nregs = size / base_mode_size, i;
+  int i, nregs = size / 8;
   rtx regs;
 
   regs = gen_rtx_PARALLEL (BLKmode, rtvec_alloc (nregs));
@@ -5043,9 +5041,8 @@ function_arg_vector_value (int size, enum machine_mode base_mode, int regno)
     {
       XVECEXP (regs, 0, i)
 	= gen_rtx_EXPR_LIST (VOIDmode,
-			     gen_rtx_REG (base_mode, regno),
-			     GEN_INT (base_mode_size * i));
-      regno += base_mode_size / 4;
+			     gen_rtx_REG (DImode, regno + 2*i),
+			     GEN_INT (i*8));
     }
 
   return regs;
@@ -5091,7 +5088,6 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,
 
       if (mode == BLKmode)
 	return function_arg_vector_value (size,
-					  TYPE_MODE (TREE_TYPE (type)),
 					  SPARC_FP_ARG_FIRST + 2*slotno);
       else
 	mclass = MODE_FLOAT;
@@ -5507,7 +5503,6 @@ function_value (tree type, enum machine_mode mode, int incoming_p)
 
       if (mode == BLKmode)
 	return function_arg_vector_value (size,
-					  TYPE_MODE (TREE_TYPE (type)),
 					  SPARC_FP_ARG_FIRST);
       else
 	mclass = MODE_FLOAT;
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 8a03187466f..14c9028af4d 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -5070,14 +5070,11 @@
   [(set_attr "type" "multi")
    (set_attr "length" "2")])
 
-;; The V8 architecture specifies that there must be 3 instructions between
-;; a Y register write and a use of it for correct results.
-
 (define_expand "divsi3"
-  [(parallel [(set (match_operand:SI 0 "register_operand" "=r,r")
-		   (div:SI (match_operand:SI 1 "register_operand" "r,r")
-			   (match_operand:SI 2 "input_operand" "rI,m")))
-	      (clobber (match_scratch:SI 3 "=&r,&r"))])]
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (div:SI (match_operand:SI 1 "register_operand" "")
+			   (match_operand:SI 2 "input_operand" "")))
+	      (clobber (match_scratch:SI 3 ""))])]
   "TARGET_V8 || TARGET_DEPRECATED_V8_INSNS"
 {
   if (TARGET_ARCH64)
@@ -5090,24 +5087,40 @@
     }
 })
 
+;; The V8 architecture specifies that there must be at least 3 instructions
+;; between a write to the Y register and a use of it for correct results.
+;; We try to fill one of them with a simple constant or a memory load.
+
 (define_insn "divsi3_sp32"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(div:SI (match_operand:SI 1 "register_operand" "r,r")
-		(match_operand:SI 2 "input_operand" "rI,m")))
-   (clobber (match_scratch:SI 3 "=&r,&r"))]
-  "(TARGET_V8 || TARGET_DEPRECATED_V8_INSNS)
-   && TARGET_ARCH32"
-{
-  if (which_alternative == 0)
-    if (TARGET_V9)
-      return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tsdiv\t%1, %2, %0";
-    else
-      return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tnop\n\tnop\n\tnop\n\tsdiv\t%1, %2, %0";
-  else
-    if (TARGET_V9)
-      return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tld\t%2, %3\n\tsdiv\t%1, %3, %0";
-    else
-      return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tld\t%2, %3\n\tnop\n\tnop\n\tsdiv\t%1, %3, %0";
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
+	(div:SI (match_operand:SI 1 "register_operand" "r,r,r")
+		(match_operand:SI 2 "input_operand" "rI,K,m")))
+   (clobber (match_scratch:SI 3 "=&r,&r,&r"))]
+  "(TARGET_V8 || TARGET_DEPRECATED_V8_INSNS) && TARGET_ARCH32"
+{
+  output_asm_insn ("sra\t%1, 31, %3", operands);
+  output_asm_insn ("wr\t%3, 0, %%y", operands);
+
+  switch (which_alternative)
+    {
+    case 0:
+      if (TARGET_V9)
+	return "sdiv\t%1, %2, %0";
+      else
+	return "nop\n\tnop\n\tnop\n\tsdiv\t%1, %2, %0";
+    case 1:
+      if (TARGET_V9)
+	return "sethi\t%%hi(%a2), %3\n\tsdiv\t%1, %3, %0";
+      else
+	return "sethi\t%%hi(%a2), %3\n\tnop\n\tnop\n\tsdiv\t%1, %3, %0";
+    case 2:
+      if (TARGET_V9)
+	return "ld\t%2, %3\n\tsdiv\t%1, %3, %0";
+      else
+	return "ld\t%2, %3\n\tnop\n\tnop\n\tsdiv\t%1, %3, %0";
+    default:
+      gcc_unreachable ();
+    }
 }
   [(set_attr "type" "multi")
    (set (attr "length")
@@ -5142,10 +5155,13 @@
    (clobber (match_scratch:SI 3 "=&r"))]
   "TARGET_V8 || TARGET_DEPRECATED_V8_INSNS"
 {
+  output_asm_insn ("sra\t%1, 31, %3", operands);
+  output_asm_insn ("wr\t%3, 0, %%y", operands);
+
   if (TARGET_V9)
-    return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tsdivcc\t%1, %2, %0";
+    return "sdivcc\t%1, %2, %0";
   else
-    return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tnop\n\tnop\n\tnop\n\tsdivcc\t%1, %2, %0";
+    return "nop\n\tnop\n\tnop\n\tsdivcc\t%1, %2, %0";
 }
   [(set_attr "type" "multi")
    (set (attr "length")
@@ -5160,29 +5176,48 @@
   "TARGET_V8 || TARGET_DEPRECATED_V8_INSNS"
   "")
 
-;; The V8 architecture specifies that there must be 3 instructions between
-;; a Y register write and a use of it for correct results.
+;; The V8 architecture specifies that there must be at least 3 instructions
+;; between a write to the Y register and a use of it for correct results.
+;; We try to fill one of them with a simple constant or a memory load.
 
 (define_insn "udivsi3_sp32"
-  [(set (match_operand:SI 0 "register_operand" "=r,&r,&r")
-	(udiv:SI (match_operand:SI 1 "nonimmediate_operand" "r,r,m")
-		 (match_operand:SI 2 "input_operand" "rI,m,r")))]
-  "(TARGET_V8 || TARGET_DEPRECATED_V8_INSNS)
-   && TARGET_ARCH32"
+  [(set (match_operand:SI 0 "register_operand" "=r,&r,&r,&r")
+	(udiv:SI (match_operand:SI 1 "nonimmediate_operand" "r,r,r,m")
+		 (match_operand:SI 2 "input_operand" "rI,K,m,r")))]
+  "(TARGET_V8 || TARGET_DEPRECATED_V8_INSNS) && TARGET_ARCH32"
 {
-  output_asm_insn ("wr\t%%g0, %%g0, %%y", operands);
+  output_asm_insn ("wr\t%%g0, 0, %%y", operands);
+
   switch (which_alternative)
     {
-    default:
-      return "nop\n\tnop\n\tnop\n\tudiv\t%1, %2, %0";
+    case 0:
+      if (TARGET_V9)
+	return "udiv\t%1, %2, %0";
+      else
+	return "nop\n\tnop\n\tnop\n\tudiv\t%1, %2, %0";
     case 1:
-      return "ld\t%2, %0\n\tnop\n\tnop\n\tudiv\t%1, %0, %0";
+      if (TARGET_V9)
+	return "sethi\t%%hi(%a2), %0\n\tudiv\t%1, %0, %0";
+      else
+	return "sethi\t%%hi(%a2), %0\n\tnop\n\tnop\n\tudiv\t%1, %0, %0";
     case 2:
-      return "ld\t%1, %0\n\tnop\n\tnop\n\tudiv\t%0, %2, %0";
+      if (TARGET_V9)
+	return "ld\t%2, %0\n\tudiv\t%1, %0, %0";
+      else
+	return "ld\t%2, %0\n\tnop\n\tnop\n\tudiv\t%1, %0, %0";
+    case 3:
+      if (TARGET_V9)
+	return "ld\t%1, %0\n\tudiv\t%0, %2, %0";
+      else
+	return "ld\t%1, %0\n\tnop\n\tnop\n\tudiv\t%0, %2, %0";
+    default:
+      gcc_unreachable ();
     }
 }
   [(set_attr "type" "multi")
-   (set_attr "length" "5")])
+   (set (attr "length")
+	(if_then_else (eq_attr "isa" "v9")
+		      (const_int 3) (const_int 5)))])
 
 (define_insn "udivsi3_sp64"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -5208,13 +5243,14 @@
 		    (const_int 0)))
    (set (match_operand:SI 0 "register_operand" "=r")
 	(udiv:SI (match_dup 1) (match_dup 2)))]
-  "TARGET_V8
-   || TARGET_DEPRECATED_V8_INSNS"
+  "TARGET_V8 || TARGET_DEPRECATED_V8_INSNS"
 {
+  output_asm_insn ("wr\t%%g0, 0, %%y", operands);
+
   if (TARGET_V9)
-    return "wr\t%%g0, %%g0, %%y\n\tudivcc\t%1, %2, %0";
+    return "udivcc\t%1, %2, %0";
   else
-    return "wr\t%%g0, %%g0, %%y\n\tnop\n\tnop\n\tnop\n\tudivcc\t%1, %2, %0";
+    return "nop\n\tnop\n\tnop\n\tudivcc\t%1, %2, %0";
 }
   [(set_attr "type" "multi")
    (set (attr "length")
diff --git a/gcc/config/sparc/sysv4.h b/gcc/config/sparc/sysv4.h
index 54e9a9f3f38..1359272d960 100644
--- a/gcc/config/sparc/sysv4.h
+++ b/gcc/config/sparc/sysv4.h
@@ -100,22 +100,6 @@ do { ASM_OUTPUT_ALIGN ((FILE), Pmode == SImode ? 2 : 3);		\
 	fprintf (FILE, "\n");						\
   } while (0)
 
-/* Define how the SPARC registers should be numbered for Dwarf output.
-   The numbering provided here should be compatible with the native
-   svr4 SDB debugger in the SPARC/svr4 reference port.  The numbering
-   is as follows:
-
-   Assembly name	gcc internal regno	Dwarf regno
-   ----------------------------------------------------------
-   g0-g7		0-7			0-7
-   o0-o7		8-15			8-15
-   l0-l7		16-23			16-23
-   i0-i7		24-31			24-31
-   f0-f31		32-63			40-71
-*/
-
-#define DBX_REGISTER_NUMBER(REGNO) ((REGNO) < 32 ? (REGNO) : (REGNO) + 8)
-
 /* A set of symbol definitions for assembly pseudo-ops which will
    get us switched to various sections of interest.  These are used
    in all places where we simply want to switch to a section, and
diff --git a/gcc/configure b/gcc/configure
index d15637e546f..e4791ccd6a5 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -14045,9 +14045,16 @@ L2:' > conftest.s
   # arbitrary sections are supported and try the test.
   as_ver=`$gcc_cv_as --version 2>/dev/null | sed 1q`
   if echo "$as_ver" | grep GNU > /dev/null; then
-    as_ver=`echo $as_ver | sed -e 's/GNU assembler \([0-9.][0-9.]*\).*/\1/'`
-    as_major=`echo $as_ver | sed 's/\..*//'`
-    as_minor=`echo $as_ver | sed 's/[^.]*\.\([0-9]*\).*/\1/'`
+    as_vers=`echo $as_ver | sed -n \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\)[	 ].*$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[	 ].*$,\1,p' \
+	-e 's,^.*[ 	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[ 	].*$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[	 -].*$,\1,p'`
+    as_major=`expr "$as_vers" : '\([0-9]*\)'`
+    as_minor=`expr "$as_vers" : '[0-9]*\.\([0-9]*\)'`
     if test $as_major -eq 2 && test $as_minor -lt 11
     then :
     else gcc_cv_as_leb128=yes
diff --git a/gcc/configure.ac b/gcc/configure.ac
index c4ee27ae961..c67c4cbcdb6 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -2178,9 +2178,16 @@ L2:],
   as_ver=`$gcc_cv_as --version 2>/dev/null | sed 1q`
   if echo "$as_ver" | grep GNU > /dev/null; then
 changequote(,)dnl
-    as_ver=`echo $as_ver | sed -e 's/GNU assembler \([0-9.][0-9.]*\).*/\1/'`
-    as_major=`echo $as_ver | sed 's/\..*//'`
-    as_minor=`echo $as_ver | sed 's/[^.]*\.\([0-9]*\).*/\1/'`
+    as_vers=`echo $as_ver | sed -n \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\)[	 ].*$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[	 ].*$,\1,p' \
+	-e 's,^.*[ 	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[ 	].*$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[	 -].*$,\1,p'`
+    as_major=`expr "$as_vers" : '\([0-9]*\)'`
+    as_minor=`expr "$as_vers" : '[0-9]*\.\([0-9]*\)'`
 changequote([,])dnl
     if test $as_major -eq 2 && test $as_minor -lt 11
     then :
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index ca5f4f8948f..742f90f75dc 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,43 @@
+2009-01-15  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38850
+	* pt.c (tsubst_copy_and_build): Tell finish_call_expr to
+	accept hidden friends.
+
+2009-01-12  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/36019
+	* pt.c (parameter_of_template_p): New function.
+	* pt.c (get_template_info): Ditto.
+	* cp-tree.h: Declare those.
+	* name-lookup.c (binding_to_template_parms_of_scope_p): New
+	function.
+	(outer_binding): Take template parameters in account when looking for
+	a name binding.
+
+2008-11-19  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/37142
+	* pt.c (coerce_template_template_parm): Use the more robust
+	uses_template_parms instead of dependent_type_p.
+
+2008-11-14  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38030
+	* semantics.c (finish_call_expr): Don't repeat arg-dep lookup
+	for a non-dependent call.
+
+2008-11-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/37932
+	* typeck2.c (process_init_constructor_record): Update bitfield
+	handling.
+	
+2008-11-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38007
+	* typeck.c (cp_build_modify_expr): Update bitfield handling.
+
 2008-05-19  Release Manager
 
 	* GCC 4.2.4 released.
@@ -82,7 +122,7 @@
 	PR c++/33959
 	* pt.c (tsubst_aggr_type): Make sure our context is complete.
 
-2008-01-02  Volker Reichelt  <reichelt@netcologne.de>
+2008-01-02  Volker Reichelt  <v.reichelt@netcologne.de>
 
 	Backport:
 	2007-10-31  Paolo Carlini  <pcarlini@suse.de>
@@ -545,7 +585,7 @@
 	PR C++/30168
 	* optimize.c (update_cloned_parm): Copy DECL_COMPLEX_GIMPLE_REG_P also.
 
-2007-03-08  Volker Reichelt  <reichelt@netcologne.de>
+2007-03-08  Volker Reichelt  <v.reichelt@netcologne.de>
 
 	PR c++/30852
 	* semantics.c (finish_offsetof): Handle COMPOUND_EXPR.
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index 48d8de8ff20..576fc28d79c 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -4163,6 +4163,8 @@ extern bool reregister_specialization		(tree, tree, tree);
 extern tree fold_non_dependent_expr		(tree);
 extern bool explicit_class_specialization_p     (tree);
 extern tree outermost_tinst_level		(void);
+extern tree get_template_info			(tree t);
+extern bool parameter_of_template_p		(tree, tree);
 
 /* in repo.c */
 extern void init_repo				(void);
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index f02bf269fad..f990a3bd616 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -3850,9 +3850,33 @@ qualified_lookup_using_namespace (tree name, tree scope,
   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result->value != error_mark_node);
 }
 
+/* Subroutine of outer_binding.
+   Returns TRUE if BINDING is a binding to a template parameter of SCOPE,
+   FALSE otherwise.  */
+static bool
+binding_to_template_parms_of_scope_p (cxx_binding *binding,
+				      cxx_scope *scope)
+{
+  tree binding_value;
+
+  if (!binding || !scope)
+    return false;
+
+  binding_value = binding->value ?  binding->value : binding->type;
+
+  return (scope
+          && scope->this_entity
+          && get_template_info (scope->this_entity)
+          && parameter_of_template_p (binding_value,
+                                      TI_TEMPLATE (get_template_info \
+                                                    (scope->this_entity))));
+}
+
 /* Return the innermost non-namespace binding for NAME from a scope
-   containing BINDING, or, if BINDING is NULL, the current scope.  If
-   CLASS_P is false, then class bindings are ignored.  */
+   containing BINDING, or, if BINDING is NULL, the current scope.
+   Please note that for a given template, the template parameters are
+   considered to be in the scope containing the current scope.
+   If CLASS_P is false, then class bindings are ignored.  */
 
 cxx_binding *
 outer_binding (tree name,
@@ -3900,6 +3924,12 @@ outer_binding (tree name,
 		return class_binding;
 	      }
 	  }
+	/* If SCOPE is a template and if NAME binds to one of its template parameters
+	   return the binding, otherwise we might miss it.  */
+	if (outer_scope && outer_scope->kind == sk_template_parms
+	    && binding_to_template_parms_of_scope_p (outer, scope))
+	  return outer;
+
 	scope = scope->level_chain;
       }
 
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 721f02bfe61..260229f15ad 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -251,6 +251,25 @@ finish_member_template_decl (tree decl)
   return error_mark_node;
 }
 
+/* Return the template info node corresponding to T, whatever T is.  */
+
+tree
+get_template_info (tree t)
+{
+  tree tinfo = NULL_TREE;
+
+  if (DECL_P (t) && DECL_LANG_SPECIFIC (t))
+    tinfo = DECL_TEMPLATE_INFO (t);
+
+  if (!tinfo && TREE_CODE (t) == TYPE_DECL)
+    t = TREE_TYPE (t);
+
+  if (TAGGED_TYPE_P (t))
+    tinfo = TYPE_TEMPLATE_INFO (t);
+
+  return tinfo;
+}
+
 /* Returns the template nesting level of the indicated class TYPE.
 
    For example, in:
@@ -3962,7 +3981,7 @@ coerce_template_template_parms (tree parm_parms,
 	       D<int, C> d;
 
 	     i.e. the parameter list of TT depends on earlier parameters.  */
-	  if (!dependent_type_p (TREE_TYPE (arg))
+	  if (!uses_template_parms (TREE_TYPE (arg))
 	      && !same_type_p
 		    (tsubst (TREE_TYPE (parm), outer_args, complain, in_decl),
 			     TREE_TYPE (arg)))
@@ -5327,6 +5346,30 @@ outermost_tinst_level (void)
   return tree_last (current_tinst_level);
 }
 
+/* Returns TRUE if PARM is a parameter of the template TEMPL.  */
+
+bool
+parameter_of_template_p (tree parm, tree templ)
+{
+  tree parms;
+  int i;
+
+  if (!parm || !templ)
+    return false;
+
+  gcc_assert (DECL_TEMPLATE_PARM_P (parm));
+  gcc_assert (TREE_CODE (templ) == TEMPLATE_DECL);
+
+  parms = DECL_TEMPLATE_PARMS (templ);
+  parms = INNERMOST_TEMPLATE_PARMS (parms);
+
+  for (i = 0; i < TREE_VEC_LENGTH (parms); ++i)
+    if (parm == TREE_VALUE (TREE_VEC_ELT (parms, i)))
+      return true;
+
+  return false;
+}
+
 /* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the
    vector of template arguments, as for tsubst.
 
@@ -9274,9 +9317,12 @@ tsubst_copy_and_build (tree t,
 		       qualified_p ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL,
 		       /*fn_p=*/NULL));
 	  }
+	/* Pass true for koenig_p so that build_new_function_call will
+	   allow hidden friends found by arg-dependent lookup at template
+	   parsing time.  */
 	return finish_call_expr (function, call_args,
 				 /*disallow_virtual=*/qualified_p,
-				 koenig_p);
+				 /*koenig_p*/true);
       }
 
     case COND_EXPR:
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index 5886972f9fd..d95d731e6fd 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -1886,7 +1886,9 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)
     {
       result = build3 (CALL_EXPR, TREE_TYPE (result), orig_fn,
 		       orig_args, NULL_TREE);
-      KOENIG_LOOKUP_P (result) = koenig_p;
+      /* Don't repeat arg-dependent lookup at instantiation time if this call
+         is not type-dependent.  */
+      KOENIG_LOOKUP_P (result) = 0;
     }
   return result;
 }
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 76ac3f03ee6..89ad608a0a9 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -5549,7 +5549,6 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)
   tree newrhs = rhs;
   tree lhstype = TREE_TYPE (lhs);
   tree olhstype = lhstype;
-  tree olhs = NULL_TREE;
   bool plain_assign = (modifycode == NOP_EXPR);
 
   /* Avoid duplicate error messages from operands that had errors.  */
@@ -5737,35 +5736,11 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)
 	      && C_TYPE_FIELDS_READONLY (lhstype))))
     readonly_error (lhs, "assignment", 0);
 
-  /* If storing into a structure or union member, it has probably been
-     given type `int'.  Compute the type that would go with the actual
-     amount of storage the member occupies.  */
+  /* If storing into a structure or union member, it may have been given a
+     lowered bitfield type.  We need to convert to the declared type first,
+     so retrieve it now.  */
 
-  if (TREE_CODE (lhs) == COMPONENT_REF
-      && (TREE_CODE (lhstype) == INTEGER_TYPE
-	  || TREE_CODE (lhstype) == REAL_TYPE
-	  || TREE_CODE (lhstype) == ENUMERAL_TYPE))
-    {
-      lhstype = TREE_TYPE (get_unwidened (lhs, 0));
-
-      /* If storing in a field that is in actuality a short or narrower
-	 than one, we must store in the field in its actual type.  */
-
-      if (lhstype != TREE_TYPE (lhs))
-	{
-	  /* Avoid warnings converting integral types back into enums for
-	     enum bit fields.  */
-	  if (TREE_CODE (lhstype) == INTEGER_TYPE
-	      && TREE_CODE (olhstype) == ENUMERAL_TYPE)
-	    {
-	      if (TREE_SIDE_EFFECTS (lhs))
-		lhs = stabilize_reference (lhs);
-	      olhs = lhs;
-	    }
-	  lhs = copy_node (lhs);
-	  TREE_TYPE (lhs) = lhstype;
-	}
-    }
+  olhstype = unlowered_expr_type (lhs);
 
   /* Convert new value to destination type.  */
 
@@ -5801,21 +5776,17 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)
     }
 
   if (modifycode == INIT_EXPR)
-    newrhs = convert_for_initialization (lhs, lhstype, newrhs, LOOKUP_NORMAL,
+    newrhs = convert_for_initialization (lhs, olhstype, newrhs, LOOKUP_NORMAL,
 					 "initialization", NULL_TREE, 0);
   else
+    newrhs = convert_for_assignment (olhstype, newrhs, "assignment",
+				     NULL_TREE, 0);
+
+  if (!same_type_p (lhstype, olhstype))
+    newrhs = convert_and_check (lhstype, newrhs);
+
+  if (modifycode != INIT_EXPR)
     {
-      /* Avoid warnings on enum bit fields.  */
-      if (TREE_CODE (olhstype) == ENUMERAL_TYPE
-	  && TREE_CODE (lhstype) == INTEGER_TYPE)
-	{
-	  newrhs = convert_for_assignment (olhstype, newrhs, "assignment",
-					   NULL_TREE, 0);
-	  newrhs = convert_force (lhstype, newrhs, 0);
-	}
-      else
-	newrhs = convert_for_assignment (lhstype, newrhs, "assignment",
-					 NULL_TREE, 0);
       if (TREE_CODE (newrhs) == CALL_EXPR
 	  && TYPE_NEEDS_CONSTRUCTING (lhstype))
 	newrhs = build_cplus_new (lhstype, newrhs);
@@ -5847,21 +5818,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)
   if (!plain_assign)
     TREE_NO_WARNING (result) = 1;
 
-  /* If we got the LHS in a different type for storing in,
-     convert the result back to the nominal type of LHS
-     so that the value we return always has the same type
-     as the LHS argument.  */
-
-  if (olhstype == TREE_TYPE (result))
-    return result;
-  if (olhs)
-    {
-      result = build2 (COMPOUND_EXPR, olhstype, result, olhs);
-      TREE_NO_WARNING (result) = 1;
-      return result;
-    }
-  return convert_for_assignment (olhstype, result, "assignment",
-				 NULL_TREE, 0);
+  return result;
 }
 
 tree
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index 9ab0c65e88b..a2fce0c7596 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -888,6 +888,7 @@ process_init_constructor_record (tree type, tree init)
   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))
     {
       tree next;
+      tree type;
 
       if (!DECL_NAME (field) && DECL_C_BIT_FIELD (field))
 	{
@@ -899,6 +900,11 @@ process_init_constructor_record (tree type, tree init)
       if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))
 	continue;
 
+      /* If this is a bitfield, first convert to the declared type.  */
+      type = TREE_TYPE (field);
+      if (DECL_BIT_FIELD_TYPE (field))
+	type = DECL_BIT_FIELD_TYPE (field);
+
       if (idx < VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init)))
 	{
 	  constructor_elt *ce = VEC_index (constructor_elt,
@@ -919,7 +925,7 @@ process_init_constructor_record (tree type, tree init)
 	    }
 
 	  gcc_assert (ce->value);
-	  next = digest_init (TREE_TYPE (field), ce->value);
+	  next = digest_init (type, ce->value);
 	  ++idx;
 	}
       else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))
@@ -962,6 +968,9 @@ process_init_constructor_record (tree type, tree init)
 	    continue;
 	}
 
+      /* If this is a bitfield, now convert to the lowered type.  */
+      if (type != TREE_TYPE (field))
+	next = convert_and_check (TREE_TYPE (field), next);
       flags |= picflag_from_initializer (next);
       CONSTRUCTOR_APPEND_ELT (v, field, next);
     }
diff --git a/gcc/cse.c b/gcc/cse.c
index d0cf2971904..31ee15c7656 100644
--- a/gcc/cse.c
+++ b/gcc/cse.c
@@ -1455,17 +1455,6 @@ lookup_as_function (rtx x, enum rtx_code code)
   struct table_elt *p
     = lookup (x, SAFE_HASH (x, VOIDmode), GET_MODE (x));
 
-  /* If we are looking for a CONST_INT, the mode doesn't really matter, as
-     long as we are narrowing.  So if we looked in vain for a mode narrower
-     than word_mode before, look for word_mode now.  */
-  if (p == 0 && code == CONST_INT
-      && GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (word_mode))
-    {
-      x = copy_rtx (x);
-      PUT_MODE (x, word_mode);
-      p = lookup (x, SAFE_HASH (x, VOIDmode), word_mode);
-    }
-
   if (p == 0)
     return 0;
 
@@ -3258,6 +3247,7 @@ static rtx
 fold_rtx_subreg (rtx x, rtx insn)
 {
   enum machine_mode mode = GET_MODE (x);
+  enum machine_mode imode = GET_MODE (SUBREG_REG (x));
   rtx folded_arg0;
   rtx const_arg0;
   rtx new;
@@ -3267,6 +3257,21 @@ fold_rtx_subreg (rtx x, rtx insn)
       || (new = lookup_as_function (x, CONST_DOUBLE)) != 0)
     return new;
 
+  /* If we didn't and if doing so makes sense, see if we previously
+     assigned a constant value to the enclosing word mode SUBREG.  */
+  if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (word_mode)
+      && GET_MODE_SIZE (word_mode) < GET_MODE_SIZE (imode))
+    {
+      int byte = SUBREG_BYTE (x) - subreg_lowpart_offset (mode, word_mode);
+      if (byte >= 0 && (byte % UNITS_PER_WORD) == 0)
+	{
+	  rtx y = gen_rtx_SUBREG (word_mode, SUBREG_REG (x), byte);
+	  new = lookup_as_function (y, CONST_INT);
+	  if (new)
+	    return gen_lowpart (mode, new);
+	}
+    }
+
   /* If this is a paradoxical SUBREG, we have no idea what value the
      extra bits would have.  However, if the operand is equivalent to
      a SUBREG whose operand is the same as our mode, and all the modes
@@ -3275,9 +3280,8 @@ fold_rtx_subreg (rtx x, rtx insn)
 
      Similarly if we find an integer constant.  */
 
-  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))
+  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (imode))
     {
-      enum machine_mode imode = GET_MODE (SUBREG_REG (x));
       struct table_elt *elt;
 
       if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD
@@ -3310,8 +3314,7 @@ fold_rtx_subreg (rtx x, rtx insn)
 
   if (folded_arg0 != SUBREG_REG (x))
     {
-      new = simplify_subreg (mode, folded_arg0,
-			     GET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));
+      new = simplify_subreg (mode, folded_arg0, imode, SUBREG_BYTE (x));
       if (new)
 	return new;
     }
@@ -4372,6 +4375,11 @@ fold_rtx (rtx x, rtx insn)
 			  && exact_log2 (- INTVAL (const_arg1)) >= 0)))
 		break;
 
+	      /* ??? Vector mode shifts by scalar
+		 shift operand are not supported yet.  */
+	      if (is_shift && VECTOR_MODE_P (mode))
+                break;
+
 	      if (is_shift
 		  && (INTVAL (inner_const) >= GET_MODE_BITSIZE (mode)
 		      || INTVAL (inner_const) < 0))
diff --git a/gcc/doc/install.texi2html b/gcc/doc/install.texi2html
index 60d670b4785..bb0204eea14 100755
--- a/gcc/doc/install.texi2html
+++ b/gcc/doc/install.texi2html
@@ -32,7 +32,7 @@ fi
       echo "@clear DEVELOPMENT"
    fi
    echo "@set srcdir $SOURCEDIR/.."
-) > $SOURCEDIR/include/gcc-vers.texi
+) > $DESTDIR/gcc-vers.texi
 
 for x in index.html specific.html prerequisites.html download.html configure.html \
          build.html test.html finalinstall.html binaries.html old.html \
@@ -40,7 +40,7 @@ for x in index.html specific.html prerequisites.html download.html configure.htm
 do
     define=`echo $x | sed -e 's/\.//g'`
     echo "define = $define"
-    $MAKEINFO -I $SOURCEDIR -I $SOURCEDIR/include $SOURCEDIR/install.texi --html --no-split -D$define -o$DESTDIR/$x
+    $MAKEINFO -I $SOURCEDIR -I $SOURCEDIR/include $SOURCEDIR/install.texi -I $DESTDIR --html --no-split -D$define -o$DESTDIR/$x
 done
 
-rm $SOURCEDIR/include/gcc-vers.texi
+rm $DESTDIR/gcc-vers.texi
diff --git a/gcc/expmed.c b/gcc/expmed.c
index d392197d8e9..8de9e4d208b 100644
--- a/gcc/expmed.c
+++ b/gcc/expmed.c
@@ -3163,7 +3163,8 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,
 	{
 	  /* If we are multiplying in DImode, it may still be a win
 	     to try to work with shifts and adds.  */
-	  if (CONST_DOUBLE_HIGH (op1) == 0)
+	  if (CONST_DOUBLE_HIGH (op1) == 0
+	      && CONST_DOUBLE_LOW (op1) > 0)
 	    coeff = CONST_DOUBLE_LOW (op1);
 	  else if (CONST_DOUBLE_LOW (op1) == 0
 		   && EXACT_POWER_OF_2_OR_ZERO_P (CONST_DOUBLE_HIGH (op1)))
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 4a1cc2c9721..059496e4882 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -816,7 +816,7 @@ div_and_round_double (enum tree_code code, int uns,
 	if (hden < 0)
 	  neg_double (lden, hden, &labs_den, &habs_den);
 
-	/* If (2 * abs (lrem) >= abs (lden)) */
+	/* If (2 * abs (lrem) >= abs (lden)), adjust the quotient.  */
 	mul_double ((HOST_WIDE_INT) 2, (HOST_WIDE_INT) 0,
 		    labs_rem, habs_rem, &ltwice, &htwice);
 
@@ -824,7 +824,7 @@ div_and_round_double (enum tree_code code, int uns,
 	     < (unsigned HOST_WIDE_INT) htwice)
 	    || (((unsigned HOST_WIDE_INT) habs_den
 		 == (unsigned HOST_WIDE_INT) htwice)
-		&& (labs_den < ltwice)))
+		&& (labs_den <= ltwice)))
 	  {
 	    if (*hquo < 0)
 	      /* quo = quo - 1;  */
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index fa2035bc39c..ea43aaf64bf 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -3540,7 +3540,7 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)
      side as statements and throw away the assignment.  Do this after
      gimplify_modify_expr_rhs so we handle TARGET_EXPRs of addressable
      types properly.  */
-  if (zero_sized_type (TREE_TYPE (*from_p)))
+  if (zero_sized_type (TREE_TYPE (*from_p)) && !want_value)
     {
       gimplify_stmt (from_p);
       gimplify_stmt (to_p);
diff --git a/gcc/gthr-posix.h b/gcc/gthr-posix.h
index 47d38a320ba..fd1ce2204d3 100644
--- a/gcc/gthr-posix.h
+++ b/gcc/gthr-posix.h
@@ -152,9 +152,12 @@ __gthrw(pthread_setschedparam)
    it is passed so we cannot pretend that the interface is active if -pthreads
    is not specified.  On Solaris 2.5.1, the interface is not exposed at all so
    we need to play the usual game with weak symbols.  On Solaris 10 and up, a
-   working interface is always exposed.  */
+   working interface is always exposed.  On FreeBSD 6 and later, libc also
+   exposes a dummy POSIX threads interface, similar to what Solaris 2.6 up
+   to 9 does.  FreeBSD >= 700014 even provides a pthread_cancel stub in libc,
+   which means the alternate __gthread_active_p below cannot be used there.  */
 
-#if defined(__sun) && defined(__svr4__)
+#if defined(__FreeBSD__) || (defined(__sun) && defined(__svr4__))
 
 static volatile int __gthread_active = -1;
 
@@ -197,7 +200,7 @@ __gthread_active_p (void)
   return __gthread_active_latest_value != 0;
 }
 
-#else /* not Solaris */
+#else /* neither FreeBSD nor Solaris */
 
 static inline int
 __gthread_active_p (void)
@@ -207,7 +210,7 @@ __gthread_active_p (void)
   return __gthread_active_ptr != 0;
 }
 
-#endif /* Solaris */
+#endif /* FreeBSD or Solaris */
 
 #else /* not SUPPORTS_WEAK */
 
diff --git a/gcc/gthr-posix95.h b/gcc/gthr-posix95.h
index fde264594f8..172439638af 100644
--- a/gcc/gthr-posix95.h
+++ b/gcc/gthr-posix95.h
@@ -115,9 +115,12 @@ __gthrw(pthread_setschedparam)
    it is passed so we cannot pretend that the interface is active if -pthreads
    is not specified.  On Solaris 2.5.1, the interface is not exposed at all so
    we need to play the usual game with weak symbols.  On Solaris 10 and up, a
-   working interface is always exposed.  */
+   working interface is always exposed.  On FreeBSD 6 and later, libc also
+   exposes a dummy POSIX threads interface, similar to what Solaris 2.6 up
+   to 9 does.  FreeBSD >= 700014 even provides a pthread_cancel stub in libc,
+   which means the alternate __gthread_active_p below cannot be used there.  */
 
-#if defined(__sun) && defined(__svr4__)
+#if defined(__FreeBSD__) || (defined(__sun) && defined(__svr4__))
 
 static volatile int __gthread_active = -1;
 
@@ -160,7 +163,7 @@ __gthread_active_p (void)
   return __gthread_active_latest_value != 0;
 }
 
-#else /* not Solaris */
+#else /* neither FreeBSD nor Solaris */
 
 static inline int
 __gthread_active_p (void)
@@ -170,7 +173,7 @@ __gthread_active_p (void)
   return __gthread_active_ptr != 0;
 }
 
-#endif /* Solaris */
+#endif /* FreeBSD or Solaris */
 
 #else /* not SUPPORTS_WEAK */
 
diff --git a/gcc/longlong.h b/gcc/longlong.h
index f03e25b85bb..fa0417abe84 100644
--- a/gcc/longlong.h
+++ b/gcc/longlong.h
@@ -1,20 +1,33 @@
 /* longlong.h -- definitions for mixed size 32/64 bit arithmetic.
-   Copyright (C) 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2004,
-   2005, 2007  Free Software Foundation, Inc.
+   Copyright (C) 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
+   Free Software Foundation, Inc.
 
-   This definition file is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public
-   License as published by the Free Software Foundation; either
-   version 3, or (at your option) any later version.
-
-   This definition file is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied
-   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-   See the GNU General Public License for more details.
+   This file is part of the GNU C Library.
 
-   You should have received a copy of the GNU General Public License
-   along with this program; see the file COPYING3.  If not see
-   <http://www.gnu.org/licenses/>.  */
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
 
 /* You have to define the following before including this file:
 
diff --git a/gcc/regrename.c b/gcc/regrename.c
index f7b5a68da8c..da8ca1ec1ba 100644
--- a/gcc/regrename.c
+++ b/gcc/regrename.c
@@ -1335,6 +1335,10 @@ maybe_mode_change (enum machine_mode orig_mode, enum machine_mode copy_mode,
 		   enum machine_mode new_mode, unsigned int regno,
 		   unsigned int copy_regno ATTRIBUTE_UNUSED)
 {
+  if (GET_MODE_SIZE (copy_mode) < GET_MODE_SIZE (orig_mode)
+      && GET_MODE_SIZE (copy_mode) < GET_MODE_SIZE (new_mode))
+    return NULL_RTX;
+
   if (orig_mode == new_mode)
     return gen_rtx_raw_REG (new_mode, regno);
   else if (mode_change_ok (orig_mode, new_mode, regno))
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index b16da4a0956..2b71e9ddf68 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -3400,8 +3400,9 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,
   enum rtx_code code;
   unsigned int mode_width = GET_MODE_BITSIZE (mode);
 
-  /* For floating-point values, assume all bits are needed.  */
-  if (FLOAT_MODE_P (GET_MODE (x)) || FLOAT_MODE_P (mode))
+  /* For floating-point and vector values, assume all bits are needed.  */
+  if (FLOAT_MODE_P (GET_MODE (x)) || FLOAT_MODE_P (mode)
+      || VECTOR_MODE_P (GET_MODE (x)) || VECTOR_MODE_P (mode))
     return nonzero;
 
   /* If X is wider than MODE, use its mode instead.  */
@@ -3914,7 +3915,8 @@ num_sign_bit_copies1 (rtx x, enum machine_mode mode, rtx known_x,
   if (mode == VOIDmode)
     mode = GET_MODE (x);
 
-  if (mode == VOIDmode || FLOAT_MODE_P (mode) || FLOAT_MODE_P (GET_MODE (x)))
+  if (mode == VOIDmode || FLOAT_MODE_P (mode) || FLOAT_MODE_P (GET_MODE (x))
+      || VECTOR_MODE_P (GET_MODE (x)) || VECTOR_MODE_P (mode))
     return 1;
 
   /* For a smaller object, just ignore the high bits.  */
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 59153964162..fc8d3f5c080 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,120 @@
+2009-01-15  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38850
+	* g++.dg/template/koenig6.C: New test.
+
+2009-01-12  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/36019
+	* g++.dg/lookup/hidden-class12.C: New test.
+	* g++.dg/lookup/hidden-class13.C: New test.
+	* g++.dg/lookup/hidden-class14.C: New test.
+	* g++.dg/lookup/hidden-class15.C: New test.
+	* g++.dg/lookup/hidden-class16.C: New test.
+	* gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C: Adjust testcase.
+
+2008-12-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/union-5.c: Run only on x86 and x86-64.
+
+2008-12-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/union-5.c: New test.
+
+2008-11-30  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/opt/reload3.C: New test.
+
+2008-11-19  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/37142
+	* g++.dg/template/crash71.C: New test.
+
+2008-11-14  Dodji Seketeli  <dodji@redhat.com>
+
+	PR c++/27574
+	* testsuite/g++.dg/debug/dwarf2/dwarf2.exp: Backport this here from
+	gcc-4_3-branch.
+	* g++.dg/debug/dwarf2/local-var-in-contructor.C: New testcase.
+
+2008-11-13  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2008-06-06  Uros Bizjak <ubizjak@gmail.com>
+
+	PR rtl-optimization/36438
+	* gcc.target/i386/pr36438.c
+
+2008-11-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38030
+	* g++.dg/template/lookup8.C: New test.
+
+	PR c++/37740
+	* g++.dg/cpp0x/initlist8.C: New test.
+
+	PR c++/37932
+	* g++.dg/conversion/bitfield11.C: New test.
+
+2008-11-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/38007
+	* g++.dg/conversion/bitfield10.C: New test.
+	* g++.old-deja/g++.mike/enum1.C: Expect warn about assignment.
+	* g++.dg/expr/bitfield9.C: Pass -Wno-overflow.
+
+2008-11-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2008-11-10  Ralph Loader  <suckfish@ihug.co.nz>
+
+	PR middle-end/37807
+	PR middle-end/37809
+	* gcc.target/i386/mmx-8.c: New test.
+
+2008-10-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2008-10-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR middle-end/37731
+	* expmed.c (expand_mult): Properly check DImode constant in
+	CONST_DOUBLE.
+
+2008-09-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/conv_decimal.adb: New test.
+
+2008-09-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2008-09-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/37544
+	* gcc.dg/pr37544.c: New test.
+
+2008-08-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2008-08-14  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/37101
+	* gcc.target/i386/pr37101.c: New test.
+
+2008-08-06  Aldy Hernandez  <aldyh@redhat.com>
+
+	PR middle-end/35432
+	* gcc.c-torture/compile/pr35432.c: New file.
+
+2008-05-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/nested-func-6.c: New test.
+
+2008-05-20  Adam Nemet  <anemet@caviumnetworks.com>
+
+	PR middle-end/36194
+	* gcc.dg/pr36194.c: New test.
+
 2008-05-19  Release Manager
 
 	* GCC 4.2.4 released.
@@ -293,7 +410,7 @@
 	PR testsuite/30459
 	g++.dg/eh/ia64-2.C: Require weak support.
 
-2008-01-02  Volker Reichelt  <reichelt@netcologne.de>
+2008-01-02  Volker Reichelt  <v.reichelt@netcologne.de>
 
 	Backport:
 	2007-10-31  Paolo Carlini  <pcarlini@suse.de>
@@ -1385,7 +1502,7 @@
 	PR libfortran/31001
 	* gfortran.dg/zero_sized_3.f90: New test.
 
-2007-03-08  Volker Reichelt  <reichelt@netcologne.de>
+2007-03-08  Volker Reichelt  <v.reichelt@netcologne.de>
 
 	PR c++/30852
 	* g++.dg/ext/offsetof1.C: Add cases with volatile.
diff --git a/gcc/testsuite/g++.dg/conversion/bitfield10.C b/gcc/testsuite/g++.dg/conversion/bitfield10.C
new file mode 100644
index 00000000000..f75504e0d99
--- /dev/null
+++ b/gcc/testsuite/g++.dg/conversion/bitfield10.C
@@ -0,0 +1,24 @@
+// PR c++/38007
+// We need to use the conversion function to the declared type of a bitfield,
+// not the lowered bitfield type.
+// { dg-do link }
+
+struct A
+{
+  operator unsigned int() { return 42; }
+  operator unsigned char();
+};
+
+struct B
+{
+  unsigned int b : 8;
+};
+
+int
+main ()
+{
+  A u;
+  unsigned int v = u;
+  B w;
+  w.b = u;
+}
diff --git a/gcc/testsuite/g++.dg/conversion/bitfield11.C b/gcc/testsuite/g++.dg/conversion/bitfield11.C
new file mode 100644
index 00000000000..e36539c64b5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/conversion/bitfield11.C
@@ -0,0 +1,8 @@
+// Make sure that digest_init converts to the declared type of the
+// bitfield, not just the lowered type.
+
+enum E { EA, EB };
+
+struct A { E e: 8; };
+
+A a = { 0 };			// { dg-error "invalid conversion" }
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/dwarf2.exp b/gcc/testsuite/g++.dg/debug/dwarf2/dwarf2.exp
new file mode 100644
index 00000000000..1255d0630e7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/dwarf2.exp
@@ -0,0 +1,43 @@
+#   Copyright (C) 2007, 2007 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# G++ testsuite that uses the `dg.exp' driver.
+
+# Load support procs.
+load_lib g++-dg.exp
+
+# If a testcase doesn't have special options, use these.
+global DEFAULT_CFLAGS
+if ![info exists DEFAULT_CFLAGS] then {
+    set DEFAULT_CFLAGS " -gdwarf-2"
+}
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+set comp_output [g++_target_compile \
+    "$srcdir/$subdir/../trivial.C" "trivial.S" assembly \
+    "additional_flags=-gdwarf-2"]
+if { ! [string match "*: target system does not support the * debug format*" \
+    $comp_output] } {
+    remove-build-file "trivial.S"
+    dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[C\]]] \
+	    "" $DEFAULT_CFLAGS
+}
+
+# All done.
+dg-finish
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/local-var-in-contructor.C b/gcc/testsuite/g++.dg/debug/dwarf2/local-var-in-contructor.C
new file mode 100644
index 00000000000..d61d27fe7e4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/local-var-in-contructor.C
@@ -0,0 +1,30 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR27574
+// { dg-do compile }
+// { dg-options "-O0 -g" }
+// { dg-final { scan-assembler "problem" } }
+
+void f (int *)
+{
+}
+
+class A
+{
+public:
+ A(int i);
+};
+
+A::A(int i)
+{
+ int *problem = new int(i);
+ f (problem);
+}
+
+int
+main (void)
+{
+  A a (0);
+
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.dg/expr/bitfield9.C b/gcc/testsuite/g++.dg/expr/bitfield9.C
index 047b1bf5239..177f65b8800 100644
--- a/gcc/testsuite/g++.dg/expr/bitfield9.C
+++ b/gcc/testsuite/g++.dg/expr/bitfield9.C
@@ -1,5 +1,6 @@
 // PR c++/32346
 // { dg-do run }
+// { dg-options "-Wno-overflow" }
 
 extern "C" void abort();
 
diff --git a/gcc/testsuite/g++.dg/lookup/hidden-class12.C b/gcc/testsuite/g++.dg/lookup/hidden-class12.C
new file mode 100644
index 00000000000..4a3f2d7618b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lookup/hidden-class12.C
@@ -0,0 +1,24 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/36019
+// { dg-do compile }
+
+struct F {
+  static const int x = 0;
+};
+
+struct A {
+  template <typename A>
+  static int f ()
+  {
+    return A::x;
+  }
+};
+
+
+int
+main ()
+{
+  int i = A::f<F> ();
+  return i;
+}
+
diff --git a/gcc/testsuite/g++.dg/lookup/hidden-class13.C b/gcc/testsuite/g++.dg/lookup/hidden-class13.C
new file mode 100644
index 00000000000..2f685b2cb36
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lookup/hidden-class13.C
@@ -0,0 +1,25 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/36019
+// { dg-do compile }
+
+struct F {
+  static const int x = 0;
+};
+
+struct B {
+  template <typename B>
+  struct C
+  {
+    static int f ()
+    {
+      return B::x;
+    }
+  };
+};
+
+int
+main ()
+{
+  int j = B::C<F>::f ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/lookup/hidden-class14.C b/gcc/testsuite/g++.dg/lookup/hidden-class14.C
new file mode 100644
index 00000000000..99bd6731b1b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lookup/hidden-class14.C
@@ -0,0 +1,23 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/36019
+// { dg-do compile }
+
+struct F {
+  static const int x = 0;
+  typedef int A;
+};
+
+struct A {
+  template <typename A>
+  struct G : public F 
+  {
+    static const A i = 0;
+  };
+};
+
+int
+main ()
+{
+  return A::G<F>::i ;
+}
+
diff --git a/gcc/testsuite/g++.dg/lookup/hidden-class15.C b/gcc/testsuite/g++.dg/lookup/hidden-class15.C
new file mode 100644
index 00000000000..b0ed660a6a3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lookup/hidden-class15.C
@@ -0,0 +1,30 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/36019
+// { dg-do compile }
+
+struct F {
+  static const int y = 0;
+};
+
+struct A {
+  static const int x = 0;
+};
+
+struct B : public A {
+  template <typename A>
+  struct C
+  {
+    static int f ()
+    {
+      return A::x; // { dg-error "'x' is not a member of 'F'" }
+    }
+  };
+};
+
+int
+main ()
+{
+  int j = B::C<F>::f ();
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.dg/lookup/hidden-class16.C b/gcc/testsuite/g++.dg/lookup/hidden-class16.C
new file mode 100644
index 00000000000..25cc4029408
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lookup/hidden-class16.C
@@ -0,0 +1,27 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin PR c++/36019
+// { dg-do compile }
+
+struct F {
+  static const int y = 0;
+};
+
+struct A {
+  static const int x = 0;
+};
+
+struct B : public A {
+  template <typename A>
+  static int f ()
+  {
+    return A::x; // { dg-error "'x' is not a member of 'F'" }
+  }
+};
+
+int
+main ()
+{
+  int j = B::f<F> ();
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.dg/opt/reload3.C b/gcc/testsuite/g++.dg/opt/reload3.C
new file mode 100644
index 00000000000..12f3e66f369
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/reload3.C
@@ -0,0 +1,39 @@
+// PR target/38287
+// { dg-do run }
+// { dg-options "-O2 -mcpu=v8 -fPIC" { target { { sparc*-*-* } && { ilp32 && fpic } } } }
+
+#include <cstdlib>
+
+class QTime
+{
+public:
+    explicit QTime(int ms = 0) : ds(ms) {}
+    static QTime currentTime() { return QTime(); }
+    QTime addMSecs(int ms) const;
+    int msecs() const { return ds; }
+private:
+    unsigned ds;
+};
+
+static const unsigned MSECS_PER_DAY = 86400000;
+
+QTime QTime::addMSecs(int ms) const
+{
+    QTime t;
+    if ( ms < 0 ) {
+        // % not well-defined for -ve, but / is.
+        int negdays = (MSECS_PER_DAY-ms) / MSECS_PER_DAY;
+        t.ds = ((int)ds + ms + negdays*MSECS_PER_DAY)
+                % MSECS_PER_DAY;
+    } else {
+        t.ds = ((int)ds + ms) % MSECS_PER_DAY;
+    }
+    return t;
+}
+
+int main()
+{
+  if (QTime(1).addMSecs(1).msecs() != 2)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/template/crash71.C b/gcc/testsuite/g++.dg/template/crash71.C
new file mode 100644
index 00000000000..18ef338818b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/crash71.C
@@ -0,0 +1,16 @@
+// Contributed by Dodji Seketeli <dodji@redhat.com>
+// Origin: PR c++/37142
+// { dg-do compile }
+
+template<typename T, const T a, template <typename U, U u> class W> struct A {};
+
+template<typename T, const T t> struct B {};
+
+int
+main ()
+{
+  A<long, 0, B> a;
+  return 0;
+}
+
+
diff --git a/gcc/testsuite/g++.dg/template/koenig6.C b/gcc/testsuite/g++.dg/template/koenig6.C
new file mode 100644
index 00000000000..8f93a653a7b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/koenig6.C
@@ -0,0 +1,29 @@
+// PR c++/38850
+
+template <typename VType>
+class Vector2 {
+ private:
+  VType c_[2];
+ public:
+  typedef Vector2<VType> Self;
+
+  Vector2(const VType x, const VType y) {
+    c_[0] = x;
+    c_[1] = y;
+  }
+
+  friend inline Self Max(const Self &v1, const Self &v2) {
+    return Self(v1.c_[0], v1.c_[1]);
+  }
+};
+
+template <class T>
+Vector2<float> foo(T x) {
+  Vector2<float> y(0,0);
+  return Max(y, y);
+}
+
+int main() {
+  foo(3);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/template/lookup8.C b/gcc/testsuite/g++.dg/template/lookup8.C
new file mode 100644
index 00000000000..981c283e4dd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/lookup8.C
@@ -0,0 +1,19 @@
+// PR c++/38030
+// The call to f should be resolved at template definition time.
+// { dg-do link }
+
+struct B { };
+struct D : public B { };
+D d;
+void f (B &) { }
+template < class T >
+void g ()
+{
+  return f (d);
+}
+void f (D &);
+int main ()
+{
+  g<int> ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C b/gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C
index 73b99659e12..791850366df 100644
--- a/gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C
@@ -83,7 +83,7 @@ public:
 template <class T10, int i> struct Xfour {// { dg-error "" } .*
   int T10; // { dg-error "" } .*
   void f(){
-    char T10;
+    char T10; // { dg-error "declaration of 'char T10'" }
   }
 };
 
@@ -126,8 +126,8 @@ public:
   template <class T161>
   friend bool foo(T161 u)
     {
-      Xseven<T161, 5, int> obj; // { dg-error "" } .*
-      return (obj.inst == u.inst); // { dg-error "" } .*
+      Xseven<T161, 5, int> obj;
+      return (obj.inst == u.inst);
     }
 
 };
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/enum1.C b/gcc/testsuite/g++.old-deja/g++.mike/enum1.C
index 0b1a0eeac14..35b1df0898a 100644
--- a/gcc/testsuite/g++.old-deja/g++.mike/enum1.C
+++ b/gcc/testsuite/g++.old-deja/g++.mike/enum1.C
@@ -8,4 +8,4 @@ struct Type {
   void setBTK();
 };
 
-void Type::setBTK() { kind = DTK; }
+void Type::setBTK() { kind = DTK; } // { dg-warning "truncate" }
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr35432.c b/gcc/testsuite/gcc.c-torture/compile/pr35432.c
new file mode 100644
index 00000000000..6a0c9217746
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr35432.c
@@ -0,0 +1,11 @@
+/* PR middle-end/35432 */
+
+struct A
+{
+  char c[0];
+};
+
+void foo(struct A a)
+{
+  (a = a).c;
+}
diff --git a/gcc/testsuite/gcc.dg/nested-func-6.c b/gcc/testsuite/gcc.dg/nested-func-6.c
new file mode 100644
index 00000000000..3bae4db352e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/nested-func-6.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O -Winline" } */
+
+static inline int foo1 (int a)
+{                       /* { dg-bogus "function not inlinable" } */
+  void bar1 (int b)
+  {}
+  return a;
+}
+
+int foo2 (int a)
+{
+  return foo1 (a);
+}
diff --git a/gcc/testsuite/gcc.dg/pr36194.c b/gcc/testsuite/gcc.dg/pr36194.c
new file mode 100644
index 00000000000..3d2195b03d4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr36194.c
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+void abort (void);
+
+__attribute__ ((noinline)) void
+f (int i)
+{
+  if (i != 0x87654321)
+    abort ();
+  asm ("");
+}
+
+__attribute__ ((noinline)) void
+g (long long a)
+{
+  f (a);
+  asm ("");
+}
+
+main ()
+{
+  g (0x1234567887654321ll);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr37544.c b/gcc/testsuite/gcc.dg/pr37544.c
new file mode 100644
index 00000000000..9dba8c4858d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr37544.c
@@ -0,0 +1,38 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+/* { dg-options "-O2 -msse2 -mtune=nocona -mfpmath=387" { target { i?86-*-* x86_64-*-* } } } */
+
+#ifdef __i386__
+#include "i386-cpuid.h"
+#endif
+
+extern void abort (void);
+
+int main(void)
+{
+  double arr[1000];
+  double a, b;
+
+  int i;
+
+#ifdef __i386__
+  unsigned long cpu_facilities;
+
+  cpu_facilities = i386_cpuid_edx ();
+ 
+  /* Run SSE2 test only if host has SSE2 support.  */
+  if (!(cpu_facilities & bit_SSE2))
+    return 0;
+#endif
+
+  for (i = 0; i < 1000; i++)
+    arr[i] = 4294967296.0 + (double)i;
+
+  a = arr[0];
+  b = (unsigned int)((unsigned long long int)a % 4294967296ULL);
+
+  if (b >= 4294967296.0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr37731-1.c b/gcc/testsuite/gcc.dg/torture/pr37731-1.c
new file mode 100644
index 00000000000..5c156b1f9a6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr37731-1.c
@@ -0,0 +1,17 @@
+/* { dg-do run } */
+
+extern void abort ();
+
+unsigned long long xh = 1;
+
+int
+main ()
+{
+  unsigned long long yh = 0xffffffffull;
+  unsigned long long z = xh * yh;
+
+  if (z != yh)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr37731-2.c b/gcc/testsuite/gcc.dg/torture/pr37731-2.c
new file mode 100644
index 00000000000..a7f8f1e02e5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr37731-2.c
@@ -0,0 +1,17 @@
+/* { dg-do run } */
+
+extern void abort ();
+
+long long xh = 1;
+
+int
+main ()
+{
+  long long yh = 0xffffffffll;
+  long long z = xh * yh;
+
+  if (z != yh)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/union-5.c b/gcc/testsuite/gcc.dg/union-5.c
new file mode 100644
index 00000000000..983ce7209ee
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/union-5.c
@@ -0,0 +1,46 @@
+/* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-O -fgcse" } */
+
+extern void abort(void);
+
+typedef unsigned short int uint16_t;
+typedef unsigned int uint32_t;
+typedef unsigned long long uint64_t;
+
+typedef struct
+{
+  uint16_t thread;
+  uint16_t phase;
+} s32;
+
+typedef union
+{
+  uint32_t i;
+  s32 s;
+} u32;
+
+typedef union
+{
+  uint64_t i;
+  u32 u;
+} u64;
+
+static __attribute__((noinline))
+void foo(int val)
+{
+  u64 data;
+  uint32_t thread;
+
+  data.u.i = 0x10000L;
+  thread = data.u.s.thread;
+  if (val)
+    abort ();
+  if (thread)
+    abort ();
+}
+
+int main(void)
+{
+  foo (0);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/mmx-8.c b/gcc/testsuite/gcc.target/i386/mmx-8.c
new file mode 100644
index 00000000000..bb5e8a8337a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/mmx-8.c
@@ -0,0 +1,150 @@
+/* PR middle-end/37809 */
+
+/* { dg-do run } */
+/* { dg-options "-O2 -mmmx" } */
+
+#include <mmintrin.h>
+#include "../../gcc.dg/i386-cpuid.h"
+
+// Various tests of cases where it is incorrect to optimise vectors as if they
+// were integers of the same width.
+
+extern void abort (void);
+extern void exit (int);
+
+void __attribute__ ((noinline))
+Sshift()
+{
+    volatile __m64 y = (__m64) 0xffffffffll;
+    __m64 x = y & (__m64) 0xffffffffll;
+    x = _m_psradi (x, 1);
+    x &= (__m64) 0x80000000ll;
+    if (0 == (long long) x)
+        abort();
+}
+
+#define SHIFTU(F,B,S,T)                         \
+    void F()                                    \
+    {                                           \
+        volatile __m64 y = (__m64) 0ll;         \
+        __m64 x = y | (__m64) (1llu << B);      \
+        if (S > 0)                              \
+            x = _m_pslldi (x, S);               \
+        else                                    \
+            x = _m_psrldi (x, -S);              \
+        if (T > 0)                              \
+            x = _m_pslldi (x, T);               \
+        else                                    \
+            x = _m_psrldi (x, -T);              \
+        x &= (__m64) (1llu << (B + S + T));     \
+        if ((long long) x)                      \
+            abort();                            \
+    }
+
+SHIFTU (shiftU1, 31, 1, -1)
+SHIFTU (shiftU2, 32, -1, 1)
+SHIFTU (shiftU3, 31, 1, 0)
+SHIFTU (shiftU4, 32, -1, 0)
+
+void __attribute__ ((noinline))
+add_1()
+{
+    volatile long long ONE = 1;
+    long long one = ONE;
+
+    __m64 a = (__m64) one;
+    __m64 b = (__m64) -one;
+    __m64 c = a + b;
+    if (0 == (long long) c)
+        abort();
+}
+
+void __attribute__ ((noinline))
+add_2()
+{
+    volatile long long ONE = 1;
+    long long one = ONE;
+
+    __m64 a = (__m64) one;
+    __m64 b = (__m64) -one;
+    __m64 c = _m_paddd (a, b);
+    if (0 == (long long) c)
+        abort();
+}
+
+void __attribute__ ((noinline))
+mult_1()
+{
+    volatile __m64 y = (__m64) 0ll;
+    __m64 x = y | (__m64) (1ll << 32);
+    x = x * (__m64) 1ll;
+    x &= (__m64) (1ll << 32);
+    if (0 != (long long) x)
+        abort();
+}
+
+void __attribute__ ((noinline))
+mult_2()
+{
+    volatile int foo = 1;
+    unsigned long long one = foo & 1;
+
+    __m64 x = (__m64) (one << 16);
+    x *= x;
+    x &= (__m64) (1ll << 32);
+    if (0 != (long long) x)
+        abort();
+}
+
+void __attribute__ ((noinline))
+mult_3()
+{
+    volatile __m64 y = (__m64) (1ll << 32);
+    __m64 a = y;
+    __m64 b = y * (__m64) 1ll;
+    if (((long long) a) == (long long) b)
+        abort();
+}
+
+void __attribute__ ((noinline))
+div_1()
+{
+    volatile __m64 y = (__m64) 0ll;
+    __m64 x = y | (__m64) (1ull << 32);
+    x |= (__m64) 1ull;
+    x = x / x;
+    if (1ll == (long long) x)
+        abort();
+}
+
+
+void mmx_test (void)
+{
+    Sshift();
+    shiftU1();
+    shiftU2();
+    shiftU3();
+    shiftU4();
+
+    add_1();
+    add_2();
+
+    mult_1();
+    mult_2();
+    mult_3();
+
+    div_1();
+}
+
+int main()
+{
+  unsigned long cpu_facilities;
+
+  cpu_facilities = i386_cpuid ();
+
+  if ((cpu_facilities & bit_MMX) == 0)
+    exit (0);
+
+  mmx_test ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr36438.c b/gcc/testsuite/gcc.target/i386/pr36438.c
new file mode 100644
index 00000000000..73b5b9dffa6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr36438.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mmmx" } */
+
+#include <mmintrin.h>
+
+extern __m64 SetS16 (unsigned short, unsigned short,
+		     unsigned short, unsigned short);
+
+void
+foo (__m64 * dest)
+{
+  __m64 mask = SetS16 (0x00FF, 0xFF00, 0x0000, 0x00FF);
+
+  mask = _mm_slli_si64 (mask, 8);
+  mask = _mm_slli_si64 (mask, 8);
+
+  *dest = mask;
+
+  _mm_empty ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr37101.c b/gcc/testsuite/gcc.target/i386/pr37101.c
new file mode 100644
index 00000000000..8fd3bfc5f85
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr37101.c
@@ -0,0 +1,64 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse2 -ftree-vectorize -march=nocona" } */
+
+typedef __SIZE_TYPE__ size_t;
+extern void *malloc (size_t);
+extern void free (void *);
+
+typedef struct _Resource
+{
+  struct _Resource *next;
+  unsigned int id;
+} ResourceRec, *ResourcePtr;
+
+typedef struct _ClientResource
+{
+  ResourcePtr *resources;
+  int elements;
+  int buckets;
+  int hashsize;
+} ClientResourceRec;
+
+static ClientResourceRec clientTable[256];
+
+void
+RebuildTable (int client)
+{
+  int j;
+  ResourcePtr res, next;
+  ResourcePtr **tails, *resources;
+  ResourcePtr **tptr, *rptr;
+
+  j = 2 * clientTable[client].buckets;
+
+  tails =
+    (ResourcePtr **) malloc ((unsigned long) (j * sizeof (ResourcePtr *)));
+  resources =
+    (ResourcePtr *) malloc ((unsigned long) (j * sizeof (ResourcePtr)));
+
+  for (rptr = resources, tptr = tails; --j >= 0; rptr++, tptr++)
+    {
+      *rptr = ((ResourcePtr) ((void *) 0));
+      *tptr = rptr;
+    }
+
+  clientTable[client].hashsize++;
+  for (j = clientTable[client].buckets,
+       rptr = clientTable[client].resources; --j >= 0; rptr++)
+    {
+      for (res = *rptr; res; res = next)
+	{
+	  next = res->next;
+	  res->next = ((ResourcePtr) ((void *) 0));
+	  tptr = &tails[Hash (client, res->id)];
+	  **tptr = res;
+	  *tptr = &res->next;
+	}
+    }
+  free ((void *) tails);
+  clientTable[client].buckets *= 2;
+  free ((void *) clientTable[client].resources);
+  clientTable[client].resources = resources;
+}
+
+/* { dg-final { scan-assembler-not "movlps" } } */
diff --git a/gcc/testsuite/gnat.dg/conv_decimal.adb b/gcc/testsuite/gnat.dg/conv_decimal.adb
new file mode 100644
index 00000000000..d5199c1b48b
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/conv_decimal.adb
@@ -0,0 +1,34 @@
+-- PR middle-end/36575
+-- reporter: Laurent Guerby <laurent@guerby.net>
+-- { dg-do run }
+
+procedure Conv_Decimal is
+
+  type Unsigned_Over_8 is mod 2**8+2;
+  type Signed_Over_8 is range -200 .. 200;
+
+  procedure Assert(Truth: Boolean) is
+  begin
+    if not Truth then
+      raise Program_Error;
+    end if;
+  end;
+
+  type Decim is delta 0.1 digits 5;
+
+  Halfway  : Decim := 2.5;
+  Neg_Half : Decim := -2.5;
+
+  Big      : Unsigned_Over_8;
+  Also_Big : Signed_Over_8;
+
+begin
+  Big := Unsigned_Over_8 (Halfway); -- Rounds up by 4.6(33).
+  Assert(Big = 3);
+
+  Also_Big := Signed_Over_8 (Halfway); -- Rounds up by 4.6(33).
+  Assert(Also_Big = 3);
+
+  Also_Big := Signed_Over_8 (Neg_Half); -- Rounds down by 4.6(33).
+  Assert(Also_Big = -3);
+end;
diff --git a/gcc/tree-nested.c b/gcc/tree-nested.c
index c7c25360a6f..9337423c939 100644
--- a/gcc/tree-nested.c
+++ b/gcc/tree-nested.c
@@ -749,7 +749,7 @@ check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)
   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)
     {
       for (arg = DECL_ARGUMENTS (cgn->decl); arg; arg = TREE_CHAIN (arg))
-	if (variably_modified_type_p (TREE_TYPE (arg), 0), orig_fndecl)
+	if (variably_modified_type_p (TREE_TYPE (arg), orig_fndecl))
 	  return true;
 
       if (check_for_nested_with_variably_modified (cgn->decl, orig_fndecl))
diff --git a/libdecnumber/ChangeLog b/libdecnumber/ChangeLog
index 0f3f6ee93ba..54b0a64ed15 100644
--- a/libdecnumber/ChangeLog
+++ b/libdecnumber/ChangeLog
@@ -1,3 +1,11 @@
+2008-06-16  Ben Elliston  <bje@au.ibm.com>
+
+	boostrap/27367
+	Backport from mainline:
+
+	2008-04-18  Ben Elliston  <bje@au.ibm.com>
+	* Makefile.in (distclean): Add gstdint.h.
+
 2008-05-19  Release Manager
 
 	* GCC 4.2.4 released.
diff --git a/libdecnumber/Makefile.in b/libdecnumber/Makefile.in
index c020e0b7a07..10c84b9839d 100644
--- a/libdecnumber/Makefile.in
+++ b/libdecnumber/Makefile.in
@@ -122,7 +122,7 @@ clean: mostlyclean
 distclean: clean
 	-rm -f config.h stamp-h1 config.status config.cache config.log \
 	  configure.lineno configure.status.lineno Makefile localedir.h \
-	  localedir.hs
+	  localedir.hs gstdint.h
 
 maintainer-clean: distclean
 	@echo "This command is intended for maintainers to use"
