diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index be37364ac60..4a7a86b9837 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,169 @@
+2001-10-02  Zack Weinberg  <zack@codesourcery.com>
+
+	* gcc.c (main): Set this_file_error if the appropriate
+	compiler for a language has not been installed.
+
+2001-09-17  Philip Blundell  <philb@gnu.org>
+
+	* cccp.c (print_help): Fix typos.
+
+2001-08-29  David O'Brien  <obrien@FreeBSD.org>
+
+	* config/alpha/crtbegin.asm: The normal calling convention for alpha is
+	to re-initialize gp using 'ldgp gp,0(ra)' after a jsr instruction.
+
+2001-06-19  Bernd Schmidt  <bernds@redhat.com>
+
+	* regmove.c (optimize_reg_copy_3): Do nothing if previous insn
+	carries a REG_EQUIV note.  If it carries REG_EQUAL, delete the
+	note.
+
+2001-05-22  Bernd Schmidt  <bernds@redhat.com>
+
+	* sparc.md (movsf, movdf): Allow constant to integer reg moves.
+	(movsf, movdf splitters): Always split if there's an alignment
+	problem.
+
+2001-05-22  David Edelsohn  <dje@watson.ibm.com>
+
+	* rs6000.md (movsfcc,movdfcc): Remove NE case.
+
+2001-05-17  Bernd Schmidt  <bernds@redhat.com>
+
+	* function.c: Small formatting change to prevent compilation errors
+	on broken hpux systems.
+
+	* expr.c (protect_from_queue): Protect against subsequent calls to
+	emit_queue.
+	(expand_expr, case ADDR_EXPR): Prevent protect_from_queue from being
+	too clever.
+
+2001-04-06  Bernd Schmidt  <bernds@redhat.com>
+
+	2000-10-17  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>
+	* function.c (locate_and_pad_parm): Don't align stack unconditionally.
+
+	Thu Oct 28 10:20:02 1999  Geoffrey Keating  <geoffk@cygnus.com>
+	* config/rs6000/rs6000.md (movsf): Don't convert a SUBREG
+	of the function return register into a plain REG until
+	after function inlining is done.
+
+2001-04-04  Bernd Schmidt  <bernds@redhat.com>
+
+	Fri Nov  5 10:07:25 1999  Nick Clifton  <nickc@cygnus.com>
+	* function.c (is_addressof): New function.  Returns true if
+	the given piece of RTL is an ADDRESSOF.
+	(purge_addressof_1): Make boolean.  Return false if the
+	ADDRESSOFs could not be purged.
+	(purge_addressof): If ADDRESSOFs could not be purged from the
+	notes attached to an insn, remove the offending note(s),
+	unless they are attached to a libcall.
+
+2001-04-03  Bernd Schmidt  <bernds@redhat.com>
+
+	2001-03-16  Jakub Jelinek  <jakub@redhat.com>
+	* crtstuff.c (init_dummy): Use CRT_END_INIT_DUMMY if defined.
+	Remove ia32 linux PIC kludge and move it...
+	* config/i386/linux.h (CRT_END_INIT_DUMMY): ...here.
+
+	* loop.c (combine_movables): Restrict combinations of constants with
+	different modes so that we don't introduce SUBREGs into memory
+	addresses.
+
+	2001-02-02  Philip Blundell  <philb@gnu.org>
+	* arm/linux-elf.h (MAKE_DECL_ONE_ONLY, UNIQUE_SECTION_P): Define.
+	(UNIQUE_SECTION): Define.                                  
+
+	Wed Aug 25 15:27:22 1999  Gavin Romig-Koch  <gavin@cygnus.com>
+	* combine.c (nonzero_bits) : Allow single-ly set registers to be
+	anywere in the function only if they are pseudos and set before
+	being used (not live at the start of the function).
+	(num_sign_bit_copies) : Same.
+	(get_last_value_validate) : Same.
+	(get_last_value) : Same.
+
+	Fri Mar  3 12:49:28 2000  J"orn Rennecke <amylaar@cygnus.co.uk>
+        * reload1.c (reload_combine_note_use): Handle return register USEs.
+	REG case: Handle multi-hard-register hard regs.
+
+2001-03-30  Bernd Schmidt  <bernds@redhat.com>
+
+	* jump.c (delete_barrier_successors): Fix error in last change.
+
+	* reload1.c (delete_output_reload): Call eliminate_regs on substed.
+	(reload_as_needed): Call update_eliminable_offsets a bit later.
+
+	* final.c (cleanup_subreg_operands): Also clean up inside MEMs.
+
+	Mon Oct  4 02:31:20 1999  Mark Mitchell  <mark@codesourcery.com>
+	* mips.md: Define conditional move patterns for floating point
+	operands and DI mode conditions.
+
+	2000-11-25  Jakub Jelinek  <jakub@redhat.com>
+	* config/sparc/sparc.md (muldi3_v8plus): Remove H constraint.
+	Handle CONST_INT as second argument.
+
+2001-03-28  Bernd Schmidt  <bernds@redhat.com>
+
+	* flow.c (propagate_block): When trying to delete a case vector, cope
+	if its label has LABEL_PRESERVE_P set.
+	* jump.c (jump_optimize_1): Move call to delete_barrier_successors to
+	a point where JUMP_LABELS and LABEL_NUSES are set up properly.
+	(delete_barrier_successors): If deleting a table jump, delete the case
+	vector as well.
+	* varasm.c (force_const_mem): If we have a label, set LABEL_PRESERVE_P
+	so it won't get deleted.
+
+Tue Mar 20 18:31:48 2001  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	1999-11-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+        * c-lex.c (yylex): With -Wtraditional, when the ANSI type of an
+	integer constant does not match the traditional type, limit the
+	warnings to cases where the base of the type is ten.
+
+        * invoke.texi (-Wtraditional): Document it.
+
+2001-03-20  David O'Brien  <obrien@FreeBSD.org>
+
+	from 2000-07-12  Zack Weinberg  <zack@wolery.cumb.org>
+	* final.c (profile_function): Do not emit profile counters in
+	the data section, if NO_PROFILE_COUNTERS is defined.
+	* tm.texi: Document NO_PROFILE_COUNTERS.  Update doc for
+	FUNCTION_PROFILER.
+
+	from 2000-10-02  David O'Brien  <obrien@dragon.nuxi.com>
+	* config/i386/freebsd.h (NO_PROFILE_COUNTERS): Define.
+
+2001-03-19  Bernd Schmidt  <bernds@redhat.com>
+
+	* version.c: Bump.
+
+	2000-01-18  Martin v. Löwis  <loewis@informatik.hu-berlin.de>
+	* c-parse.in (SAVE_WARN_FLAGS): Create an INTEGER_CST.
+	(RESTORE_WARN_FLAGS): Unpack it.
+	Change semantic type of extension to ttype.
+	* c-common.c (split_specs_attrs): Expect an INTEGER_CST.
+	* c-parse.y, c-parse.c, objc/objc-parse.y,
+	objc/objc-parse.c: Regenerate.
+
+	Wed Sep  1 09:12:02 1999  Jim Kingdon  <http://developer.redhat.com>
+	* c-parse.in: save and restore warn_pointer_arith on __extension__
+	along with pedantic.
+	(SAVE_WARN_FLAGS, RESTORE_WARN_FLAGS): Added.
+	Set the type of extension to itype rather than $<itype>1 kludge.
+	* extend.texi (Alternate Keywords): Adjust documentation.
+
+	Bring back the sjlj eh fixes.
+	* expr.c (expand_builtin_setjmp_setup): New.
+	(expand_builtin_setjmp_receiver): New.
+	(expand_builtin_setjmp): Split out _setup and _receiver functions.
+	Move argument parsing in from ...
+	(expand_builtin): ... here.
+	* except.c (receive_exception_label): Branch around receiver
+	unless new-style exceptions.  Call expand_builtin_setjmp_receiver.
+	(start_dynamic_handler): Call expand_builtin_setjmp_setup.
+	* expr.h: Update builtin setjmp decls.
+
 Fri Mar 16 12:46:19 GMT 2001 Bernd Schmidt  (bernds@redhat.com)
 
 	* gcc-2.95.3 Released.
diff --git a/gcc/c-common.c b/gcc/c-common.c
index 59dd407758d..2b98e0c7c10 100644
--- a/gcc/c-common.c
+++ b/gcc/c-common.c
@@ -965,6 +965,15 @@ split_specs_attrs (specs_attrs, declspecs, prefix_attributes)
 {
   tree t, s, a, next, specs, attrs;
 
+  /* This can happen after an __extension__ in pedantic mode.  */
+  if (specs_attrs != NULL_TREE 
+      && TREE_CODE (specs_attrs) == INTEGER_CST)
+    {
+      *declspecs = NULL_TREE;
+      *prefix_attributes = NULL_TREE;
+      return;
+    }
+
   /* This can happen in c++ (eg: decl: typespec initdecls ';').  */
   if (specs_attrs != NULL_TREE
       && TREE_CODE (specs_attrs) != TREE_LIST)
diff --git a/gcc/c-lex.c b/gcc/c-lex.c
index 27c65f3fa27..8ee2fe40db3 100644
--- a/gcc/c-lex.c
+++ b/gcc/c-lex.c
@@ -1812,7 +1812,11 @@ yylex ()
 
 	    type = flag_traditional ? traditional_type : ansi_type;
 
-	    if (warn_traditional && traditional_type != ansi_type)
+	    /* We assume that constants specified in a non-decimal
+	       base are bit patterns, and that the programmer really
+	       meant what they wrote.  */
+	    if (warn_traditional && base == 10
+		&& traditional_type != ansi_type)
 	      {
 		if (TYPE_PRECISION (traditional_type)
 		    != TYPE_PRECISION (ansi_type))
diff --git a/gcc/c-parse.c b/gcc/c-parse.c
index 85a70035d5f..29b153c94e6 100644
--- a/gcc/c-parse.c
+++ b/gcc/c-parse.c
@@ -1,69 +1,68 @@
 
 /*  A Bison parser, made from c-parse.y
- by  GNU Bison version 1.25
-  */
+    by GNU Bison version 1.28  */
 
 #define YYBISON 1  /* Identify Bison output.  */
 
-#define	IDENTIFIER	258
-#define	TYPENAME	259
-#define	SCSPEC	260
-#define	TYPESPEC	261
-#define	TYPE_QUAL	262
-#define	CONSTANT	263
-#define	STRING	264
-#define	ELLIPSIS	265
-#define	SIZEOF	266
-#define	ENUM	267
-#define	STRUCT	268
-#define	UNION	269
-#define	IF	270
-#define	ELSE	271
-#define	WHILE	272
-#define	DO	273
-#define	FOR	274
-#define	SWITCH	275
-#define	CASE	276
-#define	DEFAULT	277
-#define	BREAK	278
-#define	CONTINUE	279
-#define	RETURN	280
-#define	GOTO	281
-#define	ASM_KEYWORD	282
-#define	TYPEOF	283
-#define	ALIGNOF	284
-#define	ATTRIBUTE	285
-#define	EXTENSION	286
-#define	LABEL	287
-#define	REALPART	288
-#define	IMAGPART	289
-#define	ASSIGN	290
-#define	OROR	291
-#define	ANDAND	292
-#define	EQCOMPARE	293
-#define	ARITHCOMPARE	294
-#define	LSHIFT	295
-#define	RSHIFT	296
-#define	UNARY	297
-#define	PLUSPLUS	298
-#define	MINUSMINUS	299
-#define	HYPERUNARY	300
-#define	POINTSAT	301
-#define	INTERFACE	302
-#define	IMPLEMENTATION	303
-#define	END	304
-#define	SELECTOR	305
-#define	DEFS	306
-#define	ENCODE	307
-#define	CLASSNAME	308
-#define	PUBLIC	309
-#define	PRIVATE	310
-#define	PROTECTED	311
-#define	PROTOCOL	312
-#define	OBJECTNAME	313
-#define	CLASS	314
-#define	ALIAS	315
-#define	OBJC_STRING	316
+#define	IDENTIFIER	257
+#define	TYPENAME	258
+#define	SCSPEC	259
+#define	TYPESPEC	260
+#define	TYPE_QUAL	261
+#define	CONSTANT	262
+#define	STRING	263
+#define	ELLIPSIS	264
+#define	SIZEOF	265
+#define	ENUM	266
+#define	STRUCT	267
+#define	UNION	268
+#define	IF	269
+#define	ELSE	270
+#define	WHILE	271
+#define	DO	272
+#define	FOR	273
+#define	SWITCH	274
+#define	CASE	275
+#define	DEFAULT	276
+#define	BREAK	277
+#define	CONTINUE	278
+#define	RETURN	279
+#define	GOTO	280
+#define	ASM_KEYWORD	281
+#define	TYPEOF	282
+#define	ALIGNOF	283
+#define	ATTRIBUTE	284
+#define	EXTENSION	285
+#define	LABEL	286
+#define	REALPART	287
+#define	IMAGPART	288
+#define	ASSIGN	289
+#define	OROR	290
+#define	ANDAND	291
+#define	EQCOMPARE	292
+#define	ARITHCOMPARE	293
+#define	LSHIFT	294
+#define	RSHIFT	295
+#define	UNARY	296
+#define	PLUSPLUS	297
+#define	MINUSMINUS	298
+#define	HYPERUNARY	299
+#define	POINTSAT	300
+#define	INTERFACE	301
+#define	IMPLEMENTATION	302
+#define	END	303
+#define	SELECTOR	304
+#define	DEFS	305
+#define	ENCODE	306
+#define	CLASSNAME	307
+#define	PUBLIC	308
+#define	PRIVATE	309
+#define	PROTECTED	310
+#define	PROTOCOL	311
+#define	OBJECTNAME	312
+#define	CLASS	313
+#define	ALIAS	314
+#define	OBJC_STRING	315
 
 #line 56 "c-parse.y"
 
@@ -119,6 +118,17 @@ static tree declspec_stack;
 /* 1 if we explained undeclared var errors.  */
 static int undeclared_variable_notice;
 
+/* For __extension__, save/restore the warning flags which are
+   controlled by __extension__.  */
+#define SAVE_WARN_FLAGS()	\
+	build_int_2 (pedantic | (warn_pointer_arith << 1), 0)
+#define RESTORE_WARN_FLAGS(tval) \
+  do {                                     \
+    int val = TREE_INT_CST_LOW (tval);     \
+    pedantic = val & 1;                    \
+    warn_pointer_arith = (val >> 1) & 1;   \
+  } while (0)
+
 
 /* Tell yyparse how to print a token's value, if yydebug is set.  */
 
@@ -138,7 +148,7 @@ extern void yyprint			PROTO ((FILE *, int, YYSTYPE));
 #define	YYFLAG		-32768
 #define	YYNTBASE	84
 
-#define YYTRANSLATE(x) ((unsigned)(x) <= 316 ? yytranslate[x] : 241)
+#define YYTRANSLATE(x) ((unsigned)(x) <= 315 ? yytranslate[x] : 241)
 
 static const char yytranslate[] = {     0,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -166,13 +176,13 @@ static const char yytranslate[] = {     0,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
-     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
-    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
-    39,    40,    44,    45,    46,    47,    53,    54,    55,    56,
-    57,    61,    62,    63,    64,    65,    66,    67,    68,    69,
-    70,    71,    72,    73,    74,    75
+     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
+     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+    27,    28,    29,    30,    31,    32,    33,    34,    35,    39,
+    40,    44,    45,    46,    47,    53,    54,    55,    56,    57,
+    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
+    71,    72,    73,    74,    75
 };
 
 #if YYDEBUG != 0
@@ -357,47 +367,47 @@ static const short yyrhs[] = {    -1,
 
 #if YYDEBUG != 0
 static const short yyrline[] = { 0,
-   233,   238,   252,   254,   254,   255,   257,   259,   260,   268,
-   272,   283,   288,   293,   295,   297,   298,   299,   304,   311,
-   313,   318,   323,   329,   331,   336,   341,   347,   349,   354,
-   361,   363,   366,   368,   370,   372,   374,   376,   378,   382,
-   386,   389,   392,   395,   399,   401,   404,   407,   411,   439,
-   445,   448,   451,   454,   456,   460,   464,   468,   470,   473,
-   477,   504,   506,   508,   510,   512,   514,   516,   518,   520,
-   522,   524,   526,   528,   530,   534,   536,   540,   542,   545,
-   549,   551,   558,   561,   569,   580,   679,   680,   682,   688,
-   690,   704,   727,   729,   731,   735,   741,   743,   748,   750,
-   755,   757,   758,   768,   773,   775,   776,   777,   784,   790,
-   795,   798,   806,   811,   813,   814,   815,   822,   833,   837,
-   843,   848,   853,   858,   860,   862,   871,   874,   878,   880,
-   882,   887,   891,   894,   898,   901,   903,   915,   918,   920,
-   922,   926,   930,   932,   935,   948,   951,   955,   957,   965,
-   966,   967,   971,   973,   979,   980,   981,   984,   986,   989,
-   991,   994,   997,  1003,  1010,  1012,  1019,  1026,  1029,  1036,
-  1039,  1043,  1046,  1050,  1055,  1058,  1062,  1065,  1067,  1069,
-  1071,  1078,  1080,  1081,  1082,  1087,  1089,  1094,  1102,  1107,
-  1111,  1114,  1116,  1121,  1123,  1124,  1127,  1127,  1130,  1133,
-  1135,  1137,  1140,  1142,  1145,  1151,  1153,  1157,  1168,  1176,
-  1180,  1191,  1199,  1206,  1208,  1213,  1216,  1221,  1223,  1225,
-  1232,  1234,  1242,  1248,  1253,  1255,  1257,  1264,  1266,  1272,
-  1278,  1280,  1282,  1287,  1289,  1296,  1298,  1301,  1304,  1308,
-  1311,  1315,  1318,  1322,  1327,  1329,  1333,  1335,  1337,  1339,
-  1343,  1345,  1348,  1351,  1354,  1357,  1361,  1363,  1366,  1368,
-  1373,  1376,  1381,  1383,  1385,  1399,  1406,  1411,  1417,  1422,
-  1424,  1429,  1431,  1435,  1439,  1443,  1453,  1455,  1460,  1465,
-  1468,  1472,  1475,  1479,  1482,  1485,  1488,  1492,  1495,  1499,
-  1503,  1505,  1507,  1509,  1511,  1513,  1515,  1517,  1521,  1529,
-  1537,  1539,  1541,  1545,  1547,  1550,  1553,  1564,  1566,  1571,
-  1573,  1576,  1590,  1593,  1596,  1598,  1600,  1608,  1616,  1627,
-  1632,  1635,  1649,  1658,  1662,  1666,  1670,  1676,  1680,  1685,
-  1688,  1693,  1696,  1697,  1714,  1719,  1722,  1734,  1736,  1746,
-  1756,  1757,  1765,  1768,  1780,  1784,  1801,  1811,  1820,  1825,
-  1830,  1835,  1839,  1843,  1854,  1861,  1868,  1875,  1886,  1892,
-  1895,  1900,  1923,  1957,  1988,  2019,  2034,  2048,  2052,  2056,
-  2059,  2064,  2066,  2069,  2071,  2075,  2080,  2083,  2089,  2094,
-  2099,  2101,  2110,  2111,  2117,  2119,  2129,  2131,  2135,  2138,
-  2144,  2154,  2163,  2172,  2182,  2196,  2201,  2206,  2208,  2217,
-  2220,  2225,  2228,  2232
+   244,   249,   263,   265,   265,   266,   268,   270,   271,   279,
+   283,   294,   299,   304,   306,   308,   309,   310,   315,   322,
+   324,   329,   334,   340,   342,   347,   352,   358,   360,   365,
+   372,   374,   377,   379,   381,   383,   385,   387,   389,   393,
+   397,   400,   403,   406,   410,   412,   415,   418,   422,   450,
+   456,   459,   462,   465,   467,   471,   475,   479,   481,   484,
+   488,   515,   517,   519,   521,   523,   525,   527,   529,   531,
+   533,   535,   537,   539,   541,   545,   547,   551,   553,   556,
+   560,   562,   569,   572,   580,   591,   690,   691,   693,   699,
+   701,   715,   738,   740,   742,   746,   752,   754,   759,   761,
+   766,   768,   769,   779,   784,   786,   787,   788,   795,   801,
+   806,   809,   817,   822,   824,   825,   826,   833,   844,   848,
+   854,   859,   864,   869,   871,   873,   882,   885,   889,   891,
+   893,   898,   902,   905,   909,   912,   914,   926,   929,   931,
+   933,   937,   941,   943,   946,   959,   962,   966,   968,   976,
+   977,   978,   982,   984,   990,   991,   992,   995,   997,  1000,
+  1002,  1005,  1008,  1014,  1021,  1023,  1030,  1037,  1040,  1047,
+  1050,  1054,  1057,  1061,  1066,  1069,  1073,  1076,  1078,  1080,
+  1082,  1089,  1091,  1092,  1093,  1098,  1100,  1105,  1113,  1118,
+  1122,  1125,  1127,  1132,  1134,  1135,  1138,  1138,  1141,  1144,
+  1146,  1148,  1151,  1153,  1156,  1162,  1164,  1168,  1179,  1187,
+  1191,  1202,  1210,  1217,  1219,  1224,  1227,  1232,  1234,  1236,
+  1243,  1245,  1253,  1259,  1264,  1266,  1268,  1275,  1277,  1283,
+  1289,  1291,  1293,  1298,  1300,  1307,  1309,  1312,  1315,  1319,
+  1322,  1326,  1329,  1333,  1338,  1340,  1344,  1346,  1348,  1350,
+  1354,  1356,  1359,  1362,  1365,  1368,  1372,  1374,  1377,  1379,
+  1384,  1387,  1392,  1394,  1396,  1410,  1417,  1422,  1428,  1433,
+  1435,  1440,  1442,  1446,  1450,  1454,  1464,  1466,  1471,  1476,
+  1479,  1483,  1486,  1490,  1493,  1496,  1499,  1503,  1506,  1510,
+  1514,  1516,  1518,  1520,  1522,  1524,  1526,  1528,  1532,  1540,
+  1548,  1550,  1552,  1556,  1558,  1561,  1564,  1575,  1577,  1582,
+  1584,  1587,  1601,  1604,  1607,  1609,  1611,  1619,  1627,  1638,
+  1643,  1646,  1660,  1669,  1673,  1677,  1681,  1687,  1691,  1696,
+  1699,  1704,  1707,  1708,  1725,  1730,  1733,  1745,  1747,  1757,
+  1767,  1768,  1776,  1779,  1791,  1795,  1812,  1822,  1831,  1836,
+  1841,  1846,  1850,  1854,  1865,  1872,  1879,  1886,  1897,  1903,
+  1906,  1911,  1934,  1968,  1999,  2030,  2045,  2059,  2063,  2067,
+  2070,  2075,  2077,  2080,  2082,  2086,  2091,  2094,  2100,  2105,
+  2110,  2112,  2121,  2122,  2128,  2130,  2140,  2142,  2146,  2149,
+  2155,  2165,  2174,  2183,  2193,  2207,  2212,  2217,  2219,  2228,
+  2231,  2236,  2239,  2243
 };
 #endif
 
@@ -1206,6 +1216,7 @@ static const short yycheck[] = {    38,
 };
 /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
 #line 3 "/usr/lib/bison.simple"
+/* This file comes from bison-1.28.  */
 
 /* Skeleton output parser for bison,
    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
@@ -1222,46 +1233,66 @@ static const short yycheck[] = {    38,
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
 
 /* As a special exception, when this file is copied by Bison into a
    Bison output file, you may use that output file without restriction.
    This special exception was added by the Free Software Foundation
    in version 1.24 of Bison.  */
 
-#ifndef alloca
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+#ifndef YYSTACK_USE_ALLOCA
+#ifdef alloca
+#define YYSTACK_USE_ALLOCA
+#else /* alloca not defined */
 #ifdef __GNUC__
+#define YYSTACK_USE_ALLOCA
 #define alloca __builtin_alloca
 #else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+#define YYSTACK_USE_ALLOCA
 #include <alloca.h>
 #else /* not sparc */
-#if defined (MSDOS) && !defined (__TURBOC__)
+/* We think this test detects Watcom and Microsoft C.  */
+/* This used to test MSDOS, but that is a bad idea
+   since that symbol is in the user namespace.  */
+#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+#if 0 /* No need for malloc.h, which pollutes the namespace;
+	 instead, just don't use alloca.  */
 #include <malloc.h>
+#endif
 #else /* not MSDOS, or __TURBOC__ */
 #if defined(_AIX)
-#include <malloc.h>
+/* I don't know what this was needed for, but it pollutes the namespace.
+   So I turned it off.   rms, 2 May 1997.  */
+/* #include <malloc.h>  */
  #pragma alloca
-#else /* not MSDOS, __TURBOC__, or _AIX */
-#ifdef __hpux
-#ifdef __cplusplus
-extern "C" {
-void *alloca (unsigned int);
-};
-#else /* not __cplusplus */
-void *alloca ();
-#endif /* not __cplusplus */
+#define YYSTACK_USE_ALLOCA
+#else /* not MSDOS, or __TURBOC__, or _AIX */
+#if 0
+#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+		 and on HPUX 10.  Eventually we can turn this on.  */
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
 #endif /* __hpux */
+#endif
 #endif /* not _AIX */
 #endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc.  */
-#endif /* not GNU C.  */
-#endif /* alloca not defined.  */
+#endif /* not sparc */
+#endif /* not GNU C */
+#endif /* alloca not defined */
+#endif /* YYSTACK_USE_ALLOCA not defined */
 
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
+#ifdef YYSTACK_USE_ALLOCA
+#define YYSTACK_ALLOC alloca
+#else
+#define YYSTACK_ALLOC malloc
+#endif
 
 /* Note: there must be only one dollar sign in this file.
    It is replaced by the list of actions, each action
@@ -1271,8 +1302,8 @@ void *alloca ();
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		-2
 #define YYEOF		0
-#define YYACCEPT	return(0)
-#define YYABORT 	return(1)
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
 #define YYERROR		goto yyerrlab1
 /* Like YYERROR except do call yyerror.
    This remains here temporarily to ease the
@@ -1353,12 +1384,12 @@ int yydebug;			/*  nonzero means print parse trace	*/
 #ifndef YYMAXDEPTH
 #define YYMAXDEPTH 10000
 #endif
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-int yyparse (void);
-#endif
 
+/* Define __yy_memcpy.  Note that the size argument
+   should be passed with type unsigned int, because that is what the non-GCC
+   definitions require.  With GCC, __builtin_memcpy takes an arg
+   of type size_t, but it can handle unsigned int.  */
+
 #if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
 #define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
 #else				/* not GNU C or C++ */
@@ -1370,7 +1401,7 @@ static void
 __yy_memcpy (to, from, count)
      char *to;
      char *from;
-     int count;
+     unsigned int count;
 {
   register char *f = from;
   register char *t = to;
@@ -1385,10 +1416,10 @@ __yy_memcpy (to, from, count)
 /* This is the most reliable way to avoid incompatibilities
    in available built-in functions on various systems.  */
 static void
-__yy_memcpy (char *to, char *from, int count)
+__yy_memcpy (char *to, char *from, unsigned int count)
 {
-  register char *f = from;
   register char *t = to;
+  register char *f = from;
   register int i = count;
 
   while (i-- > 0)
@@ -1398,7 +1429,7 @@ __yy_memcpy (char *to, char *from, int count)
 #endif
 #endif
 
-#line 196 "/usr/lib/bison.simple"
+#line 217 "/usr/lib/bison.simple"
 
 /* The user can define YYPARSE_PARAM as the name of an argument to be passed
    into yyparse.  The argument should have type void *.
@@ -1419,6 +1450,15 @@ __yy_memcpy (char *to, char *from, int count)
 #define YYPARSE_PARAM_DECL
 #endif /* not YYPARSE_PARAM */
 
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+#ifdef YYPARSE_PARAM
+int yyparse (void *);
+#else
+int yyparse (void);
+#endif
+#endif
+
 int
 yyparse(YYPARSE_PARAM_ARG)
      YYPARSE_PARAM_DECL
@@ -1447,6 +1487,7 @@ yyparse(YYPARSE_PARAM_ARG)
 #endif
 
   int yystacksize = YYINITDEPTH;
+  int yyfree_stacks = 0;
 
 #ifdef YYPURE
   int yychar;
@@ -1531,18 +1572,32 @@ yynewstate:
       if (yystacksize >= YYMAXDEPTH)
 	{
 	  yyerror("parser stack overflow");
+	  if (yyfree_stacks)
+	    {
+	      free (yyss);
+	      free (yyvs);
+#ifdef YYLSP_NEEDED
+	      free (yyls);
+#endif
+	    }
 	  return 2;
 	}
       yystacksize *= 2;
       if (yystacksize > YYMAXDEPTH)
 	yystacksize = YYMAXDEPTH;
-      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
-      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
+#ifndef YYSTACK_USE_ALLOCA
+      yyfree_stacks = 1;
+#endif
+      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1,
+		   size * (unsigned int) sizeof (*yyssp));
+      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
+		   size * (unsigned int) sizeof (*yyvsp));
 #ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
+      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1,
+		   size * (unsigned int) sizeof (*yylsp));
 #endif
 #endif /* no yyoverflow */
 
@@ -1703,14 +1758,14 @@ yyreduce:
   switch (yyn) {
 
 case 1:
-#line 234 "c-parse.y"
+#line 245 "c-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids an empty source file");
 		  finish_file ();
 		;
     break;}
 case 2:
-#line 239 "c-parse.y"
+#line 250 "c-parse.y"
 {
 		  /* In case there were missing closebraces,
 		     get us back to the global binding level.  */
@@ -1720,15 +1775,15 @@ case 2:
 		;
     break;}
 case 3:
-#line 253 "c-parse.y"
+#line 264 "c-parse.y"
 {yyval.ttype = NULL_TREE; ;
     break;}
 case 5:
-#line 254 "c-parse.y"
+#line 265 "c-parse.y"
 {yyval.ttype = NULL_TREE; ;
     break;}
 case 9:
-#line 261 "c-parse.y"
+#line 272 "c-parse.y"
 { STRIP_NOPS (yyvsp[-2].ttype);
 		  if ((TREE_CODE (yyvsp[-2].ttype) == ADDR_EXPR
 		       && TREE_CODE (TREE_OPERAND (yyvsp[-2].ttype, 0)) == STRING_CST)
@@ -1738,11 +1793,11 @@ case 9:
 		    error ("argument of `asm' is not a constant string"); ;
     break;}
 case 10:
-#line 269 "c-parse.y"
-{ pedantic = yyvsp[-1].itype; ;
+#line 280 "c-parse.y"
+{ RESTORE_WARN_FLAGS (yyvsp[-1].ttype); ;
     break;}
 case 11:
-#line 274 "c-parse.y"
+#line 285 "c-parse.y"
 { if (pedantic)
 		    error ("ANSI C forbids data definition with no type or storage class");
 		  else if (!flag_traditional)
@@ -1754,45 +1809,45 @@ case 11:
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 12:
-#line 284 "c-parse.y"
+#line 295 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 13:
-#line 289 "c-parse.y"
+#line 300 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype);  ;
     break;}
 case 14:
-#line 294 "c-parse.y"
+#line 305 "c-parse.y"
 { pedwarn ("empty declaration"); ;
     break;}
 case 15:
-#line 296 "c-parse.y"
+#line 307 "c-parse.y"
 { shadow_tag (yyvsp[-1].ttype); ;
     break;}
 case 18:
-#line 300 "c-parse.y"
+#line 311 "c-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C does not allow extra `;' outside of a function"); ;
     break;}
 case 19:
-#line 306 "c-parse.y"
+#line 317 "c-parse.y"
 { if (! start_function (current_declspecs, yyvsp[0].ttype,
 					prefix_attributes, NULL_TREE, 0))
 		    YYERROR1;
 		  reinit_parse_for_function (); ;
     break;}
 case 20:
-#line 311 "c-parse.y"
+#line 322 "c-parse.y"
 { store_parm_decls (); ;
     break;}
 case 21:
-#line 313 "c-parse.y"
+#line 324 "c-parse.y"
 { finish_function (0); 
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -1800,25 +1855,25 @@ case 21:
 		  resume_momentary (yyvsp[-5].itype); ;
     break;}
 case 22:
-#line 319 "c-parse.y"
+#line 330 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 23:
-#line 324 "c-parse.y"
+#line 335 "c-parse.y"
 { if (! start_function (current_declspecs, yyvsp[0].ttype,
 					prefix_attributes, NULL_TREE, 0))
 		    YYERROR1;
 		  reinit_parse_for_function (); ;
     break;}
 case 24:
-#line 329 "c-parse.y"
+#line 340 "c-parse.y"
 { store_parm_decls (); ;
     break;}
 case 25:
-#line 331 "c-parse.y"
+#line 342 "c-parse.y"
 { finish_function (0); 
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -1826,25 +1881,25 @@ case 25:
 		  resume_momentary (yyvsp[-5].itype); ;
     break;}
 case 26:
-#line 337 "c-parse.y"
+#line 348 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 27:
-#line 342 "c-parse.y"
+#line 353 "c-parse.y"
 { if (! start_function (NULL_TREE, yyvsp[0].ttype,
 					prefix_attributes, NULL_TREE, 0))
 		    YYERROR1;
 		  reinit_parse_for_function (); ;
     break;}
 case 28:
-#line 347 "c-parse.y"
+#line 358 "c-parse.y"
 { store_parm_decls (); ;
     break;}
 case 29:
-#line 349 "c-parse.y"
+#line 360 "c-parse.y"
 { finish_function (0); 
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -1852,72 +1907,72 @@ case 29:
 		  resume_momentary (yyvsp[-5].itype); ;
     break;}
 case 30:
-#line 355 "c-parse.y"
+#line 366 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 33:
-#line 367 "c-parse.y"
+#line 378 "c-parse.y"
 { yyval.code = ADDR_EXPR; ;
     break;}
 case 34:
-#line 369 "c-parse.y"
+#line 380 "c-parse.y"
 { yyval.code = NEGATE_EXPR; ;
     break;}
 case 35:
-#line 371 "c-parse.y"
+#line 382 "c-parse.y"
 { yyval.code = CONVERT_EXPR; ;
     break;}
 case 36:
-#line 373 "c-parse.y"
+#line 384 "c-parse.y"
 { yyval.code = PREINCREMENT_EXPR; ;
     break;}
 case 37:
-#line 375 "c-parse.y"
+#line 386 "c-parse.y"
 { yyval.code = PREDECREMENT_EXPR; ;
     break;}
 case 38:
-#line 377 "c-parse.y"
+#line 388 "c-parse.y"
 { yyval.code = BIT_NOT_EXPR; ;
     break;}
 case 39:
-#line 379 "c-parse.y"
+#line 390 "c-parse.y"
 { yyval.code = TRUTH_NOT_EXPR; ;
     break;}
 case 40:
-#line 383 "c-parse.y"
+#line 394 "c-parse.y"
 { yyval.ttype = build_compound_expr (yyvsp[0].ttype); ;
     break;}
 case 41:
-#line 388 "c-parse.y"
+#line 399 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 43:
-#line 394 "c-parse.y"
+#line 405 "c-parse.y"
 { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;
     break;}
 case 44:
-#line 396 "c-parse.y"
+#line 407 "c-parse.y"
 { chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;
     break;}
 case 46:
-#line 402 "c-parse.y"
+#line 413 "c-parse.y"
 { yyval.ttype = build_indirect_ref (yyvsp[0].ttype, "unary *"); ;
     break;}
 case 47:
-#line 405 "c-parse.y"
+#line 416 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
-		  pedantic = yyvsp[-1].itype; ;
+		  RESTORE_WARN_FLAGS (yyvsp[-1].ttype); ;
     break;}
 case 48:
-#line 408 "c-parse.y"
+#line 419 "c-parse.y"
 { yyval.ttype = build_unary_op (yyvsp[-1].code, yyvsp[0].ttype, 0);
 		  overflow_warning (yyval.ttype); ;
     break;}
 case 49:
-#line 412 "c-parse.y"
+#line 423 "c-parse.y"
 { tree label = lookup_label (yyvsp[0].ttype);
 		  if (pedantic)
 		    pedwarn ("ANSI C forbids `&&'");
@@ -1932,7 +1987,7 @@ case 49:
 		;
     break;}
 case 50:
-#line 440 "c-parse.y"
+#line 451 "c-parse.y"
 { skip_evaluation--;
 		  if (TREE_CODE (yyvsp[0].ttype) == COMPONENT_REF
 		      && DECL_C_BIT_FIELD (TREE_OPERAND (yyvsp[0].ttype, 1)))
@@ -1940,49 +1995,49 @@ case 50:
 		  yyval.ttype = c_sizeof (TREE_TYPE (yyvsp[0].ttype)); ;
     break;}
 case 51:
-#line 446 "c-parse.y"
+#line 457 "c-parse.y"
 { skip_evaluation--;
 		  yyval.ttype = c_sizeof (groktypename (yyvsp[-1].ttype)); ;
     break;}
 case 52:
-#line 449 "c-parse.y"
+#line 460 "c-parse.y"
 { skip_evaluation--;
 		  yyval.ttype = c_alignof_expr (yyvsp[0].ttype); ;
     break;}
 case 53:
-#line 452 "c-parse.y"
+#line 463 "c-parse.y"
 { skip_evaluation--;
 		  yyval.ttype = c_alignof (groktypename (yyvsp[-1].ttype)); ;
     break;}
 case 54:
-#line 455 "c-parse.y"
+#line 466 "c-parse.y"
 { yyval.ttype = build_unary_op (REALPART_EXPR, yyvsp[0].ttype, 0); ;
     break;}
 case 55:
-#line 457 "c-parse.y"
+#line 468 "c-parse.y"
 { yyval.ttype = build_unary_op (IMAGPART_EXPR, yyvsp[0].ttype, 0); ;
     break;}
 case 56:
-#line 461 "c-parse.y"
+#line 472 "c-parse.y"
 { skip_evaluation++; ;
     break;}
 case 57:
-#line 465 "c-parse.y"
+#line 476 "c-parse.y"
 { skip_evaluation++; ;
     break;}
 case 59:
-#line 471 "c-parse.y"
+#line 482 "c-parse.y"
 { tree type = groktypename (yyvsp[-2].ttype);
 		  yyval.ttype = build_c_cast (type, yyvsp[0].ttype); ;
     break;}
 case 60:
-#line 474 "c-parse.y"
+#line 485 "c-parse.y"
 { start_init (NULL_TREE, NULL, 0);
 		  yyvsp[-2].ttype = groktypename (yyvsp[-2].ttype);
 		  really_start_incremental_init (yyvsp[-2].ttype); ;
     break;}
 case 61:
-#line 478 "c-parse.y"
+#line 489 "c-parse.y"
 { char *name;
 		  tree result = pop_init_level (0);
 		  tree type = yyvsp[-5].ttype;
@@ -2009,90 +2064,90 @@ case 61:
 		;
     break;}
 case 63:
-#line 507 "c-parse.y"
+#line 518 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 64:
-#line 509 "c-parse.y"
+#line 520 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 65:
-#line 511 "c-parse.y"
+#line 522 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 66:
-#line 513 "c-parse.y"
+#line 524 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 67:
-#line 515 "c-parse.y"
+#line 526 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 68:
-#line 517 "c-parse.y"
+#line 528 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 69:
-#line 519 "c-parse.y"
+#line 530 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 70:
-#line 521 "c-parse.y"
+#line 532 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 71:
-#line 523 "c-parse.y"
+#line 534 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 72:
-#line 525 "c-parse.y"
+#line 536 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 73:
-#line 527 "c-parse.y"
+#line 538 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 74:
-#line 529 "c-parse.y"
+#line 540 "c-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 75:
-#line 531 "c-parse.y"
+#line 542 "c-parse.y"
 { yyvsp[-1].ttype = truthvalue_conversion (default_conversion (yyvsp[-1].ttype));
 		  skip_evaluation += yyvsp[-1].ttype == boolean_false_node; ;
     break;}
 case 76:
-#line 534 "c-parse.y"
+#line 545 "c-parse.y"
 { skip_evaluation -= yyvsp[-3].ttype == boolean_false_node;
 		  yyval.ttype = parser_build_binary_op (TRUTH_ANDIF_EXPR, yyvsp[-3].ttype, yyvsp[0].ttype); ;
     break;}
 case 77:
-#line 537 "c-parse.y"
+#line 548 "c-parse.y"
 { yyvsp[-1].ttype = truthvalue_conversion (default_conversion (yyvsp[-1].ttype));
 		  skip_evaluation += yyvsp[-1].ttype == boolean_true_node; ;
     break;}
 case 78:
-#line 540 "c-parse.y"
+#line 551 "c-parse.y"
 { skip_evaluation -= yyvsp[-3].ttype == boolean_true_node;
 		  yyval.ttype = parser_build_binary_op (TRUTH_ORIF_EXPR, yyvsp[-3].ttype, yyvsp[0].ttype); ;
     break;}
 case 79:
-#line 543 "c-parse.y"
+#line 554 "c-parse.y"
 { yyvsp[-1].ttype = truthvalue_conversion (default_conversion (yyvsp[-1].ttype));
 		  skip_evaluation += yyvsp[-1].ttype == boolean_false_node; ;
     break;}
 case 80:
-#line 546 "c-parse.y"
+#line 557 "c-parse.y"
 { skip_evaluation += ((yyvsp[-4].ttype == boolean_true_node)
 				      - (yyvsp[-4].ttype == boolean_false_node)); ;
     break;}
 case 81:
-#line 549 "c-parse.y"
+#line 560 "c-parse.y"
 { skip_evaluation -= yyvsp[-6].ttype == boolean_true_node;
 		  yyval.ttype = build_conditional_expr (yyvsp[-6].ttype, yyvsp[-3].ttype, yyvsp[0].ttype); ;
     break;}
 case 82:
-#line 552 "c-parse.y"
+#line 563 "c-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids omitting the middle term of a ?: expression");
 		  /* Make sure first operand is calculated only once.  */
@@ -2101,12 +2156,12 @@ case 82:
 		  skip_evaluation += yyvsp[-1].ttype == boolean_true_node; ;
     break;}
 case 83:
-#line 559 "c-parse.y"
+#line 570 "c-parse.y"
 { skip_evaluation -= yyvsp[-4].ttype == boolean_true_node;
 		  yyval.ttype = build_conditional_expr (yyvsp[-4].ttype, yyvsp[-3].ttype, yyvsp[0].ttype); ;
     break;}
 case 84:
-#line 562 "c-parse.y"
+#line 573 "c-parse.y"
 { char class;
 		  yyval.ttype = build_modify_expr (yyvsp[-2].ttype, NOP_EXPR, yyvsp[0].ttype);
 		  class = TREE_CODE_CLASS (TREE_CODE (yyval.ttype));
@@ -2116,7 +2171,7 @@ case 84:
 		;
     break;}
 case 85:
-#line 570 "c-parse.y"
+#line 581 "c-parse.y"
 { char class;
 		  yyval.ttype = build_modify_expr (yyvsp[-2].ttype, yyvsp[-1].code, yyvsp[0].ttype);
 		  /* This inhibits warnings in truthvalue_conversion.  */
@@ -2127,7 +2182,7 @@ case 85:
 		;
     break;}
 case 86:
-#line 582 "c-parse.y"
+#line 593 "c-parse.y"
 {
 		  yyval.ttype = lastiddecl;
 		  if (!yyval.ttype || yyval.ttype == error_mark_node)
@@ -2227,11 +2282,11 @@ case 86:
 		;
     break;}
 case 88:
-#line 681 "c-parse.y"
+#line 692 "c-parse.y"
 { yyval.ttype = combine_strings (yyvsp[0].ttype); ;
     break;}
 case 89:
-#line 683 "c-parse.y"
+#line 694 "c-parse.y"
 { char class = TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype));
 		  if (class == 'e' || class == '1'
 		      || class == '2' || class == '<')
@@ -2239,11 +2294,11 @@ case 89:
 		  yyval.ttype = yyvsp[-1].ttype; ;
     break;}
 case 90:
-#line 689 "c-parse.y"
+#line 700 "c-parse.y"
 { yyval.ttype = error_mark_node; ;
     break;}
 case 91:
-#line 691 "c-parse.y"
+#line 702 "c-parse.y"
 { if (current_function_decl == 0)
 		    {
 		      error ("braced-group within expression allowed only inside a function");
@@ -2259,7 +2314,7 @@ case 91:
 		  yyval.ttype = expand_start_stmt_expr (); ;
     break;}
 case 92:
-#line 705 "c-parse.y"
+#line 716 "c-parse.y"
 { tree rtl_exp;
 		  if (pedantic)
 		    pedwarn ("ANSI C forbids braced-groups within expressions");
@@ -2284,21 +2339,21 @@ case 92:
 		;
     break;}
 case 93:
-#line 728 "c-parse.y"
+#line 739 "c-parse.y"
 { yyval.ttype = build_function_call (yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 94:
-#line 730 "c-parse.y"
+#line 741 "c-parse.y"
 { yyval.ttype = build_array_ref (yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 95:
-#line 732 "c-parse.y"
+#line 743 "c-parse.y"
 {
 		    yyval.ttype = build_component_ref (yyvsp[-2].ttype, yyvsp[0].ttype);
 		;
     break;}
 case 96:
-#line 736 "c-parse.y"
+#line 747 "c-parse.y"
 {
                   tree expr = build_indirect_ref (yyvsp[-2].ttype, "->");
 
@@ -2306,56 +2361,56 @@ case 96:
 		;
     break;}
 case 97:
-#line 742 "c-parse.y"
+#line 753 "c-parse.y"
 { yyval.ttype = build_unary_op (POSTINCREMENT_EXPR, yyvsp[-1].ttype, 0); ;
     break;}
 case 98:
-#line 744 "c-parse.y"
+#line 755 "c-parse.y"
 { yyval.ttype = build_unary_op (POSTDECREMENT_EXPR, yyvsp[-1].ttype, 0); ;
     break;}
 case 100:
-#line 751 "c-parse.y"
+#line 762 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 103:
-#line 760 "c-parse.y"
+#line 771 "c-parse.y"
 { c_mark_varargs ();
 		  if (pedantic)
 		    pedwarn ("ANSI C does not permit use of `varargs.h'"); ;
     break;}
 case 104:
-#line 770 "c-parse.y"
+#line 781 "c-parse.y"
 { ;
     break;}
 case 109:
-#line 786 "c-parse.y"
+#line 797 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 110:
-#line 791 "c-parse.y"
+#line 802 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);	
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 111:
-#line 796 "c-parse.y"
+#line 807 "c-parse.y"
 { shadow_tag_warned (yyvsp[-1].ttype, 1);
 		  pedwarn ("empty declaration"); ;
     break;}
 case 112:
-#line 799 "c-parse.y"
+#line 810 "c-parse.y"
 { pedwarn ("empty declaration"); ;
     break;}
 case 113:
-#line 808 "c-parse.y"
+#line 819 "c-parse.y"
 { ;
     break;}
 case 118:
-#line 823 "c-parse.y"
+#line 834 "c-parse.y"
 { yyval.itype = suspend_momentary ();
 		  pending_xref_error ();
 		  declspec_stack = tree_cons (prefix_attributes,
@@ -2365,131 +2420,131 @@ case 118:
 				     &current_declspecs, &prefix_attributes); ;
     break;}
 case 119:
-#line 834 "c-parse.y"
+#line 845 "c-parse.y"
 { prefix_attributes = chainon (prefix_attributes, yyvsp[0].ttype); ;
     break;}
 case 120:
-#line 839 "c-parse.y"
+#line 850 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 121:
-#line 844 "c-parse.y"
+#line 855 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 122:
-#line 849 "c-parse.y"
+#line 860 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-1].itype); ;
     break;}
 case 123:
-#line 854 "c-parse.y"
+#line 865 "c-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-1].itype); ;
     break;}
 case 124:
-#line 859 "c-parse.y"
+#line 870 "c-parse.y"
 { shadow_tag (yyvsp[-1].ttype); ;
     break;}
 case 125:
-#line 861 "c-parse.y"
+#line 872 "c-parse.y"
 { pedwarn ("empty declaration"); ;
     break;}
 case 126:
-#line 863 "c-parse.y"
-{ pedantic = yyvsp[-1].itype; ;
+#line 874 "c-parse.y"
+{ RESTORE_WARN_FLAGS (yyvsp[-1].ttype); ;
     break;}
 case 127:
-#line 873 "c-parse.y"
+#line 884 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 128:
-#line 875 "c-parse.y"
+#line 886 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[0].ttype, tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[-2].ttype)); ;
     break;}
 case 129:
-#line 879 "c-parse.y"
+#line 890 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 130:
-#line 881 "c-parse.y"
+#line 892 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 131:
-#line 883 "c-parse.y"
+#line 894 "c-parse.y"
 { if (extra_warnings)
 		    warning ("`%s' is not at beginning of declaration",
 			     IDENTIFIER_POINTER (yyvsp[0].ttype));
 		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 132:
-#line 888 "c-parse.y"
+#line 899 "c-parse.y"
 { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype); ;
     break;}
 case 133:
-#line 893 "c-parse.y"
+#line 904 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 134:
-#line 895 "c-parse.y"
+#line 906 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[0].ttype, tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[-2].ttype)); ;
     break;}
 case 135:
-#line 900 "c-parse.y"
+#line 911 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 136:
-#line 902 "c-parse.y"
+#line 913 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 137:
-#line 904 "c-parse.y"
+#line 915 "c-parse.y"
 { if (extra_warnings)
 		    warning ("`%s' is not at beginning of declaration",
 			     IDENTIFIER_POINTER (yyvsp[0].ttype));
 		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 138:
-#line 917 "c-parse.y"
+#line 928 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 139:
-#line 919 "c-parse.y"
+#line 930 "c-parse.y"
 { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, NULL_TREE); ;
     break;}
 case 140:
-#line 921 "c-parse.y"
+#line 932 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 141:
-#line 923 "c-parse.y"
+#line 934 "c-parse.y"
 { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype); ;
     break;}
 case 142:
-#line 928 "c-parse.y"
+#line 939 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE);
 		  TREE_STATIC (yyval.ttype) = 1; ;
     break;}
 case 143:
-#line 931 "c-parse.y"
+#line 942 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 144:
-#line 933 "c-parse.y"
+#line 944 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
 		  TREE_STATIC (yyval.ttype) = 1; ;
     break;}
 case 145:
-#line 936 "c-parse.y"
+#line 947 "c-parse.y"
 { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
 		    warning ("`%s' is not at beginning of declaration",
 			     IDENTIFIER_POINTER (yyvsp[0].ttype));
@@ -2497,138 +2552,138 @@ case 145:
 		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;
     break;}
 case 146:
-#line 950 "c-parse.y"
+#line 961 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 147:
-#line 952 "c-parse.y"
+#line 963 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[0].ttype, tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[-2].ttype)); ;
     break;}
 case 148:
-#line 956 "c-parse.y"
+#line 967 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 149:
-#line 958 "c-parse.y"
+#line 969 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 152:
-#line 968 "c-parse.y"
+#line 979 "c-parse.y"
 { /* For a typedef name, record the meaning, not the name.
 		     In case of `foo foo, bar;'.  */
 		  yyval.ttype = lookup_name (yyvsp[0].ttype); ;
     break;}
 case 153:
-#line 972 "c-parse.y"
+#line 983 "c-parse.y"
 { yyval.ttype = TREE_TYPE (yyvsp[-1].ttype); ;
     break;}
 case 154:
-#line 974 "c-parse.y"
+#line 985 "c-parse.y"
 { yyval.ttype = groktypename (yyvsp[-1].ttype); ;
     break;}
 case 162:
-#line 996 "c-parse.y"
+#line 1007 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 163:
-#line 998 "c-parse.y"
+#line 1009 "c-parse.y"
 { if (TREE_CHAIN (yyvsp[-1].ttype)) yyvsp[-1].ttype = combine_strings (yyvsp[-1].ttype);
 		  yyval.ttype = yyvsp[-1].ttype;
 		;
     break;}
 case 164:
-#line 1005 "c-parse.y"
+#line 1016 "c-parse.y"
 { yyval.ttype = start_decl (yyvsp[-3].ttype, current_declspecs, 1,
 					  yyvsp[-1].ttype, prefix_attributes);
 		  start_init (yyval.ttype, yyvsp[-2].ttype, global_bindings_p ()); ;
     break;}
 case 165:
-#line 1010 "c-parse.y"
+#line 1021 "c-parse.y"
 { finish_init ();
 		  finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-4].ttype); ;
     break;}
 case 166:
-#line 1013 "c-parse.y"
+#line 1024 "c-parse.y"
 { tree d = start_decl (yyvsp[-2].ttype, current_declspecs, 0,
 				       yyvsp[0].ttype, prefix_attributes);
 		  finish_decl (d, NULL_TREE, yyvsp[-1].ttype); 
                 ;
     break;}
 case 167:
-#line 1021 "c-parse.y"
+#line 1032 "c-parse.y"
 { yyval.ttype = start_decl (yyvsp[-3].ttype, current_declspecs, 1,
 					  yyvsp[-1].ttype, prefix_attributes);
 		  start_init (yyval.ttype, yyvsp[-2].ttype, global_bindings_p ()); ;
     break;}
 case 168:
-#line 1026 "c-parse.y"
+#line 1037 "c-parse.y"
 { finish_init ();
 		  decl_attributes (yyvsp[-1].ttype, yyvsp[-3].ttype, prefix_attributes);
 		  finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-4].ttype); ;
     break;}
 case 169:
-#line 1030 "c-parse.y"
+#line 1041 "c-parse.y"
 { tree d = start_decl (yyvsp[-2].ttype, current_declspecs, 0,
 				       yyvsp[0].ttype, prefix_attributes);
 		  finish_decl (d, NULL_TREE, yyvsp[-1].ttype); ;
     break;}
 case 170:
-#line 1038 "c-parse.y"
+#line 1049 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 171:
-#line 1040 "c-parse.y"
+#line 1051 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 172:
-#line 1045 "c-parse.y"
+#line 1056 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 173:
-#line 1047 "c-parse.y"
+#line 1058 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 174:
-#line 1052 "c-parse.y"
+#line 1063 "c-parse.y"
 { yyval.ttype = yyvsp[-2].ttype; ;
     break;}
 case 175:
-#line 1057 "c-parse.y"
+#line 1068 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 176:
-#line 1059 "c-parse.y"
+#line 1070 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 177:
-#line 1064 "c-parse.y"
+#line 1075 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 178:
-#line 1066 "c-parse.y"
+#line 1077 "c-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 179:
-#line 1068 "c-parse.y"
+#line 1079 "c-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-3].ttype, build_tree_list (NULL_TREE, yyvsp[-1].ttype)); ;
     break;}
 case 180:
-#line 1070 "c-parse.y"
+#line 1081 "c-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-5].ttype, tree_cons (NULL_TREE, yyvsp[-3].ttype, yyvsp[-1].ttype)); ;
     break;}
 case 181:
-#line 1072 "c-parse.y"
+#line 1083 "c-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 187:
-#line 1090 "c-parse.y"
+#line 1101 "c-parse.y"
 { really_start_incremental_init (NULL_TREE);
 		  /* Note that the call to clear_momentary
 		     is in process_init_element.  */
 		  push_momentary (); ;
     break;}
 case 188:
-#line 1095 "c-parse.y"
+#line 1106 "c-parse.y"
 { yyval.ttype = pop_init_level (0);
 		  if (yyval.ttype == error_mark_node
 		      && ! (yychar == STRING || yychar == CONSTANT))
@@ -2637,44 +2692,44 @@ case 188:
 		    pop_momentary_nofree (); ;
     break;}
 case 189:
-#line 1103 "c-parse.y"
+#line 1114 "c-parse.y"
 { yyval.ttype = error_mark_node; ;
     break;}
 case 190:
-#line 1109 "c-parse.y"
+#line 1120 "c-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids empty initializer braces"); ;
     break;}
 case 196:
-#line 1125 "c-parse.y"
+#line 1136 "c-parse.y"
 { set_init_label (yyvsp[-1].ttype); ;
     break;}
 case 199:
-#line 1132 "c-parse.y"
+#line 1143 "c-parse.y"
 { push_init_level (0); ;
     break;}
 case 200:
-#line 1134 "c-parse.y"
+#line 1145 "c-parse.y"
 { process_init_element (pop_init_level (0)); ;
     break;}
 case 201:
-#line 1136 "c-parse.y"
+#line 1147 "c-parse.y"
 { process_init_element (yyvsp[0].ttype); ;
     break;}
 case 205:
-#line 1147 "c-parse.y"
+#line 1158 "c-parse.y"
 { set_init_label (yyvsp[0].ttype); ;
     break;}
 case 206:
-#line 1152 "c-parse.y"
+#line 1163 "c-parse.y"
 { set_init_index (yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 207:
-#line 1154 "c-parse.y"
+#line 1165 "c-parse.y"
 { set_init_index (yyvsp[-1].ttype, NULL_TREE); ;
     break;}
 case 208:
-#line 1159 "c-parse.y"
+#line 1170 "c-parse.y"
 { push_c_function_context ();
 		  if (! start_function (current_declspecs, yyvsp[0].ttype,
 					prefix_attributes, NULL_TREE, 1))
@@ -2685,16 +2740,16 @@ case 208:
 		  reinit_parse_for_function (); ;
     break;}
 case 209:
-#line 1168 "c-parse.y"
+#line 1179 "c-parse.y"
 { store_parm_decls (); ;
     break;}
 case 210:
-#line 1176 "c-parse.y"
+#line 1187 "c-parse.y"
 { finish_function (1);
 		  pop_c_function_context (); ;
     break;}
 case 211:
-#line 1182 "c-parse.y"
+#line 1193 "c-parse.y"
 { push_c_function_context ();
 		  if (! start_function (current_declspecs, yyvsp[0].ttype,
 					prefix_attributes, NULL_TREE, 1))
@@ -2705,211 +2760,211 @@ case 211:
 		  reinit_parse_for_function (); ;
     break;}
 case 212:
-#line 1191 "c-parse.y"
+#line 1202 "c-parse.y"
 { store_parm_decls (); ;
     break;}
 case 213:
-#line 1199 "c-parse.y"
+#line 1210 "c-parse.y"
 { finish_function (1);
 		  pop_c_function_context (); ;
     break;}
 case 216:
-#line 1215 "c-parse.y"
+#line 1226 "c-parse.y"
 { yyval.ttype = yyvsp[-1].ttype; ;
     break;}
 case 217:
-#line 1217 "c-parse.y"
+#line 1228 "c-parse.y"
 { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 218:
-#line 1222 "c-parse.y"
+#line 1233 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 219:
-#line 1224 "c-parse.y"
+#line 1235 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-2].ttype, NULL_TREE); ;
     break;}
 case 220:
-#line 1226 "c-parse.y"
+#line 1237 "c-parse.y"
 { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 221:
-#line 1233 "c-parse.y"
+#line 1244 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 223:
-#line 1244 "c-parse.y"
+#line 1255 "c-parse.y"
 { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 224:
-#line 1249 "c-parse.y"
+#line 1260 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-3].ttype, NULL_TREE);
 		  if (! flag_isoc9x)
 		    error ("`[*]' in parameter declaration only allowed in ISO C 9x");
 		;
     break;}
 case 225:
-#line 1254 "c-parse.y"
+#line 1265 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 226:
-#line 1256 "c-parse.y"
+#line 1267 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-2].ttype, NULL_TREE); ;
     break;}
 case 227:
-#line 1258 "c-parse.y"
+#line 1269 "c-parse.y"
 { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 228:
-#line 1265 "c-parse.y"
+#line 1276 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 230:
-#line 1274 "c-parse.y"
+#line 1285 "c-parse.y"
 { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 231:
-#line 1279 "c-parse.y"
+#line 1290 "c-parse.y"
 { yyval.ttype = yyvsp[-1].ttype; ;
     break;}
 case 232:
-#line 1281 "c-parse.y"
+#line 1292 "c-parse.y"
 { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 233:
-#line 1283 "c-parse.y"
+#line 1294 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-3].ttype, NULL_TREE);
 		  if (! flag_isoc9x)
 		    error ("`[*]' in parameter declaration only allowed in ISO C 9x");
 		;
     break;}
 case 234:
-#line 1288 "c-parse.y"
+#line 1299 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 235:
-#line 1290 "c-parse.y"
+#line 1301 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-2].ttype, NULL_TREE); ;
     break;}
 case 236:
-#line 1297 "c-parse.y"
+#line 1308 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 238:
-#line 1303 "c-parse.y"
+#line 1314 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 239:
-#line 1305 "c-parse.y"
+#line 1316 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 240:
-#line 1310 "c-parse.y"
+#line 1321 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 241:
-#line 1312 "c-parse.y"
+#line 1323 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 242:
-#line 1317 "c-parse.y"
+#line 1328 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 243:
-#line 1319 "c-parse.y"
+#line 1330 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 244:
-#line 1324 "c-parse.y"
+#line 1335 "c-parse.y"
 { yyval.ttype = start_struct (RECORD_TYPE, yyvsp[-1].ttype);
 		  /* Start scope of tag before parsing components.  */
 		;
     break;}
 case 245:
-#line 1328 "c-parse.y"
+#line 1339 "c-parse.y"
 { yyval.ttype = finish_struct (yyvsp[-3].ttype, yyvsp[-2].ttype, chainon (yyvsp[-6].ttype, yyvsp[0].ttype)); ;
     break;}
 case 246:
-#line 1330 "c-parse.y"
+#line 1341 "c-parse.y"
 { yyval.ttype = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),
 				      yyvsp[-2].ttype, chainon (yyvsp[-4].ttype, yyvsp[0].ttype));
 		;
     break;}
 case 247:
-#line 1334 "c-parse.y"
+#line 1345 "c-parse.y"
 { yyval.ttype = xref_tag (RECORD_TYPE, yyvsp[0].ttype); ;
     break;}
 case 248:
-#line 1336 "c-parse.y"
+#line 1347 "c-parse.y"
 { yyval.ttype = start_struct (UNION_TYPE, yyvsp[-1].ttype); ;
     break;}
 case 249:
-#line 1338 "c-parse.y"
+#line 1349 "c-parse.y"
 { yyval.ttype = finish_struct (yyvsp[-3].ttype, yyvsp[-2].ttype, chainon (yyvsp[-6].ttype, yyvsp[0].ttype)); ;
     break;}
 case 250:
-#line 1340 "c-parse.y"
+#line 1351 "c-parse.y"
 { yyval.ttype = finish_struct (start_struct (UNION_TYPE, NULL_TREE),
 				      yyvsp[-2].ttype, chainon (yyvsp[-4].ttype, yyvsp[0].ttype));
 		;
     break;}
 case 251:
-#line 1344 "c-parse.y"
+#line 1355 "c-parse.y"
 { yyval.ttype = xref_tag (UNION_TYPE, yyvsp[0].ttype); ;
     break;}
 case 252:
-#line 1346 "c-parse.y"
+#line 1357 "c-parse.y"
 { yyvsp[0].itype = suspend_momentary ();
 		  yyval.ttype = start_enum (yyvsp[-1].ttype); ;
     break;}
 case 253:
-#line 1349 "c-parse.y"
+#line 1360 "c-parse.y"
 { yyval.ttype= finish_enum (yyvsp[-4].ttype, nreverse (yyvsp[-3].ttype), chainon (yyvsp[-7].ttype, yyvsp[0].ttype));
 		  resume_momentary (yyvsp[-5].itype); ;
     break;}
 case 254:
-#line 1352 "c-parse.y"
+#line 1363 "c-parse.y"
 { yyvsp[0].itype = suspend_momentary ();
 		  yyval.ttype = start_enum (NULL_TREE); ;
     break;}
 case 255:
-#line 1355 "c-parse.y"
+#line 1366 "c-parse.y"
 { yyval.ttype= finish_enum (yyvsp[-4].ttype, nreverse (yyvsp[-3].ttype), chainon (yyvsp[-6].ttype, yyvsp[0].ttype));
 		  resume_momentary (yyvsp[-5].itype); ;
     break;}
 case 256:
-#line 1358 "c-parse.y"
+#line 1369 "c-parse.y"
 { yyval.ttype = xref_tag (ENUMERAL_TYPE, yyvsp[0].ttype); ;
     break;}
 case 260:
-#line 1369 "c-parse.y"
+#line 1380 "c-parse.y"
 { if (pedantic && ! flag_isoc9x)
 		    pedwarn ("comma at end of enumerator list"); ;
     break;}
 case 261:
-#line 1375 "c-parse.y"
+#line 1386 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 262:
-#line 1377 "c-parse.y"
+#line 1388 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype);
 		  pedwarn ("no semicolon at end of struct or union"); ;
     break;}
 case 263:
-#line 1382 "c-parse.y"
+#line 1393 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 264:
-#line 1384 "c-parse.y"
+#line 1395 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[-1].ttype); ;
     break;}
 case 265:
-#line 1386 "c-parse.y"
+#line 1397 "c-parse.y"
 { if (pedantic)
 		    pedwarn ("extra semicolon in struct or union specified"); ;
     break;}
 case 266:
-#line 1401 "c-parse.y"
+#line 1412 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -2917,14 +2972,14 @@ case 266:
 		  resume_momentary (yyvsp[-1].itype); ;
     break;}
 case 267:
-#line 1407 "c-parse.y"
+#line 1418 "c-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids member declarations with no members");
 		  shadow_tag(yyvsp[0].ttype);
 		  yyval.ttype = NULL_TREE; ;
     break;}
 case 268:
-#line 1412 "c-parse.y"
+#line 1423 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -2932,144 +2987,144 @@ case 268:
 		  resume_momentary (yyvsp[-1].itype); ;
     break;}
 case 269:
-#line 1418 "c-parse.y"
+#line 1429 "c-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids member declarations with no members");
 		  shadow_tag(yyvsp[0].ttype);
 		  yyval.ttype = NULL_TREE; ;
     break;}
 case 270:
-#line 1423 "c-parse.y"
+#line 1434 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 271:
-#line 1425 "c-parse.y"
+#line 1436 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
-		  pedantic = yyvsp[-1].itype; ;
+		  RESTORE_WARN_FLAGS (yyvsp[-1].ttype); ;
     break;}
 case 273:
-#line 1432 "c-parse.y"
+#line 1443 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 274:
-#line 1437 "c-parse.y"
+#line 1448 "c-parse.y"
 { yyval.ttype = grokfield (yyvsp[-3].filename, yyvsp[-2].lineno, yyvsp[-1].ttype, current_declspecs, NULL_TREE);
 		  decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;
     break;}
 case 275:
-#line 1441 "c-parse.y"
+#line 1452 "c-parse.y"
 { yyval.ttype = grokfield (yyvsp[-5].filename, yyvsp[-4].lineno, yyvsp[-3].ttype, current_declspecs, yyvsp[-1].ttype);
 		  decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;
     break;}
 case 276:
-#line 1444 "c-parse.y"
+#line 1455 "c-parse.y"
 { yyval.ttype = grokfield (yyvsp[-4].filename, yyvsp[-3].lineno, NULL_TREE, current_declspecs, yyvsp[-1].ttype);
 		  decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;
     break;}
 case 278:
-#line 1456 "c-parse.y"
+#line 1467 "c-parse.y"
 { if (yyvsp[-2].ttype == error_mark_node)
 		    yyval.ttype = yyvsp[-2].ttype;
 		  else
 		    yyval.ttype = chainon (yyvsp[0].ttype, yyvsp[-2].ttype); ;
     break;}
 case 279:
-#line 1461 "c-parse.y"
+#line 1472 "c-parse.y"
 { yyval.ttype = error_mark_node; ;
     break;}
 case 280:
-#line 1467 "c-parse.y"
+#line 1478 "c-parse.y"
 { yyval.ttype = build_enumerator (yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 281:
-#line 1469 "c-parse.y"
+#line 1480 "c-parse.y"
 { yyval.ttype = build_enumerator (yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 282:
-#line 1474 "c-parse.y"
+#line 1485 "c-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 283:
-#line 1476 "c-parse.y"
+#line 1487 "c-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 284:
-#line 1481 "c-parse.y"
+#line 1492 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 286:
-#line 1487 "c-parse.y"
+#line 1498 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 287:
-#line 1489 "c-parse.y"
+#line 1500 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 288:
-#line 1494 "c-parse.y"
+#line 1505 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 289:
-#line 1496 "c-parse.y"
+#line 1507 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 290:
-#line 1501 "c-parse.y"
+#line 1512 "c-parse.y"
 { yyval.ttype = yyvsp[-1].ttype; ;
     break;}
 case 291:
-#line 1504 "c-parse.y"
+#line 1515 "c-parse.y"
 { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 292:
-#line 1506 "c-parse.y"
+#line 1517 "c-parse.y"
 { yyval.ttype = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 293:
-#line 1508 "c-parse.y"
+#line 1519 "c-parse.y"
 { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 294:
-#line 1510 "c-parse.y"
+#line 1521 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 295:
-#line 1512 "c-parse.y"
+#line 1523 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-2].ttype, NULL_TREE); ;
     break;}
 case 296:
-#line 1514 "c-parse.y"
+#line 1525 "c-parse.y"
 { yyval.ttype = build_nt (CALL_EXPR, NULL_TREE, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 297:
-#line 1516 "c-parse.y"
+#line 1527 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, NULL_TREE, yyvsp[-1].ttype); ;
     break;}
 case 298:
-#line 1518 "c-parse.y"
+#line 1529 "c-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); ;
     break;}
 case 299:
-#line 1522 "c-parse.y"
+#line 1533 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 300:
-#line 1531 "c-parse.y"
+#line 1542 "c-parse.y"
 {
 		  if (pedantic && yyvsp[0].ends_in_label)
 		    pedwarn ("ANSI C forbids label at end of compound statement");
 		;
     break;}
 case 302:
-#line 1540 "c-parse.y"
+#line 1551 "c-parse.y"
 { yyval.ends_in_label = yyvsp[0].ends_in_label; ;
     break;}
 case 303:
-#line 1542 "c-parse.y"
+#line 1553 "c-parse.y"
 { yyval.ends_in_label = 0; ;
     break;}
 case 307:
-#line 1554 "c-parse.y"
+#line 1565 "c-parse.y"
 { emit_line_note (input_filename, lineno);
 		  pushlevel (0);
 		  clear_last_expr ();
@@ -3078,12 +3133,12 @@ case 307:
 		;
     break;}
 case 309:
-#line 1567 "c-parse.y"
+#line 1578 "c-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids label declarations"); ;
     break;}
 case 312:
-#line 1578 "c-parse.y"
+#line 1589 "c-parse.y"
 { tree link;
 		  for (link = yyvsp[-1].ttype; link; link = TREE_CHAIN (link))
 		    {
@@ -3094,19 +3149,19 @@ case 312:
 		;
     break;}
 case 313:
-#line 1592 "c-parse.y"
+#line 1603 "c-parse.y"
 {;
     break;}
 case 315:
-#line 1596 "c-parse.y"
+#line 1607 "c-parse.y"
 { compstmt_count++; ;
     break;}
 case 316:
-#line 1599 "c-parse.y"
+#line 1610 "c-parse.y"
 { yyval.ttype = convert (void_type_node, integer_zero_node); ;
     break;}
 case 317:
-#line 1601 "c-parse.y"
+#line 1612 "c-parse.y"
 { emit_line_note (input_filename, lineno);
 		  expand_end_bindings (getdecls (), 1, 0);
 		  yyval.ttype = poplevel (1, 1, 0);
@@ -3116,7 +3171,7 @@ case 317:
 		    pop_momentary (); ;
     break;}
 case 318:
-#line 1609 "c-parse.y"
+#line 1620 "c-parse.y"
 { emit_line_note (input_filename, lineno);
 		  expand_end_bindings (getdecls (), kept_level_p (), 0);
 		  yyval.ttype = poplevel (kept_level_p (), 0, 0);
@@ -3126,7 +3181,7 @@ case 318:
 		    pop_momentary (); ;
     break;}
 case 319:
-#line 1617 "c-parse.y"
+#line 1628 "c-parse.y"
 { emit_line_note (input_filename, lineno);
 		  expand_end_bindings (getdecls (), kept_level_p (), 0);
 		  yyval.ttype = poplevel (kept_level_p (), 0, 0);
@@ -3136,7 +3191,7 @@ case 319:
 		    pop_momentary (); ;
     break;}
 case 322:
-#line 1637 "c-parse.y"
+#line 1648 "c-parse.y"
 { emit_line_note (yyvsp[-5].filename, yyvsp[-4].lineno);
 		  c_expand_start_cond (truthvalue_conversion (yyvsp[-1].ttype), 0, 
 				       compstmt_count);
@@ -3146,7 +3201,7 @@ case 322:
 		  position_after_white_space (); ;
     break;}
 case 323:
-#line 1651 "c-parse.y"
+#line 1662 "c-parse.y"
 { stmt_count++;
 		  compstmt_count++;
 		  emit_line_note (yyvsp[-2].filename, yyvsp[-1].lineno);
@@ -3156,43 +3211,43 @@ case 323:
 		  position_after_white_space (); ;
     break;}
 case 324:
-#line 1659 "c-parse.y"
+#line 1670 "c-parse.y"
 { expand_loop_continue_here (); ;
     break;}
 case 325:
-#line 1663 "c-parse.y"
+#line 1674 "c-parse.y"
 { yyval.filename = input_filename; ;
     break;}
 case 326:
-#line 1667 "c-parse.y"
+#line 1678 "c-parse.y"
 { yyval.lineno = lineno; ;
     break;}
 case 327:
-#line 1672 "c-parse.y"
+#line 1683 "c-parse.y"
 { ;
     break;}
 case 328:
-#line 1677 "c-parse.y"
+#line 1688 "c-parse.y"
 { ;
     break;}
 case 329:
-#line 1682 "c-parse.y"
+#line 1693 "c-parse.y"
 { yyval.ends_in_label = yyvsp[0].ends_in_label; ;
     break;}
 case 330:
-#line 1687 "c-parse.y"
+#line 1698 "c-parse.y"
 { yyval.ends_in_label = 0; ;
     break;}
 case 331:
-#line 1689 "c-parse.y"
+#line 1700 "c-parse.y"
 { yyval.ends_in_label = 1; ;
     break;}
 case 332:
-#line 1695 "c-parse.y"
+#line 1706 "c-parse.y"
 { stmt_count++; ;
     break;}
 case 334:
-#line 1698 "c-parse.y"
+#line 1709 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);
 /* It appears that this should not be done--that a non-lvalue array
@@ -3211,19 +3266,19 @@ case 334:
 		  clear_momentary (); ;
     break;}
 case 335:
-#line 1715 "c-parse.y"
+#line 1726 "c-parse.y"
 { c_expand_start_else ();
 		  yyvsp[-1].itype = stmt_count;
 		  position_after_white_space (); ;
     break;}
 case 336:
-#line 1719 "c-parse.y"
+#line 1730 "c-parse.y"
 { c_expand_end_cond ();
 		  if (extra_warnings && stmt_count == yyvsp[-3].itype)
 		    warning ("empty body in an else-statement"); ;
     break;}
 case 337:
-#line 1723 "c-parse.y"
+#line 1734 "c-parse.y"
 { c_expand_end_cond ();
 		  /* This warning is here instead of in simple_if, because we
 		     do not want a warning if an empty if is followed by an
@@ -3234,11 +3289,11 @@ case 337:
 						"empty body in an if-statement"); ;
     break;}
 case 338:
-#line 1735 "c-parse.y"
+#line 1746 "c-parse.y"
 { c_expand_end_cond (); ;
     break;}
 case 339:
-#line 1737 "c-parse.y"
+#line 1748 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-2].filename, yyvsp[-1].lineno);
 		  /* The emit_nop used to come before emit_line_note,
@@ -3250,7 +3305,7 @@ case 339:
 		  emit_nop (); ;
     break;}
 case 340:
-#line 1747 "c-parse.y"
+#line 1758 "c-parse.y"
 { /* Don't start the loop till we have succeeded
 		     in parsing the end test.  This is to make sure
 		     that we end every loop we start.  */
@@ -3261,11 +3316,11 @@ case 340:
 		  position_after_white_space (); ;
     break;}
 case 341:
-#line 1756 "c-parse.y"
+#line 1767 "c-parse.y"
 { expand_end_loop (); ;
     break;}
 case 342:
-#line 1759 "c-parse.y"
+#line 1770 "c-parse.y"
 { emit_line_note (input_filename, lineno);
 		  expand_exit_loop_if_false (NULL_PTR,
 					     truthvalue_conversion (yyvsp[-2].ttype));
@@ -3273,12 +3328,12 @@ case 342:
 		  clear_momentary (); ;
     break;}
 case 343:
-#line 1766 "c-parse.y"
+#line 1777 "c-parse.y"
 { expand_end_loop ();
 		  clear_momentary (); ;
     break;}
 case 344:
-#line 1770 "c-parse.y"
+#line 1781 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-5].filename, yyvsp[-4].lineno);
 		  /* See comment in `while' alternative, above.  */
@@ -3291,12 +3346,12 @@ case 344:
 		;
     break;}
 case 345:
-#line 1782 "c-parse.y"
+#line 1793 "c-parse.y"
 { yyvsp[0].lineno = lineno;
 		  yyval.filename = input_filename; ;
     break;}
 case 346:
-#line 1785 "c-parse.y"
+#line 1796 "c-parse.y"
 { 
 		  /* Start the loop.  Doing this after parsing
 		     all the expressions ensures we will end the loop.  */
@@ -3314,7 +3369,7 @@ case 346:
 		  position_after_white_space (); ;
     break;}
 case 347:
-#line 1801 "c-parse.y"
+#line 1812 "c-parse.y"
 { /* Emit the increment expression, with a line number.  */
 		  emit_line_note (yyvsp[-4].filename, yyvsp[-5].lineno);
 		  expand_loop_continue_here ();
@@ -3327,7 +3382,7 @@ case 347:
 		  expand_end_loop (); ;
     break;}
 case 348:
-#line 1812 "c-parse.y"
+#line 1823 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-5].filename, yyvsp[-4].lineno);
 		  c_expand_start_case (yyvsp[-1].ttype);
@@ -3337,7 +3392,7 @@ case 348:
 		  position_after_white_space (); ;
     break;}
 case 349:
-#line 1820 "c-parse.y"
+#line 1831 "c-parse.y"
 { expand_end_case (yyvsp[-3].ttype);
 		  if (yychar == CONSTANT || yychar == STRING)
 		    pop_momentary_nofree ();
@@ -3345,33 +3400,33 @@ case 349:
 		    pop_momentary (); ;
     break;}
 case 350:
-#line 1826 "c-parse.y"
+#line 1837 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);
 		  if ( ! expand_exit_something ())
 		    error ("break statement not within loop or switch"); ;
     break;}
 case 351:
-#line 1831 "c-parse.y"
+#line 1842 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);
 		  if (! expand_continue_loop (NULL_PTR))
 		    error ("continue statement not within a loop"); ;
     break;}
 case 352:
-#line 1836 "c-parse.y"
+#line 1847 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);
 		  c_expand_return (NULL_TREE); ;
     break;}
 case 353:
-#line 1840 "c-parse.y"
+#line 1851 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-4].filename, yyvsp[-3].lineno);
 		  c_expand_return (yyvsp[-1].ttype); ;
     break;}
 case 354:
-#line 1844 "c-parse.y"
+#line 1855 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-7].filename, yyvsp[-6].lineno);
 		  STRIP_NOPS (yyvsp[-2].ttype);
@@ -3383,7 +3438,7 @@ case 354:
 		    error ("argument of `asm' is not a constant string"); ;
     break;}
 case 355:
-#line 1855 "c-parse.y"
+#line 1866 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-9].filename, yyvsp[-8].lineno);
 		  c_expand_asm_operands (yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE, NULL_TREE,
@@ -3391,7 +3446,7 @@ case 355:
 					 input_filename, lineno); ;
     break;}
 case 356:
-#line 1862 "c-parse.y"
+#line 1873 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-11].filename, yyvsp[-10].lineno);
 		  c_expand_asm_operands (yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE,
@@ -3399,7 +3454,7 @@ case 356:
 					 input_filename, lineno); ;
     break;}
 case 357:
-#line 1870 "c-parse.y"
+#line 1881 "c-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-13].filename, yyvsp[-12].lineno);
 		  c_expand_asm_operands (yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype,
@@ -3407,7 +3462,7 @@ case 357:
 					 input_filename, lineno); ;
     break;}
 case 358:
-#line 1876 "c-parse.y"
+#line 1887 "c-parse.y"
 { tree decl;
 		  stmt_count++;
 		  emit_line_note (yyvsp[-4].filename, yyvsp[-3].lineno);
@@ -3420,7 +3475,7 @@ case 358:
 		;
     break;}
 case 359:
-#line 1887 "c-parse.y"
+#line 1898 "c-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids `goto *expr;'");
 		  stmt_count++;
@@ -3428,7 +3483,7 @@ case 359:
 		  expand_computed_goto (convert (ptr_type_node, yyvsp[-1].ttype)); ;
     break;}
 case 362:
-#line 1902 "c-parse.y"
+#line 1913 "c-parse.y"
 {
 	    /* The value returned by this action is  */
 	    /*      1 if everything is OK */ 
@@ -3451,14 +3506,14 @@ case 362:
 	  ;
     break;}
 case 363:
-#line 1923 "c-parse.y"
+#line 1934 "c-parse.y"
 {
 	    if (yyvsp[-1].itype)
 	      iterator_for_loop_end (yyvsp[-3].ttype);
 	  ;
     break;}
 case 364:
-#line 1958 "c-parse.y"
+#line 1969 "c-parse.y"
 { register tree value = check_case_value (yyvsp[-1].ttype);
 		  register tree label
 		    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);
@@ -3491,7 +3546,7 @@ case 364:
 		  position_after_white_space (); ;
     break;}
 case 365:
-#line 1989 "c-parse.y"
+#line 2000 "c-parse.y"
 { register tree value1 = check_case_value (yyvsp[-3].ttype);
 		  register tree value2 = check_case_value (yyvsp[-1].ttype);
 		  register tree label
@@ -3524,7 +3579,7 @@ case 365:
 		  position_after_white_space (); ;
     break;}
 case 366:
-#line 2020 "c-parse.y"
+#line 2031 "c-parse.y"
 {
 		  tree duplicate;
 		  register tree label
@@ -3541,7 +3596,7 @@ case 366:
 		  position_after_white_space (); ;
     break;}
 case 367:
-#line 2035 "c-parse.y"
+#line 2046 "c-parse.y"
 { tree label = define_label (input_filename, lineno, yyvsp[-2].ttype);
 		  stmt_count++;
 		  emit_nop ();
@@ -3553,52 +3608,52 @@ case 367:
 		  position_after_white_space (); ;
     break;}
 case 368:
-#line 2050 "c-parse.y"
+#line 2061 "c-parse.y"
 { emit_line_note (input_filename, lineno);
 		  yyval.ttype = NULL_TREE; ;
     break;}
 case 369:
-#line 2053 "c-parse.y"
+#line 2064 "c-parse.y"
 { emit_line_note (input_filename, lineno); ;
     break;}
 case 370:
-#line 2058 "c-parse.y"
+#line 2069 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 372:
-#line 2065 "c-parse.y"
+#line 2076 "c-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 375:
-#line 2072 "c-parse.y"
+#line 2083 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 376:
-#line 2077 "c-parse.y"
+#line 2088 "c-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 377:
-#line 2082 "c-parse.y"
+#line 2093 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, combine_strings (yyvsp[0].ttype), NULL_TREE); ;
     break;}
 case 378:
-#line 2084 "c-parse.y"
+#line 2095 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, combine_strings (yyvsp[0].ttype), yyvsp[-2].ttype); ;
     break;}
 case 379:
-#line 2090 "c-parse.y"
+#line 2101 "c-parse.y"
 { pushlevel (0);
 		  clear_parm_order ();
 		  declare_parm_level (0); ;
     break;}
 case 380:
-#line 2094 "c-parse.y"
+#line 2105 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
 		  parmlist_tags_warning ();
 		  poplevel (0, 0, 0); ;
     break;}
 case 382:
-#line 2102 "c-parse.y"
+#line 2113 "c-parse.y"
 { tree parm;
 		  if (pedantic)
 		    pedwarn ("ANSI C forbids forward parameter declarations");
@@ -3608,19 +3663,19 @@ case 382:
 		  clear_parm_order (); ;
     break;}
 case 383:
-#line 2110 "c-parse.y"
+#line 2121 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 384:
-#line 2112 "c-parse.y"
+#line 2123 "c-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE); ;
     break;}
 case 385:
-#line 2118 "c-parse.y"
+#line 2129 "c-parse.y"
 { yyval.ttype = get_parm_info (0); ;
     break;}
 case 386:
-#line 2120 "c-parse.y"
+#line 2131 "c-parse.y"
 { yyval.ttype = get_parm_info (0);
 		  /* Gcc used to allow this as an extension.  However, it does
 		     not work for all targets, and thus has been disabled.
@@ -3632,23 +3687,23 @@ case 386:
 		;
     break;}
 case 387:
-#line 2130 "c-parse.y"
+#line 2141 "c-parse.y"
 { yyval.ttype = get_parm_info (1); ;
     break;}
 case 388:
-#line 2132 "c-parse.y"
+#line 2143 "c-parse.y"
 { yyval.ttype = get_parm_info (0); ;
     break;}
 case 389:
-#line 2137 "c-parse.y"
+#line 2148 "c-parse.y"
 { push_parm_decl (yyvsp[0].ttype); ;
     break;}
 case 390:
-#line 2139 "c-parse.y"
+#line 2150 "c-parse.y"
 { push_parm_decl (yyvsp[0].ttype); ;
     break;}
 case 391:
-#line 2146 "c-parse.y"
+#line 2157 "c-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
@@ -3659,7 +3714,7 @@ case 391:
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 392:
-#line 2155 "c-parse.y"
+#line 2166 "c-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
@@ -3670,7 +3725,7 @@ case 392:
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 393:
-#line 2164 "c-parse.y"
+#line 2175 "c-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
@@ -3681,7 +3736,7 @@ case 393:
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 394:
-#line 2173 "c-parse.y"
+#line 2184 "c-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
@@ -3692,7 +3747,7 @@ case 394:
 		  resume_momentary (yyvsp[-2].itype);  ;
     break;}
 case 395:
-#line 2183 "c-parse.y"
+#line 2194 "c-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
@@ -3703,19 +3758,19 @@ case 395:
 		  resume_momentary (yyvsp[-2].itype);  ;
     break;}
 case 396:
-#line 2197 "c-parse.y"
+#line 2208 "c-parse.y"
 { pushlevel (0);
 		  clear_parm_order ();
 		  declare_parm_level (1); ;
     break;}
 case 397:
-#line 2201 "c-parse.y"
+#line 2212 "c-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
 		  parmlist_tags_warning ();
 		  poplevel (0, 0, 0); ;
     break;}
 case 399:
-#line 2209 "c-parse.y"
+#line 2220 "c-parse.y"
 { tree t;
 		  for (t = yyvsp[-1].ttype; t; t = TREE_CHAIN (t))
 		    if (TREE_VALUE (t) == NULL_TREE)
@@ -3723,29 +3778,30 @@ case 399:
 		  yyval.ttype = tree_cons (NULL_TREE, NULL_TREE, yyvsp[-1].ttype); ;
     break;}
 case 400:
-#line 2219 "c-parse.y"
+#line 2230 "c-parse.y"
 { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;
     break;}
 case 401:
-#line 2221 "c-parse.y"
+#line 2232 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;
     break;}
 case 402:
-#line 2227 "c-parse.y"
+#line 2238 "c-parse.y"
 { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;
     break;}
 case 403:
-#line 2229 "c-parse.y"
+#line 2240 "c-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;
     break;}
 case 404:
-#line 2234 "c-parse.y"
-{ yyval.itype = pedantic;
-		  pedantic = 0; ;
+#line 2245 "c-parse.y"
+{ yyval.ttype = SAVE_WARN_FLAGS();
+		  pedantic = 0;
+		  warn_pointer_arith = 0; ;
     break;}
 }
    /* the action file gets copied in in place of this dollarsign */
-#line 498 "/usr/lib/bison.simple"
+#line 543 "/usr/lib/bison.simple"
 
   yyvsp -= yylen;
   yyssp -= yylen;
@@ -3940,6 +3996,30 @@ yyerrhandle:
 
   yystate = yyn;
   goto yynewstate;
+
+ yyacceptlab:
+  /* YYACCEPT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 0;
+
+ yyabortlab:
+  /* YYABORT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 1;
 }
-#line 2238 "c-parse.y"
+#line 2250 "c-parse.y"
 
diff --git a/gcc/c-parse.h b/gcc/c-parse.h
index 21b3d0caf6b..4b38e1dfcfe 100644
--- a/gcc/c-parse.h
+++ b/gcc/c-parse.h
@@ -1,64 +1,64 @@
 typedef union {long itype; tree ttype; enum tree_code code;
 	char *filename; int lineno; int ends_in_label; } YYSTYPE;
-#define	IDENTIFIER	258
-#define	TYPENAME	259
-#define	SCSPEC	260
-#define	TYPESPEC	261
-#define	TYPE_QUAL	262
-#define	CONSTANT	263
-#define	STRING	264
-#define	ELLIPSIS	265
-#define	SIZEOF	266
-#define	ENUM	267
-#define	STRUCT	268
-#define	UNION	269
-#define	IF	270
-#define	ELSE	271
-#define	WHILE	272
-#define	DO	273
-#define	FOR	274
-#define	SWITCH	275
-#define	CASE	276
-#define	DEFAULT	277
-#define	BREAK	278
-#define	CONTINUE	279
-#define	RETURN	280
-#define	GOTO	281
-#define	ASM_KEYWORD	282
-#define	TYPEOF	283
-#define	ALIGNOF	284
-#define	ATTRIBUTE	285
-#define	EXTENSION	286
-#define	LABEL	287
-#define	REALPART	288
-#define	IMAGPART	289
-#define	ASSIGN	290
-#define	OROR	291
-#define	ANDAND	292
-#define	EQCOMPARE	293
-#define	ARITHCOMPARE	294
-#define	LSHIFT	295
-#define	RSHIFT	296
-#define	UNARY	297
-#define	PLUSPLUS	298
-#define	MINUSMINUS	299
-#define	HYPERUNARY	300
-#define	POINTSAT	301
-#define	INTERFACE	302
-#define	IMPLEMENTATION	303
-#define	END	304
-#define	SELECTOR	305
-#define	DEFS	306
-#define	ENCODE	307
-#define	CLASSNAME	308
-#define	PUBLIC	309
-#define	PRIVATE	310
-#define	PROTECTED	311
-#define	PROTOCOL	312
-#define	OBJECTNAME	313
-#define	CLASS	314
-#define	ALIAS	315
-#define	OBJC_STRING	316
+#define	IDENTIFIER	257
+#define	TYPENAME	258
+#define	SCSPEC	259
+#define	TYPESPEC	260
+#define	TYPE_QUAL	261
+#define	CONSTANT	262
+#define	STRING	263
+#define	ELLIPSIS	264
+#define	SIZEOF	265
+#define	ENUM	266
+#define	STRUCT	267
+#define	UNION	268
+#define	IF	269
+#define	ELSE	270
+#define	WHILE	271
+#define	DO	272
+#define	FOR	273
+#define	SWITCH	274
+#define	CASE	275
+#define	DEFAULT	276
+#define	BREAK	277
+#define	CONTINUE	278
+#define	RETURN	279
+#define	GOTO	280
+#define	ASM_KEYWORD	281
+#define	TYPEOF	282
+#define	ALIGNOF	283
+#define	ATTRIBUTE	284
+#define	EXTENSION	285
+#define	LABEL	286
+#define	REALPART	287
+#define	IMAGPART	288
+#define	ASSIGN	289
+#define	OROR	290
+#define	ANDAND	291
+#define	EQCOMPARE	292
+#define	ARITHCOMPARE	293
+#define	LSHIFT	294
+#define	RSHIFT	295
+#define	UNARY	296
+#define	PLUSPLUS	297
+#define	MINUSMINUS	298
+#define	HYPERUNARY	299
+#define	POINTSAT	300
+#define	INTERFACE	301
+#define	IMPLEMENTATION	302
+#define	END	303
+#define	SELECTOR	304
+#define	DEFS	305
+#define	ENCODE	306
+#define	CLASSNAME	307
+#define	PUBLIC	308
+#define	PRIVATE	309
+#define	PROTECTED	310
+#define	PROTOCOL	311
+#define	OBJECTNAME	312
+#define	CLASS	313
+#define	ALIAS	314
+#define	OBJC_STRING	315
 
 
 extern YYSTYPE yylval;
diff --git a/gcc/c-parse.in b/gcc/c-parse.in
index 6757c4d464a..57702d51d90 100644
--- a/gcc/c-parse.in
+++ b/gcc/c-parse.in
@@ -186,7 +186,7 @@ end ifc
 %type <ttype> init maybeasm
 %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers
 %type <ttype> maybe_attribute attributes attribute attribute_list attrib
-%type <ttype> any_word
+%type <ttype> any_word extension
 
 %type <ttype> compstmt
 
@@ -247,6 +247,17 @@ static tree declspec_stack;
 /* 1 if we explained undeclared var errors.  */
 static int undeclared_variable_notice;
 
+/* For __extension__, save/restore the warning flags which are
+   controlled by __extension__.  */
+#define SAVE_WARN_FLAGS()	\
+	build_int_2 (pedantic | (warn_pointer_arith << 1), 0)
+#define RESTORE_WARN_FLAGS(tval) \
+  do {                                     \
+    int val = TREE_INT_CST_LOW (tval);     \
+    pedantic = val & 1;                    \
+    warn_pointer_arith = (val >> 1) & 1;   \
+  } while (0)
+
 ifobjc
 /* Objective-C specific information */
 
@@ -307,7 +318,7 @@ end ifobjc
 		  else
 		    error ("argument of `asm' is not a constant string"); }
 	| extension extdef
-		{ pedantic = $<itype>1; }
+		{ RESTORE_WARN_FLAGS ($1); }
 	;
 
 datadef:
@@ -448,7 +459,7 @@ unary_expr:
 	/* __extension__ turns off -pedantic for following primary.  */
 	| extension cast_expr	  %prec UNARY
 		{ $$ = $2;
-		  pedantic = $<itype>1; }
+		  RESTORE_WARN_FLAGS ($1); }
 	| unop cast_expr  %prec UNARY
 		{ $$ = build_unary_op ($1, $2, 0);
 		  overflow_warning ($$); }
@@ -1015,7 +1026,7 @@ decl:
 	| declmods ';'
 		{ pedwarn ("empty declaration"); }
 	| extension decl
-		{ pedantic = $<itype>1; }
+		{ RESTORE_WARN_FLAGS ($1); }
 	;
 
 /* Declspecs which contain at least one type specifier or typedef name.
@@ -1614,7 +1625,7 @@ component_decl:
 		{ $$ = NULL_TREE; }
 	| extension component_decl
 		{ $$ = $2;
-		  pedantic = $<itype>1; }
+		  RESTORE_WARN_FLAGS ($1); }
 	;
 
 components:
@@ -2426,8 +2437,9 @@ identifiers_or_typenames:
 
 extension:
 	EXTENSION
-		{ $<itype>$ = pedantic;
-		  pedantic = 0; }
+		{ $$ = SAVE_WARN_FLAGS();
+		  pedantic = 0;
+		  warn_pointer_arith = 0; }
 	;
 
 ifobjc
diff --git a/gcc/c-parse.y b/gcc/c-parse.y
index bb69dfed313..02bbd6f9203 100644
--- a/gcc/c-parse.y
+++ b/gcc/c-parse.y
@@ -174,7 +174,7 @@ char *language_string = "GNU C";
 %type <ttype> init maybeasm
 %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers
 %type <ttype> maybe_attribute attributes attribute attribute_list attrib
-%type <ttype> any_word
+%type <ttype> any_word extension
 
 %type <ttype> compstmt
 
@@ -222,6 +222,17 @@ static tree declspec_stack;
 /* 1 if we explained undeclared var errors.  */
 static int undeclared_variable_notice;
 
+/* For __extension__, save/restore the warning flags which are
+   controlled by __extension__.  */
+#define SAVE_WARN_FLAGS()	\
+	build_int_2 (pedantic | (warn_pointer_arith << 1), 0)
+#define RESTORE_WARN_FLAGS(tval) \
+  do {                                     \
+    int val = TREE_INT_CST_LOW (tval);     \
+    pedantic = val & 1;                    \
+    warn_pointer_arith = (val >> 1) & 1;   \
+  } while (0)
+
 
 /* Tell yyparse how to print a token's value, if yydebug is set.  */
 
@@ -266,7 +277,7 @@ extdef:
 		  else
 		    error ("argument of `asm' is not a constant string"); }
 	| extension extdef
-		{ pedantic = $<itype>1; }
+		{ RESTORE_WARN_FLAGS ($1); }
 	;
 
 datadef:
@@ -403,7 +414,7 @@ unary_expr:
 	/* __extension__ turns off -pedantic for following primary.  */
 	| extension cast_expr	  %prec UNARY
 		{ $$ = $2;
-		  pedantic = $<itype>1; }
+		  RESTORE_WARN_FLAGS ($1); }
 	| unop cast_expr  %prec UNARY
 		{ $$ = build_unary_op ($1, $2, 0);
 		  overflow_warning ($$); }
@@ -860,7 +871,7 @@ decl:
 	| declmods ';'
 		{ pedwarn ("empty declaration"); }
 	| extension decl
-		{ pedantic = $<itype>1; }
+		{ RESTORE_WARN_FLAGS ($1); }
 	;
 
 /* Declspecs which contain at least one type specifier or typedef name.
@@ -1423,7 +1434,7 @@ component_decl:
 		{ $$ = NULL_TREE; }
 	| extension component_decl
 		{ $$ = $2;
-		  pedantic = $<itype>1; }
+		  RESTORE_WARN_FLAGS ($1); }
 	;
 
 components:
@@ -2231,8 +2242,9 @@ identifiers_or_typenames:
 
 extension:
 	EXTENSION
-		{ $<itype>$ = pedantic;
-		  pedantic = 0; }
+		{ $$ = SAVE_WARN_FLAGS();
+		  pedantic = 0;
+		  warn_pointer_arith = 0; }
 	;
 
 %%
diff --git a/gcc/cccp.c b/gcc/cccp.c
index 023502fbde4..843866c59eb 100644
--- a/gcc/cccp.c
+++ b/gcc/cccp.c
@@ -1124,7 +1124,7 @@ print_help ()
   printf ("Usage: %s [switches] input output\n", progname);
   printf ("Switches:\n");
   printf ("  -include <file>           Include the contents of <file> before other files\n");
-  printf ("  -imacros <file>           Accept definition of marcos in <file>\n");
+  printf ("  -imacros <file>           Accept definition of macros in <file>\n");
   printf ("  -iprefix <path>           Specify <path> as a prefix for next two options\n");
   printf ("  -iwithprefix <dir>        Add <dir> to the end of the system include paths\n");
   printf ("  -iwithprefixbefore <dir>  Add <dir> to the end of the main include paths\n");
@@ -1138,7 +1138,7 @@ print_help ()
   printf ("  -traditional              Follow K&R pre-processor behaviour\n");
   printf ("  -trigraphs                Support ANSI C trigraphs\n");
   printf ("  -lang-c                   Assume that the input sources are in C\n");
-  printf ("  -lang-c89                 Assume that the input is C89; depricated\n");
+  printf ("  -lang-c89                 Assume that the input is C89; deprecated\n");
   printf ("  -lang-c++                 Assume that the input sources are in C++\n");
   printf ("  -lang-objc                Assume that the input sources are in ObjectiveC\n");
   printf ("  -lang-objc++              Assume that the input sources are in ObjectiveC++\n");
diff --git a/gcc/combine.c b/gcc/combine.c
index eb754815ce1..9445e3076cb 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -7580,8 +7580,11 @@ nonzero_bits (x, mode)
 
       if (reg_last_set_value[REGNO (x)] != 0
 	  && reg_last_set_mode[REGNO (x)] == mode
-	  && (REG_N_SETS (REGNO (x)) == 1
-	      || reg_last_set_label[REGNO (x)] == label_tick)
+	  && (reg_last_set_label[REGNO (x)] == label_tick
+	      || (REGNO (x) >= FIRST_PSEUDO_REGISTER
+		  && REG_N_SETS (REGNO (x)) == 1
+		  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, 
+					REGNO (x))))
 	  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)
 	return reg_last_set_nonzero_bits[REGNO (x)];
 
@@ -7970,8 +7973,11 @@ num_sign_bit_copies (x, mode)
 
       if (reg_last_set_value[REGNO (x)] != 0
 	  && reg_last_set_mode[REGNO (x)] == mode
-	  && (REG_N_SETS (REGNO (x)) == 1
-	      || reg_last_set_label[REGNO (x)] == label_tick)
+	  && (reg_last_set_label[REGNO (x)] == label_tick
+	      || (REGNO (x) >= FIRST_PSEUDO_REGISTER
+		  && REG_N_SETS (REGNO (x)) == 1
+		  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start,
+					REGNO (x))))
 	  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)
 	return reg_last_set_sign_bit_copies[REGNO (x)];
 
@@ -10819,9 +10825,11 @@ get_last_value_validate (loc, insn, tick, replace)
 
       for (j = regno; j < endregno; j++)
 	if (reg_last_set_invalid[j]
-	    /* If this is a pseudo-register that was only set once, it is
-	       always valid.  */
-	    || (! (regno >= FIRST_PSEUDO_REGISTER && REG_N_SETS (regno) == 1)
+	    /* If this is a pseudo-register that was only set once and not
+	       live at the beginning of the function, it is always valid.  */
+	    || (! (regno >= FIRST_PSEUDO_REGISTER 
+		   && REG_N_SETS (regno) == 1
+		   && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, regno))
 		&& reg_last_set_label[j] > tick))
 	  {
 	    if (replace)
@@ -10880,12 +10888,21 @@ get_last_value (x)
   regno = REGNO (x);
   value = reg_last_set_value[regno];
 
-  /* If we don't have a value or if it isn't for this basic block,
-     return 0.  */
+  /* If we don't have a value, or if it isn't for this basic block and
+     it's either a hard register, set more than once, or it's a live
+     at the beginning of the function, return 0.  
+
+     Because if it's not live at the beginnning of the function then the reg 
+     is always set before being used (is never used without being set).
+     And, if it's set only once, and it's always set before use, then all
+     uses must have the same last value, even if it's not from this basic
+     block.  */
 
   if (value == 0
-      || (REG_N_SETS (regno) != 1
-	  && reg_last_set_label[regno] != label_tick))
+      || (reg_last_set_label[regno] != label_tick
+	  && (regno < FIRST_PSEUDO_REGISTER
+	      || REG_N_SETS (regno) != 1
+	      || REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, regno))))
     return 0;
 
   /* If the value was set in a later insn than the ones we are processing,
diff --git a/gcc/config/alpha/crtbegin.asm b/gcc/config/alpha/crtbegin.asm
index f954f1ab0d3..6350d4722a5 100644
--- a/gcc/config/alpha/crtbegin.asm
+++ b/gcc/config/alpha/crtbegin.asm
@@ -68,6 +68,7 @@ __EH_FRAME_BEGIN__:
 	br      $29,1f
 1:	ldgp    $29,0($29)
 	jsr     $26,__do_global_dtors_aux
+	ldgp    $29,0($26)
 
 	# Ideally this call would go in crtend.o, except that we can't
 	# get hold of __EH_FRAME_BEGIN__ there.
diff --git a/gcc/config/arm/linux-elf.h b/gcc/config/arm/linux-elf.h
index a7e9e28938f..559fb7773f2 100644
--- a/gcc/config/arm/linux-elf.h
+++ b/gcc/config/arm/linux-elf.h
@@ -223,6 +223,44 @@ const_section ()							\
    go into the const section.  */
 #define SELECT_RTX_SECTION(MODE,RTX) const_section ()
 
+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)
+#define UNIQUE_SECTION_P(DECL)   (DECL_ONE_ONLY (DECL))
+
+#define UNIQUE_SECTION(DECL, RELOC)				\
+  do								\
+    {								\
+      int len;							\
+      char *name;						\
+      char *string;						\
+      char *prefix;						\
+								\
+      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));	\
+      								\
+      if (! DECL_ONE_ONLY (DECL))				\
+	{							\
+	  prefix = ".";                                         \
+	  if (TREE_CODE (DECL) == FUNCTION_DECL)		\
+	    prefix = ".text.";					\
+	  else if (DECL_READONLY_SECTION (DECL, RELOC))		\
+	    prefix = ".rodata.";				\
+	  else							\
+	    prefix = ".data.";					\
+	}							\
+      else if (TREE_CODE (DECL) == FUNCTION_DECL)		\
+	prefix = ".gnu.linkonce.t.";				\
+      else if (DECL_READONLY_SECTION (DECL, RELOC))		\
+	prefix = ".gnu.linkonce.r.";				\
+      else							\
+	prefix = ".gnu.linkonce.d.";				\
+      								\
+      len = strlen (name) + strlen (prefix);			\
+      string = alloca (len + 1);				\
+      sprintf (string, "%s%s", prefix, name);			\
+      								\
+      DECL_SECTION_NAME (DECL) = build_string (len, string);	\
+    }								\
+  while (0)
+
 /* On svr4, we *do* have support for the .init and .fini sections, and we
    can put stuff in there to be executed before and after `main'.  We let
    crtstuff.c and other files know this by defining the following symbols.
diff --git a/gcc/config/i386/freebsd-elf.h b/gcc/config/i386/freebsd-elf.h
index e97d4ca07bb..4e450204094 100644
--- a/gcc/config/i386/freebsd-elf.h
+++ b/gcc/config/i386/freebsd-elf.h
@@ -135,6 +135,9 @@ Boston, MA 02111-1307, USA.  */
  : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \
  : (-1))
 
+#undef  NO_PROFILE_COUNTERS
+#define NO_PROFILE_COUNTERS
+
 /* Tell final.c that we don't need a label passed to mcount.  */
 
 #undef FUNCTION_PROFILER
diff --git a/gcc/config/i386/linux.h b/gcc/config/i386/linux.h
index 7b368f8e5fb..90b9aa26f0e 100644
--- a/gcc/config/i386/linux.h
+++ b/gcc/config/i386/linux.h
@@ -234,3 +234,21 @@ Boston, MA 02111-1307, USA.  */
     }									\
   } while (0)
 #endif
+
+#if defined(__PIC__) && defined (USE_GNULIBC_1)
+/* This is a kludge. The i386 GNU/Linux dynamic linker needs ___brk_addr,
+   __environ and atexit (). We have to make sure they are in the .dynsym
+   section. We accomplish it by making a dummy call here. This
+   code is never reached.  */
+         
+#define CRT_END_INIT_DUMMY		\
+  do					\
+    {					\
+      extern void *___brk_addr;		\
+      extern char **__environ;		\
+					\
+      ___brk_addr = __environ;		\
+      atexit (0);			\
+    }					\
+  while (0)
+#endif
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index 81c5cd38e38..cc1282c7386 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -10083,6 +10083,21 @@ move\\t%0,%z4\\n\\
   [(set_attr "type" "move")
    (set_attr "mode" "SF")])
 
+(define_insn ""
+  [(set (match_operand:SF 0 "register_operand" "=f,f")
+	(if_then_else:SF
+	 (match_operator 4 "equality_op"
+			 [(match_operand:DI 1 "se_register_operand" "d,d")
+			  (const_int 0)])
+	 (match_operand:SF 2 "register_operand" "f,0")
+	 (match_operand:SF 3 "register_operand" "0,f")))]
+  "mips_isa >= 4 && TARGET_HARD_FLOAT"
+  "@
+    mov%B4.s\\t%0,%2,%1
+    mov%b4.s\\t%0,%3,%1"
+  [(set_attr "type" "move")
+   (set_attr "mode" "SF")])
+
 (define_insn ""
   [(set (match_operand:SF 0 "register_operand" "=f,f")
 	(if_then_else:SF
@@ -10114,6 +10129,21 @@ move\\t%0,%z4\\n\\
   [(set_attr "type" "move")
    (set_attr "mode" "DF")])
 
+(define_insn ""
+  [(set (match_operand:DF 0 "register_operand" "=f,f")
+	(if_then_else:DF
+	 (match_operator 4 "equality_op"
+			 [(match_operand:DI 1 "se_register_operand" "d,d")
+			  (const_int 0)])
+	 (match_operand:DF 2 "register_operand" "f,0")
+	 (match_operand:DF 3 "register_operand" "0,f")))]
+  "mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT"
+  "@
+    mov%B4.d\\t%0,%2,%1
+    mov%b4.d\\t%0,%3,%1"
+  [(set_attr "type" "move")
+   (set_attr "mode" "DF")])
+
 (define_insn ""
   [(set (match_operand:DF 0 "register_operand" "=f,f")
 	(if_then_else:DF
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index 23a9715f9be..1238db21271 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -3759,7 +3759,7 @@
     FAIL;
   switch (code)
     {
-    case GE: case EQ: case NE:
+    case GE: case EQ:
       op0 = rs6000_compare_op0;
       op1 = rs6000_compare_op1;
       break;
@@ -3790,11 +3790,6 @@
 	  emit_insn (gen_negdf2 (temp, temp));
 	  emit_insn (gen_fseldfsf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negdf2 (temp, temp));
-	  emit_insn (gen_fseldfsf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   else
     {
@@ -3806,11 +3801,6 @@
 	  emit_insn (gen_negsf2 (temp, temp));
 	  emit_insn (gen_fselsfsf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negsf2 (temp, temp));
-	  emit_insn (gen_fselsfsf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   DONE;
 }")
@@ -4006,7 +3996,7 @@
     FAIL;
   switch (code)
     {
-    case GE: case EQ: case NE:
+    case GE: case EQ:
       op0 = rs6000_compare_op0;
       op1 = rs6000_compare_op1;
       break;
@@ -4037,11 +4027,6 @@
 	  emit_insn (gen_negdf2 (temp, temp));
 	  emit_insn (gen_fseldfdf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negdf2 (temp, temp));
-	  emit_insn (gen_fseldfdf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   else
     {
@@ -4053,11 +4038,6 @@
 	  emit_insn (gen_negsf2 (temp, temp));
 	  emit_insn (gen_fselsfdf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negsf2 (temp, temp));
-	  emit_insn (gen_fselsfdf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   DONE;
 }")
@@ -6184,7 +6164,9 @@
      reg.  So expand it.  */
   if (GET_CODE (operands[0]) == SUBREG
       && GET_CODE (SUBREG_REG (operands[0])) == REG
-      && REGNO (SUBREG_REG (operands[0])) < FIRST_PSEUDO_REGISTER)
+      && REGNO (SUBREG_REG (operands[0])) < FIRST_PSEUDO_REGISTER
+      && (! REG_FUNCTION_VALUE_P (SUBREG_REG (operands[0]))
+	  || ! rtx_equal_function_value_matters))
     operands[0] = alter_subreg (operands[0]);
   if (GET_CODE (operands[1]) == SUBREG
       && GET_CODE (SUBREG_REG (operands[1])) == REG
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 58e882c5ac7..315a35a9381 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -2899,6 +2899,11 @@
          crashes in output_constant_pool.  */
       if (operands [1] == const0_rtx)
         operands[1] = CONST0_RTX (SFmode);
+      /* We are able to build any SF constant in integer registers
+	 with at most 2 instructions.  */
+      if (REGNO (operands[0]) < 32)
+	goto movsf_is_ok;
+
       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),
                                                    operands[1]));
     }
@@ -3093,6 +3098,9 @@
          crashes in output_constant_pool.  */
       if (operands [1] == const0_rtx)
         operands[1] = CONST0_RTX (DFmode);
+      if (REGNO (operands[0]) < 32)
+	goto movdf_is_ok;
+
       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),
                                                    operands[1]));
     }
@@ -3277,17 +3285,11 @@
 (define_split
   [(set (match_operand:DF 0 "register_operand" "")
 	(match_operand:DF 1 "memory_operand" ""))]
-  "((! TARGET_V9
-     || (! TARGET_ARCH64
-         && ((GET_CODE (operands[0]) == REG
-              && REGNO (operands[0]) < 32)
-             || (GET_CODE (operands[0]) == SUBREG
-                 && GET_CODE (SUBREG_REG (operands[0])) == REG
-                 && REGNO (SUBREG_REG (operands[0])) < 32))))
-    && (reload_completed
-        && (((REGNO (operands[0])) % 2) != 0
-             || ! mem_min_alignment (operands[1], 8))
-        && offsettable_memref_p (operands[1])))"
+  "reload_completed
+   && ! TARGET_ARCH64
+   && (((REGNO (operands[0]) % 2) != 0)
+       || ! mem_min_alignment (operands[1], 8))
+   && offsettable_memref_p (operands[1])"
   [(clobber (const_int 0))]
   "
 {
@@ -3318,17 +3320,11 @@
 (define_split
   [(set (match_operand:DF 0 "memory_operand" "")
 	(match_operand:DF 1 "register_operand" ""))]
-  "((! TARGET_V9
-     || (! TARGET_ARCH64
-         && ((GET_CODE (operands[1]) == REG
-              && REGNO (operands[1]) < 32)
-             || (GET_CODE (operands[1]) == SUBREG
-                 && GET_CODE (SUBREG_REG (operands[1])) == REG
-                 && REGNO (SUBREG_REG (operands[1])) < 32))))
-    && (reload_completed
-        && (((REGNO (operands[1])) % 2) != 0
-             || ! mem_min_alignment (operands[0], 8))
-        && offsettable_memref_p (operands[0])))"
+  "reload_completed
+   && ! TARGET_ARCH64
+   && (((REGNO (operands[1]) % 2) != 0)
+       || ! mem_min_alignment (operands[0], 8))
+   && offsettable_memref_p (operands[0])"
   [(clobber (const_int 0))]
   "
 {
@@ -5211,7 +5207,7 @@
 (define_insn "muldi3_v8plus"
   [(set (match_operand:DI 0 "register_operand" "=r,h")
 	(mult:DI (match_operand:DI 1 "arith_double_operand" "%r,0")
-		 (match_operand:DI 2 "arith_double_operand" "rHI,rHI")))
+		 (match_operand:DI 2 "arith_double_operand" "rI,rI")))
    (clobber (match_scratch:SI 3 "=&h,X"))
    (clobber (match_scratch:SI 4 "=&h,X"))]
   "TARGET_V8PLUS"
@@ -5221,6 +5217,13 @@
     output_asm_insn (\"srl\\t%L1, 0, %L1\", operands);
   if (which_alternative == 1)
     output_asm_insn (\"sllx\\t%H1, 32, %H1\", operands);
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      if (which_alternative == 1)
+	return \"or\\t%L1, %H1, %H1\\n\\tmulx\\t%H1, %2, %L0\;srlx\\t%L0, 32, %H0\";
+      else
+	return \"sllx\\t%H1, 32, %3\\n\\tor\\t%L1, %3, %3\\n\\tmulx\\t%3, %2, %3\\n\\tsrlx\\t%3, 32, %H0\\n\\tmov\\t%3, %L0\";
+    }
   if (sparc_check_64 (operands[2], insn) <= 0)
     output_asm_insn (\"srl\\t%L2, 0, %L2\", operands);
   if (which_alternative == 1)
diff --git a/gcc/crtstuff.c b/gcc/crtstuff.c
index ccebde1d2c9..2d2f360bb75 100644
--- a/gcc/crtstuff.c
+++ b/gcc/crtstuff.c
@@ -380,19 +380,8 @@ init_dummy (void)
 #endif
   asm (TEXT_SECTION_ASM_OP);
 
-/* This is a kludge. The i386 GNU/Linux dynamic linker needs ___brk_addr,
-   __environ and atexit (). We have to make sure they are in the .dynsym
-   section. We accomplish it by making a dummy call here. This
-   code is never reached.  */
- 
-#if defined(__linux__) && defined(__PIC__) && defined(__i386__)
-  {
-    extern void *___brk_addr;
-    extern char **__environ;
-
-    ___brk_addr = __environ;
-    atexit ();
-  }
+#ifdef CRT_END_INIT_DUMMY
+  CRT_END_INIT_DUMMY;
 #endif
 }
 
diff --git a/gcc/cse.c b/gcc/cse.c
index ca40ab36e41..ff4d00f326e 100644
--- a/gcc/cse.c
+++ b/gcc/cse.c
@@ -695,8 +695,6 @@ static void check_fold_consts	PROTO((PTR));
 static struct cse_reg_info* get_cse_reg_info PROTO((int));
 static void free_cse_reg_info   PROTO((splay_tree_value));
 static void flush_hash_table	PROTO((void));
-
-extern int rtx_equal_function_value_matters;
 
 /* Dump the expressions in the equivalence class indicated by CLASSP.
    This function is used only for debugging.  */
diff --git a/gcc/except.c b/gcc/except.c
index f7d78d687ef..9075226c326 100644
--- a/gcc/except.c
+++ b/gcc/except.c
@@ -723,21 +723,41 @@ static void
 receive_exception_label (handler_label)
      rtx handler_label;
 {
+  rtx around_label = NULL_RTX;
+
+  if (! flag_new_exceptions || exceptions_via_longjmp)
+    {
+      around_label = gen_label_rtx ();
+      emit_jump (around_label);
+      emit_barrier ();
+    }
+
   emit_label (handler_label);
-  
-#ifdef HAVE_exception_receiver
+
   if (! exceptions_via_longjmp)
-    if (HAVE_exception_receiver)
-      emit_insn (gen_exception_receiver ());
+    {
+#ifdef HAVE_exception_receiver
+      if (HAVE_exception_receiver)
+	emit_insn (gen_exception_receiver ());
+      else
 #endif
-
 #ifdef HAVE_nonlocal_goto_receiver
-  if (! exceptions_via_longjmp)
-    if (HAVE_nonlocal_goto_receiver)
-      emit_insn (gen_nonlocal_goto_receiver ());
+      if (HAVE_nonlocal_goto_receiver)
+	emit_insn (gen_nonlocal_goto_receiver ());
+      else
 #endif
-}
+	{ /* Nothing */ }
+    }
+  else
+    {
+#ifndef DONT_USE_BUILTIN_SETJMP
+      expand_builtin_setjmp_receiver (handler_label);
+#endif
+    }
 
+  if (around_label)
+    emit_label (around_label);
+}
 
 struct func_eh_entry 
 {
@@ -1320,7 +1340,7 @@ static void
 start_dynamic_handler ()
 {
   rtx dhc, dcc;
-  rtx x, arg, buf;
+  rtx arg, buf;
   int size;
 
 #ifndef DONT_USE_BUILTIN_SETJMP
@@ -1362,18 +1382,17 @@ start_dynamic_handler ()
   buf = plus_constant (XEXP (arg, 0), GET_MODE_SIZE (Pmode)*2);
 
 #ifdef DONT_USE_BUILTIN_SETJMP
-  x = emit_library_call_value (setjmp_libfunc, NULL_RTX, 1, SImode, 1,
-			       buf, Pmode);
-  /* If we come back here for a catch, transfer control to the handler.  */
-  jumpif_rtx (x, ehstack.top->entry->exception_handler_label);
-#else
   {
-    /* A label to continue execution for the no exception case.  */
-    rtx noex = gen_label_rtx();
-    x = expand_builtin_setjmp (buf, NULL_RTX, noex,
-			       ehstack.top->entry->exception_handler_label);
-    emit_label (noex);
+    rtx x;
+    x = emit_library_call_value (setjmp_libfunc, NULL_RTX, LCT_CONST,
+                                TYPE_MODE (integer_type_node), 1,
+                                buf, Pmode);
+    /* If we come back here for a catch, transfer control to the handler.  */
+    jumpif_rtx (x, ehstack.top->entry->exception_handler_label);
   }
+#else
+  expand_builtin_setjmp_setup (buf,
+                              ehstack.top->entry->exception_handler_label);
 #endif
 
   /* We are committed to this, so update the handler chain.  */
diff --git a/gcc/expr.c b/gcc/expr.c
index e3fe1f8f9f1..ef16c762f98 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -192,6 +192,7 @@ static rtx expand_builtin	PROTO((tree, rtx, rtx,
 static int apply_args_size	PROTO((void));
 static int apply_result_size	PROTO((void));
 static rtx result_vector	PROTO((int, rtx));
+static rtx expand_builtin_setjmp PROTO((tree, rtx));
 static rtx expand_builtin_apply_args PROTO((void));
 static rtx expand_builtin_apply	PROTO((rtx, rtx, rtx));
 static void expand_builtin_return PROTO((rtx));
@@ -449,6 +450,9 @@ protect_from_queue (x, modify)
 				QUEUED_INSN (y));
 	      return temp;
 	    }
+	  /* Copy the address into a pseudo, so that the returned value
+	     remains correct across calls to emit_queue.  */
+	  XEXP (new, 0) = copy_to_reg (XEXP (new, 0));
 	  return new;
 	}
       /* Otherwise, recursively protect the subexpressions of all
@@ -475,9 +479,11 @@ protect_from_queue (x, modify)
 	}
       return x;
     }
-  /* If the increment has not happened, use the variable itself.  */
+  /* If the increment has not happened, use the variable itself.  Copy it
+     into a new pseudo so that the value remains correct across calls to
+     emit_queue.  */
   if (QUEUED_INSN (x) == 0)
-    return QUEUED_VAR (x);
+    return copy_to_reg (QUEUED_VAR (x));
   /* If the increment has happened and a pre-increment copy exists,
      use that copy.  */
   if (QUEUED_COPY (x) != 0)
@@ -8076,7 +8082,9 @@ expand_expr (exp, target, tmode, modifier)
 	  if (ignore)
 	    return op0;
 
-	  op0 = protect_from_queue (op0, 0);
+	  /* Pass 1 for MODIFY, so that protect_from_queue doesn't get
+	     clever and returns a REG when given a MEM.  */
+	  op0 = protect_from_queue (op0, 1);
 
 	  /* We would like the object in memory.  If it is a constant,
 	     we can have it be statically allocated into memory.  For
@@ -8544,44 +8552,29 @@ expand_builtin_return_addr (fndecl_code, count, tem)
   return tem;
 }
 
-/* __builtin_setjmp is passed a pointer to an array of five words (not
-   all will be used on all machines).  It operates similarly to the C
-   library function of the same name, but is more efficient.  Much of
-   the code below (and for longjmp) is copied from the handling of
-   non-local gotos.
-
-   NOTE: This is intended for use by GNAT and the exception handling
-   scheme in the compiler and will only work in the method used by
-   them.  */
+/* Construct the leading half of a __builtin_setjmp call.  Control will
+   return to RECEIVER_LABEL.  This is used directly by sjlj exception
+   handling code.  */
 
-rtx
-expand_builtin_setjmp (buf_addr, target, first_label, next_label)
+void
+expand_builtin_setjmp_setup (buf_addr, receiver_label)
      rtx buf_addr;
-     rtx target;
-     rtx first_label, next_label;
+     rtx receiver_label;
 {
-  rtx lab1 = gen_label_rtx ();
   enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);
-  enum machine_mode value_mode;
   rtx stack_save;
 
-  value_mode = TYPE_MODE (integer_type_node);
-
 #ifdef POINTERS_EXTEND_UNSIGNED
   buf_addr = convert_memory_address (Pmode, buf_addr);
 #endif
 
   buf_addr = force_reg (Pmode, buf_addr);
 
-  if (target == 0 || GET_CODE (target) != REG
-      || REGNO (target) < FIRST_PSEUDO_REGISTER)
-    target = gen_reg_rtx (value_mode);
-
   emit_queue ();
 
-  /* We store the frame pointer and the address of lab1 in the buffer
-     and use the rest of it for the stack save area, which is
-     machine-dependent.  */
+  /* We store the frame pointer and the address of receiver_label in
+     the buffer and use the rest of it for the stack save area, which
+     is machine-dependent.  */
 
 #ifndef BUILTIN_SETJMP_FRAME_VALUE
 #define BUILTIN_SETJMP_FRAME_VALUE virtual_stack_vars_rtx
@@ -8593,7 +8586,7 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
 		  (gen_rtx_MEM (Pmode,
 				plus_constant (buf_addr,
 					       GET_MODE_SIZE (Pmode)))),
-		  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, lab1)));
+		  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, receiver_label)));
 
   stack_save = gen_rtx_MEM (sa_mode,
 			    plus_constant (buf_addr,
@@ -8606,20 +8599,22 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
     emit_insn (gen_builtin_setjmp_setup (buf_addr));
 #endif
 
-  /* Set TARGET to zero and branch to the first-time-through label.  */
-  emit_move_insn (target, const0_rtx);
-  emit_jump_insn (gen_jump (first_label));
-  emit_barrier ();
-  emit_label (lab1);
-
-  /* Tell flow about the strange goings on.  Putting `lab1' on
-     `nonlocal_goto_handler_labels' to indicates that function
-     calls may traverse the arc back to this label.  */
+  /* Tell optimize_save_area_alloca that extra work is going to
+     need to go on during alloca.  */
+  current_function_calls_setjmp = 1;
 
+  /* Set this so all the registers get saved in our frame; we need to be
+     able to copy the saved values for any registers from frames we unwind. */
   current_function_has_nonlocal_label = 1;
-  nonlocal_goto_handler_labels =
-    gen_rtx_EXPR_LIST (VOIDmode, lab1, nonlocal_goto_handler_labels);
+}
+
+/* Construct the trailing part of a __builtin_setjmp call.
+   This is used directly by sjlj exception handling code.  */
 
+void
+expand_builtin_setjmp_receiver (receiver_label)
+      rtx receiver_label ATTRIBUTE_UNUSED;
+{
   /* Clobber the FP when we get here, so we have to make sure it's
      marked as used by this function.  */
   emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));
@@ -8666,7 +8661,7 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
 
 #ifdef HAVE_builtin_setjmp_receiver
   if (HAVE_builtin_setjmp_receiver)
-    emit_insn (gen_builtin_setjmp_receiver (lab1));
+    emit_insn (gen_builtin_setjmp_receiver (receiver_label));
   else
 #endif
 #ifdef HAVE_nonlocal_goto_receiver
@@ -8678,10 +8673,66 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
 	; /* Nothing */
       }
 
-  /* Set TARGET, and branch to the next-time-through label.  */
-  emit_move_insn (target, const1_rtx);
-  emit_jump_insn (gen_jump (next_label));
+  /* @@@ This is a kludge.  Not all machine descriptions define a blockage
+     insn, but we must not allow the code we just generated to be reordered
+     by scheduling.  Specifically, the update of the frame pointer must
+     happen immediately, not later.  So emit an ASM_INPUT to act as blockage
+     insn.  */
+  emit_insn (gen_rtx_ASM_INPUT (VOIDmode, ""));
+}
+
+
+/* __builtin_setjmp is passed a pointer to an array of five words (not
+   all will be used on all machines).  It operates similarly to the C
+   library function of the same name, but is more efficient.  Much of
+   the code below (and for longjmp) is copied from the handling of
+   non-local gotos.
+
+   NOTE: This is intended for use by GNAT and the exception handling
+   scheme in the compiler and will only work in the method used by
+   them.  */
+
+static rtx
+expand_builtin_setjmp (arglist, target)
+     tree arglist;
+     rtx target;
+{
+  rtx buf_addr, next_lab, cont_lab;
+
+  if (arglist == 0
+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)
+    return NULL_RTX;
+
+  if (target == 0 || GET_CODE (target) != REG
+      || REGNO (target) < FIRST_PSEUDO_REGISTER)
+    target = gen_reg_rtx (TYPE_MODE (integer_type_node));
+
+  buf_addr = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);
+
+  next_lab = gen_label_rtx ();
+  cont_lab = gen_label_rtx ();
+
+  expand_builtin_setjmp_setup (buf_addr, next_lab);
+
+  /* Set TARGET to zero and branch to the continue label.  */
+  emit_move_insn (target, const0_rtx);
+  emit_jump_insn (gen_jump (cont_lab));
   emit_barrier ();
+  emit_label (next_lab);
+
+  expand_builtin_setjmp_receiver (next_lab);
+
+  /* Set TARGET to one.  */
+  emit_move_insn (target, const1_rtx);
+  emit_label (cont_lab);
+
+  /* Tell flow about the strange goings on.  Putting `next_lab' on
+     `nonlocal_goto_handler_labels' to indicates that function
+     calls may traverse the arc back to this label.  */
+
+  current_function_has_nonlocal_label = 1;
+  nonlocal_goto_handler_labels
+    = gen_rtx_EXPR_LIST (VOIDmode, next_lab, nonlocal_goto_handler_labels);
 
   return target;
 }
@@ -9703,18 +9754,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)
 #endif
 
     case BUILT_IN_SETJMP:
-      if (arglist == 0
-	  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)
-	break;
-      else
-	{
-	  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,
-				      VOIDmode, 0);
-	  rtx lab = gen_label_rtx ();
-	  rtx ret = expand_builtin_setjmp (buf_addr, target, lab, lab);
-	  emit_label (lab);
-	  return ret;
-	}
+      target = expand_builtin_setjmp (arglist, target);
+      if (target)
+	return target;
+      break;
 
       /* __builtin_longjmp is passed a pointer to an array of five words.
 	 It's similar to the C library longjmp function but works with
diff --git a/gcc/expr.h b/gcc/expr.h
index 55e82e6622d..c279774afe5 100644
--- a/gcc/expr.h
+++ b/gcc/expr.h
@@ -831,7 +831,8 @@ extern rtx store_expr PROTO((tree, rtx, int));
    Useful after calling expand_expr with 1 as sum_ok.  */
 extern rtx force_operand PROTO((rtx, rtx));
 
-extern rtx expand_builtin_setjmp PROTO((rtx, rtx, rtx, rtx));
+extern void expand_builtin_setjmp_setup PARAMS ((rtx, rtx));
+extern void expand_builtin_setjmp_receiver PARAMS ((rtx));
 
 #ifdef TREE_CODE
 /* Generate code for computing expression EXP.
diff --git a/gcc/final.c b/gcc/final.c
index 11cfebf3462..7a31cdeef8a 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -1701,7 +1701,9 @@ static void
 profile_function (file)
      FILE *file;
 {
+#ifndef NO_PROFILE_COUNTERS
   int align = MIN (BIGGEST_ALIGNMENT, LONG_TYPE_SIZE);
+#endif
 #if defined(ASM_OUTPUT_REG_PUSH)
 #if defined(STRUCT_VALUE_INCOMING_REGNUM) || defined(STRUCT_VALUE_REGNUM)
   int sval = current_function_returns_struct;
@@ -1711,10 +1713,12 @@ profile_function (file)
 #endif
 #endif /* ASM_OUTPUT_REG_PUSH */
 
+#ifndef NO_PROFILE_COUNTERS
   data_section ();
   ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));
   ASM_OUTPUT_INTERNAL_LABEL (file, "LP", profile_label_no);
   assemble_integer (const0_rtx, LONG_TYPE_SIZE / BITS_PER_UNIT, 1);
+#endif
 
   function_section (current_function_decl);
 
@@ -3043,7 +3047,8 @@ cleanup_subreg_operands (insn)
       if (GET_CODE (recog_operand[i]) == SUBREG)
         recog_operand[i] = alter_subreg (recog_operand[i]);
       else if (GET_CODE (recog_operand[i]) == PLUS
-               || GET_CODE (recog_operand[i]) == MULT)
+               || GET_CODE (recog_operand[i]) == MULT
+	       || GET_CODE (recog_operand[i]) == MEM)
        recog_operand[i] = walk_alter_subreg (recog_operand[i]);
     }
 
@@ -3052,7 +3057,8 @@ cleanup_subreg_operands (insn)
       if (GET_CODE (*recog_dup_loc[i]) == SUBREG)
         *recog_dup_loc[i] = alter_subreg (*recog_dup_loc[i]);
       else if (GET_CODE (*recog_dup_loc[i]) == PLUS
-               || GET_CODE (*recog_dup_loc[i]) == MULT)
+               || GET_CODE (*recog_dup_loc[i]) == MULT
+	       || GET_CODE (*recog_dup_loc[i]) == MEM)
         *recog_dup_loc[i] = walk_alter_subreg (*recog_dup_loc[i]);
     }
 }
diff --git a/gcc/flow.c b/gcc/flow.c
index 432a990220a..f3b32139541 100644
--- a/gcc/flow.c
+++ b/gcc/flow.c
@@ -2744,15 +2744,23 @@ propagate_block (old, first, last, final, significant, bnum, remove_dead_code)
 		{
 		  if (REG_NOTE_KIND (inote) == REG_LABEL)
 		    {
+		      int n_forced;
 		      rtx label = XEXP (inote, 0);
 		      rtx next;
 		      LABEL_NUSES (label)--;
 
+		      /* The label may be forced if it has been put in the
+		         constant pool.  We can't delete it in this case, but
+		         we still must discard a jump table following it.  */
+		      n_forced = 0;
+		      if (LABEL_PRESERVE_P (label))
+			n_forced++;
+
 		      /* If this label was attached to an ADDR_VEC, it's
 			 safe to delete the ADDR_VEC.  In fact, it's pretty much
 			 mandatory to delete it, because the ADDR_VEC may
 			 be referencing labels that no longer exist.  */
-		      if (LABEL_NUSES (label) == 0
+		      if (LABEL_NUSES (label) == n_forced
 			  && (next = next_nonnote_insn (label)) != NULL
 			  && GET_CODE (next) == JUMP_INSN
 			  && (GET_CODE (PATTERN (next)) == ADDR_VEC
diff --git a/gcc/function.c b/gcc/function.c
index edd0bca1216..77dabeb6ccd 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -513,8 +513,9 @@ static int *record_insns	PROTO((rtx));
 static int contains		PROTO((rtx, int *));
 #endif /* HAVE_prologue || HAVE_epilogue */
 static void put_addressof_into_stack PROTO((rtx, struct hash_table *));
-static void purge_addressof_1	PROTO((rtx *, rtx, int, int, 
+static boolean purge_addressof_1 PROTO((rtx *, rtx, int, int, 
 				       struct hash_table *));
+static int is_addressof		PROTO ((rtx *, void *));
 static struct hash_entry *insns_for_mem_newfunc PROTO((struct hash_entry *,
 						       struct hash_table *,
 						       hash_table_key));
@@ -3055,9 +3056,10 @@ static rtx purge_addressof_replacements;
 
 /* Helper function for purge_addressof.  See if the rtx expression at *LOC
    in INSN needs to be changed.  If FORCE, always put any ADDRESSOFs into
-   the stack.  */
+   the stack.  If the function returns FALSE then the replacement could not
+   be made.  */
 
-static void
+static boolean
 purge_addressof_1 (loc, insn, force, store, ht)
      rtx *loc;
      rtx insn;
@@ -3068,13 +3070,14 @@ purge_addressof_1 (loc, insn, force, store, ht)
   RTX_CODE code;
   int i, j;
   char *fmt;
+  boolean result = true;
 
   /* Re-start here to avoid recursion in common cases.  */
  restart:
 
   x = *loc;
   if (x == 0)
-    return;
+    return true;
 
   code = GET_CODE (x);
 
@@ -3087,7 +3090,7 @@ purge_addressof_1 (loc, insn, force, store, ht)
 
       if (validate_change (insn, loc, sub, 0)
 	  || validate_replace_rtx (x, sub, insn))
-	return;
+	return true;
   
       start_sequence ();
       sub = force_operand (sub, NULL_RTX);
@@ -3098,7 +3101,7 @@ purge_addressof_1 (loc, insn, force, store, ht)
       insns = gen_sequence ();
       end_sequence ();
       emit_insn_before (insns, insn);
-      return;
+      return true;
     }
   else if (code == MEM && GET_CODE (XEXP (x, 0)) == ADDRESSOF && ! force)
     {
@@ -3117,7 +3120,7 @@ purge_addressof_1 (loc, insn, force, store, ht)
 	  && (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode))
 	{
 	  put_addressof_into_stack (XEXP (x, 0), ht);
-	  return;
+	  return true;
 	}
       else if (GET_CODE (sub) == REG && GET_MODE (x) != GET_MODE (sub))
 	{
@@ -3136,7 +3139,7 @@ purge_addressof_1 (loc, insn, force, store, ht)
 		if (rtx_equal_p (x, XEXP (tem, 0)))
 		  {
 		    *loc = XEXP (XEXP (tem, 1), 0);
-		    return;
+		    return true;
 		  }
 
 	      /* See comment for purge_addressof_replacements. */
@@ -3176,11 +3179,17 @@ purge_addressof_1 (loc, insn, force, store, ht)
 		      z = gen_lowpart (GET_MODE (x), z);
 
 		    *loc = z;
-		    return;
+		    return true;
 		  }
 
-	      /* There should always be such a replacement.  */
-	      abort ();
+	      /* Sometimes we may not be able to find the replacement.  For
+		 example when the original insn was a MEM in a wider mode,
+		 and the note is part of a sign extension of a narrowed
+		 version of that MEM.  Gcc testcase compile/990829-1.c can
+		 generate an example of this siutation.  Rather than complain
+		 we return false, which will prompt our caller to remove the
+		 offending note.  */
+	      return false;
 	    }
 
 	  size_x = GET_MODE_BITSIZE (GET_MODE (x));
@@ -3266,7 +3275,7 @@ purge_addressof_1 (loc, insn, force, store, ht)
 				      purge_bitfield_addressof_replacements));
 
 	      /* We replaced with a reg -- all done.  */
-	      return;
+	      return true;
 	    }
 	}
       else if (validate_change (insn, loc, sub, 0))
@@ -3283,13 +3292,13 @@ purge_addressof_1 (loc, insn, force, store, ht)
 		if (rtx_equal_p (XEXP (x, 0), XEXP (tem, 0)))
 		  {
 		    XEXP (XEXP (tem, 1), 0) = sub;
-		    return;
+		    return true;
 		  }
 	      purge_addressof_replacements
 		= gen_rtx (EXPR_LIST, VOIDmode, XEXP (x, 0),
 			   gen_rtx_EXPR_LIST (VOIDmode, sub,
 					      purge_addressof_replacements));
-	      return;
+	      return true;
 	    }
 	  goto restart;
 	}
@@ -3299,13 +3308,13 @@ purge_addressof_1 (loc, insn, force, store, ht)
   else if (code == ADDRESSOF)
     {
       put_addressof_into_stack (x, ht);
-      return;
+      return true;
     }
   else if (code == SET)
     {
-      purge_addressof_1 (&SET_DEST (x), insn, force, 1, ht);
-      purge_addressof_1 (&SET_SRC (x), insn, force, 0, ht);
-      return;
+      result = purge_addressof_1 (&SET_DEST (x), insn, force, 1, ht);
+      result &= purge_addressof_1 (&SET_SRC (x), insn, force, 0, ht);
+      return result;
     }
 
   /* Scan all subexpressions. */
@@ -3313,11 +3322,13 @@ purge_addressof_1 (loc, insn, force, store, ht)
   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)
     {
       if (*fmt == 'e')
-	purge_addressof_1 (&XEXP (x, i), insn, force, 0, ht);
+	result &= purge_addressof_1 (&XEXP (x, i), insn, force, 0, ht);
       else if (*fmt == 'E')
 	for (j = 0; j < XVECLEN (x, i); j++)
-	  purge_addressof_1 (&XVECEXP (x, i, j), insn, force, 0, ht);
+	  result &= purge_addressof_1 (&XVECEXP (x, i, j), insn, force, 0, ht);
     }
+
+  return result;
 }
 
 /* Return a new hash table entry in HT.  */
@@ -3437,6 +3448,16 @@ compute_insns_for_mem (insns, last_insn, ht)
 	}
 }
 
+/* Helper function for purge_addressof called through for_each_rtx.
+   Returns true iff the rtl is an ADDRESSOF.  */
+static int
+is_addressof (rtl, data)
+     rtx * rtl;
+     void * data ATTRIBUTE_UNUSED;
+{
+  return GET_CODE (* rtl) == ADDRESSOF;
+}
+
 /* Eliminate all occurrences of ADDRESSOF from INSNS.  Elide any remaining
    (MEM (ADDRESSOF)) patterns, and force any needed registers into the
    stack.  */
@@ -3465,9 +3486,30 @@ purge_addressof (insns)
     if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN
 	|| GET_CODE (insn) == CALL_INSN)
       {
-	purge_addressof_1 (&PATTERN (insn), insn,
-			   asm_noperands (PATTERN (insn)) > 0, 0, &ht);
-	purge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0, &ht);
+	if (! purge_addressof_1 (&PATTERN (insn), insn,
+				 asm_noperands (PATTERN (insn)) > 0, 0, &ht))
+	  /* If we could not replace the ADDRESSOFs in the insn,
+	     something is wrong.  */
+	  abort ();
+	
+	if (! purge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0, &ht))
+	  {
+	    /* If we could not replace the ADDRESSOFs in the insn's notes,
+	       we can just remove the offending notes instead.  */
+	    rtx note;
+
+	    for (note = REG_NOTES (insn); note; note = XEXP (note, 1))
+	      {
+		/* If we find a REG_RETVAL note then the insn is a libcall.
+		   Such insns must have REG_EQUAL notes as well, in order
+		   for later passes of the compiler to work.  So it is not
+		   safe to delete the notes here, and instead we abort.  */
+		if (REG_NOTE_KIND (note) == REG_RETVAL)
+		  abort ();
+		if (for_each_rtx (& note, is_addressof, NULL))
+		  remove_note (insn, note);
+	      }
+	  }
       }
 
   /* Clean up.  */
@@ -5292,7 +5334,18 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,
 				- offset_ptr->constant); 
     }
 #else /* !ARGS_GROW_DOWNWARD */
-  pad_to_arg_alignment (initial_offset_ptr, boundary);
+  if (!in_regs 
+#ifdef REG_PARM_STACK_SPACE
+      || REG_PARM_STACK_SPACE (fndecl) > 0
+#else
+      /* For the gcc-2_95-branch we want to make sure not to break something
+         on platforms which pass argument in registers but don't define
+         REG_PARM_STACK_SPACE. So we force the original behaviour here.  */
+      || 1
+#endif
+      )
+    pad_to_arg_alignment (initial_offset_ptr, boundary);
+
   *offset_ptr = *initial_offset_ptr;
 
 #ifdef PUSH_ROUNDING
@@ -6927,7 +6980,7 @@ thread_prologue_and_epilogue_insns (f)
 	    }
 	}
       }
-  #endif
+#endif
 }
 
 /* Reposition the prologue-end and epilogue-begin notes after instruction
diff --git a/gcc/gcc.c b/gcc/gcc.c
index d4dbf5ea9d6..c5a312d8496 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -5040,48 +5040,53 @@ main (argc, argv)
 	  int len;
 
 	  if (cp->spec[0][0] == '#')
-	    error ("%s: %s compiler not installed on this system",
-		   input_filename, &cp->spec[0][1]);
-
-	  input_basename = input_filename;
-	  for (p = input_filename; *p; p++)
-	    if (IS_DIR_SEPARATOR (*p))
-	      input_basename = p + 1;
-
-	  /* Find a suffix starting with the last period,
-	     and set basename_length to exclude that suffix.  */
-	  basename_length = strlen (input_basename);
-	  p = input_basename + basename_length;
-	  while (p != input_basename && *p != '.') --p;
-	  if (*p == '.' && p != input_basename)
 	    {
-	      basename_length = p - input_basename;
-	      input_suffix = p + 1;
+	      error ("%s: %s compiler not installed on this system",
+		     input_filename, &cp->spec[0][1]);
+	      this_file_error = 1;
 	    }
 	  else
-	    input_suffix = "";
+	    {
+	      input_basename = input_filename;
+	      for (p = input_filename; *p; p++)
+		if (IS_DIR_SEPARATOR (*p))
+		  input_basename = p + 1;
+
+	      /* Find a suffix starting with the last period,
+		 and set basename_length to exclude that suffix.  */
+	      basename_length = strlen (input_basename);
+	      p = input_basename + basename_length;
+	      while (p != input_basename && *p != '.') --p;
+	      if (*p == '.' && p != input_basename)
+		{
+		  basename_length = p - input_basename;
+		  input_suffix = p + 1;
+		}
+	      else
+		input_suffix = "";
 
-	  len = 0;
-	  for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
-	    if (cp->spec[j])
-	      len += strlen (cp->spec[j]);
+	      len = 0;
+	      for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
+		if (cp->spec[j])
+		  len += strlen (cp->spec[j]);
 
-	  {
-	    char *p1 = (char *) xmalloc (len + 1);
+	      {
+		char *p1 = (char *) xmalloc (len + 1);
 	    
-	    len = 0;
-	    for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
-	      if (cp->spec[j])
-		{
-		  strcpy (p1 + len, cp->spec[j]);
-		  len += strlen (cp->spec[j]);
-		}
+		len = 0;
+		for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
+		  if (cp->spec[j])
+		    {
+		      strcpy (p1 + len, cp->spec[j]);
+		      len += strlen (cp->spec[j]);
+		    }
 	    
-	    value = do_spec (p1);
-	    free (p1);
-	  }
-	  if (value < 0)
-	    this_file_error = 1;
+		value = do_spec (p1);
+		free (p1);
+	      }
+	      if (value < 0)
+		this_file_error = 1;
+	    }
 	}
 
       /* If this file's name does not contain a recognized suffix,
diff --git a/gcc/invoke.texi b/gcc/invoke.texi
index e97495e1b6c..9865a3449ec 100644
--- a/gcc/invoke.texi
+++ b/gcc/invoke.texi
@@ -1694,6 +1694,12 @@ A @code{switch} statement has an operand of type @code{long}.
 @item
 A non-@code{static} function declaration follows a @code{static} one.
 This construct is not accepted by some traditional C compilers.
+
+@item
+The ANSI type of an integer constant has a different width or signedness
+from its traditional type.  This warning is only issued if the base of
+the constant is ten.  I.e. hexadecimal or octal values, which typically
+represent bit patterns, are not warned about.
 @end itemize
 
 @item -Wundef
diff --git a/gcc/jump.c b/gcc/jump.c
index 32eebd1eb6c..6e7e90505c8 100644
--- a/gcc/jump.c
+++ b/gcc/jump.c
@@ -200,8 +200,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)
   if (flag_exceptions && cross_jump)
     init_insn_eh_region (f, max_uid);
 
-  delete_barrier_successors (f);
-
   /* Leave some extra room for labels and duplicate exit test insns
      we make.  */
   max_jump_chain = max_uid * 14 / 10;
@@ -224,6 +222,8 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)
   for (insn = exception_handler_labels; insn; insn = XEXP (insn, 1))
     LABEL_NUSES (XEXP (insn, 0))++;
 
+  delete_barrier_successors (f);
+
   /* Quit now if we just wanted to rebuild the JUMP_LABEL and REG_LABEL
      notes and recompute LABEL_NUSES.  */
   if (mark_labels_only)
@@ -2139,7 +2139,24 @@ delete_barrier_successors (f)
 	  insn = NEXT_INSN (insn);
 	  while (insn != 0 && GET_CODE (insn) != CODE_LABEL)
 	    {
-	      if (GET_CODE (insn) == NOTE
+	      if (GET_CODE (insn) == JUMP_INSN)
+		{
+		  /* Detect when we're deleting a tablejump; get rid of
+		     the jump table as well.  */
+		  rtx next1 = next_nonnote_insn (insn);
+		  rtx next2 = next1 ? next_nonnote_insn (next1) : 0;
+		  if (next2 && GET_CODE (next1) == CODE_LABEL
+		      && GET_CODE (next2) == JUMP_INSN
+		      && (GET_CODE (PATTERN (next2)) == ADDR_VEC
+			  || GET_CODE (PATTERN (next2)) == ADDR_DIFF_VEC))
+		    {
+		      delete_insn (insn);
+		      insn = next2;
+		    }
+		  else
+		    insn = delete_insn (insn);
+		}
+	      else if (GET_CODE (insn) == NOTE
 		  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END)
 		insn = NEXT_INSN (insn);
 	      else
diff --git a/gcc/loop.c b/gcc/loop.c
index aca291dd6b1..eff3c4a26d9 100644
--- a/gcc/loop.c
+++ b/gcc/loop.c
@@ -1481,10 +1481,16 @@ combine_movables (movables, nregs)
 		      width as M1.  The check for integer is redundant, but
 		      safe, since the only case of differing destination
 		      modes with equal sources is when both sources are
-		      VOIDmode, i.e., CONST_INT.  */
+		      VOIDmode, i.e., CONST_INT.
+		    
+		      For 2.95, don't do this if the mode of M1 is Pmode.
+		      This prevents us from substituting SUBREGs for REGs
+		      in memory accesses; not all targets are prepared to
+		      handle this properly.  */
 		   (GET_MODE (m->set_dest) == GET_MODE (m1->set_dest)
 		    || (GET_MODE_CLASS (GET_MODE (m->set_dest)) == MODE_INT
 			&& GET_MODE_CLASS (GET_MODE (m1->set_dest)) == MODE_INT
+			&& GET_MODE (m1->set_dest) != Pmode
 			&& (GET_MODE_BITSIZE (GET_MODE (m->set_dest))
 			    >= GET_MODE_BITSIZE (GET_MODE (m1->set_dest)))))
 		   /* See if the source of M1 says it matches M.  */
diff --git a/gcc/objc/objc-parse.c b/gcc/objc/objc-parse.c
index b95312d8708..64dfbc2cd63 100644
--- a/gcc/objc/objc-parse.c
+++ b/gcc/objc/objc-parse.c
@@ -1,69 +1,68 @@
 
 /*  A Bison parser, made from objc-parse.y
- by  GNU Bison version 1.25
-  */
+    by GNU Bison version 1.28  */
 
 #define YYBISON 1  /* Identify Bison output.  */
 
-#define	IDENTIFIER	258
-#define	TYPENAME	259
-#define	SCSPEC	260
-#define	TYPESPEC	261
-#define	TYPE_QUAL	262
-#define	CONSTANT	263
-#define	STRING	264
-#define	ELLIPSIS	265
-#define	SIZEOF	266
-#define	ENUM	267
-#define	STRUCT	268
-#define	UNION	269
-#define	IF	270
-#define	ELSE	271
-#define	WHILE	272
-#define	DO	273
-#define	FOR	274
-#define	SWITCH	275
-#define	CASE	276
-#define	DEFAULT	277
-#define	BREAK	278
-#define	CONTINUE	279
-#define	RETURN	280
-#define	GOTO	281
-#define	ASM_KEYWORD	282
-#define	TYPEOF	283
-#define	ALIGNOF	284
-#define	ATTRIBUTE	285
-#define	EXTENSION	286
-#define	LABEL	287
-#define	REALPART	288
-#define	IMAGPART	289
-#define	ASSIGN	290
-#define	OROR	291
-#define	ANDAND	292
-#define	EQCOMPARE	293
-#define	ARITHCOMPARE	294
-#define	LSHIFT	295
-#define	RSHIFT	296
-#define	UNARY	297
-#define	PLUSPLUS	298
-#define	MINUSMINUS	299
-#define	HYPERUNARY	300
-#define	POINTSAT	301
-#define	INTERFACE	302
-#define	IMPLEMENTATION	303
-#define	END	304
-#define	SELECTOR	305
-#define	DEFS	306
-#define	ENCODE	307
-#define	CLASSNAME	308
-#define	PUBLIC	309
-#define	PRIVATE	310
-#define	PROTECTED	311
-#define	PROTOCOL	312
-#define	OBJECTNAME	313
-#define	CLASS	314
-#define	ALIAS	315
-#define	OBJC_STRING	316
+#define	IDENTIFIER	257
+#define	TYPENAME	258
+#define	SCSPEC	259
+#define	TYPESPEC	260
+#define	TYPE_QUAL	261
+#define	CONSTANT	262
+#define	STRING	263
+#define	ELLIPSIS	264
+#define	SIZEOF	265
+#define	ENUM	266
+#define	STRUCT	267
+#define	UNION	268
+#define	IF	269
+#define	ELSE	270
+#define	WHILE	271
+#define	DO	272
+#define	FOR	273
+#define	SWITCH	274
+#define	CASE	275
+#define	DEFAULT	276
+#define	BREAK	277
+#define	CONTINUE	278
+#define	RETURN	279
+#define	GOTO	280
+#define	ASM_KEYWORD	281
+#define	TYPEOF	282
+#define	ALIGNOF	283
+#define	ATTRIBUTE	284
+#define	EXTENSION	285
+#define	LABEL	286
+#define	REALPART	287
+#define	IMAGPART	288
+#define	ASSIGN	289
+#define	OROR	290
+#define	ANDAND	291
+#define	EQCOMPARE	292
+#define	ARITHCOMPARE	293
+#define	LSHIFT	294
+#define	RSHIFT	295
+#define	UNARY	296
+#define	PLUSPLUS	297
+#define	MINUSMINUS	298
+#define	HYPERUNARY	299
+#define	POINTSAT	300
+#define	INTERFACE	301
+#define	IMPLEMENTATION	302
+#define	END	303
+#define	SELECTOR	304
+#define	DEFS	305
+#define	ENCODE	306
+#define	CLASSNAME	307
+#define	PUBLIC	308
+#define	PRIVATE	309
+#define	PROTECTED	310
+#define	PROTOCOL	311
+#define	OBJECTNAME	312
+#define	CLASS	313
+#define	ALIAS	314
+#define	OBJC_STRING	315
 
 #line 33 "objc-parse.y"
 
@@ -120,6 +119,17 @@ static tree declspec_stack;
 /* 1 if we explained undeclared var errors.  */
 static int undeclared_variable_notice;
 
+/* For __extension__, save/restore the warning flags which are
+   controlled by __extension__.  */
+#define SAVE_WARN_FLAGS()	\
+	build_int_2 (pedantic | (warn_pointer_arith << 1), 0)
+#define RESTORE_WARN_FLAGS(tval) \
+  do {                                     \
+    int val = TREE_INT_CST_LOW (tval);     \
+    pedantic = val & 1;                    \
+    warn_pointer_arith = (val >> 1) & 1;   \
+  } while (0)
+
 /* Objective-C specific information */
 
 tree objc_interface_context;
@@ -150,7 +160,7 @@ extern void yyprint			PROTO ((FILE *, int, YYSTYPE));
 #define	YYFLAG		-32768
 #define	YYNTBASE	84
 
-#define YYTRANSLATE(x) ((unsigned)(x) <= 316 ? yytranslate[x] : 311)
+#define YYTRANSLATE(x) ((unsigned)(x) <= 315 ? yytranslate[x] : 311)
 
 static const char yytranslate[] = {     0,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -178,13 +188,13 @@ static const char yytranslate[] = {     0,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
-     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
-    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
-    39,    40,    44,    45,    46,    47,    53,    54,    55,    56,
-    57,    61,    62,    63,    64,    65,    66,    67,    68,    69,
-    70,    71,    72,    73,    74,    75
+     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
+     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+    27,    28,    29,    30,    31,    32,    33,    34,    35,    39,
+    40,    44,    45,    46,    47,    53,    54,    55,    56,    57,
+    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
+    71,    72,    73,    74,    75
 };
 
 #if YYDEBUG != 0
@@ -431,63 +441,63 @@ static const short yyrhs[] = {    -1,
 
 #if YYDEBUG != 0
 static const short yyrline[] = { 0,
-   233,   238,   252,   254,   254,   255,   257,   259,   260,   261,
-   269,   273,   284,   289,   294,   296,   298,   299,   300,   305,
-   312,   314,   319,   324,   330,   332,   337,   342,   348,   350,
-   355,   362,   364,   365,   366,   369,   371,   373,   375,   377,
-   379,   381,   385,   389,   392,   395,   398,   402,   404,   407,
-   410,   414,   442,   448,   451,   454,   457,   459,   463,   467,
-   471,   473,   476,   480,   507,   509,   511,   513,   515,   517,
-   519,   521,   523,   525,   527,   529,   531,   533,   537,   539,
-   543,   545,   548,   552,   554,   561,   564,   572,   583,   743,
-   744,   746,   752,   754,   768,   791,   793,   795,   807,   821,
-   823,   825,   827,   829,   831,   833,   838,   840,   846,   848,
-   852,   854,   855,   865,   870,   872,   873,   874,   881,   887,
-   892,   895,   903,   908,   910,   911,   912,   919,   930,   934,
-   940,   945,   950,   955,   957,   959,   968,   971,   975,   977,
-   979,   984,   988,   991,   995,   998,  1000,  1012,  1015,  1017,
-  1019,  1023,  1027,  1029,  1032,  1045,  1048,  1052,  1054,  1062,
-  1063,  1064,  1068,  1070,  1075,  1077,  1079,  1085,  1086,  1087,
-  1090,  1092,  1095,  1097,  1100,  1103,  1109,  1116,  1118,  1125,
-  1132,  1135,  1142,  1145,  1149,  1152,  1156,  1161,  1164,  1168,
-  1171,  1173,  1175,  1177,  1184,  1186,  1187,  1188,  1193,  1195,
-  1200,  1208,  1213,  1217,  1220,  1222,  1227,  1229,  1230,  1233,
-  1233,  1236,  1239,  1241,  1243,  1246,  1248,  1251,  1259,  1270,
-  1278,  1282,  1293,  1301,  1308,  1310,  1315,  1318,  1323,  1325,
-  1327,  1334,  1336,  1337,  1345,  1351,  1353,  1355,  1362,  1364,
-  1370,  1376,  1378,  1380,  1382,  1389,  1391,  1394,  1397,  1401,
-  1404,  1408,  1411,  1415,  1420,  1422,  1426,  1428,  1430,  1432,
-  1436,  1438,  1441,  1444,  1447,  1450,  1454,  1456,  1459,  1461,
-  1466,  1469,  1474,  1476,  1478,  1482,  1506,  1513,  1518,  1524,
-  1529,  1531,  1536,  1538,  1542,  1546,  1550,  1560,  1562,  1567,
-  1572,  1575,  1579,  1582,  1586,  1589,  1592,  1595,  1599,  1602,
-  1606,  1610,  1612,  1614,  1616,  1618,  1620,  1622,  1624,  1628,
-  1636,  1644,  1646,  1648,  1652,  1654,  1657,  1660,  1673,  1675,
-  1680,  1682,  1685,  1699,  1702,  1705,  1707,  1709,  1717,  1725,
-  1736,  1741,  1744,  1758,  1767,  1771,  1775,  1779,  1785,  1789,
-  1794,  1797,  1802,  1805,  1806,  1823,  1828,  1831,  1843,  1845,
-  1855,  1865,  1866,  1874,  1877,  1889,  1893,  1910,  1920,  1929,
-  1934,  1939,  1944,  1948,  1952,  1963,  1970,  1977,  1984,  1995,
-  2001,  2004,  2009,  2032,  2066,  2097,  2128,  2143,  2157,  2161,
-  2165,  2168,  2173,  2175,  2178,  2180,  2184,  2189,  2192,  2198,
-  2203,  2208,  2210,  2219,  2220,  2226,  2228,  2238,  2240,  2244,
-  2247,  2253,  2263,  2272,  2281,  2291,  2305,  2310,  2315,  2317,
-  2326,  2329,  2334,  2337,  2341,  2349,  2351,  2352,  2353,  2354,
-  2355,  2369,  2372,  2376,  2382,  2388,  2395,  2400,  2406,  2413,
-  2419,  2425,  2430,  2436,  2443,  2449,  2455,  2461,  2469,  2475,
-  2481,  2489,  2496,  2502,  2511,  2518,  2526,  2531,  2534,  2544,
-  2546,  2549,  2551,  2552,  2555,  2560,  2561,  2578,  2585,  2591,
-  2595,  2598,  2599,  2602,  2610,  2616,  2625,  2635,  2642,  2646,
-  2651,  2660,  2667,  2671,  2681,  2683,  2684,  2686,  2688,  2689,
-  2690,  2691,  2693,  2695,  2698,  2706,  2713,  2713,  2720,  2726,
-  2728,  2734,  2739,  2744,  2753,  2755,  2761,  2763,  2766,  2768,
-  2769,  2770,  2773,  2779,  2781,  2785,  2788,  2795,  2801,  2806,
-  2813,  2818,  2823,  2828,  2835,  2839,  2842,  2848,  2850,  2851,
-  2852,  2855,  2857,  2858,  2859,  2860,  2861,  2862,  2863,  2864,
-  2865,  2866,  2867,  2868,  2869,  2870,  2871,  2872,  2873,  2874,
-  2875,  2875,  2878,  2884,  2889,  2894,  2900,  2902,  2905,  2907,
-  2914,  2926,  2931,  2937,  2939,  2945,  2949,  2950,  2956,  2958,
-  2961,  2963,  2969,  2974,  2980,  2987,  2996
+   244,   249,   263,   265,   265,   266,   268,   270,   271,   272,
+   280,   284,   295,   300,   305,   307,   309,   310,   311,   316,
+   323,   325,   330,   335,   341,   343,   348,   353,   359,   361,
+   366,   373,   375,   376,   377,   380,   382,   384,   386,   388,
+   390,   392,   396,   400,   403,   406,   409,   413,   415,   418,
+   421,   425,   453,   459,   462,   465,   468,   470,   474,   478,
+   482,   484,   487,   491,   518,   520,   522,   524,   526,   528,
+   530,   532,   534,   536,   538,   540,   542,   544,   548,   550,
+   554,   556,   559,   563,   565,   572,   575,   583,   594,   754,
+   755,   757,   763,   765,   779,   802,   804,   806,   818,   832,
+   834,   836,   838,   840,   842,   844,   849,   851,   857,   859,
+   863,   865,   866,   876,   881,   883,   884,   885,   892,   898,
+   903,   906,   914,   919,   921,   922,   923,   930,   941,   945,
+   951,   956,   961,   966,   968,   970,   979,   982,   986,   988,
+   990,   995,   999,  1002,  1006,  1009,  1011,  1023,  1026,  1028,
+  1030,  1034,  1038,  1040,  1043,  1056,  1059,  1063,  1065,  1073,
+  1074,  1075,  1079,  1081,  1086,  1088,  1090,  1096,  1097,  1098,
+  1101,  1103,  1106,  1108,  1111,  1114,  1120,  1127,  1129,  1136,
+  1143,  1146,  1153,  1156,  1160,  1163,  1167,  1172,  1175,  1179,
+  1182,  1184,  1186,  1188,  1195,  1197,  1198,  1199,  1204,  1206,
+  1211,  1219,  1224,  1228,  1231,  1233,  1238,  1240,  1241,  1244,
+  1244,  1247,  1250,  1252,  1254,  1257,  1259,  1262,  1270,  1281,
+  1289,  1293,  1304,  1312,  1319,  1321,  1326,  1329,  1334,  1336,
+  1338,  1345,  1347,  1348,  1356,  1362,  1364,  1366,  1373,  1375,
+  1381,  1387,  1389,  1391,  1393,  1400,  1402,  1405,  1408,  1412,
+  1415,  1419,  1422,  1426,  1431,  1433,  1437,  1439,  1441,  1443,
+  1447,  1449,  1452,  1455,  1458,  1461,  1465,  1467,  1470,  1472,
+  1477,  1480,  1485,  1487,  1489,  1493,  1517,  1524,  1529,  1535,
+  1540,  1542,  1547,  1549,  1553,  1557,  1561,  1571,  1573,  1578,
+  1583,  1586,  1590,  1593,  1597,  1600,  1603,  1606,  1610,  1613,
+  1617,  1621,  1623,  1625,  1627,  1629,  1631,  1633,  1635,  1639,
+  1647,  1655,  1657,  1659,  1663,  1665,  1668,  1671,  1684,  1686,
+  1691,  1693,  1696,  1710,  1713,  1716,  1718,  1720,  1728,  1736,
+  1747,  1752,  1755,  1769,  1778,  1782,  1786,  1790,  1796,  1800,
+  1805,  1808,  1813,  1816,  1817,  1834,  1839,  1842,  1854,  1856,
+  1866,  1876,  1877,  1885,  1888,  1900,  1904,  1921,  1931,  1940,
+  1945,  1950,  1955,  1959,  1963,  1974,  1981,  1988,  1995,  2006,
+  2012,  2015,  2020,  2043,  2077,  2108,  2139,  2154,  2168,  2172,
+  2176,  2179,  2184,  2186,  2189,  2191,  2195,  2200,  2203,  2209,
+  2214,  2219,  2221,  2230,  2231,  2237,  2239,  2249,  2251,  2255,
+  2258,  2264,  2274,  2283,  2292,  2302,  2316,  2321,  2326,  2328,
+  2337,  2340,  2345,  2348,  2352,  2361,  2363,  2364,  2365,  2366,
+  2367,  2381,  2384,  2388,  2394,  2400,  2407,  2412,  2418,  2425,
+  2431,  2437,  2442,  2448,  2455,  2461,  2467,  2473,  2481,  2487,
+  2493,  2501,  2508,  2514,  2523,  2530,  2538,  2543,  2546,  2556,
+  2558,  2561,  2563,  2564,  2567,  2572,  2573,  2590,  2597,  2603,
+  2607,  2610,  2611,  2614,  2622,  2628,  2637,  2647,  2654,  2658,
+  2663,  2672,  2679,  2683,  2693,  2695,  2696,  2698,  2700,  2701,
+  2702,  2703,  2705,  2707,  2710,  2718,  2725,  2725,  2732,  2738,
+  2740,  2746,  2751,  2756,  2765,  2767,  2773,  2775,  2778,  2780,
+  2781,  2782,  2785,  2791,  2793,  2797,  2800,  2807,  2813,  2818,
+  2825,  2830,  2835,  2840,  2847,  2851,  2854,  2860,  2862,  2863,
+  2864,  2867,  2869,  2870,  2871,  2872,  2873,  2874,  2875,  2876,
+  2877,  2878,  2879,  2880,  2881,  2882,  2883,  2884,  2885,  2886,
+  2887,  2887,  2890,  2896,  2901,  2906,  2912,  2914,  2917,  2919,
+  2926,  2938,  2943,  2949,  2951,  2957,  2961,  2962,  2968,  2970,
+  2973,  2975,  2981,  2986,  2992,  2999,  3008
 };
 #endif
 
@@ -1675,6 +1685,7 @@ static const short yycheck[] = {    56,
 };
 /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
 #line 3 "/usr/lib/bison.simple"
+/* This file comes from bison-1.28.  */
 
 /* Skeleton output parser for bison,
    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
@@ -1691,46 +1702,66 @@ static const short yycheck[] = {    56,
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
 
 /* As a special exception, when this file is copied by Bison into a
    Bison output file, you may use that output file without restriction.
    This special exception was added by the Free Software Foundation
    in version 1.24 of Bison.  */
 
-#ifndef alloca
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+#ifndef YYSTACK_USE_ALLOCA
+#ifdef alloca
+#define YYSTACK_USE_ALLOCA
+#else /* alloca not defined */
 #ifdef __GNUC__
+#define YYSTACK_USE_ALLOCA
 #define alloca __builtin_alloca
 #else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+#define YYSTACK_USE_ALLOCA
 #include <alloca.h>
 #else /* not sparc */
-#if defined (MSDOS) && !defined (__TURBOC__)
+/* We think this test detects Watcom and Microsoft C.  */
+/* This used to test MSDOS, but that is a bad idea
+   since that symbol is in the user namespace.  */
+#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+#if 0 /* No need for malloc.h, which pollutes the namespace;
+	 instead, just don't use alloca.  */
 #include <malloc.h>
+#endif
 #else /* not MSDOS, or __TURBOC__ */
 #if defined(_AIX)
-#include <malloc.h>
+/* I don't know what this was needed for, but it pollutes the namespace.
+   So I turned it off.   rms, 2 May 1997.  */
+/* #include <malloc.h>  */
  #pragma alloca
-#else /* not MSDOS, __TURBOC__, or _AIX */
-#ifdef __hpux
-#ifdef __cplusplus
-extern "C" {
-void *alloca (unsigned int);
-};
-#else /* not __cplusplus */
-void *alloca ();
-#endif /* not __cplusplus */
+#define YYSTACK_USE_ALLOCA
+#else /* not MSDOS, or __TURBOC__, or _AIX */
+#if 0
+#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+		 and on HPUX 10.  Eventually we can turn this on.  */
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
 #endif /* __hpux */
+#endif
 #endif /* not _AIX */
 #endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc.  */
-#endif /* not GNU C.  */
-#endif /* alloca not defined.  */
+#endif /* not sparc */
+#endif /* not GNU C */
+#endif /* alloca not defined */
+#endif /* YYSTACK_USE_ALLOCA not defined */
 
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
+#ifdef YYSTACK_USE_ALLOCA
+#define YYSTACK_ALLOC alloca
+#else
+#define YYSTACK_ALLOC malloc
+#endif
 
 /* Note: there must be only one dollar sign in this file.
    It is replaced by the list of actions, each action
@@ -1740,8 +1771,8 @@ void *alloca ();
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		-2
 #define YYEOF		0
-#define YYACCEPT	return(0)
-#define YYABORT 	return(1)
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
 #define YYERROR		goto yyerrlab1
 /* Like YYERROR except do call yyerror.
    This remains here temporarily to ease the
@@ -1822,12 +1853,12 @@ int yydebug;			/*  nonzero means print parse trace	*/
 #ifndef YYMAXDEPTH
 #define YYMAXDEPTH 10000
 #endif
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-int yyparse (void);
-#endif
 
+/* Define __yy_memcpy.  Note that the size argument
+   should be passed with type unsigned int, because that is what the non-GCC
+   definitions require.  With GCC, __builtin_memcpy takes an arg
+   of type size_t, but it can handle unsigned int.  */
+
 #if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
 #define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
 #else				/* not GNU C or C++ */
@@ -1839,7 +1870,7 @@ static void
 __yy_memcpy (to, from, count)
      char *to;
      char *from;
-     int count;
+     unsigned int count;
 {
   register char *f = from;
   register char *t = to;
@@ -1854,10 +1885,10 @@ __yy_memcpy (to, from, count)
 /* This is the most reliable way to avoid incompatibilities
    in available built-in functions on various systems.  */
 static void
-__yy_memcpy (char *to, char *from, int count)
+__yy_memcpy (char *to, char *from, unsigned int count)
 {
-  register char *f = from;
   register char *t = to;
+  register char *f = from;
   register int i = count;
 
   while (i-- > 0)
@@ -1867,7 +1898,7 @@ __yy_memcpy (char *to, char *from, int count)
 #endif
 #endif
 
-#line 196 "/usr/lib/bison.simple"
+#line 217 "/usr/lib/bison.simple"
 
 /* The user can define YYPARSE_PARAM as the name of an argument to be passed
    into yyparse.  The argument should have type void *.
@@ -1888,6 +1919,15 @@ __yy_memcpy (char *to, char *from, int count)
 #define YYPARSE_PARAM_DECL
 #endif /* not YYPARSE_PARAM */
 
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+#ifdef YYPARSE_PARAM
+int yyparse (void *);
+#else
+int yyparse (void);
+#endif
+#endif
+
 int
 yyparse(YYPARSE_PARAM_ARG)
      YYPARSE_PARAM_DECL
@@ -1916,6 +1956,7 @@ yyparse(YYPARSE_PARAM_ARG)
 #endif
 
   int yystacksize = YYINITDEPTH;
+  int yyfree_stacks = 0;
 
 #ifdef YYPURE
   int yychar;
@@ -2000,18 +2041,32 @@ yynewstate:
       if (yystacksize >= YYMAXDEPTH)
 	{
 	  yyerror("parser stack overflow");
+	  if (yyfree_stacks)
+	    {
+	      free (yyss);
+	      free (yyvs);
+#ifdef YYLSP_NEEDED
+	      free (yyls);
+#endif
+	    }
 	  return 2;
 	}
       yystacksize *= 2;
       if (yystacksize > YYMAXDEPTH)
 	yystacksize = YYMAXDEPTH;
-      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
-      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
+#ifndef YYSTACK_USE_ALLOCA
+      yyfree_stacks = 1;
+#endif
+      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1,
+		   size * (unsigned int) sizeof (*yyssp));
+      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
+		   size * (unsigned int) sizeof (*yyvsp));
 #ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
+      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1,
+		   size * (unsigned int) sizeof (*yylsp));
 #endif
 #endif /* no yyoverflow */
 
@@ -2172,14 +2227,14 @@ yyreduce:
   switch (yyn) {
 
 case 1:
-#line 234 "objc-parse.y"
+#line 245 "objc-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids an empty source file");
 		  finish_file ();
 		;
     break;}
 case 2:
-#line 239 "objc-parse.y"
+#line 250 "objc-parse.y"
 {
 		  /* In case there were missing closebraces,
 		     get us back to the global binding level.  */
@@ -2189,15 +2244,15 @@ case 2:
 		;
     break;}
 case 3:
-#line 253 "objc-parse.y"
+#line 264 "objc-parse.y"
 {yyval.ttype = NULL_TREE; ;
     break;}
 case 5:
-#line 254 "objc-parse.y"
+#line 265 "objc-parse.y"
 {yyval.ttype = NULL_TREE; ;
     break;}
 case 10:
-#line 262 "objc-parse.y"
+#line 273 "objc-parse.y"
 { STRIP_NOPS (yyvsp[-2].ttype);
 		  if ((TREE_CODE (yyvsp[-2].ttype) == ADDR_EXPR
 		       && TREE_CODE (TREE_OPERAND (yyvsp[-2].ttype, 0)) == STRING_CST)
@@ -2207,11 +2262,11 @@ case 10:
 		    error ("argument of `asm' is not a constant string"); ;
     break;}
 case 11:
-#line 270 "objc-parse.y"
-{ pedantic = yyvsp[-1].itype; ;
+#line 281 "objc-parse.y"
+{ RESTORE_WARN_FLAGS (yyvsp[-1].ttype); ;
     break;}
 case 12:
-#line 275 "objc-parse.y"
+#line 286 "objc-parse.y"
 { if (pedantic)
 		    error ("ANSI C forbids data definition with no type or storage class");
 		  else if (!flag_traditional)
@@ -2223,45 +2278,45 @@ case 12:
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 13:
-#line 285 "objc-parse.y"
+#line 296 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 14:
-#line 290 "objc-parse.y"
+#line 301 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype);  ;
     break;}
 case 15:
-#line 295 "objc-parse.y"
+#line 306 "objc-parse.y"
 { pedwarn ("empty declaration"); ;
     break;}
 case 16:
-#line 297 "objc-parse.y"
+#line 308 "objc-parse.y"
 { shadow_tag (yyvsp[-1].ttype); ;
     break;}
 case 19:
-#line 301 "objc-parse.y"
+#line 312 "objc-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C does not allow extra `;' outside of a function"); ;
     break;}
 case 20:
-#line 307 "objc-parse.y"
+#line 318 "objc-parse.y"
 { if (! start_function (current_declspecs, yyvsp[0].ttype,
 					prefix_attributes, NULL_TREE, 0))
 		    YYERROR1;
 		  reinit_parse_for_function (); ;
     break;}
 case 21:
-#line 312 "objc-parse.y"
+#line 323 "objc-parse.y"
 { store_parm_decls (); ;
     break;}
 case 22:
-#line 314 "objc-parse.y"
+#line 325 "objc-parse.y"
 { finish_function (0); 
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -2269,25 +2324,25 @@ case 22:
 		  resume_momentary (yyvsp[-5].itype); ;
     break;}
 case 23:
-#line 320 "objc-parse.y"
+#line 331 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 24:
-#line 325 "objc-parse.y"
+#line 336 "objc-parse.y"
 { if (! start_function (current_declspecs, yyvsp[0].ttype,
 					prefix_attributes, NULL_TREE, 0))
 		    YYERROR1;
 		  reinit_parse_for_function (); ;
     break;}
 case 25:
-#line 330 "objc-parse.y"
+#line 341 "objc-parse.y"
 { store_parm_decls (); ;
     break;}
 case 26:
-#line 332 "objc-parse.y"
+#line 343 "objc-parse.y"
 { finish_function (0); 
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -2295,25 +2350,25 @@ case 26:
 		  resume_momentary (yyvsp[-5].itype); ;
     break;}
 case 27:
-#line 338 "objc-parse.y"
+#line 349 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 28:
-#line 343 "objc-parse.y"
+#line 354 "objc-parse.y"
 { if (! start_function (NULL_TREE, yyvsp[0].ttype,
 					prefix_attributes, NULL_TREE, 0))
 		    YYERROR1;
 		  reinit_parse_for_function (); ;
     break;}
 case 29:
-#line 348 "objc-parse.y"
+#line 359 "objc-parse.y"
 { store_parm_decls (); ;
     break;}
 case 30:
-#line 350 "objc-parse.y"
+#line 361 "objc-parse.y"
 { finish_function (0); 
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -2321,72 +2376,72 @@ case 30:
 		  resume_momentary (yyvsp[-5].itype); ;
     break;}
 case 31:
-#line 356 "objc-parse.y"
+#line 367 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 36:
-#line 370 "objc-parse.y"
+#line 381 "objc-parse.y"
 { yyval.code = ADDR_EXPR; ;
     break;}
 case 37:
-#line 372 "objc-parse.y"
+#line 383 "objc-parse.y"
 { yyval.code = NEGATE_EXPR; ;
     break;}
 case 38:
-#line 374 "objc-parse.y"
+#line 385 "objc-parse.y"
 { yyval.code = CONVERT_EXPR; ;
     break;}
 case 39:
-#line 376 "objc-parse.y"
+#line 387 "objc-parse.y"
 { yyval.code = PREINCREMENT_EXPR; ;
     break;}
 case 40:
-#line 378 "objc-parse.y"
+#line 389 "objc-parse.y"
 { yyval.code = PREDECREMENT_EXPR; ;
     break;}
 case 41:
-#line 380 "objc-parse.y"
+#line 391 "objc-parse.y"
 { yyval.code = BIT_NOT_EXPR; ;
     break;}
 case 42:
-#line 382 "objc-parse.y"
+#line 393 "objc-parse.y"
 { yyval.code = TRUTH_NOT_EXPR; ;
     break;}
 case 43:
-#line 386 "objc-parse.y"
+#line 397 "objc-parse.y"
 { yyval.ttype = build_compound_expr (yyvsp[0].ttype); ;
     break;}
 case 44:
-#line 391 "objc-parse.y"
+#line 402 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 46:
-#line 397 "objc-parse.y"
+#line 408 "objc-parse.y"
 { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;
     break;}
 case 47:
-#line 399 "objc-parse.y"
+#line 410 "objc-parse.y"
 { chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;
     break;}
 case 49:
-#line 405 "objc-parse.y"
+#line 416 "objc-parse.y"
 { yyval.ttype = build_indirect_ref (yyvsp[0].ttype, "unary *"); ;
     break;}
 case 50:
-#line 408 "objc-parse.y"
+#line 419 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
-		  pedantic = yyvsp[-1].itype; ;
+		  RESTORE_WARN_FLAGS (yyvsp[-1].ttype); ;
     break;}
 case 51:
-#line 411 "objc-parse.y"
+#line 422 "objc-parse.y"
 { yyval.ttype = build_unary_op (yyvsp[-1].code, yyvsp[0].ttype, 0);
 		  overflow_warning (yyval.ttype); ;
     break;}
 case 52:
-#line 415 "objc-parse.y"
+#line 426 "objc-parse.y"
 { tree label = lookup_label (yyvsp[0].ttype);
 		  if (pedantic)
 		    pedwarn ("ANSI C forbids `&&'");
@@ -2401,7 +2456,7 @@ case 52:
 		;
     break;}
 case 53:
-#line 443 "objc-parse.y"
+#line 454 "objc-parse.y"
 { skip_evaluation--;
 		  if (TREE_CODE (yyvsp[0].ttype) == COMPONENT_REF
 		      && DECL_C_BIT_FIELD (TREE_OPERAND (yyvsp[0].ttype, 1)))
@@ -2409,49 +2464,49 @@ case 53:
 		  yyval.ttype = c_sizeof (TREE_TYPE (yyvsp[0].ttype)); ;
     break;}
 case 54:
-#line 449 "objc-parse.y"
+#line 460 "objc-parse.y"
 { skip_evaluation--;
 		  yyval.ttype = c_sizeof (groktypename (yyvsp[-1].ttype)); ;
     break;}
 case 55:
-#line 452 "objc-parse.y"
+#line 463 "objc-parse.y"
 { skip_evaluation--;
 		  yyval.ttype = c_alignof_expr (yyvsp[0].ttype); ;
     break;}
 case 56:
-#line 455 "objc-parse.y"
+#line 466 "objc-parse.y"
 { skip_evaluation--;
 		  yyval.ttype = c_alignof (groktypename (yyvsp[-1].ttype)); ;
     break;}
 case 57:
-#line 458 "objc-parse.y"
+#line 469 "objc-parse.y"
 { yyval.ttype = build_unary_op (REALPART_EXPR, yyvsp[0].ttype, 0); ;
     break;}
 case 58:
-#line 460 "objc-parse.y"
+#line 471 "objc-parse.y"
 { yyval.ttype = build_unary_op (IMAGPART_EXPR, yyvsp[0].ttype, 0); ;
     break;}
 case 59:
-#line 464 "objc-parse.y"
+#line 475 "objc-parse.y"
 { skip_evaluation++; ;
     break;}
 case 60:
-#line 468 "objc-parse.y"
+#line 479 "objc-parse.y"
 { skip_evaluation++; ;
     break;}
 case 62:
-#line 474 "objc-parse.y"
+#line 485 "objc-parse.y"
 { tree type = groktypename (yyvsp[-2].ttype);
 		  yyval.ttype = build_c_cast (type, yyvsp[0].ttype); ;
     break;}
 case 63:
-#line 477 "objc-parse.y"
+#line 488 "objc-parse.y"
 { start_init (NULL_TREE, NULL, 0);
 		  yyvsp[-2].ttype = groktypename (yyvsp[-2].ttype);
 		  really_start_incremental_init (yyvsp[-2].ttype); ;
     break;}
 case 64:
-#line 481 "objc-parse.y"
+#line 492 "objc-parse.y"
 { char *name;
 		  tree result = pop_init_level (0);
 		  tree type = yyvsp[-5].ttype;
@@ -2478,90 +2533,90 @@ case 64:
 		;
     break;}
 case 66:
-#line 510 "objc-parse.y"
+#line 521 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 67:
-#line 512 "objc-parse.y"
+#line 523 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 68:
-#line 514 "objc-parse.y"
+#line 525 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 69:
-#line 516 "objc-parse.y"
+#line 527 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 70:
-#line 518 "objc-parse.y"
+#line 529 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 71:
-#line 520 "objc-parse.y"
+#line 531 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 72:
-#line 522 "objc-parse.y"
+#line 533 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 73:
-#line 524 "objc-parse.y"
+#line 535 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 74:
-#line 526 "objc-parse.y"
+#line 537 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 75:
-#line 528 "objc-parse.y"
+#line 539 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 76:
-#line 530 "objc-parse.y"
+#line 541 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 77:
-#line 532 "objc-parse.y"
+#line 543 "objc-parse.y"
 { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 78:
-#line 534 "objc-parse.y"
+#line 545 "objc-parse.y"
 { yyvsp[-1].ttype = truthvalue_conversion (default_conversion (yyvsp[-1].ttype));
 		  skip_evaluation += yyvsp[-1].ttype == boolean_false_node; ;
     break;}
 case 79:
-#line 537 "objc-parse.y"
+#line 548 "objc-parse.y"
 { skip_evaluation -= yyvsp[-3].ttype == boolean_false_node;
 		  yyval.ttype = parser_build_binary_op (TRUTH_ANDIF_EXPR, yyvsp[-3].ttype, yyvsp[0].ttype); ;
     break;}
 case 80:
-#line 540 "objc-parse.y"
+#line 551 "objc-parse.y"
 { yyvsp[-1].ttype = truthvalue_conversion (default_conversion (yyvsp[-1].ttype));
 		  skip_evaluation += yyvsp[-1].ttype == boolean_true_node; ;
     break;}
 case 81:
-#line 543 "objc-parse.y"
+#line 554 "objc-parse.y"
 { skip_evaluation -= yyvsp[-3].ttype == boolean_true_node;
 		  yyval.ttype = parser_build_binary_op (TRUTH_ORIF_EXPR, yyvsp[-3].ttype, yyvsp[0].ttype); ;
     break;}
 case 82:
-#line 546 "objc-parse.y"
+#line 557 "objc-parse.y"
 { yyvsp[-1].ttype = truthvalue_conversion (default_conversion (yyvsp[-1].ttype));
 		  skip_evaluation += yyvsp[-1].ttype == boolean_false_node; ;
     break;}
 case 83:
-#line 549 "objc-parse.y"
+#line 560 "objc-parse.y"
 { skip_evaluation += ((yyvsp[-4].ttype == boolean_true_node)
 				      - (yyvsp[-4].ttype == boolean_false_node)); ;
     break;}
 case 84:
-#line 552 "objc-parse.y"
+#line 563 "objc-parse.y"
 { skip_evaluation -= yyvsp[-6].ttype == boolean_true_node;
 		  yyval.ttype = build_conditional_expr (yyvsp[-6].ttype, yyvsp[-3].ttype, yyvsp[0].ttype); ;
     break;}
 case 85:
-#line 555 "objc-parse.y"
+#line 566 "objc-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids omitting the middle term of a ?: expression");
 		  /* Make sure first operand is calculated only once.  */
@@ -2570,12 +2625,12 @@ case 85:
 		  skip_evaluation += yyvsp[-1].ttype == boolean_true_node; ;
     break;}
 case 86:
-#line 562 "objc-parse.y"
+#line 573 "objc-parse.y"
 { skip_evaluation -= yyvsp[-4].ttype == boolean_true_node;
 		  yyval.ttype = build_conditional_expr (yyvsp[-4].ttype, yyvsp[-3].ttype, yyvsp[0].ttype); ;
     break;}
 case 87:
-#line 565 "objc-parse.y"
+#line 576 "objc-parse.y"
 { char class;
 		  yyval.ttype = build_modify_expr (yyvsp[-2].ttype, NOP_EXPR, yyvsp[0].ttype);
 		  class = TREE_CODE_CLASS (TREE_CODE (yyval.ttype));
@@ -2585,7 +2640,7 @@ case 87:
 		;
     break;}
 case 88:
-#line 573 "objc-parse.y"
+#line 584 "objc-parse.y"
 { char class;
 		  yyval.ttype = build_modify_expr (yyvsp[-2].ttype, yyvsp[-1].code, yyvsp[0].ttype);
 		  /* This inhibits warnings in truthvalue_conversion.  */
@@ -2596,7 +2651,7 @@ case 88:
 		;
     break;}
 case 89:
-#line 585 "objc-parse.y"
+#line 596 "objc-parse.y"
 {
 		  yyval.ttype = lastiddecl;
 		  if (!yyval.ttype || yyval.ttype == error_mark_node)
@@ -2757,11 +2812,11 @@ case 89:
 		;
     break;}
 case 91:
-#line 745 "objc-parse.y"
+#line 756 "objc-parse.y"
 { yyval.ttype = combine_strings (yyvsp[0].ttype); ;
     break;}
 case 92:
-#line 747 "objc-parse.y"
+#line 758 "objc-parse.y"
 { char class = TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype));
 		  if (class == 'e' || class == '1'
 		      || class == '2' || class == '<')
@@ -2769,11 +2824,11 @@ case 92:
 		  yyval.ttype = yyvsp[-1].ttype; ;
     break;}
 case 93:
-#line 753 "objc-parse.y"
+#line 764 "objc-parse.y"
 { yyval.ttype = error_mark_node; ;
     break;}
 case 94:
-#line 755 "objc-parse.y"
+#line 766 "objc-parse.y"
 { if (current_function_decl == 0)
 		    {
 		      error ("braced-group within expression allowed only inside a function");
@@ -2789,7 +2844,7 @@ case 94:
 		  yyval.ttype = expand_start_stmt_expr (); ;
     break;}
 case 95:
-#line 769 "objc-parse.y"
+#line 780 "objc-parse.y"
 { tree rtl_exp;
 		  if (pedantic)
 		    pedwarn ("ANSI C forbids braced-groups within expressions");
@@ -2814,15 +2869,15 @@ case 95:
 		;
     break;}
 case 96:
-#line 792 "objc-parse.y"
+#line 803 "objc-parse.y"
 { yyval.ttype = build_function_call (yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 97:
-#line 794 "objc-parse.y"
+#line 805 "objc-parse.y"
 { yyval.ttype = build_array_ref (yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 98:
-#line 796 "objc-parse.y"
+#line 807 "objc-parse.y"
 {
                   if (doing_objc_thang)
                     {
@@ -2836,7 +2891,7 @@ case 98:
 		;
     break;}
 case 99:
-#line 808 "objc-parse.y"
+#line 819 "objc-parse.y"
 {
                   tree expr = build_indirect_ref (yyvsp[-2].ttype, "->");
 
@@ -2852,80 +2907,80 @@ case 99:
 		;
     break;}
 case 100:
-#line 822 "objc-parse.y"
+#line 833 "objc-parse.y"
 { yyval.ttype = build_unary_op (POSTINCREMENT_EXPR, yyvsp[-1].ttype, 0); ;
     break;}
 case 101:
-#line 824 "objc-parse.y"
+#line 835 "objc-parse.y"
 { yyval.ttype = build_unary_op (POSTDECREMENT_EXPR, yyvsp[-1].ttype, 0); ;
     break;}
 case 102:
-#line 826 "objc-parse.y"
+#line 837 "objc-parse.y"
 { yyval.ttype = build_message_expr (yyvsp[0].ttype); ;
     break;}
 case 103:
-#line 828 "objc-parse.y"
+#line 839 "objc-parse.y"
 { yyval.ttype = build_selector_expr (yyvsp[0].ttype); ;
     break;}
 case 104:
-#line 830 "objc-parse.y"
+#line 841 "objc-parse.y"
 { yyval.ttype = build_protocol_expr (yyvsp[0].ttype); ;
     break;}
 case 105:
-#line 832 "objc-parse.y"
+#line 843 "objc-parse.y"
 { yyval.ttype = build_encode_expr (yyvsp[0].ttype); ;
     break;}
 case 106:
-#line 834 "objc-parse.y"
+#line 845 "objc-parse.y"
 { yyval.ttype = build_objc_string_object (yyvsp[0].ttype); ;
     break;}
 case 108:
-#line 841 "objc-parse.y"
+#line 852 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 110:
-#line 849 "objc-parse.y"
+#line 860 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 113:
-#line 857 "objc-parse.y"
+#line 868 "objc-parse.y"
 { c_mark_varargs ();
 		  if (pedantic)
 		    pedwarn ("ANSI C does not permit use of `varargs.h'"); ;
     break;}
 case 114:
-#line 867 "objc-parse.y"
+#line 878 "objc-parse.y"
 { ;
     break;}
 case 119:
-#line 883 "objc-parse.y"
+#line 894 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 120:
-#line 888 "objc-parse.y"
+#line 899 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);	
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 121:
-#line 893 "objc-parse.y"
+#line 904 "objc-parse.y"
 { shadow_tag_warned (yyvsp[-1].ttype, 1);
 		  pedwarn ("empty declaration"); ;
     break;}
 case 122:
-#line 896 "objc-parse.y"
+#line 907 "objc-parse.y"
 { pedwarn ("empty declaration"); ;
     break;}
 case 123:
-#line 905 "objc-parse.y"
+#line 916 "objc-parse.y"
 { ;
     break;}
 case 128:
-#line 920 "objc-parse.y"
+#line 931 "objc-parse.y"
 { yyval.itype = suspend_momentary ();
 		  pending_xref_error ();
 		  declspec_stack = tree_cons (prefix_attributes,
@@ -2935,131 +2990,131 @@ case 128:
 				     &current_declspecs, &prefix_attributes); ;
     break;}
 case 129:
-#line 931 "objc-parse.y"
+#line 942 "objc-parse.y"
 { prefix_attributes = chainon (prefix_attributes, yyvsp[0].ttype); ;
     break;}
 case 130:
-#line 936 "objc-parse.y"
+#line 947 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 131:
-#line 941 "objc-parse.y"
+#line 952 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 132:
-#line 946 "objc-parse.y"
+#line 957 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-1].itype); ;
     break;}
 case 133:
-#line 951 "objc-parse.y"
+#line 962 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-1].itype); ;
     break;}
 case 134:
-#line 956 "objc-parse.y"
+#line 967 "objc-parse.y"
 { shadow_tag (yyvsp[-1].ttype); ;
     break;}
 case 135:
-#line 958 "objc-parse.y"
+#line 969 "objc-parse.y"
 { pedwarn ("empty declaration"); ;
     break;}
 case 136:
-#line 960 "objc-parse.y"
-{ pedantic = yyvsp[-1].itype; ;
+#line 971 "objc-parse.y"
+{ RESTORE_WARN_FLAGS (yyvsp[-1].ttype); ;
     break;}
 case 137:
-#line 970 "objc-parse.y"
+#line 981 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 138:
-#line 972 "objc-parse.y"
+#line 983 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[0].ttype, tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[-2].ttype)); ;
     break;}
 case 139:
-#line 976 "objc-parse.y"
+#line 987 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 140:
-#line 978 "objc-parse.y"
+#line 989 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 141:
-#line 980 "objc-parse.y"
+#line 991 "objc-parse.y"
 { if (extra_warnings)
 		    warning ("`%s' is not at beginning of declaration",
 			     IDENTIFIER_POINTER (yyvsp[0].ttype));
 		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 142:
-#line 985 "objc-parse.y"
+#line 996 "objc-parse.y"
 { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype); ;
     break;}
 case 143:
-#line 990 "objc-parse.y"
+#line 1001 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 144:
-#line 992 "objc-parse.y"
+#line 1003 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[0].ttype, tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[-2].ttype)); ;
     break;}
 case 145:
-#line 997 "objc-parse.y"
+#line 1008 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 146:
-#line 999 "objc-parse.y"
+#line 1010 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 147:
-#line 1001 "objc-parse.y"
+#line 1012 "objc-parse.y"
 { if (extra_warnings)
 		    warning ("`%s' is not at beginning of declaration",
 			     IDENTIFIER_POINTER (yyvsp[0].ttype));
 		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 148:
-#line 1014 "objc-parse.y"
+#line 1025 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 149:
-#line 1016 "objc-parse.y"
+#line 1027 "objc-parse.y"
 { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, NULL_TREE); ;
     break;}
 case 150:
-#line 1018 "objc-parse.y"
+#line 1029 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 151:
-#line 1020 "objc-parse.y"
+#line 1031 "objc-parse.y"
 { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype); ;
     break;}
 case 152:
-#line 1025 "objc-parse.y"
+#line 1036 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE);
 		  TREE_STATIC (yyval.ttype) = 1; ;
     break;}
 case 153:
-#line 1028 "objc-parse.y"
+#line 1039 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 154:
-#line 1030 "objc-parse.y"
+#line 1041 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
 		  TREE_STATIC (yyval.ttype) = 1; ;
     break;}
 case 155:
-#line 1033 "objc-parse.y"
+#line 1044 "objc-parse.y"
 { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
 		    warning ("`%s' is not at beginning of declaration",
 			     IDENTIFIER_POINTER (yyvsp[0].ttype));
@@ -3067,150 +3122,150 @@ case 155:
 		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;
     break;}
 case 156:
-#line 1047 "objc-parse.y"
+#line 1058 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 157:
-#line 1049 "objc-parse.y"
+#line 1060 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[0].ttype, tree_cons (NULL_TREE, yyvsp[-1].ttype, yyvsp[-2].ttype)); ;
     break;}
 case 158:
-#line 1053 "objc-parse.y"
+#line 1064 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 159:
-#line 1055 "objc-parse.y"
+#line 1066 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 162:
-#line 1065 "objc-parse.y"
+#line 1076 "objc-parse.y"
 { /* For a typedef name, record the meaning, not the name.
 		     In case of `foo foo, bar;'.  */
 		  yyval.ttype = lookup_name (yyvsp[0].ttype); ;
     break;}
 case 163:
-#line 1069 "objc-parse.y"
+#line 1080 "objc-parse.y"
 { yyval.ttype = get_static_reference (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 164:
-#line 1071 "objc-parse.y"
+#line 1082 "objc-parse.y"
 { yyval.ttype = get_object_reference (yyvsp[0].ttype); ;
     break;}
 case 165:
-#line 1076 "objc-parse.y"
+#line 1087 "objc-parse.y"
 { yyval.ttype = get_object_reference (yyvsp[0].ttype); ;
     break;}
 case 166:
-#line 1078 "objc-parse.y"
+#line 1089 "objc-parse.y"
 { yyval.ttype = TREE_TYPE (yyvsp[-1].ttype); ;
     break;}
 case 167:
-#line 1080 "objc-parse.y"
+#line 1091 "objc-parse.y"
 { yyval.ttype = groktypename (yyvsp[-1].ttype); ;
     break;}
 case 175:
-#line 1102 "objc-parse.y"
+#line 1113 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 176:
-#line 1104 "objc-parse.y"
+#line 1115 "objc-parse.y"
 { if (TREE_CHAIN (yyvsp[-1].ttype)) yyvsp[-1].ttype = combine_strings (yyvsp[-1].ttype);
 		  yyval.ttype = yyvsp[-1].ttype;
 		;
     break;}
 case 177:
-#line 1111 "objc-parse.y"
+#line 1122 "objc-parse.y"
 { yyval.ttype = start_decl (yyvsp[-3].ttype, current_declspecs, 1,
 					  yyvsp[-1].ttype, prefix_attributes);
 		  start_init (yyval.ttype, yyvsp[-2].ttype, global_bindings_p ()); ;
     break;}
 case 178:
-#line 1116 "objc-parse.y"
+#line 1127 "objc-parse.y"
 { finish_init ();
 		  finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-4].ttype); ;
     break;}
 case 179:
-#line 1119 "objc-parse.y"
+#line 1130 "objc-parse.y"
 { tree d = start_decl (yyvsp[-2].ttype, current_declspecs, 0,
 				       yyvsp[0].ttype, prefix_attributes);
 		  finish_decl (d, NULL_TREE, yyvsp[-1].ttype); 
                 ;
     break;}
 case 180:
-#line 1127 "objc-parse.y"
+#line 1138 "objc-parse.y"
 { yyval.ttype = start_decl (yyvsp[-3].ttype, current_declspecs, 1,
 					  yyvsp[-1].ttype, prefix_attributes);
 		  start_init (yyval.ttype, yyvsp[-2].ttype, global_bindings_p ()); ;
     break;}
 case 181:
-#line 1132 "objc-parse.y"
+#line 1143 "objc-parse.y"
 { finish_init ();
 		  decl_attributes (yyvsp[-1].ttype, yyvsp[-3].ttype, prefix_attributes);
 		  finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-4].ttype); ;
     break;}
 case 182:
-#line 1136 "objc-parse.y"
+#line 1147 "objc-parse.y"
 { tree d = start_decl (yyvsp[-2].ttype, current_declspecs, 0,
 				       yyvsp[0].ttype, prefix_attributes);
 		  finish_decl (d, NULL_TREE, yyvsp[-1].ttype); ;
     break;}
 case 183:
-#line 1144 "objc-parse.y"
+#line 1155 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 184:
-#line 1146 "objc-parse.y"
+#line 1157 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 185:
-#line 1151 "objc-parse.y"
+#line 1162 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 186:
-#line 1153 "objc-parse.y"
+#line 1164 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 187:
-#line 1158 "objc-parse.y"
+#line 1169 "objc-parse.y"
 { yyval.ttype = yyvsp[-2].ttype; ;
     break;}
 case 188:
-#line 1163 "objc-parse.y"
+#line 1174 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 189:
-#line 1165 "objc-parse.y"
+#line 1176 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 190:
-#line 1170 "objc-parse.y"
+#line 1181 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 191:
-#line 1172 "objc-parse.y"
+#line 1183 "objc-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 192:
-#line 1174 "objc-parse.y"
+#line 1185 "objc-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-3].ttype, build_tree_list (NULL_TREE, yyvsp[-1].ttype)); ;
     break;}
 case 193:
-#line 1176 "objc-parse.y"
+#line 1187 "objc-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-5].ttype, tree_cons (NULL_TREE, yyvsp[-3].ttype, yyvsp[-1].ttype)); ;
     break;}
 case 194:
-#line 1178 "objc-parse.y"
+#line 1189 "objc-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 200:
-#line 1196 "objc-parse.y"
+#line 1207 "objc-parse.y"
 { really_start_incremental_init (NULL_TREE);
 		  /* Note that the call to clear_momentary
 		     is in process_init_element.  */
 		  push_momentary (); ;
     break;}
 case 201:
-#line 1201 "objc-parse.y"
+#line 1212 "objc-parse.y"
 { yyval.ttype = pop_init_level (0);
 		  if (yyval.ttype == error_mark_node
 		      && ! (yychar == STRING || yychar == CONSTANT))
@@ -3219,36 +3274,36 @@ case 201:
 		    pop_momentary_nofree (); ;
     break;}
 case 202:
-#line 1209 "objc-parse.y"
+#line 1220 "objc-parse.y"
 { yyval.ttype = error_mark_node; ;
     break;}
 case 203:
-#line 1215 "objc-parse.y"
+#line 1226 "objc-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids empty initializer braces"); ;
     break;}
 case 209:
-#line 1231 "objc-parse.y"
+#line 1242 "objc-parse.y"
 { set_init_label (yyvsp[-1].ttype); ;
     break;}
 case 212:
-#line 1238 "objc-parse.y"
+#line 1249 "objc-parse.y"
 { push_init_level (0); ;
     break;}
 case 213:
-#line 1240 "objc-parse.y"
+#line 1251 "objc-parse.y"
 { process_init_element (pop_init_level (0)); ;
     break;}
 case 214:
-#line 1242 "objc-parse.y"
+#line 1253 "objc-parse.y"
 { process_init_element (yyvsp[0].ttype); ;
     break;}
 case 218:
-#line 1253 "objc-parse.y"
+#line 1264 "objc-parse.y"
 { set_init_label (yyvsp[0].ttype); ;
     break;}
 case 219:
-#line 1261 "objc-parse.y"
+#line 1272 "objc-parse.y"
 { push_c_function_context ();
 		  if (! start_function (current_declspecs, yyvsp[0].ttype,
 					prefix_attributes, NULL_TREE, 1))
@@ -3259,16 +3314,16 @@ case 219:
 		  reinit_parse_for_function (); ;
     break;}
 case 220:
-#line 1270 "objc-parse.y"
+#line 1281 "objc-parse.y"
 { store_parm_decls (); ;
     break;}
 case 221:
-#line 1278 "objc-parse.y"
+#line 1289 "objc-parse.y"
 { finish_function (1);
 		  pop_c_function_context (); ;
     break;}
 case 222:
-#line 1284 "objc-parse.y"
+#line 1295 "objc-parse.y"
 { push_c_function_context ();
 		  if (! start_function (current_declspecs, yyvsp[0].ttype,
 					prefix_attributes, NULL_TREE, 1))
@@ -3279,197 +3334,197 @@ case 222:
 		  reinit_parse_for_function (); ;
     break;}
 case 223:
-#line 1293 "objc-parse.y"
+#line 1304 "objc-parse.y"
 { store_parm_decls (); ;
     break;}
 case 224:
-#line 1301 "objc-parse.y"
+#line 1312 "objc-parse.y"
 { finish_function (1);
 		  pop_c_function_context (); ;
     break;}
 case 227:
-#line 1317 "objc-parse.y"
+#line 1328 "objc-parse.y"
 { yyval.ttype = yyvsp[-1].ttype; ;
     break;}
 case 228:
-#line 1319 "objc-parse.y"
+#line 1330 "objc-parse.y"
 { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 229:
-#line 1324 "objc-parse.y"
+#line 1335 "objc-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 230:
-#line 1326 "objc-parse.y"
+#line 1337 "objc-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-2].ttype, NULL_TREE); ;
     break;}
 case 231:
-#line 1328 "objc-parse.y"
+#line 1339 "objc-parse.y"
 { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 232:
-#line 1335 "objc-parse.y"
+#line 1346 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 235:
-#line 1347 "objc-parse.y"
+#line 1358 "objc-parse.y"
 { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 236:
-#line 1352 "objc-parse.y"
+#line 1363 "objc-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 237:
-#line 1354 "objc-parse.y"
+#line 1365 "objc-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-2].ttype, NULL_TREE); ;
     break;}
 case 238:
-#line 1356 "objc-parse.y"
+#line 1367 "objc-parse.y"
 { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 239:
-#line 1363 "objc-parse.y"
+#line 1374 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 241:
-#line 1372 "objc-parse.y"
+#line 1383 "objc-parse.y"
 { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 242:
-#line 1377 "objc-parse.y"
+#line 1388 "objc-parse.y"
 { yyval.ttype = yyvsp[-1].ttype; ;
     break;}
 case 243:
-#line 1379 "objc-parse.y"
+#line 1390 "objc-parse.y"
 { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 244:
-#line 1381 "objc-parse.y"
+#line 1392 "objc-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 245:
-#line 1383 "objc-parse.y"
+#line 1394 "objc-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-2].ttype, NULL_TREE); ;
     break;}
 case 246:
-#line 1390 "objc-parse.y"
+#line 1401 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 248:
-#line 1396 "objc-parse.y"
+#line 1407 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 249:
-#line 1398 "objc-parse.y"
+#line 1409 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 250:
-#line 1403 "objc-parse.y"
+#line 1414 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 251:
-#line 1405 "objc-parse.y"
+#line 1416 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 252:
-#line 1410 "objc-parse.y"
+#line 1421 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 253:
-#line 1412 "objc-parse.y"
+#line 1423 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 254:
-#line 1417 "objc-parse.y"
+#line 1428 "objc-parse.y"
 { yyval.ttype = start_struct (RECORD_TYPE, yyvsp[-1].ttype);
 		  /* Start scope of tag before parsing components.  */
 		;
     break;}
 case 255:
-#line 1421 "objc-parse.y"
+#line 1432 "objc-parse.y"
 { yyval.ttype = finish_struct (yyvsp[-3].ttype, yyvsp[-2].ttype, chainon (yyvsp[-6].ttype, yyvsp[0].ttype)); ;
     break;}
 case 256:
-#line 1423 "objc-parse.y"
+#line 1434 "objc-parse.y"
 { yyval.ttype = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),
 				      yyvsp[-2].ttype, chainon (yyvsp[-4].ttype, yyvsp[0].ttype));
 		;
     break;}
 case 257:
-#line 1427 "objc-parse.y"
+#line 1438 "objc-parse.y"
 { yyval.ttype = xref_tag (RECORD_TYPE, yyvsp[0].ttype); ;
     break;}
 case 258:
-#line 1429 "objc-parse.y"
+#line 1440 "objc-parse.y"
 { yyval.ttype = start_struct (UNION_TYPE, yyvsp[-1].ttype); ;
     break;}
 case 259:
-#line 1431 "objc-parse.y"
+#line 1442 "objc-parse.y"
 { yyval.ttype = finish_struct (yyvsp[-3].ttype, yyvsp[-2].ttype, chainon (yyvsp[-6].ttype, yyvsp[0].ttype)); ;
     break;}
 case 260:
-#line 1433 "objc-parse.y"
+#line 1444 "objc-parse.y"
 { yyval.ttype = finish_struct (start_struct (UNION_TYPE, NULL_TREE),
 				      yyvsp[-2].ttype, chainon (yyvsp[-4].ttype, yyvsp[0].ttype));
 		;
     break;}
 case 261:
-#line 1437 "objc-parse.y"
+#line 1448 "objc-parse.y"
 { yyval.ttype = xref_tag (UNION_TYPE, yyvsp[0].ttype); ;
     break;}
 case 262:
-#line 1439 "objc-parse.y"
+#line 1450 "objc-parse.y"
 { yyvsp[0].itype = suspend_momentary ();
 		  yyval.ttype = start_enum (yyvsp[-1].ttype); ;
     break;}
 case 263:
-#line 1442 "objc-parse.y"
+#line 1453 "objc-parse.y"
 { yyval.ttype= finish_enum (yyvsp[-4].ttype, nreverse (yyvsp[-3].ttype), chainon (yyvsp[-7].ttype, yyvsp[0].ttype));
 		  resume_momentary (yyvsp[-5].itype); ;
     break;}
 case 264:
-#line 1445 "objc-parse.y"
+#line 1456 "objc-parse.y"
 { yyvsp[0].itype = suspend_momentary ();
 		  yyval.ttype = start_enum (NULL_TREE); ;
     break;}
 case 265:
-#line 1448 "objc-parse.y"
+#line 1459 "objc-parse.y"
 { yyval.ttype= finish_enum (yyvsp[-4].ttype, nreverse (yyvsp[-3].ttype), chainon (yyvsp[-6].ttype, yyvsp[0].ttype));
 		  resume_momentary (yyvsp[-5].itype); ;
     break;}
 case 266:
-#line 1451 "objc-parse.y"
+#line 1462 "objc-parse.y"
 { yyval.ttype = xref_tag (ENUMERAL_TYPE, yyvsp[0].ttype); ;
     break;}
 case 270:
-#line 1462 "objc-parse.y"
+#line 1473 "objc-parse.y"
 { if (pedantic && ! flag_isoc9x)
 		    pedwarn ("comma at end of enumerator list"); ;
     break;}
 case 271:
-#line 1468 "objc-parse.y"
+#line 1479 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 272:
-#line 1470 "objc-parse.y"
+#line 1481 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype);
 		  pedwarn ("no semicolon at end of struct or union"); ;
     break;}
 case 273:
-#line 1475 "objc-parse.y"
+#line 1486 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 274:
-#line 1477 "objc-parse.y"
+#line 1488 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[-1].ttype); ;
     break;}
 case 275:
-#line 1479 "objc-parse.y"
+#line 1490 "objc-parse.y"
 { if (pedantic)
 		    pedwarn ("extra semicolon in struct or union specified"); ;
     break;}
 case 276:
-#line 1483 "objc-parse.y"
+#line 1494 "objc-parse.y"
 {
 		  tree interface = lookup_interface (yyvsp[-1].ttype);
 
@@ -3484,7 +3539,7 @@ case 276:
 		;
     break;}
 case 277:
-#line 1508 "objc-parse.y"
+#line 1519 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -3492,14 +3547,14 @@ case 277:
 		  resume_momentary (yyvsp[-1].itype); ;
     break;}
 case 278:
-#line 1514 "objc-parse.y"
+#line 1525 "objc-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids member declarations with no members");
 		  shadow_tag(yyvsp[0].ttype);
 		  yyval.ttype = NULL_TREE; ;
     break;}
 case 279:
-#line 1519 "objc-parse.y"
+#line 1530 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -3507,144 +3562,144 @@ case 279:
 		  resume_momentary (yyvsp[-1].itype); ;
     break;}
 case 280:
-#line 1525 "objc-parse.y"
+#line 1536 "objc-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids member declarations with no members");
 		  shadow_tag(yyvsp[0].ttype);
 		  yyval.ttype = NULL_TREE; ;
     break;}
 case 281:
-#line 1530 "objc-parse.y"
+#line 1541 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 282:
-#line 1532 "objc-parse.y"
+#line 1543 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
-		  pedantic = yyvsp[-1].itype; ;
+		  RESTORE_WARN_FLAGS (yyvsp[-1].ttype); ;
     break;}
 case 284:
-#line 1539 "objc-parse.y"
+#line 1550 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 285:
-#line 1544 "objc-parse.y"
+#line 1555 "objc-parse.y"
 { yyval.ttype = grokfield (yyvsp[-3].filename, yyvsp[-2].lineno, yyvsp[-1].ttype, current_declspecs, NULL_TREE);
 		  decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;
     break;}
 case 286:
-#line 1548 "objc-parse.y"
+#line 1559 "objc-parse.y"
 { yyval.ttype = grokfield (yyvsp[-5].filename, yyvsp[-4].lineno, yyvsp[-3].ttype, current_declspecs, yyvsp[-1].ttype);
 		  decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;
     break;}
 case 287:
-#line 1551 "objc-parse.y"
+#line 1562 "objc-parse.y"
 { yyval.ttype = grokfield (yyvsp[-4].filename, yyvsp[-3].lineno, NULL_TREE, current_declspecs, yyvsp[-1].ttype);
 		  decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;
     break;}
 case 289:
-#line 1563 "objc-parse.y"
+#line 1574 "objc-parse.y"
 { if (yyvsp[-2].ttype == error_mark_node)
 		    yyval.ttype = yyvsp[-2].ttype;
 		  else
 		    yyval.ttype = chainon (yyvsp[0].ttype, yyvsp[-2].ttype); ;
     break;}
 case 290:
-#line 1568 "objc-parse.y"
+#line 1579 "objc-parse.y"
 { yyval.ttype = error_mark_node; ;
     break;}
 case 291:
-#line 1574 "objc-parse.y"
+#line 1585 "objc-parse.y"
 { yyval.ttype = build_enumerator (yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 292:
-#line 1576 "objc-parse.y"
+#line 1587 "objc-parse.y"
 { yyval.ttype = build_enumerator (yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 293:
-#line 1581 "objc-parse.y"
+#line 1592 "objc-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 294:
-#line 1583 "objc-parse.y"
+#line 1594 "objc-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 295:
-#line 1588 "objc-parse.y"
+#line 1599 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 297:
-#line 1594 "objc-parse.y"
+#line 1605 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 298:
-#line 1596 "objc-parse.y"
+#line 1607 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 299:
-#line 1601 "objc-parse.y"
+#line 1612 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 300:
-#line 1603 "objc-parse.y"
+#line 1614 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype); ;
     break;}
 case 301:
-#line 1608 "objc-parse.y"
+#line 1619 "objc-parse.y"
 { yyval.ttype = yyvsp[-1].ttype; ;
     break;}
 case 302:
-#line 1611 "objc-parse.y"
+#line 1622 "objc-parse.y"
 { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;
     break;}
 case 303:
-#line 1613 "objc-parse.y"
+#line 1624 "objc-parse.y"
 { yyval.ttype = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 304:
-#line 1615 "objc-parse.y"
+#line 1626 "objc-parse.y"
 { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 305:
-#line 1617 "objc-parse.y"
+#line 1628 "objc-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 306:
-#line 1619 "objc-parse.y"
+#line 1630 "objc-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, yyvsp[-2].ttype, NULL_TREE); ;
     break;}
 case 307:
-#line 1621 "objc-parse.y"
+#line 1632 "objc-parse.y"
 { yyval.ttype = build_nt (CALL_EXPR, NULL_TREE, yyvsp[0].ttype, NULL_TREE); ;
     break;}
 case 308:
-#line 1623 "objc-parse.y"
+#line 1634 "objc-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, NULL_TREE, yyvsp[-1].ttype); ;
     break;}
 case 309:
-#line 1625 "objc-parse.y"
+#line 1636 "objc-parse.y"
 { yyval.ttype = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); ;
     break;}
 case 310:
-#line 1629 "objc-parse.y"
+#line 1640 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 311:
-#line 1638 "objc-parse.y"
+#line 1649 "objc-parse.y"
 {
 		  if (pedantic && yyvsp[0].ends_in_label)
 		    pedwarn ("ANSI C forbids label at end of compound statement");
 		;
     break;}
 case 313:
-#line 1647 "objc-parse.y"
+#line 1658 "objc-parse.y"
 { yyval.ends_in_label = yyvsp[0].ends_in_label; ;
     break;}
 case 314:
-#line 1649 "objc-parse.y"
+#line 1660 "objc-parse.y"
 { yyval.ends_in_label = 0; ;
     break;}
 case 318:
-#line 1661 "objc-parse.y"
+#line 1672 "objc-parse.y"
 { emit_line_note (input_filename, lineno);
 		  pushlevel (0);
 		  clear_last_expr ();
@@ -3655,12 +3710,12 @@ case 318:
 		;
     break;}
 case 320:
-#line 1676 "objc-parse.y"
+#line 1687 "objc-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids label declarations"); ;
     break;}
 case 323:
-#line 1687 "objc-parse.y"
+#line 1698 "objc-parse.y"
 { tree link;
 		  for (link = yyvsp[-1].ttype; link; link = TREE_CHAIN (link))
 		    {
@@ -3671,19 +3726,19 @@ case 323:
 		;
     break;}
 case 324:
-#line 1701 "objc-parse.y"
+#line 1712 "objc-parse.y"
 {;
     break;}
 case 326:
-#line 1705 "objc-parse.y"
+#line 1716 "objc-parse.y"
 { compstmt_count++; ;
     break;}
 case 327:
-#line 1708 "objc-parse.y"
+#line 1719 "objc-parse.y"
 { yyval.ttype = convert (void_type_node, integer_zero_node); ;
     break;}
 case 328:
-#line 1710 "objc-parse.y"
+#line 1721 "objc-parse.y"
 { emit_line_note (input_filename, lineno);
 		  expand_end_bindings (getdecls (), 1, 0);
 		  yyval.ttype = poplevel (1, 1, 0);
@@ -3693,7 +3748,7 @@ case 328:
 		    pop_momentary (); ;
     break;}
 case 329:
-#line 1718 "objc-parse.y"
+#line 1729 "objc-parse.y"
 { emit_line_note (input_filename, lineno);
 		  expand_end_bindings (getdecls (), kept_level_p (), 0);
 		  yyval.ttype = poplevel (kept_level_p (), 0, 0);
@@ -3703,7 +3758,7 @@ case 329:
 		    pop_momentary (); ;
     break;}
 case 330:
-#line 1726 "objc-parse.y"
+#line 1737 "objc-parse.y"
 { emit_line_note (input_filename, lineno);
 		  expand_end_bindings (getdecls (), kept_level_p (), 0);
 		  yyval.ttype = poplevel (kept_level_p (), 0, 0);
@@ -3713,7 +3768,7 @@ case 330:
 		    pop_momentary (); ;
     break;}
 case 333:
-#line 1746 "objc-parse.y"
+#line 1757 "objc-parse.y"
 { emit_line_note (yyvsp[-5].filename, yyvsp[-4].lineno);
 		  c_expand_start_cond (truthvalue_conversion (yyvsp[-1].ttype), 0, 
 				       compstmt_count);
@@ -3723,7 +3778,7 @@ case 333:
 		  position_after_white_space (); ;
     break;}
 case 334:
-#line 1760 "objc-parse.y"
+#line 1771 "objc-parse.y"
 { stmt_count++;
 		  compstmt_count++;
 		  emit_line_note (yyvsp[-2].filename, yyvsp[-1].lineno);
@@ -3733,43 +3788,43 @@ case 334:
 		  position_after_white_space (); ;
     break;}
 case 335:
-#line 1768 "objc-parse.y"
+#line 1779 "objc-parse.y"
 { expand_loop_continue_here (); ;
     break;}
 case 336:
-#line 1772 "objc-parse.y"
+#line 1783 "objc-parse.y"
 { yyval.filename = input_filename; ;
     break;}
 case 337:
-#line 1776 "objc-parse.y"
+#line 1787 "objc-parse.y"
 { yyval.lineno = lineno; ;
     break;}
 case 338:
-#line 1781 "objc-parse.y"
+#line 1792 "objc-parse.y"
 { ;
     break;}
 case 339:
-#line 1786 "objc-parse.y"
+#line 1797 "objc-parse.y"
 { ;
     break;}
 case 340:
-#line 1791 "objc-parse.y"
+#line 1802 "objc-parse.y"
 { yyval.ends_in_label = yyvsp[0].ends_in_label; ;
     break;}
 case 341:
-#line 1796 "objc-parse.y"
+#line 1807 "objc-parse.y"
 { yyval.ends_in_label = 0; ;
     break;}
 case 342:
-#line 1798 "objc-parse.y"
+#line 1809 "objc-parse.y"
 { yyval.ends_in_label = 1; ;
     break;}
 case 343:
-#line 1804 "objc-parse.y"
+#line 1815 "objc-parse.y"
 { stmt_count++; ;
     break;}
 case 345:
-#line 1807 "objc-parse.y"
+#line 1818 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);
 /* It appears that this should not be done--that a non-lvalue array
@@ -3788,19 +3843,19 @@ case 345:
 		  clear_momentary (); ;
     break;}
 case 346:
-#line 1824 "objc-parse.y"
+#line 1835 "objc-parse.y"
 { c_expand_start_else ();
 		  yyvsp[-1].itype = stmt_count;
 		  position_after_white_space (); ;
     break;}
 case 347:
-#line 1828 "objc-parse.y"
+#line 1839 "objc-parse.y"
 { c_expand_end_cond ();
 		  if (extra_warnings && stmt_count == yyvsp[-3].itype)
 		    warning ("empty body in an else-statement"); ;
     break;}
 case 348:
-#line 1832 "objc-parse.y"
+#line 1843 "objc-parse.y"
 { c_expand_end_cond ();
 		  /* This warning is here instead of in simple_if, because we
 		     do not want a warning if an empty if is followed by an
@@ -3811,11 +3866,11 @@ case 348:
 						"empty body in an if-statement"); ;
     break;}
 case 349:
-#line 1844 "objc-parse.y"
+#line 1855 "objc-parse.y"
 { c_expand_end_cond (); ;
     break;}
 case 350:
-#line 1846 "objc-parse.y"
+#line 1857 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-2].filename, yyvsp[-1].lineno);
 		  /* The emit_nop used to come before emit_line_note,
@@ -3827,7 +3882,7 @@ case 350:
 		  emit_nop (); ;
     break;}
 case 351:
-#line 1856 "objc-parse.y"
+#line 1867 "objc-parse.y"
 { /* Don't start the loop till we have succeeded
 		     in parsing the end test.  This is to make sure
 		     that we end every loop we start.  */
@@ -3838,11 +3893,11 @@ case 351:
 		  position_after_white_space (); ;
     break;}
 case 352:
-#line 1865 "objc-parse.y"
+#line 1876 "objc-parse.y"
 { expand_end_loop (); ;
     break;}
 case 353:
-#line 1868 "objc-parse.y"
+#line 1879 "objc-parse.y"
 { emit_line_note (input_filename, lineno);
 		  expand_exit_loop_if_false (NULL_PTR,
 					     truthvalue_conversion (yyvsp[-2].ttype));
@@ -3850,12 +3905,12 @@ case 353:
 		  clear_momentary (); ;
     break;}
 case 354:
-#line 1875 "objc-parse.y"
+#line 1886 "objc-parse.y"
 { expand_end_loop ();
 		  clear_momentary (); ;
     break;}
 case 355:
-#line 1879 "objc-parse.y"
+#line 1890 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-5].filename, yyvsp[-4].lineno);
 		  /* See comment in `while' alternative, above.  */
@@ -3868,12 +3923,12 @@ case 355:
 		;
     break;}
 case 356:
-#line 1891 "objc-parse.y"
+#line 1902 "objc-parse.y"
 { yyvsp[0].lineno = lineno;
 		  yyval.filename = input_filename; ;
     break;}
 case 357:
-#line 1894 "objc-parse.y"
+#line 1905 "objc-parse.y"
 { 
 		  /* Start the loop.  Doing this after parsing
 		     all the expressions ensures we will end the loop.  */
@@ -3891,7 +3946,7 @@ case 357:
 		  position_after_white_space (); ;
     break;}
 case 358:
-#line 1910 "objc-parse.y"
+#line 1921 "objc-parse.y"
 { /* Emit the increment expression, with a line number.  */
 		  emit_line_note (yyvsp[-4].filename, yyvsp[-5].lineno);
 		  expand_loop_continue_here ();
@@ -3904,7 +3959,7 @@ case 358:
 		  expand_end_loop (); ;
     break;}
 case 359:
-#line 1921 "objc-parse.y"
+#line 1932 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-5].filename, yyvsp[-4].lineno);
 		  c_expand_start_case (yyvsp[-1].ttype);
@@ -3914,7 +3969,7 @@ case 359:
 		  position_after_white_space (); ;
     break;}
 case 360:
-#line 1929 "objc-parse.y"
+#line 1940 "objc-parse.y"
 { expand_end_case (yyvsp[-3].ttype);
 		  if (yychar == CONSTANT || yychar == STRING)
 		    pop_momentary_nofree ();
@@ -3922,33 +3977,33 @@ case 360:
 		    pop_momentary (); ;
     break;}
 case 361:
-#line 1935 "objc-parse.y"
+#line 1946 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);
 		  if ( ! expand_exit_something ())
 		    error ("break statement not within loop or switch"); ;
     break;}
 case 362:
-#line 1940 "objc-parse.y"
+#line 1951 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);
 		  if (! expand_continue_loop (NULL_PTR))
 		    error ("continue statement not within a loop"); ;
     break;}
 case 363:
-#line 1945 "objc-parse.y"
+#line 1956 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);
 		  c_expand_return (NULL_TREE); ;
     break;}
 case 364:
-#line 1949 "objc-parse.y"
+#line 1960 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-4].filename, yyvsp[-3].lineno);
 		  c_expand_return (yyvsp[-1].ttype); ;
     break;}
 case 365:
-#line 1953 "objc-parse.y"
+#line 1964 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-7].filename, yyvsp[-6].lineno);
 		  STRIP_NOPS (yyvsp[-2].ttype);
@@ -3960,7 +4015,7 @@ case 365:
 		    error ("argument of `asm' is not a constant string"); ;
     break;}
 case 366:
-#line 1964 "objc-parse.y"
+#line 1975 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-9].filename, yyvsp[-8].lineno);
 		  c_expand_asm_operands (yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE, NULL_TREE,
@@ -3968,7 +4023,7 @@ case 366:
 					 input_filename, lineno); ;
     break;}
 case 367:
-#line 1971 "objc-parse.y"
+#line 1982 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-11].filename, yyvsp[-10].lineno);
 		  c_expand_asm_operands (yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE,
@@ -3976,7 +4031,7 @@ case 367:
 					 input_filename, lineno); ;
     break;}
 case 368:
-#line 1979 "objc-parse.y"
+#line 1990 "objc-parse.y"
 { stmt_count++;
 		  emit_line_note (yyvsp[-13].filename, yyvsp[-12].lineno);
 		  c_expand_asm_operands (yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype,
@@ -3984,7 +4039,7 @@ case 368:
 					 input_filename, lineno); ;
     break;}
 case 369:
-#line 1985 "objc-parse.y"
+#line 1996 "objc-parse.y"
 { tree decl;
 		  stmt_count++;
 		  emit_line_note (yyvsp[-4].filename, yyvsp[-3].lineno);
@@ -3997,7 +4052,7 @@ case 369:
 		;
     break;}
 case 370:
-#line 1996 "objc-parse.y"
+#line 2007 "objc-parse.y"
 { if (pedantic)
 		    pedwarn ("ANSI C forbids `goto *expr;'");
 		  stmt_count++;
@@ -4005,7 +4060,7 @@ case 370:
 		  expand_computed_goto (convert (ptr_type_node, yyvsp[-1].ttype)); ;
     break;}
 case 373:
-#line 2011 "objc-parse.y"
+#line 2022 "objc-parse.y"
 {
 	    /* The value returned by this action is  */
 	    /*      1 if everything is OK */ 
@@ -4028,14 +4083,14 @@ case 373:
 	  ;
     break;}
 case 374:
-#line 2032 "objc-parse.y"
+#line 2043 "objc-parse.y"
 {
 	    if (yyvsp[-1].itype)
 	      iterator_for_loop_end (yyvsp[-3].ttype);
 	  ;
     break;}
 case 375:
-#line 2067 "objc-parse.y"
+#line 2078 "objc-parse.y"
 { register tree value = check_case_value (yyvsp[-1].ttype);
 		  register tree label
 		    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);
@@ -4068,7 +4123,7 @@ case 375:
 		  position_after_white_space (); ;
     break;}
 case 376:
-#line 2098 "objc-parse.y"
+#line 2109 "objc-parse.y"
 { register tree value1 = check_case_value (yyvsp[-3].ttype);
 		  register tree value2 = check_case_value (yyvsp[-1].ttype);
 		  register tree label
@@ -4101,7 +4156,7 @@ case 376:
 		  position_after_white_space (); ;
     break;}
 case 377:
-#line 2129 "objc-parse.y"
+#line 2140 "objc-parse.y"
 {
 		  tree duplicate;
 		  register tree label
@@ -4118,7 +4173,7 @@ case 377:
 		  position_after_white_space (); ;
     break;}
 case 378:
-#line 2144 "objc-parse.y"
+#line 2155 "objc-parse.y"
 { tree label = define_label (input_filename, lineno, yyvsp[-2].ttype);
 		  stmt_count++;
 		  emit_nop ();
@@ -4130,52 +4185,52 @@ case 378:
 		  position_after_white_space (); ;
     break;}
 case 379:
-#line 2159 "objc-parse.y"
+#line 2170 "objc-parse.y"
 { emit_line_note (input_filename, lineno);
 		  yyval.ttype = NULL_TREE; ;
     break;}
 case 380:
-#line 2162 "objc-parse.y"
+#line 2173 "objc-parse.y"
 { emit_line_note (input_filename, lineno); ;
     break;}
 case 381:
-#line 2167 "objc-parse.y"
+#line 2178 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 383:
-#line 2174 "objc-parse.y"
+#line 2185 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 386:
-#line 2181 "objc-parse.y"
+#line 2192 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[0].ttype); ;
     break;}
 case 387:
-#line 2186 "objc-parse.y"
+#line 2197 "objc-parse.y"
 { yyval.ttype = build_tree_list (yyvsp[-3].ttype, yyvsp[-1].ttype); ;
     break;}
 case 388:
-#line 2191 "objc-parse.y"
+#line 2202 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, combine_strings (yyvsp[0].ttype), NULL_TREE); ;
     break;}
 case 389:
-#line 2193 "objc-parse.y"
+#line 2204 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, combine_strings (yyvsp[0].ttype), yyvsp[-2].ttype); ;
     break;}
 case 390:
-#line 2199 "objc-parse.y"
+#line 2210 "objc-parse.y"
 { pushlevel (0);
 		  clear_parm_order ();
 		  declare_parm_level (0); ;
     break;}
 case 391:
-#line 2203 "objc-parse.y"
+#line 2214 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
 		  parmlist_tags_warning ();
 		  poplevel (0, 0, 0); ;
     break;}
 case 393:
-#line 2211 "objc-parse.y"
+#line 2222 "objc-parse.y"
 { tree parm;
 		  if (pedantic)
 		    pedwarn ("ANSI C forbids forward parameter declarations");
@@ -4185,19 +4240,19 @@ case 393:
 		  clear_parm_order (); ;
     break;}
 case 394:
-#line 2219 "objc-parse.y"
+#line 2230 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype; ;
     break;}
 case 395:
-#line 2221 "objc-parse.y"
+#line 2232 "objc-parse.y"
 { yyval.ttype = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE); ;
     break;}
 case 396:
-#line 2227 "objc-parse.y"
+#line 2238 "objc-parse.y"
 { yyval.ttype = get_parm_info (0); ;
     break;}
 case 397:
-#line 2229 "objc-parse.y"
+#line 2240 "objc-parse.y"
 { yyval.ttype = get_parm_info (0);
 		  /* Gcc used to allow this as an extension.  However, it does
 		     not work for all targets, and thus has been disabled.
@@ -4209,23 +4264,23 @@ case 397:
 		;
     break;}
 case 398:
-#line 2239 "objc-parse.y"
+#line 2250 "objc-parse.y"
 { yyval.ttype = get_parm_info (1); ;
     break;}
 case 399:
-#line 2241 "objc-parse.y"
+#line 2252 "objc-parse.y"
 { yyval.ttype = get_parm_info (0); ;
     break;}
 case 400:
-#line 2246 "objc-parse.y"
+#line 2257 "objc-parse.y"
 { push_parm_decl (yyvsp[0].ttype); ;
     break;}
 case 401:
-#line 2248 "objc-parse.y"
+#line 2259 "objc-parse.y"
 { push_parm_decl (yyvsp[0].ttype); ;
     break;}
 case 402:
-#line 2255 "objc-parse.y"
+#line 2266 "objc-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
@@ -4236,7 +4291,7 @@ case 402:
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 403:
-#line 2264 "objc-parse.y"
+#line 2275 "objc-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
@@ -4247,7 +4302,7 @@ case 403:
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 404:
-#line 2273 "objc-parse.y"
+#line 2284 "objc-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
@@ -4258,7 +4313,7 @@ case 404:
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 405:
-#line 2282 "objc-parse.y"
+#line 2293 "objc-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
@@ -4269,7 +4324,7 @@ case 405:
 		  resume_momentary (yyvsp[-2].itype);  ;
     break;}
 case 406:
-#line 2292 "objc-parse.y"
+#line 2303 "objc-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
@@ -4280,19 +4335,19 @@ case 406:
 		  resume_momentary (yyvsp[-2].itype);  ;
     break;}
 case 407:
-#line 2306 "objc-parse.y"
+#line 2317 "objc-parse.y"
 { pushlevel (0);
 		  clear_parm_order ();
 		  declare_parm_level (1); ;
     break;}
 case 408:
-#line 2310 "objc-parse.y"
+#line 2321 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
 		  parmlist_tags_warning ();
 		  poplevel (0, 0, 0); ;
     break;}
 case 410:
-#line 2318 "objc-parse.y"
+#line 2329 "objc-parse.y"
 { tree t;
 		  for (t = yyvsp[-1].ttype; t; t = TREE_CHAIN (t))
 		    if (TREE_VALUE (t) == NULL_TREE)
@@ -4300,28 +4355,29 @@ case 410:
 		  yyval.ttype = tree_cons (NULL_TREE, NULL_TREE, yyvsp[-1].ttype); ;
     break;}
 case 411:
-#line 2328 "objc-parse.y"
+#line 2339 "objc-parse.y"
 { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;
     break;}
 case 412:
-#line 2330 "objc-parse.y"
+#line 2341 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;
     break;}
 case 413:
-#line 2336 "objc-parse.y"
+#line 2347 "objc-parse.y"
 { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;
     break;}
 case 414:
-#line 2338 "objc-parse.y"
+#line 2349 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;
     break;}
 case 415:
-#line 2343 "objc-parse.y"
-{ yyval.itype = pedantic;
-		  pedantic = 0; ;
+#line 2354 "objc-parse.y"
+{ yyval.ttype = SAVE_WARN_FLAGS();
+		  pedantic = 0;
+		  warn_pointer_arith = 0; ;
     break;}
 case 421:
-#line 2356 "objc-parse.y"
+#line 2368 "objc-parse.y"
 {
 		  if (objc_implementation_context)
                     {
@@ -4334,27 +4390,27 @@ case 421:
 		;
     break;}
 case 422:
-#line 2371 "objc-parse.y"
+#line 2383 "objc-parse.y"
 { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;
     break;}
 case 423:
-#line 2373 "objc-parse.y"
+#line 2385 "objc-parse.y"
 { yyval.ttype = chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;
     break;}
 case 424:
-#line 2378 "objc-parse.y"
+#line 2390 "objc-parse.y"
 {
 		  objc_declare_class (yyvsp[-1].ttype);
 		;
     break;}
 case 425:
-#line 2384 "objc-parse.y"
+#line 2396 "objc-parse.y"
 {
 		  objc_declare_alias (yyvsp[-2].ttype, yyvsp[-1].ttype);
 		;
     break;}
 case 426:
-#line 2390 "objc-parse.y"
+#line 2402 "objc-parse.y"
 {
 		  objc_interface_context = objc_ivar_context
 		    = start_class (CLASS_INTERFACE_TYPE, yyvsp[-2].ttype, NULL_TREE, yyvsp[-1].ttype);
@@ -4362,20 +4418,20 @@ case 426:
 		;
     break;}
 case 427:
-#line 2396 "objc-parse.y"
+#line 2408 "objc-parse.y"
 {
                   continue_class (objc_interface_context);
 		;
     break;}
 case 428:
-#line 2401 "objc-parse.y"
+#line 2413 "objc-parse.y"
 {
 		  finish_class (objc_interface_context);
 		  objc_interface_context = NULL_TREE;
 		;
     break;}
 case 429:
-#line 2407 "objc-parse.y"
+#line 2419 "objc-parse.y"
 {
 		  objc_interface_context
 		    = start_class (CLASS_INTERFACE_TYPE, yyvsp[-1].ttype, NULL_TREE, yyvsp[0].ttype);
@@ -4383,14 +4439,14 @@ case 429:
 		;
     break;}
 case 430:
-#line 2414 "objc-parse.y"
+#line 2426 "objc-parse.y"
 {
 		  finish_class (objc_interface_context);
 		  objc_interface_context = NULL_TREE;
 		;
     break;}
 case 431:
-#line 2420 "objc-parse.y"
+#line 2432 "objc-parse.y"
 {
 		  objc_interface_context = objc_ivar_context
 		    = start_class (CLASS_INTERFACE_TYPE, yyvsp[-4].ttype, yyvsp[-2].ttype, yyvsp[-1].ttype);
@@ -4398,20 +4454,20 @@ case 431:
 		;
     break;}
 case 432:
-#line 2426 "objc-parse.y"
+#line 2438 "objc-parse.y"
 {
                   continue_class (objc_interface_context);
 		;
     break;}
 case 433:
-#line 2431 "objc-parse.y"
+#line 2443 "objc-parse.y"
 {
 		  finish_class (objc_interface_context);
 		  objc_interface_context = NULL_TREE;
 		;
     break;}
 case 434:
-#line 2437 "objc-parse.y"
+#line 2449 "objc-parse.y"
 {
 		  objc_interface_context
 		    = start_class (CLASS_INTERFACE_TYPE, yyvsp[-3].ttype, yyvsp[-1].ttype, yyvsp[0].ttype);
@@ -4419,14 +4475,14 @@ case 434:
 		;
     break;}
 case 435:
-#line 2444 "objc-parse.y"
+#line 2456 "objc-parse.y"
 {
 		  finish_class (objc_interface_context);
 		  objc_interface_context = NULL_TREE;
 		;
     break;}
 case 436:
-#line 2450 "objc-parse.y"
+#line 2462 "objc-parse.y"
 {
 		  objc_implementation_context = objc_ivar_context
 		    = start_class (CLASS_IMPLEMENTATION_TYPE, yyvsp[-1].ttype, NULL_TREE, NULL_TREE);
@@ -4434,14 +4490,14 @@ case 436:
 		;
     break;}
 case 437:
-#line 2456 "objc-parse.y"
+#line 2468 "objc-parse.y"
 {
                   objc_ivar_chain
 		    = continue_class (objc_implementation_context);
 		;
     break;}
 case 438:
-#line 2462 "objc-parse.y"
+#line 2474 "objc-parse.y"
 {
 		  objc_implementation_context
 		    = start_class (CLASS_IMPLEMENTATION_TYPE, yyvsp[0].ttype, NULL_TREE, NULL_TREE);
@@ -4450,7 +4506,7 @@ case 438:
 		;
     break;}
 case 439:
-#line 2470 "objc-parse.y"
+#line 2482 "objc-parse.y"
 {
 		  objc_implementation_context = objc_ivar_context
 		    = start_class (CLASS_IMPLEMENTATION_TYPE, yyvsp[-3].ttype, yyvsp[-1].ttype, NULL_TREE);
@@ -4458,14 +4514,14 @@ case 439:
 		;
     break;}
 case 440:
-#line 2476 "objc-parse.y"
+#line 2488 "objc-parse.y"
 {
                   objc_ivar_chain
 		    = continue_class (objc_implementation_context);
 		;
     break;}
 case 441:
-#line 2482 "objc-parse.y"
+#line 2494 "objc-parse.y"
 {
 		  objc_implementation_context
 		    = start_class (CLASS_IMPLEMENTATION_TYPE, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE);
@@ -4474,7 +4530,7 @@ case 441:
 		;
     break;}
 case 442:
-#line 2490 "objc-parse.y"
+#line 2502 "objc-parse.y"
 {
 		  objc_interface_context
 		    = start_class (CATEGORY_INTERFACE_TYPE, yyvsp[-4].ttype, yyvsp[-2].ttype, yyvsp[0].ttype);
@@ -4482,14 +4538,14 @@ case 442:
 		;
     break;}
 case 443:
-#line 2497 "objc-parse.y"
+#line 2509 "objc-parse.y"
 {
 		  finish_class (objc_interface_context);
 		  objc_interface_context = NULL_TREE;
 		;
     break;}
 case 444:
-#line 2503 "objc-parse.y"
+#line 2515 "objc-parse.y"
 {
 		  objc_implementation_context
 		    = start_class (CATEGORY_IMPLEMENTATION_TYPE, yyvsp[-3].ttype, yyvsp[-1].ttype, NULL_TREE);
@@ -4498,7 +4554,7 @@ case 444:
 		;
     break;}
 case 445:
-#line 2513 "objc-parse.y"
+#line 2525 "objc-parse.y"
 {
 		  remember_protocol_qualifiers ();
 		  objc_interface_context
@@ -4506,7 +4562,7 @@ case 445:
 		;
     break;}
 case 446:
-#line 2519 "objc-parse.y"
+#line 2531 "objc-parse.y"
 {
 		  forget_protocol_qualifiers();
 		  finish_protocol(objc_interface_context);
@@ -4514,13 +4570,13 @@ case 446:
 		;
     break;}
 case 447:
-#line 2528 "objc-parse.y"
+#line 2540 "objc-parse.y"
 {
 		  yyval.ttype = NULL_TREE;
 		;
     break;}
 case 449:
-#line 2536 "objc-parse.y"
+#line 2548 "objc-parse.y"
 {
 		  if (yyvsp[-2].code == LT_EXPR && yyvsp[0].code == GT_EXPR)
 		    yyval.ttype = yyvsp[-1].ttype;
@@ -4529,32 +4585,32 @@ case 449:
 		;
     break;}
 case 452:
-#line 2550 "objc-parse.y"
+#line 2562 "objc-parse.y"
 { objc_public_flag = 2; ;
     break;}
 case 453:
-#line 2551 "objc-parse.y"
+#line 2563 "objc-parse.y"
 { objc_public_flag = 0; ;
     break;}
 case 454:
-#line 2552 "objc-parse.y"
+#line 2564 "objc-parse.y"
 { objc_public_flag = 1; ;
     break;}
 case 455:
-#line 2557 "objc-parse.y"
+#line 2569 "objc-parse.y"
 {
                   yyval.ttype = NULL_TREE;
                 ;
     break;}
 case 457:
-#line 2562 "objc-parse.y"
+#line 2574 "objc-parse.y"
 {
                   if (pedantic)
 		    pedwarn ("extra semicolon in struct or union specified");
                 ;
     break;}
 case 458:
-#line 2580 "objc-parse.y"
+#line 2592 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -4562,7 +4618,7 @@ case 458:
 		  resume_momentary (yyvsp[-1].itype); ;
     break;}
 case 459:
-#line 2586 "objc-parse.y"
+#line 2598 "objc-parse.y"
 { yyval.ttype = yyvsp[0].ttype;
 		  current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
@@ -4570,15 +4626,15 @@ case 459:
 		  resume_momentary (yyvsp[-1].itype); ;
     break;}
 case 460:
-#line 2592 "objc-parse.y"
+#line 2604 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 461:
-#line 2597 "objc-parse.y"
+#line 2609 "objc-parse.y"
 { yyval.ttype = NULL_TREE; ;
     break;}
 case 464:
-#line 2604 "objc-parse.y"
+#line 2616 "objc-parse.y"
 {
 		  yyval.ttype = add_instance_variable (objc_ivar_context,
 					      objc_public_flag,
@@ -4587,7 +4643,7 @@ case 464:
                 ;
     break;}
 case 465:
-#line 2611 "objc-parse.y"
+#line 2623 "objc-parse.y"
 {
 		  yyval.ttype = add_instance_variable (objc_ivar_context,
 					      objc_public_flag,
@@ -4595,7 +4651,7 @@ case 465:
                 ;
     break;}
 case 466:
-#line 2617 "objc-parse.y"
+#line 2629 "objc-parse.y"
 {
 		  yyval.ttype = add_instance_variable (objc_ivar_context,
 					      objc_public_flag,
@@ -4604,7 +4660,7 @@ case 466:
                 ;
     break;}
 case 467:
-#line 2627 "objc-parse.y"
+#line 2639 "objc-parse.y"
 {
 		  remember_protocol_qualifiers ();
 		  if (objc_implementation_context)
@@ -4614,7 +4670,7 @@ case 467:
 		;
     break;}
 case 468:
-#line 2635 "objc-parse.y"
+#line 2647 "objc-parse.y"
 {
 		  forget_protocol_qualifiers ();
 		  add_class_method (objc_implementation_context, yyvsp[0].ttype);
@@ -4623,20 +4679,20 @@ case 468:
 		;
     break;}
 case 469:
-#line 2642 "objc-parse.y"
+#line 2654 "objc-parse.y"
 {
 		  continue_method_def ();
 		;
     break;}
 case 470:
-#line 2646 "objc-parse.y"
+#line 2658 "objc-parse.y"
 {
 		  finish_method_def ();
 		  objc_method_context = NULL_TREE;
 		;
     break;}
 case 471:
-#line 2652 "objc-parse.y"
+#line 2664 "objc-parse.y"
 {
 		  remember_protocol_qualifiers ();
 		  if (objc_implementation_context)
@@ -4646,7 +4702,7 @@ case 471:
 		;
     break;}
 case 472:
-#line 2660 "objc-parse.y"
+#line 2672 "objc-parse.y"
 {
 		  forget_protocol_qualifiers ();
 		  add_instance_method (objc_implementation_context, yyvsp[0].ttype);
@@ -4655,28 +4711,28 @@ case 472:
 		;
     break;}
 case 473:
-#line 2667 "objc-parse.y"
+#line 2679 "objc-parse.y"
 {
 		  continue_method_def ();
 		;
     break;}
 case 474:
-#line 2671 "objc-parse.y"
+#line 2683 "objc-parse.y"
 {
 		  finish_method_def ();
 		  objc_method_context = NULL_TREE;
 		;
     break;}
 case 476:
-#line 2683 "objc-parse.y"
+#line 2695 "objc-parse.y"
 {yyval.ttype = NULL_TREE; ;
     break;}
 case 481:
-#line 2690 "objc-parse.y"
+#line 2702 "objc-parse.y"
 {yyval.ttype = NULL_TREE; ;
     break;}
 case 485:
-#line 2700 "objc-parse.y"
+#line 2712 "objc-parse.y"
 {
 		  /* Remember protocol qualifiers in prototypes.  */
 		  remember_protocol_qualifiers ();
@@ -4684,7 +4740,7 @@ case 485:
 		;
     break;}
 case 486:
-#line 2706 "objc-parse.y"
+#line 2718 "objc-parse.y"
 {
 		  /* Forget protocol qualifiers here.  */
 		  forget_protocol_qualifiers ();
@@ -4692,7 +4748,7 @@ case 486:
 		;
     break;}
 case 488:
-#line 2714 "objc-parse.y"
+#line 2726 "objc-parse.y"
 {
 		  /* Remember protocol qualifiers in prototypes.  */
 		  remember_protocol_qualifiers ();
@@ -4700,7 +4756,7 @@ case 488:
 		;
     break;}
 case 489:
-#line 2720 "objc-parse.y"
+#line 2732 "objc-parse.y"
 {
 		  /* Forget protocol qualifiers here.  */
 		  forget_protocol_qualifiers ();
@@ -4708,94 +4764,94 @@ case 489:
 		;
     break;}
 case 491:
-#line 2730 "objc-parse.y"
+#line 2742 "objc-parse.y"
 {
 		  yyval.ttype = build_method_decl (objc_inherit_code, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE);
 		;
     break;}
 case 492:
-#line 2735 "objc-parse.y"
+#line 2747 "objc-parse.y"
 {
 		  yyval.ttype = build_method_decl (objc_inherit_code, NULL_TREE, yyvsp[0].ttype, NULL_TREE);
 		;
     break;}
 case 493:
-#line 2740 "objc-parse.y"
+#line 2752 "objc-parse.y"
 {
 		  yyval.ttype = build_method_decl (objc_inherit_code, yyvsp[-3].ttype, yyvsp[-1].ttype, yyvsp[0].ttype);
 		;
     break;}
 case 494:
-#line 2745 "objc-parse.y"
+#line 2757 "objc-parse.y"
 {
 		  yyval.ttype = build_method_decl (objc_inherit_code, NULL_TREE, yyvsp[-1].ttype, yyvsp[0].ttype);
 		;
     break;}
 case 503:
-#line 2775 "objc-parse.y"
+#line 2787 "objc-parse.y"
 { current_declspecs = TREE_VALUE (declspec_stack);
 		  prefix_attributes = TREE_PURPOSE (declspec_stack);
 		  declspec_stack = TREE_CHAIN (declspec_stack);
 		  resume_momentary (yyvsp[-2].itype); ;
     break;}
 case 504:
-#line 2780 "objc-parse.y"
+#line 2792 "objc-parse.y"
 { shadow_tag (yyvsp[-1].ttype); ;
     break;}
 case 505:
-#line 2782 "objc-parse.y"
+#line 2794 "objc-parse.y"
 { pedwarn ("empty declaration"); ;
     break;}
 case 506:
-#line 2787 "objc-parse.y"
+#line 2799 "objc-parse.y"
 { push_parm_decl (yyvsp[0].ttype); ;
     break;}
 case 507:
-#line 2789 "objc-parse.y"
+#line 2801 "objc-parse.y"
 { push_parm_decl (yyvsp[0].ttype); ;
     break;}
 case 508:
-#line 2797 "objc-parse.y"
+#line 2809 "objc-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
 							 yyvsp[0].ttype)); ;
     break;}
 case 509:
-#line 2802 "objc-parse.y"
+#line 2814 "objc-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
 							 yyvsp[0].ttype)); ;
     break;}
 case 510:
-#line 2807 "objc-parse.y"
+#line 2819 "objc-parse.y"
 { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
 							 yyvsp[-1].ttype),
 					build_tree_list (prefix_attributes,
 							 yyvsp[0].ttype)); ;
     break;}
 case 511:
-#line 2815 "objc-parse.y"
+#line 2827 "objc-parse.y"
 {
 	    	  yyval.ttype = NULL_TREE;
 		;
     break;}
 case 512:
-#line 2819 "objc-parse.y"
+#line 2831 "objc-parse.y"
 {
 		  /* oh what a kludge! */
 		  yyval.ttype = (tree)1;
 		;
     break;}
 case 513:
-#line 2824 "objc-parse.y"
+#line 2836 "objc-parse.y"
 {
 		  pushlevel (0);
 		;
     break;}
 case 514:
-#line 2828 "objc-parse.y"
+#line 2840 "objc-parse.y"
 {
 	  	  /* returns a tree list node generated by get_parm_info */
 		  yyval.ttype = yyvsp[0].ttype;
@@ -4803,119 +4859,119 @@ case 514:
 		;
     break;}
 case 517:
-#line 2843 "objc-parse.y"
+#line 2855 "objc-parse.y"
 {
 		  yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype);
 		;
     break;}
 case 522:
-#line 2856 "objc-parse.y"
+#line 2868 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 523:
-#line 2857 "objc-parse.y"
+#line 2869 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 524:
-#line 2858 "objc-parse.y"
+#line 2870 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 525:
-#line 2859 "objc-parse.y"
+#line 2871 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 526:
-#line 2860 "objc-parse.y"
+#line 2872 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 527:
-#line 2861 "objc-parse.y"
+#line 2873 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 528:
-#line 2862 "objc-parse.y"
+#line 2874 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 529:
-#line 2863 "objc-parse.y"
+#line 2875 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 530:
-#line 2864 "objc-parse.y"
+#line 2876 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 531:
-#line 2865 "objc-parse.y"
+#line 2877 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 532:
-#line 2866 "objc-parse.y"
+#line 2878 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 533:
-#line 2867 "objc-parse.y"
+#line 2879 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 534:
-#line 2868 "objc-parse.y"
+#line 2880 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 535:
-#line 2869 "objc-parse.y"
+#line 2881 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 536:
-#line 2870 "objc-parse.y"
+#line 2882 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 537:
-#line 2871 "objc-parse.y"
+#line 2883 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 538:
-#line 2872 "objc-parse.y"
+#line 2884 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 539:
-#line 2873 "objc-parse.y"
+#line 2885 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 540:
-#line 2874 "objc-parse.y"
+#line 2886 "objc-parse.y"
 { yyval.ttype = get_identifier (token_buffer); ;
     break;}
 case 543:
-#line 2880 "objc-parse.y"
+#line 2892 "objc-parse.y"
 {
 		  yyval.ttype = build_keyword_decl (yyvsp[-5].ttype, yyvsp[-2].ttype, yyvsp[0].ttype);
 		;
     break;}
 case 544:
-#line 2885 "objc-parse.y"
+#line 2897 "objc-parse.y"
 {
 		  yyval.ttype = build_keyword_decl (yyvsp[-2].ttype, NULL_TREE, yyvsp[0].ttype);
 		;
     break;}
 case 545:
-#line 2890 "objc-parse.y"
+#line 2902 "objc-parse.y"
 {
 		  yyval.ttype = build_keyword_decl (NULL_TREE, yyvsp[-2].ttype, yyvsp[0].ttype);
 		;
     break;}
 case 546:
-#line 2895 "objc-parse.y"
+#line 2907 "objc-parse.y"
 {
 		  yyval.ttype = build_keyword_decl (NULL_TREE, NULL_TREE, yyvsp[0].ttype);
 		;
     break;}
 case 550:
-#line 2908 "objc-parse.y"
+#line 2920 "objc-parse.y"
 {
 		  yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype);
 		;
     break;}
 case 551:
-#line 2916 "objc-parse.y"
+#line 2928 "objc-parse.y"
 {
 		  if (TREE_CHAIN (yyvsp[0].ttype) == NULL_TREE)
 		    /* just return the expr., remove a level of indirection */
@@ -4926,76 +4982,76 @@ case 551:
 		;
     break;}
 case 552:
-#line 2928 "objc-parse.y"
+#line 2940 "objc-parse.y"
 {
 		  yyval.ttype = build_tree_list (yyvsp[-2].ttype, yyvsp[0].ttype);
 		;
     break;}
 case 553:
-#line 2932 "objc-parse.y"
+#line 2944 "objc-parse.y"
 {
 		  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype);
 		;
     break;}
 case 555:
-#line 2940 "objc-parse.y"
+#line 2952 "objc-parse.y"
 {
 		  yyval.ttype = get_class_reference (yyvsp[0].ttype);
 		;
     break;}
 case 556:
-#line 2947 "objc-parse.y"
+#line 2959 "objc-parse.y"
 { objc_receiver_context = 1; ;
     break;}
 case 557:
-#line 2949 "objc-parse.y"
+#line 2961 "objc-parse.y"
 { objc_receiver_context = 0; ;
     break;}
 case 558:
-#line 2951 "objc-parse.y"
+#line 2963 "objc-parse.y"
 {
 		  yyval.ttype = build_tree_list (yyvsp[-3].ttype, yyvsp[-1].ttype);
 		;
     break;}
 case 562:
-#line 2964 "objc-parse.y"
+#line 2976 "objc-parse.y"
 {
 		  yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype);
 		;
     break;}
 case 563:
-#line 2971 "objc-parse.y"
+#line 2983 "objc-parse.y"
 {
 		  yyval.ttype = build_tree_list (yyvsp[-1].ttype, NULL_TREE);
 		;
     break;}
 case 564:
-#line 2975 "objc-parse.y"
+#line 2987 "objc-parse.y"
 {
 		  yyval.ttype = build_tree_list (NULL_TREE, NULL_TREE);
 		;
     break;}
 case 565:
-#line 2982 "objc-parse.y"
+#line 2994 "objc-parse.y"
 {
 		  yyval.ttype = yyvsp[-1].ttype;
 		;
     break;}
 case 566:
-#line 2989 "objc-parse.y"
+#line 3001 "objc-parse.y"
 {
 		  yyval.ttype = yyvsp[-1].ttype;
 		;
     break;}
 case 567:
-#line 2998 "objc-parse.y"
+#line 3010 "objc-parse.y"
 {
 		  yyval.ttype = groktypename (yyvsp[-1].ttype);
 		;
     break;}
 }
    /* the action file gets copied in in place of this dollarsign */
-#line 498 "/usr/lib/bison.simple"
+#line 543 "/usr/lib/bison.simple"
 
   yyvsp -= yylen;
   yyssp -= yylen;
@@ -5190,6 +5246,30 @@ yyerrhandle:
 
   yystate = yyn;
   goto yynewstate;
+
+ yyacceptlab:
+  /* YYACCEPT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 0;
+
+ yyabortlab:
+  /* YYABORT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 1;
 }
-#line 3003 "objc-parse.y"
+#line 3015 "objc-parse.y"
 
diff --git a/gcc/objc/objc-parse.y b/gcc/objc/objc-parse.y
index 1ad13219c4d..4ab08b0896a 100644
--- a/gcc/objc/objc-parse.y
+++ b/gcc/objc/objc-parse.y
@@ -152,7 +152,7 @@ char *language_string = "GNU Obj-C";
 %type <ttype> init maybeasm
 %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers
 %type <ttype> maybe_attribute attributes attribute attribute_list attrib
-%type <ttype> any_word
+%type <ttype> any_word extension
 
 %type <ttype> compstmt
 
@@ -211,6 +211,17 @@ static tree declspec_stack;
 /* 1 if we explained undeclared var errors.  */
 static int undeclared_variable_notice;
 
+/* For __extension__, save/restore the warning flags which are
+   controlled by __extension__.  */
+#define SAVE_WARN_FLAGS()	\
+	build_int_2 (pedantic | (warn_pointer_arith << 1), 0)
+#define RESTORE_WARN_FLAGS(tval) \
+  do {                                     \
+    int val = TREE_INT_CST_LOW (tval);     \
+    pedantic = val & 1;                    \
+    warn_pointer_arith = (val >> 1) & 1;   \
+  } while (0)
+
 /* Objective-C specific information */
 
 tree objc_interface_context;
@@ -267,7 +278,7 @@ extdef:
 		  else
 		    error ("argument of `asm' is not a constant string"); }
 	| extension extdef
-		{ pedantic = $<itype>1; }
+		{ RESTORE_WARN_FLAGS ($1); }
 	;
 
 datadef:
@@ -406,7 +417,7 @@ unary_expr:
 	/* __extension__ turns off -pedantic for following primary.  */
 	| extension cast_expr	  %prec UNARY
 		{ $$ = $2;
-		  pedantic = $<itype>1; }
+		  RESTORE_WARN_FLAGS ($1); }
 	| unop cast_expr  %prec UNARY
 		{ $$ = build_unary_op ($1, $2, 0);
 		  overflow_warning ($$); }
@@ -957,7 +968,7 @@ decl:
 	| declmods ';'
 		{ pedwarn ("empty declaration"); }
 	| extension decl
-		{ pedantic = $<itype>1; }
+		{ RESTORE_WARN_FLAGS ($1); }
 	;
 
 /* Declspecs which contain at least one type specifier or typedef name.
@@ -1530,7 +1541,7 @@ component_decl:
 		{ $$ = NULL_TREE; }
 	| extension component_decl
 		{ $$ = $2;
-		  pedantic = $<itype>1; }
+		  RESTORE_WARN_FLAGS ($1); }
 	;
 
 components:
@@ -2340,8 +2351,9 @@ identifiers_or_typenames:
 
 extension:
 	EXTENSION
-		{ $<itype>$ = pedantic;
-		  pedantic = 0; }
+		{ $$ = SAVE_WARN_FLAGS();
+		  pedantic = 0;
+		  warn_pointer_arith = 0; }
 	;
 
 /* Objective-C productions.  */
diff --git a/gcc/regmove.c b/gcc/regmove.c
index 800859582c7..27c6d4af12c 100644
--- a/gcc/regmove.c
+++ b/gcc/regmove.c
@@ -693,6 +693,9 @@ optimize_reg_copy_3 (insn, dest, src)
     }
   if (! (set = single_set (p))
       || GET_CODE (SET_SRC (set)) != MEM
+      /* If there's a REG_EQUIV note, this must be an insn that loads an
+	 argument.  Prefer keeping the note over doing this optimization.  */
+      || find_reg_note (p, REG_EQUIV, NULL_RTX)
       || SET_DEST (set) != src_reg)
     return;
 
@@ -737,6 +740,12 @@ optimize_reg_copy_3 (insn, dest, src)
       PUT_MODE (src_reg, old_mode);
       XEXP (src, 0) = src_reg;
     }
+  else
+    {
+      rtx note = find_reg_note (p, REG_EQUAL, NULL_RTX);
+      if (note)
+	remove_note (p, note);
+    }
 }
 
 
diff --git a/gcc/reload1.c b/gcc/reload1.c
index e95ff5e7ef5..24eb0116a7a 100644
--- a/gcc/reload1.c
+++ b/gcc/reload1.c
@@ -4278,9 +4278,6 @@ reload_as_needed (live_known)
 			    spill_reg_order);
 	    }
 
-	  if (num_eliminable && chain->need_elim)
-	    update_eliminable_offsets ();
-
 	  if (n_reloads > 0)
 	    {
 	      rtx next = NEXT_INSN (insn);
@@ -4327,6 +4324,10 @@ reload_as_needed (live_known)
 		      NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;
 		    }
 	    }
+
+	  if (num_eliminable && chain->need_elim)
+	    update_eliminable_offsets ();
+
 	  /* Any previously reloaded spilled pseudo reg, stored in this insn,
 	     is no longer validly lying around to save a future reload.
 	     Note that this does not detect pseudos that were reloaded
@@ -8071,7 +8072,9 @@ delete_output_reload (insn, j, last_reload_reg)
     }
   n_occurrences = count_occurrences (PATTERN (insn), reg);
   if (substed)
-    n_occurrences += count_occurrences (PATTERN (insn), substed);
+    n_occurrences += count_occurrences (PATTERN (insn),
+					eliminate_regs (substed, 0,
+							NULL_RTX));
   if (n_occurrences > n_inherited)
     return;
 
@@ -9967,6 +9970,21 @@ reload_combine_note_use (xp, insn)
 	}
       break;
 
+    case USE:
+      /* If this is the USE of a return value, we can't change it.  */
+      if (GET_CODE (XEXP (x, 0)) == REG && REG_FUNCTION_VALUE_P (XEXP (x, 0)))
+	{
+	/* Mark the return register as used in an unknown fashion.  */
+	  rtx reg = XEXP (x, 0);
+	  int regno = REGNO (reg);
+	  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));
+
+	  while (--nregs >= 0)
+	    reg_state[regno + nregs].use_index = -1;
+	  return;
+	}
+      break;
+
     case CLOBBER:
       if (GET_CODE (SET_DEST (x)) == REG)
 	return;
@@ -9983,12 +10001,23 @@ reload_combine_note_use (xp, insn)
       {
 	int regno = REGNO (x);
 	int use_index;
+	int nregs;
 
 	/* Some spurious USEs of pseudo registers might remain.
 	   Just ignore them.  */
 	if (regno >= FIRST_PSEUDO_REGISTER)
 	  return;
 
+	nregs = HARD_REGNO_NREGS (regno, GET_MODE (x));
+
+	/* We can't substitute into multi-hard-reg uses.  */
+	if (nregs > 1)
+	  {
+	    while (--nregs >= 0)
+	      reg_state[regno + nregs].use_index = -1;
+	    return;
+	  }
+
 	/* If this register is already used in some unknown fashion, we
 	   can't do anything.
 	   If we decrement the index from zero to -1, we can't store more
diff --git a/gcc/rtl.h b/gcc/rtl.h
index efbf588d769..754228f6d5d 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -888,6 +888,12 @@ extern char *note_insn_name[];
 /* For a NOTE_INSN_LIVE note, the original basic block number.  */
 #define RANGE_LIVE_ORIG_BLOCK(INSN) (XINT (INSN, 1))
 
+/* Nonzero if we need to distinguish between the return value of this function
+   and the return value of a function called by this function.  This helps
+   integrate.c.
+   This is 1 until after the rtl generation pass.  */
+extern int rtx_equal_function_value_matters;
+
 /* Generally useful functions.  */
 
 /* The following functions accept a wide integer argument.  Rather than
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
new file mode 100644
index 00000000000..64ec141af16
--- /dev/null
+++ b/gcc/testsuite/ChangeLog
@@ -0,0 +1,3197 @@
+Sun Oct 24 23:54:10 PDT 1999 Jeff Law  (law@cygnus.com)
+
+	* gcc-2.95.2 Released.
+
+Mon Aug 16 01:29:24 PDT 1999 Jeff Law  (law@cygnus.com)
+
+	* gcc-2.95.1 Released.
+
+Wed Jul 28 21:39:31 PDT 1999 Jeff Law  (law@cygnus.com)
+
+	* gcc-2.95 Released.
+
+Sun Jul 25 23:40:51 PDT 1999 Jeff Law  (law@cygnus.com)
+
+	* gcc-2.95 Released.
+
+Sun Jul 25 21:41:37 1999  Jeffrey A Law  (law@cygnus.com)
+
+        * README: More listname related changes.
+
+1999-06-05  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/compile/19990502-0.f: Replace with new,
+	shorter, test that still fails after recent changes.
+
+Wed May 19 02:56:18 1999  Raja R Harinath <harinath@cs.umn.edu>
+
+	* gcc.c-torture/compile/990519-1.c: New test.
+
+1999-05-17  Andreas Schwab  <schwab@issan.cs.uni-dortmund.de>
+
+	* gcc.c-torture/compile/990517-1.c: New test.
+
+	* gcc.c-torture/execute/990326-1.c: Force bitfields to be aligned.
+	(e4, f4): New tests.
+	(main): Call them.
+
+1999-05-13  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.dg/noreturn-1.c: New test.
+
+Thu May 13 02:02:46 1999  Andreas Schwab <schwab@issan.cs.uni-dortmund.de>
+
+	* gcc.c-torture/execute/990513-1.c: New test.
+
+1999-05-10  Richard Henderson  <rth@cygnus.com>
+
+	* g++.old-deja/g++.other/null1.C (g): Add overload for long.
+
+1999-05-10  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/erfc.f: Use small single-precision
+	values, to avoid problems on Alphas when not -mieee.
+
+1999-05-08  Craig Burley  <craig@jcb-sc.com>
+
+	* gcc.dg/990506-0.c: New test.
+
+1999-05-08  Richard Henderson  <rth@cygnus.com>
+
+	* g++.old-deja/g++.benjamin/p12475.C: Use LONG_MAX to find
+	the constant to test.  Don't XFAIL 64-bit targets.
+
+	* g++.old-deja/g++.jason/thunk3.C: Don't XFAIL Alpha.
+	* g++.old-deja/g++.law/profile1.C: Likewise.
+
+	* g++.old-deja/g++.other/delete4.C: Define size_t; use it in all
+	operator new instances.
+	* g++.old-deja/g++.other/delete5.C: Likewise.
+
+1999-05-03  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/u77-test.f (main): Declare ABORT as
+	intrinsic.
+
+1999-05-03  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/u77-test.f: Reverse order of two
+	arguments to CTIME_subr, DTIME_subr, ETIME_subr, and TTYNAM_subr.
+
+1999-05-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.dg/compare1.c: New test.
+
+1999-05-02  Joseph S. Myers  <jsm28@cam.ac.uk>
+
+	* gcc.dg/cast-qual-1.c, gcc.dg/return-type-1.c, gcc.dg/unused-1.c:
+	New tests.
+
+1999-05-02  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/compile/19990502-1.f: New test.
+
+1999-05-02  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/compile/19990502-0.f: New test.
+
+Sun May  2 01:38:50 1999  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/u77-test.f (main): Declare FTELL as
+	intrinsic.
+
+Sun May  2 01:13:37 1999  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/u77-test.f (main): List libU77
+	intrinsics not currently tested.
+	Add tests for TIME8, CTIME_subr, IARGC, TTYNAM_subr,
+	GETENV, FDATE_subr, DTIME_subr, ETIME_subr, DATE, ITIME,
+	FTELL_subr, MCLOCK, MCLOCK8, and CPU_TIME.
+	Trim blanks off the ends of some printed strings.
+
+Sun May  2 00:06:45 1999  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/u77-test.f (main): Just warn about
+	FSTAT gid disagreement, as it's expected on some systems.
+
+Sat May  1 23:57:18 1999  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/u77-test.f: Generalize sum-checking to
+	use a new function, which allows for some slop.
+	Clean up some commentary.
+	(issum): The new function.
+	(sgladd): Deleted subroutine.
+
+1999-05-01  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/u77-test.f: Modify to be more like
+	libf2c/libU77 version, bringing patches to that version here.
+	Add suitable commentary.
+
+Sun Apr 25 12:28:59 1999  Richard Henderson  <rth@cygnus.com>
+
+	* gcc.dg/990424-1.c: New test.
+
+1999-04-24  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/u77-test.f (main): Bug involving
+	LSTAT has been fixed, so turn back on full checking.
+
+1999-04-20  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/compile/19990419-0.f: New test.
+	* g77.f-torture/execute/19990419-1.f: New test.
+
+Sat Apr 17 16:56:48 1999  Richard Henderson  <rth@cygnus.com>
+
+	* gcc.dg/uninit-9.c (func): Use __builtin_alloca instead of alloca
+	to avoid the need for a prototype to supress a warning.
+
+Sun Apr  4 04:02:53 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/990404-1.c: New test.
+
+1999-04-03 10:35 -0500  Zack Weinberg  <zack@rabi.columbia.edu>
+
+	* gcc.dg/cpp-if1.c: Adjust regexps to accommodate cccp.
+	* gcc.dg/cpp-if3.c: Don't use -pedantic.
+	* gcc.misc-tests/m-un-2.c: Adjust regexps for new format of
+	missing initializer warnings.
+
+Sun Mar 28 00:49:41 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* lib/objc-torture.exp: Replace "77" with "Obj-C" in pattern
+	matching strings.
+
+Fri Mar 26 00:50:46 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/990326-1.c: New test from Charles Hannum.
+
+1999-03-26  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/19990325-0.f: New test.
+	* g77.f-torture/execute/19990325-1.f: New test.
+
+Wed Mar 24 22:50:50 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/990324-1.c: New test.
+
+1999-03-13  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/19990313-2.f: New test.
+	* g77.f-torture/execute/19990313-3.f: New test.
+
+1999-03-13  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/19990313-0.f: New test.
+	* g77.f-torture/execute/19990313-1.f: New test.
+
+1999-03-08  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/19981119-0.f: Improve testiness.
+
+1999-03-08  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/compile/19990305-0.f: New test.
+	* g77.f-torture/execute/19981119-0.f: New test.
+
+1999-03-08  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/970625-2.f: call ABORT if final
+	result is not correct, instead of just printing it.
+	Add this checking via newly introduced obfuscation, to
+	trip up buggy front ends.
+
+1999-03-07  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/compile/960317-1.f: Moved from being
+	in execute/.  (Somehow I didn't notice "SUBROUTINE...".)
+
+1999-03-06  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/execute/960317-1.f: New (old) test.
+	* g77.f-torture/execute/970625-2.f: Ditto.
+
+Mon Mar  1 23:29:14 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* g++.old-deja/g++.law/weak1.C: New test.
+
+1999-02-28 17:59 -0500  Zack Weinberg  <zack@rabi.columbia.edu>
+
+	* gcc.c-torture/execute/990119-1.c: Renamed to...
+	* gcc.dg/990119-1.c: this, so it will only be tested once
+	(it's a preprocessor test, it doesn't need to be run at
+	multiple optimization levels).
+
+1999-02-27 13:34 -0500  Zack Weinberg  <zack@rabi.columbia.edu>
+
+	* lib/g++.exp: Don't add incdir=$base_dir/../include to
+        ALWAYS_CXXFLAGS.
+
+1999-02-24  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/noncompile/19981216-0.f: Renamed from...
+	* g77.f-torture/compile/19981216-0.f: ...as it is expected
+	to not be compilable by current g77.
+
+1999-02-24  Nick Clifton  <nickc@cygnus.com>
+
+	* lib/c-torture.exp: Add -O3 to TORTURE_OPTIONS list.
+
+Mon Feb 22 01:15:08 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/990222-1.c: New test.
+
+1999-02-19  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/compile/19990218-0.f: New test.
+	* g77.f-torture/noncompile/19990218-1.f: New test.
+
+1999-02-18  Craig Burley  <craig@jcb-sc.com>
+
+	* g77.f-torture/compile/19981216-0.f: New test.
+
+Sun Feb 14 01:26:29 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/990214-1.c: New test.
+
+Sat Feb 13 00:43:52 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/990213-2.c: New test.
+
+	* gcc.dg/990213-1.c: New test.
+
+Fri Feb 12 11:04:35 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/990106-2.c: Update to work on targets with 16bit
+	ints.
+
+1999-02-11  Nick Clifton  <nickc@cygnus.com>
+
+	* lib/gcc.exp (proc gcc_target_compile): Add support for timeout
+	specified by target.
+
+	* lib/chill.exp: Fix typo: doesn'timeout -> doesn't
+
+Thu Feb 11 01:12:12 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/990211-1.c: New test from Nathan SIdwell.
+
+Wed Feb 10 13:08:12 1999  Jonathan Larmour  <jlarmour@cygnus.co.uk>
+
+	* gcc.dg/special/ecos.exp: New test driver for new tests with
+	special requirements.
+
+	* gcc.dg/special/alias-1.c: New test.
+	* gcc.dg/special/gcsec-1.c: New test.
+	* gcc.dg/special/weak-1.c: New test.
+	* gcc.dg/special/weak-1a.c: Accompanying file to weak-1.c.
+	* gcc.dg/special/weak-2.c: New test.
+	* gcc.dg/special/weak-2a.c: Accompanying file to weak-2.c.
+	* gcc.dg/special/weak-2b.c: Accompanying file to weak-2.c.
+	* gcc.dg/special/wkali-1.c: New test.
+	* gcc.dg/special/wkali-2.c: New test.
+	* gcc.dg/special/wkali-2a.c: Accompanying file to wkali-2.c.
+	* gcc.dg/special/wkali-2b.c: Accompanying file to wkali-2.c.
+
+Wed Feb 10 12:15:35 1999  Felix Lee  <flee@cygnus.com>
+
+        * lib/c-torture.exp (c-torture-compile): Pull out code for
+        analyzing gcc error messages.
+        (c-torture-execute): Likewise.  Fix some (harmless) false
+        positives.
+        * lib/gcc.exp (gcc_check_compile): New function.
+
+Mon Feb  8 21:42:57 1999  Richard Henderson  <rth@cygnus.com>
+
+	* gcc.c-torture/execute/990208-1.c: New test.
+
+1999-02-07  Jonathan Larmour  <jlarmour@cygnus.co.uk>
+
+	* g++.dg/special/ecos.exp: New driver for new tests with special
+	requirements
+	
+	* g++.dg/special/conpr-1.C: New test
+	* g++.dg/special/conpr-2.C: New test
+	* g++.dg/special/conpr-2a.C: New test
+	* g++.dg/special/conpr-3.C: New test
+	* g++.dg/special/conpr-3a.C: New test
+	* g++.dg/special/conpr-3b.C: New test
+	
+	* lib/g++-dg.exp: New driver file, based on lib/gcc-dg.exp to
+	allow g++ to use the dg driver
+
+	* README: Add comment about g++.dg directory
+
+Sat Feb  6 18:00:38 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* README: Update email addresses.
+
+Sat Jan 30 16:22:47 1999  Richard Henderson  <rth@cygnus.com>
+
+	* gcc.c-torture/execute/990130-1.c: New test.
+
+Sat Jan 30 11:10:06 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/990130-1.c: New test.
+
+1999-01-27  Felix Lee  <flee@cygnus.com>
+
+	* lib/c-torture.exp (c-torture-compile): pull out code for
+	analyzing gcc error messages.
+	(c-torture-execute): ditto, and fix some (harmless) false
+	positives.
+	* lib/gcc.exp (gcc_check_compile): new function.
+
+Sun Jan 17 00:02:33 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/990117-1.c: New test.
+
+	* gcc.c-torture/compile/990117-1.c: New test from Horst von Brand.
+
+	* gcc.c-torture/execute/990117-1.c: New test from HJ Lu.
+
+Fri Jan 15 02:52:00 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* g77.f-torture/compile/990115-1.f: New test.
+
+Thu Jan  7 23:39:47 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/compile/990107-1.c: New test
+
+Wed Jan  6 02:21:59 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/990106-2.c: New test.
+
+	* gcc.c-torture/execute/990106-1.c: New test.
+
+Wed Dec 30 23:05:28 1998  Zack Weinberg <zack@rabi.columbia.edu>
+
+	* gcc.c-torture/compile/981223-1.c: New test.
+
+Tue Dec 29 11:33:25 1998  Richard Henderson  <rth@cygnus.com>
+
+	* gcc.c-torture/execute/bcp-1.c (bad10): Rename from opt3.
+	(opt3): Rename from opt4 and disable.
+
+1998-12-20  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/ptrmem5.C: New test.
+
+1998-12-15  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/conv5.C: New test.
+
+Fri Dec 11 10:25:57 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* g++.old-deja/g++.benjamin/p12475.C: Expect failure on mips64 targets.
+
+Fri Dec 11 01:12:45 1998  Zack Weinberg <zack@rabi.columbia.edu>
+
+	* gcc.c-torture/compile/981211-1.c: New test.
+
+1998-12-09  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* gcc.dg/ultrasp1.c: Empty dg-options, avoid `long long' warnings.
+
+	* g++.old-deja/g++.pt/instantiate6.C: Linker error, not	crash.
+
+Tue Dec  8 22:50:04 1998  Franz Sirl <Franz.Sirl-kernel@lauterbach.com>
+
+	* gcc.special/930510-1.c: Make C9X safe.
+	* gcc.misc-tests/gcov-1.c Similarly.
+	* gcc.misc-tests/gcov-2.c Similarly.
+
+1998-12-06  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* gcc.dg/ultrasp1.c: New test.
+
+Sun Dec  6 00:40:12 1998  Richard Henderson  <rth@cygnus.com>
+
+	* gcc.c-torture/execute/981206.c: New test.
+
+1998-12-06  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.ns/template7.C: New test.
+
+	* g++.old-deja/g++.other/expr1.C: New test.
+
+	* g++.old-deja/g++.eh/tmpl3.C: New test.
+
+	* g++.old-deja/g++.eh/tmpl2.C: New test.
+
+1998-12-04  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/using5.C: Usified using[567].C here.
+	* g++.old-deja/g++.other/using6.C: Removed.
+	* g++.old-deja/g++.other/using7.C: Mark Mitchel removed it.
+
+	* g++.old-deja/g++.pt/spec20.C: Re-insert non-bogus ERROR marks.
+
+1998-12-03  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/overload8.C: New test.
+
+	* g++.old-deja/g++.pt/overload7.C: New test.
+
+	* g++.old-deja/g++.pt/spec20.C: ERROR marks were bogus.
+
+	* lib/old-dejagnu.exp (old-dejagnu): Ignore collect recompiling
+	and relinking messages.
+	* lib/g++.exp (g++_target_compile): Remove .rpo file when
+	compiling with -frepo.
+
+1998-12-01  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/lookup6.C: New test.
+
+1998-11-27  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/explicit76.C: New test.
+
+	* g++.old-deja/g++.pt/friend38.C: New test.
+
+	* g++.old-deja/g++.ns/crash2.C: New test.
+
+	* g++.old-deja/g++.pt/defarg8.C: New test.
+
+	* g++.old-deja/g++.pt/instantiate6.C: New test.
+
+	* g++.old-deja/g++.pt/static6.C: New test.
+
+	* g++.old-deja/g++.pt/decl2.C: New test.
+
+1998-11-26  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/lookup5.C: New test.  Not sure the
+	problem is actually related with name lookup, but so what? :-)
+
+	* g++.old-deja/g++.pt/friend37.C: New test.
+
+1998-11-25  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/u77-test.f (main): Avoid testing [f]statb
+	element, which fails on some systems.
+
+	* g77.f-torture/execute/labug1.f: New test.
+
+Sat Nov 21 21:41:05 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/980526-1.c: Do nothing if NO_LABEL_VALUES
+	is defined.
+
+1998-11-18  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/compile/981117-1.f: New test.
+
+1998-11-16  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.eh/throw2.C: New test.  CV-qualifiers are not
+ 	properly discarded.
+
+1998-11-07  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>
+
+	* README: New file, general information about the testsuite and 
+	new description of the various C++ test subdirectories.
+	* README.g++: Eliminate obsolete information, update and move most
+	relevant stuff to README.
+
+Sat Nov  7 02:55:55 1998  Richard Henderson  <rth@cygnus.com>
+
+	* gcc.c-torture/compile/981107-1.c: New test.
+
+Mon Nov  2 11:16:03 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* execute/memcpy-bi.c: New testcase.
+
+1998-10-31  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/sizeof3.C: A similar testcase not involving
+	base classes.
+
+	* g++.old-deja/g++.pt/sizeof2.C: Incorrect specialization of base
+	template is selected.
+
+	* g++.old-deja/g++.ext/arrnew2.C: If new T[n](i) is accepted for
+	classes, it should be accepted for all types.
+
+	* g++.old-deja/g++.eh/sjlj1.C: Test checked sjlj-exception.
+
+	* g++.old-deja/g++.pt/spec24.C: Ensure that template
+	specializations start with template headers.
+
+1998-10-29  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/dcast2.C: Cannot dynamic downcast &x.
+
+	* g++.old-deja/g++.other/init9.C: Test cross initialization of
+	non-POD types.
+
+1998-10-27  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* lib/old-dejagnu.exp (old-dejagnu): Document `Additional sources'.
+
+Thu Oct 22 16:01:44 1998  Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>
+
+	* compile/981022-1.c, compile/981022-1.x: New test and driver.
+
+Mon Oct 19 14:03:07 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* 981019-1.c: New test.
+
+Wed Oct 14 21:11:19 1998  Robert Lipe <robertl@dgii.com>
+
+	* lib/objc-torture.exp (objc-torture-execute): Add -I so we can
+ 	find objc headers.
+
+1998-10-14  Andreas Schwab  <schwab@issan.cs.uni-dortmund.de>
+
+	* compile/981001-4.c: Remove use of GCC extension that triggers a
+	compiler bug.
+
+1998-10-13  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* lib/old-dejagnu.exp (old-dejagnu): Support `Additional sources:'.
+
+1998-10-12  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/explicit74.C: New test.  Explicit
+ 	instantiation of template produces incorrect code for delete
+ 	expression.
+
+	* g++.old-deja/g++.pt/instantiate5.C: New test.  `global
+	constructors' name is not unique.
+	* g++.old-deja/g++.pt/instantiate5.cc: Ditto.
+	* g++.old-deja/g++.pt/instantiate5-main.cc: Ditto.
+
+	* g++.old-deja/g++.other/init8.C: New test.  Uninitialized
+ 	automatic array of const is ill-formed.
+
+	* g++.old-deja/g++.pt/ttp53.C: New test.  Incorrect substitution
+	of template parameter?
+
+	* g++.old-deja/g++.other/conv3.C: New test.  Conversion discards
+	const.
+
+	* g++.old-deja/g++.other/pmf2.C: New test.  Invalid
+	pointer-to-member expression.
+
+	* g++.old-deja/g++.other/friend5.C: New test.  Bogus friend
+	declaration causes ICE.
+
+1998-10-11  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.ns/main1.C: New test.  main() should only be
+ 	reserved in the global namespace.
+
+	* g++.old-deja/g++.pt/instantiate4.C: New test: -frepo does not
+	generate needed virtual table.
+
+	* lib/old-dejagnu.exp (old-dejagnu): Support `Build then link:'.
+
+1998-10-10  Dariush Eslimi  <eslimi@loran.com>
+
+	* g++.old-deja/g++.ext/typeof1.C: New test; typeof based on
+	template-dependent type
+
+1998-10-10  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.brendan/parse3.C: XFAILs, not ERRORs.
+	* g++.old-deja/g++.brendan/parse5.C: XFAILs, not ERRORs.
+	* g++.old-deja/g++.brendan/parse6.C: XFAILs, not ERRORs.
+
+	* g++.old-deja/g++.other/using5.C: New test; using decl from base
+ 	class should be usable as argument of member function.
+	* g++.old-deja/g++.other/using6.C: New test; using decl from base
+ 	class should be usable as return type of member function.
+	* g++.old-deja/g++.other/using7.C: New test; using decl from base
+ 	class should be usable as type of data member.
+
+	* g++.old-deja/g++.ns/extern1.C: Fix XFAIL mark.
+
+Fri Oct  9 19:19:19 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/special/920521-1.c: Fix bogus test.
+
+Thu Oct  8 19:14:05 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* gcc.dg/dll-?.c Add thumb to target list.
+	Fix assembler scan patterns to match current assembler output.
+
+1998-10-08  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/expr6.C: New test.  operator?: breaks
+	matching of template brackets.
+
+	* g++.old-deja/g++.other/using4.C: New test.  Test using
+ 	declarations of methods from base classes.
+
+	* g++.old-deja/g++.ns/extern1.C: New test.  Extern declarations
+ 	within functions should introduce names into the innermost
+ 	enclosing namespace.
+
+	* g++.old-deja/g++.other/init7.C: New test.  Retry initialization
+ 	of static locals if first initialization throws.
+
+Wed Oct  7 12:00:20 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* gcc.c-torture/compile/981007-1.c: New test for irix6 -O0 core dump.
+
+1998-10-06  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/friend35.C: New test.  A template function
+ 	must be declared before its specializations can be named in friend
+ 	declarations.
+
+1998-10-05  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/u77-test.f: Add regression test for RAND.
+
+	* g77.f-torture/execute/io1.f: New test.
+
+1998-10-04  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/overload5.C: New test; initialize variable
+ 	with pointer to template function, for which no argument deduction
+ 	is possible.
+
+	* g++.old-deja/g++.pt/overload4.C: New test; passing pointer to
+	specialization of template function as argument to template
+	function.
+
+	* g++.old-deja/g++.other/access2.C: New test; Inner class
+	shouldn't have privileged access to Outer's names.
+
+1998-10-03  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/friend34.C: New test; name injection of
+	friend template declared within template class conflicts with
+	nested class of the same name.
+
+	* g++.old-deja/g++.other/badopt1.C: New test; post-increment
+ 	is ignored.
+
+	* g++.old-deja/g++.other/decl1.C: New test; incorrect parsing of
+	object with direct initializer as function declaration.
+
+	* g++.old-deja/g++.other/decl2.C: New test; duplicate
+	initializers.
+
+	* g++.old-deja/g++.other/null2.C: New test; conditional operator
+ 	involving const pointer and NULL produces incorrect result.
+
+	* g++.old-deja/g++.other/typename1.C: New test; template-dependent
+ 	type name without `typename' should be rejected with -pedantic.
+
+Fri Oct  2 21:55:58 1998  Richard Henderson  <rth@cygnus.com>
+
+	* g++.old-deja/g++.other/addrof1.C: New test.
+
+Thu Oct  1 19:05:20 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/compile/981001-2.c: New test.
+	* gcc.c-torture/compile/981001-3.c: New test.
+	* gcc.c-torture/compile/981001-4.c: New test.
+
+1998-10-01  Robert Lipe  <robertl@dgii.com>
+
+	* lib/objc.exp (objc_target_compile): Add -L during compiles for
+	multilibbed hosts.   Idea grafted from g77.exp.
+
+1998-09-30  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/u77-test.f (main): Excise `hostnm' to
+	avoid losing on systems which need -lsocket.
+
+1998-09-28  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/bitfld1.C: Expected failure.
+	* g++.old-deja/g++.other/nested2.C: Ditto.
+	* g++.old-deja/g++.robertl/eb132.C: No longer an expected
+	failure.
+
+1998-09-26  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/bitfld1.C: Built-in operator!= should be
+	preferred over template operator!= for enum bitfields.
+
+1998-09-18  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/nested2.C: Different virtual base classes
+ 	that happen to have the same base name, but in different scopes,
+ 	are incorrectly rejected.
+
+1998-09-16  Richard Henderson  <rth@cygnus.com>
+
+	* g++.old-deja/g++.brendan/array1.C: Size array via arithmetic based
+	on the native word size instead of an integer literal.
+
+1998-09-15  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/static2.C: Invocation of static data
+ 	member of type pointer-to-function denoted as non-static member.
+
+	* g++.old-deja/g++.other/typedef5.C: Add some more tests involving 
+	checks involving function types and aliases.
+
+1998-09-12  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/typedef5.C: Check whether typedefs can be
+ 	redefined to the same non-trivial type.
+
+	* g++.old-deja/g++.pt/explicit73.C: Test for proper
+ 	namespace-qualification of template specializations declared in
+ 	other namespaces.
+
+	* g++.old-deja/g++.other/friend4.C: Check whether it is possible
+	to declare a subset of the specializations of a template function
+	as friends of specializations of a template class.
+
+	* g++.old-deja/g++.pt/explicit71.C: Make sure specializations of
+ 	member templates that do not fully specialize the enclosing
+ 	template class are rejected.
+
+1998-09-11  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/u77-test.f: Fix bad consistency checks.
+
+1998-09-08  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/u77-test.f (main): New file, somewhat
+	altered from libf2c/libU77 version.
+
+1998-09-06  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/io0.f: Test formatted direct i/o too.
+
+1998-09-04  Reid M. Pinchback  <reidmp@MIT.EDU>, Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.pt/explicit72.C: Ensure that char and
+	(un)signed char are different types for template specialization
+	purposes.
+
+Thu Sep  3 00:40:32 1998  Ovidiu Predescu  <ovidiu@aracnet.com>
+
+	* lib/{objc.exp,objc-torture.exp}: New files for objc testing harness.
+	* objc: ObjC testsuite.
+
+Mon Aug 31 15:19:32 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* lib/c-torture.exp: Add support for
+	torture_eval_before_compile and torture_eval_before_execute
+	variables.
+
+Sun Aug 30 17:38:20 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/980626-1.c: Delete this test.  We've declared the warning
+	this test triggers valid.
+
+Thu Aug 27 23:59:18 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/980827-1.c: New test.
+
+Wed Aug 26 16:25:38 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* lib/c-torture.exp: Add support for
+	torture_eval_before_compile and torture_eval_before_execute
+	variables.
+
+Tue Aug 25 19:42:13 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/compile/980825-1.c: New test.
+
+Mon Aug 24 16:38:52 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/compile/930326-1.x: Fix typo.
+
+1998-08-23  Mark Mitchell  <mark@markmitchell.com>
+
+	* lib/old-dejagnu.exp: Make it possible to XFAIL a test that
+	causes an ICE.
+
+Fri Aug 21 23:59:18 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/unsorted/memtst.c: Reduce size of array when
+	STACK_SIZE is defined.
+	* gcc.c-torture/unsorted/stuct.c: Similarly.
+
+	* gcc.c-torture/compile/980821-1.c: New test.
+
+Fri Aug 21 03:14:04 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/980526-2.c: Disable for targets with 16bit ints.
+
+1998-08-19  Mark Mitchell  <mark@markmitchell.com>
+
+	* lib/old-dejagnu.exp (old-dejagnu): Remove sig6/sig11 handling
+	code. 
+
+1998-08-09  Mark Mitchell  <mark@markmitchell.com>
+
+	* lib/old-dejagnu.exp: Revise handling of `Internal compiler
+	error'.
+
+Tue Aug 18 19:19:50 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/*.x: Some updates for the h8300 targets.
+
+Sun Aug 16 01:29:19 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/compile/980816-1.c: New test.
+
+	* gcc.dg/980816-1.c: New test.
+
+1998-08-01  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/compile/980729-0.f: New test.
+
+1998-07-30  Ken Raeburn  <raeburn@cygnus.com>
+
+	* gcc.c-torture/special/eeprof-1.c: New test, for
+	-finstrument-functions.
+	* gcc.c-torture/special/special.exp: Run it.
+
+Wed Jul 29 00:17:18 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/compile/980729-1.c: New test.
+
+1998-07-26  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/noncompile/980615-0.f: New test.
+
+Sun Jul 26 01:15:56 1998  H.J. Lu  (hjl@gnu.org)
+
+	* gcc.dg/980312-1.c: Do link instead of compile.
+	* gcc.dg/980313-1.c: Likewise.
+
+Sun Jul 26 01:05:02 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/compile/980726-1.c: New test.
+
+1998-07-25  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/io0.f: New test.
+
+Fri Jul 17 14:19:32 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* gcc.dg/980626-1.c: Expect failures for all toolchains until
+	c-decl.c:grokdeclarator can handle mode attributes.
+
+Thu Jul 16 21:42:50 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/980716-1.c: New test.
+
+Mon Jul 13 22:26:37 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/920715-1.x: No longer expected to fail on
+	the mn10200.
+	* gcc.c-torture/execute/strct-varg-1.x: New file.  Expect failure on
+	the mn10200.
+	* gcc.c-torture/execute/va-arg-3.x: Similarly.
+	* gcc.c-torture/compile/930326-1.x: Similarly.
+
+1998-07-13  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/auto0.f, g77.f-torture/execute/auto1.f:
+	New test from Craig.
+
+1998-07-12  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/noncompile/980616-0.f: New test.
+
+	* g77.f-torture/execute/970816-3.f:  New test from Craig.
+
+Fri Jul 10 23:43:33 1998 Martin von Loewis <martin@mira.isdn.cs.tu-berlin.de>
+	
+	*  g++.other/singleton.C: Return error value instead of taking
+	SIGSEGV.
+
+Fri Jul 10 10:02:03 1998  Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de> 
+
+	*  g++.other/singleton.C: New test.   Warning is under dispute.
+	Runtime crash is not.
+
+Thu Jul  9 23:07:45 1998  Martin von Loewis <martin@mira.isdn.cs.tu-berlin.de>
+
+	* g++.ns/{alias2.C, alias5.C, koenig4.C, lookup3.C ns13.C, 
+	ns14.C, ns15.C, template3.C, undef1.C, using4.C, using5.C, 
+	using6.C, using7.C}:  New namespace tests.
+
+Thu Jul  9 22:44:49 1998  Alexandre Oliva   <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/partspec1.C: Test matching of partial
+	specialization with typedef'ed names used as array indexes.
+
+Thu Jul  9 00:38:51 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/980709-1.c: New test.
+
+	* gcc.dg/980709-1.c: New test.
+
+Tue Jul  7 13:41:27 1998  Richard Henderson  <rth@cygnus.com>
+
+	* gcc.c-torture/execute/bcp-1.c: New test.
+
+Tue Jul  7 11:49:04 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/980707-1.c: New test.
+
+Mon Jul  6 18:20:27 1998  Kamil Iskra  <iskra@student.uci.agh.edu.pl>
+
+	* gcc.c-torture/compile/980706-1.c: New test.
+
+1998-07-01  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/980701-0.f,
+	g77.f-torture/execute/980701-1.f: New test from Craig.
+
+Wed Jul  1 00:52:51 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/compile/980701-1.c: New test.
+
+	* gcc.c-torture/execute/980701-1.c: New test.
+
+Tue Jun 30 11:51:42 1998  Klaus-Georg Adams  <Klaus-Georg.Adams@chemie.uni-ka
+rlsruhe.de>
+
+	* g++.old-deja/g++.robertl/eb132.C: New test.
+	* g++.old-deja/g++.robertl/eb133.C: Likewise.
+
+1998-06-29  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/980628-7.f,
+	g77.f-torture/execute/980628-8.f,
+	g77.f-torture/execute/980628-9.f,
+	g77.f-torture/execute/980628-10.f: New tests from Craig.
+
+	* g77.f-torture/execute/980628-3.f: Remove mail headers.
+
+Sun Jun 28 12:49:02 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* g77.f-torture/execute/980628-4.f: New test from Craig.
+	* g77.f-torture/execute/980628-5.f: Likewise.
+	* g77.f-torture/execute/980628-2.f: Likewise.
+	* g77.f-torture/execute/980628-0.f: Likewise.
+	* g77.f-torture/execute/980628-1.f: Likewise.
+	* g77.f-torture/execute/980628-3.f: Likewise.
+	* g77.f-torture/execute/980628-6.f: Likewise.
+
+Sun Jun 28 00:37:26 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* lib/g77.exp (default_g77_version): Tweak to make it work in a build
+	directory when nothing has been installed yet.
+
+Sat Jun 27 23:23:18 1998  Carlo Wood  <carlo@runaway.xs4all.nl>
+
+	* gcc.c-torture/special/special.exp: Handle newer versions of
+	dejagnu.
+
+Fri Jun 26 17:57:40 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/980626-1.c: New test.
+
+Fri Jun 19 23:26:12 1998  Bruno Haible <haible@ilog.fr>
+
+	* gcc.misc-tests/m-un-2.c: New test.
+	* g++.old-deja/g++.other/warn01.c: Likewise.
+
+Fri Jun 19 14:06:36 1998  Robert Lipe  <robertl@dgii.com>
+	
+	* gcc.dg/980414-1.c: Move comments outside of ASM to improve
+	compatibility with assmblers with a different comment character.
+	Eliminate use of GAS-specific extensions. 
+
+Fri Jun 19 02:05:14 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/ieee/980619-1.c: New test.
+
+Fri Jun 19 00:58:11 1998  Robert Lipe  <robertl@dgii.com>
+
+	*lib/g77.exp: Replace search for libf2c.a with search for newly
+	renamed libg2c.a
+
+Wed Jun 17 18:53:12 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/980617-1.c: New test.
+
+Fri Jun 12 01:08:49 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/980612-1.c: New test.
+
+Mon Jun  8 02:13:42 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/980523-1.c: Only test on ppc-linux.
+	* gcc.dg/980526-1.c, gcc.dg/switch-1.c: Likewise.
+
+	* gcc.c-torture/execute/980608-1.c: New test.
+
+Thu Jun  4 01:39:24 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/980604-1.c: New test.
+
+Tue Jun  2 20:51:43 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/980602-1.c: New test.
+	* gcc.c-torture/execute/980602-2.c: Likewise.
+
+1998-06-02  Dave Love  <d.love@dl.ac.uk>
+
+	* 970125-0.f: Fix per JCB.  Add commentary.
+
+Fri May 29 01:10:12 1998  Peter Leven <leven@lpr.e-technik.tu-muenchen.de>
+
+	* gcc.c-torture/execute/ieee/fp-cmp-1.c: Set up signal handler
+	earlier.
+
+Thu May 28 00:17:42 1998  Catherine Moore <clm@cygnus.com>
+
+	* gcc.c-torture/execute/980526-3.c: New test.
+
+1998-05-27  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* g++.old-deja/g++.jason/thunk2.C: Setup this test to be expected to
+	fail on m68k-motorola-sysv and m88k-motorola-sysv3.
+	* g++.old-deja/g++.jason/thunk3.C: Add m68k-motorola-sysv and
+	m88k-motorola-sysv3 to XFAIL.
+
+Tue May 26 23:58:03 1998  Franz Sirl <Franz.Sirl-kernel@lauterbach.com>
+
+	* gcc.dg/980526-1.c: New test.
+	* gcc.c-torture/execute/980526-2.c: New test.
+
+Tue May 26 23:40:40 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/980523-1.c: Change "ppc" to "powerpc".
+
+	* gcc.c-torture/execute/980526-1.c: New test.
+
+1998-05-26  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/alpha2.f: Add runtime test.
+
+1998-05-24  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* g++.old-deja/old-deja.exp: Strip leading directories.
+
+	* lib/old-dejagnu.exp: All tests fail if we got an internal compiler
+	error for the line.  Don't run multiple tests for the same line.
+
+Sat May 23 23:27:10 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/980523-1.c: New test.
+
+1998-05-23  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/compile/970915-0.f: New test.
+
+1998-05-23  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* lib/old-dejagnu.exp: Ignore C++ "instantiated from" mesages.
+
+Thu May 21 23:23:21 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/980520-1.c: New test.
+
+Wed May 20 14:37:15 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* gcc.dg/980502-1.c: Fix return type.
+
+Wed May 20 11:29:48 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/{980502-1.c, clobbers.c}: New tests.
+	* gcc.c-torture/compile/{980504-1.c, 980506-1.c}: Likewise.
+	* gcc.c-torture/compile/{980506-2.c, 980611-1.c}: Likewise.
+	* gcc.c-torture/execute/{980505-1.c, 980505-2.c, 980506-1.c}: Likewise.
+	* gcc.c-torture/execute/{980506-2.c, 980506-3.c}: Likewise.
+
+1998-05-20  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/980520-1.f: New test.
+
+1998-05-15  Dave Love  <d.love@dl.ac.uk>
+
+	* lib/mike-g77.exp: New file.
+
+	* g77.f-torture/noncompile/noncompile.exp,
+	g77.f-torture/noncompile/check0.f: New files.
+
+1998-05-14  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/short.f, g77.f-torture/execute/le.f,
+	g77.f-torture/execute/exp.f, g77.f-torture/execute/erfc.f,
+	g77.f-torture/execute/dnrm2.f, g77.f-torture/execute/dcomplex.f,
+	g77.f-torture/execute/cpp.F, g77.f-torture/execute/complex_1.f,
+	g77.f-torture/execute/claus.f, g77.f-torture/execute/cabs.f: Call
+	abort where appropriate.
+
+Tue May  5 19:20:13 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* lib/c-torture.exp (TORTURE_OPTIONS): Add -Os to options.
+	* lib/f-torture.exp (TORTURE_OPTIONS): Ditto.
+
+1998-04-29  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/compile/980419-1.f: Removed since doesn't compile.
+
+1998-04-27  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/compile/980427-0.f: New test.
+
+1998-04-24  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/compile/980424-0.f: New test.
+
+1998-04-19  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/compile/980419-2.f (main): New test.
+	* g77.f-torture/compile/970125-0.f: New test.
+	* g77.f-torture/compile/980419-1.f: New test.
+
+Wed Mar 18 16:22:22 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* gcc.dg/980313-1.c: New test for fp conditional move on PPro.
+	* gcc.dg/980312-1.c: Fix typo in -march command.
+
+Mon Mar 16 20:01:30 1998  H.J. Lu  (hjl@gnu.org)
+
+	* gcc.dg/980312-1.c: New test for fp conditional move on PPro.
+
+Wed Mar 11 13:08:48 1998  Robert Lipe  <robertl@dgii.com>
+
+	* g77.f-torture/execute/980310-5.f: Deleted.  Craig Burley and
+	Dave Love agree the Fortran source is bogus.
+
+Wed Mar 11 00:03:49 1998  Robert Lipe  <robertl@dgii.com>
+
+	* g77.f-torture/compile/980310-1.f, g77.f-torture/compile/980310-2.f
+	g77.f-torture/compile/980310-3.f, g77.f-torture/compile/980310-4.f
+	g77.f-torture/compile/980310-6.f, g77.f-torture/compile/980310-7.f
+	g77.f-torture/compile/980310-8.f: New tests from egcs-bugs archives.
+	* g77.f-torture/execute/980310-5.f: New test from egcs-bugs archives.
+
+Tue Mar 10 00:31:51 1998  Alexandre Oliva   <oliva@dcc.unicamp.br>
+
+	* g++.old-deja/g++.other/friend1.C: New test.
+
+1998-02-18  Dave Love  <d.love@dl.ac.uk>
+
+	* g77.f-torture/execute/dnrm2.f (dnrm2): Avoid uninitialized (and
+	possibly uninitialized) variables and declare dnrm2.
+
+Fri Feb 13 00:36:07 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.dg/ifelse-1.c: New test.
+
+Mon Feb  9 02:08:47 1998  H.J. Lu  (hjl@gnu.org)
+
+	* lib/g77.exp (g77_target_compile): Fix multilibs for libf2c.
+
+        * lib/old-dejagnu.exp (old-dejagnu): Added the
+        "execution test - XFAIL *-*-*" handling in the spirit of
+        "excess errors test -". Changed the "execution test fails"
+        handling to be like "excess errors test fails".
+        * Update various tests accordingly.
+
+Sun Jan 18 01:33:59 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* lib/c-torture.exp: Look for .x files instead of .cexp files.
+	* lib/f-torture.exp: Similarly.
+	* gcc.c-torture: Rename all .cexp files to .x files.
+
+Tue Nov 25 16:18:51 1997  Kate Hedstrom  (kate@ahab.rutgers.edu)
+
+        * lib/f-torture.exp: Improve error and loop detection.
+
+Fri Sep 26 10:50:53 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/c-torture.exp(c-torture-execute): Fix typo.
+
+	* lib/old-dejagnu.exp(old-dejagnu): Use a name derived from the
+	testcase as the executable name. Keep the executable around if
+	the test fails.
+
+Fri Sep 19 17:19:53 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/c-torture.exp (TORTURE_OPTIONS): Removed unnecessary
+ 	changes.  Only test one -g option, and move it to the end of the
+ 	list of options to test.
+
+Fri Sep 19 17:58:00 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* lib/c-torture.exp (TORTURE_OPTIONS): Check for the environment
+	variable GCC_TORTURE_OPTIONS to supply default switches separated
+	by colons.  If no environment variable, run tests with -O0 -g, -O1
+	-g, and -O2 -g as well.
+
+Wed Sep 17 10:12:26 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/plumhall.exp: Don't set PHSRC in this file. Add a few
+	explanatory comments. Fix indentation.
+
+Mon Sep 15 00:36:53 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* lib/g++.exp (g++_init): Look for xgcc in $basedir too.
+
+Thu Sep 11 13:54:47 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* g++.old-deja/g++.brendan/scope4.C: No longer expected to fail.
+	* g++.old-deja/g++.mike/p7325.C: Likewise.
+	* g++.old-deja/g++.mike/eh51.C: No longer expected to fail on the PA.
+
+Thu Sep 11 10:00:03 1997  Alexandre Oliva  (oliva@dcc.unicamp.br)
+
+	* g++.old-deja/g++.brendan/crash20.C: Rework to avoid libg++.
+	* g++.old-deja/g++.brendan/crash30.C: Likewise.
+	* g++.old-deja/g++.brendan/crash39.C: Likewise.
+	* g++.old-deja/g++.law/operators4.C: Likewise.
+
+Thu Sep 11 09:53:40 1997  Joe Buck  (jbuck@synopsys.com)
+
+	* g++.old-deja/g++.mike/p658.C: eliminate <bool.h> use.
+	* g++.old-deja/g++.mike/p784.C: Ditto.
+	* g++.old-deja/g++.mike/p785.C: Ditto.
+
+Fri Sep  5 00:21:42 1997  Jeffrey A Law  (law@cygnus.com)
+
+        * gcc.c-torture/execute/cbrt.c: Tweak to work on more targets.
+
+Wed Sep  3 17:15:00 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/c-torture.exp(c-torture-execute): If the previous and the
+ 	current executables being tested are identical, we don't need to
+ 	run the executable again. Try to make the executable names
+ 	unique. Add an optional argument for passing additional compiler
+ 	flags.
+
+Tue Sep  2 16:34:31 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/gcc-dg.exp (gcc-dg-test): Fix typos setting compile_type.
+
+Thu Jul 31 12:17:24 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/920501-9.c: Fix to work on targets with
+	32bit or larger longs.
+
+	* gcc.c-torture/execute/961017-2.c: Fix to work on targets which
+	have either a 32bit long or 32bit int.
+
+Wed Jul  9 15:15:40 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* gcc.prms/5403.c: Allow CRLFs to occur at the start of the output
+	too.
+
+Mon Jun 16 15:27:06 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/g++.exp(g++_init): Use g++_include_flags instead of making
+	up the includes ourselves.
+
+Wed Jun 11 17:33:21 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/plumhall.exp: Remove random include, and add a few
+	verbose messages for debugging.
+
+Fri Jun  6 14:23:24 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/g++.exp: Use g++_link_flags from libgloss.exp, instead
+	of trying to do it ourselves.
+
+Wed Jun  4 18:43:55 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* gcc.prms/5403.c: Made regexp a bit less strict.
+
+Tue Jun  3 15:12:39 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/mike-gcc.exp: Don't use global exec_output anymore. Output
+	is returned from remote_load instead.
+	* lib/plumhall.exp: Ditto.
+	* lib/mike-g++.exp: Ditto.
+	* lib/old-dejagnu.exp: Ditto.
+	* lib/c-torture.exp: Ditto.
+
+Fri May 30 23:15:15 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/g++.exp: Use build_wrapper procedure.
+	* lib/gcc.exp: Ditto.
+
+Tue May 20 15:23:27 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/*.c: Include stdlib.h instead of using
+	an old-style decl for malloc.  Fixes tests to work when
+	sizeof (int) != sizeof (size_t).
+
+Thu May 15 14:10:39 1997  Mike Meissner  <meissner@cygnus.com>
+
+	* lib/gcc.exp (gcc_target_compile): If gcc,no_varargs, define
+	NO_VARARGS when compiling.
+
+Thu May  1 14:49:19 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/plumhall.exp(ph_includes): New procedure.
+	(ph_make): Use it.
+	(ph_compiler): Ditto.
+
+	* lib/g++.exp: Rename test-glue.c to testglue.c.
+	* lib/gcc.exp: Ditto.
+
+Thu Apr 10 14:50:26 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/g++.exp(g++init): Don't try to be smart, always run g++_init
+ 	to completion when it's called.
+
+Thu Mar 20 09:50:32 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/plumhall.exp (ph_make): Comment out errorCode=NONE test
+	for object files.
+	(ph_summary): Mark skipped testcases as untested, not unresolved.
+
+	* lib/plumhall.exp (ph_make): If unresolved because of bad
+	errorCode, record errorCode in log file.
+	(*): Replace send_log/verbose with verbose -log.
+
+Thu Mar 13 16:09:28 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/plumhall.exp: Use incr_count.
+
+Wed Mar 12 10:01:33 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture: Update to c-torture-1.45.
+
+Sun Feb 23 18:12:04 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/gcc.exp(gcc_init): Add args parameter (which will contain
+ 	the name of the expect testcase file).
+	
+	* lib/g++.exp(g++_init): Ditto.
+
+Thu Feb 20 13:53:05 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/g++.exp(g++_exit): $gluefile lives on the build, not
+	the host.
+
+	* lib/gcc.exp(gcc_exit): New procedure.
+
+Wed Feb 19 15:16:16 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* g++.old-deja/g++.rfg/*: Added "Build don't link" and ERROR
+	specs where appropriate.
+
+	* g++.old-deja/g++.arm/*: Added additional ERROR checks
+	because of new "candidates are" messages, and removed a few
+
+	* Converted all non-old-style g++ testcases to old-style, and
+	moved into g++.old-deja.
+
+Fri Feb 14 11:46:46 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/old-dejagnu.exp(old-dejagnu): Add various "skip if"
+	options.
+
+	* lib/gcc.exp(gcc_init): Don't set gluefile unless the compile
+	succeeded.
+
+	* lib/g++.exp(g++_init): Don't unset gluefile unless it exists.
+
+Thu Feb 13 17:30:46 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* lib/gcc.exp (gcc_target_compile): Add support for defining
+	NO_TRAMPOLINES and NO_LABEL_VALUES if the baseboard file indicates
+	the machine doesn't have those features.
+
+Tue Feb 11 12:57:11 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* g++.law/operators4.exp: Don't use LIBS.
+
+Sat Feb  8 14:45:55 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* g++.law/virtual1.exp: Don't use CXX_FLAGS.
+	
+	* lib/mike-g++.exp: Don't set the compiler to be tested here.
+	* lib/g++.exp: Set it here instead. Also, allow use of the
+	--tool_exec and --tool_opt options. Change CXX to
+	GXX_UNDER_TEST.
+	
+	* g++.old-deja/old-deja.exp: Change CXX to GXX_UNDER_TEST.
+	
+	* lib/gcc.exp: Allow use of --tool_exec and --tool_opt.
+
+Fri Feb  7 12:55:45 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/old-dejagnu.exp: Use prune_warnings instead of
+ 	prune_system_crud.
+	* lib/mike-g++.exp: Ditto.
+	* lib/gcc.exp: Ditto.
+	* lib/g++.exp: Ditto.
+
+	* lib/g++.exp: Include both libstdc++ and libstdc++/stl.
+
+Fri Feb  7 10:41:53 1997  Jeffrey A Law  (law@cygnus.com)
+
+        * 941014-2.c: Include stdlib.h
+        * 960327-1.c: Include stdio.h
+        * dbra.c, index-1.c: Don't assume ints are 32bits.
+
+Tue Feb  4 12:51:09 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/gcc.exp: Add gcc,stack_size target feature.
+
+	* lib/g++.exp(g++_target_compile): Add the include and link 
+	paths here, not in two other places. And, it's $options, not
+	options.
+
+	* lib/mike-g++.exp(postbase): Remove the code that determines
+	the correct include and link paths.
+	* g++.old-deja/old-deja.exp: Ditto.
+
+Mon Feb  3 19:00:07 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/g++.exp(g++_init): target_compile no longer returns the
+	filename of the result.
+
+Sun Feb  2 14:42:34 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* gcc.misc-tests/gcov.exp: Add -nocomplain to the
+	call to glob.
+
+	* gcc.c-torture/special/special.exp: Change call to
+ 	gcc_target_compile to include the object file.
+
+Sun Feb  2 17:11:50 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* gcc.c-torture/special/special.exp: Correct misspelling in last
+	change.
+
+Sat Feb  1 12:34:23 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/plumhall.exp(ph_summary): Log the entire output of the
+ 	executable. Return -1 if there were any failures, 0 otherwise.
+	(ph_execute): Return -1 if there were any failures, 0 otherwise.
+	(ph_make): Clean up objects and executables that were built
+	if the tests succeeded.
+
+Thu Jan 30 13:45:56 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* g++.old-deja/old-deja.exp: Add -L and -I flags so we include
+	libraries and includes in the build tree as appropriate.
+
+Wed Jan 29 17:19:34 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/c-torture.exp: Instead of looking for the global variable
+	NO_LONG_LONG, check to see if that's a feature of the target.
+
+Wed Jan 29 00:36:25 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* config/default.exp: Minimize. Delete the remainer of the files in
+	config;	this functionality is now in devo/dejagnu/config.
+
+	g++.*/*: Pass any additional flags used to compile to postbase;
+	delete CXXFLAGS.
+	
+	gcc.c-torture/*: Remove calls to gcc_init and gcc_finish; this
+	is now done by runtest.exp. Use gcc_target_compile instead of
+	compile.
+
+	lib/c-torture.exp: Use gcc_target_compile instead of compile.
+	Remove references to CFLAGS. Use remote_file instead of
+	calling rm -f.
+	(c-torture): Take a list of arguments to use to compile this
+	testcase.
+
+	lib/g++.exp: Simplify. Use target_compile instead of compile.
+	lib/gcc-dg.exp: Ditto.
+	lib/gcc.exp: Ditto.
+	lib/mike-{gcc,g++}.exp: Ditto.
+	lib/old-dejagnu.exp: Ditto.
+	lib/plumhall.exp: Ditto.
+	
+Wed Jan  8 14:43:07 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* lib/plumhall.exp (ph_make): Use CFLAGS and ANSICFLAGS when linking.
+	(ph_linker): Likewise.
+
+Wed Nov 13 16:04:19 1996  Joern Rennecke <amylaar@cygnus.com>
+
+        * gcc.c-torture/execute/{loop-2e.c,loop-2f.c}: Only use
+	MAP_ANON / MAP_ANONYMOUS if defined;
+	else try to map from /dev/zero .
+
+Tue Nov 12 23:30:12 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/{loop-2e.c,loop-2f.c}:  If MAP_ANON
+	isn't defined, then define it to MAP_ANONYMOUS.
+
+Tue Nov 12 11:57:49 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture: Update to c-torture-1.42 release.
+
+Mon Nov 11 12:45:31 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture: Update to c-torture-1.41 release.
+
+Sun Oct 27 18:56:18 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/enum-1.c: New test.  Will be in next
+	c-torture release.
+
+Thu Aug 15 11:09:36 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/gcc.exp (gcc_init): Always append the target_info to CFLAGS
+	and LDFLAGS.  Fix second case to append the target_info ldflags
+	onto LDFLAGS, not CFLAGS.
+	* lib/g++.exp (g++_init): Add target_info stuff.
+	* lib/old-dejagnu.exp (old-dejagnu-init): Likewise.  Add inclusion
+	of libgloss and newlib flags for !native.
+
+	* config/proelf.exp: Load remote.exp and do `push_target hppro'.
+	(GDB): Fix relative path to go up another dir for finding gdb.
+
+Thu Aug  8 17:03:27 1996  Rob Savoye  <rob@chinadoll.cygnus.com>
+
+	* lib/gcc.exp(gcc_init): Set CFLAGS and LDFLAGS to their new
+	versions in the target_info array, if they don't exist.
+
+Fri Aug  2 15:39:03 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* config/vx.exp (${tool}_load): Fix syntax of `$shell_id < 0'.
+
+Mon Jul  8 15:45:58 1996  Jim Wilson  <wilson@cygnus.com>
+
+	* lib/g++.exp: Change all uses of $base_dir/ to $base_dir/../.
+	* lib/gcc.exp, lib/old-dejagnu.exp: Likewise.
+
+Mon Jul  1 15:53:00 1996  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/old-dejagnu.exp: Don't remove the output file before we've
+	actually tested it. Don't append pwd to the path of the executable
+	we're testing.
+
+Sun Jun 30 14:37:50 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/g++.exp (default_g++_start): Don't pass LDFLAGS, LIBS if -c.
+
+Wed Jun 26 14:15:55 1996  Bob Manson  <manson@charmed.cygnus.com>
+
+	* lib/old-dejagnu.exp (old-dejagnu): Add $tmpdir to specify a
+ 	temporary directory for compiler files, and set it to a default
+ 	value of /tmp. Set $output as the name of the output file from
+ 	compiling the testcase. Add a -o option to $cflags_var so the
+ 	compiler writes the final output file as $output. Set $executable
+ 	to $output.
+
+	* lib/mike-g++.exp (postbase): Add $tmpdir to specify a temporary
+ 	directory for compiler files, and set it to /tmp if it doesn't
+ 	already have a value. Set $output_file to the name of the output
+ 	file from compiling the testcase. Add a -o option to CXXFLAGS so
+ 	the compiler writes the final output file as $output. Use $output
+ 	as the executable to be tested.
+
+Mon Jun 24 17:12:16 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/g++.exp: Also add -Wl,-rpath,... for linux.
+
+Sat Jun  8 15:12:24 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture/execute/pending-1.c: New test.  Still
+	pending in Tege's queue.
+
+Wed Apr 24 18:13:45 1996  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* lib/plumhall.exp (ph_summary): Add arguments name and exec_status.
+	Add variables local_failcnt and local_unresolvedcnt.  Call gcc_fail
+	if there were failures.  Call unresolved if there were unresolved
+	testcases.  Call gcc_fail if program did not run to completion.
+	(ph_make): Pass additional argument name to ph_execute.
+	(ph_execute): Add new argument.  Pass additional arguments to
+	ph_summary.  Call gcc_fail is there is no execution output.
+
+Wed Apr 24 13:39:23 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* lib/plumhall.exp (proc_summary): Output relavent summary
+	lines into the log so specific failures in plumhall can be
+	investigated.
+
+Wed Apr 10 13:23:45 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* lib/c-torture.exp: Provide a default value for $NO_LONG_LONG.
+	(c-torture-execute): Don't try to execute tests which use
+	"long long" types if $NO_LONG_LONG is nonzero.
+
+Mon Apr  8 08:52:29 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.c-torture/execute/ieee/ieee.exp: Run c-torture-execute,
+	not c-torture.
+
+	* gcc.ieee: Move from here.
+	* gcc.c-torture/execute/ieee: To here.
+
+Tue Mar 26 23:41:18 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture: Update to c-torture-1.41 release.
+
+Fri Mar 22 15:49:24 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* lib/c-torture.exp (c-torture-execute): Remove "$executable",
+	not "$output".
+
+Thu Mar  7 12:37:08 1996  Doug Evans  <dje@charmed.cygnus.com>
+
+	* lib/gcc.exp (default_gcc_start): Don't pass $LDFLAGS $LIBS if
+	-c present.
+
+Sat Mar  2 22:36:37 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* config/proelf.exp: Handle connecting to a simulator.
+
+Wed Jan 31 00:58:15 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* config/proelf.exp: New file.  Enough framework that we can
+	run c-torture tests on the proelf targets (or any other target
+	that gdb can connect to for that matter).
+
+Mon Jan 29 08:57:46 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.c-torture/special/special.exp: Delete libs arg to dg-runtest.
+	* gcc.ph/testing/limits/limits.exp: Likewise.  Don't pass $CFLAGS.
+
+	* lib/plumhall.exp (ph_execute): Always call ph_summary if
+	exec_output exists.
+
+Sun Jan 28 11:28:43 1996  Doug Evans  <dje@charmed.cygnus.com>
+
+	* config/sim.exp (SIM_TIME_LIMIT): New user settable variable.
+	(${tool}_load): Use 240 seconds if SIM_TIME_LIMIT not set.
+
+	* config/*.exp: Update FSF address.  Change result of ${tool}_load
+	to pass/fail/unresolved/unsupported/untested.  Caller must now
+	call unresolved/unsupported/untested.
+	* lib/*.exp: Update FSF address.  Update to handle new results of
+	${tool}_load.
+	* lib/chill.exp (verbose): Delete.
+
+Sat Jan 27 12:28:07 1996  Doug Evans  <dje@charmed.cygnus.com>
+
+	* lib/gcc.exp (default_gcc_start): Change order of args to
+	$LDFLAGS $CFLAGS $LIBS.
+	* lib/gcc-dg.exp (gcc-dg-test): Arguments have changed, update.
+	Save/set/restore CFLAGS.  Pass single arg to gcc_start.
+	* gcc.dg/dg.exp: Delete libs arg in call to dg-runtest.
+	(CC,CFLAGS,LIBS): Delete references. Don't pass $CFLAGS to dg-runtest.
+	* gcc.misc-tests/dg-test.exp: Likewise.
+	* gcc.misc-tests/msgs.exp: Likewise.
+	* gcc.prms/prms.exp: Likewise.
+	* gcc.misc-tests/gcov.exp: Delete libs arg in call to dg-runtest.
+	(CFLAGS,LIBS): Delete references.  Don't pass $CFLAGS to dg-runtest.
+
+	* lib/dg.exp: Deleted, moved to dejagnu/lib.
+
+Wed Jan 24 18:37:00 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* g++.old-deja/old-deja.exp: Add passing of $mathlib to old-dejagnu.
+
+	* g++.old-deja/old-deja.exp: Move setting of runshlib from here...
+	* lib/old-dejagnu.exp (old-dejagnu-init): ...to here.
+
+	* lib/g++.exp (g++_init): Take out use of -rpath for the sun4, not
+	necessary.
+
+Sat Jan 20 17:22:08 1996  Brendan Kehoe  <brendan@cygnus.com>
+
+	* g++.old-deja/old-deja.exp: Move setting of runshlib out of the
+	global for loop; add use of $mathlib.
+	* lib/old-dejagnu.exp (old-dejagnu-init): Put the runshlib
+	settings here; set mathlib for anything but VxWorks.
+
+Mon Jan 22 16:31:57 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture: Update to c-torture-1.40 release.
+
+Wed Jan  3 00:54:33 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.ph/testing/limits/limits.exp: Load ${tool}-dg.exp, not
+	dg.exp.
+
+Sun Dec  3 16:17:42 1995  Jeffrey A. Law  <law@sethra.cygnus.com>
+
+	* lib/c-torture.exp (c-torture-execute): Declare "output" as
+	global.
+
+Fri Nov 17 20:01:19 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/g++.exp (LIBS): Define if not already.
+	* lib/gcc-dg.exp (gcc-dg-test): Set executable file as a.out.
+	(gcc-dg-prune): Call prune_gcc_output.
+	* lib/gcc.exp (prune_gcc_output): New proc.
+	* gcc.c-torture/special (921210-1.c): Call prune_system_crud and
+	prune_gcc_output.
+
+Thu Nov 16 09:15:40 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/c-torture.exp (c-torture-compile): Fix calls to `unsupported'.
+	(c-torture-execute): Likewise.	Rename `name' to `testcase'.
+
+Wed Nov 15 23:04:36 1995  Jeffrey A Law  (law@cygnus.com)
+
+	* gcc.c-torture: Update to c-torture-1.39 release.
+
+Sat Nov  4 12:52:05 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/c-torture.exp (c-torture-execute): Don't return if one option
+	fails, try others as well.
+
+Thu Nov  2 09:28:35 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/c-torture.exp (c-torture-execute): This proc's result is `void'.
+	If compilation fails, mark execute tests as `untested'.
+	If test is marked as unsupported, don't mark compilation and
+	execute tests as failed.
+
+Wed Oct 25 20:57:55 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/g++.exp (g++_init): Don't link in libg++, and look to
+	libstdc++ for whether or not we want to be doing shared
+	libraries.  Delete link_curses since we don't need it anymore.
+	* lib/mike-g++.exp (postbase): Don't link in libg++.
+	* g++.old-deja/old-deja.exp: Likewise.
+
+Mon Oct 23 13:05:11 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/g++.exp (CXX): Default to run `c++' instead of `g++'.
+
+Tue Oct 17 15:24:47 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/g++.exp (g++_init): Also check for libg++.sl for the hppa.
+	For that, add `-Wl,-a,shared_archive'.
+	* g++.old-deja/old-deja.exp: Likewise.
+
+Tue Oct 17 13:09:06 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/c-torture.exp (c-torture-execute): Ensure CFLAGS restored.
+
+Mon Oct 16 23:13:32 1995  Brendan Kehoe  <brendan@cygnus.com>
+
+	* lib/mike-g++.exp (postbase): Pay attention to the status of
+	g++_load.
+
+Mon Oct 16 19:28:32 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+        * g++.old-deja/old-deja.exp: Add $LIBS at the end of the args.
+
+Mon Oct 16 13:48:58 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/gcc.exp (default_gcc_start): No longer need to log program
+	being executed or its output, execute_anywhere does that now.
+	* lib/g++.exp (default_g++_version): Call execute_anywhere.
+	(default_g++_start): Likewise.  Delete calls to verbose/send_log.
+
+Thu Oct 12 10:34:58 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* g++.old-deja/old-deja.exp: Updated the shared libg++ tests to be
+	the same as those in lib/g++.exp.
+
+Tue Oct 10 13:47:27 1995  Jeff Law  (law@hurl.cygnus.com)
+
+	* gcc.c-torture: Update to c-torture-1.38 release.
+	* gcc.ieee: Related changes.
+
+Fri Oct  6 12:39:17 1995  Rob Savoye  <rob@darkstar.cygnus.com>
+
+	* mike-gcc.exp, mike-g++.exp: Use "execute_anywhere" rather than
+	"exec". Minor reformatting changes.
+
+	* config/rom68k.exp (${tool}_load): Make it work in a canadian
+	cross. This means all "exec" calls now work on a remote host as
+	well.
+	* lib/c-torture.exp (c-torture-compile): Make work for a canadian
+	cross. Filter out the extra "\r\n" stuff that expect puts in.
+	(c-torture-execute): Filter out the bogus warnings like
+	c-torture-compile does. Add support for canadian cross.
+	* lib/gcc.exp (default_gcc_version, default_gcc_start)
+	Use execute_anywhere rather than calling exec directly. Now it
+	works for canadian cross testing.
+
+Thu Oct  5 10:06:45 1995  Brendan Kehoe  <brendan@rtl.cygnus.com>
+
+	* lib/g++.exp: Add -nocomplain flag to glob.  Use catch to put the
+	results into a variable, and check that rather than using file exists.
+
+Wed Oct  4 16:31:02 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/g++.exp: Use glob to see libg++.so.2.7.0, since sun4 doesn't
+	create a libg++.so.  For sunos4.1.*, also add -ltermcap.
+
+Tue Sep 26 10:15:14 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* g++.old-deja/old-deja.exp: Create and pass runshlib and
+	lib_curses if there's a shared libg++ in the build tree.
+
+Fri Sep 22 10:47:24 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/mike-{gcc,g++}.exp (postbase): Restore CFLAGS, CXX_FLAGS, LIBS
+	if not supported target.
+
+Fri Sep 22 09:22:07 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/g++.exp (g++_init): Move empty setting of runshlib and
+	link_curses up to always happen, not just for native builds.
+
+Thu Sep 21 10:23:32 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* gcc.c-torture: Update to c-torture-1.36 release.
+	* gcc.failure: Related changes.
+
+Wed Sep 20 10:56:26 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/plumhall.exp (PHSRC, PHDST): Allow config files to override.
+
+Tue Sep 19 17:26:07 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/g++.exp (g++_init): Put the shared and math lib stuff in here.
+	* lib/mike-g++.exp (postbase): Not in here.  Still reference
+	runshlib, link_curses, and mathlib for link and run.
+
+	* lib/mike-g++.exp (postbase): If we've built a libg++.so, then
+	pass the runtime shared library options for Solaris, OSF/1, and
+	Irix5, and link with -lcurses to avoid unresolved references.
+	
+Wed Sep 13 15:28:10 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/gcc.exp (gcc_init): Return if gcc_initialized is 1, so we
+	only run once.
+
+Wed Sep 13 10:51:52 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/c-torture.exp (c-torture-compile): Don't alter CFLAGS.
+
+Mon Sep 11 11:02:03 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* gcc.c-torture: Update to c-torture-1.35 release.  Note we
+	do not have a framework for the "compat" tests yet.
+
+Sat Sep  9 16:15:20 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/mike-g++.exp (postbase): New local variable `mathlib',
+	set to null if we're testing vxworks5.1.  Use that instead of
+	`-lm' in the setting of LIBS for link and run.
+
+Fri Sep  8 13:53:38 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* config/rom68k.exp (${tool}_load): Major changes to make it
+	work.  Verified that it does in fact return the stuff in
+	exec_output properly.  Catch any Emul or any TRAP other than 0.
+
+Thu Sep  7 23:04:06 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* lib/mike-g++.exp (prebase): Call g++_init at the end to set
+	LDFLAGS properly for targets that need stuff from libgloss.
+	* lib/g++.exp (g++_init): Return if gpp_initialized is 1, so we
+	only run once.
+	(gpp_initialized): New variable.
+
+Wed Sep  6 21:56:13 1995  Rob Savoye  <rob@darkstar.cygnus.com>
+
+	* config/rom68k.exp: Load libgloss.exp.
+	* lib/gcc.exp (gcc_init): get proper flags for newlib and libgloss
+	so we can produce a fully linked binary.
+	* lib/g++.exp (g++_init): get proper flags for newlib and libgloss
+	so we can produce a fully linked binary.
+
+Sun Sep  3 13:25:26 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/plumhall.exp (ph_section): Watch for expected failures.
+	Add missing `else'.
+
+	* lib/c-torture.exp (c-torture-execute): Look for .cexp files to
+	run the testcase.
+	(c-torture): Likewise.
+
+Mon Aug 28 11:23:38 1995  Doug Evans  <dje@cygnus.com>
+
+	* gcc.dg/dg.exp (scan-assembler, scan-assembler-not): New procs.
+
+	* lib/mike-g++.exp (mike_cleanup): New proc.
+	(prebase): New globals compiler_result, not_compiler_result,
+	target_regexp.
+	(postbase): Likewise.  Call mike_cleanup.  Pass "--" to regexp to
+	allow leading "-" in pattern.  Watch for unsupported tests.
+	If $compiler_result is set, pattern match assembler code,
+	and ditto for $not_compiler_result.
+	* lib/mike-gcc.exp: Likewise.
+
+	* lib/plumhall.exp (ph_execute): Only call ph_summary if
+	execution "succeeded".
+
+Mon Aug 14 14:03:53 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config/win32.exp: New file.
+	* lib/c-torture.exp (c-torture-execute): Handle $exe_ext.
+
+Fri Aug  4 15:39:54 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/gcc-dg.exp (gcc-dg-prune): Mark testcases that fill ram as
+	unsupported.
+	* lib/mike-{gcc,g++}.exp (postbase): Likewise.
+	* lib/{c-torture.exp,old-dejagnu.exp}: Likewise.
+	* lib/{gcc,g++}.exp (${tool}_check_untested_p): New proc.
+
+	* lib/mike-g++.exp (postbase): Delete alpha-*-* checking of
+	"... without exceptions was ...".  That is now handled by
+	prune_system_crud.
+	* lib/old-dejagnu.exp (old-dejagnu): Likewise.
+
+Tue Aug  1 11:09:33 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.misc-tests/{acker1.c,dhry.c,dhry.h,matrix1.c,optbench.c,
+	sieve.c,sort2.c}: New files.
+	* gcc.misc-tests/{acker1.exp,dhry.exp,matrix1.exp,optbench.exp,
+	sieve.exp,sort2.exp}: Drivers for them.
+
+	* lib/mike-gcc.exp (program_output): New user settable variable.
+	(postbase): Call prune_system_crud.  Also prune extraneous compiler
+	messages.
+	* lib/mike-g++.exp (program_output): New user settable variable.
+
+	* gcc.misc-tests/mg.exp (compiler_output): Handle multiple lines.
+
+	* config/sh.exp: Deleted (use sim.exp instead).
+
+Fri Jul 28 11:33:46 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* config/vx.exp: Declare CHECKTASK as global.
+	* config/vxworks29k.exp: Reduce to only set CHECKTASK, and load vx.exp.
+	* lib/mike-g++.exp: Load [pwd]/a.out, not `./a.out'.
+	* lib/old-dejagnu.exp: Load [pwd]/$executable.
+
+Wed Jul 26 19:45:39 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* config/vxworks29k.exp: New file, for the a29k-vxworks5.1
+	target. Like vx.exp, only includes `vx29k.exp' instead of
+	`vxworks.exp'.
+
+Sun Jul 23 17:38:52 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config/sim.exp: Increase time limit from 120 seconds to 240.
+
+Thu Jul  6 11:07:38 1995  Jeffrey A. Law  <law@rtl.cygnus.com>
+
+	* gcc.c-torture/execute/950628-1.c: New test.
+
+Sat Jun 10 18:51:41 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* gcc.c-torture: Update with changes/additions from
+	c-torture-1.34.
+
+Mon Jun  5 17:58:07 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.prms/prms.exp: Pass LDFLAGS to dg-test.
+
+Sun Jun  4 05:13:57 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* gcc.c-torture/compile/funcptr-1.c: Test case for 7107.
+
+Thu Jun  1 00:06:19 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* gcc.c-torture/compile/950512-1.c: New test.
+	* gcc.c-torture/execute/strct-pack-4.c, strct-pack-5.c}: Likewise.
+	* gcc.dg/struct-ret-1.c: Likewise.
+
+Wed May 31 14:25:13 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.c-torture/execute/{920410-1.c,921113-1.c,921208-2.c,
+        930106-1.c,memcpy-1.c}: Use STACK_SIZE if defined.
+
+Tue May 30 11:19:54 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.c-torture/special/920411-1.c: Deleted.
+	* gcc.c-torture/special/special.exp: Delete 920411-1.c.
+
+Mon May 22 16:55:11 1995  Doug Evans  <dje@chestnut.cygnus.com>
+
+	* config/sim.exp (${tool}_load): Hack in call to bash to get a
+	cpu limit.
+
+Fri May 12 18:57:54 1995  Torbjorn Granlund  <tege@rtl.cygnus.com>
+
+	* gcc.c-torture/execute/{950511-1.c,950512-1.c}: New tests.
+
+Thu May  4 14:23:54 1995  Torbjorn Granlund  <tege@adder.cygnus.com>
+
+	From kenner;
+	* gcc.c-torture/execute/va-arg-2.c (f[0-9], f1[0-5]): Verify format
+	is the proper length.
+	* va-arg-3.c: Likewise.
+
+Sun Apr 30 16:02:59 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/dg.exp: Moved to dejagnu/lib.  Copy kept here (for awhile).
+	* lib/gcc-dg.exp: New file, gcc interface to dg.exp.
+
+	* lib/gcc.exp (default_gcc_start): Delete old cruft.  Delete result.
+	* lib/g++.exp (default_g++_start): Delete old cruft.
+
+Tue Apr 25 17:20:18 1995  Torbjorn Granlund  <tege@cygnus.com>
+
+	* gcc.c-torture/execute/memcpy-1.c: Decrease stack requirements from
+	(2 * (1 << 18)) to (2 * (1 << 17)).
+
+	* gcc.c-torture/execute/arith-rand.c: Avoid -0x80000000/-1.
+
+Thu Apr 20 12:21:13 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* config/rom68k.exp: Renamed from config/idp.exp
+
+Tue Apr 18 13:33:26 1995  Torbjorn Granlund  <tege@rtl.cygnus.com>
+
+	* c-torture/compile/921109-2.c
+
+Tue Apr 18 10:45:12 1995  Mike Stump  <mrs@cygnus.com>
+
+	* lib/old-dejagnu.exp: We expect Execution test failure if we expected
+	excess errors.
+
+Sat Apr 15 11:16:58 1995  Doug Evans  <dje@chestnut.cygnus.com>
+
+	* lib/gcc.exp (default_gcc_start): Handle leading "-" in compiler
+	output.
+	* lib/g++.exp (default_g++_start): Likewise.
+
+Wed Mar 29 16:34:03 1995  Torbjorn Granlund  <tege@adder.cygnus.com>
+
+	* gcc.c-torture/compile/950329-1.c: New test.
+
+Tue Mar 28 16:10:33 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+        * config/bug.exp (${tool}_load): Updated to use new remote_open
+	  and remote_close procs.
+	* config/idp.exp: New file.
+
+Wed Mar 22 15:01:58 1995  Torbjorn Granlund  <tege@rtl.cygnus.com>
+
+	* gcc.c-torture/execute/950322-1.c: New test.
+
+Tue Mar 21 21:24:49 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config/vx.exp (${tool}_load): Clean up testing of return code from
+	vxworks_ld and vxworks_spawn.
+
+Tue Mar 21 17:01:42 1995  Doug Evans  <dje@deneb.cygnus.com>
+
+	* lib/c-torture.exp (c-torture-execute): Pass same text to pass/fail.
+
+Mon Mar 13 14:49:42 1995  Mike Stump  <mrs@cygnus.com>
+
+	* lib/old-deja.exp: Add `excess errors test - ' error, now one
+	can mark excess errors on a machine by machine basis.  Note, the
+	default is to not expect any excess errors, even when excess
+	errors test - is given, so you will want to put an XFAIL ... on
+	these lines.  For example, // excess errors test - XFAIL hppa*-*-*
+	mips-*-* alpha-*-* m68k-*-* is how to expect excess errors on
+	those 4 machines, but no others.
+
+Fri Mar 10 12:33:04 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* gcc.c-torture/execute/execute.exp (c-torture-execute): from here.
+	* lib/c-torture.exp: to here.
+
+Fri Mar 10 10:38:15 1995  Torbjorn Granlund  <tege@adder.cygnus.com>
+
+	* gcc.c-torture/execute/950221-1.c: New test.
+	* gcc.c-torture/execute/struct-ret-1.c: New test.
+	* gcc.c-torture/compile/950221-1.c: New test.
+
+	* gcc.c-torture/execute/941101-1.c (f): Fix typo, == was !=.
+
+Fri Mar  3 16:28:35 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.c-torture/execute/arith-1.c (main): Return 0.
+	* gcc.c-torture/execute/arith-rand.c (main): Return 0.
+
+Wed Mar  1 02:08:29 1995  Gerald Baumgartner  (gb@lorenzo.cs.purdue.edu)
+
+	* g++.gb: New directory of tests, derived from my signature and
+	class scoping tests.
+
+	* g++.gb/{sig01.C, sig02.C, sig03.C, sig04.C}: New tests.
+	* g++.gb/{sig05.C, sig06.C, sig07.C, sig08.C}: Likewise.
+	* g++.gb/{sig09.C, sig10.C, sig11.C, sig12.C}: Likewise.
+	* g++.gb/{sig13.C, sig14.C, sig15.C, sig16.C}: Likewise.
+	* g++.gb/{sig17.C, sig18.C, sig19.C, sig20.C}: Likewise.
+	* g++.gb/{sig21.C, sig22.C, sig23.C, sig24.C}: Likewise.
+	* g++.gb/sig25.C: Likewise.
+
+	* g++.gb/{sig01.exp, sig02.exp, sig03.exp, sig04.exp}: Run them.
+	* g++.gb/{sig05.exp, sig06.exp, sig07.exp, sig08.exp}: Likewise.
+	* g++.gb/{sig09.exp, sig10.exp, sig11.exp, sig12.exp}: Likewise.
+	* g++.gb/{sig13.exp, sig14.exp, sig15.exp, sig16.exp}: Likewise.
+	* g++.gb/{sig17.exp, sig18.exp, sig19.exp, sig20.exp}: Likewise.
+	* g++.gb/{sig21.exp, sig22.exp, sig23.exp, sig24.exp}: Likewise.
+	* g++.gb/sig25.exp: Likewise.
+
+	* g++.gb/{scope01.C, scope02.C, scope03.C, scope04.C}: New tests.
+	* g++.gb/{scope05.C, scope06.C, scope07.C, scope08.C}: Likewise.
+	* g++.gb/{scope09.C, scope10.C, scope11.C, scope12.C}: Likewise.
+	* g++.gb/scope13.C: Likewise, this test still fails.
+
+	* g++.gb/{scope01.exp, scope02.exp, scope03.exp, scope04.exp}: Run 'em.
+	* g++.gb/{scope05.exp, scope06.exp, scope07.exp, scope08.exp}: Ditto.
+	* g++.gb/{scope09.exp, scope10.exp, scope11.exp, scope12.exp}: Ditto.
+	* g++.gb/scope13.exp: Ditto.
+
+	* g++.gb/README: New file, explains what these tests are about.
+
+Tue Feb 28 10:37:52 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/dg.exp (dg-do): Support `preprocess'.
+	(dg-test): Likewise.
+
+Mon Feb 13 15:18:10 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* config/udi.exp: change "continue -expect" to "exp_continue".
+
+Sat Feb 11 00:25:20 1995  Torbjorn Granlund  (tege@tiny.cygnus.com)
+
+	* gcc.c-torture/execute/{921025-1.c, 930525-1.c}:
+	Delete redundant tests.
+
+	* gcc.c-torture/execute/{941014-1.c, 941014-2.c}: New tests.
+	* gcc.c-torture/execute/{941015-1.c, 941021-1.c}: New tests.
+	* gcc.c-torture/execute/{941025-1.c, 941031-1.c}: New tests.
+	* gcc.c-torture/execute/{941101-1.c, 941110-1.c}: New tests.
+	* gcc.c-torture/execute/{941202-1.c, arith-1.c}: New tests.
+	* gcc.c-torture/execute/{arith-rand.c, complex-3.c}: New tests.
+	* gcc.c-torture/execute/{inst-check.c, loop-1.c}: New tests.
+	* gcc.c-torture/execute/{memcpy-1.c, va-arg-2.c}: New tests.
+
+	* gcc.c-torture/execute/920302-1.c: Use void * instead of long for
+	storing label pointers.
+	* gcc.c-torture/execute/921019-1.c: Likewise.
+	* gcc.c-torture/execute/920501-8.c: Add prototype for sprintf.
+	* gcc.c-torture/execute/930513-1.c: Provide full declaration for
+	parameter fp.
+	* gcc.c-torture/execute/va-arg-1.c (main): Add L suffix to all
+	constants.
+
+	* gcc.c-torture/compile/{920501-14.c, 931127-1.c}:
+	Delete obsolete tests.
+
+	* gcc.c-torture/compile/{940409-1.c, 940718-1.c}: New tests.
+	* gcc.c-torture/compile/{941014-1.c, 941014-2.c}: New tests.
+	* gcc.c-torture/compile/{941014-3.c, 941014-4.c}: New tests.
+	* gcc.c-torture/compile/{941019-1.c, 941111-1.c}: New tests.
+	* gcc.c-torture/compile/{941113-1.c, 950122-1.c}: New tests.
+	* gcc.c-torture/compile/950124-1.c: New test.
+
+	* gcc.c-torture/compile/920902-1.c: Delete 2:nd parameter.
+
+Wed Feb  8 15:30:17 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* lib/mike-g++.exp: Add -lm to LIBS.
+
+Tue Feb  7 17:09:50 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/c-torture.exp (c-torture): Allow relative pathname in $srcdir.
+
+Mon Jan 30 14:33:25 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* lib/mike-g++.exp: Add -lstdc++ to LIBS.
+
+Thu Jan 12 16:41:34 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.misc-tests/dg-test.exp: Only run if $DG_TEST=yes.
+
+Mon Jan  2 11:50:10 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* g++.law/{arg9.C, arg10.C, arg11.C, arm15.C, arm16.C}: New tests.
+	* g++.law/{bad-error3.C, bad-error4.C, bad-error5.C}: Likewise.
+	* g++.law/{bad-error6.C, bad-error7.C}: Likewise.
+	* g++.law/{bit-fields3.C, casts2.C, casts3.C}: Likewise.
+	* g++.law/{enum8.C, enum9.C, friend5.C}: Likewise.
+	* g++.law/{nest2.C, nest3.C, nest4.C, nest5.C}: Likewise.
+	* g++.law/{nest6.C, next7.C, operators30.C}: Likewise.
+	* g++.law/{operators31.C, operators32.C, 
+	* g++.law/{operators33.C, operators34.C}: Likewise.
+	* g++.law/{pic1.C, refs2.C}: Likewise.
+	* g++.law/{refs3.C, refs4.C, static-mem3.C}: Likewise.
+	* g++.law/{static-mem4.C, static-mem5.C, typeck4.C}: Likewise.
+	* g++.law/{vbase1.C, visibility27.C, visibility28.C}: Likewise.
+	* g++.law/{vtable2.exp, vtable3.exp}: Likewise.
+
+	* g++.law/{arg9.exp, arg10.exp, arg11.exp, arm15.exp}: Run them.
+	* g++.law/{arm16.exp, bad-error3.exp, bad-error4.exp: Likewise.
+	* g++.law/{bad-error5.exp, bad-error6.exp}: Likewise.
+	* g++.law/{bad-error7.exp, bit-fields3.exp}: Likewise.
+	* g++.law/{casts2.exp, casts3.exp, enum8.exp}: Likewise.
+	* g++.law/{enum9.exp, friend5.exp}: Likewise.
+	* g++.law/{nest3.exp, nest4.exp}: Likewise.
+	* g++.law/{nest5.exp, nest6.exp, nest7.exp}: Likewise.
+	* g++.law/{operators30.exp, operators31.exp}: Likewise.
+	* g++.law/{operators32.exp, operators33.exp}: Likewise. 
+	* g++.law/{operators34.exp}: Likewise.
+	* g++.law/{pic1.exp, refs2.exp, refs3.exp refs4.exp}: Likewise.
+	* g++.law/{static-mem3.exp, static-mem4.exp}: Likewise.
+	* g++.law/{static-mem5.exp, typeck4.exp, vbase1.exp}: Likewise.
+	* g++.law/{visibility27.exp, visibility28.exp}: Likewise.
+	* g++.law/{vtable2.exp, vtable3.exp}: Likewise.
+
+	* g++.law/{union4.exp, visibility17.exp}: Fix expected output.
+	No longer expected to fail.
+	* g++.law/missed-error3.C: Tweak for recent bool changes.
+
+Sun Dec  4 20:54:33 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config/emb-unix: Deleted.
+	* config/unix.exp (${tool}_load): Use new proc rsh_exec to perform
+	remote execution.  Do final link on remote host if REMOTE_LINK is set.
+
+Thu Dec  1 08:43:05 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/dg.exp (dg-test): Fix typo in last patch.
+
+Wed Nov 30 13:25:32 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/dg.exp (dg-test): Fix pattern that searches for expected output
+	(handles multiple occurrences).
+
+Thu Nov 24 19:48:38 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.c-torture/*/*.exp: Pass full pathname to c-torture.
+	* gcc.c-torture/execute/execute.exp (c-torture-execute): Remove
+	$srcdir from pathname in pass/fail messages (but ensure $subdir *is*
+	printed).
+	* lib/c-torture.exp (c-torture-compile): Likewise.
+	(c-torture): Prepend full path if missing.
+	* lib/gcc.exp (gcc_pass): Pass entire pathname of testcase.
+	(gcc_fail): Likewise.
+	* lib/dg.exp (dg-test): Don't delete $subdir from pathname in messages.
+
+Wed Nov 23 13:56:00 1994  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* lib/netware.exp: Only attach to NetWare i386 systems.
+
+Wed Nov 16 11:27:00 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/dg.exp (dg-test): Don't print $subdir (or above) in pass/fail
+	messages.  Add test name to "output pattern match" pass/fail message.
+
+Sat Nov 12 22:11:52 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.dg: New testsuite.
+	* gcc.dg/dg.exp: New file.
+
+	* gcc.misc-tests/{misc.exp,inst-check.c,test-ior.c,test-consts.c,
+	test-switch.c}: Deleted.
+
+	* gcc.misc-tests/msgs.exp: New testcase driver.
+
+Wed Nov  9 14:23:09 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.c-torture/execute/execute.exp (c-torture_execute): New proc.
+	Watch for illegal return values from ${tool}_load.
+	* config/unix.exp (${tool}_load): Fix pass/fail detection for
+	cross targets.  Coerce return value >0 to 1.
+
+Tue Nov  8 14:10:33 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config/unix.exp (${tool}_load): Call program rsh, not proc.
+
+	* config/emb-unix.exp: New file.
+
+	* config/sim.exp: Error if variable $SIM not defined.
+	(${tool}_load): Mark test as "untested" if simulator missing.
+
+	* config/unix.exp: Load remote.exp to get rcp_download.
+	* lib/c-torture.exp: Use different option lists for testcases with
+	and without loops.
+	* gcc.c-torture/execute/execute.exp: Likewise.
+
+Wed Nov  2 14:47:58 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config/*.exp: Clarify return code from ${tool}_load.
+	Call `unresolved' or `untested' instead of `warning' or `perror'
+	(sometimes you still want to call both though).
+	Add comment that `shell_id' is local to each file.
+	* config/udi.exp (timeout): Set to 30.
+	Don't print warning if connection fails, $connectmode has already
+	printed an error.
+	(${tool}_load): Move verbose messages to level 2.
+	Rework pattern for "Process started" message.
+	Pass `shell_id' to ${connectmode}_download.
+	Retry twice upon timeout.  Make resetting of target more robust.
+	(${tool}_exit): Remove /tmp/soc_name. if connected ok (bug in mondfe).
+	Pass `shell_id' to exit_$connectmode.
+	Only call exit_$connectmode if connected.
+	* config/unix.exp (${tool}_load): Check return codes better.
+	* config/vrtx.exp (${tool}_load): Likewise.
+	* config/vx.exp (${tool}_load): Likewise.
+	Delete unneeded global's.
+	* lib/dg.exp (dg-test): Update to reflect clarified return codes
+	from ${tool}_load.
+	(dg-stat): Delete.
+	(dg-init): Delete recording of pass/fail counts.
+	* lib/old-dejagnu.exp (old-dejagnu): Likewise.
+	(old-dejagnu-init): Likewise.
+	(old-dejagnu-stat): Delete contents, empty proc now.
+	* lib/c-torture.exp (TORTURE_OPTIONS): New global.
+	(c-torture): Delete references to lcnt, lpass, lfail.
+	Get option list from TORTURE_OPTIONS.
+	Delete -funroll[-all]-loops if no loops.
+	* lib/g++.exp (g++_init): Delete references to lcnt, lpass, lfail.
+	(g++_stat): Delete contents (empty proc now).
+	* lib/gcc.exp (gcc_init): Delete references to pass/fail counts.
+	(gcc_finish): Likewise.
+	(gcc_stat): Deleted.
+	* lib/mike-gcc.exp (postbase): Delete references to lcnt, lpass, lfail.
+	* gcc.*/*.exp: Delete calls to gcc_stat, dg-stat.
+	* gcc.c-torture/execute/execute.exp: Likewise.
+	Split tests into two parts: compile, execute.
+	Get option list from TORTURE_OPTIONS.  Delete -funroll[-all]-loops if
+	no loops.  Update to reflect clarified return codes from ${tool}_load.
+
+Fri Oct 21 23:10:16 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/old-dejagnu.exp (process-option): Append ".*" to pattern
+	to grep for.
+	(old-dejagnu): Likewise (where necessary).
+
+Fri Oct 14 17:54:58 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* gcc.misc-tests/gcov.exp: New file, for gcov testing.
+
+	* lib/dg.exp (dg-process-target): Fix processing of selector.
+	Add comment regarding use of `error'.
+
+	* lib/gcc.exp (prune_system_crud): Define if missing.
+	* lib/g++.exp (prune_system_crud): Likewise.
+
+	* lib/{c-torture.exp,dg.exp,mike-g++.exp,old-dejagnu.exp}:
+	Call prune_system_crud.
+	* lib/dg.exp (dg-runtest): New proc.
+	Use perror instead of send_user for tcl errors in testcase.
+	Don't return any value, it's never used.
+	Don't clobber previous definition of `unknown'.
+	Print tcl errors in `dg-final'.
+
+Wed Oct 12 13:05:37 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* lib/dg.exp (dg-process-target): Improve syntax error messages.
+	(dg-test): Don't print errorInfo, it contains stack backtrace.
+
+Mon Sep 26 12:18:53 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/g++.exp (runtest_file_p): Define if missing.
+
+Sat Sep 24 15:29:23 1994  Doug Evans  (dje@cygnus.com)
+
+	* lib/mike-g++.exp: Comment out loading of g++.exp.
+	* lib/g++.exp: Update copyright.  Test for existence of $CXX at start.
+	(default_g++_version): Always print something.
+	(default_g++_start): Comment out call to `which'.
+	(g++_start, g++_load): Deleted (must be defined in config file).
+	* lib/gcc.exp: Test for existence of $CC at start.
+	Delete check for tmpdir (done in gcc_init).
+	(default_gcc_version): Always print something.
+	(default_gcc_start): Comment out call to `which'.
+	* config/*.exp: Major cleanup - make cross targets work at least a
+	little better for g++ (by not being "--tool gcc" specific).
+	Rename gcc_xxx to ${tool}_xxx.
+	* g++.old-deja/old-deja.exp: utils.exp is loaded by runtest.exp.
+	* lib/old-dejagnu.exp: ${tool}.exp is loaded by config file.
+
+Thu Sep 22 11:39:17 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/c-torture.exp (c-torture-compile): Rework compiler
+	message processing.
+
+	* gcc.c-torture/compile/initbug1.{c,exp}: Deleted, not part of
+	c-torture.
+
+Wed Sep 21 09:49:43 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* gcc.wendy/wendy.dis: Renamed from wendy.exp to disable the testsuite.
+
+	* lib/dg.exp (dg-process-target): Support { target native }.
+
+Tue Sep 20 17:16:55 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/dg.exp (dg-test): Clean up some comments.  Delete code that
+	looked for "... program xxx got fatal signal".
+	Correct regsub munging of `comp_output'.
+	Ignore compiler messages "path prefix not used" and "linker input
+	file unused".
+
+Wed Sep 14 11:44:40 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/gcc.exp (runtest_file_p): Define if missing.
+	* gcc.prms/template.c: Example to work from.
+
+Tue Sep 13 10:30:48 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/gcc.exp (gcc_finish): Delete code to update `testcnt'.
+	* lib/dg.exp (dg-test): Call unsupported testcases as such.
+
+	* gcc.prms/{3324.c,3565.c}: Moved from compile/940713-[12].c.
+	* gcc.prms/1883.c: Moved from compile/940714-1.c.
+	* gcc.prms/{5012.c,4453.c,4723.c,2541.c}: Moved from
+	execute/{940712-1.c,940712-2.c,940713-1.c,940714-1,c}.
+
+	* lib/dg.exp (user option docs): Clean up docs on target/xfail option.
+	(dg-process-target): No longer a varargs proc.
+	Return S/N for target, P/F for xfail.  All callers changed.
+	(user option procs): More argument checking.
+	(dg-do): `dg-do-what' now contains 3 elements {what flag P/F}.
+	(dg-output): `dg-output-text' now contains 2 elements {P/F text}.
+	(dg-test): Skip test if not running on selected target in `dg-do'.
+	Update handling of `dg-do-what', `dg-output-text'.
+	Separate execution pass/fail from output pattern match pass/fail.
+	Delete BUILD/XBUILD support (duplicate of LOSE/XLOSE).
+
+Mon Sep 12 13:47:35 1994  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* gcc.c-torture/special/special.exp: Don't expect failure for mips
+	target for 920510-1.c.
+
+Mon Sep 12 12:44:39 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/gcc.exp (gcc_init): Move initialized message to verbose level 3.
+	Clean up comment regarding use of passcnt, etc.
+	(gcc_stat): Don't update `testcnt' here.
+	(gcc_finish): Do it here.
+	Might as well reset `but_id' here too.
+	* gcc.c-torture/code_quality/code_quality.exp: Call `runtest_file_p'
+	to determine if the file should be tested.
+	* gcc.c-torture/compile/compile.exp: Likewise.
+	* gcc.c-torture/execute/execute.exp: Likewise.
+	* gcc.c-torture/unsorted/unsorted.exp: Likewise.
+	* gcc.misc-tests/dg-test.exp: Likewise.
+	* gcc.prms/prms.exp: Likewise.
+	* gcc.wendy/wendy.exp: Likewise.
+	* g++.old-deja.exp: Likewise.
+	Move "Testing file" message to verbose level 1.
+
+Fri Sep  9 10:21:18 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* gcc.wendy/t.c: Add DEJAGNU_CFLAGS:"-DNOPAUSE".
+
+Thu Sep  8 16:52:43 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/gcc.exp: Ensure CFLAGS, LIBS, and LDFLAGS are set.
+	(default_gcc_start): Accept optional second list element
+	of compiler flags.  Print compiler output at verbosity level 2.
+	Remove setting of CFLAGS, LIBS, LDFLAGS from here.
+	(gcc_init): Delete globals lcnt, lpass, lfail, lxpass, lxfail.
+	Save current values of framework globals passcnt, failcnt, xpasscnt,
+	and xfailcnt in gcc_passcnt, gcc_failcnt, gcc_xpasscnt, and
+	gcc_xfailcnt.  Set global `tmpdir' to /tmp if it doesn't exist.
+	(gcc_stat): Use framework globals passcnt, failcnt, xpasscnt, and
+	xfailcnt to compute stats.  Update framework global `testcnt' from
+	pass/fail counts.
+	(gcc_finish): New proc.  Clean up test environment.
+	(gcc_cpass, gcc_cfail): Rename to gcc_pass/gcc_fail.
+	(gcc_epass, gcc_efail): Delete.
+	* lib/dg.exp (dg-error, dg-warning, dg-bogus): Accept optional 5th
+	argument of line number.
+	(dg-init): If the tool has an init routine, call it.
+	(dg-test): Remove args `cflags_var' and `libs_var'.
+	Pass all compiler options to ${tool}_start.
+	Handle missing line number.
+	(dg-finish): New function.
+	* gcc.c-torture/code_quality/code_quality.exp: Add support for testing
+	particular files.  Call gcc_finish at end.  Move "skipping test"
+	message to verbosity level 3.
+	* gcc.c-torture/compile/compile.exp: Likewise.
+	* gcc.c-torture/unsorted/unsorted.exp: Likewise.
+	* gcc.c-torture/execute/execute.exp: Likewise.
+	Delete setting of prms_id, bug_id, lcnt, lfail, lpass.
+	Print testcase being tried at verbosity level 1.
+	* gcc.c-torture/special/special.exp: Unset xfail.
+	Delete setting of prms_id, bug_id, lcnt, lfail, lpass.
+	* gcc.c-torture/compile/initbug1.exp: Call gcc_finish.
+	* gcc.c-torture/noncompile/noncompile.exp: Likewise.
+	* gcc.failure/failure.exp: Likewise.
+	* gcc.ieee/ieee.exp: Likewise.
+	* gcc.misc-tests/dg-test.exp: Delete LDFLAGS.
+	Update call to dg-test.  Call dg-finish at end.
+	* gcc.misc-tests/mg.exp: Call gcc_finish at end.  Unset orig_flags.
+	Delete setting of prms_id, bug_id, lcnt, lfail, lpass.
+	* gcc.misc-tests/misc.exp: Call gcc_finish at end.
+	* gcc.prms/prms.exp: Delete loading of utils.exp (redundant).
+	Delete LDFLAGS.  Update call to dg-test.  Call dg-finish at end.
+	* gcc.wendy/wendy.exp: Add copyright.
+	Delete setting of tmpdir (done by gcc_init).
+	Call gcc_pass/gcc_fail instead of gcc_[ce]pass/fail.
+	Pass compiler flags to gcc_start.  Call gcc_finish at end.
+	* lib/c-torture.exp: Call gcc_pass/gcc_fail instead of
+	gcc_[ce]pass/fail.
+
+Wed Sep  7 11:09:08 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/g++.exp (g++_start): Rename arg to `prog' to avoid varargs
+	confusion.
+	(g++_load): Likewise.
+
+	* config/*.exp (gcc_load): Some were varargs fns and some were not.
+	Rename argument to `prog' to remove the confusion.
+	Varargs fns behave differently too!
+	(g++_load): Likewise.
+
+	* lib/dg.exp (dg-stat): Correct calculation of npass, nfail.
+
+	* config/unix.exp (gcc_load): Rename `args' to `prog' because that's
+	what it is.  Delete (always) printing of status value for !native.
+	Simplify verbose code, and include status and exec_output.
+	(g++_load): Use gcc_load.
+
+Sun Sep  4 13:59:27 1994  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* gcc.c-torture/noncompile/920928-1.c: Delete obsolete file.
+	* gcc.c-torture/noncompile/noncompile.exp: Delete support for
+	920928-1.c, 921017-1.c, 940712-1.c, 940714-1.c, 940714-2.c,
+	940714-3.c as these testcases don't exist anymore.  Make
+	va-arg-1.c expected to pass.
+
+Fri Aug 19 12:27:07 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* gcc.misc-tests/misc.exp: Only run specific testcases.
+	* gcc.misc-tests/dg-test.exp: New file.  Tests dg.exp.
+	* gcc.misc-tests/dg-[1-9].c: New files.
+
+	* lib/dg.exp: New testsuite driver.
+	* gcc.prms/prms.exp: Use it.
+
+	* README.gcc: New file.
+
+	* lib/gcc.exp (gcc_init): Delete srcdir, no longer referenced.
+	Document and reset `lxpass' and `lxfail'.
+	Simplify "initialized" message.
+	(gcc_stat): Clean up comments a little.
+
+Tue Aug 16 11:16:46 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* gcc.prms/prms.exp: New driver for gcc.prms testsuite directory.
+
+Mon Aug 15 21:20:36 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/old-dejagnu.exp (process-option): New proc.
+	(old-dejagnu-init, old-dejagnu-stat): Likewise.
+	(old-dejagnu): Simplify.
+	* g++.old-deja/old-deja.exp: Update to new version of old-dejagnu.
+
+Sun Aug 14 09:23:53 1994  Jeff Law  (law@snake.cs.utah.edu)
+
+	* lib/c-torture.exp (c-torture): Only call setup_xfail if $xfail
+	exists and is not an empty string.
+
+	* gcc.c-torture/special/special.exp (920520-1.c, 930510-1): Set
+	$xfail rather than calling setup_xfail.  Clear $xfail when test is
+	finished.
+	(920717-x.c): Add $srcdir/$subdir as "gcc_start" does not do it
+	automatically.
+
+	* gcc.c-torture/noncompile/noncompile.exp (940712-1 test): No
+	longer expected to fail.
+
+	* gcc.c-torture/execute/strct-pack-3.c: Add missing argument to 
+	"f" function call.
+
+	* gcc.misc-tests/mg.exp: Call gcc_stat when finished.
+
+	* gcc.c-torture/execute/{920202-1.c, 931208-1.c, 931228-1.c,
+	940115-1.c, 940122-1.c, bf-pack-1.c, bf64-1.c, comp-goto-1.c,
+	complex-2.c, packed-1.c, strct-pack-2.c	strct-pack-3.c,
+	struct-ini-2.c, struct-ini-3.c, va-arg-1.c}: Import from
+	c-torture-1.29.
+
+	* gcc.c-torture/execute/{nest-stdar-1.c, struct-ini-1.c,
+	strct-pack-1.c, strct-varg-1.c}: Renamed to match c-torture-1.29.
+
+	* gcc.c-torture/execute/920612-2.c: Update to c-torture-1.29.
+
+	* gcc.c-torture/noncompile/{931203-1.c, 940112-1.c, 940227-1.c,
+	940510-1.c, init-1.c, init-2.c}: Import from c-torture-1.29
+
+	* gcc.c-torture/compile/{920928-6.c, 931203-1.c, 940611-1.c,
+	940712-1.c, calls.c, combine-hang.c, goto-1.c, init-2.c,
+	labels-1.c, packed-1.c, zero-strct-1.c}: Import from c-torture-1.29.
+
+Tue Jul 12 12:49:44 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* gcc.execute/{940712-1.c, 940712-2.c, 940713-1.c, 940714-1.c},
+	gcc.noncompile/{940712-1.h, 940712-1a.h, 940712-1b.h, 940712-1.c,
+	940714-1.c, 940714-2.c, 940714-3.c},
+	gcc.compile/{940713-1.c, 940713-2.c, 940714-1.c},
+	gcc.misc-tests/{mg.c,mg.exp}:
+	New tests.
+	* gcc.noncompile/noncompile.exp: Change accordingly.
+
+Thu Jul  7 14:20:33 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* config/sim.exp, lib/c-torture.exp, lib/gcc.exp:
+	Undo previous clobberage.
+
+Mon Jul  4 17:00:59 1994  Jeff Law  (law@snake.cs.utah.edu)
+
+	* gcc.compile/{931102-1.c, 931102-2.c, 931031-1.c}:
+	* gcc.special/{930510-1.c, special.exp}:
+	* gcc.execute/{931031-1.c, 931110-1.c, 931110-2.c, 931102-1.c,
+	931102-2.c, struct-pack-1.c, divmod-1.c, complex-1.c,
+	struct-varargs-1.c}: New tests from c-torture-1.26.
+
+Tue Jun 28 17:39:42 1994  J.T. Conklin  (jtc@phishhead.cygnus.com)
+
+	* gcc.wendy/wendy.exp: add --'s so that -1 isn't parsed as an
+	  argument to switch.
+
+Sat May 21 10:39:38 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* Revert the previous changes.  Please see Rob's directory
+	  (/lisa/test/rob/progressive/gcc/testsuite) for testing
+	  fixes.
+
+Thu May 19 18:00:03 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* config/sim.exp, config/udi.exp, config/unix.exp, config/vx.exp, 
+          g++.brendan/alignof.exp, g++.brendan/arm3.exp, g++.brendan/code-gen5.exp,
+          g++.brendan/crash29.exp, g++.brendan/crash5.exp, g++.brendan/cvt3.exp,
+          g++.brendan/delete1.exp, g++.brendan/nest12.exp, g++.brendan/nest13.exp,
+          g++.brendan/overload3.exp, g++.brendan/redecl1.exp, g++.brendan/visibility2.exp,
+          g++.jason/cond.exp, g++.jason/hmc1.exp, g++.jason/report.exp,
+          g++.law/access1.exp, g++.law/access2.exp, g++.law/arg6.exp, 
+          g++.law/arg7.exp, g++.law/arg8.exp, g++.law/arm1.exp, 
+          g++.law/arm10.exp, g++.law/arm4.exp, g++.law/arm5.exp,
+          g++.law/ctors15.exp, g++.law/ctors19.exp, g++.law/cvt1.exp,
+          g++.law/cvt12.exp, g++.law/cvt13.exp, g++.law/cvt18.exp, 
+          g++.law/cvt22.exp, g++.law/cvt3.exp, g++.law/cvt5.exp, 
+          g++.law/cvt6.exp, g++.law/cvt8.exp, g++.law/dtors3.exp, 
+          g++.law/except1.exp, g++.law/except3.exp, g++.law/except4.exp,
+          g++.law/except5.exp, g++.law/except6.exp, g++.law/init5.exp, 
+          g++.law/init8.exp, g++.law/inline4.exp, g++.law/memoized1.exp,
+          g++.law/missing1.exp, g++.law/operators14.exp, g++.law/operators18.exp,
+          g++.law/operators9.exp, g++.law/scope2.exp, g++.law/temps2.exp,
+          g++.law/temps3.exp, g++.law/temps5.exp, g++.law/typeck2.exp, 
+          g++.mike/misc4.exp, g++.mike/misc6.exp, g++.niklas/t118.exp,
+          g++.niklas/t128.exp, g++.niklas/t138.exp, g++.niklas/t139.exp,
+          g++.niklas/t140.exp, g++.niklas/t141.exp, gcc.code_quality/code_quality.exp,
+          gcc.compile/compile.exp, gcc.dje/dje.exp, gcc.execute/execute.exp, 
+          gcc.failure/failure.exp, gcc.ieee/ieee.exp, gcc.noncompile/noncompile.exp,
+          gcc.special/special.exp, gcc.unsorted/unsorted.exp, lib/c-torture.exp,
+          lib/chill.exp, lib/g++.exp, lib/gcc.exp, lib/mike-g++.exp, lib/mike-gcc.exp,
+          lib/old-dejagnu.exp: Checkin Rob's 94Q1 testing changes.
+
+Tue May 17 14:55:09 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* config/udi.exp, gcc.execute/execute.exp, gcc.wendy/wendy.exp,
+          lib/g++.exp, lib/old-dejagnu.exp: Replace error proc calls
+	  with perror calls.
+
+Mon May  2 17:41:13 1994  Jason Merrill  (jason@deneb.cygnus.com)
+
+	* config/unix.exp (g++_load): Fix syntax.
+
+Thu Apr 14 12:22:10 1994  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* gcc.compile/initbug1.exp (CFLAGS): Add space at beginning.
+	* gcc.noncompile/921017-1.c: Deleted obsolete test.
+	* gcc.noncompile/noncompile.exp: Remove code for deleted test.
+	Don't expect va-arg-1.c to fail.  Correct expected output for
+	920928-1.c.
+	* gcc.wendy/d.c, msgs.c, prolog.c, subs.c, z.c: Deleted.
+	* gcc.wendy/hbm4.c: Correct typo.
+	* gcc.wendy/tad1.c, tad2.c: Correct expected output.
+
+Mon Mar 28 13:29:37 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/gcc.exp (gcc_[ce]{pass,fail}): Remove output/executable argument.
+	* gcc.wendy/wendy.exp (wendy_try): Remove `output' argument of
+	gcc_[ce]{pass,fail}.  Explicitly remove executable if test passes.
+	* lib/c-torture.exp (c-torture-compile): Ditto.
+
+	Reduce volume of output (remove all the -I's and such).
+	* lib/c-torture.exp (c-torture-compile): New argument OPTION.
+	Call gcc_cpass, gcc_cfail.
+	(c-torture): Pass testing option to c-torture-compile.
+
+Mon Mar 21 12:40:33 1994  Doug Evans  (dje@cygnus.com)
+
+	Bring patches over from progressive.
+	* config/default.exp: Exit remote shell cleanly.
+	(g++_exit, g++_start): Add default versions.
+	* config/sim.exp (gcc_load): Use perror, not error.
+
+Sun Mar 20 12:05:32 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* lib/gcc.exp: Don't set CFLAGS if CC not set.  It clobbers the	value
+	set in site.exp.
+
+Mon Mar 14 19:30:28 1994  Doug Evans  (dje@cygnus.com)
+
+	* gcc.wendy/wendy.exp (wendy_first_line): New proc to fetch
+	DEJAGNU_OUTPUT and DEJAGNU_CFLAGS.
+	(wendy_try): New proc to run testcase.
+	(main loop): Call 'em.
+	* gcc.wendy/*.c: Clean up pass to correct expected output.
+
+	* lib/gcc.exp: Minor cleanup work.
+	(gcc_cpass, gcc_cfail, gcc_epass, gcc_efail): New procs.
+
+Wed Mar  9 15:22:54 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* config/sim.exp (gcc_load): Document return codes better.
+	Don't pass -v to simulator.
+
+Thu Feb 24 07:15:18 1994  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+        * gcc.special/920717-x.c: Fix typo.
+        * gcc.special/special.exp (920717-x.c): Use $srcdir/$subdir to
+        get at sources.
+
+	* lib/mike-gcc.exp: Fix typo.
+
+Tue Feb 15 15:41:47 1994  Rob Savoye  (rob@darkstar.cygnus.com)
+
+	* lib/gcc.exp: Minor cleanup work. Find the proper gcc or g++
+	binary to use, transform the name.
+	* config/*.exp: rename everything. Nuke any g++ specific files,
+	it's now a special case of gcc that requires no special support.
+	Add a default.exp for unsupported targets.
+
+Fri Feb 11 12:59:54 1994  Rob Savoye  (rob@poseidon.cygnus.com)
+
+	* g++.jason/report.exp, g++.old-deja/old-deja.exp,
+	lib/old-dejagnu.exp: Fix a few patterns to work with the new
+	version of Tcl.
+
+Wed Feb  9 21:35:47 1994  Rob Savoye  (rob@darkstar.cygnus.com)
+
+	* lib/c-torture.exp: Made "file prefix*never used a pass, rather
+	than a warning.
+
+Sun Feb  6 16:52:13 1994  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* lib/mike-gcc.exp: Add in recent changes from mike-g++.exp.
+
+Mon Jan  3 17:28:25 1994  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* gcc.execute/execute.exp: Combine opt_list and foption_list into
+	option_list.  Compile every file with only 4/6 option choices
+	(same as C torture) instead of with 12/18 different option
+	choices.
+	* lib/c-torture.exp: Likewise.
+
+	* lib/gcc.exp: Set LIBS, CFLAGS, and LDFLAGS to empty strings if
+	not already set.
+
+Thu Dec 30 17:17:07 1993  Mike Stump  (mrs@rtl.cygnus.com)
+
+	* lib/old-deja.exp: Add `excess errors test fails' error, now one
+	can put an XFAIL *-*-* on excess errors.
+
+Sun Dec 19 21:45:34 1993  Jeffrey A. Law  (law@snake.cs.utah.edu
+
+	* g++.law: Add more tests derived from g++-bugs snapshots.
+
+	* g++.law/init11.{c,exp}: Delete test.  Brendan sez it's 
+	equivalent to g++.law/init9.
+
+	* lib/mike-gcc.exp (postbase): Delete the .o file after we've
+	compiled it, and the a.out file after we've run it.
+
+Fri Dec 17 11:29:56 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* lib/mike-g++.exp (postbase): Delete the .o file after we've
+	compiled it, and the a.out file after we've run it.
+
+Fri Dec 17 10:18:16 1993  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* g++.law/*.exp: Avoid losing arguments added via "append" commands.
+
+Wed Dec 15 20:36:40 1993  Rob Savoye  (rob@darkstar.cygnus.com)
+
+	* lib/gcc.exp, lib/g++.exp: Use catch rather than exec to get the
+	version number. 
+
+Sun Dec 12 21:10:04 1993  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* g++.law: New directory of g++ tests derived from the g++-bugs
+	snapshots.
+
+Thu Dec 09 16:50:41 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* gcc.compile: initbug1.c initbug1.exp testcase added
+
+Mon Dec 06 11:09:52 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* gcc.dje/sizetype-1.exp, dje.exp: minor clean ups
+	* gcc.execute/execute.exp: minor cleanups. added gcc_stat calls. added
+	  fixes submitted by Jeff Law (law@cs.utah.edu)
+	* gcc.noncompile/noncompile.exp, lib/mike-gcc.exp: new files from
+	  Jeff Law (law@cs.utah.edu)
+
+
+Tue Nov 30 16:34:07 1993  Mike Stump  (mrs@cygnus.com)
+
+	* config/unix-g++.exp: Follow the gcc way of doing things.
+	* g++.old-deja/old-deja.exp: Minor updates.
+	* lib/g++.exp: New file, follow the gcc way of doing things.
+	* lib/old-dejagnu.exp: Minor updates.
+	* lib/mike-g++.exp: Always unset errorInfo.
+
+Sat Nov  6 11:34:51 1993  Mike Stump  (mrs@cygnus.com)
+
+	* lib/gcc.exp: Fix some errors with the below change, CC and
+	CFLAGS should be global when setting, not local.
+
+Wed Nov  3 11:16:26 1993  Rob Savoye  (rob@darkstar.cygnus.com)
+
+	* lib/gcc.exp: Transform tool name.
+
+Wed Oct 27 23:57:29 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* gcc.*/*.exp: Fixd some de-stablizing changes. Sorry.
+
+Wed Oct 27 14:45:50 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* lib/gcc.exp: change gcc_done to gcc_stat
+
+Wed Oct 27 09:57:51 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* Upgraded gcc testsuite to c-torture version 1.25
+
+Sun Oct 24 10:58:03 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* lib/gcc.exp: added reporting code. Changed verbose compile message.
+	* lib/c-torture: added hooks for new reporting code.
+
+Thu Oct 21 18:45:32 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* config/sh-gcc.exp: check if sh-sim exists in the path
+
+Mon Oct 18 11:13:22 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* gcc.code_quality/code_quality.exp: Initial changes for new logic.
+	* gcc.compile/compile.exp: Initial changes for new logic.
+	* gcc.dje/dje.exp, sizetype-1.exp: Initial changes for new logic.
+	* gcc.failure/failure.exp: Initial changes for new logic.
+	* gcc.ieee/ieee.exp: Initial changes for new logic.
+	* gcc.misc-tests/misc.exp: Initial changes for new logic.
+	* gcc.noncompile/non_compile.exp: Initial changes for new logic.
+	* gcc.unsorted/unsorted.exp: Initial changes for new logic.
+	* lib/c-torture.exp: Initial changes for new logic.
+	* lib/gcc.exp: Initial changes for new logic.
+
+Fri Oct 15 00:19:42 1993  Mike Stump  (mrs@cygnus.com)
+
+	* lib/mike-g++.exp, lib/old-dejagnu.exp: Make the message not
+	depend upon failure or success.  Fully qualify names in failure
+	and success messages.  Always remove a.out before starting
+	compile, just in case.  Pay more attention to error text output by
+	the compiler.  Handle testcases with no known past errors just
+	like all others, so that things are uniform.  Other miscellaneous
+	improvements.
+
+Wed Oct 13 15:04:51 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* gcc.cpp: new directory for cpp tests
+
+Mon Oct  4 09:03:41 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* lib/chill.exp: Code reformatted, removed unused code.
+	* config/unix-chill.exp: Code reformatted, removed unused code.
+	* chill.execute/execute.exp: Code reformatted, removed unused code.
+	* chill.execute/oe/orient.exp: Code reformatted, removed unused code.
+
+Mon Oct  4 06:19:26 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config/mips-gcc.exp, config/mips-g++.exp: New files.  Execution
+	routines not written.
+
+Mon Sep 27 21:07:44 1993  Rob Savoye  (rob@darkstar.cygnus.com)
+
+	* config/bug-gcc.exp: Use new procs from bug.exp.
+
+Tue Sep 21 18:21:12 1993  Rob Savoye  (rob@darkstar.cygnus.com)
+
+	* config/vx-gcc.exp: Use new vxworks_ld proc, so files get loaded
+	via ftp, rather than depending on NFS.
+	* config/vx-gcc.exp: Use new vxworks_spawn proc to execute test
+	case.
+
+Thu Sep  9 23:09:15 1993  Rob Savoye  (rob@darkstar.cygnus.com)
+
+	* config/bug-gcc.exp: Use new download proc.
+
+Tue Sep 14 19:23:58 1993  Jeffrey Wheat  (cassidy at deneb.cygnus.com)
+
+	* chill.execute/execute.exp: cleanups, handles errors better
+	* chill.compile/compile.exp: rewrite, based on execute.exp
+	* chill.noncompile/noncompile.exp: rewrite, based on execute.exp
+	* lib/chill.exp: major changes to diff proc and compile and link
+	  procs. added chill_fail and chill_pass wrappers to pass and
+	  fail. added more comments, and handle error codes better. 
+	  Added a hack to capture stderr from exec, so noncompile tests
+	  can work.
+	  
+Sat Sep 11 15:30:10 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* chill.execute/execute.exp: rewrite of testsuite driver
+	* lib/chill.exp: rewrite of testsuite driver
+	* config/unix-chill.exp: rewrite of testsuite driver
+
+Wed Aug 25 14:11:13 1993  Bill Cox  (bill@rtl.cygnus.com)
+
+    In chill.execute:
+	* iexpr.ch: Standardize uppercase.
+	* tuples.dat: Standardize uppercase.
+	* vary.ch: standardize.  Correct varying string assignments.
+	* vary.dat: Add new output lines.
+
+Tue Aug 24 13:45:49 1993  Bill Cox  (bill@rtl.cygnus.com)
+
+    In chill.execute:
+	* chprintf.ch: Standardize use of uppercase.
+	* tuples.ch: Standardize and turn arr2 into a DCL,
+	  rather than a SYN.
+	* pinits.ch: Standardize.
+
+Mon Aug 23 17:26:58 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* rts.c:  Get malloc() from <stdlib.h>, not <malloc.h>.
+	* Makefil: Renamed to Makefile.in.
+	* configure.in: New.
+
+Mon Aug 23 14:24:13 1993  Bill Cox  (bill@rtl.cygnus.com)
+
+    In chill.execute:
+	* .cvsignore: Add result/output files.
+	* Makefile: Fix up variables at start.  Use MFLAGS
+	  everywhere.  Correct bool_loc, built_ins entries.
+	  Add entry for vary1.ch.
+	* bitarray.ch: Standardize upper-case usage.
+	* bitexpr.ch: Standardize, add output of b1.
+	* params.ch: Use arrayt in along PROC parameters, to
+	  avoid novelty problems.
+	* sets.ch: Tiny cleanup.
+	* vary1.ch: Re-indent.
+
+Tue Aug 17 15:42:07 1993  Bill Cox  (bill@rtl.cygnus.com)
+
+        * Add PR-related files to Makefiles, .cvsignore files, etc.
+
+Mon Aug  2 15:46:05 PDT 1993  Jeff Wheat  (cassidy@cygnus.com)
+
+	* gcc.unsorted: flow.c and loop.c - renamed to avoid conflicts
+	  with compiler objects. New names are test-flow.c and test-loop.c
+
+Tue Jul 27 10:08:08 PDT 1993  Jeff Wheat  (cassidy@cygnus.com)
+
+	* Upgraded c-torture tests from 1.19 to 1.20
+
+	* new files:
+	* gcc.compile: 930609-1.c 930611-1.c 930618-1.c 930621-1.c 
+	* gcc.compile: 930623-1.c 930623-2.c 
+	* gcc.noncompile: 930622-1.c 930622-2.c
+	* gcc.failure: 920411-1.c 920627-2.c
+	* gcc.ieee: 920518-1.c 920810-1.c 930529-1.c
+
+Tue Jul 20 15:19:44 PDT 1993  Jeff Wheat  (cassidy@cygnus.com)
+
+	* chill.compile/compile.exp chill.execute/execute.exp lib/chill.exp
+	  More changes to get testsuite working properly. Needs more work.
+	  Added some support for POSIX IEEE Std 1003.3-1991 error messages.
+
+Mon Jul 19 18:40:31 PDT 1993  Jeff Wheat  (cassidy@cygnus.com)
+
+	* chill.compile/compile.exp chill.execute/execute.exp lib/chill.exp
+	  More changes to get testsuite working properly. Needs more work.
+
+Tue Jul 13 18:38:56 PDT 1993 Jeff Wheat  (cassidy@cygnus.com)
+
+	* chill.compile/compile.exp: Added for Dejagnu support
+	* chill.execute/execute.exp: Added for Dejagnu support
+	* lib/chill.exp config/unix-chill.exp  : Added for Dejagnu support
+
+Sat Jun 19 07:13:05 1993  Bill Cox  (bill@rtl.cygnus.com)
+
+    This should complete moving the CHILL test files.
+	* chill.noncompile(.cvsignore printf.grt 
+          in-printf.grt chprintf.grt chprintf.ch):
+          Added test-support files.
+	  (Makefile): Modified further.
+	* chill.compile (emptymod.ch gdbme.ch neg_range.ch
+          signal.ch): Added test files.
+        * chill.execute (.cvsignore printf.grt printr.c
+          in-printf.grt rts.c chprintf.grt rts.h): Added
+	  test-support files.
+          (Makefile): More corrections.
+
+Fri Jun 18 23:40:54 1993  Bill Cox  (bill@rtl.cygnus.com)
+
+	* chill.compile, chill.execute, chill.nocompile: Add CHILL
+	  test cases, ready for DejaGnu.
+
+Thu Jun 17 19:14:40 MDT 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* Upgraded c-torture tests from 1.18 to 1.19
+
+	* gcc.compile: added test(s):
+	  930607-1.c
+	* gcc.execute: added test(s):
+	  930603-1.c 930603-2.c 930603-3.c 930608-1.c conversion.c inst-check.c
+
+	* added new subdirectory for misc tests: gcc.misc-tests
+	* gcc.misc-test(s): added tests:
+	  inst-check.c test-consts.c test-ior.c test-switch.c
+
+Wed Jun  9 16:53:26 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* lib/mike-g++.exp: Load `./a.out', not `a.out'.
+
+Mon Jun  7 16:18:40 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* g++.old-deja/old-deja.exp: Don't delete all the .o files.
+
+Thu Jun  3 13:13:36 MDT 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* Upgraded c-torture tests from 1.17 to 1.18
+
+Wed Jun  2 19:02:40 MDT 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* Upgraded c-torture tests from 1.12 to 1.17
+
+Fri Apr 30 09:38:41 1993  Mike Werner  (mtw@deneb.cygnus.com)
+
+	* lib/old-dejagnu.exp:
+	  Fixed handling of XFAIL target triplets to correctly
+	  recognize wildcard characters.  Removed code that
+	  appended a unique id tag to the end of the file name
+	  printed out by the result of the testcases within a
+	  given test file.
+
+Thu Apr 29 19:06:29 1993  Mike Werner  (mtw@deneb.cygnus.com)
+
+	* lib/old-dejagnu.exp:
+	  Reworked expected failure handling to trigger off of XFAIL
+	  keyword in keyphrase embeded in testcase source code. The
+	  XFAIL keyword must be at the end of the keyphrase line. It
+	  may optionally be followed by one or more target triplets.
+	  It has just occured that the handling of wildcards in the
+	  target triplet may not be correct.
+
+Fri Apr 23 13:16:20 1993  Mike Werner  (mtw@deneb.cygnus.com)
+
+	* g++.old-deja/tests:
+	  Moved all subdirectories up one level into g++.old-deja .
+
+	* lib/old-dejagnu.exp:
+	  Fixed problem with CXXFLAGS not being properly reset, and being
+	  corrupted with extraneous "-c" compiler option.  This was
+	  causing binaries to not be generated for test that needed them.
+	  Modified strings passed to "pass" and "fail" so that individual
+	  tests from the same test file would be distinguished by an
+	  identifier appended to the test file name in the summary logs;
+	  this corrected a problem with erroneous diff logs.  Added code
+	  to search testcases for expected fail and unexpected pass keywords.
+
+Tue Apr 20 18:27:58 1993  Rob Savoye  (rob at darkstar.cygnus.com)
+
+	* lib/c-torture.exp: Ignore "file path prefix*unused" message.
+
+Thu Apr 15 11:01:59 1993  Mike Werner  (mtw@deneb.cygnus.com)
+
+	* g++.old-deja/tests/g++.sun/g++.frag/1045608.C:
+	  Removed extraneous text from end of "Special g++ Options"
+	  keyphrase.
+
+	* lib/old-dejagnu.exp: Added pattern matching to look for new
+	  keywords, embedded in testcases comments, which will trigger
+	  calls to xpass and xfail.
+
+Wed Apr 14 14:28:01 1993  Mike Werner  (mtw@deneb.cygnus.com)
+
+	* lib/old-dejagnu.exp: Cleaned up pattern matching for keyphrase
+	  comments embedded in the testcases, especially the one looking for
+	  special compiler options, as well as the pattern matching for the
+	  compiler output again.
+
+Mon Apr 12 15:15:37 1993  Mike Werner  (mtw@deneb.cygnus.com)
+
+	* lib/old-dejagnu.exp: Do a proper check of the return value for
+	  execute tests. Fixed several problems with the pattern matching
+	  of the compiler output which gave erroneous test results.
+	  Changed several of the test result messages to be more descriptive.
+	* config/unix-g++.exp: Proc g++_load now actually works and
+	  executes the tests passed to it and returns a usable return
+	  value. 
+
+Sun Apr 11 17:22:37 1993  Rob Savoye  (rob at darkstar.cygnus.com)
+
+        * lib/gcc.exp: Exits gracefully if $CC is bogus.
+
+Fri Apr  9 09:41:59 1993  Mike Werner  (mtw@deneb.cygnus.com)
+
+	* lib/old-dejagnu.exp , g++.old-deja/old-deja.exp:
+	  Modified both files to properly execute the old style
+	  dejagnu tests. The previous versions of these files were
+	  experimental and did not function anything near correctly.
+
+Mon Apr  5 21:08:24 1993  Rob Savoye  (rob@cygnus.com)
+
+	* Removed all Makefile.in and configure.in files. No configuration
+	needed now.
+
+Fri Apr  2 12:15:17 1993  Mike Werner  (mtw@deneb.cygnus.com)
+
+	* lib: relocated old-dejagnu.exp from devo/dejagnu/lib
+
+Sun Mar 28 11:17:48 1993  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* gcc.compile/configure.in, gcc.unsorted/configure.in,
+	gcc.special/configure.in, gcc.noncompile/configure.in,
+	gcc.execute/configure.in, gcc.code_quality/configure.in,
+	g++.other/configure.in, g++.old-deja/configure.in,
+	g++.niklas/configure.in, g++.mike/configure.in: Remove extra quote
+	in srcname setting.
+
+Thu Mar 25 20:07:55 1993  Rob Savoye  (rob at darkstar.cygnus.com)
+
+	* lib/udi.exp:  Fixed mondfe and mondfe_download.
+	* config/udi-gcc.exp: Fixed misc bugs, works with expect 4.x.
+	* config/abug-gcc.exp: Fixed misc bugs, works with expect 4.x.
+
+Thu Mar 25 13:06:41 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config/udi-gdb.exp: Check $shell_id after connecting to target.
+	(gdb_exit): Don't remove *_soc files.
+
+Mon Mar 22 14:28:46 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* lib/c-torture.exp: Don't look for main; instead always use -w
+	-c.  This is how the c-torture tests work.  Remove the object
+	file if the compilation succeeds.
+	* gcc.execute/execute.exp: Remove executable if test passes.
+	* gcc.noncompile/noncompile.exp: Every test is an expected
+	failure.
+	* gcc.special/special.exp: Added tests from c-torture 1.11,
+	corrected use of existing test.
+	* gcc.execute/920302-1.c, gcc.execute/920501-8.c,
+	gcc.execute/920625-1.c: Updated to c-torture 1.11.
+	* gcc.compile/921103-1.c, gcc.compile/921109-1.c,
+	gcc.compile/921109-2.c, gcc.compile/921109-3.c,
+	gcc.compile/921111-1.c, gcc.compile/921116-2.c,
+	gcc.compile/921118-1.c, gcc.compile/921126-1.c,
+	gcc.compile/921202-1.c, gcc.compile/921202-2.c,
+	gcc.compile/921203-1.c, gcc.compile/921203-2.c,
+	gcc.compile/921206-1.c, gcc.execute/921029-1.c,
+	gcc.execute/921104-1.c, gcc.execute/921110-1.c,
+	gcc.execute/921112-1.c, gcc.execute/921113-1.c,
+	gcc.execute/921117-1.c, gcc.execute/921123-1.c,
+	gcc.execute/921123-2.c, gcc.execute/921124-1.c,
+	gcc.execute/921202-1.c, gcc.execute/921202-2.c,
+	gcc.execute/921204-1.c, gcc.execute/921207-1.c,
+	gcc.execute/921208-1.c, gcc.execute/921208-2.c,
+	gcc.execute/921215-1.c, gcc.execute/921218-1.c,
+	gcc.execute/921218-2.c, gcc.noncompile/921102-1.c,
+	gcc.noncompile/921116-1.c, gcc.unsorted/x.c: Added from
+	c-torture 1.11.
+	* gcc.noncompile/921021-1.c, gcc.unsorted/x11bug.c: Removed to
+	correspond to c-torture	1.11.
+
+	* New file.
+
diff --git a/gcc/testsuite/README b/gcc/testsuite/README
new file mode 100644
index 00000000000..7d064730daf
--- /dev/null
+++ b/gcc/testsuite/README
@@ -0,0 +1,50 @@
+This is a collection of tests for the C and C++ frontends of EGCS. For
+further information please check README.gcc and README.g++, though the
+latter may not be up-to-date any more.
+
+The driver that runs this testsuite is called DejaGnu and you will
+need a current DejaGnu snapshot, which is available from
+ftp://egcs.cygnus.com/pub/egcs/infrastructure, for example.
+
+Most of these tests were originally developed and/or collected by
+Cygnus Solutions, but these days many are being added by the EGCS
+developers.
+
+These tests are included "as is". If any of them fails, do not report
+a bug.  Bug reports for DejaGnu can go to bug-dejagnu@prep.ai.mit.edu.
+Discussion and comments about this testsuite should be sent to
+gcc@gcc.gnu.org; additions and changes to should go to sent to
+gcc-patches@gcc.gnu.org.
+
+The entire testsuite is invoked by `make check` at the top level of
+the EGCS tree. `make check-g++` runs the C++ testsuite only.
+
+
+STRUCTURE OF THE TESTSUITE
+
+Almost all C++ tests reside in subdirectories of g++.old-deja, based on
+the following structure:
+
+  g++.benjamin	Tests by Benjamin Koz
+  g++.bob
+  g++.brendan	Tests by Brendan Kehoe
+  g++.bugs
+  g++.eh  	Tests for exception handling
+  g++.ext  	Tests for g++ extensions
+  g++.gb  	Tests by Gerald Baumgartner
+  g++.jason	Tests by Jason Merill
+  g++.jeff	Tests by Jeffrey A Law
+  g++.martin	Tests by Martin v. Löwis
+  g++.mike	Tests by Mike Stump
+  g++.niklas	Tests by Niklas Hallqvist
+  g++.ns  	Tests for namespaces
+  g++.other
+  g++.pt  	Tests for templates
+  g++.rfg
+  g++.robertl	Tests from gcc-bugs@gcc.gnu.org, gathered by Robert Lipe
+	
+g++.old-deja uses a fixed driver for all g++ tests based on the old
+DejaGnu drivers. But just because its old, doesn't mean its redundant!
+Tests that want to use the normal dg.exp driver can be put in g++.dg instead.
+This may be required for platform-specific tests, or tests with other
+special requirements.
diff --git a/gcc/testsuite/README.g++ b/gcc/testsuite/README.g++
new file mode 100644
index 00000000000..7ded0fdade4
--- /dev/null
+++ b/gcc/testsuite/README.g++
@@ -0,0 +1,33 @@
+Here are some random last minute notes by this file's original maintainer,
+Mike Stump <mrs@cygnus.com>:
+
+> and the command
+
+>       runtest --tool g++ --srcdir ./testsuite
+
+> doesn't work.  I got it to work by explicitly setting CXX and CXXFLAGS
+> on the command line, e.g.
+
+> runtest --tool g++ --srcdir ./testsuite CXX=g++ CXXFLAGS=""
+
+site.exp updated to have right CXXFLAGS and CXX, but not at the FSF yet.
+
+
+  To run the tests, first change to the gcc-2.7.1 directory, then type:
+
+	runtest --tool g++ --srcdir ./testsuite
+
+Here's a brief explanation.
+
+runtest         - Is the name used to invoke DejaGnu.   If DejaGnu is not
+		  install this will be the relative path name for runtest.
+
+--tool          - This tells DejaGnu which tool you are testing. It is
+                  mainly used to find the testsuite directories for a
+                  particular tool when several testsuites are in the
+                  same directory. (like the gcc and g++ testsuites)
+
+--srcdir        - This points to the top level of the directory
+                  containing the sources of the testsuite. This is
+                  ./testsuite if you are in the directory that has the
+                  testsuite directory.
diff --git a/gcc/testsuite/README.gcc b/gcc/testsuite/README.gcc
new file mode 100644
index 00000000000..17904bceae5
--- /dev/null
+++ b/gcc/testsuite/README.gcc
@@ -0,0 +1,87 @@
+This file contains a list of notes for those writing testcases and those
+writing expect scripts.  At present, they're in random order.
+
+Verbosity Levels
+
+- each level adds verbosity so level 2 prints all level 1 and level 2 stuff.
+
+1) Print a one-liner indicating the testcase being run (and maybe special
+   compiler options).
+
+2) Print compiler and program invocation including arguments and their output.
+   Proc's gcc_load and gcc_start handle the latter two.
+
+3) Print detailed testcase analysis like "Looking for pattern ...", etc.
+
+4) Maximum verbosity.  Print anything else of interest.
+
+send_log conventions
+
+Various messages are stored in gcc.log by the testing framework and we
+try to augment them with some of our own.  The format of the framework
+messages are:
+
+PASS: blah blah ...
+FAIL: blah blah ...
+
+so we use
+
+XXXX: blah blah ...
+
+Current messages are:
+
+EXEC: program being executed (so compiler path and args are recorded)
+STAT: intermediate pass/fail statistics
+
+Test scripts must ignore the compiler messages "path prefix never used"
+and "linker input file unused".  Don't let their appearance cause a testcase
+to fail.  See lib/dg.exp for the exact regsub to use.
+
+If you're unclear about which directory a testcase should be installed in,
+ask gcc-local.
+
+Have the text of a fail message be the same as that for pass.
+IE: have
+
+        if ...success...
+                pass "pr 1234"
+        else
+                fail "pr 1234"
+
+not
+
+        if ...success...
+                pass "pr 1234 passed"
+        else
+                fail "pr 1234 failed"
+
+
+This lets test-tool (which drives the nightly tests) do a better job
+at tracking which tests have digressed or been fixed.
+
+DO NOT PUT NON-PORTABLE TESTCASES IN gcc.c-torture.
+
+ANY TARGET SPECIFIC TESTCASE MUST HAVE APPROPRIATE CODE TO PREVENT IT FROM
+CAUSING A `FAILURE' ON UNSUPPORTED PLATFORMS.
+
+The "torture" tests are meant to be generic tests that can run on any
+target.  So you have to be careful about endianness, assumptions about
+sizes of datatypes, etc etc.
+
+For tests that merely need to compile, put them in the "compile" directory.
+
+For tests which should give an error, put them in the "noncompile" directory
+and update noncompile.exp appropriately (see examples in noncompile.exp).
+
+For IEEE FP specific tests, put them in execute/ieee.
+
+For execution tests, put them in execute.
+
+Always use abort() for runtime failures, and exit(0) for success.
+The testing harness is set up to watch for these and do something appropriate
+(when necessary) for target boards.
+
+If a test does not fit into the torture framework, use the dg framework.
+
+
+
diff --git a/gcc/testsuite/config/default.exp b/gcc/testsuite/config/default.exp
new file mode 100644
index 00000000000..9ae55bc6a76
--- /dev/null
+++ b/gcc/testsuite/config/default.exp
@@ -0,0 +1,20 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+load_lib "standard.exp"
diff --git a/gcc/testsuite/g++.dg/special/conpr-1.C b/gcc/testsuite/g++.dg/special/conpr-1.C
new file mode 100644
index 00000000000..8ab6bfee258
--- /dev/null
+++ b/gcc/testsuite/g++.dg/special/conpr-1.C
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+
+class foo_t {
+    int x;
+public:
+    foo_t(void) { x=1; }
+    int get(void) { return x; }
+};
+
+static foo_t foo __attribute__((init_priority(5000)));
+
+int main(void) {
+
+    if (foo.get())
+        exit(0);
+    else
+        abort();
+}
diff --git a/gcc/testsuite/g++.dg/special/conpr-2.C b/gcc/testsuite/g++.dg/special/conpr-2.C
new file mode 100644
index 00000000000..07ba8ab9e89
--- /dev/null
+++ b/gcc/testsuite/g++.dg/special/conpr-2.C
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+
+class foo_t {
+    int x;
+    static int count;
+public:
+    foo_t(void) { x=++count; }
+    int get(void) { return x; }
+};
+
+int foo_t::count;
+
+extern foo_t foo1, foo2;
+
+int main(void) {
+
+    if ( (foo1.get() != 2) || (foo2.get() != 1) )
+        abort();
+    exit(0);
+}
diff --git a/gcc/testsuite/g++.dg/special/conpr-2a.C b/gcc/testsuite/g++.dg/special/conpr-2a.C
new file mode 100644
index 00000000000..69fb7d64831
--- /dev/null
+++ b/gcc/testsuite/g++.dg/special/conpr-2a.C
@@ -0,0 +1,12 @@
+/* { dg-do run } */
+
+class foo_t {
+    int x;
+    static int count;
+public:
+    foo_t(void) { x=++count; }
+    int get(void) { return x; }
+};
+
+foo_t foo1 __attribute__((init_priority(6000)));
+foo_t foo2 __attribute__((init_priority(5000)));
diff --git a/gcc/testsuite/g++.dg/special/conpr-3.C b/gcc/testsuite/g++.dg/special/conpr-3.C
new file mode 100644
index 00000000000..07ba8ab9e89
--- /dev/null
+++ b/gcc/testsuite/g++.dg/special/conpr-3.C
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+
+class foo_t {
+    int x;
+    static int count;
+public:
+    foo_t(void) { x=++count; }
+    int get(void) { return x; }
+};
+
+int foo_t::count;
+
+extern foo_t foo1, foo2;
+
+int main(void) {
+
+    if ( (foo1.get() != 2) || (foo2.get() != 1) )
+        abort();
+    exit(0);
+}
diff --git a/gcc/testsuite/g++.dg/special/conpr-3a.C b/gcc/testsuite/g++.dg/special/conpr-3a.C
new file mode 100644
index 00000000000..b237bb57f36
--- /dev/null
+++ b/gcc/testsuite/g++.dg/special/conpr-3a.C
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+
+class foo_t {
+    int x;
+    static int count;
+public:
+    foo_t(void) { x=++count; }
+    int get(void) { return x; }
+};
+
+foo_t foo1 __attribute__((init_priority(6000)));
diff --git a/gcc/testsuite/g++.dg/special/conpr-3b.C b/gcc/testsuite/g++.dg/special/conpr-3b.C
new file mode 100644
index 00000000000..b5efa0c35f6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/special/conpr-3b.C
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+
+class foo_t {
+    int x;
+    static int count;
+public:
+    foo_t(void) { x=++count; }
+    int get(void) { return x; }
+};
+
+foo_t foo2 __attribute__((init_priority(5000)));
diff --git a/gcc/testsuite/g++.dg/special/ecos.exp b/gcc/testsuite/g++.dg/special/ecos.exp
new file mode 100644
index 00000000000..34a54b7f428
--- /dev/null
+++ b/gcc/testsuite/g++.dg/special/ecos.exp
@@ -0,0 +1,75 @@
+# Copyright (C) 1999 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 
+
+# Please email any bugs, comments, and/or additions to this file to:
+# jlarmour@cygnus.co.uk
+
+# This file was written by Jonathan Larmour (jlarmour@cygnus.co.uk).
+
+# G++ testsuite that uses the `dg.exp' driver.
+
+# Load support procs.
+load_lib g++-dg.exp
+
+###########
+# conpr-1.C
+###########
+
+dg-init
+dg-runtest "$srcdir/$subdir/conpr-1.C" "-finit-priority" ""
+dg-finish
+
+
+###########
+# conpr-2.C
+###########
+
+dg-init
+
+set lines [g++_target_compile "$srcdir/$subdir/conpr-2a.C" "conpr-2a.o" object "additional_flags=-finit-priority"]
+if ![string match "" $lines] then {
+    fail "conpr-2a.o"
+} else {
+    dg-runtest "$srcdir/$subdir/conpr-2.C" "conpr-2a.o" "-finit-priority" 
+    file delete conpr-2a.o
+}
+dg-finish
+
+
+###########
+# conpr-3.C
+###########
+
+dg-init
+
+set lines [g++_target_compile "$srcdir/$subdir/conpr-3a.C" "conpr-3a.o" object "additional_flags=-finit-priority"]
+if ![string match "" $lines] then {
+    fail "conpr-3a.o"
+} else {
+    set lines [g++_target_compile "$srcdir/$subdir/conpr-3b.C" "conpr-3b.o" object "additional_flags=-finit-priority"]
+    if ![string match "" $lines] then {
+        fail "conpr-3b.o"
+    } else {
+        # run it with objects both ways around!
+        dg-runtest "$srcdir/$subdir/conpr-3.C" "conpr-3a.o conpr-3b.o" "-finit-priority"
+        dg-runtest "$srcdir/$subdir/conpr-3.C" "conpr-3b.o conpr-3a.o" "-finit-priority"
+        file delete conpr-3a.o conpr-3b.o
+    }
+}
+dg-finish
+
+
+### EOF ecos.exp
diff --git a/gcc/testsuite/g++.old-deja/Makefile.in b/gcc/testsuite/g++.old-deja/Makefile.in
new file mode 100644
index 00000000000..e6209dbc6c2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+	-rm -f *.o *.diff *~ *.bad core *.x
+
+distclean:	clean
+	-rm -f Makefile config.status
diff --git a/gcc/testsuite/g++.old-deja/configure.in b/gcc/testsuite/g++.old-deja/configure.in
new file mode 100644
index 00000000000..c6cacc6757d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=old-deja.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/.cvsignore b/gcc/testsuite/g++.old-deja/g++.benjamin/.cvsignore
new file mode 100644
index 00000000000..7abff1dbead
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/.cvsignore
@@ -0,0 +1,2 @@
+Makefile
+config.status
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/13478.C b/gcc/testsuite/g++.old-deja/g++.benjamin/13478.C
new file mode 100644
index 00000000000..97256ed7643
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/13478.C
@@ -0,0 +1,36 @@
+// 981203 bkoz
+// g++/13478
+// Build don't link:
+  
+class A {};
+class AData {};
+
+typedef void (A::* hand) (void);
+
+struct hand_table {
+  const int data1;
+  const hand data2;
+};
+
+class Agent : public A {
+public:
+  enum { first = 1, last };
+protected:
+  static const hand_table table_1[];
+  static const AData 	  table_2;
+private:
+  void foo (void);
+};
+
+const hand_table Agent::table_1[] = 
+{
+   {0,     &Agent::table_2},
+   {first, &Agent::foo},
+   {last,  &(hand)Agent::foo} // ERROR - // ERROR -
+}; // ERROR - // ERROR -
+
+
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/13523.C b/gcc/testsuite/g++.old-deja/g++.benjamin/13523.C
new file mode 100644
index 00000000000..eca71fa2f7b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/13523.C
@@ -0,0 +1,12 @@
+// 981203 bkoz
+// g++/13523
+// Build don't link: 
+
+template<typename T> class latin_america;
+
+class peru
+{
+  friend class latin_america<int>;  // Particular template class friend works
+  template<class T> friend class latin_america; // This does not work.
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/13908.C b/gcc/testsuite/g++.old-deja/g++.benjamin/13908.C
new file mode 100644
index 00000000000..403a9988dfd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/13908.C
@@ -0,0 +1,21 @@
+// 981203 bkoz
+// g++/13908
+// Build don't link: 
+
+class chile
+{
+public:
+protected:
+private:
+};
+
+typedef void (chile::* pmf) ();
+
+void* foo;
+
+void bar (chile* pobj, pmf pmethod)
+{
+  //-edg: expected member name
+  //-g++: taking address of bound pointer-to-member expression
+  foo = (void*) &(pobj->*pmethod);  // ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/14139.C b/gcc/testsuite/g++.old-deja/g++.benjamin/14139.C
new file mode 100644
index 00000000000..dc0c5695f15
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/14139.C
@@ -0,0 +1,22 @@
+// 981203 bkoz
+// g++/14309
+// test for global functions, mf's, and templatized mf's.
+// Build don't link: 
+
+static int fooe_1(void) { return 5; }
+static int fooe_2(int x = fooe_1()) { return x; }
+
+struct antigua {
+  static int& foo_1();
+  static int foo_2(int& x = antigua::foo_1());
+  static int foo_3(int x = fooe_2());
+};
+
+template <typename T>
+  struct jamacia {
+    static int& foo_1();
+    static int foo_2(int& x = antigua::foo_1());
+    static int foo_3(int x = fooe_2());
+  };
+
+template class jamacia<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/14664-1.C b/gcc/testsuite/g++.old-deja/g++.benjamin/14664-1.C
new file mode 100644
index 00000000000..b5dc839f884
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/14664-1.C
@@ -0,0 +1,16 @@
+// 981203 bkoz
+// g++/14664 - test
+// Build don't link: 
+// Special g++ Options: -fconst-strings
+
+char foo[26];
+
+void bar()
+{
+  //-g++: incompatible types in assignment of 'const char[]' to 'char[]'
+  //-edg: expression must be a modifiable lvalue
+  foo = "0123456789012345678901234"; // ERROR - // ERROR -
+}
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/14664-2.C b/gcc/testsuite/g++.old-deja/g++.benjamin/14664-2.C
new file mode 100644
index 00000000000..35dc0b2f6ad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/14664-2.C
@@ -0,0 +1,16 @@
+// 981203 bkoz
+// g++/14664 + test
+// Build don't link: 
+// Special g++ Options: -fno-const-strings
+
+char foo[26];
+
+void bar()
+{
+  // the addition of the flag "-fno-const-string-literal" reverts to pre-ISO.
+  // -g++: ANSI C++ forbids assignment of arrays
+  foo = "0123456789012345678901234"; // WARNING -
+}
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/14687.C b/gcc/testsuite/g++.old-deja/g++.benjamin/14687.C
new file mode 100644
index 00000000000..c2a9a99d0c2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/14687.C
@@ -0,0 +1,53 @@
+// 981203 bkoz
+// g++/14687
+// excess errors test - XFAIL *-*-*
+
+#include <assert.h>
+unsigned int gtest;
+
+// 7.3.3 the using declaration
+
+// p 3
+struct belieze {
+  void f(char);
+  void g(char);
+  enum E { e };
+  union { int x; };
+};
+
+struct dominica: belieze {
+  using belieze::f;
+  void f(int i) { f('c'); } // calls belieze::f(char)
+  void g(int i) { g('c'); } // recursively calls dominca::g(int)
+};
+
+
+// p 6
+namespace A {
+  void f(int i) { gtest = 1; }
+}
+
+using A::f; 	 //f is a synonym for A::f, that is for A::f(int)
+
+namespace A {
+  void f(char c) { gtest = 3; }
+}
+
+void foo(void) {
+  f('a'); 	 //calls f(int), even though A::f(char) exits
+  assert (gtest = 1);
+}
+
+void bar(void) {
+  using A::f;    //f is a synonm for A::f, that is for A::f(int) and A::f(char)
+  f('a'); 	 //calls f(char)
+  assert (gtest = 3);
+}
+
+int main(void)
+{
+  foo();
+  bar();
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15054.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15054.C
new file mode 100644
index 00000000000..65688f70a31
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15054.C
@@ -0,0 +1,10 @@
+// 981203 bkoz
+// g++/15054
+// Build don't link: 
+// Special g++ Options: -Wno-pointer-arith
+// note that -pedantic also turns on this warning
+
+void cuba(void) {
+  void* p; 
+  p++;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15071.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15071.C
new file mode 100644
index 00000000000..d05ba8c00dd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15071.C
@@ -0,0 +1,11 @@
+// 981203 bkoz
+// g++/15071
+// gcc invocation fails to link in libstdc++
+
+#include <iostream.h>
+
+int main() {
+  cout<<"hi"<<endl;
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15309-1.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15309-1.C
new file mode 100644
index 00000000000..ec83fb46ae4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15309-1.C
@@ -0,0 +1,21 @@
+// 981203 bkoz
+// g++/15309
+// Build don't link: 
+// Special g++ Options: -Wnon-virtual-dtor -Weffc++
+
+class bahamian {
+public:
+  bahamian ();
+  ~bahamian ();  
+};
+
+class miami : public bahamian
+{
+public:
+   miami ();
+   ~miami ();
+}; // WARNING - // WARNING -        
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15309-2.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15309-2.C
new file mode 100644
index 00000000000..1b483c869b9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15309-2.C
@@ -0,0 +1,10 @@
+// 981203 bkoz
+// g++/15309
+// Build don't link: 
+// Special g++ Options: -Wnon-virtual-dtor -Weffc++
+
+class bermuda {
+public:
+  virtual int func1(int); 
+  ~bermuda();
+};  // WARNING - // WARNING -
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15351-1.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15351-1.C
new file mode 100644
index 00000000000..755c3608fcb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15351-1.C
@@ -0,0 +1,27 @@
+// 981203 bkoz
+// g++/15351 - test
+// Special g++ Options: -fno-const-strings
+
+#include <assert.h>
+
+bool gtest;
+
+struct acapulco {
+  acapulco(const char *) { gtest = false; }
+  acapulco(char *) { gtest = true; }
+};
+
+void foo(void)
+{
+  acapulco("some such string\n");
+}
+
+int main() 
+{
+  foo();
+  if (!gtest)
+    assert (0);
+
+  return !gtest;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15351-2.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15351-2.C
new file mode 100644
index 00000000000..98ecaac29a1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15351-2.C
@@ -0,0 +1,27 @@
+// 981203 bkoz
+// g++/15351 + test
+// Special g++ Options: -fconst-strings
+
+#include <assert.h>
+
+bool gtest;
+
+struct acapulco {
+  acapulco(const char *) { gtest = true; }
+  acapulco(char *) { gtest = false; }
+};
+
+void foo(void)
+{
+  acapulco("some such string\n");
+}
+
+int main() 
+{
+  foo();
+  if (!gtest)
+    assert (0);
+
+  return !gtest;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15756-1.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15756-1.C
new file mode 100644
index 00000000000..cc44e6a74a0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15756-1.C
@@ -0,0 +1,36 @@
+// 981203 bkoz
+// g++/15756  test1
+// Build don't link: 
+// Special g++ Options: -Wsign-promo
+
+enum e_value { first = 0, next = 30 };
+
+struct sanjuan {
+  sanjuan(int value);
+  sanjuan(unsigned value);
+  friend sanjuan operator&(const sanjuan& x, const sanjuan& y);
+  friend int operator!=(const sanjuan& x, const sanjuan& y);
+};
+
+extern void mod_enum(e_value*);
+extern int a;
+
+void foo(void) {
+  e_value mod = first;
+  mod_enum(&mod);
+  if (mod != next)
+    ++a;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15756-2.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15756-2.C
new file mode 100644
index 00000000000..33c4b23963e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15756-2.C
@@ -0,0 +1,44 @@
+// 981203 bkoz
+// g++/15756  test2
+// Build don't link: 
+// Special g++ Options: -Wsign-promo
+// this test may only be valid for 32bit targets at present
+
+enum e_i {
+  vali
+}
+enum_int;
+
+enum e_ui {
+  valui = 0xF2345678
+}
+enum_uint;
+ 
+int i;
+unsigned int ui;
+
+struct caracas {
+  caracas(int);
+  caracas(unsigned int);
+  void foo();
+};
+ 
+int main ()
+{
+  caracas obj_ei  ( enum_int  ); // WARNING - // WARNING -
+  caracas obj_eui ( enum_uint ); // WARNING - // WARNING -
+  caracas obj_i  ( i  );
+  caracas obj_ui ( ui );
+  
+  obj_ei.foo();
+  obj_eui.foo();
+  obj_i.foo();
+  obj_ui.foo();
+}
+ 
+
+
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15799.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15799.C
new file mode 100644
index 00000000000..5309daf8c63
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15799.C
@@ -0,0 +1,29 @@
+// 981203 bkoz
+// g++/15799  test1
+// Build don't link:
+
+/* 
+15799.cpp: In function `void foo()':
+15799.cpp:21: call of overloaded `sanjose({anonymous enum})' is ambiguous
+15799.cpp:13: candidates are: sanjose::sanjose(const sanjose &) <near match>
+15799.cpp:14:                 sanjose::sanjose(unsigned int)
+*/
+
+typedef char int_8;
+typedef unsigned long uint_32;
+
+class sanjose {
+public:
+   sanjose();
+   sanjose(const sanjose&);  
+   sanjose(int_8 value);  // ERROR -  // ERROR -
+   sanjose(uint_32 value);  // ERROR -  // ERROR -
+};
+
+enum { first, last};
+
+void foo(void) {
+  sanjose obj(first); // ERROR -  // ERROR -
+};
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15800-1.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15800-1.C
new file mode 100644
index 00000000000..49aabc9655c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15800-1.C
@@ -0,0 +1,17 @@
+// 981203 bkoz
+// g++/15800  - test
+// Build don't link:
+
+struct panama {
+  panama();
+  panama(panama &);
+  panama& operator=(panama&); // ERROR - // ERROR -
+};
+
+extern panama dig();
+
+void foo() {
+   panama obj;
+   obj = dig(); // ERROR -  // ERROR -
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15800-2.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15800-2.C
new file mode 100644
index 00000000000..18e299aa44c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15800-2.C
@@ -0,0 +1,18 @@
+// 981203 bkoz
+// g++/15800 + test
+// Build don't link:
+
+struct panama {
+  panama();
+  panama(panama &);
+  panama& operator=(panama&); 
+  panama& getref() { return *this; }
+};
+
+extern panama dig();
+
+void foo() {
+   panama obj;
+   obj = dig().getref();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/15822.C b/gcc/testsuite/g++.old-deja/g++.benjamin/15822.C
new file mode 100644
index 00000000000..ecd93afd869
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/15822.C
@@ -0,0 +1,27 @@
+// 981203 bkoz
+// g++/15822
+
+#include <assert.h>
+
+static unsigned int gcount;
+
+struct playahermosa {
+  playahermosa() { ++gcount; }
+  playahermosa(const playahermosa &) { ++gcount; }
+  ~playahermosa() { --gcount; }
+};
+
+struct playacoco {
+  playacoco(const playahermosa& = playahermosa()) {  } //create a temporary
+};
+
+void foo(playacoco *) { }
+
+int main() 
+{
+   playacoco bar[2];
+   foo(bar);
+   assert (gcount == 0);
+
+   return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/16077.C b/gcc/testsuite/g++.old-deja/g++.benjamin/16077.C
new file mode 100644
index 00000000000..f38154ec507
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/16077.C
@@ -0,0 +1,28 @@
+// 981203 bkoz
+// g++/16077
+// Build don't link: 
+
+class nicaragua;
+struct colombia {
+   colombia();
+   colombia(const colombia &);
+   colombia(const nicaragua &);
+   colombia &operator= (const colombia&);
+};
+
+struct nicaragua {
+public:
+   nicaragua();
+   nicaragua(const nicaragua&);
+   operator colombia();
+};
+
+void peace(const colombia&); // WARNING - // WARNING -
+
+void foo(nicaragua& b) {
+  peace(b); // WARNING - // WARNING -
+}
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/16567.C b/gcc/testsuite/g++.old-deja/g++.benjamin/16567.C
new file mode 100644
index 00000000000..8039f5babe6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/16567.C
@@ -0,0 +1,44 @@
+// 981203 bkoz
+// g++/16567
+// Build don't link:
+
+typedef bool Bool;
+typedef unsigned char		Uint8;
+typedef unsigned short		Uint16;
+typedef unsigned int		Uint32;
+
+enum e_ms  { third = 3, fourth = 4 };
+ 
+struct bitmask {
+  Uint8* anon1;		 
+  Uint32 anon2;
+  Uint8 anon3;
+  Uint8 here: 2;
+  Uint8 anon4: 2;
+  Uint8 anon5: 4;
+};
+
+struct control {
+  Uint8 foo_1();
+};
+
+inline Uint8 foo_2(bitmask* p) {
+   return p->here;
+}
+
+inline Uint8 control::foo_1() {
+   return foo_2((bitmask*) this);
+}
+
+void foo(void) {
+  control obj;
+  control *fp = &obj;
+  e_ms result;
+  
+  result = (e_ms) fp->foo_1; // ERROR - // ERROR -
+}
+  
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/17922.C b/gcc/testsuite/g++.old-deja/g++.benjamin/17922.C
new file mode 100644
index 00000000000..471709287ef
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/17922.C
@@ -0,0 +1,19 @@
+// 981204 bkoz
+// g++/17922
+// Build don't link:
+
+class base { };
+
+struct derived : public base   {
+   derived (const derived&);
+   derived (const base&);
+};
+
+class tahiti {
+public: 
+   static void mf (derived);
+};
+
+void foo (const derived aaa) {
+   tahiti::mf(aaa);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/17930.C b/gcc/testsuite/g++.old-deja/g++.benjamin/17930.C
new file mode 100644
index 00000000000..3d7fc65a326
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/17930.C
@@ -0,0 +1,6 @@
+// 981204 bkoz
+// g++/17930
+// Build don't link:
+
+char const one[] = "test";
+char const two[] = one; // ERROR - // ERROR -
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/18208.C b/gcc/testsuite/g++.old-deja/g++.benjamin/18208.C
new file mode 100644
index 00000000000..7ec1dc09098
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/18208.C
@@ -0,0 +1,25 @@
+// 981204 bkoz
+// g++/18208
+// Build don't link:
+
+typedef unsigned int uint_32;
+
+class puertorico {
+public:
+  void *f ();
+private:
+  uint_32 member;
+};
+
+void foo( )
+{
+  uint_32 ui;
+  puertorico obj;
+
+  // Bug using static_cast<>
+  ui = static_cast<uint_32>(obj); // ERROR - // ERROR -
+  
+  // Bug when missing the pair of braces
+  ui = (uint_32) obj.f; // ERROR - // ERROR -
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/bool01.C b/gcc/testsuite/g++.old-deja/g++.benjamin/bool01.C
new file mode 100644
index 00000000000..c73557ae657
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/bool01.C
@@ -0,0 +1,74 @@
+//980323 bkoz
+//test for bools with inclusive ors
+
+#include <assert.h>
+void bar ( bool  x ) {};
+void bars ( short  x ) {};
+
+/* 980326 bkoz this is not initialized and so can have indeterminate value. */
+#if 0
+int orb(){
+  bool y;
+  bar ( y );
+  int blob = ( 27 | int (y) );
+  return blob; //expect 27 or 0
+}
+#endif
+
+int orbtrue(){
+  bool y = true;
+  bar ( y );
+  int blob = ( 27 | int (y) );
+  return blob; //expect 27
+}
+
+int orbfalse(){
+  bool y = false;
+  bar ( y );
+  int blob = ( 27 | int (y) );
+  return blob; //expect 27
+}
+
+int orbfalse2(){
+  bool y = 0;
+  bar ( y );
+  int blob = ( 27 | int (y) );
+  return blob;  //expect 27
+}
+
+int ors(){
+  short y = 1;
+  bars ( y );
+  int blob = ( 27 | int (y) );
+  return blob;  //expect 27
+}
+
+
+int orus(){
+  unsigned short y = 1;
+  bars ( y );
+  int blob = ( 65539 | int (y) );
+  return blob;  //expect 65539, will be 3 if done in us type
+}
+
+
+int main() {
+  int tmp;
+#if 0
+  tmp = orb();
+  assert (tmp == 27 || tmp == 0);
+#endif
+  tmp = orbtrue();
+  assert (tmp ==27);
+  tmp = orbfalse();
+  assert (tmp ==27);
+  tmp = orbfalse2();
+  assert (tmp ==27);
+  tmp = ors();
+  assert (tmp ==27);
+  tmp = orus();
+  assert (tmp == 65539);
+
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/bool02.C b/gcc/testsuite/g++.old-deja/g++.benjamin/bool02.C
new file mode 100644
index 00000000000..c17c935287b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/bool02.C
@@ -0,0 +1,63 @@
+//980324 bkoz
+//test for bool and bitwise ands
+
+#include <assert.h>
+
+
+void bar ( bool  x ) {};
+void bars ( short  x ) {};
+
+#if 0
+int andb(){
+  bool y;
+  bar ( y );
+  int blob = ( 27 & int (y) );
+  return blob; //expect 1 or 0
+}
+#endif
+
+int andbtrue(){
+  bool y = true;
+  bar ( y );
+  int blob = ( 27 & int (y) );
+  return blob; //expect 1
+}
+
+int andbfalse(){
+  bool y = false;
+  bar ( y );
+  int blob = ( 27 & int (y) );
+  return blob; //expect 0
+}
+
+int andbfalse2(){
+  bool y = 0;
+  bar ( y );
+  int blob = ( 27 & int (y) );
+  return blob;  //expect 0
+}
+
+int ands(){
+  short y = 1;
+  bars ( y );
+  int blob = ( 27 & int (y) );
+  return blob;  //expect 1
+}
+
+
+int main() {
+  int tmp;
+#if 0
+  tmp = andb();
+  assert (tmp == 1 || tmp == 0);
+#endif
+  tmp = andbtrue();
+  assert (tmp == 1);
+  tmp = andbfalse();
+  assert (tmp == 0);
+  tmp = andbfalse2();
+  assert (tmp == 0);
+  tmp = ands();
+  assert (tmp == 1);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/friend01.C b/gcc/testsuite/g++.old-deja/g++.benjamin/friend01.C
new file mode 100644
index 00000000000..66d42c55490
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/friend01.C
@@ -0,0 +1,31 @@
+// Build don't link:
+//980610 bkoz
+// example 1: buggy
+
+class foo {
+public:
+    class bar;
+    int func(bar *);
+    class bar {
+        int st;
+    public:
+        bar(){st=12;}
+        ~bar(){}
+        friend int foo::func(bar *);
+    };
+    foo(){}
+    ~foo(){}
+};
+
+
+int foo::func(bar *obj) {
+  obj->st++;
+  return (obj->st);
+}
+
+void test02() {
+  foo obj_f;
+  foo::bar obj_b;
+  
+  obj_f.func( &obj_b);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/friend02.C b/gcc/testsuite/g++.old-deja/g++.benjamin/friend02.C
new file mode 100644
index 00000000000..e9520e3ff60
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/friend02.C
@@ -0,0 +1,31 @@
+// Build don't link:
+//980610 bkoz
+// example 2: ok
+
+class bar;
+class foo {
+public:
+    int func(bar *);
+    foo(){}
+    ~foo(){}
+};
+
+class bar {
+  int st;
+public:
+  bar(){st=12;}
+  ~bar(){}
+  friend int foo::func(bar *);
+};
+
+int foo::func(bar *obj) {
+  obj->st++;
+  return (obj->st);
+}
+
+void test02() {
+  foo obj_f;
+  bar obj_b;
+  
+  obj_f.func( &obj_b);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/p12475.C b/gcc/testsuite/g++.old-deja/g++.benjamin/p12475.C
new file mode 100644
index 00000000000..6b210f3bf3d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/p12475.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// prms-id: 12475
+
+#include <limits.h>
+
+#if LONG_MAX == 2147483647
+#define TEST 2147483648
+#elif LONG_MAX == 9223372036854775807
+#define TEST 9223372036854775808
+#else
+#error "Unsupported test -- add new constants."
+#endif
+
+enum huh { start =-TEST, next };	// WARNING - 
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/p13417.C b/gcc/testsuite/g++.old-deja/g++.benjamin/p13417.C
new file mode 100644
index 00000000000..18d62e80512
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/p13417.C
@@ -0,0 +1,11 @@
+// Build don't link:
+// Special g++ Options:  
+// prms-id: 13417
+
+class   Foo {
+public:
+  explicit Foo (int){}
+};
+Foo f(10);
+Foo blat() return f(4){}; //this should not give an error
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/p13721.C b/gcc/testsuite/g++.old-deja/g++.benjamin/p13721.C
new file mode 100644
index 00000000000..be1df799082
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/p13721.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// prms-id: 13721
+
+class A
+{
+  public :
+  int a;
+};
+class B : public A
+{
+  public :
+  void cmp(int a, int b) {}
+  B(int a = 0)
+    {
+      cmp(A::a, a); //should not give warning
+    }
+};
+int main(void)
+{
+  return(1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/scope01.C b/gcc/testsuite/g++.old-deja/g++.benjamin/scope01.C
new file mode 100644
index 00000000000..a834f4f4956
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/scope01.C
@@ -0,0 +1,71 @@
+// Build don't link:
+// 980604 bkoz
+// 3.4.5 Class member access p 4
+// nested and non-nested calls, no dtors
+
+struct L { 
+  int ii; 
+  void foo(int a) {++a;}
+  struct Linner {
+    int ii_inner; 
+    void foo_inner(int b) {++b;}
+  };
+};
+class A : public L {};
+class B : public L {};
+class C : public A, public B {};
+
+
+void foo() {
+  // straight call
+  C x;
+  x.A::ii = 5;
+  x.A::foo(x.A::ii);
+  
+  // 5.1 Primary expressions
+  // p 8 
+  // a nested name specifier that names a class,
+  // optionally followed by the keyword template and then followd by
+  // the name of a member of either that class or one of its base
+  // classes is a qualified-id.  (3.4.3.1 describes their lookup.) 
+
+  // 5.2.5 Class memember access 
+
+  // p 3 if E1 has the type 'pointer to class X' then 
+  // E1->E2 == (*(E1)).E32
+  // E1 == object-expression
+  // E2 == id-expression
+  // thus everything gets converted to the "." notation
+
+  // p 2
+  // the id-expression shall name a member of the class
+  // (object-expression) or of one of its base classes.
+
+  // p4 if E2 is a nested type (of the object-expression), tye
+  // expression E1.E2 is ill formed.
+
+  // try 1 nested call - ERROR
+#if 0
+  C x2;
+  x2.A::L::Linner::ii_inner = 6; //ERROR violates p2, does not name member of C
+  x2.A::L::Linner::foo_inner(x2.A::L::Linner::ii_inner);
+#endif
+
+  //try2: scoped method call  -edg +acc +g++
+#if 1
+  C::A::Linner x2;
+  x2.A::Linner::ii_inner = 6;
+  x2.A::Linner::foo_inner(x2.A::Linner::ii_inner);
+#endif
+
+  //try 3: non-scoped method call  -edg +acc +g++
+#if 0
+  C::A::L::Linner x3;
+  x3.ii_inner = 6;
+  x3.foo_inner(x3.ii_inner);
+#endif
+}
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/scope02.C b/gcc/testsuite/g++.old-deja/g++.benjamin/scope02.C
new file mode 100644
index 00000000000..a2c9c04279f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/scope02.C
@@ -0,0 +1,208 @@
+// Build don't link:
+//980529 bkoz
+//3.4.5 Class member access via pointer and non-pointer
+// non-nested dtor calls
+
+int counter = 0;
+
+struct X {
+  int rank;
+  X(int init = 64) : rank(init) { }
+  ~X() { ++counter; }
+  typedef X classtype;
+};
+typedef X globaltype;
+
+#if 0
+template <typename T>
+struct X_tem {
+  T rank;
+  X_tem(T init = T(64) ) : rank(init) { }
+  ~X_tem() { ++counter; }
+  typedef X_tem classtype_tem;
+};
+typedef X_tem<int> globaltype_tem;
+#endif
+
+
+
+
+int main(void)
+{
+  // 3.4.5 Class member access
+  // p 2
+  // if the id-expression in a class member access is an
+  // unqualified-id, and the type of the object expression is of class
+  // type C (or pointer to class type C), the unqualified-id is looked
+  // up in the scope of class C. If the type of the object-expression
+  // is of pointer to scalar type, the unqualified-id is looked up in
+  // the context of the complete postfix-expression.
+
+  // p 3
+  // if the unqualitified id is ~type-name, and the type of the object
+  // expression is of a class type C (or pointer to class type C), the
+  // type-name is looked up in the context of the entire
+  // postfix-expression and in the scope of class C. The type-name
+  // shall refer to a class-name. If type-name is found in both
+  // contexts, the name shall refer to the same class type. If the
+  // type of the object expression is of scalar type, the type-name is
+  // looked up in the complete postfix-expression.
+  
+  typedef X localtype;
+
+  //
+  // 1 non-templatized, pointer, unqualified
+  //
+  X x01 ;
+  X *px = &x01;
+  px->~X(); 
+
+  X x02 (66);
+  px = &x02;
+  px->~localtype();
+
+  X x03 (68);
+  px = &x03;
+  px->~classtype(); //-g++  //p3: unqual-id lookup in object and postfix-expr
+
+  X x04 (70);
+  px = &x04;
+  px->~globaltype();
+
+
+  // p 1
+  // . . . the id-expression is first looked up in the class of the
+  // object-expression. If the identifier is not found, itis then
+  // looked up in the context of the entier postfix-expression and
+  // shall name a class or function template. If the lookup in the
+  // class of the object-expression finds a template, the name is also
+  // looked up in teh context of the entier postfix-expression and
+  // 1 if the name is not found, use the name from the object-expr
+  // 2 if the name found in postfix-expr != class template, use object-expr
+  // 3 if name found is class template, name must match object-expr or error
+
+  // p 4 
+
+  // if the id-expr in a class member acess is a qualified-id, the
+  // id-expression is looked up in both the context of the entire
+  // postfix-expr and in the scope of the class of the object-expr. If
+  // the name is found in both contexts, the id-expr shall refer to
+  // the same entity.
+
+
+  //
+  // 2 non-templatized, pointer, qualified
+  //
+  X x05 ;
+  px = &x05;
+  px->X::~X(); 
+
+  X x06 (66);
+  px = &x06;
+  px->X::~localtype();
+
+  X x07 (68);
+  px = &x07;
+  px->X::~classtype(); // -edg
+
+  X x08 (70);
+  px = &x08;
+  px->X::~globaltype();
+
+  X x09 (66);
+  px = &x09;
+  px->localtype::~localtype();
+
+  X x10 (68);
+  px = &x10;
+  px->classtype::~classtype();
+
+  X x11 (70);
+  px = &x11;
+  px->globaltype::~globaltype();
+
+  X x12 (66);
+  px = &x12;
+  px->classtype::~localtype();
+
+  X x13 (68);
+  px = &x13;
+  px->globaltype::~localtype();
+
+  X x14 (70);
+  px = &x14;
+  px->localtype::~globaltype();
+
+  X x15 (70);
+  px = &x15;
+  px->classtype::~globaltype();
+
+  X x16 (70);
+  px = &x16;
+  px->localtype::~classtype(); //-edg
+
+  X x17 (70);
+  px = &x17;
+  px->globaltype::~classtype(); //-edg
+
+#if 0
+  //
+  // non-templatized, non-pointer
+  //
+  X xo5 ;
+  xo5.~X(); //unqualified
+
+  localtype xo6 (66);
+  xo6.~localtype();
+
+  X xo7 (68);
+  xo7.~classtype();
+
+  X xo8 (70);
+  xo8.~globaltype();
+
+
+  //
+  // templatized, pointer
+  //
+  X_tem<int> xto1 ;
+  X_tem<int> *pxt = &xto1;
+  pxt->~X_tem(); //unqualified
+
+  typedef X_tem<int> localtype_tem;
+  localtype_tem xto2 (66);
+  pxt = &xto2;
+  pxt->~localtype_tem();
+
+  //paragraph 2:  unqualitifed id looked up in scope of post-fix expr if object
+  X_tem<int> xto3 (68);
+  pxt = &xto3;
+  pxt->~classtype_tem();
+
+  X_tem<int> xto4 (70);
+  pxt = &xto4;
+  pxt->~globaltype_tem();
+
+  //
+  // templatized, non-pointer
+  //
+  X_tem<int> xto5 ;
+  xto5.~X_tem(); //unqualified
+
+  localtype_tem xto6 (66);
+  xto6.~localtype_tem();
+
+  X_tem<int> xto7 (68);
+  xto7.~classtype_tem();
+
+  X_tem<int> xto8 (70);
+  xto8.~globaltype_tem();
+#endif
+  return 0;
+}
+
+
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/tem01.C b/gcc/testsuite/g++.old-deja/g++.benjamin/tem01.C
new file mode 100644
index 00000000000..e464c0e2e4b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/tem01.C
@@ -0,0 +1,136 @@
+// Build don't link: 
+// prms-id: 13911
+
+template<unsigned int N>
+class ref_counter {
+public:
+  ref_counter() : p_refcnt(new unsigned int(N)) {}
+  ref_counter(const ref_counter<N>& x) : p_refcnt(x.p_refcnt) { 
+    ++*p_refcnt; 
+  }
+  ref_counter& operator=(const ref_counter<N>& rhs) {
+    ++*rhs.p_refcnt;
+    decrement();
+    p_refcnt = rhs.p_refcnt;
+    return *this;
+  }
+  ~ref_counter() {decrement();}
+  
+  bool unique() const {return *p_refcnt == N;}
+  
+private:
+  unsigned int* p_refcnt;
+  void decrement() {
+    if (unique()) delete p_refcnt;
+    else --*p_refcnt;
+  }
+};
+
+template<class T, unsigned int N>
+class ref_pointer {
+public:
+   
+  ref_pointer() : the_p(0) {}  
+  ref_pointer(T* just_newed) : the_p(just_newed) {}       
+  virtual ~ref_pointer() {if (unique()) delete the_p;}
+protected:
+  ref_pointer(T* the_p_arg, ref_counter<N>& ref_count_arg)
+    : the_p(the_p_arg), ref_count(ref_count_arg) {}               
+
+public:
+   
+  ref_pointer& operator=(const ref_pointer&); 
+  ref_pointer& operator=(T*);                         
+  operator const T*() const {return the_p;}
+  T* operator()() {return the_p;} 
+  T* operator()() const {return the_p;} 
+  T& operator*() const {return *the_p;}                       
+  friend bool operator==(const ref_pointer<T, N>& lhs, 
+			 const ref_pointer<T, N>& rhs) {
+    return lhs.the_p == rhs.the_p;
+  }
+  friend bool operator!=(const ref_pointer<T, N>& lhs, 
+			 const ref_pointer<T, N>& rhs) {
+    return lhs.the_p != rhs.the_p;
+  }
+  
+   
+  bool unique() const {return ref_count.unique();}
+  bool isNull() const {return the_p==0;}
+
+protected:
+  ref_counter<N>& refCount() {return ref_count;}
+
+private:
+   
+  ref_counter<N> ref_count;
+  T* the_p;
+};
+
+template<class T, unsigned int N>
+ref_pointer<T, N>& ref_pointer<T, N>::operator=(const ref_pointer<T, N>& rhs) {
+  if (the_p != rhs.the_p) {
+    if (unique()) delete the_p;
+    the_p = rhs.the_p;
+    ref_count = rhs.ref_count;
+  }
+  return *this;
+}
+
+
+template<class T, unsigned int N>
+ref_pointer<T, N>& ref_pointer<T, N>::operator=(T* just_newed) { 
+  if (unique()) delete the_p;
+  the_p = just_newed;
+  ref_count = ref_counter<N>();
+  return *this;
+}
+
+
+
+template<class T>
+class CountedObjPtr : public ref_pointer<T, 1> {
+public:
+  CountedObjPtr() {}
+  CountedObjPtr(T* just_newed) : ref_pointer<T, 1>(just_newed) {}
+  CountedObjPtr(T* the_p_arg, ref_counter<1>& ref_count_arg)
+    : ref_pointer<T, 1>(the_p_arg, ref_count_arg) {}
+  CountedObjPtr<T>& operator=(T* rhs) {
+    ref_pointer<T, 1>::operator=(rhs); 
+    return *this; 
+  }
+  CountedObjPtr<T>& operator=(const CountedObjPtr<T>& rhs) { 
+    ref_pointer<T, 1>::operator=(rhs); 
+    return *this; 
+  }
+  T* operator->() const {return (*this)();}
+
+};
+
+
+
+
+
+//instantiating type
+
+class TSObservable;
+
+class TSObserver {
+public:
+   
+  enum TSType { NormalTS, UpYldCrvTS, DownYldCrvTS, ZeroVolTS };
+   
+  virtual ~TSObserver() {}
+   
+  virtual void update(TSObservable* theChangedObservable) = 0;
+  virtual TSType key() const { return myKey; }
+  virtual TSType& key() { return myKey; }
+protected:
+  TSObserver(TSType myKeyArg) : myKey(myKeyArg) {}
+  TSType myKey;
+};
+
+
+
+//now try to instantiate
+template class CountedObjPtr<TSObserver>;
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/tem02.C b/gcc/testsuite/g++.old-deja/g++.benjamin/tem02.C
new file mode 100644
index 00000000000..38a8f1d5e2b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/tem02.C
@@ -0,0 +1,54 @@
+// Build don't link: 
+//980519 bad error from nathan
+//$ egcs -fhonor-std -nostdinc -c redef.C
+//redef.C:56: redefinition of default argument for `class _Traits'
+
+template<class _CharT> struct char_traits;
+template<class _CharT> struct char_traits { };
+template<> struct char_traits<char>;
+template<> struct char_traits<char> { };
+
+template<class _CharT, class _Traits = char_traits<_CharT> > class istreambuf_iterator;
+
+
+template<class _CharT, class _Traits>
+  class istreambuf_iterator
+{
+ public:
+  typedef _Traits traits_type;
+  class _Proxy;
+ public:
+  inline istreambuf_iterator() throw();
+  inline istreambuf_iterator(const _Proxy& __p) throw();
+};
+
+
+template <class _CharT, class _Traits>
+  class istreambuf_iterator<_CharT,_Traits>::_Proxy 
+{
+ public:
+  _CharT operator*();
+
+  //bug -g++  w/ decl "redef", no decl no prob.
+  //ok -edg: no warnings
+  friend class istreambuf_iterator;  //  XXX  OK?
+
+  //bug -g++ w/ decl "redef", no decl no prob.
+  //ok -edg: no warnings
+  //friend class istreambuf_iterator<_CharT,_Traits>;
+
+  //bug -g++ w/ decl "redef", no decl no prob.
+  //ok -edg: declaration of "_CharT" and "_Traits" hides template parameter
+  //template <class _CharT, class _Traits> friend class istreambuf_iterator; 
+
+  //ok -g++
+  //ok -edg
+  //friend class istreambuf_iterator<_CharT>;
+
+};
+
+
+
+//explicit instantiation of a nested class
+template class istreambuf_iterator<char, char_traits<char> >::_Proxy;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C b/gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C
new file mode 100644
index 00000000000..0e4c389b506
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C
@@ -0,0 +1,209 @@
+// Build don't link:
+// 980808-980824 bkoz
+// template parameter redeclaration bugs
+
+// 14.1 Template parameters
+// p 13
+// The scope of a template-parameter extens from its point of
+// declartion until the end of its template. In particular, a
+// template-parameter can be used in the declaration of subsequent
+// template-parameters and their default arguments. 
+
+// 14.6.1 Locally declared names
+// p 4
+// A template-parameter shall not be redeclared within its scope
+// (including nested scopes). A template-parameter shall not have the
+// sname name as the template name.
+
+
+// 01 
+// declared friend template
+template <class T4>// ERROR - .*
+class Xone {
+protected:
+  T4* next;
+  T4* prev;
+  T4 value;
+public:
+  Xone(): next(0), prev(0), value(1999){}
+  Xone(T4 init): value(init) {}
+
+  // these are ok:
+  // can also do template-decl and then can ditch the foward-declaration
+  // template <class T5> friend bool isequal (Xone<T5>& lhs, Xone<T5>& rhs);
+  // this is not ok:
+  template <class T4> friend bool isequal (Xone<T4>& lhs, Xone<T4>& rhs);// ERROR - .*
+};
+
+
+// 02
+// nested template class
+template <class T6>// ERROR - .*
+class Xtwo {
+protected:
+  T6* next;
+  T6* prev;
+  T6 value;
+public:
+  Xtwo(): next(0), prev(0), value(1999){}
+  Xtwo(T6 init): value(init) {}
+
+  template <class T6> class nested {// ERROR - .*
+    T6 value;
+  public:
+    nested(): value( T6(0)) {}
+  };
+};
+
+
+// 03
+// member templates
+template <class T8>// ERROR - .*
+class Xthree {
+protected:
+  T8* next;
+  T8* prev;
+  T8 value;
+public:
+  Xthree(): next(0), prev(0), value(1999){}
+  Xthree(T8 init): value(init) {}
+
+  template <class T8> T8 comp_ge(T8 test) {// ERROR - .*
+    T8 local_value;
+    if (local_value > value) 
+      return local_value;
+    else
+      return value;
+  }
+};
+
+
+// 04
+// local names (14.6.1 p 4)
+template <class T10, int i> struct Xfour {// ERROR - .*
+  int T10; // ERROR - .*
+  void f(){
+    char T10;
+  }
+};
+
+
+// 05
+// using different tempate-parms for out-of-line defs
+template <class T12, int i> struct Xfive {
+  void f();
+};
+
+template <class T13, int i> void Xfive<T13,i>::f() {// ERROR - .*
+  int T13; // ERROR - .*
+  int T12; //should be ok
+}
+
+
+// 06
+// multiple names at the same level
+template <class T14, class T14> class Xsix { // ERROR - .*
+private:
+public:
+  void f();
+};
+
+
+// 07
+// multiple names, one in template parameter one in class-name
+template <class T12> class T12; // ERROR - .*
+
+
+// 08 
+// with multiple template params, and second (third) one is redeclared
+template <class T16, int i, class T161> class Xseven { // ERROR - .*
+private:
+  char T161; // ERROR - .*
+public:
+  template <class U>
+  friend bool fooy(U u);
+
+  template <class T161>
+  friend bool foo(T161 u)
+    {
+      Xseven<T161, 5, int> obj;
+      return (obj.inst == u.inst);
+    }
+
+};
+
+
+// 09 
+// check for correct scoping of member templates
+template <class T>
+struct S1
+{
+  template <class U>
+  void f(U u)
+    {
+      S1<U> s2u(u);
+      s2u.g();
+    }
+
+  template <class U> //ok
+  void f2(U u)
+    {
+      S1<U> s2u(u);
+      s2u.g();
+    }
+
+};
+
+
+// 10 
+// check for non-type parameters, should still be able to redeclare?
+// local names (14.6.1 p 4)
+template <class T18, int i> class Xten {// ERROR - .*
+  float i; // ERROR - .*
+};
+
+
+// 11 
+// declared friend template, non-type parameters
+template <long l>// ERROR - .*
+class Xeleven {
+public:
+  template <long l> friend bool isequal (Xeleven<5> lhs, Xeleven<5> rhs);  // ERROR - .*
+};
+
+
+
+// 12
+// nested template class, non-type parameters
+template <long l>// ERROR - .*
+class Xtwelve {
+public:
+  template <long l> class nested {// ERROR - .
+    long value;
+  public:
+    nested(): value(0) {}
+  };
+};
+
+
+// 13
+// member templates, non-type parameters
+template <long l>// ERROR - .*
+struct Xthirteen {
+  template <long l> long comp_ge(long test) {// ERROR - .
+    long local_value;
+    if (local_value > value) 
+      return local_value;
+    else
+      return value;
+  }
+};
+
+
+
+
+
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/tem04.C b/gcc/testsuite/g++.old-deja/g++.benjamin/tem04.C
new file mode 100644
index 00000000000..0330d0bbd0a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/tem04.C
@@ -0,0 +1,182 @@
+// Build don't link:
+// 980827 bkoz
+// template parameter redeclaration bugs, part two:
+// template template params and expanded template non-type parms
+
+// 14.1 Template parameters
+// p 13
+// The scope of a template-parameter extens from its point of
+// declartion until the end of its template. In particular, a
+// template-parameter can be used in the declaration of subsequent
+// template-parameters and their default arguments. 
+
+// 14.6.1 Locally declared names
+// p 4
+// A template-parameter shall not be redeclared within its scope
+// (including nested scopes). A template-parameter shall not have the
+// same name as the template name.
+
+// 14 
+// declared friend template (v3, template type parameters)
+template <class T4>// ERROR - .*
+class Xfourteen {
+protected:
+  T4 value;
+public:
+  Xfourteen(T4 init): value(init) {}
+  template <template <typename T4> class T5> // ERROR - .*
+  friend bool isequal (Xfourteen<int>& lhs, Xfourteen<int>& rhs);
+};
+
+
+// 15
+// nested template class (v3, template type parameters)
+template <class T6>// ERROR - .*
+class Xfifteen {
+protected:
+  T6 value;
+public:
+  Xfifteen(T6 init): value(init) {}
+
+  template <template <typename T6> class T7> class nested {// ERROR - .*
+    int value;
+  public:
+    nested(): value( int(0)) {}
+  };
+};
+
+
+// 16
+// member templates (v3, template type parameters)
+template <class T8>// ERROR - .*
+class Xsixteen {
+protected:
+  T8 value;
+public:
+  Xsixteen(T8 init): value(init) {}
+
+  template <template <typename T8> class T9> int comp_ge(int test) {// ERROR - .*
+    int local_value;
+    if (local_value > value) 
+      return local_value;
+    else
+      return value;
+  }
+};
+
+
+// 17
+// declared friend template (v4, template type parameters on the class)
+template <typename T9> class tem_base {
+public:
+  T9 value;
+};
+
+template <typename T10, template <typename T12> class C10>
+class Xseventeen {
+protected:
+  C10<T10> value;
+public:
+  Xseventeen(){}
+  template <typename T12> // ok??
+  friend bool isequal (Xseventeen<T10, tem_base>& lhs, 
+		       Xseventeen<T10, tem_base>& rhs);
+};
+
+//template class Xseventeen<int, tem_base>;
+
+
+// 18
+// more template template redecl tests
+template <typename T14, template <typename T15> class C12>// ERROR - .*
+class Xeighteen {
+protected:
+  C12<T14> value;
+  int C12; // ERROR - .*
+};
+
+
+// 19
+// more template template redecl tests
+template <typename T16, template <typename T17> class C14>// ERROR - .*
+class Xnineteen{
+protected:
+  C14<T16> value;
+  template <class C14> class nested {// ERROR - .*
+    T16 value;
+  public:
+    nested(): value( T16(0)) {}
+  };
+};
+
+
+// 20
+// local names (14.6.1 p 4) part two, variable names as template param
+template <class T17, int i> struct Xtwenty {
+  void f(){
+    T17 my_type; //ok
+    for (int j = 0; j < 5; ++l)
+      {
+	T17 my_type; //ok
+	++my_type;
+      }
+  }
+};
+
+
+// 14.1 Template parameters
+// p 4
+// A non-type templat- parameter shall have one of the following
+// (optionally cv-qualified) types:
+//   integral or enumeration type
+//   pointer to object or pointer to function
+//   referenct to object or referece to function
+//   pointer to member
+
+// 21 
+// non-type template parameters v1: enum
+enum my_enum {my_A = 45, my_B, my_C};
+
+template <my_enum T18> class Xtwentyone {// ERROR - .*
+  float T18; // ERROR - .*
+};
+
+
+// 22
+// non-type template parameters v1: pointer to object
+struct base {
+  int	gcount;
+  int ret_gcount() {return gcount;}
+};
+
+template <class T20, base* b> class Xtwentytwo {// ERROR - .*
+  float b; // ERROR - .*
+};
+
+
+// 23
+// non-type template parameters v2: reference to object
+template <class T20, base& b2> class Xtwentythree {// ERROR - .*
+  float b2; // ERROR - .*
+};
+
+
+// 24
+// non-type template parameters v3: pointer to member
+template <class T20, int base::* b3> class Xtwentyfour {// ERROR - .*
+  float b3; // ERROR - .*
+};
+
+
+// 25
+// non-type template parms that use push_class_level
+template <class T22> void f1() {// ERROR - .*
+  struct foo { 
+    enum T22 { un, du, toi }; // ERROR - .*
+  };
+}
+
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/tem05.C b/gcc/testsuite/g++.old-deja/g++.benjamin/tem05.C
new file mode 100644
index 00000000000..92ad7390731
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/tem05.C
@@ -0,0 +1,58 @@
+// 980924 bkoz
+// just a quick test for export, to make sure we are warning for it.
+// CHANGE ME when it's supported
+// Build don't link: 
+
+
+// 14 Templates
+//p 6
+// A namespace-scope declaration or definintion of a non-line function
+// template, a non-inline member function template, a non-inline
+// member function of a class template or a static data member of a
+// class template may be preceeded by the export keyword. If such a
+// template is defined in the same translation unit in which it is
+// declared as exported, the definition is considered to be
+// exported. The first declaration of the template containing the
+// export keyword must not follow the definition. (meaning that export
+// can't beredeclared as non-export??)
+
+// 1
+// template definition
+export template <class T>  // WARNING - 
+bool templ_one(T a) {
+   if (a > 0)
+     return true;
+   else
+     return false;
+}
+
+
+// 2
+// static data, mf, mf template
+template <class T>
+class X_one {
+  unsigned short	id;
+  T	type;
+public:
+  static const bool 	is_specialized ;
+
+  X_one(const unsigned short& us = 5): id(us), type(T(0)) {}
+  unsigned short ret_id ();
+  template <class T2> bool compare_ge(T2 test);
+};
+
+export template <class T> // WARNING - 
+const bool X_one<T>::is_specialized = false;
+
+export template <class T> // WARNING - 
+unsigned short X_one<T>::ret_id() {
+  return id;
+}
+
+export template <class T> template <class T2> // WARNING - 
+bool compare_ge(T2 test) {
+  if (test > type)
+    return true;
+  return false;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/tem06.C b/gcc/testsuite/g++.old-deja/g++.benjamin/tem06.C
new file mode 100644
index 00000000000..e55ee6aafb4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/tem06.C
@@ -0,0 +1,49 @@
+// 980945 bkoz
+// test for correct operators at link time
+
+/*
+/tmp/cca211431.o: In function `void blah<foo<int> >(foo<int> const &)':
+/tmp/cca211431.o(.void gnu.linkonce.t.blah<foo<int> >(foo<int> const &)+0x1e): undefined reference to `void x<int>(int const &)'
+*/
+
+template<class T>
+class foo {
+public:
+  foo () {}
+  friend void x (const T &) { }
+};
+
+template<class T>
+void blah (const T &) {
+  T y;
+  x (4);
+};
+
+int main () {
+  const foo<int> v;
+  blah (v);
+}
+
+/*
+fno-exceptions -fno-rtti
+
+1.98r1.o:
+00000000 W __t3foo1Zi
+00000000 W blah__H1Zt3foo1Zi_RCX01_v
+00000000 t gcc2_compiled.
+00000000 T main
+         U x__H1Zi_RCX01_v
+
+1.egcs.o:
+00000000 W __t3foo1Zi
+00000000 W blah__H1Zt3foo1Zi_RCX01_v
+00000000 t gcc2_compiled.
+00000000 T main
+00000000 W x__FRCi
+
+
+the reason this goes away at -O is because the U or W function is
+elided completely.  
+
+*/
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/tem07.C b/gcc/testsuite/g++.old-deja/g++.benjamin/tem07.C
new file mode 100644
index 00000000000..953ed90d95c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/tem07.C
@@ -0,0 +1,37 @@
+
+template <class T>
+class Foo
+{
+public:
+    Foo(const T&);
+    Foo(const T&, const T&);
+};
+
+template <class T>
+Foo<T>::Foo(const T& t0)
+{
+}
+
+template <class T>
+Foo<T>::Foo(const T& t0, const T& t1)
+{
+}
+
+template Foo<int>::Foo(const int& t0);
+
+
+int main (void) {
+  return 0;
+}
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/typedef01.C b/gcc/testsuite/g++.old-deja/g++.benjamin/typedef01.C
new file mode 100644
index 00000000000..ba6af18b632
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/typedef01.C
@@ -0,0 +1,46 @@
+// Build don't link:
+//980205 bkoz
+
+//7.1.3 the typedef specifier
+
+
+//p1
+typedef int MILES, *KLICKSP;
+MILES distance;
+extern KLICKSP metricp;
+
+//p2--can redefine to same type
+typedef struct s { /* ... */ } s;
+typedef int I;
+typedef int I;
+typedef I I;
+
+//p3--cannot redefine to a different type in a given scope
+class complex2 { /* ... */ };// ERROR - .*
+typedef int complex2;// ERROR - .*
+typedef int complex3;// ERROR - .*
+class complex3 { /* ... */ };// ERROR - .*
+
+
+//p4
+/*
+4 A typedef-name that names a class is a class-name (_class.name_).   If
+  a  typedef-name is used 
+  1) following the class-key in an elaborated-type-specifier 
+  2) or in the class-head of a class declaration 
+  3) or is used as the identifier in the declarator for a
+  constructor or destructor  declaration 
+  the program is ill-formed.  [Example:
+*/
+struct S {
+  S();
+  ~S();
+};
+
+typedef struct S T;
+
+S a = T();                      // OK 
+struct T * p;                   // ERROR - using typedef after struct
+
+//case01
+typedef bool short;// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/typedef03.C b/gcc/testsuite/g++.old-deja/g++.benjamin/typedef03.C
new file mode 100644
index 00000000000..cf09ccbc008
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/typedef03.C
@@ -0,0 +1,44 @@
+// Build don't link:
+//980526 bkoz
+// reduced testcase for 980511 brendan qt bug
+
+
+class QTextStream				 
+{
+public:
+    QTextStream();
+    virtual ~QTextStream();
+
+    enum {
+	skipws	  = 0x0001,			 
+	left	  = 0x0002,			 
+	right	  = 0x0004,			 
+	internal  = 0x0008,			 
+	bin	  = 0x0010,			 
+	oct	  = 0x0020,			 
+	dec	  = 0x0040,			 
+	hex	  = 0x0080,			 
+	showbase  = 0x0100,			 
+	showpoint = 0x0200,			 
+	uppercase = 0x0400,			 
+	showpos	  = 0x0800,			 
+	scientific= 0x1000,			 
+	fixed	  = 0x2000			 
+    };
+
+    static const int basefield;			 
+    static const int adjustfield;	
+};
+
+typedef QTextStream QTS;
+const int QTS::basefield   = (QTS::bin | QTS::dec | QTS::hex) ;
+const int QTS::adjustfield = QTS::left | QTS::right | QTS::internal;
+#if 0
+#define QTS QTextStream
+const int QTS::basefield   = (QTS::bin | QTS::dec | QTS::hex) ;
+const int QTS::adjustfield = QTS::left | QTS::right | QTS::internal;
+#endif
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/typeid01.C b/gcc/testsuite/g++.old-deja/g++.benjamin/typeid01.C
new file mode 100644
index 00000000000..c75c65b08d9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/typeid01.C
@@ -0,0 +1,71 @@
+// 980617 bkoz
+// typeid for local types
+// typeid bool vs int and enum vs int
+
+#include <typeinfo>
+#ifdef DEBUG_ASSERT
+#include <assert.h>
+#endif
+
+// 4: local class in non-main function
+
+void test1 (void) {
+  bool class_p = false;
+  class X2 { 
+  private:
+    unsigned int counter;
+  public:
+    X2 (unsigned int i = 35): counter(i) {}
+    ~X2(){}
+    unsigned int ret_counter() {return counter;}
+  };
+  X2 obj_1;
+  class_p = typeid(X2) == typeid(obj_1);
+}  
+
+int main ()
+{
+  // 1: simple
+#if 1
+  bool enum_p = false;
+  enum E { A, B, C };
+  enum_p = typeid(A) == typeid(E);
+#ifdef DEBUG_ASSERT
+  assert (enum_p);
+#endif
+#endif  
+
+  // 2: complex
+#if 0
+  bool enum2_p = false;
+  bool int_p = false;
+  bool bool_p = false;
+  enum E2 { A2, B2};
+  enum2_p = typeid(A2) == typeid(E2);
+  int_p =  typeid(int) == typeid(E2);
+  bool_p =  typeid(bool) == typeid(E2);
+#ifdef DEBUG_ASSERT
+  assert (enum2_p);
+  assert (!int_p);
+  assert (!bool_p);
+#endif
+#endif
+
+  // 3: local class
+  bool class_p = false;
+  class X { 
+  private:
+    unsigned int counter;
+  public:
+    X (unsigned int i = 35): counter(i) {}
+    ~X(){}
+    unsigned int ret_counter() {return counter;}
+  };
+  X obj_1;
+  class_p = typeid(X) == typeid(obj_1);
+
+  // 4: local class in function
+  test1();
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/warn01.C b/gcc/testsuite/g++.old-deja/g++.benjamin/warn01.C
new file mode 100644
index 00000000000..d0cf0d01785
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/warn01.C
@@ -0,0 +1,98 @@
+// Build don't link: 
+// Special g++ Options:  -Wall -Weffc++
+
+//1 g++/12952 un-named variables in a catch block
+//Wall or Wunused should not give warnings here
+template <class T>
+void f (void) { 
+   try
+    {
+    }
+ 
+   catch( int)
+    {    
+    }
+};
+
+//
+//2 g++/12923 __attribute__((__unused__)) not working for objects
+//Weffc++ or Wunused should not report the object as an error
+class C {
+  public:
+  C();
+};
+
+void f (void){
+  C x __attribute__ ((__unused__));
+  int y __attribute__ ((__unused__));
+}
+
+//
+//3 g++/12982 lock should not give error here, as above
+void setLock ();
+void clearLock ();
+
+template <class T>
+class test {
+public:
+   class lock
+   {
+   public:
+     lock () { setLock(); }
+     ~lock () { clearLock(); }
+   };
+
+  static void f (void)
+  {
+   lock local  __attribute__ ((__unused__));
+  } 
+
+};
+
+
+//
+//4 g++/12988 neither Mutex nor AutoMutex varibles should give warnings here
+//compile with -Weffc++ or -Wunused depending on post or pre 97r1
+class Mutex {
+private:
+  long counter;
+public:
+  virtual long retcntr() {return counter;};
+  Mutex(int i = 0): counter(i) {};
+  virtual ~Mutex() {};
+} __attribute__ ((__unused__));
+
+class AutoMutex: public Mutex{
+private:
+  long counter2;
+public:
+  long retcntr() {return counter2;};
+  AutoMutex(int i = 0): counter2(i) {};
+  virtual ~AutoMutex() {};
+} __attribute__ ((__unused__));
+
+
+template <class T>
+int foofunc(T x){
+  Mutex sm(2);
+  AutoMutex m(&sm);
+  return 0;
+};
+
+
+//5 sanity check to make sure other attributes cannot be used
+class Mutex2 {
+private:
+  long counter;
+public:
+  virtual long retcntr() {return counter;};
+  Mutex2(int i = 0): counter(i) {};
+  virtual ~Mutex2() {};
+} __attribute__ ((warn));  // WARNING - 
+
+
+
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/warn02.C b/gcc/testsuite/g++.old-deja/g++.benjamin/warn02.C
new file mode 100644
index 00000000000..e63d43cbec9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/warn02.C
@@ -0,0 +1,54 @@
+// 980413 bkoz 
+// from g++/15307, tests for -Wredundant-decls 
+// for friend functions and functions 
+// Build don't link: 
+//Special g++ Options: -Wredundant-decls
+
+
+extern int foo(const char *);
+
+class A
+{
+  friend int foo(const char *);
+  int a;
+};
+
+class B
+{
+  friend int foo(const char *);
+  int foo2() {return b;}
+  int b;
+};
+
+class C
+{
+  friend int foo(const char *);
+  friend int foo(const char *); // WARNING - 
+  int foo2() {return b;}
+  int b;
+};
+
+class D
+{
+public:
+  int foo2() {return b;}  
+  int foo2() {return b;}  // ERROR - 
+  int b;
+};
+
+class E
+{
+public:
+  int foo2(); 
+  int foo2(); // ERROR - 
+  int b;
+};
+
+extern int foo3(const char *);  // WARNING - 
+extern int foo3(const char *);  // WARNING - 
+
+
+
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/warn03.C b/gcc/testsuite/g++.old-deja/g++.benjamin/warn03.C
new file mode 100644
index 00000000000..b3bd3affc9d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/warn03.C
@@ -0,0 +1,10 @@
+// 980420 bkoz 
+// from g++/15307, tests for -Wredundant-decls for decls
+// Build don't link: 
+// Special g++ Options: -Wredundant-decls
+
+//shouldn't crash
+extern unsigned char *foo5[]; 
+extern unsigned char *foo5[]; 
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.benjamin/warn04.C b/gcc/testsuite/g++.old-deja/g++.benjamin/warn04.C
new file mode 100644
index 00000000000..cb96ac67b33
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.benjamin/warn04.C
@@ -0,0 +1,9 @@
+// 980903 bkoz
+// make sure this option works
+// Build don't link: 
+// Special g++ Options: -Wno-non-template-friend
+
+
+template<class T> class task {
+  friend void next_time(); //shouldn't give a warning
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/array1.C b/gcc/testsuite/g++.old-deja/g++.bob/array1.C
new file mode 100644
index 00000000000..2e86f6ff105
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/array1.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+char *stuff() {
+   char array[10]; // WARNING - 
+
+   return array;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/array2.C b/gcc/testsuite/g++.old-deja/g++.bob/array2.C
new file mode 100644
index 00000000000..8ddeba8c83d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/array2.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+extern const int a[];
+extern const int a[];
+extern const int a[];
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/case1.C b/gcc/testsuite/g++.old-deja/g++.bob/case1.C
new file mode 100644
index 00000000000..a8e5f7b7621
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/case1.C
@@ -0,0 +1,13 @@
+// prms-id: 9028
+class Foo;
+
+int main()
+{
+  int i=0;
+  switch (i) 
+    {
+    case ((Foo *)0): // ERROR - 
+    case ((Foo *)1): // ERROR - 
+      break;
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/cond1.C b/gcc/testsuite/g++.old-deja/g++.bob/cond1.C
new file mode 100644
index 00000000000..d6f1165061a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/cond1.C
@@ -0,0 +1,31 @@
+// Build don't link: 
+// prms-id: 9866
+class TChar 
+	{ 
+public: 
+	explicit inline TChar(unsigned int aChar); 
+	inline operator unsigned int() const; 
+private: 
+	unsigned int iChar; 
+   }; 
+inline TChar::TChar(unsigned int aChar) 
+	: iChar(aChar) 
+	{} 
+inline TChar::operator unsigned int() const 
+	{return(iChar);} 
+ 
+class TDes8 
+   { 
+public: 
+   inline const unsigned char &operator[](int anIndex) const; 
+	const unsigned char &AtC(int anIndex) const; 
+   }; 
+ 
+inline const unsigned char &TDes8::operator[](int anIndex) const 
+	{return(AtC(anIndex));} 
+ 
+ 
+void doExponent(TDes8 &aDigBuf) 
+            { 
+            2 ? TChar(aDigBuf[2]) : '0';
+            } 
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/delete1.C b/gcc/testsuite/g++.old-deja/g++.bob/delete1.C
new file mode 100644
index 00000000000..cf4c8df8949
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/delete1.C
@@ -0,0 +1,22 @@
+// prms-id: 7330
+#include <stddef.h>
+int size = 0; 
+
+struct X {
+    int x;
+    void *operator new[](size_t sz) throw()  {
+         size = sz;
+         return 0;  
+    }
+    void operator delete[] (void *vp) { ::operator delete(vp); }  
+};
+int main()
+{
+     X (*px) [10];
+
+     px = new X[5][10];
+
+     delete [] px;
+
+     return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/extern_C.C b/gcc/testsuite/g++.old-deja/g++.bob/extern_C.C
new file mode 100644
index 00000000000..6b91adc36e3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/extern_C.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+extern "C" {
+  class A {
+  public:
+    void a();
+  };
+};
+
+void A::a() {}
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/friend1.C b/gcc/testsuite/g++.old-deja/g++.bob/friend1.C
new file mode 100644
index 00000000000..1782f08913a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/friend1.C
@@ -0,0 +1,4 @@
+class C {
+public:
+  static friend int f(); // ERROR - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/incomplete-cast1.C b/gcc/testsuite/g++.old-deja/g++.bob/incomplete-cast1.C
new file mode 100644
index 00000000000..fb08c63e9c3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/incomplete-cast1.C
@@ -0,0 +1,16 @@
+// prms-id: 5274
+class VHDLIdentifier;
+
+class VHDLPackageProtoRep {
+public:
+    int thing();
+private:
+    virtual VHDLIdentifier &actual_name() ;
+};
+extern void form(const char *format, ... );
+int
+VHDLPackageProtoRep::thing()
+{
+    form("package `%s'", (char *)actual_name()); // ERROR - can't convert from incomplete type
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/inherit1.C b/gcc/testsuite/g++.old-deja/g++.bob/inherit1.C
new file mode 100644
index 00000000000..4d62e3896f5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/inherit1.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+class A {
+char str[10];
+public:
+    char* m1 () { return str;};
+};
+
+class C : public A {
+public:
+};
+
+class B : public A {
+public:
+    char* m1 () { C::m1(); return ""; } // ERROR - 
+};
+
+int main () {
+A a;
+B b;
+C c;
+
+a.m1();
+c.m1();
+b.m1();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/inherit2.C b/gcc/testsuite/g++.old-deja/g++.bob/inherit2.C
new file mode 100644
index 00000000000..52d35b0462c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/inherit2.C
@@ -0,0 +1,22 @@
+// Build don't link:
+class A {
+public:
+  void z();
+  A(void) {}
+private:
+  A(const A &) { abort(); } // ERROR - 
+  const A& operator =(const A &) { abort(); }
+};
+
+class B : public A {
+public:
+  B(void) {}
+};
+
+void f(B b) {
+};
+
+void g() {
+  B h;
+  f(h); // ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/nested1.C b/gcc/testsuite/g++.old-deja/g++.bob/nested1.C
new file mode 100644
index 00000000000..b5b7a762e0f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/nested1.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+  class A {
+    class B {
+      typedef long T;
+      int i;
+    };
+  };
+  class C {
+    class B {
+      typedef float T;
+      int i;
+    };
+  };
+
+C::B::T a;
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/packed1.C b/gcc/testsuite/g++.old-deja/g++.bob/packed1.C
new file mode 100644
index 00000000000..86a946fc363
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/packed1.C
@@ -0,0 +1,17 @@
+int
+main() {
+  struct s
+    {
+      int a;
+      short b;
+    } __attribute__((packed)) t;
+
+  if (sizeof (t) != (sizeof(int)+sizeof(short))) 
+    {
+      return 1;
+    }
+  else 
+    {
+      return 0;
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/protected1.C b/gcc/testsuite/g++.old-deja/g++.bob/protected1.C
new file mode 100644
index 00000000000..95a400eeaa1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/protected1.C
@@ -0,0 +1,42 @@
+// Build don't link: 
+class A {
+public:
+  int i;
+  A(int j) : i(j){}
+};
+
+class B : protected A {
+public:
+  B(int j) : A(j){}
+  void f(){
+    A k(*this);
+  }
+};
+
+class C : protected B {
+public:
+  C(int j) : B(j){}
+  void f();
+
+  void g(){
+    A k(i); 
+  }
+};
+
+
+class D : public C {
+public:
+   D(int w) : C(i) {}
+   void j() { A k(*this); }
+   void h() { i=3; }
+};
+
+void C::f() {
+   A k(*this);
+}
+
+B b(3);
+int
+main() {
+ A *z = &b; // ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/static1.C b/gcc/testsuite/g++.old-deja/g++.bob/static1.C
new file mode 100644
index 00000000000..a8e6b88bd93
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/static1.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+class A {
+  public:
+    static int a;
+};
+
+class B : public A {
+  public:
+    static int b;
+};
+
+int B::a; // ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/template1.C b/gcc/testsuite/g++.old-deja/g++.bob/template1.C
new file mode 100644
index 00000000000..4a22f086130
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/template1.C
@@ -0,0 +1,27 @@
+// Build don't link:
+// prms-id: 10038
+template < class Referencee >
+class Referencer
+{
+public:
+    Referencer (Referencee const * pReferencee);
+};
+
+template <class T>
+class Array
+{
+public:
+    int addElement (T const & e);
+    int addElement ();
+};
+
+class ScenarioGroup;
+
+class ScenarioSet : public Array< Referencer<ScenarioGroup> >
+{
+    typedef Array< Referencer<ScenarioGroup> > arrayBase;
+    void addElement(ScenarioGroup *group)
+	{
+	    arrayBase::addElement(group);
+	}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/template2.C b/gcc/testsuite/g++.old-deja/g++.bob/template2.C
new file mode 100644
index 00000000000..5663da84be2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/template2.C
@@ -0,0 +1,49 @@
+// Build don't link:
+// prms-id: 10046
+template <class T>
+class Array
+{
+public:
+    T const & operator[] (int i) const;
+};
+
+class Referenceable {};
+
+template < class Referencee >
+class Referencer
+{
+public:
+    operator Referencee *() const { return i_referencee; }
+
+protected:
+    Referencee* i_referencee;
+};
+
+class ScenarioGroup {};
+
+class ScenarioSpace;
+
+class ScenarioSet : public Referenceable,
+		    public Array< Referencer<ScenarioGroup> >
+{
+public:
+    ScenarioSet& operator=(ScenarioSet const & s);
+};
+
+class ScenarioSpace : public Referenceable,
+		      public Array< Referencer<ScenarioSet> >
+{
+};
+
+class ScenarioSetNameSelector
+{
+public:
+    bool operator () (ScenarioSpace &space)
+    {
+	int idx;
+	i_set = space[idx];
+	return false;
+    }
+private:
+    ScenarioSet *i_set;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/template3.C b/gcc/testsuite/g++.old-deja/g++.bob/template3.C
new file mode 100644
index 00000000000..7aca6eda3d6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/template3.C
@@ -0,0 +1,49 @@
+// Build don't link: 
+// prms-id: 9979
+
+template < class Referencee >
+class Referencer
+{
+public:
+    Referencer() {}
+};
+
+template <class T>
+class List
+{
+public:
+    List() {}
+};
+
+template<class T, class KEY>
+class Dictionary
+{
+public:
+    Dictionary() : i_buckets (new List<T>[1234]) {}
+    ~Dictionary() { delete [] i_buckets; }
+
+    List<T> *		i_buckets;
+};
+
+class Exchangeable {};
+class ExchangeableHandle {};
+
+class ExchangeableList
+    : public Dictionary<Referencer<Exchangeable>, ExchangeableHandle>
+{
+public:
+    ExchangeableList(int size=0);
+};
+
+class ObjectExchange
+{
+public:
+    ObjectExchange() {};
+
+    ExchangeableList	i_theWatchList; // Instruments being monitored
+};
+
+int
+main()
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bob/template4.C b/gcc/testsuite/g++.old-deja/g++.bob/template4.C
new file mode 100644
index 00000000000..1ef2057f3fb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bob/template4.C
@@ -0,0 +1,21 @@
+// prms-id: 10166
+
+template <class A>
+class B {
+  public:
+    int f() {
+      for(int x=0;x<10;x++) {
+        continue;
+        return 1;
+     }
+     return 0;
+   }
+  private:
+    A w;
+};
+
+int
+main() {
+  B<int> c;
+  return c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/README b/gcc/testsuite/g++.old-deja/g++.brendan/README
new file mode 100644
index 00000000000..ce760b1e677
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/README
@@ -0,0 +1,40 @@
+
+abstract	- abstract functions
+alignof		- gcc alignof builtin
+ambiguity	- diagnosing ambiguities
+arm		- ARM cases
+array-refs	- arrays of references
+bit-fields	- bit fields
+chainon		- deaths cuz we call chainon() incorrectly
+copy		- copy constructors
+crash		- old compiler crashes/aborts
+cvt		- user-defined conversions
+def-fns		- default function generation (in add'n to copy)
+enum-clash	- int vs enum
+enum		- enumerated types
+err-msg		- error messages
+friend		- dealing with friend functions and classes
+groff		- crashes derived from groff code
+init		- initialization bugs
+label		- handling labels
+line		- line numbers in error messages
+misc		- miscellaneous tests that didn't fit another category
+nest		- nested types
+new-array	- doing new of an array
+new		- generic operator new bugs
+operators	- tests for various overloaded operators
+parse		- parser bugs
+prepost		- prefix/postfix operator ++/--
+ptolemy		- bugs derived from ptolemy
+recurse		- infinite recursion in the compiler
+redecl		- handling redeclarations
+scope		- managing scopes
+shadow		- shadowing of params, etc
+sizeof		- ARM compliance w/ sizeof operator
+sorry		- old "sorry, not implemented" messages
+static		- handling static data
+template	- template bugs
+union		- handling unions
+visibility	- access control and visibility checking
+warnings	- warning messages
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/abstract1.C b/gcc/testsuite/g++.old-deja/g++.brendan/abstract1.C
new file mode 100644
index 00000000000..b9cd9c5733b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/abstract1.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed abstract-functions
+class O
+{
+public:
+   virtual int c()=0;
+};
+
+class I: public O
+{
+};
+
+class S: public virtual I
+{
+public: 
+  int c();
+  virtual int v()=0;
+};
+
+class D: public S
+{
+   int v();
+};
+
+D *p=new D();
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/access1.C b/gcc/testsuite/g++.old-deja/g++.brendan/access1.C
new file mode 100644
index 00000000000..0272c7ae1a9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/access1.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed access-control
+class Base
+{
+protected:
+  virtual void DoSomething() = 0;
+};
+
+class Fibber : public Base
+{
+public:
+  void DoBP() {
+    DoSomething();
+  }
+};
+
+class Flat : public virtual Fibber
+{
+public:
+  void DoIt() {
+    DoSomething();
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/alignof.C b/gcc/testsuite/g++.old-deja/g++.brendan/alignof.C
new file mode 100644
index 00000000000..1449aded826
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/alignof.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed extensions
+struct bar { int bit : 1; };
+
+void foo (int *r, bar t)
+{
+  // doing alignof on a bit-field should be illegal
+  __alignof__ (t.bit);// ERROR - .*
+
+  // both of these (a regular ref and an INDIRECT_REF) should work
+  __alignof__ (r);
+  __alignof__ (*r);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ambiguity1.C b/gcc/testsuite/g++.old-deja/g++.brendan/ambiguity1.C
new file mode 100644
index 00000000000..c6d6fcbd4ad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ambiguity1.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed ambiguity
+struct A {
+  A (int);
+};
+
+struct B {
+  B (int);
+};
+
+void myfunc (const A& t0); // ERROR - 
+void myfunc (const B& t0); // ERROR - 
+
+int main ()
+{
+   myfunc(1);   // ERROR - ambiguous call
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/anon-union1.C b/gcc/testsuite/g++.old-deja/g++.brendan/anon-union1.C
new file mode 100644
index 00000000000..86b7ce3fabc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/anon-union1.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed anonymous-unions
+static union {
+        char*   uC;
+private:
+        int     uI;// ERROR - .*private member.*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/arm1.C b/gcc/testsuite/g++.old-deja/g++.brendan/arm1.C
new file mode 100644
index 00000000000..e4156323d1a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/arm1.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed ARM-compliance
+// ARM $5.7, it's illegal to do math on a `void*'.
+
+int
+main()
+{
+  void *p;
+  ++p;// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/arm2.C b/gcc/testsuite/g++.old-deja/g++.brendan/arm2.C
new file mode 100644
index 00000000000..62bdc3d2a39
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/arm2.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+// ARM 9.4 ``There cannot be a static and a nonstatic member function
+//	     with the same name and the same argument types.''
+//
+// The trick is to make sure it's caught with both orders (static,
+// then normal, and vice-versa.
+
+class X {
+public:
+   int foo();
+  static int foo();	// error: redeclaration// ERROR - .*
+};
+
+class Y {
+public:
+   static int foo();
+  int foo();		// error: redeclaration// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/arm3.C b/gcc/testsuite/g++.old-deja/g++.brendan/arm3.C
new file mode 100644
index 00000000000..c352bfa57f0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/arm3.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed initialization
+// ARM $11.4: A function first declared in a friend decl is equivalent
+// to an extern decl, so the below is illegal.
+
+class X {
+      friend g(); // ERROR - previous declaration
+};
+static g() { return 1; }// ERROR - previously declared
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/array-refs.C b/gcc/testsuite/g++.old-deja/g++.brendan/array-refs.C
new file mode 100644
index 00000000000..0eaa45c7f1d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/array-refs.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed arm
+int a, b;
+
+// declaring an array of references should be illegal
+int & v[ 2] = { a, b};// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/array1.C b/gcc/testsuite/g++.old-deja/g++.brendan/array1.C
new file mode 100644
index 00000000000..18129589d9f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/array1.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// Special g++ Options: -fconserve-space -fcommon
+// GROUPS passed array-bindings
+
+extern "C" void printf (char *, ...);
+char array[~(~0ul>>1)|~(0ul>>3)];  // ERROR - overflow in array dimension.*
+int main () { printf ("PASS\n"); return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/asm-extn1.C b/gcc/testsuite/g++.old-deja/g++.brendan/asm-extn1.C
new file mode 100644
index 00000000000..fecd092dfb3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/asm-extn1.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// Special g++ Options: -S
+// GROUPS passed asm-extension
+// Skip if not target: sparc-sun-*
+// This used to crash because c_expand_asm_keyword didn't know what to
+// do with this.  The parser rules were changed to accept an expr, instead
+// of a stmt.
+
+extern void traptable(void);
+
+main()
+{
+  asm("wr    %0,%%tbr" : : "r" (traptable));
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/bit-fields1.C b/gcc/testsuite/g++.old-deja/g++.brendan/bit-fields1.C
new file mode 100644
index 00000000000..76f4ac33ac2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/bit-fields1.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed bit-fields
+struct bar {
+  int : 2 = 1;// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/bit-fields2.C b/gcc/testsuite/g++.old-deja/g++.brendan/bit-fields2.C
new file mode 100644
index 00000000000..c77ce86e07d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/bit-fields2.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed bit-fields
+	struct {
+	    char c;
+	    int i:8;
+	} s;
+	
+	int main()
+	{
+	    int &ir = s.i;	// ERROR - address of bitfield
+	    int *ip = &s.i;	// ERROR - address of bitfield
+	    ir = 10;
+	}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/bool1.C b/gcc/testsuite/g++.old-deja/g++.brendan/bool1.C
new file mode 100644
index 00000000000..1e7b343ad16
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/bool1.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed boolean
+int
+main()
+{
+    typedef char Boolean; // Instrinsic.h
+    Boolean c = false;
+    bool b = true;
+
+    if (!c != !b)
+	;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/code-gen1.C b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen1.C
new file mode 100644
index 00000000000..84dd634d9cf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen1.C
@@ -0,0 +1,40 @@
+// GROUPS passed code-generation
+// Check that sub-word sized structs/classes are passed correctly
+// if the struct/class has a constructor (i.e. ANY constructor).
+
+extern "C" void printf (char *, ...); 
+
+struct base {
+	unsigned int f1 : 8;
+	unsigned int f2 : 8;
+
+	base (int ii)
+	{
+	}
+};
+
+base global_base (7);
+
+int test2 (base formal_base);
+
+int main ()
+{
+	global_base.f1 = 0x55;
+	global_base.f2 = 0xee;
+
+	if (test2 (global_base) == 0)
+	  printf ("PASS\n");
+	else
+	  printf ("FAIL\n");
+
+	return 0;
+}
+
+int test2 (base formal_base)
+{
+	if (formal_base.f1 != global_base.f1)
+		return -1;
+	if (formal_base.f2 != global_base.f2)
+		return -1;
+	return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/code-gen2.C b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen2.C
new file mode 100644
index 00000000000..133755e894d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen2.C
@@ -0,0 +1,18 @@
+// GROUPS passed code-generation
+// Check that declarations with initializations are executed
+// correctly.
+
+extern "C" void printf (char *, ...); 
+
+int main ()
+{
+	char buff[40] ;
+	char *tmp = &buff[0];	// also fails for char *tmp = buff;
+
+	if ((unsigned int) tmp != (unsigned int) &buff[0])
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+
+	return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/code-gen3.C b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen3.C
new file mode 100644
index 00000000000..6d73bd2336e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen3.C
@@ -0,0 +1,34 @@
+// GROUPS passed code-generation
+// Check that passing things which are not a multiple of
+// 4 bytes in size doesn't mess up other subsequent parameters.
+
+extern "C" void printf (char *, ...); 
+
+struct base {
+	int f1 : 8;
+	int f2 : 8;
+};
+
+base global_base;
+
+int val1;
+
+int test2 (struct base formal_base, int v1);
+
+int main ()
+{
+	val1 = 0x5e5e;
+	return test2 (global_base, val1);
+}
+
+int test2 (struct base formal_base, int v1)
+{
+	formal_base.f1 = formal_base.f2;	// prevent warnings
+
+	if (v1 != 0x5e5e)
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+
+	return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/code-gen4.C b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen4.C
new file mode 100644
index 00000000000..e29b16a2b09
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen4.C
@@ -0,0 +1,31 @@
+// Special g++ Options: -O
+// GROUPS passed code-generation
+// Options: -O
+//
+// Check that when an int value is assigned to a short int, the proper
+// half of the int (i.e. the low order half) ends up in the short.
+//
+// This fails with 1.32.0 with -O and f1() is inline.
+//
+// Workaround - declare "f1_arg" as type "short int".
+
+extern "C" void printf (char *, ...); 
+
+short int v2;
+
+long v1 = 0x11117777;
+
+inline void f1 (long f1_arg)
+{
+	v2 = f1_arg;
+}
+
+int main ()
+{
+	f1 (v1);
+
+	if (v2 != 0x00007777)
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/code-gen5.C b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen5.C
new file mode 100644
index 00000000000..25987776e26
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen5.C
@@ -0,0 +1,57 @@
+// Special g++ Options: -Wno-deprecated -fthis-is-variable
+// GROUPS passed code-generation
+// Check that the "this" pointer is zero when a method is
+// called for an object pointed to by a null pointer.
+
+// Normally, the "__builtin_new" operation which actually
+// allocates objects in heap space is *not* called at the
+// actual point of the "new" keyword.  Rather, a check is
+// made within each constructor and if the "this" pointer
+// value passed in is zero, then the actual allocation of
+// memory (via __builtin_new) is done at that point (i.e.
+// at the very beginning of the constructor).
+
+// A special trick allows one to subvert this mechanism.
+// Specifically, if a given constructor contains a statement
+// like: "this = this", then no attempt will be made to
+// implicitly call __builtin_new within that constructor.
+
+extern "C" void printf (char *, ...); 
+
+struct base {
+	int member;
+
+	base ();
+	void member_function ();
+};
+
+base *base_pointer_1 = 0;
+base *base_pointer_2 = 0;
+
+int errors = 0;
+
+int main ()
+{
+	//base_pointer_2 = new base();
+	base_pointer_1->member_function ();
+
+	if (errors)
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+
+	return 0;
+}
+
+base::base ()
+{
+	this = this;
+	if ((int) this != 0)
+		errors++;
+}
+
+void base::member_function ()
+{
+	if ((int) this != 0)
+		errors++;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/code-gen6.C b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen6.C
new file mode 100644
index 00000000000..ea5d730949d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/code-gen6.C
@@ -0,0 +1,54 @@
+// GROUPS passed code-generation
+// Check that type float parameters can be correctly passed to
+// methods.
+
+extern "C" void printf (char *, ...); 
+
+class tres_floats {
+	float ff1;
+	float ff2;
+	float ff3;
+public:
+	tres_floats (float f1, float f2, float f3);
+	float get_f1 ();
+	float get_f2 ();
+	float get_f3 ();
+};
+
+float v1 = 1.2345;
+float v2 = 3.14159;
+float v3 = 0.707;
+
+int main ()
+{
+	tres_floats tf (v1, v2, v3);
+
+	if ((tf.get_f1() != v1) || (tf.get_f2() != v2) || (tf.get_f3() != v3))
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+
+	return 0;
+}
+
+tres_floats::tres_floats (float f1, float f2, float f3)
+{
+	ff1 = f1;
+	ff2 = f2;
+	ff3 = f3;
+}
+
+float tres_floats::get_f1 ()
+{
+	return ff1;
+}
+
+float tres_floats::get_f2 ()
+{
+	return ff2;
+}
+
+float tres_floats::get_f3 ()
+{
+	return ff3;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/complex1.C b/gcc/testsuite/g++.old-deja/g++.brendan/complex1.C
new file mode 100644
index 00000000000..908b4ca5f90
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/complex1.C
@@ -0,0 +1,22 @@
+// Special g++ Options:
+
+// This test makes sure that the stuff in lex.c (real_yylex) is
+// set up to handle real and imag numbers correctly.  This test is against
+// a bug where the compiler was not converting the integer `90' to a
+// complex number, unless you did `90.0'.  Fixed 10/1/1997.
+
+extern "C" void printf (char *, ...);
+
+__complex__ double cd;
+
+int
+main(int argc, char *argv[])
+{
+  cd = 1.0+90i;
+  cd *= argc;
+
+  if (__real__ cd != 1 || __imag__ cd != 90)
+    exit (1);
+
+  exit (0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/copy1.C b/gcc/testsuite/g++.old-deja/g++.brendan/copy1.C
new file mode 100644
index 00000000000..27d959f8320
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/copy1.C
@@ -0,0 +1,21 @@
+// GROUPS passed copy-ctors
+extern "C" void printf (char *, ...);
+int count = 0;
+
+class C {
+public:
+  C (int) { count++; }
+  operator int () { return 0; }
+};
+
+int
+main ()
+{
+  C c1 (1);
+  C c2 (c1);
+
+  if (count != 1)
+    printf ("FAIL\n");
+  else
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/copy2.C b/gcc/testsuite/g++.old-deja/g++.brendan/copy2.C
new file mode 100644
index 00000000000..0ecc1e9db10
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/copy2.C
@@ -0,0 +1,79 @@
+// GROUPS passed copy-ctors
+/*
+The old g++ output is
+
+Item()
+Compound()
+Pre foo
+foo
+~Compound()
+~Item()
+Post foo
+~Compound()
+~Item()
+
+The output should be something like (produced from ATT 2.1)
+
+Item()
+Compound()
+Pre foo
+Item(const Item& i)    <------ missing above
+foo
+~Compound()
+~Item()
+Post foo
+~Compound()
+~Item()
+
+*/
+
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+int count = 0;
+
+void
+die (int x)
+{
+  if (x != ++count)
+    {
+      printf ("FAIL\n");
+      exit (1);
+    }
+}
+  
+
+class Item {
+ public:
+  Item() { die (1); }
+  Item(const Item& i) { die (4); }
+  ~Item() { count++; if (count != 7 && count != 10) die (-1); }
+};
+
+
+class Compound {
+  Item i;
+ public:
+  Compound() { die (2); }
+  ~Compound() { count++; if (count != 6 && count != 9) die (-1); }
+};
+
+
+void foo(Compound a)
+{
+  die (5);
+}
+
+int
+main()
+{
+  Compound a;
+
+  die (3);
+  foo(a);
+
+  die (8);
+
+  printf ("PASS\n");
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/copy3.C b/gcc/testsuite/g++.old-deja/g++.brendan/copy3.C
new file mode 100644
index 00000000000..3b1edd5f0ab
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/copy3.C
@@ -0,0 +1,58 @@
+// GROUPS passed copy-ctors
+/*
+
+If I compile it with cfront (AT&T C++ Translator 2.00.02 08/25/89) and run it
+I get:
+
+	A::A()
+	A::A(const A&)
+	B::Bar()
+	A::~A()
+	A::~A()
+
+If I compile it with g++ (gcc version 2.2.2) and run it I get:
+
+	A::A()
+	B::Bar()
+	A::~A()
+	A::~A()
+
+*/
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+int count = 0;
+
+void
+die (int x)
+{
+  if (x != ++count)
+    {
+      printf ("FAIL\n");
+      exit (1);
+    }
+}
+  
+
+class A {
+public:
+  A() { die (1); }
+  A(const A&) { die (2); }
+  ~A() { count++; if (count != 4 && count != 5) die (-1); }
+};
+
+class B : public A {
+public:
+  void Bar() { die (3); }
+};
+
+void Foo(B b) { b.Bar(); }
+
+int
+main()
+{
+  B b;
+  Foo(b);
+
+  printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/copy4.C b/gcc/testsuite/g++.old-deja/g++.brendan/copy4.C
new file mode 100644
index 00000000000..35b53932141
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/copy4.C
@@ -0,0 +1,58 @@
+// GROUPS passed copy-ctors
+// Using Cfront 3.0.1 the programm below prints
+// 
+// 	  A()
+// 	  A(const A& a)
+// 	  ~A()
+// 	  A(A& a)        <---- !!!
+// 	  ~A()
+// 	  ~A()
+// 
+// the g++ 2.2.2 (sparc-sun-sunos4.1) generated code prints
+// 
+// 	  A()
+// 	  A(const A& a)
+// 	  ~A()
+// 	  A(const A& a)  <---- !!!
+// 	  ~A()
+// 	  ~A()
+
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+int count = 0;
+
+void
+die (int x)
+{
+  if (x != ++count)
+    {
+      printf ("FAIL\n");
+      exit (1);
+    }
+}
+
+class A {
+public:
+  A() { die (1); }
+  A(const A& a) { die (2); }
+  A(A& a) { die (4); }
+  ~A() { count++; if (count != 3 && count != 5 && count != 6) die (-1); }
+};
+
+void foo1(const A& a) {
+  A b = a;
+}
+
+void foo2( A& a) {
+  A b = a;
+}
+
+int main() {
+  A a;
+
+  foo1(a);
+  foo2(a);
+
+  printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/copy5.C b/gcc/testsuite/g++.old-deja/g++.brendan/copy5.C
new file mode 100644
index 00000000000..277940ba240
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/copy5.C
@@ -0,0 +1,85 @@
+// GROUPS passed copy-ctors
+/*
+bad:
+sibelius402> a.out
+a=5  a.virtMember()=30
+BaseClass::Increm --> {i=5, virtMember()=30}
+a=7  a.virtMember()=30
+b=7  b.virtMember()=30
+BaseClass::Increm --> {i=7, virtMember()=999}
+b=9  b.virtMember()=30
+sibelius403> 
+
+ good:
+
+sibelius406> a.out
+a=5  a.virtMember()=30
+BaseClass::Increm --> {i=5, virtMember()=30}
+a=7  a.virtMember()=30
+b=7  b.virtMember()=30
+BaseClass::Increm --> {i=7, virtMember()=30}
+b=9  b.virtMember()=30
+*/
+
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+void die () { printf ("FAIL\n"); exit (1); }
+
+class BaseClass {
+
+  friend int operator != (const BaseClass irv, int x);
+
+  int i;
+
+public:
+
+  BaseClass( const BaseClass& ir ) : i(ir.i) {};
+  BaseClass() : i(5) {};
+
+  virtual int virtMember() { return( 999 ); };
+
+  void Increm( int r );
+};
+
+void BaseClass::Increm( int r )
+{
+  if ((i == 5 && virtMember () == 30)
+      || (i == 7 && virtMember () == 30))
+    i += r;
+  else
+    die ();
+};
+
+class DerivedClass : public BaseClass {
+public:
+  int virtMember() { return( 30 ); };
+};
+
+int operator != (const BaseClass irv, int x) { return irv.i != x; }
+
+int
+main ()
+{
+    DerivedClass a;
+
+    if (a != 5 || a.virtMember () != 30)
+      die ();
+
+    a.Increm(2);
+
+    if (a != 7 || a.virtMember () != 30)
+      die ();
+
+    DerivedClass b = a;
+
+    if (b != 7 || a.virtMember () != 30)
+      die ();
+
+    b.Increm(2);
+
+    if (b != 9 || a.virtMember () != 30)
+      die ();
+
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/copy6.C b/gcc/testsuite/g++.old-deja/g++.brendan/copy6.C
new file mode 100644
index 00000000000..d15a4beee15
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/copy6.C
@@ -0,0 +1,55 @@
+// GROUPS passed copy-ctors
+/*
+g++ 2.3.3 will prefer using type conversions over the
+implicitly generated copy constructor. This is wrong.
+If you explicitly define a copy constructor, it will
+use it. However, the implicit copy constructor MUST be
+called whenever an explicit one would have been called
+also. See below: g++ converts from and back into
+unsigned, instead of using the implicit copy constructor:
+here is the version:
+Reading specs from /usr/lib/gcc-lib/i386-linux/2.3.3/specs
+gcc version 2.3.3
+ /usr/lib/gcc-lib/i386-linux/2.3.3/cpp -lang-c++ -v -undef -D__GNUC__=2 -D__GNUG__=2 -D__cplusplus -Dunix -Di386 -Dlinux -D__unix__ -D__i386__ -D__linux__ -D__unix -D__i386 -D__linux bug2.cc /usr/tmp/cca02008.i
+GNU CPP version 2.3.3 (80386, BSD syntax)
+ /usr/lib/gcc-lib/i386-linux/2.3.3/cc1plus /usr/tmp/cca02008.i -quiet -dumpbase bug2.cc -version -o /usr/tmp/cca02008.s
+GNU C++ version 2.3.3 (80386, BSD syntax) compiled by GNU C version 2.3.3.
+ as -o /usr/tmp/cca020081.o /usr/tmp/cca02008.s
+ ld /usr/lib/crt0.o -nojump -L/usr/lib/gcc-lib/i386-linux/2.3.3 /usr/tmp/cca020081.o -lg++ -lgcc -lc -lgcc
+
+Ok, and here is the output:
+test k: constructing from scratch
+test l=k: type conversion into unsigned
+constructing from unsigned
+
+*/
+
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+int count = 0;
+
+void die () { printf ("FAIL\n"); exit (1); }
+
+struct test {
+	test() { if (count != 0) die (); }
+
+	test(unsigned) {
+	  die ();
+	}
+	operator unsigned() {
+	  die ();
+	  return 0;
+	}
+};
+
+int
+main() {
+  test k;
+  test l=k;
+
+  printf ("PASS\n");
+
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/copy7.C b/gcc/testsuite/g++.old-deja/g++.brendan/copy7.C
new file mode 100644
index 00000000000..e2f4e7ac286
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/copy7.C
@@ -0,0 +1,30 @@
+// GROUPS passed copy-ctors
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+void die () { printf ("FAIL\n"); exit (1); }
+
+class B {
+public:
+  B() {}
+  B(const B &) { printf ("PASS\n"); exit (0); };
+private:
+    int x;
+};
+
+class A : public B {
+public:
+    A() {}
+
+  A(const B &) { printf ("FAIL\n"); exit (1); }
+};
+
+int
+main()
+{
+    A a;
+    A b(a);
+
+    printf ("FAIL\n");
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/copy8.C b/gcc/testsuite/g++.old-deja/g++.brendan/copy8.C
new file mode 100644
index 00000000000..fe248bae34d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/copy8.C
@@ -0,0 +1,67 @@
+// GROUPS passed copy-ctors
+/*
+This report is for GCC 2.3.3 running on a Sun/4.  The bug is that when
+a class instance is passed-by-value, GCC does not correctly copy the value.
+At the end of this report is an example program that demonstrates the bug.  
+It should print:
+
+	construct A('x')
+	copy A('x')
+	destruct A('x')
+	destruct A('x')
+
+and in fact does for IBM's xlC C++.  However, for GCC 2.3.3, it fails
+to print the second line ["copy A('x')"], which indicates that it failed
+to call the copy-constructor for class A when it should have.  Below is a 
+typescript that lists the program, shows how I compiled it, and shows the 
+incorrect output.
+*/
+
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+int count = 0;
+
+void
+die (int x)
+{
+  if (x != ++count)
+    {
+      printf ("FAIL\n");
+      exit (1);
+    }
+}
+
+class A { // Class with explicit & instrumented copy-constructor and destructor.
+public:
+    const char * id;
+    A( const char * id1 ) : id(id1) { die (1); }
+
+    // Copy constructor
+    A( const A& a ) : id(a.id) { die (2); }
+
+    // Destructor
+    ~A() { count++; if (count != 3 && count != 4) die (-1); }
+};
+
+class X { // Class without explicit copy-constructor
+private:
+    A a;
+public:
+    X( const char * id ) : a(id) {}
+};
+
+void Func( X x ) {      // Function with call-by-value argument
+}
+
+int
+main() {
+    X x("x");           // Construct instance of x.
+
+    // The next line should call the copy-constructor for X since x is
+    // being passed by value.  For GCC 2.3.3 on a Sun/4, it does not.
+    Func(x);
+
+    printf ("PASS\n");
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/copy9.C b/gcc/testsuite/g++.old-deja/g++.brendan/copy9.C
new file mode 100644
index 00000000000..59fd2285419
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/copy9.C
@@ -0,0 +1,41 @@
+// GROUPS passed copy-ctors
+#include <iostream.h>
+
+// token types: from state parser
+const int T_EOF = 257;
+const int T_ERROR = 258;
+const int T_Float = 259;
+const int T_Int = 260;
+const int T_ID = 261;
+const int T_STRING = 262;
+
+class Complex;
+class State;
+
+// token, from state parser.
+class ParseToken {
+public:
+	int tok;
+	union {
+		char cval;
+		const char *sval;
+		int intval;
+		double  doubleval;
+		Complex* Complexval;
+		const State*  s;
+	}; 
+	ParseToken () { tok = 0; intval = 0;}
+};
+
+int
+main () {
+	ParseToken a;
+	a.tok = T_Float;
+	a.doubleval = 23.2;
+	ParseToken b(a);
+
+	if (b.doubleval == 23.2)
+	  cout << "PASS\n";
+	else
+	  cout << "FAIL\n";
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash1.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash1.C
new file mode 100644
index 00000000000..66de235b484
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash1.C
@@ -0,0 +1,44 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class D_Interval;
+
+class Date
+{
+ public:
+  Date(const D_Interval*,const Date&);
+private:
+  const D_Interval* interval;
+};
+
+class Time_Interval
+{
+ public:
+   Time_Interval(const Date& start,const Date& stop);
+   const Date& Start() const { return start; }
+   const Date& Stop() const { return stop; }
+ private:
+   Date start;
+   Date stop;
+};
+
+class Dated_Data
+{
+ public:
+   Dated_Data(const Time_Interval& dates);
+   virtual ~Dated_Data();
+   Time_Interval Dates() const { return dates; }
+ private:
+   Time_Interval dates;
+};
+
+class Raw_Data : public Dated_Data
+{
+ public:
+   Raw_Data(const Dated_Data *source,const D_Interval& period);
+};
+
+Raw_Data::Raw_Data(const Dated_Data *source,const D_Interval& period)
+     : Dated_Data(Time_Interval(Date(&period,source->Dates().Start()),
+				Date(&period,source->Dates().Stop())))
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash10.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash10.C
new file mode 100644
index 00000000000..6680718bad6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash10.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class word
+{
+  unsigned char b1, b2;
+public:
+  word (unsigned int i = 0) { b1 = i & 0xff; b2 = (i & 0xff00) >> 8; }
+  operator unsigned int () { return (b2 <<  8) + b1; }
+};
+
+class just_another
+{
+  int foo;
+  char bar[23];
+};
+
+int mumble(word w)
+{
+  just_another *jap;
+  unsigned bar;
+
+  bar = w;
+  
+  jap = new just_another [w];
+  
+  return 0;
+}  
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash11.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash11.C
new file mode 100644
index 00000000000..00c30867cf9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash11.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed old-abort
+extern "C" void printf (char *, ...);
+
+class A {
+        int	i; // ERROR - private
+        int	j; // ERROR - private
+    public:
+	int	h;
+	A() { i=10; j=20; }
+	virtual void f1() { printf("i=%d j=%d\n",i,j); }
+	friend virtual void f2() { printf("i=%d j=%d\n",i,j); }// ERROR -  virtual.*
+};
+
+class B : public A {
+    public:
+	virtual void f1() { printf("i=%d j=%d\n",i,j); }// ERROR -  member.*// ERROR -  member.*
+	friend virtual void f2() { printf("i=%d j=%d\n",i,j); }// ERROR -  virtual.*// ERROR -  member.*// ERROR -  member.*
+};
+
+int
+main() {
+	A * a = new A;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash12.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash12.C
new file mode 100644
index 00000000000..0671c7b8970
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash12.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class X
+{
+        int i;
+public:
+        X(int j);
+}
+
+X *x = new X[10]();// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash13.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash13.C
new file mode 100644
index 00000000000..c375e9b7220
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash13.C
@@ -0,0 +1,36 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class gen_op
+{
+public:
+  gen_op ( );
+  gen_op (const gen_op &Op1);
+  ~gen_op ( );
+  void operator = (const gen_op &Op1);
+};
+
+
+
+
+class spin_op 
+{
+public:
+  spin_op();
+  spin_op(const spin_op& SOp);
+  ~spin_op();
+  void operator= (const spin_op& SOp);
+  operator gen_op();
+};
+
+
+spin_op Fe();
+
+
+gen_op Spul_U_axis()
+{
+  gen_op U1;
+  U1 = Fe();
+}; // ERROR - reaches end of non-void function
+
+int
+main () {};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash14.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash14.C
new file mode 100644
index 00000000000..dc2812191ac
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash14.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed old-abort
+extern "C" void printf (char *, ...);
+
+
+class cl
+{
+  int i;
+public:
+  cl(int j = 0) {i = j;}
+  int get_i() {return i;}
+  };
+
+int
+main()
+{
+  cl ob[3] = {1, 2, 3};
+  int i;
+
+  for(i=0; i<3; i++)
+    printf("%d\n", ob[i].get_i());
+
+  return 0;
+  }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash15.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash15.C
new file mode 100644
index 00000000000..56a7e75b9ba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash15.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed old-abort
+#include <iostream.h>
+
+class A {
+ public:
+  virtual ~A() {cout << "executed ~A()\n";};
+};
+
+class B : public A {
+ public:
+  virtual ~B() {cout << "executed ~B()\n";};
+};
+
+int
+main() {
+  cout << "starting\n";
+  B b;
+  b.~A();// ERROR -  destructor
+  cout << "done\n";
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash16.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash16.C
new file mode 100644
index 00000000000..5030b297ae0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash16.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class Graph {
+public:
+      unsigned         char N;
+      Graph(void) {}; // ERROR - previously defined here
+}
+
+Graph::Graph(void)
+{    N = 10;// ERROR -  return type.*
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash17.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash17.C
new file mode 100644
index 00000000000..7072eab2c88
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash17.C
@@ -0,0 +1,35 @@
+// Build don't link: 
+// GROUPS passed old-abort
+//
+// This one creates
+//
+// gcc2: Internal compiler error: program cc1plus got fatal signal 11
+//
+// when compiled with g++.
+// The error goes away, if
+// 1) int ClassInvariant() is not virtual or
+// 2) GnObject has a virtual destructor or
+// 3) GnWidget has no virtual destructor or
+// 4) GnContracts has a virtual destructor
+//
+
+
+class GnContracts {
+  public:
+    virtual int ClassInvariant();
+//    virtual ~GnContracts();
+};
+
+class GnObject : public GnContracts {
+  public:
+//    virtual ~GnObject();
+};
+
+class GnWidget : public GnObject {
+  public:
+    virtual ~GnWidget();
+};
+
+class GnOptionGroup : public GnObject, public GnWidget {
+};// ERROR -  warning
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash18.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash18.C
new file mode 100644
index 00000000000..d4a4c60b7c8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash18.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed old-abort
+typedef int element;
+class Pix {
+public:
+    Pix();
+    Pix(const Pix&);
+
+    // Friend functions so that v == x works as does x == v works
+    friend int operator==(void *v, const Pix& x)
+        { return v == index; }// ERROR - .*
+    friend int operator==(void *v, const Pix& x)
+        { return v != index; }// ERROR - .*
+private:
+//    friend class List<T>;
+    element *index;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash2.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash2.C
new file mode 100644
index 00000000000..ad6e04029cc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash2.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed old-abort
+// The compiler used to crash on this example.
+
+class x {
+public:
+  x();
+  static const x y[23];
+};
+const x x::y[23];
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash20.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash20.C
new file mode 100644
index 00000000000..7704b98ebd2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash20.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed old-abort
+#include <complex>
+typedef complex<double> Complex;
+
+Complex ComputeVVself()
+{
+Complex temp1;
+Complex self[3][3];
+
+   self[1][2] = 100.0;
+   return self[1][2];
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash22.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash22.C
new file mode 100644
index 00000000000..f7db97d43e9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash22.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed old-abort
+struct A {
+    void a1();
+    void a2();
+};
+
+struct B {
+    void A::a1(); // this used to die in chainon(), now grokdeclarator should// ERROR -  cannot declare.*
+    void A::a2(); // should be fixed by the 930629 change.// ERROR -  cannot declare.*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash23.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash23.C
new file mode 100644
index 00000000000..03ffee666a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash23.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed old-abort
+// This used to die in chainon; it shouldn't any more.
+
+class A
+{
+public:
+  class B {
+  public:
+    void f ();
+    void g (int);
+  };
+  void B::f () {}// ERROR - .*
+  void B::g (int val) {}// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash24.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash24.C
new file mode 100644
index 00000000000..af1c3010229
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash24.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// Special g++ Options: -O
+// GROUPS passed old-abort
+// gcc puts the array into a register, and then the store_bit_field () code
+// in expmed.c gets confused when it tries to store zero past the end of the
+// register (because the index is past the array bounds).   It ends up calling
+// store_split_bit_field, which then aborts, because we don't have a split bit
+// field.
+//
+// Seems easiest to detect this case in the front end, i.e. access outside the
+// array bounds, and then force the array to be allocated on the stack instead
+// of a register.
+
+main()
+{
+  char i[1];
+
+  i[1] = 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash25.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash25.C
new file mode 100644
index 00000000000..625eaf84707
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash25.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class memo{
+public:
+	static int rep;
+};
+
+class port_head : public memo {
+public:
+	static 	int rep;
+	unsigned cap();
+};
+
+class buff_head : private port_head {
+public:
+	static int rep;
+	port_head::cap;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash26.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash26.C
new file mode 100644
index 00000000000..9b6643debe4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash26.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed old-abort
+struct B {
+    B();
+};
+ 
+class C : virtual public B
+{
+  public:
+    C() { }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash27.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash27.C
new file mode 100644
index 00000000000..62acbe03e19
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash27.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class First {
+public:
+  First(const First& a);
+};
+
+class Second {
+  int i;
+  First f;
+public:
+  ~Second() {}
+  Second func();
+};
+
+void foo()
+{
+  extern Second x;
+  x = x.func();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash28.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash28.C
new file mode 100644
index 00000000000..08adee9308a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash28.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed old-abort
+    class abc
+    {
+     public: 
+      void F()       { return; }
+
+     private:
+      typedef int myint;
+      typedef struct { int b; } mystruct;
+      typedef union  { int c; } myunion;
+    };
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash29.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash29.C
new file mode 100644
index 00000000000..72bbdc77849
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash29.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed old-abort
+
+union Value
+{
+	Value(){}
+};
+
+struct GlobalAddress
+{
+	GlobalAddress(Value *nvar){}// ERROR - .*
+};// ERROR -  candidates .*
+
+int
+main()
+{
+	new GlobalAddress(Value());		// internal error occured here// ERROR -  no matching function .*
+	//new GlobalAddress(new Value());	// This line is correct code
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash3.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash3.C
new file mode 100644
index 00000000000..b3b8354b543
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash3.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed old-abort
+int	strcmp();
+
+extern "C" {
+      // dies in common_type, cuz the TREE_TYPE of t2 is 0, so it can't get its
+      // TYPE_MAIN_VARIANT value.
+      // <void_type 184510 void permanent VOID
+      //  size <integer_cst 1844e0 type <integer_type 182548 int> constant permanent 0
+      //    align 1 symtab 0
+      //    pointer_to_this <pointer_type 1845e0>
+
+int       strcmp(const char*, const char*);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash30.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash30.C
new file mode 100644
index 00000000000..707e89841ff
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash30.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed old-abort
+#include <string>
+
+int
+main(void) {
+
+  string a[] = {"Hello"};
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash31.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash31.C
new file mode 100644
index 00000000000..d5b7e541e8a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash31.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed old-abort
+struct mbuf {
+	struct mbuf *next;
+};
+
+void* malloc(int);
+struct mbuf *
+mbuf_allocate(int size)
+{
+    struct mbuf *bp;
+
+    bp = (struct mbuf *) malloc( 10 /*(unsigned) (size + sizeof(struct mbuf))*/);
+    return bp;
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash32.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash32.C
new file mode 100644
index 00000000000..ebca5a4f6fa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash32.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// Special g++ Options: -fshort-enums
+// GROUPS passed old-abort
+enum Bool { FALSE, TRUE };
+Bool foo () { return TRUE; }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash33.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash33.C
new file mode 100644
index 00000000000..d89fa7b5147
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash33.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed old-abort
+extern void foo(void *);
+int
+main() {
+	foo((struct bar *)0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash34.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash34.C
new file mode 100644
index 00000000000..a147b6219df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash34.C
@@ -0,0 +1,3 @@
+// Build don't link: 
+// GROUPS passed old-abort
+operator int () {}// ERROR - .*// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash35.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash35.C
new file mode 100644
index 00000000000..e32b7c13b59
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash35.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed old-abort
+const unsigned int ENET_INTERRUPT_MID = 5;
+
+extern "C" void ENET_RxP();
+
+class EnetReceiver
+    {
+    public:
+        friend void ENET_RxP();
+        void  receiveMessage();
+        int *messagePointer;
+    };
+
+void EnetReceiver::receiveMessage()
+    {
+    if (*((unsigned int*) messagePointer) == ENET_INTERRUPT_MID)
+        {
+        }
+    }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash36.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash36.C
new file mode 100644
index 00000000000..10534535405
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash36.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed old-abort
+struct wait { int w_status; };
+int wait();
+extern "C" int wait(int*);
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash37.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash37.C
new file mode 100644
index 00000000000..18eb64a7683
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash37.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed old-abort
+typedef int _sigset_t;
+extern "C" {
+        extern int sigaction(int signo, const struct sigaction *action_spec_p, struct sigaction *old_action_p);
+}
+extern "C" {
+        extern void foo();
+};
+class SS {
+        friend void foo();
+protected:
+        void goo();
+};
+inline void
+SS::goo() { }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash38.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash38.C
new file mode 100644
index 00000000000..eeb70e1c373
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash38.C
@@ -0,0 +1,43 @@
+// Build don't link: 
+// GROUPS passed old-abort
+/*
+   I received the following message when using g++ (version 2.3.3):
+
+   main.cc: In method 'Implicit<implicit<INTEGER,2>,3>::Implicit()':
+   main.cc: Internal compiler error 241.
+   main.cc: Please report this to 'bug-g++@prep.ai.mit.edu'
+   */
+
+#include <stream.h>
+
+class INTEGER {
+int x;
+public:
+   typedef int BASE;
+   INTEGER(int y) : x(y) {}
+   INTEGER() {}
+   void encode() { cout << "Integer encoder";}
+   int operator=(int y) { x=y; return x; }
+   operator int() {return x; }
+};
+
+template< class T,  int n> class Implicit : public T {
+   public:
+     typedef typename T::BASE BASE;
+     Implicit(BASE value ): T(value) {};
+     Implicit() : T() {};
+     int myTag() { return n; }
+     void encode() { T::encode(); }
+     BASE operator=(BASE t) { return T::operator=(t); }
+};
+
+int
+main() 
+{
+  Implicit<Implicit<INTEGER, 2> ,  3> y;
+
+  y = 10;
+};
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash39.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash39.C
new file mode 100644
index 00000000000..a19187295ec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash39.C
@@ -0,0 +1,33 @@
+// Build don't link: 
+// Special g++ Options: -w
+// GROUPS passed old-abort
+//#include <GetOpt.h>
+#include <stdio.h>
+
+class GetOpt
+{
+private:
+  static char *nextchar;
+   enum OrderingEnum { REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER };
+   OrderingEnum ordering;
+  static int first_nonopt;
+  static int last_nonopt;
+  void exchange (char **argv);
+public:
+  char *optarg;
+  int optind;
+  int opterr;
+  
+  int    nargc;
+  char **nargv;
+  const char  *noptstring;
+  
+  GetOpt (int argc, char **argv, const char *optstring);
+  int operator () (void);
+};
+//end <GetOpt.h>
+#include <string>
+
+class foo {public: foo () {}};
+class bar {public: bar (const foo& dflt);};
+class baz: public bar {public: baz (): bar (foo ()) {}};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash4.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash4.C
new file mode 100644
index 00000000000..1f8a3ffc532
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash4.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed old-abort
+typedef struct Thing {
+		Thing();
+	int	x;
+} Thing;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash40.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash40.C
new file mode 100644
index 00000000000..dcebfbebade
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash40.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class foo {
+
+public:
+
+	virtual foo &operator <<(foo &(foo::*)(foo &));
+};
+
+
+foo &foo::operator<<(foo &(foo::*manip)(foo &))
+{
+ 
+   (this->*manip)(*this);
+ 
+   return *this;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash41.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash41.C
new file mode 100644
index 00000000000..5d533b866e2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash41.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed old-abort
+typedef void (**ppfn)(void);
+
+int main() {
+    ppfn fn;
+
+    fn = new (void(*)(void));
+
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash42.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash42.C
new file mode 100644
index 00000000000..1b92f5d858d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash42.C
@@ -0,0 +1,6 @@
+// GROUPS passed old-abort
+// Build don't link: 
+int fn();// ERROR -  ambiguates.*
+int x;
+int& fn() {// ERROR -  new decl.*
+return x;}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash43.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash43.C
new file mode 100644
index 00000000000..5fe54231c89
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash43.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// Special g++ Options: -g -fno-strict-prototype
+// GROUPS passed old-abort
+// excess errors test - XFAIL sparc64-*-elf
+extern "C" { typedef int jmp_buf[12]; }
+
+enum Error { NO_ERROR };
+class ErrorHandler
+{
+    ErrorHandler *previous;
+    static ErrorHandler *error_stack;
+    jmp_buf error_buffer;
+protected:
+    static void pop()
+    {
+	error_stack = error_stack->previous;
+    }
+public:
+    jmp_buf *push()
+    {
+	previous = error_stack;
+	error_stack = this;
+	return &error_buffer;
+    }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash44.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash44.C
new file mode 100644
index 00000000000..00a4df4b0dc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash44.C
@@ -0,0 +1,27 @@
+// Build don't link: 
+// GROUPS passed old-abort
+template <class T> class bug {
+
+public:
+    void		Foo(const int = 0);
+    void		NotRedeclared(const int);
+
+private:
+	T		TheItem;
+};
+
+template <class T> void bug<T>::NotRedeclared(const int)
+{
+}
+
+template <class T> void bug<T>::Foo(const int)
+{
+}
+
+int
+main()
+{
+	bug<char>	InstantiatedBug;
+
+	return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash45.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash45.C
new file mode 100644
index 00000000000..269a51908b2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash45.C
@@ -0,0 +1,3 @@
+// Build don't link: 
+// GROUPS passed old-abort
+void foo() { static const char *const v[] = { 0 }; }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash46.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash46.C
new file mode 100644
index 00000000000..64d8d59ce21
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash46.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class Rational {
+public:
+    Rational(int v): value(v)
+	{  }
+
+    int value;
+};
+typedef Rational __Rational;
+
+extern int operator>(const Rational&, const Rational&);
+
+class V {
+public:
+    class Rational {
+    public:
+	static int x(const __Rational& value);
+    };
+};
+
+int
+V::Rational::x(const __Rational& value)
+{
+    return value > 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash47.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash47.C
new file mode 100644
index 00000000000..9bdbb11ab3d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash47.C
@@ -0,0 +1,94 @@
+// Build don't link: 
+// GROUPS passed old-abort
+const int TRUE = 1;
+const int FALSE = 0;
+
+class Rep {
+protected:
+    Rep(): count(0)
+	{ }
+    Rep(const Rep& other): count(0)
+	{ }
+
+    Rep& operator=(const Rep& other)
+	{ /* DO NOT copy over other.count */
+	  return *this; }
+
+public:		// TODO - for now
+    // Because it is to hard to restrict these operations to the descendants
+    // of Rep<REP> that we haven't named yet.  So we just make them public.
+    void inc()
+	{ count++; }
+    void dec()
+	{ if (0 == --count) delete this; }
+private:
+    unsigned count;
+};
+
+template<class REP>
+class Ref {
+public:
+    Ref(): rep(0)
+	{ }
+    Ref(const Ref<REP>& other): rep(other.rep)
+	{ if (rep) rep->inc(); }
+    ~Ref()
+	{ if (rep) rep->dec();
+	  rep = 0; }
+
+    Ref<REP>& operator=(const Ref<REP>& other)
+	{ if (rep != other.rep) {
+	    if (rep) rep->dec();
+	    rep = other.rep;
+	    if (rep) rep->inc(); }
+	  return *this; }
+
+    bool null() const
+	{ return 0 == rep ? TRUE: FALSE; }
+    bool valid() const
+	{ return 0 != rep ? TRUE: FALSE; }
+
+    REP* operator->() const		// should be a valid() reference
+	{ return rep; }
+    operator REP*() const;		// should be a valid() reference
+
+protected:
+    REP *rep;
+
+    Ref(REP *r): rep(r)
+	{ if (rep) rep->inc(); }
+
+    Ref<REP>& operator=(REP *r)
+	{ if (rep != r) {
+	    if (rep) rep->dec();
+	    rep = r;
+	    if (rep) rep->inc(); }
+	  return *this; }
+};
+
+template<class REP>
+Ref<REP>::operator REP*() const		// should be a valid() reference
+{ return rep; }
+
+template<class REP> 
+inline int
+operator==(const Ref<REP>& a, const Ref<REP>& b)
+{ return (REP *) a == (REP *) b; }
+
+template<class REP> 
+inline int
+operator!=(const Ref<REP>& a, const Ref<REP>& b)
+{ return (REP *) a != (REP *) b; }
+
+class XRep: public Rep {
+public:
+    int i;
+};
+
+int
+main()
+{
+    Ref<XRep> y;
+
+    return y != y;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash48.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash48.C
new file mode 100644
index 00000000000..6dc9da09d0a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash48.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class internal {
+	int field;
+	int anotherfield;
+}; // ERROR - candidates are
+
+class bug {
+	internal* numbers;
+	bug(int size);
+}; // ERROR - several errors
+
+bug::bug(int size)
+{ // ERROR - candidates
+	numbers = new internal(size * size);// ERROR -  no match.*
+}
+
+int
+main()
+{
+	bug test;// ERROR -  no match
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash49.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash49.C
new file mode 100644
index 00000000000..98a580d3cb1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash49.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed old-abort
+#include<iostream.h>
+
+const int keys = 10;
+const int key[keys] = {6, key[1], 2, keys, 1, 7, 6, key[2], key[8]};
+
+void main()
+{ // ERROR - return type for main
+        for(int i = 0; i < keys;) cout << key[i++] << " ";
+        endl(cout);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash5.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash5.C
new file mode 100644
index 00000000000..0e82e1607ba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash5.C
@@ -0,0 +1,107 @@
+// Build don't link: 
+// GROUPS passed old-abort
+// Should have been fixed by:
+//
+// Sun Jun 13 12:55:22 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+// 
+// 	* cp-cvt.c (build_default_binary_type_conversion): Look deeper into
+// 	what ARG1 and ARG2 are if they're POINTER_TYPEs.
+
+volatile void exit(int);
+
+class CountableSet
+{
+	public:
+		virtual	~CountableSet() { }		
+};	
+
+template<class T>
+class FixedSet : virtual public CountableSet
+{
+	public:
+		virtual	int Get(int, T&) = 0;		 
+		virtual	~FixedSet() { }		
+};
+
+class ShrinkableSet
+{
+	public:
+		virtual int Remove(int) = 0;   
+};
+
+template<class T>
+class PVSet : virtual public FixedSet<T>, virtual public ShrinkableSet
+{
+	public:
+		virtual	void Append(const T&) = 0;
+		virtual	void operator+=(const T& a) { Append(a); }
+		virtual	~PVSet() { }		
+};
+
+template<class T>
+class MutSet : virtual public FixedSet<T>, virtual public FixedSet<T *>
+{
+	protected:
+		typedef	T	*Tp;
+
+	public:
+		void Append(const Tp& tp) { Append(*tp); }
+
+		T&	Access(int p)
+		{
+			Tp	tp;
+			Get(p, tp);
+			return *tp;
+		}
+		virtual	~MutSet() { }		
+};
+
+template <class T>
+class	SimpleSet : virtual public MutSet<T>
+{
+	protected:
+		T	*array;
+		int	size;
+
+		virtual	void	Allocate(int s)
+		{
+			array = new T[s];
+		}
+	public:
+		SimpleSet()
+		{
+			size = 0;
+			array = ((void*)0) ; // ERROR - implicit conversion
+		}
+ 		int	Get(int p, T& t)
+		{
+			t = array[p-1];
+			return 1;
+		}
+		int	Get(int p, T *& t)
+		{
+			t = &array[p-1];
+			return 1;
+		}
+		inline void Append(const T& a)
+		{
+			array[size-1] = a;
+		}
+		inline int Remove(int n) { return 0; }
+};
+
+class	Dummy
+{
+	public:
+		Dummy()	{}
+};
+
+int
+main()
+{
+	SimpleSet<Dummy *>		bs1;
+	int	i, j;
+	Dummy	foo;
+
+	bs1+=&foo;// ERROR -  no .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash50.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash50.C
new file mode 100644
index 00000000000..fd87d75a2e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash50.C
@@ -0,0 +1,29 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class B
+        {
+public:
+        int i;
+        };
+int operator & (const B &s) { return ( s.i  );};
+
+
+
+
+
+class C
+        {
+public:
+        C &operator = (const C &x)
+                {
+                return *this;
+                };
+        };
+
+C &(C::*DD)(const C &x) = &C::operator=;
+
+int main()
+{
+        &DD;
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash51.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash51.C
new file mode 100644
index 00000000000..3586eb425f7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash51.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class obj;
+
+typedef obj *obj_t;
+
+class obj {
+public:
+    obj( const obj& o );
+};   
+
+extern obj nowhere;
+
+class set: public obj {
+    unsigned  bit_vector;
+public:
+    set( const obj& o );
+    set&      operator|=( const int q );
+};   
+
+enum pin_enum { E_F, O_C, O_D, O_S, P_D, P_U, R, T, A, C };
+
+set t_q = ( ( ( ( ( ( set( nowhere ) |= E_F ) |= O_C ) |= O_D ) |= O_S )
+              |= P_U ) |= P_D ) |= T;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash52.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash52.C
new file mode 100644
index 00000000000..d10afdcc43d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash52.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed old-abort
+#include <iostream.h>
+
+class A {
+public:
+  friend A f(A &a);// ERROR -  ambiguates.*
+};
+
+A &f(A &a) {// ERROR -  new decl.*
+  cout << "Blah\n";
+} // ERROR - non-void function
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash53.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash53.C
new file mode 100644
index 00000000000..163f8e6ced7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash53.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class A
+{
+  public:
+    class B
+    {
+      public:
+        virtual ~B();
+    };
+};
+
+template<int I>
+class C
+{
+  public:
+    class B
+    : public A::B
+    {
+    }; // bug2.cc:18: Internal compiler error 233.
+       // bug2.cc:18: Please submit a full bug report to `bug-g++@prep.ai.mit.edu'.
+};
+
+C<0> c;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash54.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash54.C
new file mode 100644
index 00000000000..7d2a8a0530e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash54.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed old-abort
+int main()
+{
+    int a[100], **p;
+
+    p = &a[50];// ERROR -  assignment to.*
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash55.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash55.C
new file mode 100644
index 00000000000..47a74249ef6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash55.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed old-abort
+      extern f(int);// ERROR -  ambiguates.*
+
+      int& f(int x)
+      {// ERROR -  new declaration.*
+          int local;// ERROR -  warning
+
+          local = x+2;
+      
+          return local;
+      }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash56.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash56.C
new file mode 100644
index 00000000000..b5e997cc6ee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash56.C
@@ -0,0 +1,385 @@
+// Build don't link: 
+// GROUPS passed old-abort
+// Special g++ Options:
+
+const bool FALSE = 0;
+const bool TRUE = 1;
+class ListDProto {
+public:
+    ListDProto();
+    ListDProto(const ListDProto&);
+    virtual ~ListDProto();
+    void operator=(const ListDProto&);
+    unsigned length() const;
+    bool empty() const;
+    void clear();
+    void remove_head();
+    void remove_tail();
+    class link;
+    class Vix {
+    public:
+	Vix();
+	friend int operator==(void *v, const Vix& x)
+	    { return v == x.item; }// ERROR - list of candidates
+	friend int operator==(const Vix& x, void *v)
+	    { return v == x.item; }// ERROR - candidate for call
+	friend int operator!=(void *v, const Vix& x)
+	    { return v != x.item; }
+	friend int operator!=(const Vix& x, void *v)
+	    { return v != x.item; }
+	friend int operator==(const Vix& x1, const Vix& x2)
+	    { return x1.owner == x2.owner && x1.item == x2.item; }// ERROR - candidate for call
+	friend int operator!=(const Vix& x1, const Vix& x2)
+	    { return x1.owner != x2.owner || x1.item != x2.item; }
+	bool first;		 
+	bool last;		 
+    protected:
+        friend class ListDProto;
+	Vix(const ListDProto *o, link *i);
+	const ListDProto *owner;
+    private:
+	link *item;
+    };
+    enum Action { NORMAL, REMOVE_CURRENT };
+    Vix first() const;
+    void first(Vix& x) const;
+    void next(Vix& x) const;
+    void next(Vix& x, Action a = NORMAL);
+    Vix last() const;
+    void last(Vix& x) const;
+    void prev(Vix& x) const;
+    void prev(Vix& x, Action a = NORMAL);
+protected:
+    struct link {
+	link *next;
+	link *prev;
+	link(link *n = 0, link *p = 0);
+	virtual ~link();
+    private:
+	link(const link&);
+	void operator=(const link&);
+    };
+    unsigned count;
+    link *list_head;		 
+    link *list_tail;		 
+    virtual link *copy_item(link *old_item) const = 0;
+    void prepend(link *item);
+    void append(link *item);
+    void prepend(const ListDProto& proto);
+    void append(const ListDProto& proto);
+    void remove(link *item);
+    link *ref(const Vix&) const;
+};
+template<class T>
+class ListD: public ListDProto {
+public:
+    void prepend(const T& item);
+    void append(const T& item);
+    const T& head() const;
+    T& head();
+    void head(T& fill) const;
+    void remove_head()
+	{ ListDProto::remove_head(); }
+    void remove_head(T& fill);
+    const T& tail() const;
+    T& tail();
+    void tail(T& fill) const;
+    void remove_tail()
+	{ ListDProto::remove_tail(); }
+    void remove_tail(T& fill);
+    class Vix: public ListDProto::Vix {
+    public:
+	Vix(): ListDProto::Vix()
+	    { }
+    protected:
+        friend class ListD<T>;
+	Vix(const ListDProto::Vix& x): ListDProto::Vix(x)
+	    { }
+    };
+    Vix first() const
+	{ return ListDProto::first(); };
+    void first(Vix& x) const
+	{ ListDProto::first(x); };
+    void next(Vix& x, ListDProto::Action a = NORMAL) const
+	{ ListDProto::next(x, a); }// ERROR - .*// ERROR - .*
+    Vix last() const
+	{ return ListDProto::last(); }
+    void last(Vix& x) const
+	{ return ListDProto::last(x); }
+    void prev(Vix& x, ListDProto::Action a = NORMAL) const
+	{ return ListDProto::prev(x, a); }
+protected:
+    struct link_item: public ListDProto::link {
+	T item;
+	link_item(const T& i): link(0, 0), item(i)
+	    { }
+    private:
+	link_item(const link_item&);
+	void operator=(const link_item&);
+    };
+public:
+    T& operator()(const Vix& x)
+	{ link_item *li = (link_item *) ref(x);
+	  return li->item; }
+    const T& operator()(const Vix& x) const
+	{ link_item *li = (link_item *) ref(x);
+	  return li->item; }
+private:
+    ListDProto::link *copy_item(ListDProto::link *old_item) const;
+};
+template<class T>
+class SetLD: private ListD<T> {
+public:
+    SetLD();			 
+    SetLD(const ListD<T>&);	 
+    void add(const T& item);
+    void add(const ListD<T>& other);
+    void add(const SetLD<T>& other);
+    void remove(const T& item);
+    bool contains(const T& item) const;
+    ListD<T>::length;
+    ListD<T>::empty;
+    ListD<T>::clear;
+    typedef ListD<T>::Vix Vix;
+    ListD<T>::first;
+    ListD<T>::next;
+    ListD<T>::operator();
+};
+extern "C" {
+extern void __eprintf (const char *, const char *, unsigned, const char *);
+}
+extern "C" {
+extern void __eprintf (const char *, const char *, unsigned, const char *);
+}
+template<class T>
+void
+ListD<T>::prepend(const T& item)
+{
+    link *newl = new link_item(item);
+    ListDProto::prepend(newl);
+}
+template<class T>
+void
+ListD<T>::append(const T& item)
+{
+    link *newl = new link_item(item); 
+    ListDProto::append(newl);
+}
+template<class T>
+const T&
+ListD<T>::head() const
+{
+    ((void) (( 0 != list_head ) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n",	  "/home/wbaker/work/include/templates/ListD.body.h" ,   50 ,  "0 != list_head" ), 0) )) ;
+    link_item *h = (link_item *) list_head;
+    return h->item;
+}
+template<class T>
+T&
+ListD<T>::head()
+{
+    ((void) (( 0 != list_head ) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n",	  "/home/wbaker/work/include/templates/ListD.body.h" ,   59 ,  "0 != list_head" ), 0) )) ;
+    link_item *h = (link_item *) list_head;
+    return h->item;
+}
+template<class T>
+void
+ListD<T>::head(T& fill) const
+{
+    ((void) (( 0 != list_head ) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n",	  "/home/wbaker/work/include/templates/ListD.body.h" ,   68 ,  "0 != list_head" ), 0) )) ;
+    link_item *h = (link_item *) list_head;
+    fill = h->item;
+}
+template<class T>
+void
+ListD<T>::remove_head(T& fill)
+{
+    head(fill);
+    remove_head();
+}
+template<class T>
+const T&
+ListD<T>::tail() const
+{
+    ((void) (( 0 != list_tail ) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n",	  "/home/wbaker/work/include/templates/ListD.body.h" ,   85 ,  "0 != list_tail" ), 0) )) ;
+    link_item *h = (link_item *) list_tail;
+    return h->item;
+}
+template<class T>
+T&
+ListD<T>::tail()
+{
+    ((void) (( 0 != list_tail ) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n",	  "/home/wbaker/work/include/templates/ListD.body.h" ,   94 ,  "0 != list_tail" ), 0) )) ;
+    link_item *h = (link_item *) list_tail;
+    return h->item;
+}
+template<class T>
+void
+ListD<T>::tail(T& fill) const
+{
+    ((void) (( 0 != list_tail ) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n",	  "/home/wbaker/work/include/templates/ListD.body.h" ,   103 ,  "0 != list_tail" ), 0) )) ;
+    link_item *h = (link_item *) list_tail;
+    fill = h->item;
+}
+template<class T>
+void
+ListD<T>::remove_tail(T& fill)
+{
+    ((void) (( 0 != list_tail ) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n",	  "/home/wbaker/work/include/templates/ListD.body.h" ,   112 ,  "0 != list_tail" ), 0) )) ;
+    link_item *h = (link_item *) list_tail;
+    fill = h->item;
+}
+template<class T>
+ListDProto::link *
+ListD<T>::copy_item(ListDProto::link *old) const
+{
+    link_item *old_item = (link_item *) old;
+    link_item *new_item = new link_item(old_item->item);
+    return new_item;
+}
+template<class T>
+SetLD<T>::SetLD():
+ListD<T>()
+{ }
+template<class T>
+SetLD<T>::SetLD(const ListD<T>& other):
+ListD<T>(other)
+{ }
+template<class T>
+void
+SetLD<T>::add(const T& item)
+{
+    if ( ! contains(item) )
+	append(item);
+}
+template<class T>
+void
+SetLD<T>::add(const ListD<T>& other)
+{
+    ListD<T>::Vix x;
+    for (first(x); 0 != x; next(x))
+	add(other(x));
+}
+template<class T>
+void
+SetLD<T>::add(const SetLD<T>& other)
+{
+    const ListD<T>& lother = other;
+    add(lother);
+}
+template<class T>
+void
+SetLD<T>::remove(const T& item)
+{
+    Action a = NORMAL;
+    Vix x;
+    for (first(x); 0 != x && REMOVE_CURRENT != a; next(x, a))
+	a = operator()(x) == item ? REMOVE_CURRENT: NORMAL;// ERROR - .*
+}
+template<class T>
+bool
+SetLD<T>::contains(const T& item) const
+{
+    Vix x;
+    for (first(x); 0 != x; next(x)) {
+	if (operator()(x) == item)// ERROR - .*
+	    return TRUE;
+    }
+    return FALSE;
+}
+template<class T>
+int
+operator==(const SetLD<T>& a, const SetLD<T>& b)
+{
+    if (a.length() != b.length())
+	return FALSE;
+    SetLD<T>::Vix x;
+    for (a.first(x); 0 != x; a.next(x)) {
+	if ( ! b.contains(a(x)) )
+	    return FALSE;
+    }
+    for (b.first(x); 0 != x; b.next(x)) {
+	if ( ! a.contains(b(x)) )
+	    return FALSE;
+    }
+    return TRUE;
+}
+template<class T>
+int
+operator!=(const SetLD<T>& a, const SetLD<T>& b)
+{ return ! (a == b); }
+template<class T>
+int
+operator<=(const SetLD<T>& a, const SetLD<T>& b)
+{
+    if (a.length() > b.length())
+	return FALSE;
+    SetLD<T>::Vix x;
+    for (x=a.first(); 0 != x; a.next(x)) {
+	if ( ! b.contains(a(x)) )
+	    return FALSE;
+    }
+    return TRUE;
+}
+template<class T>
+int
+operator<(const SetLD<T>& a, const SetLD<T>& b)
+{
+    if (a.length() >= b.length())
+	return FALSE;
+    return a <= b;
+}
+template<class T>
+int
+operator>(const SetLD<T>& a, const SetLD<T>& b)
+{ return ! (a <= b); }
+template<class T>
+int
+operator>=(const SetLD<T>& a, const SetLD<T>& b)
+{ return ! (a < b); }
+class String { };
+class IcaseString: public String { };
+class SetLD< IcaseString >: public SetLD<    String  > {	public:	 SetLD (): SetLD<    String  >() { };	 SetLD (const ListD<   IcaseString  >& other): SetLD<    String  >()	{ ListD<   IcaseString  >::Vix x;	for (other.first(x); 0 != x; other.next(x))	add(other(x)); };	 SetLD (const  SetLD & other): SetLD<    String  >(other) { };	const    IcaseString  & operator()(const Vix& x) const	{ return (   IcaseString  &) SetLD<    String  >::operator()(x); }	}; 	typedef SetLD<  String > SetLD_String_IcaseString_old_tmp99;	typedef SetLD< IcaseString > SetLD_String_IcaseString_new_tmp99;	
+inline int	 operator== (const SetLD_String_IcaseString_new_tmp99& a,	const SetLD_String_IcaseString_new_tmp99& b)
+{// ERROR - candidate for call
+const SetLD_String_IcaseString_old_tmp99& oa = a;
+const SetLD_String_IcaseString_old_tmp99& ob = b;
+return  operator== (oa, ob);	} 	
+inline int	 operator!= (const SetLD_String_IcaseString_new_tmp99& a,	const SetLD_String_IcaseString_new_tmp99& b)
+{
+const SetLD_String_IcaseString_old_tmp99& oa = a;
+const SetLD_String_IcaseString_old_tmp99& ob = b;
+return  operator!= (oa, ob);	} 	
+inline int	 operator< (const SetLD_String_IcaseString_new_tmp99& a,	const SetLD_String_IcaseString_new_tmp99& b)
+{
+const SetLD_String_IcaseString_old_tmp99& oa = a;
+const SetLD_String_IcaseString_old_tmp99& ob = b;
+return  operator< (oa, ob);	} 	
+inline int	 operator<= (const SetLD_String_IcaseString_new_tmp99& a,	const SetLD_String_IcaseString_new_tmp99& b)
+{
+const SetLD_String_IcaseString_old_tmp99& oa = a;
+const SetLD_String_IcaseString_old_tmp99& ob = b;
+return  operator<= (oa, ob);	} 	
+inline int	 operator> (const SetLD_String_IcaseString_new_tmp99& a,	const SetLD_String_IcaseString_new_tmp99& b)
+{
+const SetLD_String_IcaseString_old_tmp99& oa = a;
+const SetLD_String_IcaseString_old_tmp99& ob = b;
+return  operator> (oa, ob);	} 	
+inline int	 operator>= (const SetLD_String_IcaseString_new_tmp99& a,	const SetLD_String_IcaseString_new_tmp99& b)
+{
+const SetLD_String_IcaseString_old_tmp99& oa = a;
+const SetLD_String_IcaseString_old_tmp99& ob = b;
+return  operator>= (oa, ob);	}   ;
+typedef SetLD<IcaseString> SLDiS;
+static void
+nop(int i)
+{
+    SetLD<IcaseString> x, y;
+    nop(x == y);
+ nop(x != y);
+nop(x < y);
+nop(x <= y);
+nop(x > y);
+nop(x >= y);
+}
+
+template class SetLD<String>;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash57.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash57.C
new file mode 100644
index 00000000000..5032b3f6cce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash57.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class foo {
+private:
+  char buffer[1024];
+public:
+  foo();
+};
+
+int main()
+{
+  static foo& a = *(new foo);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash58.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash58.C
new file mode 100644
index 00000000000..922290f000c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash58.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class X {
+public:
+void doit();
+};
+
+X::::doit()// ERROR -  (syntax|parse) error.*
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash6.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash6.C
new file mode 100644
index 00000000000..a6527a5cbd4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash6.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed old-abort
+// Should be fixed by:
+// Sun Jun 13 12:55:22 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+// 
+// 	* cp-decl.c (start_function): Avoid a null-reference on CTYPE.
+
+template<int>
+class Program {
+} ;
+
+class Program<0> {
+public:
+   inline friend float EvalNextArg()
+        { return 1.0 ; }
+} ;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash60.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash60.C
new file mode 100644
index 00000000000..b2af4310d1b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash60.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class X
+{
+public:
+    X ();
+    int	f[4];
+};
+
+// Note that we mistakenly initialize the array data member as if it
+// was scalar
+X::X () : f (0) {}// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash61.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash61.C
new file mode 100644
index 00000000000..4d3bbc4c693
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash61.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed old-abort
+        template <class TP> class sapp { };
+        class foo {};
+        extern foo& __iomanip_setw (foo&, TP);// ERROR -  type spec.*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash62.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash62.C
new file mode 100644
index 00000000000..77b9fc84763
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash62.C
@@ -0,0 +1,32 @@
+// Build don't link: 
+// GROUPS passed old-abort
+#include <iostream.h>
+
+	void
+	fubar(ostream* out, const char* string)
+	{
+  	  (*out) << string << endl;
+  	  return;
+	}
+
+	int
+	main()
+	{
+  	  // Declare a ref and a pointer to the same ostream.
+  	  //
+  	  ostream* out = &cerr;
+  	  ostream& die = cerr;
+
+  	  // Valid call to fubar.
+  	  //
+  	  fubar(out, "First line.");
+  
+  	  // Invalid call to fubar. (1st arg is an ostream&. fubar expects
+  	  // ostream*.)This should be a syntax error, but g++ does not catch it.
+  	  // Call to this function results in a bus error in fubar when the 1st
+  	  // arg is dereferenced.
+  	  //
+  	  fubar(die, "Second line.");// ERROR -  cannot convert .die.*
+  
+  	  return 1;
+	}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash63.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash63.C
new file mode 100644
index 00000000000..84f8fc57624
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash63.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class String
+   {
+ public:
+   String (const char *str);
+   };
+
+class UnitList 
+   {
+ public:
+   UnitList (...);
+   };
+
+UnitList unit_list (String("keV"));
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash64.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash64.C
new file mode 100644
index 00000000000..310241850f7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash64.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed old-abort
+typedef long unsigned int size_t;
+typedef void (*RF_Ptr)(void *);
+
+struct _im_pers_mem_spec {
+  inline _im_pers_mem_spec(void );
+  inline _im_pers_mem_spec(auto int of, auto int n);
+};
+
+struct _type_desc {
+  _type_desc(char *, int , RF_Ptr , int , int ,...);
+};
+
+struct metatype { int base_list; };
+
+static _type_desc _type_metatype("metatype", sizeof(metatype),
+  (RF_Ptr)0, 0, 1, 1,
+  _im_pers_mem_spec( ((size_t)&((( metatype *)0)-> base_list )) , 1));
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash65.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash65.C
new file mode 100644
index 00000000000..132651e90a0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash65.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class X {
+public:  
+  virtual const char* 	XY(const void* val) const = 0;
+};
+
+
+class Y : public X {
+public:
+  using X::xy;// ERROR -  no memb.*
+
+  using X::z;// ERROR -  no memb.*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash66.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash66.C
new file mode 100644
index 00000000000..878957b84e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash66.C
@@ -0,0 +1,137 @@
+// Build don't link: 
+// Special g++ Options: -O
+// GROUPS passed old-abort
+typedef unsigned char uchar;
+typedef unsigned short ushort;
+typedef unsigned long ulong;
+extern int swap_endian;			 
+inline ushort
+swapshort(ushort value)
+{
+    value &= 0xffff;
+    return ((value << 8) | (value >> 8));
+}
+struct eshort
+{
+    ushort	data;			 
+    operator ushort() { return swap_endian ? swapshort(data) : data;}
+    eshort(ushort t) { data = swap_endian ? swapshort(t) : t;}
+    eshort() {}
+};
+inline ulong
+swaplong(ulong value)
+{
+    ulong v = (value << 16) | (value >> 16);
+    return ((v >> 8) & 0x00ff00ff) | ((v << 8) & 0xff00ff00);
+};
+struct elong
+{
+    ulong	data;			 
+    operator ulong() { return swap_endian ? swaplong(data) : data;}
+    elong(ulong t) { data = swap_endian ? swaplong(t) : t; }
+    elong() {}
+};
+struct digiheader
+{
+    uchar	type[2];		 
+    eshort	soft_version;		 
+    eshort	lo_boot_rev;		 
+    eshort	hi_boot_rev;		 
+    eshort	load_segment;		 
+    eshort	length;			 
+    eshort	exec_start;		 
+    eshort	image_offset;		 
+    elong	startup_code[2];	 
+    elong	checksum;		 
+};
+extern void uncompress(uchar* buf, ulong len);
+extern ulong compress(char* filename, uchar* buffer, ulong);
+struct filehdr
+{
+    eshort	f_magic;		 
+    eshort	f_nscns;		 
+    elong	f_timdat;		 
+    elong	f_symptr;		 
+    elong	f_nsyms;		 
+    eshort	f_opthdr;		 
+    eshort	f_flags;		 
+};
+struct aouthdr
+{
+    eshort	magic;			 
+    eshort	vstamp;			 
+    elong	tsize;			 
+    elong	dsize;			 
+    elong	bsize;			 
+    elong	entry;			 
+    elong	text_start;		 
+    elong	data_start;		 
+    elong	bss_start;		 
+    elong	gprmask;		 
+    elong	cprmask[4];		 
+    elong	gp_value;		 
+};
+struct scnhdr
+{
+    char	s_name[8];		 
+    elong	s_paddr;		 
+    elong	s_vaddr;		 
+    elong	s_size;			 
+    elong	s_scnptr;		 
+    elong	s_relptr;		 
+    elong	s_lnnoptr;		 
+    eshort	s_nreloc;		 
+    eshort	s_nlnno;		 
+    elong	s_flags;		 
+};
+int file_little_endian;			 
+int host_little_endian;			 
+int swap_endian;			 
+int docheck;				 
+int expand;				 
+ulong memsize;				 
+ulong compression_quality;		 
+char *compressfile;			 
+int debug_level;			 
+extern "C" int getopt (int, char**, char*);
+int
+main(int argc, char** argv)
+{
+    uchar checksum;
+    uchar docrc;
+    ulong len;
+    ulong maxlen;
+    int i;
+    int c;
+    int magic;
+    int tsize;
+    int dsize;
+    int quality;
+    char dummy;
+    uchar* code;
+    uchar* buf;
+    char* ap;
+    digiheader *dh;
+    compression_quality = 10000;
+    docheck = 0;
+    while ((c = getopt(argc, argv, "Ccdf:k:q:x:")) != -1)
+    {
+	switch (c)
+	{
+	default:
+	    goto usage;
+	}
+    }
+    if ((expand && (docheck || compressfile || quality)) ||
+	(quality && !compressfile))
+    {
+    usage:
+	return(2);
+    }
+    if (compressfile)
+    {
+	dh->image_offset = len;
+	
+	len += compress(compressfile, code + len, maxlen - len);
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash67.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash67.C
new file mode 100644
index 00000000000..f63ba5ddf3f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash67.C
@@ -0,0 +1,3 @@
+// Build don't link: 
+// GROUPS passed old-abort
+#pragma comment(exestr, "@(#) errno.h 10.2 92/03/26 ")
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash68.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash68.C
new file mode 100644
index 00000000000..b209bd891c0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash68.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// Special g++ Options: -w -O
+// GROUPS passed old-abort
+class   RWDlist
+{
+public:
+  RWDlist& operator=(const RWDlist&);
+};
+class DataItemRWGDlist : public RWDlist {};
+
+class Base {};
+class DataItemList : public Base
+{
+  private:
+  DataItemRWGDlist m_diList;
+};      
+
+class StatementGroup
+{
+  public:
+    DataItemList   dataItemList;
+    StatementGroup(const StatementGroup&);
+};
+
+StatementGroup::StatementGroup(const StatementGroup& sg)
+{
+  dataItemList = sg.dataItemList;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash7.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash7.C
new file mode 100644
index 00000000000..19476fc47ce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash7.C
@@ -0,0 +1,48 @@
+// Build don't link: 
+// GROUPS passed templates
+
+template<class T>
+class Vector
+{
+  int sz;
+  T *v;
+public:
+  Vector (int s) : sz (s) { v = new T[sz]; }
+  ~Vector () { delete[] v; }
+  T &operator[] (int i) { return v[i]; }
+  int size () { return sz; }
+};
+
+template<class T>// ERROR - previous definition of T
+struct Comparator
+{
+  typedef T T;// ERROR - use of template type T in typedef to T
+  static int lessthan (T &a, T &b) { return a < b; }
+};
+
+template<class Comp>
+struct Sort
+{
+  static void sort (Vector<Comp::T> &);// ERROR - use of bad T
+};
+
+template<class Comp>
+void Sort<Comp>::sort (Vector<Comp::T> &v)// ERROR - use of bad T
+{
+  int n = v.size ();
+
+  for (int i = 0; i < n - 1; i++)
+    for (int j = n - 1; i < j; j--)
+      if (Comp::lessthan (v[j], v[j - 1]))
+	{
+	  typename Comp::T temp = v[j];
+	  v[j] = v[j - 1];
+	  v[j - 1] = temp;
+	}
+}
+
+void
+f (Vector<int> &vi)
+{
+  Sort<Comparator<int> >::sort (vi);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash8.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash8.C
new file mode 100644
index 00000000000..8990c465677
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash8.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed old-abort
+template<int a, int b>
+class Elvis
+{// ERROR - in template.*
+} ;
+
+template<int a>
+class Elvis<0>
+{ // ERROR - incorrect number of parameters
+   int geta() { return a ; }
+} ;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/crash9.C b/gcc/testsuite/g++.old-deja/g++.brendan/crash9.C
new file mode 100644
index 00000000000..a4155ef6bb5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/crash9.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed old-abort
+class A {};
+
+class SimQuery
+{
+public:
+  SimQuery();
+  ~SimQuery();
+  int SetMeshFile(char name[]);
+protected:
+  A& scaling;
+  A* mesh;
+};
+
+SimQuery::SimQuery():scaling(A) {}// ERROR - .*
+
+SimQuery::~SimQuery() {}// ERROR - 
+
+int SimQuery::SetMeshFile(char name[])
+{// ERROR - 
+  mesh = new C;// ERROR - .*
+  return 0; // needed to avoid warning of reaching end of non-void fn
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ctors1.C b/gcc/testsuite/g++.old-deja/g++.brendan/ctors1.C
new file mode 100644
index 00000000000..eaf487159d8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ctors1.C
@@ -0,0 +1,27 @@
+// GROUPS passed constructors
+// Check that global level object constructors get called.
+
+extern "C" void printf (char *, ...); 
+
+struct base {
+	int f1;
+	int f2;
+	base (int arg1, int arg2);
+};
+
+
+base global_base(0x55, 0xff);
+
+int main ()
+{
+	if ((global_base.f1 != 0x55) || (global_base.f2 != 0xff))
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+}
+
+base::base(int arg1, int arg2)
+{
+	f1 = arg1;
+	f2 = arg2;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ctors2.C b/gcc/testsuite/g++.old-deja/g++.brendan/ctors2.C
new file mode 100644
index 00000000000..2f83ce1cdb8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ctors2.C
@@ -0,0 +1,28 @@
+// GROUPS passed constructors
+// Check that sub-words sized class members are correctly set
+// by constructors.
+
+extern "C" void printf (char *, ...); 
+
+struct base {
+	int f1 : 8;
+	int f2 : 8;
+	base (int arg1, int arg2);
+};
+
+
+base global_base(0x55, 0x7e);
+
+int main ()
+{
+	if ((global_base.f1 != 0x55) || (global_base.f2 != 0x7e))
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+}
+
+base::base(int arg1, int arg2)
+{
+	f1 = arg1;
+	f2 = arg2;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ctors3.C b/gcc/testsuite/g++.old-deja/g++.brendan/ctors3.C
new file mode 100644
index 00000000000..755d547b022
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ctors3.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed constructors
+class A;
+
+class B {
+public:
+    B();
+static A sa;
+};
+
+class A {
+public:
+    A(int i);
+};
+
+A B::sa(1);
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/cvt1.C b/gcc/testsuite/g++.old-deja/g++.brendan/cvt1.C
new file mode 100644
index 00000000000..57f3b426108
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/cvt1.C
@@ -0,0 +1,44 @@
+// Build don't link: 
+// GROUPS passed conversions
+#include <iostream.h>
+
+class Thing
+{
+public:
+      typedef enum { GOOD_THING, BAD_THING, } ThingType ; // ERROR - comma
+	Thing (ThingType type) : thingType (type) { }
+	~Thing () { }
+private:
+	ThingType thingType ;
+} ;
+
+class Group
+{
+public:
+      typedef enum { THIS_GROUP, THAT_GROUP, } GroupType ; // ERROR - comma
+	Group (GroupType type) : groupType (type), groupCount (0) { }
+	~Group () { }
+	void append (Thing* const &entry) { groupCount ++ ; }
+	operator GroupType () const { return groupType ; }
+	operator int () const { return groupCount ; } // remove this and problem gone
+
+private:
+	int groupCount ;
+	GroupType groupType ;
+} ;
+
+inline Group& operator += (Group& g, Thing* const t)
+{
+	g.append (t) ;
+	return g ; // complaint is here
+}
+
+int
+main (int argc, char** argv)
+{
+	Group g (Group::THIS_GROUP) ;
+
+	g += new Thing (Thing::GOOD_THING) ;
+	cout << "Group type is " << (Group::GroupType) g << endl ;
+	return 0 ;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/cvt2.C b/gcc/testsuite/g++.old-deja/g++.brendan/cvt2.C
new file mode 100644
index 00000000000..76ae1561f3a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/cvt2.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed conversions
+void f(const short & s) { }
+
+   int
+main() {
+   f(0);
+   return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/cvt3.C b/gcc/testsuite/g++.old-deja/g++.brendan/cvt3.C
new file mode 100644
index 00000000000..6ab8465c6df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/cvt3.C
@@ -0,0 +1,48 @@
+// Build don't link: 
+// GROUPS passed conversions
+class GttObject {};
+class GctObject: virtual public GttObject {};
+class NDAMObject: virtual public GttObject, virtual public GctObject {};
+class GctHashObject: virtual public GctObject {};
+
+class GctRef: virtual public GctHashObject
+{ public: operator void*() const; };
+
+class NDAMAssemblerObject: virtual public NDAMObject {};
+class GctReferenceObject: virtual public GctHashObject {};
+class NDAMValue: virtual public NDAMAssemblerObject, public GctReferenceObject {};
+
+class nnyacc;
+class NDAMValueRef : virtual public NDAMObject, public GctRef 
+{
+  NDAMValue *operator->() const;	 
+  operator NDAMValue *() const;	 
+friend class nnyacc;
+};
+
+typedef void* Pix;
+class NDAMValueRefSLList
+{
+public:
+  NDAMValueRefSLList();
+  NDAMValueRefSLList(const NDAMValueRefSLList& a);
+  ~NDAMValueRefSLList();
+  NDAMValueRef& operator () (Pix p) const;
+};
+
+struct bar
+{
+  NDAMValueRefSLList *valueList;
+};
+
+class nnyacc
+{
+public:
+      static void assign(void*& lval, void*& rval); // ERROR - candidates
+};
+
+void
+foo (bar yylval, bar *yyvsp)
+{
+  nnyacc::assign(yylval.valueList, yyvsp[0].valueList);// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/cvt4.C b/gcc/testsuite/g++.old-deja/g++.brendan/cvt4.C
new file mode 100644
index 00000000000..3d9f475b679
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/cvt4.C
@@ -0,0 +1,27 @@
+// Build don't link: 
+// GROUPS passed conversions
+class A {};
+
+template <class TP>
+class B
+{
+  A &(*_f) (A &, TP);
+  TP _a;
+public:
+  B (A &(*f) (A &, TP), TP a) : _f (f), _a (a) {}
+  friend A &operator<< (A &o, const B<TP> &m)
+    { (*m._f) (o, m._a); return o; }
+};
+
+A &setw (A &, int);
+B<int> setw (int n)
+{
+  return B<int> (setw, n);
+}
+
+A x;
+
+void f ()
+{
+  x << setw (2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/cvt5.C b/gcc/testsuite/g++.old-deja/g++.brendan/cvt5.C
new file mode 100644
index 00000000000..5eeea6e6393
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/cvt5.C
@@ -0,0 +1,27 @@
+// GROUPS passed conversions
+// Build don't link:
+typedef unsigned long Array[3];
+
+void sample(const unsigned long (&an_array)[3]);
+
+class Sample
+  {
+ public:
+  void simple(const Array &an_array);
+  static void sample(const Array &an_array);
+  };
+
+class A
+  {
+ public:
+  Array array;
+  };
+
+  Sample s;
+
+  void simple(const A &a)
+    {
+    s.simple(a.array);
+    sample(a.array);
+    Sample::sample(a.array);
+    }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/def-args1.C b/gcc/testsuite/g++.old-deja/g++.brendan/def-args1.C
new file mode 100644
index 00000000000..55efc52e334
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/def-args1.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// PRMS Id: 10860
+class Beige
+{
+public:
+    static int yellow();
+    void white(int green = yellow());
+    void aqua(int green = Beige::yellow());
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/def-fns1.C b/gcc/testsuite/g++.old-deja/g++.brendan/def-fns1.C
new file mode 100644
index 00000000000..af9752693c7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/def-fns1.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed default-functions
+class dictionary {
+public:
+  dictionary (int);
+};
+
+class symbol {
+public:
+  symbol ();
+};
+
+// a default ctor should not be generated for hyphenation_language,
+// since a ctor has already been declared; if one is generated, there
+// will be an error about not enough args to the ctor for dictionary,
+// since dictionary only defines a ctor taking an int (it ALSO should
+// not get a default ctor)
+struct hyphenation_language {
+  symbol name;
+  dictionary exceptions;
+  hyphenation_language(symbol nm) : name(nm), exceptions(501) {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/delete1.C b/gcc/testsuite/g++.old-deja/g++.brendan/delete1.C
new file mode 100644
index 00000000000..816c3009d2e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/delete1.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed operator-delete
+/* ARM $5.3.4 */
+void f(char *p, char *q[], const char *r, const char *s[])
+{
+  delete 0;             /* illegal: non-pointer */// ERROR - .*expected pointer.*
+  delete (char*)0;      /* no effect */
+  delete p;
+  delete[] q;
+  delete[4] q;          /* ANSI forbids size arg */// ERROR -  anachronistic .*
+  delete r;             /* no longer illegal: const */
+  delete[] s;
+  delete[4] s;          /* ANSI forbids size arg */// ERROR -  anachronistic.*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/delete2.C b/gcc/testsuite/g++.old-deja/g++.brendan/delete2.C
new file mode 100644
index 00000000000..f2bacde1185
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/delete2.C
@@ -0,0 +1,25 @@
+// GROUPS passed operator-delete
+// Check that using the delete operator with a null pointer
+// is allowed (as called for by The Book, pg. 259)
+
+extern "C" void printf (char *, ...); 
+
+struct base {
+	int member;
+};
+
+base* bp;
+
+void test ()
+{
+	delete bp;
+}
+
+int main ()
+{
+	bp = (base *) 0;
+	test ();
+
+	printf ("PASS\n");
+	return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/dtors1.C b/gcc/testsuite/g++.old-deja/g++.brendan/dtors1.C
new file mode 100644
index 00000000000..dbbfa80f9f4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/dtors1.C
@@ -0,0 +1,56 @@
+// GROUPS passed destructors
+// Check that when an object of a derived class is (implicitly)
+// destructed (on exit from the block in which it is declared)
+// that the destructor for the base class also gets executed.
+//
+// (also check that this execution doesn't seg-fault)
+
+extern "C" void printf (char *, ...); 
+
+int derived_destructed;
+int base_destructed;
+
+struct base {
+  int base_data_member;
+
+  base()
+  {
+    base_data_member = 0x5e5e;
+  }
+  ~base()
+  {
+    base_destructed = 0x781f;
+  }
+};
+
+struct derived : public base {
+  int derived_data_member;
+
+  derived()
+  {
+    derived_data_member = 0xe5e5;
+  }
+  ~derived()
+  {
+    derived_destructed = 0xf178;
+  }
+};
+
+
+void test2 ();
+
+int main ()
+{
+	test2 ();
+	if ((base_destructed != 0x781f) || (derived_destructed != 0xf178))
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+}
+
+void test2 ()
+{
+	derived derived_object;
+
+	derived_object.derived_data_member = 99;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/dtors2.C b/gcc/testsuite/g++.old-deja/g++.brendan/dtors2.C
new file mode 100644
index 00000000000..511ab7f231c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/dtors2.C
@@ -0,0 +1,74 @@
+// GROUPS passed destructors
+// Check that virtual destructors work correctly.  Specifically,
+// check that when you destruct an object of a derived class for
+// which the base class had an explicitly declared virtual destructor
+// no infinite recursion occurs.
+//
+// Bug description:
+//    The generated g++ code apparently calls the base class destructor via
+//    the virtual table, rather than directly. This, of course, results in the
+//    infinite recursion.
+
+extern "C" void printf (char *, ...); 
+
+int errors = 0;
+
+struct base {
+	int member;
+	base();
+	virtual ~base();
+};
+  
+base::base()
+{
+}
+
+base::~base()
+{
+}
+
+struct derived : public base
+{
+	int member;
+	derived();
+	~derived();
+};
+  
+derived::derived() : base()
+{
+}
+
+int derived_destructor_calls = 0;
+
+extern void exit (int);
+
+derived::~derived()
+{
+	if (++derived_destructor_calls > 2)
+		errors++;
+}
+
+void test ();
+
+int main ()
+{
+	test ();
+
+	if (errors)
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+
+	return 0;
+}
+
+base* bp;
+
+void test()
+{
+	derived a;
+
+	a.member = 99;
+	bp = new derived;
+	delete bp;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/dtors3.C b/gcc/testsuite/g++.old-deja/g++.brendan/dtors3.C
new file mode 100644
index 00000000000..a1ca853cf91
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/dtors3.C
@@ -0,0 +1,66 @@
+// GROUPS passed destructors
+// Check that member and base classes get properly destructed
+// when an object of a derived class is destructed via a pointer
+// to it which only has a "compile-time" type of "pointer-to-base".
+//
+// Note that in order for this test to work properly, the destructor
+// for the base class should be explicitly declared to be virtual.
+
+extern "C" void printf (char *, ...); 
+
+int member_destructor_calls = 0;
+int middle_destructor_calls = 0;
+
+struct member_type {
+	int data_member;
+	member_type () {}
+	~member_type ();
+};
+
+struct base {
+	int data_member;
+	base () {}
+	virtual ~base ();
+};
+
+struct middle : public base {
+	member_type member1;
+	member_type member2;
+	middle () {}
+	~middle ();		// should be implicitly virtual
+};
+
+struct derived : public middle {
+	member_type member1;
+	member_type member2;
+	//~derived () {}
+};
+
+int main ()
+{
+	base* bp = new derived;
+	delete bp;
+	derived *dp = new derived;
+	delete dp;
+
+	if ((member_destructor_calls != 8) || (middle_destructor_calls != 2))
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+
+	return 0;
+}
+
+member_type::~member_type ()
+{
+	member_destructor_calls++;
+}
+
+base::~base ()
+{
+}
+
+middle::~middle ()
+{
+	middle_destructor_calls++;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/eh1.C b/gcc/testsuite/g++.old-deja/g++.brendan/eh1.C
new file mode 100644
index 00000000000..a6683060c25
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/eh1.C
@@ -0,0 +1,62 @@
+// Special g++ Options: -O
+// PRMS Id: 10776
+
+extern "C" void printf (char *, ...);
+
+class Foo 
+{
+  public:
+    Foo(int n) : n_(n) { }
+    int f() { return n_; }
+    
+    int badTest();
+    int goodTest();
+    
+  private:
+
+    int n_;
+};
+
+int Foo::badTest()
+{
+    try {
+	throw int(99);
+    }
+
+    catch (int &i) {
+	n_ = 16;
+    }
+
+    return n_;
+        // On the sparc, the return will use a ld [%l0],%i0 instruction.
+        // However %l0 was clobbered at the end of the catch block.  It was
+        // used to do an indirect call.
+}
+
+
+int Foo::goodTest()
+{
+    int	n;
+
+    try {
+	throw int(99);
+    }
+
+    catch (int &i) {
+	n = 16;
+    }
+
+    return n_;
+        // The return will use a ld [%l2],%i0 instruction.  Since %l2
+        // contains the "this" pointer this works.
+}
+
+int main() 
+{
+    Foo foo(5);
+    foo.goodTest();
+    foo.badTest();
+
+    // the badTest will have failed
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum-clash.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum-clash.C
new file mode 100644
index 00000000000..68639a1e143
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum-clash.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed arm
+enum color {red, yellow, green=20, blue};
+color c = 1;	// this should be an error// ERROR - .*
+int i = yellow;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum1.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum1.C
new file mode 100644
index 00000000000..9cc3ed8cf85
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum1.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed enums
+class foo {
+public:
+  enum bar { baz = 1, bat = 7 };
+};
+
+class derv : public foo { };
+
+int main()
+{
+  foo::bar x = foo::baz;
+  derv::bar y = derv::bat;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum10.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum10.C
new file mode 100644
index 00000000000..5c955d3587f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum10.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed enums
+class Type
+{
+	public:
+
+		enum name
+		{
+			A
+		};
+};
+
+class A
+{
+};
+
+class B: public A
+{
+	public:
+		B();
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum11.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum11.C
new file mode 100644
index 00000000000..7705aa36bd6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum11.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed enums
+class X
+{
+    enum
+    {
+       oneMask = 0x0000FFFF,
+       twoMask  = 0x000F0000,
+       thiMask = 0xFFF00000,
+    }; // ERROR - comma
+    unsigned int foo;
+
+public:
+    X (int) : foo (oneMask | twoMask ) {}               // No warning
+    X ()    : foo (oneMask | twoMask | thiMask) {}      // Warning
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum12.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum12.C
new file mode 100644
index 00000000000..7d4eb7d0c42
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum12.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed enums
+enum Bool { False, True };
+
+enum Bool object;
+
+struct S
+{
+  Bool field:1;
+
+  void copy_enum_bit_field () const { object = field; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum13.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum13.C
new file mode 100644
index 00000000000..ea6dfa71f23
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum13.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed enums
+enum COLOR { red, green, blue };
+ 
+struct S {
+    COLOR       color:2;
+};
+ 
+COLOR color;
+S object;
+ 
+void fubar ()
+{
+    color = object.color;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum14.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum14.C
new file mode 100644
index 00000000000..192a2b4c468
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum14.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// Special g++ Options: -fshort-enums
+// GROUPS passed enums
+  enum E { A = 0x80000000 };
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum2.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum2.C
new file mode 100644
index 00000000000..1c5c50b8dfc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum2.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed enums
+class foo {
+public:
+  enum bar { baz = 1, bat = 7 };
+};
+
+class foo2 {
+public:
+  enum bar2 { baz2 = 1, bat2 = 7 };
+};
+
+class derv : public foo, public foo2 { };
+
+int main()
+{
+  foo::bar x = foo::baz;
+  derv::bar2 y = derv::bat2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum3.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum3.C
new file mode 100644
index 00000000000..38b7d3cdae8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum3.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed enums
+enum foo
+{
+  x = 0
+};
+
+enum bar
+{
+  // this used to say `x' wasn't a constant, because build_enumerator
+  // was getting the value of x wrapped around a NOP_EXPR.  It now
+  // strips them off before working on it, so we shouldn't get any
+  // errors  for this.
+  y = (x + 0x0000)
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum4.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum4.C
new file mode 100644
index 00000000000..826ccd3b9f0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum4.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed enums
+class X {
+public:
+  enum { a };
+};
+
+enum { b = 1 };
+enum ok {  y = b };
+enum notok { z = X::a };
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum5.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum5.C
new file mode 100644
index 00000000000..32134eff85c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum5.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed enums
+enum Thing { FIRST, SECOND } ;
+
+int main()
+{
+    Thing x = FIRST ;
+    x = 27 ;          // this line should be a type error.// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum6.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum6.C
new file mode 100644
index 00000000000..8c5c9ad9299
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum6.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed enums
+class X {
+  private:
+    enum E1 {a1, b1}; // ERROR - private
+  public:
+    enum E2 {a2, b2};
+    };
+
+void h(X* p) {
+    X::E2 e2;
+    int x2 = X::a2;
+
+    X::E1 e1;
+    int x1 = X::a1;  // ERROR - within this context
+    }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum7.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum7.C
new file mode 100644
index 00000000000..5a397d7f361
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum7.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed enums
+enum color { red, green, blue, orange, brown };
+
+struct s {
+      enum color      field:2; // ERROR - too small
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum8.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum8.C
new file mode 100644
index 00000000000..d9380ad09ef
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum8.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed enums
+class foo1
+{
+ public:
+   enum foo1_enum
+   {
+      ENUM1,
+      ENUM2,
+   }; // ERROR - comma
+};
+
+   
+class foo2 
+{
+ private:
+   enum foo1::foo1_enum	Enum;
+};
+
+
+class foo3
+{
+ private:
+   foo1::foo1_enum Enum;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/enum9.C b/gcc/testsuite/g++.old-deja/g++.brendan/enum9.C
new file mode 100644
index 00000000000..f04deb13a83
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/enum9.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed enums
+enum fig {
+    figgy,
+    pudding,
+}; // ERROR - comma
+
+class X {
+public:
+    static fig (*open)(void *thing, const char *filename);
+    static fig (*parse)(void *thing);
+};
+
+enum fig (*X::open)(void *thing, const char *filename) = 0;
+fig (*X::parse)(void *thing) = 0;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg1.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg1.C
new file mode 100644
index 00000000000..9450d7671c6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg1.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed error-messages
+class A { };
+
+int i = A::_ter;// ERROR -  ._ter.*
+int j = A::term;// ERROR -  .term.*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg10.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg10.C
new file mode 100644
index 00000000000..24ddcaa1661
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg10.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed error-messages
+class foo {
+public:
+  virtual static int f () = 0;// ERROR -  member `f' cannot be declared both virtual and static.*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg11.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg11.C
new file mode 100644
index 00000000000..de5ed8a1316
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg11.C
@@ -0,0 +1,3 @@
+// Build don't link: 
+// GROUPS passed error-messages
+void foo (mutable int x);// ERROR -  non-member `x' cannot be declared `mutable'.*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg12.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg12.C
new file mode 100644
index 00000000000..0b59ba0c8da
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg12.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed error-messages
+class foo {
+public:
+  friend mutable int x ();// ERROR -  non-object member `x' cannot be declared `mutable'
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg2.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg2.C
new file mode 100644
index 00000000000..0bfb4c22414
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg2.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed error-messages
+typedef void (*pfv)(double, double);
+extern "C" typedef void (*pfv)(double, double);// ERROR -  multiple.*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg3.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg3.C
new file mode 100644
index 00000000000..1d115e6c46a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg3.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed error-messages
+#include <fstream.h>
+#include <iomanip.h>
+
+// This error should not appear:
+// bug.C: In method `test::test(const class test &)':
+// bug.C:8: field `' not in immediate context
+
+class test{
+public:
+	int	flags;
+	test()	{};
+	};
+
+int main()
+
+{
+return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg4.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg4.C
new file mode 100644
index 00000000000..72f6150a882
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg4.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed error-messages
+class X {
+public:
+    static int x;// ERROR -  previous.*
+    static int y;// ERROR -  previous.*
+};
+
+unsigned X::x;// ERROR -  conflict.*
+unsigned X::y;// ERROR -  conflict.*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg5.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg5.C
new file mode 100644
index 00000000000..37b956c568f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg5.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed error-messages
+class foo {};
+~foo () {}// ERROR -  destructors must be member functions.*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg6.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg6.C
new file mode 100644
index 00000000000..ce60f0d4567
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg6.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed error-messages
+class foo {
+public:
+  ~bar () {}// ERROR -  destructor `bar' must match class name `foo'.*
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg7.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg7.C
new file mode 100644
index 00000000000..5971806fa46
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg7.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed error-messages
+class foo {
+public:
+  volatile int () {}// ERROR - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg8.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg8.C
new file mode 100644
index 00000000000..a2ad4df947d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg8.C
@@ -0,0 +1,3 @@
+// Build don't link: 
+// GROUPS passed error-messages
+operator int ;// ERROR -  declaration of `operator int' as non-function.*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/err-msg9.C b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg9.C
new file mode 100644
index 00000000000..0714de696cc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/err-msg9.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed error-messages
+class foo {
+public:
+  int ~foo ();// ERROR -  return type specification for destructor invalid.*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/explicit1.C b/gcc/testsuite/g++.old-deja/g++.brendan/explicit1.C
new file mode 100644
index 00000000000..148155e2f69
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/explicit1.C
@@ -0,0 +1,4 @@
+// $7.1.2 disallows explicit on anything but declarations of
+// constructors ... including friends.
+class foo { public: foo(); };
+class bar { public: friend explicit foo::foo(); }; // ERROR - explicit friend
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/friend1.C b/gcc/testsuite/g++.old-deja/g++.brendan/friend1.C
new file mode 100644
index 00000000000..9aea4602c8f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/friend1.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed friends
+class A
+{
+private:
+  A () {}
+
+friend struct B;
+};
+
+class B
+{
+public:
+  A a;
+};
+
+B b;
+
+int main () {}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/friend2.C b/gcc/testsuite/g++.old-deja/g++.brendan/friend2.C
new file mode 100644
index 00000000000..5b1333f7b80
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/friend2.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed friends
+class X {
+  int a;
+friend void friend_set (X*, int);
+};
+
+void friend_set (X *p, int i) { p->a = i; }
+
+void f()
+{
+  X obj;
+  friend_set (&obj, 10);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/friend3.C b/gcc/testsuite/g++.old-deja/g++.brendan/friend3.C
new file mode 100644
index 00000000000..1fa48a8c527
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/friend3.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// GROUPS passed friends
+class B {
+
+   friend class A;
+
+   enum {
+      bEnum = 1,
+   }; // ERROR - comma
+
+   int bArray[ bEnum ];
+
+public:
+   void bFunction(int arg[ bEnum ]);
+};
+
+
+class A {
+   int aMember;
+
+public:
+   void aFunction(int a[B::bEnum])
+   {
+      B b;
+      b.bArray[ B::bEnum ] = aMember;
+   }
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/friend4.C b/gcc/testsuite/g++.old-deja/g++.brendan/friend4.C
new file mode 100644
index 00000000000..f19d81a9d0a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/friend4.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed friends
+// do_friend should complain that foo was declared as a friend of
+// A before A was defined
+struct A;
+struct B { friend A::foo (); };// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/groff1.C b/gcc/testsuite/g++.old-deja/g++.brendan/groff1.C
new file mode 100644
index 00000000000..179ef30ab04
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/groff1.C
@@ -0,0 +1,33 @@
+// GROUPS passed groff
+/* This should compile properly with the new overloading scheme.  */
+
+extern "C" void printf (const char *, ...);
+extern "C" void exit (int);
+
+int win = 0;
+
+class symbol
+{
+public:
+  symbol(const char *p, int how = 0) {}
+  symbol() {}
+};
+
+class dictionary
+{
+public:
+  void *lookup(symbol s, void *v=0) { win = 1; }
+  void *lookup(const char *) {}
+};
+
+int main()
+{
+  char buf[2048];
+  dictionary exceptions;
+  unsigned char *tem = new unsigned char[19 + 1];
+
+  exceptions.lookup (symbol (buf), tem);
+
+  printf (win ? "PASS\n" : "FAIL\n");
+  exit (! win);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init1.C b/gcc/testsuite/g++.old-deja/g++.brendan/init1.C
new file mode 100644
index 00000000000..4396906ed32
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init1.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed initialization
+  class Thing{
+  private:
+	  int x,y;
+  public:
+	  Thing (int v, int q) { x = v; q = y; }
+	  void doit(int);
+  };
+
+  Thing t(18,19);
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init10.C b/gcc/testsuite/g++.old-deja/g++.brendan/init10.C
new file mode 100644
index 00000000000..45b29853afd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init10.C
@@ -0,0 +1,3 @@
+// Build don't link: 
+// GROUPS passed initialization
+struct { int :0; } a;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init11.C b/gcc/testsuite/g++.old-deja/g++.brendan/init11.C
new file mode 100644
index 00000000000..69fd77c7c71
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init11.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed initialization
+struct String {
+  char * string;
+  String(const char* st);  
+};
+
+extern char array [];
+static String sub = array;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init12.C b/gcc/testsuite/g++.old-deja/g++.brendan/init12.C
new file mode 100644
index 00000000000..7d7c13a47e3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init12.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed array-bindings
+char * bob();
+
+int main()
+{
+    char a[1][2];
+    a[0] = bob();// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init13.C b/gcc/testsuite/g++.old-deja/g++.brendan/init13.C
new file mode 100644
index 00000000000..41f0fcf68bf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init13.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed initialization
+struct A {
+  operator int ();
+};
+ 
+int i = A();
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init2.C b/gcc/testsuite/g++.old-deja/g++.brendan/init2.C
new file mode 100644
index 00000000000..a9ec6f3bea6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init2.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed initialization
+// this should give an error in require_instantiated_type about not
+// being allowed to have an initializer list in an argument list.
+int f(int a = {1});// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init3.C b/gcc/testsuite/g++.old-deja/g++.brendan/init3.C
new file mode 100644
index 00000000000..b86c2c7e792
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init3.C
@@ -0,0 +1,38 @@
+// GROUPS passed initialization
+// p2766: Make sure that members are initialized in order of declaration
+// in the class, not in order of specification in the mem-initializer list.
+
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+int count = 0;
+
+void die () { printf ("FAIL\n"); exit (1); }
+
+class bar1 {
+public:
+  bar1 (int) { if (count != 0) die (); count = 1; }
+};
+
+class bar2
+{
+public:
+  bar2 (int) { if (count != 1) die (); count = 2; }
+};
+
+class foo
+{
+public:
+  bar1 a;
+  bar2 b;
+  foo (int, int);
+};
+
+// bar1 should get built before bar2
+foo::foo (int x, int y) : b(x), a(y) {}
+
+int main()
+{
+  foo f (1, 2);
+  printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init4.C b/gcc/testsuite/g++.old-deja/g++.brendan/init4.C
new file mode 100644
index 00000000000..c1d359281e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init4.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed initialization
+struct CharList { int i; };
+
+const CharList& terminals = { 1 };// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init5.C b/gcc/testsuite/g++.old-deja/g++.brendan/init5.C
new file mode 100644
index 00000000000..112dcacbb94
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init5.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed initialization
+int main( int argc, char**argv, char** envp ){
+    char* domain = argv[1];
+    domain = domain? (char*)"component" : domain;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init6.C b/gcc/testsuite/g++.old-deja/g++.brendan/init6.C
new file mode 100644
index 00000000000..e49758adf1a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init6.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed initialization
+class Tag {
+public:
+	Tag(int i):value(i){}
+	int value;
+};
+
+extern const Tag myTag;
+extern const Tag myTag=9;
+
+// The compiler should not issue an error on this line; expand_static_init
+// should be checking that there's no initializer for this line, and thus
+// doesn't need to produce an error.
+extern const Tag myTag;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init7.C b/gcc/testsuite/g++.old-deja/g++.brendan/init7.C
new file mode 100644
index 00000000000..033da8f9fe8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init7.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed initialization
+struct myChoiceList
+{
+	int bla;
+	int blubb;
+	int brummbrumm;
+};
+
+extern const myChoiceList foo;
+
+extern const myChoiceList foo = {1,1,1};
+
+// finish_decl should have an exclusion so an error is not produced
+// for this line.
+extern const myChoiceList foo;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init8.C b/gcc/testsuite/g++.old-deja/g++.brendan/init8.C
new file mode 100644
index 00000000000..4818a41ab72
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init8.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed initialization
+class A
+{
+public:
+    A(const A & a) : i_member(a.i_member)
+    {
+    }
+    A(const int & i) : i_member(i)
+    {
+    }
+    union
+    {
+        int i_member;
+    };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/init9.C b/gcc/testsuite/g++.old-deja/g++.brendan/init9.C
new file mode 100644
index 00000000000..bad6416ef23
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/init9.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed initialization
+int FALSE = 0;
+class X {
+public:
+  static int FALSE;
+};
+
+// The compiler should NOT complain about redeclaration of the global
+// `FALSE' with this declaration...grokvardecl shouldn't be doing that.
+int X::FALSE = 0;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/label1.C b/gcc/testsuite/g++.old-deja/g++.brendan/label1.C
new file mode 100644
index 00000000000..ff0b87c3097
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/label1.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed labels
+// it should only give 1 error, about using an undefined label
+int main(void) { goto dummy; }// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/label2.C b/gcc/testsuite/g++.old-deja/g++.brendan/label2.C
new file mode 100644
index 00000000000..bce21125d55
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/label2.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed labels
+class X {
+public:
+    X();
+};
+void foo ()
+{
+X:  ::abort();
+    goto X;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/line1.C b/gcc/testsuite/g++.old-deja/g++.brendan/line1.C
new file mode 100644
index 00000000000..d76832e76c4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/line1.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed error-messages
+typedef struct s S;// ERROR -  previous.*
+struct S { int member:1; };  // the lineno for this should be 2, not 0// ERROR -  conflicting types.*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc1.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc1.C
new file mode 100644
index 00000000000..666ec256fb2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc1.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed miscellaneous-bugs
+int main( int argc, char**argv, char** envp ){
+    char* domain = argv[1];
+    domain = domain? (char*)"component" : domain;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc10.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc10.C
new file mode 100644
index 00000000000..4d96926ccf8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc10.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed miscellaneous
+// The compiler shouldn't give a `invalid operands to binary +' for this
+// case.
+enum flag { OFF, ON };
+enum BOOL { FALSE = (enum flag) 0, TRUE };
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc11.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc11.C
new file mode 100644
index 00000000000..043f6a5493e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc11.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed miscellaneous
+// This should not complain about A::f being abstract.
+struct	A
+{
+	virtual int f() = 0;
+};
+
+struct	B : virtual A
+{
+	virtual int f()		{	return 1;	}
+	virtual int g() = 0;
+};
+
+struct	C: B
+{
+	int g()			{	return 2;	}
+};
+
+C	c;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc12.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc12.C
new file mode 100644
index 00000000000..73db9bfccd4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc12.C
@@ -0,0 +1,16 @@
+// GROUPS passed miscellaneous
+extern "C" void exit (int);
+extern "C" int printf (char *, ...);
+
+/* Make sure cp-lex.c handles these properly--if this links, that means
+   it emitted the strings instead of __FUNCTION__.0, etc.  */
+
+int
+main()
+{
+  char *a = __FUNCTION__;
+  char *b = __PRETTY_FUNCTION__;
+
+  printf ("PASS\n");
+  exit (0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc13.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc13.C
new file mode 100644
index 00000000000..57292a292cb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc13.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed miscellaneous-bugs
+// This should only give warnings from duplicate_decls; it should not get
+// errors from push_overloaded_decl as well.
+
+extern "C"
+{
+  long unsigned int strlen(char*);// ERROR -  warning// ERROR -  warning.*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc14.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc14.C
new file mode 100644
index 00000000000..024566fc2c8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc14.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed miscellaneous-bugs
+class X {
+public:
+    enum e {
+	New,// ERROR -  conflicts with other.*
+    }; // ERROR - comma
+
+    static int New(int);// ERROR -  declaration.*
+};
+
+int main() {}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc15.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc15.C
new file mode 100644
index 00000000000..e4dd53e0994
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc15.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed miscellaneous-bugs
+// we shouldn't get any warnings or errors for this code
+struct A {
+        int     aa;
+};
+struct B : public A {
+};
+struct C : public A {
+};
+struct D : public C, public B {
+        void fun() { C::aa = 10; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc16.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc16.C
new file mode 100644
index 00000000000..15e3946a0d3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc16.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed miscellaneous-bugs
+// Using a typedef causes a compiler error
+typedef unsigned int Uint32;
+
+// Using a define so that there isn't a typedef works OK.
+//#define Uint32 unsigned int
+
+Uint32 func0(Uint32, Uint32)
+{
+   return 0;
+}
+
+Uint32 func1(Uint32, Uint32)
+{
+   return 1;
+}
+
+Uint32 (*mf[])(Uint32, Uint32) = {func0, func1};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc17.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc17.C
new file mode 100644
index 00000000000..987618f9789
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc17.C
@@ -0,0 +1,36 @@
+// Build don't link: 
+// GROUPS passed miscellaneous-bugs
+typedef int va_list;
+class ostream;
+class String {
+public:
+operator const char *() const;
+};
+class FwtErrorManager {
+public:
+    FwtErrorManager(ostream& err, const char *program);
+public:
+    void form(const char *format, ...);
+protected:
+    const String _program;	 
+private:
+    FwtErrorManager(const FwtErrorManager&);
+    void operator=(const FwtErrorManager&);
+};
+class FwtProgram: public FwtErrorManager {
+public:
+    FwtProgram();	 
+};
+class FwtArgOptions { };
+class FwtStdProgram: public FwtProgram, public FwtArgOptions {
+public:
+    FwtStdProgram();	 
+    void usage_if_not_complete();
+};
+void
+FwtStdProgram::usage_if_not_complete()
+{
+	FwtStdProgram& thisp = *this;
+	thisp.form("%s: error, there were unrecognized options",
+		   (char *) FwtErrorManager::_program);// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc2.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc2.C
new file mode 100644
index 00000000000..d9aa99bbf78
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc2.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed miscellaneous-bugs
+// Should be fixed by:
+// Sun Jun 13 12:55:22 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+//
+//	* cp-decl.c (grokvardecl): Don't complain about duplicate
+//	definitions of `extern "C"' declarations (parallelize it with how
+//	regular `extern' decls are handled).
+
+extern "C" double  _MaXdOuB, _MiNdOuB;
+extern "C" double  _MaXdOuB, _MiNdOuB;	// no error should be emitted for this
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc3.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc3.C
new file mode 100644
index 00000000000..d632cb733f9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc3.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed miscellaneous-bugs
+// The compiler should not error about taking the addr of main in this example.
+class fred {
+private:
+  void main () {
+  }
+public:
+  fred ( ) {
+    &fred::main;
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc4.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc4.C
new file mode 100644
index 00000000000..93aea92d31f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc4.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed miscellaneous
+// This should not emit an error about A::~A() being redefined; we
+// should check that it is a pure virtual.
+class A {
+public:
+    virtual ~A() = 0;
+};
+
+A::~A() {}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc5.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc5.C
new file mode 100644
index 00000000000..05eeed61e1e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc5.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed miscellaneous
+class A {
+    static A aa[2];
+};
+
+A A::aa[2]; // should be completely legal
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc6.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc6.C
new file mode 100644
index 00000000000..b05c1f1da54
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc6.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed miscellaneous
+// test that use of `inline' is forbidden when it should be
+inline int i;// ERROR - .*
+struct c { inline int i; };// ERROR - .*
+int foo (inline int i);// ERROR - .*
+inline class c; // ERROR - inline
+inline typedef int t; // ERROR - inline
+class d { inline friend class c; }; // ERROR - inline
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc7.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc7.C
new file mode 100644
index 00000000000..af07d6f6d13
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc7.C
@@ -0,0 +1,15 @@
+// GROUPS passed miscellaneous
+extern "C" void printf (char *, ...);
+
+int main()
+{
+  int i = 0;
+  // Make sure build_unary_op correctly computes this.
+  int *pi = &(++i);
+  *pi = 4;
+
+  if (i != 4)
+    printf ("FAIL\n");
+  else
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc8.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc8.C
new file mode 100644
index 00000000000..b2aa92f1ee8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc8.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed miscellaneous
+// used to say invalid lvalue in `&\'
+class foo {
+        int     a;
+    public:
+        foo(int a);
+};
+
+foo::foo(int a)
+{
+    foo::a=a;
+}
+
+int main()
+{
+foo     obj(4);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/misc9.C b/gcc/testsuite/g++.old-deja/g++.brendan/misc9.C
new file mode 100644
index 00000000000..88071c6e04a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/misc9.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// GROUPS passed miscellaneous
+//The program listed below produces the following error during compilation:
+//   % g++ bug17.cc
+//   bug17.cc: In method `class Y& Y::operator = (const class Y&)':
+//   bug17.cc:18: invalid use of non-lvalue array
+
+class X {
+public:
+   X& operator=(const X&) { return *this; }
+};
+
+struct S {
+   char c[10];
+   X x;
+};
+
+class Y {
+   S s;
+public:
+   const S& f() const { return s; }
+
+   Y& operator=(const Y& _Y) {
+      s = _Y.s;    // this line compiles
+      s = _Y.f();  // this line does not compile
+      return *this;
+   }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/mutable1.C b/gcc/testsuite/g++.old-deja/g++.brendan/mutable1.C
new file mode 100644
index 00000000000..79157b7607c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/mutable1.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed mutable
+class foo;
+class bar {
+  mutable foo const *foobar;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest1.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest1.C
new file mode 100644
index 00000000000..32aab3ee9c2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest1.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+int x;
+class enclose {
+public:
+  int x;
+
+  class inner {
+  public:
+    void f (int i) {
+      x = i;// ERROR - .*
+    }
+  };
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest10.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest10.C
new file mode 100644
index 00000000000..d22e3075d5e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest10.C
@@ -0,0 +1,30 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+class A
+	{
+	public:
+		class B
+			{
+			public:
+				int f ();
+				void g (int);
+			private:
+				int b;
+			};
+	};
+
+int A::B::f ()
+	{
+	int val=b;
+	return val;
+	}
+
+void A::B::g (int val)
+	{
+	b = val;
+	}
+
+
+int main ()
+	{
+	}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest11.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest11.C
new file mode 100644
index 00000000000..4a57b383858
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest11.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+class A {
+  int x;
+
+  struct B {
+    int x;
+  };
+  struct C {
+    int bug (A::B &y);
+  };
+};
+
+int
+A::C::bug (A::B &y)
+{
+  return y.x;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest12.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest12.C
new file mode 100644
index 00000000000..19286db1dc0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest12.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+struct enclose {
+  class nested;
+  nested *nptr;
+  class nested {
+    int x;
+  };
+  void f();
+};
+
+void enclose::f()
+{
+  nptr = new enclose::nested;  
+}
+
+void g()
+{
+  enclose obj;
+  obj.nptr = new enclose::nested;  
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest13.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest13.C
new file mode 100644
index 00000000000..354e7bc35be
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest13.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+// The bug here is that wer'e getting a message about inner not
+// being a basetype itself.  I think it's because it's being
+// compared as the "inner" we knew about when it was forward-declared,
+// versus the "inner" we know about when it *has* been defined.
+
+class temp
+{
+public:
+        struct inner;
+        inner *trump()
+        {
+                return (tt);
+        }
+        struct inner
+        {
+                int ll;
+        }*tt;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest15.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest15.C
new file mode 100644
index 00000000000..4a696af4dc2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest15.C
@@ -0,0 +1,37 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+class BDDHeap {
+public:
+    BDDHeap();
+    BDDHeap(const BDDHeap&);
+
+    class Page {
+    public:
+	int i;
+    };
+    struct Pointer {
+	Page *page;
+	unsigned index;
+
+	Pointer();
+	Pointer(const BDDHeap& heap);
+    };
+
+    struct Half {
+	struct {
+	    Page *top;
+	    Page **tail;
+	} inuse;
+
+	Half();
+    };
+
+    Half half[2];
+    unsigned halfspace;
+};
+
+inline
+BDDHeap::Pointer::Pointer(const BDDHeap& heap):
+page(heap.half[heap.halfspace].inuse.top),
+index(0)
+{ }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest16.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest16.C
new file mode 100644
index 00000000000..920ea0b5de5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest16.C
@@ -0,0 +1,41 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+class BDDHeap {
+public:
+    BDDHeap();
+    BDDHeap(const BDDHeap&);
+
+    class Page {
+    public:
+	int i;
+    };
+    struct Pointer {
+	Page *page;
+	unsigned index;
+
+	Pointer();
+	Pointer(const BDDHeap& heap);
+    };
+
+    struct Half {
+	struct {
+	    Page *top;
+	    Page **tail;
+	} inuse;
+
+	Half();
+    };
+
+    Half half[2];
+    unsigned halfspace;
+};
+
+inline
+BDDHeap::Pointer::Pointer(const BDDHeap& heap):
+page(0),
+index(0)
+{
+    Page *x = heap.half[heap.halfspace].inuse.top;
+    page = x;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest17.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest17.C
new file mode 100644
index 00000000000..f61c49ee9f5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest17.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+class T {
+public:
+    typedef int I;
+    class Y {int y;};
+    typedef Y Z;
+};
+
+T::I i;
+T::Y y;
+T::Z z;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest18.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest18.C
new file mode 100644
index 00000000000..e41def435f9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest18.C
@@ -0,0 +1,31 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+// This is the first line of file ||t2.C||.
+
+// This code demonstrates what appears to be a bug with nested types.
+// In C++, nested typedefs are not supposed to be visible outside
+// their class scopes but they apparently are in gcc 2.4.5.  This code
+// compiles fine in AT&T cfront 3.0.1, but will not compile with gcc.
+
+// If this class does not precede String, then the code will compile.
+
+class Another {
+public:
+    typedef int Length;
+};
+
+// If String does not define typedef int Length, then the code will
+// compile.
+
+class String {
+public:
+    typedef int Length;		// remove this and it will compile fine
+
+    int foo(Length length) const;
+};
+
+int String::foo(Length length) const {
+    return length;
+}
+
+// File ||t2.C|| ends here.
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest19.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest19.C
new file mode 100644
index 00000000000..efa7ac5ee48
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest19.C
@@ -0,0 +1,40 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+// This is the first line of file ||t3.C||.
+
+// This code demonstrates a variation of the same problem with nested
+// types.  In C++, nested typedefs are not supposed to be visible
+// outside their class scopes but they apparently are in gcc 2.4.5.
+// This code compiles fine in AT&T cfront 3.0.1, but gcc rejects it
+// with the messages given below.
+
+// If this class does not precede Expr, then the code will compile.
+
+class Another {
+public:
+    typedef int Boolean;
+    enum { FALSE, TRUE };
+};
+
+// If Expr does not define typedef int Boolean, then the code will
+// compile.
+
+class Expr {
+public:
+    typedef int Boolean;
+    enum { FALSE, TRUE };
+    void foo();
+    void call_something_with(Boolean);
+};
+
+// t3.C: In method `void  Expr::foo ()':
+//   t3.C:36: uninitialized const `Boolean'
+//   t3.C:36: parse error before `='
+//   t3.C:37: `argument' undeclared (first use this function)
+//   t3.C:37: (Each undeclared identifier is reported only once
+//   t3.C:37: for each function it appears in.)
+
+void Expr::foo() {
+    const Boolean argument = TRUE;
+    call_something_with(argument);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest2.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest2.C
new file mode 100644
index 00000000000..4b55245e5f8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest2.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+class A {
+protected:
+  class B {
+  public:
+    ~B();
+  private:
+    float _datum;
+  };
+private:
+  B *_b;
+};
+
+A::B::~B()
+{
+  _datum = 8.0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest20.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest20.C
new file mode 100644
index 00000000000..297b08af825
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest20.C
@@ -0,0 +1,30 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+// This is the first line of file ||t5.C||.
+
+// This code initializing an unnamed union inside a class appears to
+// be legal C++ input and compiles fine with AT&T cfront 3.0.1, but
+// gcc 2.4.5 complains about multiple initializations of the same
+// member.
+
+class Expr {
+public:
+    enum Type { undefined, slong, ulong, ldouble };
+    Expr();
+    Expr(Type type, const Expr* initializer);
+private:
+    Type type_;
+    union {
+	long slong_;
+	unsigned long ulong_;
+	long double ldouble_;
+    };
+};
+
+// Construct an undefined expression.
+
+Expr::Expr()
+    :
+    type_(undefined),
+    slong_(-1)
+{}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest21.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest21.C
new file mode 100644
index 00000000000..f32166d9ad2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest21.C
@@ -0,0 +1,95 @@
+// GROUPS passed nested-classes
+#include <iostream.h>
+#include <stdio.h>
+
+static char output[1024];
+
+class BDDRetrace {
+public:
+    class Dump {
+    public:
+	virtual Dump& operator<<(char c) = 0;
+	virtual Dump& operator<<(int i) = 0;
+	virtual Dump& operator<<(double r) = 0;
+    };
+
+    class Dump1: public Dump {
+    public:
+	Dump& operator<<(char c);
+	Dump& operator<<(int i);
+	Dump& operator<<(double r);
+    };
+};
+
+class Dump2: public BDDRetrace::Dump {
+public:
+    BDDRetrace::Dump& operator<<(char c);
+    BDDRetrace::Dump& operator<<(int i);
+    BDDRetrace::Dump& operator<<(double r);
+};
+
+BDDRetrace::Dump&
+BDDRetrace::Dump1::operator<<(char c)
+{ char tempout[1024];
+  sprintf (tempout, "%s%s%c", output, "1-", c);
+  strcpy (output, tempout);
+  return *this;
+}
+
+BDDRetrace::Dump&
+BDDRetrace::Dump1::operator<<(int i)
+{ char tempout[1024];
+  sprintf (tempout, "%s%s%d", output, "1-", i);
+  strcpy (output, tempout);
+  return *this; }
+
+BDDRetrace::Dump&
+BDDRetrace::Dump1::operator<<(double r)
+{ char tempout[1024];
+  sprintf (tempout, "%s%s%1.0f", output, "1-", r);
+  strcpy (output, tempout);
+  return *this; }
+
+BDDRetrace::Dump&
+Dump2::operator<<(char c)
+{ char tempout[1024];
+  sprintf (tempout, "%s%s%c", output, "2-", c);
+  strcpy (output, tempout);
+  return *this; }
+
+BDDRetrace::Dump&
+Dump2::operator<<(int i)
+{ char tempout[1024];
+  sprintf (tempout, "%s%s%d", output, "2-", i);
+  strcpy (output, tempout);
+  return *this; }
+
+BDDRetrace::Dump&
+Dump2::operator<<(double r)
+{ char tempout[1024];
+  sprintf (tempout, "%s%s%1.0f", output, "2-", r);
+  strcpy (output, tempout);
+  return *this; }
+
+int main()
+{
+    BDDRetrace::Dump1 d1;
+    Dump2 d2;
+
+    sprintf (output, " ");
+
+    d1 << 'a';
+    d1 << 1;
+    d1 << 1.0;
+
+    d2 << 'a';
+    d2 << 1;
+    d2 << 1.0;
+
+    if (strcmp (output, " 1-a1-11-12-a2-12-1") == 0)
+      printf ("PASS\n");
+    else
+      printf ("FAIL\n");
+
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest22.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest22.C
new file mode 100644
index 00000000000..cd26c34d582
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest22.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+class foo {
+public:
+   typedef int bar;
+   foo::bar    fb; // this line causes a syntax error!
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest23.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest23.C
new file mode 100644
index 00000000000..e18398bf3fb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest23.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+class CS {
+public:
+    class PS {
+    };
+};
+
+class NCS: public CS {
+public:
+    class S: public PS {
+    };
+};
+
+int i;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest24.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest24.C
new file mode 100644
index 00000000000..4fcc02c63d6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest24.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+struct A {
+  A (){}
+};
+
+void foo ()
+{
+ struct B {};
+
+ struct S : B {
+   A a;
+ };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest3.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest3.C
new file mode 100644
index 00000000000..bedd5192118
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest3.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed nested-classes
+class X {
+public:
+  struct M2 { int m; };
+  M2 g(int);
+};
+
+
+X::M2 X::g(int i) { X::M2 m2; return m2; }
+
+int main() { }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/nest4.C b/gcc/testsuite/g++.old-deja/g++.brendan/nest4.C
new file mode 100644
index 00000000000..34631f4f0cd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/nest4.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed nested-classes
+class vec {
+    class blah { };
+
+    ::vec::blah	satan( 0);// ERROR - .*
+    blah	herman( 0);// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/new-array.C b/gcc/testsuite/g++.old-deja/g++.brendan/new-array.C
new file mode 100644
index 00000000000..3080a585c78
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/new-array.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed operator-new
+typedef struct {
+	int a;
+} AStruct;
+
+void MakeBug() {
+	AStruct *job;
+
+	// This used to crash, it should now give error(s).
+	job = new AStruct[];// ERROR - .*
+
+	job = new AStruct;
+}
+
+int main () {
+	MakeBug();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/new1.C b/gcc/testsuite/g++.old-deja/g++.brendan/new1.C
new file mode 100644
index 00000000000..09326d2ce58
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/new1.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed operator-new
+typedef __SIZE_TYPE__ size_t;
+struct x { int a; void * operator new (size_t, void *); };
+struct x * f(void *p) { return new (p) x; }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/new2.C b/gcc/testsuite/g++.old-deja/g++.brendan/new2.C
new file mode 100644
index 00000000000..64b3d51e08a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/new2.C
@@ -0,0 +1,67 @@
+// GROUPS passed operator-new
+// Check that if there is a user defined class-specific operator
+// new for a given class, that operator is invoked when a new
+// object of the class is requested, regardless of whether or not
+// there is also a constructor for the given class, and regardless
+// of whether or not the constructor for the given class is defined
+// before or after the new operator is even declared.
+
+extern "C" void printf (char *, ...); 
+
+typedef __SIZE_TYPE__ size_t;
+
+struct base {
+	int i;
+
+	base ()
+	{
+		i = 7;
+	}
+
+	void * operator new (size_t size);
+	void operator delete (void*);
+};
+
+class derived : public base {
+	int j;
+};
+
+int new_call_count = 0;
+int expected_size = 0;
+int errors = 0;
+
+int main ()
+{
+	base*		base_ptr;
+	derived*	derived_ptr;
+
+	expected_size = 4;
+	base_ptr = new base;
+	expected_size = 8;
+	derived_ptr = new derived ();
+
+	if ((new_call_count != 2) || (errors != 0))
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+
+	return 0;
+}
+
+char allocation_space[1000];
+char* allocation_ptr = allocation_space;
+
+void base::operator delete (void* p)
+{
+}
+
+void *base::operator new (size_t size)
+{
+	char* return_value = allocation_ptr;
+
+	new_call_count++;
+	if (size != expected_size)
+		errors++;
+	allocation_ptr = allocation_ptr + size;
+	return (void*) return_value;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/new3.C b/gcc/testsuite/g++.old-deja/g++.brendan/new3.C
new file mode 100644
index 00000000000..5f5c988c29a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/new3.C
@@ -0,0 +1,36 @@
+// GROUPS passed operator-new
+#include <stdio.h>
+#include <stdlib.h>
+#include <new>
+
+int pass = 0;
+
+void *operator new(size_t sz) throw (std::bad_alloc) {
+
+  void *p;
+
+  pass = 1;
+  p = malloc(sz);
+  return p;
+}
+
+class A {
+public:
+  A() {}
+  ~A() {}
+
+  int a;
+  int b;
+};
+
+
+int main()
+{
+  A *bb = new A[10];
+  delete [] bb;
+
+  if (pass)
+    printf ("PASS\n");
+  else
+    printf ("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ns1.C b/gcc/testsuite/g++.old-deja/g++.brendan/ns1.C
new file mode 100644
index 00000000000..d20a9d93929
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ns1.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed old-abort
+struct B 
+{
+      void f(char); 
+      void g(char);
+};
+  
+class C 
+{
+  int g();
+};// ERROR -  warning
+
+class D2 : public B 
+{
+  using B::f;  // ok: B is a base of D
+  using C::g;  // error: C isn't a base of D2
+}; // ERROR - type C is not a base type for type D2
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/operators1.C b/gcc/testsuite/g++.old-deja/g++.brendan/operators1.C
new file mode 100644
index 00000000000..89453f9f10c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/operators1.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed operators
+struct A {
+	int x;
+};
+
+int operator()(A x,float y) { // MUST be a member function// ERROR - .*
+	return 1;
+}
+
+int main() {
+	A x;
+	x(1.0); // ERROR - no match for call
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/operators2.C b/gcc/testsuite/g++.old-deja/g++.brendan/operators2.C
new file mode 100644
index 00000000000..ece06ef3d06
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/operators2.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed operators
+class X { };
+void operator[](X& a, X& b) {} // MUST be a member function// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/operators3.C b/gcc/testsuite/g++.old-deja/g++.brendan/operators3.C
new file mode 100644
index 00000000000..e068de3aa52
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/operators3.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed operators
+class X { };
+void operator->(X& a, X& b) {} // MUST be a member function// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/operators4.C b/gcc/testsuite/g++.old-deja/g++.brendan/operators4.C
new file mode 100644
index 00000000000..b56d26c073d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/operators4.C
@@ -0,0 +1,121 @@
+// GROUPS passed operators
+// Check that the & operator, when applied to a global function
+// or member function returns a proper value as long as the context
+// in which the result of & is used requires a pointer to a specific
+// unambigous (function-pointer) type.
+//
+// This test fails (in test5()) when compiled with g++ 1.34.1.
+
+extern "C" void printf (char *, ...); 
+
+int function (char c);
+int function (float f);
+
+class base {
+	int filler;
+public:
+	int method (char);
+	int method (float);
+};
+
+void* vp;
+
+typedef int (*ptr_to_func_of_char)(char);
+typedef int (*ptr_to_func_of_float)(float);
+typedef int (base::*ptr_to_method_of_char)(char);
+typedef int (base::*ptr_to_method_of_float)(float);
+
+int test2 (void*);
+int test3 (void*);
+int test4 (void*);
+int test5 (void*);
+
+base* base_ptr;
+
+int fail ()
+{
+  printf ("FAIL\n");
+  return 1;
+}
+
+int main ()
+{
+	base_ptr = new base;
+
+	ptr_to_func_of_char p0 = &function;
+	vp = (void*) p0;
+	if (test2 (vp))
+		return fail ();
+	ptr_to_func_of_float p1 = &function;
+	vp = (void*) p1;
+	if (test3 (vp))
+		return fail ();
+	ptr_to_method_of_char p2 = &base::method;
+	vp = (void*) p2; // ERROR - 
+	if (test4 (vp))
+		return fail ();
+	ptr_to_method_of_float p3 = &base::method;
+	vp = (void*) p3; // ERROR - 
+	if (test5 (vp))
+		return fail ();
+
+	printf ("PASS\n");
+	return 0;
+}
+
+int test2 (void* vp)
+{
+	char ch = 'x';
+
+	return (((ptr_to_func_of_char)vp)(ch) !=  9901);
+}
+
+int test3 (void* vp)
+{
+	float flt = 9.9;
+
+	return (((ptr_to_func_of_float)vp)(flt) !=  9902);
+}
+
+int test4 (void* vp)
+{
+	char ch = 'x';
+	ptr_to_method_of_char p = (ptr_to_method_of_char) vp; // ERROR - bad type conversion
+
+	return ((base_ptr->*p)(ch) !=  9904);
+}
+
+int test5 (void* vp)
+{
+	float flt = 9.9;
+	ptr_to_method_of_float p = (ptr_to_method_of_float) vp; // ERROR - bad type conversion
+
+	if ((base_ptr->*p)(flt) !=  9905) {
+		return 1;
+	} else
+		return 0;
+}
+
+int function (char c)
+{
+	c = c;
+	return 9901;
+}
+
+int function (float f)
+{
+	f = f;
+	return 9902;
+}
+
+int base::method (char c)
+{
+	c = c;
+	return 9904;
+}
+
+int base::method (float f)
+{
+	f = f;
+	return 9905;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/operators5.C b/gcc/testsuite/g++.old-deja/g++.brendan/operators5.C
new file mode 100644
index 00000000000..84c09a2a4b2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/operators5.C
@@ -0,0 +1,52 @@
+// GROUPS passed operators
+// Check that operators may be (directly) recursive.
+
+extern "C" void printf (char *, ...); 
+
+struct base {
+	int i;
+};
+
+base base_variable;
+
+base operator+ (const base& left, const base& right)
+{
+	base ret_val;
+
+	ret_val.i = left.i + right.i;
+	return ret_val;
+}
+
+base operator- (const base& left, int right)
+{
+	base ret_val;
+
+	ret_val.i = left.i - right;
+	return ret_val;
+}
+
+// Define the unary ! operator for class base to be the fibonachi
+// operator.
+
+base operator! (const base& right)
+{
+	if (right.i < 2)
+		return right;
+	else
+		return ((!(right-1)) + (!(right-2)));
+}
+
+int main ()
+{
+	base k;
+
+	k.i = 15;
+	k = !k;		// fib it!
+
+	if (k.i != 610)
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+
+	return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/operators6.C b/gcc/testsuite/g++.old-deja/g++.brendan/operators6.C
new file mode 100644
index 00000000000..c0c23188a8e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/operators6.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed operators
+class a {
+public:
+    a* operator->() { return this; }
+    void p();
+};
+
+void a::p() {
+  operator->();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/operators7.C b/gcc/testsuite/g++.old-deja/g++.brendan/operators7.C
new file mode 100644
index 00000000000..7a952211c9b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/operators7.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed operators
+class A {
+  char *p;
+public:
+  operator const char *() const { return p; }
+};
+
+int foo(const A &a)
+{
+  return (a != 0);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/operators8.C b/gcc/testsuite/g++.old-deja/g++.brendan/operators8.C
new file mode 100644
index 00000000000..390f749bc5e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/operators8.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed operators
+struct A {
+  char *p;
+  operator char *();
+};
+
+char foo(A a)
+{
+  return a[0];
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload1.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload1.C
new file mode 100644
index 00000000000..e5040fdc7cc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload1.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed overloading
+class Foo
+{
+public:
+  int f (void);
+};
+
+class Bar : public Foo
+{
+public:
+      int f (int); // ERROR - candidates are
+};
+
+int main ()
+{
+  Bar b;
+
+  b.f ();// ERROR - 
+  b.f (10);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload10.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload10.C
new file mode 100644
index 00000000000..e28d6ea805d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload10.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed overloading
+class Bed {
+   public:
+   static void bed_func(
+      int        (*f)(int &, int, int));
+};
+class g_func {
+public:
+	static int save_status;
+
+	// in compute_harshness, we should be using comptypes, not ==, to
+	// check if this is equivalent to the previous decl; the only
+	// difference is the default arg
+	static int rpt_func(int &status, int expand, 
+		int restore_cursor=1 );
+};
+
+int  main (int argc, 
+           char **argv,
+           char  **envp)
+{
+   Bed::bed_func(g_func::rpt_func);
+   return(1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload11.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload11.C
new file mode 100644
index 00000000000..cbced94cbcf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload11.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed overloading
+class foo_int
+{
+public:
+  int & i;
+
+  foo_int (int &j) : i(j) {};
+  void inc () { i++; }
+
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload2.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload2.C
new file mode 100644
index 00000000000..75068da88bb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload2.C
@@ -0,0 +1,43 @@
+// GROUPS passed overloading
+// Check that calls to the correct overloaded virtual
+// functions are generated even where the type of the formal
+// arguments for the overloadings are similar or related.
+
+extern "C" void printf (char *, ...); 
+
+int proper_method_called = 0;
+
+struct base {
+	int member;
+	virtual void method (char)
+	{
+	}
+	virtual void method (char *)
+	{
+	}
+};
+
+struct derived : public base {
+	int member;
+	virtual void method (char)
+	{
+	}
+	virtual void method (char *)
+	{
+		proper_method_called++;
+	}
+};
+
+char *message;
+
+int main ()
+{
+	derived derived_object;
+
+	derived_object.method (message);
+
+	if (proper_method_called != 1)
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload3.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload3.C
new file mode 100644
index 00000000000..baa90fb282d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload3.C
@@ -0,0 +1,27 @@
+// Build don't link: 
+// GROUPS passed overloading
+typedef int rutBoolean;
+
+class rutBigIntRep
+{
+public:
+  friend rutBoolean operator>(const rutBigIntRep& a, const rutBigIntRep& b);
+  operator rutBoolean() const;  
+protected:
+  enum Kluge {kluge};
+  rutBigIntRep(Kluge) {}
+  rutBigIntRep();
+  rutBigIntRep(const rutBigIntRep& value);
+  rutBigIntRep& operator=(const rutBigIntRep& value);
+};
+
+rutBoolean operator>(const rutBigIntRep& a, const rutBigIntRep& b) {
+  // This should not result in a warning.  It used to warn about the
+  // conversion from int to enum while exploring the possibility of
+  // converting `a' via `operator rutBoolean', then using the
+  // rutBigIntRep(Kluge) constructor.  It later realizes it shouldn't
+  // do this, but the call to build_type_conversion was ending up with
+  // a warning in convert.
+  rutBigIntRep diff(a);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload4.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload4.C
new file mode 100644
index 00000000000..21c3dc8db5a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload4.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed overloading
+  typedef void *		(*NewObject) (void);
+  
+  class B
+  {
+  public:
+	static void WantsNew (NewObject creator); // ERROR - candidates are
+  };
+  
+  class A
+  {
+  public:
+      static A * NewOne (void);
+  
+      static void InitClass (void)
+      {
+	  B::WantsNew ( (NewObject) A::NewOne );
+	  // This used to die in convert_harshness_{ansi,old} cuz it
+	  // didn't know what to do about a void type.
+	  B::WantsNew ( A::NewOne );// ERROR - 
+      }
+  };
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload5.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload5.C
new file mode 100644
index 00000000000..d71f0c01d2e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload5.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed overloading
+class Foo
+{
+public:
+  int operator << (const signed char&);
+  int operator << (const unsigned char&);
+  int operator << (const short&);
+  int operator << (const unsigned short&);
+  int operator << (const long&);
+  int operator << (const unsigned long&);
+};
+
+int main ()
+{
+  Foo fd;
+
+  // We fixed convert_harshness_ansi so it considers the call to
+  // <<(const signed char&) to be a trivial conversion.  It used
+  // to always make it a standard conversion, which made it conflict
+  // with <<(const unsigned char &), which is really a std conv.
+  fd << (signed char) 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload6.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload6.C
new file mode 100644
index 00000000000..84903c19d74
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload6.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed overloading
+struct temp_string {
+  temp_string (const unsigned char);
+};
+  
+class String {
+ public:
+  String& operator = (temp_string);
+  String& operator = (const String&);
+}; 
+class S {
+ public:
+  operator temp_string & () const;
+}; 
+
+S lbuf;
+
+static void e_r ()
+{
+  String a;
+  a = lbuf;
+ return;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload7.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload7.C
new file mode 100644
index 00000000000..ec2685c4067
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload7.C
@@ -0,0 +1,41 @@
+// GROUPS passed overloading
+extern "C" void printf (char *, ...);
+
+struct NoName {
+        
+        int first;
+        int second;
+};
+
+class Casted {
+
+  public:
+
+        NoName  x;
+        double  y;
+
+        Casted ( int _x , double _y ): y(_y) 
+        { 
+                x.first = _x;
+                x.second = _x*2;
+        }
+        
+        operator NoName() const { return x; }
+        operator double() const { return y; }
+};
+
+int main()
+{
+        Casted c(10,12.34);
+
+        NoName x;
+        double y;
+
+        x = c;
+        y = c;
+
+	if (x.first == 10 && x.second == 20 && y == 12.34)
+	  printf ("PASS\n");
+	else
+	  printf ("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload8.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload8.C
new file mode 100644
index 00000000000..71d16898fb7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload8.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed overloading
+typedef struct{double re,im;} complex;
+class Complex{public:double re,im;
+    inline void operator=(Complex&X){re=X.re; im=X.im;};};
+void zxcvbnm(int n,...){n=1;}
+int main(){complex c; Complex C;
+zxcvbnm(1,c);
+zxcvbnm(1,C);}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/overload9.C b/gcc/testsuite/g++.old-deja/g++.brendan/overload9.C
new file mode 100644
index 00000000000..93a0cbff9be
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/overload9.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed overloading
+class CLogger
+{
+public:
+      void operator() (int,const char *) {}; // ERROR - candidates
+      void operator() (int,const char *, ...) {}; // ERROR - candidates
+} Log;
+
+class CGLogger : public CLogger
+{
+} GLog;
+
+int main()
+{
+        Log(1,"Test");// ERROR -  call of.*
+        Log(1,"Test %d",3);
+        GLog(1,"Test");// ERROR -  call of.*
+        GLog(1,"Test %d",3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/parse1.C b/gcc/testsuite/g++.old-deja/g++.brendan/parse1.C
new file mode 100644
index 00000000000..0c62c03bda9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/parse1.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed parsing
+class Try {
+private:
+  char s;
+public:
+  // an escaped double-quote should not call consume_string inside
+  // reinit_parse_for_block
+  void  mf() { s='\"'; }
+};
+
+int main()
+{
+  Try x;
+  x.mf();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/parse2.C b/gcc/testsuite/g++.old-deja/g++.brendan/parse2.C
new file mode 100644
index 00000000000..cd588e15d86
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/parse2.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed parsing
+class BitString {
+public:
+    int i;
+};
+
+
+typedef BitString BS;
+typedef ::BitString cBS;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/parse3.C b/gcc/testsuite/g++.old-deja/g++.brendan/parse3.C
new file mode 100644
index 00000000000..8be64a39b68
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/parse3.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+
+// these are marked as expected errors because they evidence an
+// ambiguity in the grammar between expressions and declarations.
+// when the parser's been cleaned up or rewritten, these two error
+// markers can go away, since they'll no longer occur.
+
+class A
+{
+  public:
+    int high;
+    unsigned int low;
+    A operator+(const A in);
+};
+
+A A::operator+(const A in)
+{
+    if (high==0)
+      return A();    // this works
+    else
+      return (A());  // this works not // gets bogus error - XFAIL *-*-* 
+} // gets bogus error - XFAIL *-*-* 
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/parse4.C b/gcc/testsuite/g++.old-deja/g++.brendan/parse4.C
new file mode 100644
index 00000000000..6526c605951
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/parse4.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+
+// this is marked as an expected error because it evidences an
+// ambiguity in the grammar between expressions and declarations.
+// when the parser's been cleaned up or rewritten, the error
+// marker can go away, since it'll no longer occur.
+
+class B
+{
+public:
+    B( int t ) {}
+    void f() {}
+};
+
+int g() { return 0; } // gets bogus error - referenced below XFAIL *-*-*
+
+int main()
+{
+    int try1;
+    B( try1 ).f();   // no syntax error
+    B b( g() );      // no syntax error
+    B( ::g() ).f();  // no syntax error 
+    B( g() ).f();    // gets bogus error - treated as decl XFAIL *-*-*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/parse5.C b/gcc/testsuite/g++.old-deja/g++.brendan/parse5.C
new file mode 100644
index 00000000000..81a5fe649b1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/parse5.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+
+// this is marked as an expected error because it evidences an
+// ambiguity in the grammar between expressions and declarations.
+// when the parser's been cleaned up or rewritten, the error
+// marker can go away, since it'll no longer occur.
+
+class ptr8
+   {
+public:
+   ptr8(unsigned char *string,int len);
+   };
+
+template <unsigned int S>
+class buf
+   {
+public:
+   buf(const ptr8& aRef);
+   };
+
+int main()
+   {
+   unsigned  char b[3];
+   buf<3> b2(ptr8(&b[0],3)); // gets bogus error - XFAIL *-*-*
+   }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/parse6.C b/gcc/testsuite/g++.old-deja/g++.brendan/parse6.C
new file mode 100644
index 00000000000..d5ece069103
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/parse6.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+
+// this is marked as an expected error because it evidences an
+// ambiguity in the grammar between expressions and declarations.
+// when the parser's been cleaned up or rewritten, the error
+// marker can go away, since it'll no longer occur.
+
+class A { };
+
+int main()  {
+  A a = a;
+  A b(b); // gets bogus error - XFAIL *-*-*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/prepost1.C b/gcc/testsuite/g++.old-deja/g++.brendan/prepost1.C
new file mode 100644
index 00000000000..e1b18bcadc5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/prepost1.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed prefix-postfix
+class foo {
+public:
+      operator ++ (); // ERROR - no type or storage class
+};
+
+int main()
+{
+  foo x;
+
+  // This should fall back to calling operator++(), and be an error with
+  // the -pedantic flag.
+  x++;// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/prepost2.C b/gcc/testsuite/g++.old-deja/g++.brendan/prepost2.C
new file mode 100644
index 00000000000..1e34433e180
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/prepost2.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed initialization
+class foo {
+public:
+      operator ++ (); // ERROR - no type or storage class
+      operator ++ (int); // ERROR - no type or storage class
+      operator ++ (char);		// illegal// ERROR - .*
+      operator ++ (short);		// illegal// ERROR - .*
+      operator ++ (long);		// illegal// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/prepost3.C b/gcc/testsuite/g++.old-deja/g++.brendan/prepost3.C
new file mode 100644
index 00000000000..4244e4ff59e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/prepost3.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed prefix-postfix
+class Y {
+public:
+   friend Y operator++ (Y&);
+   friend Y operator++ (Y&, char);	// illegal// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/prepost4.C b/gcc/testsuite/g++.old-deja/g++.brendan/prepost4.C
new file mode 100644
index 00000000000..ac31f912952
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/prepost4.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed prefix-postfix
+class Y {
+public:
+   friend Y operator++ (Y&);
+
+   // This is legal---it's a good test to make sure that grokfndecl's
+   // checking of the arguments is sane.
+   friend Y operator++ (Y&, int);
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ptolemy1.C b/gcc/testsuite/g++.old-deja/g++.brendan/ptolemy1.C
new file mode 100644
index 00000000000..3e3b2dfe1b5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ptolemy1.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed ptolemy-bugs
+class Tcl_Interp;
+
+class PTcl {
+public:
+	PTcl(Tcl_Interp* interp = 0);
+	~PTcl();
+	int alias(int argc,char** argv);
+};
+
+typedef int (PTcl::*InterpFuncP)(int,char**);
+
+struct InterpTableEntry {
+	char* name;
+	InterpFuncP func;
+};
+
+ 
+static InterpTableEntry funcTable[] = {
+	{ "alias" , &PTcl::alias  } ,
+	0, 0
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ptolemy2.C b/gcc/testsuite/g++.old-deja/g++.brendan/ptolemy2.C
new file mode 100644
index 00000000000..58a10dcec90
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ptolemy2.C
@@ -0,0 +1,69 @@
+// GROUPS passed ptolemy-bugs
+#include <iostream.h>
+
+class PTcl {
+public:
+	int dispatcher(int which,int argc,char** argv);
+	// fns in the table
+	int one(int argc, char** argv);
+	int two(int argc, char** argv);
+	int three(int argc, char** argv);
+};
+
+// An InterpFuncP is a pointer to an PTcl function that takes an argc-argv
+// argument list and returns TCL_OK or TCL_ERROR.
+
+typedef int (PTcl::*InterpFuncP)(int,char**);
+
+struct InterpTableEntry {
+	char* name;
+	InterpFuncP func;
+};
+
+// Here is the function table and dispatcher function.
+// These macros define entries for the table
+
+#define quote(x) #x
+#define ENTRY(verb) { quote(verb), &PTcl::verb }
+
+static InterpTableEntry funcTable[] = {
+	ENTRY(one),
+	ENTRY(two),
+	ENTRY(three),
+	{0, 0}
+};
+
+int PTcl::dispatcher(int which, int argc, char** argv) {
+	return (this->*(funcTable[which].func))(argc, argv);
+}
+
+void printargs(char** argv) {
+//	while (*argv) {
+//		cout << " " << *argv++;
+//	}
+//	cout << "\n";
+}
+
+int PTcl::one(int, char** argv) {
+  cout << "FAIL\n";
+	printargs(argv);
+	return 0;
+}
+
+int PTcl::two(int, char** argv) {
+  cout << "PASS\n";
+	printargs(argv);
+	return 0;
+}
+
+int PTcl::three(int, char** argv) {
+  cout << "FAIL\n";
+	printargs(argv);
+	return 0;
+}
+
+int main (int argc, char** argv) {
+	PTcl obj;
+	obj.dispatcher(1,argc,argv);
+	return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem1.C b/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem1.C
new file mode 100644
index 00000000000..49c9f75aa1f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem1.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed pointers-to-members
+class my_class 
+{
+public:
+  typedef void func_type (int num);
+  my_class (int num, func_type* proc);
+  void dispatch (void);
+private:
+  int _num;
+  func_type *_proc;
+};
+
+my_class::my_class (int num, func_type* proc) : _num(num), _proc(proc) 
+{
+}
+
+void my_class::dispatch (void)
+{
+  _proc(_num);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem2.C b/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem2.C
new file mode 100644
index 00000000000..2af19e04d84
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem2.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+// GROUPS passed pointers-to-members
+struct C {
+  struct N {
+    int g1(int);
+    int g2(int);
+  };
+
+  typedef int (N::*pmfn)(int);
+  
+  int f1(int);
+  int f2(int);
+};
+
+int (C::*f)(int) = &C::f1;		
+
+/*
+   The compiler should not crash on the line below; this change fixes it:
+        * cp-tree.c (list_hash_lookup_or_cons): Make sure the type doesn't
+        have TYPE_PTRMEMFUNC_P set before we try to build its
+        CLASSTYPE_ID_AS_LIST.
+*/
+
+C::pmfn h = &C::N::g1;			
+
+int (C::N::*g)(int) = &C::N::g2;	
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem3.C b/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem3.C
new file mode 100644
index 00000000000..0f6bf0bd90f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem3.C
@@ -0,0 +1,32 @@
+// Build don't link: 
+// GROUPS passed pointers-to-members
+template<class T> class TemplA {
+    T t;
+};
+
+
+template<class T> class TemplB {
+public:    
+    typedef void (T::*TClassMethod)();
+
+private:
+/*
+   This line should not crash cuz of the get_decl_list change in this:
+	* cp-tree.c (list_hash_lookup_or_cons): Make sure the type doesn't
+	have TYPE_PTRMEMFUNC_P set before we try to build its
+	CLASSTYPE_ID_AS_LIST.
+	(get_decl_list): Likewise, when trying to read it.
+*/
+    TemplA<TClassMethod> Tmethod;  
+};
+
+
+class C {
+    int a;
+};
+
+int main(int, char**) {
+
+    TemplB<C> test;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem4.C b/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem4.C
new file mode 100644
index 00000000000..a4f792e5c07
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/ptrmem4.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed pointers-to-members
+class X   {
+ private:
+  int i;
+ public:
+  X(int k)			{ i=k; }
+  int operator=(X &a)		{ return i = a.i; }
+  int operator=(int ii)	{ return i = ii; }
+};
+int main(void)
+{
+  int (X::*op1_ptr)(X&);
+  op1_ptr = &X::operator=;    // g++ gives error 
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/recurse.C b/gcc/testsuite/g++.old-deja/g++.brendan/recurse.C
new file mode 100644
index 00000000000..639dfb3b3dd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/recurse.C
@@ -0,0 +1,80 @@
+// Build don't link: 
+// GROUPS passed recursive-aborts
+// types
+typedef unsigned int DBflag;   // for storing user flag value
+typedef unsigned long DBoffset; // 32-bit unsigned integer
+typedef DBoffset DBsize;  // type for storing sizes of objects
+typedef unsigned char DBbyte;   // 8-bit unsigned char
+
+class DBlink
+{
+protected:
+  DBbyte link[4];       // hold link in portable MSB first format
+public:
+  DBlink(DBoffset = 0, DBflag = 0);
+  DBlink &operator=(const DBlink &);
+  DBlink &operator=(DBoffset);
+  operator DBoffset();
+  operator const DBbyte *() { return link; }
+  void set_flag() { link[0] |= 0x80; }
+  void reset_flag() { link[0] &= 0x7f; }
+  int test_flag() const { return (link[0] & 0x80) != 0; }
+};
+
+typedef DBlink DBsizerec;       // hold data record size in portable format
+
+// constants
+const DBoffset DB_NULL = 0;
+
+class DBlinkrec
+{
+protected:
+  // offsets are stored with MSB in link[0]
+  DBlink l;  // offset into link file of right child - MSB = red bit
+  DBlink r;  // offset into link file of left child - MSB = delete
+  DBlink d;  // offset into parallel data file - MSB = user flag
+public:
+  DBlinkrec():l(DB_NULL), r(DB_NULL), d(DB_NULL) {}
+  void make_red() // set link to red
+  { l.set_flag(); }
+  void make_black() // set link to black
+  { l.reset_flag(); }
+  int is_red() const // indicates whether this is a red link
+  { return l.test_flag(); }
+  void set_discard() // set discard flag
+  { r.set_flag(); }
+  void reset_discard() // reset discard flag
+  { r.reset_flag(); }
+  int is_discarded() const // check discard flag
+  { return r.test_flag(); }
+  void set_flag() // set user flag
+  { d.set_flag(); }
+  void reset_flag() // reset user flag
+  { d.reset_flag(); }
+  int is_flag() const // check user flag
+  { return d.test_flag(); }
+
+  friend class DataBase;
+};
+
+class DBpathrec : public DBlinkrec
+{
+  DBoffset offset;    // offset of link record in LNK file
+public:
+  DBpathrec():offset(DB_NULL) { }
+  DBpathrec(DBoffset off, const DBlinkrec &lr):offset(off), DBlinkrec(lr) {}
+  operator DBoffset() { return offset; }
+  DBpathrec &operator=(DBoffset off) { offset = off; return *this; }
+  DBpathrec &operator=(const DBpathrec &pr)
+  { offset = pr.offset; (DBlinkrec)*this = (DBlinkrec)pr; return *this; }
+
+  friend class DataBase;
+};
+
+int main()
+{
+  DBpathrec a(), b();
+
+  a = b;// ERROR -  non-lvalue in assignment.*
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/redecl1.C b/gcc/testsuite/g++.old-deja/g++.brendan/redecl1.C
new file mode 100644
index 00000000000..39a432cac5f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/redecl1.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed redeclaration
+inline int min(int x, int y) {return x < y ? x : y;}		/* 235 */// ERROR - .*
+int min(int a, int b);
+inline int min(int a, int b) {return (a < b)?a:b;}// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/redecl2.C b/gcc/testsuite/g++.old-deja/g++.brendan/redecl2.C
new file mode 100644
index 00000000000..58942197ddf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/redecl2.C
@@ -0,0 +1,51 @@
+// GROUPS passed redeclaration
+// Check that if multiple declarations of the same single
+// function are present in different places in the same file,
+// and if these declarations differ (as allowed) in the number
+// of argument defaults provided, that correct values are
+// passed at all call points anyway.
+
+extern "C" void printf (char *, ...); 
+
+void receiver (int ii, int jj);
+
+void sender_1 ()
+{
+	receiver (3,7);
+}
+
+void receiver (int ii, int jj = 9);
+
+void sender_2 ()
+{
+	receiver (5);
+}
+
+int ii_sum = 0;
+int jj_sum = 0;
+
+void sender_3 ();
+
+int main ()
+{
+	sender_1 ();
+	sender_2 ();
+	sender_3 ();
+	if (ii_sum != 13 || jj_sum != 25)
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+
+	return 0;
+}
+
+void receiver (int ii, int jj)
+{
+	ii_sum += ii;
+	jj_sum += jj;
+}
+
+void sender_3 ()
+{
+	receiver (5);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/redecl3.C b/gcc/testsuite/g++.old-deja/g++.brendan/redecl3.C
new file mode 100644
index 00000000000..5987e0e3172
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/redecl3.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed redeclaration
+class foo
+{
+public:
+    int bar(int a);
+};
+
+
+void bar(int &a);
+
+int foo::bar(int a)  {
+    int a = 0;			// Should this be an error ?// ERROR -  declaration.*
+
+    bar(a);
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/reference1.C b/gcc/testsuite/g++.old-deja/g++.brendan/reference1.C
new file mode 100644
index 00000000000..84ad6f4bf20
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/reference1.C
@@ -0,0 +1,53 @@
+// Special g++ Options: -w
+// GROUPS passed references
+// Check that if a reference is initialized to refer to a value
+// which is returned from a function call, the actual call to
+// the function is only invoked for the original initialization
+// of the reference, and not for each subsequent use of the
+// reference.
+//
+// This test fails with G++ 1.35.0- (pre-release).
+// Reported 4/4/89 by Kim Smith
+
+extern "C" void printf (char *, ...); 
+
+struct base {
+	mutable int data_member;
+
+	base () {}
+	void function_member () const;
+};
+
+base base_object;
+
+base base_returning_function ();
+
+int call_count = 0;
+
+int main ()
+{
+	const base& base_ref = base_returning_function ();
+
+	base_ref.function_member ();
+	base_ref.function_member ();
+	base_ref.data_member  = 99;
+
+	if (call_count == 1)
+	  printf ("PASS\n");
+	else
+	  printf ("FAIL\n");
+
+	return 0;
+}
+
+base base_returning_function ()
+{
+	base local_base_object;
+
+	call_count++;
+	return local_base_object;
+}
+
+void base::function_member () const
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/rtti1.C b/gcc/testsuite/g++.old-deja/g++.brendan/rtti1.C
new file mode 100644
index 00000000000..6dcdff34e36
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/rtti1.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+// GROUPS passed RTTI
+#include <typeinfo>
+
+struct B                                { virtual ~B(){}  };
+struct D0 : public virtual B            { virtual ~D0(){}  };
+struct D1 : public virtual D0           { virtual ~D1(){}  };
+struct C : public virtual B, public D1  { virtual ~C() { } };
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/scope1.C b/gcc/testsuite/g++.old-deja/g++.brendan/scope1.C
new file mode 100644
index 00000000000..babbb018396
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/scope1.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+// GROUPS passed scoping
+int f (int i) {
+  if (i)
+    for (int j = i; j; j--)
+      ;
+  return j;	// error: j should only be in scope inside the body of `for'// ERROR - .*
+} // ERROR - non-void
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/scope2.C b/gcc/testsuite/g++.old-deja/g++.brendan/scope2.C
new file mode 100644
index 00000000000..fccd1d66ec2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/scope2.C
@@ -0,0 +1,29 @@
+// Build don't link: 
+// GROUPS passed scoping
+class A
+{
+ public:
+  A() {}
+  ~A() {}
+  virtual void f() {}
+};
+
+class B : public A
+{
+ public:
+  B() {}
+  ~B() {}
+  virtual void f() {}
+};
+
+
+B GLOBAL_B;
+
+B& foo() {return GLOBAL_B;}
+
+int main()
+{
+  // build_scoped_method_call and build_scoped_ref should know how
+  // to deal with a reference for this
+  foo().A::f(); 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/scope3.C b/gcc/testsuite/g++.old-deja/g++.brendan/scope3.C
new file mode 100644
index 00000000000..cf784303171
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/scope3.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed scoping
+// This is fixed when NEW_CLASS_SCOPING is on.
+
+template<class T>
+class ArrayG {
+public:
+    ArrayG();
+protected:
+    const unsigned INITIAL;
+    T* array;			 
+};
+
+template<class T>
+ArrayG<T>::ArrayG():
+array(new T[INITIAL])
+{ }
+
+struct X {
+    struct Correspondence {
+	int i;
+    };
+
+    void fill(ArrayG<Correspondence>& a);
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/scope4.C b/gcc/testsuite/g++.old-deja/g++.brendan/scope4.C
new file mode 100644
index 00000000000..a6781abeb62
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/scope4.C
@@ -0,0 +1,31 @@
+// Build don't link: 
+// GROUPS passed scoping
+class BitString {
+public:
+    int i;
+    int length() const;
+};
+
+typedef BitString BS;
+
+class V {
+public:
+    class BitString {
+    public:
+        static int x(const ::BitString& value);
+      static int y(const class ::BitString& value); // should be parsed ok
+        static int z(const BS& value);
+    };
+};
+
+int
+V::BitString::x(const ::BitString& value)
+{ return value.length(); }
+
+int
+V::BitString::y(const class ::BitString& value) // should be parsed ok
+{ return value.length(); }
+
+int
+V::BitString::z(const BS& value)
+{ return value.length(); }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/scope5.C b/gcc/testsuite/g++.old-deja/g++.brendan/scope5.C
new file mode 100644
index 00000000000..753236948a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/scope5.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed scoping
+class Integer {
+public:
+    int i;
+};
+
+class Type {
+    enum Class { ENUM, INTEGER };
+
+    class Description {
+    public:
+        
+    };
+
+    class Integer: public Description {
+    public:
+        ::Integer low;
+        ::Integer high;
+    };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/shadow1.C b/gcc/testsuite/g++.old-deja/g++.brendan/shadow1.C
new file mode 100644
index 00000000000..6a1d9d1f8e3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/shadow1.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+// GROUPS passed errors
+void f( int a) {
+  int a;	// this should be an error now// ERROR - .*
+	{
+		int a;
+	}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/sizeof1.C b/gcc/testsuite/g++.old-deja/g++.brendan/sizeof1.C
new file mode 100644
index 00000000000..c8242eb5539
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/sizeof1.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed sizeof
+// ARM $5.3.2
+
+void f() { }
+
+int
+main()
+{
+  // sizeof may not be applied to a function
+  int i = sizeof( f);// ERROR - .*
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/sizeof2.C b/gcc/testsuite/g++.old-deja/g++.brendan/sizeof2.C
new file mode 100644
index 00000000000..ddac679d880
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/sizeof2.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed sizeof
+// ARM $5.3.2
+
+void f() { }
+
+struct foo { int bit : 1; };
+
+int
+main()
+{
+  // sizeof may not be applied to a bit-field
+  foo f;
+  int i = sizeof (f.bit);// ERROR - .*
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/sizeof3.C b/gcc/testsuite/g++.old-deja/g++.brendan/sizeof3.C
new file mode 100644
index 00000000000..e6972ca397e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/sizeof3.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed sizeof
+// ARM $5.3.2
+
+class bar;
+
+int
+main()
+{
+  // sizeof may not be applied to an undefined class
+  int k = sizeof (bar);// ERROR - .*
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/sizeof4.C b/gcc/testsuite/g++.old-deja/g++.brendan/sizeof4.C
new file mode 100644
index 00000000000..62d76c05bdd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/sizeof4.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed sizeof
+// ARM $5.3.2
+
+int
+main()
+{
+  // sizeof may not be applied to the type void
+  int l = sizeof (void);// ERROR - .*
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/sizeof5.C b/gcc/testsuite/g++.old-deja/g++.brendan/sizeof5.C
new file mode 100644
index 00000000000..0ef9d9c5ed1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/sizeof5.C
@@ -0,0 +1,17 @@
+// GROUPS passed sizeof
+// ARM $5.3.2
+
+extern "C" void printf (char *, ...);
+
+class foo {};
+
+int
+main ()
+{
+  // The size of any class or class object is larger than zero.
+  int i = sizeof (foo);
+  if (i > 0)
+    printf ("PASS\n");
+  else
+    printf ("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/sorry1.C b/gcc/testsuite/g++.old-deja/g++.brendan/sorry1.C
new file mode 100644
index 00000000000..caa9276f8a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/sorry1.C
@@ -0,0 +1,36 @@
+// Build don't link: 
+// GROUPS passed old-sorry
+class a {
+public:
+	int*	foo();
+};
+
+a aa;
+a* ap;
+
+class b {
+public:
+	int	ok(int* p =aa.foo());	
+
+  // dump_init should know what to do with this NON_LVALUE_EXPR
+	int	f(int* p =ap->foo());		
+};
+
+	int
+b::ok(int *p) 
+{
+	return 0;
+}
+
+	int
+b::f(int *p) 
+{			
+	return 0;
+}
+	void
+bar()
+{
+	b b;
+	b.ok();
+	b.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/static1.C b/gcc/testsuite/g++.old-deja/g++.brendan/static1.C
new file mode 100644
index 00000000000..b30c796eb19
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/static1.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed static
+class A { public: int a; };// ERROR - .*
+void foo7 () { A::a = 3; }// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/static2.C b/gcc/testsuite/g++.old-deja/g++.brendan/static2.C
new file mode 100644
index 00000000000..8fd5ffc8488
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/static2.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed static
+class A
+{
+        public:
+        void    member(void)
+        {
+        }
+
+        static void staticMember()
+        {
+	  member (); // illegal, no object for calling non-static method// ERROR - .*
+        }
+};
+
+int main()
+{
+        A::staticMember();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/static3.C b/gcc/testsuite/g++.old-deja/g++.brendan/static3.C
new file mode 100644
index 00000000000..5c52f0e217d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/static3.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed static
+class foo{
+public:
+  static void  bar( int i ){ value = i; }
+  static int  value;// ERROR - .*
+};
+
+const int  foo::value = 0; // should be an error.// ERROR - .*
+
+int main(){
+  foo::bar( 1 );
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/synth1.C b/gcc/testsuite/g++.old-deja/g++.brendan/synth1.C
new file mode 100644
index 00000000000..5356796094a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/synth1.C
@@ -0,0 +1,33 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors -g -Wall
+// GROUPS passed synthetics
+// excess errors test - XFAIL sparc64-*-elf
+// Check to make sure that g++ doesn't get freaked out about the use
+// of generated methods that it supposedly "can't see".
+
+class Char {
+public:
+    Char();
+    Char(char v);
+    
+    // synthetic copy-constructor and operator=
+private:
+    char value;
+};
+
+class XChar: public Char {
+public:
+    XChar();
+    XChar(char v, int serial);
+    
+    void operator=(const XChar& other);
+private:
+    int serial;
+};
+
+void
+XChar::operator=(const XChar& other)
+{
+    Char::operator=(other);
+    // serial stays the same
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template1.C b/gcc/testsuite/g++.old-deja/g++.brendan/template1.C
new file mode 100644
index 00000000000..e6609fd323b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template1.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed templates
+// g++-2.2.1: member functions returning a template type 
+
+
+template <class T> struct list { };
+
+struct A
+{
+  list<int> L;
+
+  list<int>  get_list();
+
+};
+
+
+list<int> A::get_list() { return L; }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template11.C b/gcc/testsuite/g++.old-deja/g++.brendan/template11.C
new file mode 100644
index 00000000000..4a953a34082
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template11.C
@@ -0,0 +1,47 @@
+// Build don't link: 
+// GROUPS passed templates
+template <class Called>
+class aCallback
+{
+public:
+  aCallback(Called& obj, int (Called::*met)());
+
+  int callback();
+  
+protected:
+
+private:
+  // the object to call
+  Called&       object;
+  
+  // the method to apply
+  int (Called::*method)();
+  
+};
+
+template <class Called>
+aCallback<Called>::aCallback(Called& obj,
+                             int (Called::*met)()) :
+object(obj),
+method(met)
+{};
+
+template <class Called>
+int aCallback<Called>::callback()
+{
+  return (object.*method)();
+}
+
+struct myStruct
+{
+  int action() {return 24;};
+};
+
+int main()
+{
+  myStruct toto;
+
+  aCallback<myStruct>   cb(toto, &myStruct::action);
+
+  return cb.callback();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template12.C b/gcc/testsuite/g++.old-deja/g++.brendan/template12.C
new file mode 100644
index 00000000000..2165ae29ee4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template12.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+// GROUPS passed templates
+inline void foo (const int &x) {}
+
+template <class type>
+inline void foo (const type &x) {x.eat_this_and_die();}
+
+int main (int argc, char **argv) {foo (argc);}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template13.C b/gcc/testsuite/g++.old-deja/g++.brendan/template13.C
new file mode 100644
index 00000000000..653ef215e88
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template13.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed templates
+template<class T>
+class ListS {
+public:
+    class Vix {
+    public:
+	Vix();
+    };
+};
+
+template<class T>
+ListS<T>::Vix::Vix()
+{ }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template15.C b/gcc/testsuite/g++.old-deja/g++.brendan/template15.C
new file mode 100644
index 00000000000..b830505e209
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template15.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed templates
+template<class T> class Stack {
+  public:
+    Stack (int s = 10);         //Comment out "= 10" and it will compile
+    ~Stack(void);               //Omitting "void" doesn't help
+}; 
+
+template<class T> Stack<T>::~Stack(void) 
+{ }
+
+//If this definition comes before the one for ~Stack, the error message
+//about redeclaration of `void Stack<int>::~Stack()' will not occur.
+template<class T> Stack<T>::Stack(int s)
+{ }
+
+int main () {
+    Stack<int> stk(10);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template16.C b/gcc/testsuite/g++.old-deja/g++.brendan/template16.C
new file mode 100644
index 00000000000..ec13a24f86e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template16.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed templates
+template<class T> class TList {
+   typedef void (T::*TVOIDFUNT)();
+   typedef T*   (T::*TTPFUNT)(T*);
+};
+
+class A;
+class B : TList<A> { };
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template17.C b/gcc/testsuite/g++.old-deja/g++.brendan/template17.C
new file mode 100644
index 00000000000..e6c2652dce5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template17.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed templates
+struct Regex { int i; Regex(char *, int); };
+template<class KEY>
+class NDAMName {
+public:
+    static const Regex pattern;
+    static unsigned sequence_number;
+};
+
+const Regex NDAMName<'L'>::pattern("^[Ll](.*)$",   1);// ERROR -  type/value.*
+unsigned NDAMName<'L'>::sequence_number = 0;// ERROR -  type/value
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template18.C b/gcc/testsuite/g++.old-deja/g++.brendan/template18.C
new file mode 100644
index 00000000000..5c6479cbffc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template18.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed templates
+template<class T> class X;
+typedef X<int> IX;
+
+template<class T>
+class X {
+public:
+  T x;
+};
+
+struct A {
+  IX c;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template19.C b/gcc/testsuite/g++.old-deja/g++.brendan/template19.C
new file mode 100644
index 00000000000..a8b33c1b4dd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template19.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+// GROUPS passed templates
+template <class T>
+class Base
+{
+public:
+    Base() { }
+};
+
+template <class memberType, class keyType>
+class Middle : public Base<memberType>
+{
+public:
+    Middle (keyType const & (*ko) (memberType const &))
+    {
+    }
+};
+
+// EXCHANGE the following lines for this code to work.
+//template <class memberType, class keyType> class Middle;
+template <class T, class keyType> class Middle;
+
+struct Test : public Middle <int, int>
+{
+    Test();
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template2.C b/gcc/testsuite/g++.old-deja/g++.brendan/template2.C
new file mode 100644
index 00000000000..ca60fa7e95a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template2.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed templates
+template <class Q>
+class Conc {
+public:
+	static int body();
+};
+
+template <class Q>
+int Conc<Q>::body() {return 0;}
+
+int main () {
+	Conc<int> s2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template20.C b/gcc/testsuite/g++.old-deja/g++.brendan/template20.C
new file mode 100644
index 00000000000..da26f9a756c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template20.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed templates
+template <class A, class B> class Map;
+
+class Foo
+{
+public:
+    static Map<int,int> bar;
+};
+
+template <class A, class B>
+class Map
+{
+public :
+    int find();
+};
+
+int main()
+{
+    int z = Foo::bar.find();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template21.C b/gcc/testsuite/g++.old-deja/g++.brendan/template21.C
new file mode 100644
index 00000000000..9d6139191e0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template21.C
@@ -0,0 +1,43 @@
+// Build don't link: 
+// GROUPS passed templates
+template<class T>
+class L {
+public:
+    L();
+
+    T x[30];
+    int doit(int i) const;
+};
+
+#ifdef BUG
+template<class T>
+int
+L<T>::doit(int i) const
+{
+    return x[i].z;
+}
+#endif
+
+class X {
+public:
+    class Y {
+    public:
+        Y();
+        Y(int);
+
+        int z;
+    };
+    
+    L<Y> ly;
+};
+
+#ifndef BUG
+template<class T>
+int
+L<T>::doit(int i) const
+{
+    return x[i].z;
+}
+#endif
+
+static X x;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template22.C b/gcc/testsuite/g++.old-deja/g++.brendan/template22.C
new file mode 100644
index 00000000000..28c70b34301
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template22.C
@@ -0,0 +1,22 @@
+// GROUPS passed templates
+extern "C" int printf (const char *, ...);
+
+template <class T>
+class Foo
+{
+public:
+  void func (int const& i);
+};
+
+template <class T>
+void Foo<T>::
+func (int const& i)
+{}
+
+
+int main ()
+{ 
+  Foo<int const> foo;
+  printf ("PASS\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template23.C b/gcc/testsuite/g++.old-deja/g++.brendan/template23.C
new file mode 100644
index 00000000000..f38d4204685
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template23.C
@@ -0,0 +1,34 @@
+// Build don't link: 
+// GROUPS passed templates
+template <class T>
+class T_Base
+{};
+
+template <class T>
+class T_Derived
+: public T_Base<T>
+{};
+
+
+class Base
+{
+public:
+  Base (float name);
+};
+
+class Derived
+: public Base
+{
+private:
+  T_Base<int>*	data_;	// Fix (1): Change date_ from T_Base<int>* to T_Derived<int>*
+  
+public:
+  Derived (float name); 
+};
+
+
+Derived::
+Derived (float name)
+:  Base(name),
+   data_(new T_Derived<int>()) 
+{}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template24.C b/gcc/testsuite/g++.old-deja/g++.brendan/template24.C
new file mode 100644
index 00000000000..34549a001d7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template24.C
@@ -0,0 +1,20 @@
+// GROUPS passed templates
+extern "C" void printf (char *, ...);
+
+template <class F>
+class Temp
+{
+  F  func_;
+public:
+  Temp (F f) :func_(f) {}
+};
+
+int func (int h = 1, int z = 2) { return h+z; }
+
+int main ()
+{
+  Temp<int(*)(int, int)> temp (func);
+
+  printf ("PASS\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template25.C b/gcc/testsuite/g++.old-deja/g++.brendan/template25.C
new file mode 100644
index 00000000000..5939fed5b89
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template25.C
@@ -0,0 +1,36 @@
+// Build don't link: 
+// GROUPS passed templates
+template <class T>
+class Temp_Base
+{};
+
+template <class T>
+class Temp_Derived
+: public Temp_Base<T>
+{
+public:
+  Temp_Derived (int i = 10) {}
+};
+
+
+class Base
+{
+  float r_;
+public:
+  Base (float r) : r_(r) {}
+};
+
+class Derived
+: public Base
+{
+private:
+  Temp_Base<int>*  boo_;	   
+public:
+  Derived (float);
+};
+
+Derived::
+Derived (float form)
+: Base(form),
+  boo_(new Temp_Derived<int>)
+{}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template26.C b/gcc/testsuite/g++.old-deja/g++.brendan/template26.C
new file mode 100644
index 00000000000..6dc15551f81
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template26.C
@@ -0,0 +1,31 @@
+// Build don't link: 
+// GROUPS passed templates
+class V {
+ public:
+  V();
+  V(int);
+  };
+
+template <int I> class AA: public virtual V {
+ public:
+  AA();
+  AA(int);
+  };
+
+template <int I> class BB : public virtual V {
+ public:
+  BB();
+  BB(int);
+  };
+
+template <int I> AA<I>::AA() {};
+template <int I> AA<I>::AA(int i): V(i) {};
+template <int I> BB<I>::BB() {};
+template <int I> BB<I>::BB(int i) {};
+
+class CC : public AA<1>, public BB<2> {
+ public:
+  CC();
+  CC(int);
+  };
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template27.C b/gcc/testsuite/g++.old-deja/g++.brendan/template27.C
new file mode 100644
index 00000000000..a2649d439e0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template27.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed templates
+        template<class K, class V> class MapLS { };
+        class String {};
+        class X1 { };
+        class RefProto { };
+        template<class REP> class Ref { };
+        
+        class MapLS<String, Ref<X1> >: public MapLS<String, RefProto> {
+        public:
+            ~MapLS();
+        };
+        
+        MapLS<String, Ref<X1> >::~MapLS() { }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template28.C b/gcc/testsuite/g++.old-deja/g++.brendan/template28.C
new file mode 100644
index 00000000000..48ae7fbf2fc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template28.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed templates
+class X {
+        const char *fptr;
+public:
+        X(const char *ptr) { fptr = ptr; }
+        operator const char*() { return fptr; }
+};
+
+int main(){
+        X x1("1234");
+        X x2(x1+1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template29.C b/gcc/testsuite/g++.old-deja/g++.brendan/template29.C
new file mode 100644
index 00000000000..2c427d912bf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template29.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed templates
+   template <class ElementType> class A
+    { public:
+       A(ElementType) {}
+       ElementType get() const ;
+    };
+
+    template <class ElementType> ElementType A<ElementType>::get() const
+    { return ElementType(0); }
+
+int main() { const A<short> a(3); }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template3.C b/gcc/testsuite/g++.old-deja/g++.brendan/template3.C
new file mode 100644
index 00000000000..3900421d12f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template3.C
@@ -0,0 +1,49 @@
+// GROUPS passed templates
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+int count = 0;
+
+void
+die (int x)
+{
+  if (x != ++count)
+    {
+      printf ("FAIL\n");
+      exit (1);
+    }
+}
+
+class A {
+  public:
+    void   f() const { die (-1); }
+};
+
+
+template <class Item>
+class B : public A {
+  public:
+  void f() const;
+};
+
+template <class Item>
+inline void B<Item>::f() const { die (1); }
+
+template <class Item>
+class C : public A {
+  public:
+    void f() const { die (2); }
+};
+
+
+int main()
+{
+    B<int> b;
+    C<int> c;
+
+    b.f(); //- bugged, (A::f() called instead of B::f())
+    c.f(); //- works fine (C::f() called)
+
+    printf ("PASS\n");
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template30.C b/gcc/testsuite/g++.old-deja/g++.brendan/template30.C
new file mode 100644
index 00000000000..97357d63a80
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template30.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed templates
+
+        template<class K, class V> class MapLS { };
+        class String {};
+        class X1 { };
+        class RefProto { };
+        template<class REP> class Ref { };
+        
+        class MapLS<String, Ref<X1> >: public MapLS<String, RefProto> {
+        public:
+            ~MapLS();
+        };
+        
+        MapLS<String, Ref<X1> >::~MapLS() { }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template31.C b/gcc/testsuite/g++.old-deja/g++.brendan/template31.C
new file mode 100644
index 00000000000..3a1b149fb93
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template31.C
@@ -0,0 +1,38 @@
+// Build don't link: 
+// GROUPS passed templates
+// PRMS Id: 13218
+
+struct C {
+        int x;
+        char y;
+        double z;
+};
+C c02;
+
+template <int* ip> struct A {
+        int* p;
+        A() : p(ip) {}
+};
+
+template <C* cp> struct B {
+        C* p;
+        B() : p(cp) {}
+};
+
+int i00;
+
+int main(void)
+{
+        A<&i00> a00;
+
+        extern int i01;
+        A<&i01> a01;
+
+        B<&c02> b02;
+
+        extern C c03;
+        B<&c03> b03;
+}
+
+int i01;
+C c03;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template4.C b/gcc/testsuite/g++.old-deja/g++.brendan/template4.C
new file mode 100644
index 00000000000..318cd2e10d0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template4.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed templates
+// This used to be a circularity in chainon.
+template <class ARG> struct TMPL {
+    typedef int ARG::*ARG_data_member_ptr;
+    typedef void (ARG::*ARG_func_member_ptr) ();
+};
+
+struct S { };
+
+TMPL<S> object;
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template5.C b/gcc/testsuite/g++.old-deja/g++.brendan/template5.C
new file mode 100644
index 00000000000..39b74d6a4df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template5.C
@@ -0,0 +1,48 @@
+// Build don't link: 
+// GROUPS passed templates
+template<class T>
+class Vector
+{
+public:
+    Vector(int x);
+    ~Vector();
+    T& operator [] (int i);
+
+private:
+    T* v;
+    int sz;
+} ;
+
+template<class T>
+Vector<T>::Vector(int x)
+{
+    sz = x;
+    v = new T (sz);
+} ;
+
+template<class T>
+Vector<T>::~Vector()
+    { delete [] v; } ;
+
+template<class T>
+T &
+Vector<T>::operator [] (int i)
+    { return v[i]; } ;
+
+int
+main(int, char **)
+{
+    Vector<int> intvec(3);
+
+    intvec[0] = 1;
+    intvec[1] = 2;
+    intvec[2] = 3;
+
+    for (int i = 0; i < 3; i++)
+	intvec[i];
+
+    return 0;
+}
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template6.C b/gcc/testsuite/g++.old-deja/g++.brendan/template6.C
new file mode 100644
index 00000000000..96459ca355d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template6.C
@@ -0,0 +1,30 @@
+// Build don't link: 
+// GROUPS passed templates
+struct B {
+};
+
+struct X : B {
+  ~X ();
+};
+
+struct Request {
+  X s;
+};
+
+template <class ET> class TC {
+  ET data;
+};
+
+struct TMem {
+
+  ~TMem() {}
+
+  TC<Request> *req;
+};
+
+struct FIO {
+
+  void init ();
+
+  FIO () { init(); }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template7.C b/gcc/testsuite/g++.old-deja/g++.brendan/template7.C
new file mode 100644
index 00000000000..59dc4835632
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template7.C
@@ -0,0 +1,48 @@
+// Build don't link: 
+// GROUPS passed templates
+template <class ET>
+class ChainElem {
+public:
+  
+  ET data;
+};
+
+template <class ET>
+class Chain {
+public:
+
+  ChainElem<ET> *first;
+
+  virtual ~Chain() {}
+
+};
+
+struct B {
+};
+
+struct X : B {
+  ~X ();
+};
+
+struct TBNFexpression {
+};
+
+struct TCaseLabelPair {
+};
+
+struct TVariant {  
+  Chain<TCaseLabelPair> CaseLabelList;
+};
+
+struct TCaseConstruct {
+  Chain<TBNFexpression> TagFieldPrefixes;
+  Chain<TVariant> Variants;
+};
+
+struct Production {
+  X TypeName;
+};
+
+struct SimpleSyntax {
+  Chain<Production> Productions;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template8.C b/gcc/testsuite/g++.old-deja/g++.brendan/template8.C
new file mode 100644
index 00000000000..80adbe1a05c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template8.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed templates
+#include <stdio.h>
+
+// make sure we accept unions for templates
+template<int n>
+union Double_alignt{
+	double for_alignt;
+	char array[n];
+
+};
+
+int main(){
+
+	
+	Double_alignt<20000> heap;
+
+	printf(" &heap.array[0] = %d, &heap.for_alignt = %d\n", &heap.array[0], &heap.for_alignt);
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/template9.C b/gcc/testsuite/g++.old-deja/g++.brendan/template9.C
new file mode 100644
index 00000000000..c4c9c831157
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/template9.C
@@ -0,0 +1,20 @@
+// GROUPS passed templates
+// Test that the compiler will emit the definition of min given just
+// the declaration.  At one point in the past, it did not.
+// Special g++ Options: -fguiding-decls
+#include <iostream.h>
+
+template <class T> inline T min(T a, T b) { return (a < b) ? a : b;};
+
+double min(double,double);	// this should expand the template
+
+main () {
+    int a = 1, b = 2;
+    double aa = 2.0, bb = 1.2;
+    cout << min(a,b) << ", " << min(aa,bb) << "\n";
+    if (min (a, aa) == a)
+      cout << "PASS" << endl;
+    else
+      cout << "FAIL" << endl;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/temporary1.C b/gcc/testsuite/g++.old-deja/g++.brendan/temporary1.C
new file mode 100644
index 00000000000..8c6d4c38455
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/temporary1.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed temporaries
+#include <stdio.h>
+
+int main ()
+{
+        int a = 2;
+
+        if (----a == 0)
+                printf ("a = 0\n");
+
+        printf ("a = %d\n", a);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/typedef1.C b/gcc/testsuite/g++.old-deja/g++.brendan/typedef1.C
new file mode 100644
index 00000000000..2f7aa87b122
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/typedef1.C
@@ -0,0 +1,29 @@
+// Build don't link: 
+
+class baseClassA
+{
+public:
+private:
+	class internalClassA
+	{
+	public:
+	private:
+		typedef int privateType;
+
+		privateType memberA;
+	};
+};
+
+class baseClassB
+{
+public:
+private:
+	class internalClassA
+	{
+	public:
+	private:
+		typedef unsigned int privateType;
+
+		privateType memberB;
+	};
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/union1.C b/gcc/testsuite/g++.old-deja/g++.brendan/union1.C
new file mode 100644
index 00000000000..7a4df261dbf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/union1.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed unions
+// This is fixed by finish_anon_union doing a string_cst_equal check on
+// the DECL_SIZE of the decls, instead of comparing the DECL_SIZE nodes.
+     unsigned
+     hash(const double d)
+     {
+        static union {
+           unsigned asint[2];
+           double asdouble;
+        };
+        asdouble = d;
+        return asint[0] ^ asint[1];
+     }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/union2.C b/gcc/testsuite/g++.old-deja/g++.brendan/union2.C
new file mode 100644
index 00000000000..d913ae80321
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/union2.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed unions
+class B;
+ 
+struct A {
+    A(B* x) : i(x) {}
+    A() : i(0) {}
+ 
+    union {
+        B* i;
+        B* c;
+    };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/union3.C b/gcc/testsuite/g++.old-deja/g++.brendan/union3.C
new file mode 100644
index 00000000000..ad8b840b4bf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/union3.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed unions
+union alan {
+int a;
+char *b;
+alan();
+};
+ 
+alan mary;
+ 
+alan::alan()
+{
+        a=0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/visibility1.C b/gcc/testsuite/g++.old-deja/g++.brendan/visibility1.C
new file mode 100644
index 00000000000..784c16772ea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/visibility1.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed visibility
+class foo {
+protected:
+  int i; // ERROR - protected
+};
+
+class bar : public foo {
+public:
+  friend void baz (foo *);
+};
+
+void baz (foo *f)
+{
+  f->i = 1;	// error: i is protected// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/visibility10.C b/gcc/testsuite/g++.old-deja/g++.brendan/visibility10.C
new file mode 100644
index 00000000000..4eb3cae8050
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/visibility10.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed visibility
+struct base
+{
+    protected:
+        void base_func() {}// ERROR - .*is protected.*
+};
+
+struct derived : public base
+{
+    protected:
+        void derived_func(base *ptr) { ptr->base_func(); }// ERROR -  within this context
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/visibility2.C b/gcc/testsuite/g++.old-deja/g++.brendan/visibility2.C
new file mode 100644
index 00000000000..09e0f6591ae
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/visibility2.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed visibility
+class X {
+      void g (int); // ERROR - private
+public:
+  void g (double);
+};
+	
+class Y : public X { void f() { g (1); } }; // ERROR - private
+
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/visibility3.C b/gcc/testsuite/g++.old-deja/g++.brendan/visibility3.C
new file mode 100644
index 00000000000..6e84da5ac51
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/visibility3.C
@@ -0,0 +1,38 @@
+// Build don't link: 
+// GROUPS passed visibility
+// Used to say:
+// manip.cc:17: member `_f' is a private member of class `B<int>'
+// manip.cc:17: member `_a' is a private member of class `B<int>'
+
+class A {};
+
+template <class TP>
+class B
+{
+  A &(*_f) (A &, TP);
+  TP _a;
+public:
+  B (A &(*f) (A &, TP), TP a) : _f (f), _a (a) {}
+  friend A &operator<< <>(A &o, const B<TP> &m);
+};
+
+template <class TP>
+inline A &
+operator<< (A &o, const B<TP> &m)
+{
+  (*m._f) (o, m._a);
+  return o;
+}
+
+A &setw (A &, int);
+B<int> setw (int n)
+{
+  return B<int> (setw, n);
+}
+
+A x;
+
+void f ()
+{
+  x << setw (2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/visibility4.C b/gcc/testsuite/g++.old-deja/g++.brendan/visibility4.C
new file mode 100644
index 00000000000..1e7aea1e10c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/visibility4.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed visibility
+template <class T> 
+class Feld {
+public:
+  Feld(const Feld&) {}
+};
+
+class Polynom : private Feld<double> {
+  Polynom();
+  friend Polynom f(const Polynom&);
+};
+
+Polynom f(const Polynom& p) { return p; }    
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/visibility5.C b/gcc/testsuite/g++.old-deja/g++.brendan/visibility5.C
new file mode 100644
index 00000000000..a53881a641e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/visibility5.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+// GROUPS passed visibility
+template<int K> class B;
+template<int K> class A {int n; friend class B<K>;};
+template<int K> class B {public: void method(A<K>) const;};
+template<int K> void B<K>::method(A<K> X) const {X.n=0;}
+typedef B<2> B2;
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/visibility6.C b/gcc/testsuite/g++.old-deja/g++.brendan/visibility6.C
new file mode 100644
index 00000000000..85f47b5f89d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/visibility6.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed visibility
+class bottom
+{
+public:
+  int b; // ERROR - private
+};
+class middle : private bottom
+{
+public:
+  void foo () { b; }
+};
+class top : public middle
+{
+public:
+  void bar () { b; }// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/visibility7.C b/gcc/testsuite/g++.old-deja/g++.brendan/visibility7.C
new file mode 100644
index 00000000000..670547dd2e3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/visibility7.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed visibility
+class X
+{
+public:
+  void fn ();// ERROR - .*
+};
+class Y : private X
+{};
+
+class Unrelated
+{
+public:
+  void foo () { Y y; y.fn (); }// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/visibility8.C b/gcc/testsuite/g++.old-deja/g++.brendan/visibility8.C
new file mode 100644
index 00000000000..2d69e7bcf01
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/visibility8.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed visibility
+// Make sure private inheritance affects the visibility of
+// static members used in an inherited context.
+class foo
+{
+public:
+  static int y; // ERROR - private
+};
+class foo1 : private foo
+{ };
+class foo2 : public foo1
+{ public:
+  void bar () { y; }// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/visibility9.C b/gcc/testsuite/g++.old-deja/g++.brendan/visibility9.C
new file mode 100644
index 00000000000..c2599291dc8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/visibility9.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed visibility
+class A {
+public:
+        void aMethod(void) {};// ERROR - .*
+};
+
+class AA : A { };
+
+class B {
+public:
+        void thisMethod() {
+                AA ana;
+                ana.aMethod();// ERROR - .*
+        }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/vtables1.C b/gcc/testsuite/g++.old-deja/g++.brendan/vtables1.C
new file mode 100644
index 00000000000..984ce18ce6b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/vtables1.C
@@ -0,0 +1,42 @@
+// GROUPS passed virtual-tables
+// Check that virtual function tables are generated and used
+// even for struct's/classes which have no explicit constructors.
+
+extern "C" void printf (char *, ...); 
+
+int base_func_member_1_called = 0;
+int derived_func_member_1_called = 0;
+
+struct base {
+	virtual void func_member_1 ()
+	{
+		base_func_member_1_called++;
+	}
+};
+
+struct derived : public base {
+	virtual void func_member_1 ()
+	{
+		derived_func_member_1_called++;
+	}
+
+	virtual void func_member_2 ()
+	{
+	}
+};
+
+base* bp1;
+base* bp2;
+
+int main ()
+{
+	bp1 = new base;
+	bp2 = new derived;
+
+	bp1->func_member_1 ();
+	bp2->func_member_1 ();
+
+	printf ("PASS\n");
+
+	return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/warnings1.C b/gcc/testsuite/g++.old-deja/g++.brendan/warnings1.C
new file mode 100644
index 00000000000..02963623a22
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/warnings1.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed warnings
+// there should be a warning about foo only defining private methods
+class foo {
+  int bar();
+};// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/warnings10.C b/gcc/testsuite/g++.old-deja/g++.brendan/warnings10.C
new file mode 100644
index 00000000000..78ddf77d856
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/warnings10.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed warnings
+void foo()
+{
+  int i;
+  if (1) {
+    for (int i = 0; i < 10; i++)
+      ;
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/warnings2.C b/gcc/testsuite/g++.old-deja/g++.brendan/warnings2.C
new file mode 100644
index 00000000000..49971d58356
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/warnings2.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed warnings
+class K {
+public:
+        void f() {
+        }; // there should be no warning about this semicolon
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/warnings3.C b/gcc/testsuite/g++.old-deja/g++.brendan/warnings3.C
new file mode 100644
index 00000000000..14fe9978547
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/warnings3.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// Special g++ Options: -O2 -Wall
+// GROUPS passed warnings
+class A {
+int i;
+public:
+        void funcA(void) { 
+                funcB(); 
+        }
+
+	// The compiler should not emit a warning about not being
+	// able to inline this function.
+        void funcB(void) { 
+                i++; 
+        }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/warnings4.C b/gcc/testsuite/g++.old-deja/g++.brendan/warnings4.C
new file mode 100644
index 00000000000..d733522824e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/warnings4.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed warnings
+int
+main ()
+{
+  register int x;
+  int * foo = &x; // in C++ it's perfectly legal to do this
+
+  return 0;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/warnings5.C b/gcc/testsuite/g++.old-deja/g++.brendan/warnings5.C
new file mode 100644
index 00000000000..5a953fd1c54
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/warnings5.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed warnings
+enum TypeKind { ATK, BTK } ;
+
+struct Type {
+  enum TypeKind kind : 8;
+  void setBTK();
+};
+
+void Type::setBTK() { kind = BTK; }
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/warnings6.C b/gcc/testsuite/g++.old-deja/g++.brendan/warnings6.C
new file mode 100644
index 00000000000..785c083464a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/warnings6.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// Special g++ Options: -O2 -Wall -ansi -pedantic
+// GROUPS passed warnings
+// should not emit this warning about func:
+// 	x.C:2: warning: invalid storage class for function `func'
+//
+template <class T> inline void func(T)
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/warnings7.C b/gcc/testsuite/g++.old-deja/g++.brendan/warnings7.C
new file mode 100644
index 00000000000..24e7a2cde0d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/warnings7.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// Special g++ Options: -O2 -Wall
+// GROUPS passed warnings
+template<class T>
+class X {
+public:
+    void kill(unsigned i)
+	{ vec[i].~T(); }
+    T *vec;
+};
+
+class Y { };
+
+void
+x()
+{
+    X<int> x;
+    x.kill(0);
+    X<Y> y;
+    y.kill(0);
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/warnings8.C b/gcc/testsuite/g++.old-deja/g++.brendan/warnings8.C
new file mode 100644
index 00000000000..5599918fd12
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/warnings8.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// Special g++ Options: -Wall
+// GROUPS passed warnings
+bool foo(unsigned char c)
+{
+  return (c & 17) != 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.brendan/warnings9.C b/gcc/testsuite/g++.old-deja/g++.brendan/warnings9.C
new file mode 100644
index 00000000000..c46f2a1e45d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.brendan/warnings9.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// Special g++ Options: -Wall
+// GROUPS passed warnings
+inline int foo()
+{
+  return 3;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/891229_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/891229_02.C
new file mode 100644
index 00000000000..042096c81b9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/891229_02.C
@@ -0,0 +1,24 @@
+// g++ 1.36.1 bug 891229_02
+
+// g++ limits the scope of names which are declared as typedef names within
+// another type to that other type.
+
+// This conflicts with the (global) scope given to such names by cfront 2.0.
+
+// Cfront 2.0 passes this test.
+
+// Note 2/15/94:  The standard has changed; this limiting of scope is correct
+// behavior.  See 9.9.  --jason
+
+// keywords: typedef, nested types, scope
+
+struct foo {
+	foo ();
+	typedef void (*function_p) (void);
+};
+
+function_p fp;		// ERROR - no such type in scope
+
+foo::foo () {}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/891230_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/891230_01.C
new file mode 100644
index 00000000000..ac49e0bd444
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/891230_01.C
@@ -0,0 +1,20 @@
+// g++ 1.36.1 bug 891230_01
+
+// g++ gives typedefs which are nested within class declarations a scope
+// which is local to the class declaration itself.  This causes examples
+// like the following to get compile-time errors.
+
+// Cfront 2.0 passes this test.
+
+// keywords: typedef, nested types, scope
+
+struct foo {
+
+    typedef foo* foo_p;
+    void member (foo_p);
+};
+
+void foo::member (foo_p p) {	// gets bogus errors
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900107_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900107_01.C
new file mode 100644
index 00000000000..7271f1aa71e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900107_01.C
@@ -0,0 +1,37 @@
+// g++ 1.36.1 bug 900107_01
+
+// Unlike GCC and Cfront 2.0, the g++ 1.36.1 compiler gives struct, union,
+// and class declarations which are nested within blocks file scope.
+
+// Cfront 2.0 passes this test.
+
+// keywords: block scope, file scope, nested types, tagged types
+
+class c1 { int c1_member1; };
+struct s1 { int s1_member1; };
+union u1 { int u1_member1; };
+enum e1 { e1_val1 };
+typedef int t1;
+
+void foo ()
+{
+  class c1 {			// gets bogus error
+    int c1_member1;
+  } c1_local_object_0;
+
+  struct s1 {			// gets bogus error
+    int s1_member1;
+  } s1_local_object_0;
+
+  union u1 {			// gets bogus error
+    int u1_member1;
+  } u1_local_object_0;
+
+  enum e1 {		// OK using g++ or GCC, but mishandled by Cfront 2.0.
+    e1_value1
+  } e1_local_object_0;
+
+  typedef int t1;		// OK
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900119_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900119_01.C
new file mode 100644
index 00000000000..3c93c525997
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900119_01.C
@@ -0,0 +1,46 @@
+// g++ 1.36.1 bug 900119_01
+
+// g++ allows initializers to be included in the declaration of members
+// of classes, structs, unions (even when -pedantic is used).
+
+// This is not allowed by the C++ 2.0 Reference Manual or by Cfront 2.0.
+
+// keywords: member declaration, member initialization
+
+int global_int;
+
+class class0 {
+public:
+  int class0_member_0 = 99;			/* ERROR -  */
+  static int class0_member_1 = 99;		/* ERROR -  */
+  int &class0_member_2 = global_int;		/* ERROR -  */
+
+  class0 () : class0_member_2 (global_int) { }  /* ERROR -  */
+};
+
+
+struct struct0 {
+  int struct0_member_0 = 99;			/* ERROR -  */
+  static int struct0_member_1 = 99;		/* ERROR -  */
+  int &struct0_member_2 = global_int;		/* ERROR -  */
+
+  struct0 () : struct0_member_2 (global_int) { } /* ERROR -  */
+};
+
+// g++ does not allow unions to have more than one member with an initializer
+
+union union0 {
+  int union0_member_0 = 99;			/* ERROR -  */
+};
+
+union union1 {
+  //static int union1_member_0 = 99;		/* definitely illegal (9.5) */
+};
+
+union union2 {
+  int &union2_member_0 = global_int;		/* ERROR -  */
+
+  union2 () : union2_member_0 (global_int) { }  /* ERROR -  */
+};
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900121_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900121_01.C
new file mode 100644
index 00000000000..ea07968c3a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900121_01.C
@@ -0,0 +1,16 @@
+// g++ 1.36.1 bug 900121_01
+
+// The following file causes g++ 1.36.1 (and 1.36.2) to abort.
+
+// Cfront 2.0 passes this test.
+
+// keywords: abort, incomplete types, reference types, formal parameters
+
+struct s0;              // ERROR - forward declaration
+
+void function (struct s0 &arg1, struct s0 &arg2)
+{
+  arg1 = arg2;		// ERROR - causes abort
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900121_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900121_02.C
new file mode 100644
index 00000000000..c90dfd9aaa4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900121_02.C
@@ -0,0 +1,49 @@
+// g++ 1.36.1 bug 900121_02
+
+// Assignment of structs is defined as memberwise assignment,
+// however g++ (1.36.2) and Cfront 2.0 differ on the definition
+// of assignment for unions.
+
+// (NOTE: Stroustrup now says that assignment of unions which contain either
+// members or sub-members (base classes are not allowed for unions) which
+// have non-default assignment operators defined for them will be illegal
+// in future.)
+
+// g++ (1.36.2) on the other hand, accepts this program without errors.
+
+// keywords: unions, operator=, inheritance, members
+
+struct s0 {
+
+  int i;
+
+  void operator= (s0 & arg)
+  {
+    this->i = arg.i;
+  }
+};
+
+struct s1 {
+
+  double d;
+
+  void operator= (s1 & arg)
+  {
+    this->d = arg.d;
+  }
+};
+
+union u0 {
+  s0 u0_member_0;		// ERROR - 
+  s1 u0_member_1;		// ERROR - 
+};
+
+void function ()
+{
+  u0 u0_object_0;
+  u0 u0_object_1;
+
+  u0_object_0 = u0_object_1;
+};
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900121_05.C b/gcc/testsuite/g++.old-deja/g++.bugs/900121_05.C
new file mode 100644
index 00000000000..03155abf52e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900121_05.C
@@ -0,0 +1,30 @@
+// g++ 1.36.1 bug 900121_05
+
+// g++ allows unions to have base types (i.e. to be "derived") and it allows
+// other types to have unions as base types.  Both cases are illegal.
+
+// g++ curently does not detect such errors.
+
+// Cfront 2.0 passes this test.
+
+// keywords: unions, inheritance
+
+struct s0 {
+  int s0_member;
+};
+
+union u0 : public s0 {			/* ERROR - union has base class */
+  int u0_member_0;
+  int u0_member_1;
+};
+
+union u1 {
+  int u1_member_0;
+  int u1_member_1;
+};
+
+struct s1 : public u1 {			/* ERROR - base class is a union */
+  int s1_member_0;
+};
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900127_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900127_01.C
new file mode 100644
index 00000000000..7c24d08bc10
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900127_01.C
@@ -0,0 +1,25 @@
+// g++ 1.36.1 bug 900127_01
+
+// g++ often fails to detect (and issue errors for) ambiguous overload
+// situations.  In such cases, one of the possibilities is chosen
+// (apparently arbitrarily). Errors should be issued instead.
+
+// Cfront 2.0 passes this test.
+
+// keywords: function overloading, ambiguity
+
+void foo (int);
+int foo (void);
+
+typedef int (*f_ptr_t1) (void);
+typedef void (*f_ptr_t2) (int);
+
+void bar (f_ptr_t1);		// ERROR - 
+void bar (f_ptr_t2);		// ERROR - 
+
+void function ()
+{
+  bar (foo);			// ERROR - ambiguous
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900127_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900127_02.C
new file mode 100644
index 00000000000..61cd481cecc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900127_02.C
@@ -0,0 +1,46 @@
+// g++ 1.36.1 bug 900127_02
+
+// g++ (mostly) keeps separate name spaces for the declarations of data
+// objects and functions.
+
+// This means that a single name may be declared as both a data object and
+// a function within a given scope.
+
+// This fact allows programmers to write code which is not portable to the
+// Cfront translator (which keeps a single namespace for these entities).
+
+// This can also lead to ambiguity when the & (address-of) operator is used.
+
+// Cfront 2.0 passes this test.
+
+// keywords: name spaces, overloading
+
+int global0;			// ERROR - 
+int global0 ();			// ERROR - 
+
+int global1 ();			// ERROR - xref for below
+int global1;			// ERROR - caught
+
+struct struct_0 {
+  int class_local ();		// ERROR - 
+  int class_local;		// ERROR - 
+};
+
+struct struct_1 {
+  int class_local;		// ERROR - 
+  int class_local ();		// ERROR - 
+};
+
+void function_0 ()
+{
+	int function_0_local;	// ERROR - 
+	extern int function_0_local ();	// ERROR - 
+}
+
+void function_1 ()
+{
+	int function_1_local ();        // ERROR - 
+	extern int function_1_local;	// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900205_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900205_02.C
new file mode 100644
index 00000000000..505792f0dfa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900205_02.C
@@ -0,0 +1,28 @@
+// g++ 1.36.1 bug 900205_02
+
+// g++ allows constructors to be defined which do not include
+// initializations for reference members of their associated classes.
+
+// Cfront 2.0 does not allow this.
+
+// keywords: reference members, constructors, member initialization
+
+int i;
+
+class c0 {
+  int &int_ref;
+public:
+  c0 () /* : int_ref(i) */ {	// ERROR - reference needs initializer
+  }
+};
+
+class c1 {
+  int &int_ref;
+public:
+  c1 ();
+};
+
+c1::c1() /* : int_ref(i) */ {	// ERROR - reference needs initializer
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900205_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900205_03.C
new file mode 100644
index 00000000000..4c352c87ae4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900205_03.C
@@ -0,0 +1,48 @@
+// g++ 1.36.1 bug 900205_03
+
+// Section 6.6.3 of the cfront 2.0 Reference Manual says "A return statement
+// without an expression can be used only in functions that do not return
+// a value, that is, a function with the return value type void..."
+
+// Also in 6.6.3: "Flowing off the end of a function is equivalent to a
+// return with no value; this is illegal in a value returning function."
+
+// In contrast to the manual, g++ does not generate ERRORs for cases of
+// "flowing off the end" of non-void functions.
+
+// keywords: return statements, return type, void return, implicit return
+
+// Special g++ Options: -Wreturn-type -pedantic-errors
+
+struct struct00 { };
+
+int global_function_0 () {
+}					// ERROR - 
+
+struct00 global_function_1 () {
+}					// ERROR - 
+
+struct struct0 {
+
+  int struct0_member_function_0 () {
+  }					// ERROR - 
+
+  struct0 struct0_member_function_1 () {
+  }					// ERROR - 
+};
+
+struct struct1 {
+
+  int struct1_member_function_0 ();
+
+  struct1 struct1_member_function_1 ();
+
+};
+
+int struct1_member_function_0 () {
+}					// ERROR - 
+
+struct1 struct1::struct1_member_function_1 () {
+}				        // ERROR - 
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900205_04.C b/gcc/testsuite/g++.old-deja/g++.bugs/900205_04.C
new file mode 100644
index 00000000000..f763480d45f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900205_04.C
@@ -0,0 +1,26 @@
+// g++ 1.36.1 bug 900205_04
+
+// g++ allows a class for which an implicit default X::X() constructor must
+// be created (implicitly by the compiler) to be derived from another class
+// which does not have its own default X::X() constructor.  This is illegal.
+
+// Cfront 2.0 passes this test.
+
+// keywords: default constructor, inheritance
+
+struct struct0 {
+  int data_member;
+
+  struct0 (int, void *);	// suppresses implicit default constructor
+};
+
+struct0::struct0 (int, void *)
+{
+}
+
+struct struct0_derived_struct_0 : public struct0 {
+};							// ERROR - 
+
+// struct0_derived_struct_0 object;	// would give g++ error if compiled
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900207_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900207_03.C
new file mode 100644
index 00000000000..187c070acb8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900207_03.C
@@ -0,0 +1,49 @@
+// g++ 1.36.1 bug 900207_03
+
+// g++ fails to allow objects of class or struct types to be initialized
+// using "constructor syntax" in cases where an implicitly generated copy
+// constructor would be invoked for the initialization, and where there is
+// no explicitly specified constructor associated with the type of the
+// object being initialized.
+
+// Note that the type of the error changes depending upon whether or not the
+// type being initialized has any virtual functions associated with it.
+
+// Cfront 2.0 passes this test.
+
+// keywords: implicit copy constructor, initialization
+
+
+// Check construction for a type without virtual function members.
+
+struct struct0 {
+  int data_member;
+};
+
+struct0 struct0_gbl_object0;
+struct0 struct0_gbl_object1 (struct0_gbl_object0);	// gets bogus error
+
+void struct0_test ()
+{
+  struct0 struct0_lcl_object1 (struct0_gbl_object0);	// gets bogus error
+}
+
+// Check construction for a type with virtual function members.
+
+struct struct1 {
+  int data_member;
+
+  virtual void function_member ();
+};
+
+void struct1::function_member () { }
+
+struct1 struct1_gbl_object0;
+struct1 struct1_gbl_object1 (struct1_gbl_object0);	// gets bogus error
+
+void struct1_test ()
+{
+  struct1 struct1_lcl_object1 (struct1_gbl_object0);	// gets bogus error
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900208_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900208_02.C
new file mode 100644
index 00000000000..7e99abdb00f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900208_02.C
@@ -0,0 +1,17 @@
+// g++ 1.36.1 bug 900208_02
+
+// g++ does not allow a static member of a class/struct/union to be
+// declared as an array without an explicit upper bound.
+
+// Cfront 2.0 passes this test.
+
+// keywords: static data members, arrays, dimension, array bound
+
+class class0 {
+public:
+  static int class0_data_member_0[];	// gets bogus error
+};
+
+int class0::class0_data_member_0[3] = { 1, 2, 3 };  // gets bogus error
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900208_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900208_03.C
new file mode 100644
index 00000000000..667a174de22
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900208_03.C
@@ -0,0 +1,18 @@
+// g++ 1.36.1 bug 900208_03
+
+// The Cfront 2.0 reference manual (5.3.3) says "This type must be an
+// object type; functions cannot be allocated this way...".
+
+// g++ fails to detect (at compile time) cases where an attempt is made to
+// allocate a function using new.
+
+// keywords: operator new, function types
+
+typedef void (func_type) ();
+
+void global_function_0 ()
+{
+  new func_type;	// ERROR - missed by both cfront 2.0 and g++ 1.36.1
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900208_04.C b/gcc/testsuite/g++.old-deja/g++.bugs/900208_04.C
new file mode 100644
index 00000000000..bcf03973f10
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900208_04.C
@@ -0,0 +1,20 @@
+// g++ 1.36.1 bug 900208_04
+
+// The Cfront 2.0 reference manual (5.3.3) says "This type must be an
+// object type; functions cannot be allocated this way...".
+
+// g++ fails to detect (at compile time) cases where an attempt is made to
+// deallocate a function using delete.
+
+// Cfront 2.0 passes this test.
+
+// keywords: operator delete, function types
+
+typedef void (func_type) ();
+
+void global_function_1 (func_type *p)
+{
+  delete p;		// ERROR - caught by Cfront 2.0 but not by g++ 1.36.1
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900209_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900209_01.C
new file mode 100644
index 00000000000..59871ab31ed
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900209_01.C
@@ -0,0 +1,20 @@
+// g++ 1.36.1 bug 900209_01
+
+// g++ implicitly casts values whose types are "void*" to other pointer
+// types (just as the language rules for C permit).  Such implicit
+// conversions are not allowed by the Cfront 2.0 Reference Manual
+// however.
+
+// Cfront 2.0 passes this test.
+
+// keywords: void pointers, type conversions, pointer type conversions
+
+void * void_pointer_object;
+char * char_pointer_object;
+
+void global_function_0 ()
+{
+  char_pointer_object = void_pointer_object;	// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900210_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900210_01.C
new file mode 100644
index 00000000000..0a98388f915
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900210_01.C
@@ -0,0 +1,112 @@
+// g++ 1.36.1 bug 900210_01
+
+// g++ allows pointer type values to be assigned to variables of integal
+// types.  According to the C++ Reference Manual, this is illegal.
+
+// Cfront 2.0 passes this test.
+
+// keywords: pointer types, integral types, implicit type conversions
+
+int i;
+long l;
+short s;
+char c;
+float f;
+double d;
+long double ld;
+enum {enum_value_0} e;
+
+signed int si;
+signed long sl;
+signed short ss;
+signed char sc;
+
+unsigned int ui;
+unsigned long ul;
+unsigned short us;
+unsigned char uc;
+
+void* vp;
+char* cp;
+int* ip;
+enum {enum_value_1} * ep;
+struct { int member; } * sp;
+void (*fp) (void);
+
+void global_function ()
+{
+  i = vp;	/* ERROR -  */
+  i = cp;	/* ERROR -  */
+  i = ip;	/* ERROR -  */
+  i = ep;	/* ERROR -  */
+  i = sp;	/* ERROR -  */
+  i = fp;	/* ERROR -  */
+  l = vp;	/* ERROR -  */
+  l = cp;	/* ERROR -  */
+  l = ip;	/* ERROR -  */
+  l = ep;	/* ERROR -  */
+  l = sp;	/* ERROR -  */
+  l = fp;	/* ERROR -  */
+  s = vp;	/* ERROR -  */
+  s = cp;	/* ERROR -  */
+  s = ip;	/* ERROR -  */
+  s = ep;	/* ERROR -  */
+  s = sp;	/* ERROR -  */
+  s = fp;	/* ERROR -  */
+  c = vp;	/* ERROR -  */
+  c = cp;	/* ERROR -  */
+  c = ip;	/* ERROR -  */
+  c = ep;	/* ERROR -  */
+  c = sp;	/* ERROR -  */
+  c = fp;	/* ERROR -  */
+  si = vp;	/* ERROR -  */
+  si = cp;	/* ERROR -  */
+  si = ip;	/* ERROR -  */
+  si = ep;	/* ERROR -  */
+  si = sp;	/* ERROR -  */
+  si = fp;	/* ERROR -  */
+  sl = vp;	/* ERROR -  */
+  sl = cp;	/* ERROR -  */
+  sl = ip;	/* ERROR -  */
+  sl = ep;	/* ERROR -  */
+  sl = sp;	/* ERROR -  */
+  sl = fp;	/* ERROR -  */
+  ss = vp;	/* ERROR -  */
+  ss = cp;	/* ERROR -  */
+  ss = ip;	/* ERROR -  */
+  ss = ep;	/* ERROR -  */
+  ss = sp;	/* ERROR -  */
+  ss = fp;	/* ERROR -  */
+  sc = vp;	/* ERROR -  */
+  sc = cp;	/* ERROR -  */
+  sc = ip;	/* ERROR -  */
+  sc = ep;	/* ERROR -  */
+  sc = sp;	/* ERROR -  */
+  sc = fp;	/* ERROR -  */
+  ui = vp;	/* ERROR -  */
+  ui = cp;	/* ERROR -  */
+  ui = ip;	/* ERROR -  */
+  ui = ep;	/* ERROR -  */
+  ui = sp;	/* ERROR -  */
+  ui = fp;	/* ERROR -  */
+  ul = vp;	/* ERROR -  */
+  ul = cp;	/* ERROR -  */
+  ul = ip;	/* ERROR -  */
+  ul = ep;	/* ERROR -  */
+  ul = sp;	/* ERROR -  */
+  ul = fp;	/* ERROR -  */
+  us = vp;	/* ERROR -  */
+  us = cp;	/* ERROR -  */
+  us = ip;	/* ERROR -  */
+  us = ep;	/* ERROR -  */
+  us = sp;	/* ERROR -  */
+  us = fp;	/* ERROR -  */
+  uc = vp;	/* ERROR -  */
+  uc = cp;	/* ERROR -  */
+  uc = ip;	/* ERROR -  */
+  uc = ep;	/* ERROR -  */
+  uc = sp;	/* ERROR -  */
+  uc = fp;	/* ERROR -  */
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900210_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900210_02.C
new file mode 100644
index 00000000000..f900a86db0b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900210_02.C
@@ -0,0 +1,112 @@
+// g++ 1.36.1 bug 900210_02
+
+// g++ allows integral type values to be assigned to variables of pointer
+// types.  According to the C++ Reference Manual, this is illegal.
+
+// Cfront 2.0 passes this test.
+
+// keywords: integral types, pointer types, implicit type conversions
+// Special Options: -ansi -pedantic-errors
+int i;
+long l;
+short s;
+char c;
+float f;
+double d;
+long double ld;
+enum {enum_value_0} e;
+
+signed int si;
+signed long sl;
+signed short ss;
+signed char sc;
+
+unsigned int ui;
+unsigned long ul;
+unsigned short us;
+unsigned char uc;
+
+void* vp;
+char* cp;
+int* ip;
+enum {enum_value_1} * ep;
+struct { int member; } * sp;
+void (*fp) (void);
+
+void global_function ()
+{
+  vp = i;	/* ERROR -  */
+  vp = l;	/* ERROR -  */
+  vp = s;	/* ERROR -  */
+  vp = c;	/* ERROR -  */
+  vp = si;	/* ERROR -  */
+  vp = sl;	/* ERROR -  */
+  vp = ss;	/* ERROR -  */
+  vp = sc;	/* ERROR -  */
+  vp = ui;	/* ERROR -  */
+  vp = ul;	/* ERROR -  */
+  vp = us;	/* ERROR -  */
+  vp = uc;	/* ERROR -  */
+  cp = i;	/* ERROR -  */
+  cp = l;	/* ERROR -  */
+  cp = s;	/* ERROR -  */
+  cp = c;	/* ERROR -  */
+  cp = si;	/* ERROR -  */
+  cp = sl;	/* ERROR -  */
+  cp = ss;	/* ERROR -  */
+  cp = sc;	/* ERROR -  */
+  cp = ui;	/* ERROR -  */
+  cp = ul;	/* ERROR -  */
+  cp = us;	/* ERROR -  */
+  cp = uc;	/* ERROR -  */
+  ip = i;	/* ERROR -  */
+  ip = l;	/* ERROR -  */
+  ip = s;	/* ERROR -  */
+  ip = c;	/* ERROR -  */
+  ip = si;	/* ERROR -  */
+  ip = sl;	/* ERROR -  */
+  ip = ss;	/* ERROR -  */
+  ip = sc;	/* ERROR -  */
+  ip = ui;	/* ERROR -  */
+  ip = ul;	/* ERROR -  */
+  ip = us;	/* ERROR -  */
+  ip = uc;	/* ERROR -  */
+  ep = i;	/* ERROR -  */
+  ep = l;	/* ERROR -  */
+  ep = s;	/* ERROR -  */
+  ep = c;	/* ERROR -  */
+  ep = si;	/* ERROR -  */
+  ep = sl;	/* ERROR -  */
+  ep = ss;	/* ERROR -  */
+  ep = sc;	/* ERROR -  */
+  ep = ui;	/* ERROR -  */
+  ep = ul;	/* ERROR -  */
+  ep = us;	/* ERROR -  */
+  ep = uc;	/* ERROR -  */
+  sp = i;	/* ERROR -  */
+  sp = l;	/* ERROR -  */
+  sp = s;	/* ERROR -  */
+  sp = c;	/* ERROR -  */
+  sp = si;	/* ERROR -  */
+  sp = sl;	/* ERROR -  */
+  sp = ss;	/* ERROR -  */
+  sp = sc;	/* ERROR -  */
+  sp = ui;	/* ERROR -  */
+  sp = ul;	/* ERROR -  */
+  sp = us;	/* ERROR -  */
+  sp = uc;	/* ERROR -  */
+  fp = i;	/* ERROR -  */
+  fp = l;	/* ERROR -  */
+  fp = s;	/* ERROR -  */
+  fp = c;	/* ERROR -  */
+  fp = si;	/* ERROR -  */
+  fp = sl;	/* ERROR -  */
+  fp = ss;	/* ERROR -  */
+  fp = sc;	/* ERROR -  */
+  fp = ui;	/* ERROR -  */
+  fp = ul;	/* ERROR -  */
+  fp = us;	/* ERROR -  */
+  fp = uc;	/* ERROR -  */
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900210_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900210_03.C
new file mode 100644
index 00000000000..8711d868a06
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900210_03.C
@@ -0,0 +1,26 @@
+// g++ 1.36.1 bug 900210_03
+
+// g++ allows void* type values to be assigned to variables of other
+// pointer types.  According to the C++ Reference Manual, this is illegal.
+
+// Cfront 2.0 passes this test.
+
+// keywords: void pointers, pointer type conversions, implicit type conversions
+
+void* vp;
+char* cp;
+int* ip;
+enum {enum_value_1} * ep;
+struct { int member; } * sp;
+void (*fp) (void);
+
+void global_function ()
+{
+  cp = vp;	/* ERROR -  */
+  ip = vp;	/* ERROR -  */
+  ep = vp;	/* ERROR -  */
+  sp = vp;	/* ERROR -  */
+  fp = vp;	/* ERROR -  */
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900210_05.C b/gcc/testsuite/g++.old-deja/g++.bugs/900210_05.C
new file mode 100644
index 00000000000..fc0ead9b514
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900210_05.C
@@ -0,0 +1,37 @@
+// g++ 1.36.1 bug 900210_05
+
+// Section 18.3 of the 2.0 Reference Manual says "An implementation
+// providing { anachronistic features } should also provide a way for
+// the user to ensure that they do not occur in a source file."
+
+// The *only* proper way to "ensure" an absence of anachronstic features
+// is for C++ language processors to generate errors (rather than just
+// warnings) when such features are used. These errors could perhaps be
+// triggered by some set of command line options, or by the absence of
+// certain command line options.  (For g++, the -pedantic and -traditional
+// options come to mind.)
+
+// The use of errors rather than warnings is important because errors
+// usually result in non-zero exit status codes for language processors
+// and these non-zero exit stati can be automatically checked during
+// normal execution of a Makefile.
+
+// cfront 2.0 provides the +p option which causes errors to be generated for
+// all cases of anachronistic usage.
+
+// g++ generates neither errors nor warnings for such usage, even when the
+// -ansi and -pedantic options are used.
+
+// Cfront 2.0 passes this test.
+
+// keywords: anachronism, enum types, integral types, implicit type conversions
+
+enum enum0 { enum_value_0 } enum0_object;
+int int0_object;
+
+void function ()
+{
+  enum0_object = int0_object;	/* ERROR - */
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900210_06.C b/gcc/testsuite/g++.old-deja/g++.bugs/900210_06.C
new file mode 100644
index 00000000000..d52f51143de
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900210_06.C
@@ -0,0 +1,25 @@
+// g++ 1.36.1 bug 900210_06
+
+// g++ allows values of pointer-to-const types to be assigned to variables
+// of pointer-to-non-const types.
+
+// Cfront 2.0 disallows such assignments.
+
+// g++ also allows values of pointer-to-volatile types to be assigned to
+// variables of pointer-to-non-volatile types.
+
+// Cfront 2.0 *would* disallow this (if it only supported "volatile").
+
+// keywords: pointer types, implicit type conversions
+
+const char *ccp;
+volatile char *vcp;
+char *cp;
+
+void function ()
+{
+  cp = ccp;		/* ERROR - */
+  cp = vcp;		/* ERROR - */
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900210_07.C b/gcc/testsuite/g++.old-deja/g++.bugs/900210_07.C
new file mode 100644
index 00000000000..10130586d30
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900210_07.C
@@ -0,0 +1,19 @@
+// g++ 1.36.1 bug 900210_07
+
+// g++ allows values of pointer-to-signed types to be assigned to variables
+// of pointer-to-unsigned types, and vise versa.
+
+// Cfront 2.0 passes this test.
+
+// keyowrds: pointer types, implicit type conversions
+// Special Options: -ansi -pedantic-errors
+signed int *sip;
+unsigned int *uip;
+
+void function ()
+{
+  sip = uip;		// ERROR - 
+  uip = sip;		// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900210_08.C b/gcc/testsuite/g++.old-deja/g++.bugs/900210_08.C
new file mode 100644
index 00000000000..40704d470c0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900210_08.C
@@ -0,0 +1,18 @@
+// g++ 1.36.1 bug 900210_08
+
+// g++ allows pointer-to-const values to be implicitly converted to
+// void* values.  This causes a silent loss of the const qualifier.
+
+// Cfront 2.0 passes this test.
+
+// keywords: pointer types, implicit type conversions
+
+const char *ccp;
+void *vp;
+
+void function ()
+{
+  vp = ccp;		/* ERROR - */
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900210_09.C b/gcc/testsuite/g++.old-deja/g++.bugs/900210_09.C
new file mode 100644
index 00000000000..ce78540565b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900210_09.C
@@ -0,0 +1,32 @@
+// g++ 1.36.1 bug 900210_09
+
+// g++ allows pointer to members (both data members and function members)
+// to be implicitly converted to void*.
+
+// Section 4.8 of the Cfront 2.0 Reference Manual disallows such implicit
+// conversions.
+
+// Cfront 2.0 passes this test.
+
+// keywords: member pointers, void pointers, implicit type conversions
+
+class class0 {
+public:
+  int class0_data_member_0;
+  void class0_function_member_0 ();
+};
+
+int class0::*class0_data_member_pointer;
+int (class0::*class0_function_member_pointer) ();
+
+void *vp;
+
+void global_function_0 ()
+{
+  vp = class0_data_member_pointer;		// ERROR - 
+  vp = class0_function_member_pointer;		// ERROR - 
+}
+
+int main () { return 0; }
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900210_10.C b/gcc/testsuite/g++.old-deja/g++.bugs/900210_10.C
new file mode 100644
index 00000000000..26c17218e77
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900210_10.C
@@ -0,0 +1,14 @@
+// g++ 1.36.1 bug 900210_10
+
+// g++ allows operator[] to be declared as a static member function.
+// This is illegal.
+
+// Cfront 2.0 passes this test.
+
+// keywords: operator[], static function members
+
+struct struct0 {
+  static int operator[] ();		/* ERROR - */
+};
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900211_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900211_01.C
new file mode 100644
index 00000000000..75c99b6ee0d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900211_01.C
@@ -0,0 +1,16 @@
+// g++ 1.36.1 bug 900211_01
+
+// g++ issues only warnings for calls to previously undeclared functions,
+// however such calls are actually errors.
+
+// Cfront 2.0 passes this test.
+
+// keywords: undeclared, functions
+// Build don't link: 
+
+void global_function_0 ()
+{
+  global_function_1 ();		/* ERROR - */
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900211_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900211_02.C
new file mode 100644
index 00000000000..d23a9df1ab5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900211_02.C
@@ -0,0 +1,24 @@
+// g++ 1.36.1 bug 900211_02
+
+// g++ allows you to explicitly specify the return type for a type conversion
+// operator.
+
+// The Cfront 2.0 Reference Manual (12.3.2) says that this in not allowed.
+
+// Cfront 2.0 passes this test.
+
+// keywords: type conversion operators, return type
+
+struct struct0 { int member_0; };
+
+struct0 struct0_object_0;
+
+struct struct1 {
+  struct0 operator struct0 ();		/* ERROR - */
+};
+
+struct0 struct1::operator struct0 () {	// ERROR - 
+  return struct0_object_0;
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900211_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900211_03.C
new file mode 100644
index 00000000000..b805f78bd1f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900211_03.C
@@ -0,0 +1,14 @@
+// g++ 1.36.1 bug 900211_03
+
+// The following erroneous code causes g++ to segfault.
+
+// Cfront 2.0 passes this test.
+
+// keywords: segfault, operator new, arrays, undeclared, array bound
+
+void function ()
+{
+  char* new_base = new char[x];		// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900211_04.C b/gcc/testsuite/g++.old-deja/g++.bugs/900211_04.C
new file mode 100644
index 00000000000..81bea9ef7f1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900211_04.C
@@ -0,0 +1,27 @@
+// g++ 1.36.1 bug 900211_04
+
+// g++ fails to flag as errors attempts to compare pointer values against
+// (non-zero) integer values;
+
+// Since implicit conversions of pointer to integers (or vise versa) are
+// illegal, these comparisons are also illegal.
+
+// Cfront 2.0 passes this test.
+
+// keywords: comparison operators, pointer types, integral types
+
+int result;
+int i;
+char *p;
+
+void function ()
+{
+  result = i == p;	/* ERROR - caught by g++ */
+  result = i != p;	/* ERROR - caught by g++ */
+  result = i >  p;	/* ERROR - missed */
+  result = i <  p;	/* ERROR - missed */
+  result = i >= p;	/* ERROR - missed */
+  result = i <= p;	/* ERROR - missed */
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900212_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900212_01.C
new file mode 100644
index 00000000000..03c41fb0423
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900212_01.C
@@ -0,0 +1,38 @@
+// g++ 1.36.1 bug 900212_01
+
+// g++ fails to flag as errors all attempts to add or subtract integer values
+// from pointers-to-member values.
+
+// Some cases are detected however.
+
+// Cfront 2.0 passes this test.
+
+// keywords: pointer arithmetic, member pointers
+
+struct struct0 {
+};
+
+int struct0::*p0;
+int struct0::*p1;
+
+int (struct0::*fp0) ();
+int (struct0::*fp1) ();
+
+void global_function_0 ()
+{
+  p0 = p1 + 3;			// ERROR - 
+  p0 = p1 - 3;			// ERROR - 
+  p1++;				/* ERROR - caught by g++ */
+  ++p1;				/* ERROR - caught by g++ */
+  p1--;				/* ERROR - caught by g++ */
+  --p1;				/* ERROR - caught by g++ */
+
+  fp0 = fp1 + 3;		// ERROR - 
+  fp0 = fp1 - 3;		// ERROR - 
+  fp1++;			/* ERROR - */
+  ++fp1;			/* ERROR - */
+  fp1--;			/* ERROR - */
+  --fp1;			/* ERROR - */
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900212_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900212_02.C
new file mode 100644
index 00000000000..d997b61e26e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900212_02.C
@@ -0,0 +1,27 @@
+// g++ 1.36.1 bug 900212_02
+
+// g++ fails to flag as errors attempts to take the difference of two values
+// of some compatible pointer-to-member type.
+
+// Cfront 2.0 passes this test.
+
+// keywords: pointer arithmetic, subtraction, member pointers
+
+struct struct0 {
+};
+
+int struct0::*p0;
+int struct0::*p1;
+
+int (struct0::*fp0) ();
+int (struct0::*fp1) ();
+
+int result;
+
+void global_function_0 ()
+{
+  result = (p0 - p1);		// ERROR - 
+  result = (fp0 - fp1);		// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900212_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900212_03.C
new file mode 100644
index 00000000000..479e32c795c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900212_03.C
@@ -0,0 +1,33 @@
+// g++ 1.36.1 bug 900212_03
+
+// g++ segfaults on any attempt to use the ->* operator.
+
+// Cfront 2.0 passes this test.
+
+// keywords: member pointers, operator->*
+
+struct struct0 {
+  int data_member;
+  void function_member ();
+};
+
+void struct0::function_member ()
+{
+}
+
+int i;
+
+int struct0::*dmp;
+void (struct0::*fmp) ();
+
+struct0 *ptr;
+
+void global_function_0 ()
+{
+  i = ptr->*dmp;				// causes segfault
+  (ptr->*fmp) ();				// causes segfault
+  // i = ptr->*(&struct0::data_member);		// too complicated for cfront
+  // (ptr->*(&struct0::function_member)) ();	// too complicated for cfront
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900213_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900213_01.C
new file mode 100644
index 00000000000..309a41943da
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900213_01.C
@@ -0,0 +1,26 @@
+// g++ 1.36.1 bug 900213_01
+
+// g++ incorrectly diagnoses the error when an attempt is made to reference
+// a non-static data-member without an object indication.
+
+// Similar attempts to reference non-static function-members are correctly
+// diagnosed by g++.
+
+// Cfront 2.0 passes this test.
+
+// keywords: non-static members, member pointers, scope resolution
+
+struct struct0 {
+  int struct0_data_member_0;		/* ERROR - gets error from below */
+  int struct0_function_member_0 ();
+};
+
+int i;
+
+void global_function_0 ()
+{
+  i = struct0::struct0_data_member_0;		/* ERROR - mishandled by g++ */
+  //i = struct0::struct0_function_member_0 ();	/* gets caught by g++ */
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900213_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900213_02.C
new file mode 100644
index 00000000000..c4263f99cd9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900213_02.C
@@ -0,0 +1,21 @@
+// g++ 1.36.1 bug 900213_02
+
+// The following erroneous code causes g++ to abort.
+
+// Cfront 2.0 passes this test.
+
+// keywords: abort, member pointers, operator*
+
+struct struct0 {
+  int data_member;
+};
+
+int i;
+int struct0::*dmp;
+
+void global_function_0 ()
+{
+  i = *dmp;			// ERROR - causes abort
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900213_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900213_03.C
new file mode 100644
index 00000000000..4e15896b1c7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900213_03.C
@@ -0,0 +1,28 @@
+// g++ 1.36.1 bug 900213_03
+
+// g++ fails to detect an error when the address of a "bound" function is
+// assigned to a pointer-to-member-function variable.
+
+// It does however correctly detect a similar errors for data-members.
+
+// keywords: bound function, operator&, member pointers
+// Build don't link: 
+
+struct struct0 {
+  int data_member;
+  int function_member ();
+};
+
+int i;
+int struct0::*dmp;
+int (struct0::*fmp) ();
+
+struct0 *ptr;
+
+void global_function_0 ()
+{
+  fmp = &ptr->function_member;	// ERROR - 
+  //dmp = &ptr->data_member;	//  caught by g++, missed by cfront
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900214_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900214_01.C
new file mode 100644
index 00000000000..09fd184f0ab
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900214_01.C
@@ -0,0 +1,22 @@
+// g++ 1.36.1 bug 900214_01
+
+// g++ allows function members of incomplete types to be declared to be
+// friends of other types.
+
+// Cfront 2.0 passes this test.
+
+// keywords: friends, incomplete types, function members
+
+struct A;                       // ERROR - forward declaration
+
+struct B {
+  friend void A::foo();		// ERROR - type A is incomplete
+};
+
+void A::foo();			/* ERROR - also illegal */
+
+struct A {
+  void foo() {}
+};
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900215_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900215_01.C
new file mode 100644
index 00000000000..ff16b2082e1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900215_01.C
@@ -0,0 +1,39 @@
+// g++ 1.36.1 bug 900215_01
+
+// g++ allows the definition of a type conversion operator `operator void'
+// for class types, but subsequently fails to generate calls (where needed)
+// for such type conversion operators.
+
+// Cfront 2.0 does generate such calls.
+
+// The following program exits with status 0 when compiled with Cfront 2.0
+// but exits with status 1 when compiled with g++.
+
+// Cfront 2.0 passes this test.
+
+// 4/27/94 (jason): The pre-San Diego working paper prohibits operator
+// void, so we can go back to just ignoring void values.
+
+// keywords: user-defined type conversion operators, void type, explicit casts
+
+struct struct0 {
+
+  operator void ();		// ERROR - operator void
+};
+
+int exit_status = 1;
+
+struct0::operator void ()
+{				// ERROR - operator void
+  exit_status = 0;
+}
+
+struct struct0 s0_object;
+
+int test ()
+{
+  (void) s0_object;
+  return exit_status;
+}
+
+int main () { return test (); }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900215_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900215_02.C
new file mode 100644
index 00000000000..269849eba23
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900215_02.C
@@ -0,0 +1,47 @@
+// g++ 1.36.1 bug 900215_02
+
+// g++ allows global objects (which happen to be pointers to members of some
+// class X)  to be dereferenced without prefix object specifications within
+// member functions of class X.
+
+// In effect, g++ treats any dereference of a pointer-to-member which appears
+// within the context of a member function (and which is not preceeded by
+// either ->* or .*) as if it had been implicitly prefixed with this->*.
+
+// The 2.0 Reference Manual only provides that such implicit prefixing
+// takes place for *members* of the containing class, and *not* for
+// global objects that happen to have certain types (i.e. pointer-to-member
+// of the containing class).
+
+// Also, cfront 2.0 provides implicit this-> prefixes *only* for *members*
+// of the containing class.
+
+// Cfront 2.0 passes this test.
+
+// keywords: member pointers, this, dereference, members
+
+struct struct0 {
+  int data_member;
+  void function_member ();
+};
+
+int struct0::*dmp;
+int (struct0::*fmp) ();
+int i;
+
+struct struct1 {
+  int data_member;
+
+  void function_member ();
+};
+
+void struct0::function_member ()
+{
+  i = (this->*fmp) ();		// perfectly legal - for both cfront and g++
+  i = this->*dmp;		// perfectly legal - for both cfront and g++
+
+  i = (*fmp) ();		// ERROR - 
+  i = *dmp;			// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900220_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900220_01.C
new file mode 100644
index 00000000000..df7e641fe5f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900220_01.C
@@ -0,0 +1,36 @@
+// g++ 1.36.1 bug 900220_01
+
+// Ref: 12.8
+
+// Section 12.8 says:
+
+//	"That is, X::operator=() will be generated only if no assignment
+//	operation is explicitly declared and an object of class X is actually
+//	assigned an object of class X (or an object of a class derived from X)
+//	or if the address of X::operator= is taken.
+
+// g++ does not allow you to take the address of an implicitly generated
+// operator=
+
+// keywords: operator=, implicit copy operator, operator&
+
+struct struct0 {
+  int data_member;
+};
+
+typedef struct0& (struct0::*member_func_t) (const struct0&);
+
+member_func_t member_func;
+
+void global_function_0 (member_func_t member_f)
+{						// gets bogus error - ref from below
+}
+
+void global_function_1 ()
+{
+  member_func = &struct0::operator=;		// gets bogus error
+
+  global_function_0 (&struct0::operator=);	// gets bogus error
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900220_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900220_02.C
new file mode 100644
index 00000000000..cf039f646bf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900220_02.C
@@ -0,0 +1,30 @@
+// g++ 1.36.1 bug 900220_02
+
+// g++ treats plain `char' and `unsigned char' as different types, however
+// it fails to treat `signed char' as being a different type from plain
+// `char' as called for by both the ANSI C standard and the C++ reference
+// manual.
+
+// keywords: plain char type, signed char type, unsigned char type, overloading
+
+void overloaded (char) {
+}
+
+void overloaded (signed char) {		// gets bogus error
+}
+
+void overloaded (unsigned char) {
+}
+
+void global_function ()
+{
+  char c = 0;
+  signed char sc = 0;
+  unsigned char uc = 0;
+
+  overloaded (c);
+  overloaded (sc);
+  overloaded (uc);
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900220_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900220_03.C
new file mode 100644
index 00000000000..532fc84b52e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900220_03.C
@@ -0,0 +1,51 @@
+// g++ 1.36.1 bug 900220_03
+
+// g++ does not properly disambiguate calls to overloaded functions
+// which are nearly identical except that one take a reference to a
+// type `T' object and another takes a reference to a type `const T'
+// object.
+
+// (Note that the volatile stuff is commented out here because cfront
+// does not yet grok volatile.)
+
+// Cfront 2.0 passes this test.
+
+// keywords: references, overloading, type qualifiers, pointers
+
+int c_call_count = 0;
+int cc_call_count = 0;
+//int vc_call_count = 0;
+
+void overloaded (char&)
+{
+  c_call_count++;
+}
+
+void overloaded (const char&)
+{
+  cc_call_count++;
+}
+
+//void overloaded (volatile char&)
+//{
+//  vc_call_count++;
+//}
+
+int test ()
+{
+  char c = 0;
+  const char cc = 0;
+  //volatile char vc = 0;
+
+  char& cr = c;
+  const char& ccr = cc;
+  //volatile char& vcr = vc;
+
+  overloaded (c);		// OK
+  overloaded (cc);		// gets bogus error
+  //overloaded (vc);		// OK
+
+  return (c_call_count != 1 || cc_call_count != 1 /* || vc_call_count != 1 */);
+}
+
+int main () { return test (); }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900221_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900221_01.C
new file mode 100644
index 00000000000..92c56fc08ad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900221_01.C
@@ -0,0 +1,21 @@
+// g++ 1.36.1 bug 900221_01
+
+// Ref: 3.2
+//
+// Section 3.2 of the C++ 2.0 Reference Manual says:
+//
+//	"Names of formal arguments for a function are treated as if they
+//	were declared in the outermost block of that function"
+//
+// g++ does not enforce this treatment.
+
+// Cfront 2.0 passes this test.
+
+// keywords: scope, formal parameters
+
+void function (int arg1)
+{
+  int arg1;		// ERROR - redeclaration of arg1
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900227_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900227_01.C
new file mode 100644
index 00000000000..77ac1002893
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900227_01.C
@@ -0,0 +1,38 @@
+// g++ 1.37.1 bug 900227_01
+
+// g++ allows pointer type values to be converted to integral types which are
+// not actually large enough to hold the converted values.
+
+// Section 3.3.4 of the ANSI C standard says:
+
+//	A pointer may be converted to an integral type.  The size of the
+//	integer required and the results are implementation defined.  If
+//	the space provided is not long enough, the behavior is undefined.
+
+// I believe that the only proper thing to do in such cases is to generate
+// errors.  After all, if the converted value gets truncated, it is not
+// likely to be useful after that.
+
+// Furthermore, as the following example demonstrates, allowing pointers
+// to be converted to integral types which are not of sufficient size to
+// completely hold the converted values may cause additional troubles.
+
+// I tried the following code on 5 different machines and it failed on
+// all five (unless I also use the GNU assembler and the GNU linker).  Three
+// of the five (Sun3, Sun4, and Symmetry) got link-time errors about byte
+// offset overflows.  The other two (368/SystemV and AViiON) got assembly
+// time errors about relocatable names used in "constant" expressions.
+
+// keywords: casts, pointer types, integral types
+
+// Update 2/10/95: The compiler will now compute these expressions at
+// runtime.  I think this is in the spirit of the GNU compilers (jason).
+
+// Special g++ Options:
+
+int main ();
+
+short s = (short) &main;
+char c = (char) &main;
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900321_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900321_01.C
new file mode 100644
index 00000000000..489671f24ae
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900321_01.C
@@ -0,0 +1,29 @@
+// g++ 1.37.1 bug 900321_01
+
+// cfront flags ERRORs on each of the lines indicated below. g++ does not
+// flag either ERRORs or warnings.
+
+// Although I cannot find where in the current C++ Reference Manual this
+// topic is covered, I am sure that these statements should get ERRORs in
+// a "strongly typed" language.
+
+// Cfront 2.0 passes this test.
+
+// keywords: array types, array bound, pointers
+
+int (*ptr_to_array_of_ints)[];
+int (*ptr_to_array_of_3_ints) [3];
+int (*ptr_to_array_of_5_ints) [5];
+
+void function_0 ()
+{
+  // we miss the first two because typeck.c (comp_array_types) deems
+  // it okay if one of the sizes is null
+  ptr_to_array_of_ints = ptr_to_array_of_3_ints;	// ERROR - 
+  ptr_to_array_of_3_ints = ptr_to_array_of_ints;	// ERROR - 
+
+  ptr_to_array_of_3_ints = ptr_to_array_of_5_ints;	// ERROR - 
+  ptr_to_array_of_5_ints = ptr_to_array_of_3_ints;	// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900321_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900321_02.C
new file mode 100644
index 00000000000..d635ba3d1e7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900321_02.C
@@ -0,0 +1,27 @@
+// g++ 1.37.1 bug 900321_02
+
+// The following program exits with a non-zero status because the constructor
+// is not called 3 times as it should be.  This program exits with a zero
+// status when compiled with cfront 2.0.
+
+// Cfront 2.0 passes this test.
+
+// keywords: arrays, initialization, default constructor, operator new
+
+int call_count = 0;
+
+struct struct0 {
+  struct0 ();
+};
+
+struct0::struct0 () { call_count++; }
+
+typedef struct0 array[3];	// known dimension
+
+int test ()
+{
+  new array;
+  return (call_count != 3);
+}
+
+int main () { return test (); }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900321_04.C b/gcc/testsuite/g++.old-deja/g++.bugs/900321_04.C
new file mode 100644
index 00000000000..5f3d5a1471a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900321_04.C
@@ -0,0 +1,16 @@
+// g++ 1.37.1 bug 900321_04
+
+// The following code causes g++ to segfault.
+
+// Cfront 2.0 passes this test.
+
+// keywords: segfault, object declaration, pointer, array, incomplete type
+
+struct incomplete;
+
+void function ()
+{
+  struct incomplete (*ptr)[];		// causes segfault
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900321_05.C b/gcc/testsuite/g++.old-deja/g++.bugs/900321_05.C
new file mode 100644
index 00000000000..8f417e892fc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900321_05.C
@@ -0,0 +1,20 @@
+// g++ 1.37.1 bug 900321_05
+
+// The following code is legal as far as the ANSI C standard, GCC, and
+// cfront are concerned, however g++ issues errors for the lines indicated.
+
+// Cfront 2.0 passes this test.
+
+// keywords: operator[], pointers, index
+
+char c;
+char *cp;
+int i;
+
+void function ()
+{
+  c = 3["abcdef"];	// gets bogus error
+  c = i[cp];		// gets bogus error
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900322_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900322_01.C
new file mode 100644
index 00000000000..48ae6006f10
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900322_01.C
@@ -0,0 +1,61 @@
+// g++ 1.37.1 bug 900322_01
+
+// ** Old, obsolete commentary:
+// **************************************************************************
+// The ANSI C standard, in section 3.1.2.5 (first paragraph) differentiates
+// types into three disjoint sets, i.e object types, function types, and
+// incomplete types.
+
+// Also in 3.1.2.5 (page 24) the standard says that the element type of
+// an array type is an object type.
+
+// Later in that same section the standard also notes that array types with
+// unknown size are considered incomplete types (page 25).  (Struct & union
+// types which have only been "forward declared" are also incomplete types.)
+
+// Some experts infer this to mean that it is not legal to specify or to
+// construct an array *type* whose element type is an incomplete type.
+
+// This interpretation suggests that the statements indicated below contain
+// errors.
+
+// g++ fails to flag all of the indicated statements with errors (even when
+// the -pedantic option is used).
+// **************************************************************************
+
+// The above commentary is wrong.  (jason 1998/11/13)
+// In fact, the lines marked OK are well-formed; the prohibition is only
+// against forming array types with multiple unknown bounds.  This prohibition
+// is found in 8.3.4 [dcl.array].
+
+// It is also ill-formed to create an object of incomplete type.
+
+// keywords: incomplete types, arrays, element types
+
+extern int extern_two_d [] [];		// ERROR - invalid declaration
+int tenative_two_d [] [];		// ERROR - caught by g++
+static int static_two_d [] [];		// ERROR - caught by g++
+
+int (*pointer_to_two_d)[][];		// ERROR - invalid declaration
+
+void function_0 (int arg [] []) {	// ERROR - invalid declaration
+}
+
+typedef int int_one_d_type [];
+typedef int_one_d_type int_two_d_type[];// ERROR - invalid declaration
+
+struct s;
+
+extern struct s extern_s_array [10];	// OK
+struct s tenative_s_array [10];		// ERROR - object with incomplete type
+static struct s static_s_array [10];	// ERROR - object with incomplete type
+
+struct s (*pointer_to_s_array) [];	// OK
+
+void function_1 (struct s arg []) {	// OK
+}
+
+typedef struct s s_type;
+typedef s_type s_one_d_type [10];	// OK
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900324_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900324_02.C
new file mode 100644
index 00000000000..56ff7b738d1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900324_02.C
@@ -0,0 +1,18 @@
+// g++ 1.37.1 bug 900324_02
+
+// The following erroreous code causes g++ to segfault.
+
+// Cfront 2.0 passes this test.
+
+// keywords: segfault, function pointer, conditional operator ?:
+
+void function_0 (int i) { }
+
+void (*fp)(void);
+
+void function_1 ()
+{
+  fp = 1 ? function_0 : fp;		// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900324_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900324_03.C
new file mode 100644
index 00000000000..69d9b58f039
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900324_03.C
@@ -0,0 +1,21 @@
+// g++ 1.37.1 bug 900324_03
+
+// g++ is unable to correctly parse declarations of non-global function-pointer
+// variables and/or function-pointer formal parameters.
+
+// Cfront 2.0 passes this test.
+
+// keywords: syntax, function pointers, block local, formal
+
+void (*p0)();				// OK
+
+void function_0 ()
+{
+  void (*p1)();				// gets bogus errors
+}
+
+void function_1 (void (*p2)());		// gets bogus errors
+
+void (*function_2 ()) ();		// OK
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900324_04.C b/gcc/testsuite/g++.old-deja/g++.bugs/900324_04.C
new file mode 100644
index 00000000000..c874897e68a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900324_04.C
@@ -0,0 +1,25 @@
+// g++ 1.37.1 bug 900324_04
+
+// g++ implements an extension which supports the copying of array objects.
+
+// This extension is not described in the current C++ Reference Manual, and
+// it is not implemented by cfront (2.0).
+
+// g++ should generate errors for the use of this extension when -pedantic
+// is used, however it does not.
+
+// Cfront 2.0 passes this test.
+
+// keywords: extension, pedantic, arrays, copy
+
+typedef int int_array[20];
+
+int_array ia1;
+int_array ia2;
+
+void function_0 ()
+{
+  ia1 = ia2;		// ERROR - gnu extension
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900324_05.C b/gcc/testsuite/g++.old-deja/g++.bugs/900324_05.C
new file mode 100644
index 00000000000..32f691d3719
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900324_05.C
@@ -0,0 +1,21 @@
+// g++ 1.37.1 bug 900324_05
+
+// The following erroneous code causes g++ to segfault.
+
+// Cfront 2.0 passes this test.
+
+// keywords: segfault, arrays, references, assignment operator=
+
+typedef int int_array[];
+
+extern int_array int_array_object;
+
+int_array &left = int_array_object;
+int_array &right = int_array_object;
+
+void function ()
+{
+  left = right;		// ERROR - causes segfault
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900324_06.C b/gcc/testsuite/g++.old-deja/g++.bugs/900324_06.C
new file mode 100644
index 00000000000..5a1938af8b8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900324_06.C
@@ -0,0 +1,28 @@
+// g++ 1.37.1 bug 900324_06
+
+// g++ is unable to use context information (i.e. the required type of the
+// expression) to disambiguate a possibly overloaded function name when that
+// name is used as either the second or the third operand of a ?: operator.
+
+// It is also unable to use the fact that the given name is not in fact
+// overloaded (and has only one possible interpretation).
+
+// This results in improper errors being generated.
+
+// keywords: overloading, function pointers, disambiguation, operator?:
+
+int i;
+void (*p)();
+
+void function_0 ()
+{
+}
+
+void function_1 ()
+{
+  p = i ? function_0 : 0;		// gets bogus error
+  p = i ? 0 : function_0;		// gets bogus error
+  p = i ? function_1 : function_0;	// gets bogus error
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900325_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900325_01.C
new file mode 100644
index 00000000000..f11ec189039
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900325_01.C
@@ -0,0 +1,17 @@
+// g++ 1.37.1 bug 900325_01
+
+// g++ fails to generate errors for attempts to declare a formal argument to
+// be of a void type.
+
+// keywords: formal parameter, void type
+
+typedef void __void;
+typedef __void Void;
+
+void function0 (void arg1) {	// ERROR - missed
+}
+
+void function1 (Void arg1) {	// ERROR - missed
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900330_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900330_01.C
new file mode 100644
index 00000000000..651d370ef14
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900330_01.C
@@ -0,0 +1,52 @@
+// g++ 1.37.1 bug 900330_01
+//
+// As indicated by the example at the end of the section 3.5.3 of the ANSI
+// C standard, when a type qualifier (i.e. "const" or "volatile") is applied
+// to an array type, the effect should be as if the element type had been
+// qualified with the given qualifier.
+//
+// This rule applies to C++ also.
+//
+// In section 7.1.6 of the C++ Reference Manual it says "Each element of a
+// const array is const..."
+//
+// It appears however that when a name already exists for a given array type
+// (i.e. a typedef name) and when that name is qualified by a type qualifier,
+// (i.e. "const" or "volatile"), gcc & g++ may act as if the qualifier applied
+// to the named (array) type rather that to the elements of that type.
+//
+// The result is that (even with the -ansi and -pedantic options) g++
+// generates no errors or warnings for the lines indicated (even though it
+// should).
+//
+// Due to the incorrect associations, gcc & g++ will also issue inappropriate
+// warnings in some cases (as illustrated below).
+
+// keywords: type qualifiers, arrays
+
+typedef const int const_int;
+typedef const_int array_of_const_int[3];
+array_of_const_int *ptr_to_array_of_consts;
+
+typedef int array_of_int[3];
+typedef const array_of_int const_array_of_int;
+const_array_of_int *ptr_to_const_array;
+
+void function_0 ()
+{
+  ptr_to_array_of_consts = ptr_to_const_array;	/* gets bogus warning */
+  ptr_to_const_array = ptr_to_array_of_consts;	/* gets bogus warning */
+}
+
+/* The following example is taken from ANSI 3.5.3 */
+
+typedef int A[2][3];
+const A a = {{4, 5, 6}, {7, 8, 9}};
+int *pi;
+
+void function_1 ()
+{
+  pi = a[0];	// ERROR - a[0] has type "const int *"
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900330_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900330_02.C
new file mode 100644
index 00000000000..85c40f0e8d9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900330_02.C
@@ -0,0 +1,29 @@
+// g++ 1.37.1 bug 900330_02
+
+// The C++ Reference Manual says in section 13.1:
+
+// "Two function declarations of the same name refer to the same function
+// if they are in the same scope and have identical argument types.  A
+// function member of a derived class is *not* in the same scope as a function
+// member of the same name in a base class."
+
+// g++ fails to correctly detect the error indicated.
+
+// Cfront 2.0 passes this test.
+
+// keywords: function, member, overloading, hiding
+
+struct B {
+  int f(int);
+};
+
+struct D : public B {
+  int f(struct B);		// ERROR - referred to below
+};
+
+void h(D* pd)
+{
+  pd->f(1);		// ERROR - D::f(struct B) hides B::f(int)
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900331_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900331_02.C
new file mode 100644
index 00000000000..11884db2e48
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900331_02.C
@@ -0,0 +1,27 @@
+// g++ 1.37.1 bug 900331_02
+
+// g++ fails to treat conditional expressions which yield composite type
+// (i.e. struct type, union type, or class type) lvalues as if they did
+// in fact yield lvalues in all cases.
+
+// Cfront 2.0 passes this test.
+
+// keywords: conditional operator?:, lvalues, composite types
+
+struct struct0 {
+  int data_member;
+};
+
+struct0 object0;
+struct0 object1;
+struct0 object2;
+
+int i;
+
+void function0 ()
+{
+  (i ? object0 : object1).data_member = 99;	// gets bogus error
+  (i ? object0 : object1) = object2;		// gets bogus error
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900331_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900331_03.C
new file mode 100644
index 00000000000..a73d6856040
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900331_03.C
@@ -0,0 +1,31 @@
+// g++ 1.37.1 bug 900331_03
+
+// Special Options: -ansi
+
+// The following code causes g++ to abort.
+
+// Curiously, the abort does not occur if the -pedantic option is used.
+
+// Cfront 2.0 passes this test.
+
+// Keywords: abort, conditional operator?:, lvalues, composite types
+
+struct struct0 {
+  int data_member;
+
+  virtual void function_member () {}	// contributes to the abort
+};
+
+struct0 object0;
+struct0 object1;
+struct0 object2;
+
+int i;
+
+void function0 ()
+{
+  object2 = (i ? object0 : object1);		// OK
+  (i ? object0 : object1) = object2;		// causes abort
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900331_04.C b/gcc/testsuite/g++.old-deja/g++.bugs/900331_04.C
new file mode 100644
index 00000000000..f8a14c69390
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900331_04.C
@@ -0,0 +1,32 @@
+// g++ 1.37.1 bug 900331_04
+
+// g++ is unable to correctly parse declarations of formal parameters and
+// local objects which have pointer-to-array types or reference-to-array
+// types.
+
+// Cfront 2.0 passes this test.
+
+// keywords: syntax, arrays, pointers, references, local, formal
+
+int array[10];
+
+int (*global_array_ptr)[10] = &array;
+int (&global_array_ref)[10] = array;
+
+void function0 (int (*formal_array_ptr)[10]) {	// gets bogus errors
+}
+
+void function1 (int (&formal_array_ref)[10]) {	// gets bogus errors
+}
+
+void function2 ()
+{
+  int (*local_array_ptr)[10] = &array;		// gets bogus errors
+}
+
+void function3 ()
+{
+  int (&local_array_ref)[10] = array;		// gets bogus error
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900401_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900401_01.C
new file mode 100644
index 00000000000..18ecd614e7a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900401_01.C
@@ -0,0 +1,15 @@
+// g++ 1.37.1 bug 900401_01
+
+// The following erroneous code causes g++ to abort.
+
+// Cfront 2.0 passes this test.
+
+// keywords: abort, bit-fields, arrays
+
+typedef unsigned nibble_array[4];
+
+struct whole {
+  nibble_array nibbles:16;	// ERROR - 
+};
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900402_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900402_01.C
new file mode 100644
index 00000000000..946e6d1e0d3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900402_01.C
@@ -0,0 +1,15 @@
+// g++ 1.37.1 bug 900402_01
+
+// The following erroneous code causes g++ to abort.
+
+// Cfront 2.0 passes this test.
+
+// keywords: abort, bit-fields, function types
+
+typedef void (func_type) ();
+
+struct s {
+  func_type f:32;	// ERROR - bitified with function type
+};
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900402_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900402_02.C
new file mode 100644
index 00000000000..705cbf22d01
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900402_02.C
@@ -0,0 +1,21 @@
+// g++ 1.37.1 bug 900402_02
+
+// g++ fails to correctly flag all attempts to construct an array type
+// of zero length as errors.
+
+// keywords: arrays, array bound, zero length
+
+typedef int array_type[0];		// ERROR - gets warning only
+
+int array_object_1[0];			// ERROR - gets warning only
+
+void function_0 (int formal_array[0])
+{					// ERROR - gets warning only
+}
+
+void function_2 ()
+{
+  int local_object_array_0[0];		// ERROR - gets warning only
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900403_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900403_01.C
new file mode 100644
index 00000000000..608d8f92bd5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900403_01.C
@@ -0,0 +1,19 @@
+// g++ 1.37.1 bug 900403_01
+
+// g++ allows casts to be treated as lvalues (even when the -pedantic
+// option is used).  Neither the C++ Reference Manual nor cfront 2.0
+// allow this.  (gcc gives warnings for such usage with -pedantic).
+
+// Cfront 2.0 passes this test.
+
+// keywords: lvalues, casts
+
+int i, j;
+
+void f ()
+{
+  (int) i = j;		// ERROR - 
+  ((int) i) = j;	// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900403_04.C b/gcc/testsuite/g++.old-deja/g++.bugs/900403_04.C
new file mode 100644
index 00000000000..c68e4c2d88f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900403_04.C
@@ -0,0 +1,12 @@
+// g++ 1.37.1 bug 900403_04
+
+// The following erroneous code causes g++ to abort.
+
+// keywords: abort, bit-fields, zero length
+
+struct s {
+  unsigned int foo:0;		// ERROR - This is the real line
+  unsigned int field;
+};
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900404_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900404_01.C
new file mode 100644
index 00000000000..f728865961f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900404_01.C
@@ -0,0 +1,15 @@
+// g++ 1.37.1 bug 900404_01
+
+// g++ allows string initializers for known-length character arrays to be
+// one character longer (counting the terminating null) than the actual
+// length of the array to be initialized.
+
+// The C++ Reference Manual (section 8.4.2) expressly prohibits this.
+
+// Cfront 2.0 passes this test.
+
+// keywords: arrays, initialization, array bounds
+
+char cv[4] = "asdf";		// ERROR - missed
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900404_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900404_02.C
new file mode 100644
index 00000000000..4099daa31e4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900404_02.C
@@ -0,0 +1,24 @@
+// g++ 1.37.1 bug 900404_02
+
+// g++ fails to treat multicharacter literals as type "int" as required by
+// section 2.5.2 of the C++ Reference Manual.
+
+// The result is that the following program will exit with a non-zero
+// exit status.
+
+// keywords: character literals, multi-character literals, int type
+
+int exit_status = 0;
+
+void function0 (int i)		// function that should be called
+{
+  i = i;
+}
+
+void function0 (char c)		// function that is actually called
+{
+  c = c;
+  exit_status++;
+}
+
+int main () { function0 ('abcd'); return exit_status; }		// WARNING - 
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900404_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900404_03.C
new file mode 100644
index 00000000000..98a33d717bb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900404_03.C
@@ -0,0 +1,27 @@
+// g++ 1.37.1 bug 900404_03
+
+// g++ fails to be able to properly flag errors for even simple cases of
+// ambiguous overload resolution (such as the one shown below).
+
+// Cfront 2.0 passes this test.
+
+// keywords: overloading, ambiguity, resolution
+
+void function0 (int i, char c)
+{				// ERROR - 
+  i = c;
+}
+
+void function0 (char c, int i)
+{				// ERROR - 
+  i = c;
+}
+
+char c;
+
+void test ()
+{
+  function0 (c,c);		// ERROR - missed
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900404_04.C b/gcc/testsuite/g++.old-deja/g++.bugs/900404_04.C
new file mode 100644
index 00000000000..75be8ab819a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900404_04.C
@@ -0,0 +1,17 @@
+// g++ 1.37.1 bug 900404_04
+
+// [dcl.dcl] explains that simple-declarations may omit the
+// init-declarator-list only if the decl-specifier-seq declares a
+// class, i.e. if it contains a class-specifier, an
+// elaborated-type-specifier with class key, or an enum-specifier. The
+// declaration below contains neither.
+
+// g++ fails to flag errors for such usage.
+
+// keywords: semicolon, vacuous, file scope, declaration
+
+int i;
+
+;			// ERROR - , XFAIL *-*-*
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900404_07.C b/gcc/testsuite/g++.old-deja/g++.bugs/900404_07.C
new file mode 100644
index 00000000000..c07a5775189
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900404_07.C
@@ -0,0 +1,17 @@
+// g++ 1.37.1 bug 900404_07
+
+// It is illegal to use a cast to attempt to convert an object type
+// to a non-scalar type (e.g. an array type).
+
+// g++ fails to properly flag as errors such illegal uses of array types.
+
+// keywords: array types, casts, type conversion
+
+typedef int array_type[10];
+
+array_type *ap;
+
+void foo ()
+{
+  int i = *((array_type) *ap);	/* ERROR - missed */
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900405_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900405_01.C
new file mode 100644
index 00000000000..346db0c556d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900405_01.C
@@ -0,0 +1,19 @@
+// g++ 1.37.1 bug 900405_01
+
+// The C++ Reference Manual says (in section 5.4) "Types may not be defined
+// in casts."
+
+// g++ fails to flag errors for cases where an attempt is made to define
+// a struct, class, union, or enum type within a cast.
+
+// keywords: casts, type definitions, tagged types
+
+void f ()
+{
+  (enum e { red, green } *) 0;		// ERROR - type defined in cast
+  (struct s { int member; } *) 0;	// ERROR - type defined in cast
+  (union u { int member; } * ) 0;	// ERROR - type defined in cast
+  (class c { int member; } *) 0;	// ERROR - type defined in cast
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900406_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900406_01.C
new file mode 100644
index 00000000000..93e7af3f378
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900406_01.C
@@ -0,0 +1,19 @@
+// g++ 1.37.1 bug 900406_01
+
+// The following code causes g++ to segfault.
+
+// cfront 2.0 passes this test.
+
+// keywords: segfault, operator new, array types, array bounds
+
+void function0 ()
+{
+  new int[];		// ERROR - causes segfault
+}
+
+void function1 ()
+{
+  new int (*)[];	// ERROR - no size specified 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900406_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900406_02.C
new file mode 100644
index 00000000000..daf46a14e86
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900406_02.C
@@ -0,0 +1,25 @@
+// g++ bug 900406_02
+
+// g++ fails to correctly parse some type specifications within casts.
+
+// This results in incorrect errors being issued.
+
+// These errors are not issued for identical code by either cfront or
+// by gcc.
+
+// cfront 2.0 passes this test.
+
+// keywords: syntax, array types, casts
+
+int (*ipp)[];
+int (**ippp)[];
+
+int function ()
+{
+  ipp = (int (*)[]) 0;			// OK
+  ippp = (int (**)[]) 0;		// gets bogus error (syntax)
+  return 0;
+}
+
+int main () { return 0; }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900407_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900407_01.C
new file mode 100644
index 00000000000..988642f4ad3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900407_01.C
@@ -0,0 +1,36 @@
+// g++ 1.37.1 bug 900407_01
+
+// g++ fails to flag errors for uses of anachronistic features such as the
+// invocation of a base class constructor in a ctor-initializer list without
+// explicitly giving its name.
+
+// Errors should probably be issued for such usage unless the -traditional
+// option is used.
+
+// Warnings are however issued.
+
+// Cfront 2.0 flags such usage as an error when the +p (pure-language) option
+// is used.
+
+// Cfront 2.0 passes this test.
+
+// keywords: anachronism, inheritance, initialization, mem-initializer
+
+struct s0 {
+  int member;
+
+  s0 ();
+};
+
+s0::s0() { }
+
+struct s1 : public s0 {
+  int member;
+
+  s1 ();
+};
+
+s1::s1() : () {		// ERROR - anachronism used
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900407_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900407_02.C
new file mode 100644
index 00000000000..5f6862f2fea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900407_02.C
@@ -0,0 +1,32 @@
+// g++ 1.37.1 bug 900407_02
+
+// g++ flags errors for attempts to assign to the "this" parameter within
+// class constructors (regardless of whether or not the -traditional)
+// option is used).
+
+// Such errors should probably not be issued when the -traditional option is
+// used.
+
+// Special g++ Options: -Wno-deprecated -fthis-is-variable
+// Special CC Options:
+
+// Cfront only flags errors for such usage whin the +p (pure language)
+// option is used.
+
+// cfront 2.0 passes this test.
+
+// keywords: anachronism, this, assignment
+
+struct s0 {
+
+  int member;
+
+  s0 ();
+};
+
+s0::s0 ()
+{
+  this = this;		// OK - anachronism allowed with -traditional
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900428_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900428_01.C
new file mode 100644
index 00000000000..c2eb3071352
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900428_01.C
@@ -0,0 +1,51 @@
+// g++ 1.37.1 bug 900428_01
+
+// g++ fails to issue error messages for cases where an incomplete type
+// object must be evaluated if the value of such an evaluation is not
+// actually used in the given context.
+
+// In the case where such an object is volatile, it is obvious that this
+// could be a problem, however I believe that errors should be issued
+// for such cases regardless of whether or not such values are volatile
+// because the abstract semantics seem to require the evaluation of such
+// values whether they are volatile or not.
+
+// keywords: incomplete types, evaluation, volatile qualifier
+// Build don't link: 
+
+int i;
+
+void *pv;
+volatile void *pvv;
+struct s;               // ERROR - forward declaration
+extern struct s es, *ps;  // ERROR - defined here
+extern volatile struct s evs, *pvs; // ERROR - defined here
+
+void pv_test ()
+{
+  *pv;			// ERROR - invalid void
+  (i ? *pv : *pv);	// ERROR - invalid void
+  *pv, *pv;		// ERROR - invalid void
+
+  *pvv;			// ERROR - invalid void
+  (i ? *pvv : *pvv);	// ERROR - invalid void
+  *pvv, *pvv;		// ERROR - invalid void
+
+  es;			// ERROR - incomplete
+  (i ? es : es);	// ERROR - undefined type
+  es, es;		// ERROR - incomplete
+
+  evs;			// ERROR - incomplete
+  (i ? evs : evs);	// ERROR - undefined type
+  evs, evs;		// ERROR - incomplete
+
+  *ps;			// ERROR - undefined type
+  (i ? *ps : *ps);	// ERROR - undefined type
+  *ps, *ps;		// ERROR - undefined type
+
+  *pvs;			// ERROR - undefined type
+  (i ? *pvs : *pvs);	// ERROR - undefined type
+  *pvs, *pvs;		// ERROR - undefined type
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900428_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900428_02.C
new file mode 100644
index 00000000000..9da709fdc81
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900428_02.C
@@ -0,0 +1,27 @@
+// g++ 1.37.1 bug 900428_02
+
+// g++ fails to issue either errors or warnings (even with -pedantic) for
+// attempts to perform either pre or post increment or decrement operations
+// on variables which have either pointer-to-void types or pointer-to-function
+// types.
+
+// cfront 2.0 passes this test.
+
+// keywords: pointer arithmetic, increment, decrement
+// Build don't link:
+
+void *vp;
+void (*fp) ();
+
+void test ()
+{
+  vp++;		/* ERROR - */
+  ++vp;		/* ERROR - */
+  vp--;		/* ERROR - */
+  --vp;		/* ERROR - */
+
+  fp++;		/* ERROR - */
+  ++fp;		/* ERROR - */
+  fp--;		/* ERROR - */
+  --fp;		/* ERROR - */
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900428_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900428_03.C
new file mode 100644
index 00000000000..74e55860d29
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900428_03.C
@@ -0,0 +1,44 @@
+// g++ 1.37.1 bug 900428_03
+
+// g++ fails to detect cases where a constructor for a derived class invokes
+// (either explicitly or implicitly) a private constructor for a base class.
+
+// cfront 2.0 passes this test.
+
+// keywords: inheritance, private, accessability, constructors
+
+struct struct_0 {
+  int struct_0_data_member;
+
+private:
+  struct_0 (int, int);
+public:
+  struct_0 (int);
+};
+
+struct_0::struct_0 (int i) { }
+struct_0::struct_0 (int, int) { } // ERROR - xref from below
+
+struct struct_1 : public struct_0 {
+
+  struct_1 ();
+};
+
+struct_1::struct_1 () : struct_0 (8,9)
+{				// ERROR - 
+}
+
+struct struct_2 {
+  struct_0 struct_2_data_member;
+
+  struct_2 ();
+};
+
+// g++ catches the following error (but does so only at the line with the 
+// closing curly brace).
+
+struct_2::struct_2 () : struct_2_data_member (8,9)
+{				// ERROR - should be up one line
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900511_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900511_01.C
new file mode 100644
index 00000000000..e4488d9bad1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900511_01.C
@@ -0,0 +1,42 @@
+// g++ 1.37.1 bug 900511_01
+
+// g++ fails to properly apply user-defined type conversion operators
+// in cases where is it not obvious that the given conversion is
+// appropriate for the context (i.e. operator and other operands)
+// where the conversion should take place.
+
+// cfront 2.0 passes this test.
+
+struct struct_1 {
+  int member;
+
+  operator int ();
+};
+
+struct_1::operator int ()
+{
+  return 0;
+}
+
+struct struct_2 {
+  int member;
+
+  operator float ();
+};
+
+struct_2::operator float ()
+{
+  return 0.0;
+}
+
+struct_1 struct_1_object;
+struct_2 struct_2_object;
+double d;
+
+void test ()
+{
+  d = struct_2_object + struct_1_object;	// OK
+  d = struct_1_object + struct_2_object;	// gets bogus error
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900511_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900511_02.C
new file mode 100644
index 00000000000..cef71c0a12e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900511_02.C
@@ -0,0 +1,21 @@
+// g++ 1.37.1 bug 900511_02
+
+// g++ does not properly shadow names of types with names of data members
+// in cases where the type names in question are used in the context of
+// formal parameters lists for member functions.
+
+// keywords: typedef names, shadowing, scope, formal parameter list
+
+// cfront 2.0 passes this test.
+
+enum enum0 { enum0_value_0 };	
+
+struct struct0 {
+  int enum0;			
+  void member_function (enum0 e); // ERROR - invalid use of struct-local member
+};
+
+void class0::member_function (enum0 e) {	// ERROR - syntax error
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900511_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900511_03.C
new file mode 100644
index 00000000000..849bdf34486
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900511_03.C
@@ -0,0 +1,19 @@
+// g++ 1.37.1 bug 900511_03
+
+// g++ does not properly shadow names of types with names of data members
+// in cases where the type names in question are used in the context of
+// formal parameters lists for member functions.
+
+// keywords: typedef names, shadowing, scope, formal parameter list
+
+class class0;
+
+struct struct1 {
+  int class0;
+  void member_function (class0 *); // ERROR - invalid use of struct-local member
+};
+
+void class1::member_function (class0 *p) {	// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900514_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900514_03.C
new file mode 100644
index 00000000000..54123f2bb19
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900514_03.C
@@ -0,0 +1,112 @@
+// g++ 1.37.1 bug 900514_03
+
+// g++ fails to flag ERRORs on the following erroneous code.
+
+// In Section 12.3.2 it says "Defining conversion by both a constructor and
+// a conversion function can lead to ambiguities."  However in the case below,
+// the explicit cast syntax disambiguates the constructor as one which
+// invokes the type conversion operator rather than the conversion.
+
+// cfront 2.0 passes this test.
+
+// keywords: user-defined type conversion operator, constructor
+
+struct t_0_st_0;
+
+struct t_0_st_1 {
+  int member;
+
+  t_0_st_1 (t_0_st_0&);// ERROR - 
+  t_0_st_1 ();
+};// ERROR - 
+
+struct t_0_st_0 {
+  int member;
+
+  operator t_0_st_1 ();// ERROR - 
+};
+
+t_0_st_0 t_0_st_0_obj0;
+
+void t_0_assignment ()
+{
+  t_0_st_1 t_0_st_1_obj0;
+  t_0_st_1 t_0_st_1_obj1;
+  t_0_st_1 t_0_st_1_obj2;
+
+  t_0_st_1_obj0 = t_0_st_0_obj0;			// ERROR - caught
+  t_0_st_1_obj1 = t_0_st_1 (t_0_st_0_obj0);
+}
+
+void t_0_local_init ()
+{
+  t_0_st_1 t_0_st_1_obj0 = t_0_st_0_obj0;		// ERROR - 
+  t_0_st_1 t_0_st_1_obj1 = t_0_st_1 (t_0_st_0_obj0);
+}
+
+struct t_1_st_0;
+
+struct t_1_st_1 {
+  int member;
+
+  t_1_st_1 (t_1_st_0&);					// ERROR - 
+  t_1_st_1 ();
+  void operator= (t_1_st_1&);				// ERROR - 
+};
+
+struct t_1_st_0 {
+  int member;
+
+  operator t_1_st_1 ();					// ERROR - 
+};
+
+t_1_st_0 t_1_st_0_obj0;
+
+void t_1_assignment ()
+{
+  t_1_st_1 t_1_st_1_obj0;
+  t_1_st_1 t_1_st_1_obj1;
+  t_1_st_1 t_1_st_1_obj2;
+
+  t_1_st_1_obj0 = t_1_st_0_obj0;			// ERROR - 
+  t_1_st_1_obj1 = t_1_st_1 (t_1_st_0_obj0);		// ERROR - 
+}
+
+void t_1_local_init ()
+{
+  t_1_st_1 t_1_st_1_obj0 = t_1_st_0_obj0;		// ERROR - 
+  t_1_st_1 t_1_st_1_obj1 = t_1_st_1 (t_1_st_0_obj0);
+}
+
+struct t_2_st_0;
+
+struct t_2_st_1 {
+  int member;
+
+  t_2_st_1 (t_2_st_0);		// ERROR - candidate
+  t_2_st_1 ();
+};				// ERROR - candidate
+
+struct t_2_st_0 {
+  int member;
+
+  operator t_2_st_1 ();		// ERROR - candidate
+};
+
+t_2_st_0 t_2_st_0_obj0;
+
+void t_2_assignment ()
+{
+  t_2_st_1 t_2_st_1_obj0;
+  t_2_st_1 t_2_st_1_obj1;
+  t_2_st_1 t_2_st_1_obj2;
+
+  t_2_st_1_obj0 = t_2_st_0_obj0;			// ERROR - caught
+  t_2_st_1_obj1 = t_2_st_1 (t_2_st_0_obj0);
+}
+
+void t_2_local_init ()
+{
+  t_2_st_1 t_2_st_1_obj0 = t_2_st_0_obj0;		// ERROR - 
+  t_2_st_1 t_2_st_1_obj1 = t_2_st_1 (t_2_st_0_obj0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900519_01.C b/gcc/testsuite/g++.old-deja/g++.bugs/900519_01.C
new file mode 100644
index 00000000000..9641d1d615c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900519_01.C
@@ -0,0 +1,16 @@
+// g++ 1.37.1 bug 900519_01
+
+// g++ fails to flag errors for some attempts to declare or define non-member
+// type conversion operators.
+
+// cfront 2.0 passes this test.
+
+// keywords: user-defined type conversion operator, non-member
+
+extern operator int ();		// ERROR - 
+
+extern operator int () {	// ERROR - 
+  return 0;
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900519_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900519_02.C
new file mode 100644
index 00000000000..90dc16a42ec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900519_02.C
@@ -0,0 +1,32 @@
+// g++ 1.37.1 bug 900519_02
+
+// The C++ Reference Manual says (in section 8.4.3) "A reference to a plain
+// T can only be initialized with a plain T" however g++ allows the
+// initialization of plain references with qualified objects in many cases.
+
+// keywords: references, initialization, type qualifiers
+
+extern const int cint_obj = 9;
+volatile int vint_obj = 9;
+
+void take_int_ref (int& arg) { } // ERROR - referenced by errors below
+
+int& global_int_ref0 = cint_obj;		// ERROR - 
+int& global_int_ref1 = vint_obj;		// ERROR - 
+
+extern const int& cint_ref;
+extern volatile int& vint_ref;
+
+void test_0 ()
+{
+  int& local_int_ref0 = cint_obj;		// ERROR - 
+  int& local_int_ref1 = vint_obj;		// ERROR - 
+
+  take_int_ref (cint_obj);			// ERROR - caught
+  take_int_ref (vint_obj);			// ERROR - 
+
+  take_int_ref (cint_ref);			// ERROR - 
+  take_int_ref (vint_ref);			// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900519_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900519_03.C
new file mode 100644
index 00000000000..114d90960bf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900519_03.C
@@ -0,0 +1,47 @@
+// g++ 1.37.1 bug 900519_03
+
+// The C++ Reference Manual says (in section 8.4.3) "A reference to a 
+// volatile T can be initialized with a volatile T or a plain T but not a
+// const T.  A reference to a const T can be initialized with a const T or
+// a plain T or something that can be converted into a plain T, but not a
+// volatile T."
+
+// g++ fails to disgnose such errors in most cases.
+
+// keywords: references, initialization, type qualifiers
+
+extern const int cint_obj;
+extern volatile int vint_obj;
+
+void take_cint_ref (const int& arg) { }	// ERROR - 
+void take_vint_ref (volatile int& arg) { } // ERROR - 
+
+const int& global_cint_ref2 = vint_obj;		// ERROR - 
+
+volatile int& global_vint_ref1 = cint_obj;	// ERROR - 
+
+extern const int& extern_cint_ref;
+extern volatile int& extern_vint_ref;
+
+void test_0 ()
+{
+  const int& local_cint_ref2 = vint_obj;	// ERROR - 
+
+  volatile int& local_vint_ref1 = cint_obj;	// ERROR - 
+} 
+
+void test_1 ()
+{
+  take_cint_ref (vint_obj);			// ERROR - 
+
+  take_vint_ref (cint_obj);			// ERROR - caught
+}
+
+void test_2 ()
+{
+  take_cint_ref (extern_vint_ref);		// ERROR - 
+
+  take_vint_ref (extern_cint_ref);		// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900519_04.C b/gcc/testsuite/g++.old-deja/g++.bugs/900519_04.C
new file mode 100644
index 00000000000..53867a1b2b0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900519_04.C
@@ -0,0 +1,21 @@
+// g++ 1.37.1 bug 900519_04
+
+// The following legal code causes g++ to segfault.
+
+// cfront 2.0 passes this test.
+
+// keywords: segfault, references, initialization
+
+int cint_obj = 9;
+
+void take_cint_ref (int& arg) { }
+
+int& cint_ref_0 = cint_obj;
+int& cint_ref_1 = cint_obj;
+
+void test_0 ()
+{
+  take_cint_ref (cint_ref_1);	// causes segfault
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900519_05.C b/gcc/testsuite/g++.old-deja/g++.bugs/900519_05.C
new file mode 100644
index 00000000000..9a2a4cffaa2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900519_05.C
@@ -0,0 +1,18 @@
+// g++ 1.37.1 bug 900519_05
+
+// g++ fails to allow the use of function-reference types.
+
+// cfront 2.0 passes this test.
+
+// keywords: function types, reference types
+
+typedef void (func_type) (int, int);
+typedef func_type& func_ref_type;		
+
+void function (int arg1, int arg2)
+{
+}
+
+func_type& global_func_ref1 = function;		
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900519_06.C b/gcc/testsuite/g++.old-deja/g++.bugs/900519_06.C
new file mode 100644
index 00000000000..5704c3f9520
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900519_06.C
@@ -0,0 +1,22 @@
+// g++ 1.37.1 bug 900519_06
+
+// g++ allows the type given in an invocation of operator new to be a
+// reference type.
+
+// Since pointers to reference types are illegal, the required return type
+// from such an invocation (of operator new) is illegal, and thus (it seems)
+// the entire call to new should be treated as being illegal.
+
+typedef int& int_ref;
+
+void test (int n)
+{
+  new int&;		// ERROR - missed
+  new int_ref;		// ERROR - missed
+  new int&[n];		// ERROR - missed
+  new int_ref[n];	// ERROR - missed
+  new int&[3];		// ERROR - missed
+  new int_ref[3];	// ERROR - missed
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900519_07.C b/gcc/testsuite/g++.old-deja/g++.bugs/900519_07.C
new file mode 100644
index 00000000000..f5ea6bcb8d8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900519_07.C
@@ -0,0 +1,16 @@
+// g++ 1.37.1 bug 900519_07
+
+// It is illegal to specify or to use array-of-reference types, yet g++
+// allows them to be specified (in typedef statements and in declarations)
+// and to be used (in declarations).
+
+// keywords: reference types, array types
+
+int i;
+int j;
+
+typedef int& int_ref;
+typedef int_ref int_ref_array_type[2];		// ERROR - missed
+
+int& int_ref_array_obj0[2] = { i, j };		// ERROR - missed
+int_ref int_ref_array_obj1[2] = { i, j };	// ERROR - missed
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900519_09.C b/gcc/testsuite/g++.old-deja/g++.bugs/900519_09.C
new file mode 100644
index 00000000000..3bff70eed74
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900519_09.C
@@ -0,0 +1,29 @@
+// g++ 1.37.1 bug 900519_09
+
+// g++ allows the allocation of const objects via operator new even when
+// these uses of operator new do not include initializations.
+
+// This is inconsistant within the restrictions placed on the construction
+// of class, struct, and union types which have constant members.
+
+// Since there is no completely valid way of initializing such objects
+// after the invocation of new, these cases should all be illegal.
+
+// keywords: operator new, initialization, const qualifier
+
+struct struct_0 {
+  int member;
+};
+
+typedef const int const_int;
+typedef const struct struct_0 const_struct_0;
+
+void test ()
+{
+  new const int;		// ERROR - 
+  new const_int;		// ERROR - 
+  new const struct_0;		// ERROR - 
+  new const_struct_0;		// ERROR - 
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900519_12.C b/gcc/testsuite/g++.old-deja/g++.bugs/900519_12.C
new file mode 100644
index 00000000000..112b989b805
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900519_12.C
@@ -0,0 +1,11 @@
+// g++ 1.37.1 bug 900519_12
+
+// The following erroneous code causes g++ to segfault.
+
+// cfront 2.0 passes this test.
+
+// keywords: segfault, typedef, pointer type, function type
+
+typedef eek void (*)();		// ERROR - 
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900519_13.C b/gcc/testsuite/g++.old-deja/g++.bugs/900519_13.C
new file mode 100644
index 00000000000..b4bebda6588
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900519_13.C
@@ -0,0 +1,35 @@
+// g++ 1.37.1 bug 900519_13
+
+// If multiple inheritance creates a situation in which a given name is
+// inherited from more than one base class, and if the inherited declarations
+// for the name are for different categories of members (e.g. object members,
+// function members, enumeral members), then g++ will (in some cases) fail
+// to flag errors when the ambiguous name is used.
+
+// cfront 2.0 passes this test.
+
+// keywords: inheritance, ambiguity resolution, members
+
+struct base_0 {
+  enum { base_member }; // ERROR - candidate (26, 30)
+};
+
+struct base_1 {
+  int base_member;      // ERROR - candidate (26, 34)
+};
+
+struct base_2 {
+  int base_member ();   // ERROR - candidate (30, 34)
+};
+
+struct derived_0 : public base_0, public base_1 {
+  void member () { base_member; }			// ERROR - 
+};
+
+struct derived_1 : public base_0, public base_2 {
+  void member () { base_member; }			// ERROR - missed
+};
+
+struct derived_2 : public base_1, public base_2 {
+  void member () { base_member; }			// ERROR - missed
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900520_02.C b/gcc/testsuite/g++.old-deja/g++.bugs/900520_02.C
new file mode 100644
index 00000000000..80543b67913
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900520_02.C
@@ -0,0 +1,26 @@
+// g++ 1.37.1 bug 900520_02
+
+// keywords: reference types, initialization, parameter passing
+
+typedef int b_array[3];
+typedef int u_array[];
+
+typedef b_array &b_array_ref;
+typedef u_array &u_array_ref;
+
+void take_b_array_ref (b_array_ref arg) { } // ERROR - passed to here
+
+extern u_array u_array_gbl_obj;
+
+u_array_ref u_array_ref_gbl_obj0 = u_array_gbl_obj;
+
+b_array_ref b_array_ref_gbl_obj0 = u_array_ref_gbl_obj0; // ERROR - invalid declaration
+
+void test_passing ()
+{
+  take_b_array_ref (u_array_ref_gbl_obj0); // ERROR - invalid call
+}
+
+b_array u_array_gbl_obj;
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900520_03.C b/gcc/testsuite/g++.old-deja/g++.bugs/900520_03.C
new file mode 100644
index 00000000000..b1f05c95b14
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900520_03.C
@@ -0,0 +1,49 @@
+// g++ 1.37.1 bug 900520_03
+
+// The C++ Reference Manual says (in section 8.2.4):
+
+//	When an identifier of array type appears in an expression, except
+//	as the operand of sizeof or & or used to initialize a reference,
+//	it is converted into a pointer to the first member of the array.
+
+// One must assume from the verbage, that when the name of a non-const array
+// object appears in one of the exempted contexts mentioned in this passage,
+// that it is *not* automatically converted into a pointer value, but rather
+// that it remains as an array type value, and that it may therefore also
+// still be an lvalue, and may be used to initialize references.
+
+// As the following code demonstrates, g++ does in fact treat the names
+// of non-const array objects as valid initializers for reference-to-array
+// type object in some (but not all) contexts.
+
+// The exception is that g++ does not allow names which designate objects
+// on incomplete array types to be used as actual parameters in function
+// calls where the corresponding formal parameter is of a reference-to-array
+// type.
+
+// g++ does however allow other similar sorts of initializations of non-formal
+// reference objects.
+
+// 5/16/94 (jason): The 1/25/94 WP explicitly states in section 8.3.5 that
+// parameter types may not contain pointers or references to arrays of unknown
+// bound.  g++ is correct.
+
+// keywords: reference types, array types, initialization, parameter passing
+
+typedef int u_array[];
+typedef u_array &u_array_ref;
+
+void take_u_array_ref (u_array_ref arg) { } // ERROR - reference to array of unknown bound in parmtype
+
+extern u_array u_array_gbl_obj;
+u_array_ref u_array_ref_gbl_obj0 = u_array_gbl_obj;	// OK
+
+void test_local_initialization ()
+{
+  u_array_ref u_array_ref_lcl_obj0 = u_array_gbl_obj;	// OK
+}
+
+void test_passing ()
+{
+  take_u_array_ref (u_array_gbl_obj);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900520_04.C b/gcc/testsuite/g++.old-deja/g++.bugs/900520_04.C
new file mode 100644
index 00000000000..d9488cf9b53
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900520_04.C
@@ -0,0 +1,40 @@
+// g++ 1.37.1 bug 900520_04
+
+// g++ does not yet support the initialization of scalar type objects
+// (including built-in arithmetic types, enum types, and pointer types)
+// via constructor initialization syntax except within a call to operator
+// new.
+
+// keywords: unimplemented, syntax, initialization, scalar types
+
+enum e_type { e_value };
+
+typedef char *charp;
+
+charp cp;
+
+int global_i (1);				// gets bogus error
+double global_d (9.9);				// gets bogus error
+charp global_cp0 (cp);				// gets bogus error
+charp global_cp1 (0);				// gets bogus error
+enum e_type global_e (e_value);			// gets bogus error
+
+void func0 ()
+{
+  int local_i (1);				// gets bogus error
+  double local_d (9.9);				// gets bogus error
+  charp local_cp0 (cp);				// gets bogus error
+  charp local_cp1 (0);				// gets bogus error
+  enum e_type local_e (e_value);		// gets bogus error
+}
+
+void func1 ()
+{
+  int* ip = new int (1);			// gets bogus error
+  double* dp = new double (9.9);		// gets bogus error
+  charp* cpp0 = new charp (cp);			// gets bogus error
+  charp* cpp1 = new charp (0);			// gets bogus error
+  enum e_type* ep = new e_type (e_value);	// gets bogus error
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900520_05.C b/gcc/testsuite/g++.old-deja/g++.bugs/900520_05.C
new file mode 100644
index 00000000000..d628ae37f9f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900520_05.C
@@ -0,0 +1,23 @@
+// g++ 1.37.1 bug 900520_05
+
+// The following legal code gets syntax errors from g++.
+
+// keywords: syntax, unimplemented, operator new, initialization, pointer types
+
+struct struct_0 {
+};
+
+char *cp;
+static struct_0 *sp;
+
+void test0 ()
+{
+  new char * (cp);		// gets bogus error
+}
+
+void test1 ()
+{
+  new struct_0 * (sp);		// gets bogus error
+}
+
+int main () { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.bugs/900520_06.C b/gcc/testsuite/g++.old-deja/g++.bugs/900520_06.C
new file mode 100644
index 00000000000..aa4ec9a320e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.bugs/900520_06.C
@@ -0,0 +1,78 @@
+// g++ 1.37.1 bug 900520_06
+
+// When an object of a class type is passed into a formal parameter of the
+// same class type (in a function call) the language definition calls for
+// this action to be treated like any other form of an initialization of
+// an object of the given class type.
+
+// g++ fails however to invoke the (compiler-supplied) copy constructor for
+// the class type when a parameter of the class type is passed as an
+// actual parameter.
+
+// This causes the following program to exit with a non-zero exit status.
+
+// cfront 2.0 passes this test.
+
+int base_copy_ctor_called = 0;
+int member_copy_ctor_called = 0;
+
+struct struct_0 {
+  struct_0 ();
+  struct_0 (const struct_0&);
+};
+
+struct_0::struct_0 ()
+{
+}
+
+struct_0::struct_0 (const struct_0&)
+{
+  base_copy_ctor_called++;
+}
+
+struct struct_1 {
+  struct_1 ();
+  struct_1 (const struct_1&);
+};
+
+struct_1::struct_1 ()
+{
+}
+
+struct_1::struct_1 (const struct_1&)
+{
+  member_copy_ctor_called++;
+}
+
+struct struct_2 : public struct_0 {
+  struct_2 ();
+  struct_1 struct_1_member;
+#ifdef MAKE_COPY_CONSTRUCTOR_EXPLICIT
+  struct_2 (const struct_2&);
+#endif
+};
+
+struct_2::struct_2 ()
+{
+}
+
+#ifdef MAKE_COPY_CONSTRUCTOR_EXPLICIT
+struct_2::struct_2 (const struct_2& arg) :
+  struct_0 ((struct_0&)arg),
+  struct_1_member (arg.struct_1_member)
+{
+}
+#endif
+
+void take_struct_2 (struct_2 arg)
+{
+}
+
+int test ()
+{
+  struct_2 struct_2_object0;
+  take_struct_2 (struct_2_object0);
+  return (base_copy_ctor_called != 1 || member_copy_ctor_called != 1);
+}
+
+int main () { return test (); }
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/cleanup1.C b/gcc/testsuite/g++.old-deja/g++.eh/cleanup1.C
new file mode 100644
index 00000000000..6faea269c9d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/cleanup1.C
@@ -0,0 +1,34 @@
+// Bug: obj gets destroyed twice because the fixups for the return are
+// inside its cleanup region.
+
+extern "C" int printf (const char *, ...);
+
+int d;
+
+struct myExc { };
+
+struct myExcRaiser {
+  ~myExcRaiser() { throw myExc(); }
+};
+
+struct stackObj {
+  ~stackObj() { ++d; printf ("stackObj::~stackObj()\n"); };
+};
+
+int test()
+{
+  myExcRaiser rais;
+  stackObj obj;
+  return 0;
+}
+
+int main()
+{
+  try {
+    test();
+  }
+  catch (myExc &) {
+    return d != 1;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/ctor1.C b/gcc/testsuite/g++.old-deja/g++.eh/ctor1.C
new file mode 100644
index 00000000000..9874131a44d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/ctor1.C
@@ -0,0 +1,15 @@
+struct A
+{
+  A();
+  A(A&);			// ERROR - referenced below
+};
+
+int
+main ()
+{
+  try
+    {
+      throw A();		// ERROR - can't copy
+    }
+  catch (...) { }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/flow1.C b/gcc/testsuite/g++.old-deja/g++.eh/flow1.C
new file mode 100644
index 00000000000..024670cf347
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/flow1.C
@@ -0,0 +1,21 @@
+#include <stdio.h>
+
+int bar ()
+{
+  throw 100;
+}
+
+int main ()
+{
+  int i = 0;			// this gets deleted after flow analysis
+  try
+    {
+      i = bar ();
+    }
+  catch (...)
+    {
+    }
+
+  printf ("i = %d\n", i);
+  return i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/new1.C b/gcc/testsuite/g++.old-deja/g++.eh/new1.C
new file mode 100644
index 00000000000..1671dbbe7de
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/new1.C
@@ -0,0 +1,44 @@
+// Test that a throw in foo destroys the A, but does not free the memory.
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <new.h>
+
+struct A {
+  A();
+  ~A();
+};
+
+struct B {
+  B (A);
+};
+
+void foo (B*);
+
+int newed, created;
+
+int main ()
+{
+  try {
+    foo (new B (A ()));
+  } catch (...) { }
+
+  return !(newed && !created);
+}
+
+A::A() { created = 1; }
+A::~A() { created = 0; }
+B::B(A) { }
+void foo (B*) { throw 1; }
+
+void* operator new (size_t size) throw (std::bad_alloc)
+{
+  ++newed;
+  return (void *) malloc (size);
+}
+
+void operator delete (void *p) throw ()
+{
+  --newed;
+  free (p);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/new2.C b/gcc/testsuite/g++.old-deja/g++.eh/new2.C
new file mode 100644
index 00000000000..ddc8ba82e58
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/new2.C
@@ -0,0 +1,45 @@
+// Test that a throw in B's constructor destroys the A and frees the memory.
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <new.h>
+
+struct A {
+  A();
+  ~A();
+};
+
+struct B {
+  B (A);
+};
+
+void foo (B*);
+
+int newed, created;
+
+int main ()
+{
+  newed = 0; // The libraries might call new before main starts.
+  try {
+    foo (new B (A ()));
+  } catch (...) { }
+
+  return !(!newed && !created);
+}
+
+A::A() { created = 1; }
+A::~A() { created = 0; }
+B::B(A) { throw 1; }
+void foo (B*) { }
+
+void* operator new (size_t size) throw (std::bad_alloc)
+{
+  ++newed;
+  return (void *) malloc (size);
+}
+
+void operator delete (void *p) throw ()
+{
+  --newed;
+  free (p);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/pdel1.C b/gcc/testsuite/g++.old-deja/g++.eh/pdel1.C
new file mode 100644
index 00000000000..b8e553c0e2f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/pdel1.C
@@ -0,0 +1,22 @@
+// Test for calling placement delete.
+
+#include <new>
+#include <stddef.h>
+
+int r = 1;
+
+struct A {
+  A() { throw 1; }
+  void operator delete (void *p, int, int) { r = 0; ::operator delete (p); }
+};
+
+void * operator new (size_t size, int, int) { return operator new (size); }
+
+int main ()
+{
+  try {
+    A* ap = new (1, 5) A;
+  } catch (...) {  }
+
+  return r;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/pdel2.C b/gcc/testsuite/g++.old-deja/g++.eh/pdel2.C
new file mode 100644
index 00000000000..12efcd386cf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/pdel2.C
@@ -0,0 +1,22 @@
+// Test for not calling mismatched placement delete.
+
+#include <new>
+#include <stddef.h>
+
+int r = 0;
+
+struct A {
+  A() { throw 1; }
+  void operator delete (void *p, int, long) { r = 1; ::operator delete (p); }
+};
+
+void * operator new (size_t size, int, int) { return operator new (size); }
+
+int main ()
+{
+  try {
+    A* ap = new (1, 5) A;
+  } catch (...) {  }
+
+  return r;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/ptr1.C b/gcc/testsuite/g++.old-deja/g++.eh/ptr1.C
new file mode 100644
index 00000000000..9101e9e3010
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/ptr1.C
@@ -0,0 +1,22 @@
+// Bug: catching pointers by reference doesn't work right.
+
+extern "C" int printf (const char *, ...);
+
+struct E {
+  int x;
+  E(int i) { x = i; };
+};
+
+int main()
+{
+  try {
+    E *p = new E(5);
+    throw p;
+  }
+
+  catch (E *&e) {
+    printf ("address of e is 0x%lx\n", (long)e);
+    return !(long(e) != 5 && e->x == 5);
+  }
+  return 2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/rethrow1.C b/gcc/testsuite/g++.old-deja/g++.eh/rethrow1.C
new file mode 100644
index 00000000000..ef4dcb4f19d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/rethrow1.C
@@ -0,0 +1,45 @@
+// Testcase for proper handling of rethrow.
+
+#include <stdio.h>
+
+int c, d;
+
+struct A
+{
+  int i;
+  A () { i = ++c; printf ("A() %d\n", i); }
+  A (const A&) { i = ++c; printf ("A(const A&) %d\n", i); }
+  ~A() { printf ("~A() %d\n", i); ++d; }
+};
+
+int
+main ()
+{
+  try
+    {
+      try
+	{
+	  printf ("Throwing 1...\n");
+	  throw A();
+	}
+      catch (A)
+	{
+	  try
+	    {
+	      printf ("Throwing 2...\n");
+	      throw A();
+	    }
+	  catch (A)
+	    {
+	      printf ("Throwing 3...\n");
+	      throw;
+	    }
+	}
+    }
+  catch (A)
+    {
+      printf ("Caught.\n");
+    }
+  printf ("c == %d, d == %d\n", c, d);
+  return c != d;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/rethrow2.C b/gcc/testsuite/g++.old-deja/g++.eh/rethrow2.C
new file mode 100644
index 00000000000..2d2583b7219
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/rethrow2.C
@@ -0,0 +1,45 @@
+// Testcase for proper handling of rethrow.
+
+#include <stdio.h>
+
+int c, d;
+
+struct A
+{
+  int i;
+  A () { i = ++c; printf ("A() %d\n", i); }
+  A (const A&) { i = ++c; printf ("A(const A&) %d\n", i); }
+  ~A() { printf ("~A() %d\n", i); ++d; }
+};
+
+int
+main ()
+{
+  try
+    {
+      try
+	{
+	  printf ("Throwing 1...\n");
+	  throw A();
+	}
+      catch (A)
+	{
+	  try
+	    {
+	      printf ("Throwing 2...\n");
+	      throw;
+	    }
+	  catch (A)
+	    {
+	      printf ("Throwing 3...\n");
+	      throw;
+	    }
+	}
+    }
+  catch (A)
+    {
+      printf ("Caught.\n");
+    }
+  printf ("c == %d, d == %d\n", c, d);
+  return c != d;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/rethrow3.C b/gcc/testsuite/g++.old-deja/g++.eh/rethrow3.C
new file mode 100644
index 00000000000..5da2081b1b9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/rethrow3.C
@@ -0,0 +1,38 @@
+#include <stdio.h>
+#include <exception>
+
+static void
+eh_terminate ()
+{
+  printf ("CALLING TERMINATE\n");
+  exit (1);
+}
+
+void
+eh_test (int level)
+{
+  try
+    {
+      if (level < 2)
+	eh_test (level + 1);
+      else
+	{
+	  printf ("%d: Throwing\n", level);
+	  throw (level);
+	}
+    }
+  catch (int &x)
+    {
+      printf ("%d: Got level %d\n",
+	      level, x);
+
+      if (level > 0)
+	throw;
+    }
+}
+
+int main ()
+{
+  std::set_terminate (&eh_terminate);
+  eh_test (0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/rethrow4.C b/gcc/testsuite/g++.old-deja/g++.eh/rethrow4.C
new file mode 100644
index 00000000000..c5dcd2314a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/rethrow4.C
@@ -0,0 +1,45 @@
+// Testcase for proper handling of rethrow.
+
+#include <stdio.h>
+
+int c, d;
+
+struct A
+{
+  int i;
+  A () { i = ++c; printf ("A() %d\n", i); }
+  A (const A&) { i = ++c; printf ("A(const A&) %d\n", i); }
+  ~A() { printf ("~A() %d\n", i); ++d; }
+};
+
+int
+main ()
+{
+  try
+    {
+      try
+	{
+	  printf ("Throwing 1...\n");
+	  throw A();
+	}
+      catch (A)
+	{
+	  try
+	    {
+	      printf ("Throwing 2...\n");
+	      throw;
+	    }
+	  catch (A)
+	    {
+	      printf ("Throwing 3...\n");
+	      throw A();
+	    }
+	}
+    }
+  catch (A)
+    {
+      printf ("Caught.\n");
+    }
+  printf ("c == %d, d == %d\n", c, d);
+  return c != d;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/rethrow5.C b/gcc/testsuite/g++.old-deja/g++.eh/rethrow5.C
new file mode 100644
index 00000000000..f137d1841cd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/rethrow5.C
@@ -0,0 +1,44 @@
+// Testcase for proper handling of rethrow.
+
+#include <stdio.h>
+
+int c, d;
+
+struct A
+{
+  int i;
+  A () { i = ++c; printf ("A() %d\n", i); }
+  A (const A&) { i = ++c; printf ("A(const A&) %d\n", i); }
+  ~A() { printf ("~A() %d\n", i); ++d; }
+};
+
+int
+main ()
+{
+  try
+    {
+      try
+	{
+	  printf ("Throwing 1...\n");
+	  throw A();
+	}
+      catch (A)
+	{
+	  try
+	    {
+	      printf ("Throwing 2...\n");
+	      throw;
+	    }
+	  catch (A)
+	    {
+	      printf ("Falling out...\n");
+	    }
+	}
+    }
+  catch (A)
+    {
+      printf ("Caught.\n");
+    }
+  printf ("c == %d, d == %d\n", c, d);
+  return c != d;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/spec1.C b/gcc/testsuite/g++.old-deja/g++.eh/spec1.C
new file mode 100644
index 00000000000..044af8cdb9b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/spec1.C
@@ -0,0 +1,38 @@
+// Testing exception specifications.
+// Test 1: the original exception succeeds.
+
+#include <stdlib.h>
+#include <exception>
+
+void my_term ()  { exit (1); }
+void my_unexp () { throw 42; }
+
+void
+f () throw (char, int, std::bad_exception)
+{
+  throw 'a';
+}
+
+int main ()
+{
+  std::set_terminate (my_term);
+  std::set_unexpected (my_unexp);
+
+  try
+    {
+      f ();
+    }
+  catch (char)
+    {
+      return 0;
+    }
+  catch (int)
+    {
+      return 3;
+    }
+  catch (std::bad_exception)
+    {
+      return 4;
+    }
+  return 5;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/spec2.C b/gcc/testsuite/g++.old-deja/g++.eh/spec2.C
new file mode 100644
index 00000000000..d0269b3a4be
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/spec2.C
@@ -0,0 +1,38 @@
+// Testing exception specifications.
+// Test 2: the second throw succeeds.
+
+#include <stdlib.h>
+#include <exception>
+
+void my_term ()  { exit (1); }
+void my_unexp () { throw 42; }
+
+void
+f () throw (int, std::bad_exception)
+{
+  throw 'a';
+}
+
+int main ()
+{
+  std::set_terminate (my_term);
+  std::set_unexpected (my_unexp);
+
+  try
+    {
+      f ();
+    }
+  catch (char)
+    {
+      return 2;
+    }
+  catch (int)
+    {
+      return 0;
+    }
+  catch (std::bad_exception)
+    {
+      return 4;
+    }
+  return 5;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/spec3.C b/gcc/testsuite/g++.old-deja/g++.eh/spec3.C
new file mode 100644
index 00000000000..57b29d48908
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/spec3.C
@@ -0,0 +1,38 @@
+// Testing exception specifications.
+// Test 3: the bad_exception throw succeeds.
+
+#include <stdlib.h>
+#include <exception>
+
+void my_term ()  { exit (1); }
+void my_unexp () { throw 42; }
+
+void
+f () throw (std::bad_exception)
+{
+  throw 'a';
+}
+
+int main ()
+{
+  std::set_terminate (my_term);
+  std::set_unexpected (my_unexp);
+
+  try
+    {
+      f ();
+    }
+  catch (char)
+    {
+      return 2;
+    }
+  catch (int)
+    {
+      return 3;
+    }
+  catch (std::bad_exception)
+    {
+      return 0;
+    }
+  return 5;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/spec4.C b/gcc/testsuite/g++.old-deja/g++.eh/spec4.C
new file mode 100644
index 00000000000..a92f7f06469
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/spec4.C
@@ -0,0 +1,38 @@
+// Testing exception specifications.
+// Test 4: all throws fail, call terminate.
+
+#include <stdlib.h>
+#include <exception>
+
+void my_term ()  { exit (0); }
+void my_unexp () { throw 42; }
+
+void
+f () throw (short)
+{
+  throw 'a';
+}
+
+int main ()
+{
+  std::set_terminate (my_term);
+  std::set_unexpected (my_unexp);
+
+  try
+    {
+      f ();
+    }
+  catch (char)
+    {
+      return 2;
+    }
+  catch (int)
+    {
+      return 3;
+    }
+  catch (std::bad_exception)
+    {
+      return 4;
+    }
+  return 5;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/spec5.C b/gcc/testsuite/g++.old-deja/g++.eh/spec5.C
new file mode 100644
index 00000000000..56154f973ee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/spec5.C
@@ -0,0 +1,3 @@
+// Build don't link:
+
+extern void *f(unsigned int k) throw();
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/spec6.C b/gcc/testsuite/g++.old-deja/g++.eh/spec6.C
new file mode 100644
index 00000000000..e9e3e770012
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/spec6.C
@@ -0,0 +1,46 @@
+// Build don't link:
+
+// Copyright (C) 1999 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 19 Jan 1999 <nathan@acm.org>
+
+// Determine that throw specifiers are checked correctly.
+
+// [except.spec] 1, a type in an exception specifier shall not be incomplete,
+// or pointer or ref to incomplete
+struct X; // ERROR - forward declaration - XFAIL
+void fn1() throw(X);  // ERROR - incomplete type - XFAIL
+void fn2() throw(X *); // ERROR - incomplete type - XFAIL
+void fn3() throw(X &); // ERROR - incomplete type - XFAIL
+void fn4() throw(void); // ERROR - incomplete type - XFAIL
+// except for cv pointer to void
+void fn5() throw(void *);
+
+// [except.spec] 2, exception specifiers must be the same set of types (but
+// can be reordered)
+void fn() throw(int, char);   // gets bogus error - XFAIL
+void fn() throw(char, int){}  // gets bogus error - ordering is irrelevant - XFAIL
+
+// [except.spec] 3, virtual function overriders shall throw a subset of the
+// overridden function
+struct E {};
+struct F : public E {};
+struct A
+{
+  virtual void foo() throw();
+  virtual void baz() throw(double, int);
+  virtual void bar();
+  virtual void qux() throw(E);
+  virtual void quux() throw(F);
+};
+
+struct B : A
+{
+  virtual void foo() throw(int);  // ERROR - not in base function - XFAIL
+  virtual void baz() throw(double);
+  virtual void bar(int) throw(int);
+  virtual void qux() throw(F);
+  virtual void quux() throw(E);   // ERROR - not in base function - XFAIL
+};
+
+// [except.spec] 5, types shall not be defined in exception specifiers
+void fn6() throw(struct Z {}); // ERROR - types shall not be defined - XFAIL
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/throw1.C b/gcc/testsuite/g++.old-deja/g++.eh/throw1.C
new file mode 100644
index 00000000000..49a7d1e68fd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/throw1.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+void athrow(const int & e) throw(int)
+{
+   throw e;
+}
+
+int main(void)
+{
+   athrow(int());
+   return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/throw2.C b/gcc/testsuite/g++.old-deja/g++.eh/throw2.C
new file mode 100644
index 00000000000..fbf0cec9c35
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/throw2.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+// Submitted by Sebastian Ritterbusch <uabp@rz.uni-karlsruhe.de>
+
+#define ANY int // a class with a public constructor
+
+void athrow(const ANY & e) throw(ANY)
+{
+   throw e; // gets bogus error - discarding const
+}
+
+int main(void)
+{
+   athrow(ANY());
+   return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/tmpl1.C b/gcc/testsuite/g++.old-deja/g++.eh/tmpl1.C
new file mode 100644
index 00000000000..cdbd6e1feeb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/tmpl1.C
@@ -0,0 +1,15 @@
+template <class T>
+void f() throw (T)
+{
+  throw 7;
+}
+
+
+int main()
+{
+  try {
+    f<int>();
+  } catch (...) {
+    return 0;
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/tmpl2.C b/gcc/testsuite/g++.old-deja/g++.eh/tmpl2.C
new file mode 100644
index 00000000000..af3dc7bc12a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/tmpl2.C
@@ -0,0 +1,33 @@
+// Build don't link:
+// Special g++ flags: -O
+// crash test - XFAIL i*86-*-linux*
+
+// Posted by H. J. Lu <hjl@lucon.org>
+
+template<class T>
+class FixSeq
+{
+public:
+    void append(const T&);
+};
+class foo
+{
+public:  
+    void setupIR();
+};
+typedef FixSeq<foo *> bar;
+extern void dummy (foo *);
+void *
+foobar (bar &x, foo *p)
+{
+    try
+    {
+        p -> setupIR();
+    }
+    catch(...)
+    {
+        dummy (p);
+    }
+    x.append(p);
+    return p;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/tmpl3.C b/gcc/testsuite/g++.old-deja/g++.eh/tmpl3.C
new file mode 100644
index 00000000000..521315e17e2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/tmpl3.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+// Posted by Trevor Taylor <ttaylor@powerup.com.au>
+
+template<class T> struct A {
+    void X() throw(T);
+};
+
+template<class T>
+inline void A<T>::X() 
+throw(T) { } 
diff --git a/gcc/testsuite/g++.old-deja/g++.eh/unwind1.C b/gcc/testsuite/g++.old-deja/g++.eh/unwind1.C
new file mode 100644
index 00000000000..617b355a6c6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.eh/unwind1.C
@@ -0,0 +1,24 @@
+// Test that unwinding properly restores SP.
+// Contributed by Jason Merrill <jason@cygnus.com>
+
+int f (int i)
+{
+  throw i;
+}
+
+int main ()
+{  
+  void *sp1 = __builtin_alloca (0);
+
+  try
+    {
+      f (0);
+    }
+  catch (int)
+    {
+    }
+
+  void *sp2 = __builtin_alloca (0);
+
+  return (sp1 != sp2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/addrfunc1.C b/gcc/testsuite/g++.old-deja/g++.ext/addrfunc1.C
new file mode 100644
index 00000000000..3e254e6f82b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/addrfunc1.C
@@ -0,0 +1,18 @@
+// Test that taking the address of a member function name produces
+// a pointer to member function.
+// Contributed by Jason Merrill <jason@cygnus.com>
+// Special g++ Options: -fpermissive -w
+// Build don't link:
+
+struct A { };
+int (A::*p)();
+
+struct B {
+  int f () { return 0; }
+  void g ();
+};
+
+void B::g ()
+{
+  p = (int (A::*)())&f;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/addrfunc2.C b/gcc/testsuite/g++.old-deja/g++.ext/addrfunc2.C
new file mode 100644
index 00000000000..da98333d809
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/addrfunc2.C
@@ -0,0 +1,16 @@
+// Test for implicit & on methods.
+// Contributed by Jason Merrill <jason@cygnus.com>.
+// Special g++ Options: -fpermissive -w
+
+struct A {
+  void f (int = 0) { }
+};
+
+int
+main ()
+{
+  void (A::*p)(int) = 0;
+  p = A::f;
+  if (p != A::f)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/addrfunc3.C b/gcc/testsuite/g++.old-deja/g++.ext/addrfunc3.C
new file mode 100644
index 00000000000..7926eba41da
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/addrfunc3.C
@@ -0,0 +1,13 @@
+// Test for overload resolution in comparison expressions.
+// Contributed by Jason Merrill <jason@cygnus.com>.
+// Special g++ Options: -fpermissive -w
+
+void f (int) { }
+void f ();
+
+int main () {
+  void (*p)(int);
+  p = f;
+  if (p != f)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/array1.C b/gcc/testsuite/g++.old-deja/g++.ext/array1.C
new file mode 100644
index 00000000000..808eb534403
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/array1.C
@@ -0,0 +1,22 @@
+// Testcase for assignment of non-array to array (assigns the same value to
+// each member)
+// Build don't link:
+// Special Options: 
+
+typedef struct {} ct2d_rigid, ct2d_rigid_a[1];
+class ccInspection
+{
+protected:
+  ct2d_rigid_a _dev2phys;	 
+};
+class ccBgaInspection : public ccInspection
+{
+public:
+  int reinspect (unsigned long diagFlags);
+};
+int
+ccBgaInspection::reinspect (unsigned long diag_flags) 
+{
+  ct2d_rigid physTdev;		 
+  _dev2phys = physTdev; // ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/array2.C b/gcc/testsuite/g++.old-deja/g++.ext/array2.C
new file mode 100644
index 00000000000..13679af63b2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/array2.C
@@ -0,0 +1,13 @@
+// This testcase used to cause a crash on the Alpha.
+// Special g++ Options: 
+// Build don't link:
+
+struct A {
+  int i;
+  ~A() { }
+};
+
+A f (int n)
+{
+  A a[n];
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/arrnew.C b/gcc/testsuite/g++.old-deja/g++.ext/arrnew.C
new file mode 100644
index 00000000000..ef051d265a0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/arrnew.C
@@ -0,0 +1,5 @@
+// PRMS Id: 4992
+// Build don't link:
+// Special g++ Options:
+
+	int *f(){ return new int[1] = { 1 };   }
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/arrnew2.C b/gcc/testsuite/g++.old-deja/g++.ext/arrnew2.C
new file mode 100644
index 00000000000..e572081cb81
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/arrnew2.C
@@ -0,0 +1,4 @@
+// Build don't link:
+// Special g++ Options:
+
+int *foo = new int[1](0); // gets bogus error - 
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/attrib1.C b/gcc/testsuite/g++.old-deja/g++.ext/attrib1.C
new file mode 100644
index 00000000000..dd14628956b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/attrib1.C
@@ -0,0 +1,11 @@
+// Test for using prefix attributes in a parameter decl.
+// Contributed by Jason Merrill <jason@cygnus.com>
+// Skip if not target: i?86-*-*
+// Build don't link:
+
+#define _stdcall __attribute__ ((__stdcall__))
+
+typedef void (_stdcall* pfn)();
+
+void f (void (_stdcall*)    ());
+void f (void (_stdcall* pfn)());
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/attrib2.C b/gcc/testsuite/g++.old-deja/g++.ext/attrib2.C
new file mode 100644
index 00000000000..8c32d4344e5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/attrib2.C
@@ -0,0 +1,15 @@
+// Test that stdcall doesn't prevent us from using op delete.
+// Contributed by Jason Merrill <jason@cygnus.com>
+// Skip if not target: i?86-*-*
+
+struct A {
+  void operator delete (void *) __attribute__ ((stdcall));
+};
+
+void A::operator delete (void *) { }
+
+int main()
+{
+  A* ap = new A;
+  delete ap;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/attrib3.C b/gcc/testsuite/g++.old-deja/g++.ext/attrib3.C
new file mode 100644
index 00000000000..18b16530bc3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/attrib3.C
@@ -0,0 +1,20 @@
+// Test for proper handling of attributes in template instantiation.
+// Contributed by Jason Merrill <jason@cygnus.com>
+// Skip if not target: i?86-*-*
+
+template <class T>
+struct A {
+  static void f () __attribute__ ((stdcall));
+};
+
+template <class T> void
+A<T>::f () { }
+
+void g (void (__attribute__ ((stdcall)) *p)()) { }
+void g (int);
+
+int
+main ()
+{
+  g (&A<int>::f);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/attrib4.C b/gcc/testsuite/g++.old-deja/g++.ext/attrib4.C
new file mode 100644
index 00000000000..5200eac9d92
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/attrib4.C
@@ -0,0 +1,24 @@
+// Test that attributes are really applied to function declarations under
+// various conditions.
+// Contributed by Jason Merrill (jason@cygnus.com)
+// Special g++ Options: -Wformat
+// Build don't link:
+
+#define PF __attribute__ ((format (printf, 1, 2)))
+
+struct A {
+  static PF void f (char *, ...);
+  friend PF void g (char *, ...);
+  static void test ();
+};
+
+void PF h (char *, ...);
+void PF k (char *, ...) { }
+
+void A::test ()
+{
+  f ("%f", 42);			// WARNING - 
+  g ("%f", 42);			// WARNING - 
+  h ("%f", 42);			// WARNING - 
+  k ("%f", 42);			// WARNING - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/attrib5.C b/gcc/testsuite/g++.old-deja/g++.ext/attrib5.C
new file mode 100644
index 00000000000..85f1139b78b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/attrib5.C
@@ -0,0 +1,11 @@
+// Test that attributes weak and alias coexist.
+
+extern "C" {
+  void f () __attribute__((weak, alias ("_f")));
+  void _f () { }
+}
+
+int main ()
+{
+  f ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/bound1.C b/gcc/testsuite/g++.old-deja/g++.ext/bound1.C
new file mode 100644
index 00000000000..3b926a49561
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/bound1.C
@@ -0,0 +1,29 @@
+// Testcase for cast of bound pointer to member function.
+// Special g++ Options: -Wno-pmf-conversions
+// Build don't link:
+
+struct A {
+  int f ();
+};
+
+typedef int (*fptr)(A *);
+typedef void* vptr;
+typedef int (A::*pmf)();
+
+int foo (A* ap, pmf fp, int A::* ip)
+{
+  fptr p;
+  vptr q;
+  A a;
+
+  p = (fptr)(ap->*fp);
+  p = (fptr)(ap->*fp);
+  p = (fptr)(ap->*(&A::f));
+  p = (fptr)(a.*fp);
+  p = (fptr)(a.*(&A::f));
+
+  q = (vptr)(ap->*fp);
+  q = (vptr)(ap->*(&A::f));
+  q = (vptr)(a.*fp);
+  q = (vptr)(a.*(&A::f));
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/constructor.C b/gcc/testsuite/g++.old-deja/g++.ext/constructor.C
new file mode 100644
index 00000000000..cdf9f1da98b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/constructor.C
@@ -0,0 +1,19 @@
+// Testcase for constructor expressions (GNU extension)
+// Special g++ Options:
+
+struct Any {
+    int *type;
+    int *addr;
+};
+
+int i, j;
+
+main () {
+  struct Any *ap = (struct Any *)
+    __builtin_alloca (sizeof(struct Any));
+  *ap = ((struct Any){ &i, &j }) ;
+
+  if (ap->type != &i || ap->addr != &j)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/default.C b/gcc/testsuite/g++.old-deja/g++.ext/default.C
new file mode 100644
index 00000000000..f434749ef33
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/default.C
@@ -0,0 +1,26 @@
+// PRMS Id: 5353
+// This may be an extension, but it's a very common one...
+
+extern "C" int printf (const char *, ...);
+
+class A {
+public:
+  static A*func (int = 3);
+  static A*(*ptr)(int = 4);
+};
+
+A*(*A::ptr)(int) = &A::func;
+
+int main()
+{
+  A foo;
+
+  A::ptr();
+  A::ptr(47);
+}
+
+A*A::func(int i)
+{
+  printf("I = %d\n",i);
+  return (A*)0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/implicit1.C b/gcc/testsuite/g++.old-deja/g++.ext/implicit1.C
new file mode 100644
index 00000000000..33b9450f6be
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/implicit1.C
@@ -0,0 +1,14 @@
+// test for implicit declaration
+// Special g++ Options: -w -fpermissive
+
+int
+main ()
+{
+  return blarg ();
+}
+
+extern "C" int
+blarg (...)
+{
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/jump1.C b/gcc/testsuite/g++.old-deja/g++.ext/jump1.C
new file mode 100644
index 00000000000..5e3dc26c876
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/jump1.C
@@ -0,0 +1,16 @@
+// Test that we can jump over the declaration of a non-POD object.
+// Contributed by Jason Merrill <jason@cygnus.com>
+// Special g++ Options: -fpermissive -w
+
+struct A { };
+union U {
+  void (A::*p)();
+};
+
+int main()
+{
+  goto foo;
+  U u;
+ foo:
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/memconst.C b/gcc/testsuite/g++.old-deja/g++.ext/memconst.C
new file mode 100644
index 00000000000..a49d3a05898
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/memconst.C
@@ -0,0 +1,25 @@
+// From: Ove.Ewerlid@syscon.uu.se (Ove Ewerlid)
+// Subject: ss-940630:cc1plus: internal error
+// Date: Sat, 2 Jul 1994 05:07:20 +0200
+// Special g++ Options:
+// Build don't link:
+
+class qwerty {
+public:
+    qwerty (const unsigned short userkey[8]);
+   ~qwerty ();
+};
+
+class foo {
+private:
+  static const unsigned char * const dummy_key = (unsigned char*)"ThisIs a dummy!";
+
+public:
+    void bar ();
+};
+
+void
+foo::bar ()
+{
+    qwerty QWERTY ((unsigned short*)dummy_key);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/null1.C b/gcc/testsuite/g++.old-deja/g++.ext/null1.C
new file mode 100644
index 00000000000..ca1efff480f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/null1.C
@@ -0,0 +1,8 @@
+// Test for overloading with g++ NULL.
+
+void f (int *) { }
+void f (char, char);
+int main ()
+{
+  f (__null);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/pretty.C b/gcc/testsuite/g++.old-deja/g++.ext/pretty.C
new file mode 100644
index 00000000000..715837de0be
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/pretty.C
@@ -0,0 +1,42 @@
+// Test for PRETTY_FUNCTION
+// Build don't link:
+
+class SV;
+
+class SVTable // : public Debug
+{
+  // It is an array to pointer to a SV.
+  SV ** array;
+
+  // This is the size of array.
+  int maxCount; 
+
+  // This is the current element count.
+  int count;
+
+  void fatal_error (const char *f, ...);
+
+public:
+  SVTable (int size, const char *d);
+  SVTable ();
+  SVTable (const SVTable &);
+  ~SVTable () {}
+
+};
+
+
+SVTable::SVTable (int size, const char *d)
+	: maxCount (size), count (0)// , Debug (d)
+{
+  if (size < 0)
+  {
+    fatal_error ("%s: Invalid size: %d\n", __PRETTY_FUNCTION__, size);
+  }
+
+  array = (SV **) new SV * [size];
+
+  if (array == 0)
+  {
+    fatal_error ("%s: Failed to allocate array\n", __PRETTY_FUNCTION__);
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/typeof1.C b/gcc/testsuite/g++.old-deja/g++.ext/typeof1.C
new file mode 100644
index 00000000000..a9c03b3ae60
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ext/typeof1.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+struct inttest {
+  int elem[1];
+};
+
+template <class T>
+void F(T x)
+{
+  typedef __typeof (x.elem[0]) dummy;
+  dummy i = 1;
+}
+
+int main() {
+  inttest x;
+  F(x);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/README b/gcc/testsuite/g++.old-deja/g++.gb/README
new file mode 100644
index 00000000000..db118908b26
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/README
@@ -0,0 +1,20 @@
+These are my C++ signature and class-scoping tests.
+
+In changing my signature tests to DejaGnu style, I reduced the number
+of tests from 40 to 25.  They should still test the same features,
+though.  All of these tests are run.  I don't have any tests yet to
+check correct reporting of errors/warnings.
+
+The class scoping tests were in part derived from Vince Russo's
+Renaissance operating system and in part written by myself in helping
+Niklas Hallqvist test his rewrite of the scoping code.  I had shared
+some of these tests with Niklas, others were included in bug reports I
+had sent to {g++,gcc}@cygnus.com.  It is, therefore, possible that
+these tests duplicate tests in other directories.
+
+All files in this directory, including this file, are Copyright FSF 1995
+and fall under the GPL version 2.0 or later.
+
+Gerald Baumgartner
+gb@cs.purdue.edu
+March 1, 1995
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope01.C b/gcc/testsuite/g++.old-deja/g++.gb/scope01.C
new file mode 100644
index 00000000000..e22dd394979
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope01.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed gb scope
+struct c { typedef int t; };
+struct d { typedef char t; };
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope02.C b/gcc/testsuite/g++.old-deja/g++.gb/scope02.C
new file mode 100644
index 00000000000..678b73e2251
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope02.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed gb scope
+struct c {
+  typedef int t;
+  struct d {
+    void foo (t &);
+  };
+};
+
+void c::d::foo (t & x) { }
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope03.C b/gcc/testsuite/g++.old-deja/g++.gb/scope03.C
new file mode 100644
index 00000000000..09fe16aed86
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope03.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed gb scope
+struct c {
+  class t { };
+  struct d {
+    void foo (t &);
+  };
+};
+
+void c::d::foo (t & x) { }
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope04.C b/gcc/testsuite/g++.old-deja/g++.gb/scope04.C
new file mode 100644
index 00000000000..f63775bdb49
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope04.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed gb scope
+struct a {
+  struct c {
+    struct d {
+      static int foo (int);
+    };
+  };
+
+  struct b {
+    int foo (int x) { return c::d::foo (x); }
+  };
+};
+
+int a::c::d::foo (int) { return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope05.C b/gcc/testsuite/g++.old-deja/g++.gb/scope05.C
new file mode 100644
index 00000000000..60f0b02a58d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope05.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed gb scope
+struct C {
+  void foo (int);
+  void foo (char);
+
+  struct D {
+    void foo ();
+  };
+};
+
+void C::D::foo () { }
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope06.C b/gcc/testsuite/g++.old-deja/g++.gb/scope06.C
new file mode 100644
index 00000000000..46c9d07b5da
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope06.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed gb scope
+struct C {
+  struct D {
+    int x;
+    void foo ();
+  };
+      const int Ok = 0; // ERROR - initialization forbidden
+};
+
+void C::D::foo ()
+{
+  x = Ok;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope07.C b/gcc/testsuite/g++.old-deja/g++.gb/scope07.C
new file mode 100644
index 00000000000..051bbb5fb50
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope07.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed gb scope
+struct D {
+  friend class A;
+  friend class B;
+  friend class C;
+
+  void foo ();
+};
+
+void D::foo () { }
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope08.C b/gcc/testsuite/g++.old-deja/g++.gb/scope08.C
new file mode 100644
index 00000000000..2451965f053
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope08.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed gb scope
+template <class X> class C {
+public:
+  int f (X ob) { return 0; }
+  int g (X ob) { return f (ob); }
+};
+
+class D {
+public:
+  class E { public: E (); };
+
+  C <E> x;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope09.C b/gcc/testsuite/g++.old-deja/g++.gb/scope09.C
new file mode 100644
index 00000000000..cc17afc9fe2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope09.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed gb scope
+class enclose {
+  int e;
+protected:
+  class nested {
+    int n;
+  };
+};
+
+class derived : public enclose {
+protected:
+  class nested_derived : public nested {
+    int nd;
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope10.C b/gcc/testsuite/g++.old-deja/g++.gb/scope10.C
new file mode 100644
index 00000000000..32caa6084a1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope10.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed gb scope
+void Foo (void)
+{
+  class C {
+  public:
+    virtual int foo (void) { return 0; };
+  };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope11.C b/gcc/testsuite/g++.old-deja/g++.gb/scope11.C
new file mode 100644
index 00000000000..19229df9f25
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope11.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// GROUPS passed gb scope
+template<class T, int N> class fixed_array {
+public:
+  T _array[N];
+};
+
+class Hash {
+public:
+  Hash (int);
+};
+
+typedef fixed_array<char, 4> ipAddress_t;
+
+class IPAddress {
+protected:
+  long _i;
+public:
+  IPAddress (ipAddress_t ip) { }
+  IPAddress () { }
+  IPAddress netMask () { return *this; }
+  operator Hash ();
+};
+
+IPAddress::operator Hash ()
+{
+  return Hash (_i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope12.C b/gcc/testsuite/g++.old-deja/g++.gb/scope12.C
new file mode 100644
index 00000000000..52916b955b1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope12.C
@@ -0,0 +1,35 @@
+// Build don't link: 
+// GROUPS passed gb scope
+template<class T, int N> class FixedArray_t {
+public:
+  T _array[N];
+
+  FixedArray_t () { }
+};
+
+typedef FixedArray_t<unsigned char, 4> IPAddress_t;
+
+class IPAddress {
+public:
+  IPAddress (IPAddress_t ip) { }
+
+  operator IPAddress_t ()
+  {
+    IPAddress_t rv;
+    return rv;
+  }
+
+  IPAddress () { }
+};
+
+class DatagramHeader {
+public:
+  IPAddress _src;
+
+  void setHeader (IPAddress);
+};
+
+void
+DatagramHeader::setHeader (IPAddress)
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/scope13.C b/gcc/testsuite/g++.old-deja/g++.gb/scope13.C
new file mode 100644
index 00000000000..9ca5ba8ac25
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/scope13.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed gb scope
+class X {
+public:
+};
+
+class Y {
+public:
+  void X();
+  ::X X(int);
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig01.C b/gcc/testsuite/g++.old-deja/g++.gb/sig01.C
new file mode 100644
index 00000000000..a3e927743f3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig01.C
@@ -0,0 +1,33 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr assignment
+// Test assignment to local signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+  char * g (int)  { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (int);
+};
+
+int main (void)
+{
+  C a;
+  S * p;
+
+  p = &a;
+
+  printf ("%s%s\n", p->f (), p->g (0));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig02.C b/gcc/testsuite/g++.old-deja/g++.gb/sig02.C
new file mode 100644
index 00000000000..f739a282c1b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig02.C
@@ -0,0 +1,45 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr assignment
+// Test assigning objects of different classes to local signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+};
+
+class D
+{
+public:
+  char * f (void) { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+};
+
+int main (void)
+{
+  C a;
+  D b;
+  S * p;
+  int i;
+
+  for (i = 0; i < 2; i++)
+    {
+      if (i == 0)
+	p = &a;
+      else
+	p = &b;
+      printf ("%s", p->f ());
+    }
+  printf ("\n");
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig03.C b/gcc/testsuite/g++.old-deja/g++.gb/sig03.C
new file mode 100644
index 00000000000..d791c7edbef
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig03.C
@@ -0,0 +1,33 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr overloading
+// Test overloading of signature member functions.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+  char * f (int)  { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+  char * f (int);
+};
+
+int main (void)
+{
+  C a;
+  S * p;
+
+  p = &a;
+
+  printf ("%s%s\n", p->f (), p->f (0));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig04.C b/gcc/testsuite/g++.old-deja/g++.gb/sig04.C
new file mode 100644
index 00000000000..af549591591
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig04.C
@@ -0,0 +1,46 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr this
+// Test passing of 'this' pointer through signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C;
+int inc_mod_4 (C *);
+
+class C
+{
+public:
+  char * text[4];
+  int    i;
+  int    get_i (void) { return i; }
+  char * msg   (void) { i = inc_mod_4 (this);  return text[i]; }
+};
+
+signature S
+{
+  char * msg (void);
+};
+
+int inc_mod_4 (C * p)
+{
+  return (p->get_i () + 1) % 4;
+}
+
+int main (void)
+{
+  C o = { "P", "A", "S", "S", -1 };
+  S * p;
+  int i;
+
+  p = &o;
+
+  for (i = 0; i < 4; i++)
+    printf ("%s", p->msg ());
+
+  printf ("\n");
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig05.C b/gcc/testsuite/g++.old-deja/g++.gb/sig05.C
new file mode 100644
index 00000000000..3023e348dfb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig05.C
@@ -0,0 +1,31 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr initialization
+// Test initialization of a local signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+  char * g (int)  { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (int);
+};
+
+int main (void)
+{
+  C a;
+  S * p = &a;
+
+  printf ("%s%s\n", p->f (), p->g (0));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig06.C b/gcc/testsuite/g++.old-deja/g++.gb/sig06.C
new file mode 100644
index 00000000000..b6476d5f905
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig06.C
@@ -0,0 +1,31 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr initialization
+// Test initialization of a local signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+  char * g (int)  { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (int);
+};
+
+C a;
+S * p = &a;
+
+int main (void)
+{
+  printf ("%s%s\n", p->f (), p->g (0));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig07.C b/gcc/testsuite/g++.old-deja/g++.gb/sig07.C
new file mode 100644
index 00000000000..18a47be7e6e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig07.C
@@ -0,0 +1,29 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr default-argument
+// Test calling a signature member function with default argument.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (char * text) { return text; }
+};
+
+signature S
+{
+  char * f (char * text = "PA");
+};
+
+C a;
+S * p = &a;
+
+int main (void)
+{
+  printf ("%s%s\n", p->f (), p->f ("SS"));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig08.C b/gcc/testsuite/g++.old-deja/g++.gb/sig08.C
new file mode 100644
index 00000000000..2d5d14d9970
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig08.C
@@ -0,0 +1,40 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr argument return-value
+// Test passing a signature pointer to a function and returning it from one.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * text;
+  char * get_msg (void) const { return text; }
+};
+
+const C a = { "PA" };
+const C b = { "SS" };
+
+signature S
+{
+  char * get_msg (void) const;
+};
+
+char * f (const S * p)
+{
+  return p->get_msg ();
+}
+
+const S * g (const C * p)
+{
+  return p;
+}
+
+int main (void)
+{
+  printf ("%s%s\n", f(&a), g(&b)->get_msg ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig09.C b/gcc/testsuite/g++.old-deja/g++.gb/sig09.C
new file mode 100644
index 00000000000..a2e3b33e192
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig09.C
@@ -0,0 +1,34 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr assignment initialization new
+// Test assignment to/initialization of signature pointer with run-time value.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  int f (void) { return 1; }
+};
+
+signature S
+{
+  int f (void);
+};
+
+S * p1 = new C;
+
+int main (void)
+{
+  S * p2 = new C;
+  S * p3;
+
+  p3 = new C;
+
+  if (p1->f () + p2->f () + p3->f () == 3)
+    printf ("PASS\n");
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig10.C b/gcc/testsuite/g++.old-deja/g++.gb/sig10.C
new file mode 100644
index 00000000000..e16f2eeb095
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig10.C
@@ -0,0 +1,38 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr argument return-value new
+// Test passing a signature pointer to a function and returning it from one.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+  char * text;
+public:
+  C (char * s) { text = s; }
+  char * get_msg (void) const { return text; }
+};
+
+signature S
+{
+  char * get_msg (void) const;
+};
+
+char * f (const S * p)
+{
+  return p->get_msg ();
+}
+
+const S * g (const C * p)
+{
+  return p;
+}
+
+int main (void)
+{
+  printf ("%s%s\n", f(new C ("PA")), g(new C ("SS"))->get_msg ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig11.C b/gcc/testsuite/g++.old-deja/g++.gb/sig11.C
new file mode 100644
index 00000000000..892695f3fa3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig11.C
@@ -0,0 +1,34 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr array
+// Test a signature pointer array.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+};
+
+class D
+{
+public:
+  char * f (void) { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+};
+
+int main (void)
+{
+  S * p[2] = { new C, new D };
+
+  printf ("%s%s\n", p[0]->f (), p[1]->f ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig12.C b/gcc/testsuite/g++.old-deja/g++.gb/sig12.C
new file mode 100644
index 00000000000..2747a805915
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig12.C
@@ -0,0 +1,40 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr structure
+// Test a signature pointer structure.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+};
+
+class D
+{
+public:
+  char * f (void) { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+};
+
+struct SP
+{
+  S * p;
+  S * q;
+};
+
+int main (void)
+{
+  SP o = { new C, new D };
+
+  printf ("%s%s\n", o.p->f (), o.q->f ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig13.C b/gcc/testsuite/g++.old-deja/g++.gb/sig13.C
new file mode 100644
index 00000000000..f5da9f80888
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig13.C
@@ -0,0 +1,38 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr assignment initialization
+// Test assignment of/initialization with same type signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  int f (void) { return 1; }
+};
+
+signature S
+{
+  int f (void);
+};
+
+C a;
+S * p1 = &a;
+S * q1 = p1;
+
+int main (void)
+{
+  C a;
+  S * p2 = &a;
+  S * q2 = p2;
+  S * q3;
+
+  q3 = p2;
+
+  if (q1->f () + q2->f () + q3->f () == 3)
+    printf ("PASS\n");
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig14.C b/gcc/testsuite/g++.old-deja/g++.gb/sig14.C
new file mode 100644
index 00000000000..6ce1d02d1bf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig14.C
@@ -0,0 +1,55 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr assignment initialization
+// Test assignment of/initialization with different type signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  int f (void) { return 1; }
+  int g (int)  { return 2; }
+};
+
+signature S
+{
+  int f (void);
+  int g (int);
+};
+
+signature T
+{
+  int f (void);
+};
+
+signature U
+{
+  int g (int);
+};
+
+C a;
+S * p1 = &a;
+T * q1 = p1;
+U * r1 = p1;
+
+int main (void)
+{
+  C a;
+  S * p2 = &a;
+  T * q2 = p2;
+  U * r2 = p2;
+  T * q3;
+  U * r3;
+
+  q3 = p2;
+  r3 = p2;
+
+  if (q1->f () + q2->f () + q3->f () == 3
+      && r1->g (0) + r2->g (0) + r3->g (0) == 6)
+    printf ("PASS\n");
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig15.C b/gcc/testsuite/g++.old-deja/g++.gb/sig15.C
new file mode 100644
index 00000000000..f0ae52e9ea7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig15.C
@@ -0,0 +1,35 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr cast
+// Test casting a signature pointer to a class pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+  char * g (int)  { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (int);
+};
+
+int main (void)
+{
+  C a;
+  S * p;
+  C * q;
+
+  p = &a;
+  q = (C *) p;
+
+  printf ("%s%s\n", q->f (), q->g (0));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig16.C b/gcc/testsuite/g++.old-deja/g++.gb/sig16.C
new file mode 100644
index 00000000000..35475e9f504
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig16.C
@@ -0,0 +1,44 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr cast
+// Test casting a class pointer to an anonymous signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+  char * g (int)  { return "S"; }
+  char * h (void) { return "FAIL"; }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (int);
+};
+
+signature T
+{
+  char * f (void);
+};
+
+C a;
+signature { char * g (int); } * r1 =
+  (signature { char * h (void); char * g (int); } *) &a;
+
+int main (void)
+{
+  C a;
+  S * p = &a;
+  T * q = p;
+  signature { char * g (int); } * r2 =
+    (signature { char * h (void); char * g (int); } *) &a;
+
+  printf ("%s%s%s\n", q->f (), r1->g (0), r2->g (0));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig17.C b/gcc/testsuite/g++.old-deja/g++.gb/sig17.C
new file mode 100644
index 00000000000..6d1d1d94df6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig17.C
@@ -0,0 +1,54 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr cast
+// Test casting a class pointer through a chain of signature pointers.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+  char * g (int)  { return "SS"; }
+};
+
+class D : public C
+{
+public:
+  char * h (void) { return "FAIL"; }
+};
+
+class E : public C
+{
+public:
+  int foo (int) { return 0; }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (int);
+};
+
+signature T
+{
+  char * f (void);
+};
+
+int main (void)
+{
+  D a;
+  S * p;
+  T * q;
+  signature { char * g (int); } * r;
+
+  p = &a;
+  q = (T*) (signature { char * f (void); int foo (int); } *) (E*) (S*) (C*) p;
+  r = (signature { char * h (void); char * g (int); } *) &a;
+
+  printf ("%s%s\n", q->f (), r->g (0));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig18.C b/gcc/testsuite/g++.old-deja/g++.gb/sig18.C
new file mode 100644
index 00000000000..ba0ec8689cd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig18.C
@@ -0,0 +1,33 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr assignment virtual
+// Test assignment of object from virtual class to signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  virtual char * f (void) { return "PA"; }
+  virtual char * g (int)  { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (int);
+};
+
+int main (void)
+{
+  C a;
+  S * p;
+
+  p = &a;
+
+  printf ("%s%s\n", p->f (), p->g (0));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig19.C b/gcc/testsuite/g++.old-deja/g++.gb/sig19.C
new file mode 100644
index 00000000000..160a4a3bd49
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig19.C
@@ -0,0 +1,38 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr initialization virtual
+// Test initialization of signature pointer with object from abstract class.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  virtual char * f (void) = 0;
+  virtual char * g (int)  = 0;
+};
+
+class D : public C
+{
+public:
+  char * f (void) { return "PA"; }
+  char * g (int)  { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (int);
+};
+
+int main (void)
+{
+  C * p = new D;
+  S * q = p;
+
+  printf ("%s%s\n", q->f (), q->g (0));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig20.C b/gcc/testsuite/g++.old-deja/g++.gb/sig20.C
new file mode 100644
index 00000000000..a8228de74b9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig20.C
@@ -0,0 +1,38 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr initialization virtual
+// Test initialization of signature pointer with object from virtual class.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  virtual char * f (void) { return "FA"; }
+  virtual char * g (int)  { return "IL"; }
+};
+
+class D : public C
+{
+public:
+  char * f (void) { return "PA"; }
+  char * g (int)  { return "SS"; }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (int);
+};
+
+int main (void)
+{
+  C * p = new D;
+  S * q = p;
+
+  printf ("%s%s\n", q->f (), q->g (0));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig21.C b/gcc/testsuite/g++.old-deja/g++.gb/sig21.C
new file mode 100644
index 00000000000..faad45b6403
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig21.C
@@ -0,0 +1,56 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr assignment virtual
+// Test assignment of objects of different types to same signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  virtual char * f (void) = 0;
+};
+
+class D : public C
+{
+public:
+  char * f (void) { return "P"; }
+};
+
+class E
+{
+public:
+  char * f (void) { return "AS"; }
+};
+
+class F : public C
+{
+public:
+  char * f (void) { return "S"; }
+};
+
+signature S
+{
+  char * f (void);
+};
+
+int main (void)
+{
+  E a;
+  C * p = new D;
+  S * q;
+
+  q = p;
+  printf ("%s", q->f ());
+
+  q = &a;
+  printf ("%s", q->f ());
+
+  p = new F;
+  q = p;
+  printf ("%s\n", q->f ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig22.C b/gcc/testsuite/g++.old-deja/g++.gb/sig22.C
new file mode 100644
index 00000000000..25b0a1aa5d1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig22.C
@@ -0,0 +1,59 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr assignment initialization
+// Test assignment to/init of sigptr that requires copying sigtable slots.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  int f (void) { return 1; }
+  int g (int)  { return 2; }
+  int h (void) { return 666; }
+};
+
+signature S
+{
+  int f (void);
+  int g (int);
+  int h (void);
+};
+
+signature T
+{
+  int f (void);
+  int h (void);
+};
+
+signature U
+{
+  int h (void);
+  int g (int);
+};
+
+C a;
+S * p  = &a;
+T * q1 = p;
+U * r1 = p;
+
+int main (void)
+{
+  C a;
+  S * p  = &a;
+  T * q2 = p;
+  U * r2 = p;;
+  T * q3;
+  U * r3;
+
+  q3 = p;
+  r3 = p;
+
+  if (q1->f () + q2->f () + q3->f () == 3
+      && r1->g (0) + r2->g (0) + r3->g (0) == 6)
+    printf ("PASS\n");
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig23.C b/gcc/testsuite/g++.old-deja/g++.gb/sig23.C
new file mode 100644
index 00000000000..767cfa31281
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig23.C
@@ -0,0 +1,53 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr assignment local-signature
+// Test assignment to signature pointer of local signature.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+char * PA (void)
+{
+  class C
+  {
+  public:
+    char * f (void) { return "PA"; }
+  };
+
+  signature S
+  {
+    char * f (void);
+  };
+
+  C a;
+  S * p = &a;
+
+  return p->f ();
+}
+
+char * SS (void)
+{
+  class C
+  {
+  public:
+    char * f (void) { return "SS"; }
+  };
+
+  signature S
+  {
+    char * f (void);
+  };
+
+  C a;
+  S * p = &a;
+
+  return p->f ();
+}
+
+int main (void)
+{
+  printf ("%s%s\n", PA (), SS ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig24.C b/gcc/testsuite/g++.old-deja/g++.gb/sig24.C
new file mode 100644
index 00000000000..2dca6f994ce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig24.C
@@ -0,0 +1,36 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr opaque-type
+// Test calling member functions taking/returning opaque type through sigptr.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+signature S
+{
+  typedef t;
+  char * f (t);
+  t g (void);
+  t h (void);
+};
+
+class C
+{
+public:
+  typedef char * t;
+  char * f (t text) { return text; }
+  t g (void) { return "PA"; }
+  t h (void) { return "SS"; }
+};
+
+int main (void)
+{
+  C a;
+  S *  p = &a;
+  S::t w = p->h ();
+
+  printf ("%s%s\n", p->f (p->g ()), p->f (w));
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig25.C b/gcc/testsuite/g++.old-deja/g++.gb/sig25.C
new file mode 100644
index 00000000000..d00ef57ca5e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig25.C
@@ -0,0 +1,33 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr default-implementation
+// Test calling default implementation through signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C { };
+
+class D
+{
+public:
+  char * f (void) { return "SS"; }
+};
+
+signature S
+{
+  char * f (void) { return "PA"; }
+};
+
+int main (void)
+{
+  C a;
+  D b;
+  S * p = &a;
+  S * q = &b;
+
+  printf ("%s%s\n", p->f (), q->f ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig26.C b/gcc/testsuite/g++.old-deja/g++.gb/sig26.C
new file mode 100644
index 00000000000..399737b4a37
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig26.C
@@ -0,0 +1,34 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr default-implementation
+// Test calling default implementation through signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C { };
+
+class D
+{
+public:
+  char * f (void) { return "SS"; }
+};
+
+signature S
+{
+  char * f (void) { return "PA"; }
+  char * g (void) { return f (); }
+};
+
+int main (void)
+{
+  C a;
+  D b;
+  S * p = &a;
+  S * q = &b;
+
+  printf ("%s%s\n", p->g (), q->g ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig27.C b/gcc/testsuite/g++.old-deja/g++.gb/sig27.C
new file mode 100644
index 00000000000..7b9e7d29617
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig27.C
@@ -0,0 +1,38 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr multiple-inheritance
+// Test class defined by multiple inheritance as implementation of signature.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * f (void) { return "PA"; }
+};
+
+class D
+{
+public:
+  char * g (void) { return "SS"; }
+};
+
+class E : public C, public D { };
+
+signature S
+{
+  char * f (void);
+  char * g (void);
+};
+
+int main (void)
+{
+  E a;
+  S * p = &a;
+
+  printf ("%s%s\n", p->f (), p->g ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig28.C b/gcc/testsuite/g++.old-deja/g++.gb/sig28.C
new file mode 100644
index 00000000000..4edff680ce8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig28.C
@@ -0,0 +1,46 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr multiple-inheritance
+// Test correct adjustment of `this' pointer in case of multiple inheritance.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+  char * text;
+public:
+  C () { text = "PA"; }
+  char * f (void) { return text; }
+};
+
+class D
+{
+  char * text;
+public:
+  D () { text = "SS"; }
+  char * g (void) { return text; }
+};
+
+class E : public C, public D
+{
+public:
+  E () : C (), D () { }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (void);
+};
+
+int main (void)
+{
+  E a;
+  S * p = &a;
+
+  printf ("%s%s\n", p->f (), p->g ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig29.C b/gcc/testsuite/g++.old-deja/g++.gb/sig29.C
new file mode 100644
index 00000000000..e5c5e392643
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig29.C
@@ -0,0 +1,46 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr multiple-inheritance
+// Test calling virtual function from MI class through signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+  char * text;
+public:
+  C () { text = "PA"; }
+  virtual char * f (void) { return text; }
+};
+
+class D
+{
+  char * text;
+public:
+  D () { text = "SS"; }
+  virtual char * g (void) { return text; }
+};
+
+class E : public C, public D
+{
+public:
+  E () : C (), D () { }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (void);
+};
+
+int main (void) 
+{ 
+  E a;
+  S * p = &a;
+
+  printf ("%s%s\n", p->f (), p->g ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig30.C b/gcc/testsuite/g++.old-deja/g++.gb/sig30.C
new file mode 100644
index 00000000000..3e93e114b86
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig30.C
@@ -0,0 +1,48 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr multiple-inheritance
+// Test calling overwritten virtual functions through signature pointer.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  char * text1;
+  C () { text1 = "PA"; }
+  virtual char * f (void) = 0;
+};
+
+class D
+{
+public:
+  char * text2;
+  D () { text2 = "SS"; }
+  virtual char * g (void) = 0;
+};
+
+class E : public C, public D
+{
+public:
+  E () : C (), D () { };
+  char * f (void) { return text1; }
+  char * g (void) { return text2; }
+};
+
+signature S
+{
+  char * f (void);
+  char * g (void);
+};
+
+int main (void)
+{
+  E a;
+  S * p = &a;
+
+  printf ("%s%s\n", p->f (), p->g ());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.gb/sig31.C b/gcc/testsuite/g++.old-deja/g++.gb/sig31.C
new file mode 100644
index 00000000000..90fa9e9d47a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.gb/sig31.C
@@ -0,0 +1,52 @@
+// Special g++ Options: -fhandle-signatures
+// GROUPS passed gb sigptr assignment sigsigtable
+// Test use of multiple signature-signature tables for same signature pair.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+class C
+{
+public:
+  virtual int f (void) { return 1; }
+  int g (int)          { return 2; }
+};
+
+class D : public C
+{
+public:
+  int f (void) { return 3; }
+  int g (int)  { return 4; }
+};
+
+signature S
+{
+  int f (void);
+  int g (int);
+};
+
+signature T
+{
+  int g (int);
+  int f (void);
+};
+
+int main (void)
+{
+  S * p = new C;
+  T * q = p;
+  T * r;
+
+  p = new D;
+  r = p;
+
+  if (q->f () == 1 && q->g (0) == 2
+      && r->f () == 3 && r->g (0) == 4)
+    printf ("PASS\n");
+  else
+    printf ("FAIL\n");
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/2371.C b/gcc/testsuite/g++.old-deja/g++.jason/2371.C
new file mode 100644
index 00000000000..b11db5e0b33
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/2371.C
@@ -0,0 +1,571 @@
+// GROUPS passed templates nested-classes
+// Special g++ Options: 
+//
+// The SetLS template test
+//
+// Wendell Baker, Berkeley CAD Group, 1993 (wbaker@ic.Berkeley.EDU)
+//
+
+
+#pragma implementation "ListS.h"
+#pragma implementation "SetLS.h"
+
+#include <stdlib.h>
+#include <iostream.h>
+# 1 "../../templates/SetLS.h" 1
+// -*- C++ -*-
+
+
+
+//
+// A Set Template - implemented with an ListS
+//
+// Wendell Baker, Berkeley CAD Group, 1993 (wbaker@ic.Berkeley.EDU)
+//
+
+
+
+
+
+#pragma interface
+
+
+
+
+
+#define XTRUE true
+#define XFALSE false
+
+# 37 "../../templates/SetLS.h"
+
+
+# 1 "../../templates/ListS.h" 1
+// -*- C++ -*-
+
+
+
+//
+// A List Template - providing a singly linked capability
+//
+// Wendell Baker, Berkeley CAD Group, 1993 (wbaker@ic.Berkeley.EDU)
+//
+
+
+
+
+
+#pragma interface
+
+
+
+
+
+
+# 1 "/projects/gnu-cygnus/gnu-cygnus-14/mips/lib/gcc-lib/decstation/cygnus-reno-1/g++-include/bool.h" 1 3
+// Defining XTRUE and XFALSE is usually a Bad Idea,
+// because you will probably be inconsistent with anyone
+// else who had the same clever idea.
+// Therefore:  DON'T USE THIS FILE.
+
+
+
+
+
+
+
+
+
+# 26 "../../templates/ListS.h" 2
+
+# 37 "../../templates/ListS.h"
+
+
+
+// g++ reno-1 is not yet capable of creating templates with nested
+// classes which instantiate the template arguments.
+template<class T>
+struct ListS_link {
+    T item;
+    ListS_link<T> *next;
+
+    ListS_link(const T& i, ListS_link<T> *n = 0): item(i), next(n)
+	{ }
+};
+
+
+//
+// For now, errors are raised by ::abort() because exceptions
+// are not well implemented in cxx or at all in CC 3.0.1
+//
+template<class T>
+class ListS {
+public:
+    ListS();
+    ListS(const ListS<T>&);
+    ~ListS();
+
+    void operator=(const ListS<T>&);
+    
+    unsigned length() const
+	{ return count; }
+    
+    void prepend(const T& item);
+    void append(const T& item);
+    void clear();
+
+    const T& head() const
+	{ ensure_1();
+	  return head_link->item; }
+    T& head()
+	{ ensure_1();
+	  return head_link->item; }
+    void head(T& fill) const
+	{ ensure_1();
+	  fill = head_link->item; }
+    void remove_head()
+	{ remove_head_filling(0); }
+    void remove_head(T& fill)
+	{ remove_head_filling(&fill); }
+
+    const T& tail() const
+	{ ensure_1();
+	  return tail_link->item; }
+    T& tail()
+	{ ensure_1();
+	  return tail_link->item; }
+    void tail(T& fill) const
+	{ ensure_1();
+	  fill = tail_link->item; }
+
+    class Vix {
+    public:
+	Vix(): owner(0), index(0)
+	    { }
+	
+	// These are friend functions so that v == x is the same as x == v
+	friend int operator==(void *v, const Vix& x)
+	    { return v == x.index; }
+	friend int operator==(const Vix& x, void *v)
+	    { return v == x.index; }
+	friend int operator!=(void *v, const Vix& x)
+	    { return v != x.index; }
+	friend int operator!=(const Vix& x, void *v)
+	    { return v != x.index; }
+	friend int operator==(const Vix& x1, const Vix& x2)
+	    { return x1.owner == x2.owner && x1.index == x2.index; }
+	friend int operator!=(const Vix& x1, const Vix& x2)
+	    { return x1.owner != x2.owner || x1.index != x2.index; }
+    private:
+        friend class ListS<T>;
+	
+
+	Vix(const ListS<T> *o, ListS_link<T> *i): owner(o), index(i)
+	    { }
+
+
+
+
+	
+	const ListS<T> *owner;
+
+	ListS_link<T> *index;
+
+
+
+    };
+    
+    Vix first() const
+	{ return Vix(this, head_link); }
+    void next(Vix& x) const
+	{ check(x);
+	  if (x.index != 0)
+	      x.index = x.index->next; }
+    T& operator()(const Vix& x)
+	{ check(x);
+	  return x.index->item; }
+    const T& operator()(const Vix& x) const
+	{ check(x);
+	  return x.index->item; }
+protected:
+# 154 "../../templates/ListS.h"
+
+
+    unsigned count;
+
+    ListS_link<T> *head_link;	// 0 for a zero-length list
+    ListS_link<T> *tail_link;	// 0 for a zero-length list
+
+
+
+
+
+private:
+    // fill may be 0 (then don't fill)
+    void remove_head_filling(T *fill);
+
+    void ensure_1() const
+	{ if (0 == head_link)
+	      ::abort(); }
+    void check(const Vix& x) const
+	{ if (this != x.owner)
+	      ::abort();
+	  if (0 == x.index)
+	      ::abort(); }
+};
+
+template<class T>
+ListS<T>::ListS():
+count(0),
+head_link(0),
+tail_link(0)
+{ }
+
+template<class T>
+ListS<T>::ListS(const ListS<T>& other):
+count(0),
+head_link(0),
+tail_link(0)
+{
+    for (Vix x=other.first(); 0 != x; other.next(x))
+	append(other(x));
+}
+
+template<class T>
+ListS<T>::~ListS()
+{
+    clear();
+}
+
+template<class T>
+void
+ListS<T>::operator=(const ListS<T>& other)
+{
+    clear();
+    for (Vix x=other.first(); 0 != x; other.next(x))
+	append(other(x));
+}
+
+template<class T>
+void
+ListS<T>::prepend(const T& item)
+{
+
+    head_link = new ListS_link<T>(item, head_link);
+
+
+
+    if (0 == tail_link)
+	tail_link = head_link;
+    count++;
+}
+
+template<class T>
+void
+ListS<T>::append(const T& item)
+{
+
+    ListS_link<T> *new_link = new ListS_link<T>(item); 
+
+
+
+    if (0 == tail_link) {
+	head_link = new_link;
+	tail_link = new_link;
+    } else {
+	tail_link->next = new_link;
+	tail_link = tail_link->next;
+    }
+    count++;
+}
+
+template<class T>
+void
+ListS<T>::clear()
+{
+
+    ListS_link<T> *next, *l;
+
+
+
+    for (l=head_link; 0 != l; l=next) {
+	next = l->next;
+	delete l;
+    }
+
+    count = 0;
+    head_link = 0;
+    tail_link = 0;
+}
+
+template<class T>
+void
+ListS<T>::remove_head_filling(T* fill)
+// fill may be 0 in which case don't assign into it
+{
+    ensure_1();
+
+    ListS_link<T> *ohead = head_link;
+
+
+
+    if (0 != fill)
+	*fill = ohead->item;
+    head_link = ohead->next;
+    if (0 == head_link)
+	tail_link = 0;
+    count--;
+    delete ohead;
+}
+
+
+# 39 "../../templates/SetLS.h" 2
+
+
+# 62 "../../templates/SetLS.h"
+
+template<class T>
+class SetLS {
+public:
+    SetLS();
+    
+    void add(const T& item);
+    // There is no remove(const T& item) for this set
+    bool contains(const T& item) const;
+
+    unsigned length() const
+	{ return list.length(); }
+
+    void clear()
+	{ list.clear(); }
+
+    class Vix {
+    public:
+	Vix(): owner(0), vix()
+	    { }
+
+	// These are friend functions so that v == x is the same as x == v
+	friend int operator==(void *v, const Vix& x)
+	    { return v == x.vix; }
+	friend int operator==(const Vix& x, void *v)
+	    { return v == x.vix; }
+	friend int operator!=(void *v, const Vix& x)
+	    { return v != x.vix; }
+	friend int operator!=(const Vix& x, void *v)
+	    { return v != x.vix; }
+	friend int operator==(const Vix& x1, const Vix& x2)
+	    { return x1.owner == x2.owner && x1.vix == x2.vix; }
+	friend int operator!=(const Vix& x1, const Vix& x2)
+	    { return x1.owner != x2.owner || x1.vix != x2.vix; }
+    private:
+	friend class SetLS<T>;
+
+	Vix(const SetLS<T> *o, const ListS<T>::Vix& x): owner(o), vix(x)
+	    { }
+
+	const SetLS<T> *owner;
+	ListS<T>::Vix vix;
+    };
+    friend class Vix;
+    
+    Vix first() const
+	{ return Vix(this, list.first()); }
+    void next(Vix& x) const
+	{ check(x);
+	  list.next(x.vix); }
+    const T& operator()(const Vix& x) const
+	{ check(x);
+	  return list(x.vix); }
+    // There is item no remove(const Vix&) for this set
+protected:
+    ListS<T> list;
+
+private:
+    void check(const Vix& x) const
+	{ if (this != x.owner)
+	      ::abort(); }
+};
+
+
+template<class T>
+SetLS<T>::SetLS():
+
+
+
+list()
+
+{ }
+
+template<class T>
+void
+SetLS<T>::add(const T& item)
+{
+    if ( ! contains(item) ) {
+
+
+
+	list.append(item);
+
+    }
+}
+
+template<class T>
+bool
+SetLS<T>::contains(const T& item) const
+{
+    for (Vix x=first(); 0 != x; next(x)) {
+	if (operator()(x) == item)
+	    return XTRUE;
+    }
+    return XFALSE;
+}
+
+
+# 14 "SetLS.cc" 2
+
+
+
+# 1 "/projects/gnu-cygnus/gnu-cygnus-14/mips/lib/gcc-lib/decstation/cygnus-reno-1/g++-include/iostream.h" 1 3
+//    This is part of the iostream library, providing -*- C++ -*- input/output.
+//    Copyright (C) 1991 Per Bothner.
+//
+//    This library is free software; you can redistribute it and/or
+//    modify it under the terms of the GNU Library General Public
+//    License as published by the Free Software Foundation; either
+//    version 2 of the License, or (at your option) any later version.
+//
+//    This library is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//    Library General Public License for more details.
+//
+//    You should have received a copy of the GNU Library General Public
+//    License along with this library; if not, write to the Free
+//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+# 211 "/projects/gnu-cygnus/gnu-cygnus-14/mips/lib/gcc-lib/decstation/cygnus-reno-1/g++-include/iostream.h" 3
+
+# 21 "SetLS.cc" 2
+
+
+// In (most versions of) g++ 2.X, this use of typedefs has the effect
+// of causing the instantiation of the templates, thereby testing the
+// templates
+
+class test {
+public:
+    test(): value(0)
+	{ }
+    test(int v): value(v)
+	{ }
+
+    void print(ostream& out) const
+	{ out << value; }
+
+    friend int operator==(const test& a, const test& b);
+private:
+    int value;
+};
+
+int
+operator==(const test& a, const test& b)
+{
+    return a.value == b.value;
+}
+
+ostream&
+operator<<(ostream& o, const test& t)
+{
+    t.print(o);
+    return o;
+}
+
+typedef SetLS<test> SLS;
+
+static ostream&
+operator<<(ostream& o, const SLS& s)
+{
+    o << "set of " << s.length() << " = {";
+
+    bool first;
+    SetLS<test>::Vix x;
+    for (first=XTRUE, x=s.first(); 0 != x; s.next(x), first=XFALSE) {
+	if ( ! first )
+	    o << ',';
+	o << ' ';
+	s(x).print(o);
+    }
+    o << '}';
+
+    return o;
+}
+
+SLS gsls;
+const SLS gcsls;
+
+int foo()
+{
+    const unsigned SIZE = 20;
+
+    //
+    // SetLS()
+    // SetLS(const SetLS<T>&)
+    // 
+    SLS sls;
+    {
+	// Fill sls with some interesting values
+	for (unsigned i=0; i<SIZE; i++) {
+	    test t = i;
+	    sls.add(t);
+	}
+    }
+
+    const SLS csls(sls);
+
+    //
+    // void operator=(const SetLS<T>&);
+    //
+    sls = csls;
+
+    //
+    // bool contains(const T& item) const
+    //
+    for (unsigned i=0; i<SIZE; i++) {
+	test t = i;
+
+	int contains = sls.contains(t);
+    }
+
+    //
+    // void clear()
+    //
+    sls.clear();
+    if (sls.length() != 0)
+	::abort();
+
+    sls = csls;
+
+    //
+    // Vix first() const
+    // void next(Vix& x) const
+    // T& operator()(const Vix& x)
+    // const T& operator()(const Vix& x) const
+    //
+    SetLS<test>::Vix cx;
+    for (cx=csls.first(); 0 != cx; sls.next(cx)) {
+	if ( ! sls.contains(csls(cx)) )
+	    ::abort();
+    }
+
+    cout << "gsls:\t" << gsls << '\n';
+    cout << "gcsls:\t" << gcsls << '\n';
+    cout << "sls:\t" << sls << '\n';
+    cout << "csls:\t" << csls << '\n';
+}
+
+// Dummy function so it'll run
+int main()
+{
+  cout << "PASS" << endl;
+}
+
+template class ListS<test>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/3523.C b/gcc/testsuite/g++.old-deja/g++.jason/3523.C
new file mode 100644
index 00000000000..f47bd7b5bf3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/3523.C
@@ -0,0 +1,40 @@
+// Build don't link: 
+// GROUPS passed assignment
+class ccUnwind 
+{
+public:
+    virtual ~ccUnwind (); // comment out virtual, and void diag changes
+};
+
+template<class T>
+class ccHandle : public ccUnwind // similarly comment out inheritance
+{   
+public:
+    ccHandle& operator = (const ccHandle& h);
+};
+
+class cc_Image;		 
+
+class ccImage : public ccHandle<cc_Image>
+{
+public:
+//  reversing the order of the next two lines changes the diagnostic
+//  printed about the def of ccDisplay::image 
+    ccImage    (const  ccImage  &);
+    ccImage    (const  cc_Image &);
+};
+
+class ccDisplay 
+{
+public:
+    ccImage img;
+//ccImage image ( ccImage i) {img = i; return img;}
+// above line  compiles 
+    ccImage image ( ccImage i) { return img = i;} /* this gets void* error */
+};
+
+
+
+// vd.C: In method `class ccImage ccDisplay::image (class ccImage)':
+// vd.C:31: bad argument 1 for function `ccImage::ccImage (const class cc_Image&)' (type was void *)
+// vd.C:31: in base initialization for class `ccImage'
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access1.C b/gcc/testsuite/g++.old-deja/g++.jason/access1.C
new file mode 100644
index 00000000000..fff77f25749
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access1.C
@@ -0,0 +1,17 @@
+// Bug: access declarations are broken.
+// Build don't link:
+
+class A {
+public:
+  void foo ();
+};
+
+class B: private A {
+public:
+  A::foo;
+};
+
+void foo() {
+  B b;
+  b.foo ();			// gets bogus error - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access10.C b/gcc/testsuite/g++.old-deja/g++.jason/access10.C
new file mode 100644
index 00000000000..6db610c5010
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access10.C
@@ -0,0 +1,14 @@
+// PRMS Id: 4839
+// Bug: The initializer of a static member of a class has the same acess
+// rights as a member function.  g++ doesn't realize that.
+// Build don't link:
+
+class X 
+{
+  X (int);
+  static X foo;
+public:
+  void dummy();
+};
+
+X X::foo = 9;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access11.C b/gcc/testsuite/g++.old-deja/g++.jason/access11.C
new file mode 100644
index 00000000000..31a89b2ede8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access11.C
@@ -0,0 +1,12 @@
+// PRMS Id: 4900
+// Bug: g++ doesn't apply access control uniformly to type conversion operators
+// Build don't link:
+
+struct A {
+protected:
+  operator int * () const;
+};
+
+struct B : public A {
+  int * foo () { return A::operator int *(); }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access12.C b/gcc/testsuite/g++.old-deja/g++.jason/access12.C
new file mode 100644
index 00000000000..71e336180e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access12.C
@@ -0,0 +1,16 @@
+// PRMS Id: 4694
+// Bug: g++ doesn't realize that A::i refers to a member of `this' in B().
+// Build don't link:
+
+class A {
+protected:
+  int i;
+};
+
+struct B : public A {
+  B () { A::i = 0; }
+};
+
+struct C : public B {
+  C () { B::i = 0; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access13.C b/gcc/testsuite/g++.old-deja/g++.jason/access13.C
new file mode 100644
index 00000000000..c12dd81dc87
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access13.C
@@ -0,0 +1,15 @@
+// PRMS Id: 4955
+// Build don't link:
+
+struct A {
+ protected:
+  int i;
+  void f ();
+};
+
+struct B: public A {
+  void g () {
+    this->A::i = 1;		// gets bogus error - access control failure
+    this->A::f();		// gets bogus error - access control failure
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access14.C b/gcc/testsuite/g++.old-deja/g++.jason/access14.C
new file mode 100644
index 00000000000..f181906ec97
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access14.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+template <class T> struct A { T t; };
+
+template <class T> class B: private T {
+ public:
+  T::t;			   // gets bogus error - doesn't recognize access decl
+};
+
+template class B<A<int> >;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access15.C b/gcc/testsuite/g++.old-deja/g++.jason/access15.C
new file mode 100644
index 00000000000..4380998521f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access15.C
@@ -0,0 +1,18 @@
+// Bug: g++ complains about Z being a private base when trying to
+// initialize B::foo.
+// Build don't link:
+
+struct Z {
+  Z();
+  Z(int);
+};
+
+struct A : private Z { };
+struct B : public A
+{
+    Z foo;
+    B();
+    B(const B&);
+};
+
+B::B() : foo(1) { }		// gets bogus error
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access16.C b/gcc/testsuite/g++.old-deja/g++.jason/access16.C
new file mode 100644
index 00000000000..b8d43f3c4c9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access16.C
@@ -0,0 +1,20 @@
+// Bug: g++ uses the same binfo for the a subobject of c and the a subobject
+// of b, so basetype_paths get bashed improperly.
+// Build don't link:
+
+class a {
+protected:
+	virtual void foo() { }	// gets bogus error
+};
+
+class b : public virtual a {};
+
+class c : public b {
+public:
+	void bar() { b::foo(); } // gets bogus error
+};
+
+int main() {
+	c test;
+	test.bar();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access17.C b/gcc/testsuite/g++.old-deja/g++.jason/access17.C
new file mode 100644
index 00000000000..676eac1bcc1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access17.C
@@ -0,0 +1,24 @@
+// Make sure definitions of static members have the right access.
+// Build don't link:
+
+struct A {
+protected:
+  int i;                        // ERROR - private
+  int f ();			// ERROR - 
+};
+
+struct B: public A {
+  static int A::*p;
+  static int (A::*fp)();
+};
+
+int A::* B::p = &A::i;
+int (A::* B::fp)() = &A::f;
+
+struct C {
+  static int A::*p;
+  static int (A::*fp)();
+};
+
+int A::* C::p = &A::i;		// ERROR - 
+int (A::* C::fp)() = &A::f;	// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access18.C b/gcc/testsuite/g++.old-deja/g++.jason/access18.C
new file mode 100644
index 00000000000..11b7e10ed47
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access18.C
@@ -0,0 +1,23 @@
+// PRMS Id: 5073
+// Bug: g++ doesn't catch access violations in base initializers.
+// Special g++ Options: -w
+
+int r = 0;
+class A {
+  private:
+    A() { r = 1; }		// ERROR - 
+    ~A() {}			// ERROR - 
+};
+    
+class B : public A {
+  public:
+    B(): A() {}			// ERROR - 
+    B(const B&) {}		// ERROR - 
+    ~B() { }			// ERROR - private dtor
+};
+
+main()
+{
+  B b;
+  return r;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access2.C b/gcc/testsuite/g++.old-deja/g++.jason/access2.C
new file mode 100644
index 00000000000..cacfbe1c6a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access2.C
@@ -0,0 +1,11 @@
+// Bug: g++ doesn't deal with friends also being derived classes.
+// Build don't link:
+
+class A {
+  int i;
+  friend class B;
+};
+
+class B : public A {
+  void f () { i = 1; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access20.C b/gcc/testsuite/g++.old-deja/g++.jason/access20.C
new file mode 100644
index 00000000000..96093dc0190
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access20.C
@@ -0,0 +1,39 @@
+// PRMS Id: 6662
+// Bug: we crash trying to check the access on anglesSinesCosines.
+// Build don't link:
+
+#define Double double
+
+class GCTransform
+{
+  protected:
+    struct angle
+    {
+	Double phi1 ;
+	Double phi2 ;
+    } ;
+
+    struct sineAndCosine
+    {
+	Double cosine1 ;
+	Double cosine2 ;
+	Double sine1 ;
+	Double sine2 ;
+    } ;
+
+    union anglesSinesCosines
+    {
+	struct angle a ;
+	struct sineAndCosine siCo ;
+    } ;
+};
+
+class GCTransTransmit : public GCTransform
+{
+  protected:
+
+    struct GCTransTransmitDataTemp
+    {
+	union anglesSinesCosines t ; // causes abort
+    } ;
+} ;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access21.C b/gcc/testsuite/g++.old-deja/g++.jason/access21.C
new file mode 100644
index 00000000000..340ed61fe97
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access21.C
@@ -0,0 +1,22 @@
+// PRMS Id: 6877
+// Build don't link:
+
+typedef __SIZE_TYPE__ size_t;
+class aa {
+public:
+        aa();
+        ~aa();
+private:
+        int iaa;
+        void operator delete(void*, size_t);
+};
+
+class bb {
+public:
+        aa caa;
+};				// gets bogus error - calling private delete
+
+void
+f(){
+        bb abb;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access22.C b/gcc/testsuite/g++.old-deja/g++.jason/access22.C
new file mode 100644
index 00000000000..225ef6cad5c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access22.C
@@ -0,0 +1,21 @@
+// PRMS Id: 8518
+// Bug: Call to foo is not checked for accessibility
+
+class A
+{
+  private:
+    static void foo() {}	// ERROR - 
+  public:
+    void goo() {}
+};
+
+struct B : public A
+{
+    void func() { foo(); }	// ERROR - 
+};
+
+int main()
+{
+    B b;
+    b.func();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access23.C b/gcc/testsuite/g++.old-deja/g++.jason/access23.C
new file mode 100644
index 00000000000..99e0b4565ce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access23.C
@@ -0,0 +1,79 @@
+// PRMS Id: 9127
+// Bug: members of anonymous unions are not access-controlled.
+
+#include <stdio.h>
+
+struct Foo {
+public:
+  union {
+    long A;
+    void *pX;
+  };
+  union X {
+    long A;
+    void *pX;
+  } PUB ;
+  int PUB_A;
+protected:
+  union {
+    long B; // ERROR - protected
+    void *pY; // ERROR - protected
+  } ;
+  union Y {
+    long B;
+    void *pY;
+  } PRT; // ERROR - protected
+  int PRT_A; // ERROR - protected
+private:
+  union {
+    long C; // ERROR - private
+    void *pZ; // ERROR - private
+  };
+  union Z {
+    long C;  
+    void *pZ;
+  } PRV; // ERROR - private
+  int PRV_A; // ERROR - private
+};
+
+struct Bar : public Foo {
+public:
+  void DoSomething() {
+    PUB_A = 0;
+    Foo::A = 0;
+    printf("%x\n",pX);  
+    Foo::PUB.A = 0;
+    printf("%x\n",PUB.pX);  
+    B = 0;			
+    printf("%x\n",Foo::pY);  
+    PRT_A = 0;
+    PRT.B = 0;		
+    printf("%x\n",Foo::PRT.pY);	
+    PRV_A = 0;			// ERROR - 
+    Foo::C = 0;			// ERROR - 
+    printf("%x\n",pZ);  	// ERROR - 
+    Foo::PRV.C = 0;		// ERROR - 
+    printf("%x\n",PRV.pZ); 	// ERROR - 
+  }
+};
+
+int main()
+{
+  Foo a;
+
+  a.PUB_A = 0;
+  a.A = 0;
+  printf("%x\n",a.pX);  
+  a.PRT_A = 0;			// ERROR - 
+  a.B = 0;			// ERROR - 
+  printf("%x\n",a.pY);  	// ERROR - 
+  a.PRV_A = 0;			// ERROR - 
+  a.C = 0;			// ERROR - 
+  printf("%x\n",a.pZ);  	// ERROR - 
+  a.PUB.A = 0;
+  printf("%x\n",a.PUB.pX);  
+  a.PRT.B = 0;			// ERROR - 
+  printf("%x\n",a.PRT.pY);  	// ERROR - 
+  a.PRV.C = 0;			// ERROR - 
+  printf("%x\n",a.PRV.pZ);  	// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access24.C b/gcc/testsuite/g++.old-deja/g++.jason/access24.C
new file mode 100644
index 00000000000..7c423598723
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access24.C
@@ -0,0 +1,11 @@
+// Bug: forward reference to friend doesn't work in template.
+// Build don't link:
+
+template <class T> class A {
+  static int i;
+  friend struct B;
+};
+
+struct B {
+  void f () { A<int>::i = 0; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access3.C b/gcc/testsuite/g++.old-deja/g++.jason/access3.C
new file mode 100644
index 00000000000..fae6c9323e1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access3.C
@@ -0,0 +1,12 @@
+// Simple testcase for access control.
+// Build don't link:
+
+class A {
+ protected:
+  void f ();
+};
+
+class B : public A {
+ public:
+  void f () { A::f(); }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access4.C b/gcc/testsuite/g++.old-deja/g++.jason/access4.C
new file mode 100644
index 00000000000..51f5fb10f8e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access4.C
@@ -0,0 +1,14 @@
+// Simple testcase for access control.
+// Build don't link:
+
+class A {
+protected:
+  static int i;
+};
+
+class B: public A { };
+
+class C: public B {
+public:
+  void g () { B b; b.i; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access5.C b/gcc/testsuite/g++.old-deja/g++.jason/access5.C
new file mode 100644
index 00000000000..5eec43d936e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access5.C
@@ -0,0 +1,12 @@
+// Simple testcase for access control.
+// Build don't link:
+
+class A {
+ protected:
+  void f ();
+};
+
+class B : public A { };
+class C : public B {
+ void f () { B::f(); }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access6.C b/gcc/testsuite/g++.old-deja/g++.jason/access6.C
new file mode 100644
index 00000000000..24676d4050b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access6.C
@@ -0,0 +1,12 @@
+// Simple testcase for access control.
+// Build don't link:
+
+class A {
+ public:
+  void f ();
+};
+
+class B: protected A { };
+class C: protected B {
+  void g() { f (); }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access7.C b/gcc/testsuite/g++.old-deja/g++.jason/access7.C
new file mode 100644
index 00000000000..a1e908f8ece
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access7.C
@@ -0,0 +1,13 @@
+// Simple testcase for access control.
+// Build don't link:
+
+class A {
+ protected:
+  static void f ();
+};
+
+class B: public A {};
+class C: public A {};
+class D: public C, public B {
+  void g () { A::f(); }		// gets bogus error - wrongly ambiguous static member call
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access8.C b/gcc/testsuite/g++.old-deja/g++.jason/access8.C
new file mode 100644
index 00000000000..c8addcd73a1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access8.C
@@ -0,0 +1,29 @@
+// From: smidt@dd.chalmers.se (Peter Smidt)
+// Date: 25 Jan 1994 23:41:33 -0500
+// Bug: g++ forgets access decls after the definition.
+// Build don't link:
+
+class inh {
+        int a;
+protected:
+        void myf(int);
+};
+
+class mel : private inh {
+protected:
+        int t;
+	inh::myf;
+};
+
+class top_t : protected mel {
+public:
+        void myf(int);
+};
+
+void inh::myf(int i) {
+        a = i;
+}
+
+void top_t::myf(int i) {
+        inh::myf(i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/access9.C b/gcc/testsuite/g++.old-deja/g++.jason/access9.C
new file mode 100644
index 00000000000..f9c2797d72b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/access9.C
@@ -0,0 +1,9 @@
+// Bug: g++ doesn't allow const objects to be constructed.
+// Build don't link:
+
+struct B { B(); };
+
+const B foo()
+{
+  return B();			// gets bogus error - constructing const
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/aggregate.C b/gcc/testsuite/g++.old-deja/g++.jason/aggregate.C
new file mode 100644
index 00000000000..8128d8de620
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/aggregate.C
@@ -0,0 +1,13 @@
+struct A { int i; };
+
+int main()
+{
+  A a1 = { 42 };
+  A a2 (a1);
+  A a3 = { 137 };
+  a1 = a3;
+
+  if (a1.i == 137 && a2.i == 42 && a3.i == 137)
+    return 0;
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ambig1.C b/gcc/testsuite/g++.old-deja/g++.jason/ambig1.C
new file mode 100644
index 00000000000..4551dc7d6e4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ambig1.C
@@ -0,0 +1,6 @@
+// Testcase for ambiguity between functional cast and abstract declarator.
+// This ambiguity accounts for 6 of the r/r conflicts.
+// Special g++ Options: -pedantic-errors
+
+int i = sizeof (int ());	// ERROR - sizeof applied to fn type
+int j = sizeof (int () + 1);
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ambig2.C b/gcc/testsuite/g++.old-deja/g++.jason/ambig2.C
new file mode 100644
index 00000000000..c6da7528bd3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ambig2.C
@@ -0,0 +1,11 @@
+// Testcase for ambiguity between cast and parmlist.
+// This ambiguity accounts for 1 of the r/r conflicts.
+// Do not compile with -pedantic so that the compiler will accept taking
+// the sizeof a function type.
+// Special g++ Options: -Wno-pointer-arith
+// Build don't link:
+
+void f(){
+  (void)sizeof(int((int)1.2));
+  (void)sizeof(int((int)));		// gets bogus error - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ambig3.C b/gcc/testsuite/g++.old-deja/g++.jason/ambig3.C
new file mode 100644
index 00000000000..3f01660bf98
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ambig3.C
@@ -0,0 +1,16 @@
+// Testcase for ambiguity between function and variable declaration (8.2).
+// Build don't link:
+
+struct A {
+  A (int, int);
+  int k;
+};
+
+void f ()
+{
+  int i[2], j;
+  A a (int (i[1]), j);		// gets bogus error - late parsing XFAIL *-*-*
+  A b (int (i[1]), int j);	// function
+  a.k = 0;			// gets bogus error - late parsing XFAIL *-*-*
+  b (i, j);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/anon.C b/gcc/testsuite/g++.old-deja/g++.jason/anon.C
new file mode 100644
index 00000000000..63d17a8cb2d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/anon.C
@@ -0,0 +1,18 @@
+// Bug: g++ has trouble copying anonymous structs.
+
+typedef struct { int i; } foo;
+struct A : public foo { 
+  struct { int i; } x;
+};
+
+int main ()
+{
+  A a;
+  a.i = 5;
+  a.x.i = 42;
+  A b (a);
+  a = b;
+  if (a.i != 5 || a.x.i != 42)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/anon2.C b/gcc/testsuite/g++.old-deja/g++.jason/anon2.C
new file mode 100644
index 00000000000..55d68988e5c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/anon2.C
@@ -0,0 +1,7 @@
+// g++ should not complain about anonymous bitfields.
+// Build don't link:
+
+struct A
+{
+  int : 2;	 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/anon3.C b/gcc/testsuite/g++.old-deja/g++.jason/anon3.C
new file mode 100644
index 00000000000..b3f05f8ad14
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/anon3.C
@@ -0,0 +1,25 @@
+// Bug: g++ dies.
+// Build don't link:
+
+class cl {
+public:
+  cl();
+  void set(void *, char *, int);
+private:
+  union {
+    float vf;
+    struct ff {
+      void *ptr;
+      char *name;
+      int sz;
+    } *vff;
+  };
+};
+
+void cl::set(void *p, char *n, int sz)
+{
+    vff = new ff; // This procude an internal compiler error.
+    vff->ptr = p;
+    vff->name = n;
+    vff->sz = sz;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/anon4.C b/gcc/testsuite/g++.old-deja/g++.jason/anon4.C
new file mode 100644
index 00000000000..de0b40e2aec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/anon4.C
@@ -0,0 +1,14 @@
+// PRMS Id: 5371
+// Bug: g++ screws up the alignment of buff and dies.
+// Build don't link:
+// Special g++ Options: -O
+
+main()
+{
+  union {
+    double a;
+    char buff[sizeof(double)];
+  };
+
+  void *p = buff;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/binding.C b/gcc/testsuite/g++.old-deja/g++.jason/binding.C
new file mode 100644
index 00000000000..cc6f25c6ed9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/binding.C
@@ -0,0 +1,11 @@
+// Bug: g++ only looks in the current temporary binding level for a name.
+
+struct T { ~T(); };
+
+int main()
+{
+  foo:
+   T t;				// ERROR - redeclared
+  bar:
+   T t;				// ERROR - redeclaration
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/binding2.C b/gcc/testsuite/g++.old-deja/g++.jason/binding2.C
new file mode 100644
index 00000000000..e56a0544b47
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/binding2.C
@@ -0,0 +1,15 @@
+// Bug: g++ screws up binding levels in a switch statement with cleanups.
+// Build don't link:
+
+struct A {
+  ~A() { }
+};
+
+int f (int i)
+{
+  switch (i) {
+  default:
+    A a;
+  }
+  return 1;
+}				// causes compiler segfault
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/binding3.C b/gcc/testsuite/g++.old-deja/g++.jason/binding3.C
new file mode 100644
index 00000000000..3cd358fb7af
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/binding3.C
@@ -0,0 +1,20 @@
+// Bug: g++ fails to clear out the IDENTIFIER_CLASS_VALUEs of various names
+// after a class definition.
+// Build don't link:
+
+struct A {
+  typedef double T;
+  virtual T f () = 0;
+};
+
+class B {
+  B (const B&);
+  void operator=(const B&);
+public:
+  B ();
+  typedef void * T;
+};
+
+struct C : public A {
+  T f ();			// gets bogus error
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/bool.C b/gcc/testsuite/g++.old-deja/g++.jason/bool.C
new file mode 100644
index 00000000000..e446f12fab6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/bool.C
@@ -0,0 +1,46 @@
+// Testcase for uses of bool.
+// Build don't link:
+
+int i,j,k;
+
+/* Check that types of certain expressions are bool.  */
+void f ()
+{
+  i ? j == k : true;
+  i ? j < k : true;
+  i ? j && k : true;
+}
+
+/* Check that g++ can find a conversion to bool when one exists.  */
+struct A { operator char * (); } a;
+struct B { operator int (); } b;
+struct C { operator float (); } c;
+struct D { operator bool (); } d;
+struct E { operator int E::* (); } e;
+
+void g ()
+{
+  a || true;
+  b || true;
+  c || true;			// gets bogus error
+  d || true;
+  e || true;
+}
+
+/* Check for support in templates.  */
+template <class T> struct F { };
+template class F<bool>;
+
+template <class T> void f (T, bool) { };
+template void f (bool, bool);
+
+/* Special cases.  */
+void h ()
+{
+  /* Used to cause infinite recursion.  */
+  i&1 || true;
+  /* Should find conversion path to int.  */
+  d == true;
+}
+
+bool boo = -1;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/bool2.C b/gcc/testsuite/g++.old-deja/g++.jason/bool2.C
new file mode 100644
index 00000000000..559b7d07615
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/bool2.C
@@ -0,0 +1,14 @@
+// Make sure that bool bitfields promote to int properly.
+
+struct F {
+  bool b1 : 1;
+  bool b2 : 7;
+};
+
+int main()
+{
+  F f = { true, true };
+
+  if (int (f.b1) != 1)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/bool3.C b/gcc/testsuite/g++.old-deja/g++.jason/bool3.C
new file mode 100644
index 00000000000..d8e95147b75
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/bool3.C
@@ -0,0 +1,13 @@
+// From: panisset@cae.ca (Jean-Francois Panisset)
+// Subject: Problem with constant expressions for bitfields
+// Date: Mon, 6 Jun 94 14:00:01 EDT
+
+// Bug: g++ doesn't treat boolean true and false as constant values.
+// Build don't link:
+
+enum E { e1,e2,e3,e4,e5 };
+
+struct X
+{
+        unsigned int bits : ((e5 > 4) ? 8 : 4);	// gets bogus error - constant expression
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/bool4.C b/gcc/testsuite/g++.old-deja/g++.jason/bool4.C
new file mode 100644
index 00000000000..8c4695dec72
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/bool4.C
@@ -0,0 +1,10 @@
+// Test for allowing conversion to bool.
+
+struct A { };
+
+int main ()
+{
+  bool b = (void*)0;
+  b = (int A::*)0;
+  b = (int (A::*)())0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/bool5.C b/gcc/testsuite/g++.old-deja/g++.jason/bool5.C
new file mode 100644
index 00000000000..8f8e37d4eb3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/bool5.C
@@ -0,0 +1,10 @@
+int main ()
+{
+  bool b = false;
+  int i = b++;
+  if (i != false || b != true)
+    return 1;
+  i = b++;
+  if (i != true || b != true)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/bool6.C b/gcc/testsuite/g++.old-deja/g++.jason/bool6.C
new file mode 100644
index 00000000000..493e25f73f3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/bool6.C
@@ -0,0 +1,9 @@
+// Bug:  The conversion from bool to int gets stripped.
+// Build don't link:
+
+bool b;
+
+int main ()
+{
+  return ((!b) != 0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/bool7.C b/gcc/testsuite/g++.old-deja/g++.jason/bool7.C
new file mode 100644
index 00000000000..1ecb68d4e04
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/bool7.C
@@ -0,0 +1,29 @@
+// Build don't link:
+
+struct A
+{
+  operator bool () const;
+  operator const void * () const;
+};
+
+struct B
+{
+  A a;
+  int foo1 ();
+  int foo2 ();
+};
+
+int
+B::foo1 ()
+{
+  return a ? 0 : 1;  // ambiguous default type conversion for `operator !='
+}
+
+int
+B::foo2 ()
+{
+  if (a)
+    return 0;
+  else
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/builtin.C b/gcc/testsuite/g++.old-deja/g++.jason/builtin.C
new file mode 100644
index 00000000000..0e0cc48c691
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/builtin.C
@@ -0,0 +1,10 @@
+// Bug: g++ overloads strlen instead of bashing the builtin version.
+// Special g++ Options: -w
+// Build don't link:
+
+extern "C" void strlen (const char *);
+
+void f ()
+{
+  strlen("Hi");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/builtin2.C b/gcc/testsuite/g++.old-deja/g++.jason/builtin2.C
new file mode 100644
index 00000000000..698d0a12112
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/builtin2.C
@@ -0,0 +1,8 @@
+// Build don't link:
+
+inline void strlen (const char *) { }
+
+void f ()
+{
+  strlen("Hi");			// gets bogus error - wrongful overload
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/byval.C b/gcc/testsuite/g++.old-deja/g++.jason/byval.C
new file mode 100644
index 00000000000..bd17797a181
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/byval.C
@@ -0,0 +1,19 @@
+// Bug: a is destroyed in both foo() and main()
+
+int count;
+
+struct A {
+  double a,b;
+  A(int) { count++; }
+  A(const A&) { count++; }
+  ~A() { count--; }
+};
+
+void foo (A a)
+{ }
+
+int main()
+{
+  foo (1);
+  return count;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/byval2.C b/gcc/testsuite/g++.old-deja/g++.jason/byval2.C
new file mode 100644
index 00000000000..490e625805d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/byval2.C
@@ -0,0 +1,23 @@
+// From: panisset@cae.ca (Jean-Francois Panisset)
+// Subject: 2.6.0 pre-rel, internal error, regression, mips-sgi-irix4
+// Date: Thu, 14 Jul 94 23:34:21 EDT
+// Build don't link:
+
+class Char
+{
+protected:
+  char          rep;
+public:
+  Char (const char ) {};
+  operator char() const;
+  void  operator -= (const Char   );
+};
+
+inline  Char  operator -  (const Char    a, const Char    b) {}
+inline  char  operator == (const Char    a, const char b) {}
+
+char mystrcmp(Char s[31], Char t[31])
+{
+  for (; *s == *t; ++s, ++t) if (*s == '\0') return 0;
+  return char(*s - *t);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/byval3.C b/gcc/testsuite/g++.old-deja/g++.jason/byval3.C
new file mode 100644
index 00000000000..7c2a798ed47
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/byval3.C
@@ -0,0 +1,14 @@
+// Test to make sure that value return of classes with cleanups works; it
+// has been broken at various times on PCC_STATIC_STRUCT_RETURN targets.
+// Build don't link:
+
+struct A {};
+
+struct R : virtual A { virtual ~R(); };
+
+R g();
+
+void encode()
+{
+    g();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/c-inline.C b/gcc/testsuite/g++.old-deja/g++.jason/c-inline.C
new file mode 100644
index 00000000000..7e90c4ea027
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/c-inline.C
@@ -0,0 +1,11 @@
+// Bug: the compiler gets hopelessly confused.
+// Build don't link:
+
+#line 1 "c-inline.h"
+#pragma interface
+inline double abs (double) { return 0.0; }
+inline short abs (short) { return 0; }
+#line 2 "c-inline.C"
+extern "C" {
+  inline int abs (int) { return 0; } // causes segfault - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/c2.C b/gcc/testsuite/g++.old-deja/g++.jason/c2.C
new file mode 100644
index 00000000000..ba7f0ed0d55
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/c2.C
@@ -0,0 +1,18 @@
+// PRMS Id: 3134
+// g++ understands C redeclaration semantics.  Sun CC 2.0.1 doesn't.
+// Special g++ Options:
+// Build don't link:
+
+extern "C" {
+  int foo();
+  int foo(int);
+
+  int bar(int);
+  int bar();
+}
+
+main()
+{
+  foo (1);
+  bar (1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/cast1.C b/gcc/testsuite/g++.old-deja/g++.jason/cast1.C
new file mode 100644
index 00000000000..4e987eafece
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/cast1.C
@@ -0,0 +1,8 @@
+// Bug: g++ fails to grok functional casts in all situations.
+// Build don't link:
+
+class A  {
+public:
+  typedef int B;
+  static B foo() { return B(1); } // gets bogus error - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/cast2.C b/gcc/testsuite/g++.old-deja/g++.jason/cast2.C
new file mode 100644
index 00000000000..02495b346d1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/cast2.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// The compiler tried to build up a double with a NOP_EXPR from
+// integer_zero_node, which fails.
+
+template <class T>
+class vector  {
+public:
+    vector (int n, const T& value = T()) {}
+};
+
+void
+foo (void)
+{
+  vector<double> v (10);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/cast3.C b/gcc/testsuite/g++.old-deja/g++.jason/cast3.C
new file mode 100644
index 00000000000..5d599805aa3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/cast3.C
@@ -0,0 +1,16 @@
+// PRMS Id: 7088
+// Build don't link:
+
+struct string
+{
+  int length () const;
+  string (string &);
+  string (char * = 0);
+  int operator [] (int);
+  ~string ();
+};
+
+string _cook(const   string     raw, bool for_postscript)
+{
+  unsigned char c = (unsigned) ((string &)raw)[1];
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/cleanup.C b/gcc/testsuite/g++.old-deja/g++.jason/cleanup.C
new file mode 100644
index 00000000000..d9adddec2e8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/cleanup.C
@@ -0,0 +1,23 @@
+// Bug: continue over object decl calls destructor but not constructor.
+
+int c = 0;
+int d = 0;
+extern "C" int printf(const char *,...);
+
+class Foo {
+public:
+  Foo(){ c++; }
+  ~Foo(){ d++; }
+};
+
+int main()
+{
+  for(int i=0;i<2;i++){
+    continue;
+    Foo bar;
+  }
+  printf ("%d %d\n", c, d);
+  if (c == d && d == 0)
+    return 0;
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/cleanup2.C b/gcc/testsuite/g++.old-deja/g++.jason/cleanup2.C
new file mode 100644
index 00000000000..fdae1b72d59
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/cleanup2.C
@@ -0,0 +1,15 @@
+// PRMS Id: 6303
+// Bug: compiler crashes processing the cleanup for arrayOfClass.
+// Build don't link:
+
+class Class {
+public:
+  ~Class();		// This dtor MUST be declared to generate the error...
+};
+
+Class varOfClass;
+
+int main() {
+  // This MUST be 'const' to generate the error...
+  const Class	arrayOfClass[1] = { varOfClass }; // causes abort
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/complete1.C b/gcc/testsuite/g++.old-deja/g++.jason/complete1.C
new file mode 100644
index 00000000000..0f140e16114
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/complete1.C
@@ -0,0 +1,12 @@
+// PRMS Id: 4695
+// Bug: g++ wrongly requires A to be complete here.
+// Build don't link:
+
+struct A;
+
+void foo(const A &);
+
+void bar(A *p)
+{
+  foo(*p);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/cond.C b/gcc/testsuite/g++.old-deja/g++.jason/cond.C
new file mode 100644
index 00000000000..b613838797d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/cond.C
@@ -0,0 +1,39 @@
+// Build don't link: 
+// GROUPS passed rtti
+// Negative testcase for decls in conditions.
+
+int main()
+{
+  float i;
+  
+  if (int i = 1)		// ERROR - , XFAIL *-*-*
+    {
+      char i;			// ERROR - , XFAIL *-*-*
+      char j;
+    }
+  else
+    {
+      short i;			// ERROR - , XFAIL *-*-*
+      char j;
+    }
+
+  if (struct A { operator int () { return 1; } } *foo = new A) // ERROR - 
+    ;
+
+  A bar;			// ERROR - 
+  
+  if (enum A { one, two, three } foo = one) // ERROR - 
+    ;
+
+  struct B { operator int () { return 2; } };
+
+  if (struct B * foo = new B)
+    ;
+
+  if (int f () = 1)		// ERROR - 
+    ;
+  
+  if (int a[2] = {1, 2})	// ERROR - 
+    ;
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/cond2.C b/gcc/testsuite/g++.old-deja/g++.jason/cond2.C
new file mode 100644
index 00000000000..9a8e04546ee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/cond2.C
@@ -0,0 +1,65 @@
+// Positive testcase for decls in conditions.
+
+extern "C" int printf(const char *, ...);
+
+int up = 0;
+int down = 0;
+
+struct T
+{
+  int i;
+  T(int j) { i = j; printf("UP\n"); up++; }
+  T(const T& t) { i = t.i; printf("unwanted copy\n"); }
+  ~T() { printf ("DOWN\n"); down++; }
+  operator int () { return i; }
+};
+
+int main ()
+{
+  int t;
+
+  if (T t = 1)
+    ;
+
+  printf ("\n");
+  
+  int j = 3;
+  while (T t = j--)
+    ;
+  
+  printf ("\n");
+  
+  j = 3;
+  while (1)
+    {
+      T t = j--;
+      if (t) continue;
+      break;
+    }
+  
+  printf ("\n");
+  
+  j = 3;
+  for (;T t = j--;)
+    ;
+
+  printf ("\n");
+  
+  for (int k = 3; T t = k--;)
+    ;
+
+  printf ("\n");
+  
+  switch (T t = 34)
+    {
+    case 34:
+      ;
+    }
+
+  printf ("\n");
+  
+  if (up == down && up == 18)
+    return 0;
+  else
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/condexp.C b/gcc/testsuite/g++.old-deja/g++.jason/condexp.C
new file mode 100644
index 00000000000..edfd12ef1a9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/condexp.C
@@ -0,0 +1,14 @@
+// PRMS id: 5629
+// Build don't link:
+
+struct String { const char *x; };
+class Pathname: public String { };
+
+String
+f(int i)
+{
+    Pathname p;
+    String s;
+
+    return i ? p: s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/const.C b/gcc/testsuite/g++.old-deja/g++.jason/const.C
new file mode 100644
index 00000000000..2faf8e5811e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/const.C
@@ -0,0 +1,16 @@
+// Bug: a ends up in the text segment, so trying to initialize it causes
+// a seg fault.
+
+struct A {
+  int i;
+  A(): i(0) {}
+  A(int j): i(j) {}
+};
+
+const A a;
+const A b(1);
+
+int main ()
+{
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/const2.C b/gcc/testsuite/g++.old-deja/g++.jason/const2.C
new file mode 100644
index 00000000000..7dd956bc284
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/const2.C
@@ -0,0 +1,14 @@
+// Example of static member constants
+
+extern "C" int printf (const char *, ...);
+
+struct T {
+  static const char letter = 'a'; // this is the new stuff!
+  char x[letter];
+  void f();
+};
+
+void T::f() { printf ("%p", &letter); }
+const char T::letter;               // still need def after class
+
+int main() { }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/const3.C b/gcc/testsuite/g++.old-deja/g++.jason/const3.C
new file mode 100644
index 00000000000..3ff8f0c89a6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/const3.C
@@ -0,0 +1,10 @@
+// Bug: bar isn't emitted, which causes havoc.
+
+extern int i;
+const int bar = i;
+int i = 5;
+
+int main()
+{
+  return bar != 5;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/const4.C b/gcc/testsuite/g++.old-deja/g++.jason/const4.C
new file mode 100644
index 00000000000..b8b8efa0ae6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/const4.C
@@ -0,0 +1,24 @@
+// PRMS Id: 8927
+// Bug: complex inheritance interferes with const checking
+
+class GrandParent {
+public:
+  virtual void DoIt();
+protected:
+  int A;
+};
+
+class Parent : virtual public GrandParent {
+public:
+  virtual void DoX() const;
+};
+
+class Child : public Parent {
+public:
+  void DoX() const;
+};
+
+void Child::DoX() const
+{
+  A = 10;		// ERROR - assignment to const
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/context.C b/gcc/testsuite/g++.old-deja/g++.jason/context.C
new file mode 100644
index 00000000000..a9a83631992
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/context.C
@@ -0,0 +1,20 @@
+// PRMS Id: 3988
+// Bug: DECL_CONTEXT of A::B gets clobbered in pushdecl when defining A::foo().
+// Build don't link:
+
+#pragma implementation "context.h"
+#line 1 "context.h"
+#pragma interface
+
+template <class T>
+struct A {
+  inline void foo () { }
+  class B { };
+};
+
+struct C : public A<int> {
+  void bar (C::B&);
+};
+#line 2 "context.C"
+
+void C::bar (C::B& b) { }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion.C
new file mode 100644
index 00000000000..80436f355a2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion.C
@@ -0,0 +1,16 @@
+// Bug: g++ doesn't find the conversion path from DPtr& to B*.
+// Build don't link:
+
+class B {};
+class D : public B {};
+class DPtr
+{
+public:
+  operator D*() const;
+};
+
+void foo (B* bp);
+void bar (DPtr& dp)
+{
+  foo (dp);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion10.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion10.C
new file mode 100644
index 00000000000..97bb70744cb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion10.C
@@ -0,0 +1,19 @@
+// PRMS Id: 9019
+// Bug: g++ doesn't find conversion to const char *.
+// Build don't link:
+
+struct String {
+  String ();
+  explicit String (const char *);
+  operator const char * ();
+};
+
+int main(int argc, char **argv) 
+{
+	String deflt("no args");
+	String useme;
+
+	const char *p = (argv[1]) ? argv[1] : deflt;
+
+	return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion11.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion11.C
new file mode 100644
index 00000000000..c0c6ca4159c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion11.C
@@ -0,0 +1,26 @@
+// PRMS Id: 8805
+// Bug: The two-level conversion is not found when calling a global fn.
+
+class Int {
+public:
+  Int(int A);
+};
+
+class Ding {
+public:
+  Ding(Int A);
+};
+
+class Something {
+public:
+  void DoSomething(Ding A);	// ERROR - referred to
+};
+
+void DoSomething(Ding A);
+
+void foo(Something* pX)
+{
+  DoSomething(1);		// ERROR - 
+  pX->DoSomething(1);		// ERROR - 
+  (*pX).DoSomething(1);		// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion2.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion2.C
new file mode 100644
index 00000000000..db773d698e4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion2.C
@@ -0,0 +1,6 @@
+// PRMS Id: 3069
+
+void f(int&);			// ERROR - referenced by error below
+void g(const int& i) {
+  f(i);				// ERROR - discarding const
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion3.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion3.C
new file mode 100644
index 00000000000..0d66c1ecee1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion3.C
@@ -0,0 +1,7 @@
+void qsort (void *, int, int, int (*)(const void *, const void *));
+int f (char *, char *);
+void g ()
+{
+  typedef int (*pf)(void *, void *);
+  qsort(0, 0, 0, pf(f));	// ERROR - adding const to function parms
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion4.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion4.C
new file mode 100644
index 00000000000..7caca196d0a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion4.C
@@ -0,0 +1,14 @@
+// Build don't link:
+struct A {
+  A (int);
+};
+struct B {
+  operator int () { return 1; }
+};
+void f (const A&);
+void g()
+{
+  B b;
+  f ((A) b);
+  f (A (b)); // gets bogus error - functional cast treated differently from C style
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion5.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion5.C
new file mode 100644
index 00000000000..303860b4725
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion5.C
@@ -0,0 +1,12 @@
+// Build don't link:
+struct A { };
+struct B: public A {
+  A a;
+  operator A () { return a; }	// WARNING - never used implicitly
+};
+void f (const A&);
+void g()
+{
+  B b;
+  (A) b; // gets bogus error - trying both constructor and type conversion operator
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion6.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion6.C
new file mode 100644
index 00000000000..a8477e36864
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion6.C
@@ -0,0 +1,40 @@
+// PRMS Id: g++/6034
+
+extern "C" int printf (const char *, ...);
+
+class Base
+{
+	char x;
+};
+
+template <class T>
+// remove the public Base inheritance and the problem goes away...
+class Container : public Base
+{
+public:
+
+    Container(const T& aValue): myValue(aValue) { }
+    
+    operator const T&(void) const
+    {
+	printf("Container::const T& called\n");
+	return myValue;
+    }
+    
+protected:
+
+    T myValue;
+};
+
+typedef unsigned short Type;
+
+typedef Container<Type> TypeContainer;
+
+int main(void)
+{
+    TypeContainer myTypeContainer(2);
+    Type t = myTypeContainer;
+
+    printf ("myType = %d\n", t);
+    return t != 2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion7.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion7.C
new file mode 100644
index 00000000000..01812f5b8ee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion7.C
@@ -0,0 +1,16 @@
+// Bug: g++ tries to look inside (B*)0 for a virtual base pointer.
+
+struct A
+{
+};
+
+struct B : virtual A
+{
+};
+
+A* a;
+
+int main()
+{
+    a = (B*)0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion8.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion8.C
new file mode 100644
index 00000000000..0c3d378b47a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion8.C
@@ -0,0 +1,10 @@
+// PRMS id: 8279
+
+int main ()
+{
+  char *const *p = 0;
+  char **q = 0;
+
+  (void)(p - q);
+  (void)(q - p);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/conversion9.C b/gcc/testsuite/g++.old-deja/g++.jason/conversion9.C
new file mode 100644
index 00000000000..e0d3715dae2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/conversion9.C
@@ -0,0 +1,13 @@
+// PRMS Id: 8475
+
+class SomeClass {
+public:
+  operator int & () {
+    static int x;
+    return x;
+  }
+} a;
+
+int main (int, char**) {
+  return a + 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash1.C b/gcc/testsuite/g++.old-deja/g++.jason/crash1.C
new file mode 100644
index 00000000000..298273490fc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash1.C
@@ -0,0 +1,29 @@
+// Bug: g++ dies on this input.
+// Build don't link:
+
+class Sample
+  {
+ public:
+  int operator <<(const char *c);
+  };
+
+extern Sample sample;
+
+struct Simple
+  {
+  int a;
+  };
+
+extern "C" void get_it();
+
+class Test
+  {
+ private:
+  void test();
+  friend void get_it();
+  };
+
+void Test::test()
+  {
+  sample << "hello";
+  }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash10.C b/gcc/testsuite/g++.old-deja/g++.jason/crash10.C
new file mode 100644
index 00000000000..b9669449589
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash10.C
@@ -0,0 +1,7 @@
+// PRMS Id: 5155
+
+struct A {
+  enum foo { bar };
+};
+
+typedef A::foo A::foo;		// ERROR - causes compiler segfault
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash11.C b/gcc/testsuite/g++.old-deja/g++.jason/crash11.C
new file mode 100644
index 00000000000..51d1629630e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash11.C
@@ -0,0 +1,9 @@
+// Bug: g++ crashes on this input.
+// Build don't link:
+
+struct A {
+  const char *p;
+};
+const char foo[] = "bar";
+const A a = { foo };
+extern const A* ap = &a;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash12.C b/gcc/testsuite/g++.old-deja/g++.jason/crash12.C
new file mode 100644
index 00000000000..46d63225bab
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash12.C
@@ -0,0 +1,10 @@
+// Bug: g++ dies instead of flagging this invalid.
+// Build don't link:
+
+inline float  max(float  x, float  y) { return (x>y)?x:y; }
+
+float  b(float  x, float  y, float  z)
+{
+  float f = (y<x)?x:(max<y)?z:y;	// ERROR - 
+  return f;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash3.C b/gcc/testsuite/g++.old-deja/g++.jason/crash3.C
new file mode 100644
index 00000000000..c3709c55536
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash3.C
@@ -0,0 +1,13 @@
+// Bug: g++ tries to generate initialization semantics for a Node from an int,
+// and fails.
+// Build don't link:
+
+struct Node
+{
+  Node* child[2];
+};				// ERROR - 
+
+void bug(int i)
+{
+  Node* q = new Node(i);	// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash4.C b/gcc/testsuite/g++.old-deja/g++.jason/crash4.C
new file mode 100644
index 00000000000..bf6a15c370a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash4.C
@@ -0,0 +1,38 @@
+// PRMS Id: 4346
+// Bug: g++ dies on redefinition of cc_Array::repInvariant.
+// Build don't link:
+
+class ccObjectInfo
+{
+public:
+    virtual const ccObjectInfo& repInvariant (int =0) const;
+};
+
+template <class T>
+class cc_Array : public ccObjectInfo
+{
+public:
+  virtual const ccObjectInfo& repInvariant (int =0) const ;
+};
+
+template <class T>
+const ccObjectInfo& cc_Array<T>::repInvariant(int) const
+{  return *this /* *this is required here */; } // ERROR - redefined
+
+template <class T>
+class ccArray :public ccObjectInfo
+{
+  ccArray (cc_Array<T>*);
+};
+
+template <class T>
+class ccObjArray : public ccArray<T>
+{
+  ccObjArray();
+}; 
+
+template <class T>
+const ccObjectInfo& cc_Array<T>::repInvariant(int) const
+{  return 0; }			// ERROR - causes compiler segfault
+
+typedef ccObjArray< double>	ccROIRuns;	 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash5.C b/gcc/testsuite/g++.old-deja/g++.jason/crash5.C
new file mode 100644
index 00000000000..b67376fe261
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash5.C
@@ -0,0 +1,4 @@
+// Bug: g++ doesn't deal well with abstract declarators used inappropriately.
+// Build don't link:
+
+void (*)();			// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash6.C b/gcc/testsuite/g++.old-deja/g++.jason/crash6.C
new file mode 100644
index 00000000000..8e0a9c861f2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash6.C
@@ -0,0 +1,9 @@
+// Bug: g++ dies on the below.
+// Build don't link:
+
+class A { };
+void f ()
+{
+  A a;
+  a.~a();			// ERROR - causes segfault
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash7.C b/gcc/testsuite/g++.old-deja/g++.jason/crash7.C
new file mode 100644
index 00000000000..e7dd8f75aad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash7.C
@@ -0,0 +1,5 @@
+// Bug: g++ can't deal.
+
+typedef unsigned size_t;	// ERROR - previous declaration
+typedef unsigned long size_t;	// ERROR - redefining size_t
+void f (size_t);		// causes compiler segfault - 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash8.C b/gcc/testsuite/g++.old-deja/g++.jason/crash8.C
new file mode 100644
index 00000000000..cadda2f4764
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash8.C
@@ -0,0 +1,9 @@
+struct A {
+  A();
+  A(A);				// ERROR - copy ctor must take reference
+};
+int main()
+{
+  A a;
+  A b(a);			// causes compiler segfault
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/crash9.C b/gcc/testsuite/g++.old-deja/g++.jason/crash9.C
new file mode 100644
index 00000000000..6cacb11a541
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/crash9.C
@@ -0,0 +1,29 @@
+// PRMS Id: 5085
+// Bug: TYPE_POINTER_TO wasn't set.
+// Build don't link:
+
+class A {
+   A(const A &);
+   void operator=(const A &); 
+public:
+   inline A();
+};
+
+class B {
+   A a;
+public:
+   B();
+   virtual void f() const;
+};
+
+class C : public B { };
+
+class D : C {
+public:
+  void f() const;
+};
+
+void D::f() const
+{
+  C::f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ctor1.C b/gcc/testsuite/g++.old-deja/g++.jason/ctor1.C
new file mode 100644
index 00000000000..123295dc409
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ctor1.C
@@ -0,0 +1,26 @@
+// PRMS Id: 5584
+
+extern "C"
+{
+  struct xx {
+    void (*xx)(void);		// ERROR - field with name of class
+    int x,y;
+  };
+}
+
+int r = 1;
+
+void f(void)
+{
+  r = 0;
+}
+
+int main()
+{
+  struct xx p;
+
+  p.xx = f;
+  p.xx();
+
+  return r;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ctor2.C b/gcc/testsuite/g++.old-deja/g++.jason/ctor2.C
new file mode 100644
index 00000000000..bf37c114be1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ctor2.C
@@ -0,0 +1,16 @@
+// Bug: the reference to c in the initializer list doesn't get fixed up.
+// Build don't link:
+
+struct AP {
+    AP(unsigned char);
+};
+
+struct AI : AP {
+    AI(unsigned char);
+};
+
+AI::AI(unsigned char c)
+: AP(c)
+{
+  &c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/dcast1.C b/gcc/testsuite/g++.old-deja/g++.jason/dcast1.C
new file mode 100644
index 00000000000..f4d93c3c068
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/dcast1.C
@@ -0,0 +1,20 @@
+// PRMS Id: 7162
+// Build don't link:
+
+struct B {
+   int i;
+   B() : i(1) {}
+};
+
+struct D : B {
+   int i;
+   D() : i(2) {}
+};
+
+void ch()
+{
+   D od2;
+   D &rd2 = od2;
+
+   B &rd1 = dynamic_cast<B&>(rd2);
+}   
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/dcast2.C b/gcc/testsuite/g++.old-deja/g++.jason/dcast2.C
new file mode 100644
index 00000000000..e42c71da2f5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/dcast2.C
@@ -0,0 +1,18 @@
+struct A { virtual void f() { } };
+struct B { virtual void g() { } };
+struct C : public A, public B { };
+
+int main ()
+{
+  C* cp = 0;
+  B* bp = 0;
+
+  if (dynamic_cast <B*> (cp) != 0)
+    return 1;
+
+  if (dynamic_cast <void *> (bp) != 0)
+    return 1;
+
+  if (dynamic_cast <C*> (bp) != 0)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/dcast3.C b/gcc/testsuite/g++.old-deja/g++.jason/dcast3.C
new file mode 100644
index 00000000000..6d333f098bc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/dcast3.C
@@ -0,0 +1,32 @@
+// Testcase for tricky dynamic cast situations.
+
+struct A {
+  virtual void f () { }
+};
+
+struct B : public A { };
+struct C : public B { };
+struct D : public B { };
+struct E : public C, public D { };
+
+struct B2 : public virtual A { };
+struct C2 : public B2 { };
+struct D2 : public B2 { };
+struct E2 : public C2, public D2 { };
+
+int main ()
+{
+  E e;
+  E2 e2;
+
+  A* ap = (C*)&e;
+
+  // ap points to base subobject of unique B; succeeds
+  if (dynamic_cast <B*> (ap) == 0)
+    return 1;
+
+  ap = (C2*)&e2;
+  // ap points to base subobject shared by two Bs; fails
+  if (dynamic_cast <B2*> (ap) != 0)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/default1.C b/gcc/testsuite/g++.old-deja/g++.jason/default1.C
new file mode 100644
index 00000000000..0372d91b7da
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/default1.C
@@ -0,0 +1,16 @@
+// PRMS Id: 5204
+// Bug: g++ bashes the type of add_sym with the type of add, so calling it
+// with one parameter generates an error.
+// Build don't link:
+
+int add(int const &symbol,
+	const unsigned char flags=(void*)0); // ERROR - invalid default arg
+
+int add_sym(int const &symbol,
+	    const unsigned char flags=0);
+
+int main()
+{
+   int fname;
+   add_sym(fname);      // Guarantee a symbol exists
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/default2.C b/gcc/testsuite/g++.old-deja/g++.jason/default2.C
new file mode 100644
index 00000000000..f50ee2f151b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/default2.C
@@ -0,0 +1,31 @@
+// PRMS Id: 5921
+// Build don't link:
+// Bug: default arguments containing constructor calls persist incorrectly.
+
+class foo
+{
+ public:
+  foo();
+  foo(int x);
+ public:
+  int iamamember;
+};
+
+class bar
+{
+ public:
+  bar();
+  int memberfunction(int i, char *j, double k, foo foo1 = foo(0));
+};
+
+int
+pain(bar *bar1)
+{
+  return bar1->memberfunction(1, "x", 0.0);
+}
+
+int
+pain2(bar *bar1)
+{
+  return bar1->memberfunction(1, "x", 0.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/default3.C b/gcc/testsuite/g++.old-deja/g++.jason/default3.C
new file mode 100644
index 00000000000..05af3b68b27
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/default3.C
@@ -0,0 +1,6 @@
+// Bug: type_list_equal aborts when it sees lang-specific tree nodes.
+// Build don't link:
+
+struct A { };
+void f (A a = A());
+void g (A a = A());
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/defctor.C b/gcc/testsuite/g++.old-deja/g++.jason/defctor.C
new file mode 100644
index 00000000000..68cf25c3ab6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/defctor.C
@@ -0,0 +1,15 @@
+// Bug: g++ doesn't generate default constructor.
+
+class A {
+public:
+  int i;
+};
+
+extern "C" int printf(const char *, ...);
+
+int main () {
+  A a;
+  a.i = 1;
+  A b (a);
+  printf("%d\n",b.i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/delete1.C b/gcc/testsuite/g++.old-deja/g++.jason/delete1.C
new file mode 100644
index 00000000000..a176652df71
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/delete1.C
@@ -0,0 +1,5 @@
+#include <stddef.h>
+struct A {
+  virtual void operator delete (void *); // ERROR - virtual delete
+  virtual void * operator new (size_t);	 // ERROR - virtual new
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/delete2.C b/gcc/testsuite/g++.old-deja/g++.jason/delete2.C
new file mode 100644
index 00000000000..7748e2b9cb5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/delete2.C
@@ -0,0 +1,16 @@
+// PRMS Id: 5003
+// Bug: g++ complains about calling the destructor for a const object.
+// Build don't link:
+
+struct A {
+public:
+  ~A();
+};
+
+const A foo ();
+
+void bar()
+{
+  A n;
+  n = foo();		// gets bogus error - deleting const
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/delete3.C b/gcc/testsuite/g++.old-deja/g++.jason/delete3.C
new file mode 100644
index 00000000000..8bffb9aca86
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/delete3.C
@@ -0,0 +1,18 @@
+// PRMS Id: 6093
+
+class A {
+public:
+  A();
+  ~A();
+protected:
+  void operator delete(void *);	// ERROR - protected
+};
+
+A::~A()
+{
+}
+
+void foo(A *p)
+{
+  delete p;			// ERROR - in this context
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/destruct.C b/gcc/testsuite/g++.old-deja/g++.jason/destruct.C
new file mode 100644
index 00000000000..c5b3be61004
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/destruct.C
@@ -0,0 +1,33 @@
+// Exhaustive test for destructors of simple types.
+// PRMS Id: 2744, 3308
+// Build don't link:
+
+template <class T> class A {
+  T q;
+public:
+  ~A() {
+    q.T::~T();
+    q.~T();
+    (&q)->T::~T();
+    (&q)->~T();
+  }
+};
+
+typedef char * cp;
+
+int main ()
+{
+  A<int> a;
+  A<cp> b;
+  int i;
+  cp c;
+
+  i.~int();
+  i.int::~int();
+  (&i)->~int();
+  (&i)->int::~int();
+  c.~cp();
+  c.cp::~cp();
+  (&c)->~cp();
+  (&c)->cp::~cp();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/destruct2.C b/gcc/testsuite/g++.old-deja/g++.jason/destruct2.C
new file mode 100644
index 00000000000..09b6bdd7991
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/destruct2.C
@@ -0,0 +1,20 @@
+// PRMS Id: 4342
+// Bug: g++ does not massage things enough to allow calling ~X().
+// Build don't link:
+
+struct X 
+{
+    virtual ~X ();
+};
+
+struct Y : public X
+{};
+
+struct Z : public Y, public X
+{};				// WARNING - 
+
+void foo ()
+{
+    Z* f = new Z;
+    delete f;			// gets bogus error - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/destruct3.C b/gcc/testsuite/g++.old-deja/g++.jason/destruct3.C
new file mode 100644
index 00000000000..d4bbf9ad790
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/destruct3.C
@@ -0,0 +1,45 @@
+// Special g++ Options: -w
+// PRMS Id: 4342 (second testcase)
+// Bug: g++ still can't deal with ambiguous inheritance in destructor calls.
+// Build don't link:
+
+struct ccUnwind 
+{
+    ccUnwind ();
+    virtual ~ccUnwind ();
+};
+
+struct ccPersistent
+{
+    virtual void bar();
+};
+
+struct ccImpExp : public ccPersistent, public ccUnwind
+{};
+
+struct ccTool : public ccImpExp
+{};
+
+struct ccScreenTool : public ccTool
+{};
+
+struct ccVTool : public ccScreenTool
+{};
+
+struct ccScreenObjRep : public ccUnwind
+{};
+
+struct ccScreenObj : public ccScreenObjRep
+{};
+
+struct ccVSTool : public ccImpExp, public ccUnwind 
+{};
+
+struct ccSCCP : public ccVSTool
+{};
+
+void foo ()
+{
+    ccSCCP* foo = new ccSCCP;
+    delete foo;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/destruct4.C b/gcc/testsuite/g++.old-deja/g++.jason/destruct4.C
new file mode 100644
index 00000000000..3ce7d765505
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/destruct4.C
@@ -0,0 +1,14 @@
+// PRMS Id: 4342
+// Bug: g++ fails to massage ambiguity in calling virtual destructor.
+// Build don't link:
+
+class A { public: virtual ~A();};
+class B: public A { };
+class C: public A { };
+class D: public B, public C { };
+ 
+void foo ()
+{
+    D* p = new D;
+    delete p;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/dot.C b/gcc/testsuite/g++.old-deja/g++.jason/dot.C
new file mode 100644
index 00000000000..3870eead449
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/dot.C
@@ -0,0 +1,20 @@
+// PRMS Id: 4143
+// Bug: Pointer is silently dereferenced in method call.
+// Build don't link:
+
+extern "C" int printf (const char *, ...);
+
+class Test
+{
+    char ch;
+  public:
+    Test(char c) : ch(c) {}
+    void Print() { printf("%c", ch); }
+};
+
+int main()
+{
+    Test *p = new Test('x');
+
+    p.Print();	// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/dtor.C b/gcc/testsuite/g++.old-deja/g++.jason/dtor.C
new file mode 100644
index 00000000000..db76e171349
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/dtor.C
@@ -0,0 +1,13 @@
+struct A {
+  ~A();
+};
+
+struct B {
+  ~B();
+};
+
+int main()
+{
+  A a;
+  a.~B();			// ERROR - wrong name
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/dtor2.C b/gcc/testsuite/g++.old-deja/g++.jason/dtor2.C
new file mode 100644
index 00000000000..c088e3f3d2e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/dtor2.C
@@ -0,0 +1,10 @@
+// PRMS Id: 5163
+// Bug: g++ doesn't accept the explicit destructor call syntax for templates.
+
+template <class T> struct A { };
+A<int> a;
+
+int main()
+{
+  a.~A();			// gets bogus error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/dtor3.C b/gcc/testsuite/g++.old-deja/g++.jason/dtor3.C
new file mode 100644
index 00000000000..0c5e68abb47
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/dtor3.C
@@ -0,0 +1,18 @@
+// PRMS Id: 5341
+// Bug: g++ complains about the explicit destructor notation.
+// Build don't link:
+
+#include <stddef.h>
+
+void *operator new(size_t Size, void* pThing) { return pThing; };
+
+template <class T> class Stack {
+public:
+  Stack() { new (Data) T(); }
+  ~Stack() { ((T*)Data)->~T(); }
+private:
+  char Data[sizeof(T)];
+};
+
+Stack<int> a;
+Stack<Stack<int> > c;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/dtor4.C b/gcc/testsuite/g++.old-deja/g++.jason/dtor4.C
new file mode 100644
index 00000000000..dfdc3aafd6c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/dtor4.C
@@ -0,0 +1,23 @@
+// PRMS Id: 5420
+// Bug: g++ gets mixed up calling destructors for references.
+// Build don't link:
+
+template<class X>
+class Z {
+public:
+    char space[100];
+    void kill()
+	{ X& x = (X&) space[0];
+	  x.~X(); }
+};
+
+class C { int i; };
+
+void
+f()
+{
+    Z<int> r;
+    r.kill();
+    Z<C> s;
+    s.kill();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/dtor5.C b/gcc/testsuite/g++.old-deja/g++.jason/dtor5.C
new file mode 100644
index 00000000000..4761bedf2cc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/dtor5.C
@@ -0,0 +1,24 @@
+// PRMS Id: 5286
+// Bug: g++ forgets side-effects of object in call to nonexistent destructor.
+
+#include <new>
+
+int r;
+
+template <class T> struct A {
+  T *p;
+  int i;
+  A() { i = 0; p = (T*) new char[sizeof (T)]; new (p + i++) T; }
+  ~A() { p[--i].~T(); r = i; }
+};
+
+int main()
+{
+  { A<int> a; }
+
+  int* p = (int*) new char[sizeof (int)];
+  new (p + r++) int;
+  p[--r].~int();
+  
+  return r;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/enum.C b/gcc/testsuite/g++.old-deja/g++.jason/enum.C
new file mode 100644
index 00000000000..6dd24e61811
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/enum.C
@@ -0,0 +1,19 @@
+// PRMS Id: 4337
+// Bug: Enums are not looked up to arbitrary depth.
+// Build don't link:
+
+struct W {
+  enum A { B };
+};
+
+struct X : public W
+{};
+
+struct Y : public X
+{};
+
+struct S
+{
+  X::A a1;
+  Y::A a2;			// gets bogus error - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/enum2.C b/gcc/testsuite/g++.old-deja/g++.jason/enum2.C
new file mode 100644
index 00000000000..8fb75386878
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/enum2.C
@@ -0,0 +1,8 @@
+// Build don't link:
+
+enum tristate { no = -1, maybe, yes };
+
+void foobar ()
+{
+  tristate var = no;		// gets bogus error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/enum3.C b/gcc/testsuite/g++.old-deja/g++.jason/enum3.C
new file mode 100644
index 00000000000..9e25570ab42
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/enum3.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Special g++ Options: -Wall
+
+enum tristate { no = -1, maybe, yes };
+
+tristate
+tristate_satisfies (register tristate const t1, register tristate const t2)
+{
+  switch (t1)
+    {
+    case no:
+      return (tristate) -t2;
+    case maybe:
+      return yes;
+    case yes:
+      return t2;
+    }
+  return maybe;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/enum4.C b/gcc/testsuite/g++.old-deja/g++.jason/enum4.C
new file mode 100644
index 00000000000..ab8b69f4aa7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/enum4.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// Special g++ Options: -Wall
+
+enum tristate { no = -1, maybe, yes };
+
+tristate
+definite_tristate (int truth)
+{
+  return (truth) ? yes : no;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/enum5.C b/gcc/testsuite/g++.old-deja/g++.jason/enum5.C
new file mode 100644
index 00000000000..bbaa6747461
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/enum5.C
@@ -0,0 +1,8 @@
+enum { a = 1 };
+
+int main(void)
+{
+  int l = -1;
+
+  return ! (l < a);		// testcase fails if a is unsigned
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/enum6.C b/gcc/testsuite/g++.old-deja/g++.jason/enum6.C
new file mode 100644
index 00000000000..4097e2db1eb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/enum6.C
@@ -0,0 +1,15 @@
+// Special g++ Options: -fshort-enums
+
+#include <limits.h>
+
+enum A { a1 = 0x7fffffff };
+enum B { b1 = 0x80000000 };
+enum C { c1 = -1, c2 = 0x80000000 };
+enum D { d1 = CHAR_MIN, d2 = CHAR_MAX };
+enum E { e1 = CHAR_MIN, e2 = CHAR_MIN };
+
+main()
+{
+  return (sizeof (A) != 4 || sizeof (B) != 4 || sizeof (C) != 8
+	  || sizeof (D) != 1 || sizeof (E) != 1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/enum7.C b/gcc/testsuite/g++.old-deja/g++.jason/enum7.C
new file mode 100644
index 00000000000..0f683047aec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/enum7.C
@@ -0,0 +1,15 @@
+// Yet Another testcase for signed/unsigned enums.
+// Build don't link:
+
+enum A { AA = 0, AB = 1};
+enum B { BA = -1, BB = 1};
+
+void set(int a);
+void set(long a);
+
+void
+foo()
+{
+	set(AA);	// gets bogus error - why is this ambiguous
+	set(BA);	// when this is not amibguous
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/enum8.C b/gcc/testsuite/g++.old-deja/g++.jason/enum8.C
new file mode 100644
index 00000000000..0a3220f7faa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/enum8.C
@@ -0,0 +1,20 @@
+// Bug: the switch fails on the Alpha because folding ef - 1 fails.
+
+enum foo { one=1, thirty=30 };
+
+int f (enum foo ef)
+{
+  switch (ef)
+    {
+    case one:
+    case thirty:
+      return 0;
+    default:
+      return 1;
+    }
+}
+
+int main ()
+{
+  return f (one);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/explicit.C b/gcc/testsuite/g++.old-deja/g++.jason/explicit.C
new file mode 100644
index 00000000000..9fcecfd81ae
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/explicit.C
@@ -0,0 +1,15 @@
+// Testcase for explicit instantiation of templates.
+// Build don't link:
+
+template <class T>
+class A {
+  T t;
+public:
+  void f () { }
+};
+
+template class A<int>;
+
+template <class T> T min (T a, T b) { return (a < b ? a : b); }
+
+template int min (int, int);
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/expr1.C b/gcc/testsuite/g++.old-deja/g++.jason/expr1.C
new file mode 100644
index 00000000000..89d719fddd9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/expr1.C
@@ -0,0 +1,12 @@
+// Bug: g++ doesn't figure out what to do.
+// Build don't link:
+
+struct A {
+  operator char *();
+};
+ 
+char foo(A a)
+{
+  char c = a[0];			// gets bogus error
+  return c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/friend.C b/gcc/testsuite/g++.old-deja/g++.jason/friend.C
new file mode 100644
index 00000000000..4c517cbeee4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/friend.C
@@ -0,0 +1,18 @@
+// Bug: g++ doesn't keep track of the lexical context of friends properly.
+
+extern "C" void exit(int);
+
+struct B;
+struct A {
+  static void f () { exit (1); }
+};
+
+struct B {
+  static void f () { exit (0); }
+  friend void g () { f (); }
+};
+
+int main ()
+{
+  g ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/friend2.C b/gcc/testsuite/g++.old-deja/g++.jason/friend2.C
new file mode 100644
index 00000000000..02ccb5c59dc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/friend2.C
@@ -0,0 +1,21 @@
+// PRMS Id: 5189
+// Bug: g++ fails to collapse the several declarations of freefoo, so it isn't
+// recognized as a friend.
+// Build don't link:
+
+extern "C"
+void freefoo(void);
+
+class foo {
+   friend void freefoo(void);
+   protected:
+      static void foomem();
+   public:
+      foo();
+      ~foo();
+};
+
+void freefoo(void)
+{
+   foo::foomem();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/groff1.C b/gcc/testsuite/g++.old-deja/g++.jason/groff1.C
new file mode 100644
index 00000000000..7ce697b0d77
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/groff1.C
@@ -0,0 +1,40 @@
+// PRMS Id: 3744
+// Bug: unswitching a COND_EXPR initializer fails to set SIDE_EFFECTS on the
+// result, so expand_expr ignores it.
+
+extern "C" {
+  int printf(const char *,...);
+  void exit(int);
+}
+
+struct A {
+  int x;
+  int y;
+
+  A() : x(0), y(0) { }
+};
+
+struct S {
+  S() : flags(0) { }
+  unsigned flags;
+  A from;
+  void foo(const A &pos);
+};
+
+void S::foo(const A &pos)
+{
+  A a = flags ? from : pos;
+  printf("%d %d\n", a.x, a.y);
+  if (a.x != 17 || a.y != 12)
+    exit (1);
+}
+
+int main()
+{
+  A pos;
+  pos.x = 17;
+  pos.y = 12;
+  S s;
+  s.foo(pos);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/hmc1.C b/gcc/testsuite/g++.old-deja/g++.jason/hmc1.C
new file mode 100644
index 00000000000..fec94879950
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/hmc1.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed templates default-arguments
+template <class I>
+class Class {
+public:
+  void func1(int n=1);
+  void func2(int d) {}
+};
+template <class I> 
+void Class<I>::func1(int n) {}
+
+//if this is replaced by:
+//void Class<I>::func1(int n=1) {}
+//the code compiles.
+
+int main() {
+  Class<int> C;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/incomplete1.C b/gcc/testsuite/g++.old-deja/g++.jason/incomplete1.C
new file mode 100644
index 00000000000..8b738d9f606
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/incomplete1.C
@@ -0,0 +1,15 @@
+// The reference parameter to fred isn't dereferenced properly.
+// Build don't link:
+
+class Gump {};
+Gump  operator &  (const Gump x){return x;}
+
+class B;
+
+void *sam(int &x)
+{return &x;}
+
+const void *fred(const B& x)
+{return &x;}  // "&x" causes the compilation error.
+
+class B {};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/incomplete2.C b/gcc/testsuite/g++.old-deja/g++.jason/incomplete2.C
new file mode 100644
index 00000000000..66423215a92
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/incomplete2.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+struct A {
+  int foo(A a) { return a.bar(); }
+  int bar();
+  int n;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/init.C b/gcc/testsuite/g++.old-deja/g++.jason/init.C
new file mode 100644
index 00000000000..032d172e160
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/init.C
@@ -0,0 +1,7 @@
+// Bug: g++ uses an empty initializer list for its own devious purpose
+// internally, and gets confused if it shows up in the input.
+// Build don't link:
+
+struct A { int i; };
+
+A a = { };
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/init2.C b/gcc/testsuite/g++.old-deja/g++.jason/init2.C
new file mode 100644
index 00000000000..c85adc385ce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/init2.C
@@ -0,0 +1,9 @@
+// PRMS Id: 5126
+
+extern int i, j;
+static const int foo [] = { i, j };
+int i = 5, j = 42;
+int main()
+{
+  return foo[1] != 42;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/init3.C b/gcc/testsuite/g++.old-deja/g++.jason/init3.C
new file mode 100644
index 00000000000..ae8693195ca
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/init3.C
@@ -0,0 +1,42 @@
+// PRMS Id: 5652
+// Bug: strings does not get initialized.
+
+extern "C" void * memcpy (void *, const void *, __SIZE_TYPE__);
+extern "C" int strcmp (const char *, const char *);
+
+class My_string {
+   char *str;
+   int len;
+public:
+   My_string(const char* string);
+   My_string(const My_string &);
+   ~My_string() { delete str; }
+   char* char_p() { return str; }
+};
+
+const My_string strings[4] = {
+   "first string",
+   "second string",
+   "third string",
+   "fourth string"
+};
+
+My_string::My_string(const char* string)
+{
+   len = strlen(string) + 1;
+   str = new char[len];
+   memcpy(str, string, len);
+}
+
+My_string::My_string(const My_string &string)
+{
+   len = string.len;
+   str = new char[len];
+   memcpy(str, string.str, len);
+}
+
+int main()
+{
+   My_string str1 = strings[0];
+   return strcmp ("first string", str1.char_p ()) != 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/init4.C b/gcc/testsuite/g++.old-deja/g++.jason/init4.C
new file mode 100644
index 00000000000..aa9417c642f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/init4.C
@@ -0,0 +1,3 @@
+struct A { int i; };
+
+A a = {{{1}}};			// ERROR - causes abort
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/inline.C b/gcc/testsuite/g++.old-deja/g++.jason/inline.C
new file mode 100644
index 00000000000..d6cb9e9a924
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/inline.C
@@ -0,0 +1,21 @@
+// PRMS Id: 4341
+// Bug: Instantiating a template in the middle of processing the functions
+// from another template screws up lineno/input_filename.
+
+#pragma implementation "C.h"
+#line 1 "A.h"
+#pragma interface
+template <class T> class A {};
+#line 1 "C.h"
+#pragma interface
+template <class T> class C
+{
+public:
+  C() { A<T> *ap; }
+  ~C() { }
+};
+#line 18 "inline.C"
+int main()
+{
+  C<int> c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/inline2.C b/gcc/testsuite/g++.old-deja/g++.jason/inline2.C
new file mode 100644
index 00000000000..7dea476d373
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/inline2.C
@@ -0,0 +1,12 @@
+// Bug: the lang-specific bits of the decl for g aren't being copied when
+// inlining.
+// Special g++ Options: -O
+// Build don't link:
+
+inline void f () {
+  void g ();
+}
+
+void h() {
+  f();				// causes compiler segfault - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/inline3.C b/gcc/testsuite/g++.old-deja/g++.jason/inline3.C
new file mode 100644
index 00000000000..00d57eb3ea1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/inline3.C
@@ -0,0 +1,42 @@
+// Testcase for order of destruction.
+// Special g++ Options: -O2
+
+extern "C" int printf( char const*, ... );
+int c;
+int r;
+
+struct B {
+  B();
+  B( B const& );
+  ~B();
+};
+
+struct A {
+  A();
+  A( A const& );
+  ~A();
+  operator B ();
+};
+
+inline A::operator B () { printf( "operator B ()\n"); return B(); }
+
+A f();
+void g( B const& );
+
+int
+main()
+{
+  g( f() );
+  return r;
+}
+
+B::B() { printf( "B::B()\n" ); if (++c != 2) r = 1; }
+B::B( B const& ) { printf( "B::B( B const& )\n" ); r = 1; }
+B::~B() { printf( "B::~B()\n" ); if (--c != 1) r = 1; }
+
+A::A() { printf( "A::A()\n" ); if (++c != 1) r = 1; }
+A::A( A const& ) { printf( "A::A( A const& )\n" ); r = 1; }
+A::~A() { printf( "A::~A()\n" ); if (--c != 0) r = 1; }
+
+A f() { printf( "f()\n"); return A(); }
+void g( B const& ) { printf( "g()\n"); }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/jump.C b/gcc/testsuite/g++.old-deja/g++.jason/jump.C
new file mode 100644
index 00000000000..e59de36fa41
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/jump.C
@@ -0,0 +1,14 @@
+// PRMS Id: 6036
+
+extern int a;
+
+int main() {
+  switch (a) {
+  case 1:
+    int v2 = 3;			// ERROR - referenced below
+  case 2:			// ERROR - jumping past initializer
+    if (v2 == 7)
+      ;
+  }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lex1.C b/gcc/testsuite/g++.old-deja/g++.jason/lex1.C
new file mode 100644
index 00000000000..174ec77b97f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lex1.C
@@ -0,0 +1,6 @@
+int main()
+{
+  char c = '\351';
+  if (c != '\351')
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lineno.C b/gcc/testsuite/g++.old-deja/g++.jason/lineno.C
new file mode 100644
index 00000000000..6878f75b61a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lineno.C
@@ -0,0 +1,6 @@
+// Bug; g++ binds a function definition to the line number of a later decl.
+// Build don't link:
+
+void foo () { }			// ERROR - redeclared
+void foo ();			// gets bogus error - invalid binding
+void foo () { }			// ERROR - redeclared
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lineno2.C b/gcc/testsuite/g++.old-deja/g++.jason/lineno2.C
new file mode 100644
index 00000000000..6c278036b9a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lineno2.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed error-reporting
+// Special g++ Options: 
+// Bug: # line directive gets ignored immediately after text.
+template <class T> class A
+{
+public:
+# 200 "lineno2.C"
+};
+
+main()
+{
+   undef1(); // ERROR - , LINE 204
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lineno3.C b/gcc/testsuite/g++.old-deja/g++.jason/lineno3.C
new file mode 100644
index 00000000000..f2688635437
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lineno3.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// Special g++ Options: 
+// GROUPS passed error-reporting
+// potential bug: # line directive does not get reproduced in template
+// expansion
+template <class T> class A
+{
+public:
+# 200 "lineno3.C"
+      int foo () { undef1(); } // ERROR - , LINE 200
+};
+
+template class A<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lineno4.C b/gcc/testsuite/g++.old-deja/g++.jason/lineno4.C
new file mode 100644
index 00000000000..a570edf313c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lineno4.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// Special g++ Options: 
+// GROUPS passed error-reporting
+// Bug: # line directive in template definition interferes with growing obstack
+template <class T> class A
+{
+public:
+
+# 200 "lineno4.C"
+      int foo () { undef1(); } // ERROR - , LINE 200
+};
+
+template class A<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lineno5.C b/gcc/testsuite/g++.old-deja/g++.jason/lineno5.C
new file mode 100644
index 00000000000..95ff218cbb2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lineno5.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed error-reporting
+// Bug: incomplete instantiation messes with lineno
+template <class T> class A;
+
+int main()
+{
+  A<int> *p;
+  undef1();// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/local.C b/gcc/testsuite/g++.old-deja/g++.jason/local.C
new file mode 100644
index 00000000000..6159db0c613
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/local.C
@@ -0,0 +1,20 @@
+// General testcase for local classes.
+
+int x;
+void f ()
+{
+  static int s;
+  int x;			// ERROR - referenced below
+  extern int q();
+
+  struct local {
+    int g() { return x; }	// ERROR - automatic variable
+    int h() { return s; }	// gets bogus error - local class
+    int k() { return ::x; }	// OK
+    int l() { return q(); }	// OK
+    int m();			// OK - not defined
+    static int foo;		// ERROR - static data member of local class
+  };
+}
+
+local* p = 0;			// ERROR - no such type in scope
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lookup.C b/gcc/testsuite/g++.old-deja/g++.jason/lookup.C
new file mode 100644
index 00000000000..c6c44c373d9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lookup.C
@@ -0,0 +1,30 @@
+// PRMS Id: 4357
+// Bug: g++ forgets to clear out push/popclass cache stuff when instantiating
+// templates.
+// Build don't link:
+
+template <class T> class ccHandle { };
+
+class cc_GStack
+{
+  static cc_GStack* freeList;
+};
+
+// OK if ccGStack is not derived from ccHandle<something>
+class ccGStack : public ccHandle<int> { };
+
+struct S { };
+
+S* freeList;	  
+
+class X
+{
+public:
+    void foo();
+};
+
+void X::foo()
+{
+  S m;
+  freeList = &m;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lookup2.C b/gcc/testsuite/g++.old-deja/g++.jason/lookup2.C
new file mode 100644
index 00000000000..e44b1dcb057
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lookup2.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+struct A {
+  struct B {
+    B ();
+  };
+};
+void f (A::B);
+void g ()
+{
+  A::B b;
+  f (b);	  // gets bogus error - can't find nested constructor
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lookup3.C b/gcc/testsuite/g++.old-deja/g++.jason/lookup3.C
new file mode 100644
index 00000000000..7be731ef0f5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lookup3.C
@@ -0,0 +1,15 @@
+// [class.ambig]: A single function, object, type, or enumerator may be
+// reached through more than one path through the DAG of base classes.  This
+// is not an ambiguity.
+// Build don't link:
+
+struct A  {
+  typedef long T;
+};
+
+struct B : public A { };
+struct C : public A { };
+
+struct D : public C , public B {
+  void f (T&);			// gets bogus error - ambiguous lookup
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/loverload.C b/gcc/testsuite/g++.old-deja/g++.jason/loverload.C
new file mode 100644
index 00000000000..2d1a9b36ae6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/loverload.C
@@ -0,0 +1,11 @@
+// Bug: g++ can't deal with multi-language overloading.
+// Build don't link:
+
+extern void foo (int, int);
+extern "C" void foo (int);
+
+void bar ()
+{
+  foo (1);
+  foo (1, 2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/loverload3.C b/gcc/testsuite/g++.old-deja/g++.jason/loverload3.C
new file mode 100644
index 00000000000..c9cc3bfbe57
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/loverload3.C
@@ -0,0 +1,12 @@
+// PRMS Id: 2010
+// Bug: g++ doesn't deal with overloads involving C-language fns properly.
+// Build don't link:
+
+extern "C" double pow (double, double);
+inline double pow (double d, int e) { return pow (d, (double) e); }
+
+void foo () 
+{
+  pow (1.0, 1);
+  pow (1.0, 1.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/loverload4.C b/gcc/testsuite/g++.old-deja/g++.jason/loverload4.C
new file mode 100644
index 00000000000..c689bf5169d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/loverload4.C
@@ -0,0 +1,8 @@
+// Bug: g++ dies on this input.
+// Build don't link:
+
+inline char abs (char x) { return 0; }
+
+extern "C" {
+  inline int abs (int x) { return 1; }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lvalue.C b/gcc/testsuite/g++.old-deja/g++.jason/lvalue.C
new file mode 100644
index 00000000000..c85e6fe5f28
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lvalue.C
@@ -0,0 +1,22 @@
+// Bug: Scoped method calls don't propagate the constness of `this'.
+// PRMS Id: 4181 (second testcase)
+// Build don't link:
+
+class D;
+
+class Bptr
+{
+public:
+  Bptr& operator=(D*);                          
+  const Bptr& operator=(const D*) const;        
+};
+
+class Dptr : public Bptr
+{
+public:
+  const Dptr& operator=(const D* rep) const 
+  {
+    Bptr::operator=(rep);
+    return *this;
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lvalue2.C b/gcc/testsuite/g++.old-deja/g++.jason/lvalue2.C
new file mode 100644
index 00000000000..2fba73c9c87
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lvalue2.C
@@ -0,0 +1,20 @@
+// PRMS Id: 4892
+// Bug: COND_EXPRs, MODIFY_EXPRs and COMPOUND_EXPRs aren't properly recognized
+// as lvalues.
+// Build don't link:
+
+extern int foo;
+int& f (int& a, int& b)
+{
+  return (foo ? a : b);		// gets bogus error - 
+}
+
+int& g (int& a)
+{
+  return (a = 0);		// gets bogus error - 
+}
+
+int& h (int& a, int& b)
+{
+  return (a = 1, b);		// gets bogus error - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lvalue3.C b/gcc/testsuite/g++.old-deja/g++.jason/lvalue3.C
new file mode 100644
index 00000000000..a3edaac6557
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lvalue3.C
@@ -0,0 +1,9 @@
+// Bug: C++ semantics for assignment don't match the backend semantics for
+// MODIFY_EXPR.
+// Build don't link:
+
+void
+foo (int j)
+{
+  (j = 1)++;			// causes compiler segfault
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/lvalue4.C b/gcc/testsuite/g++.old-deja/g++.jason/lvalue4.C
new file mode 100644
index 00000000000..79a02d8a5c0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/lvalue4.C
@@ -0,0 +1,6 @@
+int main() {
+  int i = 2;
+  int *pi = &(++i);
+
+  return i != 3;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/mangle1.C b/gcc/testsuite/g++.old-deja/g++.jason/mangle1.C
new file mode 100644
index 00000000000..59b83b9c361
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/mangle1.C
@@ -0,0 +1,23 @@
+// Bug: numeric_outputed_need_bar is not cleared properly, adding random '_'s
+// to mangled names.
+
+// Build don't link:
+
+template <int seed_length>
+class rand1
+{
+public:
+    rand1 ();
+};
+
+class codes
+{
+public:
+    rand1<32> * randgen;
+    codes (int ptr);
+
+};
+
+codes::codes (int ptr)
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/mangle2.C b/gcc/testsuite/g++.old-deja/g++.jason/mangle2.C
new file mode 100644
index 00000000000..b1876b71249
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/mangle2.C
@@ -0,0 +1,23 @@
+// I guess this was broken once.
+// Build don't link:
+
+template <class C, int D> class X { };
+typedef X<int, 0> T;
+
+class Y
+{
+  public:
+    ~Y();
+};
+
+class Z
+{
+  public:
+    void f(T**);
+};
+
+void Z::f(T** t)
+{ }
+
+Y::~Y()
+{ }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/mangle3.C b/gcc/testsuite/g++.old-deja/g++.jason/mangle3.C
new file mode 100644
index 00000000000..5a82107bfef
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/mangle3.C
@@ -0,0 +1,19 @@
+// PRMS Id: 7563
+// Bug: declaration at function scope causes mismangling.
+
+int main()
+{
+  char ArrA[10][10][20][30],
+       ArrB[10][10][20][30];
+
+  void HitMe(char [10][10][20][30], char [10][10][20][30]);
+
+  HitMe(ArrA, ArrB);
+
+  return 0;
+}
+
+void HitMe(char A[10][10][20][30], char B[10][10][20][30])
+{
+  return;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/member.C b/gcc/testsuite/g++.old-deja/g++.jason/member.C
new file mode 100644
index 00000000000..3518811967c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/member.C
@@ -0,0 +1,35 @@
+// Build don't link: 
+// GROUPS passed member-pointers error-reporting
+struct Y
+{
+  struct X
+    {
+      int A;
+      int Y::X::* foo () { undef1(1); return &Y::X::A; }// ERROR - foo().*
+      int bar () { return A; }
+    };
+};
+
+int Y::X::* foo ()
+{
+  undef2(1);// ERROR - foo().*
+  return &Y::X::A;
+}
+
+int Y::X::* (* foo2 ())()
+{
+  undef3(1);// ERROR - foo().*
+  return foo;
+}
+
+int (Y::X::* bar2 ()) ()
+{
+  undef4(1);// ERROR - foo\(\).*
+  return Y::X::bar;// ERROR - foo\(\).*
+}
+
+int Y::X::* (Y::X::* foo3 ())()
+{
+  undef5(1);// ERROR - foo().*
+  return Y::X::foo;// ERROR - foo().*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/method.C b/gcc/testsuite/g++.old-deja/g++.jason/method.C
new file mode 100644
index 00000000000..e9496b82861
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/method.C
@@ -0,0 +1,12 @@
+// Bug: pointer to pointer is treated as plain pointer.
+// PRMS Id: 1767
+// Build don't link:
+
+class Foo {
+public:
+	void method();
+};
+
+void func(Foo ** ppFoo) {
+	ppFoo->method();	// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/mi.C b/gcc/testsuite/g++.old-deja/g++.jason/mi.C
new file mode 100644
index 00000000000..de805dd4f1c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/mi.C
@@ -0,0 +1,16 @@
+int status;
+
+struct A { virtual void foo () { status = 1; } };
+struct B { };
+struct C : public A, public B { };
+struct D { virtual void baz () { } };
+struct E : public D, public C { void foo () { status = 0; } };
+
+int main ()
+{
+  E* ep = new E;
+
+  ep->foo();
+
+  return status;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/mutable1.C b/gcc/testsuite/g++.old-deja/g++.jason/mutable1.C
new file mode 100644
index 00000000000..5311a871be2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/mutable1.C
@@ -0,0 +1,11 @@
+struct X
+{
+  X () { }
+  mutable int x;
+};
+
+int main ()
+{
+  const X x;
+  x.x = 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/nested1.C b/gcc/testsuite/g++.old-deja/g++.jason/nested1.C
new file mode 100644
index 00000000000..4405f3d0649
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/nested1.C
@@ -0,0 +1,12 @@
+// Bug: g++ can't deal with function-local classes that talk about themselves.
+// Build don't link:
+
+void foo() {
+  class Wrapper {
+  public:
+    void F (void * Wrapperptr)
+    {
+      Wrapper * wrapptr = (  Wrapper  *) Wrapperptr; // gets bogus error 
+    }
+  };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/nested2.C b/gcc/testsuite/g++.old-deja/g++.jason/nested2.C
new file mode 100644
index 00000000000..24020a2dd24
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/nested2.C
@@ -0,0 +1,26 @@
+// PRMS Id: 3764 (c/h)
+// Bug: g++ gets into an infinite loop trying to find the top-level context
+// Build don't link:
+
+class Menu;
+class MenuItem;
+
+class MenuAction {
+public:
+  virtual void execute (Menu& menu, MenuItem& menuItem) = 0;
+protected:
+  MenuAction () {}
+}; 
+
+class Test {
+  class MenuCBA : public MenuAction {
+  public:
+    typedef void (Test::* MenuCBA_Member) (Menu& menu, MenuItem& menuItem);
+    MenuCBA (Test& instance, MenuCBA_Member member)
+      : _instance(&instance), _member(member) {	}
+    void execute (Menu& menu, MenuItem& menuItem);
+  private:
+    MenuCBA_Member _member;
+    Test* _instance;
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/nested4.C b/gcc/testsuite/g++.old-deja/g++.jason/nested4.C
new file mode 100644
index 00000000000..cd5a8393eb0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/nested4.C
@@ -0,0 +1,17 @@
+// From: quipu@ulrik.uio.no
+// Subject: extern "C" nested class
+// Date: Fri, 13 Aug 1993 15:33:53 +0200
+// Build don't link:
+
+extern "C" {
+  struct A {
+    struct B { int j; } *x;
+  };
+}
+
+void
+foo () {
+  A a;
+  struct A::B *b;
+  b = a.x;	// gets bogus error - type `B' is not a base type for type `B'
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/nested5.C b/gcc/testsuite/g++.old-deja/g++.jason/nested5.C
new file mode 100644
index 00000000000..1b0e35c9b91
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/nested5.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+struct A {
+  struct B { };
+};
+
+struct C : public A {
+  struct D
+    : public B			// gets bogus error - can't find B
+    { };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/nested6.C b/gcc/testsuite/g++.old-deja/g++.jason/nested6.C
new file mode 100644
index 00000000000..b98c643d3fb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/nested6.C
@@ -0,0 +1,5 @@
+// Build don't link:
+union A {
+ struct B { };
+ A::B b;			// gets bogus error
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/nested7.C b/gcc/testsuite/g++.old-deja/g++.jason/nested7.C
new file mode 100644
index 00000000000..43cce238546
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/nested7.C
@@ -0,0 +1,16 @@
+// Testcase for defining nested types separately.
+// Build don't link:
+
+class remote
+{
+  class remote_file;
+};
+
+class remote::remote_file
+{
+public:
+  ~remote_file();
+};
+
+remote::remote_file::~remote_file()
+{}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/nested8.C b/gcc/testsuite/g++.old-deja/g++.jason/nested8.C
new file mode 100644
index 00000000000..ff2d659a3fc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/nested8.C
@@ -0,0 +1,8 @@
+// Build don't link:
+
+struct A { };
+struct B: public A {
+  struct C {
+friend struct B;		// gets bogus error - base clause w/o members
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/net.C b/gcc/testsuite/g++.old-deja/g++.jason/net.C
new file mode 100644
index 00000000000..be8b962ad80
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/net.C
@@ -0,0 +1,10 @@
+// Bug: g++ doesn't instantiate function templates in instantiate_type.
+// Build don't link:
+
+template <class T> void fn (T t) { }
+template <class T> struct A {
+  void (*p)(T);
+  A() { p = fn; }
+};
+
+A<int> a;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/net2.C b/gcc/testsuite/g++.old-deja/g++.jason/net2.C
new file mode 100644
index 00000000000..8738eade438
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/net2.C
@@ -0,0 +1,37 @@
+// Test of various ?: problems.
+
+class D
+{
+public:
+  void a();
+  void b();
+  D(int i):x(i) {}
+private:
+  int x;
+};
+
+void D::a() {++x;}
+void D::b() {--x;}
+
+  
+int aa=1, bb=0;
+
+int fa() {return 0;}
+int fb() {return 2;}
+
+int main(int argc, char* argv[])
+{
+  typedef int* pi;
+  int* p = (argc == 1)? &aa: &bb;
+  *p = 0;
+
+  typedef int (*ifptr)();
+  ifptr fp = (argc == 1)? fa: fb;
+  aa = fp();
+  
+  D d(0);
+  typedef void (D::*dmem)();
+  dmem mfp = (argc == 1)? &D::a: &D::b;
+  (d.*mfp)();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/new.C b/gcc/testsuite/g++.old-deja/g++.jason/new.C
new file mode 100644
index 00000000000..ce865696078
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/new.C
@@ -0,0 +1,25 @@
+// Bug: new doesn't make sure that the count is an integral value.
+
+#include <new>
+extern "C" int printf (const char *, ...);
+extern "C" void *malloc (size_t);
+size_t s;
+
+void * operator new (size_t siz) throw (std::bad_alloc) {
+  if (s == 0)
+    s = siz;
+  else
+    s = (s != siz);
+  return malloc (siz);
+}
+
+int main()
+{
+  s = 0;
+
+  float f = 3;
+  int* b1 = new int[(int)f];
+  int* b2 = new int[f];		// ERROR - new requires integral size
+
+  return s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/new2.C b/gcc/testsuite/g++.old-deja/g++.jason/new2.C
new file mode 100644
index 00000000000..ed4f68d9f31
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/new2.C
@@ -0,0 +1,12 @@
+// PRMS Id: 6267
+// Special g++ Options: -Wno-deprecated -fthis-is-variable -fno-exceptions
+
+struct A {
+  int i;
+  A() { i = 2; }
+};
+ 
+main()
+{
+  A *p = new A ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/new3.C b/gcc/testsuite/g++.old-deja/g++.jason/new3.C
new file mode 100644
index 00000000000..9bf944c8c08
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/new3.C
@@ -0,0 +1,37 @@
+// PRMS Id: 6037
+// Special g++ Options: -fcheck-new -pedantic
+
+extern "C" void * malloc (__SIZE_TYPE__);
+
+int ena = 0;
+
+struct A {
+  int i;
+  A () { i = 2; }
+  void * operator new (__SIZE_TYPE__ s)
+  {
+    if (ena)
+      return 0; // WARNING - returning NULL
+    return malloc (s);
+  }
+};
+
+struct B {
+  int i;
+  B () { i = 2; }
+  void * operator new (__SIZE_TYPE__ s) throw()
+  {
+    if (ena)
+      return 0;
+    return malloc (s);
+  }
+};
+
+int main ()
+{
+  ena = 1;
+  A *ap = new A;
+  B *bp = new B;
+  
+  return ap || bp ;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/new4.C b/gcc/testsuite/g++.old-deja/g++.jason/new4.C
new file mode 100644
index 00000000000..ba8af272cb5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/new4.C
@@ -0,0 +1,22 @@
+// Special g++ Options: -fcheck-new
+
+struct A {
+  A(): i(42) { }
+  A(int j): i(j) { }
+  int i;
+};
+
+A* ap = new A (1);
+A* ap2 = new A[3];
+
+main ()
+{
+  if (ap->i != 1 || ap2[0].i != 42 || ap2[1].i != 42 || ap2[2].i != 42)
+    return 1;
+
+  A* ap = new A (1);
+  A* ap2 = new A[3];
+
+  if (ap->i != 1 || ap2[0].i != 42 || ap2[1].i != 42 || ap2[2].i != 42)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/new5.C b/gcc/testsuite/g++.old-deja/g++.jason/new5.C
new file mode 100644
index 00000000000..87279fd7009
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/new5.C
@@ -0,0 +1,5 @@
+int main ()
+{
+  const int *p = new const int (0);
+  delete p;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/offset1.C b/gcc/testsuite/g++.old-deja/g++.jason/offset1.C
new file mode 100644
index 00000000000..d4fd38b70dc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/offset1.C
@@ -0,0 +1,17 @@
+// PRMS Id: 5070 (testcase 1)
+// Build don't link:
+
+struct foo {
+  foo(int x = 0) {};
+  int IsAlive(void) { return 1; }
+};
+
+struct xx {
+  int IsOk(int X);
+  foo a;
+};
+
+int xx::IsOk(int X)
+{
+  return ((xx::a).IsAlive());	// gets bogus error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/offset2.C b/gcc/testsuite/g++.old-deja/g++.jason/offset2.C
new file mode 100644
index 00000000000..a598d433431
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/offset2.C
@@ -0,0 +1,23 @@
+// PRMS Id: 5070 (testcase 2)
+
+int status = 1;
+
+struct foo {
+  foo& operator= (const foo&) { status = 0; }
+};
+
+struct xx {
+  foo a;
+};
+
+struct yy : public xx {
+  yy(foo& a) { xx::a = a; }
+};
+
+int main()
+{
+  foo f;
+  yy y (f);
+
+  return status;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/offset3.C b/gcc/testsuite/g++.old-deja/g++.jason/offset3.C
new file mode 100644
index 00000000000..d980ba1fcd0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/offset3.C
@@ -0,0 +1,22 @@
+// PRMS Id: 5070 (bug 2)
+// Build don't link:
+
+struct A {
+  void f ();
+};
+
+struct Ptr {
+  A* operator->();
+};
+
+struct B {
+  Ptr p;
+};
+
+struct C: public B {
+  void g ();
+};
+
+void C::g() {
+  B::p->f();			// gets bogus error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/offset4.C b/gcc/testsuite/g++.old-deja/g++.jason/offset4.C
new file mode 100644
index 00000000000..2a5049105a4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/offset4.C
@@ -0,0 +1,15 @@
+// Bug: g++ complains about the use of A::p below.
+// Build don't link:
+
+struct A {
+  void *p;
+};
+
+struct B: public A {
+  int f ()
+    {
+      if (A::p)
+	return 1;
+      return 0;
+    }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/opeq.C b/gcc/testsuite/g++.old-deja/g++.jason/opeq.C
new file mode 100644
index 00000000000..ac099a4a667
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/opeq.C
@@ -0,0 +1,39 @@
+// PRMS Id: 4297 (related to 3525)
+// Bug: Generating default op= didn't set TYPE_HAS_ASSIGNMENT, so it wasn't
+// found.
+
+extern "C" int printf (char *, ...);
+
+class Y 
+{
+public:
+    Y(char*) {}
+    Y& operator = (const Y&) {}
+};
+    
+
+class X
+{
+public:
+    X(int v, char* m) : _v(v), _m (m) {}
+    X () : _v(0), _m("Unknown") {}
+    // Defining our own op= here makes things work correctly.
+
+private:
+    int _v;
+    int _m4;
+    // Adding more members here increases the count on u.
+    Y _m;
+};
+
+const X sPassed (1, "Passed"), sFailed (-1, "Failed");
+
+int main (int, char**)
+{
+    X result;
+    int u = 0;
+    result = (u++ ? sPassed : sFailed);
+    if (u == 1)
+      return 0;
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/opeq2.C b/gcc/testsuite/g++.old-deja/g++.jason/opeq2.C
new file mode 100644
index 00000000000..9e91ab3ae0f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/opeq2.C
@@ -0,0 +1,26 @@
+// Bug: default operator= is not being generated properly.
+// PRMS Id: 3525
+// Build don't link:
+
+struct ccUnwind 
+{
+    ccUnwind& operator = (const ccUnwind&);
+};
+
+struct ccEllipseUnit
+{ 
+    ccEllipseUnit () {}
+};
+
+struct ccEllipse : ccUnwind  
+{   
+    ccEllipse ();
+    ccEllipse (const ccEllipseUnit&);
+
+};
+
+void foo ()
+{
+    ccEllipse e;
+    e = ccEllipseUnit();	// gets bogus error - assignment not defined
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/opeq3.C b/gcc/testsuite/g++.old-deja/g++.jason/opeq3.C
new file mode 100644
index 00000000000..e290f7a21ba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/opeq3.C
@@ -0,0 +1,15 @@
+// Bug: g++ generates code for assignment in invalid situations.
+// Build don't link:
+
+class X {
+  int& a;
+public:
+  X(int& i): a(i) { };
+};
+
+void foo ()
+{
+  int one=1, two=2;
+  X a(one), b(two);
+  a = b;			// ERROR - no assignment semantics defined
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/opeq4.C b/gcc/testsuite/g++.old-deja/g++.jason/opeq4.C
new file mode 100644
index 00000000000..d993d83ab9d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/opeq4.C
@@ -0,0 +1,8 @@
+// PRMS Id: 4329
+// Bug: default op= gives an warning about casting away volatile.
+// Build don't link:
+
+struct foo
+{
+    volatile int bar[2];
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/opeq5.C b/gcc/testsuite/g++.old-deja/g++.jason/opeq5.C
new file mode 100644
index 00000000000..90996e96998
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/opeq5.C
@@ -0,0 +1,26 @@
+// Testcase for tricky synthesized op= in complex inheritance situation.
+// This used to test whether the virtual base was copy-assigned only once.
+// That feature is not required by ISO C++, so the test now only checks
+// whether the vbase is assigned at all.
+
+int count = 0;
+extern "C" int printf (const char *, ...);
+
+class A {
+ public:
+  A& operator = (const A&) { count++; return *this; }
+};
+
+class B: virtual private A { };
+class C: virtual public A { };
+class D: public B, public C { };
+
+int main()
+{
+  D a, b;
+  a = b;
+  printf ("%d\n",count);
+  if (count == 0)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/opeq6.C b/gcc/testsuite/g++.old-deja/g++.jason/opeq6.C
new file mode 100644
index 00000000000..62be499c56d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/opeq6.C
@@ -0,0 +1,24 @@
+// Testcase for wrongful generation of operator =.
+// Build don't link:
+
+class ivResource {
+public:
+  ivResource ();
+private:
+  ivResource & operator =(const ivResource &);
+};
+
+class ivButtonState : virtual public ivResource {
+public:
+  void operator=(ivButtonState &);
+};
+
+class ivPrintBS : public ivButtonState {
+};
+
+void f ()
+{
+  ivPrintBS a, b;
+  a = b;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/operator.C b/gcc/testsuite/g++.old-deja/g++.jason/operator.C
new file mode 100644
index 00000000000..bd21e378e14
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/operator.C
@@ -0,0 +1,31 @@
+// General test for operator overloading permissiveness.
+// Build don't link:
+// Special g++ Options:
+
+typedef __SIZE_TYPE__ size_t;
+
+struct A {
+  int operator?:(int a, int b);	   // WARNING - 
+  static int operator()(int a);	   // ERROR - must be nonstatic
+  static int operator+(A,A);	   // ERROR - must be nonstatic
+  int operator+(int a, int b = 1); // ERROR - two errors on this line
+  int operator++(char);		   // ERROR - must take 'int'
+  void operator delete (void *);   
+  void operator delete (void *, unsigned long);	
+};
+
+struct B {
+  void * operator new (size_t, void *);
+  int operator++(int = 0);
+  int operator+ (int);
+  void operator()();
+  char * operator[](int);
+  B * operator->();
+};
+
+int operator-(int a, int b);	// ERROR - no class argument
+
+void * operator new (A a);	// ERROR - invalid first argument
+void operator delete (A a);	// ERROR - ditto
+
+char * operator char * (int);	// ERROR - return value, nonmember
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/operator2.C b/gcc/testsuite/g++.old-deja/g++.jason/operator2.C
new file mode 100644
index 00000000000..477616086a2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/operator2.C
@@ -0,0 +1,14 @@
+// PRMS Id: 6018
+// Build don't link:
+
+class string {
+    char *p;
+public:
+    string(const char* s) ;// { p == s; }
+    operator const char*() ;// { return s; }
+};
+ 
+void f4(string& s)
+{
+        *s;     // implies "s.operator const char*()"
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/opover.C b/gcc/testsuite/g++.old-deja/g++.jason/opover.C
new file mode 100644
index 00000000000..f4a3213f0d3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/opover.C
@@ -0,0 +1,15 @@
+// Bug: g++ prefers a non-matching operator== over user-defined conversions
+// and a default operator==.
+// Build don't link:
+
+struct A {
+  operator int ();
+};
+
+struct B {
+  friend int operator== (B, int);
+};
+
+int foo (A& a) {
+  return a == 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/optimize.C b/gcc/testsuite/g++.old-deja/g++.jason/optimize.C
new file mode 100644
index 00000000000..1f554e21935
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/optimize.C
@@ -0,0 +1,42 @@
+// Bug: g++ claims that control can fall off the end of these functions.
+// PRMS Id: 4943
+// Special g++ Options: -O -pedantic-errors
+// Build don't link:
+
+struct A {
+  A();
+  A(const A&);
+  A& operator= (const A&);
+  ~A();
+};
+
+int f ()
+{
+  A a[2];
+  return 1;
+}				// gets bogus error - jump_optimize
+
+int g ()
+{
+  A a;
+  return 1;
+}				// gets bogus error - jump_optimize
+
+struct B {
+  B();
+  B(const B&);
+  B& operator= (const B&);
+  ~B();
+};
+
+inline B::~B()
+{
+  int i = 2;
+  while (i--) ;
+}
+
+int h ()
+{
+  B b;
+  return 1;
+}				// gets bogus error - jump_optimize
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/optimize2.C b/gcc/testsuite/g++.old-deja/g++.jason/optimize2.C
new file mode 100644
index 00000000000..0d4e17752c7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/optimize2.C
@@ -0,0 +1,19 @@
+// Used to crash on the alpha with optimization.
+// Special g++ Options: -w
+
+struct Fix {
+  unsigned short l;
+};
+
+static inline void f (int len)
+{
+  if (len > 65535)
+    abort ();
+}
+
+struct Fix a = { 33 };
+
+main()
+{
+  f (a.l);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload.C b/gcc/testsuite/g++.old-deja/g++.jason/overload.C
new file mode 100644
index 00000000000..bc41672c3e5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed overloading
+enum bar {};
+
+void operator+ (int, int);// ERROR - .*
+void operator+ (bar&, int);
+
+template <class T> void operator+ (int b, T& t) { return b; }
+void operator+ (int, bar&);
+
+template <class T> class foo
+{
+public:
+  friend void operator+ <> (int, T&);
+};
+
+class baz;
+
+class foo<int>;
+class foo<baz>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload1.C b/gcc/testsuite/g++.old-deja/g++.jason/overload1.C
new file mode 100644
index 00000000000..e29a7c16b91
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload1.C
@@ -0,0 +1,12 @@
+// Bug: g++ thinks there is a conversion from void * to B *.
+// Build don't link:
+
+struct A {
+  operator void* ();
+};
+
+struct B: public A { };
+
+void bar (A& a) {
+  B* bp = (B*)a;		// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload10.C b/gcc/testsuite/g++.old-deja/g++.jason/overload10.C
new file mode 100644
index 00000000000..cd18382b79f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload10.C
@@ -0,0 +1,22 @@
+// PRMS Id: 4257 (second bug)
+// Bug: g++ fails to recognize multiple previous instantiations of a function
+// template.
+// Build don't link:
+// Special g++ Options: -fguiding-decls
+
+template <class T>
+class A {
+  int i;
+
+  friend int foo (A<T>&);
+};
+
+template <class T> int foo (A<T>& a) { return a.i; }
+
+A<int> a;
+A<char> dummy;
+
+void bar ()
+{
+  foo (a);			// gets bogus error - two foo(A<int>&)'s
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload11.C b/gcc/testsuite/g++.old-deja/g++.jason/overload11.C
new file mode 100644
index 00000000000..f5ed01ef1b4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload11.C
@@ -0,0 +1,17 @@
+// PRMS Id: 4697
+// Bug: g++ calls the non-const method for a const object.
+
+class A {
+public:
+  void foo(int &i) const { i = 0; }
+  void foo(int &i) { i = 1; }
+};
+
+int main()
+{
+  A a;
+  const A& b = a;
+  int i = 2;
+  b.foo (i);
+  return i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload12.C b/gcc/testsuite/g++.old-deja/g++.jason/overload12.C
new file mode 100644
index 00000000000..61d3740ed41
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload12.C
@@ -0,0 +1,15 @@
+// PRMS Id: 4066
+// Bug: g++ doesn't notice the const on reference returns.
+
+struct B {
+  int foo() { return 1; }
+  int foo() const { return 0; }
+};
+
+B b_;
+const B &b () { return b_; }
+
+int main()
+{
+  return b().foo();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload13.C b/gcc/testsuite/g++.old-deja/g++.jason/overload13.C
new file mode 100644
index 00000000000..6b5ca0fa93d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload13.C
@@ -0,0 +1,27 @@
+// Bug: g++ screws up derived->base conversions when calling a global function
+// in the presence of matching members in the base.  Whew.
+
+struct xios {
+  virtual ~xios() { }
+};
+
+struct xistream: virtual public xios {
+  int j;
+  void operator>>(char&);
+};
+
+struct xfstreambase: virtual public xios { };
+
+struct xifstream: public xfstreambase, public xistream { };
+
+void operator>>(xistream& i, int j)
+{
+  i.j = 0;
+}
+
+int main() {
+  int i;
+  xifstream ifs;
+  
+  ifs >> i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload14.C b/gcc/testsuite/g++.old-deja/g++.jason/overload14.C
new file mode 100644
index 00000000000..6a5d3dc2d5a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload14.C
@@ -0,0 +1,10 @@
+// Bug: g++ fails to recognize that the template matches the target type.
+// Build don't link:
+
+template <class T> void foo (T *, int);
+
+struct A;
+void bar ()
+{
+  void (*p)(A *, int) = &foo;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload15.C b/gcc/testsuite/g++.old-deja/g++.jason/overload15.C
new file mode 100644
index 00000000000..779de722c41
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload15.C
@@ -0,0 +1,10 @@
+// Bug: g++ thinks that int->long is a promotion.
+// Build don't link:
+
+long f (long, long);
+double f (double, double);
+
+void g (double d)
+{
+  f (d, 0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload16.C b/gcc/testsuite/g++.old-deja/g++.jason/overload16.C
new file mode 100644
index 00000000000..34237bc4c67
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload16.C
@@ -0,0 +1,6 @@
+void f (int);			// ERROR - 
+void f (long);			// ERROR - 
+int main()
+{
+  f (1 & 0xffffff00UL);		// ERROR - ambiguous
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload17.C b/gcc/testsuite/g++.old-deja/g++.jason/overload17.C
new file mode 100644
index 00000000000..65738482844
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload17.C
@@ -0,0 +1,20 @@
+// Bug: g++ fails to prefer UDC's alone to UDC's plus standard conversions.
+// Build don't link:
+
+struct B { };
+struct D: public B { };
+struct DP {
+  operator D * () const;
+  operator double () const;
+};
+
+void f (B *);
+void f (D *);
+void g (double);
+void g (float);
+
+void h (DP p)
+{
+  f (p);
+  g (p);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload18.C b/gcc/testsuite/g++.old-deja/g++.jason/overload18.C
new file mode 100644
index 00000000000..d4d9ec14b7e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload18.C
@@ -0,0 +1,6 @@
+// pushdecl gets confused by this.
+// Build don't link:
+
+void f ();
+void f (int, int);
+template <class T> T f (T) { }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload19.C b/gcc/testsuite/g++.old-deja/g++.jason/overload19.C
new file mode 100644
index 00000000000..ad5817565fb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload19.C
@@ -0,0 +1,11 @@
+// PRMS Id: 4689
+// Bug: g++ doesn't notice operators overloaded on enumeral types.
+
+enum E { A=5, B=32, C=100 };
+
+E operator|(E a, E b) { return C; };
+
+int main()
+{
+  return (A|B) != C;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload2.C b/gcc/testsuite/g++.old-deja/g++.jason/overload2.C
new file mode 100644
index 00000000000..56419425383
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload2.C
@@ -0,0 +1,12 @@
+// Bug: foo and bar are considered to be overloaded (i.e. their
+//   IDENTIFIER_GLOBAL_VALUES are TREE_LISTs) even though they aren't,
+//   so ?: thinks it can't resolve the names.
+// Build don't link:
+
+void foo ();
+void bar ();
+
+void baz ()
+{
+  void (*p)() = 1 ? foo : bar;	// gets bogus error - wrongful overloading
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload20.C b/gcc/testsuite/g++.old-deja/g++.jason/overload20.C
new file mode 100644
index 00000000000..998f6a7466c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload20.C
@@ -0,0 +1,11 @@
+// Bug: this code causes an internal compiler error 4.
+
+void f (char *);
+void f (int);
+struct A {
+  void f ();			// ERROR - candidate
+  void f (int);			// ERROR - candidate
+  void g () {
+    void (*p)(char *) = f;	// ERROR - no matching function in scope
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload21.C b/gcc/testsuite/g++.old-deja/g++.jason/overload21.C
new file mode 100644
index 00000000000..dc2f69ee908
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload21.C
@@ -0,0 +1,12 @@
+struct X {
+  void f (int = 4, char = 'r');	// ERROR - 
+  void g (int = 4, char = 'r');	// ERROR - 
+};
+
+void
+X::f (int i = 4, char x = 'r')
+{ }				// ERROR - duplicate default args
+
+void
+X::g (int i = 9, char x = 's')
+{ }				// ERROR - duplicate default args
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload22.C b/gcc/testsuite/g++.old-deja/g++.jason/overload22.C
new file mode 100644
index 00000000000..fd7276a473b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload22.C
@@ -0,0 +1,17 @@
+// PRMS Id: 4574
+// Bug: g++ prefers int to double for float& argument
+// Build don't link:
+
+inline double abs (double x) { return x;}
+inline int    abs (int i)    { return i; }
+
+float& fn(float& f)
+{
+  return f;
+}
+
+void foo()
+{
+  float f = 23.45;
+  abs(fn(f));			// gets bogus warning
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload23.C b/gcc/testsuite/g++.old-deja/g++.jason/overload23.C
new file mode 100644
index 00000000000..21cda3a14dc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload23.C
@@ -0,0 +1,27 @@
+// From: panisset@cae.ca (Jean-Francois Panisset)
+// Date: Mon, 6 Jun 94 13:39:25 EDT
+// Subject: Problem with operator overloading
+
+// Build don't link:
+
+class ostream {
+public:
+  ostream& operator<<(double n);
+  ostream& operator<<(float n);
+};
+
+class X
+{
+public:
+  operator long() const;
+  operator double() const;
+};
+ostream& operator<< (ostream& os, const X& x);
+
+
+int main()
+{
+  X x;
+  ostream os;
+  os << x; // gets bogus error - converting to float
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload24.C b/gcc/testsuite/g++.old-deja/g++.jason/overload24.C
new file mode 100644
index 00000000000..0a12b001f78
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload24.C
@@ -0,0 +1,23 @@
+// PRMS Id: 5124
+// Bug: g++ promotes bar to int* too soon and the call to f fails.
+// Build don't link:
+
+typedef int arr[1];
+
+struct A {
+   void f(void);
+   void f(arr &);
+
+   void g(void);
+   void g(int *);
+
+   void h(void);
+};
+
+
+void A::h(void)
+{
+   arr bar;
+   f(bar);
+   g(bar);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload26.C b/gcc/testsuite/g++.old-deja/g++.jason/overload26.C
new file mode 100644
index 00000000000..0c15668af6b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload26.C
@@ -0,0 +1,22 @@
+// Bug: g++ tries to build up a mangled name for its ideal match, which
+// fails for one call below.
+// Build don't link:
+
+extern const char foo[];
+extern const char baz[10];
+extern const char *fred;
+
+struct A {
+  void f(const char *);
+} *a;
+
+void bing(const char *);
+int main ()
+{
+	a->f(foo);		// gets bogus error because foo's size unknown.
+	a->f(baz);
+	a->f(fred);
+	bing(fred);
+	bing(foo);
+	bing(baz);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload27.C b/gcc/testsuite/g++.old-deja/g++.jason/overload27.C
new file mode 100644
index 00000000000..123018dd1b5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload27.C
@@ -0,0 +1,7 @@
+void f(const int &) { }
+void f(const float &);
+
+int main()
+{
+    f(false);			// gets bogus error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload28.C b/gcc/testsuite/g++.old-deja/g++.jason/overload28.C
new file mode 100644
index 00000000000..265c523f816
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload28.C
@@ -0,0 +1,11 @@
+// PRMS Id: 6056
+
+struct Foo {
+  Foo()           { }		// ERROR - candidate
+  Foo(int i = 25) { }		// ERROR - candidate
+};
+
+int main()
+{
+  Foo* f1 = new Foo();		// ERROR - ambiguous
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload29.C b/gcc/testsuite/g++.old-deja/g++.jason/overload29.C
new file mode 100644
index 00000000000..ecd43592b08
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload29.C
@@ -0,0 +1,16 @@
+// Bug: we get an error trying to build up our ideal candidate.
+// Build don't link:
+
+class C {
+ public:
+	C( const char * );
+};
+
+	extern	const	char	c1[];
+
+void f2( const char * );
+
+void f1() {
+	C *fntp = new C(c1);			// Line 10
+	f2( c1 );
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload3.C b/gcc/testsuite/g++.old-deja/g++.jason/overload3.C
new file mode 100644
index 00000000000..63b175e70df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload3.C
@@ -0,0 +1,12 @@
+// Bug: bar is considered to be overloaded (i.e. its
+//   IDENTIFIER_GLOBAL_VALUES are TREE_LISTs) even though it isn't,
+//   so default_conversion thinks it can't resolve the name.
+// Build don't link:
+
+void foo ();
+void bar ();
+
+void baz ()
+{
+  void (*p)() = 1 ? (void (*)()) &foo : bar;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload30.C b/gcc/testsuite/g++.old-deja/g++.jason/overload30.C
new file mode 100644
index 00000000000..24485c5851d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload30.C
@@ -0,0 +1,17 @@
+// PRMS Id: 6412
+// Build don't link:
+
+class Foo;
+
+template <class F>
+class Temp
+{
+  F  func_;
+public:
+  Temp (F f) : func_(f) {}
+};
+
+template <class T>
+T* func1 (T* t) { return t; }
+
+Temp<Foo*(*)(Foo*)> temp2(func1);
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload31.C b/gcc/testsuite/g++.old-deja/g++.jason/overload31.C
new file mode 100644
index 00000000000..e45d802033f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload31.C
@@ -0,0 +1,24 @@
+// PRMS Id: 6568
+// Bug: g++ complains about the ambiguous conversion to bool even though
+// we wouldn't end up using it anyway.
+// Build don't link:
+
+class AString
+{
+public:
+    AString (unsigned len);
+    operator char *() const;
+    operator char const *() const;
+};
+
+void
+foo(unsigned t, AString const & handle)
+{
+}
+
+void
+foo(AString const & handle, bool includeSpecials)
+{
+    unsigned t;
+    foo(t, handle);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload32.C b/gcc/testsuite/g++.old-deja/g++.jason/overload32.C
new file mode 100644
index 00000000000..95f251d6664
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload32.C
@@ -0,0 +1,19 @@
+// PRMS Id: 7128
+// Build don't link:
+
+class B {};
+
+class D : public B {};
+
+class X {
+ public:
+   operator const B & () const;
+   operator const D & () const;
+};
+	
+void f( const D & );
+
+void g( const X & x )
+{
+   f( x );
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload33.C b/gcc/testsuite/g++.old-deja/g++.jason/overload33.C
new file mode 100644
index 00000000000..8b5bb4a34ae
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload33.C
@@ -0,0 +1,78 @@
+// PRMS ID: 7507
+// Build don't link:
+
+/* ------------------------------------------------------------ */
+
+class Base0
+{
+public:
+				Base0() {}
+      virtual			~Base0() {}
+};
+
+class Base1
+{
+public:
+				Base1() {}
+    virtual			~Base1() {}
+};
+
+class Derived : public Base0, public Base1
+{
+public:
+				Derived() {}
+  virtual			~Derived() {}
+};
+
+/* ------------------------------------------------------------ */
+
+class Dummy
+{
+  public:
+				Dummy(Base0 * theBase) {}
+				~Dummy() {}
+};
+
+/* ------------------------------------------------------------ */
+
+template<class T>
+class ConstSmartPtr
+{
+  T*			myItem;		// private
+
+  public:	
+			ConstSmartPtr(T const* theItem);
+
+			operator T const*() const
+				{ return myItem; }
+  protected:
+    T*			_item() const
+				{ return myItem; }
+};
+
+template<class T>
+class SmartPtr : public ConstSmartPtr<T>
+{
+  public:
+			SmartPtr(T* theItem)
+			  : ConstSmartPtr<T>(theItem) {}
+
+    T*			item() const
+				{ return _item(); }
+
+			operator T*() const
+				{ return _item(); }
+};
+
+/* ------------------------------------------------------------ */
+
+void
+function()
+{
+  SmartPtr<Derived>  myObj = new Derived();
+
+  Dummy th1(myObj);		    // Doesn't work under Cygnus
+  Dummy th2((Base0 *) myObj);	    // Doesn't work either
+}
+
+/* ------------------------------------------------------------ */
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload34.C b/gcc/testsuite/g++.old-deja/g++.jason/overload34.C
new file mode 100644
index 00000000000..871c35aea93
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload34.C
@@ -0,0 +1,8 @@
+// PRMS ID: 8010
+// Build don't link:
+
+class X {
+  int & flag;
+public:
+  void f(){ flag++ ; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload35.C b/gcc/testsuite/g++.old-deja/g++.jason/overload35.C
new file mode 100644
index 00000000000..bb6e436f2dc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload35.C
@@ -0,0 +1,25 @@
+// PRMS Id: 9647
+// Build don't link:
+
+class castBug
+{
+public:
+   operator int *();
+   operator const int *() const;
+};
+
+class castBug2
+{
+public:
+   operator const int *() const;
+};
+
+void voidfn(void *);
+
+void test()
+{
+   castBug b;
+   castBug2 b2;
+   voidfn(b);			// gets bogus error
+   voidfn(b2);			// ERROR - discarding const
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload36.C b/gcc/testsuite/g++.old-deja/g++.jason/overload36.C
new file mode 100644
index 00000000000..f5e6fb61dc3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload36.C
@@ -0,0 +1,15 @@
+// Test for subsequence checking in overload resolution.
+
+class foo {
+public:
+  void operator <<(char *) { }
+  void operator <<(const char * const &);
+};
+ 
+int
+main()
+{
+  char s[20];
+  foo f;
+  f << s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload4.C b/gcc/testsuite/g++.old-deja/g++.jason/overload4.C
new file mode 100644
index 00000000000..1da0ff0a454
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload4.C
@@ -0,0 +1,11 @@
+// Testcase for simple overloading resolution.
+// Build don't link:
+
+void foo (int);
+void foo (int, int);
+
+void bar ()
+{
+  foo (1);
+  foo (1, 2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload5.C b/gcc/testsuite/g++.old-deja/g++.jason/overload5.C
new file mode 100644
index 00000000000..8702bbb26ea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload5.C
@@ -0,0 +1,4 @@
+// Testcase for simple overloading resolution.
+
+int foo ();			// ERROR - 
+void foo ();			// ERROR - disallowed overload
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload6.C b/gcc/testsuite/g++.old-deja/g++.jason/overload6.C
new file mode 100644
index 00000000000..3ae96428389
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload6.C
@@ -0,0 +1,15 @@
+// Bug: g++ thinks there is a default conversion from void* to B*.
+//      There isn't.
+// Build don't link:
+
+struct A {
+  operator void* ();
+};
+
+struct B { };
+
+void foo (B* bp);
+
+void bar (A& a) {
+  foo (a);			// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload7.C b/gcc/testsuite/g++.old-deja/g++.jason/overload7.C
new file mode 100644
index 00000000000..361150569c9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload7.C
@@ -0,0 +1,15 @@
+// Bug: g++ thinks there is a default conversion from A& to B*.
+//      There isn't.
+// Build don't link:
+
+struct A {
+  operator A* ();
+};
+
+struct B: public A { };
+
+void foo (B* bp);
+
+void bar (A& a) {
+  foo (a);			// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload8.C b/gcc/testsuite/g++.old-deja/g++.jason/overload8.C
new file mode 100644
index 00000000000..9b605f8bce7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload8.C
@@ -0,0 +1,7 @@
+// Bug: g++ fails to catch the ambiguity below.
+// Build don't link:
+
+struct A {
+  operator int () { return 1; };
+  operator int &() { return 1; }; // ERROR - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/overload9.C b/gcc/testsuite/g++.old-deja/g++.jason/overload9.C
new file mode 100644
index 00000000000..5b832fbc5f1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/overload9.C
@@ -0,0 +1,39 @@
+// PRMS Id: 4257
+// Bug: g++ ignores non-member possibilities (ideal_candidate_ansi bug)
+// Build don't link:
+
+class ostream 
+{
+public:
+#ifdef EITHER_ONE_A
+    ostream& operator<<(unsigned long n);
+    ostream& operator<<(long n);
+#else
+    ostream& operator<<(short n);
+    ostream& operator<<(unsigned short n);
+#endif
+};
+
+class ccObjectInfo {};
+
+ostream& operator << (ostream& out, const ccObjectInfo& obj);
+
+class ccString : public ccObjectInfo
+{
+#ifdef EITHER_ONE_B
+    operator int		() const;
+#else
+    operator long   		() const;
+#endif
+};
+
+// Should pick this one!!
+ostream& operator << (ostream& o, const ccString & s);
+
+extern ostream cout;
+
+void f ()
+{
+    ccString foo;
+    cout << foo;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse1.C b/gcc/testsuite/g++.old-deja/g++.jason/parse1.C
new file mode 100644
index 00000000000..a5ba83c78eb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse1.C
@@ -0,0 +1,8 @@
+// Bug: g++ parses the declaration of r as a function declaration.
+// Build don't link:
+
+void foo (int i)
+{
+  int &r (i);
+  r = 1;			// gets bogus error - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse10.C b/gcc/testsuite/g++.old-deja/g++.jason/parse10.C
new file mode 100644
index 00000000000..b67633695c3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse10.C
@@ -0,0 +1,15 @@
+// Testcase for precedence of ?: wrt =
+
+extern "C" int printf (const char *, ...);
+
+int main()
+{
+  int j = 0, k = 0;
+  1 ? j : k = 5;		// should be parsed 1 ? j : (k = 5)
+  (void) (1 ? k = 5 : 0);
+  k = 5 ? 1 : 0;		// should be parsed k = (5 ? 1 : 0)
+
+  printf ("%d %d\n", j, k);
+
+  return j == 5 || k == 5;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse11.C b/gcc/testsuite/g++.old-deja/g++.jason/parse11.C
new file mode 100644
index 00000000000..e9f285cee8d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse11.C
@@ -0,0 +1,9 @@
+// PRMS Id: 6825
+// Build don't link:
+
+class aClass 
+{ 
+  ;
+private: 
+  ;   // This line causes problems 
+}; 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse12.C b/gcc/testsuite/g++.old-deja/g++.jason/parse12.C
new file mode 100644
index 00000000000..eb71775bcf0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse12.C
@@ -0,0 +1,17 @@
+// PRMS Id: 6821
+
+struct A {
+  int operator()(int i) { return i; }
+};
+
+struct B {
+  A* p;
+  int f () { return (*p)(42); }	// gets bogus error
+};
+
+int main ()
+{
+  B b = { new A };
+
+  return b.f () != 42;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse13.C b/gcc/testsuite/g++.old-deja/g++.jason/parse13.C
new file mode 100644
index 00000000000..0ffef983e70
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse13.C
@@ -0,0 +1,8 @@
+// Build don't link:
+
+struct A { 
+  struct B {}; 
+  struct C;
+};
+
+struct A :: C : A :: B {}; // gets bogus error - parse error before `:'
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse14.C b/gcc/testsuite/g++.old-deja/g++.jason/parse14.C
new file mode 100644
index 00000000000..20fcc47dbf8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse14.C
@@ -0,0 +1,12 @@
+// Bug: g++ decides that A::foo is introducing a constructor declarator.
+// Build don't link:
+
+struct A {
+  typedef bool foo;
+};
+
+A::foo (*bar) ();
+
+struct B {
+  A::foo (*bar) ();
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse2.C b/gcc/testsuite/g++.old-deja/g++.jason/parse2.C
new file mode 100644
index 00000000000..71be1f4aa22
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse2.C
@@ -0,0 +1,6 @@
+// Bug: g++ doesn't understand constructor syntax for pointers.
+// Build don't link:
+
+void f () {
+  char * p (0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse3.C b/gcc/testsuite/g++.old-deja/g++.jason/parse3.C
new file mode 100644
index 00000000000..16f99aaa2de
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse3.C
@@ -0,0 +1,6 @@
+// PRMS Id: 4484 (bug 2)
+// Bug: g++ does not grok abstract declarator syntax for method pointers.
+// Build don't link:
+
+template <class T> class A { };
+void (A<int>::*p)() = (void (A<int>::*)())0; // gets bogus error - abstract declarator failure
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse4.C b/gcc/testsuite/g++.old-deja/g++.jason/parse4.C
new file mode 100644
index 00000000000..95e0f441c73
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse4.C
@@ -0,0 +1,7 @@
+// Bug: g++ doesn't handle superfluous parentheses when redeclaring a TYPENAME.
+// Build don't link:
+
+typedef int foo;
+class A {
+    typedef int ((foo));	// gets bogus error - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse5.C b/gcc/testsuite/g++.old-deja/g++.jason/parse5.C
new file mode 100644
index 00000000000..519deb2867a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse5.C
@@ -0,0 +1,12 @@
+// Bug: foo (bar) should be a declaration of a static data member, not a
+// function; it's getting caught by the rules for constructors.
+// Build don't link:
+
+typedef int foo;
+typedef int bar;
+struct A {
+  static foo (bar);		// gets bogus error
+};
+
+int i = A::bar;			// gets bogus error
+int (*fp)(bar) = A::foo;	// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse6.C b/gcc/testsuite/g++.old-deja/g++.jason/parse6.C
new file mode 100644
index 00000000000..677dbe2cb3f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse6.C
@@ -0,0 +1,9 @@
+// PRMS id: 4653
+// Bug: g++ tries to resolve declarator/expression ambiguities too soon.
+// Build don't link:
+
+template<class T> struct A { };
+
+void f () {
+  void (A<int>::*pmf) ();	// gets bogus error - late binding
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse7.C b/gcc/testsuite/g++.old-deja/g++.jason/parse7.C
new file mode 100644
index 00000000000..bd9744c8315
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse7.C
@@ -0,0 +1,7 @@
+// Bug: g++ tries to parse this as a constructor.
+// Build don't link:
+
+typedef int foo;
+struct A {
+  foo (*bar)();
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse8.C b/gcc/testsuite/g++.old-deja/g++.jason/parse8.C
new file mode 100644
index 00000000000..1ed9de76040
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse8.C
@@ -0,0 +1,2 @@
+// Build don't link:
+void foo(const int* const); // gets bogus error
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/parse9.C b/gcc/testsuite/g++.old-deja/g++.jason/parse9.C
new file mode 100644
index 00000000000..da66fea7887
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/parse9.C
@@ -0,0 +1,18 @@
+// PRMS Id: 5720
+// Bug: the extra set of parens confuses the expr/declarator disambiguation.
+
+class Fu
+{
+  int val;
+public:
+  Fu(int i) : val(i) { };
+  void print() { }
+};
+
+int main(int argc, char * argv[])
+{
+  int * i = &argc;
+
+  Fu((*i)).print();		// gets bogus error
+  Fu((*j));
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmem.C b/gcc/testsuite/g++.old-deja/g++.jason/pmem.C
new file mode 100644
index 00000000000..76e873255ed
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmem.C
@@ -0,0 +1,11 @@
+// Bug: g++ parses the declaration of 'char A::* foo' below as a
+// declaration of 'char A'.
+// Build don't link:
+
+class A { };
+typedef int foo;
+void f ()
+{
+  char A::* foo;
+  foo = 0;			// gets bogus error - parsing blunder
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmem2.C b/gcc/testsuite/g++.old-deja/g++.jason/pmem2.C
new file mode 100644
index 00000000000..99adf1c143f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmem2.C
@@ -0,0 +1,43 @@
+template <class Called>
+class aCallback
+{
+public:
+  aCallback(Called& obj, int (Called::*met)());
+
+  int callback();
+  
+protected:
+
+private:
+  Called&       object;
+  
+  int (Called::*method)();
+  
+};
+
+template <class Called>
+aCallback<Called>::aCallback(Called& obj,
+                             int (Called::*met)()) :
+object(obj),
+method(met)
+{};
+
+template <class Called>
+int aCallback<Called>::callback()
+{
+  return (object.*method)();
+}
+
+struct myStruct
+{
+  int action() {return 0;};
+};
+
+int main()
+{
+  myStruct toto;
+
+  aCallback<myStruct>   cb(toto, &myStruct::action);
+
+  return cb.callback();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmem3.C b/gcc/testsuite/g++.old-deja/g++.jason/pmem3.C
new file mode 100644
index 00000000000..a780c2371d8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmem3.C
@@ -0,0 +1,11 @@
+// Test that comparison of pointers to members does not complain about
+// contravariance violation.
+
+struct A { int i; };
+struct B : public A { int j; int f (); };
+int main ()
+{
+  int A::*apm = &A::i;
+  int B::*bpm = apm;
+  return apm != bpm;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmem4.C b/gcc/testsuite/g++.old-deja/g++.jason/pmem4.C
new file mode 100644
index 00000000000..3ce2bb9fc0b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmem4.C
@@ -0,0 +1,10 @@
+struct X {};
+X& X::*PTM_1;		// ERROR - pointer to reference member
+void X::*PTM_2;		// ERROR - pointer to void member
+
+struct A {
+  static int& ir;
+};
+
+int i;
+int& A::ir = i;			// not an error
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmf.C b/gcc/testsuite/g++.old-deja/g++.jason/pmf.C
new file mode 100644
index 00000000000..677363995b7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmf.C
@@ -0,0 +1,7 @@
+// PRMS Id: 4333
+// Bug: g++ can't deal with casts to pointer to member function.
+// Build don't link:
+
+class A { };
+typedef void (A::* pmf)();
+void foo () { (pmf) 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmf2.C b/gcc/testsuite/g++.old-deja/g++.jason/pmf2.C
new file mode 100644
index 00000000000..7ebb23b095f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmf2.C
@@ -0,0 +1,13 @@
+// PRMS Id: 4484 (bug 3)
+// Bug: g++ does implicitly take the address of methods passed to fns.
+// Build don't link:
+
+struct A {
+  void f ();
+};
+
+void g (void (A::*)());
+
+void h () {
+  g (A::f);			// ERROR - failed conversion to method pointer
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmf3.C b/gcc/testsuite/g++.old-deja/g++.jason/pmf3.C
new file mode 100644
index 00000000000..4d4d6ef237f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmf3.C
@@ -0,0 +1,19 @@
+// From: enewton@uunet.uu.NET
+// Subject: g++ 2.5.8: cannot cast member function pointers
+// Date: 27 Jan 1994 01:22:56 -0500
+// Build don't link:
+
+struct A {
+	void f(char);
+	void g(int);
+};
+
+typedef void (A::*Ptr)(char);
+
+void q() {
+   Ptr p;
+
+   p  = (Ptr) &A::f;
+   p  = (Ptr) &A::g;
+   p  = &A::f;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmf4.C b/gcc/testsuite/g++.old-deja/g++.jason/pmf4.C
new file mode 100644
index 00000000000..a0af9f41289
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmf4.C
@@ -0,0 +1,9 @@
+// PRMS Id: 4484 (bug 5)
+// Bug: g++ can't convert between pmf types.
+// Build don't link:
+
+class A;
+typedef void (A::*pmf)();
+typedef void (A::*pmfc)() const;
+
+pmfc p = (pmfc)(pmf)0;		// gets bogus error - pmf conversion
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmf5.C b/gcc/testsuite/g++.old-deja/g++.jason/pmf5.C
new file mode 100644
index 00000000000..c27bec10f9e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmf5.C
@@ -0,0 +1,18 @@
+// PRMS Id: 4985
+// Build don't link:
+// Special g++ Options:
+
+struct Thing {
+        int OverloadFn() const;
+        void FunctionA(char* restOfLine);
+        void OverloadFn(char* restOfLine);
+};
+
+struct ThingEntry {
+        void (Thing::*_handler)(char* restOfLine);
+};
+
+static ThingEntry KeyWordTable[] = {
+        &Thing::FunctionA,
+        Thing::OverloadFn,
+};				// WARNING - implicit &
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmf6.C b/gcc/testsuite/g++.old-deja/g++.jason/pmf6.C
new file mode 100644
index 00000000000..08e425b7931
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmf6.C
@@ -0,0 +1,11 @@
+// PRMS Id: 5656
+// Bug: g++ tries (which is a bug) and fails (which is a bug) to initialize
+// var at runtime.
+// Build don't link:
+
+struct A
+{
+    int func(int);
+    int func() const;
+};
+int (A::* var) () const = & A::func;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmf7.C b/gcc/testsuite/g++.old-deja/g++.jason/pmf7.C
new file mode 100644
index 00000000000..8ef92fbb679
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmf7.C
@@ -0,0 +1,27 @@
+// PRMS Id: 6486
+// Make sure that no confused handling of COND_EXPRs and SAVE_EXPRs messes
+// with the number of calls to foo.
+
+int c;
+
+struct A {
+  void f () {}
+  virtual void g () {}
+};
+
+A& foo ()
+{
+  static A a;
+  ++c;
+  return a;
+}
+
+int main ()
+{
+  void (A::*p)() = &A::f;
+  (foo ().*p)();
+  p = &A::g;
+  (foo ().*p)();
+
+  return 2 - c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmf8.C b/gcc/testsuite/g++.old-deja/g++.jason/pmf8.C
new file mode 100644
index 00000000000..7fccb31cb43
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmf8.C
@@ -0,0 +1,29 @@
+// PRMS Id: 6905
+
+class Parent {
+public:
+  void DoSomething() { return; };
+  int i;
+};
+
+class Child : public Parent {
+public:
+};
+
+class User {
+public:
+  void DoAnyThing(void (Parent::*)(void)) { return; }
+  void DoAThing(void (Child::*)(void)) { return; }
+  void DoAThing(int Child::*) { return; }
+};
+
+
+int main()
+{
+  User a;
+
+  a.DoAnyThing(&Child::DoSomething);
+  a.DoAThing(&Child::DoSomething);
+  a.DoAThing(&Parent::DoSomething);
+  a.DoAThing(&Parent::i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmf9.C b/gcc/testsuite/g++.old-deja/g++.jason/pmf9.C
new file mode 100644
index 00000000000..335cfccb8c0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmf9.C
@@ -0,0 +1,57 @@
+// PRMS id: g++/13340
+// Build don't link:
+
+class rectangle {
+    
+public:
+  rectangle();
+  int overlaps() const;
+
+};
+
+class region 
+{
+  friend class region_impl;
+
+public:
+  region();
+  typedef int (region::* region_func)() const;      
+
+};
+
+class region_impl  {
+  friend class region;
+
+private:
+  rectangle content, mbb;
+  region_impl *link_p;
+  region_impl(const rectangle &content);
+
+public:
+  int iterate(region *region_p, region::region_func what,
+	      const rectangle &clip_rect) const;
+  int iterate(region *region_p, region::region_func what,
+	      const region_impl &clip_rgn) const;
+};
+
+
+int
+region_impl::iterate (region *region_p, region::region_func what, 
+		      const rectangle &clip_rect) const
+{
+  for (const region_impl *p = this; p != 0 && p->mbb.overlaps();
+       p = p->link_p)
+    if (p->content.overlaps())
+      if (!(region_p->*what)()) return 0;
+  return 1;
+}
+
+int
+region_impl::iterate (region *region_p, region::region_func what,
+		      const region_impl &clip_rgn) const
+{
+  for (const region_impl *p = this; p != 0 && p->mbb.overlaps();
+       p = p->link_p)
+    if (!clip_rgn.iterate(region_p, what, p->content)) return 0;
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/pmftemp.C b/gcc/testsuite/g++.old-deja/g++.jason/pmftemp.C
new file mode 100644
index 00000000000..87d2ed11464
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/pmftemp.C
@@ -0,0 +1,16 @@
+// PRMS Id: 4484 (bug 1)
+// Bug: g++ does not support templates involving method pointers.
+// Build don't link:
+
+struct A {
+  void f ();
+};
+
+template <class T> void
+f (void (T::*p)())		// gets bogus error - use of template parm as aggregate
+{ }
+
+void g ()
+{
+  f (&A::f);			// gets bogus error - templates and method pointers
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/precedence.C b/gcc/testsuite/g++.old-deja/g++.jason/precedence.C
new file mode 100644
index 00000000000..af2dcde85a5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/precedence.C
@@ -0,0 +1,14 @@
+// Bug: g++ groups ->* before casts.
+// PRMS Id: 4484 (bug 4)
+// Build don't link:
+
+struct A { };
+struct B : public A { void f (); };
+
+void g ()
+{
+  A* ap = new B;
+  void (B::*p)() = &B::f;
+
+  ((B*)ap->*p)();		// gets bogus error - incorrect precedence
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/redecl1.C b/gcc/testsuite/g++.old-deja/g++.jason/redecl1.C
new file mode 100644
index 00000000000..fecace37af4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/redecl1.C
@@ -0,0 +1,12 @@
+class A
+{
+public:
+    A (const A& ccref);
+    friend A const re (const A& v1); // ERROR - 
+};
+
+A // const
+re (const A& ref)
+{				// ERROR - mismatched decls
+    return A (ref);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref1.C b/gcc/testsuite/g++.old-deja/g++.jason/ref1.C
new file mode 100644
index 00000000000..590ddf507c9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref1.C
@@ -0,0 +1,8 @@
+// Bug: g++ tries to call a constructor for a reference.  Doh!
+// Build don't link:
+
+class B;
+struct A {
+  B & b;
+  A (B & x) : b (x) { }		// gets bogus error - 
+};				// gets bogus error - 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref10.C b/gcc/testsuite/g++.old-deja/g++.jason/ref10.C
new file mode 100644
index 00000000000..876ca45dd1e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref10.C
@@ -0,0 +1,31 @@
+// Test that conversion from D* to B*& works properly.
+
+extern "C" int printf (const char *, ...);
+
+struct V {
+  int a;
+};
+
+struct B: virtual V {
+  int b;
+};
+
+struct D: B {
+  int c;
+};
+
+V* gp = 0;
+
+void foo(V * const &r) {
+  gp = r;
+}
+
+int bar(V *r) {
+  return (r != gp);
+}
+
+int main() {
+  D *p = new D;
+  foo(p);
+  return bar(p);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref11.C b/gcc/testsuite/g++.old-deja/g++.jason/ref11.C
new file mode 100644
index 00000000000..b8c6f317a10
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref11.C
@@ -0,0 +1,17 @@
+int main(int argc, char ** argv) {
+
+  int (&var_field_ref)[] =  * (int (*)[]) new int [42]; 
+  int (&fix_field_ref)[1] =  * (int (*)[1]) new int [42]; 
+
+  int static_field[42];
+
+  int *const &var_field_ptr_ref  = var_field_ref; // gets bogus error
+  int *const &fix_field_ptr_ref  = fix_field_ref;
+  int *const &static_field_ptr_ref  = static_field;
+
+  int * var_field_ptr  = var_field_ref; // gets bogus error
+  int * fix_field_ptr  = fix_field_ref; 
+  int * static_field_ptr  = static_field; 
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref12.C b/gcc/testsuite/g++.old-deja/g++.jason/ref12.C
new file mode 100644
index 00000000000..30e963398cb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref12.C
@@ -0,0 +1,5 @@
+void f (char *const &) { }
+int main ()
+{
+  f ("hi");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref2.C b/gcc/testsuite/g++.old-deja/g++.jason/ref2.C
new file mode 100644
index 00000000000..fe97990cd92
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref2.C
@@ -0,0 +1,6 @@
+// Bug: g++ can't deal with references to arrays.
+// Build don't link:
+
+typedef float Matrix[4][4];
+Matrix m;
+Matrix& f () { return m; }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref3.C b/gcc/testsuite/g++.old-deja/g++.jason/ref3.C
new file mode 100644
index 00000000000..2bdd023383f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref3.C
@@ -0,0 +1,7 @@
+// PRMS Id: ????
+// Build don't link:
+
+void f (const int& i)
+{
+  &(int&)i;			// gets bogus error - references ARE lvalues
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref4.C b/gcc/testsuite/g++.old-deja/g++.jason/ref4.C
new file mode 100644
index 00000000000..5c62d6a10d2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref4.C
@@ -0,0 +1,4 @@
+// Build don't link:
+
+void f ();
+void (&fr)() = f;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref5.C b/gcc/testsuite/g++.old-deja/g++.jason/ref5.C
new file mode 100644
index 00000000000..07895223350
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref5.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+int i;
+int &const j = i;		// ERROR - invalid const
+int &const f();			// ERROR - invalid const
+void g ()
+{
+  j = 1;
+  f() = 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref6.C b/gcc/testsuite/g++.old-deja/g++.jason/ref6.C
new file mode 100644
index 00000000000..afebb6bab98
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref6.C
@@ -0,0 +1,2 @@
+const int &f();
+int &a = f();			// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref7.C b/gcc/testsuite/g++.old-deja/g++.jason/ref7.C
new file mode 100644
index 00000000000..af64d6a7521
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref7.C
@@ -0,0 +1,21 @@
+// Testcase for the lifetime of a temporary object which is used to
+// initialize a reference.
+
+int destroyed = 0;
+
+struct A {
+  A() { }
+  A(int) { }
+  ~A() { destroyed++; }
+};
+
+A a;
+A foo () { return a; }
+
+int main()
+{
+  const A& ar = foo();
+  const A& ar2 = A();
+  const A& ar3 = (A)1;
+  return destroyed;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref8.C b/gcc/testsuite/g++.old-deja/g++.jason/ref8.C
new file mode 100644
index 00000000000..10e335e9976
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref8.C
@@ -0,0 +1,17 @@
+// PRMS Id: 5184
+// Bug: cast to C& below does not adjust address
+
+struct A {};
+struct B {
+  virtual void foo () {};
+};
+struct C : public B, public A {};
+
+int main() {
+    C c;
+
+    A& ar = c;
+    C& cr = (C&)ar;
+
+    cr.foo();	// this line causes core dump
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/ref9.C b/gcc/testsuite/g++.old-deja/g++.jason/ref9.C
new file mode 100644
index 00000000000..099d3421cf8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/ref9.C
@@ -0,0 +1,25 @@
+// Bug: g++ re-evaluates the initializer for r before calling f(); since i has
+// changed to an invalid index, this breaks.
+
+class C
+{
+public:
+  void f () { }
+};
+
+void foo (C * objs[])
+{
+  int i = 0;
+  C & r = * objs[i];	/* make reference to element */
+
+  i = 666;
+  r.f ();		/* core dumps here */
+}
+
+int
+main ()
+{
+  C * objs[1] = { new C };
+
+  foo (objs);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/report.C b/gcc/testsuite/g++.old-deja/g++.jason/report.C
new file mode 100644
index 00000000000..d3d3392e451
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/report.C
@@ -0,0 +1,68 @@
+// Build don't link: 
+// GROUPS passed error-reporting
+template <char C>
+class badoo
+{
+};
+
+template <int (*F) (int)>
+class doowop
+{
+};
+
+struct A
+{
+  int a;
+  ~A () { a = 0; }
+  operator int () { return a; }
+};
+
+extern "C" int atoi (char *);
+
+int (*fee)(char *) = atoi;
+int (**bar)(char *) = &fee;
+
+char *s = "4";
+char **sp = &s;
+char ***spp = &sp;
+
+int foo (int a = (**bar) (s))
+{
+   return doowop<foo>::bar; // ERROR - not a member
+} // ERROR - non-void
+
+int foo2 (int (*a)(int) = &foo)
+{
+   undef4 (1); // ERROR - implicit declaration
+  return 1;
+}
+
+class X{
+  class Y{};
+};
+
+typedef int const * bart ();
+typedef bart const * const * bar2;
+
+bar2 baz (X::Y y)
+{
+  X::Y f;
+  bar2 wa [5];
+  wa[0] = baz(f);
+  undef2 (1); // ERROR - implicit declaration
+} // ERROR - non-void
+
+int ninny ()
+{
+  struct A
+    {
+	  static int ninny2 () { return badoo<'\001'>::foo; } // ERROR - not a member
+    };
+
+  return A::ninny2();
+}
+
+int darg (char X::*p)
+{
+   undef3 (1); // ERROR - implicit declaration
+} // ERROR - non-void
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/return.C b/gcc/testsuite/g++.old-deja/g++.jason/return.C
new file mode 100644
index 00000000000..c737a3ea8bd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/return.C
@@ -0,0 +1,21 @@
+// PRMS Id: 5331
+// Bug: the return value of foo is constructed in a temporary and then
+// copied into the return slot.  This is not necessary.
+
+int c = 0;
+
+struct X {
+   X(int i) { }
+   X(X const &XX) { c = 1; }
+   ~X() { }
+};
+
+const X foo() { 
+  return X(3); 
+};
+
+int main()
+{
+  foo();
+  return c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/return2.C b/gcc/testsuite/g++.old-deja/g++.jason/return2.C
new file mode 100644
index 00000000000..272390903e8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/return2.C
@@ -0,0 +1,23 @@
+// PRMS Id: 5368
+// Bug: the X temporary in foo() is not destroyed.
+
+int c = 0;
+
+struct X {
+  X (int) { c++; }
+  ~X() { c--; }
+};
+
+struct Y {
+   Y(const X &) { }
+};
+
+Y foo() { 
+  return X(3); 
+};
+
+int main()
+{
+  foo();
+  return c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/return3.C b/gcc/testsuite/g++.old-deja/g++.jason/return3.C
new file mode 100644
index 00000000000..ac52bc3e463
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/return3.C
@@ -0,0 +1,19 @@
+// PRMS id: 10912
+
+struct A {
+  A() { i=10; };
+  int i;
+};
+struct B : public A {};
+B b;
+
+A f()
+{
+  return b;
+}
+
+int main ()
+{
+  A a = f ();
+  return a.i != 10;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg1.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg1.C
new file mode 100644
index 00000000000..a9b581f2751
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg1.C
@@ -0,0 +1,13 @@
+// Bug: g++ parses the declaration of i as a functional cast.
+// Build don't link:
+
+void take_int (int arg) { }
+ 
+void
+test ()
+{
+    int (i);
+
+    i = 0;
+    take_int (i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg10.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg10.C
new file mode 100644
index 00000000000..8e7d2d1349d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg10.C
@@ -0,0 +1,9 @@
+// Bug: g++ doesn't notice the overflow in the enum values.
+
+#include <limits.h>
+ 
+enum COLOR
+{
+    red,
+    green = ULONG_MAX, blue
+};				// ERROR - enum overflow
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg11.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg11.C
new file mode 100644
index 00000000000..2b3e4cc02d0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg11.C
@@ -0,0 +1 @@
+typedef int int;	/* ERROR - trying to redefine int */
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg12.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg12.C
new file mode 100644
index 00000000000..e33404dfc1b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg12.C
@@ -0,0 +1 @@
+int array[3] = { 1, 2, 3, 4 };	/* ERROR - excess initializer elements */
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg13.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg13.C
new file mode 100644
index 00000000000..77560b33865
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg13.C
@@ -0,0 +1,11 @@
+// Bug: g++ does overloading on a function-by-function basis.
+
+void
+f ()
+{
+  void (*fp)(void);
+  {
+    extern void g ();
+  }
+  fp = g;	/* ERROR - no 'g' in scope */
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg14.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg14.C
new file mode 100644
index 00000000000..8475ecd6c81
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg14.C
@@ -0,0 +1,15 @@
+void *vp;
+int (*ap)[];
+struct S *sp;
+union U *up;
+int (*fp)();
+ 
+void
+test ()
+{
+    vp++;               /* ERROR - incrementing void * */
+    ap++;               /* ERROR - incrementing ptr to incomplete type */
+    sp++;               /* ERROR - incrementing ptr to incomplete type */
+    up++;               /* ERROR - incrementing ptr to incomplete type */
+    fp++;               /* ERROR - incrementing ptr to function */
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg16.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg16.C
new file mode 100644
index 00000000000..75d87a5f0f2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg16.C
@@ -0,0 +1,5 @@
+// Bug: g++ doesn't push parameter decls as they are parsed.
+// Build don't link:
+
+void (*ptr) (int foo, int array[sizeof(foo)]); // gets bogus error XFAIL *-*-*
+void test2 (int bar, int array[sizeof(bar)]) { } // gets bogus error XFAIL *-*-*
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg17.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg17.C
new file mode 100644
index 00000000000..8291650b7d6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg17.C
@@ -0,0 +1,15 @@
+// The default assignment operator for B uses array assignment, so we can't
+// just disallow it...
+
+struct A { A& operator=(const A&); };
+struct B { A f[20]; };
+
+int a1[20], a2[20];
+B b1, b2;
+
+void
+test ()
+{
+  b1 = b2;	      /* OK */
+  a1 = a2;	      /* ERROR - array assignment */
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg18.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg18.C
new file mode 100644
index 00000000000..53c3dd1628f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg18.C
@@ -0,0 +1,11 @@
+// Any expression may be explicitly converted to type void.
+// Build don't link:
+
+struct S { int m[10]; } object;
+struct S f () { return object; }
+ 
+void
+test ()
+{
+  (void) f().m;         /* OK - cast to void; see constraints in 3.8.1 */
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg2.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg2.C
new file mode 100644
index 00000000000..9c30c3640a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg2.C
@@ -0,0 +1,6 @@
+// Bug: g++ complains about a class definition containing a const member
+// but no constructor; it shouldn't complain at that point, since this is
+// valid use.
+// Build don't link:
+
+struct S { const int member; } object = { 0 };
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg20.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg20.C
new file mode 100644
index 00000000000..33b4858b758
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg20.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+typedef void func_type ();
+func_type *fp;
+void *vp;
+
+void example ()
+{
+    vp != fp;			// gets bogus error - nuttin' wrong wit dat
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg21.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg21.C
new file mode 100644
index 00000000000..d6389bebfa7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg21.C
@@ -0,0 +1 @@
+char array0[4] = "abcde";          /* ERROR - initializer too long */
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg22.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg22.C
new file mode 100644
index 00000000000..7be8ba03fc0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg22.C
@@ -0,0 +1,6 @@
+static void f ();		// ERROR - used but not defined
+
+void g ()
+{
+  f ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg23.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg23.C
new file mode 100644
index 00000000000..73bcfc0f0e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg23.C
@@ -0,0 +1,2 @@
+  signed char *ptr2 = "hello";  /* ERROR - changing sign */
+unsigned char *ptr3 = "hello";  /* ERROR - changing sign */
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg24.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg24.C
new file mode 100644
index 00000000000..e5987a149c1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg24.C
@@ -0,0 +1,8 @@
+typedef int Int;
+ 
+Int Int_object_1;
+ 
+void test ()
+{
+        ((Int) Int_object_1) = Int_object_1; /* ERROR - not an lvalue*/
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg25.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg25.C
new file mode 100644
index 00000000000..deb319d7057
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg25.C
@@ -0,0 +1 @@
+struct { int :0; };  /* ERROR - anon struct not used to declare objects */
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg26.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg26.C
new file mode 100644
index 00000000000..1ad204e8ad4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg26.C
@@ -0,0 +1,9 @@
+typedef void (FTYPE) ();
+ 
+FTYPE f;                /* ok */
+ 
+void
+test_0 ()
+{
+    (FTYPE) f;          /* ERROR - casting to function type */
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg27.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg27.C
new file mode 100644
index 00000000000..8fb85e80f52
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg27.C
@@ -0,0 +1,4 @@
+short volatile short var_0_2;              /* ERROR - duplicate short */
+long volatile long var_0_3;                /* ERROR - duplicate long */
+signed volatile signed var_0_7;            /* ERROR - duplicate signed */
+unsigned volatile unsigned var_0_8;        /* ERROR - duplicate unsigned */
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg28.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg28.C
new file mode 100644
index 00000000000..246c7e69b31
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg28.C
@@ -0,0 +1,9 @@
+/* From 01/25/94 working paper (7.1.3):
+ 
+        If, in a decl-specifier-seq containing the decl-specifier typedef,
+        there is no type-specifier, or the only type-specifiers are cv-
+        qualifiers, the typedef declaration is ill-formed.
+*/
+ 
+typedef foo;			// ERROR - invalid typedef
+typedef const bar;		// ERROR - invalid typedef
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg3.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg3.C
new file mode 100644
index 00000000000..fc254511cfe
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg3.C
@@ -0,0 +1,15 @@
+// Bug: g++ remembers the members of OUTER and complains about the second
+// definition.
+// Build don't link:
+
+void
+test ()
+{
+    {
+	struct OUTER { struct INNER { int mbr; } member; };
+    }
+
+    {
+	struct OUTER { struct INNER { int mbr; } member; };
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg4.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg4.C
new file mode 100644
index 00000000000..978b3634aab
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg4.C
@@ -0,0 +1,12 @@
+// Bug: f1 and f2 are treated as overloaded when they aren't.
+// Build don't link:
+
+int i;
+void f1(double) { }
+void f2(double) { }
+
+void
+test ()
+{
+    i ? f1 : f2;		// gets bogus error - improper overloading
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg5.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg5.C
new file mode 100644
index 00000000000..700fae36294
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg5.C
@@ -0,0 +1,10 @@
+// Bug: func is treated as an overloaded function when it isn't.
+// Build don't link:
+
+int *func () { return 0; }
+
+void
+test ()
+{
+  *func;			// gets bogus error - improper overloading
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg6.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg6.C
new file mode 100644
index 00000000000..0f3c9c3823c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg6.C
@@ -0,0 +1,4 @@
+// Build don't link:
+
+wchar_t *single  =   L"xyz"  ;
+wchar_t *(array[]) = { L"xyz" };
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg7.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg7.C
new file mode 100644
index 00000000000..8f3835fffcc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg7.C
@@ -0,0 +1,6 @@
+// Bug: fixincludes and/or cpp mangle the definition of wchar_t so that this
+// doesn't work.
+// Build don't link:
+
+#include <stdlib.h>
+wchar_t array[] = L"xxx";	// gets bogus error - wchar_t
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg8.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg8.C
new file mode 100644
index 00000000000..401d05de590
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg8.C
@@ -0,0 +1,4 @@
+// Bug: g++ is wrongfully pedantic about union initializers.
+// Build don't link:
+
+union U { int mbr; } array[1] = { 0 };
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rfg9.C b/gcc/testsuite/g++.old-deja/g++.jason/rfg9.C
new file mode 100644
index 00000000000..abf6335fa97
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rfg9.C
@@ -0,0 +1,9 @@
+int cond;
+int i;
+int *ip;
+
+void
+test ()
+{
+  cond ? i : ip;	/* ERROR - pointer/integer mismatch */
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rvalue1.C b/gcc/testsuite/g++.old-deja/g++.jason/rvalue1.C
new file mode 100644
index 00000000000..01cd497b1c0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rvalue1.C
@@ -0,0 +1,51 @@
+// PRMS Id: 6000
+// Bug: g++ gets confused trying to build up a reference to a cast.
+
+class String {
+protected:
+  char *cp;
+public:
+  String(char *incp);
+  String(const String &constStringRef);
+  virtual void virtualFn1(void) const {;}
+};
+
+String::String(char *incp)
+{
+  cp = incp;
+}
+
+String::String(const String &constStringRef)
+{
+// Right here, do an 'info args', and look at the virtual function table
+// pointer: typically junk! Calling the function through that table could
+// do anything, since we're really leaping off into the void. This example
+// goes down with 'SIGBUS', but I've seen 'SIGSEGV' too, and 'SIGILL' is
+// possible.
+
+  cp = constStringRef.cp;
+  constStringRef.virtualFn1();
+}
+
+void foofun(String string)
+{
+  ;
+}
+
+class Class1 {
+public:
+  Class1(const String & constStringRef);
+};
+
+Class1 :: Class1 (const String & constStringRef)
+{
+// If instead of calling the function 'foofun()' here, we just assign
+// 'constStringRef' to a local variable, then the vptr is typically == 0!
+
+  foofun(String(constStringRef));
+}
+
+int main(void)
+{
+  Class1 *class1 = new Class1("Hi!");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rvalue2.C b/gcc/testsuite/g++.old-deja/g++.jason/rvalue2.C
new file mode 100644
index 00000000000..71f59bc68b3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rvalue2.C
@@ -0,0 +1,17 @@
+// Test for undesired aliasing.
+
+struct A {
+  const A * get_this () const { return this; }
+};
+
+int main ()
+{
+  A a;
+  int r = 0;
+  const A& ar1 = (A)a;
+  if (&ar1 == &a)
+    r |= 1;
+  if (A(a).get_this () == &a)
+    r |= 2;
+  return r;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/rvalue3.C b/gcc/testsuite/g++.old-deja/g++.jason/rvalue3.C
new file mode 100644
index 00000000000..4e18cfbadaf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/rvalue3.C
@@ -0,0 +1,5 @@
+int main ()
+{
+   int i;
+   int &ir = (int&)(int)i;	// ERROR - casting rvalue to reference type
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping.C
new file mode 100644
index 00000000000..49715be0a9a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping.C
@@ -0,0 +1,12 @@
+// PRMS Id: 3977
+// Bug: A member function is not hidden properly by a later use of its name.
+// Build don't link:
+
+struct A {
+  void index ();
+};
+
+struct B: A {
+  int index;
+  B(): index(4) {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping10.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping10.C
new file mode 100644
index 00000000000..9119951978c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping10.C
@@ -0,0 +1,14 @@
+// Test for scope-based hiding of functions.
+
+void f (char *);
+struct A {
+  void f ();			// ERROR - referred to 
+};
+struct B : public A {
+  void g (char *);
+  void h () {
+    extern void g ();		// ERROR - 
+    f("foo");			// ERROR - hidden
+    g("foo");			// ERROR - hidden
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping11.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping11.C
new file mode 100644
index 00000000000..870b9d5b566
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping11.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+void f ();
+void g ()
+{
+  int f;
+  {
+    void f ();
+    f ();			// gets bogus error - trying to call integer
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping12.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping12.C
new file mode 100644
index 00000000000..96e4ab73033
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping12.C
@@ -0,0 +1,10 @@
+// Build don't link:
+void f ()
+{
+  struct A {
+    friend void g ();
+  };
+}
+void h () {
+  g ();				// ERROR - no g in scope
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping13.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping13.C
new file mode 100644
index 00000000000..2fd1707627b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping13.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+struct A { typedef int foo; };
+struct B: public A {
+  typedef int bar;
+  struct C {
+    void g (B::bar);		// gets bogus error - nested type failure
+    void f (B::foo);
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping14.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping14.C
new file mode 100644
index 00000000000..d8c19388151
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping14.C
@@ -0,0 +1,8 @@
+// [class.scope0]: The scope of a name declared in a class consists
+// ... also of all ... default arguments ... in that class ....
+// Build don't link:
+
+struct A {
+  void f (int A::* = &A::i);	
+  int i;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping15.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping15.C
new file mode 100644
index 00000000000..bfebf240984
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping15.C
@@ -0,0 +1,20 @@
+// Bug: g++ ignores the :: qualification and dies trying to treat an integer
+// variable as a list of functions.
+// Build don't link:
+
+class DComplex {
+public:
+  friend  double   imag(const DComplex& a);
+};
+
+class FComplex {
+public:
+  friend  float    imag(const FComplex& a);
+};
+
+void
+scnrm2(FComplex cx[])
+{
+  int imag;
+  ::imag( cx[0] );
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping16.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping16.C
new file mode 100644
index 00000000000..d88501e67a4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping16.C
@@ -0,0 +1,4 @@
+struct A {
+  int a();			// ERROR - 
+  int a;			// ERROR - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping17.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping17.C
new file mode 100644
index 00000000000..26fb45656da
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping17.C
@@ -0,0 +1,8 @@
+// Test that the integer hides the struct in block scope.
+
+int main ()
+{
+  int A;
+  struct A { };
+  A = 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping2.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping2.C
new file mode 100644
index 00000000000..68c8c754a80
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping2.C
@@ -0,0 +1,15 @@
+// Bug: A function is not hidden properly by a use of its name in an
+// inner scope.
+// Build don't link:
+
+struct A
+{
+    struct B
+    {
+	int f;
+	B() : f(0) {};
+	void g() { f = 0; };
+    };
+    void f();
+    void f(int);
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping3.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping3.C
new file mode 100644
index 00000000000..578de7a7e8e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping3.C
@@ -0,0 +1,8 @@
+// Bug: g++ does not grok nested types very well.
+// Build don't link:
+
+class A {
+  class B;
+  friend class B;
+  class B { };			// gets bogus error - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping4.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping4.C
new file mode 100644
index 00000000000..94a49bfc77a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping4.C
@@ -0,0 +1,30 @@
+// PRMS Id: 4375
+// Bug: g++ fails to keep track of nested typedefs properly.
+// Build don't link:
+
+class A {
+public:
+  typedef char * Ptr;
+  Ptr s;
+  Ptr get_string();
+  A(Ptr string); // { s = string; };
+};
+
+class B {
+public:
+  typedef A * Ptr;
+  Ptr a;
+  Ptr get_A();
+  B(Ptr a_ptr);
+};
+
+A::A(Ptr string) {		// gets bogus error - 
+  s = string;			// gets bogus error - 
+}
+
+int main() {
+  A a("testing");
+  A *a_ptr;
+  B b(&a);
+  a_ptr = b.get_A();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping5.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping5.C
new file mode 100644
index 00000000000..4572da7652a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping5.C
@@ -0,0 +1,6 @@
+// Bug: g++ thinks that A defines operator delete, and tries to call it.
+// Build don't link:
+
+struct A {
+  ~A () { ::operator delete (0); }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping6.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping6.C
new file mode 100644
index 00000000000..161cc4762f7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping6.C
@@ -0,0 +1,27 @@
+// Testcase for all uses of explicit global scope.
+// Build don't link:
+
+int a, B;
+
+struct A { };
+int operator+(A&, int);
+
+struct B {
+  struct C {
+    static int a;
+    static int f () { A a; return ::operator+ (a, ::a); } // gets bogus error
+  };
+};
+
+int B::C::a = 0;
+
+struct D : public ::B::C { };	// gets bogus error
+
+void f ()
+{
+  int B;
+  ::B::C b;
+
+  B = ::B::C::a;		// gets bogus error
+  B = ::B::C::f();		// gets bogus error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping7.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping7.C
new file mode 100644
index 00000000000..6ffa907f62a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping7.C
@@ -0,0 +1,6 @@
+// Bug: g++ doesn't flag name collisions between types and non-types as
+// errors.  It shouldn't for class names, but it should for typedefs.
+// Build don't link:
+
+int bar;			// ERROR - 
+typedef int bar;		// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping8.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping8.C
new file mode 100644
index 00000000000..de023d1c3e1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping8.C
@@ -0,0 +1,7 @@
+// Bug: g++ allows two different meanings of a name in the same scope.
+
+typedef int foo;		// ERROR - 
+struct A {
+  A (foo);
+  int foo ();			// ERROR - foo already used in scope
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/scoping9.C b/gcc/testsuite/g++.old-deja/g++.jason/scoping9.C
new file mode 100644
index 00000000000..3d8a1555ff2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/scoping9.C
@@ -0,0 +1,12 @@
+// Bug: g++ silently mangles the second 'B' to 'A::B', so the definition is
+// lost.
+// Build don't link:
+
+struct A {
+  enum B { };
+};
+
+struct C: public A {
+  enum B { };
+  void foo (C::B);
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/shadow1.C b/gcc/testsuite/g++.old-deja/g++.jason/shadow1.C
new file mode 100644
index 00000000000..59ffcbd15c3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/shadow1.C
@@ -0,0 +1,16 @@
+// Special g++ Options: -Wshadow
+// Build don't link:
+
+class x {
+public:
+        void fun();
+private:
+        int foo;
+};
+
+void x::fun() { };
+
+main ()
+{
+        float foo;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/soverload.C b/gcc/testsuite/g++.old-deja/g++.jason/soverload.C
new file mode 100644
index 00000000000..793e37f33c1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/soverload.C
@@ -0,0 +1,10 @@
+// Bug: dfs_pushdecls doesn't create an overload list for member functions,
+//   like it claims to.
+// Build don't link:
+
+struct A
+{
+  static int foo (int);
+  static int foo (int, int);
+  void bar () { foo (1, 2); }	// gets bogus error - broken overloading
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/special.C b/gcc/testsuite/g++.old-deja/g++.jason/special.C
new file mode 100644
index 00000000000..9f6202ecf44
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/special.C
@@ -0,0 +1,6 @@
+// Make sure that forward declarations of specializations work...
+
+template <class T> class A { };
+class A<int>;
+A<int> a;			// ERROR - incomplete type
+class A<int> { };
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/static1.C b/gcc/testsuite/g++.old-deja/g++.jason/static1.C
new file mode 100644
index 00000000000..8c5bdff359b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/static1.C
@@ -0,0 +1,31 @@
+// PRMS id: 6863
+
+extern "C" int printf(const char *, ...);
+extern "C" void abort();
+
+enum ENUM {E1=0, E2 };
+int d;
+
+class AAA{
+public:
+ AAA() {a = new char[10];printf("constructor AAA() called\n");}
+ AAA(int) {printf("constructor AAA(int) called\n");}
+ ~AAA(){ printf("destructor ~AAA() called\n"); d = 1; }
+ operator int () { return 1;}
+ char *a;
+ int i;
+};
+
+struct sentinel {
+  ~sentinel () { if (d == 0) abort (); }
+} s;
+
+/* forward decl here causes gcc not to execute ct and dt for arr1 */
+extern AAA arr1[];
+
+AAA arr1[] = {(int)E1 };
+
+int main()
+{
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/synth.C b/gcc/testsuite/g++.old-deja/g++.jason/synth.C
new file mode 100644
index 00000000000..733243cf363
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/synth.C
@@ -0,0 +1,13 @@
+// Bug: the synthesized copy constructor for A is not found.
+// Build don't link:
+
+struct A {
+  // A (const A& a): i(a.i) {}
+  int i;
+};
+
+struct B {
+  A a;
+  B (const B& b): a(b.a), j(b.j) { } // gets bogus error - 
+  int j;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/synth10.C b/gcc/testsuite/g++.old-deja/g++.jason/synth10.C
new file mode 100644
index 00000000000..d94e6bdebe9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/synth10.C
@@ -0,0 +1,52 @@
+// Special g++ Options: -O
+// Build don't link:
+// Bug: Synthesizing methods for the nested class screwed up current_class_decl
+// for the outer class.
+
+class A;
+class AH
+{
+  public:
+    inline  AH (   A * p = 0 );
+    AH ( const  AH & from )
+    : pointer( from.pointer )   { inc(); }
+    ~ AH ()  { dec(); }
+  private:
+    A * pointer;
+    inline void inc() const;
+    inline void dec() const;
+};
+
+class A 
+{
+  protected:
+    struct AttrTable
+    {
+	struct Row
+	{
+	};
+    };
+    
+  public:
+
+    class Attributes
+    {
+      public:
+	class iterator
+	{
+	  public:
+	    iterator() : mo(0), attr(0) {}
+	    iterator& operator++() { ++attr; return *this; }
+	    iterator operator++(int)
+	    { iterator tmp = *this; ++*this; return tmp; }
+
+	  private:
+	    AH mo;
+	    const AttrTable::Row* attr;
+	};
+
+	Attributes(AH mo)
+	: mo(mo) {}
+	AH mo;
+    };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/synth2.C b/gcc/testsuite/g++.old-deja/g++.jason/synth2.C
new file mode 100644
index 00000000000..3094b8e55cb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/synth2.C
@@ -0,0 +1,8 @@
+// PRMS Id: 4623
+// Bug: g++ tries and fails to synthesize a copy constructor for D.
+// Build don't link:
+
+class A { };
+class B: public virtual A { };
+class C: public A { };
+class D: public B, public C { }; // gets bogus error - bad synthesis
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/synth3.C b/gcc/testsuite/g++.old-deja/g++.jason/synth3.C
new file mode 100644
index 00000000000..26af8aed3b9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/synth3.C
@@ -0,0 +1,6 @@
+// Testcase for wrongful generation of copy constructor.
+// Build don't link:
+
+class A { };
+class B: virtual private A { };
+class D: public B { };		// gets bogus error
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/synth4.C b/gcc/testsuite/g++.old-deja/g++.jason/synth4.C
new file mode 100644
index 00000000000..89ecf2dc074
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/synth4.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+struct X {
+  X();
+};
+typedef	void (X::*mfp)();
+struct Y {
+  Y();
+  mfp memfp;
+};
+void f()
+{
+  Y *y1, *y2 ;
+  *y1 = *y2;		 // gets bogus error - failed to synthesize op=
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/synth5.C b/gcc/testsuite/g++.old-deja/g++.jason/synth5.C
new file mode 100644
index 00000000000..2905da72639
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/synth5.C
@@ -0,0 +1,14 @@
+// Bug: generated B::operator= tries to call A::operator=
+
+#pragma implementation
+#line 1 "synth5.h"
+#pragma interface
+
+struct A {
+  virtual A& operator= (const A&) = 0;
+};
+
+struct B: public A {
+};
+#line 5 "synth5.C"
+int main() { }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/synth6.C b/gcc/testsuite/g++.old-deja/g++.jason/synth6.C
new file mode 100644
index 00000000000..f3a95db44f7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/synth6.C
@@ -0,0 +1,15 @@
+// Bug: g++ tries to generate an op= for DbmItem and fails.
+// Build don't link:
+
+class RefCount{
+public:
+  RefCount();
+
+private:
+  RefCount& operator=(const RefCount);
+};
+
+class DbmItem: public RefCount{
+public:
+  DbmItem(): RefCount() {};
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/synth7.C b/gcc/testsuite/g++.old-deja/g++.jason/synth7.C
new file mode 100644
index 00000000000..05953779880
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/synth7.C
@@ -0,0 +1,11 @@
+// Testcase to make sure that synthesized methods are found when needed.
+
+struct B { ~B() { } };
+struct A { B b; };
+
+int main()
+{
+  A a, b (a), c = A();
+  A& (A::*afp)(const A&) = &A::operator=;
+  (a.*afp) (b);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/synth8.C b/gcc/testsuite/g++.old-deja/g++.jason/synth8.C
new file mode 100644
index 00000000000..f7e82a9e8a7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/synth8.C
@@ -0,0 +1,20 @@
+// Bug: the synthesized constructor for A tries to use the mem-initializer
+// list for the B constructor.
+// Build don't link:
+
+struct A
+{
+  virtual ~A();
+};
+
+struct B
+{
+  B();
+  char* x;
+  A* a;
+};
+
+B::B()
+: x(0), a(new A())
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/synth9.C b/gcc/testsuite/g++.old-deja/g++.jason/synth9.C
new file mode 100644
index 00000000000..6886feb6e21
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/synth9.C
@@ -0,0 +1,20 @@
+// PRMS Id: 6837
+// Bug: anonymous union confuses g++.
+// Build don't link:
+
+struct my_key {
+   my_key(const my_key&);
+   my_key(const char* n);
+};
+
+struct my_node {
+   my_node(my_key&);
+   union {
+      long cnt;
+      my_node* next;
+   };
+   my_key a;
+};
+
+extern my_node n;
+my_node a(n);
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tempargs.C b/gcc/testsuite/g++.old-deja/g++.jason/tempargs.C
new file mode 100644
index 00000000000..749e02cbd19
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tempargs.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+// GROUPS passed templates overloading
+template<class T> class Vector { };
+template<class T> struct Sort { static void sort (Vector<typename T::foo> &); };
+template<class T> void Sort<T>::sort (Vector<typename T::foo> &) { }
+struct whee { typedef int foo; };
+
+void f (Vector<int> &vi) { Sort<whee>::sort (vi); }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tempcons.C b/gcc/testsuite/g++.old-deja/g++.jason/tempcons.C
new file mode 100644
index 00000000000..77cc732090e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tempcons.C
@@ -0,0 +1,8 @@
+// Bug: member initializers are allowed where they shouldn't be.
+// Build don't link:
+
+template <class T>
+struct A {
+  int i;
+  Blarg () : i(0) { }		// ERROR - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tempdest.C b/gcc/testsuite/g++.old-deja/g++.jason/tempdest.C
new file mode 100644
index 00000000000..04fae56a740
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tempdest.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed templates destructors
+// Example of PR 3308 workaround
+
+template <class T>
+class A
+{
+  T q;
+public:
+  ~A() { (&q)->T::~T(); }
+};
+
+typedef unsigned int ui;
+
+int main()
+{
+  A<ui> *ap = new A<ui>;
+
+  delete ap;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tempinst1.C b/gcc/testsuite/g++.old-deja/g++.jason/tempinst1.C
new file mode 100644
index 00000000000..0a8a6cc378c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tempinst1.C
@@ -0,0 +1,23 @@
+// Bug: g++ fails to instantiate operator<<.
+// Build don't run:
+// Special g++ Options: -g
+
+struct ostream {
+  ostream& operator<< (const char *) { return *this; };
+};
+
+template <class T> class foo;
+
+template <class T> ostream& operator<< (ostream& ios, foo<T>&obj) { };
+
+template <class T> class foo {
+  friend ostream& operator<<<>(ostream&, foo<T>&);
+};
+
+int main()
+{
+  ostream cout;
+  foo<int> foo_obj;
+  cout << foo_obj; // causes linker error
+  return 0;
+} 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template1.C b/gcc/testsuite/g++.old-deja/g++.jason/template1.C
new file mode 100644
index 00000000000..f3aa571483e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template1.C
@@ -0,0 +1,20 @@
+// PRMS Id: 4688
+// Bug: g++ can't deal with templates instantiated within extern "C".
+// Build don't link:
+
+class Gnaf {
+public:
+   virtual int invariant ();
+};
+
+template <class T> class Array : public Gnaf {
+public:
+   virtual int invariant();
+};
+
+extern "C"
+int foo()
+{
+   Array<int> toConv;
+   return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template10.C b/gcc/testsuite/g++.old-deja/g++.jason/template10.C
new file mode 100644
index 00000000000..18a574a28eb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template10.C
@@ -0,0 +1,26 @@
+// Bug: member operator shadows global template in tsubst.
+// Build don't link:
+
+class ostream;
+
+template <class TP> class smanip {
+public:
+  friend ostream& operator<< <>(ostream &o, const smanip<TP>&m);
+};
+
+template<class TP>
+ostream& operator<<(ostream& o, const smanip<TP>& m)
+{ return o;}
+
+class X
+{
+public:
+  X operator<<(int);  // commenting out this line makes it work!
+  void print(ostream& os);
+};
+
+void X::print(ostream& os)
+{
+  smanip<double> smd;
+  os << smd;			// gets bogus error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template11.C b/gcc/testsuite/g++.old-deja/g++.jason/template11.C
new file mode 100644
index 00000000000..d58bdfe9e03
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template11.C
@@ -0,0 +1,14 @@
+// Bug: initializers for static data members of templates don't get run.
+
+template <class T> struct A {
+  static T t;
+};
+
+int foo () { return 1; }
+
+int A<int>::t = foo ();
+
+int main ()
+{
+  return (A<int>::t != 1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template12.C b/gcc/testsuite/g++.old-deja/g++.jason/template12.C
new file mode 100644
index 00000000000..93c19b63571
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template12.C
@@ -0,0 +1,14 @@
+// Testcase for 'this is a type' syntax.
+// Build don't link:
+
+struct B {
+  typedef int A;
+};
+
+template <class T> struct Y {
+  void f() {
+    typename T::A *d;
+  }
+};
+
+template class Y<B>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template13.C b/gcc/testsuite/g++.old-deja/g++.jason/template13.C
new file mode 100644
index 00000000000..fbd16a9995e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template13.C
@@ -0,0 +1,10 @@
+// Bug: g++ fails to actually instantiate templates to the specifications of
+// guiding decls.
+// Special g++ Options: -g -ansi -pedantic-errors -fguiding-decls
+
+template <class T> inline T min (T a, T b) { return a<b?a:b; }
+double min (double, double);
+
+int main () {
+  return (int) min (0, 1.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template14.C b/gcc/testsuite/g++.old-deja/g++.jason/template14.C
new file mode 100644
index 00000000000..ecd99bc5eaa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template14.C
@@ -0,0 +1,16 @@
+// PRMS Id: 4745
+// Bug: g++ gets the constructor and destructor confused because the default
+// parm prevents the two constructor types from satisfying ==.
+
+template <class T> struct A {
+  A(int = 1);
+  ~A();
+};
+
+template <class T> A<T>::A(int) { } // causes compiler abort
+template <class T> A<T>::~A() { }
+
+int main()
+{
+  A<int> a;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template15.C b/gcc/testsuite/g++.old-deja/g++.jason/template15.C
new file mode 100644
index 00000000000..9779ca024b1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template15.C
@@ -0,0 +1,27 @@
+// PRMS Id: 2139
+// Bug: g++ tries to instantiate the template with types on the function
+// obstack and fails.
+
+template<class T>
+class X {
+public:
+    X(int) { }
+
+    T x;
+};
+
+class A { };
+
+int main()
+{
+    int i;
+    X<int> xi(i);
+    X<double> xd(i);
+    
+    X<int (*)(int, void *)> fp0(i);
+    X<int (*)(int, char, double)> fp1(i);
+    X<int (*)(int, double**, void *)> fp2(i);
+
+    X<int (A::*)()> mp0 (i);
+    X<int A::*> mp1 (i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template16.C b/gcc/testsuite/g++.old-deja/g++.jason/template16.C
new file mode 100644
index 00000000000..3241f981f35
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template16.C
@@ -0,0 +1,33 @@
+// PRMS Id: 1502
+// Bug: g++ fails to resolve 'gnc' in the call to 'grid'.
+
+template<class T> class foo { 
+public:
+  foo() { } 
+};
+
+template<class T> class bar : public foo<T> {
+public:
+  bar() : foo<T>() {}
+};
+
+template<class T> class ben : public foo<T> {
+public:
+  ben() : foo<T>() {}
+  void grid(T (*f)(bar<T>&),bar<T>& x,bar<T>& y,bar<T>& param);
+};
+
+template<class T> void ben<T>::grid(T (*f)(bar<T>&),bar<T>& x,bar<T>& y,bar<T>& param) { }
+
+template<class T> T gnc(bar<T>& a)
+{
+  return 0;
+}
+
+int main()
+{
+  ben<double> a;
+  bar<double> x,y,p;
+  a.grid(gnc,x,y,p);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template17.C b/gcc/testsuite/g++.old-deja/g++.jason/template17.C
new file mode 100644
index 00000000000..27e4d047ccd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template17.C
@@ -0,0 +1,11 @@
+// Caught by Booch Components.
+// Bug: g++ tries to instantiate nested enums.
+// Build don't link:
+
+template <class T> struct A
+{
+  struct B { };
+  enum C { c };
+};
+
+template struct A<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template18.C b/gcc/testsuite/g++.old-deja/g++.jason/template18.C
new file mode 100644
index 00000000000..38224bfd5ee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template18.C
@@ -0,0 +1,18 @@
+// GROUPS passed templates
+// Bug: g++ emits template instances when it shouldn't.
+// Special g++ Options: -g -Wno-deprecated -fexternal-templates
+
+// We mark this XFAIL because we can't test for expected linker errors.
+// If we get an XPASS for this testcase, that's a bug.
+// (OK) excess errors test - XFAIL *-*-*
+
+#pragma implementation "irrelevant_file"
+#line 1 "template18.h"
+#pragma interface
+template <class T> inline T min (T a, T b) { return a<b?a:b; }
+#line 13 "template18.C"
+
+main()
+{
+  min (1, 1); 		// should produce an undefined symbol error.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template19.C b/gcc/testsuite/g++.old-deja/g++.jason/template19.C
new file mode 100644
index 00000000000..68ea9a9fbf7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template19.C
@@ -0,0 +1,9 @@
+// Make sure type deduction isn't confused by top-level cv-quals.
+template <class T> T max (const T a, const T b)  { return a>b?a:b; }
+
+int main()
+{
+  int a = 0, b = 1;
+  int c = max (a, b);
+  int d = max ((const int)a, (const int)b);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template2.C b/gcc/testsuite/g++.old-deja/g++.jason/template2.C
new file mode 100644
index 00000000000..d3950e9b2b9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template2.C
@@ -0,0 +1,12 @@
+// Bug: instantiation of member templates breaks.
+// Build don't link:
+
+template <class T> struct A {
+  static void f ();
+  void g ();
+};
+
+template <class T> void A<T>::f () { }
+template <class T> void A<T>::g () { }
+
+A<int> a;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template20.C b/gcc/testsuite/g++.old-deja/g++.jason/template20.C
new file mode 100644
index 00000000000..ee4daa0b826
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template20.C
@@ -0,0 +1,9 @@
+// Make sure type deduction works for both types of array parameters.
+template <class T> void f (T (&a)[2]) { }
+template <class T> void g (T a[2]) { }
+int main()
+{
+  int a[2] = { 0, 0 };
+  f (a);
+  g (a);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template21.C b/gcc/testsuite/g++.old-deja/g++.jason/template21.C
new file mode 100644
index 00000000000..817d1da8828
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template21.C
@@ -0,0 +1,16 @@
+// Gosh, this works!
+// Build don't link:
+
+template<class T>
+struct A
+{
+    struct B
+    {
+	void bar();
+    };
+    struct C { };
+};
+
+template<class T> void A<T>::B::bar() { }
+
+template class A<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template22.C b/gcc/testsuite/g++.old-deja/g++.jason/template22.C
new file mode 100644
index 00000000000..ce247e80752
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template22.C
@@ -0,0 +1,31 @@
+// Testcase for proper unification of code involving references.
+// Build don't link:
+
+template<class T>
+struct A
+{
+    void foo();
+};
+
+template<class T> void A<T>::foo() { }
+
+template class A<int&>;
+
+const int& f1 ();
+int& f2 ();
+int f3 ();
+
+template <class T> void g1 (const T&);
+template <class T> void g2 (T&);
+template <class T> void g3 (T);
+
+int main()
+{
+  g1 (f1 ());
+  g1 (f2 ());
+  g1 (f3 ());
+  g2 (f2 ());
+  g3 (f1 ());
+  g3 (f2 ());
+  g3 (f3 ());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template23.C b/gcc/testsuite/g++.old-deja/g++.jason/template23.C
new file mode 100644
index 00000000000..1d257a2e7df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template23.C
@@ -0,0 +1,12 @@
+// Testcase for instantiation with cv-qualified type
+// Build don't link:
+
+template<class T>
+struct A
+{
+    void foo();
+};
+
+template<class T> void A<T>::foo() { }
+
+template class A<const int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template24.C b/gcc/testsuite/g++.old-deja/g++.jason/template24.C
new file mode 100644
index 00000000000..120b717eddd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template24.C
@@ -0,0 +1,21 @@
+// Bug: g++ doesn't find the conversion from ostream_withassign to ostream.
+
+#include <iostream.h>
+
+template <class T>
+struct A {
+  T t;
+};
+
+template <class T>
+ostream & operator<< (ostream & os, A<T> & a)
+{
+  os << a.t;
+  return os;
+}
+
+int main ()
+{
+  A<int> a = { 1 };
+  cout << a << endl;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template25.C b/gcc/testsuite/g++.old-deja/g++.jason/template25.C
new file mode 100644
index 00000000000..9704412263e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template25.C
@@ -0,0 +1,48 @@
+// PRMS Id: 6393
+// Bug: g++ is too lax in considering UPTs to be the same.
+
+template <class R, class T>
+class Bar
+{
+public:
+  R do_bar (T arg);
+};
+
+
+template <class T>
+class Foo
+{
+  T i;
+
+public:
+  void do_foo () {}
+  void do_foo (T const & t) {}
+  void do_foo (Bar<char, T> const & bar);  // {} Put the body here and it works
+  void do_foo (Bar<T, T> const & bar);     // {} Put the body here and it works
+};
+
+// These definitions don't work
+
+template <class T>
+inline void Foo<T>::
+do_foo (Bar<char, T> const & bar)
+{}
+
+template <class T>
+inline void Foo<T>::
+do_foo (Bar<T, T> const & bar)
+{}
+
+
+int main ()
+{ int i;
+  Bar<char, int> bar1;
+  Bar<int, int>  bar2;
+  Foo<int> foo;
+  foo.do_foo();
+  foo.do_foo(i);
+  foo.do_foo(bar1);
+  foo.do_foo(bar2);
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template26.C b/gcc/testsuite/g++.old-deja/g++.jason/template26.C
new file mode 100644
index 00000000000..fcd598dda84
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template26.C
@@ -0,0 +1,114 @@
+// PRMS Id: 6275
+// Bug: unification fails for call to find_parameter_in_stack.
+
+#include <stdio.h>
+#include <stdlib.h>
+
+const int max_stack_size = 20;
+
+template <class T>
+class Stack {
+  private:
+    T objects[max_stack_size];
+    int nobjects;
+  public:
+    Stack(): nobjects(0) {}
+    void push(const T&a) {
+        if (nobjects >= max_stack_size) {
+            fprintf(stderr,"Stack: overflow\n");
+            abort();
+          }
+        objects[nobjects++] = a;
+      }
+    T pop() {
+        if (!nobjects) {
+            fprintf(stderr,"Stack: underflow\n");
+            abort();
+          }
+        nobjects -= 1;
+        T result = objects[nobjects];
+        return result;
+      }
+    T top() const {
+        if (!nobjects) {
+            fprintf(stderr,"Stack: underflow\n");
+            abort();
+          }
+        return objects[nobjects - 1];
+      }
+    int n() const { return nobjects; }
+    T operator[](int i) { return objects[i]; }
+};
+
+template <class T>
+class Parameter {
+    T parameter_;
+    int is_set_;
+    int overrides_;
+  public:
+    Parameter(): is_set_(0), overrides_(0) {}
+    void set(const T& a) { parameter_ = a; is_set_ = 1; }
+    void override(int overrides = 1) { overrides_ = overrides; }
+    const T& value() const { return parameter_; }
+    int overrides() const { return overrides_; }
+    int is_set() const { return is_set_; }
+};
+
+template <class T1, class T2>
+T2
+find_parameter_in_stack(Stack<T1>& stack, Parameter<T2>& (T1::*access)())
+{
+  T2 result;
+  int have_result = 0;
+  for (int i=stack.n()-1; i>=0; i--) {
+      if ((stack[i].*access)().is_set()) {
+          if (!have_result || (stack[i].*access)().overrides()) {
+              result = (stack[i].*access)().value();
+              have_result = 1;
+            }
+        }
+    }
+  return result;
+}
+
+class A {
+  private:
+    Parameter<int> a_;
+  public:
+    A() { }
+    Parameter<int>& a() { return a_; }
+};
+
+int
+main(int, char**)
+{
+  Stack<A> A_stack;
+  A a1;
+  A a2;
+  a1.a().set(1);
+  a2.a().set(2);
+  A_stack.push(a1);
+  A_stack.push(a2);
+
+  int val = find_parameter_in_stack(A_stack, &A::a);
+
+  printf("val = %d\n", val);
+  if (val != 2)
+    return 1;
+
+  A_stack.pop();
+  A_stack.pop();
+
+  a1.a().override();
+
+  A_stack.push(a1);
+  A_stack.push(a2);
+
+  val = find_parameter_in_stack(A_stack, &A::a);
+
+  printf("val = %d\n", val);
+  if (val != 1)
+    return 1;
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template27.C b/gcc/testsuite/g++.old-deja/g++.jason/template27.C
new file mode 100644
index 00000000000..be90aca8d75
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template27.C
@@ -0,0 +1,48 @@
+// PRMS Id: 6826
+// Check that unnecessary templates are not instantiated.
+
+template <class T> 
+class Test 
+{ 
+ public: 
+  void doThiss(); 
+  void doThat(); 
+};
+
+template <class T> 
+void Test<T>::doThiss() 
+{ 
+  T x; 
+
+  x.thiss(); 
+} 
+
+template <class T> 
+void Test<T>::doThat() 
+{ 
+  T x; 
+
+  x.that(); 
+} 
+
+class A 
+{ 
+ public: 
+  void thiss() {}; 
+};
+
+class B
+{ 
+ public: 
+  void that() {}; 
+};
+
+int main() 
+{ 
+  Test<A> a; 
+  a.doThiss();			// a.doThat() is not well formed, but then
+				// it's not used so needn't be instantiated. 
+  
+  Test<B> b;
+  b.doThat();			// simillarly b.doThiss(); 
+} 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template28.C b/gcc/testsuite/g++.old-deja/g++.jason/template28.C
new file mode 100644
index 00000000000..c5501d91e61
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template28.C
@@ -0,0 +1,33 @@
+// PRMS Id: 7179
+
+template <class T>
+class Car{
+public:
+   Car();
+} ;
+
+class Wheels{
+public:
+   Wheels();
+} ;
+
+class Shop
+{
+public:
+   Shop();
+private:
+   Car<Wheels> car ;
+} ;
+
+Wheels::Wheels() {}
+
+Shop::Shop() {}
+
+int main()
+{
+   Shop shop ;
+   return 0 ;
+}
+
+template <class T>
+Car<T>::Car() {}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template29.C b/gcc/testsuite/g++.old-deja/g++.jason/template29.C
new file mode 100644
index 00000000000..d4212e2e5e7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template29.C
@@ -0,0 +1,19 @@
+// PRMS Id: 9500
+// Build don't link:
+
+template <int S> 
+class base 
+   { 
+public: 
+   inline base(); 
+   }; 
+ 
+template <class T> 
+class derived : public base<sizeof(T)> 
+   { 
+public: 
+   inline derived(); 
+   }; 
+ 
+template <class T> 
+inline derived<T>::derived() : base<sizeof(T)>(){} 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template3.C b/gcc/testsuite/g++.old-deja/g++.jason/template3.C
new file mode 100644
index 00000000000..1cd65531757
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template3.C
@@ -0,0 +1,14 @@
+// PRMS Id: 4679
+// Bug: g++ doesn't re-instantiate templates after definition is seen.
+
+template <class T> struct A;
+
+A<int> *a;
+
+template <class T> struct A { T t; };
+
+int main()
+{
+  if (a)
+    a->t = 1;			// gets bogus error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template30.C b/gcc/testsuite/g++.old-deja/g++.jason/template30.C
new file mode 100644
index 00000000000..98bad49a3ee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template30.C
@@ -0,0 +1,13 @@
+template <class T, class U>    
+int func(U, T);			// ERROR - ref below
+
+template <class T, class U>    
+int func(T, U)
+{				// ERROR - ref below
+        return 2;
+}
+
+int main ()
+{
+  func (0, 1);			// ERROR - ambiguous
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template31.C b/gcc/testsuite/g++.old-deja/g++.jason/template31.C
new file mode 100644
index 00000000000..1148e278da2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template31.C
@@ -0,0 +1,40 @@
+// PRMS Id: 8569
+
+#include <iostream.h>
+#include <vector>
+
+using std::vector;
+ 
+class Component {
+    int george;
+    char mabel[128];
+};
+class CopyMe {
+public:
+    CopyMe(){;}
+private:
+    vector<Component> strvec;
+};
+
+class IncludeIt   {
+public:
+    IncludeIt() {}
+    ~IncludeIt() {}
+    IncludeIt(const IncludeIt& i) {
+        myStrvec = i.myStrvec;
+    }
+    IncludeIt& operator=(const IncludeIt& i) {
+	myStrvec = i.myStrvec;
+    }
+private:
+    CopyMe myStrvec;
+};
+
+int main(int argc, char**argv)   {
+    IncludeIt foo;
+    IncludeIt* bar;
+    exit(0);
+}
+
+template class std::__malloc_alloc_template<0>;
+template class std::__default_alloc_template<false, 0>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template32.C b/gcc/testsuite/g++.old-deja/g++.jason/template32.C
new file mode 100644
index 00000000000..d510e93c492
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template32.C
@@ -0,0 +1,10 @@
+// Bug: Instantiating A<int> screws with class bindings for B
+// Build don't link:
+
+template <class T> struct A { };
+struct B {
+  typedef int foo;
+  void f ();
+};
+
+void B::f () { A<int> a; foo i; }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template33.C b/gcc/testsuite/g++.old-deja/g++.jason/template33.C
new file mode 100644
index 00000000000..35a63aad3da
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template33.C
@@ -0,0 +1,17 @@
+// Test nested enums in templates.
+// Build don't link:
+
+template <class T>
+class A
+{
+public:
+  enum muni {X, Y};
+  
+  muni e() { return X; };
+  muni f();
+};
+
+template <class T>
+A<T>::muni A<T>::f() { return X; }
+
+template class A<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template34.C b/gcc/testsuite/g++.old-deja/g++.jason/template34.C
new file mode 100644
index 00000000000..177286f4abb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template34.C
@@ -0,0 +1,24 @@
+template<class T>
+class Set {
+  public:
+    typedef int (*Compare)(const T&, const T&);
+    static Compare cmp1;
+    static int (*cmp2)(const T&, const T&);
+};
+
+template<class T>
+int gen_cmp(const T& a, const T& b) {
+    if (a<b) return -1;
+    else if (a==b) return 0;
+    else return 1;
+}
+
+template<class T>
+Set<T>::Compare Set<T>::cmp1 = &gen_cmp;
+
+template<class T>
+int (*Set<T>::cmp2)(const T&, const T&) = &gen_cmp;
+
+int main() {
+    Set<int> s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template35.C b/gcc/testsuite/g++.old-deja/g++.jason/template35.C
new file mode 100644
index 00000000000..be3f808252c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template35.C
@@ -0,0 +1,15 @@
+// Bug: instantiation of D() corrupts declaration of basis[].
+// Build don't link:
+
+struct B { };
+template <int t>
+struct D : public B 
+{
+    D() : B () { }
+};
+
+B const * basis[] =
+{
+    new D<0>,
+    new D<1>,
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template36.C b/gcc/testsuite/g++.old-deja/g++.jason/template36.C
new file mode 100644
index 00000000000..807af75e0d2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template36.C
@@ -0,0 +1,51 @@
+// Testcase for implicit 'typename' and resolution of 'typename's in the
+// current scope.
+
+class base1 { 
+public:
+    int bar() const
+    { return 1; }
+};
+
+class base2 { 
+public:
+    int bar() const
+    { return 0; }
+};
+
+template<class X>
+struct base_trait {
+    typedef base1 base;
+};
+
+struct base_trait<float> {
+    typedef base2 base;
+};
+
+template<class T>
+class weird : public base_trait<T>::base {
+public:
+    typedef base_trait<T>::base base;
+
+    base f ();
+    int base::* g ();
+
+    int zowee() const
+    { return bar(); }  
+};
+
+template <class T>
+weird<T>::base weird<T>::f ()
+{
+    return base();
+}
+
+template <class T>
+int weird<T>::base::* weird<T>::g ()
+{ return 0; }
+
+int main()
+{
+    weird<float> z;
+    return z.zowee() || z.f().bar();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template37.C b/gcc/testsuite/g++.old-deja/g++.jason/template37.C
new file mode 100644
index 00000000000..53607ee7fbe
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template37.C
@@ -0,0 +1,36 @@
+// PRMS Id: 9930
+// Test of -fexternal-templates hackery in new template code
+// Special g++ options: -Wno-deprecated -fexternal-templates
+
+  #pragma implementation "foo.hh"
+  #pragma interface "foo.hh"
+
+  template<class T>
+  class ONE
+  {
+    public:
+      static void func();
+  };
+
+  template<class T>
+  void ONE<T>::func()
+  {
+  }
+
+  class ONE<int>
+  {
+    public:
+      static void func();
+  };
+
+  void ONE<int>::func()
+  {
+  }
+
+int main()
+  {
+    ONE<char>::func();
+    ONE<int>::func();
+
+    return 0;
+  }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template38.C b/gcc/testsuite/g++.old-deja/g++.jason/template38.C
new file mode 100644
index 00000000000..3870cbc5c14
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template38.C
@@ -0,0 +1,18 @@
+// Special g++ Options: -fguiding-decls
+
+struct A {
+  friend int operator== (const A&, const A&);
+  A (int) { }
+};
+
+template <class T> int
+operator== (const T&, const T&)
+{
+  return 0;
+}
+
+main ()
+{
+  A a (1);
+  return a == 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template39.C b/gcc/testsuite/g++.old-deja/g++.jason/template39.C
new file mode 100644
index 00000000000..dc76889e4e0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template39.C
@@ -0,0 +1,22 @@
+// PRMS Id: 10283
+// Build don't link:
+
+template <class T> struct B {
+  static void (*p)();
+  static void f ();
+};
+
+template <class T>
+void (*B<T>::p)() = &B<T>::f;
+
+B<int> b;
+
+template <int i> struct A {
+  static const int j = i;
+  int k[j];
+};
+
+A<1> a;
+
+template <int i>
+const int A<i>::j;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template4.C b/gcc/testsuite/g++.old-deja/g++.jason/template4.C
new file mode 100644
index 00000000000..7fcb45c3f9a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template4.C
@@ -0,0 +1,21 @@
+// Bug: g++ tries to instantiate ccList twice, and fails.
+// Build don't link:
+
+template<class T> class ccHandle{ };
+template <class T> class ccList;
+template <class T> class cc_List {
+public:
+  ccList <T>  copy ();
+};
+
+template <class T> class ccList : public ccHandle < cc_List <T> > {
+public:
+  ccList (int);
+};
+
+template <class T>
+ccList <T> cc_List<T>::copy (){}
+
+int main (int, char **) {
+  ccList <int> size1();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template40.C b/gcc/testsuite/g++.old-deja/g++.jason/template40.C
new file mode 100644
index 00000000000..a8803920a29
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template40.C
@@ -0,0 +1,19 @@
+// PRMS id: 11315
+// Bug: g++ doesn't recognize the copy ctor for Array<long>.
+
+template <class Type>
+class Array {
+public:
+  Array(int sz=12)
+    : ia (new Type[sz]), size(sz) {}
+  ~Array() { delete[] ia;}
+  Array(const Array<long>& r) : size(0) {} // just for testing
+private:
+  Type *ia;
+  int size;
+};
+
+int main(int argc, char *argv[])
+{
+  Array<long> ia;	// looping occurs on this line
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template41.C b/gcc/testsuite/g++.old-deja/g++.jason/template41.C
new file mode 100644
index 00000000000..62d03b67372
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template41.C
@@ -0,0 +1,33 @@
+// PRMS Id: 11420
+// Bug: Can't handle indirect virtual template base init.
+
+extern "C" int printf (const char *, ...);
+
+template<class T>
+class Vbase {
+ public:
+  Vbase(T i) { printf ("%d\n", i); }
+};
+
+template<class T>
+class D1 : virtual public Vbase<T> {
+ public:
+  D1(T i) : Vbase<T>(i) {}
+};
+
+template<class T>
+class D2 : virtual public Vbase<T> {
+ public:
+  D2(T i) : Vbase<T>(i) {}
+};
+
+template<class T>
+class Most : public D1<T>, public D2<T> {
+ public:
+  Most(T i) : D1<T>(i), D2<T>(i), Vbase<T>(i) {}
+};
+
+int main () {
+  Most<int> x(2);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template42.C b/gcc/testsuite/g++.old-deja/g++.jason/template42.C
new file mode 100644
index 00000000000..2bd62670f22
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template42.C
@@ -0,0 +1,18 @@
+// Testcase for not evaluating template default args if they are
+// never used.
+
+struct X {
+  X(int) { }
+};
+
+template <class T>
+struct A {
+  void f (T t = T()) { }
+};
+
+int main ()
+{
+  A<X> a;
+  X x (1);
+  a.f (x);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template43.C b/gcc/testsuite/g++.old-deja/g++.jason/template43.C
new file mode 100644
index 00000000000..d9b3f85fc3a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template43.C
@@ -0,0 +1,30 @@
+// Test matching of partial specializations.
+
+template <int* x, int* y>
+class EQUAL {
+public:
+	enum { value = 0 };
+};
+template <int* x>
+class EQUAL<x,x> {
+public:
+	enum { value = 1 };
+};
+
+int x;
+int y;
+
+int equals_x_x = EQUAL<&x,&x>::value; // expected value: 1
+int equals_x_y = EQUAL<&x,&y>::value; // expected value: 0
+int equals_y_x = EQUAL<&y,&x>::value; // expected value: 0
+int equals_y_y = EQUAL<&y,&y>::value; // expected value: 1
+
+int main ()
+{
+  if (equals_x_x == 1
+      && equals_x_y == 0
+      && equals_y_x == 0
+      && equals_y_y == 1)
+    return 0;
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template44.C b/gcc/testsuite/g++.old-deja/g++.jason/template44.C
new file mode 100644
index 00000000000..93b47bd23e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template44.C
@@ -0,0 +1,61 @@
+#include <stdlib.h>
+#include <string.h>
+
+template <class T>
+class List {
+public:
+    int len;
+    T *array;
+
+    int length() const { return( len ); }
+
+    List() : len( 0 ), array( 0 ) {}
+};
+
+template <class T>
+int AlgoStdCompare(const T* a, const T* b) {
+  if (*a < *b)
+    return -1;
+  else
+    return (*a > *b);	// 0 if equal, 1 if greater
+}
+
+int AlgoStdCompare(const char* const* a, const char * const*b)
+{
+    return strcmp(*a,*b);
+}
+     
+template <class T>
+void AlgoFixupSort(List< T >* , int, int ) {
+}
+
+template <class T> 
+void AlgoSort(int (*compare)(const T *, const T *),
+	  void (*fixup)( List<T> *, int first, int last),
+	  List< T >* theList, int first, int last) {
+  if (last < 0)
+    last = theList->length()-1;
+  
+  qsort(theList->array+first, last-first+1, sizeof(T),
+	(int (*)(const void *, const void *))compare);
+  if (fixup)
+    fixup(theList, first, last);
+}
+
+template <class T> 
+void AlgoSort(List< T >* theList, int first = 0, int last = -1) {
+  int (*compare)(const T*, const T*) = AlgoStdCompare;
+  void (*fixup)( List<T> *, int first, int last) = AlgoFixupSort;
+  
+  AlgoSort(compare, fixup, theList, first, last);
+}
+
+int
+main()
+{
+    List<const char *> slist;
+    AlgoSort( &slist );
+
+    List<int> ilist;
+    AlgoSort( &ilist );
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template5.C b/gcc/testsuite/g++.old-deja/g++.jason/template5.C
new file mode 100644
index 00000000000..3c1e4cd04c6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template5.C
@@ -0,0 +1,28 @@
+// Bug: g++ fails to compare integer constants properly.
+// Build don't link:
+
+template <int X, int Y>
+struct Matrix {
+   int base [X] [Y];
+};
+
+template <int M,int H,int N>
+Matrix<M,N>& Mul(Matrix<M,N>& Q,Matrix<M,H>& A,Matrix<H,N>& B) {
+  for(int i=0;i<M;i++) {
+    for(int j=0;j<N;j++) {
+      Q.base[i][j]=0;
+      for(int k=0;k<H;k++) {
+	Q.base[i][j]+=A.base[i][k]*B.base[k][j];
+      }
+    }
+  }
+  return Q;
+}
+
+void f ()
+{
+   Matrix<2, 3> q;
+   Matrix<2, 4> a;
+   Matrix<4, 3> b;
+   q = Mul (q, a, b);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template6.C b/gcc/testsuite/g++.old-deja/g++.jason/template6.C
new file mode 100644
index 00000000000..c42426a1908
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template6.C
@@ -0,0 +1,20 @@
+// PRMS Id: 4656
+// Testcase for use of member pointers in template resolution
+
+template <class T> class A {
+ public:
+  A() : a(1) {}
+  T a;
+};
+
+template <class T>
+int foo (T A<int>::*p)
+{
+  return 0;
+}
+int main()
+{
+  int A<int>::*pm = &A<int>::a;	// gets bogus error - failed temp resolution
+  foo (pm);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template7.C b/gcc/testsuite/g++.old-deja/g++.jason/template7.C
new file mode 100644
index 00000000000..87d79a8ab7b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template7.C
@@ -0,0 +1,9 @@
+// PRMS Id: 4826
+// Build don't link:
+
+class A;
+template <class T> void f(const T&, const T&);
+
+void g (const A& a, A& b) {
+  f (a, b); // gets bogus error - failed unification
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template8.C b/gcc/testsuite/g++.old-deja/g++.jason/template8.C
new file mode 100644
index 00000000000..586fb61a02e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template8.C
@@ -0,0 +1,10 @@
+// PRMS Id: 4827
+// Build don't link:
+
+class A;
+template <class T> int f (const T&, const A *);
+
+int g (const int& a)
+{
+  return f (a, (A *)0); // gets bogus error - failed unification
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/template9.C b/gcc/testsuite/g++.old-deja/g++.jason/template9.C
new file mode 100644
index 00000000000..80fd8c9775b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/template9.C
@@ -0,0 +1,12 @@
+// PRMS Id: 4864
+// Bug: g++ can't deal with a guiding declaration which comes before the
+// template.
+// Build don't link:
+
+void f (const int&, const int&);
+template <class T> void f (const T&, const T&) { }
+
+void g (int a)
+{
+  f (a,a); // gets bogus error - two identical candidates
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/temporary.C b/gcc/testsuite/g++.old-deja/g++.jason/temporary.C
new file mode 100644
index 00000000000..168bfe9103e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/temporary.C
@@ -0,0 +1,19 @@
+// From: bruno@isoft.com.ar (Bruno R. Depascale)
+// Subject: No destructor bug
+// Date: Mon, 14 Feb 1994 12:49:45 -0300 (Arg)
+
+// Bug: temporaries created with constructor notation aren't destroyed.
+
+int count = 0;
+
+class A {
+public:
+  A() { ++count; }
+  ~A() { --count; }
+};
+
+int main()
+{
+  A();
+  return count;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/temporary2.C b/gcc/testsuite/g++.old-deja/g++.jason/temporary2.C
new file mode 100644
index 00000000000..36c8e8e5d5b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/temporary2.C
@@ -0,0 +1,16 @@
+class X // Indentation has been done so to see the similarities.
+{
+public:
+  X() {}		  // ERROR - referenced below
+         X(X& x) {x.i=7;} // ERROR - Both functions modify the
+  void bar(X& x) {x.i=7;} // ERROR - reference parameter x.
+  int i;
+};
+
+X foo() { X x; return x; }
+
+int main() 
+{
+  X   x(foo()); // ERROR - Compiler doesn't warn about temporary reference.
+  x.bar(foo()); // ERROR - The same mistake is warned about in this case.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/temporary3.C b/gcc/testsuite/g++.old-deja/g++.jason/temporary3.C
new file mode 100644
index 00000000000..3ffeec79d93
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/temporary3.C
@@ -0,0 +1,26 @@
+// Bug: the temporary returned from f is elided, causing a to be constructed
+// twice but only destroyed once.
+
+extern "C" int printf (const char *, ...);
+
+int c,d;
+
+struct A {
+  A (int) { c++; }
+  ~A () { d++; }
+  A (const A&) { c++; }
+  int i;
+};
+
+A f ()
+{ return 1; }
+
+int main ()
+{
+  {
+    A a (1);
+    a = f ();
+  }
+  printf ("%d %d\n", c, d);
+  return c != d;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/temporary4.C b/gcc/testsuite/g++.old-deja/g++.jason/temporary4.C
new file mode 100644
index 00000000000..bb7e56f1a75
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/temporary4.C
@@ -0,0 +1,31 @@
+// Bug: g++ initializes both B::i and B::j before destroying any temps.
+
+extern "C" int printf (const char *, ...);
+
+int c = 0;
+int d = 0;
+int r = 0;
+
+struct A {
+  A() { if (c != d) r = 1; ++c; }
+  A(const A&);  // declare so g++ returns A on the stack
+  ~A() { ++d; }
+  operator int () { return 0; }
+};
+
+A foo ()
+{
+  return A();
+}
+
+struct B {
+  int i;
+  int j;
+  B(): i(foo()), j(foo()) { }
+};
+
+int main()
+{
+  B b;
+  return r;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/temporary5.C b/gcc/testsuite/g++.old-deja/g++.jason/temporary5.C
new file mode 100644
index 00000000000..6a2469e3627
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/temporary5.C
@@ -0,0 +1,16 @@
+// PRMS Id: 6604
+// Bug: Scoped constructor call is not properly recognized as a functional cast
+
+int c;
+
+struct A {
+  A() { ++c; }
+  ~A() { --c; }
+  operator int () { return 1; }
+};
+
+int main ()
+{
+  A::A();
+  return c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/temporary6.C b/gcc/testsuite/g++.old-deja/g++.jason/temporary6.C
new file mode 100644
index 00000000000..ce6a92e586a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/temporary6.C
@@ -0,0 +1,8 @@
+// Bug: the temporary from the default parameter to f2 is reused.
+// Build don't link:
+
+struct A {};
+int f2 (int i, const A& ar = A());
+void f (int i, int j = f2(1));
+void g () { f (1); }
+void h () { f (1); }
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/temporary7.C b/gcc/testsuite/g++.old-deja/g++.jason/temporary7.C
new file mode 100644
index 00000000000..8b91fe1324d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/temporary7.C
@@ -0,0 +1,35 @@
+// PRMS ID: 7304
+
+struct V {
+  int n;
+  V() : n(0) { }
+  V(int x) : n(x) { }
+};
+
+V baz(const V &x)
+{
+  return x;
+}
+
+int bar(V v1, V v2, V v3)
+{
+  return v1.n;
+}
+
+struct A {
+  A(): n(7) { }
+  int foo();
+  V n;
+};
+
+int A::foo()
+{
+  V v1, v2;
+  return bar(n, baz(v1), v2);
+}
+
+int main()
+{
+  A a;
+  return (a.foo() != 7);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/temporary8.C b/gcc/testsuite/g++.old-deja/g++.jason/temporary8.C
new file mode 100644
index 00000000000..bb0698e2e3c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/temporary8.C
@@ -0,0 +1,25 @@
+// Test for proper handling of temporaries in ?: exprs.
+
+extern "C" int printf (const char *, ...);
+int c = 0, d = 0;
+
+class A {
+public:
+  A() { ++c; }
+  A(const A&) { ++c; }
+  ~A() { ++d; }
+};
+
+A f (const A& a)
+{
+  return (c ? A() : A());
+}
+
+int main()
+{
+  {
+    f (c ? A() : A());
+  }
+  printf ("%d %d\n", c, d);
+  return c != d || c != 2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tempover.C b/gcc/testsuite/g++.old-deja/g++.jason/tempover.C
new file mode 100644
index 00000000000..0998f692a59
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tempover.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed templates overloading
+#define TEMPL template <class T>
+ 
+class B {};
+ 
+TEMPL class A : virtual public B {
+  public:
+    A(int);
+};
+ 
+TEMPL A<T>::A(int){}
+ 
+A<double> a(1);
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tempparse.C b/gcc/testsuite/g++.old-deja/g++.jason/tempparse.C
new file mode 100644
index 00000000000..68f67adc473
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tempparse.C
@@ -0,0 +1,29 @@
+/*
+   PRMS Id: 3631
+   Bug is: g++ mangles template class names in a way that it won't accept,
+     and then tries to feed them to itself.
+*/
+// Build don't link:
+
+template<class T>
+struct A {
+  A();
+};
+
+template<class T>
+struct B : A<T> {
+  B();
+};				// gets bogus error - B<C<char>>
+
+template<class T>
+struct C {
+  C();
+};
+
+template<class T>
+struct D {
+  D();
+  B<C<T> > p_f;
+};
+
+typedef D<char> Dummy;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tempsub.C b/gcc/testsuite/g++.old-deja/g++.jason/tempsub.C
new file mode 100644
index 00000000000..4b69d888d36
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tempsub.C
@@ -0,0 +1,28 @@
+// Distillation of crash1.C problem (PR 3633)
+// Build don't link:
+
+template<class P>
+class A
+{
+  P p;
+};
+
+template<class Q>
+class B
+{
+  A<Q> a;			// bogus error - temp parm name propagating
+};
+
+template<class R>
+class C
+{
+  B<R> b;
+};
+
+template<class S>
+class D
+{
+  S s;
+};
+
+C< D<int> > c;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/this.C b/gcc/testsuite/g++.old-deja/g++.jason/this.C
new file mode 100644
index 00000000000..544db6c361a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/this.C
@@ -0,0 +1,16 @@
+// PRMS Id: 5190
+// Bug: g++ fails to build up a const reference to `this'.
+// Build don't link:
+
+class X
+{
+public:
+    void member ();
+};
+
+void print (const X* const &);
+
+void X::member ()
+{
+    print (this);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/thunk1.C b/gcc/testsuite/g++.old-deja/g++.jason/thunk1.C
new file mode 100644
index 00000000000..22c0516f1b3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/thunk1.C
@@ -0,0 +1,47 @@
+// Test that non-variadic function calls using thunks work right.
+// Special g++ Options: -fvtable-thunks
+
+struct A {
+  void* p;
+  A (void* q): p (q) { }
+  A (const A& a): p (a.p) { }
+};
+
+class CBase {
+public:
+   void BaseFunc();
+};
+
+class MMixin {
+public:
+   virtual A MixinFunc(int arg, A arg2) = 0;
+};
+
+class CExample : public CBase, public MMixin {
+public:
+   A MixinFunc(int arg, A arg2);
+};
+
+void CBase::BaseFunc()
+{
+}
+
+A CExample::MixinFunc(int arg, A arg2)
+{
+  if (arg != 1 || arg2.p != 0)
+    return 0;
+  return this;
+}
+
+void* test(MMixin& anExample)
+{
+  return anExample.MixinFunc(1,A(0)).p;
+}
+
+main ()
+{
+  CExample c;
+
+  if (test(c) != &c)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/thunk2.C b/gcc/testsuite/g++.old-deja/g++.jason/thunk2.C
new file mode 100644
index 00000000000..73bb0ff33b1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/thunk2.C
@@ -0,0 +1,49 @@
+// Test that non-variadic function calls using thunks and PIC work right.
+// Skip if not native
+// Special g++ Options: -fvtable-thunks -fPIC
+// excess errors test - XFAIL m68k-motorola-sysv m88k-motorola-sysv3
+
+struct A {
+  void* p;
+  A (void* q): p (q) { }
+  A (const A& a): p (a.p) { }
+};
+
+class CBase {
+public:
+   void BaseFunc();
+};
+
+class MMixin {
+public:
+   virtual A MixinFunc(int arg, A arg2) = 0;
+};
+
+class CExample : public CBase, public MMixin {
+public:
+   A MixinFunc(int arg, A arg2);
+};
+
+void CBase::BaseFunc()
+{
+}
+
+A CExample::MixinFunc(int arg, A arg2)
+{
+  if (arg != 1 || arg2.p != 0)
+    return 0;
+  return this;
+}
+
+void* test(MMixin& anExample)
+{
+  return anExample.MixinFunc(1,A(0)).p;
+}
+
+main ()
+{
+  CExample c;
+
+  if (test(c) != &c)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/thunk3.C b/gcc/testsuite/g++.old-deja/g++.jason/thunk3.C
new file mode 100644
index 00000000000..66ac8f9529c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/thunk3.C
@@ -0,0 +1,59 @@
+// Test that variadic function calls using thunks work right.
+// Note that this will break on any target that uses the generic thunk
+//  support, because it doesn't support variadic functions.
+
+// Special g++ Options: -fvtable-thunks
+// excess errors test - XFAIL mips*-*-* rs6000-*-* powerpc-*-eabi m68k-*-coff m68k-motorola-sysv m88k-motorola-sysv3
+
+#include <stdarg.h>
+
+struct A {
+  void* p;
+  A (void* q): p (q) { }
+  A (const A& a): p (a.p) { }
+};
+
+class CBase {
+public:
+   void BaseFunc();
+};
+
+class MMixin {
+public:
+   virtual A MixinFunc(int arg, ...) = 0;
+};
+
+class CExample : public CBase, public MMixin {
+public:
+   A MixinFunc(int arg, ...);
+};
+
+void CBase::BaseFunc()
+{
+}
+
+A CExample::MixinFunc(int arg, ...)
+{
+  va_list ap;
+  va_start (ap, arg);
+
+  if (arg != 1 || va_arg (ap, int) != 2 || va_arg (ap, int) != 3
+      || va_arg (ap, int) != 4 || va_arg (ap, int) != 5
+      || va_arg (ap, int) != 6 || va_arg (ap, int) != 7
+      || va_arg (ap, int) != 8 || va_arg (ap, int) != 9)
+    return 0;
+  return this;
+}
+
+void* test(MMixin& anExample)
+{
+  return anExample.MixinFunc(1,2,3,4,5,6,7,8,9).p;
+}
+
+main ()
+{
+  CExample c;
+
+  if (test(c) != &c)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tpt-1.cc b/gcc/testsuite/g++.old-deja/g++.jason/tpt-1.cc
new file mode 100644
index 00000000000..15095200d01
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tpt-1.cc
@@ -0,0 +1,30 @@
+// Testcase for use of template parms as types for other template parms.
+
+template <class T, T t>
+class A {
+    T	a;
+public:
+    A(): a(t) {}
+
+    operator T () { return a; }
+};
+
+template <class S, S s>
+class B {
+    A<S,s> a;
+public:
+    B(A<S,s>& b): a(b) {}
+
+    operator S () { return a*20; }
+};
+
+main()
+{
+    A<int, 5> a;
+    B<int, 5> b(a);
+
+    if (b * a == 500)
+      return 0;
+    else
+      return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tredecl.C b/gcc/testsuite/g++.old-deja/g++.jason/tredecl.C
new file mode 100644
index 00000000000..72cbae7a6ee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tredecl.C
@@ -0,0 +1,17 @@
+// Bug:  Foo<Bar> *p semi-instantiates Foo<Bar> in local scope, so
+// when Foo<Bar> f tries to instantiate it later, it only finds the partial
+// instantiation from before.
+//
+// No PR; distilled from James Clark's SGML project.
+//
+// Build don't link:
+
+class Bar { };
+
+template<class T> class Foo;
+
+Foo<Bar> *p;
+
+template<class T> class Foo { };
+
+Foo<Bar> f;			// gets bogus error - hosed binding levels
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tredecl2.C b/gcc/testsuite/g++.old-deja/g++.jason/tredecl2.C
new file mode 100644
index 00000000000..faaf8624f27
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tredecl2.C
@@ -0,0 +1,5 @@
+// No bug; making sure my fix for tredecl.C doesn't break other cases
+// Build don't link:
+
+template<class T> struct Foo { Foo<T> * me() { return this; } };
+Foo<int> i;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tredecl3.C b/gcc/testsuite/g++.old-deja/g++.jason/tredecl3.C
new file mode 100644
index 00000000000..bcc25ba484f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tredecl3.C
@@ -0,0 +1,11 @@
+// PRMS Id: 4679
+// Bug: redeclaration of templates erases the definition.
+// Build don't link:
+
+template <class T> class Foo { public: void h(); };
+template <class T> class Foo;
+
+void g()
+{
+  Foo<int> f;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/tredecl4.C b/gcc/testsuite/g++.old-deja/g++.jason/tredecl4.C
new file mode 100644
index 00000000000..64ba4b8ff8b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/tredecl4.C
@@ -0,0 +1,5 @@
+// It is illegal to use the name of a class template for anything else,
+// including another class template.
+
+template <class T> class A { };	// ERROR - 
+template <class U, class V> class A { }; // ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/trivial.C b/gcc/testsuite/g++.old-deja/g++.jason/trivial.C
new file mode 100644
index 00000000000..f5a535541cb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/trivial.C
@@ -0,0 +1,71 @@
+// PRMS Id: 3665
+// Build don't link:
+
+//-------------------------------------------------------------
+//  Referential declaration within class
+//
+//  Imbeded below is the invocation of the compiler and the error
+//  message
+//
+//  This compiles successfully with both the xlC and CFRONT compilers
+//  This was reviewed with Clem Dickey and we agree that it appears to
+//  be a Cygnus compiler problem.
+//-------------------------------------------------------------
+/*
+$ make bug.reference.o
+        /usr/p3/bin/i960-vxworks-g++ `getsrc bug.reference.C` -I. -Iinc1 -Iinc2
+ -I/vw5.0.3/h  -I/vw5.0.3/h/i960 -I/usr/p3/lib/gcc-lib/i960-vxworks/cygnus-2.3.3
+/include -I/usr/p3/lib/gcc-lib/i960-vxworks/cygnus-2.3.3-930417/include -I/usr/p
+3/lib/i960-vxworks/include -I/usr/p3/i960-vxworks/include  -c -DCPU_FAMILY=I960
+-DCPU=I960CA -mca -mold-align -g3 -O1 -DASSERT_ON -nostdinc -nostdinc++ -MD
+./bug.reference.C: In method `class1::class1 (long unsigned int, long unsigned i
+nt **&)':
+./bug.reference.C:43: cannot convert type `long unsigned int **'
+./bug.reference.C:43:        to type `long unsigned int *[]&'
+make: 1254-004 The error code from the last command is 1.
+*/
+
+// typedefs
+typedef unsigned long u32;
+typedef u32 *ul[16];
+
+// class defs
+class class1 {
+    u32   var1;
+    class1(const class1 &);                   // Copy constructor
+    class1& operator=(const class1 &);        // operator= member function
+public:
+    class1(u32, ul&);
+    ul  &ulref;
+    ~class1() {}
+};
+
+
+// member function defs
+class1::class1(u32 u, ul &l) : var1(u), ulref(l)
+{}
+
+/* ===========================================================================
+Note:  The following is a "work around" that allows the successful compilation.
+
+
+// typedefs
+typedef unsigned long u32;
+typedef u32 *ul[16];
+
+// class defs
+class class1 {
+    u32   var1;
+    class1(const class1 &);                   // Copy constructor
+    class1& operator=(const class1 &);        // operator= member function
+public:
+    class1(u32, ul*);
+    ul  &ulref;
+    ~class1() {}
+};
+
+
+// member function defs
+class1::class1(u32 u, ul *l) : var1(u), ulref(*l)
+{}
+============================================================================*/
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/typeck.C b/gcc/testsuite/g++.old-deja/g++.jason/typeck.C
new file mode 100644
index 00000000000..cffbc87bbce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/typeck.C
@@ -0,0 +1,19 @@
+// Bug: g++ fails to catch incompatibilities in the parameter lists when
+// assigning.
+// Build don't link:
+
+typedef struct S *type_p;
+typedef struct S const *ctype_p;
+
+typedef ctype_p (*PF) (int);
+
+type_p callee (type_p arg) { return 0; }
+
+void foobar ()
+{
+  static PF p = callee;		// ERROR - 
+
+  p = callee;			// ERROR - 
+}
+
+PF pp = callee;			// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/typedef.C b/gcc/testsuite/g++.old-deja/g++.jason/typedef.C
new file mode 100644
index 00000000000..fac78cebeaf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/typedef.C
@@ -0,0 +1,9 @@
+// PRMS Id: 4687
+// Bug: g++ misinterprets typedefs of function type in class scope.
+// Build don't link:
+
+struct A {
+   typedef int F();
+   F *fp;
+   void* g() { return fp; }	// gets bogus error - typing
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/typedef2.C b/gcc/testsuite/g++.old-deja/g++.jason/typedef2.C
new file mode 100644
index 00000000000..44a32de3925
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/typedef2.C
@@ -0,0 +1,12 @@
+// PRMS Id: 5367
+// Bug: the nested name of C::func gets hosed.
+
+struct C {
+  typedef int func(int *, int *);
+};
+
+int
+main()
+{
+   C::func *handler;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/typedef3.C b/gcc/testsuite/g++.old-deja/g++.jason/typedef3.C
new file mode 100644
index 00000000000..5b96451ccc9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/typedef3.C
@@ -0,0 +1,8 @@
+// Test that inheriting from a type typedefed to itself works.
+// Build don't link:
+
+typedef struct class1 {
+    class1& operator=(const class1&);
+} class1;
+
+class class2 : public class1 { };
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/typeid1.C b/gcc/testsuite/g++.old-deja/g++.jason/typeid1.C
new file mode 100644
index 00000000000..f6cd45bc664
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/typeid1.C
@@ -0,0 +1,11 @@
+#include <typeinfo>
+#include <iostream.h>
+
+struct foo { double f(int); };
+
+int main() {
+  double f (int);
+  const std::type_info &r = typeid (f);
+  cout << typeid(f).name() << endl;
+  cout << typeid(foo::f).name() << endl;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/typeid2.C b/gcc/testsuite/g++.old-deja/g++.jason/typeid2.C
new file mode 100644
index 00000000000..64ecc5a17f5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/typeid2.C
@@ -0,0 +1,30 @@
+// PRMS Id: 11596
+
+#include <typeinfo>
+extern "C" int printf (const char *, ...);
+
+class Chicken
+{
+public:
+  int eggs_per_day;
+};
+
+template <class Bird>
+class Flock
+{
+public:
+  Bird * flock_head;
+  int    head_count;
+  void print_self() {
+    printf ("A flock of %d %ss\n", head_count, typeid (Bird).name ());
+    printf ("A flock of %d %ss\n", head_count, typeid (*flock_head).name ());
+  }
+};
+
+int main()
+{
+  Flock<Chicken> x;
+  printf ("%s\n", typeid(x).name());
+  x.head_count = 42;
+  x.print_self();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/union.C b/gcc/testsuite/g++.old-deja/g++.jason/union.C
new file mode 100644
index 00000000000..b145390efcc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/union.C
@@ -0,0 +1,11 @@
+// Bug: g++ doesn't insert anon union members into class scope.
+// Breaks groff.
+// Build don't link:
+
+struct A {
+  union {
+    int i;
+  };
+
+  void foo () { i = 1; }	// gets bogus error - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/vecdel.C b/gcc/testsuite/g++.old-deja/g++.jason/vecdel.C
new file mode 100644
index 00000000000..717e9678898
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/vecdel.C
@@ -0,0 +1,19 @@
+__SIZE_TYPE__ newsize = 0;
+__SIZE_TYPE__ delsize = 0;
+
+struct A {
+  int i;
+  void * operator new [] (__SIZE_TYPE__ i)
+    { newsize = i; return ::operator new [](i); }
+  void operator delete [] (void *p, __SIZE_TYPE__ i)
+    { delsize = i; ::operator delete [](p); }
+};
+
+int main()
+{
+  A* ap = new A [2];
+  delete [] ap;
+  if (!newsize || newsize != delsize)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/virtual.C b/gcc/testsuite/g++.old-deja/g++.jason/virtual.C
new file mode 100644
index 00000000000..3fa952b164f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/virtual.C
@@ -0,0 +1,41 @@
+// From: chw@bellcore.com (Charlie Woloszynski,MRE 2J-278,8295228,,27143)
+// Newsgroups: gnu.g++.bug
+// Subject: gcc-2.5.5 bug in multiple inheritance and pure virtual functions
+// Date: 25 Jan 1994 23:41:36 -0500
+
+// Bug: g++ fails to notice definitions of abstract virtuals.
+// Build don't link:
+
+class A 
+{
+public:
+  virtual void a1() = 0;
+  virtual void a2() = 0;
+};
+
+class B
+{
+public:
+  virtual void b1() = 0;
+  virtual void b2() = 0;
+};
+
+
+class C: public A, public B
+{
+public:
+  virtual void a2() {};
+  virtual void b2() {};
+};
+
+class D : public C
+{
+public:
+  virtual void a1() {};
+  virtual void b1() {};
+};
+
+int main()
+{
+  D d;				// gets bogus error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/virtual2.C b/gcc/testsuite/g++.old-deja/g++.jason/virtual2.C
new file mode 100644
index 00000000000..ef42f8b19b7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/virtual2.C
@@ -0,0 +1,13 @@
+struct A {
+  virtual A* f () { return this; }
+};
+
+struct B: public A {
+  virtual B* f () { return 0; }
+};
+
+int main ()
+{
+  A* ap = new B;
+  return (ap->f () != 0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/warning1.C b/gcc/testsuite/g++.old-deja/g++.jason/warning1.C
new file mode 100644
index 00000000000..86a2160e764
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/warning1.C
@@ -0,0 +1,7 @@
+// Bug: g++ protests that foo was never defined.
+// Build don't link:
+
+static void foo ();
+static void foo ();
+static void foo () { }
+void bar () { foo(); }		// gets bogus error - 
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/warning10.C b/gcc/testsuite/g++.old-deja/g++.jason/warning10.C
new file mode 100644
index 00000000000..8dbf5ed3217
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/warning10.C
@@ -0,0 +1,19 @@
+// Don't warn about these comparisons.
+// Build don't link:
+// Special g++ Options: -W -Wall
+
+struct A {
+  unsigned int b : 28;
+};
+
+int f (int i, unsigned char u, A a, unsigned long ul)
+{
+  if ((u & 0x10) == 0)
+    return 1;
+  if (i == 0U)
+    return 1;
+  if (a.b > ul)
+    return 1;
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/warning2.C b/gcc/testsuite/g++.old-deja/g++.jason/warning2.C
new file mode 100644
index 00000000000..6b51dd05219
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/warning2.C
@@ -0,0 +1,14 @@
+// g++ ought to warn about casting a base pointer to a derived reference.
+// Build don't link:
+
+struct A {
+  virtual int f () = 0;
+};
+
+struct B: public A { int f () { } };
+
+int main()
+{
+  B* bp;
+  A& ar = (A&)bp;		// WARNING - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/warning3.C b/gcc/testsuite/g++.old-deja/g++.jason/warning3.C
new file mode 100644
index 00000000000..b63b9cac148
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/warning3.C
@@ -0,0 +1,12 @@
+// Bug: overloading of 'A' for template causes bogus shadowing warnings.
+// Special g++ Options: -Wshadow
+// Build don't link:
+
+template<class T> 
+class A
+{
+ public:
+   virtual ~A() {}
+};
+
+template class A<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/warning4.C b/gcc/testsuite/g++.old-deja/g++.jason/warning4.C
new file mode 100644
index 00000000000..a4eb4ac7d41
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/warning4.C
@@ -0,0 +1,16 @@
+// Bug: a virtual function with the same name in an unrelated class will
+// cause a bogus overloading warning.
+// Special g++ Options: -Woverloaded-virtual
+// Build don't link:
+
+struct A {
+  virtual void foo ();
+};
+
+struct B {
+  virtual void bar ();
+};
+
+struct C: public A {
+  virtual void bar  ();
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/warning5.C b/gcc/testsuite/g++.old-deja/g++.jason/warning5.C
new file mode 100644
index 00000000000..239d867b52f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/warning5.C
@@ -0,0 +1,24 @@
+// PRMS Id: 5135
+// Bug: g++ complains that the result of the new expression is not used.
+// Special g++ Options: -Wall
+
+extern "C" int printf (const char *, ...);
+inline void * operator new (__SIZE_TYPE__, void *p) { return p; }
+
+class foo {
+public:
+  foo() : a(42) {};
+  int a;
+};
+
+int
+main()
+{
+  char buffer[1024];
+
+  new (buffer) foo;
+
+  foo* pY = (foo *)buffer;
+
+  return pY->a != 42;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/warning6.C b/gcc/testsuite/g++.old-deja/g++.jason/warning6.C
new file mode 100644
index 00000000000..920a4694acd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/warning6.C
@@ -0,0 +1,7 @@
+// Special g++ Options: -Wunused
+// Build don't link:
+
+struct A {
+  int i:8;
+  virtual ~A() {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/warning7.C b/gcc/testsuite/g++.old-deja/g++.jason/warning7.C
new file mode 100644
index 00000000000..1fe03f89ce9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/warning7.C
@@ -0,0 +1,6 @@
+// PRMS Id: 5481
+// Special g++ Options: -Wunused
+// Build don't link:
+
+struct A { };
+static A a = A();
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/warning8.C b/gcc/testsuite/g++.old-deja/g++.jason/warning8.C
new file mode 100644
index 00000000000..d6ea821eb90
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/warning8.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+struct A {
+  A();
+  ~A();
+};
+
+struct B {
+  B (const A&);
+  ~B ();
+};
+
+const B& f ()
+{
+  A a;
+  return a;			// WARNING - returning reference to temporary
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.jason/warning9.C b/gcc/testsuite/g++.old-deja/g++.jason/warning9.C
new file mode 100644
index 00000000000..d46ba37650c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.jason/warning9.C
@@ -0,0 +1,13 @@
+// Special g++ Options: -Wsynth
+
+struct A {
+  operator int ();
+  A& operator= (int);		// WARNING - not used below
+};
+
+main()
+{
+  A a, b;
+
+  a = b;			// WARNING - uses synthesized op=
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/access1.C b/gcc/testsuite/g++.old-deja/g++.law/access1.C
new file mode 100644
index 00000000000..75b7ec39808
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/access1.C
@@ -0,0 +1,34 @@
+// Build don't link: 
+// GROUPS passed access
+// access file
+// Message-Id: <9211281852.AA24557@cove.cis.ufl.edu>
+// From: Robert Forsman <thoth@cove.cis.ufl.edu>
+// Subject: method access bug in gcc-2.3.1 on a sparc-sun-sunos4.1.2
+// Date: Sat, 28 Nov 92 13:52:14 EST
+
+extern "C" {
+    int atoi(const char*);
+}
+
+struct thingus;
+
+class foo {
+public:
+  static const foo alpha;
+  static const foo beta;
+
+private:
+  int i;
+  foo(thingus * s);
+public:
+  foo() {i=0;}
+};
+
+struct thingus {
+  int i;
+};
+
+static thingus blah, blah2;
+
+const foo foo::alpha(&blah);
+const foo foo::beta(&blah2);
diff --git a/gcc/testsuite/g++.old-deja/g++.law/access2.C b/gcc/testsuite/g++.old-deja/g++.law/access2.C
new file mode 100644
index 00000000000..22f91845016
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/access2.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed access
+// access file
+// Message-Id: <9306301534.AA05072@sparc1.cnm.us.es>
+// From: juando@cnm.us.es (Juan D. Martin)
+// Subject: Compiler lets access to private constructor in template.
+// Date: Wed, 30 Jun 93 17:34:10 +0200
+
+template <class T> class Foo
+{
+private:
+    friend class Bar; // To avoid warning.
+      Foo(const T &v) {}; // ERROR - private
+};
+
+
+int main()
+{
+    Foo<int>(1);// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/access3.C b/gcc/testsuite/g++.old-deja/g++.law/access3.C
new file mode 100644
index 00000000000..7836fe55edd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/access3.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed access
+// unsorted.2 file
+// Date: Sat, 6 Jun 1992 18:23:03 -0400
+// From: Brendan Kehoe <brendan@cs.widener.edu>
+// Message-Id: <199206062223.AA22653@betty.cs.widener.edu>
+// Subject: bug with access control to member functions
+
+       class X {
+	     void g (int); // ERROR - is private
+        public:
+          void g (double);
+        };
+
+        class Y : public X { void f() { g (1); } };// ERROR - 
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/access4.C b/gcc/testsuite/g++.old-deja/g++.law/access4.C
new file mode 100644
index 00000000000..994a6109bde
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/access4.C
@@ -0,0 +1,27 @@
+// Build don't link: 
+// GROUPS passed access
+// (Message bugs/access:3)
+// From: jamshid@ses.com (Jamshid Afshar)
+// Date:     Wed, 2 Mar 94 18:24:22 CST
+// Subject:  g++ 2.5.5 doesn't warn about inaccessible virtual base ctor
+// Message-ID: <9403030024.AA04534@ses.com>
+
+class ForceLeafSterile {
+    friend class Sterile;
+      ForceLeafSterile() {} // ERROR - 
+};
+
+class Sterile : private virtual ForceLeafSterile {
+public:
+    Sterile() {}
+    Sterile(const char* /*blah*/) {}
+};
+
+class Illegitimate : public Sterile {
+public:
+    Illegitimate() {}           // ERROR -  can't access virtual base deflt ctor
+    Illegitimate(const char* /*blah*/)
+        : ForceLeafSterile() {} // ERROR - can't access default ctor
+    Illegitimate(const Illegitimate&)
+        {}                      // ERROR - can't access default ctor
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/access5.C b/gcc/testsuite/g++.old-deja/g++.law/access5.C
new file mode 100644
index 00000000000..8d25ed2c6a7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/access5.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed access
+// access file
+// From: Jeffrey C. Gealow <jgealow@mtl.mit.edu>
+// Date:     Thu, 18 Feb 93 10:22:23 -0500
+// Subject:  nested class access control bug
+// Message-ID: <9302181522.AA29209@mtl.mit.edu>
+
+
+class enclose {
+public:
+  class nested_public { int x; };
+protected:
+  class nested_protected { int x; };
+private:
+  class nested_private { int x; };
+};
+
+class derived : public enclose {
+  nested_public obj1;     // ok
+  nested_protected obj2;  // ok
+  nested_private obj3;    // error// ERROR - .* , XFAIL *-*-*
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg1.C b/gcc/testsuite/g++.old-deja/g++.law/arg1.C
new file mode 100644
index 00000000000..1712f932f13
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg1.C
@@ -0,0 +1,29 @@
+// Build don't link: 
+// GROUPS passed arg-matching
+// arg-matching file
+// Subject: argument matching depending on the def order
+// From: kondo@akane.mech.ibaraki.ac.jp
+// Date: Fri, 04 Sep 92 17:41:05 JST
+
+#include <iostream.h>
+//  check the order of declarations
+class A {
+public:
+      void f(double* p) { cout << "A(double*)\n"; } // ERROR - candidate
+      void f(int* p) { cout << "A(int*)\n"; } // ERROR - candidate
+};
+
+class B {
+public:
+      void f(int* p) { cout << "B(int*)\n"; } // ERROR - candidate
+      void f(double* p) { cout << "B(double*)\n"; } // ERROR - candidate
+};
+
+int main()
+{
+    A a;
+    B b;
+
+    a.f(0);// ERROR - .*
+    b.f(0);// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg10.C b/gcc/testsuite/g++.old-deja/g++.law/arg10.C
new file mode 100644
index 00000000000..2c21ced1638
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg10.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed arg-matching
+// arg-matching file
+// From: Terry Lee <terry@uivlsisd.csl.uiuc.edu>
+// Date:     Sat, 14 May 1994 02:46:15 -0500
+// Subject:  g++ 2.5.8 template<const void*> bug
+// Message-ID: <199405140746.AA03993@uivlsisd.csl.uiuc.edu>
+
+template<class T>
+class A {
+public:
+    void func(const T& val) { }
+};
+
+int main()
+{
+    A<const void*> a;
+    int* ptr = 0;
+    a.func(ptr);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg11.C b/gcc/testsuite/g++.old-deja/g++.law/arg11.C
new file mode 100644
index 00000000000..4f0868e68a6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg11.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed arg-matching
+// From: gustavo@cpqd.br (Gustavo Chaves)
+// Date:     Wed, 25 May 94 09:38:00 EST
+// Subject:  problem with user defined conversions in initialization
+// Message-ID: <9405251238.AA19815@moon.cpqd.br>
+
+struct String { String(const char*); };
+
+struct Ack { Ack(String); };
+
+struct S { void method(Ack); };	// ERROR - referenced below
+
+void function(Ack);
+
+int
+foo(S *o)
+{ // Neither call has a usable constructor for conversions of char[5] to Ack.
+  function("adsf");// ERROR - 
+  o->method("adsf");// ERROR - 
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg2.C b/gcc/testsuite/g++.old-deja/g++.law/arg2.C
new file mode 100644
index 00000000000..5dbf48389ca
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg2.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed arg-matching
+// arg-matching file
+// Message-Id: <199303032114.AA03574@kolvir.Boulder.ParcPlace.COM>
+// From: Warner Losh <imp@boulder.parcplace.com>
+// Subject: Overloading bug in g++ 2.3.3 (sparc) compiled by GNU C version 2.3.3
+// Date: Wed, 03 Mar 1993 14:14:02 MST
+
+class c1 { };
+
+typedef void    (*fnp)(void *);
+typedef void    (c1::*memfnp)(void *);
+extern  void    fn1( fnp );
+extern  void    fn1( c1*, memfnp );
+
+void f3(void *) { }
+
+void fn2()
+{
+        fn1((fnp) &f3);         // Everybody likes this
+        fn1(&f3);               // g++ complains here  line 13
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg3.C b/gcc/testsuite/g++.old-deja/g++.law/arg3.C
new file mode 100644
index 00000000000..c984d3aa23e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg3.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed arg-matching
+typedef void* Ptr;
+
+
+void func(int, const Ptr& p);
+
+template <class T> void func(T, const Ptr& p);
+
+
+Ptr& return_ref();
+
+
+int main()
+{
+  char* x;
+
+  func(x,return_ref());   // bug:
+                          //         call of      func(int,  const Ptr&)
+                          //         instead of   func(char*,const Ptr&)
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg4.C b/gcc/testsuite/g++.old-deja/g++.law/arg4.C
new file mode 100644
index 00000000000..2d4479deebc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg4.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed arg-matching
+// arg-matching file
+// Message-Id: <14t4tyk@rpi.edu>
+// From: jorgej@colossus.cs.rpi.edu (Joaquim Jorge)
+// Subject: g++ 2.3.3 Doesn't check function types in initializer lists ?
+// Date: Tue, 9 Mar 1993 21:39:08 GMT
+
+typedef void (*FuncPtr)(int a, float b);
+class Amazing { int a; int b; int c; };
+
+extern void *Wrong1(char *a, int *b);
+extern void *Wrong2(Amazing a, int *b);
+extern void *Wrong3(char *a, Amazing *b);
+extern void Wrong4(char *a, int *b);
+extern Amazing Wrong5(char *a, int *b);
+
+FuncPtr p = &Wrong5;// ERROR - .*
+FuncPtr func_ptr_array[] = { &Wrong1, &Wrong2, &Wrong3, &Wrong4, &Wrong5, 0 };// ERROR - .*
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg5.C b/gcc/testsuite/g++.old-deja/g++.law/arg5.C
new file mode 100644
index 00000000000..276068aa8b6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg5.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed arg-matching
+extern double pow(double,int*);
+
+extern "C" {
+  extern int    printf(char*,...);
+  extern double pow(double, double);
+}
+
+int main()
+{
+	if (pow (2.0, 3.0) != 8.0)
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg6.C b/gcc/testsuite/g++.old-deja/g++.law/arg6.C
new file mode 100644
index 00000000000..2ad7732c156
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg6.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed arg-matching
+// arg-matching file
+// Message-Id: <9305032310.AA03900@malachite.bbn.com>
+// From: Dan Franklin <dan@diamond.bbn.com>
+// Subject: overloaded function bug
+// Date: Mon, 3 May 93 19:10:10 EDT
+
+
+    typedef int (*fnp)(int, void*);
+    void dispatch_insert(int, int, fnp, void* = 0);
+    void dispatch_insert(int, int, long*, char*);
+    typedef void (*InsertFunP)(int, int, fnp, void*);
+    extern void f(InsertFunP);
+    void g() { f(dispatch_insert); }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg7.C b/gcc/testsuite/g++.old-deja/g++.law/arg7.C
new file mode 100644
index 00000000000..7ea89ec15fa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg7.C
@@ -0,0 +1,33 @@
+// GROUPS passed arg-matching
+// arg-matching file
+// Message-Id: <9305041759.AA04913@malachite.bbn.com>
+// From: Dan Franklin <dan@diamond.bbn.com>
+// Subject: overloaded function resolved incorrectly
+// Date: Tue, 4 May 93 13:59:18 EDT
+
+#include <stdio.h>
+
+// Given the following overloaded function definitions
+
+void ovf(unsigned long, short,         short) { printf ("PASS\n"); }
+void ovf(          int, short, unsigned long) { printf ("FAIL\n"); }
+
+// and the call
+//
+//   ovf(unsigned long, unsigned int, unsigned int)
+//
+// it seems to me (and to cfront) that this should resolve to ovf #1 above,
+// but g++ resolves it to ovf #2.  Resolving to ovf #1 requires two conversions
+// (unsigned int => short) while resolving to ovf #2 takes two conversions
+// (unsigned long => int, unsigned int => short) and a promotion
+// (unsigned int => unsigned long).
+
+int main(int, char**)
+{
+    unsigned long pixmap = 0;
+    unsigned int x = 0;
+    unsigned int y = 0;
+
+    ovf(pixmap, x, y);
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg8.C b/gcc/testsuite/g++.old-deja/g++.law/arg8.C
new file mode 100644
index 00000000000..802471bae47
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg8.C
@@ -0,0 +1,27 @@
+// GROUPS passed arg-matching
+// arg-matching file
+// Message-Id: <9307081747.AA14030@tnt>
+// From: mclaugh@tnt.acsys.com (Mark A. McLaughlin)
+// Subject: g++ bug
+// Date: Thu, 8 Jul 93 11:47:28 MDT
+
+
+#include <iostream.h>
+#include <stdio.h>
+
+// With this declaration the program will not link.
+template <class Type> ostream & save(ostream & os, Type T);
+
+   template <class Type> ostream &
+save(ostream & os, Type T) {
+   return os << T;
+}  // save
+
+   int
+main() {
+   int i = 10;
+   save((ostream &)cout, i) << endl;
+   short int s = 5;
+   save((ostream &)cout, s) << endl;
+   printf ("PASS\n");
+}  // main
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arg9.C b/gcc/testsuite/g++.old-deja/g++.law/arg9.C
new file mode 100644
index 00000000000..6f5e4b80914
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arg9.C
@@ -0,0 +1,39 @@
+// Build don't link: 
+// GROUPS passed arg-matching
+// arg-matching file
+// Message-Id: <199405132049.QAA06835@elan.cs.UMD.EDU>
+// Subject: Bug in g++ 2.4.5 and 2.5.8
+// Date: Fri, 13 May 1994 16:49:22 -0400
+// From: Evan Rosser <ejr@cs.umd.edu>
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+class TupleIterator {
+public:
+    TupleIterator(int *tpl);
+    int& operator*();
+    int  live() const;
+// The compile fails with "no post-increment operator for type" at "TI++"
+// below.
+// It succeeds with the same declarations if set_position does not take an int.
+// This occurs with G++ 2.4.5 and 2.5.8.
+// Sun CC works OK with either case.
+        void operator++(int);
+        void set_position(int);
+private:
+};
+
+int main() {
+
+int t[5];
+t[1] = 1; t[2] = 2;t[3] = 3;t[4] = 4;
+TupleIterator TI(t);
+
+    while(TI.live()){
+        printf("%d", *TI);
+        TI++;
+    }
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm1.C b/gcc/testsuite/g++.old-deja/g++.law/arm1.C
new file mode 100644
index 00000000000..112c6d80155
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm1.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+// arm file
+// Message-Id: <9211191128.AA14718@us-es.sel.de>
+// From: dcb@us-es.sel.de
+// Subject: ARM p79 trivial bug
+// Date: Thu, 19 Nov 92 12:28:24 +0100
+
+extern "C" int printf( const char *, ...);
+
+int main()
+{
+        int             a = 1 ;
+        int             b = 2 ;
+        int             c = 3 ;
+
+        (a = b) = c ;
+                printf( " %d %d %d\n", a, b, c);
+        return 0 ;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm10.C b/gcc/testsuite/g++.old-deja/g++.law/arm10.C
new file mode 100644
index 00000000000..a57785e55e1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm10.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+// arm file
+// Message-Id: <1oab2hINN7m@gap.caltech.edu>
+// From: tll@cco.caltech.edu (Tal Lewis Lancaster)
+// Subject: ARM Page 65
+// Date: 18 Mar 1993 17:21:21 GMT
+
+int(*p)[10]=new int[20][10];
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm11.C b/gcc/testsuite/g++.old-deja/g++.law/arm11.C
new file mode 100644
index 00000000000..14f6b9d4832
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm11.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+// arm file
+// Message-Id: <9302181055.AA12522@slsvitt>
+// From: dcb@us-es.sel.de (David Binderman 3841)
+// Subject: Page 81 of the ARM
+// Date: Thu, 18 Feb 93 11:55:15 +0100
+
+
+int main() {
+        int x[ 10, 11]; // ERROR - .*
+
+        return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm12.C b/gcc/testsuite/g++.old-deja/g++.law/arm12.C
new file mode 100644
index 00000000000..89e2a4d2c82
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm12.C
@@ -0,0 +1,47 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+// arm file
+// From: belley@cae.ca (Benoit Belley 3218)
+// Subject: Bad access control with private constructor and derivation
+// Date: Fri, 28 May 1993 12:39:57 -0400 (EDT)
+
+#include <iostream.h>
+
+class X
+{
+public:
+  void f();
+
+private:
+  X();
+};
+
+class Y : public X
+{
+public:
+  Y();
+};
+
+X::X()
+{// ERROR - .*
+  cout << "X::X()" << endl;
+}
+
+void X::f()
+{
+  cout << "X::f()" << endl;
+}
+
+Y::Y()
+{// ERROR -  within this
+  cout << "Y::Y()" << endl;
+}
+
+
+int main()
+{
+  Y y;
+  y.f();
+}
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm13.C b/gcc/testsuite/g++.old-deja/g++.law/arm13.C
new file mode 100644
index 00000000000..cf6227830af
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm13.C
@@ -0,0 +1,14 @@
+// GROUPS passed ARM-compliance
+#include <stdio.h>
+#include <stdlib.h>
+
+inline void *operator new(size_t, void *place) { return place; }
+
+int main()
+{
+  int* p = (int*) malloc(sizeof(int));
+  (void) new (p) int(1);
+  p->int::~int();
+  free(p);
+  printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm14.C b/gcc/testsuite/g++.old-deja/g++.law/arm14.C
new file mode 100644
index 00000000000..d50b3cdfd9b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm14.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+// unsorted.2 file
+// Message-Id: <BpBu19.GrF@math.waterloo.edu>
+// Date: Thu, 4 Jun 1992 15:07:56 GMT
+// Subject: access control
+// From: gjditchf@plg.waterloo.edu (Glen Ditchfield)
+
+
+class X {
+  private:
+    enum E1 {a1, b1}; // ERROR - private
+  public:
+    enum E2 {a2, b2};
+    };
+
+void h(X* p) {
+    X::E2 e2;
+    int x2 = X::a2;
+
+    X::E1 e1;                   // Should be rejected, but isn't.// ERROR - .* , XFAIL *-*-*
+    int x1 = X::a1;             // ERROR - Should be rejected, and is.
+    }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm15.C b/gcc/testsuite/g++.old-deja/g++.law/arm15.C
new file mode 100644
index 00000000000..639c1fc5e8b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm15.C
@@ -0,0 +1,53 @@
+// GROUPS passed ARM-compliance
+// arm file
+// From: Johan Bengtsson <jbn@lulea.trab.se>
+// Date:     Thu, 21 Oct 93 16:10:25 +0100
+// Subject:  gcc 2.4.5 initializes base classes in mem-initializer order
+// Message-ID: <9310211510.AA14943@holden.lulea.trab.se>
+
+#include <stdio.h>
+
+int state = 0;
+
+class A { public:
+        A() { 
+		if (state == 0)
+			state = 1;
+		else {
+			printf ("FAIL\n");
+			exit (1);
+		}
+	}
+};
+
+class B { public:
+        B() {
+		if (state == 1)
+			state = 2;
+		else {
+			printf ("FAIL\n");
+			exit (1);
+		}
+	}
+};
+
+class AB : public A, public B { public:
+        AB() : B(), A() { 
+		if (state == 2)
+			state = 3;
+		else {
+			printf ("FAIL\n");
+			exit (1);
+		}
+	}
+};
+
+int main()
+{
+        AB ab;
+	if (state == 3)
+		printf("PASS\n");
+	else
+		printf("FAIL\n");
+	exit (state != 3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm16.C b/gcc/testsuite/g++.old-deja/g++.law/arm16.C
new file mode 100644
index 00000000000..894c37c44e9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm16.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// Special g++ Options: -ansi -Wall -pedantic
+// GROUPS passed ARM-compliance
+// arm file
+// From: Olaf.Weber@cwi.nl
+// Date:     Fri, 2 Dec 1994 09:14:25 +0100
+// Subject:  Omitting & when obtaining a pointer to member function.
+// Message-ID: <9412020814.AA00604=olaf@havik.cwi.nl>
+
+struct C {
+        void foo();
+};
+
+void (C::*pfm)() = C::foo;// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm2.C b/gcc/testsuite/g++.old-deja/g++.law/arm2.C
new file mode 100644
index 00000000000..b679c93c951
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm2.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+// arm file
+// Message-Id: <199301260140.AA13734@world.std.com>
+// From: gparker@world.std.com (Glenn P Parker)
+// Subject: gcc bug
+// Date: Mon, 25 Jan 1993 20:40:44 -0500
+
+int f() {  return 1; }
+
+int main()
+{
+  int (&fr)() = f;
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm3.C b/gcc/testsuite/g++.old-deja/g++.law/arm3.C
new file mode 100644
index 00000000000..3c888bafd7b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm3.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+// arm file
+// Message-Id: <199301260139.AA13555@world.std.com>
+// From: gparker@world.std.com (Glenn P Parker)
+// Subject: gcc bug
+// Date: Mon, 25 Jan 1993 20:39:19 -0500
+
+class X {
+        enum S { blue, pink };
+        int S;
+public:
+        void f (enum S arg) ;
+};
+
+void X::f (enum S arg)
+{
+        S = arg;        // g++ gives error on this line.
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm4.C b/gcc/testsuite/g++.old-deja/g++.law/arm4.C
new file mode 100644
index 00000000000..2fa43c3fc17
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm4.C
@@ -0,0 +1,28 @@
+// GROUPS passed ARM-compliance
+// arm file
+// Message-Id: <199301272139.AA25489@world.std.com>
+// From: kol@world.std.com (Nikolay Yatsenko)
+// Subject: g++ bug
+// Date: Wed, 27 Jan 1993 16:39:10 -0500
+
+extern "C" int printf(const char*,...);
+int count = 0;
+
+struct S {
+  int i;
+  S(int b)      {
+    i = b;
+    count++; }
+};
+
+int main(void)
+{
+  double a = 2.0;
+
+  S x(int (a));
+  if (count > 0)
+    printf ("FAIL\n");
+  else
+    printf ("PASS\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm5.C b/gcc/testsuite/g++.old-deja/g++.law/arm5.C
new file mode 100644
index 00000000000..d39b476a840
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm5.C
@@ -0,0 +1,24 @@
+// GROUPS passed ARM-compliance
+// arm file
+// Message-Id: <9212072127.AA24243@us-es.sel.de>
+// From: dcb@us-es.sel.de
+// Subject: page 78 of the ARM
+// Date: Mon, 7 Dec 92 22:27:09 +0100
+
+extern "C" int printf( const char *, ...);
+
+int & max( int & a, int & b) {
+        return (a < b) ? b : a;
+}
+
+int main( void) {
+        int a = 1;
+        int b = 2;
+        int & c = max( a, b);
+
+        if (&c == &b)
+                printf( "PASS\n");
+        else
+                printf( "FAIL\n");
+        return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm6.C b/gcc/testsuite/g++.old-deja/g++.law/arm6.C
new file mode 100644
index 00000000000..e1715ee4bea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm6.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+// arm file
+// Message-Id: <9211231051.AA11287@us-es.sel.de>
+// From: dcb@us-es.sel.de
+// Subject: ARM page 87
+// Date: Mon, 23 Nov 92 11:51:38 +0100
+
+
+int main() {
+        int a;
+
+        switch (a) {
+        case 1:
+                int v2 = 3;// ERROR -    crosses.*
+        case 2:// ERROR -  jump.*
+                if (v2 == 7)    // error not flagged by 2.3.1
+                        ;
+        }
+
+        return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm7.C b/gcc/testsuite/g++.old-deja/g++.law/arm7.C
new file mode 100644
index 00000000000..1f3d43056ad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm7.C
@@ -0,0 +1,41 @@
+// Special g++ Options: -w
+// GROUPS passed ARM-compliance
+// arm file (also in cvt file)
+// Message-Id: <9303061246.AA09402@gjetost.cs.wisc.edu>
+// From: solomon@cs.wisc.edu (Marvin Solomon)
+// Subject: Incorrect resolution of conversion path
+// Date: Sat, 6 Mar 93 06:46:27 -0600
+
+
+extern "C" void printf(const char *,...);
+
+class Base {
+public:
+	int i;
+	Base(int ii) : i(ii) {}
+};
+
+class Derived : public Base {
+public:
+	Derived(int ii) : Base(ii) {}
+	operator Base&();
+};
+
+Derived::operator Base&() {
+	Base *b = new Base(100*i);
+	return *b;
+}
+
+void f(Base &b) {
+	if (b.i == 99)
+	  printf ("PASS\n");
+	else
+	  printf ("FAIL\n");
+}
+
+int main() {
+	Derived d(99);
+	f(d);
+	return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm8.C b/gcc/testsuite/g++.old-deja/g++.law/arm8.C
new file mode 100644
index 00000000000..ef340c6b24e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm8.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+// arm file
+// Message-Id: <9303161105.AA29336@slsvitt>
+// From: dcb@us-es.sel.de (David Binderman 3841)
+// Subject: Page 141 of the ARM
+// Date: Tue, 16 Mar 93 12:05:24 +0100
+
+struct K {
+      void f( int *p  = 0); // ERROR - previous specification
+};
+
+extern int * q;
+
+void K::f( int *p = q);// ERROR - .*
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/arm9.C b/gcc/testsuite/g++.old-deja/g++.law/arm9.C
new file mode 100644
index 00000000000..35658b17cbc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/arm9.C
@@ -0,0 +1,33 @@
+// Build don't link: 
+// GROUPS passed ARM-compliance
+#include        <iostream.h>
+enum f1 {
+     F1
+};
+
+enum f2 {
+    F2
+};
+
+class A {
+public:
+    void set (f1 f);
+};
+void A::set (f1 f) { cout << "called A f1\n";}
+
+class B : public A {
+public:
+    void set (f2 f);
+};
+void B::set (f2 f) { cout << "called B\n";} // ERROR - candidate
+
+int main() {
+    B b;
+    b.set(F1); // ARM page 309: should call A.set(f1) and that what g++ does,// ERROR - .*
+               // but 13.1 of ARM clearly states that it should call B::set()
+               // or generate an error because overloading works only for
+               // functions within the same scope (first page of chapter 13)
+               // while member of derived and base classes are considered to
+               // belong to different scopes.  Thus B::set() should have
+               // hidden (completely) the A::set() function.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/array1.C b/gcc/testsuite/g++.old-deja/g++.law/array1.C
new file mode 100644
index 00000000000..13250c63420
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/array1.C
@@ -0,0 +1,31 @@
+// GROUPS passed arrays
+// array file
+// Message-Id: <9204120353.AA06266@cs.rice.edu>
+// From: dougm@cs.rice.edu (Doug Moore)
+// Subject: constructors not called on new'ed array elements
+// Date: Sat, 11 Apr 92 22:53:35 CDT
+
+#include <stdio.h>
+
+int i = 0;
+
+class foo
+{
+private:
+  static foo *array;
+public:
+  foo()
+    {
+      i++;
+    }
+};
+
+foo* foo::array = new foo [5];
+
+int main()
+{
+  if (i != 5)
+    printf ("FAIL\n");
+  else
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/array2.C b/gcc/testsuite/g++.old-deja/g++.law/array2.C
new file mode 100644
index 00000000000..0147a4a2bae
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/array2.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed arrays
+// excess errors test - XFAIL *-*-*
+// array file
+// Message-Id: <"nac.no.188:05.10.92.14.37.45"@nac.no>
+// From: frode@auticon.no
+// Subject: prototype bug ?
+// Date: Thu, 5 Nov 92 15:37:34 PST
+
+        extern unsigned char * (*trt_def(int))[][2];
+        extern unsigned char * (trt_rplst(unsigned char *(*)[][2]));
diff --git a/gcc/testsuite/g++.old-deja/g++.law/bad-error1.C b/gcc/testsuite/g++.old-deja/g++.law/bad-error1.C
new file mode 100644
index 00000000000..09a68788549
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/bad-error1.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed bad-errors
+// bad-error file
+// Message-Id: <9301081103.AA29469@jclark.com>
+// From: jjc@jclark.com (James Clark)
+// Subject: initializer for static class member array
+// Date: Fri, 8 Jan 93 11:03:05 GMT
+
+struct A {
+  static int v[];
+};
+
+int A::v[1] = { 1 };
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/bad-error3.C b/gcc/testsuite/g++.old-deja/g++.law/bad-error3.C
new file mode 100644
index 00000000000..c5ce1188d00
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/bad-error3.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed bad-errors
+// bad-error file
+// Date: Sun, 31 Jul 1994 11:37:43 +1000 (EST)
+// From: Rohan LENARD <rjl@iassf.easams.com.au>
+// Subject: g++-2.6.0 gives wrong warning for placement syntax new
+// Message-Id: <0iCk1b0000000z0VY0@iassf.easams.com.au>
+
+
+#include <stddef.h>
+
+void * operator new(size_t, int *);
+void * operator new(size_t, void *);
+
+int *x = 0;
+int foo(){
+new (x) int *;
+new (&x) int *;
+new (x) int *;  // This is identical to line 8 !!!
+return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/bad-error4.C b/gcc/testsuite/g++.old-deja/g++.law/bad-error4.C
new file mode 100644
index 00000000000..09461c8db7c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/bad-error4.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed bad-errors
+#include <stddef.h>
+
+void * operator new(size_t, int *);
+void * operator new(size_t, void *);
+
+int *x = 0;
+int foo(){
+new (x) int *;
+new (&x) int *;
+new (x) int *;  // This is identical to line 8 !!!
+return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/bad-error6.C b/gcc/testsuite/g++.old-deja/g++.law/bad-error6.C
new file mode 100644
index 00000000000..497a49d8700
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/bad-error6.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+// GROUPS passed bad-errors
+typedef __SIZE_TYPE__ size_t;
+
+class tt {
+    public:
+    tt(int);
+
+    private:
+    void *operator new(size_t a); // Forbid object creation in heap memory.
+};
+
+void st(const tt&, int);
+
+void ff(int i, int j)
+{
+    if( i > 0 ) {
+        // This work ok.
+        tt a_tt(i);
+        st(a_tt, j);
+    }
+    else {
+        // This triggers an error because of private operator new ????.
+        st(tt(-i), j);
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/bad-error7.C b/gcc/testsuite/g++.old-deja/g++.law/bad-error7.C
new file mode 100644
index 00000000000..434921dd72d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/bad-error7.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed bad-errors
+#include <iostream.h>
+
+class ParX
+        {
+        public:
+                ParX() {}
+        };
+
+class X : public ParX
+        {
+        public:
+                void fn2() { cout << "hi" << endl; }
+        };
+
+int main()
+        {
+        X               x;
+        ParX*   pParX                   = &x;
+        void    (ParX::*p)()    = (void (ParX::*)()) &X::fn2;    // line 19
+
+        (pParX->*p)();
+        }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/bit-fields1.C b/gcc/testsuite/g++.old-deja/g++.law/bit-fields1.C
new file mode 100644
index 00000000000..ed100af3816
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/bit-fields1.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed bit-fields
+typedef int A;
+
+struct B
+{
+    int A : 2;
+} ;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/bit-fields2.C b/gcc/testsuite/g++.old-deja/g++.law/bit-fields2.C
new file mode 100644
index 00000000000..beb34d05ba1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/bit-fields2.C
@@ -0,0 +1,36 @@
+// GROUPS passed bit-fields
+// bitfield file
+// Message-Id: <92Oct29.191913est.62@jarvis.csri.toronto.edu>
+// From: mdivax1!robinson@ai.mit.edu (Jim Robinson)
+// Subject: gcc 2.2.2 C++ bug in handling :0 bit fields
+// Date:   Thu, 29 Oct 1992 19:18:28 -0500
+//
+// Also applies to:
+// bitfield file
+// From: Jaimie Wilson/MSL <Jaimie_Wilson@msl.isis.org>
+// Date:   Fri, 28 Jan 1994 06:11:43 -0500
+// Subject: GCC bug report
+
+
+#include <stdio.h>
+#include <stddef.h>
+
+struct foo {
+        char a;
+        char b;
+        unsigned int : 0;       /* force word alignment */
+        char c;
+};
+
+int
+main(int argc, char **argv)
+{
+        struct foo bar;
+
+	if (offsetof (struct foo, c) > sizeof (unsigned int))
+		printf ("FAIL\n");
+	else
+		printf ("PASS\n");
+	return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/bit-fields3.C b/gcc/testsuite/g++.old-deja/g++.law/bit-fields3.C
new file mode 100644
index 00000000000..7c7e6940e82
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/bit-fields3.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed bit-fields
+  class t {
+      short           :(sizeof(short)-2);
+    public:
+      t();
+  };
diff --git a/gcc/testsuite/g++.old-deja/g++.law/builtin1.C b/gcc/testsuite/g++.old-deja/g++.law/builtin1.C
new file mode 100644
index 00000000000..e9b465422cf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/builtin1.C
@@ -0,0 +1,17 @@
+// GROUPS passed builtins
+// Apparently not in g++ bug snapshot (was originally sent to bug-gcc)
+// Message-Id: <m0p74Fh-0002fCC@neal.ctd.comsat.com>
+// Date: Tue, 7 Dec 93 10:23 EST
+// From: neal@ctd.comsat.com (Neal Becker)
+// Subject: builtin_alloca on hpux (gcc-2.5.6)
+// We have to avoid using -ansi, which results in a call to alloca instead of
+//  the use of __builtin_alloca, and thus ends up being unresolved.
+// Special g++ Options: 
+
+extern "C" void* alloca( __SIZE_TYPE__ );
+extern "C" int printf (const char *, ...);
+
+void* junk() {
+  return alloca(10);
+}
+main() { printf ("PASS\n");}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/casts1.C b/gcc/testsuite/g++.old-deja/g++.law/casts1.C
new file mode 100644
index 00000000000..9cfeaa1a42d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/casts1.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed casts
+// casts file
+// From: dcb@us-es.sel.de (David Binderman 3841)
+// Date:     Thu, 18 Feb 93 14:42:48 +0100
+// Subject:  Page 67 of the ARM
+// Message-ID: <9302181342.AA14050@slsvitt>
+
+int main() {
+   (struct T { int b; } *) 0;      // ERROR - 
+
+        return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/casts2.C b/gcc/testsuite/g++.old-deja/g++.law/casts2.C
new file mode 100644
index 00000000000..11a36b9f5c2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/casts2.C
@@ -0,0 +1,39 @@
+// Build don't link: 
+// GROUPS passed casts
+class VObject;
+
+typedef int boolean;
+
+typedef boolean (VObject::*method)();
+typedef boolean (VObject::*method0)();
+typedef boolean (VObject::*method1)(long);
+
+#define methodOf(o,m)  (method)(&o::m)
+
+
+class VObject {
+    public:
+    boolean perform(method );
+    boolean perform(method , long);
+    void    affectMethod(method );
+    void    dummy(){};
+};
+
+
+boolean VObject::perform(method m)
+{
+        method0 q = (method0)m;
+        return(this->*q)();
+}
+
+
+boolean VObject::perform(method m, long param)
+{
+        method1 q = (method1)m;
+        return(this->*q)(param);
+ }
+
+void VObject::affectMethod(method m)
+{
+        m =   methodOf(VObject, dummy);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/casts3.C b/gcc/testsuite/g++.old-deja/g++.law/casts3.C
new file mode 100644
index 00000000000..e76f61c998d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/casts3.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed casts
+// casts file
+// From: fjh@cs.mu.oz.au
+// Message-Id: <9310121939.29641@munta.cs.mu.OZ.AU>
+// Subject: should emit diagnostic for `int *p = (void *)0;'
+// Date: Wed, 13 Oct 93 5:39:35 EST
+        int *p = (void *)0;// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.law/code-gen1.C b/gcc/testsuite/g++.old-deja/g++.law/code-gen1.C
new file mode 100644
index 00000000000..0f7c6102164
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/code-gen1.C
@@ -0,0 +1,20 @@
+// GROUPS passed code-generation
+// code-gen file
+// From: Jeffrey C. Gealow <jgealow@mtl.mit.edu>
+// Date:     Sun, 4 Jul 93 18:57:53 -0400
+// Subject:  increment bug (0 + 1 + 1 = 3)
+// Message-ID: <9307042257.AA23538@mtl.mit.edu>
+
+#include <stdio.h>
+
+int main()
+{
+  int i = 0;
+  (++i)++;
+  if (i == 2)
+    printf ("PASS\n");
+  else
+    printf ("FAIL\n");
+}
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/code-gen2.C b/gcc/testsuite/g++.old-deja/g++.law/code-gen2.C
new file mode 100644
index 00000000000..88dd13fd7ef
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/code-gen2.C
@@ -0,0 +1,34 @@
+// GROUPS passed code-generation
+// code-gen file
+// From: Gunther Seitz <Gunther.Seitz@regent.e-technik.tu-muenchen.dbp.de>
+// Date:     Thu, 18 Mar 1993 10:45:29 +0100
+// Message-ID: <93Mar18.104538met.1094@regatta.regent.e-technik.tu-muenchen.de>
+
+
+#include <stdio.h>
+
+class X {
+
+public:
+    double x;
+    X () { x=3.5; }    // Here we go. This assignment fails because
+                       // of X::x being aligned on a doubleword
+                       // boundary, not a quadword one.
+    };
+
+
+class A : public virtual X {};       // Only way to produce the
+class B : public virtual X {};       // error is to use this
+class C : public virtual X {};       // construct of virtual
+                                     // base classes.
+
+class Y : public A, public B, public C {};
+
+
+int main ()
+{
+        Y y;       // To call the constructor
+	printf ("PASS\n");
+        }
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/code-gen4.C b/gcc/testsuite/g++.old-deja/g++.law/code-gen4.C
new file mode 100644
index 00000000000..c060d660300
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/code-gen4.C
@@ -0,0 +1,30 @@
+// GROUPS passed code-generation
+// code-gen file
+// From: david.binderman@pmsr.philips.co.uk
+// Date:     Tue, 17 Aug 93 10:09:38 BST
+// Subject:  .* broken in 2.4.5
+// Message-ID: <9308170909.AA05509@pmsr.philips.co.uk>
+
+class A {
+public:
+        char c;
+};
+
+typedef char A::*PMA;
+
+PMA pmA = &A::c;
+
+A oA;
+
+extern "C" int printf( const char *, ...);
+
+int main()
+{
+        oA.c = 'q';
+
+        if ( (oA .* pmA))
+                        printf( "PASS\n");
+        else
+                        printf(" FAIL\n");
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/code-gen5.C b/gcc/testsuite/g++.old-deja/g++.law/code-gen5.C
new file mode 100644
index 00000000000..023b6237808
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/code-gen5.C
@@ -0,0 +1,283 @@
+// GROUPS passed code-generation
+// code-gen file
+// From: "David" <norman@pi14.arc.umn.edu>
+// Date:     Mon, 15 Nov 1993 20:59:14 -0600 (CST)
+// Subject:  An error!
+// Message-ID: <9311160259.AA03353@pi14.arc.umn.edu>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include <fstream.h>
+#include <iostream.h>
+#include <math.h>
+
+#define ANSI_C
+
+typedef double VEC ;
+
+class Vector;
+
+class VectorInt 
+{
+	public:
+
+	/* Nothing public!! Only Vector can use this class */
+
+	private:
+
+	VectorInt( int );
+	VectorInt( int, double *, int = 0 );
+	VectorInt( const VectorInt & );
+	~VectorInt();
+
+	VectorInt *refer();
+	void unrefer();
+	int count;				/* Number of Vector's refering to me */
+
+	VEC *vec;
+
+	friend class Vector;
+	friend class VecElem;
+};
+
+class VecElem 
+{
+	public:
+	
+	operator double();
+	double operator=( double );
+
+	private:
+
+	VecElem( Vector &, int );
+	VecElem( const VecElem & );
+
+	Vector &v;
+	int row;						/* Row element refers to */
+
+	friend class Vector;
+};
+
+class Vector 
+{
+	public:
+
+	Vector();					// Must be assigned to before used
+	Vector( VectorInt * );
+	Vector( int );
+	Vector( int, double *, int beg = 0 );
+	Vector( const Vector & );
+	Vector &operator=( const Vector & );
+	~Vector() { if(r) r->unrefer(); };
+
+	int row() const { return 19; }
+	int dim() const { return 10; }
+
+	double operator()( int ) const;
+	VecElem operator()( int );
+
+	double assign( int, double );
+
+	friend ostream& operator<<( ostream&, const Vector& m );
+	
+	private:
+
+	VectorInt *r;			/* Reference to real data */
+
+	friend class VecElem;
+	friend class LUDecom;
+	friend class SVD;
+};
+
+
+Vector::
+Vector()
+	: r(0)
+{}
+
+Vector::
+Vector( VectorInt *vi )
+	: r(vi)
+{
+	r->refer();
+}
+
+Vector::
+Vector( int row )
+{
+	assert( row > 0 );
+
+	r = new VectorInt( row );
+
+	r->refer();
+}
+
+Vector::
+Vector( int row, double *d, int beg )
+{
+	assert( row > 0 );
+
+	r = new VectorInt( row, d, beg );
+
+	r->refer();
+}
+
+Vector::
+Vector( const Vector &A )
+	: r( A.r->refer() )
+{}
+
+Vector& Vector::
+operator=( const Vector &A )
+{
+	if( r )
+		r->unrefer();
+
+	r = A.r->refer();
+
+	return *this;
+}
+
+double Vector::
+operator()( int row ) const
+{
+	assert( r );
+
+	return *r->vec;
+}
+
+VecElem Vector::
+operator()( int r )
+{
+	assert(r);
+
+	return VecElem( *this, r );
+}
+
+	/* assign changes the matrix, it does not create a new one! */
+double Vector::
+assign( int rownum, double d )
+{
+	assert(r);
+
+	if( rownum > row() || rownum <= 0 ) {
+		cerr << "Warning: trying to assign out of bounds" << endl;
+		cerr << "row " << rownum << endl;
+		cerr << "Vector size " << row() << endl;
+		abort();
+	}
+
+	if( r->count == 1 ) {
+			/* Don't need to create a new matrix, since we are the only */
+			/*  one pointing to ours 									*/
+	}
+	else {
+		VectorInt *vi = new VectorInt( *r );
+		r->unrefer();
+		r = vi->refer();
+	}
+
+	return d;
+}
+
+
+VectorInt::
+VectorInt( int sx )
+	: vec( new double[sx] ), count(0)
+{ }
+
+VectorInt::
+VectorInt( int sx, double *, int )
+	: vec( new double[sx] ), count(0)
+{
+}
+
+VectorInt::
+VectorInt( const VectorInt & )
+	: vec( new double[10] ), count(0)
+{
+}
+
+VectorInt * VectorInt::
+refer()
+{
+	count ++;
+	return this;
+
+	// cout << "Refering vec" << endl;
+}
+
+void VectorInt::
+unrefer()
+{
+	count--;
+
+	if( count == 0 ) {
+		delete this;
+	}
+
+	// cout << "Unrefering vec" << endl;
+}
+
+VectorInt::
+~VectorInt()
+{
+	delete vec;
+	vec = 0;
+}
+
+VecElem::
+VecElem( Vector &vec, int r )
+	: v(vec), row(r)
+{
+	if( r < 1 || r > vec.row() ) {
+		cerr << "Trying to access vector element out of bounds" << endl;
+		abort();
+	}
+}
+
+VecElem::
+VecElem( const VecElem &elem )
+	: v(elem.v), row(elem.row)
+{}
+
+VecElem::
+operator double()
+{
+	assert( v.r->vec );
+	return *v.r->vec;
+};
+
+double VecElem::
+operator=( double d )
+{
+	return v.assign( row, d );
+}
+
+
+
+
+
+int makeforms( Vector cen, Vector **a, Vector **b );
+
+int main()
+{
+	Vector *a[8], *b[8], disp(3);
+	Vector cen(3), cen2(3);
+	int i, j;
+
+	if (makeforms (cen,a,b) != 10)
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+
+
+}
+
+int
+makeforms( Vector cen, Vector **a, Vector **b)
+{
+	return 10;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/copy1.C b/gcc/testsuite/g++.old-deja/g++.law/copy1.C
new file mode 100644
index 00000000000..5cea11ab38a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/copy1.C
@@ -0,0 +1,66 @@
+// GROUPS passed copy-ctors
+#include <stdio.h>
+
+int pass = 0;
+class name {
+  int namestuff;
+public:
+  name() {
+    namestuff = 111;
+  }
+  name(const name& subject);
+  
+  name & operator = (const name& right) {
+    this->namestuff = right.namestuff;
+    return *this;
+  }
+  
+  ~name() {
+    ;
+  }
+};
+
+name::name(const name& subject) {
+    pass = 1;
+}
+
+class person {
+  int personstuff;
+  name personname;
+public:
+  person() {
+    ;
+    personstuff = 222;
+  }
+  ~person() {
+    ;
+  }	
+  void print() {
+    ;
+  }
+  
+};
+
+void
+test(person argp)
+{
+  person testp;
+  
+  ;
+  argp.print();
+  testp = argp;
+  argp.print();
+  testp.print();
+  ;
+}
+
+int main()
+{
+  person mainp;
+  test(mainp);
+  if (pass)
+    printf ("PASS\n");
+  else
+    printf ("FAIL\n");
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/copy2.C b/gcc/testsuite/g++.old-deja/g++.law/copy2.C
new file mode 100644
index 00000000000..3935cfd557d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/copy2.C
@@ -0,0 +1,35 @@
+// Build don't link: 
+// GROUPS passed copy-ctors
+// copy file
+// From: Vivek Khera <khera@cs.duke.edu>
+// Date:     Mon, 15 Nov 1993 16:02:18 -0500
+// Subject:  g++ 2.5.3 fails to automatically generate default initializer
+// Message-ID: <9311152102.AA21248@thneed.cs.duke.edu>
+
+class String
+{
+  private:
+    char a[100];
+    int len;
+  public:
+    String();
+};
+
+String::String()
+{
+    len = 0;
+}
+
+
+struct List
+{
+    String item[100];
+    int num_items;
+//    List();                   // uncomment this line to let compile work
+};
+
+int
+main(int argc, char **argv)
+{
+    List a;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors1.C b/gcc/testsuite/g++.old-deja/g++.law/ctors1.C
new file mode 100644
index 00000000000..79ca94aa9b9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors1.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctor file
+// From: rac@qedinc.com (Robert Clark)
+// Date:     Tue, 14 Dec 93 10:45:50 PST
+// Subject:  bug in g++ 2.5.7 Array of objects
+// Message-ID: <9312141845.AA09188@annapurna.qedinc.com>
+
+
+class POOL {
+public:
+  POOL();
+};
+
+struct VAL_LIST {
+  POOL   pool[2];
+};
+
+VAL_LIST baz;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors10.C b/gcc/testsuite/g++.old-deja/g++.law/ctors10.C
new file mode 100644
index 00000000000..213b7988b48
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors10.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctor file
+// Message-Id: <9302052351.AA10789@harvey>
+// From: greg@qualcomm.com (Greg Noel)
+// Subject: bug019.cc
+// Date: Fri, 5 Feb 93 15:51:42 -0800
+
+#include <iostream.h>
+
+class Class
+{
+        class Err : public ostream
+        {
+        public:
+                Err(void) : ostream() { }
+                ~Err(void) { }
+        };
+public:
+        //template<class T> Err& operator << (const T x) { return Err() << x; }
+        Err& operator << (const char *x) { return Err() << x; }// ERROR - .*
+private:
+        char x;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors11.C b/gcc/testsuite/g++.old-deja/g++.law/ctors11.C
new file mode 100644
index 00000000000..3c393561f6a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors11.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctor file
+// Message-Id: <9302081631.AA14744@tera.com>
+// From: rrh@tera.com (Robert R. Henry)
+// Date: Mon, 8 Feb 93 08:31:39 PST
+extern "C" void printf(const char *,...);
+class A{
+public:
+  inline A(int x){printf("constructing A with %d\n", x);}
+};
+
+class B:public A{
+private:
+public:
+}; // ERROR - non-default constructor
+
+int main()
+{
+  B(10);// ERROR - B doesn't have a constructor taking int
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors12.C b/gcc/testsuite/g++.old-deja/g++.law/ctors12.C
new file mode 100644
index 00000000000..32bf5c6ba90
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors12.C
@@ -0,0 +1,33 @@
+// GROUPS passed constructors
+#include <stdio.h>
+#include <stdlib.h>
+#include <iostream.h>
+
+#define MAGIC 7654
+
+class complex {
+        double re;
+        double im;
+        int magic;
+        static int count;
+public:
+        complex() { re=im=0; magic=MAGIC; }
+        complex(double d) { re=d; im=0; magic=MAGIC; }
+        complex(double d, double d2) {re=d; im=d2; magic=MAGIC; }
+        ~complex() {if(magic!=MAGIC) {printf("FAIL\n");exit(0);}}
+        friend ostream& operator << (ostream& o, const complex& c)
+                { return o << "(" << c.re << "," << c.im << ")"; }
+};
+
+int complex::count=0;
+
+int main()
+{
+        complex v[6] = {1, complex(1,2), complex(), 2 }; // ARM Sect. 12.6.1
+        int i;                                           // page 289
+
+        for(i=0; i<6; i++) ;
+	printf ("PASS\n");
+
+        return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors13.C b/gcc/testsuite/g++.old-deja/g++.law/ctors13.C
new file mode 100644
index 00000000000..aef721be7ce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors13.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed constructors
+#include <iostream.h>
+
+class A {
+   A() {}    // private constructor// ERROR - .*
+};
+
+int main() {
+  A* a = new A();// ERROR - .*
+  if (a) {
+     cout << "a != NULL\n";
+  } else {
+     cout << "a == NULL\n";
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors14.C b/gcc/testsuite/g++.old-deja/g++.law/ctors14.C
new file mode 100644
index 00000000000..49abdf79edb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors14.C
@@ -0,0 +1,43 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctor file
+// Message-Id: <199301310203.AA22417@oak.ucsc.edu>
+// From: "Dean R. E. Long" <dlong@cse.ucsc.edu>
+// Subject: problems with default constructors
+// Date: Sat, 30 Jan 1993 18:03:32 -0800
+
+class A0 {
+};
+
+class A1 {
+public:
+    A1(void) {}
+};
+
+class A2 {
+    A1 a;
+};
+
+class B0 : public A0 {
+public:
+    B0(void) {}
+    B0(int)  {}
+    B0(char) : A0() {}
+    B0(short) : A0() {}
+};
+
+class B1 : public A1 {
+public:
+};
+
+class B2 : public A2 {
+public:
+    B2(void) : A2() {}
+    B2(int)  : A2() {}
+};
+
+class C : public B1 {
+public:
+    C(void) : B1() {}
+    C(int)  : B1() {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors15.C b/gcc/testsuite/g++.old-deja/g++.law/ctors15.C
new file mode 100644
index 00000000000..32da1418f3d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors15.C
@@ -0,0 +1,26 @@
+// GROUPS passed constructors
+// ctor file
+// Message-Id: <9303270404.28207@munta.cs.mu.OZ.AU>
+// From: fjh@cs.mu.oz.au
+// Subject: bug with new/delete of multidimensional array
+// Date: Sat, 27 Mar 93 14:04:52 EST
+
+#include <stdio.h>
+#include <stdlib.h>
+
+int construct = 0;
+
+class Element {
+public:
+    Element() { construct++; if (construct > 6) {printf ("FAIL\n"); exit(1);}}
+    ~Element() { }
+};
+
+typedef Element array[2];
+
+int main() {
+    array *x;
+    x = new array[3];
+    delete x;
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors16.C b/gcc/testsuite/g++.old-deja/g++.law/ctors16.C
new file mode 100644
index 00000000000..8a3982b15e0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors16.C
@@ -0,0 +1,49 @@
+// GROUPS passed constructors
+// ctor file
+// Message-Id: <9306021533.AA14347@icepick.jts.com>
+// From: roland@jts.com (Roland Knight )
+// Subject: gcc 2.4.1 bug
+// Date:   Wed, 2 Jun 1993 11:33:34 -0400
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+char stuff[50];
+char *p = stuff;
+
+class A {
+public:
+    A() { *p++ = 'A';}
+};
+
+class B {
+public:
+    B() { *p++ = 'B'; }
+};
+
+class C : public A, public B {
+public:
+    C() : B(), A() { *p++ = 'C'; }
+};
+
+class D : public A, public B {
+public:
+    D() : B() { *p++ = 'D'; }
+};
+
+class E : public A, public B {
+public:
+    E() { *p++ = 'E'; }
+};
+
+
+int main() {
+    C c;
+    D d;
+    E e;
+    if (strncmp ("ABCABDABE", stuff, 9))
+	printf ("FAIL\n");
+    else
+	printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors17.C b/gcc/testsuite/g++.old-deja/g++.law/ctors17.C
new file mode 100644
index 00000000000..eab071c1248
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors17.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctor file
+// Message-Id: <199306151813.gD28471@mail.Germany.EU.net>
+// From: stephan@ifconnection.de (Stephan Muehlstrasser)
+// Subject: gcc 2.4.3.1: illegal constructor call not rejected
+// Date: Tue, 15 Jun 1993 18:34:14 +0200 (MET DST)
+
+
+#include <fstream.h>
+
+class X : public ifstream {
+    public:
+      X(int a, char *b) {} // ERROR - candidate
+}; // ERROR - candidate
+int main()
+{
+    X *y = new X(10, "123");
+    // the compiler must reject this constructor call:
+    X *x = new X("abc");// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors18.C b/gcc/testsuite/g++.old-deja/g++.law/ctors18.C
new file mode 100644
index 00000000000..e7a666e3e80
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors18.C
@@ -0,0 +1,27 @@
+// Build don't link: 
+// GROUPS passed constructors
+class test1 {
+};
+
+template<class T>
+class GC_PTR {
+public:
+  GC_PTR(T &a) {}
+};
+
+
+void
+gotPtrs(GC_PTR<test1> r1)
+{
+}
+
+static void
+short_alloc(int n)
+{
+        test1 here;
+        GC_PTR<test1> foo = here;   // This works fine.
+
+        gotPtrs(here);              // Compile error from this
+        // No constructor named `GC_PTR` in visible scope
+        // conversion between incompatible aggregate types requested
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors19.C b/gcc/testsuite/g++.old-deja/g++.law/ctors19.C
new file mode 100644
index 00000000000..25c58d6954f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors19.C
@@ -0,0 +1,33 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctor file
+// From: mkohtala@vinkku.hut.fi
+// Date: Tue, 5 Oct 1993 19:31:16 +0200
+// Message-Id: <199310051731.AA12260@lk-hp-11.hut.fi>
+// Subject: Nested class constructor calling bug
+
+class X
+{
+  public:
+    class Y
+    {
+      public:
+        Y(int i) : a(i) {}
+        int a;
+    };
+    static void f(Y y);
+};
+
+void X::f(X::Y y)
+{
+}
+
+int
+main()
+{
+    X::Y y = X::Y(1);   // Tries to call ctor Y instead of X::Y
+    X::f(X::Y(2));      // Tries to call Y instead of X::Y
+
+    return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors2.C b/gcc/testsuite/g++.old-deja/g++.law/ctors2.C
new file mode 100644
index 00000000000..d4f2d9cdabb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors2.C
@@ -0,0 +1,69 @@
+// GROUPS passed constructors
+// Message-Id: <m0p8Am6-0002fCC@neal.ctd.comsat.com>
+// Date: Fri, 10 Dec 93 11:33 EST
+// From: neal@ctd.comsat.com (Neal Becker)
+// Subject: serious problems with static constructors
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define CONST const
+
+class Sig {
+
+public:
+
+  enum Type { Byte_t, Word_t, Long_t, Float_t, Double_t, Complex_t, ComplexLong_t, Bad_t };
+
+private:
+
+  Type T;
+
+public:
+
+  static CONST char *ByteMagic, *WordMagic, *LongMagic,
+    *FloatMagic, *DoubleMagic, *ComplexMagic, *ComplexLongMagic, *BadMagic;
+
+  struct SigTable {
+    Type T;
+    CONST char* Magic;
+  };
+
+  static CONST SigTable sigTable[];
+
+};
+
+CONST char 
+*Sig::ByteMagic = "BYTE",
+*Sig::WordMagic = "WORD",
+*Sig::LongMagic = "LONG",
+*Sig::FloatMagic = "FLOA",
+*Sig::DoubleMagic = "DOUB",
+*Sig::ComplexMagic = "COMP",
+*Sig::ComplexLongMagic = "CMPL",
+*Sig::BadMagic = NULL;
+
+
+CONST Sig::SigTable Sig::sigTable[] = {
+  { Byte_t, ByteMagic },
+  { Word_t, WordMagic },
+  { Long_t, LongMagic },
+  { Float_t, FloatMagic },
+  { Double_t, DoubleMagic },
+  { Complex_t, ComplexMagic },
+  { ComplexLong_t, ComplexLongMagic },
+  { Bad_t, BadMagic }
+};
+
+int main() {
+  if (strcmp (Sig::sigTable[0].Magic, "BYTE")
+      || strcmp (Sig::sigTable[1].Magic, "WORD")
+      || strcmp (Sig::sigTable[2].Magic, "LONG")
+      || strcmp (Sig::sigTable[3].Magic, "FLOA")
+      || strcmp (Sig::sigTable[4].Magic, "DOUB")
+      || strcmp (Sig::sigTable[5].Magic, "COMP"))
+    printf ("FAIL\n");
+  else
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors20.C b/gcc/testsuite/g++.old-deja/g++.law/ctors20.C
new file mode 100644
index 00000000000..34dbf7bf023
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors20.C
@@ -0,0 +1,35 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctor file
+// Message-Id: <9311011758.AA25157@thneed.cs.duke.edu>
+// From: Vivek Khera <khera@cs.duke.edu>
+// Subject: g++ 2.5.0 fails to automatically generate default initializer
+// Date: Mon, 01 Nov 1993 12:58:34 -0500
+
+class String
+{
+  private:
+    char a[100];
+    int len;
+  public:
+    String();
+};
+
+String::String()
+{
+    len = 0;
+}
+
+
+struct List
+{
+    String item[100];
+    int num_items;
+//    List();                   // uncomment this line to let compile work
+};
+
+int
+main(int argc, char **argv)
+{
+    List a;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors21.C b/gcc/testsuite/g++.old-deja/g++.law/ctors21.C
new file mode 100644
index 00000000000..3f3b3df522a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors21.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctor file
+// From: mln@tera.com (Mark Niehaus)
+// Subject: g++-2.5.2 -- private copy ctor hides public ctor
+// Date: Mon, 8 Nov 93 10:14:50 PST
+
+class A {
+    A(A&);
+  public:
+    A();
+};
+
+class B {
+    A a;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors3.C b/gcc/testsuite/g++.old-deja/g++.law/ctors3.C
new file mode 100644
index 00000000000..6658764fe47
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors3.C
@@ -0,0 +1,29 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctor file
+// Message-Id: <m0oxRi1-0002fPC@nesmith.pactitle.com>
+// From: genehi@nesmith.pactitle.com (Gene Hightower)
+// Subject: Apparent bug in g++ 2.5.2
+// Date: Wed, 10 Nov 93 18:24 PST
+
+class One {
+  public:
+    One() {}
+};
+
+template<class T> class Two : public One {
+};
+
+class Three {
+};
+
+class Four  {
+    Two<Three>  x[1];
+};
+
+class Five {
+    Four        y;
+
+  public:
+    Five() {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors4.C b/gcc/testsuite/g++.old-deja/g++.law/ctors4.C
new file mode 100644
index 00000000000..dc1f08beaf2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors4.C
@@ -0,0 +1,27 @@
+// Special g++ Options: -w
+// GROUPS passed constructors
+// ctors file
+// Message-Id: <ACHILLES.92Nov25192123@i90s8.ira.uka.de>
+// From: Alf-Christian Achilles <achilles@ira.uka.de>
+// Subject: g++ 2.3.1 rejects initialization with object of derived class
+// Date: 25 Nov 92 19:21:23
+
+extern "C" int printf (const char *, ...);
+
+class A {
+public:
+  virtual void foo() {};
+};
+
+class B : public A {
+public:
+  void foo() {};
+};
+
+main ()
+{
+  B b;
+  A a = b;  //unjustified error: unexpected argument to constructor `A'
+  printf ("PASS\n");
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors5.C b/gcc/testsuite/g++.old-deja/g++.law/ctors5.C
new file mode 100644
index 00000000000..3fc58041192
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors5.C
@@ -0,0 +1,33 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctors file
+// Subject: bug in handling static const object of the enclosing class
+// Date: Tue, 1 Sep 92 10:38:44 EDT
+
+class X
+{
+  private:
+    int x;
+  public:
+    static const X x0;
+    X( int );
+}; // ERROR - candidate
+
+class Y
+{
+  private:
+    X xx;
+  public:
+    Y();
+}
+X::X( int xi )
+{// ERROR -  return.*
+    x = xi;
+}
+
+const X X::x0( 0 );
+
+Y::Y()
+{// ERROR -  no mat
+    xx = X::x0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors6.C b/gcc/testsuite/g++.old-deja/g++.law/ctors6.C
new file mode 100644
index 00000000000..a46f4e89bdb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors6.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed constructors
+#include <complex.h>
+
+double foo(double_complex *a)
+{
+  return 0.0;
+}
+
+
+double bar(void)
+{
+  double_complex v[10];
+  return foo(v);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors7.C b/gcc/testsuite/g++.old-deja/g++.law/ctors7.C
new file mode 100644
index 00000000000..4f056cc072c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors7.C
@@ -0,0 +1,35 @@
+// Build don't link: 
+// GROUPS passed constructors
+// ctors file
+// Message-Id: <3JUL199214462623@envmsa.eas.asu.edu>
+// From: peckham@envmsa.eas.asu.edu (Bill)
+// Subject: const constructor causes crash
+// Date: Fri, 3 Jul 1992 21:46:00 GMT
+
+class base_t {
+public:
+   virtual char *name () { return "base_t"; }
+
+   base_t ();
+   virtual ~base_t ();
+};
+
+class d1_t : public base_t {
+public:
+   virtual char *name () { return "d1_t"; }
+
+   //   The const keyword on this constructor is an error,  but  it shouldn't
+   // cause the compiler to crash.
+
+   d1_t () const;// ERROR - .*const.*
+   virtual ~d1_t ();
+};
+
+class d2_t : public base_t {
+public:
+   virtual char *name () { return "d2_t"; }
+
+   d2_t (int);
+   virtual ~d2_t ();
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors8.C b/gcc/testsuite/g++.old-deja/g++.law/ctors8.C
new file mode 100644
index 00000000000..ef40d354b69
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors8.C
@@ -0,0 +1,24 @@
+// GROUPS passed constructors
+// ctor file
+// Message-Id: <199212160609.AA18247@phecda.cs.sfu.ca>
+// From: Taj Khattra <khattra@cs.sfu.ca>
+// Subject: gcc 2.3.1 global ctor bug ?
+// Date: Tue, 15 Dec 92 22:09:37 PST
+
+#include <stdio.h>
+
+struct foo {
+     foo() : index(-1) {}
+     int index;
+};
+
+foo *arr = new foo[2];
+
+int main()
+{
+  if (arr[0].index == -1
+      && arr[1].index == -1)
+    printf ("PASS\n");
+  else
+    printf ("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/ctors9.C b/gcc/testsuite/g++.old-deja/g++.law/ctors9.C
new file mode 100644
index 00000000000..d926e64a075
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/ctors9.C
@@ -0,0 +1,39 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed constructors
+// ctors file
+// Message-Id: <9301132030.AA05210@cs.rice.edu>
+// From: dougm@cs.rice.edu (Doug Moore)
+// Subject: 2.3.3: accepts ctor-less derived class of ctor-ful base class
+// Date: Wed, 13 Jan 93 14:30:21 CST
+// Note: It gives an error now.  But not a very good one.
+
+struct Foo
+{
+  Foo(int aa);
+  int a;
+  const Foo* operator-> () const {return this;}
+};
+
+Foo::Foo(int aa)
+:a(aa)
+{ }
+
+
+struct var_Foo: public Foo
+{
+  var_Foo* operator-> () {return this;}
+};// ERROR -  base.*// ERROR -  in class.*
+
+int blort(Foo& f)
+{
+  return f->a;
+};
+
+int main()
+{
+  var_Foo b(2);// ERROR - 
+  b->a = 0;
+  int x = blort(b);
+  return x;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt1.C b/gcc/testsuite/g++.old-deja/g++.law/cvt1.C
new file mode 100644
index 00000000000..3f0866ea42e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt1.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// From: dak@pool.informatik.rwth-aachen.de
+// Date:     Sun, 21 Nov 93 17:40:32 +0100
+// Subject:  g++ mixes up array dimensions with new
+// Message-ID: <9311211640.AA11787@messua>
+
+int main()
+{
+        int (*a)[5] = new int[6][5];
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt10.C b/gcc/testsuite/g++.old-deja/g++.law/cvt10.C
new file mode 100644
index 00000000000..c943a391b97
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt10.C
@@ -0,0 +1,60 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <CC7oHn.B4F@izf.tno.nl>
+// From: tom@izfcs.izf.tno.nl (Tom Vijlbrief)
+// Subject: g++ 2.4.5 has problems with NON virtual shared base classes
+// Date: Mon, 23 Aug 1993 12:10:34 GMT
+
+
+#include        <stdio.h>
+
+#define FAIL
+
+class Base {
+public:
+  Base() { printf("Base::Base\n"); }
+  virtual ~Base() { printf("Base::~Base\n"); }
+  virtual void v() { printf("Base::v\n"); }
+};
+
+class Base2 {
+public:
+  Base2() { printf("Base2::Base2\n"); }
+  virtual ~Base2() { printf("Base2::~Base2\n"); }
+  virtual void v() { printf("Base2::v\n"); }
+};
+
+class A: public Base {
+public:
+  A() { printf("A::A\n"); }
+  ~A() { printf("A::~A\n"); }
+  virtual void va() { printf("A::va\n"); }
+};
+
+#ifdef FAIL
+class B: public Base {
+#else
+class B: public Base2 {
+#endif
+public:
+  B() { printf("B::B\n"); }
+  ~B() { printf("B::~B\n"); }
+  virtual void vb() { printf("B::vb\n"); }
+};
+
+class C: public A, public B {
+public:
+  C() { printf("C::C\n"); }
+  ~C() { printf("C::~C\n"); }
+  void va() { printf("C::va\n"); }
+};
+
+
+int main()
+{
+  C *cp= new C;
+  cp->va();
+  delete cp;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt11.C b/gcc/testsuite/g++.old-deja/g++.law/cvt11.C
new file mode 100644
index 00000000000..7394c1b9e5a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt11.C
@@ -0,0 +1,30 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Date: Tue, 10 Nov 92 11:08:08 PST
+// From: rrh@tera.com (Robert R. Henry)
+// Message-Id: <9211101908.AA13557@tera.com>
+// Subject: type cast of qualified const member breaks g++2.3.1
+
+#include <stdio.h>
+
+class Thing{
+private: int x;
+   public: const int N = -1; // ERROR - bad initialization
+  Thing(int y);
+};
+
+class Bar{ public: void doit(void); };
+
+void Bar::doit(void)
+{
+  int i, j;
+  i = Thing::N;
+  printf("i = %d\n", i);
+
+  j = (int)Thing::N;
+  printf("i = %d\n", j);
+}
+Thing::Thing(int y) { x = y; }
+int main(){ Bar x; x.doit(); }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt12.C b/gcc/testsuite/g++.old-deja/g++.law/cvt12.C
new file mode 100644
index 00000000000..5ea83dbbee1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt12.C
@@ -0,0 +1,29 @@
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9301071708.AA03432@muresh.et.tudelft.nl>
+// From: stravers@muresh.et.tudelft.nl (Paul Stravers)
+// Subject: conversion method never called
+// Date: Thu, 7 Jan 93 18:08:33 +0100
+
+#include <stdio.h>
+
+class test
+{
+   double d;
+   int    i;
+public:
+   test(double dd,int ii) {d=dd; i=ii;} // constructor
+   operator int&()        {return i;} // define a conversion from test to int&
+   int& geti()            {return i;} // same thing, but different
+};
+
+int main()
+{
+   test t(3.14, 5);  // Create an object t of class "test"
+   int x = (int&)t;  // This should call operator int&() but it does not ...
+   int y = t.geti(); // x and y should both be 5 ...
+   if (x == 5 && y == 5)
+     printf ("PASS\n");
+   else
+     printf ("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt13.C b/gcc/testsuite/g++.old-deja/g++.law/cvt13.C
new file mode 100644
index 00000000000..c7b09e97b8d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt13.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <ISHAI.93Mar26102509@cs73.technion.ac.il>
+// From: ishai@cs.technion.ac.il (& Ben-Aroya)
+// Subject: Type conversion problem.
+// Date: Fri, 26 Mar 1993 08:25:09 GMT
+
+typedef int array[10];
+
+void f(array &arg)
+{
+}
+
+int main()
+{
+    array var;
+    f(var);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt14.C b/gcc/testsuite/g++.old-deja/g++.law/cvt14.C
new file mode 100644
index 00000000000..e2b9bada124
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt14.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9303241504.AA25988@spock.orl.mmc.com>
+// Subject: internal compiler error
+// Date: Wed, 24 Mar 1993 10:04:06 -0500
+// From: "Malcolm C. Strickland" <chucks@orl.mmc.com>
+
+
+int main()
+        {
+          double *d;
+          d = new double(10);
+          return 1;
+        }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt15.C b/gcc/testsuite/g++.old-deja/g++.law/cvt15.C
new file mode 100644
index 00000000000..967cbb6a6a7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt15.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9308051530.AA05922@NeoSoft.Com>
+// From: daniels@sugar.neosoft.com (Brad Daniels)
+// Subject: g++ 2.4.5:  Conversion operators to complex types don't work either
+// Date: Thu, 5 Aug 93 15:30:04 CDT
+
+class bar { int x; public: bar() : x(1){} };
+
+class foo {
+    bar a, b;
+public:
+    foo(bar i, bar j) : a(i),b(j) {}
+    operator const bar() const { return a; }
+    const bar f() { return *this; }
+    void g(foo &c) { b = c; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt16.C b/gcc/testsuite/g++.old-deja/g++.law/cvt16.C
new file mode 100644
index 00000000000..c539c96e536
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt16.C
@@ -0,0 +1,29 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9304121647.AA25819@tnt>
+// From: mclaugh@tnt.acsys.com (Mark A. McLaughlin)
+// Subject: g++ bug
+// Date: Mon, 12 Apr 93 10:47:01 MDT
+
+#include <iostream.h>
+
+class B {
+};
+
+class A : public B {
+   short s;
+public:
+   A(short _s = 0) { s = _s; }
+   operator const short &() const { return s; }
+};
+
+   int
+main() {
+   A a(37);
+   //cout << a << endl;
+   cout << (short)a << endl;
+
+   return 0;
+}  // main
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt17.C b/gcc/testsuite/g++.old-deja/g++.law/cvt17.C
new file mode 100644
index 00000000000..b746c98488e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt17.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9305210124.AA02409@kato.cs.brown.edu>
+// From: pcm@cs.brown.edu (Peter C. McCluskey)
+// Subject: illegal code compiles silently
+// Date: Thu, 20 May 93 21:24:22 -0400
+
+
+
+class Point {};
+class Line_Segment{ public: Line_Segment(const Point&){} };
+class Node { public: Point Location(){ Point p; return p; } };
+
+int main()
+{
+   Node** node1;
+   Line_Segment(node1->Location()); // intended (*node1)// ERROR - .*
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt18.C b/gcc/testsuite/g++.old-deja/g++.law/cvt18.C
new file mode 100644
index 00000000000..79ea67985d5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt18.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9307090042.AA28565@uluru.Stanford.EDU>
+// From: interran@uluru.stanford.edu (John Interrante)
+// Subject: gcc 2.4.5 on sparc-sun-sunos4.1.2: automatic conversion functions
+// Date: Thu, 8 Jul 93 17:42:12 PDT
+
+class Token {
+public:
+    operator const void*() const;
+    int operator !=(int code) const;
+private:
+    int code_;
+};
+
+extern Token next_token();
+
+void foo(Token token) {
+    if (token && token != '{') {}
+
+    const int inside_body = 1;
+    if (inside_body && (token = next_token())) {}
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt19.C b/gcc/testsuite/g++.old-deja/g++.law/cvt19.C
new file mode 100644
index 00000000000..ae07a385a00
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt19.C
@@ -0,0 +1,27 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <1166.9307131600@ace.eng.cam.ac.uk>
+// From: ajp@eng.cam.ac.uk
+// Date: Tue, 13 Jul 93 17:00:44 BST
+
+
+class B {};
+
+class A {
+  public:
+    operator const B*() const {
+        return b;
+    }
+  private:
+    B* b;
+};
+
+
+int main()
+{
+    A a;
+    if (a!=0) {
+    }
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt2.C b/gcc/testsuite/g++.old-deja/g++.law/cvt2.C
new file mode 100644
index 00000000000..4c28a7e6bd0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt2.C
@@ -0,0 +1,42 @@
+// GROUPS passed conversions
+#include <stdio.h>
+#include <stdlib.h>
+#include <iostream.h>
+#include <fstream.h>
+
+extern "C" {
+int strncmp (const char *, const char *, size_t);
+}
+
+class cvec {
+public:
+        ~cvec(){ delete s; }
+        cvec(const char*x) { s = new char[strlen(x)+1]; strcpy(s, x); }
+	cvec(const cvec& c) { s = new char[strlen(c.s)+1]; strcpy(s, c.s); }
+        operator const char*() { return s; }
+private:
+        char *s;
+};
+
+cvec
+B(const char* a)
+{
+        return a;
+}
+
+void
+A(const char* s)
+{
+        // s still ok here
+        ifstream inf(s);
+	if (strncmp ("aaa", s, 3))
+	  printf ("FAIL\n");
+	else
+	  printf ("PASS\n");
+}
+
+int main()
+{
+        A(B("aaa"));
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt20.C b/gcc/testsuite/g++.old-deja/g++.law/cvt20.C
new file mode 100644
index 00000000000..1ecbfa2447a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt20.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9307152250.AA24812@volterra>
+// From: rst@ai.mit.edu (Robert S. Thau)
+// Subject: g++ won't convert char[] to char*&
+// Date: Thu, 15 Jul 93 18:50:59 EDT
+
+
+// Compiles fine with Sun CC 2.1
+
+void f(char *& x)
+{// ERROR - location of error
+  x++;
+}
+
+int main()
+{
+  f ("foo");// ERROR - init of non-const ref from char*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt21.C b/gcc/testsuite/g++.old-deja/g++.law/cvt21.C
new file mode 100644
index 00000000000..8cdd1507650
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt21.C
@@ -0,0 +1,36 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9307200528.AA02094@legolas>
+// From: Mark Kuzmycz <kuzmycz@deakin.edu.au>
+// Subject: int & conversion operator
+// Date: Tue, 20 Jul 93 15:28:47 EST
+
+class Int
+{
+	public:
+		Int(void);
+		Int(int);
+		Int(const Int&);
+	
+		Int* copy(void) const;
+		
+		operator int&();
+		
+		Int& operator ++(void);
+		Int& operator --(void);
+		
+	private:
+		int value;
+};
+ 
+int main()
+{
+  Int data = 2;
+  Int test;
+
+  test = data * 12;
+  data += 1;
+}
+
+// UNKNOWN "FAIL"
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt22.C b/gcc/testsuite/g++.old-deja/g++.law/cvt22.C
new file mode 100644
index 00000000000..c9a80baa617
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt22.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <93Aug2.163542pdt.26892@franklin.parc.xerox.com>
+// From: Jesse Hull <jhull@parc.xerox.com>
+// Subject: typedef bug
+// Date:   Mon, 2 Aug 1993 16:35:28 PDT
+
+typedef int A[10];
+
+int main()
+{
+   int* a1 = new A;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt23.C b/gcc/testsuite/g++.old-deja/g++.law/cvt23.C
new file mode 100644
index 00000000000..626d01c5932
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt23.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9308051209.AA15962@NeoSoft.Com>
+// From: daniels@sugar.neosoft.com (Brad Daniels)
+// Subject: Bug in g++ 2.4.5: Conversion operators to enumerated types don't wor
+// Date: Thu, 5 Aug 93 12:09:09 CDT
+
+enum bar { AAA, BBB };
+
+class foo {
+   bar a, b;
+public:
+   foo(bar i, bar j) : a(i),b(j) {}
+   operator const bar() const { return a; }
+   bar f() { return *this; }
+   void g(foo &c) { b = c; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt3.C b/gcc/testsuite/g++.old-deja/g++.law/cvt3.C
new file mode 100644
index 00000000000..357dd32f254
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt3.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9308122113.AA14119@tnt.acsys.com>
+// From: mclaugh@tnt.acsys.com (Mark A. McLaughlin)
+// Subject: g++ bug
+// Date: Thu, 12 Aug 93 15:13:23 MDT
+
+
+class C { };
+
+void f(C) { }
+
+void g(const C & c) { f(c); }
+
+void h(const C & c) { f(C(c)); }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt4.C b/gcc/testsuite/g++.old-deja/g++.law/cvt4.C
new file mode 100644
index 00000000000..d45d7898986
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt4.C
@@ -0,0 +1,27 @@
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9308091213.AA11572@emmy.Mathematik.Uni-Dortmund.DE>
+// From: Michael Strauch <strauch@emmy.mathematik.uni-dortmund.de>
+// Subject: Bug in GCC 2.4.5
+// Date: Mon, 9 Aug 93 14:13:50 MESZ
+
+extern "C" int printf (const char *, ...);
+
+int destruct = 2;
+
+  class Test{
+  protected:
+     long x;
+  public:
+     Test(){;}
+     Test(long l) {x=l;}
+     ~Test() {if (--destruct == 0) printf ("PASS\n");}
+  };
+
+int main()
+  {
+     long i=1;
+     Test t;
+
+     t=(Test)i;
+  }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt5.C b/gcc/testsuite/g++.old-deja/g++.law/cvt5.C
new file mode 100644
index 00000000000..a7a04703f96
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt5.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <1992Jul31.142856.10082@ericsson.se>
+// From: jonas@ericsson.se (Jonas Nygren)
+// Subject: g++ bug
+// Date: Fri, 31 Jul 1992 14:28:56 GMT
+
+class A {};
+class B : public A {};
+
+B b;
+
+class R{
+public:
+  R() {}
+  operator B&() { return b; }
+};
+
+void f(A&) {}
+
+int main(){
+  R r;
+
+  f(r); // problem to cast to B& and then to A&
+}
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt6.C b/gcc/testsuite/g++.old-deja/g++.law/cvt6.C
new file mode 100644
index 00000000000..fd0a83e457a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt6.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <9208261851.AA16997@josquin.media.mit.edu>
+// From: bilmes@media.mit.edu
+// Subject: gcc (g++) 2.2.2 constructing nested class from external scope
+// Date: Wed, 26 Aug 92 14:51:17 -0400
+
+
+class foo {
+
+  class bar {
+    int i;
+  public:
+    bar(int j) { i = j; }
+  };
+
+  bar b;
+public:
+  foo() : b(3) {}
+  void test(bar lb) { b = lb; }
+};
+
+
+int main() {
+  foo f;
+  f.test(34);  // line 18
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt7.C b/gcc/testsuite/g++.old-deja/g++.law/cvt7.C
new file mode 100644
index 00000000000..c9cc1b5cd6d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt7.C
@@ -0,0 +1,74 @@
+// GROUPS passed conversions
+// cvt file
+// From: krste@icsi.berkeley.edu (Krste Asanovic)
+// Date: Mon, 24 Aug 92 19:05:10 PDT
+// Message-Id: <9208250205.AA26351@icsib43.ICSI.Berkeley.EDU>
+// Subject: implicit int. convs. from member refs. in switch expressions
+
+#include <stream.h>
+#include <stdio.h>
+
+class A
+{
+public:
+    A(int j) { i = j; }
+    A(A& a) { i = a.i; }
+    operator int() { return i; }
+
+    void assign(int v) { i = v; }
+    int i;
+};
+
+class B
+{
+public:
+    B(A& inArg) : in(inArg), out(0) {}
+
+    A& in;
+    A out;
+
+    void run();
+};
+
+void
+B::run()
+{
+    // I get a "switch quantity not an integer" error for this statement.
+    switch (in)
+    // Replacing above with "switch (int(in))" removes the error.
+    {
+    case 0:
+        out = 1;
+        break;
+    default:
+        out = 0;
+        break;
+    }
+}
+
+int main()
+{
+    A a(1);
+
+    A& ar = a;
+
+    A& ar2 = ar;
+
+    // ....but no errors for this switch statement.
+    switch (ar2)
+    {
+    case 1:
+	printf ("PASS\n");
+        break;
+    default:
+	printf ("FAIL\n");
+    }
+
+    B b(a);
+    a.assign(3);
+    b.run();
+    a.assign(0);
+    b.run();
+
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt8.C b/gcc/testsuite/g++.old-deja/g++.law/cvt8.C
new file mode 100644
index 00000000000..f97790a19e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt8.C
@@ -0,0 +1,35 @@
+// Build don't link: 
+// GROUPS passed conversions
+// cvt file
+// From: solomon@cs.wisc.edu (Marvin Solomon)
+// Message-Id: <9209141509.AA23124@gjetost.cs.wisc.edu>
+// Subject: g++ 2.2.2 seems to be forgetting a "const"
+// Date: Mon, 14 Sep 92 10:09:58 -0500
+
+extern "C" void printf(...);
+
+struct A {
+        int i;
+};
+
+struct B {
+        int i;
+        operator const A&() const;
+};
+
+B::operator const A&() const {
+        static A a;
+        a.i = i;
+        printf("convert B to A at %x\n", &a);
+        return a;
+}
+
+void f(A &a) { // ERROR - in passing argument
+        printf("A at %x is %d\n", &a, a.i);
+}
+
+int main() {
+        B b;
+        b.i = 99;
+        f(b);// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/cvt9.C b/gcc/testsuite/g++.old-deja/g++.law/cvt9.C
new file mode 100644
index 00000000000..e98508d8482
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/cvt9.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed conversions
+// cvt file
+// Message-Id: <m0mVSRj-0000cEC@mobius.veritas.com>
+// From: joe@veritas.com (Joe Fasano)
+// Subject: gcc-2.2.2 bug report
+// Date: Thu, 17 Sep 92 13:27 PDT
+
+typedef int (*widget) ();
+
+class window {
+public:
+  int Isopen ();
+};
+
+widget fp = (widget) &window::Isopen;	// ERROR - // ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.law/dossier1.C b/gcc/testsuite/g++.old-deja/g++.law/dossier1.C
new file mode 100644
index 00000000000..2977f156ecf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/dossier1.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// Special g++ Options: -frtti
+// GROUPS passed rtti
+// dossier file
+// Message-Id: <9212021501.AA02484@olympia.miro.com>
+// From: rme@miro.com (Richard M. Emberson)
+// Subject: bug
+// Date: Wed, 2 Dec 92 07:01:30 PST
+
+class Vector {
+  int *p;
+  int sz;
+public:
+  Vector(int );
+  ~Vector();
+
+  int& operator[](int i);
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/dtors1.C b/gcc/testsuite/g++.old-deja/g++.law/dtors1.C
new file mode 100644
index 00000000000..5c0999c1763
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/dtors1.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed destructors
+// friends file
+// From: offline!marc@ai.mit.edu (Marc Duponcheel) (Marc Duponcheel)
+// Date:     Sat, 6 Feb 93 23:31:22 PST
+// Subject:  some 2.2.2 bugs
+// Message-ID: <9302070731.AA002jw@offline.UUCP>
+
+void    f()
+{
+        int     i;
+        i.i::~i();// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/dtors2.C b/gcc/testsuite/g++.old-deja/g++.law/dtors2.C
new file mode 100644
index 00000000000..ebf96123996
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/dtors2.C
@@ -0,0 +1,40 @@
+// GROUPS passed destructors
+#include <stdio.h>
+
+int destruct = 0;
+
+class bla {
+
+public:
+
+        inline bla(char * jim) { ; };
+
+        inline ~bla() { destruct++; if (destruct == 2) printf ("PASS\n");};
+};
+
+class ulk {
+
+public:
+
+        inline ulk() {};
+        inline ~ulk() {};
+
+        void funk(const bla & bob) { ;};
+             //       ^ interestingly, the code compiles right if
+             //         this & is deleted (and therefore the parameter
+             //         passed as value)
+};
+
+int main() {
+
+        ulk dumm;
+
+        dumm.funk(bla("laberababa"));  // this compiles correctly
+
+        dumm.funk((bla)"laberababa");  // this produces incorrect code -
+                                       // the temporary instance of
+                                       // the class "bla" is constructed
+                                       // but never destructed...
+
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/dtors3.C b/gcc/testsuite/g++.old-deja/g++.law/dtors3.C
new file mode 100644
index 00000000000..7ed92fcedb9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/dtors3.C
@@ -0,0 +1,37 @@
+// GROUPS passed destructors
+// dtor file
+// Message-Id: <9301242117.AA04053@cs.rice.edu>
+// From: dougm@cs.rice.edu (Doug Moore)
+// Subject: 2.3.3: premature dtor of temp?
+// Date: Sun, 24 Jan 93 15:17:07 CST
+
+#include <stdio.h>
+#include <stdlib.h>
+
+int killed = 0;
+
+class Foo
+{
+  int a;
+public:
+  Foo() 
+  :a(0) {;}
+  ~Foo() { killed++;}
+  Foo& operator << (int b)
+  {
+    a += b;
+    if (killed)
+      {
+	printf ("FAIL\n");
+	exit (0);
+      }
+    return *this;
+  }
+};
+
+int main()
+{
+  Foo() << 1 << 3 << 5 << 7;
+  printf ("PASS\n");
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/dtors4.C b/gcc/testsuite/g++.old-deja/g++.law/dtors4.C
new file mode 100644
index 00000000000..6168c0dd21c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/dtors4.C
@@ -0,0 +1,22 @@
+// GROUPS passed destructors
+#include <stdio.h>
+
+int destruct = 2;
+
+class a {
+        public:
+                char    *p;
+                a(){ ; }
+                ~a(){ destruct--; if (! destruct) printf ("PASS\n");}
+};
+
+a       test(){
+        return a();
+}
+
+int main(){
+        a       ai;
+
+        ai = test();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/dtors5.C b/gcc/testsuite/g++.old-deja/g++.law/dtors5.C
new file mode 100644
index 00000000000..3c54561501e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/dtors5.C
@@ -0,0 +1,33 @@
+// GROUPS passed destructors
+// dtor file:
+// Message-Id: <1992Jun25.181845.18886@leland.Stanford.EDU>
+// From: niz@leland.stanford.edu (Jim Nisbet)
+// Subject: gcc 2.2.2 -- c++ bug: destructor called twice (example)
+// Date: 25 Jun 92 18:18:45 GMT
+
+#include <stdio.h>
+
+int things = 0;
+
+class foo {
+public:
+   foo() { things++; }
+   foo(const foo&) { things++; }
+   ~foo() { things--; }
+
+   int i;
+};
+
+void
+sub(foo f) {
+   ;
+};
+
+
+int main() {
+   sub(foo());
+   if (things == 0)
+     printf ("PASS\n");
+   else
+     printf ("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/enum1.C b/gcc/testsuite/g++.old-deja/g++.law/enum1.C
new file mode 100644
index 00000000000..c3ef73d5c4b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/enum1.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed enums
+class X {
+  struct X1;
+  enum { A= sizeof(X1 *) };     //Causes a problem.
+  struct X1 { int i; };
+  X1 *f(X1 *);
+public:
+  X(void);
+};
+
+X::X1 *X::f(X1 *x) {
+  return x;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/enum2.C b/gcc/testsuite/g++.old-deja/g++.law/enum2.C
new file mode 100644
index 00000000000..902d8ed56c5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/enum2.C
@@ -0,0 +1,27 @@
+// Build don't link: 
+// Special g++ Options: -fshort-enums
+// GROUPS passed enums
+// enum file
+// From: Jeff Gehlhaar <jbg@qualcomm.com>
+// Date:     Mon, 4 Jan 1993 09:20:50 -0700
+// Subject:  Enum bug, affects library
+// Message-ID: <9301041720.AA17340@harvey>
+
+typedef unsigned long __fmtflags;
+class ios {
+  public:
+    typedef __fmtflags fmtflags;
+    enum { skipws=01, left=02, right=04, internal=010,
+           dec=020, oct=040, hex=0100,
+           showbase=0200, showpoint=0400, uppercase=01000, showpos=02000,
+           scientific=04000, fixed=010000, unitbuf=020000, stdio=040000,
+           dont_close=0x80000000 //Don't delete streambuf on stream destruction
+           };
+
+    fmtflags setf (fmtflags, fmtflags);
+};
+
+// from <iostream.h>
+inline ios& dec(ios& i)
+{ i.setf(ios::dec, ios::dec|ios::hex|ios::oct); return i; }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/enum3.C b/gcc/testsuite/g++.old-deja/g++.law/enum3.C
new file mode 100644
index 00000000000..43845e2edec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/enum3.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed enums
+// enum file
+// From: frode@auticon.no
+// Date:     Wed, 13 Jan 93 9:24:50 PST
+// Subject:  enum trouble
+// Message-ID: <"nac.no.001:13.00.93.18.40.52"@nac.no>
+
+typedef enum{on, off} TOGGLE;
+
+class field {
+private:
+  TOGGLE toggle;
+public:
+  virtual void on(void) { toggle = 3; };// ERROR - .*
+  virtual void off(void) { toggle = on; };// ERROR - .*
+};
+
+int main()
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/enum4.C b/gcc/testsuite/g++.old-deja/g++.law/enum4.C
new file mode 100644
index 00000000000..f763656441f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/enum4.C
@@ -0,0 +1,29 @@
+// Build don't link: 
+// GROUPS passed enums
+// enum file
+// From: dougm@cs.rice.edu (Doug Moore)
+// Date:     Thu, 18 Mar 93 00:14:57 CST
+// Subject:  2.3.3:Inconsistent behavior for enum conversions
+// Message-ID: <9303180614.AA12123@cs.rice.edu>
+
+enum Enum {enumerator1, enumerator2};
+
+struct Struct
+{
+  int i;
+      int getI(Enum) {return i;} // ERROR - candidates
+};
+
+int funct (Enum)
+{
+  return 0;
+}
+
+int main()
+{
+  Enum e = enumerator1;
+  Struct s;
+  int x = funct(e+1);// ERROR - .*
+  int y = s.getI(e+1);// ERROR - .*
+  return x+y;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/enum6.C b/gcc/testsuite/g++.old-deja/g++.law/enum6.C
new file mode 100644
index 00000000000..65950e9ab0a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/enum6.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed enums
+// enum file
+// From: polstra!jdp@uunet.uu.net (John Polstra)
+// Date:     Mon, 15 Nov 93 12:14 PST
+// Subject:  GCC 2.5.3 Enum Bitfield Causes Bogus Warning
+// Message-ID: <m0ozAJo-0001EgC@seattle.polstra.uucp>
+
+   enum Color { Red, Green, Blue };
+
+    struct S {
+        Color c : 8;
+    } s;
+
+    void foo()
+    {
+        s.c = Red;      // <== This statement produces the warning message.
+    }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/enum7.C b/gcc/testsuite/g++.old-deja/g++.law/enum7.C
new file mode 100644
index 00000000000..444fa489b8b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/enum7.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed enums
+// friends file
+// From: offline!marc@ai.mit.edu (Marc Duponcheel) (Marc Duponcheel)
+// Date:     Sat, 6 Feb 93 23:31:22 PST
+// Subject:  some 2.2.2 bugs
+// Message-ID: <9302070731.AA002jw@offline.UUCP>
+
+class X
+{
+        enum E { A, B };
+static enum E   e;
+};
+enum X::E X::e = A;
diff --git a/gcc/testsuite/g++.old-deja/g++.law/enum8.C b/gcc/testsuite/g++.old-deja/g++.law/enum8.C
new file mode 100644
index 00000000000..192a2b4c468
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/enum8.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// Special g++ Options: -fshort-enums
+// GROUPS passed enums
+  enum E { A = 0x80000000 };
diff --git a/gcc/testsuite/g++.old-deja/g++.law/enum9.C b/gcc/testsuite/g++.old-deja/g++.law/enum9.C
new file mode 100644
index 00000000000..0a3531e1f3b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/enum9.C
@@ -0,0 +1,14 @@
+// Special g++ Options: -fshort-enums
+// GROUPS passed enums
+  extern "C" int printf (const char *, ...);
+
+  enum E { A = 0x80000000, B = 0 };
+
+  main()
+  {
+    if (sizeof (E) != 4)
+	printf ("FAIL\n");
+    else
+	printf ("PASS\n");
+    return 0;
+  }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/except1.C b/gcc/testsuite/g++.old-deja/g++.law/except1.C
new file mode 100644
index 00000000000..edfb85f7ce9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/except1.C
@@ -0,0 +1,29 @@
+// Build don't link: 
+// Special g++ Options: -fexceptions
+// GROUPS passed exceptions
+// except file
+// Message-Id: <9207221230.AA08566@life.ai.mit.edu>
+// From: EWALLACE@endvmtkl.vnet.ibm.com
+// Subject: Bugs
+// Date: Wed, 22 Jul 92 08:29:30 EDT
+
+extern "C" void puts(const char *);
+
+class foo {
+public:
+  class error {};
+
+  void cause_error(void) { throw error(); }
+};
+
+int main(void)
+{
+  foo f;
+  try {
+    f.cause_error();
+  }
+  catch (foo::error) {
+    puts("Caught it.");
+  }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/except2.C b/gcc/testsuite/g++.old-deja/g++.law/except2.C
new file mode 100644
index 00000000000..1bf7108146b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/except2.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// Special g++ Options: -fexceptions -g
+// GROUPS passed exceptions
+// except file
+// Message-Id: <9211061330.AA29334@ifad.dk>
+// From: erik@ifad.dk (Erik Toubro Nielsen)
+// Subject: g++-2.3.1 gets fatal signal with -g and -fhandle-exceptions
+// Date: Fri, 6 Nov 92 14:30:33 +0100
+
+int main()
+{
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/except3.C b/gcc/testsuite/g++.old-deja/g++.law/except3.C
new file mode 100644
index 00000000000..553da6b6d68
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/except3.C
@@ -0,0 +1,50 @@
+// Build don't link: 
+// Special g++ Options: -fexceptions
+// GROUPS passed exceptions
+// except file
+// Message-Id: <9211301118.AA09810@ss670mp.geco.slb.com>
+// From: willoch@ss670mp.oslo.sgp.slb.com (thorbjorn willoch)
+// Subject: -fansi-exceptions bug
+// Date: Mon, 30 Nov 92 11:18:05 GMT
+
+extern "C" int printf(const char *, ...);
+
+class Vector
+{
+    int* p;
+    int sz;
+  public:
+    Vector(int s) { p = new int[sz=s]; }
+    ~Vector() {delete [] p; }
+    int size() {return sz; }
+    class Range{};
+ 
+ 
+    int& operator[](int i);
+};
+ 
+int& Vector::operator[](int i)
+{
+    if(0<=i && i<sz) return p[i];
+    throw Range();
+}
+ 
+void do_something(Vector& v)
+{
+    int i = v[v.size()+10];
+}
+ 
+main()
+{
+    Vector v(10);
+ 
+    try
+    {
+        do_something(v);
+    }
+ 
+    catch (Vector::Range)
+    {
+        printf("Range error exception\n");
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/except4.C b/gcc/testsuite/g++.old-deja/g++.law/except4.C
new file mode 100644
index 00000000000..c108c48bf74
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/except4.C
@@ -0,0 +1,34 @@
+// Build don't link: 
+// Special g++ Options: -fexceptions
+// GROUPS passed exceptions
+// except file
+// Message-Id: <9307071456.AA05275@davinci.hio.hen.nl>
+// From: akkersdi@hio.hen.nl
+// Subject: exceptions broken
+// Date: Wed, 7 Jul 1993 16:56:52 +0200 (MET DST)
+
+class	ball {
+public:	int	dummy;
+	ball() : dummy(0) { ; }
+};
+
+void	pitcher()
+{
+	throw	ball();
+}
+
+void	catcher()
+{
+	try		// <=== gcc 2.* fails here
+	{
+		pitcher();
+	}
+	catch (ball) {
+		/* sleepy catcher doing nothing */ ;
+	}
+}
+
+int	main()
+{
+	catcher();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/except5.C b/gcc/testsuite/g++.old-deja/g++.law/except5.C
new file mode 100644
index 00000000000..623d0d8587f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/except5.C
@@ -0,0 +1,39 @@
+// Build don't link: 
+// Special g++ Options: -fexceptions
+// GROUPS passed exceptions
+// except file
+// Message-Id: <199311101607.AA11803@hsi86.hsi.com>
+// From: Grigory Tsipenyuk <grigory@hsi.com>
+// Subject: exception's bug?
+// Date: Wed, 10 Nov 1993 11:07:12 -0500
+
+#include <stream.h>
+class X {
+        int     *a;
+        int     sz;
+public:
+        class range { }; // exception class
+        X(int s)        { a=new int[sz=s]; }
+        int& operator[](int i);
+};
+
+int& X::operator[](int i)
+{
+        if (i < 0 || i >= sz) {
+                throw range();
+        }
+        return a[i];
+}
+
+int
+main()
+{
+        X       c(10);
+        try {
+                for (int i = 0; i < 12; i++)
+                        c[i] = 1;
+        } catch (X::range) {
+                cerr << "invalid range\n";
+        }
+        return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/except6.C b/gcc/testsuite/g++.old-deja/g++.law/except6.C
new file mode 100644
index 00000000000..cca167c10fa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/except6.C
@@ -0,0 +1,27 @@
+// Build don't link: 
+// Special g++ Options: -fexceptions
+// GROUPS passed exceptions
+// except file
+// From: GUSTAVO%DRAGON@orion.cpqd.ansp.br
+// Date:     15 Dec 1993 09:33:30 +0000 (C)
+// Subject:  exception handling problem
+// Message-ID: <01H6I5GEAF5UPBJ0UV@VENUS.CPQD.ANSP.BR>
+
+struct Exception
+ {
+     int v;
+     Exception(int i) { v = i; };
+ };
+
+void inc(int &i)
+ {
+     try {
+         if (i == 0)
+             throw Exception(i);
+         else
+             i++;
+     }
+     catch (Exception v) {
+         i = v.v;
+     }
+ }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/friend1.C b/gcc/testsuite/g++.old-deja/g++.law/friend1.C
new file mode 100644
index 00000000000..5628e0b4074
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/friend1.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed friends
+// friends file
+// From: rwave!myersn%rwave.roguewave@cs.orst.edu (Nathan Myers)
+// Date:     Thu, 17 Dec 92 16:33 PST
+// Subject:  2.3.2: friend decl of new confuses constructor
+// Message-ID: <m0n2Vec-0000GrC@rwave.roguewave.com>
+
+#include <stddef.h>
+#include <new>
+struct Foo {
+  friend void* operator new(size_t) throw (std::bad_alloc);
+  friend void operator delete(void*) throw ();
+  Foo();
+  ~Foo();
+};
+Foo::Foo() { }
+Foo::~Foo() { }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/friend4.C b/gcc/testsuite/g++.old-deja/g++.law/friend4.C
new file mode 100644
index 00000000000..a734fc419df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/friend4.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed friends
+// friends file
+// From: osinski@cs.nyu.edu (Ed Osinski)
+// Date:     Fri, 05 Jun 92 20:47:37 -0400
+// Subject:  parameter name forgotten in certain friends
+// Message-ID: <9206060047.AA05594@MURRAY.CS.NYU.EDU>
+
+class T2;
+
+class T {
+   friend void f (int&);
+};
+
+class T2 {
+      friend void f (int& i)  { // BOGUS - 
+      i = 1;
+   };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/friend5.C b/gcc/testsuite/g++.old-deja/g++.law/friend5.C
new file mode 100644
index 00000000000..2ecc31347b1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/friend5.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed friends
+        extern "C" int good_friend(int);
+        extern "C" int bad_friend();
+
+        class assembler {
+            friend int good_friend(int);
+            friend int bad_friend();
+            void *parts;
+        };
+
+        assembler obj;
+
+        int good_friend(int)
+        {
+            obj.parts = 0;
+        } // ERROR - non-void
+
+        int bad_friend()
+        {
+            obj.parts = 0;
+        } // ERROR - non-void
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/global-init1.C b/gcc/testsuite/g++.old-deja/g++.law/global-init1.C
new file mode 100644
index 00000000000..17dc9c5cdf1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/global-init1.C
@@ -0,0 +1,20 @@
+// GROUPS passed initialization
+// global-init file
+// Message-Id: <9212021756.AA12639@grumpy.pocs.com>
+// From: wp@pocs.com (Wolfgang Polak)
+// Subject: Initializers - gcc 2.2.2 (g++), Sparc, SunOS 4.1.1
+// Date: Wed, 2 Dec 92 09:56:01 PST
+
+#include <stdio.h>
+struct S { int  a; int  c; };
+int i = 3;
+S s = {6, i};
+S * the_s  () { return &s; };
+int main ()
+{
+  S * cls = the_s ();
+  if (cls->a != 6)
+    printf ("FAIL\n");
+  else
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/incdec1.C b/gcc/testsuite/g++.old-deja/g++.law/incdec1.C
new file mode 100644
index 00000000000..ce5903c3c78
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/incdec1.C
@@ -0,0 +1,47 @@
+// Build don't link: 
+// Special g++ Options: -w -O3
+// GROUPS passed incdec
+typedef void* Pix;
+class ndbArtPtrVec 
+{
+public:
+                        ndbArtPtrVec (ndbArtPtrVec&);
+};
+class intndbArtPtrVecMap
+{
+protected:
+  int                   count;
+  ndbArtPtrVec                   def;
+                        intndbArtPtrVecMap(ndbArtPtrVec& dflt);
+  virtual ndbArtPtrVec&          operator [] (int  key) = 0;  
+  virtual void          del(int  key) = 0;        
+public:
+  virtual Pix           first() = 0;              
+  virtual void          next(Pix& i) = 0;         
+  virtual int&          key(Pix i) = 0;           
+  virtual ndbArtPtrVec&          contents(Pix i) = 0;      
+};
+struct intndbArtPtrVecAVLNode
+{
+  ndbArtPtrVec                 cont;
+                      intndbArtPtrVecAVLNode(int  h, ndbArtPtrVec& c, 
+                                    intndbArtPtrVecAVLNode* l=0, intndbArtPtrVecAVLNode* r=0);
+};
+class intndbArtPtrVecAVLMap : intndbArtPtrVecMap 
+{
+protected:
+  intndbArtPtrVecAVLNode*   root;
+public:
+  ndbArtPtrVec&          operator [] (int  key);
+  intndbArtPtrVecAVLMap(intndbArtPtrVecAVLMap&);
+};
+ndbArtPtrVec& intndbArtPtrVecAVLMap::operator [] (int  item)
+{
+    ++count;
+    root = new intndbArtPtrVecAVLNode(item, def);
+}
+intndbArtPtrVecAVLMap::intndbArtPtrVecAVLMap(intndbArtPtrVecAVLMap& b) :intndbArtPtrVecMap(b.def)
+{
+  for (Pix i = b.first(); i != 0; b.next(i)) 
+    (*this)[b.key(i)] = b.contents(i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init1.C b/gcc/testsuite/g++.old-deja/g++.law/init1.C
new file mode 100644
index 00000000000..1f23d78936d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init1.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed initialization
+class foo {
+public:
+  int data;
+  foo(int dat) { data = dat; }
+};
+
+class bar {
+public:
+  foo f[3] = { 1, 2, 3 };   // works: f[0] = 1, f[1] = 2, f[2] = 3 // ERROR - ANSI C++ forbids initialization of member f;
+};
+
+class bar2 {
+public:
+      foo f[3] = { foo(1), foo(2), foo(3) }; // ERROR - ANSI C++ forbids initialization of member f;
+  // does not compile -- error: field initializer is not constant
+};
+
+int main(void)
+{
+  foo f[3] = { foo(1), foo(2), foo(3) };
+  // standard C++ ... and it works too! :)
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init10.C b/gcc/testsuite/g++.old-deja/g++.law/init10.C
new file mode 100644
index 00000000000..b6f2085bfc5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init10.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+// GROUPS passed initialization
+// init file
+// From: Ingo Donasch <ingo@specs.de>
+// Date:     Wed, 16 Jun 93 13:28:55 +01:00
+// Subject:  g++-2.4.2 bug report
+// Message-ID: <199306161128.AA22079@opamp.specs.de>
+
+class b;
+
+class a {
+public:
+        a(const b*);            // needs this parameter
+};
+
+class b {
+private:
+        a three[3];
+public:
+        b();
+};
+
+b::b() : three(this)
+{ // ERROR - bad array initializer
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init11.C b/gcc/testsuite/g++.old-deja/g++.law/init11.C
new file mode 100644
index 00000000000..a6d6f01487d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init11.C
@@ -0,0 +1,24 @@
+// GROUPS passed initialization
+// init file
+// From: hansen@srd.ull.rdc.toshiba.co.jp
+// Date:     Mon, 13 Dec 93 18:27:51 +0900
+// Subject:  g++ Bug
+// Message-ID: <9312130927.AA08192@VLCS151.noname>
+
+#include <stdio.h>
+
+int X = 7;
+
+struct foo {
+   int a,b,c;
+};
+
+struct foo Ack = {5, X, 3};
+
+int main()
+{
+  if (Ack.a == 5 && Ack.b == 7 && Ack.c == 3)
+    printf ("PASS\n");
+  else
+    printf ("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init13.C b/gcc/testsuite/g++.old-deja/g++.law/init13.C
new file mode 100644
index 00000000000..40917c8917d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init13.C
@@ -0,0 +1,19 @@
+// GROUPS passed initialization
+// init file
+// Message-Id: <9306280834.AA20921@slsvitt.us-es.sel.de>
+// From: David Binderman 3841 <dcb@us-es.sel.de>
+// Subject: Page 289 of the ARM
+// Date: Mon, 28 Jun 93 10:34:37 +0200
+
+struct T {
+  int m;
+
+  T( int g):m(g){}
+};
+
+// T s1[2][2] = {1,2,3,4};
+
+int main() {
+	T s1[2][2] = {1,2,3,4};
+	return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init14.C b/gcc/testsuite/g++.old-deja/g++.law/init14.C
new file mode 100644
index 00000000000..3a9e3e1369f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init14.C
@@ -0,0 +1,26 @@
+// GROUPS passed initialization
+// init file
+// From: hansen@srd.ull.rdc.toshiba.co.jp
+// Message-Id: <9312130927.AA08192@VLCS151.noname>
+// Subject: g++ Bug
+// Date: Mon, 13 Dec 93 18:27:51 +0900
+
+#include <stdio.h>
+
+int X = 7;
+
+struct foo {
+   int a,b,c;
+};
+
+struct foo Ack = {5, X, 3};
+
+int main()
+{
+    if (Ack.a != 5
+	|| Ack.b != 7
+	|| Ack.c != 3)
+      printf ("FAIL\n");
+    else
+      printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init2.C b/gcc/testsuite/g++.old-deja/g++.law/init2.C
new file mode 100644
index 00000000000..bfc9014acd6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init2.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed initialization
+// init file
+// From: lupine!segfault!rfg@uunet.UU.NET
+// Date:     Sun, 27 Sep 92 14:06:22 MDT
+// Subject:  Bug in g++ (920220) handling reference initializers.
+// Message-ID: <15409.717627982@segfault>
+
+int * const & fiddle = 0;
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init3.C b/gcc/testsuite/g++.old-deja/g++.law/init3.C
new file mode 100644
index 00000000000..72b9de8e01d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init3.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed initialization
+// init file
+// From: thayer@moose.cs.columbia.edu (Charles Thayer)
+// Date:     Wed, 30 Sep 92 02:38:17 EDT
+// Subject:  small bug
+// Message-ID: <9209300638.AA22334@moose.cs.columbia.edu>
+
+int main() {
+int offset;
+char buf[offset]=""; // ERROR - ansi forbids variable arrays
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init4.C b/gcc/testsuite/g++.old-deja/g++.law/init4.C
new file mode 100644
index 00000000000..084876296d1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init4.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed initialization
+class Time;
+class TimeNote;
+
+class SvTime
+{
+public:
+    static TimeNote *time_events = 0;// ERROR - .*
+};
+
+SvTime CurrentTime = {0};// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init5.C b/gcc/testsuite/g++.old-deja/g++.law/init5.C
new file mode 100644
index 00000000000..e5882341afb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init5.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// Special g++ Options: -pedantic-errors
+// GROUPS passed initialization
+// init file
+// From: dcb@us-es.sel.de
+// Date:     Mon, 12 Oct 92 07:51:52 +0100
+// Subject:  G++, ARM Page 141
+// Message-ID: <9210120651.AA15257@us-es.sel.de>
+
+extern int fred( int);
+
+class X {
+      public :
+      void f( int = fred( 0) ) ; // ERROR - previous spec
+} ;
+
+void X::f( int x = fred( 0) ) {// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init6.C b/gcc/testsuite/g++.old-deja/g++.law/init6.C
new file mode 100644
index 00000000000..bcebd6cef8a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init6.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed initialization
+class Vector {
+        double  *v;
+        int             size;
+
+public:
+        Vector(int n);
+        ~Vector();
+};
+
+exmpl() { Vector x(8)[16]; }// ERROR - .*
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init7.C b/gcc/testsuite/g++.old-deja/g++.law/init7.C
new file mode 100644
index 00000000000..2ec97c4fd11
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init7.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed initialization
+class test
+ {
+  public:
+   int x;
+   int y;
+   test (int val) { x = val; y = 0;}
+ };
+
+test ar(34)[5];// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init8.C b/gcc/testsuite/g++.old-deja/g++.law/init8.C
new file mode 100644
index 00000000000..6b52bdcdeea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init8.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed initialization
+// init file
+// From: kol@world.std.com (Nikolay Yatsenko)
+// Date:     Wed, 27 Jan 1993 16:39:13 -0500
+// Subject:  g++ bug
+// Message-ID: <199301272139.AA25514@world.std.com>
+
+
+const int ic = 1;
+void f(int& arg)
+{ // ERROR - argument 1
+        if (arg) ;
+}
+const int& icr = ic;
+
+int main(void)
+{
+  f(icr);   // g++ does not give error here// ERROR - .*
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/init9.C b/gcc/testsuite/g++.old-deja/g++.law/init9.C
new file mode 100644
index 00000000000..d6cec1b27aa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/init9.C
@@ -0,0 +1,35 @@
+// GROUPS passed initialization
+// init file
+// From: Richard Speed <speed@cs.montana.edu>
+// Date:     Sun, 6 Jun 1993 15:19:41 -0600 (MDT)
+// Subject:  excess elements in aggr initzer
+// Message-ID: <Pine.3.07.9306061541.A10267-b100000@fubar.cs.montana.edu>
+
+extern "C" void printf (char *, ...);
+
+class samp {
+        int a;
+public:
+        samp(int n) { a = n; }
+        int get_a() { return a; }
+};
+
+int main() {
+        samp ob[4] [2] = {  // Generated Error
+                1, 2,
+                3, 4,
+                5, 6,
+                7, 8,
+        };
+        int i;
+
+	if (ob[0][0].get_a() == 1 && ob[0][1].get_a() == 2
+	    && ob[1][0].get_a() == 3 && ob[1][1].get_a() == 4
+	    && ob[2][0].get_a() == 5 && ob[2][1].get_a() == 6
+	    && ob[3][0].get_a() == 7 && ob[3][1].get_a() == 8)
+	  printf ("PASS\n");
+	else
+	  printf ("FAIL\n");
+
+        return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/inline4.C b/gcc/testsuite/g++.old-deja/g++.law/inline4.C
new file mode 100644
index 00000000000..e7c664cf936
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/inline4.C
@@ -0,0 +1,20 @@
+// GROUPS passed inlining
+// inline file
+// Message-Id: <9306020823.AA14027@joker>
+// From: stefan@mpi-sb.mpg.de
+// Subject: gcc-2.4.2  template function bug  (1)
+// Date: Wed, 2 Jun 93 10:23:14 +0200
+
+extern "C" int printf (const char *, ...);
+
+template <class T> inline T func(const T& x) { return x; }
+
+inline int func(const int& x) { return x; }
+
+
+int main()
+{ int x;
+  func(x);
+  printf ("PASS\n");
+ }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/inline6.C b/gcc/testsuite/g++.old-deja/g++.law/inline6.C
new file mode 100644
index 00000000000..f5306798bde
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/inline6.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed inlining
+// inline file
+// Message-Id: <199307162240.AA04019@world.std.com>
+// From: kol@world.std.com (Nikolay Yatsenko)
+// Subject: g++ bug: crash with extern C friend
+// Date: Fri, 16 Jul 1993 18:40:48 -0400
+
+inline void Ignore(){}
+
+extern "C" void foo() {}  // but without extern C  g++ compiles it
+
+struct A
+{
+  void f()     {Ignore();}
+  friend void foo ();
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/inline7.C b/gcc/testsuite/g++.old-deja/g++.law/inline7.C
new file mode 100644
index 00000000000..0a1d373d44e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/inline7.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed inlining
+   template <class Type>
+struct A {
+   typedef int X;
+   A() {}
+   virtual ~A() { }
+};
+   template <class Type>
+struct B : public A<Type> {
+   B() { }
+}; 
+B<int>::X x;
diff --git a/gcc/testsuite/g++.old-deja/g++.law/memoized1.C b/gcc/testsuite/g++.old-deja/g++.law/memoized1.C
new file mode 100644
index 00000000000..16e63e2161f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/memoized1.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// Special g++ Options: -fsave-memoized
+// GROUPS passed memoized
+class CArray
+{
+public:
+  CArray();
+};
+class CBTree : public CArray
+{
+};
+class CData
+{
+public:
+  virtual               ~CData();
+};
+class CStr  : public CData
+{
+  inline int     Read();
+  inline int     Write() const;
+};
+class CResource : private CBTree
+{
+  struct SResourceNode
+  {
+    CStr xKey;
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/mentor1.C b/gcc/testsuite/g++.old-deja/g++.law/mentor1.C
new file mode 100644
index 00000000000..a9362e07da8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/mentor1.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// Special g++ Options: -O
+// GROUPS passed mentor
+struct Word {
+   struct S1 *p1;
+};
+struct S1 {
+   Word o;
+   void shift_left(int delta, int ct);
+};
+inline void S1::shift_left(int delta, int ct)
+{
+   int cnt = ct;
+   for (S1 *to_p = this, *from_p = to_p + delta; cnt--;) *to_p++ = *from_p++;
+}
+
+void dispose_t(S1 *tp, int from_index, int ct, const int d_last_t)
+{
+        int new_ct = d_last_t + 1 - ct;
+        tp[0].o.p1[from_index].shift_left(ct, new_ct - from_index);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/missed-error1.C b/gcc/testsuite/g++.old-deja/g++.law/missed-error1.C
new file mode 100644
index 00000000000..5091e7d7b61
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/missed-error1.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed missed-error
+// missed-error file
+// From: John Carr <jfc@Athena.MIT.EDU>
+// Date:     Tue, 02 Feb 1993 07:38:53 EST
+// Subject:  Re: g++ ignores language context of function pointers
+// Message-ID: <9302021238.AA01513@Achates.MIT.EDU>
+
+typedef void (*pfv)();
+void f ();
+
+extern "C"
+{
+  typedef void (*pcfv)(void);
+  void cf (void);
+}
+
+pfv p = f;
+pfv p2 = cf;			// ERROR - mismatch XFAIL *-*-*
+pcfv p3 = f;			// ERROR - mismatch XFAIL *-*-*
+pcfv p4 = cf;
diff --git a/gcc/testsuite/g++.old-deja/g++.law/missed-error2.C b/gcc/testsuite/g++.old-deja/g++.law/missed-error2.C
new file mode 100644
index 00000000000..18a026d1502
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/missed-error2.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// GROUPS passed missed-error
+// missed-error file
+// From: ndc!don@csvax.cs.caltech.edu (Don Erway)
+// Date:     Thu, 21 May 92 15:40:45 PDT
+// Subject:  More on [g++ 2.1 : overloaded function selection incorrect]
+// Message-ID: <9205212240.AA17934@ndc.com>
+
+#include <iostream.h>
+
+inline int max(int a, int b) {return a > b ? a : b;}; // ERROR - candidate
+inline double max(double a, double b) {return a > b ? a : b;}; // ERROR - candidate
+
+int main() {
+   static void foo(int i, int j, double x, double y) ;// ERROR - .*
+
+   foo(4, -37, 14.39, 14.38);
+}
+
+// 971006 we no longer give an error for this since we emit a hard error
+// about the declaration above
+static void foo(int i, int j, double x, double y) { 
+
+   cout << "Max(int): " << max(i,j) << " Max(double): " <<
+max(x,y) << '\n';
+   cout << "Max(int, double): " << max(i, y) << '\n';// ERROR - 
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/missed-error3.C b/gcc/testsuite/g++.old-deja/g++.law/missed-error3.C
new file mode 100644
index 00000000000..017ce5dd420
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/missed-error3.C
@@ -0,0 +1,124 @@
+// Build don't link: 
+// GROUPS passed missed-error
+// missed-error file
+// From: Neil Wilson <csf004@cch.coventry.ac.uk>
+// Date:     Tue, 28 Apr 92 13:53:54 WET DST
+// Subject:  g++ version 2.1 bugs
+// Message-ID: <15717.9204281253@cch.coventry.ac.uk>
+
+
+// enum bool { FALSE = 0, TRUE = 1 };
+
+typedef int T;
+
+class Traversable {
+public:
+    virtual const T item() const = 0;
+    virtual const bool off() const = 0;
+    virtual ~Traversable() { };
+};
+
+class Chain : public Traversable {
+public:
+    virtual const int count() const = 0;
+    virtual const bool empty() const = 0;
+    virtual void forth() const = 0;
+    virtual const bool isfirst() const = 0;
+    virtual const bool islast() const = 0;
+    virtual const int position() const = 0;
+    virtual const T first() const = 0;
+    virtual const T last() const = 0;
+    virtual const T i_th(const int index) const = 0;
+    virtual void start() const = 0;
+    virtual void back() const = 0;
+    virtual void finish() const = 0;
+    virtual void move(const int index) const = 0;
+    virtual void go(const int index) const = 0;
+    virtual void put(const T value) = 0;
+    virtual void put_i_th(const T value, const int index) = 0;
+    virtual void swap(const int index) = 0;
+    virtual void wipe_out() = 0;
+};
+class List : public Chain {
+protected:
+    int item_count;
+    int cursor_position;
+    virtual void go_offleft() const = 0;
+    virtual void go_offright() const = 0;
+    virtual void copy(const List& other) = 0;
+public:
+    List() : item_count(0), cursor_position(0) { };
+    virtual const int count() const;
+    virtual const bool empty() const;
+    virtual const bool isfirst() const;
+    virtual const bool islast() const;
+    virtual const bool offleft() const;
+    virtual const bool offright() const;
+    virtual const bool off() const;
+    virtual const int position() const;
+    virtual const T first() const;
+    virtual const T last() const;
+    virtual const T i_th(const int index) const;
+    virtual void start() const;
+    virtual void forth() const;
+    virtual void back() const;
+    virtual void finish() const;
+    virtual void move(const int index) const;
+    virtual void go(const int index) const;
+    friend const bool operator==(const List& left,
+	const List& right);
+    friend const bool operator!=(const List& left,
+	const List& right);
+    virtual void put_i_th(const T value, const int index);
+    virtual void swap(const int index);
+};
+typedef int T;
+class Array {
+private:
+    int lower_index;
+    int upper_index;
+    T *array;
+protected:
+    virtual void allocate(const int minindex, const int maxindex);
+    virtual void copy(const Array&other);
+public:
+    Array(const int minindex, const int maxindex);
+    Array(const Array& other);
+    virtual const int count() const;
+    virtual const int lower() const;
+    virtual const int upper() const;
+    virtual const T item(const int index) const;
+      const T Array::operator[](const int index); // ERROR - qualification ignored
+    virtual const bool valid_index(const int index) const;
+    virtual const bool empty() const;
+    friend const bool operator==(const Array& left, const Array& right);
+    friend const bool operator!=(const Array& left, const Array& right);
+    virtual void put(const T value, const int index);
+    virtual void wipe_out();
+    Array& operator=(const Array& other);
+    virtual ~Array();
+};
+class Fixed_List: public List, private Array {
+protected:
+    virtual void go_offleft() const;
+    virtual void go_offright() const;
+    virtual void copy(const List& other);
+public:
+    Fixed_List(const List& other);
+    Fixed_List(const int size): Array(1, size) { };
+    virtual const bool empty() const;
+    virtual const int count() const;
+    virtual const T item() const;
+    virtual const T i_th(const int index) const;
+    virtual void move(const int index) const;
+    virtual void put(const T value);
+    virtual void put_i_th(const T value, const int index);
+    virtual void wipe_out() { };
+    Fixed_List& operator=(const List& other);
+};
+
+void Fixed_List::go_offleft() const
+{
+    cursor_position = 0;// ERROR - 
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/missing1.C b/gcc/testsuite/g++.old-deja/g++.law/missing1.C
new file mode 100644
index 00000000000..e6505f578a5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/missing1.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed missing
+// missing file
+// Message-Id: <9207100259.AA11702@quaestor>
+// From: adam@inference.com (David Adam)
+// Subject: G++ does not allow parens around declarators.
+// Date: Thu, 9 Jul 92 19:59:51 PDT
+
+void foo()
+{
+  long (bar)[5];
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/nest1.C b/gcc/testsuite/g++.old-deja/g++.law/nest1.C
new file mode 100644
index 00000000000..e8fa80ca9f4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/nest1.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed nest
+// nest file
+// From: gs4t@virginia.edu (Gnanasekaran  Swaminathan)
+// Date:     Wed, 30 Dec 1992 20:38:07 GMT
+// Subject:  Local type names bug in g++ 2.3.3
+// Message-ID: <1992Dec30.203807.17504@murdoch.acc.Virginia.EDU>
+
+typedef char* T; // ERROR - previous declaration
+
+struct Y {
+    T a;
+    typedef long T; // error. See ARM p189-191 for details// ERROR - 
+    T b;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/nest2.C b/gcc/testsuite/g++.old-deja/g++.law/nest2.C
new file mode 100644
index 00000000000..adc05568332
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/nest2.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed nest
+struct B
+{
+    class B_I { };
+};
+
+struct D : public B
+{
+    B_I foo;
+    class I : public B_I { };
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/nest3.C b/gcc/testsuite/g++.old-deja/g++.law/nest3.C
new file mode 100644
index 00000000000..eac308e566a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/nest3.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed nest
+#include <iostream.h>
+
+struct inner {
+  static void f() { cout << "inner::f()\n";}
+};
+
+struct outer {
+
+  struct inner {
+    static void f() { cout << "outer::inner::f()\n";}
+  };
+
+  static void f() {
+    inner::f();     //call of outer::inner::f()
+    ::inner::f();   //(try to) call inner::f() => parse error
+  }
+};
+
+int main() {
+  outer::f();
+  cout << endl;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/nest4.C b/gcc/testsuite/g++.old-deja/g++.law/nest4.C
new file mode 100644
index 00000000000..98b085fba0e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/nest4.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed nest
+// nest file
+// From: Neal Young <ney@princeton.edu>
+// Date:     Mon, 11 Oct 93 17:03:59 EDT
+// Subject:  g++ 2.4.5 bug report: local class decl can't access local static var
+// Message-ID: <9310112103.AA06326@cs>
+
+void f()
+{
+  static int s;
+
+  struct local {
+    int j() { return s; }       // should be okay, see 1991 ref. man. r.9.8
+  };
+}
+
+int main()
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/nest5.C b/gcc/testsuite/g++.old-deja/g++.law/nest5.C
new file mode 100644
index 00000000000..99e8508e852
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/nest5.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed nest
+// nest file
+// From: tal@vlsi.cs.caltech.edu
+// Date:     Mon, 11 Oct 93 16:26:02 -0700
+// Subject:  Serious bug: g++2.4.5 -Doesn't support local classes
+// Message-ID: <9310112325.AA13386@vlsi.cs.caltech.edu>
+
+void foo() {
+  class Wrapper {
+  public:
+    void F (void * Wrapperptr)
+    {
+      Wrapper * wrapptr = (  Wrapper  *) Wrapperptr;
+    }
+  };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators10.C b/gcc/testsuite/g++.old-deja/g++.law/operators10.C
new file mode 100644
index 00000000000..c87880fb9a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators10.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-eq file
+// Message-Id: <9306040324.AA22954@balder.cs.wisc.edu>
+// From: so@cs.wisc.edu (Bryan So)
+// Subject: g++ bug
+// Date: Thu, 3 Jun 93 22:24:13 -0500
+
+template <class T>
+struct Test {
+    int data;
+    Test& operator=(int i) { data = i; return *this; }
+};
+
+
+int main()
+{
+    Test<int> i, j;
+
+    i = j;
+
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators11.C b/gcc/testsuite/g++.old-deja/g++.law/operators11.C
new file mode 100644
index 00000000000..16eccea6e40
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators11.C
@@ -0,0 +1,36 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-eq file
+// Message-Id: <CCJrut.9M7@csc.ti.com>
+// From: rowlands@hc.ti.com (Jon Rowlands)
+// Subject: g++ 2.4.5: assignment operator in base class
+// Date: Mon, 30 Aug 1993 00:54:29 GMT
+
+class B {
+public:
+	B &	operator = (B);	// delete this line and problem goes away
+};
+
+class D : public B {
+public:
+	D();
+	D(int);
+	D(B);
+};
+
+int
+main() {
+	B	b;
+	D	d;
+
+	d = d;
+
+	d = 0;	// t.cxx:20: assignment not defined for type `D'
+	d = D(0);
+
+	d = b;	// t.cxx:23: assignment not defined for type `D'
+	d = D(b);
+
+	return(0);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators12.C b/gcc/testsuite/g++.old-deja/g++.law/operators12.C
new file mode 100644
index 00000000000..cd5312bc093
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators12.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-eq file
+// Message-Id: <199311181618.AA27761@oil.cs.columbia.edu>
+// From: Sam Fenster <fenster@cs.columbia.edu>
+// Subject: g++ 2.5.3 can't disable assignment
+// Date: Thu, 18 Nov 1993 11:18:18 -0500
+
+class B
+   {
+   B &operator = (const B &);      //Disable assignment!
+  public:
+   virtual ~B () {}
+   };
+
+class D: public B
+   {
+  public:
+   D () {}
+   };
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators13.C b/gcc/testsuite/g++.old-deja/g++.law/operators13.C
new file mode 100644
index 00000000000..f423238b824
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators13.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-eq file
+// Message-Id: <1993Nov18.210502.28842@midway.uchicago.edu>
+// From: mps@dent.uchicago.edu (Michael Spertus)
+// Subject: g++ 2.5.4 bug : operator=
+// Date: Thu, 18 Nov 1993 21:05:02 GMT
+
+class T {
+};
+
+class EP {
+public:
+  void operator=(T *);
+};
+
+
+void EP::operator=(T *) { }
+
+int main()
+{
+  EP ep1, ep2;
+  ep1 = ep2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators14.C b/gcc/testsuite/g++.old-deja/g++.law/operators14.C
new file mode 100644
index 00000000000..22e12565329
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators14.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed operators
+void foo (int * a, int * b, int * c) {}
+
+int main() {
+	int a,b,c;
+	foo (&a, &b, &c);
+	(a = b) = c;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators15.C b/gcc/testsuite/g++.old-deja/g++.law/operators15.C
new file mode 100644
index 00000000000..0b0623c94c5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators15.C
@@ -0,0 +1,27 @@
+// GROUPS passed operators
+// opr-del file
+// Message-Id: <199301272137.AA25213@world.std.com>
+// From: kol@world.std.com (Nikolay Yatsenko)
+// Subject: bug report
+// Date: Wed, 27 Jan 1993 16:37:30 -0500
+
+extern "C" int printf(const char* ...);
+
+int     delete_counter = -1;
+
+struct T{
+  void operator delete (void * p) {delete_counter ++; ::operator delete(p);}
+};
+
+int main(void)
+{
+  T * ps1 = new T;
+
+  ::delete ps1;             // Wrong T::operator delete() is called here
+
+  if (delete_counter != -1)
+    printf ("FAIL\n");
+  else
+    printf ("PASS\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators16.C b/gcc/testsuite/g++.old-deja/g++.law/operators16.C
new file mode 100644
index 00000000000..3298e3090b8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators16.C
@@ -0,0 +1,29 @@
+// GROUPS passed operators
+// copy file
+// From: gfm@mencon.mencon.oz.au (Graham Menhennitt)
+// Date:     Thu, 29 Apr 93 20:53:07 EST
+// Subject:  4 bugs in g++ 2.3.3
+// Message-ID: <9304291053.AA00090@mencon>
+
+#include <stdio.h>
+
+int pass = 0;
+struct A {
+        A(void) {}
+        A(const A& a) { ; }
+        A& operator = (const A& a) { pass = 1; }
+};
+
+struct B {
+        B(const A& aa) { B::a = aa; }
+        A a;
+};
+
+int main(void)
+{
+        B(A());
+	if (pass)
+		printf ("PASS\n");
+	else
+		printf ("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators17.C b/gcc/testsuite/g++.old-deja/g++.law/operators17.C
new file mode 100644
index 00000000000..e652d9cdd79
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators17.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// Special g++ Options: -Wall -pedantic-errors
+// GROUPS passed operators
+// copy file
+// From: gfm@mencon.mencon.oz.au (Graham Menhennitt)
+// Date:     Thu, 29 Apr 93 20:53:07 EST
+// Subject:  4 bugs in g++ 2.3.3
+// Message-ID: <9304291053.AA00090@mencon>
+
+        struct A {
+                A& operator = (const A& a) {}// ERROR - 
+        };
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators18.C b/gcc/testsuite/g++.old-deja/g++.law/operators18.C
new file mode 100644
index 00000000000..74ea15915f5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators18.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-ampr file
+// From: mecklen@oops.cs.utah.edu (Robert Mecklenburg)
+// Date:     Thu, 8 Oct 92 16:33:08 -0600
+// Subject:  Type conversion and overloading bugs in 2.2.2
+// Message-ID: <9210082233.AA28203@hellgate.utah.edu>
+
+        enum E { a, b, c };
+        struct Estr {
+            E value;
+            Estr()                              {}
+            Estr( int i ) : value( (E)i )       {}
+            operator E()                        { return value; }
+        };
+        extern Estr baz();
+        int bazz() { return baz() & 2; }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators19.C b/gcc/testsuite/g++.old-deja/g++.law/operators19.C
new file mode 100644
index 00000000000..37560411151
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators19.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-ampr file
+// From: Jarkko Sonninen <Jarkko.Sonninen@lut.fi>
+// Date:     Thu, 7 Oct 1993 08:25:26 +0200
+// Subject:  type of base class member
+// Message-ID: <199310070625.AA18653@kaisa.it.lut.fi>
+
+class A {
+  public:
+    int j;
+};
+
+class B: public A {
+  public:
+    B () {
+        !(A::j);
+    };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators2.C b/gcc/testsuite/g++.old-deja/g++.law/operators2.C
new file mode 100644
index 00000000000..82954ff7abe
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators2.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-conv file
+// Message-Id: <199301260142.AA13995@world.std.com>
+// From: gparker@world.std.com (Glenn P Parker)
+// Subject: gcc bug
+// Date: Mon, 25 Jan 1993 20:42:35 -0500
+
+int main(void)
+{
+  int i = int();  // g++ 2.3.3 cannot compile it.
+
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators21.C b/gcc/testsuite/g++.old-deja/g++.law/operators21.C
new file mode 100644
index 00000000000..a4aac7d3143
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators21.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed operators
+
+struct A {
+        int x;
+};
+
+int operator()(A x,float y) {// ERROR - .*
+        return 1;
+}
+
+int main() {
+        A x;
+        x(1.0); // ERROR - no match
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators22.C b/gcc/testsuite/g++.old-deja/g++.law/operators22.C
new file mode 100644
index 00000000000..e550dac48a7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators22.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed operators
+template <class T>
+class t {
+public:
+  t() {}
+};
+
+class m {
+  t<int> c;
+public:
+  m() : c() {}
+};
+
+m *p() {return new m;}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators23.C b/gcc/testsuite/g++.old-deja/g++.law/operators23.C
new file mode 100644
index 00000000000..7271840baa9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators23.C
@@ -0,0 +1,35 @@
+// GROUPS passed operators
+// opr-new file
+// From: (The Crossjammer) <xjam@cork.cs.berkeley.edu>
+// Date:     Mon, 23 Nov 92 23:35:26 PST
+// Subject:  g++-2.3.1 : Incorrectly calls overloaded operator new
+// Message-ID: <9211240735.AA06872@cork.CS.Berkeley.EDU>
+
+
+#include <stdio.h>
+#include <stdlib.h>
+
+class blah {
+     int j;
+   public:
+     blah();
+     void *operator new(size_t size) throw();
+};
+
+inline blah::blah() : j(0) {
+	  
+}
+
+
+void *blah::operator new(size_t size) throw(){
+     printf ("FAIL\n");
+     exit (1);
+     return NULL;
+}
+
+int main(int arg, char** argv) {
+     blah* blahPtr;
+
+     blahPtr = new blah[100];
+     printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators24.C b/gcc/testsuite/g++.old-deja/g++.law/operators24.C
new file mode 100644
index 00000000000..46346e5942c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators24.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-new file
+// From: rwave!myersn%rwave.roguewave@cs.orst.edu (Nathan Myers)
+// Date:     Wed, 16 Dec 92 11:55 PST
+// Subject:  2.3.2: friend decl breaks member op new
+// Message-ID: <m0n24qP-0000GmC@rwave.roguewave.com>
+
+#include <stddef.h>
+struct Link {
+  void* operator new(size_t, int);
+  friend void* __builtin_new(size_t);  // This declaration triggers the bug
+};
+void f() { new(2) Link; }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators25.C b/gcc/testsuite/g++.old-deja/g++.law/operators25.C
new file mode 100644
index 00000000000..4b701b6136f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators25.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-new file
+// From: gparker@world.std.com (Glenn P Parker)
+// Date:     Mon, 25 Jan 1993 20:43:43 -0500
+// Subject:  gcc bug
+// Message-ID: <199301260143.AA14133@world.std.com>
+
+typedef int (**PPF)(int);
+
+int main(void)
+{
+  PPF pf2 = new (int (*) (int));     // internal compiler error on this line.
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators27.C b/gcc/testsuite/g++.old-deja/g++.law/operators27.C
new file mode 100644
index 00000000000..6a07176ba3a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators27.C
@@ -0,0 +1,33 @@
+// GROUPS passed operators
+// opr-new file
+// From: David Binderman 3841 <dcb@us-es.sel.de>
+// Date:     Mon, 21 Jun 93 11:42:11 +0200
+// Subject:  G++ 2.4.3 and operator new
+// Message-ID: <9306210942.AA10276@slsvitt.us-es.sel.de>
+
+int FLAG=0;
+
+#include <new>
+
+extern "C" int printf( const char *, ...);
+
+void * operator new(size_t, const std::nothrow_t&) throw()         { FLAG=1; return 0; }
+
+class K {
+private:
+        int i;
+public:
+        K( int j) {
+                i = j;
+        }
+};
+
+int main(void)
+{
+    K * pK = new (std::nothrow) K( 10);
+    if ( FLAG != 1 )
+	printf ("FAIL\n");
+    else
+	printf ("PASS\n");
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators28.C b/gcc/testsuite/g++.old-deja/g++.law/operators28.C
new file mode 100644
index 00000000000..3600fb27418
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators28.C
@@ -0,0 +1,30 @@
+// Build don't link: 
+// GROUPS passed operators
+#include <sys/types.h>
+#include <stdio.h>
+
+class new_test
+{
+  int type;
+public:
+  void* operator new(size_t sz, int count, int type);
+};
+
+void* new_test::operator new(size_t sz, int count, int type)
+{
+  void *p;
+
+  printf("%d %d %d\n", sz, count, type);
+
+  p = new char[sz * count];
+  ((new_test *)p)->type = type;
+  return p;
+};
+
+int main()
+{
+  new_test *test;
+  int count = 13;
+
+  test = new(count, 1) new_test;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators29.C b/gcc/testsuite/g++.old-deja/g++.law/operators29.C
new file mode 100644
index 00000000000..c24bbe4b577
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators29.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed operators
+// (Message bugs/opr-del:4)
+// From: jamshid@ses.com (Jamshid Afshar)
+// Date:     Fri, 25 Feb 94 18:44:01 CST
+// Subject:  Re: delete on "smart pointers"
+// Message-ID: <9402262328.AA16321@pancake>
+// 
+// Who was apparently replying to kuhlins@hawk.wifo.uni-mannheim.de
+
+
+template<class T> class Ptr {
+public:
+  Ptr(T*);
+  operator T*();
+};
+
+int main() {
+  Ptr<int> ip = new int(2);
+  delete ip;
+  operator delete(ip);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators3.C b/gcc/testsuite/g++.old-deja/g++.law/operators3.C
new file mode 100644
index 00000000000..e4a8341cca9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators3.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-pl file
+// Message-Id: <9212010409.AA24967@zeus.research.otc.com.au>
+// From: grahamd@zeus.research.otca.oz.au (Graham Dumpleton)
+// Subject: Failure to use conversion operator.
+// Date: Tue, 1 Dec 92 15:11:18 EST
+
+class BUG1
+{
+  public:
+
+    operator char*() const { return myData; }
+    char* myData;
+};
+
+void bug1()
+{
+  BUG1 bug1;
+  bug1.myData = "0123456789";
+  char* s = bug1 + 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators30.C b/gcc/testsuite/g++.old-deja/g++.law/operators30.C
new file mode 100644
index 00000000000..4236dc519a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators30.C
@@ -0,0 +1,25 @@
+// GROUPS passed operators
+// opr-mm file
+// Date: Thu, 2 Jun 94 10:00:29 +0200
+// From: chatty@cenatls.cena.dgac.fr (Stephane Chatty)
+// Message-Id: <9406020800.AA14201@geant.cenatls.cena.dgac.fr>
+// Subject: result of operator -- with g++-2.5.8
+
+#include <stdio.h>
+
+void nop()
+{
+}
+
+int main ()
+{
+        int a = 2;
+
+        if (----a == 0)
+		nop ();
+
+	if (a == 0)
+		printf("PASS\n");
+	else
+		printf("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators31.C b/gcc/testsuite/g++.old-deja/g++.law/operators31.C
new file mode 100644
index 00000000000..a2ba7201d6b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators31.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-del file
+// From: Eberhard Mattes <mattes@azu.informatik.uni-stuttgart.de>
+// Date:     Thu, 4 Aug 94 08:19:20 +0200
+// Subject:  delete [] A::s
+// Message-ID: <9408040619.AA27602@azu.informatik.uni-stuttgart.de>
+
+class A
+{
+  char *s;
+public:
+  void f ();
+};
+
+void A::f ()
+{
+  delete [] A::s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators32.C b/gcc/testsuite/g++.old-deja/g++.law/operators32.C
new file mode 100644
index 00000000000..26e439876a9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators32.C
@@ -0,0 +1,55 @@
+// Build don't link: 
+// GROUPS passed operators
+#include <iostream.h>
+
+//
+// frees space allocated for N-D array
+//
+
+template <class T>
+void free(long rows, T** array)
+{
+for( long i = 0; i < rows; i++ )
+  delete [] array[i];                   // delete row
+delete [] array;                        // delete outer array
+}
+
+template <class T>
+T* allocate1d(long size, T*& array)
+{
+return array = new T[size];
+}
+
+template <class T>
+T** allocate2d(long d1, long d2, T**& array)
+{
+if( allocate1d(d1, array) != 0 )
+  {
+  for( long i = 0; i < d1; i++ )
+    {
+    if( allocate1d(d2, array[i]) == 0 )
+      {
+      free(i,array);
+      return array;
+      }
+    }
+  }
+return array;
+}
+
+int main()
+{
+long d1 = 3, d2 = 4;
+class foo
+{
+public:
+foo() {cout << "foo created" << endl; }
+
+~foo() {cout << "foo deleted" << endl; }
+};
+
+foo **f2;
+allocate2d(d1, d2, f2);// ERROR -  type.*// ERROR -    trying to.*
+free(d1, f2);// ERROR -  type.*// ERROR -    trying to.*
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators33.C b/gcc/testsuite/g++.old-deja/g++.law/operators33.C
new file mode 100644
index 00000000000..bdf5147b875
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators33.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-new file
+// From: flisakow@cae.wisc.edu
+// Date:     Thu, 1 Sep 94 18:21:09 CDT
+// Subject:  g++ bug?
+// Message-ID: <9409012321.AA05346@hprisc-19.cae.wisc.edu>
+
+#include <stdio.h>
+
+
+struct fcell {
+        FILE *fd;
+        struct fcell *next;
+};
+
+
+class FStack {
+public:
+        struct fcell *top;
+        FStack() { top = NULL ; } ;
+        inline void push(FILE * fd1, int line_num, char *fname = NULL) {
+                struct fcell *tmp = new struct fcell;
+                tmp->fd = fd1;
+                tmp->next = top;
+                top = tmp ;
+        }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators34.C b/gcc/testsuite/g++.old-deja/g++.law/operators34.C
new file mode 100644
index 00000000000..316500e5841
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators34.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// GROUPS passed operators
+class A {
+    public:
+      A() {
+      }
+};
+
+static class A *A_new_() {
+    return new class A;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators4.C b/gcc/testsuite/g++.old-deja/g++.law/operators4.C
new file mode 100644
index 00000000000..044249fa8b7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators4.C
@@ -0,0 +1,31 @@
+// GROUPS passed operators
+// opr-del file
+// From: rollins@bart.ee.queensu.ca (Mark Rollins)
+// Date:     Thu, 3 Sep 1992 22:01:03 -0400 Fri, 4 Sep 1992 02:00:25 GMT
+// Subject:  delete [size] pointer; Problem
+// Message-ID: <92Sep3.220137edt.30@jarvis.csri.toronto.edu>
+
+#include <complex>
+typedef complex<double> Complex;
+#include <stdio.h>
+
+class Vector {
+  int           size;
+  Complex       *v;
+ public:
+  Vector(int s=1) { size = s; v = new Complex[size];};
+  ~Vector() { delete [size] v;}// ERROR -  warning
+};
+
+void foo(int s)
+{
+  Vector junk(s);
+}
+
+int main()
+{
+  Vector* test;
+  for (int i=0;i<40;i++) // was 100000
+        foo(1000);
+  printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators6.C b/gcc/testsuite/g++.old-deja/g++.law/operators6.C
new file mode 100644
index 00000000000..f66f6496f39
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators6.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-as file
+// From: Klaus Ahrens <ahrens@informatik.hu-berlin.de>
+// Date:     Fri, 26 Mar 93 12:50:37 mez
+// Subject:  no default assignment
+// Message-ID: <199303261149.TA23114@mail.Germany.EU.net>
+
+class A {
+public:
+        A(int){}
+        A& operator=(const A&){return *this;}
+};
+
+class B: public A {
+public:
+        B(int i): A(i) {}
+};
+
+int main()
+{
+        B b=1;
+        b=1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators8.C b/gcc/testsuite/g++.old-deja/g++.law/operators8.C
new file mode 100644
index 00000000000..5fd94bdd685
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators8.C
@@ -0,0 +1,49 @@
+// GROUPS passed operators
+#include <stdio.h>
+
+class shape {
+  public:
+    virtual void vDisplay(void) const = 0;
+  protected:
+    int X;
+    int Y;
+};
+
+class square :public shape {
+  public:
+    square(int x, int y, int width_) {
+	X = x;
+	Y = y;
+	width = width_;
+    }
+    void vDisplay(void) const {
+	printf ("PASS\n");
+    }
+  protected:
+    int width;
+};
+
+
+class triangle :public shape {
+  public:
+    triangle(int x, int y, int width_, int height_) {
+	X = x;
+	Y = y;
+	width = width_;
+	height = height_;
+    }
+    void vDisplay(void) const {
+	printf ("FAIL\n");
+    }
+  protected:
+    int width;
+    int height;
+};
+
+int main() {
+    shape* s1 = new square(4,4,5);
+    shape* s2 = new triangle(6,6,2,3);
+    *s1 = *s2;
+    s1->vDisplay();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/operators9.C b/gcc/testsuite/g++.old-deja/g++.law/operators9.C
new file mode 100644
index 00000000000..8aeac843b7b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/operators9.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed operators
+// opr-eq file
+// Message-Id: <9301141514.AA05925@mi.el.utwente.nl>
+// From: klamer@mi.el.utwente.nl (Klamer Schutte)
+// Subject: 2.3.3: failed to detect error
+// Date: Thu, 14 Jan 93 16:14:21 +0100
+
+class B
+{
+public:
+      operator=(B &); // ERROR - no type or storage class
+};
+
+void
+test(B &b1, const B &b2)
+{
+        b1 = b2;// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/parsing1.C b/gcc/testsuite/g++.old-deja/g++.law/parsing1.C
new file mode 100644
index 00000000000..7b032e3eb57
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/parsing1.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed parsing
+// parsing folder
+// From: hendrik%vedge.UUCP@iro.umontreal.ca
+// Date:     Wed, 23 Sep 92 17:10:28 -0400
+// Subject:  parenthesized method
+// Message-ID: <9209232110.AA02533@.>
+
+
+class goo{
+public:
+      void noo_bloo();
+};
+
+void choo(goo* too)
+{     (too->noo_bloo)();
+}
+
+void choo_too(goo* too)
+{     too->noo_bloo();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/parsing10.C b/gcc/testsuite/g++.old-deja/g++.law/parsing10.C
new file mode 100644
index 00000000000..9fee9ebc808
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/parsing10.C
@@ -0,0 +1,32 @@
+// Build don't link: 
+// GROUPS passed parsing
+// parsing folder
+// From: Eirik Fuller <eirik@elf.ithaca.ny.us>
+// Date:     Wed, 15 Dec 1993 17:06:11 -0500
+// Subject:  parse error
+// Message-ID: <199312152206.AA06584@tonttu.TC.Cornell.EDU>
+
+
+class s;
+
+template <class T>
+class t
+{
+public:
+  void f(T *t);
+};
+
+class l
+{
+public:
+  void s() {};
+};
+
+extern t<l> g;
+
+class p
+{
+public:
+  void *h;
+  s *a() {return (s *) h;};
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/parsing2.C b/gcc/testsuite/g++.old-deja/g++.law/parsing2.C
new file mode 100644
index 00000000000..5570ad93832
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/parsing2.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed parsing
+// parsing folder
+// From: jonathan@Pescadero.Stanford.EDU
+// Date:     Tue, 15 Sep 92 14:15:29 PDT
+// Subject:  Function taking as argument a pointer to a pointer to a function
+//	     that returns int causes coredump in cc1plus
+// Message-ID: <9209152115.AA07423@Pescadero.Stanford.EDU>
+
+    unsigned char FindMdc ( int (**)() );
+    unsigned char FindMdc2 ( int (**funcname)() );
diff --git a/gcc/testsuite/g++.old-deja/g++.law/parsing3.C b/gcc/testsuite/g++.old-deja/g++.law/parsing3.C
new file mode 100644
index 00000000000..8efee5b0f23
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/parsing3.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed parsing
+// parsing folder
+// From: tll@cco.caltech.edu (Tal Lewis Lancaster)
+// Date:     18 Mar 1993 17:09:43 GMT
+// Subject:  Re: unexpected difference between gcc and g++ (both 2.3.3)
+// Message-ID: <1oaacnINNt20@gap.caltech.edu>
+
+/* Notice that this case parses fine */
+int (* volatile y)[10];
+
+void foo2() {
+        /* The parser can't handle it now */
+        int (* volatile x)[10];
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/parsing4.C b/gcc/testsuite/g++.old-deja/g++.law/parsing4.C
new file mode 100644
index 00000000000..e834d6f939e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/parsing4.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed parsing
+// parsing folder
+// From: Glenn Engel <glenne@lsid.hp.com>
+// Date:     Fri, 29 Jan 93 18:42:03 PST
+// Subject:  Parse Error
+// Message-ID: <9301300242.AA15550@hplslk.lsid.hp.com>
+
+int test1(void (**roc)(int,int)); // parse error
+int test2(int id,void (**orc)(int,int)); // works
diff --git a/gcc/testsuite/g++.old-deja/g++.law/parsing5.C b/gcc/testsuite/g++.old-deja/g++.law/parsing5.C
new file mode 100644
index 00000000000..f3f847302c4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/parsing5.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed parsing
+// From: Teemu Torma <Teemu.Torma@frend.fi>
+// Date:     Mon, 15 Jun 92 18:42:25 +0300
+// Subject:  G++ 2.2.2: Strange parse error
+// Message-ID: <"relay.fren.501:15.05.92.15.42.30"@frend.fi>
+
+long (*foo1 ()) (); // This is ok.
+
+typedef long INT;
+INT (*foo2 ()) ();  // This is not, g++ says "parse error before `('"
diff --git a/gcc/testsuite/g++.old-deja/g++.law/parsing6.C b/gcc/testsuite/g++.old-deja/g++.law/parsing6.C
new file mode 100644
index 00000000000..63a660eef36
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/parsing6.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+// GROUPS passed parsing
+// parsing folder
+// From: "James S. Vera" <vera@fanaraaken.stanford.edu>
+// Date:     Thu, 01 Jul 1993 16:36:32 -0700
+// Subject:  Mildly complicated type not understood, 2.4.5
+// Message-ID: <9307012336.AA13841@fanaraaken.Stanford.EDU>
+
+typedef  int (*cow[3])(...);
+
+int main() {
+  cow fs;
+  int (*pig[3])(...); // line 5
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/parsing7.C b/gcc/testsuite/g++.old-deja/g++.law/parsing7.C
new file mode 100644
index 00000000000..1b73c951dd4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/parsing7.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed parsing
+// parsing folder
+// From: szahn%Robinie@goesser.sie.siemens.co.at (Hr. Zahn)
+// Date:     Mon, 5 Jul 93 10:45:51 +0200
+// Subject:  Bug report g++ 2.4.5, unexpected syntax errors
+// Message-ID: <9307050845.AA00499@ets5.uebemc.siemens.de>
+
+int f1(
+    int (**a1)()
+    );
+
+int f2(
+    int (**a1)()
+    );
+
+
+int f3(
+    int (**a1)( int a, int b )
+    );
+
+int f4(
+    int (**a1)( int a, int b )
+    );
diff --git a/gcc/testsuite/g++.old-deja/g++.law/parsing8.C b/gcc/testsuite/g++.old-deja/g++.law/parsing8.C
new file mode 100644
index 00000000000..d897849faa4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/parsing8.C
@@ -0,0 +1,31 @@
+// Build don't link: 
+// GROUPS passed parsing
+// parsing folder
+// From: nag@soft.flab.fujitsu.co.jp
+// Date:     Thu, 08 Jul 1993 10:54:59 +0900
+// Subject:  g++ cannot understand `void (**f)()'
+// Message-ID: <9307080155.AA00496@kumade.soft.flab.fujitsu.co.jp>
+
+        void
+        func() {
+                int ( * * i )[ 2 ];
+        }
+
+// Looks like this is probably the same problem
+// parsing folder
+// From: nag@soft.flab.fujitsu.co.jp
+// Date:     Thu, 08 Jul 1993 10:54:59 +0900
+// Subject:  g++ cannot understand `void (**f)()'
+// Message-ID: <9307080155.AA00496@kumade.soft.flab.fujitsu.co.jp>
+int main()
+{
+        void (**f)();
+}
+
+
+// Same as
+// From: Chris Dodd <dodd@csl.sri.com>
+// Date:     Fri, 16 Jul 93 17:05:04 -0700
+// Subject:  bug in declaration parsing in g++ 2.4.5
+// Message-ID: <9307170005.AA03857@pekoe.csl.sri.com>
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/parsing9.C b/gcc/testsuite/g++.old-deja/g++.law/parsing9.C
new file mode 100644
index 00000000000..0cd22fd81af
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/parsing9.C
@@ -0,0 +1,32 @@
+// Build don't link: 
+// GROUPS passed parsing
+// From: Jason Merrill <jason@cygnus.com>
+// Date:     Fri, 13 Aug 93 12:49:11 PDT
+// Subject:  2.4.5 won't compile array of pointers to functions returning T
+// Message-ID: <9308131949.AA26348@cygnus.com>
+// From: "Robert M. Keller" <keller@jarthur.Claremont.EDU>
+// Subject: g++ bug
+// Date: Fri, 13 Aug 93 10:09:27 PDT
+
+/* Testing declaration of "array of pointers to functions returning T" */
+
+typedef int T;
+
+T foo()
+{ return 10; }
+
+T bar()
+{ return 20; }
+
+T baz()
+{ return 30; }
+
+int main()
+{
+T (*apfrt[10])();
+
+apfrt[0] = foo;
+apfrt[1] = bar;
+apfrt[2] = baz;
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/patches1.C b/gcc/testsuite/g++.old-deja/g++.law/patches1.C
new file mode 100644
index 00000000000..3ec9321c336
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/patches1.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed patches
+// patches file
+// From: david.binderman@pmsr.philips.co.uk
+// Date:     Wed, 6 Oct 93 17:05:54 BST
+// Subject:  Reno 1.2 bug fix
+// Message-ID: <9310061605.AA04160@pmsr.philips.co.uk>
+
+int type(float)       { return 1; }
+int type(double)      { return 2; }
+int type(long double) { return 3; }
+
+extern "C" int printf( const char *, ...);
+
+int main()
+{
+      int i = 0;
+      if (type(0.0) != 2)
+              ++i;
+      if (i > 0)
+	printf ("FAIL\n");
+      else
+	printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/pic1.C b/gcc/testsuite/g++.old-deja/g++.law/pic1.C
new file mode 100644
index 00000000000..818d3d0dd82
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/pic1.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+// GROUPS passed operators
+// pic file
+// Message-Id: <199406132030.NAA23508@dewitt.eecs.berkeley.edu>
+// Subject: gcc-2.5.8 -fpic fails to compile extern const char static initializer
+// Date: Mon, 13 Jun 1994 13:30:14 -0700
+// From: Christopher Hylands <cxh@dewitt.eecs.berkeley.edu>
+
+extern const char SDFdomainName[] = "SDF";
diff --git a/gcc/testsuite/g++.old-deja/g++.law/profile1.C b/gcc/testsuite/g++.old-deja/g++.law/profile1.C
new file mode 100644
index 00000000000..3c671a2db54
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/profile1.C
@@ -0,0 +1,9 @@
+// Special g++ Options: -pg
+// GROUPS passed profiling
+// Skip if not native
+// excess errors test - XFAIL m68k-motorola-sysv m88k-motorola-sysv3 mips*-*-* i[3456]86-*-sco3.2v5*
+#include <stdio.h>
+main()
+{
+  printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/refs1.C b/gcc/testsuite/g++.old-deja/g++.law/refs1.C
new file mode 100644
index 00000000000..0efe9db3ff4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/refs1.C
@@ -0,0 +1,42 @@
+// GROUPS passed references
+// (Message bugs/refs:1)
+// From: tal@vlsi.cs.caltech.edu
+// Date:     Fri, 25 Feb 94 23:55:50 -0800
+// Subject:  g++-2.5.8 produces incorrect code for references
+// Message-ID: <9402260755.AA27693@vlsi.cs.caltech.edu>
+
+#include <stdio.h>
+
+class C {
+private:
+   char** list;
+public:
+   C(char** );
+   void count (int&);
+};
+
+C::C (char** l) {
+   list = l;
+}
+
+void C::count (int& total) {
+   if (*list == NULL)
+      return;
+   else {
+      list++;
+      count (++total); // THIS IS WHERE THE TROUBLE STARTS
+   }
+}
+
+char * foo[] = {
+   "one", "two", "three", NULL};
+
+int main() {
+   C c(foo);
+   int i = 0;
+   c.count(i);
+   if (i == 3)
+     printf ("PASS\n");
+   else
+     printf ("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/refs2.C b/gcc/testsuite/g++.old-deja/g++.law/refs2.C
new file mode 100644
index 00000000000..b310bf63317
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/refs2.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed references
+int func(int& i)
+{
+  static int& v = i;
+  return v;
+}
+
+int main()
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/refs3.C b/gcc/testsuite/g++.old-deja/g++.law/refs3.C
new file mode 100644
index 00000000000..e77dd7fad49
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/refs3.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed references
+const int& min(const int& n, const int& m)
+{
+        return n < m ? n : m;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/refs4.C b/gcc/testsuite/g++.old-deja/g++.law/refs4.C
new file mode 100644
index 00000000000..40e199a6858
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/refs4.C
@@ -0,0 +1,21 @@
+// GROUPS passed references
+extern "C" void printf (char *, ...);
+
+const int& min(const int& tX, const int& tY)
+{
+        return tX < tY ? tX : tY;
+}
+
+void foo(const int m, const int n)
+{
+	if (m == 1 && n == 100)
+	  printf("PASS\n");
+	else
+	  printf("FAIL\n");
+}
+
+int main()
+{
+        foo(min(2, 1), min(100, 200));
+        return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/scope1.C b/gcc/testsuite/g++.old-deja/g++.law/scope1.C
new file mode 100644
index 00000000000..aa70fde059c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/scope1.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed scoping
+// scoping file
+// From: kol@world.std.com (Nikolay Yatsenko)
+// Date:     Fri, 16 Jul 1993 18:48:32 -0400
+// Subject:  g++ gives wrong error for local structure
+// Message-ID: <199307162248.AA05360@world.std.com>
+
+int main(void)
+{
+  struct A{
+  public:       int i;
+    void set (int i)
+      {A::i = i;}           // g++ gives wrong error
+  };
+
+  A a;
+  a.set(17);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/scope2.C b/gcc/testsuite/g++.old-deja/g++.law/scope2.C
new file mode 100644
index 00000000000..bfefb61fc45
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/scope2.C
@@ -0,0 +1,44 @@
+// GROUPS passed scoping
+// scoping file
+// From: svkakkad@cs.utexas.edu (Sheetal V. Kakkad)
+// Date:     Tue, 5 Oct 93 12:38:49 -0500
+// Subject:  G++ 2.4.5 - global delete operator not called when using "::delete"
+// Message-ID: <9310051738.AA14586@boogie.cs.utexas.edu>
+
+#include <stdio.h>
+#include <stddef.h>
+#include <stdlib.h>
+
+class foo
+{
+ public:
+  foo () { ; }
+  ~foo () { ; }
+  void *operator new (size_t);
+  void operator delete (void *);
+};
+
+void *foo::operator new (size_t size)
+{
+  return malloc (size);
+}
+
+int overloaded_delete = 0;
+
+void foo::operator delete (void *data)
+{
+  free ((char *) data);
+  overloaded_delete++;
+}
+
+int main ()
+{
+  foo *f = new foo;
+  foo *ff = ::new foo;
+  ::delete ff;		// should call the default delete operator
+  delete f;
+  if (overloaded_delete == 1)
+    printf ("PASS\n");
+  else
+    printf ("FAIL\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/scope3.C b/gcc/testsuite/g++.old-deja/g++.law/scope3.C
new file mode 100644
index 00000000000..0f36e1b16e8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/scope3.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed scoping
+// local-class file
+// From: dcb@us-es.sel.de
+// Date:     Fri, 27 Nov 92 15:34:28 +0100
+// Subject:  GNU G++ 2.3.1 bug report
+// Message-ID: <9211271434.AA15612@us-es.sel.de>
+
+
+void f()
+{
+        {
+                struct A {
+                        A() {};
+                } a;
+        };
+        {
+                struct A {
+                        A() {};
+                } a ;
+        };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/scope4.C b/gcc/testsuite/g++.old-deja/g++.law/scope4.C
new file mode 100644
index 00000000000..1cfb54e9c34
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/scope4.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed scoping
+// local-class file
+// From: daniels@sugar.neosoft.com (Brad Daniels)
+// Date:     Thu, 5 Aug 93 15:36:36 CDT
+// Subject:  Bug in g++ 2.4.5: Can't touch nested class identifier inside its members
+// Message-ID: <9308051536.AA06115@NeoSoft.Com>
+
+void f() {
+    class foo {
+        int x;
+    public:
+        foo() : x(1) {}
+        int bar() { foo p; return p.x; }
+    };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/scope5.C b/gcc/testsuite/g++.old-deja/g++.law/scope5.C
new file mode 100644
index 00000000000..d7bcb63ac41
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/scope5.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed scoping
+// local-class file
+// From: schlaege@methusalix.ert.rwth-aachen.de (Chris Schlaeger H Zivojnovic)
+// Date:     Tue, 10 Aug 93 16:50:33 +0200
+// Subject:  Bug report
+// Message-ID: <9308101450.AA28016@methusalix.ert.rwth-aachen.de>
+
+int main()
+{
+        class foo
+        {
+                int i;
+        } ;
+        class bar
+        {
+                public:
+                        bar() { y = 0; }
+                        void f() { foo x; }
+                private:
+                        int y;
+        } ;
+
+        bar     c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/shadow1.C b/gcc/testsuite/g++.old-deja/g++.law/shadow1.C
new file mode 100644
index 00000000000..5338bea3c98
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/shadow1.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// Special g++ Options: -Wshadow
+// GROUPS passed shadow-warnings
+// shadow file
+// Message-Id: <9211061827.AA03517@harvey>
+// From: Jeff Gehlhaar <jbg@qualcomm.com>
+// Subject: GCC Bug..
+// Date: Fri, 6 Nov 1992 10:27:10 -0700
+
+class Class
+{
+public:
+        Class(void);            // constructor
+        int Shadow(void);       // member function
+private:
+        long value;
+};
+
+Class::Class(void)
+{
+        value = 0;
+}
+
+static inline unsigned char
+Function(int Shadow)
+{
+        return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/shadow2.C b/gcc/testsuite/g++.old-deja/g++.law/shadow2.C
new file mode 100644
index 00000000000..899fe938640
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/shadow2.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// Special g++ Options: -Wshadow
+// GROUPS passed shadow-warnings
+// (Message bugs/shadow:2)
+// From: michael@utex.rni.sub.org (Michael Utech)
+// Date:     Sat, 22 Jan 1994 04:28:00 +0100
+// Subject:  very minor problem/bug in gcc-2.5.4, -Wshadow
+// Message-ID: <m0pNZ1T-0008QUC@utex.rni.sub.org>
+
+class X
+{
+  int count;
+public:
+  X() {} // necessary to produce the `count' warning
+};
+
+template <class T>
+class Y
+{
+  T t;
+public:
+  int f (int count) { return (count); }
+};
+
+main ()
+{
+  Y<char> y;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/static-mem2.C b/gcc/testsuite/g++.old-deja/g++.law/static-mem2.C
new file mode 100644
index 00000000000..3a4489e618f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/static-mem2.C
@@ -0,0 +1,27 @@
+// Build don't link: 
+// GROUPS passed static-mem
+
+class desc;
+
+class a_desc {
+    public:
+
+    static desc the_desc;
+
+    virtual desc *get_desc();
+};
+
+class desc : public a_desc {
+    public:
+
+    static desc the_desc;
+
+    desc(int);
+
+    desc *get_desc();
+};
+
+
+desc desc::the_desc(1);
+
+desc a_desc::the_desc(0);
diff --git a/gcc/testsuite/g++.old-deja/g++.law/static-mem3.C b/gcc/testsuite/g++.old-deja/g++.law/static-mem3.C
new file mode 100644
index 00000000000..39e4fc2d454
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/static-mem3.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed static-mem
+// static-mem file
+// Message-Id: <9406021639.AA00789@oz.NeXT.COM>
+// From: Sumana Srinivasan <Sumana_Srinivasan@next.com>
+// Date: Thu,  2 Jun 94 09:39:09 -0700
+// Subject: static members function pointers
+
+class CRTFooBar;
+
+class CRTFoo {
+public:
+        static const CRTFooBar & defaultFooBar( );
+
+        CRTFoo( const CRTFoo & );
+        CRTFoo( );
+        CRTFoo( const char *,
+                const CRTFooBar &tp = CRTFoo::defaultFooBar(),
+                int = 0 );
+        CRTFoo &setFoo( double,
+                const CRTFooBar & = CRTFoo::defaultFooBar() );
+
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/static-mem4.C b/gcc/testsuite/g++.old-deja/g++.law/static-mem4.C
new file mode 100644
index 00000000000..09e16371d3d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/static-mem4.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed static-mem
+struct test {
+  void test_member() {
+    static test& ds = *this;    // FIX: static test* ds = this;
+  }
+};
+
+
+int main()
+{
+  test t;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/static-mem5.C b/gcc/testsuite/g++.old-deja/g++.law/static-mem5.C
new file mode 100644
index 00000000000..2ce0df16f3e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/static-mem5.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// Special g++ Options: -w
+// GROUPS passed static-mem
+// static-mem file
+// From: bunch@tazboy.jpl.nasa.gov (Walt Bunch)
+// Date:     Thu, 23 Jun 94 14:58:35 UNI
+// Subject:  bug report
+// Message-ID: <9406232258.AA03897@tazboy.JPL.NASA.GOV>
+
+
+class A
+{
+public:
+  static void F (int i) {}
+  static void A::G (int i) {}
+};
+
+main ()
+{
+  A::F (17);
+  A::G (42);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/template1.C b/gcc/testsuite/g++.old-deja/g++.law/template1.C
new file mode 100644
index 00000000000..bde15370309
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/template1.C
@@ -0,0 +1,30 @@
+// Build don't link: 
+// GROUPS passed templates
+
+class String {
+        char s[100];
+};
+
+template <class Element>
+class Art {
+public:
+        Element *data;
+        Art() { data=new Element[100]; }
+};
+
+template <class Key,class Value>
+class Assoc {
+public:
+        struct KeyValue {
+                Key key;
+                Value value;
+                int filled;
+        };
+
+        Art<KeyValue> data;
+        int fill;
+};
+
+int main() {
+        Assoc<String,String> table;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/template2.C b/gcc/testsuite/g++.old-deja/g++.law/template2.C
new file mode 100644
index 00000000000..7fa2c766b83
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/template2.C
@@ -0,0 +1,17 @@
+// GROUPS passed templates
+// Special g++ Options: -fguiding-decls
+extern "C" void printf (char *, ...);
+
+template<class T> T max(T a, T b) { return a > b ? a : b; }
+
+int max(int, int);
+
+main()
+{
+  int j;
+
+  j = max(1,2);
+  j = max (1, 'c');
+  printf ("PASS\n");
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/template3.C b/gcc/testsuite/g++.old-deja/g++.law/template3.C
new file mode 100644
index 00000000000..7523824864e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/template3.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed templates
+template< class R, class T1 = R, class T2 = T1 >
+struct plus
+  {
+  R operator()( const T1& x, const T2& y ) const
+    {
+    return x + y;
+    }
+  };
+
+int
+main()
+  {
+  plus< int > p;
+  return 0;
+  }
diff --git a/gcc/testsuite/g++.old-deja/g++.law/temps1.C b/gcc/testsuite/g++.old-deja/g++.law/temps1.C
new file mode 100644
index 00000000000..aa3e8e83bbe
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/temps1.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed temps
+// temps file
+// Date: Mon, 07 Sep 1992 13:12:28 EDT
+// From: richard@ttt.kth.se 
+struct foo
+{
+  char *s;
+  foo(char *x) { s=x; }
+};
+
+struct cookie
+{
+  foo * v;
+  cookie ( foo * x) { v=x; }
+};
+
+cookie cat(&foo("apabepa"));// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.law/temps2.C b/gcc/testsuite/g++.old-deja/g++.law/temps2.C
new file mode 100644
index 00000000000..4e216720c7b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/temps2.C
@@ -0,0 +1,54 @@
+// GROUPS passed temps
+// temps file
+// Message-Id: <9212181914.AA05066@sparc1.cnm.us.es>
+// From: juando@cnm.us.es (Juan Domingo Martin Gomez)
+// Subject: Temporaries destroyed too soon
+// Date: Fri, 18 Dec 92 20:14:45 +0100
+
+#include <stdio.h>
+
+int status = 0;
+int fail = 0;
+
+class Foo
+{
+public:
+    Foo();
+    ~Foo();
+
+    Foo &method();
+};
+
+Foo f1()
+{
+    return Foo();
+}
+
+Foo::Foo()
+{
+}
+
+Foo::~Foo()
+{
+    if (status == 2)
+      fail = 0;
+    else
+      fail = 1;
+}
+
+Foo &Foo::method()
+{
+    status++;
+    return *this;
+}
+
+int main()
+{
+    // f1() returns a temporary object. The member function
+    // method() returns a reference to the same object.
+    f1().method().method();
+    if (fail)
+      printf ("FAIL\n");
+    else
+      printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/temps3.C b/gcc/testsuite/g++.old-deja/g++.law/temps3.C
new file mode 100644
index 00000000000..48e449813b4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/temps3.C
@@ -0,0 +1,28 @@
+// GROUPS passed temps
+// temps file
+// Message-Id: <9308231535.AA19432@geant.cenatls.cena.dgac.fr>
+// From: chatty@geant.cenatls.cena.dgac.fr (Stephane CHATTY)
+// Subject: g++ 2.4.5 does not destroy temporaries
+// Date: Mon, 23 Aug 93 17:35:34 +0200
+
+#include <stdio.h>
+
+class A {
+public:
+        int a;
+        A (int i) : a (i) { ;}
+        A (const A& aa) : a (aa.a) { ;}
+        ~A () { printf ("PASS\n");; }
+};
+
+A
+foo ()
+{
+        return A (10);
+}
+
+int main ()
+{
+        int x = foo ().a;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/temps4.C b/gcc/testsuite/g++.old-deja/g++.law/temps4.C
new file mode 100644
index 00000000000..2abf56d8214
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/temps4.C
@@ -0,0 +1,38 @@
+// Special g++ Options: -felide-constructors
+// GROUPS passed temps
+// temps file
+// Message-Id: <9311102043.AA22871@ses.com>
+// From: jamshid@ses.com (Jamshid Afshar)
+// Subject: elide-constructors (aka return value optimization)
+// Date: Wed, 10 Nov 93 14:43:54 CST
+
+#include <stdio.h>
+
+class X {
+    int i;
+  public:
+    X();
+    X(const X&);
+    X(int);
+    ~X();
+};
+
+int did_it = 0;
+
+X::X() { ; }
+X::X(const X&) { did_it = 1; }
+X::X(int) { ; }
+X::~X() { ; }
+
+X foo() {
+    X x(1);
+    return x;
+}
+
+main() {
+    X x = foo();
+    if (did_it)
+	printf ("FAIL\n");
+    else
+	printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/temps5.C b/gcc/testsuite/g++.old-deja/g++.law/temps5.C
new file mode 100644
index 00000000000..7c591a409e9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/temps5.C
@@ -0,0 +1,41 @@
+// GROUPS passed temps
+// temps file
+// Message-Id: <9311171029.AA00592@mencon>
+// From: gfm@mencon.mencon.oz.au (Graham Menhennitt)
+// Subject: gcc 2.5.3 - bug deleting object that is still referred to
+// Date: Wed, 17 Nov 93 21:29:23 EST
+
+#include        <stdio.h>
+
+class C {
+public:
+        C(int i) : val(i) { ; }
+        C(const C& c) : val(c.val) { ; }
+        ~C(void) { val = 999; }
+        C& operator = (const C& c) { val = c.val; return *this; }
+
+        C& inc(int i) { val += i; return *this; }
+
+        int val;
+};
+
+C
+f(void)
+{
+        return C(3);
+}
+
+C
+f(int i)
+{
+        return f().inc(i);
+}
+
+int
+main(void)
+{
+	if (f (2).val != 5)
+		printf ("FAIL\n");
+	else
+		printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/temps6.C b/gcc/testsuite/g++.old-deja/g++.law/temps6.C
new file mode 100644
index 00000000000..7d2952a0c83
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/temps6.C
@@ -0,0 +1,24 @@
+// GROUPS passed temps
+// Date: Tue, 22 Mar 94 12:46:28 +0100
+// From: dak@pool.informatik.rwth-aachen.de
+// Message-Id: <9403221146.AA07815@messua>
+// Subject: Bad code for pointer to member use as reference in g++ 2.5.8
+
+#include <stdio.h>
+struct str {
+  int i;
+} xxx = {0};
+
+int& test(str *arg1, int str::*arg2)
+{
+  return (arg1->*arg2);
+}
+
+int main()
+{
+  test(&xxx, &str::i) = 5;
+  if (xxx.i == 0)
+    printf ("FAIL\n");
+  else
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/temps7.C b/gcc/testsuite/g++.old-deja/g++.law/temps7.C
new file mode 100644
index 00000000000..ddf028e31fa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/temps7.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed temps
+
+template <class B >
+class A {
+public:
+  class C {};
+};
+
+template class A<int>::C;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/typeck1.C b/gcc/testsuite/g++.old-deja/g++.law/typeck1.C
new file mode 100644
index 00000000000..f0ee7734962
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/typeck1.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed typeck
+// typeck file
+// From: vern@daffy.ee.lbl.gov (Vern Paxson)
+// Date:     24 Sep 1992 23:11:22 GMT
+// Subject:  2.2.2 type-checking error (?) when comparing pointers
+// Message-ID: <26475@dog.ee.lbl.gov>
+
+
+        class a { };
+        class foo : a { };
+        class bar : a { };
+
+        int test( const foo* f, const bar* b )
+                {
+                return f == b;// ERROR - 
+                }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/typeck2.C b/gcc/testsuite/g++.old-deja/g++.law/typeck2.C
new file mode 100644
index 00000000000..24f3cb19fad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/typeck2.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed typeck
+// typeck file
+// From: Jutta Degener <jutta@cs.tu-berlin.de>
+// Date:     Wed, 9 Jun 1993 17:58:35 +0200 (MET DST)
+// Subject:  2.4.3: Type of new <typedef'ed array>
+// Message-ID: <199306091558.AA19075@mail.cs.tu-berlin.de>
+
+  typedef int arr[10];
+int main()
+  {
+        int * p = new int[10];
+        int * q = new arr;              /* g++ complains, but shouldn't     */
+        int (* r)[10] = new arr;        /* g++ doesn't complain, but should */// ERROR - 
+  }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/typeck3.C b/gcc/testsuite/g++.old-deja/g++.law/typeck3.C
new file mode 100644
index 00000000000..76c36843fd6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/typeck3.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed typeck
+// typeck file
+// From: Dror Caspi <dror@fibronics.co.il>
+// Date:     Wed, 9 Jun 1993 17:43:48 +0300
+// Subject:  function typedefs in classes
+// Message-ID: <199306091443.AA03735@zorba.fibronics.co.il>
+
+class a
+{
+ public:
+   typedef void (X)();
+
+   X x;   // Member function of type X
+};
+
+class b
+{
+ public:
+   typedef void (X)();   //!!!!!! g++ says : syntax error before `;'
+
+   X x;   // Member function of type X
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/typeck4.C b/gcc/testsuite/g++.old-deja/g++.law/typeck4.C
new file mode 100644
index 00000000000..9b510c05725
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/typeck4.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed typeck
+class A {
+  public:
+    const int &operator[]( int i );
+  private:
+    int k;
+};
+
+const int& A::operator[]( int i )
+{
+    return k;
+}
+
+
+void ff( A &anA )
+{
+    int &ani = anA[0];// ERROR - 
+
+    ani = 7;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/union1.C b/gcc/testsuite/g++.old-deja/g++.law/union1.C
new file mode 100644
index 00000000000..ce7c3d7442c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/union1.C
@@ -0,0 +1,29 @@
+// Build don't link: 
+// GROUPS passed unions
+// anon-union file
+// From: "Terry R. Coley" <terry@wag.caltech.edu>
+// Date:     Tue, 25 Aug 1992 17:33:29 -0700
+// Subject:  possible bug in gcc/g++
+// Message-ID: <199208260033.AA19417@brahms.wag.caltech.edu>
+
+typedef enum { BADBINOP = 0, PLUS, MINUS, MULT, DIV, POWR } binoptype;
+typedef enum { BADUNOP = 0, NEG = POWR+1, SIN, COS, TAN } unoptype;
+
+typedef struct {
+  char *s;
+  union {
+    binoptype bop;
+    unoptype uop;
+  };
+}
+op_to_charp;
+
+op_to_charp BINOPS[] = { {"+", PLUS},
+                         {"-", MINUS},
+                         {"*", MULT},
+                         {"/", DIV},
+                         {"^", POWR} };
+
+int main() {
+  int dummy;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/union2.C b/gcc/testsuite/g++.old-deja/g++.law/union2.C
new file mode 100644
index 00000000000..66c2c665cab
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/union2.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed unions
+// anon-union file
+// From: gerlek@dat.cse.ogi.edu (Michael Gerlek)
+// Date:     Tue, 8 Dec 92 12:56 PST
+// Subject:  private anonymous unions have public members? (gcc-2.3.1)
+// Message-ID: <m0mzByL-0000hoC@dat.cse.ogi.edu>
+
+class A {
+public:
+  int x;
+private:
+  int y;    // ERROR - private
+  union {
+    int z;  // ERROR - private
+  };
+};
+
+void f() {
+  A a;
+
+  a.x = 0;
+  a.y = 1;// ERROR - .*
+  a.z = 2;// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/union3.C b/gcc/testsuite/g++.old-deja/g++.law/union3.C
new file mode 100644
index 00000000000..62e894727df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/union3.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed unions
+// anon-union file
+// From: dcb@us-es.sel.de (David Binderman 3841)
+// Date:     Tue, 30 Mar 93 09:06:15 +0200
+// Subject:  Page 183 of the ARM
+// Message-ID: <9303300706.AA17079@slsvitt>
+
+static union {
+        char*   uC;
+private:
+        int     uI;// ERROR - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/union4.C b/gcc/testsuite/g++.old-deja/g++.law/union4.C
new file mode 100644
index 00000000000..2178697f8ec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/union4.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// GROUPS passed unions
+// anon-union file
+// From: hossein@veritas.com (Hossein Raassi)
+// Date:     Wed, 15 Dec 93 13:52 PST
+// Subject:  Internal Error
+// Message-ID: <m0pA49A-0000LdC@piano.veritas.com>
+
+static union {
+        struct SS {
+                int ss;
+        };
+};// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.law/unsorted1.C b/gcc/testsuite/g++.old-deja/g++.law/unsorted1.C
new file mode 100644
index 00000000000..eae69e8e94e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/unsorted1.C
@@ -0,0 +1,31 @@
+// Build don't link: 
+// Special g++ Options: -O
+// GROUPS passed unsorted
+// unsorted.2 file
+// From: skipnyc!skipsun!skip@fsg.com (Skip Gilbrech)
+// Date:     Wed, 10 Jun 92 6:55:18 EDT
+// Subject:  Problem with derived class access adjustment and -O
+// Message-ID: <9206101055.AA20593@skipsun.UUCP>
+
+
+class A {
+  public:
+    virtual void func() = 0;
+};
+
+class B : public A {
+  public:
+    void func() {}
+};
+
+class C : private B {
+  public:
+    B::func;
+};
+
+class D {
+    C c;
+  public:
+    void func() { c.func(); }
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/unsorted2.C b/gcc/testsuite/g++.old-deja/g++.law/unsorted2.C
new file mode 100644
index 00000000000..b3c13a456b0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/unsorted2.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+// GROUPS passed unsorted
+// code-gen file
+// From: klaus@steinitz.mathematik.uni-dortmund.de
+// Date:     Mon, 15 Nov 1993 16:51:11 +0100
+// Message-ID: <9311151551.AA17761@steinitz.mathematik.uni-dortmund.de>
+
+template <int A,int B>
+class X
+{
+};
+
+template <int A,int B,int C>
+X<A,C> f(X<A,B>,X<B,C>)
+{
+  X<A,C> result;
+  return result;
+}
+
+int main()
+{
+  X<1,3> x;
+  X<1,2> y;
+  X<2,3> z;
+  x=f(y,z);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/vbase1.C b/gcc/testsuite/g++.old-deja/g++.law/vbase1.C
new file mode 100644
index 00000000000..42282d57df8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/vbase1.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// GROUPS passed vbase
+// vbase file
+// From: pino@hubble.eecs.berkeley.edu (Jose Luis Pino)
+// Date:     28 Jul 1994 05:17:39 GMT
+// Subject:  g++ 2.6 bug: virtual base class & protected methods
+// Message-ID: <317f1j$o9c@agate.berkeley.edu>
+
+
+#include <iostream.h>
+
+class a {
+protected:
+	virtual void foo() { cout << "Class A\n";}
+};
+
+class b : public virtual a {};
+
+class c : public b {
+public:
+	void bar() { b::foo();}
+};
+
+int main() {
+	c test;
+	test.bar();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/virtual1.C b/gcc/testsuite/g++.old-deja/g++.law/virtual1.C
new file mode 100644
index 00000000000..8192273f0a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/virtual1.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// Special g++ Options: -Woverloaded-virtual
+// GROUPS passed virtual-warnings
+// copy file
+// From: gfm@mencon.mencon.oz.au (Graham Menhennitt)
+// Date:     Thu, 29 Apr 93 20:53:07 EST
+// Subject:  4 bugs in g++ 2.3.3
+// Message-ID: <9304291053.AA00090@mencon>
+
+        struct A {
+                virtual ~A(void);
+        };
+
+        struct B {
+                friend class A;
+                virtual void f(void);
+        };
+
+        struct C : public A {
+                virtual void f(void);
+        };
diff --git a/gcc/testsuite/g++.old-deja/g++.law/virtual2.C b/gcc/testsuite/g++.old-deja/g++.law/virtual2.C
new file mode 100644
index 00000000000..fa9bb69a4a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/virtual2.C
@@ -0,0 +1,31 @@
+// GROUPS passed virtual-functions
+// Not in g++ bugs snapshot
+// From: grande@isi.edu (Jim Grande)
+// Subject: g++ 2.3.3 (HPPA) virt class definition dumps core
+// Date: 5 Mar 1993 22:51:14 -0500
+// Message-ID: <23611@venera.isi.edu>
+
+#include <stdio.h>
+
+class doubleclass
+{
+	public:
+		double	d;
+		doubleclass(double x = 0)	{ d = x; };
+};
+
+class test
+{
+	doubleclass doublec;
+};
+
+class vderived : virtual public test
+{
+};
+
+int main()
+{
+	vderived v;
+
+	printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/virtual3.C b/gcc/testsuite/g++.old-deja/g++.law/virtual3.C
new file mode 100644
index 00000000000..d131da4696d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/virtual3.C
@@ -0,0 +1,47 @@
+// GROUPS passed virtual-functions
+// virtual file
+// From: allan@ramjet.multinet.DE (Allan Brighton)
+// Subject: pos. bug in gcc-2.5.2 on hp
+// Date: 4 Nov 1993 22:57:36 -0500
+// Message-ID: <9311041820.AA05942@ramjet.multinet.DE>
+
+#include <iostream.h>
+#include <strstream.h>
+
+
+class BugStream : public ostrstream {
+public:
+    BugStream() {}
+    BugStream& eval();
+};
+
+
+static struct Eval_ { } eval;
+BugStream& operator<<(ostream& os, Eval_);
+
+BugStream& BugStream::eval()
+{
+   // make sure str is null terminated
+   *this << ends;
+   
+   // eval the command and set the status
+   char* s = str();
+   cerr << s << endl;
+   
+   // reset the stream for the next command    
+   clear(0);
+   rdbuf()->freeze(0);
+   seekp(0);
+   
+   return *this;
+}
+
+BugStream& operator<<(ostream& os, Eval_)
+{
+    return ((BugStream&)os).eval();
+}
+
+int main() {
+    BugStream bs;
+    bs << "PASS" << eval;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/virtual4.C b/gcc/testsuite/g++.old-deja/g++.law/virtual4.C
new file mode 100644
index 00000000000..47af3aa9de9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/virtual4.C
@@ -0,0 +1,31 @@
+// GROUPS passed virtual-functions
+#include <stdio.h>
+#include <stdlib.h>
+
+int aset = 0;
+class A
+{
+  public:
+    void Set() { SetProp(); }
+    virtual void SetProp() { aset++;}
+};
+
+class B:public A
+{
+  public:
+    void SetProp() { if (!aset) { printf ("FAIL\n"); exit (0);} aset--;}
+};
+
+int main()
+{
+    A a;
+    B b;
+    A *c=new A;
+    A *d=new B;
+
+    a.Set();
+    b.Set();
+    c->Set();
+    d->Set();
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility1.C b/gcc/testsuite/g++.old-deja/g++.law/visibility1.C
new file mode 100644
index 00000000000..67f4bcd9919
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility1.C
@@ -0,0 +1,68 @@
+// Build don't link: 
+// GROUPS passed visibility
+#include <iostream.h>
+
+
+
+class base {
+//==========
+
+    void base_priv(char * n) 		
+	{ cout << "base_priv called from: " << n << "\n";  };
+
+protected:
+
+    void base_prot(char * n) 
+	{ cout << "base_prot called from: " << n << "\n"; };
+
+public:
+
+    void base_publ(char * n) 
+	{ cout << "base_publ called from: " << n << "\n"; };
+
+    void test(char * n) { base_publ(n); base_prot(n); base_priv(n); }
+
+}; // class base
+ 
+
+
+class derived : private base {	// Make this public, 
+//============================	// and we don't get an error
+
+friend void derived_friend();
+
+public :
+
+    void test(char * n) { base_publ(n); base_prot(n);}
+
+}; // class derived
+
+
+
+void
+derived_friend()
+//--------------
+{
+    derived pd;
+
+    pd.base_publ("friend of derived class");	// Compiler error here
+    pd.base_prot("friend of derived class");
+}
+
+
+
+int main(int argc, char *argv[])
+//==========================
+{
+    base b;
+    b.base_publ("base class object");
+    b.test("member of base class object");
+    cout << "\n";
+
+    derived pd;
+    pd.test("member of derived class object");
+    derived_friend();
+    cout << "\n";
+
+} /* main */
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility10.C b/gcc/testsuite/g++.old-deja/g++.law/visibility10.C
new file mode 100644
index 00000000000..14dfa333dea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility10.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed visibility
+
+#include <iostream.h>
+
+class base {
+public:
+  void f1 () { cout << "f1" << endl; };
+  void f2 () { cout << "f2" << endl; };
+};
+
+class deriv : public base {
+  void base :: f1();// ERROR - .*
+};
+
+int main ()
+{
+  deriv d;
+
+  d.f2();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility11.C b/gcc/testsuite/g++.old-deja/g++.law/visibility11.C
new file mode 100644
index 00000000000..eeda777e116
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility11.C
@@ -0,0 +1,52 @@
+// Build don't link: 
+// Special g++ Options: -w
+// GROUPS passed visibility
+// visibility file
+// From: Alan Shepherd <a.shepherd@nexor.co.uk>
+// Date:     Tue, 22 Jun 1993 14:53:23 +0100
+// Subject:  bug with MI in gcc-2.4.5
+// Message-ID: <9659.740757203@nexor.co.uk>
+
+class A
+{
+    int a;
+
+protected:
+
+    virtual void State(int b)   { a = b; }
+
+};
+
+class B : public A
+{
+    char* foo;
+
+public:
+
+    B(const char*);
+};
+
+class C : public A
+{
+    char* foo2;
+
+public:
+
+    C(const char*);
+};
+
+class D : public B, public C
+{
+public:
+  D();
+protected:
+
+    virtual void State(int a)
+    {
+        B::State(a);
+        C::State(a);
+    }
+};
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility12.C b/gcc/testsuite/g++.old-deja/g++.law/visibility12.C
new file mode 100644
index 00000000000..3aa6d6b26b8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility12.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: Mark Rawling <Mark.Rawling@mel.dit.csiro.au>
+// Date:     Wed, 30 Jun 93 15:28:34 +1000
+// Subject:  member access rule bug
+// Message-ID: <9306300528.AA17185@coda.mel.dit.CSIRO.AU>
+struct a {
+  int aa; // ERROR - private
+        };
+
+class b : private a {
+        };
+
+class c : public b {
+        int xx(void) { return (aa); }  // aa should be invisible// ERROR - .*
+        };
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility13.C b/gcc/testsuite/g++.old-deja/g++.law/visibility13.C
new file mode 100644
index 00000000000..7f634e20cd8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility13.C
@@ -0,0 +1,108 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: dinh@cs.ucla.edu (Dinh Le)
+// Date:     Mon, 12 Jul 93 22:21:06 -0700
+// Subject:  class, template and their scoping problem
+// Message-ID: <9307130521.AA18312@oahu.cs.ucla.edu>
+
+#include <iostream.h>
+#include <assert.h>
+
+//     ---------------   Array.h  &&  Array.cc   ------------------
+
+const int ArraySize = 12;
+
+template <class Type>
+class Array { // ERROR - .struct Array_RC redecl.*
+friend class Array_RC;
+public:
+    Array(const Type *ar, int sz) { init(ar,sz); }
+    virtual ~Array() { delete [] ia; }
+    virtual void print(ostream& = cout);
+    virtual Type& operator[](int ix) { return ia[ix]; }
+private:
+    void init(const Type*, int);
+    int size; // ERROR - private
+    int *ia; // ERROR - private
+};
+
+template <class Type>
+ostream& operator<<( ostream& os, Array<Type>& ar )
+{
+    ar.print(os);
+    return os;
+}
+
+template <class Type>
+void Array<Type>::print(ostream& os)
+{
+    const int lineLength = 12;
+
+    os << "( " << size << " )< ";
+    for (int ix = 0; ix < size; ++ix) {
+        if (ix % lineLength == 0 && ix) os << "\n\t";
+        os << ia[ ix ];
+
+        if (ix % lineLength != lineLength-1 &&
+            ix != size-1)
+            os << ", ";
+    }
+    os << " >\n";
+}
+
+template <class Type>
+void Array<Type>::init(const Type *array, int sz)
+{
+    ia = new Type[size = sz];
+
+    for (int ix = 0; ix < size; ++ix)
+        ia[ix] = (array!=0) ? array[ix] : (Type)0;
+}
+
+//     ---------------   Array_RC.h  &&  Array_RC.cc   ----------------
+
+template <class Type>
+class Array_RC : public Array<Type> {// ERROR - previous declaration.*
+public:
+    Array_RC(const Type *ar, int sz);
+    Type& operator[](int ix);
+};
+
+template <class Type>
+Array_RC<Type>::Array_RC(const Type *ar, int sz) : Array<Type>(ar, sz) {}
+
+template <class Type>
+Type &Array_RC<Type>::operator[](int ix) {
+    assert(ix >= 0 && ix < size);// ERROR - member .size.*
+    return ia[ix];// ERROR - member .ia.*
+}
+
+//    -------------------   Test routine   ----------------------
+
+template <class Type>
+void try_array( Array<Type> &iA )
+{
+    cout << "try_array: initial array values:\n";
+    cout << iA << endl;
+}
+
+template <class Type>
+inline void
+try_array( Array_RC<Type> &rc )
+{
+    try_array( ((Array<Type>&)rc) );
+}
+
+int main()
+{
+    static int ia[10] = { 12, 7, 14, 9, 128, 17, 6, 3, 27, 5 };
+    Array_RC<int> iA(ia, 10);// ERROR - instantiated from here
+
+    cout << "template Array_RC class" << endl;
+    try_array(iA);
+
+    return 0;
+}
+
+template class Array_RC<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility14.C b/gcc/testsuite/g++.old-deja/g++.law/visibility14.C
new file mode 100644
index 00000000000..7f2251bdf4b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility14.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: ajp@eng.cam.ac.uk
+// Date:     Tue, 13 Jul 93 17:15:11 BST
+// Message-ID: <1171.9307131615@ace.eng.cam.ac.uk
+
+class A {
+    static A* list;
+
+  protected:
+    struct AA {
+        AA();
+        ~AA();
+    };
+};
+
+A::AA::~AA()
+{
+    A* d=list;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility15.C b/gcc/testsuite/g++.old-deja/g++.law/visibility15.C
new file mode 100644
index 00000000000..33fdb176e4a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility15.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: wpsun4!xinforms!johnjo@uunet.uu.net (John D. Johnson)
+// Date:     Wed, 4 Aug 93 13:25:25 MDT
+// Subject:  Access to private 'operator new()'
+// Message-ID: <9308041925.AA09825@xinforms.wpunix
+#include <stdio.h>
+#include <sys/types.h>
+
+class X {
+private:
+  void* operator new(size_t) throw(){// ERROR - .*
+    printf("Inside private new().\n");
+    return NULL;
+  }
+public:
+  X() {}
+};
+
+
+int main(void)
+{
+  X* p = new X;// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility16.C b/gcc/testsuite/g++.old-deja/g++.law/visibility16.C
new file mode 100644
index 00000000000..5291d7c8961
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility16.C
@@ -0,0 +1,35 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: Marie Trapp <Marie.Trapp@analog.com>
+// Date:     Thu, 5 Aug 93 11:55:15 EDT
+// Subject:  access of protected members
+// Message-ID: <9308051553.AA07639@nwd2sun1.analog.com>
+class A {
+  protected:
+    int astuff; // ERROR - protected
+    A() {
+        astuff = 3; 
+    }
+};
+
+class B : public A {
+    int bstuff;
+  public:
+    B( A *p) {
+        bstuff = p->astuff;// ERROR - .*
+    }
+};
+
+class C : public A {
+    int cstuff;
+  public:
+    C() {
+        cstuff = 5;
+    }
+};
+
+int main() {
+    C cvar;
+    B bvar(&cvar);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility17.C b/gcc/testsuite/g++.old-deja/g++.law/visibility17.C
new file mode 100644
index 00000000000..125bf00f067
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility17.C
@@ -0,0 +1,63 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: Sandeep Shroff <ss@caere.com>
+// Date:     Thu, 05 Aug 1993 17:23:20 -0700
+// Subject:  Access to private constructor.
+// Message-ID: <9308060023.AA10283@neptune.caere.com>
+#include <iostream.h>
+
+class Base
+{
+public:
+  char* getName() {return name_;}
+
+private:
+  Base();
+  Base(char* str);
+
+  char* name_;
+};
+
+class Derived : public Base
+{
+public:
+  Derived(int n, char* str);
+  Derived(int n);
+
+  int getNum() {return num_;}
+private:
+  int num_;
+};
+
+Base::Base()
+{ // ERROR - private
+  name_ = strcpy(new char[strlen(" ") + 1], " ");
+}
+
+Base::Base(char* str)
+{ // ERROR - private
+  if(str != NULL)
+    name_ = strcpy(new char[strlen(str) + 1], str);
+}
+
+Derived::Derived(int n, char* str) : Base(str)
+{// ERROR - .*
+  num_ = n;
+}
+
+Derived::Derived(int n) : Base()
+{// ERROR - .*
+  num_ = n;
+}
+
+
+
+int main()
+{
+  // Derived* d = new Derived(10, "test");
+  Derived* d = new Derived(10);
+
+  cerr << d->getNum() << "\t" << d->getName() << endl;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility18.C b/gcc/testsuite/g++.old-deja/g++.law/visibility18.C
new file mode 100644
index 00000000000..a1ec468f521
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility18.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: cmwang@iis.sinica.edu.tw (Chien-Min Wang)
+// Date:     Fri, 6 Aug 93 19:42:31 CST
+// Subject:  A bug in g++ 2.4.5
+// Message-ID: <9308061142.AA08533@iiserv>
+struct T1 { int i; };
+
+struct T2 { int j; }; // ERROR - private
+
+struct T3 : public T1, private T2 {
+} x;
+
+int main ()
+{
+    x.i = 1;
+    x.j = 2;    // error: x.j is private// ERROR - .*
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility19.C b/gcc/testsuite/g++.old-deja/g++.law/visibility19.C
new file mode 100644
index 00000000000..82a1dc5b79b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility19.C
@@ -0,0 +1,40 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: mclaugh@tnt.acsys.com (Mark A. McLaughlin)
+// Date:     Wed, 25 Aug 93 14:30:47 MDT
+// Subject:  g++ bug
+// Message-ID: <9308252030.AA02352@tnt.acsys.com>
+class B {
+protected:
+    int i; // ERROR - protected
+};
+
+class D1 : public B {
+};
+
+class D2 : public B {
+    friend void fr(B*,D1*,D2*);
+    void mem(B*,D1*);
+};
+
+void fr(B* pb, D1* p1, D2* p2)
+{
+    pb->i = 1;  // illegal// ERROR - .*
+    p1->i = 2;  // illegal// ERROR - .*
+    p2->i = 3;  // ok (access through D2)
+}
+
+void D2::mem(B* pb, D1* p1)
+{
+    pb->i = 1;  // illegal// ERROR - .*
+    p1->i = 2;  // illegal// ERROR - .*
+    i = 3;      // ok (access through `this')
+}
+
+void g(B* pb, D1* p1, D2* p2)
+{
+    pb->i = 1;  // illegal// ERROR - .*
+    p1->i = 2;  // illegal// ERROR - .*
+    p2->i = 3;  // illegal// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility2.C b/gcc/testsuite/g++.old-deja/g++.law/visibility2.C
new file mode 100644
index 00000000000..5806fc564b7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility2.C
@@ -0,0 +1,68 @@
+// Build don't link: 
+// GROUPS passed visibility
+#include <iostream.h>
+
+
+
+class base {
+//==========
+
+    void base_priv(char * n) 		
+	{ cout << "base_priv called from: " << n << "\n";  };
+
+protected:
+
+    void base_prot(char * n) 
+	{ cout << "base_prot called from: " << n << "\n"; };
+
+public:
+
+    void base_publ(char * n) 
+	{ cout << "base_publ called from: " << n << "\n"; };
+
+    void test(char * n) { base_publ(n); base_prot(n); base_priv(n); }
+
+}; // class base
+ 
+
+
+class derived : public base {	// Make this public, 
+//============================	// and we don't get an error
+
+friend void derived_friend();
+
+public :
+
+    void test(char * n) { base_publ(n); base_prot(n);}
+
+}; // class derived
+
+
+
+void
+derived_friend()
+//--------------
+{
+    derived pd;
+
+    pd.base_publ("friend of derived class");	// Compiler error here
+    pd.base_prot("friend of derived class");
+}
+
+
+
+int main(int argc, char *argv[])
+//==========================
+{
+    base b;
+    b.base_publ("base class object");
+    b.test("member of base class object");
+    cout << "\n";
+
+    derived pd;
+    pd.test("member of derived class object");
+    derived_friend();
+    cout << "\n";
+
+} /* main */
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility20.C b/gcc/testsuite/g++.old-deja/g++.law/visibility20.C
new file mode 100644
index 00000000000..82ecaee4d34
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility20.C
@@ -0,0 +1,36 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: doug@foxtrot.ccmrc.ucsb.edu (Douglas Scott)
+// Date:     Tue, 10 Aug 93 10:06:33 PDT
+// Subject:  G++ 2.4.5 allows access to protected base members
+// Message-ID: <9308101706.AA04485@foxtrot.ccmrc.ucsb.edu>
+
+class Base {
+protected:
+      void protectedBaseFunction() {} // ERROR - protected
+public:
+    Base() {}
+};
+
+
+class Derived : public Base {
+public:
+    Derived() {}
+    void noticeThisFunction(Base *);
+};
+
+
+void
+Derived::noticeThisFunction(Base *b) {
+    b->protectedBaseFunction(); // ARM says this is not allowed// ERROR - .*
+                                // since it is not called on 'this'
+}
+
+int main() {
+    Base b;
+    Derived d;
+    d.noticeThisFunction(&b);
+    printf("gpptest run\n");// ERROR - .*
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility21.C b/gcc/testsuite/g++.old-deja/g++.law/visibility21.C
new file mode 100644
index 00000000000..845854029bf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility21.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: klamer@mi.el.utwente.nl (Klamer Schutte)
+// Date:     Thu, 12 Aug 93 12:03:09 +0200
+// Subject:  g++ 2.4.5 failed to report a bug
+// Message-ID: <9308121003.AA02294@mi.el.utwente.nl>
+class A {
+protected:
+      void foo(); // ERROR - protected
+};
+
+class B : public A
+{
+        void bar(A &a)
+                {       a.foo(); }// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility22.C b/gcc/testsuite/g++.old-deja/g++.law/visibility22.C
new file mode 100644
index 00000000000..a9448c07fee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility22.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: Robert Carden <carden@thoth.ics.uci.edu>
+// Date:     Thu, 12 Aug 1993 13:48:05 -0700
+// Subject:  bug 8/12/93 -- #5
+// Message-ID: <9308121348.aa26256@Paris.ics.uci.edu>
+
+// 5.cc
+#include <stream.h>
+
+class A {
+        int x;
+public:
+        void f(int);
+        void f(float);
+        void g(void *);
+};
+
+class B : private A {
+protected:
+        A::f;
+public:
+        A::g;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility24.C b/gcc/testsuite/g++.old-deja/g++.law/visibility24.C
new file mode 100644
index 00000000000..dab2148cc64
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility24.C
@@ -0,0 +1,40 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: joe@consolve.com (Joe Shapiro)
+// Date:     Fri, 20 Aug 93 17:18:18 EDT
+// Subject:  Template classes seem to allow users to get at private members
+// Message-ID: <9308202118.AA25599@ghana.consolve>
+/*
+ * private.cc
+ */
+extern "C" void printf(...);
+
+template <class T>
+class A
+{
+public:
+      void Fun() { printf( "Fun fun fun!\n" ); } // ERROR - private
+};
+
+
+template <class T>
+class B: private A<T>
+{
+};
+
+
+class C
+{
+public:
+    C() { _b.Fun(); }// ERROR - .*
+
+private:
+    B<int> _b;
+};
+
+
+int main()
+{
+    C c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility25.C b/gcc/testsuite/g++.old-deja/g++.law/visibility25.C
new file mode 100644
index 00000000000..76ca8d8b402
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility25.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: gfm@mencon.mencon.oz.au (Graham Menhennitt)
+// Date:     Wed, 17 Nov 93 21:30:32 EST
+// Subject:  gcc 2.5.3 - can't privately inherit and contain same class
+// Message-ID: <9311171030.AA00604@mencon>
+#include        <iostream.h>
+
+class A {
+public:
+        A(void);
+};
+
+class B : private A {
+public:
+        B(void) : A() {}
+};
+
+class C : public B {
+public:
+        C(void) : B(), a() {}
+
+private:
+        A a;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility26.C b/gcc/testsuite/g++.old-deja/g++.law/visibility26.C
new file mode 100644
index 00000000000..54fc43e2053
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility26.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: jamshid@ses.com (Jamshid Afshar)
+// Date:     Sun, 12 Dec 93 03:09:15 CST
+// Subject:  Missed access declaration error
+// Message-ID: <9312120909.AA22135@ses.com>
+
+class X {
+  public:
+    void f();
+};
+
+class Y : private X {
+  public:
+    void f(int);// ERROR -    because.*
+    X::f;  // g++ 2.5.5 doesn't flag this misuse
+};// ERROR -  cannot adjust.*
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility27.C b/gcc/testsuite/g++.old-deja/g++.law/visibility27.C
new file mode 100644
index 00000000000..4092624f712
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility27.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: jbuck@synopsys.com (Joe Buck)
+// Date:     3 Aug 1994 01:52:04 GMT
+// Subject:  2.6.0 bug with protected members and virtual baseclasses
+// Message-ID: <31mt84$lfq@hermes.synopsys.com>
+
+struct R {
+protected:
+        virtual void foo();
+};
+
+struct A : public R {
+};
+
+struct B : virtual public A {
+        void bletch() { foo();}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility28.C b/gcc/testsuite/g++.old-deja/g++.law/visibility28.C
new file mode 100644
index 00000000000..e92c299960f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility28.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+// GROUPS passed visibility
+extern "C" int printf( const char *, ...);
+
+class B {
+public:
+        B() { };
+        virtual ~B() { printf( "B::~B\n"); };
+};
+
+class D : public B {
+public:
+        virtual ~D() { printf( "D::~D\n"); };
+  void operator = ( int i) { this->~B(); }// ERROR - D has no ~B part to it
+};
+
+int
+main()
+{
+        D * pd = new D;
+        B * pb = pd;
+        delete pb;
+        return 0;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility3.C b/gcc/testsuite/g++.old-deja/g++.law/visibility3.C
new file mode 100644
index 00000000000..1e02a4bd9e5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility3.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: kol@world.std.com (Nikolay Yatsenko)
+// Date:     Wed, 27 Jan 1993 16:39:00 -0500
+// Subject:  g++ bug
+// Message-ID: <199301272139.AA25442@world.std.com>
+
+int x;
+
+int main(void)
+{
+  static int s;
+  int x; // ERROR - declared
+  extern int g();
+
+  struct local {
+    int g() { return x; }   // illegal (non-static x); g++ does not give error// ERROR - 
+    int h() { return s; }   // ok, but g++ give error
+  };
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility4.C b/gcc/testsuite/g++.old-deja/g++.law/visibility4.C
new file mode 100644
index 00000000000..2d7079eed2b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility4.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: dcb@us-es.sel.de (David Binderman 3841)
+// Date:     Tue, 30 Mar 93 15:48:47 +0200
+// Subject:  page 242 of the ARM
+// Message-ID: <9303301348.AA20751@slsvitt>
+
+class A {
+public:
+     int b; // ERROR - private
+};
+
+class C : private A {                   // NOTE WELL. private, not public
+public:
+        int d;
+};
+
+extern "C" int printf( const char *, ...);
+
+class E : public C {
+        void f() {
+                printf( "%d\n", b);// ERROR - .*
+        };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility5.C b/gcc/testsuite/g++.old-deja/g++.law/visibility5.C
new file mode 100644
index 00000000000..a68e360026d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility5.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+// GROUPS passed visibility
+
+class a {
+
+private:
+  a (int i);// ERROR - .*
+
+public:
+  a ();
+};
+
+void test ()
+{
+  a *ap = new a;
+  a *ap2 = new a (3);// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility6.C b/gcc/testsuite/g++.old-deja/g++.law/visibility6.C
new file mode 100644
index 00000000000..7e8b7c744f8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility6.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: Rob Hasker <hasker@sparc0a.cs.uiuc.edu>
+// Date:     Sat, 3 Apr 1993 13:19:05 -0600
+// Subject:  no privacy
+// Message-ID: <199304031919.AA20554@sparc17.cs.uiuc.edu
+class Top {
+public:
+    Top() {}
+      void val() {} // ERROR - private base class
+};
+
+class Derived : private Top {
+public:
+    Derived() {}
+};
+
+class Unrelated {
+    Derived derived;
+public:
+    void oops() { derived.val(); }// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility7.C b/gcc/testsuite/g++.old-deja/g++.law/visibility7.C
new file mode 100644
index 00000000000..764da35d9db
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility7.C
@@ -0,0 +1,71 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: Gordon Joly <G.Joly@cs.ucl.ac.uk>
+// Date:     Wed, 21 Apr 93 09:42:07 +0100
+// Subject:  /*** BUG REPORT : THE MYTH OF PRIVATE INHERITANCE ***/
+// Message-ID: <9304210842.AA01815@life.ai.mit.edu>
+#include <iostream.h>
+
+class A {
+ private:
+  int number;
+ public:
+  A(int i) : number(i)
+    {}
+  virtual ~A()
+    {}
+  virtual void Number(int c)
+    { number = c; } // ERROR - private
+  virtual int Number()
+    { return number; } // ERROR - private
+};
+
+class B : private A {
+ private:
+  int second_number;
+ public:
+  B(int c, int i) : second_number(c), A(i)
+    {}
+  virtual ~B()
+    {}
+
+  virtual void firstNumber(int b)  // renames member function Number(int) of class A
+    { A::Number(b); }
+  virtual int firstNumber()  // renames member function Number() of class A
+    { return A::Number(); }
+};
+
+
+
+
+class C {
+ private:
+  B* bobject;
+ public:
+  C(B* bp) : bobject(bp)
+    {}
+  virtual ~C()
+    {}
+  //
+  // the following two functions access
+  // private member functions of class B
+  // and they should not be able to do so
+  //
+  virtual void setBValue(int i) 
+    { if (bobject) bobject->Number(i); }// ERROR - .*
+  virtual int getBValue()
+    { if (bobject) { return bobject->Number(); } return 0; }// ERROR - .*
+};
+
+
+int main()
+{
+  B* bobject = new B(2, 1);
+  C* cobject = new C(bobject);
+  cobject->setBValue(8);
+  cout << cobject->getBValue() << endl;
+  delete bobject;
+  delete cobject;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility8.C b/gcc/testsuite/g++.old-deja/g++.law/visibility8.C
new file mode 100644
index 00000000000..8b36e804312
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility8.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// From: roland@jts.com (Roland Knight )
+// Date:     Thu, 29 Apr 1993 16:17:00 -0400
+// Subject:  gcc 2.3.3 bug
+// Message-ID: <m0nof3E-0021ifC@jts.com
+class t1 {
+protected:
+    int a; // ERROR - protected
+};
+
+
+class t2 : private t1 {
+public:
+    int b;
+};
+
+
+class t3 : public t2 {
+public:
+    int ttt();
+};
+
+
+int t3::ttt() { return a; }// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.law/visibility9.C b/gcc/testsuite/g++.old-deja/g++.law/visibility9.C
new file mode 100644
index 00000000000..4b0ab333be0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/visibility9.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+// GROUPS passed visibility
+// visibility file
+// rom: roland@jts.com (Roland Knight )
+// Date:     Sat, 8 May 1993 17:27:35 -0400
+// Subject:  gcc 2.3.3 protected member access bug
+// Message-ID: <9305082127.AA19577@icepick.jts.com>
+
+class A {
+protected:
+    int a; // ERROR - protected
+};
+
+class B : public A {
+public:
+    void f1(A* pa);
+};
+
+
+void B::f1(A* pa) {
+    pa->a = 1;    // illegal but allowed by gcc// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/vtable1.C b/gcc/testsuite/g++.old-deja/g++.law/vtable1.C
new file mode 100644
index 00000000000..32a546a2827
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/vtable1.C
@@ -0,0 +1,27 @@
+// Build don't link:
+// Special g++ Options: -w
+// GROUPS passed vtable
+// vtable file
+// From: mrs@cygnus.com (Mike Stump)
+// Date:     Wed, 20 Apr 1994 17:46:11 -0700
+// Subject:  vtable name generation is wrong
+// Message-ID: <199404210046.RAA25652@rtl.cygnus.com>
+
+// prepare_fresh_vtable doesn't build the names of
+// vtables very well.
+
+struct B {
+  virtual void vf() { }
+};
+
+struct Main {
+  virtual void vf() { }
+};
+
+struct Other : public Main, public B {
+  virtual void vf() { }
+};
+
+struct D : public Main, public B, public Other {
+  virtual void vf() { }
+} a;
diff --git a/gcc/testsuite/g++.old-deja/g++.law/vtable2.C b/gcc/testsuite/g++.old-deja/g++.law/vtable2.C
new file mode 100644
index 00000000000..bbc8074de91
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/vtable2.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// Special g++ Options: -fvtable-thunks
+// GROUPS passed vtable
+struct C1
+{
+    virtual ~C1();
+};
+
+struct C2 : public virtual C1
+{
+        virtual ~C2();
+};
+
+struct C3 : public virtual C2
+{
+    virtual ~C3();
+};
+
+C3::~C3() {}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/vtable3.C b/gcc/testsuite/g++.old-deja/g++.law/vtable3.C
new file mode 100644
index 00000000000..9a6e4a28508
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/vtable3.C
@@ -0,0 +1,24 @@
+// GROUPS passed vtable
+// vtable file
+// From: Pete Bevin <pete@deng.icl.co.uk>
+// Date:     Mon, 28 Nov 1994 19:57:53 +0000 (GMT)
+// Subject:  g++-2.6.2: Virtual inheritance causes incorrect padding
+// Message-ID: <Pine.SOL.3.91.941128194453.7510A-100000@gabriel>
+
+extern "C" void printf (char *, ...);
+
+struct A {
+};
+
+
+struct B : virtual A {
+   public:
+      int b;
+};
+
+
+int main()
+{
+    B blist[10];
+    printf ("PASS\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.law/weak.C b/gcc/testsuite/g++.old-deja/g++.law/weak.C
new file mode 100644
index 00000000000..98465acf9b5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.law/weak.C
@@ -0,0 +1,20 @@
+// Bug: g++ fails to instantiate operator<<.
+// Build don't run:
+// Special g++ Options: -static
+// Skip if not target: i?86-*-linux*
+
+// libc-5.4.xx has __IO_putc in its static C library, which can conflict
+// with the copy of __IO_putc in the libstdc++ library built by egcs.
+#include <iostream.h>
+#include <streambuf.h>
+
+istream x;
+extern "C" int putc(), fgets();
+
+main () {
+  x.get();
+  putc();
+  fgets(); 
+  x.gets(0, 0);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/access1.C b/gcc/testsuite/g++.old-deja/g++.martin/access1.C
new file mode 100644
index 00000000000..a4e0f63168d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/access1.C
@@ -0,0 +1,12 @@
+// Build don't link:
+class A{
+  public:
+    enum Foo{f1,f2};
+
+    class B{
+      friend class A;
+      Foo f;
+      public:
+        B():f(f1){} 
+    };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/ambig1.C b/gcc/testsuite/g++.old-deja/g++.martin/ambig1.C
new file mode 100644
index 00000000000..9886991e29b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/ambig1.C
@@ -0,0 +1,22 @@
+//Build don't link:
+//Based on a report by Bill Currie <bcurrie@tssc.co.nz>
+struct foo {
+  protected:
+    int x;        // ERROR - candidate
+};
+
+struct bar {
+  public:
+    int x();      // ERROR - candidate
+};
+
+struct foobar: public foo, public bar {
+  foobar();
+};
+
+int func(int);
+
+foobar::foobar()
+{
+    func(x);       // ERROR - ambiguous member access
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/conv1.C b/gcc/testsuite/g++.old-deja/g++.martin/conv1.C
new file mode 100644
index 00000000000..0227800d3cf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/conv1.C
@@ -0,0 +1,13 @@
+struct S{
+  operator bool()
+  {
+    return true;
+  }
+};
+
+int main()
+{
+  S a;
+  if (S &b = a);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/lookup1.C b/gcc/testsuite/g++.old-deja/g++.martin/lookup1.C
new file mode 100644
index 00000000000..d45a02e0ec3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/lookup1.C
@@ -0,0 +1,22 @@
+//Build don't link:
+//In the base class list, the context of the current is used
+//reported by Stephen Vavasis <vavasis@CS.Cornell.EDU>
+
+namespace N1 {
+  namespace N2 {
+    class A{};
+    class B;
+  }
+}
+
+class N1::N2::B : public A {
+};
+
+
+class C1 {
+    class A{};
+    class B;
+};
+
+class C1::B : A {
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/new1.C b/gcc/testsuite/g++.old-deja/g++.martin/new1.C
new file mode 100644
index 00000000000..835b42659b8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/new1.C
@@ -0,0 +1,121 @@
+//Lifetime of temporaries: 
+//egcs 2.92 performs cleanup for temporaries inside new expressions
+//after the new is complete, not at the end of the full expression.
+
+#include <new>
+#include <cstdlib>
+#include <cstdio>
+
+bool new_throws;
+bool ctor_throws;
+
+int new_done;
+int ctor_done;
+int func_done;
+int dtor_done;
+int delete_done;
+
+int count;
+
+void init()
+{
+  new_throws = ctor_throws = false;
+  new_done = ctor_done = func_done = dtor_done = delete_done = count = 0;
+}
+
+struct line_error{
+  int line;
+  line_error(int i):line(i){}
+};
+
+#define CHECK(cond)  if(!(cond))throw std::line_error(__LINE__);
+
+struct A{
+  A(int){
+    ctor_done = ++count;
+    if(ctor_throws)
+      throw 1;
+  }
+  A(const A&){
+    CHECK(false); //no copy constructors in this code
+  }
+  ~A(){
+    dtor_done = ++count;
+  }
+  A* addr(){return this;}
+};
+
+struct B{
+  B(A*){}
+  void* operator new(size_t s){
+    new_done = ++count;
+    if(new_throws)
+      throw 1;
+    return malloc(s);
+  }
+  void operator delete(void *){
+    delete_done = ++count;
+  }
+};
+
+void func(B* )
+{
+  func_done = ++count;
+}
+
+void test1()
+{
+  init();
+  try{
+    func(new B(A(10).addr()));
+  }catch(int){
+  }
+  CHECK(new_done==1);
+  CHECK(ctor_done==2);
+  CHECK(func_done==3);
+  CHECK(dtor_done==4);
+  CHECK(delete_done==0);
+}
+
+void test2()
+{
+  init();
+  new_throws = true;
+  try{
+    func(new B(A(10).addr()));
+  }catch(int){
+  }
+  CHECK(new_done==1);
+  CHECK(ctor_done==0);
+  CHECK(func_done==0);
+  CHECK(dtor_done==0);
+  CHECK(delete_done==0);
+}
+
+void test3()
+{
+  init();
+  ctor_throws = true;
+  try{
+    func(new B(A(10).addr()));
+  }catch(int){
+  }
+  CHECK(new_done==1);
+  CHECK(ctor_done==2);
+  CHECK(func_done==0);
+  CHECK(dtor_done==0);
+  CHECK(delete_done==3);
+}
+
+int main()
+{
+  try{
+    test1();
+    test2();
+    test3();
+  }catch(line_error e){
+    printf("Got error in line %d\n",e.line);
+    return 1;
+  }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/overload1.C b/gcc/testsuite/g++.old-deja/g++.martin/overload1.C
new file mode 100644
index 00000000000..8464fba6f9b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/overload1.C
@@ -0,0 +1,12 @@
+//Overload resolution should consider both declarations of func identically.
+
+struct S{};
+void func(S&){}
+
+int main()
+{
+  void func(S&);
+  S s;
+  func(s);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/sts_conv.C b/gcc/testsuite/g++.old-deja/g++.martin/sts_conv.C
new file mode 100644
index 00000000000..7717561c5cb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/sts_conv.C
@@ -0,0 +1,19 @@
+// ecgs-bugs 1999-02-22 14:21, Stefan Schwarzer 
+// sts@ica1.uni-stuttgart.de
+// this code should compile quietly
+
+class CArray 
+{
+public:
+  operator double* (){ return a; }
+  // works if we comment this line:
+  operator double* () const { return const_cast<double *>(a); }
+private:   
+  double      a[2];   
+};
+
+int main(){
+  CArray  a;
+  double *pa = a + 1; // gets bogus error - should convert
+  return 0; 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/sts_iarr.C b/gcc/testsuite/g++.old-deja/g++.martin/sts_iarr.C
new file mode 100644
index 00000000000..a2b63b82a3c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/sts_iarr.C
@@ -0,0 +1,45 @@
+// egcs-bugs 999-02-22 14:26 Stefan Schwarzer
+// sts@ica1.uni-stuttgart.de
+// should compile and return 0  
+
+template <int N>
+struct Outer{
+  struct Inner{
+    Inner(int n): sum(n){}
+
+    typename Outer<N-1>::Inner operator[](int n) const
+    { return typename Outer<N-1>::Inner(sum + n); }
+
+    int sum;
+  };
+
+  typename Outer<N-1>::Inner operator[](int n) const
+  { return typename Outer<N-1>::Inner(n); }
+};
+
+
+// specializations for N==1
+template<>
+struct Outer<1> { 
+  struct Inner {
+    Inner(int n): sum(n){}
+
+    int operator[](int n) const 
+    { return sum+n; }
+    
+    int sum;
+  };
+
+  int operator[](int n) const
+  { return n; }
+};  
+
+
+int main()
+{
+  Outer<1>  sum1;
+  //std::cout << sum1[1] << "\n";
+  Outer<2>  sum2;
+  //std::cout << sum2[1][1] << "\n";
+  return sum1[1] + sum2[1][1] - 3;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/sts_partial.C b/gcc/testsuite/g++.old-deja/g++.martin/sts_partial.C
new file mode 100644
index 00000000000..c2dc9411b54
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/sts_partial.C
@@ -0,0 +1,15 @@
+// excess errors test - XFAIL 
+// ecgs-bugs 1999-02-22 14:26 Stefan Schwarzer
+// sts@ica1.uni-stuttgart.de
+// partial ordering problem in egcs <= 1.1.1
+
+template<class T>
+int f(T &){ return 1; }
+
+template<class T>
+int f( T[] ){ return 0; }
+
+int main(){
+  int d[] ={2};
+  return f(d);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/sts_vectini.C b/gcc/testsuite/g++.old-deja/g++.martin/sts_vectini.C
new file mode 100644
index 00000000000..56f7a1c6a5e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/sts_vectini.C
@@ -0,0 +1,41 @@
+// Special g++ Options: -O2
+// egcs-bugs 1999-02-22 14:24 Stefan Schwarzer
+// sts@ica1.uni-stuttgart.de
+// optimizer problem in egcs <= 1.1.1
+
+struct XTVec{
+  XTVec(){x[0]=x[1] =x[2] =0;}
+  XTVec(int ax,int y=0.,int z=0.){x[0]=ax;x[1]=y; x[2]=z; }
+  int& operator[](int);
+
+  int x[3];
+};
+
+inline 
+int & XTVec::operator[](int i){
+  return x[i];
+}
+
+inline 
+XTVec& operator+=(XTVec& lhs, XTVec& rhs){
+  lhs[0]+=rhs[0];
+  lhs[1]+=rhs[1];
+  lhs[2]+=rhs[2];
+  return lhs;
+}
+
+inline 
+XTVec operator+(XTVec& lhs, XTVec& rhs){
+  XTVec result(lhs);
+  return result += rhs;
+}
+
+int main()
+{
+  XTVec ur(4.,0.,1.);
+  XTVec ll(0.,2.,0.);
+  XTVec initsum(ur + ll);
+
+  // sum of components should be 7
+  return (initsum[0] + initsum[1] + initsum[2] - 7);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/typedef1.C b/gcc/testsuite/g++.old-deja/g++.martin/typedef1.C
new file mode 100644
index 00000000000..b1561f21da5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/typedef1.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+// Copyright (C) 1999 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 31 Mar 1999 <nathan@acm.org>
+
+// Make sure we see through typedefs.
+
+typedef int Int;
+
+void fn()
+{
+  int *p;
+  Int *&pr2 = p;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.martin/typedef2.C b/gcc/testsuite/g++.old-deja/g++.martin/typedef2.C
new file mode 100644
index 00000000000..b9bbcb537c9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.martin/typedef2.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// Testcase from Alexander Zvyagin <zvyagin@mx.ihep.su>
+// Check implicit conversion from string constants into typedefs
+
+typedef char CHAR;
+void f2(CHAR *s="");
+
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/.cvsignore b/gcc/testsuite/g++.old-deja/g++.mike/.cvsignore
new file mode 100644
index 00000000000..7abff1dbead
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/.cvsignore
@@ -0,0 +1,2 @@
+Makefile
+config.status
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/align1.C b/gcc/testsuite/g++.old-deja/g++.mike/align1.C
new file mode 100644
index 00000000000..df6faa6ed01
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/align1.C
@@ -0,0 +1,56 @@
+// Check to make sure we align virtual base classes properly
+
+class eel_base {
+public:
+};
+
+class markable_eel_base : public eel_base {
+private:
+  int mark;
+};
+
+class eel_edge : public markable_eel_base {
+public:
+private:
+  int foo;
+};
+
+class edge : public virtual eel_edge {
+public:
+  edge() {
+    _weight = 0.0;
+  }
+private:
+  double _weight;
+};
+class eel_branch_edge : public virtual edge {
+};
+class branch_edge : public eel_branch_edge {
+};
+
+class eel_interproc_branch_edge : public branch_edge {
+};
+
+class interproc_edge : public virtual edge {
+};
+
+class eel_jump_edge : public virtual edge {
+protected:
+};
+
+class jump_edge : public eel_jump_edge {
+public:
+};
+
+class eel_interproc_jump_edge : public jump_edge {
+protected:
+};
+
+class interproc_jump_edge : public eel_interproc_jump_edge,
+                            public interproc_edge {
+public:
+};
+
+int main () {
+  void *vp = new interproc_jump_edge();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/align2.C b/gcc/testsuite/g++.old-deja/g++.mike/align2.C
new file mode 100644
index 00000000000..758e43cdda6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/align2.C
@@ -0,0 +1,16 @@
+class Foo {
+};
+
+class Bar : virtual Foo {
+public:
+  int b;
+} x;
+
+int main()
+{
+  // printf("Foo offset %d\n", (int)(Foo*)&x - (int)&x);
+  // printf("b offset %d\n", (int)&x.b - (int)&x);
+  // printf("sizeof is %d\n", sizeof(Bar));
+  // This core dumps on a SPARC is alignment is wrong.
+  Bar blist[10];
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ambig1.C b/gcc/testsuite/g++.old-deja/g++.mike/ambig1.C
new file mode 100644
index 00000000000..4552791ad5e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ambig1.C
@@ -0,0 +1,32 @@
+extern "C" int printf(const char *, ...);
+
+struct VB {
+  virtual void f() {
+    printf("VB\n");
+  }
+};
+
+class M : public virtual VB {
+public:
+  int i;
+  void f() {
+    printf("M(%d)\n", i);
+  }
+};
+
+class lM : public M {
+};
+
+class rM : public M {
+};
+
+class D : public lM, rM {
+} d;				// ERROR - ambiguous function
+
+int main() {
+  ((lM*)&d)->i = 1;
+  ((rM*)&d)->i = 2;
+  ((rM*)&d)->f();
+  ((lM*)&d)->f();
+  ((VB*)&d)->f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/asm1.C b/gcc/testsuite/g++.old-deja/g++.mike/asm1.C
new file mode 100644
index 00000000000..f6c4fe5feff
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/asm1.C
@@ -0,0 +1,9 @@
+// Build don't link:
+// Special g++ Options: 
+
+struct A {
+  static void foo() asm("_my_routine");
+};
+
+void A::foo() {
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/asm2.C b/gcc/testsuite/g++.old-deja/g++.mike/asm2.C
new file mode 100644
index 00000000000..59771d6c6a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/asm2.C
@@ -0,0 +1,27 @@
+// Compile with -S, there should be no references to
+// LTRAMP in the output.
+
+extern "C"
+{
+  int printf (char *, ...);
+}
+
+void
+sub2 (void (*func) ())
+{
+  (*func) ();
+}
+
+int
+main(void)
+{
+  extern void sub (void);
+
+  sub2 (sub);
+}
+
+void
+sub (void)
+{
+  printf ("hello world\n");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/bool1.C b/gcc/testsuite/g++.old-deja/g++.mike/bool1.C
new file mode 100644
index 00000000000..c8ff0e8416a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/bool1.C
@@ -0,0 +1,16 @@
+// bool test case
+
+// Build don't link:
+
+void foo(int i) {
+  foo (true);
+}
+
+struct C {
+  void foo(int i) {
+    foo(true);
+  }
+  void bar(bool b) {
+    bar(0);
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/bool2.C b/gcc/testsuite/g++.old-deja/g++.mike/bool2.C
new file mode 100644
index 00000000000..ce2a1f86024
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/bool2.C
@@ -0,0 +1,57 @@
+// Special g++ Options:
+class A {
+public:
+  operator bool () {
+    return true;
+  }
+} a;
+class A1 {
+public:
+  operator int () {
+    return true;
+  }
+} a1;
+class A2 {
+public:
+  operator char * () {
+    return "";
+  }
+} a2;
+class A3 {
+public:
+  operator unsigned long long int () {
+    return true;
+  }
+} a3;
+class A4 {
+public:
+  operator char * () {
+    return "";
+  }
+  operator unsigned long long int () {
+    return true;
+  }
+} a4;
+class A5 {
+public:
+  operator double () {
+    return 256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0
+      *256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0
+	*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0
+	  *256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0*256.0e0;
+  }
+} a5;
+int i = true;
+bool b = true;
+bool c = (bool)(void (A::*)())0;
+bool d = 256;
+main() {
+  if (!d) return 1;
+  if (!a) return 1;
+  if (!(bool)a) return 1;
+  //  if (!(long long)a) return 1;
+  if (!a1) return 1;
+  if (!a2) return 1;
+  if (!a3) return 1;
+  if (!a5) return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/bool4.C b/gcc/testsuite/g++.old-deja/g++.mike/bool4.C
new file mode 100644
index 00000000000..96e4a6c2a52
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/bool4.C
@@ -0,0 +1,3 @@
+// Build don't link:
+
+void foo(bool arg = (1==0)) {}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/conv1.C b/gcc/testsuite/g++.old-deja/g++.mike/conv1.C
new file mode 100644
index 00000000000..468bc423130
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/conv1.C
@@ -0,0 +1,10 @@
+enum E { C };
+
+E foo() {
+  return C;
+}
+
+int main() {
+  if (foo() != C)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/debug1.C b/gcc/testsuite/g++.old-deja/g++.mike/debug1.C
new file mode 100644
index 00000000000..9f7bc39a3ba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/debug1.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Special g++ Options: -g -O -fkeep-inline-functions
+
+class c {
+public:
+  ~c () { };
+};
+
+int
+foo (const c& lhs)
+{
+  c str (lhs);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/dyncast1.C b/gcc/testsuite/g++.old-deja/g++.mike/dyncast1.C
new file mode 100644
index 00000000000..3bddb3ce1e4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/dyncast1.C
@@ -0,0 +1,22 @@
+// Special g++ Options: -fexceptions -w
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe
+
+#include <typeinfo>
+
+struct B {
+  virtual int f() { }
+};
+
+struct D {
+  virtual int f() { }
+};
+
+main() {
+  B b;
+  try {
+    (void)dynamic_cast<D&>(b);
+  } catch (std::bad_cast) {
+    return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/dyncast2.C b/gcc/testsuite/g++.old-deja/g++.mike/dyncast2.C
new file mode 100644
index 00000000000..fcf625e8c69
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/dyncast2.C
@@ -0,0 +1,25 @@
+// Special g++ Options: -fexceptions -w
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe
+
+// Ensure reference handling works.
+
+#include <typeinfo>
+
+struct B {
+  virtual int f() { }
+} ob;
+
+struct D : public B {
+  virtual int f() { }
+} od;
+
+main() {
+  B *b=&ob;
+  try {
+    void *vp = &dynamic_cast<D&>(*b);
+    return 1;
+  } catch (std::bad_cast) {
+    return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/dyncast3.C b/gcc/testsuite/g++.old-deja/g++.mike/dyncast3.C
new file mode 100644
index 00000000000..627a7da23b5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/dyncast3.C
@@ -0,0 +1,19 @@
+// Special g++ Options: -fexceptions -w
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+// Ensure that the return type of dynamic_cast is the real type.
+
+struct B {
+  virtual int f() { }
+};
+
+struct D : public B {
+  virtual int f() { }
+  int i;
+} od;
+
+main() {
+  B *b=&od;
+  if (dynamic_cast<D*>(b)->i)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/dyncast4.C b/gcc/testsuite/g++.old-deja/g++.mike/dyncast4.C
new file mode 100644
index 00000000000..43cb6ef5292
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/dyncast4.C
@@ -0,0 +1,4 @@
+int main() {
+  int* d;
+  dynamic_cast<void*>(d);	// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/dyncast5.C b/gcc/testsuite/g++.old-deja/g++.mike/dyncast5.C
new file mode 100644
index 00000000000..f46d81e4935
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/dyncast5.C
@@ -0,0 +1,71 @@
+#include <stddef.h>
+
+void *p;
+int fail;
+
+class HeapTracked {
+public:
+    virtual ~HeapTracked() = 0;
+    void *operator new(size_t size);
+    void operator delete(void *ptr);
+    static bool isObjectAllocation(const HeapTracked *ptr);
+};
+
+HeapTracked::~HeapTracked(){}
+void * HeapTracked::operator new(size_t size)
+{
+    void * memPtr = ::operator new(size);
+    p = memPtr;
+    return memPtr;
+}
+
+void HeapTracked::operator delete(void *ptr)
+{
+    if (p != ptr)
+      fail = 1;
+    ::operator delete(ptr);
+}
+
+bool HeapTracked::isObjectAllocation(const HeapTracked *ptr)
+{
+    if (p != const_cast<void*>(dynamic_cast<const void*>(ptr)))
+      fail = 1;
+    return false;
+}
+
+class Mumble1: public virtual HeapTracked {
+    double d;
+public:
+    virtual ~Mumble1(){}
+};
+
+class Mumble2: public virtual HeapTracked {
+    double d;
+public:
+    virtual ~Mumble2(){}
+};
+
+class Foo: virtual public HeapTracked,
+           virtual public Mumble1,
+           virtual public Mumble2 {
+public:
+    ~Foo(){}
+};
+
+int main()
+{
+    Foo *pf = new Foo;
+    pf->isObjectAllocation(pf);
+
+    Mumble1 *pm1 = pf;
+    pm1->isObjectAllocation(pm1);
+
+    Mumble2 *pm2 = pf;
+    pm2->isObjectAllocation(pm2);
+
+    // delete pf;
+    // delete pm1;
+    delete pm2;
+
+    return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/dyncast6.C b/gcc/testsuite/g++.old-deja/g++.mike/dyncast6.C
new file mode 100644
index 00000000000..546561dda50
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/dyncast6.C
@@ -0,0 +1,12 @@
+#include <typeinfo>
+
+class A {
+public:
+  virtual void j () {}
+};
+
+class B : public A { };
+     
+void x (A& a) {
+  const B& b1 = dynamic_cast<B&>((const A&)a);	// ERROR - opps
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/dyncast7.C b/gcc/testsuite/g++.old-deja/g++.mike/dyncast7.C
new file mode 100644
index 00000000000..b1a55a43592
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/dyncast7.C
@@ -0,0 +1,28 @@
+// Special g++ Options: -fexceptions
+
+#include <typeinfo>
+#include <stdexcept>
+
+class A {
+public:
+  virtual void j () {}
+};
+
+class B : public A { };
+     
+void x (A& a) {
+  // These should all work.
+  const B& b2 = dynamic_cast<B&>(a);
+  const B& b3 = dynamic_cast<const B&>((const A&)a);
+  const B& b4 = dynamic_cast<const B&>(a);
+}
+
+int main() {
+  try {
+    B b;
+    x (b);
+  } catch (std::exception& e) {
+    // If we get a bad_cast, it is wrong.
+    return 1;
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/dyncast8.C b/gcc/testsuite/g++.old-deja/g++.mike/dyncast8.C
new file mode 100644
index 00000000000..5addfe07e73
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/dyncast8.C
@@ -0,0 +1,18 @@
+#include <typeinfo>
+
+class Base
+{
+public:
+  virtual ~Base() { }
+};
+
+class Derived : public Base { };
+
+int main()
+{
+    const Derived b;
+    const Base*   ap = &b;
+
+    const Derived* p1 = dynamic_cast<const Derived*>(ap);
+    return p1 == 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/dyncast9.C b/gcc/testsuite/g++.old-deja/g++.mike/dyncast9.C
new file mode 100644
index 00000000000..23db8c912bc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/dyncast9.C
@@ -0,0 +1,16 @@
+class S1 { int i; };
+class S2 { int i; };
+class VB {
+public:
+  virtual void foo() { }
+};
+
+class D : public S1, virtual public VB {
+} d;
+
+class E : public S2, public D {
+} e;
+
+int main() {
+  return (char *)&e - (char *)dynamic_cast<E*>((D*)&e);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh1.C b/gcc/testsuite/g++.old-deja/g++.mike/eh1.C
new file mode 100644
index 00000000000..95da594c2fc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh1.C
@@ -0,0 +1,38 @@
+// Build don't link:
+// Special g++ Options: -fexceptions -O -S
+
+extern "C" void printf (char *, ...);
+extern "C" int atoi (const char *);
+extern "C" void exit (int);
+
+struct Exception
+ {
+     int v;
+     Exception(int i) { v = i; };
+ };
+
+ void inc(int &i)
+ {
+     try {
+         if (i == 0)
+             throw Exception(i);
+         else
+             i++;
+     }
+     catch (Exception v) {
+         i = v.v;
+     }
+ }
+
+main (int argc, const char *argv[])
+{
+  if (argc != 2)
+    {
+      printf ("usage: a.out <num>\n");
+      exit (1);
+    }
+  int count = atoi (argv[1]);
+  inc (count);
+  printf ("success\n");
+  exit (0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh10.C b/gcc/testsuite/g++.old-deja/g++.mike/eh10.C
new file mode 100644
index 00000000000..2541f2799c7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh10.C
@@ -0,0 +1,28 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+void foo() {
+  int i;
+  i = 42;
+  throw i;
+}
+
+void ee(int *);
+
+void bar() {
+  int i = 2;
+  ee(&i);
+}
+
+void ee(int *) { }
+
+main() {
+  try {
+    foo();
+    return 3;
+  } catch (int& i) {
+    bar();
+    return i != 42;
+  }
+  return 2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh11.C b/gcc/testsuite/g++.old-deja/g++.mike/eh11.C
new file mode 100644
index 00000000000..781521f8fee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh11.C
@@ -0,0 +1,15 @@
+// Special g++ Options: -fexceptions
+// Build don't link:
+
+struct A {
+  ~A();
+};
+
+int main(int argc, char** argv) {
+  A a;
+  return 0;
+}
+
+
+A::~A() {
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh12.C b/gcc/testsuite/g++.old-deja/g++.mike/eh12.C
new file mode 100644
index 00000000000..1a42e52c82c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh12.C
@@ -0,0 +1,14 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+class MyError { };
+
+int main (int argc, char **argv) {
+  try {
+    throw MyError();
+  }
+  catch (MyError x) {
+  }
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh13.C b/gcc/testsuite/g++.old-deja/g++.mike/eh13.C
new file mode 100644
index 00000000000..841202f349c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh13.C
@@ -0,0 +1,6 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sh-*-* arm-*-pe**-*
+
+#include <string>
+
+main() { }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh14.C b/gcc/testsuite/g++.old-deja/g++.mike/eh14.C
new file mode 100644
index 00000000000..e7c321397a2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh14.C
@@ -0,0 +1,25 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+class arghh {
+public:
+  int n;
+  arghh (int v) { n = v; }
+};
+
+int main () {
+  try {
+    throw arghh (11);
+  }
+  catch (arghh& a) {
+    if (a.n != 11)
+      return 1;
+  }
+  try {
+    throw arghh (22);
+  }
+  catch (arghh& a) {
+    if (a.n != 22)
+      return 2;
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh15.C b/gcc/testsuite/g++.old-deja/g++.mike/eh15.C
new file mode 100644
index 00000000000..9ed673fc87d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh15.C
@@ -0,0 +1,6 @@
+// Build don't link:
+// Special g++ Options: -fexceptions
+
+struct A {
+  A() throw (int);
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh16.C b/gcc/testsuite/g++.old-deja/g++.mike/eh16.C
new file mode 100644
index 00000000000..2a986d54466
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh16.C
@@ -0,0 +1,26 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+int err = 1;
+
+struct A {
+  ~A() {
+    --err;
+  }
+};
+
+struct B {
+  A a;
+  B() {
+    throw 1;
+  }
+};
+
+main() {
+  try {
+    B b;
+  } catch (...) {
+    return err;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh17.C b/gcc/testsuite/g++.old-deja/g++.mike/eh17.C
new file mode 100644
index 00000000000..482ea0434f9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh17.C
@@ -0,0 +1,25 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+int err = 1;
+
+struct A {
+  ~A() {
+    --err;
+  }
+};
+
+struct B : public A {
+  B() {
+    throw 1;
+  }
+};
+
+main() {
+  try {
+    B b;
+  } catch (...) {
+    return err;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh18.C b/gcc/testsuite/g++.old-deja/g++.mike/eh18.C
new file mode 100644
index 00000000000..cf98bce4902
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh18.C
@@ -0,0 +1,63 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+class VB {
+public:
+  int n;
+  VB (int v) { n = v; }
+  VB (const VB& o) {
+    n = o.n;
+//    printf("copying VB from %d to %d\n", &o, this);
+  }
+};
+
+class D : public virtual VB {
+  int j;
+public:
+  D(int i1, int i2) : VB(i2) { j = i1; }
+  VB& vb() { return *(VB*)this; }
+  const VB& vb() const { return *(const VB*)this; }
+};
+
+class pD : private virtual VB {
+  int j;
+public:
+  pD(int i1, int i2) : VB(i2) { j = i1; }
+  VB& vb() { return *(VB*)this; }
+  const VB& vb() const { return *(const VB*)this; }
+};
+
+
+int main () {
+  D d(1943, 4279);
+  pD pd(3621, 9527);
+  VB *vb = &d.vb();
+  VB *pvb = &pd.vb();
+
+  // A catch of a public virtual base.
+  try {
+//    printf("Throwing D at %d (VB at %d)\n", &d, vb);
+    throw d;
+  }
+  catch (VB& vb) {
+//    printf("Catching VB at %d\n", &vb);
+    if (vb.n != 4279)
+      return 1;
+  }
+  catch (...) {
+    return 1;
+  }
+
+  // A catch of a private virtual base.
+  try {
+//    printf("Throwing D at %d (VB at %d)\n", &pd, pvb);
+    throw pd;
+  }
+  catch (VB& vb) {
+//    printf("Catching VB at %d\n", &vb);
+    // This was a private base of the throw object, don't catch it.
+    return 1;
+  }
+  catch (...) {
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh19.C b/gcc/testsuite/g++.old-deja/g++.mike/eh19.C
new file mode 100644
index 00000000000..6e4fe155a48
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh19.C
@@ -0,0 +1,23 @@
+// Special g++ Options: -fexceptions
+// Build don't link:
+
+class test1 {
+public:
+  class fehler{public:fehler(){};};
+  void func(int a) {
+    if( a == 0 )
+      throw fehler();
+  }
+};
+
+int main() {
+  test1 var;
+
+  try {
+    var.func(1);
+    var.func(0);
+  } catch(test1::fehler())		// function type promoted to pointer
+    {
+      ;
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh2.C b/gcc/testsuite/g++.old-deja/g++.mike/eh2.C
new file mode 100644
index 00000000000..d808a65d135
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh2.C
@@ -0,0 +1,71 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <stdlib.h>
+#include <iostream.h>
+
+class Vector {
+private:
+  int *p;
+  int sz;
+
+public:
+  // Exception class
+  class Range     {
+  private:
+    int value_i;
+
+  public:
+    Range( int i ) { value_i = i; };
+    int value() { return value_i; };
+  };
+
+  Vector( int s );
+  ~Vector();
+  int  size() { return sz; };
+  int& operator []( int i );
+};
+
+Vector::Vector(int s) {
+  sz = s;
+  p = new int[sz];
+}
+
+Vector::~Vector() {
+  delete [] p;
+}
+
+int&
+Vector::operator [](int i) {
+  if (0<=i && i<sz) {
+    return p[i];
+  } else {
+    throw Range( i );
+  }
+}
+
+void crash(Vector& v ) {
+  v[v.size()+10];  // Triggers range error!
+}
+
+void do_something(Vector& v) {
+  crash( v );
+}
+
+void
+f(Vector& v) {
+  try {
+    do_something( v );
+  } catch (Vector::Range& r) {
+    cout << "Invalid vector range " << r.value()
+      << " caught in f()" << endl;
+    exit(0);
+  }
+}
+
+main() {
+  Vector v(10);
+
+  f( v );
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh20.C b/gcc/testsuite/g++.old-deja/g++.mike/eh20.C
new file mode 100644
index 00000000000..10535bb9609
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh20.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// Special g++ Options: -fexceptions -Wall
+
+int
+main() {
+  throw 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh21.C b/gcc/testsuite/g++.old-deja/g++.mike/eh21.C
new file mode 100644
index 00000000000..261e6ea5c6e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh21.C
@@ -0,0 +1,14 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+int main () {
+  try {
+    try {
+      throw 1;
+    } catch ( char * ) {
+    }
+  } catch ( int ) {
+    return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh23.C b/gcc/testsuite/g++.old-deja/g++.mike/eh23.C
new file mode 100644
index 00000000000..27fc53d8eeb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh23.C
@@ -0,0 +1,46 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <exception>
+
+struct double_fault { };
+int fault_now;
+
+class E {
+public:
+  E() { }
+  E(const E&) {
+    if (fault_now)
+      throw double_fault();
+  }
+};
+
+void foo() {
+  try {
+    throw E();
+  } catch (...) {
+    fault_now = 1;
+    throw;
+  }
+}
+
+void bar() {
+  try {
+    foo();
+  } catch (E e) {	// double fault here
+  }
+}
+
+void my_terminate() {
+  exit (0);		// double faults should call terminate
+}
+
+main() {
+  std::set_terminate (my_terminate);
+  try {
+    bar();
+  } catch (...) {
+    return 1;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh24.C b/gcc/testsuite/g++.old-deja/g++.mike/eh24.C
new file mode 100644
index 00000000000..c9dd382f469
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh24.C
@@ -0,0 +1,33 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+int fail = 0;
+
+struct A {
+  int ok;
+  A() {
+    ok = 1;
+  }
+  ~A() {
+    if (! ok)
+      fail = 1;
+    ok = 0;
+  }
+};
+
+main() {
+  try {
+    try {
+      A  a;
+      throw 1.0;
+    } catch (double i) {
+      A a1;
+      throw 1;    // make sure both a1 and a2 are not destroyed when we throw!
+    } catch (int i) {
+      A a2;
+      throw 1.0;
+    }
+  } catch (int i) {
+  }
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh25.C b/gcc/testsuite/g++.old-deja/g++.mike/eh25.C
new file mode 100644
index 00000000000..52754b53359
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh25.C
@@ -0,0 +1,30 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <exception>
+
+void my_terminate() {
+  exit (0);		// Double faults should call terminate
+}
+
+struct A {
+  A() { }
+  ~A() {
+    std::set_terminate (my_terminate);
+    throw 1;		// This throws from EH dtor, should call my_terminate
+  }
+};
+
+main() {
+  try {
+    try {
+      throw 1;
+    } catch (int i) {
+      A a;		// A hit on this EH dtor went to the wrong place
+      throw 1;
+    }
+  } catch (...) {
+    return 1;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh26.C b/gcc/testsuite/g++.old-deja/g++.mike/eh26.C
new file mode 100644
index 00000000000..35cafa4286a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh26.C
@@ -0,0 +1,15 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+class MyExceptionHandler { };
+
+main() {
+  try {
+    throw MyExceptionHandler();
+  } catch(const MyExceptionHandler& eh) {
+    return 0;
+  } catch(...) {
+    return 1;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh27.C b/gcc/testsuite/g++.old-deja/g++.mike/eh27.C
new file mode 100644
index 00000000000..bd07138c753
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh27.C
@@ -0,0 +1,17 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <typeinfo>
+
+class MyExceptionHandler { };
+
+main() {
+  try {
+    throw MyExceptionHandler();
+  } catch(const MyExceptionHandler& eh) {
+    return 0;
+  } catch(...) {
+    return 1;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh28.C b/gcc/testsuite/g++.old-deja/g++.mike/eh28.C
new file mode 100644
index 00000000000..3f2d0a6d68b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh28.C
@@ -0,0 +1,17 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <typeinfo>
+
+int fail = 1;
+
+class X            { public: virtual void p() { } };
+class Y : public X { public: virtual void p() { fail = 0; } };
+
+main()
+{
+  try          { Y y; throw y; }
+  catch (X& x) { x.p();  }
+  catch (...)  { }
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh29.C b/gcc/testsuite/g++.old-deja/g++.mike/eh29.C
new file mode 100644
index 00000000000..58c1f0b3f82
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh29.C
@@ -0,0 +1,27 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+int count;
+
+class A {
+public:
+  A() {
+//    printf("ctor %x\n", (int)this);
+    if (count==3)
+      throw 1;
+    ++count;
+    }
+  ~A() {
+    --count;
+//    printf("dtor %x\n", (int)this);
+  }
+};
+
+main() {
+  try {
+    A a[5];
+  } catch (...) {
+    return count;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh3.C b/gcc/testsuite/g++.old-deja/g++.mike/eh3.C
new file mode 100644
index 00000000000..e8b87bf30f7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh3.C
@@ -0,0 +1,21 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+class foo {
+public:
+  class error {};
+
+  void cause_error(void) { throw error(); }
+};
+
+int main(void)
+{
+  foo f;
+  try {
+    f.cause_error();
+  }
+  catch (foo::error&) {
+    return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh30.C b/gcc/testsuite/g++.old-deja/g++.mike/eh30.C
new file mode 100644
index 00000000000..61a30c8ddda
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh30.C
@@ -0,0 +1,5 @@
+// Build don't link:
+// Skip if not native
+// Special g++ Options: -fexceptions -fPIC -S
+
+main() { throw 1; }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh31.C b/gcc/testsuite/g++.old-deja/g++.mike/eh31.C
new file mode 100644
index 00000000000..65e683cf8fd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh31.C
@@ -0,0 +1,23 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+int count;
+
+class Foo {
+public:
+  Foo() { ++count; }
+  Foo(const Foo&) { ++count; }
+  ~Foo() { --count; }
+};
+
+
+main() {
+  try {
+    throw Foo();
+  }
+  catch (Foo& object) {
+    if (count == 1)
+      return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh32.C b/gcc/testsuite/g++.old-deja/g++.mike/eh32.C
new file mode 100644
index 00000000000..12d601c883f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh32.C
@@ -0,0 +1,20 @@
+// Build don't link:
+// Special g++ Options: -fexceptions
+
+class Base {
+public:
+    virtual ~Base() throw();
+};
+ 
+Base::~Base() throw()
+{
+}
+ 
+class Foo : public Base {
+public:
+    virtual ~Foo() throw();
+};
+ 
+Foo::~Foo() throw()
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh33.C b/gcc/testsuite/g++.old-deja/g++.mike/eh33.C
new file mode 100644
index 00000000000..234b745f3a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh33.C
@@ -0,0 +1,21 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL hppa*-*-* a29k-*-* sparc64-*-elf sh-*-* z8k-*-* arm-*-pe**-*
+
+#include <exception>
+
+void my_unexpected() {
+  throw 42;
+}
+
+void foo() throw (int) { throw "Hi"; }
+
+int main() {
+  std::set_unexpected (my_unexpected);
+  try {
+    foo();
+  } catch (int i) {
+    if (i == 42)
+      return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh34.C b/gcc/testsuite/g++.old-deja/g++.mike/eh34.C
new file mode 100644
index 00000000000..9c7e985bbea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh34.C
@@ -0,0 +1,16 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <exception>
+
+void my_unexpected() {
+  exit (0);
+}
+
+void foo() throw () { throw "Hi"; }
+
+int main() {
+  std::set_unexpected (my_unexpected);
+  foo();
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh35.C b/gcc/testsuite/g++.old-deja/g++.mike/eh35.C
new file mode 100644
index 00000000000..d9bd34c58e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh35.C
@@ -0,0 +1,17 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+main() {
+  try {  
+    throw 'a';
+  } catch (char a) {
+    try {
+      throw 'a';
+    } catch (int i) {
+      return 1;
+    } catch (char c) {
+      return 0;
+    }
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh36.C b/gcc/testsuite/g++.old-deja/g++.mike/eh36.C
new file mode 100644
index 00000000000..fbb639204a7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh36.C
@@ -0,0 +1,29 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <typeinfo>
+
+class A {
+  int space;
+};
+class B {
+public:
+  int data;
+  B(int i) : data(i) {
+  }
+};
+class D : public A, public B {
+public:
+  D(int i) : B(i) {
+  }
+} d(42);
+
+main() {
+  try {
+    throw &d;
+  } catch (B* b) {
+    if (b->data == 42)
+      return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh37.C b/gcc/testsuite/g++.old-deja/g++.mike/eh37.C
new file mode 100644
index 00000000000..75f6523a3a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh37.C
@@ -0,0 +1,21 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <typeinfo>
+
+class B {
+public:
+  int data;
+  B(int i) : data(i) {
+  }
+} b(42);
+
+main() {
+  try {
+    throw &b;
+  } catch (B* b) {
+    if (b->data == 42)
+      return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh38.C b/gcc/testsuite/g++.old-deja/g++.mike/eh38.C
new file mode 100644
index 00000000000..915ef4c89e4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh38.C
@@ -0,0 +1,28 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <typeinfo>
+
+class B {
+public:
+  int data;
+  B(int i) : data(i) {
+  }
+} b(42);
+
+main() {
+  try {
+    throw &b;
+  } catch (const B* bptr) {
+    if (bptr->data == 42)
+      {
+	try {
+	  throw &b;
+	} catch (void *bptr) {
+	  if (((B*)bptr)->data == 42)
+	    return 0;
+	}
+      }
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh39.C b/gcc/testsuite/g++.old-deja/g++.mike/eh39.C
new file mode 100644
index 00000000000..54d10959a57
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh39.C
@@ -0,0 +1,28 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+int fail = 1;
+class B {
+public:
+  B() { throw 1; }
+};
+class D : public B {
+public:
+  D();
+};
+
+D::D() try : B() {
+  fail = 1;
+} catch (...) {
+  fail = 0;
+  throw;
+}
+
+main() {
+  try {
+    D d;
+    fail = 1;
+  } catch (...) {
+  }
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh4.C b/gcc/testsuite/g++.old-deja/g++.mike/eh4.C
new file mode 100644
index 00000000000..c87ab293b36
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh4.C
@@ -0,0 +1,6 @@
+// Build don't link:
+// Special g++ Options: -fexceptions
+
+void foo() {
+  throw 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh40.C b/gcc/testsuite/g++.old-deja/g++.mike/eh40.C
new file mode 100644
index 00000000000..16badc2d911
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh40.C
@@ -0,0 +1,29 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+int fail = 1;
+class B {
+public:
+  B() { throw 1; }
+};
+class D : public B {
+public:
+  D() try : B() {
+    fail = 1;
+  } catch (char c) {
+    fail = 1;
+    throw;
+  } catch (...) {
+    fail = 0;
+    throw;
+  }
+};
+
+main() {
+  try {
+    D d;
+    fail = 1;
+  } catch (...) {
+  }
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh41.C b/gcc/testsuite/g++.old-deja/g++.mike/eh41.C
new file mode 100644
index 00000000000..4127402d09e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh41.C
@@ -0,0 +1,29 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+int fail = 0;
+
+struct A {
+   A () { a = 'a'; b = 'b'; c = 'c'; }
+   ~ A () {
+      if ( a != 'a' ) fail = 1;
+      if ( b != 'b' ) fail = 1;
+      if ( c != 'c' ) fail = 1;
+   }
+   char a, b, c;
+};
+
+void some_init () { throw 1; }
+
+struct C : A {
+   C () { some_init (); }
+};
+
+int main () {
+  try {
+    C c;
+  } catch (int i) {
+    return 0;
+  }
+  return 1;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh42.C b/gcc/testsuite/g++.old-deja/g++.mike/eh42.C
new file mode 100644
index 00000000000..6da9bd51c96
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh42.C
@@ -0,0 +1,18 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+struct none { int i[50]; };
+
+class my_ex { } a;
+
+none throw_it() {
+  throw 1;
+}
+
+int main() {
+    try {
+      none n = throw_it();
+    } catch (int ex) {
+      return 0;
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh44.C b/gcc/testsuite/g++.old-deja/g++.mike/eh44.C
new file mode 100644
index 00000000000..e612aeb793b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh44.C
@@ -0,0 +1,36 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+// prms-id: 9159
+
+static unsigned int iCounter = 0;
+static unsigned int iMax;
+int fail = 0;
+
+class ca {
+public:
+  ca(int) {
+    if (iCounter++ == iMax)
+      throw (const char*)"iCounter";
+  }
+  virtual ~ca() {
+  }
+};
+
+class cc {
+public:
+  cc(const ca &rca1, const ca &rca2) {
+  }
+  virtual ~cc() {
+    fail = 1;
+  }
+};
+
+
+int main(int argc, char **argv) {
+  iMax = 1;
+  try {
+    cc sc(ca(1), ca(1));
+  } catch (const char *pMsg) {
+  }
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh45.C b/gcc/testsuite/g++.old-deja/g++.mike/eh45.C
new file mode 100644
index 00000000000..bed0b921d6b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh45.C
@@ -0,0 +1,34 @@
+int i;
+int fail;
+
+class ca {
+public:
+  ca() {
+    if (++i != 1)
+      fail = 1;
+  }
+  virtual ~ca() {
+    if (++i != 4)
+      fail = 4;
+  }
+};
+
+class cb {
+public:
+  cb(const ca &rca) {
+    if (++i != 2)
+      fail = 2;
+  }
+  virtual ~cb() {
+    if (++i != 3)
+      fail = 3;
+  }
+};
+
+void foo(const cb &rcb) {
+}
+
+int main(int argc, char **argv) {
+  foo(cb(ca()));
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh46.C b/gcc/testsuite/g++.old-deja/g++.mike/eh46.C
new file mode 100644
index 00000000000..e0e6553f7c7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh46.C
@@ -0,0 +1,47 @@
+// Build don't link:
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sh-*-* arm-*-pe**-*
+
+int atoi(const char *);
+
+struct ios {
+ virtual ~ios();
+};
+ 
+class fstreambase : virtual public ios {
+};
+
+class ifstream : public fstreambase {
+};
+
+class ofstream : public fstreambase {
+};
+
+extern const short O;
+extern const short D;
+
+const short O=  0;
+const short D= -3;
+
+
+short glc(const char* const * const l,
+	  short& n,short& x,short& y,
+	  ifstream* i,ofstream* o)
+
+{
+  n=atoi(l[1]);
+
+  x=atoi(l[2]);
+  y=atoi(l[3]);
+
+  if((x < 0)||(y <0))
+    {
+     return D;
+    }
+
+  i = new ifstream[n];
+  o = new ofstream[2];
+
+  return O;
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh47.C b/gcc/testsuite/g++.old-deja/g++.mike/eh47.C
new file mode 100644
index 00000000000..043a6174a6f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh47.C
@@ -0,0 +1,23 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <cstdlib>
+#include <exception>
+
+void myterm() {
+  exit (0);
+}
+
+main() {
+  try {
+    throw "";
+  } catch (...) {
+  }
+  try {
+    std::set_terminate (myterm);
+    throw;
+  } catch (...) {
+    return 1;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh48.C b/gcc/testsuite/g++.old-deja/g++.mike/eh48.C
new file mode 100644
index 00000000000..351fc4f60a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh48.C
@@ -0,0 +1,32 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <exception>
+using std::uncaught_exception;
+class A {
+public:
+  ~A() {
+    if (uncaught_exception ())
+      exit (0);
+  }
+};
+
+int main() {
+  if (uncaught_exception ())
+    return 1;
+  try {
+    throw "";
+  } catch (...) {
+    if (uncaught_exception ())
+      return 1;
+  }
+  if (uncaught_exception ())
+    return 1;
+  try {
+    A a;
+    throw "";
+  } catch (...) {
+    return 1;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh49.C b/gcc/testsuite/g++.old-deja/g++.mike/eh49.C
new file mode 100644
index 00000000000..0505db168b2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh49.C
@@ -0,0 +1,15 @@
+// Special g++ Options: -fexceptions -O9
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+void main1() {
+  throw 1;
+}
+
+int main() {
+  try {
+    main1();
+  } catch (...) {
+    return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh5.C b/gcc/testsuite/g++.old-deja/g++.mike/eh5.C
new file mode 100644
index 00000000000..3289d975d58
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh5.C
@@ -0,0 +1,21 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+class foo {
+public:
+  class error {};
+
+  void cause_error(void) { throw "Hello World!"; }
+};
+
+int main(void)
+{
+  foo f;
+  try {
+    f.cause_error();
+  }
+  catch (const char cp[]) {
+    return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh50.C b/gcc/testsuite/g++.old-deja/g++.mike/eh50.C
new file mode 100644
index 00000000000..0747e1032ef
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh50.C
@@ -0,0 +1,21 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL hppa*-*-* a29k-*-* sparc64-*-elf sh-*-* z8k-*-* arm-*-pe**-*
+
+#include <exception>
+
+void my_unexpected() {
+  throw 42;
+}
+
+template <class T> int foo(T) throw (int) { throw "Hi"; }
+
+main() {
+  std::set_unexpected (my_unexpected);
+  try {
+    foo(1);
+  } catch (int i) {
+    if (i == 42)
+      return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh51.C b/gcc/testsuite/g++.old-deja/g++.mike/eh51.C
new file mode 100644
index 00000000000..ac7f620df42
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh51.C
@@ -0,0 +1,21 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* z8k-*-* arm-*-pe**-*
+
+#include <exception>
+
+void my_unexpected() {
+  throw 42;
+}
+
+template <class T> int foo(T) throw (T) { throw "Hi"; }
+
+main() {
+  std::set_unexpected (my_unexpected);
+  try {
+    foo(1);
+  } catch (int i) {
+    if (i == 42)
+      return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh52.C b/gcc/testsuite/g++.old-deja/g++.mike/eh52.C
new file mode 100644
index 00000000000..475070caebf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh52.C
@@ -0,0 +1,14 @@
+// Special g++ Options: -fexceptions -O9
+
+int promote_mode (int mode, int *punsignedp)
+{
+  int unsignedp = *punsignedp;
+  *punsignedp = unsignedp;
+  return mode;
+}
+
+int main() {
+  int i;
+  i = promote_mode (42, &i);
+  return i != 42;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh53.C b/gcc/testsuite/g++.old-deja/g++.mike/eh53.C
new file mode 100644
index 00000000000..7d47c6d1461
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh53.C
@@ -0,0 +1,15 @@
+// Special g++ Options: -fexceptions -g
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+class zeroset {
+public:
+  ~zeroset () { }
+};
+
+int main () {
+  zeroset a;
+  try {
+    ;
+  } catch( zeroset ) {
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh54.C b/gcc/testsuite/g++.old-deja/g++.mike/eh54.C
new file mode 100644
index 00000000000..9c2d206f092
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh54.C
@@ -0,0 +1,3 @@
+// Special g++ Options: -fexceptions
+
+int main() { try { 1; } }	// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh55.C b/gcc/testsuite/g++.old-deja/g++.mike/eh55.C
new file mode 100644
index 00000000000..e64bcf82374
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh55.C
@@ -0,0 +1,18 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+#include <exception>
+
+void my_terminate_handler() {
+  exit(0);
+}
+
+void throw_an_unexpected_exception() throw() {
+  throw 1;
+}
+
+int main() {
+  std::set_terminate(my_terminate_handler);
+  throw_an_unexpected_exception();
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh56.C b/gcc/testsuite/g++.old-deja/g++.mike/eh56.C
new file mode 100644
index 00000000000..674a82df450
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh56.C
@@ -0,0 +1,22 @@
+// Special g++ Options: -fexceptions
+
+struct A {
+  A() { }
+  A(const char *) { }
+  A(const A&) { }
+  ~A() { }
+};
+
+struct bmf {
+  bmf (const A n) { }
+  ~bmf (void) { }
+  A name;
+};
+
+void imf (void) {
+  bmf Sabs ("abs");
+}
+
+int main(void) {
+  imf ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh57.C b/gcc/testsuite/g++.old-deja/g++.mike/eh57.C
new file mode 100644
index 00000000000..545a85fdfa9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh57.C
@@ -0,0 +1,18 @@
+// Build don't link:
+// Special g++ Options: -fno-exceptions
+
+class Calendar_Time {
+public:
+  ~Calendar_Time ();
+  int operator <= (const Calendar_Time& t) const;
+};
+
+class Temporal_Model_Interval {
+public:
+  Calendar_Time start_time ();
+};
+
+int intersects_p (Temporal_Model_Interval* i1, Temporal_Model_Interval* i2) {
+  return ((i1->start_time() <= i2->start_time())
+	  || (i1->start_time() <= i2->start_time()));
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh58.C b/gcc/testsuite/g++.old-deja/g++.mike/eh58.C
new file mode 100644
index 00000000000..967e74ab12d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh58.C
@@ -0,0 +1,18 @@
+// Build don't link:
+// Special g++ Options: -fexceptions
+
+struct C {
+    bool mem;
+    ~C();
+};
+
+C genTemp();
+  
+int foo_notok(int arg) {
+    switch (arg) {
+    case 0:
+        return genTemp().mem;
+    default:
+        return 3;
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh6.C b/gcc/testsuite/g++.old-deja/g++.mike/eh6.C
new file mode 100644
index 00000000000..b9e7c8cc46c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh6.C
@@ -0,0 +1,19 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+extern "C" int printf(const char *, ...);
+
+void main1() {
+  throw 1;
+}
+
+
+int main() {
+  try {
+    main1();
+  } catch (...) {
+    printf("Unwind works!\n");
+    return 0;
+  }
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh7.C b/gcc/testsuite/g++.old-deja/g++.mike/eh7.C
new file mode 100644
index 00000000000..3e2c75a67f2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh7.C
@@ -0,0 +1,7 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+main() {
+  if (0)
+    throw 1 | 2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh8.C b/gcc/testsuite/g++.old-deja/g++.mike/eh8.C
new file mode 100644
index 00000000000..a9f7a902f2c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh8.C
@@ -0,0 +1,20 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+
+extern "C" int printf(const char *, ...);
+
+int i;
+
+main() {
+  try {
+    try {
+      throw i;
+    } catch (char *) {
+      return 1;
+    }
+    return 1;
+  } catch (int i) {
+    return 0;
+  }    
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/eh9.C b/gcc/testsuite/g++.old-deja/g++.mike/eh9.C
new file mode 100644
index 00000000000..febd1dc4b96
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/eh9.C
@@ -0,0 +1,4 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe*
+
+main() throw () { }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/enum1.C b/gcc/testsuite/g++.old-deja/g++.mike/enum1.C
new file mode 100644
index 00000000000..89e8542b779
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/enum1.C
@@ -0,0 +1,11 @@
+// Build don't link:
+// Warn if a enum cannot fit into a small bit-field.
+
+enum TypeKind { ATK, BTK, CTK, DTK } ;
+
+struct Type {
+  enum TypeKind kind : 1;		// WARNING - 
+  void setBTK();
+};
+
+void Type::setBTK() { kind = DTK; }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/err1.C b/gcc/testsuite/g++.old-deja/g++.mike/err1.C
new file mode 100644
index 00000000000..8748c7860b1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/err1.C
@@ -0,0 +1,8 @@
+// Build don't link:
+
+struct gorf {
+  int stuff;
+  void snarf();
+};
+
+template <class T> void gorf::snarf() { return; }  // ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/err2.C b/gcc/testsuite/g++.old-deja/g++.mike/err2.C
new file mode 100644
index 00000000000..c3af5b47fe2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/err2.C
@@ -0,0 +1,6 @@
+class foo {
+public:
+  void apply(foo *(foo::*memptr)()) {
+    this->*memptr();		// ERROR - wrong
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/err3.C b/gcc/testsuite/g++.old-deja/g++.mike/err3.C
new file mode 100644
index 00000000000..b42a4a908d8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/err3.C
@@ -0,0 +1,9 @@
+class cb {
+};
+
+class cc {
+public:
+  cc()
+    : cb() {		// ERROR - 
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/explicit1.C b/gcc/testsuite/g++.old-deja/g++.mike/explicit1.C
new file mode 100644
index 00000000000..28213ba377d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/explicit1.C
@@ -0,0 +1,15 @@
+struct A1 {
+  explicit A1(int) { }
+} a1(1);
+
+struct A {
+  explicit A(int);
+} a(1);
+
+A::A(int) {
+}
+
+void foo(A a) {
+  foo(a);
+  foo(1);		// ERROR - not allowed
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/explicit2.C b/gcc/testsuite/g++.old-deja/g++.mike/explicit2.C
new file mode 100644
index 00000000000..a2077bffc2f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/explicit2.C
@@ -0,0 +1,24 @@
+// Build don't link:
+
+class string {
+public:
+  string(const char*) { } 
+  explicit string(int size) { }
+}; 
+
+void foo(string) { }
+
+string bar() {
+  foo("hello");		// ok
+  foo(string(2));	// ok
+  foo(2);		// ERROR - no implicit conversion from int to string
+  string x = 2;		// ERROR - no implicit conversion from int to string
+  string y(2);		// ok
+  foo((string)2);	// ok
+  return 2;		// ERROR - no implicit conversion from int to string
+}
+
+class A : string {
+public:
+  A() : string(2) { }	// ok
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/for1.C b/gcc/testsuite/g++.old-deja/g++.mike/for1.C
new file mode 100644
index 00000000000..e46213035bf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/for1.C
@@ -0,0 +1,3 @@
+int main() {
+  for( {int i = 0; int j = 0;} i < 10; ++i ) ;		// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/for2.C b/gcc/testsuite/g++.old-deja/g++.mike/for2.C
new file mode 100644
index 00000000000..fd01804d86b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/for2.C
@@ -0,0 +1,19 @@
+// Build don't link:
+
+void foo() {
+  for (class C {};;)
+    ;
+  C c;		// ERROR - 
+}
+
+void bar() {
+  for (enum E {num};;)
+    ;
+  E e;		// ERROR - 
+}
+
+void bee () {
+  int i = 0;
+  for (int fun() = 0; i != 2; ++i) {	// ERROR - 
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/fresco1.C b/gcc/testsuite/g++.old-deja/g++.mike/fresco1.C
new file mode 100644
index 00000000000..16fa1dbcbe9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/fresco1.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+// This is a Fresco found bug.
+
+class WhoCares {};
+
+typedef float Coord;
+
+class BugDemo : public WhoCares {
+public:
+  typedef Coord Matrix[4][4];
+  virtual void vf1(BugDemo::Matrix m) = 0;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/hog1.C b/gcc/testsuite/g++.old-deja/g++.mike/hog1.C
new file mode 100644
index 00000000000..8627100f2de
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/hog1.C
@@ -0,0 +1,187 @@
+class dummy                             { public: void operator++(void) {}
+                     };
+class dummy_000 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_001 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_002 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_003 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_004 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_005 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_006 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_007 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_008 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_009 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_010 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_011 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_012 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_013 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_014 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_015 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_016 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_017 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_018 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_019 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_020 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_021 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_022 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_023 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_024 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_025 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_026 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_027 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_028 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_029 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_030 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_031 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_032 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_033 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_034 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_035 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_036 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_037 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_038 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_039 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_040 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_041 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_042 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_043 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_044 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_045 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_046 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_047 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_048 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+class dummy_049 : private virtual dummy { public: void operator++(void) {
+dummy::operator++(); } };
+
+class super :
+  private dummy_000, private dummy_001, private dummy_002, private
+dummy_003, private dummy_004,
+  private dummy_005, private dummy_006, private dummy_007, private
+dummy_008, private dummy_009,
+  private dummy_010, private dummy_011, private dummy_012, private
+dummy_013, private dummy_014,
+  private dummy_015, private dummy_016, private dummy_017, private
+dummy_018, private dummy_019,
+  private dummy_020, private dummy_021, private dummy_022, private
+dummy_023, private dummy_024,
+  private dummy_025, private dummy_026, private dummy_027, private
+dummy_028, private dummy_029,
+  private dummy_030, private dummy_031, private dummy_032, private
+dummy_033, private dummy_034,
+  private dummy_035, private dummy_036, private dummy_037, private
+dummy_038, private dummy_039,
+  private dummy_040, private dummy_041, private dummy_042, private
+dummy_043, private dummy_044,
+  private dummy_045, private dummy_046, private dummy_047, private
+dummy_048, private dummy_049
+{
+public:
+  void operator++(void);
+};
+
+void super::operator++(void)
+{
+  dummy_000::operator++();
+  dummy_001::operator++();
+  dummy_002::operator++();
+  dummy_003::operator++();
+  dummy_004::operator++();
+  dummy_005::operator++();
+  dummy_006::operator++();
+  dummy_007::operator++();
+  dummy_008::operator++();
+  dummy_009::operator++();
+  dummy_010::operator++();
+  dummy_011::operator++();
+  dummy_012::operator++();
+  dummy_013::operator++();
+  dummy_014::operator++();
+  dummy_015::operator++();
+  dummy_016::operator++();
+  dummy_017::operator++();
+  dummy_018::operator++();
+  dummy_019::operator++();
+  dummy_020::operator++();
+  dummy_021::operator++();
+  dummy_022::operator++();
+  dummy_023::operator++();
+  dummy_024::operator++();
+  dummy_025::operator++();
+  dummy_026::operator++();
+  dummy_027::operator++();
+  dummy_028::operator++();
+  dummy_029::operator++();
+  dummy_030::operator++();
+  dummy_031::operator++();
+  dummy_032::operator++();
+  dummy_033::operator++();
+  dummy_034::operator++();
+  dummy_035::operator++();
+  dummy_036::operator++();
+  dummy_037::operator++();
+  dummy_038::operator++();
+  dummy_039::operator++();
+  dummy_040::operator++();
+  dummy_041::operator++();
+  dummy_042::operator++();
+  dummy_043::operator++();
+  dummy_044::operator++();
+  dummy_045::operator++();
+  dummy_046::operator++();
+  dummy_047::operator++();
+  dummy_048::operator++();
+  dummy_049::operator++();
+}
+
+
+int main(void)
+{
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/init1.C b/gcc/testsuite/g++.old-deja/g++.mike/init1.C
new file mode 100644
index 00000000000..8d591865d10
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/init1.C
@@ -0,0 +1,25 @@
+int count;
+
+extern "C" void _exit(int);
+
+struct C {
+  ~C() { if (count != 1) _exit(1); }
+} c;
+
+class A {
+public:
+  ~A () { ++count; }
+};
+
+void f() {
+  static A a;
+}
+
+void g() {
+  // Since this isn't constructed, we can't destruct it.
+  static A a;
+}
+
+int main () {
+  f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/init2.C b/gcc/testsuite/g++.old-deja/g++.mike/init2.C
new file mode 100644
index 00000000000..343d76f88cc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/init2.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+struct Foo {
+  Foo (int);
+};
+
+int bar (Foo);
+
+int x = bar (3);
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/leak1.C b/gcc/testsuite/g++.old-deja/g++.mike/leak1.C
new file mode 100644
index 00000000000..2a6c33779d3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/leak1.C
@@ -0,0 +1,38 @@
+int count = 0;
+
+class T {
+  int i;
+public:
+  T() {
+    i = 1;
+    ++count;
+  }
+  T(const T& o) {
+    i = o.i;
+    ++count;
+  }
+  T operator +(const T& o) {
+    T r;
+    r.i = this->i + o.i;
+    return r;
+  }
+  operator int () {
+    return i;
+  }
+  ~T() {
+    --count;
+  }
+} s, b;
+
+void bar() {
+  static int j = int(s+b);
+  int i = int(s+b);
+}
+
+int i = int(s+b);
+
+int main() {
+  bar();
+  bar();
+  return count != 2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/mangle1.C b/gcc/testsuite/g++.old-deja/g++.mike/mangle1.C
new file mode 100644
index 00000000000..ac7d6cf92fb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/mangle1.C
@@ -0,0 +1,27 @@
+// Build don't link:
+// Special g++ Options: 
+
+// Make sure the typedef name is used in name mangling, not some random
+// anonymous name
+
+struct foo {
+  typedef enum { red } color;
+  void bar(color r) {
+  }
+} f;
+
+#ifdef sparc
+void f1() asm("bar__3fooQ23foo3$_0");
+void f1() {
+}
+void f2() asm("_bar__3fooQ23foo3$_0");
+void f2() {
+}
+void f3() asm("__bar__3fooQ23foo3$_0");
+void f3() {
+}
+#endif
+
+main() {
+  f.bar(foo::red);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/mangle2.C b/gcc/testsuite/g++.old-deja/g++.mike/mangle2.C
new file mode 100644
index 00000000000..174cacc6f3b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/mangle2.C
@@ -0,0 +1,17 @@
+// Build don't link:
+// Special g++ Options: 
+
+typedef struct {
+} color;
+
+void foo(color) {
+}
+
+#ifdef sparc
+void f1() asm("foo__FG3$_0");
+void f1() { }
+void f2() asm("_foo__FG3$_0");
+void f2() { }
+void f3() asm("__foo__FG3$_0");
+void f3() { }
+#endif
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/mangle3.C b/gcc/testsuite/g++.old-deja/g++.mike/mangle3.C
new file mode 100644
index 00000000000..77b92eca166
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/mangle3.C
@@ -0,0 +1,14 @@
+struct ZZ {
+  int p;
+};
+
+
+template <int ZZ::* ptr>
+struct YY {
+  ZZ qq;
+  YY() { }
+};
+
+int main() {
+  YY<&ZZ::p> ww;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/memoize1.C b/gcc/testsuite/g++.old-deja/g++.mike/memoize1.C
new file mode 100644
index 00000000000..9b7aadc5081
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/memoize1.C
@@ -0,0 +1,4 @@
+// Build don't link:
+// Special g++ Options: -fsave-memoized
+
+#include <iostream.h>
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/mi1.C b/gcc/testsuite/g++.old-deja/g++.mike/mi1.C
new file mode 100644
index 00000000000..0f5880dc145
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/mi1.C
@@ -0,0 +1,44 @@
+// Special g++ Options: -w
+
+class A {
+public:
+  virtual ~A(){};
+  virtual int type(void) {
+    return -1;
+  }
+};
+
+class B : public A {
+public:
+  virtual ~B(){};
+};
+
+
+class C0 : public B, public virtual A {
+public:
+  virtual int type(void) {
+    return 0;
+  }
+};
+
+class C1 : public C0
+{
+public:
+  virtual int type(void) {
+    return 1;
+  }
+};
+
+class C2 : public C0 {
+public:
+  virtual int type(void) {
+    return 2;
+  }
+};
+
+main() {
+  C1 *one = new C1;
+  
+  if (one->type() != 1)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/mi2.C b/gcc/testsuite/g++.old-deja/g++.mike/mi2.C
new file mode 100644
index 00000000000..f3c01e383e5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/mi2.C
@@ -0,0 +1,46 @@
+class A {
+  char a;
+public:
+  A(char x) : a(x) { }
+  virtual ~A() { }
+};
+
+class B : virtual public A {
+  char b;
+public:
+  B(char x) : A('b'), b(x) { }
+  ~B() { }
+};
+
+class C : virtual public A {
+  char c;
+public:
+  C(char x) : A('c'), c(x) { }
+  ~C() { }
+};
+
+class D : virtual public A, public B, public C {
+  char d;
+public:
+  D(char x) : A('d'), B('d'), C('d'), d(x) { }
+  ~D() { }
+};
+
+class E : virtual public A, public B, public C {
+  char e;
+public:
+  E(char x) : A('e'), B('e'), C('e'), e(x) { }
+  ~E() { }
+};
+
+class F : virtual public A, public D, public E {
+  char f;
+public:
+  F(char x) : A('f'), D('f'), E('f'), f(x) { }
+  ~F() { }
+};
+
+int main() {
+  F f('x');
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc1.C b/gcc/testsuite/g++.old-deja/g++.mike/misc1.C
new file mode 100644
index 00000000000..0604eac63ac
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc1.C
@@ -0,0 +1,53 @@
+// GROUPS passed construct-destruct
+/* g++ constructs j 13 times, and destructs it once. */
+
+extern "C" {
+  int printf(...);
+  void exit(int);
+}
+
+void foo() {
+}
+
+class C {
+  int val;
+ public:
+  static int count;
+  C(int ii) {
+    val = ii;
+    ++count;
+    printf("up\n");
+  }
+  ~C() {
+    --count;
+    printf("down\n");
+  }
+  int operator ++() {
+    return ++val;
+  }
+  operator int() {
+    return val;
+  }
+};
+
+int C::count = 0;
+
+void bar() {
+  for (int ii=0; ii<13; ++ii)
+    for (C j=1; j<9; ++j)
+      foo();
+}
+
+int main() {
+  bar();
+  if (C::count)
+    {
+      printf("FAIL\n");
+      exit(1);
+    }
+  else
+    {
+      printf("PASS\n");
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc11.C b/gcc/testsuite/g++.old-deja/g++.mike/misc11.C
new file mode 100644
index 00000000000..642fd2e474a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc11.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed pt coredump
+template<class T> class A;
+void f () { A<int> *a; }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc12.C b/gcc/testsuite/g++.old-deja/g++.mike/misc12.C
new file mode 100644
index 00000000000..b342bb5f6c9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc12.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+// GROUPS passed
+struct A { virtual void f(); }; 
+struct B { virtual void f() ; };
+struct C : virtual A , virtual B { virtual void f(); };
+
+/* This used to get an error because the DECL_CONTEXT was blown away. */
+void g(A *ptr) { ptr->f(); }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc13.C b/gcc/testsuite/g++.old-deja/g++.mike/misc13.C
new file mode 100644
index 00000000000..166e33dce6a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc13.C
@@ -0,0 +1,53 @@
+// GROUPS passed vtable
+extern "C" int printf(...);
+enum { vf_request, vf_event } want;
+
+int errs = 0;
+
+class ivResource {
+public:
+  virtual ~ivResource () { }
+};
+
+class ivHandler   : public ivResource   {
+public:
+  virtual void event() { }
+};
+
+class ivGlyph   : public ivResource   {
+public:
+  virtual ~ivGlyph  () { }
+  virtual void request () {
+    if (want!=vf_request)
+      ++errs;
+  }
+};
+
+class ItemView : public ivGlyph, public ivHandler {
+public:
+  virtual void event () {
+    if (want!=vf_event)
+      ++errs;
+  }
+} a;
+
+ivGlyph *bar() {
+  return &a;
+}
+
+ivHandler *bar2() {
+  return &a;
+}
+
+int main() {
+  want=vf_request;
+  bar()->request();
+  want=vf_event;
+  bar2()->event();
+  if (errs) {
+    printf("FAIL\n");
+    return 1;
+  }
+  printf("PASS\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc14.C b/gcc/testsuite/g++.old-deja/g++.mike/misc14.C
new file mode 100644
index 00000000000..4886dcc9274
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc14.C
@@ -0,0 +1,27 @@
+// GROUPS passed
+extern "C" int printf(...);
+extern "C" void exit(int);
+
+class A {
+public:
+  virtual ~A() {
+    printf("FAIL\n");
+    exit (1);
+  }
+};
+
+class B : public A {
+public:
+  virtual ~B() {
+    printf("PASS\n");
+    exit (0);
+  }
+};
+
+int main() {
+  B b;
+  A *ap = &b;
+  ap->~A();  // This should call the destructor virtually.
+  printf("FAIL\n");
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc2.C b/gcc/testsuite/g++.old-deja/g++.mike/misc2.C
new file mode 100644
index 00000000000..d916651e164
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc2.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// Special g++ Options: -ansi -pedantic
+// GROUPS passed
+/* -ansi -pedantic-errors should catch this. */
+
+class C {
+ public:
+  extern inline int A() {// ERROR - .*
+	return 1;
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc3.C b/gcc/testsuite/g++.old-deja/g++.mike/misc3.C
new file mode 100644
index 00000000000..5ac7a3b4884
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc3.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS uncaught
+int a;// ERROR - .*
+int a;// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc5.C b/gcc/testsuite/g++.old-deja/g++.mike/misc5.C
new file mode 100644
index 00000000000..a0761b24818
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc5.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS uncaught
+// Cfront bug A.3 (See Language System Release Notes for the
+// SPARCompiler C++ version 3.0)
+
+struct S1 {
+  static int S1;		// ERROR - uses same name 9.3
+};
+struct S2 {
+  union { int ii; float S2; };	// ERROR - uses same name 9.3
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc6.C b/gcc/testsuite/g++.old-deja/g++.mike/misc6.C
new file mode 100644
index 00000000000..e3697527dc9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc6.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS uncaught
+// Cfront bug A.4 (See Language System Release Notes for the
+// SPARCompiler C++ version 3.0)
+
+struct assign {
+  assign& operator = (const assign&);
+};
+union U {
+  assign a;	// ERROR - member of union cannot have op= 9.4// ERROR - .*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc7.C b/gcc/testsuite/g++.old-deja/g++.mike/misc7.C
new file mode 100644
index 00000000000..e613ad9e6ba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc7.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+// GROUPS passed MI
+struct S1 { };
+
+struct S2 : S1 { };
+struct S3 : S1 { };
+
+struct S4 : S3, S2 { };
+
+struct S1 *p1;
+struct S4 *p4;
+
+void foobar ()
+{
+  p1 = p4;		// ERROR - this is illegal// ERROR - .*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc8.C b/gcc/testsuite/g++.old-deja/g++.mike/misc8.C
new file mode 100644
index 00000000000..cf15c82c761
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc8.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed vtable
+class T { public: virtual ~T() {} };
+template<class P> class X : public virtual T {};
+int main() { X<int> x; }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/misc9.C b/gcc/testsuite/g++.old-deja/g++.mike/misc9.C
new file mode 100644
index 00000000000..ec02d1e63c1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/misc9.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+// Special g++ Options: -Wall -pedantic
+// GROUPS passed qualifiers
+class bee {
+ public:
+  int bee::bar;		// WARNING - there is an extra bee:: here
+};
+
+class foo {
+ public:
+  int bee::bar;		// ERROR - you cannot do this
+    int me();
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net1.C b/gcc/testsuite/g++.old-deja/g++.mike/net1.C
new file mode 100644
index 00000000000..9b2bbb835ff
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net1.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Here is a net bug
+
+class ivAllocation {
+public:
+  ivAllocation();
+  int x_;
+};
+
+class TBScrollBoxInfo {
+public:
+  ivAllocation allocation_;
+};
+
+TBScrollBoxInfo* items_;
+
+inline TBScrollBoxInfo item() {
+  return items_[0];
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net10.C b/gcc/testsuite/g++.old-deja/g++.mike/net10.C
new file mode 100644
index 00000000000..4546bf1bd0b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net10.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// Special g++ Options: -pedantic-errors
+
+const int ci=10, *pc = &ci, *const cpc = pc, **ppc;
+int i, *p, *const cp = &i;
+
+int main()
+{
+  i = ci;
+  *cp = ci;
+  pc++;
+  pc = cpc;
+  pc = p;
+  ppc = &pc;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net11.C b/gcc/testsuite/g++.old-deja/g++.mike/net11.C
new file mode 100644
index 00000000000..2030796a126
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net11.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// Special g++ Options: -pedantic-errors
+
+struct Foo {
+  char *p;
+  const char *q;
+  void m() const;
+};
+
+void other(char &x);
+
+void
+Foo::m() const
+{
+    other(*p);		// this is legal
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net12.C b/gcc/testsuite/g++.old-deja/g++.mike/net12.C
new file mode 100644
index 00000000000..b5fbf64ddec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net12.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// Special g++ Options: -pedantic-errors
+
+struct Foo {
+  char *p;
+  const char *q;
+  void m() const;
+};
+
+void other(char &x);	// ERROR - reference below
+
+void
+Foo::m() const
+{
+    other(*q);		// ERROR - this is bad
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net13.C b/gcc/testsuite/g++.old-deja/g++.mike/net13.C
new file mode 100644
index 00000000000..d56e87270e7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net13.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+// make sure extern "C" friends work.
+
+extern "C" { void func(); }
+
+struct crash {
+  int i;
+  friend void func();
+} a;
+
+void func() {
+  a.i = 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net14.C b/gcc/testsuite/g++.old-deja/g++.mike/net14.C
new file mode 100644
index 00000000000..4f32fdd52ea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net14.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// this probably does not have correct debugging info generated.
+
+typedef struct Thing {
+                Thing();
+        int     x;
+} Thing;
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net15.C b/gcc/testsuite/g++.old-deja/g++.mike/net15.C
new file mode 100644
index 00000000000..dfe4dc5e085
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net15.C
@@ -0,0 +1,46 @@
+// InterViews (ibuild) requires this to work.
+
+extern "C" void exit(int);
+
+void *old;
+
+class c1
+{
+  int i;
+public:
+  c1 () {}
+};
+
+class c2
+{
+  int j;
+public:
+  c2 () {}
+};
+
+class c3 : public c1, public c2
+{
+public:
+  c3 ()
+    {
+      old = this;
+      // printf("new object c3 at %x\n", (int)this); }
+    }
+};
+
+c2* f ()
+{
+  c2* n = new c3 ();
+  // printf ("new object c3 casted to c2 at %x\n", (int)n);
+  return n;
+}
+
+int main ()
+{
+  c3* o = (c3*)f ();
+  // printf("new object c3, upcasted from c2 at %x\n", (int)o);
+  // if old and o are not the same, fail the test case.
+  if (old != o)
+    exit(1);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net16.C b/gcc/testsuite/g++.old-deja/g++.mike/net16.C
new file mode 100644
index 00000000000..5da97a8607f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net16.C
@@ -0,0 +1,7 @@
+// On an i386, this core dumps because the reg-stack.c code is wrong, and
+// pops an fp register that it thinks is not used, but it is.
+
+extern "C" int printf (const char*, ...);
+struct S { ~S () { } };
+double f (S) { return 5; } 
+int main() { S s; double dist = f (s); printf ("%g\n", dist); return 0; }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net17.C b/gcc/testsuite/g++.old-deja/g++.mike/net17.C
new file mode 100644
index 00000000000..5befc4fd41f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net17.C
@@ -0,0 +1,58 @@
+// example from the ARM page 292 and 293
+
+extern "C" int printf(const char *, ...);
+extern "C" void exit(int);
+
+int i = 0;
+
+class A {
+public:
+  A() {
+    printf("Doing A\n");
+    if (++i != 1)
+      exit(1);
+  }
+};
+
+class B {
+public:
+  B() {
+    printf("Doing B\n");
+    if (++i != 2)
+      exit(1);
+  }
+};
+
+class C : public virtual A, public virtual B {
+public:
+  C() {
+    printf("Doing C\n");
+    if (++i != 3)
+      exit(1);
+  }
+};
+
+class D : public virtual B, public virtual A {
+public:
+  D() {
+    printf("Doing D\n");
+    if (++i != 4)
+      exit(1);
+  }
+};
+
+class E : public C, public D {
+public:
+  E() {
+    printf("Doing E\n");
+    if (++i != 5)
+      exit(1);
+  }
+} e;
+
+
+int main() {
+  if (++i != 6)
+    exit(1);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net18.C b/gcc/testsuite/g++.old-deja/g++.mike/net18.C
new file mode 100644
index 00000000000..81e38d370e3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net18.C
@@ -0,0 +1,21 @@
+// Build don't link:
+
+class ClassA {
+public:
+  typedef ClassA& (*PMFV)(const char*);
+  static PMFV setMapper(PMFV);
+  static PMFV _mapper;
+};
+
+class ClassB {
+public:
+  typedef ClassB& (*PMFV)(const char*);
+};
+
+ClassA::PMFV ClassA::setMapper(ClassA::PMFV newFunc)
+{
+  PMFV oldFunc = _mapper;
+  _mapper = newFunc;
+
+  return oldFunc;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net19.C b/gcc/testsuite/g++.old-deja/g++.mike/net19.C
new file mode 100644
index 00000000000..68c47533a68
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net19.C
@@ -0,0 +1,20 @@
+// Test to make sure &<incomplete record type> works in c++
+// Build don't link:
+
+struct FILE {
+    int _flags;          
+};
+
+extern struct _fake_filebuf __std_filebuf_2;
+
+class Value {
+  int  width;                    
+public:
+  Value();                       
+  friend Value    operator&(    __const  Value&,        __const  Value&);
+};
+
+FILE* Foo ()
+{
+        return ((FILE*)&__std_filebuf_2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net2.C b/gcc/testsuite/g++.old-deja/g++.mike/net2.C
new file mode 100644
index 00000000000..ffc14ef2115
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net2.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// Here is another program from the net.
+
+class B;
+
+class A {
+  private:
+    A(B *);			// ERROR - 
+  public:
+    A(long);			// ERROR - 
+};
+
+A a(0); // ERROR - should be ambigious
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net20.C b/gcc/testsuite/g++.old-deja/g++.mike/net20.C
new file mode 100644
index 00000000000..916ba434b37
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net20.C
@@ -0,0 +1,11 @@
+// Build don't link:
+// A pointer to member function test case.
+
+struct X
+{
+};
+
+void (X::* fee ())()
+{
+ lab: goto lab;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net21.C b/gcc/testsuite/g++.old-deja/g++.mike/net21.C
new file mode 100644
index 00000000000..02e40b0b935
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net21.C
@@ -0,0 +1,59 @@
+// Make sure we can initialize complex (MI ambiguous) vtables.
+
+extern "C" int printf(const char *, ...);
+
+struct a
+{
+    virtual void f() = 0;
+};
+
+struct b
+{
+    virtual void g() { };
+};
+
+struct c: public a, public b
+{
+    virtual void f();
+    virtual void g();
+};
+
+void c::f()
+{
+    printf("c::f()\n");
+}
+
+void c::g()
+{
+    printf("c::g()\n");
+}
+
+struct e: public b
+{
+};
+
+struct h
+{
+};
+
+struct d: public c, public e, public h
+{
+    virtual void f();
+    virtual void g();
+};
+void d::f()
+{
+    printf("d::f()\n");
+}
+
+void d::g()
+{
+    printf("d::g()\n");
+}
+
+int main(int argc, char* argv[])
+{
+    a* tmp = new d;
+    tmp->f();
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net22.C b/gcc/testsuite/g++.old-deja/g++.mike/net22.C
new file mode 100644
index 00000000000..f18d0563f9f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net22.C
@@ -0,0 +1,13 @@
+class Parent {
+public:
+  Parent() {}
+  Parent( char *s ) {}
+};
+
+class Child : public Parent {
+};				// ERROR - called
+
+int main() {
+  Child c( "String initializer" );	// ERROR - bad
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net23.C b/gcc/testsuite/g++.old-deja/g++.mike/net23.C
new file mode 100644
index 00000000000..2fe7d4c8c01
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net23.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+class environment {
+public:
+  int get_font() ;
+};
+
+typedef int (environment::*INT_FUNCP)();
+
+void myfoo(INT_FUNCP a);
+
+void init_env_requests()
+{
+  myfoo(&environment::get_font);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net24.C b/gcc/testsuite/g++.old-deja/g++.mike/net24.C
new file mode 100644
index 00000000000..682fb08b17a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net24.C
@@ -0,0 +1,3 @@
+// Build don't link:
+
+    char HexDigit(unsigned char ch) { return ch < 'f'; }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net25.C b/gcc/testsuite/g++.old-deja/g++.mike/net25.C
new file mode 100644
index 00000000000..56356779042
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net25.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+void shake_zero()
+{
+}
+
+void shake_one()
+{
+}
+
+void (*foo)();
+
+int main(int a)
+{
+  foo = a ? shake_zero : shake_one;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net26.C b/gcc/testsuite/g++.old-deja/g++.mike/net26.C
new file mode 100644
index 00000000000..753c5f6cd2b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net26.C
@@ -0,0 +1,27 @@
+// A test case found by InterViews testing...
+
+extern "C" int printf(const char *, ...);
+
+class A {
+public:
+	int foo() { printf("ok nv\n"); }
+	virtual int vfoo() { printf("ok v\n"); }
+};
+
+struct S {
+	int (A::*pfn1)();
+	int (A::*pfn2)();
+	int (A::*pfn3)();
+};
+
+// This failed before.
+S s = { &A::foo, &A::vfoo, &A::foo };
+
+A a;
+
+int main() {
+  (a.*s.pfn1)();
+  (a.*s.pfn2)();
+  printf("PASS\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net27.C b/gcc/testsuite/g++.old-deja/g++.mike/net27.C
new file mode 100644
index 00000000000..afe975cc44f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net27.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+class path {
+public:
+        path (const path& r)
+            { "\"";
+	      '\'';
+            }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net28.C b/gcc/testsuite/g++.old-deja/g++.mike/net28.C
new file mode 100644
index 00000000000..3b724820fbd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net28.C
@@ -0,0 +1,28 @@
+// From reinhard@ifki50.informatik.fh-muenchen.de against gcc 2.5.0.
+// shows an InterViews problem on RS6000 and i386.  Doesn't happen on
+// SPARC.
+
+// From fbrowser.c.
+
+// Build don't link:
+
+class test {
+};
+
+
+typedef int ( test    ::*   test2)(int fd);
+
+class    ivFileBrowserImpl_IOCallback
+{
+ public:
+
+ int inputReady(int fd);
+  test    * _obj;
+  test2   _input;
+}; 
+
+
+int    ivFileBrowserImpl_IOCallback  ::inputReady(int fd)
+{
+        return (_obj->*_input)(fd);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net29.C b/gcc/testsuite/g++.old-deja/g++.mike/net29.C
new file mode 100644
index 00000000000..6635241eb89
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net29.C
@@ -0,0 +1,27 @@
+// This is a test case for the recent libg++ make check problem.
+// Build don't link:
+
+class SubString {
+public:
+  SubString();
+  SubString(const SubString& x);
+};
+
+class String {
+public:
+  String();
+  String(const SubString&  x);
+};
+
+int operator!=(const String& x, const SubString&  y);
+int operator!=(const String& x, const String& y);
+
+int operator!=(const SubString& x, const String& y);
+int operator!=(const SubString& x, const SubString&  y);
+
+void comparetest()
+{  
+  String x;
+  SubString s;
+  x != s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net3.C b/gcc/testsuite/g++.old-deja/g++.mike/net3.C
new file mode 100644
index 00000000000..e6dbdcbe786
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net3.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// Here is another program from the net.
+
+class BOOL {
+ public:
+  int val;
+  
+  BOOL(int i =0);
+  operator int();
+};
+
+BOOL& foo()
+{
+  static BOOL status;
+  return status;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net30.C b/gcc/testsuite/g++.old-deja/g++.mike/net30.C
new file mode 100644
index 00000000000..52f7b28fe24
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net30.C
@@ -0,0 +1,18 @@
+// Build don't link:
+
+class X {
+public:
+  void x(void);
+};
+
+class Y : public X {
+};
+
+class Z : private Y {
+public:
+  void y(void);
+};
+
+void Z::y(void) {
+  x();  // should be OK
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net31.C b/gcc/testsuite/g++.old-deja/g++.mike/net31.C
new file mode 100644
index 00000000000..3ecf81c7349
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net31.C
@@ -0,0 +1,68 @@
+// Build don't link:
+
+class foo_a {
+  protected:
+        double func(int xi) {return 0.0;}
+  public:
+        foo_a() {}
+};
+
+class foo_b {
+  public:
+        foo_b(int);
+        foo_b();
+        ~foo_b();
+        foo_b(const foo_b&);
+        inline double& operator()(int);
+        foo_b& operator=(foo_b&);
+        void bar_a(int);
+};
+
+foo_b& operator*(foo_b&, foo_b&);
+foo_b& operator*(double, foo_b&);
+
+template <class TP>
+class foo_c {
+        typedef double (TP::* Tmatf)(int);
+        int m;
+        Tmatf* a;
+        void foo_cinst (int mm);
+  public:
+        foo_c(int mm);
+        foo_c() {m = 0; a = 0;}
+        ~foo_c() {delete a;}
+        double (TP::*& operator()(int i))(int) {return a[i];}
+        foo_b& bug_func(int);
+};
+
+template <class TP>
+foo_b& foo_c<TP>::bug_func(int x) {
+        static foo_b retval(m);
+        retval.bar_a(m);
+        for (register int i = 0; i < m; i++)
+	  retval(i) = (*(operator()(i)))(x);		// ERROR - 
+        return retval;
+}
+
+template <class TP>
+class foo_d {
+  protected:
+        foo_c<TP> bar_b;
+  public:
+        foo_d() {}
+        virtual ~foo_d() {}
+        virtual void setfoo_c();
+};
+
+class foo_e : public foo_a, public foo_d<foo_a> {
+  public:
+        foo_e();
+        ~foo_e() {}
+        void setfoo_c();
+};
+
+void foo_e::setfoo_c() {
+        bar_b(0) = func;				// ERROR - 
+}
+
+template class foo_c<foo_a>;
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net32.C b/gcc/testsuite/g++.old-deja/g++.mike/net32.C
new file mode 100644
index 00000000000..4ac8a94816f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net32.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+class Co_obj {
+public:
+   Co_obj() {}
+ };
+class Linear_list_node : virtual public Co_obj { };
+class M1 : public Linear_list_node { };
+class M2 : public Linear_list_node { };
+class New_node : public M1, public M2 { };
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net34.C b/gcc/testsuite/g++.old-deja/g++.mike/net34.C
new file mode 100644
index 00000000000..51266a35d48
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net34.C
@@ -0,0 +1,36 @@
+#include <iostream.h>
+
+class foo {
+public:
+        foo(int i) {k = i;}
+protected:
+        int k;
+};
+
+class bar_1 : public foo {
+public:
+        bar_1(int i) : foo(i) {}
+        int get_k() {return k;}
+};
+
+class bar_2 : public foo {
+public:
+    bar_2(int i) : foo(i) {};
+        int get_k() {return k;}
+};
+
+class multiple : public bar_1, public bar_2 {
+public:
+        multiple(int i1, int i2) : bar_1(i1), bar_2(i2) {}
+        void print() {
+                cout << "bar_1::k -> " << bar_1::k << "\n";
+                cout << "bar_2::k -> " << bar_2::k << "\n";
+                cout << "bar_1::get_k() -> " << bar_1::get_k() << "\n";
+                cout << "bar_2::get_k() -> " << bar_2::get_k() << "\n";
+        }
+};
+
+int main() {
+        multiple m(1,2);
+        m.print();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net35.C b/gcc/testsuite/g++.old-deja/g++.mike/net35.C
new file mode 100644
index 00000000000..332bf429f3e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net35.C
@@ -0,0 +1,27 @@
+extern "C" int printf(const char *, ...);
+
+class A {
+ public:
+   char *x;
+};
+
+class B1:public virtual A { };
+
+class B2:public virtual A { };
+
+class C:public B1, public B2 {
+public:
+  C() { }
+};
+
+int main() {
+  C c;
+  printf("&c.x = %x\n", &c.x);
+  printf("&c.B1::x = %x\n", &c.B1::x);
+  printf("&c.B2::x = %x\n", &c.B2::x);
+  printf("&c.A::x = %x\n", &c.A::x);
+  if (&c.x != &c.B1::x
+      || &c.x != &c.B2::x
+      || &c.x != &c.A::x)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net36.C b/gcc/testsuite/g++.old-deja/g++.mike/net36.C
new file mode 100644
index 00000000000..843c31421ad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net36.C
@@ -0,0 +1,19 @@
+// Build don't link:
+
+class X;
+
+class A {
+public:
+  void handlerFn(X*);
+};
+
+typedef void (A::*handler) (X*);
+
+class B {
+public:
+  void setHandler(handler);
+};
+
+void f(B* b) {
+  b->setHandler(A::handlerFn);	// ERROR - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net37.C b/gcc/testsuite/g++.old-deja/g++.mike/net37.C
new file mode 100644
index 00000000000..1ce7834a5e2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net37.C
@@ -0,0 +1,39 @@
+class B {
+public:
+    int bi;
+    void bProc ( void ) { bi = 39; }
+  };
+
+class D : public B {
+public:
+    int di;
+    void dProc (void ){ di = 42; }
+  };
+
+typedef void (B::*BPROC)(void);
+typedef void (D::*DPROC)(void);
+
+union AFX_PMSG {
+public:
+
+  AFX_PMSG () {};
+  AFX_PMSG ( BPROC bpr ) { bfn = bpr ; }
+
+  operator BPROC() { return bfn; }
+
+  BPROC bfn;
+  DPROC dfn;
+};
+
+
+int main(int argc, char *argv[]) {
+  B b;
+  D d;
+
+  BPROC    bpr = &B::bProc;
+  AFX_PMSG pmsg(bpr);
+
+  BPROC ppr = pmsg;
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net38.C b/gcc/testsuite/g++.old-deja/g++.mike/net38.C
new file mode 100644
index 00000000000..2b7c0c4f940
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net38.C
@@ -0,0 +1,28 @@
+struct A {
+  virtual int a ()       { return 0; }
+};
+
+struct B {
+  virtual int b ()       { return 0; }
+  virtual int b2 ()      { return 0; }
+};
+
+struct C : public A, public B {
+  virtual int a ()       { return 1; }
+  virtual int b ()       { return 2; }
+  virtual int b2 ()      { return 3; }
+};
+
+int (C::*vmpb) () = &C::b;
+int (C::*vmpb2) () = &C::b2;
+int (C::*vmpa) () = &C::a;
+
+int main () {
+  C c;
+  if ((c.*vmpa)() != 1)
+    return 1;
+  if ((c.*vmpb)() != 2)
+    return 1;
+  if ((c.*vmpb2)() != 3)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net39.C b/gcc/testsuite/g++.old-deja/g++.mike/net39.C
new file mode 100644
index 00000000000..00ad1c6bc02
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net39.C
@@ -0,0 +1,30 @@
+void *vp;
+
+class silly {
+public:
+  virtual int b() { return 1; }
+};
+class solly : silly {
+public:
+  virtual int b() { return 2; }
+};
+class thing {
+public:
+  virtual int a() { return 3; }
+};
+class thong : public solly, public thing {
+public:
+  virtual int a() {
+    if (this != vp) return 4;
+    else return 0;
+  }
+};
+
+typedef int(thing::*ping)();
+ping qq = &thing::a;
+
+int main() {
+  thong b;
+  vp = &b;
+  return (b.*qq)();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net4.C b/gcc/testsuite/g++.old-deja/g++.mike/net4.C
new file mode 100644
index 00000000000..4cf8e7a1387
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net4.C
@@ -0,0 +1,32 @@
+// Message-Id: <m0lLuUK-0000fRC@nix.appli.se>
+// Date: Wed, 4 Mar 92 12:50 MET
+// From: niklas@appli.se (Niklas Hallqvist)
+// To: eichin@cygnus.com, tiemann@cygnus.com
+// Cc: gcc2@cygnus.com
+// Subject: nested type handling
+// 
+// The last couple of days I've been struggling with nested types in the
+// C++ compiler.  Frankly, it's a mess!  Was it impossible to put the stuff
+// into the parser instead of the lexer?  Well, anyway, to get the following
+// code to compile:
+// 
+// struct O {
+//   struct M {
+//     struct I
+//       {};
+//   };
+// };
+// O::M::I s;
+// 
+// a patch enclosed below is needed.  I'm not sure if it causes any
+// unanticipated side-effects, but it seem to work well for me.
+
+// Build don't link:
+
+struct O {
+  struct M {
+    struct I
+      {};
+  };
+};
+O::M::I s;
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net40.C b/gcc/testsuite/g++.old-deja/g++.mike/net40.C
new file mode 100644
index 00000000000..10e16e685b7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net40.C
@@ -0,0 +1,18 @@
+#include <stddef.h>
+extern "C" void abort();
+
+class toto {
+public:
+  void * operator new (size_t t) {
+    abort();
+  }
+  void operator delete (void*p, size_t t) {
+    abort();
+  }
+};
+
+int main() {
+  toto * p;
+  p = new toto[5];
+  delete [] p;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net41.C b/gcc/testsuite/g++.old-deja/g++.mike/net41.C
new file mode 100644
index 00000000000..2c29e9b4410
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net41.C
@@ -0,0 +1,3 @@
+int main() {
+  int i = ~ false;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net42.C b/gcc/testsuite/g++.old-deja/g++.mike/net42.C
new file mode 100644
index 00000000000..178a0bbf5ec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net42.C
@@ -0,0 +1,25 @@
+// Build don't link:
+
+typedef void (*__sighandler_t)(int);
+
+struct sigaction {
+  __sighandler_t sa_handler;
+};
+
+struct task_struct {
+  struct sigaction sigaction[32];
+};
+
+void
+get_stat() {
+  struct task_struct ** p = 0;
+  unsigned long bit = 1;
+  unsigned long sigignore = 0;
+  int i = 0;
+  switch((unsigned long) (*p)->sigaction[i].sa_handler)
+    {
+    case 1:
+      sigignore |= bit;
+      break;
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net43.C b/gcc/testsuite/g++.old-deja/g++.mike/net43.C
new file mode 100644
index 00000000000..3a34c8f7e2f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net43.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+class foo {
+ public:
+   friend int operator ^(const foo&, const foo&);
+};
+
+int main ()
+{
+   int (*funptr) (const foo &, const foo &)  = operator ^;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net44.C b/gcc/testsuite/g++.old-deja/g++.mike/net44.C
new file mode 100644
index 00000000000..5b6a0ad4bfe
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net44.C
@@ -0,0 +1,11 @@
+// Make sure we don't dump core
+
+enum request { q, w, e};		// ERROR - 
+
+class request {				// ERROR - 
+public:
+  int a;
+  request( int b) {
+    a = b;
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net45.C b/gcc/testsuite/g++.old-deja/g++.mike/net45.C
new file mode 100644
index 00000000000..388af8fe82f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net45.C
@@ -0,0 +1,20 @@
+// Build don't link:
+
+template <class T1, class T2>
+struct pair {
+    T1 first;
+    T2 second;
+    pair(const T1& a, const T2& b) : first(a), second(b) {}
+};
+
+struct myint {
+  myint() {
+  }
+  myint(const myint& mi) {
+  }
+  myint& operator=(const myint& mi) {
+  }
+};
+
+extern pair<const myint, myint> a;
+pair<const myint, myint> b(a);
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net46.C b/gcc/testsuite/g++.old-deja/g++.mike/net46.C
new file mode 100644
index 00000000000..ac7950117f9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net46.C
@@ -0,0 +1,16 @@
+#include <iostream.h>
+#include <stddef.h>
+#include <new>
+
+int fail = 1;
+
+static void *operator new(size_t size) throw (std::bad_alloc) {
+  --fail;
+  return (void*) 0;
+}
+
+int main() {
+  cout << "";
+  new int;
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net47.C b/gcc/testsuite/g++.old-deja/g++.mike/net47.C
new file mode 100644
index 00000000000..fc4a81f1266
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net47.C
@@ -0,0 +1,8 @@
+// Build don't link:
+// Special g++ Options: -w -fpermissive
+
+class foo {};
+class bar : foo {
+public:
+  bar () : () {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net48.C b/gcc/testsuite/g++.old-deja/g++.mike/net48.C
new file mode 100644
index 00000000000..a2d674383b6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net48.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+char *a="aê";
+
+class A
+{
+public:
+	A()
+	{
+		char *b="aê";
+	}
+};
+
+char *c="aê";
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net5.C b/gcc/testsuite/g++.old-deja/g++.mike/net5.C
new file mode 100644
index 00000000000..e9144320479
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net5.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// Special g++ Options:
+
+volatile void abort();
+volatile void oink() {
+  abort() ;
+}				// gets bogus error - 
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net6.C b/gcc/testsuite/g++.old-deja/g++.mike/net6.C
new file mode 100644
index 00000000000..6a3aef1d919
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net6.C
@@ -0,0 +1,5 @@
+// Build don't link:
+// Special g++ Options:
+
+struct X {};
+X x = X();		// gets bogus error
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net7.C b/gcc/testsuite/g++.old-deja/g++.mike/net7.C
new file mode 100644
index 00000000000..14655028ea7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net7.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// Special g++ Options:
+
+// This should compile.
+
+int foo (signed char *);
+int foo (char *);
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net8.C b/gcc/testsuite/g++.old-deja/g++.mike/net8.C
new file mode 100644
index 00000000000..12823175a24
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net8.C
@@ -0,0 +1,32 @@
+// Build don't link:
+// Special g++ Options: -pedantic-errors
+
+class Base {
+public:
+  int foo;
+};
+
+class Derived : public Base {
+public:
+  int bar;
+};
+
+void func(Base&);		// ERROR - 
+
+void func2(const Derived& d) {
+  func(d);			// ERROR - this is bad
+}
+
+void
+foo (int& a)
+{				// ERROR - 
+}
+
+int main ()
+{
+  int b;
+  const int*const a = &b;
+  *a = 10;				// ERROR - it's const
+  foo (*a);				// ERROR - it's const
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/net9.C b/gcc/testsuite/g++.old-deja/g++.mike/net9.C
new file mode 100644
index 00000000000..7d876dc95f4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/net9.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// Special g++ Options: -pedantic-errors
+
+const int ci=10, *pc = &ci, *const cpc = pc, **ppc;
+int i, *p, *const cp = &i;
+
+int main()
+{
+  ci = 1;	// ERROR - bad
+  ci++;		// ERROR - bad
+  *pc = 2;	// ERROR - bad
+  cp = &ci;	// ERROR - bad
+  cpc++;	// ERROR - bad
+  p = pc;	// ERROR - bad
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns1.C b/gcc/testsuite/g++.old-deja/g++.mike/ns1.C
new file mode 100644
index 00000000000..c347d2d93a4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns1.C
@@ -0,0 +1,11 @@
+namespace Foo {
+  int bar() {
+    return 0;
+  }
+}
+
+using namespace Foo;
+
+int main() {
+  bar();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns10.C b/gcc/testsuite/g++.old-deja/g++.mike/ns10.C
new file mode 100644
index 00000000000..a6b1c3aedd3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns10.C
@@ -0,0 +1,9 @@
+namespace Foo {
+  int bar() {
+    return 0;
+  }
+}
+
+int main() {
+  return Foo::bar();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns11.C b/gcc/testsuite/g++.old-deja/g++.mike/ns11.C
new file mode 100644
index 00000000000..bde7723bd7c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns11.C
@@ -0,0 +1,18 @@
+class Foo {
+};
+
+namespace A {
+  namespace Foo {
+    int bar() {
+      return 0;
+    }
+  }
+
+  int mymain() {
+    return Foo::bar();
+  }
+}
+
+int main() {
+  return A::mymain();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns12.C b/gcc/testsuite/g++.old-deja/g++.mike/ns12.C
new file mode 100644
index 00000000000..38978109623
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns12.C
@@ -0,0 +1,14 @@
+namespace {
+  int i = 10;
+  enum fish { one = 1, two = 2, red = 3, blue = 4 };
+}
+extern "C" void printf (const char *, ...);
+int main(void)
+{
+  if (i != 10) {
+    return 1;
+  }
+  if (one != 1) {
+    return 2;
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns13.C b/gcc/testsuite/g++.old-deja/g++.mike/ns13.C
new file mode 100644
index 00000000000..5482a43c72f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns13.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+namespace N {
+  struct C {
+    C();
+  };
+}
+
+namespace M {
+  struct C {
+    C();
+  };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns14.C b/gcc/testsuite/g++.old-deja/g++.mike/ns14.C
new file mode 100644
index 00000000000..3c3ad3fc20b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns14.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+namespace Jazz {
+  int horn( int h ) { return 1; }
+}
+
+using Jazz::horn;
+
+namespace Jazz {
+  int horn ( char c ) { return 0; }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns15.C b/gcc/testsuite/g++.old-deja/g++.mike/ns15.C
new file mode 100644
index 00000000000..39440526190
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns15.C
@@ -0,0 +1,31 @@
+// Build don't link:
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define MAX 256
+#define MAXSTATE 1000000
+
+struct R {
+  int count;
+  int state1;
+  int state2;
+};
+
+int cmp_d(const R* a, const R* b) {
+  return a->count > b->count;
+}
+
+namespace CXX {
+  template<class T, int i1, int i2>
+    inline void qsort (T b[i1][i2], int (*cmp)(const T*, const T*)) {
+    ::qsort ((void*)b, i1*i2, sizeof(T), (int (*)(const void *, const void *))cmp);
+  }
+}
+
+using namespace CXX;
+
+void sort_machine() {
+  struct R d[MAX][MAX];
+  qsort<R,MAX> (d, cmp_d);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns2.C b/gcc/testsuite/g++.old-deja/g++.mike/ns2.C
new file mode 100644
index 00000000000..365eb8c0923
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns2.C
@@ -0,0 +1,9 @@
+namespace N {
+  int i;
+};
+
+using namespace N;
+
+int main() {
+  return i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns3.C b/gcc/testsuite/g++.old-deja/g++.mike/ns3.C
new file mode 100644
index 00000000000..77da5af7f1c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns3.C
@@ -0,0 +1,4 @@
+int i;		// ERROR - 
+
+namespace i {	// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns4.C b/gcc/testsuite/g++.old-deja/g++.mike/ns4.C
new file mode 100644
index 00000000000..7c359cf5c03
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns4.C
@@ -0,0 +1,6 @@
+// Build don't link:
+
+namespace i {
+}
+namespace i {
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns5.C b/gcc/testsuite/g++.old-deja/g++.mike/ns5.C
new file mode 100644
index 00000000000..d138ff3c8fb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns5.C
@@ -0,0 +1,5 @@
+namespace A {
+  int i = 1;
+}
+
+int j = i;		// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns6.C b/gcc/testsuite/g++.old-deja/g++.mike/ns6.C
new file mode 100644
index 00000000000..dc082472ada
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns6.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+namespace A {
+  int i = 1;
+}
+
+namespace A {
+  int j = i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns7.C b/gcc/testsuite/g++.old-deja/g++.mike/ns7.C
new file mode 100644
index 00000000000..ff7cda6e5ab
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns7.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+namespace A {
+  int i = 1;
+}
+
+namespace B {
+  int j = i;	// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns8.C b/gcc/testsuite/g++.old-deja/g++.mike/ns8.C
new file mode 100644
index 00000000000..dc082472ada
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns8.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+namespace A {
+  int i = 1;
+}
+
+namespace A {
+  int j = i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ns9.C b/gcc/testsuite/g++.old-deja/g++.mike/ns9.C
new file mode 100644
index 00000000000..8d640e70fed
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ns9.C
@@ -0,0 +1,11 @@
+namespace Foo {
+  int bar() {
+    return 0;
+  }
+}
+
+using Foo::bar;
+
+int main() {
+  return bar();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/offset1.C b/gcc/testsuite/g++.old-deja/g++.mike/offset1.C
new file mode 100644
index 00000000000..6a259d8967a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/offset1.C
@@ -0,0 +1,38 @@
+extern "C" int printf(const char *, ...);
+void *vp;
+int fail = 0;
+
+class Foo {
+public:
+   virtual void setName() {
+     printf("Foo at %x\n", this);
+     if (vp != (void*)this)
+       fail = 1;
+   }
+};
+
+class Bar : public Foo {
+public:
+  virtual void init(int argc, char **argv) {
+    printf("Bar's Foo at %x\n", (Foo*)this);
+    vp = (void*)(Foo*)this;
+    setName();
+  }
+};
+
+class Barf : virtual public Bar {
+public:
+  virtual void init(int argc, char **argv) { Bar::init(argc, argv); }
+};
+
+class Baz : virtual public Bar, virtual public Barf {
+public:
+  virtual void init(int argc, char **argv) { Barf::init(argc, argv); }
+};
+
+Bar *theBar = new Baz();
+
+int main(int argc, char **argv) {
+   theBar->init(argc, argv);
+   return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/opr-as1.C b/gcc/testsuite/g++.old-deja/g++.mike/opr-as1.C
new file mode 100644
index 00000000000..935b0bac85c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/opr-as1.C
@@ -0,0 +1,11 @@
+// Shows a problem with the default op= not being an implementation...
+
+class C {
+  int i;
+};
+
+C a, b;
+
+int main() {
+  a = b;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/opr-dot1.C b/gcc/testsuite/g++.old-deja/g++.mike/opr-dot1.C
new file mode 100644
index 00000000000..acef6ad9c2b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/opr-dot1.C
@@ -0,0 +1,22 @@
+// Build don't link:
+
+typedef struct base1 {
+  int x;
+} base1_t;
+
+typedef struct base2 {
+  int x;
+} base2_t;
+
+class derived1 : public base1 {
+};
+
+class derived2 : public derived1, public base2 {
+};
+
+struct test {
+  derived2& fails;
+  void test1() {
+    fails.base1::x = 5;
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p10148.C b/gcc/testsuite/g++.old-deja/g++.mike/p10148.C
new file mode 100644
index 00000000000..074724a5646
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p10148.C
@@ -0,0 +1,33 @@
+// prms-id: 10148
+
+int fail = 1;
+void ok() { fail = 0; }
+
+class TC {
+  int s_;
+};
+
+class TIRD {
+ public:
+  void (*itc)();
+  TIRD() { itc = ok; }
+};
+
+class TCCB : public TC, public TIRD {
+};
+
+class TCRCB : public TCCB {
+public:
+  virtual void eat ();
+};
+
+void TCRCB::eat () {
+ void *vp = (TIRD*)this->itc;
+ this->itc();
+}
+
+int main() {
+  TCRCB a;
+  a.eat();
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p10247.C b/gcc/testsuite/g++.old-deja/g++.mike/p10247.C
new file mode 100644
index 00000000000..c69bc90afdf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p10247.C
@@ -0,0 +1,6 @@
+// prms-id: 10247
+
+class a {
+public:
+  int operator++(int) { return operator()++ ; }		// ERROR - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p10416.C b/gcc/testsuite/g++.old-deja/g++.mike/p10416.C
new file mode 100644
index 00000000000..aa56b5ffc2a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p10416.C
@@ -0,0 +1,9 @@
+// Build don't link:
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe*
+// prms-id: 10416
+
+class not_ok {
+public:
+  void f() throw(int) { }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p10511.C b/gcc/testsuite/g++.old-deja/g++.mike/p10511.C
new file mode 100644
index 00000000000..b92b4f7d7fd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p10511.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// prms-id: 10511
+
+class S {
+public:
+  enum E {a, b, c};
+};
+
+class C {
+public:
+  bool f (S::E()) { }
+  virtual void foo();
+};
+
+void C::foo() { }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p10769a.C b/gcc/testsuite/g++.old-deja/g++.mike/p10769a.C
new file mode 100644
index 00000000000..f5ff345a3fd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p10769a.C
@@ -0,0 +1,45 @@
+// Special g++ Options: -Wno-pmf-conversions
+// prms-id: 10769
+
+#define PMF2PF(PMF) ((void (*)())(PMF))
+
+int ok = 0;
+
+class A {
+public:
+  void f1a() { ok += 3; }
+  void f1b() { ok += 5; }
+  void f2a() { ok += 7; }	// gets bogus error XFAIL *-*-*
+  void f2b() { }
+  const static void (*table[2][2])();
+  void main();
+} a;
+
+const void (*A::table[2][2])()
+  = { { PMF2PF(&A::f1a), PMF2PF(&A::f1b) },
+      { PMF2PF(&A::f2a), PMF2PF(&A::f1b) },
+  };
+
+void
+dispatch (A *obj, int i, int j)
+{
+  (*(void (*)(A *))A::table[i][j])(obj);
+}
+
+void A::main() {
+  dispatch (&a, 0, 0);
+  void (A::*mPtr)() = &A::f1a;
+
+  (*(void (*)(A*))PMF2PF(mPtr))(&a);
+  (*(void (*)(A*))PMF2PF(f2a))(&a); // gets bogus error XFAIL *-*-*
+}
+
+int main() {
+  a.A::main();
+  dispatch (&a, 0, 1);
+  void (A::*mPtr)() = &A::f1b;
+
+  (*(void (*)(A*))PMF2PF(a.*mPtr))(&a);
+  (*(void (*)(A*))PMF2PF(a.f2a))(&a); // gets bogus error XFAIL *-*-*
+  return ok != 3+3+5+5+7+7;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p10769b.C b/gcc/testsuite/g++.old-deja/g++.mike/p10769b.C
new file mode 100644
index 00000000000..c9f859d9319
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p10769b.C
@@ -0,0 +1,25 @@
+// Special g++ Options: 
+// prms-id: 10769
+
+#define PMF2PF(PMF) ((void (*)())(PMF))
+
+class A {
+public:
+  void f1a() { }
+  void main();
+} a;
+
+class B {
+public:
+  void bf1() { }
+} b;
+
+void A::main() {
+  void (B::*mPtrB)(B*);
+  (*(void (*)(A*))PMF2PF(mPtrB))(&b);	// ERROR - 
+}
+
+int main() {
+  void (A::*mPtr)() = &A::f1a;
+  (*(void (*)(A*))PMF2PF(mPtr))(&a);	// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p10849a.C b/gcc/testsuite/g++.old-deja/g++.mike/p10849a.C
new file mode 100644
index 00000000000..d6d46569b87
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p10849a.C
@@ -0,0 +1,33 @@
+// prms-id: 10849
+
+struct A
+{
+  int comm;
+  A(int i) : comm(i) { }
+};
+
+struct S1 { char c1; };
+
+struct B : public S1, public A
+{
+  B(int i) : A(i) { }
+};
+
+struct C : public A
+{
+  C(int i) : A(i) { }
+};
+
+struct D : public B, public C
+{
+  virtual int g() {
+    int D::*pmd = (int C::*)&C::comm;
+    return (this->*pmd) == 42;
+  }
+  D() : B(41), C(42) { }
+} d;
+
+int main() {
+  if (! d.g())
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p10951.C b/gcc/testsuite/g++.old-deja/g++.mike/p10951.C
new file mode 100644
index 00000000000..d53775fecc4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p10951.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// prms-id: 10951
+
+inline int m1(const int& a) {
+  return 1;
+}
+
+template <class T>
+class A {
+public:
+  typedef int st;
+
+  static int m2t() {
+    return m1(1);
+  }
+};
+
+A<int>::st i;
+int m3() {
+  return A<int>::m2t();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p11012.C b/gcc/testsuite/g++.old-deja/g++.mike/p11012.C
new file mode 100644
index 00000000000..aca77d42607
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p11012.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Special g++ Options: -Wno-pmf-conversions
+// prms-id: 11012
+
+class Foo {
+public:
+  int f(){}
+};
+
+void foo() {
+  void *p1 = &Foo::f;
+  const void *p2 = &Foo::f;
+  int (*p3)() = &Foo::f;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p11110.C b/gcc/testsuite/g++.old-deja/g++.mike/p11110.C
new file mode 100644
index 00000000000..428486a5042
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p11110.C
@@ -0,0 +1,20 @@
+// prms-id: 11110
+
+class data;
+
+class conatiner {
+public:
+  virtual void* first    ();
+  virtual data* contents (void* i);     // ERROR - candidates
+};
+
+class user {
+public:
+  data* data1 () const;
+private:
+  conatiner& _c;
+};
+
+data* user::data1() const {
+  return (_c.contents (_c.first));	// ERROR - 
+}                                       // ERROR - control reaches end
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p11116.C b/gcc/testsuite/g++.old-deja/g++.mike/p11116.C
new file mode 100644
index 00000000000..9beff46e827
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p11116.C
@@ -0,0 +1,22 @@
+// Build don't link:
+// Special g++ Options: -Wno-pmf-conversions
+// prms-id: 11116
+
+class Bar {
+public:
+  int f(int a) { val = a; return val; }
+private:
+  int val;
+};
+
+typedef int (Bar::*BarPtr)(int);
+
+void foo() {
+  int a;
+  int (Bar::*bp)(int) = &Bar::f;
+  Bar bar;
+  int (*p)(void *, int);
+
+  p = (int (*)(void*,int))((void (*)())((bp).__pfn_or_delta2.__pfn));
+  a = (*p)(&bar, 4);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p11142.C b/gcc/testsuite/g++.old-deja/g++.mike/p11142.C
new file mode 100644
index 00000000000..a22ca45bbd7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p11142.C
@@ -0,0 +1,18 @@
+// Build don't link:
+// Special g++ Options: -fexceptions -O -g
+// prms-id: 11142
+
+class RWxmsg {
+public:
+  RWxmsg();
+  virtual ~RWxmsg();
+};
+
+class RWTHRInternalError : public RWxmsg {
+public:
+  virtual ~RWTHRInternalError() { }
+};
+
+void setCount(int count) {
+  throw RWTHRInternalError();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p11144.C b/gcc/testsuite/g++.old-deja/g++.mike/p11144.C
new file mode 100644
index 00000000000..98b9fb04ef9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p11144.C
@@ -0,0 +1,17 @@
+// Special g++ Options: -O
+// prms-id: 11144
+
+class Id {
+public:
+  int d_i;
+  Id(int i) : d_i(i) {}
+  int value() {return d_i;}
+} id(1);
+
+Id foo() { return id; }
+
+int main() {
+  const Id &id1 = foo();
+  const Id &id2 = foo();
+  return &id1 == &id2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p11482.C b/gcc/testsuite/g++.old-deja/g++.mike/p11482.C
new file mode 100644
index 00000000000..f03a4229eca
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p11482.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// prms-id: 11482
+
+void *vp;
+
+enum E { bad, ok } e;
+
+void foo() {
+  e = (E)vp;		// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p11667.C b/gcc/testsuite/g++.old-deja/g++.mike/p11667.C
new file mode 100644
index 00000000000..89ab3132f47
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p11667.C
@@ -0,0 +1,62 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+// prms-id: 11667
+
+extern "C" int printf(const char *,...);
+
+template < class T >
+class LIST {
+public:
+
+  LIST() { nitems = 16; items = new T[nitems]; };
+
+  LIST(int u) { nitems = u; items = new T[nitems]; };
+
+  T& operator[](int i) const {
+    return items[i];
+  }
+
+  void grow(int n) {
+    T* newlist = new T[n];
+    T* src = items;
+    T* dst = newlist;
+    int i = nitems;
+
+    try {
+      while (i--) *dst++ = *src++;
+    } catch (...) {
+      delete[]  newlist;
+      throw;
+    }
+
+    if (items) delete[] items;
+    nitems = n;
+    items = newlist;
+  }
+
+private:
+  int nitems;
+  T *items;
+};
+
+int main(int argc, char **argv) {
+  int i;
+  LIST<int> mylist(10);
+
+  printf("Start dumping initial 10 item list\n");
+  for (i = 0; i < 10 ; i++) {
+    mylist[i] = i;
+    printf("%d\n", mylist[i]);
+  }
+
+  printf("Growing list to 20\n");
+  mylist.grow(20);
+
+  printf("Start dumping grown 20 item list\n");
+  for (i = 0; i < 20; i++) {
+    mylist[i] = i;
+    printf("%d\n", mylist[i]);
+  }
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p12306.C b/gcc/testsuite/g++.old-deja/g++.mike/p12306.C
new file mode 100644
index 00000000000..12b4a453b9a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p12306.C
@@ -0,0 +1,75 @@
+// prms-id: 12306
+
+void *ptr1, *ptr2;
+int fail = 0;
+
+extern "C" int printf(const char *...);
+
+class RWSlist { };
+
+class RWSlistIterator {
+public:
+  RWSlist *slist;
+  RWSlistIterator(RWSlist& s) { } 
+  void toLast() {
+    if (ptr1 != (RWSlistIterator*)this)
+      fail = 5;
+    if (ptr2 != &(*this).slist)
+      fail = 6;
+
+    if (0) printf("at %x %x\n", (RWSlistIterator*)this, &(*this).slist);
+  }
+};
+
+class RWCollectable {
+};
+
+class RWSlistCollectables : public RWSlist {
+public:	 
+  RWSlistCollectables() { }
+  RWSlistCollectables(RWCollectable* a) { }
+};
+
+class RWIterator { };	  
+
+class RWSlistCollectablesIterator : public RWIterator, public RWSlistIterator {
+public:
+  RWSlistCollectablesIterator(RWSlistCollectables& s) : RWSlistIterator(s) { } 
+};
+
+class Sim_Event_Manager {
+public:
+  RWSlistCollectables scheduled_events_;
+  RWSlistCollectablesIterator last_posted_event_position_;
+  Sim_Event_Manager();
+  void post_event();
+};
+
+Sim_Event_Manager::Sim_Event_Manager ()
+  :last_posted_event_position_(scheduled_events_)
+{
+}
+
+void Sim_Event_Manager::post_event () {
+  ptr1 = (RWSlistIterator*)&last_posted_event_position_;
+  ptr2 = &((RWSlistIterator*)&last_posted_event_position_)->slist;
+  if (0) printf("at %x %x\n", (RWSlistIterator*)&last_posted_event_position_,
+		&((RWSlistIterator*)&last_posted_event_position_)->slist);
+  if (ptr1 != (RWSlistIterator*)&last_posted_event_position_)
+    fail = 1;
+  if (ptr2 != &((RWSlistIterator&)last_posted_event_position_).slist)
+    fail = 2;
+  if (0) printf("at %x ?%x\n", (RWSlistIterator*)&last_posted_event_position_,
+		&((RWSlistIterator&)last_posted_event_position_).slist);
+  if (ptr1 != (RWSlistIterator*)&last_posted_event_position_)
+    fail = 3;
+  if (ptr2 != &((RWSlistIterator&)last_posted_event_position_).slist)
+    fail = 4;
+  last_posted_event_position_.toLast();
+}
+
+int main(int argc, char **argv) {
+  Sim_Event_Manager foo;
+  foo.post_event();
+  return fail;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p12306a.C b/gcc/testsuite/g++.old-deja/g++.mike/p12306a.C
new file mode 100644
index 00000000000..bbcade4f9be
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p12306a.C
@@ -0,0 +1,35 @@
+// prms-id: 12306
+// a net report of the same problem as 12306
+
+class a {
+public:
+    int i;
+};
+
+class g : virtual public a {
+};
+
+class b : virtual public a {
+    int j;
+};
+
+class c : public g, public b {
+};
+
+class d {
+public:
+    virtual class b* get() {return 0;}
+};
+
+class f : public d {
+public:
+    virtual class b* get() {return &_c;}
+    c _c;
+};
+
+int main(void) {
+    f D;
+    b* bp=D.get();
+    D._c.i = 42;
+    return &D._c.i != &bp->i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p1248.C b/gcc/testsuite/g++.old-deja/g++.mike/p1248.C
new file mode 100644
index 00000000000..035e8e1828f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p1248.C
@@ -0,0 +1,28 @@
+// GROUPS passed pure-virt
+extern "C" { void printf(const char *, ...); }
+class Base {
+public:
+  virtual ~Base() =0;
+};
+
+class Deranged : public Base {
+public:
+  int value;
+  virtual ~Deranged();
+};
+
+
+Deranged::~Deranged(){}
+
+void foo() {
+  Deranged d;
+}
+
+int main()
+{
+  foo();
+  printf("PASS\n");
+  return 0;
+}
+
+Base::~Base () { }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p1567.C b/gcc/testsuite/g++.old-deja/g++.mike/p1567.C
new file mode 100644
index 00000000000..0b35bd972e0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p1567.C
@@ -0,0 +1,41 @@
+// GROUPS passed vtable
+extern "C" int printf (const char *, ...);
+extern "C" void exit(int);
+
+class A {
+public:
+  virtual const char* f1() { return "A::f1"; }
+  virtual const char* f2() { return "A::f2"; }
+  virtual const char* f3() { printf("FAIL\n"); exit(1); return "A::f3"; }
+};
+
+class B {
+public:
+  virtual const char* f2() { return "B::f2"; }
+  virtual const char* f3() { return "B::f3"; }
+};
+
+class C: public A, public B {
+public:
+  const char* f2() { return B::f2(); }
+  const char* f1() { return f2(); }
+  const char* f3() { return A::f3(); }
+};
+
+class D: public A, public B {
+public:
+  const char* f2() { return B::f2(); }
+  const char* f1() { return D :: f2(); }
+  const char* f3() { return A::f3(); }
+};
+
+int main() {
+  C* tempC = new C;
+  D* tempD = new D;
+  A* a = tempC;
+  printf("calling f1 on a C gives %s\n", a->f1());
+  a = tempD;
+  printf("calling f1 on a D gives %s\n", a->f1());
+  printf("PASS\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p16146.C b/gcc/testsuite/g++.old-deja/g++.mike/p16146.C
new file mode 100644
index 00000000000..070dc2ea4b8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p16146.C
@@ -0,0 +1,89 @@
+// prms-id: 16146
+
+extern "C" int printf (const char *, ...);
+
+class myFoundation {
+protected:
+  myFoundation () { count = 0; };
+  virtual ~myFoundation () {};
+
+public:
+  void addRef () { ++count; }
+  void removeRef () { if (count > 0) --count; }
+
+private:
+  long count;
+};
+
+
+class firstIntermediate :virtual public myFoundation {
+public:
+  firstIntermediate () {};
+  ~firstIntermediate () {};
+
+  void bar () { printf ("Bar\n"); }
+};
+
+
+class firstBase	:  public firstIntermediate {
+public:
+  firstBase () {};
+  ~firstBase () {};
+
+  virtual void g () {};
+};
+
+
+class secondIntermediate : virtual public myFoundation {
+public:
+  secondIntermediate () {};
+  ~secondIntermediate () {};
+
+  virtual void h () {};
+};
+
+
+class secondBase : public secondIntermediate {
+public:
+  secondBase () {};
+  ~secondBase () {};
+
+  virtual void h () {};
+};
+
+
+class typeInterface : virtual public firstBase {
+public:
+  typeInterface () {};
+  ~typeInterface () {};
+
+  virtual void i () {};
+};
+
+class classServices : virtual public firstBase,
+		      public secondBase {
+public:
+  classServices () {};
+  ~classServices () {};
+
+  virtual void j () {};
+};
+
+class classImplementation : public typeInterface,
+			    public classServices {
+public:
+  classImplementation () {};
+  ~classImplementation () {};
+
+  void g () {};
+  void h () {};
+  void i () {};
+  void j () {};
+};
+
+int main () {
+  firstBase* fbp = new classImplementation;
+  classImplementation* cip = dynamic_cast <classImplementation*> (fbp);
+  cip->addRef();
+  myFoundation* mfp = cip;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p1862.C b/gcc/testsuite/g++.old-deja/g++.mike/p1862.C
new file mode 100644
index 00000000000..401b3700777
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p1862.C
@@ -0,0 +1,62 @@
+// GROUPS vtable
+extern "C" int printf (const char *, ...);
+
+class A
+{
+public:
+  virtual ~A(){};
+  virtual int type(void)
+  {
+    return -1;
+  }
+};
+
+class B
+{
+public:
+  virtual ~B(){};
+};
+
+
+class C0 : public B, public A
+{
+public:
+  virtual int type(void)
+  {
+    return 0;
+  }
+};
+
+class C1 : public C0
+{
+public:
+  virtual int type(void)
+  {
+    return 1;
+  }
+};
+
+class C2 : public C0
+{
+public:
+  virtual int type(void)
+  {
+    return 2;
+  }
+};
+
+int main()
+{
+  C1 *one = new C1;
+  
+  if (one->type() == 1)
+    {
+      printf ("PASS\n");
+      return 0;
+    }
+  else
+    {
+      printf ("FAIL\n");
+      return 1;
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p1989.C b/gcc/testsuite/g++.old-deja/g++.mike/p1989.C
new file mode 100644
index 00000000000..7e1886922eb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p1989.C
@@ -0,0 +1,494 @@
+// Build don't link:
+// prms-id: 1989
+
+#define TRUE true
+#define FALSE false
+typedef void *Pix;
+
+template<class T>
+struct link {
+    T item;
+    link *next;
+    link *prev;
+
+    link(const T& t): item(t), prev(0), next(0)
+	{ };
+    link(const T& t, link<T> *p, link<T> *n): item(t), prev(p), next(n)
+	{ };
+};
+
+template<class T>
+class List_DL {
+public:
+    List_DL();
+    List_DL(const List_DL&);
+    ~List_DL();
+
+    void append(const T& item);
+    void prepend(const T& item);
+    void insert(const T& item, Pix x, bool before);
+
+    void remove(Pix& x)
+	{ T tmp; remove(x, tmp); }
+    void remove(Pix& x, T& item);
+
+    void clear();
+
+    unsigned length() const
+	{ return count; }
+
+private:
+
+    unsigned count;
+    link<T> *head;
+    link<T> *tail;
+
+public:
+    Pix first() const
+	{ return Pix(head); }
+    Pix last() const
+	{ return Pix(tail); }
+    void next(Pix& x) const
+	{ if (0 != x) x = ((link<T> *) x)->next; }
+    void prev(Pix& x) const
+	{ if (0 != x) x = ((link<T> *) x)->prev; }
+    T& operator()(Pix x) const
+	{ return ((link<T> *) x)->item; }
+};
+
+template<class T>
+List_DL<T>::List_DL():
+count(0),
+head(0)
+{ }
+
+template<class T>
+List_DL<T>::List_DL(const List_DL& other):
+count(0),
+head(0)
+{
+    for (Pix x=other.first(); 0 != x; other.next(x))
+	append(other(x));
+}
+
+template<class T>
+List_DL<T>::~List_DL()
+{
+    clear();
+}
+
+template<class T>
+void
+List_DL<T>::append(const T& item)
+{
+    count++;
+    if (0 == head) {
+	head = new link<T>(item);
+	tail = head;
+    } else {
+	tail->next = new link<T>(item, tail, 0);
+	tail = tail->next;
+    }
+}
+
+template<class T>
+void
+List_DL<T>::prepend(const T& item)
+{
+    count++;
+    if (0 == head) {
+	head = new link<T>(item);
+	tail = head;
+    } else {
+	head = new link<T>(item, 0, head);
+	if (tail == head)
+	    tail = tail->next;
+    }
+}
+
+template<class T>
+void
+List_DL<T>::insert(const T& item, Pix x, bool before = TRUE)
+{
+    link<T> *l = (link<T> *) x;
+
+    if (before) {
+	if (0 == l || l == head) {
+	    prepend(item);
+	} else {
+	    link<T> *n = new link<T>(item, l->prev, l);
+	    l->prev->next = n;
+	    l->prev = n;
+	}
+    } else {
+	if (0 == l || l == tail) {
+	    append(item);
+	} else {
+	    link<T> *n = new link<T>(item, l, l->next);
+	    l->next->prev = n;
+	    l->prev = n;
+	}
+    }
+}
+
+template<class T>
+void
+List_DL<T>::remove(Pix& x, T& item)
+{
+    link<T> *l = (link<T> *) x;
+
+    if (0 == l)
+	return;
+
+    item = l->item;
+    if (1 == count) {
+	delete head;
+	head = 0;
+	tail = 0;
+    } else {
+	// more than one item in the list
+	if (l == head) {
+	    link<T> *old = head;
+	    head = head->next;
+	    head->prev = 0;
+	    delete old;
+	} else if (l == tail) {
+	    link<T> *old = tail;
+	    tail = tail->prev;
+	    tail->next = 0;
+	    delete old;
+	} else {
+	    l->next->prev = l->prev;
+	    l->prev->next = l->next;
+	    delete l;
+	}
+    }
+}
+
+template<class T>
+void
+List_DL<T>::clear()
+{
+    link<T> *l, *succ;
+    for (l=head; 0 != l; l=succ) {
+	succ = l->next;
+	delete l;
+    }
+    head = 0;
+    tail = 0;
+}
+
+template<class T>
+class List_DLS: public List_DL<T> {
+public:
+    List_DLS(): List_DL<T>()
+	{ };
+    List_DLS(const List_DLS& other): List_DL<T>(other)
+	{ };
+
+    bool contains(const T& item) const
+	{ return search(item) != 0 ? TRUE: FALSE; }
+    Pix search(const T&) const;
+};
+
+template<class T>
+Pix
+List_DLS<T>::search(const T& item) const
+{
+    for (Pix x=first(); 0 != x; next(x)) {
+	if (item == operator()(x)) // ERROR - const subversion
+	    return x;
+    }
+    return 0;
+}
+
+template<class T>
+class List_DLSp: public List_DL<T> {
+public:
+    List_DLSp(): List_DL<T>()
+	{ };
+    List_DLSp(const List_DLSp& other): List_DL<T>(other)
+	{ };
+
+    bool contains(const T& item) const
+#ifndef INTERNAL_ERROR
+	;
+#else
+	{ return search(item) != 0 ? TRUE: FALSE; }
+#endif
+    Pix search(const T&) const;
+};
+
+template<class T>
+bool
+List_DLSp<T>::contains(const T& item) const
+{
+    for (Pix x=first(); 0 != x; next(x)) {
+	if (*item == *operator()(x))
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+template<class T>
+class Set {
+public:
+    Set();
+    Set(const Set& other);
+
+    virtual void add(const T& item);
+
+    void remove(const T& item)
+	{ Pix x = search(item); remove(x); }
+    void remove(Pix& x)
+	{ T tmp; remove(x, tmp); }
+    virtual void remove(Pix& x, T& item);
+
+    virtual void clear();
+
+    virtual bool contains(const T&) const;
+    virtual Pix search(const T&) const;
+
+    virtual unsigned length() const;
+
+    virtual Pix first() const;
+    virtual void next(Pix& x) const;
+    virtual T& operator()(Pix x) const;
+};
+
+template<class T>
+Set<T>::Set()
+{ }
+
+template<class T>
+Set<T>::Set(const Set& other)
+{ }
+
+
+template<class T>
+class Set_DL: public List_DLS<T> {
+public:
+    Set_DL();
+    Set_DL(const Set_DL& other);
+
+    void add(const T& item)
+	{ list.append(item); }
+    void remove(Pix& x, T& item)
+	{ list.remove(x, item); }
+
+    void clear()
+	{ list.clear(); }
+
+    bool contains(const T& item) const
+	{ return list.contains(item); }
+    Pix search(const T& item) const
+	{ return list.search(item); }
+
+    unsigned length() const
+	{ return list.length(); }
+
+    Pix first() const
+	{ return list.first(); }
+    void next(Pix& x) const
+	{ list.next(x); }
+    T& operator()(Pix x) const
+	{ return list(x); }
+private:
+    List_DLS<T> list;
+};
+
+template<class T>
+class Set_DLp: public List_DLSp<T> {
+public:
+    Set_DLp();
+    Set_DLp(const Set_DLp& other);
+
+    void add(const T& item)
+	{ list.append(item); }
+    void remove(Pix& x, T& item)
+	{ list.remove(x, item); }
+
+    void clear()
+	{ list.clear(); }
+
+    bool contains(const T& item) const
+	{ return list.contains(item); }
+    Pix search(const T& item) const
+	{ return list.search(item); }
+
+    unsigned length() const
+	{ return list.length(); }
+
+    Pix first() const
+	{ return list.first(); }
+    void next(Pix& x) const
+	{ list.next(x); }
+    T& operator()(Pix x) const
+	{ return list(x); }
+private:
+    List_DLSp<T> list;
+};
+
+template<class T>
+struct vertex {
+    T item;
+    List_DL<vertex<T> *> fanout;
+
+    vertex(): item(), fanout()	// gets bogus error
+      { };
+    vertex(const T& i): item(), fanout() // gets bogus error
+      { };
+};
+
+template<class T>
+class Graph {
+public:
+    Graph();
+    Graph(const Graph&);
+    ~Graph();
+
+    void add(const T& from, const T& to);
+    bool contains(const T& from, const T& to) const;
+
+    void clear()
+	{ vertices.clear(); }
+
+    unsigned lengthV() const
+	{ return vertices.length(); }
+
+    Pix firstV() const
+	{ return vertices.first(); }
+    void nextV(Pix& x) const
+	{ vertices.next(x); }
+    T& V(Pix x) const
+	{ return vertices(x).item; }
+
+    Pix firstV1(Pix vx) const;
+    void nextV1(Pix vx, Pix& x) const;
+    T& V1(Pix vx, Pix x) const;
+private:
+    vertex<T> *lookup(const T& from) const;
+    vertex<T> *lookup_new(const T& from);
+
+    List_DLS<vertex<T> > vertices;
+};
+
+template<class T>
+Graph<T>::Graph():
+vertices()
+{ }
+
+template<class T>
+Graph<T>::Graph(const Graph& other):
+vertices()
+{
+    for (Pix vx=firstV(); 0 != vx; nextV(vx)) {
+	for (Pix vx1=firstV1(vx); 0 != vx1; nextV1(vx, vx1)) {
+	    add(V(vx), V1(vx, vx1));
+	}
+    }
+}
+
+template<class T>
+Graph<T>::~Graph()
+{
+    clear();
+}
+
+template<class T>
+void
+Graph<T>::add(const T& from, const T& to)
+{
+    vertex<T> *fromv = lookup_new(from);
+    if (from == to)
+	return;
+    vertex<T> *tov = lookup_new(to);
+    fromv->fanout.append(tov);
+}
+
+template<class T>
+bool
+Graph<T>::contains(const T& from, const T& to) const
+{
+    vertex<T> *fromv = lookup(from);
+    if (0 == fromv)
+	return FALSE;
+
+    for (Pix x=fromv->fanout.first(); 0 != x; fromv->fanout.next(x)) {
+	if (fromv->fanout(x)->item == to)
+	    return TRUE;
+    }
+
+    return FALSE;
+}
+
+template<class T>
+vertex<T> *
+Graph<T>::lookup(const T& from) const
+{
+    for (Pix x=vertices.first(); 0 != x; vertices.next(x)) {
+	if (vertices(x).item == from)
+	    return &vertices(x);
+    }
+    return 0;
+}
+
+template<class T>
+vertex<T> *
+Graph<T>::lookup_new(const T& from)
+{
+    vertex<T> *v = lookup(from);
+    if (0 == v) {
+	vertices.append(from);
+	return &vertices(vertices.last());
+    }
+    return v;
+}
+
+template<class T>
+Pix
+Graph<T>::firstV1(Pix vx) const
+{
+    vertex<T> *v = (vertex<T> *) vx;
+    return v->fanout.first();
+}
+
+template<class T>
+void
+Graph<T>::nextV1(Pix vx, Pix& x) const
+{
+    vertex<T> *v = (vertex<T> *) vx;
+    return v->fanout.next(x);
+}
+
+template<class T>
+T&
+Graph<T>::V1(Pix vx, Pix x) const
+{
+    vertex<T> *v = (vertex<T> *) vx;
+    static T x1;
+    return x1;
+}
+
+class STRLIdentifier;
+
+extern int x(List_DL<STRLIdentifier *>);
+extern int x(List_DLS<STRLIdentifier *>);
+
+extern int x(Set<STRLIdentifier *>);
+extern int x(Set_DL<STRLIdentifier *>);
+extern int x(Set_DLp<STRLIdentifier *>);
+
+extern int x(Graph<STRLIdentifier *>);
+
+class STRLIdentifier {
+    char buf[10];
+};
+
+extern int operator==(vertex<STRLIdentifier*>&, vertex<STRLIdentifier*>&); // ERROR - const subversion
+extern int operator==(STRLIdentifier&, STRLIdentifier&); // ERROR - fn ref in err msg
+
+extern int x(List_DLSp<STRLIdentifier *>);
+
+template class Graph<STRLIdentifier *>;
+template class List_DLS<vertex<STRLIdentifier *> >;
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2394.C b/gcc/testsuite/g++.old-deja/g++.mike/p2394.C
new file mode 100644
index 00000000000..ce335c40183
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2394.C
@@ -0,0 +1,36 @@
+// prms-id: 2394
+
+class Foo {
+ public:
+  int x;
+  int y;
+  Foo(int i, int j) { x = i; y = j; }
+} foo(10, 11);
+
+class Wasted { int unsed; };
+
+class Bar : Wasted, public Foo {
+public:
+  Bar() : Foo(12, 13) { }
+} bar;
+
+int
+test0() {
+  int Foo::* pmi = &Foo::y;
+  return (int)(foo.*pmi);
+}
+
+int
+test1() {
+  int Foo::* pmi = &Foo::y;
+  return (int)(bar.*pmi);
+}
+
+int
+main() {
+  if (test0() != 11)
+    return 1;
+  if (test1() != 13)
+    return 2;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2431.C b/gcc/testsuite/g++.old-deja/g++.mike/p2431.C
new file mode 100644
index 00000000000..17a76fa7c18
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2431.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+// GROUPS passed infinite_loop
+class A
+{
+	public:
+      A(A &); // ERROR - candidates are
+};
+
+class B
+{
+	public:
+	operator A ();
+};
+
+class C
+{
+	public :
+	C()
+	{
+		B	b;
+		A a = b;// ERROR - 
+	}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2573.C b/gcc/testsuite/g++.old-deja/g++.mike/p2573.C
new file mode 100644
index 00000000000..9e3ddeed9de
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2573.C
@@ -0,0 +1,14 @@
+// prms-id: 2573
+
+class X {
+public:
+  int key();
+  virtual int vkey();
+  char *add();
+};
+
+char *X::add() {
+  char *f1 = (char *) &key;	// ERROR - 
+  char *f2 = (char *) &vkey;	// ERROR - 
+  return f1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2736.C b/gcc/testsuite/g++.old-deja/g++.mike/p2736.C
new file mode 100644
index 00000000000..7a0405196ec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2736.C
@@ -0,0 +1,28 @@
+// This is a poor test case, it is meant to ensure that function local
+// statics are destroyed at the right time.  See PR 2736 for details.
+// prms-id: 2736
+
+int count;
+
+struct A {
+  int which;
+  A(int i) :which(i) {
+    // printf("ctor %x\n", this);
+  }
+  ~A() {
+    // printf("dtor %x\n", this);
+    if (++count != which)
+      abort ();
+    }
+};
+
+void
+foo() {
+  static A a(1);
+}
+
+A a(2);
+
+int main() {
+  foo();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2746.C b/gcc/testsuite/g++.old-deja/g++.mike/p2746.C
new file mode 100644
index 00000000000..fdc37d137f7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2746.C
@@ -0,0 +1,156 @@
+// Build don't link: 
+// GROUPS passed scope pt
+class Link {
+public:
+  Link();
+  Link(Link *);
+private:
+  Link *next_;
+
+friend class IListBase;
+friend class IListIterBase;
+};
+
+inline
+Link::Link() : next_(0)
+{
+}
+
+inline
+Link::Link(Link *next) : next_(next)
+{
+}
+
+class IListBase {
+public:
+  IListBase();
+  IListBase(Link *);
+  void  append(Link *);
+  void insert(Link *);
+  Link *head();
+  int empty();
+  Link *get();
+  void remove(Link *);
+private:
+  Link *head_;
+friend class IListIterBase;
+};
+
+inline
+IListBase::IListBase() : head_(0)
+{
+}
+
+inline
+IListBase::IListBase(Link *head) : head_(head)
+{
+}
+
+inline
+void IListBase::insert(Link *p)
+{
+  p->next_ = head_;
+  head_ = p;
+}
+
+inline
+Link *IListBase::head()
+{
+  return head_;
+}
+
+inline
+int IListBase::empty()
+{
+  return head_ == 0;
+}
+
+inline
+Link *IListBase::get()
+{
+  Link *tem = head_;
+  head_ = head_->next_;
+  return tem;
+}
+  
+template<class T> class IListIter;
+
+template<class T>
+class IList : private IListBase {
+public:
+  IList() { }
+  IList(T *p) : IListBase(p) { }
+  ~IList();
+  void append(T *p) { IListBase::append(p); }
+  void insert(T *p) { IListBase::insert(p); }
+  void remove(T *p) { IListBase::remove(p); }
+  T *head() { return (T *)IListBase::head(); }
+  T *get() { return (T *)IListBase::get(); }
+  IListBase::empty;
+friend class IListIter<T>;
+};
+
+template<class T>
+IList<T>::~IList()
+{
+  while (!empty())
+    delete get();
+}
+
+class IListIterBase {
+public:
+  IListIterBase(const IListBase &);
+  int done();
+  Link *cur();
+  void next();
+private:
+  Link *p_;
+};
+
+inline
+IListIterBase::IListIterBase(const IListBase &list) : p_(list.head_)
+{
+}
+
+inline
+int IListIterBase::done()
+{
+  return p_ == 0;
+}
+
+inline
+Link *IListIterBase::cur()
+{
+  return p_;
+}
+
+inline
+void IListIterBase::next()
+{
+  p_ = p_->next_;
+}
+
+
+template<class T>
+class IListIter : private IListIterBase {
+public:
+  IListIter(const IList<T> &list) : IListIterBase(list) { }
+  T *cur() { return (T *)IListIterBase::cur(); }
+  IListIterBase::next;
+  IListIterBase::done;
+};
+
+
+struct A {
+  IList<Link> list;
+  int x;
+  void foo();
+};
+
+
+void A::foo()
+{
+  for (IListIter<Link> iter(list); !iter.done(); iter.next())
+    ;
+  x = 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2793.C b/gcc/testsuite/g++.old-deja/g++.mike/p2793.C
new file mode 100644
index 00000000000..73bf23f7349
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2793.C
@@ -0,0 +1,6 @@
+// Build don't link:
+// prms-id: 2793
+
+void f(char&) {			// ERROR - referenced by error below
+  f('c');			// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2806.C b/gcc/testsuite/g++.old-deja/g++.mike/p2806.C
new file mode 100644
index 00000000000..401b5ecd488
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2806.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+// GROUPS passed
+template<class T>
+class List
+{
+  public:
+    List();
+    void f() const;
+};
+
+template<class T>
+void List<T>::f() const
+{
+}
+
+void func()
+{
+    List<int> list;
+    list.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2846.C b/gcc/testsuite/g++.old-deja/g++.mike/p2846.C
new file mode 100644
index 00000000000..b9a44c43c1e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2846.C
@@ -0,0 +1,55 @@
+// prms-id: 2846
+
+extern "C" int printf(const char *, ...);
+extern "C" void exit(int);
+
+class A;
+class B;
+
+class A {
+public:
+
+  A(void){}
+  A(const A&){}
+  A(const B&);
+
+  virtual ~A(void){}
+
+  virtual void print(void) const {
+    printf("A::print\n");
+    printf("FAIL\n");
+    exit(1);
+  }
+  B compute(void) const;
+};
+
+class B : private A {
+friend class A;
+public:
+
+  virtual ~B(void){}
+
+  void print(void) const {
+    printf("B::print\n");
+  }
+
+private:
+  B(const A& x, int){}
+};
+
+A::A(const B& s) {
+  s.print();
+}
+
+B A::compute(void) const {
+  B sub(*this, 1);
+  return sub;
+}
+
+int main ()
+{
+  A titi;
+  A toto = titi.compute();
+  printf("PASS\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2846a.C b/gcc/testsuite/g++.old-deja/g++.mike/p2846a.C
new file mode 100644
index 00000000000..8606e4233e8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2846a.C
@@ -0,0 +1,34 @@
+// Shows that problem of initializing one object's vtable pointer from
+// another object's vtable pointer when doing a default copy of it
+// and the vtable pointer involved is the main one.
+
+// Correct answer is B::print.
+// g++ prints D::print, which is wrong.  Cfront gets is right.
+
+// prms-id: 2846
+
+extern "C" int printf(const char *, ...);
+extern "C" void exit(int);
+
+class B {
+public:
+  virtual void print(void) const { printf("B::print\n"); }
+};
+
+class D : public B {
+public:
+  void print(void) const { printf("D::print\n"); exit(1); }
+  B compute(void) const;
+};
+
+B D::compute(void) const
+{
+  B sub(*(B*)this);
+  return sub;
+}
+
+int main () {
+  D titi;
+  titi.compute().print();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2846b.C b/gcc/testsuite/g++.old-deja/g++.mike/p2846b.C
new file mode 100644
index 00000000000..acba70d6e2a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2846b.C
@@ -0,0 +1,52 @@
+// Shows that problem of initializing one object's secondary base from
+// another object via a user defined copy constructor for that base,
+// the pointer for the secondary vtable is not set after implicit
+// copying of the outer class, but rather has the pointer to the main
+// vtable for the secondary base left over from the user defined copy
+// constructor for that base.
+
+// Correct answer is B::beefy.
+// g++ prints A::beefy, which is wrong.  Cfront gets it right.
+
+// prms-id: 2846
+
+extern "C" int printf(const char *, ...);
+extern "C" void exit(int);
+
+class B;
+
+class A {
+ public:
+
+  A(void){}
+  A(const A&){}
+
+  virtual void print(void) const { }
+  B compute(void) const;
+};
+
+class C {
+public:
+  C() { }
+  C(C& o) { }		// with it, things are wrong, without it, they're ok
+  virtual void beefy(void) const { printf("A::beefy\n"); exit(1); }
+};
+
+class B : private A, public C {
+public:
+  B(const A& x, int){}
+  void beefy(void) const { printf("B::beefy\n"); }
+};
+
+B A::compute(void) const
+{
+  B sub(*this, 1);
+  return sub;
+}
+
+int main ()
+{
+  A titi;
+  titi.compute().beefy();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2855.C b/gcc/testsuite/g++.old-deja/g++.mike/p2855.C
new file mode 100644
index 00000000000..9c99bd72835
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2855.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// Special g++ Options: -Wcast-qual
+// prms-id: 2855
+
+class Ctest {
+private:
+  char* data;
+public:
+  operator const char *() const;
+};
+
+Ctest::operator const char *() const
+{
+  return data;
+}
+int main()
+{
+  Ctest obj;
+  char* temp = (char *)obj;		// WARNING - 
+  temp[0] = '\0';
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p2960.C b/gcc/testsuite/g++.old-deja/g++.mike/p2960.C
new file mode 100644
index 00000000000..4206e75b3ee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p2960.C
@@ -0,0 +1,30 @@
+// prms-id: 2960
+
+extern "C" int printf(const char *, ...);
+
+class Test0 {
+public:
+  virtual void f0() { }      // works fine if this virtual removed
+};
+
+class Test1 : public Test0 {
+public:
+  void f1() { f2(); }		// generates bus error here
+  virtual void f2() { printf("Test1::f2\n"); }
+};
+
+class Test2 {
+public:
+  virtual void f3() { }
+};
+
+class Test3 : public Test2, public Test1 {    // works fine if Test1 first
+public:
+  virtual ~Test3() { f1(); }                       // calling f2 directly works
+  virtual void f2() { printf("Test3::f2\n"); }
+};
+
+int main() {
+    Test3 t3;
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3041.C b/gcc/testsuite/g++.old-deja/g++.mike/p3041.C
new file mode 100644
index 00000000000..fd83eaf7f2f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3041.C
@@ -0,0 +1,33 @@
+// prms-id: 3041
+
+class A {
+public:
+  A() { }
+  virtual void a() = 0;
+  static int b(A * p) {
+    p->a();
+    return 1;
+  }
+};
+
+class B : virtual public A {
+public:
+  B() {
+    static int installed = b(this);
+  }
+  void a() { }
+};
+
+class C : virtual public B {
+public:
+  C() {
+    static int installed = b(this);
+  }
+  void a() { }
+};
+
+int main()
+{
+  C c;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3060c.C b/gcc/testsuite/g++.old-deja/g++.mike/p3060c.C
new file mode 100644
index 00000000000..e26b8024db6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3060c.C
@@ -0,0 +1,23 @@
+// A new problem with my pointer to member function work.
+// Build don't link:
+// prms-id: 3060
+
+class Foo
+{
+ public:
+  int x;
+  int y;
+  Foo (int i, int j) { x = i; y = j; }
+  operator int ();
+};
+
+int Foo::operator int() { return x; } // WARNING - can't specify return type
+
+Foo foo(10, 11);
+
+int
+main()
+{
+  int Foo::* pmi = &Foo::y;
+  return foo.*pmi;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3060d.C b/gcc/testsuite/g++.old-deja/g++.mike/p3060d.C
new file mode 100644
index 00000000000..5cf4fdd10d1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3060d.C
@@ -0,0 +1,34 @@
+// This is a test case to make sure the explicit cast on a pointer to
+// a member function works ok.
+// prms-id: 3060
+
+extern "C" int printf(const char *, ...);
+
+class Object;
+
+typedef void (Object::*VoidObjMemberFunc)(Object *, ...);
+
+class Object {
+public:
+  int         foo;
+};
+
+class Clipper: public Object {
+public:
+  int         bar;
+  void        Feedback(Object*, void*);
+};
+void Clipper::Feedback(Object *tracker, void *ap) {
+  printf("Doing feedback\n");
+}
+
+void vfunc(VoidObjMemberFunc of, Object *op, void *v1) {
+  (op->*of)(op, v1);
+}
+
+int main() {
+  Object      o;
+
+  vfunc((VoidObjMemberFunc)&Clipper::Feedback, &o, 0);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3068.C b/gcc/testsuite/g++.old-deja/g++.mike/p3068.C
new file mode 100644
index 00000000000..2436c8b7fa2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3068.C
@@ -0,0 +1,60 @@
+// prms-id: 3068
+
+extern "C" int printf(const char *, ...);
+extern "C" void exit(int);
+ 
+class LB {
+public:
+  virtual int test() { return 0; }
+  virtual ~LB() { }
+protected:
+  LB() { }
+};
+
+class RRB {
+public:
+  virtual ~RRB() { }
+  virtual void test2(int a) { }
+};
+
+class RR : public RRB {
+public:
+    virtual ~RR() { }
+};
+
+class RL {
+public:
+  virtual void real(int a) {
+    printf("RL::real\n");
+  }
+};
+
+
+class R : public RL, public RR {
+public:
+  virtual void test3(int a) { }
+  virtual void test2(int a) { }
+};
+
+class L : public LB {
+};
+
+class C : public L, public R {
+public:
+  C() { }
+  virtual ~C() {
+    printf("C::~C\n");
+    exit(1);
+  }
+  virtual void real(int a) {
+    printf("RL::real\n");
+  }
+};
+
+int main() {
+    C& bb = *new C;
+    R& mv = bb;
+    bb.real(0);
+    mv.real(0);
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3070.C b/gcc/testsuite/g++.old-deja/g++.mike/p3070.C
new file mode 100644
index 00000000000..c9278736d2c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3070.C
@@ -0,0 +1,32 @@
+// Build don't link:
+// Caused an Internal Compiler Error.  Works now.
+// prms-id: 3070
+
+class Object {
+public:
+  virtual ~Object() {}
+};
+
+class BaseView {
+protected:
+  virtual void _forwardReceiveUpdate() = 0;
+};
+
+
+class View : public BaseView {
+public:
+  virtual ~View();
+};
+
+class TestViewBaseUpdate {
+protected:
+  virtual void _receiveUpdate();
+};
+
+class TestViewBase : public TestViewBaseUpdate, private View {
+};
+
+class TestView : public Object, public TestViewBase {
+protected:
+  virtual void _receiveUpdate();
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3139.C b/gcc/testsuite/g++.old-deja/g++.mike/p3139.C
new file mode 100644
index 00000000000..192fa7251b5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3139.C
@@ -0,0 +1,25 @@
+// prms-id: 3139
+
+extern "C" int printf(const char *, ...);
+
+class A {
+  public:
+  A() { }
+  virtual int a() = 0;
+};
+
+class B : virtual public A {
+  public:
+  virtual int a() = 0;
+};
+
+class C : public B {
+  public:
+  int a() { return 42; }
+};
+
+int main() {
+  B * b = new C;
+  printf("%d.\n", b->a());
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3524a.C b/gcc/testsuite/g++.old-deja/g++.mike/p3524a.C
new file mode 100644
index 00000000000..0995f3530a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3524a.C
@@ -0,0 +1,25 @@
+// Make sure we can initialize a reference to a templated type, that
+// requires a conversion from a derived type to a base type.
+
+// Build don't link:
+// prms-id: 3524
+
+struct cc2Vector
+{};
+
+template <class T>
+struct ccPair
+{
+    ccPair (const cc2Vector&);
+};
+
+struct ccLine  : cc2Vector
+{
+    double distToPoint  (const ccPair <float> &);
+};
+
+void foo ()
+{
+    ccLine l2;
+    l2.distToPoint (l2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3524b.C b/gcc/testsuite/g++.old-deja/g++.mike/p3524b.C
new file mode 100644
index 00000000000..c645d4cdea4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3524b.C
@@ -0,0 +1,21 @@
+// Make sure we can cast to a templated type, that requires a conversion by
+// constructor, from a derived type to a base type.
+
+// Build don't link:
+// prms-id: 3524
+
+template <class T>
+struct ccPair {
+    ccPair () { }
+};
+
+template <class T>
+struct ccO : ccPair<T> {
+  ccO () { }
+};
+
+void foo ()
+{
+  ccO<float> r;
+  (ccPair<float>)r;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3524c.C b/gcc/testsuite/g++.old-deja/g++.mike/p3524c.C
new file mode 100644
index 00000000000..d901e19a265
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3524c.C
@@ -0,0 +1,15 @@
+// Make sure we can cast to a templated type, that requires a conversion by
+// constructor, from a non-aggregate type.
+
+// Build don't link:
+// prms-id: 3524
+
+template <class T>
+struct ccPair {
+    ccPair (int i) { }
+};
+
+void foo ()
+{
+  (ccPair<float>)1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3538a.C b/gcc/testsuite/g++.old-deja/g++.mike/p3538a.C
new file mode 100644
index 00000000000..ea1a6cc53a7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3538a.C
@@ -0,0 +1,33 @@
+// Build don't link:
+// This tests for the compiler_error in binfo_value.
+// prms-id: 3538
+
+class ccObjectInfo
+{
+public:
+    virtual const ccObjectInfo& repInvariant (int);
+};
+
+template<class T>
+class ccHandle : public  ccObjectInfo
+{
+protected:
+  T* p;
+public:
+  virtual const ccObjectInfo& repInvariant (int);
+};
+
+template <class T>
+const ccObjectInfo& ccHandle<T>::repInvariant (int)
+{ return p->ri(1); }
+
+class ccHandleBase : public ccObjectInfo
+{};
+
+class cc_CircleHdl : public virtual ccHandleBase, public ccObjectInfo
+{
+public:
+  virtual const ccObjectInfo& ri (int);
+};				// WARNING - 
+
+class ccCircleHdl : public ccHandle <cc_CircleHdl> {};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3538b.C b/gcc/testsuite/g++.old-deja/g++.mike/p3538b.C
new file mode 100644
index 00000000000..4dcd60b3d10
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3538b.C
@@ -0,0 +1,35 @@
+// Build don't link:
+// prms-id: 3538
+
+// This tests for an ambiguous conversion of the this pointer (going
+// down to DECL_CONTEXT of a FUNCTION_DECL.
+
+class ccObjectInfo
+{
+public:
+    virtual const ccObjectInfo& repInvariant (int);
+};
+
+template<class T>
+class ccHandle : public  ccObjectInfo
+{
+protected:
+  T* p;
+public:
+  virtual const ccObjectInfo& repInvariant (int);
+};
+
+template <class T>
+const ccObjectInfo& ccHandle<T>::repInvariant (int)
+{ return p->repInvariant(1); }
+
+class ccHandleBase : public ccObjectInfo
+{};
+
+class cc_CircleHdl : public virtual ccHandleBase, public ccObjectInfo
+{
+public:
+  virtual const ccObjectInfo& repInvariant (int);
+};				// WARNING - 
+
+class ccCircleHdl : public ccHandle <cc_CircleHdl> {};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3570.C b/gcc/testsuite/g++.old-deja/g++.mike/p3570.C
new file mode 100644
index 00000000000..1213a960b6e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3570.C
@@ -0,0 +1,29 @@
+// prms-id: 3570
+
+extern "C" int printf(const char *, ...);
+
+struct A {
+   void print() {printf("A");};
+};
+
+struct B :  A {
+   typedef A superB;
+   void print() {superB::print(); printf("B");};
+};
+
+struct C :  B {
+   typedef B superC;
+   void print() {superC::print(); printf("C");};
+};
+
+int main ()
+{
+   A a;
+   B b;
+   C c;
+
+   a.print(); printf("\n");
+   b.print(); printf("\n");
+   c.print(); printf("\n");
+   return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3579.C b/gcc/testsuite/g++.old-deja/g++.mike/p3579.C
new file mode 100644
index 00000000000..d960599450f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3579.C
@@ -0,0 +1,39 @@
+// prms-id: 3579
+
+extern "C" int printf(const char *, ...);
+
+int num_x;
+
+class Y {
+public:
+  Y () { printf("Y()            this: %x\n", this); }
+  ~Y () { printf("~Y()           this: %x\n", this); }
+};
+
+class X {
+public:
+  X () {
+    ++num_x;
+    printf("X()            this: %x\n", this);
+    Y y;
+    *this = (X) y;
+  }
+
+  X (const Y & yy) { printf("X(const Y&)    this: %x\n", this); ++num_x; }
+  X & operator = (const X & xx) {
+    printf("X.op=(X&)      this: %x\n", this);
+    return *this;
+  }
+
+  ~X () { printf("~X()           this: %x\n", this); --num_x; }
+};
+
+int main (int, char **) {
+    { X anX; }
+    if (num_x) {
+      printf("FAIL\n");
+      return 1;
+    }
+    printf("PASS\n");
+    return 0;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3708.C b/gcc/testsuite/g++.old-deja/g++.mike/p3708.C
new file mode 100644
index 00000000000..cda1108d629
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3708.C
@@ -0,0 +1,86 @@
+// prms-id: 3708
+
+extern "C" void printf (char *, ...);
+extern "C" int atoi (char *);
+
+void *ptr;
+
+class A {
+public:
+  A() { printf ("A is constructed.\n"); }
+  virtual void xx(int doit) { printf ("A is destructed.\n"); }
+};
+
+class A1 {
+public:
+  A1() { printf ("A1 is constructed.\n"); }
+  virtual void xx(int doit) { printf ("A1 is destructed.\n"); }
+};
+
+class B : public virtual A, public A1 {
+public:
+  B() { printf ("B is constructed.\n"); }
+  virtual void xx(int doit) {
+    printf ("B is destructed.\n");
+    A1::xx (1);
+    if (doit) A::xx (1);
+  }
+};
+
+int num;
+
+class C : public virtual A, public B {
+public:
+  C() { ++num; printf ("C is constructed.\n");
+      ptr = this;
+      }
+  virtual void xx(int doit) {
+    --num;
+    if (ptr != this)
+      printf("FAIL\n%x != %x\n", ptr, this);
+    printf ("C is destructed.\n");
+    B::xx (0);
+    if (doit) A::xx (1);
+  }
+};
+
+void fooA(A *a) {
+  printf ("Casting to A!\n");
+  a->xx (1);
+}
+void fooA1(A1 *a) {
+  printf ("Casting to A1!\n");
+  a->xx (1);
+}
+
+void fooB(B *b) {
+  printf ("Casting to B!\n");
+  b->xx (1);
+}
+
+void fooC(C *c) {
+  printf ("Casting to C!\n");
+  c->xx (1);
+}
+
+int main(int argc, char *argv[]) {
+  printf ("*** Construct C object!\n");
+  C *c = new C();
+
+  int i = 0;
+
+  printf ("*** Try to delete the casting pointer!\n");
+  switch (i)
+    {
+    case 0: fooA1(c);
+      break;
+    case 1: fooA(c);
+      break;
+    case 2: fooB(c);
+      break;
+    case 3: fooC(c);
+      break;
+    }
+
+  return num!=0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3708a.C b/gcc/testsuite/g++.old-deja/g++.mike/p3708a.C
new file mode 100644
index 00000000000..03fd1a18c74
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3708a.C
@@ -0,0 +1,86 @@
+// prms-id: 3708
+
+extern "C" void printf (char *, ...);
+extern "C" int atoi (char *);
+
+void *ptr;
+
+class A {
+public:
+  A() { printf ("A is constructed.\n"); }
+  virtual void xx(int doit) { printf ("A is destructed.\n"); }
+};
+
+class A1 {
+public:
+  A1() { printf ("A1 is constructed.\n"); }
+  virtual void xx(int doit) { printf ("A1 is destructed.\n"); }
+};
+
+class B :  public A1, public virtual A {
+public:
+  B() { printf ("B is constructed.\n"); }
+  virtual void xx(int doit) {
+    printf ("B is destructed.\n");
+    A1::xx (1);
+    if (doit) A::xx (1);
+  }
+};
+
+int num;
+
+class C : public virtual A, public B {
+public:
+  C() { ++num; printf ("C is constructed.\n");
+      ptr = this;
+      }
+  virtual void xx(int doit) {
+    --num;
+    if (ptr != this)
+      printf("FAIL\n%x != %x\n", ptr, this);
+    printf ("C is destructed.\n");
+    B::xx (0);
+    if (doit) A::xx (1);
+  }
+};
+
+void fooA(A *a) {
+  printf ("Casting to A!\n");
+  a->xx (1);
+}
+void fooA1(A1 *a) {
+  printf ("Casting to A1!\n");
+  a->xx (1);
+}
+
+void fooB(B *b) {
+  printf ("Casting to B!\n");
+  b->xx (1);
+}
+
+void fooC(C *c) {
+  printf ("Casting to C!\n");
+  c->xx (1);
+}
+
+int main(int argc, char *argv[]) {
+  printf ("*** Construct C object!\n");
+  C *c = new C();
+
+  int i = 0;
+
+  printf ("*** Try to delete the casting pointer!\n");
+  switch (i)
+    {
+    case 0: fooA1(c);
+      break;
+    case 1: fooA(c);
+      break;
+    case 2: fooB(c);
+      break;
+    case 3: fooC(c);
+      break;
+    }
+
+  return num!=0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3708b.C b/gcc/testsuite/g++.old-deja/g++.mike/p3708b.C
new file mode 100644
index 00000000000..42510074be3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3708b.C
@@ -0,0 +1,85 @@
+// prms-id: 3708
+
+extern "C" void printf (char *, ...);
+extern "C" void exit(int);
+
+void *ptr;
+
+class A {
+public:
+  A() { printf ("A is constructed.\n"); }
+  virtual void xx(int doit) { printf ("A is destructed.\n"); }
+};
+
+class A1 {
+public:
+  A1() { printf ("A1 is constructed.\n"); }
+  virtual void xx(int doit) { printf ("A1 is destructed.\n"); }
+};
+
+class B : public virtual A, public A1 {
+public:
+  B() { printf ("B is constructed.\n"); }
+  virtual void xx(int doit) {
+    printf ("B is destructed.\n");
+    A1::xx (1);
+    if (doit) A::xx (1);
+  }
+};
+
+int num;
+
+class C : public virtual A {
+public:
+  C() { printf ("C is constructed.\n");
+      }
+  virtual void xx(int doit) {
+    printf ("C is destructed.\n");
+    if (doit) A::xx (1);
+  }
+};
+
+class D : public C, public B {
+public:
+  D() { ++num; printf ("D is constructed.\n");
+      ptr = this;
+      }
+  virtual void xx(int doit) {
+    --num;
+    if (ptr != this) {
+      printf("FAIL\n%x != %x\n", ptr, this);
+      exit(1);
+    }
+    printf ("D is destructed.\n");
+    C::xx (0);
+    B::xx (0);
+  }
+};
+
+void fooA(A *a) {
+  printf ("Casting to A!\n");
+  a->xx (1);
+}
+void fooA1(A1 *a) {
+  printf ("Casting to A1!\n");
+  a->xx (1);
+}
+
+void fooB(B *b) {
+  printf ("Casting to B!\n");
+  b->xx (1);
+}
+
+void fooC(C *c) {
+  printf ("Casting to C!\n");
+  c->xx (1);
+}
+
+int main(int argc, char *argv[]) {
+  printf ("*** Construct D object!\n");
+  D *d = new D();
+
+  printf ("*** Try to delete the casting pointer!\n");
+  fooA1(d);
+  return num!=0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3764.C b/gcc/testsuite/g++.old-deja/g++.mike/p3764.C
new file mode 100644
index 00000000000..d0527555563
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3764.C
@@ -0,0 +1,25 @@
+// Build don't link:
+// prms-id: 3764
+
+class Menu;
+class MenuItem;
+
+class  MenuAction {
+public:
+  virtual void execute (Menu& menu, MenuItem& menuItem)  = 0;
+protected:
+  MenuAction () {}
+}; 
+
+class Test {
+  class MenuCBA : public MenuAction {
+  public:
+    typedef void (Test::* MenuCBA_Member) (Menu& menu, MenuItem& menuItem) ;
+    MenuCBA(Test& instance, MenuCBA_Member member)
+      : _instance(&instance), _member(member) { }
+    void execute(Menu& menu, MenuItem& menuItem);
+  private:
+    MenuCBA_Member _member;
+    Test *_instance;
+  };  
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p3836.C b/gcc/testsuite/g++.old-deja/g++.mike/p3836.C
new file mode 100644
index 00000000000..c62530f6906
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p3836.C
@@ -0,0 +1,14 @@
+// prms-id: 3836
+
+void f(int &i) {	// ERROR - ref line
+  i = 10;
+}
+
+int main()
+{
+  int i=1, j=2;
+  f(i);
+  f((int)j);		// ERROR - passing in to non-const
+  if (j != 2)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4068.C b/gcc/testsuite/g++.old-deja/g++.mike/p4068.C
new file mode 100644
index 00000000000..fbdf02e2a9e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4068.C
@@ -0,0 +1,22 @@
+// prms-id: 4068
+
+struct A {
+  A();
+  typedef void (A::*F)();
+  void d();
+  void foo() { }
+  F& f() { return f_; }
+  F f_;
+};
+
+A::A() : f_(&A::foo) {
+}
+
+void A::d() {
+  (this->*(f()))();
+}
+
+int main() {
+  A a;
+  a.d();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4104.C b/gcc/testsuite/g++.old-deja/g++.mike/p4104.C
new file mode 100644
index 00000000000..7559034779a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4104.C
@@ -0,0 +1,15 @@
+// prms-id: 4104
+
+template <class T>
+void F(T &a, void (*P)(T &temp)) {
+  (*P)(a);
+}
+
+template <class T>
+void G(T &a) {
+}
+
+int main() {
+  int a;
+  F(a, G);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4173.C b/gcc/testsuite/g++.old-deja/g++.mike/p4173.C
new file mode 100644
index 00000000000..7d07ffd26b5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4173.C
@@ -0,0 +1,26 @@
+// This error happens because lvalue is not done well in the C++ front-end.
+// NOPs should be lvalues if their arguments are.
+// NON_LVALUE_EXPRs shouldn't be.
+
+// Special g++ Options: -Wall -ansi -pedantic-errors
+// Build don't link:
+// prms-id: 4173
+
+enum TypeKind {
+    RecordTypeKind
+};
+struct Type
+{
+    enum TypeKind kind : 8;
+    unsigned char prefixLen;  
+};
+
+Type a;
+Type b;
+TypeKind c;
+
+int
+main() {
+  a.kind = b.kind = c;
+  (a.kind = c) = b.kind;	// gets bogus error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p418.C b/gcc/testsuite/g++.old-deja/g++.mike/p418.C
new file mode 100644
index 00000000000..6e868c7ec0d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p418.C
@@ -0,0 +1,18 @@
+// Build don't link:
+// prms-id: 418
+
+class Base {
+public:
+	int foo;
+};
+
+class Derived : public Base {
+public:
+	int bar;
+};
+
+void func(Base&);		// ERROR - referenced by error below
+
+void func2(const Derived& d) {
+	func(d);		// ERROR - should be error because of const
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4238.C b/gcc/testsuite/g++.old-deja/g++.mike/p4238.C
new file mode 100644
index 00000000000..2499a6d4015
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4238.C
@@ -0,0 +1,7 @@
+// This showed a problem with default op=
+// Build don't link:
+// prms-id: 4238
+
+struct sigcontext {
+  int sc_wbuf[31][25];
+};		// gets bogus error - default op= seems broken
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4246.C b/gcc/testsuite/g++.old-deja/g++.mike/p4246.C
new file mode 100644
index 00000000000..a610f70717b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4246.C
@@ -0,0 +1,48 @@
+// prms-id: 4246
+
+extern "C" void abort ();
+int num_d;
+
+class A
+{
+ public:
+  A() { }
+  virtual  ~A() { }
+  virtual void id() { }
+};
+
+class B
+{
+ public:
+  B() { }
+  virtual  ~B() { }
+  virtual void id() { }
+};
+
+class C : public A, public B
+{
+ public:
+  C() { }
+  virtual  ~C() { }
+  void id() { abort(); }
+};
+
+class D : public C
+{
+ public:
+  D() { ++num_d; }
+  virtual  ~D() { -- num_d; }
+  void id() { }
+};
+
+int main()
+{
+  D* dp2 = new D;
+  ((B*)dp2)->id();
+  delete (B*) dp2;
+
+  B* bp1 = new D;
+  bp1->id();
+  delete bp1;
+  return num_d != 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4263.C b/gcc/testsuite/g++.old-deja/g++.mike/p4263.C
new file mode 100644
index 00000000000..65d5150c751
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4263.C
@@ -0,0 +1,14 @@
+// prms-id: 4263
+
+enum OT {A_type, B_Type};
+enum AT {A, B};
+
+/* These are not ok. */
+OT t = A;	// ERROR - 
+OT e2 = 1;	// ERROR - 
+OT e3 = 1.1;	// ERROR - 
+
+/* These are ok. */
+int i = A;
+double d = A;
+OT e4 = A_type;
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p438.C b/gcc/testsuite/g++.old-deja/g++.mike/p438.C
new file mode 100644
index 00000000000..9afab638abc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p438.C
@@ -0,0 +1,23 @@
+// Build don't link:
+// prms-id: 438
+
+class D;
+
+class C
+{
+   public:
+   void test() const;
+};
+
+class D
+{
+   public:
+   void a(C& b); // ERROR - referenced below
+};
+
+void C::test() const
+{
+   D d;
+
+   d.a(*this);	// ERROR - *this is const, so should get error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4484.C b/gcc/testsuite/g++.old-deja/g++.mike/p4484.C
new file mode 100644
index 00000000000..64aab160965
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4484.C
@@ -0,0 +1,26 @@
+// Build don't link:
+// prms-id: 4484
+
+class A {
+  char buf[64];
+};
+
+typedef void (A::*pmf)();
+typedef void (A::*pmfc)() const;
+
+pmfc p = (pmfc)(pmf)0;
+
+class B {
+};
+
+class D : public A, public B {
+};
+
+typedef int (B::*bmfp)();
+typedef int (D::*dmfp)();
+
+bmfp foo;
+
+void bar(dmfp a) {
+  bar(foo);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4511.C b/gcc/testsuite/g++.old-deja/g++.mike/p4511.C
new file mode 100644
index 00000000000..e8555da88d7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4511.C
@@ -0,0 +1,33 @@
+// prms-id: 4511
+
+int bad;
+
+class A {
+public:
+  virtual void dummy (){};
+};
+
+class B {
+public:
+  virtual void f(void) = 0;
+};
+
+class C : public A, public B {
+public:
+  void f(void) { bad=1; };
+};
+
+class D : public C {
+public:
+  void f(void) { };
+};
+
+class E : public D { };
+
+int main() {
+  E e;
+  e.f();
+  E * ep = &e;
+  ep->f();
+  return bad;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4619.C b/gcc/testsuite/g++.old-deja/g++.mike/p4619.C
new file mode 100644
index 00000000000..8b772581c66
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4619.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// prms-id: 4619
+
+int main() {
+  int i = 3;
+  int (*p)[10] = new int [20][10];
+  int (*p1)[5][7][13][10] = new int [i][5][7][13][10];
+  delete [] p1;
+  delete [] p;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4623.C b/gcc/testsuite/g++.old-deja/g++.mike/p4623.C
new file mode 100644
index 00000000000..00ab5761116
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4623.C
@@ -0,0 +1,35 @@
+// prms-id: 4623
+
+class base {
+public:
+  int b_data;
+  base( int i=0 ) { b_data = i; }
+  void b_print() { }
+};
+
+class base1: virtual public base {
+public:
+  int b1_data;
+  base1( int i = 0 ) { b1_data = i; b_data++; }
+  void b1_print() { }
+};
+
+class base2: virtual public base {
+public:
+  int b2_data;
+  base2( int i = 0 ) { b2_data = i; b_data++; }
+  void b2_print() { }
+};
+
+class base3: public base {};
+
+class derived: public base3, public base1, public base2 {
+public:
+  int d_data;
+  derived( int i ) { d_data = i; base3::b_data++; }
+  void d_print() { }
+};
+
+int main() {
+  derived d(1); d.d_print(); return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4667.C b/gcc/testsuite/g++.old-deja/g++.mike/p4667.C
new file mode 100644
index 00000000000..751a5666103
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4667.C
@@ -0,0 +1,31 @@
+// prms-id: 4667
+
+int counter = 0;
+int a = 0;
+int b = 0;
+int c = 0;
+
+struct A {
+  A() { a = counter++; }
+};
+
+struct B {
+  B() { b = counter++; }
+};
+
+struct C : public virtual B {
+  C() { c = counter++; }
+};
+
+struct D : public virtual A, public virtual C { };
+
+extern "C" int printf(const char*,...);
+int main(void) {
+  D d;
+
+  if (!(a == 0 && b == 1 && c == 2)) {
+    return 1;
+  }
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4671.C b/gcc/testsuite/g++.old-deja/g++.mike/p4671.C
new file mode 100644
index 00000000000..68f3ee16c0c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4671.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// prms-id: 4671
+
+class ccUnwind {
+public:
+  virtual void _c_getInfo() const;
+  virtual ~ccUnwind ();
+};
+class ccTransmittable {
+public:
+  virtual ~ccTransmittable();
+};
+class ccCommand : public ccUnwind, public ccTransmittable {
+};
+class foo : public ccCommand {
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4677.C b/gcc/testsuite/g++.old-deja/g++.mike/p4677.C
new file mode 100644
index 00000000000..463033caec3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4677.C
@@ -0,0 +1,9 @@
+// Build don't link:
+// prms-id: 4677
+
+struct A {
+  A(double d) { }
+};
+
+struct B { B(A) { } } bad = 1;		// ERROR - 
+B good (1);
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4693.C b/gcc/testsuite/g++.old-deja/g++.mike/p4693.C
new file mode 100644
index 00000000000..b0d0d88fad3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4693.C
@@ -0,0 +1,24 @@
+// Build don't link:
+// prms-id: 4693
+
+class a {
+public:
+  virtual ~a();
+};
+
+class b {
+public:
+  virtual void set_var() = 0;
+};
+
+class c : public b, public a { };
+
+class d : public c {
+public:
+  void set_var() { }
+};
+
+int main() {
+  d * test;
+  test = new d;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4736a.C b/gcc/testsuite/g++.old-deja/g++.mike/p4736a.C
new file mode 100644
index 00000000000..a6e3aef88e7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4736a.C
@@ -0,0 +1,39 @@
+// prms-id: 4736
+
+int did_fail = 1;
+
+class O {
+public:
+  virtual void of() { }
+};
+
+class A : public O {
+public:
+  virtual void vf() { }
+};
+
+class W {
+public:
+  virtual void vf() { }
+};
+
+class X : public W, public A {
+public:
+  virtual void vf() { }
+};
+
+class Z : public X {
+public:
+  virtual void vf() { did_fail = 0; }
+};
+
+Z sz;
+
+void fail1(W* w) {
+  w->vf();
+}
+
+int main() {
+  fail1 (&sz);
+  return did_fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4736b.C b/gcc/testsuite/g++.old-deja/g++.mike/p4736b.C
new file mode 100644
index 00000000000..0978f0bb63b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4736b.C
@@ -0,0 +1,48 @@
+// prms-id: 4736
+
+class Rep {
+public:
+  virtual int foo() { return 1; }
+};
+
+class Rep_1 : public Rep {
+};
+
+class VBaseMain {
+public:
+  virtual int foo() { return 2; }
+};
+
+class OtherVBase {
+public:
+  virtual int foo() { return 3; }
+};
+
+class Rep_2 : public Rep {
+};
+
+class DVBase : public VBaseMain, public Rep_2, public OtherVBase {
+public:
+  virtual int foo() { return 4; }
+};
+
+class Main : public Rep_1, virtual public DVBase {
+public:
+  virtual int foo() { return 5; }
+};
+
+int main() {
+  Main m;
+  if (m.foo() != 5)
+    return 1;
+  if (((Rep*)(Rep_1*)&m)->foo() != 5)
+    return 2;
+  if (((DVBase*)&m)->foo() != 5)
+    return 3;
+  if (((VBaseMain*)(DVBase*)&m)->foo() != 5)
+    return 4;
+  if (((Rep*)(Rep_2*)(DVBase*)&m)->foo() != 5)
+    return 5;
+  if (((OtherVBase*)(DVBase*)&m)->foo() != 5)
+    return 6;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4736c.C b/gcc/testsuite/g++.old-deja/g++.mike/p4736c.C
new file mode 100644
index 00000000000..f76b06af1cd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4736c.C
@@ -0,0 +1,62 @@
+// prms-id: 4736
+
+int did_fail;
+
+class Rep {
+public:
+  virtual ~Rep() { }
+};
+
+class Rep_1 : public Rep {
+};
+
+class VBaseMain {
+public:
+  virtual ~VBaseMain() { }
+};
+
+class OtherVBase {
+public:
+  virtual ~OtherVBase() { }
+};
+
+class Rep_2 : public Rep {
+};
+
+class DVBase : public VBaseMain, public Rep_2, public OtherVBase {
+public:
+  virtual ~DVBase() { }
+};
+
+class Main : public Rep_1, virtual public DVBase {
+public:
+  virtual ~Main() { did_fail = 0; }
+};
+
+int main() {
+  Main* m;
+  did_fail = 1;
+  delete new Main;
+  if (did_fail)
+    return 1;
+  did_fail = 1;
+  delete (Rep*)(Rep_1*)new Main;
+  if (did_fail)
+    return 2;
+  did_fail = 1;
+  delete (DVBase*)new Main;
+  if (did_fail)
+    return 3;
+  did_fail = 1;
+  delete (VBaseMain*)(DVBase*)new Main;
+  if (did_fail)
+    return 4;
+  did_fail = 1;
+  delete (Rep*)(Rep_2*)(DVBase*)new Main;
+  if (did_fail)
+    return 5;
+  did_fail = 1;
+  delete (OtherVBase*)(DVBase*)new Main;
+  if (did_fail)
+    return 6;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p4750.C b/gcc/testsuite/g++.old-deja/g++.mike/p4750.C
new file mode 100644
index 00000000000..b404cc05ff4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p4750.C
@@ -0,0 +1,11 @@
+// Build don't link:
+// Skip if not native
+// Special g++ Options: -fpic -pedantic-errors -S
+// prms-id: 4750
+
+extern const int FRAME_VEC_MAX;
+
+const int FRAME_VEC_MAX     = 12;
+int frame_vec_sizes[FRAME_VEC_MAX+1] = {
+        0, 1, 3, 3, 6, 6, 6, 9, 9, 9, 12, 12, 12
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p5469.C b/gcc/testsuite/g++.old-deja/g++.mike/p5469.C
new file mode 100644
index 00000000000..9af20101171
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p5469.C
@@ -0,0 +1,21 @@
+// prms-id: 5469
+
+int count;
+
+class A {
+  A();
+  A(const A&);
+public:
+  A(int) { ++count; }
+  ~A() { --count; }
+  int operator== (const A& r) { return 0; }
+};
+
+int main() {
+  {
+    A a (1);
+    if (a == 2 && a == 1)
+      ;
+  }
+  return count;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p5469a.C b/gcc/testsuite/g++.old-deja/g++.mike/p5469a.C
new file mode 100644
index 00000000000..0783f77dffe
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p5469a.C
@@ -0,0 +1,21 @@
+// prms-id: 5469
+
+int count;
+
+class A {
+  A();
+  A(const A&);
+public:
+  A(int) { ++count; }
+  ~A() { --count; }
+  int operator== (const A& r) { return 1; }
+};
+
+int main() {
+  {
+    A a (1);
+    if (a == 2 || a == 1)
+      ;
+  }
+  return count;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p5571.C b/gcc/testsuite/g++.old-deja/g++.mike/p5571.C
new file mode 100644
index 00000000000..ec350eacb3a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p5571.C
@@ -0,0 +1,70 @@
+// prms-id: 5571
+
+int err = 0;
+void *vp = 0;
+
+class ParentOne {
+public:
+  ParentOne() {};
+#ifdef MAKE_WORK
+  virtual ~ParentOne() {};
+#endif
+private:
+  char SomeData[101];
+};
+
+class ParentTwo {
+public:
+  ParentTwo() {};
+  virtual ~ParentTwo() {};
+private:
+  int MoreData[12];
+  virtual int foo() { return 0; }
+};
+
+struct Child : public ParentOne, public ParentTwo {
+    int ChildsToy;
+    virtual void PrintThis() = 0;
+};
+
+struct Student : public Child {
+  int StudentsBook;
+  void PrintThis() {
+    if (vp == 0)
+      vp = (void *)this;
+    else
+      {
+	if (vp != (void *)this)
+	  ++err;
+      }
+  }
+  void LocalPrintThis() {
+    if (vp == 0)
+      vp = (void *)this;
+    else
+      {
+	if (vp != (void *)this)
+	  ++err;
+      }
+    PrintThis();
+  }
+  void ForcedPrintThis() {
+    if (vp == 0)
+      vp = (void *)this;
+    else
+      {
+	if (vp != (void *)this)
+	  ++err;
+      }
+    Student::PrintThis();
+  }
+};
+
+int main() {
+  Student  o;
+  o.LocalPrintThis();
+  o.ForcedPrintThis();
+  Child* pX = &o;
+  pX->PrintThis();
+  return err;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p5611.C b/gcc/testsuite/g++.old-deja/g++.mike/p5611.C
new file mode 100644
index 00000000000..557d2cc2baf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p5611.C
@@ -0,0 +1,11 @@
+// prms-id: 5611
+
+int main(void)
+{
+  struct B
+    {
+      virtual void b1() { };
+    };
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p5673.C b/gcc/testsuite/g++.old-deja/g++.mike/p5673.C
new file mode 100644
index 00000000000..d972ab0ceeb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p5673.C
@@ -0,0 +1,20 @@
+// prms-id: 5673
+
+class A {
+public:
+  operator int () {
+    return 7;
+  }
+  ~A();
+};
+
+int foo() {
+  return A();
+}
+
+int main() {
+  return foo() != 7;
+}
+
+A::~A() {
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p5718.C b/gcc/testsuite/g++.old-deja/g++.mike/p5718.C
new file mode 100644
index 00000000000..8858d389ef7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p5718.C
@@ -0,0 +1,37 @@
+// prms-id: 5718
+
+class Base {
+  int i;
+public:
+  Base() { i = 42; };
+};
+
+
+class Mixin {
+  int j;
+public:
+  Mixin() { j = 42; }
+};
+
+
+class Derived : public Base, public Mixin {
+public:
+  Derived() { };
+  Derived & operator=(Mixin & m) { return *this; };
+};
+
+
+void
+testFunct(Derived * arg) {
+  Mixin temp;
+
+  (Mixin &)(*arg) = temp;		// gets bogus error 
+}
+
+
+int
+main(int argc, char *argv[]) {
+  Derived temp;
+
+  testFunct(&temp);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p5793.C b/gcc/testsuite/g++.old-deja/g++.mike/p5793.C
new file mode 100644
index 00000000000..53469cdf07a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p5793.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// prms-id: 5793
+
+class temp_string {
+ public:
+  temp_string (const int);
+  temp_string (const char * const);
+};
+
+class Range { 
+ public:
+  Range ( const int);
+  operator int () const ;
+};
+
+int operator == (const int, temp_string );
+
+void CheckArrayConstraints(void)    { 
+  if (Range(0L) == 0L)
+    ;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p5840.C b/gcc/testsuite/g++.old-deja/g++.mike/p5840.C
new file mode 100644
index 00000000000..34dd37df6c3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p5840.C
@@ -0,0 +1,35 @@
+// prms-id: 5840
+
+class Signal {
+public:
+  int Name(void) { return 1; }
+};
+
+class Derived : public Signal {
+public:
+  int Name(void) { return 2; }
+};
+
+template <class Foo , int (Foo::*Id)(void)>
+class Bar
+{
+public:
+  int value (Foo* a) { return (a->*Id)(); }
+};
+
+/* The following line is illegal under the new rules for non-type
+   template arguments in the standard, so it is commented out.  */
+/* template class Bar <Derived, &Signal::Name>; */
+template class Bar <Signal, &Signal::Name>;
+template class Bar <Derived, &Derived::Name>;
+
+Derived a;
+
+/* Bar<Derived, &Signal::Name> dispatcher1; */
+Bar<Derived, &Derived::Name> dispatcher2;
+
+int main() {
+  /* int i1 = dispatcher1.value(&a); */
+  int i2 = dispatcher2.value(&a);
+  return /* i1 != 1 || */ i2 != 2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p5958.C b/gcc/testsuite/g++.old-deja/g++.mike/p5958.C
new file mode 100644
index 00000000000..20d45f264d0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p5958.C
@@ -0,0 +1,27 @@
+// Special g++ Options: -ansi
+// prms-id: 5958
+
+class A { };
+
+main() {
+  int i = 1;
+  if (1 not_eq 1)
+    return 1;
+  if (not (1 and 1))
+    return 1;
+  if (not (1 or 1))
+    return 1;
+  if (compl ~0)
+    return 1;
+  if (1 bitand 2)
+    return 1;
+  if (not (1 bitor 2))
+    return 1;
+  if (1 xor 1)
+    return 1;
+  i and_eq 1;
+  i or_eq 2;
+  i xor_eq 4;
+  if (i not_eq 7)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6004.C b/gcc/testsuite/g++.old-deja/g++.mike/p6004.C
new file mode 100644
index 00000000000..b692365b12e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6004.C
@@ -0,0 +1,20 @@
+// Special g++ Options: 
+// prms-id: 6004
+
+class A {
+public:
+  static int foo() asm("_my_routine");
+};
+
+int bar1() asm("foo__1A");
+int bar2() asm("_foo__1A");
+int bar3() asm("__foo__1A");
+int bar1() { return 45; }
+int bar2() { return 44; }
+int bar3() { return 43; }
+
+int A::foo() { return 42; }
+
+main() {
+  return A::foo() - 42;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6058.C b/gcc/testsuite/g++.old-deja/g++.mike/p6058.C
new file mode 100644
index 00000000000..1c0c6224ebc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6058.C
@@ -0,0 +1,18 @@
+// Build don't link:
+// Special g++ Options: -fexceptions -pedantic-errors
+// prms-id: 6058
+
+void bar(struct s1 { } a) { (void)a; }			// ERROR - 
+
+struct s2*fooey()
+{
+  try {
+    static_cast<struct s3 { } *>(0);			// ERROR - 
+    const_cast<struct s4 { } *>((s4*)0);		// ERROR - 
+    reinterpret_cast<struct s5 { } *>((s3*)0);		// ERROR - 
+    dynamic_cast<struct s6 { } *>((s6*)0);		// ERROR - 
+    (struct s7 { } *)(int*)0xffedec;			// ERROR - 
+  } catch (struct s8 { } s) {				// ERROR - 
+  }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6149.C b/gcc/testsuite/g++.old-deja/g++.mike/p6149.C
new file mode 100644
index 00000000000..578ee8b643c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6149.C
@@ -0,0 +1,4 @@
+// Build don't link:
+// prms-id: 6149
+
+int a[3 - sizeof(double)];	// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6311.C b/gcc/testsuite/g++.old-deja/g++.mike/p6311.C
new file mode 100644
index 00000000000..a0ef8c8c1fd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6311.C
@@ -0,0 +1,16 @@
+// prms-id: 6311
+
+struct Foo {
+  int member;
+} a = { 42 }, *ptra = &a;
+
+int Foo::*pmd = &Foo::member;
+
+int main() {
+  if (pmd == 0)
+    return 1;
+  if (a.*pmd != 42)
+    return 2;
+  if (ptra->*pmd != 42)
+    return 3;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p646.C b/gcc/testsuite/g++.old-deja/g++.mike/p646.C
new file mode 100644
index 00000000000..2644c1b43df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p646.C
@@ -0,0 +1,175 @@
+// GROUPS passed i960
+/*
+  Bug Id: bnr
+  PMRS Id: p0000646
+  Bug is: Urgent Code Generation Problem in gcc-i960 V 1.95
+*/
+
+
+// Special g++ Options: 
+
+extern "C"
+{
+  void printf (char *, ...);
+  void abort ();
+}
+
+struct foo
+{
+  static int si;
+  int i;
+  foo ();
+  foo (const foo&);
+  ~foo ();
+};
+
+int
+foo_parm_returns_i (foo foo_arg)
+{
+  return foo_arg.i;
+}
+
+int foo::si = 0;
+
+foo::foo ()
+{
+  si++;
+  printf ("new foo @ 0x%x; now %d foos\n", this, si);
+}
+
+foo::foo (const foo &other)
+{
+  si++;
+  printf ("another foo @ 0x%x; now %d foos\n", this, si);
+  *this = other;
+}
+
+foo::~foo ()
+{
+  si--;
+  printf ("deleted foo @ 0x%x; now %d foos\n", this, si);
+}
+
+int
+return_1 ()
+{
+  foo f;
+  printf ("returning 1\n");
+  return 1;
+}
+
+int
+return_arg (int arg)
+{
+  foo f;
+  printf ("returning %d\n", arg);
+  return arg;
+}
+
+int
+return_sum (int x, int y)
+{
+  foo f;
+  printf ("returning %d+%d\n", x, y);
+  return x + y;
+}
+
+foo
+return_foo ()
+{
+  foo f;
+  printf ("returning foo\n");
+  return f;
+}
+
+foo
+return_named_foo () return f
+{
+  printf ("returning named foo\n");
+  return f;
+}
+
+foo
+foo_parm_returns_foo (foo f)
+{
+  return f;
+}
+
+void
+abort_because (char *str)
+{
+  printf ("aborting because %s\n", str);
+  abort ();
+}
+
+int
+warn_return_1 ()
+{
+  foo f;
+  printf ("returning 1\n");
+}
+
+int
+warn_return_arg (int arg)
+{
+  foo f;
+  printf ("returning %d\n", arg);
+  arg;
+}
+
+int
+warn_return_sum (int x, int y)
+{
+  foo f;
+  printf ("returning %d+%d\n", x, y);
+  x + y;
+}
+
+foo
+warn_return_foo ()
+{
+  foo f;
+  printf ("returning foo\n");
+}
+
+foo
+nowarn_return_named_foo () return f
+{
+  printf ("returning named foo\n");
+}
+
+foo
+warn_foo_parm_returns_foo (foo f)
+{
+  f;
+}
+
+main ()
+{
+  int ii = return_1 ();
+  if (ii != 1)
+    abort_because ("wrong value returned");
+  int j = return_arg (42);
+  if (j != 42)
+    abort_because ("wrong value returned");
+  int k = return_sum (-69, 69);
+  if (k != 0)
+    abort_because ("wrong value returned");
+  foo f1 = return_named_foo ();
+  if (foo::si != 1)
+    abort_because ("wrong number of foos");
+  f1.i = 5;
+  int l = foo_parm_returns_i (f1);
+  if (l != 5)
+    abort_because ("l != 5");
+  foo f2 = foo_parm_returns_foo (f1);
+  if (foo::si != 2)
+    abort_because ("wrong number of foos");
+  if (f2.i != 5)
+    abort_because ("f2.i != 5");
+  foo f3 = return_foo ();
+  if (foo::si != 3)
+    abort_because ("wrong number of foos");
+  printf("PASS\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6578.C b/gcc/testsuite/g++.old-deja/g++.mike/p6578.C
new file mode 100644
index 00000000000..2b19e86ddfb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6578.C
@@ -0,0 +1,8 @@
+// Build don't link:
+// prms-id: 6578
+
+struct A {
+  operator int ();
+};
+
+int i = A();
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p658.C b/gcc/testsuite/g++.old-deja/g++.mike/p658.C
new file mode 100644
index 00000000000..14658f04956
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p658.C
@@ -0,0 +1,101 @@
+// prms-id: 658
+
+#include <ostream.h>
+
+extern "C" void abort();
+
+/* We may not find the libg++ <bool.h>.  */
+#ifndef FALSE
+#define FALSE false
+#endif
+#ifndef TRUE
+#define TRUE true
+#endif
+
+class Object {
+public:
+    Object();
+    Object(const Object&);
+    ~Object();
+
+    void OK() const;
+private:
+    bool _destructed;
+};
+
+class Char: public Object {
+public:
+    Char();
+    Char(char);
+    Char(const Char&);
+    ~Char();
+
+    operator char () const;
+private:
+    char _c;
+};
+
+int main()
+{
+    Char r, s;
+
+    r = Char('r');
+    s = Char('s');
+}
+
+//
+// Object stuff
+//
+Object::Object():
+_destructed(FALSE)
+{}
+
+Object::Object(const Object& other):
+_destructed(FALSE)
+{
+    other.OK();
+}
+
+Object::~Object()
+{
+    OK();
+    _destructed = TRUE;
+}
+
+void
+Object::OK() const
+{
+    if (_destructed) {
+	cerr << "FAILURE - reference was made to a destructed object\n";
+	abort();
+    }
+}
+
+//
+// Char stuff
+//
+
+Char::Char():
+Object(),
+_c('a')
+{ }
+
+Char::Char(char c):
+Object(),
+_c(c)
+{ }
+
+Char::Char(const Char& other):
+Object(other),
+_c(other._c)
+{ }
+
+Char::~Char()
+{
+    OK();
+}
+
+Char::operator char () const
+{
+    return _c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6610a.C b/gcc/testsuite/g++.old-deja/g++.mike/p6610a.C
new file mode 100644
index 00000000000..b9ea4b769bb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6610a.C
@@ -0,0 +1,14 @@
+// prms-id: 6610
+// There is a bug in vtable thunks with multiple/virtual inheritance.
+// execution test - XFAIL *-*-linux-gnu *-*-linux
+int fail = 1;
+struct B;
+struct A { virtual int f(const B*) = 0; int g(const B*); };
+int A::g(const B* t) { return f(t); }
+struct B : virtual A { B(); int f(const B*); B* B_this; };
+B::B() { if (g(this)) fail = 0; }
+int B::f(const B* t) { return t == this; }
+struct C : B { int f(const B*); int x; };
+int C::f(const B*) { return 0; }
+
+int main() { C c; return fail; }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6610b.C b/gcc/testsuite/g++.old-deja/g++.mike/p6610b.C
new file mode 100644
index 00000000000..8ec637eef02
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6610b.C
@@ -0,0 +1,14 @@
+// prms-id: 6610
+
+int fail = 1;
+struct B;
+struct A { virtual int f(const B*) = 0; int g(const B*); };
+int A::g(const B* t) { return f(t); }
+struct B : virtual A { int f(const B*); B* B_this; };
+int B::f(const B* t) { return t == this; }
+struct S1 { };
+struct C : virtual S1, virtual B, virtual A { C(); };
+C::C() { if (g(this)) fail = 0; }
+struct D : virtual B, virtual A, C { };
+
+int main() { D d; return fail; }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6611.C b/gcc/testsuite/g++.old-deja/g++.mike/p6611.C
new file mode 100644
index 00000000000..3d972cb8643
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6611.C
@@ -0,0 +1,26 @@
+// prms-id: 6611
+
+class COMPLEX {
+public:
+  COMPLEX(double a, double b=0) { re = a; im = b; }
+  void print() const { }
+private:
+  double re;
+  double im;
+};
+
+int main(void)
+{
+  COMPLEX a[3][3] = {
+    { 1, COMPLEX(2,3), COMPLEX(3,4), },
+    { 1, COMPLEX(2,3), COMPLEX(3,4), },
+    { 1, COMPLEX(2,3), COMPLEX(3,4), },
+  };
+  int i,j;
+
+  for (i = 0; i < 3; i++) {
+    for (j = 0; j < 3; j++) {
+      a[i][j].print();
+    }
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6746.C b/gcc/testsuite/g++.old-deja/g++.mike/p6746.C
new file mode 100644
index 00000000000..764310fc05b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6746.C
@@ -0,0 +1,18 @@
+// Build don't link:
+// prms-id: 6746
+
+class call_trace {
+public:
+  call_trace(char* fcn_name);
+  ~call_trace();
+};
+
+static char * last_tree;
+extern "C" void prt();
+
+char * smt_mark_stree() {
+  char* _my_name = "smt_mark_stree" ; 
+  call_trace _t(_my_name);
+
+  return last_tree = 0 ? (char*)0 : (prt(), (char*)0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6901.C b/gcc/testsuite/g++.old-deja/g++.mike/p6901.C
new file mode 100644
index 00000000000..83292949ca8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6901.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// prms-id: 6901
+
+void green() {
+  for (int i = 0; i < 10; i++) {}
+  for (int i = 0; i < 10; i++) {}
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p6927.C b/gcc/testsuite/g++.old-deja/g++.mike/p6927.C
new file mode 100644
index 00000000000..7a0ec4229c7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p6927.C
@@ -0,0 +1,16 @@
+// prms-id: 6927
+
+class Object {
+public:
+  Object();
+  int Value;
+};
+
+Object::Object() : Value(-1) { }
+
+Object *pArr = new Object[2];
+
+int main() {
+  if (pArr[0].Value != -1 || pArr[1].Value != -1)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p700.C b/gcc/testsuite/g++.old-deja/g++.mike/p700.C
new file mode 100644
index 00000000000..580895e557b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p700.C
@@ -0,0 +1,2387 @@
+// Special g++ Options:
+// prms-id: 700
+
+//# 1 "../../../../libg++/etc/benchmarks/dhrystone.cc"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 1 "../../../../libg++/etc/benchmarks/Int.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+class Int
+{
+protected:
+  int          rep;
+
+
+
+public:
+               Int ();
+               Int (const int  b);
+               Int (const Int& b);
+              ~Int();
+
+               operator int() const;
+
+  inline virtual  int   val() const;
+
+  inline virtual  void  operator  = (const int);
+  inline virtual  void  operator  = (const Int&);
+
+  inline virtual  void  negate();
+  inline virtual  void  complement();
+  inline virtual  void  operator ++ ();
+  inline virtual  void  operator -- ();
+
+  inline virtual  void  operator += (const Int &  );
+  inline virtual  void  operator -= (const Int &  );
+  inline virtual  void  operator *= (const Int &  );
+  inline virtual  void  operator /= (const Int &  );
+  inline virtual  void  operator %= (const Int &  );
+  inline virtual  void  operator |= (const Int &  );
+  inline virtual  void  operator &= (const Int &  );
+  inline virtual  void  operator ^= (const Int &  );
+  inline virtual  void  operator <<=(const Int &  );
+  inline virtual  void  operator >>=(const Int &  );
+
+
+  inline virtual  void  operator += (const int);
+  inline virtual  void  operator -= (const int);
+  inline virtual  void  operator *= (const int);
+  inline virtual  void  operator /= (const int);
+  inline virtual  void  operator %= (const int);
+  inline virtual  void  operator |= (const int);
+  inline virtual  void  operator &= (const int);
+  inline virtual  void  operator ^= (const int);
+  inline virtual  void  operator <<=(const int);
+  inline virtual  void  operator >>=(const int);
+
+
+};
+
+inline  int  Int::val() const { return rep; }
+inline       Int::operator int() const { return val(); }
+
+inline       Int::Int () :rep(0) {}
+inline       Int::Int (const int  b) :rep(b) {}
+inline       Int::Int (const Int& b) :rep(b.Int::val()) {}
+inline       Int::~Int() {}
+
+inline  void  Int::operator  = (const int  b)
+{ rep = b;  ; }
+inline  void  Int::operator  = (const Int&  b)
+{ rep = b.Int::val();  ; }
+
+inline  void  Int::complement()
+{ rep = ~rep;  ; }
+inline  void  Int::negate()
+{ rep = -rep;  ; }
+inline  void  Int::operator ++ ()
+{ ++rep;  ; }
+inline  void  Int::operator -- ()
+{ --rep;  ; }
+
+inline  void  Int::operator += (const Int &   b)
+{ rep += b.Int::val();  ; }
+inline  void  Int::operator -= (const Int &   b)
+{ rep -= b.Int::val();  ; }
+inline  void  Int::operator *= (const Int &   b)
+{ rep *= b.Int::val();  ; }
+inline  void  Int::operator /= (const Int &   b)
+{ rep /= b.Int::val();  ; }
+inline  void  Int::operator %= (const Int &   b)
+{ rep %= b.Int::val();  ; }
+inline  void  Int::operator |= (const Int &   b)
+{ rep |= b.Int::val();  ; }
+inline  void  Int::operator &= (const Int &   b)
+{ rep &= b.Int::val();  ; }
+inline  void  Int::operator ^= (const Int &   b)
+{ rep ^= b.Int::val();  ; }
+inline  void  Int::operator <<=(const Int &   b)
+{ rep <<= b.Int::val();  ; }
+inline  void  Int::operator >>=(const Int &   b)
+{ rep >>= b.Int::val();  ; }
+
+
+
+inline  void  Int::operator += (const int b)
+{ rep += b;  ; }
+inline  void  Int::operator -= (const int b)
+{ rep -= b;  ; }
+inline  void  Int::operator *= (const int b)
+{ rep *= b;  ; }
+inline  void  Int::operator /= (const int b)
+{ rep /= b;  ; }
+inline  void  Int::operator %= (const int b)
+{ rep %= b;  ; }
+inline  void  Int::operator |= (const int b)
+{ rep |= b;  ; }
+inline  void  Int::operator &= (const int b)
+{ rep &= b;  ; }
+inline  void  Int::operator ^= (const int b)
+{ rep ^= b;  ; }
+inline  void  Int::operator <<=(const int b)
+{ rep <<= b;  ; }
+inline  void  Int::operator >>=(const int b)
+{ rep >>= b;  ; }
+
+
+inline  int& operator  = (int& a,  const Int &   b)
+{ a = b.Int::val(); return a;}	// WARNING - 
+inline  int& operator += (int& a,  const Int &   b)
+{ a += b.Int::val(); return a; }
+inline  int& operator -= (int& a,  const Int &   b)
+{ a -= b.Int::val(); return a;}
+inline  int& operator *= (int& a,  const Int &   b)
+{ a *= b.Int::val(); return a;}
+inline  int& operator /= (int& a,  const Int &   b)
+{ a /= b.Int::val(); return a;}
+inline  int& operator %= (int& a,  const Int &   b)
+{ a %= b.Int::val(); return a;}
+inline  int& operator |= (int& a,  const Int &   b)
+{ a |= b.Int::val(); return a;}
+inline  int& operator &= (int& a,  const Int &   b)
+{ a &= b.Int::val(); return a;}
+inline  int& operator ^= (int& a,  const Int &   b)
+{ a ^= b.Int::val(); return a;}
+inline  int& operator <<=(int& a,  const Int &   b)
+{ a <<= b.Int::val(); return a;}
+inline  int& operator >>=(int& a,  const Int &   b)
+{ a >>= b.Int::val(); return a;}
+
+
+
+//# 289 "../../../../libg++/etc/benchmarks/Int.h"
+
+
+inline  Int  operator -  (const Int &   a) return r(a)
+{ r.negate();  }
+inline  Int  operator ~  (const Int &   a) return r(a)
+{ r.complement();  }
+
+inline  Int  operator +  (const Int &   a, const Int &   b) return r(a)
+{ r += b.Int::val();  }
+inline  Int  operator -  (const Int &   a, const Int &   b) return r(a)
+{ r -= b.Int::val();  }
+inline  Int  operator *  (const Int &   a, const Int &   b) return r(a)
+{ r *= b.Int::val();  }
+inline  Int  operator /  (const Int &   a, const Int &   b) return r(a)
+{ r /= b.Int::val();  }
+inline  Int  operator %  (const Int &   a, const Int &   b) return r(a)
+{ r %= b.Int::val();  }
+inline  Int  operator << (const Int &   a, const Int &   b) return r(a)
+{ r <<= b.Int::val();  }
+inline  Int  operator >> (const Int &   a, const Int &   b) return r(a)
+{ r >>= b.Int::val();  }
+inline  Int  operator &  (const Int &   a, const Int &   b) return r(a)
+{ r &= b.Int::val();  }
+inline  Int  operator |  (const Int &   a, const Int &   b) return r(a)
+{ r |= b.Int::val();  }
+inline  Int  operator ^  (const Int &   a, const Int &   b) return r(a)
+{ r ^= b.Int::val();  }
+
+inline  Int  operator +  (const Int &   a, const int b) return r(a)
+{ r += b;  }
+inline  Int  operator -  (const Int &   a, const int b) return r(a)
+{ r -= b;  }
+inline  Int  operator *  (const Int &   a, const int b) return r(a)
+{ r *= b;  }
+inline  Int  operator /  (const Int &   a, const int b) return r(a)
+{ r /= b;  }
+inline  Int  operator %  (const Int &   a, const int b) return r(a)
+{ r %= b;  }
+inline  Int  operator << (const Int &   a, const int b) return r(a)
+{ r <<= b;  }
+inline  Int  operator >> (const Int &   a, const int b) return r(a)
+{ r >>= b;  }
+inline  Int  operator &  (const Int &   a, const int b) return r(a)
+{ r &= b;  }
+inline  Int  operator |  (const Int &   a, const int b) return r(a)
+{ r |= b;  }
+inline  Int  operator ^  (const Int &   a, const int b) return r(a)
+{ r ^= b;  }
+
+inline  Int  operator +  (const int a, const Int &   b) return r(a)
+{ r += b.Int::val();  }
+inline  Int  operator -  (const int a, const Int &   b) return r(a)
+{ r -= b.Int::val();  }
+inline  Int  operator *  (const int a, const Int &   b) return r(a)
+{ r *= b.Int::val();  }
+inline  Int  operator /  (const int a, const Int &   b) return r(a)
+{ r /= b.Int::val();  }
+inline  Int  operator %  (const int a, const Int &   b) return r(a)
+{ r %= b.Int::val();  }
+inline  Int  operator << (const int a, const Int &   b) return r(a)
+{ r <<= b.Int::val();  }
+inline  Int  operator >> (const int a, const Int &   b) return r(a)
+{ r >>= b.Int::val();  }
+inline  Int  operator &  (const int a, const Int &   b) return r(a)
+{ r &= b.Int::val();  }
+inline  Int  operator |  (const int a, const Int &   b) return r(a)
+{ r |= b.Int::val();  }
+inline  Int  operator ^  (const int a, const Int &   b) return r(a)
+{ r ^= b.Int::val();  }
+
+
+
+inline  int  operator !  (const Int &   a) { return !a.Int::val(); }
+
+inline  int  operator == (const Int &   a, const Int &   b)
+{ return a.Int::val() == b.Int::val(); }
+inline  int  operator != (const Int &   a, const Int &   b)
+{ return a.Int::val() != b.Int::val(); }
+inline  int  operator <  (const Int &   a, const Int &   b)
+{ return a.Int::val() <  b.Int::val(); }
+inline  int  operator <= (const Int &   a, const Int &   b)
+{ return a.Int::val() <= b.Int::val(); }
+inline  int  operator >  (const Int &   a, const Int &   b)
+{ return a.Int::val() >  b.Int::val(); }
+inline  int  operator >= (const Int &   a, const Int &   b)
+{ return a.Int::val() >= b.Int::val(); }
+
+inline  int  operator == (const Int &   a, const int b)
+{ return a.Int::val() == b; }
+inline  int  operator != (const Int &   a, const int b)
+{ return a.Int::val() != b; }
+inline  int  operator <  (const Int &   a, const int b)
+{ return a.Int::val() <  b; }
+inline  int  operator <= (const Int &   a, const int b)
+{ return a.Int::val() <= b; }
+inline  int  operator >  (const Int &   a, const int b)
+{ return a.Int::val() >  b; }
+inline  int  operator >= (const Int &   a, const int b)
+{ return a.Int::val() >= b; }
+
+inline  int  operator == (const int a, const Int &   b)
+{ return a == b.Int::val(); }
+inline  int  operator != (const int a, const Int &   b)
+{ return a != b.Int::val(); }
+inline  int  operator <  (const int a, const Int &   b)
+{ return a <  b.Int::val(); }
+inline  int  operator <= (const int a, const Int &   b)
+{ return a <= b.Int::val(); }
+inline  int  operator >  (const int a, const Int &   b)
+{ return a >  b.Int::val(); }
+inline  int  operator >= (const int a, const Int &   b)
+{ return a >= b.Int::val(); }
+
+
+
+//# 26 "../../../../libg++/etc/benchmarks/dhrystone.cc" 2
+
+//# 1 "../../../../libg++/etc/benchmarks/Char.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+class Char
+{
+protected:
+  char          rep;
+
+
+
+public:
+               Char ();
+               Char (const char  b);
+               Char (const Char& b);
+              ~Char();
+
+               operator char() const;
+
+  inline virtual  char   val() const;
+
+  inline virtual  void  operator  = (const char);
+  inline virtual  void  operator  = (const Char&);
+
+  inline virtual  void  negate();
+  inline virtual  void  complement();
+  inline virtual  void  operator ++ ();
+  inline virtual  void  operator -- ();
+
+  inline virtual  void  operator += (const Char &  );
+  inline virtual  void  operator -= (const Char &  );
+  inline virtual  void  operator *= (const Char &  );
+  inline virtual  void  operator /= (const Char &  );
+  inline virtual  void  operator %= (const Char &  );
+  inline virtual  void  operator |= (const Char &  );
+  inline virtual  void  operator &= (const Char &  );
+  inline virtual  void  operator ^= (const Char &  );
+  inline virtual  void  operator <<=(const Char &  );
+  inline virtual  void  operator >>=(const Char &  );
+
+
+  inline virtual  void  operator += (const char);
+  inline virtual  void  operator -= (const char);
+  inline virtual  void  operator *= (const char);
+  inline virtual  void  operator /= (const char);
+  inline virtual  void  operator %= (const char);
+  inline virtual  void  operator |= (const char);
+  inline virtual  void  operator &= (const char);
+  inline virtual  void  operator ^= (const char);
+  inline virtual  void  operator <<=(const char);
+  inline virtual  void  operator >>=(const char);
+
+
+};
+
+inline  char  Char::val() const { return rep; }
+inline       Char::operator char() const { return val(); }
+
+inline       Char::Char () :rep(0) {}
+inline       Char::Char (const char  b) :rep(b) {}
+inline       Char::Char (const Char& b) :rep(b.Char::val()) {}
+inline       Char::~Char() {}
+
+inline  void  Char::operator  = (const char  b)
+{ rep = b;  ; }
+inline  void  Char::operator  = (const Char&  b)
+{ rep = b.Char::val();  ; }
+
+inline  void  Char::complement()
+{ rep = ~rep;  ; }
+inline  void  Char::negate()
+{ rep = -rep;  ; }
+inline  void  Char::operator ++ ()
+{ ++rep;  ; }
+inline  void  Char::operator -- ()
+{ --rep;  ; }
+
+inline  void  Char::operator += (const Char &   b)
+{ rep += b.Char::val();  ; }
+inline  void  Char::operator -= (const Char &   b)
+{ rep -= b.Char::val();  ; }
+inline  void  Char::operator *= (const Char &   b)
+{ rep *= b.Char::val();  ; }
+inline  void  Char::operator /= (const Char &   b)
+{ rep /= b.Char::val();  ; }
+inline  void  Char::operator %= (const Char &   b)
+{ rep %= b.Char::val();  ; }
+inline  void  Char::operator |= (const Char &   b)
+{ rep |= b.Char::val();  ; }
+inline  void  Char::operator &= (const Char &   b)
+{ rep &= b.Char::val();  ; }
+inline  void  Char::operator ^= (const Char &   b)
+{ rep ^= b.Char::val();  ; }
+inline  void  Char::operator <<=(const Char &   b)
+{ rep <<= b.Char::val();  ; }
+inline  void  Char::operator >>=(const Char &   b)
+{ rep >>= b.Char::val();  ; }
+
+
+
+inline  void  Char::operator += (const char b)
+{ rep += b;  ; }
+inline  void  Char::operator -= (const char b)
+{ rep -= b;  ; }
+inline  void  Char::operator *= (const char b)
+{ rep *= b;  ; }
+inline  void  Char::operator /= (const char b)
+{ rep /= b;  ; }
+inline  void  Char::operator %= (const char b)
+{ rep %= b;  ; }
+inline  void  Char::operator |= (const char b)
+{ rep |= b;  ; }
+inline  void  Char::operator &= (const char b)
+{ rep &= b;  ; }
+inline  void  Char::operator ^= (const char b)
+{ rep ^= b;  ; }
+inline  void  Char::operator <<=(const char b)
+{ rep <<= b;  ; }
+inline  void  Char::operator >>=(const char b)
+{ rep >>= b;  ; }
+
+
+inline  char& operator  = (char& a,  const Char &   b)
+{ a = b.Char::val(); return a;}	// WARNING - 
+inline  char& operator += (char& a,  const Char &   b)
+{ a += b.Char::val(); return a; }
+inline  char& operator -= (char& a,  const Char &   b)
+{ a -= b.Char::val(); return a;}
+inline  char& operator *= (char& a,  const Char &   b)
+{ a *= b.Char::val(); return a;}
+inline  char& operator /= (char& a,  const Char &   b)
+{ a /= b.Char::val(); return a;}
+inline  char& operator %= (char& a,  const Char &   b)
+{ a %= b.Char::val(); return a;}
+inline  char& operator |= (char& a,  const Char &   b)
+{ a |= b.Char::val(); return a;}
+inline  char& operator &= (char& a,  const Char &   b)
+{ a &= b.Char::val(); return a;}
+inline  char& operator ^= (char& a,  const Char &   b)
+{ a ^= b.Char::val(); return a;}
+inline  char& operator <<=(char& a,  const Char &   b)
+{ a <<= b.Char::val(); return a;}
+inline  char& operator >>=(char& a,  const Char &   b)
+{ a >>= b.Char::val(); return a;}
+
+
+
+//# 291 "../../../../libg++/etc/benchmarks/Char.h"
+
+
+inline  Char  operator -  (const Char &   a) return r(a)
+{ r.negate();  }
+inline  Char  operator ~  (const Char &   a) return r(a)
+{ r.complement();  }
+
+inline  Char  operator +  (const Char &   a, const Char &   b) return r(a)
+{ r += b.Char::val();  }
+inline  Char  operator -  (const Char &   a, const Char &   b) return r(a)
+{ r -= b.Char::val();  }
+inline  Char  operator *  (const Char &   a, const Char &   b) return r(a)
+{ r *= b.Char::val();  }
+inline  Char  operator /  (const Char &   a, const Char &   b) return r(a)
+{ r /= b.Char::val();  }
+inline  Char  operator %  (const Char &   a, const Char &   b) return r(a)
+{ r %= b.Char::val();  }
+inline  Char  operator << (const Char &   a, const Char &   b) return r(a)
+{ r <<= b.Char::val();  }
+inline  Char  operator >> (const Char &   a, const Char &   b) return r(a)
+{ r >>= b.Char::val();  }
+inline  Char  operator &  (const Char &   a, const Char &   b) return r(a)
+{ r &= b.Char::val();  }
+inline  Char  operator |  (const Char &   a, const Char &   b) return r(a)
+{ r |= b.Char::val();  }
+inline  Char  operator ^  (const Char &   a, const Char &   b) return r(a)
+{ r ^= b.Char::val();  }
+
+inline  Char  operator +  (const Char &   a, const char b) return r(a)
+{ r += b;  }
+inline  Char  operator -  (const Char &   a, const char b) return r(a)
+{ r -= b;  }
+inline  Char  operator *  (const Char &   a, const char b) return r(a)
+{ r *= b;  }
+inline  Char  operator /  (const Char &   a, const char b) return r(a)
+{ r /= b;  }
+inline  Char  operator %  (const Char &   a, const char b) return r(a)
+{ r %= b;  }
+inline  Char  operator << (const Char &   a, const char b) return r(a)
+{ r <<= b;  }
+inline  Char  operator >> (const Char &   a, const char b) return r(a)
+{ r >>= b;  }
+inline  Char  operator &  (const Char &   a, const char b) return r(a)
+{ r &= b;  }
+inline  Char  operator |  (const Char &   a, const char b) return r(a)
+{ r |= b;  }
+inline  Char  operator ^  (const Char &   a, const char b) return r(a)
+{ r ^= b;  }
+
+inline  Char  operator +  (const char a, const Char &   b) return r(a)
+{ r += b.Char::val();  }
+inline  Char  operator -  (const char a, const Char &   b) return r(a)
+{ r -= b.Char::val();  }
+inline  Char  operator *  (const char a, const Char &   b) return r(a)
+{ r *= b.Char::val();  }
+inline  Char  operator /  (const char a, const Char &   b) return r(a)
+{ r /= b.Char::val();  }
+inline  Char  operator %  (const char a, const Char &   b) return r(a)
+{ r %= b.Char::val();  }
+inline  Char  operator << (const char a, const Char &   b) return r(a)
+{ r <<= b.Char::val();  }
+inline  Char  operator >> (const char a, const Char &   b) return r(a)
+{ r >>= b.Char::val();  }
+inline  Char  operator &  (const char a, const Char &   b) return r(a)
+{ r &= b.Char::val();  }
+inline  Char  operator |  (const char a, const Char &   b) return r(a)
+{ r |= b.Char::val();  }
+inline  Char  operator ^  (const char a, const Char &   b) return r(a)
+{ r ^= b.Char::val();  }
+
+
+
+inline  char  operator !  (const Char &   a) { return !a.Char::val(); }
+
+inline  char  operator == (const Char &   a, const Char &   b)
+{ return a.Char::val() == b.Char::val(); }
+inline  char  operator != (const Char &   a, const Char &   b)
+{ return a.Char::val() != b.Char::val(); }
+inline  char  operator <  (const Char &   a, const Char &   b)
+{ return a.Char::val() <  b.Char::val(); }
+inline  char  operator <= (const Char &   a, const Char &   b)
+{ return a.Char::val() <= b.Char::val(); }
+inline  char  operator >  (const Char &   a, const Char &   b)
+{ return a.Char::val() >  b.Char::val(); }
+inline  char  operator >= (const Char &   a, const Char &   b)
+{ return a.Char::val() >= b.Char::val(); }
+
+inline  char  operator == (const Char &   a, const char b)
+{ return a.Char::val() == b; }
+inline  char  operator != (const Char &   a, const char b)
+{ return a.Char::val() != b; }
+inline  char  operator <  (const Char &   a, const char b)
+{ return a.Char::val() <  b; }
+inline  char  operator <= (const Char &   a, const char b)
+{ return a.Char::val() <= b; }
+inline  char  operator >  (const Char &   a, const char b)
+{ return a.Char::val() >  b; }
+inline  char  operator >= (const Char &   a, const char b)
+{ return a.Char::val() >= b; }
+
+inline  char  operator == (const char a, const Char &   b)
+{ return a == b.Char::val(); }
+inline  char  operator != (const char a, const Char &   b)
+{ return a != b.Char::val(); }
+inline  char  operator <  (const char a, const Char &   b)
+{ return a <  b.Char::val(); }
+inline  char  operator <= (const char a, const Char &   b)
+{ return a <= b.Char::val(); }
+inline  char  operator >  (const char a, const Char &   b)
+{ return a >  b.Char::val(); }
+inline  char  operator >= (const char a, const Char &   b)
+{ return a >= b.Char::val(); }
+
+
+
+//# 27 "../../../../libg++/etc/benchmarks/dhrystone.cc" 2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 1 "/giga/hgs/lib/g++-include/sys/types.h" 1
+
+
+//# 1 "/giga/hgs/lib/g++-include/stddef.h" 1
+
+extern "C" {
+//# 1 "/giga/hgs/lib/gcc/sun4/cygnus-1.96/include/stddef.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef int ptrdiff_t;
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef int size_t;
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef short unsigned int wchar_t;
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 3 "/giga/hgs/lib/g++-include/stddef.h" 2
+
+}
+//# 73 "/giga/hgs/lib/g++-include/stddef.h"
+
+//# 3 "/giga/hgs/lib/g++-include/sys/types.h" 2
+
+
+
+
+extern "C"
+{
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 1 "/usr/include/sys/types.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 1 "/usr/include/sys/stdtypes.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef	int		sigset_t;
+
+typedef	unsigned int	speed_t;
+typedef	unsigned long	tcflag_t;
+typedef	unsigned char	cc_t;
+typedef	int		pid_t;
+
+typedef	unsigned short	mode_t;
+typedef	short		nlink_t;
+
+typedef	long		clock_t;
+typedef	long		time_t;
+
+typedef	int		size_t;
+typedef int		ptrdiff_t;
+
+typedef	unsigned short	wchar_t;
+
+
+//# 16 "/usr/include/sys/types.h" 2
+
+
+
+//# 1 "/usr/include/sys/sysmacros.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 19 "/usr/include/sys/types.h" 2
+
+
+
+
+
+typedef	unsigned char	u_char;
+typedef	unsigned short	u_short;
+typedef	unsigned int	u_int;
+typedef	unsigned long	u_long;
+typedef	unsigned short	ushort;
+typedef	unsigned int	uint;
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef	struct  _physadr_t { int r[1]; } *physadr_t;
+typedef	struct label_t {
+	int	val[2];
+} label_t;
+
+
+
+
+
+
+
+typedef	struct	_quad_t { long val[2]; } quad_t;
+typedef	long	daddr_t;
+typedef	char *	caddr_t;
+typedef	unsigned long	ino_t;
+typedef	short	dev_t;
+typedef	long	off_t;
+typedef	unsigned short	uid_t;
+typedef	unsigned short	gid_t;
+typedef	long	key_t;
+typedef	char *	addr_t;
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef	long	fd_mask;
+
+
+
+
+
+
+
+
+
+typedef	struct fd_set {
+	fd_mask	fds_bits[(((256 )+(( (sizeof (fd_mask) * 8		)	)-1))/( (sizeof (fd_mask) * 8		)	)) ];
+} fd_set;
+
+
+
+
+
+
+
+//# 113 "/usr/include/sys/types.h"
+
+
+
+//# 35 "/giga/hgs/lib/g++-include/sys/types.h" 2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}
+
+
+
+
+//# 310 "../../../../libg++/etc/benchmarks/dhrystone.cc" 2
+
+//# 1 "/giga/hgs/lib/g++-include/sys/times.h" 1
+//# 1 "/giga/hgs/lib/g++-include/time.h" 1
+
+
+
+
+
+//# 1 "/giga/hgs/lib/g++-include/stddef.h" 1
+
+extern "C" {
+//# 1 "/giga/hgs/lib/gcc/sun4/cygnus-1.96/include/stddef.h" 1
+//# 94 "/giga/hgs/lib/gcc/sun4/cygnus-1.96/include/stddef.h"
+
+//# 3 "/giga/hgs/lib/g++-include/stddef.h" 2
+
+}
+//# 73 "/giga/hgs/lib/g++-include/stddef.h"
+
+//# 6 "/giga/hgs/lib/g++-include/time.h" 2
+
+//# 1 "/giga/hgs/lib/g++-include/stdio.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//#pragma interface
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 80 "/giga/hgs/lib/g++-include/stdio.h"
+
+
+
+//# 117 "/giga/hgs/lib/g++-include/stdio.h"
+
+
+
+
+
+//# 153 "/giga/hgs/lib/g++-include/stdio.h"
+
+
+
+extern "C" {
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 1 "/usr/include/stdio.h" 1
+
+
+
+
+
+extern	struct	_iobuf {
+	int	_cnt;
+	unsigned char *_ptr;
+	unsigned char *_base;
+	int	_bufsiz;
+	short	_flag;
+	char	_file;
+} _iob[];
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+extern struct _iobuf 	*c_proto_fopen ();
+extern struct _iobuf 	*c_proto_fdopen ();
+extern struct _iobuf 	*c_proto_freopen ();
+extern struct _iobuf 	*c_proto_popen ();
+extern struct _iobuf 	*tmpfile();
+extern long	ftell();
+extern char	*fgets();
+extern char	*gets();
+extern char	*c_proto_sprintf ();
+extern char	*ctermid();
+extern char	*cuserid();
+extern char	*c_proto_tempnam ();
+extern char	*tmpnam();
+
+
+
+
+
+
+//# 185 "/giga/hgs/lib/g++-include/stdio.h" 2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}
+//# 417 "/giga/hgs/lib/g++-include/stdio.h"
+
+
+
+
+
+
+extern "C" {
+
+
+
+
+
+
+
+int    _doprnt(const char*, void*, struct _iobuf *);
+int    _doscan(struct _iobuf *, const char*, ...);
+int    _filbuf(struct _iobuf *);
+int    _flsbuf(unsigned, struct _iobuf *);
+
+int    fclose(struct _iobuf *);
+struct _iobuf *  fdopen(int, const char*);
+int    fflush(struct _iobuf *);
+int    fgetc(struct _iobuf *);
+char*  fgets(char*, int, struct _iobuf  *);
+struct _iobuf *  fopen(const char*, const char*);
+int    fprintf(struct _iobuf *, const char* ...);
+int    fputc(int, struct _iobuf *);
+int    fputs(const char*, struct _iobuf *);
+int fread(void*, int, int, struct _iobuf *);
+
+
+
+struct _iobuf *  freopen(const char*, const char*, struct _iobuf *);
+
+int    fscanf(struct _iobuf *, const char* ...);
+int    fseek(struct _iobuf *, long, int);
+long   ftell(struct _iobuf  *);
+int fwrite(const void*, int, int, struct _iobuf *);
+char*  gets(char*);
+int    getw(struct _iobuf *);
+int    pclose(struct _iobuf *);
+void   perror(const char*);
+struct _iobuf *  popen(const char*, const char*);
+int    printf(const char* ...);
+int    puts(const char*);
+int    putw(int, struct _iobuf *);
+int    rewind(struct _iobuf *);
+int    scanf(const char* ...);
+int    setbuf(struct _iobuf *, char*);
+int    setbuffer(struct _iobuf *, char*, int);
+int    setlinebuf(struct _iobuf *);
+int    setvbuf(struct _iobuf *, char*, int, int);
+int    sscanf(char*, const char* ...);
+struct _iobuf *  tmpfile();
+int    ungetc(int, struct _iobuf *);
+int    vfprintf(struct _iobuf *, const char*, ...);
+
+
+
+
+int    vprintf(const char*, ... );
+
+
+
+
+
+char*  sprintf(char*, const char*, ...);
+char*  vsprintf(char*, const char*, ...);
+
+
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 7 "/giga/hgs/lib/g++-include/time.h" 2
+
+
+//# 1 "/giga/hgs/lib/g++-include/sys/types.h" 1
+
+
+//# 1 "/giga/hgs/lib/g++-include/stddef.h" 1
+
+extern "C" {
+//# 1 "/giga/hgs/lib/gcc/sun4/cygnus-1.96/include/stddef.h" 1
+//# 94 "/giga/hgs/lib/gcc/sun4/cygnus-1.96/include/stddef.h"
+
+//# 3 "/giga/hgs/lib/g++-include/stddef.h" 2
+
+}
+//# 73 "/giga/hgs/lib/g++-include/stddef.h"
+
+//# 3 "/giga/hgs/lib/g++-include/sys/types.h" 2
+
+
+
+
+extern "C"
+{
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 1 "/usr/include/sys/types.h" 1
+
+
+
+
+
+
+
+
+//# 115 "/usr/include/sys/types.h"
+
+//# 35 "/giga/hgs/lib/g++-include/sys/types.h" 2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}
+
+
+
+
+//# 9 "/giga/hgs/lib/g++-include/time.h" 2
+
+
+extern "C" {
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 42 "/giga/hgs/lib/g++-include/time.h"
+
+
+
+
+
+
+
+//# 1 "/usr/include/time.h" 1
+
+
+
+
+
+//# 1 "/usr/include/sys/stdtypes.h" 1
+
+
+
+
+
+
+
+
+
+
+//# 32 "/usr/include/sys/stdtypes.h"
+
+//# 6 "/usr/include/time.h" 2
+
+
+
+
+struct	tm {
+	int	tm_sec;
+	int	tm_min;
+	int	tm_hour;
+	int	tm_mday;
+	int	tm_mon;
+	int	tm_year;
+	int	tm_wday;
+	int	tm_yday;
+	int	tm_isdst;
+	char	*tm_zone;
+	long	tm_gmtoff;
+};
+
+extern	struct tm *c_proto_gmtime (), *c_proto_localtime ();
+extern	char *c_proto_asctime (), *c_proto_ctime ();
+extern	void c_proto_tzset (), c_proto_tzsetwall ();
+extern  int dysize();
+extern  time_t timelocal(), timegm();
+
+
+//# 49 "/giga/hgs/lib/g++-include/time.h" 2
+
+
+//# 1 "/usr/include/sys/times.h" 1
+
+
+
+
+
+
+
+
+
+//# 1 "/giga/hgs/lib/g++-include/sys/types.h" 1
+
+
+//# 1 "/giga/hgs/lib/g++-include/stddef.h" 1
+
+extern "C" {
+//# 1 "/giga/hgs/lib/gcc/sun4/cygnus-1.96/include/stddef.h" 1
+//# 94 "/giga/hgs/lib/gcc/sun4/cygnus-1.96/include/stddef.h"
+
+//# 3 "/giga/hgs/lib/g++-include/stddef.h" 2
+
+}
+//# 73 "/giga/hgs/lib/g++-include/stddef.h"
+
+//# 3 "/giga/hgs/lib/g++-include/sys/types.h" 2
+
+
+
+
+extern "C"
+{
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 1 "/usr/include/sys/types.h" 1
+
+
+
+
+
+
+
+
+//# 115 "/usr/include/sys/types.h"
+
+//# 35 "/giga/hgs/lib/g++-include/sys/types.h" 2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}
+
+
+
+
+//# 10 "/usr/include/sys/times.h" 2
+
+
+struct tms {
+	clock_t	tms_utime;
+	clock_t	tms_stime;
+	clock_t	tms_cutime;
+	clock_t	tms_cstime;
+};
+
+
+clock_t times( );
+
+
+
+//# 51 "/giga/hgs/lib/g++-include/time.h" 2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+extern struct tm* localtime(long*);
+extern struct tm* gmtime(long*);
+extern char* ctime(long*);
+extern char* asctime(struct tm*);
+extern void tzset();
+extern void tzsetwall();
+
+
+
+
+
+
+extern long times(struct tms*);
+
+
+//# 97 "/giga/hgs/lib/g++-include/time.h"
+
+extern char* timezone(int, int);
+extern int getitimer(int, struct itimerval*);
+extern int setitimer(int, struct itimerval*, struct itimerval*);
+extern int gettimeofday(struct timeval*, struct timezone*);
+extern int settimeofday(struct timeval*, struct timezone*);
+extern int stime(long*);
+int       dysize(int);
+
+
+
+
+
+
+
+
+long      clock(void);
+
+long      time(long*);
+unsigned  ualarm(unsigned, unsigned);
+unsigned  usleep(unsigned);
+int       profil(char*, int, int, int);
+
+}
+
+
+
+//# 1 "/giga/hgs/lib/g++-include/sys/times.h" 2
+
+//# 311 "../../../../libg++/etc/benchmarks/dhrystone.cc" 2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef enum	{Ident1, Ident2, Ident3, Ident4, Ident5} Enumeration;
+
+
+
+
+typedef Int	OneToThirty;
+typedef Int	OneToFifty;
+typedef Char	CapitalLetter;
+typedef Char	String30[31];
+typedef Int	Array1Dim[51];
+typedef Int	Array2Dim[51][51];
+
+struct	Record
+{
+	struct Record		*PtrComp;
+	Enumeration		Discr;
+	Enumeration		EnumComp;
+	OneToFifty		IntComp;
+	String30		StringComp;
+};
+
+typedef struct Record 	RecordType;
+typedef RecordType *	RecordPtr;
+typedef int		boolean;
+
+
+
+
+
+
+
+
+
+
+
+extern "C" {
+extern int printf(const char* ...);
+extern void exit(int);
+}
+
+void Proc0();
+void Proc1(RecordPtr PtrParIn);
+void Proc2(OneToFifty	*IntParIO);
+void Proc3(RecordPtr	*PtrParOut);
+void Proc4();
+void Proc5();
+boolean Func3(Enumeration	EnumParIn);
+void Proc6(  Enumeration	EnumParIn,   Enumeration	*EnumParOut);
+void Proc7(OneToFifty IntParI1, OneToFifty IntParI2, OneToFifty *IntParOut);
+void Proc8(Array1Dim	Array1Par,
+      Array2Dim	Array2Par,
+      OneToFifty IntParI1,
+      OneToFifty IntParI2);
+Enumeration Func1(CapitalLetter	CharPar1, CapitalLetter	CharPar2);
+boolean Func2(String30	StrParI1, String30	StrParI2);
+boolean Func3(Enumeration	EnumParIn);
+
+void mystrcpy(String30 s, char* t)
+{
+  for (; *t != '\0'; ++s, ++t) *s = *t;
+  *s = '\0';
+}
+
+char mystrcmp(String30 s, String30 t)
+{
+  for (; *s == *t; ++s, ++t) if (*s == '\0') return 0;
+  return char(*s - *t);
+}
+
+
+
+main()
+{
+	Proc0();
+	exit(0);
+}
+
+
+
+
+Int		IntGlob;
+boolean		BoolGlob;
+char		Char1Glob;
+char		Char2Glob;
+Array1Dim	Array1Glob;
+Array2Dim	Array2Glob;
+RecordPtr	PtrGlb;
+RecordPtr	PtrGlbNext;
+
+void Proc0()
+{
+	OneToFifty		IntLoc1;
+	  OneToFifty		IntLoc2;
+	OneToFifty		IntLoc3;
+	  char		CharLoc;
+	  char		CharIndex;
+	Enumeration	 	EnumLoc;
+	String30		String1Loc;
+	String30		String2Loc;
+
+//# 445 "../../../../libg++/etc/benchmarks/dhrystone.cc"
+
+
+	time_t			starttime;
+	time_t			benchtime;
+	time_t			nulltime;
+	struct tms		Tms;
+	register unsigned int	i;
+
+	times(&Tms); starttime = Tms.tms_utime;
+	for (i = 0; i < 500000		; ++i);
+	times(&Tms);
+	nulltime = Tms.tms_utime - starttime;
+
+
+	PtrGlbNext = new Record;
+	PtrGlb = new Record;
+	PtrGlb->PtrComp = PtrGlbNext;
+	PtrGlb->Discr = Ident1;
+	PtrGlb->EnumComp = Ident3;
+	PtrGlb->IntComp = 40;
+	mystrcpy(PtrGlb->StringComp, "DHRYSTONE PROGRAM, SOME STRING");
+	mystrcpy(String1Loc, "JUST INITIALIZED TO SOME JUNK.");
+
+
+
+
+
+
+
+
+	times(&Tms); starttime = Tms.tms_utime;
+
+	for (i = 0; i < 500000		; ++i)
+	{
+
+		Proc5();
+		Proc4();
+		IntLoc1 = 2;
+		IntLoc2 = 3;
+		mystrcpy(String2Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
+		EnumLoc = Ident2;
+		BoolGlob = ! Func2(String1Loc, String2Loc);
+		while (IntLoc1 < IntLoc2)
+		{
+			IntLoc3 = 5 * IntLoc1 - IntLoc2;
+			Proc7(IntLoc1, IntLoc2, &IntLoc3);
+			++IntLoc1;
+		}
+		Proc8(Array1Glob, Array2Glob, IntLoc1, IntLoc3);
+		Proc1(PtrGlb);
+		for (CharIndex = 'A'; CharIndex <= Char2Glob; ++CharIndex)
+			if (EnumLoc == Func1(CharIndex, 'C'))
+				Proc6(Ident1, &EnumLoc);
+		IntLoc3 = IntLoc2 * IntLoc1;
+		IntLoc2 = IntLoc3 / IntLoc1;
+		IntLoc2 = 7 * (IntLoc3 - IntLoc2) - IntLoc1;
+		Proc2(&IntLoc1);
+	}
+
+
+
+
+
+
+
+
+
+
+
+
+
+	times(&Tms);
+	benchtime = Tms.tms_utime - starttime - nulltime;
+	printf("Dhrystone time for %ld passes = %ld\n",
+		(long) 500000		, benchtime/60		);
+	printf("This machine benchmarks at %ld dhrystones/second\n",
+		((long) 500000		) * 60		 / benchtime);
+
+
+}
+
+void Proc1(RecordPtr PtrParIn)
+{
+
+
+	(*(PtrParIn->PtrComp))  =  *PtrGlb ;
+	PtrParIn->IntComp = 5;
+	(*(PtrParIn->PtrComp)) .IntComp = PtrParIn->IntComp;
+	(*(PtrParIn->PtrComp)) .PtrComp = PtrParIn->PtrComp;
+
+	Proc3(&((*(PtrParIn->PtrComp)) .PtrComp));
+	if ((*(PtrParIn->PtrComp)) .Discr == Ident1)
+	{
+		(*(PtrParIn->PtrComp)) .IntComp = 6;
+		Proc6(PtrParIn->EnumComp, &(*(PtrParIn->PtrComp)) .EnumComp);
+		(*(PtrParIn->PtrComp)) .PtrComp = PtrGlb->PtrComp;
+		Proc7((*(PtrParIn->PtrComp)) .IntComp, 10, &(*(PtrParIn->PtrComp)) .IntComp);
+	}
+	else
+		*PtrParIn =  (*(PtrParIn->PtrComp))  ;
+
+
+}
+
+void Proc2(OneToFifty	*IntParIO)
+{
+	  OneToFifty		IntLoc;
+	  Enumeration		EnumLoc;
+
+	IntLoc = *IntParIO + 10;
+	for(;;)
+	{
+		if (Char1Glob == 'A')
+		{
+			--IntLoc;
+			*IntParIO = IntLoc - IntGlob;
+			EnumLoc = Ident1;
+		}
+		if (EnumLoc == Ident1)
+			break;
+	}
+}
+
+void Proc3(RecordPtr	*PtrParOut)
+{
+	if (PtrGlb != 0 )
+		*PtrParOut = PtrGlb->PtrComp;
+	else
+		IntGlob = 100;
+	Proc7(10, IntGlob, &PtrGlb->IntComp);
+}
+
+void Proc4()
+{
+	  boolean	BoolLoc;
+
+	BoolLoc = Char1Glob == 'A';
+	BoolLoc |= BoolGlob;
+	Char2Glob = 'B';
+}
+
+void Proc5()
+{
+	Char1Glob = 'A';
+	BoolGlob = 	0 ;
+}
+
+
+
+
+void Proc6(  Enumeration	EnumParIn,   Enumeration	*EnumParOut)
+{
+	*EnumParOut = EnumParIn;
+	if (! Func3(EnumParIn) )
+		*EnumParOut = Ident4;
+	switch (EnumParIn)
+	{
+	case Ident1:	*EnumParOut = Ident1; break;
+	case Ident2:	if (IntGlob > 100) *EnumParOut = Ident1;
+			else *EnumParOut = Ident4;
+			break;
+	case Ident3:	*EnumParOut = Ident2; break;
+	case Ident4:	break;
+	case Ident5:	*EnumParOut = Ident3;
+	}
+}
+
+void Proc7(OneToFifty IntParI1, OneToFifty IntParI2, OneToFifty *IntParOut)
+{
+	  OneToFifty	IntLoc;
+
+	IntLoc = IntParI1 + 2;
+	*IntParOut = IntParI2 + IntLoc;
+}
+
+void Proc8(Array1Dim	Array1Par,
+      Array2Dim	Array2Par,
+      OneToFifty IntParI1,
+      OneToFifty IntParI2)
+{
+	  OneToFifty	IntLoc;
+	  OneToFifty	IntIndex;
+
+	IntLoc = IntParI1 + 5;
+	Array1Par[IntLoc] = IntParI2;
+	Array1Par[IntLoc+1] = Array1Par[IntLoc];
+	Array1Par[IntLoc+30] = IntLoc;
+	for (IntIndex = IntLoc; IntIndex <= (IntLoc+1); ++IntIndex)
+		Array2Par[IntLoc][IntIndex] = IntLoc;
+	++Array2Par[IntLoc][IntLoc-1];
+	Array2Par[IntLoc+20][IntLoc] = Array1Par[IntLoc];
+	IntGlob = 5;
+}
+
+Enumeration Func1(CapitalLetter	CharPar1, CapitalLetter	CharPar2)
+{
+	  CapitalLetter	CharLoc1;
+	  CapitalLetter	CharLoc2;
+
+	CharLoc1 = CharPar1;
+	CharLoc2 = CharLoc1;
+	if (CharLoc2 != CharPar2)
+		return (Ident1);
+	else
+		return (Ident2);
+}
+
+boolean Func2(String30	StrParI1, String30	StrParI2)
+{
+	  OneToThirty		IntLoc;
+	  CapitalLetter	CharLoc;
+
+	IntLoc = 1;
+	while (IntLoc <= 1)
+		if (Func1(StrParI1[IntLoc], StrParI2[IntLoc+1]) == Ident1)
+		{
+			CharLoc = 'A';
+			++IntLoc;
+		}
+	if (CharLoc >= 'W' && CharLoc <= 'Z')
+		IntLoc = 7;
+	if (CharLoc == 'X')
+		return(	1 );
+	else
+	{
+		if (mystrcmp(StrParI1, StrParI2) > 0)
+		{
+			IntLoc += 7;
+			return (	1 );
+		}
+		else
+			return (	0 );
+	}
+}
+
+boolean Func3(Enumeration	EnumParIn)
+{
+	  Enumeration	EnumLoc;
+
+	EnumLoc = EnumParIn;
+	if (EnumLoc == Ident3) return (	1 );
+	return (	0 );
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p701.C b/gcc/testsuite/g++.old-deja/g++.mike/p701.C
new file mode 100644
index 00000000000..c222ea1e888
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p701.C
@@ -0,0 +1,34 @@
+// Build don't link:
+// prms-id: 701
+
+extern "C" 
+{
+  int printf(const char *, ...);
+};
+
+
+void Munge(int& x) 
+{				// ERROR - referenced below
+   x = 2;
+}
+
+
+class A 
+{
+ public:
+   int i;
+   A(int x) : i(x) {}
+   void Safe() const;
+};
+
+void
+A::Safe() const 
+{
+   Munge(i);	// ERROR - should not be able to modify a const object
+}
+
+int main()
+{
+   const A a(1);
+   a.Safe();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p710.C b/gcc/testsuite/g++.old-deja/g++.mike/p710.C
new file mode 100644
index 00000000000..62dffe9ff8e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p710.C
@@ -0,0 +1,43 @@
+// Build don't link: 
+// GROUPS passed delete
+/*
+  Bug Id: 
+  PRMS Id: p0000710
+  Bug is : overloading operator delete in class def not allowed
+*/
+
+/*
+  In addition to this bug, the compiler permits overloading operator
+  delete in the class definition.  This is verboten, and should be
+  caught by a regression suite.  In other words, the following is also a
+  bug that's not caught:
+*/
+
+
+#include <stdlib.h>
+
+extern "C" 
+{
+   int printf(const char*, ...);
+};
+
+
+
+class B
+{
+ public:
+   int x;
+   virtual ~B() {}
+   void operator delete(void*,size_t s)
+  {
+      printf("B::delete() %d\n",s);
+   }
+   void operator delete(void*){}
+};
+
+int main()
+{
+   B* p = new B;
+   delete p;
+   return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p7180.C b/gcc/testsuite/g++.old-deja/g++.mike/p7180.C
new file mode 100644
index 00000000000..da75bd6d4ed
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p7180.C
@@ -0,0 +1,17 @@
+// prms-id: 7180
+
+class String {
+public:
+   String(const char*);
+   ~String();
+};
+ 
+String::String(const char* str = "") {
+}
+ 
+String::~String(void) {
+}
+ 
+int main() {
+   const String array[] = {"3"};
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p7325.C b/gcc/testsuite/g++.old-deja/g++.mike/p7325.C
new file mode 100644
index 00000000000..e6d76f5321e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p7325.C
@@ -0,0 +1,55 @@
+// I hate this type of test case.  I'm not sure how to code it better.
+// See the PR for what this tests.
+// prms-id: 7325
+// execution test - XFAIL *-*-*
+
+int fail = 0;
+
+struct A {
+  int i;
+  static const A* match_this;
+  static const A* match_arg;
+  A(): i(7) {
+    if (match_this)
+      if (match_this != this)
+	fail = 1;
+  }
+  A* get_this() { return this; }
+  A& operator = (const A& o) {
+    if (match_this)
+      if (match_this != this)
+	fail = 1;
+    if (match_arg)
+      if (match_arg != &o)
+	fail = 1;
+    match_arg = &o;
+  }
+};
+
+const A* A::match_this;
+const A* A::match_arg;
+A a;
+
+A foo() { return a; }
+void f ()
+{
+  A a;
+  A::match_this = &a;
+  a = foo ();
+  a = foo ();
+  A::match_this = 0;
+}
+
+void g ()
+{
+  A::match_this = A().get_this();
+  A();
+  A();
+  A::match_this = 0;
+}
+
+int main() {
+  f();
+  g();
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p7476.C b/gcc/testsuite/g++.old-deja/g++.mike/p7476.C
new file mode 100644
index 00000000000..acddf05ee13
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p7476.C
@@ -0,0 +1,20 @@
+// Build don't link:
+// prms-id: 7476
+
+class HeapTracked {
+public:
+  virtual ~HeapTracked() { }
+  static void isObjectAllocation(const HeapTracked *ptr);
+  static void isObjectAllocation(HeapTracked *ptr);
+};
+
+void HeapTracked::isObjectAllocation(HeapTracked *ptr)
+{
+  dynamic_cast<const void*>(ptr);
+  dynamic_cast<void*>(ptr);
+}
+void HeapTracked::isObjectAllocation(const HeapTracked *ptr)
+{
+  const_cast<void*>(dynamic_cast<const void*>(ptr));
+  dynamic_cast<void*>(ptr);		// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p755.C b/gcc/testsuite/g++.old-deja/g++.mike/p755.C
new file mode 100644
index 00000000000..256c985e271
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p755.C
@@ -0,0 +1,17 @@
+// It checks to see if you can define your own global new operator.
+// prms-id: 755
+
+#include <new>
+extern "C" void exit(int);
+
+void* operator new(size_t sz) throw (std::bad_alloc) {
+  void* p = 0;
+  exit(0);
+  return p;
+}
+
+int main () {
+  int* i = new int;
+  delete i;
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p755a.C b/gcc/testsuite/g++.old-deja/g++.mike/p755a.C
new file mode 100644
index 00000000000..73172c159ce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p755a.C
@@ -0,0 +1,14 @@
+// It checks to see if you can define your own global delete operator.
+// prms-id: 755
+
+extern "C" void exit(int);
+
+void operator delete(void *p) throw() {
+  exit(0);
+}
+
+int main () {
+  int* i = new int;
+  delete i;
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p7626.C b/gcc/testsuite/g++.old-deja/g++.mike/p7626.C
new file mode 100644
index 00000000000..8e38667ca67
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p7626.C
@@ -0,0 +1,43 @@
+// Build don't link:
+// prms-id: 7626
+
+int fail;
+
+typedef unsigned int UINT;
+
+class CObject{};
+
+class CCmdTarget : public CObject {
+};
+
+typedef void (CCmdTarget::*AFX_PMSG)(void);
+
+struct AFX_MSGMAP_ENTRY {
+  AFX_PMSG pfn;     
+};
+
+class CWnd : public CCmdTarget {
+public:
+  void OnMyMsg() { fail  = 1; }		// If this one is called, something is wrong.
+  static AFX_MSGMAP_ENTRY _messageEntries[];
+};
+
+typedef void (CWnd::*AFX_PMSGW)(void);
+
+class CDialog : public CWnd
+{
+public:
+  void OnMyMsg() { }
+  static AFX_MSGMAP_ENTRY _messageEntries[];
+};
+
+AFX_MSGMAP_ENTRY  CDialog ::_messageEntries[] = { 
+  { (AFX_PMSG)(AFX_PMSGW)(void (CWnd::*)())&CDialog::OnMyMsg }, 
+  { (AFX_PMSG)0 }
+}; 
+
+int main() {
+  CDialog d;
+  (d.*((CDialog::_messageEntries)[0]).pfn)();	// This should call CDialog::OnMyMsg
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p7635.C b/gcc/testsuite/g++.old-deja/g++.mike/p7635.C
new file mode 100644
index 00000000000..4cafa0e46fa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p7635.C
@@ -0,0 +1,6 @@
+// prms-id: 7635
+
+class DaycountBasis {
+  mutable const int * p;
+  mutable int * const q;	// ERROR - 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p7651.C b/gcc/testsuite/g++.old-deja/g++.mike/p7651.C
new file mode 100644
index 00000000000..487b0d57664
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p7651.C
@@ -0,0 +1,25 @@
+// prms-id: 7651
+
+int fail = 0;
+
+class Foo {
+public:
+  Foo(double i) : data(i) { if (data != 1.0) fail = 1; }
+  ~Foo() { if (data != 1.0) fail = 1; }
+private:
+  volatile double data;
+};
+
+int DingDong(double A) {
+  volatile Foo a(A);
+
+  if ( A != 0.0 ) {
+    return 1;
+  }
+  return 0;
+}
+
+
+int main() {
+  DingDong(1.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p783.C b/gcc/testsuite/g++.old-deja/g++.mike/p783.C
new file mode 100644
index 00000000000..4194fa8b2ba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p783.C
@@ -0,0 +1,15 @@
+// prms-id: 783
+
+extern "C" void printf (char *, ...);
+
+class C {
+public:
+  C() { }
+  ~C() { }
+};
+
+int main(int argc, char**argv) {
+  C c,d;
+  c = (argc&1) ? C() : d;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p783a.C b/gcc/testsuite/g++.old-deja/g++.mike/p783a.C
new file mode 100644
index 00000000000..6321a7b3eb5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p783a.C
@@ -0,0 +1,26 @@
+// Copying into an object directly is a lose according to tiemann.
+// Deleting an object many times is a lose.
+// prms-id: 783
+
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+class C {
+  int i;
+public:
+  C() {
+    i = 1;
+  }
+  ~C() {
+    if (i != 1) {
+      exit(1);
+    }
+    i = 0;
+  }
+};
+
+int main(int argc, char**argv) {
+  C c;
+  c = C();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p783b.C b/gcc/testsuite/g++.old-deja/g++.mike/p783b.C
new file mode 100644
index 00000000000..35a18f3f99b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p783b.C
@@ -0,0 +1,37 @@
+// This one check for objects being destroyed twice.  The bug it is
+// looking for is the extra dtor call on C() even though it is never
+// built.
+// prms-id: 783
+
+extern "C" void printf (char *, ...);
+extern "C" void exit (int);
+
+class C {
+  int i;
+public:
+//  C() {printf ("C ctor at %x\n", this);}
+//  ~C() {printf ("C dtor at %x\n", this);}
+  C() {
+    i = 1;
+  }
+  ~C() {
+    if (i != 1) {
+      exit(1);
+    }
+    i = 0;
+  }
+};
+
+C g;
+
+C func()  {
+  return g;
+}
+
+int main(int argc, char**argv) {
+  C c,d;
+//  printf ("\n");
+  c = (argc != 1) ? C() : d;
+//  printf ("\n");
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p784.C b/gcc/testsuite/g++.old-deja/g++.mike/p784.C
new file mode 100644
index 00000000000..ce6104977f1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p784.C
@@ -0,0 +1,3658 @@
+// Build don't link:
+// Special g++ Options: -w
+// prms-id: 784
+
+//# 1 "GctSymbol.GctSymbol.CHMap.cc"
+// This may look like C code, but it is really -*- C++ -*-
+/*
+Copyright (C) 1988 Free Software Foundation
+    written by Doug Lea (dl@rocky.oswego.edu)
+
+This file is part of the GNU C++ Library.  This library is free
+software; you can redistribute it and/or modify it under the terms of
+the GNU Library General Public License as published by the Free
+Software Foundation; either version 2 of the License, or (at your
+option) any later version.  This library is distributed in the hope
+that it will be useful, but WITHOUT ANY WARRANTY; without even the
+implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.  See the GNU Library General Public License for more details.
+You should have received a copy of the GNU Library General Public
+License along with this library; if not, write to the Free Software
+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+//#pragma implementation
+
+//# 1 "GctSymbol.GctSymbol.CHMap.h" 1
+// This may look like C code, but it is really -*- C++ -*-
+/*
+Copyright (C) 1988 Free Software Foundation
+    written by Doug Lea (dl@rocky.oswego.edu)
+
+This file is part of the GNU C++ Library.  This library is free
+software; you can redistribute it and/or modify it under the terms of
+the GNU Library General Public License as published by the Free
+Software Foundation; either version 2 of the License, or (at your
+option) any later version.  This library is distributed in the hope
+that it will be useful, but WITHOUT ANY WARRANTY; without even the
+implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.  See the GNU Library General Public License for more details.
+You should have received a copy of the GNU Library General Public
+License along with this library; if not, write to the Free Software
+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+
+
+//#pragma interface
+
+
+
+//# 1 "GctSymbol.GctSymbol.Map.h" 1
+// This may look like C code, but it is really -*- C++ -*-
+/*
+Copyright (C) 1988 Free Software Foundation
+    written by Doug Lea (dl@rocky.oswego.edu)
+
+This file is part of the GNU C++ Library.  This library is free
+software; you can redistribute it and/or modify it under the terms of
+the GNU Library General Public License as published by the Free
+Software Foundation; either version 2 of the License, or (at your
+option) any later version.  This library is distributed in the hope
+that it will be useful, but WITHOUT ANY WARRANTY; without even the
+implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.  See the GNU Library General Public License for more details.
+You should have received a copy of the GNU Library General Public
+License along with this library; if not, write to the Free Software
+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+
+
+//#pragma interface
+
+
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/Pix.h" 1
+
+
+
+typedef void* Pix;
+
+//# 26 "GctSymbol.GctSymbol.Map.h" 2
+
+//# 1 "GctSymbol.defs.h" 1
+// This may look like C code, but it is really -*- C++ -*-
+/*
+Copyright (C) 1988 Free Software Foundation
+    written by Doug Lea (dl@rocky.oswego.edu)
+
+This file is part of the GNU C++ Library.  This library is free
+software; you can redistribute it and/or modify it under the terms of
+the GNU Library General Public License as published by the Free
+Software Foundation; either version 2 of the License, or (at your
+option) any later version.  This library is distributed in the hope
+that it will be useful, but WITHOUT ANY WARRANTY; without even the
+implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.  See the GNU Library General Public License for more details.
+You should have received a copy of the GNU Library General Public
+License along with this library; if not, write to the Free Software
+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+
+
+
+
+
+//# 1 "../../GctSymbol.h" 1
+// -*- C++ -*-
+
+
+
+//
+// GctSymbol class
+//
+// Expects to be included by Gct.h
+//
+// Wendell Baker, Berkeley CAD Group, 1992 (wbaker@ic.Berkeley.EDU)
+//
+
+
+
+
+
+//#pragma interface
+
+
+
+
+
+//# 25 "../../GctSymbol.h" 2
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/String.h" 1
+// This may look like C code, but it is really -*- C++ -*-
+/*
+Copyright (C) 1988 Free Software Foundation
+    written by Doug Lea (dl@rocky.oswego.edu)
+
+This file is part of the GNU C++ Library.  This library is free
+software; you can redistribute it and/or modify it under the terms of
+the GNU Library General Public License as published by the Free
+Software Foundation; either version 2 of the License, or (at your
+option) any later version.  This library is distributed in the hope
+that it will be useful, but WITHOUT ANY WARRANTY; without even the
+implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.  See the GNU Library General Public License for more details.
+You should have received a copy of the GNU Library General Public
+License along with this library; if not, write to the Free Software
+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+
+
+//#pragma interface
+
+
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/stream.h" 1
+
+
+
+// Compatibility with old library.
+
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h" 1
+//    This is part of the iostream library, providing -*- C++ -*- input/output.
+//    Copyright (C) 1991 Per Bothner.
+//
+//    This library is free software; you can redistribute it and/or
+//    modify it under the terms of the GNU Library General Public
+//    License as published by the Free Software Foundation; either
+//    version 2 of the License, or (at your option) any later version.
+//
+//    This library is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//    Library General Public License for more details.
+//
+//    You should have received a copy of the GNU Library General Public
+//    License along with this library; if not, write to the Free
+//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+
+
+//#pragma interface
+
+
+
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/streambuf.h" 1
+//    This is part of the iostream library, providing -*- C++ -*- input/output.
+//    Copyright (C) 1991 Per Bothner.
+//
+//    This library is free software; you can redistribute it and/or
+//    modify it under the terms of the GNU Library General Public
+//    License as published by the Free Software Foundation; either
+//    version 2 of the License, or (at your option) any later version.
+//
+//    This library is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//    Library General Public License for more details.
+//
+//    You should have received a copy of the GNU Library General Public
+//    License along with this library; if not, write to the Free
+//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+
+
+
+//#pragma interface
+
+
+/* KLUDGES!! */
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/stddef.h" 1
+
+
+extern "C" {
+
+
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/mips/lib/gcc/decstatn/cygnus-1.96/include/stddef.h" 1
+
+
+
+
+
+
+/* This avoids lossage on Sunos but only if stdtypes.h comes first.
+   There's no way to win with the other order!  Sun lossage.  */
+
+/* In case nobody has defined these types, but we aren't running under
+   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE__TYPE__, and
+   __WCHAR_TYPE__ have reasonable values.  This can happen if the
+   parts of GCC is compiled by an older compiler, that actually
+   include gstddef.h, such as collect2.  */
+
+/* Signed type of difference of two pointers.  */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef long int ptrdiff_t;
+
+
+
+
+
+
+/* Unsigned type of `sizeof' something.  */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef unsigned int size_t;
+
+
+
+
+
+
+/* Data type for wide chars.  */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef int wchar_t;
+
+
+
+
+
+
+
+
+/* A null pointer constant.  */
+
+
+
+
+/* Offset of member MEMBER in a struct of type TYPE.  */
+
+
+
+
+
+//# 7 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/stddef.h" 2
+
+
+
+
+}
+
+//# 25 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/streambuf.h" 2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+class ostream; class streambuf;
+
+typedef long streamoff, streampos;
+
+struct _ios_fields { // The data members of an ios.
+    streambuf *_strbuf;
+    ostream* _tie;
+    long _width;
+    unsigned long _flags;
+    char _fill;
+    unsigned char _state;
+    unsigned short _precision;
+};
+
+
+enum state_value { _good = 0, _eof = 1,  _fail = 2, _bad  = 4 };
+
+
+class ios : public _ios_fields {
+  public:
+    enum io_state { goodbit=0, eofbit=1, failbit=2, badbit=4 };
+    enum open_mode {
+	in=1,
+	out=2,
+	ate=4,
+	app=8,
+	trunc=16,
+	nocreate=32,
+	noreplace=64 };
+    enum seek_dir { beg, cur, end};
+    enum { skipws=01, left=02, right=04, internal=010,
+	   dec=020, oct=040, hex=0100,
+	   showbase=0200, showpoint=0400, uppercase=01000, showpos=02000,
+	   scientific=04000, fixed=0100000, unitbuf=020000, stdio=040000,
+	   dont_close=0x80000000 //Don't close streambuf when destroying stream
+	   };
+
+    ostream* tie() { return _tie; }
+    ostream* tie(ostream* val) { ostream* save=_tie; _tie=val; return save; }
+
+    // Methods to change the format state.
+    char fill() { return _fill; }
+    char fill(char newf) { char oldf = _fill; _fill = newf; return oldf; }
+    unsigned long flags() { return _flags; }
+    unsigned long flags(unsigned long new_val) {
+	unsigned long old_val = _flags; _flags = new_val; return old_val; }
+    unsigned short precision() { return _precision; }
+    unsigned short precision(int newp) {
+	unsigned short oldp = _precision; _precision = (unsigned short)newp;
+	return oldp; }
+    unsigned long setf(unsigned long val) {
+	unsigned long oldbits = _flags;
+	_flags |= val; return oldbits; }
+    unsigned long setf(unsigned long val, unsigned long mask) {
+	unsigned long oldbits = _flags;
+	_flags = (_flags & ~mask) | (val & mask); return oldbits; }
+    unsigned long unsetf(unsigned long mask) {
+	unsigned long oldbits = _flags & mask;
+	_flags &= ~mask; return oldbits; }
+    long width() { return _width; }
+    long width(long val) { long save = _width; _width = val; return save; }
+
+    static const unsigned long basefield;
+    static const unsigned long adjustfield;
+    static const unsigned long floatfield;
+
+    streambuf* rdbuf() { return _strbuf; }
+    void clear(int state = 0) { _state = state; }
+    int good() { return _state == 0; }
+    int eof() { return _state & ios::eofbit; }
+    int fail() { return _state & (ios::badbit|ios::failbit); }
+    int bad() { return _state & ios::badbit; }
+    int rdstate() { return _state; }
+    void set(int flag) { _state |= flag; }
+    operator void*() { return fail() ? (void*)0 : (void*)this; }
+    int operator!() { return fail(); }
+
+
+    void unset(state_value flag) { _state &= ~flag; }
+    void close();
+    int is_open();
+    int readable();
+    int writable();
+
+
+  protected:
+    ios(streambuf*sb) { _strbuf=sb; _state=0; _width=0; _fill=' ';
+			_flags=ios::skipws; _precision=6; }
+};
+
+
+
+
+typedef ios::seek_dir _seek_dir;
+
+
+// Magic numbers and bits for the _flags field.
+// The magic numbers use the high-order bits of _flags;
+// the remaining bits are abailable for variable flags.
+// Note: The magic numbers must all be negative if stdio
+// emulation is desired.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+struct __streambuf {
+    // NOTE: If this is changed, also change __FILE in stdio/stdio.h!
+    int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
+    char* _gptr;	/* Current get pointer */
+    char* _egptr;	/* End of get area. */
+    char* _eback;	/* Start of putback+get area. */
+    char* _pbase;	/* Start of put area. */
+    char* _pptr;	/* Current put pointer. */
+    char* _epptr;	/* End of put area. */
+    char* _base;	/* Start of reserve area. */
+    char* _ebuf;	/* End of reserve area. */
+    struct streambuf *_chain;
+};
+
+struct streambuf : private __streambuf {
+    friend class ios;
+    friend class istream;
+    friend class ostream;
+  protected:
+    static streambuf* _list_all; /* List of open streambufs. */
+    streambuf*& xchain() { return _chain; }
+    void _un_link();
+    void _link_in();
+    char* gptr() const { return _gptr; }
+    char* pptr() const { return _pptr; }
+    char* egptr() const { return _egptr; }
+    char* epptr() const { return _epptr; }
+    char* pbase() const { return _pbase; }
+    char* eback() const { return _eback; }
+    char* ebuf() const { return _ebuf; }
+    char* base() const { return _base; }
+    void xput_char(char c) { *_pptr++ = c; }
+    int xflags() { return _flags; }
+    int xflags(int f) { int fl = _flags; _flags = f; return fl; }
+    void xsetflags(int f) { _flags |= f; }
+    void gbump(int n) { _gptr += n; }
+    void pbump(int n) { _pptr += n; }
+    void setb(char* b, char* eb, int a=0);
+    void setp(char* p, char* ep) { _pbase=_pptr=p; _epptr=ep; }
+    void setg(char* eb, char* g, char *eg) { _eback=eb; _gptr=g; _egptr=eg; }
+  public:
+    static int flush_all();
+    static void flush_all_linebuffered(); // Flush all line buffered files.
+    virtual int underflow(); // Leave public for now
+    virtual int overflow(int c = (-1) ); // Leave public for now
+    virtual int doallocate();
+    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
+    virtual streampos seekpos(streampos pos, int mode = ios::in|ios::out);
+    int sputbackc(char c);
+    int sungetc();
+    streambuf();
+    virtual ~streambuf();
+    int unbuffered() { return _flags & 2  ? 1 : 0; }
+    int linebuffered() { return _flags & 0x4000  ? 1 : 0; }
+    void unbuffered(int i)
+	{ if (i) _flags |= 2 ; else _flags &= ~2 ; }
+    void linebuffered(int i)
+	{ if (i) _flags |= 0x4000 ; else _flags &= ~0x4000 ; }
+    int allocate() {
+	if (base() || unbuffered()) return 0;
+	else return doallocate(); }
+    virtual int sync();
+    virtual int pbackfail(int c);
+    virtual int ungetfail();
+    virtual streambuf* setbuf(char* p, int len);
+    int in_avail() { return _egptr - _gptr; }
+    int out_waiting() { return _pptr - _pbase; }
+    virtual int sputn(const char* s, int n);
+    virtual int sgetn(char* s, int n);
+    long sgetline(char* buf, size_t n, char delim, int putback_delim);
+    int sbumpc() {
+	if (_gptr >= _egptr && underflow() == (-1) ) return (-1) ;
+	else return *(unsigned char*)_gptr++; }
+    int sgetc() {
+	if (_gptr >= _egptr && underflow() == (-1) ) return (-1) ;
+	else return *(unsigned char*)_gptr; }
+    int snextc() {
+	if (++_gptr >= _egptr && underflow() == (-1) ) return (-1) ;
+	else return *(unsigned char*)_gptr; }
+    int sputc(int c) {
+	if (_pptr >= _epptr) return overflow(c);
+	return *_pptr++ = c, (unsigned char)c; }
+    int vscan(char const *fmt0, char*  ap);
+    int vform(char const *fmt0, char*  ap);
+};
+
+struct __file_fields {
+    char _fake;
+    char _shortbuf[1];
+    short _fileno;
+    int _blksize;
+    char* _save_gptr;
+    char* _save_egptr;
+    long  _offset;
+};
+
+class filebuf : public streambuf {
+    struct __file_fields _fb;
+    void init();
+  public:
+    filebuf();
+    filebuf(int fd);
+    filebuf(int fd, char* p, int len);
+    ~filebuf();
+    filebuf* attach(int fd);
+    filebuf* open(const char *filename, const char *mode);
+    filebuf* open(const char *filename, int mode, int prot = 0664);
+    virtual int underflow();
+    virtual int overflow(int c = (-1) );
+    int is_open() { return _fb._fileno >= 0; }
+    int fd() { return is_open() ? _fb._fileno : (-1) ; }
+    filebuf* close();
+    virtual int doallocate();
+    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
+    int sputn(const char* s, int n);
+    int sgetn(char* s, int n);
+  protected: // See documentation in filebuf.C.
+    virtual int pbackfail(int c);
+    virtual int sync();
+    int is_reading() { return eback() != egptr(); }
+    char* cur_ptr() { return is_reading() ?  gptr() : pptr(); }
+    /* System's idea of pointer */
+    char* file_ptr() { return _fb._save_gptr ? _fb._save_egptr : egptr(); }
+    int do_flush();
+    // Low-level operations (Usually invoke system calls.)
+    virtual int sys_read(char* buf, size_t size);
+    virtual long  sys_seek(long , _seek_dir);
+    virtual long sys_write(const void*, long);
+    virtual int sys_stat(void*); // Actually, a (struct stat*)
+    virtual int sys_close();
+};
+
+
+inline int ios::readable() { return rdbuf()->_flags & 4 ; }
+inline int ios::writable() { return rdbuf()->_flags & 8 ; }
+inline int ios::is_open() {return rdbuf()->_flags & 4 +8 ;}
+
+
+
+
+//# 25 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h" 2
+
+
+class istream; class ostream;
+typedef istream& (*__imanip)(istream&);
+typedef ostream& (*__omanip)(ostream&);
+
+extern istream& ws(istream& ins);
+extern ostream& flush(ostream& outs);
+extern ostream& endl(ostream& outs);
+extern ostream& ends(ostream& outs);
+
+class ostream : public ios
+{
+    void do_osfx();
+  public:
+    ostream();
+    ostream(streambuf* sb, ostream* tied=(__null) );
+    ~ostream();
+
+    int opfx() { if (!good()) return 0; if (_tie) _tie->flush(); return 1; }
+    void osfx() { if (flags() & (ios::unitbuf|ios::stdio))
+		      do_osfx(); }
+    streambuf* ostreambuf() const { return _strbuf; }
+    ostream& flush();
+    ostream& put(char c);
+    ostream& write(const char *s, int n);
+    ostream& write(const unsigned char *s, int n) { return write((char*)s, n);}
+    ostream& write(const void *s, int n) { return write((char*)s, n);}
+    ostream& seekp(streampos);
+    ostream& seekp(streamoff, _seek_dir);
+    streampos tellp();
+    ostream& form(const char *format ...);
+    ostream& vform(const char *format, char*  args);
+};
+
+ostream& operator<<(ostream&, char c);
+ostream& operator<<(ostream& os, unsigned char c) { return os << (char)c; }
+//ostream& operator<<(ostream &os, signed char c) { return os << (char)c; }
+extern ostream& operator<<(ostream&, const char *s);
+inline ostream& operator<<(ostream& os, const unsigned char *s)
+{ return os << (const char*)s; }
+//inline ostream& operator<<(ostream& os, const signed char *s)
+//{ return os << (const char*)s; }
+ostream& operator<<(ostream&, void *p);
+ostream& operator<<(ostream&, int n);
+ostream& operator<<(ostream&, long n);
+ostream& operator<<(ostream&, unsigned int n);
+ostream& operator<<(ostream&, unsigned long n);
+ostream& operator<<(ostream& os, short n) {return os << (int)n;}
+ostream& operator<<(ostream& os, unsigned short n)
+{return os << (unsigned int)n;}
+ostream& operator<<(ostream&, float n);
+ostream& operator<<(ostream&, double n);
+ostream& operator<<(ostream& os, __omanip func) { return (*func)(os); }
+ostream& operator<<(ostream&, streambuf*);
+
+class istream : public ios
+{
+    size_t _gcount;
+  public:
+    istream();
+    istream(streambuf* sb, ostream*tied=(__null) );
+    ~istream();
+    streambuf* istreambuf() const { return _strbuf; }
+    istream& get(char& c);
+    istream& get(unsigned char& c);
+    istream& read(char *ptr, int n);
+    istream& read(unsigned char *ptr, int n) { return read((char*)ptr, n); }
+    istream& read(void *ptr, int n) { return read((char*)ptr, n); }
+    int get() { return _strbuf->sbumpc(); }
+    istream& getline(char* ptr, int len, char delim = '\n');
+    istream& get(char* ptr, int len, char delim = '\n');
+    istream& gets(char **s, char delim = '\n');
+    int ipfx(int need) {
+	if (!good()) { set(ios::failbit); return 0; }
+	if (_tie && (need == 0 || rdbuf()->in_avail())) ;  //??? THIS LINE IS QUESTIONABLE */
+	if (!need && (flags() & ios::skipws) && !ws(*this)) return 0;
+	return 1;
+    }
+    int ipfx0() { // Optimized version of ipfx(0).
+	if (!good()) { set(ios::failbit); return 0; }
+	if (_tie) _tie->flush();
+	if ((flags() & ios::skipws) && !ws(*this)) return 0;
+	return 1;
+    }
+    int ipfx1() { // Optimized version of ipfx(1).
+	if (!good()) { set(ios::failbit); return 0; }
+	if (_tie && rdbuf()->in_avail() == 0) _tie->flush();
+	return 1;
+    }
+    size_t gcount() { return _gcount; }
+    istream& seekg(streampos);
+    istream& seekg(streamoff, _seek_dir);
+    streampos tellg();
+    istream& putback(char ch) {
+	if (good() && _strbuf->sputbackc(ch) == (-1) ) clear(ios::badbit);
+	return *this;}
+    istream& unget() {
+	if (good() && _strbuf->sungetc() == (-1) ) clear(ios::badbit);
+	return *this;}
+
+    istream& unget(char ch) { return putback(ch); }
+    int skip(int i);
+
+};
+
+istream& operator>>(istream&, char*);
+istream& operator>>(istream& is, unsigned char* p) { return is >> (char*)p; }
+//istream& operator>>(istream& is, signed char* p) { return is >> (char*)p; }
+istream& operator>>(istream&, char& c);
+istream& operator>>(istream&, unsigned char& c);
+//istream& operator>>(istream&, signed char& c);
+istream& operator>>(istream&, int&);
+istream& operator>>(istream&, long&);
+istream& operator>>(istream&, short&);
+istream& operator>>(istream&, unsigned int&);
+istream& operator>>(istream&, unsigned long&);
+istream& operator>>(istream&, unsigned short&);
+istream& operator>>(istream&, float&);
+istream& operator>>(istream&, double&);
+istream& operator>>(istream& is, __imanip func) { return (*func)(is); }
+
+class iostream : public ios {
+    size_t _gcount;
+  public:
+    iostream();
+    operator istream&() { return *(istream*)this; }
+    operator ostream&() { return *(ostream*)this; }
+    ~iostream();
+    // NOTE: These duplicate istream methods.
+    istream& get(char& c) { return ((istream*)this)->get(c); }
+    istream& get(unsigned char& c) { return ((istream*)this)->get(c); }
+    istream& read(char *ptr, int n) { return ((istream*)this)->read(ptr, n); }
+    istream& read(unsigned char *ptr, int n)
+	{ return ((istream*)this)->read((char*)ptr, n); }
+    istream& read(void *ptr, int n)
+	{ return ((istream*)this)->read((char*)ptr, n); }
+    int get() { return _strbuf->sbumpc(); }
+    istream& getline(char* ptr, int len, char delim = '\n')
+	{ return ((istream*)this)->getline(ptr, len, delim); }
+    istream& get(char* ptr, int len, char delim = '\n')
+	{ return ((istream*)this)->get(ptr, len, delim); }
+    istream& gets(char **s, char delim = '\n')
+	{ return ((istream*)this)->gets(s, delim); }
+    int ipfx(int need) { return ((istream*)this)->ipfx(need); }
+    int ipfx0()  { return ((istream*)this)->ipfx0(); }
+    int ipfx1()  { return ((istream*)this)->ipfx1(); }
+    size_t gcount() { return _gcount; }
+    istream& putback(char ch) { return ((istream*)this)->putback(ch); }
+    istream& unget() { return ((istream*)this)->unget(); }
+    istream& seekg(streampos pos) { return ((istream*)this)->seekg(pos); }
+    istream& seekg(streamoff off, _seek_dir dir)
+	{ return ((istream*)this)->seekg(off, dir); }
+    streampos tellg() { return ((istream*)this)->tellg(); }
+
+    istream& unget(char ch) { return putback(ch); }
+
+
+    // NOTE: These duplicate ostream methods.
+    int opfx() { return ((ostream*)this)->opfx(); }
+    void osfx() { ((ostream*)this)->osfx(); }
+    ostream& flush() { return ((ostream*)this)->flush(); }
+    ostream& put(char c) { return ((ostream*)this)->put(c); }
+    ostream& write(const char *s, int n)
+	{ return ((ostream*)this)->write(s, n); }
+    ostream& write(const unsigned char *s, int n)
+	{ return ((ostream*)this)->write((char*)s, n); }
+    ostream& write(const void *s, int n)
+	{ return ((ostream*)this)->write((char*)s, n); }
+    ostream& form(const char *format ...);
+    ostream& vform(const char *format, char*  args)
+	{ return ((ostream*)this)->vform(format, args); }
+    ostream& seekp(streampos pos) { return ((ostream*)this)->seekp(pos); }
+    ostream& seekp(streamoff off, _seek_dir dir)
+	{ return ((ostream*)this)->seekp(off, dir); }
+    streampos tellp() { return ((ostream*)this)->tellp(); }
+};
+
+extern istream cin;
+extern ostream cout, cerr, clog; // clog->rdbuf() == cerr->rdbuf()
+
+inline ostream& ostream::put(char c) { _strbuf->sputc(c); return *this; }
+
+struct Iostream_init { } ;  // Compatibility hack for AT&T libraray.
+
+
+//# 7 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/stream.h" 2
+
+
+extern char* form(char*, ...);
+
+extern char* dec(long, int=0);
+extern char* dec(int, int=0);
+extern char* dec(unsigned long, int=0);
+extern char* dec(unsigned int, int=0);
+
+extern char* hex(long, int=0);
+extern char* hex(int, int=0);
+extern char* hex(unsigned long, int=0);
+extern char* hex(unsigned int, int=0);
+
+extern char* oct(long, int=0);
+extern char* oct(int, int=0);
+extern char* oct(unsigned long, int=0);
+extern char* oct(unsigned int, int=0);
+
+inline istream& WS(istream& str) { return ws(str); }
+
+
+//# 26 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/String.h" 2
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/Regex.h" 1
+// This may look like C code, but it is really -*- C++ -*-
+/*
+Copyright (C) 1988 Free Software Foundation
+    written by Doug Lea (dl@rocky.oswego.edu)
+
+This file is part of the GNU C++ Library.  This library is free
+software; you can redistribute it and/or modify it under the terms of
+the GNU Library General Public License as published by the Free
+Software Foundation; either version 2 of the License, or (at your
+option) any later version.  This library is distributed in the hope
+that it will be useful, but WITHOUT ANY WARRANTY; without even the
+implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.  See the GNU Library General Public License for more details.
+You should have received a copy of the GNU Library General Public
+License along with this library; if not, write to the Free Software
+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+
+
+//#pragma interface
+
+
+
+
+
+
+
+
+
+struct re_pattern_buffer;       // defined elsewhere
+struct re_registers;
+
+class Regex
+{
+private:
+
+                     Regex(const Regex&) {}  // no X(X&)
+  void               operator = (const Regex&) {} // no assignment
+
+protected:
+  re_pattern_buffer* buf;
+  re_registers*      reg;
+
+public:
+                     Regex(const char* t,
+                           int fast = 0,
+                           int bufsize = 40,
+                           const char* transtable = 0);
+
+                    ~Regex();
+
+  int                match(const char* s, int len, int pos = 0) const;
+  int                search(const char* s, int len,
+                            int& matchlen, int startpos = 0) const;
+  int                match_info(int& start, int& length, int nth = 0) const;
+
+  int                OK() const;  // representation invariant
+};
+
+// some built in regular expressions
+
+extern const Regex RXwhite;          // = "[ \n\t\r\v\f]+"
+extern const Regex RXint;            // = "-?[0-9]+"
+extern const Regex RXdouble;         // = "-?\\(\\([0-9]+\\.[0-9]*\\)\\|
+                                     //    \\([0-9]+\\)\\|\\(\\.[0-9]+\\)\\)
+                                     //    \\([eE][---+]?[0-9]+\\)?"
+extern const Regex RXalpha;          // = "[A-Za-z]+"
+extern const Regex RXlowercase;      // = "[a-z]+"
+extern const Regex RXuppercase;      // = "[A-Z]+"
+extern const Regex RXalphanum;       // = "[0-9A-Za-z]+"
+extern const Regex RXidentifier;     // = "[A-Za-z_][A-Za-z0-9_]*"
+
+
+
+//# 27 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/String.h" 2
+
+
+struct StrRep                     // internal String representations
+{
+  unsigned short    len;         // string length
+  unsigned short    sz;          // allocated space
+  char              s[1];        // the string starts here
+                                 // (at least 1 char for trailing null)
+                                 // allocated & expanded via non-public fcts
+};
+
+// primitive ops on StrReps -- nearly all String fns go through these.
+
+StrRep*     Salloc(StrRep*, const char*, int, int);
+StrRep*     Scopy(StrRep*, StrRep*);
+StrRep*     Sresize(StrRep*, int);
+StrRep*     Scat(StrRep*, const char*, int, const char*, int);
+StrRep*     Scat(StrRep*, const char*, int,const char*,int, const char*,int);
+StrRep*     Sprepend(StrRep*, const char*, int);
+StrRep*     Sreverse(StrRep*, StrRep*);
+StrRep*     Supcase(StrRep*, StrRep*);
+StrRep*     Sdowncase(StrRep*, StrRep*);
+StrRep*     Scapitalize(StrRep*, StrRep*);
+
+// These classes need to be defined in the order given
+
+class String;
+class SubString;
+
+class SubString
+{
+  friend class      String;
+protected:
+
+  String&           S;        // The String I'm a substring of
+  unsigned short    pos;      // starting position in S's rep
+  unsigned short    len;      // length of substring
+
+  void              assign(StrRep*, const char*, int = -1);
+                    SubString(String& x, int p, int l);
+                    SubString(const SubString& x);
+
+public:
+
+// Note there are no public constructors. SubStrings are always
+// created via String operations
+
+                   ~SubString();
+
+  void              operator =  (const String&     y);
+  void              operator =  (const SubString&  y);
+  void              operator =  (const char* t);
+  void              operator =  (char        c);
+
+// return 1 if target appears anywhere in SubString; else 0
+
+  int               contains(char        c) const;
+  int               contains(const String&     y) const;
+  int               contains(const SubString&  y) const;
+  int               contains(const char* t) const;
+  int               contains(const Regex&       r) const;
+
+// return 1 if target matches entire SubString
+
+  int               matches(const Regex&  r) const;
+
+// IO
+
+  friend ostream&   operator<<(ostream& s, const SubString& x);
+
+// status
+
+  unsigned int      length() const;
+  int               empty() const;
+  const char*       chars() const;
+
+  int               OK() const;
+
+};
+
+
+class String
+{
+  friend class      SubString;
+
+protected:
+  StrRep*           rep;   // Strings are pointers to their representations
+
+// some helper functions
+
+  int               search(int, int, const char*, int = -1) const;
+  int               search(int, int, char) const;
+  int               match(int, int, int, const char*, int = -1) const;
+  int               _gsub(const char*, int, const char* ,int);
+  int               _gsub(const Regex&, const char*, int);
+  SubString         _substr(int, int);
+
+public:
+
+// constructors & assignment
+
+                    String();
+                    String(const String& x);
+                    String(const SubString&  x);
+                    String(const char* t);
+                    String(const char* t, int len);
+                    String(char c);
+
+                    ~String();
+
+  void              operator =  (const String&     y);
+  void              operator =  (const char* y);
+  void              operator =  (char        c);
+  void              operator =  (const SubString&  y);
+
+// concatenation
+
+  void              operator += (const String&     y);
+  void              operator += (const SubString&  y);
+  void              operator += (const char* t);
+  void              operator += (char        c);
+
+  void              prepend(const String&     y);
+  void              prepend(const SubString&  y);
+  void              prepend(const char* t);
+  void              prepend(char        c);
+
+
+// procedural versions:
+// concatenate first 2 args, store result in last arg
+
+  friend void     cat(const String&, const String&, String&);
+  friend void     cat(const String&, const SubString&, String&);
+  friend void     cat(const String&, const char*, String&);
+  friend void     cat(const String&, char, String&);
+
+  friend void     cat(const SubString&, const String&, String&);
+  friend void     cat(const SubString&, const SubString&, String&);
+  friend void     cat(const SubString&, const char*, String&);
+  friend void     cat(const SubString&, char, String&);
+
+  friend void     cat(const char*, const String&, String&);
+  friend void     cat(const char*, const SubString&, String&);
+  friend void     cat(const char*, const char*, String&);
+  friend void     cat(const char*, char, String&);
+
+// double concatenation, by request. (yes, there are too many versions,
+// but if one is supported, then the others should be too...)
+// Concatenate first 3 args, store in last arg
+
+  friend void     cat(const String&,const String&, const String&,String&);
+  friend void     cat(const String&,const String&,const SubString&,String&);
+  friend void     cat(const String&,const String&, const char*, String&);
+  friend void     cat(const String&,const String&, char, String&);
+  friend void     cat(const String&,const SubString&,const String&,String&);
+  friend void     cat(const String&,const SubString&,const SubString&,String&);
+  friend void     cat(const String&,const SubString&, const char*, String&);
+  friend void     cat(const String&,const SubString&, char, String&);
+  friend void     cat(const String&,const char*, const String&,    String&);
+  friend void     cat(const String&,const char*, const SubString&, String&);
+  friend void     cat(const String&,const char*, const char*, String&);
+  friend void     cat(const String&,const char*, char, String&);
+
+  friend void     cat(const char*, const String&, const String&,String&);
+  friend void     cat(const char*,const String&,const SubString&,String&);
+  friend void     cat(const char*,const String&, const char*, String&);
+  friend void     cat(const char*,const String&, char, String&);
+  friend void     cat(const char*,const SubString&,const String&,String&);
+  friend void     cat(const char*,const SubString&,const SubString&,String&);
+  friend void     cat(const char*,const SubString&, const char*, String&);
+  friend void     cat(const char*,const SubString&, char, String&);
+  friend void     cat(const char*,const char*, const String&,    String&);
+  friend void     cat(const char*,const char*, const SubString&, String&);
+  friend void     cat(const char*,const char*, const char*, String&);
+  friend void     cat(const char*,const char*, char, String&);
+
+
+// searching & matching
+
+// return position of target in string or -1 for failure
+
+  int               index(char        c, int startpos = 0) const;
+  int               index(const String&     y, int startpos = 0) const;
+  int               index(const SubString&  y, int startpos = 0) const;
+  int               index(const char* t, int startpos = 0) const;
+  int               index(const Regex&      r, int startpos = 0) const;
+
+// return 1 if target appears anyhere in String; else 0
+
+  int               contains(char        c) const;
+  int               contains(const String&     y) const;
+  int               contains(const SubString&  y) const;
+  int               contains(const char* t) const;
+  int               contains(const Regex&      r) const;
+
+// return 1 if target appears anywhere after position pos
+// (or before, if pos is negative) in String; else 0
+
+  int               contains(char        c, int pos) const;
+  int               contains(const String&     y, int pos) const;
+  int               contains(const SubString&  y, int pos) const;
+  int               contains(const char* t, int pos) const;
+  int               contains(const Regex&      r, int pos) const;
+
+// return 1 if target appears at position pos in String; else 0
+
+  int               matches(char        c, int pos = 0) const;
+  int               matches(const String&     y, int pos = 0) const;
+  int               matches(const SubString&  y, int pos = 0) const;
+  int               matches(const char* t, int pos = 0) const;
+  int               matches(const Regex&      r, int pos = 0) const;
+
+//  return number of occurences of target in String
+
+  int               freq(char        c) const;
+  int               freq(const String&     y) const;
+  int               freq(const SubString&  y) const;
+  int               freq(const char* t) const;
+
+// SubString extraction
+
+// Note that you can't take a substring of a const String, since
+// this leaves open the possiblility of indirectly modifying the
+// String through the SubString
+
+  SubString         at(int         pos, int len);
+  SubString         operator () (int         pos, int len); // synonym for at
+
+  SubString         at(const String&     x, int startpos = 0);
+  SubString         at(const SubString&  x, int startpos = 0);
+  SubString         at(const char* t, int startpos = 0);
+  SubString         at(char        c, int startpos = 0);
+  SubString         at(const Regex&      r, int startpos = 0);
+
+  SubString         before(int          pos);
+  SubString         before(const String&      x, int startpos = 0);
+  SubString         before(const SubString&   x, int startpos = 0);
+  SubString         before(const char*  t, int startpos = 0);
+  SubString         before(char         c, int startpos = 0);
+  SubString         before(const Regex&       r, int startpos = 0);
+
+  SubString         through(int          pos);
+  SubString         through(const String&      x, int startpos = 0);
+  SubString         through(const SubString&   x, int startpos = 0);
+  SubString         through(const char*  t, int startpos = 0);
+  SubString         through(char         c, int startpos = 0);
+  SubString         through(const Regex&       r, int startpos = 0);
+
+  SubString         from(int          pos);
+  SubString         from(const String&      x, int startpos = 0);
+  SubString         from(const SubString&   x, int startpos = 0);
+  SubString         from(const char*  t, int startpos = 0);
+  SubString         from(char         c, int startpos = 0);
+  SubString         from(const Regex&       r, int startpos = 0);
+
+  SubString         after(int         pos);
+  SubString         after(const String&     x, int startpos = 0);
+  SubString         after(const SubString&  x, int startpos = 0);
+  SubString         after(const char* t, int startpos = 0);
+  SubString         after(char        c, int startpos = 0);
+  SubString         after(const Regex&      r, int startpos = 0);
+
+
+// deletion
+
+// delete len chars starting at pos
+  void              del(int         pos, int len);
+
+// delete the first occurrence of target after startpos
+
+  void              del(const String&     y, int startpos = 0);
+  void              del(const SubString&  y, int startpos = 0);
+  void              del(const char* t, int startpos = 0);
+  void              del(char        c, int startpos = 0);
+  void              del(const Regex&      r, int startpos = 0);
+
+// global substitution: substitute all occurrences of pat with repl
+
+  int               gsub(const String&     pat, const String&     repl);
+  int               gsub(const SubString&  pat, const String&     repl);
+  int               gsub(const char* pat, const String&     repl);
+  int               gsub(const char* pat, const char* repl);
+  int               gsub(const Regex&      pat, const String&     repl);
+
+// friends & utilities
+
+// split string into array res at separators; return number of elements
+
+  friend int        split(const String& x, String res[], int maxn,
+                          const String& sep);
+  friend int        split(const String& x, String res[], int maxn,
+                          const Regex&  sep);
+
+  friend String     common_prefix(const String& x, const String& y,
+                                  int startpos = 0);
+  friend String     common_suffix(const String& x, const String& y,
+                                  int startpos = -1);
+  friend String     replicate(char        c, int n);
+  friend String     replicate(const String&     y, int n);
+  friend String     join(String src[], int n, const String& sep);
+
+// simple builtin transformations
+
+  friend String     reverse(const String& x);
+  friend String     upcase(const String& x);
+  friend String     downcase(const String& x);
+  friend String     capitalize(const String& x);
+
+// in-place versions of above
+
+  void              reverse();
+  void              upcase();
+  void              downcase();
+  void              capitalize();
+
+// element extraction
+
+  char&             operator [] (int i);
+  char              elem(int i) const;
+  char              firstchar() const;
+  char              lastchar() const;
+
+// conversion
+
+                    operator const char*() const;
+  const char*       chars() const;
+
+
+// IO
+
+  friend ostream&   operator<<(ostream& s, const String& x);
+  friend ostream&   operator<<(ostream& s, const SubString& x);
+  friend istream&   operator>>(istream& s, String& x);
+
+  friend int        readline(istream& s, String& x,
+                             char terminator = '\n',
+                             int discard_terminator = 1);
+
+// status
+
+  unsigned int      length() const;
+  int               empty() const;
+
+// preallocate some space for String
+  void              alloc(int newsize);
+
+// report current allocation (not length!)
+
+  int               allocation() const;
+
+
+  volatile void     error(const char* msg) const;
+
+  int               OK() const;
+};
+
+typedef String StrTmp; // for backward compatibility
+
+// other externs
+
+int        compare(const String&    x, const String&     y);
+int        compare(const String&    x, const SubString&  y);
+int        compare(const String&    x, const char* y);
+int        compare(const SubString& x, const String&     y);
+int        compare(const SubString& x, const SubString&  y);
+int        compare(const SubString& x, const char* y);
+int        fcompare(const String&   x, const String&     y); // ignore case
+
+extern StrRep  _nilStrRep;
+extern String _nilString;
+
+// other inlines
+
+String operator + (const String& x, const String& y);
+String operator + (const String& x, const SubString& y);
+String operator + (const String& x, const char* y);
+String operator + (const String& x, char y);
+String operator + (const SubString& x, const String& y);
+String operator + (const SubString& x, const SubString& y);
+String operator + (const SubString& x, const char* y);
+String operator + (const SubString& x, char y);
+String operator + (const char* x, const String& y);
+String operator + (const char* x, const SubString& y);
+
+int operator==(const String& x, const String& y);
+int operator!=(const String& x, const String& y);
+int operator> (const String& x, const String& y);
+int operator>=(const String& x, const String& y);
+int operator< (const String& x, const String& y);
+int operator<=(const String& x, const String& y);
+int operator==(const String& x, const SubString&  y);
+int operator!=(const String& x, const SubString&  y);
+int operator> (const String& x, const SubString&  y);
+int operator>=(const String& x, const SubString&  y);
+int operator< (const String& x, const SubString&  y);
+int operator<=(const String& x, const SubString&  y);
+int operator==(const String& x, const char* t);
+int operator!=(const String& x, const char* t);
+int operator> (const String& x, const char* t);
+int operator>=(const String& x, const char* t);
+int operator< (const String& x, const char* t);
+int operator<=(const String& x, const char* t);
+int operator==(const SubString& x, const String& y);
+int operator!=(const SubString& x, const String& y);
+int operator> (const SubString& x, const String& y);
+int operator>=(const SubString& x, const String& y);
+int operator< (const SubString& x, const String& y);
+int operator<=(const SubString& x, const String& y);
+int operator==(const SubString& x, const SubString&  y);
+int operator!=(const SubString& x, const SubString&  y);
+int operator> (const SubString& x, const SubString&  y);
+int operator>=(const SubString& x, const SubString&  y);
+int operator< (const SubString& x, const SubString&  y);
+int operator<=(const SubString& x, const SubString&  y);
+int operator==(const SubString& x, const char* t);
+int operator!=(const SubString& x, const char* t);
+int operator> (const SubString& x, const char* t);
+int operator>=(const SubString& x, const char* t);
+int operator< (const SubString& x, const char* t);
+int operator<=(const SubString& x, const char* t);
+
+
+
+
+// status reports, needed before defining other things
+
+inline unsigned int String::length() const {  return rep->len; }
+inline int         String::empty() const { return rep->len == 0; }
+inline const char* String::chars() const { return &(rep->s[0]); }
+inline int         String::allocation() const { return rep->sz; }
+inline void        String::alloc(int newsize) { rep = Sresize(rep, newsize); }
+
+inline unsigned int SubString::length() const { return len; }
+inline int         SubString::empty() const { return len == 0; }
+inline const char* SubString::chars() const { return &(S.rep->s[pos]); }
+
+
+// constructors
+
+inline String::String()
+  : rep(&_nilStrRep) {}
+inline String::String(const String& x)
+  : rep(Scopy(0, x.rep)) {}
+inline String::String(const char* t)
+  : rep(Salloc(0, t, -1, -1)) {}
+inline String::String(const char* t, int tlen)
+  : rep(Salloc(0, t, tlen, tlen)) {}
+inline String::String(const SubString& y)
+  : rep(Salloc(0, y.chars(), y.length(), y.length())) {}
+inline String::String(char c)
+  : rep(Salloc(0, &c, 1, 1)) {}
+
+inline String::~String() { if (rep != &_nilStrRep) delete rep; }
+
+inline SubString::SubString(const SubString& x)
+  :S(x.S), pos(x.pos), len(x.len) {}
+inline SubString::SubString(String& x, int first, int l)
+  :S(x), pos(first), len(l) {}
+
+inline SubString::~SubString() {}
+
+// assignment
+
+inline void String::operator =  (const String& y)
+{
+  rep = Scopy(rep, y.rep);
+}
+
+inline void String::operator=(const char* t)
+{
+  rep = Salloc(rep, t, -1, -1);
+}
+
+inline void String::operator=(const SubString&  y)
+{
+  rep = Salloc(rep, y.chars(), y.length(), y.length());
+}
+
+inline void String::operator=(char c)
+{
+  rep = Salloc(rep, &c, 1, 1);
+}
+
+
+inline void SubString::operator = (const char* ys)
+{
+  assign(0, ys);
+}
+
+inline void SubString::operator = (char ch)
+{
+  assign(0, &ch, 1);
+}
+
+inline void SubString::operator = (const String& y)
+{
+  assign(y.rep, y.chars(), y.length());
+}
+
+inline void SubString::operator = (const SubString& y)
+{
+  assign(y.S.rep, y.chars(), y.length());
+}
+
+// Zillions of cats...
+
+inline void cat(const String& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const String& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const SubString& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const SubString& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const SubString& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const SubString& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const char* x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, x, -1, y.chars(), y.length());
+}
+
+inline void cat(const char* x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, x, -1, y.chars(), y.length());
+}
+
+inline void cat(const char* x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, x, -1, y, -1);
+}
+
+inline void cat(const char* x, char y, String& r)
+{
+  r.rep = Scat(r.rep, x, -1, &y, 1);
+}
+
+inline void cat(const String& a, const String& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& a, const String& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& a, const String& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const String& a, const String& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const String& a, const SubString& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& a, const SubString& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& a, const SubString& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const String& a, const SubString& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const String& a, const char* x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x, -1, y.chars(), y.length());
+}
+
+inline void cat(const String& a, const char* x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x, -1, y.chars(), y.length());
+}
+
+inline void cat(const String& a, const char* x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x, -1, y, -1);
+}
+
+inline void cat(const String& a, const char* x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x, -1, &y, 1);
+}
+
+
+inline void cat(const char* a, const String& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const char* a, const String& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const char* a, const String& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const char* a, const String& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const char* a, const SubString& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const char* a, const SubString& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const char* a, const SubString& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const char* a, const SubString& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const char* a, const char* x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x, -1, y.chars(), y.length());
+}
+
+inline void cat(const char* a, const char* x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x, -1, y.chars(), y.length());
+}
+
+inline void cat(const char* a, const char* x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x, -1, y, -1);
+}
+
+inline void cat(const char* a, const char* x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x, -1, &y, 1);
+}
+
+
+// operator versions
+
+inline void String::operator +=(const String& y)
+{
+  cat(*this, y, *this);
+}
+
+inline void String::operator +=(const SubString& y)
+{
+  cat(*this, y, *this);
+}
+
+inline void String::operator += (const char* y)
+{
+  cat(*this, y, *this);
+}
+
+inline void String:: operator +=(char y)
+{
+  cat(*this, y, *this);
+}
+
+// constructive concatenation
+
+
+
+inline String operator + (const String& x, const String& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const String& x, const SubString& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const String& x, const char* y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const String& x, char y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const SubString& x, const String& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const SubString& x, const SubString& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const SubString& x, const char* y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const SubString& x, char y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const char* x, const String& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const char* x, const SubString& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String reverse(const String& x) return r;
+{
+  r.rep = Sreverse(x.rep, r.rep);
+}
+
+inline String upcase(const String& x) return r;
+{
+  r.rep = Supcase(x.rep, r.rep);
+}
+
+inline String downcase(const String& x) return r;
+{
+  r.rep = Sdowncase(x.rep, r.rep);
+}
+
+inline String capitalize(const String& x) return r;
+{
+  r.rep = Scapitalize(x.rep, r.rep);
+}
+
+//# 883 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/String.h"
+
+
+// prepend
+
+inline void String::prepend(const String& y)
+{
+  rep = Sprepend(rep, y.chars(), y.length());
+}
+
+inline void String::prepend(const char* y)
+{
+  rep = Sprepend(rep, y, -1);
+}
+
+inline void String::prepend(char y)
+{
+  rep = Sprepend(rep, &y, 1);
+}
+
+inline void String::prepend(const SubString& y)
+{
+  rep = Sprepend(rep, y.chars(), y.length());
+}
+
+// misc transformations
+
+
+inline void String::reverse()
+{
+  rep = Sreverse(rep, rep);
+}
+
+
+inline void String::upcase()
+{
+  rep = Supcase(rep, rep);
+}
+
+
+inline void String::downcase()
+{
+  rep = Sdowncase(rep, rep);
+}
+
+
+inline void String::capitalize()
+{
+  rep = Scapitalize(rep, rep);
+}
+
+// element extraction
+
+inline char&  String::operator [] (int i)
+{
+  if (((unsigned)i) >= length()) error("invalid index");
+  return rep->s[i];
+}
+
+inline char  String::elem (int i) const
+{
+  if (((unsigned)i) >= length()) error("invalid index");
+  return rep->s[i];
+}
+
+inline char  String::firstchar() const
+{
+  return elem(0);
+}
+
+inline char  String::lastchar() const
+{
+  return elem(length() - 1);
+}
+
+// searching
+
+inline int String::index(char c, int startpos) const
+{
+  return search(startpos, length(), c);
+}
+
+inline int String::index(const char* t, int startpos) const
+{
+  return search(startpos, length(), t);
+}
+
+inline int String::index(const String& y, int startpos) const
+{
+  return search(startpos, length(), y.chars(), y.length());
+}
+
+inline int String::index(const SubString& y, int startpos) const
+{
+  return search(startpos, length(), y.chars(), y.length());
+}
+
+inline int String::index(const Regex& r, int startpos) const
+{
+  int unused;  return r.search(chars(), length(), unused, startpos);
+}
+
+inline int String::contains(char c) const
+{
+  return search(0, length(), c) >= 0;
+}
+
+inline int String::contains(const char* t) const
+{
+  return search(0, length(), t) >= 0;
+}
+
+inline int String::contains(const String& y) const
+{
+  return search(0, length(), y.chars(), y.length()) >= 0;
+}
+
+inline int String::contains(const SubString& y) const
+{
+  return search(0, length(), y.chars(), y.length()) >= 0;
+}
+
+inline int String::contains(char c, int p) const
+{
+  return match(p, length(), 0, &c, 1) >= 0;
+}
+
+inline int String::contains(const char* t, int p) const
+{
+  return match(p, length(), 0, t) >= 0;
+}
+
+inline int String::contains(const String& y, int p) const
+{
+  return match(p, length(), 0, y.chars(), y.length()) >= 0;
+}
+
+inline int String::contains(const SubString& y, int p) const
+{
+  return match(p, length(), 0, y.chars(), y.length()) >= 0;
+}
+
+inline int String::contains(const Regex& r) const
+{
+  int unused;  return r.search(chars(), length(), unused, 0) >= 0;
+}
+
+inline int String::contains(const Regex& r, int p) const
+{
+  return r.match(chars(), length(), p) >= 0;
+}
+
+
+inline int String::matches(const SubString& y, int p) const
+{
+  return match(p, length(), 1, y.chars(), y.length()) >= 0;
+}
+
+inline int String::matches(const String& y, int p) const
+{
+  return match(p, length(), 1, y.chars(), y.length()) >= 0;
+}
+
+inline int String::matches(const char* t, int p) const
+{
+  return match(p, length(), 1, t) >= 0;
+}
+
+inline int String::matches(char c, int p) const
+{
+  return match(p, length(), 1, &c, 1) >= 0;
+}
+
+inline int String::matches(const Regex& r, int p) const
+{
+  int l = (p < 0)? -p : length() - p;
+  return r.match(chars(), length(), p) == l;
+}
+
+
+inline int SubString::contains(const char* t) const
+{
+  return S.search(pos, pos+len, t) >= 0;
+}
+
+inline int SubString::contains(const String& y) const
+{
+  return S.search(pos, pos+len, y.chars(), y.length()) >= 0;
+}
+
+inline int SubString::contains(const SubString&  y) const
+{
+  return S.search(pos, pos+len, y.chars(), y.length()) >= 0;
+}
+
+inline int SubString::contains(char c) const
+{
+  return S.search(pos, pos+len, 0, c) >= 0;
+}
+
+inline int SubString::contains(const Regex& r) const
+{
+  int unused;  return r.search(chars(), len, unused, 0) >= 0;
+}
+
+inline int SubString::matches(const Regex& r) const
+{
+  return r.match(chars(), len, 0) == len;
+}
+
+
+inline int String::gsub(const String& pat, const String& r)
+{
+  return _gsub(pat.chars(), pat.length(), r.chars(), r.length());
+}
+
+inline int String::gsub(const SubString&  pat, const String& r)
+{
+  return _gsub(pat.chars(), pat.length(), r.chars(), r.length());
+}
+
+inline int String::gsub(const Regex& pat, const String& r)
+{
+  return _gsub(pat, r.chars(), r.length());
+}
+
+inline int String::gsub(const char* pat, const String& r)
+{
+  return _gsub(pat, -1, r.chars(), r.length());
+}
+
+inline int String::gsub(const char* pat, const char* r)
+{
+  return _gsub(pat, -1, r, -1);
+}
+
+
+
+inline  ostream& operator<<(ostream& s, const String& x)
+{
+   s << x.chars(); return s;
+}
+
+// a zillion comparison operators
+
+inline int operator==(const String& x, const String& y)
+{
+  return compare(x, y) == 0;
+}
+
+inline int operator!=(const String& x, const String& y)
+{
+  return compare(x, y) != 0;
+}
+
+inline int operator>(const String& x, const String& y)
+{
+  return compare(x, y) > 0;
+}
+
+inline int operator>=(const String& x, const String& y)
+{
+  return compare(x, y) >= 0;
+}
+
+inline int operator<(const String& x, const String& y)
+{
+  return compare(x, y) < 0;
+}
+
+inline int operator<=(const String& x, const String& y)
+{
+  return compare(x, y) <= 0;
+}
+
+inline int operator==(const String& x, const SubString&  y)
+{
+  return compare(x, y) == 0;
+}
+
+inline int operator!=(const String& x, const SubString&  y)
+{
+  return compare(x, y) != 0;
+}
+
+inline int operator>(const String& x, const SubString&  y)
+{
+  return compare(x, y) > 0;
+}
+
+inline int operator>=(const String& x, const SubString&  y)
+{
+  return compare(x, y) >= 0;
+}
+
+inline int operator<(const String& x, const SubString&  y)
+{
+  return compare(x, y) < 0;
+}
+
+inline int operator<=(const String& x, const SubString&  y)
+{
+  return compare(x, y) <= 0;
+}
+
+inline int operator==(const String& x, const char* t)
+{
+  return compare(x, t) == 0;
+}
+
+inline int operator!=(const String& x, const char* t)
+{
+  return compare(x, t) != 0;
+}
+
+inline int operator>(const String& x, const char* t)
+{
+  return compare(x, t) > 0;
+}
+
+inline int operator>=(const String& x, const char* t)
+{
+  return compare(x, t) >= 0;
+}
+
+inline int operator<(const String& x, const char* t)
+{
+  return compare(x, t) < 0;
+}
+
+inline int operator<=(const String& x, const char* t)
+{
+  return compare(x, t) <= 0;
+}
+
+inline int operator==(const SubString& x, const String& y)
+{
+  return compare(y, x) == 0;
+}
+
+inline int operator!=(const SubString& x, const String& y)
+{
+  return compare(y, x) != 0;
+}
+
+inline int operator>(const SubString& x, const String& y)
+{
+  return compare(y, x) < 0;
+}
+
+inline int operator>=(const SubString& x, const String& y)
+{
+  return compare(y, x) <= 0;
+}
+
+inline int operator<(const SubString& x, const String& y)
+{
+  return compare(y, x) > 0;
+}
+
+inline int operator<=(const SubString& x, const String& y)
+{
+  return compare(y, x) >= 0;
+}
+
+inline int operator==(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) == 0;
+}
+
+inline int operator!=(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) != 0;
+}
+
+inline int operator>(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) > 0;
+}
+
+inline int operator>=(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) >= 0;
+}
+
+inline int operator<(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) < 0;
+}
+
+inline int operator<=(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) <= 0;
+}
+
+inline int operator==(const SubString& x, const char* t)
+{
+  return compare(x, t) == 0;
+}
+
+inline int operator!=(const SubString& x, const char* t)
+{
+  return compare(x, t) != 0;
+}
+
+inline int operator>(const SubString& x, const char* t)
+{
+  return compare(x, t) > 0;
+}
+
+inline int operator>=(const SubString& x, const char* t)
+{
+  return compare(x, t) >= 0;
+}
+
+inline int operator<(const SubString& x, const char* t)
+{
+  return compare(x, t) < 0;
+}
+
+inline int operator<=(const SubString& x, const char* t)
+{
+  return compare(x, t) <= 0;
+}
+
+
+// a helper needed by at, before, etc.
+
+inline SubString String::_substr(int first, int l)
+{
+  if (first >= length() )  // ??? THIS LINE IS QUESTIONABLE
+    return SubString(_nilString, 0, 0) ;
+  else
+    return SubString(*this, first, l);
+}
+
+
+
+
+
+//# 26 "../../GctSymbol.h" 2
+
+
+//# 1 "../../../../../../mips/include/Gct/Object/GctHashObject.h" 1
+// -*- C++ -*-
+
+
+
+//
+// GctHashObject class (is abstract)
+//
+// Expects to be included by Object.h or where needed explicitly.
+//
+// Wendell Baker, Berkeley CAD Group, 1992 (wbaker@ic.Berkeley.EDU)
+//
+
+
+
+
+
+//#pragma interface
+
+
+
+//# 1 "../../../../../../mips/include/Gct/Object/GctObject.h" 1
+// -*- C++ -*-
+
+
+
+//
+// GctObject class (is abstract)
+//
+// Expects to be included by Object.h or where needed explicitly.
+//
+// Wendell Baker, Berkeley CAD Group, 1992 (wbaker@ic.Berkeley.EDU)
+//
+
+
+
+
+
+//#pragma interface
+
+
+
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/tostrstream.h" 1
+// -*- C++ -*-
+
+
+
+//
+// tostrstream class
+//
+// A terminated oststream - an ostsrstream that auto-terminates on str()
+//
+// Wendell Baker, Berkeley CAD Group, 1992 (wbaker@ic.Berkeley.EDU)
+//
+
+
+
+
+
+//#pragma interface
+
+
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/strstream.h" 1
+//    This is part of the iostream library, providing input/output for C++.
+//    Copyright (C) 1991 Per Bothner.
+//
+//    This library is free software; you can redistribute it and/or
+//    modify it under the terms of the GNU Library General Public
+//    License as published by the Free Software Foundation; either
+//    version 2 of the License, or (at your option) any later version.
+//
+//    This library is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//    Library General Public License for more details.
+//
+//    You should have received a copy of the GNU Library General Public
+//    License along with this library; if not, write to the Free
+//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+
+
+
+//#pragma interface
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h" 1
+//    This is part of the iostream library, providing -*- C++ -*- input/output.
+//    Copyright (C) 1991 Per Bothner.
+//
+//    This library is free software; you can redistribute it and/or
+//    modify it under the terms of the GNU Library General Public
+//    License as published by the Free Software Foundation; either
+//    version 2 of the License, or (at your option) any later version.
+//
+//    This library is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//    Library General Public License for more details.
+//
+//    You should have received a copy of the GNU Library General Public
+//    License along with this library; if not, write to the Free
+//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+//# 210 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h"
+
+//# 23 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/strstream.h" 2
+
+
+class strstreambuf : public streambuf {
+    size_t *lenp; /* current (logical) length (i.e. valid data bytes) */
+    size_t *sizep; /* allocated (physical) buffer size */
+    char **bufp;
+    size_t _len;
+    size_t _size;
+    char *buf;
+    int _frozen;
+  protected:
+    virtual int overflow(int = (-1) );
+  public:
+    strstreambuf();
+    strstreambuf(int initial);
+    strstreambuf(char *ptr, int size, char *pstart = (__null) );
+    ~strstreambuf();
+    int frozen() { return _frozen; }
+    void freeze(int n=1) { _frozen = n != 0; }
+    size_t pcount();
+    char *str();
+};
+
+class istrstream : public istream {
+  public:
+    istrstream(char*);
+    istrstream(char*, int);
+    strstreambuf* rdbuf() { return (strstreambuf*)_strbuf; }
+};
+
+class ostrstream : public ostream {
+  public:
+    ostrstream();
+    ostrstream(char *cp, int n, int mode=ios::out);
+    size_t pcount() { return ((strstreambuf*)_strbuf)->pcount(); }
+    char *str() { return ((strstreambuf*)_strbuf)->str(); }
+    void freeze(int n = 1) { ((strstreambuf*)_strbuf)->freeze(n); }
+    int frozen() { return ((strstreambuf*)_strbuf)->frozen(); }
+    strstreambuf* rdbuf() { return (strstreambuf*)_strbuf; }
+};
+
+
+//# 25 "/sandbox/wbaker/wbaker0/source/mips/include/tostrstream.h" 2
+
+
+//
+// tostrstream class
+//
+// An isteam class that doesn't have that nasty skipws parameter that
+// you have to remember to set.  This class simply provides the istream
+// functionality with a set of constructors which defaults skipws to
+// FALSE (instead of defaulting to TRUE as is the case with plain istream).
+//
+class tostrstream: public ostrstream {
+public:
+    tostrstream(): ostrstream()
+	{ }
+    // This constructor defines cp as the buffer to use for the
+    // stream (instead of one of its own devising); it does NOT
+    // initialize the ostrstream to contain cp (of length n).
+  tostrstream(char *cp, int n, int mode=ios::out): ostrtream(cp, n, mode)	// ERROR - 
+	{ }
+    char *str()
+	{
+	    char *s = ostrstream::str();
+	    s[ostrstream::pcount()] = '\0';
+	    return s;
+	}
+};
+
+
+//# 25 "../../../../../../mips/include/Gct/Object/GctObject.h" 2
+
+
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/Gtt/GttObject.h" 1
+// -*- C++ -*-
+
+
+
+//
+// GttObject class (is abstract)
+//
+// Expects to be included where needed explicitly.
+//
+// Wendell Baker, Berkeley CAD Group, 1992 (wbaker@ic.Berkeley.EDU)
+//
+
+
+
+
+
+//#pragma interface
+
+
+
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/tostrstream.h" 1
+// -*- C++ -*-
+//# 52 "/sandbox/wbaker/wbaker0/source/mips/include/tostrstream.h"
+
+//# 25 "/sandbox/wbaker/wbaker0/source/mips/include/Gtt/GttObject.h" 2
+
+
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/Gtt/GttErrorHandler.h" 1
+// -*- C++ -*-
+
+
+
+//
+// GttErrorHandler class
+//
+// Expects to be included by Gtt.h
+//
+// Wendell Baker, Berkeley CAD Group, 1992 (wbaker@ic.Berkeley.EDU)
+//
+
+
+
+
+
+//#pragma interface
+
+
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/bool.h" 1
+
+
+
+
+
+
+
+//# 25 "/sandbox/wbaker/wbaker0/source/mips/include/Gtt/GttErrorHandler.h" 2
+
+
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/stuff++.h" 1
+// -*- C++ -*-
+
+
+
+//
+// Fake up a libstuff++
+//
+// This is done as a complete and utter hack; this library has no function
+// at all being in the boot area; it is here solely in order to provide a
+// libstuff++ against which the Makefiles can resolve link lines.
+//
+// The only reason that this is done is to allow the STANDARD_C++_LIBRARIES
+// as provided by the Makefile templates in the boot area to be the same
+// ones that are used by the tools outside this hierarchy.
+//
+// The tools outside this hierarchy use a different libstuff++; one that is
+// written in C++.  This one is not written in C++ in order to be simpler.
+//
+
+
+
+
+
+//#pragma interface
+
+
+
+extern "C" {
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/stuff.h" 1
+
+
+
+/*
+ * Useful stuff
+ */
+
+/*
+ */
+
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/ansi.h" 1
+
+
+
+
+/*
+ * ANSI Compiler Support
+ *
+ * David Harrison
+ * University of California, Berkeley
+ * 1988
+ *
+ * ANSI compatible compilers are supposed to define the preprocessor
+ * directive __STDC__.  Based on this directive, this file defines
+ * certain ANSI specific macros.
+ *
+ * ARGS:
+ *   Used in function prototypes.  Example:
+ *   extern int foo
+ *     ARGS((char *blah, double threshold));
+ */
+
+/*
+ *
+ * Modifications
+ * Wendell C Baker
+ * University of California, Berkeley
+ */
+
+/* Function prototypes */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 15 "/sandbox/wbaker/wbaker0/source/mips/include/stuff.h" 2
+
+
+
+/*
+ * If g++, then we stub out part of this thing and let the C++ types take
+ * over and do the same job; some compatibility must be given however
+ */
+
+/*
+ *    Use the GNU libg++ definition
+ */
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/bool.h" 1
+
+
+
+
+
+
+
+//# 26 "/sandbox/wbaker/wbaker0/source/mips/include/stuff.h" 2
+
+//# 35 "/sandbox/wbaker/wbaker0/source/mips/include/stuff.h"
+
+
+/*
+ * Make various pieces of C code that use the old ``Boolean''
+ * be compatible by faking up the definition of Boolean using
+ * the new bool type.
+ */
+
+
+//# 58 "/sandbox/wbaker/wbaker0/source/mips/include/stuff.h"
+
+
+typedef long FitAny;		/* can fit any integral type */
+
+/*
+ * typedef char *String;	- DO NOT USE THIS - it conflicts with C++
+ * typedef char **Stringv;	- just use char* and char** instead.
+ * 				- void* can be used for arbitrary pointers
+ */
+
+
+
+
+extern int nocase_strcmp (char *, char *)		;
+extern int nocase_strncmp (char *, char *, int)		;
+
+extern bool	 nocase_strequal (char *, char *)		;
+extern bool	 nocase_strnequal (char *, char *, int)		;
+
+extern bool	 lead_strequal (char *, char *)		;
+extern bool	 nocase_lead_strequal (char *, char *)		;
+
+extern int strhash (char *, int)		;
+extern int nocase_strhash (char *, int)		;
+
+extern int sign (int)		;
+
+/*
+ *    Some useful macros.
+ */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 33 "/sandbox/wbaker/wbaker0/source/mips/include/stuff++.h" 2
+
+}
+
+//
+// This is here because we wish to provide externs for the two
+// functions btoa(bool, unsigned = 0) and operator<<(ostream&, bool)
+// because they are not provided in bool.h.
+//
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/bool.h" 1
+
+
+
+
+
+
+
+//# 41 "/sandbox/wbaker/wbaker0/source/mips/include/stuff++.h" 2
+
+extern const char *stringify(bool b);
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h" 1
+//    This is part of the iostream library, providing -*- C++ -*- input/output.
+//    Copyright (C) 1991 Per Bothner.
+//
+//    This library is free software; you can redistribute it and/or
+//    modify it under the terms of the GNU Library General Public
+//    License as published by the Free Software Foundation; either
+//    version 2 of the License, or (at your option) any later version.
+//
+//    This library is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//    Library General Public License for more details.
+//
+//    You should have received a copy of the GNU Library General Public
+//    License along with this library; if not, write to the Free
+//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+//# 210 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h"
+
+//# 43 "/sandbox/wbaker/wbaker0/source/mips/include/stuff++.h" 2
+
+extern ostream& operator<<(ostream&, bool);
+
+// Should this be kept separate?   bool isn't, but then  is
+// included here only to define ostream& operator<<(ostream&, bool)
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/unit.h" 1
+// -*- C++ -*-
+
+
+
+//
+// unit enum
+//
+// Wendell Baker, Berkeley CAD Group, 1991 (wbaker@ic.Berkeley.EDU)
+//
+
+
+//
+// unit enum
+//
+// This _looks_ silly, but it has an important theoretical basis in category
+// theory.  For the pragmatic reason for its existence, see the example below.
+//
+enum unit {
+    UNIT = 1,
+};
+
+extern const char *stringify(unit u);
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h" 1
+//    This is part of the iostream library, providing -*- C++ -*- input/output.
+//    Copyright (C) 1991 Per Bothner.
+//
+//    This library is free software; you can redistribute it and/or
+//    modify it under the terms of the GNU Library General Public
+//    License as published by the Free Software Foundation; either
+//    version 2 of the License, or (at your option) any later version.
+//
+//    This library is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//    Library General Public License for more details.
+//
+//    You should have received a copy of the GNU Library General Public
+//    License along with this library; if not, write to the Free
+//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+//# 210 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h"
+
+//# 28 "/sandbox/wbaker/wbaker0/source/mips/include/unit.h" 2
+
+extern ostream& operator<<(ostream&, unit);
+
+//
+// A unit is used in cases where the type signature of an overloaded
+// function must be differentiated in some stronger way than can be
+// denoted unambiguously in the C++ syntax.  This enum is used to give
+// one of the functions a different type signature, thereby allowing
+// the overloading.
+//
+// The use of ``unit'' instead of int or bool is important because a unit
+// has only one possible value; therefore it adds no more information to
+// the code.   For example, say a bool was used instead, then in the testing
+// phase, would have to ask: what if TRUE was given, what if FALSE was given.
+// The problem is compounded if char or int is used.
+//
+// Example:
+//
+//     class ID {
+//     public:
+//         ID();		// construct a null ID
+//         ID(unit);		// alloc a ID with a new id
+//     private:
+//         static unsigned high_water;
+//         unsigned id;
+//     };
+//
+// Try working this example save that ID implements all of the generic
+// features of the identifier object, but the high_water is stored
+// in the heir.  That is what originally motivated the creation of unit.
+//
+
+
+//# 48 "/sandbox/wbaker/wbaker0/source/mips/include/stuff++.h" 2
+
+
+//
+// In the spirit of the standard GNU error handler functions
+// as described in
+//     typedef void (*one_arg_error_handler_t)(const char*);
+//         a one argument error handler function pointer
+//     typedef void (*two_arg_error_handler_t)(const char*, const char*);
+//         a two argument error handler function pointer
+//
+// And now the NEW
+//
+// typedef void (*zero_arg_error_handler_t)();
+//     a zero argument error handler function pointer
+//
+typedef void (*zero_arg_error_handler_t)();
+
+//
+// In the spirit of the default GNU error handler functions
+// as described in
+//     extern void default_one_arg_error_handler(const char *message);
+//         print out message on stderr, and do the default thing (abort)
+//     extern void default_two_arg_error_handler(const char *kind, const char *message);
+//         print out kind and message on stderr, and do the default thing (abort)
+//
+// And now the NEW
+//
+// extern void default_zero_arg_error_handler(const char *message);
+//     do the default thing (abort)
+//
+extern void default_zero_arg_error_handler();
+
+// Guaranteed to exit (1)
+extern void exit_zero_arg_error_handler();
+extern void exit_one_arg_error_handler(const char *message);
+extern void exit_two_arg_error_handler(const char *kind, const char *message);
+
+// Guaranteed to abort()
+extern void abort_zero_arg_error_handler();
+extern void abort_one_arg_error_handler(const char *message);
+extern void abort_two_arg_error_handler(const char *kind, const char *message);
+
+//
+// In the spirit of the standard GNU error handlers
+// as described in
+//     extern void  verbose_File_error_handler(const char*);
+//         perror and set errno = 0
+//     extern void  quiet_File_error_handler(const char*);
+//         set errno = 0
+//     extern void  fatal_File_error_handler(const char*);
+//         perror and exit 1
+//
+// And now the NEW
+//
+// extern void preserve_File_error_handler(const char *message);
+//     no perror, no assignment to errno.
+//
+extern void preserve_File_error_handler(const char *message);
+
+
+//# 27 "/sandbox/wbaker/wbaker0/source/mips/include/Gtt/GttErrorHandler.h" 2
+
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/tostrstream.h" 1
+// -*- C++ -*-
+//# 52 "/sandbox/wbaker/wbaker0/source/mips/include/tostrstream.h"
+
+//# 28 "/sandbox/wbaker/wbaker0/source/mips/include/Gtt/GttErrorHandler.h" 2
+
+
+//
+// It is expected that this will be virtually multiply inherited
+// into all of the classes that need error reporting services.
+//
+// The typical way to have that done is by inheriting the GttObject
+// as a virtual base class.
+//
+
+//
+// GttErrorHandler class
+//
+class GttErrorHandler {
+public:
+    GttErrorHandler();
+    GttErrorHandler(const char *program);
+    virtual ~GttErrorHandler();
+
+    //
+    // Error messages
+    //     - an unacceptable, but expected and recoverable condition
+    //       was detected (but the test fails)
+    //     - errors are for ``the expected environment was not found''
+    //       rather than for ``file couldn't be opened''
+    //     - these messages cannot be shut off
+    //     - the error handler determines the recovery action
+    //       TODO - one day exceptions will be used here
+    //
+    static void error(const char *message);
+    static void error(tostrstream& message);
+
+    static void error(const char *function, const char *message);
+    static void error(const char *function, tostrstream& message);
+
+    static void error(const char *class_name, const char *method, const char *message);
+    static void error(const char *class_name, const char *method, tostrstream& message);
+
+    //
+    // Fatal messages
+    //     - an unacceptable and unexpected error was detected
+    //       the data invariants were violated, there is no recovery
+    //     - these messages cannot be shut off
+    //     - the error handler determines the recovery action
+    //       TODO - one day exceptions will be used here
+    //
+    static void fatal(const char *message);
+    static void fatal(tostrstream& message);
+
+    static void fatal(const char *function, const char *message);
+    static void fatal(const char *function, tostrstream& message);
+
+    static void fatal(const char *class_name, const char *method, const char *message);
+    static void fatal(const char *class_name, const char *method, tostrstream& message);
+private:
+    //
+    // Two underscores are used here in order to prevent confusion of these
+    // private variables with any of the heir's private variables.  Note that
+    // access control is different than visibility in C++, so all the variable
+    // names in a class hierarchy must be unique.
+    //
+
+    static bool __partial_init;
+    static void __partial_initialize();
+    static bool __full_init;
+    static void __full_initialize(const char *program);
+    static char *__program;
+
+    static void __handle_error();
+    static void __handle_fatal();
+    static void __add_newline(const char *message);
+
+    static bool __output_valid();
+    static ostream *__output;
+};
+
+
+//# 27 "/sandbox/wbaker/wbaker0/source/mips/include/Gtt/GttObject.h" 2
+
+
+//
+// GttObject class (is abstract)
+//
+class GttObject: virtual public GttErrorHandler {
+protected:
+    GttObject();
+    GttObject(const GttObject&);
+    virtual ~GttObject();	// ensure descendants have virtual destructors
+
+public:
+    //
+    // I/O Support
+    //
+    // The value typically persists only long enough for an i/o operation
+    // to be performed (see the defintion of output via operator<<(... ) below)
+    virtual const char *stringify();
+protected:
+    // This is the buffer into which the printed representation of this
+    // object will be put when the time comes.  It is associated with the
+    // object so it will never go away (so long as the object exists).
+    // Use a pointer so that you only pay for the space when I/O is used
+    tostrstream *stringbuf;
+    void clear_stringbuf();
+
+public:
+    //
+    // Consistency
+    //
+    // The global data invariant for the whole object (heirs included).
+    // This OK function will call the local invariant function ok() if
+    // necessary and in addition the OK functions of the heirs
+    // This is expected to compute the data invariant of the object.
+    // It will execute GctErrorHandler::fatal if there is wrong.
+    virtual void OK() const;
+
+protected:
+    //
+    // consistency
+    //
+    // This function computes the invariant which is local to this object.
+    // It does not call any of the ancestor's OK() or ok() functions.
+    // It is not a virtual function so that it can be called from within a
+    // constructor with impunity.  Thus this function MUST NOT call any
+    // virtual functions either; it should call them by their full name if
+    // that is necessary.  The global OK() function will call this function
+    // as necessary.
+    //
+    // This function must NOT NEVER EVER be made virtual.
+    void ok() const;
+
+protected:
+    //
+    // Class Name
+    //
+    // This must return a static (constant) string which is the name
+    // of the class being declared.  By convention, not all classes
+    // must have one of these, but the major root abstract class must
+    // have one in order to allow the stringify() to work approximately
+    // correctly.
+    virtual const char *class_name() const = 0;
+};
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h" 1
+//    This is part of the iostream library, providing -*- C++ -*- input/output.
+//    Copyright (C) 1991 Per Bothner.
+//
+//    This library is free software; you can redistribute it and/or
+//    modify it under the terms of the GNU Library General Public
+//    License as published by the Free Software Foundation; either
+//    version 2 of the License, or (at your option) any later version.
+//
+//    This library is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//    Library General Public License for more details.
+//
+//    You should have received a copy of the GNU Library General Public
+//    License along with this library; if not, write to the Free
+//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+//# 210 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h"
+
+//# 91 "/sandbox/wbaker/wbaker0/source/mips/include/Gtt/GttObject.h" 2
+
+extern ostream& operator<<(ostream&, GttObject&);
+
+// There may be other X& operator<<(X&, GttObject&) defined in the
+// packages defining class X.  For example see the definition of
+// GttUnitObject& operator<<(GttUnitObject&, GttObject&) in Unit.
+
+
+//# 27 "../../../../../../mips/include/Gct/Object/GctObject.h" 2
+
+
+//# 1 "../../../../../../mips/include/Gct/GctErrorHandler.h" 1
+// -*- C++ -*-
+
+
+
+//
+// GctErrorHandler class
+//
+// Expects to be included by Gct.h
+//
+// Wendell Baker, Berkeley CAD Group, 1991 (wbaker@ic.Berkeley.EDU)
+//
+
+
+
+
+
+//#pragma interface
+
+
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/bool.h" 1
+
+
+
+
+
+
+
+//# 25 "../../../../../../mips/include/Gct/GctErrorHandler.h" 2
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/String.h" 1
+// This may look like C code, but it is really -*- C++ -*-
+/*
+Copyright (C) 1988 Free Software Foundation
+    written by Doug Lea (dl@rocky.oswego.edu)
+
+This file is part of the GNU C++ Library.  This library is free
+software; you can redistribute it and/or modify it under the terms of
+the GNU Library General Public License as published by the Free
+Software Foundation; either version 2 of the License, or (at your
+option) any later version.  This library is distributed in the hope
+that it will be useful, but WITHOUT ANY WARRANTY; without even the
+implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.  See the GNU Library General Public License for more details.
+You should have received a copy of the GNU Library General Public
+License along with this library; if not, write to the Free Software
+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+//# 1321 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/String.h"
+
+//# 26 "../../../../../../mips/include/Gct/GctErrorHandler.h" 2
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h" 1
+//    This is part of the iostream library, providing -*- C++ -*- input/output.
+//    Copyright (C) 1991 Per Bothner.
+//
+//    This library is free software; you can redistribute it and/or
+//    modify it under the terms of the GNU Library General Public
+//    License as published by the Free Software Foundation; either
+//    version 2 of the License, or (at your option) any later version.
+//
+//    This library is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//    Library General Public License for more details.
+//
+//    You should have received a copy of the GNU Library General Public
+//    License along with this library; if not, write to the Free
+//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+//# 210 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h"
+
+//# 27 "../../../../../../mips/include/Gct/GctErrorHandler.h" 2
+
+
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/stuff++.h" 1
+// -*- C++ -*-
+//# 107 "/sandbox/wbaker/wbaker0/source/mips/include/stuff++.h"
+
+//# 29 "../../../../../../mips/include/Gct/GctErrorHandler.h" 2
+
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/tostrstream.h" 1
+// -*- C++ -*-
+//# 52 "/sandbox/wbaker/wbaker0/source/mips/include/tostrstream.h"
+
+//# 30 "../../../../../../mips/include/Gct/GctErrorHandler.h" 2
+
+
+//# 1 "/sandbox/wbaker/wbaker0/source/mips/include/Gtt/GttObject.h" 1
+// -*- C++ -*-
+//# 98 "/sandbox/wbaker/wbaker0/source/mips/include/Gtt/GttObject.h"
+
+//# 32 "../../../../../../mips/include/Gct/GctErrorHandler.h" 2
+
+
+//
+// It is expected that this will be virtually multiply inherited
+// into all of the classes that need error reporting services.
+//
+// The typical way to have that done is by inheriting the GctObject
+// as a virtual base class.
+//
+
+//
+// GctErrorHandler class
+//
+// GPP_1_96_BUG
+// NOTE - virtual public GttObject should be MI into GctObject - but that
+// causes g++ 1.96 to segfault; so we must inherit GttObject here and use SI
+// GPP_1_96_BUG
+class GctErrorHandler: virtual public GttObject {
+public:
+    GctErrorHandler();
+    GctErrorHandler(const String& program);
+    virtual ~GctErrorHandler();
+
+    //
+    // Debugging messages
+    //     - these are turned off for production code.
+    //     - these messages can be shut off
+    //
+    static void debug(const char *message);
+    static void debug(tostrstream& message);
+
+    static void debug(const char *function, const char *message);
+    static void debug(const char *function, tostrstream& message);
+
+    static void debug(const char *class_name, const char *method, const char *message);
+    static void debug(const char *class_name, const char *method, tostrstream& message);
+
+    static bool debug();		// current debug switch
+    static void debug(bool value);	// change the debug switch
+
+    //
+    // Informational messages
+    //     - these correspond to a ``verbose'' mode
+    //     - these are not errors, just chatty progress reports
+    //     - these messages can be shut off
+    //
+    static void note(const char *message);
+    static void note(tostrstream& message);
+
+    static void note(const char *function, const char *message);
+    static void note(const char *function, tostrstream& message);
+
+    static void note(const char *class_name, const char *method, const char *message);
+    static void note(const char *class_name, const char *method, tostrstream& message);
+
+    static bool note();			// current note switch
+    static void note(bool value);	// change the note switch
+
+    //
+    // Warning messages
+    //     - warnings are system-recoverable errors
+    //     - the system has noticed something and taken some
+    //       corrective action
+    //     - these messages can be shut off
+    //
+    static void warning(const char *message);
+    static void warning(tostrstream& message);
+
+    static void warning(const char *function, const char *message);
+    static void warning(const char *function, tostrstream& message);
+
+    static void warning(const char *class_name, const char *method, const char *message);
+    static void warning(const char *class_name, const char *method, tostrstream& message);
+
+    static bool warning();		// current warning switch
+    static void warning(bool value);	// change the warning switch
+
+    //
+    // Error messages
+    //     - an unacceptable, but expected and recoverable
+    //       condition was detected
+    //     - errors are for ``the expected environment was not found''
+    //       rather than for ``file couldn't be opened''
+    //     - these messages cannot be shut off
+    //     - the error handler determines the recovery action
+    //       TODO - one day exceptions will be used here
+    //
+    static void error(const char *message);
+    static void error(tostrstream& message);
+
+    static void error(const char *function, const char *message);
+    static void error(const char *function, tostrstream& message);
+
+    static void error(const char *class_name, const char *method, const char *message);
+    static void error(const char *class_name, const char *method, tostrstream& message);
+
+    // can't turn off errors - no ``static void error(bool value);''
+    static zero_arg_error_handler_t error();		// current error handler
+    static void error(zero_arg_error_handler_t handler);// change the error handler
+
+    static void error_is_lib_error_handler();		// change the error handler
+    static void error_is_exit();			// change the error handler
+
+    // Describes the fatal handler - WATCHOUT - implicitly uses AllocRing
+    static const char *error_handler_description();
+
+    //
+    // Fatal messages
+    //     - an unacceptable and unexpected error was detected
+    //       the data invariants were violated, there is no recovery
+    //     - these messages cannot be shut off
+    //     - the error handler determines the recovery action
+    //       TODO - one day exceptions will be used here
+    //
+    static void fatal(const char *message);
+    static void fatal(tostrstream& message);
+
+    static void fatal(const char *function, const char *message);
+    static void fatal(const char *function, tostrstream& message);
+
+    static void fatal(const char *class_name, const char *method, const char *message);
+    static void fatal(const char *class_name, const char *method, tostrstream& message);
+
+    // can't turn off fatals - no ``static void fatal(bool value);''
+    static zero_arg_error_handler_t fatal();			// return the fatal handler
+    static void fatal(zero_arg_error_handler_t handler);	// change the fatal handler
+
+    static void fatal_is_exit();	// change the fatal handler
+    static void fatal_is_abort();	// change the fatal handler
+
+    // Describes the fatal handler - WATCHOUT - implicitly uses AllocRing
+    static const char *fatal_handler_description();
+private:
+    //
+    // Two underscores are used here in order to prevent confusion of these
+    // private variables with any of the heir's private variables.  Note that
+    // access control is different than visibility in C++, so all the variable
+    // names in a class hierarchy must be unique.
+    //
+    static bool __debug;
+    static bool __note;
+    static bool __warning;
+    static void (*__error_handler)();	// can't turn off errors
+    static void (*__fatal_handler)();	// can't turn off fatals
+
+    static bool __partial_init;
+    static void __partial_initialize();
+    static bool __full_init;
+    static void __full_initialize(const char *program);
+    static char *__program;
+
+    static void __handle_error();
+    static void __handle_fatal();
+    static void __add_newline(const char *message);
+    static void __message_switch(bool value, bool& flag, const char *description);
+    static void __message_switch(bool value, bool& flag);
+    static const char *__describe_handler(zero_arg_error_handler_t handler);
+
+    static bool __output_valid();
+    static ostream *__output;
+
+    // GPP_1_96_BUG
+    const char *class_name() const;
+    // GPP_1_96_BUG
+};
+
+
+//# 29 "../../../../../../mips/include/Gct/Object/GctObject.h" 2
+
+
+//
+// GctObject class (is abstract)
+//
+class GctObject: virtual public GctErrorHandler /*, virtual public GttObject*/ {
+protected:
+    GctObject();
+    GctObject(const GctObject&);
+    virtual ~GctObject();	// ensure descendants have virtual destructors
+
+public:
+    //
+    // I/O Support
+    //
+    // The value typically persists only long enough for an i/o operation
+    // to be performed (see the defintion of output via operator<<(... ) below)
+    virtual const char *stringify();
+protected:
+    // This is the buffer into which the printed representation of this
+    // object will be put when the time comes.  It is associated with the
+    // object so it will never go away (so long as the object exists).
+    // Use a pointer so that you only pay for the space when I/O is used
+    tostrstream *stringbuf;
+    void clear_stringbuf();
+
+public:
+    //
+    // Consistency (global consistency)
+    //
+    // The global data invariant for the whole object (heirs included).
+    // This OK function will call the local invariant function ok() if
+    // necessary and in addition the OK functions of the heirs
+    // This is expected to compute the data invariant of the object.
+    // It will execute GctErrorHandler::fatal if there is wrong.
+    virtual void OK() const;
+
+protected:
+    //
+    // consistency (local consistency)
+    //
+    // This function computes the invariant which is local to this object.
+    // It does not call any of the ancestor's OK() or ok() functions.
+    // It is not a virtual function so that it can be called from within a
+    // constructor with impunity.  Thus this function MUST NOT call any
+    // virtual functions either; it should call them by their full name if
+    // that is necessary.  The global OK() function will call this function
+    // as necessary.
+    //
+    // This function must NOT NEVER EVER be made virtual.
+    void ok() const;
+protected:
+    //
+    // Class Name
+    //
+    // This must return a static (constant) string which is the name
+    // of the class being declared.  By convention, not all classes
+    // must have one of these, but the major root abstract class must
+    // have one in order to allow the stringify() to work approximately
+    // correctly.
+    virtual const char *class_name() const = 0;
+
+public:
+    //
+    // The ``id'' of this object
+    //
+    // NOTE - we explicitly allow the situation where this function
+    // can return the address of the object - the ``this'' pointer
+    // instead of a computed id field (the __object_id field below).
+    //
+    // This function is protected because we don't want too much dependence
+    // on this notion of object identity.  I want to be able to rip it
+    // out if it becomes to cumbersome.
+    unsigned objectId() const;
+private:
+    //
+    // Symbolic ID
+    //
+    // NOTE - Normally this would be implemented by the `this' pointer.
+    // TODO - remove this for production code
+    //
+    // However, in order to make the test suites run on all machines, we
+    // make this into a symbolic id that is maintained with each object.
+    // Thus the valid outputs are always consistent across all machines.
+    unsigned __object_id;
+    static unsigned __next_id;
+};
+
+//# 1 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h" 1
+//    This is part of the iostream library, providing -*- C++ -*- input/output.
+//    Copyright (C) 1991 Per Bothner.
+//
+//    This library is free software; you can redistribute it and/or
+//    modify it under the terms of the GNU Library General Public
+//    License as published by the Free Software Foundation; either
+//    version 2 of the License, or (at your option) any later version.
+//
+//    This library is distributed in the hope that it will be useful,
+//    but WITHOUT ANY WARRANTY; without even the implied warranty of
+//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//    Library General Public License for more details.
+//
+//    You should have received a copy of the GNU Library General Public
+//    License along with this library; if not, write to the Free
+//    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+//# 210 "/projects/gnu-cygnus/gnu-cygnus-8/common/g++-include/iostream.h"
+
+//# 117 "../../../../../../mips/include/Gct/Object/GctObject.h" 2
+
+extern ostream& operator<<(ostream&, GctObject&);
+
+
+//# 25 "../../../../../../mips/include/Gct/Object/GctHashObject.h" 2
+
+
+//
+// GctHashObject class (is abstract)
+//
+class GctHashObject: virtual public GctObject {
+protected:
+    GctHashObject();
+    GctHashObject(const GctHashObject&);
+
+public:
+    //
+    // hash support
+    //
+    virtual unsigned hash() const;
+};
+
+
+//# 28 "../../GctSymbol.h" 2
+
+
+//
+// GctSymbol
+//
+class GctSymbol: virtual public GctHashObject, String {
+public:
+    GctSymbol();		// vacuous symbol required for genclass usage
+    GctSymbol(const char*);
+    GctSymbol(const String&);
+    GctSymbol(const GctSymbol&);
+
+    operator const char *() const;
+
+    bool operator==(const GctSymbol&) const;
+    bool operator!=(const GctSymbol&) const;
+
+    bool operator<=(const GctSymbol&) const;
+    bool operator<(const GctSymbol&) const;
+    bool operator>=(const GctSymbol&) const;
+    bool operator>(const GctSymbol&) const;
+
+    unsigned hash() const;
+
+    // I/O Support
+    const char *stringify();
+
+    // Consistency
+    void OK() const;
+private:
+    const char *class_name() const;
+};
+
+extern unsigned hash(GctSymbol&);	// genclass support (no const)
+
+//
+// Inline functions
+//
+// Note - none of the String operators save for operator const char *()
+// are String member functions, instead, they are anonymous functions
+// which work by overloading.
+//
+
+
+
+
+
+GctSymbol::operator const char *() const
+{
+
+
+
+
+
+    return String::operator const char *();
+}
+
+bool
+GctSymbol::operator==(const GctSymbol& other) const
+{
+
+
+
+
+
+    return (bool)::operator==(*this, other);
+}
+
+bool
+GctSymbol::operator!=(const GctSymbol& other) const
+{
+
+
+
+
+
+    return (bool)::operator!=(*this, other);
+}
+
+bool
+GctSymbol::operator<=(const GctSymbol& other) const
+{
+
+
+
+
+
+    return (bool)::operator<=(*this, other);
+}
+
+bool
+GctSymbol::operator<(const GctSymbol& other) const
+{
+
+
+
+
+
+    return (bool)::operator<(*this, other);
+}
+
+bool
+GctSymbol::operator>=(const GctSymbol& other) const
+{
+
+
+
+
+
+    return (bool)::operator>=(*this, other);
+}
+
+bool
+GctSymbol::operator>(const GctSymbol& other) const
+{
+
+
+
+
+
+    return (bool)::operator>(*this, other);
+}
+
+
+//# 25 "GctSymbol.defs.h" 2
+
+
+// equality operator
+
+
+
+
+// less-than-or-equal
+
+
+
+
+// comparison : less-than ->  0
+
+
+
+
+// hash function
+
+extern unsigned int hash(GctSymbol&);
+
+
+
+// initial capacity for structures requiring one
+
+
+
+
+
+
+
+//# 27 "GctSymbol.GctSymbol.Map.h" 2
+
+
+class GctSymbolGctSymbolMap
+{
+protected:
+  int                   count;
+  GctSymbol                   def;
+
+public:
+                        GctSymbolGctSymbolMap(GctSymbol& dflt);
+  virtual              ~GctSymbolGctSymbolMap();
+
+  int                   length();                // current number of items
+  int                   empty();
+
+  virtual int           contains(GctSymbol& key);      // is key mapped?
+
+  virtual void          clear();                 // delete all items
+
+  virtual GctSymbol&          operator [] (GctSymbol& key) = 0; // access contents by key
+
+  virtual void          del(GctSymbol& key) = 0;       // delete entry
+
+  virtual Pix           first() = 0;             // Pix of first item or 0
+  virtual void          next(Pix& i) = 0;        // advance to next or 0
+  virtual GctSymbol&          key(Pix i) = 0;          // access key at i
+  virtual GctSymbol&          contents(Pix i) = 0;     // access contents at i
+
+  virtual int           owns(Pix i);             // is i a valid Pix  ?
+  virtual Pix           seek(GctSymbol& key);          // Pix of key
+
+  GctSymbol&                  dflt();                  // access default val
+
+  void                  error(const char* msg);
+  virtual int           OK() = 0;                // rep invariant
+};
+
+
+
+inline GctSymbolGctSymbolMap::~GctSymbolGctSymbolMap() {}
+
+inline int GctSymbolGctSymbolMap::length()
+{
+  return count;
+}
+
+inline int GctSymbolGctSymbolMap::empty()
+{
+  return count == 0;
+}
+
+inline GctSymbol& GctSymbolGctSymbolMap::dflt()
+{
+  return def;
+}
+
+inline GctSymbolGctSymbolMap::GctSymbolGctSymbolMap(GctSymbol& dflt) :def(dflt)
+{
+  count = 0;
+}
+
+
+
+
+//# 26 "GctSymbol.GctSymbol.CHMap.h" 2
+
+
+
+
+
+struct GctSymbolGctSymbolCHNode
+{
+  GctSymbolGctSymbolCHNode*      tl;
+  GctSymbol                hd;
+  GctSymbol                cont;
+                     GctSymbolGctSymbolCHNode();
+                     GctSymbolGctSymbolCHNode(GctSymbol& h, GctSymbol& c, GctSymbolGctSymbolCHNode* t = 0);
+                     ~GctSymbolGctSymbolCHNode();
+};
+
+
+
+inline GctSymbolGctSymbolCHNode::GctSymbolGctSymbolCHNode() {}
+
+inline GctSymbolGctSymbolCHNode::GctSymbolGctSymbolCHNode(GctSymbol& h, GctSymbol& c, GctSymbolGctSymbolCHNode* t)
+     : hd(h), cont(c), tl(t) {}
+
+inline GctSymbolGctSymbolCHNode::~GctSymbolGctSymbolCHNode() {}
+
+
+
+
+typedef GctSymbolGctSymbolCHNode* GctSymbolGctSymbolCHNodePtr;
+
+
+
+
+class GctSymbolGctSymbolCHMap : public GctSymbolGctSymbolMap
+{
+protected:
+  GctSymbolGctSymbolCHNode** tab;
+  unsigned int   size;
+
+public:
+                GctSymbolGctSymbolCHMap(GctSymbol& dflt,unsigned int sz=100 );
+                GctSymbolGctSymbolCHMap(GctSymbolGctSymbolCHMap& a);
+                ~GctSymbolGctSymbolCHMap();
+
+  GctSymbol&          operator [] (GctSymbol& key);
+
+  void          del(GctSymbol& key);
+
+  Pix           first();
+  void          next(Pix& i);
+  GctSymbol&          key(Pix i);
+  GctSymbol&          contents(Pix i);
+
+  Pix           seek(GctSymbol& key);
+  int           contains(GctSymbol& key);
+
+  void          clear();
+  int           OK();
+};
+
+
+
+inline GctSymbolGctSymbolCHMap::~GctSymbolGctSymbolCHMap()
+{
+  clear();
+  delete tab;
+}
+
+inline int GctSymbolGctSymbolCHMap::contains(GctSymbol& key)
+{
+  return seek(key) != 0;
+}
+
+inline GctSymbol& GctSymbolGctSymbolCHMap::key(Pix p)
+{
+  if (p == 0) error("null Pix");
+  return ((GctSymbolGctSymbolCHNode*)p)->hd;
+}
+
+inline GctSymbol& GctSymbolGctSymbolCHMap::contents(Pix p)
+{
+  if (p == 0) error("null Pix");
+  return ((GctSymbolGctSymbolCHNode*)p)->cont;
+}
+
+
+
+
+//# 22 "GctSymbol.GctSymbol.CHMap.cc" 2
+
+
+// The nodes are linked together serially via a version
+// of a trick used in some vtables: odd pointers are
+// actually links to the next table entry.
+// Not terrible, but not wonderful either
+
+static inline int goodCHptr(GctSymbolGctSymbolCHNode* t)
+{
+  return ((((unsigned)t) & 1) == 0);
+}
+
+static inline GctSymbolGctSymbolCHNode* index_to_CHptr(int i)
+{
+  return (GctSymbolGctSymbolCHNode*)((i << 1) + 1);
+}
+
+static inline int CHptr_to_index(GctSymbolGctSymbolCHNode* t)
+{
+  return ( ((unsigned) t) >> 1);
+}
+
+GctSymbolGctSymbolCHMap::GctSymbolGctSymbolCHMap(GctSymbol& dflt, unsigned int sz)
+     :GctSymbolGctSymbolMap(dflt)
+{
+  tab = (GctSymbolGctSymbolCHNode**)(new GctSymbolGctSymbolCHNodePtr[size = sz]);
+  for (unsigned int i = 0; i < size; ++i) tab[i] = index_to_CHptr(i+1);
+  count = 0;
+}
+
+GctSymbolGctSymbolCHMap::GctSymbolGctSymbolCHMap(GctSymbolGctSymbolCHMap& a) :GctSymbolGctSymbolMap(a.def)
+{
+  tab = (GctSymbolGctSymbolCHNode**)(new GctSymbolGctSymbolCHNodePtr[size = a.size]);
+  for (unsigned int i = 0; i < size; ++i) tab[i] = index_to_CHptr(i+1);
+  count = 0;
+  for (Pix p = a.first(); p; a.next(p)) (*this)[a.key(p)] = a.contents(p); // gets bogus error - type `GctSymbol' is derived from private `String'
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p786.C b/gcc/testsuite/g++.old-deja/g++.mike/p786.C
new file mode 100644
index 00000000000..c55d0c07f88
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p786.C
@@ -0,0 +1,35 @@
+// prms-id: 786
+
+extern "C" void printf (char *, ...);
+extern "C" void exit(int);
+class C
+   {
+   int a;
+public:
+   C() {a = 1;}
+   };
+
+void func(const C& a, C& b)
+{
+   printf ("in const func\n");
+   exit(1);
+}
+
+void func(C& a, C& b)
+{
+   printf ("in non-const func\n");
+}
+
+void testit(const C& a, C& b)
+{
+   func(a,b);
+}
+
+int main()
+{
+   C a;
+   C b;
+
+   func(a,b);
+   return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p7865.C b/gcc/testsuite/g++.old-deja/g++.mike/p7865.C
new file mode 100644
index 00000000000..2cac1d57a8c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p7865.C
@@ -0,0 +1,28 @@
+// prms-id: 7865
+
+int count;
+
+struct A {
+  A() { ++count; }
+  ~A() { --count; }
+};
+
+int foo() { return 1; }
+
+int bar()
+{
+  A a;
+  for (;;) {
+    A b;
+    if (foo())
+      return 0;
+    if (foo())
+      return 0;
+  }
+  return 0;
+}
+
+int main() {
+  bar();
+  return count;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p7868.C b/gcc/testsuite/g++.old-deja/g++.mike/p7868.C
new file mode 100644
index 00000000000..d79e2aa3de2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p7868.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// prms-id: 7868
+
+struct DIAGTYP {
+};
+struct DIAGTYP1 {
+  struct DIAGTYP;       // ERROR - forward declaration
+  void bar() { new struct DIAGTYP; }	// ERROR - undefined
+  void foo() { new struct DIAGTYP1; }
+};
+
+int main () {
+  struct DIAGTYP;               // ERROR - forward declaration
+  struct DIAGTYP  *lerror_desc;
+  lerror_desc= new struct DIAGTYP;	// ERROR - undefined
+}
+
+void foo () {
+  struct DIAGTYP  *lerror_desc;
+  lerror_desc= new struct DIAGTYP;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p789.C b/gcc/testsuite/g++.old-deja/g++.mike/p789.C
new file mode 100644
index 00000000000..9cad4fd805f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p789.C
@@ -0,0 +1,28 @@
+// prms-id: 789
+
+extern "C" void printf (char *, ...);
+struct foo
+{
+  static int count;
+  virtual void print (int i, int j) { printf ("foo[%d][%d] = %d\n", i, j, x); }
+  int x;
+  foo () { x = count++; }
+};
+int foo::count;
+struct bar : virtual public foo
+{
+  virtual void print (int i, int j) { printf ("bar[%d][%d] = %d\n", i, j, x); }
+};
+
+// bar array[3][3];
+foo array[3][3];
+
+int main ()
+{
+  for (int i = 0; i < 3; i++)
+    for (int j = 0; j < 3; j++) {
+//      printf("&a[%d][%d] = %x\n", i, j, (void *)&array[i][j]);
+      array[i][j].print (i, j);
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p789a.C b/gcc/testsuite/g++.old-deja/g++.mike/p789a.C
new file mode 100644
index 00000000000..b0df9f646de
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p789a.C
@@ -0,0 +1,43 @@
+// global and local multidimensional array objects are not getting
+// constructors called on any dimension, other than the first.  Also,
+// the destructors are not being called.  Seems odd, they probably
+// used to work. :-(
+// prms-id: 789
+
+extern "C" void printf (char *, ...);
+struct foo
+{
+  static int count;
+  void print (int i, int j) { printf ("foo[%d][%d] = %d\n", i, j, x); }
+  int x;
+  foo () {
+    x = count++;
+    printf("this %d = %x\n", x, (void *)this);
+  }
+  virtual ~foo () {
+    printf("this %d = %x\n", x, (void *)this);
+    --count;
+  }
+};
+int foo::count;
+
+
+int main ()
+{
+  {
+    foo array[3][3];
+    for (int i = 0; i < 3; i++)
+      {
+	for (int j = 0; j < 3; j++)
+	  {
+	    printf("&a[%d][%d] = %x\n", i, j, (void *)&array[i][j]);
+	  }
+      }
+      // The count should be nine, if not, fail the test.
+      if (foo::count != 9)
+	return 1;
+  }
+  if (foo::count != 0)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p7912.C b/gcc/testsuite/g++.old-deja/g++.mike/p7912.C
new file mode 100644
index 00000000000..40f45c48c12
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p7912.C
@@ -0,0 +1,23 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+// prms-id: 7912
+
+int count = 0;
+
+class Foo {
+public:
+  Foo() { ++count; };
+  Foo(const Foo&) { ++count; };
+  ~Foo() { --count; };
+};
+
+
+main()
+{
+  try {
+    throw Foo();
+  }
+  catch (Foo object) {
+  }
+  return count;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8009.C b/gcc/testsuite/g++.old-deja/g++.mike/p8009.C
new file mode 100644
index 00000000000..e8a124b40cf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8009.C
@@ -0,0 +1,12 @@
+// prms-id: 8009
+
+class A {
+public:
+  int i;
+};
+
+class B : public A {
+  B();
+};
+
+B::B() : i (-1) {}		// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8018.C b/gcc/testsuite/g++.old-deja/g++.mike/p8018.C
new file mode 100644
index 00000000000..37035bcd591
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8018.C
@@ -0,0 +1,85 @@
+// prms-id: 8018
+
+class RefCount {
+private:
+  int nref;
+
+public:
+  RefCount() : nref(0) {}
+  ~RefCount() {}
+
+  int nrefs() const { return nref; }
+  int reference() {
+    nref++;
+    return nref;
+  }
+  int unreference() {
+    nref--;
+    return nref;
+  }
+};
+
+class A : public RefCount {
+public:
+  A() {}
+  ~A() {}
+};
+
+class RefA {
+private:
+  A *p;
+
+  void clear() {
+    if (p) {
+      p->unreference();
+      if (!p->nrefs())
+	delete p;
+    }
+  }
+
+public:
+  RefA(A* a) : p(a) { if (p) p->reference(); }
+  RefA(const RefA& a) : p(a.p) { if (p) p->reference(); }
+  ~RefA() { clear(); }
+
+  A* operator->() { return p; }
+
+  RefA& operator=(const RefA& a) {
+    clear();
+    p=a.p;
+    if (p)
+      p->reference();
+    return *this;
+  }
+
+  RefA& operator=(A* a) {
+    clear();
+    p=a;
+    if (p)
+      p->reference();
+    return *this;
+  }
+};
+
+class AccRefA {
+private:
+  RefA a;
+
+public:
+  AccRefA(A* ap) : a(ap) {}
+  AccRefA(const RefA& ar) : a(ar) {}
+  ~AccRefA() {}
+
+  operator RefA&() { return a; }
+  RefA& result() { return a; }
+};
+
+int
+main() {
+  RefA a1 = new A;
+  AccRefA aa1(a1);
+  RefA a3 = aa1;
+
+  if (a1->nrefs() != 3)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8039.C b/gcc/testsuite/g++.old-deja/g++.mike/p8039.C
new file mode 100644
index 00000000000..fe58d09a6dc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8039.C
@@ -0,0 +1,14 @@
+// prms-id: 8039
+
+class C {
+public:
+  int func ();
+};
+
+extern void bar(int*);
+
+int main()
+{
+  int (C::*mfp)() = &C::func;
+  bar((int*)mfp);		// ERROR - no clear semantics
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p807.C b/gcc/testsuite/g++.old-deja/g++.mike/p807.C
new file mode 100644
index 00000000000..00c49e72ece
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p807.C
@@ -0,0 +1,34 @@
+// prms-id: 807
+
+extern "C" int printf(const char*, ...);
+
+class B;
+
+class AX
+{
+ protected:
+   int x;
+
+ public:
+   operator B();
+};
+
+
+class B
+{
+ private:
+   int x;
+ public:
+   B(const AX&);
+};
+
+
+int foo(B& b);			// ERROR - referenced below
+
+
+int main()
+{
+   AX a;
+   foo(a);  // ERROR - Ambiguous B(a) or a.operator B()  //  See ARM 12.3.2
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p807a.C b/gcc/testsuite/g++.old-deja/g++.mike/p807a.C
new file mode 100644
index 00000000000..d7b797af8e0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p807a.C
@@ -0,0 +1,22 @@
+// Build don't link:
+// prms-id: 807
+
+// See ARM page 275 Section 12.3.2
+
+extern "C" void printf (char *, ...);
+extern "C" void exit(int);
+
+class B;
+
+class A {
+public:
+	A(B&);			// ERROR - fn ref in err msg
+};
+
+class B {
+public:
+	operator A();		// ERROR - fn ref in err msg
+};
+
+B b;
+A a = b;  // ERROR - should fail as it is ambigious.
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p811.C b/gcc/testsuite/g++.old-deja/g++.mike/p811.C
new file mode 100644
index 00000000000..07ab9408055
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p811.C
@@ -0,0 +1,549 @@
+// This test case caused the compiler to abort at one point in time.
+// Build don't link:
+// Special g++ Options:
+// prms-id: 811
+
+class ostream; class streambuf;
+
+typedef long streamoff, streampos;
+
+struct _ios_fields {  
+    streambuf *_strbuf;
+    ostream* _tie;
+    int _width;
+    unsigned long _flags;
+    char _fill;
+    unsigned char _state;
+    unsigned short _precision;
+};
+
+
+enum state_value { _good = 0, _eof = 1,  _fail = 2, _bad  = 4 };
+enum open_mode { input=1, output=2, append=8 };
+
+
+class ios : public _ios_fields {
+  public:
+    enum io_state { goodbit=0, eofbit=1, failbit=2, badbit=4 };
+    enum open_mode {
+	in=1,
+	out=2,
+	ate=4,
+	app=8,
+	trunc=16,
+	nocreate=32,
+	noreplace=64 };
+    enum seek_dir { beg, cur, end};
+    enum { skipws=01, left=02, right=04, internal=010,
+	   dec=020, oct=040, hex=0100,
+	   showbase=0200, showpoint=0400, uppercase=01000, showpos=02000,
+	   scientific=04000, fixed=0100000, unitbuf=020000, stdio=040000,
+	   dont_close=0x80000000  
+	   };
+
+    ostream* tie() const { return _tie; }
+    ostream* tie(ostream* val) { ostream* save=_tie; _tie=val; return save; }
+
+     
+    char fill() const { return _fill; }
+    char fill(char newf) { char oldf = _fill; _fill = newf; return oldf; }
+    unsigned long flags() const { return _flags; }
+    unsigned long flags(unsigned long new_val) {
+	unsigned long old_val = _flags; _flags = new_val; return old_val; }
+    unsigned short precision() const { return _precision; }
+    unsigned short precision(int newp) {
+	unsigned short oldp = _precision; _precision = (unsigned short)newp;
+	return oldp; }
+    unsigned long setf(unsigned long val) {
+	unsigned long oldbits = _flags;
+	_flags |= val; return oldbits; }
+    unsigned long setf(unsigned long val, unsigned long mask) {
+	unsigned long oldbits = _flags;
+	_flags = (_flags & ~mask) | (val & mask); return oldbits; }
+    unsigned long unsetf(unsigned long mask) {
+	unsigned long oldbits = _flags & mask;
+	_flags &= ~mask; return oldbits; }
+    int width() const { return _width; }
+    int width(long val) { long save = _width; _width = val; return save; }
+
+    static const unsigned long basefield;
+    static const unsigned long adjustfield;
+    static const unsigned long floatfield;
+
+    streambuf* rdbuf() const { return _strbuf; }
+    void clear(int state = 0) { _state = state; }
+    int good() const { return _state == 0; }
+    int eof() const { return _state & ios::eofbit; }
+    int fail() const { return _state & (ios::badbit|ios::failbit); }
+    int bad() const { return _state & ios::badbit; }
+    int rdstate() const { return _state; }
+    void set(int flag) { _state |= flag; }
+    operator void*() const { return fail() ? (void*)0 : (void*)this; }
+    int operator!() const { return fail(); }
+
+
+    void unset(state_value flag) { _state &= ~flag; }
+    void close();
+    int is_open();
+    int readable();
+    int writable();
+
+
+  protected:
+    ios(streambuf*sb) { _strbuf=sb; _state=0; _width=0; _fill=' ';
+			_flags=ios::skipws; _precision=6; }
+};
+
+
+
+
+typedef ios::seek_dir _seek_dir;
+
+
+ 
+ 
+ 
+ 
+ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//# 168 "/usr/latest/lib/g++-include/streambuf.h" 3
+
+
+struct __streambuf {
+     
+    int _flags;		 
+    char* _gptr;	 
+    char* _egptr;	 
+    char* _eback;	 
+    char* _pbase;	 
+    char* _pptr;	 
+    char* _epptr;	 
+    char* _base;	 
+    char* _ebuf;	 
+    struct streambuf *_chain;
+
+
+
+
+};
+
+struct streambuf : private __streambuf {
+    friend class ios;
+    friend class istream;
+    friend class ostream;
+  protected:
+    static streambuf* _list_all;  
+    streambuf*& xchain() { return _chain; }
+    void _un_link();
+    void _link_in();
+    char* gptr() const { return _gptr; }
+    char* pptr() const { return _pptr; }
+    char* egptr() const { return _egptr; }
+    char* epptr() const { return _epptr; }
+    char* pbase() const { return _pbase; }
+    char* eback() const { return _eback; }
+    char* ebuf() const { return _ebuf; }
+    char* base() const { return _base; }
+    void xput_char(char c) { *_pptr++ = c; }
+    int xflags() { return _flags; }
+    int xflags(int f) { int fl = _flags; _flags = f; return fl; }
+    void xsetflags(int f) { _flags |= f; }
+    void gbump(int n) { _gptr += n; }
+    void pbump(int n) { _pptr += n; }
+    void setb(char* b, char* eb, int a=0);
+    void setp(char* p, char* ep) { _pbase=_pptr=p; _epptr=ep; }
+    void setg(char* eb, char* g, char *eg) { _eback=eb; _gptr=g; _egptr=eg; }
+  public:
+    static int flush_all();
+    static void flush_all_linebuffered();  
+    virtual int underflow();  
+    virtual int overflow(int c = (-1) );  
+    virtual int doallocate();
+    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
+    virtual streampos seekpos(streampos pos, int mode = ios::in|ios::out);
+    int sputbackc(char c);
+    int sungetc();
+    streambuf();
+    virtual ~streambuf();
+    int unbuffered() { return _flags & 2  ? 1 : 0; }
+    int linebuffered() { return _flags & 0x4000  ? 1 : 0; }
+    void unbuffered(int i)
+	{ if (i) _flags |= 2 ; else _flags &= ~2 ; }
+    void linebuffered(int i)
+	{ if (i) _flags |= 0x4000 ; else _flags &= ~0x4000 ; }
+    int allocate() {
+	if (base() || unbuffered()) return 0;
+	else return doallocate(); }
+    virtual int sync();
+    virtual int pbackfail(int c);
+    virtual int ungetfail();
+    virtual streambuf* setbuf(char* p, int len);
+    int in_avail() { return _egptr - _gptr; }
+    int out_waiting() { return _pptr - _pbase; }
+    virtual int sputn(const char* s, int n);
+    virtual int sgetn(char* s, int n);
+    long sgetline(char* buf, int  n, char delim, int putback_delim);
+    int sbumpc() {
+	if (_gptr >= _egptr && underflow() == (-1) ) return (-1) ;
+	else return *(unsigned char*)_gptr++; }
+    int sgetc() {
+	if (_gptr >= _egptr && underflow() == (-1) ) return (-1) ;
+	else return *(unsigned char*)_gptr; }
+    int snextc() {
+	if (++_gptr >= _egptr && underflow() == (-1) ) return (-1) ;
+	else return *(unsigned char*)_gptr; }
+    int sputc(int c) {
+	if (_pptr >= _epptr) return overflow(c);
+	return *_pptr++ = c, (unsigned char)c; }
+    int vscan(char const *fmt0, char*  ap);
+    int vform(char const *fmt0, char*  ap);
+
+
+
+
+
+
+};
+
+struct __file_fields {
+    char _fake;
+    char _shortbuf[1];
+    short _fileno;
+    int _blksize;
+    char* _save_gptr;
+    char* _save_egptr;
+    long   _offset;
+};
+
+class filebuf : public streambuf {
+    struct __file_fields _fb;
+    void init();
+  public:
+    filebuf();
+    filebuf(int fd);
+    filebuf(int fd, char* p, int len);
+    ~filebuf();
+    filebuf* attach(int fd);
+    filebuf* open(const char *filename, const char *mode);
+    filebuf* open(const char *filename, int mode, int prot = 0664);
+    virtual int underflow();
+    virtual int overflow(int c = (-1) );
+    int is_open() { return _fb._fileno >= 0; }
+    int fd() { return is_open() ? _fb._fileno : (-1) ; }
+    filebuf* close();
+    virtual int doallocate();
+    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
+    int sputn(const char* s, int n);
+    int sgetn(char* s, int n);
+    virtual int sync();
+  protected:  
+    virtual int pbackfail(int c);
+    int is_reading() { return eback() != egptr(); }
+    char* cur_ptr() { return is_reading() ?  gptr() : pptr(); }
+     
+    char* file_ptr() { return _fb._save_gptr ? _fb._save_egptr : egptr(); }
+    int do_flush();
+     
+    virtual int sys_read(char* buf, int  size);
+    virtual long   sys_seek(long  , _seek_dir);
+    virtual long sys_write(const void*, long);
+    virtual int sys_stat(void*);  
+    virtual int sys_close();
+};
+
+
+inline int ios::readable() { return rdbuf()->_flags & 4 ; }
+inline int ios::writable() { return rdbuf()->_flags & 8 ; }
+inline int ios::is_open() {return rdbuf()->_flags & 4 +8 ;}
+
+
+
+
+//# 25 "/usr/latest/lib/g++-include/iostream.h" 2 3
+
+
+class istream; class ostream;
+typedef istream& (*__imanip)(istream&);
+typedef ostream& (*__omanip)(ostream&);
+
+extern istream& ws(istream& ins);
+extern ostream& flush(ostream& outs);
+extern ostream& endl(ostream& outs);
+extern ostream& ends(ostream& outs);
+
+class ostream : public ios
+{
+    void do_osfx();
+  public:
+    ostream();
+    ostream(streambuf* sb, ostream* tied=__null );
+    ~ostream();
+
+    int opfx() { if (!good()) return 0; if (_tie) _tie->flush(); return 1; }
+    void osfx() { if (flags() & (ios::unitbuf|ios::stdio))
+		      do_osfx(); }
+    streambuf* ostreambuf() const { return _strbuf; }
+    ostream& flush();
+    ostream& put(char c);
+    ostream& write(const char *s, int n);
+    ostream& write(const unsigned char *s, int n) { return write((char*)s, n);}
+    ostream& write(const void *s, int n) { return write((char*)s, n);}
+    ostream& seekp(streampos);
+    ostream& seekp(streamoff, _seek_dir);
+    streampos tellp();
+    ostream& form(const char *format ...);
+    ostream& vform(const char *format, char*  args);
+};
+
+extern ostream& operator<<(ostream&, char c);
+inline ostream& operator<<(ostream& os, unsigned char c)
+{ return os << (char)c; }
+ 
+extern ostream& operator<<(ostream&, const char *s);
+inline ostream& operator<<(ostream& os, const unsigned char *s)
+{ return os << (const char*)s; }
+ 
+ 
+extern ostream& operator<<(ostream&, void *p);
+extern ostream& operator<<(ostream&, int n);
+extern ostream& operator<<(ostream&, long n);
+extern ostream& operator<<(ostream&, unsigned int n);
+extern ostream& operator<<(ostream&, unsigned long n);
+inline ostream& operator<<(ostream& os, short n) {return os << (int)n;}
+inline ostream& operator<<(ostream& os, unsigned short n)
+{return os << (unsigned int)n;}
+extern ostream& operator<<(ostream&, float n);
+extern ostream& operator<<(ostream&, double n);
+inline ostream& operator<<(ostream& os, __omanip func) { return (*func)(os); }
+extern ostream& operator<<(ostream&, streambuf*);
+
+class istream : public ios
+{
+    int  _gcount;
+  public:
+    istream();
+    istream(streambuf* sb, ostream*tied=__null );
+    ~istream();
+    streambuf* istreambuf() const { return _strbuf; }
+    istream& get(char& c);
+    istream& get(unsigned char& c);
+    istream& read(char *ptr, int n);
+    istream& read(unsigned char *ptr, int n) { return read((char*)ptr, n); }
+    istream& read(void *ptr, int n) { return read((char*)ptr, n); }
+     
+    istream& getline(char* ptr, int len, char delim = '\n');
+    istream& get(char* ptr, int len, char delim = '\n');
+    istream& gets(char **s, char delim = '\n');
+    int ipfx(int need) {
+	if (!good()) { set(ios::failbit); return 0; }
+	if (_tie && (need == 0 || rdbuf()->in_avail() < need)) _tie->flush();
+	if (!need && (flags() & ios::skipws) && !ws(*this)) return 0;
+	return 1;
+    }
+    int ipfx0() {  
+	if (!good()) { set(ios::failbit); return 0; }
+	if (_tie) _tie->flush();
+	if ((flags() & ios::skipws) && !ws(*this)) return 0;
+	return 1;
+    }
+    int ipfx1() {  
+	if (!good()) { set(ios::failbit); return 0; }
+	if (_tie && rdbuf()->in_avail() == 0) _tie->flush();
+	return 1;
+    }
+    int get() { if (!ipfx1()) return (-1) ;
+		int ch = _strbuf->sbumpc();
+		if (ch == (-1) ) set(ios::eofbit);
+		return ch; }
+    int peek() { if (!ipfx1()) return (-1) ;
+		int ch = _strbuf->sgetc();
+		if (ch == (-1) ) set(ios::eofbit);
+		return ch; }
+    int  gcount() { return _gcount; }
+    istream& ignore(int n=1, int delim = (-1) );
+    istream& seekg(streampos);
+    istream& seekg(streamoff, _seek_dir);
+    streampos tellg();
+    istream& putback(char ch) {
+	if (good() && _strbuf->sputbackc(ch) == (-1) ) clear(ios::badbit);
+	return *this;}
+    istream& unget() {
+	if (good() && _strbuf->sungetc() == (-1) ) clear(ios::badbit);
+	return *this;}
+
+    istream& unget(char ch) { return putback(ch); }
+    int skip(int i);
+
+};
+
+extern istream& operator>>(istream&, char*);
+inline istream& operator>>(istream& is, unsigned char* p)
+{ return is >> (char*)p; }
+ 
+extern istream& operator>>(istream&, char& c);
+extern istream& operator>>(istream&, unsigned char& c);
+ 
+extern istream& operator>>(istream&, int&);
+extern istream& operator>>(istream&, long&);
+extern istream& operator>>(istream&, short&);
+extern istream& operator>>(istream&, unsigned int&);
+extern istream& operator>>(istream&, unsigned long&);
+extern istream& operator>>(istream&, unsigned short&);
+extern istream& operator>>(istream&, float&);
+extern istream& operator>>(istream&, double&);
+inline istream& operator>>(istream& is, __imanip func) { return (*func)(is); }
+
+inline ostream& ostream::put(char c) { _strbuf->sputc(c); return *this; }
+
+class iostream : public ios {
+    int  _gcount;
+  public:
+    iostream();
+    iostream(streambuf* sb, ostream*tied=__null );
+    operator istream&() { return *(istream*)this; }
+    operator ostream&() { return *(ostream*)this; }
+    ~iostream();
+     
+    istream& get(char& c) { return ((istream*)this)->get(c); }
+    istream& get(unsigned char& c) { return ((istream*)this)->get(c); }
+    istream& read(char *ptr, int n) { return ((istream*)this)->read(ptr, n); }
+    istream& read(unsigned char *ptr, int n)
+	{ return ((istream*)this)->read((char*)ptr, n); }
+    istream& read(void *ptr, int n)
+	{ return ((istream*)this)->read((char*)ptr, n); }
+    istream& getline(char* ptr, int len, char delim = '\n')
+	{ return ((istream*)this)->getline(ptr, len, delim); }
+    istream& get(char* ptr, int len, char delim = '\n')
+	{ return ((istream*)this)->get(ptr, len, delim); }
+    istream& gets(char **s, char delim = '\n')
+	{ return ((istream*)this)->gets(s, delim); }
+    istream& ignore(int n=1, int delim = (-1) )
+	{ return ((istream*)this)->ignore(n, delim); }
+    int ipfx(int need) { return ((istream*)this)->ipfx(need); }
+    int ipfx0()  { return ((istream*)this)->ipfx0(); }
+    int ipfx1()  { return ((istream*)this)->ipfx1(); }
+    int get() { return _strbuf->sbumpc(); }
+    int peek() { return ipfx1() ? _strbuf->sgetc() : (-1) ; }
+    int  gcount() { return _gcount; }
+    istream& putback(char ch) { return ((istream*)this)->putback(ch); }
+    istream& unget() { return ((istream*)this)->unget(); }
+    istream& seekg(streampos pos) { return ((istream*)this)->seekg(pos); }
+    istream& seekg(streamoff off, _seek_dir dir)
+	{ return ((istream*)this)->seekg(off, dir); }
+    streampos tellg() { return ((istream*)this)->tellg(); }
+
+    istream& unget(char ch) { return putback(ch); }
+
+
+     
+    int opfx() { return ((ostream*)this)->opfx(); }
+    void osfx() { ((ostream*)this)->osfx(); }
+    ostream& flush() { return ((ostream*)this)->flush(); }
+    ostream& put(char c) { return ((ostream*)this)->put(c); }
+    ostream& write(const char *s, int n)
+	{ return ((ostream*)this)->write(s, n); }
+    ostream& write(const unsigned char *s, int n)
+	{ return ((ostream*)this)->write((char*)s, n); }
+    ostream& write(const void *s, int n)
+	{ return ((ostream*)this)->write((char*)s, n); }
+    ostream& form(const char *format ...);
+    ostream& vform(const char *format, char*  args)
+	{ return ((ostream*)this)->vform(format, args); }
+    ostream& seekp(streampos pos) { return ((ostream*)this)->seekp(pos); }
+    ostream& seekp(streamoff off, _seek_dir dir)
+	{ return ((ostream*)this)->seekp(off, dir); }
+    streampos tellp() { return ((ostream*)this)->tellp(); }
+};
+
+extern istream cin;
+extern ostream cout, cerr, clog;  
+
+struct Iostream_init { } ;   
+
+inline ios& dec(ios& i)
+{ i.setf(ios::dec, ios::dec|ios::hex|ios::oct); return i; }
+inline ios& hex(ios& i)
+{ i.setf(ios::hex, ios::dec|ios::hex|ios::oct); return i; }
+inline ios& oct(ios& i)
+{ i.setf(ios::oct, ios::dec|ios::hex|ios::oct); return i; }
+
+
+//# 7 "/usr/latest/lib/g++-include/stream.h" 2 3
+
+
+extern char* form(const char*, ...);
+
+extern char* dec(long, int=0);
+extern char* dec(int, int=0);
+extern char* dec(unsigned long, int=0);
+extern char* dec(unsigned int, int=0);
+
+extern char* hex(long, int=0);
+extern char* hex(int, int=0);
+extern char* hex(unsigned long, int=0);
+extern char* hex(unsigned int, int=0);
+
+extern char* oct(long, int=0);
+extern char* oct(int, int=0);
+extern char* oct(unsigned long, int=0);
+extern char* oct(unsigned int, int=0);
+
+inline istream& WS(istream& str) { return ws(str); }
+
+
+//# 9 "test.C" 2
+
+
+class Y {
+public:
+    Y() {}
+    virtual const char *stringify() = 0;
+    virtual char *stringify2() const = 0; // ERROR - 
+};
+
+class X: public Y {
+public:
+    X(): Y() {}
+    char *stringify();		// ERROR - ok
+    const char *stringify2() const;  // ERROR - ok
+};
+
+char *
+X::stringify() const
+{ // ERROR - ok
+    return "stringify";
+}
+
+const char *
+X::stringify2()
+{ // ERROR - ok
+    return "stringify2";
+}
+
+main()
+{
+    X x;
+    Y& y = x;
+
+    cout << "x\n";
+    cout << x.stringify() << '\n';
+    cout << x.stringify2() << '\n';
+
+    cout << "y\n";
+    cout << y.stringify() << '\n';
+    cout << y.stringify2() << '\n';
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8154.C b/gcc/testsuite/g++.old-deja/g++.mike/p8154.C
new file mode 100644
index 00000000000..b68ea5dd194
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8154.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Special g++ Options:
+// prms-id: 8154
+
+class QvFieldData;
+class QvNode {
+    QvFieldData *fieldData;
+};
+class QvGroup : public QvNode {
+  static QvFieldData *fieldData;
+};
+class QvUnknownNode : public QvGroup
+{
+public:
+  QvUnknownNode :: QvUnknownNode ();
+private:
+  static QvFieldData *fieldData;
+  virtual QvFieldData *getFieldData() { return fieldData; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8155.C b/gcc/testsuite/g++.old-deja/g++.mike/p8155.C
new file mode 100644
index 00000000000..5be14913a6a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8155.C
@@ -0,0 +1,147 @@
+// prms-id: 8155
+
+int fail = 1;
+
+class CMainWindow;
+class CFrameWnd;
+class CWnd;
+class CCmdTarget;
+ 
+typedef void (CCmdTarget::*AFX_PMSG)( void);
+typedef void (CWnd::*AFX_PMSGW)( void);
+
+struct AFX_MSGMAP_ENTRY {
+  unsigned int  nMessage;    
+  AFX_PMSG pfn;
+};
+
+struct AFX_MSGMAP {
+  const AFX_MSGMAP* pBaseMap;
+  const AFX_MSGMAP_ENTRY* lpEntries;
+};
+
+class CCmdTarget {
+public:
+  CCmdTarget();
+private:
+  static AFX_MSGMAP_ENTRY _messageEntries[];
+protected:
+  static const AFX_MSGMAP messageMap;
+  virtual const AFX_MSGMAP* GetMessageMap() const; 
+};
+
+const   AFX_MSGMAP CCmdTarget::messageMap = {
+  0, &CCmdTarget::_messageEntries[0]
+};
+
+const AFX_MSGMAP* CCmdTarget::GetMessageMap() const {
+  return &CCmdTarget::messageMap;
+}
+
+AFX_MSGMAP_ENTRY CCmdTarget::_messageEntries[] =
+{
+  { 0, 0 }
+};
+
+CCmdTarget :: CCmdTarget() { }
+ 
+class CWnd : public CCmdTarget {
+public:
+  CWnd();
+
+protected:
+  void OnPaint();
+private:
+  static AFX_MSGMAP_ENTRY _messageEntries[];
+protected:
+  static   const AFX_MSGMAP messageMap;
+  virtual const AFX_MSGMAP* GetMessageMap() const; 
+};
+
+CWnd :: CWnd() {
+}
+
+void CWnd :: OnPaint() {
+}
+
+const AFX_MSGMAP*   CWnd ::GetMessageMap() const {
+  return &  CWnd ::messageMap;
+}
+const AFX_MSGMAP   CWnd ::messageMap = {
+  &  CCmdTarget ::messageMap, &  CWnd ::_messageEntries[0]
+  };
+AFX_MSGMAP_ENTRY   CWnd ::_messageEntries[] = { 
+  {0, (AFX_PMSG)0 } }; 
+
+class CFrameWnd : public CWnd {
+public:
+  CFrameWnd();
+protected:
+private:
+  static AFX_MSGMAP_ENTRY _messageEntries[];
+protected:
+  static   const AFX_MSGMAP messageMap;
+  virtual const AFX_MSGMAP* GetMessageMap() const; 
+};
+
+CFrameWnd :: CFrameWnd() { }
+
+const AFX_MSGMAP*   CFrameWnd ::GetMessageMap() const {
+  return &  CFrameWnd ::messageMap;
+}
+const AFX_MSGMAP   CFrameWnd ::messageMap = {
+  &  CWnd ::messageMap, &  CFrameWnd ::_messageEntries[0]
+  };
+AFX_MSGMAP_ENTRY   CFrameWnd ::_messageEntries[] = { 
+  {0, (AFX_PMSG)0 } }; 
+
+class CMainWindow : public CFrameWnd {
+public:
+  CMainWindow();
+  void OnPaint();
+  void callProc();
+private:
+  static AFX_MSGMAP_ENTRY _messageEntries[];
+protected:
+  static   const AFX_MSGMAP messageMap;
+  virtual const AFX_MSGMAP* GetMessageMap() const; 
+};
+
+CMainWindow :: CMainWindow()
+{
+}
+void CMainWindow :: OnPaint()
+{
+  fail = 0;
+}
+
+void CMainWindow :: callProc()
+{
+  const AFX_MSGMAP* pMessageMap;
+  const AFX_MSGMAP_ENTRY *lpEntry;
+
+  pMessageMap = GetMessageMap();
+  lpEntry = pMessageMap->lpEntries;
+
+  if( lpEntry->nMessage == 100) {
+    (this->*lpEntry->pfn)();
+  }
+}
+
+const AFX_MSGMAP*   CMainWindow ::GetMessageMap() const {
+  return &  CMainWindow ::messageMap;
+}
+const AFX_MSGMAP   CMainWindow ::messageMap = {
+  &  CFrameWnd ::messageMap, &  CMainWindow ::_messageEntries[0]
+  };
+AFX_MSGMAP_ENTRY   CMainWindow ::_messageEntries[] = { 
+  { 100, (AFX_PMSG)(AFX_PMSGW)(void (CWnd::*)(void))&CMainWindow::OnPaint },
+  {0, (AFX_PMSG)0 }
+}; 
+
+int main( int argc, char **argv) {
+  CMainWindow     myWindow;
+
+  myWindow.callProc();
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8175.C b/gcc/testsuite/g++.old-deja/g++.mike/p8175.C
new file mode 100644
index 00000000000..8ae40588ad8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8175.C
@@ -0,0 +1,14 @@
+// prms-id: 8175
+
+class AtoBoolC {
+public:
+  AtoBoolC(const AtoBoolC& aBool);
+private:
+  int myValue;
+};
+
+struct TestCase {
+  AtoBoolC is_call_on_unack;
+};
+
+static TestCase the_cases[] = { { 0 } };	// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8269.C b/gcc/testsuite/g++.old-deja/g++.mike/p8269.C
new file mode 100644
index 00000000000..f886fe78fca
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8269.C
@@ -0,0 +1,11 @@
+// Build don't link:
+// prms-id: 8269
+
+typedef char* const char_ptr;
+
+class Foo_Bar {
+public:
+  static char* const counter;
+};
+
+char_ptr Foo_Bar::counter = 0;
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8460.C b/gcc/testsuite/g++.old-deja/g++.mike/p8460.C
new file mode 100644
index 00000000000..d4b3e8fb14f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8460.C
@@ -0,0 +1,17 @@
+// Build don't link:
+// prms-id: 8460
+
+class A {
+public:
+  A();
+  A(int) { }
+  A(const A&) { }
+private:
+};
+
+int main()
+{
+  A a;
+  
+  a.A(1);	// ERROR - cannot find name this way
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8483.C b/gcc/testsuite/g++.old-deja/g++.mike/p8483.C
new file mode 100644
index 00000000000..8e6293f5b1f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8483.C
@@ -0,0 +1,35 @@
+// prms-id: 8483
+
+int count;
+
+class A {
+public:
+  A() { ++count; }
+  ~A() { }
+};
+
+class B {
+private:
+  A b[2];  
+};
+
+class C {
+public:
+private:
+  A c[2][2];
+};
+
+class D {
+public:
+private:
+  A d[2][2][2];
+};
+
+int main() {
+  { A a; }
+  { B b; }
+  { C c; }
+  { D d; }
+  if (count != 15)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8620.C b/gcc/testsuite/g++.old-deja/g++.mike/p8620.C
new file mode 100644
index 00000000000..dc6f017adff
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8620.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// prms-id: 8620
+
+struct S {
+  long l;
+};
+
+typedef unsigned long l;
+
+void f() {
+  S* p;
+  if (p->l < 0)
+    return;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8785.C b/gcc/testsuite/g++.old-deja/g++.mike/p8785.C
new file mode 100644
index 00000000000..e10f4cfd40e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8785.C
@@ -0,0 +1,25 @@
+// Build don't link:
+// prms-id: 8785
+
+class Outer {
+private:
+  int x; // ERROR - private
+public:
+  struct Inner {
+    int y;
+    void f( Outer * p, int i) {
+      p->x = i;			// ERROR - 
+    };
+    void f( Outer & p) {
+      p.x = y;			// ERROR - 
+    };
+  };
+};
+
+int main() {
+  Outer::Inner A;
+  Outer Thing;
+
+  A.f(Thing);
+  A.f(&Thing,2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8786.C b/gcc/testsuite/g++.old-deja/g++.mike/p8786.C
new file mode 100644
index 00000000000..b5443c0fa6b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8786.C
@@ -0,0 +1,24 @@
+// Build don't link:
+// Special g++ Options: -O
+// prms-id: 8786
+
+class B {
+public:
+  inline ~B();
+};
+
+class D : public B {
+public:
+  D(int);
+};
+
+int foo() {
+  D t(0);
+
+  bool h = 1;
+  if (h) {
+    D p(0);
+    return 0;
+  }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8804.C b/gcc/testsuite/g++.old-deja/g++.mike/p8804.C
new file mode 100644
index 00000000000..df787b8fee9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8804.C
@@ -0,0 +1,18 @@
+// prms-id: 8804
+
+extern "C" int printf (const char *, ...);
+
+struct Fails {
+  int i;
+  union {
+    union {
+      int c;
+    };
+  };
+};
+
+Fails d;
+
+int main() {
+  return &d.i == &d.c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p8825.C b/gcc/testsuite/g++.old-deja/g++.mike/p8825.C
new file mode 100644
index 00000000000..11de74e78d2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p8825.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// prms-id: 8825
+
+class A {
+  typedef A x;
+};
+
+class B {
+  typedef B x;
+};
+
+class C : public A, public B {
+  typedef C x;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p9068.C b/gcc/testsuite/g++.old-deja/g++.mike/p9068.C
new file mode 100644
index 00000000000..67e879fbd94
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p9068.C
@@ -0,0 +1,21 @@
+// prms-id: 9068
+
+struct ostream {
+  void operator<< (int);	// ERROR - fn ref in err msg
+};
+
+class C {
+public:
+  static int& i ();
+  static int& i (int signatureDummy);
+};
+
+void foo (ostream& lhs, const C& rhs)
+{
+  lhs << rhs.i;		// ERROR - no such i for any opr << ()
+}
+
+int& C::i () {
+  static int _i = 4711;
+  return _i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p9129.C b/gcc/testsuite/g++.old-deja/g++.mike/p9129.C
new file mode 100644
index 00000000000..d66dab52d09
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p9129.C
@@ -0,0 +1,12 @@
+// Build don't link:
+// Special g++ Options: -ansi -pedantic-errors
+// prms-id: 9129
+
+class Foo {
+public:
+  int DoSomething();
+};
+
+int (Foo::*pA)() = { &Foo::DoSomething };	
+int (Foo::*X[1])(int) = { { &Foo::DoSomething } };		    // ERROR - 
+int (Foo::*Y[])(int) = { { &Foo::DoSomething, &Foo::DoSomething, 0 } }; // ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p9206.C b/gcc/testsuite/g++.old-deja/g++.mike/p9206.C
new file mode 100644
index 00000000000..5c4b578b866
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p9206.C
@@ -0,0 +1,21 @@
+// prms-id: 9206
+
+class X {
+public:
+  void xtest() { }
+};
+
+class Y { };
+
+typedef void (X::*Xptr)();
+typedef void (Y::*Yptr)();
+
+int main() {
+  X xx;
+
+  Xptr xp = &X::xtest;
+  Yptr yp = reinterpret_cast<Yptr>(xp);
+  xp = reinterpret_cast<Xptr>(yp);
+
+  (xx.*xp)();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p9506.C b/gcc/testsuite/g++.old-deja/g++.mike/p9506.C
new file mode 100644
index 00000000000..7c6e47b8e47
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p9506.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// prms-id: 9506
+
+char * volatile p;
+void foo() {
+  --p = 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p9706.C b/gcc/testsuite/g++.old-deja/g++.mike/p9706.C
new file mode 100644
index 00000000000..c21f6c6585c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p9706.C
@@ -0,0 +1,33 @@
+// Special g++ Options: -fexceptions
+// excess errors test - XFAIL a29k-*-* sparc64-*-elf sh-*-* arm-*-pe**-*
+// prms-id: 9706
+
+#include <stdlib.h>
+
+int count, acount;
+
+void *operator new(size_t sz) { ++count; return malloc (sz); }
+void operator delete(void *p) throw() { --count; free (p); }
+
+class A {
+public:
+  A() { ++acount; }
+  A(const A&) { ++acount; }
+  ~A() { --acount; }
+};
+
+int main() {
+  int i;
+
+  for( i = 0; i < 10; i++ ) {
+    try {
+      throw A();
+    }
+    catch (A& a) {
+    }
+  }
+  if (acount)
+    return 1;
+  if (count)
+    return 2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p9732a.C b/gcc/testsuite/g++.old-deja/g++.mike/p9732a.C
new file mode 100644
index 00000000000..13c89892b84
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p9732a.C
@@ -0,0 +1,36 @@
+// prms-id: 9732
+
+class A {
+  int i;
+public:
+  A() { i = 1; }
+  ~A() { }
+};
+
+struct value {
+  A x,y,z;
+};
+
+int crash(const value* capt, value* jet) {
+  return capt == jet;
+}
+
+class euler {
+public:
+  value number() const { return _value; }
+  int distance();
+
+private:
+  value _value;
+};
+
+int euler::distance() {
+  const value& capt = number();
+  value jet;
+  return crash (&capt, &jet);
+}
+
+int main() {
+  euler e;
+  return e.distance();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p9732b.C b/gcc/testsuite/g++.old-deja/g++.mike/p9732b.C
new file mode 100644
index 00000000000..59cfe4c578d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p9732b.C
@@ -0,0 +1,44 @@
+// prms-id: 9732
+
+int count;
+int bail = 0;
+
+extern "C" void _exit (int);
+
+struct base {
+  base () { ++count; }
+  ~base () { --count; }
+  base(const base&o) { ++count; }
+};
+
+class D {
+public:
+  ~D() {
+    if (bail++)
+      {
+	// On some Linux boxes, we run the dtor for d twice,
+	// once before exit, and once after!
+	abort ();
+      }
+    else
+      {
+	if (count != 0)
+	  _exit (1);
+	_exit (0);
+      }
+  }
+} d;
+
+base base_object;
+
+base base_returning_function ();
+
+const base& base_ref = base_returning_function ();
+
+int main () {
+}
+
+base base_returning_function () {
+  base local_base_object;
+  return local_base_object;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p9732c.C b/gcc/testsuite/g++.old-deja/g++.mike/p9732c.C
new file mode 100644
index 00000000000..9ec773cc9af
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p9732c.C
@@ -0,0 +1,5 @@
+// Build don't link:
+// prms-id: 9732
+
+struct foo {};
+foo& x() { return foo(); }	// WARNING - 
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/p991.C b/gcc/testsuite/g++.old-deja/g++.mike/p991.C
new file mode 100644
index 00000000000..037227c4f3e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/p991.C
@@ -0,0 +1,22 @@
+// Build don't link:
+// prms-id: 991
+
+class Complex {
+public:
+	double re;
+	double im;
+	Complex(double r,double i) : re(r), im(i) {}
+};
+
+Complex cos(const Complex&);
+
+extern "C" double cos (double);		// not the same as the above
+extern "C" double cosh (double);
+extern "C" double sin (double);
+extern "C" double sinh (double);
+
+Complex cos(const Complex& arg) {
+	double nr = cos(arg.re)*cosh(arg.im);
+	double ni = -sin(arg.re)*sinh(arg.im);
+	return Complex(nr,ni);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/parse1.C b/gcc/testsuite/g++.old-deja/g++.mike/parse1.C
new file mode 100644
index 00000000000..12e26cf26ea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/parse1.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+enum { name1 };
+struct name0 { };
+struct name1 { };
+struct derived1 : public name1 { };
+struct derived2 : public name0, public name1 { };
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pmd1.C b/gcc/testsuite/g++.old-deja/g++.mike/pmd1.C
new file mode 100644
index 00000000000..260dc095eba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pmd1.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+class A;
+struct XX { int A::*py; };
+
+class A {
+public:
+  int p;
+  void setp(XX *xp);
+};
+
+void A::setp(XX *xp) { xp->py = &A::p; }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pmf1.C b/gcc/testsuite/g++.old-deja/g++.mike/pmf1.C
new file mode 100644
index 00000000000..a39512f42d4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pmf1.C
@@ -0,0 +1,90 @@
+// extern "C" printf(const char *, ...);
+
+class X
+{
+public:
+  int  a;
+  int f(int);
+};
+
+class Y
+{
+public:
+  int b;
+  int c;
+  int g(int);
+};
+
+class MD : public X, public Y
+{
+public:
+  int c;
+  int hf(int);
+};
+
+int MD::* pmi0 = &MD::a;
+int MD::* pmi1 = &MD::b;
+int MD::* pmi2 = &MD::c;
+
+int (MD::* pmf0)(int) = &MD::f;
+int (MD::* pmf1)(int) = &MD::g;
+int (MD::* pmf2)(int) = &MD::hf;
+
+int main()
+{
+  MD obj;
+  int fail = 0;
+
+  obj.a = 1;
+  obj.b = 2;
+  obj.c = 3;
+
+  obj.*pmi0 = 7;
+  obj.*pmi1 = 8;
+  obj.*pmi2 = 9;
+
+  fail += (obj.*pmf0)(7);
+  fail += (obj.*pmf1)(8);
+  fail += (obj.*pmf2)(9);
+
+#if 0
+  if (fail != 0)
+    printf ("failed %d tests\n", fail);
+  else
+    printf ("passed\n");
+
+  printf ("sizeof(X) = %d, sizeof(Y) = %d, sizeof(MD) = %d\n",
+	  sizeof(X), sizeof(Y), sizeof(MD));
+#endif
+  return fail;
+}
+
+int X::f(int v)
+{
+  if (v != a)
+  {
+//    printf ("failed in X::f, a = %d\n", a);
+    return 1;
+  }
+  return 0;
+}
+
+int Y::g(int v)
+{
+  if (v != b)
+  {
+//    printf ("failed in Y::g, b = %d\n", b);
+    return 1;
+  }
+  return 0;
+}
+
+int MD::hf(int v)
+{
+  if (v != c)
+  {
+//    printf ("failed in MD::hf, c = %d\n", c);
+    return 1;
+  }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pmf2.C b/gcc/testsuite/g++.old-deja/g++.mike/pmf2.C
new file mode 100644
index 00000000000..5a5aa0667b6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pmf2.C
@@ -0,0 +1,54 @@
+extern "C" int printf(const char *, ...);
+
+class A_table {
+  int c;
+public:
+  A_table() { c = 3;}
+  virtual void func2(int &item) { printf("func2(%d,) c=%d\n",item,c);}
+};
+
+class B_table : private A_table {
+  typedef void (B_table::* B_ti_fn) (int &item);
+public:
+  B_table() { j = 0x4321;}
+  virtual void call_fn_fn1(int &item, void *pfn1);
+  void func1(int &item) { printf("func1(%d)\n",item);}
+  virtual void func2(int &item) { printf("func2(%d) j=%d\n",item,j);}
+  int j;
+};
+
+class foo : public A_table {
+public:
+  int i;
+  virtual ~foo();
+  virtual void func2(int &item) { printf("func2(%d) i=%d\n",item,i);}
+};
+foo::~foo() { i = 0;}
+
+class bar :public foo,public B_table {
+public:
+  int w;
+  virtual ~bar();
+  virtual void func2(int &item) { printf("func2(%d) w=%d\n",item,w);}
+};
+bar::~bar() { w = 0;}
+
+void B_table::call_fn_fn1(int &item, void *pfn1) {
+  (this->*(*(B_ti_fn*)pfn1))(item);
+}
+
+B_table b;
+bar jar;
+
+int main() {
+  printf("ptr to B_table=%x, ptr to A_table=%x\n",&b,(A_table*)&b);
+  B_table::B_ti_fn z = &B_table::func1;
+  int j = 1;
+  jar.call_fn_fn1(j,(void *)&z);
+  j++;
+  z = &B_table::func2;
+  b.call_fn_fn1(j,(void *)&z);
+  j++;
+  jar.call_fn_fn1(j,(void *)&z);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pmf3.C b/gcc/testsuite/g++.old-deja/g++.mike/pmf3.C
new file mode 100644
index 00000000000..b38f0b7d16b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pmf3.C
@@ -0,0 +1,19 @@
+struct Fooey {
+  void f(char* pX);
+  void f(int in);
+  void f(float fx);
+  void h(double dx);
+};
+
+void Fooey::f(char*) { }	// ERROR - candidate
+void Fooey::f(int) { }		// ERROR - candidate
+void Fooey::f(float) { }	// ERROR - candidate
+void Fooey::h(double zahl) { }
+
+int main() {
+  Fooey Blah;
+  void (Fooey::*pointer)(double);
+  pointer = &Fooey::f;		// ERROR - don't call Fooey::h
+  (Blah.*pointer)(42.5);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pmf4.C b/gcc/testsuite/g++.old-deja/g++.mike/pmf4.C
new file mode 100644
index 00000000000..02e5b10c1ac
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pmf4.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+class NF { };
+
+struct QF {
+  NF nf;
+
+  typedef float(NF::* const NPF)() const;
+
+  void p (NPF npf) const {
+    float q = (nf.*npf)();
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pmf5.C b/gcc/testsuite/g++.old-deja/g++.mike/pmf5.C
new file mode 100644
index 00000000000..685801a8591
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pmf5.C
@@ -0,0 +1,31 @@
+// Special g++ Options: -w
+
+class A {
+  int j;
+};
+
+class Space {
+  int j;
+};
+
+typedef int (A::*pma)();
+
+class B : public Space, virtual public A {
+public:
+  int i;
+  int foo () {
+    return i!=42;
+  }
+  B() {
+    i = 42;
+  }
+};
+
+int call_base (A* ap, pma pmf) {
+  return (ap->*pmf)();
+}
+
+int main() {
+  B b;
+  return call_base ((A*)&b, (pma)&B::foo);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pmf6.C b/gcc/testsuite/g++.old-deja/g++.mike/pmf6.C
new file mode 100644
index 00000000000..6848781aca3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pmf6.C
@@ -0,0 +1,12 @@
+// Special g++ Options:
+
+class S {
+public:
+  void (S::*pmf)();
+  void foo() {
+    pmf();			// WARNING - 
+  }
+  static void foo1(S* sp) {
+    (sp->pmf)();		// ERROR - 
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pmf7.C b/gcc/testsuite/g++.old-deja/g++.mike/pmf7.C
new file mode 100644
index 00000000000..b238171ba5f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pmf7.C
@@ -0,0 +1,29 @@
+class A;
+typedef int (A::*f_ptr) (void);
+
+class B {
+public:
+  B() {}; ~B() {};
+  B& dummy(f_ptr cb) { return *this; };
+};
+
+template<class SP, class CB> SP& call_dummy(SP* sp, CB cb) {
+  sp->dummy(cb);
+  return *sp;
+};
+
+class A {
+public:
+  A() {}; ~A() {};
+  int ok() { return 0; };
+  A& call_it(B* s) {
+    call_dummy(s, &A::ok);
+    return *this;
+  };
+};
+
+int main() {
+  A a; B b;
+  a.call_it(&b);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pmf8.C b/gcc/testsuite/g++.old-deja/g++.mike/pmf8.C
new file mode 100644
index 00000000000..41a4c0194fb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pmf8.C
@@ -0,0 +1,31 @@
+int fail;
+
+class A *ptr_a;
+
+class A {
+public:
+  char space1[24];
+  virtual void foo() {
+    if (this != ptr_a)
+      fail = 1;
+  }
+};
+
+class Space {
+  char space2[36];
+};
+
+class B : public Space, public A {
+} b;
+
+void (B::*pmf1)() = &A::foo;
+void (A::*pmf2)() = &A::foo;
+
+int main() {
+  ptr_a = &b;
+  (b .* (void (B::*) ()) &A::foo) ();
+  (b .* pmf1) ();
+  (b .* pmf2) ();
+  (b .* &A::foo) ();
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pmf9.C b/gcc/testsuite/g++.old-deja/g++.mike/pmf9.C
new file mode 100644
index 00000000000..800618ff6c6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pmf9.C
@@ -0,0 +1,23 @@
+class K {
+public:
+  int f(int i) { return i; }
+};
+
+class Q {
+public:
+  Q() { kp = new K; }
+  int g();
+private:
+  K * kp;
+};
+
+int Q::g() {
+  return (kp->f)(42);
+};
+
+
+int main () {
+  Q q;
+  if (q.g() != 42)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pt1.C b/gcc/testsuite/g++.old-deja/g++.mike/pt1.C
new file mode 100644
index 00000000000..2ef8556b13d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pt1.C
@@ -0,0 +1,36 @@
+template <class T, class V>
+class A {
+public:
+  A (T at, V av);
+  void print () { }
+protected:
+  T t;
+  V v;
+};
+
+template <class T, class V>
+A<T, V>::A (T at, V av) {
+  t = at;
+  v = av;
+}
+
+
+template <class T, class V>
+class B: public virtual A<T, V> {
+public:
+  B (T at, V av);
+  void print () { }
+};
+
+template <class T, class V>
+B<T, V>::B (T at, V av) : A<T, V> (at, av) { }	// gets bogus error - 
+
+int main () {
+  int i = 2;
+  double x = 2;
+
+  B<int, double> ab(i, x);
+  ab.print();
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pt2.C b/gcc/testsuite/g++.old-deja/g++.mike/pt2.C
new file mode 100644
index 00000000000..7c96cabff4d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pt2.C
@@ -0,0 +1,22 @@
+class A {
+public:
+};
+
+template <class T>
+class B: public virtual A {
+public:
+  B ();
+  ~B ();
+};
+
+template <class T>
+B<T>::B () { }
+
+template <class T>
+B<T>::~B () { }
+
+int main () {
+  B<int> ab;
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pt3.C b/gcc/testsuite/g++.old-deja/g++.mike/pt3.C
new file mode 100644
index 00000000000..a61d9023f8c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pt3.C
@@ -0,0 +1,29 @@
+// Build don't link:
+
+template<class Repr>
+class syHandle
+{
+protected:
+  syHandle();
+  ~syHandle();
+  Repr *_repr;
+};
+
+template<class Repr>
+syHandle<Repr>::~syHandle()
+{
+}
+
+typedef char * char_ptr_t;
+
+template <>
+syHandle<char_ptr_t>::syHandle() 
+{
+    _repr = 0;
+}
+
+template <>
+syHandle<char_ptr_t>::~syHandle() 
+{
+    _repr = 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/pt4.C b/gcc/testsuite/g++.old-deja/g++.mike/pt4.C
new file mode 100644
index 00000000000..7c1563e93a7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/pt4.C
@@ -0,0 +1,4 @@
+// Build don't link:
+
+template <char* c> struct B { B() { } };
+B<0> bnull; // ERROR - could not convert template argument
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/ref1.C b/gcc/testsuite/g++.old-deja/g++.mike/ref1.C
new file mode 100644
index 00000000000..054c9850c67
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/ref1.C
@@ -0,0 +1,21 @@
+int count;
+
+struct base {
+  base () { ++count; }
+  ~base () { --count; }
+  base(const base&o) { ++count; }
+};
+
+base base_returning_function ();
+
+const base& base_ref = base_returning_function ();
+
+int main () {
+  if (count != 1)
+    return 1;
+}
+
+base base_returning_function () {
+  base local_base_object;
+  return local_base_object;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/rtti1.C b/gcc/testsuite/g++.old-deja/g++.mike/rtti1.C
new file mode 100644
index 00000000000..e44c5fafdc5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/rtti1.C
@@ -0,0 +1,4 @@
+// Build don't link:
+
+#include <typeinfo>
+#include <iostream.h>
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/rtti2.C b/gcc/testsuite/g++.old-deja/g++.mike/rtti2.C
new file mode 100644
index 00000000000..0c8b8b0c24c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/rtti2.C
@@ -0,0 +1,5 @@
+#include <typeinfo>
+
+int main() {
+  typeid(bool);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/rtti3.C b/gcc/testsuite/g++.old-deja/g++.mike/rtti3.C
new file mode 100644
index 00000000000..a250a26b0f4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/rtti3.C
@@ -0,0 +1,23 @@
+class base {
+public:
+  virtual ~base() {}
+  virtual void m1() = 0;
+  virtual void m2() = 0;
+};
+
+class intermediate : public virtual base {
+public:
+  virtual ~intermediate() {}
+  virtual void m1() {}
+  virtual void m2() {}
+};
+
+class derived : public intermediate {
+public:
+  virtual int IwantedThisMethod() { return 0; }
+  virtual int ButIgotThisOne() { return 1; }
+};
+
+int main() {
+  return derived().IwantedThisMethod();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/s9959.C b/gcc/testsuite/g++.old-deja/g++.mike/s9959.C
new file mode 100644
index 00000000000..654f7d57dd5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/s9959.C
@@ -0,0 +1,20 @@
+// Build don't link:
+
+class A {
+protected:
+  int aData;
+};
+ 
+class B : public A {
+public:
+  virtual void func1() { 
+    A::aData = 1;
+  }
+};
+
+class C : virtual public B {
+public:
+  virtual void func1(void) {
+    A::aData = 2;
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/scast1.C b/gcc/testsuite/g++.old-deja/g++.mike/scast1.C
new file mode 100644
index 00000000000..11666b45430
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/scast1.C
@@ -0,0 +1,7 @@
+class A {};
+class C {};
+
+int main() {
+  A* a = 0;
+  C* c = static_cast<C*>(a);	// ERROR - bad static cast 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/temp.C b/gcc/testsuite/g++.old-deja/g++.mike/temp.C
new file mode 100644
index 00000000000..5a1ce6754a9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/temp.C
@@ -0,0 +1,31 @@
+extern "C" int printf(const char *, ...);
+extern "C" const char *getenv(const char *);
+
+class T {
+  int i;
+public:
+  T() {
+    i = 1;
+    printf("T() at %x\n", this);
+  }
+  T(const T& o) {
+    i = o.i;
+    printf("T(const T&) at %x <-- %x\n", this, &o);
+  }
+  T operator +(const T& o) {
+    T r;
+    r.i = this->i + o.i;
+    return r;
+  }
+  operator int () {
+    return i;
+  }
+  ~T() { printf("~T() at %x\n", this); }
+} s, b;
+
+int foo() { return getenv("TEST") == 0; }
+
+int main() {
+  int i = foo() ? s+b : s;
+  return i != 2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/thunk1.C b/gcc/testsuite/g++.old-deja/g++.mike/thunk1.C
new file mode 100644
index 00000000000..9780c05bc97
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/thunk1.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Special g++ Options: -fvtable-thunks
+
+struct C1
+{
+    virtual ~C1();
+};
+
+struct C2 : public virtual C1
+{
+        virtual ~C2();
+};
+
+struct C3 : public virtual C2
+{
+    virtual ~C3();
+};
+
+C3::~C3() {}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/thunk2.C b/gcc/testsuite/g++.old-deja/g++.mike/thunk2.C
new file mode 100644
index 00000000000..9bc4558d9f7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/thunk2.C
@@ -0,0 +1,39 @@
+// Special g++ Options: -fvtable-thunks
+
+#include <typeinfo>
+
+int state;
+int fail;
+
+class A {
+public:
+  A() {
+    if (++state != 1)
+      fail = 1;
+  }
+  virtual int foo() {
+    if (++state != 2)
+      fail = 1;
+  }
+  virtual ~A() {
+    if (++state != 3)
+      fail = 1;
+  }
+};
+
+A* bar() {
+  return new A;
+}
+
+main() {
+  A *aptr = bar();
+  aptr->foo();
+  if (dynamic_cast <void*> (aptr) != aptr)
+    fail = 1;
+  if (typeid (*aptr) != typeid (A))
+    fail = 1;
+  delete aptr;
+  if (++state != 4)
+    fail = 1;
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/thunk3.C b/gcc/testsuite/g++.old-deja/g++.mike/thunk3.C
new file mode 100644
index 00000000000..9a52c9d6916
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/thunk3.C
@@ -0,0 +1,35 @@
+// Special g++ Options: -fvtable-thunks
+
+int state;
+int fail;
+
+class A {
+public:
+  A() {
+    if (++state != 1)
+      fail = 1;
+  }
+  virtual int foo() {
+    if (++state != 2)
+      fail = 1;
+  }
+  virtual ~A() {
+    if (++state != 3)
+      fail = 1;
+  }
+};
+
+A* bar() {
+  return new A;
+}
+
+main() {
+  A *aptr = bar();
+  aptr->foo();
+  if (dynamic_cast <void*> (aptr) != aptr)
+    fail = 1;
+  delete aptr;
+  if (++state != 4)
+    fail = 1;
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/unroll1.C b/gcc/testsuite/g++.old-deja/g++.mike/unroll1.C
new file mode 100644
index 00000000000..90f37f1ef92
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/unroll1.C
@@ -0,0 +1,11 @@
+// Build don't link:
+// Special g++ Options: -g -O -funroll-loops
+
+struct A {
+  inline ~A() { }
+};
+
+void foo (A) {
+  while (1)
+    A bar;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/virt1.C b/gcc/testsuite/g++.old-deja/g++.mike/virt1.C
new file mode 100644
index 00000000000..28483177bf9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/virt1.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+struct S0 { virtual void f1 () { } };
+
+struct S1 : virtual public S0 { virtual void f1 () { } };
+
+struct S2 : public S1 { virtual void f1 () { } };
+
+struct S3 : virtual public S0 { virtual void f1 () { } };
+
+struct S4 : public S3 { };
+
+void creator () { new S4; }
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/virt2.C b/gcc/testsuite/g++.old-deja/g++.mike/virt2.C
new file mode 100644
index 00000000000..612d07e49e3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/virt2.C
@@ -0,0 +1,25 @@
+struct S0 {
+  virtual int is_kind_of_S1 () const { return 0; }
+  virtual void dummy () { }
+};
+
+struct S1 : virtual public S0 {
+  virtual int is_kind_of_S1 () const { return 1; }
+  virtual void dummy () { }
+};
+
+struct S2 : virtual public S0 {
+  virtual void dummy () { }
+};
+
+struct S3 : public S2, public S1 {
+  virtual void dummy () { }
+};
+
+static struct S0 *var = new S3 ();
+
+int main () {
+  if (var->is_kind_of_S1() != 1)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/virt3.C b/gcc/testsuite/g++.old-deja/g++.mike/virt3.C
new file mode 100644
index 00000000000..de3ea3d07e2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/virt3.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+class B {
+public:
+  int Bi;
+  virtual int g() { };
+};
+
+class D : private B {
+  int Di;
+};
+
+class E : public virtual D, public B {
+  int Ei;
+};		// WARNING - direct base inaccessible due to ambiguity
+
+E e;
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/virt4.C b/gcc/testsuite/g++.old-deja/g++.mike/virt4.C
new file mode 100644
index 00000000000..9750af6b0b5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/virt4.C
@@ -0,0 +1,27 @@
+// Special g++ Options:
+
+void  Foo () {}
+
+class B {
+public:
+  virtual void foo() = 0;
+};
+
+class D: virtual public B {
+public:
+  void foo() { Foo(); }
+};
+
+class D1: public D {};
+
+class D2: public D {};
+
+class D1_2: public D1, public D2 {
+public:
+  void foo() { D1::foo(); D2::foo(); }
+};
+
+main() {
+  D1_2 h;
+  h.foo();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/virt5.C b/gcc/testsuite/g++.old-deja/g++.mike/virt5.C
new file mode 100644
index 00000000000..dac85cc2dba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/virt5.C
@@ -0,0 +1,53 @@
+// Ensure that virtual base upcast and downcasting works on this
+// conversions during virtual function dispatch at ctor/dtor time
+// when dynamic vtable fixups for deltas are needed.
+
+int fail = 0;
+
+struct BASE1 {
+  virtual ~BASE1 () { }      
+};   
+
+class MID;
+
+class BASE2 {
+public: 
+  virtual MID *VFN (){ return 0; }
+};   
+
+class MIBASE : public BASE1, public BASE2 { };   
+
+class VBB : public MIBASE {
+public:
+  virtual long get_STATE () const = 0;
+  void print_STATE() { if (get_STATE () != 87654321) fail = 1; }
+};   
+
+class VBD : public virtual VBB {
+  long STATE;
+public:
+  long get_STATE() const { return STATE; }
+  VBD() { STATE = 87654321; }
+  ~VBD() { STATE = 87654321; }
+};   
+
+class MID : public virtual VBD {
+public:
+  MID () { print_STATE(); }
+  ~MID () { print_STATE(); }
+  virtual MID *VFN() { return this; }
+};  
+
+class LAST : public MID {
+public:
+  LAST () { print_STATE(); }
+  ~LAST () { print_STATE(); }
+};
+
+int main() {
+  MIBASE *o = new LAST;
+  MID *p = o->VFN();
+  p->print_STATE();
+  delete o;
+  return fail;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/virt6.C b/gcc/testsuite/g++.old-deja/g++.mike/virt6.C
new file mode 100644
index 00000000000..61491cede48
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/virt6.C
@@ -0,0 +1,39 @@
+// This testcase ensures that we can build vtable names for complex MI
+// classes.
+
+class C_A {
+public:
+  virtual int foo(void *) { }
+} a;
+ 
+class C_B : public C_A {
+} b;
+ 
+class C_C : public C_A {
+} c;
+ 
+class C_D : public C_A {
+} d;
+ 
+class C_E : public C_C, public C_B {
+public:
+  virtual int foo(void *) { }
+} e;
+ 
+class C_F : public C_D, public C_B {
+public:
+  virtual int foo(void *) { }
+} f;
+ 
+class C_G : public C_A {
+public:
+  virtual int foo(void *) { }
+} g;
+ 
+class C_H : public C_G, public C_E, public C_F {
+public:
+  virtual int foo(void *) { }
+} h;
+ 
+int main() {
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/vtable1.C b/gcc/testsuite/g++.old-deja/g++.mike/vtable1.C
new file mode 100644
index 00000000000..260f93de048
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/vtable1.C
@@ -0,0 +1,12 @@
+// Build don't run:
+// Special g++ Options: -fno-implement-inlines 
+struct type {
+  virtual void m1();
+  virtual void m2() { }
+};
+
+void type::m1() { }
+
+int main() {
+  type t;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/warn1.C b/gcc/testsuite/g++.old-deja/g++.mike/warn1.C
new file mode 100644
index 00000000000..206042cb962
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/warn1.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// Special g++ Options: -Wall
+
+typedef char * charptr;
+char c[]={'A','B','C','D'};
+int i=int(&c);
+int *pp=&i;
+void foo() { }
+int main()
+{
+ charptr(*pp)++;	// WARNING - 
+ return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/warn2.C b/gcc/testsuite/g++.old-deja/g++.mike/warn2.C
new file mode 100644
index 00000000000..f865f1e52d9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/warn2.C
@@ -0,0 +1,26 @@
+// Build don't link:
+// Special g++ Options: -Wall
+
+enum Boolean {
+  Ok = 0,
+  NotOk = 1,
+};
+
+enum OpResult {
+  Succeeded = 0,
+  TempFail = 1,
+  PermFail = 2,
+};
+
+OpResult fn1() {
+  return TempFail;
+}
+
+extern void foo();
+
+int
+main () {
+  if (fn1() == Ok) {	// WARNING - 
+    foo();
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/warn3.C b/gcc/testsuite/g++.old-deja/g++.mike/warn3.C
new file mode 100644
index 00000000000..7adc8a1c37f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/warn3.C
@@ -0,0 +1,12 @@
+// Build don't link:
+// Special g++ Options: -Wall
+
+class B {
+public:
+  B(int) { }
+};
+
+class D : public B {
+  int member;
+  D() : member(0), B(member) { }	// WARNING - reordered
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/warn4.C b/gcc/testsuite/g++.old-deja/g++.mike/warn4.C
new file mode 100644
index 00000000000..9b959b0316f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/warn4.C
@@ -0,0 +1 @@
+void foo (int a, int a) { }	// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/warn5.C b/gcc/testsuite/g++.old-deja/g++.mike/warn5.C
new file mode 100644
index 00000000000..742c4bc1807
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/warn5.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// Special g++ Options: -Wpointer-arith
+
+double X(const double x) { return x; }
+double Y() { return 1.0; }
+double Z() { return 2.0; }
+
+struct A {
+  void bar() { }
+  void foo() { }
+};
+
+typedef void (A::*pmf)();
+
+static int mememe = &A::foo - &A::bar;	// WARNING - 
+pmf b = &A::foo-1;	// WARNING - 
+
+int main() {
+    double y;
+    y=X(Y-Z);   // WARNING - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/warn6.C b/gcc/testsuite/g++.old-deja/g++.mike/warn6.C
new file mode 100644
index 00000000000..381a3424da2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/warn6.C
@@ -0,0 +1,42 @@
+// Build don't link:
+// Special g++ Options: -Woverloaded-virtual
+
+struct B4 {
+  virtual void bothfardiff(float);	// WARNING - was hidden
+};
+
+struct B3 : public B4 {
+};
+
+struct B2 {
+};
+
+struct B {
+  virtual void baseonly(int);
+
+  virtual void bothsame(int);
+
+  virtual void bothdiff(float);		// WARNING - was hidden
+
+  virtual void both2same(int);
+  virtual void both2same(float);
+
+  virtual void both12diff(int);
+  virtual void both12diff(float);	// WARNING - was hidden
+};
+
+struct D : public B, public B2, public B3 {
+  virtual void derivedonly(int);
+
+  virtual void bothsame(int);
+
+  virtual void bothdiff(int);		// WARNING - 
+
+  virtual void both2same(int);
+  virtual void both2same(float);
+
+  virtual void both12diff(int);		// WARNING - 
+
+  virtual void bothfardiff(int);	// WARNING - 
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/warn7.C b/gcc/testsuite/g++.old-deja/g++.mike/warn7.C
new file mode 100644
index 00000000000..6772f9585f5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/warn7.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Special g++ Options: -Wall
+
+const int& foo() {
+  extern int bar;
+  
+  return bar;
+}
+
+const int* baz() {
+  extern int bar;
+  
+  return &bar;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.mike/warn8.C b/gcc/testsuite/g++.old-deja/g++.mike/warn8.C
new file mode 100644
index 00000000000..3c61c8e0afb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.mike/warn8.C
@@ -0,0 +1,19 @@
+// Build don't link:
+
+struct foo {
+  bool test();
+};
+bool func();
+
+void test() {
+  foo A;
+  bool (foo::* pmf)() = &foo::test;
+  bool (*pf)() = func;
+
+  if (A.test) ;			// WARNING - 
+  if (func) ;			// WARNING - 
+  if (bool(A.test)) ;		// WARNING - 
+  if (bool(func)) ;
+  if (pmf) ;
+  if (pf) ;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/.cvsignore b/gcc/testsuite/g++.old-deja/g++.niklas/.cvsignore
new file mode 100644
index 00000000000..7abff1dbead
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/.cvsignore
@@ -0,0 +1,2 @@
+Makefile
+config.status
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/Makefile.in b/gcc/testsuite/g++.old-deja/g++.niklas/Makefile.in
new file mode 100644
index 00000000000..d5eb149dbee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+		-rm -f *.o *.diff *~ *.bad core 
+
+distclean:	clean
+		-rm -f Makefile config.status
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/README b/gcc/testsuite/g++.old-deja/g++.niklas/README
new file mode 100644
index 00000000000..b729b9a0cd0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/README
@@ -0,0 +1,18 @@
+Date: Fri, 22 Jan 93 15:20:55 +0100
+From: niklas@della.appli.se (Niklas Hallqvist)
+Message-Id: <9301221420.AA18489@della.appli.se>
+Subject: g++.niklas DejaGnu sharfile
+
+These are my test-cases in DejaGnu format.
+
+The tests which have "passed" in the groups variable do actually pass
+on my local G++ so if there is a specific "passed" test you'd like to
+see working in your version of G++ but it doesn't pass, contact me and
+I'll dig up the specific patches you'll need.
+
+I have about a hundred or so unsorted test-cases which are not
+included in this archive, due to lack of time and boredom stemming
+from writing .exp-files.  But they will show up eventually.
+
+All these files, and this file are Copyright FSF 1993, and fall under
+the GPL version 2.0 or later.
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/configure.in b/gcc/testsuite/g++.old-deja/g++.niklas/configure.in
new file mode 100644
index 00000000000..2ec1354c91f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=t131.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t113.C b/gcc/testsuite/g++.old-deja/g++.niklas/t113.C
new file mode 100644
index 00000000000..fdbf4550dce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t113.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed niklas explicit-construct virtual-base
+struct A {};
+struct B : virtual A { B(); };
+struct C : B {};
+struct D { D(C&); };
+D d(C());
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t114.C b/gcc/testsuite/g++.old-deja/g++.niklas/t114.C
new file mode 100644
index 00000000000..c5b458a4e15
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t114.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed niklas explicit-construct
+struct A { A(); };
+struct B { B(A&); };
+B b(A());
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t115.C b/gcc/testsuite/g++.old-deja/g++.niklas/t115.C
new file mode 100644
index 00000000000..7ec5b4699dd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t115.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+// GROUPS passed niklas virtual-base
+struct A { A(); virtual void f(); };
+struct B : virtual A { B(); };
+struct C : B {};
+C *c = new C;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t118.C b/gcc/testsuite/g++.old-deja/g++.niklas/t118.C
new file mode 100644
index 00000000000..255747f5498
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t118.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS niklas pt
+template <class T> class C1 {};
+class C1<int> C1_int_object;
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t119.C b/gcc/testsuite/g++.old-deja/g++.niklas/t119.C
new file mode 100644
index 00000000000..522e514f811
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t119.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed niklas i386
+unsigned long foo(unsigned long x)
+{
+  return x & ~0104000;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t120.C b/gcc/testsuite/g++.old-deja/g++.niklas/t120.C
new file mode 100644
index 00000000000..c04158047be
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t120.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed niklas ellipsis
+typedef void (*T) (...);
+void f ();
+struct S { void g (T); void h() { g(f); } };// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t121.C b/gcc/testsuite/g++.old-deja/g++.niklas/t121.C
new file mode 100644
index 00000000000..e99c940110d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t121.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed niklas ellipsis
+void f ();
+void g1 (void (*) (...)); void h1 () { g1 (f); }// ERROR - .*
+struct S { void g2 (void (*) (...)); void h2 () { g2 (f); } };// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t122.C b/gcc/testsuite/g++.old-deja/g++.niklas/t122.C
new file mode 100644
index 00000000000..a4ec0454712
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t122.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+// GROUPS passed niklas dwarf
+struct S { S(); };
+
+inline void
+foo (
+      S a,
+      S b
+    )
+{}
+
+void
+bar (S s1, S s2)
+{ foo (s1, s2); }
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t123.C b/gcc/testsuite/g++.old-deja/g++.niklas/t123.C
new file mode 100644
index 00000000000..37db7875eb8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t123.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed niklas dwarf
+struct S { S(); };
+void f(S) {}
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t124.C b/gcc/testsuite/g++.old-deja/g++.niklas/t124.C
new file mode 100644
index 00000000000..ba1aa55cc7d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t124.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed niklas nested-types static-members
+struct A
+{
+  static void f ();
+  struct B
+  {
+    static void g () { f (); }
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t125.C b/gcc/testsuite/g++.old-deja/g++.niklas/t125.C
new file mode 100644
index 00000000000..e5947ef9ce1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t125.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// GROUPS passed niklas nested-types static-members
+struct A
+{
+  static void f ();
+  struct B
+  {
+    void h () { f (); }
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t126.C b/gcc/testsuite/g++.old-deja/g++.niklas/t126.C
new file mode 100644
index 00000000000..7313a6abab1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t126.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+// GROUPS passed niklas nested-types static-members
+struct A
+{
+  static void f ();
+  struct B
+  {
+    void g () {}
+    void h () {}
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t127.C b/gcc/testsuite/g++.old-deja/g++.niklas/t127.C
new file mode 100644
index 00000000000..a53d2d4a3b7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t127.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed niklas nested-types
+struct A { struct B { ~B (); }; };
+A::B::~B () {}
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t128.C b/gcc/testsuite/g++.old-deja/g++.niklas/t128.C
new file mode 100644
index 00000000000..7ada1dc685e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t128.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS niklas uncaught default-construct
+struct A { A (int); };
+struct B : A {}; // ERROR - 
+void f () { B (0); }// ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t129.C b/gcc/testsuite/g++.old-deja/g++.niklas/t129.C
new file mode 100644
index 00000000000..11e316aef21
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t129.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed niklas nested-types
+struct X {
+struct A { A (int); };
+struct B : A { B (int a) : A (a) {} };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t130.C b/gcc/testsuite/g++.old-deja/g++.niklas/t130.C
new file mode 100644
index 00000000000..7b2fb433b85
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t130.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed niklas nested-types
+struct A;
+struct B { struct A { A(int); }; struct C : A { C() : A (0) {} }; };
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t131.C b/gcc/testsuite/g++.old-deja/g++.niklas/t131.C
new file mode 100644
index 00000000000..75283a828a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t131.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed niklas static-members
+struct A { static A a; };
+A f () { return A::a; }
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t132.C b/gcc/testsuite/g++.old-deja/g++.niklas/t132.C
new file mode 100644
index 00000000000..18cd01c4b5e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t132.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+// GROUPS passed niklas construct-destruct
+struct S { S (); ~S (); };
+void f () { while (1) S s; }
+
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t133.C b/gcc/testsuite/g++.old-deja/g++.niklas/t133.C
new file mode 100644
index 00000000000..f79c6dbdef1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t133.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed niklas nested-types
+struct A { struct B { void operator = (const B&); }; };
+void A::B::operator = (const B&) {}
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t134.C b/gcc/testsuite/g++.old-deja/g++.niklas/t134.C
new file mode 100644
index 00000000000..faa15555e22
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t134.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS passed niklas static-members
+extern "C" int f ();
+struct A { static void f () {} };
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t135.C b/gcc/testsuite/g++.old-deja/g++.niklas/t135.C
new file mode 100644
index 00000000000..138c27802c9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t135.C
@@ -0,0 +1,28 @@
+// Build don't link: 
+// GROUPS niklas pt friend
+// excess errors test - XFAIL *-*-*
+template <class T> class C1
+{
+public:
+	void diddle_C2 ();
+};
+
+class C2
+{
+	int data_member;
+        friend class C1;
+};
+
+class C2 C2_object;
+
+template <class T> void C1<T>::diddle_C2 ()
+{
+  C2_object.data_member = 99;
+}
+
+C1<int> C1_int_object;
+
+void foobar ()
+{
+  C1_int_object.diddle_C2 ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t136.C b/gcc/testsuite/g++.old-deja/g++.niklas/t136.C
new file mode 100644
index 00000000000..4890f61e25f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t136.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+// GROUPS niklas overloading
+extern "C" void f (char*);
+void f (const char*) {}
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t137.C b/gcc/testsuite/g++.old-deja/g++.niklas/t137.C
new file mode 100644
index 00000000000..9a64f0fe154
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t137.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed niklas nested-types
+struct A {
+  struct B { void f (); };
+  struct C : B { void f () { B::f (); } };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t138.C b/gcc/testsuite/g++.old-deja/g++.niklas/t138.C
new file mode 100644
index 00000000000..0f30d953420
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t138.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// GROUPS passed niklas hiding
+struct A;
+void f (A*);
+A* A;
+void g () { f (A); }
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t139.C b/gcc/testsuite/g++.old-deja/g++.niklas/t139.C
new file mode 100644
index 00000000000..702d065f2ad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t139.C
@@ -0,0 +1,7 @@
+// GROUPS passed niklas hiding ARM
+// Build don't link:
+// Special g++ Options: -w
+struct stat {};
+stat gstat;
+int stat (struct stat*);
+void f () { struct stat* ps; stat (ps); }
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t140.C b/gcc/testsuite/g++.old-deja/g++.niklas/t140.C
new file mode 100644
index 00000000000..f840c62a82e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t140.C
@@ -0,0 +1,11 @@
+// GROUPS passed niklas hiding local-types
+extern "C" int printf (const char*, ...);
+int val = 1;
+void S () { printf ("FAIL\n"); }
+void f () { printf ("PASS\n"); val = 0; }
+int main ()
+{
+  struct S { S () { f (); } };
+  S ();
+  return val;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.niklas/t141.C b/gcc/testsuite/g++.old-deja/g++.niklas/t141.C
new file mode 100644
index 00000000000..d85e97edb97
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.niklas/t141.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+// Special g++ Options: -Wshadow
+// GROUPS passed niklas scoping ARM
+class X { X (int); };
+void X (int);// ERROR - .*hides constructor.*
+void f () { X (1); }
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/alias1.C b/gcc/testsuite/g++.old-deja/g++.ns/alias1.C
new file mode 100644
index 00000000000..797e2b2d244
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/alias1.C
@@ -0,0 +1,18 @@
+namespace foo{
+ int eine_funktion(int)
+ {
+   return 0;
+ }
+}
+
+namespace foo{
+ void eine_funktion(int,int)
+ {}
+}
+
+namespace bar = foo;
+
+int main()
+{
+  return bar::eine_funktion(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/alias2.C b/gcc/testsuite/g++.old-deja/g++.ns/alias2.C
new file mode 100644
index 00000000000..95b2a2354df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/alias2.C
@@ -0,0 +1,8 @@
+//Build don't link:
+namespace NS1
+{
+  int a;
+}
+
+namespace NS2 = NonExistant; //ERROR - 
+
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/alias3.C b/gcc/testsuite/g++.old-deja/g++.ns/alias3.C
new file mode 100644
index 00000000000..3b8de0cf1a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/alias3.C
@@ -0,0 +1,30 @@
+namespace A{
+  struct X{};
+  void f(X&);
+  extern int i;
+  namespace a_very_long_namespace_name{
+    int k;
+  }
+}
+
+namespace B = A;
+namespace B = A;
+namespace B = B;
+
+namespace avl = A::a_very_long_namespace_name;
+
+void B::f(A::X& x)
+{
+  B::f(x);
+  f(x);
+  avl::k = 1;
+}
+
+int B::i = 0;
+
+int main()
+{
+  B::X x;
+  if (B::i)
+    A::f(x);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/alias4.C b/gcc/testsuite/g++.old-deja/g++.ns/alias4.C
new file mode 100644
index 00000000000..16c4dca02d4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/alias4.C
@@ -0,0 +1,13 @@
+namespace A = B;  // ERROR - unknown namespace
+
+namespace C{}
+namespace D = C;  
+namespace D {     // ERROR - reopening namespace with alias
+  void f();
+}
+
+void C::f(){}     // ERROR - previous definition
+
+void D::f(){}     // ERROR - redefinition
+
+namespace E = C::F; // ERROR - unknown namespace
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/alias5.C b/gcc/testsuite/g++.old-deja/g++.ns/alias5.C
new file mode 100644
index 00000000000..797e2b2d244
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/alias5.C
@@ -0,0 +1,18 @@
+namespace foo{
+ int eine_funktion(int)
+ {
+   return 0;
+ }
+}
+
+namespace foo{
+ void eine_funktion(int,int)
+ {}
+}
+
+namespace bar = foo;
+
+int main()
+{
+  return bar::eine_funktion(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/alias6.C b/gcc/testsuite/g++.old-deja/g++.ns/alias6.C
new file mode 100644
index 00000000000..b0799abf775
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/alias6.C
@@ -0,0 +1,35 @@
+// Check namespace aliases inside blocks
+namespace A { 
+  int i;
+  void f(){
+    i = 0;
+  }
+}
+
+int g();
+
+int main ()
+{
+  namespace B = A;
+  B::i=42;
+  B::f();
+  using namespace B;
+  f();
+  // A::i is now 0, B::i is 1
+  return g();
+}
+
+namespace B {
+  int i = 1;
+}
+
+int g()
+{
+  namespace x = A;
+  if (x::i)
+  {
+    namespace x = B;
+    return x::i;
+  }
+  return x::i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/alias7.C b/gcc/testsuite/g++.old-deja/g++.ns/alias7.C
new file mode 100644
index 00000000000..ce1ebb86755
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/alias7.C
@@ -0,0 +1,11 @@
+//Build don't link:
+namespace A{
+  namespace B{int i;}
+  using namespace B;
+}
+
+namespace C=A;
+
+void f(){
+  C::i = 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/anon1.C b/gcc/testsuite/g++.old-deja/g++.ns/anon1.C
new file mode 100644
index 00000000000..c4a242a5078
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/anon1.C
@@ -0,0 +1,12 @@
+namespace{
+  void f();
+}
+
+int main()
+{
+  f();
+}
+
+namespace{
+  void f(){}
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/bogus1.C b/gcc/testsuite/g++.old-deja/g++.ns/bogus1.C
new file mode 100644
index 00000000000..c61dea8e77e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/bogus1.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+namespace N {}
+
+void f(int N::k); // ERROR - cannot use `::' in parameter declaration
+
+class Foo
+{
+  int N::j; // ERROR - invalid use of `::'
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/crash1.C b/gcc/testsuite/g++.old-deja/g++.ns/crash1.C
new file mode 100644
index 00000000000..5a002bd7bf9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/crash1.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template <class T> 
+struct S1 {};
+
+namespace N {
+}
+
+struct S2 
+{
+  typedef N::S1<int> S2_T; // ERROR - parse error
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/crash2.C b/gcc/testsuite/g++.old-deja/g++.ns/crash2.C
new file mode 100644
index 00000000000..d49189bfbe1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/crash2.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+// Submitted by bjornw@fairplay.no
+
+// crash test - XFAIL *-*-*
+
+namespace hei {
+  class CSomeClass {};
+  extern CSomeClass SomeClass;
+};
+
+hei::CSomeClass hei::CSomeClass; // ERROR - should be hei::SomeClass
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/crash3.C b/gcc/testsuite/g++.old-deja/g++.ns/crash3.C
new file mode 100644
index 00000000000..842ed090bcc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/crash3.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+namespace N {
+  template <class T> struct S;
+};
+
+void f()
+{
+  N::S(); // ERROR - invalid use of template
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/extern1.C b/gcc/testsuite/g++.old-deja/g++.ns/extern1.C
new file mode 100644
index 00000000000..906b97b8f06
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/extern1.C
@@ -0,0 +1,18 @@
+// Build don't run:
+
+// Based on a testcase by eyal.ben-david@aks.com
+
+// An extern declaration of an undeclared object within a function
+// introduces the object into the enclosing namespace [basic.link]/7
+
+namespace {
+  void foo() {
+    extern int xx;
+    xx = 0;
+  }
+  int xx = 1;
+}
+
+int main() {
+  xx = 2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/friend1.C b/gcc/testsuite/g++.old-deja/g++.ns/friend1.C
new file mode 100644
index 00000000000..859a84ec3ec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/friend1.C
@@ -0,0 +1,8 @@
+// Build don't link:
+namespace A{
+  void f(int);
+}
+
+class X{
+  friend void A::f(int);
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/friend2.C b/gcc/testsuite/g++.old-deja/g++.ns/friend2.C
new file mode 100644
index 00000000000..7d4a6c87d87
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/friend2.C
@@ -0,0 +1,11 @@
+//Build don't link:
+namespace A{
+  void foo();
+}
+
+
+namespace B{
+class B{
+  friend void A::foo();
+};
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/invalid1.C b/gcc/testsuite/g++.old-deja/g++.ns/invalid1.C
new file mode 100644
index 00000000000..76d3d70db38
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/invalid1.C
@@ -0,0 +1,12 @@
+//Build don't link:
+namespace x { };
+
+void f(int);
+
+int main()
+{
+        x();   // ERROR - calling a namespace
+        x=4;   // ERROR - assigning to a namespace
+	f(x);  // ERROR - passing a namespace as parameter
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/koenig1.C b/gcc/testsuite/g++.old-deja/g++.ns/koenig1.C
new file mode 100644
index 00000000000..bd721fe94e2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/koenig1.C
@@ -0,0 +1,18 @@
+// Build don't link:
+class ostream;
+extern ostream cout;
+namespace foo
+{
+  struct S
+  {
+    int i;
+  };
+  
+  extern ostream &operator<<(ostream &, const S &);
+}
+
+
+void bar(foo::S s)
+{
+  cout << s ;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/koenig2.C b/gcc/testsuite/g++.old-deja/g++.ns/koenig2.C
new file mode 100644
index 00000000000..629cd388af8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/koenig2.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// Check association of {error} for Koenig lookup
+// Special g++ Options:
+
+struct QString { operator void * (); };
+int foo()
+{
+  QString bar;
+  return (bar == __null );
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/koenig3.C b/gcc/testsuite/g++.old-deja/g++.ns/koenig3.C
new file mode 100644
index 00000000000..e039df69557
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/koenig3.C
@@ -0,0 +1,21 @@
+//Check association of member pointer in overload resolution.
+struct A {
+	int m_val;
+	friend int operator ->* (A & other, int A::*pm)
+		{ return 31; }
+};
+
+int A::*pi = & A::m_val;
+
+int
+main(void)
+{
+	A c;
+	c.m_val = 42;
+	int j = c ->* pi;
+
+	if (j == 31)
+		return 0;
+	else
+		return 1;
+}	
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/koenig4.C b/gcc/testsuite/g++.old-deja/g++.ns/koenig4.C
new file mode 100644
index 00000000000..009327c3463
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/koenig4.C
@@ -0,0 +1,24 @@
+void f();
+void f(int);
+
+namespace A{
+  struct S{
+    void f();
+    void f(S);
+  };
+  void f(S&){}
+  void h(S&){}
+}
+
+template<class T>
+void g(T t){
+  f(t);
+}
+
+int main()
+{
+  A::S s;
+  f(s);
+  g(s);
+  h(s);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/koenig5.C b/gcc/testsuite/g++.old-deja/g++.ns/koenig5.C
new file mode 100644
index 00000000000..e5500cbea8b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/koenig5.C
@@ -0,0 +1,15 @@
+// To find function pointers in Koenig lookup is ok as long as we only find one.
+namespace A{
+  void foo();             // ERROR - 
+  struct X{};
+  void (*bar)(X*)=0;
+}
+using A::X;
+
+void (*foo)(X*)=0;        // ERROR - 
+
+void g()
+{
+  foo(new X);            // ERROR - both objects and functions found
+  bar(new X);            // ok
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/koenig6.C b/gcc/testsuite/g++.old-deja/g++.ns/koenig6.C
new file mode 100644
index 00000000000..dc549038500
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/koenig6.C
@@ -0,0 +1,12 @@
+namespace A{
+  struct X{};
+
+  X foo(X a){return a;}
+  void bar(X*){}
+}
+
+int main()
+{
+  A::X x;
+  bar(&foo(x));  // WARNING - address of temporary
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/koenig7.C b/gcc/testsuite/g++.old-deja/g++.ns/koenig7.C
new file mode 100644
index 00000000000..2565a9e849d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/koenig7.C
@@ -0,0 +1,22 @@
+// Test for Koenig lookup involving overloaded functions.
+
+namespace N1 {
+  struct A { };
+  void f1(A) {}
+  void f2(float) {}
+  void g(void (*)(float)) {}
+}
+
+using N1::f1;
+void f1(float) {}
+
+using N1::f2;
+template <class T>
+void f2(N1::A, T) {}
+
+void g(void (*)(int)) {}
+
+int main() {  
+   g(&f1); // Works?
+   g(f2); // Works?
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/lookup1.C b/gcc/testsuite/g++.old-deja/g++.ns/lookup1.C
new file mode 100644
index 00000000000..6b6f0cc9b0d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/lookup1.C
@@ -0,0 +1,3 @@
+// Build don't link: 
+typedef int __quad_t;
+typedef __quad_t __qaddr_t;
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/lookup2.C b/gcc/testsuite/g++.old-deja/g++.ns/lookup2.C
new file mode 100644
index 00000000000..0143290a67f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/lookup2.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+template <class charT>
+struct basic_string
+{
+  charT append (charT c)
+    { return c; }
+};
+typedef char c;
+template class basic_string <char>;
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/lookup3.C b/gcc/testsuite/g++.old-deja/g++.ns/lookup3.C
new file mode 100644
index 00000000000..3ace233c1b9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/lookup3.C
@@ -0,0 +1,14 @@
+namespace A{
+  int i;
+  int f();
+}
+
+int A::f()
+{
+  return i;
+}
+
+int main()
+{
+  return A::f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/lookup4.C b/gcc/testsuite/g++.old-deja/g++.ns/lookup4.C
new file mode 100644
index 00000000000..208a9d68459
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/lookup4.C
@@ -0,0 +1,23 @@
+//Build don't link:
+namespace X{
+  typedef int foo;
+  const int bar=2;
+  namespace Y{
+    void f(foo);
+    extern int g;
+    extern int g1;
+    struct h{
+      void i(foo);
+    };
+  }
+}
+
+void X::Y::f(foo)
+{
+}
+
+int X::Y::g = bar;
+int X::Y::g1(bar);
+
+void X::Y::h::i(foo)
+{}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/lookup5.C b/gcc/testsuite/g++.old-deja/g++.ns/lookup5.C
new file mode 100644
index 00000000000..c83b50a9779
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/lookup5.C
@@ -0,0 +1,23 @@
+// Build don't link: 
+namespace A{
+  void f();
+}
+
+namespace B{
+  using namespace A;
+  void f(int);			// ERROR - referenced below
+}
+
+using namespace B;
+
+void g()
+{
+  ::f();               // ERROR - A::f is not found
+}
+
+using namespace A;
+
+void g1()
+{
+  ::f();               // ok, it is found now
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/main1.C b/gcc/testsuite/g++.old-deja/g++.ns/main1.C
new file mode 100644
index 00000000000..0e5a07f6aae
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/main1.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+// main is only reserved in the global namespace [basic.start.main]/3
+
+// submitted by Gerald Gutierrez <gutier@intergate.bc.ca>
+
+namespace A { void main () { } }
+namespace B { void main () { } }
+namespace C {
+  void main () { }
+  namespace D {
+    void main () { }
+  }
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns1.C b/gcc/testsuite/g++.old-deja/g++.ns/ns1.C
new file mode 100644
index 00000000000..f835716d2c3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns1.C
@@ -0,0 +1,16 @@
+namespace foo{
+  int eine_funktion(int)
+    {
+      return 0;
+    }
+
+  int eine_funktion(int,int)
+    {
+      return 1;
+    }
+}
+
+int main(int,char**)
+{
+  return foo::eine_funktion(1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns10.C b/gcc/testsuite/g++.old-deja/g++.ns/ns10.C
new file mode 100644
index 00000000000..3eb70a8de60
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns10.C
@@ -0,0 +1,13 @@
+//Build don't link:
+namespace bb
+{
+  int f(int);
+
+  namespace k
+  {
+    void foo(int bar)
+    {
+      int i=bb:f(bar); // ERROR - namespace
+    }
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns11.C b/gcc/testsuite/g++.old-deja/g++.ns/ns11.C
new file mode 100644
index 00000000000..ffc5acbb839
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns11.C
@@ -0,0 +1,19 @@
+// Build don't link
+// Check [namespace.memdef]/2
+
+namespace A{
+  void f(int);
+  void f(int,int);
+  int i;              // ERROR - .*
+}
+
+void A::f(){}         // ERROR - should have been declared before
+
+namespace B{
+  void A::f(int){}    // ERROR - B does not surround A
+}
+
+int A::i;             // ERROR - redefinition
+
+void A::f(int,int){}  // ok
+
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns12.C b/gcc/testsuite/g++.old-deja/g++.ns/ns12.C
new file mode 100644
index 00000000000..40f5b7cfe25
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns12.C
@@ -0,0 +1,22 @@
+namespace fred
+{
+  int barney();
+  extern int wilma;
+}
+
+int fred::barney()
+{
+  return fred::wilma;
+}
+
+int fred::wilma;
+
+int barney()
+{
+  return 1;
+}
+
+int main()
+{
+  return fred::barney();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns13.C b/gcc/testsuite/g++.old-deja/g++.ns/ns13.C
new file mode 100644
index 00000000000..0b8c38a1cbb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns13.C
@@ -0,0 +1,13 @@
+namespace std{ 
+  void f(){}
+  void g();
+  int i=5;
+}
+
+void std::g()
+{}
+
+int main()
+{
+  return std::i-5;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns14.C b/gcc/testsuite/g++.old-deja/g++.ns/ns14.C
new file mode 100644
index 00000000000..5a3cc701074
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns14.C
@@ -0,0 +1,16 @@
+//Special g++ Options: -fhonor-std
+namespace std{ 
+  int f(){
+    return 0;
+  }
+}
+
+int f()
+{
+  return 1;
+}
+
+int main()
+{
+  return std::f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns15.C b/gcc/testsuite/g++.old-deja/g++.ns/ns15.C
new file mode 100644
index 00000000000..cbb6292e284
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns15.C
@@ -0,0 +1,2 @@
+//Build don't link:
+namespace std {}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns16.C b/gcc/testsuite/g++.old-deja/g++.ns/ns16.C
new file mode 100644
index 00000000000..1f04ae82ffb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns16.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+class Y {
+public:
+  void operator +(int) const;
+};
+
+namespace X {
+  extern Y const& z;
+}
+
+void f(void) {
+  X::z + 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns17.C b/gcc/testsuite/g++.old-deja/g++.ns/ns17.C
new file mode 100644
index 00000000000..8d1fdd7e2ac
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns17.C
@@ -0,0 +1,13 @@
+//Build don't link:
+namespace foo
+{
+  class c
+  {
+  };
+};
+
+int
+foo::c:fn ()  // ERROR - syntax error
+{
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns2.C b/gcc/testsuite/g++.old-deja/g++.ns/ns2.C
new file mode 100644
index 00000000000..e0d1bdade04
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns2.C
@@ -0,0 +1,26 @@
+namespace foo{
+ struct X{
+   int i;
+   void f();
+   static int k1,k2;
+ };
+ void X::f(){}
+ int var;
+ int X::k1;
+}
+
+using namespace foo;
+X zzz;
+int X::k2;
+
+void andere_funktion()
+{
+  zzz.f();
+  var=4;
+}
+
+int main(int,char**)
+{
+  andere_funktion();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns3.C b/gcc/testsuite/g++.old-deja/g++.ns/ns3.C
new file mode 100644
index 00000000000..a1c8f536d4b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns3.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+namespace foo{
+ void eine_funktion(int)
+ {}
+}
+
+using namespace foo;
+
+namespace foo{
+ void eine_funktion(int,int)
+ {}
+}
+
+void andere_funktion()
+{
+  eine_funktion(3,4);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns4.C b/gcc/testsuite/g++.old-deja/g++.ns/ns4.C
new file mode 100644
index 00000000000..f720da30fc2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns4.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+namespace A{
+  enum foo{a,b,c};
+}
+using A::foo;
+using A::b;
+void g()
+{
+  foo x;
+  x=b;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns5.C b/gcc/testsuite/g++.old-deja/g++.ns/ns5.C
new file mode 100644
index 00000000000..f35b2474588
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns5.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+namespace X{
+  class Y{};
+}
+
+X::Y z;
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns6.C b/gcc/testsuite/g++.old-deja/g++.ns/ns6.C
new file mode 100644
index 00000000000..ba2508c6ded
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns6.C
@@ -0,0 +1,13 @@
+namespace A{
+ int i;
+ namespace B{
+  void f(){i++;}
+  int i;
+  void g(){i++;}
+  }
+}
+
+int main()
+{
+  return A::i-A::B::i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns7.C b/gcc/testsuite/g++.old-deja/g++.ns/ns7.C
new file mode 100644
index 00000000000..9afc97c410f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns7.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+namespace A{
+ struct X{
+   int i;
+   X(){}
+   X(int j);
+   void operator=(const X&);
+   virtual ~X(){}
+ };
+ void X::operator=(const X&o)
+ {
+   i=o.i;
+ }
+}
+
+A::X::X(int j):i(j){}
+
+namespace A{
+  struct Y:public X{
+    int j;
+    Y(int,int);
+  };
+}
+
+A::Y::Y(int a,int b):X(a),j(b)
+{}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns8.C b/gcc/testsuite/g++.old-deja/g++.ns/ns8.C
new file mode 100644
index 00000000000..4d1ab40592d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns8.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+namespace B{
+ void f();
+}
+
+using namespace B;
+
+void g()
+{
+	::f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/ns9.C b/gcc/testsuite/g++.old-deja/g++.ns/ns9.C
new file mode 100644
index 00000000000..a8803b89326
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/ns9.C
@@ -0,0 +1,13 @@
+// Build don't link:
+namespace bb
+{
+  int f(int);
+
+  namespace k
+  {
+    void foo(int bar)
+    {
+      return bb:f(bar); //ERROR - syntax error
+    }
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/overload1.C b/gcc/testsuite/g++.old-deja/g++.ns/overload1.C
new file mode 100644
index 00000000000..55d66a1de09
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/overload1.C
@@ -0,0 +1,33 @@
+// Unqualified lookup should find all functions.
+// Duplicates are ignored as long as they lose during overload resolution.
+namespace A{
+  int f(){
+    return 1;
+  }
+  int f(double);
+}
+namespace B{
+  int f(int){
+    return 2;
+  }
+  int f(double);
+}
+
+int f(int,int)
+{
+  return 3;
+}
+
+using namespace A;
+using namespace B;
+
+int main()
+{
+  if(f() != 1)
+    return 1;
+  if(f(1) != 2)
+    return 1;
+  if(f(0,0) != 3)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/overload2.C b/gcc/testsuite/g++.old-deja/g++.ns/overload2.C
new file mode 100644
index 00000000000..500d7804850
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/overload2.C
@@ -0,0 +1,12 @@
+namespace A{
+  void f();   // ERROR - .*
+}
+
+using namespace A;
+
+void f();     // ERROR - .*
+
+void g()
+{
+  f();        // ERROR - ambiguous, ::f or A::f ?
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/overload3.C b/gcc/testsuite/g++.old-deja/g++.ns/overload3.C
new file mode 100644
index 00000000000..945f9488511
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/overload3.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Declarations after the first one don't affect the set of used decls.
+
+namespace A{
+  void f();         // ERROR - .*
+}
+
+using A::f;
+
+namespace A{
+  void f(int);
+}
+
+using A::f;
+
+void g()
+{
+  f(4);            // ERROR - too many arguments
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/overload4.C b/gcc/testsuite/g++.old-deja/g++.ns/overload4.C
new file mode 100644
index 00000000000..ad961576419
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/overload4.C
@@ -0,0 +1,8 @@
+// Build don't link:
+namespace A{
+  void f();  
+}
+
+using A::f;
+void f();     // ERROR - duplicate declaration
+
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/overload5.C b/gcc/testsuite/g++.old-deja/g++.ns/overload5.C
new file mode 100644
index 00000000000..24a0a6df4da
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/overload5.C
@@ -0,0 +1,14 @@
+// Build don't link:
+namespace A{
+  void f(){}        
+}
+
+using A::f;
+
+void f(int);
+void f(){}            // ERROR - conflict
+
+void g()
+{
+  f(4);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/template1.C b/gcc/testsuite/g++.old-deja/g++.ns/template1.C
new file mode 100644
index 00000000000..593df9e8d06
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/template1.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+namespace foo {
+
+  template <class T>
+  class x {};
+
+}
+
+foo::x<int> y;
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/template2.C b/gcc/testsuite/g++.old-deja/g++.ns/template2.C
new file mode 100644
index 00000000000..bb7c1dced71
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/template2.C
@@ -0,0 +1,14 @@
+//Build don't link:
+//Inheritance from templates which are namespace members
+namespace foo {
+
+  template <class T>
+  struct x {
+    x(){}
+  };
+
+}
+
+class y : public foo::x<int> {};
+
+y r;
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/template3.C b/gcc/testsuite/g++.old-deja/g++.ns/template3.C
new file mode 100644
index 00000000000..761656f5a69
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/template3.C
@@ -0,0 +1,21 @@
+//Check instantiation of templates outside their namespace
+namespace A{
+template <class T>void g(){}
+template <class T> struct B {
+  B(){
+   f();
+  }
+  void f()
+  {
+    g<T>();
+  }
+};
+}
+
+template class A::B<int>;
+A::B<int> s;
+
+int main()
+{
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/template4.C b/gcc/testsuite/g++.old-deja/g++.ns/template4.C
new file mode 100644
index 00000000000..dd3244449f0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/template4.C
@@ -0,0 +1,17 @@
+namespace NS
+{
+template <typename T>
+void solver (){}
+
+}
+
+template<typename T>
+void solver(){}
+
+int main()
+{
+  solver<double>();
+  NS::solver<double>();
+}
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/template5.C b/gcc/testsuite/g++.old-deja/g++.ns/template5.C
new file mode 100644
index 00000000000..9dc7a396a7e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/template5.C
@@ -0,0 +1,33 @@
+//Check whether namespace-scoped template instantiations
+//are mangled differently.
+
+namespace X{
+  template<class T>
+  struct Y{
+   int f(T){
+     return 1;
+   }
+   template<class X>void g(){}
+  };
+}
+
+template<class T>
+struct Y{
+  int f(T){
+    return 2;
+  }
+};
+
+int main()
+{
+  X::Y<int> z;
+  if (z.f(4) != 1)
+    return 1;
+  z.template g<long>();
+
+  Y<int> z1;
+  if (z1.f(5) != 2)
+    return 1;
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/template6.C b/gcc/testsuite/g++.old-deja/g++.ns/template6.C
new file mode 100644
index 00000000000..324b4d22a59
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/template6.C
@@ -0,0 +1,24 @@
+//Build don't link:
+//reported by Theodore Papadopoulo (Theodore.Papadopoulo@sophia.inria.fr)
+
+namespace A {
+
+   namespace B {
+
+      template <class T1,class T2>
+         struct B {
+               static const unsigned count = 0;
+               template <class ForwardIter>
+               void SetError(ForwardIter it,const T1& p1,const T2& p2) const { }
+         };
+
+      template <>
+         const unsigned B<int,int>::count = 2; // ERROR - duplicate init
+   }
+};
+
+int
+main()
+{
+   unsigned kk =  A::B<int,int>::count; // ERROR - not a template: syntax error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/template7.C b/gcc/testsuite/g++.old-deja/g++.ns/template7.C
new file mode 100644
index 00000000000..3c857355a50
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/template7.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+// crash test - XFAIL *-*-*
+
+// Based on bug report by Eric NICOLAS <nicolas@bnp-eng.remcomp.com>
+
+namespace foo {
+  template<class F> struct bar {};
+}
+
+void baz() {
+  foo::bar(); // ERROR - template used as expression
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/template8.C b/gcc/testsuite/g++.old-deja/g++.ns/template8.C
new file mode 100644
index 00000000000..758f1927653
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/template8.C
@@ -0,0 +1,9 @@
+// Build don't link:
+namespace X {
+    template <class T> class foo;
+}
+
+template <class T>
+class X::foo {
+    T worthless;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/template9.C b/gcc/testsuite/g++.old-deja/g++.ns/template9.C
new file mode 100644
index 00000000000..1b50a5f626a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/template9.C
@@ -0,0 +1,40 @@
+// Produces ICE 980519.
+// Test case from Dirk Engelmann <Dirk.Engelmann@IWR.Uni-Heidelberg.De>
+
+namespace vector {
+
+  // allocate memory for vector
+        
+        template <class T>
+        inline T* alloc(const int aWidth)
+        {
+                // allocate memory
+                return new T[aWidth];
+        }
+
+}
+
+namespace matrix {
+
+  // allocate memory for matrix
+        template <class T>
+        T** alloc(const int aWidth,const int aHeight)
+        {
+                // allocate memory
+                T **mat = vector::alloc<T*>(aHeight);
+                T *data = vector::alloc<T> (aWidth*aHeight);
+                // set pointer
+                for (int i=0; i<aHeight; i++)
+                        mat[i] = &data[aWidth*i];
+                // ok
+                return mat;
+        }
+
+}
+
+int main(void)
+{
+  // sample
+  double **m=matrix::alloc<double>(10,20);
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/undef1.C b/gcc/testsuite/g++.old-deja/g++.ns/undef1.C
new file mode 100644
index 00000000000..d13b8e7063d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/undef1.C
@@ -0,0 +1,5 @@
+//Build don't link:
+namespace A{
+}
+
+struct Y: A::S<int>{};     //ERROR - no such type
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using1.C b/gcc/testsuite/g++.old-deja/g++.ns/using1.C
new file mode 100644
index 00000000000..489faac4e93
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using1.C
@@ -0,0 +1,3 @@
+// Build don't link:
+using namespace bb; // ERROR - .*
+
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using10.C b/gcc/testsuite/g++.old-deja/g++.ns/using10.C
new file mode 100644
index 00000000000..cd5cd47627a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using10.C
@@ -0,0 +1,9 @@
+//Build don't link:
+//Based on a report by Helmut Jarausch <jarausch@IGPM.Rwth-Aachen.DE>
+template<class>
+class foo{};
+
+namespace ABC
+{
+  using ::foo;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using11.C b/gcc/testsuite/g++.old-deja/g++.ns/using11.C
new file mode 100644
index 00000000000..23943f22a1a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using11.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+class joey {
+public:
+  typedef int SVec;
+};
+
+using joey::SVec; // ERROR - joey is not a namespace
+
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using12.C b/gcc/testsuite/g++.old-deja/g++.ns/using12.C
new file mode 100644
index 00000000000..edc863b08bf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using12.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Origin: Brendan Kehoe <brendan@cygnus.com>
+
+namespace foo
+{
+  void x (bool);     // ERROR - candidates
+  void x (char);     // ERROR - candidates
+  void x (int);      // ERROR - candidates
+  void x (double);   // ERROR - candidates
+}
+
+namespace baz { void x (int); }  // ERROR - candidates
+
+void fn (int i)
+{
+  using foo::x;
+  using baz::x;
+  x(i); 	 // ERROR - ambiguous
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using13.C b/gcc/testsuite/g++.old-deja/g++.ns/using13.C
new file mode 100644
index 00000000000..c1e96adcc96
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using13.C
@@ -0,0 +1,23 @@
+namespace A{
+ void foo(int){}
+}
+namespace B{
+  void foo(bool){}
+}
+
+void bar()
+{
+  using B::foo;
+  using A::foo;
+  foo(true);
+}
+
+namespace Foo {
+  template<class N> void Hello(N) {}
+}
+
+int main() {
+  using Foo::Hello;
+  Hello(4);
+  bar();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using2.C b/gcc/testsuite/g++.old-deja/g++.ns/using2.C
new file mode 100644
index 00000000000..879e0c5ef67
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using2.C
@@ -0,0 +1,5 @@
+// Build don't link:
+void f();
+namespace A{
+  using ::f;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using3.C b/gcc/testsuite/g++.old-deja/g++.ns/using3.C
new file mode 100644
index 00000000000..a8c1761f6f5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using3.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+typedef	unsigned int atypedef;
+struct astruct{};
+void afunction();
+void aovlfunction();
+void aovlfunction(int);
+int avariable;
+
+namespace foo {
+  using ::atypedef;
+  using ::astruct;
+  using ::afunction;
+  using ::aovlfunction;
+  using ::avariable;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using4.C b/gcc/testsuite/g++.old-deja/g++.ns/using4.C
new file mode 100644
index 00000000000..f3197be1f9d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using4.C
@@ -0,0 +1,5 @@
+//Build don't link
+#include <vector>
+namespace csp {
+using namespace std::vector;  // ERROR - vector is not a namespace
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using5.C b/gcc/testsuite/g++.old-deja/g++.ns/using5.C
new file mode 100644
index 00000000000..37fc6a85981
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using5.C
@@ -0,0 +1,6 @@
+// Build don't link:
+namespace a {
+    class b {
+	using std::c;  //ERROR - namespace using on class level
+    };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using6.C b/gcc/testsuite/g++.old-deja/g++.ns/using6.C
new file mode 100644
index 00000000000..b770950cc64
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using6.C
@@ -0,0 +1,9 @@
+//Build don't link:
+#include <vector>
+
+namespace csp {
+    using namespace std;
+    struct X {
+	vector<int> v;
+    };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using7.C b/gcc/testsuite/g++.old-deja/g++.ns/using7.C
new file mode 100644
index 00000000000..a449284a532
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using7.C
@@ -0,0 +1,11 @@
+namespace X{
+  void f(int){}
+}
+
+void f();
+
+int main()
+{
+  using X::f;
+  f(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using8.C b/gcc/testsuite/g++.old-deja/g++.ns/using8.C
new file mode 100644
index 00000000000..2234f589f34
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using8.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+namespace M {
+   int i;
+}
+namespace N {
+  using namespace M;
+}
+
+using namespace N;
+int j = i;
+
+namespace O{
+  int k;
+}
+
+namespace N {
+  using namespace O;
+}
+
+int l = k;
diff --git a/gcc/testsuite/g++.old-deja/g++.ns/using9.C b/gcc/testsuite/g++.old-deja/g++.ns/using9.C
new file mode 100644
index 00000000000..547ae3101fd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.ns/using9.C
@@ -0,0 +1,24 @@
+// Test for proper merging of functions from multiple using directives.
+
+// Build don't link:
+
+namespace standard 
+{ void print(int) {};
+  void dump(int)  {};
+}
+namespace A { using standard::print; }
+namespace B { using namespace standard; }
+namespace User
+{ using namespace standard; 
+  using namespace A;
+  void test()
+  {  print(1); }
+  // egcs-1.1: call of overloaded `print (int)' is ambiguous
+}
+namespace User2
+{ using namespace standard;
+  using namespace B;
+  void test()
+  { print(1); } // egcs has no problems here
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/.cvsignore b/gcc/testsuite/g++.old-deja/g++.other/.cvsignore
new file mode 100644
index 00000000000..7abff1dbead
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/.cvsignore
@@ -0,0 +1,2 @@
+Makefile
+config.status
diff --git a/gcc/testsuite/g++.old-deja/g++.other/900403_04.C b/gcc/testsuite/g++.old-deja/g++.other/900403_04.C
new file mode 100644
index 00000000000..9d55a37976b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/900403_04.C
@@ -0,0 +1,12 @@
+// GROUPS passed abort
+// Build don't link:
+// g++ 1.37.1 bug 900403_04
+
+// The following erroneous code causes g++ to abort.
+
+// keywords: abort, bit-fields, zero length
+
+struct s {
+  unsigned int foo:0;	// ERROR - causes abort
+  unsigned int field;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/900519_12.C b/gcc/testsuite/g++.old-deja/g++.other/900519_12.C
new file mode 100644
index 00000000000..1170b068b2f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/900519_12.C
@@ -0,0 +1,11 @@
+// GROUPS abort
+// Build don't link:
+// g++ 1.37.1 bug 900519_12
+
+// The following erroneous code causes g++ to segfault.
+
+// cfront 2.0 passes this test.
+
+// keywords: segfault, typedef, pointer type, function type
+
+typedef eek void (*)();		// ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.other/Makefile.in b/gcc/testsuite/g++.old-deja/g++.other/Makefile.in
new file mode 100644
index 00000000000..d5eb149dbee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+		-rm -f *.o *.diff *~ *.bad core 
+
+distclean:	clean
+		-rm -f Makefile config.status
diff --git a/gcc/testsuite/g++.old-deja/g++.other/access1.C b/gcc/testsuite/g++.old-deja/g++.other/access1.C
new file mode 100644
index 00000000000..43aff60a161
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/access1.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+class X{
+    unsigned int i;
+  public:
+    void f();
+};
+
+void X::f()
+{
+  union {
+    int foo[sizeof (i)];
+  };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/access2.C b/gcc/testsuite/g++.old-deja/g++.other/access2.C
new file mode 100644
index 00000000000..beb02a1f7d8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/access2.C
@@ -0,0 +1,12 @@
+// Build don't link:
+// Based on a test-case in the Standard, submitted by several people
+
+class Outer {
+  typedef int T;
+  struct Inner {
+    T i; // ERROR - not accessible - XFAIL *-*-*
+    void f() {
+      T j; // ERROR - not accessible - XFAIL *-*-*
+    }
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/access3.C b/gcc/testsuite/g++.old-deja/g++.other/access3.C
new file mode 100644
index 00000000000..2ba2c0c51d6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/access3.C
@@ -0,0 +1,26 @@
+// Build don't link:
+// The standard sez that a use of a name gets the most access it can through
+// the various paths that can reach it.  Here, the access decl in B gives
+// us access.
+
+struct A
+{
+  void f ();			
+};
+
+struct B: private virtual A
+{
+  A::f;
+};
+
+struct C: private virtual A, public B
+{
+};
+
+int
+main ()
+{
+  C c;
+
+  c.f ();			
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/access4.C b/gcc/testsuite/g++.old-deja/g++.other/access4.C
new file mode 100644
index 00000000000..75f3a6191a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/access4.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+struct A {
+  static int i;
+};
+
+struct B : private A { };
+
+struct C : public B {
+  int f () { return A::i; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/access5.C b/gcc/testsuite/g++.old-deja/g++.other/access5.C
new file mode 100644
index 00000000000..0d58ea0b3f3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/access5.C
@@ -0,0 +1,22 @@
+// Build don't link:
+
+class A
+{
+protected:
+  int i;     
+};
+
+class B : private A
+{
+protected:
+  A::i;
+};
+
+struct C : public B {
+  friend int f(C *p);
+};
+
+int f(C *p) {
+  return p->i;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/access6.C b/gcc/testsuite/g++.old-deja/g++.other/access6.C
new file mode 100644
index 00000000000..7a7c7ff5941
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/access6.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+template <int I>
+struct S {
+  void g();
+};
+
+class C {
+  static const int i = 3; // gets bogus error - private - XFAIL *-*-*
+public:
+  S<C::i>* f(); // gets bogus error - redeclared - XFAIL *-*-*
+};
+
+S<C::i>* C::f() { // gets bogus error - private - XFAIL *-*-*
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/addrof1.C b/gcc/testsuite/g++.old-deja/g++.other/addrof1.C
new file mode 100644
index 00000000000..b4d55f6a21b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/addrof1.C
@@ -0,0 +1,30 @@
+typedef struct st {
+        unsigned char   a;
+        unsigned char   b;
+        unsigned char   c;
+        unsigned char   d;
+} __attribute__((aligned(4))) st;
+
+void testme(int, int, int);
+
+static inline void
+stupid_func(st s)
+{
+        testme(s.a, s.b, s.c);
+}
+
+int main()
+{
+        st s;
+
+        s.a = s.b = s.c = 216;
+        stupid_func(s);
+
+        return 0;
+}    
+
+void testme(int a, int b, int c)
+{
+  if (a != 216 || b != 216 || c != 216)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/ambig1.C b/gcc/testsuite/g++.old-deja/g++.other/ambig1.C
new file mode 100644
index 00000000000..d6574a2b79c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/ambig1.C
@@ -0,0 +1,28 @@
+// Build don't link:
+
+struct A {
+  int operator ++(); // ERROR - candidates
+  void operator ()(); // ERROR - candidates
+  void operator delete(void*); // ERROR - candidates
+};
+
+struct B {
+  int operator ++(int); // ERROR - candidates
+  void operator ()(); // ERROR - candidates
+  void operator delete(void*); // ERROR - candidates
+  void f();
+};
+
+struct C : public A, public B {
+};
+
+void f()
+{
+  C c;
+  C* cp;
+  
+  delete cp; // ERROR - ambiguous
+  c(); // ERROR - ambiguous
+  c++; // ERROR - ambiguous
+}
+  
diff --git a/gcc/testsuite/g++.old-deja/g++.other/anon1.C b/gcc/testsuite/g++.old-deja/g++.other/anon1.C
new file mode 100644
index 00000000000..87948481d2b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/anon1.C
@@ -0,0 +1,6 @@
+// Build don't link:
+
+static union {
+  union {
+  };
+}; // ERROR - anonymous union with no members
diff --git a/gcc/testsuite/g++.old-deja/g++.other/anon2.C b/gcc/testsuite/g++.old-deja/g++.other/anon2.C
new file mode 100644
index 00000000000..49a7b2c35d6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/anon2.C
@@ -0,0 +1,31 @@
+extern "C" void abort (void);
+
+static union { 
+  int x1; 
+  long x2; 
+  short x3;
+  long x4;
+};
+
+static union {
+  union {
+    union {
+      int z;
+    };
+  };
+  union {
+    union {
+      double d;
+      int i;
+    };
+  };
+};
+
+
+int main()
+{
+  z = 3;
+  if (i != 3)
+    abort ();
+  d = 2.5;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/array1.C b/gcc/testsuite/g++.old-deja/g++.other/array1.C
new file mode 100644
index 00000000000..0ecba7778aa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/array1.C
@@ -0,0 +1,26 @@
+int i;
+
+struct S {
+  S (int) {
+    ++i;
+    if (i == 3)
+      throw 3;
+  };
+
+  S () {}
+
+  ~S() {
+    --i;
+  }
+};
+
+int main()
+{
+  try {
+    S s[5] = { 0, 1, 2, 3, 4 };
+  } catch (...) {
+  }
+
+  if (i != 1)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/array2.C b/gcc/testsuite/g++.old-deja/g++.other/array2.C
new file mode 100644
index 00000000000..255d8cce2d3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/array2.C
@@ -0,0 +1,18 @@
+int i;
+
+struct S {
+  S () {
+    ++i;
+  };
+
+  S (int) {
+  };
+};
+
+int main()
+{
+  S s[3][3] = { 2 };
+
+  if (i != 8)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/badarrow.C b/gcc/testsuite/g++.old-deja/g++.other/badarrow.C
new file mode 100644
index 00000000000..e5946fd7768
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/badarrow.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+struct S { 
+  int i;
+} s;
+
+void f()
+{
+  s->i = 3; // ERROR - base operand
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/badopt1.C b/gcc/testsuite/g++.old-deja/g++.other/badopt1.C
new file mode 100644
index 00000000000..096770e77ad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/badopt1.C
@@ -0,0 +1,15 @@
+// Based on a testcase by Bryan Weston <bryanw@bluemoon.sps.mot.com>
+// egcs 1.1 fails to increment count
+
+#include <cstdlib>
+
+struct Base { Base() {} }; // removing the constructor fixes the problem
+struct Derived : Base {}; // so does removing the base class
+
+int main() {
+  int count = 0;
+  Derived* array[1]; // making this Base*[1] does not fix the problem
+  array[count++] = new Derived (); // but then new Base() does
+  if (count!=1)
+    std::abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/bitfld1.C b/gcc/testsuite/g++.old-deja/g++.other/bitfld1.C
new file mode 100644
index 00000000000..ad21fd7fb85
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/bitfld1.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Based on a bug report by Stephen Vavasis <vavasis@CS.Cornell.EDU>
+
+// excess errors test - XFAIL *-*-*
+
+// declares template operator!=
+#include <utility>
+
+struct foo {
+  enum e { bar } baz:1;
+  void test() { 
+    baz != bar;
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/cast1.C b/gcc/testsuite/g++.old-deja/g++.other/cast1.C
new file mode 100644
index 00000000000..7cd805975aa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/cast1.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+struct S0 { };
+struct S1 : virtual public S0 { };
+struct S2 : virtual public S0 { };
+
+struct S3 : public S1, public S2, virtual public S0
+{
+};
+
+void f(const S0*) {}
+
+void g()
+{
+  f(static_cast<S3*>(0));
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/cast2.C b/gcc/testsuite/g++.old-deja/g++.other/cast2.C
new file mode 100644
index 00000000000..80cf7dc1864
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/cast2.C
@@ -0,0 +1,17 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+struct A {
+};
+
+int main()
+{
+  A a;
+  typedef void (A::*F)();
+  F p;
+
+  const_cast<const A>(a); // ERROR - const_cast requires pointer/ref types
+  const_cast<F>(p); // ERROR - const_cast requires pointer/ref types
+  const_cast<int (*)()>(&main); // ERROR - function type in const_cast
+  const_cast<int (&)()>(main); // ERROR - function type in const_cast
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/cleanup1.C b/gcc/testsuite/g++.old-deja/g++.other/cleanup1.C
new file mode 100644
index 00000000000..fd4dc6e4db0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/cleanup1.C
@@ -0,0 +1,20 @@
+// Bug: fold is too eager about pushing down CLEANUP_POINT_EXPR.
+
+int d;
+
+struct A {
+  A() { }
+  ~A() { d = 1; }
+};
+
+int f (const A& a)
+{
+  return 1;
+}
+
+int main ()
+{
+  if (f (A()) && d == 0)
+    return 0;
+  return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/cleanup2.C b/gcc/testsuite/g++.old-deja/g++.other/cleanup2.C
new file mode 100644
index 00000000000..4cd0b55e43d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/cleanup2.C
@@ -0,0 +1,26 @@
+// Origin: Bryan Scattergood <bryan@fsel.com>
+// Special g++ Options: -O -fno-exceptions
+
+extern "C" void abort();
+
+class A
+{
+public:
+  A();
+  ~A();
+  int foo();
+};
+
+A::A() {}
+A::~A() { abort (); }
+int A::foo() {}
+
+extern int f()
+{
+  return 0;
+}
+
+int main()
+{
+  return ((f() != 0) ? A().foo() : 0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/configure.in b/gcc/testsuite/g++.old-deja/g++.other/configure.in
new file mode 100644
index 00000000000..e198b4f0d45
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=g++-03.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/g++.old-deja/g++.other/const1.C b/gcc/testsuite/g++.old-deja/g++.other/const1.C
new file mode 100644
index 00000000000..7c26da1aea3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/const1.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+struct S
+{
+  void f()
+    {
+      const int i; // ERROR - uninitialized const
+    }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/const2.C b/gcc/testsuite/g++.old-deja/g++.other/const2.C
new file mode 100644
index 00000000000..90b70d16619
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/const2.C
@@ -0,0 +1,5 @@
+// Build don't link:
+
+struct S {
+  static const char* cp = "abc"; // ERROR - initialization of non-const
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/conv1.C b/gcc/testsuite/g++.old-deja/g++.other/conv1.C
new file mode 100644
index 00000000000..a558c5eba64
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/conv1.C
@@ -0,0 +1,6 @@
+// Build don't link:
+
+class X {
+public:
+  const operator int (); // ERROR - invalid declaration.
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/conv2.C b/gcc/testsuite/g++.old-deja/g++.other/conv2.C
new file mode 100644
index 00000000000..e713304c575
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/conv2.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Special g++ Options: -pedantic-errors
+
+void cheat( int* i ) { ++(*i); }
+ 
+struct t {
+        void cheat( int& i ) { ++i; }
+};
+
+int main()
+{
+  void (t::*member)( const int& ) = &t::cheat; // ERROR - conversion
+  void (*cheater)( const int* ) = &cheat; // ERROR - converting
+  t t2;
+  const int i=1;
+  int j=1;
+  (t2.*member)( i );
+  (t2.*member)( j );
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/conv3.C b/gcc/testsuite/g++.old-deja/g++.other/conv3.C
new file mode 100644
index 00000000000..7690f56ee94
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/conv3.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+// submitted by David C Binderman <dcb@pncl.co.uk>
+
+typedef const int ci;
+typedef ci aci[ 10];
+aci var = { 2, 3, 5, 7, 11, 13 };
+
+void
+f()
+{
+	int * ip = var;	// ERROR - requires const_cast
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/conv4.C b/gcc/testsuite/g++.old-deja/g++.other/conv4.C
new file mode 100644
index 00000000000..0ed0ee86563
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/conv4.C
@@ -0,0 +1,17 @@
+// Testcase for proper hiding of base conversion ops.
+
+struct A
+{
+  operator const char *();
+};
+
+struct B : public A
+{
+  operator const char *() { return 0; }
+};
+
+int main( void )
+{
+  B b;
+  const char *p = b;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/conv5.C b/gcc/testsuite/g++.old-deja/g++.other/conv5.C
new file mode 100644
index 00000000000..97bf23889a9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/conv5.C
@@ -0,0 +1,8 @@
+// Build don't link:
+
+// Based on bug report by Thomas Kunert <kunert@physik.tu-dresden.de>
+
+// Special g++ Options:
+
+int foo();
+const int (*bar)() = foo; // ERROR - adding const - XFAIL *-*-*
diff --git a/gcc/testsuite/g++.old-deja/g++.other/conv6.C b/gcc/testsuite/g++.old-deja/g++.other/conv6.C
new file mode 100644
index 00000000000..918e69742d8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/conv6.C
@@ -0,0 +1,28 @@
+// Test for composite pointer types, as defined in [expr.rel],
+// and common pointer to member types, as defined in [expr.eq].
+
+struct A { int i; };
+struct B : public A { };
+
+int main ()
+{
+  B b;
+
+  // The composite type is `A const *'
+        A* ap = &b;
+  const B* bp = &b;
+  if (ap != bp)		// gets bogus error - distinct types XFAIL *-*-*
+    return 1;
+
+  // The composite type is `B const *const *'
+  B       *const * p = 0;
+  B const *      * q = 0;
+  if (p != q)		// gets bogus error - distinct types XFAIL *-*-*
+    return 1;
+
+  // The common type is `int const B::*'
+  const int A::*apm = &A::i;
+        int B::*bpm = &A::i;
+  if (apm != bpm)	// gets bogus error - distinct types XFAIL *-*-*
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/copy1.C b/gcc/testsuite/g++.old-deja/g++.other/copy1.C
new file mode 100644
index 00000000000..5cc68a5623e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/copy1.C
@@ -0,0 +1,25 @@
+// Bug: expand_vec_init doesn't copy arrays of builtin types.
+
+struct B {
+  B() { }
+  B(const B&) { }
+};
+
+struct A
+{
+  B b;
+  int ar[5];
+};
+
+int main()
+{
+  A a;
+  for (int i = 0; i < 5; ++i)
+    a.ar[i] = i;
+
+  A a2 = a;
+
+  for (int i = 0; i < 5; ++i)
+    if (a2.ar[i] != a.ar[i])
+      return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/crash1.C b/gcc/testsuite/g++.old-deja/g++.other/crash1.C
new file mode 100644
index 00000000000..f7caa2f00ba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/crash1.C
@@ -0,0 +1,6 @@
+class A
+{
+        enum B { ONE, TWO, THREE };
+};
+
+class A::B; // ERROR - A::B is not a class type
diff --git a/gcc/testsuite/g++.old-deja/g++.other/crash2.C b/gcc/testsuite/g++.old-deja/g++.other/crash2.C
new file mode 100644
index 00000000000..93e0a6e3bcc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/crash2.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+struct A {
+  int rep;
+  static const A a(0); // ERROR - initialization
+  static const A b = 3; // ERROR - initialization
+  static const A& c = 2; // ERROR - initialization
+  A(int x) : rep(x) {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/crash3.C b/gcc/testsuite/g++.old-deja/g++.other/crash3.C
new file mode 100644
index 00000000000..01148434535
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/crash3.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Special g++ Options: -g -O2
+
+inline void f() {
+  struct S {};
+  S s;
+}
+
+int g()
+{
+  for (int i = 0; i < 2; ++i)
+    f();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/crash4.C b/gcc/testsuite/g++.old-deja/g++.other/crash4.C
new file mode 100644
index 00000000000..d86a6bb3f66
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/crash4.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+struct T {
+  struct S __attribute__ ((packed)) { // ERROR - parse error
+    int i;                            
+  };
+}; // ERROR - parse error
diff --git a/gcc/testsuite/g++.old-deja/g++.other/crash5.C b/gcc/testsuite/g++.old-deja/g++.other/crash5.C
new file mode 100644
index 00000000000..761ec0d960f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/crash5.C
@@ -0,0 +1,21 @@
+// Build don't link:
+
+class TecMesh {};
+
+extern TecMesh& m;
+
+struct X { 
+  X(TecMesh&);
+};
+
+struct D  {
+  D();
+  TecMesh& Mesh;
+};
+
+
+D::D ()
+  : Mesh(m)
+{
+  X x(D::Mesh);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/crash6.C b/gcc/testsuite/g++.old-deja/g++.other/crash6.C
new file mode 100644
index 00000000000..498c9833501
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/crash6.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Special g++ Options: -O2
+
+struct E
+{
+  int f(int);
+};
+
+int ha()
+{
+  enum {X = 0};
+
+  int A, C;
+
+  E vList[10];
+
+  A = (C + 1) % 3;
+  vList[1].f(A);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/crash7.C b/gcc/testsuite/g++.old-deja/g++.other/crash7.C
new file mode 100644
index 00000000000..0f581988b1f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/crash7.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+void f() 
+{
+  union {
+  private:
+    int i; // ERROR - private
+  } u;
+
+  u.i = 3; // ERROR - within this context
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/crash8.C b/gcc/testsuite/g++.old-deja/g++.other/crash8.C
new file mode 100644
index 00000000000..22b27ef9b12
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/crash8.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// Origin: Jason Merrill <jason@cygnus.com>
+
+int main()
+{
+  void f();
+  class A {
+    friend void f();
+  };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/crash9.C b/gcc/testsuite/g++.old-deja/g++.other/crash9.C
new file mode 100644
index 00000000000..d3c23977abf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/crash9.C
@@ -0,0 +1,9 @@
+// Build don't link:
+// Origin: Jason Merrill <jason@cygnus.com>
+
+struct A { };
+struct B : public A
+{
+  int A;
+};
+struct C : public B { };
diff --git a/gcc/testsuite/g++.old-deja/g++.other/cvt1.C b/gcc/testsuite/g++.old-deja/g++.other/cvt1.C
new file mode 100644
index 00000000000..f448cc1a31b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/cvt1.C
@@ -0,0 +1,23 @@
+// Build don't link:
+
+typedef int Array_T[2];
+
+struct S1 {
+  S1(const Array_T&);
+};
+
+struct S2 {
+  S1 g();
+  Array_T a;
+};
+
+S1 S2::g()
+{
+  return S1(a);
+}
+
+void h()
+{
+  S2 s2;
+  s2.g();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dcast1.C b/gcc/testsuite/g++.old-deja/g++.other/dcast1.C
new file mode 100644
index 00000000000..d9dd6575aec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dcast1.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+class C {
+public:
+  virtual void f();
+};
+
+extern volatile C* cp;
+extern volatile C& cr;
+
+void f ()
+{
+  dynamic_cast<void*>(cp); // ERROR - cannot dynamic_cast
+  dynamic_cast<C&>(cr); // ERROR - cannot dynamic_cast
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dcast2.C b/gcc/testsuite/g++.old-deja/g++.other/dcast2.C
new file mode 100644
index 00000000000..bd343a7e61d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dcast2.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+// Based on a testcase by Ruslan Shevchenko <Ruslan@Shevchenko.Kiev.UA>
+
+struct B {
+  virtual ~B();
+};
+
+struct D : public B {
+};
+
+void foo() {
+  B x;
+  dynamic_cast<D*>(&x); // WARNING - will never succeed
+  B* p = &x;
+  dynamic_cast<D*>(p);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/debug1.C b/gcc/testsuite/g++.old-deja/g++.other/debug1.C
new file mode 100644
index 00000000000..84858957a79
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/debug1.C
@@ -0,0 +1,48 @@
+// Build don't link:
+// Special g++ Options: -g
+
+typedef unsigned int size_t;
+
+
+struct dummy { };
+
+struct arrrrrgh { };
+
+
+template<class Par,class Rand = arrrrrgh>
+struct whyyyyyyy { };	 
+
+
+
+
+template<class T, class S =dummy> 
+struct grrrrrrrr { };         
+
+
+template<class Par, class Par2 =Par, class Rand =arrrrrgh>
+class no_future
+{
+public:
+
+   
+  template<class S>
+  no_future(const grrrrrrrr<whyyyyyyy<Par,Rand>*,S>& man )  { }
+
+  ~no_future( ) { }
+
+private:
+
+   
+  no_future(const no_future&);
+  no_future& operator=(const no_future&);
+};	 
+ 
+
+int main( )
+{
+  grrrrrrrr<whyyyyyyy<double>*> man;
+
+  no_future<double> here(man);
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/debug2.C b/gcc/testsuite/g++.old-deja/g++.other/debug2.C
new file mode 100644
index 00000000000..200aeb3cffc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/debug2.C
@@ -0,0 +1,31 @@
+// Build don't link:
+// Special g++ Options: -funroll-loops -O2 -g
+
+inline void f()
+{
+  typedef int T;
+}
+
+inline void g()
+{
+  typedef double U;
+}
+
+int n;
+
+struct B
+{
+  ~B() { 
+    for (int i = 0; i < n; ++i)
+      g(); 
+  }
+};
+
+struct D : public B {
+  ~D() { 
+    for (int j = 0; j < n; ++j)
+      f(); 
+  }
+};
+
+D d;
diff --git a/gcc/testsuite/g++.old-deja/g++.other/decl1.C b/gcc/testsuite/g++.old-deja/g++.other/decl1.C
new file mode 100644
index 00000000000..7a55ce0cdeb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/decl1.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// Based on a test case by Phil Blecker <tmwg@inxservices.com>
+
+// excess errors test - XFAIL *-*-*
+
+int foo(int);
+int bar() {
+  int baz(int(foo(0)));
+  int foo = baz;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/decl2.C b/gcc/testsuite/g++.old-deja/g++.other/decl2.C
new file mode 100644
index 00000000000..1da75406d9f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/decl2.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// Based on a test-case by Maciej Radziejewski <maciejr@iws.uni-stuttgart.de>
+
+int i(0)(1); // ERROR - multiple initialization
+int j(2) = 3; // ERROR - multiple initialization
+int k(4)(5)(6); // ERROR - multiple initialization
+int m, n(7)(8); // ERROR - multiple initialization
diff --git a/gcc/testsuite/g++.old-deja/g++.other/decl3.C b/gcc/testsuite/g++.old-deja/g++.other/decl3.C
new file mode 100644
index 00000000000..6068e3105dc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/decl3.C
@@ -0,0 +1,19 @@
+// Build don't link:
+
+// Origin:  Adapted by Nathan Sidwell 29 Apr 1999 <nathan@acm.org>
+//          from a test case submitted by Corey Kosak <kosak@cs.cmu.edu>
+//          http://egcs.cygnus.com/ml/egcs-bugs/1999-04/msg00502.html
+
+// We should not allow arrays of abstract type. [class.abstract/2]
+
+struct cow_t {
+  virtual void f()=0; // ERROR - abstract
+};
+
+
+int main()
+{
+  cow_t cow[2];  // ERROR - abstract class
+  cow[0].f();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/defarg1.C b/gcc/testsuite/g++.old-deja/g++.other/defarg1.C
new file mode 100644
index 00000000000..68b07a510cc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/defarg1.C
@@ -0,0 +1,28 @@
+// Build don't link:
+
+int f (int x)
+{
+  extern void g (int i = f (x)); // ERROR - default argument uses local
+  
+  g();
+
+  return 0;
+}
+
+int f (void);
+
+int h1 (int (*)(int) = f);
+int h2 (int (*)(double) = f); // ERROR - no matching f
+
+template <class T>
+int j (T t)
+{
+  extern void k (int i = j (t)); // ERROR - default argument uses local
+
+  k ();
+
+  return 0;
+}
+
+template int j (double); // ERROR - instantiated from here
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/defarg2.C b/gcc/testsuite/g++.old-deja/g++.other/defarg2.C
new file mode 100644
index 00000000000..edb0770c7d6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/defarg2.C
@@ -0,0 +1,15 @@
+// Test that default args don't mess up pmf type comparisons.
+// Contributed by Jason Merrill <jason@cygnus.com>.
+
+struct A {
+  void f (int = 0) { }
+};
+
+int
+main ()
+{
+  void (A::*p)(int) = 0;
+  p = &A::f;
+  if (p != &A::f)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/delete1.C b/gcc/testsuite/g++.old-deja/g++.other/delete1.C
new file mode 100644
index 00000000000..6386fe1883b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/delete1.C
@@ -0,0 +1,15 @@
+//Build don't link:
+struct cl_heap_ring{
+    void operator delete (void* ptr) { }
+    cl_heap_ring ()
+    { }
+};
+
+struct cl_heap_null_ring : public cl_heap_ring {
+    void operator delete (void* ptr) { }
+};
+
+void f()
+{
+  new cl_heap_null_ring();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/delete2.C b/gcc/testsuite/g++.old-deja/g++.other/delete2.C
new file mode 100644
index 00000000000..d90def03a3f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/delete2.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+struct foo {
+  operator char*() const;
+};
+
+void bar(foo a) {
+  delete a; // should be accepted
+  delete[] a; // should be accepted
+  char b[1];
+  delete b; // ERROR - expecting pointer type
+  delete[] b; // ERROR - expecting pointer type
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/delete3.C b/gcc/testsuite/g++.old-deja/g++.other/delete3.C
new file mode 100644
index 00000000000..eb56350371b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/delete3.C
@@ -0,0 +1,38 @@
+#include <new>
+
+int i;
+
+extern "C" void printf(const char*, ...);
+
+template <class T, class U> 
+struct map {
+  ~map ();
+};
+
+template <class T, class U>
+map<T, U>::~map ()
+{}
+
+struct SomeClass { };
+
+void* operator new(size_t numBytes, SomeClass&, const nothrow_t&) throw()
+{
+  return operator new(numBytes, nothrow);
+}
+
+void operator delete(void* pMemory, SomeClass&, const nothrow_t&) throw()
+{
+  i = 7;
+  return operator delete(pMemory);
+}
+
+int
+main()
+{
+  map< int, int>* pMap = new map< int, int>;
+  
+  delete pMap;
+  
+  if (i == 7)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/delete4.C b/gcc/testsuite/g++.old-deja/g++.other/delete4.C
new file mode 100644
index 00000000000..74ddcdd1545
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/delete4.C
@@ -0,0 +1,53 @@
+// Build don't link:
+
+// Copyright (C) 1999 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 15 Apr 1999 <nathan@acm.org>
+
+// delete (void *)e and delete[] (void *)e result in undefined behaviour
+// [expr.delete/3]. Check we warn about them
+// operator new functions can only return NULL, if their exceptions
+// specification is `throw()'. All other cases must return a non-null pointer
+// [expr.new/13].
+
+typedef __SIZE_TYPE__ size_t;
+
+void *operator new(size_t)
+{
+  return 0; // ERROR - cannot return NULL
+}
+void *operator new[](size_t)
+{
+  return 0; // ERROR - cannot return NULL
+}
+
+struct X
+{
+  void *operator new(size_t)
+  {
+    return 0; // ERROR - cannot return NULL
+  }
+  void *operator new[](size_t)
+  {
+    return 0; // ERROR - cannot return NULL
+  }
+};
+
+struct Y
+{
+  void *operator new(size_t) throw()
+  {
+    return 0; // ok
+  }
+  void *operator new[](size_t) throw()
+  {
+    return 0; // ok
+  }
+};
+
+void fn(double *d, void *v)
+{
+  delete d;   // ok
+  delete v;   // WARNING - deleting void
+  delete[] d; // ok
+  delete[] v; // WARNING - deleting void
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/delete5.C b/gcc/testsuite/g++.old-deja/g++.other/delete5.C
new file mode 100644
index 00000000000..e9cc493d668
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/delete5.C
@@ -0,0 +1,41 @@
+// Copyright (C) 1999 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 15 Apr 1999 <nathan@acm.org>
+
+typedef __SIZE_TYPE__ size_t;
+
+struct X
+{
+  int i;
+  
+  X():i(){}
+  void *operator new(size_t)
+  {
+    return 0; // WARNING - cannot return NULL
+  }
+  void *operator new[](size_t)
+  {
+    return 0; // WARNING - cannot return NULL
+  }
+};
+
+struct Y
+{
+  int i;
+  
+  Y():i(){}
+  void *operator new(size_t) throw()
+  {
+    return 0; // ok
+  }
+  void *operator new[](size_t) throw()
+  {
+    return 0; // ok
+  }
+};
+
+int main()
+{
+  Y *yp = new Y;
+  
+  return yp != 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dll-1.C b/gcc/testsuite/g++.old-deja/g++.other/dll-1.C
new file mode 100644
index 00000000000..0c66b7faf4b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dll-1.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// Special g++ Options: -mno-nop-fun-dllimport
+// Skip if not target: arm-*pe
+// declspec test #1
+// set compiler_result "__imp_imp.*\.section${spaces}.drectve\n\[^\n\]*-export:exp"
+// set not_compiler_result "__imp_exp"
+
+__declspec (dllimport) void imp ();
+
+__declspec (dllexport) void exp () { imp (); }
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dll-2.C b/gcc/testsuite/g++.old-deja/g++.other/dll-2.C
new file mode 100644
index 00000000000..f5c7b2eb8e8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dll-2.C
@@ -0,0 +1,19 @@
+// Skip if not target: arm-*pe
+// Build don't link:
+// Microsoft's MSVC 2.0 allows dllimport followed by dllexport for variables,
+// but does not allow dllexport followed by dllimport.
+//
+// Switching between dll{export,import} works for functions.
+// We test for that too (by ensuring no error is produced).
+
+__declspec (dllimport) int foo1 ();
+__declspec (dllexport) int foo1 ();
+
+__declspec (dllexport) int foo2 ();
+__declspec (dllimport) int foo2 ();
+
+__declspec (dllimport) int bar1;
+__declspec (dllexport) int bar1;
+
+__declspec (dllexport) int bar2; // ERROR - previously declared
+__declspec (dllimport) int bar2; // ERROR - redefinition
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dll-3.C b/gcc/testsuite/g++.old-deja/g++.other/dll-3.C
new file mode 100644
index 00000000000..469ea1c6b78
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dll-3.C
@@ -0,0 +1,17 @@
+// Build don't link:
+// Skip if not target: arm-*pe
+// Special g++ Options: -mno-nop-fun-dllimport
+// set compiler_result "__imp_f1.*\.section${spaces}.drectve\n\[^\n\]*-export:f2"
+// set not_compiler_result "__imp_f2"
+
+class aClass 
+{ 
+public: 
+  __declspec(dllimport) int f1(); 
+  __declspec(dllexport) int f2(); 
+}; 
+ 
+__declspec(dllexport) int aClass::f2() 
+{ 
+  return f1(); 
+} 
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dll-4.C b/gcc/testsuite/g++.old-deja/g++.other/dll-4.C
new file mode 100644
index 00000000000..322f003dbde
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dll-4.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Skip if not target: arm-*pe
+// Ensure dllexport overrides dllimport.
+// set compiler_result "\.section${spaces}\.drectve\n\[^\n\]*-export:foo1.*\.section${spaces}\.drectve\n\[^\n\]*-export:foo2"
+// set not_compiler_result "(__imp_foo1|__imp_foo2)"
+
+__declspec (dllimport) int foo1 ();
+__declspec (dllexport) int foo1 ();
+
+__declspec (dllexport) int foo2 ();
+__declspec (dllimport) int foo2 ();
+
+__declspec (dllexport) int foo1 () { return foo2 (); }
+__declspec (dllexport) int foo2 () { return foo1 (); }
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dll-5.C b/gcc/testsuite/g++.old-deja/g++.other/dll-5.C
new file mode 100644
index 00000000000..b2ad9f51bac
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dll-5.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// Skip if not target: arm-*pe
+// dllimport is "sorta like" to "extern".
+// set compiler_result "(\nfoo1:.*\nfoo2:|\nfoo2:.*\nfoo1:)"
+// set not_compiler_result "__imp_"
+
+__declspec (dllimport) int foo1;
+int foo1;
+
+__declspec (dllimport) int foo2;
+int foo2 = 5;
+
+int f () { return foo1 + foo2; }
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dll-6.C b/gcc/testsuite/g++.old-deja/g++.other/dll-6.C
new file mode 100644
index 00000000000..b4e0b42edbf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dll-6.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// Skip if not target: arm-*pe
+// set not_compiler_result "__imp_"
+// dll.h
+class aClass 
+    { 
+public: 
+    __declspec(dllimport) aClass(); 
+    }; 
+
+// dll.cpp
+
+__declspec(dllexport) aClass::aClass() 
+    { 
+    } 
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dtor1.C b/gcc/testsuite/g++.old-deja/g++.other/dtor1.C
new file mode 100644
index 00000000000..3f9803c39a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dtor1.C
@@ -0,0 +1,17 @@
+// Test for use of typedef in explicit destructor call.
+
+#include <new>
+
+struct X {
+  typedef X foo;
+};
+
+X x;
+unsigned char bar[sizeof (X)];
+
+int
+main ()
+{
+  X* p = new (bar) X;
+  p->~foo();
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dtor2.C b/gcc/testsuite/g++.old-deja/g++.other/dtor2.C
new file mode 100644
index 00000000000..201068c415b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dtor2.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+class K {
+public:
+  friend class C;
+
+private:
+  static K qwe;
+  K();
+  ~K();
+}; 
+
+K K::qwe;
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dtor3.C b/gcc/testsuite/g++.old-deja/g++.other/dtor3.C
new file mode 100644
index 00000000000..a2ad16dfdb3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dtor3.C
@@ -0,0 +1,51 @@
+// Build don't link:
+
+struct S1
+{
+  ~S1(int); // ERROR - destructors may not have parameters
+};
+
+
+template <class T>
+struct S2
+{
+  ~S2(int); // ERROR - destructors may not have parameters
+};
+
+
+struct S3 
+{
+  ~S3(double) {} // ERROR - destructors may not have parameters
+};
+
+
+template <class T>
+struct S4
+{
+  ~S4(double) {} // ERROR - destructors may not have parameters
+};
+
+
+struct S5
+{
+  ~S5(); 
+};
+
+S5::~S5(float) 
+{ // ERROR - destructors may not have parameters
+}
+
+
+template <class T>
+struct S6
+{
+  ~S6();
+};
+
+template <class T>
+S6<T>::~S6(float)
+{ // ERROR - destructors may not have parameters
+}
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/dtor4.C b/gcc/testsuite/g++.old-deja/g++.other/dtor4.C
new file mode 100644
index 00000000000..f23ab782560
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/dtor4.C
@@ -0,0 +1,31 @@
+// Build don't link:
+
+struct S1 {
+  ~S1(); // ERROR - candidate
+};
+
+S1::~S1() const
+{ // ERROR - prototype does not match 
+}
+
+
+struct S2 {
+  ~S2() volatile; // ERROR - destructors may not be volatile
+};
+
+
+template <class T>
+struct S3 {
+  ~S3(); // ERROR - candidate
+};
+
+template <class T>
+S3<T>::~S3() volatile
+{ // ERROR - prototype does not match 
+}
+
+
+template <class T>
+struct S4 {
+  ~S4() const; // ERROR - destructors may not be const
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/elab1.C b/gcc/testsuite/g++.old-deja/g++.other/elab1.C
new file mode 100644
index 00000000000..614e73bac53
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/elab1.C
@@ -0,0 +1,9 @@
+typedef struct {} S;
+
+S s1;
+struct S* s2; // ERROR - S is a typedef name
+
+template <class T>
+struct X {
+  friend class T; // ERROR - T is a template type parameter
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/empty1.C b/gcc/testsuite/g++.old-deja/g++.other/empty1.C
new file mode 100644
index 00000000000..0789884079b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/empty1.C
@@ -0,0 +1,23 @@
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+extern "C" void abort();
+extern "C" void printf(const char*, ...);
+
+int i;
+
+struct A;
+
+struct A* as[10];
+
+struct A {
+  A () { as[i++] = this; }
+  A (const A&) { as[i++] = this; }
+  ~A() { if (i == 0 || as[--i] != this) abort(); }
+};
+
+A f() { return A(); }
+
+int main ()
+{
+  A a (f ());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/enum1.C b/gcc/testsuite/g++.old-deja/g++.other/enum1.C
new file mode 100644
index 00000000000..f692991a442
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/enum1.C
@@ -0,0 +1,15 @@
+extern "C" void abort();
+
+struct A
+{
+  enum { a = 3}* p;
+  int f() { return (int) a; }
+};
+
+int main()
+{
+  A a;
+
+  if (a.f() != 3)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/expr1.C b/gcc/testsuite/g++.old-deja/g++.other/expr1.C
new file mode 100644
index 00000000000..fece8d48c29
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/expr1.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+// Simplified from bug report by Trevor Taylor <ttaylor@powerup.com.au>
+
+struct T {
+  int operator()(int) { } // ERROR - candidate
+};
+
+int main() {
+  T()(); // ERROR - no such operator
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/field1.C b/gcc/testsuite/g++.old-deja/g++.other/field1.C
new file mode 100644
index 00000000000..e734830a1c4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/field1.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+struct X
+{
+  static const bool b = true;
+  static const int i = b ? 1 : 2;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/field2.C b/gcc/testsuite/g++.old-deja/g++.other/field2.C
new file mode 100644
index 00000000000..5eb67554fdf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/field2.C
@@ -0,0 +1,20 @@
+// Test for proper handling of field calls.
+// Contributed by Jason Merrill <jason@cygnus.com>
+
+struct A {
+  inline A* operator()() { return this; }
+};
+
+struct B {
+  int i;
+  union { A a; };
+};
+
+int
+main ()
+{
+  B b;
+  A* ap = &b.a;
+  A* ap2 = b.a();
+  return (ap != ap2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/for1.C b/gcc/testsuite/g++.old-deja/g++.other/for1.C
new file mode 100644
index 00000000000..31cd741a366
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/for1.C
@@ -0,0 +1,41 @@
+// Build don't link:
+
+int i;
+int j;
+
+struct S {
+  int operator()(int)
+    {
+      i = 1;
+    }
+
+  typedef int I;
+
+  void f() {
+    for (S I; false; )
+      ;
+    int k = I(3);
+  }
+};
+
+typedef int J;
+
+struct T {
+  int operator()(int)
+    {
+      j = 1;
+    }
+
+  void f() {
+    for (T J; false; )
+      ;
+    int k = J(3);
+  }
+};
+
+int main()
+{
+  S s;
+  s.f();
+  return 2 * i + j;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/friend1.C b/gcc/testsuite/g++.old-deja/g++.other/friend1.C
new file mode 100644
index 00000000000..76fcebe1fae
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/friend1.C
@@ -0,0 +1,85 @@
+// Build don't link:
+// f() should be able to access B::j, as of FDIS [class.protected]/1
+
+// Subject: Re: [bug] Inheritance and friend access control broken
+// References: <199803032141.WAA09332@piano.dptmaths.ens-cachan.fr>
+// <orhg5ff544.fsf@iguacu.dcc.unicamp.br>
+// <199803041125.MAA06937@cor.dptmaths.ens-cachan.fr>
+// <orn2f6ek92.fsf@iguacu.dcc.unicamp.br> <19980304102900.46897@dgii.com>
+// From: Alexandre Oliva <oliva@dcc.unicamp.br>
+// Date: 06 Mar 1998 01:43:18 -0300
+
+template <int*>
+class X {};
+
+template <typename T>
+void g();
+
+struct S;
+
+template <typename T>
+struct R;
+
+class B {
+protected:
+  int i; // ERROR - in this context
+  static int j;
+};
+
+class D : public B {
+  friend void f();
+  template <typename T>
+  friend void g();
+  friend struct S;
+  template <typename T>
+  friend struct R;
+};
+
+struct S {
+  void h();
+  X<&B::j> x;
+};
+
+template <typename T>
+struct R {
+  void h();
+  X<&B::j> x;
+};
+
+void f()
+{
+    ((B*)0)->i = 3; // ERROR - protected
+    ((D*)0)->i = 4;
+    B::j = 5;
+    D::j = 6;
+}
+
+template <typename T>
+void g()
+{
+    ((B*)0)->i = 3; // ERROR - protected
+    ((D*)0)->i = 4;
+    B::j = 5;
+    D::j = 6;
+}
+
+template void g<int>();
+
+void S::h()
+{
+  ((B*)0)->i = 3; // ERROR - protected
+  ((D*)0)->i = 4;
+  B::j = 5;
+  D::j = 6;
+}
+
+template <typename T>
+void R<T>::h() 
+{
+  ((B*)0)->i = 3; // ERROR - protected
+  ((D*)0)->i = 4;
+  B::j = 5;
+  D::j = 6;
+}
+
+template struct R<double>;
diff --git a/gcc/testsuite/g++.old-deja/g++.other/friend2.C b/gcc/testsuite/g++.old-deja/g++.other/friend2.C
new file mode 100644
index 00000000000..32a0a285fc6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/friend2.C
@@ -0,0 +1,19 @@
+// Build don't link:
+
+void
+f()
+{
+  class Local_2 {
+    friend class Friend;
+
+    int i;
+  };
+  
+  class Friend {
+  public:
+    void g() {
+      Local_2 l2;
+      l2.i = 3;
+    }
+  };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/friend3.C b/gcc/testsuite/g++.old-deja/g++.other/friend3.C
new file mode 100644
index 00000000000..84c6b2d3b7c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/friend3.C
@@ -0,0 +1,23 @@
+// Build don't link:
+
+class foo {
+public:
+    class bar;
+    void func(bar *);
+    class bar {
+      int st;
+      friend void foo::func(bar *);
+    };
+};
+
+
+void foo::func(bar *obj) {
+  obj->st++;
+}
+
+void test02() {
+  foo obj_f;
+  foo::bar obj_b;
+  
+  obj_f.func( &obj_b);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/friend4.C b/gcc/testsuite/g++.old-deja/g++.other/friend4.C
new file mode 100644
index 00000000000..07969cd5487
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/friend4.C
@@ -0,0 +1,23 @@
+// Build don't link:
+
+// by Alexandre Oliva <oliva@dcc.unicamp.br>
+
+// I'm not 100% sure this program is correct, but g++ shouldn't just
+// crash.
+
+// The idea is to give privileged access to bar<A> only to
+// specializations foo<A,B>, for all B.
+
+template <class A, class B> void foo();
+template <class C> class bar {
+  int i; // ERROR - private
+  template <class B> friend void foo<C,B>(); // ERROR - bogus declaration
+};
+template <class A, class B> void foo() {
+  bar<A> baz; baz.i = 1;   // ERROR - foo cannot access bar<int>::i
+  bar<int> buz; buz.i = 1; // ERROR - foo cannot access bar<int>::i
+}
+int main() {
+  foo<void,void>();
+  foo<int,void>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/friend5.C b/gcc/testsuite/g++.old-deja/g++.other/friend5.C
new file mode 100644
index 00000000000..ab15fa58c5b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/friend5.C
@@ -0,0 +1,5 @@
+// submitted by David C Binderman <dcb@pncl.co.uk>
+
+struct A {
+	friend bool();		// ERROR - invalid declaration
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/incomplete.C b/gcc/testsuite/g++.old-deja/g++.other/incomplete.C
new file mode 100644
index 00000000000..0c230c18777
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/incomplete.C
@@ -0,0 +1,5 @@
+// Build don't link:
+
+struct S;
+
+void f(S s) {} // ERROR - incomplete type
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init1.C b/gcc/testsuite/g++.old-deja/g++.other/init1.C
new file mode 100644
index 00000000000..a87f14bc4d3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init1.C
@@ -0,0 +1,10 @@
+extern "C" void abort();
+
+int i;
+int j = i++;
+
+int main()
+{
+  if (i != 1)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init10.C b/gcc/testsuite/g++.old-deja/g++.other/init10.C
new file mode 100644
index 00000000000..fa238132f3f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init10.C
@@ -0,0 +1,22 @@
+int i;
+
+struct D {
+  D () {
+    i++;
+  }
+};
+
+struct C {
+  C() {}
+    
+  D d[1];
+};
+
+
+int main ()
+{
+  C c;
+
+  if (i != 1)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init11.C b/gcc/testsuite/g++.old-deja/g++.other/init11.C
new file mode 100644
index 00000000000..79d7d6caa71
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init11.C
@@ -0,0 +1,38 @@
+// Check that elements for which no explicit initializer was given are
+// default-initialized properly.
+
+extern "C" int printf (const char *, ...);
+
+struct A
+{
+  int i;
+  A(): i (42) { }
+  A(int j): i(j) { }
+};
+
+A ar[4] = { 1, 2 };
+
+struct B
+{
+  A a1, a2, a3, a4;
+};
+
+B b = { 1, 2 };
+
+struct C
+{
+  A ar[4];
+};
+
+C c = { 1, 2 };
+
+int
+main ()
+{
+  printf ("%d %d %d %d\n%d %d %d %d\n%d %d %d %d\n",
+	  ar[0].i, ar[1].i, ar[2].i, ar[3].i,
+	  b.a1.i, b.a2.i, b.a3.i, b.a4.i,
+	  c.ar[1-1].i, c.ar[2-1].i, c.ar[3-1].i, c.ar[4-1].i);
+
+  return (b.a4.i != 42 || c.ar[3].i != 42);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init12.C b/gcc/testsuite/g++.old-deja/g++.other/init12.C
new file mode 100644
index 00000000000..ee0a029253a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init12.C
@@ -0,0 +1,22 @@
+// Build don't run:
+// Special g++ Options: -O3
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+typedef int (*fp)();
+ 
+struct S
+{
+  fp f;
+};
+
+struct T
+{
+  static int f() {}
+};
+
+static const S s = { &T::f };
+
+int main()
+{
+  return (*s.f)();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init13.C b/gcc/testsuite/g++.old-deja/g++.other/init13.C
new file mode 100644
index 00000000000..1213a5c5622
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init13.C
@@ -0,0 +1,13 @@
+// Build don't run:
+// Special g++ Options: -O3
+// Origin: Gabriel Dos_Reis <Gabriel.Dos_Reis@sophia.inria.fr>
+
+void f() {}
+
+struct X {
+    ~X() { f (); }
+};
+
+X x;
+
+int main () {}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init2.C b/gcc/testsuite/g++.old-deja/g++.other/init2.C
new file mode 100644
index 00000000000..c17427a7643
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init2.C
@@ -0,0 +1,20 @@
+// Special g++ Options: -O3
+
+typedef int (*fp)();
+
+struct S
+{
+  fp f;
+};
+
+static int f()
+{
+  return 0;
+}
+
+static const S s = { &f };
+
+int main()
+{
+  return (*s.f)();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init3.C b/gcc/testsuite/g++.old-deja/g++.other/init3.C
new file mode 100644
index 00000000000..a4c6e761e66
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init3.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+struct X
+{ 
+  static const bool   is_signed  =  true  ;
+  static const int digits = is_signed ? 8 *sizeof(wchar_t)-1 : 0;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init4.C b/gcc/testsuite/g++.old-deja/g++.other/init4.C
new file mode 100644
index 00000000000..9bc473fb9d7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init4.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+class error {
+public:
+  error(int) {}
+};
+
+class foo {
+  const error x = 1; // ERROR - initialization of non-static data member
+};
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init5.C b/gcc/testsuite/g++.old-deja/g++.other/init5.C
new file mode 100644
index 00000000000..3f4785e360e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init5.C
@@ -0,0 +1,27 @@
+// Objects must be destructed in decreasing cnt order
+// Original test attributed to James Kanze <jkanze@otelo.ibmmail.com>
+// execution test - XFAIL *-*-*
+
+static int cnt;
+
+class A {
+  int myCnt;
+public:
+  A() : myCnt(cnt++) {}
+  ~A() { if (--cnt != myCnt) abort(); }
+};
+
+void f() { static A a; /* a.myCnt == 1 */ }
+
+class B {
+  int myCnt;
+public:
+  B() : myCnt(cnt+1) { f(); ++cnt; }
+  ~B() { if (--cnt != myCnt) abort(); }
+};
+
+static A a1; // a1.myCnt == 0
+static B b1; // b1.myCnt == 2
+static A a2; // a2.myCnt == 3
+
+int main() {}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init6.C b/gcc/testsuite/g++.old-deja/g++.other/init6.C
new file mode 100644
index 00000000000..a684ae10740
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init6.C
@@ -0,0 +1,12 @@
+// Test for default-initialization of POD-structs in functional cast notation.
+
+struct foo { int a[10]; };
+
+int main()
+{
+  foo f = foo();
+  int r = 0;
+  for (int i = 0; i < 10; ++i)
+    r |= f.a[i];
+  return r;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init7.C b/gcc/testsuite/g++.old-deja/g++.other/init7.C
new file mode 100644
index 00000000000..3b17da029e8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init7.C
@@ -0,0 +1,28 @@
+// simplified from testcase in Windows Developer Journal,
+// submitted by eyal.ben-david@aks.com
+
+// The initialization of a static local variable must be retried if a
+// previous try finished by throwing an exception [stmt.dcl]/4
+
+struct foo {
+  foo() { throw true; }
+};
+
+void bar() {
+  static foo baz;
+}
+
+int main() {
+  try {
+    bar(); // must throw
+  }
+  catch (bool) {
+    try {
+      bar(); // must throw again!
+    }
+    catch (bool) {
+      return 0;
+    }
+  }
+  abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init8.C b/gcc/testsuite/g++.old-deja/g++.other/init8.C
new file mode 100644
index 00000000000..80df498e6e1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init8.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+// submitted by David C Binderman <dcb@pncl.co.uk>
+
+// According to [dcl.init]/9, this should be ill-formed
+
+void
+f()
+{
+  const int var [ 10 ]; // ERROR - missing initializer 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/init9.C b/gcc/testsuite/g++.old-deja/g++.other/init9.C
new file mode 100644
index 00000000000..5626174bbe4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/init9.C
@@ -0,0 +1,40 @@
+// Build don't link:
+
+// Based on a testcase submitted by Tudor Hulubei <tudor@cs.unh.edu>
+
+// X is not a POD because it has a user-defined destructor.
+// Therefore, we can't cross its initialization.
+
+// vector<int> is not even an aggregate; nevertheless, no error is
+// reported...
+
+struct A {
+  A() {}
+};
+
+void a() {
+  goto bar; // ERROR - jump from here
+  A x; // ERROR - jump crosses initialization
+ bar: // ERROR - jump to here
+  ;
+}
+
+struct X {
+  ~X() {}
+};
+
+void b() {
+  goto bar; // ERROR - jump from here
+  X x; // ERROR - jump crosses initialization
+ bar: // ERROR - jump to here
+  ;
+}
+
+#include <vector>
+
+void c() {
+  goto bar; // ERROR - jump from here
+  vector<int> x; // ERROR - jump crosses initialization
+ bar: // ERROR - jump to here
+  ;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lineno1.C b/gcc/testsuite/g++.old-deja/g++.other/lineno1.C
new file mode 100644
index 00000000000..ab003e0ff95
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lineno1.C
@@ -0,0 +1,14 @@
+// Submitted by Nathan Sidwell <nathan@acm.org>
+// Bug: g++ was giving the wrong line number for statics.
+// Special g++ Options: -w
+
+class A
+{
+  A();				// ERROR - private
+  ~A();				// ERROR - private
+};
+
+static A a;			// ERROR - here
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lineno2.C b/gcc/testsuite/g++.old-deja/g++.other/lineno2.C
new file mode 100644
index 00000000000..4d64d1abf1a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lineno2.C
@@ -0,0 +1,14 @@
+// Submitted by Nathan Sidwell <nathan@acm.org>
+// Bug: g++ wasn't listing candidates for a failed conversion.
+
+void f(int, double);		// ERROR - candidate
+void f(double, int);		// ERROR - candidate
+void f(int);			// ERROR - candidate
+
+int
+main ()
+{
+  void (*ptr)(int, int);
+  
+  ptr = &f;			// ERROR - no match
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/linkage1.C b/gcc/testsuite/g++.old-deja/g++.other/linkage1.C
new file mode 100644
index 00000000000..65a2848a2b1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/linkage1.C
@@ -0,0 +1,14 @@
+typedef struct {
+  int i;
+} *p;
+
+void f (p) { }			// ERROR - function uses anonymous type
+p q;
+
+int main()
+{
+  extern p j;
+  struct A { int j; };
+  extern A a;			// ERROR - extern uses local type
+  extern void f (A);		// ERROR - extern uses local type
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/linkage2.C b/gcc/testsuite/g++.old-deja/g++.other/linkage2.C
new file mode 100644
index 00000000000..c9b6e2a3d62
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/linkage2.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// From: Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de>    
+extern "C" 
+{
+typedef struct {int dummy[10];} *GDBM_FILE;
+extern GDBM_FILE gdbm_open();
+}
+
+typedef struct { int dummy[10]; } *FAIL_FILE;
+extern FAIL_FILE fail_open(); // ERROR - non-local function
+
+typedef struct { int dummy[10]; } *SUCCESS_FILE, S;
+extern SUCCESS_FILE success_open();
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/local1.C b/gcc/testsuite/g++.old-deja/g++.other/local1.C
new file mode 100644
index 00000000000..d0ed4f04e2e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/local1.C
@@ -0,0 +1,13 @@
+// Build don't run:
+
+struct Outer {
+  virtual ~Outer() {}
+};
+
+int
+main()
+{
+  { struct Inner : virtual public Outer {} inner; }
+  { struct Inner : virtual public Outer {} inner; }
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/local2.C b/gcc/testsuite/g++.old-deja/g++.other/local2.C
new file mode 100644
index 00000000000..2d17b33e601
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/local2.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// Special g++ Options: -O2
+
+void f ()
+{
+  struct Init {
+    Init () {
+    }
+  };
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup1.C b/gcc/testsuite/g++.old-deja/g++.other/lookup1.C
new file mode 100644
index 00000000000..f3ea5ebbb72
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup1.C
@@ -0,0 +1,9 @@
+// simple test for id from base class during class defn
+// Build don't link:
+
+struct foo {
+  enum { blah = 1 };
+};
+struct bar : public foo {
+  char cache[blah];
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup10.C b/gcc/testsuite/g++.old-deja/g++.other/lookup10.C
new file mode 100644
index 00000000000..da2b485c5d3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup10.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+struct A {
+  struct B {
+    static int i;
+  };
+  enum { a };
+};
+
+int A::B::i = a;
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup11.C b/gcc/testsuite/g++.old-deja/g++.other/lookup11.C
new file mode 100644
index 00000000000..61a6e91d545
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup11.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+namespace A {
+  int i;
+}
+using namespace A;
+namespace B {
+  int i;
+}
+using namespace B;
+
+int i;
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup12.C b/gcc/testsuite/g++.old-deja/g++.other/lookup12.C
new file mode 100644
index 00000000000..5c3143cdf33
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup12.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+struct B {
+  struct X {};
+};
+
+
+struct D : public B {
+  void X();
+
+  struct X x;
+
+  void f();
+};
+
+
+void D::f() 
+{
+  struct X y;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup13.C b/gcc/testsuite/g++.old-deja/g++.other/lookup13.C
new file mode 100644
index 00000000000..0c1e5460c4f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup13.C
@@ -0,0 +1,18 @@
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+int main() 
+{
+  typedef double I;
+ 
+  struct S1 {
+    typedef char I;
+    
+    struct S2;
+  };
+  
+  struct S1::S2 {
+    typedef I J;
+  };
+ 
+  return !(sizeof (S1::S2::J) == 1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup14.C b/gcc/testsuite/g++.old-deja/g++.other/lookup14.C
new file mode 100644
index 00000000000..5c81c44815a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup14.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+union U {
+  typedef int I;
+
+  struct S {
+    void f();
+  };
+};
+
+void U::S::f() {
+  I i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup15.C b/gcc/testsuite/g++.old-deja/g++.other/lookup15.C
new file mode 100644
index 00000000000..be9096a3be1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup15.C
@@ -0,0 +1,37 @@
+// Build don't link:
+// Origin: Benjamin Kosnik <bkoz@cygnus.com>
+
+class b
+{
+  int j;
+public:
+  b(int a = 6): j(a) {}
+  void imbue(int a) {++j;}
+};
+
+class d: public b
+{
+  int k;
+public:
+  d(int a = 7): b(a), k(a) {}
+  void imbue(int a) {++k;}
+};
+  
+//virtual public kills, public ok
+class mostd: virtual public d
+{
+  int l;
+public:
+  mostd(int a = 9): d(a), l(a) {}
+};
+
+int main() {
+
+  d dobj;
+  dobj.imbue(5);
+
+  mostd mobj;
+  mobj.imbue(5);
+  
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup2.C b/gcc/testsuite/g++.old-deja/g++.other/lookup2.C
new file mode 100644
index 00000000000..0772399222d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup2.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+struct B { 
+  int i;
+};
+
+struct D: virtual public B {
+  int i;
+};
+
+struct D2 : public D {
+  void f() { i = 3; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup3.C b/gcc/testsuite/g++.old-deja/g++.other/lookup3.C
new file mode 100644
index 00000000000..347be4e295a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup3.C
@@ -0,0 +1,17 @@
+// Test to make sure that the use of __typeof__ in WIFEXITED works.
+
+int main ()
+{
+  int stat_loc = 0;
+  (__extension__
+   ({
+     union
+     {
+       __typeof__ (stat_loc) __in;
+       int 		__i;
+     } __u;
+     __u.__in = (stat_loc);
+     __u.__i;
+   })
+   );
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup4.C b/gcc/testsuite/g++.old-deja/g++.other/lookup4.C
new file mode 100644
index 00000000000..59b7a75b2bd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup4.C
@@ -0,0 +1,21 @@
+// Test for proper handling of references to overloaded member functions.
+
+struct A {
+  static void f (int) { }
+  void f ();
+};
+
+void (*p)(int) = &A::f;
+
+void A::f ()
+{
+  p = f;
+}
+
+int main()
+{
+  A a;
+  p = &a.f;
+  (a.f)();
+  (a.f)(42);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup5.C b/gcc/testsuite/g++.old-deja/g++.other/lookup5.C
new file mode 100644
index 00000000000..9fe04151142
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup5.C
@@ -0,0 +1,11 @@
+// Build don't link:
+// Simplified from bug report by Paris Smaragdis <paris@media.mit.edu>
+
+// crash test - XFAIL *-*-*
+
+template <class T> class vector {};
+class foo {};
+int main() {
+        foo f;
+        f.vector(); // ERROR - not a method
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup6.C b/gcc/testsuite/g++.old-deja/g++.other/lookup6.C
new file mode 100644
index 00000000000..08f5ac521ed
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup6.C
@@ -0,0 +1,25 @@
+int f(int i)
+{
+  struct C {
+    int i;
+    C () : i(1) {}
+    int f() {    
+      struct D {
+        int i;
+	D () : i(2) {}
+        int g() { return i; }
+      } d;
+
+      return d.g();
+    }
+  } c;
+
+  return c.f();
+}
+
+
+int main()
+{
+  if (f(0) != 2)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup7.C b/gcc/testsuite/g++.old-deja/g++.other/lookup7.C
new file mode 100644
index 00000000000..55726a5d613
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup7.C
@@ -0,0 +1,12 @@
+// Test for handling of type shadowing in function scope.
+
+int main()
+{
+  int A = 42;
+  struct A
+  {
+    enum { a };
+  };
+  A = A::a;
+  return A;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup8.C b/gcc/testsuite/g++.old-deja/g++.other/lookup8.C
new file mode 100644
index 00000000000..f81572ab260
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup8.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+struct S {
+  int A;
+  struct A {
+    enum { a = 0 };
+  };
+
+  void f();
+};
+
+void S::f() {
+  A = A::a;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/lookup9.C b/gcc/testsuite/g++.old-deja/g++.other/lookup9.C
new file mode 100644
index 00000000000..250040071d2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/lookup9.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+struct S {
+  typedef long I;
+};
+
+struct D : virtual public S {
+  I i;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/loop1.C b/gcc/testsuite/g++.old-deja/g++.other/loop1.C
new file mode 100644
index 00000000000..3380dd4d74d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/loop1.C
@@ -0,0 +1,30 @@
+// Test for bad loop optimization of goto fixups.
+// Special g++ Options: -O2
+
+typedef bool (*ftype) ();
+
+int c, d;
+struct A {
+  A() { ++c; }
+  A(const A&) { ++c; }
+  ~A() { ++d; }
+};
+
+void f (ftype func)
+{
+  A a;
+  do {
+    if ((*func)()) return;
+  } while (true);
+}
+
+bool test ()
+{
+  return true;
+}
+
+main ()
+{
+  f (test);
+  return (c != d);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/main1.C b/gcc/testsuite/g++.old-deja/g++.other/main1.C
new file mode 100644
index 00000000000..09ab4113f9d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/main1.C
@@ -0,0 +1,12 @@
+// Build don't linK:
+
+int main()
+{ // ERROR - invalid redeclaration of
+  return 0;
+}
+
+
+int main(int, const char**)
+{ // ERROR - as
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/mangle1.C b/gcc/testsuite/g++.old-deja/g++.other/mangle1.C
new file mode 100644
index 00000000000..0ffc5d1a262
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/mangle1.C
@@ -0,0 +1,42 @@
+// Test for proper mangling by setting up name clashes.
+// Special g++ Options: -fno-squangle
+
+class A { };
+typedef A A2;
+typedef int I;
+typedef void V;
+typedef I I2;
+
+void f (const A2&, int, const A2&, const A&) { } // ERROR - name clash
+int f__FRC1AiT0T0 = 0; // ERROR - name clash
+
+void f (int, long, int, I) { } // ERROR - name clash
+int f__Filii = 0; // ERROR - name clash
+
+void f (I, float, I, I2) { } // ERROR - name clash
+int f__Fifii = 0; // ERROR - name clash
+
+void f (void*, float, void*, V*) { } // ERROR - name clash
+int f__FPvfT0T0 = 0; // ERROR - name clash
+
+void f (wchar_t) { } // ERROR - name clash
+int f__Fw = 0; // ERROR - name clash
+
+void f(int, A, A2, A) { } // ERROR - name clash
+int f__FiG1AN21 = 0; // ERROR - name clash
+
+void f(const A2&, const A2&, const A2&, const A2&,
+       int&) { } // ERROR - name clash
+int f__FRC1AN30Ri = 0; // ERROR - name clash
+
+void f(const A2&, int, const A2&, const A2&, const A2&,
+       int&) { } // ERROR - name clash
+int f__FRC1AiT0N20Ri = 0; // ERROR - name clash
+
+void f(const A2&, int, const A2&, const A2&, const A2&, int&, int&,
+       int&) { } // ERROR - name clash
+int f__FRC1AiT0N20RiN25 = 0; // ERROR - name clash
+
+void f(const A2&, int, const A2&, const A2&, const A2&, int, int,
+       int) { } // ERROR - name clash
+int f__FRC1AiT0N20iii = 0; // ERROR - name clash
diff --git a/gcc/testsuite/g++.old-deja/g++.other/mangle2.C b/gcc/testsuite/g++.old-deja/g++.other/mangle2.C
new file mode 100644
index 00000000000..873cb369e76
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/mangle2.C
@@ -0,0 +1,42 @@
+// Test for proper mangling by setting up name clashes.
+// Special g++ Options: -fsquangle
+
+class A;
+typedef A A2;
+typedef int I;
+typedef void V;
+typedef I I2;
+
+void f (const A2&, int, const A2&, const A&) { } // ERROR - name clash
+int f__FRC1AiRCB0n1 = 0; // ERROR - name clash
+
+void f (int, long, int, I) { } // ERROR - name clash
+int f__Filii = 0; // ERROR - name clash
+
+void f (I, float, I, I2) { } // ERROR - name clash
+int f__Fifii = 0; // ERROR - name clash
+
+void f (void*, float, void*, V*) { } // ERROR - name clash
+int f__FPvfPvn1 = 0; // ERROR - name clash
+
+void f (wchar_t) { } // ERROR - name clash
+int f__Fw = 0; // ERROR - name clash
+
+void f(int, A, A2, A) { } // ERROR - name clash
+int f__FiG1An2 = 0; // ERROR - name clash
+
+void f(const A2&, const A2&, const A2&, const A2&,
+       int&) { } // ERROR - name clash
+int f__FRC1An3Ri = 0; // ERROR - name clash
+
+void f(const A2&, int, const A2&, const A2&, const A2&,
+       int&) { } // ERROR - name clash
+int f__FRC1AiRCB0n2Ri = 0; // ERROR - name clash
+
+void f(const A2&, int, const A2&, const A2&, const A2&, int&, int&,
+       int&) { } // ERROR - name clash
+int f__FRC1AiRCB0n2Rin2 = 0; // ERROR - name clash
+
+void f(const A2&, int, const A2&, const A2&, const A2&, int, int,
+       int) { } // ERROR - name clash
+int f__FRC1AiRCB0n2in2 = 0; // ERROR - name clash
diff --git a/gcc/testsuite/g++.old-deja/g++.other/mutable1.C b/gcc/testsuite/g++.old-deja/g++.other/mutable1.C
new file mode 100644
index 00000000000..3fd0c3e6b7c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/mutable1.C
@@ -0,0 +1,43 @@
+// Copyright (C) 1999 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 14 Jan 1999 <nathan@acm.org>
+
+// Make sure objects with mutable members are never placed in a read only
+// section.
+
+// All these are POD structs, and hence do not need ctors
+struct A { mutable int i; };
+struct B { A a; };
+struct C { A a[1]; };
+struct D { static A const a; };
+
+// all these are static consts and hence naively suitable for a read only
+// section. But they contain a mutable, so must be in a writable section.
+static int const i = 0;
+static A const a = {0};
+static B const b = {{0}};
+static C const c = {{{0}}};
+static A const aa[] = {{0}};
+static B const bb[] = {{{0}}};
+static C const cc[] = {{{{0}}}};
+A const D::a = {0};
+
+int main()
+{
+  a.i = 05;
+  b.a.i = 05;
+  c.a[0].i = 05;
+  aa[0].i = 05;
+  bb[0].a.i = 05;
+  cc[0].a[0].i = 05;
+  D::a.i = 05;
+  
+  if(!a.i) return 1;
+  if(!b.a.i) return 1;
+  if(!c.a[0].i) return 1;
+  if(!aa[0].i) return 1;
+  if(!bb[0].a.i) return 1;
+  if(!cc[0].a[0].i) return 1;
+  if(!D::a.i) return 1;
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/nested1.C b/gcc/testsuite/g++.old-deja/g++.other/nested1.C
new file mode 100644
index 00000000000..0c038561d66
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/nested1.C
@@ -0,0 +1,19 @@
+// Build don't link:
+
+struct C
+{
+  struct D
+  {
+  };
+};
+
+struct E
+{
+  C& c;
+  void g();
+};
+
+void E::g()
+{
+  c.D().f(); // ERROR - no matching function
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/nested2.C b/gcc/testsuite/g++.old-deja/g++.other/nested2.C
new file mode 100644
index 00000000000..5492b536b43
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/nested2.C
@@ -0,0 +1,12 @@
+// Build don't link:
+// by Bert Bril <bert@dgb.nl>
+
+struct M1 {
+    struct I                            {};
+};
+ 
+struct M2 {
+    struct I                            {};
+    struct J : virtual public M2::I,
+               virtual public M1::I     {};
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/nested3.C b/gcc/testsuite/g++.old-deja/g++.other/nested3.C
new file mode 100644
index 00000000000..783caadd285
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/nested3.C
@@ -0,0 +1,12 @@
+// Build don't link:
+// Origin: Chip Salzenberg <chip@perlsupport.com>
+
+class Foo {
+  public:
+    class Bar;
+};
+
+class Foo::Bar {
+  public:
+    Bar() {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/new.C b/gcc/testsuite/g++.old-deja/g++.other/new.C
new file mode 100644
index 00000000000..e2839578d15
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/new.C
@@ -0,0 +1,57 @@
+// Build don't link:
+
+typedef __SIZE_TYPE__ size_t;
+inline void *
+operator new(size_t alloc_sz, const char *fname, unsigned lineno)
+{
+}
+inline void *
+operator new[](size_t alloc_sz, const char *fname, unsigned lineno) 
+{
+}
+inline void
+operator delete(void *ptr, const char *fname, unsigned lineno) 
+{
+}
+inline void
+operator delete[](void *ptr, const char *fname, unsigned lineno)
+{
+}
+
+class DEF {						 
+public:
+    DEF( DEF *parent=0, const char *name=0 );
+};
+
+class ABC
+{
+public:
+    enum stuff { ID0, ID1 };
+    ABC( stuff, DEF *parent=0, const char *name=0 );
+};
+
+class GHI : public DEF			 
+{
+};
+
+class LMNFrame;
+class LMN : public DEF
+{
+  friend class LMNFrame;
+  public:
+public:
+  LMN();
+private:
+  LMNFrame *draw_area;
+				 
+  ABC *scroll_h;		 
+};
+class LMNFrame : public GHI {
+};
+LMN::LMN()
+{
+  draw_area = new ("abc", 69) LMNFrame;
+				 
+  scroll_h = new ("def", 71)  ABC(ABC::ID0, this);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/new2.C b/gcc/testsuite/g++.old-deja/g++.other/new2.C
new file mode 100644
index 00000000000..9a6e0514ff4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/new2.C
@@ -0,0 +1,21 @@
+//Build don't link:
+typedef __SIZE_TYPE__ size_t;
+void *operator new(size_t, unsigned int);
+
+struct X{
+  X();
+  X(int);
+};
+
+
+void f(X *x = new X);          // ERROR - 
+
+void f(X *x = new X(4));       // ERROR - 
+
+void f(X *x = new X[4]);       // ERROR - 
+
+void f(X *x = new (3) X(6));   // ERROR - 
+
+void f(X *x = new (2) X[10]);  // ERROR - 
+
+void f(X *x = new X[10][5]);   // ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.other/new3.C b/gcc/testsuite/g++.old-deja/g++.other/new3.C
new file mode 100644
index 00000000000..fa32cdde6cb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/new3.C
@@ -0,0 +1,25 @@
+typedef __SIZE_TYPE__ size_t;
+
+template <class T>
+struct A
+{
+  int size;
+  A ()
+    {
+      T *p;
+      p = new T[size];
+      int foo;
+      foo = 5 * size;
+    };
+};
+
+struct B
+{
+  virtual ~B() { }
+  void operator delete [] (void *ptr, size_t size) { }
+};
+
+int main ()
+{
+  A<B> *p = new A<B>;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/null1.C b/gcc/testsuite/g++.old-deja/g++.other/null1.C
new file mode 100644
index 00000000000..22d08a40aef
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/null1.C
@@ -0,0 +1,41 @@
+// Build don't run:
+
+#include <cstddef>
+
+void g(int) {}
+void g(long) {}
+extern void g(void*);
+
+template <int I>
+void h() {}
+
+void k(int) {}
+
+template <class T>
+void l(T);
+
+template <>
+void l(int) {}
+
+int main()
+{
+  int i = NULL; // WARNING - converting NULL to non-pointer type
+  float z = NULL; // WARNING - converting NULL to non-pointer type
+  int a[2];
+
+  i != NULL; // WARNING - NULL used in arithmetic
+  NULL != z; // WARNING - NULL used in arithmetic
+  k != NULL; // No warning: decay conversion
+  NULL != a; // Likewise.
+  -NULL;     // WARNING - converting NULL to non-pointer type
+  +NULL;     // WARNING - converting NULL to non-pointer type
+  ~NULL;     // WARNING - converting NULL to non-pointer type
+  a[NULL] = 3; // WARNING - converting NULL to non-pointer-type
+  i = NULL;  // WARNING - converting NULL to non-pointer type
+  z = NULL;  // WARNING - converting NULL to non-pointer type
+  k(NULL);   // WARNING - converting NULL to int
+  g(NULL);   // WARNING - converting NULL to int
+  h<NULL>(); // WARNING - NULL bound to integer template parameter
+  l(NULL);   // WARNING - converting NULL to int
+  NULL && NULL; // No warning: converting NULL to bool is OK
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/null2.C b/gcc/testsuite/g++.old-deja/g++.other/null2.C
new file mode 100644
index 00000000000..9dc5b130914
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/null2.C
@@ -0,0 +1,12 @@
+// Based on a testcase by Eric Dumazet <Eric.Dumazet@COSMOSBAY.COM>
+
+#include <cstdlib>
+
+const char * const foo = ""; // foo is not NULL
+
+int main() {
+  if ((foo == 0) ? 0 : foo)  // so this should evaluate to `foo'
+    return 0;
+  else
+    std::abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/null3.C b/gcc/testsuite/g++.old-deja/g++.other/null3.C
new file mode 100644
index 00000000000..aef456e974a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/null3.C
@@ -0,0 +1,6 @@
+// Build don't link:
+
+void x()
+{
+ int* p = 1==0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overcnv1.C b/gcc/testsuite/g++.old-deja/g++.other/overcnv1.C
new file mode 100644
index 00000000000..05941df5ff0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overcnv1.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+class A {
+public:
+	void f(const char * const * );
+};
+void f(const char * const *) {}
+
+void g()
+{
+	char *ar[10];
+	A a;
+	f(ar);
+	a.f(ar);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overcnv2.C b/gcc/testsuite/g++.old-deja/g++.other/overcnv2.C
new file mode 100644
index 00000000000..725ce0991ce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overcnv2.C
@@ -0,0 +1,18 @@
+// Test that we resolve this case as mandated by the standard, but also
+// warn about it.  We choose op char* not because it is a member of B --
+// the standard says that all conversion ops are treated as coming from
+// the type of the argument -- but because it is non-const.
+
+struct A  {
+  operator const char *() const;
+};
+
+struct B : public A {
+  operator char *() { return 0; }
+};
+
+int main()
+{
+  B b;
+  (const char *)b;		// WARNING - surprising overload resolution
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overload1.C b/gcc/testsuite/g++.old-deja/g++.other/overload1.C
new file mode 100644
index 00000000000..59191d501e2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload1.C
@@ -0,0 +1,11 @@
+struct A {
+  A operator+ (int) const { return *this; }
+};
+
+A operator+ (A, float);
+
+int main ()
+{
+  A a;
+  a + 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overload2.C b/gcc/testsuite/g++.old-deja/g++.other/overload2.C
new file mode 100644
index 00000000000..598f71c821e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload2.C
@@ -0,0 +1,24 @@
+// Build don't run:
+
+template <class T>
+class ConstArray {
+};
+
+template <class T1, class T2>
+void operator+(const ConstArray<T1>&, const ConstArray<T2>&)
+{
+}
+
+template <class T1, class T2>
+void operator+(const ConstArray<T1>&, T2);
+
+template <class T1, class T2>
+void operator+(T1, const ConstArray<T2>&);
+
+const ConstArray<int> cai() { return ConstArray<int>(); }
+const ConstArray<double> cad() { return ConstArray<double>(); }
+
+int main()
+{
+  cai () + cad ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overload3.C b/gcc/testsuite/g++.old-deja/g++.other/overload3.C
new file mode 100644
index 00000000000..fc1d5c09d61
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload3.C
@@ -0,0 +1,16 @@
+// Build don't run:
+
+void f(const int *);
+void f(int *) {}
+
+void f2(const volatile int *);
+void f2(volatile int *) {}
+
+int i;
+
+int main()
+{
+  f(&i);
+  f2(&i);
+}
+          
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overload4.C b/gcc/testsuite/g++.old-deja/g++.other/overload4.C
new file mode 100644
index 00000000000..22478531b95
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload4.C
@@ -0,0 +1,10 @@
+// Build don't run:
+
+void f(int* const volatile * const * const*);
+void f(int* const * const * const*) {}
+
+int main()
+{
+  int*** ip;
+  f(&ip);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overload5.C b/gcc/testsuite/g++.old-deja/g++.other/overload5.C
new file mode 100644
index 00000000000..5f5e11f9dd1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload5.C
@@ -0,0 +1,22 @@
+// Build don't run:
+
+struct S {};
+
+struct T : public S {};
+
+struct U : public T {};
+
+void f(int T::*) {}
+void f(int U::*);
+
+void g(void (T::*)(int)) {}
+void g(void (U::*)(int));
+
+int main()
+{
+  int S::*ip;
+  void (S::*fp)(int);
+
+  f(ip);
+  g(fp);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overload6.C b/gcc/testsuite/g++.old-deja/g++.other/overload6.C
new file mode 100644
index 00000000000..fae26c34824
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload6.C
@@ -0,0 +1,18 @@
+extern "C" void abort();
+
+struct S1
+{
+  int f() { return 0; }
+  int f() const { return 1; }
+};
+
+struct S2 : public S1
+{
+};
+
+int main()
+{
+  S2 s2;
+  if (s2.f() != 0)
+    abort ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overload7.C b/gcc/testsuite/g++.old-deja/g++.other/overload7.C
new file mode 100644
index 00000000000..57bec8bed2d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload7.C
@@ -0,0 +1,22 @@
+// Check that object call works when there are multiple conversion ops
+// returning the same type.
+
+typedef int (*pfn)();
+
+int zero () { return 0; }
+int one  () { return 1; }
+int two  () { return 2; }
+
+struct A {
+  A() { }
+  operator pfn () { return one; }
+  operator pfn () const { return zero; }
+  operator pfn () volatile { return two; }
+};
+
+int
+main ()
+{
+  const A a;
+  return a();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overload8.C b/gcc/testsuite/g++.old-deja/g++.other/overload8.C
new file mode 100644
index 00000000000..d2c1483a9b2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload8.C
@@ -0,0 +1,22 @@
+class a {
+public:
+  int f()        { return 0; }
+  int f() const  { return 1; }
+};
+
+class b : public a {
+};
+
+int main() 
+{
+  int (b::* ptr1)()       = &b::f; 
+  int (b::* ptr2)() const = &b::f; 
+  
+  b ao;
+  
+  if ((ao.*ptr1)() != 0)
+    return 1;
+  if ((ao.*ptr2)() != 1)
+    return 1;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overload9.C b/gcc/testsuite/g++.old-deja/g++.other/overload9.C
new file mode 100644
index 00000000000..521f4bd4d06
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload9.C
@@ -0,0 +1,31 @@
+struct T { ~T() {}; };
+
+int g ()
+{
+ foo:
+  T t;
+  int f(int);
+ bar:
+  T t2;
+  int f(double);
+  return f(3);
+}
+
+
+int f(int)
+{
+  return 0;
+}
+
+
+int f(double)
+{
+  return 1;
+}
+
+
+int main()
+{
+  return g();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/parse1.C b/gcc/testsuite/g++.old-deja/g++.other/parse1.C
new file mode 100644
index 00000000000..d81751289f0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/parse1.C
@@ -0,0 +1,6 @@
+// Test that we save declspecs before a class defn properly.
+// Build don't link:
+
+static volatile union {
+  void f() { }
+} u;
diff --git a/gcc/testsuite/g++.old-deja/g++.other/pmf1.C b/gcc/testsuite/g++.old-deja/g++.other/pmf1.C
new file mode 100644
index 00000000000..e84a39a03f1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/pmf1.C
@@ -0,0 +1,8 @@
+struct foo {};
+typedef long unsigned int & (foo::*pmf)(void);
+void fn (...) {}
+int main ()
+{
+  pmf y = 0;
+  fn (y);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/pmf2.C b/gcc/testsuite/g++.old-deja/g++.other/pmf2.C
new file mode 100644
index 00000000000..92935c0e451
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/pmf2.C
@@ -0,0 +1,18 @@
+// Build don't link:
+
+// submitted by David C Binderman <dcb@pncl.co.uk>
+
+struct S
+{
+	void f();
+};
+
+void (S ::* pmf) ();
+
+S * pf;
+
+void
+f()
+{
+	pmf = & pf->f; // ERROR - not a valid pmf expression
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/pmf3.C b/gcc/testsuite/g++.old-deja/g++.other/pmf3.C
new file mode 100644
index 00000000000..237812246e5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/pmf3.C
@@ -0,0 +1,24 @@
+// Submitted by Nathan Sidwell <nathan@acm.org>
+// Bug: g++ was crashing after giving errors.
+
+template<class T>
+  void connect_to_method(
+    T *receiver,
+    void (T::*method)())
+  {}
+
+class Gtk_Base
+{ 
+public:
+  void expose();
+  void show();
+  void show(int);
+  Gtk_Base();
+};
+
+
+Gtk_Base::Gtk_Base()
+{
+  connect_to_method(this,&show);   // ERROR - invalid pmf expression
+  connect_to_method(this,&expose); // ERROR - invalid pmf expression
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/printf1.C b/gcc/testsuite/g++.old-deja/g++.other/printf1.C
new file mode 100644
index 00000000000..04c4d9f8de5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/printf1.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Special g++ Options: -Wall
+
+struct a
+{
+  void x(char *f,...) __attribute__((format(printf,2,3)));
+};
+
+int main()
+{
+  a A;
+  A.x("%d"); // WARNING - too few arguments for format
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/ptrmem1.C b/gcc/testsuite/g++.old-deja/g++.other/ptrmem1.C
new file mode 100644
index 00000000000..1b5d5df8e39
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/ptrmem1.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+class x
+{
+public:
+  virtual int is_constant();
+};
+
+void foo()
+{
+  x* y;
+  if (y->is_constant) // ERROR - assuming &
+    {
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/ptrmem2.C b/gcc/testsuite/g++.old-deja/g++.other/ptrmem2.C
new file mode 100644
index 00000000000..85730952d0c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/ptrmem2.C
@@ -0,0 +1,15 @@
+class cow {
+public:
+  void moo (char *);
+};
+
+void f()
+{
+  cow* c;
+
+  void (cow::*fp0)(char*) = &cow::moo;  // OK
+  void (cow::*fp1)(int) = &cow::moo;    // ERROR - conversion
+  int (cow::*fp2)(char*) = &cow::moo;   // ERROR - conversion
+  int (cow::*fp3)(char*, void*) = fp2;  // ERROR - conversion
+  int (cow::*fp4)(double) = (int (cow::*)(double)) fp2; // OK
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/ptrmem3.C b/gcc/testsuite/g++.old-deja/g++.other/ptrmem3.C
new file mode 100644
index 00000000000..3f6a2afca0e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/ptrmem3.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+class c {
+  void (c::*x)();
+public:
+  void f() { this->x(); } // ERROR - pointer-to-member
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/ptrmem4.C b/gcc/testsuite/g++.old-deja/g++.other/ptrmem4.C
new file mode 100644
index 00000000000..dc378b23e6f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/ptrmem4.C
@@ -0,0 +1,12 @@
+// Test to make sure g++ can handle target types that aren't identical
+// with pointers to members.
+
+struct A { int i; };
+struct B : public A { };
+
+int main ()
+{
+  int A::*p = &A::i;
+  const int B::*q = &A::i;
+  return p != q;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/realloc.C b/gcc/testsuite/g++.old-deja/g++.other/realloc.C
new file mode 100644
index 00000000000..1e1c6db8aa4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/realloc.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+extern "C" void realloc();
+
+class bug {
+public:
+  void realloc(int foo,int bar);
+};
+
+void f() {
+  bug c;
+  c.realloc(50,50);
+}
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.other/redecl1.C b/gcc/testsuite/g++.old-deja/g++.other/redecl1.C
new file mode 100644
index 00000000000..d08e5aa9088
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/redecl1.C
@@ -0,0 +1,6 @@
+//Build don't link:
+struct X{
+  void i();
+  void i(int);  // ERROR - 
+  int i;        // ERROR - conflict
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/redecl2.C b/gcc/testsuite/g++.old-deja/g++.other/redecl2.C
new file mode 100644
index 00000000000..7dcdeb4cbe8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/redecl2.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+struct S {
+  S(int);
+  S(int); // ERROR - already declared
+
+  ~S();
+  ~S(); // ERROR - already declared
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/ref1.C b/gcc/testsuite/g++.old-deja/g++.other/ref1.C
new file mode 100644
index 00000000000..b6d82aa25ca
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/ref1.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+int f();
+
+void g()
+{
+  const int& i = f(); // OK
+  int& j = f(); // ERROR - initialization of non-const reference 
+  const volatile int& k = f(); // ERROR - initialization of volatile ref
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/rtti1.C b/gcc/testsuite/g++.old-deja/g++.other/rtti1.C
new file mode 100644
index 00000000000..7377e156dba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/rtti1.C
@@ -0,0 +1,121 @@
+// test of rtti of non-class types
+// Special g++ Options: -frtti
+
+#include <typeinfo>
+
+extern "C" {
+  int printf(const char *, ...);
+  void exit(int);
+}
+
+int i;
+short s;
+char c;
+long l;
+
+unsigned int ui;
+unsigned short us;
+unsigned char uc;
+unsigned long ul;
+
+float f;
+double d;
+
+int& ri = i;
+const volatile int cvi = 10;
+volatile const int vci = 20;
+const int ci = 100;
+
+int *pi;
+int ai[10];
+
+enum color { red, blue, green, yellow};
+
+int (*fp)();
+int (*gp)();
+int (*hp)(int);
+
+class XX {
+public:
+  int xxi;
+  float xxf;
+  int xxf1 () {};
+  int xxf2 (int k) {};
+};
+
+class YY {
+public:
+  int yyi;
+  double yyd;
+  int yyf1 (float f) {};
+  double yyf2 () {return yyd;};
+};
+
+int XX::*ptmd1;
+int XX::*ptmd2;
+float XX::*ptmd3;
+int YY::*ptmd4;
+
+int (XX::*ptmf1) ();
+int (XX::*ptmf2) ();
+int (XX::*ptmf3) (int);
+int (YY::*ptmf4) ();
+
+int func1 ()
+{ return 0;}
+
+int func2 ()
+{ return 1;}
+
+int func3 (int i)
+{ return i;}
+
+short func4 ()
+{ return 99;}
+
+void error  (int i)
+{
+  exit(i);
+}
+
+int main ()
+{
+  if (typeid(i) != typeid(int)) error(1);
+  if (typeid(s) != typeid(short)) error(2);
+  if (typeid(c) != typeid(char)) error(3);
+  if (typeid(l) != typeid(long)) error(4);
+  if (typeid(ui) != typeid(unsigned int)) error(5);
+  if (typeid(us) != typeid(unsigned short)) error(6);
+  if (typeid(uc) != typeid(unsigned char)) error(7);
+  if (typeid(ul) != typeid(unsigned long)) error(8);
+  if (typeid(f) != typeid(float)) error(9);
+  if (typeid(d) != typeid(double)) error(10);
+
+  if (typeid(*pi) != typeid(int)) error(51);
+  if (typeid(pi) == typeid(ai)) error(52);
+  if (typeid(ri) != typeid(i)) error(53);
+  if (typeid(cvi) != typeid(vci)) error (54);
+  if (typeid(vci) != typeid(i)) error(55);
+  if (typeid(ci) != typeid(cvi)) error (56);
+  if (typeid(ci) != typeid(const int)) error(57);
+
+  if (typeid(func1) != typeid(func2)) error (81);
+  if (typeid(func2) == typeid(func3)) error (82);
+  if (typeid(func1) == typeid(func4)) error (83);
+  if (typeid(func3) == typeid(func4)) error (84);
+
+  if (typeid(red) != typeid(color)) error (101);
+  if (typeid(green) != typeid(blue)) error (102);
+
+  if (typeid(fp) != typeid(gp)) error (103);
+  if (typeid(gp) == typeid(hp)) error (104);
+
+  if (typeid(ptmd1) != typeid(ptmd2)) error (105);
+  if (typeid(ptmd1) == typeid(ptmd3)) error (106);
+  if (typeid(ptmd2) == typeid(ptmd4)) error (107);
+
+  if (typeid(ptmf1) != typeid(ptmf2)) error (108);
+  if (typeid(ptmf2) == typeid(ptmf3)) error (109);
+  if (typeid(ptmf1) == typeid(ptmf4)) error (110);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/rtti2.C b/gcc/testsuite/g++.old-deja/g++.other/rtti2.C
new file mode 100644
index 00000000000..a7a218b06e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/rtti2.C
@@ -0,0 +1,88 @@
+// test of rtti of single inheritance and multiple inheritance classes
+// Special g++ Options: -frtti
+
+#include <typeinfo>
+
+extern "C" {
+  int printf(const char *, ...);
+  void exit(int);
+}
+
+class X {
+ public:
+  int xi;
+};
+
+class Y : public X {
+  short ys;
+};
+
+class Z : public Y {
+  int zi;
+};
+
+Z z;
+Y y;
+Y *yp = &z;
+X *xp = &z;
+Z *zp = &z;
+
+class A {
+ public:
+  int Ai;
+};
+
+class B {
+ public:
+  int Bi;
+};
+
+class D : public A, public B {
+  int Di;
+};
+
+/*
+class E : public D, public B {
+  int Ei;
+};
+*/
+class E {
+  int Ei;
+};
+
+class F : public E, public D {
+  int Fi;
+};
+
+D d;
+A *ap = &d;
+B *bp = &d;
+F f;
+A *aap = &f;
+D *dp = &f;
+B *bbp = dp;
+
+void *vp = zp;
+
+void error  (int i)
+{
+  exit(i);
+}
+
+int main ()
+{
+  if (typeid(z) != typeid(Z)) error(1);
+  if (typeid(*yp) == typeid(Z)) error(2);
+  if (typeid(*yp) == typeid(*zp)) error(3);
+  if (typeid(xp) == typeid(yp)) error(4);
+
+  xp = (X *)&y;
+  if (typeid(*xp) == typeid(*yp)) error(5);
+  if (typeid(*xp) == typeid(Y)) error(6);
+  
+  if (typeid(*ap) == typeid(*bp)) error (31);
+  if (typeid(*ap) == typeid(D)) error(32);
+
+  if (typeid(*aap) == typeid(*bbp)) error(33);
+  if (typeid(*dp) == typeid(*aap)) error(34);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/rtti3.C b/gcc/testsuite/g++.old-deja/g++.other/rtti3.C
new file mode 100644
index 00000000000..fdb1f9e090d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/rtti3.C
@@ -0,0 +1,96 @@
+// test of rtti of single inheritance and multiple inheritance with 
+// virtual functions
+// Special g++ Options: -frtti
+
+#include <typeinfo>
+
+extern "C" {
+  int printf(const char *, ...);
+  void exit(int);
+}
+
+class X {
+ public:
+  int xi;
+  virtual int f() {};
+};
+
+class Y : public X {
+  short ys;
+};
+
+class Z : public Y {
+  int zi;
+};
+
+Z z;
+Y y;
+Y *yp = &z;
+X *xp = &z;
+Z *zp = &z;
+
+class A {
+ public:
+  int Ai;
+  virtual int a() {};
+};
+
+class B {
+ public:
+  int Bi;
+  virtual int g() {};
+};
+
+class D : public A, public B {
+  int Di;
+};
+
+/*
+class E : public D, public B {
+  int Ei;
+};
+*/
+class E {
+  int Ei;
+};
+
+class F : public E, public D {
+  int Fi;
+};
+
+D d;
+A *ap = &d;
+B *bp = &d;
+D *dp = &d;
+F f;
+A *aap = &f;
+B *bbp = &f;
+
+void *vp = zp;
+
+void error  (int i)
+{
+  exit(i);
+}
+
+int main ()
+{
+  if (typeid(z) != typeid(Z)) error(1);
+  if (typeid(*yp) != typeid(Z)) error(2);
+  if (typeid(*yp) != typeid(*zp)) error(3);
+  if (typeid(xp) == typeid(yp)) error(4);
+
+  xp = (X *)&y;
+  if (typeid(*xp) == typeid(*yp)) error(5);
+  if (typeid(*xp) != typeid(Y)) error(6);
+  
+  if (typeid(*ap) != typeid(*bp)) error (31);
+  if (typeid(*ap) != typeid(D)) error(32);
+  vp = dp;
+  vp = dynamic_cast<void*> ((B *)vp);
+  if (dp != (D *)vp) error(35);
+
+  dp = (D *)&f;
+  if (typeid(*aap) != typeid(*bbp)) error(37);
+  if (typeid(*dp) != typeid(*aap)) error(38);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/rtti4.C b/gcc/testsuite/g++.old-deja/g++.other/rtti4.C
new file mode 100644
index 00000000000..571ed68fd9f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/rtti4.C
@@ -0,0 +1,86 @@
+// test of rtti of single inheritance and multiple inheritance with 
+// virtual inheritance
+// Special g++ Options: -frtti -w
+
+#include <typeinfo>
+
+extern "C" {
+  int printf(const char *, ...);
+  void exit(int);
+}
+
+class X {
+ public:
+  int xi;
+  virtual int f() {};
+};
+
+class Y : public virtual X {
+  short ys;
+};
+
+class Z : public virtual Y {
+  int zi;
+};
+
+Z z;
+Y y;
+Y *yp = &z;
+X *xp = &z;
+Z *zp = &z;
+
+class A {
+public:
+  int Ai;
+  virtual int a() {};
+};
+
+class B {
+public:
+  int Bi;
+  virtual int g() {};
+};
+
+class D : public virtual A, private B {
+  int Di;
+};
+
+class E : public virtual D, public B {
+  int Ei;
+};
+
+class F : public E, public virtual D {
+  int Fi;
+};
+
+D d;
+A *ap = &d;
+B *bp = (B *)&d;
+F f;
+A *aap = &f;
+D *dp = &f;
+B *bbp = (B *)dp;
+
+void *vp = zp;
+
+void error  (int i)
+{
+  exit(i);
+}
+
+int main ()
+{
+  if (typeid(z) != typeid(Z)) error(1);
+  if (typeid(*yp) != typeid(Z)) error(2);
+  if (typeid(*yp) != typeid(*zp)) error(3);
+  if (typeid(xp) == typeid(yp)) error(4);
+
+  xp = (X *)&y;
+  if (typeid(*xp) == typeid(*yp)) error(5);
+  if (typeid(*xp) != typeid(Y)) error(6);
+  
+  if (typeid(*ap) != typeid(*bp)) error (31);
+  if (typeid(*ap) != typeid(D)) error(32);
+  if (typeid(*aap) != typeid(*bbp)) error(33);
+  if (typeid(*dp) != typeid(*aap)) error(34);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/rtti5.C b/gcc/testsuite/g++.old-deja/g++.other/rtti5.C
new file mode 100644
index 00000000000..38a5146e8c9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/rtti5.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Special g++ Options: -fno-rtti
+
+// Copyright (C) 1999 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 9 Apr 1999 <nathan@acm.org>
+// derrived from bug report from Alexander Zvyagin <zvyagin@mx.ihep.su>
+
+// check we don't die with disabled rtti
+
+
+int main(void) {
+  int i;
+  typeid(i); // ERROR - rtti disabled
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/rttid2.C b/gcc/testsuite/g++.old-deja/g++.other/rttid2.C
new file mode 100644
index 00000000000..50c1867c267
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/rttid2.C
@@ -0,0 +1,100 @@
+// test of rtti of single inheritance and multiple inheritance classes
+// dynamic casting
+// Special g++ Options: -frtti
+
+#include <typeinfo>
+
+extern "C" {
+  int printf(const char *, ...);
+  void exit(int);
+}
+
+class X {
+ public:
+  int xi;
+};
+
+class Y : public X {
+  short ys;
+};
+
+class Z : public Y {
+  int zi;
+};
+
+Z z;
+Y y;
+Y *yp = &z;
+X *xp = &z;
+Z *zp = &z;
+
+class A {
+ public:
+  int Ai;
+};
+
+class B {
+ public:
+  int Bi;
+};
+
+class D : public A, public B {
+  int Di;
+};
+
+/*
+class E : public D, public B {
+  int Ei;
+};
+*/
+class E {
+  int Ei;
+};
+
+class F : public E, public D {
+  int Fi;
+};
+
+D d;
+A *ap = &d;
+B *bp = &d;
+F f;
+F *fp = &f;
+A *aap = &f;
+D *dp = &f;
+B *bbp = dp;
+
+void *vp = zp;
+
+/*
+void error (int i)
+{
+  printf("FAIL\n");
+  exit(i);
+}
+*/
+
+void error  (int i)
+{
+  exit(i);
+}
+
+int main ()
+{
+
+  vp = (void *)0;
+
+  vp = dynamic_cast<Y *> (&z);
+  if (vp == 0) error(11);
+
+  vp = dynamic_cast<X *> (yp);
+  if (vp == 0) error(12);
+
+  vp = dynamic_cast<D *> (dp);
+  if (vp != (void *)dp) error(21);
+
+  vp = dynamic_cast<B *> (fp);
+  if (vp != (void *)bbp) error(22);
+
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/rttid3.C b/gcc/testsuite/g++.old-deja/g++.other/rttid3.C
new file mode 100644
index 00000000000..69b7fc5c38a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/rttid3.C
@@ -0,0 +1,115 @@
+// test of rtti of single inheritance and multiple inheritance with 
+// virtual functions
+// dynamic casting
+// Special g++ Options: -frtti
+
+#include <typeinfo>
+
+extern "C" {
+  int printf(const char *, ...);
+  void exit(int);
+}
+
+class X {
+ public:
+  int xi;
+  virtual int f() {};
+};
+
+class Y : public X {
+  short ys;
+};
+
+class Z : public Y {
+  int zi;
+};
+
+Z z;
+Y y;
+Y *yp = &z;
+X *xp = &z;
+Z *zp = &z;
+
+class A {
+ public:
+  int Ai;
+  virtual int a() {};
+};
+
+class B {
+ public:
+  int Bi;
+  virtual int g() {};
+};
+
+class D : public A, public B {
+  int Di;
+};
+
+/*
+class E : public D, public B {
+  int Ei;
+};
+*/
+class E {
+  int Ei;
+};
+
+class F : public E, public D {
+  int Fi;
+};
+
+D d;
+A *ap = &d;
+B *bp = &d;
+D *dp = &d;
+F f;
+F *fp = &f;
+A *aap = &f;
+B *bbp = &f;
+
+void *vp = zp;
+
+/*
+void error (int i)
+{
+  printf("FAIL\n");
+  exit(i);
+}
+*/
+
+void error  (int i)
+{
+  exit(i);
+}
+
+int main ()
+{
+  vp = (void *)0;
+
+  vp = dynamic_cast<Y *> (&z);
+  if (vp == 0) error(11);
+
+  vp = dynamic_cast<Z *> (yp);
+  if (vp == 0) error(11);
+
+  vp = dynamic_cast<X *> (yp);
+  if (vp == 0) error(12);
+
+  vp = dynamic_cast<D *> (dp);
+  if (vp != (void *)dp) error(21);
+
+  vp = dynamic_cast<B *> (dp);
+  if (vp == (void *)dp) error(21);
+
+  vp = dynamic_cast<B *> (fp);
+  if (vp != (void *)bbp) error(22);
+
+  vp = dynamic_cast<void *> (aap);
+  if (vp != (void *)fp) error(23);
+
+  vp = dynamic_cast<B *> (aap);
+  if (vp != (void *)bbp) error(24);
+
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/rttid4.C b/gcc/testsuite/g++.old-deja/g++.other/rttid4.C
new file mode 100644
index 00000000000..0b72bae1ee3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/rttid4.C
@@ -0,0 +1,111 @@
+// test of rtti of single inheritance and multiple inheritance with 
+// virtual inheritance
+// dynamic casting
+// Special g++ Options: -w
+
+#include <typeinfo>
+
+extern "C" {
+  int printf(const char *, ...);
+  void exit(int);
+}
+
+class X {
+ public:
+  int xi;
+  virtual int f() {};
+};
+
+class Y : public virtual X {
+  short ys;
+};
+
+class Z : public virtual Y {
+  int zi;
+};
+
+Z z;
+Y y;
+Y *yp = &z;
+X *xp = &z;
+Z *zp = &z;
+
+class A {
+public:
+  int Ai;
+  virtual int a() {};
+};
+
+class B {
+public:
+  int Bi;
+  virtual int g() {};
+};
+
+class D : public virtual A, private B {
+  int Di;
+};
+
+class E : public virtual D, public B {
+  int Ei;
+};
+
+class F : public E, public virtual D {
+  int Fi;
+};
+
+D d;
+A *ap = &d;
+B *bp = (B *)&d;
+F f;
+F *fp = &f;
+A *aap = &f;
+D *dp = &f;
+E *ep = &f;
+B *bbp = (B *)dp;
+
+void *vp = zp;
+
+/*
+void error (int i)
+{
+  printf("FAIL\n");
+  exit(i);
+}
+*/
+
+void error  (int i)
+{
+  exit(i);
+}
+
+int main ()
+{
+  vp = (void *)0;
+
+  vp = dynamic_cast<Y *> (&z);
+  if (vp == 0) error(11);
+
+  vp = dynamic_cast<Z *> (yp);
+  if (vp == 0) error(11);
+
+  vp = dynamic_cast<X *> (yp);
+  if (vp == 0) error(12);
+
+  vp = dynamic_cast<D *> (dp);
+  if (vp != (void *)dp) error(21);
+
+  // Ill-formed: dynamic_cast to private or ambiguous base
+  //   vp = dynamic_cast<B *> (dp);
+  //   if (vp == (void *)dp) error(21);
+
+  //   vp = dynamic_cast<B *> (fp);
+  //   if (vp == (void *)bbp) error(22);
+
+  vp = dynamic_cast<void *> (aap);
+  if (vp != (void *)fp) error(23);
+
+  vp = dynamic_cast<B *> (aap);
+  if (vp == (void *)bbp) error(24);
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/signed.C b/gcc/testsuite/g++.old-deja/g++.other/signed.C
new file mode 100644
index 00000000000..3bdce03a3e4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/signed.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+// Copyright (C) 1999 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 24 Mar 1999 <nathan@acm.org>
+
+// Determine that function style casts are groked
+
+void fn()
+{
+  +char(5);
+  +short(5);
+  +int(5);
+  +long(5);
+  +signed(5);
+  +unsigned(5);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/singleton.C b/gcc/testsuite/g++.old-deja/g++.other/singleton.C
new file mode 100644
index 00000000000..075d83ac79a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/singleton.C
@@ -0,0 +1,38 @@
+// This tests two things:
+// 1. there is an annoying warning.
+// singleton.C:26: warning: `class singleton' only defines private constructors and has no friends
+// egcs fails to see that there is a public static accessor function.
+// 2. the program crashes, because apparently the static variable s in
+// singleton::instance() is considered constructed although the ctor
+// exited via an exception. (crash changed to non-zero return here)
+
+class singleton {
+public:
+       static singleton& instance() {
+               static singleton s;
+               return s;
+       }
+       int check() {return initialized;}
+
+private:
+       singleton() : initialized(1) {
+               if ( counter++ == 0 ) throw "just for the heck of it";
+               initialized = 2;
+       }
+       singleton( const singleton& rhs );
+       void operator=( const singleton& rhs );
+       int initialized;
+       static int counter;
+};  
+
+int singleton::counter;
+
+int main()
+{
+       while (1) {
+               try {
+                       return singleton::instance().check()-2;
+               } catch (...) { }
+       }
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.other/sizeof1.C b/gcc/testsuite/g++.old-deja/g++.other/sizeof1.C
new file mode 100644
index 00000000000..6b547ae912e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/sizeof1.C
@@ -0,0 +1,12 @@
+// Build don't link:
+// Origin: Jason Merrill <jason@cygnus.com>
+
+struct X {
+  int f ();
+  int f (int);
+};
+
+void f(int i)
+{
+  i = sizeof(X::f); // ERROR - cannot take sizeof a member function
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/static1.C b/gcc/testsuite/g++.old-deja/g++.other/static1.C
new file mode 100644
index 00000000000..c18e55c63dc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/static1.C
@@ -0,0 +1,8 @@
+extern "C" void abort();
+
+struct S
+{
+  static const int i = 3;
+};
+
+const int S::i = 2; // ERROR - duplicate initialization
diff --git a/gcc/testsuite/g++.old-deja/g++.other/static2.C b/gcc/testsuite/g++.old-deja/g++.other/static2.C
new file mode 100644
index 00000000000..471448d3300
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/static2.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// Based on a test case by Koos Vriezen <koos@polder.ubc.kun.nl>
+
+struct foo {
+    static void (*mystatic) ();
+};
+
+void bar(foo& t) {
+    t.mystatic ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/static3.C b/gcc/testsuite/g++.old-deja/g++.other/static3.C
new file mode 100644
index 00000000000..b75771e76e2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/static3.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+class S 
+{
+  ~S();
+public:
+  friend void f();
+};
+
+
+S::~S()
+{
+  static S s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/static4.C b/gcc/testsuite/g++.old-deja/g++.other/static4.C
new file mode 100644
index 00000000000..70213370b07
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/static4.C
@@ -0,0 +1,9 @@
+// Origin: Andrew Pollard <andrew@odie.demon.co.uk>
+// Special g++ Options: -O
+
+struct A {
+        A(int, int);
+};
+A::A(int, int) {}
+static A _A(0, 0);
+int main() { return(0); }
diff --git a/gcc/testsuite/g++.old-deja/g++.other/string1.C b/gcc/testsuite/g++.old-deja/g++.other/string1.C
new file mode 100644
index 00000000000..425e9bf817c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/string1.C
@@ -0,0 +1,20 @@
+// Build don't link:
+// Origin: mrs@wrs.com (Mike Stump)
+
+class Wrapper {
+public:
+  static const char msgPtr[];
+  static const char *JunkFunc() {
+    return &msgPtr[0];
+  }
+};
+ 
+const char Wrapper::msgPtr[] = "Hello world.";
+ 
+int main() {
+  const char *p1 = &Wrapper::msgPtr[0];
+  const char *p2 = Wrapper::JunkFunc();
+ 
+  if (p1 != p2)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/temporary1.C b/gcc/testsuite/g++.old-deja/g++.other/temporary1.C
new file mode 100644
index 00000000000..93cd7097783
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/temporary1.C
@@ -0,0 +1,40 @@
+extern "C" int printf(char*, ...);
+
+int c, d;
+class Foo 
+{
+public:
+   Foo() { printf("Foo() 0x%08lx\n", (unsigned long)this); ++c; }
+   Foo(Foo const &) { printf("Foo(Foo const &) 0x%08lx\n", (unsigned long)this); }
+   ~Foo() { printf("~Foo() 0x%08lx\n", (unsigned long)this); ++d; }
+};
+
+// Bar creates constructs a temporary Foo() as a default
+class Bar 
+{
+public:
+   Bar(Foo const & = Foo()) { printf("Bar(Foo const &) 0x%08lx\n", (unsigned long)this); }
+};
+
+void fakeRef(Bar *)
+{
+}
+
+int main() 
+{
+   // Create array of Bar. Will use default argument on constructor.
+   // The old compiler will loop constructing Bar. Each loop will
+   // construct a temporary Foo() but will not destruct the Foo(). 
+   // The Foo() temporary is destructed only once after the loop 
+   // completes. This could lead to a memory leak if the constructor 
+   // of Foo() allocates memory.
+   Bar bar[2];
+
+   fakeRef(bar);
+
+   printf("Done\n");
+
+   if (c == d && c == 2)
+     return 0;
+   return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/typeck1.C b/gcc/testsuite/g++.old-deja/g++.other/typeck1.C
new file mode 100644
index 00000000000..6dd5fed5c25
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/typeck1.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+extern int a[][];   // ERROR - invalid multidimensional array
+extern int b[7][];  // ERROR - invalid multidimensional array
+extern int c[][7];  // OK
+
+extern int (*i)[];  // ERROR - previous declaration
+extern int (*i)[7]; // ERROR - conflicting types for `i'
+
+extern int m[];
+extern int m[7];    // OK
+
+void f(int (*j)[3])
+{
+  extern int (*k)[];
+  f(k);             // ERROR - passing wrong type
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/typedef1.C b/gcc/testsuite/g++.old-deja/g++.other/typedef1.C
new file mode 100644
index 00000000000..d44772932ed
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/typedef1.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+typedef const struct {
+   int x;
+} Test;
+
+void foo(Test);
+
+void foo(Test t)
+{
+  t.x = 0; // ERROR - assignment of read-only member
+  return;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/typedef2.C b/gcc/testsuite/g++.old-deja/g++.other/typedef2.C
new file mode 100644
index 00000000000..b12ed13c406
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/typedef2.C
@@ -0,0 +1,10 @@
+//Build don't link:
+struct S{
+
+  static const int i;
+  static const int j;
+};
+
+typedef S T;
+const int T::i = 4;
+const int T::j = 4;
diff --git a/gcc/testsuite/g++.old-deja/g++.other/typedef3.C b/gcc/testsuite/g++.old-deja/g++.other/typedef3.C
new file mode 100644
index 00000000000..465e9a00e7a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/typedef3.C
@@ -0,0 +1,14 @@
+//Build don't link:
+template<class T>
+struct X{
+  T v;
+  X(){}
+  virtual ~X(){}
+  virtual inline T f(T x){return x;}
+};
+
+void f()
+{
+  typedef int H;
+  X<H> y;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/typedef4.C b/gcc/testsuite/g++.old-deja/g++.other/typedef4.C
new file mode 100644
index 00000000000..8b5ba499406
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/typedef4.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+struct A {
+  void f ();
+};
+
+typedef A foo;
+
+void foo::f() { }
diff --git a/gcc/testsuite/g++.old-deja/g++.other/typedef5.C b/gcc/testsuite/g++.old-deja/g++.other/typedef5.C
new file mode 100644
index 00000000000..d8f74aee938
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/typedef5.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+// by Alexandre Oliva <oliva@dcc.unicamp.br>
+
+typedef int t;
+typedef t* u;
+typedef u v;
+typedef v* (*w)(t);
+typedef int t;
+typedef t* u;
+typedef u v;
+typedef v* (*w)(t const); // this is ok
+typedef v* (*w)(t); // ERROR - covers message `previously declared here'
+typedef v* (*const w)(t); // ERROR - invalid redeclaration
+typedef v const* (*w)(t); // ERROR - invalid redeclaration
+typedef v* const (*w)(t); // ERROR - invalid redeclaration
diff --git a/gcc/testsuite/g++.old-deja/g++.other/typedef6.C b/gcc/testsuite/g++.old-deja/g++.other/typedef6.C
new file mode 100644
index 00000000000..53b81669172
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/typedef6.C
@@ -0,0 +1,17 @@
+// Submitted by Jason Merrill <jason@cygnus.com>.
+// Bug: g++ fails to see through the T typedef in the C ctor.
+// Build don't link:
+
+struct A {
+  A (int) { }
+};
+
+typedef A T;
+
+struct B: public virtual T {
+  B (): T(1) { }
+};
+
+struct C: public B {
+  C (): T(1) { }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/typeinfo1.C b/gcc/testsuite/g++.old-deja/g++.other/typeinfo1.C
new file mode 100644
index 00000000000..070e885fe91
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/typeinfo1.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+#include <typeinfo>
+
+struct S {
+  S (const char*);
+};
+
+void f(S s);
+void f(type_info);
+
+void g()
+{
+  f("abc");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/typename1.C b/gcc/testsuite/g++.old-deja/g++.other/typename1.C
new file mode 100644
index 00000000000..2921b3d3c02
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/typename1.C
@@ -0,0 +1,17 @@
+// This code snippet should be rejected with -pedantic
+// Based on a test case by Louidor Erez <s3824888@techst02.technion.ac.il>
+
+// Build don't link:
+// Special g++ Options: -pedantic
+
+template<class T>
+class Vector {
+public:
+  typedef T* iterator;
+};
+
+template<class T>
+void f()
+{
+  Vector<T>::iterator i = 0; // ERROR - missing typename - XFAIL *-*-*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/union1.C b/gcc/testsuite/g++.old-deja/g++.other/union1.C
new file mode 100644
index 00000000000..6573b4d055f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/union1.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+class A
+{
+  private:
+    int myInt;
+
+  public:
+    A& operator = (int right) {myInt = right; return *this;}
+};
+
+union B
+{
+    char f1;
+    A    f2;   // gets bogus error - non-copy assignment op is OK
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/using1.C b/gcc/testsuite/g++.old-deja/g++.other/using1.C
new file mode 100644
index 00000000000..d22d512f64b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/using1.C
@@ -0,0 +1,26 @@
+class D2;
+
+class B {
+private:
+  int a; // ERROR - B::a is private
+protected:
+  int b;
+
+  friend class D2;
+};
+
+class D : public B {
+public:
+  using B::a;
+  using B::b;
+}; // ERROR - within this context
+
+class D2 : public B {
+public:
+  using B::a;
+  using B::b;
+
+private:
+  using B::b; 
+}; // ERROR - conflicting access specifications
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.other/using2.C b/gcc/testsuite/g++.old-deja/g++.other/using2.C
new file mode 100644
index 00000000000..2924498e35a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/using2.C
@@ -0,0 +1,10 @@
+// Build don't link:
+struct X{
+  void f();        
+};
+
+struct Y:X{
+  void f(int);
+  void f();         // ERROR - conflict
+  using X::f;
+};                  // ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.other/using3.C b/gcc/testsuite/g++.old-deja/g++.other/using3.C
new file mode 100644
index 00000000000..7d75d8a8794
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/using3.C
@@ -0,0 +1,12 @@
+// Build don't link:
+struct A{
+  A();
+};
+
+typedef struct {
+  A i;
+} S;
+
+struct B: S{
+  using S::S;        // ERROR - no such field
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/using4.C b/gcc/testsuite/g++.old-deja/g++.other/using4.C
new file mode 100644
index 00000000000..218ffe2a85c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/using4.C
@@ -0,0 +1,20 @@
+// Build don't link:
+
+// Based on a testcase by Martin Bachtold <martinb@coyotesystems.com>
+
+// excess errors test - XFAIL *-*-*
+
+struct foo {
+  void m();
+};
+
+struct bar : foo {
+  using foo::m;
+  void m(int);
+};
+
+void f() {
+  bar b;
+  b.m();
+  b.m(1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/using5.C b/gcc/testsuite/g++.old-deja/g++.other/using5.C
new file mode 100644
index 00000000000..65dc9522a76
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/using5.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+// Based on bug report by Klaus-Georg Adams
+// <Klaus-Georg.Adams@chemie.uni-karlsruhe.de>
+
+struct bar {
+  typedef bar t;
+};
+
+struct foo : bar {
+  using bar::t;
+  t field;
+  t meth();
+  void baz(t arg);
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/virtual1.C b/gcc/testsuite/g++.old-deja/g++.other/virtual1.C
new file mode 100644
index 00000000000..28483177bf9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/virtual1.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+struct S0 { virtual void f1 () { } };
+
+struct S1 : virtual public S0 { virtual void f1 () { } };
+
+struct S2 : public S1 { virtual void f1 () { } };
+
+struct S3 : virtual public S0 { virtual void f1 () { } };
+
+struct S4 : public S3 { };
+
+void creator () { new S4; }
diff --git a/gcc/testsuite/g++.old-deja/g++.other/virtual2.C b/gcc/testsuite/g++.old-deja/g++.other/virtual2.C
new file mode 100644
index 00000000000..a3ebbcd40e1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/virtual2.C
@@ -0,0 +1,19 @@
+struct B
+{
+  virtual int f() volatile
+    { return 0; }
+};
+
+
+struct D : public B 
+{
+  virtual int f()
+    { return 1; }
+};
+
+int main()
+{
+  volatile D d;
+  volatile B& b = d;
+  return b.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/virtual3.C b/gcc/testsuite/g++.old-deja/g++.other/virtual3.C
new file mode 100644
index 00000000000..b9a77191030
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/virtual3.C
@@ -0,0 +1,24 @@
+struct B
+{
+  virtual int f() volatile
+    { return 1; }
+};
+
+struct D : public B 
+{
+  int f() 
+    { return 0; }
+};
+
+struct D2 : public D
+{
+  int f()
+    { return 2; } 
+};
+
+int main()
+{
+  D2 d2;
+  D& d = d2;
+  return d.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/virtual4.C b/gcc/testsuite/g++.old-deja/g++.other/virtual4.C
new file mode 100644
index 00000000000..8a44ee14135
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/virtual4.C
@@ -0,0 +1,25 @@
+// Build don't link:
+
+class A {
+public:
+  virtual int foo() = 0; // ERROR - original definition
+};
+
+class B {
+public:
+    virtual double foo() = 0;
+};
+
+class C
+  : public A, public B
+{
+public:
+  virtual double foo() { return 2; } // ERROR - conflicting return type
+};
+
+class D
+  : public B, public A
+{
+public:
+  virtual double foo() { return 2; } // ERROR - conflicting return type
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.other/vtbl1.C b/gcc/testsuite/g++.old-deja/g++.other/vtbl1.C
new file mode 100644
index 00000000000..4724ee1b497
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/vtbl1.C
@@ -0,0 +1,15 @@
+// Build don't run:
+// Origin: DJ Delorie <dj@delorie.com>
+
+class X {
+public:
+  int i;
+  X() { i = 0; }
+  ~X();
+  virtual int foo() { return i; }
+  virtual void bar();
+};
+
+int main()
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.other/warn01.C b/gcc/testsuite/g++.old-deja/g++.other/warn01.C
new file mode 100644
index 00000000000..229363a3ec0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/warn01.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// Special g++ Options: -W -Wall
+
+typedef unsigned long size_t;
+extern void* malloc (size_t);
+extern void free (void*);
+extern void* realloc (void*, size_t);
+
+struct vtable {
+  void* (* _malloc) (size_t);
+  void (* _free) (void*);
+  void* (* _realloc) (void*, size_t);
+};
+
+struct vtable mtable = { malloc, free };  // WARNING - _realloc
diff --git a/gcc/testsuite/g++.old-deja/g++.other/warn3.C b/gcc/testsuite/g++.old-deja/g++.other/warn3.C
new file mode 100644
index 00000000000..4827c5645f2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/warn3.C
@@ -0,0 +1,54 @@
+// Build don't link:
+
+class A {
+};
+
+
+class B {
+public:
+  void f();
+
+private:
+  B (); 
+  B (const B&);
+}; // WARNING - only private constructors
+
+
+class C { 
+public: 
+  void f();
+
+private:
+  ~C (); 
+}; // WARNING - only private destructors
+
+
+class D {
+private:
+  void f(); 
+}; // WARNING - all member functions are private
+
+
+template <class T>
+class X {
+private:
+  ~X (); 
+}; // WARNING - only private destructors
+
+template class X<int>;
+template class X<double>;
+
+
+template <class T>
+class Y {
+private:
+  Y (); 
+  Y (const Y&);
+}; // WARNING - only private constructors
+
+
+template <class T>
+class Z {
+private:
+  void f(); 
+}; // WARNING - all member functions are private
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/alignof.C b/gcc/testsuite/g++.old-deja/g++.pt/alignof.C
new file mode 100644
index 00000000000..0cfeed4084c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/alignof.C
@@ -0,0 +1,21 @@
+extern "C" void abort();
+
+struct S
+{
+  char c;
+  double d;
+};
+
+
+template <class T>
+void foo(T)
+{
+  if (__alignof__(T) != __alignof__(S))
+    abort();
+}
+
+
+int main()
+{
+  foo(S());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/array1.C b/gcc/testsuite/g++.old-deja/g++.pt/array1.C
new file mode 100644
index 00000000000..669600f0443
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/array1.C
@@ -0,0 +1,10 @@
+template <class T, unsigned N>
+  unsigned size(T (&)[N]) { return N; }
+template <class T, unsigned N>
+  unsigned size(T const (&)[N]) { return N; }
+
+int main() {
+  short iarray[] = { 1, 2, 3, 4, 5 };
+  const short carray[] = { 1, 2, 3, 4, 5 };
+  return size(iarray) - size(carray);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/array2.C b/gcc/testsuite/g++.old-deja/g++.pt/array2.C
new file mode 100644
index 00000000000..6c5810ed77b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/array2.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+template<int N, class C>
+class Bar {};
+
+template<class C>
+class Huh {};
+
+template<int N>
+void foo(const Bar<N,Huh<float[1]> > &x) {}
+
+int main() {
+  foo(Bar<3,Huh<float[1]> >());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/array3.C b/gcc/testsuite/g++.old-deja/g++.pt/array3.C
new file mode 100644
index 00000000000..ec5e1e0e3a7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/array3.C
@@ -0,0 +1,5 @@
+// Build don't link:
+// Origin: Brendan Kehoe <brendan@cygnus.com>
+
+ template <int x> int foo(char[4][x]) { return x; }
+ int (*bar)(char[4][3]) = &foo;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/array4.C b/gcc/testsuite/g++.old-deja/g++.pt/array4.C
new file mode 100644
index 00000000000..fab2d5b1527
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/array4.C
@@ -0,0 +1,14 @@
+// Test to make sure that the array bounds are treated as an expression
+// in template parm substitution.
+
+// Written by Jason Merrill <jason@cygnus.com>
+
+// Build don't link:
+
+template <class T> void f (T t) { int ar[sizeof (T)]; }
+
+int
+main ()
+{
+  f (1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/assign1.C b/gcc/testsuite/g++.old-deja/g++.pt/assign1.C
new file mode 100644
index 00000000000..dfdaab27010
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/assign1.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class T>
+struct S {
+  S();
+  T t;
+};
+
+void f()
+{
+  S<const int> s;
+  s = s; // ERROR - generated assignment operator is illegal
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/auto_ptr.C b/gcc/testsuite/g++.old-deja/g++.pt/auto_ptr.C
new file mode 100644
index 00000000000..dd5b988b316
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/auto_ptr.C
@@ -0,0 +1,54 @@
+template <typename Y> struct auto_ptr_ref {
+  Y* py;
+  auto_ptr_ref(Y* p) : py(p) {}
+};
+template<typename X> struct auto_ptr {
+   X* px;
+ public:
+   typedef X element_type;
+
+   explicit auto_ptr(X* p =0) throw() : px(p) {}
+   auto_ptr(auto_ptr& r) throw() : px(r.release()) {}
+   template<typename Y>
+      auto_ptr(auto_ptr<Y>& r) throw() : px(r.release()) {}
+
+   auto_ptr& operator=(auto_ptr& r) throw() { 
+      reset(r.release()); 
+      return *this;
+   }
+   template<typename Y> auto_ptr& operator=(auto_ptr<Y>& r) throw() { 
+      reset(r.release()); 
+      return *this;
+   }
+
+   ~auto_ptr() { delete px; }
+
+   X& operator*() const throw() { return *px; }
+   X* operator->() const throw() { return px; }
+   X* get() const throw() { return px; }
+   X* release() throw() { X* p=px; px=0; return p; }
+   void reset(X* p=0) throw() { if (px != p) delete px, px = p; }
+
+   auto_ptr(auto_ptr_ref<X> r) throw() : px(r.py) {}
+   template<typename Y> operator auto_ptr_ref<Y>() throw() {
+      return auto_ptr_ref<Y>(release()); 
+   }
+   template<typename Y> operator auto_ptr<Y>() throw() { 
+      return auto_ptr<Y>(release());
+   }
+};
+
+struct Base { Base() {} virtual ~Base() {} };
+struct Derived : Base { Derived() {}; };
+
+auto_ptr<Derived> f() { auto_ptr<Derived> null(0); return null; }
+void g(auto_ptr<Derived>) { }
+void h(auto_ptr<Base>) { }
+
+int main() {
+    auto_ptr<Base> x(f());
+    auto_ptr<Derived> y(f());
+    x = y;
+    g(f());
+    h(f());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/bad-type.C b/gcc/testsuite/g++.old-deja/g++.pt/bad-type.C
new file mode 100644
index 00000000000..6b22b86a30f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/bad-type.C
@@ -0,0 +1,19 @@
+template<class Type>
+class A
+{
+public:
+  Type m;
+};
+
+template<class Type>
+void f(A<Type>& a, Type d)
+{
+  A.m=d; // ERROR - invalid use of template
+}
+
+int main()
+{
+  A<int> a;
+  f(a,2);
+}
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/call1.C b/gcc/testsuite/g++.old-deja/g++.pt/call1.C
new file mode 100644
index 00000000000..b9836bbcc5a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/call1.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+struct IsCompressed { };
+struct Field {
+  bool IsCompressed() const { return true; }
+};
+
+template<class C>
+inline bool
+for_each(const Field& p, IsCompressed, C)
+{
+  return p.IsCompressed();
+}
+
+template bool for_each<int>(const Field& p, IsCompressed, int);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/call2.C b/gcc/testsuite/g++.old-deja/g++.pt/call2.C
new file mode 100644
index 00000000000..51b246948ed
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/call2.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+struct IsCompressed { };
+struct Field {
+};
+
+template<class C>
+inline bool
+for_each(const Field& p, IsCompressed, C)
+{
+  return p.IsCompressed(); // ERROR - calling type like a method
+}
+
+template bool for_each<int>(const Field& p, IsCompressed, int); // ERROR - instantiated from here
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/cast1.C b/gcc/testsuite/g++.old-deja/g++.pt/cast1.C
new file mode 100644
index 00000000000..e37b1693155
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/cast1.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class T>
+void f (T t) {
+  const_cast<T>(t);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/const1.C b/gcc/testsuite/g++.old-deja/g++.pt/const1.C
new file mode 100644
index 00000000000..8ac8a51bf9d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/const1.C
@@ -0,0 +1,4 @@
+// Build don't link:
+template <class T> struct B { static const int i = 3; };
+template <class T> struct A { static const int i = B<T>::i; };
+enum { i = A<int>::i };
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/conv1.C b/gcc/testsuite/g++.old-deja/g++.pt/conv1.C
new file mode 100644
index 00000000000..19e433e2f70
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/conv1.C
@@ -0,0 +1,19 @@
+// Build don't link:
+
+template <class T>
+struct S1 {};
+
+struct S2
+{
+  template <class T>
+  operator S1<T>*();
+};
+
+struct D: public S1<int> {
+};
+
+void f()
+{
+  S2 s;
+  (D*) s; // ERROR - cannot convert
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/conv2.C b/gcc/testsuite/g++.old-deja/g++.pt/conv2.C
new file mode 100644
index 00000000000..f3e0b359e19
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/conv2.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+template<class T>
+class A {
+public:
+  operator const T*() const;
+  const T* cast() const;
+};
+
+template<class T>
+const T* A<T>::cast() const {
+  return operator const T*();
+}
+
+template class A<char>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/copy1.C b/gcc/testsuite/g++.old-deja/g++.pt/copy1.C
new file mode 100644
index 00000000000..7981530f697
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/copy1.C
@@ -0,0 +1,29 @@
+int i = 0;
+
+template <class T>
+class F 
+{
+public:
+  F() {}
+  
+  template <class T2> F(F<T2>) 
+    {
+      i = 1;
+    }      
+};
+
+
+F<int>
+foo()
+{
+  F<int> f1;
+  F<int> f2(f1);
+  return f1;
+}
+
+int
+main()
+{
+  return i;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash1.C b/gcc/testsuite/g++.old-deja/g++.pt/crash1.C
new file mode 100644
index 00000000000..3d3dd5e09b6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash1.C
@@ -0,0 +1,11 @@
+template<class T> class A {
+    public:
+        class subA {};
+};
+
+
+template<class T> class B : public A<T> {
+    public:
+  class subB : public A::subA {}; // ERROR - not a class or namespace
+};
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash10.C b/gcc/testsuite/g++.old-deja/g++.pt/crash10.C
new file mode 100644
index 00000000000..033e2341c24
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash10.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+template<int M, int N>
+class GCD {
+public:
+  enum { val = (N == 0) ? M : GCD<N, M % N>::val }; 
+};
+
+int main() {
+  GCD< 1, 0 >::val; // ERROR - division
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash11.C b/gcc/testsuite/g++.old-deja/g++.pt/crash11.C
new file mode 100644
index 00000000000..30c72a679f2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash11.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+class A
+{
+      class A_impl;
+   public: 
+      A(){}
+};
+
+
+template <class j> class A::A_impl 
+{ // ERROR - does not declare a template
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash12.C b/gcc/testsuite/g++.old-deja/g++.pt/crash12.C
new file mode 100644
index 00000000000..ade8139c45d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash12.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// Special g++ Options: -g
+
+template <class C>
+class CenteringTag {
+};
+
+struct S {
+  template <class B, class C>
+  static void f() {
+    CenteringTag<C> ctag;
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash13.C b/gcc/testsuite/g++.old-deja/g++.pt/crash13.C
new file mode 100644
index 00000000000..f3de38e6be1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash13.C
@@ -0,0 +1,6 @@
+// Build don't link:
+
+template <class T> struct A {};
+template <class T> struct A<T>;    // ERROR - does not specialize args
+template <class T> const struct A; // ERROR - parse error
+template <class T> template A<int>; // ERROR - .*
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash14.C b/gcc/testsuite/g++.old-deja/g++.pt/crash14.C
new file mode 100644
index 00000000000..f698316b511
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash14.C
@@ -0,0 +1,5 @@
+// Build don't link:
+
+template <class T> struct A {};
+template <class T> struct A<T*>;
+A<int*> ai; // ERROR - incomplete type
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash15.C b/gcc/testsuite/g++.old-deja/g++.pt/crash15.C
new file mode 100644
index 00000000000..75b10544ac9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash15.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+template <class T>
+template <class U>
+struct A { // ERROR - too many template parameter lists
+public:
+  A() {}
+
+  A(const A<T>& b) {} // ERROR - invalid use of template
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash16.C b/gcc/testsuite/g++.old-deja/g++.pt/crash16.C
new file mode 100644
index 00000000000..ed12b909ca2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash16.C
@@ -0,0 +1,28 @@
+// Build don't link:
+// Special g++ Options:
+
+extern "C" void qsort();
+
+struct R {
+  int count;
+  int state1;
+  int state2;
+};
+
+int cmp_d(const R* a, const R* b) {
+  return a->count > b->count;
+}
+
+namespace CXX {
+  template<class T, int i1, int i2>
+    inline void qsort (T b[i1][i2], int (*cmp)(const T*, const T*)) {
+    ::qsort ((void*)b, i1*i2, sizeof(T), (int (*)(const void *, const void *))cmp);
+  }
+}
+
+using namespace CXX;
+
+void sort_machine() {
+  struct R d[256][256];
+  qsort<R,256> (d, cmp_d);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash17.C b/gcc/testsuite/g++.old-deja/g++.pt/crash17.C
new file mode 100644
index 00000000000..c4dd969d1e7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash17.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+template <int B>
+class foo;
+
+template <class U>
+class bar
+{
+  typedef foo<(U::id > 0)> foobar;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash18.C b/gcc/testsuite/g++.old-deja/g++.pt/crash18.C
new file mode 100644
index 00000000000..b12c702e856
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash18.C
@@ -0,0 +1,23 @@
+// Build don't run:
+
+template<class T>
+class foo {
+  T deft;
+
+  template<class U> int priv (U u, T t) { return u - t; }
+public:
+  foo (T t) : deft (t) {}
+
+  template<class U> int pub (U u) {
+    int (foo::*fn) (U, T);
+    fn = &foo<T>::template priv<U>;
+    return (this->*fn) (u, deft);
+  }
+};
+
+int
+main ()
+{
+  foo<long> fff (5);
+  return fff.pub (3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash19.C b/gcc/testsuite/g++.old-deja/g++.pt/crash19.C
new file mode 100644
index 00000000000..2da6dd9bbbf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash19.C
@@ -0,0 +1,19 @@
+// Build don't link:
+
+template <int I>
+void f()
+{
+  class C { public: int c; };
+
+  struct S {
+    void g() {
+      C e;
+      e.c = 3;
+    };
+  };
+
+  S s;
+  s.g();
+}
+
+template void f<7>();
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash2.C b/gcc/testsuite/g++.old-deja/g++.pt/crash2.C
new file mode 100644
index 00000000000..3b900c77de7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash2.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+template <class T> 
+struct S1
+{
+  T* t;
+  static int foo;
+};
+
+
+struct S2 : public S1<S2>
+{
+  S2* s;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash20.C b/gcc/testsuite/g++.old-deja/g++.pt/crash20.C
new file mode 100644
index 00000000000..29b4281c76e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash20.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+template <class T = int>
+struct A { const T x; A() : x(0) { } A(T x) : x(x) { } }; 
+
+template <class B>
+void func () { B y; y = B(); } // ERROR - can't use default assignment
+
+int main (void) { func< A<> >(); } // ERROR - instantiated from here
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash21.C b/gcc/testsuite/g++.old-deja/g++.pt/crash21.C
new file mode 100644
index 00000000000..c84809b38dc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash21.C
@@ -0,0 +1,26 @@
+// Build don't link:
+// Special g++ Options:
+
+class Pooled
+{
+};
+
+class RefCounted
+{
+};
+
+class BrickExpressionBase : public RefCounted, public Pooled
+{
+};
+
+template<unsigned Dim, class LHS, class RHS, class OP>
+class BrickExpression : public BrickExpressionBase
+{
+};
+
+template <unsigned Dim, class T>
+void f()
+{
+  typedef BrickExpression<Dim, T, T, T> ExprT;
+  ExprT(3).apply;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash22.C b/gcc/testsuite/g++.old-deja/g++.pt/crash22.C
new file mode 100644
index 00000000000..e947ef3ffe4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash22.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+template <class T>
+struct S1 {};
+
+template <class T, class U = S1<T> > 
+struct S2 {};
+
+template struct S2<100>; // ERROR - type/value mismatch
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash23.C b/gcc/testsuite/g++.old-deja/g++.pt/crash23.C
new file mode 100644
index 00000000000..ac4fae02b0b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash23.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template <class A, class B> void foo();
+template <class C> class bar {
+public:
+  int i;
+  template <class B> friend void foo<C,B>(); // ERROR - template-id
+};
+template <class A, class B> void foo() {
+  bar<A> baz; baz.i = 1;
+  bar<int> buz; buz.i = 1;
+}
+int main() {
+  foo<void,void>();
+  foo<int,void>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash24.C b/gcc/testsuite/g++.old-deja/g++.pt/crash24.C
new file mode 100644
index 00000000000..9c31af6017f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash24.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+template<typename T, template <class> class U> void template_fn (T);
+template<typename T> void callme ( void (*)(T));
+
+template<typename T> struct S1;
+
+int main()
+{
+  callme(&template_fn<double, S1>);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash25.C b/gcc/testsuite/g++.old-deja/g++.pt/crash25.C
new file mode 100644
index 00000000000..f5875854562
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash25.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+template <class T>
+void f()
+{
+  int i[1 << 3];
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash26.C b/gcc/testsuite/g++.old-deja/g++.pt/crash26.C
new file mode 100644
index 00000000000..d2101bd3b63
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash26.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// Origin: Theodore Papadopoulo <Theodore.Papadopoulo@sophia.inria.fr>
+
+double f(double);
+typedef double (*M)(double);
+
+class A {
+public:
+	template <const M n> void g(); 
+};
+
+class B: public A {
+public:
+	void g() { A::g<f>(); }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash27.C b/gcc/testsuite/g++.old-deja/g++.pt/crash27.C
new file mode 100644
index 00000000000..f52f1ba9e02
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash27.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+template<int i> int f (void)
+{
+        if (__extension__ ({ 1; }))
+                return 0;
+        return 1;
+}
+
+void g (void)
+{
+        f<1> ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash28.C b/gcc/testsuite/g++.old-deja/g++.pt/crash28.C
new file mode 100644
index 00000000000..752c9706990
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash28.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Special g++ Options:
+
+template <class ARRY>
+inline unsigned int asize(ARRY &a)
+{
+  return sizeof(a) / sizeof(a[0]);
+}
+
+int f(unsigned int n) {
+  int x[n];
+
+  asize(x); // ERROR - no matching function
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash29.C b/gcc/testsuite/g++.old-deja/g++.pt/crash29.C
new file mode 100644
index 00000000000..05bef969836
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash29.C
@@ -0,0 +1,69 @@
+// Build don't link:
+// Origin: Steven Parkes <parkes@sierravista.com>
+
+typedef __SIZE_TYPE__ size_t;
+
+class UUId {};
+
+template <class T> class MetaClass;
+
+class TypeInfo;
+
+struct MetaClassGeneric 
+{
+                                MetaClassGeneric( TypeInfo& );
+};
+
+struct TypeInfo 
+{
+                        void    (*constructor)( void* );
+                        void    initialize( void* );
+};
+
+template <class T>
+class TypeIDInit {
+public:
+                                TypeIDInit();
+                 static void    initialize();
+             static TypeInfo    info;
+                  static int    storage[];
+                 static void    metaclassConstructor( void* );
+};
+
+template <class T>
+TypeInfo TypeIDInit<T>::info = 
+{
+  TypeIDInit<T>::metaclassConstructor
+};
+
+template <class T>
+inline
+TypeIDInit<T>::TypeIDInit()
+{
+  info.initialize(storage);
+}
+
+template <class T>
+class NameInfo : public MetaClassGeneric {
+public:
+                                NameInfo() 
+				: MetaClassGeneric( TypeIDInit<T>::info ) {}
+};
+
+class MetaClass<UUId>
+: public NameInfo<UUId>
+{
+};
+
+extern "C++"
+inline void *operator new(size_t, void *place) throw() { return place; }
+
+template <class T>
+void
+TypeIDInit<T>::metaclassConstructor( void* place )
+{
+  new ( place ) MetaClass<T>;
+}
+
+template class   TypeIDInit<UUId>   ;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash3.C b/gcc/testsuite/g++.old-deja/g++.pt/crash3.C
new file mode 100644
index 00000000000..0d2a7cd935d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash3.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template <class Type>
+class CVector {
+public:
+    CVector<int> f() const
+    {
+       CVector<int> v(n);
+       return v;
+    }
+    CVector<long> g() const
+    {
+       CVector<long> v(n);
+       return v;
+    }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash30.C b/gcc/testsuite/g++.old-deja/g++.pt/crash30.C
new file mode 100644
index 00000000000..13dc37af68d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash30.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+extern "C" int printf(const char *, ...);
+template <class T> struct A {
+  typedef typename T::X B; // ERROR - not a class
+  A(double);
+};
+ 
+template <class T> void xxx(typename A<T>::B);
+ 
+template <class T> struct B {
+  friend void xxx<T>(T); // ERROR - does not match any template
+};
+ 
+template struct B<double>; // ERROR - 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash31.C b/gcc/testsuite/g++.old-deja/g++.pt/crash31.C
new file mode 100644
index 00000000000..34758967c2e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash31.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Origin: Corey Kosak
+
+struct cow_t {
+  template<bool Q>
+  static void tfunc(cow_t *cowp) {}
+
+  void moo() {
+    cow_t *cowp;
+    cow_t::tfunc<true>(cowp);
+  }
+};
+
+
+int main()
+{
+  cow_t *cowp;
+  cow_t::tfunc<true>(cowp);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash32.C b/gcc/testsuite/g++.old-deja/g++.pt/crash32.C
new file mode 100644
index 00000000000..68cf4df6fb2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash32.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// Origin: Jason Merrill <jason@cygnus.com>
+
+template <class T> struct A
+{
+  struct B;
+};
+
+template<class T> struct C
+{
+  friend typename A<T>::B;
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash33.C b/gcc/testsuite/g++.old-deja/g++.pt/crash33.C
new file mode 100644
index 00000000000..bc7dcf5c4c7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash33.C
@@ -0,0 +1,17 @@
+// Build don't link:
+// Origin: Theodore Papadopoulo <Theodore.Papadopoulo@sophia.inria.fr>
+
+class A {
+public:
+        template <class T> T& f(T& t) const;
+};
+
+class B {
+public:
+        template <class T> T& f(T& t) const;
+};
+
+class C: public A,B {
+public:
+        template <class T> T& f(T& t) const;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash34.C b/gcc/testsuite/g++.old-deja/g++.pt/crash34.C
new file mode 100644
index 00000000000..d178a406fb2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash34.C
@@ -0,0 +1,20 @@
+// Build don't link:
+// Origin: Theodore Papadopoulo <Theodore.Papadopoulo@sophia.inria.fr>
+
+template <class T>
+class A {
+public:
+        class B { };
+        class C: public B {
+        public:
+                C(A&):B() { }
+        };
+        C f() { return C(*this); }
+};
+
+int
+main()
+{
+        A<int> a;
+        a.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash35.C b/gcc/testsuite/g++.old-deja/g++.pt/crash35.C
new file mode 100644
index 00000000000..d4084fea2fb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash35.C
@@ -0,0 +1,11 @@
+// Build don't link:
+// Origin: Miniussi <miniussi@ilog.fr>
+
+template <class O>
+struct Str {
+  Str(int& val= (*new int())); 
+};
+
+template<class O>
+Str<O>::Str(int& val) {}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash36.C b/gcc/testsuite/g++.old-deja/g++.pt/crash36.C
new file mode 100644
index 00000000000..b5281c32b61
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash36.C
@@ -0,0 +1,35 @@
+// Build don't link:
+// Origin: Andreas Kloeckner <ak@ixion.net>
+
+template<class Iterator> struct iterator_traits {
+  typedef typename Iterator::iterator_category 
+  iterator_category; // ERROR - no type iterator_category
+};
+
+template<class Category>
+struct iterator {
+  typedef Category  iterator_category;
+};
+
+
+template <class Iterator>
+struct reverse_iterator : public
+iterator<typename iterator_traits<Iterator>::iterator_category> {
+  protected:
+  Iterator current;
+  
+};
+class tag { };
+
+template <class T>
+struct list {
+  template <class Item>
+  struct list_iterator {
+  };
+  
+  reverse_iterator<list_iterator<T> > rbegin()
+    { return reverse_iterator<list_iterator<T> > // ERROR - no type
+	(list_iterator<T>(Head->next())); } // ERROR - instantiated here
+};
+
+template class list<int>; // ERROR - instantiated from here
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash37.C b/gcc/testsuite/g++.old-deja/g++.pt/crash37.C
new file mode 100644
index 00000000000..c2325bffa8a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash37.C
@@ -0,0 +1,22 @@
+// Build don't link:
+// Origin: Jens Maurer <jmaurer@menuett.rhein-main.de>
+
+template<class T, void (T::*f)(int)>
+class C { };
+
+template<class T>
+C<T, &T::output> call(T& obj)
+{   	return C<T, &T::output>();
+}
+
+class Test {
+public:
+	void output(int);
+};
+
+void sub()
+{
+	Test t;
+	call(t);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash38.C b/gcc/testsuite/g++.old-deja/g++.pt/crash38.C
new file mode 100644
index 00000000000..49270644395
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash38.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class T>
+struct S {
+  typedef typename T::Y<T>::Z X; // ERROR - No Y in A
+  X x; // ERROR - No Y in A
+};
+
+struct A {
+  struct Y {
+    typedef A Z;
+  };
+};
+
+template struct S<A>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash39.C b/gcc/testsuite/g++.old-deja/g++.pt/crash39.C
new file mode 100644
index 00000000000..2c4bb5a4115
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash39.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Origin: Ian Nixon <ian@tharas.com>
+
+class Action {
+public:
+  virtual void action () = 0;
+};
+
+class Var {
+public:
+
+  template<class Base> void Add() {
+	struct tmp : public Action {
+	  void action () {}
+	};
+	tmp *tp = new tmp; 
+  }
+
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash4.C b/gcc/testsuite/g++.old-deja/g++.pt/crash4.C
new file mode 100644
index 00000000000..510d4cdd836
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash4.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+template <unsigned rank>
+class Tensor
+{
+};
+
+template <unsigned rank>
+class Tensor<2> : Tensor<rank> { // ERROR - template parameters not used
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash40.C b/gcc/testsuite/g++.old-deja/g++.pt/crash40.C
new file mode 100644
index 00000000000..da828d98510
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash40.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Origin: rch@larissa.sd.bi.ruhr-uni-bochum.de
+
+template< class X >
+struct VB: public virtual X
+{};
+
+template< class MOPTerm1, class MOPTerm2 >
+struct MOPTermUnify
+{
+  struct MO:
+    public VB<MOPTerm1>,
+    public VB<MOPTerm2>
+  {
+    void   fix()
+      { 
+      }
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash5.C b/gcc/testsuite/g++.old-deja/g++.pt/crash5.C
new file mode 100644
index 00000000000..5797eee23e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash5.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template <class T, int i>
+struct K {
+	void f();
+};  // ERROR - forward declaration
+
+template <class T>
+void
+K<T, i>::f()
+{ // ERROR - template parameters
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash6.C b/gcc/testsuite/g++.old-deja/g++.pt/crash6.C
new file mode 100644
index 00000000000..09e8df07973
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash6.C
@@ -0,0 +1,23 @@
+// Build don't link:
+
+template <class T> class List;
+ 
+template <class T>
+struct ListIterator
+{
+  ListIterator ();
+  ListIterator (const ListIterator<T>& rhs);
+};
+
+template <class T>
+struct List
+{
+  void length () const {
+    for (ListIterator<T> li; li; ); // ERROR - used where a `bool'
+  }
+};
+
+void test(List<int>& vals)
+{
+  vals.length();  // ERROR - instantiated from here
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash7.C b/gcc/testsuite/g++.old-deja/g++.pt/crash7.C
new file mode 100644
index 00000000000..9ee7b2c665d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash7.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+class foo 
+{
+};
+
+template <class T : public foo> // ERROR - base clause
+struct bar
+{
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash8.C b/gcc/testsuite/g++.old-deja/g++.pt/crash8.C
new file mode 100644
index 00000000000..deff42dba89
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash8.C
@@ -0,0 +1,34 @@
+// Build don't link:
+
+template<class T>
+class TestClass1 {
+public:
+  TestClass1() { } 
+};
+
+template<class T>
+class TestClass2 {
+public:
+  TestClass2() { } 
+  T operator()(int) { }
+};
+
+template<class T>
+void doit(T x) {
+  TestClass1<T> q1;
+  q1 = TestClass1<T>();
+  TestClass2<T> q2;
+  q2 = TestClass2<T>();
+
+  TestClass1<T> p1;
+  p1 = TestClass1(); // ERROR - template used as expression
+
+  TestClass2<T> p2;
+  p2 = TestClass2(); // ERROR - template used as expression
+}
+
+int main() {
+  double x;
+  doit(x);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/crash9.C b/gcc/testsuite/g++.old-deja/g++.pt/crash9.C
new file mode 100644
index 00000000000..297b8accaad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/crash9.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+template <class T>
+void f(T) {} // ERROR - parameter has incomplete type
+
+class C;
+
+void g(const C& c)
+{
+  f(c); // ERROR - invalid use of undefined type
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ctor1.C b/gcc/testsuite/g++.old-deja/g++.pt/ctor1.C
new file mode 100644
index 00000000000..9e36706711a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ctor1.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+template <typename _CharT>
+  struct moneypunct
+{
+   moneypunct (); 
+};
+
+template <>
+  moneypunct<char>::moneypunct ();
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ctor2.C b/gcc/testsuite/g++.old-deja/g++.pt/ctor2.C
new file mode 100644
index 00000000000..c2554a2ce56
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ctor2.C
@@ -0,0 +1,13 @@
+// Test for use of template parms in constructor name.
+// Submitted by Jason Merrill <jason@cygnus.com>
+// Build don't link:
+
+template <class T>
+struct A {
+  A<T>();
+};
+
+template <class T>
+A<T>::A<T>()
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/decl1.C b/gcc/testsuite/g++.old-deja/g++.pt/decl1.C
new file mode 100644
index 00000000000..5814251f95e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/decl1.C
@@ -0,0 +1,19 @@
+struct S {
+  template <class T>
+  int f(T), g(T); // ERROR - more than one declarator
+};
+
+template <class T>
+void x(T), y(T); // ERROR - more than one declarator
+
+template <class T>
+struct S2 
+{
+  static int i, j; // OK.
+};
+
+template <class T>
+int S2<T>::i, S2<T>::j; // ERROR - more than one declarator
+
+template <>
+int S2<int>::i, S2<double>::i;  // ERROR - more than one declarator
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/decl2.C b/gcc/testsuite/g++.old-deja/g++.pt/decl2.C
new file mode 100644
index 00000000000..3b4825b6cda
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/decl2.C
@@ -0,0 +1,8 @@
+// Build don't link:
+// crash test - XFAIL *-*-*
+
+// Simplified from testcase by Christophe Boyanique <boyan@imac.u-paris2.fr>
+
+template <class T> struct foo { foo(); };
+template<class T> foo<T>::foo() {}
+T; // ERROR - ICE - XFAIL *-*-*
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/deduct1.C b/gcc/testsuite/g++.old-deja/g++.pt/deduct1.C
new file mode 100644
index 00000000000..a87b2a7566e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/deduct1.C
@@ -0,0 +1,27 @@
+// Build don't link:
+
+template<class CoordinateSystem, class MeshTag>
+struct Mesh { };
+
+struct RectGrid { };
+
+struct RectMesh { };
+
+struct Cartesian { };
+
+template<class CS>
+struct Mesh<CS, RectGrid> { };
+
+template<class CS>
+struct Mesh<CS, RectMesh> : public Mesh<CS, RectGrid> { };
+
+template<class CS>
+void foo(const Mesh<CS, RectGrid> &)
+{
+}
+
+int main()
+{
+  Mesh<Cartesian, RectMesh> m;
+  foo(m);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/defarg.C b/gcc/testsuite/g++.old-deja/g++.pt/defarg.C
new file mode 100644
index 00000000000..314339d1965
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/defarg.C
@@ -0,0 +1,10 @@
+template <class T>
+void f(T t, int i = 10);
+
+template <class T>
+void f(T t, int i) {}
+
+int main()
+{
+  f(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/defarg2.C b/gcc/testsuite/g++.old-deja/g++.pt/defarg2.C
new file mode 100644
index 00000000000..444ecc40b50
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/defarg2.C
@@ -0,0 +1,17 @@
+template <int S=0, class T=int>
+struct X
+{};
+
+template <>
+struct X<0,int>
+{};
+
+template <int S>
+struct X<S,int>
+: X<>
+{};
+
+int main()
+{
+  X<1,int> x;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/defarg3.C b/gcc/testsuite/g++.old-deja/g++.pt/defarg3.C
new file mode 100644
index 00000000000..9a7e0460497
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/defarg3.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template <class T> 
+struct S;
+
+template <class T = int>
+struct S {};
+
+template <class T> 
+struct S;
+
+void f()
+{
+  S<> s;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/defarg4.C b/gcc/testsuite/g++.old-deja/g++.pt/defarg4.C
new file mode 100644
index 00000000000..9d5df8cf2a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/defarg4.C
@@ -0,0 +1,32 @@
+// Build don't link:
+
+template <class T>
+struct S1
+{
+  void foo(T = t());
+
+  static T t();
+};
+
+
+template <class T>
+struct S2
+{
+  void bar();
+};
+
+
+template <class T>
+void S2<T>::bar ()
+{
+  S1<T> st;
+  st.foo();
+}
+
+
+int main()
+{
+  S2<int> s2i;
+  s2i.bar();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/defarg5.C b/gcc/testsuite/g++.old-deja/g++.pt/defarg5.C
new file mode 100644
index 00000000000..6a68bad8251
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/defarg5.C
@@ -0,0 +1,24 @@
+// Build don't link:
+
+template <int dim>
+class Point {
+  public:
+    Point (Point<dim> &);
+    Point<dim> & operator = (Point<dim> &);
+};
+
+
+
+template <int dim>
+class bar{
+  public:
+    void foo (Point<dim> p = Point<dim>());
+};
+
+
+
+template <>
+void bar<2>::foo (Point<2> p) {
+  const int dim = 2;
+  Point<dim> q = p;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/defarg6.C b/gcc/testsuite/g++.old-deja/g++.pt/defarg6.C
new file mode 100644
index 00000000000..0094c5ca7e0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/defarg6.C
@@ -0,0 +1,27 @@
+// Build don't link:
+
+template <class T>
+struct C {
+  template <class U>
+  void f(U); // OK
+
+  template <class V = int>
+  struct I {}; // OK
+
+  template <class W = int>
+  void h(W); // ERROR - default argument
+  
+  template <class Y>
+  void k(Y);
+};
+
+template <class T>
+template <class U = double>
+void C<T>::f(U) {} // ERROR - default argument
+
+template <class X = void*>
+void g(X); // ERROR - default argument
+
+template <class T = double>
+template <class Y>
+void C<T>::k(Y) {} // ERROR - default argument
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/defarg7.C b/gcc/testsuite/g++.old-deja/g++.pt/defarg7.C
new file mode 100644
index 00000000000..0db043fb633
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/defarg7.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+template <int Dim, class T, class EngineTag>
+class Engine {};
+
+struct Brick;
+ 
+template<int Dim, class T = double , class EngineTag = Brick >
+struct ConstArray {
+  static const int dimensions = Engine<Dim, T, EngineTag>::dimensions;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/defarg8.C b/gcc/testsuite/g++.old-deja/g++.pt/defarg8.C
new file mode 100644
index 00000000000..6bb1125259c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/defarg8.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+// Default arguments containing more than one non-nested explicit
+// template argument leads to parse error
+
+template <class T> class foo1;
+template <class T, class U> class foo2;
+
+struct bar {
+  template <class T, class U>
+  bar(int i = foo1<T>::baz, // ok
+      int j = int(foo2<T, U>::baz), // ok
+      int k = foo2<T, U>::baz) {} // gets bogus error - before > - XFAIL *-*-*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/derived1.C b/gcc/testsuite/g++.old-deja/g++.pt/derived1.C
new file mode 100644
index 00000000000..e2275f4328d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/derived1.C
@@ -0,0 +1,24 @@
+// Build don't link:
+
+class A
+{
+public:
+  typedef int Info;
+};
+
+template <class T>
+class B : public A
+{
+public:
+  typedef struct{
+    int a; 
+    int b;
+  } Info;
+};
+
+void f()
+{
+  B<A>::Info ie;
+  ie.a=1;
+  ie.b=2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/derived2.C b/gcc/testsuite/g++.old-deja/g++.pt/derived2.C
new file mode 100644
index 00000000000..737792cab9f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/derived2.C
@@ -0,0 +1,35 @@
+// Build don't link:
+// Special g++ Options:
+
+template <typename T>
+void f(T);
+template <>
+void f(int) {}
+
+struct B {
+  typedef int I;
+};
+
+template <typename T> 
+struct D1 : virtual public B {
+  typedef T I;
+};
+
+
+template <typename T> 
+struct D : virtual public B, public D1<T>
+{
+  void g()
+    {
+      I i;
+      f(i);
+    }
+};
+
+int
+main()
+{
+  D<double> d;
+  d.g();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/eichin01.C b/gcc/testsuite/g++.old-deja/g++.pt/eichin01.C
new file mode 100644
index 00000000000..154587b0ac9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/eichin01.C
@@ -0,0 +1,27 @@
+// Build don't run:
+
+/*
+
+
+*/
+
+
+template <class X> class TC {
+public:
+  X aaa;
+  static X sss;
+  TC(X a) { aaa = a; }
+  TC(X a, X s) { aaa = a; sss = s; }
+  void sz(X s) { sss = s; }
+};
+
+float TC<float>::sss;
+long TC<long>::sss;
+
+TC<long> xjj(1,2);
+
+int main(int,char*) {
+  TC<float> xff(9.9,3.14);
+  xjj.sz(123);
+  xff.sz(2.71828);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/eichin01a.C b/gcc/testsuite/g++.old-deja/g++.pt/eichin01a.C
new file mode 100644
index 00000000000..1a37eebfc23
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/eichin01a.C
@@ -0,0 +1,21 @@
+template <class X> class TC {
+public:
+  X aaa;
+  static X sss;
+  TC(X a) {aaa = a; }
+  TC(X a, X s) {aaa = a; sss = s; }
+  void sz(X s) { sss = s; }
+};
+
+
+long TC<long>::sss;
+float TC<float>::sss;
+
+TC<long> xjj(1,2);
+
+int main(int,char*) {
+  TC<float> xff(9.9,3.14);
+  xjj.sz(123);
+  xff.sz(2.71828);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/eichin01b.C b/gcc/testsuite/g++.old-deja/g++.pt/eichin01b.C
new file mode 100644
index 00000000000..51bb4474c8f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/eichin01b.C
@@ -0,0 +1,21 @@
+template <class X> class TC {
+public:
+  X aaa;
+  static X sss;
+  TC(X a) {aaa = a; }
+  TC(X a, X s) {aaa = a; sss = s; }
+  void sz(X s) { sss = s; }
+  void syy(X syarg) { sss = syarg; }
+};
+
+long TC<long>::sss;
+float TC<float>::sss;
+
+TC<long> xjj(1,2);
+
+int main(int,char*) {
+  TC<float> xff(9.9,3.14);
+  xjj.sz(123);
+  xff.sz(2.71828);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum.C b/gcc/testsuite/g++.old-deja/g++.pt/enum.C
new file mode 100644
index 00000000000..4fe84a4a8a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+// GROUPS passed enums
+template<class T>
+struct templ
+{
+    enum { val = 0 };
+};
+struct Foo
+{
+    enum {
+	bar = 0,
+	len = templ<int>::val
+    };
+};
+void func()
+{
+    int s = Foo::bar;	// Ensure that expansion of templ did not erase bar
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum10.C b/gcc/testsuite/g++.old-deja/g++.pt/enum10.C
new file mode 100644
index 00000000000..713c11c33d5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum10.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template <class T> 
+struct S {
+  enum E { a = (int) T::b };
+};
+
+struct S2 {
+  enum E2 { b };
+};
+
+template class S<S2>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum11.C b/gcc/testsuite/g++.old-deja/g++.pt/enum11.C
new file mode 100644
index 00000000000..77631c41c6f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum11.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+template <class T> void f1() 
+{ 
+  struct foo { enum T2 {
+    un, du, toi };
+  }; 
+}
+
+void f2() { f1<int>(); }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum12.C b/gcc/testsuite/g++.old-deja/g++.pt/enum12.C
new file mode 100644
index 00000000000..b1c2b169d57
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum12.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template <int I>
+struct S1 { };
+
+template <class T>
+struct S2 {
+  enum { x = 3 };
+
+  void f(S1<x>&);
+};
+
+template <class T>
+void S2<T>::f(S1<x>&)
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum2.C b/gcc/testsuite/g++.old-deja/g++.pt/enum2.C
new file mode 100644
index 00000000000..5a2d7f32007
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum2.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+struct U {
+  static int STATIC;
+};
+
+template <int* x> class FOO {
+public:
+  enum { n = 0 };
+};
+
+template <class A> class BAR {
+public:
+  enum { n = FOO<&A::STATIC>::n };
+};
+
+int n = BAR<U>::n;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum3.C b/gcc/testsuite/g++.old-deja/g++.pt/enum3.C
new file mode 100644
index 00000000000..d39da3a2b91
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum3.C
@@ -0,0 +1,14 @@
+struct S { enum en { s0, s1, s2 }; };
+
+template<typename S::en e>
+int val( )
+{
+  return e;
+}
+
+
+int main()
+{
+  return val<S::s0>( );
+}
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum4.C b/gcc/testsuite/g++.old-deja/g++.pt/enum4.C
new file mode 100644
index 00000000000..28f4b2949df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum4.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template <class T>
+struct U
+{
+  T mT;
+};
+ 
+template <class H>
+struct M
+{
+  enum FLAG {On, Off};
+  U<FLAG> mUF;
+};
+
+M<char> gm;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum5.C b/gcc/testsuite/g++.old-deja/g++.pt/enum5.C
new file mode 100644
index 00000000000..f6feefb5608
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum5.C
@@ -0,0 +1,4 @@
+// Build don't link:
+
+template <>
+enum E {e}; // ERROR - template declaration of enum
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum6.C b/gcc/testsuite/g++.old-deja/g++.pt/enum6.C
new file mode 100644
index 00000000000..acfd681ec92
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum6.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+template <class T>
+struct vector {};
+
+template<class T>
+void fn(T)
+{
+  enum tern { H, L, X, U };
+
+  vector<tern> ternvec; // ERROR - composed from a local type
+}
+
+template void fn(int);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum7.C b/gcc/testsuite/g++.old-deja/g++.pt/enum7.C
new file mode 100644
index 00000000000..47dcbfa6761
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum7.C
@@ -0,0 +1,27 @@
+template <int I>
+int f()
+{
+  enum E { a = I };
+
+  struct S {
+    int g() {
+      E e;
+      e = a;
+      return (int) e;
+    };
+  };
+
+  S s;
+
+  return s.g();
+}
+
+
+int main()
+{
+  if (f<7>() != 7)
+    return 1;
+  if (f<-3>() != -3)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum8.C b/gcc/testsuite/g++.old-deja/g++.pt/enum8.C
new file mode 100644
index 00000000000..e5cc58a4a2d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum8.C
@@ -0,0 +1,18 @@
+// Build don't link:
+
+template <int I>
+void f();
+
+template <>
+void f<4>() {}
+
+template <class T>
+struct S
+{
+  enum E { a = 1, b = a + 3 };
+};
+
+int main()
+{
+  f<S<int>::b>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/enum9.C b/gcc/testsuite/g++.old-deja/g++.pt/enum9.C
new file mode 100644
index 00000000000..5ab8e8b58bc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/enum9.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+template <typename _CharT>
+class _Format_cache
+{
+public:  
+  enum {   
+    _S_digits,   _S_digits_end = _S_digits+10,
+    _S_xdigits = _S_digits_end
+  };
+};
+
+template class _Format_cache<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit1.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit1.C
new file mode 100644
index 00000000000..d218474ec8b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit1.C
@@ -0,0 +1,9 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+void foo(T t) {}
+
+void bar()
+{
+  (void (*)(double)) &foo<double>;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit10.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit10.C
new file mode 100644
index 00000000000..d90b8d05197
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit10.C
@@ -0,0 +1,9 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+void foo(T t);
+
+int main()
+{
+  foo<int>(3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit11.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit11.C
new file mode 100644
index 00000000000..fb7834f1a20
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit11.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+void foo(T t);
+
+template <class T>
+struct S {};
+
+int main()
+{
+  S<int> si;
+
+  foo<S<int> >(si);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit12.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit12.C
new file mode 100644
index 00000000000..0defb196116
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit12.C
@@ -0,0 +1,19 @@
+// Build don't run:
+// GROUPS passed templates
+template <class U>
+struct S 
+{
+  template <class T>
+  void foo(T t);
+};
+
+
+template <>
+template <>
+void S<char*>::foo<int>(int) {}
+
+int main()
+{
+  S<char*> s;
+  s.template foo<int>(3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit13.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit13.C
new file mode 100644
index 00000000000..fbb79013038
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit13.C
@@ -0,0 +1,22 @@
+// Build don't run:
+// GROUPS passed templates
+
+template <class U>
+struct S 
+{
+  template <class T>
+  void foo(T t);
+
+  template <class T>
+  void bar(T t) { this->template foo<U>(3.74); }
+};
+
+template <>
+template <>
+void S<int>::foo(int) { }
+
+int main()
+{
+  S<int> s;
+  s.bar(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit14.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit14.C
new file mode 100644
index 00000000000..aa9d03fca75
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit14.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+struct S
+{
+  template <class U>
+  typename U::R foo(U u);
+};
+
+
+void bar()
+{
+  S<int> si;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit15.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit15.C
new file mode 100644
index 00000000000..290da42192d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit15.C
@@ -0,0 +1,30 @@
+// Build don't link:
+// GROUPS passed templates
+template<int N_rank>
+class Array;
+
+
+template<class T>
+class ArraySectionInfo {
+public:
+    enum { rank = 0 };
+};
+
+
+template<class T1>
+class SliceInfo {
+public:
+    enum {
+        rank          = ArraySectionInfo<T1>::rank
+    };
+
+    typedef Array<rank> T_slice;
+};
+
+template<class T2>
+typename  SliceInfo<T2>::T_slice
+foo(T2 r2)
+{
+  return SliceInfo<T2>::T_slice();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit16.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit16.C
new file mode 100644
index 00000000000..c7a87339ca1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit16.C
@@ -0,0 +1,28 @@
+// Build don't link:
+// GROUPS passed templates
+template<int N_rank>
+class Array;
+
+
+template<class T>
+class ArraySectionInfo {
+public:
+    enum { rank = 0 };
+};
+
+
+template<class T1>
+class SliceInfo {
+public:
+  static const int rank = ArraySectionInfo<T1>::rank;
+
+  typedef Array<rank> T_slice;
+};
+
+template<class T2>
+typename  SliceInfo<T2>::T_slice
+foo(T2 r2)
+{
+  return SliceInfo<T2>::T_slice();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit17.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit17.C
new file mode 100644
index 00000000000..8e8688df321
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit17.C
@@ -0,0 +1,22 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T, class U>
+void foo(U u, T t);
+
+template <class T>
+void foo(T t);
+
+template <class T>
+struct S {};
+
+template <class T>
+void foo(const S<T>&);
+
+void bar()
+{
+  void (*fn)(double, int) = 
+    (void (*)(double, int)) &foo<int>;
+  void (*fn2)(double) = foo<double>;
+  foo<int>(3, 3.0);
+  foo<int>(S<int>());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit18.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit18.C
new file mode 100644
index 00000000000..20c4b75d11e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit18.C
@@ -0,0 +1,11 @@
+// Build don't run:
+// GROUPS passed templates
+template <class T>
+int foo(T t) { return 0; }
+
+int foo(int i);
+
+int main()
+{
+  return foo<int>(3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit19.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit19.C
new file mode 100644
index 00000000000..b209bbe8672
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit19.C
@@ -0,0 +1,12 @@
+// Build don't run:
+// GROUPS passed templates
+template <class T>
+int foo(T t);
+
+template <>
+int foo<int>(int i) { return 0; }
+
+int main()
+{
+  return foo<int>(3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit2.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit2.C
new file mode 100644
index 00000000000..73880315b64
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit2.C
@@ -0,0 +1,9 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+void foo(T t) {}
+
+void bar()
+{
+  (void (*)(int)) (void (*)(double)) &foo<double>;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit20.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit20.C
new file mode 100644
index 00000000000..918ff3a44f7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit20.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+T foo(T t);
+
+template <>
+int foo<char>(char c); // ERROR - does not match any template declaration
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit21.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit21.C
new file mode 100644
index 00000000000..a99a49bae4b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit21.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+T foo(T* t);
+
+template <>
+int foo<char>(char c); // ERROR - does not match declaration.
+
+template <>
+int bar<char>(); // ERROR - no template bar.
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit22.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit22.C
new file mode 100644
index 00000000000..0f06c53f8fc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit22.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T, class U>
+T foo(T t, U* u);
+
+template <class T>
+T foo(T t, T* u);
+
+template <>
+int foo<int>(int, int*);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit23.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit23.C
new file mode 100644
index 00000000000..cdffb15bc66
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit23.C
@@ -0,0 +1,12 @@
+// Build don't run:
+// GROUPS passed templates
+template <class T>
+int foo(T t) { return 1; }
+
+template <>
+int foo<int>(int i) { return 0; }
+
+int main()
+{
+  return foo<int>(3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit24.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit24.C
new file mode 100644
index 00000000000..42f4c3cb1a2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit24.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+int foo(T t);
+
+int foo<int>(int i) { return 0; } // ERROR - missing template <>
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit25.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit25.C
new file mode 100644
index 00000000000..022521695f8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit25.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// GROUPS passed templates
+template <int I>
+class S {};
+
+template <int I, class T>
+void foo(T t, S<I>);
+
+void bar()
+{
+  S<3> s3;
+  foo<3>("abc", s3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit26.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit26.C
new file mode 100644
index 00000000000..7d1616255b2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit26.C
@@ -0,0 +1,12 @@
+// Build don't run:
+// GROUPS passed templates
+template <class T>
+int foo(T t) { return 1; }
+
+template <>
+int foo(int i) { return 0; }
+
+int main()
+{
+  (int (*)(int)) &foo<int>;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit27.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit27.C
new file mode 100644
index 00000000000..a8d82211fc2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit27.C
@@ -0,0 +1,12 @@
+// Build don't run:
+// GROUPS passed templates
+template <class T>
+void foo(T t);
+
+template <>
+void foo(int i) {}
+
+int main()
+{
+  (void (*)(int)) &foo<int>;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit28.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit28.C
new file mode 100644
index 00000000000..0133f16c5af
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit28.C
@@ -0,0 +1,12 @@
+// Build don't run:
+// GROUPS passed templates
+template <class T>
+int foo(T t) { return 1; }
+
+template <>
+int foo(int i) { return 0; }
+
+int main()
+{
+  return (*((int (*)(int)) &foo<int>))(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit29.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit29.C
new file mode 100644
index 00000000000..a247779f8b3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit29.C
@@ -0,0 +1,12 @@
+// Build don't run:
+// GROUPS passed templates
+template <class T>
+int foo(T) { return 0; }
+
+int foo(int);
+
+int main()
+{
+  return foo<int>(3);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit3.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit3.C
new file mode 100644
index 00000000000..2a5309fb4ed
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit3.C
@@ -0,0 +1,9 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T, class U>
+void foo(T t, U u) {}
+
+void bar()
+{
+  (void (*)(double, int)) &foo<double>;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit30.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit30.C
new file mode 100644
index 00000000000..468dd7914b6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit30.C
@@ -0,0 +1,11 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+void foo(T, T*);
+
+
+void bar()
+{
+  double d;
+  (*((void (*)(int, double*)) (void (*)(int, int*)) &foo<int>))(3, &d);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit31.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit31.C
new file mode 100644
index 00000000000..61190f7f5f1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit31.C
@@ -0,0 +1,16 @@
+// Build don't run:
+// GROUPS passed templates
+template <class T>
+struct S
+{
+  template <class U>
+  static double foo(U u) { return (double) u; }
+};
+
+
+int main()
+{
+  double d = S<int>::template foo<char>(3.3);
+
+  return (d >= 3.1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit32.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit32.C
new file mode 100644
index 00000000000..5942fe744b6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit32.C
@@ -0,0 +1,25 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+struct S
+{
+};
+
+
+template <>
+struct S<int>
+{
+  void foo();
+};
+
+
+void S<int>::foo()
+{
+}
+
+
+void bar()
+{
+  S<int> si;
+  si.foo();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit33.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit33.C
new file mode 100644
index 00000000000..048a3565be8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit33.C
@@ -0,0 +1,9 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+void foo(T t);
+
+template <>
+void foo(int) {};
+
+void foo(int) {}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit34.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit34.C
new file mode 100644
index 00000000000..0aede3824bd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit34.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+void foo(T t);
+
+template <>
+void foo(int) {}; // ERROR - previously defined here.
+
+template <>
+void foo<int>(int) {} // ERROR - duplicate specialization.
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit35.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit35.C
new file mode 100644
index 00000000000..c9282632aa1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit35.C
@@ -0,0 +1,16 @@
+// Build don't run:
+// GROUPS passed templates
+struct S 
+{
+  template <class T>
+  void foo(T t);
+};
+
+template <>
+void S::foo<int>(int i) { }
+
+int main()
+{
+  S s;
+  s.template foo<int>(3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit36.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit36.C
new file mode 100644
index 00000000000..6f9e7c6b468
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit36.C
@@ -0,0 +1,24 @@
+// Build don't run:
+// GROUPS passed templates
+template <class T>
+void foo(T);
+
+class S {
+  friend void foo<>(int);
+
+  int i;
+};
+
+
+template <>
+void foo(int)
+{
+  S s;
+  s.i = 3;
+}
+
+
+int main()
+{
+  foo(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit37.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit37.C
new file mode 100644
index 00000000000..4d911a43f2a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit37.C
@@ -0,0 +1,23 @@
+// Build don't run:
+// GROUPS passed templates
+class ostream {};
+
+template <class T>
+class S;
+
+template <class T>
+void operator<<(ostream&, S<T>) {}
+
+template <class T>
+class S
+{
+  friend void operator<<<>(ostream&, const S<T>);
+};
+
+
+int main()
+{
+  ostream o;
+
+  o << S<int>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit38.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit38.C
new file mode 100644
index 00000000000..27121b667b2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit38.C
@@ -0,0 +1,7 @@
+template <int I>
+void f(int j);
+
+void g()
+{
+  f<7, 12>(3); // ERROR - no matching function.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit39.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit39.C
new file mode 100644
index 00000000000..906ef30aab1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit39.C
@@ -0,0 +1,7 @@
+template <class T>
+void f(int i);
+
+void g()
+{
+  f<7>(3); // ERROR - no matching function.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit4.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit4.C
new file mode 100644
index 00000000000..911e7b3a20a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit4.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+void foo(T t);
+
+template <class T>
+struct S {};
+
+template <class T>
+void bar(T t)
+{
+  void (*f)(S<T> ) = &foo<S<T> >;
+}
+
+
+void baz()
+{
+  bar(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit40.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit40.C
new file mode 100644
index 00000000000..d237924902e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit40.C
@@ -0,0 +1,27 @@
+extern "C" void abort();
+
+template <void* P>
+void f(int j);
+
+template <unsigned int I>
+void f(int j);
+
+
+template <void* P>
+void f(int j)
+{
+  abort();
+}
+
+
+template <unsigned int I>
+void f(int j)
+{
+}
+
+
+int main()
+{
+  f<3>(7);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit41.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit41.C
new file mode 100644
index 00000000000..b5ca475462a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit41.C
@@ -0,0 +1,8 @@
+template <int I>
+void f(int i);
+
+void g()
+{
+  int i;
+  f<i>(7); // ERROR - template argument 1 is invalid.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit42.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit42.C
new file mode 100644
index 00000000000..c19ffd02563
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit42.C
@@ -0,0 +1,17 @@
+extern "C" void abort(void);
+
+template <int I>
+void f(int i)
+{
+}
+
+template <void*>
+void f(int i) 
+{ 
+  abort();
+}
+
+int main()
+{
+  f<0>(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit43.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit43.C
new file mode 100644
index 00000000000..6396f09dde6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit43.C
@@ -0,0 +1,23 @@
+extern "C" void abort(void);
+
+void F(int)
+{
+}
+
+
+void F(double)
+{
+  abort();
+}
+
+template <void (*F)(int)> 
+void g()
+{
+  (*F)(3);
+}
+
+
+int main()
+{
+  g<&F>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit5.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit5.C
new file mode 100644
index 00000000000..2c2b7637421
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit5.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T>
+void foo(T t) {}
+
+template <class T>
+struct S {};
+
+template <class T>
+void bar(T t)
+{
+  void (*f)(S<T> ) = &foo<S<T> >;
+}
+
+
+void baz()
+{
+  bar(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit50.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit50.C
new file mode 100644
index 00000000000..8c424cc744c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit50.C
@@ -0,0 +1,15 @@
+extern "C" void abort ();
+
+template <class T> int f ()
+{
+  return sizeof(T);
+}
+
+int main ()
+{
+  if (f<long> () != sizeof(long)
+      || f<char> () != sizeof(char)
+      || f<long> () != sizeof(long)
+      || f<long int> () != sizeof(long int))
+    abort ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit51.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit51.C
new file mode 100644
index 00000000000..e4a0a64c46e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit51.C
@@ -0,0 +1,18 @@
+extern "C" void abort ();
+
+template <int a> int fact ()
+{
+  return 0;
+}
+
+template <> int fact<1> ()
+{
+  return 1;
+}
+
+int main()
+{
+  if (fact<3> () != 0 || fact<1> () != 1
+      || fact<3> () != 0 || fact<1> () != 1 || fact<1+0> () != 1)
+    abort ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit52.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit52.C
new file mode 100644
index 00000000000..368573e5b85
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit52.C
@@ -0,0 +1,18 @@
+extern "C" void abort ();
+
+template <int a> inline int fact ()
+{
+  return a * fact<a-1> ();
+}
+
+template <> inline int fact<1> ()
+{
+  return 1;
+}
+
+int main()
+{
+  if (fact<3> () != 6 || fact<1> () != 1
+      || fact<3> () != 6 || fact<1> () != 1 || fact<1+0> () != 1)
+    abort ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit53.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit53.C
new file mode 100644
index 00000000000..e66cca99d5c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit53.C
@@ -0,0 +1,21 @@
+extern "C" void abort ();
+
+template <int a> inline int fact ();
+template <> inline int fact<1> ();
+
+template <int a> inline int fact ()
+{
+  return a * fact<a-1> ();
+}
+
+template <> inline int fact<1> ()
+{
+  return 1;
+}
+
+int main()
+{
+  if (fact<3> () != 6 || fact<1> () != 1
+      || fact<3> () != 6 || fact<1> () != 1 || fact<1+0> () != 1)
+    abort ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit54.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit54.C
new file mode 100644
index 00000000000..9d185be24ce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit54.C
@@ -0,0 +1,35 @@
+extern "C" void abort ();
+
+template <int a> inline int fact2 ();
+
+template <int a> inline int fact ()
+{
+  return a * fact2<a-1> ();
+}
+
+template <> inline int fact<1> ()
+{
+  return 1;
+}
+
+template <int a> inline int fact2 ()
+{
+  return a*fact<a-1>();
+}
+
+template <> inline int fact2<1> ()
+{
+  return 1;
+}
+
+int main()
+{
+  if (fact<3> () != 6 || fact<1> () != 1
+      || fact<3> () != 6 || fact<1> () != 1 || fact<1+0> () != 1)
+    abort ();
+  if (fact2<3> () != 6 || fact2<1> () != 1
+      || fact2<3> () != 6 || fact2<1> () != 1 || fact2<1+0> () != 1)
+    abort ();
+  if (fact2<4> () != 24 || fact<4> () != 24)
+    abort ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit55.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit55.C
new file mode 100644
index 00000000000..c9d312520a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit55.C
@@ -0,0 +1,14 @@
+template <class T> T* create ()
+{
+  return new T;
+}
+
+template <class T> T* create2()
+{
+  return create<T>();
+}
+
+int main()
+{
+  int *p = create2<int>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit56.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit56.C
new file mode 100644
index 00000000000..d202160be16
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit56.C
@@ -0,0 +1,16 @@
+template <class T> T* create ();
+
+template <class T> T* create2()
+{
+  return create<T>();
+}
+
+template <class T> T* create ()
+{
+  return new T;
+}
+
+int main()
+{
+  int *p = create2<int>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit57.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit57.C
new file mode 100644
index 00000000000..d1f0ea870dc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit57.C
@@ -0,0 +1,42 @@
+extern "C" void abort ();
+
+int a = 0;
+
+template <class T> void f ();
+template <class T> void g ()
+{
+  if (a)
+    abort ();
+}
+
+template <> void g<char> ()
+{
+}
+
+template <class T> class C
+{
+  public:
+    void ff () { f<T> (); }
+    void gg () { g<T> (); }
+};
+
+template <class T> void f ()
+{
+  if (a)
+    abort ();
+}
+
+template <> void f<char> ()
+{
+}
+
+int main ()
+{
+  C<int> c;
+  c.ff();
+  c.gg();
+  a = 1;
+  C<char> d;
+  d.ff();
+  d.gg();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit58.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit58.C
new file mode 100644
index 00000000000..7193d2d84bd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit58.C
@@ -0,0 +1,41 @@
+extern "C" void abort ();
+
+template <class T> void f ();
+template <class T> void g ()
+{
+  abort ();
+}
+
+template <> void g<char> ()
+{
+  abort ();
+}
+
+template <class T> class C
+{
+  public:
+    template <class U> void f () {}
+    template <class U> void g () {}
+    void ff () { f<T> (); }
+    void gg () { g<T> (); }
+};
+
+template <class T> void f ()
+{
+  abort ();
+}
+
+template <> void f<char> ()
+{
+  abort ();
+}
+
+int main ()
+{
+  C<int> c;
+  c.ff();
+  c.gg();
+  C<char> d;
+  d.ff();
+  d.gg();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit59.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit59.C
new file mode 100644
index 00000000000..847a80acca6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit59.C
@@ -0,0 +1,41 @@
+extern "C" void abort ();
+
+template <class T> void f ();
+template <class T> void g ()
+{
+  abort ();
+}
+
+template <> void g<char> ()
+{
+  abort ();
+}
+
+template <class T> class C
+{
+  public:
+    void ff () { f<T> (); }
+    void gg () { g<T> (); }
+    template <class U> void f () {}
+    template <class U> void g () {}
+};
+
+template <class T> void f ()
+{
+  abort ();
+}
+
+template <> void f<char> ()
+{
+  abort ();
+}
+
+int main ()
+{
+  C<int> c;
+  c.ff();
+  c.gg();
+  C<char> d;
+  d.ff();
+  d.gg();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit6.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit6.C
new file mode 100644
index 00000000000..1ee7751b555
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit6.C
@@ -0,0 +1,12 @@
+// Build don't run:
+// GROUPS passed templates
+template <class T>
+int foo(T t);
+
+template <>
+int foo(int i) { return 0; }
+
+int main()
+{
+  return foo<int>(3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit60.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit60.C
new file mode 100644
index 00000000000..5fda3335585
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit60.C
@@ -0,0 +1,43 @@
+extern "C" void abort ();
+
+template <class T> void f ();
+template <class T> void g ()
+{
+  abort ();
+}
+
+template <> void g<char> ()
+{
+  abort ();
+}
+
+template <class T> class C
+{
+  public:
+    void ff () { f<T> (); }
+    void gg () { g<T> (); }
+    template <class U> void f () {}
+    template <class U> void g () {}
+    template <class U> void f (int) { abort(); }
+    template <class U> void g (int) { abort(); }
+};
+
+template <class T> void f ()
+{
+  abort ();
+}
+
+template <> void f<char> ()
+{
+  abort ();
+}
+
+int main ()
+{
+  C<int> c;
+  c.ff();
+  c.gg();
+  C<char> d;
+  d.ff();
+  d.gg();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit61.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit61.C
new file mode 100644
index 00000000000..69b78914742
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit61.C
@@ -0,0 +1,43 @@
+extern "C" void abort ();
+
+template <class T> void f ();
+template <class T> void g ()
+{
+  abort ();
+}
+
+template <> void g<char> ()
+{
+  abort ();
+}
+
+template <class T> class C
+{
+  public:
+    void ff () { f<T> (0); }
+    void gg () { g<T> (1); }
+    template <class U> void f () { abort(); }
+    template <class U> void g () { abort(); }
+    template <class U> void f (int) {}
+    template <class U> void g (int) {}
+};
+
+template <class T> void f ()
+{
+  abort ();
+}
+
+template <> void f<char> ()
+{
+  abort ();
+}
+
+int main ()
+{
+  C<int> c;
+  c.ff();
+  c.gg();
+  C<char> d;
+  d.ff();
+  d.gg();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit62.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit62.C
new file mode 100644
index 00000000000..5917ce01cf3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit62.C
@@ -0,0 +1,19 @@
+extern "C" void abort ();
+
+template <class T> void f ()
+{
+}
+
+
+template <class T> class C
+{
+  friend void f<char> ();
+  public:
+    void ff () { f<char> (); }
+};
+
+int main ()
+{
+  C<int> c;
+  c.ff();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit63.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit63.C
new file mode 100644
index 00000000000..ce4d99af1e7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit63.C
@@ -0,0 +1,19 @@
+extern "C" void abort ();
+
+template <class T> void f ()
+{
+}
+
+
+template <class T> class C
+{
+  friend void f<T> ();
+  public:
+    void ff () { f<T> (); }
+};
+
+int main ()
+{
+  C<int> c;
+  c.ff();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit64.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit64.C
new file mode 100644
index 00000000000..2208b30eae7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit64.C
@@ -0,0 +1,23 @@
+extern "C" void abort ();
+
+template <class T> void f ()
+{
+  abort ();
+}
+
+template <> void f<char> ()
+{
+}
+
+template <class T> class C
+{
+  friend void f<char> ();
+  public:
+    void ff () { f<char> (); }
+};
+
+int main ()
+{
+  C<int> c;
+  c.ff();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit65.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit65.C
new file mode 100644
index 00000000000..a026e8ee3f3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit65.C
@@ -0,0 +1,33 @@
+extern "C" void abort ();
+
+template <class T> void f ()
+{
+  abort ();
+}
+
+template <> void f<char> ()
+{
+  abort ();
+}
+
+template <class T> void f (int)
+{
+  abort ();
+}
+
+template <> void f<char> (int)
+{
+}
+
+template <class T> class C
+{
+  friend void f<char> (int);
+  public:
+    void ff () { f<char> (0); }
+};
+
+int main ()
+{
+  C<int> c;
+  c.ff();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit66.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit66.C
new file mode 100644
index 00000000000..d4a3c627a97
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit66.C
@@ -0,0 +1,11 @@
+void f(int) {}
+void f(double);
+
+template <void (*fn)(int)>
+void foo() {}
+
+int main()
+{
+  foo<f>();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit67.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit67.C
new file mode 100644
index 00000000000..c8705f42564
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit67.C
@@ -0,0 +1,20 @@
+struct S
+{
+  void f(int);
+  void f(double);
+};
+
+void g(int);
+void g(double);
+
+template <int* IP>
+void foo();
+template <long l>
+void foo();
+
+void bar()
+{
+  foo<S::f>(); // ERROR - no matching function
+  foo<g>();    // ERROR - no matching function
+  
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit68.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit68.C
new file mode 100644
index 00000000000..bc47c6c8f11
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit68.C
@@ -0,0 +1,24 @@
+// Build don't link:
+
+template <bool B>
+struct S
+{
+  static void g();
+};
+
+template <bool B>
+void g();
+
+template<unsigned Length>
+void f()
+{
+  const bool b = true;
+  g<b>();
+  const bool b1 = (Length == 2);
+  S<b1>::g();
+}
+
+void h()
+{
+  f<3>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit69.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit69.C
new file mode 100644
index 00000000000..671cf005de5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit69.C
@@ -0,0 +1,2 @@
+//Build don't link:
+template class x {}; // ERROR - not a template instantiation
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit70.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit70.C
new file mode 100644
index 00000000000..ade83fdc443
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit70.C
@@ -0,0 +1,43 @@
+// Build don't link:
+
+template <class T>
+void f(T) {}
+
+template <class T>
+struct S {
+  static T t;
+};
+
+template <class T>
+T S<T>::t;
+
+template void f(int);
+template void f(int); // ERROR - duplicate explicit instantiation 
+template int S<int>::t;
+template int S<int>::t; // ERROR - duplicate explicit instantiation 
+template class S<double>;
+template class S<double>; // ERROR - duplicate explicit instantiation 
+
+extern template void f(double); // WARNING - extern not allowed
+inline template class S<float>; // WARNING - inline not allowed
+
+template <class T>
+struct S<T*> {};
+
+template class S<void*>; // OK - explicit instantiation of partial
+                         // specialization
+
+template <>
+struct S<long double> {};  // ERROR - explicit specialization
+
+template class S<long double>; // ERROR - explicit instantiation after
+
+template <>
+void f(long double) {}        // ERROR - explicit specialization
+
+template void f(long double); // ERROR - explicit instantiation after
+
+template <class T>
+void g(T);
+
+template void g(int); // ERROR - no definition of g.
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit71.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit71.C
new file mode 100644
index 00000000000..c84eebcc428
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit71.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// by Alexandre Oliva <oliva@dcc.unicamp.br>
+// Based on a testcase by Reid M. Pinchback <reidmp@MIT.EDU>
+// According to the C++ Standard [temp.expl.spec]/17-18, explicit
+// specializations are only valid if all enclosing template classes
+// of the specialized template are fully specialized too
+
+template <class X> 
+class bug {
+  template <class Y> 
+  class a {}; 
+};
+template <class X> 
+template <>			// ERROR - invalid specialization
+class bug<X>::a<char> {};	// ERROR -  ""
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit72.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit72.C
new file mode 100644
index 00000000000..bc9edfb4de7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit72.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// Contributed by Reid M. Pinchback <reidmp@MIT.EDU>
+// Adapted by Alexandre Oliva <oliva@dcc.unicamp.br>
+// plain char, signed char and unsigned char are distinct types
+
+template <class X, class Y> class bug {};
+template <class X> class bug<X,char> { typedef char t; };
+template <class X> class bug<X,unsigned char> { typedef unsigned char t; };
+template <class X> class bug<X,signed char> { typedef signed char t; };
+template <class X> class bug<char,X> { typedef char t; };
+template <class X> class bug<unsigned char,X> { typedef unsigned char t; };
+template <class X> class bug<signed char,X> { typedef signed char t; };
+
+void foo() {
+  bug<int,char>::t();
+  bug<int,signed char>::t();
+  bug<int,unsigned char>::t();
+  bug<char,int>::t();
+  bug<signed char,int>::t();
+  bug<unsigned char,int>::t();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit73.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit73.C
new file mode 100644
index 00000000000..1dd0f69ab22
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit73.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+// by Alexandre Oliva <oliva@dcc.unicamp.br>
+
+// According to [temp.expl.spec]/2, a template explicit specialization
+// must be declared in the namespace that contains the declaration of
+// the template
+
+namespace N {
+  template <class T> class foo;	// ERROR - referenced below
+}
+
+using namespace N;
+
+template <> class foo<void>; // ERROR - invalid specialization
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit74.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit74.C
new file mode 100644
index 00000000000..c49d16919a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit74.C
@@ -0,0 +1,10 @@
+// Reduced from a testcase by Yotam Medini <yotam@avanticorp.com>
+
+// egcs 1.1 seems to generate code that deletes a NULL pointer.
+
+template <class bar> struct foo { void fuz(); ~foo(); };
+struct baz { int i; foo<baz> j; } *p = 0;
+template <class bar> void foo<bar>::fuz() { delete p; }
+template <class bar> foo<bar>::~foo() { delete p; }
+template class foo<baz>;
+int main() { foo<baz>(); }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit75.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit75.C
new file mode 100644
index 00000000000..433f0b193e3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit75.C
@@ -0,0 +1,11 @@
+// Test for not complaining about mismatches during unification.
+// Build don't link:
+
+template <void (*F)(int)> void f();
+template <void (*F)(double)> void f();
+extern void g(double);
+
+void h ()
+{
+  f<g>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit76.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit76.C
new file mode 100644
index 00000000000..18c161c6e27
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit76.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+// Based on bug report by Simon A. Crase <s.crase@ieee.org>
+
+// crash test - XFAIL *-*-*
+
+struct foo {
+  template <class T> void bar();
+};
+
+template void foo::bar<void>(); // gets bogus error - ICE - XFAIL *-*-*
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit77.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit77.C
new file mode 100644
index 00000000000..5a07f8e0168
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit77.C
@@ -0,0 +1,18 @@
+// Build don't link:
+
+template <int I, int J, int K>
+struct S {};
+
+template <int I, int J>
+struct S<I, J, 2> : public S<I, I, I>, S<J, J, J> {};
+
+template <int I, int J, int K>
+void f(S<I, J, K>, S<I, I, I>);
+
+void g() {
+  S<0, 0, 0> s0;
+  S<0, 1, 2> s2;
+  
+  f<0>(s0, s2);
+  f(s0, s2); // ERROR - no matching function
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit78.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit78.C
new file mode 100644
index 00000000000..2375816af87
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit78.C
@@ -0,0 +1,28 @@
+// Build don't link:
+
+template <int I>
+struct A {
+};
+
+template <int I, int J>
+struct B {
+  operator A<3> ();
+  operator B<3, 7> ();
+};
+
+
+template <int I, int J>
+void f(B<I, J>);
+
+template <int I>
+void f(A<I>)
+{
+}
+
+int main()
+{
+  // Deduction fails with the first `f'.  Since `3' is explicitly
+  // specified, we don't try any deduction with the second `f'.  So,
+  // we call the second `f'.
+  f<3>(B<2, 7>());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit79.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit79.C
new file mode 100644
index 00000000000..16429ba6213
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit79.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template <int I>
+void f(int (*)[I] = 0);
+
+template <int J>
+void f();
+
+void g()
+{
+  f<-1>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit8.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit8.C
new file mode 100644
index 00000000000..777c5d4afc2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit8.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// GROUPS passed templates
+template <class T, class U>
+void foo(T t, U u);
+
+template <class U>
+void foo(double, U) {}
+
+void baz()
+{
+  foo<char*>(3.0, "abc");
+  foo<char*, double>("abc", 3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/explicit9.C b/gcc/testsuite/g++.old-deja/g++.pt/explicit9.C
new file mode 100644
index 00000000000..908374b720a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/explicit9.C
@@ -0,0 +1,8 @@
+// Build don't link:
+// GROUPS passed templates
+void foo(int);
+
+void bar()
+{
+  foo<int>(3); // ERROR - foo is not a template.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/expr1.C b/gcc/testsuite/g++.old-deja/g++.pt/expr1.C
new file mode 100644
index 00000000000..cdb868770bc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/expr1.C
@@ -0,0 +1,33 @@
+template <int n> class vec {
+    double x[n];
+
+    public:
+    vec() {
+ for (int i=0; i<n-1; ++i) x[i]=0;
+    }
+
+    vec(const vec<n>& v) {
+ for (int i=0; i<n; ++i) x[i]=v(i);
+    }
+
+    vec(const vec<n-1>& v, const double& y) {
+ for (int i=0; i<n-1; ++i) x[i]=v(i);
+ x[n-1]=y;
+    }
+
+    inline double operator()(const int i) const {
+ return x[i];
+    }
+};
+
+
+template <int n> vec<n + 1>& operator,(const vec<n>& v, const double& y) {
+    return *(new vec<n + 1>(v, y));
+}
+
+
+int main() {
+    vec<4> v;
+    vec<5> w;
+    w=(v,3.);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/expr2.C b/gcc/testsuite/g++.old-deja/g++.pt/expr2.C
new file mode 100644
index 00000000000..d6e5593b242
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/expr2.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template <int I>
+struct S {};
+
+template <int J>
+void foo(S<J + 2>);
+
+void bar()
+{
+  foo(S<3>()); // ERROR - no way to deduce J from this.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/expr3.C b/gcc/testsuite/g++.old-deja/g++.pt/expr3.C
new file mode 100644
index 00000000000..4d77370e186
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/expr3.C
@@ -0,0 +1,20 @@
+// Build don't link:
+
+template <int I>
+struct S {};
+
+template <int J>
+void foo(S<J - 1>);
+
+template <class T>
+void baz(S<sizeof(T)>);
+
+template <int J>
+void fun(S<J>, S<J * 2>);
+
+void bar()
+{
+  foo<5>(S<4>()); // OK - 4 is 5 - 1.
+  baz<int>(S<sizeof(int)>()); // OK
+  fun(S<4>(), S<8>()); // OK - deduce J from first argument.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/expr5.C b/gcc/testsuite/g++.old-deja/g++.pt/expr5.C
new file mode 100644
index 00000000000..4cb5078702f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/expr5.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+template <class T, int i>
+struct S1;
+
+template <class T, int i, int j>
+struct S2
+{
+  typedef typename S1<T, (i >= j ? 0 : 1) >::type type;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/expr6.C b/gcc/testsuite/g++.old-deja/g++.pt/expr6.C
new file mode 100644
index 00000000000..e1d38de7e56
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/expr6.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+// Based on a bug report by tveldhui <tveldhui@extreme.indiana.edu>
+
+// excess errors test - XFAIL *-*-*
+
+template <int X> class foo {};
+
+foo< true ? 1 : 0 > bar;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/expr7.C b/gcc/testsuite/g++.old-deja/g++.pt/expr7.C
new file mode 100644
index 00000000000..5fb567b5b77
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/expr7.C
@@ -0,0 +1,8 @@
+// Build don't link:
+
+template<int I> struct A { };
+template<int I, int J> int f(A<I+J>);
+int g() {
+  A<3> a;
+  return f<1,2>(a);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend1.C b/gcc/testsuite/g++.old-deja/g++.pt/friend1.C
new file mode 100644
index 00000000000..ba642ba5c5a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend1.C
@@ -0,0 +1,24 @@
+template <class T>
+void f(T);
+
+class C
+{
+  template <class T>
+  friend void f(T);
+
+  int i;
+};
+
+
+template <class T>
+void f(T)
+{
+  C c;
+  c.i = 3;
+}
+
+
+int main()
+{
+  f(7);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend10.C b/gcc/testsuite/g++.old-deja/g++.pt/friend10.C
new file mode 100644
index 00000000000..bff432b5620
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend10.C
@@ -0,0 +1,29 @@
+template <class T>
+void f(T);
+
+template <class U>
+class C
+{
+  template <class T>
+  friend void f(T)
+    {
+      C<U> c;
+      c.i = 3;
+    }
+
+public:
+
+  void g()
+    {
+      f(3.0);
+    }
+
+  int i;
+};
+
+int main()
+{
+  f(7);
+  C<double> c;
+  c.g();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend11.C b/gcc/testsuite/g++.old-deja/g++.pt/friend11.C
new file mode 100644
index 00000000000..1aeba3a1018
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend11.C
@@ -0,0 +1,31 @@
+template <class T>
+class C;
+
+template <class T>
+struct S
+{
+  template <class U>
+  void f(U u)
+    {
+      C<U> cu;
+      cu.i = 3; // ERROR - S<double>::f<U> is a friend, but this is
+                //         S<int>::f<double>. 
+    }
+};
+
+
+template <class T>
+class C
+{
+  template <class U>
+  friend void S<T>::f(U);
+
+  int i; // ERROR - private
+};
+
+
+int main()
+{
+  S<int> si;
+  si.f(3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend12.C b/gcc/testsuite/g++.old-deja/g++.pt/friend12.C
new file mode 100644
index 00000000000..ef9bfc8a02c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend12.C
@@ -0,0 +1,33 @@
+template <class T>
+class C;
+
+template <class T>
+struct S
+{
+  template <class U>
+  void f(U u1, U u2) {}
+
+  template <class U>
+  void f(U u)
+    {
+      C<T> ct;
+      ct.i = 3;
+    }
+};
+
+
+template <class T>
+class C
+{
+  template <class U>
+  friend void S<T>::f(U);
+
+  int i;
+};
+
+
+int main()
+{
+  S<int> si;
+  si.f(3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend13.C b/gcc/testsuite/g++.old-deja/g++.pt/friend13.C
new file mode 100644
index 00000000000..251d52a47bc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend13.C
@@ -0,0 +1,33 @@
+template <class T>
+class C;
+
+template <class U>
+struct S
+{
+  template <class V>
+  void f(V v)
+    {
+      C<V> cv;
+      cv.i = 3;
+    }
+};
+
+
+template <class T>
+class C
+{
+  template <class U>
+  template <class V>
+  friend void S<U>::f(V);
+
+  int i;
+};
+
+
+int main()
+{
+  S<int> si;
+  si.f(3.0);
+  S<long> sl;
+  sl.f('c');
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend14.C b/gcc/testsuite/g++.old-deja/g++.pt/friend14.C
new file mode 100644
index 00000000000..4ed5fcc47a8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend14.C
@@ -0,0 +1,25 @@
+// Build don't link:
+
+template <class U>
+class S1
+{
+  template <class T>
+  friend class S2;
+
+  static int i;
+};
+
+
+template <class T>
+class S2
+{
+public:
+  static void f() { S1<T>::i = 3; }
+};
+
+
+void g()
+{
+  S2<double>::f();
+  S2<long>::f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend15.C b/gcc/testsuite/g++.old-deja/g++.pt/friend15.C
new file mode 100644
index 00000000000..8d49f6a2be0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend15.C
@@ -0,0 +1,24 @@
+// Build don't link:
+
+class S1
+{
+  template <class T>
+  friend class S2;
+
+  static int i;
+};
+
+
+template <class T>
+class S2
+{
+public:
+  static void f() { S1::i = 3; }
+};
+
+
+void g()
+{
+  S2<double>::f();
+  S2<char>::f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend16.C b/gcc/testsuite/g++.old-deja/g++.pt/friend16.C
new file mode 100644
index 00000000000..7f13e5b90b3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend16.C
@@ -0,0 +1,31 @@
+// Build don't link:
+
+template <class T>
+class S2
+{
+public:
+  static void f();
+};
+
+
+template <class U>
+class S1
+{
+  template <class T>
+  friend class S2;
+
+  static int i;
+};
+
+
+template <class T>
+void S2<T>::f() 
+{
+  S1<T>::i = 3;
+}
+
+void g()
+{
+  S2<double>::f();
+  S2<char>::f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend17.C b/gcc/testsuite/g++.old-deja/g++.pt/friend17.C
new file mode 100644
index 00000000000..cb12ce8e793
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend17.C
@@ -0,0 +1,28 @@
+// Build don't link:
+
+template <class T>
+class S2
+{
+public:
+  static void f();
+};
+
+class S1
+{
+  template <class T>
+  friend class S2;
+
+  static int i;
+};
+
+template <class T>
+void S2<T>::f() 
+{
+  S1::i = 3;
+}
+
+void g()
+{
+  S2<double>::f();
+  S2<char>::f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend18.C b/gcc/testsuite/g++.old-deja/g++.pt/friend18.C
new file mode 100644
index 00000000000..998e1639fe6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend18.C
@@ -0,0 +1,26 @@
+// Build don't link:
+
+template <class U>
+class S1
+{
+  template <class T>
+  friend class S2;
+
+  static int i;
+};
+
+
+template <class T>
+class S2
+{
+public:
+  static void f() { S1<T>::i = 3; }
+};
+
+
+void g()
+{
+  S2<double>::f();
+  S2<long>::f();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend19.C b/gcc/testsuite/g++.old-deja/g++.pt/friend19.C
new file mode 100644
index 00000000000..998e1639fe6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend19.C
@@ -0,0 +1,26 @@
+// Build don't link:
+
+template <class U>
+class S1
+{
+  template <class T>
+  friend class S2;
+
+  static int i;
+};
+
+
+template <class T>
+class S2
+{
+public:
+  static void f() { S1<T>::i = 3; }
+};
+
+
+void g()
+{
+  S2<double>::f();
+  S2<long>::f();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend20.C b/gcc/testsuite/g++.old-deja/g++.pt/friend20.C
new file mode 100644
index 00000000000..40d5370a810
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend20.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+template <class T = int> struct A;
+
+template <class T> struct B
+{
+  friend class A<T>;
+};
+
+template class B<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend21.C b/gcc/testsuite/g++.old-deja/g++.pt/friend21.C
new file mode 100644
index 00000000000..3f690a4404a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend21.C
@@ -0,0 +1,30 @@
+// Build don't link:
+
+template <class T> struct A {
+  static void f();
+};
+
+template <class T> class B
+{
+  friend class A<T>;
+  static int i; // ERROR - private
+};
+
+template <class T> class C
+{
+  template <class U>
+  friend class A;
+
+  static int i;
+};
+
+template <class T>
+void A<T>::f()
+{
+  B<T>::i = 3;
+  C<T>::i = 3;
+  C<double>::i = 3;
+  B<double>::i = 3; // ERROR - member `i' is private
+}
+
+template void A<int>::f(); // ERROR - instantiated from here
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend22.C b/gcc/testsuite/g++.old-deja/g++.pt/friend22.C
new file mode 100644
index 00000000000..ed459d71fe2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend22.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+template <class T = int>
+struct S
+{
+  template <class U>
+  friend class S;
+};
+
+template struct S<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend23.C b/gcc/testsuite/g++.old-deja/g++.pt/friend23.C
new file mode 100644
index 00000000000..21065f1cac1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend23.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+template <class T = int> // ERROR - original definition
+struct S
+{ // ERROR - redefinition of default arg
+  template <class U = int>
+  friend class S;
+};
+
+template struct S<int>; // ERROR - instantiated from here
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend24.C b/gcc/testsuite/g++.old-deja/g++.pt/friend24.C
new file mode 100644
index 00000000000..d312b3854ea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend24.C
@@ -0,0 +1,18 @@
+// Build don't link:
+
+template <class T>
+struct S
+{
+  template <class U = T>
+  friend class S;
+
+  void f(T);
+};
+
+template struct S<int>;
+
+void g()
+{
+  S<> s;
+  s.f(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend25.C b/gcc/testsuite/g++.old-deja/g++.pt/friend25.C
new file mode 100644
index 00000000000..f93e73bc396
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend25.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+template <class T> struct A;
+
+struct B
+{
+  template <class U>
+  friend class A<U>;  // ERROR - does not specialize any args
+};
+
+struct C
+{
+  template <class U>
+  friend class A<U*>; // ERROR - partial specialization
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend26.C b/gcc/testsuite/g++.old-deja/g++.pt/friend26.C
new file mode 100644
index 00000000000..a426f8b775f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend26.C
@@ -0,0 +1,6 @@
+// Build don't link:
+
+struct S
+{
+  friend void f<>(int); // ERROR - does not match any template
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend27.C b/gcc/testsuite/g++.old-deja/g++.pt/friend27.C
new file mode 100644
index 00000000000..0f11a49c060
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend27.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+class S
+{
+  friend void f<>(int); // ERROR - does not match any template
+  int i;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend28.C b/gcc/testsuite/g++.old-deja/g++.pt/friend28.C
new file mode 100644
index 00000000000..f86d0b67b95
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend28.C
@@ -0,0 +1,22 @@
+// Build don't link:
+
+class mystream;
+
+template <class T> class a {
+public:
+	friend mystream& operator>> <>( mystream&, a<T>& thea );
+private:
+	T amember;
+};
+
+template <class T> mystream& operator>>( mystream& s, a<T>& thea );
+
+template<> mystream& operator>> <int>( mystream& s, a<int>& thea );
+
+template class a<int>;
+
+template<> mystream& operator>> <int>( mystream& s, a<int>& thea )
+{
+	thea.amember = 0;
+	return s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend29.C b/gcc/testsuite/g++.old-deja/g++.pt/friend29.C
new file mode 100644
index 00000000000..e141aaa363f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend29.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template <class T> class a {
+public:
+	friend void foo<>( a<T>& thea );
+private:
+	T amember;
+};
+
+template <class T> void foo( a<T>& thea )
+{
+	thea.amember = 0;
+}
+
+template class a<int>;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend3.C b/gcc/testsuite/g++.old-deja/g++.pt/friend3.C
new file mode 100644
index 00000000000..74d0e06699c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend3.C
@@ -0,0 +1,25 @@
+// Build don't link:
+
+template <class T>
+void f(T);
+
+class C
+{
+  friend void f<>(double);
+
+  int i; // ERROR - private
+};
+
+
+template <class T>
+void f(T)
+{
+  C c;
+  c.i = 3; // ERROR - f<double> is a friend, this is f<int>.
+}
+
+
+int main()
+{
+  f(7);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend30.C b/gcc/testsuite/g++.old-deja/g++.pt/friend30.C
new file mode 100644
index 00000000000..61dd8fcb8e9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend30.C
@@ -0,0 +1,18 @@
+// Build don't link:
+
+template <class T, class U>
+struct S {
+  template <class X, class Y, class Z>
+  friend X f(X, Y, Z);
+};
+
+template <class X, class Y, class Z>
+X f(X x, Y, Z) {
+  return x;
+}
+
+template char f(char, long, short);
+template char* f(char*, long*, short*);
+template class S<int, double>;
+template class S<void*, double>;
+template double* f(double*, long*, short*);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend31.C b/gcc/testsuite/g++.old-deja/g++.pt/friend31.C
new file mode 100644
index 00000000000..15a380b462a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend31.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template <class T>
+struct S1 {
+};
+
+template <>
+struct S1<int> {};
+
+struct S2 {
+  friend class S1<int>;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend32.C b/gcc/testsuite/g++.old-deja/g++.pt/friend32.C
new file mode 100644
index 00000000000..b1f173a4623
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend32.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template <class T, class U>
+struct S {
+  template <class X, class Y, class Z>
+  friend X f(X, Y, Z);
+};
+
+template class S<int, double>;
+template char f(char, long, short);
+template char* f(char*, long*, short*);
+
+template <class X, class Y, class Z>
+X f(X x, Y, Z) {
+  return x;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend33.C b/gcc/testsuite/g++.old-deja/g++.pt/friend33.C
new file mode 100644
index 00000000000..5feec1a06d7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend33.C
@@ -0,0 +1,28 @@
+// Build don't run:
+// Special g++ Options: -g
+
+template <class P1>
+struct S1
+{
+  struct SS1
+  {
+  };
+  friend void Foo (const SS1& ss1)
+    {
+    }
+};
+
+template <class P1>
+void Foo(const S1<P1>& s1)
+{
+  typedef typename S1<P1>::SS1 TYPE;
+  TYPE t;
+  Foo(t);
+}
+
+int main ()
+{
+  S1<double> obj;
+  Foo(obj);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend34.C b/gcc/testsuite/g++.old-deja/g++.pt/friend34.C
new file mode 100644
index 00000000000..56eb80a5056
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend34.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// excess errors test 
+
+// This testcase won't fail if class ::foo is forward-declared in the
+// global namespace, nor if class bar is not a template class.
+
+template <typename T = void>
+class bar {
+public:
+  friend class foo; // this is not bar::foo, it forward-declares ::foo
+  class foo {};
+  bar() { foo(); } // but this should refer to bar::foo
+};
+
+bar<> baz;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend35.C b/gcc/testsuite/g++.old-deja/g++.pt/friend35.C
new file mode 100644
index 00000000000..c2c22c7634e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend35.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+class foo {
+  friend void bar<int>(int); // ERROR - must be declared first
+};
+
+template <typename T> void bar(T);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend36.C b/gcc/testsuite/g++.old-deja/g++.pt/friend36.C
new file mode 100644
index 00000000000..4a9042ad3ec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend36.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template <class T>
+void f(T) {} // ERROR - previously defined here
+
+template <class U>
+struct S {
+  template <class T>
+  friend void f(T) {} // ERROR - redeclaration
+};
+
+S<int> si;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend37.C b/gcc/testsuite/g++.old-deja/g++.pt/friend37.C
new file mode 100644
index 00000000000..c3ee4c7aaef
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend37.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// Simplified from report by Volker Dobler <volker@hugo.physik.uni-konstanz.de>
+
+template <class T> class A {
+  friend int ice<>( int k=0 ); // ERROR - default argument
+  friend inline int f<>(double); // ERROR - inline
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend38.C b/gcc/testsuite/g++.old-deja/g++.pt/friend38.C
new file mode 100644
index 00000000000..e3a6a060ef6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend38.C
@@ -0,0 +1,8 @@
+// Build don't link:
+
+// Overly simplified from testcase by "B. K. Oxley" <binkley@bigfoot.com>
+
+template<class P> struct foo {
+  typedef P parent_type;
+  friend parent_type; // ERROR - template parameters cannot be friends - XFAIL *-*-*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend39.C b/gcc/testsuite/g++.old-deja/g++.pt/friend39.C
new file mode 100644
index 00000000000..836c83054bb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend39.C
@@ -0,0 +1,23 @@
+// Build don't link:
+
+template <class T>
+struct S;
+
+template <class T>
+class C
+{
+  friend void S<T>::f();
+  
+  int i;
+};
+
+template <class T>
+struct S
+{
+  void f() {
+    C<T> c;
+    c.i = 3;
+  }
+};
+
+template void S<int>::f();
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend4.C b/gcc/testsuite/g++.old-deja/g++.pt/friend4.C
new file mode 100644
index 00000000000..ea439277c5a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend4.C
@@ -0,0 +1,21 @@
+class C
+{
+  template <class T>
+  friend void f(T);
+
+  int i;
+};
+
+
+template <class T>
+void f(T)
+{
+  C c;
+  c.i = 3;
+}
+
+
+int main()
+{
+  f(7);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend40.C b/gcc/testsuite/g++.old-deja/g++.pt/friend40.C
new file mode 100644
index 00000000000..90288e8a336
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend40.C
@@ -0,0 +1,12 @@
+// Build don't link:
+// Origin: Jason Merrill <jason@cygnus.com>
+// Special g++ Options: -Wno-non-template-friend
+
+template<class T> struct A
+{
+  friend void f ();
+};
+
+A<short> a;
+A<int> b;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend41.C b/gcc/testsuite/g++.old-deja/g++.pt/friend41.C
new file mode 100644
index 00000000000..d6b74a084d7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend41.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class T>
+class S {
+public:
+  template <class U>
+  class C {
+  public:
+    void f() { S::i = 3; }
+  };
+
+  template <class U>
+  friend class C;
+
+private:
+  static int i;
+};
+
+
+template void S<int>::C<double>::f();
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend42.C b/gcc/testsuite/g++.old-deja/g++.pt/friend42.C
new file mode 100644
index 00000000000..dcbfd462bac
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend42.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class T>
+struct S {
+  template <class U>
+  friend struct S2;
+};
+
+template struct S<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend5.C b/gcc/testsuite/g++.old-deja/g++.pt/friend5.C
new file mode 100644
index 00000000000..516be4dd018
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend5.C
@@ -0,0 +1,17 @@
+class C
+{
+  template <class T>
+  friend void f(T)
+    {
+      C c;
+      c.i = 3;
+    }
+
+  int i;
+};
+
+
+int main()
+{
+  f(7);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend6.C b/gcc/testsuite/g++.old-deja/g++.pt/friend6.C
new file mode 100644
index 00000000000..5651421e6cf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend6.C
@@ -0,0 +1,28 @@
+template <class T>
+void f(T);
+
+class C
+{
+  template <class T>
+  friend void f(T)
+    {
+      C c;
+      c.i = 3;
+    }
+
+public:
+
+  void g()
+    {
+      f(3.0);
+    }
+
+  int i;
+};
+
+int main()
+{
+  f(7);
+  C c;
+  c.g();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend7.C b/gcc/testsuite/g++.old-deja/g++.pt/friend7.C
new file mode 100644
index 00000000000..2962d924531
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend7.C
@@ -0,0 +1,25 @@
+template <class T>
+void f(T);
+
+template <class U>
+class C
+{
+  template <class T>
+  friend void f(T);
+
+  int i;
+};
+
+
+template <class T>
+void f(T)
+{
+  C<T> c;
+  c.i = 3;
+}
+
+
+int main()
+{
+  f(7);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend8.C b/gcc/testsuite/g++.old-deja/g++.pt/friend8.C
new file mode 100644
index 00000000000..ffa9122728f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend8.C
@@ -0,0 +1,18 @@
+template <class T>
+class C
+{
+  friend void f (C<T> c)
+    {
+      c.i = 3;
+    }
+
+  int i;
+};
+
+
+int main()
+{
+  C<int> ci;
+
+  f(ci);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/friend9.C b/gcc/testsuite/g++.old-deja/g++.pt/friend9.C
new file mode 100644
index 00000000000..63455d01a52
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/friend9.C
@@ -0,0 +1,22 @@
+template <class U>
+class C
+{
+  template <class T>
+  friend void f(T);
+
+  int i;
+};
+
+
+template <class T>
+void f(T)
+{
+  C<int> c;
+  c.i = 3;
+}
+
+
+int main()
+{
+  f(7);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/goto.C b/gcc/testsuite/g++.old-deja/g++.pt/goto.C
new file mode 100644
index 00000000000..c6c1a569cf2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/goto.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template<class T>
+void compute(T) {
+    goto Exit;
+Exit: ;
+    }
+
+int main() 
+{
+  compute(0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/inherit1.C b/gcc/testsuite/g++.old-deja/g++.pt/inherit1.C
new file mode 100644
index 00000000000..6ae70c1bb9e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/inherit1.C
@@ -0,0 +1,25 @@
+// Origin: Wolfgang Bangerth <wolf@gaia.iwr.uni-heidelberg.de>
+
+int i = 1;
+
+struct Base1 {  int local1;  };
+struct Base2 {  int local2;  };
+
+template <int dim> class Derived;
+
+template <>
+class Derived<1> : public Base1, public Base2 {};
+
+template <int dim>
+class FinalClass :  public Derived<dim> {
+public:
+  FinalClass () {
+    if (&local1 != &local2)
+      i = 0;
+  }
+};
+
+int main () {
+  FinalClass<1> a1;
+  return i;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/instantiate1.C b/gcc/testsuite/g++.old-deja/g++.pt/instantiate1.C
new file mode 100644
index 00000000000..11f9c781988
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/instantiate1.C
@@ -0,0 +1,22 @@
+// Build don't link:
+
+template <class T>
+void f(T t) {}
+
+template void f<int>(int);
+template void f<>(long);
+
+template <class T>
+struct S
+{
+  void bar(int) {}
+  
+  template <class U>
+  void baz(U u) {}
+};
+
+
+template S<char>;
+template void S<int>::bar(int);
+template void S<double>::baz<short>(short);
+template void S<long>::baz<>(char);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/instantiate2.C b/gcc/testsuite/g++.old-deja/g++.pt/instantiate2.C
new file mode 100644
index 00000000000..a5c6c49d16f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/instantiate2.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template<class T>
+struct X_two {
+  template <class T2> T2 conv_compare_ge(T2 test) {
+    T2 tmp_value = T2 (0);
+    return (tmp_value > test ? tmp_value : test);
+  }
+};
+
+template int X_two<double>::conv_compare_ge(int);
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/instantiate3.C b/gcc/testsuite/g++.old-deja/g++.pt/instantiate3.C
new file mode 100644
index 00000000000..62062f7bfe9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/instantiate3.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+template <class T>
+struct S
+{
+  S(const T&) {}
+  S(int, long);
+};
+
+template S<double>::S(const double&);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/instantiate4.C b/gcc/testsuite/g++.old-deja/g++.pt/instantiate4.C
new file mode 100644
index 00000000000..296356b713f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/instantiate4.C
@@ -0,0 +1,27 @@
+// Build then link:
+
+// Special g++ Options: -frepo -Werror
+
+// Submitted by Melissa O'Neill <oneill@cs.sfu.ca>
+// the vtable of Foo<int> wouldn't be generated
+
+template <typename A>
+struct Foo {
+   virtual void foo() {}
+};
+
+template <typename A>
+struct Bar {   
+   void bar();
+};
+
+template <typename A> 
+void Bar<A>::bar() {
+   Foo<A> oof;
+}
+
+int main () {
+    Bar<int> rab;
+    
+    rab.bar();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/instantiate5-main.cc b/gcc/testsuite/g++.old-deja/g++.pt/instantiate5-main.cc
new file mode 100644
index 00000000000..be64bdbc4c2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/instantiate5-main.cc
@@ -0,0 +1,3 @@
+// this file is part of testcase instantiate5.C
+
+int main() {}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/instantiate5.C b/gcc/testsuite/g++.old-deja/g++.pt/instantiate5.C
new file mode 100644
index 00000000000..70eefcbb455
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/instantiate5.C
@@ -0,0 +1,14 @@
+// Build don't run:
+
+// Additional sources: instantiate5.cc instantiate5-main.cc
+
+// `global constructors' are given the same name, based on foo(), on
+// both translation units, which is wrong, because it must be possible
+// to define template functions in multiple translation units, as long
+// as they're given the same definition
+
+// simplified from test case submitted by Daniel X. Pape <dpape@canis.uiuc.edu>
+
+template <class T> void foo() { }
+inline int bar() { foo<void>(); return 1; }
+static int i = bar();
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/instantiate5.cc b/gcc/testsuite/g++.old-deja/g++.pt/instantiate5.cc
new file mode 100644
index 00000000000..fc86e0f8309
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/instantiate5.cc
@@ -0,0 +1,5 @@
+// this file is part of testcase instantiate5.C
+
+template <class T> void foo() { }
+inline int bar() { foo<void>(); return 1; }
+static int i = bar();
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/instantiate6.C b/gcc/testsuite/g++.old-deja/g++.pt/instantiate6.C
new file mode 100644
index 00000000000..e896ed32570
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/instantiate6.C
@@ -0,0 +1,26 @@
+// Build then link:
+// Special g++ Options: -frepo
+
+// Simplified from testcase by Erez Louidor Lior <s3824888@techst02.technion.ac.il>
+// excess errors test - XFAIL *-*-*
+
+template <class T>
+class foo{
+public:
+  void g();
+  void h();
+};
+
+template <class T>
+void foo<T>::g() {
+  h();
+}
+
+template <class T>
+void foo<T>::h() {
+}
+
+int main() {
+  foo<int> f;
+  f.g();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/label1.C b/gcc/testsuite/g++.old-deja/g++.pt/label1.C
new file mode 100644
index 00000000000..964d1d7afc3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/label1.C
@@ -0,0 +1,25 @@
+// Build don't link:
+
+template <class T>
+struct S {};
+
+template <class T>
+inline void g(T t)
+{
+ here:
+  S<T> st;
+  goto here;
+}
+
+template <class T>
+void f(T t)
+{
+ here:
+  g(t);
+  goto here;
+}
+
+void h()
+{
+  f(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/link1.C b/gcc/testsuite/g++.old-deja/g++.pt/link1.C
new file mode 100644
index 00000000000..b1991f62106
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/link1.C
@@ -0,0 +1,29 @@
+// Build don't run:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class T>
+int f(T);
+
+template <class T>
+struct S {
+  template <class U>
+  friend int f(U) { return 0; }
+};
+
+int k = f(2);
+
+template <class T>
+int g(T);
+
+int h = g(7);
+
+template <class T>
+int g(T) {
+  S<T> si;
+  return 0;
+}
+
+int main()
+{
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/local1.C b/gcc/testsuite/g++.old-deja/g++.pt/local1.C
new file mode 100644
index 00000000000..1b9e5155b52
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/local1.C
@@ -0,0 +1,21 @@
+template <class STRUCT, class MEMBER> inline STRUCT *
+setback(MEMBER *bp, MEMBER STRUCT::*offset)
+{
+        if(!bp) return 0;
+        union { int i; MEMBER STRUCT::*of; } u;
+        u.of = offset;
+        return (STRUCT *) ((int) bp - u.i);
+}
+ 
+
+struct S
+{
+  int i;
+};
+
+int main()
+{
+  S s;
+
+  S* sp = setback (&s.i, &S::i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/local2.C b/gcc/testsuite/g++.old-deja/g++.pt/local2.C
new file mode 100644
index 00000000000..4aafc695486
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/local2.C
@@ -0,0 +1,20 @@
+extern "C" void abort();
+
+template <class T>
+void f(T)
+{
+  struct S {
+    int i;
+  } s;
+
+  s.i = 3;
+
+  if (s.i != 3)
+    abort();
+}
+
+
+int main()
+{
+  f(7);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/local3.C b/gcc/testsuite/g++.old-deja/g++.pt/local3.C
new file mode 100644
index 00000000000..ea1b386b254
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/local3.C
@@ -0,0 +1,26 @@
+extern "C" void abort();
+
+template <class T>
+void f(T)
+{
+  int j;
+
+  j = 6;
+
+  struct S {
+    int i;
+  };
+
+  S s;
+
+  s.i = j;
+
+  if (s.i != 6)
+    abort();
+}
+
+
+int main()
+{
+  f(7);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/local4.C b/gcc/testsuite/g++.old-deja/g++.pt/local4.C
new file mode 100644
index 00000000000..6a7eb341e5b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/local4.C
@@ -0,0 +1,25 @@
+extern "C" void abort();
+
+template <class T>
+struct S {};
+
+S<int> si;
+
+template <class T>
+int f(T t)
+{
+  struct S { 
+    int g(int i) { return i + 2; }
+  };
+
+  S s;
+
+  return s.g(t) + s.g(t);
+}
+
+
+int main()
+{
+  if (f(3) != 10)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/local5.C b/gcc/testsuite/g++.old-deja/g++.pt/local5.C
new file mode 100644
index 00000000000..b49525c3484
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/local5.C
@@ -0,0 +1,24 @@
+template <class INT>
+class b
+{
+private:
+  char a(int x)
+  {
+    union {
+      int i;
+      char c;
+    } val;
+    val.i = x;
+    return val.c;
+  };
+
+public:
+  b()  {
+  }
+};
+
+int main() {
+  b<int> n;
+  return 0;
+}
+   
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/local6.C b/gcc/testsuite/g++.old-deja/g++.pt/local6.C
new file mode 100644
index 00000000000..d3f2f4c6f06
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/local6.C
@@ -0,0 +1,24 @@
+extern "C" void abort();
+
+template <class T>
+int f(T)
+{
+  struct S1 {
+    virtual int foo() { return 1; }
+  };
+
+  struct S2 : public S1 {
+    int foo() { return 2; }
+  };
+
+  S1* s2 = new S2;
+
+  return s2->foo();
+}
+
+
+int main()
+{
+  if (f(3) != 2)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/lookup1.C b/gcc/testsuite/g++.old-deja/g++.pt/lookup1.C
new file mode 100644
index 00000000000..359915cb6d7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/lookup1.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+template <class T, class Allocator>
+  struct __vector_alloc_base 
+{ 
+  typedef int allocator_type; 
+};
+
+template <class T>
+  struct vector :  __vector_alloc_base<T,int> 
+{
+  typedef short allocator_type;
+  explicit vector(const allocator_type& a = allocator_type()) {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/lookup2.C b/gcc/testsuite/g++.old-deja/g++.pt/lookup2.C
new file mode 100644
index 00000000000..169aee09ca3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/lookup2.C
@@ -0,0 +1,20 @@
+// Build don't link:
+// Special g++ Options:
+
+class A
+{
+protected:
+  void f1() {};
+};
+
+template <class T> class B : private A {
+protected:
+  using A::f1;
+};
+
+template <class T> class D : private B<T>
+{
+public:
+  void f2() { f1(); };
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/lookup3.C b/gcc/testsuite/g++.old-deja/g++.pt/lookup3.C
new file mode 100644
index 00000000000..9ada72f87b5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/lookup3.C
@@ -0,0 +1,17 @@
+template<class T>
+class A {
+public:
+  void f() { }
+};
+
+class B : public A<int> {
+public:
+  void f();
+};
+
+int main()
+{
+  B b;
+  B& b1 = b;
+  b1.A<int>::f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/lookup4.C b/gcc/testsuite/g++.old-deja/g++.pt/lookup4.C
new file mode 100644
index 00000000000..fe152526b69
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/lookup4.C
@@ -0,0 +1,24 @@
+// Build don't link:
+
+void h(int);
+
+template <class T>
+class i {};
+
+struct B
+{
+  int i;
+};
+
+template <class T>
+struct D : public B
+{
+  void f();
+  void g() { h(i); }
+};
+
+template <class T>
+void D<T>::f()
+{
+  h(i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/lookup5.C b/gcc/testsuite/g++.old-deja/g++.pt/lookup5.C
new file mode 100644
index 00000000000..e38b2227487
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/lookup5.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+struct B { 
+  int i;
+};
+
+struct D: public B {
+  int i;
+};
+
+template <class T>
+struct D2 : public D {
+  void f() { i = 3; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/lookup6.C b/gcc/testsuite/g++.old-deja/g++.pt/lookup6.C
new file mode 100644
index 00000000000..ae1f5ca2c5b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/lookup6.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+// Based on bug report by Miniussi <miniussi@ilog.fr>
+
+class t {};
+
+template <class T> struct A { typedef T t; typedef T u; };
+
+template <class T> struct B : public A<T> {
+  // according to [temp.dep.type], `t' and `u' cannot be dependent types,
+  // and so there's no reason to delay lookup to specialization time.
+  void f(t p); // this is ::t [temp.dep]/3
+  void f(typename A<T>::t p); // gets bogus error - redefinition
+  void g(u p); // ERROR - unknown type name
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/lookup7.C b/gcc/testsuite/g++.old-deja/g++.pt/lookup7.C
new file mode 100644
index 00000000000..9cc0d616d63
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/lookup7.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Origin: Jason Merrill <jason@cygnus.com>
+
+struct A { typedef int B; };
+template <int B> struct C : public A { 
+  B b; 
+  void f();
+};
+
+
+template <int B>
+void C<B>::f() {
+  B b;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/lookup8.C b/gcc/testsuite/g++.old-deja/g++.pt/lookup8.C
new file mode 100644
index 00000000000..cc562bf5d75
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/lookup8.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class T>
+class X{};
+
+class Y : public X<int>
+{
+  void f();
+};
+
+void Y::f()
+{
+  X x; // ERROR - X is not a type.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/lookup9.C b/gcc/testsuite/g++.old-deja/g++.pt/lookup9.C
new file mode 100644
index 00000000000..d81ffb63a96
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/lookup9.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// Origin: "Artem Hodyush" <artem@duma.gov.ru>
+
+struct B { int m; };
+
+template< class T >
+void
+q( T& t ) {
+  t.T::m=1;
+}
+
+void f() {
+  B b;
+  b.B::m=1;
+  q( b );
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/m1.C b/gcc/testsuite/g++.old-deja/g++.pt/m1.C
new file mode 100644
index 00000000000..7de0e0cd58e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/m1.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+
+int f1 () {
+  struct A {
+    A() : b (2) { }
+    int fred () { return b.hi_mom; }
+    struct B {
+      int hi_mom;
+      B (int a) { hi_mom = a; }
+    };
+    B b;
+  };
+  A aa;
+  return aa.fred();
+}
+/* crashes with signal 11 */
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/m2.C b/gcc/testsuite/g++.old-deja/g++.pt/m2.C
new file mode 100644
index 00000000000..00fdbadea0b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/m2.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+
+struct A { A() { a = 2; } int a; };
+
+int f1 () {
+  struct A { A() { a = 2; } int a; };
+  A aa;
+  return aa.a;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/m3.C b/gcc/testsuite/g++.old-deja/g++.pt/m3.C
new file mode 100644
index 00000000000..492b2611a31
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/m3.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+
+struct A { A() { a = 2; } int a; };
+
+struct B {
+  struct A { A() { a = 2; } int a; };
+  A aa;
+};
+char xx[]="../tests/m3.cc:4: redefinition of `struct A'";
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/m4.C b/gcc/testsuite/g++.old-deja/g++.pt/m4.C
new file mode 100644
index 00000000000..bbfb2272e61
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/m4.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+
+struct A1 { struct B { B(); } b; };
+struct A2 { struct B { ~B(); } b; };
+char xx[] ="../tests/m4.cc:1: warning: return type specification for constructor invalid";
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/m5.C b/gcc/testsuite/g++.old-deja/g++.pt/m5.C
new file mode 100644
index 00000000000..e8349704cae
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/m5.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+
+struct B { struct A { A(); int a; } aa; };
+struct A { A(); int a; };
+B::A::A () { a = 37; }
+char xx[]="../tests/m5.cc:3: Segmentation violation";
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/m6.C b/gcc/testsuite/g++.old-deja/g++.pt/m6.C
new file mode 100644
index 00000000000..5d0c81e0d1e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/m6.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+
+struct B { struct A { A(); int a; } aa; };
+B::A::A () { a = 37; }
+char* xx[] = {
+"../tests/m6.cc:1: warning: return type specification for constructor invalid",
+"../tests/m6.cc:2: semicolon missing after declaration of `A'",
+"../tests/m6.cc:2: warning: empty declaration",
+"../tests/m6.cc: In function int A ():",
+"../tests/m6.cc:2: `a' undeclared (first use this function)",
+"../tests/m6.cc:2: (Each undeclared identifier is reported only once",
+"../tests/m6.cc:2: for each function it appears in.)",
+"../tests/m6.cc:2: warning: control reaches end of non-void function" };
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/m7.C b/gcc/testsuite/g++.old-deja/g++.pt/m7.C
new file mode 100644
index 00000000000..06d2ba337a2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/m7.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+
+struct B { struct A { A(); int a; }; A aa; };
+B::A::A () { a = 37; }
+char *xx[]= {"/*",
+"../tests/m7.cc:1: warning: return type specification for constructor invalid",
+"../tests/m7.cc: In function struct A A ():",
+"../tests/m7.cc:2: `a' undeclared (first use this function)",
+"../tests/m7.cc:2: (Each undeclared identifier is reported only once",
+"../tests/m7.cc:2: for each function it appears in.)",
+"../tests/m7.cc:2: warning: control reaches end of non-void function",
+	       "*/" };
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/m8.C b/gcc/testsuite/g++.old-deja/g++.pt/m8.C
new file mode 100644
index 00000000000..22d01441bb1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/m8.C
@@ -0,0 +1,22 @@
+// Build don't link: 
+
+class A {
+  int a;
+ public:
+  A (int aa = 3);
+};
+
+class B {
+  class A {
+  public:
+    A (int, int);
+  };
+  A aa;
+ public:
+  B (int);
+};
+
+extern void foo();
+B::B (int z) : aa (1, z) {
+  foo ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/m9.C b/gcc/testsuite/g++.old-deja/g++.pt/m9.C
new file mode 100644
index 00000000000..d519dbdc728
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/m9.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+
+struct A { A() { a = 1; } int a; };
+struct Q {
+  struct A { A() { a = 2; } int a; };
+  struct R {
+     struct A { A() { a = 3; } int a; };
+     A aaz;
+  };
+  R rrr;
+  A aay;
+}
+;
+
+Q qqq;
+A aav;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/m9a.C b/gcc/testsuite/g++.old-deja/g++.pt/m9a.C
new file mode 100644
index 00000000000..9118306d697
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/m9a.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+
+struct A { A() { a = 1; } int a; }; // ERROR - 
+struct A { A() { a = 2; } int a; }; // ERROR - 
+A aavv;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass1.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass1.C
new file mode 100644
index 00000000000..5ad839c231e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass1.C
@@ -0,0 +1,13 @@
+template <class T> struct A {
+  template <class U> struct B {
+    template <class V> void f (V) { }
+    void g () { }
+  };
+};
+
+int main ()
+{
+  A<int>::B<char> b;
+  b.f (42);
+  b.g ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass10.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass10.C
new file mode 100644
index 00000000000..1deb38054cc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass10.C
@@ -0,0 +1,10 @@
+// Build don't link:
+
+struct S1
+{
+  template <class T>
+  struct S2 {}; // ERROR - previous definition
+
+  template <class T>
+  struct S2 {}; // ERROR - redefinition 
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass11.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass11.C
new file mode 100644
index 00000000000..6eee67a6e3d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass11.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+struct S1
+{
+  template <class T>
+  struct S2;
+
+  template <class T>
+  struct S2 {
+    enum E { a };
+  };
+};
+
+int i = (int) S1::S2<double>::a;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass12.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass12.C
new file mode 100644
index 00000000000..f4d035481a0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass12.C
@@ -0,0 +1,6 @@
+// Build don't link:
+
+struct outer {
+  template <class T> struct inner;
+} o;
+template <class T> struct outer::inner {};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass13.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass13.C
new file mode 100644
index 00000000000..7eddc278b25
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass13.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template <class X, class Y>
+struct Inner;
+
+template <class T>
+struct S
+{
+  template <class U>
+  struct Inner
+  {
+  };
+};
+
+
+S<double>::Inner<int> si;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass14.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass14.C
new file mode 100644
index 00000000000..ad1b2b4b5ac
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass14.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+template <class X, class Y>
+struct Inner;
+
+struct S
+{
+  template <class U>
+  struct Inner
+  {
+  };
+};
+
+
+S::Inner<int> si;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass15.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass15.C
new file mode 100644
index 00000000000..52f92bf5221
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass15.C
@@ -0,0 +1,27 @@
+// Build don't link:
+
+template <class T>
+struct S1
+{
+  template <class U>
+  struct S2 {};
+
+  template <class X, class Y, class Z>
+  void f(X, Y, Z)
+    {
+      S2<Z> s2z;
+    }
+
+  template <class X, class Z>
+  void g(X, Z)
+    {
+      S2<Z> s2z;
+    }
+};
+
+
+void h()
+{
+  S1<int> si;
+  si.g(3, 4);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass16.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass16.C
new file mode 100644
index 00000000000..e8e564369e9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass16.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+template <class Q>
+class A {
+public:
+ 
+        typedef enum { X, Y } B;
+        template <B c> class Traits{ };
+};
+
+
+template class A<int>;
+template class A<double>::Traits<A<double>::X>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass17.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass17.C
new file mode 100644
index 00000000000..96024e21859
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass17.C
@@ -0,0 +1,22 @@
+// Build don't link:
+
+template <class T> struct S 
+{
+  template <class U> struct I 
+  {
+  };
+
+  S();
+  S(S& s);
+  S(I<T>);
+
+  template <class U> operator I<U>();
+};
+
+S<int> f();
+void g(S<int>);
+
+void h()
+{
+  g(f());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass18.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass18.C
new file mode 100644
index 00000000000..bb7f6f12b99
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass18.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+template <class T> struct A {
+  template <class U> struct B;
+};
+
+template <class T> template <class U> struct A<T>::B { };
+
+A<int>::B<int> b;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass19.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass19.C
new file mode 100644
index 00000000000..6a8b0a7d11c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass19.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+template <class T> struct A {
+  template <class U> struct B;
+};
+
+template <class T> template <class U> struct A<T>::B<U*> { };
+
+A<int>::B<int*> b;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass2.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass2.C
new file mode 100644
index 00000000000..895fd6128e3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass2.C
@@ -0,0 +1,18 @@
+template <class T> struct A {
+  template <class U> struct B {
+    template <class V> void f (V) { }
+    void g () { }
+  };
+  template <class W> struct B<W*> {
+    void h () { }
+  };
+};
+
+int main ()
+{
+  A<int>::B<char> b;
+  b.f (42);
+  b.g ();
+  A<double>::B<void*> b2;
+  b2.h ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass20.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass20.C
new file mode 100644
index 00000000000..c57c27dfe09
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass20.C
@@ -0,0 +1,18 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class X, class Y>
+struct S{};
+
+template <class X> 
+struct S<int, X> {
+  template <class W>
+  struct I {};
+};
+
+template <class T>
+void f() {
+  typename S<T, T>::I<T> si;
+}
+
+template void f<int>();
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass3.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass3.C
new file mode 100644
index 00000000000..77744f854a9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass3.C
@@ -0,0 +1,21 @@
+template <class T> struct A {
+  template <class U> struct B {
+    template <class V> struct C {
+      template <class W> struct D {
+	template <class X> struct E {
+	  template <class Y> struct F {
+	    template <class Z> void f (Z) { }
+	    void g () { }
+	  };
+	};
+      };
+    };
+  };
+};
+
+int main ()
+{
+  A<int>::B<int>::C<int>::D<int>::E<int>::F<int> b;
+  b.f (42);
+  b.g ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass4.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass4.C
new file mode 100644
index 00000000000..4c101c6609d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass4.C
@@ -0,0 +1,23 @@
+#include <typeinfo>
+
+template <class T>
+struct allocator {
+  typedef T*        pointer;
+
+  template <class U> struct rebind {
+    typedef allocator<U> other;
+  };
+};
+
+template <class T, class Allocator>
+struct alloc_traits
+{
+  typedef typename Allocator::template rebind<T>::other allocator_type;
+};
+
+int main ()
+{
+  typedef alloc_traits<int, allocator<void> >::allocator_type at;
+
+  return typeid (at) != typeid (allocator <int>);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass5.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass5.C
new file mode 100644
index 00000000000..06a1413eb0e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass5.C
@@ -0,0 +1,22 @@
+template <class T> struct A {
+  template <class U> struct B {
+    template <class V> static void f () { }
+    void g () { }
+  };
+};
+
+template <class T, class U>
+void f ()
+{
+  A<T>::template B<U>::template f<T> ();
+  typename A<T>::B<U> b;
+  typename A<T>::template B<U> b2;
+  b.A<T>::template B<U>::~B();
+}
+
+template <class T> struct C: public A<T>::B<T> { };
+  
+int main ()
+{
+  f<int, char>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass6.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass6.C
new file mode 100644
index 00000000000..65de1d1bd99
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass6.C
@@ -0,0 +1,18 @@
+// Compiler: egcs-2.91.12 980302
+// Error:    compiler error in ctor of 'foo::bar<T>::bar(T const &)'
+
+struct foo
+{
+  template <typename T>
+        struct bar
+        {
+          bar(T const &t) : tt(t) {}
+          T tt;
+        };
+};
+
+int main()
+{
+  foo::bar<int> fb(3);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass7.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass7.C
new file mode 100644
index 00000000000..1a5cabe67a1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass7.C
@@ -0,0 +1,18 @@
+struct S 
+{
+  template <class U>
+  struct Y {
+    template <class T>
+    void foo(T t);
+  };
+};
+
+template <>
+template <>
+void S::Y<char>::foo<int>(int i) { }
+
+int main()
+{
+  S::Y<char> s;
+  s.template foo<int>(3.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass8.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass8.C
new file mode 100644
index 00000000000..431d41d64e8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass8.C
@@ -0,0 +1,11 @@
+// Build don't link:
+
+template <class T>
+class S
+{
+  template <class U>
+  struct S2 {
+    S2(const S2<U>& s2u) {}
+  };
+};
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memclass9.C b/gcc/testsuite/g++.old-deja/g++.pt/memclass9.C
new file mode 100644
index 00000000000..824ee76f0c5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memclass9.C
@@ -0,0 +1,32 @@
+// Build don't link:
+
+template <class T>
+struct S1
+{
+  template <class U>
+  struct S2
+  { 
+    S2(U);
+
+    void g() 
+      {
+	S2<U> s2u (u);
+      }
+
+    U& u;
+  };
+
+  template <class U>
+  void f(U u)
+    {
+      S2<U> s2u(u);
+      s2u.g();
+    }
+};
+
+void g()
+{
+  S1<int> s1;
+  s1.f(3.0);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp1.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp1.C
new file mode 100644
index 00000000000..94274e5003d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp1.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+struct S {
+  template <class T>
+  void foo(T&);
+};
+
+
+template <class T>
+void S::foo(T&)
+{
+}
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp10.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp10.C
new file mode 100644
index 00000000000..9e97b5e72f9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp10.C
@@ -0,0 +1,24 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+struct S {
+  template <class T>
+  operator T*();
+};
+
+
+template <class T>
+S::operator T*()
+{
+  printf("Hello, world.\n");
+  return 0;
+}
+
+
+int main()
+{
+  S s;
+
+  char* cp = s.operator char*();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp11.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp11.C
new file mode 100644
index 00000000000..a0d681dc199
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp11.C
@@ -0,0 +1,27 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+struct S
+{
+  template <class U>
+  S(U u, int i) {}
+
+  template <class T>
+  T foo(T t) 
+  { 
+    printf("Hello, world.\n");
+    return t; 
+  }
+};
+
+
+int main()
+{
+  S s(3, 4);
+  int i = s.foo(3);
+  s.foo("hello");
+  s.foo(s);
+  
+  S s2("hello", 5);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp12.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp12.C
new file mode 100644
index 00000000000..94a8c3c3026
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp12.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <class T>
+struct S
+{
+  template <class U>
+  void foo(U);
+};
+
+void f()
+{
+  S<int> s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp13.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp13.C
new file mode 100644
index 00000000000..d6bc7b967fd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp13.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <class T>
+struct S
+{
+  template <class U>
+  void foo(U);
+};
+
+void f()
+{
+  S<int> s;
+  s.foo(3);
+  s.foo("hello");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp14.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp14.C
new file mode 100644
index 00000000000..e24a3a7f0de
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp14.C
@@ -0,0 +1,30 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" const char* printf(const char*, ...);
+
+template <class T>
+struct S
+{
+  template <class U, class V>
+  void foo(U, V);
+};
+
+
+template <class T>
+template <class U, class V>
+void S<T>::foo(U, V)
+{
+  printf("Hello, world.\n");
+}
+
+
+int main()
+{
+  S<int> s;
+  s.foo(3, 3);
+  s.foo("hello", s);
+
+  S<char*> s2;
+  s2.foo(3, 3);
+  s2.foo("hello", s);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp15.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp15.C
new file mode 100644
index 00000000000..140730ba725
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp15.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <class T>
+struct S
+{
+  template <class U>
+  void foo(U) {}
+};
+
+
+void f()
+{
+  S<int> s;
+  s.foo(3);
+  s.foo("hello");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp16.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp16.C
new file mode 100644
index 00000000000..cfa66aac0ce
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp16.C
@@ -0,0 +1,30 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class U>
+struct S {
+  template <class T>
+  void operator+(T);
+};
+
+template <class U>
+template <class T>
+void S<U>::operator+(T)
+{
+  printf("Hello, world.\n");
+}
+
+
+int main()
+{
+  S<int> s;
+  s + 3;
+  s + s;
+  s.operator+("Hi");
+
+  S<S<int> > s2;
+  s2 + 3;
+  s2 + s;
+  s2.operator+("Hi");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp17.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp17.C
new file mode 100644
index 00000000000..0816b3665b5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp17.C
@@ -0,0 +1,26 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class V>
+struct S {
+  template <class T, class U>
+  S(T, U, T);
+};
+
+
+template <class V>
+template <class T, class U>
+S<V>::S(T t1, U u1, T t2)
+{
+  printf("Hello, world.\n");
+}
+
+
+int main()
+{
+  S<int> s1(3, "abc", 3);
+  S<int> s2('a', s1, 'a');
+
+  S<char> s3("abc", 3, "abc");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp18.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp18.C
new file mode 100644
index 00000000000..638e5e33852
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp18.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+struct S
+{
+  template <class T>
+  void foo(T) {}
+};
+
+template void S::foo(int);
+
+int main()
+{
+  S s;
+  s.foo(3);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp19.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp19.C
new file mode 100644
index 00000000000..8551531b5cd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp19.C
@@ -0,0 +1,25 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+struct S {
+  template <class T>
+  operator T();
+};
+
+template <class T>
+S::operator T()
+{
+  printf("Hello, world.\n");
+  return T();
+}
+
+
+template S::operator int();
+
+int main()
+{
+  S s;
+
+  int i = s.operator int();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp2.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp2.C
new file mode 100644
index 00000000000..e000ffaed1e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp2.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+struct S {
+  template <class T>
+  void foo(T&);
+};
+
+
+template <class U>
+void S::foo(U&)
+{
+}
+
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp20.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp20.C
new file mode 100644
index 00000000000..a79c53467d5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp20.C
@@ -0,0 +1,43 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+struct S
+{
+  template <class T, class U>
+  void foo(T t, U u);
+
+  template <class U>
+  void foo(char*, U);
+
+  void foo(int i);
+};
+
+template <class T, class U>
+void S::foo(T t, U u)
+{
+  printf ("T,U version\n");
+}
+
+
+template <class U>
+void S::foo(char*, U u)
+{
+  printf ("char*,U version\n");
+}
+
+
+void S::foo(int i)
+{
+  printf ("int version\n");
+}
+
+
+int main()
+{
+  S s;
+  s.foo(3);
+  s.foo(3, 3);
+  s.foo("abc", s);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp23.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp23.C
new file mode 100644
index 00000000000..5310b624fae
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp23.C
@@ -0,0 +1,24 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class X>
+struct S
+{
+  S()
+  { printf ("In S::S()\n"); f(3); }
+  
+  S(char)
+  { printf ("In S::S(char)\n"); f(*this); }
+
+  template <class U>
+  void f(U u)
+  { printf ("In S::f(U)\nsizeof(U) == %d\n", sizeof(u)); }
+
+  int c[16];
+};
+
+int main()
+{
+  S<char*> s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp24.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp24.C
new file mode 100644
index 00000000000..b1bfac17cdf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp24.C
@@ -0,0 +1,25 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class X>
+struct S
+{
+  S()
+  { printf ("In S::S()\n"); f(3); }
+  
+  S(char)
+  { printf ("In S::S(char)\n"); f(*this); }
+
+  template <class U>
+  void f(U u)
+  { printf ("In S::f(U)\nsizeof(U) == %d\n", sizeof(u)); }
+
+  int c[16];
+};
+
+int main()
+{
+  S<char*> s;
+  S<char*> s2('a');
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp25.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp25.C
new file mode 100644
index 00000000000..672a9c8e28d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp25.C
@@ -0,0 +1,20 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class X>
+struct S
+{
+  template <class U>
+  void f(U u) { printf ("%d\n", sizeof (U)); }
+
+  int i[4];
+};
+
+
+int main()
+{
+  S<char*> s;
+  s.f(3);
+  s.f(s);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp26.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp26.C
new file mode 100644
index 00000000000..cbfc93eb2cf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp26.C
@@ -0,0 +1,28 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class X>
+struct S
+{
+  template <class U>
+  void f(U u);
+
+  int i[4];
+};
+
+
+template <class X>
+template <class U>
+void S<X>::f(U u)
+{
+  printf ("%d\n", sizeof (U));
+}
+
+
+int main()
+{
+  S<char*> s;
+  s.f(3);
+  s.f(s);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp27.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp27.C
new file mode 100644
index 00000000000..b1bfac17cdf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp27.C
@@ -0,0 +1,25 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class X>
+struct S
+{
+  S()
+  { printf ("In S::S()\n"); f(3); }
+  
+  S(char)
+  { printf ("In S::S(char)\n"); f(*this); }
+
+  template <class U>
+  void f(U u)
+  { printf ("In S::f(U)\nsizeof(U) == %d\n", sizeof(u)); }
+
+  int c[16];
+};
+
+int main()
+{
+  S<char*> s;
+  S<char*> s2('a');
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp28.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp28.C
new file mode 100644
index 00000000000..37e79c8cfef
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp28.C
@@ -0,0 +1,27 @@
+extern "C" void abort();
+
+int k;
+
+template <class X>
+struct S
+{
+  template <class U>
+  void f(U u)
+  { ++k; g(u); }
+
+  template <class U>
+  void g(U u)
+  { ++k; }
+
+  int c[16];
+};
+
+int main()
+{
+  S<char*> s;
+  s.f(3);
+  s.f("adf");
+
+  if (k != 4)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp29.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp29.C
new file mode 100644
index 00000000000..4000070c30a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp29.C
@@ -0,0 +1,32 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class X>
+struct S
+{
+  template <class U>
+  void f(U u);
+
+  template <class U>
+  void g(U U);
+
+  int c[16];
+};
+
+template <class X>
+template <class U>
+void S<X>::f(U u)
+  { printf ("In S::f(U)\n"); g(u); }
+
+template <class X>
+template <class U>
+void S<X>::g(U u)
+  { printf ("In S::g(U)\n"); }
+
+int main()
+{
+  S<char*> s;
+  s.f(3);
+  s.f("adf");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp3.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp3.C
new file mode 100644
index 00000000000..2a4dbb85c31
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp3.C
@@ -0,0 +1,24 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+struct S {
+  template <class T>
+  void foo(T);
+};
+
+
+template <class T>
+void S::foo(T)
+{
+  printf("Hello, world.\n");
+}
+
+
+
+int main()
+{
+  S s;
+  s.foo(3);
+  s.foo(s);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp30.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp30.C
new file mode 100644
index 00000000000..923ec85a738
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp30.C
@@ -0,0 +1,17 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class X>
+struct S
+{
+  template <class U>
+  void g(U u) { this; }
+};
+
+
+int main()
+{
+  S<char*> s;
+  s.g(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp31.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp31.C
new file mode 100644
index 00000000000..3bb1cd3dd99
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp31.C
@@ -0,0 +1,16 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+struct S
+{
+  template <class U>
+  void g(U u)
+  { this; }
+};
+
+int main()
+{
+  S s;
+  s.g(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp32.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp32.C
new file mode 100644
index 00000000000..3f0bfc7729f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp32.C
@@ -0,0 +1,18 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+struct S
+{
+  template <class U>
+  void g(U u)
+  { i = 3; }
+
+  int i;
+};
+
+int main()
+{
+  S s;
+  s.g(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp33.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp33.C
new file mode 100644
index 00000000000..500abe0a30e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp33.C
@@ -0,0 +1,19 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class T>
+struct S
+{
+  template <class U>
+  void g(U u)
+  { i; }
+
+  int i;
+};
+
+int main()
+{
+  S<char> s;
+  s.g(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp34.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp34.C
new file mode 100644
index 00000000000..29e11017acf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp34.C
@@ -0,0 +1,16 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+template <class T>
+struct S
+{
+  template <class U>
+  static void f(U u)
+  {}
+};
+
+int main()
+{
+  S<int>::f(3);
+  S<char>::f("abc");
+  S<int>::f("abc");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp35.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp35.C
new file mode 100644
index 00000000000..7603d947b88
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp35.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <class T>
+struct S
+{
+  S(const S& s) {}
+
+  template <class U>
+  S(S<U>& s)
+  {
+    S<U> s2(s);
+  }
+};
+
+
+extern S<int>& si;
+
+void foo()
+{
+  S<char*> sc(si);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp36.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp36.C
new file mode 100644
index 00000000000..6c57a97c0ea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp36.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <class X>
+struct R
+{
+};
+
+
+template <class T>
+struct S
+{
+  template <class U>
+  S(R<U> r);
+};
+
+
+void foo()
+{
+  R<int> r;
+  S<char*> s(r);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp37.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp37.C
new file mode 100644
index 00000000000..186083b8009
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp37.C
@@ -0,0 +1,20 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <class T>
+struct S
+{
+  template <class U>
+  void f(U u);
+};
+
+
+template <class T>
+template <class U>
+void S<T>::f(U)
+{
+}
+
+enum 
+{
+  a = 3
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp39.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp39.C
new file mode 100644
index 00000000000..146d329de68
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp39.C
@@ -0,0 +1,17 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <class T>
+struct S
+{
+  template <class U>
+  void f(U u) { g(u); }
+
+  template <class U>
+  void g(U u) { f(u); }
+};
+
+void foo()
+{
+  S<int> si;
+  si.f(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp4.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp4.C
new file mode 100644
index 00000000000..b9f9c16a8e5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp4.C
@@ -0,0 +1,12 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+struct S {
+  template <class T>
+  void operator+(T);
+};
+
+
+template <class T>
+void S::operator+(T)
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp40.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp40.C
new file mode 100644
index 00000000000..70506f000ed
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp40.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <class T>
+struct R
+{
+  template <class U>
+  void g(U u) {}
+};
+
+template <class T>
+struct S
+{
+  template <class U>
+  void f(U u) { R<T> r; r.g(u); }
+};
+
+void foo()
+{
+  S<int> si;
+  si.f("abc");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp41.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp41.C
new file mode 100644
index 00000000000..603f702c4d1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp41.C
@@ -0,0 +1,7 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <int i>
+struct S
+{
+  static void foo() {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp42.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp42.C
new file mode 100644
index 00000000000..3c11dd4229c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp42.C
@@ -0,0 +1,22 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+template<class T, int N>
+class Foo {
+
+public:
+    template<int N2>
+    Foo<T,N> operator=(const Foo<T,N2>& z)
+    {
+        return Foo<T,N>();
+    }
+};
+
+int main()
+{
+    Foo<double,4> x;
+    Foo<double,7> y;
+    x = y;
+
+    return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp43.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp43.C
new file mode 100644
index 00000000000..3d8e3ad7cff
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp43.C
@@ -0,0 +1,16 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+template<class T, int N>
+class A
+{
+public:
+    template<class U>
+    void operator=(A<U, N> const & a) { return; }
+};
+
+int main()
+{
+    A<float, 3> a;
+    A<double, 3> b;
+    a = b;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp44.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp44.C
new file mode 100644
index 00000000000..c8d6f163c4d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp44.C
@@ -0,0 +1,20 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+template<class T>
+class A
+{
+};
+
+template<>
+class A<float>
+{
+public:
+    template<class U>
+    void func(U v1) {}
+};
+
+int main()
+{
+  A<float> a;
+  a.func(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp45.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp45.C
new file mode 100644
index 00000000000..d71f25d07d5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp45.C
@@ -0,0 +1,20 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+template<class T>
+class A
+{
+};
+
+template<>
+class A<float>
+{
+public:
+    template<class U>
+    void func(U v1 = 0) {}
+};
+
+int main()
+{
+  A<float> a;
+  a.func(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp46.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp46.C
new file mode 100644
index 00000000000..2212a52123f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp46.C
@@ -0,0 +1,20 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+template<class T, class U>
+class A
+{
+};
+
+template<class U>
+class A<float, U>
+{
+public:
+  template <class V>
+  void func(V v1 = 0) {}
+};
+
+int main()
+{
+  A<float, int> a;
+  a.func("abc");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp47.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp47.C
new file mode 100644
index 00000000000..e4f7ebf4922
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp47.C
@@ -0,0 +1,29 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+template <class X>
+struct S
+{
+  template <class U>
+  void g(U u)
+  { printf ("In S::g(U)\n"); }
+
+  int c[16];
+};
+
+
+template <class X>
+struct T : public S<X>
+{
+  template <class U>
+  void f(U u)
+  { printf ("In T::f(U)\n"); g(u); }
+};
+
+int main()
+{
+  T<char*> t;
+  t.f(3);
+  t.f("adf");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp48.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp48.C
new file mode 100644
index 00000000000..8ce6f668467
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp48.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+struct S
+{
+  template <class T>
+  void f(T t1, T t = T())
+  {}
+};
+
+
+void foo()
+{
+  S si;
+  si.f(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp49.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp49.C
new file mode 100644
index 00000000000..f2d610fdc44
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp49.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <class X>
+struct S
+{
+  template <class T>
+  void f(T t1, T t = T())
+  {}
+};
+
+
+void foo()
+{
+  S<int> si;
+  si.f(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp5.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp5.C
new file mode 100644
index 00000000000..14647a30560
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp5.C
@@ -0,0 +1,25 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+struct S {
+  template <class T>
+  void operator+(T);
+};
+
+
+template <class T>
+void S::operator+(T)
+{
+  printf("Hello, world.\n");
+}
+
+
+
+int main()
+{
+  S s;
+  s + 3;
+  s + s;
+  s.operator+("Hi");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp52.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp52.C
new file mode 100644
index 00000000000..25dc7e752be
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp52.C
@@ -0,0 +1,20 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template<class T, int N>
+class A { };
+
+template<int N>
+struct X {
+    template<class T2, int N2>
+    void f(A<T2,N>&, A<int,N2>&)
+    { }
+};
+
+
+void foo()
+{
+  X<3> x;
+  A<char*, 3> a1;
+  A<int, 2> a2;
+  x.f(a1, a2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp53.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp53.C
new file mode 100644
index 00000000000..4fd65b9f1cc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp53.C
@@ -0,0 +1,36 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+template<int N>
+struct I {
+};
+
+template<class T>
+struct A {
+
+  int r;
+
+  template<class T1, class T2>
+  void operator()(T1, T2)
+  { r = 0; }
+
+  template<int N1, int N2>
+  void operator()(I<N1>, I<N2>)
+  { r = 1; }
+};
+
+int main()
+{
+    A<float> x;
+    I<0> a;
+    I<1> b;
+
+    x(a,b);
+    if (x.r != 1)
+        return 1;
+
+    x(float(), double());
+    if (x.r != 0)
+        return 1;
+
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp55.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp55.C
new file mode 100644
index 00000000000..b955189a2c2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp55.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template<class X> class  _bz_update { };
+
+template<class T>
+struct S {
+template<int N_destRank>
+void foo() { _bz_update<int>(); }
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp56.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp56.C
new file mode 100644
index 00000000000..ef6b286a6fd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp56.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template<class P_numtype, int N_length>
+class TinyVector {};
+
+template<class P_numtype, int N_rank>
+struct Array 
+{
+    template<int N_rank2>
+    Array() {}
+  
+    template<int N_rank2>
+    P_numtype operator()(const TinyVector<int,N_rank2>& index) const {}
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp58.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp58.C
new file mode 100644
index 00000000000..38c295388d0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp58.C
@@ -0,0 +1,30 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template<int N, class T>
+struct B {
+};
+
+template<int N1, int N2, int N3>
+struct D {
+    struct E {
+        template<int N4, class T>
+        static void f(B<N4,T>)
+        { }
+    };
+};
+
+template<int N>
+struct A {
+    template<int N2, class T, int N3>
+    static void f(B<N2,T>, B<N3,T> b)
+    {
+        typedef typename D<N2,N3,N>::E E;
+	E::f(b);
+    }
+};
+
+void foo()
+{
+    A<5>::f(B<5,float>(),B<3,float>());
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp59.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp59.C
new file mode 100644
index 00000000000..fbdc0d850a2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp59.C
@@ -0,0 +1,22 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+template <int N>
+struct IndexPlaceholder {};
+
+template <int N1, int N2, int N3>
+struct ArrayIndexMapping {};
+
+template <class T_numtype, int N_rank>
+struct Array
+{
+  template<int N0, int N1>
+  ArrayIndexMapping<N_rank, N0, N1> 
+  f(IndexPlaceholder<N0>, IndexPlaceholder<N1>);
+};
+
+
+template <class T_numtype>
+void foo(T_numtype)
+{
+  Array<T_numtype, 1> t;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp6.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp6.C
new file mode 100644
index 00000000000..6989a7df735
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp6.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+struct S {
+  template <class T, class U>
+  S(T, U, T);
+};
+
+
+template <class T, class U>
+S::S(T, U, T)
+{
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp60.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp60.C
new file mode 100644
index 00000000000..7358d7225f7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp60.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// GROUPS passed membertemplates
+template <class T>
+struct S
+{
+  S(const S<T>& x)  {}
+
+  template <class U>
+  S(const S<U>& x)  {}
+}; 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp61.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp61.C
new file mode 100644
index 00000000000..1fdb055b357
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp61.C
@@ -0,0 +1,20 @@
+// Build don't run:
+// GROUPS passed membertemplates
+struct S
+{
+  template <class T>
+  void foo(T t);
+};
+
+
+template <>
+void S::foo(int i)
+{
+}
+
+
+int main()
+{
+  S s;
+  s.foo(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp62.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp62.C
new file mode 100644
index 00000000000..8cfadeffd3e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp62.C
@@ -0,0 +1,20 @@
+// Build don't run:
+// GROUPS passed membertemplates
+struct S
+{
+  template <class T>
+  void foo(T t);
+};
+
+
+template <>
+void S::foo<int>(int i)
+{
+}
+
+
+int main()
+{
+  S s;
+  s.foo(3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp63.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp63.C
new file mode 100644
index 00000000000..4f793d40e53
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp63.C
@@ -0,0 +1,13 @@
+template <class T> struct A {
+  template <class U> void f (U u);
+};
+
+A<int> a;
+
+template <class T> template <class U> void A<T>::f (U u) { }
+
+int main()
+{
+  a.f (24);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp64.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp64.C
new file mode 100644
index 00000000000..6185d3d6058
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp64.C
@@ -0,0 +1,21 @@
+// Build don't link:
+
+template <class T>
+struct S1 {};
+
+template <class T>
+void f(T);
+
+template <class C>
+struct S2
+{
+  template <class T>
+  void f<S1<T> >(T) {}  // ERROR - bad specialization.
+};
+
+
+template <class T>
+struct S3
+{
+  friend class S2<T>;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp65.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp65.C
new file mode 100644
index 00000000000..ef49d84317e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp65.C
@@ -0,0 +1,23 @@
+// Build don't link:
+
+template<unsigned int n> struct PartialDotProduct {
+    template<class T>
+    static T Expand(T* a, T* b) { return T(); }
+};
+
+const int N = 10;
+
+template<class In1, class In2>
+void
+dot(In1 f1, In2 f2)
+{
+  PartialDotProduct<N>::Expand(f1, f2);
+
+}
+
+int main()
+{
+  double a[N], b[N];
+  
+  dot(&a[0], &b[0]);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp66.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp66.C
new file mode 100644
index 00000000000..d7c1f57fc6c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp66.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+template <class T>
+struct S
+{
+  template <class U>
+  void f(U u) { this->template f<>(3); }
+};
+
+
+void g()
+{
+  S<char> s;
+  s.f(1.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp67.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp67.C
new file mode 100644
index 00000000000..7170c9027b8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp67.C
@@ -0,0 +1,19 @@
+template <class T>
+struct A
+{
+  template <class T2>
+  operator A<T2>() const { return A<T2>(); }
+};
+
+int main()
+{
+  A<int> a1;
+  A<long> a2;    
+  A<double> a3;
+  A<char> a4;
+
+  a2 = a1.operator A<long>();
+  a3 = (A<double>) a1;                   
+  a4 = a1;
+}
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp68.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp68.C
new file mode 100644
index 00000000000..96a08145c00
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp68.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+  struct locale
+  {
+    template<class _Facet>
+      locale (const locale&, _Facet*);
+    locale(int*) throw();
+  };
+  void f(int* p) { locale keep (p); }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp69.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp69.C
new file mode 100644
index 00000000000..4c9a2a91ca7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp69.C
@@ -0,0 +1,35 @@
+struct S 
+{
+  template <class T>
+  void f(T (&i)[7])
+    {}
+
+  void g()
+    {
+      int i[] = {1, 2, 3, 4, 5, 6, 7};
+      f(i);
+      int j[7];
+      f(j);
+    }
+};
+
+struct foo {
+  template <typename T, int N>
+  static T* array_end(T(&array)[N]) { return &array[N]; }
+};
+
+struct X
+{
+  template <class T1>
+  void f(const T1&) {}
+};
+
+int main(int ac, char* av[]) {
+  S s;
+  s.g();
+  int i[] = {1,2,3,4,5};
+  int* e = foo::array_end(i);
+  X x;
+  x.f("hello");
+}
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp7.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp7.C
new file mode 100644
index 00000000000..2dee05834f9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp7.C
@@ -0,0 +1,22 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+struct S {
+  template <class T, class U>
+  S(T, U, T);
+};
+
+
+template <class T, class U>
+S::S(T t1, U u1, T t2)
+{
+  printf("Hello, world.\n");
+}
+
+
+int main()
+{
+  S s1(3, "abc", 3);
+  S s2('a', s1, 'a');
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp70.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp70.C
new file mode 100644
index 00000000000..2a9fe8a2c35
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp70.C
@@ -0,0 +1,24 @@
+// Build don't link:
+
+template <class T>
+class X {
+public:
+  T x;
+};
+
+class Y {
+public:
+  template <class T> static void f(X<T>& a) {}
+
+  void g(void);
+};
+
+void
+Y::g(void)
+{
+  X<int> a;
+
+  f(a);
+}
+
+  
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp71.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp71.C
new file mode 100644
index 00000000000..38cf5c78549
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp71.C
@@ -0,0 +1,6 @@
+// Build don't link:
+
+class A
+{
+  template<class T>T epsilon; // ERROR - invalid member template
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp72.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp72.C
new file mode 100644
index 00000000000..52332c63c61
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp72.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+template<class P> struct B
+{
+  template<class T> void f(T& t) { t = T(); }
+};
+
+enum ptype { t1, t2};
+
+struct D : public B<ptype>
+{
+  void g(double& d) { f(d); }
+};
+
+
+D d;
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp73.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp73.C
new file mode 100644
index 00000000000..5732d49756e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp73.C
@@ -0,0 +1,18 @@
+template <class T> struct A {
+  template <class U> void f(U);
+};
+
+template <int i> struct B { };
+
+template <class T> template <class U>
+void A<T>::f (U)
+{
+  enum { foo };
+  B<foo> b;
+}
+
+int main ()
+{
+  A<char> a;
+  a.f (42);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp74.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp74.C
new file mode 100644
index 00000000000..e99103f40e6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp74.C
@@ -0,0 +1,21 @@
+// Build don't link:
+
+template <class T>
+class S
+{
+protected:
+  template <class U>
+  void f(U); // ERROR - is protected
+
+private:
+  template <class U>
+  void g(U); // ERROR - is private
+};
+
+
+void f()
+{
+  S<double> s;
+  s.f(3); // ERROR - within this context
+  s.g(2.0); // ERROR - within this context
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp75.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp75.C
new file mode 100644
index 00000000000..4ff38b6c04c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp75.C
@@ -0,0 +1,25 @@
+// Build don't link:
+
+void
+print(const int& i)
+{
+}
+
+template<class A>
+class bar
+{
+public:	
+  template<void (*B)(const A& a)>
+  void doit(const A& a)
+    {
+      B(a);
+    }
+};
+
+
+int
+main()
+{
+  bar<int>	b;
+  b.template doit<print>(2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp76.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp76.C
new file mode 100644
index 00000000000..b2028511a11
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp76.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+class base
+{
+public:
+  virtual void method()=0;
+};
+
+class der: public base
+{
+public:
+  template<class C>
+  void method()
+    {
+      C foo;
+    }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp77.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp77.C
new file mode 100644
index 00000000000..ca4cf20e7df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp77.C
@@ -0,0 +1,25 @@
+extern "C" int strcmp(const char*, const char*);
+
+template <class T>
+struct S3
+{
+  template <class U>
+  static char* h(U);
+};
+
+template <>
+template <>
+char* S3<double>::h(int) { return __PRETTY_FUNCTION__; }
+
+template <>
+template <>
+char* S3<char>::h(int) { return __PRETTY_FUNCTION__; }
+
+int main()
+{
+  if (strcmp (S3<double>::h(7), 
+	      "static char * S3<double>::h<int>(int)") == 0)
+    return 0;
+  else 
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp78.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp78.C
new file mode 100644
index 00000000000..945e7ff68f0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp78.C
@@ -0,0 +1,56 @@
+// Build don't link:
+
+struct A 
+{
+  void f() {}
+
+  template <class U>
+  void f() {}
+};
+
+
+template <class T>
+struct B
+{
+  void f() {}
+
+  template <class U>
+  void f() {}
+};
+
+template struct B<int>;
+
+struct C 
+{
+  template <class U>
+  void f() {}
+
+  template <class U>
+  void f() {}  // ERROR - redeclaration
+};
+
+
+template <class T, class U>
+struct D
+{
+  void f(T);
+  void f(U);
+};
+
+template struct D<int, double>;
+
+template <class T, class U>
+struct D2
+{
+  void f(T);
+  void f(U); // ERROR - redeclaration 
+};
+
+template struct D2<int, int>; 
+
+struct E
+{
+  void f(); 
+  void f(); // ERROR - redeclaration
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp79.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp79.C
new file mode 100644
index 00000000000..4eeffde4e7c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp79.C
@@ -0,0 +1,6 @@
+// Build don't link:
+
+struct foo {
+	template<typename T> static void bar( foo* );
+	template<typename T> void bar() const; // gets bogus error - quals XFAIL *-*-*
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp8.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp8.C
new file mode 100644
index 00000000000..1bf08908790
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp8.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// GROUPS passed templates membertemplates
+struct S {
+  template <class T>
+  operator T();
+};
+
+
+template <class T>
+S::operator T()
+{
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp80.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp80.C
new file mode 100644
index 00000000000..61a2fb87033
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp80.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template<typename T> T baz() { return 0; }
+
+struct foo {
+       template<typename T> static T staticbar() { return 0; }
+       template<typename T> T bar() { return 0; }
+};
+
+void f()
+{
+       foo t;
+       int i = baz<int>();
+       int j = foo::staticbar<int>();
+       int k = t.bar<int>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp81.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp81.C
new file mode 100644
index 00000000000..1584f88b802
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp81.C
@@ -0,0 +1,24 @@
+// Build don't link:
+
+template <int i> class a
+{
+public :
+int  k;
+
+template <int j> int f() const { return this->f<j-1>(); }
+
+int g() const { return f<i>(); };
+};
+
+template <>
+template <>
+int a<2>::f<0>() const {
+  return 0;
+}
+
+int main()
+{
+a<2> x;
+return x.g();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp82.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp82.C
new file mode 100644
index 00000000000..d4bb37aa410
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp82.C
@@ -0,0 +1,13 @@
+// Build don't link:
+// excess errors test
+
+struct foo {
+       template<typename T> T bar() { return staticbar<T>( this ); }
+       template<typename T> static T staticbar( foo* ) { return 0; }
+};
+
+void f()
+{
+       foo t;
+       int k = t.bar<int>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp83.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp83.C
new file mode 100644
index 00000000000..69ab94820b0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp83.C
@@ -0,0 +1,19 @@
+// Build don't link:
+// Origin: Corey Kosak <kosak@cs.cmu.edu>
+
+struct cow_t {
+  template<bool Q>
+  static void tfunc(cow_t *cowp) {}
+
+  void moo() {
+    cow_t *cowp;
+    tfunc<true>(cowp);
+  }
+};
+
+
+int main()
+{
+  cow_t *cowp;
+  cow_t::tfunc<true>(cowp);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/memtemp9.C b/gcc/testsuite/g++.old-deja/g++.pt/memtemp9.C
new file mode 100644
index 00000000000..943dbfb7767
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/memtemp9.C
@@ -0,0 +1,22 @@
+// Build don't run:
+// GROUPS passed templates membertemplates
+extern "C" int printf(const char*, ...);
+
+struct S {
+  template <class T>
+  operator T();
+};
+
+template <class T>
+S::operator T()
+{
+  printf("Hello, world.\n");
+  return T();
+}
+
+int main()
+{
+  S s;
+
+  int i = s.operator int();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/mi1.C b/gcc/testsuite/g++.old-deja/g++.pt/mi1.C
new file mode 100644
index 00000000000..82822611a4b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/mi1.C
@@ -0,0 +1,75 @@
+// Test that binfos aren't erroneously shared between instantiations.
+
+class PK_CryptoSystem
+{
+};
+class PK_Encryptor : public virtual PK_CryptoSystem
+{
+};
+class PK_FixedLengthCryptoSystem : public virtual PK_CryptoSystem
+{
+public:
+	virtual unsigned int CipherTextLength() const =0;
+};
+class PK_FixedLengthEncryptor : public virtual PK_Encryptor, public virtual PK_FixedLengthCryptoSystem
+{
+};
+class PK_SignatureSystem
+{
+public:
+	virtual ~PK_SignatureSystem() {};
+};
+class PK_Signer : public virtual PK_SignatureSystem
+{
+public:
+	virtual void Sign() = 0;
+};
+class PK_Verifier : public virtual PK_SignatureSystem
+{
+};
+class PK_Precomputation
+{
+};
+template <class T> class
+PK_WithPrecomputation : public T, public virtual PK_Precomputation
+{
+};
+typedef PK_WithPrecomputation<PK_FixedLengthEncryptor> PKWPFLE;
+typedef PK_WithPrecomputation<PK_Signer> PKWPS;
+template <class EC> class
+ECPublicKey : public PKWPFLE
+{
+public:
+	unsigned int CipherTextLength() const { return 1; }
+	EC ec;
+};
+template <class EC>
+class ECPrivateKey : public ECPublicKey<EC>, public PKWPS
+{
+	void Sign() {}
+	int d;
+};
+template <class EC>
+class ECKEP : public ECPrivateKey<EC>
+{
+};
+class GF2NT : public PK_CryptoSystem
+{
+	int t1;
+};
+class EC2N : public PK_CryptoSystem
+{
+	GF2NT field;
+	int a;
+};
+template class ECKEP<EC2N>;
+template class ECKEP<int>;
+
+int
+main ()
+{
+  ECKEP<EC2N> foo;
+
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/nested1.C b/gcc/testsuite/g++.old-deja/g++.pt/nested1.C
new file mode 100644
index 00000000000..3df7c47abb6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/nested1.C
@@ -0,0 +1,47 @@
+// Build don't link:
+
+template <class T1,class T2>
+struct X
+{
+  T1 a;
+
+  struct Y
+  {
+    T2 x;
+    Y (T2 _x) { x=_x; }
+  };
+
+};
+
+template <class T1>
+struct X<T1,int>
+{
+  T1 a;
+
+  struct Y
+  {
+    int x;
+    Y (int _x) { x=_x; }
+  };
+
+};
+
+template <>
+struct X<int,int>
+{
+  int a;
+
+  struct Y
+  {
+    int x;
+    Y (int _x) { x=_x; }
+  };
+
+};
+
+void f ()
+{
+  X<char,char> t1;
+  X<char,int> t2; 
+  X<int,int> t3;  
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/nested2.C b/gcc/testsuite/g++.old-deja/g++.pt/nested2.C
new file mode 100644
index 00000000000..ce52b4e5cea
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/nested2.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// Origin: Mathias Doreille <Mathias.Doreille@imag.fr>
+
+template<class T>
+struct  a {
+  struct b {
+    T operator()();
+  };
+};
+
+
+template<class T>
+T a<T>::b::operator()() { return T(0); }
+
+template<> int a<int>::b::operator()() { return 1; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/niklas01.C b/gcc/testsuite/g++.old-deja/g++.pt/niklas01.C
new file mode 100644
index 00000000000..6dcf9d3efaf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/niklas01.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+
+template <class T> struct A {};
+template <class T> struct B : A<B<T> > {};
+
+B<int> x;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/niklas01a.C b/gcc/testsuite/g++.old-deja/g++.pt/niklas01a.C
new file mode 100644
index 00000000000..027f2ae9595
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/niklas01a.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+
+struct A {
+  friend struct B : A {		// ERROR - 
+    int x;
+  };
+  int y;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/niklas01b.C b/gcc/testsuite/g++.old-deja/g++.pt/niklas01b.C
new file mode 100644
index 00000000000..fa2e5ac884a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/niklas01b.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+
+template <class T> struct A { T *t; inline A() { t = 0; } };
+template <class T> struct B : A<B<T> > { int x; inline B() { x = 3; } };
+
+B<int> x;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/niklas02.C b/gcc/testsuite/g++.old-deja/g++.pt/niklas02.C
new file mode 100644
index 00000000000..b4d300deaed
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/niklas02.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+
+struct B { int foo (); };
+int B::foo() { return 37; }
+
+template <class A> struct X {
+  void f(int);
+};
+
+template <class A> void X<A>::f (int jj)
+{}
+
+X<int> x;
+
+void xxx () { x.f (1); }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/niklas03.C b/gcc/testsuite/g++.old-deja/g++.pt/niklas03.C
new file mode 100644
index 00000000000..29b19726a2d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/niklas03.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+
+template <class A> struct X {
+  A operator[] (int);
+};
+
+template <class A> A X<A>::operator[] (int i)
+{
+  return A();	// gets bogus error
+}
+
+X<int> x;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/nontype1.C b/gcc/testsuite/g++.old-deja/g++.pt/nontype1.C
new file mode 100644
index 00000000000..120282a7a45
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/nontype1.C
@@ -0,0 +1,19 @@
+// Build don't link:
+
+template<int N_length>
+struct B
+{
+    B();
+    ~B();
+};
+template<class P, int N>
+struct D
+{
+    D(int r0);
+    D(B<N-1> &, int);
+};
+template<class T>
+void func()
+{
+    D<T,1> tmp;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/nontype2.C b/gcc/testsuite/g++.old-deja/g++.pt/nontype2.C
new file mode 100644
index 00000000000..e18141191a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/nontype2.C
@@ -0,0 +1,20 @@
+// Build don't link:
+
+enum E { };
+
+template <const E* ep>
+struct S1
+{
+};
+
+
+struct S2
+{
+  static E es[1];
+};
+
+
+struct S3
+{
+  typedef S1<S2::es> S3_Type;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/nontype3.C b/gcc/testsuite/g++.old-deja/g++.pt/nontype3.C
new file mode 100644
index 00000000000..d6f339453ad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/nontype3.C
@@ -0,0 +1,28 @@
+// Build don't link:
+
+enum E { e };
+
+template <const E* ep>
+struct S1
+{
+  static char* s;
+};
+
+template <int D>
+struct S2 {};
+
+template <>
+struct S2<1>
+{
+  static E es[1];
+};
+
+struct S3
+{
+  typedef S1<S2<1>::es> S3_Type;
+};
+
+E S2<1>::es[1] = {e};
+
+template <>
+char* S1<S2<1>::es>::s = "abc";
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/nontype4.C b/gcc/testsuite/g++.old-deja/g++.pt/nontype4.C
new file mode 100644
index 00000000000..2aa38b1cd67
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/nontype4.C
@@ -0,0 +1,31 @@
+// Build don't link:
+
+template <class R, void (R::* A) (void)>
+class s
+{
+public:
+  s (R &r) : _r (r) {}
+
+  void e (void) { (_r.*A) (); }
+
+private:
+  R &_r;
+};
+
+class x
+{
+public:
+  void test1 (void) { int j = 0; }
+  void test2 (void) { int j = 1; }
+};
+
+int
+main (void)
+{
+  x r;
+
+  s<x, &x::test1> c4 (r);
+  s<x, &x::test2> c5 (r);
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/nttp1.C b/gcc/testsuite/g++.old-deja/g++.pt/nttp1.C
new file mode 100644
index 00000000000..36b743848c4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/nttp1.C
@@ -0,0 +1,21 @@
+// Test for nested template template parameter feature
+
+template <template<template <class> class> class TTT> struct C
+{
+	int f();
+};
+
+template <template<template <class> class> class TTT> int C<TTT>::f()
+{
+	return 0;
+}
+
+template <template <class> class TT> struct D
+{
+};
+
+int main()
+{
+	C<D> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/nttp2.C b/gcc/testsuite/g++.old-deja/g++.pt/nttp2.C
new file mode 100644
index 00000000000..08781daf516
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/nttp2.C
@@ -0,0 +1,30 @@
+// Test for nested template template parameter feature
+
+template <template<template <class> class> class TTT> struct C
+{
+	int f() { return 0; }
+};
+
+template <template <class> class TT> struct D
+{
+	int	a;
+};
+
+template <template <class> class TT> struct E
+{
+	int	a;
+	int	b;
+};
+
+template <template <template <template<class> class> class> class TTT> 
+int g(TTT<E> t)
+{
+	TTT<D> tt;
+	return tt.f();
+}
+
+int main()
+{
+	C<E> c;
+	g(c);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload1.C b/gcc/testsuite/g++.old-deja/g++.pt/overload1.C
new file mode 100644
index 00000000000..25a40b13f02
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload1.C
@@ -0,0 +1,15 @@
+template <class T> struct B { };
+
+template <class T> struct A {
+  template <class U, class V> int operator () (U u, V v);
+  template <class U, class V> void operator () (B<U> u, B<V> v) { }
+};
+
+int
+main ()
+{
+  A<int> a;
+  B<char> b1;
+  B<short> b2;
+  a (b1, b2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload10.C b/gcc/testsuite/g++.old-deja/g++.pt/overload10.C
new file mode 100644
index 00000000000..19dd174a019
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload10.C
@@ -0,0 +1,16 @@
+struct B {
+  int f(int) { return 1; }
+};
+
+struct D {
+  template <class T>
+  int f(T) { return 0; }
+};
+
+int main()
+{
+  int (D::*g)(int) = &D::f;
+  
+  D d;
+  return (d.*g)(0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload11.C b/gcc/testsuite/g++.old-deja/g++.pt/overload11.C
new file mode 100644
index 00000000000..300d91ea2b8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload11.C
@@ -0,0 +1,27 @@
+// Build don't run:
+
+template <class T>
+int f(int (*fn)(T))
+{
+  return (*fn)(3);
+}
+
+struct S {
+  static int g(int) { return 1; }
+  static void g();
+
+  int h();
+};
+
+int S::h()
+{
+  return f(&g);
+}
+
+
+int main()
+{
+  S s;
+  if (s.h () != 1)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload12.C b/gcc/testsuite/g++.old-deja/g++.pt/overload12.C
new file mode 100644
index 00000000000..bf37bb66867
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload12.C
@@ -0,0 +1,21 @@
+// Testcase for not trying a candidate that would generate an ill-formed
+// instantiation.
+
+template <int N> struct A {
+  int ar[N];
+};
+
+template <int N> struct B {
+  B () { };
+  B (const A<N> &) { };
+  B (const A<N-1> &, int);
+};
+
+int
+main ()
+{
+  A<1> a;
+  B<1> b1;
+  B<1> b2 (a);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload2.C b/gcc/testsuite/g++.old-deja/g++.pt/overload2.C
new file mode 100644
index 00000000000..809fac4eeda
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload2.C
@@ -0,0 +1,16 @@
+//Build don't link:
+template<class T>
+class C
+{
+public:
+	C<T*> O();
+	C<T*> O() const;
+};
+
+
+int
+main()
+{
+	C<char*>	c;
+	char*		p = Z(c.O); //ERROR - ambiguous c.O
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload3.C b/gcc/testsuite/g++.old-deja/g++.pt/overload3.C
new file mode 100644
index 00000000000..a716917bc0a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload3.C
@@ -0,0 +1,18 @@
+// Build don't link:
+
+template <class T>
+void g(T, T);
+
+template <class T>
+void g(int*, T);
+
+struct S
+{
+  void f() const
+    {
+      g(X, X+3);
+    }
+
+  double X[3];
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload4.C b/gcc/testsuite/g++.old-deja/g++.pt/overload4.C
new file mode 100644
index 00000000000..f4e58e27fc7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload4.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template <class T> void foo(T);
+
+template <class T> void bar(void (*)(T), T);
+
+void baz() {
+  bar<int>(foo, 1);
+  bar(foo<int>, 1);
+  bar<int>(foo<int>, 1);
+  bar(foo, 1); 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload5.C b/gcc/testsuite/g++.old-deja/g++.pt/overload5.C
new file mode 100644
index 00000000000..058f4f4325c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload5.C
@@ -0,0 +1,6 @@
+// Build don't link:
+
+template <class T> void foo();	// ERROR - candidate
+
+void (*bar)() = foo<void>;
+void (*baz)() = foo; // ERROR - can't deduce T
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload6.C b/gcc/testsuite/g++.old-deja/g++.pt/overload6.C
new file mode 100644
index 00000000000..10f793a8633
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload6.C
@@ -0,0 +1,13 @@
+// Check that foo<int> isn't resolved too early.
+
+template <class T> void foo(T*);
+template <class T, class U> void foo(T*, U) { }
+
+template <class T, class U> void bar(void (*)(T, U), U) { }
+
+int main() {
+  bar<int*>(&foo, 1);
+  bar<int*>(&foo<int>, 1);  
+  bar<int*>(foo, 1);
+  bar<int*>(foo<int>, 1);  
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload7.C b/gcc/testsuite/g++.old-deja/g++.pt/overload7.C
new file mode 100644
index 00000000000..bfd8b5a5eb4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload7.C
@@ -0,0 +1,20 @@
+// Build don't link:
+
+// Adapted from testcase by Corey Kosak <kosak@cs.cmu.edu>
+
+template<class T>
+struct moo_t {
+  struct cow_t {};
+};
+
+template<class T> void foo(typename moo_t<T>::cow_t) {}
+
+template<class T> void foo(moo_t<T>) {
+  typename moo_t<T>::cow_t p;
+  foo(p); // gets bogus error - no matching function for call - XFAIL *-*-*
+}
+
+int main() {
+  moo_t<int> x;
+  foo(x); // gets bogus error - instantiated from here - XFAIL *-*-*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload8.C b/gcc/testsuite/g++.old-deja/g++.pt/overload8.C
new file mode 100644
index 00000000000..9f38a5cb256
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload8.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+// Simplified from bug report by Tim Rowley <tor@cs.brown.edu>
+
+struct baz;
+
+void operator*(baz&, double);
+
+template <class T> inline T operator*(double s, const T &p)
+  ; // gets bogus error - must have argument of class type - XFAIL *-*-*
+
+void m(baz& a) { a * .5; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/overload9.C b/gcc/testsuite/g++.old-deja/g++.pt/overload9.C
new file mode 100644
index 00000000000..bd9eeb1791a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/overload9.C
@@ -0,0 +1,21 @@
+template <class T>
+int f(T)
+{
+  return 1;
+}
+
+
+template <class T>
+int f(T*)
+{
+  return 0;
+}
+
+
+int main()
+{
+  int (*h)(int*) = &f;
+  int (&k)(int*) = f;
+
+  return (*h)(0) || (*k)(0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/parse2.C b/gcc/testsuite/g++.old-deja/g++.pt/parse2.C
new file mode 100644
index 00000000000..f7b737e6915
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/parse2.C
@@ -0,0 +1,8 @@
+// Build don't link:
+// Origin: Jason Merrill <jason@cygnus.com>
+
+template <class T> struct A {
+  A (const A&) { }
+};
+
+template A<int>::A (const A&);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/partial1.C b/gcc/testsuite/g++.old-deja/g++.pt/partial1.C
new file mode 100644
index 00000000000..7a929962fd4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/partial1.C
@@ -0,0 +1,26 @@
+template<class T_type, int N>
+class foo {
+public:
+  enum bar { z = 0 };
+};
+
+template<int N>
+class foo<double, N> {
+public:
+  enum bar { z = 1 };
+};
+
+template<class T_type>
+class foo<T_type, 2> {
+public:
+  enum bar { z = 2 };
+};
+
+int main()
+{
+    if ((foo<int,3>::z == 0) && (foo<double,3>::z == 1) 
+       && (foo<float,2>::z == 2))
+           return 0;
+    else
+        return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/partial2.C b/gcc/testsuite/g++.old-deja/g++.pt/partial2.C
new file mode 100644
index 00000000000..cdf2199b012
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/partial2.C
@@ -0,0 +1,23 @@
+// Build don't link:
+// Tests partial specialization
+template<class T> struct foo1 {};
+template<class T, int n> struct foo1<T[n]>;
+foo1<char> bar1;
+foo1<char[10]> baz1; // ERROR - incomplete type
+
+template<class T> struct foo2 {};
+template<class T, unsigned n> struct foo2<T[n]>;
+foo2<char> bar2;
+foo2<char[10]> baz2; // ERROR - incomplete type
+
+typedef unsigned int other1_t;
+template<class T> struct foo3 {};
+template<class T, other1_t n> struct foo3<T[n]>;
+foo3<char> bar3;
+foo3<char[10]> baz3; // ERROR - incomplete type - 
+
+typedef int other2_t;
+template<class T> struct foo4 {};
+template<class T, other1_t n> struct foo4<T[n]>;
+foo4<char> bar4;
+foo4<char[10]> baz4; // ERROR - incomplete type - 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/partial3.C b/gcc/testsuite/g++.old-deja/g++.pt/partial3.C
new file mode 100644
index 00000000000..49820db532c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/partial3.C
@@ -0,0 +1,16 @@
+// Test that partial ordering works between conversion ops from different
+// classes.
+// From Jason Merrill <jason@cygnus.com>
+
+struct A {
+  template <class T> operator T*() { return 0; }
+};
+struct B : public A {
+  template <class T> operator T();
+};
+
+int main()
+{
+  B b;
+  (void*) b;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/pointer1.C b/gcc/testsuite/g++.old-deja/g++.pt/pointer1.C
new file mode 100644
index 00000000000..f85497674df
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/pointer1.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+template <class T>
+struct S1
+{
+};
+
+template <class T>
+struct S2
+{
+  typedef T* pointer_t;
+};
+
+int f(S2<S1<int> >::pointer_t p1, S2<S1<int> >::pointer_t p2)
+{
+  return (int) (p1 - p2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ptrmem1.C b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem1.C
new file mode 100644
index 00000000000..e14c726c1d7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem1.C
@@ -0,0 +1,18 @@
+class foo
+{
+public:
+  template<class T>
+  T bar() { return 7; }
+};
+
+int
+main()
+{
+  foo f;
+  
+  int (foo::*s)() = &foo::template bar<int>;
+  if ((f.*s)() == 7)
+    return 0;
+  else 
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ptrmem2.C b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem2.C
new file mode 100644
index 00000000000..c6927d19472
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem2.C
@@ -0,0 +1,43 @@
+struct S;
+
+template <S* (S::*p)()>
+struct F {
+  S* f (S& s)
+    {
+      return (s.*p)();
+    }
+};
+
+template <int S::*p>
+struct D {
+  void d (S& s)
+    {
+      (s.*p) = 3;
+    }
+};
+
+struct S {
+  S* g ();
+  int i;
+  F<&S::g> fg;
+  D<&S::i> di;
+  S* h(), k(F<&S::h>);
+  F<&S::g> fg2;
+  D<&S::i> di2;
+};
+
+S* S::g()
+{
+  return this;
+}
+
+int main()
+{
+  S s;
+  s.i = 2;
+  s.di.d (s);
+  if (s.i != 3)
+    return 1;
+  if (s.fg2.f(s) != &s)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ptrmem3.C b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem3.C
new file mode 100644
index 00000000000..8b7c373c1b7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem3.C
@@ -0,0 +1,12 @@
+// Build don't link:
+
+template <class T>
+struct S : public S<T*> {};
+template <>
+struct S<int**> {};
+
+void g()
+{
+  int S<int*>::*p;
+  int S<int>::*q = p;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ptrmem4.C b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem4.C
new file mode 100644
index 00000000000..139be923550
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem4.C
@@ -0,0 +1,28 @@
+// Build don't run:
+
+template<class T,class T1>
+int connect_to_method(T* receiver,
+                      int (T1::*method)()) 
+{ 
+  return (receiver->*method)();
+}
+
+class Gtk_Container
+{
+public:
+  int remove_callback() { return 1; }
+  void remove_callback(int);
+  int f();
+};
+
+int Gtk_Container::f() 
+{
+  return connect_to_method(this, &Gtk_Container::remove_callback);
+}
+
+int main()
+{
+  Gtk_Container gc;
+  if (gc.f () != 1)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ptrmem5.C b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem5.C
new file mode 100644
index 00000000000..c9e6c9b9841
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem5.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+// Based on testcase by adriang@campbellsoft.com
+
+struct Null {
+  template <typename T> operator T*() { return 0; }
+  template <typename C, typename T> operator T C::*() { return 0; }
+#if WORK_AROUND
+  typedef int pmf();
+  template <typename C> operator pmf C::* () { return 0; }
+#endif
+} NULL;
+
+int *pd = NULL;
+int (*pf)() = NULL;
+int Null::*pmd = NULL;
+int (Null::*pmf)() = NULL; // gets bogus error - cannot convert - XFAIL *-*-*
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ptrmem6.C b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem6.C
new file mode 100644
index 00000000000..946e6244f4a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem6.C
@@ -0,0 +1,34 @@
+// Build don't link:
+
+class A {
+public:
+  virtual void f();
+  int i;
+};
+
+class B : public A {
+public:
+  void f();
+  int j;
+};
+
+template <void (A::*)() >
+void g() {}
+template <int A::*>
+void h() {}
+
+
+int main() {
+  g<&A::f>();
+  h<&A::i>();
+  g<&B::f>(); // ERROR - 
+  h<&B::j>(); // ERROR - 
+  g<(void (A::*)()) &A::f>(); // ERROR - XFAIL *-*-*
+  h<(int A::*) &A::i>(); // ERROR - 
+  g<(void (A::*)()) &B::f>(); // ERROR - 
+  h<(int A::*) &B::j>(); // ERROR - 
+  g<(void (A::*)()) 0>(); // ERROR - 
+  h<(int A::*) 0>(); // ERROR - 
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ptrmem7.C b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem7.C
new file mode 100644
index 00000000000..9efeec87a68
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ptrmem7.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Origin: Jason Merrill <jason@cygnus.com>
+
+struct A {
+  int i;
+};
+
+template<const int A::* P>
+struct B { };
+
+int main()
+{
+  B<&A::i> b;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/recursion.C b/gcc/testsuite/g++.old-deja/g++.pt/recursion.C
new file mode 100644
index 00000000000..7efaeb059c0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/recursion.C
@@ -0,0 +1,31 @@
+// Build don't link:
+
+const double M_PI=3.14159265358979323846;
+
+template<int N,int I,int J,int K>
+inline double SineSeries()
+{
+  const double x=I*2*M_PI/N;
+  const bool go=K+1!=J;
+  return 1.0-x*x/(2*K+2)/(2*K+3)*SineSeries<N*go,I*go,J*go,(K+1)*go>();
+}
+
+template<>
+inline double SineSeries<0,0,0,0>()
+{
+  return 1.0;
+}
+
+template<int N,int I>
+inline double Sine()
+{
+  const double x=(I*2*M_PI/N);
+  return x * SineSeries<N,I,10,0>();
+}
+
+int main()
+{
+  double f=Sine<32,5>();
+  return 0;
+}
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/recursion2.C b/gcc/testsuite/g++.old-deja/g++.pt/recursion2.C
new file mode 100644
index 00000000000..8cb3a2b30c7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/recursion2.C
@@ -0,0 +1,25 @@
+template< int i > struct T :
+public T< i-1 >
+{
+};
+
+template<> struct T< 0 >
+{
+};
+
+template< class F > struct T1 :
+public T< F::dim >
+{
+};
+
+template< int i > struct S
+{
+  enum { dim = i } ;
+};
+
+int main()
+{
+  T1< S< 4 > > t ;
+  return( 0 ) ;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/redecl1.C b/gcc/testsuite/g++.old-deja/g++.pt/redecl1.C
new file mode 100644
index 00000000000..283d83f2aff
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/redecl1.C
@@ -0,0 +1,22 @@
+// Build don't link:
+
+template <class T>
+struct S1; // ERROR - previous declaration
+
+template <class T, class U>
+struct S1 {}; // ERROR - used 1 template parameter
+
+template <class T = int> // ERROR - original def of default
+struct S2; 
+
+template <class T = int>
+struct S2; // ERROR - redefinition of default
+
+template <class T> // ERROR - template parameter
+struct S3;
+
+template <int I>
+struct S3; // ERROR - redeclared here
+
+template <template <class T> class C>
+struct S3; // ERROR - redeclared here
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/redecl2.C b/gcc/testsuite/g++.old-deja/g++.pt/redecl2.C
new file mode 100644
index 00000000000..0b65e1ec957
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/redecl2.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+struct A 
+{
+  template <class A>
+  void f(A) {}
+};
+
+void g()
+{
+  A a;
+  a.f(3);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ref1.C b/gcc/testsuite/g++.old-deja/g++.pt/ref1.C
new file mode 100644
index 00000000000..8b117a5fffb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ref1.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+int i;
+
+template <void (&FN)()>
+void g ()
+{
+  FN ();
+}
+
+void h ()
+{
+  i = 7;
+}
+
+template void g<h>();
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/scope1.C b/gcc/testsuite/g++.old-deja/g++.pt/scope1.C
new file mode 100644
index 00000000000..cfd9cdffb32
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/scope1.C
@@ -0,0 +1,13 @@
+// Build don't link:
+
+template<class X, class Z>
+class foo
+{
+public:
+  typedef X y;
+
+  class bar {
+  public:
+    void blah () { y Y; }
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/shadow1.C b/gcc/testsuite/g++.old-deja/g++.pt/shadow1.C
new file mode 100644
index 00000000000..dfe99c7b22d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/shadow1.C
@@ -0,0 +1,19 @@
+// Build don't link:
+
+template <class T>
+struct S {
+  typedef T X;
+
+  class C {
+    typedef T X;
+  };
+};
+
+template <int I>
+struct S2 {
+  enum { A = I };
+
+  void f() {
+    int A;
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/shadow2.C b/gcc/testsuite/g++.old-deja/g++.pt/shadow2.C
new file mode 100644
index 00000000000..452e8ca63b9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/shadow2.C
@@ -0,0 +1,10 @@
+// Build don't link:
+// Origin: Jason Merrill <jason@cygnus.com>
+
+template <class T> struct A { // ERROR - shadowed parameter
+  struct B {
+    void T(); // ERROR - shadows template parameter
+  };
+};
+A<int> a;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/sizeof.C b/gcc/testsuite/g++.old-deja/g++.pt/sizeof.C
new file mode 100644
index 00000000000..41915b30927
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/sizeof.C
@@ -0,0 +1,17 @@
+extern "C" void abort();
+
+template <int I>
+int bar() { return I; }
+
+template <class T>
+int foo(T)
+{
+  return bar<sizeof(T) + 4>() + bar<sizeof(long) + 7>();
+}
+
+
+int main()
+{
+  if (foo(2) != sizeof(int) + 4 + sizeof(long) + 7)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/sizeof2.C b/gcc/testsuite/g++.old-deja/g++.pt/sizeof2.C
new file mode 100644
index 00000000000..566665af23c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/sizeof2.C
@@ -0,0 +1,20 @@
+// Although template class B is not used at all, it causes the
+// incorrect specialization of A to be selected
+
+// Adapted from testcase by Oskar Enoksson <osken393@student.liu.se>
+
+extern "C" void abort();
+
+template<int N, class T> // Base class
+class A { public: static int n() { return sizeof(T); } };
+
+template<int N> // Derived #1
+class B: public A<N,char[N]> {};
+
+template<int N, int M> // Derived #2 (wrong!)
+class C: public A<N,char[M]> {};
+
+int main() {
+  if (C<1,2>::n() != 2)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/sizeof3.C b/gcc/testsuite/g++.old-deja/g++.pt/sizeof3.C
new file mode 100644
index 00000000000..cd5f701f20f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/sizeof3.C
@@ -0,0 +1,25 @@
+// Adapted from testcase by Oskar Enoksson <osken393@student.liu.se>
+
+extern "C" void abort();
+
+template<class T0>
+class A {
+public:
+  typedef T0 T;
+};
+
+template<int K>
+class B {
+  typedef A<char[K]> BC;
+};
+
+template<int N, int M>
+class C { 
+public:
+  typedef A<char[M]> AC;
+};
+
+int main() {
+  if (sizeof(C<3,7>::AC::T) != 7) 
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec1.C b/gcc/testsuite/g++.old-deja/g++.pt/spec1.C
new file mode 100644
index 00000000000..7467293e145
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec1.C
@@ -0,0 +1,21 @@
+// Build don't link:
+
+template <class S, class T>
+class mem_fun1_t {
+public:
+  mem_fun1_t(S (T::*pf)(double)) {} 
+};
+
+template <class T>
+class mem_fun1_t<void, T> { 
+public:
+  mem_fun1_t(void (T::*pf)(double)) {}
+};
+
+struct Operation {
+  double eval(double) {}
+};
+
+int main() {
+  mem_fun1_t<double, Operation> m(&Operation::eval);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec10.C b/gcc/testsuite/g++.old-deja/g++.pt/spec10.C
new file mode 100644
index 00000000000..5d53e2d76b1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec10.C
@@ -0,0 +1,27 @@
+extern "C" void abort();
+
+template <class T>
+struct S
+{
+  template <int i>
+  int f(int j) { abort(); return 0; }
+};
+
+template <>
+template <>
+int S<double>::f<7>(int j) { return j + 7; }
+
+template <>
+template <>
+int S<double>::f<8>(int j) { return j + 8; }
+
+int main()
+{
+  S<double> s;
+
+  if (s.template f<7>(3) != 10)
+    abort();
+
+  if (s.template f<8>(3) != 11)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec11.C b/gcc/testsuite/g++.old-deja/g++.pt/spec11.C
new file mode 100644
index 00000000000..340b58e73ec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec11.C
@@ -0,0 +1,20 @@
+extern "C" void abort();
+
+template <class T>
+struct S
+{
+  template <class U>
+  int f(U u);
+};
+
+template <>
+template <>
+int S<char>::f(int i) { return 1; }
+
+int main()
+{
+  S<char> sc;
+
+  if (sc.f(3) != 1)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec12.C b/gcc/testsuite/g++.old-deja/g++.pt/spec12.C
new file mode 100644
index 00000000000..d9c39654e93
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec12.C
@@ -0,0 +1,21 @@
+extern "C" void abort();
+
+template <class T>
+struct S
+{
+  template <class U>
+  int f(U u);
+};
+
+
+template <>
+template <>
+int S<char>::f<int>(int i) { return 1; }
+
+int main()
+{
+  S<char> sc;
+
+  if (sc.f(3) != 1)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec13.C b/gcc/testsuite/g++.old-deja/g++.pt/spec13.C
new file mode 100644
index 00000000000..e5748f56c14
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec13.C
@@ -0,0 +1,43 @@
+template <class T>
+void f(T t);
+
+template <class T>
+void f(T* t);
+
+template <>
+void f(int* ip) {}
+
+struct S1
+{
+  template <class T>
+  void f(T t);
+
+  template <class T>
+  void f(T* t);
+};
+
+template <>
+void S1::f(int* ip) {}
+
+template <class U>
+struct S2
+{
+  template <class T>
+  void f(T t);
+
+  template <class T>
+  void f(T* t);
+};
+
+template <>
+template <>
+void S2<double>::f(int* ip) {}
+
+int main()
+{
+  int* ip;
+  S1 s1;
+  s1.f(ip);
+  S2<double> s2;
+  s2.f(ip);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec14.C b/gcc/testsuite/g++.old-deja/g++.pt/spec14.C
new file mode 100644
index 00000000000..0380c61f619
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec14.C
@@ -0,0 +1,9 @@
+class X
+{
+public:
+  template <typename A, typename B, typename C>
+  X() {}
+  
+  template <typename A, typename B>
+  X::X<A, void, B>() {} // ERROR - non-template type used as a template
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec15.C b/gcc/testsuite/g++.old-deja/g++.pt/spec15.C
new file mode 100644
index 00000000000..2e97b046265
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec15.C
@@ -0,0 +1,49 @@
+extern "C" void abort();
+
+template <class T>
+struct S1
+{
+  static void f();
+};
+
+template <>
+void S1<int>::f() {}
+
+struct S2
+{
+  template <class T>
+  static void g(T);
+};
+
+template <>
+void S2::g(double) {}
+
+template <>
+void S2::g<int>(int) {}
+
+template <class T>
+struct S3
+{
+  template <class U>
+  static int h(U);
+};
+
+template <>
+template <>
+int S3<double>::h(int) { return 0; }
+
+template <>
+template <>
+int S3<char>::h(int) { return 1; }
+
+int main()
+{
+  S1<int>::f();
+  S2::g(3.0);
+  S2::g(7);
+
+  if (S3<double>::h(7) != 0) 
+    abort();
+  if (S3<char>::h(7) != 1)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec16.C b/gcc/testsuite/g++.old-deja/g++.pt/spec16.C
new file mode 100644
index 00000000000..9f6da97c771
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec16.C
@@ -0,0 +1,21 @@
+// Build don't link:
+
+template<class K>
+struct A {
+	int foo(const K&);
+	int bar(const K&);
+};
+
+template<class K>
+int
+A<K>::bar(const K& k)
+{
+	return(foo(k));
+}
+
+template<>
+int
+A<const char*>::foo(const char*const& k)
+{
+        return((int)k);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec17.C b/gcc/testsuite/g++.old-deja/g++.pt/spec17.C
new file mode 100644
index 00000000000..3e3dd63751a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec17.C
@@ -0,0 +1,44 @@
+// Build don't link:
+
+template<class T>
+struct Foo { };
+
+template<class T1, class T2>
+struct BT { };
+
+template<class T1, class T2>
+struct BT< Foo<T1>, Foo<T2> > { static const int i = 1; };
+
+template<class T1, class T2>
+struct BT< T1, Foo<T2> > { static const int i = 2; };
+
+template<class T1, class T2>
+struct BT< Foo<T1>, T2 > { static const int i = 3; };
+
+template<class T1, class T2>
+int foo(Foo<T1>, Foo<T2>)
+{
+  return 1;
+}
+
+template<class T1, class T2>
+int foo(T1, Foo<T2>)
+{
+  return 2;
+}
+
+template<class T1, class T2>
+int foo(Foo<T1>, T2)
+{
+  return 3;
+}
+
+void f()
+{
+  BT< double, Foo<int> >::i;
+  BT< Foo<int>, Foo<int> >::i;
+  BT< Foo<int>, float >::i;
+  foo(1.0, Foo<int>());
+  foo(Foo<int>(), Foo<int>());
+  foo(Foo<int>(), 1.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec18.C b/gcc/testsuite/g++.old-deja/g++.pt/spec18.C
new file mode 100644
index 00000000000..d7d034d6f7f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec18.C
@@ -0,0 +1,30 @@
+// Build don't link:
+
+template<class A, class B>
+void foo(const A& a, const B& b)
+{
+}
+
+template<class A, class B>
+void foo(const A& a, const int& b)
+{
+}
+
+template<class A*, class B>
+void foo(const A*& a, const B& b)
+{
+}
+
+template<>
+void foo(const int&, const double&)
+{
+}
+
+
+int
+main()
+{
+  foo("98239", 23);
+  foo(232, 1.022);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec19.C b/gcc/testsuite/g++.old-deja/g++.pt/spec19.C
new file mode 100644
index 00000000000..f9b601125b4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec19.C
@@ -0,0 +1,5 @@
+// Build don't link:
+
+template<class T> T f(T o) { return o; }
+template<> int f(int o)    { return o; } // ERROR - after specialization
+template int f(int);  // ERROR - explicit instantiation
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec2.C b/gcc/testsuite/g++.old-deja/g++.pt/spec2.C
new file mode 100644
index 00000000000..338c69ef31c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec2.C
@@ -0,0 +1,27 @@
+// Build don't link:
+
+class X
+{
+  public:
+    virtual void f() const = 0;
+};
+
+template <class T>
+class Y: public X
+{
+  public:
+    virtual void f() const;
+};
+
+template <class T>
+void Y<T>::f() const
+{
+}
+
+template <>
+void Y<bool>::f() const;
+
+template <>
+void Y<bool>::f() const
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec20.C b/gcc/testsuite/g++.old-deja/g++.pt/spec20.C
new file mode 100644
index 00000000000..c6b699d9411
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec20.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+// According to the non-normative example in
+// [temp.class.spec.mfunc]/2, these should be valid, but the grammar
+// in the Standard does not allow partial nor full specializations as
+// member-declarations, so we'd better not support them.
+
+template <class T> 
+struct S {
+  template <class U> void f(U);
+  template <> void f<int>(int); // ERROR - invalid specialization
+
+  template <class V> struct I {};
+  template <class V> struct I<V*> {};
+  template <> struct I<int>; // ERROR - invalid specialization
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec21.C b/gcc/testsuite/g++.old-deja/g++.pt/spec21.C
new file mode 100644
index 00000000000..95e12d2f923
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec21.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template <class T> struct S {};
+template <class T = int> struct S<T*> {}; // ERROR - default argument
+
+template <int I, int J> struct A {};
+template <int I> struct A<I+5, I*2> {}; // ERROR - argument involves parameter
+
+template <class T, T t> struct C {};
+template <class T> struct C<T, 1>;  // ERROR - type depends on parameter
+int i;
+template <class T> struct C<T*, &i>; // ERROR - type depends on parameter
+
+template< int X, int (*array_ptr)[X] > class B {};
+int array[5];
+template< int X > class B<X,&array> { }; // ERROR - type depends on parameter
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec22.C b/gcc/testsuite/g++.old-deja/g++.pt/spec22.C
new file mode 100644
index 00000000000..e170b6e3476
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec22.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+template <class T>
+struct S
+{
+  template <class U>
+  void f();
+};
+
+
+template <class T> 
+template <> // ERROR - enclosing classes not specialized
+void S<T>::f<int> () 
+{ // ERROR - template does not match any declaration
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec23.C b/gcc/testsuite/g++.old-deja/g++.pt/spec23.C
new file mode 100644
index 00000000000..0e9ee61d253
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec23.C
@@ -0,0 +1,10 @@
+/* [temp.expl.spec] p18.  */
+
+template<class T>
+struct A {
+  template <class U> class B { };
+};
+
+template<class T>
+class A<T>::B<void> {		// ERROR - only one template header
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec24.C b/gcc/testsuite/g++.old-deja/g++.pt/spec24.C
new file mode 100644
index 00000000000..2b7d336698f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec24.C
@@ -0,0 +1,5 @@
+// Build don't link:
+
+template <class T> class A;
+// template <>
+class A<int>; // ERROR - missing template header - XFAIL *-*-*
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec25.C b/gcc/testsuite/g++.old-deja/g++.pt/spec25.C
new file mode 100644
index 00000000000..884abf07dee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec25.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+template <class T, int I>
+struct S {
+};
+
+template <int I>
+struct S <double, I> {
+};
+
+template <class T>
+void f ()
+{
+  S<double, T::x> s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec26.C b/gcc/testsuite/g++.old-deja/g++.pt/spec26.C
new file mode 100644
index 00000000000..1bd40b6083c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec26.C
@@ -0,0 +1,11 @@
+// From: lat@iki.fi (Lassi A. Tuura)
+// Test that a specialization without an initializer is not a definition,
+// as specified in [temp.expl.spec].
+
+// Build don't link:
+
+struct X;
+template <class T> struct Y { static const X array[]; };
+template <> const X Y<int>::array [];
+struct X { int i; };
+template <> const X Y<int>::array [] = { 0, 1, 2, 3 };
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec27.C b/gcc/testsuite/g++.old-deja/g++.pt/spec27.C
new file mode 100644
index 00000000000..63aae4c9bf6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec27.C
@@ -0,0 +1,18 @@
+// Build don't link:
+
+template <class T, class U>
+struct Y {};
+
+template <class T>
+struct X {};
+
+template <class T, class U>
+void f()
+{
+  typename X<Y<T, U> >::A a;
+}
+
+template <class T, class U>
+struct X<Y<T, U> >
+{
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec28.C b/gcc/testsuite/g++.old-deja/g++.pt/spec28.C
new file mode 100644
index 00000000000..d63e7967672
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec28.C
@@ -0,0 +1,25 @@
+// Build don't link:
+
+template <class T> 
+struct S1 {
+  friend bool f<>(const S1&);
+  typedef T X;
+};
+
+template <class T>
+struct S2 {
+};
+
+template <class T>
+struct S2<S1<T> > {
+  typedef typename S1<T>::X Y;
+};
+
+template <class T>
+bool f(T);
+
+template <class T>
+typename S2<S1<T> >::Y
+f(const S1<T>&);
+
+template struct S1<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec29.C b/gcc/testsuite/g++.old-deja/g++.pt/spec29.C
new file mode 100644
index 00000000000..9f27a8e53a3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec29.C
@@ -0,0 +1,31 @@
+char c;
+
+struct S {
+  template <typename T>
+  operator T*();
+
+  template <typename T>
+  operator T();
+};
+
+template <>
+S::operator int()
+{
+  return 2;
+}
+
+template <>
+S::operator char*()
+{
+  return &c;
+}
+
+int main()
+{
+  S s;
+  int i = s;
+  char* cp = s;
+
+  if (i != 2 || cp != &c)
+    return 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec3.C b/gcc/testsuite/g++.old-deja/g++.pt/spec3.C
new file mode 100644
index 00000000000..b0e710f3b01
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec3.C
@@ -0,0 +1,37 @@
+extern "C" void abort();
+
+class X
+{
+  public:
+    virtual int f() const = 0;
+};
+
+template <class T>
+class Y: public X
+{
+  public:
+    virtual int f() const;
+};
+
+template <class T>
+int Y<T>::f() const
+{
+  abort();
+  return 0;
+}
+
+template <>
+int Y<bool>::f() const;
+
+template <>
+int Y<bool>::f() const
+{
+  return 0;
+}
+
+int main()
+{
+  Y<bool> yb;
+
+  yb.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec30.C b/gcc/testsuite/g++.old-deja/g++.pt/spec30.C
new file mode 100644
index 00000000000..5d36e254a40
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec30.C
@@ -0,0 +1,41 @@
+#include <cstddef>
+
+template <class T>	
+struct S {
+  void *operator new (size_t);
+  void *operator new (size_t, int);
+  void operator delete (void*);
+};
+
+static void* s[2];
+
+template <>
+void* S<int>::operator new (size_t b) 
+{ 
+  s[0] = ::operator new(b);
+  return s[0];
+}
+
+template <>
+void* S<int>::operator new (size_t b, int)
+{
+  s[1] = ::operator new(b);
+  return s[1];
+}
+
+template <>
+void S<int>::operator delete (void*) 
+{
+}
+
+int main()
+{
+  S<int>* s1 = new S<int>;
+  S<int>* s2 = new(3) S<int>;
+
+  if (s1 != s[0] || s2 != s[1])
+    return 1;
+
+  delete s1;
+  delete s2;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec31.C b/gcc/testsuite/g++.old-deja/g++.pt/spec31.C
new file mode 100644
index 00000000000..a66e03f62eb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec31.C
@@ -0,0 +1,2 @@
+template <> struct A {};	// ERROR - not a specialization
+template <> void f ();		// ERROR - not a specialization
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec4.C b/gcc/testsuite/g++.old-deja/g++.pt/spec4.C
new file mode 100644
index 00000000000..b6e6858e0a0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec4.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+template <class T>
+struct S {};
+
+template <>
+struct S<int>
+{
+  void f();
+  void g();
+};
+
+void S<int>::f() {}
+
+template <>
+void S<int>::g() {} // ERROR - does not match any template declaration
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec5.C b/gcc/testsuite/g++.old-deja/g++.pt/spec5.C
new file mode 100644
index 00000000000..553d95659f0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec5.C
@@ -0,0 +1,20 @@
+// Build don't link:
+
+template <class T>
+void f(T t1, T t2);
+
+template <>
+void f(int i, int j);
+
+template <class T>
+void g(T t1, T t2) {}
+
+template void g(int i, int j);
+
+void h()
+{
+  f(3, 'c'); // ERROR - no matching function
+  g(3, 'c'); // ERROR - no matching function
+}
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec6.C b/gcc/testsuite/g++.old-deja/g++.pt/spec6.C
new file mode 100644
index 00000000000..4ef8e651594
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec6.C
@@ -0,0 +1,31 @@
+// Build don't link:
+
+struct S1
+{
+  template <class T>
+  void f(T t1, T t2);
+};
+
+
+template <>
+void S1::f(int i1, int i2);
+
+template <class U>
+struct S2
+{
+  template <class T>
+  void f(T t1, T t2);
+};
+
+template <>
+template <>
+void S2<char>::f(int i1, int i2);
+
+void h()
+{
+  S1 s1;
+  s1.f(3, 'c'); // ERROR - no matching function
+
+  S2<char> s2;
+  s2.f(3, 'c'); // ERROR - no matching function
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec7.C b/gcc/testsuite/g++.old-deja/g++.pt/spec7.C
new file mode 100644
index 00000000000..81358d9ccca
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec7.C
@@ -0,0 +1,19 @@
+extern "C" void abort();
+
+template <class T>
+void f(T t1, T t2);
+
+template <>
+void f(int i, int j) 
+{
+  abort();
+}
+
+void f(short s, char c)
+{
+}
+
+int main()
+{
+  f(3, 'c');
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec8.C b/gcc/testsuite/g++.old-deja/g++.pt/spec8.C
new file mode 100644
index 00000000000..966f69f2ee4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec8.C
@@ -0,0 +1,27 @@
+extern "C" void abort();
+
+template <void* P>
+void f(int j);
+
+template <int I>
+void f(int j);
+
+
+template <void* P>
+void f(int j)
+{
+  abort();
+}
+
+
+template <int I>
+void f(int j)
+{
+}
+
+
+int main()
+{
+  f<3>(7);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/spec9.C b/gcc/testsuite/g++.old-deja/g++.pt/spec9.C
new file mode 100644
index 00000000000..e2a220819a1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/spec9.C
@@ -0,0 +1,21 @@
+extern "C" void abort();
+
+template <class T>
+inline int f(T t) 
+{
+  return 0;
+}
+
+int main()
+{
+  if (!f(3))
+    abort();
+}
+
+template <>
+int f(int i) 
+{             // ERROR - specialization of f<int>(int) after instantiation
+  return 1;
+}
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/static1.C b/gcc/testsuite/g++.old-deja/g++.pt/static1.C
new file mode 100644
index 00000000000..67e23631600
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/static1.C
@@ -0,0 +1,21 @@
+extern "C" void abort();
+
+template <class T> 
+class A
+{
+ public:
+  static int foo(int);
+};
+
+template <>
+int A<int>::foo(int i)
+{
+  return i;
+}
+
+
+int main()
+{
+  if (A<int>::foo(22) != 22)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/static2.C b/gcc/testsuite/g++.old-deja/g++.pt/static2.C
new file mode 100644
index 00000000000..5060cfdfb9e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/static2.C
@@ -0,0 +1,21 @@
+// Build don't link:
+
+template <class A>
+class TEST
+{
+public:
+  TEST (A) {}
+};
+
+template <class A>
+class TEST2
+{
+  static A i;
+};
+
+template <class A>
+A TEST2 <A>::i (0);
+
+TEST2 <TEST <int> > a;
+
+template class TEST2 <TEST <int> >;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/static3.C b/gcc/testsuite/g++.old-deja/g++.pt/static3.C
new file mode 100644
index 00000000000..6fe33f9ead9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/static3.C
@@ -0,0 +1,16 @@
+// On targets that don't support weak symbols, we require an explicit
+// instantiation of arr.
+// excess errors test - XFAIL *-*-aout *-*-coff *-*-hpux*
+
+template<class T>
+struct A {
+  static T arr[5];
+};
+
+template <class T>
+T A<T>::arr[5] = { 0, 1, 2, 3, 4 };
+
+int main ()
+{
+  return A<int>::arr[0];
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/static4.C b/gcc/testsuite/g++.old-deja/g++.pt/static4.C
new file mode 100644
index 00000000000..2ff32215437
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/static4.C
@@ -0,0 +1,8 @@
+// Build don't link:
+
+template <class T>
+struct S
+{
+  static const T t = 3;
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/static5.C b/gcc/testsuite/g++.old-deja/g++.pt/static5.C
new file mode 100644
index 00000000000..f6e125dbfb7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/static5.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+template <class T>
+struct S
+{
+  static const T t = 3; // ERROR - initializing non-integral type
+};
+
+double d = S<double>::t;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/static6.C b/gcc/testsuite/g++.old-deja/g++.pt/static6.C
new file mode 100644
index 00000000000..c52c3cb2af5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/static6.C
@@ -0,0 +1,14 @@
+// Build don't run:
+
+// Simplified from testcase by Erez Louidor Lior <s3824888@techst02.technion.ac.il>
+
+template <class T> struct A {
+ static const int l[1];
+};
+
+template<class T>
+const int A<T>::l[1] = {1};
+
+int i = A<int>::l[0];
+
+int main(){}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/static7.C b/gcc/testsuite/g++.old-deja/g++.pt/static7.C
new file mode 100644
index 00000000000..282f78fe8f8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/static7.C
@@ -0,0 +1,14 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class T>
+struct S {
+  S() {}
+
+  static S s;
+};
+
+template <class T>
+S<T> S<T>::s;
+
+S<int> si;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/static8.C b/gcc/testsuite/g++.old-deja/g++.pt/static8.C
new file mode 100644
index 00000000000..172c3c3fe7d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/static8.C
@@ -0,0 +1,32 @@
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+int i;
+
+template <class T>
+struct S {
+  S() { ++i; }
+
+  virtual void g() {}
+  virtual void f();
+
+  static S s;
+};
+
+template <class T>
+void S<T>::f() {
+  s.f();
+}
+
+S<int> si;
+
+template <class T>
+S<T> S<T>::s;
+
+int main ()
+{
+  si.g();
+  if (i != 2)
+    return 1;
+  else
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/static_cast.C b/gcc/testsuite/g++.old-deja/g++.pt/static_cast.C
new file mode 100644
index 00000000000..26f26c56fc9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/static_cast.C
@@ -0,0 +1,22 @@
+// Build don't link:
+
+template <class InputIterator, class BinaryOperation>
+void accumulate(InputIterator first, 
+    	         BinaryOperation binary_op) {
+}
+
+
+template<class R> int p( int val, R& r )
+{
+   return val + r;
+}
+
+template<class R> void f(R)
+{
+   accumulate(0, static_cast<int (*)(int, R&)>(p) );
+}
+
+int main()
+{
+   f(0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/stmtexpr.C b/gcc/testsuite/g++.old-deja/g++.pt/stmtexpr.C
new file mode 100644
index 00000000000..57ef7e3ab38
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/stmtexpr.C
@@ -0,0 +1,16 @@
+extern "C" void abort();
+
+template <class T>
+T f(T)
+{
+  T t = __extension__ ({ T j = 4; j + 3; });
+  return t;
+}
+
+
+int main()
+{
+  if (f(3) != 7)
+    abort();
+}
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/stmtexpr2.C b/gcc/testsuite/g++.old-deja/g++.pt/stmtexpr2.C
new file mode 100644
index 00000000000..475ad72dda1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/stmtexpr2.C
@@ -0,0 +1,24 @@
+extern "C" void abort();
+
+int i;
+
+void g()
+{
+  i++;
+}
+
+template <class T>
+void f(T)
+{
+  __extension__ ({g();});
+}
+
+int main()
+{
+  f(3.0);
+  if (i != 1)
+    abort();
+
+  return 0;
+}
+ 
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t00.C b/gcc/testsuite/g++.old-deja/g++.pt/t00.C
new file mode 100644
index 00000000000..14bfcf82ca6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t00.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+
+int f1 () {
+    struct A { A() { a = 2; } int a; } ;
+  A aa;
+  return aa.a;
+}
+int f2 () {
+    struct A { A() { a = 2; } int a; } ;
+  A ab;
+  return ab.a;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t01.C b/gcc/testsuite/g++.old-deja/g++.pt/t01.C
new file mode 100644
index 00000000000..b1d7d386cd9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t01.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+
+template <class A> class B { public: A a; };
+static B<int> b_int;
+
+int foo () { return b_int.a; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t03.C b/gcc/testsuite/g++.old-deja/g++.pt/t03.C
new file mode 100644
index 00000000000..29f687ae1bc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t03.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+
+template <class A> class B { public: A a; };
+static B<int> b_int;
+static B<char> b_char;
+
+int foo () { return b_int.a + b_char.a; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t04.C b/gcc/testsuite/g++.old-deja/g++.pt/t04.C
new file mode 100644
index 00000000000..faa04fc5771
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t04.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+
+template <class A> class B { public: A a; };
+static B<int> b_int;
+static B<char> b_char;
+static B<unsigned char> b_uchar;
+
+int foo () { return b_int.a + b_char.a + b_uchar.a; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t05.C b/gcc/testsuite/g++.old-deja/g++.pt/t05.C
new file mode 100644
index 00000000000..5c99f772ad9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t05.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+
+template <class A> class B {   
+  A a;                          
+ public:
+  B(A&aa);			// ERROR - near match
+  ~B();
+};  // ERROR - candidates
+static B<int> b_int (3);	// ERROR - no matching function
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t06.C b/gcc/testsuite/g++.old-deja/g++.pt/t06.C
new file mode 100644
index 00000000000..8681f5332fa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t06.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+
+typedef int I;
+int i;
+
+template <class A> class B {
+  A a;
+ public:
+  B(A&aa);
+  B();
+  ~B();
+};
+
+template <class B> class C { public: B b; };
+
+template <class I, class i> class D : I { public: i ii; };
+
+typedef B<int> b_int;
+typedef C<int> c_int;      
+typedef C<b_int> c_b_int2; 
+
+c_b_int2 x2;
+int z;
+D<c_b_int2,b_int> d;
+int q;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t07.C b/gcc/testsuite/g++.old-deja/g++.pt/t07.C
new file mode 100644
index 00000000000..3cdb3dafdb2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t07.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+
+template <class A> class B {
+  A a;
+ public:
+  const A& value () { return a; }
+};
+static B<int> b_int;
+
+int foo () { return b_int.value(); }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t08.C b/gcc/testsuite/g++.old-deja/g++.pt/t08.C
new file mode 100644
index 00000000000..ce24cca7e36
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t08.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+
+template <class A> class B {
+  A a;
+ public:
+  B ();
+  ~B ();
+};
+B<int> b_int;
+B<int> *bp = &b_int;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t09.C b/gcc/testsuite/g++.old-deja/g++.pt/t09.C
new file mode 100644
index 00000000000..dab4730e091
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t09.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+
+struct bs_1 {
+  typedef int (*pfi) (void);
+};
+static bs_1::pfi fp;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t10.C b/gcc/testsuite/g++.old-deja/g++.pt/t10.C
new file mode 100644
index 00000000000..4f3fc182e04
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t10.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+
+template <class A> class B { public: A a; B(); };
+class B<char> { public: int y[10]; };
+static B<int> bi;
+static B<char> bc;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t11.C b/gcc/testsuite/g++.old-deja/g++.pt/t11.C
new file mode 100644
index 00000000000..81373498df8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t11.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+
+template <class A>
+class B {
+public:
+  A a;
+  B() { x = 2; }	// ERROR - no x
+};
+static B<int> bi;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t11a.C b/gcc/testsuite/g++.old-deja/g++.pt/t11a.C
new file mode 100644
index 00000000000..0dcd297fa15
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t11a.C
@@ -0,0 +1,9 @@
+// Build don't link: 
+
+template <class A>
+class B {
+public:
+  A a;
+  B() { a = 2; }
+};
+static B<int> bi;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t12.C b/gcc/testsuite/g++.old-deja/g++.pt/t12.C
new file mode 100644
index 00000000000..0ebb0451f79
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t12.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+
+class OBJECT {int a;};
+class STDFILE {int b;};
+
+template <class T> class VECTOR {
+    T *v;
+    int sz;
+public:
+    T& elem(int i) { return v[i]; }
+    T& operator[] (int i);
+};
+
+template <class T>
+class PVECTOR : VECTOR<void *> {
+public:
+    T*& elem(int i)
+        {return (T*&) VECTOR<void *>::elem(i); }
+    T*& operator[] (int i)
+        {return (T*&) VECTOR<void *>::operator[](i);}
+};
+
+PVECTOR<OBJECT *> *foo;
+
+PVECTOR<STDFILE *> *goo;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t12a.C b/gcc/testsuite/g++.old-deja/g++.pt/t12a.C
new file mode 100644
index 00000000000..e0f1e65d50b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t12a.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+
+int a (void * x) { return 1; }
+typedef void *T;
+int b (T x) { return 2; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t13.C b/gcc/testsuite/g++.old-deja/g++.pt/t13.C
new file mode 100644
index 00000000000..2f589a7d227
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t13.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+
+template <class A> class B {
+public:
+  B();
+  A a;
+  int i;
+};
+
+void *f () {
+  return new B<char *>;
+}
+
+struct foo { int i[10]; };
+extern B<foo> *foop;
+
+void f2 () {
+  foop = new B<foo>;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t14.C b/gcc/testsuite/g++.old-deja/g++.pt/t14.C
new file mode 100644
index 00000000000..8532f2b3501
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t14.C
@@ -0,0 +1,24 @@
+// Build don't link: 
+
+class OBJECT
+{
+    int	a;
+};
+
+ 
+
+template <class T> class TESTA
+{
+public:
+    TESTA();
+      T	foo(int i) {T t = 0; return t};	// ERROR - no semi
+};
+
+
+
+void foo()
+{
+    TESTA<OBJECT *>   *foo;
+
+    foo = new TESTA<OBJECT *>;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t14a.C b/gcc/testsuite/g++.old-deja/g++.pt/t14a.C
new file mode 100644
index 00000000000..694f846fbe5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t14a.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+
+class OBJECT
+{
+    int	a;
+};
+
+ 
+
+template <class T> class TESTA
+{
+public:
+    TESTA();
+      T	foo(int i) {T t = 0; return t;}
+};
+
+
+
+void foo()
+{
+    TESTA<OBJECT *>   *foo;
+
+    foo = new TESTA<OBJECT *>;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t16.C b/gcc/testsuite/g++.old-deja/g++.pt/t16.C
new file mode 100644
index 00000000000..4cdf3a26803
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t16.C
@@ -0,0 +1,30 @@
+extern "C" void printf (char *, ...);
+template <class T> T max (const T&x, const T&y)
+{
+  return (x>y)?x:y;
+}
+int min (const float&, const float&);
+int min (const int& i1, const int& i2) {
+  return (i1 < i2) ? i1 : i2;
+}
+
+class complex
+{
+  double re, im;
+ public:
+  complex (double r, double i=0) { re = r; im = i; }
+  friend int operator > (const complex& x, const complex &y) { return 0; }
+  void print () { }
+};
+
+int main ()
+{
+  complex c1 (1, 0);
+  complex c2 (2, 0);
+
+  int j = max (1, 37);
+  complex m1 = max (c1, c2);
+  m1.print ();
+  printf ("j=%d\n", j);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t18.C b/gcc/testsuite/g++.old-deja/g++.pt/t18.C
new file mode 100644
index 00000000000..760747eeceb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t18.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+
+extern void byebye ();
+template <class T1, class T2>
+struct A
+{
+  T1 t1;
+  T2 t2;
+  A() { t1 = 0; t2 = 0; }
+  ~A() { byebye(); }
+};
+
+template <class Q>
+int f (A<int, Q> a) {
+  return a.t1;
+}
+
+extern A<int,double*> aa;
+int foop () { return f(aa); }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t20.C b/gcc/testsuite/g++.old-deja/g++.pt/t20.C
new file mode 100644
index 00000000000..07a86fa2d6e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t20.C
@@ -0,0 +1,15 @@
+// Build don't link: 
+
+template <class X> class A {
+public:
+  X aaa;
+  int foo();
+};
+
+template <class X> A<X> f(X);
+
+void frep() {
+  int x;
+  x = f(6.4).foo();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t21.C b/gcc/testsuite/g++.old-deja/g++.pt/t21.C
new file mode 100644
index 00000000000..f05f89ff4c2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t21.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+
+template <class X> class A { public: int a; X x; };
+template <class X> X f (A<X> a) { return a.x; }
+
+extern A<double> a_dbl;
+
+double fred () { return f (a_dbl); }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t22.C b/gcc/testsuite/g++.old-deja/g++.pt/t22.C
new file mode 100644
index 00000000000..1102baabef3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t22.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+
+class AA { public: static int xx; };
+template <class X> class A {
+ public:
+  static int x;
+};
+
+int AA::xx;
+template <class Y> int A<Y>::x;	// gets bogus error
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t23.C b/gcc/testsuite/g++.old-deja/g++.pt/t23.C
new file mode 100644
index 00000000000..82221b32715
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t23.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+
+template <class T> class temp1
+{
+public:
+        T tvar;
+};
+
+
+template <class T2> class temp2
+{
+public :
+        temp1<T2> t1var;
+};
+
+
+temp1<int> temp1var;
+temp2<int> temp2var;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t24.C b/gcc/testsuite/g++.old-deja/g++.pt/t24.C
new file mode 100644
index 00000000000..60322706389
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t24.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+// Special g++ Options: 
+
+template <class X> int f (X x, X y) { return 23; }
+
+int foo () {
+  return f (7);	// ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t25.C b/gcc/testsuite/g++.old-deja/g++.pt/t25.C
new file mode 100644
index 00000000000..23197746825
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t25.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+
+template <class X> int f (X x, X y) { return 23; }
+template <class X> int f (X x, int j = 3) { return 29; }
+
+int foo () {
+  return f (7);		// gets bogus error - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t26.C b/gcc/testsuite/g++.old-deja/g++.pt/t26.C
new file mode 100644
index 00000000000..cfc1591df2d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t26.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+
+template <class X> int f (X x, unsigned int j = 3) { return 29; }
+template <class X> int f (X x, X y) { return 23; }
+
+int foo () {
+  return f (7.0, 9.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t27.C b/gcc/testsuite/g++.old-deja/g++.pt/t27.C
new file mode 100644
index 00000000000..f3246e81204
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t27.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+
+template <class X> int f (X x, int * j) { return 29; }
+template <class X> int f (X x, ...) { return 23; }
+
+int foo () {
+  return f (7.0, 9.0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t28.C b/gcc/testsuite/g++.old-deja/g++.pt/t28.C
new file mode 100644
index 00000000000..dd524cb781a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t28.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+
+template <class X> class B;
+template <class X> int f (B<X> b) { return 37; }
+template <class Y> class B { public: Y y; B() { y = 1; } };
+
+int foo () {
+  B<double> bd;
+  return f(bd);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t29.C b/gcc/testsuite/g++.old-deja/g++.pt/t29.C
new file mode 100644
index 00000000000..54a5052ff02
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t29.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+
+template <class X, int n> X f (auto X (*x)[n]) { return (*x)[n/2]; }
+extern int i[30];
+extern double d[99];
+
+int foo (int ii) { return f (&i); }		// causes abort
+double foo (double dd) { return f (&d); }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t30.C b/gcc/testsuite/g++.old-deja/g++.pt/t30.C
new file mode 100644
index 00000000000..42d88eaee29
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t30.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+
+template <class X, int n> X f (auto X (*x)[n]) { return (*x)[n/2]; }
+extern int i[30], i2[33];
+extern double d[99];
+
+int foo (int ii) { return f (&i) + f(&i2); }	// causes abort
+double foo (double dd) { return f (&d); }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t31.C b/gcc/testsuite/g++.old-deja/g++.pt/t31.C
new file mode 100644
index 00000000000..8800ebe7ca8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t31.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+
+struct B { int foo (); };
+int B::foo() { return 37; }
+
+template <class A> struct X {
+  void f();
+};
+
+template <class A> void X<A>::f ()
+{}
+
+X<int> x;
+
+void xyzzy () {
+  x.f ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t32.C b/gcc/testsuite/g++.old-deja/g++.pt/t32.C
new file mode 100644
index 00000000000..89f8db19108
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t32.C
@@ -0,0 +1,14 @@
+// Build don't link: 
+
+template <class X> struct A {
+  int fooo (int x);
+  int x;
+  inline int y () { return 3; }
+  inline int z () { return 5; }
+};
+
+template <class Y> int A<Y>::fooo (int t) { return (this->*(x?&A<Y>::y : &A<Y>::z))() + t; };	// gets bogus error
+
+A<int> ai;
+
+int frop () { return ai.fooo (100); }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t32a.C b/gcc/testsuite/g++.old-deja/g++.pt/t32a.C
new file mode 100644
index 00000000000..13dfda122b6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t32a.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+
+struct A {
+  int x;
+  int y ();
+  int z ();
+  int foo (int j);
+};
+
+int A::foo (int q) { return q + (this->*(x ? &A::y : &A::z)) (); }	// gets bogus error
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t34.C b/gcc/testsuite/g++.old-deja/g++.pt/t34.C
new file mode 100644
index 00000000000..acf858adf93
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t34.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+
+template <class X> struct A { int operator [] (int); };
+template <class Y> int A<Y>::operator[] (int j) { return j * j; }
+
+extern A<void **> avpp;
+
+int q () { return avpp[99]; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t34a.C b/gcc/testsuite/g++.old-deja/g++.pt/t34a.C
new file mode 100644
index 00000000000..7d5aebf598a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t34a.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+
+struct A {
+  int operator[] (int);
+};
+
+//int A::operator[] (int);
+
+int A::operator[] (int j)
+{
+  return j * j;
+}
+
+extern A a;
+
+int q () { return a[99]; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t35.C b/gcc/testsuite/g++.old-deja/g++.pt/t35.C
new file mode 100644
index 00000000000..f0ed971ae47
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t35.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// Special g++ Options:
+template<class X> struct A {
+  A ();
+  ~A();
+  int x, y, z;
+};
+
+template <class Y> inline A<Y>::A () { x = y = 3; z = 99; }
+template <class Z> inline A<Z>::~A() { y = 9999; }
+
+A<int> ai;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t35a.C b/gcc/testsuite/g++.old-deja/g++.pt/t35a.C
new file mode 100644
index 00000000000..40fba4d0997
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t35a.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+
+template <class X> struct A {  };
+struct A<int> { int foo (); };
+int A<int>::foo () { return 37; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t36.C b/gcc/testsuite/g++.old-deja/g++.pt/t36.C
new file mode 100644
index 00000000000..bb791b9df75
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t36.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+
+void * foo () {
+  typedef int * ip;
+  return new ip;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t37.C b/gcc/testsuite/g++.old-deja/g++.pt/t37.C
new file mode 100644
index 00000000000..434dadd8228
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t37.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+
+class A {
+public:
+  A(int);			// ERROR - referenced below
+  A(float);			// ERROR - referenced below
+  ~A();
+}; // ERROR - synthesized copy ctor
+
+A::A() {		// ERROR - 
+}
+  
+A::A(int) {
+}
+  
+A::~A() {
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t37a.C b/gcc/testsuite/g++.old-deja/g++.pt/t37a.C
new file mode 100644
index 00000000000..797b78df5ac
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t37a.C
@@ -0,0 +1,18 @@
+// Build don't link: 
+
+class A {
+public:
+  A(int);
+  A(float);
+  ~A();
+};
+
+A::A(float f) {
+}
+  
+A::A(int i) {
+}
+  
+A::~A() {
+}
+  
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t38.C b/gcc/testsuite/g++.old-deja/g++.pt/t38.C
new file mode 100644
index 00000000000..cd892822b14
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t38.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+// Special g++ Options:
+extern "C" int printf (const char *, ...);
+
+template<class X> struct A {
+  A (int, char);
+  ~A ();
+  A (X *, float);
+};
+
+template<class Y> inline A<Y>::A (int i, char c) {
+  printf ("%d, %d\n", i, c);
+}
+template<class Z> A<Z>::~A() {}
+template<class W> A<W>::A (W * d, float f) {
+  printf ("%x, %e\n", d, f);
+}
+
+A<void> avoid (9, 0);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t39.C b/gcc/testsuite/g++.old-deja/g++.pt/t39.C
new file mode 100644
index 00000000000..d12ef814063
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t39.C
@@ -0,0 +1,25 @@
+extern "C" int printf (const char *, ...);
+
+template <class T>
+struct frob {
+  T *ptr;
+  void print ();
+  frob (T* init) { ptr = init; }
+};
+
+template <class T>
+void frob<T>::print () {
+  printf ("this = %08x\n", this);
+  printf (" ptr = %08x\n", ptr);
+  printf (" values = %x %x %x ...\n", ptr[0], ptr[1], ptr[2]);
+}
+
+  static int x[10];
+  frob<char> fc ("hello");
+  frob<int> fi (x);
+
+int main () {
+  fc.print ();
+  fi.print ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t40.C b/gcc/testsuite/g++.old-deja/g++.pt/t40.C
new file mode 100644
index 00000000000..34768a995ff
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t40.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+
+struct A {
+  struct B {
+    B (int);
+  };
+  static int foop (B);
+  static int splat () {
+    return foop (B (1));
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t41.C b/gcc/testsuite/g++.old-deja/g++.pt/t41.C
new file mode 100644
index 00000000000..c02f6779a39
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t41.C
@@ -0,0 +1,11 @@
+// Build don't link: 
+
+struct A {
+  struct B {
+    B (int);
+  };
+  static int foop (B);
+  int splat () {
+    return foop (B (1));
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/t42.C b/gcc/testsuite/g++.old-deja/g++.pt/t42.C
new file mode 100644
index 00000000000..55459949b77
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/t42.C
@@ -0,0 +1,17 @@
+extern "C" void abort ();
+
+struct A {
+  struct stat {
+    int x;
+    stat (int j) { abort (); }
+  };
+  static int stat (double d) { return 0; }	// gets bogus error - cfront takes it
+  static int zap () {
+    stat (0);
+    return stat (1);	// gets bogus error - this should work
+  }
+};
+
+int main () {
+  return A::zap ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/test4.C b/gcc/testsuite/g++.old-deja/g++.pt/test4.C
new file mode 100644
index 00000000000..f4c2a205fdf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/test4.C
@@ -0,0 +1,4 @@
+// Build don't link: 
+
+class B { };
+template <class x, int b> class X : public B { int y[b]; };
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/test5.C b/gcc/testsuite/g++.old-deja/g++.pt/test5.C
new file mode 100644
index 00000000000..dc74c2d88f7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/test5.C
@@ -0,0 +1,3 @@
+// Build don't link: 
+
+template <char *a, const char *b, char *const c> class A{int x;};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/tiemann1r.C b/gcc/testsuite/g++.old-deja/g++.pt/tiemann1r.C
new file mode 100644
index 00000000000..65e6807da98
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/tiemann1r.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+
+struct bs_1
+{
+  typedef int (*p_user_hashf)(int);
+};
+
+bs_1::p_user_hashf i_user_hashf;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/tiemann2.C b/gcc/testsuite/g++.old-deja/g++.pt/tiemann2.C
new file mode 100644
index 00000000000..4c71541cee2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/tiemann2.C
@@ -0,0 +1,34 @@
+extern "C" void printf (char *, ...);
+template <class T> T max (const T&x, const T&y)
+{
+  return (x>y)?x:y;
+}
+
+class complex
+{
+  double re, im;
+ public:
+  complex (double r, double i=0) { re = r; im = i; }
+  friend int operator > (const complex& x, const complex &y);
+  void print () { printf ("re = %g; im = %g;\n", re, im); }
+};
+int operator >(const complex& x, const complex &y)
+{
+  double c1 = x.re * x.re + x.im * x.im;
+  double c2 = y.re * y.re + y.im * y.im;
+  return c1 > c2;
+}
+
+int main ()
+{
+  complex c1 (1, 0);
+  complex c2 (2, 0);
+  complex c3 (2, 3);
+  complex c4 (2, 1);
+
+  complex m1 = max (c1, c2);
+  complex m2 = max (c3, c4);
+  m1.print ();
+  m2.print ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/to2.C b/gcc/testsuite/g++.old-deja/g++.pt/to2.C
new file mode 100644
index 00000000000..936729c6b18
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/to2.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+
+template <class A> class B { public: A a; };
+static B<int> b_int;
+static B<int> b_int2;
+
+int foo () { return b_int.a + b_int2.a; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/tt.C b/gcc/testsuite/g++.old-deja/g++.pt/tt.C
new file mode 100644
index 00000000000..e597875a05a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/tt.C
@@ -0,0 +1,33 @@
+// Build don't link: 
+
+#define DEF_A   struct A { A() { a = 2; } int a; }
+
+#if 1
+int f1 () {
+  DEF_A;
+  A aa;
+  return aa.a;
+}
+
+int f2 () {
+  DEF_A;
+  A ab;
+  return ab.a;
+}
+/* results:
+tt.cc: In function int f2 ():
+tt.cc:9: conflicting types for `A::A ()'
+tt.cc:3: previous declaration of `A::A ()'
+/u2/projects/gcc2/src/cplus-cvt.c:1149: failed assertion `distance >= 0'
+gcc2: Program cc1plus got fatal signal 6.
+*/
+#else
+
+struct B1 { DEF_A; A aa; };
+
+struct B2 { DEF_A; A aa; };
+/* results:
+/u2/projects/gcc2/src/cplus-decl.c:5469: failed assertion `return_type == return_ctor'
+gcc2: Program cc1plus got fatal signal 6.
+*/
+#endif
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/tt2.C b/gcc/testsuite/g++.old-deja/g++.pt/tt2.C
new file mode 100644
index 00000000000..f6c435b1cdc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/tt2.C
@@ -0,0 +1,27 @@
+// Build don't link: 
+
+int f1 () {
+  struct A {
+    A() : b (2) { }
+    int fred () { return b.hi_mom; }
+    struct B {
+      int hi_mom;
+      B (int a) { hi_mom = a; }
+    };
+    B b;
+  };
+  A aa;
+  return aa.fred();
+}
+
+int f2 () {
+  struct A {
+    ~A() { a = 3; }
+    int a;
+    int fred () { return a + 1; }
+  };
+
+  A ab;
+  ab.a = 12;
+  return ab.fred();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp1.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp1.C
new file mode 100644
index 00000000000..4c6bac0cdfd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp1.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+template<class E> class D
+{
+};
+
+template<template<class> class D,class E> class C
+{
+};
+
+int main()
+{
+	C<int,D> c;		// ERROR - args not match
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp10.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp10.C
new file mode 100644
index 00000000000..ca0c9b636e1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp10.C
@@ -0,0 +1,30 @@
+// Build don't link:
+
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D d;			// ERROR - D is a template
+	public:
+		int f();
+};
+
+template<template<class> class D,class E> int C<D,E>::f()
+{
+	return d.f();			// ERROR - d not properly declared
+}
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp11.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp11.C
new file mode 100644
index 00000000000..213eb40d75f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp11.C
@@ -0,0 +1,25 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() { return d.f(); }
+};
+
+int main()
+{
+	C<D,int> c;
+	C<D,char> d;
+	c.f();
+	d.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp12.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp12.C
new file mode 100644
index 00000000000..c9bc9f3a909
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp12.C
@@ -0,0 +1,28 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class E,class D> class C
+{
+		E<D> d;
+	public:
+		int f();
+};
+
+template<template<class> class E,class D> int C<E,D>::f()
+{
+	return d.f();
+}
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp13.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp13.C
new file mode 100644
index 00000000000..2745c7acfd2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp13.C
@@ -0,0 +1,28 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f();
+};
+
+template<template<class> class D,class E> int C<D,E>::f()
+{
+	return d.f();
+}
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp14.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp14.C
new file mode 100644
index 00000000000..04877d65b75
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp14.C
@@ -0,0 +1,30 @@
+template<class T> class D
+{
+	T	a;
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<class E,template<class> class DD = D> class C
+{
+		DD<E> d;
+	public:
+		int f();
+};
+
+template<class E,template<class> class DD> int C<E,DD>::f()
+{
+	DD<E> d2;
+	return d2.f();
+}
+
+int main()
+{
+	C<int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp15.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp15.C
new file mode 100644
index 00000000000..25f3c4d0cf7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp15.C
@@ -0,0 +1,29 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f();
+};
+
+template<template<class> class D,class E> int C<D,E>::f()
+{
+	D<E> d2;
+	return d2.f();
+}
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp16.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp16.C
new file mode 100644
index 00000000000..ac736fabd79
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp16.C
@@ -0,0 +1,30 @@
+template<class T> class D
+{
+	T	a;
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f();
+};
+
+template<template<class> class D,class E> int C<D,E>::f()
+{
+	D<E> d2;
+	return d2.f();
+}
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp17.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp17.C
new file mode 100644
index 00000000000..685240490b1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp17.C
@@ -0,0 +1,30 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f();
+		int g() { return 0; }
+};
+
+template<template<class> class D,class E> int C<D,E>::f()
+{
+	C<D,E> d2;
+	return d2.g();
+}
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp18.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp18.C
new file mode 100644
index 00000000000..6c9e579281a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp18.C
@@ -0,0 +1,30 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f();
+		int g() { return 0; }
+};
+
+template<template<class> class D,class E> int C<D,E>::f()
+{
+	C<D,char> d2;
+	return d2.g();
+}
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp19.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp19.C
new file mode 100644
index 00000000000..8a249467abd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp19.C
@@ -0,0 +1,24 @@
+#include <vector>
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int size() { return d.size(); }
+};
+
+template<template<class> class D,class E> int size(D<E> &d1)
+{
+	d1.size();
+	C<D,E> d2;
+	d2.size();
+	return 0;
+}
+
+int main()
+{
+	std::vector<int> c1;
+	std::vector<char> c2;
+	size(c1);
+	size(c2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp2.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp2.C
new file mode 100644
index 00000000000..5badbe22fe0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp2.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+template<class E> class D
+{
+};
+
+template<template<class> class D,int> class C
+{
+};
+
+int main()
+{
+	C<1,D> c;		// ERROR - args not match
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp20.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp20.C
new file mode 100644
index 00000000000..e3b26c65fc2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp20.C
@@ -0,0 +1,27 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C : D<E>
+{
+	public:
+		int g();
+};
+
+template<template<class> class D,class E> int C<D,E>::g()
+{
+	return f();
+}
+
+int main()
+{
+	C<D,int> c;
+	c.g();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp21.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp21.C
new file mode 100644
index 00000000000..c6cc24b3d87
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp21.C
@@ -0,0 +1,33 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C : D<E>
+{
+	public:
+		int g();
+};
+
+template<template<class> class D,class E> int C<D,E>::g()
+{
+	return f();
+}
+
+class E : C<D,int>
+{
+	public:
+		int h() { return g(); }
+};
+
+int main()
+{
+	E c;
+	c.h();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp22.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp22.C
new file mode 100644
index 00000000000..7eac0ed4261
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp22.C
@@ -0,0 +1,33 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class DD,class EE> class C : DD<EE>
+{
+	public:
+		int f();
+};
+
+template<template<class> class DD,class EE> int C<DD,EE>::f()
+{
+	return DD<EE>::f();
+}
+
+class E : C<D,int>
+{
+	public:
+		int f() { return C<D,int>::f(); }
+};
+
+int main()
+{
+	E c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp23.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp23.C
new file mode 100644
index 00000000000..636bb1cae26
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp23.C
@@ -0,0 +1,33 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class E,class D> class C : E<D>
+{
+	public:
+		int f();
+};
+
+template<template<class> class E,class D> int C<E,D>::f()
+{
+	return E<D>::f();
+}
+
+class E : C<D,int>
+{
+	public:
+		int f() { return C<D,int>::f(); }
+};
+
+int main()
+{
+	E c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp24.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp24.C
new file mode 100644
index 00000000000..1e6278f6b80
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp24.C
@@ -0,0 +1,22 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> int f()
+{
+	D<E> d;
+	return d.f();
+};
+
+int main()
+{
+	f<D,int>();
+	f<D,char>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp25.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp25.C
new file mode 100644
index 00000000000..c30905ed4c5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp25.C
@@ -0,0 +1,33 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() { return d.f(); }
+};
+
+template<template<class> class D,class E> int f(D<E> &d1)
+{
+	d1.f();
+	C<D,E> d2;
+	d2.f();
+	return 0;
+}
+
+int main()
+{
+	D<int> c1;
+	D<char> c2;
+	f(c1);
+	f(c2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp26.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp26.C
new file mode 100644
index 00000000000..6e6425e99dd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp26.C
@@ -0,0 +1,33 @@
+template<class T, class U = int> class D
+{
+	public:
+		int f();
+};
+
+template<class T, class U> int D<T,U>::f()
+{
+	return sizeof(T)+sizeof(U);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() { return d.f(); }
+};
+
+template<template<class> class D,class E> int f(D<E> &d1)
+{
+	d1.f();
+	C<D,E> d2;
+	d2.f();
+	return 0;
+}
+
+int main()
+{
+	D<int> c1;
+	D<char> c2;
+	f(c1);
+	f(c2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp27.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp27.C
new file mode 100644
index 00000000000..7ecf30197b5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp27.C
@@ -0,0 +1,35 @@
+template<class T> class D
+{
+	public:
+		int f() const;
+};
+
+template<class T> int D<T>::f() const
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() const { return d.f(); }
+};
+
+template<template<class> class D,class E> int f(const D<E> &d1)
+{
+	d1.f();
+	C<D,E> d2;
+	d2.f();
+	return 0;
+}
+
+int main()
+{
+	D<const int> c1;
+	D<char> c2;
+	const D<char> c3(c2);
+	f(c1);
+	f(c2);
+	f(c3);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp28.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp28.C
new file mode 100644
index 00000000000..5948dc5d99a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp28.C
@@ -0,0 +1,39 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() { return d.f(); }
+};
+
+template<template<class> class D,class E> int f(D<E> &d1)
+{
+	d1.f();
+	C<D,E> d2;
+	d2.f();
+	return 0;
+}
+
+template<> int f<>(D<char> &d1)
+{
+	d1.f();
+	return 0;
+}
+
+int main()
+{
+	D<int> c1;
+	D<char> c2;
+	f(c1);
+	f(c2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp29.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp29.C
new file mode 100644
index 00000000000..b431ad0e38c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp29.C
@@ -0,0 +1,32 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+extern "C" void abort();
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() { abort(); return 0; }
+};
+
+template<class E> class C<D,E>
+{
+		D<E> d;
+	public:
+		int f() { return d.f(); }
+};
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp3.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp3.C
new file mode 100644
index 00000000000..322dd1991e3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp3.C
@@ -0,0 +1,14 @@
+// Build don't link:
+
+template<class E,class F> class D
+{
+};
+
+template<template<class> class D,class E> class C
+{
+};
+
+int main()
+{
+	C<D,int> c;		// ERROR - param list not match// WARNING - sees it as not having a type
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp30.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp30.C
new file mode 100644
index 00000000000..c47b15758ad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp30.C
@@ -0,0 +1,37 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+extern "C" void abort();
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() { abort(); return 0; }
+};
+
+template<class E> class C<D,E>
+{
+		D<E> d;
+	public:
+		int f();
+};
+
+template<class E> int C<D,E>::f()
+{
+	return d.f();
+}
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp31.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp31.C
new file mode 100644
index 00000000000..4e1acf20720
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp31.C
@@ -0,0 +1,32 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+extern "C" void abort();
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() { abort(); return 0; }
+};
+
+template<template <class> class F> class C<F,int>
+{
+		F<int> d;
+	public:
+		int f() { return d.f(); }
+};
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp32.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp32.C
new file mode 100644
index 00000000000..5c7a63a151f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp32.C
@@ -0,0 +1,37 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+extern "C" void abort();
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() { abort(); return 0; }
+};
+
+template<template <class> class F> class C<F,int>
+{
+		F<int> d;
+	public:
+		int f();
+};
+
+template<template<class>class F> int C<F,int>::f()
+{
+	return d.f();
+}
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp33.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp33.C
new file mode 100644
index 00000000000..3755ff34377
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp33.C
@@ -0,0 +1,31 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		template<template<class> class F> int f(F<int>);
+};
+
+template<template<class> class D,class E> 
+template<template<class> class F> int C<D,E>::f(F<int>)
+{
+	F<E> d2;
+	return d2.f();
+}
+
+int main()
+{
+	C<D,int> c;
+	D<int> d;
+	c.f(d);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp34.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp34.C
new file mode 100644
index 00000000000..d605043d686
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp34.C
@@ -0,0 +1,31 @@
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	return sizeof(T);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f();
+};
+
+template<template<class> class D,class E> int C<D,E>::f()
+{
+	D<E> d2;
+	return d2.f();
+}
+
+template class C<D,int>;
+
+int main()
+{
+	C<D,int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp35.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp35.C
new file mode 100644
index 00000000000..655f406ed80
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp35.C
@@ -0,0 +1,35 @@
+template<int T, class U = int> class D
+{
+	public:
+		int f();
+};
+
+template<int T, class U> int D<T,U>::f()
+{
+	return T+sizeof(U);
+}
+
+template<template<int> class D,class E> class C
+{
+		D<1> d;
+	public:
+		int f() { return d.f(); }
+};
+
+template<template<int> class D> int f(D<2> &d1)
+{
+	d1.f();
+	return 0;
+}
+
+template<template<int> class D> int f(D<1> &d1)
+{
+	d1.f();
+	return 0;
+}
+
+int main()
+{
+	D<1> c1;
+	f(c1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp36.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp36.C
new file mode 100644
index 00000000000..976bc0e603d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp36.C
@@ -0,0 +1,29 @@
+template<int T, class U = int> class D
+{
+	public:
+		int f();
+};
+
+template<int T, class U> int D<T,U>::f()
+{
+	return T+sizeof(U);
+}
+
+template<template<int> class D,class E> class C
+{
+		D<1> d;
+	public:
+		int f() { return d.f(); }
+};
+
+template<template<int> class D> int f(D<1> &d1)
+{
+	d1.f();
+	return 0;
+}
+
+int main()
+{
+	D<1> c1;
+	f(c1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp37.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp37.C
new file mode 100644
index 00000000000..01b0d29b0b2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp37.C
@@ -0,0 +1,29 @@
+template<int T, class U = int> class D
+{
+	public:
+		int f();
+};
+
+template<int T, class U> int D<T,U>::f()
+{
+	return T+sizeof(U);
+}
+
+template<template<int> class D,class E> class C
+{
+		D<1> d;
+	public:
+		int f() { return d.f(); }
+};
+
+template<template<int> class D, int T> int f(D<T> &d1)
+{
+	d1.f();
+	return T;
+}
+
+int main()
+{
+	D<1> c1;
+	f(c1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp38.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp38.C
new file mode 100644
index 00000000000..00c663c9d60
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp38.C
@@ -0,0 +1,29 @@
+template<class T, class U = int> class D
+{
+	public:
+		int f();
+};
+
+template<class T, class U> int D<T,U>::f()
+{
+	return sizeof(T)+sizeof(U);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() { return d.f(); }
+};
+
+template<template<class> class D> int f(D<int> &d1)
+{
+	d1.f();
+	return 0;
+}
+
+int main()
+{
+	D<int> c1;
+	f(c1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp39.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp39.C
new file mode 100644
index 00000000000..24ff6c00372
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp39.C
@@ -0,0 +1,29 @@
+template<class T, class U = T> class D
+{
+	public:
+		int f();
+};
+
+template<class T, class U> int D<T,U>::f()
+{
+	return sizeof(T)+sizeof(U);
+}
+
+template<template<class> class D,class E> class C
+{
+		D<E> d;
+	public:
+		int f() { return d.f(); }
+};
+
+template<template<class> class D> int f(D<int> &d1)
+{
+	d1.f();
+	return 0;
+}
+
+int main()
+{
+	D<int> c1;
+	f(c1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp4.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp4.C
new file mode 100644
index 00000000000..249ad9c35fa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp4.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+template<class E> class D
+{
+};
+
+template<template<class> class D,class E> class C
+{
+	D<1> d;			// ERROR - arg not match
+};
+
+int main()
+{
+	C<D,int> c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp40.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp40.C
new file mode 100644
index 00000000000..d30b4d6a00e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp40.C
@@ -0,0 +1,20 @@
+#include <vector>
+
+template<class E,template<class> class DD = std::vector> class C
+{
+		DD<E> d;
+	public:
+		int f();
+};
+
+template<class E,template<class> class DD> int C<E,DD>::f()
+{
+	DD<E> d2;
+	return d2.size();
+}
+
+int main()
+{
+	C<int> c;
+	c.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp41.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp41.C
new file mode 100644
index 00000000000..f206c03c291
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp41.C
@@ -0,0 +1,23 @@
+template<template<class> class D,class E> class C
+{
+	public:
+		int g() { return 1; }
+};
+
+template<class T> class D
+{
+	public:
+		int f();
+};
+
+template<class T> int D<T>::f()
+{
+	C<D,D> c;
+	return c.g();
+}
+
+int main()
+{
+	D<char> d;
+	d.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp42.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp42.C
new file mode 100644
index 00000000000..b2610dfb123
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp42.C
@@ -0,0 +1,21 @@
+template <class T, template <class T> class C>
+struct X
+{};
+
+template <class T>
+struct Y
+{};
+
+template <class T>
+struct Z
+{};
+
+template <class T>
+struct X<T,Y>
+{};
+
+int main()
+{
+  X<int,Y> a;
+  X<int,Z> b;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp43.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp43.C
new file mode 100644
index 00000000000..a020655b131
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp43.C
@@ -0,0 +1,30 @@
+// Build don't link:
+
+template < class T, template <class> class E1, template <class> class E2 >
+struct Add {
+  Add(const E1<T>& e1, const E2<T>& e2) {}
+};
+
+
+template < class T, template <class> class E1, template <class> class E2 >
+struct Mul {
+  Mul(const E1<T>& e1, const E2<T>& e2) {}
+};
+
+
+template < class T >
+struct Lit {
+  Lit(const T& t) {}
+};
+
+
+template < class T >
+struct Id {
+  Add < T, Id, Lit > operator+(const T& t) const {
+    return Add < T, Id, Lit >(*this, Lit<T>(t));
+  }
+
+  Mul < T, Id, Lit > operator*(const T& t) const {
+    return Mul < T, Id, Lit >(*this, Lit<T>(t));
+  }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp44.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp44.C
new file mode 100644
index 00000000000..7f797e6dd86
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp44.C
@@ -0,0 +1,17 @@
+// Build don't link:
+
+template < class T, template < class > class E1, template < class > class E2 >
+class Add {
+public:
+  Add(const E1<T>& e1, const E2<T>& e2) {}
+};
+
+template < class T >
+struct Id {
+  template < template < class > class E >
+  Add < T, Id, E > operator+(const E<T>& e) const {
+    return Add < T, Id, E >(*this, e);
+  }
+};
+
+template struct Id<double>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp45.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp45.C
new file mode 100644
index 00000000000..05fcd9d399a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp45.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+template<class M, class T> struct temp2;
+template<template<class> class M, class T> struct temp2<M<T>, T> {};
+
+template<class M> struct temp1;
+template<template<class> class M, class T> struct temp1<M<T> > {};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp46.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp46.C
new file mode 100644
index 00000000000..23a32a8434d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp46.C
@@ -0,0 +1,4 @@
+// Build don't link:
+
+template <template<class> class TT> void f() {}
+template <template<class,class> class TT> void f() {}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp47.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp47.C
new file mode 100644
index 00000000000..731ce40cede
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp47.C
@@ -0,0 +1,16 @@
+template <template<class,class> class TT, class T> void f(T)
+{
+}
+
+template <template<class> class TT, class T> void f(T)
+{
+}
+
+template <class T> class C {};
+template <class T,class U> class D {};
+
+int main()
+{
+	f<C>(1);
+	f<D>(1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp48.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp48.C
new file mode 100644
index 00000000000..33d0d47296c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp48.C
@@ -0,0 +1,16 @@
+template <template<int> class TT, class T> void f(T)
+{
+}
+
+template <template<class> class TT, class T> void f(T)
+{
+}
+
+template <class T> class C {};
+template <int> class D {};
+
+int main()
+{
+	f<C>(1);
+	f<D>(1);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp49.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp49.C
new file mode 100644
index 00000000000..b0a02d2c6c4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp49.C
@@ -0,0 +1,9 @@
+// Build don't link:
+
+template <int i> class C {};
+template <template <long> class TT> class D {};
+
+int main()
+{
+	D<C> d;		// ERROR - args not match
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp5.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp5.C
new file mode 100644
index 00000000000..4b835e88821
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp5.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+template<int> class D
+{
+};
+
+template<template<int> class D,class E> class C
+{
+	D<int> d;			// ERROR - arg not match
+};
+
+int main()
+{
+	C<D,int> c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp50.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp50.C
new file mode 100644
index 00000000000..4892e0c86e9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp50.C
@@ -0,0 +1,7 @@
+template <class T, template <T> class TT> class C {};
+template <int> class D {};
+
+int main()
+{
+  C<int,D> c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp51.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp51.C
new file mode 100644
index 00000000000..9a497b797c8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp51.C
@@ -0,0 +1,13 @@
+template<class E, int i, class F, class G=int, int j=i, class H=E> class D
+{
+};
+
+template<template<class,int,class,class> class D,class E> class C
+{
+	D<E,2,char,bool>	d;
+};
+
+int main()
+{
+	C<D,int> c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp52.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp52.C
new file mode 100644
index 00000000000..fb841b96ea7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp52.C
@@ -0,0 +1,18 @@
+// Build don't link:
+
+template<class A,class B> class mymap {};
+
+template<class Key, 
+         class Value, 
+         template<class, class > class MapT> 
+class base 
+{
+  
+};
+
+// specialization
+template<class Key, class Value>
+class base<Key, Value, mymap<int, int > >	
+{						// ERROR - type/value mismatch
+  
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp53.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp53.C
new file mode 100644
index 00000000000..e5e87b46089
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp53.C
@@ -0,0 +1,35 @@
+// Build don't link:
+
+// Submitted by Erez Louidor Lior <s3824888@techst02.technion.ac.il>
+
+template <typename> class H;
+template <typename Target, typename Source>
+H<Target> foo(const H<Source>&);
+
+template <typename Type>
+class H{
+
+#ifdef OK
+public:
+#endif
+  template<template<class, class> class Caster, typename Source>
+  static H<Type> cast(const H<Source>& s);
+
+#ifndef OK
+  template <typename Target, typename Source>
+  friend H<Target> foo(const H<Source>&);
+#endif
+
+};
+
+template <class, class> class caster;
+
+template <typename Target, typename Source>
+H<Target> foo(const H<Source>& s){
+  return H<Target>::template cast<caster, Source>(s);
+}
+
+int main(){
+  H<int> i;
+  foo<const int>(i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp54.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp54.C
new file mode 100644
index 00000000000..bae649a3dfa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp54.C
@@ -0,0 +1,20 @@
+// Build don't link:
+
+// Reported by Bruce Eckel <Bruce@EckelObjects.com>
+
+// [temp.deduct.type]
+// Make sure we treat <T> in the construct TT<T> as any type containing T.
+
+template <class T> class C
+{
+};
+
+template <class T, template <class> class TT> void f (TT<T *> &t)
+{
+}
+
+int main ()
+{
+       C<char *> c;
+       f(c);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp55.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp55.C
new file mode 100644
index 00000000000..10af608bcba
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp55.C
@@ -0,0 +1,23 @@
+// Build don't link:
+
+// Testing overloading of function argument involving template template
+// parameters
+
+// Reported by Thomus Kunert <kunert@physik.tu-dresden.de>
+
+template<class A>
+class H{};
+
+template <class T>
+void f( const T& ){}                      // #1
+
+template< template<class, class> class X, 
+	class A, class B>
+void f( const X<A,B> & x )                // #2
+{}
+
+int main()
+{
+    H<int> h;
+    f(h);                                 // #3
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp6.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp6.C
new file mode 100644
index 00000000000..cdea182849e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp6.C
@@ -0,0 +1,13 @@
+template<int> class F
+{
+};
+
+template<template<int> class D,class E> class C
+{
+	D<1> d;
+};
+
+int main()
+{
+	C<F,int> c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp7.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp7.C
new file mode 100644
index 00000000000..0b982170e78
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp7.C
@@ -0,0 +1,15 @@
+// Build don't link:
+
+template<class E> class D
+{
+};
+
+template<template<class> class D,class E> class C	// ERROR - ref below
+{
+	D<int,int> d;				// ERROR - arg not match
+};
+
+int main()
+{
+	C<D,int> c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp8.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp8.C
new file mode 100644
index 00000000000..fd2a67c1b4a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp8.C
@@ -0,0 +1,17 @@
+template<class E> class DD
+{
+};
+
+template<int> class D
+{
+};
+
+template<template<class> class D,class E> class C
+{
+	D<E>	d;
+};
+
+int main()
+{
+	C<DD,int> c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/ttp9.C b/gcc/testsuite/g++.old-deja/g++.pt/ttp9.C
new file mode 100644
index 00000000000..3892b6e9fec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/ttp9.C
@@ -0,0 +1,13 @@
+template<class E,class F=int> class D
+{
+};
+
+template<template<class> class D,class E> class C
+{
+	D<E>	d;
+};
+
+int main()
+{
+	C<D,int> c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typedef1.C b/gcc/testsuite/g++.old-deja/g++.pt/typedef1.C
new file mode 100644
index 00000000000..8d674c9f127
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typedef1.C
@@ -0,0 +1,18 @@
+// Testcase for handling of typedef wierdness.
+// Build don't link:
+
+template <class T>
+struct A
+{
+  typedef enum
+  {
+    foo
+  } B;
+
+  A (B b);
+};
+
+template <class T>
+A<T>::A (B b)
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typedef2.C b/gcc/testsuite/g++.old-deja/g++.pt/typedef2.C
new file mode 100644
index 00000000000..18802fcd7bc
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typedef2.C
@@ -0,0 +1,20 @@
+// Build don't link:
+
+typedef const int cint;
+
+template<class T>
+class A
+{
+public:
+  T f(cint i);
+};
+
+template <class T>
+T A<T>::f(cint i)
+{
+}
+
+int main()
+{
+  A<int> a;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typedef3.C b/gcc/testsuite/g++.old-deja/g++.pt/typedef3.C
new file mode 100644
index 00000000000..110e4814515
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typedef3.C
@@ -0,0 +1,25 @@
+// Build don't link:
+
+template <class T>
+void f(T, T)
+{
+}
+
+struct A {
+  typedef enum {
+    VAL1
+  } result_t;
+};
+
+struct B {
+  typedef enum {
+    VAL2
+  } result_t;
+};
+
+
+void g()
+{
+  f(A::VAL1, A::VAL1);
+  f(B::VAL2, B::VAL2);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typedef4.C b/gcc/testsuite/g++.old-deja/g++.pt/typedef4.C
new file mode 100644
index 00000000000..4b1c5d82598
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typedef4.C
@@ -0,0 +1,17 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+struct B1 {
+  typedef int X;
+};
+
+struct B2 {
+  typedef int X;
+};
+
+template <class T>
+struct D : public B1, public B2 {
+  typedef int X;
+};
+
+template struct D<int>;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename1.C b/gcc/testsuite/g++.old-deja/g++.pt/typename1.C
new file mode 100644
index 00000000000..c34eff12cdd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename1.C
@@ -0,0 +1,27 @@
+// Build don't link:
+
+template<class T>
+struct A {
+    typedef T T1;
+};
+
+template<class T>
+struct B {
+    typedef T T2;
+};
+
+template<class T>
+struct C {
+};
+
+template<class E>
+C<typename E::T2::T1>
+foo (E)
+{
+    return C<typename E::T2::T1>();
+}
+
+void test()
+{
+    foo(B<A<int> >());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename10.C b/gcc/testsuite/g++.old-deja/g++.pt/typename10.C
new file mode 100644
index 00000000000..1b122b22901
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename10.C
@@ -0,0 +1,7 @@
+// Build don't link:
+
+struct S {
+  typedef int I;
+};
+
+void f(typename S::I); // ERROR - using typename outside of template
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename11.C b/gcc/testsuite/g++.old-deja/g++.pt/typename11.C
new file mode 100644
index 00000000000..1b4a1d51a69
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename11.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// Special g++ Options:
+
+template <class T, int I>
+struct S {
+  struct X {};
+};
+
+template <class T, class U, int I>
+S<T,I>::X f(T, U)
+{
+  S<T, I>::X();
+}
+
+template S<int, 3>::X f<int, double, 3>(int, double);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename12.C b/gcc/testsuite/g++.old-deja/g++.pt/typename12.C
new file mode 100644
index 00000000000..cef670089c1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename12.C
@@ -0,0 +1,31 @@
+// Special g++ Options:
+// execution test - XFAIL *-*-*
+// excess errors test - XFAIL *-*-*
+
+int i = 0;
+
+template <class T>
+struct S {
+  struct X {};
+};
+
+template <class T>
+void f(T)
+{
+  S<T>::X();
+}
+
+template <>
+struct S<int> {
+  static void X() { i = 1; }
+};
+
+int main()
+{
+  f(3);
+  if (i != 1)
+    return 1;
+  else 
+    return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename13.C b/gcc/testsuite/g++.old-deja/g++.pt/typename13.C
new file mode 100644
index 00000000000..48d12e6351e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename13.C
@@ -0,0 +1,37 @@
+// Build don't link:
+// Special g++ Options:
+// excess errors test - XFAIL *-*-*
+
+template <class T>
+struct B 
+{
+  typedef int I;
+};
+
+
+template <class T>
+struct D : public B<T>
+{
+  void f();
+};
+
+
+template <class T>
+void D<T>::f()
+{
+  I();
+}
+
+
+template <>
+struct B<int> 
+{
+  void I();
+};
+
+
+int main()
+{
+  D<int> di;
+  di.f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename14.C b/gcc/testsuite/g++.old-deja/g++.pt/typename14.C
new file mode 100644
index 00000000000..7365b66801d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename14.C
@@ -0,0 +1,15 @@
+// Build don't link:
+// Special g++ Options:
+
+template <class T>
+struct B {
+  typedef T X;
+};
+
+template <class T>
+struct S : public B<T>
+{
+  struct I {
+    void f(X x);
+  };
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename15.C b/gcc/testsuite/g++.old-deja/g++.pt/typename15.C
new file mode 100644
index 00000000000..8e26057922e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename15.C
@@ -0,0 +1,18 @@
+// Build don't link:
+// Special g++ Options:
+
+template <class T, bool B> 
+struct R {
+  struct X {};
+};
+
+template <class T, bool B = false>
+struct S : public R <T, B> {
+};
+
+template <class T> void f() 
+{
+  S<T>::X();
+}
+
+template void f<int>();
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename16.C b/gcc/testsuite/g++.old-deja/g++.pt/typename16.C
new file mode 100644
index 00000000000..51a8765e9ac
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename16.C
@@ -0,0 +1,31 @@
+// Build don't run:
+// Special g++ Options:
+
+struct B {
+  typedef int I;
+};
+
+template <class T>
+struct D1 : public B {
+};
+
+template <class T>
+struct D2 : public D1<T> {
+  I i;
+};
+
+template <>
+struct D1<int> {
+  typedef double I;
+};
+
+template <class T>
+void f(T);
+template <>
+void f(double) {}
+
+int main()
+{
+  D2<int> d2i;
+  f(d2i.i);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename17.C b/gcc/testsuite/g++.old-deja/g++.pt/typename17.C
new file mode 100644
index 00000000000..87b0ab3b905
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename17.C
@@ -0,0 +1,20 @@
+// Build don't link:
+
+template <class T>
+struct A
+{
+  typedef T A_Type;
+};
+
+
+template <class U>
+struct B : public A<U>
+{
+  typename B<U>::A_Type Func();
+};
+
+
+template <class U>
+typename B<U>::A_Type B<U>::Func()
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename18.C b/gcc/testsuite/g++.old-deja/g++.pt/typename18.C
new file mode 100644
index 00000000000..ed423e77bec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename18.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// Special g++ Options:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+void X();
+
+template <class T>
+struct J {
+  typedef T X;
+};
+
+template <class T>
+struct S {
+  typedef T X;
+
+  struct I : public J<X> {
+    static X* f();
+  };
+};
+
+S<int> si;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename19.C b/gcc/testsuite/g++.old-deja/g++.pt/typename19.C
new file mode 100644
index 00000000000..be93a983267
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename19.C
@@ -0,0 +1,26 @@
+// Special g++ Options:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class T>
+struct O {
+  typedef char X;
+};
+
+template <class T>
+struct S {
+  typedef double X;
+
+  template <class U>
+  struct I : public O<U> {
+    static X x; // WARNING - lookup finds S<T>::X
+  };
+};
+
+template <class T>
+template <class U>
+typename S<T>::X S<T>::I<U>::x;
+
+int main()
+{
+  return sizeof (S<int>::I<double>::x) == 1;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename2.C b/gcc/testsuite/g++.old-deja/g++.pt/typename2.C
new file mode 100644
index 00000000000..f2f22657eb5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename2.C
@@ -0,0 +1,21 @@
+// Build don't link:
+
+class Base {
+public:
+  class Bar { public: virtual ~Bar() {}; };
+};
+
+class Derived : public Base {
+public:
+  class Bar : public Base::Bar {};
+};
+
+template <class T>
+struct XYZ : public T::Bar {
+  XYZ(): T::Bar() { }
+};
+
+void test() {
+  XYZ<Base> b;
+  XYZ<Derived> d;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename20.C b/gcc/testsuite/g++.old-deja/g++.pt/typename20.C
new file mode 100644
index 00000000000..0f6c4fc1ef4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename20.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+// Special g++ Options:
+
+template <class T>
+struct B {
+  typedef int I;
+};
+
+template <class T, class X = int>
+struct S : public B <T> {
+  struct I {
+  };
+
+  void f(int i = true) {}
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename21.C b/gcc/testsuite/g++.old-deja/g++.pt/typename21.C
new file mode 100644
index 00000000000..2dc52aa429a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename21.C
@@ -0,0 +1,25 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+// Special g++ Options:
+
+template <class T>
+struct S1 {
+  typedef T X;
+};
+
+template <class T>
+struct B {
+  typedef T I;
+};
+
+template <class T>
+struct S2 : public B<T> {
+  struct I {};
+
+  typedef typename S1<I>::X IX;
+
+  void f(IX);
+};
+
+template <class T>
+void S2<T>::f(IX) {}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename22.C b/gcc/testsuite/g++.old-deja/g++.pt/typename22.C
new file mode 100644
index 00000000000..86a82df65cb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename22.C
@@ -0,0 +1,17 @@
+// Build don't link:
+// Origin: Mark Mitchell <mark@codesourcery.com>
+
+template <class T>
+struct S {
+  template <class U>
+  struct I { 
+    typedef U X;
+
+    X f();
+  };
+};
+
+
+template <class T>
+template <class U>
+typename S<T>::I<U>::X S<T>::I<U>::f() {}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename3.C b/gcc/testsuite/g++.old-deja/g++.pt/typename3.C
new file mode 100644
index 00000000000..55d6430f2ef
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename3.C
@@ -0,0 +1,21 @@
+// Build don't link:
+// Special g++ Options:
+
+template <class T>
+struct A
+{
+  typedef T A_Type;
+};
+
+
+template <class U>
+struct B : public A<U>
+{
+  A_Type Func();
+};
+
+
+template <class U>
+B<U>::A_Type B<U>::Func()
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename4.C b/gcc/testsuite/g++.old-deja/g++.pt/typename4.C
new file mode 100644
index 00000000000..6f9362fe8e7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename4.C
@@ -0,0 +1,27 @@
+// Build don't link:
+// Special g++ Options:
+
+template <class T>
+struct A
+{
+  typedef T A_Type;
+};
+
+
+template <class U>
+struct B : public A<U>
+{
+};
+
+
+template <class U>
+struct C : public B<U>
+{
+  A_Type Func();
+};
+
+
+template <class U>
+C<U>::A_Type C<U>::Func()
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename5.C b/gcc/testsuite/g++.old-deja/g++.pt/typename5.C
new file mode 100644
index 00000000000..e967d143f37
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename5.C
@@ -0,0 +1,27 @@
+// Build don't link:
+// Special g++ Options:
+
+template <class T>
+struct A
+{
+  typedef T A_Type;
+};
+
+
+template <class U>
+struct B : public A<U>
+{
+};
+
+
+template <class U>
+struct C : public B<U>
+{
+  void Func(A_Type);
+};
+
+
+template <class U>
+void C<U>::Func(A_Type)
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename6.C b/gcc/testsuite/g++.old-deja/g++.pt/typename6.C
new file mode 100644
index 00000000000..a3df71840e7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename6.C
@@ -0,0 +1,22 @@
+// We don't try to make implicit typename handle this case.
+
+// Build don't link:
+// Special g++ Options:
+
+template <class T>
+struct A
+{
+  typedef T A_Type;
+};
+
+
+template <class U>
+struct B : public A<U>
+{
+  A_Type Func();		// ERROR - candidate
+};
+
+template <class U>
+A<U>::A_Type B<U>::Func()
+{				// ERROR - no match
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename7.C b/gcc/testsuite/g++.old-deja/g++.pt/typename7.C
new file mode 100644
index 00000000000..5c89603c8aa
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename7.C
@@ -0,0 +1,20 @@
+// Test for implicit typename
+// Build don't link:
+// Special g++ Options:
+
+template <class T>
+struct A {
+protected:
+  typedef struct B { } B;
+};
+
+template <class T>
+struct C { };
+
+template <class T>
+struct D : public A <C <T> > {
+  void f ()
+    {
+      B* new_entries = (B *) 0;
+    }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename8.C b/gcc/testsuite/g++.old-deja/g++.pt/typename8.C
new file mode 100644
index 00000000000..86881f51127
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename8.C
@@ -0,0 +1,27 @@
+// Build don't link:
+
+template < class T > class A
+{
+public:
+  typedef typename T::myT anotherT; // ERROR - undefined type
+
+  anotherT t; // ERROR - undefined type 
+
+  A(anotherT _t) { // ERROR - undefined type
+    t=_t;
+  }
+
+  anotherT getT() {
+    return t;
+  }
+};
+
+class B : public A< B > // ERROR - forward declaration
+{
+public:
+  typedef int myT;
+};
+
+int main() {
+  B b;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/typename9.C b/gcc/testsuite/g++.old-deja/g++.pt/typename9.C
new file mode 100644
index 00000000000..027d0a00043
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/typename9.C
@@ -0,0 +1,16 @@
+// Test to make sure that implicit typename doesn't break name binding rules.
+// Special g++ Options: -w
+
+typedef double A;
+template<class T> class B {
+  typedef char A;
+};
+template<class T> struct X : B<T> {
+  A a;
+};
+
+int main()
+{
+  X<char*> x;
+  return sizeof (x.a) != sizeof (double);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/unify1.C b/gcc/testsuite/g++.old-deja/g++.pt/unify1.C
new file mode 100644
index 00000000000..283e2f50f8a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/unify1.C
@@ -0,0 +1,14 @@
+// Tests non-unification of parms that don't use template parms.
+// Build don't link:
+
+enum kind {a, b};
+
+class C { public: C () {} };
+
+template<class P>
+void f (P c, kind k) {}
+
+template<class P>
+void f (P c, P d, kind k) {}
+
+template void f (C c, C c, kind k);
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/unify2.C b/gcc/testsuite/g++.old-deja/g++.pt/unify2.C
new file mode 100644
index 00000000000..89b043d7901
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/unify2.C
@@ -0,0 +1,27 @@
+// Build don't link:
+
+template <class T>
+struct S
+{
+  typedef T S_Type;
+};
+
+
+template <class T>
+void foo(typename S<T>::S_Type)
+{
+}
+
+
+template <class T>
+void foo(T)
+{
+}
+
+
+struct S2 {};
+
+void bar()
+{
+  foo(S2()); // We can't unify with the first foo, so we get the second.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/unify3.C b/gcc/testsuite/g++.old-deja/g++.pt/unify3.C
new file mode 100644
index 00000000000..847dc0eda38
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/unify3.C
@@ -0,0 +1,22 @@
+// Build don't link:
+
+template <class T1, class T2>
+struct ComputeBinaryType
+{
+};
+
+template<class T1>
+struct ComputeBinaryType<T1, double> {
+  void g();
+};
+
+template<class T1>
+struct ComputeBinaryType<T1&, double> {
+  void h();
+};
+
+void f()
+{ 
+  ComputeBinaryType<double, double> cb;
+  cb.g();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/unify4.C b/gcc/testsuite/g++.old-deja/g++.pt/unify4.C
new file mode 100644
index 00000000000..259920d4565
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/unify4.C
@@ -0,0 +1,11 @@
+template <class T> void f (T);
+
+void g ();
+void g (int);
+
+int
+main ()
+{
+  f (g);			// ERROR - ambiguous unification
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/union1.C b/gcc/testsuite/g++.old-deja/g++.pt/union1.C
new file mode 100644
index 00000000000..a1da446e570
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/union1.C
@@ -0,0 +1,18 @@
+// Build don't link:
+
+union Un {int i;};
+
+template<class T1, class T2> struct St1 {};
+template<class T> struct St1<Un,T> {};
+
+template<class T> struct St2 {};
+template<> struct St2<Un> {};
+
+template<class T1, class T2> struct St3 {};
+template<> struct St3<Un,int> {};
+
+void f() {
+  St1<int,int> s1;
+  St2<int>     s2;
+  St3<int,int> s3;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/union2.C b/gcc/testsuite/g++.old-deja/g++.pt/union2.C
new file mode 100644
index 00000000000..f064e4ecefd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/union2.C
@@ -0,0 +1,18 @@
+// Build don't link:
+// Origin: David Mazieres <dm@amsterdam.lcs.mit.edu>
+
+template<class T> struct vector_base {
+  typedef T elm_t;
+protected:
+  union {
+    double alignment_hack;
+    char defbuf_space[2 * sizeof (elm_t)];
+  };
+  elm_t *def_basep () { return reinterpret_cast<elm_t *> (defbuf_space); }
+};
+
+template<class T> struct vector : public vector_base<T> {
+  vector () { def_basep (); }
+};
+
+vector<int> iv;
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/vaarg.C b/gcc/testsuite/g++.old-deja/g++.pt/vaarg.C
new file mode 100644
index 00000000000..56ae0d411c7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/vaarg.C
@@ -0,0 +1,28 @@
+#include <stdarg.h>
+
+extern "C" void abort();
+
+template <class T>
+T* f(T t, ...)
+{
+  va_list ap;
+
+  va_start(ap, t);
+  T* r = va_arg(ap, T*);
+  va_end(ap);
+
+  return r;
+}
+
+
+struct S 
+{
+};
+
+int main()
+{
+  S s;
+
+  if (f(s, &s) != &s)
+    abort();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/vbase1.C b/gcc/testsuite/g++.old-deja/g++.pt/vbase1.C
new file mode 100644
index 00000000000..58d26fcf2ad
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/vbase1.C
@@ -0,0 +1,31 @@
+// Check that template classes handle inherited virtual bases
+// properly, initializing them before direct non-virtual bases.
+
+int aflag;
+
+struct A
+{
+  A() { aflag = 1; }
+};
+
+struct B : virtual public A 
+{
+  B() { }
+};
+
+struct C
+{
+  C() { if (!aflag) exit (1); }
+};
+
+template<class Parent>
+struct D : public C, public Parent
+{
+  D() { }
+};
+
+int
+main ()
+{
+  D<B> c;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/virtual1.C b/gcc/testsuite/g++.old-deja/g++.pt/virtual1.C
new file mode 100644
index 00000000000..efa97b7f41b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/virtual1.C
@@ -0,0 +1,6 @@
+  struct V { virtual ~V() {} };
+  template <class T> struct A : virtual V { };
+  template <class T> struct B {
+    virtual void f() { T foo; }
+  };
+  int main() { B< A<int> > bar; }
diff --git a/gcc/testsuite/g++.old-deja/g++.pt/warn1.C b/gcc/testsuite/g++.old-deja/g++.pt/warn1.C
new file mode 100644
index 00000000000..96ed1485226
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.pt/warn1.C
@@ -0,0 +1,27 @@
+// Build don't link:
+// Special g++ Options: -Wunused
+
+template <class T>
+struct S
+{
+  struct R 
+  {
+    R();
+    ~R();
+  };
+
+  void foo()
+  {
+    R r;			// no warning
+    int i;			// WARNING - unused
+  }
+
+  S();
+  ~S();
+};
+
+void f()
+{
+  S<int> si;
+  si.foo();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.rfg/00321_01-.C b/gcc/testsuite/g++.old-deja/g++.rfg/00321_01-.C
new file mode 100644
index 00000000000..d7e08a3876f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.rfg/00321_01-.C
@@ -0,0 +1,14 @@
+// Here is a simple one.  GCC correctly gives errors for this code when the
+// - -pedantic-errors option is used, whereas g++ doesn't.
+
+// Build don't link:
+
+int (*p1)[3];
+int (*p2)[5];
+
+void
+test ()
+{
+  p1 == p2;		// ERROR - comparison.*
+  p1 > p2;		// ERROR - comparison.*
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.rfg/00324_02-.C b/gcc/testsuite/g++.old-deja/g++.rfg/00324_02-.C
new file mode 100644
index 00000000000..4055ba8432e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.rfg/00324_02-.C
@@ -0,0 +1,16 @@
+// Another simple one.  GCC corerctly gives errors for this code when the
+// - -pedantic-errors options is used.  g++ doesn't.
+
+// Build don't link:
+
+void f (int i) { }
+ 
+void (*fp)(void);
+ 
+int i;
+ 
+void
+test ()
+{
+   i ? f : fp; // ERROR - 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/980310-1.C b/gcc/testsuite/g++.old-deja/g++.robertl/980310-1.C
new file mode 100644
index 00000000000..ee558f41221
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/980310-1.C
@@ -0,0 +1,43 @@
+// Special g++ Options: -g
+// Internal compiler error on egcs 1.0.1 i586-pc-linux-gnulibc1. 
+// From: Max Lawson <mlawson@drfmc.ceng.cea.fr>
+// Message-Id: <9803091022.AA07520@drfmc.ceng.cea.fr>
+
+
+typedef __SIZE_TYPE__ size_t;
+
+struct dummy { };
+
+struct arrrrrgh { };
+
+template<class Par,class Rand = arrrrrgh>
+struct whyyyyyyy { };	 
+
+template<class T, class S =dummy> 
+struct grrrrrrrr { };         
+
+template<class Par, class Par2 =Par, class Rand =arrrrrgh>
+class no_future
+{
+public:
+   
+  template<class S>
+  no_future(const grrrrrrrr<whyyyyyyy<Par,Rand>*,S>& man )  { }
+
+  ~no_future( ) { }
+
+private:
+
+  no_future(const no_future&);
+  no_future& operator=(const no_future&);
+};	 
+
+int main( )
+{
+  grrrrrrrr<whyyyyyyy<double>*> man;
+
+  no_future<double> here(man);
+
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/README b/gcc/testsuite/g++.old-deja/g++.robertl/README
new file mode 100644
index 00000000000..36029c7d9c7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/README
@@ -0,0 +1,18 @@
+This directory contains a hodgepodge of problem reports that appeared on
+the egcs-bugs or egcs mailing lists.  Just like the reports themselves,
+they tend to be poorly understood and poorly organized.  However, we
+drop them into the testsuite on the premise that internal compiler errors
+are always bad - no matter how bogus the source.  
+
+If you really understand C++ (and you know who you are) if you find
+entries in this area that are bogus, feel free to just fix them or nuke
+them.  You don't need my permission.
+
+Many of the first entries in this area were done in "block mode" by
+whipping through many months of archives.  In hindsight, some important
+information was lost, but being picky on over 8,000 messages is a sure
+way to never get out of the gate.
+
+We'll do better now.
+
+Robert Lipe
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb10.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb10.C
new file mode 100644
index 00000000000..7da5d7562ee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb10.C
@@ -0,0 +1,30 @@
+// Build don't link:
+template <int object_size>
+class _fixed_size_allocator
+{
+  private:
+
+    struct      something { };
+    static something *  asdf;
+
+  public:
+
+    static void         delete_object ();
+};
+
+
+template <class T>
+class object_allocator
+{
+  private:
+
+    typedef     _fixed_size_allocator<sizeof (T)>               allocator;
+
+  public:
+
+    static void         deallocate (T * p)
+    {
+        allocator::delete_object (reinterpret_cast<void *> (p));
+    }
+};
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb101.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb101.C
new file mode 100644
index 00000000000..74c6cbb8141
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb101.C
@@ -0,0 +1,3886 @@
+// Special g++ Options: -fcheck-memory-usage
+// Build don't link: 
+
+ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#pragma interface
+
+#define _IOSTREAM_H
+
+ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#define _STREAMBUF_H
+
+#pragma interface
+
+
+   
+
+#define _IO_NEW_STREAMS 
+
+extern "C" {
+ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#define _IO_STDIO_H
+
+  
+
+#define _G_config_h
+#define _G_LIB_VERSION "0.67"
+#define _G_NAMES_HAVE_UNDERSCORE 1
+#define _G_VTABLE_LABEL_HAS_LENGTH 1
+#define _G_VTABLE_LABEL_PREFIX "__vt$"
+#define _G_HAVE_ST_BLKSIZE 1
+typedef long _G_clock_t;
+typedef short _G_dev_t;
+typedef long   _G_fpos_t;
+typedef unsigned short _G_gid_t;
+typedef unsigned long _G_ino_t;
+typedef unsigned short _G_mode_t;
+typedef short _G_nlink_t;
+typedef long _G_off_t;
+typedef int _G_pid_t;
+
+
+
+typedef int _G_ptrdiff_t;
+typedef int _G_sigset_t;
+
+
+
+typedef unsigned int _G_size_t;
+typedef long _G_time_t;
+typedef unsigned short _G_uid_t;
+
+
+
+typedef __wchar_t _G_wchar_t;
+typedef int   _G_ssize_t;
+typedef int   _G_wint_t;
+typedef char * _G_va_list;
+#define _G_signal_return_type void
+#define _G_sprintf_return_type char*
+
+typedef signed char _G_int8_t;
+
+typedef unsigned char _G_uint8_t;
+typedef short _G_int16_t;
+typedef unsigned short _G_uint16_t;
+typedef long _G_int32_t;
+typedef unsigned long _G_uint32_t;
+
+#define HAVE_INT64
+typedef long long _G_int64_t;
+typedef unsigned long long _G_uint64_t;
+
+#define _G_BUFSIZ 1024
+#define _G_FOPEN_MAX 32 
+#define _G_FILENAME_MAX 1024 
+#define _G_NULL 0 
+
+#define _G_ARGS(ARGLIST) ARGLIST
+
+
+
+
+
+
+
+
+
+#define _G_HAVE_ATEXIT 0
+#define _G_HAVE_SYS_RESOURCE 1
+#define _G_HAVE_SYS_SOCKET 1
+#define _G_HAVE_SYS_WAIT 1
+#define _G_HAVE_UNISTD 1
+#define _G_HAVE_DIRENT 1
+#define _G_HAVE_CURSES 1
+#define _G_MATH_H_INLINES 0
+#define _G_HAVE_BOOL 1
+
+
+#define _IO_pos_t _G_fpos_t 
+#define _IO_fpos_t _G_fpos_t
+#define _IO_size_t _G_size_t
+#define _IO_ssize_t _G_ssize_t
+#define _IO_off_t _G_off_t
+#define _IO_pid_t _G_pid_t
+#define _IO_uid_t _G_uid_t
+#define _IO_HAVE_SYS_WAIT _G_HAVE_SYS_WAIT
+#define _IO_HAVE_ST_BLKSIZE _G_HAVE_ST_BLKSIZE
+#define _IO_BUFSIZ _G_BUFSIZ
+#define _IO_va_list _G_va_list
+
+
+
+
+
+
+
+
+#define __P(protos) protos
+
+
+
+
+
+
+ 
+
+#define _PARAMS(protos) __P(protos)
+
+
+
+
+
+#define _IO_UNIFIED_JUMPTABLES 1
+
+#define _IO_USE_DTOA 1
+
+
+
+#define EOF (-1)
+
+
+
+
+#define NULL (__null)
+
+
+
+
+
+
+
+
+
+#define _IOS_INPUT	1
+#define _IOS_OUTPUT	2
+#define _IOS_ATEND	4
+#define _IOS_APPEND	8
+#define _IOS_TRUNC	16
+#define _IOS_NOCREATE	32
+#define _IOS_NOREPLACE	64
+#define _IOS_BIN	128
+
+ 
+
+
+
+
+
+#define _IO_MAGIC 0xFBAD0000 
+#define _OLD_STDIO_MAGIC 0xFABC0000 
+#define _IO_MAGIC_MASK 0xFFFF0000
+#define _IO_USER_BUF 1 
+#define _IO_UNBUFFERED 2
+#define _IO_NO_READS 4 
+#define _IO_NO_WRITES 8 
+#define _IO_EOF_SEEN 0x10
+#define _IO_ERR_SEEN 0x20
+#define _IO_DELETE_DONT_CLOSE 0x40 
+#define _IO_LINKED 0x80 
+#define _IO_IN_BACKUP 0x100
+#define _IO_LINE_BUF 0x200
+#define _IO_TIED_PUT_GET 0x400 
+#define _IO_CURRENTLY_PUTTING 0x800
+#define _IO_IS_APPENDING 0x1000
+#define _IO_IS_FILEBUF 0x2000
+#define _IO_BAD_SEEN 0x4000
+
+ 
+#define _IO_SKIPWS 01
+#define _IO_LEFT 02
+#define _IO_RIGHT 04
+#define _IO_INTERNAL 010
+#define _IO_DEC 020
+#define _IO_OCT 040
+#define _IO_HEX 0100
+#define _IO_SHOWBASE 0200
+#define _IO_SHOWPOINT 0400
+#define _IO_UPPERCASE 01000
+#define _IO_SHOWPOS 02000
+#define _IO_SCIENTIFIC 04000
+#define _IO_FIXED 010000
+#define _IO_UNITBUF 020000
+#define _IO_STDIO 040000
+#define _IO_DONT_CLOSE 0100000
+#define _IO_BOOLALPHA 0200000
+
+
+struct _IO_jump_t;  struct _IO_FILE;
+
+ 
+
+
+
+
+
+
+
+
+
+    typedef void _IO_lock_t;
+
+
+
+
+
+ 
+
+struct _IO_marker {
+  struct _IO_marker *_next;
+  struct _IO_FILE *_sbuf;
+   
+
+   
+  int _pos;
+
+};
+
+struct _IO_FILE {
+  int _flags;		 
+#define _IO_file_flags _flags
+
+   
+   
+  char* _IO_read_ptr;	 
+  char* _IO_read_end;	 
+  char* _IO_read_base;	 
+  char* _IO_write_base;	 
+  char* _IO_write_ptr;	 
+  char* _IO_write_end;	 
+  char* _IO_buf_base;	 
+  char* _IO_buf_end;	 
+   
+  char *_IO_save_base;  
+  char *_IO_backup_base;   
+  char *_IO_save_end;  
+
+  struct _IO_marker *_markers;
+
+  struct _IO_FILE *_chain;
+
+  int _fileno;
+  int _blksize;
+  _G_off_t  _offset;
+
+#define __HAVE_COLUMN 
+   
+  unsigned short _cur_column;
+  char _unused;
+  char _shortbuf[1];
+
+   
+
+
+
+
+};
+
+
+
+
+
+struct _IO_FILE_plus;
+extern struct _IO_FILE_plus _IO_stdin_, _IO_stdout_, _IO_stderr_;
+#define _IO_stdin ((_IO_FILE*)(&_IO_stdin_))
+#define _IO_stdout ((_IO_FILE*)(&_IO_stdout_))
+#define _IO_stderr ((_IO_FILE*)(&_IO_stderr_))
+
+
+ 
+typedef struct
+{
+  _G_ssize_t  (*read)  (struct _IO_FILE *, void *, _G_ssize_t )  ;
+  _G_ssize_t  (*write)  (struct _IO_FILE *, const void *, _G_ssize_t )  ;
+  _G_fpos_t  (*seek)  (struct _IO_FILE *, _G_off_t , int)  ;
+  int (*close)  (struct _IO_FILE *)  ;
+} _IO_cookie_io_functions_t;
+
+ 
+struct _IO_cookie_file
+{
+  struct _IO_FILE file;
+  const void *vtable;
+  void *cookie;
+  _IO_cookie_io_functions_t io_functions;
+};
+
+
+
+extern "C" {
+
+
+extern int __underflow  (_IO_FILE *)  ;
+extern int __uflow  (_IO_FILE *)  ;
+extern int __overflow  (_IO_FILE *, int)  ;
+
+#define _IO_getc_unlocked(_fp) ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end ? __uflow (_fp) : *(unsigned char *) (_fp)->_IO_read_ptr++)
+
+
+#define _IO_peekc_unlocked(_fp) ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end && __underflow (_fp) == EOF ? EOF : *(unsigned char *) (_fp)->_IO_read_ptr)
+
+
+
+
+#define _IO_putc_unlocked(_ch, _fp) (((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end) ? __overflow (_fp, (unsigned char) (_ch)) : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))
+
+
+
+
+#define _IO_feof_unlocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)
+#define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)
+
+extern int _IO_getc  (_IO_FILE *__fp)  ;
+extern int _IO_putc  (int __c, _IO_FILE *__fp)  ;
+extern int _IO_feof  (_IO_FILE *__fp)  ;
+extern int _IO_ferror  (_IO_FILE *__fp)  ;
+
+extern int _IO_peekc_locked  (_IO_FILE *__fp)  ;
+
+ 
+#define _IO_PENDING_OUTPUT_COUNT(_fp)	((_fp)->_IO_write_ptr - (_fp)->_IO_write_base)
+
+
+extern void _IO_flockfile  (_IO_FILE *)  ;
+extern void _IO_funlockfile  (_IO_FILE *)  ;
+extern int _IO_ftrylockfile  (_IO_FILE *)  ;
+
+
+
+
+#define _IO_peekc(_fp) _IO_peekc_unlocked (_fp)
+#define _IO_flockfile(_fp) 
+#define _IO_funlockfile(_fp) 
+#define _IO_ftrylockfile(_fp) 
+#define _IO_cleanup_region_start(_fct, _fp) 
+#define _IO_cleanup_region_end(_Doit) 
+
+
+
+extern int _IO_vfscanf  (_IO_FILE *, const char *, _G_va_list , int *)  ;
+extern int _IO_vfprintf  (_IO_FILE *, const char *, _G_va_list )  ;
+extern _G_ssize_t  _IO_padn  (_IO_FILE *, int, _G_ssize_t )  ;
+extern _G_size_t  _IO_sgetn  (_IO_FILE *, void *, _G_size_t )  ;
+
+extern _G_fpos_t  _IO_seekoff  (_IO_FILE *, _G_off_t , int, int)  ;
+extern _G_fpos_t  _IO_seekpos  (_IO_FILE *, _G_fpos_t , int)  ;
+
+extern void _IO_free_backup_area  (_IO_FILE *)  ;
+
+
+}
+
+
+
+
+}
+ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#define _IO_wchar_t short
+
+
+extern "C++" {
+class istream;  
+class ostream; class streambuf;
+
+ 
+
+
+
+typedef _G_off_t  streamoff;
+typedef _G_fpos_t  streampos;
+typedef _G_ssize_t  streamsize;
+
+typedef unsigned long __fmtflags;
+typedef unsigned char __iostate;
+
+struct _ios_fields
+{  
+    streambuf *_strbuf;
+    ostream* _tie;
+    int _width;
+    __fmtflags _flags;
+    short  _fill;
+    __iostate _state;
+    __iostate _exceptions;
+    int _precision;
+
+    void *_arrays;  
+};
+
+#define _IOS_GOOD	0
+#define _IOS_EOF	1
+#define _IOS_FAIL	2
+#define _IOS_BAD	4
+
+#define _IO_INPUT	1
+#define _IO_OUTPUT	2
+#define _IO_ATEND	4
+#define _IO_APPEND	8
+#define _IO_TRUNC	16
+#define _IO_NOCREATE	32
+#define _IO_NOREPLACE	64
+#define _IO_BIN		128
+
+
+
+class ios : public _ios_fields {
+  ios& operator=(ios&);   
+  ios (const ios&);  
+  public:
+    typedef __fmtflags fmtflags;
+    typedef int iostate;
+    typedef int openmode;
+    typedef int streamsize;
+    enum io_state {
+	goodbit = 0 ,
+	eofbit = 1 ,
+	failbit = 2 ,
+	badbit = 4  };
+    enum open_mode {
+	in = 1 ,
+	out = 2 ,
+	ate = 4 ,
+	app = 8 ,
+	trunc = 16 ,
+	nocreate = 32 ,
+	noreplace = 64 ,
+	bin = 128 ,  
+	binary = 128  };
+    enum seek_dir { beg, cur, end};
+    typedef enum seek_dir seekdir;
+     
+    enum { skipws= 01 ,
+	   left= 02 , right= 04 , internal= 010 ,
+	   dec= 020 , oct= 040 , hex= 0100 ,
+	   showbase= 0200 , showpoint= 0400 ,
+	   uppercase= 01000 , showpos= 02000 ,
+	   scientific= 04000 , fixed= 010000 ,
+	   unitbuf= 020000 , stdio= 040000 
+
+
+
+	   };
+    enum {  
+	basefield=dec+oct+hex,
+	floatfield = scientific+fixed,
+	adjustfield = left+right+internal
+    };
+
+
+
+    ostream* tie() const { return _tie; }
+    ostream* tie(ostream* val) { ostream* save=_tie; _tie=val; return save; }
+
+     
+    short  fill() const { return (short )_fill; }
+    short  fill(short  newf)
+	{short  oldf = (short )_fill; _fill = (char)newf; return oldf;}
+    fmtflags flags() const { return _flags; }
+    fmtflags flags(fmtflags new_val) {
+	fmtflags old_val = _flags; _flags = new_val; return old_val; }
+    int precision() const { return _precision; }
+    int precision(int newp) {
+	unsigned short oldp = _precision; _precision = (unsigned short)newp;
+	return oldp; }
+    fmtflags setf(fmtflags val) {
+	fmtflags oldbits = _flags;
+	_flags |= val; return oldbits; }
+    fmtflags setf(fmtflags val, fmtflags mask) {
+	fmtflags oldbits = _flags;
+	_flags = (_flags & ~mask) | (val & mask); return oldbits; }
+    fmtflags unsetf(fmtflags mask) {
+	fmtflags oldbits = _flags;
+	_flags &= ~mask; return oldbits; }
+    int width() const { return _width; }
+    int width(int val) { int save = _width; _width = val; return save; }
+
+
+
+
+    void _throw_failure() const { }
+
+    void clear(iostate state = 0) {
+	_state = _strbuf ? state : state|badbit;
+	if (_state & _exceptions) _throw_failure(); }
+    void set(iostate flag) { _state |= flag;
+	if (_state & _exceptions) _throw_failure(); }
+    void setstate(iostate flag) { _state |= flag;  
+	if (_state & _exceptions) _throw_failure(); }
+    int good() const { return _state == 0; }
+    int eof() const { return _state & ios::eofbit; }
+    int fail() const { return _state & (ios::badbit|ios::failbit); }
+    int bad() const { return _state & ios::badbit; }
+    iostate rdstate() const { return _state; }
+    operator void*() const { return fail() ? (void*)0 : (void*)(-1); }
+    int operator!() const { return fail(); }
+    iostate exceptions() const { return _exceptions; }
+    void exceptions(iostate enable) {
+	_exceptions = enable;
+	if (_state & _exceptions) _throw_failure(); }
+
+    streambuf* rdbuf() const { return _strbuf; }
+    streambuf* rdbuf(streambuf *_s) {
+      streambuf *_old = _strbuf; _strbuf = _s; clear (); return _old; }
+
+    static int sync_with_stdio(int on);
+    static void sync_with_stdio() { sync_with_stdio(1); }
+    static fmtflags bitalloc();
+    static int xalloc();
+    void*& pword(int);
+    void* pword(int) const;
+    long& iword(int);
+    long iword(int) const;
+
+
+
+
+
+
+
+
+
+     
+    class Init {
+    public:
+      Init () { }
+    };
+
+  protected:
+    inline ios(streambuf* sb = 0, ostream* tie_to = 0);
+    inline virtual ~ios();
+    inline void init(streambuf* sb, ostream* tie = 0);
+};
+
+
+
+
+typedef ios::seek_dir _seek_dir;
+
+
+ 
+ 
+ 
+ 
+ 
+
+ 
+ 
+class streammarker : private _IO_marker {
+    friend class streambuf;
+    void set_offset(int offset) { _pos = offset; }
+  public:
+    streammarker(streambuf *sb);
+    ~streammarker();
+    int saving() { return  1; }
+    int delta(streammarker&);
+    int delta();
+};
+
+struct streambuf : public _IO_FILE {  
+    friend class ios;
+    friend class istream;
+    friend class ostream;
+    friend class streammarker;
+    const void *&_vtable() { return *(const void**)((_IO_FILE*)this + 1); }
+  protected:
+    static streambuf* _list_all;  
+    _IO_FILE*& xchain() { return _chain; }
+    void _un_link();
+    void _link_in();
+    char* gptr() const
+      { return _flags  & 0x100  ? _IO_save_base : _IO_read_ptr; }
+    char* pptr() const { return _IO_write_ptr; }
+    char* egptr() const
+      { return _flags  & 0x100  ? _IO_save_end : _IO_read_end; }
+    char* epptr() const { return _IO_write_end; }
+    char* pbase() const { return _IO_write_base; }
+    char* eback() const
+      { return _flags  & 0x100  ? _IO_save_base : _IO_read_base;}
+    char* base() const { return _IO_buf_base; }
+    char* ebuf() const { return _IO_buf_end; }
+    int blen() const { return _IO_buf_end - _IO_buf_base; }
+    void xput_char(char c) { *_IO_write_ptr++ = c; }
+    int xflags() { return _flags ; }
+    int xflags(int f) {int fl = _flags ; _flags  = f; return fl;}
+    void xsetflags(int f) { _flags  |= f; }
+    void xsetflags(int f, int mask)
+      { _flags  = (_flags  & ~mask) | (f & mask); }
+    void gbump(int n)
+      { _flags  & 0x100  ? (_IO_save_base+=n):(_IO_read_ptr+=n);}
+    void pbump(int n) { _IO_write_ptr += n; }
+    void setb(char* b, char* eb, int a=0);
+    void setp(char* p, char* ep)
+      { _IO_write_base=_IO_write_ptr=p; _IO_write_end=ep; }
+    void setg(char* eb, char* g, char *eg) {
+      if (_flags  & 0x100 ) _IO_free_backup_area(this); 
+      _IO_read_base = eb; _IO_read_ptr = g; _IO_read_end = eg; }
+    char *shortbuf() { return _shortbuf; }
+
+    int in_backup() { return _flags & 0x100 ; }
+     
+    char *Gbase() { return in_backup() ? _IO_save_base : _IO_read_base; }
+     
+    char *eGptr() { return in_backup() ? _IO_save_end : _IO_read_end; }
+     
+    char *Bbase() { return in_backup() ? _IO_read_base : _IO_save_base; }
+    char *Bptr() { return _IO_backup_base; }
+     
+    char *eBptr() { return in_backup() ? _IO_read_end : _IO_save_end; }
+    char *Nbase() { return _IO_save_base; }
+    char *eNptr() { return _IO_save_end; }
+    int have_backup() { return _IO_save_base != (__null) ; }
+    int have_markers() { return _markers != (__null) ; }
+    void free_backup_area();
+    void unsave_markers();  
+    int put_mode() { return _flags & 0x800 ; }
+    int switch_to_get_mode();
+    
+    streambuf(int flags=0);
+  public:
+    static int flush_all();
+    static void flush_all_linebuffered();  
+    virtual ~streambuf();
+    virtual int overflow(int c = (-1) );  
+    virtual int underflow();  
+    virtual int uflow();  
+    virtual int pbackfail(int c);
+ 
+    virtual streamsize xsputn(const char* s, streamsize n);
+    virtual streamsize xsgetn(char* s, streamsize n);
+    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
+    virtual streampos seekpos(streampos pos, int mode = ios::in|ios::out);
+
+    streampos pubseekoff(streamoff o, _seek_dir d, int mode=ios::in|ios::out)
+      { return _IO_seekoff (this, o, d, mode); }
+    streampos pubseekpos(streampos pos, int mode = ios::in|ios::out)
+      { return _IO_seekpos (this, pos, mode); }
+    streampos sseekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
+    streampos sseekpos(streampos pos, int mode = ios::in|ios::out);
+    virtual streambuf* setbuf(char* p, int len);
+    virtual int sync();
+    virtual int doallocate();
+
+    int seekmark(streammarker& mark, int delta = 0);
+    int sputbackc(char c);
+    int sungetc();
+    int unbuffered() { return _flags & 2  ? 1 : 0; }
+    int linebuffered() { return _flags & 0x200  ? 1 : 0; }
+    void unbuffered(int i)
+	{ if (i) _flags |= 2 ; else _flags &= ~2 ; }
+    void linebuffered(int i)
+	{ if (i) _flags |= 0x200 ; else _flags &= ~0x200 ; }
+    int allocate() {  
+	if (base() || unbuffered()) return 0;
+	else return doallocate(); }
+     
+    void allocbuf() { if (base() == (__null) ) doallocbuf(); }
+    void doallocbuf();
+    int in_avail() { return _IO_read_end - _IO_read_ptr; }
+    int out_waiting() { return _IO_write_ptr - _IO_write_base; }
+    streamsize sputn(const char* s, streamsize n) { return xsputn(s, n); }
+    streamsize padn(char pad, streamsize n) { return _IO_padn(this, pad, n); }
+    streamsize sgetn(char* s, streamsize n) { return _IO_sgetn(this, s, n); }
+    int ignore(int);
+    int get_column();
+    int set_column(int);
+    long sgetline(char* buf, _G_size_t  n, char delim, int putback_delim);
+    int sputc(int c) { return _IO_putc(c, this); }
+    int sbumpc() { return _IO_getc(this); }
+    int sgetc() { return ((  this  )->_IO_read_ptr >= (  this  )->_IO_read_end && __underflow (  this  ) == (-1)  ? (-1)  : *(unsigned char *) (  this  )->_IO_read_ptr)  ; }
+    int snextc() {
+	if (_IO_read_ptr >= _IO_read_end && __underflow(this) == (-1) )
+	  return (-1) ;
+	else return _IO_read_ptr++, sgetc(); }
+    void stossc() { if (_IO_read_ptr < _IO_read_end) _IO_read_ptr++; }
+    int vscan(char const *fmt0, _G_va_list  ap, ios* stream = (__null) );
+    int scan(char const *fmt0 ...);
+    int vform(char const *fmt0, _G_va_list  ap);
+    int form(char const *fmt0 ...);
+
+
+
+
+    virtual streamsize sys_read(char* buf, streamsize size);
+    virtual streamsize sys_write(const char*, streamsize);
+    virtual streampos sys_seek(streamoff, _seek_dir);
+    virtual int sys_close();
+    virtual int sys_stat(void*);  
+};
+
+ 
+ 
+
+class filebuf : public streambuf {
+  protected:
+    void init();
+  public:
+    static const int openprot;  
+    filebuf();
+    filebuf(int fd);
+    filebuf(int fd, char* p, int len);
+
+
+
+    ~filebuf();
+    filebuf* attach(int fd);
+    filebuf* open(const char *filename, const char *mode);
+    filebuf* open(const char *filename, ios::openmode mode, int prot = 0664);
+    virtual int underflow();
+    virtual int overflow(int c = (-1) );
+    int is_open() const { return _fileno >= 0; }
+    int fd() const { return is_open() ? _fileno : (-1) ; }
+    filebuf* close();
+    virtual int doallocate();
+    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
+    virtual streambuf* setbuf(char* p, int len);
+    streamsize xsputn(const char* s, streamsize n);
+    streamsize xsgetn(char* s, streamsize n);
+    virtual int sync();
+  protected:  
+ 
+    int is_reading() { return eback() != egptr(); }
+    char* cur_ptr() { return is_reading() ?  gptr() : pptr(); }
+     
+    char* file_ptr() { return eGptr(); }
+     
+    virtual streamsize sys_read(char* buf, streamsize size);
+    virtual streampos sys_seek(streamoff, _seek_dir);
+    virtual streamsize sys_write(const char*, streamsize);
+    virtual int sys_stat(void*);  
+    virtual int sys_close();
+
+
+
+
+};
+
+inline void ios::init(streambuf* sb, ostream* tie_to) {
+		_state = sb ? ios::goodbit : ios::badbit; _exceptions=0;
+		_strbuf=sb; _tie = tie_to; _width=0; _fill=' ';
+
+		_flags=ios::skipws|ios::dec;
+
+
+
+		_precision=6; _arrays = 0; }
+
+inline ios::ios(streambuf* sb, ostream* tie_to) { init(sb, tie_to); }
+
+inline ios::~ios() {
+
+
+
+    operator delete(_arrays);
+}
+}  
+
+
+
+extern "C++" {
+class istream; class ostream;
+typedef ios& (*__manip)(ios&);
+typedef istream& (*__imanip)(istream&);
+typedef ostream& (*__omanip)(ostream&);
+
+extern istream& ws(istream& ins);
+extern ostream& flush(ostream& outs);
+extern ostream& endl(ostream& outs);
+extern ostream& ends(ostream& outs);
+
+class ostream : virtual public ios
+{
+     
+    void do_osfx();
+  public:
+    ostream() { }
+    ostream(streambuf* sb, ostream* tied= (__null) );
+    int opfx() {
+	if (!good()) return 0;
+	else { if (_tie) _tie->flush();  ; return 1;} }
+    void osfx() {  ;
+		  if (flags() & (ios::unitbuf|ios::stdio))
+		      do_osfx(); }
+    ostream& flush();
+    ostream& put(char c) { _strbuf->sputc(c); return *this; }
+
+
+
+
+
+    ostream& write(const char *s, streamsize n);
+    ostream& write(const unsigned char *s, streamsize n)
+      { return write((const char*)s, n);}
+    ostream& write(const signed char *s, streamsize n)
+      { return write((const char*)s, n);}
+    ostream& write(const void *s, streamsize n)
+      { return write((const char*)s, n);}
+    ostream& seekp(streampos);
+    ostream& seekp(streamoff, _seek_dir);
+    streampos tellp();
+    ostream& form(const char *format ...);
+    ostream& vform(const char *format, _G_va_list  args);
+
+    ostream& operator<<(char c);
+    ostream& operator<<(unsigned char c) { return (*this) << (char)c; }
+    ostream& operator<<(signed char c) { return (*this) << (char)c; }
+    ostream& operator<<(const char *s);
+    ostream& operator<<(const unsigned char *s)
+	{ return (*this) << (const char*)s; }
+    ostream& operator<<(const signed char *s)
+	{ return (*this) << (const char*)s; }
+    ostream& operator<<(const void *p);
+    ostream& operator<<(int n);
+    ostream& operator<<(unsigned int n);
+    ostream& operator<<(long n);
+    ostream& operator<<(unsigned long n);
+
+    __extension__ ostream& operator<<(long long n);
+    __extension__ ostream& operator<<(unsigned long long n);
+
+    ostream& operator<<(short n) {return operator<<((int)n);}
+    ostream& operator<<(unsigned short n) {return operator<<((unsigned int)n);}
+
+    ostream& operator<<(bool b) { return operator<<((int)b); }
+
+    ostream& operator<<(double n);
+    ostream& operator<<(float n) { return operator<<((double)n); }
+
+
+
+    ostream& operator<<(long double n) { return operator<<((double)n); }
+
+    ostream& operator<<(__omanip func) { return (*func)(*this); }
+    ostream& operator<<(__manip func) {(*func)(*this); return *this;}
+    ostream& operator<<(streambuf*);
+
+
+
+};
+
+class istream : virtual public ios
+{
+     
+protected:
+    _G_size_t  _gcount;
+
+    int _skip_ws();
+  public:
+    istream(): _gcount (0) { }
+    istream(streambuf* sb, ostream*tied= (__null) );
+    istream& get(char* ptr, int len, char delim = '\n');
+    istream& get(unsigned char* ptr, int len, char delim = '\n')
+	{ return get((char*)ptr, len, delim); }
+    istream& get(char& c);
+    istream& get(unsigned char& c) { return get((char&)c); }
+    istream& getline(char* ptr, int len, char delim = '\n');
+    istream& getline(unsigned char* ptr, int len, char delim = '\n')
+	{ return getline((char*)ptr, len, delim); }
+    istream& get(signed char& c)  { return get((char&)c); }
+    istream& get(signed char* ptr, int len, char delim = '\n')
+	{ return get((char*)ptr, len, delim); }
+    istream& getline(signed char* ptr, int len, char delim = '\n')
+	{ return getline((char*)ptr, len, delim); }
+    istream& read(char *ptr, streamsize n);
+    istream& read(unsigned char *ptr, streamsize n)
+      { return read((char*)ptr, n); }
+    istream& read(signed char *ptr, streamsize n)
+      { return read((char*)ptr, n); }
+    istream& read(void *ptr, streamsize n)
+      { return read((char*)ptr, n); }
+    istream& get(streambuf& sb, char delim = '\n');
+    istream& gets(char **s, char delim = '\n');
+    int ipfx(int need = 0) {
+	if (!good()) { set(ios::failbit); return 0; }
+	else {
+	   ;
+	  if (_tie && (need == 0 || rdbuf()->in_avail() < need)) _tie->flush();
+	  if (!need && (flags() & ios::skipws)) return _skip_ws();
+	  else return 1;
+	}
+    }
+    int ipfx0() {  
+	if (!good()) { set(ios::failbit); return 0; }
+	else {
+	   ;
+	  if (_tie) _tie->flush();
+	  if (flags() & ios::skipws) return _skip_ws();
+	  else return 1;
+	}
+    }
+    int ipfx1() {  
+	if (!good()) { set(ios::failbit); return 0; }
+	else {
+	   ;
+	  if (_tie && rdbuf()->in_avail() == 0) _tie->flush();
+	  return 1;
+	}
+    }
+    void isfx() {  ; }
+    int get() { if (!ipfx1()) return (-1) ;
+		else { int ch = _strbuf->sbumpc();
+		       if (ch == (-1) ) set(ios::eofbit);
+		       return ch;
+		     } }
+    int peek();
+    _G_size_t  gcount() { return _gcount; }
+    istream& ignore(int n=1, int delim = (-1) );
+    int sync ();
+    istream& seekg(streampos);
+    istream& seekg(streamoff, _seek_dir);
+    streampos tellg();
+    istream& putback(char ch) {
+	if (good() && _strbuf->sputbackc(ch) == (-1) ) clear(ios::badbit);
+	return *this;}
+    istream& unget() {
+	if (good() && _strbuf->sungetc() == (-1) ) clear(ios::badbit);
+	return *this;}
+    istream& scan(const char *format ...);
+    istream& vscan(const char *format, _G_va_list  args);
+
+
+
+
+
+
+    istream& operator>>(char*);
+    istream& operator>>(unsigned char* p) { return operator>>((char*)p); }
+    istream& operator>>(signed char*p) { return operator>>((char*)p); }
+    istream& operator>>(char& c);
+    istream& operator>>(unsigned char& c) {return operator>>((char&)c);}
+    istream& operator>>(signed char& c) {return operator>>((char&)c);}
+    istream& operator>>(int&);
+    istream& operator>>(long&);
+
+    __extension__ istream& operator>>(long long&);
+    __extension__ istream& operator>>(unsigned long long&);
+
+    istream& operator>>(short&);
+    istream& operator>>(unsigned int&);
+    istream& operator>>(unsigned long&);
+    istream& operator>>(unsigned short&);
+
+    istream& operator>>(bool&);
+
+    istream& operator>>(float&);
+    istream& operator>>(double&);
+    istream& operator>>(long double&);
+    istream& operator>>( __manip func) {(*func)(*this); return *this;}
+    istream& operator>>(__imanip func) { return (*func)(*this); }
+    istream& operator>>(streambuf*);
+};
+
+class iostream : public istream, public ostream
+{
+  public:
+    iostream() { }
+    iostream(streambuf* sb, ostream*tied= (__null) );
+};
+
+class _IO_istream_withassign : public istream {
+public:
+  _IO_istream_withassign& operator=(istream&);
+  _IO_istream_withassign& operator=(_IO_istream_withassign& rhs)
+    { return operator= (static_cast<istream&> (rhs)); }
+};
+
+class _IO_ostream_withassign : public ostream {
+public:
+  _IO_ostream_withassign& operator=(ostream&);
+  _IO_ostream_withassign& operator=(_IO_ostream_withassign& rhs)
+    { return operator= (static_cast<ostream&> (rhs)); }
+};
+
+extern _IO_istream_withassign cin;
+ 
+extern _IO_ostream_withassign cout, cerr;
+
+extern _IO_ostream_withassign clog
+
+
+
+;
+
+extern istream& lock(istream& ins);
+extern istream& unlock(istream& ins);
+extern ostream& lock(ostream& outs);
+extern ostream& unlock(ostream& outs);
+
+struct Iostream_init { } ;   
+
+inline ios& dec(ios& i)
+{ i.setf(ios::dec, ios::dec|ios::hex|ios::oct); return i; }
+inline ios& hex(ios& i)
+{ i.setf(ios::hex, ios::dec|ios::hex|ios::oct); return i; }
+inline ios& oct(ios& i)
+{ i.setf(ios::oct, ios::dec|ios::hex|ios::oct); return i; }
+}  
+
+
+
+ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#pragma interface
+
+#define _IOMANIP_H
+
+
+
+extern "C++" {
+ 
+ 
+ 
+
+ 
+ 
+ 
+ 
+template<class TP> class smanip;  
+
+template<class TP> class sapp {
+    ios& (*_f)(ios&, TP);
+public: 
+    sapp(ios& (*f)(ios&, TP)) : _f(f) {}
+     
+    smanip<TP> operator()(TP a) 
+      { return smanip<TP>(_f, a); }
+};
+
+template<class TP>
+inline istream& operator>>(istream& i, const smanip<TP>& m);
+template<class TP>
+inline ostream& operator<<(ostream& o, const smanip<TP>& m);
+
+template <class TP> class smanip {
+    ios& (*_f)(ios&, TP);
+    TP _a;
+public:
+    smanip(ios& (*f)(ios&, TP), TP a) : _f(f), _a(a) {}
+     
+    friend 
+      istream& operator>> <>(istream& i, const smanip<TP>& m);
+    friend
+      ostream& operator<< <>(ostream& o, const smanip<TP>& m);
+};
+
+
+extern template class smanip<int>;
+extern template class smanip<ios::fmtflags>;
+
+
+template<class TP>
+inline istream& operator>>(istream& i, const smanip<TP>& m)
+{ (*m._f)(i, m._a); return i; }
+
+template<class TP>
+inline ostream& operator<<(ostream& o, const smanip<TP>& m)
+{ (*m._f)(o, m._a); return o;}
+
+
+extern template istream& operator>>(istream&, const smanip<int>&);
+extern template istream& operator>>(istream&, const smanip<ios::fmtflags>&);
+extern template ostream& operator<<(ostream&, const smanip<int>&);
+extern template ostream& operator<<(ostream&, const smanip<ios::fmtflags>&);
+
+
+ 
+ 
+ 
+ 
+template<class TP> class imanip; 
+
+template<class TP> class iapp {
+    istream& (*_f)(istream&, TP);
+public: 
+    iapp(istream& (*f)(istream&,TP)) : _f(f) {}
+     
+    imanip<TP> operator()(TP a)
+       { return imanip<TP>(_f, a); }
+};
+
+template <class TP>
+inline istream& operator>>(istream&, const imanip<TP>&);
+
+template <class TP> class imanip {
+    istream& (*_f)(istream&, TP);
+    TP _a;
+public:
+    imanip(istream& (*f)(istream&, TP), TP a) : _f(f), _a(a) {}
+     
+    friend
+      istream& operator>> <>(istream& i, const imanip<TP>& m);
+};
+
+template <class TP>
+inline istream& operator>>(istream& i, const imanip<TP>& m)
+{ return (*m._f)( i, m._a); }
+
+ 
+ 
+ 
+ 
+template<class TP> class omanip; 
+
+template<class TP> class oapp {
+    ostream& (*_f)(ostream&, TP);
+public: 
+    oapp(ostream& (*f)(ostream&,TP)) : _f(f) {}
+     
+    omanip<TP> operator()(TP a)
+      { return omanip<TP>(_f, a); }
+};
+
+template <class TP>
+inline ostream& operator<<(ostream&, const omanip<TP>&);
+
+template <class TP> class omanip {
+    ostream& (*_f)(ostream&, TP);
+    TP _a;
+public:
+    omanip(ostream& (*f)(ostream&, TP), TP a) : _f(f), _a(a) {}
+     
+    friend
+      ostream& operator<< <>(ostream& o, const omanip<TP>& m);
+};
+
+template <class TP>
+inline ostream& operator<<(ostream& o, const omanip<TP>& m)
+{ return (*m._f)(o, m._a); }
+
+ 
+ 
+ 
+
+ 
+ 
+ 
+ 
+#define __DEFINE_IOMANIP_FN1(type,param,function) extern ios& __iomanip_##function (ios&, param); inline type<param> function (param n) { return type<param> (__iomanip_##function, n); }
+
+
+
+
+extern ios& __iomanip_setbase  (ios&,   int ); inline   smanip <  int >   setbase  (  int  n) { return   smanip <  int > (__iomanip_setbase , n); } 
+extern ios& __iomanip_setfill  (ios&,   int ); inline   smanip <  int >   setfill  (  int  n) { return   smanip <  int > (__iomanip_setfill , n); } 
+extern ios& __iomanip_setprecision  (ios&,   int ); inline   smanip <  int >   setprecision  (  int  n) { return   smanip <  int > (__iomanip_setprecision , n); } 
+extern ios& __iomanip_setw  (ios&,   int ); inline   smanip <  int >   setw  (  int  n) { return   smanip <  int > (__iomanip_setw , n); } 
+
+extern ios& __iomanip_resetiosflags  (ios&,   ios::fmtflags ); inline   smanip <  ios::fmtflags >   resetiosflags  (  ios::fmtflags  n) { return   smanip <  ios::fmtflags > (__iomanip_resetiosflags , n); } 
+extern ios& __iomanip_setiosflags  (ios&,   ios::fmtflags ); inline   smanip <  ios::fmtflags >   setiosflags  (  ios::fmtflags  n) { return   smanip <  ios::fmtflags > (__iomanip_setiosflags , n); } 
+}  
+
+
+
+
+#define LS_hh
+
+
+#define Mouvement_hh
+
+
+
+#define usuel_hh
+
+ 
+
+
+
+
+#define 	_MATH_H
+
+
+extern "C" {
+
+
+#pragma ident	"@(#)math.h	2.5	95/02/07"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+ 
+
+
+typedef union _h_val {
+  	unsigned long _i[2];
+	double _d;
+} _h_val;
+
+
+extern const _h_val __huge_val;
+
+
+
+
+
+#define 	HUGE_VAL __huge_val._d
+
+
+
+
+ 
+
+
+#define 	M_E		2.7182818284590452354
+#define 	M_LOG2E		1.4426950408889634074
+#define 	M_LOG10E	0.43429448190325182765
+#define 	M_LN2		0.69314718055994530942
+#define 	M_LN10		2.30258509299404568402
+#define 	M_PI		3.14159265358979323846
+#define 	M_PI_2		1.57079632679489661923
+#define 	M_PI_4		0.78539816339744830962
+#define 	M_1_PI		0.31830988618379067154
+#define 	M_2_PI		0.63661977236758134308
+#define 	M_2_SQRTPI	1.12837916709551257390
+#define 	M_SQRT2		1.41421356237309504880
+#define 	M_SQRT1_2	0.70710678118654752440
+
+extern int signgam;
+
+#define 	MAXFLOAT	((float)3.40282346638528860e+38)
+
+
+ 
+
+
+enum version {libm_ieee = -1, c_issue_4, ansi_1, strict_ansi};
+
+
+extern const enum version _lib_version;
+
+
+
+
+
+#define exception __math_exception
+
+struct __math_exception  {
+
+#undef exception
+
+	int type;
+	char *name;
+	double arg1;
+	double arg2;
+	double retval;
+};
+
+#define 	HUGE		MAXFLOAT
+
+#define 	_ABS(x)		((x) < 0 ? -(x) : (x))
+
+#define 	_REDUCE(TYPE, X, XN, C1, C2)	{ double x1 = (double)(TYPE)X, x2 = X - x1; X = x1 - (XN) * (C1); X += x2; X -= (XN) * (C2); }
+
+
+
+#define 	DOMAIN		1
+#define 	SING		2
+#define 	OVERFLOW	3
+#define 	UNDERFLOW	4
+#define 	TLOSS		5
+#define 	PLOSS		6
+
+#define 	_POLY1(x, c)	((c)[0] * (x) + (c)[1])
+#define 	_POLY2(x, c)	(_POLY1((x), (c)) * (x) + (c)[2])
+#define 	_POLY3(x, c)	(_POLY2((x), (c)) * (x) + (c)[3])
+#define 	_POLY4(x, c)	(_POLY3((x), (c)) * (x) + (c)[4])
+#define 	_POLY5(x, c)	(_POLY4((x), (c)) * (x) + (c)[5])
+#define 	_POLY6(x, c)	(_POLY5((x), (c)) * (x) + (c)[6])
+#define 	_POLY7(x, c)	(_POLY6((x), (c)) * (x) + (c)[7])
+#define 	_POLY8(x, c)	(_POLY7((x), (c)) * (x) + (c)[8])
+#define 	_POLY9(x, c)	(_POLY8((x), (c)) * (x) + (c)[9])
+
+
+
+ 
+
+
+extern double acos  (double)  ;
+extern double asin  (double)  ;
+extern double atan  (double)  ;
+extern double atan2  (double, double)  ;
+extern double cos  (double)  ;
+extern double sin  (double)  ;
+extern double tan  (double)  ;
+
+extern double cosh  (double)  ;
+extern double sinh  (double)  ;
+extern double tanh  (double)  ;
+
+extern double exp  (double)  ;
+extern double frexp  (double, int *)  ;
+extern double ldexp  (double, int)  ;
+extern double log  (double)  ;
+extern double log10  (double)  ;
+extern double modf  (double, double *)  ;
+
+extern double pow  (double, double)  ;
+extern double sqrt  (double)  ;
+
+extern double ceil  (double)  ;
+extern double fabs  (double)  ;
+extern double floor  (double)  ;
+extern double fmod  (double, double)  ;
+
+
+
+ 
+
+
+extern double erf  (double)  ;
+extern double erfc  (double)  ;
+extern double gamma  (double)  ;
+extern double hypot  (double, double)  ;
+extern int isnan  (double)  ;
+extern double j0  (double)  ;
+extern double j1  (double)  ;
+extern double jn  (int, double)  ;
+extern double lgamma  (double)  ;
+extern double y0  (double)  ;
+extern double y1  (double)  ;
+extern double yn  (int, double)  ;
+
+
+
+ 
+
+
+extern double acosh  (double)  ;
+extern double asinh  (double)  ;
+extern double atanh  (double)  ;
+extern double cbrt  (double)  ;
+extern double logb  (double)  ;
+extern double nextafter  (double, double)  ;
+extern double remainder  (double, double)  ;
+extern double scalb  (double, double)  ;
+
+ 
+
+
+extern double expm1  (double)  ;
+extern int ilogb  (double)  ;
+extern double log1p  (double)  ;
+extern double rint  (double)  ;
+
+
+
+ 
+
+
+
+#define exception __math_exception
+
+extern int matherr  (struct __math_exception  *)  ;
+
+#undef exception
+
+
+ 
+
+
+extern double significand  (double)  ;
+
+ 
+
+
+extern double copysign  (double, double)  ;
+extern double scalbn  (double, int)  ;
+
+ 
+
+
+
+
+
+
+
+
+ 
+
+
+extern float modff  (float, float *)  ;
+
+ 
+ 
+
+ 
+ 
+ 
+
+
+#define _FLOATINGPOINT_H
+
+
+extern "C" {
+
+
+#pragma ident	"@(#)floatingpoint.h	2.4 94/06/09"
+
+ 
+
+
+
+
+ 
+
+
+
+
+
+
+
+
+
+
+ 
+ 
+
+ 
+ 
+ 
+
+ 
+
+
+
+
+#define 	_STDIO_H
+
+#pragma ident	"@(#)stdio.h	1.39	95/12/04 SMI"	
+
+ 
+ 
+
+ 
+ 
+ 
+
+
+#define 	_SYS_FEATURE_TESTS_H
+
+#pragma ident	"@(#)feature_tests.h	1.7	94/12/06 SMI"
+
+
+extern "C" {
+
+
+ 
+
+
+
+
+
+
+
+
+
+
+
+
+}
+
+
+
+
+ 
+
+
+
+
+
+#define 	_SYS_VA_LIST_H
+
+#pragma ident	"@(#)va_list.h	1.6	96/01/26 SMI"
+
+ 
+
+
+
+
+
+
+
+
+
+
+extern "C" {
+
+
+
+
+
+typedef void *__va_list;
+
+
+
+
+
+
+
+}
+
+
+
+
+
+
+extern "C" {
+
+
+
+#define 	_SIZE_T
+typedef unsigned int	size_t;
+
+
+typedef long	fpos_t;
+
+
+
+
+
+
+
+
+
+
+#define 	BUFSIZ	1024
+
+ 
+
+
+
+
+
+
+
+
+
+
+ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#define 	_NFILE	20	
+
+
+
+#define 	_SBFSIZ	8	
+
+#define 	_IOFBF		0000	
+#define 	_IOLBF		0100	
+#define 	_IONBF		0004	
+#define 	_IOEOF		0020	
+#define 	_IOERR		0040	
+
+#define 	_IOREAD		0001	
+#define 	_IOWRT		0002	
+#define 	_IORW		0200	
+#define 	_IOMYBUF	0010	
+
+
+
+
+
+#define 	FOPEN_MAX	_NFILE
+#define 	FILENAME_MAX    1024	
+
+#define 	SEEK_SET	0
+#define 	SEEK_CUR	1
+#define 	SEEK_END	2
+#define 	TMP_MAX		17576	
+
+
+
+
+#define 	L_ctermid	9
+#define 	L_cuserid	9
+
+
+
+
+
+#define 	P_tmpdir	"/var/tmp/"
+
+
+#define 	L_tmpnam	25	
+
+
+#define 	stdin	(&__iob[0])
+#define 	stdout	(&__iob[1])
+#define 	stderr	(&__iob[2])
+
+
+
+
+
+
+typedef struct	 
+{
+
+
+
+
+	int		_cnt;	 
+	unsigned char	*_ptr;	 
+
+	unsigned char	*_base;	 
+	unsigned char	_flag;	 
+	unsigned char	_file;	 
+} FILE;
+
+
+extern FILE		__iob[20 ];
+
+
+
+extern FILE		*_lastbuf;
+extern unsigned char	*_bufendtab[];
+
+extern unsigned char	 _sibuf[], _sobuf[];
+
+
+
+
+extern int	remove(const char *);
+extern int	rename(const char *, const char *);
+extern FILE	*tmpfile(void);
+extern char	*tmpnam(char *);
+
+
+
+extern int	fclose(FILE *);
+extern int	fflush(FILE *);
+extern FILE	*fopen(const char *, const char *);
+extern FILE	*freopen(const char *, const char *, FILE *);
+extern void	setbuf(FILE *, char *);
+extern int	setvbuf(FILE *, char *, int, size_t);
+ 
+extern int	fprintf(FILE *, const char *, ...);
+ 
+extern int	fscanf(FILE *, const char *, ...);
+ 
+extern int	printf(const char *, ...);
+ 
+extern int	scanf(const char *, ...);
+ 
+extern int	sprintf(char *, const char *, ...);
+ 
+extern int	sscanf(const char *, const char *, ...);
+extern int	vfprintf(FILE *, const char *, __va_list);
+extern int	vprintf(const char *, __va_list);
+extern int	vsprintf(char *, const char *, __va_list);
+extern int	fgetc(FILE *);
+extern char	*fgets(char *, int, FILE *);
+extern int	fputc(int, FILE *);
+extern int	fputs(const char *, FILE *);
+extern int	getc(FILE *);
+extern int	getchar(void);
+extern char	*gets(char *);
+extern int	putc(int, FILE *);
+extern int	putchar(int);
+extern int	puts(const char *);
+extern int	ungetc(int, FILE *);
+extern size_t	fread(void *, size_t, size_t, FILE *);
+extern size_t	fwrite(const void *, size_t, size_t, FILE *);
+extern int	fgetpos(FILE *, fpos_t *);
+extern int	fseek(FILE *, long, int);
+extern int	fsetpos(FILE *, const fpos_t *);
+extern long	ftell(FILE *);
+extern void	rewind(FILE *);
+extern void	clearerr(FILE *);
+extern int	feof(FILE *);
+extern int	ferror(FILE *);
+extern void	perror(const char *);
+
+extern int	__filbuf(FILE *);
+extern int	__flsbuf(int, FILE *);
+
+ 
+
+
+
+
+
+extern FILE	*fdopen(int, const char *);
+extern char	*ctermid(char *);
+extern int	fileno(FILE *);
+
+
+
+ 
+
+
+
+
+ 
+
+
+
+
+extern FILE	*popen(const char *, const char *);
+extern char	*cuserid(char *);
+extern char	*tempnam(const char *, const char *);
+extern int	getopt(int, char *const *, const char *);
+
+extern int	getsubopt(char **, char *const *, char **);
+
+extern char	*optarg;
+extern int	optind, opterr, optopt;
+extern int	getw(FILE *);
+extern int	putw(int, FILE *);
+extern int	pclose(FILE *);
+
+
+
+
+
+ 
+
+
+
+
+
+
+
+
+
+
+
+#define 	getc(p)		(--(p)->_cnt < 0 ? __filbuf(p) : (int)*(p)->_ptr++)
+#define 	putc(x, p)	(--(p)->_cnt < 0 ? __flsbuf((unsigned char) (x), (p)) : (int)(*(p)->_ptr++ = (x)))
+
+
+
+
+
+
+
+#define 	getchar()	getc(stdin)
+#define 	putchar(x)	putc((x), stdout)
+#define 	clearerr(p)	((void)((p)->_flag &= ~(_IOERR | _IOEOF)))
+#define 	feof(p)		((p)->_flag & _IOEOF)
+#define 	ferror(p)	((p)->_flag & _IOERR)
+
+
+
+
+#define 	fileno(p)	((p)->_file)
+
+
+
+
+
+
+
+}
+
+
+
+
+
+ 
+
+
+
+
+#define _SYS_IEEEFP_H
+
+#pragma ident	"@(#)ieeefp.h	2.7 94/11/09"
+
+
+extern "C" {
+
+
+ 
+
+
+
+enum fp_direction_type {	 
+	fp_nearest	= 0,
+	fp_tozero	= 1,
+	fp_positive	= 2,
+	fp_negative	= 3
+};
+
+enum fp_precision_type {	 
+	fp_extended	= 0,
+	fp_single	= 1,
+	fp_double	= 2,
+	fp_precision_3	= 3
+};
+
+enum fp_exception_type {	 
+	fp_inexact	= 0,
+	fp_division	= 1,
+	fp_underflow	= 2,
+	fp_overflow	= 3,
+	fp_invalid	= 4
+};
+
+enum fp_trap_enable_type {	 
+	fp_trap_inexact	= 0,
+	fp_trap_division	= 1,
+	fp_trap_underflow	= 2,
+	fp_trap_overflow	= 3,
+	fp_trap_invalid	= 4
+};
+
+
+
+
+
+
+enum fp_class_type {		 
+	fp_zero		= 0,
+	fp_subnormal	= 1,
+	fp_normal	= 2,
+	fp_infinity   	= 3,
+	fp_quiet	= 4,
+	fp_signaling	= 5
+};
+
+
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#define N_IEEE_EXCEPTION 5	
+
+typedef int sigfpe_code_type;	 
+
+typedef void (*sigfpe_handler_type)();	 
+
+#define SIGFPE_DEFAULT (void (*)())0	
+#define SIGFPE_IGNORE  (void (*)())1  	
+#define SIGFPE_ABORT   (void (*)())2  	
+
+extern sigfpe_handler_type sigfpe  (sigfpe_code_type, sigfpe_handler_type)  ;
+
+ 
+
+
+typedef float single;			
+
+
+#define _EXTENDED
+typedef unsigned extended[3];
+
+
+typedef long double quadruple;	 
+
+typedef unsigned fp_exception_field_type;
+				 
+
+
+
+ 
+
+
+#define DECIMAL_STRING_LENGTH 512	
+
+typedef char decimal_string[512 ];	
+				 
+
+typedef struct {
+	enum fp_class_type fpclass;
+	int	sign;
+	int	exponent;
+	decimal_string ds;	 
+
+
+	int	more;		 
+
+
+	int 	ndigits;	 
+
+
+} decimal_record;
+
+enum decimal_form {
+	fixed_form,		 
+
+
+	floating_form		 
+
+};
+
+typedef struct {
+	enum fp_direction_type rd;	
+				 
+	enum decimal_form df;	 
+
+	int ndigits;		 
+} decimal_mode;
+
+enum decimal_string_form {	 
+	invalid_form,		 
+	whitespace_form,	 
+	fixed_int_form,		 
+	fixed_intdot_form,	 
+	fixed_dotfrac_form,	 
+	fixed_intdotfrac_form,	 
+	floating_int_form,	 	
+	floating_intdot_form,	 
+	floating_dotfrac_form,	 
+	floating_intdotfrac_form, 
+	inf_form,		 
+	infinity_form,		 
+	nan_form,		 
+	nanstring_form		 
+};
+
+extern void single_to_decimal  (single *, decimal_mode *, decimal_record *,
+				fp_exception_field_type *)  ;
+extern void double_to_decimal  (double *, decimal_mode *, decimal_record *,
+				fp_exception_field_type *)  ;
+extern void extended_to_decimal  (extended *, decimal_mode *,
+				decimal_record *, fp_exception_field_type *)  ;
+extern void quadruple_to_decimal  (quadruple *, decimal_mode *,
+				decimal_record *, fp_exception_field_type *)  ;
+
+extern void decimal_to_single  (single *, decimal_mode *, decimal_record *,
+				fp_exception_field_type *)  ;
+extern void decimal_to_double  (double *, decimal_mode *, decimal_record *,
+				fp_exception_field_type *)  ;
+extern void decimal_to_extended  (extended *, decimal_mode *,
+				decimal_record *, fp_exception_field_type *)  ;
+extern void decimal_to_quadruple  (quadruple *, decimal_mode *,
+				decimal_record *, fp_exception_field_type *)  ;
+
+extern void string_to_decimal  (char **, int, int, decimal_record *,
+				enum decimal_string_form *, char **)  ;
+extern void func_to_decimal  (char **, int, int, decimal_record *,
+				enum decimal_string_form *, char **,
+				int (*)(void), int *, int (*)(int))  ;
+extern void file_to_decimal  (char **, int, int, decimal_record *,
+				enum decimal_string_form *, char **,
+				FILE *, int *)  ;
+
+extern char *seconvert  (single *, int, int *, int *, char *)  ;
+extern char *sfconvert  (single *, int, int *, int *, char *)  ;
+extern char *sgconvert  (single *, int, int, char *)  ;
+extern char *econvert  (double, int, int *, int *, char *)  ;
+extern char *fconvert  (double, int, int *, int *, char *)  ;
+extern char *gconvert  (double, int, int, char *)  ;
+extern char *qeconvert  (quadruple *, int, int *, int *, char *)  ;
+extern char *qfconvert  (quadruple *, int, int *, int *, char *)  ;
+extern char *qgconvert  (quadruple *, int, int, char *)  ;
+
+extern char *ecvt  (double, int, int *, int *)  ;
+extern char *fcvt  (double, int, int *, int *)  ;
+extern char *gcvt  (double, int, char *)  ;
+
+ 
+
+
+
+extern double atof  (const char *)  ;
+extern double strtod  (const char *, char **)  ;
+
+
+}
+
+
+
+
+
+
+
+
+}
+
+
+
+
+ 
+ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#pragma interface
+
+#define _String_h 1
+
+
+ 
+ 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#pragma interface
+
+#define _Regex_h 1
+
+
+
+
+
+
+
+struct re_pattern_buffer;        
+struct re_registers;
+
+class Regex
+{
+private:
+
+                     Regex(const Regex&) {}   
+  void               operator = (const Regex&) {}  
+
+protected:
+  re_pattern_buffer* buf;
+  re_registers*      reg;
+
+public:
+                     Regex(const char* t,
+                           int fast = 0,
+                           int bufsize = 40,
+                           const char* transtable = 0);
+
+                    ~Regex();
+
+  int                match(const char* s, int len, int pos = 0) const;
+  int                search(const char* s, int len,
+                            int& matchlen, int startpos = 0) const;
+  int                match_info(int& start, int& length, int nth = 0) const;
+
+  int                OK() const;   
+};
+
+ 
+
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+
+
+
+
+
+struct StrRep                      
+{
+  unsigned short    len;          
+  unsigned short    sz;           
+  char              s[1];         
+                                  
+                                  
+};
+
+ 
+
+StrRep*     Salloc(StrRep*, const char*, int, int);
+StrRep*     Scopy(StrRep*, const StrRep*);
+StrRep*     Scat(StrRep*, const char*, int, const char*, int);
+StrRep*     Scat(StrRep*, const char*, int,const char*,int, const char*,int);
+StrRep*     Sprepend(StrRep*, const char*, int);
+StrRep*     Sreverse(const StrRep*, StrRep*);
+StrRep*     Supcase(const StrRep*, StrRep*);
+StrRep*     Sdowncase(const StrRep*, StrRep*);
+StrRep*     Scapitalize(const StrRep*, StrRep*);
+
+ 
+
+class String;
+class SubString;
+
+class SubString
+{
+  friend class      String;
+protected:
+
+  String&           S;         
+  unsigned short    pos;       
+  unsigned short    len;       
+
+  void              assign(const StrRep*, const char*, int = -1);
+                    SubString(String& x, int p, int l);
+
+public:
+                    SubString(const SubString& x);  
+
+ 
+ 
+
+                   ~SubString();
+
+  SubString&        operator =  (const String&     y);
+  SubString&        operator =  (const SubString&  y);
+  SubString&        operator =  (const char* t);
+  SubString&        operator =  (char        c);
+
+ 
+
+  int               contains(char        c) const;
+  int               contains(const String&     y) const;
+  int               contains(const SubString&  y) const;
+  int               contains(const char* t) const;
+  int               contains(const Regex&       r) const;
+
+ 
+
+  int               matches(const Regex&  r) const;
+
+ 
+
+  friend ostream&   operator<<(ostream& s, const SubString& x);
+
+ 
+
+  unsigned int      length() const;
+  int               empty() const;
+  const char*       chars() const;
+
+  int               OK() const;
+
+};
+
+
+class String
+{
+  friend class      SubString;
+
+protected:
+  StrRep*           rep;    
+
+ 
+
+  int               search(int, int, const char*, int = -1) const;
+  int               search(int, int, char) const;
+  int               match(int, int, int, const char*, int = -1) const;
+  int               _gsub(const char*, int, const char* ,int);
+  int               _gsub(const Regex&, const char*, int);
+  SubString         _substr(int, int);
+
+public:
+
+ 
+
+                    String();
+                    String(const String& x);
+                    String(const SubString&  x);
+                    String(const char* t);
+                    String(const char* t, int len);
+                    String(char c);
+
+                    ~String();
+
+  String&           operator =  (const String&     y);
+  String&           operator =  (const char* y);
+  String&           operator =  (char        c);
+  String&           operator =  (const SubString&  y);
+
+ 
+
+  String&           operator += (const String&     y);
+  String&           operator += (const SubString&  y);
+  String&           operator += (const char* t);
+  String&           operator += (char        c);
+
+  void              prepend(const String&     y);
+  void              prepend(const SubString&  y);
+  void              prepend(const char* t);
+  void              prepend(char        c);
+
+
+ 
+ 
+
+  friend inline void     cat(const String&, const String&, String&);
+  friend inline void     cat(const String&, const SubString&, String&);
+  friend inline void     cat(const String&, const char*, String&);
+  friend inline void     cat(const String&, char, String&);
+
+  friend inline void     cat(const SubString&, const String&, String&);
+  friend inline void     cat(const SubString&, const SubString&, String&);
+  friend inline void     cat(const SubString&, const char*, String&);
+  friend inline void     cat(const SubString&, char, String&);
+
+  friend inline void     cat(const char*, const String&, String&);
+  friend inline void     cat(const char*, const SubString&, String&);
+  friend inline void     cat(const char*, const char*, String&);
+  friend inline void     cat(const char*, char, String&);
+
+ 
+ 
+ 
+
+  friend inline void     cat(const String&,const String&, const String&,String&);
+  friend inline void     cat(const String&,const String&,const SubString&,String&);
+  friend inline void     cat(const String&,const String&, const char*, String&);
+  friend inline void     cat(const String&,const String&, char, String&);
+  friend inline void     cat(const String&,const SubString&,const String&,String&);
+  inline friend void     cat(const String&,const SubString&,const SubString&,String&);
+  friend inline void     cat(const String&,const SubString&, const char*, String&);
+  friend inline void     cat(const String&,const SubString&, char, String&);
+  friend inline void     cat(const String&,const char*, const String&,    String&);
+  friend inline void     cat(const String&,const char*, const SubString&, String&);
+  friend inline void     cat(const String&,const char*, const char*, String&);
+  friend inline void     cat(const String&,const char*, char, String&);
+
+  friend inline void     cat(const char*, const String&, const String&,String&);
+  friend inline void     cat(const char*,const String&,const SubString&,String&);
+  friend inline void     cat(const char*,const String&, const char*, String&);
+  friend inline void     cat(const char*,const String&, char, String&);
+  friend inline void     cat(const char*,const SubString&,const String&,String&);
+  friend inline void     cat(const char*,const SubString&,const SubString&,String&);
+  friend inline void     cat(const char*,const SubString&, const char*, String&);
+  friend inline void     cat(const char*,const SubString&, char, String&);
+  friend inline void     cat(const char*,const char*, const String&,    String&);
+  friend inline void     cat(const char*,const char*, const SubString&, String&);
+  friend inline void     cat(const char*,const char*, const char*, String&);
+  friend inline void     cat(const char*,const char*, char, String&);
+
+
+ 
+
+ 
+
+  int               index(char        c, int startpos = 0) const;
+  int               index(const String&     y, int startpos = 0) const;
+  int               index(const SubString&  y, int startpos = 0) const;
+  int               index(const char* t, int startpos = 0) const;
+  int               index(const Regex&      r, int startpos = 0) const;
+
+ 
+
+  int               contains(char        c) const;
+  int               contains(const String&     y) const;
+  int               contains(const SubString&  y) const;
+  int               contains(const char* t) const;
+  int               contains(const Regex&      r) const;
+
+ 
+ 
+
+  int               contains(char        c, int pos) const;
+  int               contains(const String&     y, int pos) const;
+  int               contains(const SubString&  y, int pos) const;
+  int               contains(const char* t, int pos) const;
+  int               contains(const Regex&      r, int pos) const;
+
+ 
+
+  int               matches(char        c, int pos = 0) const;
+  int               matches(const String&     y, int pos = 0) const;
+  int               matches(const SubString&  y, int pos = 0) const;
+  int               matches(const char* t, int pos = 0) const;
+  int               matches(const Regex&      r, int pos = 0) const;
+
+ 
+
+  int               freq(char        c) const;
+  int               freq(const String&     y) const;
+  int               freq(const SubString&  y) const;
+  int               freq(const char* t) const;
+
+ 
+
+ 
+ 
+ 
+
+  SubString         at(int         pos, int len);
+  SubString         operator () (int         pos, int len);  
+
+  SubString         at(const String&     x, int startpos = 0);
+  SubString         at(const SubString&  x, int startpos = 0);
+  SubString         at(const char* t, int startpos = 0);
+  SubString         at(char        c, int startpos = 0);
+  SubString         at(const Regex&      r, int startpos = 0);
+
+  SubString         before(int          pos);
+  SubString         before(const String&      x, int startpos = 0);
+  SubString         before(const SubString&   x, int startpos = 0);
+  SubString         before(const char*  t, int startpos = 0);
+  SubString         before(char         c, int startpos = 0);
+  SubString         before(const Regex&       r, int startpos = 0);
+
+  SubString         through(int          pos);
+  SubString         through(const String&      x, int startpos = 0);
+  SubString         through(const SubString&   x, int startpos = 0);
+  SubString         through(const char*  t, int startpos = 0);
+  SubString         through(char         c, int startpos = 0);
+  SubString         through(const Regex&       r, int startpos = 0);
+
+  SubString         from(int          pos);
+  SubString         from(const String&      x, int startpos = 0);
+  SubString         from(const SubString&   x, int startpos = 0);
+  SubString         from(const char*  t, int startpos = 0);
+  SubString         from(char         c, int startpos = 0);
+  SubString         from(const Regex&       r, int startpos = 0);
+
+  SubString         after(int         pos);
+  SubString         after(const String&     x, int startpos = 0);
+  SubString         after(const SubString&  x, int startpos = 0);
+  SubString         after(const char* t, int startpos = 0);
+  SubString         after(char        c, int startpos = 0);
+  SubString         after(const Regex&      r, int startpos = 0);
+
+
+ 
+
+ 
+  void              del(int         pos, int len);
+
+ 
+
+  void              del(const String&     y, int startpos = 0);
+  void              del(const SubString&  y, int startpos = 0);
+  void              del(const char* t, int startpos = 0);
+  void              del(char        c, int startpos = 0);
+  void              del(const Regex&      r, int startpos = 0);
+
+ 
+
+  int               gsub(const String&     pat, const String&     repl);
+  int               gsub(const SubString&  pat, const String&     repl);
+  int               gsub(const char* pat, const String&     repl);
+  int               gsub(const char* pat, const char* repl);
+  int               gsub(const Regex&      pat, const String&     repl);
+
+ 
+
+ 
+
+  friend int        split(const String& x, String res[], int maxn,
+                          const String& sep);
+  friend int        split(const String& x, String res[], int maxn,
+                          const Regex&  sep);
+
+  friend String     common_prefix(const String& x, const String& y,
+                                  int startpos = 0);
+  friend String     common_suffix(const String& x, const String& y,
+                                  int startpos = -1);
+  friend String     replicate(char        c, int n);
+  friend String     replicate(const String&     y, int n);
+  friend String     join(String src[], int n, const String& sep);
+
+ 
+
+  friend inline String     reverse(const String& x);
+  friend inline String     upcase(const String& x);
+  friend inline String     downcase(const String& x);
+  friend inline String     capitalize(const String& x);
+
+ 
+
+  void              reverse();
+  void              upcase();
+  void              downcase();
+  void              capitalize();
+
+ 
+
+  char&             operator [] (int i);
+  const char&       operator [] (int i) const;
+  char              elem(int i) const;
+  char              firstchar() const;
+  char              lastchar() const;
+
+ 
+
+                    operator const char*() const;
+  const char*       chars() const;
+
+
+ 
+
+  friend inline ostream&   operator<<(ostream& s, const String& x);
+  friend ostream&   operator<<(ostream& s, const SubString& x);
+  friend istream&   operator>>(istream& s, String& x);
+
+  friend int        readline(istream& s, String& x,
+                             char terminator = '\n',
+                             int discard_terminator = 1);
+
+ 
+
+  unsigned int      length() const;
+  int               empty() const;
+
+ 
+  void              alloc(int newsize);
+
+ 
+
+  int               allocation() const;
+
+
+  void     error(const char* msg) const;
+
+  int               OK() const;
+};
+
+typedef String StrTmp;  
+
+ 
+
+int        compare(const String&    x, const String&     y);
+int        compare(const String&    x, const SubString&  y);
+int        compare(const String&    x, const char* y);
+int        compare(const SubString& x, const String&     y);
+int        compare(const SubString& x, const SubString&  y);
+int        compare(const SubString& x, const char* y);
+int        fcompare(const String&   x, const String&     y);  
+
+extern StrRep  _nilStrRep;
+extern String _nilString;
+
+ 
+
+inline unsigned int String::length() const {  return rep->len; }
+inline int         String::empty() const { return rep->len == 0; }
+inline const char* String::chars() const { return &(rep->s[0]); }
+inline int         String::allocation() const { return rep->sz; }
+
+inline unsigned int SubString::length() const { return len; }
+inline int         SubString::empty() const { return len == 0; }
+inline const char* SubString::chars() const { return &(S.rep->s[pos]); }
+
+
+ 
+
+inline String::String()
+  : rep(&_nilStrRep) {}
+inline String::String(const String& x)
+  : rep(Scopy(0, x.rep)) {}
+inline String::String(const char* t)
+  : rep(Salloc(0, t, -1, -1)) {}
+inline String::String(const char* t, int tlen)
+  : rep(Salloc(0, t, tlen, tlen)) {}
+inline String::String(const SubString& y)
+  : rep(Salloc(0, y.chars(), y.length(), y.length())) {}
+inline String::String(char c)
+  : rep(Salloc(0, &c, 1, 1)) {}
+
+inline String::~String() { if (rep != &_nilStrRep) delete rep; }
+
+inline SubString::SubString(const SubString& x)
+  :S(x.S), pos(x.pos), len(x.len) {}
+inline SubString::SubString(String& x, int first, int l)
+  :S(x), pos(first), len(l) {}
+
+inline SubString::~SubString() {}
+
+ 
+
+inline String& String::operator =  (const String& y)
+{
+  rep = Scopy(rep, y.rep);
+  return *this;
+}
+
+inline String& String::operator=(const char* t)
+{
+  rep = Salloc(rep, t, -1, -1);
+  return *this;
+}
+
+inline String& String::operator=(const SubString&  y)
+{
+  rep = Salloc(rep, y.chars(), y.length(), y.length());
+  return *this;
+}
+
+inline String& String::operator=(char c)
+{
+  rep = Salloc(rep, &c, 1, 1);
+  return *this;
+}
+
+
+inline SubString& SubString::operator = (const char* ys)
+{
+  assign(0, ys);
+  return *this;
+}
+
+inline SubString& SubString::operator = (char ch)
+{
+  assign(0, &ch, 1);
+  return *this;
+}
+
+inline SubString& SubString::operator = (const String& y)
+{
+  assign(y.rep, y.chars(), y.length());
+  return *this;
+}
+
+inline SubString& SubString::operator = (const SubString& y)
+{
+  assign(y.S.rep, y.chars(), y.length());
+  return *this;
+}
+
+ 
+
+inline void cat(const String& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const String& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const SubString& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const SubString& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const SubString& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const SubString& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const char* x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, x, -1, y.chars(), y.length());
+}
+
+inline void cat(const char* x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, x, -1, y.chars(), y.length());
+}
+
+inline void cat(const char* x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, x, -1, y, -1);
+}
+
+inline void cat(const char* x, char y, String& r)
+{
+  r.rep = Scat(r.rep, x, -1, &y, 1);
+}
+
+inline void cat(const String& a, const String& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& a, const String& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& a, const String& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const String& a, const String& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const String& a, const SubString& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& a, const SubString& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const String& a, const SubString& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const String& a, const SubString& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const String& a, const char* x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x, -1, y.chars(), y.length());
+}
+
+inline void cat(const String& a, const char* x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x, -1, y.chars(), y.length());
+}
+
+inline void cat(const String& a, const char* x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x, -1, y, -1);
+}
+
+inline void cat(const String& a, const char* x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a.chars(), a.length(), x, -1, &y, 1);
+}
+
+
+inline void cat(const char* a, const String& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const char* a, const String& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const char* a, const String& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const char* a, const String& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const char* a, const SubString& x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const char* a, const SubString& x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y.chars(), y.length());
+}
+
+inline void cat(const char* a, const SubString& x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), y, -1);
+}
+
+inline void cat(const char* a, const SubString& x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x.chars(), x.length(), &y, 1);
+}
+
+inline void cat(const char* a, const char* x, const String& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x, -1, y.chars(), y.length());
+}
+
+inline void cat(const char* a, const char* x, const SubString& y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x, -1, y.chars(), y.length());
+}
+
+inline void cat(const char* a, const char* x, const char* y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x, -1, y, -1);
+}
+
+inline void cat(const char* a, const char* x, char y, String& r)
+{
+  r.rep = Scat(r.rep, a, -1, x, -1, &y, 1);
+}
+
+
+ 
+
+inline String& String::operator +=(const String& y)
+{
+  cat(*this, y, *this);
+  return *this;
+}
+
+inline String& String::operator +=(const SubString& y)
+{
+  cat(*this, y, *this);
+  return *this;
+}
+
+inline String& String::operator += (const char* y)
+{
+  cat(*this, y, *this);
+  return *this;
+}
+
+inline String& String:: operator +=(char y)
+{
+  cat(*this, y, *this);
+  return *this;
+}
+
+ 
+
+
+
+inline String operator + (const String& x, const String& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const String& x, const SubString& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const String& x, const char* y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const String& x, char y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const SubString& x, const String& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const SubString& x, const SubString& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const SubString& x, const char* y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const SubString& x, char y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const char* x, const String& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String operator + (const char* x, const SubString& y) return r;
+{
+  cat(x, y, r);
+}
+
+inline String reverse(const String& x) return r;
+{
+  r.rep = Sreverse(x.rep, r.rep);
+}
+
+inline String upcase(const String& x) return r;
+{
+  r.rep = Supcase(x.rep, r.rep);
+}
+
+inline String downcase(const String& x) return r;
+{
+  r.rep = Sdowncase(x.rep, r.rep);
+}
+
+inline String capitalize(const String& x) return r;
+{
+  r.rep = Scapitalize(x.rep, r.rep);
+}
+
+
+
+ 
+
+inline void String::prepend(const String& y)
+{
+  rep = Sprepend(rep, y.chars(), y.length());
+}
+
+inline void String::prepend(const char* y)
+{
+  rep = Sprepend(rep, y, -1);
+}
+
+inline void String::prepend(char y)
+{
+  rep = Sprepend(rep, &y, 1);
+}
+
+inline void String::prepend(const SubString& y)
+{
+  rep = Sprepend(rep, y.chars(), y.length());
+}
+
+ 
+
+
+inline void String::reverse()
+{
+  rep = Sreverse(rep, rep);
+}
+
+
+inline void String::upcase()
+{
+  rep = Supcase(rep, rep);
+}
+
+
+inline void String::downcase()
+{
+  rep = Sdowncase(rep, rep);
+}
+
+
+inline void String::capitalize()
+{
+  rep = Scapitalize(rep, rep);
+}
+
+ 
+
+inline char&  String::operator [] (int i)
+{
+  if (((unsigned)i) >= length()) error("invalid index");
+  return rep->s[i];
+}
+
+inline const char&  String::operator [] (int i) const
+{
+  if (((unsigned)i) >= length()) error("invalid index");
+  return rep->s[i];
+}
+
+inline char  String::elem (int i) const
+{
+  if (((unsigned)i) >= length()) error("invalid index");
+  return rep->s[i];
+}
+
+inline char  String::firstchar() const
+{
+  return elem(0);
+}
+
+inline char  String::lastchar() const
+{
+  return elem(length() - 1);
+}
+
+ 
+
+inline int String::index(char c, int startpos) const
+{
+  return search(startpos, length(), c);
+}
+
+inline int String::index(const char* t, int startpos) const
+{
+  return search(startpos, length(), t);
+}
+
+inline int String::index(const String& y, int startpos) const
+{
+  return search(startpos, length(), y.chars(), y.length());
+}
+
+inline int String::index(const SubString& y, int startpos) const
+{
+  return search(startpos, length(), y.chars(), y.length());
+}
+
+inline int String::index(const Regex& r, int startpos) const
+{
+  int unused;  return r.search(chars(), length(), unused, startpos);
+}
+
+inline int String::contains(char c) const
+{
+  return search(0, length(), c) >= 0;
+}
+
+inline int String::contains(const char* t) const
+{
+  return search(0, length(), t) >= 0;
+}
+
+inline int String::contains(const String& y) const
+{
+  return search(0, length(), y.chars(), y.length()) >= 0;
+}
+
+inline int String::contains(const SubString& y) const
+{
+  return search(0, length(), y.chars(), y.length()) >= 0;
+}
+
+inline int String::contains(char c, int p) const
+{
+  return match(p, length(), 0, &c, 1) >= 0;
+}
+
+inline int String::contains(const char* t, int p) const
+{
+  return match(p, length(), 0, t) >= 0;
+}
+
+inline int String::contains(const String& y, int p) const
+{
+  return match(p, length(), 0, y.chars(), y.length()) >= 0;
+}
+
+inline int String::contains(const SubString& y, int p) const
+{
+  return match(p, length(), 0, y.chars(), y.length()) >= 0;
+}
+
+inline int String::contains(const Regex& r) const
+{
+  int unused;  return r.search(chars(), length(), unused, 0) >= 0;
+}
+
+inline int String::contains(const Regex& r, int p) const
+{
+  return r.match(chars(), length(), p) >= 0;
+}
+
+
+inline int String::matches(const SubString& y, int p) const
+{
+  return match(p, length(), 1, y.chars(), y.length()) >= 0;
+}
+
+inline int String::matches(const String& y, int p) const
+{
+  return match(p, length(), 1, y.chars(), y.length()) >= 0;
+}
+
+inline int String::matches(const char* t, int p) const
+{
+  return match(p, length(), 1, t) >= 0;
+}
+
+inline int String::matches(char c, int p) const
+{
+  return match(p, length(), 1, &c, 1) >= 0;
+}
+
+inline int String::matches(const Regex& r, int p) const
+{
+  int l = (p < 0)? -p : length() - p;
+  return r.match(chars(), length(), p) == l;
+}
+
+
+inline int SubString::contains(const char* t) const
+{
+  return S.search(pos, pos+len, t) >= 0;
+}
+
+inline int SubString::contains(const String& y) const
+{
+  return S.search(pos, pos+len, y.chars(), y.length()) >= 0;
+}
+
+inline int SubString::contains(const SubString&  y) const
+{
+  return S.search(pos, pos+len, y.chars(), y.length()) >= 0;
+}
+
+inline int SubString::contains(char c) const
+{
+  return S.search(pos, pos+len, c) >= 0;
+}
+
+inline int SubString::contains(const Regex& r) const
+{
+  int unused;  return r.search(chars(), len, unused, 0) >= 0;
+}
+
+inline int SubString::matches(const Regex& r) const
+{
+  return r.match(chars(), len, 0) == len;
+}
+
+
+inline int String::gsub(const String& pat, const String& r)
+{
+  return _gsub(pat.chars(), pat.length(), r.chars(), r.length());
+}
+
+inline int String::gsub(const SubString&  pat, const String& r)
+{
+  return _gsub(pat.chars(), pat.length(), r.chars(), r.length());
+}
+
+inline int String::gsub(const Regex& pat, const String& r)
+{
+  return _gsub(pat, r.chars(), r.length());
+}
+
+inline int String::gsub(const char* pat, const String& r)
+{
+  return _gsub(pat, -1, r.chars(), r.length());
+}
+
+inline int String::gsub(const char* pat, const char* r)
+{
+  return _gsub(pat, -1, r, -1);
+}
+
+
+
+inline  ostream& operator<<(ostream& s, const String& x)
+{
+   s << x.chars(); return s;
+}
+
+ 
+
+inline int operator==(const String& x, const String& y)
+{
+  return compare(x, y) == 0;
+}
+
+inline int operator!=(const String& x, const String& y)
+{
+  return compare(x, y) != 0;
+}
+
+inline int operator>(const String& x, const String& y)
+{
+  return compare(x, y) > 0;
+}
+
+inline int operator>=(const String& x, const String& y)
+{
+  return compare(x, y) >= 0;
+}
+
+inline int operator<(const String& x, const String& y)
+{
+  return compare(x, y) < 0;
+}
+
+inline int operator<=(const String& x, const String& y)
+{
+  return compare(x, y) <= 0;
+}
+
+inline int operator==(const String& x, const SubString&  y)
+{
+  return compare(x, y) == 0;
+}
+
+inline int operator!=(const String& x, const SubString&  y)
+{
+  return compare(x, y) != 0;
+}
+
+inline int operator>(const String& x, const SubString&  y)
+{
+  return compare(x, y) > 0;
+}
+
+inline int operator>=(const String& x, const SubString&  y)
+{
+  return compare(x, y) >= 0;
+}
+
+inline int operator<(const String& x, const SubString&  y)
+{
+  return compare(x, y) < 0;
+}
+
+inline int operator<=(const String& x, const SubString&  y)
+{
+  return compare(x, y) <= 0;
+}
+
+inline int operator==(const String& x, const char* t)
+{
+  return compare(x, t) == 0;
+}
+
+inline int operator!=(const String& x, const char* t)
+{
+  return compare(x, t) != 0;
+}
+
+inline int operator>(const String& x, const char* t)
+{
+  return compare(x, t) > 0;
+}
+
+inline int operator>=(const String& x, const char* t)
+{
+  return compare(x, t) >= 0;
+}
+
+inline int operator<(const String& x, const char* t)
+{
+  return compare(x, t) < 0;
+}
+
+inline int operator<=(const String& x, const char* t)
+{
+  return compare(x, t) <= 0;
+}
+
+inline int operator==(const SubString& x, const String& y)
+{
+  return compare(y, x) == 0;
+}
+
+inline int operator!=(const SubString& x, const String& y)
+{
+  return compare(y, x) != 0;
+}
+
+inline int operator>(const SubString& x, const String& y)
+{
+  return compare(y, x) < 0;
+}
+
+inline int operator>=(const SubString& x, const String& y)
+{
+  return compare(y, x) <= 0;
+}
+
+inline int operator<(const SubString& x, const String& y)
+{
+  return compare(y, x) > 0;
+}
+
+inline int operator<=(const SubString& x, const String& y)
+{
+  return compare(y, x) >= 0;
+}
+
+inline int operator==(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) == 0;
+}
+
+inline int operator!=(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) != 0;
+}
+
+inline int operator>(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) > 0;
+}
+
+inline int operator>=(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) >= 0;
+}
+
+inline int operator<(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) < 0;
+}
+
+inline int operator<=(const SubString& x, const SubString&  y)
+{
+  return compare(x, y) <= 0;
+}
+
+inline int operator==(const SubString& x, const char* t)
+{
+  return compare(x, t) == 0;
+}
+
+inline int operator!=(const SubString& x, const char* t)
+{
+  return compare(x, t) != 0;
+}
+
+inline int operator>(const SubString& x, const char* t)
+{
+  return compare(x, t) > 0;
+}
+
+inline int operator>=(const SubString& x, const char* t)
+{
+  return compare(x, t) >= 0;
+}
+
+inline int operator<(const SubString& x, const char* t)
+{
+  return compare(x, t) < 0;
+}
+
+inline int operator<=(const SubString& x, const char* t)
+{
+  return compare(x, t) <= 0;
+}
+
+
+ 
+
+inline SubString String::_substr(int first, int l)
+{
+  if (first < 0 || (unsigned)(first + l) > length() )
+    return SubString(_nilString, 0, 0) ;
+  else
+    return SubString(*this, first, l);
+}
+
+
+
+
+
+#define booleen_hh
+
+ 
+typedef int booleen;
+
+const booleen VRAI=1;
+const booleen FAUX=0;
+
+
+
+
+#define valeur_bidon 12345678
+
+#define fors(type, i, imin, imax) for(type i=imin; i< imax; i++)
+#define fore(type, i, imin, imax) for(type i=imin; i<=imax; i++)
+
+void verif_nb_param(int argc, char* argv[], int nb_params);
+
+booleen f_exists(String nom);
+
+ 
+template<class Type>
+inline Type carre(const Type x)
+{
+  return x*x;
+}
+
+template<class Type>
+inline Type cube(const Type x)
+{
+  return x*x*x;
+}
+
+template<class Type>
+inline Type rac3(const Type x)
+{
+  if(fabs(x)<1E-5)
+    return 0;
+  else
+    if(x>0)
+      return exp(log(x)/3);
+    else
+      return -exp(log(-x)/3);
+}
+
+template<class Type>
+inline Type min(const Type a,const Type b)
+{
+  return (a>b)?b:a;
+}
+
+template<class Type>
+inline Type max(const Type a,const Type b)
+{
+  return (a<b)?b:a;
+}
+
+template<class Type>
+inline Type min(const Type a,const Type b,const Type c)
+{
+  return min(a,min(b,c));
+}
+
+template<class Type>
+inline Type max(const Type a,const Type b,const Type c)
+{
+  return max(a,max(b,c));
+}
+
+template <class Type>
+inline void echange(Type& a,Type& b)
+{
+  Type t=a;
+  a=b;
+  b=t;
+}
+
+ 
+String i2S(int n,int l=0);
+
+template <class Type>
+inline booleen dans(Type x, Type a, Type b)
+{
+  return (a<=x) && (x<=b);
+}
+
+template <class Type>
+inline Type mabs(Type x)
+{
+  return (x<0) ? -x : x ;
+}
+
+template <class Type>
+inline booleen dans2(Type x, Type a, Type b)	   
+   
+{
+  return mabs(x-(a+b)/2) <= mabs((a-b)/2) ;
+}
+
+template <class Type>
+inline booleen proche(Type x, Type y, Type eps)
+{
+  return mabs(x-y)<eps;				   
+}
+
+template <class Type>
+inline int arrondi(Type x)
+{
+  return int(x+0.5);
+}
+
+template<class Type>
+unsigned char arrondi_ng(Type x)
+{
+  if((-0.5<x) && (x<255.5))
+    return (unsigned char)(x+0.5);
+  else
+  {
+    if(x<-3.0 || x>268.0)
+      cerr<<"arrondi_ng : attention x= "<<x<<endl;
+     
+    if(x<0.0)
+      return 0;
+    else
+      return 255;
+  }
+}
+
+template<class Type>
+unsigned char arrondi_ng_err(Type x)
+{
+  if((-0.5<x) && (x<255.5))
+    return (unsigned char)(x+0.5);
+  else
+  {
+    if(x<0.0)
+      return 0;
+    else
+      return 255;
+  }
+}
+
+inline int nb_diff2(int a,int b)		   
+{
+  if(a==b)
+    return 1;
+  else
+    return 2;
+}
+
+inline int nb_diff3(int a,int b,int c)		   
+{
+  if(a==b || a==c)
+    return nb_diff2(b,c);
+  else
+    return 1+nb_diff2(b,c);
+}
+
+inline int nb_diff4(int a,int b,int c,int d)	   
+{
+  if(a==b || a==c || a==d)
+    return nb_diff3(b,c,d);
+  else
+    return 1+nb_diff3(b,c,d);
+}
+
+float echMSB(float a);
+
+void plante();					   
+void arrete();					   
+
+void touche();					   
+
+template<class Type>
+void lis_param(istream& f, Type& param)
+{
+  f>>param;
+  f.ignore(20000,'\n');				   
+}
+
+void lis_chaine(istream& s, String chaine);
+
+template<class Type_dest, class Type_source>
+void convert(Type_dest& dest, const Type_source& source)
+{
+  dest=source;
+}
+
+
+
+
+struct Vect2Dent
+{
+  int di;
+  int dj;
+};
+
+
+
+
+
+
+struct depl2D
+{
+  double x;
+  double y;
+  depl2D() : x(0.0), y(0.0)
+  { }
+   
+   
+  depl2D(double xx, double yy) : x(xx), y(yy)
+  { }
+  double amplitude()
+  {
+    return max(mabs(x),mabs(y));
+  }
+};
+
+ostream& operator<<(ostream& s, depl2D m);
+
+class Mouvement
+{
+private:
+  Mouvement* read_mv(istream& s);
+protected:
+  double t_x;
+  double t_y;
+  double centre_x;
+  double centre_y;
+public:
+  Mouvement();
+  Mouvement(double i_t_x, double i_t_y, double i_centre_x, double i_centre_y);
+  virtual void Id()=0;
+  virtual void centre(double x,double y)=0;
+  virtual void applique(double& xx, double& yy, double x, double y) const=0;
+  virtual void applique(float& xx, float& yy, float x, float y) const=0;
+  virtual depl2D calc_depl(double x, double y)=0;
+  double Centre_x() const
+  {
+    return centre_x;
+  }
+  double Centre_y() const
+  {
+    return centre_y;
+  }
+
+  virtual int nb_param() const=0;
+   
+   
+  virtual void init_from_vect_d(const double param[])=0;
+  virtual void init_vect_d(double param[]) const=0;
+  virtual void init_from_vect_f(const float param[])=0;
+  virtual void init_vect_f(float param[]) const=0;
+
+  virtual Mouvement* clone() const=0;
+  virtual String nom() const=0;
+  virtual void dump(ostream& s) const=0;
+
+  virtual booleen trop_grand(float seuil) const=0;
+  booleen trop_grand2(float seuil, float seuil_t) const;
+};
+
+ostream& operator<<(ostream& s, const Mouvement& m);
+Mouvement* read_mv(istream& s);
+
+
+
+
+class AFF;
+
+class LS : public Mouvement
+{
+protected:
+  double k;
+  double theta;
+public:
+  LS();
+  LS(double i_t_x, double i_t_y, double i_k, double i_theta, double i_centre_x, double i_centre_y);
+  LS(istream& s);
+  LS(const AFF& aff);
+  int nb_param() const;
+  void update(double d_t_x, double d_t_y, double d_k, double d_theta);
+  void init_from_vect_d(const double param[]);
+  void init_vect_d(double param[]) const;
+  void init_from_vect_f(const float param[]);
+  void init_vect_f(float param[]) const;
+  friend class AFF;
+  void dump(ostream& s) const;
+};
+
+ostream& operator<<(ostream& s, const LS& m);
+
+
+
+
+#define AFF_hh
+
+
+
+class LS;
+
+class AFF: public Mouvement
+{
+protected:
+  double a;
+  double b;
+  double c;
+  double d;
+public:
+  AFF();
+  AFF(double i_t_x, double i_t_y,
+      double i_a, double i_b, double i_c, double i_d,
+      double i_centre_x, double i_centre_y);
+  AFF(istream& s);
+  AFF(const LS& ls);
+  int nb_param() const;
+  void init_from_vect_d(const double param[]);
+  void init_vect_d(double param[]) const;
+  void init_from_vect_f(const float param[]);
+  void init_vect_f(float param[]) const;
+
+  friend class LS;
+  void dump(ostream& s) const;
+};
+
+ostream& operator<<(ostream& s, const AFF& m);
+
+
+
+
+
+
+
+
+
+LS::LS() :
+  k(0.0), theta(0.0)
+{ }
+
+LS::LS(double i_t_x, double i_t_y,
+       double i_k, double i_theta,
+       double i_centre_x, double i_centre_y) :
+  Mouvement(i_t_x, i_t_y, i_centre_x, i_centre_y),
+  k(i_k),
+  theta(i_theta)
+{ }
+
+LS::LS(istream& s)
+{
+  s>>k>>theta>>t_x>>theta>>k>>t_y>>centre_x>>centre_y;
+}
+
+LS::LS(const AFF& aff): Mouvement(aff.t_x, aff.t_y, aff.centre_x, aff.centre_y)
+{
+  const double eps_k=1E-6;
+  if(mabs(aff.a-aff.d)>eps_k)
+  {
+    cout<<"AFF_2_LS :  delta k < "<<eps_k<<endl;
+    cout<<aff.a<<endl<<aff.d<<endl;
+    plante();
+  }
+  else
+    k=(aff.a+aff.d)/2;
+
+  const double eps_theta=1E-6;
+  if(mabs(aff.c+aff.b)>eps_theta)
+  {
+    cout<<"AFF_2_LS :  delta theta < "<<eps_theta<<endl;
+    plante();
+  }
+  else
+    theta=(aff.c-aff.b)/2;
+}
+
+int LS::nb_param() const
+{
+  return 4;
+}
+
+void LS::update(double d_t_x,
+		double d_t_y,
+		double d_k,
+		double d_theta)
+{
+  t_x+=d_t_x;
+  t_y+=d_t_y;
+  k+=d_k;
+  theta+=d_theta;
+}
+
+void LS::init_from_vect_d(const double param[])
+{
+  t_x=param[0];
+  t_y=param[1];
+  k=param[2];
+  theta=param[3];
+}
+
+void LS::init_vect_d(double param[]) const
+{
+  param[0]=t_x;
+  param[1]=t_y;
+  param[2]=k;
+  param[3]=theta;
+}
+
+void LS::init_from_vect_f(const float param[])
+{
+  t_x=param[0];
+  t_y=param[1];
+  k=param[2];
+  theta=param[3];
+}
+
+void LS::init_vect_f(float param[]) const
+{
+  param[0]=t_x;
+  param[1]=t_y;
+  param[2]=k;
+  param[3]=theta;
+}
+
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+
+ 
+ 
+ 
+ 
+
+void LS::dump(ostream& s) const
+{
+  const int largeur=14;
+  s.setf(ios::left,ios::adjustfield);
+  s<<nom()<<endl
+   <<setw(largeur)<<k<<setw(largeur)<<-theta<<setw(largeur)<<t_x<<endl
+   <<setw(largeur)<<theta<<setw(largeur)<<k<<setw(largeur)<<t_y<<endl
+   <<centre_x<<' '<<centre_y<<endl;
+}
+
+ostream& operator<<(ostream& s, const LS& m)
+{
+  m.dump(s);
+  return s;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb102.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb102.C
new file mode 100644
index 00000000000..9bbd47fdb33
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb102.C
@@ -0,0 +1,34 @@
+// Error: intenral compiler error on 1998/05/28 snapshot.
+#include <stdio.h>
+#include <stdlib.h>
+
+void evilRises (void **ptr)
+{
+    int *pi;
+
+    pi = new int;
+
+    *pi = 0;
+
+    *ptr = (void *)pi;
+}
+
+int main (int argc, char *argv[])
+{
+#ifdef WORKAROUND
+    union foo
+#else
+    union
+#endif
+    {
+        int a;
+        int b;
+        int c;
+    } *fred, barney;
+
+    evilRises((void **)&fred);
+
+    barney = *fred;
+
+    return EXIT_SUCCESS;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb103.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb103.C
new file mode 100644
index 00000000000..ef25fb46634
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb103.C
@@ -0,0 +1,11 @@
+// Build don't link:  
+// Error: Internal compiler error in 2.7.2 & EGCS 1.0.0
+
+template <int nlimb, int i>
+inline unsigned f (unsigned* ptr);
+template <int nlimb>
+inline unsigned f<nlimb,nlimb> (unsigned* ptr)
+{                        //ERROR - partial specialization of function?
+  return 1;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb104.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb104.C
new file mode 100644
index 00000000000..10c5945bb15
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb104.C
@@ -0,0 +1,29 @@
+#include <string.h>
+
+class SomeClass_t {
+public:
+    SomeClass_t () : x (11) {}
+protected:
+  float x;
+};
+
+class DynamicOnly_t {
+public:
+  static DynamicOnly_t* create (const char* name = "UNDEF",
+                                const SomeClass_t& somec = *(new SomeClass_t
+())) {
+    return new DynamicOnly_t (name, somec);
+  }
+  DynamicOnly_t (const char* name, const SomeClass_t& somec) :
+    m_somec (somec) {
+    strncpy (m_Name, name, sizeof (m_Name));
+  }
+private:
+  SomeClass_t m_somec;
+  char m_Name[255];
+};
+
+int main (int argc, char* argv[]) {
+  DynamicOnly_t* ptr = DynamicOnly_t::create ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb105.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb105.C
new file mode 100644
index 00000000000..f431fba88d8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb105.C
@@ -0,0 +1,13 @@
+// Build don't link: 
+template< class T >
+void    sort( T* t, int n )
+        {
+            struct
+/*line5*/   {
+                int     operator()(T i, T j)
+                        {
+                            return (i < j) ? -1 : ((j < i) ? 1 : 0) ;
+                        }
+            } c ;
+            sort(t, n, c, 0) ;
+        }
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb106.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb106.C
new file mode 100644
index 00000000000..93631715869
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb106.C
@@ -0,0 +1,37 @@
+// Skip if not native
+// Special g++ Options: -O2 -fPIC 
+// Build don't link: 
+struct T
+{
+	char*	f1;
+	int	f2;
+};
+
+void f(T*);
+int g();
+
+extern char a1[];
+
+inline int m(int a, int b) {return b < a ? 2 : 1;}
+
+void
+h()
+{
+	T	a[10];
+	int	i(0);
+
+	bool	c;
+	if (c)
+	{		 
+		a[i++].f1 = "asf";
+		f(a);
+		i = 0;
+	}
+
+	a[i].f1 = &a1[1];
+	a[i].f2 = m(1, g());
+	i++;
+
+	a[i].f1 = "zxv";
+	a[i].f2 = 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb107.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb107.C
new file mode 100644
index 00000000000..8d0f3cbe5b1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb107.C
@@ -0,0 +1,20 @@
+// Build don't link: 
+template <class T>
+struct X
+{
+    virtual void f(int) const;
+};
+
+template <class T>
+struct Y: public X<T>
+{
+    virtual void f(int) const;
+};
+
+template <class T>
+void Y<T>::f(int) const
+{
+}
+
+template <>
+void Y<bool>::f(int) const;
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb108.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb108.C
new file mode 100644
index 00000000000..3bf71b06dee
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb108.C
@@ -0,0 +1,21 @@
+// Build don't link: 
+class X
+{
+  public:
+    virtual void f() const = 0;
+};
+
+template <class T>
+class Y: public X
+{
+  public:
+    virtual void f() const;
+};
+
+template <class T>
+void Y<T>::f() const
+{
+}
+
+template <>
+void Y<bool>::f() const;
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb109.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb109.C
new file mode 100644
index 00000000000..ccd206b0e2c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb109.C
@@ -0,0 +1,71 @@
+#include<map>
+#include<iostream.h>
+#include<vector>
+#include<string>
+
+// empty parameter class with a minimal set of operations
+// if there are no weights for edges necessary
+struct Empty
+{
+  public:
+    Empty(int=0) {}
+    bool operator<(const Empty&) const { return true;}
+};
+inline ostream& operator<<(ostream& os, const Empty&) { return os;}
+inline istream& operator>>(istream& is, Empty& ) { return is;}
+
+
+template<class VertexType, class EdgeType>
+class Graph
+{ 
+  public:
+    // public type interface
+    typedef map<int, EdgeType > Successor;
+    typedef pair<VertexType, Successor> vertex;
+    typedef vector<vertex> GraphType;
+    typedef typename GraphType::iterator iterator;
+    typedef typename GraphType::const_iterator const_iterator;
+
+  // a lot of stuff deleted ....
+
+  private:
+    bool directed;
+    GraphType C;          // container
+    ostream* pOut;
+}; // ERROR - candidates
+
+// all graph-methods delet
+template<class VertexType, class EdgeType>
+ostream& operator<<(ostream& os, Graph<VertexType,EdgeType>& G)
+{
+    // display of vertices with successors
+  for(int i = 0; i < G.size(); ++i)  // ERROR - no size function
+    {
+      os << G[i].first << " <";      // ERROR - no index operator
+
+        // The compiler does not like this line!!!!!!
+        typename Graph<VertexType, EdgeType>::Successor::iterator
+	  startN = G[i].second.begin(), // ERROR - no index operator
+	  endN   = G[i].second.end();  // ERROR - no index operator
+
+        while(startN != endN)
+        {
+            os << G[(*startN).first].first << ' ' // vertex
+               << (*startN).second << ' ';        // ERROR - no index operator
+            ++startN;
+        }
+        os << ">\n";
+    }
+    return os;
+}
+
+int main()
+{
+    // no edge weighting, therefore type Empty:
+    Graph<string, Empty> V(true);        // ERROR - no bool constructor
+    // ReadGraph(V, "gra1.dat");
+
+    // display of vertices with successors
+    cout << V;
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb11.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb11.C
new file mode 100644
index 00000000000..307aa6a9568
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb11.C
@@ -0,0 +1,29 @@
+// Build don't link:
+
+template<int N1, int N2>
+struct meta_max {
+    enum { max = (N1 > N2) ? N1 : N2 };
+};
+
+struct X {
+    enum {
+       a = 0,
+       n = 0
+    };
+};
+
+template<class T1, class T2>
+struct Y {
+
+    enum {
+       a = T1::a + T2::a,
+
+       // NB: if the next line is changed to
+       // n = (T1::n > T2::n) ? T1::n : T2::n
+       // the problem goes away.
+
+       n = meta_max<T1::n,T2::n>::max
+    };
+};
+
+int z = Y<X,X>::a;
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb110.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb110.C
new file mode 100644
index 00000000000..54a1c8bbb86
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb110.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+class X
+{
+  public:
+    virtual void f() const = 0;
+};
+
+template <class T>
+class Y: public X
+{
+  public:
+    virtual void f() const;
+};
+
+template <class T>
+void Y<T>::f() const
+{
+}
+
+template <>
+void Y<bool>::f() const;
+
+template <>
+void Y<bool>::f() const
+{
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb111.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb111.C
new file mode 100644
index 00000000000..8afc921e109
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb111.C
@@ -0,0 +1,6 @@
+  int main() {
+      for(int i=1; i < 9; i++);
+      for(int i=1; i < 9; i++);
+
+      return 0;
+      }
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb112.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb112.C
new file mode 100644
index 00000000000..3233287ff10
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb112.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+template <class STRUCT, class MEMBER> inline STRUCT *
+setback(MEMBER *bp, MEMBER STRUCT::*offset)
+{
+        // The implementation of this function may be platform dependend
+        if(!bp) return 0; // NULL pointers remain NULL
+        union { int i; MEMBER STRUCT::*of; } u; // Switch types. Casting won't
++work.
+        u.of = offset;
+        return (STRUCT *) ((int) bp - u.i);
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb113.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb113.C
new file mode 100644
index 00000000000..f3c28b9ac65
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb113.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+#include <iostream.h>
+
+class X : public std::streambuf
+{
+} ;
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb114.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb114.C
new file mode 100644
index 00000000000..020b88bb775
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb114.C
@@ -0,0 +1,29 @@
+#include <string.h>
+
+class SomeClass_t {
+public:
+  SomeClass_t () : x (11) {}
+protected:
+  float x;
+};
+
+class DynamicOnly_t {
+public:
+  static DynamicOnly_t* create (const char* name = "UNDEF",
+                                const SomeClass_t& somec = *(new SomeClass_t
+())) {
+    return new DynamicOnly_t (name, somec);
+  }
+  DynamicOnly_t (const char* name, const SomeClass_t& somec) :
+    m_somec (somec) {
+    strncpy (m_Name, name, sizeof (m_Name));
+  }
+private:
+  SomeClass_t m_somec;
+  char m_Name[255];
+};
+
+int main (int argc, char* argv[]) {
+  DynamicOnly_t* ptr = DynamicOnly_t::create (); //*
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb115.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb115.C
new file mode 100644
index 00000000000..30eab786f34
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb115.C
@@ -0,0 +1,9 @@
+// Special g++ Options: -O
+
+#include <iostream.h>
+#include <typeinfo>
+
+int main() {
+  int *i1, *i2;
+  cerr << (typeid(i1)==typeid(i2)) << endl;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb116.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb116.C
new file mode 100644
index 00000000000..63f5e79c062
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb116.C
@@ -0,0 +1,23 @@
+template <class INT>
+class b
+{
+private:
+  char a(int x)
+  {
+    union {
+      int i;
+      char c;
+    } val;
+    val.i = x;
+    return val.c;
+  };
+
+public:
+  b()  {
+  }
+};
+
+int main() {
+  b<int> n;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb118.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb118.C
new file mode 100644
index 00000000000..23498c78554
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb118.C
@@ -0,0 +1,37 @@
+// Test for obsolete specialization syntax.  Turn off -pedantic.
+// Special g++ Options:
+
+#include <iostream.h>
+#include <typeinfo>
+
+template <typename T>
+class A {
+public:
+  void test ();
+};
+
+template <typename T>
+void
+A<T>::test(){
+  cerr << "test for " << typeid(*this).name() << endl;
+}
+// Specialization declaration
+void                           
+A<double>::test();
+
+// Specialization definition
+void
+A<double>::test(){
+  cerr << "specialization for " << typeid(*this).name() << endl;
+}
+
+
+int
+main(){
+  A<int> ai;
+  A<double> ad;
+  ai.test();
+  ad.test();
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb119.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb119.C
new file mode 100644
index 00000000000..cecea834f8a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb119.C
@@ -0,0 +1,10 @@
+template<bool B>
+void f()
+{
+}
+
+int main()
+{
+  f<bool>(); // ERROR - .*
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb12.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb12.C
new file mode 100644
index 00000000000..5c948f11b58
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb12.C
@@ -0,0 +1,32 @@
+// Build don't link: 
+// Error: Internal Compiler Error in 2.7.2. & egcs 1.0.0
+
+#ifndef NO_META_MAX
+template<int N1, int N2>
+struct meta_max {
+    enum { max = (N1 > N2) ? N1 : N2 };
+};
+#endif
+
+struct X {
+    enum {
+       a = 0,
+       n = 0
+    };
+};
+
+template<class T1, class T2>
+struct Y {
+
+    enum {
+       a = T1::a + T2::a,
+
+       // NB: if the next line is changed to
+       // n = (T1::n > T2::n) ? T1::n : T2::n
+       // the problem goes away.
+
+       n = meta_max<T1::n,T2::n>::max
+    };
+};
+
+int z = Y<X,X>::a;
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb120.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb120.C
new file mode 100644
index 00000000000..b94820cdfec
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb120.C
@@ -0,0 +1,22 @@
+template<double functionToIntegrate(double)>
+double integrate(double a, double b, int numSamplePoints)
+{
+  //    PRECONDITION(numSamplePoints > 1);
+    double delta = (b-a) / (numSamplePoints-1);
+    double sum = 0.;
+    for (int i=0; i < numSamplePoints; ++i)
+        sum += functionToIntegrate(a + i*delta);
+    return sum * (b-a) / numSamplePoints;
+}
+
+inline double myFunction(double x)
+{
+    return 1 / (1 + x);
+}
+
+// Example use
+int main() {
+double z = integrate<myFunction>(0.0, 1.0, 50);
+	return 0 ;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb121.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb121.C
new file mode 100644
index 00000000000..456615d67c5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb121.C
@@ -0,0 +1,21 @@
+//Build don't link:
+class A {
+private:
+  int i1_;
+public:
+  void f(int const i1 = 1); // ERROR - previous specification
+};
+
+void
+A::f(int const i1 = 1)
+{                          // ERROR - duplicate default argument
+  i1_ = i1;
+}
+
+int
+main()
+{
+  A a;
+  a.f();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb122.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb122.C
new file mode 100644
index 00000000000..9cf30333312
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb122.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+// Disable -ansi -pedantic-errors because of GNU extension
+// Special g++ Options:                                             
+template<class foo>
+class bar {
+public:
+  void baz() { (({ while( foo::baz() );})); }
+};
+template<class foo>
+void baz() { (({ while( foo::baz() );})); }
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb123.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb123.C
new file mode 100644
index 00000000000..dd729d48ae9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb123.C
@@ -0,0 +1,10 @@
+// Special g++ Options: -O2 -W   
+// Build don't link: 
+#include "stdio.h"
+
+void writeNote() throw( int )
+{
+    printf( "hello world\n" );
+    try { }
+    catch( int ){ throw; }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb124.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb124.C
new file mode 100644
index 00000000000..c9c7395b5de
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb124.C
@@ -0,0 +1,3 @@
+//Build don't link:
+#include <stdexcept>
+class X : public std::runtime_error {};
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb125.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb125.C
new file mode 100644
index 00000000000..aff6ae61007
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb125.C
@@ -0,0 +1,23 @@
+// This is a crash test; we don't care how many normal errors we get.
+// excess errors test - XFAIL *-*-*
+
+struct test_box
+    {
+     void print(void);
+    };
+
+void test<class BOX> (test_box *);   // ERROR - illegal code
+
+class test_square
+    {
+      friend void test<class BOX> (test_box *); // ERROR - does not match
+    }
+
+
+
+template <class BOX> void test(BOX *the_box)  // ERROR - semicolon missing
+    {
+    the_box->print();
+    };
+
+template void test<> (test_box *);
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb126.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb126.C
new file mode 100644
index 00000000000..8c634e87201
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb126.C
@@ -0,0 +1,29 @@
+#include <string.h>
+
+class SomeClass_t {
+public:
+  SomeClass_t () : x (11) {}
+protected:
+  float x;
+};
+
+class DynamicOnly_t {
+public:
+  static DynamicOnly_t* create (const char* name = "UNDEF",
+                                const SomeClass_t& somec = *(new SomeClass_t
+())) {
+    return new DynamicOnly_t (name, somec);
+  }
+  DynamicOnly_t (const char* name, const SomeClass_t& somec) :
+    m_somec (somec) {
+    strncpy (m_Name, name, sizeof (m_Name));
+  }
+private:
+  SomeClass_t m_somec;
+  char m_Name[255];
+};
+
+int main (int argc, char* argv[]) {
+  DynamicOnly_t* ptr = DynamicOnly_t::create ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb127.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb127.C
new file mode 100644
index 00000000000..cf5f69fc1a6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb127.C
@@ -0,0 +1,59 @@
+// Gets ICE 40.
+
+#include <vector>
+#include<string>
+
+using namespace std;
+
+class ODEsolver
+{
+    private:
+        void eulerODE(vector<double>& y, double& t, double& dt);
+        void midpointODE(vector<double>& y, double& t, double& dt);
+
+    protected:
+        void (ODEsolver::*useMethod)(vector<double>&, double&, double&);
+        void init();
+
+    public:
+        ODEsolver();
+        void timeloop(vector<double>& y, double ts, double te, double dt);
+};
+
+
+ODEsolver::ODEsolver()
+{
+  init();
+}
+
+
+void ODEsolver::eulerODE(vector<double>& y, double& t, double& dt)
+{
+  y[0] = dt * 2.;
+}
+
+void ODEsolver::midpointODE(vector<double>& y, double& t, double& dt)
+{
+  y[0] = dt * 3.;
+}
+
+
+
+void ODEsolver::init()
+{
+  ODEsolver::useMethod = &ODEsolver::midpointODE;
+}
+
+void ODEsolver::timeloop(vector<double>& y, double ts, double te, double dt)
+{
+  (ODEsolver::useMethod)(y,ts,dt);
+}
+
+int main (int nargs, char** args)
+{
+  ODEsolver solver;
+  vector<double> y(2);  double t_start=5.;  double t_end=7.;  double dt=2.;
+  solver.timeloop(y,t_start,t_end,dt);
+  cout << y[0] << endl;
+  return(0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb128.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb128.C
new file mode 100644
index 00000000000..d056e39012e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb128.C
@@ -0,0 +1,11 @@
+template<class T>
+struct A {
+  typedef T* iterator; // ERROR - pointer to reference
+public:
+  A(){}
+};
+
+void f()
+{
+  A<int&> a; // ERROR - instantiated from here
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb129.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb129.C
new file mode 100644
index 00000000000..a39d0c5b4cb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb129.C
@@ -0,0 +1,22 @@
+// Build don't link:
+// Gives ICE on EGCS release branch as of 98/06/08 on i686-pc-linux-gnulibc1)
+// From: Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de>    
+// Message-Id: <199806081358.PAA02505@achibm5.chemie.uni-karlsruhe.de> 
+#include <list>
+#include <functional>
+#include <algorithm>
+#include <cassert>
+int main()
+{
+      list<int> l;
+      l.push_back(1);
+      l.push_back(2);
+
+      list<int>::iterator it =
+              find_if( l.begin(), l.end(),
+                       // This is a typo, it should be bind2nd, but an
+                       // ICE is not a very helpful diagnostic!
+                       binder2nd( equal_to<int>(), 2 ) ); // ERROR - 
+      assert( *(it) == 2 );
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb13.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb13.C
new file mode 100644
index 00000000000..f0e48484302
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb13.C
@@ -0,0 +1,16 @@
+// Build don't link:
+template<class T>
+class Array {
+public:
+    typedef T T_numtype;
+};
+
+template<class T_array>
+void f(T_array, typename T_array::T_numtype)
+{
+}
+
+void g()
+{
+    f(Array<float>(), float());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb130.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb130.C
new file mode 100644
index 00000000000..48bbb8f9898
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb130.C
@@ -0,0 +1,11 @@
+// Build don't link:
+// Gives spurious warnings when compiled with -Wall
+// EGCS 06/08/98 i686-pc-linux-gnulibc1
+// Special g++ Options: -Wall
+// Message-Id: <199806081358.PAA02505@achibm5.chemie.uni-karlsruhe.de>
+// From: Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de>
+
+
+#include <hash_set>
+std::hash_set<int> foo;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb131.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb131.C
new file mode 100644
index 00000000000..d966fd9c01f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb131.C
@@ -0,0 +1,20 @@
+// Build don't link:
+// From: Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de> 
+// Reported against EGCS snaps 98/06/18.
+
+struct a {
+	a();
+	void junk( float );
+	void junk( double );
+
+	void bar( double );
+	void bar( float );
+
+  void foo( void (a::*member)(float) ); // ERROR - candidate
+};
+
+a::a()
+{
+	foo( &junk ); // ERROR - junk is an unqualified-id.
+	foo( &bar );  // ERROR - bar is an unqualified-id.
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb132.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb132.C
new file mode 100644
index 00000000000..5b6bc6a5842
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb132.C
@@ -0,0 +1,28 @@
+// Build don't link:
+// From: Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de> 
+// Reported against EGCS snaps 98/06/28.
+// Special g++ Options: -O -Wall  -fgcse -frerun-loop-opt
+//
+// Compilation of this program with the flags g++ -Wall -O -fgcse
+// -frerun-loop-opt or -O2 produces spurious warnings in the standard
+// header <std/bastring.h>.
+//
+// They vanish if the declaration of a::b is taken out.
+
+#include <string>
+
+string foo();
+struct a {
+	void bar();
+	enum b { c, d };
+	b theb;
+	string baz;
+};
+
+void
+a::bar()
+{
+	baz += foo() + foo();
+	baz += foo() + foo() + "foo";
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb133.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb133.C
new file mode 100644
index 00000000000..5ffdf9e6afe
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb133.C
@@ -0,0 +1,16 @@
+// Build don't link:
+// Gives ICE 109
+// From: Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de> 
+// Reported against EGCS snaps 98/06/28.
+
+int main()
+{
+	try {
+	}
+	catch (bad_alloc) { // ERROR - parse error
+		return 1;
+	}
+	return 0;
+}
+
+	
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb14.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb14.C
new file mode 100644
index 00000000000..de00e7baa6b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb14.C
@@ -0,0 +1,36 @@
+template<int N>
+struct I {
+};
+
+template<class T>
+struct A {
+
+  int r;
+
+  template<class T1, class T2>
+  void operator()(T1, T2)
+  { r = 0; }
+
+  template<int N1, int N2>
+  void operator()(I<N1>, I<N2>)
+  { r = 1; }
+};
+
+int main()
+{
+    A<float> x;
+    I<0> a;
+    I<1> b;
+
+    x(a,b);
+    if (x.r != 1)
+        abort();
+
+    x(float(), double());
+    if (x.r != 0)
+        abort();
+
+    return 0;
+}
+
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb15.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb15.C
new file mode 100644
index 00000000000..902d4631ac1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb15.C
@@ -0,0 +1,25 @@
+// Build don't link:
+#include<iostream.h>
+#include<stddef.h>
+
+struct A {
+  A() {
+    cerr<<"A constructing\n";
+    throw 1;
+  }
+  void *operator new(size_t sz) {
+    cerr<<"A allocated\n";
+    return ::operator new(sz);
+  }
+  void operator delete (void *p) {
+    cerr<<"A deleted\n";
+    ::operator delete (p);
+  }
+};
+
+int main() {
+  try {
+     new A();
+  } catch (...) {
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb16.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb16.C
new file mode 100644
index 00000000000..5dc259d2822
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb16.C
@@ -0,0 +1,14 @@
+// Build don't link:
+template<class T>
+struct A {
+    typedef T T1;
+};
+
+template<class T>
+struct B : T::T1 {           // insert `typename' before T::T1
+};
+
+struct C { };
+
+B<A<C> > z;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb17.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb17.C
new file mode 100644
index 00000000000..f32dadba9a5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb17.C
@@ -0,0 +1,56 @@
+// excess errors test - XFAIL
+// covariant return types in are currently not support for complex inheritance
+#include <stdio.h>
+
+class A {
+public:
+    virtual void print();
+    virtual A * clone();
+};
+
+class B : virtual public A {
+public:
+    void print();
+    B * clone();
+};
+
+void A::print()
+{
+    printf("A\n");
+}
+
+void B::print()
+{
+    printf("B\n");
+}
+
+
+A * A::clone()
+{
+    return this;
+}
+
+B * B::clone()
+{
+    return this;
+}
+
+
+int main()
+{
+    A * a = new B;
+    B * b = dynamic_cast<B *>(a);
+
+    printf("%p\n",b);                // (*2*)
+    b->print();
+
+    a = b;
+    printf("%p\n",a);
+    a->print();
+
+    a = a->clone();
+    printf("%p\n",a);
+    a->print();                      // (*1*)
+
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb18.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb18.C
new file mode 100644
index 00000000000..fd953fe0710
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb18.C
@@ -0,0 +1,8 @@
+// Build don't link:
+class C { };
+
+void foo()
+{
+    C c;
+    void * v = static_cast<void *>(c);  // ERROR - illegal cast
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb19.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb19.C
new file mode 100644
index 00000000000..a5ddd36c7bd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb19.C
@@ -0,0 +1,16 @@
+// Build don't link:
+
+#define CRASH 1
+#ifdef CRASH
+#define VIRTUAL virtual
+#else
+#define VIRTUAL
+#endif
+
+class A {};
+class B : public VIRTUAL A {};
+template <class Imp> class C : public /*virtual*/ Imp {};
+// define CRASH and uncomment here    ^^^^^^^^^^^
+// and the crash goes away!!!!
+
+template class C<B>;
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb2.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb2.C
new file mode 100644
index 00000000000..b20002121a1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb2.C
@@ -0,0 +1,17 @@
+// Build don't link: 
+typedef __SIZE_TYPE__ size_t;
+inline void *operator new(size_t, void *place) throw() { return place; }
+
+struct A
+{
+    A();
+    ~A();
+};
+
+void testfunc( void )
+{
+   A*    mybuf;
+   A        v[1];
+
+   new (mybuf) A();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb20.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb20.C
new file mode 100644
index 00000000000..08c76d0f97e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb20.C
@@ -0,0 +1,33 @@
+// Error: ICE on 2.7.2.3 and EGCS 1.0.0.
+// Build don't link:
+
+template<int N1, int N2>
+struct meta_max {
+    enum { max = (N1 > N2) ? N1 : N2 };
+};
+
+struct X {
+    enum {
+       a = 0,
+       n = 0
+    };
+};
+
+template<class T1, class T2, class T3>
+struct Y {
+
+    enum {
+       a = T1::a + T2::a + T3::a,
+       n = meta_max<meta_max<T1::n,T2::n>::max, T3::n>::max
+    };
+};
+
+template<class T>
+struct Z {
+    enum {
+       a = T::a,
+       n = T::n
+    };
+};
+
+Z<Y<X,X,X> > z;
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb21.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb21.C
new file mode 100644
index 00000000000..b3468d9e82f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb21.C
@@ -0,0 +1,22 @@
+#include <vector>
+
+#include <strstream.h>
+
+/*----------------------------------------*/
+
+struct connection_t {
+  connection_t() {}
+};
+
+vector<connection_t> connections;
+
+/*----------------------------------------*/
+
+int
+main() {
+  ostrstream str;
+
+  connections.insert(connections.end(), connection_t());
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb22.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb22.C
new file mode 100644
index 00000000000..bfe513b46db
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb22.C
@@ -0,0 +1,26 @@
+// Ambiguous conversion, three candidates:
+// builtin == (int, int), and the two user-defined operators
+// Each one requires a user-defined ICS where another uses builtin conversions,
+// so none is the best viable function.
+
+class MyInt
+{
+public:
+        MyInt(int = 0) {}
+        operator int() const {return 2;}
+};
+
+bool operator==(const MyInt& a, const int& b)
+{                                               // ERROR - candidate
+        return (int)a == b;
+}
+
+bool operator==(const MyInt& a, const MyInt& b)
+{                                               // ERROR - candidate
+        return (int)a == (int)b;
+}
+
+bool f()
+{
+  return 3 == MyInt();                          // ERROR - ambiguous
+}                                               // ERROR - no return value
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb23.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb23.C
new file mode 100644
index 00000000000..8a0602a8235
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb23.C
@@ -0,0 +1,20 @@
+// Build don't link:
+class foo {
+protected:
+  void __duplicate ();
+
+};
+
+class bar : public virtual foo  {
+protected:
+    void __duplicate() {
+       foo::__duplicate ();
+    }
+};
+
+class oops : public virtual bar {
+protected:
+    void __duplicate() {
+       foo::__duplicate ();
+    }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb24.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb24.C
new file mode 100644
index 00000000000..b1f01043817
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb24.C
@@ -0,0 +1,23 @@
+// Build don't link:
+#include <iostream.h>
+
+template < class T >
+class X
+{
+  protected:
+
+    union {
+        int     x;
+        double  y;
+    };
+};
+
+template < class T >
+class Y : public X<T>
+{
+  public:
+
+    using X<T>::x;
+
+    void        f () { cout << x << endl; }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb26.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb26.C
new file mode 100644
index 00000000000..2374b557346
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb26.C
@@ -0,0 +1,30 @@
+//
+// egcs-2.90.06
+// cannot declare friend of enclosing class using its scope, works fine
+// without scope or for definition of foo::bar::f
+//
+
+class foo
+{
+public:
+  static int f();
+  class bar {
+    friend int foo::f();
+//  friend int f();
+    static int x;
+  public:
+    static int f() {return foo::f();};
+   };
+};
+
+int foo::bar::x;
+
+int foo::f() {
+  return bar::x;
+}
+
+int
+main ()
+{
+  return foo::bar::f ();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb27.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb27.C
new file mode 100644
index 00000000000..9e44f3af8b9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb27.C
@@ -0,0 +1,39 @@
+/* bug.cc */
+/* simple program to demonstrate the bug with named return values in gcc
+*/
+/* (w) 4.9.97 by Kurt Garloff <K.Garloff@ping.de> */
+// Special g++ Options:
+// 8/28/1998 - This dies in add_conversions from dfs_walk, null CLASSTYPE_METHOD_VEC
+// for the test<T> record_type.  This is marked as an expected failure for now,
+// until we actually fix it.
+
+#include <iostream.h>
+
+template <class T> class test;
+template <class T> test<T> operator + (const test<T>& a, const test<T>& b);
+
+// A simple numerical class
+template <class T>
+class test
+{
+   T elem;
+ public:
+   test ()  { elem = 0; };
+   test (const T& a)  { elem = a; };
+   test<T>& operator += (const test<T>& a)  { elem += a.elem; return *this; };
+   friend test<T> operator + <> (const test<T>&, const test<T>&);
+   friend ostream& operator << (ostream& os, const test<T>& a)
+     { return os << a.elem; };
+};
+
+// named return value version
+template <class T>
+test<T> operator + (const test<T>& a, const test<T>& b) return c(a);
+{ c += b; };
+
+int main()
+{
+   test<int> x, y;
+   x += 5; cout << x << endl;
+   y = x + test<int>(2); cout << y << endl;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb28.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb28.C
new file mode 100644
index 00000000000..6c3130eafa5
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb28.C
@@ -0,0 +1,17 @@
+//Build don't link: 
+#include <vector.h>
+enum s { S };
+class a
+{
+        vector<s> vs;
+        friend class b;
+};
+struct b
+{
+        vector<a> va;
+        operator vector< vector<s> >()
+        {
+                vector< vector<s> > vvs(va.size());
+                return vvs;
+        }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb29.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb29.C
new file mode 100644
index 00000000000..f1017a774a7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb29.C
@@ -0,0 +1,16 @@
+//Build don't link: 
+#include <vector.h>
+enum s { S };
+class a
+{
+        vector<s> vs;
+        friend class b;
+};
+struct b
+{
+        vector<a> va;
+        operator vector< vector<s> >()
+        {
+                return vector< vector<s> >(va.size());
+        }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb3.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb3.C
new file mode 100644
index 00000000000..d257043e46a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb3.C
@@ -0,0 +1,11 @@
+// Build don't link:
+#include <complex.h>
+template<class T>
+class Vec {
+public:
+    Vec() { data = new T; }
+    Vec<T> split() { Vec<T> tmp; operator=(tmp); return tmp; }
+    void operator=(const Vec<T> &v) { data = new T; }
+    T *data;
+};
+template class Vec<complex<double> >;
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb30.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb30.C
new file mode 100644
index 00000000000..c116ab4cd4d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb30.C
@@ -0,0 +1,16 @@
+// Build don't link:
+#include <fstream.h>
+
+class bifstream : public ifstream {
+public:
+    bifstream();
+//     ~bifstream();
+};
+
+void load_bin()
+{
+    bifstream InFile;
+
+    if (!InFile)
+        return;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb31.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb31.C
new file mode 100644
index 00000000000..1a18af5b4c8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb31.C
@@ -0,0 +1,17 @@
+#include<iostream.h>
+
+int main() {
+  try {
+    throw 1;
+  } catch(...) {
+   try {
+     throw;
+   } catch(int) {
+   }
+   try {
+     throw;
+   } catch(int) {
+   }
+  }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb32.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb32.C
new file mode 100644
index 00000000000..95e16178298
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb32.C
@@ -0,0 +1,12 @@
+// Build don't link:
+class A {
+public:
+    void malloc(unsigned int);
+};
+
+void A::malloc(unsigned int) {}
+
+void foo() {
+    A a;
+    a.malloc(3);    // <-- line 10
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb33.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb33.C
new file mode 100644
index 00000000000..3797ab3740f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb33.C
@@ -0,0 +1,11 @@
+#include <fstream.h>
+#include <stdio.h>
+
+int
+main()
+{
+    printf("If you see this, you don't have a problem!\n");
+#ifdef EXPOSE_BUG
+    ifstream a;
+#endif
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb34.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb34.C
new file mode 100644
index 00000000000..08167b5d981
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb34.C
@@ -0,0 +1,19 @@
+// Build don't link:
+class Base {
+public:
+  class Bar { public: virtual ~Bar() {}; };
+};
+
+class Derived : public Base {
+public:
+  class Bar : public Base::Bar {};
+};
+
+template <class T>
+class XYZ : public T::Bar {
+};
+
+void test() {
+  XYZ<Base> b;
+  XYZ<Derived> d;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb35.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb35.C
new file mode 100644
index 00000000000..e28fb4925f6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb35.C
@@ -0,0 +1,38 @@
+// Build don't link:
+
+class string
+{
+public:
+    string();
+    string(const string& x);
+    string(const char* t);
+
+    ~string();
+};
+
+void set_status(string message);
+
+class StatusDelay {
+private:
+    string cause;
+
+public:
+    StatusDelay(const string& c)
+        : cause(c)
+    {
+        set_status(cause);
+    }
+
+    ~StatusDelay()
+    {
+        set_status(cause);
+    }
+};
+
+static char delay_message[] = "Filtering files";
+
+static void searchRemote()
+{
+    StatusDelay delay(delay_message);
+    return;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb36.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb36.C
new file mode 100644
index 00000000000..415e5bdf6f4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb36.C
@@ -0,0 +1,17 @@
+#include <vector>
+
+template <typename T=float> class foo {
+public:
+  foo();
+  foo(vector<int> v);
+private:
+  vector<int> v;
+  T t;
+};
+
+template <typename T>
+foo<T>::foo()               :v(),   t() {}
+template <typename T=float>
+foo<T>::foo(vector<int> v_) :v(v_), t() {} // ERROR - default arg for member template
+
+foo<float> a;
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb37.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb37.C
new file mode 100644
index 00000000000..be4b57d8751
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb37.C
@@ -0,0 +1,26 @@
+// Build don't link: 
+template<class T>
+struct A {
+    typedef T T1;
+};
+
+template<class T>
+struct B {
+    typedef T T2;
+};
+
+template<class T>
+struct C {
+};
+
+template<class E>
+C<typename E::T2::T1>
+foo (E)
+{
+    return C<typename E::T2::T1>();
+}
+
+void test()
+{
+    foo(B<A<int> >());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb38.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb38.C
new file mode 100644
index 00000000000..9a75405d129
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb38.C
@@ -0,0 +1,37 @@
+// Build don't link: 
+class string
+{
+public:
+    string();
+    string(const string& x);
+    string(const char* t);
+
+    ~string();
+};
+
+void set_status(string message);
+
+class StatusDelay {
+private:
+    string cause;
+
+public:
+    StatusDelay(const string& c)
+        : cause(c)
+    {
+        set_status(cause);
+    }
+
+    ~StatusDelay()
+    {
+        set_status(cause);
+    }
+};
+
+static char delay_message[] = "Filtering files";
+
+static void searchRemote()
+{
+    StatusDelay delay(delay_message);
+    return;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb39.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb39.C
new file mode 100644
index 00000000000..feefca77ad9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb39.C
@@ -0,0 +1,16 @@
+// Build don't link: 
+#include <ctype.h>
+#include <iostream.h>
+// #include <streambuf.h>
+#include <libio.h>
+#include <strstream.h>
+
+extern bool foo2 (ostream &out, istream &in);
+
+bool
+foo1 (ostream &out, const char *in)
+{
+  strstreambuf sb (in, (int) strlen (in));
+  istream fmt (&sb);
+  return foo2 (out, fmt);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb4.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb4.C
new file mode 100644
index 00000000000..b51d3eafb98
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb4.C
@@ -0,0 +1,48 @@
+// Error: Internal Compiler Error in GCC 2.7.2 and EGCS 1998/05/28 snapshot.
+
+#include <iostream.h>
+
+class some_base
+        {
+public:
+        class base_func_args;
+        virtual void func(base_func_args &) = 0; // ERROR - referenced below
+        };
+
+class some_base::base_func_args
+        {
+public:
+        int i;
+        };
+
+class some_derived : public some_base
+        {
+public:
+        class derived_func_args;
+        void func(derived_func_args &);
+        };
+
+
+class derived_func_args : public some_base::base_func_args
+        {
+public:
+        float f;
+        };
+
+class some_derived::func(derived_func_args &a)  // ERROR - illegal member syntax
+        {
+        cout << a.i << ' ' << a.f << endl;
+        }
+
+int
+main()
+        {
+	some_derived d;                     // ERROR - abstract class
+        some_derived::derived_func_args dfa; // ERROR - incomplete class
+        some_base *b = &d;
+
+        dfa.i = 10;
+        dfa.f = 20;
+        b->func(dfs);                       // ERROR - dfs not declared
+        return 0;
+        }
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb41.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb41.C
new file mode 100644
index 00000000000..3c97e01844e
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb41.C
@@ -0,0 +1,13 @@
+#include <iostream.h>
+#include <iterator.h>
+#include <string>
+
+ostream_iterator<string> oo(cout);
+
+int main()
+{
+    *oo = "Hello, ";
+    ++oo;
+    *oo = "world!\n";
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb43.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb43.C
new file mode 100644
index 00000000000..7f8647226c8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb43.C
@@ -0,0 +1,38 @@
+// All the pointer_to_binary_function cases used to fail because g++
+// couldn't handle converting an overloaded function to a class type.
+// The first one should still fail because it requires an implicit conversion
+// to pointer_to_binary_function, which has an `explicit' constructor.
+
+#include <vector.h>
+#include <algo.h>
+
+template <class T> class Expr 
+{
+public :
+  Expr(){};
+  Expr(const T&){};
+};
+
+template <class T >
+inline bool compare(const Expr<T> a, const Expr<T> b){ return true; };
+
+int main()
+{
+  vector<int>	a(3);
+  sort( a.begin(), a.end(),
+	static_cast<bool (*)(const Expr<int>,const Expr<int>)>(compare) );
+  sort( a.begin(), a.end(), compare<int> );
+  sort<vector<int>::iterator,
+       pointer_to_binary_function<const Expr<int>, const Expr<int>, bool> >
+    ( a.begin(), a.end(), compare ); // ERROR - constructor is explicit
+  sort( a.begin(), a.end(),
+	ptr_fun<const Expr<int>, const Expr<int>, bool> (compare) );
+  sort( a.begin(), a.end(),
+	ptr_fun(compare<int>) );
+  sort( a.begin(), a.end(),
+	pointer_to_binary_function<const Expr<int>, const Expr<int>, bool>(compare) );
+  sort( a.begin(), a.end(),
+	pointer_to_binary_function<const Expr<int>, const Expr<int>, bool>(compare<int>) );
+  sort( a.begin(), a.end(),
+	pointer_to_binary_function<const Expr<int>, const Expr<int>, bool>(compare<>) );
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb44.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb44.C
new file mode 100644
index 00000000000..54eab153609
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb44.C
@@ -0,0 +1,35 @@
+// spurious 'const' in error.
+// For egcs-2.91.34, the warning message refers to
+// class ostream & operator <<(class ostream &, const class Vector<T> &)
+// Also, the template instantiation does not provide the missing
+// friend function, the non-template function does
+
+#include <stdio.h>
+#include <iostream.h>
+
+template <class T>
+class Vector
+{
+  friend ostream& operator<< (ostream& out, const Vector<T> & vec); // WARNING - 
+};
+
+template <class T>
+ostream& operator<< (ostream& out,  const Vector<T> & vec)
+{
+  abort();  // this should not be called
+}
+
+template class Vector<char>;
+template ostream& operator<< (ostream& out,  const Vector<char> &);
+
+ostream& operator<< (ostream& out, const Vector<char>&)
+{
+  return out;
+}
+
+int main()
+{
+  Vector<char> vc;
+  ostream out;
+  out << vc;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb45.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb45.C
new file mode 100644
index 00000000000..9e2642c2a42
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb45.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+class A {};
+class B : public virtual A {};
+template <class Imp> class C : public Imp {};
+
+template class C<B>;
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb46.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb46.C
new file mode 100644
index 00000000000..ad077e38dc3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb46.C
@@ -0,0 +1,27 @@
+#include <iostream.h>
+
+class A1 {
+        friend class B;
+ public:
+        virtual void foo() {};
+};
+
+class A2 : public virtual A1 {friend class B;};
+
+class A3 : public virtual A1, private A2 {friend class B;};
+
+class B
+{
+ public:
+        B(A1* a) : itsA(dynamic_cast<A2*>(a)) {};
+        A2* itsA;
+};
+
+int main()
+{
+        A1* a=new A3;
+        B b(a);
+
+        if (b.itsA) cout << "cast ok" << endl; else cout << "cast failed" << endl;
+        return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb48.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb48.C
new file mode 100644
index 00000000000..1d10bed5c03
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb48.C
@@ -0,0 +1,10 @@
+// Build don't link: 
+char *t1 (const char *s)
+{
+  return const_cast<char *>(s);
+}
+
+char *&t1 (const char *&s)
+{
+  return const_cast<char *&>(s);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb49.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb49.C
new file mode 100644
index 00000000000..95c454eaef1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb49.C
@@ -0,0 +1,49 @@
+// Build don't link:
+// excess errors test
+
+// Here we declare ::S
+typedef struct s1 *S;
+
+struct s1
+{
+  int s;
+};
+
+struct A
+{
+  // Here we declare A::S
+  typedef struct s1 *S;
+};
+
+template<class T, class U> class XX;
+
+template<class T, class U>
+class X
+{
+public:
+  static T *do_something ();
+  friend class T; // ERROR - `T' is a template parameter
+  friend class XX<T, U>;
+};
+
+struct N
+{
+  // Here we declare N::S
+  class S
+  {
+  };
+
+  // Should use N::S and A::S.
+  typedef X<S, A::S> X_S;
+
+  void bug ();
+};
+
+void
+N::bug ()
+{
+  // X_S is template class X<N::S, A::S>
+  // `s' is N::S.
+  S *s = X_S::do_something ();
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb5.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb5.C
new file mode 100644
index 00000000000..6609be8c0dd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb5.C
@@ -0,0 +1,13 @@
+// Build don't link:
+enum { a, b };
+
+class Bug {
+  int pri:8;
+  int flags:24;
+public:
+  void bug() {
+    flags |= a;   // this does not work
+  }
+};
+
+void dummy(Bug x) { x.bug(); }
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb50.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb50.C
new file mode 100644
index 00000000000..c7f90766af2
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb50.C
@@ -0,0 +1,16 @@
+struct foo { };
+int f(int a, int b)
+{
+        if (b == 0)
+                throw foo();
+        return a / b;
+}
+int main()
+{
+        try {
+                f(0, 0);
+                return 1;
+        } catch (foo x) {
+                return 0;
+        }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb51.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb51.C
new file mode 100644
index 00000000000..0357f92ba66
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb51.C
@@ -0,0 +1,36 @@
+// Build don't link: 
+typedef unsigned long   Xv_opaque;
+
+class DynaString
+{
+public:
+    DynaString();
+    DynaString( const DynaString& dynaStr );
+    DynaString( const long n );
+    ~DynaString();
+
+    int operator ==( const char* const string ) const;
+};
+
+class DDE_Defaults
+{
+public:
+        DynaString      GetHost();
+        DynaString      GetService();
+        DynaString      GetDatabase();
+};
+
+extern DDE_Defaults* ddeDefaults;
+
+void
+f()
+{
+        DynaString tempHost, tempService, tempDatabase;
+        if(     (tempHost = ddeDefaults->GetHost()) == 0
+                || (tempService = ddeDefaults->GetService()) == 0
+                || (tempDatabase = ddeDefaults->GetDatabase()) == 0
+        )
+        {
+        }
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb52.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb52.C
new file mode 100644
index 00000000000..50b45169ab8
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb52.C
@@ -0,0 +1,37 @@
+// Build don't link: 
+class base {
+protected:
+    virtual void f();
+};
+
+class d1 : public virtual base {
+protected:
+    void f();
+};
+
+void d1::f()
+{
+    base::f();
+}
+
+class dd1 : public virtual d1 {
+protected:
+     void f();
+};
+
+void dd1::f()
+{
+    d1::f();
+    base::f();
+}
+
+class d1_and_base : public virtual d1, public virtual base {
+protected:
+     void f();
+};
+
+void d1_and_base::f()
+{
+    d1::f();
+    base::f();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb54.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb54.C
new file mode 100644
index 00000000000..dfcf3a9e927
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb54.C
@@ -0,0 +1,7 @@
+#include <iomanip.h>
+
+int main()
+{
+	cout << setbase(3) << endl;
+	exit (0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb55.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb55.C
new file mode 100644
index 00000000000..4ba4b54eff0
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb55.C
@@ -0,0 +1,12 @@
+// Build don't link: 
+// Since the constructor is in streambuf.h, additional diagnostics are
+// produced, which are not really supported in the old-deja framework
+// excess errors test - XFAIL *-*-*
+#include <strstream.h>
+
+void
+t( char* buf )
+{
+  istrstream str = buf;  //ERROR - inaccessible copy constructor
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb56.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb56.C
new file mode 100644
index 00000000000..2d497f8b4e3
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb56.C
@@ -0,0 +1,9 @@
+// Error: Internal compiler error on 1998/05/28 snapshot.
+// Build don't link:
+
+class foo {
+        typedef int sometype;
+};
+
+struct die : public foo::sometype { // ERROR - invalid base type
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb57.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb57.C
new file mode 100644
index 00000000000..5f7de55559d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb57.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+#include <exception>
+//using namespace std;
+class A {
+    class B : public std::exception {}
+    ;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb58.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb58.C
new file mode 100644
index 00000000000..3612034bf70
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb58.C
@@ -0,0 +1,14 @@
+// Special g++ Options:
+// Test for g++ array init extension 
+
+class A {
+public:
+        A(int i) {}
+private:
+        A( const A & ) {}
+};
+
+main()
+{
+  A *list = new A[10](4);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb59.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb59.C
new file mode 100644
index 00000000000..7c0c1534ae4
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb59.C
@@ -0,0 +1,28 @@
+#define INC_FUNCTIONAL  1
+#define USE_STATIC_CAST 1
+
+#include <vector>
+#include <numeric>
+#ifdef INC_FUNCTIONAL
+#include <functional>
+#endif
+
+template<class R> int p( int val, R& r )
+{
+   return val + r;
+}
+
+template<class R> void f( vector<R>& v )
+{
+#ifdef USE_STATIC_CAST
+   accumulate( v.begin(), v.end(), 0, static_cast<int (*)(int, R&)>(p) );
+#else
+   accumulate( v.begin(), v.end(), 0, p<R> );
+#endif
+}
+
+int main()
+{
+   vector<int> r;
+   f( r );
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb6.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb6.C
new file mode 100644
index 00000000000..157bf472f1a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb6.C
@@ -0,0 +1,14 @@
+// Build don't link:
+class A {
+public:
+  A() { t=0; }
+  double t;
+};
+template <class T>
+class B {
+public:
+  void f1() { new T; f2(); }
+  void f2() { new T; }
+};
+template class B<A>;
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb60.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb60.C
new file mode 100644
index 00000000000..64ca71d9606
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb60.C
@@ -0,0 +1,18 @@
+//Build don't link:
+#include <string>
+
+class t {
+public:
+       t(const string& s) : s_(s) {}
+       string s_;
+       static t* t_;
+};
+
+t* t::t_;
+
+t* makeT()
+{
+       return new t("test");
+       return t::t_ ? t::t_ :
+        t::t_ = new t("test");
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb61.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb61.C
new file mode 100644
index 00000000000..370273ae26d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb61.C
@@ -0,0 +1,8 @@
+// Build don't link: 
+void
+action0(float& arg1)
+{
+  long cn0 = 1;
+
+  arg1 = cn0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb62.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb62.C
new file mode 100644
index 00000000000..02646b2fb8a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb62.C
@@ -0,0 +1,7 @@
+//Build don't link: 
+#include <vector>
+
+void f(void)
+{
+  vector<int> l(5, 0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb63.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb63.C
new file mode 100644
index 00000000000..0e8559124d6
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb63.C
@@ -0,0 +1,15 @@
+//Special g++ Options:
+//This uses GNU extensions, so disable -ansi
+#include <stdio.h>
+
+class A {
+public:
+        A(bool b) { abort(); }
+        A(int a, bool b) { printf("cool\n"); }
+};
+
+main() {
+        A* a;
+	a = new A[2] = { A(1,false), A(1,false) } ;
+        a = new A[2](1,false);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb64.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb64.C
new file mode 100644
index 00000000000..da043af5191
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb64.C
@@ -0,0 +1,25 @@
+// Build don't link: 
+template <class A>
+class B:public A {
+  B(){}
+};
+
+template <class A>
+class C:public B<A> {
+  C(){}
+};
+
+/*
+g++  bugsol.C
+bugsol.C:9: Internal compiler error.
+bugsol.C:9: Please submit a full bug report to `egcs-bugs@cygnus.com'.
+
+g++ -v
+Reading specs from
+/home/pierre/local/lib/gcc-lib/i586-pc-linux-gnulibc1/egcs-2.90.16/specs
+gcc version egcs-2.90.16 971105 (gcc2-970802 experimental)
+
+egcc compiled with gcc version 2.7.2.1 on debian 1.3.1
+
+*/
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb65.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb65.C
new file mode 100644
index 00000000000..94be7ecbdb7
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb65.C
@@ -0,0 +1,22 @@
+#include <iterator>
+
+template<size_t n, size_t i> struct PartialDotProduct {
+    template<class T>
+    static T Expand(T* a, T* b) { return T(); }
+};
+
+const int N = 10;
+
+template<class In1, class In2>
+typename iterator_traits<In1>::value_type
+dot(In1 f1, In2 f2)
+{
+    return PartialDotProduct<N, 0>::Expand(f1, f2);     // line 14
+}
+
+int main()
+{
+    double a[N], b[N];
+
+    double s = dot(&a[0], &b[0]);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb66.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb66.C
new file mode 100644
index 00000000000..d79865f21d9
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb66.C
@@ -0,0 +1,22 @@
+#include <assert.h>
+#include <iostream.h>
+
+int bar ()
+{
+  throw 100;
+}
+
+int main ()
+{
+  int i = 0;
+  try
+    {
+      i = bar ();
+    }
+  catch (...)
+    {
+    }
+
+//  cout << "i = " << i << endl;
+  assert (i == 0) ; 
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb67.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb67.C
new file mode 100644
index 00000000000..45cdedd995c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb67.C
@@ -0,0 +1,6 @@
+// Build don't link: 
+/*
+Check whether a typedef for a basic type as a baseclass is diagnosed.
+*/
+typedef int an_int;
+class bar : public an_int {}; // ERROR - not an aggregate 
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb69.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb69.C
new file mode 100644
index 00000000000..9cc5f4a3ffe
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb69.C
@@ -0,0 +1,9 @@
+        #include <iostream.h>
+        struct foo {
+                foo(int x) { cerr << "foo's int constructor (" << x << ")\n"; };
+        };
+        struct bar : foo {
+                typedef int an_int;
+                bar() : bar::an_int(3) {};  // will call foo::foo(3)
+        };
+int main() { bar b; }
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb7.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb7.C
new file mode 100644
index 00000000000..fc43aab4179
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb7.C
@@ -0,0 +1,16 @@
+// Build don't link:
+#include <vector>
+
+class T
+{
+  public:
+  T();
+
+};
+
+vector <T> tp;
+
+void f()
+{
+      tp.insert(tp.begin(), 10 , T());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb70.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb70.C
new file mode 100644
index 00000000000..30da1845973
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb70.C
@@ -0,0 +1,17 @@
+// conversion ops should be treated as coming from the most derived class
+// for overload resolution.  See [over.match.funcs].
+// Build don't link:
+
+class X {
+public:
+  operator bool() const;
+};
+
+class Y : public X {
+private:
+  operator void*() const;
+};
+
+int f(Y const& y) {
+  return bool(y);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb71.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb71.C
new file mode 100644
index 00000000000..1417c4ab891
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb71.C
@@ -0,0 +1,37 @@
+// Build don't link: 
+typedef __SIZE_TYPE__ size_t;
+
+class   A {
+
+public:
+  void          operator delete(void*, size_t);
+  void*         operator new(size_t);
+};
+
+class   B   : public A  {
+friend class   D;
+
+  B();
+  unsigned      counter;
+};
+
+class   D {
+
+  int                   ins( B*&);
+};                    //WARNING - only private members
+
+int
+D::ins( B*& tempN)
+{
+  unsigned i;
+
+  if (i == 10) {
+  }
+  else {
+  }
+
+  tempN = new B();
+  tempN->counter = 20;
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb73.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb73.C
new file mode 100644
index 00000000000..b5aae397a8a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb73.C
@@ -0,0 +1,14 @@
+// Special g++ Options: -O -Wall
+// Depeletes VM.
+
+#include <iostream.h>
+#include <list>
+#include <algorithm>
+using namespace std;
+
+int main()
+{
+    int daten [16] = { 1, 4, 4, 6, 1, 2, 2, 3, 6, 6, 6, 5, 7, 5, 4, 4};
+    list<int> menge;
+    copy (daten, daten+16, back_inserter(menge));
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb74.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb74.C
new file mode 100644
index 00000000000..1ec7da6cc71
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb74.C
@@ -0,0 +1,33 @@
+// Build don't link: 
+class base {
+public:
+        virtual ~base();
+};
+
+
+class foo : public base {
+
+public :
+
+     foo (char *cs);
+
+     virtual void op (unsigned char dummy = false);
+     unsigned char m_dummy;
+};
+
+
+void foo :: op ( unsigned char dummy)
+
+{
+    bool bar;
+
+    if (dummy) {
+        foo IT_tempPhase( 0 );
+        return;
+    }
+
+    if ((m_dummy || bar)) {
+
+    }
+
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb75.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb75.C
new file mode 100644
index 00000000000..41ad816bddd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb75.C
@@ -0,0 +1,19 @@
+// Build don't link: 
+int*& foo (int const *& x)
+{
+  return const_cast<int*&> (x);
+}
+
+/*
+If the references in this example are changed to pointers (change
+all `&''s to `*'), no warnings result.
+
+I think this is incorrect according to CD2 5.2.11, para 4:
+
+4 An  lvalue of type T1 can be explicitly converted to an lvalue of type
+  T2 using the cast const_cast<T2&> (where T1 and T2 are  object  types)
+  if  a pointer to T1 can be explicitly converted to the type pointer to
+  T2 using a const_cast.  The result of a reference const_cast refers to
+  the original object.
+
+*/
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb76.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb76.C
new file mode 100644
index 00000000000..e2817eefd09
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb76.C
@@ -0,0 +1,19 @@
+//Build don't link:
+// the template operator!= interferes.  It should be in a namespace.
+// excess errors test - XFAIL *-*-*
+
+#include <utility>
+
+enum T {
+  V1
+};
+
+struct X {
+  T      t : 31;
+};
+
+void
+f(X& v) {
+  if( v.t != V1 ) {		// complains about taking address of bitfield
+  }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb77.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb77.C
new file mode 100644
index 00000000000..206b27dbf22
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb77.C
@@ -0,0 +1,30 @@
+#include <stream.h>
+#include <strstream.h>
+
+int
+main(int, char* [])
+{
+  strstream s;
+
+  s << "line 1\nline 2\n\nline 4";
+  s << ends;
+
+  int nLine = 0;
+
+  while( true ) {
+    char* line = 0;
+    s.gets(&line);
+
+    if( ! line ) {
+      break;
+    }
+
+    ++nLine;
+    cout << nLine << ": " << line << endl;
+
+    if( nLine > 10 ) {  // stop infinite loop
+      break;
+    }
+  }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb79.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb79.C
new file mode 100644
index 00000000000..5691532b99f
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb79.C
@@ -0,0 +1,23 @@
+// Makes bogus x86 assembly code.
+#include <iostream.h>
+
+template<class T>
+T max(T a, T b)
+{
+  return (a > b) ? a : b;
+}
+
+// Prototypes (enable one or the other)
+double max<>(double, double);      // ERROR - bogus code
+// int max(int, int);
+
+int main()
+{
+  int i = 123;
+  double d = 1234.5678;
+
+  cout.precision(12);
+  cout << max(d, i) << endl;  // #1
+  cout << max(i, d) << endl;  // #2
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb8.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb8.C
new file mode 100644
index 00000000000..213bb6de90b
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb8.C
@@ -0,0 +1,13 @@
+
+class foo {
+public:
+  operator <<(const void *);  //ERROR - no return type
+  operator <<(char *);        //ERROR - no return type
+};
+
+void main()
+{                             //ERROR - wrong return type for main
+  foo f;
+  f << (void*)0;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb80.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb80.C
new file mode 100644
index 00000000000..71614236558
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb80.C
@@ -0,0 +1,7 @@
+// Build don't link: 
+#include <exception>
+
+class A {
+    class B : public std::exception {}
+    ;
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb81.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb81.C
new file mode 100644
index 00000000000..919fd58b0fe
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb81.C
@@ -0,0 +1,42 @@
+// Build don't link: 
+class   x
+{
+public:
+        x   (int init_buffer_size=0);
+        ~x   ();
+};
+
+
+
+class   xSequence
+{
+public:
+        xSequence   ();
+        ~xSequence   ();
+        x   Get(int index)const;
+};
+
+
+
+class   foo
+{
+public:
+        bool bar(const x   & name, x    & value);
+
+};
+
+
+
+bool foo::bar(const x  & name, x    & value)
+{
+        bool result = false;
+
+        xSequence    seq;
+        x    v1, v2;
+        if(result ? bar(seq.Get(1),v2) : bar(seq.Get(2),v2))
+
+                ;
+
+        return result;
+}
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb82.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb82.C
new file mode 100644
index 00000000000..1e4d8c6249c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb82.C
@@ -0,0 +1,12 @@
+#include <stdio.h>
+
+template <int n1>
+double val <int> ()
+{                          // ERROR - bogus code
+   return (double) n1;
+};
+
+int main ()
+{
+   printf ("%d\n", val<(int)3> ());
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb83.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb83.C
new file mode 100644
index 00000000000..7121e140078
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb83.C
@@ -0,0 +1,16 @@
+// Skip if not native
+// Special g++ Options: -fprofile-arcs -ftest-coverage
+void
+swap(int& x, int& y) throw()
+{
+  int tmp = x;
+  x = y;
+  y = tmp;
+}
+
+main()
+{
+  int i = 5;
+  int j = 7;
+  swap(i, j);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb84.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb84.C
new file mode 100644
index 00000000000..dce51d86d52
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb84.C
@@ -0,0 +1,17 @@
+// Error: Internal Compiler error on GCC 2.7.2.3 & EGCS 1998/05/23 snapshot.
+
+class A {
+public:
+        enum { ONE, TWO, THREE };
+};
+
+template <const unsigned c1,const unsigned c2,const unsigned c3>
+void f() {
+
+}
+
+int
+main()
+{
+        f<A::ONE,A::TWO,A::THREE>();
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb86.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb86.C
new file mode 100644
index 00000000000..463d2d1cb60
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb86.C
@@ -0,0 +1,5 @@
+// Build don't link: 
+template <class T>
+class Q {
+    friend void foo<T> ();
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb87.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb87.C
new file mode 100644
index 00000000000..eee6ff67a75
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb87.C
@@ -0,0 +1,6 @@
+template <unsigned X, class T> struct Foo {
+  friend void operator<<(int, Foo const &) {}
+};
+template <unsigned X> class Bar : public Foo<X,int> {};
+inline Bar<0> bar(int,int,int) { return Bar<3>(); }  // ERROR - no conversion
+
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb88.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb88.C
new file mode 100644
index 00000000000..006fe568e51
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb88.C
@@ -0,0 +1,15 @@
+// Another magic NULL problem.
+// Special g++ Options: -w
+
+#include <stddef.h>
+
+int main()
+{
+  try
+    {
+      throw(NULL);
+    }
+  catch (...)
+    {
+    }
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb9.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb9.C
new file mode 100644
index 00000000000..cec700220cb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb9.C
@@ -0,0 +1,21 @@
+// Build don't link:
+template <class Key>
+class d0om_Hashmap
+{
+public:
+  typedef int value_type;
+
+  class iterator
+  {
+  public:
+    value_type* operator-> () const;
+  };
+
+};
+
+
+template <class Key>
+d0om_Hashmap<Key>::value_type* d0om_Hashmap<Key>::iterator::operator-> () const
+{
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb90.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb90.C
new file mode 100644
index 00000000000..2a43645d017
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb90.C
@@ -0,0 +1,22 @@
+// Special g++ Options: -O2
+// Build don't link: 
+
+#ifdef HIDE_BUG
+#define realloc Realloc
+#endif
+
+class TmpRgn {
+public:
+     void
+   realloc();
+};
+
+class TmpActor {
+    TmpRgn      tmpRgn;
+
+public:
+      void
+      realloc() {
+          tmpRgn.realloc();
+      }
+};
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb91.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb91.C
new file mode 100644
index 00000000000..8262b7939e1
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb91.C
@@ -0,0 +1,85 @@
+#include <sys/types.h>
+#include <algorithm>
+typedef short _eb91_int16_t;
+typedef char _eb91_int8_t;
+typedef unsigned char _eb91_u_int8_t;
+typedef unsigned short _eb91_u_int16_t;
+
+template <class INT>
+class other_endian
+{
+private:
+   
+  INT value;
+
+   
+  _eb91_u_int16_t change_endian(_eb91_u_int16_t x)
+  {
+    union {
+      _eb91_u_int16_t i;
+      _eb91_u_int8_t c[2];
+    } val;
+    val.i = x;
+    swap(val.c[0], val.c[1]);
+    return val.i;
+  };
+
+  _eb91_int16_t change_endian(_eb91_int16_t x)
+  {
+    union {
+      _eb91_int16_t i;
+      _eb91_int8_t c[2];
+    } val;
+    val.i = x;
+    swap(val.c[0], val.c[1]);
+    return val.i;
+  };
+public:
+  other_endian(const INT i = 0)
+  {
+    value = change_endian(i);
+  }
+
+  operator INT()
+  {
+    return change_endian(value);
+  }
+};
+
+template <class INT>
+class same_endian
+{
+  INT value;
+
+public:
+  same_endian(const INT i = 0)
+  {
+    value = i;
+  }
+
+  operator INT()
+  {
+    return value;
+  }
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+int main() {
+  other_endian <_eb91_u_int16_t> little_endian_16_bit_int;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb92.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb92.C
new file mode 100644
index 00000000000..8cb1639323c
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb92.C
@@ -0,0 +1 @@
+template<int N> f<0>(){}  // ERROR - invalid code
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb93.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb93.C
new file mode 100644
index 00000000000..988e65d7321
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb93.C
@@ -0,0 +1,30 @@
+// Error: Internal compiler error on egcs 1998/05/28 snapshot.
+
+const double M_PI=3.14159265358979323846;
+
+template<int N,int I,int J,int K>
+inline double SineSeries()
+{
+  const double x=I*2*M_PI/N;
+  const bool go=K+1!=J;
+  return 1.0-x*x/(2*K+2)/(2*K+3)*SineSeries<N*go,I*go,J*go,(K+1)*go>();
+}
+
+template<>
+inline double SineSeries<0,0,0,0>()
+{
+  return 1.0;
+}
+
+template<int N,int I>
+inline double Sine()
+{
+  const double x=(I*2*M_PI/N);
+  return x * SineSeries<N,I,10,0>();
+}
+
+int main()
+{
+  double f=Sine<32,5>()
+  return 0;               // ERROR - parse error
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb94.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb94.C
new file mode 100644
index 00000000000..7f7c0b4e8eb
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb94.C
@@ -0,0 +1,15 @@
+
+
+class baseClass
+{
+private:
+static int variable;
+};
+
+class myClass : public baseClass
+{
+private:
+static int variable;                    // this is intentionally duplicated
+};
+
+myClass::variable = 0;                  //ERROR - no type
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb95.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb95.C
new file mode 100644
index 00000000000..0d8e405c80a
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb95.C
@@ -0,0 +1,17 @@
+struct A {};
+
+template <class T>
+void operator+ (A &i, T &b) {}
+
+template<class T>
+void func (A &a, T &b) {}
+
+int main()
+{
+  A a;
+
+#if STRANGE
+  func(a, "egcs");
+#endif
+  a+"egcs";
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb97.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb97.C
new file mode 100644
index 00000000000..e05cc415b66
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb97.C
@@ -0,0 +1,24 @@
+// Creates bad assembly on sparc and x86
+template<unsigned long SIZE>
+struct Array { };
+
+template<unsigned long SIZE>
+Array<SIZE> test_ok(const Array<SIZE>& a) {
+    Array<SIZE> result;
+    return(result);
+}
+
+template<unsigned long SIZE>
+Array<SIZE + 1> test_error(const Array<SIZE>& a) {
+    Array<SIZE + 1> result;
+    return(result);
+}
+
+int main(int argc, char* argv[]) {
+    Array<2> a;
+
+    test_ok(a);
+    test_error(a); // <<< MARKED LINE!
+
+    return(0);
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb98.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb98.C
new file mode 100644
index 00000000000..cc19f0997cd
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb98.C
@@ -0,0 +1,17 @@
+// Error:    Internal compiler error in egcs 1998/05/28 snapshot.
+
+
+    template<class T, unsigned int Length>
+    inline
+    unsigned int
+    extent(T (&x)[Length])
+    {
+            return Length;
+    }
+
+    extern int b[];
+
+    void f()
+    {
+      extent(b);  // ERROR - no matching function
+    }
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/eb99.C b/gcc/testsuite/g++.old-deja/g++.robertl/eb99.C
new file mode 100644
index 00000000000..4cced8b0a09
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/eb99.C
@@ -0,0 +1,134 @@
+ 
+ 
+ 
+ 
+ 
+ 
+
+ 
+ 
+ 
+ 
+
+
+
+
+ 
+
+class ref_counted
+{
+ 
+protected:
+        ref_counted( void ) : _count( 0 ) {}
+
+public:
+ 
+        unsigned int add_ref( void ) { return ++_count; }
+        unsigned int release( void ) { return --_count; }
+        unsigned int count( void ) const { return _count; }
+
+ 
+protected:
+        unsigned int _count;
+};
+
+
+ 
+
+
+template < class T >
+class ref_ptr
+{
+ 
+public:
+        ref_ptr( T* ptr = 0 ) : _ptr( ptr )
+        {
+                add_ref();
+        }
+
+        ref_ptr( const ref_ptr & rptr ) : _ptr( rptr.get() )
+        {
+                add_ref();
+        }
+
+        ~ref_ptr( void ) { release(); }
+
+ 
+        T* get( void ) const { return _ptr; }
+        T* operator->( void ) const { return get(); }
+        T& operator*( void ) const { return *get(); }
+
+        bool operator!( void ) const { return get() == 0; }
+        bool operator==( const ref_ptr & rptr ) const { return *get() == *rptr;
+}
+        bool operator<( const ref_ptr & rptr ) const { return *get() < *rptr; }
+
+
+        bool operator==( T* ptr ) const { return *get() == *ptr; }
+        bool operator<( T* ptr ) const { return *get() < *ptr; }
+
+        const ref_ptr & operator=( const ref_ptr & rptr )
+        {
+                release();
+                _ptr = rptr.get();
+                add_ref();
+
+                return *this;
+        }
+
+       T* operator=( T* ptr )    
+       {
+         release();
+         _ptr = ptr;
+         add_ref();
+
+         return _ptr;
+       }
+
+protected:
+        void add_ref( void )
+        {
+                if( _ptr )
+                        _ptr->add_ref();
+        }
+
+        void release( void )
+        {
+                if( _ptr && 0 == _ptr->release() )
+                {
+                        delete _ptr;
+                        _ptr = 0;
+                }
+        }
+
+ 
+protected:
+        T *     _ptr;
+};
+
+
+template< class T >
+bool operator==( T* ptr, const ref_ptr< T > & rptr )
+{
+        return *ptr == *rptr;
+}
+
+template< class T >
+bool operator<( T* ptr, const ref_ptr< T > & rptr )
+{
+        return *ptr < *rptr;
+}
+
+
+
+class Baz : public ref_counted {
+  int dummy;
+};
+
+
+class Bar;
+
+int main() {
+  ref_ptr<Baz> foo;
+  static_cast<Bar *> (foo)->DoSomething;  //ERROR - invalid cast
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/ebnull-cast.C b/gcc/testsuite/g++.old-deja/g++.robertl/ebnull-cast.C
new file mode 100644
index 00000000000..d220e9089cf
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/ebnull-cast.C
@@ -0,0 +1,18 @@
+class null {
+    null (null const&);
+    void operator& ();
+
+  public:
+    null () {}
+
+    template <typename T>
+    operator T* () const { return 0; }
+} const null;
+
+
+int main ()
+{
+    int *p = static_cast<int*>(null);
+
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/ebnull-oldcast.C b/gcc/testsuite/g++.old-deja/g++.robertl/ebnull-oldcast.C
new file mode 100644
index 00000000000..cf6c21b6012
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/ebnull-oldcast.C
@@ -0,0 +1,17 @@
+class null {
+    null (null const&);
+    void operator& ();
+
+  public:
+    null () {}
+
+    template <typename T>
+    operator T* () const { return 0; }
+} const null;
+
+int main ()
+{
+    int *p = (int*) null;
+
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.robertl/ebnull.C b/gcc/testsuite/g++.old-deja/g++.robertl/ebnull.C
new file mode 100644
index 00000000000..e6eea2d6a54
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.robertl/ebnull.C
@@ -0,0 +1,17 @@
+class null {
+    null (null const&);
+    void operator& ();
+
+  public:
+    null () {}
+
+    template <typename T>
+    operator T* () const { return 0; }
+} const null;
+
+int main ()
+{
+    int *p = null;
+
+    return 0;
+}
diff --git a/gcc/testsuite/g++.old-deja/old-deja.exp b/gcc/testsuite/g++.old-deja/old-deja.exp
new file mode 100644
index 00000000000..70b822abc80
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/old-deja.exp
@@ -0,0 +1,65 @@
+# Copyright (C) 1988, 90, 91, 92, 1994, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-g++@prep.ai.mit.edu
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+
+#
+# these tests come from the original DejaGnu test suite 
+# developed at Cygnus Support. If this isn't deja gnu, I
+# don't know what is...
+#
+
+# load support procs
+load_lib old-dejagnu.exp
+load_lib g++.exp
+
+
+# When a testcase doesn't have any special options, use these.
+if ![info exists DEFAULT_CXXFLAGS] {
+    set DEFAULT_CXXFLAGS "-ansi -pedantic-errors"
+
+}
+
+old-dejagnu-init
+global GXX_UNDER_TEST
+
+#
+# main test loop
+#
+
+set dirlen [expr [string length "$srcdir/$subdir"] + 1];
+foreach file [lsort [find $srcdir/$subdir *.C]] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    set tfile [string range $file $dirlen end];
+    if ![runtest_file_p $runtests $tfile] then {
+	continue
+    }
+    verbose "Testing $file"
+
+    # We don't want old-dejagnu.exp to have to know about all the global
+    # variables we use.  For now we tell it about CXXFLAGS and LIBS and
+    # leave LDFLAGS alone.
+    old-dejagnu $GXX_UNDER_TEST "$file" "$tfile" "" "$DEFAULT_CXXFLAGS" "-lstdc++"
+}
+
+# The framework doesn't like to see any error remnants,
+# so remove them.
+if [info exists errorInfo] then {
+      unset errorInfo
+}
diff --git a/gcc/testsuite/g77.f-torture/compile/19990218-0.f b/gcc/testsuite/g77.f-torture/compile/19990218-0.f
new file mode 100644
index 00000000000..3e34117ec69
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/19990218-0.f
@@ -0,0 +1,13 @@
+        program test
+        double precision a,b,c
+        data a,b/1.0d-46,1.0d0/
+        c=fun(a,b)
+        print*,'in main: fun=',c
+        end
+        double precision function fun(a,b)
+        double precision a,b
+        print*,'in sub: a,b=',a,b
+        fun=a*b
+        print*,'in sub: fun=',fun
+        return
+        end
diff --git a/gcc/testsuite/g77.f-torture/compile/19990305-0.f b/gcc/testsuite/g77.f-torture/compile/19990305-0.f
new file mode 100644
index 00000000000..32c656d90a6
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/19990305-0.f
@@ -0,0 +1,55 @@
+* Date: Fri, 5 Mar 1999 00:35:44 -0500 (EST)
+* From: Denes Molnar <molnard@phys.columbia.edu>
+* To: fortran@gnu.org
+* Subject: f771 gets fatal signal 6
+* Content-Type: TEXT/PLAIN; charset=US-ASCII
+* X-UIDL: 8d81e9cbdcc96209c6e9b298d966ba7f
+*
+* Hi,
+*
+*
+* Comiling object from the source code below WORKS FINE with
+*   'g77 -o hwuci2 -c hwuci2.F'
+* but FAILS with fatal signal 6
+*   'g77 -o hwuci2 -O -c hwuci2.F'
+*
+* Any explanations?
+*
+* I am running GNU Fortran 0.5.23 with GCC 2.8.1 (glibc1).
+*
+*
+* Denes Molnar
+*
+* %%%%%%%%%%%%%%%%%%%%%%%%%
+* %the source:
+* %%%%%%%%%%%%%%%%%%%%%%%%%
+*
+CDECK  ID>, HWUCI2.
+*CMZ :-        -23/08/94  13.22.29  by  Mike Seymour
+*-- Author :    Ulrich Baur & Nigel Glover, adapted by Ian Knowles
+C-----------------------------------------------------------------------
+      FUNCTION HWUCI2(A,B,Y0)
+C-----------------------------------------------------------------------
+C     Integral  LOG(A-EPSI-BY(1-Y))/(Y-Y0)
+C-----------------------------------------------------------------------
+      IMPLICIT NONE
+      DOUBLE COMPLEX HWUCI2,HWULI2,EPSI,Y1,Y2,Z1,Z2,Z3,Z4
+      DOUBLE PRECISION A,B,Y0,ZERO,ONE,FOUR,HALF
+      EXTERNAL HWULI2
+      COMMON/SMALL/EPSI
+      PARAMETER (ZERO=0.D0, ONE =1.D0, FOUR= 4.D0, HALF=0.5D0)
+      IF(B.EQ.ZERO)THEN
+         HWUCI2=CMPLX(ZERO,ZERO)
+      ELSE
+         Y1=HALF*(ONE+SQRT(ONE-FOUR*(A+EPSI)/B))
+         Y2=ONE-Y1
+         Z1=Y0/(Y0-Y1)
+         Z2=(Y0-ONE)/(Y0-Y1)
+         Z3=Y0/(Y0-Y2)
+         Z4=(Y0-ONE)/(Y0-Y2)
+         HWUCI2=HWULI2(Z1)-HWULI2(Z2)+HWULI2(Z3)-HWULI2(Z4)
+      ENDIF
+      RETURN
+      END
+*
+* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
diff --git a/gcc/testsuite/g77.f-torture/compile/19990419-0.f b/gcc/testsuite/g77.f-torture/compile/19990419-0.f
new file mode 100644
index 00000000000..084e7a254bf
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/19990419-0.f
@@ -0,0 +1,7 @@
+* Test case Toon submitted, cut down to expose the one bug.
+* Belongs in compile/.
+      SUBROUTINE INIERS1
+      IMPLICIT   LOGICAL(L)
+      COMMON/COMIOD/ NHIERS1, LERS1
+      inquire(nhiers1, exist=lers1)
+      END
diff --git a/gcc/testsuite/g77.f-torture/compile/19990502-0.f b/gcc/testsuite/g77.f-torture/compile/19990502-0.f
new file mode 100644
index 00000000000..4f5d6859138
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/19990502-0.f
@@ -0,0 +1,66 @@
+* Mailing-List: contact egcs-bugs-help@egcs.cygnus.com; run by ezmlm
+* Precedence: bulk
+* Sender: owner-egcs-bugs@egcs.cygnus.com
+* From: Norbert Conrad <Norbert.Conrad@hrz.uni-giessen.de>
+* Subject: egcs g77 19990524pre Internal compiler error in `print_operand'
+* To: egcs-bugs@egcs.cygnus.com
+* Date: Mon, 31 May 1999 11:46:52 +0200 (CET)
+* Content-Type: text/plain; charset=US-ASCII
+* X-UIDL: 9a00095a5fe4d774b7223de071157374
+* 
+* Hi,
+* 
+* I ./configure --prefix=/opt and bootstrapped egcs g77 snapshot 19990524
+* on an i686-pc-linux-gnu. The program below gives an internal compiler error.
+* 
+* 
+* Script started on Mon May 31 11:30:01 1999
+* lx{g010}:/tmp>/opt/bin/g77 -v -O3 -malign-double -c e3.f
+* g77 version gcc-2.95 19990524 (prerelease) (from FSF-g77 version 0.5.24-19990515)
+* Reading specs from /opt/lib/gcc-lib/i686-pc-linux-gnu/gcc-2.95/specs
+* gcc version gcc-2.95 19990524 (prerelease)
+*  /opt/lib/gcc-lib/i686-pc-linux-gnu/gcc-2.95/f771 e3.f -quiet -dumpbase e3.f -malign-double -O3 -version -fversion -o /tmp/ccQgeaaa.s
+* GNU F77 version gcc-2.95 19990524 (prerelease) (i686-pc-linux-gnu) compiled by GNU C version gcc-2.95 19990524 (prerelease).
+* GNU Fortran Front End version 0.5.24-19990515
+* e3.f:25: Internal compiler error in `print_operand', at ./config/i386/i386.c:3405
+* Please submit a full bug report to `egcs-bugs@egcs.cygnus.com'.
+* See <URL:http://egcs.cygnus.com/faq.html#bugreport> for details.
+* lx{g010}:/tmp>cat e3.f
+      SUBROUTINE DLASQ2( QQ, EE,  TOL2, SMALL2 )
+      DOUBLE PRECISION   SMALL2, TOL2
+      DOUBLE PRECISION   EE( * ), QQ( * )
+      INTEGER            ICONV,  N, OFF
+      DOUBLE PRECISION   QEMAX, XINF
+      EXTERNAL           DLASQ3
+      INTRINSIC          MAX, SQRT
+      XINF = 0.0D0
+      ICONV = 0
+      IF( EE( N ).LE.MAX( QQ( N ), XINF, SMALL2 )*TOL2 ) THEN
+      END IF
+      IF( EE( N-2 ).LE.MAX( XINF, SMALL2,
+     $    ( QQ( N ) / ( QQ( N )+EE( N-1 ) ) )* QQ( N-1 ))*TOL2 ) THEN
+         QEMAX = MAX( QQ( N ), QQ( N-1 ), EE( N-1 ) )
+      END IF
+      IF( N.EQ.0 ) THEN
+         IF( OFF.EQ.0 ) THEN
+            RETURN
+         ELSE
+            XINF =0.0D0 
+         END IF
+      ELSE IF( N.EQ.2 ) THEN
+      END IF
+      CALL DLASQ3(ICONV)
+      END
+* lx{g010}:/tmp>exit
+* 
+* Script done on Mon May 31 11:30:23 1999
+* 
+* Best regards,
+* 
+* Norbert.
+* -- 
+* Norbert Conrad                             phone: ++49 641 9913021
+* Hochschulrechenzentrum                     email: conrad@hrz.uni-giessen.de
+* Heinrich-Buff-Ring 44
+* 35392 Giessen
+* Germany
diff --git a/gcc/testsuite/g77.f-torture/compile/19990502-1.f b/gcc/testsuite/g77.f-torture/compile/19990502-1.f
new file mode 100644
index 00000000000..b7238fcd881
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/19990502-1.f
@@ -0,0 +1,6 @@
+      SUBROUTINE G(IGAMS,IWRK,NADC,NCellsInY)
+      INTEGER*2 IGAMS(2,NADC)
+      in = 1
+      do while (in.le.nadc.and.IGAMS(2,in).le.in)
+      enddo
+      END
diff --git a/gcc/testsuite/g77.f-torture/compile/960317-1.f b/gcc/testsuite/g77.f-torture/compile/960317-1.f
new file mode 100644
index 00000000000..4bb0a37278e
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/960317-1.f
@@ -0,0 +1,103 @@
+* Date: Sat, 16 Mar 1996 19:58:37 -0500 (EST)
+* From: Kate Hedstrom <kate@ahab.Rutgers.EDU>
+* To: burley@gnu.ai.mit.edu
+* Subject: g77 bug in assign
+* 
+* I found some files in the NCAR graphics source code which used to
+* compile with g77 and now don't.  All contain the following combination
+* of "save" and "assign".  It fails on a Sun running SunOS 4.1.3 and a
+* Sun running SunOS 5.5 (slightly older g77), but compiles on an
+* IBM/RS6000:
+* 
+C
+      SUBROUTINE QUICK
+      SAVE
+C
+      ASSIGN 101 TO JUMP
+  101 Continue
+C
+      RETURN
+      END
+* 
+* Everything else in the NCAR distribution compiled, including quite a
+* few C routines.
+* 
+* Kate
+* 
+* 
+* nemo% g77 -v -c quick.f
+*  gcc -v -c -xf77 quick.f
+* Reading specs from /usr/local/lib/gcc-lib/sparc-sun-sunos4.1.3/2.7.2/specs
+* gcc version 2.7.2
+*  /usr/local/lib/gcc-lib/sparc-sun-sunos4.1.3/2.7.2/f771 quick.f -fset-g77-defaults -quiet -dumpbase quick.f -version -fversion -o /usr/tmp/cca24166.s
+* GNU F77 version 2.7.2 (sparc) compiled by GNU C version 2.7.1.
+* GNU Fortran Front End version 0.5.18-960314 compiled: Mar 16 1996 14:28:11
+* gcc: Internal compiler error: program f771 got fatal signal 11
+* 
+* 
+* nemo% gdb /usr/local/lib/gcc-lib/*/*/f771 core
+* GDB is free software and you are welcome to distribute copies of it
+*  under certain conditions; type "show copying" to see the conditions.
+* There is absolutely no warranty for GDB; type "show warranty" for details.
+* GDB 4.14 (sparc-sun-sunos4.1.3), 
+* Copyright 1995 Free Software Foundation, Inc...
+* Core was generated by `f771'.
+* Program terminated with signal 11, Segmentation fault.
+* Couldn't read input and local registers from core file
+* find_solib: Can't read pathname for load map: I/O error
+* 
+* Couldn't read input and local registers from core file
+* #0  0x21aa4 in ffecom_sym_transform_assign_ (s=???) at f/com.c:7881
+* 7881          if ((ffesymbol_save (s) || ffe_is_saveall ())
+* (gdb) where
+* #0  0x21aa4 in ffecom_sym_transform_assign_ (s=???) at f/com.c:7881
+* Error accessing memory address 0xefffefcc: Invalid argument.
+* (gdb) 
+* 
+* 
+* ahab% g77 -v -c quick.f
+*  gcc -v -c -xf77 quick.f
+* Reading specs from /usr/local/lib/gcc-lib/sparc-sun-solaris2.5/2.7.2/specs
+* gcc version 2.7.2
+*  /usr/local/lib/gcc-lib/sparc-sun-solaris2.5/2.7.2/f771 quick.f -quiet -dumpbase quick.f -version -fversion -o /var/tmp/cca003D2.s
+* GNU F77 version 2.7.2 (sparc) compiled by GNU C version 2.7.2.
+* GNU Fortran Front End version 0.5.18-960304 compiled: Mar  5 1996 16:12:46
+* gcc: Internal compiler error: program f771 got fatal signal 11
+* 
+* 
+* ahab% !gdb
+* gdb /usr/local/lib/gcc-lib/*/*/f771 core
+* GDB is free software and you are welcome to distribute copies of it
+*  under certain conditions; type "show copying" to see the conditions.
+* There is absolutely no warranty for GDB; type "show warranty" for details.
+* GDB 4.15.1 (sparc-sun-solaris2.4), 
+* Copyright 1995 Free Software Foundation, Inc...
+* Core was generated by
+* `/usr/local/lib/gcc-lib/sparc-sun-solaris2.5/2.7.2/f771 quick.f -quiet -dumpbase'.
+* Program terminated with signal 11, Segmentation fault.
+* Reading symbols from /usr/lib/libc.so.1...done.
+* Reading symbols from /usr/lib/libdl.so.1...done.
+* #0  0x43e04 in ffecom_sym_transform_assign_ (s=0x3a22f8) at f/com.c:7963
+* Source file is more recent than executable.
+* 7963      assert (st != NULL);
+* (gdb) where
+* #0  0x43e04 in ffecom_sym_transform_assign_ (s=0x3a22f8) at f/com.c:7963
+* #1  0x38044 in ffecom_expr_ (expr=0x3a23c0, dest_tree=0x0, dest=0x0, dest_used=0x0, assignp=true) at f/com.c:2100
+* #2  0x489c8 in ffecom_expr_assign_w (expr=0x3a23c0) at f/com.c:10238
+* #3  0xe9228 in ffeste_R838 (label=0x3a1ba8, target=0x3a23c0) at f/ste.c:2769
+* #4  0xdae60 in ffestd_stmt_pass_ () at f/std.c:840
+* #5  0xdc090 in ffestd_exec_end () at f/std.c:1405
+* #6  0xcb534 in ffestc_shriek_subroutine_ (ok=true) at f/stc.c:4849
+* #7  0xd8f00 in ffestc_R1225 (name=0x0) at f/stc.c:12307
+* #8  0xcc808 in ffestc_end () at f/stc.c:5572
+* #9  0x9fa84 in ffestb_end3_ (t=0x3a19c8) at f/stb.c:3216
+* #10 0x9f30c in ffestb_end (t=0x3a19c8) at f/stb.c:2995
+* #11 0x98414 in ffesta_save_ (t=0x3a19c8) at f/sta.c:453
+* #12 0x997ec in ffesta_second_ (t=0x3a19c8) at f/sta.c:1178
+* #13 0x8ed84 in ffelex_send_token_ () at f/lex.c:1614
+* #14 0x8cab8 in ffelex_finish_statement_ () at f/lex.c:946
+* #15 0x91684 in ffelex_file_fixed (wf=0x397780, f=0x37a560) at f/lex.c:2946
+* #16 0x107a94 in ffe_file (wf=0x397780, f=0x37a560) at f/top.c:456
+* #17 0x96218 in yyparse () at f/parse.c:77
+* #18 0x10beac in compile_file (name=0xdffffaf7 "quick.f") at toplev.c:2239
+* #19 0x110dc0 in main (argc=9, argv=0xdffff994, envp=0xdffff9bc) at toplev.c:3927
diff --git a/gcc/testsuite/g77.f-torture/compile/970125-0.f b/gcc/testsuite/g77.f-torture/compile/970125-0.f
new file mode 100644
index 00000000000..004f5584f3e
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/970125-0.f
@@ -0,0 +1,40 @@
+C JCB comments:
+C g77 doesn't accept the added line "integer(kind=7) ..." --
+C it crashes!
+C 
+C It's questionable that g77 DTRT with regarding to passing
+C %LOC() as an argument (thus by reference) and the new global
+C analysis.  I need to look into that further; my feeling is that
+C passing %LOC() as an argument should be treated like passing an
+C INTEGER(KIND=7) by reference, and no more specially than that
+C (and that INTEGER(KIND=7) should be permitted as equivalent to
+C INTEGER(KIND=1), INTEGER(KIND=2), or whatever, depending on the
+C system's pointer size).
+C 
+C The back end *still* has a bug here, which should be fixed,
+C because, currently, what g77 is passing to it is, IMO, correct.
+
+C No options:
+C ../../egcs/gcc/f/info.c:259: failed assertion `ffeinfo_types_[basictype][kindtype] != NULL'
+C -fno-globals -O:
+C ../../egcs/gcc/expr.c:7291: Internal compiler error in function expand_expr
+
+c     Frontend bug fixed by JCB 1998-06-01 com.c &c changes.
+
+        integer*4 i4
+        integer*8 i8
+        integer*8 max4
+        data max4/2147483647/
+        i4 = %loc(i4)
+        i8 = %loc(i8)
+        print *, max4
+        print *, i4, %loc(i4)
+        print *, i8, %loc(i8)
+        call foo(i4, %loc(i4), i8, %loc(i8))
+        end
+        subroutine foo(i4, i4a, i8, i8a)
+        integer(kind=7) i4a, i8a
+        integer*8 i8
+        print *, i4, i4a
+        print *, i8, i8a
+        end
diff --git a/gcc/testsuite/g77.f-torture/compile/970915-0.f b/gcc/testsuite/g77.f-torture/compile/970915-0.f
new file mode 100644
index 00000000000..9ac3cf8aa97
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/970915-0.f
@@ -0,0 +1,20 @@
+* fixed by patch to safe_from_p to avoid visiting any SAVE_EXPR
+* node twice in a given top-level call to it.
+* (JCB com.c patch of 1998-06-04.)
+
+      SUBROUTINE TSTSIG11
+      IMPLICIT COMPLEX (A-Z)
+      EXTERNAL gzi1,gzi2
+      branch3 =  sw2 / cw
+     .     * (  rdw * (epsh*gzi1(A,B)-gzi2(A,B))
+     .     + rdw * (epsh*gzi1(A,B)-gzi2(A,B)) )
+     .     + (-1./2. + 2.*sw2/3.) / (sw*cw)
+     .     * rdw * (epsh*gzi1(A,B)-gzi2(A,B)
+     .     + rdw * (epsh*gzi1(A,B)-gzi2(A,B))
+     .     + rdw * (epsh*gzi1(A,B)-gzi2(A,B)) )
+     .     * rup * (epsh*gzi1(A,B)-gzi2(A,B)
+     .     + rup * (epsh*gzi1(A,B)-gzi2(A,B)) )
+     .     * 4.*(3.-tw**2) * gzi2(A,B)
+     .     + ((1.+2./tauw)*tw**2-(5.+2./tauw))* gzi1(A,B)
+      RETURN
+      END
diff --git a/gcc/testsuite/g77.f-torture/compile/980310-1.f b/gcc/testsuite/g77.f-torture/compile/980310-1.f
new file mode 100644
index 00000000000..bc8aa85c14a
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980310-1.f
@@ -0,0 +1,28 @@
+C Causes internal compiler error on egcs 1.0.1 on i586-pc-sco3.2v5.0.4
+C To: egcs-bugs@cygnus.com
+C Subject: backend case range problem/fix
+C From: Dave Love <d.love@dl.ac.uk>
+C Date: 02 Dec 1997 18:11:35 +0000
+C Message-ID: <rzqpvnfboo8.fsf@djlvig.dl.ac.uk>
+C 
+C The following Fortran test case aborts the compiler because
+C tree_int_cst_lt dereferences a null tree; this is a regression from
+C gcc 2.7.
+
+      INTEGER N
+      READ(*,*) N
+      SELECT CASE (N)
+        CASE (1:)
+           WRITE(*,*) 'case 1'
+        CASE (0)
+           WRITE(*,*) 'case 0'
+      END SELECT
+      END
+
+C The relevant change to cure this is:
+C
+C Thu Dec  4 06:34:40 1997  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>
+C
+C       * stmt.c (pushcase_range): Clean up handling of "infinite" values.
+C
+
diff --git a/gcc/testsuite/g77.f-torture/compile/980310-2.f b/gcc/testsuite/g77.f-torture/compile/980310-2.f
new file mode 100644
index 00000000000..5077c552da8
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980310-2.f
@@ -0,0 +1,43 @@
+C unable to confirm this bug on egcs 1.0.1 for i586-pc-sco3.2v5.0.4 robertl
+C
+C Date: Sat, 23 Aug 1997 00:47:53 -0400 (EDT)
+C From: David Bristow <dbristow@lynx.dac.neu.edu>
+C To: egcs-bugs@cygnus.com
+C Subject: g77 crashes compiling Dungeon
+C Message-ID: <Pine.OSF.3.91.970823003521.11281A-100000@lynx.dac.neu.edu>
+C
+C The following small segment of Dungeon (the adventure that became the 
+C commercial hit Zork) causes an internal error in f771.  The platform is 
+C i586-pc-linux-gnulibc1, the compiler is egcs-ss-970821 (g77-GNU Fortran 
+C 0.5.21-19970811)
+C 
+C --cut here--cut here--cut here--cut here--cut here--cut here--
+C g77 --verbose -fugly -fvxt -c subr_.f
+C g77 version 0.5.21-19970811
+C  gcc --verbose -fugly -fvxt -xf77 subr_.f -xnone -lf2c -lm
+C Reading specs from /usr/lib/gcc-lib/i586-pc-linux-gnulibc1/egcs-2.90.01/specs
+C gcc version egcs-2.90.01 970821 (gcc2-970802 experimental)
+C  /usr/lib/gcc-lib/i586-pc-linux-gnulibc1/egcs-2.90.01/f771 subr_.f -fset-g77-defaults -quiet -dumpbase subr_.f -version -fversion -fugly -fvxt -o /tmp/cca23974.s
+C f771: warning: -fugly is overloaded with meanings and likely to be removed;
+C f771: warning: use only the specific -fugly-* options you need
+C GNU F77 version egcs-2.90.01 970821 (gcc2-970802 experimental) (i586-pc-linux-gnulibc1) compiled by GNU C version egcs-2.90.01 970821 (gcc2-970802 experimental).
+C GNU Fortran Front End version 0.5.21-19970811
+C f/com.c:941: failed assertion `TYPE_PRECISION (type) <= TYPE_PRECISION (TREE_TYPE (e))'
+C gcc: Internal compiler error: program f771 got fatal signal 6
+C --cut here--cut here--cut here--cut here--cut here--cut here--
+C 
+C Here's the FORTRAN code, it's basically a single subroutine from subr.f 
+C in the Dungeon source, slightly altered (the original calls RAN(), which 
+C doesn't exist in the g77 runtime)
+C 
+C RND - Return a random integer mod n
+C
+	INTEGER FUNCTION RND (N)
+	IMPLICIT INTEGER (A-Z)
+	REAL RAND
+	COMMON /SEED/ RNSEED
+
+	RND = RAND(RNSEED)*FLOAT(N)
+	RETURN
+
+	END
diff --git a/gcc/testsuite/g77.f-torture/compile/980310-3.f b/gcc/testsuite/g77.f-torture/compile/980310-3.f
new file mode 100644
index 00000000000..ddfb4c4bb9f
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980310-3.f
@@ -0,0 +1,259 @@
+c
+c	This demonstrates a problem with g77 and pic on x86 where 
+c 	egcs 1.0.1 and earlier will generate bogus assembler output.
+c	unfortunately, gas accepts the bogus acssembler output and 
+c	generates code that almost works.
+c
+
+
+C Date: Wed, 17 Dec 1997 23:20:29 +0000
+C From: Joao Cardoso <jcardoso@inescn.pt>
+C To: egcs-bugs@cygnus.com
+C Subject: egcs-1.0 f77 bug on OSR5
+C When trying to compile the Fortran file that I enclose bellow,
+C I got an assembler error:
+C 
+C ./g77 -B./ -fpic -O -c scaleg.f
+C /usr/tmp/cca002D8.s:123:syntax error at (
+C 
+C ./g77 -B./ -fpic -O0 -c scaleg.f 
+C /usr/tmp/cca002EW.s:246:invalid operand combination: leal
+C 
+C Compiling without the -fpic flag runs OK.
+
+      subroutine scaleg (n,ma,a,mb,b,low,igh,cscale,cperm,wk)
+c
+c     *****parameters:
+      integer igh,low,ma,mb,n
+      double precision a(ma,n),b(mb,n),cperm(n),cscale(n),wk(n,6)
+c
+c     *****local variables:
+      integer i,ir,it,j,jc,kount,nr,nrp2
+      double precision alpha,basl,beta,cmax,coef,coef2,coef5,cor,
+     *                 ew,ewc,fi,fj,gamma,pgamma,sum,t,ta,tb,tc
+c
+c     *****fortran functions:
+      double precision dabs, dlog10, dsign
+c     float
+c
+c     *****subroutines called:
+c     none
+c
+c     ---------------------------------------------------------------
+c
+c     *****purpose:
+c     scales the matrices a and b in the generalized eigenvalue
+c     problem a*x = (lambda)*b*x such that the magnitudes of the
+c     elements of the submatrices of a and b (as specified by low
+c     and igh) are close to unity in the least squares sense.
+c     ref.:  ward, r. c., balancing the generalized eigenvalue
+c     problem, siam j. sci. stat. comput., vol. 2, no. 2, june 1981,
+c     141-152.
+c
+c     *****parameter description:
+c
+c     on input:
+c
+c       ma,mb   integer
+c               row dimensions of the arrays containing matrices
+c               a and b respectively, as declared in the main calling
+c               program dimension statement;
+c
+c       n       integer
+c               order of the matrices a and b;
+c
+c       a       real(ma,n)
+c               contains the a matrix of the generalized eigenproblem
+c               defined above;
+c
+c       b       real(mb,n)
+c               contains the b matrix of the generalized eigenproblem
+c               defined above;
+c
+c       low     integer
+c               specifies the beginning -1 for the rows and
+c               columns of a and b to be scaled;
+c
+c       igh     integer
+c               specifies the ending -1 for the rows and columns
+c               of a and b to be scaled;
+c
+c       cperm   real(n)
+c               work array.  only locations low through igh are
+c               referenced and altered by this subroutine;
+c
+c       wk      real(n,6)
+c               work array that must contain at least 6*n locations.
+c               only locations low through igh, n+low through n+igh,
+c               ..., 5*n+low through 5*n+igh are referenced and
+c               altered by this subroutine.
+c
+c     on output:
+c
+c       a,b     contain the scaled a and b matrices;
+c
+c       cscale  real(n)
+c               contains in its low through igh locations the integer
+c               exponents of 2 used for the column scaling factors.
+c               the other locations are not referenced;
+c
+c       wk      contains in its low through igh locations the integer
+c               exponents of 2 used for the row scaling factors.
+c
+c     *****algorithm notes:
+c     none.
+c
+c     *****history:
+c     written by r. c. ward.......
+c     modified 8/86 by bobby bodenheimer so that if
+c       sum = 0 (corresponding to the case where the matrix
+c       doesn't need to be scaled) the routine returns.
+c
+c     ---------------------------------------------------------------
+c
+      if (low .eq. igh) go to 410
+      do 210 i = low,igh
+         wk(i,1) = 0.0d0
+         wk(i,2) = 0.0d0
+         wk(i,3) = 0.0d0
+         wk(i,4) = 0.0d0
+         wk(i,5) = 0.0d0
+         wk(i,6) = 0.0d0
+         cscale(i) = 0.0d0
+         cperm(i) = 0.0d0
+  210 continue
+c
+c     compute right side vector in resulting linear equations
+c
+      basl = dlog10(2.0d0)
+      do 240 i = low,igh
+         do 240 j = low,igh
+            tb = b(i,j)
+            ta = a(i,j)
+            if (ta .eq. 0.0d0) go to 220
+            ta = dlog10(dabs(ta)) / basl
+  220       continue
+            if (tb .eq. 0.0d0) go to 230
+            tb = dlog10(dabs(tb)) / basl
+  230       continue
+            wk(i,5) = wk(i,5) - ta - tb
+            wk(j,6) = wk(j,6) - ta - tb
+  240 continue
+      nr = igh-low+1
+      coef = 1.0d0/float(2*nr)
+      coef2 = coef*coef
+      coef5 = 0.5d0*coef2
+      nrp2 = nr+2
+      beta = 0.0d0
+      it = 1
+c
+c     start generalized conjugate gradient iteration
+c
+  250 continue
+      ew = 0.0d0
+      ewc = 0.0d0
+      gamma = 0.0d0
+      do 260 i = low,igh
+         gamma = gamma + wk(i,5)*wk(i,5) + wk(i,6)*wk(i,6)
+         ew = ew + wk(i,5)
+         ewc = ewc + wk(i,6)
+  260 continue
+      gamma = coef*gamma - coef2*(ew**2 + ewc**2)
+     +        - coef5*(ew - ewc)**2
+      if (it .ne. 1) beta = gamma / pgamma
+      t = coef5*(ewc - 3.0d0*ew)
+      tc = coef5*(ew - 3.0d0*ewc)
+      do 270 i = low,igh
+         wk(i,2) = beta*wk(i,2) + coef*wk(i,5) + t
+         cperm(i) = beta*cperm(i) + coef*wk(i,6) + tc
+  270 continue
+c
+c     apply matrix to vector
+c
+      do 300 i = low,igh
+         kount = 0
+         sum = 0.0d0
+         do 290 j = low,igh
+            if (a(i,j) .eq. 0.0d0) go to 280
+            kount = kount+1
+            sum = sum + cperm(j)
+  280       continue
+            if (b(i,j) .eq. 0.0d0) go to 290
+            kount = kount+1
+            sum = sum + cperm(j)
+  290    continue
+         wk(i,3) = float(kount)*wk(i,2) + sum
+  300 continue
+      do 330 j = low,igh
+         kount = 0
+         sum = 0.0d0
+         do 320 i = low,igh
+            if (a(i,j) .eq. 0.0d0) go to 310
+            kount = kount+1
+            sum = sum + wk(i,2)
+  310       continue
+            if (b(i,j) .eq. 0.0d0) go to 320
+            kount = kount+1
+            sum = sum + wk(i,2)
+  320    continue
+         wk(j,4) = float(kount)*cperm(j) + sum
+  330 continue
+      sum = 0.0d0
+      do 340 i = low,igh
+         sum = sum + wk(i,2)*wk(i,3) + cperm(i)*wk(i,4)
+  340 continue
+      if(sum.eq.0.0d0) return
+      alpha = gamma / sum
+c
+c     determine correction to current iterate
+c
+      cmax = 0.0d0
+      do 350 i = low,igh
+         cor = alpha * wk(i,2)
+         if (dabs(cor) .gt. cmax) cmax = dabs(cor)
+         wk(i,1) = wk(i,1) + cor
+         cor = alpha * cperm(i)
+         if (dabs(cor) .gt. cmax) cmax = dabs(cor)
+         cscale(i) = cscale(i) + cor
+  350 continue
+      if (cmax .lt. 0.5d0) go to 370
+      do 360 i = low,igh
+         wk(i,5) = wk(i,5) - alpha*wk(i,3)
+         wk(i,6) = wk(i,6) - alpha*wk(i,4)
+  360 continue
+      pgamma = gamma
+      it = it+1
+      if (it .le. nrp2) go to 250
+c
+c     end generalized conjugate gradient iteration
+c
+  370 continue
+      do 380 i = low,igh
+         ir = wk(i,1) + dsign(0.5d0,wk(i,1))
+         wk(i,1) = ir
+         jc = cscale(i) + dsign(0.5d0,cscale(i))
+         cscale(i) = jc
+  380 continue
+c
+c     scale a and b
+c
+      do 400 i = 1,igh
+         ir = wk(i,1)
+         fi = 2.0d0**ir
+         if (i .lt. low) fi = 1.0d0
+         do 400 j =low,n
+            jc = cscale(j)
+            fj = 2.0d0**jc
+            if (j .le. igh) go to 390
+            if (i .lt. low) go to 400
+            fj = 1.0d0
+  390       continue
+            a(i,j) = a(i,j)*fi*fj
+            b(i,j) = b(i,j)*fi*fj
+  400 continue
+  410 continue
+      return
+c
+c     last line of scaleg
+c
+      end
diff --git a/gcc/testsuite/g77.f-torture/compile/980310-4.f b/gcc/testsuite/g77.f-torture/compile/980310-4.f
new file mode 100644
index 00000000000..b169845e634
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980310-4.f
@@ -0,0 +1,348 @@
+
+C To: egcs-bugs@cygnus.com
+C Subject: -fPIC problem showing up with fortran on x86
+C From: Dave Love <d.love@dl.ac.uk>
+C Date: 19 Dec 1997 19:31:41 +0000
+C 
+C 
+C This illustrates a long-standing problem noted at the end of the g77
+C `Actual Bugs' info node and thought to be in the back end.  Although
+C the report is against gcc 2.7 I can reproduce it (specifically on
+C redhat 4.2) with the 971216 egcs snapshot.
+C 
+C g77 version 0.5.21
+C  gcc -v -fnull-version -o /tmp/gfa00415 -xf77-cpp-input /tmp/gfa00415.f -xnone
+C -lf2c -lm
+C
+
+C ------------
+      subroutine dqage(f,a,b,epsabs,epsrel,limit,result,abserr,
+     *   neval,ier,alist,blist,rlist,elist,iord,last)
+C     --------------------------------------------------
+C
+C     Modified Feb 1989 by Barry W. Brown to eliminate key
+C     as argument (use key=1) and to eliminate all Fortran
+C     output.
+C
+C     Purpose: to make this routine usable from within S.
+C
+C     --------------------------------------------------
+c***begin prologue  dqage
+c***date written   800101   (yymmdd)
+c***revision date  830518   (yymmdd)
+c***category no.  h2a1a1
+c***keywords  automatic integrator, general-purpose,
+c             integrand examinator, globally adaptive,
+c             gauss-kronrod
+c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
+c***purpose  the routine calculates an approximation result to a given
+c            definite integral   i = integral of f over (a,b),
+c            hopefully satisfying following claim for accuracy
+c            abs(i-reslt).le.max(epsabs,epsrel*abs(i)).
+c***description
+c
+c        computation of a definite integral
+c        standard fortran subroutine
+c        double precision version
+c
+c        parameters
+c         on entry
+c            f      - double precision
+c                     function subprogram defining the integrand
+c                     function f(x). the actual name for f needs to be
+c                     declared e x t e r n a l in the driver program.
+c
+c            a      - double precision
+c                     lower limit of integration
+c
+c            b      - double precision
+c                     upper limit of integration
+c
+c            epsabs - double precision
+c                     absolute accuracy requested
+c            epsrel - double precision
+c                     relative accuracy requested
+c                     if  epsabs.le.0
+c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+c                     the routine will end with ier = 6.
+c
+c            key    - integer
+c                     key for choice of local integration rule
+c                     a gauss-kronrod pair is used with
+c                          7 - 15 points if key.lt.2,
+c                         10 - 21 points if key = 2,
+c                         15 - 31 points if key = 3,
+c                         20 - 41 points if key = 4,
+c                         25 - 51 points if key = 5,
+c                         30 - 61 points if key.gt.5.
+c
+c            limit  - integer
+c                     gives an upperbound on the number of subintervals
+c                     in the partition of (a,b), limit.ge.1.
+c
+c         on return
+c            result - double precision
+c                     approximation to the integral
+c
+c            abserr - double precision
+c                     estimate of the modulus of the absolute error,
+c                     which should equal or exceed abs(i-result)
+c
+c            neval  - integer
+c                     number of integrand evaluations
+c
+c            ier    - integer
+c                     ier = 0 normal and reliable termination of the
+c                             routine. it is assumed that the requested
+c                             accuracy has been achieved.
+c                     ier.gt.0 abnormal termination of the routine
+c                             the estimates for result and error are
+c                             less reliable. it is assumed that the
+c                             requested accuracy has not been achieved.
+c            error messages
+c                     ier = 1 maximum number of subdivisions allowed
+c                             has been achieved. one can allow more
+c                             subdivisions by increasing the value
+c                             of limit.
+c                             however, if this yields no improvement it
+c                             is rather advised to analyze the integrand
+c                             in order to determine the integration
+c                             difficulties. if the position of a local
+c                             difficulty can be determined(e.g.
+c                             singularity, discontinuity within the
+c                             interval) one will probably gain from
+c                             splitting up the interval at this point
+c                             and calling the integrator on the
+c                             subranges. if possible, an appropriate
+c                             special-purpose integrator should be used
+c                             which is designed for handling the type of
+c                             difficulty involved.
+c                         = 2 the occurrence of roundoff error is
+c                             detected, which prevents the requested
+c                             tolerance from being achieved.
+c                         = 3 extremely bad integrand behaviour occurs
+c                             at some points of the integration
+c                             interval.
+c                         = 6 the input is invalid, because
+c                             (epsabs.le.0 and
+c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+c                             result, abserr, neval, last, rlist(1) ,
+c                             elist(1) and iord(1) are set to zero.
+c                             alist(1) and blist(1) are set to a and b
+c                             respectively.
+c
+c            alist   - double precision
+c                      vector of dimension at least limit, the first
+c                       last  elements of which are the left
+c                      end points of the subintervals in the partition
+c                      of the given integration range (a,b)
+c
+c            blist   - double precision
+c                      vector of dimension at least limit, the first
+c                       last  elements of which are the right
+c                      end points of the subintervals in the partition
+c                      of the given integration range (a,b)
+c
+c            rlist   - double precision
+c                      vector of dimension at least limit, the first
+c                       last  elements of which are the
+c                      integral approximations on the subintervals
+c
+c            elist   - double precision
+c                      vector of dimension at least limit, the first
+c                       last  elements of which are the moduli of the
+c                      absolute error estimates on the subintervals
+c
+c            iord    - integer
+c                      vector of dimension at least limit, the first k
+c                      elements of which are pointers to the
+c                      error estimates over the subintervals,
+c                      such that elist(iord(1)), ...,
+c                      elist(iord(k)) form a decreasing sequence,
+c                      with k = last if last.le.(limit/2+2), and
+c                      k = limit+1-last otherwise
+c
+c            last    - integer
+c                      number of subintervals actually produced in the
+c                      subdivision process
+c
+c***references  (none)
+c***routines called  d1mach,dqk15,dqk21,dqk31,
+c                    dqk41,dqk51,dqk61,dqpsrt
+c***end prologue  dqage
+c
+      double precision a,abserr,alist,area,area1,area12,area2,a1,a2,b,
+     *  blist,b1,b2,dabs,defabs,defab1,defab2,dmax1,d1mach,elist,epmach,
+     *  epsabs,epsrel,errbnd,errmax,error1,error2,erro12,errsum,f,
+     *  resabs,result,rlist,uflow
+      integer ier,iord,iroff1,iroff2,k,last,limit,maxerr,neval,
+     *  nrmax
+c
+      dimension alist(limit),blist(limit),elist(limit),iord(limit),
+     *  rlist(limit)
+c
+      external f
+c
+c            list of major variables
+c            -----------------------
+c
+c           alist     - list of left end points of all subintervals
+c                       considered up to now
+c           blist     - list of right end points of all subintervals
+c                       considered up to now
+c           rlist(i)  - approximation to the integral over
+c                      (alist(i),blist(i))
+c           elist(i)  - error estimate applying to rlist(i)
+c           maxerr    - pointer to the interval with largest
+c                       error estimate
+c           errmax    - elist(maxerr)
+c           area      - sum of the integrals over the subintervals
+c           errsum    - sum of the errors over the subintervals
+c           errbnd    - requested accuracy max(epsabs,epsrel*
+c                       abs(result))
+c           *****1    - variable for the left subinterval
+c           *****2    - variable for the right subinterval
+c           last      - index for subdivision
+c
+c
+c           machine dependent constants
+c           ---------------------------
+c
+c           epmach  is the largest relative spacing.
+c           uflow  is the smallest positive magnitude.
+c
+c***first executable statement  dqage
+      epmach = d1mach(4)
+      uflow = d1mach(1)
+c
+c           test on validity of parameters
+c           ------------------------------
+c
+      ier = 0
+      neval = 0
+      last = 0
+      result = 0.0d+00
+      abserr = 0.0d+00
+      alist(1) = a
+      blist(1) = b
+      rlist(1) = 0.0d+00
+      elist(1) = 0.0d+00
+      iord(1) = 0
+      if(epsabs.le.0.0d+00.and.
+     *  epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28)) ier = 6
+      if(ier.eq.6) go to 999
+c
+c           first approximation to the integral
+c           -----------------------------------
+c
+      neval = 0
+      call dqk15(f,a,b,result,abserr,defabs,resabs)
+      last = 1
+      rlist(1) = result
+      elist(1) = abserr
+      iord(1) = 1
+c
+c           test on accuracy.
+c
+      errbnd = dmax1(epsabs,epsrel*dabs(result))
+      if(abserr.le.0.5d+02*epmach*defabs.and.abserr.gt.errbnd) ier = 2
+      if(limit.eq.1) ier = 1
+      if(ier.ne.0.or.(abserr.le.errbnd.and.abserr.ne.resabs)
+     *  .or.abserr.eq.0.0d+00) go to 60
+c
+c           initialization
+c           --------------
+c
+c
+      errmax = abserr
+      maxerr = 1
+      area = result
+      errsum = abserr
+      nrmax = 1
+      iroff1 = 0
+      iroff2 = 0
+c
+c           main do-loop
+c           ------------
+c
+      do 30 last = 2,limit
+c
+c           bisect the subinterval with the largest error estimate.
+c
+        a1 = alist(maxerr)
+        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
+        a2 = b1
+        b2 = blist(maxerr)
+        call dqk15(f,a1,b1,area1,error1,resabs,defab1)
+        call dqk15(f,a2,b2,area2,error2,resabs,defab2)
+c
+c           improve previous approximations to integral
+c           and error and test for accuracy.
+c
+        neval = neval+1
+        area12 = area1+area2
+        erro12 = error1+error2
+        errsum = errsum+erro12-errmax
+        area = area+area12-rlist(maxerr)
+        if(defab1.eq.error1.or.defab2.eq.error2) go to 5
+        if(dabs(rlist(maxerr)-area12).le.0.1d-04*dabs(area12)
+     *  .and.erro12.ge.0.99d+00*errmax) iroff1 = iroff1+1
+        if(last.gt.10.and.erro12.gt.errmax) iroff2 = iroff2+1
+    5   rlist(maxerr) = area1
+        rlist(last) = area2
+        errbnd = dmax1(epsabs,epsrel*dabs(area))
+        if(errsum.le.errbnd) go to 8
+c
+c           test for roundoff error and eventually set error flag.
+c
+        if(iroff1.ge.6.or.iroff2.ge.20) ier = 2
+c
+c           set error flag in the case that the number of subintervals
+c           equals limit.
+c
+        if(last.eq.limit) ier = 1
+c
+c           set error flag in the case of bad integrand behaviour
+c           at a point of the integration range.
+c
+        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*
+     *  epmach)*(dabs(a2)+0.1d+04*uflow)) ier = 3
+c
+c           append the newly-created intervals to the list.
+c
+    8   if(error2.gt.error1) go to 10
+        alist(last) = a2
+        blist(maxerr) = b1
+        blist(last) = b2
+        elist(maxerr) = error1
+        elist(last) = error2
+        go to 20
+   10   alist(maxerr) = a2
+        alist(last) = a1
+        blist(last) = b1
+        rlist(maxerr) = area2
+        rlist(last) = area1
+        elist(maxerr) = error2
+        elist(last) = error1
+c
+c           call subroutine dqpsrt to maintain the descending ordering
+c           in the list of error estimates and select the subinterval
+c           with the largest error estimate (to be bisected next).
+c
+   20   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
+c ***jump out of do-loop
+        if(ier.ne.0.or.errsum.le.errbnd) go to 40
+   30 continue
+c
+c           compute final result.
+c           ---------------------
+c
+   40 result = 0.0d+00
+      do 50 k=1,last
+        result = result+rlist(k)
+   50 continue
+      abserr = errsum
+   60 neval = 30*neval+15
+  999 return
+      end
diff --git a/gcc/testsuite/g77.f-torture/compile/980310-6.f b/gcc/testsuite/g77.f-torture/compile/980310-6.f
new file mode 100644
index 00000000000..fd91500eea8
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980310-6.f
@@ -0,0 +1,21 @@
+C From: Norbert Conrad <Norbert.Conrad@hrz.uni-giessen.de>
+C Message-Id: <199711131008.LAA12272@marvin.hrz.uni-giessen.de>
+C Subject: 971105  g77 bug
+C To: egcs-bugs@cygnus.com
+C Date: Thu, 13 Nov 1997 11:08:19 +0100 (CET)
+
+C I found a bug in g77 in snapshot 971105
+
+      subroutine ai (a)
+      dimension a(-1:*)
+      return
+      end
+C ai.f: In subroutine `ai':
+C ai.f:1: 
+C          subroutine ai (a)
+C                         ^
+C Array `a' at (^) is too large to handle
+C 
+C This happens whenever the lower index boundary is negative and the upper index
+C boundary is '*'. 
+
diff --git a/gcc/testsuite/g77.f-torture/compile/980310-7.f b/gcc/testsuite/g77.f-torture/compile/980310-7.f
new file mode 100644
index 00000000000..9cfbaed692a
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980310-7.f
@@ -0,0 +1,50 @@
+C From: "David C. Doherty" <doherty@networkcs.com>
+C Message-Id: <199711171846.MAA27947@uh.msc.edu>
+C Subject: g77: auto arrays + goto = no go
+C To: egcs-bugs@cygnus.com
+C Date: Mon, 17 Nov 1997 12:46:27 -0600 (CST)
+
+C I sent the following to fortran@gnu.ai.mit.edu, and Dave Love
+C replied that he was able to reproduce it on rs6000-aix; not on
+C others. He suggested that I send it to egcs-bugs. 
+
+C Hi - I've observed the following behavior regarding 
+C automatic arrays and gotos.  Seems similar to what I found
+C in the docs about computed gotos (but not exactly the same).
+C 
+C I suspect from the nature of the error msg that it's in the GBE.
+C 
+C I'm using egcs-971105, under linux-ppc.
+C 
+C I also observed the same in g77-0.5.19 (and gcc 2.7.2?).
+C 
+C I'd appreciate any advice on this.  thanks for the great work.
+C --
+C >cat testg77.f
+      subroutine testg77(n, a)
+c
+      implicit none
+c
+      integer n
+      real a(n)
+      real b(n)
+      integer i
+c
+      do i = 1, 10
+        if (i .gt. 4) goto 100
+        write(0, '(i2)')i
+      enddo
+c
+      goto 200
+100   continue
+200   continue
+c
+      return
+      end
+C >g77 -c testg77.f
+C testg77.f: In subroutine `testg77':
+C testg77.f:19: label `200' used before containing binding contour
+C testg77.f:18: label `100' used before containing binding contour
+C --
+C If I comment out the b(n) line or replace it with, e.g., b(10),
+C it compiles fine.
diff --git a/gcc/testsuite/g77.f-torture/compile/980310-8.f b/gcc/testsuite/g77.f-torture/compile/980310-8.f
new file mode 100644
index 00000000000..9501012f60a
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980310-8.f
@@ -0,0 +1,39 @@
+C To: egcs-bugs@cygnus.com
+C Subject: egcs-g77 and array indexing
+C Reply-To: etseidl@jutland.ca.sandia.gov
+C Date: Wed, 26 Nov 1997 10:38:27 -0800
+C From: Edward Seidl <etseidl@jutland.ca.sandia.gov>
+C	
+C	I have some horrible spaghetti code I'm trying compile with egcs-g77,
+C	but it's puking on code like the example below.  I have no idea if it's
+C	legal fortran or not, and I'm in no position to change it.  All I do know
+C	is it compiles with a number of other compilers, including f2c and
+C	g77-0.5.19.1/gcc-2.7.2.1.  When I try to compile with egcs-2.90.18 971122
+C	I get the following (on both i686-pc-linux-gnu and alphaev56-unknown-linux-gnu):
+C	
+C	foo.f: In subroutine `foobar':
+C	foo.f:11: 
+C	         subroutine foobar(norb,nnorb)
+C	                           ^
+C	Array `norb' at (^) is too large to handle
+
+      program foo
+      implicit integer(A-Z)
+      dimension norb(6)
+      nnorb=6
+
+      call foobar(norb,nnorb)
+
+      stop
+      end
+
+      subroutine foobar(norb,nnorb)
+      implicit integer(A-Z)
+      dimension norb(-1:*)
+
+      do 10 i=-1,nnorb-2
+        norb(i) = i+999
+  10  continue
+
+      return
+      end
diff --git a/gcc/testsuite/g77.f-torture/compile/980419-2.f b/gcc/testsuite/g77.f-torture/compile/980419-2.f
new file mode 100644
index 00000000000..ac9134dc8a7
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980419-2.f
@@ -0,0 +1,48 @@
+c     SEGVs in loop.c with -O2.
+
+      character*80 function nxtlin(lun,ierr,itok)
+      character onechr*1,twochr*2,thrchr*3
+      itok=0
+      do while (.true.)
+         read (lun,'(a)',iostat=ierr) nxtlin
+         if (nxtlin(1:1).ne.'#') then
+            ito=0
+            do 10 it=1,79
+               if (nxtlin(it:it).ne.' ' .and. nxtlin(it+1:it+1).eq.' ')
+     $              then
+                  itast=0
+                  itstrt=0
+                  do itt=ito+1,it
+                     if (nxtlin(itt:itt).eq.'*') itast=itt
+                  enddo
+                  itstrt=ito+1
+                  do while (nxtlin(itstrt:itstrt).eq.' ')
+                     itstrt=itstrt+1
+                  enddo
+                  if (itast.gt.0) then
+                     nchrs=itast-itstrt
+                     if (nchrs.eq.1) then
+                        onechr=nxtlin(itstrt:itstrt)
+                        read (onechr,*) itokn
+                     elseif (nchrs.eq.2) then
+                        twochr=nxtlin(itstrt:itstrt+1)
+                        read (twochr,*) itokn
+                     elseif (nchrs.eq.3) then
+                        thrchr=nxtlin(itstrt:itstrt+2)
+                        read (thrchr,*) itokn
+                     elseif (nchrs.eq.4) then
+                        thrchr=nxtlin(itstrt:itstrt+3)
+                        read (thrchr,*) itokn
+                     endif
+                     itok=itok+itokn
+                  else
+                     itok=itok+1
+                  endif
+                  ito=it+1
+               endif
+ 10         continue
+            return
+         endif
+      enddo
+      return
+      end
diff --git a/gcc/testsuite/g77.f-torture/compile/980424-0.f b/gcc/testsuite/g77.f-torture/compile/980424-0.f
new file mode 100644
index 00000000000..5df45bb79a9
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980424-0.f
@@ -0,0 +1,6 @@
+C     crashes in subst_stack_regs_pat on x86-linux, in the "abort();"
+C     within the switch statement.
+      SUBROUTINE C(A)
+      COMPLEX A
+      WRITE(*,*) A.NE.CMPLX(0.0D0)
+      END
diff --git a/gcc/testsuite/g77.f-torture/compile/980427-0.f b/gcc/testsuite/g77.f-torture/compile/980427-0.f
new file mode 100644
index 00000000000..d5d7d74c57b
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980427-0.f
@@ -0,0 +1,8 @@
+c ../../egcs/gcc/f/com.c:938: failed assertion `TREE_CODE (TREE_TYPE (e)) == REAL_TYPE'
+c     Fixed by 28-04-1998 global.c (ffeglobal_ref_progunit_) change.
+      external b
+      call y(b)
+      end
+      subroutine x
+      a = b()
+      end
diff --git a/gcc/testsuite/g77.f-torture/compile/980729-0.f b/gcc/testsuite/g77.f-torture/compile/980729-0.f
new file mode 100644
index 00000000000..07789441d41
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/980729-0.f
@@ -0,0 +1,5 @@
+c     Got ICE on Alpha only with -mieee (currently not tested).
+c     Fixed by rth 1998-07-30 alpha.md change.
+      subroutine a(b,c)
+      b = max(b,c)
+      end
diff --git a/gcc/testsuite/g77.f-torture/compile/981117-1.f b/gcc/testsuite/g77.f-torture/compile/981117-1.f
new file mode 100644
index 00000000000..019167064fa
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/981117-1.f
@@ -0,0 +1,23 @@
+* egcs-bugs:
+* From: Martin Kahlert <martin.kahlert@mchp.siemens.de>
+* Subject: ICE in g77 from egcs-19981109
+* Message-Id: <199811101134.MAA29838@keksy.mchp.siemens.de>
+
+* As of 1998-11-17, fails -O2 -fomit-frame-pointer with 
+* egcs/gcc/testsuite/g77.f-torture/compile/981117-1.f:8: internal error--insn does not satisfy its constraints:
+* (insn 31 83 32 (set (reg:SF 8 %st(0))
+*         (mult:SF (reg:SF 8 %st(0))
+*             (const_double:SF (mem/u:SF (symbol_ref/u:SI ("*.LC1")) 0) 0 0 1073643520))) 350 {strlensi-3} (nil)
+*     (nil))
+* ../../egcs/gcc/toplev.c:1390: Internal compiler error in function fatal_insn
+
+* Fixed sometime before 1998-11-21 -- don't know by which change.
+
+      SUBROUTINE SSPTRD
+      PARAMETER (HALF = 0.5 )
+      DO I = 1, N
+         CALL SSPMV(TAUI)
+         ALPHA = -HALF*TAUI
+         CALL SAXPY(ALPHA)
+      ENDDO
+      END
diff --git a/gcc/testsuite/g77.f-torture/compile/990115-1.f b/gcc/testsuite/g77.f-torture/compile/990115-1.f
new file mode 100644
index 00000000000..187e1b463b5
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/990115-1.f
@@ -0,0 +1,8 @@
+C Derived from lapack
+      SUBROUTINE ZGELSX( M, N, NRHS, A, LDA, B, LDB, JPVT, RCOND, RANK,
+     $                   WORK, RWORK, INFO )
+      COMPLEX*16         WORK( * )
+            DO 20 I = 1, RANK
+               WORK( ISMAX+I-1 ) = S2*WORK( ISMAX+I-1 )
+   20       CONTINUE
+      END
diff --git a/gcc/testsuite/g77.f-torture/compile/alpha1.f b/gcc/testsuite/g77.f-torture/compile/alpha1.f
new file mode 100644
index 00000000000..7cda74ebd45
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/alpha1.f
@@ -0,0 +1,10 @@
+      REAL*8 A,B,C
+      REAL*4 RARRAY(19)/19*(-1)/
+      INTEGER BOTTOM,RIGHT
+      INTEGER IARRAY(19)/0,0,0,0,0,0,0,0,0,0,0,0,13,14,0,0,0,0,0/
+      EQUIVALENCE (RARRAY(13),BOTTOM),(RARRAY(14),RIGHT)
+C
+      IF(I.NE.0) call exit(1)
+C gcc: Internal compiler error: program f771 got fatal signal 11
+C  at this point!
+      END
diff --git a/gcc/testsuite/g77.f-torture/compile/compile.exp b/gcc/testsuite/g77.f-torture/compile/compile.exp
new file mode 100644
index 00000000000..a2a2177a94f
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/compile.exp
@@ -0,0 +1,44 @@
+# Expect driver script for GCC Regression Tests
+# Copyright (C) 1993, 1995, 1997 Free Software Foundation
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+
+# These tests come from Torbjorn Granlund's (tege@cygnus.com)
+# F torture test suite, and other contributors.
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib f-torture.exp
+
+foreach testcase [glob -nocomplain $srcdir/$subdir/*.f] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $testcase] then {
+	continue
+    }
+
+    f-torture $testcase
+}
+
+foreach testcase [glob -nocomplain $srcdir/$subdir/*.F] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $testcase] then {
+	continue
+    }
+
+    f-torture $testcase
+}
diff --git a/gcc/testsuite/g77.f-torture/compile/toon_1.f b/gcc/testsuite/g77.f-torture/compile/toon_1.f
new file mode 100644
index 00000000000..6b6847c4de5
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/compile/toon_1.f
@@ -0,0 +1,3 @@
+      SUBROUTINE AAP(NOOT)
+      DIMENSION NOOT(*)
+      END
diff --git a/gcc/testsuite/g77.f-torture/execute/19981119-0.f b/gcc/testsuite/g77.f-torture/execute/19981119-0.f
new file mode 100644
index 00000000000..5cfab57a5fc
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/19981119-0.f
@@ -0,0 +1,40 @@
+* X-Delivered: at request of burley on mescaline.gnu.org
+* Date: Sat, 31 Oct 1998 18:26:29 +0200 (EET)
+* From: "B. Yanchitsky" <yan@im.imag.kiev.ua>
+* To: fortran@gnu.org
+* Subject: Bug report
+* MIME-Version: 1.0
+* Content-Type: TEXT/PLAIN; charset=US-ASCII
+* 
+* There is a trouble with g77 on Alpha.
+* My configuration: 
+* Digital Personal Workstation 433au,
+* Digital Unix 4.0D,
+* GNU Fortran 0.5.23 and GNU C 2.8.1.
+* 
+* The following program treated successfully but crashed when running. 
+* 
+* C --- PROGRAM BEGIN -------
+* 
+      subroutine sub(N,u)
+      integer N
+      double precision u(-N:N,-N:N)
+
+C vvvv    CRASH HERE   vvvvv   
+      u(-N,N)=0d0
+      return
+      end
+
+
+      program bug
+      integer N
+      double precision a(-10:10,-10:10)
+      data a/441*1d0/
+      N=10
+      call sub(N,a)
+      if (a(-N,N) .ne. 0d0) call abort
+      end
+* 
+* C --- PROGRAM END -------
+* 
+* Good luck!
diff --git a/gcc/testsuite/g77.f-torture/execute/19990313-0.f b/gcc/testsuite/g77.f-torture/execute/19990313-0.f
new file mode 100644
index 00000000000..abf898fb793
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/19990313-0.f
@@ -0,0 +1,33 @@
+* To: craig@jcb-sc.com
+* Subject: Re: G77 and KIND=2
+* Content-Type: text/plain; charset=us-ascii
+* From: Dave Love <d.love@dl.ac.uk>
+* Date: 03 Mar 1999 18:20:11 +0000
+* In-Reply-To: craig@jcb-sc.com's message of "1 Mar 1999 21:04:38 -0000"
+* User-Agent: Gnus/5.07007 (Pterodactyl Gnus v0.70) Emacs/20.3
+* X-UIDL: d442bafe961c2a6ec6904f492e05d7b0
+* 
+* ISTM that there is a real problem printing integer*8 (on x86):
+* 
+* $ cat x.f
+*[modified for test suite]
+        integer *8 foo, bar
+        data r/4e10/
+        foo = 4e10
+        bar = r
+        if (foo .ne. bar) call abort
+        end
+* $ g77 x.f && ./a.out
+*  1345294336
+*  123
+* $ f2c x.f && g77 x.c && ./a.out
+* x.f:
+*    MAIN:
+*  40000000000
+*  123
+* $
+* 
+* Gdb shows the upper half of the buffer passed to do_lio is zeroed in
+* the g77 case.
+* 
+* I've forgotten how the code generation happens.
diff --git a/gcc/testsuite/g77.f-torture/execute/19990313-1.f b/gcc/testsuite/g77.f-torture/execute/19990313-1.f
new file mode 100644
index 00000000000..d99c72f2fde
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/19990313-1.f
@@ -0,0 +1,7 @@
+        integer *8 foo, bar
+	double precision r
+        data r/4d10/
+        foo = 4d10
+        bar = r
+        if (foo .ne. bar) call abort
+        end
diff --git a/gcc/testsuite/g77.f-torture/execute/19990313-2.f b/gcc/testsuite/g77.f-torture/execute/19990313-2.f
new file mode 100644
index 00000000000..ffb7549d413
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/19990313-2.f
@@ -0,0 +1,7 @@
+        integer *8 foo, bar
+	complex c
+        data c/(4e10,0)/
+        foo = 4e10
+        bar = c
+        if (foo .ne. bar) call abort
+        end
diff --git a/gcc/testsuite/g77.f-torture/execute/19990313-3.f b/gcc/testsuite/g77.f-torture/execute/19990313-3.f
new file mode 100644
index 00000000000..6366dccd890
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/19990313-3.f
@@ -0,0 +1,7 @@
+        integer *8 foo, bar
+	double complex c
+        data c/(4d10,0)/
+        foo = 4d10
+        bar = c
+        if (foo .ne. bar) call abort
+        end
diff --git a/gcc/testsuite/g77.f-torture/execute/19990325-0.f b/gcc/testsuite/g77.f-torture/execute/19990325-0.f
new file mode 100644
index 00000000000..a230362fdde
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/19990325-0.f
@@ -0,0 +1,313 @@
+* test whether complex operators properly handle
+* full and partial aliasing.
+* (libf2c/libF77 routines used to assume no aliasing,
+* then were changed to accommodate full aliasing, while
+* the libg2c/libF77 versions were changed to accommodate
+* both full and partial aliasing.)
+*
+* NOTE: this (19990325-0.f) is the single-precision version.
+* See 19990325-1.f for the double-precision version.
+
+      program complexalias
+      implicit none
+
+* Make sure non-aliased cases work.  (Catch roundoff/precision
+* problems, etc., here.  Modify subroutine check if they occur.)
+
+      call tryfull (1, 3, 5)
+
+* Now check various combinations of aliasing.
+
+* Full aliasing.
+      call tryfull (1, 1, 5)
+
+* Partial aliasing.
+      call trypart (2, 3, 5)
+      call trypart (2, 1, 5)
+      call trypart (2, 5, 3)
+      call trypart (2, 5, 1)
+
+      end
+
+      subroutine tryfull (xout, xin1, xin2)
+      implicit none
+      integer xout, xin1, xin2
+
+* out, in1, and in2 are the desired indexes into the REAL array (array).
+
+      complex expect
+      integer pwr
+      integer out, in1, in2
+
+      real array(6)
+      complex carray(3)
+      equivalence (carray(1), array(1))
+
+* Make sure the indexes can be accommodated by the equivalences above.
+
+      if (mod (xout, 2) .ne. 1) call abort
+      if (mod (xin1, 2) .ne. 1) call abort
+      if (mod (xin2, 2) .ne. 1) call abort
+
+* Convert the indexes into ones suitable for the COMPLEX array (carray).
+
+      out = (xout + 1) / 2
+      in1 = (xin1 + 1) / 2
+      in2 = (xin2 + 1) / 2
+
+* Check some open-coded stuff, just in case.
+
+      call prepare1 (carray(in1))
+      expect = + carray(in1)
+      carray(out) = + carray(in1)
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = - carray(in1)
+      carray(out) = - carray(in1)
+      call check (expect, carray(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) + carray(in2)
+      carray(out) = carray(in1) + carray(in2)
+      call check (expect, carray(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) - carray(in2)
+      carray(out) = carray(in1) - carray(in2)
+      call check (expect, carray(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) * carray(in2)
+      carray(out) = carray(in1) * carray(in2)
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** 2
+      carray(out) = carray(in1) ** 2
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** 3
+      carray(out) = carray(in1) ** 3
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = abs (carray(in1))
+      array(out*2-1) = abs (carray(in1))
+      array(out*2) = 0
+      call check (expect, carray(out))
+
+* Now check the stuff implemented in libF77.
+
+      call prepare1 (carray(in1))
+      expect = cos (carray(in1))
+      carray(out) = cos (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = exp (carray(in1))
+      carray(out) = exp (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = log (carray(in1))
+      carray(out) = log (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = sin (carray(in1))
+      carray(out) = sin (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = sqrt (carray(in1))
+      carray(out) = sqrt (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = conjg (carray(in1))
+      carray(out) = conjg (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1i (carray(in1), pwr)
+      expect = carray(in1) ** pwr
+      carray(out) = carray(in1) ** pwr
+      call check (expect, carray(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) / carray(in2)
+      carray(out) = carray(in1) / carray(in2)
+      call check (expect, carray(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) ** carray(in2)
+      carray(out) = carray(in1) ** carray(in2)
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** .2
+      carray(out) = carray(in1) ** .2
+      call check (expect, carray(out))
+
+      end
+
+      subroutine trypart (xout, xin1, xin2)
+      implicit none
+      integer xout, xin1, xin2
+
+* out, in1, and in2 are the desired indexes into the REAL array (array).
+
+      complex expect
+      integer pwr
+      integer out, in1, in2
+
+      real array(6)
+      complex carray(3), carrayp(2)
+      equivalence (carray(1), array(1))
+      equivalence (carrayp(1), array(2))
+
+* Make sure the indexes can be accommodated by the equivalences above.
+
+      if (mod (xout, 2) .ne. 0) call abort
+      if (mod (xin1, 2) .ne. 1) call abort
+      if (mod (xin2, 2) .ne. 1) call abort
+
+* Convert the indexes into ones suitable for the COMPLEX array (carray).
+
+      out = xout / 2
+      in1 = (xin1 + 1) / 2
+      in2 = (xin2 + 1) / 2
+
+* Check some open-coded stuff, just in case.
+
+      call prepare1 (carray(in1))
+      expect = + carray(in1)
+      carrayp(out) = + carray(in1)
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = - carray(in1)
+      carrayp(out) = - carray(in1)
+      call check (expect, carrayp(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) + carray(in2)
+      carrayp(out) = carray(in1) + carray(in2)
+      call check (expect, carrayp(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) - carray(in2)
+      carrayp(out) = carray(in1) - carray(in2)
+      call check (expect, carrayp(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) * carray(in2)
+      carrayp(out) = carray(in1) * carray(in2)
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** 2
+      carrayp(out) = carray(in1) ** 2
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** 3
+      carrayp(out) = carray(in1) ** 3
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = abs (carray(in1))
+      array(out*2) = abs (carray(in1))
+      array(out*2+1) = 0
+      call check (expect, carrayp(out))
+
+* Now check the stuff implemented in libF77.
+
+      call prepare1 (carray(in1))
+      expect = cos (carray(in1))
+      carrayp(out) = cos (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = exp (carray(in1))
+      carrayp(out) = exp (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = log (carray(in1))
+      carrayp(out) = log (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = sin (carray(in1))
+      carrayp(out) = sin (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = sqrt (carray(in1))
+      carrayp(out) = sqrt (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = conjg (carray(in1))
+      carrayp(out) = conjg (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1i (carray(in1), pwr)
+      expect = carray(in1) ** pwr
+      carrayp(out) = carray(in1) ** pwr
+      call check (expect, carrayp(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) / carray(in2)
+      carrayp(out) = carray(in1) / carray(in2)
+      call check (expect, carrayp(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) ** carray(in2)
+      carrayp(out) = carray(in1) ** carray(in2)
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** .2
+      carrayp(out) = carray(in1) ** .2
+      call check (expect, carrayp(out))
+
+      end
+
+      subroutine prepare1 (in)
+      implicit none
+      complex in
+
+      in = (3.2, 4.2)
+
+      end
+
+      subroutine prepare1i (in, i)
+      implicit none
+      complex in
+      integer i
+
+      in = (2.3, 2.5)
+      i = 4
+
+      end
+
+      subroutine prepare2 (in1, in2)
+      implicit none
+      complex in1, in2
+
+      in1 = (1.3, 2.4)
+      in2 = (3.5, 7.1)
+
+      end
+
+      subroutine check (expect, got)
+      implicit none
+      complex expect, got
+
+      if (aimag(expect) .ne. aimag(got)) call abort
+      if (real(expect) .ne. real(got)) call abort
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/19990325-1.f b/gcc/testsuite/g77.f-torture/execute/19990325-1.f
new file mode 100644
index 00000000000..802f375b33d
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/19990325-1.f
@@ -0,0 +1,313 @@
+* test whether complex operators properly handle
+* full and partial aliasing.
+* (libf2c/libF77 routines used to assume no aliasing,
+* then were changed to accommodate full aliasing, while
+* the libg2c/libF77 versions were changed to accommodate
+* both full and partial aliasing.)
+*
+* NOTE: this (19990325-1.f) is the double-precision version.
+* See 19990325-0.f for the single-precision version.
+
+      program doublecomplexalias
+      implicit none
+
+* Make sure non-aliased cases work.  (Catch roundoff/precision
+* problems, etc., here.  Modify subroutine check if they occur.)
+
+      call tryfull (1, 3, 5)
+
+* Now check various combinations of aliasing.
+
+* Full aliasing.
+      call tryfull (1, 1, 5)
+
+* Partial aliasing.
+      call trypart (2, 3, 5)
+      call trypart (2, 1, 5)
+      call trypart (2, 5, 3)
+      call trypart (2, 5, 1)
+
+      end
+
+      subroutine tryfull (xout, xin1, xin2)
+      implicit none
+      integer xout, xin1, xin2
+
+* out, in1, and in2 are the desired indexes into the REAL array (array).
+
+      double complex expect
+      integer pwr
+      integer out, in1, in2
+
+      double precision array(6)
+      double complex carray(3)
+      equivalence (carray(1), array(1))
+
+* Make sure the indexes can be accommodated by the equivalences above.
+
+      if (mod (xout, 2) .ne. 1) call abort
+      if (mod (xin1, 2) .ne. 1) call abort
+      if (mod (xin2, 2) .ne. 1) call abort
+
+* Convert the indexes into ones suitable for the COMPLEX array (carray).
+
+      out = (xout + 1) / 2
+      in1 = (xin1 + 1) / 2
+      in2 = (xin2 + 1) / 2
+
+* Check some open-coded stuff, just in case.
+
+      call prepare1 (carray(in1))
+      expect = + carray(in1)
+      carray(out) = + carray(in1)
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = - carray(in1)
+      carray(out) = - carray(in1)
+      call check (expect, carray(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) + carray(in2)
+      carray(out) = carray(in1) + carray(in2)
+      call check (expect, carray(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) - carray(in2)
+      carray(out) = carray(in1) - carray(in2)
+      call check (expect, carray(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) * carray(in2)
+      carray(out) = carray(in1) * carray(in2)
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** 2
+      carray(out) = carray(in1) ** 2
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** 3
+      carray(out) = carray(in1) ** 3
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = abs (carray(in1))
+      array(out*2-1) = abs (carray(in1))
+      array(out*2) = 0
+      call check (expect, carray(out))
+
+* Now check the stuff implemented in libF77.
+
+      call prepare1 (carray(in1))
+      expect = cos (carray(in1))
+      carray(out) = cos (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = exp (carray(in1))
+      carray(out) = exp (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = log (carray(in1))
+      carray(out) = log (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = sin (carray(in1))
+      carray(out) = sin (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = sqrt (carray(in1))
+      carray(out) = sqrt (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = conjg (carray(in1))
+      carray(out) = conjg (carray(in1))
+      call check (expect, carray(out))
+
+      call prepare1i (carray(in1), pwr)
+      expect = carray(in1) ** pwr
+      carray(out) = carray(in1) ** pwr
+      call check (expect, carray(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) / carray(in2)
+      carray(out) = carray(in1) / carray(in2)
+      call check (expect, carray(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) ** carray(in2)
+      carray(out) = carray(in1) ** carray(in2)
+      call check (expect, carray(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** .2
+      carray(out) = carray(in1) ** .2
+      call check (expect, carray(out))
+
+      end
+
+      subroutine trypart (xout, xin1, xin2)
+      implicit none
+      integer xout, xin1, xin2
+
+* out, in1, and in2 are the desired indexes into the REAL array (array).
+
+      double complex expect
+      integer pwr
+      integer out, in1, in2
+
+      double precision array(6)
+      double complex carray(3), carrayp(2)
+      equivalence (carray(1), array(1))
+      equivalence (carrayp(1), array(2))
+
+* Make sure the indexes can be accommodated by the equivalences above.
+
+      if (mod (xout, 2) .ne. 0) call abort
+      if (mod (xin1, 2) .ne. 1) call abort
+      if (mod (xin2, 2) .ne. 1) call abort
+
+* Convert the indexes into ones suitable for the COMPLEX array (carray).
+
+      out = xout / 2
+      in1 = (xin1 + 1) / 2
+      in2 = (xin2 + 1) / 2
+
+* Check some open-coded stuff, just in case.
+
+      call prepare1 (carray(in1))
+      expect = + carray(in1)
+      carrayp(out) = + carray(in1)
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = - carray(in1)
+      carrayp(out) = - carray(in1)
+      call check (expect, carrayp(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) + carray(in2)
+      carrayp(out) = carray(in1) + carray(in2)
+      call check (expect, carrayp(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) - carray(in2)
+      carrayp(out) = carray(in1) - carray(in2)
+      call check (expect, carrayp(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) * carray(in2)
+      carrayp(out) = carray(in1) * carray(in2)
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** 2
+      carrayp(out) = carray(in1) ** 2
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** 3
+      carrayp(out) = carray(in1) ** 3
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = abs (carray(in1))
+      array(out*2) = abs (carray(in1))
+      array(out*2+1) = 0
+      call check (expect, carrayp(out))
+
+* Now check the stuff implemented in libF77.
+
+      call prepare1 (carray(in1))
+      expect = cos (carray(in1))
+      carrayp(out) = cos (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = exp (carray(in1))
+      carrayp(out) = exp (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = log (carray(in1))
+      carrayp(out) = log (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = sin (carray(in1))
+      carrayp(out) = sin (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = sqrt (carray(in1))
+      carrayp(out) = sqrt (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = conjg (carray(in1))
+      carrayp(out) = conjg (carray(in1))
+      call check (expect, carrayp(out))
+
+      call prepare1i (carray(in1), pwr)
+      expect = carray(in1) ** pwr
+      carrayp(out) = carray(in1) ** pwr
+      call check (expect, carrayp(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) / carray(in2)
+      carrayp(out) = carray(in1) / carray(in2)
+      call check (expect, carrayp(out))
+
+      call prepare2 (carray(in1), carray(in2))
+      expect = carray(in1) ** carray(in2)
+      carrayp(out) = carray(in1) ** carray(in2)
+      call check (expect, carrayp(out))
+
+      call prepare1 (carray(in1))
+      expect = carray(in1) ** .2
+      carrayp(out) = carray(in1) ** .2
+      call check (expect, carrayp(out))
+
+      end
+
+      subroutine prepare1 (in)
+      implicit none
+      double complex in
+
+      in = (3.2d0, 4.2d0)
+
+      end
+
+      subroutine prepare1i (in, i)
+      implicit none
+      double complex in
+      integer i
+
+      in = (2.3d0, 2.5d0)
+      i = 4
+
+      end
+
+      subroutine prepare2 (in1, in2)
+      implicit none
+      double complex in1, in2
+
+      in1 = (1.3d0, 2.4d0)
+      in2 = (3.5d0, 7.1d0)
+
+      end
+
+      subroutine check (expect, got)
+      implicit none
+      double complex expect, got
+
+      if (dimag(expect) .ne. dimag(got)) call abort
+      if (dble(expect) .ne. dble(got)) call abort
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/19990419-1.f b/gcc/testsuite/g77.f-torture/execute/19990419-1.f
new file mode 100644
index 00000000000..7449bac2b95
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/19990419-1.f
@@ -0,0 +1,21 @@
+* Test DO WHILE, to make sure it fully reevaluates its expression.
+* Belongs in execute/.
+      common /x/ ival
+      j = 0
+      do while (i() .eq. 1)
+         j = j + 1
+         if (j .gt. 5) call abort
+      end do
+      if (j .ne. 4) call abort
+      if (ival .ne. 5) call abort
+      end
+      function i()
+      common /x/ ival
+      ival = ival + 1
+      i = 10
+      if (ival .lt. 5) i = 1
+      end
+      block data
+      common /x/ ival
+      data ival/0/
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/970625-2.f b/gcc/testsuite/g77.f-torture/execute/970625-2.f
new file mode 100644
index 00000000000..3ef6f46cb79
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/970625-2.f
@@ -0,0 +1,84 @@
+* Date: Wed, 25 Jun 1997 12:48:26 +0200 (MET DST)
+* MIME-Version: 1.0
+* From: R.Hooft@EuroMail.com (Rob Hooft)
+* To: g77-alpha@gnu.ai.mit.edu
+* Subject: Re: testing 970624.
+* In-Reply-To: <199706251027.GAA07892@churchy.gnu.ai.mit.edu>
+* References: <199706251018.MAA21538@nu>
+* 	<199706251027.GAA07892@churchy.gnu.ai.mit.edu>
+* X-Mailer: VM 6.30 under Emacs 19.34.1
+* Content-Type: text/plain; charset=US-ASCII
+* 
+* >>>>> "CB" == Craig Burley <burley@gnu.ai.mit.edu> writes:
+* 
+*  CB> but OTOH I'd like to see more problems like this on other
+*  CB> applications, and especially other systems
+* 
+* How about this one: An application that prints "112." on all
+* compilers/platforms I have tested, except with the new g77 on ALPHA (I
+* don't have the new g77 on any other platform here to test)?
+* 
+* Application Appended. Source code courtesy of my boss.....
+* Disclaimer: I do not know the right answer, or even whether there is a
+* single right answer.....
+* 
+* Regards,
+* -- 
+* =====       R.Hooft@EuroMail.com   http://www.Sander.EMBL-Heidelberg.DE/rob/ ==
+* ==== In need of protein modeling?  http://www.Sander.EMBL-Heidelberg.DE/whatif/
+* Validation of protein structures?  http://biotech.EMBL-Heidelberg.DE:8400/ ====
+* == PGPid 0xFA19277D == Use Linux!  Free Software Rules The World! =============
+* 
+* nu[152]for% cat humor.f      
+      PROGRAM SUBROUTINE
+      LOGICAL ELSE IF
+      INTEGER REAL, GO TO PROGRAM, WHILE
+      REAL FORMAT(2)
+      DATA IF,REAL,END DO,WHILE,FORMAT(2),I2/2,6,7,1,112.,1/
+      DO THEN=1, END DO, WHILE
+         CALL = END DO - IF
+         PROGRAM = THEN - IF
+         ELSE IF = THEN .GT. IF
+         IF (THEN.GT.REAL) THEN
+            CALL FUNCTION PROGRAM (ELSE IF, GO TO PROGRAM, THEN)
+         ELSE IF (ELSE IF) THEN
+            REAL = THEN + END DO
+         END IF
+      END DO
+ 10   FORMAT(I2/I2) = WHILE*REAL*THEN
+      IF (FORMAT(I2) .NE. FORMAT(I2+I2)) CALL ABORT
+      END ! DO
+      SUBROUTINE FUNCTION PROGRAM (REAL,INTEGER, LOGICAL)
+      LOGICAL REAL
+      REAL LOGICAL
+      INTEGER INTEGER, STOP, RETURN, GO TO
+      ASSIGN 9 TO STOP
+      ASSIGN = 9 + LOGICAL
+      ASSIGN 7 TO RETURN
+      ASSIGN 9 TO GO TO
+      GO TO = 5
+      STOP = 8
+      IF (.NOT.REAL) GOTO STOP
+      IF (LOGICAL.GT.INTEGER) THEN
+         IF = LOGICAL +5
+         IF (LOGICAL.EQ.5) ASSIGN 5 TO IF
+         INTEGER=IF
+      ELSE
+         IF (ASSIGN.GT.STOP) ASSIGN 9 TO GOTO
+         ELSE = GO TO
+         END IF = ELSE + GO TO
+         IF (.NOT.REAL.AND.GOTO.GT.ELSE) GOTO RETURN
+      END IF
+    5 CONTINUE
+    7 LOGICAL=LOGICAL+STOP
+    9 RETURN
+      END ! IF
+* nu[153]for% f77 humor.f
+* nu[154]for% ./a.out
+*    112.0000    
+* nu[155]for% f90 humor.f  
+* nu[156]for% ./a.out    
+*    112.0000    
+* nu[157]for% g77 humor.f 
+* nu[158]for% ./a.out    
+*   40.
diff --git a/gcc/testsuite/g77.f-torture/execute/970816-3.f b/gcc/testsuite/g77.f-torture/execute/970816-3.f
new file mode 100644
index 00000000000..6398600f059
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/970816-3.f
@@ -0,0 +1,20 @@
+* Date: Wed, 13 Aug 1997 15:34:23 +0200 (METDST)
+* From: Claus Denk <denk@cica.es>
+* To: g77-alpha@gnu.ai.mit.edu
+* Subject: 970811 report - segfault bug on alpha still there
+*[...]
+* Now, the bug that I reported some weeks ago is still there, I'll post
+* the test program again:
+*
+        PROGRAM TEST
+C       a bug in g77-0.5.21 - alpha. Works with NSTART=0 and segfaults with
+C       NSTART=1 on the second write.
+        PARAMETER (NSTART=1,NADD=NSTART+1)
+        REAL AB(NSTART:NSTART)
+        AB(NSTART)=1.0
+        I=1
+        J=2
+        IND=I-J+NADD
+        write(*,*) AB(IND)
+        write(*,*) AB(I-J+NADD)
+        END
diff --git a/gcc/testsuite/g77.f-torture/execute/971102-1.f b/gcc/testsuite/g77.f-torture/execute/971102-1.f
new file mode 100644
index 00000000000..6b0c2f3b3a9
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/971102-1.f
@@ -0,0 +1,11 @@
+       i=3
+       j=0
+       do i=i,5
+         j = j+i
+       end do
+       do i=3,i
+         j = j+i
+       end do
+       if (i.ne.7) call abort()
+       print *, i,j
+       end
diff --git a/gcc/testsuite/g77.f-torture/execute/980520-1.f b/gcc/testsuite/g77.f-torture/execute/980520-1.f
new file mode 100644
index 00000000000..6d05c6767fd
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980520-1.f
@@ -0,0 +1,6 @@
+c     Produced a link error through not eliminating the unused statement
+c     function after 1998-05-15 change to gcc/toplev.c.  It's in
+c     `execute' since it needs to link.
+c     Fixed by 1998-05-23 change to f/com.c.
+      values(i,j) = val((i-1)*n+j)
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-0.f b/gcc/testsuite/g77.f-torture/execute/980628-0.f
new file mode 100644
index 00000000000..c36b1efc052
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-0.f
@@ -0,0 +1,61 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system.
+
+      call subr
+      end
+
+      subroutine subr
+      implicit none
+
+      real r1(5), r2(5), r3(5)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+      equivalence (r1(2), d1)
+      equivalence (r2(2), d2)
+      equivalence (r3(2), d3)
+
+      r1(1) = 1.
+      d1 = 10.
+      r1(4) = 1.
+      r1(5) = 1.
+      i1 = 1
+      r2(1) = 2.
+      d2 = 20.
+      r2(4) = 2.
+      r2(5) = 2.
+      i2 = 2
+      r3(1) = 3.
+      d3 = 30.
+      r3(4) = 3.
+      r3(5) = 3.
+      i3 = 3
+
+      call x (r1, d1, i1, r2, d2, i2, r3, d3, i3)
+
+      end
+
+      subroutine x (r1, d1, i1, r2, d2, i2, r3, d3, i3)
+      implicit none
+
+      real r1(5), r2(5), r3(5)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+
+      if (r1(1) .ne. 1.) call abort
+      if (d1 .ne. 10.) call abort
+      if (r1(4) .ne. 1.) call abort
+      if (r1(5) .ne. 1.) call abort
+      if (i1 .ne. 1) call abort
+      if (r2(1) .ne. 2.) call abort
+      if (d2 .ne. 20.) call abort
+      if (r2(4) .ne. 2.) call abort
+      if (r2(5) .ne. 2.) call abort
+      if (i2 .ne. 2) call abort
+      if (r3(1) .ne. 3.) call abort
+      if (d3 .ne. 30.) call abort
+      if (r3(4) .ne. 3.) call abort
+      if (r3(5) .ne. 3.) call abort
+      if (i3 .ne. 3) call abort
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-1.f b/gcc/testsuite/g77.f-torture/execute/980628-1.f
new file mode 100644
index 00000000000..6ab0a0a81a8
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-1.f
@@ -0,0 +1,62 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system.
+
+      call subr
+      end
+
+      subroutine subr
+      implicit none
+      save
+
+      real r1(5), r2(5), r3(5)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+      equivalence (r1(2), d1)
+      equivalence (r2(2), d2)
+      equivalence (r3(2), d3)
+
+      r1(1) = 1.
+      d1 = 10.
+      r1(4) = 1.
+      r1(5) = 1.
+      i1 = 1
+      r2(1) = 2.
+      d2 = 20.
+      r2(4) = 2.
+      r2(5) = 2.
+      i2 = 2
+      r3(1) = 3.
+      d3 = 30.
+      r3(4) = 3.
+      r3(5) = 3.
+      i3 = 3
+
+      call x (r1, d1, i1, r2, d2, i2, r3, d3, i3)
+
+      end
+
+      subroutine x (r1, d1, i1, r2, d2, i2, r3, d3, i3)
+      implicit none
+
+      real r1(5), r2(5), r3(5)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+
+      if (r1(1) .ne. 1.) call abort
+      if (d1 .ne. 10.) call abort
+      if (r1(4) .ne. 1.) call abort
+      if (r1(5) .ne. 1.) call abort
+      if (i1 .ne. 1) call abort
+      if (r2(1) .ne. 2.) call abort
+      if (d2 .ne. 20.) call abort
+      if (r2(4) .ne. 2.) call abort
+      if (r2(5) .ne. 2.) call abort
+      if (i2 .ne. 2) call abort
+      if (r3(1) .ne. 3.) call abort
+      if (d3 .ne. 30.) call abort
+      if (r3(4) .ne. 3.) call abort
+      if (r3(5) .ne. 3.) call abort
+      if (i3 .ne. 3) call abort
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-10.f b/gcc/testsuite/g77.f-torture/execute/980628-10.f
new file mode 100644
index 00000000000..427f635add9
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-10.f
@@ -0,0 +1,57 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system.
+
+      call subr
+      end
+
+      subroutine subr
+      implicit none
+      save
+
+      character c1(11), c2(11), c3(11)
+      real r1, r2, r3
+      character c4, c5, c6
+      equivalence (r1, c1(2))
+      equivalence (r2, c2(2))
+      equivalence (r3, c3(2))
+
+      c1(1) = '1'
+      r1 = 1.
+      c1(11) = '1'
+      c4 = '4'
+      c2(1) = '2'
+      r2 = 2.
+      c2(11) = '2'
+      c5 = '5'
+      c3(1) = '3'
+      r3 = 3.
+      c3(11) = '3'
+      c6 = '6'
+
+      call x (c1, r1, c2, r2, c3, r3, c4, c5, c6)
+
+      end
+
+      subroutine x (c1, r1, c2, r2, c3, r3, c4, c5, c6)
+      implicit none
+
+      character c1(11), c2(11), c3(11)
+      real r1, r2, r3
+      character c4, c5, c6
+
+      if (c1(1) .ne. '1') call abort
+      if (r1 .ne. 1.) call abort
+      if (c1(11) .ne. '1') call abort
+      if (c4 .ne. '4') call abort
+      if (c2(1) .ne. '2') call abort
+      if (r2 .ne. 2.) call abort
+      if (c2(11) .ne. '2') call abort
+      if (c5 .ne. '5') call abort
+      if (c3(1) .ne. '3') call abort
+      if (r3 .ne. 3.) call abort
+      if (c3(11) .ne. '3') call abort
+      if (c6 .ne. '6') call abort
+
+      end
+
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-2.f b/gcc/testsuite/g77.f-torture/execute/980628-2.f
new file mode 100644
index 00000000000..a140e7db611
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-2.f
@@ -0,0 +1,55 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system.
+
+      call subr
+      end
+
+      subroutine subr
+      implicit none
+
+      character c1(11), c2(11), c3(11)
+      real r1, r2, r3
+      character c4, c5, c6
+      equivalence (c1(2), r1)
+      equivalence (c2(2), r2)
+      equivalence (c3(2), r3)
+
+      c1(1) = '1'
+      r1 = 1.
+      c1(11) = '1'
+      c4 = '4'
+      c2(1) = '2'
+      r2 = 2.
+      c2(11) = '2'
+      c5 = '5'
+      c3(1) = '3'
+      r3 = 3.
+      c3(11) = '3'
+      c6 = '6'
+
+      call x (c1, r1, c2, r2, c3, r3, c4, c5, c6)
+
+      end
+
+      subroutine x (c1, r1, c2, r2, c3, r3, c4, c5, c6)
+      implicit none
+
+      character c1(11), c2(11), c3(11)
+      real r1, r2, r3
+      character c4, c5, c6
+
+      if (c1(1) .ne. '1') call abort
+      if (r1 .ne. 1.) call abort
+      if (c1(11) .ne. '1') call abort
+      if (c4 .ne. '4') call abort
+      if (c2(1) .ne. '2') call abort
+      if (r2 .ne. 2.) call abort
+      if (c2(11) .ne. '2') call abort
+      if (c5 .ne. '5') call abort
+      if (c3(1) .ne. '3') call abort
+      if (r3 .ne. 3.) call abort
+      if (c3(11) .ne. '3') call abort
+      if (c6 .ne. '6') call abort
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-3.f b/gcc/testsuite/g77.f-torture/execute/980628-3.f
new file mode 100644
index 00000000000..47e6ea57301
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-3.f
@@ -0,0 +1,56 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system.
+
+      call subr
+      end
+
+      subroutine subr
+      implicit none
+      save
+
+      character c1(11), c2(11), c3(11)
+      real r1, r2, r3
+      character c4, c5, c6
+      equivalence (c1(2), r1)
+      equivalence (c2(2), r2)
+      equivalence (c3(2), r3)
+
+      c1(1) = '1'
+      r1 = 1.
+      c1(11) = '1'
+      c4 = '4'
+      c2(1) = '2'
+      r2 = 2.
+      c2(11) = '2'
+      c5 = '5'
+      c3(1) = '3'
+      r3 = 3.
+      c3(11) = '3'
+      c6 = '6'
+
+      call x (c1, r1, c2, r2, c3, r3, c4, c5, c6)
+
+      end
+
+      subroutine x (c1, r1, c2, r2, c3, r3, c4, c5, c6)
+      implicit none
+
+      character c1(11), c2(11), c3(11)
+      real r1, r2, r3
+      character c4, c5, c6
+
+      if (c1(1) .ne. '1') call abort
+      if (r1 .ne. 1.) call abort
+      if (c1(11) .ne. '1') call abort
+      if (c4 .ne. '4') call abort
+      if (c2(1) .ne. '2') call abort
+      if (r2 .ne. 2.) call abort
+      if (c2(11) .ne. '2') call abort
+      if (c5 .ne. '5') call abort
+      if (c3(1) .ne. '3') call abort
+      if (r3 .ne. 3.) call abort
+      if (c3(11) .ne. '3') call abort
+      if (c6 .ne. '6') call abort
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-4.f b/gcc/testsuite/g77.f-torture/execute/980628-4.f
new file mode 100644
index 00000000000..40bd6e6df51
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-4.f
@@ -0,0 +1,27 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system,
+* including when initial values are provided (e.g. DATA).
+
+      program test
+      implicit none
+
+      real r
+      double precision d
+      common /cmn/ r, d
+
+      if (r .ne. 1.) call abort
+      if (d .ne. 10.) call abort
+
+      end
+
+      block data init
+      implicit none
+
+      real r
+      double precision d
+      common /cmn/ r, d
+
+      data r/1./, d/10./
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-5.f b/gcc/testsuite/g77.f-torture/execute/980628-5.f
new file mode 100644
index 00000000000..14f39e3c51e
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-5.f
@@ -0,0 +1,27 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system,
+* including when initial values are provided (e.g. DATA).
+
+      program test
+      implicit none
+
+      character c
+      double precision d
+      common /cmn/ c, d
+
+      if (c .ne. '1') call abort
+      if (d .ne. 10.) call abort
+
+      end
+
+      block data init
+      implicit none
+
+      character c
+      double precision d
+      common /cmn/ c, d
+
+      data c/'1'/, d/10./
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-6.f b/gcc/testsuite/g77.f-torture/execute/980628-6.f
new file mode 100644
index 00000000000..c5ade65ed39
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-6.f
@@ -0,0 +1,26 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system,
+* including when initial values are provided (e.g. DATA).
+
+      program test
+      implicit none
+
+      character c
+      double precision d(100)
+      common /cmn/ c, d
+
+      if (d(80) .ne. 10.) call abort
+
+      end
+
+      block data init
+      implicit none
+
+      character c
+      double precision d(100)
+      common /cmn/ c, d
+
+      data d(80)/10./
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-7.f b/gcc/testsuite/g77.f-torture/execute/980628-7.f
new file mode 100644
index 00000000000..c81ba31fc26
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-7.f
@@ -0,0 +1,62 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system.
+
+      call subr
+      end
+
+      subroutine subr
+      implicit none
+
+      real r1(5), r2(5), r3(5)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+      equivalence (d1, r1(2))
+      equivalence (d2, r2(2))
+      equivalence (d3, r3(2))
+
+      r1(1) = 1.
+      d1 = 10.
+      r1(4) = 1.
+      r1(5) = 1.
+      i1 = 1
+      r2(1) = 2.
+      d2 = 20.
+      r2(4) = 2.
+      r2(5) = 2.
+      i2 = 2
+      r3(1) = 3.
+      d3 = 30.
+      r3(4) = 3.
+      r3(5) = 3.
+      i3 = 3
+
+      call x (r1, d1, i1, r2, d2, i2, r3, d3, i3)
+
+      end
+
+      subroutine x (r1, d1, i1, r2, d2, i2, r3, d3, i3)
+      implicit none
+
+      real r1(5), r2(5), r3(5)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+
+      if (r1(1) .ne. 1.) call abort
+      if (d1 .ne. 10.) call abort
+      if (r1(4) .ne. 1.) call abort
+      if (r1(5) .ne. 1.) call abort
+      if (i1 .ne. 1) call abort
+      if (r2(1) .ne. 2.) call abort
+      if (d2 .ne. 20.) call abort
+      if (r2(4) .ne. 2.) call abort
+      if (r2(5) .ne. 2.) call abort
+      if (i2 .ne. 2) call abort
+      if (r3(1) .ne. 3.) call abort
+      if (d3 .ne. 30.) call abort
+      if (r3(4) .ne. 3.) call abort
+      if (r3(5) .ne. 3.) call abort
+      if (i3 .ne. 3) call abort
+
+      end
+
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-8.f b/gcc/testsuite/g77.f-torture/execute/980628-8.f
new file mode 100644
index 00000000000..8940d009954
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-8.f
@@ -0,0 +1,63 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system.
+
+      call subr
+      end
+
+      subroutine subr
+      implicit none
+      save
+
+      real r1(5), r2(5), r3(5)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+      equivalence (d1, r1(2))
+      equivalence (d2, r2(2))
+      equivalence (d3, r3(2))
+
+      r1(1) = 1.
+      d1 = 10.
+      r1(4) = 1.
+      r1(5) = 1.
+      i1 = 1
+      r2(1) = 2.
+      d2 = 20.
+      r2(4) = 2.
+      r2(5) = 2.
+      i2 = 2
+      r3(1) = 3.
+      d3 = 30.
+      r3(4) = 3.
+      r3(5) = 3.
+      i3 = 3
+
+      call x (r1, d1, i1, r2, d2, i2, r3, d3, i3)
+
+      end
+
+      subroutine x (r1, d1, i1, r2, d2, i2, r3, d3, i3)
+      implicit none
+
+      real r1(5), r2(5), r3(5)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+
+      if (r1(1) .ne. 1.) call abort
+      if (d1 .ne. 10.) call abort
+      if (r1(4) .ne. 1.) call abort
+      if (r1(5) .ne. 1.) call abort
+      if (i1 .ne. 1) call abort
+      if (r2(1) .ne. 2.) call abort
+      if (d2 .ne. 20.) call abort
+      if (r2(4) .ne. 2.) call abort
+      if (r2(5) .ne. 2.) call abort
+      if (i2 .ne. 2) call abort
+      if (r3(1) .ne. 3.) call abort
+      if (d3 .ne. 30.) call abort
+      if (r3(4) .ne. 3.) call abort
+      if (r3(5) .ne. 3.) call abort
+      if (i3 .ne. 3) call abort
+
+      end
+
diff --git a/gcc/testsuite/g77.f-torture/execute/980628-9.f b/gcc/testsuite/g77.f-torture/execute/980628-9.f
new file mode 100644
index 00000000000..54e6552d628
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980628-9.f
@@ -0,0 +1,56 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system.
+
+      call subr
+      end
+
+      subroutine subr
+      implicit none
+
+      character c1(11), c2(11), c3(11)
+      real r1, r2, r3
+      character c4, c5, c6
+      equivalence (r1, c1(2))
+      equivalence (r2, c2(2))
+      equivalence (r3, c3(2))
+
+      c1(1) = '1'
+      r1 = 1.
+      c1(11) = '1'
+      c4 = '4'
+      c2(1) = '2'
+      r2 = 2.
+      c2(11) = '2'
+      c5 = '5'
+      c3(1) = '3'
+      r3 = 3.
+      c3(11) = '3'
+      c6 = '6'
+
+      call x (c1, r1, c2, r2, c3, r3, c4, c5, c6)
+
+      end
+
+      subroutine x (c1, r1, c2, r2, c3, r3, c4, c5, c6)
+      implicit none
+
+      character c1(11), c2(11), c3(11)
+      real r1, r2, r3
+      character c4, c5, c6
+
+      if (c1(1) .ne. '1') call abort
+      if (r1 .ne. 1.) call abort
+      if (c1(11) .ne. '1') call abort
+      if (c4 .ne. '4') call abort
+      if (c2(1) .ne. '2') call abort
+      if (r2 .ne. 2.) call abort
+      if (c2(11) .ne. '2') call abort
+      if (c5 .ne. '5') call abort
+      if (c3(1) .ne. '3') call abort
+      if (r3 .ne. 3.) call abort
+      if (c3(11) .ne. '3') call abort
+      if (c6 .ne. '6') call abort
+
+      end
+
diff --git a/gcc/testsuite/g77.f-torture/execute/980701-0.f b/gcc/testsuite/g77.f-torture/execute/980701-0.f
new file mode 100644
index 00000000000..a3ddd55473a
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980701-0.f
@@ -0,0 +1,72 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system.
+
+      call subr
+      end
+
+      subroutine subr
+      implicit none
+
+      real r1(5), r2(5), r3(5)
+      real s1(2), s2(2), s3(2)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+      equivalence (r1, s1(2))
+      equivalence (d1, r1(2))
+      equivalence (r2, s2(2))
+      equivalence (d2, r2(2))
+      equivalence (r3, s3(2))
+      equivalence (d3, r3(2))
+
+      s1(1) = 1.
+      r1(1) = 1.
+      d1 = 10.
+      r1(4) = 1.
+      r1(5) = 1.
+      i1 = 1
+      s2(1) = 2.
+      r2(1) = 2.
+      d2 = 20.
+      r2(4) = 2.
+      r2(5) = 2.
+      i2 = 2
+      s3(1) = 3.
+      r3(1) = 3.
+      d3 = 30.
+      r3(4) = 3.
+      r3(5) = 3.
+      i3 = 3
+
+      call x (s1, r1, d1, i1, s2, r2, d2, i2, s3, r3, d3, i3)
+
+      end
+
+      subroutine x (s1, r1, d1, i1, s2, r2, d2, i2, s3, r3, d3, i3)
+      implicit none
+
+      real r1(5), r2(5), r3(5)
+      real s1(2), s2(2), s3(2)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+
+      if (s1(1) .ne. 1.) call abort
+      if (r1(1) .ne. 1.) call abort
+      if (d1 .ne. 10.) call abort
+      if (r1(4) .ne. 1.) call abort
+      if (r1(5) .ne. 1.) call abort
+      if (i1 .ne. 1) call abort
+      if (s2(1) .ne. 2.) call abort
+      if (r2(1) .ne. 2.) call abort
+      if (d2 .ne. 20.) call abort
+      if (r2(4) .ne. 2.) call abort
+      if (r2(5) .ne. 2.) call abort
+      if (i2 .ne. 2) call abort
+      if (s3(1) .ne. 3.) call abort
+      if (r3(1) .ne. 3.) call abort
+      if (d3 .ne. 30.) call abort
+      if (r3(4) .ne. 3.) call abort
+      if (r3(5) .ne. 3.) call abort
+      if (i3 .ne. 3) call abort
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/980701-1.f b/gcc/testsuite/g77.f-torture/execute/980701-1.f
new file mode 100644
index 00000000000..fba78564572
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/980701-1.f
@@ -0,0 +1,72 @@
+* g77 0.5.23 and previous had bugs involving too little space
+* allocated for EQUIVALENCE and COMMON areas needing initial
+* padding to meet alignment requirements of the system.
+
+      call subr
+      end
+
+      subroutine subr
+      implicit none
+
+      real r1(5), r2(5), r3(5)
+      real s1(2), s2(2), s3(2)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+      equivalence (d1, r1(2))
+      equivalence (r1, s1(2))
+      equivalence (d2, r2(2))
+      equivalence (r2, s2(2))
+      equivalence (d3, r3(2))
+      equivalence (r3, s3(2))
+
+      s1(1) = 1.
+      r1(1) = 1.
+      d1 = 10.
+      r1(4) = 1.
+      r1(5) = 1.
+      i1 = 1
+      s2(1) = 2.
+      r2(1) = 2.
+      d2 = 20.
+      r2(4) = 2.
+      r2(5) = 2.
+      i2 = 2
+      s3(1) = 3.
+      r3(1) = 3.
+      d3 = 30.
+      r3(4) = 3.
+      r3(5) = 3.
+      i3 = 3
+
+      call x (s1, r1, d1, i1, s2, r2, d2, i2, s3, r3, d3, i3)
+
+      end
+
+      subroutine x (s1, r1, d1, i1, s2, r2, d2, i2, s3, r3, d3, i3)
+      implicit none
+
+      real r1(5), r2(5), r3(5)
+      real s1(2), s2(2), s3(2)
+      double precision d1, d2, d3
+      integer i1, i2, i3
+
+      if (s1(1) .ne. 1.) call abort
+      if (r1(1) .ne. 1.) call abort
+      if (d1 .ne. 10.) call abort
+      if (r1(4) .ne. 1.) call abort
+      if (r1(5) .ne. 1.) call abort
+      if (i1 .ne. 1) call abort
+      if (s2(1) .ne. 2.) call abort
+      if (r2(1) .ne. 2.) call abort
+      if (d2 .ne. 20.) call abort
+      if (r2(4) .ne. 2.) call abort
+      if (r2(5) .ne. 2.) call abort
+      if (i2 .ne. 2) call abort
+      if (s3(1) .ne. 3.) call abort
+      if (r3(1) .ne. 3.) call abort
+      if (d3 .ne. 30.) call abort
+      if (r3(4) .ne. 3.) call abort
+      if (r3(5) .ne. 3.) call abort
+      if (i3 .ne. 3) call abort
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/alpha2.f b/gcc/testsuite/g77.f-torture/execute/alpha2.f
new file mode 100644
index 00000000000..d7b9d39da4b
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/alpha2.f
@@ -0,0 +1,19 @@
+c     This was originally a compile test.
+      IMPLICIT REAL*8 (A-H,O-Z)
+      COMMON /C/   A(9), INT
+      DATA A      /
+     1                 0.49999973986348730D01, 0.40000399113084100D01,
+     2                 0.29996921166596490D01, 0.20016917082678680D01,
+     3                 0.99126390351864390D00, 0.97963256554443300D-01,
+     4                -0.87360964813570100D-02, 0.16917082678692080D-02,
+     5                7./
+C     Data values were once mis-compiled on (OSF/1 ?) Alpha with -O2
+c     such that, for instance, `7.' appeared as `4.' in the assembler
+c     output.
+      call test(a(9), 7)
+      END
+      subroutine test(r, i)
+      double precision r
+      if (nint(r)/=i) call abort
+      end
+
diff --git a/gcc/testsuite/g77.f-torture/execute/auto0.f b/gcc/testsuite/g77.f-torture/execute/auto0.f
new file mode 100644
index 00000000000..4b6b2f51a8e
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/auto0.f
@@ -0,0 +1,80 @@
+* Test automatic arrays.
+      program auto0
+      implicit none
+      integer i
+      integer j0(40)
+      integer j1(40)
+      integer jc0(40)
+      integer jc1(40)
+      common /jc0/ jc0
+      common /jc1/ jc1
+
+      data j0/40*3/
+      data j1/40*4/
+
+      i = 40
+      call a1 (j0, j1, i)
+
+      do i = 1, 40
+         if (j0(i) .ne. 4) call abort
+         if (j1(i) .ne. 3) call abort
+         if (jc0(i) .ne. 6) call abort
+         if (jc1(i) .ne. 5) call abort
+      end do
+
+      end
+
+      block data jc
+      implicit none
+      integer jc0(40)
+      integer jc1(40)
+      common /jc0/ jc0
+      common /jc1/ jc1
+
+      data jc0/40*5/
+      data jc1/40*6/
+
+      end
+
+      subroutine a1 (j0, j1, n)
+      implicit none
+      integer j0(40), j1(40), n
+      integer k0(n), k1(n)
+      integer i
+      integer jc0(40)
+      integer jc1(40)
+      common /jc0/ jc0
+      common /jc1/ jc1
+
+      do i = 1, 40
+         j0(i) = j1(i) - j0(i)
+         jc0(i) = jc1(i) - jc0(i)
+      end do
+
+      n = -1
+
+      do i = 1, 40
+         k0(i) = n
+         k1(i) = n
+      end do
+
+      do i = 1, 40
+         j1(i) = j1(i) + k0(i) * j0(i)
+         jc1(i) = jc1(i) + k1(i) * jc0(i)
+      end do
+
+      n = 500
+
+      do i = 1, 40
+         if (k0(i) .ne. -1) call abort
+         k0(i) = n
+         if (k1(i) .ne. -1) call abort
+         k1(i) = n
+      end do
+
+      do i = 1, 40
+         j0(i) = j1(i) + j0(i)
+         jc0(i) = jc1(i) + jc0(i)
+      end do
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/auto1.f b/gcc/testsuite/g77.f-torture/execute/auto1.f
new file mode 100644
index 00000000000..ab9044ceca5
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/auto1.f
@@ -0,0 +1,88 @@
+* Test automatic arrays.
+      program auto1
+      implicit none
+      integer i
+      integer j0(40)
+      integer j1(40)
+      integer jc0(40)
+      integer jc1(40)
+      common /jc0/ jc0
+      common /jc1/ jc1
+
+      data j0/40*3/
+      data j1/40*4/
+
+      i = 40
+      call a1 (j0, j1, i)
+
+      do i = 1, 40
+         if (j0(i) .ne. 4) call abort
+         if (j1(i) .ne. 3) call abort
+         if (jc0(i) .ne. 6) call abort
+         if (jc1(i) .ne. 5) call abort
+      end do
+
+      end
+
+      block data jc
+      implicit none
+      integer jc0(40)
+      integer jc1(40)
+      common /jc0/ jc0
+      common /jc1/ jc1
+
+      data jc0/40*5/
+      data jc1/40*6/
+
+      end
+
+      subroutine a1 (j0, j1, n)
+      implicit none
+      integer j0(40), j1(40), n
+      integer k0(n,3,2), k1(n,3,2)
+      integer i,j,k
+      integer jc0(40)
+      integer jc1(40)
+      common /jc0/ jc0
+      common /jc1/ jc1
+
+      do i = 1, 40
+         j0(i) = j1(i) - j0(i)
+         jc0(i) = jc1(i) - jc0(i)
+      end do
+
+      n = -1
+
+      do k = 1, 2
+         do j = 1, 3
+            do i = 1, 40
+               k0(i, j, k) = n
+               k1(i, j, k) = n
+            end do
+         end do
+      end do
+
+      do i = 1, 40
+         j1(i) = j1(i) + k0(i, 3, 2) * j0(i)
+         jc1(i) = jc1(i) + k1(i, 1, 1) * jc0(i)
+      end do
+
+      n = 500
+
+      do k = 1, 2
+         do j = 1, 3
+            do i = 1, 40
+               if (k0(i, j, k) .ne. -1) call abort
+               k0(i, j, k) = n
+               if (k1(i, j, k) .ne. -1) call abort
+               k1(i, j, k) = n
+            end do
+         end do
+      end do
+
+      do i = 1, 40
+         j0(i) = j1(i) + j0(i)
+         jc0(i) = jc1(i) + jc0(i)
+      end do
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/cabs.f b/gcc/testsuite/g77.f-torture/execute/cabs.f
new file mode 100644
index 00000000000..61fd263620b
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/cabs.f
@@ -0,0 +1,14 @@
+      program cabs_1
+      complex      z0
+      real         r0
+      complex*16   z1
+      real*8       r1
+
+      z0 = cmplx(3.,4.)
+      r0 = cabs(z0)
+      if (r0 .ne. 5.) call abort
+
+      z1 = dcmplx(3.d0,4.d0)
+      r1 = zabs(z1)
+      if (r1 .ne. 5.d0) call abort
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/claus.f b/gcc/testsuite/g77.f-torture/execute/claus.f
new file mode 100644
index 00000000000..bccef7f4090
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/claus.f
@@ -0,0 +1,13 @@
+        PROGRAM TEST
+        REAL AB(3)
+        do i=1,3
+         AB(i)=i
+        enddo
+        k=1
+        n=2
+        ind=k-n+2
+	if (ind /= 1) call abort
+	if (ab(ind) /= 1) call abort
+	if (k-n+2 /= 1) call abort
+	if (ab(k-n+2) /= 1) call abort
+        END
diff --git a/gcc/testsuite/g77.f-torture/execute/complex_1.f b/gcc/testsuite/g77.f-torture/execute/complex_1.f
new file mode 100644
index 00000000000..77da6359f72
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/complex_1.f
@@ -0,0 +1,18 @@
+      program complex_1
+      complex      z0, z1, z2
+
+      z0 = cmplx(0.,.5)
+      z1 = 1./z0
+      if (z1 .ne. cmplx(0.,-2)) call abort
+
+      z0 = 10.*z0
+      if (z0 .ne. cmplx(0.,5.)) call abort
+
+      z2 = cmplx(1.,2.)
+      z1 = z0/z2
+      if (z1 .ne. cmplx(2.,1.)) call abort
+
+      z1 = z0*z2
+      if (z1 .ne. cmplx(-10.,5.)) call abort
+      end
+
diff --git a/gcc/testsuite/g77.f-torture/execute/cpp.F b/gcc/testsuite/g77.f-torture/execute/cpp.F
new file mode 100644
index 00000000000..fc9386b5c92
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/cpp.F
@@ -0,0 +1,5 @@
+!  Some versions of cpp will delete "//'World' as a C++ comment.
+      character*40    title
+      title = 'Hello '//'World'
+      if (title .ne. 'Hello World') call abort
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/dcomplex.f b/gcc/testsuite/g77.f-torture/execute/dcomplex.f
new file mode 100644
index 00000000000..a46f03aabef
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/dcomplex.f
@@ -0,0 +1,18 @@
+      program foo
+      complex*16      z0, z1, z2
+
+      z0 = dcmplx(0.,.5)
+      z1 = 1./z0
+      if (z1 .ne. dcmplx(0.,-2)) call abort
+
+      z0 = 10.*z0
+      if (z0 .ne. dcmplx(0.,5.)) call abort
+
+      z2 = cmplx(1.,2.)
+      z1 = z0/z2
+      if (z1 .ne. dcmplx(2.,1.)) call abort
+
+      z1 = z0*z2
+      if (z1 .ne. dcmplx(-10.,5.)) call abort
+      end
+
diff --git a/gcc/testsuite/g77.f-torture/execute/dnrm2.f b/gcc/testsuite/g77.f-torture/execute/dnrm2.f
new file mode 100644
index 00000000000..c69608786b9
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/dnrm2.f
@@ -0,0 +1,74 @@
+CCC g77 0.5.21 `Actual Bugs':
+CCC   * A code-generation bug afflicts Intel x86 targets when `-O2' is
+CCC     specified compiling, for example, an old version of the `DNRM2'
+CCC     routine.  The x87 coprocessor stack is being somewhat mismanaged
+CCC     in cases where assigned `GOTO' and `ASSIGN' are involved.
+CCC
+CCC     Version 0.5.21 of `g77' contains an initial effort to fix the
+CCC     problem, but this effort is incomplete, and a more complete fix is
+CCC     planned for the next release.
+
+C     Currently this test fails with (at least) `-O2 -funroll-loops' on
+C     i586-unknown-linux-gnulibc1.
+
+C     (This is actually an obsolete version of dnrm2 -- consult the
+c     current Netlib BLAS.)
+
+      integer i
+      double precision a(1:100), dnrm2
+      do i=1,100
+         a(i)=0.D0
+      enddo
+      if (dnrm2(100,a,1) .ne. 0.0) call abort
+      end
+
+      double precision function dnrm2 ( n, dx, incx)
+      integer i, incx, ix, j, n, next
+      double precision   dx(1), cutlo, cuthi, hitest, sum, xmax,zero,one
+      data   zero, one /0.0d0, 1.0d0/
+      data cutlo, cuthi / 8.232d-11,  1.304d19 /
+      j = 0
+      if(n .gt. 0 .and. incx.gt.0) go to 10
+         dnrm2  = zero
+         go to 300
+   10 assign 30 to next
+      sum = zero
+      i = 1
+      ix = 1
+   20    go to next,(30, 50, 70, 110)
+   30 if( dabs(dx(i)) .gt. cutlo) go to 85
+      assign 50 to next
+      xmax = zero
+   50 if( dx(i) .eq. zero) go to 200
+      if( dabs(dx(i)) .gt. cutlo) go to 85
+      assign 70 to next
+      go to 105
+  100 continue
+      ix = j
+      assign 110 to next
+      sum = (sum / dx(i)) / dx(i)
+  105 xmax = dabs(dx(i))
+      go to 115
+   70 if( dabs(dx(i)) .gt. cutlo ) go to 75
+  110 if( dabs(dx(i)) .le. xmax ) go to 115
+         sum = one + sum * (xmax / dx(i))**2
+         xmax = dabs(dx(i))
+         go to 200
+  115 sum = sum + (dx(i)/xmax)**2
+      go to 200
+   75 sum = (sum * xmax) * xmax
+   85 hitest = cuthi/float( n )
+      do 95 j = ix,n
+      if(dabs(dx(i)) .ge. hitest) go to 100
+         sum = sum + dx(i)**2
+         i = i + incx
+   95 continue
+      dnrm2 = dsqrt( sum )
+      go to 300
+  200 continue
+      ix = ix + 1
+      i = i + incx
+      if( ix .le. n ) go to 20
+      dnrm2 = xmax * dsqrt(sum)
+  300 continue
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/erfc.f b/gcc/testsuite/g77.f-torture/execute/erfc.f
new file mode 100644
index 00000000000..e5e0412f587
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/erfc.f
@@ -0,0 +1,38 @@
+c============================================== test.f
+                real x, y
+		real*8 x1, y1
+		x=0.
+		y = erfc(x)
+		if (y .ne. 1.) call abort
+
+		x=1.1
+		y = erfc(x)
+		if (abs(y - .1197949) .ge. 1.e-6) call abort
+
+* modified from x=10, y .gt. 1.5e-44 to avoid lack of -mieee on Alphas.
+		x=8
+		y = erfc(x)
+		if (y .gt. 1.2e-28) call abort
+
+		x1=0.
+		y1 = erfc(x1)
+		if (y1 .ne. 1.) call abort
+
+		x1=1.1d0
+		y1 = erfc(x1)
+		if (abs(y1 - .1197949d0) .ge. 1.d-6) call abort
+
+		x1=10
+		y1 = erfc(x1)
+		if (y1 .gt. 1.5d-44) call abort
+		end
+c=================================================
+!output:
+!  0.  1.875
+!  1.10000002  1.48958981
+!  10.  5.00220949E-06
+!
+!The values should be:
+!erfc(0)=1
+!erfc(1.1)= 0.1197949
+!erfc(10)<1.543115467311259E-044
diff --git a/gcc/testsuite/g77.f-torture/execute/execute.exp b/gcc/testsuite/g77.f-torture/execute/execute.exp
new file mode 100644
index 00000000000..31608eed4f9
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/execute.exp
@@ -0,0 +1,55 @@
+# Copyright (C) 1991, 1992, 1993, 1995, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-g77@prep.ai.mit.edu
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+# Modified and maintained by Jeffrey Wheat (cassidy@cygnus.com)
+
+#
+# These tests come from Torbjorn Granlund (tege@cygnus.com)
+# Fortran torture test suite.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib f-torture.exp
+
+#
+# main test loop
+#
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.f]] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $src] then {
+	continue
+    }
+
+    f-torture-execute $src
+}
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.F]] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $src] then {
+	continue
+    }
+
+    f-torture-execute $src
+}
diff --git a/gcc/testsuite/g77.f-torture/execute/exp.f b/gcc/testsuite/g77.f-torture/execute/exp.f
new file mode 100644
index 00000000000..de388f181b0
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/exp.f
@@ -0,0 +1,3 @@
+      a = 2**-2*1.
+      if (a .ne. .25) call abort
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/io0.f b/gcc/testsuite/g77.f-torture/execute/io0.f
new file mode 100644
index 00000000000..c56c9919077
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/io0.f
@@ -0,0 +1,46 @@
+*     Preliminary tests for a few things in the i/o library.
+*     Thrown together by Dave Love not from specific bug reports --
+*     other ideas welcome.
+
+      character *(*) fmt
+      parameter (fmt='(1x,i3,f5.1)')
+*     Scratch file makes sure we can use one and avoids dealing with
+*     explicit i/o in the testsuite.
+      open(90, status='scratch') ! try a biggish unit number
+      write(90, '()')           ! extra record for interest
+*     Formatted i/o can go wild (endless loop AFAIR) if we're wrongly
+*     assuming an ANSI sprintf.
+      write(90, fmt) 123, 123.0
+      backspace 90              ! backspace problems reported on DOSish systems
+      read(90, fmt) i, r
+      endfile 90
+      if (i/=123 .or. nint(r)/=123) call abort
+      rewind 90                 ! make sure we can rewind too
+      read(90, '()')
+      read(90, fmt) i, r
+      if (i/=123 .or. nint(r)/=123) call abort
+      close(90)
+*     Make sure we can do unformatted i/o OK.  This might be
+*     problematic on DOS-like systems if we've done an fopen in text
+*     mode, not binary.     
+      open(90, status='scratch', access='direct', form='unformatted',
+     +     recl=8)
+      write(90, rec=1) 123, 123.0
+      read(90, rec=1) i, r
+      if (i/=123 .or. nint(r)/=123) call abort
+      close(90)
+      open(90, status='scratch', form='unformatted')
+      write(90) 123, 123.0
+      backspace 90
+      read(90) i, r
+      if (i/=123 .or. nint(r)/=123) call abort
+      close(90)
+*     Fails at 1998-09-01 on spurious recursive i/o check (fixed by
+*     1998-09-06 libI77 change):
+      open(90, status='scratch', form='formatted', recl=16,
+     +     access='direct')
+      write(90, '(i8,f8.1)',rec=1) 123, 123.0
+      read(90, '(i8,f8.1)', rec=1) i, r
+      if (i/=123 .or. nint(r)/=123) call abort
+      close(90)
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/io1.f b/gcc/testsuite/g77.f-torture/execute/io1.f
new file mode 100644
index 00000000000..c5242446a49
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/io1.f
@@ -0,0 +1,10 @@
+*     Fixed by 1998-09-28 libI77/open.c change.
+      open(90,status='scratch')
+      write(90, '(1X, I1 / 1X, I1)') 1, 2
+      rewind 90
+      write(90, '(1X, I1)') 1
+      rewind 90                 ! implicit ENDFILE expected
+      read(90, *) i
+      read(90, *, end=10) j
+      call abort()
+ 10   end
diff --git a/gcc/testsuite/g77.f-torture/execute/labug1.f b/gcc/testsuite/g77.f-torture/execute/labug1.f
new file mode 100644
index 00000000000..032fa41f899
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/labug1.f
@@ -0,0 +1,57 @@
+      PROGRAM LABUG1
+
+*  This program core dumps on mips-sgi-irix6.2 when compiled
+*  with egcs-19981101, egcs-19981109 and egcs-19981122 snapshots
+*  with -O2
+*
+*  Originally derived from LAPACK test suite.
+*  Almost any change allows it to run.
+*
+*  David Billinghurst, (David.Billinghurst@riotinto.com.au)
+*  25 November 1998
+* 
+*     .. Parameters ..
+      INTEGER   LDA, LDE
+      PARAMETER ( LDA = 2500, LDE = 50  )
+      COMPLEX   CZERO 
+      PARAMETER ( CZERO = ( 0.0E+0, 0.0E+0 ) )
+
+      INTEGER   I, J, M, N
+      REAL      V
+      COMPLEX   A(LDA),B(LDA),C(LDA),E(LDE,LDE),F(LDE,LDE)  
+      COMPLEX   Z
+
+      N=2
+      M=1
+*
+      do i = 1, m
+         do j = 1, n
+            e(i,j) = czero
+            f(i,j) = czero
+        end do
+      end do
+*
+      DO J = 1, N
+         DO I = 1, M
+            V =  ABS( E(I,J) - F(I,J) )
+         END DO
+      END DO
+ 
+      CALL SUB2(M,Z)
+
+      END
+
+      subroutine SUB2(I,A)
+      integer i
+      complex a
+      end
+
+
+
+
+
+
+
+
+
+
diff --git a/gcc/testsuite/g77.f-torture/execute/large_vec.f b/gcc/testsuite/g77.f-torture/execute/large_vec.f
new file mode 100644
index 00000000000..0af5b1b0b3f
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/large_vec.f
@@ -0,0 +1,3 @@
+      parameter (nmax=165000)
+      double precision x(nmax)
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/le.f b/gcc/testsuite/g77.f-torture/execute/le.f
new file mode 100644
index 00000000000..74e42750d55
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/le.f
@@ -0,0 +1,29 @@
+      program fool
+
+      real     foo
+      integer  n
+      logical  t
+
+      foo = 2.5
+      n = 5
+
+      t = (n > foo)
+      if (t .neqv. .true.) call abort
+      t = (n >= foo)
+      if (t .neqv. .true.) call abort
+      t = (n < foo)
+      if (t .neqv. .false.) call abort
+      t = (n <= 5)
+      if (t .neqv. .true.) call abort
+      t = (n >= 5 )
+      if (t .neqv. .true.) call abort
+      t = (n == 5)
+      if (t .neqv. .true.) call abort
+      t = (n /= 5)
+      if (t .neqv. .false.) call abort
+      t = (n /= foo)
+      if (t .neqv. .true.) call abort
+      t = (n == foo)
+      if (t .neqv. .false.) call abort
+
+      end
diff --git a/gcc/testsuite/g77.f-torture/execute/short.f b/gcc/testsuite/g77.f-torture/execute/short.f
new file mode 100644
index 00000000000..89ae273891c
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/short.f
@@ -0,0 +1,57 @@
+      program short
+
+      parameter   (   N=2  )
+      common /chb/    pi,sig(0:N)
+      common /parm/   h(2,2)
+
+c  initialize some variables
+      h(2,2) = 1117
+      h(2,1) = 1178
+      h(1,2) = 1568
+      h(1,1) = 1621
+      sig(0) = -1.
+      sig(1) = 0.
+      sig(2) = 1.
+
+      call printout
+      stop
+      end
+
+c ******************************************************************
+
+      subroutine printout
+      parameter   (   N=2  )
+      common /chb/    pi,sig(0:N)
+      common /parm/   h(2,2)
+      dimension       yzin1(0:N), yzin2(0:N)
+
+c  function subprograms
+      z(i,j,k) = 0.5*h(i,j)*(sig(k)-1.)
+
+c  a four-way average of rhobar
+      do 260  k=0,N
+        yzin1(k) = 0.25 * 
+     &       ( z(2,2,k) + z(1,2,k) +
+     &         z(2,1,k) + z(1,1,k) )
+  260       continue
+
+c  another four-way average of rhobar
+      do 270  k=0,N
+	rtmp1 = z(2,2,k)
+	rtmp2 = z(1,2,k)
+	rtmp3 = z(2,1,k)
+	rtmp4 = z(1,1,k)
+        yzin2(k) = 0.25 * 
+     &       ( rtmp1 + rtmp2 + rtmp3 + rtmp4 )
+  270       continue
+
+      do k=0,N
+	if (yzin1(k) .ne. yzin2(k)) call abort
+      enddo
+      if (yzin1(0) .ne. -1371.) call abort
+      if (yzin1(1) .ne. -685.5) call abort
+      if (yzin1(2) .ne. 0.) call abort
+
+      return
+      end
+
diff --git a/gcc/testsuite/g77.f-torture/execute/u77-test.f b/gcc/testsuite/g77.f-torture/execute/u77-test.f
new file mode 100644
index 00000000000..198d48b460c
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/execute/u77-test.f
@@ -0,0 +1,421 @@
+***   Some random stuff for testing libU77.  Should be done better.  It's
+*     hard to test things where you can't guarantee the result.  Have a
+*     good squint at what it prints, though detected errors will cause 
+*     starred messages.
+*
+* Currently not tested:
+*   ALARM
+*   CHDIR (func)
+*   CHMOD (func)
+*   FGET (func/subr)
+*   FGETC (func)
+*   FPUT (func/subr)
+*   FPUTC (func)
+*   FSTAT (subr)
+*   GETCWD (subr)
+*   HOSTNM (subr)
+*   IRAND
+*   KILL
+*   LINK (func)
+*   LSTAT (subr)
+*   RENAME (func/subr)
+*   SIGNAL (subr)
+*   SRAND
+*   STAT (subr)
+*   SYMLNK (func/subr)
+*   UMASK (func)
+*   UNLINK (func)
+*
+* NOTE! This is the testsuite version, so it should compile and
+* execute on all targets, and either run to completion (with
+* success status) or fail (by calling abort).  The *other* version,
+* which is a bit more interactive and tests a couple of things
+* this one cannot, should be generally the same, and is in
+* libf2c/libU77/u77-test.f.  Please keep it up-to-date.
+
+      implicit none
+
+      external hostnm
+*     intrinsic hostnm
+      integer hostnm
+
+      integer i, j, k, ltarray (9), idat (3), count, rate, count_max,
+     +     pid, mask
+      real tarray1(2), tarray2(2), r1, r2
+      double precision d1
+      integer(kind=2) bigi
+      logical issum
+      intrinsic getpid, getuid, getgid, ierrno, gerror, time8,
+     +     fnum, isatty, getarg, access, unlink, fstat, iargc,
+     +     stat, lstat, getcwd, gmtime, etime, chmod, itime, date,
+     +     chdir, fgetc, fputc, system_clock, second, idate, secnds,
+     +     time, ctime, fdate, ttynam, date_and_time, mclock, mclock8,
+     +     cpu_time, dtime, ftell, abort
+      external lenstr, ctrlc
+      integer lenstr
+      logical l
+      character gerr*80, c*1
+      character ctim*25, line*80, lognam*20, wd*100, line2*80, ddate*8,
+     +     ttime*10, zone*5, ctim2*25
+      integer fstatb (13), statb (13)
+      integer *2 i2zero
+      integer values(8)
+      integer(kind=7) sigret
+
+      i = time ()
+      ctim = ctime (i)
+      WRITE (6,'(A/)') '1 GNU libU77 test at: ' // ctim(:lenstr (ctim))
+      write (6,'(A,I3,'', '',I3)')
+     +     ' Logical units 5 and 6 correspond (FNUM) to'
+     +     // ' Unix i/o units ', fnum(5), fnum(6)
+      if (lnblnk('foo ').ne.3 .or. len_trim('foo ').ne.3) then
+        print *, 'LNBLNK or LEN_TRIM failed'
+        call abort
+      end if
+
+      bigi = time8 ()
+
+      call ctime (i, ctim2)
+      if (ctim .ne. ctim2) then
+        write (6, *) '*** CALL CTIME disagrees with CTIME(): ',
+     +    ctim2(:lenstr (ctim2)), ' vs. ', ctim(:lenstr (ctim))
+        call doabort
+      end if
+
+      j = time ()
+      if (i .gt. bigi .or. bigi .gt. j) then
+        write (6, *) '*** TIME/TIME8/TIME sequence failures: ',
+     +    i, bigi, j
+        call doabort
+      end if
+
+      print *, 'Command-line arguments: ', iargc ()
+      do i = 0, iargc ()
+         call getarg (i, line)
+         print *, 'Arg ', i, ' is: ', line(:lenstr (line))
+      end do
+
+      l= isatty(6)
+      line2 = ttynam(6)
+      if (l) then
+        line = 'and 6 is a tty device (ISATTY) named '//line2
+      else
+        line = 'and 6 isn''t a tty device (ISATTY)'
+      end if
+      write (6,'(1X,A)') line(:lenstr(line))
+      call ttynam (6, line)
+      if (line .ne. line2) then
+        print *, '*** CALL TTYNAM disagrees with TTYNAM: ',
+     +    line(:lenstr (line))
+        call doabort
+      end if
+
+*     regression test for compiler crash fixed by JCB 1998-08-04 com.c
+      sigret = signal(2, ctrlc)
+
+      pid = getpid()
+      WRITE (6,'(A,I10)') ' Process id (GETPID): ', pid
+      WRITE (6,'(A,I10)') ' User id (GETUID): ', GETUID ()
+      WRITE (6,'(A,I10)') ' Group id (GETGID): ', GETGID ()
+      WRITE (6, *) 'If you have the `id'' program, the following call'
+      write (6, *) 'of SYSTEM should agree with the above:'
+      call flush(6)
+      CALL SYSTEM ('echo " " `id`')
+      call flush
+
+      lognam = 'blahblahblah'
+      call getlog (lognam)
+      write (6,*) 'Login name (GETLOG): ', lognam(:lenstr (lognam))
+
+      wd = 'blahblahblah'
+      call getenv ('LOGNAME', wd)
+      write (6,*) 'Login name (GETENV of LOGNAME): ', wd(:lenstr (wd))
+
+      call umask(0, mask)
+      write(6,*) 'UMASK returns', mask
+      call umask(mask)
+
+      ctim = fdate()
+      write (6,*) 'FDATE returns: ', ctim(:lenstr (ctim))
+      call fdate (ctim)
+      write (6,*) 'CALL FDATE returns: ', ctim(:lenstr (ctim))
+
+      j=time()
+      call ltime (j, ltarray)
+      write (6,'(1x,a,9i4)') 'LTIME returns:', ltarray
+      call gmtime (j, ltarray)
+      write (6,'(1x,a,9i4)') 'GMTIME returns:', ltarray
+
+      call system_clock(count)  ! omitting optional args
+      call system_clock(count, rate, count_max)
+      write(6,*) 'SYSTEM_CLOCK returns: ', count, rate, count_max
+
+      call date_and_time(ddate)  ! omitting optional args
+      call date_and_time(ddate, ttime, zone, values)
+      write(6, *) 'DATE_AND_TIME returns: ', ddate, ' ', ttime, ' ',
+     +     zone, ' ', values
+
+      write (6,*) 'Sleeping for 1 second (SLEEP) ...'
+      call sleep (1)
+
+c consistency-check etime vs. dtime for first call
+      r1 = etime (tarray1)
+      r2 = dtime (tarray2)
+      if (abs (r1-r2).gt.1.0) then
+        write (6,*)
+     +       'Results of ETIME and DTIME differ by more than a second:',
+     +       r1, r2
+        call doabort
+      end if
+      if (.not. issum (r1, tarray1(1), tarray1(2))) then
+        write (6,*) '*** ETIME didn''t return sum of the array: ',
+     +       r1, ' /= ', tarray1(1), '+', tarray1(2)
+        call doabort
+      end if
+      if (.not. issum (r2, tarray2(1), tarray2(2))) then
+        write (6,*) '*** DTIME didn''t return sum of the array: ',
+     +       r2, ' /= ', tarray2(1), '+', tarray2(2)
+        call doabort
+      end if
+      write (6, '(A,3F10.3)')
+     +     ' Elapsed total, user, system time (ETIME): ',
+     +     r1, tarray1
+
+c now try to get times to change enough to see in etime/dtime
+      write (6,*) 'Looping until clock ticks at least once...'
+      do i = 1,1000
+      do j = 1,1000
+      end do
+      call dtime (tarray2, r2)
+      if (tarray2(1) .ne. 0. .or. tarray2(2) .ne. 0.) exit
+      end do
+      call etime (tarray1, r1)
+      if (.not. issum (r1, tarray1(1), tarray1(2))) then
+        write (6,*) '*** ETIME didn''t return sum of the array: ',
+     +       r1, ' /= ', tarray1(1), '+', tarray1(2)
+        call doabort
+      end if
+      if (.not. issum (r2, tarray2(1), tarray2(2))) then
+        write (6,*) '*** DTIME didn''t return sum of the array: ',
+     +       r2, ' /= ', tarray2(1), '+', tarray2(2)
+        call doabort
+      end if
+      write (6, '(A,3F10.3)')
+     +     ' Differences in total, user, system time (DTIME): ',
+     +     r2, tarray2
+      write (6, '(A,3F10.3)')
+     +     ' Elapsed total, user, system time (ETIME): ',
+     +     r1, tarray1
+      write (6, *) '(Clock-tick detected after ', i, ' 1K loops.)'
+
+      call idate (i,j,k)
+      call idate (idat)
+      write (6,*) 'IDATE (date,month,year): ',idat
+      print *,  '... and the VXT version (month,date,year): ', i,j,k
+      if (i/=idat(2) .or. j/=idat(1) .or. k/=mod(idat(3),100)) then
+        print *, '*** VXT and U77 versions don''t agree'
+        call doabort
+      end if
+
+      call date (ctim)
+      write (6,*) 'DATE (dd-mmm-yy): ', ctim(:lenstr (ctim))
+
+      call itime (idat)
+      write (6,*) 'ITIME (hour,minutes,seconds): ', idat
+
+      call time(line(:8))
+      print *, 'TIME: ', line(:8)
+
+      write (6,*) 'SECNDS(0.0) returns: ',secnds(0.0)
+
+      write (6,*) 'SECOND returns: ', second()
+      call dumdum(r1)
+      call second(r1)
+      write (6,*) 'CALL SECOND returns: ', r1
+
+*     compiler crash fixed by 1998-10-01 com.c change
+      if (rand(0).lt.0.0 .or. rand(0).gt.1.0) then
+        write (6,*) '*** rand(0) error'
+        call doabort()
+      end if
+
+      i = getcwd(wd)
+      if (i.ne.0) then
+        call perror ('*** getcwd')
+        call doabort
+      else
+        write (6,*) 'Current directory is "'//wd(:lenstr(wd))//'"'
+      end if
+      call chdir ('.',i)
+      if (i.ne.0) then
+        write (6,*) '***CHDIR to ".": ', i
+        call doabort
+      end if
+
+      i=hostnm(wd)
+      if(i.ne.0) then
+        call perror ('*** hostnm')
+        call doabort
+      else
+        write (6,*) 'Host name is ', wd(:lenstr(wd))
+      end if
+
+      i = access('/dev/null ', 'rw')
+      if (i.ne.0) write (6,*) '***Read/write ACCESS to /dev/null: ', i
+      write (6,*) 'Creating file "foo" for testing...'
+      open (3,file='foo',status='UNKNOWN')
+      rewind 3
+      call fputc(3, 'c',i)
+      call fputc(3, 'd',j)      
+      if (i+j.ne.0) write(6,*) '***FPUTC: ', i
+C     why is it necessary to reopen?  (who wrote this?)
+C     the better to test with, my dear!  (-- burley)
+      close(3)
+      open(3,file='foo',status='old')
+      call fseek(3,0,0,*10)
+      go to 20
+ 10   write(6,*) '***FSEEK failed'
+      call doabort
+ 20   call fgetc(3, c,i)
+      if (i.ne.0) then
+        write(6,*) '***FGETC: ', i
+        call doabort
+      end if
+      if (c.ne.'c') then
+        write(6,*) '***FGETC read the wrong thing: ', ichar(c)
+        call doabort
+      end if
+      i= ftell(3)
+      if (i.ne.1) then
+        write(6,*) '***FTELL offset: ', i
+        call doabort
+      end if
+      call ftell(3, i)
+      if (i.ne.1) then
+        write(6,*) '***CALL FTELL offset: ', i
+        call doabort
+      end if
+      call chmod ('foo', 'a+w',i)
+      if (i.ne.0) then
+        write (6,*) '***CHMOD of "foo": ', i
+        call doabort
+      end if
+      i = fstat (3, fstatb)
+      if (i.ne.0) then
+        write (6,*) '***FSTAT of "foo": ', i
+        call doabort
+      end if
+      i = stat ('foo', statb)
+      if (i.ne.0) then
+        write (6,*) '***STAT of "foo": ', i
+        call doabort
+      end if
+      write (6,*) '  with stat array ', statb
+      if (statb(6) .ne. getgid ()) then
+        write (6,*) 'Note: FSTAT gid wrong (happens on some systems).'
+      end if
+      if (statb(5) .ne. getuid () .or. statb(4) .ne. 1) then
+        write (6,*) '*** FSTAT uid or nlink is wrong'
+        call doabort
+      end if
+      do i=1,13
+        if (fstatb (i) .ne. statb (i)) then
+          write (6,*) '*** FSTAT and STAT don''t agree on '// '
+     +         array element ', i, ' value ', fstatb (i), statb (i)
+          call abort
+        end if
+      end do
+      i = lstat ('foo', fstatb)
+      do i=1,13
+        if (fstatb (i) .ne. statb (i)) then
+          write (6,*) '*** LSTAT and STAT don''t agree on '//
+     +         'array element ', i, ' value ', fstatb (i), statb (i)
+          call abort
+        end if
+      end do
+
+C     in case it exists already:
+      call unlink ('bar',i)
+      call link ('foo ', 'bar ',i)
+      if (i.ne.0) then
+        write (6,*) '***LINK "foo" to "bar" failed: ', i
+        call doabort
+      end if
+      call unlink ('foo',i)
+      if (i.ne.0) then
+        write (6,*) '***UNLINK "foo" failed: ', i
+        call doabort
+      end if
+      call unlink ('foo',i)
+      if (i.eq.0) then
+        write (6,*) '***UNLINK "foo" again: ', i
+        call doabort
+      end if
+
+      call gerror (gerr)
+      i = ierrno()
+      write (6,'(A,I3,A/1X,A)') ' The current error number is: ',
+     +     i,
+     +     ' and the corresponding message is:', gerr(:lenstr(gerr))
+      write (6,*) 'This is sent to stderr prefixed by the program name'
+      call getarg (0, line)
+      call perror (line (:lenstr (line)))
+      call unlink ('bar')
+
+      print *, 'MCLOCK returns ', mclock ()
+      print *, 'MCLOCK8 returns ', mclock8 ()
+
+      call cpu_time (d1)
+      print *, 'CPU_TIME returns ', d1
+
+C     WRITE (6,*) 'You should see exit status 1'
+      CALL EXIT(0)
+ 99   END
+
+* Return length of STR not including trailing blanks, but always > 0.
+      integer function lenstr (str)
+      character*(*) str
+      if (str.eq.' ') then
+        lenstr=1
+      else
+        lenstr = lnblnk (str)
+      end if
+      end
+
+* Just make sure SECOND() doesn't "magically" work the second time.
+      subroutine dumdum(r)
+      r = 3.14159
+      end
+
+* Test whether sum is approximately left+right.
+      logical function issum (sum, left, right)
+      implicit none
+      real sum, left, right
+      real mysum, delta, width
+      mysum = left + right
+      delta = abs (mysum - sum)
+      width = abs (left) + abs (right)
+      issum = (delta .le. .0001 * width)
+      end
+
+* Signal handler
+      subroutine ctrlc
+      print *, 'Got ^C'
+      call doabort
+      end
+
+* A problem has been noticed, so maybe abort the test.
+      subroutine doabort
+* For this version, call the ABORT intrinsic.
+      intrinsic abort
+      call abort
+      end
+
+* Testsuite version only.
+* Don't actually reference the HOSTNM intrinsic, because some targets
+* need -lsocket, which we don't have a mechanism for supplying.
+      integer function hostnm(nm)
+      character*(*) nm
+      nm = 'not determined by this version of u77-test.f'
+      hostnm = 0
+      end
diff --git a/gcc/testsuite/g77.f-torture/noncompile/19981216-0.f b/gcc/testsuite/g77.f-torture/noncompile/19981216-0.f
new file mode 100644
index 00000000000..0cc9087d6cb
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/noncompile/19981216-0.f
@@ -0,0 +1,89 @@
+* Resent-From: Craig Burley <burley@gnu.org>
+* Resent-To: craig@jcb-sc.com
+* X-Delivered: at request of burley on mescaline.gnu.org
+* Date: Wed, 16 Dec 1998 18:31:24 +0100
+* From: Dieter Stueken <stueken@conterra.de>
+* Organization: con terra GmbH
+* To: fortran@gnu.org
+* Subject: possible bug
+* Content-Type: text/plain; charset=iso-8859-1
+* X-Mime-Autoconverted: from 8bit to quoted-printable by mescaline.gnu.org id KAA09085
+* X-UIDL: 72293bf7f9fac8378ec7feca2bccbce2
+* 
+* Hi,
+* 
+* I'm about to compile a very old, very ugly Fortran program.
+* For one part I got:
+* 
+* f77: Internal compiler error: program f771 got fatal signal 6
+* 
+* instead of any detailed error message. I was able to break down the
+* problem to the following source fragment:
+* 
+* -------------------------------------------
+        PROGRAM WAP
+
+        integer*2  ios
+        character*80  name
+
+        name = 'blah'
+        open(unit=8,status='unknown',file=name,form='formatted',
+     F       iostat=ios)
+
+      END
+* -------------------------------------------
+* 
+* The problem seems to be caused by the "integer*2 ios" declaration.
+* So far I solved it by simply using a plain integer instead.
+* 
+* I'm running gcc on a Linux system compiled/installed
+* with no special options:
+* 
+* -> g77 -v
+* g77 version 0.5.23
+* Driving: g77 -v -c -xf77-version /dev/null -xnone
+* Reading specs from /usr/lib/gcc-lib/i686-pc-linux-gnulibc1/2.8.1/specs
+* gcc version 2.8.1
+*  /usr/lib/gcc-lib/i686-pc-linux-gnulibc1/2.8.1/cpp -lang-c -v -undef
+* -D__GNUC__=2 -D__GNUC_MINOR__=8 -D__ELF__ -D__unix__ -D__linux__
+* -D__unix -D__linux -Asystem(posix) -D_LANGUAGE_FORTRAN -traditional
+* -Di386 -Di686 -Asystem(unix) -Acpu(i386) -Amachine(i386) -D__i386__
+* -D__i686__ -Asystem(unix) -Acpu(i386) -Amachine(i386) /dev/null
+* /dev/null
+* GNU CPP version 2.8.1 (i386 GNU/Linux with ELF)
+* #include "..." search starts here:
+* #include <...> search starts here:
+*  /usr/local/include
+*  /usr/i686-pc-linux-gnulibc1/include
+*  /usr/lib/gcc-lib/i686-pc-linux-gnulibc1/2.8.1/include
+*  /usr/include
+* End of search list.
+*  /usr/lib/gcc-lib/i686-pc-linux-gnulibc1/2.8.1/f771 -fnull-version
+* -quiet -dumpbase g77-version.f -version -fversion -o /tmp/cca24911.s
+* /dev/null
+* GNU F77 version 2.8.1 (i686-pc-linux-gnulibc1) compiled by GNU C version
+* 2.8.1.
+* GNU Fortran Front End version 0.5.23
+*  as -V -Qy -o /tmp/cca24911.o /tmp/cca24911.s
+* GNU assembler version 2.8.1 (i486-linux), using BFD version 2.8.1
+*  ld -m elf_i386 -dynamic-linker /lib/ld-linux.so.1 -o /tmp/cca24911
+* /tmp/cca24911.o /usr/lib/crt1.o /usr/lib/crti.o
+* /usr/lib/gcc-lib/i686-pc-linux-gnulibc1/2.8.1/crtbegin.o
+* -L/usr/lib/gcc-lib/i686-pc-linux-gnulibc1/2.8.1 -L/usr -lg2c -lm -lgcc
+* -lc -lgcc /usr/lib/gcc-lib/i686-pc-linux-gnulibc1/2.8.1/crtend.o
+* /usr/lib/crtn.o
+*  /tmp/cca24911
+* __G77_LIBF77_VERSION__: 0.5.23
+* @(#)LIBF77 VERSION 19970919
+* __G77_LIBI77_VERSION__: 0.5.23
+* @(#) LIBI77 VERSION pjw,dmg-mods 19980405
+* __G77_LIBU77_VERSION__: 0.5.23
+* @(#) LIBU77 VERSION 19970919
+* 
+* 
+* Regards, Dieter.
+* -- 
+* Dieter Stüken, con terra GmbH, Münster
+*     stueken@conterra.de         stueken@qgp.uni-muenster.de
+*     http://www.conterra.de/     http://qgp.uni-muenster.de/~stueken
+*     (0)251-980-2027             (0)251-83-334974
diff --git a/gcc/testsuite/g77.f-torture/noncompile/19990218-1.f b/gcc/testsuite/g77.f-torture/noncompile/19990218-1.f
new file mode 100644
index 00000000000..25b7c5b2b52
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/noncompile/19990218-1.f
@@ -0,0 +1,13 @@
+        double precision function fun(a,b)
+        double precision a,b
+        print*,'in sub: a,b=',a,b
+        fun=a*b
+        print*,'in sub: fun=',fun
+        return
+        end
+        program test
+        double precision a,b,c
+        data a,b/1.0d-46,1.0d0/
+        c=fun(a,b)
+        print*,'in main: fun=',c
+        end
diff --git a/gcc/testsuite/g77.f-torture/noncompile/980615-0.f b/gcc/testsuite/g77.f-torture/noncompile/980615-0.f
new file mode 100644
index 00000000000..316969f6aa8
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/noncompile/980615-0.f
@@ -0,0 +1,10 @@
+* Fixed by JCB 1998-07-25 change to stc.c.
+
+* Date: Thu, 11 Jun 1998 22:35:20 -0500
+* From: Ian A Watson <WATSON_IAN_A@lilly.com>
+* Subject: crash
+* 
+      CaLL foo(W)
+      END
+      SUBROUTINE foo(W)
+      yy(I)=A(I)Q(X)
diff --git a/gcc/testsuite/g77.f-torture/noncompile/980616-0.f b/gcc/testsuite/g77.f-torture/noncompile/980616-0.f
new file mode 100644
index 00000000000..bd5e74022a3
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/noncompile/980616-0.f
@@ -0,0 +1,8 @@
+* Fixed by 1998-07-11 equiv.c change.
+* ../../gcc/f/equiv.c:666: failed assertion `ffebld_op (subscript) == FFEBLD_opCONTER'
+
+* Date: Mon, 15 Jun 1998 21:54:32 -0500
+* From: Ian A Watson <WATSON_IAN_A@lilly.com>
+* Subject: Mangler Crash
+      EQUIVALENCE(I,glerf(P))
+      COMMON /foo/ glerf(3)
diff --git a/gcc/testsuite/g77.f-torture/noncompile/check0.f b/gcc/testsuite/g77.f-torture/noncompile/check0.f
new file mode 100644
index 00000000000..fc3c6ca730e
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/noncompile/check0.f
@@ -0,0 +1,11 @@
+CCC Abort fixed by:
+CCC1998-04-21  Jim Wilson  <wilson@cygnus.com>
+CCC
+CCC        * stmt.c (check_seenlabel): When search for line number note for
+CCC        warning, handle case where there is no such note.
+      logical l(10)
+      integer i(10)
+      goto (10,20),l
+      goto (10,20),i
+ 10   stop
+ 20   end
diff --git a/gcc/testsuite/g77.f-torture/noncompile/noncompile.exp b/gcc/testsuite/g77.f-torture/noncompile/noncompile.exp
new file mode 100644
index 00000000000..7087aa2eb4d
--- /dev/null
+++ b/gcc/testsuite/g77.f-torture/noncompile/noncompile.exp
@@ -0,0 +1,39 @@
+#   Copyright (C) 1988, 90, 91, 92, 97, 1998 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# This file was written by Jeff Law. (law@cs.utah.edu)
+
+#
+# These tests come from Torbjorn Granlund (tege@cygnus.com)
+# C torture test suite.
+#
+
+load_lib mike-g77.exp
+
+# Test check0.f
+prebase
+
+set src_code check0.f
+# Not really sure what the error should be here...
+set compiler_output ".*:8.*:9"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
diff --git a/gcc/testsuite/gcc.c-torture/ChangeLog b/gcc/testsuite/gcc.c-torture/ChangeLog
new file mode 100644
index 00000000000..9fc47901c02
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/ChangeLog
@@ -0,0 +1,837 @@
+Sun Oct 24 23:54:10 PDT 1999 Jeff Law  (law@cygnus.com)
+
+	* gcc-2.95.2 Released.
+
+Mon Aug 16 01:29:24 PDT 1999 Jeff Law  (law@cygnus.com)
+
+	* gcc-2.95.1 Released.
+
+Wed Jul 28 21:39:31 PDT 1999 Jeff Law  (law@cygnus.com)
+
+	* gcc-2.95 Released.
+
+Sun Jul 25 23:40:51 PDT 1999 Jeff Law  (law@cygnus.com)
+
+	* gcc-2.95 Released.
+
+Wed Apr  7 23:08:59 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* execute/920501-7.c (main): Delete __I960__ ifndef.
+
+Mon Mar 22 14:55:58 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* execute/bf-sign-2.c (main): Replace struct sizeof test with 4.
+
+Wed Mar 17 12:22:39 1999  Richard Henderson  <rth@cygnus.com>
+
+	* gcc.c-torture/execute/ieee/980619-1.x: New.  Expected fail on x86.
+
+Fri Mar 12 16:17:28 1999  Jim Wilson  <wilson@cygnus.com>
+
+	* execute/970312-1.c, execute/980605-1.c (f): Change printf to sprintf.
+	* execute/bf-sign-2.c (struct X): Add u15 field.
+	(main): Add check for u15.  Conditionalize u31 check depending on
+	whether ints are <32 bits or >=32 bits.
+	
+1999-03-01 Zack Weinberg  <zack@rabi.columbia.edu>
+
+	* noncompile/noncompile.exp (951025-1.c): Accept an error
+	message on line 1 or line 2; cccp and cpplib do this differently.
+
+1999-02-03  Nick Clifton  <nickc@cygnus.com>
+
+	* execute/memcheck/blkarg.c (foo): Use 10 leading arguments in
+	order to force structure S onto the stack even on the alpha.
+	(test): Pass 10 leading arguments to function foo as well as the
+	structure S.
+
+	* execute/memcheck/blkarg.x: New file: Expected failure for all
+	targets. 
+
+	* execute/memcheck/driver.c (main): Use exit or abort to terminate
+	program execution.
+
+1999-01-28  Michael Meissner  <meissner@cygnus.com>
+
+	* execute/990128-1.c: New test.
+
+1999-01-27  Michael Meissner  <meissner@cygnus.com>
+
+	* execute/990127-{1,2}.c: New tests.
+
+1998-12-14  Nick Clifton  <nickc@cygnus.com>
+
+	* execute/920501-4.c (main): Fix typo: replace | with ||.
+
+1998-11-30  Nick Clifton  <nickc@cygnus.com>
+
+	* execute/981130-1.c: New test.
+	* execute/981130-1.x: New test failure expectations.
+
+Sun Oct 11 05:04:28 1998  Ken Raeburn  <raeburn@cygnus.com>
+
+	* execute/memcheck: New directory of tests for
+	-fcheck-memory-usage.
+
+1998-10-06  Ken Raeburn  <raeburn@cygnus.com>
+
+	* special/981006-1.c: New test.  Make sure gcc doesn't lose track
+	of the possible targets of tablejump insns.
+	* special/special.exp: Run it.
+
+Thu Oct  1 17:15:26 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* compile/981001-1.c: New test.
+	* execute/981001-1.c: New test.
+	
+Mon Aug 31 12:00:00 1998  Catherine Moore  <clm@cygnus.com>
+
+	* execute/941014-1.x:  New file.
+
+Wed Aug 26 16:10:00 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* execute/loop-4b.c: New test.
+
+Mon Aug 24 14:20:32 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* execute/bcp-1.c (main): Fix optimize test loop to count number
+	tests in opt_t0 not good_t0.
+
+Thu Aug 13 00:13:55 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* execute/ieee/ieee.exp: Pass -ffloat-store to compiler for
+	ieee tests.
+
+Mon Jul 27 11:05:07 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* execute/ieee/930529-1.c (main): Check to see if __thumb__ is
+	defined, and test for ARM style doubles if so.
+
+Fri Jul 24 11:02:43 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* execute/comp-goto-1.c (main): Make main() return an int.
+
+Thu Jun 18 15:12:30 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* execute/980618-{1,2}.c: New tests that showed up m32r bugs.
+
+Fri Jun  5 21:54:26 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* execute/980605-1.c: New test.
+
+Sun May 31 23:23:29 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* execute/ieee/mzero2.c: New test to better test IEEE -0 support.
+
+Wed Apr  8 13:09:15 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* execute/980407-1.c: Delete test.  Is duplicate of loop-4.c.
+
+Tue Apr  7 12:01:24 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* execute/980407-1.c: New test from Joern Rennecke.
+
+Fri Apr  3 12:27:49 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* compile/980329-1.c: New test.
+
+Mon Feb 23 15:16:53 1998  Robert Lipe <robertl@dgii.com>
+	From Bruno Haible <haible@ilog.fr>:
+	* execute/980223.c: New test.
+
+Fri Feb  6 14:30:48 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* execute/980205.c: New test.
+
+Mon Dec  8 23:55:26 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* noncompile/noncompile.exp (921102-1.c): Fixed comment.
+	(940510-1.c): Removed duplicate.
+	(971104-1.c): New test.
+
+Wed Nov 19 14:27:04 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* execute/950221-1.c (filler): If STACK_SIZE is defined, use that
+	to size the filler array.
+
+Wed Sep  3 17:29:35 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* execute/ieee/ieee.exp: Check for ieee_multilib_flags target
+	feature; pass this to c-torture-execute as needed.
+
+Fri Aug 29 12:48:09 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* execute/921007-1.c: Make strcmp static.
+
+Tue Jul 29 00:40:38 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* conversion.c (test_float_to_integer): Make double precision tests
+	dependent on sizeof (double).
+
+Tue Jun 17 22:11:16 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* compile/961203-1.cexp: New script.
+
+Wed Jun  4 03:38:50 1997  J"orn Rennecke <amylaar@cygnus.co.uk>
+
+	* execute/ieee/ieee.exp: Set -mieee for SH.
+
+Thu May 15 14:00:04 1997  Mike Meissner  <meissner@cygnus.com>
+
+	* execute/va-arg-3.c: If NO_VARARGS is defined, nop test.
+
+	* execute/strct-varg-1.c: If NO_VARARGS is defined, use stdargs.h
+	interface.
+
+Fri Mar 21 16:34:52 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* execute/920501-7.c (main,x): If NO_LABELS_VALUES is defined,
+	don't do test.
+
+Wed Mar 19 13:06:26 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* execute/ieee/rbug.c (main): Don't do long long to double
+	conversion if double isn't at least 8 bytes.
+
+	* execute/cvt-1.c: Make all functions use long, not int to work
+	with targets where int is 16 bits.
+
+	* execute/920715-1.c (main): If double isn't at least 8 bytes,
+	just exit, since 4 byte doubles don't have enough bits of
+	precision for the test to complete.
+
+Fri Mar 14 17:51:02 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* execute/920715-1.cexp (d10v-*-*): Expect to fail if d10v is not
+	compiled with the -mdouble64 flag.
+	* execute/ieee/rbug.cexp (d10v-*-*): Ditto.
+
+	* execute/cvt-1.cexp (d10v-*-*): Expect to fail if d10v is not
+	compiled with the -mint32 flag.
+
+Wed Mar 12 01:23:08 1997  Torbjorn Granlund  <tege@pdc.kth.se>
+
+	* execute/961213-1.c: New test (from hjl@lucon.org).
+
+	* execute/complex-5.c: New test (from moshier@world.std.com).
+
+	* execute/970217-1.c: New test (from eggert@twinsun.com).
+
+	* execute/970214-[12].c: New tests (from eggert@twinsun.com).
+
+	* compile/970214-1.c: New test (from wilson@cygnus.com).
+
+	* execute/ieee/930529-1.c: Also handle arm's unusual byte/word
+	ordering (from amylaar@cygnus.com).
+
+	* execute/index-1.c: Make large vars and values `long'
+	(from law@cygnus.com).
+
+	* execute/941014-2.c: Declare malloc.
+
+	* compile/970206-1.c: New test (from dje@cygnus.com).
+
+	* execute/960521-1.c: Rewrite to take STACK_SIZE into account
+	(from amylaar@cygnus.co.uk).
+
+	* execute/961223-1.c: New test (from wilson@cygnus.com).
+
+	* compile/961203-1.c: New test (from amylaar@cygnus.co.uk).
+
+	* compile/961126-1.c: New test (from wilson@cygnus.com).
+
+	* execute/961125-1.c: New test (from meyering@asic.sc.ti.com).
+
+	* execute/961122-2.c: New test (from
+	schwab@issan.informatik.uni-dortmund.de).
+
+	* execute/961122-1.c: New test (from Philippe De Muyter).
+
+	* execute/loop-2[ef].c: Default MAP_FIXED to 0 (from
+	amylaar@cygnus.co.uk).
+
+	Changes from meissner@cygnus.com:
+	* execute/920501-9.c (print_longlong): Print pieces as a long, not int.
+	* execute/950915-1.c: (a,b): Make types long to prevent implicit
+	overflow on 16-bit systems.
+	* execute/dbra-1.c: Pass long values to functions expecting
+	long values.
+	* execute/950607-2.c: (Point): Make field type long, since 23250 -
+	(-23250) is larger than 16 bits.
+	* execute/960416-1.c: Make st type unsigned long, not unsigned int.
+	* execute/bf-sign-2.c: Make bitfields whose size is > 16 bits
+	long, not int for 16-bit hosts.
+	* execute/961017-2.c: Make z unsigned long, not unsigned int.
+
+	* execute/cmpsi-1.c: Rewrite not to depend on type sizes.
+
+	* execute/960909-1.c (ffs): New function (from law@cygnus.com).
+
+	* execute/fp-cmp-1.c: Add test for SIGNAL_SUPPRESS around signal call.
+	Move to execute/ieee.
+
+	* execute/970312-1.c: New test.
+	* execute/cvt-1.c: New test.
+
+Thu Feb 13 13:52:23 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* compile/920301-1.c: If NO_LABEL_VALUES is defined, nop test
+	using labels as values extension.
+	* compile/920415-1.c: Ditto.
+	* compile/920428-3.c: Ditto.
+	* compile/920501-1.c: Ditto.
+	* compile/920501-7.c: Ditto.
+	* compile/941014-4.c: Ditto.
+	* compile/950613-1.c: Ditto.
+	* compile/labels-1.c: Ditto.
+	* execute/920302-1.c: Ditto.
+	* execute/920415-1.c: Ditto.
+	* execute/920428-2.c: Ditto.
+	* execute/920501-3.c: Ditto.
+	* execute/920501-4.c: Ditto.
+	* execute/920501-5.c: Ditto.
+	* execute/920721-4.c: Ditto.
+	* execute/comp-goto-1.c: Ditto.
+
+	* compile/930506-2.c: If NO_TRAMPOLINES is defined, nop the test.
+	* execute/921215-1.c: Ditto.
+	* execute/931002-1.c: Ditto.
+	* execute/nestfunc-1.c: Ditto.
+
+Wed Jan 22 00:04:53 1997  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/961017-1.c: Add missing exit (0).
+
+Fri Dec  6 19:38:57 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/961206-1.c: New test.
+
+Wed Nov 13 17:13:05 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/loop-2[ef].c: Misc portability changes
+	(from amylaar@cygnus.co.uk).
+
+Tue Nov 12 15:00:42 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/961112-1.c: New test (based on a test by wilson@cygnus.com).
+
+	* execute/ieee/DESC: New file.
+
+	* execute/{loop-2[bcdef].c,loop-3[bc].c}:
+	New tests (from amylaar@cygnus.co.uk).
+
+	* execute/ieee/nan.c: Delete test.
+
+	* execute/fp-cmp-1.c: Disable for Cray and VAX.
+
+	* execute/960416-1.c: Make it work for big-endian machines (from
+	amylaar@cygnus.co.uk).
+
+Mon Nov 11 18:00:35 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/960830-1.c: Make it work for non-x86 machines.
+
+	* execute/961017-2.c: Call exit(0).
+
+Fri Nov  8 19:19:17 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/960311-3.c: #include <stdio.h>.
+	* execute/920501-8.c: Likewise.
+	* execute/920501-9.c: Likewise.
+	* execute/941014-2.c: Likewise.
+	* execute/960311-1.c: Likewise.
+	* execute/960311-2.c: Likewise.
+
+	* execute/961017-[12].c: New test (from wilson@cygnus.com).
+	* compile/961031-1.c: New test (from wilson@cygnus.com).
+	* compile/961019-1.c: New test (from wilson@cygnus.com).
+	* utils/ctest.c: Print and pass (to run_a_test) all arguments.
+	* execute/{920711-1.c,920810-1.c,920922-1.c,930603-3.c,931018-1.c}
+	* execute/{941025-1.c,950221-1.c,950426-2.c,960209-1.c,960321-1.c}
+	* execute/{960327-1.c,arith-rand.c,bf-pack-1.c,cbrt.c,divconst-2.c}
+	* execute/memcpy-1.c: 16-bit changes (from law@cygnus.com).
+
+	* compile/960514-1.c: New test (from rwilhelm@physik.tu-muenchen.de).
+
+	* execute/960512-1.c: New test (from amylaar@meolyon.hanse.de).
+
+	* execute/960513-1.c: New test (from amylaar@meolyon.hanse.de).
+
+	* execute/960405-1.c: New test (from moshier@world.std.com).
+
+Fri Nov  1 13:06:28 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/dbra-1.c: New test.
+
+Mon Oct 28 02:31:10 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/961026-1.c: New test (from rankin@eql.caltech.edu).
+
+	* execute/enum-1.c: New test (from law@cygnus.com).
+
+Tue Oct 22 22:13:12 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/960801-1.c: Generalize.
+
+Fri Oct 18 04:14:01 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* utils/ctest.c (run_a_test): Don't call `fatal' when the compiler
+	returns non-zero, but there is no error message from the compiler.
+
+Wed Oct 16 01:39:57 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/arith-rand.c (main): Decrease the number of iteration to
+	1000.
+
+Fri Oct 11 16:40:44 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* compile/961010-1.c: New test (from ian@cygnus.com).
+
+Fri Oct  4 18:29:00 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/961004-1.c: New test (from wilson@cygnus.com).
+
+	* compile/961004-1.c: New test (from amylaar@cygnus.co.uk).
+
+Thu Oct  3 02:51:24 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/fp-cmp-1.c: Move signal handler setup to after == and !=
+	compares.
+
+Wed Oct  2 04:53:54 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/fp-cmp-1.c: New test.
+
+Mon Sep 30 01:11:06 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* compile/960620-1.c: Delete test.
+
+Fri Sep 13 12:12:30 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* execute/ieee/920810-1.c: Include <stdio.h>.
+
+Mon Sep  9 18:56:33 1996  Torbjorn Granlund  <tege@quiet.matematik.su.se>
+
+	* execute/960909-1.c: New test.
+
+Fri Aug 30 06:31:25 1996  Torbjorn Granlund  <tege@quiet.tmg.se>
+
+	* execute/960830-1.c: New test.
+
+Thu Aug 29 22:06:49 1996  Torbjorn Granlund  <tege@quiet.tmg.se>
+
+	* compile/960829-1.c: New test.
+
+Tue Aug 13 19:23:06 1996  Torbjorn Granlund  <tege@noisy.tmg.se>
+
+	* utils/ctest.c (run_a_test): Call wait repeatedly until
+	we get back the right pid.
+
+Sat Aug  3 16:36:43 1996  Torbjorn Granlund  <tege@noisy.tmg.se>
+
+	* execute/960416-1.c: New test (from amylaar@meolyon.hanse.de).
+
+	* execute/960419-[12].c: New tests (from jtc@cygnus.com).
+
+	* execute/960416-1.c: New test (from amylaar@meolyon.hanse.de).
+
+	* execute/920721-1.c: Make it work for 16-bit systems
+	(from law@cygnus.com).
+	* execute/920728-1.c: Likewise.
+
+	* compile/960201-1.c: New test (from eggert@twinsun.com).
+	* compile/960130-1.c: New test (from eggert@twinsun.com).
+
+Sat Aug  3 16:10:20 1996  Andrew Cagney  <cagney@highland.com.au>
+
+	* utils/ctest.c (run_a_test): Flush output before first fork to
+	avoid later duplication.
+
+	* utils/ctest.c (run_a_test): If really verbose, and a run command
+	was specified (-run), print the command to be executed out.
+	* (run_a_test): For the -run option, accept an argument list.
+
+	* utils/ctest.c (main): Change verbose flag so it increments the
+	verbosity instead of just setting it.  Backward compatible hack
+	that allows multiple levels of tracing.  Perhaphs a separate flag
+	would be better.
+	(main): If really verbose, print the GCC command that is to be executed.
+	(run_a_test): If really verbose, print the output from compiler
+	and allow the output from the run to be displayed.
+
+	* utils/ctest.c (main): New option -postopts added.  This allows
+	the user to specify arguments that should be appended to the GCC
+	command (in addition to the -options flag that specfies arguments
+	that are to be prepended).
+	(usage): Adjust.
+
+Sat Aug  3 16:10:20 1996  Torbjorn Granlund  <tege@noisy.tmg.se>
+
+	From Mike Meissner:
+	* utils/ctest.c: Sort test files by calling `ls -r'.
+	* utils/ctest.c: Flush stdout after each printf.
+	* utils/ctest.c: When `-run', up timeout to 1000.  Allow
+	explicit setting of timeout through new -cc-timeout option.
+
+Fri Aug  2 19:53:27 1996  Torbjorn Granlund  <tege@noisy.tmg.se>
+
+	* execute/960521-1.c: New test
+	(from eggert@twinsun.com and Andreas Schwab).
+
+	* compile/960620-1.c: New test (from rwilhelm@physik.tu-muenchen.de).
+
+	* compile/960704-1.c: New test (from wilson@cygnus.com).
+
+	* execute/bf-sign-2.c: New test (from gavin@nando.net).
+
+	* execute/960802-1.c: New test (from law@cygnus.com).
+
+	* execute/960801-1.c: New test (from dje@cygnus.com).
+
+Sun Jun  9 17:35:56 1996  Torbjorn Granlund  <tege@noisy.tmg.se>
+
+	* execute/960608-1.c: New test (from law@cygnus.com).
+
+Tue Apr  2 23:18:51 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* execute/900409-1.c: Change types from int to long
+	(from law@cygnus.com).
+
+	* execute/960402-1.c: New test.
+
+Fri Mar 29 23:40:01 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* execute/960327-1.c: New test (from law@cygnus.com).
+
+Tue Mar 26 22:57:34 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* execute/960326-1.c: New test (from wilson@cygnus.com).
+	* execute/960321-1.c: New test (from law@cygnus.com).
+	* compile/960319-1.c: New test (from amylaar@meolyon.hanse.de).
+	* execute/960317-1.c: New test (from amylaar@meolyon.hanse.de).
+	* execute/960312-1.c: New test (from amylaar@meolyon.hanse.de).
+	* execute/960311-[123].c: New tests (from dje@cygnus.com).
+	* execute/960302-1.c: New test (from law@cygnus.com).
+	* execute/960215-1.c: New test (from moshier@world.std.com).
+
+Fri Mar  1 06:01:58 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* execute/regstack-1.c: New test (from moshier@world.std.com).
+	* execute/960301-1.c: New test (from rankin@eql.caltech.edu).
+	* execute/struct-ini-4.c: New test (from wilson@cygnus.com).
+
+Sun Feb 25 01:10:12 1996  Paul Eggert  <eggert@twinsun.com>
+
+	* special/doit (960224-1, 960224-2): New tests.
+
+Wed Feb 21 07:18:19 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* compile/960221-1.c: New test (from law@cygnus.com).
+	* compile/960220-1.c: New test.
+
+Mon Feb 19 03:14:18 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* execute/960219-1.c: New test.
+	* compile/960218-1.c: New test (from eggert@twinsun.com).
+
+Sun Feb 18 04:01:54 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* execute/960218-1.c: New test.
+
+Sat Feb 10 03:07:04 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* execute/960209-1.c: New test (from law@cygnus.com).
+
+Wed Jan 24 23:23:05 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* execute/960117-1.c: New test (from dje@cygnus.com).
+	* execute/960116-1.c: New test (from Philippe De Muyter).
+
+Mon Jan 22 23:46:17 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* noncompile/930714-1.c: Moved from compile.
+
+Mon Jan 22 19:08:04 1996  Paul Eggert  <eggert@twinsun.com>
+
+	* special/doit (920717-1): Make sure `not found' message is ignored
+	when invoking cc.
+
+Tue Jan 16 14:24:36 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* noncompile/951227-1.c: New test (from eggert).
+	* special/doit (951130-1): New test (from eggert).
+	* noncompile/951025-1.c: New test.
+
+Thu Jan 11 09:36:49 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* execute/widechar-1.c: New test (from eggert).
+
+Tue Jan  9 12:44:21 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* compile/960106-1.c: New test.
+
+Mon Dec 25 19:21:08 1995  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* compile/951222-1.c: New test (from kenner).
+
+Wed Dec 20 14:45:42 1995  Torbjorn Granlund  <tege@noisy.tmg.se>
+
+	* compile/951220-1.c: New test.
+
+Wed Dec  6 13:46:17 1995  Torbjorn Granlund  <tege@noisy.tmg.se>
+
+	From Alan Modra:
+	* utils/ctest.c (main): mktemp needs 6 X's on some systems.
+
+Mon Dec  4 21:39:39 1995  Torbjorn Granlund  <tege@noisy.tmg.se>
+
+	* compile/widechar-1.c: New test.
+
+	* unsorted/{bugx.c,bugy.c,inline.c}: Delete huge/duplicate tests.
+
+	* execute/951204-1.c: New test.
+	* compile/951128-1.c: New test.
+
+Mon Nov 27 00:16:37 1995  Torbjorn Granlund  <tege@noisy.tmg.se>
+
+	* execute/bf-layout-1.c: New test.
+
+Wed Nov 22 21:38:25 1995  Torbjorn Granlund  <tege@noisy.tmg.se>
+
+	* noncompile/951123-1.c: New test.
+
+Wed Nov 16 23:31:23 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* compile/951116-1.c: New test.
+
+Wed Nov 15 20:34:03 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* utils/ctest.c: New name for runtests.c (not to confuse it with
+	DejaGNU runtest).
+
+	* utils/runtests.c (RLIMIT_CORE): Default to 4.
+
+	* execute/951115-1.c: New test (PA delay slot filling bug).
+
+Tue Nov 14 00:27:10 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* utils/runtests.c (run_a_test): Read from errmess pipe before
+	blocking on child process.  Also, loop calling read(2) until pipe
+	is empty or 8000 chars are read.
+	(usage): New function.
+	(main): Call usage for -help.
+
+Sun Nov  7 17:15:12 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* compile/951106-1.c: New test (MIPS3).
+
+Sun Nov  5 12:22:20 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* utils/runtests.c (run_a_test): Don't print exit status for failing
+	noncompile test.
+
+Thu Oct 26 00:45:43 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* utils/runtests.c (run_a_test): Save and restore filedesc for
+	stdout, so that failure in execve is reported properly.
+	From Arne Juul:
+	(run_a_test): To work around NetBSD bug, don't pass NULL as 2nd
+	execve argument.
+
+Wed Oct 25 16:13:46 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* utils/runtests.c (main): Fix typo testing `execute_these_files'.
+
+Tue Oct 10 17:41:47 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/950714-1.c (main): Call exit(0).
+
+	* compile/951004-1.c: New test.
+
+Tue Oct  3 22:59:13 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/950929-1.c: New test (from ian@cygnus.com).
+
+	* execute/951003-1.c: New test (from dje@cygnus.com).
+
+Tue Sep 26 15:31:49 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/950714-1.c: New test (from wilson@cygnus.com).
+
+	* execute/950706-1.c: New test (from rearnsha)
+
+	* execute/ieee/{minuszero.c,rbug.c,nan.c}: New tests (from moshier).
+
+	* execute/scope-2.c: New test (from rfg).
+
+	* execute/bf-sign-1.c: New test (from jtc@cygnus.com).
+
+	* noncompile/930927-1.c: Delete this duplicated test.
+
+	* unsorted/gdb.c: Delete this test.
+	* */*.c: Delete whitespace at the end of lines.
+
+	* execute/loop-3.c: New test (from amylaar@meolyon.hanse.de).
+
+Mon Sep 25 14:08:32 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* Make file permissions be regular.
+
+	* utils/runtests.c (main): Combine `flag_execute' and
+	`execute_these_files' into the latter.
+	(run_a_test): Test only `execute_these_files'.
+
+	* execute/920411-1.c: Generalize to work even for big-endian
+	64-bit machines (from amylaar@meolyon.hanse.de).
+
+Sun Sep 24 16:26:03 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* utils/runtests.c (set_watchdog): Actually use `seconds' parameter.
+
+Sat Sep 23 00:08:33 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* compile/950922-1.c: New test.
+
+Thu Sep 21 12:25:40 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* utils/runtests.c (environ): Declare.
+	(run_a_test): Pass environ to execve calls.
+	(main): Don't NULL-terminate `passes' array.
+	(main): Make ii loop's termination condition depend on n_passes.
+	(run_a_test): Check result from read; '\0'-terminate buf.
+	(main): Avoid d_namlen, use strlen of d_name instead (from meyering).
+
+	* compile/950919-1.c: New test.
+
+	* execute/conversion.c (test_longlong_integer_to_float): Modify
+	some tests conditionally for __HAVE_68881__.
+
+	* execute/950915-1.c: New test.
+
+	* utils/runtests.c: New file to run tests faster.
+	* {execute/compile/unsorted/noncompile}/DESC: New files.
+
+	* compile/950921-1.c: New test (from Ian Taylor).
+
+Wed Sep 20 14:53:33 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* execute/920501-7.c (STACK_SIZE): Check for and use to limit
+	depth of recursion.
+
+Mon Sep 18 23:43:28 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* compile/gcc-failure/940409-1.c: Moved from compile.
+
+	* execute/920411-1.c: Moved from execute/gcc_failure.
+	* execute/gcc_failure/920627-2.c: Delete spurious test.
+
+	* utils/runtests.c: New program.
+
+Tue Sep 12 22:05:15 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/divconst-3.c: New test.
+
+Mon Sep 11 12:48:04 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* compat/struct-ret-1.c: Add prototype for f.
+	* compat/strct-layout.c: Conditionalize main.
+
+Sun Sep 10 20:47:34 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/strct-pack-5.c: Delete, test is useless because of
+	lack of 68k structure packing.
+
+Thu Sep  7 13:07:40 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/{930628-1.c,941202-1.c,arith-1.c,gofast.c,struct-ret-1.c,
+	va-arg-4.c}: Call exit(0), don't do return 0.
+
+Tue Sep  5 15:23:14 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* compat/strct-layout.c (main): Add missing call to exit.
+
+Tue Sep  5 15:23:14 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	1.35 Released.
+
+	* noncompile/doit (case $arg): Fix typo.
+
+	* execute/compndlit-1.c: New test.
+	* execute/loop-2.c: New test.
+	* execute/950809-1.c: New test.
+	* execute/va-arg-5.c: New test.
+	* execute/va-arg-6.c: New test.
+	* execute/ptr-arith-1.c: New test.
+	* execute/cmpsi-1.c: New test.
+
+	* compile/cmpdi-1.c: New test.
+	* compile/950719-1.c: New test.
+	* compile/950729-1.c: New test.
+	* compile/950816-[123].c: New test.
+	* compile/: New test.
+	* compile/: New test.
+	* compile/: New test.
+	* compile/: New test.
+
+Fri Sep 5 09:30:32 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* */doit: Add -run <cmd> option to allow the use of a simulator to
+	run commands in the execute subdirectory.  Accept the switch in
+	the other doit commands.
+
+Tue Jul 11 01:02:21 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/950710-1.c: New test (from meyering).
+
+Wed Jul  5 16:03:45 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* compile/950618-1.c: New test.
+	* execute/scope-1.c: New test.
+	* execute/950621-1.c: New test.
+	* execute/950704-1.c: New test.
+	* execute/950628-1.c: New test.
+
+Wed Jun 14 15:20:44 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/950612-1.c: New test.
+	* execute/cmpdi-1.c: New test.
+	* execute/tstdi-1.c: New test.
+	* compile/950613-1.c: New test.
+	* compile/950530-1.c: New test.
+	* compile/950610-1.c: New test.
+	* compile/950612-1.c: New test.
+
+	* execute/strct-pack-5.c: Clean up, use defined type s2_t.
+	* execute/strct-pack-4.c: Clean up.
+
+Sat Jun 10 12:37:22 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/cbrt.c: Disable for vax.
+
+Fri Jun  9 21:49:58 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/940115-1.c: Cast parameters to char *.
+
+Thu Jun  8 00:33:51 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* compile/950607-1.c: New test.
+	* execute/cbrt.c: New test.
+	* execute/950607-[12].c: New tests.
+	* execute/memcpy-1.c: Try more cases.
+	* execute/struct-ret-2.c: New test.
+	* execute/complex-4.c: New test.
+
+Wed Jun  7 12:40:05 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/950601.c: Delete this messy and redundant test.
+
+	* compile/funcptr-1.c: Clean up.
+
+	* execute/950512-1.c (main): Call f1 and f2 with 0 too.
+	(f2): Use type `long long', not `long'.
+
+	* execute/950605-1.c: New test.
+
+Wed Jun  1 01:57:45 1995  Torbjorn Granlund  <tege@bozo.matematik.su.se>
+
+	* execute/divconst-[12].c: New tests.
diff --git a/gcc/testsuite/gcc.c-torture/code_quality/920608-1.c b/gcc/testsuite/gcc.c-torture/code_quality/920608-1.c
new file mode 100644
index 00000000000..cae1978e6c0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/code_quality/920608-1.c
@@ -0,0 +1,25 @@
+foo (p)
+     int *p;
+{
+  int x;
+  int a;
+
+  a = p[0];
+  x = a + 5;
+  a = -1;
+  p[0] = x - 5;
+  return a;
+}
+
+bar (p)
+{
+  short x;
+  int a;
+
+  x = ((short *) p)[1];
+#if INHIBIT_COMBINE
+  ((short *) p)[0] = x;
+#endif
+
+  return (x < 45);
+}
diff --git a/gcc/testsuite/gcc.c-torture/code_quality/Makefile.in b/gcc/testsuite/gcc.c-torture/code_quality/Makefile.in
new file mode 100644
index 00000000000..e6209dbc6c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/code_quality/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+	-rm -f *.o *.diff *~ *.bad core *.x
+
+distclean:	clean
+	-rm -f Makefile config.status
diff --git a/gcc/testsuite/gcc.c-torture/code_quality/code_quality.exp b/gcc/testsuite/gcc.c-torture/code_quality/code_quality.exp
new file mode 100644
index 00000000000..b8b72ea1bcb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/code_quality/code_quality.exp
@@ -0,0 +1,55 @@
+#
+# Expect driver script for GCC Regression Tests
+#   Copyright (C) 1993, 1997 Free Software Foundation
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+#
+# Written by Jeffrey Wheat (cassidy@cygnus.com)
+#
+
+#
+# These tests come from Torbjorn Granlund's (tege@cygnus.com)
+# C torture test suite, and other contributors.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+
+#
+# This loop will run c-torture on any *.c file found in this directory.
+# If a *.c has a corresponding *.exp file, then the test is skipped as
+# as the *.exp will drive the test itself. I did things this way so that
+# generic tests did not need a seperate .exp for it. Only the tests that 
+# required unique options would need it's own .exp file.
+#
+
+foreach testcase [glob -nocomplain $srcdir/$subdir/*.c] {
+    if [file exists [file rootname $testcase].exp] then {
+	verbose "INFO:\"[file rootname $testcase].exp\" exists, skipping test" 3
+	continue
+    }
+
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $testcase] then {
+	continue
+    }
+    
+    c-torture $testcase
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/code_quality/configure.in b/gcc/testsuite/gcc.c-torture/code_quality/configure.in
new file mode 100644
index 00000000000..0fb5342a5d6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/code_quality/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=code_quality.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/gcc.c-torture/compat/Makefile.in b/gcc/testsuite/gcc.c-torture/compat/Makefile.in
new file mode 100644
index 00000000000..e6209dbc6c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compat/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+	-rm -f *.o *.diff *~ *.bad core *.x
+
+distclean:	clean
+	-rm -f Makefile config.status
diff --git a/gcc/testsuite/gcc.c-torture/compat/configure.in b/gcc/testsuite/gcc.c-torture/compat/configure.in
new file mode 100644
index 00000000000..a4a5810eb96
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compat/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=struct-big.c
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/gcc.c-torture/compat/strct-layout.c b/gcc/testsuite/gcc.c-torture/compat/strct-layout.c
new file mode 100644
index 00000000000..b77e1636dd2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compat/strct-layout.c
@@ -0,0 +1,69 @@
+typedef struct
+{
+  char a;
+  int b;
+  char c;
+  short d;
+  double e;
+  char f;
+} T;
+
+#if COMPILER != 1
+f (T *x)
+{
+  x[0].a = 'a';
+  x[0].b = 47114711;
+  x[0].c = 'c';
+  x[0].d = 1234;
+  x[0].e = 3.141592897932;
+  x[0].f = '*';
+
+  x[1].a = 'A';
+  x[1].b = 71417141;
+  x[1].c = 'C';
+  x[1].d = 4321;
+  x[1].e = 2.718281828459;
+  x[1].f = '?';
+}
+#endif
+
+#if COMPILER != 2
+g (T *x)
+{
+  if (x[0].a != 'a')
+    abort ();
+  if (x[0].b != 47114711)
+    abort ();
+  if (x[0].c != 'c')
+    abort ();
+  if (x[0].d != 1234)
+    abort ();
+  if (x[0].e != 3.141592897932)
+    abort ();
+  if (x[0].f != '*')
+    abort ();
+
+  if (x[1].a != 'A')
+    abort ();
+  if (x[1].b != 71417141)
+    abort ();
+  if (x[1].c != 'C')
+    abort ();
+  if (x[1].d != 4321)
+    abort ();
+  if (x[1].e != 2.718281828459)
+    abort ();
+  if (x[1].f != '?')
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+main ()
+{
+  T x[2];
+  f (x);
+  g (x);
+  exit (0);
+}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compat/struct-align.c b/gcc/testsuite/gcc.c-torture/compat/struct-align.c
new file mode 100644
index 00000000000..69fe6b335ca
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compat/struct-align.c
@@ -0,0 +1,52 @@
+typedef union
+{
+  struct {int a; int b;} s;
+  double d;
+} T;
+
+int h (T *);
+T g (T);
+
+#if COMPILER != 1
+h (T *x)
+{
+  if (x->s.a != 0 || x->s.b != 1)
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+T
+g (T x)
+{
+  if (x.s.a != 13 || x.s.b != 47)
+    abort ();
+  x.s.a = 0;
+  x.s.b = 1;
+  h (&x);
+  return x;
+}
+#endif
+
+#if COMPILER != 1
+f ()
+{
+  T x;
+  x.s.a = 13;
+  x.s.b = 47;
+  g (x);
+  if (x.s.a != 13 || x.s.b != 47)
+    abort ();
+  x = g (x);
+  if (x.s.a != 0 || x.s.b != 1)
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+main ()
+{
+  f ();
+  exit (0);
+}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compat/struct-big.c b/gcc/testsuite/gcc.c-torture/compat/struct-big.c
new file mode 100644
index 00000000000..e1d5c6a6b37
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compat/struct-big.c
@@ -0,0 +1,54 @@
+typedef struct {int a, b, c, d, e;} T;
+
+int h (T *);
+T g (T);
+
+#if COMPILER != 1
+h (T *x)
+{
+  if (x->a != 0 || x->b != 1 || x->c != 2 || x->d != 3 || x->e != 4)
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+T
+g (T x)
+{
+  if (x.a != 13 || x.b != 47 || x.c != 123456 || x.d != -4711 || x.e != -2)
+    abort ();
+  x.a = 0;
+  x.b = 1;
+  x.c = 2;
+  x.d = 3;
+  x.e = 4;
+  h (&x);
+  return x;
+}
+#endif
+
+#if COMPILER != 1
+f ()
+{
+  T x;
+  x.a = 13;
+  x.b = 47;
+  x.c = 123456;
+  x.d = -4711;
+  x.e = -2;
+  g (x);
+  if (x.a != 13 || x.b != 47 || x.c != 123456 || x.d != -4711 || x.e != -2)
+    abort ();
+  x = g (x);
+  if (x.a != 0 || x.b != 1 || x.c != 2 || x.d != 3 || x.e != 4)
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+main ()
+{
+  f ();
+  exit (0);
+}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compat/struct-i.c b/gcc/testsuite/gcc.c-torture/compat/struct-i.c
new file mode 100644
index 00000000000..25cbee6071e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compat/struct-i.c
@@ -0,0 +1,46 @@
+typedef struct {int a;} T;
+
+int h (T *);
+T g (T);
+
+#if COMPILER != 1
+h (T *x)
+{
+  if (x->a != 47114711)
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+T
+g (T x)
+{
+  if (x.a != 13)
+    abort ();
+  x.a = 47114711;
+  h (&x);
+  return x;
+}
+#endif
+
+#if COMPILER != 1
+f ()
+{
+  T x;
+  x.a = 13;
+  g (x);
+  if (x.a != 13)
+    abort ();
+  x = g (x);
+  if (x.a != 47114711)
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+main ()
+{
+  f ();
+  exit (0);
+}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compat/struct-ic.c b/gcc/testsuite/gcc.c-torture/compat/struct-ic.c
new file mode 100644
index 00000000000..7c5fa79e142
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compat/struct-ic.c
@@ -0,0 +1,48 @@
+typedef struct {int a; char b;} T;
+
+int h (T *);
+T g (T);
+
+#if COMPILER != 1
+h (T *x)
+{
+  if (x->a != 0 || x->b != 1)
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+T
+g (T x)
+{
+  if (x.a != 13 || x.b != 47)
+    abort ();
+  x.a = 0;
+  x.b = 1;
+  h (&x);
+  return x;
+}
+#endif
+
+#if COMPILER != 1
+f ()
+{
+  T x;
+  x.a = 13;
+  x.b = 47;
+  g (x);
+  if (x.a != 13 || x.b != 47)
+    abort ();
+  x = g (x);
+  if (x.a != 0 || x.b != 1)
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+main ()
+{
+  f ();
+  exit (0);
+}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compat/struct-ii.c b/gcc/testsuite/gcc.c-torture/compat/struct-ii.c
new file mode 100644
index 00000000000..11ebc37edbd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compat/struct-ii.c
@@ -0,0 +1,48 @@
+typedef struct {int a, b;} T;
+
+int h (T *);
+T g (T);
+
+#if COMPILER != 1
+h (T *x)
+{
+  if (x->a != 0 || x->b != 1)
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+T
+g (T x)
+{
+  if (x.a != 13 || x.b != 47)
+    abort ();
+  x.a = 0;
+  x.b = 1;
+  h (&x);
+  return x;
+}
+#endif
+
+#if COMPILER != 1
+f ()
+{
+  T x;
+  x.a = 13;
+  x.b = 47;
+  g (x);
+  if (x.a != 13 || x.b != 47)
+    abort ();
+  x = g (x);
+  if (x.a != 0 || x.b != 1)
+    abort ();
+}
+#endif
+
+#if COMPILER != 2
+main ()
+{
+  f ();
+  exit (0);
+}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compat/struct-ret-1.c b/gcc/testsuite/gcc.c-torture/compat/struct-ret-1.c
new file mode 100644
index 00000000000..a585c8fdb40
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compat/struct-ret-1.c
@@ -0,0 +1,25 @@
+typedef struct { int re; int im; } T;
+
+T f (int, int);
+
+#if COMPILER != 1
+T
+f (int arg1, int arg2)
+{
+  T x;
+  x.re = arg1;
+  x.im = arg2;
+  return x;
+}
+#endif
+
+#if COMPILER != 2
+main ()
+{
+  T result;
+  result = f (3, 4);
+  if (result.re != 3 || result.im != 4)
+    abort ();
+  exit (0);
+}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compile/900116-1.c b/gcc/testsuite/gcc.c-torture/compile/900116-1.c
new file mode 100644
index 00000000000..37c7eb789b9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/900116-1.c
@@ -0,0 +1,14 @@
+struct st {char a, b, c, d; }
+
+zloop (struct st *s, int *p, int *q)
+{
+  int i;
+  struct st ss;
+
+  for (i = 0;  i < 100;  i++)
+    {
+      ss = s[i];
+      p[i] = ss.c;
+      q[i] = ss.b;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/900216-1.c b/gcc/testsuite/gcc.c-torture/compile/900216-1.c
new file mode 100644
index 00000000000..8a4bfb74e78
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/900216-1.c
@@ -0,0 +1,9 @@
+foo (p, a, b)
+     unsigned short *p;
+{
+  unsigned int x;
+
+  x = p[0];
+
+  return (x == 134U);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/900313-1.c b/gcc/testsuite/gcc.c-torture/compile/900313-1.c
new file mode 100644
index 00000000000..f2bc40d7242
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/900313-1.c
@@ -0,0 +1,172 @@
+main ()
+{
+  char *a;
+  foo (alloca (10000));
+  foo (alloca (100000));
+  foo (alloca ((int) &main));
+}
+
+many_par (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
+{
+  char *x;
+  int aa, ba, ca, da, ea, fa, ga, ha, ia, ja, ka, la, ma, na, oa, pa;
+
+  aa = bar ();
+  ba = bar ();
+  ca = bar ();
+  da = bar ();
+  ea = bar ();
+  fa = bar ();
+  ga = bar ();
+  ha = bar ();
+  ia = bar ();
+  ja = bar ();
+  ka = bar ();
+  la = bar ();
+  ma = bar ();
+  na = bar ();
+  oa = bar ();
+  pa = bar ();
+  foobar (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, aa, ba, ca,
+	  da, ea, fa, ga, ha, ia, ja, ka, la, ma, na, oa, pa);
+
+}
+
+foobar (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, aa, ba, ca,
+	da, ea, fa, ga, ha, ia, ja, ka, la, ma, na, oa, pa)
+{
+  int ab, bb, cb, db, eb, fb, gb, hb, ib, jb, kb, lb, mb, nb, ob, pb;
+  int qb, rb, sb, tb, ub, vb, xb, yb;
+
+  ab = bar ();
+  bb = bar ();
+  cb = bar ();
+  db = bar ();
+  eb = bar ();
+  fb = bar ();
+  gb = bar ();
+  hb = bar ();
+  ib = bar ();
+  jb = bar ();
+  kb = bar ();
+  lb = bar ();
+  mb = bar ();
+  nb = bar ();
+  ob = bar ();
+  pb = bar ();
+  qb = bar ();
+  rb = bar ();
+  sb = bar ();
+  tb = bar ();
+  ub = bar ();
+  vb = bar ();
+  xb = bar ();
+  yb = bar ();
+
+  boofar (a);
+  boofar (b);
+  boofar (c);
+  boofar (d);
+  boofar (e);
+  boofar (f);
+  boofar (g);
+  boofar (h);
+  boofar (i);
+  boofar (j);
+  boofar (k);
+  boofar (l);
+  boofar (m);
+  boofar (n);
+  boofar (o);
+  boofar (p);
+  boofar (aa);
+  boofar (ba);
+  boofar (ca);
+  boofar (da);
+  boofar (ea);
+  boofar (fa);
+  boofar (ga);
+  boofar (ha);
+  boofar (ia);
+  boofar (ja);
+  boofar (ka);
+  boofar (la);
+  boofar (ma);
+  boofar (na);
+  boofar (oa);
+  boofar (pa);
+
+  boofar (ab);
+  boofar (bb);
+  boofar (cb);
+  boofar (db);
+  boofar (eb);
+  boofar (fb);
+  boofar (gb);
+  boofar (hb);
+  boofar (ib);
+  boofar (jb);
+  boofar (kb);
+  boofar (lb);
+  boofar (mb);
+  boofar (nb);
+  boofar (ob);
+  boofar (pb);
+
+  boofar (a);
+  boofar (b);
+  boofar (c);
+  boofar (d);
+  boofar (e);
+  boofar (f);
+  boofar (g);
+  boofar (h);
+  boofar (i);
+  boofar (j);
+  boofar (k);
+  boofar (l);
+  boofar (m);
+  boofar (n);
+  boofar (o);
+  boofar (p);
+  boofar (aa);
+  boofar (ba);
+  boofar (ca);
+  boofar (da);
+  boofar (ea);
+  boofar (fa);
+  boofar (ga);
+  boofar (ha);
+  boofar (ia);
+  boofar (ja);
+  boofar (ka);
+  boofar (la);
+  boofar (ma);
+  boofar (na);
+  boofar (oa);
+  boofar (pa);
+
+  boofar (ab);
+  boofar (bb);
+  boofar (cb);
+  boofar (db);
+  boofar (eb);
+  boofar (fb);
+  boofar (gb);
+  boofar (hb);
+  boofar (ib);
+  boofar (jb);
+  boofar (kb);
+  boofar (lb);
+  boofar (mb);
+  boofar (nb);
+  boofar (ob);
+  boofar (pb);
+
+}
+
+test_exit_ignore_stack ()
+{
+  foobar (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/900407-1.c b/gcc/testsuite/gcc.c-torture/compile/900407-1.c
new file mode 100644
index 00000000000..fdf47791cd7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/900407-1.c
@@ -0,0 +1,10 @@
+foo (a, b, p)
+     int *p;
+{
+  int c;
+  p[1] = a + 0x1000;
+  c = b + 0xffff0000;
+  if ((b + 0xffff0000) == 0)
+    c++;
+  p[2] = c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/900516-1.c b/gcc/testsuite/gcc.c-torture/compile/900516-1.c
new file mode 100644
index 00000000000..69e96144745
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/900516-1.c
@@ -0,0 +1 @@
+f(c){return!(c?2.0:1.0);}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920301-1.c b/gcc/testsuite/gcc.c-torture/compile/920301-1.c
new file mode 100644
index 00000000000..c4d663eb8a7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920301-1.c
@@ -0,0 +1,4 @@
+#ifndef NO_LABEL_VALUES
+f(){static void*t[]={&&x};x:;}
+#endif
+g(){static unsigned p[5];}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920409-1.c b/gcc/testsuite/gcc.c-torture/compile/920409-1.c
new file mode 100644
index 00000000000..b96ec53d595
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920409-1.c
@@ -0,0 +1 @@
+x(){int y;y>0.0?y:y-1;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920409-2.c b/gcc/testsuite/gcc.c-torture/compile/920409-2.c
new file mode 100644
index 00000000000..ef2bdb8b7e7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920409-2.c
@@ -0,0 +1,2 @@
+double x(){int x1,x2;double v;
+if(((long)(x1-x2))<1)return -1.0;v=t(v);v=y(1,v>0.0?(int)v:((int)v-1));}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920410-1.c b/gcc/testsuite/gcc.c-torture/compile/920410-1.c
new file mode 100644
index 00000000000..4bfa7a665a3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920410-1.c
@@ -0,0 +1,30 @@
+int alloc_float(f)
+ float f;
+{  union
+    {
+      float f;
+      int i;
+    }
+  u;
+  u.f=f;
+  return u.i&~1;
+}
+
+float c_float(int obj)
+{  union
+    {
+      float f;
+      int i;
+    } u;
+
+  u.i=obj;
+  return u.f;
+}
+
+main()
+{ int x=alloc_float(1.2);
+  int y=alloc_float(5.7);
+  int z=alloc_float(c_float(x)*c_float(y));
+
+  printf("%g\n",(double)c_float(z));
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920410-2.c b/gcc/testsuite/gcc.c-torture/compile/920410-2.c
new file mode 100644
index 00000000000..958aae9cb0f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920410-2.c
@@ -0,0 +1,12 @@
+joe()
+{
+  int j;
+
+  while( 1 )
+    {
+      for( j = 0; j < 4; j++ )
+	;
+      for( j = 0; j < 4; j++ )
+	;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920411-2.c b/gcc/testsuite/gcc.c-torture/compile/920411-2.c
new file mode 100644
index 00000000000..0cc13c8436a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920411-2.c
@@ -0,0 +1 @@
+x(){int n;double x;n=x<1?n:n+1;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920413-1.c b/gcc/testsuite/gcc.c-torture/compile/920413-1.c
new file mode 100644
index 00000000000..45b5fc5d09c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920413-1.c
@@ -0,0 +1,2 @@
+union u {double d;long long ll;};
+f(double x, int n){union u v;v.d=x;if(n>=0){v.ll<<=63;}else{v.ll+=1<<-n;v.ll>>=-n;}return v.ll;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920415-1.c b/gcc/testsuite/gcc.c-torture/compile/920415-1.c
new file mode 100644
index 00000000000..8d9bc065349
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920415-1.c
@@ -0,0 +1,17 @@
+#ifndef NO_LABEL_VALUES
+f ()
+{
+  __label__ l;
+  void *x()
+    {
+      return &&l;
+    }
+  goto *x ();
+  abort ();
+  return;
+ l:
+  exit (0);
+}
+#else
+int x;
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compile/920428-1.c b/gcc/testsuite/gcc.c-torture/compile/920428-1.c
new file mode 100644
index 00000000000..fdc478a382c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920428-1.c
@@ -0,0 +1 @@
+x(){char*q;return(long)q>>8&0xff;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920428-2.c b/gcc/testsuite/gcc.c-torture/compile/920428-2.c
new file mode 100644
index 00000000000..23f32a83a9d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920428-2.c
@@ -0,0 +1,531 @@
+double sin(double x);
+double cos(double x);
+double tan(double x);
+double asin(double x);
+double acos(double x);
+double atan(double x);
+double atan2(double y, double x);
+double sinh(double x);
+double cosh(double x);
+double tanh(double x);
+double exp(double x);
+double expm1(double x);
+double log(double x);
+double log10(double x);
+double log1p(double x);
+double pow(double x, double y);
+double sqrt(double x);
+double cbrt(double x);
+double ceil(double x);
+double floor(double x);
+double fabs(double x);
+double frexp(double value, int *eptr);
+double ldexp(double value, int exp);
+double modf(double value, double *iptr);
+double erf(double x);
+double erfc(double x);
+double atof(const char *nptr);
+double hypot(double x, double y);
+double lgamma(double x);
+double j0(double x);
+double j1(double x);
+double jn(int n, double x);
+double y0(double x);
+double y1(double x);
+double yn(int n, double x);
+extern struct _iobuf {
+ int _cnt;
+ char *_ptr;
+ char *_base;
+ int _bufsiz;
+ short _flag;
+ char _file;
+} _iob[];
+typedef unsigned long size_t;
+typedef char *va_list;
+struct _iobuf *fopen(const char *filename, const char *type);
+struct _iobuf *freopen(const char *filename, const char *type, struct _iobuf *stream);
+struct _iobuf *fdopen(int fildes, const char *type);
+struct _iobuf *popen(const char *command, const char *type);
+int pclose(struct _iobuf *stream);
+int fflush(struct _iobuf *stream);
+int fclose(struct _iobuf *stream);
+int remove(const char *path);
+int rename(const char *from, const char *to);
+struct _iobuf *tmpfile(void);
+char *tmpnam(char *s);
+int setvbuf(struct _iobuf *iop, char *buf, int type, size_t size);
+int setbuf(struct _iobuf *stream, char *buf);
+int setbuffer(struct _iobuf *stream, char *buf, size_t size);
+int setlinebuf(struct _iobuf *stream);
+int fprintf(struct _iobuf *stream, const char *format, ...);
+int printf(const char *format, ...);
+char *sprintf(char *s, const char *format, ...);
+int vfprintf(struct _iobuf *stream, const char *format, va_list arg);
+int vprintf(const char *format, va_list arg);
+int vsprintf(char *s, const char *format, va_list arg);
+int fscanf(struct _iobuf *stream, const char *format, ...);
+int scanf(const char *format, ...);
+int sscanf(char *s, const char *format, ...);
+int fgetc(struct _iobuf *stream);
+int getw(struct _iobuf *stream);
+char *fgets(char *s, int n, struct _iobuf *stream);
+char *gets(char *s);
+int fputc(int c, struct _iobuf *stream);
+int putw(int w, struct _iobuf *stream);
+int fputs(const char *s, struct _iobuf *stream);
+int puts(const char *s);
+int ungetc(int c, struct _iobuf *stream);
+int fread(void *ptr, size_t size, size_t count, struct _iobuf *iop);
+int fwrite(const void *ptr, size_t size, size_t count, struct _iobuf *iop);
+int fseek(struct _iobuf *stream, long offset, int ptrname);
+long ftell(struct _iobuf *stream);
+void rewind(struct _iobuf *stream);
+int fgetpos(struct _iobuf *stream, long *pos);
+int fsetpos(struct _iobuf *stream, const long *pos);
+void perror(const char *s);
+typedef unsigned char byte;
+typedef unsigned char uchar;
+typedef unsigned short ushort;
+typedef unsigned int uint;
+typedef unsigned long ulong;
+typedef unsigned char u_char;
+typedef unsigned short u_short;
+typedef unsigned int u_int;
+typedef unsigned long u_long;
+typedef unsigned short ushort_;
+typedef struct _physadr { int r[1]; } *physadr;
+typedef struct label_t {
+ int val[11];
+} label_t;
+typedef struct _quad { long val[2]; } quad;
+typedef long daddr_t;
+typedef char * caddr_t;
+typedef u_long ino_t;
+typedef long swblk_t;
+typedef long time_t;
+typedef short dev_t;
+typedef long off_t;
+typedef u_short uid_t;
+typedef u_short gid_t;
+typedef signed char prio_t;
+typedef long fd_mask;
+typedef struct fd_set {
+ fd_mask fds_bits[(((256 )+(( (sizeof(fd_mask) * 8 ) )-1))/( (sizeof(fd_mask) * 8 ) )) ];
+} fd_set;
+typedef struct qhdr {
+ struct qhdr *link, *rlink;
+} *queue_t;
+typedef char *ptr_ord_t;
+typedef double floatp;
+typedef char *(*proc_alloc_t)(unsigned num_elements, unsigned element_size, const char *client_name );
+typedef void (*proc_free_t)(char *data, unsigned num_elements, unsigned element_size, const char *client_name );
+extern struct _iobuf *gs_out;
+typedef struct gs_point_s {
+ double x, y;
+} gs_point;
+typedef struct gs_int_point_s {
+ int x, y;
+} gs_int_point;
+typedef struct gs_rect_s {
+ gs_point p, q;
+} gs_rect;
+typedef struct gs_int_rect_s {
+ gs_int_point p, q;
+} gs_int_rect;
+typedef struct gs_state_s gs_state;
+typedef struct {
+ proc_alloc_t alloc;
+ proc_free_t free;
+} gs_memory_procs;
+char *gs_malloc(uint, uint, const char * );
+void gs_free(char *, uint, uint, const char * );
+extern char gs_debug[128];
+extern int gs_log_error(int, const char *, int );
+typedef long fixed;
+typedef struct gs_fixed_point_s {
+ fixed x, y;
+} gs_fixed_point;
+typedef struct gs_fixed_rect_s {
+ gs_fixed_point p, q;
+} gs_fixed_rect;
+typedef struct gs_matrix_s {
+ long _xx; float xx; long _xy; float xy; long _yx; float yx; long _yy; float yy; long _tx; float tx; long _ty; float ty;
+} gs_matrix;
+void gs_make_identity(gs_matrix * );
+int gs_make_translation(floatp, floatp, gs_matrix * ),
+ gs_make_scaling(floatp, floatp, gs_matrix * ),
+ gs_make_rotation(floatp, gs_matrix * );
+int gs_matrix_multiply(const gs_matrix *, const gs_matrix *, gs_matrix * ),
+ gs_matrix_invert(const gs_matrix *, gs_matrix * ),
+ gs_matrix_rotate(const gs_matrix *, floatp, gs_matrix * );
+int gs_point_transform(floatp, floatp, const gs_matrix *, gs_point * ),
+ gs_point_transform_inverse(floatp, floatp, const gs_matrix *, gs_point * ),
+ gs_distance_transform(floatp, floatp, const gs_matrix *, gs_point * ),
+ gs_distance_transform_inverse(floatp, floatp, const gs_matrix *, gs_point * ),
+ gs_bbox_transform_inverse(gs_rect *, gs_matrix *, gs_rect * );
+typedef struct gs_matrix_fixed_s {
+ long _xx; float xx; long _xy; float xy; long _yx; float yx; long _yy; float yy; long _tx; float tx; long _ty; float ty;
+ fixed tx_fixed, ty_fixed;
+} gs_matrix_fixed;
+extern void gs_update_matrix_fixed(gs_matrix_fixed * );
+int gs_point_transform2fixed(gs_matrix_fixed *, floatp, floatp, gs_fixed_point * ),
+ gs_distance_transform2fixed(gs_matrix_fixed *, floatp, floatp, gs_fixed_point * );
+typedef struct {
+ long xx, xy, yx, yy;
+ int skewed;
+ int shift;
+ int max_bits;
+ fixed round;
+} fixed_coeff;
+
+typedef enum {
+ gs_cap_butt = 0,
+ gs_cap_round = 1,
+ gs_cap_square = 2
+} gs_line_cap;
+typedef enum {
+ gs_join_miter = 0,
+ gs_join_round = 1,
+ gs_join_bevel = 2
+} gs_line_join;
+gs_state *gs_state_alloc(proc_alloc_t, proc_free_t );
+int gs_state_free(gs_state * );
+int gs_gsave(gs_state * ),
+ gs_grestore(gs_state * ),
+ gs_grestoreall(gs_state * );
+gs_state *gs_gstate(gs_state * );
+int gs_currentgstate(gs_state * , const gs_state * ),
+ gs_setgstate(gs_state * , const gs_state * );
+gs_state *gs_state_swap_saved(gs_state *, gs_state * );
+void gs_state_swap(gs_state *, gs_state * );
+int gs_initgraphics(gs_state * );
+typedef struct gx_device_s gx_device;
+int gs_flushpage(gs_state * );
+int gs_copypage(gs_state * );
+int gs_output_page(gs_state *, int, int );
+int gs_copyscanlines(gx_device *, int, byte *, uint, int *, uint * );
+gx_device * gs_getdevice(int );
+int gs_copydevice(gx_device **, gx_device *, proc_alloc_t );
+int gs_makeimagedevice(gx_device **, gs_matrix *, uint, uint, byte *, int, proc_alloc_t );
+void gs_nulldevice(gs_state * );
+int gs_setdevice(gs_state *, gx_device * );
+gx_device * gs_currentdevice(gs_state * );
+const char * gs_devicename(gx_device * );
+void gs_deviceinitialmatrix(gx_device *, gs_matrix * );
+int gs_closedevice(gx_device * );
+int gs_setlinewidth(gs_state *, floatp );
+float gs_currentlinewidth(const gs_state * );
+int gs_setlinecap(gs_state *, gs_line_cap );
+gs_line_cap gs_currentlinecap(const gs_state * );
+int gs_setlinejoin(gs_state *, gs_line_join );
+gs_line_join gs_currentlinejoin(const gs_state * );
+int gs_setmiterlimit(gs_state *, floatp );
+float gs_currentmiterlimit(const gs_state * );
+int gs_setdash(gs_state *, const float *, uint, floatp );
+uint gs_currentdash_length(const gs_state * );
+int gs_currentdash_pattern(const gs_state *, float * );
+float gs_currentdash_offset(const gs_state * );
+int gs_setflat(gs_state *, floatp );
+float gs_currentflat(const gs_state * );
+int gs_setstrokeadjust(gs_state *, int );
+int gs_currentstrokeadjust(const gs_state * );
+typedef enum {
+ gs_color_space_DeviceGray = 0,
+ gs_color_space_DeviceRGB,
+ gs_color_space_DeviceCMYK
+} gs_color_space;
+typedef struct gs_color_s gs_color;
+extern const uint gs_color_sizeof;
+int gs_setgray(gs_state *, floatp );
+float gs_currentgray(gs_state * );
+int gs_sethsbcolor(gs_state *, floatp, floatp, floatp ),
+ gs_currenthsbcolor(gs_state *, float [3] ),
+ gs_setrgbcolor(gs_state *, floatp, floatp, floatp ),
+ gs_currentrgbcolor(gs_state *, float [3] );
+int gs_currentcolorspace(gs_state *, gs_color_space * );
+typedef float (*gs_transfer_proc)(gs_state *, floatp );
+int gs_settransfer(gs_state *, gs_transfer_proc ),
+ gs_settransfer_remap(gs_state *, gs_transfer_proc, int );
+gs_transfer_proc gs_currenttransfer(gs_state * );
+int gs_setcolortransfer(gs_state *, gs_transfer_proc ,
+ gs_transfer_proc , gs_transfer_proc ,
+ gs_transfer_proc ),
+ gs_setcolortransfer_remap(gs_state *, gs_transfer_proc ,
+ gs_transfer_proc , gs_transfer_proc ,
+ gs_transfer_proc , int );
+void gs_currentcolortransfer(gs_state *, gs_transfer_proc [4] );
+int gs_setscreen(gs_state *, floatp, floatp, float (*)(floatp, floatp ) );
+int gs_currentscreen(gs_state *, float *, float *, float (**)(floatp, floatp ) );
+int gs_sethalftonephase(gs_state *, int, int );
+int gs_currenthalftonephase(gs_state *, gs_int_point * );
+typedef struct gs_screen_enum_s gs_screen_enum;
+extern const uint gs_screen_enum_sizeof;
+int gs_screen_init(gs_screen_enum *, gs_state *, floatp, floatp );
+int gs_screen_currentpoint(gs_screen_enum *, gs_point * );
+int gs_screen_next(gs_screen_enum *, floatp );
+struct gs_state_s {
+ gs_state *saved;
+ gs_memory_procs memory_procs;
+ gs_matrix_fixed ctm;
+ gs_matrix ctm_inverse;
+ int inverse_valid;
+ struct gx_path_s *path;
+ struct gx_clip_path_s *clip_path;
+ int clip_rule;
+ struct line_params_s *line_params;
+ struct halftone_params_s *halftone;
+ float (*ht_proc)(floatp, floatp );
+ gs_int_point ht_phase;
+ gs_int_point phase_mod;
+ struct gs_color_s *color;
+ struct gx_device_color_s *dev_color;
+ struct gx_transfer_s *transfer;
+ struct gs_font_s *font;
+ gs_matrix char_tm;
+ int char_tm_valid;
+ byte in_cachedevice;
+ byte in_charpath;
+
+
+
+
+ int level;
+ float flatness;
+ int stroke_adjust;
+ struct device_s *device;
+ int device_is_shared;
+
+};
+typedef unsigned long gx_bitmap_id;
+typedef struct gx_bitmap_s {
+ byte *data;
+ int raster;
+ gs_int_point size;
+ gx_bitmap_id id;
+ ushort rep_width, rep_height;
+} gx_bitmap;
+typedef unsigned long gx_color_index;
+typedef unsigned short gx_color_value;
+typedef struct gx_device_color_info_s {
+ int num_components;
+
+ int depth;
+ gx_color_value max_gray;
+ gx_color_value max_rgb;
+
+ gx_color_value dither_gray;
+ gx_color_value dither_rgb;
+
+} gx_device_color_info;
+typedef struct gx_device_procs_s gx_device_procs;
+struct gx_device_s {
+ int params_size; gx_device_procs *procs; const char *dname; int width; int height; float x_pixels_per_inch; float y_pixels_per_inch; float l_margin, b_margin, r_margin, t_margin; gx_device_color_info color_info; int is_open;
+};
+typedef struct gs_prop_item_s gs_prop_item;
+struct gx_device_procs_s {
+ int (*open_device)(gx_device *dev );
+ void (*get_initial_matrix)(gx_device *dev, gs_matrix *pmat );
+ int (*sync_output)(gx_device *dev );
+ int (*output_page)(gx_device *dev, int num_copies, int flush );
+ int (*close_device)(gx_device *dev );
+ gx_color_index (*map_rgb_color)(gx_device *dev, gx_color_value red, gx_color_value green, gx_color_value blue );
+ int (*map_color_rgb)(gx_device *dev, gx_color_index color, gx_color_value rgb[3] );
+ int (*fill_rectangle)(gx_device *dev, int x, int y, int width, int height, gx_color_index color );
+ int (*tile_rectangle)(gx_device *dev, gx_bitmap *tile, int x, int y, int width, int height, gx_color_index color0, gx_color_index color1, int phase_x, int phase_y );
+ int (*copy_mono)(gx_device *dev, unsigned char *data, int data_x, int raster, gx_bitmap_id id, int x, int y, int width, int height, gx_color_index color0, gx_color_index color1 );
+ int (*copy_color)(gx_device *dev, unsigned char *data, int data_x, int raster, gx_bitmap_id id, int x, int y, int width, int height );
+ int (*draw_line)(gx_device *dev, int x0, int y0, int x1, int y1, gx_color_index color );
+ int (*get_bits)(gx_device *dev, int y, unsigned char *data, unsigned int size, int pad_to_word );
+ int (*get_props)(gx_device *dev, gs_prop_item *plist );
+
+ int (*put_props)(gx_device *dev, gs_prop_item *plist, int count );
+
+};
+extern unsigned int gx_device_bytes_per_scan_line(gx_device *dev, int pad_to_word );
+int gx_default_open_device(gx_device *dev );
+void gx_default_get_initial_matrix(gx_device *dev, gs_matrix *pmat );
+int gx_default_sync_output(gx_device *dev );
+int gx_default_output_page(gx_device *dev, int num_copies, int flush );
+int gx_default_close_device(gx_device *dev );
+gx_color_index gx_default_map_rgb_color(gx_device *dev, gx_color_value red, gx_color_value green, gx_color_value blue );
+int gx_default_map_color_rgb(gx_device *dev, gx_color_index color, gx_color_value rgb[3] );
+int gx_default_tile_rectangle(gx_device *dev, gx_bitmap *tile, int x, int y, int width, int height, gx_color_index color0, gx_color_index color1, int phase_x, int phase_y );
+int gx_default_copy_color(gx_device *dev, unsigned char *data, int data_x, int raster, gx_bitmap_id id, int x, int y, int width, int height );
+int gx_default_draw_line(gx_device *dev, int x0, int y0, int x1, int y1, gx_color_index color );
+int gx_default_get_bits(gx_device *dev, int y, unsigned char *data, unsigned int size, int pad_to_word );
+int gx_default_get_props(gx_device *dev, gs_prop_item *plist );
+int gx_default_put_props(gx_device *dev, gs_prop_item *plist, int count );
+typedef struct device_s {
+ gx_device *info;
+ int is_band_device;
+ gx_color_index white, black;
+} device;
+int gs_initmatrix(gs_state * ),
+ gs_defaultmatrix(const gs_state *, gs_matrix * ),
+ gs_currentmatrix(const gs_state *, gs_matrix * ),
+ gs_setmatrix(gs_state *, const gs_matrix * ),
+ gs_translate(gs_state *, floatp, floatp ),
+ gs_scale(gs_state *, floatp, floatp ),
+ gs_rotate(gs_state *, floatp ),
+ gs_concat(gs_state *, const gs_matrix * );
+int gs_transform(gs_state *, floatp, floatp, gs_point * ),
+ gs_dtransform(gs_state *, floatp, floatp, gs_point * ),
+ gs_itransform(gs_state *, floatp, floatp, gs_point * ),
+ gs_idtransform(gs_state *, floatp, floatp, gs_point * );
+static int
+ctm_set_inverse(gs_state *pgs)
+{ int code = gs_matrix_invert(&*(gs_matrix *)&(pgs)->ctm , &pgs->ctm_inverse);
+ 0;
+ if ( code < 0 ) return code;
+ pgs->inverse_valid = 1;
+ return 0;
+}
+void
+gs_update_matrix_fixed(gs_matrix_fixed *pmat)
+{ (*pmat). tx = ((float)(((*pmat). tx_fixed = ((fixed)(((*pmat). tx)*(float)(1<<12 ) )) )*(1.0/(1<<12 ) ))) , (*pmat). ty = ((float)(((*pmat). ty_fixed = ((fixed)(((*pmat). ty)*(float)(1<<12 ) )) )*(1.0/(1<<12 ) )));
+}
+int
+gs_initmatrix(gs_state *pgs)
+{ gx_device *dev = pgs->device->info;
+ (*dev->procs->get_initial_matrix)(dev, &*(gs_matrix *)&(pgs)->ctm );
+ (pgs->ctm). tx = ((float)(((pgs->ctm). tx_fixed = ((fixed)(((pgs->ctm). tx)*(float)(1<<12 ) )) )*(1.0/(1<<12 ) ))) , (pgs->ctm). ty = ((float)(((pgs->ctm). ty_fixed = ((fixed)(((pgs->ctm). ty)*(float)(1<<12 ) )) )*(1.0/(1<<12 ) ))) , pgs->inverse_valid = 0, pgs->char_tm_valid = 0;
+ return 0;
+}
+int
+gs_defaultmatrix(const gs_state *pgs, gs_matrix *pmat)
+{ gx_device *dev = pgs->device->info;
+ (*dev->procs->get_initial_matrix)(dev, pmat);
+ return 0;
+}
+int
+gs_currentmatrix(const gs_state *pgs, gs_matrix *pmat)
+{ *pmat = *(gs_matrix *)&(pgs)->ctm;
+ return 0;
+}
+int
+gs_setmatrix(gs_state *pgs, const gs_matrix *pmat)
+{ *(gs_matrix *)&(pgs)->ctm = *pmat;
+ (pgs->ctm). tx = ((float)(((pgs->ctm). tx_fixed = ((fixed)(((pgs->ctm). tx)*(float)(1<<12 ) )) )*(1.0/(1<<12 ) ))) , (pgs->ctm). ty = ((float)(((pgs->ctm). ty_fixed = ((fixed)(((pgs->ctm). ty)*(float)(1<<12 ) )) )*(1.0/(1<<12 ) ))) , pgs->inverse_valid = 0, pgs->char_tm_valid = 0;
+ return 0;
+}
+int
+gs_translate(gs_state *pgs, floatp dx, floatp dy)
+{ gs_point pt;
+ int code;
+ if ( (code = gs_distance_transform(dx, dy, &*(gs_matrix *)&(pgs)->ctm , &pt)) < 0 )
+ return code;
+ pgs->ctm.tx += pt.x;
+ pgs->ctm.ty += pt.y;
+ (pgs->ctm). tx = ((float)(((pgs->ctm). tx_fixed = ((fixed)(((pgs->ctm). tx)*(float)(1<<12 ) )) )*(1.0/(1<<12 ) ))) , (pgs->ctm). ty = ((float)(((pgs->ctm). ty_fixed = ((fixed)(((pgs->ctm). ty)*(float)(1<<12 ) )) )*(1.0/(1<<12 ) ))) , pgs->inverse_valid = 0, pgs->char_tm_valid = 0;
+ return 0;
+}
+int
+gs_scale(gs_state *pgs, floatp sx, floatp sy)
+{ pgs->ctm.xx *= sx;
+ pgs->ctm.xy *= sx;
+ pgs->ctm.yx *= sy;
+ pgs->ctm.yy *= sy;
+ pgs->inverse_valid = 0, pgs->char_tm_valid = 0;
+ return 0;
+}
+int
+gs_rotate(gs_state *pgs, floatp ang)
+{ int code = gs_matrix_rotate(&*(gs_matrix *)&(pgs)->ctm , ang, &*(gs_matrix *)&(pgs)->ctm );
+ pgs->inverse_valid = 0, pgs->char_tm_valid = 0;
+ return code;
+}
+int
+gs_concat(gs_state *pgs, const gs_matrix *pmat)
+{ int code = gs_matrix_multiply(pmat, &*(gs_matrix *)&(pgs)->ctm , &*(gs_matrix *)&(pgs)->ctm );
+ (pgs->ctm). tx = ((float)(((pgs->ctm). tx_fixed = ((fixed)(((pgs->ctm). tx)*(float)(1<<12 ) )) )*(1.0/(1<<12 ) ))) , (pgs->ctm). ty = ((float)(((pgs->ctm). ty_fixed = ((fixed)(((pgs->ctm). ty)*(float)(1<<12 ) )) )*(1.0/(1<<12 ) ))) , pgs->inverse_valid = 0, pgs->char_tm_valid = 0;
+ return code;
+}
+int
+gs_transform(gs_state *pgs, floatp x, floatp y, gs_point *pt)
+{ return gs_point_transform(x, y, &*(gs_matrix *)&(pgs)->ctm , pt);
+}
+int
+gs_dtransform(gs_state *pgs, floatp dx, floatp dy, gs_point *pt)
+{ return gs_distance_transform(dx, dy, &*(gs_matrix *)&(pgs)->ctm , pt);
+}
+int
+gs_itransform(gs_state *pgs, floatp x, floatp y, gs_point *pt)
+{
+
+ if ( !!(((*(long *)(&((&pgs->ctm)->xy)) | *(long *)(&( (&pgs->ctm)->yx)) ) << 1) == 0) )
+ { return gs_point_transform_inverse(x, y, &*(gs_matrix *)&(pgs)->ctm , pt);
+ }
+ else
+ { if ( !pgs->inverse_valid ) { int code = ctm_set_inverse(pgs); if ( code < 0 ) return code; };
+ return gs_point_transform(x, y, &pgs->ctm_inverse, pt);
+ }
+}
+int
+gs_idtransform(gs_state *pgs, floatp dx, floatp dy, gs_point *pt)
+{
+
+ if ( !!(((*(long *)(&((&pgs->ctm)->xy)) | *(long *)(&( (&pgs->ctm)->yx)) ) << 1) == 0) )
+ { return gs_distance_transform_inverse(dx, dy,
+ &*(gs_matrix *)&(pgs)->ctm , pt);
+ }
+ else
+ { if ( !pgs->inverse_valid ) { int code = ctm_set_inverse(pgs); if ( code < 0 ) return code; };
+ return gs_distance_transform(dx, dy, &pgs->ctm_inverse, pt);
+ }
+}
+int
+gs_translate_to_fixed(register gs_state *pgs, fixed px, fixed py)
+{ pgs->ctm.tx = ((float)((pgs->ctm.tx_fixed = px)*(1.0/(1<<12 ) )));
+ pgs->ctm.ty = ((float)((pgs->ctm.ty_fixed = py)*(1.0/(1<<12 ) )));
+ pgs->inverse_valid = 0;
+ pgs->char_tm_valid = 1;
+ return 0;
+}
+int
+gx_matrix_to_fixed_coeff(const gs_matrix *pmat, register fixed_coeff *pfc,
+ int max_bits)
+{ gs_matrix ctm;
+ int scale = -10000;
+ int expt, shift;
+ ctm = *pmat;
+ pfc->skewed = 0;
+ if ( !((*(long *)(&(ctm.xx)) << 1) == 0) )
+ { (void)frexp(ctm.xx, &scale);
+ }
+ if ( !((*(long *)(&(ctm.xy)) << 1) == 0) )
+ { (void)frexp(ctm.xy, &expt);
+ if ( expt > scale ) scale = expt;
+ pfc->skewed = 1;
+ }
+ if ( !((*(long *)(&(ctm.yx)) << 1) == 0) )
+ { (void)frexp(ctm.yx, &expt);
+ if ( expt > scale ) scale = expt;
+ pfc->skewed = 1;
+ }
+ if ( !((*(long *)(&(ctm.yy)) << 1) == 0) )
+ { (void)frexp(ctm.yy, &expt);
+ if ( expt > scale ) scale = expt;
+ }
+ scale = sizeof(long) * 8 - 1 - max_bits - scale;
+ shift = scale - 12;
+ if ( shift > 0 )
+ { pfc->shift = shift;
+ pfc->round = (fixed)1 << (shift - 1);
+ }
+ else
+ { pfc->shift = 0;
+ pfc->round = 0;
+ scale -= shift;
+ }
+ pfc->xx = (((*(long *)(&(ctm.xx)) << 1) == 0) ? 0 : (long)ldexp(ctm.xx, scale));
+ pfc->yy = (((*(long *)(&(ctm.yy)) << 1) == 0) ? 0 : (long)ldexp(ctm.yy, scale));
+ if ( pfc->skewed )
+ { pfc->xy = (((*(long *)(&(ctm.xy)) << 1) == 0) ? 0 : (long)ldexp(ctm.xy, scale));
+ pfc->yx = (((*(long *)(&(ctm.yx)) << 1) == 0) ? 0 : (long)ldexp(ctm.yx, scale));
+ }
+ else
+ pfc->xy = pfc->yx = 0;
+ pfc->max_bits = max_bits;
+ return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920428-3.c b/gcc/testsuite/gcc.c-torture/compile/920428-3.c
new file mode 100644
index 00000000000..13640c98ad2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920428-3.c
@@ -0,0 +1,5 @@
+#ifndef NO_LABEL_VALUES
+x(a){static void*j[]={&&l1,&&l2};goto*j[a];l1:return 0;l2:return 1;}
+#else
+main(){ exit (0); }
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compile/920428-4.c b/gcc/testsuite/gcc.c-torture/compile/920428-4.c
new file mode 100644
index 00000000000..cc5e30c2a80
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920428-4.c
@@ -0,0 +1 @@
+x(a){struct{int p[a],i;}l;l.i;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920428-5.c b/gcc/testsuite/gcc.c-torture/compile/920428-5.c
new file mode 100644
index 00000000000..ff313799280
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920428-5.c
@@ -0,0 +1 @@
+typedef struct{unsigned b0:1;}*t;x(a,b)t a,b;{b->b0=a->b0;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920428-6.c b/gcc/testsuite/gcc.c-torture/compile/920428-6.c
new file mode 100644
index 00000000000..e43af7ed3a7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920428-6.c
@@ -0,0 +1,22 @@
+typedef struct x
+{
+  struct x *type;
+  struct x *chain;
+  struct x *value;
+} *tree;
+
+int
+func (new, old)
+     register tree new, old;
+{
+  if (old->type == 0 || new->type == 0)
+    {
+      register tree t = old->type;
+      if (t == 0)
+	t = new->type;
+      for (; t; t = t->chain )
+	if (t->value)
+	  return 1;
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920428-7.c b/gcc/testsuite/gcc.c-torture/compile/920428-7.c
new file mode 100644
index 00000000000..69b1d979aa9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920428-7.c
@@ -0,0 +1 @@
+x(float*x){int a[4],i=0,j;for(j=0;j<2;j++){f(a[i++]);f(a[i++]);}}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-1.c b/gcc/testsuite/gcc.c-torture/compile/920501-1.c
new file mode 100644
index 00000000000..a84956417b0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-1.c
@@ -0,0 +1,7 @@
+/* CYGNUS LOCAL -- meissner/no label values */
+#ifndef NO_LABEL_VALUES
+a(){int**b[]={&&c};c:;}
+#else
+int x;
+#endif
+/* END CYGNUS LOCAL -- meissner/no label values */
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-10.c b/gcc/testsuite/gcc.c-torture/compile/920501-10.c
new file mode 100644
index 00000000000..ecb5bb4151c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-10.c
@@ -0,0 +1 @@
+x(y){return 8193*y;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-11.c b/gcc/testsuite/gcc.c-torture/compile/920501-11.c
new file mode 100644
index 00000000000..d636357e867
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-11.c
@@ -0,0 +1 @@
+typedef struct{int s;}S;foo(){int i=(int)&(S){(void*)((int)&(S){1})};}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-12.c b/gcc/testsuite/gcc.c-torture/compile/920501-12.c
new file mode 100644
index 00000000000..594e14178b9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-12.c
@@ -0,0 +1,5 @@
+x(x){            return 3 + x;}
+a(x){int y[994]; return 3 + x;}
+b(x){int y[999]; return 2*(x + 3);}
+A(x){int y[9999];return 2*(x + 3);}
+B(x){int y[9949];return 3 + x;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-13.c b/gcc/testsuite/gcc.c-torture/compile/920501-13.c
new file mode 100644
index 00000000000..b5a6798ecc2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-13.c
@@ -0,0 +1 @@
+typedef struct{int i;}t;inline y(t u){}x(){t u;y(u);}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-15.c b/gcc/testsuite/gcc.c-torture/compile/920501-15.c
new file mode 100644
index 00000000000..81fd66401d5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-15.c
@@ -0,0 +1 @@
+x(a)double a;{int i;return i>a?i:i+1;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-16.c b/gcc/testsuite/gcc.c-torture/compile/920501-16.c
new file mode 100644
index 00000000000..f82b7524b24
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-16.c
@@ -0,0 +1 @@
+f(n){struct z{int a,b[n],c[n];};}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-17.c b/gcc/testsuite/gcc.c-torture/compile/920501-17.c
new file mode 100644
index 00000000000..05a4d408d50
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-17.c
@@ -0,0 +1 @@
+x(){static const char x[]="x";char y[2];y[0]=x[1];}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-18.c b/gcc/testsuite/gcc.c-torture/compile/920501-18.c
new file mode 100644
index 00000000000..70f7c0af505
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-18.c
@@ -0,0 +1,2 @@
+union u{int i;float f;};
+x(p)int p;{union u x;for(x.i=0;x.i<p;x.i++)if(x.f>(float)3.0)break;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-19.c b/gcc/testsuite/gcc.c-torture/compile/920501-19.c
new file mode 100644
index 00000000000..1671cc37e68
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-19.c
@@ -0,0 +1 @@
+long long x=0;y(){x=0;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-2.c b/gcc/testsuite/gcc.c-torture/compile/920501-2.c
new file mode 100644
index 00000000000..905f5ddb627
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-2.c
@@ -0,0 +1,11 @@
+extern short distdata[64][64], taxidata[64][64];
+extern short PieceList[2][64];
+
+int
+ScoreKBNK (short int winner, short int king1, short int king2)
+{
+  register short s;
+
+  s = taxidata[king1][king2] + distdata[PieceList[winner][1]][king2];
+  return s;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-20.c b/gcc/testsuite/gcc.c-torture/compile/920501-20.c
new file mode 100644
index 00000000000..170d0501761
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-20.c
@@ -0,0 +1 @@
+int*f(x)int*x;{if(x[4]){int h[1];if(setjmp(h))return x;}}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-21.c b/gcc/testsuite/gcc.c-torture/compile/920501-21.c
new file mode 100644
index 00000000000..4a9f05a1b20
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-21.c
@@ -0,0 +1,3 @@
+typedef unsigned short t;
+struct foo{t d;};
+int bar(d)t d;{struct foo u;u.d=d;return(int)(&u);}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-22.c b/gcc/testsuite/gcc.c-torture/compile/920501-22.c
new file mode 100644
index 00000000000..b15d7984b1b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-22.c
@@ -0,0 +1 @@
+x(){int y[]={};}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-23.c b/gcc/testsuite/gcc.c-torture/compile/920501-23.c
new file mode 100644
index 00000000000..291d93e6c5d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-23.c
@@ -0,0 +1,16 @@
+typedef unsigned char qi;
+typedef unsigned short hi;
+typedef unsigned long si;
+typedef unsigned long long di;
+subi(a){return 100-a;}
+add(a,b){return a+b;}
+mul(a){return 85*a;}
+memshift(p)unsigned*p;{unsigned x;for(;;){x=*p++>>16;if(x)return x;}}
+ldw(xp)si*xp;{return xp[4];}
+ldws_m(xp)si*xp;{si x;do{x=xp[3];xp+=3;}while(x);}
+postinc_si(p)si*p;{si x;for(;;){x=*p++;if(x)return x;}}
+preinc_si(p)si*p;{si x;for(;;){x=*++p;if(x)return x;}}
+postinc_di(p)di*p;{di x;for(;;){x=*p++;if(x)return x;}}
+preinc_di(p)di*p;{di x;for(;;){x=*++p;if(x)return x;}}
+inc_overlap(p,a)di*p;{do{p=*(di**)p;p=(di*)((int)p+4);}while(*p);}
+di move_di(p,p2)di*p,*p2;{di x=p;p2=((di*)x)[1];return p2[1];}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-3.c b/gcc/testsuite/gcc.c-torture/compile/920501-3.c
new file mode 100644
index 00000000000..41ef87fbf7f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-3.c
@@ -0,0 +1,2 @@
+struct{long long x:24,y:40;}v;
+x(){v.y=0;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-4.c b/gcc/testsuite/gcc.c-torture/compile/920501-4.c
new file mode 100644
index 00000000000..9cd2fd7bd7a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-4.c
@@ -0,0 +1,49 @@
+foo ()
+{
+  int r0[8186 ];
+  int r1[2 ];
+  int r2[2 ];
+  int bitm0[2 ];
+  int bitm1[2 ];
+  int bitm2[2 ];
+
+  int i,j,k,m,n,m_max;
+  int f;
+  double fm,ft;
+
+  while (1) {
+
+    if (m%4 == 2)
+      ++m;
+
+    if (m_max != 0 && m > m_max)
+      break;
+
+    fm=m;
+
+    r0[k=1]=0;
+    bitm0[0] = 0;
+
+      while ( n%f == 0 ) {
+	while ( (ft != 0) && (ft < fm )) {
+	  bitm1[i] = 0;
+	  r1[i]=0;
+          }
+
+	while ( r0[i] != 0 && r1[i] != 0 ) {
+	  if ( r0[i] < r1[i] ) {
+	    bitm2[k] = bitm0[i];
+	    r2[k++]=0;
+	  }
+	  else if ( r0[i] > r1[j] ) {
+	    bitm2[k] = bitm1[j];
+	    r2[k++]=r1[j++];
+	  }
+	  else {
+	    bitm1[k] = bitm0[i];
+	    r2[k++]=r0[i++];
+	  }
+	}
+      }
+  }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-6.c b/gcc/testsuite/gcc.c-torture/compile/920501-6.c
new file mode 100644
index 00000000000..d0a406381ff
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-6.c
@@ -0,0 +1 @@
+x(y,z)float*y;{*y=z;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-7.c b/gcc/testsuite/gcc.c-torture/compile/920501-7.c
new file mode 100644
index 00000000000..ee193f78a4a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-7.c
@@ -0,0 +1,7 @@
+/* CYGNUS LOCAL -- meissner/no label values */
+#ifndef NO_LABEL_VALUES
+x(){if(&&e-&&b<0)x();b:goto*&&b;e:;}
+#else
+int x;
+#endif
+/* END CYGNUS LOCAL -- meissner/no label values */
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-8.c b/gcc/testsuite/gcc.c-torture/compile/920501-8.c
new file mode 100644
index 00000000000..68e33934d21
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-8.c
@@ -0,0 +1 @@
+x(int*p){int x=p;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920501-9.c b/gcc/testsuite/gcc.c-torture/compile/920501-9.c
new file mode 100644
index 00000000000..98a06000bf2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920501-9.c
@@ -0,0 +1 @@
+short x(a)unsigned a;{a=32987799;return a;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920502-1.c b/gcc/testsuite/gcc.c-torture/compile/920502-1.c
new file mode 100644
index 00000000000..b576c6c990c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920502-1.c
@@ -0,0 +1 @@
+extern void*t[];x(i){goto*t[i];}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920502-2.c b/gcc/testsuite/gcc.c-torture/compile/920502-2.c
new file mode 100644
index 00000000000..d3aa1e26d81
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920502-2.c
@@ -0,0 +1 @@
+x(c){1LL<<c;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920529-1.c b/gcc/testsuite/gcc.c-torture/compile/920529-1.c
new file mode 100644
index 00000000000..0f50309a27c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920529-1.c
@@ -0,0 +1,21 @@
+void
+f (a, b, m, n)
+     unsigned short *a, *b;
+     int m, n;
+{
+  unsigned long acc;
+  int qn;
+  int j;
+
+  abort ();
+
+  acc = a[m - 1];
+  a += 0;
+  for (j = qn - 1; j >= 0; j = j - 1)
+    {
+      acc = (acc << 16) | a[j];
+      acc = acc % *b;
+    }
+
+  return;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920611-2.c b/gcc/testsuite/gcc.c-torture/compile/920611-2.c
new file mode 100644
index 00000000000..e54b1cda5fc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920611-2.c
@@ -0,0 +1,53 @@
+typedef unsigned char uchar;
+typedef unsigned short ushort;
+typedef unsigned int uint;
+typedef unsigned long ulong;
+
+static unsigned long S[1][1]={0x00820200};
+
+static int body(out0,out1,ks,Eswap0,Eswap1)
+ulong *out0,*out1;
+int *ks;
+ulong Eswap0,Eswap1;
+{
+  register unsigned long l,r,t,u,v;
+  register unsigned long *s;
+  register int i,j;
+  register unsigned long E0,E1;
+
+  l=0;
+  r=0;
+
+  s=(ulong *)ks;
+  E0=Eswap0;
+  E1=Eswap1;
+
+  for (i=0; i<(16 *2); i+=4)
+    {
+      v=(r^(r>>16));
+      u=(v&E0);
+      v=(v&E1);
+      u=(u^(u<<16))^r^s[  i  ];
+      t=(v^(v<<16))^r^s[  i+1];
+      t=(t>>4)|(t<<28);
+      l^=S[1][(t)&0x3f]| S[3][(t>> 8)&0x3f]| S[5][(t>>16)&0x3f]| S[7][(t>>24)&0x3f]| S[0][(u)&0x3f]| S[2][(u>> 8)&0x3f]| S[4][(u>>16)&0x3f]| S[6][(u>>24)&0x3f];
+      v=(l^(l>>16));
+      u=(v&E0);
+      v=(v&E1);
+      u=(u^(u<<16))^l^s[  i+2  ];
+      t=(v^(v<<16))^l^s[  i+2+1];
+      t=(t>>4)|(t<<28);
+      r^=	S[1][(t    )&0x3f];
+    }
+  t=l;
+  l=r;
+  r=t;
+
+  t=r;
+  r=(l>>1)|(l<<31);
+  l=(t>>1)|(t<<31);
+
+  *out0=l;
+  *out1=r;
+  return(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920615-1.c b/gcc/testsuite/gcc.c-torture/compile/920615-1.c
new file mode 100644
index 00000000000..9b1c6aceef3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920615-1.c
@@ -0,0 +1,4 @@
+f()
+{
+  int x[20] = {[0] = 5, [10] = 12};
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920617-1.c b/gcc/testsuite/gcc.c-torture/compile/920617-1.c
new file mode 100644
index 00000000000..2d84e8d84f8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920617-1.c
@@ -0,0 +1 @@
+f(){double*xp,y;*xp++=sqrt(y);}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920617-2.c b/gcc/testsuite/gcc.c-torture/compile/920617-2.c
new file mode 100644
index 00000000000..3a5450982c0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920617-2.c
@@ -0,0 +1 @@
+f(a,b,c,d)float a[],d;int b[],c;{}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920623-1.c b/gcc/testsuite/gcc.c-torture/compile/920623-1.c
new file mode 100644
index 00000000000..9b6ad51e102
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920623-1.c
@@ -0,0 +1,2 @@
+int f(int c){return f(c--);}
+g(){}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920624-1.c b/gcc/testsuite/gcc.c-torture/compile/920624-1.c
new file mode 100644
index 00000000000..8b4d2979d26
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920624-1.c
@@ -0,0 +1,2 @@
+int B[],Q[];
+f(){int s;for(s=0;s<=1;s++)switch(s){case 2:case 3:++B[s];case 4:case 5:++Q[s];}}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920625-1.c b/gcc/testsuite/gcc.c-torture/compile/920625-1.c
new file mode 100644
index 00000000000..720d43fd42f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920625-1.c
@@ -0,0 +1,279 @@
+typedef unsigned long int unsigned_word;
+typedef signed long int signed_word;
+typedef unsigned_word word;
+
+typedef enum { ADD, ADD_CI, ADD_CO, ADD_CIO, SUB, SUB_CI, SUB_CO,
+SUB_CIO, ADC_CI, ADC_CO, ADC_CIO, AND, IOR, XOR, ANDC, IORC, EQV,
+NAND, NOR, AND_RC, IOR_RC, XOR_RC, ANDC_RC, IORC_RC, EQV_RC, NAND_RC,
+NOR_RC, AND_CC, IOR_CC, XOR_CC, ANDC_CC, IORC_CC, EQV_CC, NAND_CC,
+NOR_CC, LSHIFTR, ASHIFTR, SHIFTL, LSHIFTR_CO, ASHIFTR_CO, SHIFTL_CO,
+ROTATEL, ROTATEL_CO, ROTATEXL_CIO, ASHIFTR_CON, EXTS1, EXTS2, EXTU1,
+EXTU2, CLZ, CTZ, FF1, FF0, ABSVAL, NABSVAL, CMP, CPEQ, CPGE, CPGEU,
+CPGT, CPGTU, CPLE, CPLEU, CPLT, CPLTU, CPNEQ, CMPPAR, DOZ, COPY,
+EXCHANGE, COMCY, } opcode_t;
+
+typedef struct
+{
+  opcode_t opcode:8;
+  unsigned int s1:8;
+  unsigned int s2:8;
+  unsigned int d:8;
+} insn_t;
+
+enum prune_flags
+{
+  NO_PRUNE = 0,
+  CY_0 = 1,
+  CY_1 = 2,
+  CY_JUST_SET = 4,
+};
+
+int flag_use_carry = 1;
+
+inline
+recurse(opcode_t opcode,
+ int d,
+ int s1,
+ int s2,
+ word v,
+ int cost,
+ insn_t *sequence,
+ int n_insns,
+ word *values,
+ int n_values,
+ const word goal_value,
+ int allowed_cost,
+ int cy,
+ int prune_flags)
+{
+  insn_t insn;
+
+  allowed_cost -= cost;
+
+  if (allowed_cost > 0)
+    {
+      word old_d;
+
+      old_d = values[d];
+      values[d] = v;
+
+      insn.opcode = opcode;
+      insn.s1 = s1;
+      insn.s2 = s2;
+      insn.d = d;
+      sequence[n_insns] = insn;
+
+      synth(sequence, n_insns + 1, values, n_values,
+     goal_value, allowed_cost, cy, prune_flags);
+
+      values[d] = old_d;
+    }
+  else if (goal_value == v)
+    {
+      insn.opcode = opcode;
+      insn.s1 = s1;
+      insn.s2 = s2;
+      insn.d = d;
+      sequence[n_insns] = insn;
+      test_sequence(sequence, n_insns + 1);
+    }
+}
+
+synth(insn_t *sequence,
+      int n_insns,
+      word *values,
+      int n_values,
+      word goal_value,
+      int allowed_cost,
+      int ci,
+      int prune_hint)
+{
+  int s1, s2;
+  word v, r1, r2;
+  int co;
+  int last_dest;
+
+  if (n_insns > 0)
+    last_dest = sequence[n_insns - 1].d;
+  else
+    last_dest = -1;
+  if (ci >= 0 && flag_use_carry)
+    {
+      for (s1 = n_values - 1; s1 >= 0; s1--)
+ {
+   r1 = values[s1];
+   for (s2 = s1 - 1; s2 >= 0; s2--)
+     {
+       r2 = values[s2];
+
+       if (allowed_cost <= 1 && (prune_hint & CY_JUST_SET) == 0)
+  {
+    if (last_dest >= 0 && s1 != last_dest && s2 != last_dest)
+      continue;
+  }
+       do { word __d = ( r1) + ( r2) + (( ci)); ( co) = ( ci) ? __d <= ( r1) : __d < ( r1); (v) = __d; } while (0);
+       recurse(ADD_CIO, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+       do { word __d = ( r1) + ( r2) + (( ci)); ( co) = ( ci); (v) = __d; } while (0);
+       recurse(ADD_CI, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+       do { word __d = ( r1) - ( r2) - (( ci)); ( co) = ( ci) ? __d >= ( r1) : __d > ( r1); (v) = __d; } while (0);
+       recurse(SUB_CIO, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+       do { word __d = ( r2) - ( r1) - (( ci)); ( co) = ( ci) ? __d >= ( r2) : __d > ( r2); (v) = __d; } while (0);
+       recurse(SUB_CIO, n_values,  s2,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+
+       do { word __d = ( r1) - ( r2) - (( ci)); ( co) = ( ci); (v) = __d; } while (0);
+       recurse(SUB_CI, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+       do { word __d = ( r2) - ( r1) - (( ci)); ( co) = ( ci); (v) = __d; } while (0);
+       recurse(SUB_CI, n_values,  s2,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+     }
+ }
+    }
+  for (s1 = n_values - 1; s1 >= 0; s1--)
+    {
+      r1 = values[s1];
+      for (s2 = s1 - 1; s2 >= 0; s2--)
+ {
+   r2 = values[s2];
+
+   if (allowed_cost <= 1)
+     {
+       if (last_dest >= 0 && s1 != last_dest && s2 != last_dest)
+  continue;
+     }
+
+   do { word __d = ( r1) + ( r2); ( co) = __d < ( r1); (v) = __d; } while (0);
+   recurse(ADD_CO, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+
+   ((v) = ( r1) + ( r2), ( co) = ( ci));
+   recurse(ADD, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+   do { word __d = ( r1) - ( r2); ( co) = __d > ( r1); (v) = __d; } while (0);
+   recurse(SUB_CO, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+   do { word __d = ( r2) - ( r1); ( co) = __d > ( r2); (v) = __d; } while (0);
+   recurse(SUB_CO, n_values,  s2,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+   ((v) = ( r1) - ( r2), ( co) = ( ci));
+   recurse(SUB, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+   ((v) = ( r2) - ( r1), ( co) = ( ci));
+   recurse(SUB, n_values,  s2,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+   ((v) = ( r1) & ( r2), ( co) = ( ci));
+   recurse(AND, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+   ((v) = ( r1) | ( r2), ( co) = ( ci));
+   recurse(IOR, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+   ((v) = ( r1) ^ ( r2), ( co) = ( ci));
+   recurse(XOR, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+   ((v) = ( r1) & ~( r2), ( co) = ( ci));
+   recurse(ANDC, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+   ((v) = ( r2) & ~( r1), ( co) = ( ci));
+   recurse(ANDC, n_values,  s2,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+   ((v) = ( r1) | ~( r2), ( co) = ( ci));
+   recurse(IORC, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+   ((v) = ( r2) | ~( r1), ( co) = ( ci));
+   recurse(IORC, n_values,  s2,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+   ((v) = ( r1) ^ ~( r2), ( co) = ( ci));
+   recurse(EQV, n_values,  s1,  s2, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+ }
+    }
+  if (ci >= 0 && flag_use_carry)
+    {
+      for (s1 = n_values - 1; s1 >= 0; s1--)
+ {
+   r1 = values[s1];
+
+   if (allowed_cost <= 1 && (prune_hint & CY_JUST_SET) == 0)
+     {
+
+       if (last_dest >= 0 && s1 != last_dest)
+  continue;
+     }
+
+   do { word __d = ( r1) + ( r1) + (( ci)); ( co) = ( ci) ? __d <= ( r1) : __d < ( r1); (v) = __d; } while (0);
+   recurse(ADD_CIO, n_values,  s1,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+
+   do { word __d = ( r1) + ( r1) + (( ci)); ( co) = ( ci); (v) = __d; } while (0);
+   recurse(ADD_CI, n_values,  s1,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+   do { word __d = ( r1) + ( -1 ) + (( ci)); ( co) = ( ci) ? __d <= ( r1) : __d < ( r1); (v) = __d; } while (0);
+   recurse(ADD_CIO, n_values,  s1,  (0x20 + -1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+
+   do { word __d = ( r1) + ( 0 ) + (( ci)); ( co) = ( ci) ? __d <= ( r1) : __d < ( r1); (v) = __d; } while (0);
+   recurse(ADD_CIO, n_values,  s1,  (0x20 + 0) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+   do { word __d = ( 0 ) - ( r1) - (( ci)); ( co) = ( ci) ? __d >= ( 0 ) : __d > ( 0 ); (v) = __d; } while (0);
+   recurse(SUB_CIO, n_values,  (0x20 + 0) ,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+
+ }
+    }
+  for (s1 = n_values - 1; s1 >= 0; s1--)
+    {
+      r1 = values[s1];
+
+      if (allowed_cost <= 1)
+ {
+   if (last_dest >= 0 && s1 != last_dest)
+     continue;
+ }
+      do { word __d = ( r1) + ( r1); ( co) = __d < ( r1); (v) = __d; } while (0);
+      recurse(ADD_CO, n_values,  s1,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+
+      ((v) = ( r1) & ( 1 ), ( co) = ( ci));
+      recurse(AND, n_values,  s1,  (0x20 + 1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+      ((v) = ( r1) ^ ( 1 ), ( co) = ( ci));
+      recurse(XOR, n_values,  s1,  (0x20 + 1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+      ((v) = ( -1 ) - ( r1), ( co) = ( ci));
+      recurse(SUB, n_values,  (0x20 + -1) ,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+      do { word __d = ( r1) + ( 1 ); ( co) = __d < ( r1); (v) = __d; } while (0);
+      recurse(ADD_CO, n_values,  s1,  (0x20 + 1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+      ((v) = ( r1) + ( 1 ), ( co) = ( ci));
+      recurse(ADD, n_values,  s1,  (0x20 + 1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+      do { word __d = ( r1) + ( -1 ); ( co) = __d < ( r1); (v) = __d; } while (0);
+      recurse(ADD_CO, n_values,  s1,  (0x20 + -1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+      do { word __d = ( r1) - ( 1 ); ( co) = __d > ( r1); (v) = __d; } while (0);
+      recurse(SUB_CO, n_values,  s1,  (0x20 + 1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+      do { word __d = ( 0 ) - ( r1); ( co) = __d > ( 0 ); (v) = __d; } while (0);
+      recurse(SUB_CO, n_values,  (0x20 + 0) ,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET);
+      ((v) = ( 0 ) - ( r1), ( co) = ( ci));
+      recurse(SUB, n_values,  (0x20 + 0) ,  s1, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+      ((v) = ((unsigned_word) ( r1) >> (( 1 ) & (32  - 1)) ), ( co) = ( ci));
+      recurse(LSHIFTR, n_values,  s1,  (0x20 + 1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+      ((v) = ((signed_word) ( r1) >> (( 1 ) & (32  - 1)) ), ( co) = ( ci));
+      recurse(ASHIFTR, n_values,  s1,  (0x20 + 1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+      ((v) = ((signed_word) ( r1) << (( 1 ) & (32  - 1)) ), ( co) = ( ci));
+      recurse(SHIFTL, n_values,  s1,  (0x20 + 1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+      ((v) = ((unsigned_word) ( r1) >> (( 32 -1 ) & (32  - 1)) ), ( co) = ( ci));
+      recurse(LSHIFTR, n_values,  s1,  (0x20 + 32 -1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+      ((v) = ((signed_word) ( r1) >> (( 32 -1 ) & (32  - 1)) ), ( co) = ( ci));
+      recurse(ASHIFTR, n_values,  s1,  (0x20 + 32 -1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+    }
+  if (ci >= 0 && flag_use_carry
+      && (allowed_cost <= 1 ? ((prune_hint & CY_JUST_SET) != 0) : 1))
+    {
+      do { word __d = ( 0 ) + ( 0 ) + (( ci)); ( co) = ( ci) ? __d <= ( 0 ) : __d < ( 0 ); (v) = __d; } while (0);
+      recurse(ADD_CIO, n_values,  (0x20 + 0) ,  (0x20 + 0) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET | CY_0);
+      do { word __d = ( 0 ) - ( 0 ) - (( ci)); ( co) = ( ci) ? __d >= ( 0 ) : __d > ( 0 ); (v) = __d; } while (0);
+      recurse(SUB_CIO, n_values,  (0x20 + 0) ,  (0x20 + 0) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+      do { word __d = ( 0 ) - ( -1 ) - (( ci)); ( co) = ( ci) ? __d >= ( 0 ) : __d > ( 0 ); (v) = __d; } while (0);
+      recurse(SUB_CIO, n_values,  (0x20 + 0) ,  (0x20 + -1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  CY_JUST_SET | CY_1);
+      do { word __d = ( 0 ) + ( -1 ) + (( ci)); ( co) = ( ci) ? __d <= ( 0 ) : __d < ( 0 ); (v) = __d; } while (0);
+      recurse(ADD_CIO, n_values,  (0x20 + 0) ,  (0x20 + -1) , v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+    }
+
+  if (allowed_cost > 1)
+    {
+      ((v) = ( 0x80000000 ), ( co) = ( ci));
+      recurse(COPY, n_values,  (0x20 - 2) ,  0, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+      ((v) = ( -1 ), ( co) = ( ci));
+      recurse(COPY, n_values,  (0x20 + -1) ,  0, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+
+      ((v) = ( 1 ), ( co) = ( ci));
+      recurse(COPY, n_values,  (0x20 + 1) ,  0, v, 1, sequence, n_insns, values, n_values + 1, goal_value, allowed_cost, co,  prune_hint & ~CY_JUST_SET);
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920625-2.c b/gcc/testsuite/gcc.c-torture/compile/920625-2.c
new file mode 100644
index 00000000000..1466285f88e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920625-2.c
@@ -0,0 +1,103 @@
+typedef	char *	caddr_t;
+typedef unsigned Cursor;
+typedef char *String;
+typedef struct _WidgetRec *Widget;
+typedef char		Boolean;
+typedef unsigned int	Cardinal;
+typedef struct _XedwListReturnStruct {
+  String   string;
+  int      xedwList_index;
+  struct _XedwListReturnStruct *next;
+} XedwListReturnStruct;
+static XedwListReturnStruct *return_list;
+static String   srcdir, dstdir;
+char *strcpy();
+  extern void setCursor(Cursor);
+  extern void query_dialog(String, Boolean);
+  extern Boolean directoryManagerNewDirectory(String);
+trashQueryResult(Widget w, Boolean delete, caddr_t call_data)
+{
+  int  execute(String, String, String, Boolean);
+  extern void destroy_button_dialog(void);
+  extern void changestate(Boolean);
+
+  extern Cursor busy, left_ptr;
+  extern String cwd;
+      	static void freeReturnStruct(void);
+  String rmstring;
+  int status;
+  XedwListReturnStruct *tmp;
+  setCursor(busy);
+  destroy_button_dialog();
+  if (delete == 1) {
+    rmstring = (("rm -fr") != ((void *)0) ? (strcpy((char*)XtMalloc((unsigned)strlen("rm -fr") + 1), "rm -fr")) : ((void *)0));
+    tmp = return_list;
+    while (tmp != ((void *)0)) {
+      rmstring = (String) XtRealloc (rmstring, sizeof(char) *
+				     (strlen(rmstring) +
+				      strlen(tmp->string) + 5));
+      sprintf(rmstring, "%s '%s'", rmstring, tmp->string);
+      tmp = tmp->next;
+    }
+    if ((status = execute(((void *)0), "rm", rmstring, 1)) != 0) {
+      XBell(XtDisplay(w), 100);
+      query_dialog("Can't remove file", 0);
+    }
+    XtFree(rmstring);
+
+    directoryManagerNewDirectory(cwd);
+  } else {
+    changestate(1);
+  }
+  setCursor(left_ptr);
+  freeReturnStruct();
+}
+
+copyQueryResult(Widget w, Boolean copy, caddr_t call_data)
+{
+  extern void destroy_button_dialog();
+  extern void changestate(Boolean);
+  extern Cursor busy, left_ptr;
+  static void freeReturnStruct(void);
+  int execute(String, String, String, Boolean);
+  extern String cwd;
+  String copystring;
+  int status;
+  Cardinal srclen, dstlen;
+  XedwListReturnStruct *tmp;
+  destroy_button_dialog();
+  setCursor(busy);
+  if (copy == 1) {
+    srclen = strlen(srcdir);
+    dstlen = strlen(dstdir);
+    copystring = (("cp -r") != ((void *)0) ? (strcpy((char*)XtMalloc((unsigned)strlen("cp -r") + 1), "cp -r")) : ((void *)0));
+    tmp = return_list;
+    while (tmp != ((void *)0)) {
+      copystring = (String) XtRealloc (copystring, sizeof(char) *
+				       (strlen(copystring) +
+					strlen(tmp->string) +
+					srclen + 6));
+      sprintf(copystring, "%s '%s/%s'", copystring, srcdir, tmp->string);
+      tmp = tmp->next;
+    }
+    copystring = (String) XtRealloc (copystring, sizeof(char) *
+				     (strlen(copystring) +
+				      dstlen + 5));
+    sprintf(copystring, "%s '%s'", copystring, dstdir);
+    if ((status = execute(((void *)0), "cp", copystring, 1)) != 0) {
+      XBell(XtDisplay(w), 100);
+      query_dialog("Can't copy file!", 0);
+    }
+    XtFree(copystring);
+
+    directoryManagerNewDirectory(cwd);
+  } else {
+    changestate(1);
+  }
+  XtFree(srcdir);
+  XtFree(dstdir);
+  setCursor(left_ptr);
+  freeReturnStruct();
+}
+
+freeReturnStruct(){}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920626-1.c b/gcc/testsuite/gcc.c-torture/compile/920626-1.c
new file mode 100644
index 00000000000..54419866a1f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920626-1.c
@@ -0,0 +1 @@
+f(x)unsigned x;{return x>>-5;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920701-1.c b/gcc/testsuite/gcc.c-torture/compile/920701-1.c
new file mode 100644
index 00000000000..4302f9ea331
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920701-1.c
@@ -0,0 +1 @@
+f(char*c){extern char a[],b[];return a+(b-c);}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920702-1.c b/gcc/testsuite/gcc.c-torture/compile/920702-1.c
new file mode 100644
index 00000000000..23a5395b0cd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920702-1.c
@@ -0,0 +1,10 @@
+int somevar;
+void
+yylex ()
+{
+  register int result = 0;
+  int num_bits = -1;
+
+  if (((result >> -1) & 1))
+    somevar = 99;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920706-1.c b/gcc/testsuite/gcc.c-torture/compile/920706-1.c
new file mode 100644
index 00000000000..13b0ff1e0ba
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920706-1.c
@@ -0,0 +1 @@
+f(){float i[2],o[1];g(o);return*o;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920710-2.c b/gcc/testsuite/gcc.c-torture/compile/920710-2.c
new file mode 100644
index 00000000000..dcaf1bea3cf
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920710-2.c
@@ -0,0 +1,36 @@
+union u
+{
+  struct {unsigned h, l;} i;
+  double d;
+};
+
+foo (union u x)
+{
+  while (x.i.h++)
+    {
+      while (x.i.l-- > 0)
+	;
+      while (x.d++ > 0)
+	;
+    }
+}
+
+union n
+{
+  long long unsigned i;
+  double d;
+};
+
+bar (union n x)
+{
+  int i;
+  for (i = 0; i < 100; i++)
+    {
+      while (--x.i > 0)
+	;
+      while (++x.d > 0)
+	;
+    }
+  return x.i;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/920711-1.c b/gcc/testsuite/gcc.c-torture/compile/920711-1.c
new file mode 100644
index 00000000000..a5aa7df1127
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920711-1.c
@@ -0,0 +1 @@
+f(a){a=(1,1)/2;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920721-1.c b/gcc/testsuite/gcc.c-torture/compile/920721-1.c
new file mode 100644
index 00000000000..7ced611eb6f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920721-1.c
@@ -0,0 +1,11 @@
+typedef struct{short ttype;float s;}T;
+short t[8][8];
+
+T f(T t2,T t1)
+{
+  T x;
+  if (t1.ttype == 1)
+    x.ttype = t[t2.ttype][t1.ttype],
+    x.s = 1;
+  return x;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920723-1.c b/gcc/testsuite/gcc.c-torture/compile/920723-1.c
new file mode 100644
index 00000000000..af0cf76f42c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920723-1.c
@@ -0,0 +1,23 @@
+typedef struct {
+  double x, y;
+} vector_t;
+double sqrt();
+f(int count,vector_t*pos,double r,double *rho)
+{
+  int i, j, miny, maxy, hy;
+  float help, d;
+  int gitt[150][150];
+  int *data = (int *)malloc(count*sizeof(int));
+  for (i = 0; i < count; i++)
+    rho[i] = 0;
+  for (i = 1; i < count; i++)
+    for (hy = miny; hy<= maxy; hy++)
+      while(j >=0) {
+	d = pos[i].y - pos[j].y;
+	if ( d <= r) {
+	  d = sqrt(d);
+	  rho[i] += help;
+	}
+      }
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/920729-1.c b/gcc/testsuite/gcc.c-torture/compile/920729-1.c
new file mode 100644
index 00000000000..96676e95307
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920729-1.c
@@ -0,0 +1,2 @@
+extern int i;extern volatile int i;
+f(){int j;for(;;)j = i;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920806-1.c b/gcc/testsuite/gcc.c-torture/compile/920806-1.c
new file mode 100644
index 00000000000..0928fe8a784
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920806-1.c
@@ -0,0 +1 @@
+f(){short x=32000;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920808-1.c b/gcc/testsuite/gcc.c-torture/compile/920808-1.c
new file mode 100644
index 00000000000..17510a96821
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920808-1.c
@@ -0,0 +1 @@
+f(i){for(i=1;i<=2;({;}),i++){({;}),g();}}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920809-1.c b/gcc/testsuite/gcc.c-torture/compile/920809-1.c
new file mode 100644
index 00000000000..ad35e121003
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920809-1.c
@@ -0,0 +1 @@
+f(x,y){memcpy (&x,&y,8192);}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920817-1.c b/gcc/testsuite/gcc.c-torture/compile/920817-1.c
new file mode 100644
index 00000000000..31a57339ea9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920817-1.c
@@ -0,0 +1 @@
+int v;static inline f(){return 0;}g(){return f();}void h(){return v++;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920820-1.c b/gcc/testsuite/gcc.c-torture/compile/920820-1.c
new file mode 100644
index 00000000000..2bc0dbea07b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920820-1.c
@@ -0,0 +1 @@
+long long f(double y){return y;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920821-1.c b/gcc/testsuite/gcc.c-torture/compile/920821-1.c
new file mode 100644
index 00000000000..40a8c178f10
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920821-1.c
@@ -0,0 +1 @@
+/* empty */
diff --git a/gcc/testsuite/gcc.c-torture/compile/920821-2.c b/gcc/testsuite/gcc.c-torture/compile/920821-2.c
new file mode 100644
index 00000000000..a69c0a901ba
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920821-2.c
@@ -0,0 +1,4 @@
+typedef struct{int p[25];}t1;
+struct{t1 x,y;}y;
+t1 x[1];
+f(){y.x=*x;y.y=*x;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920825-1.c b/gcc/testsuite/gcc.c-torture/compile/920825-1.c
new file mode 100644
index 00000000000..514d63f977f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920825-1.c
@@ -0,0 +1,3 @@
+#pragma pack(1)
+struct{unsigned short f1:5;unsigned short f2:6;}x;
+f(){x.f2=1;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920825-2.c b/gcc/testsuite/gcc.c-torture/compile/920825-2.c
new file mode 100644
index 00000000000..9834aac1783
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920825-2.c
@@ -0,0 +1,3 @@
+f(double*a,int m){int j;for(j=0;j<m;j++)a[j]=1;}
+g(double*a){int j;for(j=0;j<4;j++)a[j]=1;}
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/920826-1.c b/gcc/testsuite/gcc.c-torture/compile/920826-1.c
new file mode 100644
index 00000000000..d19eff2cec6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920826-1.c
@@ -0,0 +1 @@
+f(int*x){goto*(char)*x;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920828-1.c b/gcc/testsuite/gcc.c-torture/compile/920828-1.c
new file mode 100644
index 00000000000..4893173423b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920828-1.c
@@ -0,0 +1 @@
+char a[]={4,5};f(n){return a[n<2?n:0];}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920829-1.c b/gcc/testsuite/gcc.c-torture/compile/920829-1.c
new file mode 100644
index 00000000000..593400bac92
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920829-1.c
@@ -0,0 +1 @@
+f(double x){double y;y=x/0.5;if(y<0.1)y=1.0;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920831-1.c b/gcc/testsuite/gcc.c-torture/compile/920831-1.c
new file mode 100644
index 00000000000..ff2fd6360bf
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920831-1.c
@@ -0,0 +1 @@
+f(x){goto*(char)x;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920902-1.c b/gcc/testsuite/gcc.c-torture/compile/920902-1.c
new file mode 100644
index 00000000000..6f6dcd5bf30
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920902-1.c
@@ -0,0 +1,2 @@
+void f(int);
+void f(x)unsigned char x;{}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920909-1.c b/gcc/testsuite/gcc.c-torture/compile/920909-1.c
new file mode 100644
index 00000000000..939aaf789e8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920909-1.c
@@ -0,0 +1 @@
+long long f(long long a,long long b){return a<<b;}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920917-1.c b/gcc/testsuite/gcc.c-torture/compile/920917-1.c
new file mode 100644
index 00000000000..ebe8200d48b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920917-1.c
@@ -0,0 +1,2 @@
+inline f(x){switch(x){case 6:case 4:case 3:case 1:;}return x;}
+g(){f(sizeof("xxxxxx"));}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920928-1.c b/gcc/testsuite/gcc.c-torture/compile/920928-1.c
new file mode 100644
index 00000000000..137363dc120
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920928-1.c
@@ -0,0 +1,2 @@
+struct{int c;}v;
+static long i=((char*)&(v.c)-(char*)&v);
diff --git a/gcc/testsuite/gcc.c-torture/compile/920928-2.c b/gcc/testsuite/gcc.c-torture/compile/920928-2.c
new file mode 100644
index 00000000000..a0964f90f44
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920928-2.c
@@ -0,0 +1,19 @@
+typedef struct{struct{char*d;int b;}*i;}*t;
+double f();
+g(p)t p;
+{
+  short x,y,delta,s,w,h,fx,fy,tx,ty;
+  int q1,q2,q3,q4;
+  h=f((ty-fy)/2.0+0.5);
+  s=(((int)((short)(tx-fx))<(int)((short)(ty-fy)))?((short)(tx-fx)):((short)(ty-fy)))%2;
+  delta=(((int)(w)<(int)(h))?(w):(h))-s;
+  for(x=0;x<=delta;x++)
+    for(y=1-s;y<=delta;y++){
+      q1=((int)((*(p->i->d+(fx+w+x)/8+(fy+h+y)*p->i->b)&(1<<((fx+w+x)%8)))?1:0));
+      q2=((int)((*(p->i->d+(fx+w+y)/8+(fy+h-s-x)*p->i->b)&(1<<((fx+w+y)%8)))?1:0));
+      q3=((int)((*(p->i->d+(fx+w-s-x)/8+(fy+h-s-y)*p->i->b)&(1<<((fx+w-s-x)%8)))?1:0));
+      q4=((int)((*(p->i->d+(fx+w-s-y)/8+(fy+h+x)*p->i->b)&(1<<((fx+w-s-y)%8)))?1:0));
+      if(q4!=q1)
+	ff(p,fx+w-s-y,fy+h+x);
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920928-3.c b/gcc/testsuite/gcc.c-torture/compile/920928-3.c
new file mode 100644
index 00000000000..583dc69b74c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920928-3.c
@@ -0,0 +1,19 @@
+f (int phaseone)
+{
+  typedef struct
+    {
+      unsigned char *p;
+    }
+  FILE;
+  FILE b[2];
+  static unsigned char xchr[2];
+  int j;
+  int for_end;
+  if (phaseone)
+    {
+      if (j <= for_end)
+	do
+	  *(b[1].p) = xchr[j];
+	while (j++ < 10);
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/920928-4.c b/gcc/testsuite/gcc.c-torture/compile/920928-4.c
new file mode 100644
index 00000000000..348de654f30
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920928-4.c
@@ -0,0 +1,113 @@
+typedef unsigned char	unsigned8;
+typedef unsigned short int	unsigned16;
+typedef unsigned long int	unsigned32;
+typedef char	signed8;
+typedef short int	signed16;
+typedef long int	signed32;
+typedef unsigned32 boolean32;
+typedef unsigned long int	error_status_t;
+typedef struct {
+	unsigned32 time_low;
+	unsigned16 time_mid;
+	unsigned16 time_hi_and_version;
+	unsigned8 clock_seq_hi_and_reserved;
+	unsigned8 clock_seq_low;
+	unsigned char	node[6];
+} uuid_t;
+
+typedef unsigned32 bitset;
+typedef signed32 sec_timeval_sec_t;
+typedef struct {
+	signed32 sec;
+	signed32 usec;
+} sec_timeval_t;
+typedef signed32 sec_timeval_period_t;
+typedef signed32 sec_rgy_acct_key_t;
+
+typedef struct {
+	uuid_t source;
+	signed32 handle;
+	boolean32 valid;
+} sec_rgy_cursor_t;
+typedef unsigned char	sec_rgy_pname_t[257];
+typedef unsigned char	sec_rgy_name_t[1025];
+
+typedef signed32 sec_rgy_override_t;
+typedef signed32 sec_rgy_mode_resolve_t;
+typedef unsigned char	sec_rgy_unix_gecos_t[292];
+typedef unsigned char	sec_rgy_unix_login_name_t[1025];
+typedef unsigned char	sec_rgy_member_t[1025];
+typedef unsigned char	sec_rgy_unix_passwd_buf_t[16];
+typedef struct sec_rgy_sid_t {
+	uuid_t person;
+	uuid_t group;
+	uuid_t org;
+} sec_rgy_sid_t;
+typedef struct {
+	signed32 person;
+	signed32 group;
+	signed32 org;
+} sec_rgy_unix_sid_t;
+typedef struct {
+	sec_rgy_unix_login_name_t name;
+	sec_rgy_unix_passwd_buf_t passwd;
+	signed32 uid;
+	signed32 gid;
+	signed32 oid;
+	sec_rgy_unix_gecos_t gecos;
+	sec_rgy_pname_t homedir;
+	sec_rgy_pname_t shell;
+} sec_rgy_unix_passwd_t;
+typedef unsigned char	sec_rgy_member_buf_t[10250];
+typedef struct {
+	sec_rgy_name_t name;
+	signed32 gid;
+	sec_rgy_member_buf_t members;
+} sec_rgy_unix_group_t;
+
+typedef struct {
+	uuid_t site_id;
+	sec_timeval_sec_t person_dtm;
+	sec_timeval_sec_t group_dtm;
+	sec_timeval_sec_t org_dtm;
+} rs_cache_data_t;
+
+typedef enum {
+	rs_unix_query_name,
+	rs_unix_query_unix_num,
+	rs_unix_query_none
+} rs_unix_query_t;
+
+typedef struct {
+	rs_unix_query_t query;
+	union {
+		struct {
+			long int	name_len;
+			sec_rgy_name_t name;
+		} name;
+		long int	unix_num;
+	} tagged_union;
+} rs_unix_query_key_t;
+
+static unsigned long int IDL_offset_vec[] =
+{
+    0,
+    sizeof(sec_rgy_unix_group_t),
+    (unsigned long int) ((unsigned char *) &((sec_rgy_unix_group_t *) 0)->name - (unsigned char *) 0),
+    (unsigned long int) ((unsigned char *) &((sec_rgy_unix_group_t *) 0)->gid - (unsigned char *) 0),
+    (unsigned long int) ((unsigned char *) &((sec_rgy_unix_group_t *) 0)->members - (unsigned char *) 0),
+    sizeof(rs_cache_data_t),
+    (unsigned long int) ((unsigned char *) &((rs_cache_data_t *) 0)->site_id.time_low - (unsigned char *) 0),
+    (unsigned long int) ((unsigned char *) &((rs_cache_data_t *) 0)->site_id.time_mid - (unsigned char *) 0),
+    (unsigned long int) ((unsigned char *) &((rs_cache_data_t *) 0)->site_id.time_hi_and_version - (unsigned char *) 0),
+    sizeof(sec_rgy_unix_passwd_t),
+    (unsigned long int) ((unsigned char *) &((sec_rgy_cursor_t *) 0)->source.clock_seq_hi_and_reserved - (unsigned char *) 0),
+    (unsigned long int) ((unsigned char *) &((sec_rgy_cursor_t *) 0)->source.clock_seq_low - (unsigned char *) 0),
+    (unsigned long int) ((unsigned char *) &((sec_rgy_cursor_t *) 0)->source.node - (unsigned char *) 0),
+    (unsigned long int) ((unsigned char *) &((sec_rgy_cursor_t *) 0)->handle - (unsigned char *) 0),
+    (unsigned long int) ((unsigned char *) &((sec_rgy_cursor_t *) 0)->valid - (unsigned char *) 0),
+    sizeof(struct {long int name_len; sec_rgy_name_t name;}),
+    (unsigned long int) ((unsigned char *) &((struct {long int name_len; sec_rgy_name_t name;} *)0)->name_len
+			 - (unsigned char *) 0),
+    (unsigned long int) ((unsigned char *) &((struct {long int name_len; sec_rgy_name_t name;} *)0)->name - (unsigned char *) 0),
+};
diff --git a/gcc/testsuite/gcc.c-torture/compile/920928-5.c b/gcc/testsuite/gcc.c-torture/compile/920928-5.c
new file mode 100644
index 00000000000..8c975f0c051
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920928-5.c
@@ -0,0 +1,7 @@
+/* REPRODUCED:CC1:SIGNAL MACHINE:m68k OPTIONS:-fpcc-struct-return */
+struct b{};
+f(struct b(*f)())
+{
+struct b d=f();
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/920928-6.c b/gcc/testsuite/gcc.c-torture/compile/920928-6.c
new file mode 100644
index 00000000000..692191b1245
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/920928-6.c
@@ -0,0 +1,2 @@
+struct{int c;}v;
+static short i=((char*)&(v.c)-(char*)&v);
diff --git a/gcc/testsuite/gcc.c-torture/compile/921004-1.c b/gcc/testsuite/gcc.c-torture/compile/921004-1.c
new file mode 100644
index 00000000000..a947229089f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921004-1.c
@@ -0,0 +1,6 @@
+/* REPRODUCED:CC1:SIGNAL MACHINE:i386 OPTIONS: */
+long long f()
+{
+long long*g,*s;
+return*g+*s;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921011-1.c b/gcc/testsuite/gcc.c-torture/compile/921011-1.c
new file mode 100644
index 00000000000..6cc707dc74c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921011-1.c
@@ -0,0 +1,27 @@
+void
+fun (nb)
+     int nb;
+{
+  int th, h, em, nlwm, nlwS, nlw, sy;
+
+  while (nb--)
+    while (h--)
+      {
+	nlw = nlwm;
+	while (nlw)
+	  {
+	    if (nlwS == 1)
+	      {
+	      }
+	    else
+	      if (nlwS == 1)
+		{
+		}
+	    nlwS--; nlw--;
+	  }
+	if (em)
+	  nlwS--;
+	if (++sy == th)
+	  sy = 0;
+      }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921011-2.c b/gcc/testsuite/gcc.c-torture/compile/921011-2.c
new file mode 100644
index 00000000000..bf11dad979f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921011-2.c
@@ -0,0 +1,65 @@
+extern int foobar1 ();
+
+typedef struct
+  {
+    unsigned long colormap;
+    unsigned long red_max;
+    unsigned long red_mult;
+    unsigned long green_max;
+    unsigned long green_mult;
+    unsigned long blue_max;
+    unsigned long blue_mult;
+    unsigned long base_pixel;
+    unsigned long visualid;
+    unsigned long killid;
+  }
+frotz;
+
+int
+foobar (stdcmap, count)
+     frotz **stdcmap;
+     int *count;
+{
+  register int i;
+  frotz *data = ((void *) 0);
+
+  unsigned long nitems;
+  int ncmaps;
+  int old_style = 0;
+  unsigned long def_visual = 0L;
+  frotz *cmaps;
+
+
+  if ( foobar1 (&data) != 0)
+    return 0;
+  if (nitems < 10)
+    {
+      ncmaps = 1;
+      if (nitems < 9)
+	{
+	}
+    }
+  else
+    ncmaps = (nitems / 10);
+
+  {
+    register frotz *map;
+    register frotz *prop;
+
+    for (i = ncmaps, map = cmaps, prop = data; i > 0; i--, map++, prop++)
+      {
+	map->colormap = prop->colormap;
+	map->red_max = prop->red_max;
+	map->red_mult = prop->red_mult;
+	map->green_max = prop->green_max;
+	map->green_mult = prop->green_mult;
+	map->blue_max = prop->blue_max;
+	map->blue_mult = prop->blue_mult;
+	map->base_pixel = prop->base_pixel;
+	map->visualid = (def_visual ? def_visual : prop->visualid);
+	map->killid = (old_style ? 0L : prop->killid);
+      }
+  }
+  *stdcmap = cmaps;
+  *count = ncmaps;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921012-1.c b/gcc/testsuite/gcc.c-torture/compile/921012-1.c
new file mode 100644
index 00000000000..7b5cb6b9f17
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921012-1.c
@@ -0,0 +1,4 @@
+f()
+{
+g(({int x;0;}));
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921012-2.c b/gcc/testsuite/gcc.c-torture/compile/921012-2.c
new file mode 100644
index 00000000000..6f4de779549
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921012-2.c
@@ -0,0 +1,7 @@
+struct foo {
+int a,b,c;
+};
+f(struct foo*a,struct foo*b)
+{
+*a=*b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921013-1.c b/gcc/testsuite/gcc.c-torture/compile/921013-1.c
new file mode 100644
index 00000000000..0d14cbc6bb6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921013-1.c
@@ -0,0 +1,4 @@
+f(int x,short y)
+{
+long z=y<0?x>0?x:0:y;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921019-1.c b/gcc/testsuite/gcc.c-torture/compile/921019-1.c
new file mode 100644
index 00000000000..227bdc276fa
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921019-1.c
@@ -0,0 +1,9 @@
+struct
+{
+int n:1,c:1;
+}p;
+
+f()
+{
+p.c=p.n=0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921021-1.c b/gcc/testsuite/gcc.c-torture/compile/921021-1.c
new file mode 100644
index 00000000000..18dffeb9dd3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921021-1.c
@@ -0,0 +1,12 @@
+void g();
+
+f()
+{
+int x=1;
+while(x)
+{
+x=h();
+if(x)
+g();
+}
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921024-1.c b/gcc/testsuite/gcc.c-torture/compile/921024-1.c
new file mode 100644
index 00000000000..e723246d6b2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921024-1.c
@@ -0,0 +1,9 @@
+long long f(s,r)
+{
+  return *(long long*)(s+r);
+}
+
+g(s,r)
+{
+  *(long long*)(s+r)=0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921026-1.c b/gcc/testsuite/gcc.c-torture/compile/921026-1.c
new file mode 100644
index 00000000000..18238de8332
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921026-1.c
@@ -0,0 +1,4 @@
+f(unsigned short*a)
+{
+a[0]=65535;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921103-1.c b/gcc/testsuite/gcc.c-torture/compile/921103-1.c
new file mode 100644
index 00000000000..578e91aaf83
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921103-1.c
@@ -0,0 +1,12 @@
+struct {
+  unsigned int f1, f2;
+} s;
+
+f()
+{
+ unsigned x, y;
+ x = y = 0;
+ while (y % 4)
+   y++;
+ g(&s.f2, s.f1 + x, 4);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921109-1.c b/gcc/testsuite/gcc.c-torture/compile/921109-1.c
new file mode 100644
index 00000000000..eda43451f25
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921109-1.c
@@ -0,0 +1,28 @@
+typedef struct { double x, y; } p;
+typedef struct { int s; float r; } t;
+t *e, i;
+int i1;
+
+f(t *op)
+{
+int i2 = e->r;
+p pt;
+int c = g();
+t p;
+
+if (c)
+{
+i = *e;
+e -= 3;
+return 8;
+}
+if (op > e)
+return 1;
+op->r = pt.x;
+op->r = pt.y;
+p = *e;
+++e;
+e->r = i1, e->s = i1;
+*++e = p;
+return 3;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921111-1.c b/gcc/testsuite/gcc.c-torture/compile/921111-1.c
new file mode 100644
index 00000000000..11b467460b3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921111-1.c
@@ -0,0 +1,40 @@
+int ps;
+struct vp {
+  int wa;
+};
+typedef struct vp *vpt;
+typedef struct vc {
+  int o;
+  vpt py[8];
+} *vct;
+struct n {
+  int a;
+};
+struct nh {
+  int x;
+};
+typedef struct np *npt;
+struct np {
+  vct d;
+  int di;
+};
+struct nh xhp;
+struct n np[3];
+
+f(dp)
+     npt dp;
+{
+  vpt *py;
+  int a, l, o = 0;
+  a = dp->d->o;
+  if (dp->di < 0)
+    l = ps;
+
+  if ((int)o & 3)
+    g();
+
+  xhp.x = a;
+  py = &dp->d->py[dp->di];
+  if (o + l > ps)
+    np[2].a = (int)(py[1])->wa;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921116-2.c b/gcc/testsuite/gcc.c-torture/compile/921116-2.c
new file mode 100644
index 00000000000..9eac91cb5c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921116-2.c
@@ -0,0 +1,9 @@
+typedef struct {
+ long l[5];
+} t;
+
+f(size)
+{
+ t event;
+ g(&(event.l[2 + size]), (3 - size) * 4);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921118-1.c b/gcc/testsuite/gcc.c-torture/compile/921118-1.c
new file mode 100644
index 00000000000..857c74e74f1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921118-1.c
@@ -0,0 +1,8 @@
+inline f(i)
+{
+  h((long long) i * 2);
+}
+g()
+{
+  f(9);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921126-1.c b/gcc/testsuite/gcc.c-torture/compile/921126-1.c
new file mode 100644
index 00000000000..a7b908b2ef0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921126-1.c
@@ -0,0 +1,11 @@
+f()
+{
+  long long a0, a1, a0s, val;
+  int width;
+  float d;
+  if (d)
+    ;
+  if (a0s & (1LL << width))
+    ;
+  return a0 / a1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921202-1.c b/gcc/testsuite/gcc.c-torture/compile/921202-1.c
new file mode 100644
index 00000000000..1287edc57b8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921202-1.c
@@ -0,0 +1,22 @@
+f ()
+{
+  long dx[2055];
+  long dy[2055];
+  long s1[2055];
+  int x, y;
+  int i;
+  long s;
+
+  for (;;)
+    {
+      s = 2055;
+      g (s1, s);
+      for (i = 0; i < 1; i++);
+      dy[s] = 0x12345;
+      for (i = 0; i < 1; i++);
+      if (x != y || h (dx, dy, s) || dx[s] != 0x12345)
+	{
+	  j (y);k (dy);
+	}
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921202-2.c b/gcc/testsuite/gcc.c-torture/compile/921202-2.c
new file mode 100644
index 00000000000..97d482b633c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921202-2.c
@@ -0,0 +1,8 @@
+f(x, c)
+{
+  for (;;)
+    {
+      if (x << c) break;
+      x++;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921203-1.c b/gcc/testsuite/gcc.c-torture/compile/921203-1.c
new file mode 100644
index 00000000000..50fe3eb0b6f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921203-1.c
@@ -0,0 +1,5 @@
+char dispstr[];
+f()
+{
+  strcpy(dispstr,"xxxxxxxxxxx");
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921203-2.c b/gcc/testsuite/gcc.c-torture/compile/921203-2.c
new file mode 100644
index 00000000000..929afb1bdde
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921203-2.c
@@ -0,0 +1,13 @@
+typedef struct
+{
+  char x;
+} s1;
+
+s1 f (int arg0,...)
+{
+  int args;
+  s1 back;
+  va_start (args, arg0);
+  va_end (args);
+  return back;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921206-1.c b/gcc/testsuite/gcc.c-torture/compile/921206-1.c
new file mode 100644
index 00000000000..b18709dd8d1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921206-1.c
@@ -0,0 +1,28 @@
+double sqrt(double),fabs(double),sin(double);
+int sxs;
+int sys;
+f()
+{
+  int l;
+  int sm = -52, sx = 52;
+  char *smap;
+  for (l = 0; l < 9; l++)
+    {
+      double g;
+      int cx, cy, gx, gy, x, y;
+      gx = 2 > g / 3 ? 2 : g / 3;
+      gy = 2 > g / 3 ? 2 : g / 3;
+      for (y = 0 > cy - gy ? 0 : cy - gy; y <= (sys - 1 < cy + gy ? sys : cy + gy); y++)
+	{
+	  int sx = 0 > cx - gx ? 0 : cx - gx;
+	  short *ax = (short *) (y * sxs + sx);
+
+	  for (x = sx; x <= (sxs - 1 < cx + gx ? sxs - 1 : cx + gx); x++)
+	    {
+	      double c=2.25, z=sqrt(fabs(1-c)), cz=(c>1?0.0:-10)>z?c>1?0:1:z;
+	    }
+	}
+    }
+  for (l = sm; l <= sx; l++)
+    smap[l] = l > 0 ? 1 + pow(sin(.1 * l / sx)) : 1 - pow(sin(.1 * l / sm));
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/921227-1.c b/gcc/testsuite/gcc.c-torture/compile/921227-1.c
new file mode 100644
index 00000000000..a49750c81af
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/921227-1.c
@@ -0,0 +1,5 @@
+#define k(a) #a
+char *s = k(k(1,2));
+char *t = k(#) k(#undef k) k(x);
+
+f(){}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930109-1.c b/gcc/testsuite/gcc.c-torture/compile/930109-1.c
new file mode 100644
index 00000000000..dbd15a1bd0a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930109-1.c
@@ -0,0 +1,12 @@
+f(x)
+     unsigned x;
+{
+  static short c;
+  return x>>c;
+}
+g(x)
+     unsigned x;
+{
+  static char c;
+  return x>>c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930109-2.c b/gcc/testsuite/gcc.c-torture/compile/930109-2.c
new file mode 100644
index 00000000000..61e3a4df99f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930109-2.c
@@ -0,0 +1,11 @@
+f(r)
+{
+  int i;
+  for (i = 0; i < 2; i++)
+    {
+      r+= (4 >> i*2);
+      r+= (2 >> i*2);
+      r+= (1 >> i*2);
+    }
+  return r;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930111-1.c b/gcc/testsuite/gcc.c-torture/compile/930111-1.c
new file mode 100644
index 00000000000..28574191d13
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930111-1.c
@@ -0,0 +1,10 @@
+/* 2.3.3 crashes on 386 with -traditional */
+f(a)
+     char *a;
+{
+  int d = strcmp(a,"-");
+
+  while (vfork() < 0)
+    ;
+  return d;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930117-1.c b/gcc/testsuite/gcc.c-torture/compile/930117-1.c
new file mode 100644
index 00000000000..83317cdd07b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930117-1.c
@@ -0,0 +1,4 @@
+f(x)
+{
+  (*(void (*)())&x)();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930118-1.c b/gcc/testsuite/gcc.c-torture/compile/930118-1.c
new file mode 100644
index 00000000000..b29543c529e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930118-1.c
@@ -0,0 +1,6 @@
+f()
+{
+__label__ l;
+l:p();
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/930120-1.c b/gcc/testsuite/gcc.c-torture/compile/930120-1.c
new file mode 100644
index 00000000000..95ac43c07ed
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930120-1.c
@@ -0,0 +1,138 @@
+union {
+  short I[2];
+  long int L;
+  char C[4];
+} itolws;
+char *errflg;
+long int dot;
+short dotinc;
+long int expvf;
+
+char *
+f(fcount,ifp,itype,ptype)
+     short fcount;
+     char *ifp;
+{
+  unsigned w;
+  long int savdot, wx;
+  char *fp;
+  char c, modifier, longpr;
+  union {
+    double dval;
+    struct {
+      int i1;
+      int i2;
+    } ival;
+  } dw;
+  union {
+    float fval;
+    int ival;
+  } fw;
+  int gotdot = 0;
+  while (fcount > 0) {
+    fp = ifp;
+    c = *fp;
+    longpr = ((c >= 'A') & (c <= 'Z') | (c == 'f') | (c == '4') | (c == 'p') | (c == 'i'));
+    if ((itype == 0) || (*fp == 'a')) {
+      wx = dot;
+      w = dot;
+    } else {
+      gotdot = 1;
+      wx = get((int)dot, itype);
+      if (!longpr) {
+	w = (itolws.L=(wx), itolws.I[((dot)&3)>>1]);
+      }
+    }
+    if (c == 'F') {
+      dw.ival.i1 = wx;
+      if (itype == 0) {
+	dw.ival.i2 = expvf;
+      }
+    }
+
+    modifier = *fp++;
+    switch(modifier) {
+    case ' ' :
+    case '\t' :
+      break;
+    case 't':
+    case 'T':
+      printf("%T",fcount);
+      return(fp);
+    case 'r':
+    case 'R':
+      printf("%M",fcount);
+      return(fp);
+    case 'k':
+      printf("%k",w);
+      break;
+    case 'K':
+      printf("%K",wx);
+      break;
+    case 'a':
+      psymoff(dot,ptype,":%16t");
+      dotinc = 0;
+      break;
+    case 'p':
+      psymoff(0,ptype,"%16t");
+      break;
+    case 'u':
+      printf("%-8u",w);
+      break;
+    case 'U':
+      printf("%-16U",wx); break;
+    case 'c':
+    case 'C':
+      if (modifier == 'C') {
+	printesc((int)(itolws.L=(wx), itolws.C[(dot)&3]));
+      } else {
+	printc((char)(itolws.L=(wx), itolws.C[(dot)&3]));
+      }
+      dotinc = 1;
+      break;
+    case 'b':
+      printf("%-8x", (itolws.L=(wx), itolws.C[(dot)&3]));
+      dotinc = 1;
+      break;
+    case 'B':
+      printf("%-8o", (itolws.L=(wx), itolws.C[(dot)&3]));
+      dotinc = 1;
+      break;
+    case 's':
+    case 'S':
+      savdot = dot;
+      dotinc = 1;
+      while ((c = (itolws.L=(wx), itolws.C[(dot)&3])) && (errflg == 0)) {
+	dot = inkdot(1);
+	if (modifier == 'S') {
+	  printesc(c);
+	} else {
+	  printc(c);
+	}
+	endline();
+	if (!(dot & 3))
+	  wx = get((int)dot, itype);
+      }
+      dotinc = dot - savdot + 1;
+      dot = savdot;
+      break;
+    case 'i':
+      if (gotdot) {
+	wx = get((int)(dot & ~3), itype);
+      }
+      iDasm((int)(wx), (unsigned int)0, (unsigned int)(dot&~3));
+      printc('\n');
+      break;
+    case 'f':
+      fw.ival = wx;
+      printf("%-16.9f", fw.fval);
+      dotinc = 4;
+      break;
+    case 'F':
+      printf("%-32.18F", dw.dval);
+      dotinc = 8;
+      break;
+    }
+  }
+  return(fp);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930126-1.c b/gcc/testsuite/gcc.c-torture/compile/930126-1.c
new file mode 100644
index 00000000000..8313c5c450b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930126-1.c
@@ -0,0 +1,74 @@
+typedef unsigned T;
+typedef char Tchar;
+T mt (long, char *);
+T ms (long, char *);
+T mv (long, T, char);
+T cons (T, T);
+T decl (T * (*) (T *), char *);
+
+T*L92(T*),*L15(T*),*L14(T*),*L13(T*),*L12(T*),*L11(T*),*L10(T*),*L9(T*),*L8(T*),*L7(T*),*L6(T*),*L5(T*),*L4(T*),*L3(T*),*L2(T*),*L1(T*);
+
+static T *
+Ldata (T * my_pc)
+{
+int cc = (((* ((T *) (my_pc))) >> 16) & 0xFF);
+T B92, B91, B90, B15, B14, B13, B12, B11, B10, B9, B8, B7, B6, B5, B4, B3, B2, B1, tO7, tO6, tO5, tO4, tO3, tO2, tO1, tO0;
+T object = mv (168, 0, ((Tchar) 1));
+T * cb = (T *) (((T) (object & 0x3FF)) | 0x400);
+tO0 = mv (92, 0, ((Tchar) 1));
+B92 = decl (L92, "");
+B15 = decl (L15, "");
+B14 = decl (L14, "");
+B13 = decl (L13, "");
+B12 = decl (L12, "");
+B11 = decl (L11, "");
+B10 = decl (L10, "");
+B9 = decl (L9, "");
+B8 = decl (L8, "");
+B7 = decl (L7, "");
+B6 = decl (L6, "");
+B5 = decl (L5, "");
+B4 = decl (L4, "");
+B3 = decl (L3, "");
+B2 = decl (L2, "");
+B1 = decl (L1, "");
+cb[19] = ((((cc) & 0xFF) << 16) | (9 & 0xFF));
+cb[21] = ((((cc) & 0xFF) << 16) | ((10) & 0xFF));
+cb[23] = ((((cc) & 0xFF) << 16) | (11 & 0xFF));
+cb[25] = ((((cc) & 0xFF) << 16) | (12 & 0xFF));
+cb[27] = ((((cc) & 0xFF) << 16) | (13 & 0xFF));
+cb[29] = ((((cc) & 0xFF) << 16) | (14 & 0xFF));
+cb[31] = ((((cc) & 0xFF) << 16) | (15 & 0xFF));
+cb[35] = ((((cc) & 0xFF) << 16) | (17 & 0xFF));
+cb[36] = ((0x1A) << 26) | (((0x39) << 26) | 1) & 0x3FF;
+cb[39] = ms (24, ((char *) ""));
+cb[41] = ((0x1A) << 26) | (((0x39) << 26) | 1) & 0x3FF;
+cb[44] = 3;
+cb[46] = 2;
+cb[48] = 3;
+cb[50] = 6;
+cb[52] = 4;
+cb[146] = tO0;
+((T *) (((tO0 & 0x3FF)) | 0x400))[92] = B1;
+((T *) (((tO0 & 0x3FF)) | 0x400))[91] = B2;
+((T *) (((tO0 & 0x3FF)) | 0x400))[2] = B90;
+((T *) (((tO0 & 0x3FF)) | 0x400))[2] = B91;
+((T *) (((tO0 & 0x3FF)) | 0x400))[1] = B92;
+cb[58] = 0x2800 | (T) ((T *) ((B6 & 0x3FF) | 0x400) + 3);
+cb[57] = 0x2800 | (T) ((T *) ((B7 & 0x3FF) | 0x400) + 3) & ~0xC00;
+cb[56] = 0x2800 | (T) ((T *) ((B8 & 0x3FF) | 0x400) + 3) & ~0xC00;
+cb[55] = 0x2800 | (T) ((T *) ((B9 & 0x3FF) | 0x400) + 3) & ~0xC00;
+tO7 = mv (8, 0, ((Tchar) 1));
+tO4 = ms (9, ((char *) ""));
+tO3 = mv (58, 0, ((Tchar) 1));
+tO6 = ms (4, ((char *) ""));
+tO2 = mv (4, 0, ((Tchar) 1));
+tO5 = ms (4, ((char *) ""));
+tO1 = mv (28, 0, ((Tchar) 1));
+cb[165] = tO1;
+cb[163] = cons (((ms (10, ((char *) "")))), (cons (tO5, 0)));
+cb[162] = cons (1, (cons (2, 0)));
+cb[150] = cons (1, (cons (2, (cons (3, (cons (4, (cons (5, (cons (6, 0)))))))))));
+cb[148] = tO7;
+return cb;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930210-1.c b/gcc/testsuite/gcc.c-torture/compile/930210-1.c
new file mode 100644
index 00000000000..47d2da2aca5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930210-1.c
@@ -0,0 +1,11 @@
+f()
+{
+  char  c1, c2;
+  char *p1, *p2;
+
+  do {
+    c1 = c2 = *p1++;
+    while (c1--)
+      *p2++ = *p1++;
+  } while (c2);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930217-1.c b/gcc/testsuite/gcc.c-torture/compile/930217-1.c
new file mode 100644
index 00000000000..70f4a4897c4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930217-1.c
@@ -0,0 +1,14 @@
+double g ();
+typedef union {
+  struct {
+    unsigned s:1, e:8, f:23;
+  } u;
+  float f;
+} s;
+
+f(x, n)
+     float x;
+{
+  ((s *)&x)->u.e -= n;
+  x = g((double)x, -n);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930222-1.c b/gcc/testsuite/gcc.c-torture/compile/930222-1.c
new file mode 100644
index 00000000000..c6d6aa3b47d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930222-1.c
@@ -0,0 +1,16 @@
+typedef struct
+  {
+    long i;
+    double f;
+  } T;
+
+f (T *n1, T *n2)
+{
+  if (g (n2))
+    return n1->i - n2->i;
+  else
+    {
+      double f = n1->f - n2->i;
+      return f == 0.0 ? 0 : (f > 0.0 ? 1 : -1);
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930325-1.c b/gcc/testsuite/gcc.c-torture/compile/930325-1.c
new file mode 100644
index 00000000000..24cea5027ab
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930325-1.c
@@ -0,0 +1,23 @@
+typedef unsigned uint;
+
+inline
+g (uint *s, uint *d, uint c)
+{
+  while (c != 0)
+    {
+      *--d = *--s;
+      c--;
+    }
+}
+
+f (uint *p1, uint c, uint *p2)
+{
+  while (c > 0 && *p1 == 0)
+    {
+      p1++;
+      c--;
+    }
+  if (c == 0)
+    return 1;
+  g (p2, p1, c);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930326-1.c b/gcc/testsuite/gcc.c-torture/compile/930326-1.c
new file mode 100644
index 00000000000..97313d86aa9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930326-1.c
@@ -0,0 +1,6 @@
+struct
+{
+  char a, b, f[3];
+} s;
+
+long i = s.f-&s.b;
diff --git a/gcc/testsuite/gcc.c-torture/compile/930326-1.x b/gcc/testsuite/gcc.c-torture/compile/930326-1.x
new file mode 100644
index 00000000000..622145638d1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930326-1.x
@@ -0,0 +1,7 @@
+# This doesn't work on mn10200
+
+if { [istarget "mn10200*-*-*"] } {
+	set torture_compile_xfail "mn10200*-*-*"
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/compile/930411-1.c b/gcc/testsuite/gcc.c-torture/compile/930411-1.c
new file mode 100644
index 00000000000..bb03c13fa07
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930411-1.c
@@ -0,0 +1,36 @@
+int heap;
+
+g(){}
+
+f(int i1, int i2)
+{
+  i1 = *(int*)(i1 + 4);
+  if (i1 == 0)
+    goto L4;
+  else
+    goto L9;
+ L3:
+  i2 = heap - 8;
+  *(int*)i2 = 3;
+  *(int*)(i2 + 4) = i1;
+  heap -= 8;
+  return i2;
+ L4:
+  i1 = g(i2);
+  goto L5;
+ L5:
+  i1 = *(int*)(i1 + 4);
+  if (i1 == 0)
+    goto L7;
+  else
+    goto L8;
+ L7:
+  i1 = 0;
+  goto L3;
+ L8:
+  i1 = 1;
+  goto L3;
+ L9:
+  i1 = 1;
+  goto L3;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930421-1.c b/gcc/testsuite/gcc.c-torture/compile/930421-1.c
new file mode 100644
index 00000000000..01b465f7fec
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930421-1.c
@@ -0,0 +1,19 @@
+double q(double);
+
+f (int **x, int *r, int *s, int a, int b, int c, int d)
+{
+  int i, j, k, m, e, f, g, z[1024], y[2];
+
+  e = g = 0;
+  for (i = 0; i < a; i++)
+    for (j = 0; j < b; j++)
+      if (x[i][j])
+	for (k = 0; k < c; k++)
+	  {
+	    f = q(1.5) + q(2.5);
+	    if (g < y[f])
+	      g = e;
+	  }
+  for (m = 0; m < 1; m++)
+    z[0] = m*2*d/3.0 - d;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930427-2.c b/gcc/testsuite/gcc.c-torture/compile/930427-2.c
new file mode 100644
index 00000000000..53b633785ae
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930427-2.c
@@ -0,0 +1,9 @@
+struct s {
+  int f;
+};
+
+f (w, v0, v1, v2, v3)
+     struct s *w;
+{
+ g (v0 ? 1 : w->f, v1 ? v3 : v2);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930503-1.c b/gcc/testsuite/gcc.c-torture/compile/930503-1.c
new file mode 100644
index 00000000000..6889e8b7aed
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930503-1.c
@@ -0,0 +1,8 @@
+f (const char *s, char *d, unsigned l)
+{
+  if (0)
+    while (1);
+  else
+    while (--l >= 0)
+      *d++ = *s++;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930503-2.c b/gcc/testsuite/gcc.c-torture/compile/930503-2.c
new file mode 100644
index 00000000000..1b0ea34f038
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930503-2.c
@@ -0,0 +1,5 @@
+f()
+{
+  struct { char x; } r;
+  g(r);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930506-1.c b/gcc/testsuite/gcc.c-torture/compile/930506-1.c
new file mode 100644
index 00000000000..8c26ea3670c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930506-1.c
@@ -0,0 +1,12 @@
+long long
+f (a)
+     double a;
+{
+  double b;
+  unsigned long long v;
+
+  b = a / 2.0;
+  v = (unsigned) b;
+  a -= (double) v;
+  return v;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930506-2.c b/gcc/testsuite/gcc.c-torture/compile/930506-2.c
new file mode 100644
index 00000000000..e11e62f026f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930506-2.c
@@ -0,0 +1,15 @@
+#ifndef NO_TRAMPOLINES
+int f1()
+{
+  { int ___() { foo(1); } bar(___); }
+  return( { int ___() { foo(2); } bar(___);} );
+}
+
+int f2(int j)
+{
+  { int ___() { foo(j); } bar(___); }
+  return( { int ___() { foo(j); } bar(___);} );
+}
+#else
+int x;
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compile/930510-1.c b/gcc/testsuite/gcc.c-torture/compile/930510-1.c
new file mode 100644
index 00000000000..8c46282626c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930510-1.c
@@ -0,0 +1,18 @@
+typedef long time_t;
+static __const int mon_lengths[2][12] = {
+  31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
+  31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
+};
+static time_t
+f (janfirst, year, rulep, offset)
+     __const time_t janfirst;
+     __const int year;
+     register __const struct rule * __const rulep;
+     __const long offset;
+{
+  register int leapyear;
+  register time_t value;
+  register int i;
+
+  value += mon_lengths[leapyear][i] * ((long) (60 * 60) * 24);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930513-1.c b/gcc/testsuite/gcc.c-torture/compile/930513-1.c
new file mode 100644
index 00000000000..2e106ae43a9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930513-1.c
@@ -0,0 +1,9 @@
+struct s {
+  int f1 : 26;
+  int f2 : 8;
+};
+
+f (struct s *x)
+{
+  return x->f2++ == 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930513-2.c b/gcc/testsuite/gcc.c-torture/compile/930513-2.c
new file mode 100644
index 00000000000..a7f508c8266
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930513-2.c
@@ -0,0 +1,9 @@
+double g ();
+
+f (x)
+     double x;
+{
+  x = .85;
+  while (g () < x)
+    ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930513-3.c b/gcc/testsuite/gcc.c-torture/compile/930513-3.c
new file mode 100644
index 00000000000..f8d4e60341c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930513-3.c
@@ -0,0 +1,9 @@
+test ()
+{
+  short *p, q[3];
+  int x;
+
+  p = q;
+  for (x = 0; x < 3; x++)
+    *p++ = 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930523-1.c b/gcc/testsuite/gcc.c-torture/compile/930523-1.c
new file mode 100644
index 00000000000..5f2b5b5d7e3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930523-1.c
@@ -0,0 +1,54 @@
+int v;
+
+f ()
+{
+  unsigned long *a1, *a2;
+  int vertex2;
+  int c, x1, x2, dx1, dx2, dy1, dy2, e1, e2, s2;
+  unsigned long m, b;
+  int n;
+  unsigned long r;
+  int aba;
+
+  do
+    {
+      if (dx2 >= dy2)
+	dx2 = dx2 % dy2;
+
+      if (dx2 >= dy2)
+	{
+	  s2 = - (dx2 / dy2);
+	  dx2 = dx2 % dy2;
+	}
+    }
+  while (vertex2 / 65536);
+
+  for (;;)
+    {
+      c = x2;
+      a2 = a1;
+      if (v)
+	a2 = 0;
+
+      if (c + n)
+	{
+	  m = b << (c * 8);
+	  *a2 = (*a2 & ~m) | (r & m);
+	  n += c;
+
+	  while (--n)
+	    {
+	      {
+	      }
+	    }
+	}
+
+      a1 = 0;
+      x1 += 0;
+      if (e1 += dx1)
+	e1 -= dy1;
+      x2 += s2;
+      if (e2 += dx2)
+	e2 -= dy2;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930525-1.c b/gcc/testsuite/gcc.c-torture/compile/930525-1.c
new file mode 100644
index 00000000000..00c2e263b82
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930525-1.c
@@ -0,0 +1,7 @@
+typedef struct foo foo_t;
+foo_t x;
+struct foo {
+  int i;
+};
+
+foo_t x = { 10 };
diff --git a/gcc/testsuite/gcc.c-torture/compile/930527-1.c b/gcc/testsuite/gcc.c-torture/compile/930527-1.c
new file mode 100644
index 00000000000..53e00e65ed1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930527-1.c
@@ -0,0 +1,16 @@
+enum {e0, e1};
+
+int x[] =
+{
+  [e0] = 0
+};
+
+f ()
+{
+  switch (1)
+    {
+    case e0:
+    case e1:
+      break;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930529-1.c b/gcc/testsuite/gcc.c-torture/compile/930529-1.c
new file mode 100644
index 00000000000..70b2cb8f90c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930529-1.c
@@ -0,0 +1,83 @@
+struct r
+{
+  int d1, d2;
+};
+
+struct km
+{
+  int d;
+};
+
+struct f1
+{
+  char *fn;
+  char *fd;
+  char *fs;
+  char *ic;
+  void (*ff) ();
+};
+
+int g ();
+
+int y;
+struct r *bs;
+int bv;
+
+void b ();
+char *w ();
+
+struct km **q;
+char **mns;
+int nm;
+struct f1 **z;
+
+f (char *km, char *h)
+{
+  struct f1 *t;
+  int map = midn(km, strlen(km));
+  int V;
+  int c;
+  struct r r;
+  struct f1 *cm;
+
+  if (!g(&V, &cm, h, strlen(h)))
+    {
+      c = (cm - z[V]);
+      goto L;
+    }
+
+  for (c = 0; c < nm; c++)
+    if (!strcmp (h, mns[c]))
+      {
+	V = -1;
+	goto L;
+      }
+
+  for (c = 0; c < y; c++)
+    {
+      if (!memcmp (&bs[c], &r, 8))
+	goto L;
+    }
+
+  h = w (&r);
+  if (!bv)
+    {
+      bs = g (8);
+      t = (struct f1 *)g (20);
+    }
+  else
+    {
+      bs = g (bs, y * 8);
+      z[bv] = cr (z[bv], (1 + y) * 20);
+      t = &z[bv][y - 1];
+    }
+  bs[y - 1] = r;
+  t->fs[0] = sp (y - 1);
+  t->fs[1] = 0;
+  t->ic = 0;
+  t->fd = 0;
+  t->fn = cs (h);
+  t->ff = b;
+ L:
+  g (q[map], V, c);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930530-1.c b/gcc/testsuite/gcc.c-torture/compile/930530-1.c
new file mode 100644
index 00000000000..848e0400ece
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930530-1.c
@@ -0,0 +1,5 @@
+f ()
+{
+  struct { char a, b; } x;
+  g (x, x, x, x);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930602-1.c b/gcc/testsuite/gcc.c-torture/compile/930602-1.c
new file mode 100644
index 00000000000..5a0eb2189ba
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930602-1.c
@@ -0,0 +1,13 @@
+typedef struct {
+ int f[8];
+} T;
+
+f (w, l, r)
+     T *w;
+     unsigned short l, r;
+{
+  int i;
+
+  for (i = l; i < r; i++)
+    g (w->f[i]);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930603-1.c b/gcc/testsuite/gcc.c-torture/compile/930603-1.c
new file mode 100644
index 00000000000..643cc52d4c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930603-1.c
@@ -0,0 +1,10 @@
+union u { union u *a; double d; };
+union u *s, g();
+
+f()
+{
+  union u x = g();
+
+  s[0] = *x.a;
+  s[1] = g();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930607-1.c b/gcc/testsuite/gcc.c-torture/compile/930607-1.c
new file mode 100644
index 00000000000..97c94b25ec3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930607-1.c
@@ -0,0 +1,9 @@
+typedef void f ();
+typedef f *pf;
+long long i;
+
+g ()
+{
+  long long p = i;
+  ((pf) (long) p) ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930611-1.c b/gcc/testsuite/gcc.c-torture/compile/930611-1.c
new file mode 100644
index 00000000000..c216c096523
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930611-1.c
@@ -0,0 +1,7 @@
+float
+f (float a1)
+{
+  union { float f; int l; } fl1;
+  fl1.f = a1;
+  return fl1.l ? 1.0 : a1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930618-1.c b/gcc/testsuite/gcc.c-torture/compile/930618-1.c
new file mode 100644
index 00000000000..74c21572550
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930618-1.c
@@ -0,0 +1,8 @@
+f (s)
+{
+  int r;
+
+  r = (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s)) | (!g(s));
+
+ return r;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930621-1.c b/gcc/testsuite/gcc.c-torture/compile/930621-1.c
new file mode 100644
index 00000000000..3679cf1d3de
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930621-1.c
@@ -0,0 +1,30 @@
+int bytestart[5000 + 1];
+unsigned char modtext[400 + 1];
+unsigned char bytemem[2][45000L + 1];
+
+long
+modlookup (int l)
+{
+  signed char c;
+  long j;
+  long k;
+  signed char w;
+  long p;
+  while (p != 0)
+    {
+      while ((k < bytestart[p + 2]) && (j <= l) && (modtext[j] == bytemem[w][k]))
+	{
+	  k = k + 1;
+	  j = j + 1;
+	}
+      if (k == bytestart[p + 2])
+	if (j > l)
+	  c = 1;
+	else c = 4;
+      else if (j > l)
+	c = 3;
+      else if (modtext[j] < bytemem[w][k])
+	c = 0;
+      else c = 2;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930623-1.c b/gcc/testsuite/gcc.c-torture/compile/930623-1.c
new file mode 100644
index 00000000000..4b5b90bd848
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930623-1.c
@@ -0,0 +1,7 @@
+g (a, b) {}
+
+f (xx)
+     void* xx;
+{
+  __builtin_apply ((void*)g, xx, 200);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930702-1.c b/gcc/testsuite/gcc.c-torture/compile/930702-1.c
new file mode 100644
index 00000000000..9f51dd876ee
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930702-1.c
@@ -0,0 +1,5 @@
+f ()
+{
+  {({});}
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930926-1.c b/gcc/testsuite/gcc.c-torture/compile/930926-1.c
new file mode 100644
index 00000000000..fcfa4fbc499
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930926-1.c
@@ -0,0 +1,7 @@
+int f () { return 0; }
+
+void
+test ()
+{
+    int j = { f() };
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/930927-1.c b/gcc/testsuite/gcc.c-torture/compile/930927-1.c
new file mode 100644
index 00000000000..81a4979f482
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/930927-1.c
@@ -0,0 +1,3 @@
+#include <stddef.h>
+
+wchar_t s[5] = L"abcd";
diff --git a/gcc/testsuite/gcc.c-torture/compile/931003-1.c b/gcc/testsuite/gcc.c-torture/compile/931003-1.c
new file mode 100644
index 00000000000..922b14379c9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/931003-1.c
@@ -0,0 +1,15 @@
+f (n, a)
+     int n;
+     double a[];
+{
+   double b[51];
+   int i, j;
+
+   i = 0;
+
+   for (j = n - 1; j > 0; j--)
+     b[i++] = 0;
+
+   if (b[0] > b[i - 1])
+     a[i] = b[i - 1];
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/931004-1.c b/gcc/testsuite/gcc.c-torture/compile/931004-1.c
new file mode 100644
index 00000000000..0e741fd4ac0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/931004-1.c
@@ -0,0 +1,8 @@
+#define A "This is a long test that tests the structure initialization"
+#define B A,A
+#define C B,B,B,B
+#define D C,C,C,C
+int main()
+{
+  char *subs[]={ D, D, D, D, D, D, D, D, D, D, D, D, D, D, D};
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/931013-1.c b/gcc/testsuite/gcc.c-torture/compile/931013-1.c
new file mode 100644
index 00000000000..c237c0b7341
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/931013-1.c
@@ -0,0 +1,10 @@
+g ();
+
+f ()
+{
+  long ldata[2];
+  int seed;
+
+  seed = (ldata[0]) + (ldata[1] << 16);
+  g (seed);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/931013-2.c b/gcc/testsuite/gcc.c-torture/compile/931013-2.c
new file mode 100644
index 00000000000..8fc0db492ab
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/931013-2.c
@@ -0,0 +1,20 @@
+f (unsigned short Z[48])
+{
+  int j;
+  unsigned short t1, t2, t3, T[48];
+  unsigned short *p = T + 48;
+
+  for (j = 1; j < 8; j++)
+    {
+      t1 = *Z++;
+      *--p = *Z++;
+      *--p = t1;
+      t1 = inv(*Z++);
+      t2 = -*Z++;
+      t3 = -*Z++;
+      *--p = inv(*Z++);
+      *--p = t2;
+      *--p = t3;
+      *--p = t1;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/931013-3.c b/gcc/testsuite/gcc.c-torture/compile/931013-3.c
new file mode 100644
index 00000000000..e663b9acc1c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/931013-3.c
@@ -0,0 +1,11 @@
+struct s
+{
+  int f;
+};
+
+struct s
+f ()
+{
+  int addr;
+  return *(struct s *) &addr;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/931018-1.c b/gcc/testsuite/gcc.c-torture/compile/931018-1.c
new file mode 100644
index 00000000000..7efe40ec094
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/931018-1.c
@@ -0,0 +1,14 @@
+typedef struct
+{
+  int a, b;
+} T;
+
+f (T *bs)
+{
+  long long x;
+  x = ({
+    union { T s; long long l; } u;
+    u.s = *bs;
+    u.l;
+  });
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/931031-1.c b/gcc/testsuite/gcc.c-torture/compile/931031-1.c
new file mode 100644
index 00000000000..9015f54f7bf
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/931031-1.c
@@ -0,0 +1,9 @@
+struct s
+{
+  int pad:1, no:1;
+};
+
+f (struct s *b, int c)
+{
+  char d = b->no && c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/931102-1.c b/gcc/testsuite/gcc.c-torture/compile/931102-1.c
new file mode 100644
index 00000000000..a039c26331c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/931102-1.c
@@ -0,0 +1,111 @@
+char *e ();
+
+#define SET \
+  if (d > *b++) d |= a; \
+  if (b) b = e(b);
+
+xxx()
+{
+  int a, d;
+  char *b, *c;
+
+  while (1) {
+    while (1) {
+      while (1) {
+	if (a) {
+	  switch (a) {
+	  case 1:
+	    while (1) {
+	      SET
+		do {
+		  SET
+		} while (1);
+	    }
+	  case 2:
+	    while (1) {
+	      if (d) {
+		do {
+		  SET
+		} while (1);
+	      }
+	      else {
+		do {
+		  SET
+		} while (1);
+	      }
+	    }
+	  case 3:
+	    while (1) {
+	      if (d) {
+		do {
+		  SET
+		} while (1);
+	      }
+	      else {
+		do {
+		  SET
+		} while (1);
+	      }
+	    }
+	  case 4:
+	    while (1) {
+	      if (d) {
+		do {
+		  SET
+		} while (1);
+	      }
+	      else {
+		do {
+		  SET
+		} while (1);
+	      }
+	    }
+	  }
+	}
+	else {
+	  switch (a) {
+	  case 2:
+	    while (1) {
+	      if (d) {
+		do {
+		  SET
+		} while (1);
+	      }
+	      else {
+		do {
+		  SET
+		} while (1);
+	      }
+	    }
+	  case 3:
+	    while (1) {
+	      if (d) {
+		do {
+		  SET
+		} while (1);
+	      }
+	      else {
+		do {
+		  SET
+		} while (1);
+	      }
+	    }
+	  case 4:
+	    while (1) {
+	      if (d) {
+		do {
+		  SET
+		} while (1);
+	      }
+	      else {
+		do {
+		  SET
+		} while (1);
+	      }
+	    }
+	  }
+	}
+      }
+    }
+  }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/931102-2.c b/gcc/testsuite/gcc.c-torture/compile/931102-2.c
new file mode 100644
index 00000000000..f39b271645d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/931102-2.c
@@ -0,0 +1,21 @@
+typedef struct {
+  int a;
+} VCR;
+
+typedef struct {
+  VCR vcr[8];
+} VCRC;
+
+typedef struct {
+  char vcr;
+} OWN;
+
+OWN Own[16];
+
+f (x, own)
+  VCRC *x;
+  OWN *own;
+{
+  x[own->vcr / 8].vcr[own->vcr % 8].a--;
+  x[own->vcr / 8].vcr[own->vcr % 8].a = x[own->vcr / 8].vcr[own->vcr % 8].a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/931203-1.c b/gcc/testsuite/gcc.c-torture/compile/931203-1.c
new file mode 100644
index 00000000000..3007ff582e0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/931203-1.c
@@ -0,0 +1,5 @@
+v (a, i)
+     unsigned  *a, i;
+{
+  a++[i] = 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/940611-1.c b/gcc/testsuite/gcc.c-torture/compile/940611-1.c
new file mode 100644
index 00000000000..90f72486ada
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/940611-1.c
@@ -0,0 +1,10 @@
+f ()
+{
+  do
+L:;
+  while (0);
+  do
+    ;
+  while (0);
+  goto L;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/940712-1.c b/gcc/testsuite/gcc.c-torture/compile/940712-1.c
new file mode 100644
index 00000000000..10a6961dcb7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/940712-1.c
@@ -0,0 +1,4 @@
+f ()
+{
+  return (*(volatile unsigned int *)8000) / 3;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/940718-1.c b/gcc/testsuite/gcc.c-torture/compile/940718-1.c
new file mode 100644
index 00000000000..505280fa91e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/940718-1.c
@@ -0,0 +1,7 @@
+extern double log (double) __attribute__ ((const));
+
+f (double x)
+{
+  for (;;)
+    exp(log(x));
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/941014-1.c b/gcc/testsuite/gcc.c-torture/compile/941014-1.c
new file mode 100644
index 00000000000..d31701572fc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/941014-1.c
@@ -0,0 +1,11 @@
+f (to)
+     char *to;
+{
+  unsigned int wch;
+  register length;
+  unsigned char tmp;
+  unsigned int mult = 10;
+
+  tmp = (wch>>(unsigned int)(length * mult));
+  *to++ = (unsigned char)tmp;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/941014-2.c b/gcc/testsuite/gcc.c-torture/compile/941014-2.c
new file mode 100644
index 00000000000..01e9a672e88
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/941014-2.c
@@ -0,0 +1,37 @@
+void
+f (n, ppt, xrot)
+{
+  int tileWidth;
+  int nlwSrc;
+  int srcx;
+  int v3, v4;
+  register unsigned long ca1, cx1, ca2, cx2;
+  unsigned long *pSrcLine;
+  register unsigned long *pDst;
+  register unsigned long *pSrc;
+  register unsigned long b, tmp;
+  unsigned long tileEndMask;
+  int v1, v2;
+  int tileEndPart;
+  int needFirst;
+  tileEndPart = 0;
+  v1 = tileEndPart << 5;
+  v2 = 32 - v1;
+  while (n--)
+    {
+      if ((srcx = (ppt - xrot) % tileWidth) < 0)
+	if (needFirst)
+	  if (nlwSrc == 1)
+	    {
+	      tmp = b;
+	      if (tileEndPart)
+		b = (*pSrc & tileEndMask) | (*pSrcLine >> v1);
+	    }
+      if (tileEndPart)
+	b = (tmp << v1) | (b >> v2);
+      if (v4 != 32)
+	*pDst = (*pDst & ((tmp << v3) | (b >> v4) & ca1 ^ cx1)
+		 ^ (((tmp << v3) | (b >> v4)) & ca2 ^ cx2));
+      *pDst = *pDst & tmp;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/941014-3.c b/gcc/testsuite/gcc.c-torture/compile/941014-3.c
new file mode 100644
index 00000000000..6dcb89395e3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/941014-3.c
@@ -0,0 +1,72 @@
+typedef unsigned char byte;
+typedef unsigned int uint;
+typedef unsigned long ulong;
+typedef ulong gs_char;
+typedef struct gs_show_enum_s gs_show_enum;
+typedef struct gs_font_s gs_font;
+typedef struct gx_font_stack_item_s {
+  gs_font *font;
+} gx_font_stack_item;
+typedef struct gx_font_stack_s {
+  gx_font_stack_item items[1 + 5 ];
+} gx_font_stack;
+struct gs_show_enum_s {
+  gx_font_stack fstack;
+};
+typedef enum {
+  ft_composite = 0,
+} font_type;
+struct gs_font_s {
+  font_type FontType;
+};
+typedef enum {
+  fmap_escape = 3,
+  fmap_shift = 8
+  } fmap_type;
+typedef struct gs_type0_data_s {
+  fmap_type FMapType;
+} gs_type0_data;
+gs_type0_next_char(register gs_show_enum *penum)
+{
+  const byte *p;
+  int fdepth;
+  gs_font *pfont;
+  gs_type0_data *pdata;
+  uint fidx;
+  gs_char chr;
+  for (; pfont->FontType == ft_composite; )
+    {
+      fmap_type fmt;
+      switch ( fmt )
+	{
+	  do {} while (0);
+	rdown:
+	  continue;
+	case fmap_shift:
+	  p++;
+	  do {} while (0);
+	  goto rdown;
+	}
+      break;
+    }
+ up:
+  while ( fdepth > 0 )
+    {
+      switch ( pdata->FMapType )
+	{
+	default:
+	  continue;
+	case fmap_escape:
+	  fidx = *++p;
+	  do {} while (0);
+	  if ( fidx == chr && fdepth > 1 )
+	    goto up;
+	down:
+	  fdepth--;
+	  do {} while (0);
+	}
+      break;
+    }
+  while ( (pfont = penum->fstack.items[fdepth].font)->FontType == ft_composite )
+    ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/941014-4.c b/gcc/testsuite/gcc.c-torture/compile/941014-4.c
new file mode 100644
index 00000000000..9e673f37833
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/941014-4.c
@@ -0,0 +1,16 @@
+#ifndef NO_LABEL_VALUES
+f (int *re)
+{
+  int *loops = 0, *loope = 0;
+  unsigned dat0 = 0;
+  static void *debug = &&firstdebug;
+
+ firstdebug:
+  g (loops, loope);
+
+  if (dat0 & 1)
+    re[(dat0 >> 2) & 3] = 0;
+}
+#else
+int x;
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compile/941019-1.c b/gcc/testsuite/gcc.c-torture/compile/941019-1.c
new file mode 100644
index 00000000000..257b594c1b6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/941019-1.c
@@ -0,0 +1 @@
+__complex__ long double sub (__complex__ long double cld) { return cld; }
diff --git a/gcc/testsuite/gcc.c-torture/compile/941111-1.c b/gcc/testsuite/gcc.c-torture/compile/941111-1.c
new file mode 100644
index 00000000000..3f0c28bef12
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/941111-1.c
@@ -0,0 +1,8 @@
+main ()
+{
+  struct S { int i; char c; } obj1, obj2;
+
+  foo ();
+  if (obj1.c != obj2.c)
+    bar ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/941113-1.c b/gcc/testsuite/gcc.c-torture/compile/941113-1.c
new file mode 100644
index 00000000000..5c2e0b68c56
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/941113-1.c
@@ -0,0 +1,12 @@
+typedef void foo (void);
+
+f (x)
+{
+  if (x)
+    {
+      const foo* v;
+      (*v)();
+    }
+  else
+    g (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950122-1.c b/gcc/testsuite/gcc.c-torture/compile/950122-1.c
new file mode 100644
index 00000000000..8dea7905093
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950122-1.c
@@ -0,0 +1,5 @@
+int
+foo (int i, unsigned short j)
+{
+  return j *= i;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950124-1.c b/gcc/testsuite/gcc.c-torture/compile/950124-1.c
new file mode 100644
index 00000000000..e723954a0c1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950124-1.c
@@ -0,0 +1,15 @@
+f ()
+{
+  if (g ())
+    h ();
+  else
+    {
+      do
+	{
+	  return 0;
+	  break;
+	}
+      while (1);
+    }
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950221-1.c b/gcc/testsuite/gcc.c-torture/compile/950221-1.c
new file mode 100644
index 00000000000..14147638668
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950221-1.c
@@ -0,0 +1,16 @@
+short v = -1;
+
+typedef struct
+{
+  short network;
+} atype;
+
+void f ()
+{
+  static atype config;
+  atype *cp;
+  short net;
+  cp = &config;
+  cp->network = (v == -1) ? 100 : v;
+  net = cp->network;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950329-1.c b/gcc/testsuite/gcc.c-torture/compile/950329-1.c
new file mode 100644
index 00000000000..7c047f5a59c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950329-1.c
@@ -0,0 +1,19 @@
+f ()
+{
+  int i;
+  for (i = 1;; i = 0)
+    {
+      if (h ())
+	{
+	  if (i)
+	    g ();
+	  g (h ());
+	  g (h ());
+	}
+      else
+	{
+	  g ();
+	  break;
+	}
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950512-1.c b/gcc/testsuite/gcc.c-torture/compile/950512-1.c
new file mode 100644
index 00000000000..e43ec48d165
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950512-1.c
@@ -0,0 +1,6 @@
+typedef unsigned short uint16;
+f (unsigned char *w)
+{
+  w[2] = (uint16) ((((g (0) % 10000 + 42) & 0xFF) << 8) | (((g (0) % 10000 + 42) >> 8) & 0xFF)) & 0xFF,
+  w[3] = (uint16) ((((g (0) % 10000 + 42) & 0xFF) << 8) | (((g (0) % 10000 + 42) >> 8) & 0xFF)) >> 8;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950530-1.c b/gcc/testsuite/gcc.c-torture/compile/950530-1.c
new file mode 100644
index 00000000000..2b714e059bc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950530-1.c
@@ -0,0 +1,4 @@
+f (int *s, int *t)
+{
+  return (t - s) / 2;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950607-1.c b/gcc/testsuite/gcc.c-torture/compile/950607-1.c
new file mode 100644
index 00000000000..851defce34c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950607-1.c
@@ -0,0 +1,38 @@
+typedef struct {
+  int component_id;
+  int component_index;
+  int h_samp_factor;
+  int v_samp_factor;
+} jpeg_component_info;
+struct jpeg_common_struct {
+  struct jpeg_error_mgr * err;
+};
+typedef struct jpeg_common_struct * j_common_ptr;
+typedef struct jpeg_compress_struct * j_compress_ptr;
+struct jpeg_compress_struct {
+  struct jpeg_error_mgr * err;
+  int num_components;
+  jpeg_component_info * comp_info;
+  int max_h_samp_factor;
+  int max_v_samp_factor;
+};
+struct jpeg_error_mgr {
+  int msg_code;
+};
+
+void
+jinit_downsampler (j_compress_ptr cinfo)
+{
+  int ci;
+  jpeg_component_info * compptr;
+
+  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+       ci++, compptr++) {
+    if (compptr->h_samp_factor == cinfo->max_h_samp_factor &&
+	compptr->v_samp_factor == cinfo->max_v_samp_factor) {
+    } else if ((cinfo->max_h_samp_factor % compptr->h_samp_factor) == 0 &&
+	       (cinfo->max_v_samp_factor % compptr->v_samp_factor) == 0) {
+    } else
+      cinfo->err->msg_code = 0;
+  }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950610-1.c b/gcc/testsuite/gcc.c-torture/compile/950610-1.c
new file mode 100644
index 00000000000..16d0d0e60f5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950610-1.c
@@ -0,0 +1 @@
+f (int n, int a[2][n]) {}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950612-1.c b/gcc/testsuite/gcc.c-torture/compile/950612-1.c
new file mode 100644
index 00000000000..cb3cb0a59d6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950612-1.c
@@ -0,0 +1,134 @@
+typedef enum
+{
+  LODI,
+  STO,
+  ADDI,
+  ADD,
+  SUBI,
+  SUB,
+  MULI,
+  MUL,
+  DIVI,
+  DIV,
+  INC,
+  DEC
+} INSN;
+
+f (pc)
+     short *pc;
+{
+  long long stack[16], *sp = &stack[16], acc = 0;
+
+  for (;;)
+    {
+      switch ((INSN)*pc++)
+	{
+	case LODI:
+	  *--sp = acc;
+	  acc = ((long long)*pc++) << 32;
+	  break;
+	case STO:
+	  return (acc >> 32) + (((((unsigned long long) acc) & 0xffffffff)  & (1 << 31)) != 0);
+	  break;
+	case ADDI:
+	  acc += ((long long)*pc++) << 32;
+	  break;
+	case ADD:
+	  acc = *sp++ + acc;
+	  break;
+	case SUBI:
+	  acc -= ((long long)*pc++) << 32;
+	  break;
+	case SUB:
+	  acc = *sp++ - acc;
+	  break;
+	case MULI:
+	  acc *= *pc++;
+	  break;
+	case MUL:
+	  {
+	    long long aux;
+	    unsigned char minus;
+
+	    minus = 0;
+	    aux = *sp++;
+	    if (aux < 0)
+	      {
+		minus = ~minus;
+		aux = -aux;
+	      }
+	    if (acc < 0)
+	      {
+		minus = ~minus;
+		acc = -acc;
+	      }
+	    acc = ((((((unsigned long long) acc) & 0xffffffff)  * (((unsigned long long) aux) & 0xffffffff)) >> 32)
+		   + ((((unsigned long long) acc) >> 32)  * (((unsigned long long) aux) & 0xffffffff)  + (((unsigned long long) acc) & 0xffffffff)  + (((unsigned long long) aux) >> 32))
+		   + (((((unsigned long long) acc) >> 32)  * (((unsigned long long) aux) >> 32)) << 32));
+	    if (minus)
+	      acc = -acc;
+	  }
+	  break;
+	case DIVI:
+	  {
+	    short aux;
+
+	    aux = *pc++;
+	    acc = (acc + aux / 2) / aux;
+	  }
+	  break;
+	case DIV:
+	  {
+	    long long aux;
+	    unsigned char minus;
+
+	    minus = 0;
+	    aux = *sp++;
+	    if (aux < 0)
+	      {
+		minus = ~minus;
+		aux = -aux;
+	      }
+	    if (acc < 0)
+	      {
+		minus = ~minus;
+		acc = -acc;
+	      }
+
+	    if (((unsigned long long)acc)  == 0)
+	      acc = (unsigned long long)-1 / 2;
+	    else if ((((unsigned long long) ((unsigned long long)acc)) & 0xffffffff)  == 0)
+	      acc = ((unsigned long long)aux)  / (((unsigned long long) ((unsigned long long)acc)) >> 32);
+	    else if ((((unsigned long long) ((unsigned long long)acc)) >> 32)  == 0)
+	      acc = ((((unsigned long long)aux)  / ((unsigned long long)acc)) << 32)
+		+ ((((unsigned long long)aux)  % ((unsigned long long)acc)) << 32) / ((unsigned long long)acc);
+	    else
+	      {
+		unsigned char shift;
+		unsigned long hi;
+
+		shift = 32;
+		hi = (((unsigned long long) ((unsigned long long)acc)) >> 32);
+		do {
+		  if (hi & ((unsigned long)1 << (shift - 1)))
+		    break;
+		} while (--shift != 0);
+		printf("shift = %d\n", shift);
+		acc = ((((unsigned long long)aux)  / ((unsigned long long)acc)) << 32)
+		  + (((((unsigned long long)aux)  % ((unsigned long long)acc)) << (32 - shift)) + ((((unsigned long long)acc)  >> shift) / 2)) / (((unsigned long long)acc)  >> shift);
+	      }
+
+	    if (minus)
+	      acc = -acc;
+	  }
+	  break;
+	case INC:
+	  acc += 1;
+	  break;
+	case DEC:
+	  acc -= 1;
+	  break;
+	}
+      printf("%08lx.%08lx\n", (long)(((unsigned long long) acc) >> 32) , (long)(((unsigned long long) acc) & 0xffffffff));
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950613-1.c b/gcc/testsuite/gcc.c-torture/compile/950613-1.c
new file mode 100644
index 00000000000..8aa757f476c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950613-1.c
@@ -0,0 +1,31 @@
+#ifndef NO_LABEL_VALUES
+f ()
+{
+  long *sp;
+  long *pc;
+
+  static void *dummy[] =
+    {
+      &&L1,
+      &&L2,
+    };
+
+ L1:
+  {
+    float val;
+    val = *(float *) sp;
+    val = -val;
+    *(float *) sp = val;
+    goto *pc++;
+  }
+
+ L2:
+  {
+    float from;
+    *(long long *) sp = from;
+    goto *pc++;
+  }
+}
+#else
+int x;
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compile/950618-1.c b/gcc/testsuite/gcc.c-torture/compile/950618-1.c
new file mode 100644
index 00000000000..4229da4e9bf
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950618-1.c
@@ -0,0 +1,2 @@
+static __inline__ int f () { return g (); }
+int g () { return f (); }
diff --git a/gcc/testsuite/gcc.c-torture/compile/950719-1.c b/gcc/testsuite/gcc.c-torture/compile/950719-1.c
new file mode 100644
index 00000000000..d3277fada4e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950719-1.c
@@ -0,0 +1,11 @@
+typedef struct
+{
+  int Header;
+  char data[4092];
+} t_node;
+
+f (unsigned short rid, unsigned short record_length)
+{
+  t_node tnode;
+  g (rid, tnode.data + rid * record_length);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950729-1.c b/gcc/testsuite/gcc.c-torture/compile/950729-1.c
new file mode 100644
index 00000000000..cfdbad9206f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950729-1.c
@@ -0,0 +1,39 @@
+static const char * const lcset = "0123456789abcdef";
+static const char * const ucset = "0123456789ABCDEF";
+
+char *
+f (char *buffer, long long value, char type)
+{
+  int base, i;
+
+  i = 128  - 1;
+  buffer[i--] = '\0';
+
+  switch (type)
+    {
+    case 'u':
+    case 'o':
+    case 'x':
+    case 'X':
+      if (type == 'u')
+	base = 10;
+      else if (type == 'o')
+	base = 8;
+      else
+	base = 16;
+
+      while (i >= 0)
+	{
+	  if (type == 'X')
+	    buffer[i--] = ucset[((unsigned long long) value) % base];
+	  else
+	    buffer[i--] = lcset[((unsigned long long) value) % base];
+
+	  if ((value = ((unsigned long long) value) / base) == 0)
+	    break;
+	}
+      break;
+    }
+
+  return &buffer[++i];
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950816-1.c b/gcc/testsuite/gcc.c-torture/compile/950816-1.c
new file mode 100644
index 00000000000..da849bbad0a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950816-1.c
@@ -0,0 +1,7 @@
+f ()
+{
+  unsigned char b[2];
+  float f;
+  b[0] = (unsigned char) f / 256;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950816-2.c b/gcc/testsuite/gcc.c-torture/compile/950816-2.c
new file mode 100644
index 00000000000..41e770d177d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950816-2.c
@@ -0,0 +1,8 @@
+f ()
+{
+  int i;
+  float a,b,c;
+  unsigned char val[2];
+  i = func (&c);
+  val[0] = c < a ? a : c >= 1.0 ? b : c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950816-3.c b/gcc/testsuite/gcc.c-torture/compile/950816-3.c
new file mode 100644
index 00000000000..b3cb0fca377
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950816-3.c
@@ -0,0 +1,8 @@
+f ()
+{
+  int i;
+  short	x, z;
+  for (i = 0; i <= 1; i++)
+    x = i;
+  return x + z;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950910-1.c b/gcc/testsuite/gcc.c-torture/compile/950910-1.c
new file mode 100644
index 00000000000..1be2aa55e68
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950910-1.c
@@ -0,0 +1,22 @@
+f (char *p)
+{
+  char c;
+
+  c = *++p;
+  if (c != ' ')
+    return 0;
+  for (;;)
+    {
+      c = *p;
+      if (g (c))
+	p++;
+      else
+	{
+	  if (c == ' ')
+	    break;
+	  else
+	    return 0;
+	}
+    }
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950919-1.c b/gcc/testsuite/gcc.c-torture/compile/950919-1.c
new file mode 100644
index 00000000000..8320f6d025a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950919-1.c
@@ -0,0 +1,5 @@
+#define empty
+#if empty#cpu(m68k)
+#endif
+
+f (){}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950921-1.c b/gcc/testsuite/gcc.c-torture/compile/950921-1.c
new file mode 100644
index 00000000000..371c7d569c5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950921-1.c
@@ -0,0 +1,12 @@
+f ()
+{
+  union
+    {
+      signed char c;
+      double d;
+    } u;
+
+  u.c = 1;
+  u.c = 1;
+  return u.c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/950922-1.c b/gcc/testsuite/gcc.c-torture/compile/950922-1.c
new file mode 100644
index 00000000000..73574f33e68
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/950922-1.c
@@ -0,0 +1,68 @@
+struct sw {
+  const void *x;
+  int r;
+};
+struct sq {
+  struct sw *q_w;
+  int t;
+  int z;
+};
+
+int
+f (int ch, char *fp, char *ap)
+{
+  register int n;
+  register char *cp;
+  register struct sw *p;
+  register int f;
+  int prec;
+  double _double;
+  int expt;
+  int ndig;
+  char expstr[7];
+  unsigned long long _uquad;
+  struct sq q;
+  struct sw w[8];
+  static char zeroes[16];
+
+  for (;;) {
+    switch (ch) {
+    case 'd':
+      _double = (double) (ap += 8, *((double *) (ap - 8)));
+      break;
+    case 'o':
+      goto nosign;
+    case 'u':
+      _uquad = (f & 0x020 ? (ap += 8, *((long long *) (ap - 8))) : f & 0x010 ? (ap += 4, *((long *) (ap - 4))) : f & 0x040 ? (long)(short)(ap += 4, *((int *) (ap - 4))) : (long)(ap += 4, *((int *) (ap - 4))));
+      goto nosign;
+    case 'x':
+      _uquad = (f & 0x020 ? (ap += 8, *((long long *) (ap - 8))) : f & 0x010 ? (ap += 4, *((long *) (ap - 4))) : f & 0x040 ? (long)(unsigned short)(ap += 4, *((int *) (ap - 4))) : (long)(ap += 4, *((int *) (ap - 4))));
+    nosign:
+      if (_uquad != 0 || prec != 0);
+      break;
+    default:
+    }
+    if ((f & 0x100) == 0) {
+    } else {
+      if (ch >= 'f') {
+	if (_double == 0) {
+	  if (expt < ndig || (f & 0x001) != 0) {
+	    { if ((n = (ndig - 1)) > 0) { while (n > 16) {{ p->x = (zeroes); p->r = 16; q.z += 16; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }} n -= 16; }{ p->x = (zeroes); p->r = n; q.z += n; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}}}
+	  }
+	} else if (expt <= 0) {
+	  { p->x = ("0"); p->r = 1; q.z += 1; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
+	  { p->x = 0; p->r = 1; q.z += 1; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
+	  { if ((n = (-expt)) > 0) { while (n > 16) {{ p->x = (zeroes); p->r = 16; q.z += 16; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }} n -= 16; }{ p->x = (zeroes); p->r = n; q.z += n; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }} }}
+	  { p->x = cp; p->r = ndig; q.z += ndig; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
+	} else {
+	  { p->x = cp; p->r = expt; q.z += expt; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
+	  cp += expt;
+	  { p->x = ("."); p->r = 1; q.z += 1; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
+	  { p->x = cp; p->r = (ndig-expt); q.z += (ndig-expt); p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
+	}
+      }
+    }
+  }
+
+ error:
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/951004-1.c b/gcc/testsuite/gcc.c-torture/compile/951004-1.c
new file mode 100644
index 00000000000..1ca60819cdd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/951004-1.c
@@ -0,0 +1,23 @@
+typedef struct
+{
+  short v, h;
+} S;
+
+S a;
+
+f (S pnt)
+{
+  S mpnt, mtp;
+
+  (&pnt)->v -= 1;
+  mpnt = pnt;
+  mtp = a;
+  if (mtp.v != mpnt.v)
+    {
+      S tpnt;
+
+      tpnt = mtp;
+      mtp = mpnt;
+      mpnt = tpnt;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/951106-1.c b/gcc/testsuite/gcc.c-torture/compile/951106-1.c
new file mode 100644
index 00000000000..09cba20c1d0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/951106-1.c
@@ -0,0 +1,4 @@
+f (double a, double b)
+{
+  g (a, 0, b);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/951116-1.c b/gcc/testsuite/gcc.c-torture/compile/951116-1.c
new file mode 100644
index 00000000000..100d6902a72
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/951116-1.c
@@ -0,0 +1,9 @@
+f ()
+{
+  long long i;
+  int j;
+  long long k = i = j;
+
+  int inner () {return j + i;}
+  return k;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/951128-1.c b/gcc/testsuite/gcc.c-torture/compile/951128-1.c
new file mode 100644
index 00000000000..5e4dc7093c8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/951128-1.c
@@ -0,0 +1,5 @@
+char a[];
+f (const int i)
+{
+  a[i] = 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/951220-1.c b/gcc/testsuite/gcc.c-torture/compile/951220-1.c
new file mode 100644
index 00000000000..33e98f6221e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/951220-1.c
@@ -0,0 +1,4 @@
+f (char *x)
+{
+  return (*x & 2) || (*x & 3);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/951222-1.c b/gcc/testsuite/gcc.c-torture/compile/951222-1.c
new file mode 100644
index 00000000000..b8246f5fe81
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/951222-1.c
@@ -0,0 +1,15 @@
+extern long long foo ();
+
+long long
+sub1 ()
+{
+  char junk[10000];
+  register long long a, b, c;
+
+  b = foo ();
+
+  setjmp ();
+  a = foo ();
+  c = a - b;
+  return c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/960106-1.c b/gcc/testsuite/gcc.c-torture/compile/960106-1.c
new file mode 100644
index 00000000000..c8228aab587
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/960106-1.c
@@ -0,0 +1,4 @@
+f (a)
+{
+  return (a & 1) && !(a & 2 & 4);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/960130-1.c b/gcc/testsuite/gcc.c-torture/compile/960130-1.c
new file mode 100644
index 00000000000..ed8dab45988
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/960130-1.c
@@ -0,0 +1,8 @@
+int a[1];
+
+int
+main()
+{
+  extern int a[];
+  return *a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/960201-1.c b/gcc/testsuite/gcc.c-torture/compile/960201-1.c
new file mode 100644
index 00000000000..adc462389d2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/960201-1.c
@@ -0,0 +1,5 @@
+union foo
+{
+  char a;
+  int x[2];
+} __attribute__ ((transparent_union));
diff --git a/gcc/testsuite/gcc.c-torture/compile/960218-1.c b/gcc/testsuite/gcc.c-torture/compile/960218-1.c
new file mode 100644
index 00000000000..46fbf778524
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/960218-1.c
@@ -0,0 +1,2 @@
+#define X(x) x
+int main() { return X(0/* *//* */); }
diff --git a/gcc/testsuite/gcc.c-torture/compile/960220-1.c b/gcc/testsuite/gcc.c-torture/compile/960220-1.c
new file mode 100644
index 00000000000..766a066c449
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/960220-1.c
@@ -0,0 +1,6 @@
+f ()
+{
+  unsigned long long int a = 0, b;
+  while (b > a)
+    ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/960221-1.c b/gcc/testsuite/gcc.c-torture/compile/960221-1.c
new file mode 100644
index 00000000000..0e02496c104
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/960221-1.c
@@ -0,0 +1,11 @@
+struct s1 { int f1; };
+
+struct s2 {
+  struct s1 a;
+  int f2;
+};
+
+foo (struct s2 *ptr)
+{
+  *ptr = (struct s2) {{}, 0};
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/960319-1.c b/gcc/testsuite/gcc.c-torture/compile/960319-1.c
new file mode 100644
index 00000000000..f3d95ab6e8e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/960319-1.c
@@ -0,0 +1,10 @@
+static void
+f()
+{
+  long long a[2];
+  int i;
+  if (g())
+    if (h())
+      ;
+  *a |= (long long)i << 65 ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/960514-1.c b/gcc/testsuite/gcc.c-torture/compile/960514-1.c
new file mode 100644
index 00000000000..1d38cfd1a0b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/960514-1.c
@@ -0,0 +1,12 @@
+struct s {
+  unsigned long long t[5];
+};
+
+void
+f (struct s *d, unsigned long long *l)
+{
+  int i;
+
+  for (i = 0; i < 5; i++)
+    d->t[i] += l[i];
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/960704-1.c b/gcc/testsuite/gcc.c-torture/compile/960704-1.c
new file mode 100644
index 00000000000..5a9d35cfd9a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/960704-1.c
@@ -0,0 +1,10 @@
+struct A {
+  double d;
+};
+
+struct A f ();
+
+main ()
+{
+  struct A a = f();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/960829-1.c b/gcc/testsuite/gcc.c-torture/compile/960829-1.c
new file mode 100644
index 00000000000..8c6163dfaf0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/960829-1.c
@@ -0,0 +1,4 @@
+f ()
+{
+  g (0, 0.0, 0.0, 0.0, 0.0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/961004-1.c b/gcc/testsuite/gcc.c-torture/compile/961004-1.c
new file mode 100644
index 00000000000..6407b625d66
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/961004-1.c
@@ -0,0 +1,37 @@
+void
+f1 (o1, o2, o3, i, j, k)
+     long long *o1, *o2, *o3;
+     int i, j, k;
+{
+  while (--i)
+    o1[i] = o2[j >>= 1] + o3[k >>= 1];
+}
+
+void
+f2 (o1, o2, o3, i, j, k)
+     long long *o1, *o2, *o3;
+     int i, j, k;
+{
+  while (--i)
+    o1[i] = o2[j >>= 1] - o3[k >>= 1];
+}
+
+void
+f3 (o1, o2, o3, i, j, k)
+     long long *o1, *o3;
+     unsigned *o2;
+     int i, j, k;
+{
+  while (--i)
+    o1[i] = o2[j >>= 1] + o3[k >>= 1];
+}
+
+void
+f4 (o1, o2, o3, i, j, k)
+     long long *o1, *o2;
+     unsigned *o3;
+     int i, j, k;
+{
+  while (--i)
+    o1[i] = o2[j >>= 1] - o3[k >>= 1];
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/961010-1.c b/gcc/testsuite/gcc.c-torture/compile/961010-1.c
new file mode 100644
index 00000000000..d6145bc4233
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/961010-1.c
@@ -0,0 +1 @@
+double f (double x) { return x == 0 ? x : 0.0; }
diff --git a/gcc/testsuite/gcc.c-torture/compile/961019-1.c b/gcc/testsuite/gcc.c-torture/compile/961019-1.c
new file mode 100644
index 00000000000..0ea6ec6e280
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/961019-1.c
@@ -0,0 +1,11 @@
+char _hex_value[256];
+
+void
+hex_init ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    _hex_value[i] = 99;
+  for (i = 0; i < 10; i++)
+    _hex_value['0' + i] = i;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/961031-1.c b/gcc/testsuite/gcc.c-torture/compile/961031-1.c
new file mode 100644
index 00000000000..ea8718f763b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/961031-1.c
@@ -0,0 +1,16 @@
+struct s {
+  double d;
+} sd;
+
+struct s g () __attribute__ ((const));
+
+struct s
+g ()
+{
+  return sd;
+}
+
+f ()
+{
+  g ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/961126-1.c b/gcc/testsuite/gcc.c-torture/compile/961126-1.c
new file mode 100644
index 00000000000..f3b6af55595
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/961126-1.c
@@ -0,0 +1,107 @@
+int *p;
+
+main()
+{
+  int i = sub ();
+
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+  i = -i;
+  if (*p != i)
+    goto quit;
+
+  i = -i;
+quit:
+  sub2 (i);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/961203-1.c b/gcc/testsuite/gcc.c-torture/compile/961203-1.c
new file mode 100644
index 00000000000..0f066ace617
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/961203-1.c
@@ -0,0 +1,14 @@
+struct s {
+  char a[0x32100000];
+  int x:30, y:30;
+};
+
+int
+main ()
+{
+  struct s* p;
+
+  p = (struct s*) 0;
+  if (p->x == p->y)
+    exit (1);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/961203-1.x b/gcc/testsuite/gcc.c-torture/compile/961203-1.x
new file mode 100644
index 00000000000..dad1a21aaae
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/961203-1.x
@@ -0,0 +1,7 @@
+# This doesn't work on any host with 32 bit int or smaller.
+
+# Because this test tends to consume lots of system resources and doesn't
+# currently work, don't actually run it.  Just report a failure.
+setup_xfail "*-*-*"
+fail "gcc.c-torture/compile/961203-1.c"
+return 1 ;# `1' says we handled the testcase ourselves
diff --git a/gcc/testsuite/gcc.c-torture/compile/970206-1.c b/gcc/testsuite/gcc.c-torture/compile/970206-1.c
new file mode 100644
index 00000000000..95196cd6a54
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/970206-1.c
@@ -0,0 +1,13 @@
+struct Rect
+{
+  int iA;
+  int iB;
+  int iC;
+  int iD;
+};
+
+void
+f (int * const this, struct Rect arect)
+{
+  g (*this, arect);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/970214-1.c b/gcc/testsuite/gcc.c-torture/compile/970214-1.c
new file mode 100644
index 00000000000..508ea9e92b6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/970214-1.c
@@ -0,0 +1,3 @@
+#include <stddef.h>
+#define L       264
+wchar_t c = L'X';
diff --git a/gcc/testsuite/gcc.c-torture/compile/980329-1.c b/gcc/testsuite/gcc.c-torture/compile/980329-1.c
new file mode 100644
index 00000000000..d11b49b01c7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980329-1.c
@@ -0,0 +1,72 @@
+typedef unsigned long int size_t;
+struct re_pattern_buffer
+  {
+    unsigned char *buffer;
+    unsigned long int used;
+  };
+struct re_registers
+  {
+    int *start;
+  };
+
+static const char **regstart, **regend;
+static const char **old_regend;
+
+static int
+re_match_2_internal (struct re_pattern_buffer *bufp,
+		     struct re_registers *regs)
+{
+  unsigned char *p = bufp->buffer;
+  unsigned char *pend = p + bufp->used;
+
+  for (;;)
+    {
+      int highest_active_reg = 1;
+      if (bufp)
+	{
+	  int i;
+	  for (i = 1;; i++)
+	    regs->start[i] = 0;
+	}
+
+      switch ((unsigned int) *p++)
+	{
+	case 1:
+	  {
+	    unsigned char r = *p;
+	    if (r)
+	      highest_active_reg = r;
+	  }
+	  if (p + 2 == pend)
+	    {
+	      char is_a_jump_n = 0;
+	      int mcnt = 0;
+	      unsigned char *p1;
+
+	      p1 = p + 2;
+	      switch (*p1++)
+		{
+		case 2:
+		  is_a_jump_n = 1;
+		case 1:
+		  do { do { mcnt = *p1; } while (0); p1 += 2; } while (0);
+		  if (is_a_jump_n)
+		    p1 = 0;
+		}
+
+	      if (mcnt && *p1 == 0)
+		{
+		  unsigned r;
+		  for (r = 0; r < (unsigned) *p + (unsigned) *(p + 1); r++)
+		    {
+		      if (regend[0] >= regstart[r])
+			regend[r] = old_regend[r];
+		    }
+		  do { while (0 < highest_active_reg + 1) { } } while (0);
+		}
+	    }
+	}
+    }
+
+  return -1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/980408-1.c b/gcc/testsuite/gcc.c-torture/compile/980408-1.c
new file mode 100644
index 00000000000..09bf430406e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980408-1.c
@@ -0,0 +1,129 @@
+typedef struct _RunlengthPacket
+{
+  unsigned short
+    red,
+    green,
+    blue,
+    length;
+  unsigned short
+    index;
+} RunlengthPacket;
+typedef struct _Image
+{
+  int
+    status,
+    temporary;
+  char
+    filename[1664 ];
+  long int
+    filesize;
+  int
+    pipe;
+  char
+    magick[1664 ],
+    *comments,
+    *label,
+    *text;
+  unsigned int
+    matte;
+  unsigned int
+    columns,
+    rows,
+    depth;
+  unsigned int
+    scene,
+    number_scenes;
+  char
+    *montage,
+    *directory;
+  unsigned int
+    colors;
+  double
+    gamma;
+  float
+    x_resolution,
+    y_resolution;
+  unsigned int
+    mean_error_per_pixel;
+  double
+    normalized_mean_error,
+    normalized_maximum_error;
+  unsigned long
+    total_colors;
+  char
+    *signature;
+  unsigned int
+    packets,
+    runlength,
+    packet_size;
+  unsigned char
+    *packed_pixels;
+  long int
+    magick_time;
+  char
+    magick_filename[1664 ];
+  unsigned int
+    magick_columns,
+    magick_rows;
+  char
+    *geometry,
+    *page;
+  unsigned int
+    dispose,
+    delay,
+    iterations;
+  unsigned int
+    orphan;
+  struct _Image
+    *previous,
+    *list,
+    *next;
+} Image;
+  Image *MinifyImage(Image *image)
+{
+  Image
+    *minified_image;
+  register RunlengthPacket
+    *q,
+    *s,
+    *s0,
+    *s1,
+    *s2,
+    *s3;
+  register unsigned int
+    x;
+  unsigned int
+    blue,
+    green,
+    red;
+  unsigned long
+    total_matte,
+    total_blue,
+    total_green,
+    total_red;
+  unsigned short
+    index;
+    for (x=0; x < (image->columns-1); x+=2)
+    {
+      total_red=0;
+      total_green=0;
+      total_blue=0;
+      total_matte=0;
+      s=s0;
+      total_red+=( 3 )*(s->red); total_green+=( 3 )*(s->green); total_blue+=( 3 )*(s->blue); total_matte+=( 3 )*(s->index); s++; ; total_red+=( 7 )*(s->red); total_green+=( 7 )*(s->green); total_blue+=( 7 )*(s->blue); total_matte+=( 7 )*(s->index); s++; ;  total_red+=( 7 )*(s->red); total_green+=( 7 )*(s->green); total_blue+=( 7 )*(s->blue); total_matte+=( 7 )*(s->index); s++; ;  total_red+=( 3 )*(s->red); total_green+=( 3 )*(s->green); total_blue+=( 3 )*(s->blue); total_matte+=( 3 )*(s->index); s++; ;
+      s=s1;
+      total_red+=( 7 )*(s->red); total_green+=( 7 )*(s->green); total_blue+=( 7 )*(s->blue); total_matte+=( 7 )*(s->index); s++; ; total_red+=( 15 )*(s->red); total_green+=( 15 )*(s->green); total_blue+=( 15 )*(s->blue); total_matte+=( 15 )*(s->index); s++; ; total_red+=( 15 )*(s->red); total_green+=( 15 )*(s->green); total_blue+=( 15 )*(s->blue); total_matte+=( 15 )*(s->index); s++; ; total_red+=( 7 )*(s->red); total_green+=( 7 )*(s->green); total_blue+=( 7 )*(s->blue); total_matte+=( 7 )*(s->index); s++; ;
+      s=s2;
+      total_red+=( 7 )*(s->red); total_green+=( 7 )*(s->green); total_blue+=( 7 )*(s->blue); total_matte+=( 7 )*(s->index); s++; ; total_red+=( 15 )*(s->red); total_green+=( 15 )*(s->green); total_blue+=( 15 )*(s->blue); total_matte+=( 15 )*(s->index); s++; ; total_red+=( 15 )*(s->red); total_green+=( 15 )*(s->green); total_blue+=( 15 )*(s->blue); total_matte+=( 15 )*(s->index); s++; ; total_red+=( 7 )*(s->red); total_green+=( 7 )*(s->green); total_blue+=( 7 )*(s->blue); total_matte+=( 7 )*(s->index); s++; ;
+      s=s3;
+      total_red+=( 3 )*(s->red); total_green+=( 3 )*(s->green); total_blue+=( 3 )*(s->blue); total_matte+=( 3 )*(s->index); s++; ; total_red+=( 7 )*(s->red); total_green+=( 7 )*(s->green); total_blue+=( 7 )*(s->blue); total_matte+=( 7 )*(s->index); s++; ;  total_red+=( 7 )*(s->red); total_green+=( 7 )*(s->green); total_blue+=( 7 )*(s->blue); total_matte+=( 7 )*(s->index); s++; ;  total_red+=( 3 )*(s->red); total_green+=( 3 )*(s->green); total_blue+=( 3 )*(s->blue); total_matte+=( 3 )*(s->index); s++; ;
+      red=(unsigned short) ((total_red+63) >> 7);
+      green=(unsigned short) ((total_green+63) >> 7);
+      blue=(unsigned short) ((total_blue+63) >> 7);
+      index=(unsigned short) ((total_matte+63) >> 7);
+      if ((red == q->red) && (green == q->green) && (blue == q->blue) &&
+          (index == q->index) && ((int) q->length < 65535L ))
+        q->length++;
+    }
+  return(minified_image);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/980504-1.c b/gcc/testsuite/gcc.c-torture/compile/980504-1.c
new file mode 100644
index 00000000000..7b757ccd2e8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980504-1.c
@@ -0,0 +1,28 @@
+typedef struct _geom_elem {
+  double        coeffs[6];
+} pGeomDefRec, *pGeomDefPtr;
+typedef struct _mpgeombanddef {
+	int	yOut;		 
+	int	in_width;	 
+} mpGeometryBandRec, *mpGeometryBandPtr;
+typedef void *pointer;
+typedef unsigned char  CARD8;
+typedef CARD8 BytePixel;
+void  BiGL_B  (OUTP,srcimg,width,sline,pedpvt,pvtband)	pointer OUTP;
+pointer *srcimg;
+register int width;
+int sline;
+pGeomDefPtr pedpvt; mpGeometryBandPtr pvtband;
+{
+  register float s, t, st;
+  register int 	isrcline,isrcpix;
+  register int 	srcwidth = pvtband->in_width - 1;
+  register   BytePixel  val;
+  register   BytePixel  *ptrIn, *ptrJn;
+  register double a  = pedpvt->coeffs[0];
+  register double c  = pedpvt->coeffs[2];
+  register double srcpix  = a * ((double)(0.0000))  +	pedpvt->coeffs[1] * (pvtband->yOut + ((double)(0.0000)) ) +	pedpvt->coeffs[4];
+  register double srcline = c * ((double)(0.0000))  +	pedpvt->coeffs[3] * (pvtband->yOut + ((double)(0.0000)) ) +	pedpvt->coeffs[5];
+  if ( (isrcpix >= 0) && (isrcpix < srcwidth) )
+    val =	ptrIn[isrcpix]   * ((float)1. - s - t + st) + ptrIn[isrcpix+1] * (s - st) +	ptrJn[isrcpix]   * (t - st) +	ptrJn[isrcpix+1] * (st) +   (float)0.5 ;
+} 
diff --git a/gcc/testsuite/gcc.c-torture/compile/980506-1.c b/gcc/testsuite/gcc.c-torture/compile/980506-1.c
new file mode 100644
index 00000000000..6ef7796261f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980506-1.c
@@ -0,0 +1,63 @@
+unsigned char	TIFFFax2DMode[20][256];
+unsigned char	TIFFFax2DNextState[20][256];
+unsigned char	TIFFFaxUncompAction[20][256];
+unsigned char	TIFFFaxUncompNextState[20][256];
+unsigned char	TIFFFax1DAction[230][256];
+unsigned char	TIFFFax1DNextState[230][256];
+
+typedef struct tableentry {
+    unsigned short length;
+    unsigned short code;
+    short       runlen;
+} tableentry;
+
+extern tableentry TIFFFaxWhiteCodes[];
+extern tableentry TIFFFaxBlackCodes[];
+
+static short sp_data, sp_bit;
+
+static unsigned char
+fetchByte (inbuf)
+
+unsigned char **inbuf;
+
+{
+    unsigned char byte = **inbuf;
+    (*inbuf)++;
+    return (byte);
+}
+
+static int
+decode_white_run (inbuf)
+
+unsigned char **inbuf;
+
+{
+    short state = sp_bit;
+    short action;
+    int runlen = 0;
+
+    for (;;)
+    {
+	if (sp_bit == 0)
+	{
+	nextbyte:
+	    sp_data = fetchByte (inbuf);
+	}
+
+	action = TIFFFax1DAction[state][sp_data];
+	state = TIFFFax1DNextState[state][sp_data];
+	if (action == 0 )
+	    goto nextbyte;
+	if (action == 1 )
+	    return (-1 );
+	if (action == 210 )
+	    return (-3 );
+	sp_bit = state;
+	action = (TIFFFaxWhiteCodes[ action - 2  ].runlen) ;
+	runlen += action;
+	if (action < 64)
+	    return (runlen);
+    }
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/980506-2.c b/gcc/testsuite/gcc.c-torture/compile/980506-2.c
new file mode 100644
index 00000000000..6f6fe19270c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980506-2.c
@@ -0,0 +1,89 @@
+/*
+ * inspired by glibc-2.0.6/sysdeps/libm-ieee754/s_nextafterf.c
+ *
+ * gcc -O2 -S -DOP=+ gives faddp %st(1),%st
+ * gcc -O2 -S -DOP=* gives fmulp %st(1),%st
+ * gcc -O2 -S -DOP=- gives fsubrp %st(1),%st
+ * gcc -O2 -S -DOP=/ gives fdivrp %st(1),%st
+ */
+
+#ifndef OP
+#define OP *
+#endif
+
+typedef int int32_t __attribute__ ((__mode__ (  __SI__ ))) ;
+typedef unsigned int u_int32_t __attribute__ ((__mode__ (  __SI__ ))) ;
+
+typedef union
+{
+  float value;
+  u_int32_t word;
+} ieee_float_shape_type;
+
+float __nextafterf(float x, float y)
+{
+ int32_t hx,hy,ix,iy;
+
+ {
+  ieee_float_shape_type gf_u;
+  gf_u.value = x;
+  hx = gf_u.word;
+ }
+ {
+  ieee_float_shape_type gf_u;
+  gf_u.value = y;
+  hy = gf_u.word;
+ }
+ ix = hx&0x7fffffff;
+ iy = hy&0x7fffffff;
+
+ if ( ix > 0x7f800000 || iy > 0x7f800000 )
+    return x+y;
+ if (x == y) return x;
+ if (ix == 0)
+   {
+    {
+     ieee_float_shape_type sf_u;
+     sf_u.word = (hy&0x80000000) | 1;
+     x = sf_u.value;
+    }
+    y = x*x;
+    if (y == x) return y; else return x;
+   }
+ if (hx >= 0)
+   {
+    if (hx > hy)
+       hx -= 1;
+    else
+       hx += 1;
+   }
+ else
+   {
+    if (hy >= 0 || hx > hy)
+       hx -= 1;
+    else
+       hx += 1;
+   }
+ hy = hx & 0x7f800000;
+ if (hy >= 0x7f800000)
+    return x+x;
+ if (hy < 0x00800000)
+   {
+    y = x OP x;
+    if (y != x)
+      {
+       ieee_float_shape_type sf_u;
+       sf_u.word = hx;
+       y = sf_u.value;
+       return y;
+      }
+   }
+ {
+  ieee_float_shape_type sf_u;
+  sf_u.word = hx;
+  x = sf_u.value;
+ }
+ return x;
+}
+
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/980511-1.c b/gcc/testsuite/gcc.c-torture/compile/980511-1.c
new file mode 100644
index 00000000000..f1bac0c434a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980511-1.c
@@ -0,0 +1,20 @@
+typedef unsigned int	__kernel_dev_t;
+typedef __kernel_dev_t		dev_t;
+struct ustat {
+};
+typedef unsigned int kdev_t;
+static inline kdev_t to_kdev_t(int dev)
+{
+	int major, minor;
+	major = (dev >> 8);
+	minor = (dev & 0xff);
+	return ((( major ) << 22 ) | (  minor )) ;
+}
+struct super_block {
+};
+struct super_block * get_super (kdev_t dev);
+int sys_ustat(dev_t dev, struct ustat * ubuf)
+{
+        struct super_block *s;
+        s = get_super(to_kdev_t(dev));
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/980701-1.c b/gcc/testsuite/gcc.c-torture/compile/980701-1.c
new file mode 100644
index 00000000000..82dd16d6be2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980701-1.c
@@ -0,0 +1,9 @@
+
+short
+func(void)
+{
+	unsigned char x, y;
+
+	return  y | x << 8;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/980706-1.c b/gcc/testsuite/gcc.c-torture/compile/980706-1.c
new file mode 100644
index 00000000000..214f36d5311
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980706-1.c
@@ -0,0 +1,10 @@
+void g(long long);
+
+long long f(long long v1, long long v2, long long v3, long long v4)
+{
+  g(v1);
+  g(v2);
+  g(v3);
+  g(v4);
+  return v1 && v2;
+} 
diff --git a/gcc/testsuite/gcc.c-torture/compile/980726-1.c b/gcc/testsuite/gcc.c-torture/compile/980726-1.c
new file mode 100644
index 00000000000..3d4daa203de
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980726-1.c
@@ -0,0 +1,10 @@
+static __inline__ unsigned char BCD(unsigned char binval)
+{
+  if (binval > 99) return 0x99;
+  return (((binval/10) << 4) | (binval%10));
+}
+
+void int1a(unsigned char i)
+{
+    (*((unsigned char *)1)) = BCD(i);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/980729-1.c b/gcc/testsuite/gcc.c-torture/compile/980729-1.c
new file mode 100644
index 00000000000..973372b2ea3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980729-1.c
@@ -0,0 +1,14 @@
+static int
+regex_compile ()
+{
+  int  c, c1;
+  char str[6  + 1];
+  c1 = 0;
+  for (;;)
+    {
+      do { } while (0) ;
+      if (c1 == 6 )
+        break;
+      str[c1++] = c;
+    }
+}  
diff --git a/gcc/testsuite/gcc.c-torture/compile/980816-1.c b/gcc/testsuite/gcc.c-torture/compile/980816-1.c
new file mode 100644
index 00000000000..c56b6c9b92c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980816-1.c
@@ -0,0 +1,51 @@
+typedef unsigned int size_t;
+typedef void *XtPointer;
+
+typedef struct _WidgetRec *Widget;
+typedef struct _WidgetClassRec *WidgetClass;
+
+extern WidgetClass commandWidgetClass;
+
+typedef void (*XtCallbackProc)(
+    Widget 		 ,
+    XtPointer 		 ,	 
+    XtPointer 		 	 
+);
+
+extern const  char XtStrings[];
+
+
+typedef struct						 
+{
+	char			*Name,			 
+				*Label;			 
+	XtCallbackProc		Callback;		 
+	XtPointer		ClientData;		 
+	Widget			W;				 
+} DialogButtonType, *DialogButtonTypePtr;
+
+ 
+Widget AddButtons(Widget Parent, Widget Top,
+	DialogButtonTypePtr Buttons, size_t Count)
+{
+	int		i;
+
+	for (i = 0; i < Count; i++)
+	{
+		if (!Buttons[i].Label)
+			continue;
+		Buttons[i].W  = XtVaCreateManagedWidget(Buttons[i].Name,
+			commandWidgetClass,
+			Parent,
+			((char*)&XtStrings[429]) , Buttons[i].Label,
+			"fromHoriz" , i ? Buttons[i-1].W : ((void *)0) ,
+			"fromVert" , Top,
+			"resizable" , 1 ,
+			((void *)0) );
+
+		XtAddCallback(((char*)&XtStrings[136]),
+				 Buttons[i].Callback, Buttons[i].ClientData);
+	}
+	return(Buttons[Count-1].W);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/980821-1.c b/gcc/testsuite/gcc.c-torture/compile/980821-1.c
new file mode 100644
index 00000000000..9eb1ac4ca1c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980821-1.c
@@ -0,0 +1,15 @@
+typedef int __int32_t;
+int __kernel_rem_pio2(int prec)
+{
+	__int32_t i, jz;
+	double fw, fq[20];
+	switch(prec) {
+	    case 2:
+		fw = 0.0;
+	    case 3:	 
+		for (i=jz;i>0;i--) {
+		    fw      = fq[i-1] +fq[i]; 
+		    fq[i-1] = fw;
+		}
+	}
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/980825-1.c b/gcc/testsuite/gcc.c-torture/compile/980825-1.c
new file mode 100644
index 00000000000..34e35bf83c4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/980825-1.c
@@ -0,0 +1,30 @@
+typedef enum { FALSE, TRUE } boolean;
+enum _errorTypes { FATAL = 1, WARNING = 2, PERROR = 4 };
+typedef struct _optionValues {
+    struct _include {		 
+	boolean	classNames;	 
+	boolean	defines;	 
+	boolean	enumerators;	 
+    } include;
+} optionValues;
+extern optionValues	Option;
+static void applyTagInclusionList( list )
+    const char *const list;
+{
+    boolean mode = TRUE;	 
+    const char *p;
+    for (p = list  ;  *p != '\0'  ;  ++p)
+	switch (*p)
+	{
+	    case '=':	 
+		clearTagList();
+		mode = TRUE;
+		break;
+	    case '+':	mode = TRUE;	break;	 
+	    case '-':	mode = FALSE;	break;	 
+	    case 'c':	Option.include.classNames	= mode;		break;
+	    case 'd':	Option.include.defines		= mode;		break;
+	    case 'e':	Option.include.enumerators	= mode;		break;
+	    default: error(FATAL, "-i: Invalid tag option '%c'", *p);	break;
+	}
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/981001-1.c b/gcc/testsuite/gcc.c-torture/compile/981001-1.c
new file mode 100644
index 00000000000..d7cf0dc64b0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/981001-1.c
@@ -0,0 +1,18 @@
+unsigned short code = 0x0000;
+unsigned short  low = 0x4000;
+unsigned short high = 0xb000;
+
+int main (void)
+{
+  if (
+         (high & 0x8000) != (low & 0x8000)
+      && ( low & 0x4000) == 0x4000
+      && (high & 0x4000) == 0
+      )
+    {
+      code ^= 0x4000;
+      low  |= 0x4000;
+    }
+  
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/981001-2.c b/gcc/testsuite/gcc.c-torture/compile/981001-2.c
new file mode 100644
index 00000000000..9ade1d92aef
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/981001-2.c
@@ -0,0 +1,12 @@
+#define weak_alias(func, aliasname) \
+	extern __typeof (func) aliasname __attribute__ ((weak, alias (#func)));
+
+#define add3(d, m, c) ((d) + (m) + (c))
+
+int
+__add3(int d, int m, int c)
+{
+  return d + m + c;
+}
+
+weak_alias (__add3, add3)
diff --git a/gcc/testsuite/gcc.c-torture/compile/981001-3.c b/gcc/testsuite/gcc.c-torture/compile/981001-3.c
new file mode 100644
index 00000000000..5f6458757ac
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/981001-3.c
@@ -0,0 +1,14 @@
+#define P(a, b) P1(a,b)
+#define P1(a,b) a##b
+
+#define FLT_MIN_EXP (-125)
+#define DBL_MIN_EXP (-1021)
+
+#define MIN_EXP P(FLT,_MIN_EXP)
+
+#define FLT FLT
+int f1 = MIN_EXP;
+
+#undef FLT
+#define FLT DBL
+int f2 = MIN_EXP;
diff --git a/gcc/testsuite/gcc.c-torture/compile/981001-4.c b/gcc/testsuite/gcc.c-torture/compile/981001-4.c
new file mode 100644
index 00000000000..dd3df9cce4b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/981001-4.c
@@ -0,0 +1,14 @@
+#define P(a,b) P1(a,b)
+#define P1(a,b) a##b
+
+#define ONCE(x, y) (x ?: (x = y()))
+#define PREFIX
+
+extern int P(PREFIX, init) (void);
+
+int
+fun(void)
+{
+  static int memo;
+  return ONCE(memo, P(PREFIX, init));
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/981007-1.c b/gcc/testsuite/gcc.c-torture/compile/981007-1.c
new file mode 100644
index 00000000000..d41400b7832
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/981007-1.c
@@ -0,0 +1,21 @@
+extern double fabs (double);
+extern double sqrt (double);
+
+typedef struct complexm {
+  double re,im;
+} complex;
+
+static complex
+setCom (double r, double i)
+{
+  complex ct;
+  ct.re=fabs(r)<1E-300?0.0:r;
+  ct.im=fabs(i)<1E-300?0.0:i;
+  return ct;
+}
+
+static complex
+csqrt_crash (double x)
+{
+  return (x>=0) ? setCom(sqrt(x),0) : setCom(0,sqrt(-x));
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/981022-1.c b/gcc/testsuite/gcc.c-torture/compile/981022-1.c
new file mode 100644
index 00000000000..6256673804a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/981022-1.c
@@ -0,0 +1,9 @@
+/* This tests a combination of two gcc extensions.  Omitting the middle
+   operand of ?: and using ?: as an lvalue.  */
+int x, y;
+
+int main ()
+{
+  (x ?: y) = 0;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/981022-1.x b/gcc/testsuite/gcc.c-torture/compile/981022-1.x
new file mode 100644
index 00000000000..f41cdc29913
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/981022-1.x
@@ -0,0 +1,2 @@
+set torture_compile_xfail "*-*-*"
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/compile/981107-1.c b/gcc/testsuite/gcc.c-torture/compile/981107-1.c
new file mode 100644
index 00000000000..987ec180f9f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/981107-1.c
@@ -0,0 +1,9 @@
+unsigned long seed(void)
+{
+    unsigned long u;
+
+    call();
+
+    u = 26107 * (unsigned long)&u;
+    return u;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/981211-1.c b/gcc/testsuite/gcc.c-torture/compile/981211-1.c
new file mode 100644
index 00000000000..92c9cfb7013
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/981211-1.c
@@ -0,0 +1,43 @@
+/* Basic tests of the #assert preprocessor extension. */
+
+#define fail  int fail
+
+#assert abc (def)
+#assert abc (ghi)
+#assert abc (jkl)
+#assert space ( s p a c e )
+
+/* Basic: */
+#if !#abc (def) || !#abc (ghi) || !#abc (jkl)
+fail
+#endif
+
+/* any answer for #abc */
+#if !#abc
+fail
+#endif
+
+/* internal whitespace is collapsed,
+   external whitespace is deleted  */
+#if !#space (s p  a  c e) || !#space (  s p a c e  ) || #space (space)
+fail
+#endif
+
+/* removing assertions */
+#unassert abc (jkl)
+#if !#abc || !#abc (def) || !#abc (ghi) || #abc (jkl)
+fail
+#endif
+
+#unassert abc
+#if #abc || #abc (def) || #abc (ghi) || #abc (jkl)
+fail
+#endif
+
+int gobble
+
+/* make sure it can succeed too.
+   also check space before open paren isn't significant */
+#if #space(s p a c e)
+;
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compile/981223-1.c b/gcc/testsuite/gcc.c-torture/compile/981223-1.c
new file mode 100644
index 00000000000..d207ff10bb3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/981223-1.c
@@ -0,0 +1,8 @@
+__complex__ float
+func (__complex__ float x)
+{
+    if (__real__ x == 0.0)
+	return 1.0;
+    else
+	return 0.0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/990107-1.c b/gcc/testsuite/gcc.c-torture/compile/990107-1.c
new file mode 100644
index 00000000000..a123ce9cbf3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/990107-1.c
@@ -0,0 +1,7 @@
+static int
+java_double_finite (d)
+     double  d;
+{
+  long long  *ip = (long long  *) &d;
+  return (*ip & 0x7ff0000000000000LL ) != 0x7ff0000000000000LL ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/990117-1.c b/gcc/testsuite/gcc.c-torture/compile/990117-1.c
new file mode 100644
index 00000000000..dda52205988
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/990117-1.c
@@ -0,0 +1,13 @@
+static void
+__bb_init_prg ()
+{
+  const char *p;
+
+      {
+	unsigned long l;
+
+	(__extension__ (__builtin_constant_p (p) && __builtin_constant_p (l)
+			? 5 : 2));
+      }
+
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/990203-1.c b/gcc/testsuite/gcc.c-torture/compile/990203-1.c
new file mode 100644
index 00000000000..2c69a8fe086
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/990203-1.c
@@ -0,0 +1,7 @@
+int
+f (f)
+     float f;
+{
+  long long  *ip = (long long  *) &f;
+  return (*ip & 0x7ff0000000000000LL ) != 0x7ff0000000000000LL ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/990517-1.c b/gcc/testsuite/gcc.c-torture/compile/990517-1.c
new file mode 100644
index 00000000000..c738d4be760
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/990517-1.c
@@ -0,0 +1,30 @@
+/* Extracted from the sdm module in perl.  */
+typedef struct {
+	char *dptr;
+	int dsize;
+} datum;
+extern long sdbm_hash  (char *, int)  ;
+extern void  sdbm__putpair   (char *, datum, datum)  ;
+void
+sdbm__splpage (char *pag, char *New, long int sbit)
+{
+	datum key;
+	datum val;
+	register int n;
+	register int off = 1024 ;
+	char cur[1024 ];
+	register short *ino = (short *) cur;
+	(void) memcpy(cur, pag, 1024 );
+	(void) ({ void *__s = ( pag ); __builtin_memset ( __s , '\0',     1024   ) ; __s; });
+	(void) ({ void *__s = ( New ); __builtin_memset ( __s , '\0',     1024   ) ; __s; });
+	n = ino[0];
+	for (ino++; n > 0; ino += 2) {
+		key.dptr = cur + ino[0]; 
+		key.dsize = off - ino[0];
+		val.dptr = cur + ino[1];
+		val.dsize = ino[0] - ino[1];
+		(void) sdbm__putpair ((sdbm_hash(( key ).dptr, ( key ).dsize)  & sbit) ? New : pag, key, val);
+		off = ino[1];
+		n -= 2;
+	}
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/990519-1.c b/gcc/testsuite/gcc.c-torture/compile/990519-1.c
new file mode 100644
index 00000000000..9c116178230
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/990519-1.c
@@ -0,0 +1,10 @@
+  typedef int   gboolean;
+
+  typedef struct{
+    gboolean names : 1;
+    gboolean types : 1;
+  } ParamOptions;
+
+  int p_param(ParamOptions* o){
+    return o->types && o->names;
+  }
diff --git a/gcc/testsuite/gcc.c-torture/compile/Makefile.in b/gcc/testsuite/gcc.c-torture/compile/Makefile.in
new file mode 100644
index 00000000000..e6209dbc6c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+	-rm -f *.o *.diff *~ *.bad core *.x
+
+distclean:	clean
+	-rm -f Makefile config.status
diff --git a/gcc/testsuite/gcc.c-torture/compile/calls.c b/gcc/testsuite/gcc.c-torture/compile/calls.c
new file mode 100644
index 00000000000..1582c0e92fa
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/calls.c
@@ -0,0 +1,22 @@
+typedef void  *(*T)(void);
+f1 ()
+{
+  ((T) 0)();
+}
+f2 ()
+{
+  ((T) 1000)();
+}
+f3 ()
+{
+  ((T) 10000000)();
+}
+f4 (r)
+{
+  ((T) r)();
+}
+f5 ()
+{
+  int (*r)() = f3;
+  ((T) r)();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/cmpdi-1.c b/gcc/testsuite/gcc.c-torture/compile/cmpdi-1.c
new file mode 100644
index 00000000000..9e1b659c7cf
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/cmpdi-1.c
@@ -0,0 +1,15 @@
+f (long long d)
+{
+  int i = 0;
+  if (d == 1)
+    i = 1;
+  return i;
+}
+
+g (long long d)
+{
+  int i = 0;
+  if (d <= 0)
+    i = 1;
+  return i;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/combine-hang.c b/gcc/testsuite/gcc.c-torture/compile/combine-hang.c
new file mode 100644
index 00000000000..7cc57afe603
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/combine-hang.c
@@ -0,0 +1,26 @@
+typedef union
+{
+  double value;
+  struct
+  {
+    unsigned long msw;
+    unsigned long lsw;
+  } parts;
+} ieee_double_shape_type;
+
+double f (int iy)
+{
+  double z, t;
+  ieee_double_shape_type u, v;
+
+  if (iy == 1)
+    return 0;
+
+  u.parts.msw = iy;
+  u.parts.lsw = 0;
+  z = u.value;
+  v.parts.msw = iy;
+  v.parts.lsw = 0;
+  t = v.value;
+  return 1.0+z+t+t;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/compile.exp b/gcc/testsuite/gcc.c-torture/compile/compile.exp
new file mode 100644
index 00000000000..f96f0231a6c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/compile.exp
@@ -0,0 +1,35 @@
+# Expect driver script for GCC Regression Tests
+# Copyright (C) 1993, 1995, 1997 Free Software Foundation
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+
+# These tests come from Torbjorn Granlund's (tege@cygnus.com)
+# C torture test suite, and other contributors.
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+
+foreach testcase [glob -nocomplain $srcdir/$subdir/*.c] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $testcase] then {
+	continue
+    }
+
+    c-torture $testcase
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/configure.in b/gcc/testsuite/gcc.c-torture/compile/configure.in
new file mode 100644
index 00000000000..e4cc69d249e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=compile.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/gcc.c-torture/compile/funcptr-1.c b/gcc/testsuite/gcc.c-torture/compile/funcptr-1.c
new file mode 100644
index 00000000000..79687c9c005
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/funcptr-1.c
@@ -0,0 +1,19 @@
+extern int (*gp)(const char*);
+
+int
+g (const char* d)
+{
+  printf ("g");
+  return 0;
+}
+
+f ()
+{
+  int errcnt=0;
+
+  if (gp != g)
+    {
+      printf ("f");
+      errcnt++;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/goto-1.c b/gcc/testsuite/gcc.c-torture/compile/goto-1.c
new file mode 100644
index 00000000000..caeed3aa0ba
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/goto-1.c
@@ -0,0 +1,16 @@
+f ()
+{
+  do
+    {
+      if (0)
+	{
+        L1:;
+	}
+      else
+	goto L2;
+    L2:;
+    }
+  while (0);
+
+  goto L1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/init-1.c b/gcc/testsuite/gcc.c-torture/compile/init-1.c
new file mode 100644
index 00000000000..38db9ad87d9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/init-1.c
@@ -0,0 +1,19 @@
+typedef struct
+{
+  char *key;
+  char *value;
+} T1;
+
+typedef struct
+{
+  long type;
+  char *value;
+} T3;
+
+T1 a[] =
+{
+  {
+    "",
+    ((char *)&((T3) {1, (char *) 1}))
+  }
+};
diff --git a/gcc/testsuite/gcc.c-torture/compile/init-2.c b/gcc/testsuite/gcc.c-torture/compile/init-2.c
new file mode 100644
index 00000000000..63a7f5849d6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/init-2.c
@@ -0,0 +1,4 @@
+struct
+{
+  int e1, e2;
+} v = { e2: 0 };
diff --git a/gcc/testsuite/gcc.c-torture/compile/labels-1.c b/gcc/testsuite/gcc.c-torture/compile/labels-1.c
new file mode 100644
index 00000000000..fae6ab8f400
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/labels-1.c
@@ -0,0 +1,13 @@
+#ifndef NO_LABEL_VALUES
+f ()
+{
+  void *x = &&L2;
+  if (&&L3 - &&L1 > 1)
+    abort();
+ L1: return 1;
+ L2: abort ();
+ L3:;
+}
+#else
+int x;
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/compile/packed-1.c b/gcc/testsuite/gcc.c-torture/compile/packed-1.c
new file mode 100644
index 00000000000..709fc3cb102
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/packed-1.c
@@ -0,0 +1,14 @@
+struct s
+{
+  int e;
+} x;
+
+struct rbuf
+{
+  struct s *p __attribute__ ((packed));
+} *b;
+
+f ()
+{
+  b->p = &x;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/widechar-1.c b/gcc/testsuite/gcc.c-torture/compile/widechar-1.c
new file mode 100644
index 00000000000..5d89f33a864
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/widechar-1.c
@@ -0,0 +1 @@
+char *s = L"a" "b";
diff --git a/gcc/testsuite/gcc.c-torture/compile/zero-strct-1.c b/gcc/testsuite/gcc.c-torture/compile/zero-strct-1.c
new file mode 100644
index 00000000000..d3db812691b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/zero-strct-1.c
@@ -0,0 +1,7 @@
+typedef struct { } empty_t;
+
+f ()
+{
+  empty_t i;
+  bar (i);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20010910-1.c b/gcc/testsuite/gcc.c-torture/execute/20010910-1.c
new file mode 100644
index 00000000000..185e29d2b28
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20010910-1.c
@@ -0,0 +1,59 @@
+/* Test case contributed by Ingo Rohloff <rohloff@in.tum.de>.
+   Code distilled from Linux kernel.  */
+
+/* Compile this program with a gcc-2.95.2 using
+   "gcc -O2" and run it. The result will be that
+   rx_ring[1].next == 0   (it should be == 14)
+   and
+   ep.skbuff[4] == 5      (it should be 0)
+*/
+
+extern void abort(void);
+
+struct epic_rx_desc 
+{
+  unsigned int next;
+};
+
+struct epic_private 
+{
+  struct epic_rx_desc *rx_ring;
+  unsigned int rx_skbuff[5];
+};
+
+static void epic_init_ring(struct epic_private *ep)
+{
+  int i;
+
+  for (i = 0; i < 5; i++) 
+  {
+    ep->rx_ring[i].next = 10 + (i+1)*2;
+    ep->rx_skbuff[i] = 0;
+  }
+  ep->rx_ring[i-1].next = 10;
+}
+
+static int check_rx_ring[5] = { 12,14,16,18,10 };
+
+int main(void)
+{
+  struct epic_private ep;
+  struct epic_rx_desc rx_ring[5];
+  int i;
+
+  for (i=0;i<5;i++)
+  {
+    rx_ring[i].next=0;
+    ep.rx_skbuff[i]=5;
+  }
+  
+  ep.rx_ring=rx_ring;
+  epic_init_ring(&ep);
+  
+  for (i=0;i<5;i++)
+  {
+    if ( rx_ring[i].next != check_rx_ring[i] ) abort();
+    if ( ep.rx_skbuff[i] != 0 ) abort();
+  }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/900409-1.c b/gcc/testsuite/gcc.c-torture/execute/900409-1.c
new file mode 100644
index 00000000000..3112effaf2f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/900409-1.c
@@ -0,0 +1,20 @@
+long f1(long a){return a&0xff000000L;}
+long f2 (long a){return a&~0xff000000L;}
+long f3(long a){return a&0x000000ffL;}
+long f4(long a){return a&~0x000000ffL;}
+long f5(long a){return a&0x0000ffffL;}
+long f6(long a){return a&~0x0000ffffL;}
+
+main ()
+{
+  long a = 0x89ABCDEF;
+
+  if (f1(a)!=0x89000000L||
+      f2(a)!=0x00ABCDEFL||
+      f3(a)!=0x000000EFL||
+      f4(a)!=0x89ABCD00L||
+      f5(a)!=0x0000CDEFL||
+      f6(a)!=0x89AB0000L)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920202-1.c b/gcc/testsuite/gcc.c-torture/execute/920202-1.c
new file mode 100644
index 00000000000..e30ce2fd5c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920202-1.c
@@ -0,0 +1,18 @@
+static int rule_text_needs_stack_pop = 0;
+static int input_stack_pos = 1;
+
+f (void)
+{
+  rule_text_needs_stack_pop = 1;
+
+  if (input_stack_pos <= 0)
+    return 1;
+  else
+    return 0;
+}
+
+main ()
+{
+  f ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920302-1.c b/gcc/testsuite/gcc.c-torture/execute/920302-1.c
new file mode 100644
index 00000000000..5fbfd9d1b9c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920302-1.c
@@ -0,0 +1,42 @@
+short optab[5];
+char buf[10];
+execute (ip)
+     register unsigned short *ip;
+{
+#ifndef NO_LABEL_VALUES
+  register void *base = &&x;
+  char *bp = buf;
+  static void *tab[] = {&&x, &&y, &&z};
+  if (ip == 0)
+    {
+      int i;
+      for (i = 0; i < 3; ++i)
+	optab[i] = (short)(tab[i] - base);
+      return;
+    }
+x:  *bp++='x';
+    goto *(base + *ip++);
+y:  *bp++='y';
+    goto *(base + *ip++);
+z:  *bp++='z';
+    *bp=0;
+    return;
+#else
+    strcpy (buf, "xyxyz");
+#endif
+}
+
+short p[5];
+
+main ()
+{
+  execute (0);
+  p[0] = optab[1];
+  p[1] = optab[0];
+  p[2] = optab[1];
+  p[3] = optab[2];
+  execute (&p);
+  if (strcmp (buf, "xyxyz"))
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920409-1.c b/gcc/testsuite/gcc.c-torture/execute/920409-1.c
new file mode 100644
index 00000000000..938ce7d92d6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920409-1.c
@@ -0,0 +1 @@
+x(){signed char c=-1;return c<0;}main(){if(x()!=1)abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920410-1.c b/gcc/testsuite/gcc.c-torture/execute/920410-1.c
new file mode 100644
index 00000000000..f5180f06a9c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920410-1.c
@@ -0,0 +1,6 @@
+#define STACK_REQUIREMENT (40000 * 4 + 256)
+#if defined (STACK_SIZE) && STACK_SIZE < STACK_REQUIREMENT
+main () { exit (0); }
+#else
+main(){int d[40000];d[0]=0;exit(0);}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/920411-1.c b/gcc/testsuite/gcc.c-torture/execute/920411-1.c
new file mode 100644
index 00000000000..e3e98100108
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920411-1.c
@@ -0,0 +1,24 @@
+long f (w)
+     char *w;
+{
+  long k, i, c = 0, x;
+  char *p = (char*) &x;
+  for (i = 0; i < 1; i++)
+    {
+      for (k = 0; k < sizeof (long); k++)
+	p[k] = w[k];
+      c += x;
+    }
+  return c;
+}
+
+main ()
+{
+  int i;
+  char a[sizeof (long)];
+
+  for (i = sizeof (long); --i >= 0;) a[i] = ' ';
+  if (f (a) != ~0UL / (unsigned char) ~0 * ' ')
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920415-1.c b/gcc/testsuite/gcc.c-torture/execute/920415-1.c
new file mode 100644
index 00000000000..25100ad5200
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920415-1.c
@@ -0,0 +1,7 @@
+/* CYGNUS LOCAL -- meissner/no label values */
+#ifndef NO_LABEL_VALUES
+main(){__label__ l;void*x(){return&&l;}goto*x();abort();return;l:exit(0);}
+#else
+main(){ exit (0); }
+#endif
+/* END CYGNUS LOCAL -- meissner/no label values */
diff --git a/gcc/testsuite/gcc.c-torture/execute/920428-1.c b/gcc/testsuite/gcc.c-torture/execute/920428-1.c
new file mode 100644
index 00000000000..154af763a50
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920428-1.c
@@ -0,0 +1,2 @@
+x(const char*s){char a[1];const char*ss=s;a[*s++]|=1;return(int)ss+1==(int)s;}
+main(){if(x("")!=1)abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920428-2.c b/gcc/testsuite/gcc.c-torture/execute/920428-2.c
new file mode 100644
index 00000000000..118ba968314
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920428-2.c
@@ -0,0 +1,7 @@
+#ifndef NO_LABEL_VALUES
+s(i){if(i>0){__label__ l1;int f(int i){if(i==2)goto l1;return 0;}return f(i);l1:;}return 1;}
+x(){return s(0)==1&&s(1)==0&&s(2)==1;}
+main(){if(x()!=1)abort();exit(0);}
+#else
+main(){ exit (0); }
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/920428-2.x b/gcc/testsuite/gcc.c-torture/execute/920428-2.x
new file mode 100644
index 00000000000..c7d9f030049
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920428-2.x
@@ -0,0 +1,6 @@
+# This doesn't work on sparc's with -mflat.
+
+if { [istarget "sparc-*-*"] && [string match "*mflat*" $CFLAGS] } {
+	set torture_execute_xfail "sparc-*-*"
+}
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/920429-1.c b/gcc/testsuite/gcc.c-torture/execute/920429-1.c
new file mode 100644
index 00000000000..f37bf68bdd4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920429-1.c
@@ -0,0 +1,3 @@
+typedef unsigned char t;int i,j;
+t*f(t*p){t c;c=*p++;i=((c&2)?1:0);j=(c&7)+1;return p;}
+main(){t*p0="ab",*p1;p1=f(p0);if(p0+1!=p1)abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920501-1.c b/gcc/testsuite/gcc.c-torture/execute/920501-1.c
new file mode 100644
index 00000000000..6f757cac59c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920501-1.c
@@ -0,0 +1,3 @@
+int s[2];
+x(){if(!s[0]){s[1+s[1]]=s[1];return 1;}}
+main(){s[0]=s[1]=0;if(x(0)!=1)abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920501-2.c b/gcc/testsuite/gcc.c-torture/execute/920501-2.c
new file mode 100644
index 00000000000..d99eef289e5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920501-2.c
@@ -0,0 +1,114 @@
+unsigned long
+gcd_ll (unsigned long long x, unsigned long long y)
+{
+  for (;;)
+    {
+      if (y == 0)
+	return (unsigned long) x;
+      x = x % y;
+      if (x == 0)
+	return (unsigned long) y;
+      y = y % x;
+    }
+}
+
+unsigned long long
+powmod_ll (unsigned long long b, unsigned e, unsigned long long m)
+{
+  unsigned t;
+  unsigned long long pow;
+  int i;
+
+  if (e == 0)
+    return 1;
+
+  /* Find the most significant bit in E.  */
+  t = e;
+  for (i = 0; t != 0; i++)
+    t >>= 1;
+
+  /* The most sign bit in E is handled outside of the loop, by beginning
+     with B in POW, and decrementing I.  */
+  pow = b;
+  i -= 2;
+
+  for (; i >= 0; i--)
+    {
+      pow = pow * pow % m;
+      if ((1 << i) & e)
+	pow = pow * b % m;
+    }
+
+  return pow;
+}
+
+unsigned long factab[10];
+
+void
+facts (t, a_int, x0, p)
+     unsigned long long t;
+     int a_int;
+     int x0;
+     unsigned p;
+{
+  unsigned long *xp = factab;
+  unsigned long long x, y;
+  unsigned long q = 1;
+  unsigned long long a = a_int;
+  int i;
+  unsigned long d;
+  int j = 1;
+  unsigned long tmp;
+  int jj = 0;
+
+  x = x0;
+  y = x0;
+
+  for (i = 1; i < 10000; i++)
+    {
+      x = powmod_ll (x, p, t) + a;
+      y = powmod_ll (y, p, t) + a;
+      y = powmod_ll (y, p, t) + a;
+
+      if (x > y)
+	tmp = x - y;
+      else
+	tmp = y - x;
+      q = (unsigned long long) q * tmp % t;
+
+      if (i == j)
+	{
+	  jj += 1;
+	  j += jj;
+	  d = gcd_ll (q, t);
+	  if (d != 1)
+	    {
+	      *xp++ = d;
+	      t /= d;
+	      if (t == 1)
+		{
+		  return;
+		  *xp = 0;
+		}
+	    }
+	}
+    }
+}
+
+main ()
+{
+  unsigned long long t;
+  unsigned x0, a;
+  unsigned p;
+
+  p = 27;
+  t = (1ULL << p) - 1;
+
+  a = -1;
+  x0 = 3;
+
+  facts (t, a, x0, p);
+  if (factab[0] != 7 || factab[1] != 73 || factab[2] != 262657)
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920501-3.c b/gcc/testsuite/gcc.c-torture/execute/920501-3.c
new file mode 100644
index 00000000000..1031d7378cb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920501-3.c
@@ -0,0 +1,35 @@
+int tab[9];
+execute(oip, ip)
+     unsigned short *oip, *ip;
+{
+#ifndef NO_LABEL_VALUES
+  int x = 0;
+  int *xp = tab;
+base:
+  x++;
+  if (x == 4)
+    {
+      *xp = 0;
+      return;
+    }
+  *xp++ = ip - oip;
+  goto *(&&base + *ip++);
+#else
+  tab[0] = 0;
+  tab[1] = 1;
+  tab[2] = 2;
+  tab[3] = 0;
+#endif
+}
+
+main()
+{
+  unsigned short ip[10];
+  int i;
+  for (i = 0; i < 10; i++)
+    ip[i] = 0;
+  execute(ip, ip);
+  if (tab[0] != 0 || tab[1] != 1 || tab[2] != 2 || tab[3] != 0)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920501-4.c b/gcc/testsuite/gcc.c-torture/execute/920501-4.c
new file mode 100644
index 00000000000..3524dd5c8b2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920501-4.c
@@ -0,0 +1,27 @@
+#ifndef NO_LABEL_VALUES
+int
+x (int i)
+{
+  static const void *j[] = {&& x, && y, && z};
+  
+  goto *j[i];
+  
+ x: return 2;
+ y: return 3;
+ z: return 5;
+}
+
+int
+main (void)
+{
+  if (   x (0) != 2
+      || x (1) != 3
+      || x (2) != 5)
+    abort ();
+
+  exit (0);
+}
+#else
+int
+main (void) { exit (0); }
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/920501-5.c b/gcc/testsuite/gcc.c-torture/execute/920501-5.c
new file mode 100644
index 00000000000..09740747712
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920501-5.c
@@ -0,0 +1,19 @@
+#ifndef NO_LABEL_VALUES
+x (int i)
+{
+  void *j[] = {&&x, &&y, &&z};
+  goto *j[i];
+ x:return 2;
+ y:return 3;
+ z:return 5;
+
+}
+main ()
+{
+  if (x (0) != 2 || x (1) != 3 | x (2) != 5)
+    abort();
+  exit(0);
+}
+#else
+main(){ exit (0); }
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/920501-6.c b/gcc/testsuite/gcc.c-torture/execute/920501-6.c
new file mode 100644
index 00000000000..833624ff3f7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920501-6.c
@@ -0,0 +1,91 @@
+#include <stdio.h>
+
+/* Convert a decimal string to a long long unsigned.  No error check is
+   performed.  */
+
+long long unsigned
+str2llu (str)
+     char *str;
+{
+  long long unsigned acc;
+  int d;
+  acc =  *str++ - '0';
+  for (;;)
+    {
+      d = *str++;
+      if (d == '\0')
+	break;
+      d -= '0';
+      acc = acc * 10 + d;
+    }
+
+  return acc;
+}
+
+/* isqrt(t) - computes the square root of t. (tege 86-10-27) */
+
+long unsigned
+sqrtllu (long long unsigned t)
+{
+  long long unsigned s;
+  long long unsigned b;
+
+  for (b = 0, s = t;  b++, (s >>= 1) != 0; )
+    ;
+
+  s = 1LL << (b >> 1);
+
+  if (b & 1)
+    s += s >> 1;
+
+  do
+    {
+      b = t / s;
+      s = (s + b) >> 1;
+    }
+  while (b < s);
+
+  return s;
+}
+
+
+int plist (p0, p1, tab)
+     long long unsigned p0, p1;
+     long long unsigned *tab;
+{
+  long long unsigned p;
+  long unsigned d;
+  long unsigned s;
+  long long unsigned *xp = tab;
+
+  for (p = p0;  p <= p1;  p += 2)
+    {
+      s = sqrtllu (p);
+
+      for (d = 3;  d <= s;  d += 2)
+	{
+	  long long unsigned q = p % d;
+	  if (q == 0)
+	    goto not_prime;
+	}
+
+      *xp++ = p;
+    not_prime:;
+    }
+  *xp = 0;
+  return xp - tab;
+}
+
+main (argc, argv)
+     int argc;
+     char *argv[];
+{
+  long long tab[10];
+  int nprimes;
+  nprimes = plist (str2llu ("1234111111"), str2llu ("1234111127"), tab);
+
+  if(tab[0]!=1234111117LL||tab[1]!=1234111121LL||tab[2]!=1234111127LL||tab[3]!=0)
+    abort();
+
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920501-7.c b/gcc/testsuite/gcc.c-torture/execute/920501-7.c
new file mode 100644
index 00000000000..f6bc0de3a15
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920501-7.c
@@ -0,0 +1,32 @@
+/* CYGNUS LOCAL -- meissner/no label values */
+#ifdef STACK_SIZE
+#define DEPTH ((STACK_SIZE) / 512 + 1)
+#else
+#define DEPTH 1000
+#endif
+
+#ifndef NO_LABEL_VALUES
+x(a)
+{
+  __label__ xlab;
+  void y(a)
+    {
+      if (a==0)
+	goto xlab;
+      y (a-1);
+    }
+  y (a);
+ xlab:;
+  return a;
+}
+#endif
+
+main ()
+{
+#ifndef NO_LABEL_VALUES
+  if (x (DEPTH) != DEPTH)
+    abort ();
+#endif
+  exit (0);
+}
+/* END CYGNUS LOCAL -- meissner/no label values */
diff --git a/gcc/testsuite/gcc.c-torture/execute/920501-7.x b/gcc/testsuite/gcc.c-torture/execute/920501-7.x
new file mode 100644
index 00000000000..c7d9f030049
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920501-7.x
@@ -0,0 +1,6 @@
+# This doesn't work on sparc's with -mflat.
+
+if { [istarget "sparc-*-*"] && [string match "*mflat*" $CFLAGS] } {
+	set torture_execute_xfail "sparc-*-*"
+}
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/920501-8.c b/gcc/testsuite/gcc.c-torture/execute/920501-8.c
new file mode 100644
index 00000000000..62780a08cc7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920501-8.c
@@ -0,0 +1,38 @@
+#include <stdio.h>
+#include <stdarg.h>
+
+char buf[50];
+int
+va (int a, double b, int c, ...)
+{
+  va_list ap;
+  int d, e, f, g, h, i, j, k, l, m, n, o, p;
+  va_start (ap, c);
+
+  d = va_arg (ap, int);
+  e = va_arg (ap, int);
+  f = va_arg (ap, int);
+  g = va_arg (ap, int);
+  h = va_arg (ap, int);
+  i = va_arg (ap, int);
+  j = va_arg (ap, int);
+  k = va_arg (ap, int);
+  l = va_arg (ap, int);
+  m = va_arg (ap, int);
+  n = va_arg (ap, int);
+  o = va_arg (ap, int);
+  p = va_arg (ap, int);
+
+  sprintf (buf,
+	   "%d,%f,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
+	   a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);
+  va_end (ap);
+}
+
+main()
+{
+  va (1, 1.0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  if (strcmp ("1,1.000000,2,3,4,5,6,7,8,9,10,11,12,13,14,15", buf))
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920501-9.c b/gcc/testsuite/gcc.c-torture/execute/920501-9.c
new file mode 100644
index 00000000000..f585ac6e0f4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920501-9.c
@@ -0,0 +1,27 @@
+#include <stdio.h>
+
+long long proc1(){return 1LL;}
+long long proc2(){return 0x12345678LL;}
+long long proc3(){return 0xaabbccdd12345678LL;}
+long long proc4(){return -1LL;}
+long long proc5(){return 0xaabbccddLL;}
+
+print_longlong(x,buf)
+     long long x;
+     char *buf;
+{
+  unsigned long l;
+  l= (x >> 32) & 0xffffffff;
+  if (l != 0)
+    sprintf(buf,"%lx%08.lx",l,((unsigned long)x & 0xffffffff));
+  else
+    sprintf(buf,"%lx",((unsigned long)x & 0xffffffff));
+}
+
+main(){char buf[100];
+print_longlong(proc1(),buf);if(strcmp("1",buf))abort();
+print_longlong(proc2(),buf);if(strcmp("12345678",buf))abort();
+print_longlong(proc3(),buf);if(strcmp("aabbccdd12345678",buf))abort();
+print_longlong(proc4(),buf);if(strcmp("ffffffffffffffff",buf))abort();
+print_longlong(proc5(),buf);if(strcmp("aabbccdd",buf))abort();
+exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920506-1.c b/gcc/testsuite/gcc.c-torture/execute/920506-1.c
new file mode 100644
index 00000000000..9a646a30fc2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920506-1.c
@@ -0,0 +1,2 @@
+int l[]={0,1};
+main(){int*p=l;switch(*p++){case 0:exit(0);case 1:break;case 2:break;case 3:case 4:break;}abort();}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920520-1.c b/gcc/testsuite/gcc.c-torture/execute/920520-1.c
new file mode 100644
index 00000000000..068a12e9249
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920520-1.c
@@ -0,0 +1,36 @@
+foo(int *bar)
+{
+  *bar = 8;
+}
+
+bugger()
+{
+  int oldDepth, newDepth;
+
+  foo(&oldDepth);
+
+  switch (oldDepth)
+    {
+    case 8:
+    case 500:
+      newDepth = 8;
+      break;
+
+    case 5000:
+      newDepth = 500;
+      break;
+
+    default:
+      newDepth = 17;
+      break;
+    }
+
+  return newDepth - oldDepth;
+}
+
+main()
+{
+  if (bugger() != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920603-1.c b/gcc/testsuite/gcc.c-torture/execute/920603-1.c
new file mode 100644
index 00000000000..bd27ca6196e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920603-1.c
@@ -0,0 +1,2 @@
+f(got){if(got!=0xffff)abort();}
+main(){signed char c=-1;unsigned u=(unsigned short)c;f(u);exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920604-1.c b/gcc/testsuite/gcc.c-torture/execute/920604-1.c
new file mode 100644
index 00000000000..d7d9be13fd8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920604-1.c
@@ -0,0 +1,13 @@
+long long
+mod (a, b)
+     long long a, b;
+{
+  return a % b;
+}
+
+int
+main ()
+{
+  mod (1LL, 2LL);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920612-1.c b/gcc/testsuite/gcc.c-torture/execute/920612-1.c
new file mode 100644
index 00000000000..a70c0d2e078
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920612-1.c
@@ -0,0 +1,2 @@
+f(j)int j;{return++j>0;}
+main(){if(f((~0U)>>1))abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920612-2.c b/gcc/testsuite/gcc.c-torture/execute/920612-2.c
new file mode 100644
index 00000000000..2667093491f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920612-2.c
@@ -0,0 +1,12 @@
+main ()
+{
+  int i = 0;
+  int a (int x)
+    {
+      while (x)
+	i++, x--;
+      return x;
+    }
+  a (2);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920618-1.c b/gcc/testsuite/gcc.c-torture/execute/920618-1.c
new file mode 100644
index 00000000000..224f7208953
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920618-1.c
@@ -0,0 +1 @@
+main(){if(1.17549435e-38F<=1.1)exit(0);abort();}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920625-1.c b/gcc/testsuite/gcc.c-torture/execute/920625-1.c
new file mode 100644
index 00000000000..ae2f415dec7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920625-1.c
@@ -0,0 +1,38 @@
+#include <stdarg.h>
+
+typedef struct{double x,y;}point;
+point pts[]={{1.0,2.0},{3.0,4.0},{5.0,6.0},{7.0,8.0}};
+static int va1(int nargs,...)
+{
+  va_list args;
+  int i;
+  point pi;
+  va_start(args,nargs);
+  for(i=0;i<nargs;i++){
+    pi=va_arg(args,point);
+    if(pts[i].x!=pi.x||pts[i].y!=pi.y)abort();
+  }
+  va_end(args);
+}
+
+typedef struct{int x,y;}ipoint;
+ipoint ipts[]={{1,2},{3,4},{5,6},{7,8}};
+static int va2(int nargs,...)
+{
+  va_list args;
+  int i;
+  ipoint pi;
+  va_start(args,nargs);
+  for(i=0;i<nargs;i++){
+    pi=va_arg(args,ipoint);
+    if(ipts[i].x!=pi.x||ipts[i].y!=pi.y)abort();
+  }
+  va_end(args);
+}
+
+main()
+{
+va1(4,pts[0],pts[1],pts[2],pts[3]);
+va2(4,ipts[0],ipts[1],ipts[2],ipts[3]);
+exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920710-1.c b/gcc/testsuite/gcc.c-torture/execute/920710-1.c
new file mode 100644
index 00000000000..7c6f871e2ac
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920710-1.c
@@ -0,0 +1,11 @@
+main()
+{
+  if ((double) 18446744073709551615ULL < 1.84467440737095e+19 ||
+      (double) 18446744073709551615ULL > 1.84467440737096e+19)
+    abort();
+
+  if (16777217L != (float)16777217e0)
+    abort();
+
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920711-1.c b/gcc/testsuite/gcc.c-torture/execute/920711-1.c
new file mode 100644
index 00000000000..aa83452dafe
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920711-1.c
@@ -0,0 +1,2 @@
+f(long a){return (--a > 0);}
+main(){if(f(0x80000000L)==0)abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920721-1.c b/gcc/testsuite/gcc.c-torture/execute/920721-1.c
new file mode 100644
index 00000000000..086b5463f7f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920721-1.c
@@ -0,0 +1,2 @@
+long f(short a,short b){return (long)a/b;}
+main(){if(f(-32768,-1)!=32768L)abort();else exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920721-2.c b/gcc/testsuite/gcc.c-torture/execute/920721-2.c
new file mode 100644
index 00000000000..ed4e0bf8700
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920721-2.c
@@ -0,0 +1,2 @@
+f(){}
+main(){int n=2;double x[n];f();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920721-3.c b/gcc/testsuite/gcc.c-torture/execute/920721-3.c
new file mode 100644
index 00000000000..61f605d0ad9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920721-3.c
@@ -0,0 +1,26 @@
+static inline fu (unsigned short data)
+{
+  return data;
+}
+ru(i)
+{
+   if(fu(i++)!=5)abort();
+   if(fu(++i)!=7)abort();
+}
+static inline fs (signed short data)
+{
+  return data;
+}
+rs(i)
+{
+   if(fs(i++)!=5)abort();
+   if(fs(++i)!=7)abort();
+}
+
+
+main()
+{
+  ru(5);
+  rs(5);
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920721-4.c b/gcc/testsuite/gcc.c-torture/execute/920721-4.c
new file mode 100644
index 00000000000..3cccc5b3024
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920721-4.c
@@ -0,0 +1,60 @@
+#ifndef NO_LABEL_VALUES
+int try (int num) {
+  __label__ lab1, lab2, lab3, lab4, lab5, lab6, default_lab;
+
+  void *do_switch (int num) {
+    switch(num) {
+    case 1:
+      return &&lab1;
+    case 2:
+      return &&lab2;
+    case 3:
+      return &&lab3;
+    case 4:
+      return &&lab4;
+    case 5:
+      return &&lab5;
+    case 6:
+      return &&lab6;
+    default:
+      return &&default_lab;
+    }
+  }
+
+  goto *do_switch (num);
+
+ lab1:
+  return 1;
+
+ lab2:
+  return 2;
+
+ lab3:
+  return 3;
+
+ lab4:
+  return 4;
+
+ lab5:
+  return 5;
+
+ lab6:
+  return 6;
+
+ default_lab:
+  return -1;
+}
+
+main()
+{
+  int i;
+  for (i = 1; i <= 6; i++)
+    {
+      if (try (i) != i)
+	abort();
+    }
+  exit(0);
+}
+#else
+main(){ exit (0); }
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/920726-1.c b/gcc/testsuite/gcc.c-torture/execute/920726-1.c
new file mode 100644
index 00000000000..d6042c9f5d1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920726-1.c
@@ -0,0 +1,63 @@
+#include <stdio.h>
+#include <stdarg.h>
+
+struct spurious
+{
+    int anumber;
+};
+
+int first(char *buf, char *fmt, ...)
+{
+  int pos, number;
+  va_list args;
+  int dummy;
+  char *bp = buf;
+
+  va_start(args, fmt);
+  for (pos = 0; fmt[pos]; pos++)
+    if (fmt[pos] == 'i')
+      {
+	number = va_arg(args, int);
+	sprintf(bp, "%d", number);
+	bp += strlen(bp);
+      }
+    else
+      *bp++ = fmt[pos];
+
+  va_end(args);
+  *bp = 0;
+  return dummy;
+}
+
+struct spurious second(char *buf,char *fmt, ...)
+{
+  int pos, number;
+  va_list args;
+  struct spurious dummy;
+  char *bp = buf;
+
+  va_start(args, fmt);
+  for (pos = 0; fmt[pos]; pos++)
+    if (fmt[pos] == 'i')
+      {
+	number = va_arg(args, int);
+	sprintf(bp, "%d", number);
+	bp += strlen(bp);
+      }
+    else
+      *bp++ = fmt[pos];
+
+  va_end(args);
+  *bp = 0;
+  return dummy;
+}
+
+main()
+{
+  char buf1[100], buf2[100];
+  first(buf1, "i i ", 5, 20);
+  second(buf2, "i i ", 5, 20);
+  if (strcmp ("5 20 ", buf1) || strcmp ("5 20 ", buf2))
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920728-1.c b/gcc/testsuite/gcc.c-torture/execute/920728-1.c
new file mode 100644
index 00000000000..7a2968b71be
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920728-1.c
@@ -0,0 +1,24 @@
+typedef struct {int dims[0]; } *A;
+
+f(unsigned long obj)
+{
+  unsigned char y = obj >> 24;
+  y &= ~4;
+
+  if ((y==0)||(y!=251  ))
+    abort();
+
+  if(((int)obj&7)!=7)return;
+
+  REST_OF_CODE_JUST_HERE_TO_TRIGGER_THE_BUG:
+
+  {
+    unsigned char t = obj >> 24;
+    if (!(t==0)&&(t<=0x03))
+      return 0;
+    return ((A)(obj&0x00FFFFFFL))->dims[1];
+  }
+}
+
+long g(){return 0xff000000L;}
+main (){int x;f(g());exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920731-1.c b/gcc/testsuite/gcc.c-torture/execute/920731-1.c
new file mode 100644
index 00000000000..de0fb58fcde
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920731-1.c
@@ -0,0 +1,2 @@
+f(x){int i;for(i=0;i<8&&(x&1)==0;x>>=1,i++);return i;}
+main(){if(f(4)!=2)abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920810-1.c b/gcc/testsuite/gcc.c-torture/execute/920810-1.c
new file mode 100644
index 00000000000..9565bfc1a2b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920810-1.c
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+typedef struct{void*super;int name;int size;}t;
+t*f(t*clas,int size)
+{
+  t*child=(t*)malloc(size);
+  memcpy(child,clas,clas->size);
+  child->super=clas;
+  child->name=0;
+  child->size=size;
+  return child;
+}
+main()
+{
+  t foo,*bar;
+  memset(&foo,37,sizeof(t));
+  foo.size=sizeof(t);
+  bar=f(&foo,sizeof(t));
+  if(bar->super!=&foo||bar->name!=0||bar->size!=sizeof(t))abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920812-1.c b/gcc/testsuite/gcc.c-torture/execute/920812-1.c
new file mode 100644
index 00000000000..b49ab425b21
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920812-1.c
@@ -0,0 +1,3 @@
+typedef int t;
+f(t y){switch(y){case 1:return 1;}return 0;}
+main(){if(f((t)1)!=1)abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920829-1.c b/gcc/testsuite/gcc.c-torture/execute/920829-1.c
new file mode 100644
index 00000000000..ed2c2271caa
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920829-1.c
@@ -0,0 +1,2 @@
+long long c=2863311530LL,c3=2863311530LL*3;
+main(){if(c*3!=c3)abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920908-1.c b/gcc/testsuite/gcc.c-torture/execute/920908-1.c
new file mode 100644
index 00000000000..98fbb5eaa6d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920908-1.c
@@ -0,0 +1,28 @@
+/* REPRODUCED:RUN:SIGNAL MACHINE:mips OPTIONS: */
+
+#include <stdarg.h>
+
+typedef struct{int A;}T;
+
+T f(int x,...)
+{
+va_list ap;
+T X;
+va_start(ap,x);
+X=va_arg(ap,T);
+if(X.A!=10)abort();
+X=va_arg(ap,T);
+if(X.A!=20)abort();
+va_end(ap);
+return X;
+}
+
+main()
+{
+T X,Y;
+int i;
+X.A=10;
+Y.A=20;
+f(2,X,Y);
+exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920908-2.c b/gcc/testsuite/gcc.c-torture/execute/920908-2.c
new file mode 100644
index 00000000000..66a6d86a7e7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920908-2.c
@@ -0,0 +1,23 @@
+/*
+CONF:m68k-sun-sunos4.1.1
+OPTIONS:-O
+*/
+struct T
+{
+unsigned i:8;
+unsigned c:24;
+};
+f(struct T t)
+{
+struct T s[1];
+s[0]=t;
+return(char)s->c;
+}
+main()
+{
+struct T t;
+t.i=0xff;
+t.c=0xffff11;
+if(f(t)!=0x11)abort();
+exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920909-1.c b/gcc/testsuite/gcc.c-torture/execute/920909-1.c
new file mode 100644
index 00000000000..c8880348c12
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920909-1.c
@@ -0,0 +1,2 @@
+f(a){switch(a){case 0x402:return a+1;case 0x403:return a+2;case 0x404:return a+3;case 0x405:return a+4;case 0x406:return 1;case 0x407:return 4;}return 0;}
+main(){if(f(1))abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920922-1.c b/gcc/testsuite/gcc.c-torture/execute/920922-1.c
new file mode 100644
index 00000000000..4fae192bb90
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920922-1.c
@@ -0,0 +1,14 @@
+unsigned long*
+f(p)unsigned long*p;
+{
+  unsigned long a = (*p++) >> 24;
+  return p + a;
+}
+
+main ()
+{
+  unsigned long x = 0x80000000UL;
+  if (f(&x) != &x + 0x81)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/920929-1.c b/gcc/testsuite/gcc.c-torture/execute/920929-1.c
new file mode 100644
index 00000000000..e43444e31d7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/920929-1.c
@@ -0,0 +1,13 @@
+/* REPRODUCED:RUN:SIGNAL MACHINE:sparc OPTIONS: */
+f(int n)
+{
+int i;
+double v[n];
+for(i=0;i<n;i++)
+v[i]=0;
+}
+main()
+{
+f(100);
+exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921006-1.c b/gcc/testsuite/gcc.c-torture/execute/921006-1.c
new file mode 100644
index 00000000000..50fbdb71125
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921006-1.c
@@ -0,0 +1,6 @@
+/* REPRODUCED:RUN:SIGNAL MACHINE:i386 OPTIONS:-O */
+main()
+{
+if(strcmp("X","")<0)abort();
+exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921007-1.c b/gcc/testsuite/gcc.c-torture/execute/921007-1.c
new file mode 100644
index 00000000000..23ab52e7ae8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921007-1.c
@@ -0,0 +1,7 @@
+static int strcmp(){return-1;}
+#define strcmp __builtin_strcmp
+main()
+{
+if(strcmp("X","X\376")>=0)abort();
+exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921013-1.c b/gcc/testsuite/gcc.c-torture/execute/921013-1.c
new file mode 100644
index 00000000000..d041beb257a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921013-1.c
@@ -0,0 +1,20 @@
+f(d,x,y,n)
+int*d;
+float*x,*y;
+int n;
+{
+  while(n--){*d++=*x++==*y++;}
+}
+
+main()
+{
+  int r[4];
+  float a[]={5,1,3,5};
+  float b[]={2,4,3,0};
+  int i;
+  f(r,a,b,4);
+  for(i=0;i<4;i++)
+    if((a[i]==b[i])!=r[i])
+      abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921016-1.c b/gcc/testsuite/gcc.c-torture/execute/921016-1.c
new file mode 100644
index 00000000000..46f8a838765
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921016-1.c
@@ -0,0 +1,10 @@
+main()
+{
+int j=1081;
+struct
+{
+signed int m:11;
+}l;
+if((l.m=j)==j)abort();
+exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921017-1.c b/gcc/testsuite/gcc.c-torture/execute/921017-1.c
new file mode 100644
index 00000000000..3a0db5c4d56
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921017-1.c
@@ -0,0 +1,15 @@
+f(n)
+{
+  int a[n];
+  int g(i)
+    {
+      return a[i];
+    }
+  a[1]=4711;
+  return g(1);
+}
+main()
+{
+  if(f(2)!=4711)abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921019-1.c b/gcc/testsuite/gcc.c-torture/execute/921019-1.c
new file mode 100644
index 00000000000..f48613a8ba9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921019-1.c
@@ -0,0 +1,8 @@
+void *foo[]={(void *)&("X"[0])};
+
+main ()
+{
+  if (((char*)foo[0])[0] != 'X')
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921019-2.c b/gcc/testsuite/gcc.c-torture/execute/921019-2.c
new file mode 100644
index 00000000000..9003e7b64d5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921019-2.c
@@ -0,0 +1,8 @@
+main()
+{
+  double x,y=0.5;
+  x=y/0.2;
+  if(x!=x)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921029-1.c b/gcc/testsuite/gcc.c-torture/execute/921029-1.c
new file mode 100644
index 00000000000..76fc974c2f0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921029-1.c
@@ -0,0 +1,42 @@
+typedef unsigned long long ULL;
+ULL back;
+ULL hpart, lpart;
+ULL
+build(long h, long l)
+{
+  hpart = h;
+  hpart <<= 32;
+  lpart = l;
+  lpart &= 0xFFFFFFFFLL;
+  back = hpart | lpart;
+  return back;
+}
+
+main()
+{
+  if (build(0, 1) != 0x0000000000000001LL)
+    abort();
+  if (build(0, 0) != 0x0000000000000000LL)
+    abort();
+  if (build(0, 0xFFFFFFFF) != 0x00000000FFFFFFFFLL)
+    abort();
+  if (build(0, 0xFFFFFFFE) != 0x00000000FFFFFFFELL)
+    abort();
+  if (build(1, 1) != 0x0000000100000001LL)
+    abort();
+  if (build(1, 0) != 0x0000000100000000LL)
+    abort();
+  if (build(1, 0xFFFFFFFF) != 0x00000001FFFFFFFFLL)
+    abort();
+  if (build(1, 0xFFFFFFFE) != 0x00000001FFFFFFFELL)
+    abort();
+  if (build(0xFFFFFFFF, 1) != 0xFFFFFFFF00000001LL)
+    abort();
+  if (build(0xFFFFFFFF, 0) != 0xFFFFFFFF00000000LL)
+    abort();
+  if (build(0xFFFFFFFF, 0xFFFFFFFF) != 0xFFFFFFFFFFFFFFFFLL)
+    abort();
+  if (build(0xFFFFFFFF, 0xFFFFFFFE) != 0xFFFFFFFFFFFFFFFELL)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921104-1.c b/gcc/testsuite/gcc.c-torture/execute/921104-1.c
new file mode 100644
index 00000000000..4b6f4bcfb5b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921104-1.c
@@ -0,0 +1,8 @@
+main ()
+{
+  unsigned long val = 1;
+
+  if (val > (unsigned long) ~0)
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921110-1.c b/gcc/testsuite/gcc.c-torture/execute/921110-1.c
new file mode 100644
index 00000000000..27ff96f18fb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921110-1.c
@@ -0,0 +1,7 @@
+extern int abort();
+typedef int (*frob)();
+frob f[] = {abort};
+main()
+{
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921112-1.c b/gcc/testsuite/gcc.c-torture/execute/921112-1.c
new file mode 100644
index 00000000000..5946398e3c0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921112-1.c
@@ -0,0 +1,21 @@
+union u {
+  struct { int i1, i2; } t;
+  double d;
+} x[2], v;
+
+f (x, v)
+     union u *x, v;
+{
+  *++x = v;
+}
+
+main()
+{
+  x[1].t.i1 = x[1].t.i2 = 0;
+  v.t.i1 = 1;
+  v.t.i2 = 2;
+  f (x, v);
+  if (x[1].t.i1 != 1 || x[1].t.i2 != 2)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921113-1.c b/gcc/testsuite/gcc.c-torture/execute/921113-1.c
new file mode 100644
index 00000000000..78972bc975e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921113-1.c
@@ -0,0 +1,63 @@
+#define STACK_REQUIREMENT (128 * 128 * 4 + 1024)
+#if defined (STACK_SIZE) && STACK_SIZE < STACK_REQUIREMENT
+main () { exit (0); }
+#else
+
+typedef struct {
+  float wsx;
+} struct_list;
+
+typedef struct_list *list_t;
+
+typedef struct {
+  float x, y;
+} vector_t;
+
+w(float x, float y) {}
+
+f1(float x, float y)
+{
+  if (x != 0 || y != 0)
+    abort();
+}
+f2(float x, float y)
+{
+  if (x != 1 || y != 1)
+    abort();
+}
+
+gitter(int count, vector_t pos[], list_t list, int *nww, vector_t limit[2], float r)
+{
+  float d;
+  int gitt[128][128];
+
+  f1(limit[0].x, limit[0].y);
+  f2(limit[1].x, limit[1].y);
+
+  *nww = 0;
+
+  d = pos[0].x;
+  if (d <= 0.)
+    {
+      w(d, r);
+      if (d <= r * 0.5)
+	{
+	  w(d, r);
+	  list[0].wsx = 1;
+	}
+    }
+}
+
+vector_t pos[1] = {{0., 0.}};
+vector_t limit[2] = {{0.,0.},{1.,1.}};
+
+main()
+{
+  int nww;
+  struct_list list;
+
+  gitter(1, pos, &list, &nww, limit, 1.);
+  exit(0);
+}
+
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/921117-1.c b/gcc/testsuite/gcc.c-torture/execute/921117-1.c
new file mode 100644
index 00000000000..2ed30fbeeef
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921117-1.c
@@ -0,0 +1,22 @@
+struct s {
+  char text[11];
+  int flag;
+} cell;
+
+int
+check (struct s p)
+{
+  if (p.flag != 99)
+    return 1;
+  return strcmp (p.text, "0123456789");
+}
+
+main ()
+{
+  cell.flag = 99;
+  strcpy (cell.text, "0123456789");
+
+  if (check (cell))
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921123-1.c b/gcc/testsuite/gcc.c-torture/execute/921123-1.c
new file mode 100644
index 00000000000..d3daf120f0a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921123-1.c
@@ -0,0 +1,13 @@
+f(short *p)
+{
+  short x = *p;
+  return (--x < 0);
+}
+
+main()
+{
+  short x = -10;
+  if (!f(&x))
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921123-2.c b/gcc/testsuite/gcc.c-torture/execute/921123-2.c
new file mode 100644
index 00000000000..3028717cf5a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921123-2.c
@@ -0,0 +1,24 @@
+typedef struct
+{
+  unsigned short b0, b1, b2, b3;
+} four_quarters;
+
+four_quarters x;
+int a, b;
+
+void f (four_quarters j)
+{
+  b = j.b2;
+  a = j.b3;
+}
+
+main ()
+{
+  four_quarters x;
+  x.b0 = x.b1 = x.b2 = 0;
+  x.b3 = 38;
+  f(x);
+  if (a != 38)
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921124-1.c b/gcc/testsuite/gcc.c-torture/execute/921124-1.c
new file mode 100644
index 00000000000..51b090b4de1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921124-1.c
@@ -0,0 +1,19 @@
+f(x, d1, d2, d3)
+   double d1, d2, d3;
+{
+   return x;
+}
+
+g(b,s,x,y,i,j)
+     char *b,*s;
+     double x,y;
+{
+  if (x != 1.0 || y != 2.0 || i != 3 || j != 4)
+    abort();
+}
+
+main()
+{
+  g("","", 1.0, 2.0, f(3, 0.0, 0.0, 0.0), f(4, 0.0, 0.0, 0.0));
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921202-1.c b/gcc/testsuite/gcc.c-torture/execute/921202-1.c
new file mode 100644
index 00000000000..d42fc74403c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921202-1.c
@@ -0,0 +1,36 @@
+main ()
+{
+  long dx[2055];
+  long dy[2055];
+  long s1[2055];
+  int cyx, cyy;
+  int i;
+  long size;
+
+  for (;;)
+    {
+      size = 2055;
+      mpn_random2 (s1, size);
+
+      for (i = 0; i < 1; i++)
+	;
+
+      dy[size] = 0x12345678;
+
+      for (i = 0; i < 1; i++)
+	cyy = mpn_mul_1 (dy, s1, size);
+
+      if (cyx != cyy || mpn_cmp (dx, dy, size + 1) != 0 || dx[size] != 0x12345678)
+	{
+	  foo ("", 8, cyy); mpn_print (dy, size);
+	}
+      exxit();
+    }
+}
+
+foo (){}
+mpn_mul_1(){}
+mpn_print (){}
+mpn_random2(){}
+mpn_cmp(){}
+exxit(){exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921202-2.c b/gcc/testsuite/gcc.c-torture/execute/921202-2.c
new file mode 100644
index 00000000000..48d4a412d1b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921202-2.c
@@ -0,0 +1,13 @@
+int
+f(long long x)
+{
+  x >>= 8;
+  return x & 0xff;
+}
+
+main()
+{
+  if (f(0x0123456789ABCDEFLL) != 0xCD)
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921204-1.c b/gcc/testsuite/gcc.c-torture/execute/921204-1.c
new file mode 100644
index 00000000000..9e4f4a6bae7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921204-1.c
@@ -0,0 +1,36 @@
+typedef struct {
+  unsigned b0:1, f1:17, b18:1, b19:1, b20:1, f2:11;
+} bf;
+
+typedef union {
+  bf b;
+  unsigned w;
+} bu;
+
+bu
+f(bu i)
+{
+  bu o = i;
+
+  if (o.b.b0)
+    o.b.b18 = 1,
+    o.b.b20 = 1;
+  else
+    o.b.b18 = 0,
+    o.b.b20 = 0;
+
+  return o;
+}
+
+main()
+{
+  bu a;
+  bu r;
+
+  a.w = 0x4000000;
+  a.b.b0 = 0;
+  r = f(a);
+  if (a.w != r.w)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921207-1.c b/gcc/testsuite/gcc.c-torture/execute/921207-1.c
new file mode 100644
index 00000000000..5ee9d27cc2f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921207-1.c
@@ -0,0 +1,15 @@
+f()
+{
+  unsigned b = 0;
+
+  if (b > ~0U)
+    b = ~0U;
+
+  return b;
+}
+main()
+{
+  if (f()!=0)
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921208-1.c b/gcc/testsuite/gcc.c-torture/execute/921208-1.c
new file mode 100644
index 00000000000..143ef63b0c9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921208-1.c
@@ -0,0 +1,18 @@
+double
+f(double x)
+{
+  return x*x;
+}
+
+double
+Int(double (*f)(double), double a)
+{
+  return (*f)(a);
+}
+
+main()
+{
+  if (Int(&f,2.0) != 4.0)
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921208-2.c b/gcc/testsuite/gcc.c-torture/execute/921208-2.c
new file mode 100644
index 00000000000..d5edcf97c66
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921208-2.c
@@ -0,0 +1,26 @@
+#define STACK_REQUIREMENT (100000 * 4 + 1024)
+#if defined (STACK_SIZE) && STACK_SIZE < STACK_REQUIREMENT
+main () { exit (0); }
+#else
+
+g(){}
+
+f()
+{
+  int i;
+  float a[100000];
+
+  for (i = 0; i < 1; i++)
+    {
+      g(1.0, 1.0 + i / 2.0 * 3.0);
+      g(2.0, 1.0 + i / 2.0 * 3.0);
+    }
+}
+
+main ()
+{
+  f();
+  exit(0);
+}
+
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/921215-1.c b/gcc/testsuite/gcc.c-torture/execute/921215-1.c
new file mode 100644
index 00000000000..4fa3b7dfccc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921215-1.c
@@ -0,0 +1,24 @@
+main()
+{
+#ifndef NO_TRAMPOLINES
+  void p(void ((*f) (void ())))
+    {
+      void r()
+	{
+	  foo ();
+	}
+
+      f(r);
+    }
+
+  void q(void ((*f)()))
+    {
+      f();
+    }
+
+  p(q);
+#endif
+  exit(0);
+}
+
+foo(){}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921218-1.c b/gcc/testsuite/gcc.c-torture/execute/921218-1.c
new file mode 100644
index 00000000000..ab7bc19cc15
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921218-1.c
@@ -0,0 +1,11 @@
+f()
+{
+  return (unsigned char)("\377"[0]);
+}
+
+main()
+{
+  if (f() != (unsigned char)(0377))
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/921218-2.c b/gcc/testsuite/gcc.c-torture/execute/921218-2.c
new file mode 100644
index 00000000000..b5d57e9c3c8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/921218-2.c
@@ -0,0 +1,17 @@
+f()
+{
+  long l2;
+  unsigned short us;
+  unsigned long ul;
+  short s2;
+
+  ul = us = l2 = s2 = -1;
+  return ul;
+}
+
+main()
+{
+  if (f()!=(unsigned short)-1)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930106-1.c b/gcc/testsuite/gcc.c-torture/execute/930106-1.c
new file mode 100644
index 00000000000..8081f926013
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930106-1.c
@@ -0,0 +1,27 @@
+#if defined (STACK_SIZE)
+#define DUMMY_SIZE 9
+#else
+#define DUMMY_SIZE 399999
+#endif
+
+double g()
+{
+  return 1.0;
+}
+
+f()
+{
+  char dummy[DUMMY_SIZE];
+  double f1, f2, f3;
+  f1 = g();
+  f2 = g();
+  f3 = g();
+  return f1 + f2 + f3;
+}
+
+main()
+{
+  if (f() != 3.0)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930111-1.c b/gcc/testsuite/gcc.c-torture/execute/930111-1.c
new file mode 100644
index 00000000000..e908f14f67f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930111-1.c
@@ -0,0 +1,22 @@
+main()
+{
+  if (wwrite((long long) 0) != 123)
+    abort();
+  exit(0);
+}
+
+int
+wwrite(long long i)
+{
+  switch(i)
+    {
+    case 3:
+    case 10:
+    case 23:
+    case 28:
+    case 47:
+      return 0;
+    default:
+      return 123;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930123-1.c b/gcc/testsuite/gcc.c-torture/execute/930123-1.c
new file mode 100644
index 00000000000..7365bae5200
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930123-1.c
@@ -0,0 +1,16 @@
+f(int *x)
+{
+  *x = 0;
+}
+
+main()
+{
+  int s, c, x;
+  char a[] = "c";
+
+  f(&s);
+  a[c = 0] = s == 0 ? (x=1, 'a') : (x=2, 'b');
+  if (a[c] != 'a')
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930126-1.c b/gcc/testsuite/gcc.c-torture/execute/930126-1.c
new file mode 100644
index 00000000000..ff08e7d6131
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930126-1.c
@@ -0,0 +1,20 @@
+struct s {
+  unsigned long long a:8, b:32;
+};
+
+struct s
+f(struct s x)
+{
+  x.b = 0xcdef1234;
+  return x;
+}
+
+main()
+{
+  static struct s i;
+  i.a = 12;
+  i = f(i);
+  if (i.a != 12 || i.b != 0xcdef1234)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930208-1.c b/gcc/testsuite/gcc.c-torture/execute/930208-1.c
new file mode 100644
index 00000000000..464b69d437e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930208-1.c
@@ -0,0 +1,23 @@
+typedef union {
+  long l;
+  struct { char b3, b2, b1, b0; } c;
+} T;
+
+f (T u)
+{
+  ++u.c.b0;
+  ++u.c.b3;
+  return (u.c.b1 != 2 || u.c.b2 != 2);
+}
+
+main ()
+{
+  T u;
+  u.c.b1 = 2;
+  u.c.b2 = 2;
+  u.c.b0 = ~0;
+  u.c.b3 = ~0;
+  if (f (u))
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930406-1.c b/gcc/testsuite/gcc.c-torture/execute/930406-1.c
new file mode 100644
index 00000000000..1546f5150dd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930406-1.c
@@ -0,0 +1,19 @@
+f()
+{
+  int x = 1;
+  char big[0x1000];
+
+  ({
+    __label__ mylabel;
+  mylabel:
+    x++;
+    if (x != 3)
+      goto mylabel;
+  });
+  exit(0);
+}
+
+main()
+{
+  f();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930408-1.c b/gcc/testsuite/gcc.c-torture/execute/930408-1.c
new file mode 100644
index 00000000000..42ffc098f80
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930408-1.c
@@ -0,0 +1,27 @@
+typedef enum foo E;
+enum foo { e0, e1 };
+
+struct {
+  E eval;
+} s;
+
+p()
+{
+  abort();
+}
+
+f()
+{
+  switch (s.eval)
+    {
+    case e0:
+      p();
+    }
+}
+
+main()
+{
+  s.eval = e1;
+  f();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930429-1.c b/gcc/testsuite/gcc.c-torture/execute/930429-1.c
new file mode 100644
index 00000000000..656d928ebd7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930429-1.c
@@ -0,0 +1,14 @@
+char *
+f (char *p)
+{
+  short x = *p++ << 16;
+  return p;
+}
+
+main ()
+{
+  char *p = "";
+  if (f (p) != p + 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930429-2.c b/gcc/testsuite/gcc.c-torture/execute/930429-2.c
new file mode 100644
index 00000000000..e52c8b4d723
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930429-2.c
@@ -0,0 +1,14 @@
+int
+f (b)
+{
+  return (b >> 1) > 0;
+}
+
+main ()
+{
+  if (!f (9))
+    abort ();
+  if (f (-9))
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930513-1.c b/gcc/testsuite/gcc.c-torture/execute/930513-1.c
new file mode 100644
index 00000000000..4544471ec7d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930513-1.c
@@ -0,0 +1,16 @@
+#include <stdio.h>
+char buf[2];
+
+f (fp)
+     int (*fp)(char *, const char *, ...);
+{
+  (*fp)(buf, "%.0f", 5.0);
+}
+
+main ()
+{
+  f (&sprintf);
+  if (buf[0] != '5' || buf[1] != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930513-2.c b/gcc/testsuite/gcc.c-torture/execute/930513-2.c
new file mode 100644
index 00000000000..3731f620497
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930513-2.c
@@ -0,0 +1,27 @@
+sub3 (i)
+     const int *i;
+{
+}
+
+eq (a, b)
+{
+  static int i = 0;
+  if (a != i)
+    abort ();
+  i++;
+}
+
+main ()
+{
+  int i;
+
+  for (i = 0; i < 4; i++)
+    {
+      const int j = i;
+      int k;
+      sub3 (&j);
+      k = j;
+      eq (k, k);
+    }
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930518-1.c b/gcc/testsuite/gcc.c-torture/execute/930518-1.c
new file mode 100644
index 00000000000..44bdf96afb7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930518-1.c
@@ -0,0 +1,24 @@
+int bar = 0;
+
+f (p)
+     int *p;
+{
+  int foo = 2;
+
+  while (foo > bar)
+    {
+      foo -=  bar;
+      *p++ = foo;
+      bar = 1;
+    }
+}
+
+main ()
+{
+  int tab[2];
+  tab[0] = tab[1] = 0;
+  f (tab);
+  if (tab[0] != 2 || tab[1] != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930526-1.c b/gcc/testsuite/gcc.c-torture/execute/930526-1.c
new file mode 100644
index 00000000000..bbf63c6009a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930526-1.c
@@ -0,0 +1,18 @@
+inline
+f (x)
+{
+  int *(p[25]);
+  int m[25*7];
+  int i;
+
+  for (i = 0; i < 25; i++)
+    p[i] = m + x*i;
+
+  p[1][0] = 0;
+}
+
+main ()
+{
+  f (7);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930527-1.c b/gcc/testsuite/gcc.c-torture/execute/930527-1.c
new file mode 100644
index 00000000000..fef34bf6b7f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930527-1.c
@@ -0,0 +1,11 @@
+f (unsigned char x)
+{
+  return (0x50 | (x >> 4)) ^ 0xff;
+}
+
+main ()
+{
+  if (f (0) != 0xaf)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930529-1.c b/gcc/testsuite/gcc.c-torture/execute/930529-1.c
new file mode 100644
index 00000000000..906338e6e9a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930529-1.c
@@ -0,0 +1,45 @@
+dd (x,d) { return x / d; }
+
+main ()
+{
+  int i;
+  for (i = -3; i <= 3; i++)
+    {
+      if (dd (i, 1) != i / 1)
+	abort ();
+      if (dd (i, 2) != i / 2)
+	abort ();
+      if (dd (i, 3) != i / 3)
+	abort ();
+      if (dd (i, 4) != i / 4)
+	abort ();
+      if (dd (i, 5) != i / 5)
+	abort ();
+      if (dd (i, 6) != i / 6)
+	abort ();
+      if (dd (i, 7) != i / 7)
+	abort ();
+      if (dd (i, 8) != i / 8)
+	abort ();
+    }
+  for (i = ((unsigned) ~0 >> 1) - 3; i <= ((unsigned) ~0 >> 1) + 3; i++)
+    {
+      if (dd (i, 1) != i / 1)
+	abort ();
+      if (dd (i, 2) != i / 2)
+	abort ();
+      if (dd (i, 3) != i / 3)
+	abort ();
+      if (dd (i, 4) != i / 4)
+	abort ();
+      if (dd (i, 5) != i / 5)
+	abort ();
+      if (dd (i, 6) != i / 6)
+	abort ();
+      if (dd (i, 7) != i / 7)
+	abort ();
+      if (dd (i, 8) != i / 8)
+	abort ();
+    }
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930603-1.c b/gcc/testsuite/gcc.c-torture/execute/930603-1.c
new file mode 100644
index 00000000000..6a84de03562
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930603-1.c
@@ -0,0 +1,22 @@
+float fx (x)
+     float x;
+{
+  return 1.0 + 3.0 / (2.302585093 * x);
+}
+
+main ()
+{
+  float fx (), inita (), initc (), a, b, c;
+  a = inita ();
+  c = initc ();
+  f ();
+  b = fx (c) + a;
+  f ();
+  if (a != 3.0 || b < 4.3257 || b > 4.3258 || c != 4.0)
+    abort ();
+  exit (0);
+}
+
+float inita () { return 3.0; }
+float initc () { return 4.0; }
+f () {}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930603-2.c b/gcc/testsuite/gcc.c-torture/execute/930603-2.c
new file mode 100644
index 00000000000..8cf06a21139
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930603-2.c
@@ -0,0 +1,19 @@
+int w[2][2];
+
+f ()
+{
+  int i, j;
+
+  for (i = 0; i < 2; i++)
+    for (j = 0; j < 2; j++)
+      if (i == j)
+	w[i][j] = 1;
+}
+
+main ()
+{
+  f ();
+  if (w[0][0] != 1 || w[1][1] != 1 || w[1][0] != 0 || w[0][1] != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930603-3.c b/gcc/testsuite/gcc.c-torture/execute/930603-3.c
new file mode 100644
index 00000000000..22e5aed4a8b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930603-3.c
@@ -0,0 +1,30 @@
+f (b, c)
+     unsigned char *b;
+     int c;
+{
+  unsigned long v = 0;
+  switch (c)
+    {
+    case 'd':
+      v = ((unsigned long)b[0] << 8) + b[1];
+      v >>= 9;
+      break;
+
+    case 'k':
+      v = b[3] >> 4;
+      break;
+
+    default:
+      abort ();
+    }
+
+  return v;
+}
+main ()
+{
+  char buf[4];
+  buf[0] = 170; buf[1] = 5;
+  if (f (buf, 'd') != 85)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930608-1.c b/gcc/testsuite/gcc.c-torture/execute/930608-1.c
new file mode 100644
index 00000000000..004a4400709
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930608-1.c
@@ -0,0 +1,11 @@
+double f (double a) {}
+double (* const a[]) (double) = {&f};
+
+main ()
+{
+  double (*p) ();
+  p = &f;
+  if (p != a[0])
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930614-1.c b/gcc/testsuite/gcc.c-torture/execute/930614-1.c
new file mode 100644
index 00000000000..7b206344b3a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930614-1.c
@@ -0,0 +1,19 @@
+f (double *ty)
+{
+  *ty = -1.0;
+}
+
+main ()
+{
+  double foo[6];
+  double tx = 0.0, ty, d;
+
+  f (&ty);
+
+  if (ty < 0)
+    ty = -ty;
+  d = (tx > ty) ? tx : ty;
+  if (ty != d)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930614-2.c b/gcc/testsuite/gcc.c-torture/execute/930614-2.c
new file mode 100644
index 00000000000..ab83a7e3bb9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930614-2.c
@@ -0,0 +1,20 @@
+main ()
+{
+  int i, j, k, l;
+  float x[8][2][8][2];
+
+  for (i = 0; i < 8; i++)
+    for (j = i; j < 8; j++)
+      for (k = 0; k < 2; k++)
+	for (l = 0; l < 2; l++)
+	  {
+	    if ((i == j) && (k == l))
+	      x[i][k][j][l] = 0.8;
+	    else
+	      x[i][k][j][l] = 0.8;
+	    if (x[i][k][j][l] < 0.0)
+	      abort ();
+	  }
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930621-1.c b/gcc/testsuite/gcc.c-torture/execute/930621-1.c
new file mode 100644
index 00000000000..6131301df2f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930621-1.c
@@ -0,0 +1,19 @@
+f ()
+{
+  struct {
+    int x : 18;
+    int y : 14;
+  } foo;
+
+  foo.x = 10;
+  foo.y = 20;
+
+  return foo.y;
+}
+
+main ()
+{
+  if (f () != 20)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930622-1.c b/gcc/testsuite/gcc.c-torture/execute/930622-1.c
new file mode 100644
index 00000000000..d733e133d35
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930622-1.c
@@ -0,0 +1,22 @@
+int a = 1, b;
+
+g () { return 0; }
+h (x) {}
+
+f ()
+{
+  if (g () == -1)
+    return 0;
+  a = g ();
+  if (b >= 1)
+    h (a);
+  return 0;
+}
+
+main ()
+{
+  f ();
+  if (a != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930622-2.c b/gcc/testsuite/gcc.c-torture/execute/930622-2.c
new file mode 100644
index 00000000000..d049b002a19
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930622-2.c
@@ -0,0 +1,24 @@
+long double
+ll_to_ld (long long n)
+{
+  return n;
+}
+
+long long
+ld_to_ll (long double n)
+{
+  return n;
+}
+
+main ()
+{
+  long long n;
+
+  if (ll_to_ld (10LL) != 10.0)
+    abort ();
+
+  if (ld_to_ll (10.0) != 10)
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930628-1.c b/gcc/testsuite/gcc.c-torture/execute/930628-1.c
new file mode 100644
index 00000000000..58c612d1a1c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930628-1.c
@@ -0,0 +1,27 @@
+f (double x[2], double y[2])
+{
+  if (x == y)
+    abort ();
+}
+
+main ()
+{
+  struct { int f[3]; double x[1][2]; } tp[4][2];
+  int i, j, ki, kj, mi, mj;
+  float bdm[4][2][4][2];
+
+  for (i = 0; i < 4; i++)
+    for (j = i; j < 4; j++)
+      for (ki = 0; ki < 2; ki++)
+	for (kj = 0; kj < 2; kj++)
+	  if ((j == i) && (ki == kj))
+	    bdm[i][ki][j][kj] = 1000.0;
+	  else
+	    {
+	      for (mi = 0; mi < 1; mi++)
+		for (mj = 0; mj < 1; mj++)
+		  f (tp[i][ki].x[mi], tp[j][kj].x[mj]);
+	      bdm[i][ki][j][kj] = 1000.0;
+	    }
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930630-1.c b/gcc/testsuite/gcc.c-torture/execute/930630-1.c
new file mode 100644
index 00000000000..4befa835d0d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930630-1.c
@@ -0,0 +1,19 @@
+main ()
+{
+  struct
+    {
+      signed int bf0:17;
+      signed int bf1:7;
+    } bf;
+
+  bf.bf1 = 7;
+  f (bf.bf1);
+  exit (0);
+}
+
+f (x)
+     int x;
+{
+  if (x != 7)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930702-1.c b/gcc/testsuite/gcc.c-torture/execute/930702-1.c
new file mode 100644
index 00000000000..8828a701cb9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930702-1.c
@@ -0,0 +1,14 @@
+fp (double a, int b)
+{
+  if (a != 33 || b != 11)
+    abort ();
+}
+
+main ()
+{
+  int (*f) (double, int) = fp;
+
+  fp (33, 11);
+  f (33, 11);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930713-1.c b/gcc/testsuite/gcc.c-torture/execute/930713-1.c
new file mode 100644
index 00000000000..6b4d5ab796a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930713-1.c
@@ -0,0 +1,23 @@
+typedef struct
+{
+  char x;
+} T;
+
+T
+f (s1)
+     T s1;
+{
+  T s1a;
+  s1a.x = 17;
+  return s1a;
+}
+
+main ()
+{
+  T s1a, s1b;
+  s1a.x = 13;
+  s1b = f (s1a);
+  if (s1a.x != 13 || s1b.x != 17)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930718-1.c b/gcc/testsuite/gcc.c-torture/execute/930718-1.c
new file mode 100644
index 00000000000..a8eacc2d222
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930718-1.c
@@ -0,0 +1,34 @@
+typedef struct rtx_def
+{
+  int f1 :1;
+  int f2 :1;
+} *rtx;
+
+static rtx
+f (orig)
+     register rtx orig;
+{
+  if (orig->f1 || orig->f2)
+    return orig;
+  orig->f2 = 1;
+  return orig;
+}
+
+void
+f2 ()
+{
+  abort ();
+}
+
+main ()
+{
+  struct rtx_def foo;
+  rtx bar;
+
+  foo.f1 = 1;
+  foo.f2 = 0;
+  bar = f (&foo);
+  if (bar != &foo || bar->f2 != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930719-1.c b/gcc/testsuite/gcc.c-torture/execute/930719-1.c
new file mode 100644
index 00000000000..c6557efc735
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930719-1.c
@@ -0,0 +1,23 @@
+int
+f (foo, bar, com)
+{
+  unsigned align;
+  if (foo)
+    return 0;
+  while (1)
+    {
+      switch (bar)
+	{
+	case 1:
+	  if (com != 0)
+ 	    return align;
+	  *(char *) 0 = 0;
+	}
+    }
+}
+
+main ()
+{
+  f (0, 1, 1);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930725-1.c b/gcc/testsuite/gcc.c-torture/execute/930725-1.c
new file mode 100644
index 00000000000..3bd738ca08a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930725-1.c
@@ -0,0 +1,21 @@
+int v;
+
+char *
+g ()
+{
+  return "";
+}
+
+char *
+f ()
+{
+  return (v == 0 ? g () : "abc");
+}
+
+main ()
+{
+  v = 1;
+  if (!strcmp (f (), "abc"))
+    exit (0);
+  abort();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930818-1.c b/gcc/testsuite/gcc.c-torture/execute/930818-1.c
new file mode 100644
index 00000000000..710e3ce2fbe
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930818-1.c
@@ -0,0 +1,15 @@
+static double one = 1.0;
+
+f()
+{
+  int colinear;
+  colinear = (one == 0.0);
+  if (colinear)
+    abort ();
+  return colinear;
+}
+main()
+{
+  if (f()) abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930916-1.c b/gcc/testsuite/gcc.c-torture/execute/930916-1.c
new file mode 100644
index 00000000000..6302614a8c8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930916-1.c
@@ -0,0 +1,13 @@
+f (n)
+     unsigned n;
+{
+  if ((int) n >= 0)
+    abort ();
+}
+
+main ()
+{
+  unsigned x = ~0;
+  f (x);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930921-1.c b/gcc/testsuite/gcc.c-torture/execute/930921-1.c
new file mode 100644
index 00000000000..12e04e30954
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930921-1.c
@@ -0,0 +1,15 @@
+f (x)
+     unsigned x;
+{
+  return (unsigned) (((unsigned long long) x * 0xAAAAAAAB) >> 32) >> 1;
+}
+
+main ()
+{
+  unsigned i;
+
+  for (i = 0; i < 10000; i++)
+    if (f (i) != i / 3)
+      abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930929-1.c b/gcc/testsuite/gcc.c-torture/execute/930929-1.c
new file mode 100644
index 00000000000..31f695442f5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930929-1.c
@@ -0,0 +1,36 @@
+sub1 (i)
+     int i;
+{
+  return i - (5 - i);
+}
+
+sub2 (i)
+     int i;
+{
+  return i + (5 + i);
+}
+
+sub3 (i)
+     int i;
+{
+  return i - (5 + i);
+}
+
+sub4 (i)
+     int i;
+{
+  return i + (5 - i);
+}
+
+main()
+{
+  if (sub1 (20) != 35)
+    abort ();
+  if (sub2 (20) != 45)
+    abort ();
+  if (sub3 (20) != -5)
+    abort ();
+  if (sub4 (20) != 5)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930930-1.c b/gcc/testsuite/gcc.c-torture/execute/930930-1.c
new file mode 100644
index 00000000000..68fdbbfe851
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930930-1.c
@@ -0,0 +1,35 @@
+long *wm_TR;
+long *wm_HB;
+long *wm_SPB;
+
+long mem[100];
+
+f (mr_TR, mr_SPB, mr_HB, reg1, reg2)
+     long *mr_TR;
+     long *mr_SPB;
+     long *mr_HB;
+     long *reg1;
+     long *reg2;
+{
+  long *x = mr_TR;
+
+  for (;;)
+    {
+      if (reg1 < reg2)
+	goto out;
+      if ((long *) *reg1 < mr_HB && (long *) *reg1 >= mr_SPB)
+	*--mr_TR = *reg1;
+      reg1--;
+    }
+ out:
+
+  if (x != mr_TR)
+    abort ();
+}
+
+main ()
+{
+  mem[99] = (long) mem;
+  f (mem + 100, mem + 6, mem + 8, mem + 99, mem + 99);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/930930-2.c b/gcc/testsuite/gcc.c-torture/execute/930930-2.c
new file mode 100644
index 00000000000..eb34d11fe22
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/930930-2.c
@@ -0,0 +1,30 @@
+int
+test_endianness()
+{
+  union doubleword
+    {
+      double d;
+      unsigned long u[2];
+    } dw;
+  dw.d = 10;
+  return dw.u[0] != 0 ? 1 : 0;
+}
+
+int
+test_endianness_vol()
+{
+  union doubleword
+    {
+      volatile double d;
+      volatile long u[2];
+    } dw;
+  dw.d = 10;
+  return dw.u[0] != 0 ? 1 : 0;
+}
+
+main ()
+{
+  if (test_endianness () != test_endianness_vol ())
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/931002-1.c b/gcc/testsuite/gcc.c-torture/execute/931002-1.c
new file mode 100644
index 00000000000..6a02b234394
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931002-1.c
@@ -0,0 +1,28 @@
+f (void (*func) ())
+{
+  func ();
+}
+
+main ()
+{
+#ifndef NO_TRAMPOLINES
+  void t0 ()
+    {
+    }
+
+  void t1 ()
+    {
+      f (t0);
+    }
+
+  void t2 ()
+    {
+      t1 ();
+    }
+
+  t1 ();
+  t1 ();
+  t2 ();
+#endif
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-1.c b/gcc/testsuite/gcc.c-torture/execute/931004-1.c
new file mode 100644
index 00000000000..9c89afdae35
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-1.c
@@ -0,0 +1,30 @@
+struct tiny
+{
+  int c;
+};
+
+f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
+{
+  if (x.c != 10)
+    abort();
+
+  if (y.c != 11)
+    abort();
+
+  if (z.c != 12)
+    abort();
+
+  if (l != 123)
+    abort ();
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-10.c b/gcc/testsuite/gcc.c-torture/execute/931004-10.c
new file mode 100644
index 00000000000..cf0125dba62
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-10.c
@@ -0,0 +1,44 @@
+#include <stdarg.h>
+
+struct tiny
+{
+  char c;
+  char d;
+};
+
+f (int n, ...)
+{
+  struct tiny x;
+  int i;
+
+  va_list ap;
+  va_start (ap,n);
+  for (i = 0; i < n; i++)
+    {
+      x = va_arg (ap,struct tiny);
+      if (x.c != i + 10)
+	abort();
+      if (x.d != i + 20)
+	abort();
+    }
+  {
+    long x = va_arg (ap, long);
+    if (x != 123)
+      abort();
+  }
+  va_end (ap);
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  x[0].d = 20;
+  x[1].d = 21;
+  x[2].d = 22;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-11.c b/gcc/testsuite/gcc.c-torture/execute/931004-11.c
new file mode 100644
index 00000000000..b6047025ce9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-11.c
@@ -0,0 +1,50 @@
+struct tiny
+{
+  char c;
+  char d;
+  char e;
+};
+
+f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
+{
+  if (x.c != 10)
+    abort();
+  if (x.d != 20)
+    abort();
+  if (x.e != 30)
+    abort();
+
+  if (y.c != 11)
+    abort();
+  if (y.d != 21)
+    abort();
+  if (y.e != 31)
+    abort();
+
+  if (z.c != 12)
+    abort();
+  if (z.d != 22)
+    abort();
+  if (z.e != 32)
+    abort();
+
+  if (l != 123)
+    abort ();
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  x[0].d = 20;
+  x[1].d = 21;
+  x[2].d = 22;
+  x[0].e = 30;
+  x[1].e = 31;
+  x[2].e = 32;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-12.c b/gcc/testsuite/gcc.c-torture/execute/931004-12.c
new file mode 100644
index 00000000000..d3fc71e0cb0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-12.c
@@ -0,0 +1,50 @@
+#include <stdarg.h>
+
+struct tiny
+{
+  char c;
+  char d;
+  char e;
+};
+
+f (int n, ...)
+{
+  struct tiny x;
+  int i;
+
+  va_list ap;
+  va_start (ap,n);
+  for (i = 0; i < n; i++)
+    {
+      x = va_arg (ap,struct tiny);
+      if (x.c != i + 10)
+	abort();
+      if (x.d != i + 20)
+	abort();
+      if (x.e != i + 30)
+	abort();
+    }
+  {
+    long x = va_arg (ap, long);
+    if (x != 123)
+      abort();
+  }
+  va_end (ap);
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  x[0].d = 20;
+  x[1].d = 21;
+  x[2].d = 22;
+  x[0].e = 30;
+  x[1].e = 31;
+  x[2].e = 32;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-13.c b/gcc/testsuite/gcc.c-torture/execute/931004-13.c
new file mode 100644
index 00000000000..60422af8eb7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-13.c
@@ -0,0 +1,60 @@
+struct tiny
+{
+  char c;
+  char d;
+  char e;
+  char f;
+};
+
+f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
+{
+  if (x.c != 10)
+    abort();
+  if (x.d != 20)
+    abort();
+  if (x.e != 30)
+    abort();
+  if (x.f != 40)
+    abort();
+
+  if (y.c != 11)
+    abort();
+  if (y.d != 21)
+    abort();
+  if (y.e != 31)
+    abort();
+  if (y.f != 41)
+    abort();
+
+  if (z.c != 12)
+    abort();
+  if (z.d != 22)
+    abort();
+  if (z.e != 32)
+    abort();
+  if (z.f != 42)
+    abort();
+
+  if (l != 123)
+    abort ();
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  x[0].d = 20;
+  x[1].d = 21;
+  x[2].d = 22;
+  x[0].e = 30;
+  x[1].e = 31;
+  x[2].e = 32;
+  x[0].f = 40;
+  x[1].f = 41;
+  x[2].f = 42;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-14.c b/gcc/testsuite/gcc.c-torture/execute/931004-14.c
new file mode 100644
index 00000000000..55c71bbc42a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-14.c
@@ -0,0 +1,56 @@
+#include <stdarg.h>
+
+struct tiny
+{
+  char c;
+  char d;
+  char e;
+  char f;
+};
+
+f (int n, ...)
+{
+  struct tiny x;
+  int i;
+
+  va_list ap;
+  va_start (ap,n);
+  for (i = 0; i < n; i++)
+    {
+      x = va_arg (ap,struct tiny);
+      if (x.c != i + 10)
+	abort();
+      if (x.d != i + 20)
+	abort();
+      if (x.e != i + 30)
+	abort();
+      if (x.f != i + 40)
+	abort();
+    }
+  {
+    long x = va_arg (ap, long);
+    if (x != 123)
+      abort();
+  }
+  va_end (ap);
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  x[0].d = 20;
+  x[1].d = 21;
+  x[2].d = 22;
+  x[0].e = 30;
+  x[1].e = 31;
+  x[2].e = 32;
+  x[0].f = 40;
+  x[1].f = 41;
+  x[2].f = 42;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-2.c b/gcc/testsuite/gcc.c-torture/execute/931004-2.c
new file mode 100644
index 00000000000..83bdea67b0c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-2.c
@@ -0,0 +1,38 @@
+#include <stdarg.h>
+
+struct tiny
+{
+  int c;
+};
+
+f (int n, ...)
+{
+  struct tiny x;
+  int i;
+
+  va_list ap;
+  va_start (ap,n);
+  for (i = 0; i < n; i++)
+    {
+      x = va_arg (ap,struct tiny);
+      if (x.c != i + 10)
+	abort();
+    }
+  {
+    long x = va_arg (ap, long);
+    if (x != 123)
+      abort();
+  }
+  va_end (ap);
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-3.c b/gcc/testsuite/gcc.c-torture/execute/931004-3.c
new file mode 100644
index 00000000000..1e7a0fdcd53
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-3.c
@@ -0,0 +1,30 @@
+struct tiny
+{
+  short c;
+};
+
+f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
+{
+  if (x.c != 10)
+    abort();
+
+  if (y.c != 11)
+    abort();
+
+  if (z.c != 12)
+    abort();
+
+  if (l != 123)
+    abort ();
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-4.c b/gcc/testsuite/gcc.c-torture/execute/931004-4.c
new file mode 100644
index 00000000000..f0d2331e5cc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-4.c
@@ -0,0 +1,38 @@
+#include <stdarg.h>
+
+struct tiny
+{
+  short c;
+};
+
+f (int n, ...)
+{
+  struct tiny x;
+  int i;
+
+  va_list ap;
+  va_start (ap,n);
+  for (i = 0; i < n; i++)
+    {
+      x = va_arg (ap,struct tiny);
+      if (x.c != i + 10)
+	abort();
+    }
+  {
+    long x = va_arg (ap, long);
+    if (x != 123)
+      abort();
+  }
+  va_end (ap);
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-5.c b/gcc/testsuite/gcc.c-torture/execute/931004-5.c
new file mode 100644
index 00000000000..9bef779e6ed
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-5.c
@@ -0,0 +1,40 @@
+struct tiny
+{
+  short c;
+  short d;
+};
+
+f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
+{
+  if (x.c != 10)
+    abort();
+  if (x.d != 20)
+    abort();
+
+  if (y.c != 11)
+    abort();
+  if (y.d != 21)
+    abort();
+
+  if (z.c != 12)
+    abort();
+  if (z.d != 22)
+    abort();
+
+  if (l != 123)
+    abort ();
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  x[0].d = 20;
+  x[1].d = 21;
+  x[2].d = 22;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-6.c b/gcc/testsuite/gcc.c-torture/execute/931004-6.c
new file mode 100644
index 00000000000..6dca48f38ef
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-6.c
@@ -0,0 +1,44 @@
+#include <stdarg.h>
+
+struct tiny
+{
+  short c;
+  short d;
+};
+
+f (int n, ...)
+{
+  struct tiny x;
+  int i;
+
+  va_list ap;
+  va_start (ap,n);
+  for (i = 0; i < n; i++)
+    {
+      x = va_arg (ap,struct tiny);
+      if (x.c != i + 10)
+	abort();
+      if (x.d != i + 20)
+	abort();
+    }
+  {
+    long x = va_arg (ap, long);
+    if (x != 123)
+      abort();
+  }
+  va_end (ap);
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  x[0].d = 20;
+  x[1].d = 21;
+  x[2].d = 22;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-7.c b/gcc/testsuite/gcc.c-torture/execute/931004-7.c
new file mode 100644
index 00000000000..8ab2fcb2ab2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-7.c
@@ -0,0 +1,30 @@
+struct tiny
+{
+  char c;
+};
+
+f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
+{
+  if (x.c != 10)
+    abort();
+
+  if (y.c != 11)
+    abort();
+
+  if (z.c != 12)
+    abort();
+
+  if (l != 123)
+    abort ();
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-8.c b/gcc/testsuite/gcc.c-torture/execute/931004-8.c
new file mode 100644
index 00000000000..5fb97f64a6b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-8.c
@@ -0,0 +1,38 @@
+#include <stdarg.h>
+
+struct tiny
+{
+  char c;
+};
+
+f (int n, ...)
+{
+  struct tiny x;
+  int i;
+
+  va_list ap;
+  va_start (ap,n);
+  for (i = 0; i < n; i++)
+    {
+      x = va_arg (ap,struct tiny);
+      if (x.c != i + 10)
+	abort();
+    }
+  {
+    long x = va_arg (ap, long);
+    if (x != 123)
+      abort();
+  }
+  va_end (ap);
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931004-9.c b/gcc/testsuite/gcc.c-torture/execute/931004-9.c
new file mode 100644
index 00000000000..07247f7adfa
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931004-9.c
@@ -0,0 +1,40 @@
+struct tiny
+{
+  char c;
+  char d;
+};
+
+f (int n, struct tiny x, struct tiny y, struct tiny z, long l)
+{
+  if (x.c != 10)
+    abort();
+  if (x.d != 20)
+    abort();
+
+  if (y.c != 11)
+    abort();
+  if (y.d != 21)
+    abort();
+
+  if (z.c != 12)
+    abort();
+  if (z.d != 22)
+    abort();
+
+  if (l != 123)
+    abort ();
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  x[0].d = 20;
+  x[1].d = 21;
+  x[2].d = 22;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931005-1.c b/gcc/testsuite/gcc.c-torture/execute/931005-1.c
new file mode 100644
index 00000000000..5a7e031cbfe
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931005-1.c
@@ -0,0 +1,23 @@
+typedef struct
+{
+  char x;
+} T;
+
+T
+f (s1)
+     T s1;
+{
+  T s1a;
+  s1a.x = s1.x;
+  return s1a;
+}
+
+main ()
+{
+  T s1a, s1b;
+  s1a.x = 100;
+  s1b = f (s1a);
+  if (s1b.x != 100)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/931009-1.c b/gcc/testsuite/gcc.c-torture/execute/931009-1.c
new file mode 100644
index 00000000000..292228014e7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931009-1.c
@@ -0,0 +1,26 @@
+main ()
+{
+  f ();
+  exit (0);
+}
+
+static
+g (out, size, lo, hi)
+     int *out, size, lo, hi;
+{
+  int j;
+
+  for (j = 0; j < size; j++)
+    out[j] = j * (hi - lo);
+}
+
+
+f ()
+{
+  int a[2];
+
+  g (a, 2, 0, 1);
+
+  if (a[0] != 0 || a[1] != 1)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/931012-1.c b/gcc/testsuite/gcc.c-torture/execute/931012-1.c
new file mode 100644
index 00000000000..d9c958ddb90
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931012-1.c
@@ -0,0 +1,13 @@
+f (int b, int c)
+{
+  if (b != 0 && b != 1 && c != 0)
+    b = 0;
+  return b;
+}
+
+main ()
+{
+  if (!f (1, 2))
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/931017-1.c b/gcc/testsuite/gcc.c-torture/execute/931017-1.c
new file mode 100644
index 00000000000..5917bd95b76
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931017-1.c
@@ -0,0 +1,54 @@
+int v;
+
+main ()
+{
+  f ();
+  exit (0);
+}
+
+h1 ()
+{
+  return 0;
+}
+
+h2 (e)
+     int *e;
+{
+  if (e != &v)
+    abort ();
+  return 0;
+}
+
+g (c)
+     char *c;
+{
+  int i;
+  int b;
+
+  do
+    {
+      i = h1 ();
+      if (i == -1)
+	return 0;
+      else if (i == 1)
+	h1 ();
+    }
+  while (i == 1);
+
+  do
+    b = h2 (&v);
+  while (i == 5);
+
+  if (i != 2)
+    return b;
+  *c = 'a';
+
+  return 0;
+}
+
+
+f ()
+{
+  char c;
+  g (&c);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/931018-1.c b/gcc/testsuite/gcc.c-torture/execute/931018-1.c
new file mode 100644
index 00000000000..d3814e699b8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931018-1.c
@@ -0,0 +1,18 @@
+unsigned int a[0x1000];
+extern unsigned long v;
+
+main ()
+{
+  f (v);
+  f (v);
+  exit (0);
+}
+
+f (a)
+     unsigned long a;
+{
+  if (a != 0xdeadbeefL)
+    abort();
+}
+
+const unsigned long v = 0xdeadbeefL;
diff --git a/gcc/testsuite/gcc.c-torture/execute/931031-1.c b/gcc/testsuite/gcc.c-torture/execute/931031-1.c
new file mode 100644
index 00000000000..761989040f4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931031-1.c
@@ -0,0 +1,24 @@
+struct foo
+{
+  unsigned y:1;
+  unsigned x:32;
+};
+
+int
+f (x)
+     struct foo x;
+{
+  int t = x.x;
+  if (t < 0)
+    return 1;
+  return t+1;
+}
+
+main ()
+{
+  struct foo x;
+  x.x = -1;
+  if (f (x) == 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/931102-1.c b/gcc/testsuite/gcc.c-torture/execute/931102-1.c
new file mode 100644
index 00000000000..489e7ebda8d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931102-1.c
@@ -0,0 +1,30 @@
+typedef union
+{
+  struct
+    {
+      char h, l;
+    } b;
+} T;
+
+f (x)
+     int x;
+{
+  int num = 0;
+  T reg;
+
+  reg.b.l = x;
+  while ((reg.b.l & 1) == 0)
+    {
+      num++;
+      reg.b.l >>= 1;
+    }
+  return num;
+}
+
+main ()
+{
+  if (f (2) != 1)
+    abort ();
+  exit (0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931102-2.c b/gcc/testsuite/gcc.c-torture/execute/931102-2.c
new file mode 100644
index 00000000000..6fc735c8bc1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931102-2.c
@@ -0,0 +1,31 @@
+typedef union
+{
+  long align;
+  struct
+    {
+      short h, l;
+    } b;
+} T;
+
+f (x)
+     int x;
+{
+  int num = 0;
+  T reg;
+
+  reg.b.l = x;
+  while ((reg.b.l & 1) == 0)
+    {
+      num++;
+      reg.b.l >>= 1;
+    }
+  return num;
+}
+
+main ()
+{
+  if (f (2) != 1)
+    abort ();
+  exit (0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/931110-1.c b/gcc/testsuite/gcc.c-torture/execute/931110-1.c
new file mode 100644
index 00000000000..5b33b269a2d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931110-1.c
@@ -0,0 +1,18 @@
+typedef struct
+{
+  short f:3, g:3, h:10;
+} small;
+
+struct
+{
+  int i;
+  small s[10];
+} x;
+
+main ()
+{
+  int i;
+  for (i = 0; i < 10; i++)
+    x.s[i].f = 0;
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/931110-2.c b/gcc/testsuite/gcc.c-torture/execute/931110-2.c
new file mode 100644
index 00000000000..586615b180c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931110-2.c
@@ -0,0 +1,12 @@
+main ()
+{
+  static int a[] = {3, 4};
+  register int *b;
+  int c;
+
+  b = a;
+  c = *b++ % 8;
+  if (c != 3)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/931208-1.c b/gcc/testsuite/gcc.c-torture/execute/931208-1.c
new file mode 100644
index 00000000000..ee2bc9f1e04
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931208-1.c
@@ -0,0 +1,14 @@
+f ()
+{
+  unsigned long x, y = 1;
+
+  x = ((y * 8192) - 216) / 16;
+  return x;
+}
+
+main ()
+{
+  if (f () != 498)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/931228-1.c b/gcc/testsuite/gcc.c-torture/execute/931228-1.c
new file mode 100644
index 00000000000..dcd3b65ff3b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/931228-1.c
@@ -0,0 +1,15 @@
+f (x)
+{
+  x &= 010000;
+  x &= 007777;
+  x ^= 017777;
+  x &= 017770;
+  return x;
+}
+
+main ()
+{
+  if (f (-1) != 017770)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/940115-1.c b/gcc/testsuite/gcc.c-torture/execute/940115-1.c
new file mode 100644
index 00000000000..d0fac9077a1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/940115-1.c
@@ -0,0 +1,13 @@
+f (cp, end)
+     char *cp;
+     char *end;
+{
+  return (cp < end);
+}
+
+main ()
+{
+  if (! f ((char *) 0, (char *) 1))
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/940122-1.c b/gcc/testsuite/gcc.c-torture/execute/940122-1.c
new file mode 100644
index 00000000000..9dbf6ae185b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/940122-1.c
@@ -0,0 +1,21 @@
+char *a = 0;
+char *b = 0;
+
+g (x)
+     int x;
+{
+  if ((!!a) != (!!b))
+    abort ();
+}
+
+f (x)
+     int x;
+{
+  g (x * x);
+}
+
+main ()
+{
+  f (100);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/941014-1.c b/gcc/testsuite/gcc.c-torture/execute/941014-1.c
new file mode 100644
index 00000000000..98db917428f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/941014-1.c
@@ -0,0 +1,15 @@
+int f (int a, int b) { }
+
+main ()
+{
+  unsigned long addr1;
+  unsigned long addr2;
+
+  addr1 = (unsigned long) &f;
+  addr1 += 5;
+  addr2 = 5 + (unsigned long) &f;
+
+  if (addr1 != addr2)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/941014-1.x b/gcc/testsuite/gcc.c-torture/execute/941014-1.x
new file mode 100644
index 00000000000..90775849832
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/941014-1.x
@@ -0,0 +1,6 @@
+# This doesn't work for thumb-elf
+ 
+if { [istarget "thumb-*-elf"] } {
+        set torture_execute_xfail "thumb-*-elf"
+}
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/941014-2.c b/gcc/testsuite/gcc.c-torture/execute/941014-2.c
new file mode 100644
index 00000000000..3932a34ce92
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/941014-2.c
@@ -0,0 +1,33 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+typedef struct {
+  unsigned short a;
+  unsigned short b;
+} foo_t;
+
+void a1 (unsigned long offset) {}
+
+volatile foo_t *
+f ()
+{
+  volatile foo_t *foo_p = (volatile foo_t *)malloc (sizeof (foo_t));
+
+  a1((unsigned long)foo_p-30);
+  if (foo_p->a & 0xf000)
+    printf("%d\n", foo_p->a);
+  foo_p->b = 0x0100;
+  a1 ((unsigned long)foo_p + 2);
+  a1 ((unsigned long)foo_p - 30);
+  return foo_p;
+}
+
+main ()
+{
+  volatile foo_t *foo_p;
+
+  foo_p = f ();
+  if (foo_p->b != 0x0100)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/941015-1.c b/gcc/testsuite/gcc.c-torture/execute/941015-1.c
new file mode 100644
index 00000000000..38d4796645f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/941015-1.c
@@ -0,0 +1,35 @@
+int
+foo1 (value)
+     long long value;
+{
+  register const long long constant = 0xc000000080000000LL;
+
+  if (value < constant)
+    return 1;
+  else
+    return 2;
+}
+
+int
+foo2 (value)
+     unsigned long long value;
+{
+  register const unsigned long long constant = 0xc000000080000000LL;
+
+  if (value < constant)
+    return 1;
+  else
+    return 2;
+}
+
+main ()
+{
+  unsigned long long value = 0xc000000000000001LL;
+  int x, y;
+
+  x = foo1 (value);
+  y = foo2 (value);
+  if (x != y || x != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/941021-1.c b/gcc/testsuite/gcc.c-torture/execute/941021-1.c
new file mode 100644
index 00000000000..9fc1cfadf97
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/941021-1.c
@@ -0,0 +1,20 @@
+double glob_dbl;
+
+f (pdbl, value)
+     double *pdbl;
+     double value;
+{
+  if (pdbl == 0)
+    pdbl = &glob_dbl;
+
+  *pdbl = value;
+}
+
+main ()
+{
+  f ((void *) 0, 55.1);
+
+  if (glob_dbl != 55.1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/941025-1.c b/gcc/testsuite/gcc.c-torture/execute/941025-1.c
new file mode 100644
index 00000000000..2daf0ad25cc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/941025-1.c
@@ -0,0 +1,12 @@
+long f (x, y)
+     long x,y;
+{
+  return (x > 1) ? y : (y & 1);
+}
+
+main ()
+{
+  if (f (2L, 0xdecadeL) != 0xdecadeL)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/941031-1.c b/gcc/testsuite/gcc.c-torture/execute/941031-1.c
new file mode 100644
index 00000000000..134f966c6f3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/941031-1.c
@@ -0,0 +1,27 @@
+typedef long mpt;
+
+int
+f (mpt us, mpt vs)
+{
+  long aus;
+  long avs;
+
+  aus = us >= 0 ? us : -us;
+  avs = vs >= 0 ? vs : -vs;
+
+  if (aus < avs)
+    {
+      long t = aus;
+      aus = avs;
+      avs = aus;
+    }
+
+  return avs;
+}
+
+main ()
+{
+  if (f ((mpt) 3, (mpt) 17) != 17)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/941101-1.c b/gcc/testsuite/gcc.c-torture/execute/941101-1.c
new file mode 100644
index 00000000000..66b5f384a80
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/941101-1.c
@@ -0,0 +1,15 @@
+f ()
+{
+  int var = 7;
+
+  if ((var/7) == 1)
+    return var/7;
+  return 0;
+}
+
+main ()
+{
+  if (f () != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/941110-1.c b/gcc/testsuite/gcc.c-torture/execute/941110-1.c
new file mode 100644
index 00000000000..b78256d3c3f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/941110-1.c
@@ -0,0 +1,16 @@
+f (const int x)
+{
+  int y = 0;
+  y = x ? y : -y;
+  {
+    const int *p = &x;
+  }
+  return y;
+}
+
+main ()
+{
+  if (f (0))
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/941202-1.c b/gcc/testsuite/gcc.c-torture/execute/941202-1.c
new file mode 100644
index 00000000000..72d0b33e924
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/941202-1.c
@@ -0,0 +1,21 @@
+g (x, y)
+{
+  if (x != 3)
+    abort ();
+}
+
+static inline
+f (int i)
+{
+  int *tmp;
+
+  tmp = (int *) alloca (sizeof (i));
+  *tmp = i;
+  g (*tmp, 0);
+}
+
+main ()
+{
+  f (3);
+  exit (0);
+};
diff --git a/gcc/testsuite/gcc.c-torture/execute/950221-1.c b/gcc/testsuite/gcc.c-torture/execute/950221-1.c
new file mode 100644
index 00000000000..d67da5b0c8c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950221-1.c
@@ -0,0 +1,55 @@
+struct parsefile
+{
+  long fd;
+  char *buf;
+};
+struct parsefile basepf;
+struct parsefile *parsefile = &basepf;
+#ifdef STACK_SIZE
+int filler[STACK_SIZE / (2*sizeof(int))];
+#else
+int filler[0x3000];
+#endif
+int el;
+
+char *
+g1 (a, b)
+     int a;
+     int *b;
+{
+}
+
+g2 (a)
+     long a;
+{
+  if (a != 0xdeadbeefL)
+    abort ();
+  exit (0);
+}
+
+f ()
+{
+  register char *p, *q;
+  register int i;
+  register int something;
+
+  if (parsefile->fd == 0L && el)
+    {
+      const char *rl_cp;
+      int len;
+      rl_cp = g1 (el, &len);
+      strcpy (p, rl_cp);
+    }
+  else
+    {
+    alabel:
+      i = g2 (parsefile->fd);
+    }
+}
+
+main ()
+{
+  el = 0;
+  parsefile->fd = 0xdeadbeefL;
+  f ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950322-1.c b/gcc/testsuite/gcc.c-torture/execute/950322-1.c
new file mode 100644
index 00000000000..28a1469fea0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950322-1.c
@@ -0,0 +1,30 @@
+f (unsigned char *a)
+{
+  int i, j;
+  int x, y;
+
+  j = a[1];
+  i = a[0] - j;
+  if (i < 0)
+    {
+      x = 1;
+      y = -i;
+    }
+  else
+    {
+      x = 0;
+      y =  i;
+    }
+  return x + y;
+}
+
+
+main ()
+{
+  unsigned char a[2];
+  a[0] = 8;
+  a[1] = 9;
+  if (f (a) != 2)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950426-1.c b/gcc/testsuite/gcc.c-torture/execute/950426-1.c
new file mode 100644
index 00000000000..076032c7220
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950426-1.c
@@ -0,0 +1,32 @@
+
+struct tag {
+  int m1;
+  char *m2[5];
+} s1, *p1;
+
+int i;
+
+main()
+{
+  s1.m1 = -1;
+  p1 = &s1;
+
+  if ( func1( &p1->m1 ) == -1 )
+    foo ("ok");
+  else
+    abort ();
+
+  i = 3;
+  s1.m2[3]= "123";
+
+  if ( strlen( (p1->m2[i])++ ) == 3 )
+    foo ("ok");
+  else
+    abort ();
+
+  exit (0);
+}
+
+func1(int *p) { return(*p); }
+
+foo (char *s) {}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950426-2.c b/gcc/testsuite/gcc.c-torture/execute/950426-2.c
new file mode 100644
index 00000000000..a1a690469d1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950426-2.c
@@ -0,0 +1,13 @@
+main()
+{
+  long int i = -2147483647L - 1L; /* 0x80000000 */
+  char ca = 1;
+
+  if (i >> ca != -1073741824L)
+    abort ();
+
+  if (i >> i / -2000000000L != -1073741824L)
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950503-1.c b/gcc/testsuite/gcc.c-torture/execute/950503-1.c
new file mode 100644
index 00000000000..1c95b369c50
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950503-1.c
@@ -0,0 +1,15 @@
+main ()
+{
+  int tmp;
+  unsigned long long utmp1, utmp2;
+
+  tmp = 16;
+
+  utmp1 = (~((unsigned long long) 0)) >> tmp;
+  utmp2 = (~((unsigned long long) 0)) >> 16;
+
+  if (utmp1 != utmp2)
+    abort ();
+  exit (0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/950511-1.c b/gcc/testsuite/gcc.c-torture/execute/950511-1.c
new file mode 100644
index 00000000000..6584b0c86b6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950511-1.c
@@ -0,0 +1,11 @@
+main ()
+{
+  unsigned long long xx;
+  unsigned long long *x = (unsigned long long *) &xx;
+
+  *x = -3;
+  *x = *x * *x;
+  if (*x != 9)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950512-1.c b/gcc/testsuite/gcc.c-torture/execute/950512-1.c
new file mode 100644
index 00000000000..8aa116d27ca
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950512-1.c
@@ -0,0 +1,24 @@
+unsigned
+f1 (x)
+{
+  return ((unsigned) (x != 0) - 3) / 2;
+}
+
+unsigned long long
+f2 (x)
+{
+  return ((unsigned long long) (x != 0) - 3) / 2;
+}
+
+main ()
+{
+  if (f1 (1) != (~(unsigned) 0) >> 1)
+    abort ();
+  if (f1 (0) != ((~(unsigned) 0) >> 1) - 1)
+    abort ();
+  if (f2 (1) != (~(unsigned long long) 0) >> 1)
+    abort ();
+  if (f2 (0) != ((~(unsigned long long) 0) >> 1) - 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950605-1.c b/gcc/testsuite/gcc.c-torture/execute/950605-1.c
new file mode 100644
index 00000000000..d89a42e49c6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950605-1.c
@@ -0,0 +1,12 @@
+f (c)
+    unsigned char c;
+{
+  if (c != 0xFF)
+    abort ();
+}
+
+main ()
+{
+  f (-1);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950607-1.c b/gcc/testsuite/gcc.c-torture/execute/950607-1.c
new file mode 100644
index 00000000000..7b1503ad11d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950607-1.c
@@ -0,0 +1,9 @@
+main ()
+{
+  struct { long status; } h;
+
+  h.status = 0;
+  if (((h.status & 128) == 1) && ((h.status & 32) == 0))
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950607-2.c b/gcc/testsuite/gcc.c-torture/execute/950607-2.c
new file mode 100644
index 00000000000..da18f7373f4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950607-2.c
@@ -0,0 +1,41 @@
+typedef struct {
+  long int p_x, p_y;
+} Point;
+
+int
+f (Point basePt, Point pt1, Point pt2)
+{
+  long long vector;
+
+  vector =
+    (long long) (pt1.p_x - basePt.p_x) * (long long) (pt2.p_y - basePt.p_y) -
+      (long long) (pt1.p_y - basePt.p_y) * (long long) (pt2.p_x - basePt.p_x);
+
+  if (vector > (long long) 0)
+    return 0;
+  else if (vector < (long long) 0)
+    return 1;
+  else
+    return 2;
+}
+
+main ()
+{
+  Point b, p1, p2;
+  int answer;
+
+  b.p_x = -23250;
+  b.p_y = 23250;
+
+  p1.p_x = 23250;
+  p1.p_y = -23250;
+
+  p2.p_x = -23250;
+  p2.p_y = -23250;
+
+  answer = f (b, p1, p2);
+
+  if (answer != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950612-1.c b/gcc/testsuite/gcc.c-torture/execute/950612-1.c
new file mode 100644
index 00000000000..f9885279c33
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950612-1.c
@@ -0,0 +1,48 @@
+unsigned int
+f1 (int diff)
+{
+  return ((unsigned int) (diff < 0 ? -diff : diff));
+}
+
+unsigned int
+f2 (unsigned int diff)
+{
+  return ((unsigned int) ((signed int) diff < 0 ? -diff : diff));
+}
+
+unsigned long long
+f3 (long long diff)
+{
+  return ((unsigned long long) (diff < 0 ? -diff : diff));
+}
+
+unsigned long long
+f4 (unsigned long long diff)
+{
+  return ((unsigned long long) ((signed long long) diff < 0 ? -diff : diff));
+}
+
+main ()
+{
+  int i;
+  for (i = 0; i <= 10; i++)
+    {
+      if (f1 (i) != i)
+	abort ();
+      if (f1 (-i) != i)
+	abort ();
+      if (f2 (i) != i)
+	abort ();
+      if (f2 (-i) != i)
+	abort ();
+      if (f3 ((long long) i) != i)
+	abort ();
+      if (f3 ((long long) -i) != i)
+	abort ();
+      if (f4 ((long long) i) != i)
+	abort ();
+      if (f4 ((long long) -i) != i)
+	abort ();
+    }
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950621-1.c b/gcc/testsuite/gcc.c-torture/execute/950621-1.c
new file mode 100644
index 00000000000..5fc5a902874
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950621-1.c
@@ -0,0 +1,20 @@
+struct s
+{
+  int a;
+  int b;
+  struct s *dummy;
+};
+
+f (struct s *sp)
+{
+  return sp && sp->a == -1 && sp->b == -1;
+}
+
+main ()
+{
+  struct s x;
+  x.a = x.b = -1;
+  if (f (&x) == 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950628-1.c b/gcc/testsuite/gcc.c-torture/execute/950628-1.c
new file mode 100644
index 00000000000..e330ff56971
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950628-1.c
@@ -0,0 +1,31 @@
+typedef struct
+{
+  char hours, day, month;
+  short year;
+} T;
+
+T g (void)
+{
+  T now;
+
+  now.hours = 1;
+  now.day = 2;
+  now.month = 3;
+  now.year = 4;
+  return now;
+}
+
+T f (void)
+{
+  T virk;
+
+  virk = g ();
+  return virk;
+}
+
+main ()
+{
+  if (f ().hours != 1 || f ().day != 2 || f ().month != 3 || f ().year != 4)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950704-1.c b/gcc/testsuite/gcc.c-torture/execute/950704-1.c
new file mode 100644
index 00000000000..f11aff8cabc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950704-1.c
@@ -0,0 +1,59 @@
+int errflag;
+
+long long
+f (long long x, long long y)
+{
+  long long r;
+
+  errflag = 0;
+  r = x + y;
+  if (x >= 0)
+    {
+      if ((y < 0) || (r >= 0))
+	return r;
+    }
+  else
+    {
+      if ((y > 0) || (r < 0))
+	return r;
+    }
+  errflag = 1;
+  return 0;
+}
+
+main ()
+{
+  f (0, 0);
+  if (errflag)
+    abort ();
+
+  f (1, -1);
+  if (errflag)
+    abort ();
+
+  f (-1, 1);
+  if (errflag)
+    abort ();
+
+  f (0x8000000000000000LL, 0x8000000000000000LL);
+  if (!errflag)
+    abort ();
+
+  f (0x8000000000000000LL, -1LL);
+  if (!errflag)
+    abort ();
+
+  f (0x7fffffffffffffffLL, 0x7fffffffffffffffLL);
+  if (!errflag)
+    abort ();
+
+  f (0x7fffffffffffffffLL, 1LL);
+  if (!errflag)
+    abort ();
+
+  f (0x7fffffffffffffffLL, 0x8000000000000000LL);
+  if (errflag)
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950706-1.c b/gcc/testsuite/gcc.c-torture/execute/950706-1.c
new file mode 100644
index 00000000000..2db1915411c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950706-1.c
@@ -0,0 +1,16 @@
+int
+f (int n)
+{
+  return (n > 0) - (n < 0);
+}
+
+main ()
+{
+  if (f (-1) != -1)
+    abort ();
+  if (f (1) != 1)
+    abort ();
+  if (f (0) != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950710-1.c b/gcc/testsuite/gcc.c-torture/execute/950710-1.c
new file mode 100644
index 00000000000..26ff9b2a8a0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950710-1.c
@@ -0,0 +1,54 @@
+struct twelve
+{
+  int a;
+  int b;
+  int c;
+};
+
+struct pair
+{
+  int first;
+  int second;
+};
+
+struct pair
+g ()
+{
+  struct pair p;
+  return p;
+}
+
+static void
+f ()
+{
+  int i;
+  for (i = 0; i < 1; i++)
+    {
+      int j;
+      for (j = 0; j < 1; j++)
+	{
+	  if (0)
+	    {
+	      int k;
+	      for (k = 0; k < 1; k++)
+		{
+		  struct pair e = g ();
+		}
+	    }
+	  else
+	    {
+	      struct twelve a, b;
+	      if ((((char *) &b - (char *) &a) < 0
+		   ? (-((char *) &b - (char *) &a))
+		   : ((char *) &b - (char *) &a))  < sizeof (a))
+		abort ();
+	    }
+	}
+    }
+}
+
+main ()
+{
+  f ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950714-1.c b/gcc/testsuite/gcc.c-torture/execute/950714-1.c
new file mode 100644
index 00000000000..5dc44a906e2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950714-1.c
@@ -0,0 +1,17 @@
+int array[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+
+main ()
+{
+  int i, j;
+  int *p;
+
+  for (i = 0; i < 10; i++)
+    for (p = &array[0]; p != &array[9]; p++)
+      if (*p == i)
+	goto label;
+
+ label:
+  if (i != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950809-1.c b/gcc/testsuite/gcc.c-torture/execute/950809-1.c
new file mode 100644
index 00000000000..a33d42bd7cd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950809-1.c
@@ -0,0 +1,33 @@
+struct S
+{
+  int *sp, fc, *sc, a[2];
+};
+
+f (struct S *x)
+{
+  int *t = x->sc;
+  int t1 = t[0];
+  int t2 = t[1];
+  int t3 = t[2];
+  int a0 = x->a[0];
+  int a1 = x->a[1];
+  t[2] = t1;
+  t[0] = a1;
+  x->a[1] = a0;
+  x->a[0] = t3;
+  x->fc = t2;
+  x->sp = t;
+}
+
+main ()
+{
+  struct S s;
+  static int sc[3] = {2, 3, 4};
+  s.sc = sc;
+  s.a[0] = 10;
+  s.a[1] = 11;
+  f (&s);
+  if (s.sp[2] != 2)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950906-1.c b/gcc/testsuite/gcc.c-torture/execute/950906-1.c
new file mode 100644
index 00000000000..31997d5c257
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950906-1.c
@@ -0,0 +1,16 @@
+g (int i)
+{
+}
+
+f (int i)
+{
+  g (0);
+  while ( ({ i--; }) )
+    g (0);
+}
+
+main ()
+{
+  f (10);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950915-1.c b/gcc/testsuite/gcc.c-torture/execute/950915-1.c
new file mode 100644
index 00000000000..cfa044757b8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950915-1.c
@@ -0,0 +1,15 @@
+long int a = 100000;
+long int b = 21475;
+
+long
+f ()
+{
+  return ((long long) a * (long long) b) >> 16;
+}
+
+main ()
+{
+  if (f () < 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/950929-1.c b/gcc/testsuite/gcc.c-torture/execute/950929-1.c
new file mode 100644
index 00000000000..a35cd6a153e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/950929-1.c
@@ -0,0 +1,21 @@
+int f (char *p) { }
+
+main ()
+{
+  char c;
+  char c2;
+  int i = 0;
+  char *pc = &c;
+  char *pc2 = &c2;
+  int *pi = &i;
+
+  *pc2 = 1;
+  *pi = 1;
+  *pc2 &= *pi;
+  f (pc2);
+  *pc2 = 1;
+  *pc2 &= *pi;
+  if (*pc2 != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/951003-1.c b/gcc/testsuite/gcc.c-torture/execute/951003-1.c
new file mode 100644
index 00000000000..269bf135386
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/951003-1.c
@@ -0,0 +1,21 @@
+int f (i) { return 12; }
+int g () { return 0; }
+
+main ()
+{
+  int i, s;
+
+  for (i = 0; i < 32; i++)
+    {
+      s = f (i);
+
+      if (i == g ())
+	s = 42;
+      if (i == 0 || s == 12)
+	;
+      else
+	abort ();
+    }
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/951115-1.c b/gcc/testsuite/gcc.c-torture/execute/951115-1.c
new file mode 100644
index 00000000000..03520c99ca2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/951115-1.c
@@ -0,0 +1,24 @@
+int var = 0;
+
+g ()
+{
+  var = 1;
+}
+
+f ()
+{
+  int f2 = 0;
+
+  if (f2 == 0)
+    ;
+
+  g ();
+}
+
+main ()
+{
+  f ();
+  if (var != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/951204-1.c b/gcc/testsuite/gcc.c-torture/execute/951204-1.c
new file mode 100644
index 00000000000..c4d585b6b9e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/951204-1.c
@@ -0,0 +1,18 @@
+f (char *x)
+{
+  *x = 'x';
+}
+
+main ()
+{
+  int i;
+  char x = '\0';
+
+  for (i = 0; i < 100; ++i)
+    {
+      f (&x);
+      if (*(const char *) &x != 'x')
+	abort ();
+    }
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960116-1.c b/gcc/testsuite/gcc.c-torture/execute/960116-1.c
new file mode 100644
index 00000000000..6d7624ca1a1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960116-1.c
@@ -0,0 +1,20 @@
+static inline
+p (int *p)
+{
+  return !((long) p & 1);
+}
+
+int
+f (int *q)
+{
+  if (p (q) && *q)
+    return 1;
+  return 0;
+}
+
+main ()
+{
+  if (f ((int*) 0xffffffff) != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960117-1.c b/gcc/testsuite/gcc.c-torture/execute/960117-1.c
new file mode 100644
index 00000000000..741455b08b9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960117-1.c
@@ -0,0 +1,46 @@
+static char id_space[2] [32 +1];
+typedef short COUNT;
+
+typedef char TEXT;
+
+union T_VALS
+{
+  TEXT   *id __attribute__ ((aligned (2), packed)) ;
+};
+typedef union T_VALS VALS;
+
+struct T_VAL
+{
+  COUNT    pos __attribute__ ((aligned (2), packed)) ;
+  VALS    vals __attribute__ ((aligned (2), packed)) ;
+};
+typedef struct T_VAL VAL;
+
+VAL curval = {0};
+
+static short idc = 0;
+static int cur_line;
+static int char_pos;
+
+typedef unsigned short WORD;
+
+WORD
+get_id (char c)
+{
+  curval.vals.id[0] = c;
+}
+
+WORD
+get_tok ()
+{
+  char c = 'c';
+  curval.vals.id = id_space[idc];
+  curval.pos = (cur_line << 10) | char_pos;
+  return get_id (c);
+}
+
+main ()
+{
+  get_tok ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960209-1.c b/gcc/testsuite/gcc.c-torture/execute/960209-1.c
new file mode 100644
index 00000000000..decd2af2aab
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960209-1.c
@@ -0,0 +1,43 @@
+struct a_struct
+{
+  unsigned char a_character;
+};
+
+struct a_struct an_array[5];
+struct a_struct *a_ptr;
+int yabba = 1;
+
+int
+f (a, b)
+     unsigned char a;
+     unsigned long b;
+{
+  long i, j, p, q, r, s;
+
+  if (b != (unsigned long) 0)
+    {
+      if (yabba)
+	return -1;
+      s = 4000000 / b;
+      for (i = 0; i < 11; i++)
+	{
+	  for (j = 0; j < 256; j++)
+	    {
+	      if (((p - s < 0) ? -s : 0) < (( q - s < 0) ? -s : q))
+		r = i;
+	    }
+	}
+    }
+
+  if (yabba)
+    return 0;
+  a_ptr = &an_array[a];
+  a_ptr->a_character = (unsigned char) r;
+}
+
+main ()
+{
+  if (f (1, 0UL) != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960215-1.c b/gcc/testsuite/gcc.c-torture/execute/960215-1.c
new file mode 100644
index 00000000000..9502b4b2de4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960215-1.c
@@ -0,0 +1,25 @@
+long double C = 2;
+long double U = 1;
+long double Y2 = 3;
+long double Y1 = 1;
+long double X, Y, Z, T, R, S;
+main ()
+{
+  X = (C + U) * Y2;
+  Y = C - U - U;
+  Z = C + U + U;
+  T = (C - U) * Y1;
+  X = X - (Z + U);
+  R = Y * Y1;
+  S = Z * Y2;
+  T = T - Y;
+  Y = (U - Y) + R;
+  Z = S - (Z + U + U);
+  R = (Y2 + U) * Y1;
+  Y1 = Y2 * Y1;
+  R = R - Y2;
+  Y1 = Y1 - 0.5L;
+  if (Z != 6)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960218-1.c b/gcc/testsuite/gcc.c-torture/execute/960218-1.c
new file mode 100644
index 00000000000..7301a17b00d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960218-1.c
@@ -0,0 +1,22 @@
+int glob;
+
+g (x)
+{
+  glob = x;
+  return 0;
+}
+
+f (x)
+{
+  int a = ~x;
+  while (a)
+    a = g (a);
+}
+
+main ()
+{
+  f (3);
+  if (glob != -4)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960219-1.c b/gcc/testsuite/gcc.c-torture/execute/960219-1.c
new file mode 100644
index 00000000000..d21bcfcad24
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960219-1.c
@@ -0,0 +1,11 @@
+f (int i)
+{
+  if (((1 << i) & 1) == 0)
+    abort ();
+}
+
+main ()
+{
+  f (0);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960301-1.c b/gcc/testsuite/gcc.c-torture/execute/960301-1.c
new file mode 100644
index 00000000000..d75efea9844
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960301-1.c
@@ -0,0 +1,22 @@
+struct foo {
+  unsigned : 12;
+  unsigned field : 4;
+} foo;
+unsigned oldfoo;
+
+int
+bar (unsigned k)
+{
+  oldfoo = foo.field;
+  foo.field = k;
+  if (k)
+    return 1;
+  return 2;
+}
+
+main ()
+{
+  if (bar (1U) != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960302-1.c b/gcc/testsuite/gcc.c-torture/execute/960302-1.c
new file mode 100644
index 00000000000..7a9426a4635
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960302-1.c
@@ -0,0 +1,21 @@
+long a = 1;
+
+foo ()
+{
+  switch (a % 2 % 2 % 2 % 2 % 2 % 2 % 2 % 2)
+    {
+    case 0:
+      return 0;
+    case 1:
+      return 1;
+    default:
+      return -1;
+    }
+}
+
+main ()
+{
+  if (foo () != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960311-1.c b/gcc/testsuite/gcc.c-torture/execute/960311-1.c
new file mode 100644
index 00000000000..16579d0bbd1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960311-1.c
@@ -0,0 +1,69 @@
+#include <stdio.h>
+
+#ifdef DEBUG
+#define abort() printf ("error, line %d\n", __LINE__)
+#endif
+
+int count;
+
+void a1() { ++count; }
+
+void
+b (unsigned char data)
+{
+  if (data & 0x80) a1();
+  data <<= 1;
+
+  if (data & 0x80) a1();
+  data <<= 1;
+
+  if (data & 0x80) a1();
+}
+
+main ()
+{
+  count = 0;
+  b (0);
+  if (count != 0)
+    abort ();
+
+  count = 0;
+  b (0x80);
+  if (count != 1)
+    abort ();
+
+  count = 0;
+  b (0x40);
+  if (count != 1)
+    abort ();
+
+  count = 0;
+  b (0x20);
+  if (count != 1)
+    abort ();
+
+  count = 0;
+  b (0xc0);
+  if (count != 2)
+    abort ();
+
+  count = 0;
+  b (0xa0);
+  if (count != 2)
+    abort ();
+
+  count = 0;
+  b (0x60);
+  if (count != 2)
+    abort ();
+
+  count = 0;
+  b (0xe0);
+  if (count != 3)
+    abort ();
+
+#ifdef DEBUG
+  printf ("Done.\n");
+#endif
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960311-2.c b/gcc/testsuite/gcc.c-torture/execute/960311-2.c
new file mode 100644
index 00000000000..d5c2d07a336
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960311-2.c
@@ -0,0 +1,69 @@
+#include <stdio.h>
+
+#ifdef DEBUG
+#define abort() printf ("error, line %d\n", __LINE__)
+#endif
+
+int count;
+
+void a1() { ++count; }
+
+void
+b (unsigned short data)
+{
+  if (data & 0x8000) a1();
+  data <<= 1;
+
+  if (data & 0x8000) a1();
+  data <<= 1;
+
+  if (data & 0x8000) a1();
+}
+
+main ()
+{
+  count = 0;
+  b (0);
+  if (count != 0)
+    abort ();
+
+  count = 0;
+  b (0x8000);
+  if (count != 1)
+    abort ();
+
+  count = 0;
+  b (0x4000);
+  if (count != 1)
+    abort ();
+
+  count = 0;
+  b (0x2000);
+  if (count != 1)
+    abort ();
+
+  count = 0;
+  b (0xc000);
+  if (count != 2)
+    abort ();
+
+  count = 0;
+  b (0xa000);
+  if (count != 2)
+    abort ();
+
+  count = 0;
+  b (0x6000);
+  if (count != 2)
+    abort ();
+
+  count = 0;
+  b (0xe000);
+  if (count != 3)
+    abort ();
+
+#ifdef DEBUG
+  printf ("Done.\n");
+#endif
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960311-3.c b/gcc/testsuite/gcc.c-torture/execute/960311-3.c
new file mode 100644
index 00000000000..755fc723f85
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960311-3.c
@@ -0,0 +1,69 @@
+#include <stdio.h>
+
+#ifdef DEBUG
+#define abort() printf ("error, line %d\n", __LINE__)
+#endif
+
+int count;
+
+void a1() { ++count; }
+
+void
+b (unsigned long data)
+{
+  if (data & 0x80000000) a1();
+  data <<= 1;
+
+  if (data & 0x80000000) a1();
+  data <<= 1;
+
+  if (data & 0x80000000) a1();
+}
+
+main ()
+{
+  count = 0;
+  b (0);
+  if (count != 0)
+    abort ();
+
+  count = 0;
+  b (0x80000000);
+  if (count != 1)
+    abort ();
+
+  count = 0;
+  b (0x40000000);
+  if (count != 1)
+    abort ();
+
+  count = 0;
+  b (0x20000000);
+  if (count != 1)
+    abort ();
+
+  count = 0;
+  b (0xc0000000);
+  if (count != 2)
+    abort ();
+
+  count = 0;
+  b (0xa0000000);
+  if (count != 2)
+    abort ();
+
+  count = 0;
+  b (0x60000000);
+  if (count != 2)
+    abort ();
+
+  count = 0;
+  b (0xe0000000);
+  if (count != 3)
+    abort ();
+
+#ifdef DEBUG
+  printf ("Done.\n");
+#endif
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960312-1.c b/gcc/testsuite/gcc.c-torture/execute/960312-1.c
new file mode 100644
index 00000000000..94e67df23bd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960312-1.c
@@ -0,0 +1,34 @@
+struct S
+{
+  int *sp, fc, *sc, a[2];
+};
+
+f (struct S *x)
+{
+  int *t = x->sc;
+  int t1 = t[0];
+  int t2 = t[1];
+  int t3 = t[2];
+  int a0 = x->a[0];
+  int a1 = x->a[1];
+  asm("": :"r" (t2), "r" (t3));
+  t[2] = t1;
+  t[0] = a1;
+  x->a[1] = a0;
+  x->a[0] = t3;
+  x->fc = t2;
+  x->sp = t;
+}
+
+main ()
+{
+  struct S s;
+  static int sc[3] = {2, 3, 4};
+  s.sc = sc;
+  s.a[0] = 10;
+  s.a[1] = 11;
+  f (&s);
+  if (s.sp[2] != 2)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960317-1.c b/gcc/testsuite/gcc.c-torture/execute/960317-1.c
new file mode 100644
index 00000000000..8d7907d751c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960317-1.c
@@ -0,0 +1,22 @@
+int
+f (unsigned bitcount, int mant)
+{
+  int mask = -1 << bitcount;
+  {
+    if (! (mant & -mask))
+      goto ab;
+    if (mant & ~mask)
+      goto auf;
+  }
+ab:
+  return 0;
+auf:
+  return 1;
+}
+
+main ()
+{
+  if (f (0, -1))
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960321-1.c b/gcc/testsuite/gcc.c-torture/execute/960321-1.c
new file mode 100644
index 00000000000..eafe48ff753
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960321-1.c
@@ -0,0 +1,14 @@
+char a[10] = "deadbeef";
+
+char
+acc_a (long i)
+{
+  return a[i-2000000000L];
+}
+
+main ()
+{
+  if (acc_a (2000000000L) != 'd')
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960326-1.c b/gcc/testsuite/gcc.c-torture/execute/960326-1.c
new file mode 100644
index 00000000000..f2013737022
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960326-1.c
@@ -0,0 +1,16 @@
+struct s
+{
+  int a;
+  int b;
+  short c;
+  int d[3];
+};
+
+struct s s = { .b = 3, .d = {2,0,0} };
+
+main ()
+{
+  if (s.b != 3)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960327-1.c b/gcc/testsuite/gcc.c-torture/execute/960327-1.c
new file mode 100644
index 00000000000..d630a7b572c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960327-1.c
@@ -0,0 +1,30 @@
+#include <stdio.h>
+g ()
+{
+  return '\n';
+}
+
+f ()
+{
+  char s[] = "abcedfg01234";
+  char *sp = s + 12;
+
+  switch (g ())
+    {
+      case '\n':
+        break;
+    }
+
+  while (*--sp == '0')
+    ;
+  sprintf (sp + 1, "X");
+
+  if (s[12] != 'X')
+    abort ();
+}
+
+main ()
+{
+  f ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960402-1.c b/gcc/testsuite/gcc.c-torture/execute/960402-1.c
new file mode 100644
index 00000000000..601a9a3b091
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960402-1.c
@@ -0,0 +1,11 @@
+f (signed long long int x)
+{
+  return x > 0xFFFFFFFFLL || x < -0x80000000LL;
+}
+
+main ()
+{
+  if (f (0) != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960405-1.c b/gcc/testsuite/gcc.c-torture/execute/960405-1.c
new file mode 100644
index 00000000000..d8480cc2c05
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960405-1.c
@@ -0,0 +1,13 @@
+#define X  5.9486574767861588254287966331400356538172e4931L
+
+long double x = X + X;
+long double y = 2.0L * X;
+
+main ()
+{
+#if ! defined (__vax__) && ! defined (_CRAY)
+  if (x != y)
+    abort ();
+#endif
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960416-1.c b/gcc/testsuite/gcc.c-torture/execute/960416-1.c
new file mode 100644
index 00000000000..f7cb056802c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960416-1.c
@@ -0,0 +1,63 @@
+typedef unsigned long int st;
+typedef unsigned long long dt;
+typedef union
+{
+  dt d;
+  struct
+  {
+    st h, l;
+  }
+  s;
+} t_be;
+
+typedef union
+{
+  dt d;
+  struct
+  {
+    st l, h;
+  }
+  s;
+} t_le;
+
+#define df(f, t) \
+int \
+f (t afh, t bfh) \
+{ \
+  t hh; \
+  t hp, lp, dp, m; \
+  st ad, bd; \
+  int s; \
+  s = 0; \
+  ad = afh.s.h - afh.s.l; \
+  bd = bfh.s.l - bfh.s.h; \
+  if (bd > bfh.s.l) \
+    { \
+      bd = -bd; \
+      s = ~s; \
+    } \
+  lp.d = (dt) afh.s.l * bfh.s.l; \
+  hp.d = (dt) afh.s.h * bfh.s.h; \
+  dp.d = (dt) ad *bd; \
+  dp.d ^= s; \
+  hh.d = hp.d + hp.s.h + lp.s.h + dp.s.h; \
+  m.d = (dt) lp.s.h + hp.s.l + lp.s.l + dp.s.l; \
+  return hh.s.l + m.s.l; \
+}
+
+df(f_le, t_le)
+df(f_be, t_be)
+
+main ()
+{
+  t_be x;
+  x.s.h = 0x10000000U;
+  x.s.l = 0xe0000000U;
+  if (x.d == 0x10000000e0000000ULL
+      && f_be ((t_be) 0x100000000ULL, (t_be) 0x100000000ULL) != -1)
+    abort ();
+  if (x.d == 0xe000000010000000ULL
+      && f_le ((t_le) 0x100000000ULL, (t_le) 0x100000000ULL) != -1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960419-1.c b/gcc/testsuite/gcc.c-torture/execute/960419-1.c
new file mode 100644
index 00000000000..68bd2b97dd1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960419-1.c
@@ -0,0 +1,17 @@
+static int i;
+
+void
+check(x)
+     int x;
+{
+  if (!x)
+    abort();
+}
+
+main()
+{
+  int *p = &i;
+
+  check(p != (void *)0);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960419-2.c b/gcc/testsuite/gcc.c-torture/execute/960419-2.c
new file mode 100644
index 00000000000..c9526dcd779
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960419-2.c
@@ -0,0 +1,13 @@
+#define SIZE 8
+
+main()
+{
+  int a[SIZE] = {1};
+  int i;
+
+  for (i = 1; i < SIZE; i++)
+    if (a[i] != 0)
+      abort();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960512-1.c b/gcc/testsuite/gcc.c-torture/execute/960512-1.c
new file mode 100644
index 00000000000..a7c1d5fb47c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960512-1.c
@@ -0,0 +1,19 @@
+__complex__
+double f ()
+{
+  int a[40];
+  __complex__ double c;
+
+  a[9] = 0;
+  c = a[9];
+  return c;
+}
+
+main ()
+{
+  __complex__ double c;
+
+  if (c = f ())
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960513-1.c b/gcc/testsuite/gcc.c-torture/execute/960513-1.c
new file mode 100644
index 00000000000..acc263ca6c8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960513-1.c
@@ -0,0 +1,25 @@
+long double
+f (d, i)
+     long double d;
+     int i;
+{
+  long double e;
+
+  d = -d;
+  e = d;
+  if (i == 1)
+    d *= 2;
+  d -= e * d;
+  d -= e * d;
+  d -= e * d;
+  d -= e * d;
+  d -= e * d;
+  return d;
+}
+
+main ()
+{
+  if (! (int) (f (2.0L, 1)))
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960521-1.c b/gcc/testsuite/gcc.c-torture/execute/960521-1.c
new file mode 100644
index 00000000000..9fc5821495a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960521-1.c
@@ -0,0 +1,30 @@
+#include <stdlib.h>
+
+int *a, *b;
+int n;
+
+#ifdef STACK_SIZE
+#define BLOCK_SIZE (STACK_SIZE / (sizeof (*a) + sizeof (*b)))
+#else
+#define BLOCK_SIZE 32768
+#endif
+foo ()
+{
+  int i;
+  for (i = 0; i < n; i++)
+    a[i] = -1;
+  for (i = 0; i < BLOCK_SIZE - 1; i++)
+    b[i] = -1;
+}
+
+main ()
+{
+  n = BLOCK_SIZE;
+  a = malloc (n * sizeof(*a));
+  b = malloc (n * sizeof(*b));
+  *b++ = 0;
+  foo ();
+  if (b[-1])
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960608-1.c b/gcc/testsuite/gcc.c-torture/execute/960608-1.c
new file mode 100644
index 00000000000..1f47d02d9d5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960608-1.c
@@ -0,0 +1,34 @@
+typedef struct
+{
+  unsigned char a  : 2;
+  unsigned char b  : 3;
+  unsigned char c  : 1;
+  unsigned char d  : 1;
+  unsigned char e  : 1;
+} a_struct;
+
+foo (flags)
+     a_struct *flags;
+{
+  return (flags->c != 0
+	  || flags->d != 1
+	  || flags->e != 1
+	  || flags->a != 2
+	  || flags->b != 3);
+}
+
+main ()
+{
+  a_struct flags;
+
+  flags.c  = 0;
+  flags.d  = 1;
+  flags.e  = 1;
+  flags.a  = 2;
+  flags.b  = 3;
+
+  if (foo (&flags) != 0)
+    abort ();
+  else
+    exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960801-1.c b/gcc/testsuite/gcc.c-torture/execute/960801-1.c
new file mode 100644
index 00000000000..1707269189a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960801-1.c
@@ -0,0 +1,32 @@
+unsigned
+f ()
+{
+  long long l2;
+  unsigned short us;
+  unsigned long long ul;
+  short s2;
+
+  ul = us = l2 = s2 = -1;
+  return ul;
+}
+
+unsigned long long
+g ()
+{
+  long long l2;
+  unsigned short us;
+  unsigned long long ul;
+  short s2;
+
+  ul = us = l2 = s2 = -1;
+  return ul;
+}
+
+main ()
+{
+  if (f () != (unsigned short) -1)
+    abort ();
+  if (g () != (unsigned short) -1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960802-1.c b/gcc/testsuite/gcc.c-torture/execute/960802-1.c
new file mode 100644
index 00000000000..f9ee75260be
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960802-1.c
@@ -0,0 +1,36 @@
+long val = 0x5e000000;
+
+long
+f1 (void)
+{
+  return 0x132;
+}
+
+long
+f2 (void)
+{
+  return 0x5e000000;
+}
+
+void
+f3 (long b)
+{
+  val = b;
+}
+
+void
+f4 ()
+{
+  long v = f1 ();
+  long o = f2 ();
+  v = (v & 0x00ffffff) | (o & 0xff000000);
+  f3 (v);
+}
+
+main ()
+{
+  f4 ();
+  if (val != 0x5e000132)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/960830-1.c b/gcc/testsuite/gcc.c-torture/execute/960830-1.c
new file mode 100644
index 00000000000..d87b39e2da3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960830-1.c
@@ -0,0 +1,22 @@
+#ifdef __i386__
+f (rp)
+     unsigned int *rp;
+{
+  __asm__ ("mull %3" : "=a" (rp[0]), "=d" (rp[1]) : "%0" (7), "rm" (7));
+}
+
+main ()
+{
+  unsigned int s[2];
+
+  f (s);
+  if (s[1] != 0 || s[0] != 49)
+    abort ();
+ exit (0);
+}
+#else
+main ()
+{
+  exit (0);
+}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/960909-1.c b/gcc/testsuite/gcc.c-torture/execute/960909-1.c
new file mode 100644
index 00000000000..de1ed933978
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/960909-1.c
@@ -0,0 +1,29 @@
+int
+ffs (x)
+     int x;
+{
+  int bit, mask;
+
+  if (x == 0)
+    return 0;
+
+  for (bit = 1, mask = 1; !(x & mask); bit++, mask <<= 1)
+    ;
+
+  return bit;
+}
+
+f (x)
+     int x;
+{
+  int y;
+  y = ffs (x) - 1;
+  if (y < 0) 
+    abort ();
+}
+
+main ()
+{
+  f (1);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961004-1.c b/gcc/testsuite/gcc.c-torture/execute/961004-1.c
new file mode 100644
index 00000000000..7ebba2d7b1e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961004-1.c
@@ -0,0 +1,22 @@
+int k = 0;
+
+main()
+{
+  int i;
+  int j;
+
+  for (i = 0; i < 2; i++)
+    {
+      if (k)
+	{
+	  if (j != 2)
+	    abort ();
+	}
+      else
+	{
+	  j = 2;
+	  k++;
+	}
+    }
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961017-1.c b/gcc/testsuite/gcc.c-torture/execute/961017-1.c
new file mode 100644
index 00000000000..88c9d9505a1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961017-1.c
@@ -0,0 +1,8 @@
+main ()
+{
+  unsigned char z = 0;
+
+  do ;
+  while (--z > 0);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961017-2.c b/gcc/testsuite/gcc.c-torture/execute/961017-2.c
new file mode 100644
index 00000000000..768ddbc6e74
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961017-2.c
@@ -0,0 +1,32 @@
+main ()
+{
+  int i = 0;
+
+
+  if (sizeof (unsigned long int) == 4)
+    {
+      unsigned long int z = 0;
+
+      do {
+	z -= 0x00004000;
+	i++;
+	if (i > 0x00040000)
+	  abort ();
+      } while (z > 0);
+      exit (0);
+    }
+  else if (sizeof (unsigned int) == 4)
+    {
+      unsigned int z = 0;
+
+      do {
+	z -= 0x00004000;
+	i++;
+	if (i > 0x00040000)
+	  abort ();
+      } while (z > 0);
+      exit (0);
+    }
+  else
+    exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961026-1.c b/gcc/testsuite/gcc.c-torture/execute/961026-1.c
new file mode 100644
index 00000000000..942a6eb131a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961026-1.c
@@ -0,0 +1,17 @@
+int
+test (arg)
+     int arg;
+{
+  if (arg > 0 || arg == 0)
+    return 0;
+  return -1;
+}
+
+main ()
+{
+  if (test (0) != 0)
+    abort ();
+  if (test (-1) != -1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961112-1.c b/gcc/testsuite/gcc.c-torture/execute/961112-1.c
new file mode 100644
index 00000000000..4b1c31222ca
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961112-1.c
@@ -0,0 +1,13 @@
+f (x)
+{
+  if (x != 0 || x == 0)
+    return 0;
+  return 1;
+}
+
+main ()
+{
+  if (f (3))
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961122-1.c b/gcc/testsuite/gcc.c-torture/execute/961122-1.c
new file mode 100644
index 00000000000..1f0a63463e1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961122-1.c
@@ -0,0 +1,23 @@
+long long acc;
+
+addhi (short a)
+{
+  acc += (long long) a << 32;
+}
+
+subhi (short a)
+{
+  acc -= (long long) a << 32;
+}
+
+main ()
+{
+  acc = 0xffff00000000ll;
+  addhi (1);
+  if (acc != 0x1000000000000ll)
+    abort ();
+  subhi (1);
+  if (acc != 0xffff00000000ll)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961122-2.c b/gcc/testsuite/gcc.c-torture/execute/961122-2.c
new file mode 100644
index 00000000000..81e404ec4f1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961122-2.c
@@ -0,0 +1,12 @@
+int
+f (int a)
+{
+  return ((a >= 0 && a <= 10) && ! (a >= 0));
+}
+
+main ()
+{
+  if (f (0))
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961125-1.c b/gcc/testsuite/gcc.c-torture/execute/961125-1.c
new file mode 100644
index 00000000000..7fe3dd45422
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961125-1.c
@@ -0,0 +1,33 @@
+static char *
+begfield (int tab, char *ptr, char *lim, int sword, int schar)
+{
+  if (tab)
+    {
+      while (ptr < lim && sword--)
+	{
+	  while (ptr < lim && *ptr != tab)
+	    ++ptr;
+	  if (ptr < lim)
+	    ++ptr;
+	}
+    }
+  else
+    {
+      while (1)
+	;
+    }
+
+  if (ptr + schar <= lim)
+    ptr += schar;
+
+  return ptr;
+}
+
+main ()
+{
+  char *s = ":ab";
+  char *lim = s + 3;
+  if (begfield (':', s, lim, 1, 1) != s + 2)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961206-1.c b/gcc/testsuite/gcc.c-torture/execute/961206-1.c
new file mode 100644
index 00000000000..943ac66804d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961206-1.c
@@ -0,0 +1,52 @@
+int
+sub1 (unsigned long long i)
+{
+  if (i < 0x80000000)
+    return 1;
+  else
+    return 0;
+}
+
+int
+sub2 (unsigned long long i)
+{
+  if (i <= 0x7FFFFFFF)
+    return 1;
+  else
+    return 0;
+}
+
+int
+sub3 (unsigned long long i)
+{
+  if (i >= 0x80000000)
+    return 0;
+  else
+    return 1;
+}
+
+int
+sub4 (unsigned long long i)
+{
+  if (i > 0x7FFFFFFF)
+    return 0;
+  else
+    return 1;
+}
+
+main()
+{
+  if (sub1 (0x80000000ULL))
+    abort ();
+
+  if (sub2 (0x80000000ULL))
+    abort ();
+
+  if (sub3 (0x80000000ULL))
+    abort ();
+
+  if (sub4 (0x80000000ULL))
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961213-1.c b/gcc/testsuite/gcc.c-torture/execute/961213-1.c
new file mode 100644
index 00000000000..12bb27f3145
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961213-1.c
@@ -0,0 +1,22 @@
+int
+g (unsigned long long int *v, int n, unsigned int a[], int b)
+{
+  int cnt;
+  *v = 0;
+  for (cnt = 0; cnt < n; ++cnt)
+    *v = *v * b + a[cnt];
+  return n;
+}
+
+main ()
+{
+  int res;
+  unsigned int ar[] = { 10, 11, 12, 13, 14 };
+  unsigned long long int v;
+
+  res = g (&v, sizeof(ar)/sizeof(ar[0]), ar, 16);
+  if (v != 0xabcdeUL)
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/961223-1.c b/gcc/testsuite/gcc.c-torture/execute/961223-1.c
new file mode 100644
index 00000000000..9bc6cfa354d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/961223-1.c
@@ -0,0 +1,19 @@
+struct s {
+  double d;
+};
+
+inline struct s
+sub (struct s s)
+{
+  s.d += 1.0;
+  return s;
+}
+
+main ()
+{
+  struct s t = { 2.0 };
+  t = sub (t);
+  if (t.d != 3.0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/970214-1.c b/gcc/testsuite/gcc.c-torture/execute/970214-1.c
new file mode 100644
index 00000000000..4a06dfebc8d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/970214-1.c
@@ -0,0 +1,5 @@
+#define L 1
+main ()
+{
+  exit (L'1' != L'1');
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/970214-2.c b/gcc/testsuite/gcc.c-torture/execute/970214-2.c
new file mode 100644
index 00000000000..cb9007625dd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/970214-2.c
@@ -0,0 +1,5 @@
+#define m(L) (L'1' + (L))
+main ()
+{
+  exit (m (0) != L'1');
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/970217-1.c b/gcc/testsuite/gcc.c-torture/execute/970217-1.c
new file mode 100644
index 00000000000..09e716a330b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/970217-1.c
@@ -0,0 +1,10 @@
+sub (int i, int array[i++])
+{
+  return i;
+}
+
+main()
+{
+  int array[10];
+  exit (sub (10, array) != 11);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/970312-1.c b/gcc/testsuite/gcc.c-torture/execute/970312-1.c
new file mode 100644
index 00000000000..6b78ee1ca60
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/970312-1.c
@@ -0,0 +1,73 @@
+#include <stdio.h>
+
+__inline__ static int
+dummy (x)
+{
+  int y;
+  y = (long) (x * 4711.3);
+  return y;
+}
+
+int getval (void);
+
+int
+f2 (double x)
+{
+  unsigned short s;
+  int a, b, c, d, e, f, g, h, i, j;
+
+  a = getval ();
+  b = getval ();
+  c = getval ();
+  d = getval ();
+  e = getval ();
+  f = getval ();
+  g = getval ();
+  h = getval ();
+  i = getval ();
+  j = getval ();
+
+
+  s = x;
+
+  return a + b + c + d + e + f + g + h + i + j + s;
+}
+
+int x = 1;
+
+int
+getval (void)
+{
+  return x++;
+}
+
+char buf[10];
+
+void
+f ()
+{
+  int a, b, c, d, e, f, g, h, i, j, k;
+
+  a = getval ();
+  b = getval ();
+  c = getval ();
+  d = getval ();
+  e = getval ();
+  f = getval ();
+  g = getval ();
+  h = getval ();
+  i = getval ();
+  j = getval ();
+
+  k = f2 (17.0);
+
+  sprintf (buf, "%d\n", a + b + c + d + e + f + g + h + i + j + k);
+  if (a + b + c + d + e + f + g + h + i + j + k != 227)
+    abort ();
+}
+
+main ()
+{
+  f ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/970923-1.c b/gcc/testsuite/gcc.c-torture/execute/970923-1.c
new file mode 100644
index 00000000000..1d78b47c724
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/970923-1.c
@@ -0,0 +1,27 @@
+int
+ts(a)
+     int a;
+{
+  if (a < 1000 && a > 2000)
+    return 1;
+  else
+    return 0;
+}
+
+int
+tu(a)
+     unsigned int a;
+{
+  if (a < 1000 && a > 2000)
+    return 1;
+  else
+    return 0;
+}
+
+
+main()
+{
+  if (ts (0) || tu (0))
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980205.c b/gcc/testsuite/gcc.c-torture/execute/980205.c
new file mode 100644
index 00000000000..da15d3c4dd7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980205.c
@@ -0,0 +1,20 @@
+#include <stdarg.h>
+
+void fdouble (double one, ...)
+{
+  double value;
+  va_list ap;
+
+  va_start (ap, one);
+  value = va_arg (ap, double);
+  va_end (ap);
+
+  if (one != 1.0 || value != 2.0)
+    abort ();
+}
+
+int main ()
+{
+  fdouble (1.0, 2.0);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980223.c b/gcc/testsuite/gcc.c-torture/execute/980223.c
new file mode 100644
index 00000000000..eccfdfa8a39
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980223.c
@@ -0,0 +1,31 @@
+typedef struct { long addr; long type; } object;
+
+object bar (object blah)
+{
+  abort();
+}
+
+object foo (object x, object y)
+{
+  object z = *(object*)(x.addr);
+  if (z.type & 64)
+    {
+      y = *(object*)(z.addr+sizeof(object));
+      z = *(object*)(z.addr);
+      if (z.type & 64)
+        y = bar(y);
+    }
+  return y;
+}
+
+int nil;
+object cons1[2] = { {(long) &nil, 0}, {(long) &nil, 0} };
+object cons2[2] = { {(long) &cons1, 64}, {(long) &nil, 0} };
+
+main()
+{
+  object x = {(long) &cons2, 64};
+  object y = {(long) &nil, 0};
+  object three = foo(x,y);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980424-1.c b/gcc/testsuite/gcc.c-torture/execute/980424-1.c
new file mode 100644
index 00000000000..514e91773a5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980424-1.c
@@ -0,0 +1,22 @@
+int i, a[99];
+
+void f (int one)
+{
+  if (one != 1)
+    abort ();
+}
+
+void
+g ()
+{
+  f (a[i & 0x3f]);
+}
+
+int
+main ()
+{
+  a[0] = 1;
+  i = 0x40;
+  g ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980505-1.c b/gcc/testsuite/gcc.c-torture/execute/980505-1.c
new file mode 100644
index 00000000000..905241164dd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980505-1.c
@@ -0,0 +1,11 @@
+static int f(int) __attribute__((const));
+int main()
+{
+   int f1, f2, x;
+   x = 1; f1 = f(x);
+   x = 2; f2 = f(x);
+   if (f1 != 1 || f2 != 2)
+     abort ();
+   exit (0);
+}
+static int f(int x) { return x; }
diff --git a/gcc/testsuite/gcc.c-torture/execute/980505-2.c b/gcc/testsuite/gcc.c-torture/execute/980505-2.c
new file mode 100644
index 00000000000..d0d8aa8c6c0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980505-2.c
@@ -0,0 +1,22 @@
+typedef unsigned short Uint16;
+typedef unsigned int Uint;
+
+Uint f ()
+{
+        Uint16 token;
+        Uint count;
+        static Uint16 values[1] = {0x9300};
+
+        token = values[0];
+        count = token >> 8;
+
+        return count;
+}
+
+int
+main ()
+{
+  if (f () != 0x93)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980506-1.c b/gcc/testsuite/gcc.c-torture/execute/980506-1.c
new file mode 100644
index 00000000000..a48b3ad4cd7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980506-1.c
@@ -0,0 +1,26 @@
+struct decision
+{
+  char enforce_mode;             
+  struct decision *next;         
+};
+
+
+static void
+clear_modes (p)
+     register struct decision *p;
+{
+  goto blah;
+
+foo:
+  p->enforce_mode = 0;
+blah:
+  if (p)
+    goto foo;
+}
+
+main()
+{
+  struct decision *p = 0;
+  clear_modes (p);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980506-2.c b/gcc/testsuite/gcc.c-torture/execute/980506-2.c
new file mode 100644
index 00000000000..4dd9a2c4814
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980506-2.c
@@ -0,0 +1,22 @@
+static void *self(void *p){ return p; }
+
+int
+f()
+{
+  struct { int i; } s, *sp;
+  int *ip = &s.i;
+
+  s.i = 1;
+  sp = self(&s);
+  
+  *ip = 0;
+  return sp->i+1;
+}
+
+main()
+{
+  if (f () != 1)
+    abort ();
+  else
+    exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980506-3.c b/gcc/testsuite/gcc.c-torture/execute/980506-3.c
new file mode 100644
index 00000000000..a943e9ad62c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980506-3.c
@@ -0,0 +1,24 @@
+unsigned char lookup_table [257];
+
+static int 
+build_lookup (pattern)
+     unsigned char *pattern;
+{
+  int m;
+
+  m = strlen (pattern) - 1;
+  
+  memset (lookup_table, ++m, 257);
+  return m;
+}
+
+int main(argc, argv)
+     int argc;
+     char **argv;
+{
+  if (build_lookup ("bind") != 4)
+    abort ();
+  else
+    exit (0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/980526-1.c b/gcc/testsuite/gcc.c-torture/execute/980526-1.c
new file mode 100644
index 00000000000..57a910e4366
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980526-1.c
@@ -0,0 +1,37 @@
+int expect_do1 = 1, expect_do2 = 2;
+ 
+static int doit(int x){
+  __label__ lbl1;
+  __label__ lbl2;
+  static int jtab_init = 0;
+  static void *jtab[2];
+ 
+  if(!jtab_init) {
+    jtab[0] = &&lbl1;
+    jtab[1] = &&lbl2;
+    jtab_init = 1;
+  }
+  goto *jtab[x];
+lbl1:
+  return 1;
+lbl2:
+  return 2;
+}
+ 
+static void do1(void) {
+  if (doit(0) != expect_do1)
+    abort ();
+}
+ 
+static void do2(void){
+  if (doit(1) != expect_do2)
+    abort ();
+}
+ 
+int main(void){
+#ifndef NO_LABEL_VALUES
+  do1();
+  do2();
+#endif
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980526-2.c b/gcc/testsuite/gcc.c-torture/execute/980526-2.c
new file mode 100644
index 00000000000..2547147176d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980526-2.c
@@ -0,0 +1,57 @@
+typedef unsigned int dev_t;
+typedef unsigned int kdev_t;
+
+static inline kdev_t to_kdev_t(int dev)
+{
+	int major, minor;
+	
+	if (sizeof(kdev_t) == 16)
+		return (kdev_t)dev;
+	major = (dev >> 8);
+	minor = (dev & 0xff);
+	return ((( major ) << 22 ) | (  minor )) ;
+
+}
+
+void do_mknod(const char * filename, int mode, kdev_t dev)
+{
+	if (dev==0x15800078)
+		exit(0);
+	else
+		abort();
+}
+
+
+char * getname(const char * filename)
+{
+	register unsigned int a1,a2,a3,a4,a5,a6,a7,a8,a9;
+	a1 = (unsigned int)(filename) *5 + 1;
+	a2 = (unsigned int)(filename) *6 + 2;
+	a3 = (unsigned int)(filename) *7 + 3;
+	a4 = (unsigned int)(filename) *8 + 4;
+	a5 = (unsigned int)(filename) *9 + 5;
+	a6 = (unsigned int)(filename) *10 + 5;
+	a7 = (unsigned int)(filename) *11 + 5;
+	a8 = (unsigned int)(filename) *12 + 5;
+	a9 = (unsigned int)(filename) *13 + 5;
+	return (char *)(a1*a2+a3*a4+a5*a6+a7*a8+a9);
+}
+
+int sys_mknod(const char * filename, int mode, dev_t dev)
+{
+	int error;
+	char * tmp;
+
+	tmp = getname(filename);
+	error = ((long)( tmp )) ;
+	do_mknod(tmp,mode,to_kdev_t(dev));
+	return error;
+}
+
+int main(void)
+{
+	if (sizeof (int) < 4)
+	  exit (0);
+
+	return sys_mknod("test",1,0x12345678);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980526-3.c b/gcc/testsuite/gcc.c-torture/execute/980526-3.c
new file mode 100644
index 00000000000..a564174e283
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980526-3.c
@@ -0,0 +1,20 @@
+int compare(x, y)
+unsigned int x;
+unsigned int y;
+{
+   if (x==y)
+     return 0;
+   else
+     return 1;
+}
+ 
+main()
+{
+ unsigned int i, j, k, l;
+ i = 5; j = 2; k=0; l=2;
+ if (compare(5%(~(unsigned) 2), i%~j) 
+     || compare(0, k%~l))
+    abort();
+ else
+    exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980602-1.c b/gcc/testsuite/gcc.c-torture/execute/980602-1.c
new file mode 100644
index 00000000000..2df7283740f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980602-1.c
@@ -0,0 +1,10 @@
+main()
+{
+  int i;
+  for (i = 1; i < 100; i++)
+    ;
+  if (i == 100) 
+    exit (0);
+  abort ();
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/980602-2.c b/gcc/testsuite/gcc.c-torture/execute/980602-2.c
new file mode 100644
index 00000000000..8ef23222d62
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980602-2.c
@@ -0,0 +1,11 @@
+struct {
+    unsigned bit : 30;
+} t;
+
+int main()
+{
+    if (!(t.bit++))
+	exit (0);
+    else
+	abort ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980604-1.c b/gcc/testsuite/gcc.c-torture/execute/980604-1.c
new file mode 100644
index 00000000000..8992a90c643
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980604-1.c
@@ -0,0 +1,20 @@
+int a = 1;
+int b = -1;
+
+int c = 1;
+int d = 0;
+
+main ()
+{
+  double e;
+  double f;
+  double g;
+
+  f = c;
+  g = d;
+  e = (a < b) ? f : g;
+  if (e)
+    abort ();
+  exit(0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/980605-1.c b/gcc/testsuite/gcc.c-torture/execute/980605-1.c
new file mode 100644
index 00000000000..2fc2691e535
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980605-1.c
@@ -0,0 +1,78 @@
+#include <stdio.h>
+
+#ifndef STACK_SIZE
+#define STACK_SIZE 200000
+#endif
+
+__inline__ static int
+dummy (x)
+{
+  int y;
+  y = (long) (x * 4711.3);
+  return y;
+}
+
+int getval (void);
+
+int
+f2 (double x)
+{
+  unsigned short s;
+  int a, b, c, d, e, f, g, h, i, j;
+
+  a = getval ();
+  b = getval ();
+  c = getval ();
+  d = getval ();
+  e = getval ();
+  f = getval ();
+  g = getval ();
+  h = getval ();
+  i = getval ();
+  j = getval ();
+
+
+  s = x;
+
+  return a + b + c + d + e + f + g + h + i + j + s;
+}
+
+int x = 1;
+
+int
+getval (void)
+{
+  return x++;
+}
+
+char buf[10];
+
+void
+f ()
+{
+  char ar[STACK_SIZE/2];
+  int a, b, c, d, e, f, g, h, i, j, k;
+
+  a = getval ();
+  b = getval ();
+  c = getval ();
+  d = getval ();
+  e = getval ();
+  f = getval ();
+  g = getval ();
+  h = getval ();
+  i = getval ();
+  j = getval ();
+
+  k = f2 (17.0);
+
+  sprintf (buf, "%d\n", a + b + c + d + e + f + g + h + i + j + k);
+  if (a + b + c + d + e + f + g + h + i + j + k != 227)
+    abort ();
+}
+
+main ()
+{
+  f ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980608-1.c b/gcc/testsuite/gcc.c-torture/execute/980608-1.c
new file mode 100644
index 00000000000..b34d1374903
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980608-1.c
@@ -0,0 +1,36 @@
+#include <stdarg.h>
+
+void f1(int a,int b,int c,int d,int e, int f,int g,int h,int i,int j, int k,int
+l,int m,int n,int o)
+{
+    return;
+}
+
+inline void debug(const char *msg,...)
+{
+    va_list ap;
+    va_start( ap, msg );
+
+    f1(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
+
+    if ( va_arg(ap,int) != 101)
+        abort();
+    if ( va_arg(ap,int) != 102)
+        abort();
+    if ( va_arg(ap,int) != 103)
+        abort();
+    if ( va_arg(ap,int) != 104)
+        abort();
+    if ( va_arg(ap,int) != 105)
+        abort();
+    if ( va_arg(ap,int) != 106)
+        abort();
+
+    va_end( ap );
+}
+
+int main(void)
+{
+  debug("%d %d %d  %d %d %d\n", 101, 102, 103, 104, 105, 106);
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980612-1.c b/gcc/testsuite/gcc.c-torture/execute/980612-1.c
new file mode 100644
index 00000000000..db2438731a1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980612-1.c
@@ -0,0 +1,17 @@
+struct fd
+{
+	unsigned char a;
+	unsigned char b;
+} f = { 5 };
+
+struct fd *g() { return &f; }
+int h() { return -1; }
+
+int main()
+{
+	struct fd *f = g();
+	f->b = h();
+	if (((f->a & 0x7f) & ~0x10) <= 2)
+		abort ();
+	exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980617-1.c b/gcc/testsuite/gcc.c-torture/execute/980617-1.c
new file mode 100644
index 00000000000..5f7768aca7a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980617-1.c
@@ -0,0 +1,14 @@
+void foo (unsigned int * p)
+{
+  if ((signed char)(*p & 0xFF) == 17 || (signed char)(*p & 0xFF) == 18)
+    return;
+  else
+    abort ();
+}
+
+int main ()
+{
+  int i = 0x30011;
+  foo(&i);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980618-1.c b/gcc/testsuite/gcc.c-torture/execute/980618-1.c
new file mode 100644
index 00000000000..59db7f28b9c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980618-1.c
@@ -0,0 +1,16 @@
+void func(int, int);
+
+int main()
+{
+        int x = 7;
+        func(!x, !7);
+	exit (0);
+}
+
+void func(int x, int y)
+{
+        if (x == y)
+                return;
+        else
+                abort ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980701-1.c b/gcc/testsuite/gcc.c-torture/execute/980701-1.c
new file mode 100644
index 00000000000..391cc0ee1c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980701-1.c
@@ -0,0 +1,22 @@
+ns_name_skip (unsigned char **x, unsigned char *y)
+{
+  *x = 0;
+  return 0;
+}
+
+unsigned char a[2];
+
+int dn_skipname(unsigned char *ptr, unsigned char *eom) {
+    unsigned char *saveptr = ptr;
+
+    if (ns_name_skip(&ptr, eom) == -1)
+	        return (-1);
+    return (ptr - saveptr);
+}
+
+main()
+{
+  if (dn_skipname (&a[0], &a[1]) == 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980707-1.c b/gcc/testsuite/gcc.c-torture/execute/980707-1.c
new file mode 100644
index 00000000000..3af163a3767
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980707-1.c
@@ -0,0 +1,46 @@
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+
+char **
+buildargv (char *input)
+{
+  static char *arglist[256];
+  int numargs = 0;
+
+  while (1)
+    {
+      while (isspace ((unsigned char)*input) && *input != 0)
+	input++;
+      if (*input == 0)
+	break;
+      arglist [numargs++] = input;
+      while (!isspace ((unsigned char)*input) && *input != 0)
+	input++;
+      if (*input == 0)
+	break;
+      *(input++) = 0;
+    }
+  arglist [numargs] = NULL;
+  return arglist;
+}
+
+
+int main()
+{
+  char **args;
+  char input[256];
+  int i;
+
+  strcpy(input, " a b");
+  args = buildargv(input);
+
+  if (strcmp (args[0], "a"))
+    abort ();
+  if (strcmp (args[1], "b"))
+    abort ();
+  if (args[2] != NULL)
+    abort ();
+  
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980709-1.c b/gcc/testsuite/gcc.c-torture/execute/980709-1.c
new file mode 100644
index 00000000000..cda80765a6f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980709-1.c
@@ -0,0 +1,14 @@
+#include <math.h>
+
+main()
+{
+  volatile double a;
+  double c;
+  a = 32.0;
+  c = pow(a, 1.0/3.0);
+  if (c + 0.1 > 3.174802
+      && c - 0.1 < 3.174802)
+    exit (0);
+  else
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/980716-1.c b/gcc/testsuite/gcc.c-torture/execute/980716-1.c
new file mode 100644
index 00000000000..91e5518d53f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980716-1.c
@@ -0,0 +1,26 @@
+#include <stdarg.h>
+
+void
+stub(int num, ...)
+{
+    va_list ap;
+    char *end;
+    int i;
+
+    for (i = 0; i < 2; i++) {
+        va_start(ap, num);
+        while ( 1 ) {
+            end = va_arg(ap, char *);
+            if (!end) break;
+        }
+        va_end(ap);
+    }
+}
+
+int
+main()
+{
+    stub(1, "ab", "bc", "cx", 0);
+    exit (0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/980929-1.c b/gcc/testsuite/gcc.c-torture/execute/980929-1.c
new file mode 100644
index 00000000000..1d9246e01d7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/980929-1.c
@@ -0,0 +1,21 @@
+void f(int i)
+{
+  if (i != 1000)
+    abort ();
+}
+
+
+int main()
+{
+  int n=1000;
+  int i;
+
+  f(n);
+  for(i=0; i<1; ++i) {
+    f(n);
+    n=666;
+    &n;
+  }
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/981001-1.c b/gcc/testsuite/gcc.c-torture/execute/981001-1.c
new file mode 100644
index 00000000000..da63f4796b8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/981001-1.c
@@ -0,0 +1,38 @@
+#define NG   0x100L
+
+unsigned long flg = 0;
+
+long sub (int n)
+{
+  int a, b ;
+
+  if (n >= 2)
+    {
+      if (n % 2 == 0)
+	{
+	  a = sub (n / 2);
+	  
+	  return (a + 2 * sub (n / 2 - 1)) * a;
+	}
+      else
+	{
+	  a = sub (n / 2 + 1);
+	  b = sub (n / 2);
+	  
+	  return a * a + b * b;
+	}
+    }
+  else 
+    return (long) n;
+}
+
+int main (void)
+{
+  if (sub (30) != 832040L)
+    flg |= NG;
+
+  if (flg)
+    abort ();
+  
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/981019-1.c b/gcc/testsuite/gcc.c-torture/execute/981019-1.c
new file mode 100644
index 00000000000..5d1f009009b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/981019-1.c
@@ -0,0 +1,44 @@
+extern int f2(void);
+extern int f3(void);
+extern void f1(void);
+
+void
+ff(int fname, int part, int nparts)
+{
+  if (fname)  /* bb 0 */
+    {
+      if (nparts)  /* bb 1 */
+	f1();  /* bb 2 */
+    }
+  else
+    fname = 2; /* bb 3  */
+
+  /* bb 4 is the branch to bb 10
+     (bb 10 is physically at the end of the loop) */
+  while (f3() /* bb 10 */)
+    {
+      if (nparts /* bb 5 */ && f2() /* bb 6 */)
+	{
+	  f1();  /* bb 7 ... */
+	  nparts = part;
+	  if (f3())  /* ... bb 7 */
+	    f1();  /* bb 8 */
+	  f1(); /* bb 9 */
+	  break;
+	}
+    }
+
+  if (nparts)  /* bb 11 */
+    f1(); /* bb 12 */
+  return; /* bb 13 */
+}
+
+int main(void)
+{
+  ff(0, 1, 0);
+  return 0;
+}
+
+int f3(void) { static int x = 0; x = !x; return x; }
+void f1(void) { abort(); }
+int f2(void) { abort(); }
diff --git a/gcc/testsuite/gcc.c-torture/execute/981130-1.c b/gcc/testsuite/gcc.c-torture/execute/981130-1.c
new file mode 100644
index 00000000000..72630b07ec8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/981130-1.c
@@ -0,0 +1,30 @@
+struct s { int a; int b;};
+struct s s1;
+struct s s2 = { 1, 2, };
+
+void
+check (a, b)
+     int a;
+     int b;
+{
+  if (a == b)
+    exit (0);
+  else
+    abort ();
+}
+
+int
+main ()
+{
+  int * p;
+  int x;
+  
+  s1.a = 9;
+  p    = & s1.a;
+  s1   = s2;
+  x    = * p;
+  
+  check (x, 1);
+}
+
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/981130-1.x b/gcc/testsuite/gcc.c-torture/execute/981130-1.x
new file mode 100644
index 00000000000..1565c68adc7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/981130-1.x
@@ -0,0 +1,22 @@
+# This test is known to fail on targets that use the instruction scheduler
+# at optimisation levels of 2 or more because the alias analysis is confused
+# by the reassignment of a variable structure to a fixed structure.  The 
+# failure could be suppressed by preventing instruction scheduling:
+#
+# set additional_flags "-fno-schedule-insns2";
+#
+# but this would disguise the fact that there is a problem.  Instead we use
+# we generate an xfail result and explain that it is alias analysis that
+# is at fault.
+
+set torture_eval_before_execute {
+
+    set compiler_conditional_xfail_data {
+        "alias analysis conflicts with instruction scheduling" \
+	"m32r-*-*" \
+	{ "-O2" "-O1" "-O0" "-Os"} \
+	{ "" }
+	}    
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/981206-1.c b/gcc/testsuite/gcc.c-torture/execute/981206-1.c
new file mode 100644
index 00000000000..12ec0ab1897
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/981206-1.c
@@ -0,0 +1,17 @@
+/* Verify unaligned address aliasing on Alpha EV[45].  */
+
+static unsigned short x, y;
+
+void foo()
+{
+  x = 0x345;
+  y = 0x567;
+}
+
+int main()
+{
+  foo ();
+  if (x != 0x345 || y != 0x567)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990106-1.c b/gcc/testsuite/gcc.c-torture/execute/990106-1.c
new file mode 100644
index 00000000000..6631bfd96cb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990106-1.c
@@ -0,0 +1,16 @@
+foo(bufp)
+char *bufp;
+{
+    int x = 80;
+    return (*bufp++ = x ? 'a' : 'b');
+}
+
+main()
+{
+  char x;
+
+  if (foo (&x) != 'a')
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990106-2.c b/gcc/testsuite/gcc.c-torture/execute/990106-2.c
new file mode 100644
index 00000000000..c2791efaae6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990106-2.c
@@ -0,0 +1,22 @@
+unsigned calc_mp(unsigned mod)
+{
+      unsigned a,b,c;
+      c=-1;
+      a=c/mod;
+      b=0-a*mod;
+      if (b > mod) { a += 1; b-=mod; }
+      return b;
+}
+
+int main(int argc, char *argv[])
+{
+      unsigned x = 1234;
+      unsigned y = calc_mp(x);
+
+      if ((sizeof (y) == 4 && y != 680)
+	  || (sizeof (y) == 2 && y != 134))
+	abort ();
+      exit (0);
+}
+
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/990117-1.c b/gcc/testsuite/gcc.c-torture/execute/990117-1.c
new file mode 100644
index 00000000000..9589ae746f8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990117-1.c
@@ -0,0 +1,16 @@
+int
+foo (int x, int y, int i, int j)
+{
+  double tmp1 = ((double) x / y);
+  double tmp2 = ((double) i / j);
+
+  return tmp1 < tmp2;
+}
+
+main ()
+{
+  if (foo (2, 24, 3, 4) == 0)
+    abort ();
+  return 0;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/990127-1.c b/gcc/testsuite/gcc.c-torture/execute/990127-1.c
new file mode 100644
index 00000000000..c49584820c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990127-1.c
@@ -0,0 +1,31 @@
+main()
+{
+    int a,b,c;
+    int *pa, *pb, *pc;
+    int **ppa, **ppb, **ppc;
+    int i,j,k,x,y,z;
+
+    a = 10;
+    b = 20;
+    c = 30;
+    pa = &a; pb = &b; pc = &c;
+    ppa = &pa; ppb = &pb; ppc = &pc;
+    x = 0; y = 0; z = 0;
+
+    for(i=0;i<10;i++){
+        if( pa == &a ) pa = &b;
+        else pa = &a;
+        while( (*pa)-- ){
+            x++;
+            if( (*pa) < 3 ) break;
+            else pa = &b;
+        }
+        x++;
+        pa = &b;
+    }
+
+    if ((*pa) != -5 || (*pb) != -5 || x != 43)
+      abort ();
+
+    exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990127-2.c b/gcc/testsuite/gcc.c-torture/execute/990127-2.c
new file mode 100644
index 00000000000..0d0f495124a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990127-2.c
@@ -0,0 +1,20 @@
+void
+fpEq (double x, double y)
+{
+  if (x != y)
+    abort ();
+}
+
+void
+fpTest (double x, double y)
+{
+  double result1 = (35.7 * 100.0) / 45.0;
+  double result2 = (x * 100.0) / y;
+  fpEq (result1, result2);
+}
+
+main ()
+{
+  fpTest (35.7, 45.0);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990128-1.c b/gcc/testsuite/gcc.c-torture/execute/990128-1.c
new file mode 100644
index 00000000000..cfdab3e87e5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990128-1.c
@@ -0,0 +1,50 @@
+extern int printf (const char *,...);
+
+struct s { struct s *n; } *p;
+struct s ss;
+#define MAX     10
+struct s sss[MAX];
+int count = 0;
+
+void sub( struct s *p, struct s **pp );
+int look( struct s *p, struct s **pp );
+
+main()
+{
+    struct s *pp;
+    struct s *next;
+    int i;
+
+    p = &ss;
+    next = p;
+    for ( i = 0; i < MAX; i++ ) {
+        next->n = &sss[i];
+        next = next->n;
+    }
+    next->n = 0;
+
+    sub( p, &pp );
+    if (count != MAX+2)
+      abort ();
+
+    exit( 0 );
+}
+
+void sub( struct s *p, struct s **pp )
+{
+   for ( ; look( p, pp ); ) {
+        if ( p )
+            p = p->n;
+        else
+            break;
+   }
+}
+
+int look( struct s *p, struct s **pp )
+{
+    for ( ; p; p = p->n )
+        ;
+    *pp = p;
+    count++;
+    return( 1 );
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990130-1.c b/gcc/testsuite/gcc.c-torture/execute/990130-1.c
new file mode 100644
index 00000000000..c38ecddbe59
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990130-1.c
@@ -0,0 +1,23 @@
+int count = 0;
+int dummy;
+
+static int *
+bar(void)
+{
+  ++count;
+  return &dummy;
+}
+
+static void
+foo(void)
+{
+  asm("" : "+r"(*bar()));
+}
+
+main()
+{
+  foo();
+  if (count != 1)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990208-1.c b/gcc/testsuite/gcc.c-torture/execute/990208-1.c
new file mode 100644
index 00000000000..37a11472962
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990208-1.c
@@ -0,0 +1,46 @@
+/* As a quality of implementation issue, we should not prevent inlining
+   of function explicitly marked inline just because a label therein had
+   its address taken.  */
+
+#ifndef NO_LABEL_VALUES
+static void *ptr1, *ptr2;
+
+static __inline__ void doit(void **pptr, int cond)
+{
+  if (cond) {
+  here:
+    *pptr = &&here;
+  }
+}
+
+static void f(int cond)
+{
+  doit (&ptr1, cond);
+}
+
+static void g(int cond)
+{
+  doit (&ptr2, cond);
+}
+
+static void bar(void);
+
+int main()
+{
+  f (1);
+  bar();
+  g (1);
+
+#ifdef  __OPTIMIZE__
+  if (ptr1 == ptr2)
+    abort ();
+#endif
+
+  exit (0);
+}
+
+void bar(void) { }
+
+#else /* NO_LABEL_VALUES */
+int main() { exit(0); }
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/990211-1.c b/gcc/testsuite/gcc.c-torture/execute/990211-1.c
new file mode 100644
index 00000000000..e2fe7eea398
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990211-1.c
@@ -0,0 +1,61 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+  Contributed by Nathan Sidwell 20 Jan 1999 <nathan@acm.org> */
+
+/* check range combining boolean operations work */
+
+extern void abort();
+
+#define N 77
+
+void func(int i)
+{
+  /* fold-const does some clever things with range tests. Make sure
+     we get (some of) them right */
+  
+  /* these must fail, regardless of the value of i */
+  if ((i < 0) && (i >= 0))
+    abort();
+  if ((i > 0) && (i <= 0))
+    abort();
+  if ((i >= 0) && (i < 0))
+    abort();
+  if ((i <= 0) && (i > 0))
+    abort();
+
+  if ((i < N) && (i >= N))
+    abort();
+  if ((i > N) && (i <= N))
+    abort();
+  if ((i >= N) && (i < N))
+    abort();
+  if ((i <= N) && (i > N))
+    abort();
+    
+  /* these must pass, regardless of the value of i */
+  if (! ((i < 0) || (i >= 0)))
+    abort();
+  if (! ((i > 0) || (i <= 0)))
+    abort();
+  if (! ((i >= 0) || (i < 0)))
+    abort();
+  if (! ((i <= 0) || (i > 0)))
+    abort();
+
+  if (! ((i < N) || (i >= N)))
+    abort();
+  if (! ((i > N) || (i <= N)))
+    abort();
+  if (! ((i >= N) || (i < N)))
+    abort();
+  if (! ((i <= N) || (i > N)))
+    abort();
+  
+  return;
+}
+
+int main()
+{
+  func(0);
+  func(1);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990222-1.c b/gcc/testsuite/gcc.c-torture/execute/990222-1.c
new file mode 100644
index 00000000000..98b94f39860
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990222-1.c
@@ -0,0 +1,11 @@
+char line[4] = { '1', '9', '9', '\0' };
+
+int main()
+{
+  char *ptr = line + 3;
+
+  while ((*--ptr += 1) > '9') *ptr = '0';
+  if (line[0] != '2' || line[1] != '0' || line[2] != '0')
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990324-1.c b/gcc/testsuite/gcc.c-torture/execute/990324-1.c
new file mode 100644
index 00000000000..d9baa0885f5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990324-1.c
@@ -0,0 +1,13 @@
+void f(long i)
+{
+  if ((signed char)i < 0 || (signed char)i == 0) 
+    abort ();
+  else
+    exit (0);
+}
+
+main()
+{
+  f(0xffffff01);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/990326-1.c b/gcc/testsuite/gcc.c-torture/execute/990326-1.c
new file mode 100644
index 00000000000..d7427cf8512
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990326-1.c
@@ -0,0 +1,407 @@
+struct a {
+	char a, b;
+	short c;
+};
+
+int
+a1()
+{
+	static struct a x = { 1, 2, ~1 }, y = { 65, 2, ~2 };
+
+	return (x.a == (y.a & ~64) && x.b == y.b);
+}
+
+int
+a2()
+{
+	static struct a x = { 1, 66, ~1 }, y = { 1, 2, ~2 };
+
+	return (x.a == y.a && (x.b & ~64) == y.b);
+}
+
+int
+a3()
+{
+	static struct a x = { 9, 66, ~1 }, y = { 33, 18, ~2 };
+
+	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
+}
+
+struct b {
+	int c;
+	short b, a;
+};
+
+int
+b1()
+{
+	static struct b x = { ~1, 2, 1 }, y = { ~2, 2, 65 };
+
+	return (x.a == (y.a & ~64) && x.b == y.b);
+}
+
+int
+b2()
+{
+	static struct b x = { ~1, 66, 1 }, y = { ~2, 2, 1 };
+
+	return (x.a == y.a && (x.b & ~64) == y.b);
+}
+
+int
+b3()
+{
+	static struct b x = { ~1, 66, 9 }, y = { ~2, 18, 33 };
+
+	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
+}
+
+struct c {
+	unsigned int c:4, b:14, a:14;
+} __attribute__ ((aligned));
+
+int
+c1()
+{
+	static struct c x = { ~1, 2, 1 }, y = { ~2, 2, 65 };
+
+	return (x.a == (y.a & ~64) && x.b == y.b);
+}
+
+int
+c2()
+{
+	static struct c x = { ~1, 66, 1 }, y = { ~2, 2, 1 };
+
+	return (x.a == y.a && (x.b & ~64) == y.b);
+}
+
+int
+c3()
+{
+	static struct c x = { ~1, 66, 9 }, y = { ~2, 18, 33 };
+
+	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
+}
+
+struct d {
+	unsigned int a:14, b:14, c:4;
+} __attribute__ ((aligned));
+
+int
+d1()
+{
+	static struct d x = { 1, 2, ~1 }, y = { 65, 2, ~2 };
+
+	return (x.a == (y.a & ~64) && x.b == y.b);
+}
+
+int
+d2()
+{
+	static struct d x = { 1, 66, ~1 }, y = { 1, 2, ~2 };
+
+	return (x.a == y.a && (x.b & ~64) == y.b);
+}
+
+int
+d3()
+{
+	static struct d x = { 9, 66, ~1 }, y = { 33, 18, ~2 };
+
+	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
+}
+
+struct e {
+	int c:4, b:14, a:14;
+} __attribute__ ((aligned));
+
+int
+e1()
+{
+	static struct e x = { ~1, -2, -65 }, y = { ~2, -2, -1 };
+
+	return (x.a == (y.a & ~64) && x.b == y.b);
+}
+
+int
+e2()
+{
+	static struct e x = { ~1, -2, -1 }, y = { ~2, -66, -1 };
+
+	return (x.a == y.a && (x.b & ~64) == y.b);
+}
+
+int
+e3()
+{
+	static struct e x = { ~1, -18, -33 }, y = { ~2, -66, -9 };
+
+	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
+}
+
+int
+e4()
+{
+	static struct e x = { -1, -1, 0 };
+
+	return x.a == 0 && x.b & 0x2000;
+}
+
+struct f {
+	int a:14, b:14, c:4;
+} __attribute__ ((aligned));
+
+int
+f1()
+{
+	static struct f x = { -65, -2, ~1 }, y = { -1, -2, ~2 };
+
+	return (x.a == (y.a & ~64) && x.b == y.b);
+}
+
+int
+f2()
+{
+	static struct f x = { -1, -2, ~1 }, y = { -1, -66, ~2 };
+
+	return (x.a == y.a && (x.b & ~64) == y.b);
+}
+
+int
+f3()
+{
+	static struct f x = { -33, -18, ~1 }, y = { -9, -66, ~2 };
+
+	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
+}
+
+int
+f4()
+{
+	static struct f x = { 0, -1, -1 };
+
+	return x.a == 0 && x.b & 0x2000;
+}
+
+struct gx {
+	int c:4, b:14, a:14;
+} __attribute__ ((aligned));
+struct gy {
+	int b:14, a:14, c:4;
+} __attribute__ ((aligned));
+
+int
+g1()
+{
+	static struct gx x = { ~1, -2, -65 };
+	static struct gy y = { -2, -1, ~2 };
+
+	return (x.a == (y.a & ~64) && x.b == y.b);
+}
+
+int
+g2()
+{
+	static struct gx x = { ~1, -2, -1 };
+	static struct gy y = { -66, -1, ~2 };
+
+	return (x.a == y.a && (x.b & ~64) == y.b);
+}
+
+int
+g3()
+{
+	static struct gx x = { ~1, -18, -33 };
+	static struct gy y = { -66, -9, ~2 };
+
+	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
+}
+
+int
+g4()
+{
+	static struct gx x = { ~1, 0x0020, 0x0010 };
+	static struct gy y = { 0x0200, 0x0100, ~2 };
+
+	return ((x.a & 0x00f0) == (y.a & 0x0f00) &&
+		(x.b & 0x00f0) == (y.b & 0x0f00));
+}
+
+int
+g5()
+{
+	static struct gx x = { ~1, 0x0200, 0x0100 };
+	static struct gy y = { 0x0020, 0x0010, ~2 };
+
+	return ((x.a & 0x0f00) == (y.a & 0x00f0) &&
+		(x.b & 0x0f00) == (y.b & 0x00f0));
+}
+
+int
+g6()
+{
+	static struct gx x = { ~1, 0xfe20, 0xfd10 };
+	static struct gy y = { 0xc22f, 0xc11f, ~2 };
+
+	return ((x.a & 0x03ff) == (y.a & 0x3ff0) &&
+		(x.b & 0x03ff) == (y.b & 0x3ff0));
+}
+
+int
+g7()
+{
+	static struct gx x = { ~1, 0xc22f, 0xc11f };
+	static struct gy y = { 0xfe20, 0xfd10, ~2 };
+
+	return ((x.a & 0x3ff0) == (y.a & 0x03ff) &&
+		(x.b & 0x3ff0) == (y.b & 0x03ff));
+}
+
+struct hx {
+	int a:14, b:14, c:4;
+} __attribute__ ((aligned));
+struct hy {
+	int c:4, a:14, b:14;
+} __attribute__ ((aligned));
+
+int
+h1()
+{
+	static struct hx x = { -65, -2, ~1 };
+	static struct hy y = { ~2, -1, -2 };
+
+	return (x.a == (y.a & ~64) && x.b == y.b);
+}
+
+int
+h2()
+{
+	static struct hx x = { -1, -2, ~1 };
+	static struct hy y = { ~2, -1, -66 };
+
+	return (x.a == y.a && (x.b & ~64) == y.b);
+}
+
+int
+h3()
+{
+	static struct hx x = { -33, -18, ~1 };
+	static struct hy y = { ~2, -9, -66 };
+
+	return ((x.a & ~8) == (y.a & ~32) && (x.b & ~64) == (y.b & ~16));
+}
+
+int
+h4()
+{
+	static struct hx x = { 0x0010, 0x0020, ~1 };
+	static struct hy y = { ~2, 0x0100, 0x0200 };
+
+	return ((x.a & 0x00f0) == (y.a & 0x0f00) &&
+		(x.b & 0x00f0) == (y.b & 0x0f00));
+}
+
+int
+h5()
+{
+	static struct hx x = { 0x0100, 0x0200, ~1 };
+	static struct hy y = { ~2, 0x0010, 0x0020 };
+
+	return ((x.a & 0x0f00) == (y.a & 0x00f0) &&
+		(x.b & 0x0f00) == (y.b & 0x00f0));
+}
+
+int
+h6()
+{
+	static struct hx x = { 0xfd10, 0xfe20, ~1 };
+	static struct hy y = { ~2, 0xc11f, 0xc22f };
+
+	return ((x.a & 0x03ff) == (y.a & 0x3ff0) &&
+		(x.b & 0x03ff) == (y.b & 0x3ff0));
+}
+
+int
+h7()
+{
+	static struct hx x = { 0xc11f, 0xc22f, ~1 };
+	static struct hy y = { ~2, 0xfd10, 0xfe20 };
+
+	return ((x.a & 0x3ff0) == (y.a & 0x03ff) &&
+		(x.b & 0x3ff0) == (y.b & 0x03ff));
+}
+
+int
+main()
+{
+  if (!a1 ())
+    abort ();
+  if (!a2 ())
+    abort ();
+  if (!a3 ())
+    abort ();
+  if (!b1 ())
+    abort ();
+  if (!b2 ())
+    abort ();
+  if (!b3 ())
+    abort ();
+  if (!c1 ())
+    abort ();
+  if (!c2 ())
+    abort ();
+  if (!c3 ())
+    abort ();
+  if (!d1 ())
+    abort ();
+  if (!d2 ())
+    abort ();
+  if (!d3 ())
+    abort ();
+  if (!e1 ())
+    abort ();
+  if (!e2 ())
+    abort ();
+  if (!e3 ())
+    abort ();
+  if (!e4 ())
+    abort ();
+  if (!f1 ())
+    abort ();
+  if (!f2 ())
+    abort ();
+  if (!f3 ())
+    abort ();
+  if (!f4 ())
+    abort ();
+  if (!g1 ())
+    abort ();
+  if (!g2 ())
+    abort ();
+  if (!g3 ())
+    abort ();
+  if (g4 ())
+    abort ();
+  if (g5 ())
+    abort ();
+  if (!g6 ())
+    abort ();
+  if (!g7 ())
+    abort ();
+  if (!h1 ())
+    abort ();
+  if (!h2 ())
+    abort ();
+  if (!h3 ())
+    abort ();
+  if (h4 ())
+    abort ();
+  if (h5 ())
+    abort ();
+  if (!h6 ())
+    abort ();
+  if (!h7 ())
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990404-1.c b/gcc/testsuite/gcc.c-torture/execute/990404-1.c
new file mode 100644
index 00000000000..be917d6d292
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990404-1.c
@@ -0,0 +1,27 @@
+
+int x[10] = { 0,1,2,3,4,5,6,7,8,9};
+
+int
+main()
+{
+  int niterations = 0, i;
+
+  for (;;) {
+    int i, mi, max;
+    max = 0;
+    for (i = 0; i < 10 ; i++) {
+      if (x[i] > max) {
+	max = x[i];
+	mi = i;
+      }
+    }
+    if (max == 0)
+      break;
+    x[mi] = 0;
+    niterations++;
+    if (niterations > 10)
+      abort ();
+  }
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990413-2.c b/gcc/testsuite/gcc.c-torture/execute/990413-2.c
new file mode 100644
index 00000000000..262140a3fe5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990413-2.c
@@ -0,0 +1,50 @@
+/* This tests for a bug in regstack that was breaking glibc's math library. */
+
+extern void abort (void);
+
+static __inline double
+minus_zero (void)
+{
+  union { double __d; int __i[2]; } __x;
+  __x.__i[0] = 0x0;
+  __x.__i[1] = 0x80000000;
+  return __x.__d;
+}
+
+static __inline long double
+__atan2l (long double __y, long double __x)
+{
+  register long double __value;
+  __asm __volatile__ ("fpatan\n\t"
+		      : "=t" (__value)
+		      : "0" (__x), "u" (__y)
+		      : "st(1)");
+  return __value;
+}
+
+static __inline long double
+__sqrtl (long double __x)
+{
+  register long double __result;
+  __asm __volatile__ ("fsqrt" : "=t" (__result) : "0" (__x));
+  return __result;
+}
+
+static __inline double
+asin (double __x)
+{
+  return __atan2l (__x, __sqrtl (1.0 - __x * __x));
+}
+
+int
+main (void)
+{
+  double x;
+
+  x = minus_zero();
+  x = asin (x);
+
+  if (x != 0.0) /* actually -0.0, but 0.0 == -0.0 */
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990413-2.x b/gcc/testsuite/gcc.c-torture/execute/990413-2.x
new file mode 100644
index 00000000000..039cecea4aa
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990413-2.x
@@ -0,0 +1,3 @@
+# This test is x86 specific.
+if { ! [istarget "i?86-*-*"] } { return 1 }
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/990513-1.c b/gcc/testsuite/gcc.c-torture/execute/990513-1.c
new file mode 100644
index 00000000000..6ad228fb006
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990513-1.c
@@ -0,0 +1,26 @@
+#include <string.h>
+
+void foo (int *BM_tab, int j)
+{
+  int *BM_tab_base;
+
+  BM_tab_base = BM_tab;
+  BM_tab += 0400;
+  while (BM_tab_base != BM_tab)
+    {
+      *--BM_tab = j;
+      *--BM_tab = j;
+      *--BM_tab = j;
+      *--BM_tab = j;
+    }
+}
+
+int main ()
+{
+  int BM_tab[0400];
+  memset (BM_tab, 0, sizeof (BM_tab));
+  foo (BM_tab, 6);
+  if (BM_tab[0] != 6)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/Makefile.in b/gcc/testsuite/gcc.c-torture/execute/Makefile.in
new file mode 100644
index 00000000000..e6209dbc6c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+	-rm -f *.o *.diff *~ *.bad core *.x
+
+distclean:	clean
+	-rm -f Makefile config.status
diff --git a/gcc/testsuite/gcc.c-torture/execute/arith-1.c b/gcc/testsuite/gcc.c-torture/execute/arith-1.c
new file mode 100644
index 00000000000..58df322e68a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/arith-1.c
@@ -0,0 +1,15 @@
+unsigned
+sat_add (unsigned i)
+{
+  unsigned ret = i + 1;
+  if (ret < i)
+    ret = i;
+  return ret;
+}
+
+main ()
+{
+  if (sat_add (~0U) != ~0U)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/arith-rand.c b/gcc/testsuite/gcc.c-torture/execute/arith-rand.c
new file mode 100644
index 00000000000..4af146a1a56
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/arith-rand.c
@@ -0,0 +1,114 @@
+long
+simple_rand ()
+{
+  static unsigned long seed = 47114711;
+  unsigned long this = seed * 1103515245 + 12345;
+  seed = this;
+  return this >> 8;
+}
+
+unsigned long int
+random_bitstring ()
+{
+  unsigned long int x;
+  int n_bits;
+  long ran;
+  int tot_bits = 0;
+
+  x = 0;
+  for (;;)
+    {
+      ran = simple_rand ();
+      n_bits = (ran >> 1) % 16;
+      tot_bits += n_bits;
+
+      if (n_bits == 0)
+	return x;
+      else
+	{
+	  x <<= n_bits;
+	  if (ran & 1)
+	    x |= (1 << n_bits) - 1;
+
+	  if (tot_bits > 8 * sizeof (long) + 6)
+	    return x;
+	}
+    }
+}
+
+#define ABS(x) ((x) >= 0 ? (x) : -(x))
+
+main ()
+{
+  long int i;
+
+  for (i = 0; i < 1000; i++)
+    {
+      unsigned long x, y;
+      x = random_bitstring ();
+      y = random_bitstring ();
+
+      if (sizeof (int) == sizeof (long))
+	goto save_time;
+
+      { unsigned long xx = x, yy = y, r1, r2;
+	if (yy == 0) continue;
+	r1 = xx / yy;
+	r2 = xx % yy;
+	if (r2 >= yy || r1 * yy + r2 != xx)
+	  abort ();
+      }
+      { signed long xx = x, yy = y, r1, r2;
+	if ((unsigned long) xx << 1 == 0 && yy == -1)
+	  continue;
+	r1 = xx / yy;
+	r2 = xx % yy;
+	if (ABS (r2) >= (unsigned long) ABS (yy) || (signed long) (r1 * yy + r2) != xx)
+	  abort ();
+      }
+    save_time:
+      { unsigned int xx = x, yy = y, r1, r2;
+	if (yy == 0) continue;
+	r1 = xx / yy;
+	r2 = xx % yy;
+	if (r2 >= yy || r1 * yy + r2 != xx)
+	  abort ();
+      }
+      { signed int xx = x, yy = y, r1, r2;
+	if ((unsigned int) xx << 1 == 0 && yy == -1)
+	  continue;
+	r1 = xx / yy;
+	r2 = xx % yy;
+	if (ABS (r2) >= (unsigned int) ABS (yy) || (signed int) (r1 * yy + r2) != xx)
+	  abort ();
+      }
+      { unsigned short xx = x, yy = y, r1, r2;
+	if (yy == 0) continue;
+	r1 = xx / yy;
+	r2 = xx % yy;
+	if (r2 >= yy || r1 * yy + r2 != xx)
+	  abort ();
+      }
+      { signed short xx = x, yy = y, r1, r2;
+	r1 = xx / yy;
+	r2 = xx % yy;
+	if (ABS (r2) >= (unsigned short) ABS (yy) || (signed short) (r1 * yy + r2) != xx)
+	  abort ();
+      }
+      { unsigned char xx = x, yy = y, r1, r2;
+	if (yy == 0) continue;
+	r1 = xx / yy;
+	r2 = xx % yy;
+	if (r2 >= yy || r1 * yy + r2 != xx)
+	  abort ();
+      }
+      { signed char xx = x, yy = y, r1, r2;
+	r1 = xx / yy;
+	r2 = xx % yy;
+	if (ABS (r2) >= (unsigned char) ABS (yy) || (signed char) (r1 * yy + r2) != xx)
+	  abort ();
+      }
+    }
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/bcp-1.c b/gcc/testsuite/gcc.c-torture/execute/bcp-1.c
new file mode 100644
index 00000000000..38b1d3e8e93
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bcp-1.c
@@ -0,0 +1,90 @@
+int global;
+
+/* These must fail.  */
+int bad0(void) { return __builtin_constant_p(global); }
+int bad1(void) { return __builtin_constant_p(global++); }
+inline int bad2(int x) { return __builtin_constant_p(x++); }
+inline int bad3(int x) { return __builtin_constant_p(x); }
+inline int bad4(const char *x) { return __builtin_constant_p(x); }
+int bad5(void) { return bad2(1); }
+inline int bad6(int x) { return __builtin_constant_p(x+1); }
+int bad7(void) { return __builtin_constant_p(abort()); }
+int bad8(void) { char buf[10]; return __builtin_constant_p(buf); }
+int bad9(const char *x) { return __builtin_constant_p(x[123456]); }
+int bad10(void) { return __builtin_constant_p(&global); }
+
+/* These must pass, or we've broken gcc2 functionality.  */
+int good0(void) { return __builtin_constant_p(1); }
+int good1(void) { return __builtin_constant_p("hi"); }
+int good2(void) { return __builtin_constant_p((1234 + 45) & ~7); }
+
+/* These are extensions to gcc2.  Failure indicates an optimization
+   regression.  */
+int opt0(void) { return bad3(1); }
+int opt1(void) { return bad6(1); }
+int opt2(void) { return __builtin_constant_p("hi"[0]); }
+
+/* 
+ * Opt3 is known to fail.  It is one of the important cases that glibc
+ * was interested in though, so keep this around as a reminder.
+ *
+ * The solution is to add bits to recover bytes from constant pool
+ * elements given nothing but a constant pool label and an offset.
+ * When we can do that, and we can simplify strlen after the fact,
+ * then we can enable recognition of constant pool labels as constants.
+ */
+
+/* int opt3(void) { return bad4("hi"); } */
+
+
+/* Call through tables so -finline-functions can't screw with us.  */
+int (*bad_t0[])(void) = {
+	bad0, bad1, bad5, bad7, bad8, bad10
+};
+
+int (*bad_t1[])(int x) = {
+	bad2, bad3, bad6
+};
+
+int (*bad_t2[])(const char *x) = {
+	bad4, bad9
+};
+
+int (*good_t0[])(void) = {
+	good0, good1, good2
+};
+
+int (*opt_t0[])(void) = {
+	opt0, opt1, opt2 /* , opt3 */
+};
+
+#define N(arr) (sizeof(arr)/sizeof(*arr))
+
+int main()
+{
+  int i;
+
+  for (i = 0; i < N(bad_t0); ++i)
+    if ((*bad_t0[i])())
+      abort();
+
+  for (i = 0; i < N(bad_t1); ++i)
+    if ((*bad_t1[i])(1))
+      abort();
+
+  for (i = 0; i < N(bad_t2); ++i)
+    if ((*bad_t2[i])("hi"))
+      abort();
+
+  for (i = 0; i < N(good_t0); ++i)
+    if (! (*good_t0[i])())
+      abort();
+
+#ifdef __OPTIMIZE__
+  for (i = 0; i < N(opt_t0); ++i)
+    if (! (*opt_t0[i])())
+      abort();
+#endif
+
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/bf-layout-1.c b/gcc/testsuite/gcc.c-torture/execute/bf-layout-1.c
new file mode 100644
index 00000000000..a82429ba208
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bf-layout-1.c
@@ -0,0 +1,9 @@
+struct { long f8:8; long f24:24; } a;
+struct { long f32:32; } b;
+
+main ()
+{
+  if (sizeof (a) != sizeof (b))
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/bf-pack-1.c b/gcc/testsuite/gcc.c-torture/execute/bf-pack-1.c
new file mode 100644
index 00000000000..ca3b1db763b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bf-pack-1.c
@@ -0,0 +1,23 @@
+struct foo
+{
+  unsigned half:16;
+  unsigned long whole:32 __attribute__ ((packed));
+};
+
+f (struct foo *q)
+{
+  if (q->half != 0x1234)
+    abort ();
+  if (q->whole != 0x56789abcL)
+    abort ();
+}
+
+main ()
+{
+  struct foo bar;
+
+  bar.half = 0x1234;
+  bar.whole = 0x56789abcL;
+  f (&bar);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/bf-sign-1.c b/gcc/testsuite/gcc.c-torture/execute/bf-sign-1.c
new file mode 100644
index 00000000000..3cc3eac15fd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bf-sign-1.c
@@ -0,0 +1,18 @@
+main ()
+{
+  struct  {
+    signed int s:3;
+    unsigned int u:3;
+    int i:3;
+  } x = {-1, -1, -1};
+
+  if (x.u != 7)
+    abort ();
+  if (x.s != - 1)
+    abort ();
+
+  if (x.i != -1 && x.i != 7)
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/bf-sign-2.c b/gcc/testsuite/gcc.c-torture/execute/bf-sign-2.c
new file mode 100644
index 00000000000..f0a8d52270b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bf-sign-2.c
@@ -0,0 +1,66 @@
+/* 
+ This test checks promotion of bitfields.  Bitfields should be promoted
+ very much like chars and shorts: 
+
+ Bitfields (signed or unsigned) should be promoted to signed int if their
+ value will fit in a signed int, otherwise to an unsigned int if their 
+ value will fit in an unsigned int, otherwise we don't promote them (ANSI/ISO
+ does not specify the behavior of bitfields larger than an unsigned int).
+
+ We test the behavior by subtracting two from the promoted value: this will
+ result in a negitive value for signed types, a positive value for unsigned
+ types.  This test (of course) assumes that the compiler is correctly 
+ implementing signed and unsigned arithmetic.
+ */
+
+struct X {
+  unsigned int	     u3:3;
+	   long int  s31:31;
+	   long int  s32:32;
+  unsigned long int  u31:31;
+  unsigned long int  u32:32;
+  unsigned long long ull3 :3;
+  unsigned long long ull35:35;
+  unsigned u15:15;
+};
+
+struct X x;
+
+main ()
+{
+  if ((x.u3 - 2) >= 0)		/* promoted value should be signed */
+    abort ();
+
+  if ((x.s31 - 2) >= 0)		/* promoted value should be signed */
+    abort ();
+
+  if ((x.s32 - 2) >= 0)		/* promoted value should be signed */
+    abort ();
+
+  if ((x.u15 - 2) >= 0)		/* promoted value should be signed */
+    abort ();
+
+  /* Conditionalize check on whether integers are 4 bytes or larger, i.e.
+     larger than a 31 bit bitfield.  */
+  if (sizeof (int) >= 4)
+    {
+      if ((x.u31 - 2) >= 0)	/* promoted value should be signed */
+	abort ();
+    }
+  else
+    {
+      if ((x.u31 - 2) < 0)	/* promoted value should be UNsigned */
+	abort ();
+    }
+
+  if ((x.u32 - 2) < 0)		/* promoted value should be UNsigned */
+    abort ();
+
+  if ((x.ull3 - 2) >= 0)	/* promoted value should be signed */
+    abort ();
+
+  if ((x.ull35 - 2) < 0)	/* promoted value should be UNsigned */
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/bf64-1.c b/gcc/testsuite/gcc.c-torture/execute/bf64-1.c
new file mode 100644
index 00000000000..60028fb1aa8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bf64-1.c
@@ -0,0 +1,40 @@
+struct tmp
+{
+  long long int pad : 12;
+  long long int field : 52;
+};
+
+struct tmp2
+{
+  long long int field : 52;
+  long long int pad : 12;
+};
+
+struct tmp
+sub (struct tmp tmp)
+{
+  tmp.field |= 0x0008765412345678LL;
+  return tmp;
+}
+
+struct tmp2
+sub2 (struct tmp2 tmp2)
+{
+  tmp2.field |= 0x0008765412345678LL;
+  return tmp2;
+}
+
+main()
+{
+  struct tmp tmp = {0x123, 0xFFF000FFF000FLL};
+  struct tmp2 tmp2 = {0xFFF000FFF000FLL, 0x123};
+
+  tmp = sub (tmp);
+  tmp2 = sub2 (tmp2);
+
+  if (tmp.pad != 0x123 || tmp.field != 0xFFFFFF541FFF567FLL)
+    abort ();
+  if (tmp2.pad != 0x123 || tmp2.field != 0xFFFFFF541FFF567FLL)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/cbrt.c b/gcc/testsuite/gcc.c-torture/execute/cbrt.c
new file mode 100644
index 00000000000..8659cc7a723
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/cbrt.c
@@ -0,0 +1,92 @@
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+*/
+
+#ifndef __vax__
+static const unsigned long
+	B1 = 715094163, /* B1 = (682-0.03306235651)*2**20 */
+	B2 = 696219795; /* B2 = (664-0.03306235651)*2**20 */
+
+static const double
+	C =  5.42857142857142815906e-01, /* 19/35     = 0x3FE15F15, 0xF15F15F1 */
+	D = -7.05306122448979611050e-01, /* -864/1225 = 0xBFE691DE, 0x2532C834 */
+	E =  1.41428571428571436819e+00, /* 99/70     = 0x3FF6A0EA, 0x0EA0EA0F */
+	F =  1.60714285714285720630e+00, /* 45/28     = 0x3FF9B6DB, 0x6DB6DB6E */
+	G =  3.57142857142857150787e-01; /* 5/14      = 0x3FD6DB6D, 0xB6DB6DB7 */
+
+double
+cbrtl (double x)
+{
+  long hx;
+  double r,s,w;
+  double lt;
+  unsigned sign;
+  typedef unsigned unsigned32 __attribute__((mode(SI)));
+  union {
+    double t;
+    unsigned32 pt[2];
+  } ut, ux;
+  int n0;
+
+  ut.t = 1.0;
+  n0 = (ut.pt[0] == 0);
+
+  ut.t = 0.0;
+  ux.t = x;
+
+  hx = ux.pt[n0];			/* high word of x */
+  sign=hx&0x80000000;			/* sign= sign(x) */
+  hx  ^=sign;
+  if(hx>=0x7ff00000) return(x+x);	/* cbrt(NaN,INF) is itself */
+  if((hx| ux.pt[1-n0])==0)
+    return(ux.t);			/* cbrt(0) is itself */
+
+  ux.pt[n0] = hx;
+  /* rough cbrt to 5 bits */
+  if(hx<0x00100000)			/* subnormal number */
+    {ut.pt[n0]=0x43500000;		/* set t= 2**54 */
+     ut.t*=x; ut.pt[n0]=ut.pt[n0]/3+B2;
+   }
+  else
+    ut.pt[n0]=hx/3+B1;
+
+  /* new cbrt to 23 bits, may be implemented in single precision */
+  r=ut.t*ut.t/ux.t;
+  s=C+r*ut.t;
+  ut.t*=G+F/(s+E+D/s);
+
+  /* chopped to 20 bits and make it larger than cbrt(x) */
+  ut.pt[1-n0]=0; ut.pt[n0]+=0x00000001;
+
+  /* one step newton iteration to 53 bits with error less than 0.667 ulps */
+  s=ut.t*ut.t;				/* t*t is exact */
+  r=ux.t/s;
+  w=ut.t+ut.t;
+  r=(r-ut.t)/(w+r);			/* r-s is exact */
+  ut.t=ut.t+ut.t*r;
+
+  /* restore the sign bit */
+  ut.pt[n0] |= sign;
+
+  lt = ut.t;
+  lt -= (lt - (x/(lt*lt))) * 0.333333333333333333333;
+  return lt;
+}
+
+main ()
+{
+  if ((int) (cbrtl (27.0) + 0.5) != 3)
+    abort ();
+
+  exit (0);
+}
+#else
+main () { exit (0); }
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/cmpdi-1.c b/gcc/testsuite/gcc.c-torture/execute/cmpdi-1.c
new file mode 100644
index 00000000000..e3e9c860603
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/cmpdi-1.c
@@ -0,0 +1,218 @@
+#define F 140
+#define T 13
+
+feq (x, y)
+     long long int x;
+     long long int y;
+{
+  if (x == y)
+    return T;
+  else
+    return F;
+}
+
+fne (x, y)
+     long long int x;
+     long long int y;
+{
+  if (x != y)
+    return T;
+  else
+    return F;
+}
+
+flt (x, y)
+     long long int x;
+     long long int y;
+{
+  if (x < y)
+    return T;
+  else
+    return F;
+}
+
+fge (x, y)
+     long long int x;
+     long long int y;
+{
+  if (x >= y)
+    return T;
+  else
+    return F;
+}
+
+fgt (x, y)
+     long long int x;
+     long long int y;
+{
+  if (x > y)
+    return T;
+  else
+    return F;
+}
+
+fle (x, y)
+     long long int x;
+     long long int y;
+{
+  if (x <= y)
+    return T;
+  else
+    return F;
+}
+
+fltu (x, y)
+     unsigned long long int x;
+     unsigned long long int y;
+{
+  if (x < y)
+    return T;
+  else
+    return F;
+}
+
+fgeu (x, y)
+     unsigned long long int x;
+     unsigned long long int y;
+{
+  if (x >= y)
+    return T;
+  else
+    return F;
+}
+
+fgtu (x, y)
+     unsigned long long int x;
+     unsigned long long int y;
+{
+  if (x > y)
+    return T;
+  else
+    return F;
+}
+
+fleu (x, y)
+     unsigned long long int x;
+     unsigned long long int y;
+{
+  if (x <= y)
+    return T;
+  else
+    return F;
+}
+
+long long args[] =
+{
+  0LL,
+  1LL,
+  -1LL,
+  0x7fffffffffffffffLL,
+  0x8000000000000000LL,
+  0x8000000000000001LL,
+  0x1A3F237394D36C58LL,
+  0x93850E92CAAC1B04LL
+};
+
+int correct_results[] =
+{
+  T, F, F, T, F, T, F, T, F, T,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, F, T, T, F, F, T, T, F,
+  T, F, F, T, F, T, F, T, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, T, F, F, T, F, T, T, F,
+  T, F, F, T, F, T, F, T, F, T,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, F, T, T, F, F, T, T, F,
+  F, T, F, T, T, F, F, T, T, F,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, F, T, T, F, F, T, T, F,
+  F, T, F, T, T, F, F, T, T, F,
+  F, T, F, T, T, F, F, T, T, F,
+  F, T, F, T, T, F, T, F, F, T,
+  T, F, F, T, F, T, F, T, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, F, T, T, F, F, T, T, F,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, T, F, F, T, F, T, T, F,
+  T, F, F, T, F, T, F, T, F, T,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, F, T, T, F, F, T, T, F,
+  T, F, F, T, F, T, F, T, F, T,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, F, T, T, F, F, T, T, F,
+  F, T, F, T, T, F, F, T, T, F,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  T, F, F, T, F, T, F, T, F, T,
+  F, T, F, T, T, F, T, F, F, T,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, T, F, F, T, T, F, F, T,
+  F, T, T, F, F, T, F, T, T, F,
+  F, T, F, T, T, F, F, T, T, F,
+  F, T, F, T, T, F, F, T, T, F,
+  F, T, T, F, F, T, F, T, T, F,
+  T, F, F, T, F, T, F, T, F, T
+};
+
+main ()
+{
+  int i, j, *res = correct_results;
+
+  for (i = 0; i < 8; i++)
+    {
+      long long arg0 = args[i];
+      for (j = 0; j < 8; j++)
+	{
+	  long long arg1 = args[j];
+
+	  if (feq (arg0, arg1) != *res++)
+	    abort ();
+	  if (fne (arg0, arg1) != *res++)
+	    abort ();
+	  if (flt (arg0, arg1) != *res++)
+	    abort ();
+	  if (fge (arg0, arg1) != *res++)
+	    abort ();
+	  if (fgt (arg0, arg1) != *res++)
+	    abort ();
+	  if (fle (arg0, arg1) != *res++)
+	    abort ();
+	  if (fltu (arg0, arg1) != *res++)
+	    abort ();
+	  if (fgeu (arg0, arg1) != *res++)
+	    abort ();
+	  if (fgtu (arg0, arg1) != *res++)
+	    abort ();
+	  if (fleu (arg0, arg1) != *res++)
+	    abort ();
+	}
+    }
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/cmpsi-1.c b/gcc/testsuite/gcc.c-torture/execute/cmpsi-1.c
new file mode 100644
index 00000000000..9fce104fefb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/cmpsi-1.c
@@ -0,0 +1,32 @@
+f1 (unsigned int x, unsigned int y)
+{
+  if (x == 0)
+    dummy ();
+  x -= y;
+  /* 0xfffffff2 < 0x80000000? */
+  if (x < ~(~(unsigned int) 0 >> 1))
+    abort ();
+  return x;
+}
+
+f2 (unsigned long int x, unsigned long int y)
+{
+  if (x == 0)
+    dummy ();
+  x -= y;
+  /* 0xfffffff2 < 0x80000000? */
+  if (x < ~(~(unsigned long int) 0 >> 1))
+    abort ();
+  return x;
+}
+
+
+dummy () {}
+
+main ()
+{
+  /*      0x7ffffff3			0x80000001 */
+  f1 ((~(unsigned int) 0 >> 1) - 12, ~(~(unsigned int) 0 >> 1) + 1);
+  f2 ((~(unsigned long int) 0 >> 1) - 12, ~(~(unsigned long int) 0 >> 1) + 1);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/comp-goto-1.c b/gcc/testsuite/gcc.c-torture/execute/comp-goto-1.c
new file mode 100644
index 00000000000..f9f6c126df3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/comp-goto-1.c
@@ -0,0 +1,164 @@
+#include <stdlib.h>
+
+#ifndef NO_LABEL_VALUES
+typedef unsigned int uint32;
+typedef signed int sint32;
+
+typedef uint32 reg_t;
+
+typedef unsigned long int host_addr_t;
+typedef uint32 target_addr_t;
+typedef sint32 target_saddr_t;
+
+typedef union
+{
+  struct
+    {
+      unsigned int	offset:18;
+      unsigned int	ignore:4;
+      unsigned int	s1:8;
+      int		:2;
+      signed int	simm:14;
+      unsigned int	s3:8;
+      unsigned int	s2:8;
+      int		pad2:2;
+    } f1;
+  long long ll;
+  double d;
+} insn_t;
+
+typedef struct
+{
+  target_addr_t vaddr_tag;
+  unsigned long int rigged_paddr;
+} tlb_entry_t;
+
+typedef struct
+{
+  insn_t *pc;
+  reg_t registers[256];
+  insn_t *program;
+  tlb_entry_t tlb_tab[0x100];
+} environment_t;
+
+enum operations
+{
+  LOAD32_RR,
+  METAOP_DONE
+};
+
+host_addr_t
+f ()
+{
+  abort ();
+}
+
+reg_t
+simulator_kernel (int what, environment_t *env)
+{
+  register insn_t *pc = env->pc;
+  register reg_t *regs = env->registers;
+  register insn_t insn;
+  register int s1;
+  register reg_t r2;
+  register void *base_addr = &&sim_base_addr;
+  register tlb_entry_t *tlb = env->tlb_tab;
+
+  if (what != 0)
+    {
+      int i;
+      static void *op_map[] =
+	{
+	  &&L_LOAD32_RR,
+	  &&L_METAOP_DONE,
+	};
+      insn_t *program = env->program;
+      for (i = 0; i < what; i++)
+	program[i].f1.offset = op_map[program[i].f1.offset] - base_addr;
+    }
+
+ sim_base_addr:;
+
+  insn = *pc++;
+  r2 = (*(reg_t *) (((char *) regs) + (insn.f1.s2 << 2)));
+  s1 = (insn.f1.s1 << 2);
+  goto *(base_addr + insn.f1.offset);
+
+ L_LOAD32_RR:
+  {
+    target_addr_t vaddr_page = r2 / 4096;
+    unsigned int x = vaddr_page % 0x100;
+    insn = *pc++;
+
+    for (;;)
+      {
+	target_addr_t tag = tlb[x].vaddr_tag;
+	host_addr_t rigged_paddr = tlb[x].rigged_paddr;
+
+	if (tag == vaddr_page)
+	  {
+	    *(reg_t *) (((char *) regs) + s1) = *(uint32 *) (rigged_paddr + r2);
+	    r2 = *(reg_t *) (((char *) regs) + (insn.f1.s2 << 2));
+	    s1 = insn.f1.s1 << 2;
+	    goto *(base_addr + insn.f1.offset);
+	  }
+
+	if (((target_saddr_t) tag < 0))
+	  {
+	    *(reg_t *) (((char *) regs) + s1) = *(uint32 *) f ();
+	    r2 = *(reg_t *) (((char *) regs) + (insn.f1.s2 << 2));
+	    s1 = insn.f1.s1 << 2;
+	    goto *(base_addr + insn.f1.offset);
+	  }
+
+	x = (x - 1) % 0x100;
+      }
+
+    L_METAOP_DONE:
+      return (*(reg_t *) (((char *) regs) + s1));
+  }
+}
+
+insn_t program[2 + 1];
+
+void *malloc ();
+
+int
+main ()
+{
+  environment_t env;
+  insn_t insn;
+  int i, res;
+  host_addr_t a_page = (host_addr_t) malloc (2 * 4096);
+  target_addr_t a_vaddr = 0x123450;
+  target_addr_t vaddr_page = a_vaddr / 4096;
+  a_page = (a_page + 4096 - 1) & -4096;
+
+  env.tlb_tab[((vaddr_page) % 0x100)].vaddr_tag = vaddr_page;
+  env.tlb_tab[((vaddr_page) % 0x100)].rigged_paddr = a_page - vaddr_page * 4096;
+  insn.f1.offset = LOAD32_RR;
+  env.registers[0] = 0;
+  env.registers[2] = a_vaddr;
+  *(int *) (a_page + a_vaddr % 4096) = 88;
+  insn.f1.s1 = 0;
+  insn.f1.s2 = 2;
+
+  for (i = 0; i < 2; i++)
+    program[i] = insn;
+
+  insn.f1.offset = METAOP_DONE;
+  insn.f1.s1 = 0;
+  program[2] = insn;
+
+  env.pc = program;
+  env.program = program;
+
+  res = simulator_kernel (2 + 1, &env);
+
+  if (res != 88)
+    abort ();
+  exit (0);
+}
+#else
+main(){ exit (0); }
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/complex-1.c b/gcc/testsuite/gcc.c-torture/execute/complex-1.c
new file mode 100644
index 00000000000..424fa65b150
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/complex-1.c
@@ -0,0 +1,40 @@
+double
+g0 (double x)
+{
+  return 1.0;
+}
+
+double
+g1 (double x)
+{
+  return -1.0;
+}
+
+double
+g2 (double x)
+{
+  return 0.0;
+}
+
+__complex__ double
+cexp (__complex__ double x)
+{
+  double r;
+
+  r = g0 (__real__ x);
+  __real__ x = r * g1 (__imag__ x);
+  __imag__ x = r * g2 (__imag__ x);
+  return x;
+}
+
+main ()
+{
+  __complex__ double x;
+
+  x = cexp (1.0i);
+  if (__real__ x != -1.0)
+    abort ();
+  if (__imag__ x != 0.0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/complex-2.c b/gcc/testsuite/gcc.c-torture/execute/complex-2.c
new file mode 100644
index 00000000000..9634c7943f3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/complex-2.c
@@ -0,0 +1,27 @@
+__complex__ double
+f (__complex__ double x, __complex__ double y)
+{
+  x += y;
+  return x;
+}
+
+__complex__ double ag = 1.0 + 1.0i;
+__complex__ double bg = -2.0 + 2.0i;
+
+main ()
+{
+  __complex__ double a, b, c;
+
+  a = ag;
+  b = -2.0 + 2.0i;
+  c = f (a, b);
+
+  if (a != 1.0 + 1.0i)
+    abort ();
+  if (b != -2.0 + 2.0i)
+    abort ();
+  if (c != -1.0 + 3.0i)
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/complex-3.c b/gcc/testsuite/gcc.c-torture/execute/complex-3.c
new file mode 100644
index 00000000000..4297cf11ebd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/complex-3.c
@@ -0,0 +1,25 @@
+struct complex
+{
+  float r;
+  float i;
+};
+
+struct complex cmplx (float, float);
+
+struct complex
+f (float a, float b)
+{
+  struct complex c;
+  c.r = a;
+  c.i = b;
+  return c;
+}
+
+main ()
+{
+  struct complex z = f (1.0, 0.0);
+
+  if (z.r != 1.0 || z.i != 0.0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/complex-4.c b/gcc/testsuite/gcc.c-torture/execute/complex-4.c
new file mode 100644
index 00000000000..1c458d21fba
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/complex-4.c
@@ -0,0 +1,9 @@
+main ()
+{
+  if ((__complex__ double) 0.0 != (__complex__ double) (-0.0))
+    abort ();
+
+  if (0.0 != -0.0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/complex-5.c b/gcc/testsuite/gcc.c-torture/execute/complex-5.c
new file mode 100644
index 00000000000..a3338082c46
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/complex-5.c
@@ -0,0 +1,20 @@
+float __complex__
+p (float __complex__  a, float __complex__  b)
+{
+  return a + b;
+}
+
+float __complex__  x = 1.0 + 14.0 * (1.0fi);
+float __complex__  y = 7.0 + 5.0 * (1.0fi);
+float __complex__  w = 8.0 + 19.0 * (1.0fi);
+float __complex__  z;
+
+main ()
+{
+
+  z = p (x,y);
+  y = p (x, 1.0f / z);
+  if (z != w)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/compndlit-1.c b/gcc/testsuite/gcc.c-torture/execute/compndlit-1.c
new file mode 100644
index 00000000000..4a8488d0ab4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/compndlit-1.c
@@ -0,0 +1,15 @@
+struct S
+{
+  int a:3;
+  unsigned b:1, c:28;
+};
+
+struct S x = {1, 1, 1};
+
+main ()
+{
+  x = (struct S) {b:0, a:0, c:({ struct S o = x; o.a == 1 ? 10 : 20;})};
+  if (x.c != 10)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/configure.in b/gcc/testsuite/gcc.c-torture/execute/configure.in
new file mode 100644
index 00000000000..7d7078dbfd2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=execute.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/gcc.c-torture/execute/conversion.c b/gcc/testsuite/gcc.c-torture/execute/conversion.c
new file mode 100644
index 00000000000..fc69d6279ba
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/conversion.c
@@ -0,0 +1,380 @@
+/* Test front-end conversions, optimizer conversions, and run-time
+   conversions between different arithmetic types.
+
+   Constants are specified in a non-obvious way to make them work for
+   any word size.  Their value on a 32-bit machine is indicated in the
+   comments.
+
+   Note that this code is NOT intended for testing of accuracy of fp
+   conversions.  */
+
+float
+u2f(u)
+     unsigned int u;
+{
+  return u;
+}
+
+double
+u2d(u)
+     unsigned int u;
+{
+  return u;
+}
+
+float
+s2f(s)
+     int s;
+{
+  return s;
+}
+
+double
+s2d(s)
+     int s;
+{
+  return s;
+}
+
+int
+fnear (float x, float y)
+{
+  float t = x - y;
+  return t == 0 || x / t > 1000000.0;
+}
+
+int
+dnear (double x, double y)
+{
+  double t = x - y;
+  return t == 0 || x / t > 100000000000000.0;
+}
+
+test_integer_to_float()
+{
+  if (u2f(0U) != (float) 0U)				/* 0 */
+    abort();
+  if (!fnear (u2f(~0U), (float) ~0U))			/* 0xffffffff */
+    abort();
+  if (!fnear (u2f((~0U) >> 1), (float) ((~0U) >> 1)))	/* 0x7fffffff */
+    abort();
+  if (u2f(~((~0U) >> 1)) != (float) ~((~0U) >> 1))	/* 0x80000000 */
+    abort();
+
+  if (u2d(0U) != (double) 0U)				/* 0 */
+    abort();
+  if (!dnear (u2d(~0U), (double) ~0U))			/* 0xffffffff */
+    abort();
+  if (!dnear (u2d((~0U) >> 1),(double) ((~0U) >> 1)))	/* 0x7fffffff */
+    abort();
+  if (u2d(~((~0U) >> 1)) != (double) ~((~0U) >> 1))	/* 0x80000000 */
+    abort();
+
+  if (s2f(0) != (float) 0)				/* 0 */
+    abort();
+  if (!fnear (s2f(~0), (float) ~0))			/* 0xffffffff */
+    abort();
+  if (!fnear (s2f((int)((~0U) >> 1)), (float)(int)((~0U) >> 1))) /* 0x7fffffff */
+    abort();
+  if (s2f((int)(~((~0U) >> 1))) != (float)(int)~((~0U) >> 1)) /* 0x80000000 */
+    abort();
+
+  if (s2d(0) != (double) 0)				/* 0 */
+    abort();
+  if (!dnear (s2d(~0), (double) ~0))			/* 0xffffffff */
+    abort();
+  if (!dnear (s2d((int)((~0U) >> 1)), (double)(int)((~0U) >> 1))) /* 0x7fffffff */
+    abort();
+  if (s2d((int)~((~0U) >> 1)) != (double)(int)~((~0U) >> 1)) /* 0x80000000 */
+    abort();
+}
+
+#if __GNUC__
+float
+ull2f(u)
+     unsigned long long int u;
+{
+  return u;
+}
+
+double
+ull2d(u)
+     unsigned long long int u;
+{
+  return u;
+}
+
+float
+sll2f(s)
+     long long int s;
+{
+  return s;
+}
+
+double
+sll2d(s)
+     long long int s;
+{
+  return s;
+}
+
+test_longlong_integer_to_float()
+{
+  if (ull2f(0ULL) != (float) 0ULL)			/* 0 */
+    abort();
+  if (ull2f(~0ULL) != (float) ~0ULL)			/* 0xffffffff */
+    abort();
+  if (ull2f((~0ULL) >> 1) != (float) ((~0ULL) >> 1))	/* 0x7fffffff */
+    abort();
+  if (ull2f(~((~0ULL) >> 1)) != (float) ~((~0ULL) >> 1)) /* 0x80000000 */
+    abort();
+
+  if (ull2d(0ULL) != (double) 0ULL)			/* 0 */
+    abort();
+#if __HAVE_68881__
+  /* Some 68881 targets return values in fp0, with excess precision.
+     But the compile-time conversion to double works correctly.  */
+  if (! dnear (ull2d(~0ULL), (double) ~0ULL))		/* 0xffffffff */
+    abort();
+  if (! dnear (ull2d((~0ULL) >> 1), (double) ((~0ULL) >> 1))) /* 0x7fffffff */
+    abort();
+#else
+  if (ull2d(~0ULL) != (double) ~0ULL)			/* 0xffffffff */
+    abort();
+  if (ull2d((~0ULL) >> 1) != (double) ((~0ULL) >> 1))	/* 0x7fffffff */
+    abort();
+#endif
+  if (ull2d(~((~0ULL) >> 1)) != (double) ~((~0ULL) >> 1)) /* 0x80000000 */
+    abort();
+
+  if (sll2f(0LL) != (float) 0LL)			/* 0 */
+    abort();
+  if (sll2f(~0LL) != (float) ~0LL)			/* 0xffffffff */
+    abort();
+  if (! fnear (sll2f((long long int)((~0ULL) >> 1)), (float)(long long int)((~0ULL) >> 1))) /* 0x7fffffff */
+    abort();
+  if (sll2f((long long int)(~((~0ULL) >> 1))) != (float)(long long int)~((~0ULL) >> 1)) /* 0x80000000 */
+    abort();
+
+  if (sll2d(0LL) != (double) 0LL)			/* 0 */
+    abort();
+  if (sll2d(~0LL) != (double) ~0LL)			/* 0xffffffff */
+    abort();
+  if (!dnear (sll2d((long long int)((~0ULL) >> 1)), (double)(long long int)((~0ULL) >> 1))) /* 0x7fffffff */
+    abort();
+  if (! dnear (sll2d((long long int)~((~0ULL) >> 1)), (double)(long long int)~((~0ULL) >> 1))) /* 0x80000000 */
+    abort();
+}
+#endif
+
+unsigned int
+f2u(float f)
+{
+  return (unsigned) f;
+}
+
+unsigned int
+d2u(double d)
+{
+  return (unsigned) d;
+}
+
+int
+f2s(float f)
+{
+  return (int) f;
+}
+
+int
+d2s(double d)
+{
+  return (int) d;
+}
+
+test_float_to_integer()
+{
+  if (f2u(0.0) != 0)
+    abort();
+  if (f2u(0.999) != 0)
+    abort();
+  if (f2u(1.0) != 1)
+    abort();
+  if (f2u(1.99) != 1)
+    abort();
+  if (f2u((float) ((~0U) >> 1)) != (~0U) >> 1 &&	/* 0x7fffffff */
+      f2u((float) ((~0U) >> 1)) != ((~0U) >> 1) + 1)
+    abort();
+  if (f2u((float) ~((~0U) >> 1)) != ~((~0U) >> 1))	/* 0x80000000 */
+    abort();
+
+ /* CYGNUS LOCAL -- amylaar/32bit doubles */
+ /* These tests require double precision, so for hosts that don't offer
+    that much precision, just ignore these test.  */
+ if (sizeof (double) >= 8) {
+ /* END CYGNUS LOCAL -- amylaar/32bit doubles */
+  if (d2u(0.0) != 0)
+    abort();
+  if (d2u(0.999) != 0)
+    abort();
+  if (d2u(1.0) != 1)
+    abort();
+  if (d2u(1.99) != 1)
+    abort();
+  if (d2u((double) (~0U)) != ~0U)			/* 0xffffffff */
+    abort();
+  if (d2u((double) ((~0U) >> 1)) != (~0U) >> 1)		/* 0x7fffffff */
+    abort();
+  if (d2u((double) ~((~0U) >> 1)) != ~((~0U) >> 1))	/* 0x80000000 */
+    abort();
+ /* CYGNUS LOCAL -- amylaar/32bit doubles */
+ }
+ /* END CYGNUS LOCAL -- amylaar/32bit doubles */
+
+
+  if (f2s(0.0) != 0)
+    abort();
+  if (f2s(0.999) != 0)
+    abort();
+  if (f2s(1.0) != 1)
+    abort();
+  if (f2s(1.99) != 1)
+    abort();
+  if (f2s(-0.999) != 0)
+    abort();
+  if (f2s(-1.0) != -1)
+    abort();
+  if (f2s(-1.99) != -1)
+    abort();
+  if (f2s((float)(int)~((~0U) >> 1)) != (int)~((~0U) >> 1)) /* 0x80000000 */
+    abort();
+
+ /* CYGNUS LOCAL -- amylaar/32bit doubles */
+ /* These tests require double precision, so for hosts that don't offer
+    that much precision, just ignore these test.  */
+ if (sizeof (double) >= 8) {
+ /* END CYGNUS LOCAL -- amylaar/32bit doubles */
+  if (d2s(0.0) != 0)
+    abort();
+  if (d2s(0.999) != 0)
+    abort();
+  if (d2s(1.0) != 1)
+    abort();
+  if (d2s(1.99) != 1)
+    abort();
+  if (d2s(-0.999) != 0)
+    abort();
+  if (d2s(-1.0) != -1)
+    abort();
+  if (d2s(-1.99) != -1)
+    abort();
+  if (d2s((double) ((~0U) >> 1)) != (~0U) >> 1)		/* 0x7fffffff */
+    abort();
+  if (d2s((double)(int)~((~0U) >> 1)) != (int)~((~0U) >> 1)) /* 0x80000000 */
+    abort();
+ /* CYGNUS LOCAL -- amylaar/32bit doubles */
+ }
+ /* END CYGNUS LOCAL -- amylaar/32bit doubles */
+}
+
+#if __GNUC__
+unsigned long long int
+f2ull(float f)
+{
+  return (unsigned long long int) f;
+}
+
+unsigned long long int
+d2ull(double d)
+{
+  return (unsigned long long int) d;
+}
+
+long long int
+f2sll(float f)
+{
+  return (long long int) f;
+}
+
+long long int
+d2sll(double d)
+{
+  return (long long int) d;
+}
+
+test_float_to_longlong_integer()
+{
+  if (f2ull(0.0) != 0LL)
+    abort();
+  if (f2ull(0.999) != 0LL)
+    abort();
+  if (f2ull(1.0) != 1LL)
+    abort();
+  if (f2ull(1.99) != 1LL)
+    abort();
+  if (f2ull((float) ((~0ULL) >> 1)) != (~0ULL) >> 1 &&	/* 0x7fffffff */
+      f2ull((float) ((~0ULL) >> 1)) != ((~0ULL) >> 1) + 1)
+    abort();
+  if (f2ull((float) ~((~0ULL) >> 1)) != ~((~0ULL) >> 1)) /* 0x80000000 */
+    abort();
+
+  if (d2ull(0.0) != 0LL)
+    abort();
+  if (d2ull(0.999) != 0LL)
+    abort();
+  if (d2ull(1.0) != 1LL)
+    abort();
+  if (d2ull(1.99) != 1LL)
+    abort();
+  if (d2ull((double) ((~0ULL) >> 1)) != (~0ULL) >> 1 &&	/* 0x7fffffff */
+      d2ull((double) ((~0ULL) >> 1)) != ((~0ULL) >> 1) + 1)
+    abort();
+  if (d2ull((double) ~((~0ULL) >> 1)) != ~((~0ULL) >> 1)) /* 0x80000000 */
+    abort();
+
+
+  if (f2sll(0.0) != 0LL)
+    abort();
+  if (f2sll(0.999) != 0LL)
+    abort();
+  if (f2sll(1.0) != 1LL)
+    abort();
+  if (f2sll(1.99) != 1LL)
+    abort();
+  if (f2sll(-0.999) != 0LL)
+    abort();
+  if (f2sll(-1.0) != -1LL)
+    abort();
+  if (f2sll(-1.99) != -1LL)
+    abort();
+  if (f2sll((float)(long long int)~((~0ULL) >> 1)) != (long long int)~((~0ULL) >> 1)) /* 0x80000000 */
+    abort();
+
+  if (d2sll(0.0) != 0LL)
+    abort();
+  if (d2sll(0.999) != 0LL)
+    abort();
+  if (d2sll(1.0) != 1LL)
+    abort();
+  if (d2sll(1.99) != 1LL)
+    abort();
+  if (d2sll(-0.999) != 0LL)
+    abort();
+  if (d2sll(-1.0) != -1LL)
+    abort();
+  if (d2sll(-1.99) != -1LL)
+    abort();
+  if (d2sll((double)(long long int)~((~0ULL) >> 1)) != (long long int)~((~0ULL) >> 1)) /* 0x80000000 */
+    abort();
+}
+#endif
+
+main()
+{
+  test_integer_to_float();
+  test_float_to_integer();
+#if __GNUC__
+  test_longlong_integer_to_float();
+  test_float_to_longlong_integer();
+#endif
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/cvt-1.c b/gcc/testsuite/gcc.c-torture/execute/cvt-1.c
new file mode 100644
index 00000000000..d7c2b33fde1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/cvt-1.c
@@ -0,0 +1,30 @@
+/* CYGNUS LOCAL -- meissner/16 bit ints */
+static inline long
+g1 (double x)
+{
+  return (double) (long) x;
+}
+
+long
+g2 (double f)
+{
+  return f;
+}
+
+double
+f (long i)
+{
+  if (g1 (i) != g2 (i))
+    abort ();
+  return g2 (i);
+}
+
+main ()
+{
+  if (f (123456789L) != 123456789L)
+    abort ();
+  if (f (123456789L) != g2 (123456789L))
+    abort ();
+  exit (0);
+}
+/* END CYGNUS LOCAL -- meissner/16 bit ints */
diff --git a/gcc/testsuite/gcc.c-torture/execute/cvt-1.x b/gcc/testsuite/gcc.c-torture/execute/cvt-1.x
new file mode 100644
index 00000000000..997c8650c00
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/cvt-1.x
@@ -0,0 +1,7 @@
+# This doesn't work on d10v if ints are not 32 bits
+
+if { [istarget "d10v-*-*"] && ! [string-match "*-mint32*" $CFLAGS] } {
+	set torture_execute_xfail "d10v-*-*"
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/dbra-1.c b/gcc/testsuite/gcc.c-torture/execute/dbra-1.c
new file mode 100644
index 00000000000..20ae8988ec8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/dbra-1.c
@@ -0,0 +1,95 @@
+f1 (a)
+     long a;
+{
+  int i;
+  for (i = 0; i < 10; i++)
+    {
+      if (--a == -1)
+	return i;
+    }
+  return -1;
+}
+
+f2 (a)
+     long a;
+{
+  int i;
+  for (i = 0; i < 10; i++)
+    {
+      if (--a != -1)
+	return i;
+    }
+  return -1;
+}
+
+f3 (a)
+     long a;
+{
+  int i;
+  for (i = 0; i < 10; i++)
+    {
+      if (--a == 0)
+	return i;
+    }
+  return -1;
+}
+
+f4 (a)
+     long a;
+{
+  int i;
+  for (i = 0; i < 10; i++)
+    {
+      if (--a != 0)
+	return i;
+    }
+  return -1;
+}
+
+f5 (a)
+     long a;
+{
+  int i;
+  for (i = 0; i < 10; i++)
+    {
+      if (++a == 0)
+	return i;
+    }
+  return -1;
+}
+
+f6 (a)
+     long a;
+{
+  int i;
+  for (i = 0; i < 10; i++)
+    {
+      if (++a != 0)
+	return i;
+    }
+  return -1;
+}
+
+
+main()
+{
+  if (f1 (5L) != 5)
+    abort ();
+  if (f2 (1L) != 0)
+    abort ();
+  if (f2 (0L) != 1)
+    abort ();
+  if (f3 (5L) != 4)
+    abort ();
+  if (f4 (1L) != 1)
+    abort ();
+  if (f4 (0L) != 0)
+    abort ();
+  if (f5 (-5L) != 4)
+    abort ();
+  if (f6 (-1L) != 1)
+    abort ();
+  if (f6 (0L) != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/divconst-1.c b/gcc/testsuite/gcc.c-torture/execute/divconst-1.c
new file mode 100644
index 00000000000..ce9dd60a8e8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/divconst-1.c
@@ -0,0 +1,21 @@
+typedef struct
+{
+  unsigned a, b, c, d;
+} t1;
+
+f (t1 *ps)
+{
+    ps->a = 10000;
+    ps->b = ps->a / 3;
+    ps->c = 10000;
+    ps->d = ps->c / 3;
+}
+
+main ()
+{
+  t1 s;
+  f (&s);
+  if (s.a != 10000 || s.b != 3333 || s.c != 10000 || s.d != 3333)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/divconst-2.c b/gcc/testsuite/gcc.c-torture/execute/divconst-2.c
new file mode 100644
index 00000000000..d3adaf3a0af
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/divconst-2.c
@@ -0,0 +1,12 @@
+long
+f (long x)
+{
+  return x / (-0x7fffffffL - 1L);
+}
+
+main ()
+{
+  if (f (-1L) != 0L || f (0x7fffffffL) != 0L || f (-0x7fffffffL - 1L) != 1l)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/divconst-3.c b/gcc/testsuite/gcc.c-torture/execute/divconst-3.c
new file mode 100644
index 00000000000..ddd687cbcfd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/divconst-3.c
@@ -0,0 +1,12 @@
+long long
+f (long long x)
+{
+  return x / 10000000000LL;
+}
+
+main ()
+{
+  if (f (10000000000LL) != 1 || f (100000000000LL) != 10)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/divmod-1.c b/gcc/testsuite/gcc.c-torture/execute/divmod-1.c
new file mode 100644
index 00000000000..ade019c884e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/divmod-1.c
@@ -0,0 +1,72 @@
+div1 (x)
+     signed char x;
+{
+  return x / -1;
+}
+
+div2 (x)
+     signed short x;
+{
+  return x / -1;
+}
+
+div3 (x, y)
+     signed char x;
+     signed char y;
+{
+  return x / y;
+}
+
+div4 (x, y)
+     signed short x;
+     signed short y;
+{
+  return x / y;
+}
+
+mod1 (x)
+     signed char x;
+{
+  return x % -1;
+}
+
+mod2 (x)
+     signed short x;
+{
+  return x % -1;
+}
+
+mod3 (x, y)
+     signed char x;
+     signed char y;
+{
+  return x % y;
+}
+
+mod4 (x, y)
+     signed short x;
+     signed short y;
+{
+  return x % y;
+}
+
+main ()
+{
+  if (div1 (-(1 << 7)) != 1 << 7)
+    abort ();
+  if (div2 (-(1 << 15)) != 1 << 15)
+    abort ();
+  if (div3 (-(1 << 7), -1) != 1 << 7)
+    abort ();
+  if (div4 (-(1 << 15), -1) != 1 << 15)
+    abort ();
+  if (mod1 (-(1 << 7)) != 0)
+    abort ();
+  if (mod2 (-(1 << 15)) != 0)
+    abort ();
+  if (mod3 (-(1 << 7), -1) != 0)
+    abort ();
+  if (mod4 (-(1 << 15), -1) != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/enum-1.c b/gcc/testsuite/gcc.c-torture/execute/enum-1.c
new file mode 100644
index 00000000000..381e354918c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/enum-1.c
@@ -0,0 +1,43 @@
+typedef enum
+{
+  END = -1,
+  EMPTY = (1 << 8 ) ,
+  BACKREF,
+  BEGLINE,
+  ENDLINE,
+  BEGWORD,
+  ENDWORD,
+  LIMWORD,
+  NOTLIMWORD,
+  QMARK,
+  STAR,
+  PLUS,
+  REPMN,
+  CAT,
+  OR,
+  ORTOP,
+  LPAREN,
+  RPAREN,
+  CSET
+} token;
+
+static token tok;
+
+static int
+atom ()
+{
+  if ((tok >= 0 && tok < (1 << 8 ) ) || tok >= CSET || tok == BACKREF
+      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
+      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)
+    return 1;
+  else
+    return 0;
+}
+
+main ()
+{
+  tok = 0;
+  if (atom () != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/execute.exp b/gcc/testsuite/gcc.c-torture/execute/execute.exp
new file mode 100644
index 00000000000..8c896cb3e15
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/execute.exp
@@ -0,0 +1,46 @@
+# Copyright (C) 1991, 1992, 1993, 1995, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+# Modified and maintained by Jeffrey Wheat (cassidy@cygnus.com)
+
+#
+# These tests come from Torbjorn Granlund (tege@cygnus.com)
+# C torture test suite.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+
+#
+# main test loop
+#
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.c]] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $src] then {
+	continue
+    }
+
+    c-torture-execute $src
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/func-ptr-1.c b/gcc/testsuite/gcc.c-torture/execute/func-ptr-1.c
new file mode 100644
index 00000000000..55f0e10660f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/func-ptr-1.c
@@ -0,0 +1,16 @@
+static double f (float a);
+static double (*fp) (float a);
+
+main ()
+{
+  fp = f;
+  if (fp ((float) 1) != 1.0)
+    abort ();
+  exit (0);
+}
+
+static double
+f (float a)
+{
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/gofast.c b/gcc/testsuite/gcc.c-torture/execute/gofast.c
new file mode 100644
index 00000000000..f55ced22073
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/gofast.c
@@ -0,0 +1,99 @@
+/* Program to test gcc's usage of the gofast library.  */
+
+/* The main guiding themes are to make it trivial to add test cases over time
+   and to make it easy for a program to parse the output to see if the right
+   libcalls are being made.  */
+
+#include <stdio.h>
+
+float fp_add (float a, float b) { return a + b; }
+float fp_sub (float a, float b) { return a - b; }
+float fp_mul (float a, float b) { return a * b; }
+float fp_div (float a, float b) { return a / b; }
+float fp_neg (float a) { return -a; }
+
+double dp_add (double a, double b) { return a + b; }
+double dp_sub (double a, double b) { return a - b; }
+double dp_mul (double a, double b) { return a * b; }
+double dp_div (double a, double b) { return a / b; }
+double dp_neg (double a) { return -a; }
+
+double fp_to_dp (float f) { return f; }
+float dp_to_fp (double d) { return d; }
+
+int eqsf2 (float a, float b) { return a == b; }
+int nesf2 (float a, float b) { return a != b; }
+int gtsf2 (float a, float b) { return a > b; }
+int gesf2 (float a, float b) { return a >= b; }
+int ltsf2 (float a, float b) { return a < b; }
+int lesf2 (float a, float b) { return a <= b; }
+
+int eqdf2 (double a, double b) { return a == b; }
+int nedf2 (double a, double b) { return a != b; }
+int gtdf2 (double a, double b) { return a > b; }
+int gedf2 (double a, double b) { return a >= b; }
+int ltdf2 (double a, double b) { return a < b; }
+int ledf2 (double a, double b) { return a <= b; }
+
+float floatsisf (int i) { return i; }
+double floatsidf (int i) { return i; }
+int fixsfsi (float f) { return f; }
+int fixdfsi (double d) { return d; }
+unsigned int fixunssfsi (float f) { return f; }
+unsigned int fixunsdfsi (double d) { return d; }
+
+int fail_count = 0;
+
+int
+fail (char *msg)
+{
+  fail_count++;
+  fprintf (stderr, "Test failed: %s\n", msg);
+}
+
+int
+main()
+{
+  if (fp_add (1, 1) != 2) fail ("fp_add 1+1");
+  if (fp_sub (3, 2) != 1) fail ("fp_sub 3-2");
+  if (fp_mul (2, 3) != 6) fail ("fp_mul 2*3");
+  if (fp_div (3, 2) != 1.5) fail ("fp_div 3/2");
+  if (fp_neg (1) != -1) fail ("fp_neg 1");
+
+  if (dp_add (1, 1) != 2) fail ("dp_add 1+1");
+  if (dp_sub (3, 2) != 1) fail ("dp_sub 3-2");
+  if (dp_mul (2, 3) != 6) fail ("dp_mul 2*3");
+  if (dp_div (3, 2) != 1.5) fail ("dp_div 3/2");
+  if (dp_neg (1) != -1) fail ("dp_neg 1");
+
+  if (fp_to_dp (1.5) != 1.5) fail ("fp_to_dp 1.5");
+  if (dp_to_fp (1.5) != 1.5) fail ("dp_to_fp 1.5");
+
+  if (floatsisf (1) != 1) fail ("floatsisf 1");
+  if (floatsidf (1) != 1) fail ("floatsidf 1");
+  if (fixsfsi (1.42) != 1) fail ("fixsfsi 1.42");
+  if (fixunssfsi (1.42) != 1) fail ("fixunssfsi 1.42");
+  if (fixdfsi (1.42) != 1) fail ("fixdfsi 1.42");
+  if (fixunsdfsi (1.42) != 1) fail ("fixunsdfsi 1.42");
+
+  if (eqsf2 (1, 1) == 0) fail ("eqsf2 1==1");
+  if (eqsf2 (1, 2) != 0) fail ("eqsf2 1==2");
+  if (nesf2 (1, 2) == 0) fail ("nesf2 1!=1");
+  if (nesf2 (1, 1) != 0) fail ("nesf2 1!=1");
+  if (gtsf2 (2, 1) == 0) fail ("gtsf2 2>1");
+  if (gtsf2 (1, 1) != 0) fail ("gtsf2 1>1");
+  if (gtsf2 (0, 1) != 0) fail ("gtsf2 0>1");
+  if (gesf2 (2, 1) == 0) fail ("gesf2 2>=1");
+  if (gesf2 (1, 1) == 0) fail ("gesf2 1>=1");
+  if (gesf2 (0, 1) != 0) fail ("gesf2 0>=1");
+  if (ltsf2 (1, 2) == 0) fail ("ltsf2 1<2");
+  if (ltsf2 (1, 1) != 0) fail ("ltsf2 1<1");
+  if (ltsf2 (1, 0) != 0) fail ("ltsf2 1<0");
+  if (lesf2 (1, 2) == 0) fail ("lesf2 1<=2");
+  if (lesf2 (1, 1) == 0) fail ("lesf2 1<=1");
+  if (lesf2 (1, 0) != 0) fail ("lesf2 1<=0");
+
+  if (fail_count != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/920518-1.c b/gcc/testsuite/gcc.c-torture/execute/ieee/920518-1.c
new file mode 100644
index 00000000000..7f072b2981a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/920518-1.c
@@ -0,0 +1,8 @@
+unsigned u=2147483839;float f0=2147483648e0,f1=2147483904e0;
+main()
+{
+  float f=u;
+  if(f==f0)
+    abort();
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/920810-1.c b/gcc/testsuite/gcc.c-torture/execute/ieee/920810-1.c
new file mode 100644
index 00000000000..62d22940adc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/920810-1.c
@@ -0,0 +1,3 @@
+#include <stdio.h>
+double normalize(x)double x;{if(x==0)x=0;return x;}
+main(){char b[9];sprintf(b,"%g",normalize(-0.0));if(strcmp(b,"0"))abort();exit(0);}
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/930529-1.c b/gcc/testsuite/gcc.c-torture/execute/ieee/930529-1.c
new file mode 100644
index 00000000000..b96a3c06423
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/930529-1.c
@@ -0,0 +1,27 @@
+main ()
+{
+  union {
+    double d;
+    unsigned char c[8];
+  } d;
+
+  d.d = 1.0/7.0;
+
+  if (sizeof (char) * 8 == sizeof (double))
+    {
+      if (d.c[0] == 0x92 && d.c[1] == 0x24 && d.c[2] == 0x49 && d.c[3] == 0x92
+	  && d.c[4] == 0x24 && d.c[5] == 0x49 && d.c[6] == 0xc2 && d.c[7] == 0x3f)
+	exit (0);
+      if (d.c[7] == 0x92 && d.c[6] == 0x24 && d.c[5] == 0x49 && d.c[4] == 0x92
+	  && d.c[3] == 0x24 && d.c[2] == 0x49 && d.c[1] == 0xc2 && d.c[0] == 0x3f)
+	exit (0);
+#if defined __arm__ || defined __thumb__
+      if (d.c[4] == 0x92 && d.c[5] == 0x24 && d.c[6] == 0x49 && d.c[7] == 0x92
+	  && d.c[0] == 0x24 && d.c[1] == 0x49 && d.c[2] == 0xc2 && d.c[3] == 0x3f)
+	exit (0);
+#endif
+      abort ();
+    }
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/980619-1.c b/gcc/testsuite/gcc.c-torture/execute/ieee/980619-1.c
new file mode 100644
index 00000000000..0465ed51c8b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/980619-1.c
@@ -0,0 +1,23 @@
+	int main(void)
+	{
+		float reale = 1.0f;
+		float oneplus;
+		int i;
+	
+	 	if (sizeof (float) != 4)
+		  exit (0);
+
+		for (i = 0; ; i++)
+		{
+			oneplus = 1.0f + reale;
+			if (oneplus == 1.0f)
+				break;
+			reale=reale/2.0f;
+		}
+		/* Assumes ieee754 accurate arithmetic above.  */
+		if (i != 24)
+		  abort ();
+		else
+		  exit (0);
+	}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/980619-1.x b/gcc/testsuite/gcc.c-torture/execute/ieee/980619-1.x
new file mode 100644
index 00000000000..de72f0385c7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/980619-1.x
@@ -0,0 +1,11 @@
+set torture_eval_before_execute {
+
+    set compiler_conditional_xfail_data {
+        "ia32 fp rounding isn't pedantic" \
+        "i?86-*-*" \
+        { "-O3" "-O2" "-O1" "-Os"} \
+        { "" }
+        }    
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/Makefile.in b/gcc/testsuite/gcc.c-torture/execute/ieee/Makefile.in
new file mode 100644
index 00000000000..e6209dbc6c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+	-rm -f *.o *.diff *~ *.bad core *.x
+
+distclean:	clean
+	-rm -f Makefile config.status
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/configure.in b/gcc/testsuite/gcc.c-torture/execute/ieee/configure.in
new file mode 100644
index 00000000000..7d7078dbfd2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=execute.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/fp-cmp-1.c b/gcc/testsuite/gcc.c-torture/execute/ieee/fp-cmp-1.c
new file mode 100644
index 00000000000..4794efcb53b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/fp-cmp-1.c
@@ -0,0 +1,41 @@
+#include <signal.h>
+
+double nan = 1.0/0.0 - 1.0/0.0;
+double x = 1.0;
+
+void leave ()
+{
+  exit (0);
+}
+
+main ()
+{
+#if ! defined (__vax__) && ! defined (_CRAY)
+  /* Move this line earlier, for architectures (like alpha) that issue 
+     SIGFPE on the first comparisons. */
+#ifndef SIGNAL_SUPPRESS
+  /* Some machines catches a SIGFPE when a NaN is compared.
+     Let this test succeed o such machines.  */
+  signal (SIGFPE, leave);
+#endif
+  /* NaN is an IEEE unordered operand.  All these test should be false.  */
+  if (nan == nan)
+    abort ();
+  if (nan != x)
+    x = 1.0;
+  else
+    abort ();
+
+  if (nan < x)
+    abort ();
+  if (nan > x)
+    abort ();
+  if (nan <= x)
+    abort ();
+  if (nan >= x)
+    abort ();
+  if (nan == x)
+    abort ();
+#endif
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp b/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp
new file mode 100644
index 00000000000..903d5cef147
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp
@@ -0,0 +1,61 @@
+#
+# Expect driver script for GCC Regression Tests
+#   Copyright (C) 1993, 1996 Free Software Foundation
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+#
+# Written by Jeffrey Wheat (cassidy@cygnus.com)
+#
+
+#
+# These tests come from Torbjorn Granlund's (tege@cygnus.com)
+# C torture test suite, and other contributors.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+if [target_info exists ieee_multilib_flags] {
+    set additional_flags [target_info ieee_multilib_flags];
+} else {
+    set additional_flags "";
+}
+
+# We must use -ffloat-store to ensure that excess precision on some machines
+# does not cause problems
+lappend additional_flags "-ffloat-store"
+
+# load support procs
+load_lib c-torture.exp
+
+# initialize harness
+gcc_init
+
+#
+# main test loop
+#
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.c]] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $src] then {
+	continue
+    }
+
+    c-torture-execute $src $additional_flags
+}
+
+# All done.
+gcc_finish
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/minuszero.c b/gcc/testsuite/gcc.c-torture/execute/ieee/minuszero.c
new file mode 100644
index 00000000000..85715261d61
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/minuszero.c
@@ -0,0 +1,22 @@
+main ()
+{
+  union
+    {
+      double d;
+      unsigned short i[sizeof (double) / sizeof (short)];
+    } u;
+  int a = 0;
+  int b = -5;
+  int j;
+
+  u.d = (double) a / b;
+
+  /* Look for the right pattern, but be sloppy since
+     we don't know the byte order.  */
+  for (j = 0; j < sizeof (double) / sizeof (short); j++)
+    {
+      if (u.i[j] == 0x8000)
+	exit (0);
+    }
+  abort ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/mzero2.c b/gcc/testsuite/gcc.c-torture/execute/ieee/mzero2.c
new file mode 100644
index 00000000000..0da53d24737
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/mzero2.c
@@ -0,0 +1,58 @@
+/* Test IEEE +0/-0 rules */
+
+static double pzero = +0.0;
+static double nzero = -0.0;
+static double pinf  = +1.0 / 0.0;
+static double ninf  = -1.0 / 0.0;
+static double nan   =  0.0 / 0.0;
+
+void
+expect (double value, double expected)
+{
+  if (expected != expected)	/* expected value is Not a number */
+    {
+      if (value == value)	/* actual value is a number */
+	abort ();
+    }
+
+  else if (value != value)
+    abort ();			/* actual value is a NaN */
+
+  else if (memcmp ((void *)&value, (void *)&expected, sizeof (double)) != 0)
+    abort ();			/* values don't match */
+}
+
+main ()
+{
+  expect (pzero + pzero, pzero);
+  expect (pzero + nzero, pzero);
+  expect (nzero + pzero, pzero);
+  expect (nzero + nzero, nzero);
+
+  expect (pzero - pzero, pzero);
+  expect (pzero - nzero, pzero);
+  expect (nzero - pzero, nzero);
+  expect (nzero - nzero, pzero);
+
+  expect (pzero * pzero, pzero);
+  expect (pzero * nzero, nzero);
+  expect (nzero * pzero, nzero);
+  expect (nzero * nzero, pzero);
+
+  expect (+1.00 * pzero, pzero);
+  expect (-1.00 * pzero, nzero);
+  expect (+1.00 * nzero, nzero);
+  expect (-1.00 * nzero, pzero);
+
+  expect (pzero / pzero, nan);
+  expect (pzero / nzero, nan);
+  expect (nzero / pzero, nan);
+  expect (nzero / nzero, nan);
+
+  expect (+1.00 / pzero, pinf);
+  expect (-1.00 / pzero, ninf);
+  expect (+1.00 / nzero, ninf);
+  expect (-1.00 / nzero, pinf);
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/rbug.c b/gcc/testsuite/gcc.c-torture/execute/ieee/rbug.c
new file mode 100644
index 00000000000..a91a99e92e2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/rbug.c
@@ -0,0 +1,41 @@
+double d (unsigned long long k)
+{
+  double x;
+
+  x = (double) k;
+  return x;
+}
+
+float s (unsigned long long k)
+{
+  float x;
+
+  x = (float) k;
+  return x;
+}
+
+main ()
+{
+  unsigned long long int k;
+  double x;
+
+  /* CYGNUS LOCAL -- meissner/32bit doubles */
+  if (sizeof (double) >= 8)
+    {
+      k = 0x8693ba6d7d220401ULL;
+      x = d (k);
+      k = (unsigned long long) x;
+      if (k != 0x8693ba6d7d220800ULL)
+	abort ();
+    }
+  /* END CYGNUS LOCAL -- meissner/32bit doubles */
+
+  k = 0x8234508000000001ULL;
+  x = s (k);
+  k = (unsigned long long) x;
+  if (k != 0x8234510000000000ULL)
+    abort ();
+
+  exit (0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/rbug.x b/gcc/testsuite/gcc.c-torture/execute/ieee/rbug.x
new file mode 100644
index 00000000000..0ae0a35d315
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/rbug.x
@@ -0,0 +1,7 @@
+# This doesn't work on d10v if doubles are not 64 bits
+
+if { [istarget "d10v-*-*"] && ! [string-match "*-mdouble64*" $CFLAGS] } {
+	set torture_execute_xfail "d10v-*-*"
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/index-1.c b/gcc/testsuite/gcc.c-torture/execute/index-1.c
new file mode 100644
index 00000000000..b00090d834a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/index-1.c
@@ -0,0 +1,20 @@
+int a[] =
+{
+  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
+  10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
+  20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
+  30, 31, 32, 33, 34, 35, 36, 37, 38, 39
+};
+
+int
+f (long n)
+{
+  return a[n - 100000];
+}
+
+main ()
+{
+  if (f (100030L) != 30)
+    abort();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/inst-check.c b/gcc/testsuite/gcc.c-torture/execute/inst-check.c
new file mode 100644
index 00000000000..ff4b00d7868
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/inst-check.c
@@ -0,0 +1,14 @@
+#include <stdarg.h>
+
+f(m)
+{
+  int i,s=0;
+  for(i=0;i<m;i++)
+    s+=i;
+  return s;
+}
+
+main()
+{
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/int-compare.c b/gcc/testsuite/gcc.c-torture/execute/int-compare.c
new file mode 100644
index 00000000000..017a8cc3f15
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/int-compare.c
@@ -0,0 +1,108 @@
+#include <limits.h>
+
+gt (a, b)
+{
+  return a > b;
+}
+
+ge (a, b)
+{
+  return a >= b;
+}
+
+lt (a, b)
+{
+  return a < b;
+}
+
+le (a, b)
+{
+  return a <= b;
+}
+
+void
+true (c)
+{
+  if (!c)
+    abort();
+}
+
+void
+false (c)
+{
+  if (c)
+    abort();
+}
+
+f ()
+{
+  true (gt (2, 1));
+  false (gt (1, 2));
+
+  true (gt (INT_MAX, 0));
+  false (gt (0, INT_MAX));
+  true (gt (INT_MAX, 1));
+  false (gt (1, INT_MAX));
+
+  false (gt (INT_MIN, 0));
+  true (gt (0, INT_MIN));
+  false (gt (INT_MIN, 1));
+  true (gt (1, INT_MIN));
+
+  true (gt (INT_MAX, INT_MIN));
+  false (gt (INT_MIN, INT_MAX));
+
+  true (ge (2, 1));
+  false (ge (1, 2));
+
+  true (ge (INT_MAX, 0));
+  false (ge (0, INT_MAX));
+  true (ge (INT_MAX, 1));
+  false (ge (1, INT_MAX));
+
+  false (ge (INT_MIN, 0));
+  true (ge (0, INT_MIN));
+  false (ge (INT_MIN, 1));
+  true (ge (1, INT_MIN));
+
+  true (ge (INT_MAX, INT_MIN));
+  false (ge (INT_MIN, INT_MAX));
+
+  false (lt (2, 1));
+  true (lt (1, 2));
+
+  false (lt (INT_MAX, 0));
+  true (lt (0, INT_MAX));
+  false (lt (INT_MAX, 1));
+  true (lt (1, INT_MAX));
+
+  true (lt (INT_MIN, 0));
+  false (lt (0, INT_MIN));
+  true (lt (INT_MIN, 1));
+  false (lt (1, INT_MIN));
+
+  false (lt (INT_MAX, INT_MIN));
+  true (lt (INT_MIN, INT_MAX));
+
+  false (le (2, 1));
+  true (le (1, 2));
+
+  false (le (INT_MAX, 0));
+  true (le (0, INT_MAX));
+  false (le (INT_MAX, 1));
+  true (le (1, INT_MAX));
+
+  true (le (INT_MIN, 0));
+  false (le (0, INT_MIN));
+  true (le (INT_MIN, 1));
+  false (le (1, INT_MIN));
+
+  false (le (INT_MAX, INT_MIN));
+  true (le (INT_MIN, INT_MAX));
+}
+
+main ()
+{
+  f ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-1.c b/gcc/testsuite/gcc.c-torture/execute/loop-1.c
new file mode 100644
index 00000000000..81aeeb6b392
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-1.c
@@ -0,0 +1,18 @@
+main ()
+{
+  int i, j, k[3];
+
+  j = 0;
+  for (i=0; i < 3; i++)
+    {
+      k[i] = j++;
+    }
+
+  for (i=2; i >= 0; i--)
+    {
+      if (k[i] != i)
+	abort ();
+    }
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-2.c b/gcc/testsuite/gcc.c-torture/execute/loop-2.c
new file mode 100644
index 00000000000..3227734fbf8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-2.c
@@ -0,0 +1,17 @@
+int a[2];
+
+f (b)
+{
+  unsigned int i;
+  for (i = 0; i < b; i++)
+    a[i] = i - 2;
+}
+
+main ()
+{
+  a[0] = a[1] = 0;
+  f (2);
+  if (a[0] != -2 || a[1] != -1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-2b.c b/gcc/testsuite/gcc.c-torture/execute/loop-2b.c
new file mode 100644
index 00000000000..7f67bcd639d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-2b.c
@@ -0,0 +1,22 @@
+#include <limits.h>
+
+int a[2];
+
+f (int i)
+{
+  for (; i < INT_MAX; i++)
+    {
+      a[i] = -2;
+      if (&a[i] == &a[1])
+	break;
+    }
+}
+
+main ()
+{
+  a[0] = a[1] = 0;
+  f (0);
+  if (a[0] != -2 || a[1] != -2)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-2c.c b/gcc/testsuite/gcc.c-torture/execute/loop-2c.c
new file mode 100644
index 00000000000..9facf3bfd92
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-2c.c
@@ -0,0 +1,23 @@
+int a[2];
+
+__inline__ f (b, o)
+{
+  unsigned int i;
+  int *p;
+  for (p = &a[b], i = b; --i < ~0; )
+    *--p = i * 3 + o;
+}
+
+g(int b)
+{
+  f (b, (int)a);
+}
+
+main ()
+{
+  a[0] = a[1] = 0;
+  g (2);
+  if (a[0] != (int)a || a[1] != (int)a + 3)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-2d.c b/gcc/testsuite/gcc.c-torture/execute/loop-2d.c
new file mode 100644
index 00000000000..19272bf0183
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-2d.c
@@ -0,0 +1,18 @@
+int a[2];
+
+f (b)
+{
+  unsigned int i;
+  int *p;
+  for (p = &a[b], i = b; --i < ~0; )
+    *--p = i * 3 + (int)a;
+}
+
+main ()
+{
+  a[0] = a[1] = 0;
+  f (2);
+  if (a[0] != (int)a || a[1] != (int)a + 3)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-2e.c b/gcc/testsuite/gcc.c-torture/execute/loop-2e.c
new file mode 100644
index 00000000000..b6ee6501501
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-2e.c
@@ -0,0 +1,60 @@
+#include <limits.h>
+
+#ifdef __unix__ /* ??? Is that good enough? */
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef MAP_ANON
+#ifdef MAP_ANONYMOUS
+#define MAP_ANON MAP_ANONYMOUS
+#else
+#define MAP_ANON MAP_FILE
+#endif
+#endif
+#ifndef MAP_FILE
+#define MAP_FILE 0
+#endif
+#ifndef MAP_FIXED
+#define MAP_FIXED 0
+#endif
+#endif
+
+#define MAP_START (void *)0x7fff8000
+#define MAP_LEN 0x10000
+
+#define OFFSET (MAP_LEN/2 - 2 * sizeof (int));
+
+f (int *p, int **q)
+{
+  int i;
+  for (i = 0; i < 40; i++)
+    {
+      *q++ = &p[i];
+    }
+}
+
+main ()
+{
+#ifdef MAP_ANON
+  void *p;
+  int *q[40];
+  int dev_zero;
+
+  dev_zero = open ("/dev/zero", O_RDONLY);
+  /* -1 is OK when we have MAP_ANON; else mmap will flag an error.  */
+  if (INT_MAX != 0x7fffffffL || sizeof (char *) != sizeof (int))
+    exit (0);
+  p = mmap (MAP_START, MAP_LEN, PROT_READ|PROT_WRITE,
+	    MAP_ANON|MAP_FIXED|MAP_PRIVATE, dev_zero, 0);
+  if (p != (void *)-1)
+    {
+      p = (char *)p + OFFSET;
+      q[39] = 0;
+      f (p, q);
+      if (q[39] != (int *)p + 39)
+	abort ();
+    }
+#endif
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-2e.x b/gcc/testsuite/gcc.c-torture/execute/loop-2e.x
new file mode 100644
index 00000000000..e68b8fbb8d2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-2e.x
@@ -0,0 +1,9 @@
+# This doesn't work on m68k-motorola-sysv
+# It also doesn't work on m88k-motorola-sysv3
+
+global target_triplet
+if { [istarget "m68k-motorola-sysv"] || [istarget "m88k-motorola-sysv3"] } {
+      set torture_compile_xfail "$target_triplet"
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-2f.c b/gcc/testsuite/gcc.c-torture/execute/loop-2f.c
new file mode 100644
index 00000000000..9f544b9fcbd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-2f.c
@@ -0,0 +1,63 @@
+#include <limits.h>
+
+#ifdef __unix__ /* ??? Is that good enough? */
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef MAP_ANON
+#ifdef MAP_ANONYMOUS
+#define MAP_ANON MAP_ANONYMOUS
+#else
+#define MAP_ANON MAP_FILE
+#endif
+#endif
+#ifndef MAP_FILE
+#define MAP_FILE 0
+#endif
+#ifndef MAP_FIXED
+#define MAP_FIXED 0
+#endif
+#endif
+
+#define MAP_START (void *)0x7fff8000
+#define MAP_LEN 0x10000
+
+#define OFFSET (MAP_LEN/2 - 2 * sizeof (char));
+
+f (int s, char *p)
+{
+  int i;
+  for (i = s; i >= 0 && &p[i] < &p[40]; i++)
+    {
+      p[i] = -2;
+    }
+}
+
+main ()
+{
+#ifdef MAP_ANON
+  char *p;
+  int dev_zero;
+
+  dev_zero = open ("/dev/zero", O_RDONLY);
+  /* -1 is OK when we have MAP_ANON; else mmap will flag an error.  */
+  if (INT_MAX != 0x7fffffffL || sizeof (char *) != sizeof (int))
+    exit (0);
+  p = mmap (MAP_START, MAP_LEN, PROT_READ|PROT_WRITE,
+	    MAP_ANON|MAP_FIXED|MAP_PRIVATE, dev_zero, 0);
+  if (p != (char *)-1)
+    {
+      p += OFFSET;
+      p[39] = 0;
+      f (0, p);
+      if (p[39] != (char)-2)
+	abort ();
+      p[39] = 0;
+      f (-1, p);
+      if (p[39] != 0)
+	abort ();
+    }
+#endif
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-2f.x b/gcc/testsuite/gcc.c-torture/execute/loop-2f.x
new file mode 100644
index 00000000000..e68b8fbb8d2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-2f.x
@@ -0,0 +1,9 @@
+# This doesn't work on m68k-motorola-sysv
+# It also doesn't work on m88k-motorola-sysv3
+
+global target_triplet
+if { [istarget "m68k-motorola-sysv"] || [istarget "m88k-motorola-sysv3"] } {
+      set torture_compile_xfail "$target_triplet"
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-2g.c b/gcc/testsuite/gcc.c-torture/execute/loop-2g.c
new file mode 100644
index 00000000000..8792dbf586b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-2g.c
@@ -0,0 +1,63 @@
+#include <limits.h>
+
+#ifdef __unix__ /* ??? Is that good enough? */
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifndef MAP_ANON
+#ifdef MAP_ANONYMOUS
+#define MAP_ANON MAP_ANONYMOUS
+#else
+#define MAP_ANON MAP_FILE
+#endif
+#endif
+#ifndef MAP_FILE
+#define MAP_FILE 0
+#endif
+#ifndef MAP_FIXED
+#define MAP_FIXED 0
+#endif
+#endif
+
+#define MAP_START (void *)0x7fff8000
+#define MAP_LEN 0x10000
+
+#define OFFSET (MAP_LEN/2 - 2 * sizeof (char));
+
+f (int s, char *p)
+{
+  int i;
+  for (i = s; &p[i] < &p[40] && i >= 0; i++)
+    {
+      p[i] = -2;
+    }
+}
+
+main ()
+{
+#ifdef MAP_ANON
+  char *p;
+  int dev_zero;
+
+  dev_zero = open ("/dev/zero", O_RDONLY);
+  /* -1 is OK when we have MAP_ANON; else mmap will flag an error.  */
+  if (INT_MAX != 0x7fffffffL || sizeof (char *) != sizeof (int))
+    exit (0);
+  p = mmap (MAP_START, MAP_LEN, PROT_READ|PROT_WRITE,
+	    MAP_ANON|MAP_FIXED|MAP_PRIVATE, dev_zero, 0);
+  if (p != (char *)-1)
+    {
+      p += OFFSET;
+      p[39] = 0;
+      f (0, p);
+      if (p[39] != (char)-2)
+	abort ();
+      p[39] = 0;
+      f (-1, p);
+      if (p[39] != 0)
+	abort ();
+    }
+#endif
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-2g.x b/gcc/testsuite/gcc.c-torture/execute/loop-2g.x
new file mode 100644
index 00000000000..e68b8fbb8d2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-2g.x
@@ -0,0 +1,9 @@
+# This doesn't work on m68k-motorola-sysv
+# It also doesn't work on m88k-motorola-sysv3
+
+global target_triplet
+if { [istarget "m68k-motorola-sysv"] || [istarget "m88k-motorola-sysv3"] } {
+      set torture_compile_xfail "$target_triplet"
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-3.c b/gcc/testsuite/gcc.c-torture/execute/loop-3.c
new file mode 100644
index 00000000000..e314a01b1f1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-3.c
@@ -0,0 +1,27 @@
+#include <limits.h>
+
+int n = 0;
+
+g (i)
+{
+  n++;
+}
+
+f (m)
+{
+  int i;
+  i = m;
+  do
+    {
+      g (i * INT_MAX / 2);
+    }
+  while (--i > 0);
+}
+
+main ()
+{
+  f (4);
+  if (n != 4)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-3b.c b/gcc/testsuite/gcc.c-torture/execute/loop-3b.c
new file mode 100644
index 00000000000..3de322cf146
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-3b.c
@@ -0,0 +1,28 @@
+#include <limits.h>
+
+int n = 0;
+
+g (i)
+{
+  n++;
+}
+
+f (m)
+{
+  int i;
+  i = m;
+  do
+    {
+      g (i * 4);
+      i -= INT_MAX / 8;
+    }
+  while (i > 0);
+}
+
+main ()
+{
+  f (INT_MAX/8*4);
+  if (n != 4)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-3c.c b/gcc/testsuite/gcc.c-torture/execute/loop-3c.c
new file mode 100644
index 00000000000..bc74c2e6d9b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-3c.c
@@ -0,0 +1,31 @@
+#include <limits.h>
+
+void * a[255];
+
+f (m)
+{
+  int i;
+  int sh = 0x100;
+  i = m;
+  do
+    {
+      a[sh >>= 1] = ((unsigned)i << 3)  + (char*)a;
+      i += 4;
+    }
+  while (i < INT_MAX/2 + 1 + 4 * 4);
+}
+
+main ()
+{
+  a[0x10] = 0;
+  a[0x08] = 0;
+  f (INT_MAX/2 + INT_MAX/4 + 2);
+  if (a[0x10] || a[0x08])
+    abort ();
+  a[0x10] = 0;
+  a[0x08] = 0;
+  f (INT_MAX/2 + 1);
+  if (! a[0x10] || a[0x08])
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-4.c b/gcc/testsuite/gcc.c-torture/execute/loop-4.c
new file mode 100644
index 00000000000..b308aa27689
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-4.c
@@ -0,0 +1,16 @@
+int
+f()
+{
+  int j = 1;
+  long i;
+  for (i = -0x70000000L; i < 0x60000000L; i += 0x10000000L) j <<= 1;
+  return j;
+}
+
+int
+main ()
+{
+  if (f () != 8192)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/loop-4b.c b/gcc/testsuite/gcc.c-torture/execute/loop-4b.c
new file mode 100644
index 00000000000..eaf7f30c4c5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/loop-4b.c
@@ -0,0 +1,21 @@
+int
+f()
+{
+  int j = 1;
+  long i;
+  i = 0x60000000L;
+  do
+    {
+      j <<= 1;
+      i += 0x10000000L;
+    } while (i < -0x60000000L);
+  return j;
+}
+
+int
+main ()
+{
+  if (f () != 2)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/blkarg.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/blkarg.c
new file mode 100644
index 00000000000..4f448d661d6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/blkarg.c
@@ -0,0 +1,75 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup () NOCHECK; */
+
+#include "driver.h"
+
+/* Test permissions of BLKmode arguments constructed purely on the
+   stack.
+
+   Maybe we can't guarantee that we'll always wind up with stack args,
+   but if we don't, they're in registers, and permissions should just
+   always yield success.  So while this test may not be effective on
+   all platforms, failure probably does indicate a real bug.
+
+   Note that because of the implementation, we do want to test BLKmode
+   arguments that live purely on the stack and are constructed there.
+   We want to test other situations of function arguments, of course,
+   but don't assume this case would be covered by using one monster
+   argument that is read from memory (including using constructor
+   syntax but constant values), or may live partially in registers.  */
+
+int expect_error = 0;
+
+/* Must be BLKmode.  Using only two fields gets TImode on Alpha.  */
+struct S
+{
+  unsigned long long ll;
+  long               xx;
+  long               yy;
+};
+
+unsigned long long   x = 0x12345689ULL;
+#define I2	     42
+
+static int first_time = 1;
+
+/* Leading ten arguments force struct S onto the stack on both Alpha and MIPS.  */
+int
+foo (int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10,
+     struct S s)
+{
+  if (a1 != 1 || a2 != 2 || a3 != 3 || a4 != 4 || a5 != 5 || a6 != 6 || a7 != 7
+      || a8 != 8 || a9 !=9 || a10 != 10)
+    abort ();
+  
+  if (first_time)
+    {
+      if (s.ll != x || s.xx != I2 || s.yy != 0)
+	abort ();
+      
+      first_time = 0;
+    }
+  else
+    {
+      if (s.ll != 0 || s.xx != 0 || s.yy != 0)
+	abort ();
+    }
+  
+  return 0;
+}
+
+void
+test ()
+{
+  foo (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, (struct S) { x, I2 });
+  foo (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, (struct S) { 0 });
+}
+
+void
+setup () /* NOCHECK */
+{
+  mark_region (&x, sizeof (x), ACCESS_RO);
+  mark_region (&first_time, sizeof (first_time), ACCESS_RW);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/blkarg.x b/gcc/testsuite/gcc.c-torture/execute/memcheck/blkarg.x
new file mode 100644
index 00000000000..52b53fe2163
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/blkarg.x
@@ -0,0 +1,9 @@
+# The memeory checking code does not mark the stack as readable or writable
+# so this test fails.  Ideally the memory checking library ought to 
+# cooperate with the host OS to mark the stack as it is used or individual
+# function prologues and epilogues ought to mark their pieces of stack as 
+# writable and readable-after-written.
+
+set torture_execute_xfail "*-*-*"
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/driver.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/driver.c
new file mode 100644
index 00000000000..1da22e7a222
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/driver.c
@@ -0,0 +1,272 @@
+/* GNU C dependencies:
+   Checker support hooks
+   ISO C 9x array element initialization
+   void-pointer arithmetic */
+
+#include "driver.h"
+
+int verbose = 0;
+int debug = 0;
+int bad_accesses = 0;
+
+const char *const memory_use_strings[] =
+{
+#define INIT(x)		[x] = #x
+  INIT (MEMORY_USE_BAD),
+  INIT (MEMORY_USE_DONT),
+  INIT (MEMORY_USE_RO),
+  INIT (MEMORY_USE_RW),
+  INIT (MEMORY_USE_TW),
+  INIT (MEMORY_USE_WO),
+#undef INIT
+};
+
+/* This won't be used for any really huge test cases, so a simple
+   linked list is adequate.  We won't even worry about overlapping
+   regions; the matching entry that comes up first wins.  */
+const char *const access_mode_strings[] =
+{
+  "none", "ro", "wo", "rw",
+};
+struct access_node
+{
+  struct access_node *next;
+  const void *addr;
+  size_t sz;
+  enum access_mode mode;
+};
+
+static struct access_node *access_list;
+
+void
+mark_region (const void *addr, size_t sz, enum access_mode mode)
+{
+  struct access_node *a;
+  if (debug)
+    printf ("mark_region (%p, %ld, %s)\n", addr, (long) sz,
+	    access_mode_strings[mode]);
+  a = malloc (sizeof (struct access_node));
+  a->next = access_list;
+  a->addr = addr;
+  a->sz = sz;
+  a->mode = mode;
+  access_list = a;
+}
+
+void report_bad_access (void *, size_t, enum memory_use_mode) NOCHECK;
+void
+report_bad_access (void *addr, size_t sz, enum memory_use_mode mode)
+{
+  if (++bad_accesses > 100)
+    bad_accesses = 100;
+  if (verbose)
+    {
+      static char x[100];
+      const char *mode_str;
+      if (mode >= 0
+	  && mode < sizeof (memory_use_strings) / sizeof (*memory_use_strings)
+	  && memory_use_strings[mode] != 0)
+	mode_str = memory_use_strings[mode];
+      else
+	{
+	  sprintf (x, "<bad mode %d>", mode);
+	  mode_str = x;
+	}
+      printf ("bad access (%p, %ld, %s)\n", addr, (long) sz, mode_str);
+    }
+}
+
+int verify1 (void *, size_t, enum access_mode, struct access_node *) NOCHECK;
+int
+verify1 (void *addr, size_t sz, enum access_mode mode,
+	 struct access_node *a)
+{
+  while (a && (addr + sz <= a->addr || addr >= a->addr + a->sz))
+    a = a->next;
+  if (a == 0)
+    return 0;
+
+  if (debug)
+    printf ("verify1 (%p, %ld, %s)\n", addr, (long) sz,
+	    access_mode_strings[mode]);
+
+  if (mode & ~a->mode)
+    return 0;
+
+  if (addr < a->addr)
+    if (verify1 (a, a->addr - addr, mode, a->next) == 0)
+      return 0;
+  if (addr + sz > a->addr + a->sz)
+    if (verify1 (a->addr + a->sz, (addr + sz) - (a->addr + a->sz), mode, a->next) == 0)
+      return 0;
+
+  /* All regions okay.  */
+  return 1;
+}
+
+int verify_range_permission (void *, size_t, enum access_mode) NOCHECK;
+int
+verify_range_permission (void *addr, size_t sz, enum access_mode mode)
+{
+  if (debug)
+    printf ("verify_range_permission (%p, %ld, %s)\n", addr, (long) sz,
+	    access_mode_strings[mode]);
+  return verify1 (addr, sz, mode, access_list);
+}
+
+void chkr_check_addr (void *, size_t, int) NOCHECK;
+void
+chkr_check_addr (void *addr, size_t sz, int mode)
+{
+  switch (mode)
+    {
+    case MEMORY_USE_BAD:
+    case MEMORY_USE_DONT:
+    default:
+      report_bad_access (addr, sz, mode);
+      return;
+    case MEMORY_USE_RO:
+      /* verify range readable */
+      if (!verify_range_permission (addr, sz, ACCESS_RO))
+	report_bad_access (addr, sz, mode);
+      return;
+    case MEMORY_USE_WO:
+      /* verify writeable, set writeable and readable */
+      if (!verify_range_permission (addr, sz, ACCESS_WO))
+	report_bad_access (addr, sz, mode);
+      mark_region (addr, sz, ACCESS_RW);
+      return;
+    case MEMORY_USE_RW:
+      /* verify readable and writeable, no change */
+      if (!verify_range_permission (addr, sz, ACCESS_RW))
+	report_bad_access (addr, sz, mode);
+      return;
+    case MEMORY_USE_TW:
+      /* verify writeable, no change */
+      if (!verify_range_permission (addr, sz, ACCESS_WO))
+	report_bad_access (addr, sz, mode);
+      return;
+    }
+  /* All branches should return.  */
+  abort ();
+}
+
+void copy1 (void *, void *, size_t, struct access_node *) NOCHECK;
+void
+copy1 (void *dest, void *src, size_t sz, struct access_node *a)
+{
+  while (a && (src + sz <= a->addr || src >= a->addr + a->sz))
+    a = a->next;
+  if (a == 0)
+    {
+      report_bad_access (src, sz, MEMORY_USE_RO);
+      return;
+    }
+
+  if (debug)
+    printf ("copy1 (%p, %p, %ld)\n", dest, src, (long) sz);
+
+  {
+    void *start, *end;
+    start = src;
+    if (start < a->addr)
+      start = a->addr;
+    end = src + sz;
+    if (end > a->addr + a->sz)
+      end = a->addr + a->sz;
+    mark_region (dest + (start - src), end - start, a->mode);
+  }
+
+  if (src < a->addr)
+    copy1 (dest, src, a->addr - src, a->next);
+  if (src + sz > a->addr + a->sz)
+    copy1 (dest + (a->addr + a->sz - src), a->addr + a->sz,
+	   (src + sz) - (a->addr + a->sz), a->next);
+}
+
+void chkr_copy_bitmap (void *, void *, size_t) NOCHECK;
+void
+chkr_copy_bitmap (void *dest, void *src, size_t sz)
+{
+  if (verify_range_permission (dest, sz, MEMORY_USE_WO) == 0)
+    report_bad_access (dest, sz, MEMORY_USE_WO);
+  copy1 (dest, src, sz, access_list);
+}
+
+void chkr_set_right (void *, size_t, enum access_mode) NOCHECK;
+void
+chkr_set_right (void *addr, size_t sz, enum access_mode mode)
+{
+  mark_region (addr, sz, mode);
+}
+
+int main () NOCHECK;
+int
+main ()
+{
+  setup ();
+  test ();
+  bad_accesses = !!bad_accesses; /* get 0 or 1 */
+  
+  if (bad_accesses == expect_error)
+    exit (0);
+  else
+    abort ();
+  
+  return 0;
+}
+
+struct malloc_node
+{
+  struct malloc_node *next;
+  void *addr;
+  size_t sz;
+  unsigned is_free : 1;
+};
+static struct malloc_node *malloc_list;
+
+void *
+c_malloc (size_t sz)
+{
+  void *p;
+  struct malloc_node *m;
+  if (sz == 0)
+    return 0;
+  p = malloc (sz);
+  if (p == 0)
+    {
+      if (verbose)
+	printf ("malloc(%ld) failed\n", (long) sz);
+      exit (1);
+    }
+  m = malloc (sizeof (struct malloc_node));
+  if (m == 0)
+    {
+      if (verbose)
+	printf ("malloc(%ld) failed\n", (long) sizeof (struct malloc_node));
+      exit (1);
+    }
+  mark_region (p, sz, ACCESS_WO);
+  m->addr = p;
+  m->sz = sz;
+  m->is_free = 0;
+  m->next = malloc_list;
+  malloc_list = m;
+  return p;
+}
+
+void
+c_free (void *p)
+{
+  struct malloc_node *m;
+  if (p == 0)
+    return;
+  for (m = malloc_list; m; m = m->next)
+    if (m->addr == p)
+      break;
+  if (m == 0 || m->is_free)
+    /* Test is broken.  */
+    abort ();
+  m->is_free = 1;
+  free (p);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/driver.h b/gcc/testsuite/gcc.c-torture/execute/memcheck/driver.h
new file mode 100644
index 00000000000..d8d22d2496a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/driver.h
@@ -0,0 +1,28 @@
+/* GNU C dependencies:
+   Checker support hooks
+   ISO C 9x array element initialization
+   void-pointer arithmetic */
+
+typedef __SIZE_TYPE__ size_t;
+
+extern void *malloc (size_t);
+extern int printf (const char *, ...);
+
+/* This comes from gcc internals.  Should be exported.  */
+enum memory_use_mode {MEMORY_USE_BAD = 0, MEMORY_USE_RO = 1,
+		      MEMORY_USE_WO = 2, MEMORY_USE_RW = 3,
+		      MEMORY_USE_TW = 6, MEMORY_USE_DONT = 99};
+
+enum access_mode {
+  ACCESS_NONE = 0, ACCESS_RO = 1, ACCESS_WO = 2, ACCESS_RW = 3
+};
+
+#define NOCHECK __attribute__ ((no_check_memory_usage))
+
+void mark_region (const void *, size_t, enum access_mode) NOCHECK;
+void setup () NOCHECK;
+void test ();
+extern int expect_error;
+
+void *c_malloc (size_t) NOCHECK;
+void c_free (void *) NOCHECK;
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/memcheck.exp b/gcc/testsuite/gcc.c-torture/execute/memcheck/memcheck.exp
new file mode 100644
index 00000000000..7fb756b4f5c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/memcheck.exp
@@ -0,0 +1,54 @@
+# Copyright (C) 1991, 92-93, 95, 97, 1998 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+# Modified and maintained by Jeffrey Wheat (cassidy@cygnus.com)
+
+#
+# These tests come from Torbjorn Granlund (tege@cygnus.com)
+# C torture test suite.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+
+#
+# main test loop
+#
+
+set tests [lsort [glob -nocomplain $srcdir/$subdir/*.c]]
+set idx [lsearch $tests */driver.c]
+if $idx>=0 {
+    set tests [lreplace $tests $idx $idx]
+} else {
+    error "list can't find driver.c in $srcdir/$subdir"
+}
+gcc_target_compile $srcdir/$subdir/driver.c driver.o object {additional_flags=-w additional_flags=-g}
+foreach src $tests {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $src] then {
+	continue
+    }
+
+    c-torture-execute $src "-fcheck-memory-usage driver.o"
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/t1.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/t1.c
new file mode 100644
index 00000000000..03b6acc1335
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/t1.c
@@ -0,0 +1,27 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup ();   -- NOCHECK */
+
+#include "driver.h"
+
+int expect_error = 0;
+
+int *ip;
+
+void test ()
+{
+  ip = c_malloc (sizeof (int));
+  *ip = 42;
+  t2 ();
+}
+
+int t2 ()
+{
+  return *ip;
+}
+
+void setup () /* NOCHECK */
+{
+  mark_region (&ip, sizeof (ip), ACCESS_RW);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/t2.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/t2.c
new file mode 100644
index 00000000000..d386eb7ebb1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/t2.c
@@ -0,0 +1,26 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup () NOCHECK; */
+
+#include "driver.h"
+
+int expect_error = 1;
+
+int *ip;
+
+void test ()
+{
+  ip = c_malloc (sizeof (int));
+  t2 ();
+}
+
+int t2 ()
+{
+  return *ip;
+}
+
+void setup () /* NOCHECK */
+{
+  mark_region (&ip, sizeof (ip), ACCESS_RW);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/t3.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/t3.c
new file mode 100644
index 00000000000..5b6333d4e8e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/t3.c
@@ -0,0 +1,25 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup () NOCHECK; */
+
+#include "driver.h"
+
+int expect_error = 0;
+
+int *ip;
+
+void test ()
+{
+  ip = c_malloc (sizeof (int));
+  t2 (ip);
+}
+
+int t2 (int *ip)
+{
+}
+
+void setup () /* NOCHECK */
+{
+  mark_region (&ip, sizeof (ip), ACCESS_RW);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/t4.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/t4.c
new file mode 100644
index 00000000000..25010a06818
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/t4.c
@@ -0,0 +1,34 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup () NOCHECK; */
+
+#include "driver.h"
+
+int expect_error = 0;
+
+struct s {
+  char c;
+  int a, b;
+};
+
+struct s *sp;
+
+void test ()
+{
+  sp = c_malloc (sizeof (struct s));
+  sp->c = 0;
+  sp->a = 12;
+  sp->b = 47;
+  foo (sp);
+}
+
+int foo (struct s *sp)
+{
+  return sp->c + sp->a + sp->b;
+}
+
+void setup () /* NOCHECK */
+{
+  mark_region (&sp, sizeof (sp), ACCESS_RW);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/t5.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/t5.c
new file mode 100644
index 00000000000..c3bbf640517
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/t5.c
@@ -0,0 +1,33 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup () NOCHECK; */
+
+#include "driver.h"
+
+int expect_error = 1;
+
+struct s {
+  char c;
+  int a, b;
+};
+
+struct s *sp;
+
+void test ()
+{
+  sp = c_malloc (sizeof (struct s));
+  sp->c = 0;
+  sp->b = 47;
+  foo (sp);
+}
+
+int foo (struct s *sp)
+{
+  return sp->c + sp->a + sp->b;
+}
+
+void setup () /* NOCHECK */
+{
+  mark_region (&sp, sizeof (sp), ACCESS_RW);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/t6.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/t6.c
new file mode 100644
index 00000000000..652d33d0f8c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/t6.c
@@ -0,0 +1,39 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup () NOCHECK; */
+
+#include "driver.h"
+
+int expect_error = 1;
+
+struct s {
+  char c;
+  int a, b;
+};
+
+struct s *sp;
+
+void test ()
+{
+  sp = c_malloc (sizeof (struct s) * 2);
+  sp->c = 0;
+  sp->b = 47;
+  cp (sp);
+  foo (sp);
+}
+
+int foo (struct s *sp)
+{
+  return sp[1].c + sp[1].a + sp[1].b;
+}
+
+int cp (struct s *sp)
+{
+  sp[1] = sp[0];
+}
+
+void setup () /* NOCHECK */
+{
+  mark_region (&sp, sizeof (sp), ACCESS_RW);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/t7.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/t7.c
new file mode 100644
index 00000000000..a7c6f5127ed
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/t7.c
@@ -0,0 +1,40 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup () NOCHECK; */
+
+#include "driver.h"
+
+int expect_error = 0;
+
+struct s {
+  char c;
+  int a, b;
+};
+
+struct s *sp;
+
+void test ()
+{
+  sp = c_malloc (sizeof (struct s) * 2);
+  sp->c = 0;
+  sp->a = 13;
+  sp->b = 47;
+  cp (sp);
+  foo (sp);
+}
+
+int foo (struct s *sp)
+{
+  return sp[1].c + sp[1].a + sp[1].b;
+}
+
+int cp (struct s *sp)
+{
+  sp[1] = sp[0];
+}
+
+void setup () /* NOCHECK */
+{
+  mark_region (&sp, sizeof (sp), ACCESS_RW);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/t8.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/t8.c
new file mode 100644
index 00000000000..01c167247f8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/t8.c
@@ -0,0 +1,41 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup () NOCHECK; */
+
+#include "driver.h"
+
+int expect_error = 0;
+
+typedef struct {
+  short a;
+  char b;
+} S1;
+typedef struct {
+  struct { int x; S1 *s1p; } *p;
+} S2;
+
+S1 *s1;
+S2 *s2;
+
+void test ()
+{
+  s1 = c_malloc (sizeof (S1));
+  s2 = c_malloc (sizeof (S2));
+  s2->p = c_malloc (sizeof (*s2->p));
+  s2->p->s1p = s1;
+  s1->a = 47;
+  s1->b = 3;
+  foo ();
+}
+
+int foo ()
+{
+  return s2->p->s1p->b;
+}
+
+void setup () /* NOCHECK */
+{
+  mark_region (&s1, sizeof (s1), ACCESS_RW);
+  mark_region (&s2, sizeof (s2), ACCESS_RW);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/t9.c b/gcc/testsuite/gcc.c-torture/execute/memcheck/t9.c
new file mode 100644
index 00000000000..f32ca011dd8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/t9.c
@@ -0,0 +1,40 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup () NOCHECK; */
+
+#include "driver.h"
+
+int expect_error = 1;
+
+typedef struct {
+  short a;
+  char b;
+} S1;
+typedef struct {
+  struct { int x; S1 *s1p; } *p;
+} S2;
+
+S1 *s1;
+S2 *s2;
+
+void test ()
+{
+  s1 = c_malloc (sizeof (S1));
+  s2 = c_malloc (sizeof (S2));
+  s2->p = c_malloc (sizeof (*s2->p));
+  s2->p->s1p = s1;
+  s1->a = 47;
+  foo ();
+}
+
+int foo ()
+{
+  return s2->p->s1p->b;
+}
+
+void setup () /* NOCHECK */
+{
+  mark_region (&s1, sizeof (s1), ACCESS_RW);
+  mark_region (&s2, sizeof (s2), ACCESS_RW);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcheck/template b/gcc/testsuite/gcc.c-torture/execute/memcheck/template
new file mode 100644
index 00000000000..37ebb137c87
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcheck/template
@@ -0,0 +1,16 @@
+/* Must define:
+   int expect_error;
+   void test ();
+   void setup () NOCHECK; */
+
+#include "driver.h"
+
+int expect_error = ;
+
+void test ()
+{
+}
+
+void setup () /* NOCHECK */
+{
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcpy-1.c b/gcc/testsuite/gcc.c-torture/execute/memcpy-1.c
new file mode 100644
index 00000000000..684854b66dc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcpy-1.c
@@ -0,0 +1,63 @@
+#include <string.h>
+
+#if defined (STACK_SIZE)
+#define MEMCPY_SIZE (STACK_SIZE / 3)
+#else
+#define MEMCPY_SIZE (1 << 17)
+#endif
+
+
+void *copy (void *o, const void *i, unsigned l)
+{
+  return memcpy (o, i, l);
+}
+
+main ()
+{
+  unsigned i;
+  unsigned char src[MEMCPY_SIZE];
+  unsigned char dst[MEMCPY_SIZE];
+
+  for (i = 0; i < MEMCPY_SIZE; i++)
+    src[i] = (unsigned char) i,  dst[i] = 0;
+
+  (void) memcpy (dst, src, MEMCPY_SIZE / 128);
+
+  for (i = 0; i < MEMCPY_SIZE / 128; i++)
+    if (dst[i] != (unsigned char) i)
+      abort ();
+
+  (void) memset (dst, 1, MEMCPY_SIZE / 128);
+
+  for (i = 0; i < MEMCPY_SIZE / 128; i++)
+    if (dst[i] != 1)
+      abort ();
+
+  (void) memcpy (dst, src, MEMCPY_SIZE);
+
+  for (i = 0; i < MEMCPY_SIZE; i++)
+    if (dst[i] != (unsigned char) i)
+      abort ();
+
+  (void) memset (dst, 0, MEMCPY_SIZE);
+
+  for (i = 0; i < MEMCPY_SIZE; i++)
+    if (dst[i] != 0)
+      abort ();
+
+  (void) copy (dst, src, MEMCPY_SIZE / 128);
+
+  for (i = 0; i < MEMCPY_SIZE / 128; i++)
+    if (dst[i] != (unsigned char) i)
+      abort ();
+
+  (void) memset (dst, 0, MEMCPY_SIZE);
+
+  (void) copy (dst, src, MEMCPY_SIZE);
+
+  for (i = 0; i < MEMCPY_SIZE; i++)
+    if (dst[i] != (unsigned char) i)
+      abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/memcpy-bi.c b/gcc/testsuite/gcc.c-torture/execute/memcpy-bi.c
new file mode 100644
index 00000000000..c6d6e035346
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/memcpy-bi.c
@@ -0,0 +1,52 @@
+/* Test builtin-memcpy (which may emit different code for different N).  */
+
+#define TESTSIZE 80
+
+char src[TESTSIZE] __attribute__ ((aligned));
+char dst[TESTSIZE] __attribute__ ((aligned));
+
+void
+check (char *test, char *match, int n)
+{
+  if (memcmp (test, match, n))
+    abort ();
+}
+
+#define TN(n) \
+{ memset (dst, 0, n); memcpy (dst, src, n); check (dst, src, n); }
+#define T(n) \
+TN (n) \
+TN ((n) + 1) \
+TN ((n) + 2) \
+TN ((n) + 3)
+
+main ()
+{
+  int i,j;
+
+  for (i = 0; i < sizeof (src); ++i)
+      src[i] = 'a' + i % 26;
+
+  T (0);
+  T (4);
+  T (8);
+  T (12);
+  T (16);
+  T (20);
+  T (24);
+  T (28);
+  T (32);
+  T (36);
+  T (40);
+  T (44);
+  T (48);
+  T (52);
+  T (56);
+  T (60);
+  T (64);
+  T (68);
+  T (72);
+  T (76);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/mod-1.c b/gcc/testsuite/gcc.c-torture/execute/mod-1.c
new file mode 100644
index 00000000000..b460df5cdb1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/mod-1.c
@@ -0,0 +1,11 @@
+f (x, y)
+{
+  if (x % y != 0)
+    abort ();
+}
+
+main ()
+{
+  f (-5, 5);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/nest-stdar-1.c b/gcc/testsuite/gcc.c-torture/execute/nest-stdar-1.c
new file mode 100644
index 00000000000..2c6108b52e6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/nest-stdar-1.c
@@ -0,0 +1,19 @@
+#include <stdarg.h>
+
+main ()
+{
+  static double f (int x, ...)
+    {
+      va_list args;
+      double a;
+
+      va_start (args, x);
+      a = va_arg (args, double);
+      va_end (args);
+      return a;
+    }
+
+  if (f (1, (double)1) != 1.0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/nestfunc-1.c b/gcc/testsuite/gcc.c-torture/execute/nestfunc-1.c
new file mode 100644
index 00000000000..e34a56b3f57
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/nestfunc-1.c
@@ -0,0 +1,28 @@
+int
+g (int a, int b, int (*gi) (int, int))
+{
+  if ((*gi) (a, b))
+    return a;
+  else
+    return b;
+}
+
+f ()
+{
+#ifndef NO_TRAMPOLINES
+  int i, j;
+  int f2 (int a, int b)
+    {
+      return a > b;
+    }
+
+  if (g (1, 2, f2) != 2)
+    abort ();
+#endif
+}
+
+main ()
+{
+  f ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/packed-1.c b/gcc/testsuite/gcc.c-torture/execute/packed-1.c
new file mode 100644
index 00000000000..9b226aeab9b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/packed-1.c
@@ -0,0 +1,19 @@
+short x1 = 17;
+
+struct
+{
+  short i __attribute__ ((packed));
+} t;
+
+f ()
+{
+  t.i = x1;
+  if (t.i != 17)
+    abort ();
+}
+
+main ()
+{
+  f ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pending-4.c b/gcc/testsuite/gcc.c-torture/execute/pending-4.c
new file mode 100644
index 00000000000..8000621e6b6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pending-4.c
@@ -0,0 +1,33 @@
+
+void dummy (x, y)
+     int *x;
+     int y;
+{}
+
+int
+main (argc, argv)
+     int argc;
+     char **argv;
+{
+  int number_columns=9;
+  int cnt0 = 0;
+  int cnt1 = 0;
+  int i,A1;
+
+  for (i = number_columns-1; i != 0; i--)
+    {         
+      if (i == 1)
+	{
+	  dummy(&A1, i);
+	  cnt0++;
+	}
+      else
+	{
+          dummy(&A1, i-1);
+          cnt1++;
+	}
+    }
+  if (cnt0 != 1 || cnt1 != 7)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/ptr-arith-1.c b/gcc/testsuite/gcc.c-torture/execute/ptr-arith-1.c
new file mode 100644
index 00000000000..46162b8964d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ptr-arith-1.c
@@ -0,0 +1,14 @@
+char *
+f (char *s, unsigned int i)
+{
+  return &s[i + 3 - 1];
+}
+
+main ()
+{
+  char *str = "abcdefghijkl";
+  char *x2 = f (str, 12);
+  if (str + 14 != x2)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/regstack-1.c b/gcc/testsuite/gcc.c-torture/execute/regstack-1.c
new file mode 100644
index 00000000000..51fb858cf92
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/regstack-1.c
@@ -0,0 +1,26 @@
+long double C = 5;
+long double U = 1;
+long double Y2 = 11;
+long double Y1 = 17;
+long double X, Y, Z, T, R, S;
+main ()
+{
+  X = (C + U) * Y2;
+  Y = C - U - U;
+  Z = C + U + U;
+  T = (C - U) * Y1;
+  X = X - (Z + U);
+  R = Y * Y1;
+  S = Z * Y2;
+  T = T - Y;
+  Y = (U - Y) + R;
+  Z = S - (Z + U + U);
+  R = (Y2 + U) * Y1;
+  Y1 = Y2 * Y1;
+  R = R - Y2;
+  Y1 = Y1 - 0.5L;
+  if (Z != 68. || Y != 49. || X != 58. || Y1 != 186.5 || R != 193. || S != 77.
+      || T != 65. || Y2 != 11.)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/scope-1.c b/gcc/testsuite/gcc.c-torture/execute/scope-1.c
new file mode 100644
index 00000000000..cedd0b48ccb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/scope-1.c
@@ -0,0 +1,17 @@
+int v = 3;
+
+f ()
+{
+  int v = 4;
+  {
+    extern int v;
+    if (v != 3)
+      abort ();
+  }
+}
+
+main ()
+{
+  f ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/scope-2.c b/gcc/testsuite/gcc.c-torture/execute/scope-2.c
new file mode 100644
index 00000000000..c9a4775f6f5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/scope-2.c
@@ -0,0 +1,17 @@
+static int v = 3;
+
+f ()
+{
+  int v = 4;
+  {
+    extern int v;
+    if (v != 3)
+      abort ();
+  }
+}
+
+main ()
+{
+  f ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/strct-pack-1.c b/gcc/testsuite/gcc.c-torture/execute/strct-pack-1.c
new file mode 100644
index 00000000000..7b702f2cd68
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/strct-pack-1.c
@@ -0,0 +1,25 @@
+typedef struct
+{
+  short s __attribute__ ((aligned(2), packed));
+  double d __attribute__ ((aligned(2), packed));
+} TRIAL;
+
+int
+check (TRIAL *t)
+{
+  if (t->s != 1 || t->d != 16.0)
+    return 1;
+  return 0;
+}
+
+main ()
+{
+  TRIAL trial;
+
+  trial.s = 1;
+  trial.d = 16.0;
+
+  if (check (&trial) != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/strct-pack-2.c b/gcc/testsuite/gcc.c-torture/execute/strct-pack-2.c
new file mode 100644
index 00000000000..be76c764521
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/strct-pack-2.c
@@ -0,0 +1,13 @@
+typedef struct
+{
+  short a __attribute__ ((aligned (2),packed));
+  short *ap[2]  __attribute__ ((aligned (2),packed));
+} A;
+
+main ()
+{
+  short i, j = 1;
+  A a, *ap = &a;
+  ap->ap[j] = &i;
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/strct-pack-3.c b/gcc/testsuite/gcc.c-torture/execute/strct-pack-3.c
new file mode 100644
index 00000000000..8f91b040ca8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/strct-pack-3.c
@@ -0,0 +1,28 @@
+typedef struct
+{
+  short i __attribute__ ((aligned (2),packed));
+  int f[2] __attribute__ ((aligned (2),packed));
+} A;
+
+f (ap)
+  A *ap;
+{
+  short i, j = 1;
+
+  i = ap->f[1];
+  i += ap->f[j];
+  for (j = 0; j < 2; j++)
+    i += ap->f[j];
+
+  return i;
+}
+
+main ()
+{
+  A a;
+  a.f[0] = 100;
+  a.f[1] = 13;
+  if (f (&a) != 139)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/strct-pack-4.c b/gcc/testsuite/gcc.c-torture/execute/strct-pack-4.c
new file mode 100644
index 00000000000..56d315f47ff
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/strct-pack-4.c
@@ -0,0 +1,29 @@
+typedef struct
+{
+  unsigned char a __attribute__((packed));
+  unsigned short b __attribute__((packed));
+} three_char_t;
+
+unsigned char
+my_set_a (void)
+{
+  return 0xab;
+}
+
+unsigned short
+my_set_b (void)
+{
+  return 0x1234;
+}
+
+main ()
+{
+  three_char_t three_char;
+
+  three_char.a = my_set_a ();
+  three_char.b = my_set_b ();
+  if (three_char.a != 0xab || three_char.b != 0x1234)
+    abort ();
+  exit (0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/strct-stdarg-1.c b/gcc/testsuite/gcc.c-torture/execute/strct-stdarg-1.c
new file mode 100644
index 00000000000..508c954705a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/strct-stdarg-1.c
@@ -0,0 +1,61 @@
+#include <stdarg.h>
+
+struct tiny
+{
+  char c;
+  char d;
+  char e;
+  char f;
+  char g;
+};
+
+f (int n, ...)
+{
+  struct tiny x;
+  int i;
+
+  va_list ap;
+  va_start (ap,n);
+  for (i = 0; i < n; i++)
+    {
+      x = va_arg (ap,struct tiny);
+      if (x.c != i + 10)
+	abort();
+      if (x.d != i + 20)
+	abort();
+      if (x.e != i + 30)
+	abort();
+      if (x.f != i + 40)
+	abort();
+      if (x.g != i + 50)
+	abort();
+    }
+  {
+    long x = va_arg (ap, long);
+    if (x != 123)
+      abort();
+  }
+  va_end (ap);
+}
+
+main ()
+{
+  struct tiny x[3];
+  x[0].c = 10;
+  x[1].c = 11;
+  x[2].c = 12;
+  x[0].d = 20;
+  x[1].d = 21;
+  x[2].d = 22;
+  x[0].e = 30;
+  x[1].e = 31;
+  x[2].e = 32;
+  x[0].f = 40;
+  x[1].f = 41;
+  x[2].f = 42;
+  x[0].g = 50;
+  x[1].g = 51;
+  x[2].g = 52;
+  f (3, x[0], x[1], x[2], (long) 123);
+  exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/strct-varg-1.c b/gcc/testsuite/gcc.c-torture/execute/strct-varg-1.c
new file mode 100644
index 00000000000..f76bb368409
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/strct-varg-1.c
@@ -0,0 +1,56 @@
+#ifdef NO_VARARGS
+#include <stdarg.h>
+#define va_alist int x_attr, ...
+#define va_dcl
+#else
+#include <varargs.h>
+#endif
+
+struct s { int x, y; };
+
+f (va_alist)
+     va_dcl
+{
+  struct s va_values;
+  va_list va;
+  int attr;
+  int i;
+
+#ifdef NO_VARARGS
+  va_start (va, x_attr);
+  attr = x_attr;
+#else
+  va_start (va);
+  attr = va_arg (va, int);
+#endif
+
+  if (attr != 2)
+    abort ();
+
+  va_values = va_arg (va, struct s);
+  if (va_values.x != 0xaaaa || va_values.y != 0x5555)
+    abort ();
+
+  attr = va_arg (va, int);
+  if (attr != 3)
+    abort ();
+
+  va_values = va_arg (va, struct s);
+  if (va_values.x != 0xffff || va_values.y != 0x1111)
+    abort ();
+
+  va_end (va);
+}
+
+main ()
+{
+  struct s a, b;
+
+  a.x = 0xaaaa;
+  a.y = 0x5555;
+  b.x = 0xffff;
+  b.y = 0x1111;
+
+  f (2, a, 3, b);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/strct-varg-1.x b/gcc/testsuite/gcc.c-torture/execute/strct-varg-1.x
new file mode 100644
index 00000000000..22e08efa977
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/strct-varg-1.x
@@ -0,0 +1,10 @@
+# This doesn't work on mn10200
+
+if { [istarget "mn10200*-*-*"] } {
+	set torture_execute_xfail "mn10200*-*-*"
+}
+
+if { [istarget "h8300*-*-*"] } {
+	set torture_execute_xfail "h8300*-*-*"
+}
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/struct-ini-1.c b/gcc/testsuite/gcc.c-torture/execute/struct-ini-1.c
new file mode 100644
index 00000000000..ab2d178a751
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/struct-ini-1.c
@@ -0,0 +1,15 @@
+struct S
+{
+  char f1;
+  int f2[2];
+};
+
+struct S object = {'X', 8, 9};
+
+main ()
+{
+  if (object.f1 != 'X' || object.f2[0] != 8 || object.f2[1] != 9)
+    abort ();
+  exit (0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/struct-ini-2.c b/gcc/testsuite/gcc.c-torture/execute/struct-ini-2.c
new file mode 100644
index 00000000000..c785257ccba
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/struct-ini-2.c
@@ -0,0 +1,17 @@
+struct {
+  int a:4;
+  int :4;
+  int b:4;
+  int c:4;
+} x = { 2,3,4 };
+
+main ()
+{
+  if (x.a != 2)
+    abort ();
+  if (x.b != 3)
+    abort ();
+  if (x.c != 4)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/struct-ini-3.c b/gcc/testsuite/gcc.c-torture/execute/struct-ini-3.c
new file mode 100644
index 00000000000..7d282ecb8af
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/struct-ini-3.c
@@ -0,0 +1,11 @@
+struct
+{
+  unsigned int f1:1, f2:1, f3:3, f4:3, f5:2, f6:1, f7:1;
+} result = {1, 1, 7, 7, 3, 1, 1};
+
+main ()
+{
+  if ((result.f3 & ~7) != 0 || (result.f4 & ~7) != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/struct-ini-4.c b/gcc/testsuite/gcc.c-torture/execute/struct-ini-4.c
new file mode 100644
index 00000000000..3342439e54d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/struct-ini-4.c
@@ -0,0 +1,15 @@
+struct s {
+  int a[3];
+  int c[3];
+};
+
+struct s s = {
+  c: {1, 2, 3}
+};
+
+main()
+{
+  if (s.c[0] != 1)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/struct-ret-1.c b/gcc/testsuite/gcc.c-torture/execute/struct-ret-1.c
new file mode 100644
index 00000000000..e5274ec4c15
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/struct-ret-1.c
@@ -0,0 +1,57 @@
+#include <stdio.h>
+#include <string.h>
+
+char out[100];
+
+typedef struct { double d; int i[3]; } B;
+typedef struct { char c[33],c1; } X;
+
+char c1 = 'a';
+char c2 = 127;
+char c3 = (char)128;
+char c4 = (char)255;
+char c5 = -1;
+
+double d1 = 0.1;
+double d2 = 0.2;
+double d3 = 0.3;
+double d4 = 0.4;
+double d5 = 0.5;
+double d6 = 0.6;
+double d7 = 0.7;
+double d8 = 0.8;
+double d9 = 0.9;
+
+B B1 = {0.1,{1,2,3}};
+B B2 = {0.2,{5,4,3}};
+X X1 = {"abcdefghijklmnopqrstuvwxyzABCDEF", 'G'};
+X X2 = {"123",'9'};
+X X3 = {"return-return-return",'R'};
+
+X f (B a, char b, double c, B d)
+{
+  static X xr = {"return val", 'R'};
+  X r;
+  r = xr;
+  r.c1 = b;
+  sprintf (out, "X f(B,char,double,B):({%g,{%d,%d,%d}},'%c',%g,{%g,{%d,%d,%d}})",
+	   a.d, a.i[0], a.i[1], a.i[2], b, c, d.d, d.i[0], d.i[1], d.i[2]);
+  return r;
+}
+
+X (*fp) (B, char, double, B) = &f;
+
+main ()
+{
+  X Xr;
+  char tmp[100];
+
+  Xr = f (B1, c2, d3, B2);
+  strcpy (tmp, out);
+  Xr.c[0] = Xr.c1 = '\0';
+  Xr = (*fp) (B1, c2, d3, B2);
+  if (strcmp (tmp, out))
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/struct-ret-2.c b/gcc/testsuite/gcc.c-torture/execute/struct-ret-2.c
new file mode 100644
index 00000000000..06a40a72099
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/struct-ret-2.c
@@ -0,0 +1,29 @@
+typedef struct
+{
+  unsigned char a __attribute__ ((packed));
+  unsigned short b __attribute__ ((packed));
+} three_byte_t;
+
+unsigned char
+f (void)
+{
+  return 0xab;
+}
+
+unsigned short
+g (void)
+{
+  return 0x1234;
+}
+
+main ()
+{
+  three_byte_t three_byte;
+
+  three_byte.a = f ();
+  three_byte.b = g ();
+  if (three_byte.a != 0xab || three_byte.b != 0x1234)
+    abort ();
+  exit (0);
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/tstdi-1.c b/gcc/testsuite/gcc.c-torture/execute/tstdi-1.c
new file mode 100644
index 00000000000..3e31fdf5934
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/tstdi-1.c
@@ -0,0 +1,139 @@
+#define FALSE 140
+#define TRUE 13
+
+feq (x)
+     long long int x;
+{
+  if (x == 0)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+fne (x)
+     long long int x;
+{
+  if (x != 0)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+flt (x)
+     long long int x;
+{
+  if (x < 0)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+fge (x)
+     long long int x;
+{
+  if (x >= 0)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+fgt (x)
+     long long int x;
+{
+  if (x > 0)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+fle (x)
+     long long int x;
+{
+  if (x <= 0)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+main ()
+{
+  if (feq (0LL) != TRUE)
+    abort ();
+  if (feq (-1LL) != FALSE)
+    abort ();
+  if (feq (0x8000000000000000LL) != FALSE)
+    abort ();
+  if (feq (0x8000000000000001LL) != FALSE)
+    abort ();
+  if (feq (1LL) != FALSE)
+    abort ();
+  if (feq (0x7fffffffffffffffLL) != FALSE)
+    abort ();
+
+  if (fne (0LL) != FALSE)
+    abort ();
+  if (fne (-1LL) != TRUE)
+    abort ();
+  if (fne (0x8000000000000000LL) != TRUE)
+    abort ();
+  if (fne (0x8000000000000001LL) != TRUE)
+    abort ();
+  if (fne (1LL) != TRUE)
+    abort ();
+  if (fne (0x7fffffffffffffffLL) != TRUE)
+    abort ();
+
+  if (flt (0LL) != FALSE)
+    abort ();
+  if (flt (-1LL) != TRUE)
+    abort ();
+  if (flt (0x8000000000000000LL) != TRUE)
+    abort ();
+  if (flt (0x8000000000000001LL) != TRUE)
+    abort ();
+  if (flt (1LL) != FALSE)
+    abort ();
+  if (flt (0x7fffffffffffffffLL) != FALSE)
+    abort ();
+
+  if (fge (0LL) != TRUE)
+    abort ();
+  if (fge (-1LL) != FALSE)
+    abort ();
+  if (fge (0x8000000000000000LL) != FALSE)
+    abort ();
+  if (fge (0x8000000000000001LL) != FALSE)
+    abort ();
+  if (fge (1LL) != TRUE)
+    abort ();
+  if (fge (0x7fffffffffffffffLL) != TRUE)
+    abort ();
+
+  if (fgt (0LL) != FALSE)
+    abort ();
+  if (fgt (-1LL) != FALSE)
+    abort ();
+  if (fgt (0x8000000000000000LL) != FALSE)
+    abort ();
+  if (fgt (0x8000000000000001LL) != FALSE)
+    abort ();
+  if (fgt (1LL) != TRUE)
+    abort ();
+  if (fgt (0x7fffffffffffffffLL) != TRUE)
+    abort ();
+
+  if (fle (0LL) != TRUE)
+    abort ();
+  if (fle (-1LL) != TRUE)
+    abort ();
+  if (fle (0x8000000000000000LL) != TRUE)
+    abort ();
+  if (fle (0x8000000000000001LL) != TRUE)
+    abort ();
+  if (fle (1LL) != FALSE)
+    abort ();
+  if (fle (0x7fffffffffffffffLL) != FALSE)
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/va-arg-1.c b/gcc/testsuite/gcc.c-torture/execute/va-arg-1.c
new file mode 100644
index 00000000000..3f3b141a931
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/va-arg-1.c
@@ -0,0 +1,24 @@
+#include <stdarg.h>
+
+typedef unsigned long L;
+f (L p0, L p1, L p2, L p3, L p4, L p5, L p6, L p7, L p8, ...)
+{
+  va_list select;
+
+  va_start (select, p8);
+
+  if (va_arg (select, L) != 10)
+    abort ();
+  if (va_arg (select, L) != 11)
+    abort ();
+  if (va_arg (select, L) != 0)
+    abort ();
+
+  va_end (select);
+}
+
+main ()
+{
+  f (1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 0L);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/va-arg-2.c b/gcc/testsuite/gcc.c-torture/execute/va-arg-2.c
new file mode 100644
index 00000000000..7675b3f7603
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/va-arg-2.c
@@ -0,0 +1,292 @@
+/* The purpose of this test is to catch edge cases when arguments are passed
+   in regs and on the stack.  We test 16 cases, trying to catch multiple
+   targets (some use 3 regs for argument passing, some use 12, etc.).
+   We test both the arguments and the `lastarg' (the argument to va_start).  */
+
+#include <stdarg.h>
+
+extern __SIZE_TYPE__ strlen ();
+
+int
+to_hex (unsigned int a)
+{
+  static char hex[] = "0123456789abcdef";
+
+  if (a > 15)
+    abort ();
+  return hex[a];
+}
+
+void
+f0 (char* format, ...)
+{
+  va_list ap;
+
+  va_start (ap, format);
+  if (strlen (format) != 16 - 0)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f1 (int a1, char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 1)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f2 (int a1, int a2, char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 2)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f3 (int a1, int a2, int a3, char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 3)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f4 (int a1, int a2, int a3, int a4, char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 4)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f5 (int a1, int a2, int a3, int a4, int a5,
+    char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 5)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f6 (int a1, int a2, int a3, int a4, int a5,
+    int a6,
+    char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 6)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f7 (int a1, int a2, int a3, int a4, int a5,
+    int a6, int a7,
+    char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 7)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f8 (int a1, int a2, int a3, int a4, int a5,
+    int a6, int a7, int a8,
+    char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 8)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f9 (int a1, int a2, int a3, int a4, int a5,
+     int a6, int a7, int a8, int a9,
+     char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 9)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f10 (int a1, int a2, int a3, int a4, int a5,
+     int a6, int a7, int a8, int a9, int a10,
+     char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 10)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f11 (int a1, int a2, int a3, int a4, int a5,
+     int a6, int a7, int a8, int a9, int a10,
+     int a11,
+     char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 11)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f12 (int a1, int a2, int a3, int a4, int a5,
+     int a6, int a7, int a8, int a9, int a10,
+     int a11, int a12,
+     char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 12)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f13 (int a1, int a2, int a3, int a4, int a5,
+     int a6, int a7, int a8, int a9, int a10,
+     int a11, int a12, int a13,
+     char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 13)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f14 (int a1, int a2, int a3, int a4, int a5,
+     int a6, int a7, int a8, int a9, int a10,
+     int a11, int a12, int a13, int a14,
+     char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 14)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f15 (int a1, int a2, int a3, int a4, int a5,
+     int a6, int a7, int a8, int a9, int a10,
+     int a11, int a12, int a13, int a14, int a15,
+     char* format, ...)
+{
+  va_list ap;
+
+  va_start(ap, format);
+  if (strlen (format) != 16 - 15)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+main ()
+{
+  char *f = "0123456789abcdef";
+
+  f0 (f+0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f1 (0, f+1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f2 (0, 1, f+2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f3 (0, 1, 2, f+3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f4 (0, 1, 2, 3, f+4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f5 (0, 1, 2, 3, 4, f+5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f6 (0, 1, 2, 3, 4, 5, f+6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f7 (0, 1, 2, 3, 4, 5, 6, f+7, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f8 (0, 1, 2, 3, 4, 5, 6, 7, f+8, 8, 9, 10, 11, 12, 13, 14, 15);
+  f9 (0, 1, 2, 3, 4, 5, 6, 7, 8, f+9, 9, 10, 11, 12, 13, 14, 15);
+  f10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, f+10, 10, 11, 12, 13, 14, 15);
+  f11 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, f+11, 11, 12, 13, 14, 15);
+  f12 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, f+12, 12, 13, 14, 15);
+  f13 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, f+13, 13, 14, 15);
+  f14 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, f+14, 14, 15);
+  f15 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, f+15, 15);
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/va-arg-3.c b/gcc/testsuite/gcc.c-torture/execute/va-arg-3.c
new file mode 100644
index 00000000000..7b0a0b0cf36
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/va-arg-3.c
@@ -0,0 +1,339 @@
+/* Same as va-arg-2.c but using varargs.h.  */
+/* The purpose of this test is to catch edge cases when arguments are passed
+   in regs and on the stack.  We test 16 cases, trying to catch multiple
+   targets (some use 3 regs for argument passing, some use 12, etc.).
+   We test both the arguments and the `lastarg' (the argument to va_start).  */
+
+#ifdef NO_VARARGS
+int main()
+{
+  exit (0);
+}
+
+#else
+#include <varargs.h>
+
+extern __SIZE_TYPE__ strlen ();
+
+int
+to_hex (unsigned int a)
+{
+  static char hex[] = "0123456789abcdef";
+
+  if (a > 15)
+    abort ();
+  return hex[a];
+}
+
+void
+f0 (va_alist)
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 0)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f1 (a1, va_alist)
+     int a1;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 1)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f2 (a1, a2, va_alist)
+     int a1, a2;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 2)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f3 (a1, a2, a3, va_alist)
+     int a1, a2, a3;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 3)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f4 (a1, a2, a3, a4, va_alist)
+     int a1, a2, a3, a4;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 4)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f5 (a1, a2, a3, a4, a5, va_alist)
+     int a1, a2, a3, a4, a5;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 5)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f6 (a1, a2, a3, a4, a5, a6, va_alist)
+     int a1, a2, a3, a4, a5, a6;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 6)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f7 (a1, a2, a3, a4, a5, a6, a7, va_alist)
+     int a1, a2, a3, a4, a5, a6, a7;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 7)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f8 (a1, a2, a3, a4, a5, a6, a7, a8, va_alist)
+     int a1, a2, a3, a4, a5, a6, a7, a8;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 8)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f9 (a1, a2, a3, a4, a5, a6, a7, a8, a9, va_alist)
+     int a1, a2, a3, a4, a5, a6, a7, a8, a9;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 9)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f10 (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, va_alist)
+     int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 10)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f11 (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,
+     va_alist)
+     int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 11)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f12 (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, va_alist)
+     int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 12)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f13 (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, va_alist)
+     int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 13)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f14 (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, va_alist)
+     int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 14)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+void
+f15 (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, va_alist)
+     int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15;
+     va_dcl
+{
+  va_list ap;
+  char *format;
+
+  va_start (ap);
+  format = va_arg (ap, char *);
+  if (strlen (format) != 16 - 15)
+    abort ();
+  while (*format)
+    if (*format++ != to_hex (va_arg (ap, int)))
+      abort ();
+  va_end(ap);
+}
+
+main ()
+{
+  char *f = "0123456789abcdef";
+
+  f0 (f+0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f1 (0, f+1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f2 (0, 1, f+2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f3 (0, 1, 2, f+3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f4 (0, 1, 2, 3, f+4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f5 (0, 1, 2, 3, 4, f+5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f6 (0, 1, 2, 3, 4, 5, f+6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f7 (0, 1, 2, 3, 4, 5, 6, f+7, 7, 8, 9, 10, 11, 12, 13, 14, 15);
+  f8 (0, 1, 2, 3, 4, 5, 6, 7, f+8, 8, 9, 10, 11, 12, 13, 14, 15);
+  f9 (0, 1, 2, 3, 4, 5, 6, 7, 8, f+9, 9, 10, 11, 12, 13, 14, 15);
+  f10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, f+10, 10, 11, 12, 13, 14, 15);
+  f11 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, f+11, 11, 12, 13, 14, 15);
+  f12 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, f+12, 12, 13, 14, 15);
+  f13 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, f+13, 13, 14, 15);
+  f14 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, f+14, 14, 15);
+  f15 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, f+15, 15);
+
+  exit (0);
+}
+#endif /* ! NO_VARARGS */
diff --git a/gcc/testsuite/gcc.c-torture/execute/va-arg-3.x b/gcc/testsuite/gcc.c-torture/execute/va-arg-3.x
new file mode 100644
index 00000000000..865aaf81c54
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/va-arg-3.x
@@ -0,0 +1,12 @@
+# This doesn't work on mn10200
+
+if { [istarget "mn10200*-*-*"] } {
+	set torture_execute_xfail "mn10200*-*-*"
+}
+
+if { [istarget "h8300*-*-*"] } {
+	set torture_execute_xfail "h8300*-*-*"
+}
+
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/va-arg-4.c b/gcc/testsuite/gcc.c-torture/execute/va-arg-4.c
new file mode 100644
index 00000000000..a824f64ffa1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/va-arg-4.c
@@ -0,0 +1,33 @@
+/* On the i960 any arg bigger than 16 bytes causes all subsequent args
+   to be passed on the stack.  We test this.  */
+
+#include <stdarg.h>
+
+typedef struct {
+  char a[32];
+} big;
+
+void
+f (big x, char *s, ...)
+{
+  va_list ap;
+
+  if (x.a[0] != 'a' || x.a[1] != 'b' || x.a[2] != 'c')
+    abort ();
+  va_start (ap, s);
+  if (va_arg (ap, int) != 42)
+    abort ();
+  if (va_arg (ap, int) != 'x')
+    abort ();
+  if (va_arg (ap, int) != 0)
+    abort ();
+  va_end (ap);
+}
+
+main ()
+{
+  static big x = { "abc" };
+
+  f (x, "", 42, 'x', 0);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/va-arg-5.c b/gcc/testsuite/gcc.c-torture/execute/va-arg-5.c
new file mode 100644
index 00000000000..3d8b1a79ad1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/va-arg-5.c
@@ -0,0 +1,44 @@
+#include <stdarg.h>
+
+va_double (int n, ...)
+{
+  va_list args;
+
+  va_start (args, n);
+
+  if (va_arg (args, double) != 3.141592)
+    abort ();
+  if (va_arg (args, double) != 2.71827)
+    abort ();
+  if (va_arg (args, double) != 2.2360679)
+    abort ();
+  if (va_arg (args, double) != 2.1474836)
+    abort ();
+
+  va_end (args);
+}
+
+va_long_double (int n, ...)
+{
+  va_list args;
+
+  va_start (args, n);
+
+  if (va_arg (args, long double) != 3.141592L)
+    abort ();
+  if (va_arg (args, long double) != 2.71827L)
+    abort ();
+  if (va_arg (args, long double) != 2.2360679L)
+    abort ();
+  if (va_arg (args, long double) != 2.1474836L)
+    abort ();
+
+  va_end (args);
+}
+
+main ()
+{
+  va_double (4, 3.141592, 2.71827, 2.2360679, 2.1474836);
+  va_long_double (4, 3.141592L, 2.71827L, 2.2360679L, 2.1474836L);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/va-arg-6.c b/gcc/testsuite/gcc.c-torture/execute/va-arg-6.c
new file mode 100644
index 00000000000..e8d495d66e7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/va-arg-6.c
@@ -0,0 +1,35 @@
+#include <stdarg.h>
+
+f (int n, ...)
+{
+  va_list args;
+
+  va_start (args, n);
+
+  if (va_arg (args, int) != 10)
+    abort ();
+  if (va_arg (args, long long) != 10000000000LL)
+    abort ();
+  if (va_arg (args, int) != 11)
+    abort ();
+  if (va_arg (args, long double) != 3.14L)
+    abort ();
+  if (va_arg (args, int) != 12)
+    abort ();
+  if (va_arg (args, int) != 13)
+    abort ();
+  if (va_arg (args, long long) != 20000000000LL)
+    abort ();
+  if (va_arg (args, int) != 14)
+    abort ();
+  if (va_arg (args, double) != 2.72)
+    abort ();
+
+  va_end(args);
+}
+
+main ()
+{
+  f (4, 10, 10000000000LL, 11, 3.14L, 12, 13, 20000000000LL, 14, 2.72);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/widechar-1.c b/gcc/testsuite/gcc.c-torture/execute/widechar-1.c
new file mode 100644
index 00000000000..45b9d89b4b4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/widechar-1.c
@@ -0,0 +1,14 @@
+#define C L'\400'
+
+#if C
+#define zero (!C)
+#else
+#define zero C
+#endif
+
+main()
+{
+  if (zero != 0)
+    abort ();
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/920507-1.c b/gcc/testsuite/gcc.c-torture/noncompile/920507-1.c
new file mode 100644
index 00000000000..e1bd9934de3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/920507-1.c
@@ -0,0 +1 @@
+x(){register*a asm("fr1");int*v[1]={a};}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/920616-2.c b/gcc/testsuite/gcc.c-torture/noncompile/920616-2.c
new file mode 100644
index 00000000000..ddfa0de1ba1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/920616-2.c
@@ -0,0 +1 @@
+f(void a,...){}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/920721-2.c b/gcc/testsuite/gcc.c-torture/noncompile/920721-2.c
new file mode 100644
index 00000000000..4621983e037
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/920721-2.c
@@ -0,0 +1 @@
+f(int n){int s;for(s=0;s<n;s++)s==5?1 n=1;}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/920824-1.c b/gcc/testsuite/gcc.c-torture/noncompile/920824-1.c
new file mode 100644
index 00000000000..36661f63c17
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/920824-1.c
@@ -0,0 +1 @@
+struct s{struct s{int i;}x;};
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/920923-1.c b/gcc/testsuite/gcc.c-torture/noncompile/920923-1.c
new file mode 100644
index 00000000000..52f8338abf3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/920923-1.c
@@ -0,0 +1,36 @@
+typedef BYTE unsigned char;typedef int item_n;typedef int perm_set;struct
+PENT{caddr_t v_addr;};typedef struct PENT prec;typedef struct PENT*
+prec_t;prec_t mem_hash;BYTE*mem_base;struct PTE{BYTE*p_page;perm_set
+p_perms;};typedef struct PTE pte;struct PTP{union{struct*PTP
+p_tablep;struct*PTE p_entry;}u;int valid;};typedef struct PTP
+(u.p_tablep);int pfree=0;int pcount=0;void mmu_walk_find(va)caddr_t va;{
+BYTE*page_addr;if(mmu_base[Level1(va)]->valid==0x0){l1_base=
+mmu_base[Level1(va)]->(u.p_tablep)=p_alloc();mmu_base[Level1(va)]->valid=
+0x3;for(idx=0;idx<LEVEL1_ENTRIES;idx++)l1_base[idx]->valid=0x0;goto
+build_level2;}else l1_base=mmu_base[Level1(va)]->(u.p_tablep);if
+(l1_base[Level2(va)]->valid==0x0){build_level2:l2_base=
+l1_base[Level2(va)]->(u.p_tablep)=p_alloc();l1_base[Level2(va)]->valid=
+0x3;for(idx=0;idx<LEVEL2_ENTRIES;idx++)l2_base[idx]->valid=0x0;goto
+build_page;}else l2_base=mmu_base[Level2(va)]->(u.p_tablep);
+page_addr=l2_base[Level2(va)]->valid;}void*a_translate(va_op,v_addr)int
+va_op;caddr_t v_addr;{register prec_t bucket;register caddr_t p_addr;
+bucket=mem_hash+((((v_addr)>>ITEMBITS))&hash_mask);do{if
+(bucket->v_addr==((v_addr)>>ITEMBITS){if(!(bucket->perm_set&va_op))
+goto prot_fault;return mem_base+v_addr;}}while((bucket++)->v_addr!=
+((caddr_t)0));page_miss:p_addr=(--bucket)->p_addr;page_type:switch
+(p_addr){case BUCKET_FULL:enlarge_hash_table(mem_hash);case((caddr_t)0):
+p_addr=fill_item_entry(va_op,v_addr);goto page_type;case((caddr_t)1):
+default:((void)(((0))?0:(__eprintf("Failed assertion`%s'at line%d
+of`%s'.\n","FALSE",327,"b.c"),0)));}}void flush_hash(hasht,
+hash_size)prec_t hasht;int hash_size;{register prec_t bucket;register int
+idx;bucket=hasht;for(idx=(hash_size*3)-1;idx>=0;idx--){
+bucket->v_addr=((caddr_t)0);bucket->p_addr=((caddr_t)0);
+bucket->perm_set=VA_EMPTY;}}void init_mem(){mem_base=(BYTE*)calloc(1024
+,(1<<13));((void)((mem_base!=(BYTE*)0)?0:(__eprintf("Failed
+assertion`%s'at line%d of`%s'.\n","mem_base!=(BYTE*)0",366,"b.c"),
+0)));hash_num=INIT_NUM_ENTRIES*3;mem_hash=(prec_t)calloc(hash_num,
+sizeof(prec));((void)((mem_hash!=(prec_t)0)?0:(__eprintf("Failed
+assertion`%s'at line%d of`%s'.\n","mem_hash!=(prec_t)0",370,"b.c"),
+0)));flush_hash(mem_hash,32);build_ptables(mem_base,1024*(1<<13));}
+struct tm{int tm_sec;int tm_min;int tm_hour;int tm_mday;int tm_mon;int
+tm_year;int tm_wday;int tm_yday;int tm_isdst;char*tm_zone;long tm_gmtoff;};
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/921102-1.c b/gcc/testsuite/gcc.c-torture/noncompile/921102-1.c
new file mode 100644
index 00000000000..3fb42f19b56
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/921102-1.c
@@ -0,0 +1 @@
+int x[]={[0.3 ... 4.6]9};
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/921116-1.c b/gcc/testsuite/gcc.c-torture/noncompile/921116-1.c
new file mode 100644
index 00000000000..78a75ea8193
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/921116-1.c
@@ -0,0 +1 @@
+void a (void x) {}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/930301-1.c b/gcc/testsuite/gcc.c-torture/noncompile/930301-1.c
new file mode 100644
index 00000000000..de4271415e9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/930301-1.c
@@ -0,0 +1,5 @@
+struct a *q;
+f()
+{
+  q++;
+}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/930622-1.c b/gcc/testsuite/gcc.c-torture/noncompile/930622-1.c
new file mode 100644
index 00000000000..27bb9ebd2f2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/930622-1.c
@@ -0,0 +1,6 @@
+f ()
+{
+  double b;
+  b = b * 10;
+  goto c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/930622-2.c b/gcc/testsuite/gcc.c-torture/noncompile/930622-2.c
new file mode 100644
index 00000000000..a75e0c43889
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/930622-2.c
@@ -0,0 +1,6 @@
+f ()
+{
+  int i;
+  for (i--)
+    ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/930714-1.c b/gcc/testsuite/gcc.c-torture/noncompile/930714-1.c
new file mode 100644
index 00000000000..d940c550f57
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/930714-1.c
@@ -0,0 +1,25 @@
+typedef union _yystype
+{
+  int i;
+  int *iptr;
+  int (*ifunc)(int);
+  void (*vfunc)(int);
+}
+YYSTYPE;
+
+extern int f1(int k);
+
+void test()
+{
+  YYSTYPE a;
+  int (*iptr)(int);
+  int foo[5];
+
+  a = f1;
+  a = (YYSTYPE)f1;
+  a = (YYSTYPE)foo;
+  a = (YYSTYPE)(int *)foo;
+  iptr = f1;
+  a = iptr;
+  a = (YYSTYPE)iptr;
+}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/931203-1.c b/gcc/testsuite/gcc.c-torture/noncompile/931203-1.c
new file mode 100644
index 00000000000..1f5a8c3d7ad
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/931203-1.c
@@ -0,0 +1,11 @@
+typedef struct
+{
+  int x, y;
+} point_t;
+
+
+point_t
+f ()
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/940112-1.c b/gcc/testsuite/gcc.c-torture/noncompile/940112-1.c
new file mode 100644
index 00000000000..17dda8be54a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/940112-1.c
@@ -0,0 +1,7 @@
+double
+f (int x)
+{
+  double e = 1;
+  e = 1;
+  return (e)
+}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/940227-1.c b/gcc/testsuite/gcc.c-torture/noncompile/940227-1.c
new file mode 100644
index 00000000000..21bba6c9cfe
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/940227-1.c
@@ -0,0 +1,5 @@
+struct font {
+  struct {
+    char *line,*ulmask;
+  } c[2];
+} character[1] = { { {"", ""}, {"", ""} } };
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/940510-1.c b/gcc/testsuite/gcc.c-torture/noncompile/940510-1.c
new file mode 100644
index 00000000000..9882d155e97
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/940510-1.c
@@ -0,0 +1 @@
+struct { int a[]; } x = { 0 };
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/940712-1.c b/gcc/testsuite/gcc.c-torture/noncompile/940712-1.c
new file mode 100644
index 00000000000..b1b82347483
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/940712-1.c
@@ -0,0 +1,14 @@
+/* PR 4713 */
+
+#include "940712-1.h"
+#include "940712-1a.h"
+#include "940712-1b.h"
+
+/* comment start in comment error
+/* in a .c file */
+
+int main ()
+{
+    return 0;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/940712-1.h b/gcc/testsuite/gcc.c-torture/noncompile/940712-1.h
new file mode 100644
index 00000000000..183821334b1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/940712-1.h
@@ -0,0 +1,10 @@
+/* comment start in comment error
+/* in a .h file */
+
+#if 0
+#endif /* comment start in comment error
+/* after a cpp directive */
+
+/* comment start in comment error
+
+
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/940712-1a.h b/gcc/testsuite/gcc.c-torture/noncompile/940712-1a.h
new file mode 100644
index 00000000000..55ab6b844ec
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/940712-1a.h
@@ -0,0 +1,4 @@
+/* spanning a .h file */
+
+#if 0
+#endif /* comment start in comment error
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/940712-1b.h b/gcc/testsuite/gcc.c-torture/noncompile/940712-1b.h
new file mode 100644
index 00000000000..d75156c04b9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/940712-1b.h
@@ -0,0 +1,2 @@
+/* spanning a .h file */
+
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/950825-1.c b/gcc/testsuite/gcc.c-torture/noncompile/950825-1.c
new file mode 100644
index 00000000000..6104444da3b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/950825-1.c
@@ -0,0 +1 @@
+main() { return (struct x) {{y: 0}}; }
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/950921-1.c b/gcc/testsuite/gcc.c-torture/noncompile/950921-1.c
new file mode 100644
index 00000000000..bcf2f05e44f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/950921-1.c
@@ -0,0 +1,10 @@
+typedef enum
+{
+  a = (X) 0,
+  b
+} c;
+
+typedef enum
+{
+  d = (X) 0
+} e;
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/951025-1.c b/gcc/testsuite/gcc.c-torture/noncompile/951025-1.c
new file mode 100644
index 00000000000..694887290dd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/951025-1.c
@@ -0,0 +1 @@
+#include /\
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/951123-1.c b/gcc/testsuite/gcc.c-torture/noncompile/951123-1.c
new file mode 100644
index 00000000000..e9ed3dcd246
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/951123-1.c
@@ -0,0 +1,2 @@
+struct S { int a; int b[2]; };
+struct S x = { 0, [0]; };
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/951227-1.c b/gcc/testsuite/gcc.c-torture/noncompile/951227-1.c
new file mode 100644
index 00000000000..7c449c8579c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/951227-1.c
@@ -0,0 +1,2 @@
+#if 0xe-1
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/971104-1.c b/gcc/testsuite/gcc.c-torture/noncompile/971104-1.c
new file mode 100644
index 00000000000..3f0996dfb30
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/971104-1.c
@@ -0,0 +1,26 @@
+typedef unsigned short          ushort;
+struct sembuf {
+  ushort  sem_num;         
+  short   sem_op;          
+  short   sem_flg;         
+};
+union semun {
+  int val;                       
+  struct semid_ds *buf;          
+  ushort *array;                 
+  struct seminfo *__buf;         
+  void *__pad;
+};
+static union semun semctl_arg;
+static int semid;
+static void up(int sem){
+  struct sembuf sb;
+  sb.sem_num = (unsigned short) sem;
+  sb.sem_op  = 1;         
+  sb.sem_flg = 0x1000 ;  
+  if(semop(semid, &sb, 1) == -1) error("up failure");
+  if(semctl(semid, sb.sem_num, 12 , semctl_arg) == 0)
+    printf("%s had processes sleeping on it!\n",
+    ({ "MUTEX     ", "BARB_SEM 1", "BARB_SEM 2", "CUST_SEM 1", "CUST_SEM 2", "WA
+IT_SEM 1", "WAIT_SEM 2", "WAIT_SEM 3", "WAIT_SEM 4"} [( sb.sem_num )]) );
+}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/990416-1.c b/gcc/testsuite/gcc.c-torture/noncompile/990416-1.c
new file mode 100644
index 00000000000..9d4323ba1cd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/990416-1.c
@@ -0,0 +1,10 @@
+typedef int word_type;
+   
+static void
+copy_reg (unsigned int reg, frame_state *udata, frame_state *target_udata)
+{  
+  word_type *preg = get_reg_addr (reg, udata, 0);
+  word_type *ptreg = get_reg_addr (reg, target_udata, 0);
+   
+  memcpy (ptreg, preg, __builtin_dwarf_reg_size (reg));
+}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/Makefile.in b/gcc/testsuite/gcc.c-torture/noncompile/Makefile.in
new file mode 100644
index 00000000000..e6209dbc6c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+	-rm -f *.o *.diff *~ *.bad core *.x
+
+distclean:	clean
+	-rm -f Makefile config.status
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/configure.in b/gcc/testsuite/gcc.c-torture/noncompile/configure.in
new file mode 100644
index 00000000000..19f62f2dfe5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=noncompile.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/init-1.c b/gcc/testsuite/gcc.c-torture/noncompile/init-1.c
new file mode 100644
index 00000000000..52f43e81a4f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/init-1.c
@@ -0,0 +1,17 @@
+struct a
+{ double a, b, c; };
+
+struct b
+{
+  struct a arr[6];
+};
+
+static struct b a_b =
+{
+  {0,0,0},
+  {0,0,0},
+  {0,0,0},
+  {0,0,0},
+  {0,0,0},
+  {0,0,0},
+};
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/init-2.c b/gcc/testsuite/gcc.c-torture/noncompile/init-2.c
new file mode 100644
index 00000000000..52ee17b019f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/init-2.c
@@ -0,0 +1 @@
+int d[][] = { {1}, {2}, {3} };
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/invalid_asm.c b/gcc/testsuite/gcc.c-torture/noncompile/invalid_asm.c
new file mode 100644
index 00000000000..bb017f4315e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/invalid_asm.c
@@ -0,0 +1 @@
+asm_invalid_register_name(){asm("":::"this_is_an_invalid_register_name");}
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/noncompile.exp b/gcc/testsuite/gcc.c-torture/noncompile/noncompile.exp
new file mode 100644
index 00000000000..c4808b949cb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/noncompile.exp
@@ -0,0 +1,314 @@
+#   Copyright (C) 1988, 1990, 1991, 1992, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# This file was written by Jeff Law. (law@cs.utah.edu)
+
+#
+# These tests come from Torbjorn Granlund (tege@cygnus.com)
+# C torture test suite.
+#
+
+load_lib mike-gcc.exp
+
+# Test 920507-1.c
+prebase
+
+set src_code 920507-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 920616-2.c
+prebase
+
+set src_code 920616-2.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 920721-2.c
+prebase
+
+set src_code 920721-2.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 920824-1.c
+prebase
+
+set src_code 920824-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 920923-1.c
+prebase
+
+set src_code 920923-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 921102-1.c
+prebase
+
+set src_code 921102-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 921116-1.c
+prebase
+
+set src_code 921116-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 930301-1.c
+prebase
+
+set src_code 930301-1.c
+set compiler_output ".*:4:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 930622-1.c
+prebase
+
+set src_code 930622-1.c
+set compiler_output ".*:5:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 930622-2.c
+prebase
+
+set src_code 930622-2.c
+set compiler_output ".*:4:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 930714-1.c
+prebase
+
+set src_code 930714-1.c
+# Not really sure what the error should be here...
+set compiler_output ".*:18.*:23"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+# Test 931203-1.c
+prebase
+
+set src_code 931203-1.c
+set compiler_output ".*:10"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 940112-1.c
+prebase
+
+set src_code 940112-1.c
+set compiler_output ".*:7"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 940227-1.c
+prebase
+
+set src_code 940227-1.c
+set compiler_output ".*:5.*:5"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 940510-1.c
+prebase
+
+set src_code 940510-1.c
+set compiler_output ".*:1.*:1"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 940712-1.c
+prebase
+
+set src_code 940712-1.c
+set compiler_output ".*:8.*:4"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 950825-1.c
+prebase
+set src_code 950825-1.c
+set compiler_output ".*:1.*:1.*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 950921-1.c
+prebase
+set src_code 950921-1.c
+set compiler_output ".*:3.*:3.*:9.*:9:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 951025-1.c
+prebase
+set src_code 951025-1.c
+set compiler_output ".*:\[12\]:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 951123-1.c
+prebase
+set src_code 951123-1.c
+set compiler_output ".*:2:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 951227-1.c
+prebase
+set src_code 951227-1.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test 971104-1.c
+prebase
+set src_code 971104-1.c
+set compiler_output ".*:25:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+# Test 990416-1.c
+prebase
+set src_code 990416-1.c
+set compiler_output ".*:4:.*:6:.*:6:.*:6:.*:6:.*:6:.*:7:.*:7:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+# Test init-1.c
+prebase
+set src_code init-1.c
+set compiler_output ".*:12.*:12.*:13.*:13.*:14.*:14.*:15.*:15.*:16.*:16:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test init-2.c
+prebase
+set src_code init-2.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test invalid_asm.c
+prebase
+set src_code invalid_asm.c
+set compiler_output ".*:1:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
+
+
+# Test va-arg-1.c
+# It is debatable if this test should be included at all.
+# varags may be implemented by macros, which may not actually
+# reference the bogus argument.
+prebase
+
+set src_code va-arg-1.c
+set compiler_output ".*:6:"
+
+set groups {passed gcc-noncompile}
+
+postbase $src_code $run $groups
diff --git a/gcc/testsuite/gcc.c-torture/noncompile/va-arg-1.c b/gcc/testsuite/gcc.c-torture/noncompile/va-arg-1.c
new file mode 100644
index 00000000000..0285872860d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/noncompile/va-arg-1.c
@@ -0,0 +1,8 @@
+#include <stdarg.h>
+
+f (int x, ...)
+{
+  va_list args;
+  va_start (args, bogus_variable);
+  va_end (args);
+}
diff --git a/gcc/testsuite/gcc.c-torture/special/920413-1.c b/gcc/testsuite/gcc.c-torture/special/920413-1.c
new file mode 100644
index 00000000000..a3e06139a5d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/920413-1.c
@@ -0,0 +1 @@
+x(b){unsigned long c;c=4294967295U/(unsigned long)b;}
diff --git a/gcc/testsuite/gcc.c-torture/special/920520-1.c b/gcc/testsuite/gcc.c-torture/special/920520-1.c
new file mode 100644
index 00000000000..6b1cd7b17c4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/920520-1.c
@@ -0,0 +1 @@
+f(){asm("%0"::"r"(1.5F));}g(){asm("%0"::"r"(1.5));}
diff --git a/gcc/testsuite/gcc.c-torture/special/920521-1.c b/gcc/testsuite/gcc.c-torture/special/920521-1.c
new file mode 100644
index 00000000000..95b949798dc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/920521-1.c
@@ -0,0 +1 @@
+f(){asm("f":::"cc");}g(x,y){asm("g"::"%r"(x), "r"(y));}
diff --git a/gcc/testsuite/gcc.c-torture/special/920717-x.c b/gcc/testsuite/gcc.c-torture/special/920717-x.c
new file mode 100644
index 00000000000..07601e397f0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/920717-x.c
@@ -0,0 +1,3 @@
+/* 920717-1.c */
+
+const char s[]="foo";
diff --git a/gcc/testsuite/gcc.c-torture/special/920717-y.c b/gcc/testsuite/gcc.c-torture/special/920717-y.c
new file mode 100644
index 00000000000..eaffa5e4bb7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/920717-y.c
@@ -0,0 +1,8 @@
+/* 920717-y.c */
+
+extern const char s[];
+
+main()
+{
+	puts(s);
+}
diff --git a/gcc/testsuite/gcc.c-torture/special/920730-1.c b/gcc/testsuite/gcc.c-torture/special/920730-1.c
new file mode 100644
index 00000000000..d97d873634d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/920730-1.c
@@ -0,0 +1,32 @@
+/* 920730-1.c */
+
+f1()
+{
+	int b=0x80000000;
+	return b>=0x80000000;
+}
+
+f2()
+{
+	int b=0x80000001;
+	return b>=0x80000001;
+}
+
+f3()
+{
+	int b=0x7fffffff;
+	return b>=0x7fffffff;
+}
+
+f4()
+{
+	int b=0xffffffff;
+	return b>=0xffffffff;
+}
+
+main ()
+{
+	if((f1()&f2()&f3()&f4())!=1)
+		abort();
+		exit(0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/special/921210-1.c b/gcc/testsuite/gcc.c-torture/special/921210-1.c
new file mode 100644
index 00000000000..bbbf39a314b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/921210-1.c
@@ -0,0 +1,4 @@
+#define a1(y) (y+1)
+#define a2(y) a1(y)+1
+#define f a->f
+a2(f)
diff --git a/gcc/testsuite/gcc.c-torture/special/930510-1.c b/gcc/testsuite/gcc.c-torture/special/930510-1.c
new file mode 100644
index 00000000000..54ad858a5e2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/930510-1.c
@@ -0,0 +1,3 @@
+#define ugly 3
+#ugly "foobar" 3	/* { dg-error "invalid" "invalid directive" } */
+int main() { exit (0); }
diff --git a/gcc/testsuite/gcc.c-torture/special/951130-1.c b/gcc/testsuite/gcc.c-torture/special/951130-1.c
new file mode 100644
index 00000000000..c06ba075ff6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/951130-1.c
@@ -0,0 +1,2 @@
+unsigned long long x = -(unsigned long long)(-(long long)(((unsigned long
+long)0 - 1) >> 1) - 1);
diff --git a/gcc/testsuite/gcc.c-torture/special/960224-1.c b/gcc/testsuite/gcc.c-torture/special/960224-1.c
new file mode 100644
index 00000000000..de0a6ae7227
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/960224-1.c
@@ -0,0 +1,6 @@
+#if 0
+#if 0
+#endif \
+\
+
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/special/960224-2.c b/gcc/testsuite/gcc.c-torture/special/960224-2.c
new file mode 100644
index 00000000000..3d696940640
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/960224-2.c
@@ -0,0 +1,4 @@
+#if 0
+#if 0
+#endif /
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/special/981006-1.c b/gcc/testsuite/gcc.c-torture/special/981006-1.c
new file mode 100644
index 00000000000..6af6d9a8ea5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/981006-1.c
@@ -0,0 +1,50 @@
+/* Test that tablejump insns are correctly handled.  If the compiler
+   loses track of the jump targets, it will report that x and y can be
+   used uninitialized.
+
+   This is broken in egcs 1998/10/06 for mips in pic mode.  */
+/* { dg-do compile } */
+
+int foo (int a, int b)
+{
+  __label__ z;
+  int x; /* { dg-bogus "warning: `.' might be used uninitialized in this function" } */
+  int y; /* { dg-bogus "warning: `.' might be used uninitialized in this function" } */
+  static void *p;
+
+  switch (a) {
+  case 2:
+    x = 4;
+    break;
+  case 4:
+    x = 6;
+    break;
+  case 8: case 10: case 13: case 11: case 17: case 19:
+    x = 7;
+    break;
+  default:
+    x = -1;
+    break;
+  }
+  switch (b) {
+  case 2:
+    y = 4;
+    break;
+  case 4:
+    y = 6;
+    break;
+  case 8: case 10: case 13: case 11: case 17: case 19:
+    y = 7;
+    break;
+  default:
+    y = -1;
+    break;
+  }
+ z:
+  p = &&z;
+  return x * y;
+}
+int main (int argc, char *argv[])
+{
+  return 1 == foo (argc, argc + 1);
+}
diff --git a/gcc/testsuite/gcc.c-torture/special/Makefile.in b/gcc/testsuite/gcc.c-torture/special/Makefile.in
new file mode 100644
index 00000000000..e6209dbc6c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+	-rm -f *.o *.diff *~ *.bad core *.x
+
+distclean:	clean
+	-rm -f Makefile config.status
diff --git a/gcc/testsuite/gcc.c-torture/special/configure.in b/gcc/testsuite/gcc.c-torture/special/configure.in
new file mode 100644
index 00000000000..b9cbac3fd77
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=special.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/gcc.c-torture/special/eeprof-1.c b/gcc/testsuite/gcc.c-torture/special/eeprof-1.c
new file mode 100644
index 00000000000..6dad7ec5a73
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/eeprof-1.c
@@ -0,0 +1,67 @@
+#define ASSERT(X)	if (!(X)) abort ();
+#define NOCHK __attribute__ ((no_instrument_function))
+
+int entry_calls, exit_calls;
+void (*last_fn_entered)();
+void (*last_fn_exited)();
+
+int main () NOCHK;
+
+void foo ()
+{
+  ASSERT (last_fn_entered == foo);
+}
+
+static void foo2 ()
+{
+  ASSERT (entry_calls == 1 && exit_calls == 0);
+  ASSERT (last_fn_entered == foo2);
+  foo ();
+  ASSERT (entry_calls == 2 && exit_calls == 1);
+  ASSERT (last_fn_entered == foo);
+  ASSERT (last_fn_exited == foo);
+}
+
+void nfoo (void) NOCHK;
+void nfoo ()
+{
+  ASSERT (entry_calls == 2 && exit_calls == 2);
+  ASSERT (last_fn_entered == foo);
+  ASSERT (last_fn_exited == foo2);
+  foo ();
+  ASSERT (entry_calls == 3 && exit_calls == 3);
+  ASSERT (last_fn_entered == foo);
+  ASSERT (last_fn_exited == foo);
+}
+
+int main ()
+{
+  ASSERT (entry_calls == 0 && exit_calls == 0);
+
+  foo2 ();
+
+  ASSERT (entry_calls == 2 && exit_calls == 2);
+  ASSERT (last_fn_entered == foo);
+  ASSERT (last_fn_exited == foo2);
+
+  nfoo ();
+
+  ASSERT (entry_calls == 3 && exit_calls == 3);
+  ASSERT (last_fn_entered == foo);
+
+  return 0;
+}
+
+void __cyg_profile_func_enter (void (*fn)(), void (*parent)()) NOCHK;
+void __cyg_profile_func_exit (void (*fn)(), void (*parent)()) NOCHK;
+
+void __cyg_profile_func_enter (void (*fn)(), void (*parent)())
+{
+  entry_calls++;
+  last_fn_entered = fn;
+}
+void __cyg_profile_func_exit (void (*fn)(), void (*parent)())
+{
+  exit_calls++;
+  last_fn_exited = fn;
+}
diff --git a/gcc/testsuite/gcc.c-torture/special/special.exp b/gcc/testsuite/gcc.c-torture/special/special.exp
new file mode 100644
index 00000000000..d37d18c8a1d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/special/special.exp
@@ -0,0 +1,116 @@
+# Copyright (C) 1988, 90-96, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+
+#
+# These tests come from Torbjorn Granlund (tege@cygnus.com)
+# C torture test suite.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+load_lib gcc-dg.exp
+
+################## ADD NEXT CASE HERE (NOT AT THE END) ##################
+
+# 981006-1
+# For MIPS at least, pic is needed to trigger the problem.
+dg-init
+if { [istarget rs6000-*-aix*]
+     || [istarget powerpc*-*-aix*]
+     || [istarget arm*-*-*]
+} {
+    set extra_flags ""
+} else {
+    set extra_flags "-fpic"
+}
+dg-runtest $srcdir/$subdir/981006-1.c "-Wuninitialized -O2 $extra_flags" ""
+dg-finish
+
+# 921210-1
+set lines [gcc_target_compile $srcdir/$subdir/921210-1.c "" preprocess ""]
+set lines [prune [split [prune_warnings [prune_gcc_output $lines]] "\n"] ""]
+set line [lindex $lines [expr [llength $lines]-1]]
+regsub -all " " $line "" clean
+if [expr [string compare $clean "(a->f+1)+1"]==0] then {
+    pass "921210-1.c"
+} else {
+    fail "921210-1.c"
+}
+
+# 920521-1
+c-torture 920521-1.c "-S"
+
+# 920520-1
+c-torture 920520-1.c "-S"
+
+# 920717-1
+if [isnative] then {
+    set lines [gcc_target_compile "$srcdir/$subdir/920717-x.c" "920717-x.o" object {additional_flags="-w"}]
+    if ![string match "" $lines] then {
+	fail "920717-x.c"
+    } else {
+	# This is a completely bogus test. Sorry.
+	catch exec "rm -f 920717-y.o"
+	send_log "cc -c $srcdir/$subdir/920717-y.c 2>/dev/null >/dev/null\n"
+	catch exec "cc -c $srcdir/$subdir/920717-y.c 2>/dev/null >/dev/null"
+	if ![file exists "920717-y.o"] then {
+	    send_log "c89 -c $srcdir/$subdir/920717-y.c 2>/dev/null >/dev/null\n"
+	    catch exec "c89 -c $srcdir/$subdir/920717-y.c 2>/dev/null >/dev/null"
+	}
+	if [file exists "920717-y.o"] then {
+	    set lines [gcc_target_compile "920717-y.o x.o" "x" executable ""]
+	    if [string match "" $lines] then {
+		pass "920717-1.c"
+	    } else {
+		fail "920717-1.c"
+	    }
+	}
+    }
+}
+
+# 920730-1
+if [isnative] then {
+    c-torture "920730-1.c"
+    c-torture "920730-1.c" "-traditional"
+}
+
+# 920413-1
+c-torture 920413-1.c "-Wtraditional"
+
+# 930510-1
+dg-init
+dg-runtest $srcdir/$subdir/930510-1.c "" ""
+dg-finish
+
+# 951130-1
+c-torture 951130-1.c "-Werror"
+
+# 960224-1
+c-torture 960224-1.c "-E -ansi -pedantic-errors"
+
+# 960224-2
+#c-torture 960224-2.c "-E -ansi -pedantic-errors"
+
+c-torture-execute $srcdir/$subdir/eeprof-1.c "-finstrument-functions"
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/386.c b/gcc/testsuite/gcc.c-torture/unsorted/386.c
new file mode 100644
index 00000000000..432cdaddd12
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/386.c
@@ -0,0 +1,23 @@
+foo (a, p)
+     int *p;
+{
+  p[0] = a;
+  a = (short) a;
+  return a;
+}
+
+main ()
+{
+  int i;
+  foobar (i, &i);
+}
+
+
+foobar (a, b)
+{
+  int c;
+
+  c = a % b;
+  a = a / b;
+  return a + b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/86.c b/gcc/testsuite/gcc.c-torture/unsorted/86.c
new file mode 100644
index 00000000000..deea85ee2f4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/86.c
@@ -0,0 +1,19 @@
+m32 (a)
+     int *a;
+{
+  a[1] = a[0];
+}
+
+m16 (a)
+     short *a;
+{
+  a[1] = a[0];
+}
+
+
+m8 (a)
+     char *a;
+{
+  a[1] = a[0];
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG1.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG1.c
new file mode 100644
index 00000000000..ada8eaf49c7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG1.c
@@ -0,0 +1,37 @@
+struct _XtTextSource {
+	/* ... */
+    	void (* SetSelection)();
+	/* ... */
+    };
+
+typedef struct _XtTextSource *XtTextSource;
+
+typedef struct _TextPart {
+    	XtTextSource source;
+	/* ... */
+} TextPart;
+
+typedef struct _TextRec {
+	/* ... */
+	TextPart    text;
+} TextRec;
+
+typedef struct _TextRec      *TextWidget;
+
+
+void XtTextUnsetSelection(w)
+    TextWidget          w;		   /* original is: Widget w; */
+{
+    register TextWidget ctx = (TextWidget) w;
+    void (*nullProc)() = 0;
+
+/*
+ * the following line causes the error, when optimizing:
+ */
+
+    if (ctx->text.source->SetSelection != nullProc) {
+
+	foo();
+
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG11.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG11.c
new file mode 100644
index 00000000000..fe2923a97f0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG11.c
@@ -0,0 +1,29 @@
+#define DD 2410065408
+
+unsigned
+foo (d)
+     double d;
+{
+  return d;
+}
+
+#if foobar
+
+main ()
+{
+#if bar
+  unsigned u = DD;
+  double d = (double) u;
+#else
+  double d = (double) DD;
+#endif
+  printf ("%u = %u = %lf\n", foo ((double) DD), foo (d), d);
+}
+#else
+
+main ()
+{
+  printf ("%lf\n", (double) ((unsigned) DD));
+  foo ((double) DD);
+}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG12.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG12.c
new file mode 100644
index 00000000000..b32fa607176
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG12.c
@@ -0,0 +1,5 @@
+long long
+main ()
+{
+  return 1.1e10;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG13.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG13.c
new file mode 100644
index 00000000000..9a302b95152
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG13.c
@@ -0,0 +1,19 @@
+struct tree_common
+{
+  int uid;
+  unsigned int code : 8;
+  unsigned int code2 : 8;
+  unsigned external_attr : 1;
+  unsigned public_attr : 1;
+
+};
+
+static int
+duplicate_decls (x)
+     register struct tree_common *x;
+{
+  if (x->external_attr)
+    if (x->code)
+      if (x->code2)
+	x->public_attr = 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG16.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG16.c
new file mode 100644
index 00000000000..daeae2ca562
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG16.c
@@ -0,0 +1,6 @@
+setgetlen (a)
+     int *a;
+{
+  while (*a++ & 0x80000000)
+    ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG17.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG17.c
new file mode 100644
index 00000000000..920587046ed
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG17.c
@@ -0,0 +1,8 @@
+double d;
+
+main()
+{
+  int i;
+
+  i = (int) d;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG18.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG18.c
new file mode 100644
index 00000000000..ed586a7f9d6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG18.c
@@ -0,0 +1,5 @@
+main()
+{
+  if ((signed int) 1 < (signed int) -2147483648)
+    printf("true\n");
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG2.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG2.c
new file mode 100644
index 00000000000..6dc30be6502
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG2.c
@@ -0,0 +1,8 @@
+BUG2 (p) int *p;
+{
+  int a = 0;
+  if (*p == a)
+    return 0;
+  else
+    return 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG21.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG21.c
new file mode 100644
index 00000000000..c8a1157cc46
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG21.c
@@ -0,0 +1,22 @@
+typedef struct {
+	int knock_on_wood;		/* leave it out and it works. */
+	int f1;
+} FOO;
+
+typedef struct {
+	FOO *b1;
+} BAR;
+
+Nase ()
+{
+	int i, j;
+	FOO *foop;
+	BAR *barp;
+
+	for (i = 0; i < 2; i++) {
+		foop = &barp->b1[i];
+		for (j = 0; j < foop->f1; j++) {
+			/* dummy() */;		/* put it in and it works. */
+		}
+	}
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG22.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG22.c
new file mode 100644
index 00000000000..9fd95254d3d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG22.c
@@ -0,0 +1,6 @@
+
+void
+Rotate (float angle)
+{
+    float mag = (angle < 0) ? -angle : angle;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG23.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG23.c
new file mode 100644
index 00000000000..1ff429ef0ac
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG23.c
@@ -0,0 +1,18 @@
+main()
+{
+  static char static_char_array[1];
+  static char *static_char_pointer;
+  static char static_char;
+  char  char_array[1];
+  char *char_pointer;
+  char  character;
+
+  char *cp, c;
+
+  c = cp - static_char_array;   /* error */
+  c = cp - static_char_pointer;
+  c = cp - &static_char;        /* error */
+  c = cp - char_array;
+  c = cp - char_pointer;
+  c = cp - &character;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG24.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG24.c
new file mode 100644
index 00000000000..7627a3ddcdd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG24.c
@@ -0,0 +1,15 @@
+struct ack {
+    char a, b, c;
+};
+
+main()
+{
+   struct ack bad;
+
+   foo(bad);
+}
+
+foo(c)
+   struct ack c;
+{
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG25.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG25.c
new file mode 100644
index 00000000000..57441706125
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG25.c
@@ -0,0 +1,5 @@
+
+foo (a)
+{
+  __builtin_ffs (a);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG3.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG3.c
new file mode 100644
index 00000000000..30e6622a566
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG3.c
@@ -0,0 +1,8 @@
+BUG2 (p) char *p;
+{
+  int a = 0;
+  if (*p == a)
+    return 0;
+  else
+    return 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG4.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG4.c
new file mode 100644
index 00000000000..be6a14989c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG4.c
@@ -0,0 +1,20 @@
+int foo()
+{
+	char c;
+
+ 	return (c ^ 30  ) > (c ^ 40 );
+/*
+  these also get the signal :
+ 	return (c ^ 30  ) == (c ^ 40 );
+ 	return ((int)c ^ 30  ) > (c ^ 40 );
+  also fails if c is "extern char"
+
+  these are ok :
+ 	return (c + 30  ) > (c ^ 40 );
+ 	return (c ^ 30  ) > (c + 40 );
+ 	return (c ^ 30  ) + (c ^ 40 );
+ 	return ('a' ^ 30  ) > (c ^ 40 );
+ 	return (c ^ 40 );
+ 	return (c ^ 30  ) > (c ^ 40 );
+*/
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG5.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG5.c
new file mode 100644
index 00000000000..9bed7136f59
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG5.c
@@ -0,0 +1,18 @@
+enum bar
+{
+  one,
+  two
+};
+
+enum bar foo;
+
+void bar()
+{
+  switch (foo)
+  {
+    case one:
+    case two:
+      printf ("one to two\n");
+    break;
+  }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/BUG6.c b/gcc/testsuite/gcc.c-torture/unsorted/BUG6.c
new file mode 100644
index 00000000000..b1394650964
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/BUG6.c
@@ -0,0 +1,8 @@
+main()
+{
+  unsigned long L;
+  double D;
+  D = L = -3;
+  printf("L=%lu, D=%g\n", L, D);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/DFcmp.c b/gcc/testsuite/gcc.c-torture/unsorted/DFcmp.c
new file mode 100644
index 00000000000..b32b0ecc6ab
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/DFcmp.c
@@ -0,0 +1,280 @@
+#define type double
+
+type glob0, glob1;
+
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)((int)&glob0))
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)((int)&glob1))
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+reg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= reg1) return 1; else return 0;}
+
+reg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= indreg1) return 1; else return 0;}
+
+reg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= imm1) return 1; else return 0;}
+
+reg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= limm1) return 1; else return 0;}
+
+reg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adr1) return 1; else return 0;}
+
+reg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrreg1) return 1; else return 0;}
+
+reg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrx1) return 1; else return 0;}
+
+reg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= regx1) return 1; else return 0;}
+
+indreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= reg1) return 1; else return 0;}
+
+indreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= indreg1) return 1; else return 0;}
+
+indreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= imm1) return 1; else return 0;}
+
+indreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= limm1) return 1; else return 0;}
+
+indreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adr1) return 1; else return 0;}
+
+indreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrreg1) return 1; else return 0;}
+
+indreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrx1) return 1; else return 0;}
+
+indreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= regx1) return 1; else return 0;}
+
+imm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= reg1) return 1; else return 0;}
+
+imm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= indreg1) return 1; else return 0;}
+
+imm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= imm1) return 1; else return 0;}
+
+imm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= limm1) return 1; else return 0;}
+
+imm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adr1) return 1; else return 0;}
+
+imm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrreg1) return 1; else return 0;}
+
+imm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrx1) return 1; else return 0;}
+
+imm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= regx1) return 1; else return 0;}
+
+limm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= reg1) return 1; else return 0;}
+
+limm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= indreg1) return 1; else return 0;}
+
+limm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= imm1) return 1; else return 0;}
+
+limm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= limm1) return 1; else return 0;}
+
+limm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adr1) return 1; else return 0;}
+
+limm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrreg1) return 1; else return 0;}
+
+limm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrx1) return 1; else return 0;}
+
+limm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= regx1) return 1; else return 0;}
+
+adr0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= reg1) return 1; else return 0;}
+
+adr0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= indreg1) return 1; else return 0;}
+
+adr0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= imm1) return 1; else return 0;}
+
+adr0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= limm1) return 1; else return 0;}
+
+adr0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adr1) return 1; else return 0;}
+
+adr0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrreg1) return 1; else return 0;}
+
+adr0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrx1) return 1; else return 0;}
+
+adr0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= regx1) return 1; else return 0;}
+
+adrreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= reg1) return 1; else return 0;}
+
+adrreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= indreg1) return 1; else return 0;}
+
+adrreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= imm1) return 1; else return 0;}
+
+adrreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= limm1) return 1; else return 0;}
+
+adrreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adr1) return 1; else return 0;}
+
+adrreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrreg1) return 1; else return 0;}
+
+adrreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrx1) return 1; else return 0;}
+
+adrreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= regx1) return 1; else return 0;}
+
+adrx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= reg1) return 1; else return 0;}
+
+adrx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= indreg1) return 1; else return 0;}
+
+adrx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= imm1) return 1; else return 0;}
+
+adrx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= limm1) return 1; else return 0;}
+
+adrx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adr1) return 1; else return 0;}
+
+adrx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrreg1) return 1; else return 0;}
+
+adrx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrx1) return 1; else return 0;}
+
+adrx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= regx1) return 1; else return 0;}
+
+regx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= reg1) return 1; else return 0;}
+
+regx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= indreg1) return 1; else return 0;}
+
+regx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= imm1) return 1; else return 0;}
+
+regx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= limm1) return 1; else return 0;}
+
+regx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adr1) return 1; else return 0;}
+
+regx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrreg1) return 1; else return 0;}
+
+regx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrx1) return 1; else return 0;}
+
+regx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= regx1) return 1; else return 0;}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/HIcmp.c b/gcc/testsuite/gcc.c-torture/unsorted/HIcmp.c
new file mode 100644
index 00000000000..eea39841b95
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/HIcmp.c
@@ -0,0 +1,280 @@
+#define type short
+
+type glob0, glob1;
+
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+reg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= reg1) return 1; else return 0;}
+
+reg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= indreg1) return 1; else return 0;}
+
+reg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= imm1) return 1; else return 0;}
+
+reg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= limm1) return 1; else return 0;}
+
+reg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adr1) return 1; else return 0;}
+
+reg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrreg1) return 1; else return 0;}
+
+reg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrx1) return 1; else return 0;}
+
+reg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= regx1) return 1; else return 0;}
+
+indreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= reg1) return 1; else return 0;}
+
+indreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= indreg1) return 1; else return 0;}
+
+indreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= imm1) return 1; else return 0;}
+
+indreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= limm1) return 1; else return 0;}
+
+indreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adr1) return 1; else return 0;}
+
+indreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrreg1) return 1; else return 0;}
+
+indreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrx1) return 1; else return 0;}
+
+indreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= regx1) return 1; else return 0;}
+
+imm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= reg1) return 1; else return 0;}
+
+imm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= indreg1) return 1; else return 0;}
+
+imm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= imm1) return 1; else return 0;}
+
+imm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= limm1) return 1; else return 0;}
+
+imm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adr1) return 1; else return 0;}
+
+imm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrreg1) return 1; else return 0;}
+
+imm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrx1) return 1; else return 0;}
+
+imm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= regx1) return 1; else return 0;}
+
+limm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= reg1) return 1; else return 0;}
+
+limm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= indreg1) return 1; else return 0;}
+
+limm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= imm1) return 1; else return 0;}
+
+limm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= limm1) return 1; else return 0;}
+
+limm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adr1) return 1; else return 0;}
+
+limm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrreg1) return 1; else return 0;}
+
+limm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrx1) return 1; else return 0;}
+
+limm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= regx1) return 1; else return 0;}
+
+adr0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= reg1) return 1; else return 0;}
+
+adr0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= indreg1) return 1; else return 0;}
+
+adr0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= imm1) return 1; else return 0;}
+
+adr0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= limm1) return 1; else return 0;}
+
+adr0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adr1) return 1; else return 0;}
+
+adr0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrreg1) return 1; else return 0;}
+
+adr0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrx1) return 1; else return 0;}
+
+adr0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= regx1) return 1; else return 0;}
+
+adrreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= reg1) return 1; else return 0;}
+
+adrreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= indreg1) return 1; else return 0;}
+
+adrreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= imm1) return 1; else return 0;}
+
+adrreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= limm1) return 1; else return 0;}
+
+adrreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adr1) return 1; else return 0;}
+
+adrreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrreg1) return 1; else return 0;}
+
+adrreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrx1) return 1; else return 0;}
+
+adrreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= regx1) return 1; else return 0;}
+
+adrx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= reg1) return 1; else return 0;}
+
+adrx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= indreg1) return 1; else return 0;}
+
+adrx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= imm1) return 1; else return 0;}
+
+adrx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= limm1) return 1; else return 0;}
+
+adrx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adr1) return 1; else return 0;}
+
+adrx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrreg1) return 1; else return 0;}
+
+adrx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrx1) return 1; else return 0;}
+
+adrx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= regx1) return 1; else return 0;}
+
+regx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= reg1) return 1; else return 0;}
+
+regx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= indreg1) return 1; else return 0;}
+
+regx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= imm1) return 1; else return 0;}
+
+regx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= limm1) return 1; else return 0;}
+
+regx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adr1) return 1; else return 0;}
+
+regx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrreg1) return 1; else return 0;}
+
+regx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrx1) return 1; else return 0;}
+
+regx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= regx1) return 1; else return 0;}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/HIset.c b/gcc/testsuite/gcc.c-torture/unsorted/HIset.c
new file mode 100644
index 00000000000..8108fbb27c4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/HIset.c
@@ -0,0 +1,216 @@
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)(int)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)(int)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+int glob0, glob1;
+
+#define type short
+
+reg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = reg1;  }
+
+reg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = indreg1;  }
+
+reg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = imm1;  }
+
+reg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = limm1;  }
+
+reg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adr1;  }
+
+reg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adrreg1;  }
+
+reg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adrx1;  }
+
+reg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = regx1;  }
+
+indreg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = reg1;  }
+
+indreg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = indreg1;  }
+
+indreg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = imm1;  }
+
+indreg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = limm1;  }
+
+indreg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adr1;  }
+
+indreg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adrreg1;  }
+
+indreg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adrx1;  }
+
+indreg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = regx1;  }
+
+adr0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = reg1;  }
+
+adr0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = indreg1;  }
+
+adr0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = imm1;  }
+
+adr0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = limm1;  }
+
+adr0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adr1;  }
+
+adr0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adrreg1;  }
+
+adr0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adrx1;  }
+
+adr0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = regx1;  }
+
+adrreg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = reg1;  }
+
+adrreg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = indreg1;  }
+
+adrreg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = imm1;  }
+
+adrreg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = limm1;  }
+
+adrreg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adr1;  }
+
+adrreg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adrreg1;  }
+
+adrreg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adrx1;  }
+
+adrreg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = regx1;  }
+
+adrx0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = reg1;  }
+
+adrx0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = indreg1;  }
+
+adrx0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = imm1;  }
+
+adrx0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = limm1;  }
+
+adrx0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adr1;  }
+
+adrx0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adrreg1;  }
+
+adrx0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adrx1;  }
+
+adrx0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = regx1;  }
+
+regx0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = reg1;  }
+
+regx0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = indreg1;  }
+
+regx0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = imm1;  }
+
+regx0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = limm1;  }
+
+regx0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adr1;  }
+
+regx0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adrreg1;  }
+
+regx0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adrx1;  }
+
+regx0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = regx1;  }
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/Makefile.in b/gcc/testsuite/gcc.c-torture/unsorted/Makefile.in
new file mode 100644
index 00000000000..e6209dbc6c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+	-rm -f *.o *.diff *~ *.bad core *.x
+
+distclean:	clean
+	-rm -f Makefile config.status
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/PYRBUG.c b/gcc/testsuite/gcc.c-torture/unsorted/PYRBUG.c
new file mode 100644
index 00000000000..c64c3f5e1b2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/PYRBUG.c
@@ -0,0 +1,17 @@
+typedef struct
+{
+  int v;
+  int h;
+} Point;
+
+typedef struct
+{
+  int top, left, bottom, right;
+} Rect;
+
+int
+x_PtInRect (Point pt, Rect *r)
+{
+  return  pt.v >= r->top  && pt.v < r->bottom
+    && pt.h >= r->left && pt.h < r->right;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/QIcmp.c b/gcc/testsuite/gcc.c-torture/unsorted/QIcmp.c
new file mode 100644
index 00000000000..c5161646f2c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/QIcmp.c
@@ -0,0 +1,280 @@
+#define type signed char
+
+type glob0, glob1;
+
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+reg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= reg1) return 1; else return 0;}
+
+reg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= indreg1) return 1; else return 0;}
+
+reg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= imm1) return 1; else return 0;}
+
+reg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= limm1) return 1; else return 0;}
+
+reg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adr1) return 1; else return 0;}
+
+reg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrreg1) return 1; else return 0;}
+
+reg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrx1) return 1; else return 0;}
+
+reg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= regx1) return 1; else return 0;}
+
+indreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= reg1) return 1; else return 0;}
+
+indreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= indreg1) return 1; else return 0;}
+
+indreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= imm1) return 1; else return 0;}
+
+indreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= limm1) return 1; else return 0;}
+
+indreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adr1) return 1; else return 0;}
+
+indreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrreg1) return 1; else return 0;}
+
+indreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrx1) return 1; else return 0;}
+
+indreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= regx1) return 1; else return 0;}
+
+imm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= reg1) return 1; else return 0;}
+
+imm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= indreg1) return 1; else return 0;}
+
+imm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= imm1) return 1; else return 0;}
+
+imm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= limm1) return 1; else return 0;}
+
+imm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adr1) return 1; else return 0;}
+
+imm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrreg1) return 1; else return 0;}
+
+imm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrx1) return 1; else return 0;}
+
+imm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= regx1) return 1; else return 0;}
+
+limm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= reg1) return 1; else return 0;}
+
+limm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= indreg1) return 1; else return 0;}
+
+limm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= imm1) return 1; else return 0;}
+
+limm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= limm1) return 1; else return 0;}
+
+limm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adr1) return 1; else return 0;}
+
+limm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrreg1) return 1; else return 0;}
+
+limm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrx1) return 1; else return 0;}
+
+limm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= regx1) return 1; else return 0;}
+
+adr0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= reg1) return 1; else return 0;}
+
+adr0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= indreg1) return 1; else return 0;}
+
+adr0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= imm1) return 1; else return 0;}
+
+adr0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= limm1) return 1; else return 0;}
+
+adr0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adr1) return 1; else return 0;}
+
+adr0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrreg1) return 1; else return 0;}
+
+adr0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrx1) return 1; else return 0;}
+
+adr0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= regx1) return 1; else return 0;}
+
+adrreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= reg1) return 1; else return 0;}
+
+adrreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= indreg1) return 1; else return 0;}
+
+adrreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= imm1) return 1; else return 0;}
+
+adrreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= limm1) return 1; else return 0;}
+
+adrreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adr1) return 1; else return 0;}
+
+adrreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrreg1) return 1; else return 0;}
+
+adrreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrx1) return 1; else return 0;}
+
+adrreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= regx1) return 1; else return 0;}
+
+adrx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= reg1) return 1; else return 0;}
+
+adrx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= indreg1) return 1; else return 0;}
+
+adrx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= imm1) return 1; else return 0;}
+
+adrx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= limm1) return 1; else return 0;}
+
+adrx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adr1) return 1; else return 0;}
+
+adrx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrreg1) return 1; else return 0;}
+
+adrx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrx1) return 1; else return 0;}
+
+adrx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= regx1) return 1; else return 0;}
+
+regx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= reg1) return 1; else return 0;}
+
+regx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= indreg1) return 1; else return 0;}
+
+regx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= imm1) return 1; else return 0;}
+
+regx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= limm1) return 1; else return 0;}
+
+regx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adr1) return 1; else return 0;}
+
+regx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrreg1) return 1; else return 0;}
+
+regx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrx1) return 1; else return 0;}
+
+regx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= regx1) return 1; else return 0;}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/QIset.c b/gcc/testsuite/gcc.c-torture/unsorted/QIset.c
new file mode 100644
index 00000000000..212609dc864
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/QIset.c
@@ -0,0 +1,216 @@
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)(int)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)(int)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+int glob0, glob1;
+
+#define type char
+
+reg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = reg1;  }
+
+reg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = indreg1;  }
+
+reg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = imm1;  }
+
+reg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = limm1;  }
+
+reg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adr1;  }
+
+reg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adrreg1;  }
+
+reg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adrx1;  }
+
+reg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = regx1;  }
+
+indreg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = reg1;  }
+
+indreg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = indreg1;  }
+
+indreg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = imm1;  }
+
+indreg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = limm1;  }
+
+indreg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adr1;  }
+
+indreg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adrreg1;  }
+
+indreg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adrx1;  }
+
+indreg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = regx1;  }
+
+adr0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = reg1;  }
+
+adr0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = indreg1;  }
+
+adr0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = imm1;  }
+
+adr0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = limm1;  }
+
+adr0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adr1;  }
+
+adr0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adrreg1;  }
+
+adr0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adrx1;  }
+
+adr0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = regx1;  }
+
+adrreg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = reg1;  }
+
+adrreg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = indreg1;  }
+
+adrreg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = imm1;  }
+
+adrreg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = limm1;  }
+
+adrreg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adr1;  }
+
+adrreg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adrreg1;  }
+
+adrreg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adrx1;  }
+
+adrreg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = regx1;  }
+
+adrx0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = reg1;  }
+
+adrx0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = indreg1;  }
+
+adrx0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = imm1;  }
+
+adrx0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = limm1;  }
+
+adrx0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adr1;  }
+
+adrx0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adrreg1;  }
+
+adrx0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adrx1;  }
+
+adrx0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = regx1;  }
+
+regx0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = reg1;  }
+
+regx0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = indreg1;  }
+
+regx0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = imm1;  }
+
+regx0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = limm1;  }
+
+regx0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adr1;  }
+
+regx0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adrreg1;  }
+
+regx0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adrx1;  }
+
+regx0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = regx1;  }
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/SFset.c b/gcc/testsuite/gcc.c-torture/unsorted/SFset.c
new file mode 100644
index 00000000000..ad3e41b834b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/SFset.c
@@ -0,0 +1,216 @@
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)(int)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)(int)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+int glob0, glob1;
+
+#define type float
+
+reg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = reg1;  }
+
+reg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = indreg1;  }
+
+reg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = imm1;  }
+
+reg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = limm1;  }
+
+reg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adr1;  }
+
+reg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adrreg1;  }
+
+reg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adrx1;  }
+
+reg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = regx1;  }
+
+indreg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = reg1;  }
+
+indreg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = indreg1;  }
+
+indreg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = imm1;  }
+
+indreg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = limm1;  }
+
+indreg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adr1;  }
+
+indreg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adrreg1;  }
+
+indreg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adrx1;  }
+
+indreg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = regx1;  }
+
+adr0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = reg1;  }
+
+adr0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = indreg1;  }
+
+adr0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = imm1;  }
+
+adr0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = limm1;  }
+
+adr0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adr1;  }
+
+adr0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adrreg1;  }
+
+adr0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adrx1;  }
+
+adr0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = regx1;  }
+
+adrreg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = reg1;  }
+
+adrreg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = indreg1;  }
+
+adrreg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = imm1;  }
+
+adrreg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = limm1;  }
+
+adrreg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adr1;  }
+
+adrreg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adrreg1;  }
+
+adrreg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adrx1;  }
+
+adrreg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = regx1;  }
+
+adrx0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = reg1;  }
+
+adrx0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = indreg1;  }
+
+adrx0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = imm1;  }
+
+adrx0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = limm1;  }
+
+adrx0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adr1;  }
+
+adrx0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adrreg1;  }
+
+adrx0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adrx1;  }
+
+adrx0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = regx1;  }
+
+regx0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = reg1;  }
+
+regx0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = indreg1;  }
+
+regx0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = imm1;  }
+
+regx0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = limm1;  }
+
+regx0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adr1;  }
+
+regx0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adrreg1;  }
+
+regx0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adrx1;  }
+
+regx0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = regx1;  }
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/SIcmp.c b/gcc/testsuite/gcc.c-torture/unsorted/SIcmp.c
new file mode 100644
index 00000000000..30e07392467
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/SIcmp.c
@@ -0,0 +1,280 @@
+#define type int
+
+type glob0, glob1;
+
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+reg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= reg1) return 1; else return 0;}
+
+reg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= indreg1) return 1; else return 0;}
+
+reg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= imm1) return 1; else return 0;}
+
+reg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= limm1) return 1; else return 0;}
+
+reg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adr1) return 1; else return 0;}
+
+reg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrreg1) return 1; else return 0;}
+
+reg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrx1) return 1; else return 0;}
+
+reg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= regx1) return 1; else return 0;}
+
+indreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= reg1) return 1; else return 0;}
+
+indreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= indreg1) return 1; else return 0;}
+
+indreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= imm1) return 1; else return 0;}
+
+indreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= limm1) return 1; else return 0;}
+
+indreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adr1) return 1; else return 0;}
+
+indreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrreg1) return 1; else return 0;}
+
+indreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrx1) return 1; else return 0;}
+
+indreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= regx1) return 1; else return 0;}
+
+imm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= reg1) return 1; else return 0;}
+
+imm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= indreg1) return 1; else return 0;}
+
+imm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= imm1) return 1; else return 0;}
+
+imm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= limm1) return 1; else return 0;}
+
+imm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adr1) return 1; else return 0;}
+
+imm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrreg1) return 1; else return 0;}
+
+imm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrx1) return 1; else return 0;}
+
+imm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= regx1) return 1; else return 0;}
+
+limm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= reg1) return 1; else return 0;}
+
+limm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= indreg1) return 1; else return 0;}
+
+limm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= imm1) return 1; else return 0;}
+
+limm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= limm1) return 1; else return 0;}
+
+limm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adr1) return 1; else return 0;}
+
+limm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrreg1) return 1; else return 0;}
+
+limm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrx1) return 1; else return 0;}
+
+limm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= regx1) return 1; else return 0;}
+
+adr0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= reg1) return 1; else return 0;}
+
+adr0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= indreg1) return 1; else return 0;}
+
+adr0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= imm1) return 1; else return 0;}
+
+adr0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= limm1) return 1; else return 0;}
+
+adr0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adr1) return 1; else return 0;}
+
+adr0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrreg1) return 1; else return 0;}
+
+adr0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrx1) return 1; else return 0;}
+
+adr0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= regx1) return 1; else return 0;}
+
+adrreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= reg1) return 1; else return 0;}
+
+adrreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= indreg1) return 1; else return 0;}
+
+adrreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= imm1) return 1; else return 0;}
+
+adrreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= limm1) return 1; else return 0;}
+
+adrreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adr1) return 1; else return 0;}
+
+adrreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrreg1) return 1; else return 0;}
+
+adrreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrx1) return 1; else return 0;}
+
+adrreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= regx1) return 1; else return 0;}
+
+adrx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= reg1) return 1; else return 0;}
+
+adrx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= indreg1) return 1; else return 0;}
+
+adrx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= imm1) return 1; else return 0;}
+
+adrx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= limm1) return 1; else return 0;}
+
+adrx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adr1) return 1; else return 0;}
+
+adrx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrreg1) return 1; else return 0;}
+
+adrx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrx1) return 1; else return 0;}
+
+adrx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= regx1) return 1; else return 0;}
+
+regx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= reg1) return 1; else return 0;}
+
+regx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= indreg1) return 1; else return 0;}
+
+regx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= imm1) return 1; else return 0;}
+
+regx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= limm1) return 1; else return 0;}
+
+regx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adr1) return 1; else return 0;}
+
+regx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrreg1) return 1; else return 0;}
+
+regx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrx1) return 1; else return 0;}
+
+regx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= regx1) return 1; else return 0;}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/SIset.c b/gcc/testsuite/gcc.c-torture/unsorted/SIset.c
new file mode 100644
index 00000000000..74a51cd0fb4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/SIset.c
@@ -0,0 +1,216 @@
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)(int)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)(int)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+int glob0, glob1;
+
+#define type int
+
+reg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = reg1;  }
+
+reg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = indreg1;  }
+
+reg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = imm1;  }
+
+reg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = limm1;  }
+
+reg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adr1;  }
+
+reg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adrreg1;  }
+
+reg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = adrx1;  }
+
+reg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{reg0 = regx1;  }
+
+indreg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = reg1;  }
+
+indreg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = indreg1;  }
+
+indreg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = imm1;  }
+
+indreg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = limm1;  }
+
+indreg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adr1;  }
+
+indreg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adrreg1;  }
+
+indreg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = adrx1;  }
+
+indreg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{indreg0 = regx1;  }
+
+adr0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = reg1;  }
+
+adr0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = indreg1;  }
+
+adr0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = imm1;  }
+
+adr0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = limm1;  }
+
+adr0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adr1;  }
+
+adr0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adrreg1;  }
+
+adr0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = adrx1;  }
+
+adr0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adr0 = regx1;  }
+
+adrreg0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = reg1;  }
+
+adrreg0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = indreg1;  }
+
+adrreg0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = imm1;  }
+
+adrreg0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = limm1;  }
+
+adrreg0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adr1;  }
+
+adrreg0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adrreg1;  }
+
+adrreg0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = adrx1;  }
+
+adrreg0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrreg0 = regx1;  }
+
+adrx0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = reg1;  }
+
+adrx0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = indreg1;  }
+
+adrx0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = imm1;  }
+
+adrx0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = limm1;  }
+
+adrx0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adr1;  }
+
+adrx0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adrreg1;  }
+
+adrx0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = adrx1;  }
+
+adrx0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{adrx0 = regx1;  }
+
+regx0reg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = reg1;  }
+
+regx0indreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = indreg1;  }
+
+regx0imm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = imm1;  }
+
+regx0limm1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = limm1;  }
+
+regx0adr1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adr1;  }
+
+regx0adrreg1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adrreg1;  }
+
+regx0adrx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = adrx1;  }
+
+regx0regx1_set (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{regx0 = regx1;  }
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/UHIcmp.c b/gcc/testsuite/gcc.c-torture/unsorted/UHIcmp.c
new file mode 100644
index 00000000000..1e969e7103a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/UHIcmp.c
@@ -0,0 +1,280 @@
+#define type unsigned short
+
+type glob0, glob1;
+
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+reg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= reg1) return 1; else return 0;}
+
+reg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= indreg1) return 1; else return 0;}
+
+reg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= imm1) return 1; else return 0;}
+
+reg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= limm1) return 1; else return 0;}
+
+reg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adr1) return 1; else return 0;}
+
+reg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrreg1) return 1; else return 0;}
+
+reg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrx1) return 1; else return 0;}
+
+reg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= regx1) return 1; else return 0;}
+
+indreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= reg1) return 1; else return 0;}
+
+indreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= indreg1) return 1; else return 0;}
+
+indreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= imm1) return 1; else return 0;}
+
+indreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= limm1) return 1; else return 0;}
+
+indreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adr1) return 1; else return 0;}
+
+indreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrreg1) return 1; else return 0;}
+
+indreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrx1) return 1; else return 0;}
+
+indreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= regx1) return 1; else return 0;}
+
+imm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= reg1) return 1; else return 0;}
+
+imm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= indreg1) return 1; else return 0;}
+
+imm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= imm1) return 1; else return 0;}
+
+imm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= limm1) return 1; else return 0;}
+
+imm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adr1) return 1; else return 0;}
+
+imm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrreg1) return 1; else return 0;}
+
+imm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrx1) return 1; else return 0;}
+
+imm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= regx1) return 1; else return 0;}
+
+limm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= reg1) return 1; else return 0;}
+
+limm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= indreg1) return 1; else return 0;}
+
+limm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= imm1) return 1; else return 0;}
+
+limm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= limm1) return 1; else return 0;}
+
+limm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adr1) return 1; else return 0;}
+
+limm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrreg1) return 1; else return 0;}
+
+limm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrx1) return 1; else return 0;}
+
+limm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= regx1) return 1; else return 0;}
+
+adr0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= reg1) return 1; else return 0;}
+
+adr0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= indreg1) return 1; else return 0;}
+
+adr0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= imm1) return 1; else return 0;}
+
+adr0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= limm1) return 1; else return 0;}
+
+adr0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adr1) return 1; else return 0;}
+
+adr0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrreg1) return 1; else return 0;}
+
+adr0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrx1) return 1; else return 0;}
+
+adr0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= regx1) return 1; else return 0;}
+
+adrreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= reg1) return 1; else return 0;}
+
+adrreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= indreg1) return 1; else return 0;}
+
+adrreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= imm1) return 1; else return 0;}
+
+adrreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= limm1) return 1; else return 0;}
+
+adrreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adr1) return 1; else return 0;}
+
+adrreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrreg1) return 1; else return 0;}
+
+adrreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrx1) return 1; else return 0;}
+
+adrreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= regx1) return 1; else return 0;}
+
+adrx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= reg1) return 1; else return 0;}
+
+adrx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= indreg1) return 1; else return 0;}
+
+adrx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= imm1) return 1; else return 0;}
+
+adrx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= limm1) return 1; else return 0;}
+
+adrx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adr1) return 1; else return 0;}
+
+adrx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrreg1) return 1; else return 0;}
+
+adrx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrx1) return 1; else return 0;}
+
+adrx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= regx1) return 1; else return 0;}
+
+regx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= reg1) return 1; else return 0;}
+
+regx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= indreg1) return 1; else return 0;}
+
+regx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= imm1) return 1; else return 0;}
+
+regx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= limm1) return 1; else return 0;}
+
+regx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adr1) return 1; else return 0;}
+
+regx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrreg1) return 1; else return 0;}
+
+regx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrx1) return 1; else return 0;}
+
+regx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= regx1) return 1; else return 0;}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/UQIcmp.c b/gcc/testsuite/gcc.c-torture/unsorted/UQIcmp.c
new file mode 100644
index 00000000000..3e9cdebc903
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/UQIcmp.c
@@ -0,0 +1,280 @@
+#define type unsigned char
+
+type glob0, glob1;
+
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+reg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= reg1) return 1; else return 0;}
+
+reg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= indreg1) return 1; else return 0;}
+
+reg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= imm1) return 1; else return 0;}
+
+reg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= limm1) return 1; else return 0;}
+
+reg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adr1) return 1; else return 0;}
+
+reg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrreg1) return 1; else return 0;}
+
+reg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrx1) return 1; else return 0;}
+
+reg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= regx1) return 1; else return 0;}
+
+indreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= reg1) return 1; else return 0;}
+
+indreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= indreg1) return 1; else return 0;}
+
+indreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= imm1) return 1; else return 0;}
+
+indreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= limm1) return 1; else return 0;}
+
+indreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adr1) return 1; else return 0;}
+
+indreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrreg1) return 1; else return 0;}
+
+indreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrx1) return 1; else return 0;}
+
+indreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= regx1) return 1; else return 0;}
+
+imm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= reg1) return 1; else return 0;}
+
+imm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= indreg1) return 1; else return 0;}
+
+imm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= imm1) return 1; else return 0;}
+
+imm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= limm1) return 1; else return 0;}
+
+imm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adr1) return 1; else return 0;}
+
+imm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrreg1) return 1; else return 0;}
+
+imm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrx1) return 1; else return 0;}
+
+imm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= regx1) return 1; else return 0;}
+
+limm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= reg1) return 1; else return 0;}
+
+limm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= indreg1) return 1; else return 0;}
+
+limm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= imm1) return 1; else return 0;}
+
+limm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= limm1) return 1; else return 0;}
+
+limm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adr1) return 1; else return 0;}
+
+limm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrreg1) return 1; else return 0;}
+
+limm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrx1) return 1; else return 0;}
+
+limm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= regx1) return 1; else return 0;}
+
+adr0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= reg1) return 1; else return 0;}
+
+adr0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= indreg1) return 1; else return 0;}
+
+adr0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= imm1) return 1; else return 0;}
+
+adr0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= limm1) return 1; else return 0;}
+
+adr0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adr1) return 1; else return 0;}
+
+adr0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrreg1) return 1; else return 0;}
+
+adr0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrx1) return 1; else return 0;}
+
+adr0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= regx1) return 1; else return 0;}
+
+adrreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= reg1) return 1; else return 0;}
+
+adrreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= indreg1) return 1; else return 0;}
+
+adrreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= imm1) return 1; else return 0;}
+
+adrreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= limm1) return 1; else return 0;}
+
+adrreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adr1) return 1; else return 0;}
+
+adrreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrreg1) return 1; else return 0;}
+
+adrreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrx1) return 1; else return 0;}
+
+adrreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= regx1) return 1; else return 0;}
+
+adrx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= reg1) return 1; else return 0;}
+
+adrx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= indreg1) return 1; else return 0;}
+
+adrx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= imm1) return 1; else return 0;}
+
+adrx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= limm1) return 1; else return 0;}
+
+adrx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adr1) return 1; else return 0;}
+
+adrx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrreg1) return 1; else return 0;}
+
+adrx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrx1) return 1; else return 0;}
+
+adrx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= regx1) return 1; else return 0;}
+
+regx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= reg1) return 1; else return 0;}
+
+regx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= indreg1) return 1; else return 0;}
+
+regx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= imm1) return 1; else return 0;}
+
+regx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= limm1) return 1; else return 0;}
+
+regx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adr1) return 1; else return 0;}
+
+regx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrreg1) return 1; else return 0;}
+
+regx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrx1) return 1; else return 0;}
+
+regx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= regx1) return 1; else return 0;}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/USIcmp.c b/gcc/testsuite/gcc.c-torture/unsorted/USIcmp.c
new file mode 100644
index 00000000000..e2175262a42
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/USIcmp.c
@@ -0,0 +1,280 @@
+#define type unsigned int
+
+type glob0, glob1;
+
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+reg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= reg1) return 1; else return 0;}
+
+reg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= indreg1) return 1; else return 0;}
+
+reg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= imm1) return 1; else return 0;}
+
+reg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= limm1) return 1; else return 0;}
+
+reg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adr1) return 1; else return 0;}
+
+reg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrreg1) return 1; else return 0;}
+
+reg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= adrx1) return 1; else return 0;}
+
+reg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (reg0 <= regx1) return 1; else return 0;}
+
+indreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= reg1) return 1; else return 0;}
+
+indreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= indreg1) return 1; else return 0;}
+
+indreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= imm1) return 1; else return 0;}
+
+indreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= limm1) return 1; else return 0;}
+
+indreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adr1) return 1; else return 0;}
+
+indreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrreg1) return 1; else return 0;}
+
+indreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= adrx1) return 1; else return 0;}
+
+indreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (indreg0 <= regx1) return 1; else return 0;}
+
+imm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= reg1) return 1; else return 0;}
+
+imm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= indreg1) return 1; else return 0;}
+
+imm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= imm1) return 1; else return 0;}
+
+imm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= limm1) return 1; else return 0;}
+
+imm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adr1) return 1; else return 0;}
+
+imm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrreg1) return 1; else return 0;}
+
+imm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= adrx1) return 1; else return 0;}
+
+imm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (imm0 <= regx1) return 1; else return 0;}
+
+limm0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= reg1) return 1; else return 0;}
+
+limm0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= indreg1) return 1; else return 0;}
+
+limm0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= imm1) return 1; else return 0;}
+
+limm0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= limm1) return 1; else return 0;}
+
+limm0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adr1) return 1; else return 0;}
+
+limm0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrreg1) return 1; else return 0;}
+
+limm0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= adrx1) return 1; else return 0;}
+
+limm0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (limm0 <= regx1) return 1; else return 0;}
+
+adr0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= reg1) return 1; else return 0;}
+
+adr0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= indreg1) return 1; else return 0;}
+
+adr0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= imm1) return 1; else return 0;}
+
+adr0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= limm1) return 1; else return 0;}
+
+adr0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adr1) return 1; else return 0;}
+
+adr0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrreg1) return 1; else return 0;}
+
+adr0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= adrx1) return 1; else return 0;}
+
+adr0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adr0 <= regx1) return 1; else return 0;}
+
+adrreg0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= reg1) return 1; else return 0;}
+
+adrreg0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= indreg1) return 1; else return 0;}
+
+adrreg0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= imm1) return 1; else return 0;}
+
+adrreg0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= limm1) return 1; else return 0;}
+
+adrreg0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adr1) return 1; else return 0;}
+
+adrreg0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrreg1) return 1; else return 0;}
+
+adrreg0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= adrx1) return 1; else return 0;}
+
+adrreg0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrreg0 <= regx1) return 1; else return 0;}
+
+adrx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= reg1) return 1; else return 0;}
+
+adrx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= indreg1) return 1; else return 0;}
+
+adrx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= imm1) return 1; else return 0;}
+
+adrx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= limm1) return 1; else return 0;}
+
+adrx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adr1) return 1; else return 0;}
+
+adrx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrreg1) return 1; else return 0;}
+
+adrx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= adrx1) return 1; else return 0;}
+
+adrx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (adrx0 <= regx1) return 1; else return 0;}
+
+regx0reg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= reg1) return 1; else return 0;}
+
+regx0indreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= indreg1) return 1; else return 0;}
+
+regx0imm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= imm1) return 1; else return 0;}
+
+regx0limm1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= limm1) return 1; else return 0;}
+
+regx0adr1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adr1) return 1; else return 0;}
+
+regx0adrreg1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrreg1) return 1; else return 0;}
+
+regx0adrx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= adrx1) return 1; else return 0;}
+
+regx0regx1 (r0, r1, x0, x1, p0, p1)
+type r0, r1;  type *p0, *p1;
+{if (regx0 <= regx1) return 1; else return 0;}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/a.c b/gcc/testsuite/gcc.c-torture/unsorted/a.c
new file mode 100644
index 00000000000..47fb1f493f2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/a.c
@@ -0,0 +1,4 @@
+foo (a)
+{
+  return a & 65535;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/a1.c b/gcc/testsuite/gcc.c-torture/unsorted/a1.c
new file mode 100644
index 00000000000..654781d05ea
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/a1.c
@@ -0,0 +1,7 @@
+int
+foo (a, p)
+     int *p;
+{
+  p[0] = 85 * a;
+  p[1] = -86 * a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/a3.c b/gcc/testsuite/gcc.c-torture/unsorted/a3.c
new file mode 100644
index 00000000000..85d2a242630
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/a3.c
@@ -0,0 +1,12 @@
+foo (a)
+{
+  int i;
+
+  for (i = 1;  i < a; i++)
+    ;
+  {
+    int b = (int) &foo;
+
+    return (a & b) == 0;
+  }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/aa.c b/gcc/testsuite/gcc.c-torture/unsorted/aa.c
new file mode 100644
index 00000000000..61a4147afa6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/aa.c
@@ -0,0 +1,8 @@
+#define w 20
+#define c 1
+
+foo (a)
+     unsigned a;
+{
+  return ((a & ((1 << w) - 1)) << c) > 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/aaa.c b/gcc/testsuite/gcc.c-torture/unsorted/aaa.c
new file mode 100644
index 00000000000..e31fb567c1c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/aaa.c
@@ -0,0 +1,11 @@
+foo (a, b)
+{
+  int t;
+  while (b < 0)
+    {
+      t = a;
+      a = b;
+      b = t;
+    }
+  return a + b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/abs.c b/gcc/testsuite/gcc.c-torture/unsorted/abs.c
new file mode 100644
index 00000000000..6a746b12639
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/abs.c
@@ -0,0 +1,9 @@
+foo (a)
+{
+  return __builtin_abs (a);
+}
+
+main ()
+{
+  printf ("%d %d\n", foo (0x80000000), foo (12));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/ac.c b/gcc/testsuite/gcc.c-torture/unsorted/ac.c
new file mode 100644
index 00000000000..1d3c085eec1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/ac.c
@@ -0,0 +1,30 @@
+barfoo (a)
+{
+  return (a << 16) & ~0xffff;
+}
+
+foobar (a)
+{
+  return ((unsigned short) a) << 15;}
+
+foo (a)
+{
+  return (a & 0x121) << 31;
+}
+
+bar (a)
+{
+  return (a & ~0xffff) << 16;
+}
+
+main ()
+{
+  int a;
+
+  for (a = 1;  a; a += a)
+    {
+      printf ("%d", (foo (a)));
+    }
+  puts ("");
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/acc.c b/gcc/testsuite/gcc.c-torture/unsorted/acc.c
new file mode 100644
index 00000000000..a4a027a5fce
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/acc.c
@@ -0,0 +1,8 @@
+foo (a)
+{
+  int b = a + 1;
+  int c = (short) a;
+  if (b)
+    return b;
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/add.c b/gcc/testsuite/gcc.c-torture/unsorted/add.c
new file mode 100644
index 00000000000..d796e41c712
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/add.c
@@ -0,0 +1,5 @@
+foo (a, b, p)
+     int *p;
+{
+  return 34 + *p;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/add386.c b/gcc/testsuite/gcc.c-torture/unsorted/add386.c
new file mode 100644
index 00000000000..bfdffbfe2f2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/add386.c
@@ -0,0 +1,4 @@
+main (a)
+{
+  return a + 128;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/addcc.c b/gcc/testsuite/gcc.c-torture/unsorted/addcc.c
new file mode 100644
index 00000000000..cf52307aa97
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/addcc.c
@@ -0,0 +1,18 @@
+foo (p, a, b)
+     int *p;
+     int a;
+     int b;
+{
+
+  a += p[0];
+  b += p[1];
+  if (a == 0)
+    return b;
+  return a;
+}
+
+
+bar (a)
+{
+  return -a > 0 ? 1 : 2;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/andm.c b/gcc/testsuite/gcc.c-torture/unsorted/andm.c
new file mode 100644
index 00000000000..17101ae3050
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/andm.c
@@ -0,0 +1,15 @@
+foo (p)
+     int *p;
+{
+  return (*p & 255) == 0;
+}
+
+bar (a)
+{
+  return (a & 0xfff00000) == 0;
+}
+
+main ()
+{
+  printf ("%d%d\n", bar (-1), bar(0));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/andmem.c b/gcc/testsuite/gcc.c-torture/unsorted/andmem.c
new file mode 100644
index 00000000000..10bad00f445
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/andmem.c
@@ -0,0 +1,22 @@
+void p1 (p) int *p;
+{ *p &= ~0xff;
+}
+void p2 (p) int *p;
+{ *p &= ~0xff00;
+}
+void p3 (p) int *p;
+{ *p &= ~0xffff0000;
+}
+void p4 (p) int *p;
+{ *p &= ~0xffff;
+}
+
+main ()
+{
+  int a;
+
+  a = 0x12345678;  p1 (&a);  printf ("%x\n", a);
+  a = 0x12345678;  p2 (&a);  printf ("%x\n", a);
+  a = 0x12345678;  p3 (&a);  printf ("%x\n", a);
+  a = 0x12345678;  p4 (&a);  printf ("%x\n", a);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/andn.c b/gcc/testsuite/gcc.c-torture/unsorted/andn.c
new file mode 100644
index 00000000000..2e38dd0e36e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/andn.c
@@ -0,0 +1,5 @@
+foo (a)
+{
+  int b = 0x1fff;
+  return a & ~b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/andok.c b/gcc/testsuite/gcc.c-torture/unsorted/andok.c
new file mode 100644
index 00000000000..d55bd01b70d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/andok.c
@@ -0,0 +1,6 @@
+foo (a, b, p)
+     int *p;
+{
+  p[1] = a & 0xfff0000;
+  p[2] = b & 0xfff0000;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/andsi.c b/gcc/testsuite/gcc.c-torture/unsorted/andsi.c
new file mode 100644
index 00000000000..b9c3c76de03
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/andsi.c
@@ -0,0 +1,4 @@
+foo ()
+{
+  return (int)&foo;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/andsparc.c b/gcc/testsuite/gcc.c-torture/unsorted/andsparc.c
new file mode 100644
index 00000000000..62f0de003b2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/andsparc.c
@@ -0,0 +1,11 @@
+foo (int *p)
+{
+  int a, b;
+
+  a = 123456;
+  a += p[0];
+  b = p[0];
+  if (a == 0)
+    return b;
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/aos.c b/gcc/testsuite/gcc.c-torture/unsorted/aos.c
new file mode 100644
index 00000000000..77c92f677e4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/aos.c
@@ -0,0 +1,8 @@
+foo (p)
+     int *p;
+{
+  if ((int) p > 0)
+    return 1;
+  else
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/arr.c b/gcc/testsuite/gcc.c-torture/unsorted/arr.c
new file mode 100644
index 00000000000..ed56667dd75
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/arr.c
@@ -0,0 +1,9 @@
+foo (a, b, c)
+{
+  bar (a, b);
+  {
+    int arr[10];
+    arr[c] = b;
+    bar (arr[0], arr[1]);
+  }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/as.c b/gcc/testsuite/gcc.c-torture/unsorted/as.c
new file mode 100644
index 00000000000..172f88355d9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/as.c
@@ -0,0 +1,14 @@
+
+#define S 31
+#define A 17
+
+foo (a)
+     unsigned a;
+{
+  return (a >> S) & ((1 << A) - 1);
+}
+
+main ()
+{
+  printf ("%d%d\n", foo (-1), foo (0));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/ase.c b/gcc/testsuite/gcc.c-torture/unsorted/ase.c
new file mode 100644
index 00000000000..2d3d8edbd0b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/ase.c
@@ -0,0 +1,10 @@
+ase (p)
+     short *p;
+{
+  int a;
+  a = p[1];
+  p[2] = a;
+  if ((short) a)
+    p[a]++;
+  return (a == 0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/b.c b/gcc/testsuite/gcc.c-torture/unsorted/b.c
new file mode 100644
index 00000000000..498d7552af9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/b.c
@@ -0,0 +1,4 @@
+main ()
+{
+  *(short *) 25 = 123;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/b1.c b/gcc/testsuite/gcc.c-torture/unsorted/b1.c
new file mode 100644
index 00000000000..b6737594cb1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/b1.c
@@ -0,0 +1,11 @@
+foo (long long x)
+{
+  if (x--)
+    return 255;
+  return 0;
+}
+
+main ()
+{
+  printf ("%d\n", foo (0));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/b2.c b/gcc/testsuite/gcc.c-torture/unsorted/b2.c
new file mode 100644
index 00000000000..96e4556a53a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/b2.c
@@ -0,0 +1,24 @@
+
+struct s
+{
+  unsigned a : 8;
+  unsigned b : 8;
+  unsigned c : 8;
+  unsigned d : 8;
+};
+
+/*
+struct
+{
+  unsigned a : 8;
+  unsigned b : 16;
+  unsigned c : 8;
+};
+*/
+
+struct s
+foo (struct s s, int i)
+{
+  s.b = i;
+  return s;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/b3.c b/gcc/testsuite/gcc.c-torture/unsorted/b3.c
new file mode 100644
index 00000000000..af693f77931
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/b3.c
@@ -0,0 +1,12 @@
+struct tree_common
+{
+  unsigned int code : 9;
+  unsigned int code2 : 7;
+};
+
+static int
+duplicate_decls (x)
+     register struct tree_common x;
+{
+  return x.code2;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/b88.c b/gcc/testsuite/gcc.c-torture/unsorted/b88.c
new file mode 100644
index 00000000000..971c7c76d92
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/b88.c
@@ -0,0 +1,12 @@
+foo (double d)
+{
+  d = -d;
+  if (d < 0.0)
+    return 1;
+  return 2;
+}
+
+main ()
+{
+  foo (0.0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bad.c b/gcc/testsuite/gcc.c-torture/unsorted/bad.c
new file mode 100644
index 00000000000..8cc84973b72
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bad.c
@@ -0,0 +1,26 @@
+typedef union longlong
+{
+  struct {unsigned short h0, h1, h2, h3;} h;
+  struct {signed long low, high;} si;
+  struct {unsigned long low, high;} ui;
+  signed long long sll;
+  unsigned long long ull;
+} long_long;
+
+
+long long
+__negdi2 (u)
+     long long u;
+{
+  long_long uu;
+
+  uu.sll = u;
+
+  uu.si.low = -uu.si.low;
+  if (uu.si.low == 0)
+    uu.si.high = -uu.si.high;
+  else
+    uu.si.high = ~uu.si.high;
+
+  return uu.sll;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/band.c b/gcc/testsuite/gcc.c-torture/unsorted/band.c
new file mode 100644
index 00000000000..74b02fd3b34
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/band.c
@@ -0,0 +1,16 @@
+foo (a)
+{
+  return (a & (1 << 31)) != 0;
+}
+
+main ()
+{
+  if (foo (0))
+    puts ("foo");
+  else
+    puts ("bar");
+  if (foo (~0))
+    puts ("foo");
+  else
+    puts ("bar");
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bb0.c b/gcc/testsuite/gcc.c-torture/unsorted/bb0.c
new file mode 100644
index 00000000000..aab6d683fbd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bb0.c
@@ -0,0 +1,5 @@
+foo (a)
+{
+  return (a & 0xfff000) != 0;
+
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bb1.c b/gcc/testsuite/gcc.c-torture/unsorted/bb1.c
new file mode 100644
index 00000000000..3f9aebe0364
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bb1.c
@@ -0,0 +1,8 @@
+foo (a)
+{
+  int b = 32;
+  if (b & a)
+    return 1;
+  else
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bbb.c b/gcc/testsuite/gcc.c-torture/unsorted/bbb.c
new file mode 100644
index 00000000000..837dd9ecf93
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bbb.c
@@ -0,0 +1,12 @@
+struct looksets
+    {
+        int lset[10];
+    };
+
+struct looksets lkst[];
+
+flset( p )
+struct looksets *p;
+{
+    p-- > lkst;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bc.c b/gcc/testsuite/gcc.c-torture/unsorted/bc.c
new file mode 100644
index 00000000000..c713bb61b3d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bc.c
@@ -0,0 +1,4 @@
+foo (a, b)
+{
+  return a % (1 << b);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bcopy.c b/gcc/testsuite/gcc.c-torture/unsorted/bcopy.c
new file mode 100644
index 00000000000..1732b349e4d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bcopy.c
@@ -0,0 +1,64 @@
+void
+bcopy1 (s, d, c)
+     long long *s;
+     long long *d;
+     int c;
+{
+  int i;
+  c = c / 8;
+  for (i = 0;  i < c;  i++)
+    d[i] = s[i];
+}
+
+void
+bcopy2 (s, d, c)
+     long *s;
+     long *d;
+     int c;
+{
+  int i;
+  c = c / 4;
+  for (i = 0;  i < c;  i++)
+    d[i] = s[i];
+}
+
+
+void
+bcopy3 (s, d, c)
+     char *s;
+     char *d;
+     int c;
+{
+  long long z0, z1;
+  int r = d - s;
+
+  int i;
+
+  c /= 16;
+
+  z0 = *((long long *) s);
+  s += 8;
+  z1 = *((long long *) s);
+  s += 8;
+  for (i = 0; i < c; i++)
+    {
+      *(long long *)(s + r) = z0;
+      z0 = *((long long *) s);
+      s += 8;
+      *(long long *)(s + r) = z1;
+      z1 = *((long long *) s);
+      s += 8;
+    }
+}
+
+#define BYTES 16384
+
+main ()
+{
+  long long s[BYTES / 8];
+  long long d[BYTES / 8];
+  int i;
+
+  for (i = 1; i < 67108864 / BYTES; i++)
+    bcopy (s, d, BYTES);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bf.c b/gcc/testsuite/gcc.c-torture/unsorted/bf.c
new file mode 100644
index 00000000000..821623df09c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bf.c
@@ -0,0 +1,31 @@
+typedef unsigned long uint32;
+typedef signed long sint32;
+
+uint32
+ext (sint32 src, unsigned o5, unsigned w5)
+{
+  return (w5 == 0) ? src >> o5 : (src << (( - o5 - w5) & 31)) >> (32 - w5);
+}
+
+uint32
+extu (uint32 src, unsigned o5, unsigned w5)
+{
+  return (w5 == 0) ? src >> o5 : (src << (( - o5 - w5) & 31)) >> (32 - w5);
+}
+
+uint32
+mak (uint32 src, unsigned o5, unsigned w5)
+{
+  return (w5 == 0) ? src << o5 : (src << (32 - w5)) >> (( - o5 - w5) & 31);
+}
+
+uint32
+rot (uint32 src, unsigned o5)
+{
+  return (src >> o5) | (src << (( - o5) & 31));
+}
+
+main (int argc, char **argv)
+{
+  printf ("%x\n", clr (0xffffffff, atoi (argv[2]), atoi (argv[1])));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bfins.c b/gcc/testsuite/gcc.c-torture/unsorted/bfins.c
new file mode 100644
index 00000000000..e626d82b3cb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bfins.c
@@ -0,0 +1,15 @@
+struct foo
+{
+  unsigned j : 16;
+  unsigned i : 16;
+};
+
+struct foo
+foo (a, b)
+     struct foo a;
+     int b;
+{
+  a.j = 123;
+  a.i = b;
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bfx.c b/gcc/testsuite/gcc.c-torture/unsorted/bfx.c
new file mode 100644
index 00000000000..d47bd7d18bc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bfx.c
@@ -0,0 +1,9 @@
+foo (x, c)
+{
+  return x << -c;
+}
+
+main ()
+{
+  printf ("%x\n", foo (0xf05, -4));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bge.c b/gcc/testsuite/gcc.c-torture/unsorted/bge.c
new file mode 100644
index 00000000000..55f4788299a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bge.c
@@ -0,0 +1,7 @@
+foo (a)
+     double a;
+{
+  if (a >= 0)
+    return 1;
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bit.c b/gcc/testsuite/gcc.c-torture/unsorted/bit.c
new file mode 100644
index 00000000000..e76bb45e7cd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bit.c
@@ -0,0 +1,13 @@
+bar (a)
+{
+  return (a == 0);
+}
+
+foo (a)
+     int a;
+{
+  if ((a & (1 << 26)) >= 0)
+    return 1;
+  else
+    return 2;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bitf.c b/gcc/testsuite/gcc.c-torture/unsorted/bitf.c
new file mode 100644
index 00000000000..5b0aefc83d4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bitf.c
@@ -0,0 +1,17 @@
+#define int unsigned
+
+struct foo
+{
+  int aa : 1;
+  int a : 9;
+  int c : 16;
+  int d : 6;
+};
+
+
+int
+foo (a, b)
+     struct foo a;
+{
+  return a.d == 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bitw.c b/gcc/testsuite/gcc.c-torture/unsorted/bitw.c
new file mode 100644
index 00000000000..585cd32e603
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bitw.c
@@ -0,0 +1,9 @@
+foo (a)
+     unsigned a;
+{
+  unsigned b = 0;
+
+  if ((a & 12345678) > b)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/blk.c b/gcc/testsuite/gcc.c-torture/unsorted/blk.c
new file mode 100644
index 00000000000..18a9545cc28
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/blk.c
@@ -0,0 +1,18 @@
+struct
+{
+  double a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t;
+} foo, bar;
+
+foobar ()
+{
+  foo = bar;
+  xxx (&foo, &bar);
+}
+
+main ()
+{
+  bar.g = 1.0;
+  foo.g = 2.0;
+  foobar ();
+  printf ("%lf\n", foo.g);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bt.c b/gcc/testsuite/gcc.c-torture/unsorted/bt.c
new file mode 100644
index 00000000000..ac20c05674d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bt.c
@@ -0,0 +1,7 @@
+main ()
+{
+  int i;
+
+  for (i = 1000000; --i;)
+    ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bt386.c b/gcc/testsuite/gcc.c-torture/unsorted/bt386.c
new file mode 100644
index 00000000000..283ab5fa64a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bt386.c
@@ -0,0 +1,18 @@
+foo (a, b)
+{
+  return (a & (1 << b)) != 0;
+}
+
+bar (a, b)
+{
+  a ^= (1 << b);
+  return a != 0;
+}
+
+main ()
+{
+  int i;
+  for (i = 0; i < 32; i++)
+    printf ("%d ", foo (0x8000000f, i));
+  puts ("");
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bug.c b/gcc/testsuite/gcc.c-torture/unsorted/bug.c
new file mode 100644
index 00000000000..447eb7af297
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bug.c
@@ -0,0 +1,4 @@
+foo (a, b)
+{
+  return a - 65536;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bugc.c b/gcc/testsuite/gcc.c-torture/unsorted/bugc.c
new file mode 100644
index 00000000000..b2ce1fad8ac
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bugc.c
@@ -0,0 +1,7 @@
+
+int
+reg0indreg1 (r0, p1)
+     short  r0;  short *p1;
+{
+  return (r0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/buns.c b/gcc/testsuite/gcc.c-torture/unsorted/buns.c
new file mode 100644
index 00000000000..f206bfaed0c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/buns.c
@@ -0,0 +1,12 @@
+foo (a)
+{
+  int bar = 0;
+
+  return (unsigned) (a - 1) <= (unsigned) bar;
+}
+
+main ()
+{
+  if (foo (-1))
+    puts ("The largest possible unsigned <= 0 on this machine...");
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/bx.c b/gcc/testsuite/gcc.c-torture/unsorted/bx.c
new file mode 100644
index 00000000000..274fb015cf5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/bx.c
@@ -0,0 +1,12 @@
+unsigned
+good (unsigned src, unsigned o5, unsigned w5)
+{
+  return src & ~((w5 == 0) ? (~0 << o5) : (1 << o5));
+}
+
+unsigned
+bad (unsigned src, unsigned o5, unsigned w5)
+{
+  return src & ((w5 == 0) ? ~(~0 << o5) : ~(1 << o5));
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/c.c b/gcc/testsuite/gcc.c-torture/unsorted/c.c
new file mode 100644
index 00000000000..384ee3e3cf3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/c.c
@@ -0,0 +1,17 @@
+foo (a, b)
+     long long a, b;
+{
+  if (a & ~b)
+    return 1;
+  else
+    return 0;
+}
+
+bar (a, b)
+     long long a, b;
+{
+  if (a & ~b & ((long long) 87612378))
+    return 1;
+  else
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/c1.c b/gcc/testsuite/gcc.c-torture/unsorted/c1.c
new file mode 100644
index 00000000000..f50d437f60b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/c1.c
@@ -0,0 +1,7 @@
+unsigned
+rec (a, b)
+     unsigned a;
+     unsigned b;
+{
+  return a * rec (a - 1, b + 1);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/c2.c b/gcc/testsuite/gcc.c-torture/unsorted/c2.c
new file mode 100644
index 00000000000..ef5a71188d3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/c2.c
@@ -0,0 +1,5 @@
+foo (a)
+{
+  bar (a);
+  bar (a);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/call.c b/gcc/testsuite/gcc.c-torture/unsorted/call.c
new file mode 100644
index 00000000000..c8106038371
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/call.c
@@ -0,0 +1,7 @@
+int foo () {}
+
+main (a, b)
+{
+  foo (foo (a, b), foo (b, a));
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/call386.c b/gcc/testsuite/gcc.c-torture/unsorted/call386.c
new file mode 100644
index 00000000000..18498932c5b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/call386.c
@@ -0,0 +1,20 @@
+
+foo () {}
+
+main ()
+{
+  int i;
+  for (i = 100000; i >= 0; i--)
+    {
+      foo ();
+      foo ();
+      foo ();
+      foo ();
+      foo ();
+      foo ();
+      foo ();
+      foo ();
+      foo ();
+      foo ();
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/callind.c b/gcc/testsuite/gcc.c-torture/unsorted/callind.c
new file mode 100644
index 00000000000..74c0f1f9cef
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/callind.c
@@ -0,0 +1,8 @@
+call (foo, a)
+     int (**foo) ();
+{
+
+  (foo)[1] = call;
+
+  foo[a] (1);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/cc.c b/gcc/testsuite/gcc.c-torture/unsorted/cc.c
new file mode 100644
index 00000000000..e29bec49d41
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/cc.c
@@ -0,0 +1,96 @@
+cc8 (a, b)
+{
+  if (a < 0)
+    goto L1;
+    if (a == 0)
+      goto L2;
+ L1:b++;
+ L2:b++;
+  return b;
+}
+
+cc7 (a)
+     long long a;
+{
+  if (a < 0)
+    return 1;
+  else
+    return 0;
+}
+
+cc6 (float a, double p)
+{
+  p = a;
+  if (p < 0)
+    return p;
+  else
+    return p + 1;
+}
+
+cc5 (p, a)
+     char *p;
+     char a;
+{
+  p[2] = a;
+  if (a)
+    return 0;
+  else
+    return 1;
+}
+
+
+cc4 (a, b, p)
+     int a, b;
+     int *p;
+{
+  a = (int short)b;
+  *p = a;
+  if ((int) a < 0)
+    return 0;
+  else
+    return 1;
+}
+
+
+cc1 (a, b)
+{
+  int x = 0;
+
+  if ((int) a < (int) b)
+    {
+      if ((unsigned) a < (unsigned) b)
+	x++;
+      x++;
+    }
+
+  return x;
+}
+
+cc2 (a, b)
+{
+  int x = 0;
+
+  if ((int) a <= (int) b)
+    {
+      if ((int) a < (int) b)
+	x++;
+      x++;
+    }
+
+  return x;
+}
+
+cc3 (a, b)
+{
+  int x = 0;
+
+  a += b;
+  if ((unsigned) a > 0)
+    {
+      if (a == 0)
+	x++;
+      x++;
+    }
+
+  return x;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/charmtst.c b/gcc/testsuite/gcc.c-torture/unsorted/charmtst.c
new file mode 100644
index 00000000000..2945f198e5e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/charmtst.c
@@ -0,0 +1,15 @@
+c_move_tst (char b)
+{
+  char a;
+
+  a = b;
+  b = 'b';
+  foo (a);
+  foo (b);
+  foo (a);
+  bar (a, b);
+  b = a;
+  if (b == 0)
+    a++;
+  return a + b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/cmb.c b/gcc/testsuite/gcc.c-torture/unsorted/cmb.c
new file mode 100644
index 00000000000..1fd946182ba
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/cmb.c
@@ -0,0 +1,6 @@
+foo (p1, p2)
+     short p1, *p2;
+{
+  int a;
+  return (int) p1 + (int) *p2;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/cmp.c b/gcc/testsuite/gcc.c-torture/unsorted/cmp.c
new file mode 100644
index 00000000000..a82fe424735
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/cmp.c
@@ -0,0 +1,11 @@
+struct fooalign {char x; double d;};
+union fooround {long x; double d;};
+
+int
+foo ()
+{
+  int extra = 4;
+  if (extra < sizeof (union fooround))
+    extra = sizeof (union fooround);
+  return extra;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/cmphi.c b/gcc/testsuite/gcc.c-torture/unsorted/cmphi.c
new file mode 100644
index 00000000000..1ffc2140fba
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/cmphi.c
@@ -0,0 +1,4 @@
+foo (short *p, short a)
+{
+  return a < *p;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/cmpsi386.c b/gcc/testsuite/gcc.c-torture/unsorted/cmpsi386.c
new file mode 100644
index 00000000000..50b08d7126d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/cmpsi386.c
@@ -0,0 +1,14 @@
+foo (a, p)
+     register int a;
+     int *p;
+{
+
+  for (a = 10000000; a >= *p; a--)
+    ;
+}
+
+main ()
+{
+  int a;
+  foo (a, a);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/cmul.c b/gcc/testsuite/gcc.c-torture/unsorted/cmul.c
new file mode 100644
index 00000000000..cce20bc358d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/cmul.c
@@ -0,0 +1,4 @@
+foo (a)
+{
+  return a * 84;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/cn1.c b/gcc/testsuite/gcc.c-torture/unsorted/cn1.c
new file mode 100644
index 00000000000..866778ca199
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/cn1.c
@@ -0,0 +1,5 @@
+int
+foo ()
+{
+  return 7561;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/comb.c b/gcc/testsuite/gcc.c-torture/unsorted/comb.c
new file mode 100644
index 00000000000..a4689079b79
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/comb.c
@@ -0,0 +1,7 @@
+foo (a, b)
+{
+  int c = a & b;
+  if ((a & b) == 0)
+    return 0;
+  return c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/configure.in b/gcc/testsuite/gcc.c-torture/unsorted/configure.in
new file mode 100644
index 00000000000..7810172c29e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=unsorted.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/consec.c b/gcc/testsuite/gcc.c-torture/unsorted/consec.c
new file mode 100644
index 00000000000..fd76cd2eec4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/consec.c
@@ -0,0 +1,17 @@
+int glob;
+
+conseq (a, b, c, d)
+     int *a, *b;
+{
+  a[2] = d;
+  a[1] = c;
+  sequence (a, b, c, d);
+  sequence (d, c, b, a);
+  b[0] = 0;
+  b[1] = 123;
+  a[0] = 321;
+  a[1] = 0;
+  sequence (111, 0, 0, 222, 0, 333);
+  ((int *)glob)[2] = c;
+  ((int *)glob)[3] = d;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/const.c b/gcc/testsuite/gcc.c-torture/unsorted/const.c
new file mode 100644
index 00000000000..209fc768887
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/const.c
@@ -0,0 +1,4 @@
+main (a)
+{
+  return a + (~0 - 240);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/conv.c b/gcc/testsuite/gcc.c-torture/unsorted/conv.c
new file mode 100644
index 00000000000..70fc024127c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/conv.c
@@ -0,0 +1,32 @@
+double
+u2d (unsigned int u)
+{
+  return u;
+}
+
+double
+i2d (signed int i)
+{
+  return i;
+}
+
+unsigned int
+d2u (double d)
+{
+  return d;
+}
+
+signed int
+d2i (double d)
+{
+  return d;
+}
+
+main ()
+{
+  printf ("%lf, %lf, %lf\n", u2d (~0), u2d (1 << 31), u2d (1));
+  printf ("%lf, %lf, %lf\n", i2d (~0), i2d (1 << 31), i2d (1));
+
+  printf ("%u, %u, %u\n", d2u (u2d (~0)), d2u (u2d (1 << 31)), d2u (u2d (1)));
+  printf ("%d, %d, %d\n", d2i (i2d (~0)), d2i (i2d (1 << 31)), d2i (i2d (1)));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/conv_tst.c b/gcc/testsuite/gcc.c-torture/unsorted/conv_tst.c
new file mode 100644
index 00000000000..513d6a2471e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/conv_tst.c
@@ -0,0 +1,66 @@
+#define ID_1 2400000000.0
+#define ID_2 1.7
+#define ID_3 -1.7
+
+unsigned ui;
+int si;
+
+conv_i1 ()
+{
+/*
+  ui = (unsigned) ID_1;
+  si = (int) ID_1;
+*/
+}
+
+conv_i2 ()
+{
+  ui = (unsigned) ID_2;
+  si = (int) ID_2;
+}
+
+conv_i3 ()
+{
+/*  ui = (unsigned) ID_3;*/
+  si = (int) ID_3;
+}
+
+conv_1 (d)
+     double d;
+{
+  ui = (unsigned) d;
+/*
+  si = (int) d;
+*/
+}
+
+double
+foo (u)
+     unsigned u;
+{
+  return u;
+}
+
+main ()
+{
+  printf ("%lf\n", foo (2400000000));
+
+  conv_i1 ();
+  printf ("%lf, %u, %d\n", ID_1, ui, si);
+
+  conv_i2 ();
+  printf ("%lf, %u, %d\n", ID_2, ui, si);
+
+  conv_i3 ();
+  printf ("%lf, %u, %d\n", ID_3, ui, si);
+
+  conv_1 (ID_1);
+  printf ("%lf, %u, %d\n", ID_1, ui, si);
+
+  conv_1 (ID_2);
+  printf ("%lf, %u, %d\n", ID_2, ui, si);
+
+  conv_1 (ID_3);
+  printf ("%lf, %u, %d\n", ID_3, ui, si);
+
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/cp.c b/gcc/testsuite/gcc.c-torture/unsorted/cp.c
new file mode 100644
index 00000000000..04b1420cb30
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/cp.c
@@ -0,0 +1,42 @@
+struct _obstack_chunk
+{
+  char  *limit;
+  struct _obstack_chunk *prev;
+  char	contents[4];
+};
+
+struct obstack
+{
+  long	chunk_size;
+  struct _obstack_chunk* chunk;
+  char	*object_base;
+  char	*next_free;
+  char	*chunk_limit;
+  int	temp;
+  int   alignment_mask;
+  struct _obstack_chunk *(*chunkfun) ();
+  void (*freefun) ();
+};
+
+struct fooalign {char x; double d;};
+union fooround {long x; double d;};
+
+void
+_obstack_begin (h, size, alignment, chunkfun, freefun)
+     struct obstack *h;
+     int size;
+     int alignment;
+     void *  (*chunkfun) ();
+     void (*freefun) ();
+{
+  register struct _obstack_chunk* chunk;
+
+  if (alignment == 0)
+    alignment = ((char *)&((struct fooalign *) 0)->d - (char *)0);
+  if (size == 0)
+    {
+      int extra = 4;
+      if (extra < (sizeof (union fooround)))
+	extra = (sizeof (union fooround));
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/csebug.c b/gcc/testsuite/gcc.c-torture/unsorted/csebug.c
new file mode 100644
index 00000000000..f49f6842c1a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/csebug.c
@@ -0,0 +1,7 @@
+
+int
+reg0indreg1 (r0, p1)
+     short  r0;  short *p1;
+{
+  return (r0 + *p1);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/cvt.c b/gcc/testsuite/gcc.c-torture/unsorted/cvt.c
new file mode 100644
index 00000000000..716659c4798
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/cvt.c
@@ -0,0 +1,9 @@
+foo (p)
+     unsigned char *p;
+{
+  unsigned char a = 0;
+
+  if (*p > 0)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/d.c b/gcc/testsuite/gcc.c-torture/unsorted/d.c
new file mode 100644
index 00000000000..5fca120d85a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/d.c
@@ -0,0 +1,19 @@
+long long unsigned
+str2llu (str)
+     char *str;
+{
+  long long unsigned acc;
+  long long b = 10;
+  char d;
+  acc =  *str++ - '0';
+  for (;;)
+    {
+      d = *str++;
+      if (d == '\0')
+	break;
+      d -= '0';
+      acc = acc * 10 + d;
+    }
+
+  return acc;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dbl_parm.c b/gcc/testsuite/gcc.c-torture/unsorted/dbl_parm.c
new file mode 100644
index 00000000000..ce5ba4f16d5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dbl_parm.c
@@ -0,0 +1,10 @@
+foo (a, b, c)
+     double a;
+     int b;
+     double c;
+{
+  if (b)
+    return a + c;
+  else
+    return a - c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dblbug.c b/gcc/testsuite/gcc.c-torture/unsorted/dblbug.c
new file mode 100644
index 00000000000..cd13b796297
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dblbug.c
@@ -0,0 +1,21 @@
+union real_extract
+{
+  double  d;
+  int i[sizeof (double ) / sizeof (int)];
+};
+
+typedef struct
+{
+  int zzzz;
+} *rtx;
+
+rtx
+immed_real_const_1 (d)
+     double  d;
+{
+  union real_extract u;
+  register rtx r;
+
+  u.d = d;
+  foo (&(r->zzzz), &u);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/ddd.c b/gcc/testsuite/gcc.c-torture/unsorted/ddd.c
new file mode 100644
index 00000000000..b0b6809dd69
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/ddd.c
@@ -0,0 +1,7 @@
+int foo;
+int bar;
+
+main ()
+{
+  return foo + bar;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dead.c b/gcc/testsuite/gcc.c-torture/unsorted/dead.c
new file mode 100644
index 00000000000..795f7c7e467
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dead.c
@@ -0,0 +1,5 @@
+foo (a)
+{
+  ++a;
+  return a == 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/delay.c b/gcc/testsuite/gcc.c-torture/unsorted/delay.c
new file mode 100644
index 00000000000..c776383520a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/delay.c
@@ -0,0 +1,11 @@
+foo (a, b)
+{
+  if (a == 1)
+    goto foo1;
+  if (a == 2)
+    goto foo2;
+ foo1:
+  return 2;
+ foo2:
+  return 3;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/di.c b/gcc/testsuite/gcc.c-torture/unsorted/di.c
new file mode 100644
index 00000000000..476bf700fb3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/di.c
@@ -0,0 +1,12 @@
+long long
+foo (a, b)
+     long long a, b;
+{
+  return a * b;
+}
+
+main ()
+{
+  int a = foo ((long long) 2, (long long) 3);
+  printf ("%d\n", a);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dic.c b/gcc/testsuite/gcc.c-torture/unsorted/dic.c
new file mode 100644
index 00000000000..9c2c9f90fd6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dic.c
@@ -0,0 +1,5 @@
+unsigned long long
+main ()
+{
+  return (unsigned long long) 7816234 << 671111;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dilayout.c b/gcc/testsuite/gcc.c-torture/unsorted/dilayout.c
new file mode 100644
index 00000000000..4bba661c0a4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dilayout.c
@@ -0,0 +1,33 @@
+struct ii
+{
+  int a;
+  int b;
+};
+
+struct foo
+{
+  int a;
+  struct ii ab;
+  int b;
+};
+
+struct ii
+foo (int *p, struct foo a)
+{
+  p[0] = a.a;
+  p[1] = a.ab.a;
+  p[2] = a.ab.b;
+  p[3] = a.b;
+  return a.ab;
+}
+
+str (struct ii ab, struct ii *p)
+{
+  *p = ab;
+}
+
+ll (long long ab, long long *p)
+{
+  *p = ab;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dimove.c b/gcc/testsuite/gcc.c-torture/unsorted/dimove.c
new file mode 100644
index 00000000000..7caf3fa468b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dimove.c
@@ -0,0 +1,4 @@
+foo (long long *p)
+{
+  p[0] = p[1];
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dimul.c b/gcc/testsuite/gcc.c-torture/unsorted/dimul.c
new file mode 100644
index 00000000000..c8529565fa9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dimul.c
@@ -0,0 +1,6 @@
+long long
+foo (a, b)
+     long long a, b;
+{
+  return a * b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/div.c b/gcc/testsuite/gcc.c-torture/unsorted/div.c
new file mode 100644
index 00000000000..1f0904a649d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/div.c
@@ -0,0 +1,4 @@
+foo (a, b)
+{
+  return a / b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/divdf.c b/gcc/testsuite/gcc.c-torture/unsorted/divdf.c
new file mode 100644
index 00000000000..5ea89ae3ddc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/divdf.c
@@ -0,0 +1,5 @@
+double
+foo (float a, float b)
+{
+  return (double)a / (double)b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dm.c b/gcc/testsuite/gcc.c-torture/unsorted/dm.c
new file mode 100644
index 00000000000..67c60ee9820
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dm.c
@@ -0,0 +1,24 @@
+struct dm
+{
+  unsigned q;
+  unsigned r;
+};
+
+struct dm
+dm (a, b)
+     unsigned a, b;
+{
+  struct dm qr;
+
+  qr.q = a / b;
+  qr.r = a % b;
+  return qr;
+}
+
+main ()
+{
+  struct dm qr;
+
+  qr = dm (100, 30);
+  printf ("%u, %u\n", qr.q, qr.r);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dshift.c b/gcc/testsuite/gcc.c-torture/unsorted/dshift.c
new file mode 100644
index 00000000000..94750cc3cbc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dshift.c
@@ -0,0 +1,10 @@
+foo (b, c)
+     unsigned b, c;
+{
+  return (b << 12) | (c >> 20);
+}
+
+main ()
+{
+  printf ("0x%x\n", foo (0x11223344, 0xaabbccdd));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/e.c b/gcc/testsuite/gcc.c-torture/unsorted/e.c
new file mode 100644
index 00000000000..fa20e00ef8f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/e.c
@@ -0,0 +1,10 @@
+foo (short a, int *p, short *s)
+{
+  int i;
+  for (i = 10;  i >= 0; i--)
+    {
+      a = (short) bar ();
+      p[i] = a;
+      s[i] = a;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/ex.c b/gcc/testsuite/gcc.c-torture/unsorted/ex.c
new file mode 100644
index 00000000000..f5d90fd2e65
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/ex.c
@@ -0,0 +1,11 @@
+foo (a, b)
+{
+  if ((a & (1 << b)) == 0)
+    return 1;
+  return 0;
+}
+
+main ()
+{
+  printf ("%d\n", foo ());
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/ext.c b/gcc/testsuite/gcc.c-torture/unsorted/ext.c
new file mode 100644
index 00000000000..8fa8cd73363
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/ext.c
@@ -0,0 +1,13 @@
+struct foo
+{
+  unsigned b31 : 1;
+  unsigned b30 : 1;
+  unsigned b29 : 1;
+  unsigned b28 : 1;
+  unsigned rest : 28;
+};
+foo(a)
+     struct foo a;
+{
+  return a.b30;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/f1.c b/gcc/testsuite/gcc.c-torture/unsorted/f1.c
new file mode 100644
index 00000000000..446acc6e1a1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/f1.c
@@ -0,0 +1,5 @@
+double
+foo ()
+{
+  return 1.2587624368724;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/f2.c b/gcc/testsuite/gcc.c-torture/unsorted/f2.c
new file mode 100644
index 00000000000..8bb384902b9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/f2.c
@@ -0,0 +1,4 @@
+foo (double *p)
+{
+  p[0] = p[1];
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/fdmul.c b/gcc/testsuite/gcc.c-torture/unsorted/fdmul.c
new file mode 100644
index 00000000000..711707b51fc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/fdmul.c
@@ -0,0 +1,2 @@
+double
+foo (float a, float b) { return (double) a * (double) b; }
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/flo.c b/gcc/testsuite/gcc.c-torture/unsorted/flo.c
new file mode 100644
index 00000000000..2a213b7ab79
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/flo.c
@@ -0,0 +1,7 @@
+foo (a)
+     double a;
+{
+  double b = 0.0;
+
+  return (a == 0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/float.c b/gcc/testsuite/gcc.c-torture/unsorted/float.c
new file mode 100644
index 00000000000..b6789203b5d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/float.c
@@ -0,0 +1,6 @@
+double
+foo (a, b, c)
+     double a, b, c;
+{
+  return a * b + c * a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/flt_const.c b/gcc/testsuite/gcc.c-torture/unsorted/flt_const.c
new file mode 100644
index 00000000000..65700ba7730
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/flt_const.c
@@ -0,0 +1,5 @@
+double
+foo ()
+{
+  return 3.141592653589793238462643;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/fnul.c b/gcc/testsuite/gcc.c-torture/unsorted/fnul.c
new file mode 100644
index 00000000000..b0c9816adf7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/fnul.c
@@ -0,0 +1,23 @@
+main ()
+{
+  int i;
+  int f;
+
+  for (i = 0;; i--)
+    {
+      f = 0;
+
+      if ((i & (i - 1)) == 0)
+	{
+	  printf ("d");
+	  f = 1;
+	}
+      if ((i & -i) == i)
+	{
+	  printf ("t");
+	  f = 1;
+	}
+      if (f)
+	printf ("%d\n", i);
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/foo.c b/gcc/testsuite/gcc.c-torture/unsorted/foo.c
new file mode 100644
index 00000000000..762d7e457d0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/foo.c
@@ -0,0 +1,8 @@
+int *
+main (s1, s2)
+     int *s1; int *s2;
+{
+  while ((*s1++ = *s2++) != '\0')
+    ;
+  return s1 - 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/forgetcc.c b/gcc/testsuite/gcc.c-torture/unsorted/forgetcc.c
new file mode 100644
index 00000000000..4105408a050
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/forgetcc.c
@@ -0,0 +1,11 @@
+foo (hp, p, a)
+     short *hp;
+     int *p;
+     int a;
+{
+  hp[10] = a;
+  p[0] = 10;
+  if (hp[10] > 0)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/fq.c b/gcc/testsuite/gcc.c-torture/unsorted/fq.c
new file mode 100644
index 00000000000..c4ac3696096
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/fq.c
@@ -0,0 +1,25 @@
+expand_to_ascii (int *i, int *o)
+{
+  unsigned x, y, out;
+  unsigned x1;
+
+  /* Big endian code.  */
+
+  x = *i++;
+
+  y = x >> (32 - 13);
+  out = (y / 91);
+  out = (out << 8) | (y % 91);
+
+  x <<= 13;
+  y = x >> (32 - 13);
+  out = (out << 8) | (y / 91);
+  out = (out << 8) | (y % 91);
+
+  *o++ = out + 0x20202020;
+
+  /* 6 bits left in x.  */
+
+  x1 = *i++;
+  x = (x << 26) | (x1 >> 6);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/g.c b/gcc/testsuite/gcc.c-torture/unsorted/g.c
new file mode 100644
index 00000000000..e00f1244fc4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/g.c
@@ -0,0 +1,9 @@
+foo (a, b)
+     long long a, b;
+
+{
+  if (a == b)
+    return 0;
+  else
+    return 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/gen_tst.c b/gcc/testsuite/gcc.c-torture/unsorted/gen_tst.c
new file mode 100644
index 00000000000..5a7a3763a3a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/gen_tst.c
@@ -0,0 +1,67 @@
+/* Compiler Test Generator Program.
+   Copyright (C) 1989 FSF.  */
+
+
+#define E0 ((type *)10000000)
+#define reg0 r0
+#define indreg0 (*p0)
+#define imm0 22
+#define limm0 ((type)(int)&glob0)
+#define adr0 (*E0)
+#define adrreg0 (p0[10000000])
+#define adrx0 (E0[x0])
+#define regx0 (p0[x0])
+
+#define E1 ((type *)11111111)
+#define reg1 r1
+#define indreg1 (*p1)
+#define imm1 33
+#define limm1 ((type)(int)&glob1)
+#define adr1 (*E1)
+#define adrreg1 (p1[1111111/4])
+#define adrx1 (E1[x1])
+#define regx1 (p1[x1])
+
+int glob0, glob1;
+
+#define type double
+
+char *a0[] = {"reg0", "indreg0", "imm0", "limm0",
+		"adr0", "adrreg0", "adrx0", "regx0"};
+char *a1[] = {"reg1", "indreg1", "imm1", "limm1",
+		"adr1", "adrreg1", "adrx1", "regx1"};
+
+main_compare ()
+{
+  int i0, i1;
+
+  for (i0 = 0;  i0 < 8;  i0++)
+    {
+      for (i1 = 0;  i1 < 8;  i1++)
+	{
+	  printf ("%s%s_cmp (r0, r1, x0, x1, p0, p1)\n", a0[i0], a1[i1]);
+	  printf ("type r0, r1;  type *p0, *p1;\n");
+	  printf ("{if (%s <= %s) return 1; else return 0;}\n\n",
+		  a0[i0], a1[i1], a0[i0]);
+	}
+    }
+}
+
+main_assign ()
+{
+  int i0, i1;
+
+  for (i0 = 0;  i0 < 8;  i0++)
+    {
+      if (i0 < 2 || i0 > 3)
+      for (i1 = 0;  i1 < 8;  i1++)
+	{
+	  printf ("%s%s_set (r0, r1, x0, x1, p0, p1)\n", a0[i0], a1[i1]);
+	  printf ("type r0, r1;  type *p0, *p1;\n");
+	  printf ("{%s = %s;  }\n\n",
+		  a0[i0], a1[i1]);
+	}
+    }
+}
+
+main () {main_assign ();}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/glob.c b/gcc/testsuite/gcc.c-torture/unsorted/glob.c
new file mode 100644
index 00000000000..e3206154fd9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/glob.c
@@ -0,0 +1,12 @@
+typedef int tt;
+
+tt a1;
+tt a2;
+tt a3;
+
+foo ()
+{
+  a1++;
+  a2++;
+  a1++;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/gronk.c b/gcc/testsuite/gcc.c-torture/unsorted/gronk.c
new file mode 100644
index 00000000000..c1bb767e576
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/gronk.c
@@ -0,0 +1,8 @@
+test_opt (a, b)
+     unsigned a, b;
+{
+  a = a / b;
+  if (a == 0)
+    a++;
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/hi.c b/gcc/testsuite/gcc.c-torture/unsorted/hi.c
new file mode 100644
index 00000000000..1624f777995
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/hi.c
@@ -0,0 +1,5 @@
+foo (a, b)
+     short a, b;
+{
+  return a < b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/hibug.c b/gcc/testsuite/gcc.c-torture/unsorted/hibug.c
new file mode 100644
index 00000000000..ad5c8267994
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/hibug.c
@@ -0,0 +1,15 @@
+struct foo
+{
+  short  d;
+  int a;
+};
+
+int
+bar (d, u)
+     short d;
+  struct foo u;
+{
+
+  u.d = d;
+  return (int) (&u);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/i++.c b/gcc/testsuite/gcc.c-torture/unsorted/i++.c
new file mode 100644
index 00000000000..01d9ca95a8a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/i++.c
@@ -0,0 +1,7 @@
+int main ()
+{
+  int i = 2;
+
+  i = i++;
+  printf ("%d\n",i);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/i.c b/gcc/testsuite/gcc.c-torture/unsorted/i.c
new file mode 100644
index 00000000000..3bee8eacb80
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/i.c
@@ -0,0 +1,8 @@
+ase (p)
+     short *p;
+{
+  int a;
+
+  a = *p;
+  *p = a + 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/ic.c b/gcc/testsuite/gcc.c-torture/unsorted/ic.c
new file mode 100644
index 00000000000..150e1e8ed7e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/ic.c
@@ -0,0 +1,7 @@
+foo (int *ip, int a)
+{
+  a++;
+  if (a < ip[a])
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/icmp.c b/gcc/testsuite/gcc.c-torture/unsorted/icmp.c
new file mode 100644
index 00000000000..dc9678ec335
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/icmp.c
@@ -0,0 +1,10 @@
+foo (a, b)
+{
+  b++;
+  if (a <= b)
+    if ((int) a < (int) b)
+      b--;
+    else
+      b++;
+  return b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/ifreg.c b/gcc/testsuite/gcc.c-torture/unsorted/ifreg.c
new file mode 100644
index 00000000000..9e2f9562e38
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/ifreg.c
@@ -0,0 +1,12 @@
+union foo
+{
+  float f;
+  int i;
+};
+
+foo (int a, float c)
+{
+  union foo b;
+  b.i = a;
+  return b.f + c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/imm.c b/gcc/testsuite/gcc.c-torture/unsorted/imm.c
new file mode 100644
index 00000000000..c3efba45eee
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/imm.c
@@ -0,0 +1,7 @@
+int
+imm ()
+
+{
+  return 11234;
+
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/isinf.c b/gcc/testsuite/gcc.c-torture/unsorted/isinf.c
new file mode 100644
index 00000000000..12a8283747f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/isinf.c
@@ -0,0 +1,5 @@
+int
+isinf ()
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/jmp.c b/gcc/testsuite/gcc.c-torture/unsorted/jmp.c
new file mode 100644
index 00000000000..474206a1f5e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/jmp.c
@@ -0,0 +1,20 @@
+foo (a)
+{
+  if (a)
+    goto a1;
+  goto a2;
+ a1: goto a3;
+ a2: goto a4;
+ a3: goto a5;
+ a4: goto a6;
+ a5: goto a7;
+ a6: goto a8;
+ a7: goto a9;
+ a8: goto a10;
+ a9: goto a11;
+ a10: goto a12;
+ a11: goto a13;
+ a12:;
+ a13:;
+  return -a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/jumptab.c b/gcc/testsuite/gcc.c-torture/unsorted/jumptab.c
new file mode 100644
index 00000000000..d86c30e40d6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/jumptab.c
@@ -0,0 +1,20 @@
+jumptab (a)
+{
+  int b;
+  switch (a)
+    {
+    case 0:
+      b = 6;break;
+    case 1:
+      b = 5;break;
+    case 2:
+      b = 4;break;
+    case 3:
+      b = 3;break;
+    case 4:
+      b = 2;break;
+    case 5:
+      b = 1;break;
+    }
+  return b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/l.c b/gcc/testsuite/gcc.c-torture/unsorted/l.c
new file mode 100644
index 00000000000..cc23b190b1d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/l.c
@@ -0,0 +1,4 @@
+main (a)
+{
+  return - 256 + a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/layout.c b/gcc/testsuite/gcc.c-torture/unsorted/layout.c
new file mode 100644
index 00000000000..04c825df645
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/layout.c
@@ -0,0 +1,13 @@
+struct foo
+{
+  char a;
+};
+
+foo ()
+{
+  struct foo bar[3];
+  bar[0].a = '0';
+  bar[1].a = '1';
+  bar[2].a = '2';
+  foof (bar);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/lbug.c b/gcc/testsuite/gcc.c-torture/unsorted/lbug.c
new file mode 100644
index 00000000000..0440a0a7a9d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/lbug.c
@@ -0,0 +1,7 @@
+long long x = 0;
+main()
+{
+  if (x--)
+    return 255;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/ll1.c b/gcc/testsuite/gcc.c-torture/unsorted/ll1.c
new file mode 100644
index 00000000000..9009e77b6f4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/ll1.c
@@ -0,0 +1,5 @@
+long long
+foo (long long a)
+{
+  return a + ((long long) 10230101 << 32) + 7561;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/llbug.c b/gcc/testsuite/gcc.c-torture/unsorted/llbug.c
new file mode 100644
index 00000000000..8c56dfbe70d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/llbug.c
@@ -0,0 +1,13 @@
+union foo
+{
+  long long  d;
+};
+
+int
+bar (long long d)
+{
+  union foo u;
+
+  u.d = d;
+  return (int) &u;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/lll.c b/gcc/testsuite/gcc.c-torture/unsorted/lll.c
new file mode 100644
index 00000000000..dee9dc37d15
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/lll.c
@@ -0,0 +1,45 @@
+
+byte_match_count2 (buf, n, xm, m1, m2, m3, m4)
+     unsigned *buf;
+     unsigned n;
+     unsigned xm;
+     unsigned m1, m2, m3, m4;
+{
+  unsigned w, cnt = 0;
+  unsigned *bp;
+
+  n /= 4;
+
+  bp = buf;
+  while (bp < buf + n)
+    {
+      w = *bp++;
+      w ^= xm;
+      cnt += ((m1 & w) == 0);
+      cnt += ((m2 & w) == 0);
+      cnt += ((m3 & w) == 0);
+      cnt += ((m4 & w) == 0);
+
+      w = *bp++;
+      w ^= xm;
+      cnt += ((m1 & w) == 0);
+      cnt += ((m2 & w) == 0);
+      cnt += ((m3 & w) == 0);
+      cnt += ((m4 & w) == 0);
+
+      w = *bp++;
+      w ^= xm;
+      cnt += ((m1 & w) == 0);
+      cnt += ((m2 & w) == 0);
+      cnt += ((m3 & w) == 0);
+      cnt += ((m4 & w) == 0);
+
+      w = *bp++;
+      w ^= xm;
+      cnt += ((m1 & w) == 0);
+      cnt += ((m2 & w) == 0);
+      cnt += ((m3 & w) == 0);
+      cnt += ((m4 & w) == 0);
+    }
+  return cnt;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/load8.c b/gcc/testsuite/gcc.c-torture/unsorted/load8.c
new file mode 100644
index 00000000000..947a8165c29
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/load8.c
@@ -0,0 +1,4 @@
+foo ()
+{
+  return *(short *) 126;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/loadhicc.c b/gcc/testsuite/gcc.c-torture/unsorted/loadhicc.c
new file mode 100644
index 00000000000..a7540894f5e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/loadhicc.c
@@ -0,0 +1,15 @@
+typedef int xtype;
+
+foo (p, pc)
+     xtype *p;
+     char *pc;
+{
+  xtype a;
+  unsigned b = 0;
+
+  a = *p;
+  p[1] = a;
+  if ((unsigned) p[1] > 0)
+    return 1;
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/log2.c b/gcc/testsuite/gcc.c-torture/unsorted/log2.c
new file mode 100644
index 00000000000..39b85784069
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/log2.c
@@ -0,0 +1,6 @@
+log2 (a, b)
+{
+  int c;
+  c = ~(~a & ~b);
+  return c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/logic.c b/gcc/testsuite/gcc.c-torture/unsorted/logic.c
new file mode 100644
index 00000000000..a9d6e9d0c2d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/logic.c
@@ -0,0 +1,37 @@
+logic (a, b)
+     int *a, b;
+{
+  if (*a & 123)
+    b = 1;
+  if (*a & ~222)
+    b = 2;
+  if (124 & *a)
+    b = 3;
+  if (~111 & *a)
+    b = 4;
+
+  if (~*a & 23)
+    b = 1;
+  if (~*a & ~22)
+    b = 2;
+  if (24 & ~*a)
+    b = 3;
+  if (~11 & ~*a)
+    b = 4;
+
+  if (~*a & b)
+    b = 1;
+  if (~*a & ~b)
+    b = 2;
+  if (*a & ~*a)
+    b = 3;
+  return b;
+}
+
+x (a, b, c)
+{
+  for (a = 0;  --a > 0;);
+  for (b = -1; --b > 0;);
+  for (c = -65536; --c > 0;);
+  return a + b + c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/loop-1.c b/gcc/testsuite/gcc.c-torture/unsorted/loop-1.c
new file mode 100644
index 00000000000..e50687a9fdd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/loop-1.c
@@ -0,0 +1,11 @@
+foo (a)
+{
+  while ((a -= 1) != -1)
+    bar (270000);
+  putchar ('\n');
+}
+
+main ()
+{
+  foo (5);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/loop386.c b/gcc/testsuite/gcc.c-torture/unsorted/loop386.c
new file mode 100644
index 00000000000..429a320abbd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/loop386.c
@@ -0,0 +1,15 @@
+foo (a)
+{
+  do
+    {
+      puts ("a");
+      a -= 1;
+    }
+  while (a != 0);
+}
+
+main ()
+{
+  int p[100];
+  printf ("%d\n", foo (3));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/lop.c b/gcc/testsuite/gcc.c-torture/unsorted/lop.c
new file mode 100644
index 00000000000..72464111d4d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/lop.c
@@ -0,0 +1,6 @@
+lop (a)
+{
+  do
+    a--;
+  while (a >= -1);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/m1.c b/gcc/testsuite/gcc.c-torture/unsorted/m1.c
new file mode 100644
index 00000000000..8660f60c950
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/m1.c
@@ -0,0 +1,5 @@
+foo (p)
+     int *p;
+{
+  *p = 1234;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/m2.c b/gcc/testsuite/gcc.c-torture/unsorted/m2.c
new file mode 100644
index 00000000000..203c855b5eb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/m2.c
@@ -0,0 +1,44 @@
+void
+store16 (p, a)
+     short *p;
+     short a;
+{
+  *p = a;
+}
+
+signed int
+sign_extend16 (p)
+     signed short *p;
+{
+  return *p;
+}
+
+unsigned int
+zero_extend16 (p)
+     unsigned short *p;
+{
+  return *p;
+}
+
+void
+store8 (p, a)
+     char *p;
+     char a;
+{
+  *p = a;
+}
+
+signed int
+sign_extend8 (p)
+     signed char *p;
+{
+  return *p;
+}
+
+unsigned int
+zero_extend8 (p)
+     unsigned char *p;
+{
+  return *p;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/m5.c b/gcc/testsuite/gcc.c-torture/unsorted/m5.c
new file mode 100644
index 00000000000..23ad8445d32
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/m5.c
@@ -0,0 +1,4 @@
+foo (a)
+{
+  return a * 5 + 12;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/m68.c b/gcc/testsuite/gcc.c-torture/unsorted/m68.c
new file mode 100644
index 00000000000..a1ee486d4c2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/m68.c
@@ -0,0 +1,14 @@
+foo (a)
+{
+  return a | 12345;
+}
+
+bar (a)
+{
+  return a & (0xffff0000 | 12345);
+}
+
+foobar (a)
+{
+  return a - 128;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mbyte.c b/gcc/testsuite/gcc.c-torture/unsorted/mbyte.c
new file mode 100644
index 00000000000..a8a23eab90a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mbyte.c
@@ -0,0 +1,14 @@
+foo1 (p)
+     char *p;
+{
+  p[0] = p[1];
+  return p[0];
+}
+
+foo2 (p, x)
+     char *p;
+{
+  p[0] = x;
+  return p[0];
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mchar.c b/gcc/testsuite/gcc.c-torture/unsorted/mchar.c
new file mode 100644
index 00000000000..a1b106037f7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mchar.c
@@ -0,0 +1,11 @@
+int
+foo (char *a, char *b)
+{
+  int x;
+  *a = *b;
+  x = *b;
+  if ((char) x)
+    return 1;
+  else
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mcmp.c b/gcc/testsuite/gcc.c-torture/unsorted/mcmp.c
new file mode 100644
index 00000000000..6008008e164
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mcmp.c
@@ -0,0 +1,9 @@
+foo (ip, a, x)
+     int a;
+     int *ip;
+     int x;
+{
+  if (a >= 1)
+    x++;
+  return x;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mdouble.c b/gcc/testsuite/gcc.c-torture/unsorted/mdouble.c
new file mode 100644
index 00000000000..992db2205f2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mdouble.c
@@ -0,0 +1,6 @@
+double
+foo (double a)
+{
+
+  return 1.123486712;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/memtst.c b/gcc/testsuite/gcc.c-torture/unsorted/memtst.c
new file mode 100644
index 00000000000..b5ef2607073
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/memtst.c
@@ -0,0 +1,26 @@
+#ifdef STACK_SIZE
+#define SIZE STACK_SIZE / 8
+#else
+#define SIZE 65536
+#endif
+
+memtst (int *p, int a)
+{
+  do
+    {
+      if (p[a] == 1)
+	break;
+    }
+  while (--a);
+}
+
+main ()
+{
+  int a[SIZE];
+  int i;
+  bzero (a, SIZE * 4);
+  for (i = 0;  i < 100;  i++)
+    {
+      memtst (a, SIZE);
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/miscomp.c b/gcc/testsuite/gcc.c-torture/unsorted/miscomp.c
new file mode 100644
index 00000000000..0bcb568d54b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/miscomp.c
@@ -0,0 +1,15 @@
+unsigned char foo(unsigned long);
+main()
+{
+    unsigned char AChar;
+    unsigned long ALong = 0x12345678;
+
+    AChar = foo(ALong);
+
+    printf("AChar = %x\n",(int)AChar);
+}
+unsigned char
+foo( unsigned long TheLong)
+{
+     return( (unsigned char) (TheLong & 0xff) );
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mm.c b/gcc/testsuite/gcc.c-torture/unsorted/mm.c
new file mode 100644
index 00000000000..a8efaae21cb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mm.c
@@ -0,0 +1,4 @@
+foo (a, b)
+{
+  return a * 2;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mod.c b/gcc/testsuite/gcc.c-torture/unsorted/mod.c
new file mode 100644
index 00000000000..c33211dc7fc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mod.c
@@ -0,0 +1,4 @@
+foo (a, b)
+{
+  return a % b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/modcc.c b/gcc/testsuite/gcc.c-torture/unsorted/modcc.c
new file mode 100644
index 00000000000..2574090e96c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/modcc.c
@@ -0,0 +1,4 @@
+foo (a, b)
+{
+  return (a % b) == 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/move.c b/gcc/testsuite/gcc.c-torture/unsorted/move.c
new file mode 100644
index 00000000000..78e00ff2100
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/move.c
@@ -0,0 +1,9 @@
+typedef char type;
+
+type
+foo (b)
+{
+  type a;
+  for (a = 10; a < b; a++)
+    ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/move_qhi.c b/gcc/testsuite/gcc.c-torture/unsorted/move_qhi.c
new file mode 100644
index 00000000000..9bc9cb6630c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/move_qhi.c
@@ -0,0 +1,12 @@
+move (a, b)
+     char a, b;
+{
+  char s;
+  s = a;
+  if (s)
+    gurka (s);
+  foo (b, a);
+  a = bar ();
+  b = bar ();
+  gra (s);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mregtst.c b/gcc/testsuite/gcc.c-torture/unsorted/mregtst.c
new file mode 100644
index 00000000000..b6bb6c21f55
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mregtst.c
@@ -0,0 +1,17 @@
+foo (a, p)
+     int *p;
+{
+  int old, new, i;
+
+  old = 0;
+  for (i = 1; i < 100; i++)
+    {
+      new = p[i];
+      if (new < old)
+	a++;
+      old = new;
+      if (old == 0)
+	return 0;
+    }
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/msp.c b/gcc/testsuite/gcc.c-torture/unsorted/msp.c
new file mode 100644
index 00000000000..c73cedd294c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/msp.c
@@ -0,0 +1,5 @@
+foo ()
+{
+  int a[16384];
+  bar (a);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mtst.c b/gcc/testsuite/gcc.c-torture/unsorted/mtst.c
new file mode 100644
index 00000000000..4f43137b705
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mtst.c
@@ -0,0 +1,17 @@
+foo (int *p, int c)
+{
+  int a, b;
+  a = p[0];
+  b = p[1];
+  c = p[2];
+  if (b == 0)
+    goto foo1;
+  if (b < 0)
+    goto foo2;;
+
+  return a + b + c;
+ foo1:
+  return 1;
+ foo2:
+  return 2;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mu.c b/gcc/testsuite/gcc.c-torture/unsorted/mu.c
new file mode 100644
index 00000000000..c469a6e3a9b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mu.c
@@ -0,0 +1,4 @@
+foo (a, b)
+{
+  return a * b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mul.c b/gcc/testsuite/gcc.c-torture/unsorted/mul.c
new file mode 100644
index 00000000000..cc5d06b5fac
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mul.c
@@ -0,0 +1,5 @@
+void
+mulqi (char *p, char a, char b)
+{
+  p[0] = a/b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mword.c b/gcc/testsuite/gcc.c-torture/unsorted/mword.c
new file mode 100644
index 00000000000..873e08868c5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mword.c
@@ -0,0 +1,29 @@
+int
+foo (a, b)
+int *a,  *b;
+{
+  int x, y;
+  x++;
+  *a = *b;
+  y = *b;
+
+  if ((int) x)
+    return 1;
+  else
+    return y;
+}
+
+foo1 (p)
+     int *p;
+{
+  p[0] = p[1];
+  return p[0];
+}
+
+foo2 (p, x)
+     int *p;
+{
+  p[0] = x;
+  return p[0];
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/mword1.c b/gcc/testsuite/gcc.c-torture/unsorted/mword1.c
new file mode 100644
index 00000000000..690703eb8bf
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/mword1.c
@@ -0,0 +1,12 @@
+int
+foo (a, b)
+int *a,  *b;
+{
+  int x;
+  *a = (*b + 1);
+  x = *b;
+  if ((int) x)
+    return 1;
+  else
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/n.c b/gcc/testsuite/gcc.c-torture/unsorted/n.c
new file mode 100644
index 00000000000..1a9a8697417
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/n.c
@@ -0,0 +1,6 @@
+char_autoincr (b1, c)
+    short *b1;
+    short c;
+{
+  *b1 = c;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/n1.c b/gcc/testsuite/gcc.c-torture/unsorted/n1.c
new file mode 100644
index 00000000000..dfa93cebed4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/n1.c
@@ -0,0 +1,10 @@
+foo (a, p)
+     long long a;
+     int *p;
+{
+  int b = (int)-a;
+  if (b > 32)
+    return 1;
+  else
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/nand.c b/gcc/testsuite/gcc.c-torture/unsorted/nand.c
new file mode 100644
index 00000000000..8228a3c3a42
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/nand.c
@@ -0,0 +1,4 @@
+nadn (a, b)
+{
+  return (~a) | (~b);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/neg.c b/gcc/testsuite/gcc.c-torture/unsorted/neg.c
new file mode 100644
index 00000000000..c005b1327dd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/neg.c
@@ -0,0 +1 @@
+foo (a) {return -a;}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/o.c b/gcc/testsuite/gcc.c-torture/unsorted/o.c
new file mode 100644
index 00000000000..e8b78e383cb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/o.c
@@ -0,0 +1,12 @@
+foo (a, p)
+     char a;
+     int *p;
+{
+  int b = a;
+  *p = b;
+  a = (char) a;
+  if (a)
+    return b;
+  else
+    return b + 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/omit.c b/gcc/testsuite/gcc.c-torture/unsorted/omit.c
new file mode 100644
index 00000000000..f59d6ee8f27
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/omit.c
@@ -0,0 +1,11 @@
+omit (a, b)
+    char a;
+    char *b;
+{
+  char x;
+  int i;
+  x = *b;
+  b[1] = x;
+  foo ((int)x);
+  return x + 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/opout.c b/gcc/testsuite/gcc.c-torture/unsorted/opout.c
new file mode 100644
index 00000000000..6d3736e059a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/opout.c
@@ -0,0 +1,10 @@
+x ()
+{}
+
+y ()
+{}
+
+z (a, b)
+{
+  return (int) &a + (int) &b + (int) x + (int) z;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/opt.c b/gcc/testsuite/gcc.c-torture/unsorted/opt.c
new file mode 100644
index 00000000000..faad10e48fe
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/opt.c
@@ -0,0 +1,5 @@
+int
+foo (a)
+{
+  return (a == 2);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/or.c b/gcc/testsuite/gcc.c-torture/unsorted/or.c
new file mode 100644
index 00000000000..2a2e3b668b7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/or.c
@@ -0,0 +1,4 @@
+foo (a)
+{
+  return a | 0xffff0101;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/or386.c b/gcc/testsuite/gcc.c-torture/unsorted/or386.c
new file mode 100644
index 00000000000..ad49f35043c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/or386.c
@@ -0,0 +1,13 @@
+typedef int xtype;
+
+xtype
+foo (a)
+     xtype a;
+{
+  return a | 0x7f;
+}
+
+main ()
+{
+  printf ("%08x\n", foo (-1));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/p.c b/gcc/testsuite/gcc.c-torture/unsorted/p.c
new file mode 100644
index 00000000000..465e741592a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/p.c
@@ -0,0 +1,6 @@
+foo (a, b, p)
+     short *p;
+{
+  p[0] = a;
+  p[1] = b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/parms.c b/gcc/testsuite/gcc.c-torture/unsorted/parms.c
new file mode 100644
index 00000000000..26c2c701756
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/parms.c
@@ -0,0 +1,7 @@
+#define alloca __builtin_alloca
+
+x (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, x, y)
+{
+  foo (alloca (8));
+  return a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+r+s+t+u+v+x+y;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/pass.c b/gcc/testsuite/gcc.c-torture/unsorted/pass.c
new file mode 100644
index 00000000000..6b663828aee
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/pass.c
@@ -0,0 +1,13 @@
+int
+foo (a, b, c)
+{
+  return a + b + c;
+}
+
+int
+bar ()
+{
+  int q, w, e, r, t, y;
+
+  return foo ((int) & q, q, w, e, q, (int) &w);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/pmt.c b/gcc/testsuite/gcc.c-torture/unsorted/pmt.c
new file mode 100644
index 00000000000..b6aced6ec81
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/pmt.c
@@ -0,0 +1,6 @@
+long long
+foo (a, b)
+     long long a, b;
+{
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/poor.c b/gcc/testsuite/gcc.c-torture/unsorted/poor.c
new file mode 100644
index 00000000000..66d584aff43
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/poor.c
@@ -0,0 +1,34 @@
+typedef struct
+{
+	char	c[510];
+} s510;
+
+typedef struct
+{
+	char	c[511];
+} s511;
+
+s510	G510, s1;
+s511	G511;
+int	I, J;
+double	D;
+
+void main(void);
+void f0(double D, ...);
+s510 f1(double D, ...);
+void f2a(s510 S);
+void f2b(s511 S);
+
+
+void main(void)
+{
+
+	f0(D, I, J);
+
+	s1 = f1(D, I, D);
+
+	f2a(G510);
+
+	f2b(G511);
+
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/pp.c b/gcc/testsuite/gcc.c-torture/unsorted/pp.c
new file mode 100644
index 00000000000..7d38d53de0f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/pp.c
@@ -0,0 +1,9 @@
+foo (a, b, c, d, e, i0, f, i1)
+     double a, b, c, d, e, f;
+     int i0, i1;
+{}
+
+main ()
+{
+  foo (1.0, 2.0, 3.0, 4.0, 5.0, 1, 6.0, 2);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/pret-arg.c b/gcc/testsuite/gcc.c-torture/unsorted/pret-arg.c
new file mode 100644
index 00000000000..a7fa8562830
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/pret-arg.c
@@ -0,0 +1,5 @@
+foo (a, b, c, d, e, f, g, h, i, j, xx)
+     double xx;
+{
+  return xx + 1.2345;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/pyr.c b/gcc/testsuite/gcc.c-torture/unsorted/pyr.c
new file mode 100644
index 00000000000..d25b2a99aa5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/pyr.c
@@ -0,0 +1,11 @@
+foo (char *a)
+{
+  char b;
+  int c;
+  b = *a;
+  c = b;
+  if (c < 0)
+    return 1;
+  a[1] = b;
+
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/pyr2.c b/gcc/testsuite/gcc.c-torture/unsorted/pyr2.c
new file mode 100644
index 00000000000..12e2ccd24b2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/pyr2.c
@@ -0,0 +1,4 @@
+foo (a)
+{
+  return ((int *)0)[a];
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/q.c b/gcc/testsuite/gcc.c-torture/unsorted/q.c
new file mode 100644
index 00000000000..fa08e758a52
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/q.c
@@ -0,0 +1,7 @@
+
+unsigned
+reg0indreg1 (r0, p1)
+     unsigned short  r0;  unsigned short p1;
+{
+  return (r0 + p1);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/r.c b/gcc/testsuite/gcc.c-torture/unsorted/r.c
new file mode 100644
index 00000000000..19eeda7ab44
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/r.c
@@ -0,0 +1,7 @@
+r (a, b)
+{
+  if (a < b)
+    return 1;
+  else
+    return 2;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/r1.c b/gcc/testsuite/gcc.c-torture/unsorted/r1.c
new file mode 100644
index 00000000000..0b277b0f8dc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/r1.c
@@ -0,0 +1,29 @@
+void assert (a) {if (a != 1) abort ();}
+
+int h1 (int *p) {return *p & 255;}
+
+void p1 () {int a = 0x01020304; assert (h1 (&a) == 0x04);}
+
+
+int h2 (a) {return a > 0;}
+
+p2 () {assert (h2 (1));}
+
+h3 (int *p)
+{
+  *p |= 255;
+}
+
+p3 ()
+{
+  int *p;
+  h3 (p);
+}
+
+main ()
+{
+  p1 ();
+  p2 ();
+  p3 ();
+  puts ("Compiler test passed.");
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/rel.c b/gcc/testsuite/gcc.c-torture/unsorted/rel.c
new file mode 100644
index 00000000000..54d36052ed3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/rel.c
@@ -0,0 +1,8 @@
+foo (int *c, int b)
+{
+  int a;
+
+  a = *c + b;
+  c[1] = a;
+  return b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/rmsc.c b/gcc/testsuite/gcc.c-torture/unsorted/rmsc.c
new file mode 100644
index 00000000000..5c97c6dae14
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/rmsc.c
@@ -0,0 +1,46 @@
+
+cc1 (x, y)
+     int x, y;
+{
+  int z;
+  z = x - y;
+  if (x >= y)
+    return z + 1;
+  else
+    return z + 0;
+}
+
+cc2 (x, y)
+     int x, y;
+{
+  int z;
+
+  z = x - y;
+  if (z >= 0)
+    return z + 1;
+  else
+    return z + 0;
+}
+
+cc3 (x, y)
+     unsigned x, y;
+{
+  unsigned z;
+  z = x - y;
+  if (x >= y)
+    return z + 1;
+  else
+    return z + 0;
+}
+
+cc4 (x, y)
+     unsigned x, y;
+{
+  unsigned z;
+
+  z = x - y;
+  if (z >= 0)
+    return z + 1;
+  else
+    return z + 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/round.c b/gcc/testsuite/gcc.c-torture/unsorted/round.c
new file mode 100644
index 00000000000..5233e65ea90
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/round.c
@@ -0,0 +1,13 @@
+foo (a)
+     double a;
+{
+  printf ("%d\n", (int) a);
+}
+
+main ()
+{
+  foo (1.6);
+  foo (1.4);
+  foo (-1.4);
+  foo (-1.6);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/run.c b/gcc/testsuite/gcc.c-torture/unsorted/run.c
new file mode 100644
index 00000000000..40892f6037f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/run.c
@@ -0,0 +1,11 @@
+main ()
+{
+  typedef short int xtype;
+
+  xtype i;
+  xtype ii;
+
+  for (i = 0; i < 100; i++)
+    for (ii = 65535; --ii;)
+      ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/s.c b/gcc/testsuite/gcc.c-torture/unsorted/s.c
new file mode 100644
index 00000000000..e0c84262208
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/s.c
@@ -0,0 +1,24 @@
+struct foo
+{
+  int a, b, c, d;
+  double doubl;
+} s1, s2;
+
+struct foo
+structret (s1, i1, i2, s2)
+     struct foo s1, s2;
+     int i1, i2;
+{
+  if (i1 != i2)
+    {
+      if (i1 < i2)
+	return s1;
+      else
+	return s2;
+    }
+  s2.a = 11;
+  s2.b = 22;
+  s2.c = s1.c;
+  s2.d = s1.d;
+  return s2;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/sar.c b/gcc/testsuite/gcc.c-torture/unsorted/sar.c
new file mode 100644
index 00000000000..9bf9bec0625
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/sar.c
@@ -0,0 +1,10 @@
+struct foo
+{
+  char a;
+} foo[100];
+
+main ()
+{
+  foo[1].a = '1';
+  foo[2].a = '2';
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/sc.c b/gcc/testsuite/gcc.c-torture/unsorted/sc.c
new file mode 100644
index 00000000000..84dc60f7e90
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/sc.c
@@ -0,0 +1,5 @@
+foo (a, b)
+     int a, b;
+{
+  return (a < 0) | (a <= 0) | (a == 0) | (a != 0) | (a >= 0) | (a > 0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/scal.c b/gcc/testsuite/gcc.c-torture/unsorted/scal.c
new file mode 100644
index 00000000000..94e22aa80f5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/scal.c
@@ -0,0 +1,19 @@
+int g1, g2;
+
+void
+write_at (addr, off, val)
+     int *addr;
+     int off;
+     int val;
+{
+  g2 = 1;
+  addr[off] = val;
+  g2++;
+}
+
+main ()
+{
+  g2 = 12;
+  write_at (&g1, &g2 - &g1, 12345);
+  printf ("%d\n", g2);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/scc.c b/gcc/testsuite/gcc.c-torture/unsorted/scc.c
new file mode 100644
index 00000000000..79ae4e12f45
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/scc.c
@@ -0,0 +1,11 @@
+foo (a, b)
+{
+  if (a < 0)
+    goto ret1;
+  if (a == 0)
+    return 2;
+  return 3;
+ ret1:
+  return 1;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/scond.c b/gcc/testsuite/gcc.c-torture/unsorted/scond.c
new file mode 100644
index 00000000000..087b0a66e94
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/scond.c
@@ -0,0 +1,4 @@
+scond (a, b, c, d)
+{
+  return (a > b) & (c < d);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/selfrec.c b/gcc/testsuite/gcc.c-torture/unsorted/selfrec.c
new file mode 100644
index 00000000000..c7aaca552a0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/selfrec.c
@@ -0,0 +1,5 @@
+int
+foo (a)
+{
+  return foo (a - 1) * a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/seq.c b/gcc/testsuite/gcc.c-torture/unsorted/seq.c
new file mode 100644
index 00000000000..0793228b491
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/seq.c
@@ -0,0 +1,4 @@
+foo (a)
+{
+  return a < 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/set386.c b/gcc/testsuite/gcc.c-torture/unsorted/set386.c
new file mode 100644
index 00000000000..c16ae8dbdfe
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/set386.c
@@ -0,0 +1,5 @@
+foo (a, p)
+     int *p;
+{
+  *p = a > 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/set88.c b/gcc/testsuite/gcc.c-torture/unsorted/set88.c
new file mode 100644
index 00000000000..8069ea622a3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/set88.c
@@ -0,0 +1,9 @@
+foo (a)
+{
+  return -1 << a;
+}
+
+bar (a, b)
+{
+  return b | (-1 << a);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/sh.c b/gcc/testsuite/gcc.c-torture/unsorted/sh.c
new file mode 100644
index 00000000000..8d3265f83f7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/sh.c
@@ -0,0 +1,4 @@
+foo (a, b)
+{
+  return a << b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/shand.c b/gcc/testsuite/gcc.c-torture/unsorted/shand.c
new file mode 100644
index 00000000000..5a401961355
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/shand.c
@@ -0,0 +1,11 @@
+int
+foo (x, c)
+     int x;
+{
+  return x >> 24 & 0xff;
+}
+
+bar (x)
+{
+  return (int)(x & 0xfffff) << 13;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/shft.c b/gcc/testsuite/gcc.c-torture/unsorted/shft.c
new file mode 100644
index 00000000000..7d318c863c5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/shft.c
@@ -0,0 +1,15 @@
+foo (a)
+     int a;
+{
+  int b = 8;
+
+  if ((a << b) >= 0)
+    return 1;
+  return a;
+}
+
+main ()
+{
+  if (foo (0x00ffffff) == 1)
+    puts ("y");
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/shift.c b/gcc/testsuite/gcc.c-torture/unsorted/shift.c
new file mode 100644
index 00000000000..1ed1879c616
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/shift.c
@@ -0,0 +1,7 @@
+foo (a)
+{
+  if (a >= 0)
+    return (unsigned) a << 10;
+  else
+    return (int) a << 10;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/shloop.c b/gcc/testsuite/gcc.c-torture/unsorted/shloop.c
new file mode 100644
index 00000000000..f4c9366394a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/shloop.c
@@ -0,0 +1,7 @@
+main ()
+{
+  int volatile p;
+  int i;
+  for (i = 10000000; i > 0; i--)
+    p = i >> 10;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/shm.c b/gcc/testsuite/gcc.c-torture/unsorted/shm.c
new file mode 100644
index 00000000000..b667b26abe9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/shm.c
@@ -0,0 +1,5 @@
+foo (int *p)
+{
+  int a = *p;
+  return a >> 24;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/signext.c b/gcc/testsuite/gcc.c-torture/unsorted/signext.c
new file mode 100644
index 00000000000..2724098d031
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/signext.c
@@ -0,0 +1,27 @@
+void longprint (x)
+     long long x;
+{
+  printf (" %d, %d\n", (unsigned) ((unsigned long long) x >> 32),
+	  (unsigned) x);
+}
+
+void
+k_min (p, qa, d)
+     int d;
+{
+  int s = 1;
+  long long x;
+
+  if (s >= d)
+    s -= d;
+
+  x = ((long long)((8 * s) % 3) + qa) % d;
+  longprint (x);
+}
+
+int
+main ()
+{
+  k_min (100003, -600017, 3);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/signext2.c b/gcc/testsuite/gcc.c-torture/unsorted/signext2.c
new file mode 100644
index 00000000000..d2eb6370df8
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/signext2.c
@@ -0,0 +1,11 @@
+long long
+foo (a)
+     int a;
+{
+  return a;
+}
+
+main ()
+{
+  printf ("%d\n", (int) (foo (-1) >> 32));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/sim.c b/gcc/testsuite/gcc.c-torture/unsorted/sim.c
new file mode 100644
index 00000000000..e8c4fb42f53
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/sim.c
@@ -0,0 +1,7 @@
+main ()
+{
+  int i;
+
+  for (i = 1;  i < 10000; i++)
+    ;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/simple.c b/gcc/testsuite/gcc.c-torture/unsorted/simple.c
new file mode 100644
index 00000000000..614acba82d9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/simple.c
@@ -0,0 +1,4 @@
+foo (a)
+{
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/sne.c b/gcc/testsuite/gcc.c-torture/unsorted/sne.c
new file mode 100644
index 00000000000..6844a6e53b9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/sne.c
@@ -0,0 +1,4 @@
+foo (double a)
+{
+  return (a != 0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/sound.c b/gcc/testsuite/gcc.c-torture/unsorted/sound.c
new file mode 100644
index 00000000000..be727e3febb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/sound.c
@@ -0,0 +1,13 @@
+
+main ()
+{
+  char audio[8192];
+  int i;
+
+  for (i = 0;  i < 4095;  i += 1)
+    audio[i] = i / 8,
+    audio[8191 - i] = i / 8;
+
+  for (;;)
+    write (1, audio, 8192);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/sparcbug.c b/gcc/testsuite/gcc.c-torture/unsorted/sparcbug.c
new file mode 100644
index 00000000000..cd42a86cccc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/sparcbug.c
@@ -0,0 +1,5 @@
+foo (a)
+{
+  int b = a;
+  return b + 8762345;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/speed.c b/gcc/testsuite/gcc.c-torture/unsorted/speed.c
new file mode 100644
index 00000000000..d61407e321d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/speed.c
@@ -0,0 +1,8 @@
+main ()
+{
+  int i;
+
+  for (i = 5000000; i >=0; i--)
+    {
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/stor.c b/gcc/testsuite/gcc.c-torture/unsorted/stor.c
new file mode 100644
index 00000000000..57981eff5a6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/stor.c
@@ -0,0 +1,12 @@
+#define C 1
+
+foo (p)
+     int *p;
+{
+  p[0] = C;
+  p[1] = C;
+  p[2] = C;
+  p[3] = C;
+  p[4] = C;
+  p[5] = C;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/store0.c b/gcc/testsuite/gcc.c-torture/unsorted/store0.c
new file mode 100644
index 00000000000..3b7b16ef3bc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/store0.c
@@ -0,0 +1,4 @@
+foo (int *p)
+{
+  p[10] = 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/storecc.c b/gcc/testsuite/gcc.c-torture/unsorted/storecc.c
new file mode 100644
index 00000000000..11634691091
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/storecc.c
@@ -0,0 +1,6 @@
+foo (char *p, int a)
+{
+  *p = a;
+  if ((char) a)
+    return 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/str.c b/gcc/testsuite/gcc.c-torture/unsorted/str.c
new file mode 100644
index 00000000000..d2dec4b2303
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/str.c
@@ -0,0 +1,13 @@
+typedef struct
+{
+  char a;
+  char b;
+} foo;
+
+bar ()
+{
+  foo foobar[100];
+  foobar[1].a = 'a';
+  foobar[2].a = 'b';
+  barfoo (foobar);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/stru.c b/gcc/testsuite/gcc.c-torture/unsorted/stru.c
new file mode 100644
index 00000000000..042c5221784
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/stru.c
@@ -0,0 +1,9 @@
+struct foo
+{
+  int a, b, c;
+};
+
+foo (struct foo *a)
+{
+  a[0] = a[1];
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/structret.c b/gcc/testsuite/gcc.c-torture/unsorted/structret.c
new file mode 100644
index 00000000000..9c705d4c0a2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/structret.c
@@ -0,0 +1,69 @@
+struct foo
+{
+  int a, b, c, d;
+  double doubl;
+} s1, s2;
+
+#ifndef ONLY2
+
+struct foo
+structret (s1, i1, i2, s2)
+     struct foo s1, s2;
+     int i1, i2;
+{
+  if (i1 != i2)
+    {
+      if (i1 < i2)
+	return s1;
+      else
+	return s2;
+    }
+  s2.a = 11;
+  s2.b = 22;
+  s2.c = s1.c;
+  s2.d = s1.d;
+  return s2;
+}
+
+#endif
+
+#ifndef ONLY1
+
+struct foo
+mani (a, b)
+{
+  return structret (s1, a, b, s2);
+}
+
+init ()
+{
+  s1.a = 1;
+  s1.b = 2;
+  s1.c = 3;
+  s1.d = 4;
+  s1.doubl = 3.1415;
+  s2.a = -1;
+  s2.b = -2;
+  s2.c = -3;
+  s2.d = -4;
+  s2.doubl = 2.71818;
+}
+
+main ()
+{
+  struct foo s;
+
+  init ();
+  s = mani (1, 1);
+  printf ("%d, %d, %d, %d : %f\n", s.a, s.b, s.c, s.d, s.doubl);
+
+  init ();
+  s = mani (2, 1);
+  printf ("%d, %d, %d, %d : %f\n", s.a, s.b, s.c, s.d, s.doubl);
+
+  init ();
+  s = mani (1, 2);
+  printf ("%d, %d, %d, %d : %f\n", s.a, s.b, s.c, s.d, s.doubl);
+}
+
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/stuct.c b/gcc/testsuite/gcc.c-torture/unsorted/stuct.c
new file mode 100644
index 00000000000..deb838d8099
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/stuct.c
@@ -0,0 +1,22 @@
+#ifdef STACK_SIZE
+#define SIZE STACK_SIZE / 8
+#else
+#define SIZE 10000000
+#endif
+
+struct foo
+{
+  int a, b, c;
+  int arr[SIZE];
+};
+
+struct foo s, ss;
+
+main ()
+{
+
+  s.b = 2;
+  s.c = 3;
+  ss.b = 2;
+  ss.c = 3;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/sub32.c b/gcc/testsuite/gcc.c-torture/unsorted/sub32.c
new file mode 100644
index 00000000000..93114d96cd7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/sub32.c
@@ -0,0 +1,4 @@
+foo (a)
+{
+  return a + 32;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/subcc.c b/gcc/testsuite/gcc.c-torture/unsorted/subcc.c
new file mode 100644
index 00000000000..d50114eee42
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/subcc.c
@@ -0,0 +1,31 @@
+foo (a, c)
+{
+  int b;
+
+  if (a + c >= 0)			/* b < 0 ==== a < 10? */
+    return a | 0x80000000;
+  return 0;
+}
+
+bar (a)
+{
+  if (foo (a, 10) & 0x80000000)
+    printf ("y");
+  else
+    printf ("n");
+}
+
+main ()
+{
+  bar (0);
+  bar (1);
+  bar (-1);
+  bar (10);
+  bar (-10);
+  bar (11);
+  bar (-11);
+  bar (0x7fffffff);
+  bar (-0x7fffffff);
+
+  puts ("");
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/subcse.c b/gcc/testsuite/gcc.c-torture/unsorted/subcse.c
new file mode 100644
index 00000000000..0a10991f18a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/subcse.c
@@ -0,0 +1,6 @@
+foo (a, b, p)
+     int *p;
+{
+  p[0] = 1230 - a;
+  p[1] = 1230 - b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/sym.c b/gcc/testsuite/gcc.c-torture/unsorted/sym.c
new file mode 100644
index 00000000000..8a0fe323b03
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/sym.c
@@ -0,0 +1,4 @@
+foo ()
+{
+  return (int) &foo;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/symconst.c b/gcc/testsuite/gcc.c-torture/unsorted/symconst.c
new file mode 100644
index 00000000000..7add218108e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/symconst.c
@@ -0,0 +1,4 @@
+foo ()
+{
+  return (int)foo;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/t.c b/gcc/testsuite/gcc.c-torture/unsorted/t.c
new file mode 100644
index 00000000000..48095e7c38b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/t.c
@@ -0,0 +1,18 @@
+#define B 95
+
+foo (a, b, p)
+     unsigned a, b;
+     int *p;
+{
+  p[1] = a % B;
+  p[0] = a / B;
+}
+
+bar (a, b, p)
+     unsigned a, b;
+     int *p;
+{
+  p[0] = a / B;
+  p[1] = a % B;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/test-flow.c b/gcc/testsuite/gcc.c-torture/unsorted/test-flow.c
new file mode 100644
index 00000000000..01ec724eb2f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/test-flow.c
@@ -0,0 +1,12 @@
+foo (a, b, c, d)
+{
+  if (a < 0)
+    {
+      b = c;
+    }
+  else
+    {
+      b = d;
+    }
+  return b + 75;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/test-loop.c b/gcc/testsuite/gcc.c-torture/unsorted/test-loop.c
new file mode 100644
index 00000000000..d441dde0ca9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/test-loop.c
@@ -0,0 +1,7 @@
+main ()
+{
+  int i;
+  for (i = 100;  i >= -1; i--)
+    foo ();
+
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/test.c b/gcc/testsuite/gcc.c-torture/unsorted/test.c
new file mode 100644
index 00000000000..46e830a3521
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/test.c
@@ -0,0 +1,6 @@
+foo (a)
+{
+  if (a & 38)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/time.c b/gcc/testsuite/gcc.c-torture/unsorted/time.c
new file mode 100644
index 00000000000..7e22681d98b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/time.c
@@ -0,0 +1,7 @@
+main ()
+{
+  int i;
+  for (i = 3000000; --i;)
+    {
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/tmp.c b/gcc/testsuite/gcc.c-torture/unsorted/tmp.c
new file mode 100644
index 00000000000..463d9fb530d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/tmp.c
@@ -0,0 +1,5 @@
+foo (a, b)
+{
+  return (a - b) == 0;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/trivial.c b/gcc/testsuite/gcc.c-torture/unsorted/trivial.c
new file mode 100644
index 00000000000..e9665cd8dd7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/trivial.c
@@ -0,0 +1 @@
+foo () {}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/trunc.c b/gcc/testsuite/gcc.c-torture/unsorted/trunc.c
new file mode 100644
index 00000000000..dee0e158728
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/trunc.c
@@ -0,0 +1,11 @@
+main ()
+{
+  printf ("%x, %x\n", (unsigned char) main, main);
+}
+
+foo (p)
+     char *p;
+{
+  p[0] = (char)foo;
+  p[1] = (char)foo;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/u.c b/gcc/testsuite/gcc.c-torture/unsorted/u.c
new file mode 100644
index 00000000000..7fc0dda3784
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/u.c
@@ -0,0 +1 @@
+foo (a, b) { return a % b; }
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/udconvert.c b/gcc/testsuite/gcc.c-torture/unsorted/udconvert.c
new file mode 100644
index 00000000000..31b494fe08a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/udconvert.c
@@ -0,0 +1,30 @@
+double
+unsigned_to_double1 (u)
+     unsigned u;
+{
+  double d;
+  d = (int) u;			/* convert as from a *signed* integer */
+  return ((int) u < 0)
+    ? d + 4294967296.0
+      : d;
+}
+
+/* Alternatively */
+
+double
+unsigned_to_double2 (u)
+     unsigned u;
+{
+  double d;
+  u -= 2147483648;		/* complement sign bit */
+  d = (int) u;			/* convert as from a *signed* integer */
+  return d + 2147483648.0;
+}
+
+unsigned
+double_to_unsigned (d)
+     double d;
+{
+  d += 2147483648.0;
+  return ((int) d) - 2147483648;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/udivmod4.c b/gcc/testsuite/gcc.c-torture/unsorted/udivmod4.c
new file mode 100644
index 00000000000..40d2fa8d07c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/udivmod4.c
@@ -0,0 +1,56 @@
+long long
+xlrandom ()
+{
+  long long x;
+  unsigned a;
+  int bits = 64;
+  unsigned b;
+
+  do
+    {
+      a = random ();
+      b = (a & 15) + 1;
+      x <<= b;				/* shift up 1-16 steps */
+      a = (a >> 18) & 1;
+      if (a)
+	x |= (unsigned) (1 << b) - 1;
+      bits -= b;
+    }
+  while (bits >= 0);
+  return x;
+}
+
+
+unsigned long long __udivmoddi4();
+
+main ()
+{
+  int i;
+  unsigned long long n, d, q, r, rr;
+
+  for (i = 0; ;i++)
+    {
+      n = xlrandom ();
+      d = xlrandom ();
+      if (d == 0)
+	continue;
+
+      q = __udivmoddi4 (n, d, &r);
+
+      if (i % 1000000 == 0)
+	printf ("Testing udivmoddi4: %d iterations made\n", i);
+
+      rr = n - q * d;
+      if (rr != r || r >= d)
+	{
+	  printf ("Testing udivmoddi4: failure after %d iterations\n", i);
+	  printf ("n=%lX%08lX\n", (unsigned) (n >> 32), (unsigned) n);
+	  printf ("d=%lX%08lX\n", (unsigned) (d >> 32), (unsigned) d);
+	  printf ("q=%lX%08lX\n", (unsigned) (q >> 32), (unsigned) q);
+	  printf ("r=%lX%08lX\n", (unsigned) (r >> 32), (unsigned) r);
+	  printf ("rr=%lX%08lX\n", (unsigned) (rr >> 32), (unsigned) rr);
+	  abort ();
+	}
+    }
+
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/uns.c b/gcc/testsuite/gcc.c-torture/unsorted/uns.c
new file mode 100644
index 00000000000..314704f89d3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/uns.c
@@ -0,0 +1,5 @@
+foo (a)
+{
+  if ((unsigned) a < 234)
+    return 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/uns_tst.c b/gcc/testsuite/gcc.c-torture/unsorted/uns_tst.c
new file mode 100644
index 00000000000..e34ffaf30eb
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/uns_tst.c
@@ -0,0 +1,19 @@
+a (c)
+     unsigned char c;
+{
+  unsigned u = c;
+  if ((int)u < 0)
+    return 1;
+  else
+    return 0;
+}
+
+b (x, y)
+     unsigned x, y;
+{
+  x /= y;
+  if ((int)x < 0)
+    return 1;
+  else
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/unsorted.exp b/gcc/testsuite/gcc.c-torture/unsorted/unsorted.exp
new file mode 100644
index 00000000000..a586170a48a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/unsorted.exp
@@ -0,0 +1,54 @@
+#
+# Expect driver script for GCC Regression Tests
+#   Copyright (C) 1993, 1997 Free Software Foundation
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+#
+# Written by Jeffrey Wheat (cassidy@cygnus.com)
+#
+
+#
+# These tests come from Torbjorn Granlund's (tege@cygnus.com)
+# C torture test suite, and other contributors.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+
+#
+# This loop will run c-torture on any *.c file found in this directory.
+# If a *.c has a corresponding *.exp file, then the test is skipped as
+# as the *.exp will drive the test itself.  It is done this way so that
+# generic tests do not need a seperate .exp for it.  Only the tests that 
+# require unique options need their own .exp file.
+#
+
+foreach testcase [glob -nocomplain $srcdir/$subdir/*.c] {
+    if [file exists [file rootname $testcase].exp] then {
+	verbose "INFO:\"[file rootname $testcase].exp\" exists, skipping test" 3
+	continue
+    }
+
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $testcase] then {
+	continue
+    }
+
+    c-torture $testcase
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/uuarg.c b/gcc/testsuite/gcc.c-torture/unsorted/uuarg.c
new file mode 100644
index 00000000000..8928b3e0768
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/uuarg.c
@@ -0,0 +1,4 @@
+foo (a, b, c, d, e, f, g, h, i)
+{
+  return foo () + i;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/v.c b/gcc/testsuite/gcc.c-torture/unsorted/v.c
new file mode 100644
index 00000000000..87ac00aef64
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/v.c
@@ -0,0 +1,11 @@
+main (int *p)
+{
+  int a;
+
+  a = 0;
+  p[1] = a;
+  a = 0;
+  p[2] = a;
+  a = 123456;
+  p[3] = a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/w.c b/gcc/testsuite/gcc.c-torture/unsorted/w.c
new file mode 100644
index 00000000000..1acfe1512a5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/w.c
@@ -0,0 +1 @@
+int foo (unsigned short a, unsigned short b) { return a + b; }
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/ww.c b/gcc/testsuite/gcc.c-torture/unsorted/ww.c
new file mode 100644
index 00000000000..657f8c6b839
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/ww.c
@@ -0,0 +1,7 @@
+foo (p)
+     short *p;
+{
+  static int *foo;
+  *p = 1234;
+  *foo = 1234;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/x.c b/gcc/testsuite/gcc.c-torture/unsorted/x.c
new file mode 100644
index 00000000000..baf98960cfd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/x.c
@@ -0,0 +1 @@
+f(m){int i,s=0;for(i=0;i<m;i++)s+=i;return s;}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xb.c b/gcc/testsuite/gcc.c-torture/unsorted/xb.c
new file mode 100644
index 00000000000..09087ccf387
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xb.c
@@ -0,0 +1,17 @@
+foo (a, b)
+{
+  unsigned x = 1;
+
+  a += b;
+  a += x;
+  if (a <= 0)
+    return 1;
+  return 0;
+}
+
+main ()
+{
+  printf ("%d\n", foo (1, ~0));
+  printf ("%d\n", foo (0, ~0));
+  printf ("%d\n", foo (-1, ~0));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xbg.c b/gcc/testsuite/gcc.c-torture/unsorted/xbg.c
new file mode 100644
index 00000000000..b600964d420
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xbg.c
@@ -0,0 +1,14 @@
+typedef short type;
+
+short
+foo (type *sp, int a)
+{
+  type t;
+  int i;
+
+  t = sp[a];
+  i = (int)(type)sp[a];
+  if (i)
+    return 0;
+  return t;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xc.c b/gcc/testsuite/gcc.c-torture/unsorted/xc.c
new file mode 100644
index 00000000000..aed06a04ecd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xc.c
@@ -0,0 +1,11 @@
+foo (a, p)
+     int *p;
+{
+  int b;
+
+  a++;
+  b = *p;
+  if (a)
+    return 1;
+  return b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xcsebug.c b/gcc/testsuite/gcc.c-torture/unsorted/xcsebug.c
new file mode 100644
index 00000000000..614a6e80ebf
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xcsebug.c
@@ -0,0 +1,14 @@
+int g1;
+int g2;
+
+foo ()
+{
+  int i = 1;
+  int x;
+
+  x = g1;
+  (*(&g1 + i - 1)) = x + 1;
+  x = g1;
+  (*(&g1 + i - 1)) = x + 1;
+  g1++;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xdi.c b/gcc/testsuite/gcc.c-torture/unsorted/xdi.c
new file mode 100644
index 00000000000..413dd6cf84d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xdi.c
@@ -0,0 +1,15 @@
+foo (long long *p, int a, int b)
+{
+  *(p + a + b) = 876243243874343LL;
+}
+
+bar (p, pp)
+     long long *p, *pp;
+{
+  long long a;
+  *p++ = a;
+  fee (*p);
+    *p++ = *pp--;
+    *p++ = *pp--;
+  return (int) p;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xfoo.c b/gcc/testsuite/gcc.c-torture/unsorted/xfoo.c
new file mode 100644
index 00000000000..da879d2aa13
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xfoo.c
@@ -0,0 +1,4 @@
+foo (a)
+{
+  return (a & ~0xfff) == 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xi.c b/gcc/testsuite/gcc.c-torture/unsorted/xi.c
new file mode 100644
index 00000000000..54b42c5a377
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xi.c
@@ -0,0 +1,7 @@
+foo (a)
+{
+  int r = 0;
+  if (a)
+    r = 1;
+  return r;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xlop.c b/gcc/testsuite/gcc.c-torture/unsorted/xlop.c
new file mode 100644
index 00000000000..6506bfd3415
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xlop.c
@@ -0,0 +1,11 @@
+foo (a)
+{
+  int b;
+  do
+    {
+      b = bar ();
+      a = b - 10;
+    }
+  while (a > 10);
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xmtst.c b/gcc/testsuite/gcc.c-torture/unsorted/xmtst.c
new file mode 100644
index 00000000000..ca78fcaac12
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xmtst.c
@@ -0,0 +1,26 @@
+p1 (int b, int *p, int a)
+{
+  p[0] = p[1];
+  return p[0];
+}
+p2 (int b, int *p, int a)
+{
+  p[0] = p[1];
+  return p[0] == 0;
+}
+p3 (int b, int *p, int a)
+{
+  p[0] = p[1];
+  a = p[0];
+  if (a)
+    return 0;
+  return a;
+}
+p4 (int b, int *p, int a)
+{
+  a = p[1];
+  p[0] = p[1];
+  if (a)
+    return 0;
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xneg.c b/gcc/testsuite/gcc.c-torture/unsorted/xneg.c
new file mode 100644
index 00000000000..ff5b8503482
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xneg.c
@@ -0,0 +1,5 @@
+foo (a)
+     double a;
+{
+  return -a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xopt.c b/gcc/testsuite/gcc.c-torture/unsorted/xopt.c
new file mode 100644
index 00000000000..b1a50f86cef
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xopt.c
@@ -0,0 +1,35 @@
+proc1 (a)
+     unsigned a;
+{
+  return (a >> 20) & 0x010fffff;
+}
+
+proc2 (a)
+     unsigned a;
+{
+  return (a << 17) & 0xfffff001;
+}
+
+proc3 (a)
+     unsigned a;
+{
+  return (a & 0xff00000a) >> 25;
+}
+
+proc4 (a)
+     unsigned a;
+{
+  return (a & 0x100000ff) << 25;
+}
+
+proc5 (a)
+     unsigned a;
+{
+  return (unsigned char) (a >> 24);
+}
+
+proc6 (a)
+     unsigned a;
+{
+  return ((unsigned char) a) << 30;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xor.c b/gcc/testsuite/gcc.c-torture/unsorted/xor.c
new file mode 100644
index 00000000000..435f2231e64
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xor.c
@@ -0,0 +1,4 @@
+foo (a, b)
+{
+  return ~(a ^ ~123);
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xorn.c b/gcc/testsuite/gcc.c-torture/unsorted/xorn.c
new file mode 100644
index 00000000000..d7b75f936bd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xorn.c
@@ -0,0 +1,31 @@
+int
+xorn (a, b)
+     int a, b;
+{
+  return a ^ ~b;
+}
+
+int
+not (a)
+     int a;
+{
+  return ~a;
+}
+
+int
+xor (a, b)
+     int a, b;
+{
+  return a ^ b;
+}
+
+main ()
+{
+  int i, j;
+
+  for (i = 0;  i <= 1;  i++)
+    for (j = 0;  j <= 1;  j++)
+      printf ("%d op %d = %d = %d?\n", i, j,
+	      1 & xor (i, not (j)),
+	      1 & xorn (i, j));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xp.c b/gcc/testsuite/gcc.c-torture/unsorted/xp.c
new file mode 100644
index 00000000000..139335c0287
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xp.c
@@ -0,0 +1,4 @@
+foo (a)
+{
+  return a & 255;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xpp.c b/gcc/testsuite/gcc.c-torture/unsorted/xpp.c
new file mode 100644
index 00000000000..daf3399a3f4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xpp.c
@@ -0,0 +1,12 @@
+foo (a)
+{
+  a++;
+  if (a < 10)
+    return 1;
+  return a;
+}
+
+main ()
+{
+  printf ("%d\n", foo ((1 << 31) - 1));
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xs.c b/gcc/testsuite/gcc.c-torture/unsorted/xs.c
new file mode 100644
index 00000000000..24f773e7577
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xs.c
@@ -0,0 +1,9 @@
+foo (a, b)
+{
+  for (b = 0; b < 10; b++)
+    ;
+  for (a = 0; a < 10; a++)
+    ;
+  a = b << 1;
+  return a;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xsh.c b/gcc/testsuite/gcc.c-torture/unsorted/xsh.c
new file mode 100644
index 00000000000..9ba0b6c9e02
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xsh.c
@@ -0,0 +1,7 @@
+foo (a, b)
+{
+  a = b + b;
+  if (a)
+    return a;
+  return b;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xz.c b/gcc/testsuite/gcc.c-torture/unsorted/xz.c
new file mode 100644
index 00000000000..97a1d1e2cdc
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xz.c
@@ -0,0 +1,4 @@
+foo (int *p)
+{
+  *p = (unsigned short) *p;
+}
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/xzz.c b/gcc/testsuite/gcc.c-torture/unsorted/xzz.c
new file mode 100644
index 00000000000..f1972b6c618
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/unsorted/xzz.c
@@ -0,0 +1,4 @@
+foo (a, b)
+{
+  return a >> (char) b;
+}
diff --git a/gcc/testsuite/gcc.dg/980211-1.c b/gcc/testsuite/gcc.dg/980211-1.c
new file mode 100644
index 00000000000..6332b7e7e3f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980211-1.c
@@ -0,0 +1,27 @@
+/* Test long double on x86. */
+
+/* { dg-do run { target i?86-*-* } } */
+/* { dg-options -O2 } */
+
+__inline int
+__signbitl (long double __x)
+{
+  union { long double __l; int __i[3]; } __u = { __l: __x };
+
+  return (__u.__i[2] & 0x8000) != 0;
+}
+
+void
+foo (long double x, long double y)
+{
+  long double z = x / y;
+  if (__signbitl (x) && __signbitl (z))
+    abort ();
+}
+
+int main()
+{
+  if (sizeof (long double) > sizeof (double))
+    foo (-0.0, -1.0);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/980217-1.c b/gcc/testsuite/gcc.dg/980217-1.c
new file mode 100644
index 00000000000..2236e848d03
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980217-1.c
@@ -0,0 +1,36 @@
+/* Test float on alpha. */
+
+/* { dg-do run { target alpha*-*-* } } */
+/* { dg-options "-mieee -O2" } */
+
+typedef int int32_t __attribute__ ((__mode__ (  __SI__ ))) ;
+typedef union
+{
+  float value;
+  int32_t word;
+} ieee_float_shape_type;
+
+int isinff(float x)
+{
+  int32_t ix,t;
+  ieee_float_shape_type gf_u;
+  gf_u.value = x;
+  ix = gf_u.word;
+  printf ("%x\n", ix);
+  t = ix & 0x7fffffff;
+  t ^= 0x7f800000;
+  t |= -t;
+  return ~(t >> 31) & (1 - ((ix & 0x80000000) >> 30));
+}
+
+main ()
+{
+  float x = 1.0 / 0.0;
+  int i = isinff (x);
+
+  if (i == 0)
+    abort ();
+
+  printf ("%d\n", i);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/980226-1.c b/gcc/testsuite/gcc.dg/980226-1.c
new file mode 100644
index 00000000000..f66e9e2a9f7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980226-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target i?86-*-* } } */
+/* { dg-options -O2 } */
+
+extern double bar (double);
+
+int
+baz (double d)
+{
+  double e = bar (d);
+  asm volatile ("" : : : "st");
+  return printf ("%lg\n", e);
+}
diff --git a/gcc/testsuite/gcc.dg/980312-1.c b/gcc/testsuite/gcc.dg/980312-1.c
new file mode 100644
index 00000000000..8f72c31d341
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980312-1.c
@@ -0,0 +1,24 @@
+/* { dg-do link { target i?86-*-* } } */
+/* { dg-options "-O2 -march=pentiumpro" } */
+
+extern __inline  double
+__expm1 (double __x)
+{
+  double __temp;
+  __temp = 1.0;
+  return __temp;
+}
+extern __inline  double
+__sgn1 (double __x)
+{
+  return __x >= 0.0 ? 1.0 : -1.0;
+}
+double
+tanh (double __x)
+{
+  return  __expm1 (__x) * __sgn1 (-__x);
+}
+main ()
+{
+  return tanh (3.45) != 0;
+}
diff --git a/gcc/testsuite/gcc.dg/980313-1.c b/gcc/testsuite/gcc.dg/980313-1.c
new file mode 100644
index 00000000000..1036339b076
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980313-1.c
@@ -0,0 +1,25 @@
+/* { dg-do link { target i?86-*-* } } */
+/* { dg-options "-O2 -march=pentiumpro" } */
+
+extern __inline  double
+__expm1 (double __x)
+{
+  double __temp;
+  __temp -= 1.0;
+  return __temp;
+}
+extern __inline  double
+__sgn1 (double __x)
+{
+  return __x >= 0.0 ? 1.0 : -1.0;
+}
+double
+tanh (double __x)
+{
+  register double __exm1 = __expm1 (__x);
+  return __exm1 / (__exm1 + 2.0) * __sgn1 (-__x);
+}
+main ()
+{
+  return tanh (3.45) != 0;
+}
diff --git a/gcc/testsuite/gcc.dg/980414-1.c b/gcc/testsuite/gcc.dg/980414-1.c
new file mode 100644
index 00000000000..8fd0e127296
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980414-1.c
@@ -0,0 +1,76 @@
+/* Test double on x86. */
+
+/* { dg-do run { target i?86-*-* } } */
+/* { dg-options -O2 } */
+
+static __inline  double
+mypow (double __x, double __y)
+{
+  register double __value, __exponent;
+  long __p = (long) __y;
+  if (__y == (double) __p)
+    {
+      double __r = 1.0;
+      if (__p == 0)
+	return 1.0;
+      if (__p < 0)
+	{
+	  __p = -__p;
+	  __x = 1.0 / __x;
+	}
+      while (1)
+	{
+	  if (__p & 1)
+	    __r *= __x;
+	  __p >>= 1;
+	  if (__p == 0)
+	    return __r;
+	  __x *= __x;
+	}
+    }
+  __asm __volatile__
+    ("fmul	%%st(1),%%st\n\t"	/* y * log2(x) */
+     "fst	%%st(1)\n\t"
+     "frndint\n\t"			/* int(y * log2(x)) */
+     "fxch\n\t"
+     "fsub	%%st(1),%%st\n\t"	/* fract(y * log2(x)) */
+     "f2xm1\n\t"			/* 2^(fract(y * log2(x))) - 1 */
+     : "=t" (__value), "=u" (__exponent) :  "0" (__x), "1" (__y));
+  __value += 1.0;
+  __asm __volatile__
+    ("fscale"
+     : "=t" (__value) : "0" (__value), "u" (__exponent));
+  return __value;
+}
+
+const double E1 = 2.71828182845904523536028747135;
+
+double fact (double x)
+{
+  double corr;
+  corr = 1.0;
+  return corr * mypow(x/E1, x);
+}
+
+int main ()
+{
+  double y, z;
+
+  y = fact (46.2);
+  z = mypow (46.2/E1, 46.2);
+
+#if 0
+  printf ("%26.19e, %26.19e\n", y, z);
+#endif
+
+  if (y > z)
+    y -= z;
+  else
+    y = z - y;
+
+  y /= z;
+  if (y > 0.1)
+    abort ();
+ 
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/980502-1.c b/gcc/testsuite/gcc.dg/980502-1.c
new file mode 100644
index 00000000000..f06491cd96c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980502-1.c
@@ -0,0 +1,9 @@
+/* { dg-do compile  }*/
+/* { dg-options "-O2" } */
+
+char *const f(void)
+{
+        char *const line = "/dev/ptyXX";
+        line[8] = 1;
+        return line;
+}
diff --git a/gcc/testsuite/gcc.dg/980520-1.c b/gcc/testsuite/gcc.dg/980520-1.c
new file mode 100644
index 00000000000..e1401824f54
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980520-1.c
@@ -0,0 +1,17 @@
+/* { dg-do compile { target i?86-*-* } } */
+/* { dg-options -O2 } */
+
+int bug(void)
+{
+        unsigned long a, b;
+   
+        __asm__(""
+                : "=d" (a)
+                :
+                : "memory");
+        __asm__ __volatile__(""
+                             :
+                             : "g" (b)
+                             : "memory");
+        return a;
+}
diff --git a/gcc/testsuite/gcc.dg/980523-1.c b/gcc/testsuite/gcc.dg/980523-1.c
new file mode 100644
index 00000000000..6265a733780
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980523-1.c
@@ -0,0 +1,51 @@
+/* { dg-do run { target rs6000-*-linux* powerpc-*-linux*} } */
+/* { dg-options "-O2 -fpic" } */
+
+void foo1(int a, char *b, int c)
+{
+   c =a+c+234;
+}
+
+int foo2(int d)
+{
+   return d*d;
+}
+
+int bar1, bar2, bar3;
+char * bar4;
+
+int main(void) {
+    int h;
+    bar1 = foo2(1);
+    bar2 = foo2(1);
+
+    h = foo2(1);
+    foo1(1, "a", foo2(1));
+    foo1(bar1, "a", foo2(1));
+    foo2(1);
+
+    h = foo2(1);
+    bar3 = 1;
+    bar4 = "a";
+    foo1(1, "n", foo2(1));
+    foo1(1, "o", foo2(1));
+    foo1(1, "p", foo2(1));
+    foo1(bar1, "a", foo2(1));
+
+    bar3 = h;
+    bar4 = "b";  foo1(bar1, "b", foo2(1));
+    foo1(1, "q", foo2(1));
+    bar4 = "c";  foo1(1, "c", foo2(1));
+    bar4 = "d";  foo1(1, "d", foo2(1));
+    bar4 = "e";  foo1(1, "e", foo2(1));
+    bar4 = "f";  foo1(1, "f", foo2(1));
+    bar4 = "g";  foo1(1, "g", foo2(1));
+    bar4 = "h";  foo1(1, "h", foo2(1));
+    bar4 = "i";  foo1(1, "i", foo2(1));
+    bar4 = "j";  foo1(1, "j", foo2(1));
+    bar4 = "k";  foo1(1, "k", foo2(1));
+    bar4 = "l";  foo1(1, "l", foo2(1));
+    bar4 = "m";
+    foo1(bar2, "m", foo2(1));
+    exit(0);
+}
diff --git a/gcc/testsuite/gcc.dg/980526-1.c b/gcc/testsuite/gcc.dg/980526-1.c
new file mode 100644
index 00000000000..08ef6e285a1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980526-1.c
@@ -0,0 +1,17 @@
+/* { dg-do compile { target rs6000-*-linux* powerpc-*-linux* } } */
+/* { dg-options "-O2 -fpic" } */
+
+int
+test(void)
+{
+    double value, maxValue = - (__extension__	((union { unsigned __l __attribute__((__mode__(__DI__))); double __d; }) { __l: 0x7ff0000000000000ULL }).__d)  ;
+    int idx, maxIdx = 1;
+
+    for (idx = 1; idx < 22; idx++) {
+        if (value > maxValue) {
+            maxValue = value;
+            maxIdx = idx;
+        }
+    }
+    return 0 ;
+}
diff --git a/gcc/testsuite/gcc.dg/980709-1.c b/gcc/testsuite/gcc.dg/980709-1.c
new file mode 100644
index 00000000000..a4359300587
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980709-1.c
@@ -0,0 +1,20 @@
+/* { dg-do compile { target i?86-*-* } } */
+/* { dg-options -O2 } */
+
+extern __inline__ int test_and_set_bit(int nr, volatile void * addr)
+{
+	int oldbit;
+	__asm__ __volatile__( "" 
+		"btsl %2,%1\n\tsbbl %0,%0"
+		:"=r" (oldbit),"=m" (addr)
+		:"ir" (nr));
+	return oldbit;
+}
+struct buffer_head {
+	unsigned long b_state;		 
+};
+extern void lock_buffer(struct buffer_head * bh)
+{
+	while (test_and_set_bit(2 , &bh->b_state))
+		__wait_on_buffer(bh);
+}
diff --git a/gcc/testsuite/gcc.dg/980816-1.c b/gcc/testsuite/gcc.dg/980816-1.c
new file mode 100644
index 00000000000..2a96ef4bcc9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980816-1.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options -fno-force-mem } */
+
+int
+div_and_round_double (lden_orig, hden_orig)
+     int lden_orig, hden_orig;
+{
+  int quo[4];
+  register int i;
+  unsigned int  work;
+  register unsigned int  carry = 0;
+  int  lden = lden_orig;
+  int  hden = hden_orig;
+  neg_double (&lden, &hden);
+  for (i = 4 - 1; i >= 0; i--)
+    {
+      quo[i] = work / (unsigned int ) lden;
+      carry = work % (unsigned int ) lden;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/980827-1.c b/gcc/testsuite/gcc.dg/980827-1.c
new file mode 100644
index 00000000000..0de02ccc58f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/980827-1.c
@@ -0,0 +1,26 @@
+/* { dg-do run { target rs6000-*-linux* powerpc-*-linux*} } */
+/* { dg-options -O2 } */
+
+double dval = 0;
+
+void splat (double d);
+
+int main(void)
+{
+  splat(0);
+  if (dval == 0)
+    abort();
+  exit (0);
+}
+
+void splat (double d)
+{
+  union {
+    double f;
+    unsigned int l[2];
+  } u;
+  
+  u.f = d + d;
+  u.l[1] |= 1;
+  asm volatile ("stfd %0,dval@sdarel(13)" : : "f" (u.f));
+}
diff --git a/gcc/testsuite/gcc.dg/990117-1.c b/gcc/testsuite/gcc.dg/990117-1.c
new file mode 100644
index 00000000000..2e7ea5a1551
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990117-1.c
@@ -0,0 +1,21 @@
+/* { dg-do compile { target i?86-*-* } } */
+/* { dg-options "-O2 -march=pentiumpro" } */
+
+extern __inline  double
+fabs (double __x)
+{
+  register double __value;
+  __asm __volatile__
+    ("fabs"
+     : "=t" (__value) : "0" (__x));
+  return __value;
+}
+int
+foo ()
+{
+  int i, j, k;
+  double x = 0, y = ((i == j) ? 1 : 0);
+  for (i = 0; i < 10; i++)
+    ;
+  fabs (x - y);
+}
diff --git a/gcc/testsuite/gcc.dg/990119-1.c b/gcc/testsuite/gcc.dg/990119-1.c
new file mode 100644
index 00000000000..7e33518a35c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990119-1.c
@@ -0,0 +1,15 @@
+/* This checks for two things:
+   - an obscure corner case in the standard rules for __LINE__
+   - regression of an associated bug in cpplib where the semicolon got lost */
+/* { dg-do run } */
+
+int i = __LINE__\
+;
+
+int main (void)  /* { dg-bogus "parse error" "semicolon eaten" } */
+{
+  if (i != 6)
+    abort();
+  else
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/990130-1.c b/gcc/testsuite/gcc.dg/990130-1.c
new file mode 100644
index 00000000000..3e711c2febb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990130-1.c
@@ -0,0 +1,24 @@
+/* { dg-do compile { target i?86-*-* } } */
+/* { dg-options -O0 } */
+
+typedef 	 int SItype	__attribute__ ((mode (SI)));
+typedef		 int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+  struct DIstruct {SItype low, high;};
+typedef union
+{
+  struct DIstruct s;
+  DItype ll;
+} DIunion;
+DItype
+__muldi3 (DItype u, DItype v)
+{
+  DIunion w;
+  DIunion uu, vv;
+  uu.ll = u,
+  vv.ll = v;
+  w.ll = ({DIunion __w;	__asm__ ("mull %3"	: "=a" ((USItype) (  __w.s.low )),	"=d" ((USItype) ( __w.s.high ))	: "%0" ((USItype) (   uu.s.low  )),	"rm" ((USItype) (    vv.s.low  ))) ;	__w.ll; }) ;
+  w.s.high += ((USItype) uu.s.low * (USItype) vv.s.high
+	       + (USItype) uu.s.high * (USItype) vv.s.low);
+  return w.ll;
+}
diff --git a/gcc/testsuite/gcc.dg/990213-1.c b/gcc/testsuite/gcc.dg/990213-1.c
new file mode 100644
index 00000000000..a7c9f24898a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990213-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-W -Wall -Werror" } */
+
+static inline int unused_fn(int dummyarg)
+{
+	return dummyarg*dummyarg;
+}
+
+int main()
+{
+	return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/990213-2.c b/gcc/testsuite/gcc.dg/990213-2.c
new file mode 100644
index 00000000000..6e6b924ed89
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990213-2.c
@@ -0,0 +1,15 @@
+/* { dg-do compile { target i?86-*-* } } */
+/* { dg-options "-fPIC" } */
+
+struct normal_encoding {};
+struct unknown_encoding {};
+static const struct normal_encoding latin1_encoding = {};
+
+struct encoding*
+XmlInitUnknownEncoding(void *mem)
+{
+  int i;
+  struct unknown_encoding *e = mem;
+  for (i = 0; i < sizeof(struct normal_encoding); i++)
+    ((char *)mem)[i] = ((char *)&latin1_encoding)[i];
+}
diff --git a/gcc/testsuite/gcc.dg/990214-1.c b/gcc/testsuite/gcc.dg/990214-1.c
new file mode 100644
index 00000000000..5701b5df713
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990214-1.c
@@ -0,0 +1,15 @@
+/* { dg-do compile { target i?86-*-* } } */
+/* { dg-options "-fPIC" } */
+
+typedef int int64_t __attribute__ ((__mode__ (  __DI__ ))) ;
+unsigned *
+bar (int64_t which)
+{
+	switch (which & 15 ) {
+	case 0 :
+		break;
+	case 1 :
+	case 5 :
+	case 2 :
+	}
+}
diff --git a/gcc/testsuite/gcc.dg/990228-1.c b/gcc/testsuite/gcc.dg/990228-1.c
new file mode 100644
index 00000000000..4b846ea219f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990228-1.c
@@ -0,0 +1,29 @@
+/* Regression test for cpp.  The following input may cause core dumps
+   or # line markers in the middle of the line.  */
+/* { dg-do preprocess } */
+
+#define foo(string, arg) bar(2, string, arg)
+
+foo ("\
+\
+\
+\
+\
+\
+\
+\
+\
+\
+\
+",
+NULL);
+
+/*
+   { dg-final { if ![file exists 990228-1.i] { return }			} }
+   { dg-final { set tmp [grep 990228-1.i ".#"]				} }
+   { dg-final { if { [string length $tmp] == 0 } \{			} }
+   { dg-final {     pass "990228-1.c: linemarkers in middle of line"	} }
+   { dg-final { \} else \{						} }
+   { dg-final {     fail "990228-1.c: linemarkers in middle of line"    } }
+   { dg-final { \}							} }
+ */
diff --git a/gcc/testsuite/gcc.dg/990407-1.c b/gcc/testsuite/gcc.dg/990407-1.c
new file mode 100644
index 00000000000..96b3f862639
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990407-1.c
@@ -0,0 +1,18 @@
+/* Regression test for a cpplib macro-expansion bug where
+   `@' becomes `@@' when stringified.  */
+
+/* { dg-do run } */
+
+#include <string.h>
+
+#define STR(x) #x
+
+char *a = STR(@foo), *b = "@foo";
+
+int
+main(void)
+{
+  if (strcmp (a, b))
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/990409-1.c b/gcc/testsuite/gcc.dg/990409-1.c
new file mode 100644
index 00000000000..cda9dd87ad8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990409-1.c
@@ -0,0 +1,18 @@
+/* Test that __LINE__ works when embedded in a macro. */
+/* { dg-do run } */
+
+#define XLINE __LINE__
+
+void
+bar(int x, int y)
+{
+    if (x != y)
+	abort();
+}
+
+int
+main(void)
+{
+    bar(XLINE, __LINE__);
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/990413-1.c b/gcc/testsuite/gcc.dg/990413-1.c
new file mode 100644
index 00000000000..591159abc67
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990413-1.c
@@ -0,0 +1,13 @@
+/* Verify that cpp doesn't screw up the line numbering when a macro argument
+   extends over multiple lines.  */
+/* { dg-do compile } */
+
+#define FOO(x)  /* nothing */
+
+void
+func(void)
+{
+  FOO(i
+      = 4)
+  else;  /* { dg-error "parse error" "error on this line" { target native } { 12 } } */ 
+}
diff --git a/gcc/testsuite/gcc.dg/990424-1.c b/gcc/testsuite/gcc.dg/990424-1.c
new file mode 100644
index 00000000000..589e0468e76
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990424-1.c
@@ -0,0 +1,26 @@
+/* Test that stack alignment is preserved with pending_stack_adjust
+   with stdcall functions.  */
+
+/* { dg-do run { target i?86-*-* } } */
+/* { dg-options -mpreferred-stack-boundary=4 } */
+
+void __attribute__((stdcall)) foo(int a, int b, int c);
+
+int
+main ()
+{
+  foo(1, 2, 3);
+  foo(1, 2, 3);
+  exit (0);
+}
+
+void __attribute__((stdcall))
+foo(int a, int b, int c)
+{
+  static int last_align = -1;
+  int dummy, align = (int)&dummy & 15;
+  if (last_align < 0)
+    last_align = align;
+  else if (align != last_align)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/990506-0.c b/gcc/testsuite/gcc.dg/990506-0.c
new file mode 100644
index 00000000000..7db7215721a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/990506-0.c
@@ -0,0 +1,9 @@
+/* Verify that a diagnostic is issued without crashing due to
+   --enable-checking catching a bug in the C front end.  */
+/* { dg-do compile } */
+x()
+{
+  foo (i);
+  /* { dg-error "undeclared" "undeclared-variable message" { target native } { 6 } } */
+  /* { dg-error "function it appears in" "reminder message" { target native } { 6 } } */ 
+}
diff --git a/gcc/testsuite/gcc.dg/README b/gcc/testsuite/gcc.dg/README
new file mode 100644
index 00000000000..6f14899edf9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/README
@@ -0,0 +1,16 @@
+Notes for testsuite/gcc.dg.
+
+1) There should be only one driver, dg.exp.
+
+2) Try to organize the tests by topic using file name prefixes.
+
+   Eg: All bitfield tests are named "bf-*.c".
+
+   This lets the person running the tests choose particular sets of tests to
+   run easily (using wildcards).
+
+   Eg: make check RUNTESTFLAGS='dg.exp=bf-*.c'
+
+3) Remember DOS file name restrictions (8.3).  Sigh.
+
+4) Send bugs, comments, etc. to dje@cygnus.com.
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.dg/bf-spl1.c b/gcc/testsuite/gcc.dg/bf-spl1.c
new file mode 100644
index 00000000000..df3f4817043
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/bf-spl1.c
@@ -0,0 +1,58 @@
+/* { dg-do run { target m68k-*-* sparc-*-* } } */
+/* { dg-options { -m68000 -O2 } { target m68k-*-* } } */
+/* { dg-options { -O2 } { target sparc-*-* } } */
+
+typedef SFtype __attribute__ ((mode (SF)));
+typedef DFtype __attribute__ ((mode (DF)));
+
+typedef int HItype __attribute__ ((mode (HI)));
+typedef int SItype __attribute__ ((mode (SI)));
+typedef int DItype __attribute__ ((mode (DI)));
+
+typedef unsigned int UHItype __attribute__ ((mode (HI)));
+typedef unsigned int USItype __attribute__ ((mode (SI)));
+typedef unsigned int UDItype __attribute__ ((mode (DI)));
+
+typedef UDItype fractype;
+typedef USItype halffractype;
+typedef DFtype FLO_type;
+typedef DItype intfrac;
+
+
+typedef union
+{
+  long long foo;
+  FLO_type value;
+  struct
+    {
+      fractype fraction:52 __attribute__ ((packed));
+      unsigned int exp:11 __attribute__ ((packed));
+      unsigned int sign:1 __attribute__ ((packed));
+    }
+  bits;
+} FLO_union_type;
+
+void foo (long long a);
+long long x; 
+
+void
+pack_d ()
+{
+  FLO_union_type dst = { 0x0123456789abcdefLL };
+
+  x = dst.bits.fraction;
+}
+
+main ()
+{
+  pack_d ();
+  foo (x);
+  return 0;
+}
+
+void
+foo (long long a)
+{
+  if (a != 0x0123456789abcLL)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/cast-qual-1.c b/gcc/testsuite/gcc.dg/cast-qual-1.c
new file mode 100644
index 00000000000..a7a34700bd5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cast-qual-1.c
@@ -0,0 +1,30 @@
+/* Incorrect `cast discards `const'' warnings.  There should be warnings
+   in bad_cast and bad_assign; bad_assign gets the correct warning, but
+   good_cast may get the warning instead of bad_cast.
+   gcc 2.7.2.3 passes, egcs-1.1.2 and egcs-ss-19990428 fail.
+   http://www.cygnus.com/ml/egcs-bugs/1998-Aug/0635.html */
+/* { dg-do compile } */
+/* { dg-options "-Wcast-qual" } */
+void
+good_cast(const void *bar)
+{
+  (char *const *)bar; /* { dg-bogus "cast discards" "discarding `const' warning" } */
+}
+
+void
+bad_cast(const void *bar)
+{
+  (const char **)bar; /* { dg-warning "cast discards" "discarding `const' warning" } */
+}
+
+void
+good_assign(const void *bar)
+{
+  char *const *foo = bar;
+}
+
+void
+bad_assign(const void *bar)
+{
+  const char **foo = bar; /* { dg-warning "initialization discards" "discarding `const' warning" } */
+}
diff --git a/gcc/testsuite/gcc.dg/clobbers.c b/gcc/testsuite/gcc.dg/clobbers.c
new file mode 100644
index 00000000000..0eddc14f953
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/clobbers.c
@@ -0,0 +1,27 @@
+/* Test asm clobbers on x86. */
+
+/* { dg-do run { target i?86-*-* } } */
+
+int main ()
+{
+        int i;
+        __asm__ ("movl $1,%0\n\txorl %%eax,%%eax" : "=r" (i) : : "eax");
+        if (i != 1)
+                abort ();
+        __asm__ ("movl $1,%0\n\txorl %%ebx,%%ebx" : "=r" (i) : : "ebx");
+        if (i != 1)
+                abort ();
+        __asm__ ("movl $1,%0\n\txorl %%ecx,%%ecx" : "=r" (i) : : "ecx");
+        if (i != 1)
+                abort ();
+        __asm__ ("movl $1,%0\n\txorl %%edx,%%edx" : "=r" (i) : : "edx");
+        if (i != 1)
+                abort ();
+        __asm__ ("movl $1,%0\n\txorl %%esi,%%esi" : "=r" (i) : : "esi");
+        if (i != 1)
+                abort ();
+        __asm__ ("movl $1,%0\n\txorl %%edi,%%edi" : "=r" (i) : : "edi");
+        if (i != 1)
+                abort ();
+        return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/compare1.c b/gcc/testsuite/gcc.dg/compare1.c
new file mode 100644
index 00000000000..bba5f1d1dce
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/compare1.c
@@ -0,0 +1,26 @@
+/* Test for a bogus warning on comparison between signed and unsigned.
+   This was inspired by code in gcc. */
+
+/* { dg-do compile } */
+/* { dg-options "-Wsign-compare" } */
+
+int target_flags = 1;
+
+enum machine_mode 
+{
+  VOIDmode , PQImode , QImode , PHImode , HImode ,
+  PSImode , SImode , PDImode , DImode , TImode , OImode , QFmode ,
+  HFmode , TQFmode , SFmode , DFmode , XFmode , TFmode , QCmode ,
+  HCmode , SCmode , DCmode , XCmode , TCmode , CQImode , CHImode ,
+  CSImode , CDImode , CTImode , COImode , BLKmode , CCmode , CCXmode,
+  CC_NOOVmode, CCX_NOOVmode, CCFPmode, CCFPEmode , MAX_MACHINE_MODE 
+};
+
+#define Pmode ( target_flags ? DImode : SImode )
+
+int main()
+{
+  enum machine_mode mode = DImode;
+
+  return (mode == Pmode); /* dg-bogus "warning:" "comparison between signed and unsigned" } */
+}
diff --git a/gcc/testsuite/gcc.dg/cpp-if1.c b/gcc/testsuite/gcc.dg/cpp-if1.c
new file mode 100644
index 00000000000..d3b078fc3c6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp-if1.c
@@ -0,0 +1,34 @@
+/* { dg-do preprocess } */ 
+/* { dg-options "-pedantic-errors" } */
+
+#if 0xa != 10
+#error 0xa != 10 /* { dg-bogus "#error" "normal conversion" } */
+#endif
+
+#if 077 != 63
+#error 077 != 63 /* { dg-bogus "#error" "normal conversion" } */
+#endif
+
+#if 12wrt /* { dg-error "nvalid number|missing white" "invalid number" } */
+#endif
+
+#if 0abc /* { dg-error "nvalid number|missing white" "invalid number" } */
+#endif
+
+#if 42abc /* { dg-error "nvalid number|missing white" "invalid number" } */
+#endif
+
+#if 1.2 /* { dg-error "loating point numbers" "floating point in #if" } */
+#endif
+
+#if 4uu /* { dg-error "(too many|two) `u'" "too many suffixes" } */
+#endif
+
+#if 124123231lll /* { dg-error "too many `l'" "too many suffixes" } */
+#endif
+
+#if 099 /* { dg-error "digits beyond the radix" "decimal in octal constant" } */
+#endif
+
+#if 0xfffffffffffffffff /* { dg-error "integer constant out of range" "range error" } */
+#endif
diff --git a/gcc/testsuite/gcc.dg/cpp-if2.c b/gcc/testsuite/gcc.dg/cpp-if2.c
new file mode 100644
index 00000000000..60e8ffd22dc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp-if2.c
@@ -0,0 +1,19 @@
+/* { dg-do preprocess } */
+/* { dg-options -pedantic-errors } */
+
+#if 'a' != 'a' || '\001' != 1 || '\x12' != 0x12
+#error a,1,0x12 /* { dg-bogus "#error" "basic charconst recognition" } */
+#endif
+
+#if 'a' != L'a' || L'\xfeed' != 0xfeed
+#error L'a',0xfeed /* { dg-bogus "#error" "wide charconst recognition" } */
+#endif
+
+#if 'abcd' /* { dg-warning "multi-character character constant" "multi-character charconst" } */
+#endif
+
+#if 'abcdefghi' /* { dg-error "character constant (is )?too long" "charconst too long" } */
+#endif
+
+#if '' /* { dg-error "empty character constant" "empty charconst" } */
+#endif
diff --git a/gcc/testsuite/gcc.dg/cpp-if3.c b/gcc/testsuite/gcc.dg/cpp-if3.c
new file mode 100644
index 00000000000..c46f5633761
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp-if3.c
@@ -0,0 +1,25 @@
+/* Test that the preprocessor is capable of 64-bit arithmetic.
+   (Must turn off -pedantic, since `LL' constants are only in C9x.)  */
+/* { dg-do preprocess } */
+/* { dg-options "" } */
+
+#define U_MAX 4294967295U
+#define ULL_MAX 18446744073709551615ULL
+#define LL_MAX 9223372036854775807LL
+#define LL_MIN (-LL_MAX-1)
+
+/* Check simple truncation. */
+#if U_MAX == ULL_MAX || LL_MIN == 0 || LL_MAX == -1
+#error "simple truncation"  /* { dg-bogus "trunc" "simple truncation" } */
+#endif
+
+/* Check left/right shifting with all bits set and with one bit set. */
+#if !(~0ULL >> 63) || !(~0ULL << 63) || !(~0LL >> 63) || !(~0LL << 63) || \
+  !(LL_MIN >> 63) || !(1LL << 62) || !(ULL_MAX >> 63) || !(1ULL << 63)
+#error "bit shift truncation" /* { dg-bogus "trunc" "bit shift truncation" } */
+#endif
+
+/* Check math expressions. */
+#if (2ULL * U_MAX < U_MAX) || (1ULL + U_MAX < U_MAX)
+#error "math truncation"  /* { dg-bogus "trunc" "math truncation" } */
+#endif
diff --git a/gcc/testsuite/gcc.dg/cpp-mi.c b/gcc/testsuite/gcc.dg/cpp-mi.c
new file mode 100644
index 00000000000..f667d0c4b9d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp-mi.c
@@ -0,0 +1,34 @@
+/* Test "ignore redundant include" facility.
+   This doesn't test for the case where the file is opened, and then ignored
+   (the file shouldn't have even been opened).  That would require tracing
+   system calls.  It could be done on some systems however.  */
+
+/* We have to test two cases: C comments at the top and C++ comments
+   at the top.  */
+
+/*
+{ dg-do preprocess }
+{ dg-options "-Wp,-lang-c-c++-comments" }
+*/
+
+#include "cpp-mic.h"
+#include "cpp-mic.h"
+
+#include "cpp-micc.h"
+#include "cpp-micc.h"
+
+main ()
+{
+}
+
+/*
+   { dg-final { if ![file exists cpp-mi.i] { return }		} }
+
+   { dg-final { set tmp [grep cpp-mi.i cpp-micc? line]		} }
+   { dg-final { # send_user "$tmp\n" } }
+   { dg-final { if [regexp "^{\[0-9\]+ cpp-mic} {\[0-9\]+ cpp-micc}$" $tmp] \{ } }
+   { dg-final {     pass "cpp-mi.c: redundant include check"	} }
+   { dg-final { \} else \{					} }
+   { dg-final {     fail "cpp-mi.c: redundant include check"	} }
+   { dg-final { \}						} }
+*/
diff --git a/gcc/testsuite/gcc.dg/cpp-mic.h b/gcc/testsuite/gcc.dg/cpp-mic.h
new file mode 100644
index 00000000000..bae9d8b6db7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp-mic.h
@@ -0,0 +1,10 @@
+/* Redundant header include test with C comments at top.  */
+
+#ifndef CPP_MIC_H
+#define CPP_MIC_H
+
+int a;
+
+#endif
+
+/* And at the end too!  */
diff --git a/gcc/testsuite/gcc.dg/cpp-micc.h b/gcc/testsuite/gcc.dg/cpp-micc.h
new file mode 100644
index 00000000000..52c9dccca89
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp-micc.h
@@ -0,0 +1,10 @@
+// Redundant header include test with C comments at top.
+
+#ifndef CPP_MICC_H
+#define CPP_MICC_H
+
+int a;
+
+#endif
+
+// And at the end too!
diff --git a/gcc/testsuite/gcc.dg/dg.exp b/gcc/testsuite/gcc.dg/dg.exp
new file mode 100644
index 00000000000..6edb5dcae01
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dg.exp
@@ -0,0 +1,69 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# Utility for scanning compiler result, invoked via dg-final.
+# Call pass if pattern is present, otherwise fail.
+proc scan-assembler { testcase pattern } {
+    global subdir
+
+    set fd [open [file rootname $testcase].s r]
+    set text [read $fd]
+    close $fd
+
+    if [regexp -- $pattern $text] {
+	pass "$subdir/$testcase scan-assembler"
+    } else {
+	fail "$subdir/$testcase scan-assembler"
+    }
+}
+
+# Call pass if pattern is not present, otherwise fail.
+proc scan-assembler-not { testcase pattern } {
+    global subdir
+
+    set fd [open [file rootname $testcase].s r]
+    set text [read $fd]
+    close $fd
+
+    if ![regexp -- $pattern $text] {
+	pass "$subdir/$testcase scan-assembler-not"
+    } else {
+	fail "$subdir/$testcase scan-assembler-not"
+    }
+}
+
+# If a testcase doesn't have special options, use these.
+global DEFAULT_CFLAGS
+if ![info exists DEFAULT_CFLAGS] then {
+    set DEFAULT_CFLAGS " -ansi -pedantic-errors"
+}
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c]] "" $DEFAULT_CFLAGS
+
+# All done.
+dg-finish
diff --git a/gcc/testsuite/gcc.dg/dll-1.c b/gcc/testsuite/gcc.dg/dll-1.c
new file mode 100644
index 00000000000..eb3b9b867f0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dll-1.c
@@ -0,0 +1,10 @@
+/* { dg-do compile { target arm*-*-pe* } } */
+/* { dg-do compile { target thumb*-*-pe* } } */
+/* { dg-options -mno-nop-fun-dllimport } */
+
+__declspec (dllimport) void imp ();
+
+__declspec (dllexport) void exp () { imp (); }
+
+/* { dg-final { scan-assembler dll-1.c "\.section\[ \t\]*.drectve\n\[^\n\]*-export:exp.*__imp_imp" } } */
+/* { dg-final { scan-assembler-not dll-1.c "__imp_exp" } } */
diff --git a/gcc/testsuite/gcc.dg/dll-2.c b/gcc/testsuite/gcc.dg/dll-2.c
new file mode 100644
index 00000000000..c55e9209359
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dll-2.c
@@ -0,0 +1,24 @@
+/* These dllimport and dllexport appearing for a symbol.
+   The desired behaviour is that if both dllimport
+   and dllexport appear (in either order) the result is dllexport.
+
+   Microsoft's MSVC 2.0 allows dllimport followed by dllexport for variables,
+   but does not allow dllexport followed by dllimport.
+
+   In C, it's ok to redeclare a variable so this works for variables
+   and functions.  In C++, it only works for functions.  */
+
+/* { dg-do compile { target arm*-*-pe* } } */
+/* { dg-do compile { target thumb*-*-pe* } } */
+
+__declspec (dllimport) int foo1 ();
+__declspec (dllexport) int foo1 ();
+
+__declspec (dllexport) int foo2 ();
+__declspec (dllimport) int foo2 ();
+
+__declspec (dllimport) int bar1;
+__declspec (dllexport) int bar1;
+
+__declspec (dllexport) int bar2;
+__declspec (dllimport) int bar2;
diff --git a/gcc/testsuite/gcc.dg/dll-3.c b/gcc/testsuite/gcc.dg/dll-3.c
new file mode 100644
index 00000000000..0f7818f1e5c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dll-3.c
@@ -0,0 +1,16 @@
+/* Ensure dllexport overrides dllimport.  */
+
+/* { dg-do compile { target arm*-*-pe* } } */
+/* { dg-do compile { target thumb*-*-pe* } } */
+
+__declspec (dllimport) int foo1 ();
+__declspec (dllexport) int foo1 ();
+
+__declspec (dllexport) int foo2 ();
+__declspec (dllimport) int foo2 ();
+
+__declspec (dllexport) int foo1 () { return foo2 (); }
+__declspec (dllexport) int foo2 () { return foo1 (); }
+
+/* { dg-final { scan-assembler dll-3.c "\.section\[ \t\]*\.drectve\n\[^\n\]*-export:foo1.*\.section\[ \t\]*\.drectve\n\[^\n\]*-export:foo2" } } */
+/* { dg-final { scan-assembler-not dll-3.c "(__imp_foo1|__imp_foo2)" } } */
diff --git a/gcc/testsuite/gcc.dg/dll-4.c b/gcc/testsuite/gcc.dg/dll-4.c
new file mode 100644
index 00000000000..b708790baa5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dll-4.c
@@ -0,0 +1,14 @@
+/* { dg-do compile { target arm*-*-pe* } } */
+/* { dg-do compile { target thumb*-*-pe* } } */
+
+__declspec (dllimport) int foo1;
+int foo1;
+
+__declspec (dllimport) int foo2;
+int foo2 = 5;
+
+int f () { return foo1 + foo2; }
+
+/* FIXME: We should scan the output of nm for this case.  */
+/* { dg-final { scan-assembler dll-4.c "(foo2:.*\.comm\[ \t_\]*foo1)" } } */
+/* { dg-final { scan-assembler-not dll-4.c "__imp_" } } */
diff --git a/gcc/testsuite/gcc.dg/ifelse-1.c b/gcc/testsuite/gcc.dg/ifelse-1.c
new file mode 100644
index 00000000000..2dd2208b01f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ifelse-1.c
@@ -0,0 +1,21 @@
+/*
+{ dg-do compile }
+{ dg-options "-W -Wall" }
+*/
+
+
+extern int bar ();
+extern int com ();
+extern int baz ();
+void
+foo (a,b)
+     int a, b;
+{
+  if (a)
+    if (b)
+      bar ();
+    else
+      com ();	/* { dg-bogus ".*warning.*" "bogus warning" } */
+  else
+    baz ();
+}
diff --git a/gcc/testsuite/gcc.dg/noreturn-1.c b/gcc/testsuite/gcc.dg/noreturn-1.c
new file mode 100644
index 00000000000..3d68cbcf500
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/noreturn-1.c
@@ -0,0 +1,43 @@
+/* Check for various valid and erroneous "noreturn" cases. */
+/* { dg-do compile } */
+/* { dg-options "-O -Wmissing-noreturn" } */
+
+extern void foo1(void) __attribute__ ((__noreturn__));
+void
+foo1(void)
+{
+} /* { dg-warning "`noreturn' function does return" "detect falling off end of noreturn" } */
+
+extern void foo2(void) __attribute__ ((__noreturn__));
+void
+foo2(void)
+{
+  exit(0);
+} /* { dg-bogus "warning:" "this function should not get any warnings" } */
+
+extern void foo3(void);
+void
+foo3(void)
+{
+} /* { dg-bogus "warning:" "this function should not get any warnings" } */
+
+extern void foo4(void);
+void
+foo4(void)
+{
+  exit(0);
+} /* { dg-warning "candidate for attribute `noreturn'" "detect noreturn candidate" } */
+
+extern void foo5(void) __attribute__ ((__noreturn__));
+void
+foo5(void)
+{
+  return; /* { dg-warning "`noreturn' has a `return' statement" "detect invalid return" } */
+} /* { dg-warning "`noreturn' function does return" "detect return from noreturn" } */
+
+extern void foo6(void);
+void
+foo6(void)
+{
+  return;
+} /* { dg-bogus "warning:" "this function should not get any warnings" } */
diff --git a/gcc/testsuite/gcc.dg/return-type-1.c b/gcc/testsuite/gcc.dg/return-type-1.c
new file mode 100644
index 00000000000..4b245533ac9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/return-type-1.c
@@ -0,0 +1,9 @@
+/* Missing warning for falling off the end of a non-void function.
+   egcs-1.1.2 passes, egcs-ss-19990428 fails.
+   http://egcs.cygnus.com/ml/egcs-bugs/1999-03/msg00220.html */
+/* { dg-do compile } */
+/* { dg-options "-O -Wreturn-type" } */
+int
+foo(void)
+{
+} /* { dg-warning "control reaches end of non-void function" "warning for falling off end of non-void function" } */
diff --git a/gcc/testsuite/gcc.dg/setjmp-1.c b/gcc/testsuite/gcc.dg/setjmp-1.c
new file mode 100644
index 00000000000..85e0fb4261f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/setjmp-1.c
@@ -0,0 +1,36 @@
+/* Test for bogus "variable `x' may be clobbered by longjmp" warnings.
+   Inspired by cse.c:simplify_relational_operation. */
+
+/* { dg-do compile } */
+/* { dg-options "-O -W -Wall" } */
+
+#include <setjmp.h>
+
+extern void set_float_handler (jmp_buf *);
+
+#define EQ 0x01
+#define LT 0x02
+#define GT 0x04
+
+int
+compare_float (double a, double b)  /* { dg-bogus "clobbered" "spurious clobbered warning" { xfail *-*-* } } */
+{
+  jmp_buf handler;
+  int result;
+
+  a += 1.0;
+
+  if (setjmp (handler))
+    {
+      set_float_handler (0);
+      return 0;
+    }
+
+  set_float_handler (&handler);
+  if (a == b) result = EQ;
+  else if (a > b) result = LT;
+  else if (a < b) result = GT;
+  else result = 0;
+  set_float_handler (0);
+  return result;
+}
diff --git a/gcc/testsuite/gcc.dg/special/alias-1.c b/gcc/testsuite/gcc.dg/special/alias-1.c
new file mode 100644
index 00000000000..347e1745630
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/alias-1.c
@@ -0,0 +1,15 @@
+/* { dg-do link } */
+
+extern int foo(void) __attribute__((alias("bar")));
+
+int bar(void) {
+    return 1;
+}
+
+int main(void) {
+
+    if (foo())
+        exit(0);
+    else
+        abort();
+}
diff --git a/gcc/testsuite/gcc.dg/special/ecos.exp b/gcc/testsuite/gcc.dg/special/ecos.exp
new file mode 100644
index 00000000000..dc54df6eea1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/ecos.exp
@@ -0,0 +1,214 @@
+#   Copyright (C) 1999 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# jlarmour@cygnus.co.uk
+
+# This file was written by Jonathan Larmour (jlarmour@cygnus.co.uk).
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+###################################
+# proc gcc_target_object_format { }
+###################################
+
+proc gcc_target_object_format { } { 
+    global gcc_target_object_format_saved
+
+    if [info exists gcc_target_object_format_saved] {
+        verbose "gcc_target_object_format returning saved $gcc_target_object_format_saved" 2
+        return $gcc_target_object_format_saved
+    } else {
+
+        set objdump_name [find_binutils_prog objdump]
+        set open_file [open objfmtst.c w]
+        puts $open_file "void foo(void) { }"
+        close $open_file
+        
+        gcc_target_compile objfmtst.c objfmtst.o object ""
+        
+        set output [exec $objdump_name --file-headers objfmtst.o ]
+        
+        file delete objfmtst.o
+        
+        if ![ regexp "file format (.*)arch" $output dummy objformat ]  {
+            verbose "Could not parse objdump output" 2
+            set gcc_target_object_format_saved unknown
+        } else {
+            switch -regexp $objformat {
+                elf          {
+                    verbose "gcc_target_object_format returning elf" 2
+                    set gcc_target_object_format_saved elf
+                } 
+                ecoff        {
+                    verbose "gcc_target_object_format returning ecoff" 2
+                    set gcc_target_object_format_saved ecoff
+                }
+                coff         {
+                    verbose "gcc_target_object_format returning coff" 2
+                    set gcc_target_object_format_saved coff
+                }
+                a\.out       {
+                    verbose "gcc_target_object_format returning a.out" 2
+                    set gcc_target_object_format_saved a.out
+                }
+                default      {
+                    verbose "gcc_target_object_format returning unknown" 2
+                    set gcc_target_object_format_saved unknown
+                }
+            }
+        }
+        return $gcc_target_object_format_saved
+    }
+}
+
+###############################
+# proc check_weak_available { }
+###############################
+
+# weak symbols are only supported in some configs/object formats
+# this proc returns 1 if they're support, 0 if they're not, or -1 if unsure
+
+proc check_weak_available { } {
+    global target_cpu
+
+    # All mips targets should support it
+    
+    if { [ string first "mips" $target_cpu ] >= 0 } {
+        return 1
+    }
+
+    # ELF and ECOFF support it. a.out does with gas/gld but may also with
+    # other linkers, so we should try it
+
+    set objformat [gcc_target_object_format]
+
+    switch $objformat {
+        elf      { return 1 }
+        ecoff    { return 1 }
+        a.out    { return 1 }
+        unknown  { return -1 }
+        default  { return 0 }
+    }
+}
+
+##########
+# weak-1.c
+##########
+
+if { [ check_weak_available ] == 1 } {
+    dg-init
+
+    set lines [gcc_target_compile "$srcdir/$subdir/weak-1a.c" "weak-1a.o" object ""]
+    if ![string match "" $lines] then {
+        fail "weak-1a.o"
+    } else {
+        dg-runtest "$srcdir/$subdir/weak-1.c" "weak-1a.o" "" 
+        file delete weak-1a.o
+    }
+    dg-finish
+} elseif { [ check_weak_available ] == 0 } {
+    unsupported "weak-1.c"
+} else {
+    unresolved "weak-1.c"
+}
+
+##########
+# weak-2.c
+##########
+
+if { [ check_weak_available ] == 1 } {
+    dg-init
+    
+    set lines [gcc_target_compile "$srcdir/$subdir/weak-2a.c" "weak-2a.o" object ""]
+    if ![string match "" $lines] then {
+        fail "weak-2a.o"
+    } else {
+        set lines [gcc_target_compile "$srcdir/$subdir/weak-2b.c" "weak-2b.o" object ""]
+        if ![string match "" $lines] then {
+            fail "weak-2b.o"
+        } else {
+            dg-runtest "$srcdir/$subdir/weak-2.c" "weak-2a.o weak-2b.o" "" 
+            file delete weak-2a.o weak-2b.o
+        }
+    }
+    dg-finish
+} elseif { [ check_weak_available ] == 0 } {
+    unsupported "weak-2.c"
+} else {
+    unresolved "weak-2.c"
+}
+
+###########
+# alias-1.c
+###########
+
+dg-init
+dg-runtest "$srcdir/$subdir/alias-1.c" "" ""
+dg-finish
+
+###########
+# wkali-1.c
+###########
+
+dg-init
+dg-runtest "$srcdir/$subdir/wkali-1.c" "" ""
+dg-finish
+
+###########
+# wkali-2.c
+###########
+
+if { [ check_weak_available ] == 1 } {
+    dg-init
+    set lines [gcc_target_compile "$srcdir/$subdir/wkali-2a.c" "wkali-2a.o" object ""]
+    if ![string match "" $lines] then {
+        fail "wkali-2a.o"
+    } else {
+        set lines [gcc_target_compile "$srcdir/$subdir/wkali-2b.c" "wkali-2b.o" object ""]
+        if ![string match "" $lines] then {
+            fail "wkali-2b.o"
+        } else {
+            dg-runtest "$srcdir/$subdir/wkali-2.c" "wkali-2a.o wkali-2b.o" ""
+            file delete wkali-2a.o wkali-2b.o
+        }
+    }
+    dg-finish
+} elseif { [ check_weak_available ] == 0 } {
+    unsupported "wkali-2.c"
+} else {
+    unresolved "wkali-2.c"
+}
+
+###########
+# gcsec-1.c
+###########
+
+set ld_output [ exec [ find_ld ] --help ]
+
+if { [ string first "--gc-sections" $ld_output ] >= 0 } {
+
+    dg-init
+    dg-runtest "$srcdir/$subdir/gcsec-1.c" "-ffunction-sections -fdata-sections -Wl,--gc-sections" ""
+    dg-finish
+} else {
+    unsupported "gcsec-1.c"
+}
+
+### EOF ecos.exp
diff --git a/gcc/testsuite/gcc.dg/special/gcsec-1.c b/gcc/testsuite/gcc.dg/special/gcsec-1.c
new file mode 100644
index 00000000000..fa3f884fcbf
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/gcsec-1.c
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+
+static int unusedint=5;
+
+static int usedint=1;
+
+int unused(void) {
+    return 1;
+}
+
+int foo(void) {
+    return usedint;
+}
+
+int main(void) {
+
+    if (foo())
+        exit(0);
+    else
+        abort();
+}
diff --git a/gcc/testsuite/gcc.dg/special/weak-1.c b/gcc/testsuite/gcc.dg/special/weak-1.c
new file mode 100644
index 00000000000..ccf2b087a94
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/weak-1.c
@@ -0,0 +1,15 @@
+/* { dg-do run } */
+
+int foo(void) __attribute__((weak));
+
+int foo(void) {
+    return 0;
+}
+
+int main(void) {
+
+    if (foo())
+        exit(0);
+    else
+        abort();
+}
diff --git a/gcc/testsuite/gcc.dg/special/weak-1a.c b/gcc/testsuite/gcc.dg/special/weak-1a.c
new file mode 100644
index 00000000000..2a7dbba3d89
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/weak-1a.c
@@ -0,0 +1,3 @@
+int foo(void) {
+    return 1;
+}
diff --git a/gcc/testsuite/gcc.dg/special/weak-2.c b/gcc/testsuite/gcc.dg/special/weak-2.c
new file mode 100644
index 00000000000..74259cf9bca
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/weak-2.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+
+extern int foo(void);
+
+int main(void) {
+
+    if (foo())
+        exit(0);
+    else
+        abort();
+}
diff --git a/gcc/testsuite/gcc.dg/special/weak-2a.c b/gcc/testsuite/gcc.dg/special/weak-2a.c
new file mode 100644
index 00000000000..52d3e08a2d7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/weak-2a.c
@@ -0,0 +1,5 @@
+int foo(void) __attribute__((weak));
+
+int foo(void) {
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/special/weak-2b.c b/gcc/testsuite/gcc.dg/special/weak-2b.c
new file mode 100644
index 00000000000..2a7dbba3d89
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/weak-2b.c
@@ -0,0 +1,3 @@
+int foo(void) {
+    return 1;
+}
diff --git a/gcc/testsuite/gcc.dg/special/wkali-1.c b/gcc/testsuite/gcc.dg/special/wkali-1.c
new file mode 100644
index 00000000000..d33c8d1d601
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/wkali-1.c
@@ -0,0 +1,15 @@
+/* { dg-do link } */
+
+extern int foo(void) __attribute__((weak, alias("bar")));
+
+int bar(void) {
+    return 1;
+}
+
+int main(void) {
+
+    if (foo())
+        exit(0);
+    else
+        abort();
+}
diff --git a/gcc/testsuite/gcc.dg/special/wkali-2.c b/gcc/testsuite/gcc.dg/special/wkali-2.c
new file mode 100644
index 00000000000..74259cf9bca
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/wkali-2.c
@@ -0,0 +1,11 @@
+/* { dg-do run } */
+
+extern int foo(void);
+
+int main(void) {
+
+    if (foo())
+        exit(0);
+    else
+        abort();
+}
diff --git a/gcc/testsuite/gcc.dg/special/wkali-2a.c b/gcc/testsuite/gcc.dg/special/wkali-2a.c
new file mode 100644
index 00000000000..79dde145540
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/wkali-2a.c
@@ -0,0 +1,7 @@
+/* { dg-do run } */
+
+extern int foo(void) __attribute__((weak, alias("bar_a")));
+
+int bar_a(void) {
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/special/wkali-2b.c b/gcc/testsuite/gcc.dg/special/wkali-2b.c
new file mode 100644
index 00000000000..84f389e846d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/special/wkali-2b.c
@@ -0,0 +1,7 @@
+/* { dg-do run } */
+
+extern int foo(void) __attribute__((alias("bar_b")));
+
+int bar_b(void) {
+    return 1;
+}
diff --git a/gcc/testsuite/gcc.dg/splet-1.c b/gcc/testsuite/gcc.dg/splet-1.c
new file mode 100644
index 00000000000..03dbb2e3a3c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/splet-1.c
@@ -0,0 +1,21 @@
+/* Test inl-sparc.h.  */
+
+/* { dg-do run { target sparclet-*-* } } */
+/* { dg-options -mcpu=sparclet } */
+
+#include <inl-sparc.h>
+
+main ()
+{
+  int a,b;
+
+  a = scan (1, 2);
+  if (a != 3)
+    abort ();
+
+  b = shuffle (4, 5);
+  if (b != 6)
+    abort ();
+
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.dg/struct-ret-1.c b/gcc/testsuite/gcc.dg/struct-ret-1.c
new file mode 100644
index 00000000000..f581aad07d2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/struct-ret-1.c
@@ -0,0 +1,45 @@
+/* { dg-do run { target hppa*-*-* } } */
+/* { dg-options { -O2 } { target hppa*-*-* } } */
+typedef struct {
+        int             x;
+        int             y;
+}               point_t;
+
+int main(int argc, char *argv[]);
+int printPoints(point_t a, point_t b);
+point_t toPoint(int x1, int y1);
+
+int
+main(int argc, char *argv[])
+{
+
+        if (printPoints(toPoint(0, 0), toPoint(1000, 1000)) != 1)
+                abort();
+        else
+                exit();
+
+        return 0;
+}
+
+int
+printPoints(point_t a, point_t b)
+{
+        if (a.x != 0
+            || a.y != 0
+            || b.x != 1000
+            || b.y != 1000)
+                return 0;
+        else
+                return 1;
+}
+
+point_t
+toPoint(int x1, int y1)
+{
+        point_t         p;
+
+        p.x = x1;
+        p.y = y1;
+
+        return p;
+}
diff --git a/gcc/testsuite/gcc.dg/switch-1.c b/gcc/testsuite/gcc.dg/switch-1.c
new file mode 100644
index 00000000000..457c5205388
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/switch-1.c
@@ -0,0 +1,17 @@
+/* { dg-do compile { target rs6000-*-linux* powerpc-*-linux*} } */
+/* { dg-options "-fpic -O2" } */
+
+void f (char *s)
+{
+  for (;;)
+    {
+      int t = 6;
+      switch (t)
+	{
+	case 2:
+	  *s = '2';
+	case 6: case 4: case 3: case 1:
+	  break;
+	}
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/ultrasp1.c b/gcc/testsuite/gcc.dg/ultrasp1.c
new file mode 100644
index 00000000000..853c72d35ab
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ultrasp1.c
@@ -0,0 +1,9 @@
+/* Simplified from testcase by David Staepelaere <staapa@ultimatech.com> */
+
+/* { dg-do compile { xfail sparc-*-* } } */
+/* { dg-options "" } */
+/* { dg-options -mcpu=ultrasparc { target sparc-*-*-* } } */
+
+int foo(long long y) {
+  return -1 * y;
+}
diff --git a/gcc/testsuite/gcc.dg/uninit-1.c b/gcc/testsuite/gcc.dg/uninit-1.c
new file mode 100644
index 00000000000..91838810fda
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-1.c
@@ -0,0 +1,30 @@
+/* Spurious uninitialized variable warnings, case 1.
+   Taken from cppfiles.c (merge_include_chains) */
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+struct list
+{
+  struct list *next;
+  int id;
+};
+
+extern void free (void *);
+
+void remove_dupes (struct list *el)
+{
+  struct list *p, *q, *r;  /* { dg-bogus "r" "uninitialized variable warning" { xfail *-*-* } } */
+
+  for (p = el; p; p = p->next)
+  {
+    for (q = el; q != p; q = q->next)
+      if (q->id == p->id)
+      {
+	r->next = p->next;
+	free (p);
+	p = r;
+	break;
+      }
+    r = p;
+  }
+}
diff --git a/gcc/testsuite/gcc.dg/uninit-2.c b/gcc/testsuite/gcc.dg/uninit-2.c
new file mode 100644
index 00000000000..5035a309ebd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-2.c
@@ -0,0 +1,52 @@
+/* Spurious uninitialized variable warnings, case 2.
+   Taken from cpphash.c (macroexpand) */
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+struct definition
+{
+  int nargs;
+  int rest_args;
+};
+
+struct cpp_reader;
+
+enum cpp_token
+{
+  CPP_EOF, CPP_POP, CPP_COMMA, CPP_RPAREN
+};
+
+extern enum cpp_token macarg (struct cpp_reader *, int);
+
+void
+macroexpand (struct cpp_reader *pfile, struct definition *defn)
+{
+  int nargs = defn->nargs;
+
+  if (nargs >= 0)
+    {
+      enum cpp_token token;  /* { dg-bogus "token" "uninitialized variable warning" { xfail *-*-* } } */
+      int i, rest_args;
+      i = 0;
+      rest_args = 0;
+      do
+	{
+	  if (rest_args)
+	    continue;
+	  if (i < nargs || (nargs == 0 && i == 0))
+	    {
+	      /* if we are working on last arg which absorbs rest of args... */
+	      if (i == nargs - 1 && defn->rest_args)
+		rest_args = 1;
+	      token = macarg (pfile, rest_args);
+	    }
+	  else
+	    token = macarg (pfile, 0);
+	  if (token == CPP_EOF || token == CPP_POP)
+	    return;
+
+	  i++;
+	}
+      while (token == CPP_COMMA);
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/uninit-3.c b/gcc/testsuite/gcc.dg/uninit-3.c
new file mode 100644
index 00000000000..78c4254dea5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-3.c
@@ -0,0 +1,33 @@
+/* Spurious uninit variable warnings, case 3.
+   Inspired by cppexp.c (parse_charconst) */
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+extern void error (char *);
+
+int
+parse_charconst (const char *start, const char *end)
+{
+  int c; /* { dg-bogus "c" "uninitialized variable warning" { xfail *-*-* } } */
+  int nchars, retval;
+
+  nchars = 0;
+  retval = 0;
+  while (start < end)
+    {
+      c = *start++;
+      if (c == '\'')
+	break;
+      nchars++;
+      retval += c;
+      retval <<= 8;
+    }
+
+  if (nchars == 0)
+    return 0;
+
+  if (c != '\'')
+    error ("malformed character constant");
+
+  return retval;
+}
diff --git a/gcc/testsuite/gcc.dg/uninit-4.c b/gcc/testsuite/gcc.dg/uninit-4.c
new file mode 100644
index 00000000000..34973532c57
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-4.c
@@ -0,0 +1,50 @@
+/* Spurious uninit variable warnings, case 4.
+   Simplified version of cppexp.c (cpp_parse_expr).
+
+   This one is really fragile, it gets it right if you take out case
+   1, or if the structure is replaced by an int, or if the structure
+   has fewer members (!) */
+
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+struct operation {
+    short op;
+    char rprio;
+    char flags;
+    char unsignedp;
+    long value;
+};
+
+extern struct operation cpp_lex (void);
+
+void
+cpp_parse_expr (void)
+{
+  int rprio; /* { dg-bogus "rprio" "uninitialized variable warning" { xfail *-*-* } } */
+  struct operation op;
+
+  for (;;)
+    {
+      op = cpp_lex ();
+
+      switch (op.op)
+	{
+	case 0:
+	  break;
+	case 1:
+	  return;
+	case 2:
+	  rprio = 1;
+	  break;
+	default:
+	  return;
+	}
+
+      if (op.op == 0)
+	return;
+
+      if (rprio != 1)
+	abort();
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/uninit-5.c b/gcc/testsuite/gcc.dg/uninit-5.c
new file mode 100644
index 00000000000..ac760d69e03
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-5.c
@@ -0,0 +1,40 @@
+/* Spurious uninitialized-variable warnings.
+   These cases are documented as not working in the gcc manual. */
+
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+extern void use(int);
+extern void foo(void);
+
+void
+func1(int cond)
+{
+    int x;  /* { dg-bogus "x" "uninitialized variable warning" { xfail *-*-* } } */
+
+    if(cond)
+	x = 1;
+
+    foo();
+
+    if(cond)
+	use(x);
+}
+
+void
+func2 (int cond)
+{
+    int x;  /* { dg-bogus "x" "uninitialized variable warning" { xfail *-*-* } } */
+    int flag = 0;
+
+    if(cond)
+    {
+	x = 1;
+	flag = 1;
+    }
+
+    foo();
+
+    if(flag)
+	use(x);
+}
diff --git a/gcc/testsuite/gcc.dg/uninit-6.c b/gcc/testsuite/gcc.dg/uninit-6.c
new file mode 100644
index 00000000000..2c428df79b6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-6.c
@@ -0,0 +1,47 @@
+/* Spurious uninitialized variable warnings.
+   This one inspired by java/class.c:build_utf8_ref.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+#include <stddef.h>
+
+struct tree
+{
+    struct tree *car;
+    struct tree *cdr;
+    int type, data;
+};
+
+extern void *malloc(size_t);
+
+#define INTEGER_T 1
+#define PTR_T	  2
+
+#define APPEND(TREE, LAST, TYPE, VALUE)				\
+do {								\
+     struct tree *tmp = malloc (sizeof (struct tree));		\
+     tmp->car = 0; tmp->cdr = 0; tmp->type = TYPE;		\
+     tmp->data = VALUE;						\
+     if (TREE->car)						\
+	 LAST->cdr = tmp;					\
+     else							\
+	 TREE->car = tmp;					\
+     LAST = tmp;						\
+} while(0)
+ 
+struct tree *
+make_something(int a, int b, int c)
+{
+    struct tree *rv;
+    struct tree *field;  /* { dg-bogus "field" "uninitialized variable warning" { xfail *-*-* } } */
+
+    rv = malloc (sizeof (struct tree));
+    rv->car = 0;
+
+    APPEND(rv, field, INTEGER_T, a);
+    APPEND(rv, field, PTR_T, b);
+    APPEND(rv, field, INTEGER_T, c);
+
+    return rv;
+}
diff --git a/gcc/testsuite/gcc.dg/uninit-8.c b/gcc/testsuite/gcc.dg/uninit-8.c
new file mode 100644
index 00000000000..94117da37c9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-8.c
@@ -0,0 +1,32 @@
+/* Uninitialized variable warning tests...
+   Inspired by part of optabs.c:expand_binop.
+   May be the same as uninit-1.c.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+#include <limits.h>
+
+void
+add_bignums (int *out, int *x, int *y)
+{
+    int p, sum;
+    int carry; /* { dg-bogus "carry" "uninitialized variable warning" { xfail *-*-* } } */
+
+    p = 0;
+    for (; *x; x++, y++, out++, p++)
+    {
+	if (p)
+	    sum = *x + *y + carry;
+	else
+	    sum = *x + *y;
+
+	if (sum < 0)
+	{
+	    carry = 1;
+	    sum -= INT_MAX;
+	}
+	else
+	    carry = 0;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/uninit-9.c b/gcc/testsuite/gcc.dg/uninit-9.c
new file mode 100644
index 00000000000..62681f9e0fd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-9.c
@@ -0,0 +1,41 @@
+/* Spurious uninitialized variable warnings.  Slight variant on the
+   documented case, inspired by reg-stack.c:record_asm_reg_life.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+struct foo
+{
+    int type;
+    struct foo *car;
+    struct foo *cdr;
+    char *data;
+    int data2;
+};
+
+extern void use(struct foo *);
+
+#define CLOBBER 6
+#define PARALLEL 3
+
+void
+func(struct foo *list, int count)
+{
+    int n_clobbers = 0;
+    int i;
+    struct foo **clob_list;   /* { dg-bogus "clob_list" "uninitialized variable warning" { xfail *-*-* } } */
+
+    if(list[0].type == PARALLEL)
+    {
+	clob_list = __builtin_alloca(count * sizeof(struct foo *));
+	
+	for(i = 1; i < count; i++)
+	{
+	    if(list[i].type == CLOBBER)
+		clob_list[n_clobbers++] = &list[i];
+	}
+    }
+
+    for(i = 0; i < n_clobbers; i++)
+	use(clob_list[i]);
+}
diff --git a/gcc/testsuite/gcc.dg/uninit-A.c b/gcc/testsuite/gcc.dg/uninit-A.c
new file mode 100644
index 00000000000..119ed6902aa
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-A.c
@@ -0,0 +1,115 @@
+/* Inspired by part of java/parse.y.
+   May be a real bug in CSE. */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall" } */
+
+struct tree
+{
+    struct tree *car, *cdr, *wfl;
+    int code;
+    struct { int renp:1; int rtnp:1; int rpnp:1; } flags;
+};
+typedef struct tree *tree;
+#define NULL_TREE ((tree)0)
+
+/* Codes */
+enum
+{
+    CALL_EXPR, NEW_ARRAY_EXPR, NEW_CLASS_EXPR, CONVERT_EXPR,
+    ARRAY_REF, CONDITIONAL_EXPR, STRING_CST, EXPR_WITH_FILE_LOCATION
+};
+
+/* Flags */
+#define RESOLVE_EXPRESSION_NAME_P(t) ((t)->flags.renp)
+#define RESOLVE_TYPE_NAME_P(t) ((t)->flags.rtnp)
+#define RESOLVE_PACKAGE_NAME_P(t) ((t)->flags.rpnp)
+
+/* Macros */
+#define EXPR_WFL_QUALIFICATION(t) ((t)->wfl)
+#define QUAL_WFL(t) ((t)->wfl)
+#define EXPR_WFL_NODE(t) ((t)->wfl)
+#define TREE_CODE(t) ((t)->code)
+#define TREE_OPERAND(t,x) ((t)->car)
+#define CLASSTYPE_SUPER(t) ((t)->car)
+#define IDENTIFIER_LOCAL_VALUE(t) ((t)->car)
+#define TREE_CHAIN(t) ((t)->cdr)
+#define QUAL_RESOLUTION(t) ((t)->cdr)
+
+extern tree current_class, this_identifier_node;
+extern tree super_identifier_node, length_identifier_node;
+
+tree resolve_and_layout (tree, tree);
+tree lookup_field_wrapper (tree, tree);
+
+void
+qualify_ambiguous_name (id)
+     tree id;
+{
+  tree qual, qual_wfl, decl;
+  tree name;	 /* { dg-bogus "name" "uninitialized variable warning" { xfail *-*-* } } */
+  tree ptr_type; /* { dg-bogus "ptr_type" "uninitialized variable warning" { xfail *-*-* } } */
+  int again, new_array_found = 0;
+  int super_found = 0, this_found = 0;
+
+  qual = EXPR_WFL_QUALIFICATION (id);
+  do {
+    qual_wfl = QUAL_WFL (qual);
+    switch (TREE_CODE (qual_wfl))
+      {
+      case CALL_EXPR:
+	qual_wfl = TREE_OPERAND (qual_wfl, 0);
+	if (TREE_CODE (qual_wfl) != EXPR_WITH_FILE_LOCATION)
+	  {
+	    qual = EXPR_WFL_QUALIFICATION (qual_wfl);
+	    qual_wfl = QUAL_WFL (qual);
+	  }
+	break;
+      case NEW_ARRAY_EXPR:
+	qual = TREE_CHAIN (qual);
+	new_array_found = again = 1;
+	continue;
+      case NEW_CLASS_EXPR:
+      case CONVERT_EXPR:
+	qual_wfl = TREE_OPERAND (qual_wfl, 0);
+	break;
+      case ARRAY_REF:
+	while (TREE_CODE (qual_wfl) == ARRAY_REF)
+	  qual_wfl = TREE_OPERAND (qual_wfl, 0);
+	break;
+      default:
+	break;
+      }
+
+    name = EXPR_WFL_NODE (qual_wfl);
+    ptr_type = current_class;
+    again = 0;
+
+  } while (again);
+
+  /* If you put straightforward uses of name and ptr_type here
+     instead of the if-else sequence below, the warnings go away.
+     Therefore I suspect a real bug. */
+  
+  if (!this_found && !super_found && (decl = IDENTIFIER_LOCAL_VALUE (name)))
+    {
+      RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;
+      QUAL_RESOLUTION (qual) = decl;
+    }
+  else if ((decl = lookup_field_wrapper (ptr_type, name))
+	   || (new_array_found && name == length_identifier_node))
+    {
+      RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;
+      QUAL_RESOLUTION (qual) = (new_array_found ? NULL_TREE : decl);
+    }
+  else if ((decl = resolve_and_layout (name, NULL_TREE)))
+    {
+      RESOLVE_TYPE_NAME_P (qual_wfl) = 1;
+      QUAL_RESOLUTION (qual) = decl;
+    }
+  else if (TREE_CODE (QUAL_WFL (qual)) == CALL_EXPR
+	   || TREE_CODE (QUAL_WFL (qual)) == ARRAY_REF)
+    RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;
+  else 
+    RESOLVE_PACKAGE_NAME_P (qual_wfl) = 1;
+}
diff --git a/gcc/testsuite/gcc.dg/unused-1.c b/gcc/testsuite/gcc.dg/unused-1.c
new file mode 100644
index 00000000000..be941860e49
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/unused-1.c
@@ -0,0 +1,11 @@
+/* Missing `unused parameter' warning.
+   egcs-1.1.2 fails, egcs-ss-19990418 passes.
+   http://www.cygnus.com/ml/egcs-bugs/1998-Sep/0199.html */
+/* { dg-do compile } */
+/* { dg-options "-O -Wall -W" } */
+int
+f(c)
+     char c; /* { dg-warning "unused parameter" "unused parameter warning" } */
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.failure/940409-1.c b/gcc/testsuite/gcc.failure/940409-1.c
new file mode 100644
index 00000000000..3d5b58864e8
--- /dev/null
+++ b/gcc/testsuite/gcc.failure/940409-1.c
@@ -0,0 +1,3 @@
+struct S { volatile int field; };
+int f (register struct S arg);
+int g (register struct S);
diff --git a/gcc/testsuite/gcc.failure/940409-1.x b/gcc/testsuite/gcc.failure/940409-1.x
new file mode 100644
index 00000000000..aac01277616
--- /dev/null
+++ b/gcc/testsuite/gcc.failure/940409-1.x
@@ -0,0 +1,6 @@
+# gcc doesn't handle compile/940409-1.cexp properly, but it's an obscure bug
+# so rather than constantly seeing it fail, just record it as expected to
+# fail.
+
+set torture_compile_xfail "*-*-*"
+return 0 ;# `0' says we didn't handle the testcase ourselves so continue
diff --git a/gcc/testsuite/gcc.failure/failure.exp b/gcc/testsuite/gcc.failure/failure.exp
new file mode 100644
index 00000000000..bfd9f3487ea
--- /dev/null
+++ b/gcc/testsuite/gcc.failure/failure.exp
@@ -0,0 +1,58 @@
+#
+# Expect driver script for GCC Regression Tests
+#   Copyright (C) 1993, 1997 Free Software Foundation
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+#
+# Written by Jeffrey Wheat (cassidy@cygnus.com)
+#
+
+#
+# These tests come from Torbjorn Granlund's (tege@cygnus.com)
+# C torture test suite, and other contributors.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+
+#
+# This loop will run c-torture on any *.c file found in this directory.
+# If a *.c has a corresponding *.exp file, then the test is skipped as
+# as the *.exp will drive the test itself. I did things this way so that
+# generic tests did not need a seperate .exp for it. Only the tests that 
+# required unique options would need it's own .exp file.
+#
+
+#
+# The main logic is in ../lib/c-torture.exp. This was done to eliminate
+# redundant code that otherwise lived in each of these driver files.
+#
+foreach testcase [glob -nocomplain $srcdir/$subdir/*.c] {
+    
+    # let c-torture.exp figure out the path. this lets users add new
+    # special tests without having to remeber to use $srcdir/$subdir
+    
+    if [file exists [file rootname $testcase].exp] then {
+	verbose "INFO:\"[file rootname $testcase].exp\"exists, skipping test" 1
+	continue
+    } else {
+	c-torture [file tail $testcase]
+    }
+}
+
diff --git a/gcc/testsuite/gcc.misc-tests/Makefile.in b/gcc/testsuite/gcc.misc-tests/Makefile.in
new file mode 100644
index 00000000000..e6209dbc6c2
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/Makefile.in
@@ -0,0 +1,12 @@
+#### host, target, and site specific Makefile frags come in here.
+
+srcdir = .
+
+# Nothing to do...
+all:
+
+clean:
+	-rm -f *.o *.diff *~ *.bad core *.x
+
+distclean:	clean
+	-rm -f Makefile config.status
diff --git a/gcc/testsuite/gcc.misc-tests/acker1.c b/gcc/testsuite/gcc.misc-tests/acker1.c
new file mode 100644
index 00000000000..9e77e42bedd
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/acker1.c
@@ -0,0 +1,20 @@
+int acker(int, int);
+
+void main()
+{
+    acker(3,6);
+    /* */
+    exit(0);
+    /* */
+}
+
+int
+acker(int x,int y)
+{
+    if (x==0)
+	return(y+1);
+    else if (y==0)
+	return(acker(x-1,1));
+    else
+	return(acker(x-1, acker(x, y-1)));
+}
diff --git a/gcc/testsuite/gcc.misc-tests/acker1.exp b/gcc/testsuite/gcc.misc-tests/acker1.exp
new file mode 100644
index 00000000000..3462d66bbc4
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/acker1.exp
@@ -0,0 +1,31 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+global PERF_TEST
+if { ![info exists PERF_TEST] || "$PERF_TEST" != "yes" } {
+    return
+}
+
+load_lib mike-gcc.exp
+
+prebase
+set actions run
+set compiler_output "^$"
+set program_output "^$"
+postbase acker1.c $run $groups
diff --git a/gcc/testsuite/gcc.misc-tests/configure.in b/gcc/testsuite/gcc.misc-tests/configure.in
new file mode 100644
index 00000000000..e4cc69d249e
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/configure.in
@@ -0,0 +1,15 @@
+# This file is a shell script fragment that supplies the information
+# necessary to tailor a template configure script into the configure
+# script appropriate for this directory.  For more information, check
+# any existing configure script.
+
+srctrigger=compile.exp
+srcname="DejaGnu"
+
+# per-host:
+
+# per-target:
+
+target_makefile_frag=../config/mt-${target_alias}
+
+# post-target:
diff --git a/gcc/testsuite/gcc.misc-tests/dg-1.c b/gcc/testsuite/gcc.misc-tests/dg-1.c
new file mode 100644
index 00000000000..319f8a20a7b
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-1.c
@@ -0,0 +1,14 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-do compile } */
+
+main () { return 0; }
+
+/* { dg-final { if ![file exists dg-1.s] { fail "dg-1.c (compile)"; return; } } } */
+
+/* { dg-final { set tmp [grep dg-1.s main line]			} } */
+/* { dg-final { if ![string match "" $tmp] \{			} } */
+/* { dg-final {     pass "dg-1.c (main function present)"	} } */
+/* { dg-final { \} else \{					} } */
+/* { dg-final {     fail "dg-1.c (main function not present)"	} } */
+/* { dg-final { \}						} } */
diff --git a/gcc/testsuite/gcc.misc-tests/dg-10.c b/gcc/testsuite/gcc.misc-tests/dg-10.c
new file mode 100644
index 00000000000..6d7b3441623
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-10.c
@@ -0,0 +1,12 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-options "-Wall" } */
+
+/* FIXME: we want to test dg-lose here.  Anyone know of a good way to
+   crash the compiler?  */
+
+int
+main (int argc, char *argv[])
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.misc-tests/dg-11.c b/gcc/testsuite/gcc.misc-tests/dg-11.c
new file mode 100644
index 00000000000..e4f86ba2b12
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-11.c
@@ -0,0 +1,9 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-do run { target sparc-sun-solaris2* } } */
+/* The \n is left out of the pattern because tcl's exec will remove it.  */
+/* { dg-output {^Hello world[.]$} } */
+
+#include <stdio.h>
+
+main () { printf ("Hello world.\n"); return 0; }
diff --git a/gcc/testsuite/gcc.misc-tests/dg-12.c b/gcc/testsuite/gcc.misc-tests/dg-12.c
new file mode 100644
index 00000000000..ad0870d88cc
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-12.c
@@ -0,0 +1,9 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-do run { target foo-bar-eh } } */
+/* The \n is left out of the pattern because tcl's exec will remove it.  */
+/* { dg-output {^Hello world[.]$} } */
+
+#include <stdio.h>
+
+main () { printf ("Hello world.\n"); return 0; }
diff --git a/gcc/testsuite/gcc.misc-tests/dg-2.c b/gcc/testsuite/gcc.misc-tests/dg-2.c
new file mode 100644
index 00000000000..bb40387e632
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-2.c
@@ -0,0 +1,11 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-do assemble } */
+
+main () { return 0; }
+
+/* { dg-final { if [file exists dg-2.o] \{			} } */
+/* { dg-final {     pass "dg-2.c (assemble: produce .o test)"	} } */
+/* { dg-final { \} else \{					} } */
+/* { dg-final {     fail "dg-2.c (assemble: produce .o test)"	} } */
+/* { dg-final { \}						} } */
diff --git a/gcc/testsuite/gcc.misc-tests/dg-3.c b/gcc/testsuite/gcc.misc-tests/dg-3.c
new file mode 100644
index 00000000000..017ab279f8e
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-3.c
@@ -0,0 +1,11 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-do link } */
+
+main () { return 0; }
+
+/* { dg-final { if [file exists a.out] \{			} } */
+/* { dg-final {     pass "dg-2.c (link: produce a.out test)"	} } */
+/* { dg-final { \} else \{					} } */
+/* { dg-final {     fail "dg-2.c (link: produce a.out test)"	} } */
+/* { dg-final { \}						} } */
diff --git a/gcc/testsuite/gcc.misc-tests/dg-4.c b/gcc/testsuite/gcc.misc-tests/dg-4.c
new file mode 100644
index 00000000000..806bdfbf91a
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-4.c
@@ -0,0 +1,5 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-do run } */
+
+main () { return 0; }
diff --git a/gcc/testsuite/gcc.misc-tests/dg-5.c b/gcc/testsuite/gcc.misc-tests/dg-5.c
new file mode 100644
index 00000000000..33a5b4e893b
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-5.c
@@ -0,0 +1,9 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-do run } */
+/* The \n is left out of the pattern because tcl's exec will remove it.  */
+/* { dg-output {^Hello world[.]$} } */
+
+#include <stdio.h>
+
+main () { printf ("Hello world.\n"); return 0; }
diff --git a/gcc/testsuite/gcc.misc-tests/dg-6.c b/gcc/testsuite/gcc.misc-tests/dg-6.c
new file mode 100644
index 00000000000..f9273f873ee
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-6.c
@@ -0,0 +1,9 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-do run { target *-*-* } } */
+/* The \n is left out of the pattern because tcl's exec will remove it.  */
+/* { dg-output {^Hello world[.]$} { xfail *-*-* } } */
+
+#include <stdio.h>
+
+main () { printf ("Hello world (oops).\n"); return 0; }
diff --git a/gcc/testsuite/gcc.misc-tests/dg-7.c b/gcc/testsuite/gcc.misc-tests/dg-7.c
new file mode 100644
index 00000000000..068749f71b2
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-7.c
@@ -0,0 +1,5 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-do run { xfail *-*-* } } */
+
+main () { abort (); return 0; }
diff --git a/gcc/testsuite/gcc.misc-tests/dg-8.c b/gcc/testsuite/gcc.misc-tests/dg-8.c
new file mode 100644
index 00000000000..63a5b0e73fa
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-8.c
@@ -0,0 +1,9 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-options "-Wall" } */
+/* { dg-do run } */
+/* { dg-excess-errors "excess errors" } */
+
+/* should get warning about defaulting return type - excess error */
+
+main () { return 0; }
diff --git a/gcc/testsuite/gcc.misc-tests/dg-9.c b/gcc/testsuite/gcc.misc-tests/dg-9.c
new file mode 100644
index 00000000000..43b7ab34b0d
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-9.c
@@ -0,0 +1,15 @@
+/* Test the tester.  */
+/* { dg-prms-id 42 } */
+/* { dg-options "-Wall" } */
+
+f ()
+{	/* { dg-warning "return-type" "warning test" } */
+}	/* { dg-warning "control reaches end" "warning test" } */
+
+main (int argc, char *argv[])
+{		/* { dg-warning "return-type" "warning test" } */
+  foo a;	/* { dg-error "syntax" "error test" } */
+		/* { dg-bogus "foobar" "bogus fail test" } */
+
+  return a;	/* { dg-bogus "undeclared|identifier|appears" "bogus pass test" { xfail *-*-* } } */
+}		/* { dg-warning "control reaches end" "warning test" } */
diff --git a/gcc/testsuite/gcc.misc-tests/dg-test.exp b/gcc/testsuite/gcc.misc-tests/dg-test.exp
new file mode 100644
index 00000000000..42364252b63
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dg-test.exp
@@ -0,0 +1,41 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# Test the dg.exp driver.
+# This is a testsuite tester tester.  As such we *want* to test things like
+# expected failure handling.  But expected failures must continually be
+# monitored and so in the normal case we create unnecessary work.  So only
+# run these tests if DG_TEST is defined to "yes".
+
+global DG_TEST
+if { ![info exists DG_TEST] || "$DG_TEST" != "yes" } {
+    return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# Initialize harness.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/dg-*.c]] "" ""
+
+# All done.
+dg-finish
diff --git a/gcc/testsuite/gcc.misc-tests/dhry.c b/gcc/testsuite/gcc.misc-tests/dhry.c
new file mode 100644
index 00000000000..ae29a693654
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dhry.c
@@ -0,0 +1,602 @@
+/*
+ ****************************************************************************
+ *
+ *                   "DHRYSTONE" Benchmark Program
+ *                   -----------------------------
+ *                                                                            
+ *  Version:    C, Version 2.1
+ *                                                                            
+ *  File:       dhry_1.c (part 2 of 3)
+ *
+ *  Date:       May 25, 1988
+ *
+ *  Author:     Reinhold P. Weicker
+ *
+ ****************************************************************************
+ */
+
+#include "dhry.h"
+
+/* Global Variables: */
+
+Rec_Pointer     Ptr_Glob,
+                Next_Ptr_Glob;
+int             Int_Glob;
+Boolean         Bool_Glob;
+char            Ch_1_Glob,
+                Ch_2_Glob;
+int             Arr_1_Glob [50];
+int             Arr_2_Glob [50] [50];
+
+extern char     *malloc ();
+Enumeration     Func_1 ();
+  /* forward declaration necessary since Enumeration may not simply be int */
+
+#ifndef REG
+        Boolean Reg = false;
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+        Boolean Reg = true;
+#endif
+
+/* variables for time measurement: */
+
+/*
+#ifdef TIMES
+struct tms      time_info;
+extern  int     times ();
+#endif
+*/           
+/*
+#ifdef TIME
+extern long     time();
+#endif
+*/
+#define Too_Small_Time 2
+                /* Measurements should last at least 2 seconds */
+
+long            Begin_Time,
+                End_Time,
+                User_Time;
+float           Microseconds,
+                Dhrystones_Per_Second;
+
+/* end of variables for time measurement */
+
+
+main ()
+/*****/
+
+  /* main program, corresponds to procedures        */
+  /* Main and Proc_0 in the Ada version             */
+{
+        One_Fifty       Int_1_Loc;
+  REG   One_Fifty       Int_2_Loc;
+        One_Fifty       Int_3_Loc;
+  REG   char            Ch_Index;
+        Enumeration     Enum_Loc;
+        Str_30          Str_1_Loc;
+        Str_30          Str_2_Loc;
+  REG   int             Run_Index;
+  REG   int             Number_Of_Runs;
+
+  /* Initializations */
+
+  Next_Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
+  Ptr_Glob = (Rec_Pointer) malloc (sizeof (Rec_Type));
+
+  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;
+  Ptr_Glob->Discr                       = Ident_1;
+  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;
+  Ptr_Glob->variant.var_1.Int_Comp      = 40;
+  strcpy (Ptr_Glob->variant.var_1.Str_Comp, 
+          "DHRYSTONE PROGRAM, SOME STRING");
+  strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
+
+  Arr_2_Glob [8][7] = 10;
+        /* Was missing in published program. Without this statement,    */
+        /* Arr_2_Glob [8][7] would have an undefined value.             */
+        /* Warning: With 16-Bit processors and Number_Of_Runs > 32000,  */
+        /* overflow may occur for this array element.                   */
+
+/*
+  printf ("\n");
+  printf ("Dhrystone Benchmark, Version 2.1 (Language: C)\n");
+  printf ("\n");
+*/
+  if (Reg)
+  {
+/*
+    printf ("Program compiled with 'register' attribute\n");
+    printf ("\n");
+*/
+  }
+  else
+  {
+/*
+    printf ("Program compiled without 'register' attribute\n");
+    printf ("\n");
+*/
+  }
+/*
+  printf ("Please give the number of runs through the benchmark: ");
+*/
+  {
+    int n;
+/*
+    scanf ("%d", &n);
+*/
+    Number_Of_Runs = n=1000;
+  }
+/*
+  printf ("\n");
+
+  printf ("Execution starts, %d runs through Dhrystone\n", Number_Of_Runs);
+*/
+
+  /***************/
+  /* Start timer */
+  /***************/
+
+/* 
+#ifdef TIMES
+  times (&time_info);
+  Begin_Time = (long) time_info.tms_utime;
+#endif
+#ifdef TIME
+  Begin_Time = time ( (long *) 0);
+#endif
+*/
+
+  for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
+  {
+
+    Proc_5();
+    Proc_4();
+      /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */
+    Int_1_Loc = 2;
+    Int_2_Loc = 3;
+    strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
+    Enum_Loc = Ident_2;
+    Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
+      /* Bool_Glob == 1 */
+    while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */
+    {
+      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
+        /* Int_3_Loc == 7 */
+      Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
+        /* Int_3_Loc == 7 */
+      Int_1_Loc += 1;
+    } /* while */
+      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+    Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
+      /* Int_Glob == 5 */
+    Proc_1 (Ptr_Glob);
+    for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
+                             /* loop body executed twice */
+    {
+      if (Enum_Loc == Func_1 (Ch_Index, 'C'))
+          /* then, not executed */
+        {
+        Proc_6 (Ident_1, &Enum_Loc);
+        strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
+        Int_2_Loc = Run_Index;
+        Int_Glob = Run_Index;
+        }
+    }
+      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+    Int_2_Loc = Int_2_Loc * Int_1_Loc;
+    Int_1_Loc = Int_2_Loc / Int_3_Loc;
+    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
+      /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */
+    Proc_2 (&Int_1_Loc);
+      /* Int_1_Loc == 5 */
+
+  } /* loop "for Run_Index" */
+
+  /**************/
+  /* Stop timer */
+  /**************/
+ 
+/* 
+#ifdef TIMES
+  times (&time_info);
+  End_Time = (long) time_info.tms_utime;
+#endif
+#ifdef TIME
+  End_Time = time ( (long *) 0);
+#endif
+*/
+
+/*
+  printf ("Execution ends\n");
+  printf ("\n");
+  printf ("Final values of the variables used in the benchmark:\n");
+  printf ("\n");
+  printf ("Int_Glob:            %d\n", Int_Glob);
+  printf ("        should be:   %d\n", 5);
+  printf ("Bool_Glob:           %d\n", Bool_Glob);
+  printf ("        should be:   %d\n", 1);
+  printf ("Ch_1_Glob:           %c\n", Ch_1_Glob);
+  printf ("        should be:   %c\n", 'A');
+  printf ("Ch_2_Glob:           %c\n", Ch_2_Glob);
+  printf ("        should be:   %c\n", 'B');
+  printf ("Arr_1_Glob[8]:       %d\n", Arr_1_Glob[8]);
+  printf ("        should be:   %d\n", 7);
+  printf ("Arr_2_Glob[8][7]:    %d\n", Arr_2_Glob[8][7]);
+  printf ("        should be:   Number_Of_Runs + 10\n");
+  printf ("Ptr_Glob->\n");
+  printf ("  Ptr_Comp:          %d\n", (int) Ptr_Glob->Ptr_Comp);
+  printf ("        should be:   (implementation-dependent)\n");
+  printf ("  Discr:             %d\n", Ptr_Glob->Discr);
+  printf ("        should be:   %d\n", 0);
+  printf ("  Enum_Comp:         %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
+  printf ("        should be:   %d\n", 2);
+  printf ("  Int_Comp:          %d\n", Ptr_Glob->variant.var_1.Int_Comp);
+  printf ("        should be:   %d\n", 17);
+  printf ("  Str_Comp:          %s\n", Ptr_Glob->variant.var_1.Str_Comp);
+  printf ("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  printf ("Next_Ptr_Glob->\n");
+  printf ("  Ptr_Comp:          %d\n", (int) Next_Ptr_Glob->Ptr_Comp);
+  printf ("        should be:   (implementation-dependent), same as above\n");
+  printf ("  Discr:             %d\n", Next_Ptr_Glob->Discr);
+  printf ("        should be:   %d\n", 0);
+  printf ("  Enum_Comp:         %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
+  printf ("        should be:   %d\n", 1);
+  printf ("  Int_Comp:          %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
+  printf ("        should be:   %d\n", 18);
+  printf ("  Str_Comp:          %s\n",
+                                Next_Ptr_Glob->variant.var_1.Str_Comp);
+  printf ("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  printf ("Int_1_Loc:           %d\n", Int_1_Loc);
+  printf ("        should be:   %d\n", 5);
+  printf ("Int_2_Loc:           %d\n", Int_2_Loc);
+  printf ("        should be:   %d\n", 13);
+  printf ("Int_3_Loc:           %d\n", Int_3_Loc);
+  printf ("        should be:   %d\n", 7);
+  printf ("Enum_Loc:            %d\n", Enum_Loc);
+  printf ("        should be:   %d\n", 1);
+  printf ("Str_1_Loc:           %s\n", Str_1_Loc);
+  printf ("        should be:   DHRYSTONE PROGRAM, 1'ST STRING\n");
+  printf ("Str_2_Loc:           %s\n", Str_2_Loc);
+  printf ("        should be:   DHRYSTONE PROGRAM, 2'ND STRING\n");
+  printf ("\n");
+*/
+
+  User_Time = End_Time - Begin_Time;
+
+  if (User_Time < Too_Small_Time)
+  {
+/*
+    printf ("Measured time too small to obtain meaningful results\n");
+    printf ("Please increase number of runs\n");
+    printf ("\n");
+*/
+  }
+  else
+  {
+#ifdef TIME
+/*
+    Microseconds = (float) User_Time * Mic_secs_Per_Second 
+                        / (float) Number_Of_Runs;
+    Dhrystones_Per_Second = (float) Number_Of_Runs / (float) User_Time;
+*/
+#else
+/*
+    Microseconds = (float) User_Time * Mic_secs_Per_Second 
+                        / ((float) HZ * ((float) Number_Of_Runs));
+    Dhrystones_Per_Second = ((float) HZ * (float) Number_Of_Runs)
+                        / (float) User_Time;
+*/
+#endif
+/*
+    printf ("Microseconds for one run through Dhrystone: ");
+    printf ("%6.1f \n", Microseconds);
+    printf ("Dhrystones per Second:                      ");
+    printf ("%6.1f \n", Dhrystones_Per_Second);
+    printf ("\n");
+*/
+  }
+
+  exit (0);
+}
+
+
+Proc_1 (Ptr_Val_Par)
+/******************/
+
+REG Rec_Pointer Ptr_Val_Par;
+    /* executed once */
+{
+  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;  
+                                        /* == Ptr_Glob_Next */
+  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */
+  /* corresponds to "rename" in Ada, "with" in Pascal           */
+  
+  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob); 
+  Ptr_Val_Par->variant.var_1.Int_Comp = 5;
+  Next_Record->variant.var_1.Int_Comp 
+        = Ptr_Val_Par->variant.var_1.Int_Comp;
+  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
+  Proc_3 (&Next_Record->Ptr_Comp);
+    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp 
+                        == Ptr_Glob->Ptr_Comp */
+  if (Next_Record->Discr == Ident_1)
+    /* then, executed */
+  {
+    Next_Record->variant.var_1.Int_Comp = 6;
+    Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp, 
+           &Next_Record->variant.var_1.Enum_Comp);
+    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
+    Proc_7 (Next_Record->variant.var_1.Int_Comp, 10, 
+           &Next_Record->variant.var_1.Int_Comp);
+  }
+  else /* not executed */
+    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);
+} /* Proc_1 */
+
+
+Proc_2 (Int_Par_Ref)
+/******************/
+    /* executed once */
+    /* *Int_Par_Ref == 1, becomes 4 */
+
+One_Fifty   *Int_Par_Ref;
+{
+  One_Fifty  Int_Loc;  
+  Enumeration   Enum_Loc;
+
+  Int_Loc = *Int_Par_Ref + 10;
+  do /* executed once */
+    if (Ch_1_Glob == 'A')
+      /* then, executed */
+    {
+      Int_Loc -= 1;
+      *Int_Par_Ref = Int_Loc - Int_Glob;
+      Enum_Loc = Ident_1;
+    } /* if */
+  while (Enum_Loc != Ident_1); /* true */
+} /* Proc_2 */
+
+
+Proc_3 (Ptr_Ref_Par)
+/******************/
+    /* executed once */
+    /* Ptr_Ref_Par becomes Ptr_Glob */
+
+Rec_Pointer *Ptr_Ref_Par;
+
+{
+  if (Ptr_Glob != Null)
+    /* then, executed */
+    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
+  Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
+} /* Proc_3 */
+
+
+Proc_4 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Boolean Bool_Loc;
+
+  Bool_Loc = Ch_1_Glob == 'A';
+  Bool_Glob = Bool_Loc | Bool_Glob;
+  Ch_2_Glob = 'B';
+} /* Proc_4 */
+
+
+Proc_5 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Ch_1_Glob = 'A';
+  Bool_Glob = false;
+} /* Proc_5 */
+
+
+        /* Procedure for the assignment of structures,          */
+        /* if the C compiler doesn't support this feature       */
+#ifdef  NOSTRUCTASSIGN
+memcpy (d, s, l)
+register char   *d;
+register char   *s;
+register int    l;
+{
+        while (l--) *d++ = *s++;
+}
+#endif
+
+
+/*
+ ****************************************************************************
+ *
+ *                   "DHRYSTONE" Benchmark Program
+ *                   -----------------------------
+ *                                                                            
+ *  Version:    C, Version 2.1
+ *                                                                            
+ *  File:       dhry_2.c (part 3 of 3)
+ *
+ *  Date:       May 25, 1988
+ *
+ *  Author:     Reinhold P. Weicker
+ *
+ ****************************************************************************
+ */
+
+#ifndef REG
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#endif
+
+extern  int     Int_Glob;
+extern  char    Ch_1_Glob;
+
+
+Proc_6 (Enum_Val_Par, Enum_Ref_Par)
+/*********************************/
+    /* executed once */
+    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
+
+Enumeration  Enum_Val_Par;
+Enumeration *Enum_Ref_Par;
+{
+  *Enum_Ref_Par = Enum_Val_Par;
+  if (! Func_3 (Enum_Val_Par))
+    /* then, not executed */
+    *Enum_Ref_Par = Ident_4;
+  switch (Enum_Val_Par)
+  {
+    case Ident_1: 
+      *Enum_Ref_Par = Ident_1;
+      break;
+    case Ident_2: 
+      if (Int_Glob > 100)
+        /* then */
+      *Enum_Ref_Par = Ident_1;
+      else *Enum_Ref_Par = Ident_4;
+      break;
+    case Ident_3: /* executed */
+      *Enum_Ref_Par = Ident_2;
+      break;
+    case Ident_4: break;
+    case Ident_5: 
+      *Enum_Ref_Par = Ident_3;
+      break;
+  } /* switch */
+} /* Proc_6 */
+
+
+Proc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
+/**********************************************/
+    /* executed three times                                      */ 
+    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */
+    /*                  Int_Par_Ref becomes 7                    */
+    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
+    /*                  Int_Par_Ref becomes 17                   */
+    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
+    /*                  Int_Par_Ref becomes 18                   */
+One_Fifty       Int_1_Par_Val;
+One_Fifty       Int_2_Par_Val;
+One_Fifty      *Int_Par_Ref;
+{
+  One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 2;
+  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
+} /* Proc_7 */
+
+
+Proc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
+/*********************************************************************/
+    /* executed once      */
+    /* Int_Par_Val_1 == 3 */
+    /* Int_Par_Val_2 == 7 */
+Arr_1_Dim       Arr_1_Par_Ref;
+Arr_2_Dim       Arr_2_Par_Ref;
+int             Int_1_Par_Val;
+int             Int_2_Par_Val;
+{
+  REG One_Fifty Int_Index;
+  REG One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 5;
+  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
+  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
+  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
+  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
+    Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
+  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
+  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
+  Int_Glob = 5;
+} /* Proc_8 */
+
+
+Enumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
+/*************************************************/
+    /* executed three times                                         */
+    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */
+    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */
+    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */
+
+Capital_Letter   Ch_1_Par_Val;
+Capital_Letter   Ch_2_Par_Val;
+{
+  Capital_Letter        Ch_1_Loc;
+  Capital_Letter        Ch_2_Loc;
+
+  Ch_1_Loc = Ch_1_Par_Val;
+  Ch_2_Loc = Ch_1_Loc;
+  if (Ch_2_Loc != Ch_2_Par_Val)
+    /* then, executed */
+    return (Ident_1);
+  else  /* not executed */
+  {
+    Ch_1_Glob = Ch_1_Loc;
+    return (Ident_2);
+   }
+} /* Func_1 */
+
+
+Boolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
+/*************************************************/
+    /* executed once */
+    /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
+    /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
+
+Str_30  Str_1_Par_Ref;
+Str_30  Str_2_Par_Ref;
+{
+  REG One_Thirty        Int_Loc;
+      Capital_Letter    Ch_Loc;
+
+  Int_Loc = 2;
+  while (Int_Loc <= 2) /* loop body executed once */
+    if (Func_1 (Str_1_Par_Ref[Int_Loc],
+                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
+      /* then, executed */
+    {
+      Ch_Loc = 'A';
+      Int_Loc += 1;
+    } /* if, while */
+  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
+    /* then, not executed */
+    Int_Loc = 7;
+  if (Ch_Loc == 'R')
+    /* then, not executed */
+    return (true);
+  else /* executed */
+  {
+    if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
+      /* then, not executed */
+    {
+      Int_Loc += 7;
+      Int_Glob = Int_Loc;
+      return (true);
+    }
+    else /* executed */
+      return (false);
+  } /* if Ch_Loc */
+} /* Func_2 */
+
+
+Boolean Func_3 (Enum_Par_Val)
+/***************************/
+    /* executed once        */
+    /* Enum_Par_Val == Ident_3 */
+Enumeration Enum_Par_Val;
+{
+  Enumeration Enum_Loc;
+
+  Enum_Loc = Enum_Par_Val;
+  if (Enum_Loc == Ident_3)
+    /* then, executed */
+    return (true);
+  else /* not executed */
+    return (false);
+} /* Func_3 */
+
diff --git a/gcc/testsuite/gcc.misc-tests/dhry.exp b/gcc/testsuite/gcc.misc-tests/dhry.exp
new file mode 100644
index 00000000000..890f25018a8
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dhry.exp
@@ -0,0 +1,31 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+global PERF_TEST
+if { ![info exists PERF_TEST] || "$PERF_TEST" != "yes" } {
+    return
+}
+
+load_lib mike-gcc.exp
+
+prebase
+set actions run
+set compiler_output "^$"
+set program_output "^$"
+postbase dhry.c $run $groups
diff --git a/gcc/testsuite/gcc.misc-tests/dhry.h b/gcc/testsuite/gcc.misc-tests/dhry.h
new file mode 100644
index 00000000000..8d42da0094d
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/dhry.h
@@ -0,0 +1,431 @@
+/*
+ ****************************************************************************
+ *
+ *                   "DHRYSTONE" Benchmark Program
+ *                   -----------------------------
+ *                                                                            
+ *  Version:    C, Version 2.1
+ *                                                                            
+ *  File:       dhry.h (part 1 of 3)
+ *
+ *  Date:       May 25, 1988
+ *
+ *  Author:     Reinhold P. Weicker
+ *                      Siemens AG, AUT E 51
+ *                      Postfach 3220
+ *                      8520 Erlangen
+ *                      Germany (West)
+ *                              Phone:  [+49]-9131-7-20330
+ *                                      (8-17 Central European Time)
+ *                              Usenet: ..!mcsun!unido!estevax!weicker
+ *
+ *              Original Version (in Ada) published in
+ *              "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
+ *              pp. 1013 - 1030, together with the statistics
+ *              on which the distribution of statements etc. is based.
+ *
+ *              In this C version, the following C library functions are used:
+ *              - strcpy, strcmp (inside the measurement loop)
+ *              - printf, scanf (outside the measurement loop)
+ *              In addition, Berkeley UNIX system calls "times ()" or "time ()"
+ *              are used for execution time measurement. For measurements
+ *              on other systems, these calls have to be changed.
+ *
+ *  Collection of Results:
+ *              Reinhold Weicker (address see above) and
+ *              
+ *              Rick Richardson
+ *              PC Research. Inc.
+ *              94 Apple Orchard Drive
+ *              Tinton Falls, NJ 07724
+ *                      Phone:  (201) 389-8963 (9-17 EST)               
+ *                      Usenet: ...!uunet!pcrat!rick
+ *
+ *      Please send results to Rick Richardson and/or Reinhold Weicker.
+ *      Complete information should be given on hardware and software used.
+ *      Hardware information includes: Machine type, CPU, type and size
+ *      of caches; for microprocessors: clock frequency, memory speed
+ *      (number of wait states).
+ *      Software information includes: Compiler (and runtime library)
+ *      manufacturer and version, compilation switches, OS version.
+ *      The Operating System version may give an indication about the
+ *      compiler; Dhrystone itself performs no OS calls in the measurement loop.
+ *
+ *      The complete output generated by the program should be mailed
+ *      such that at least some checks for correctness can be made.
+ *
+ ***************************************************************************
+ *
+ *  History:    This version C/2.1 has been made for two reasons:
+ *
+ *              1) There is an obvious need for a common C version of
+ *              Dhrystone, since C is at present the most popular system
+ *              programming language for the class of processors
+ *              (microcomputers, minicomputers) where Dhrystone is used most.
+ *              There should be, as far as possible, only one C version of
+ *              Dhrystone such that results can be compared without
+ *              restrictions. In the past, the C versions distributed
+ *              by Rick Richardson (Version 1.1) and by Reinhold Weicker
+ *              had small (though not significant) differences.
+ *
+ *              2) As far as it is possible without changes to the Dhrystone
+ *              statistics, optimizing compilers should be prevented from
+ *              removing significant statements.
+ *
+ *              This C version has been developed in cooperation with
+ *              Rick Richardson (Tinton Falls, NJ), it incorporates many
+ *              ideas from the "Version 1.1" distributed previously by
+ *              him over the UNIX network Usenet.
+ *              I also thank Chaim Benedelac (National Semiconductor),
+ *              David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
+ *              Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
+ *              for their help with comments on earlier versions of the
+ *              benchmark.
+ *
+ *  Changes:    In the initialization part, this version follows mostly
+ *              Rick Richardson's version distributed via Usenet, not the
+ *              version distributed earlier via floppy disk by Reinhold Weicker.
+ *              As a concession to older compilers, names have been made
+ *              unique within the first 8 characters.
+ *              Inside the measurement loop, this version follows the
+ *              version previously distributed by Reinhold Weicker.
+ *
+ *              At several places in the benchmark, code has been added,
+ *              but within the measurement loop only in branches that 
+ *              are not executed. The intention is that optimizing compilers
+ *              should be prevented from moving code out of the measurement
+ *              loop, or from removing code altogether. Since the statements
+ *              that are executed within the measurement loop have NOT been
+ *              changed, the numbers defining the "Dhrystone distribution"
+ *              (distribution of statements, operand types and locality)
+ *              still hold. Except for sophisticated optimizing compilers,
+ *              execution times for this version should be the same as
+ *              for previous versions.
+ *              
+ *              Since it has proven difficult to subtract the time for the
+ *              measurement loop overhead in a correct way, the loop check
+ *              has been made a part of the benchmark. This does have
+ *              an impact - though a very minor one - on the distribution
+ *              statistics which have been updated for this version.
+ *
+ *              All changes within the measurement loop are described
+ *              and discussed in the companion paper "Rationale for
+ *              Dhrystone version 2".
+ *
+ *              Because of the self-imposed limitation that the order and
+ *              distribution of the executed statements should not be
+ *              changed, there are still cases where optimizing compilers
+ *              may not generate code for some statements. To a certain
+ *              degree, this is unavoidable for small synthetic benchmarks.
+ *              Users of the benchmark are advised to check code listings
+ *              whether code is generated for all statements of Dhrystone.
+ *
+ *              Version 2.1 is identical to version 2.0 distributed via
+ *              the UNIX network Usenet in March 1988 except that it corrects
+ *              some minor deficiencies that were found by users of version 2.0.
+ *              The only change within the measurement loop is that a
+ *              non-executed "else" part was added to the "if" statement in
+ *              Func_3, and a non-executed "else" part removed from Proc_3.
+ *
+ ***************************************************************************
+ *
+ * Defines:     The following "Defines" are possible:
+ *              -DREG=register          (default: Not defined)
+ *                      As an approximation to what an average C programmer
+ *                      might do, the "register" storage class is applied
+ *                      (if enabled by -DREG=register)
+ *                      - for local variables, if they are used (dynamically)
+ *                        five or more times
+ *                      - for parameters if they are used (dynamically)
+ *                        six or more times
+ *                      Note that an optimal "register" strategy is
+ *                      compiler-dependent, and that "register" declarations
+ *                      do not necessarily lead to faster execution.
+ *              -DNOSTRUCTASSIGN        (default: Not defined)
+ *                      Define if the C compiler does not support
+ *                      assignment of structures.
+ *              -DNOENUMS               (default: Not defined)
+ *                      Define if the C compiler does not support
+ *                      enumeration types.
+ *              -DTIMES                 (default)
+ *              -DTIME
+ *                      The "times" function of UNIX (returning process times)
+ *                      or the "time" function (returning wallclock time)
+ *                      is used for measurement. 
+ *                      For single user machines, "time ()" is adequate. For
+ *                      multi-user machines where you cannot get single-user
+ *                      access, use the "times ()" function. If you have
+ *                      neither, use a stopwatch in the dead of night.
+ *                      "printf"s are provided marking the points "Start Timer"
+ *                      and "Stop Timer". DO NOT use the UNIX "time(1)"
+ *                      command, as this will measure the total time to
+ *                      run this program, which will (erroneously) include
+ *                      the time to allocate storage (malloc) and to perform
+ *                      the initialization.
+ *              -DHZ=nnn
+ *                      In Berkeley UNIX, the function "times" returns process
+ *                      time in 1/HZ seconds, with HZ = 60 for most systems.
+ *                      CHECK YOUR SYSTEM DESCRIPTION BEFORE YOU JUST APPLY
+ *                      A VALUE.
+ *
+ ***************************************************************************
+ *
+ *  Compilation model and measurement (IMPORTANT):
+ *
+ *  This C version of Dhrystone consists of three files:
+ *  - dhry.h (this file, containing global definitions and comments)
+ *  - dhry_1.c (containing the code corresponding to Ada package Pack_1)
+ *  - dhry_2.c (containing the code corresponding to Ada package Pack_2)
+ *
+ *  The following "ground rules" apply for measurements:
+ *  - Separate compilation
+ *  - No procedure merging
+ *  - Otherwise, compiler optimizations are allowed but should be indicated
+ *  - Default results are those without register declarations
+ *  See the companion paper "Rationale for Dhrystone Version 2" for a more
+ *  detailed discussion of these ground rules.
+ *
+ *  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
+ *  models ("small", "medium", "large" etc.) should be given if possible,
+ *  together with a definition of these models for the compiler system used.
+ *
+ **************************************************************************
+ *
+ *  Dhrystone (C version) statistics:
+ *
+ *  [Comment from the first distribution, updated for version 2.
+ *   Note that because of language differences, the numbers are slightly
+ *   different from the Ada version.]
+ *
+ *  The following program contains statements of a high level programming
+ *  language (here: C) in a distribution considered representative:           
+ *
+ *    assignments                  52 (51.0 %)
+ *    control statements           33 (32.4 %)
+ *    procedure, function calls    17 (16.7 %)
+ *
+ *  103 statements are dynamically executed. The program is balanced with
+ *  respect to the three aspects:                                             
+ *
+ *    - statement type
+ *    - operand type
+ *    - operand locality
+ *         operand global, local, parameter, or constant.                     
+ *
+ *  The combination of these three aspects is balanced only approximately.    
+ *
+ *  1. Statement Type:                                                        
+ *  -----------------             number
+ *
+ *     V1 = V2                     9
+ *       (incl. V1 = F(..)
+ *     V = Constant               12
+ *     Assignment,                 7
+ *       with array element
+ *     Assignment,                 6
+ *       with record component
+ *                                --
+ *                                34       34
+ *
+ *     X = Y +|-|"&&"|"|" Z        5
+ *     X = Y +|-|"==" Constant     6
+ *     X = X +|- 1                 3
+ *     X = Y *|/ Z                 2
+ *     X = Expression,             1
+ *           two operators
+ *     X = Expression,             1
+ *           three operators
+ *                                --
+ *                                18       18
+ *
+ *     if ....                    14
+ *       with "else"      7
+ *       without "else"   7
+ *           executed        3
+ *           not executed    4
+ *     for ...                     7  |  counted every time
+ *     while ...                   4  |  the loop condition
+ *     do ... while                1  |  is evaluated
+ *     switch ...                  1
+ *     break                       1
+ *     declaration with            1
+ *       initialization
+ *                                --
+ *                                34       34
+ *
+ *     P (...)  procedure call    11
+ *       user procedure      10
+ *       library procedure    1
+ *     X = F (...)
+ *             function  call      6
+ *       user function        5                                         
+ *       library function     1                                               
+ *                                --                                          
+ *                                17       17
+ *                                        ---
+ *                                        103
+ *
+ *    The average number of parameters in procedure or function calls
+ *    is 1.82 (not counting the function values as implicit parameters).
+ *
+ *
+ *  2. Operators
+ *  ------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *    Arithmetic             32          50.8                                 
+ *
+ *       +                     21          33.3                              
+ *       -                      7          11.1                              
+ *       *                      3           4.8
+ *       / (int div)            1           1.6
+ *
+ *    Comparison             27           42.8
+ *
+ *       ==                     9           14.3
+ *       /=                     4            6.3
+ *       >                      1            1.6
+ *       <                      3            4.8
+ *       >=                     1            1.6
+ *       <=                     9           14.3
+ *
+ *    Logic                   4            6.3
+ *
+ *       && (AND-THEN)          1            1.6
+ *       |  (OR)                1            1.6
+ *       !  (NOT)               2            3.2
+ * 
+ *                           --          -----
+ *                           63          100.1
+ *
+ *
+ *  3. Operand Type (counted once per operand reference):
+ *  ---------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *     Integer               175        72.3 %
+ *     Character              45        18.6 %
+ *     Pointer                12         5.0 %
+ *     String30                6         2.5 %
+ *     Array                   2         0.8 %
+ *     Record                  2         0.8 %
+ *                           ---       -------
+ *                           242       100.0 %
+ *
+ *  When there is an access path leading to the final operand (e.g. a record
+ *  component), only the final data type on the access path is counted.       
+ *
+ *
+ *  4. Operand Locality:                                                      
+ *  -------------------
+ *                                number    approximate
+ *                                          percentage
+ *
+ *     local variable              114        47.1 %
+ *     global variable              22         9.1 %
+ *     parameter                    45        18.6 %
+ *        value                        23         9.5 %
+ *        reference                    22         9.1 %
+ *     function result               6         2.5 %
+ *     constant                     55        22.7 %
+ *                                 ---       -------
+ *                                 242       100.0 %
+ *
+ *
+ *  The program does not compute anything meaningful, but it is syntactically
+ *  and semantically correct. All variables have a value assigned to them
+ *  before they are used as a source operand.
+ *
+ *  There has been no explicit effort to account for the effects of a
+ *  cache, or to balance the use of long or short displacements for code or
+ *  data.
+ *
+ ***************************************************************************
+ */
+
+/* Compiler and system dependent definitions: */
+/*
+#ifndef TIME
+#define TIMES
+#endif
+*/                /* Use times(2) time function unless    */
+                /* explicitly defined otherwise         */
+
+/*
+ #ifndef HZ
+ #define HZ      60
+ #endif
+*/
+
+/*
+#ifdef TIMES
+#include <sys/types.h>
+#include <sys/times.h>
+*/                /* for "times" */
+/*
+#endif
+*/
+#define Mic_secs_Per_Second     1000000.0
+                /* Berkeley UNIX C returns process times in seconds/HZ */
+
+#ifdef  NOSTRUCTASSIGN
+#define structassign(d, s)      memcpy(&(d), &(s), sizeof(d))
+#else
+#define structassign(d, s)      d = s
+#endif
+
+#ifdef  NOENUM
+#define Ident_1 0
+#define Ident_2 1
+#define Ident_3 2
+#define Ident_4 3
+#define Ident_5 4
+  typedef int   Enumeration;
+#else
+  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}
+                Enumeration;
+#endif
+        /* for boolean and enumeration types in Ada, Pascal */
+
+/* General definitions: */
+
+#include <stdio.h>
+                /* for strcpy, strcmp */
+
+#define Null 0 
+                /* Value of a Null pointer */
+#define true  1
+#define false 0
+
+typedef int     One_Thirty;
+typedef int     One_Fifty;
+typedef char    Capital_Letter;
+typedef int     Boolean;
+typedef char    Str_30 [31];
+typedef int     Arr_1_Dim [50];
+typedef int     Arr_2_Dim [50] [50];
+
+typedef struct record 
+    {
+    struct record *Ptr_Comp;
+    Enumeration    Discr;
+    union {
+          struct {
+                  Enumeration Enum_Comp;
+                  int         Int_Comp;
+                  char        Str_Comp [31];
+                  } var_1;
+          struct {
+                  Enumeration E_Comp_2;
+                  char        Str_2_Comp [31];
+                  } var_2;
+          struct {
+                  char        Ch_1_Comp;
+                  char        Ch_2_Comp;
+                  } var_3;
+          } variant;
+      } Rec_Type, *Rec_Pointer;
+
+
diff --git a/gcc/testsuite/gcc.misc-tests/gcov-1.c b/gcc/testsuite/gcc.misc-tests/gcov-1.c
new file mode 100644
index 00000000000..99a02790dee
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/gcov-1.c
@@ -0,0 +1,20 @@
+/* Test Gcov basics.  */
+
+/* { dg-options "-fprofile-arcs -ftest-coverage" } */
+/* { dg-do run { target native } } */
+
+void noop ()
+{
+}
+
+int main ()
+{
+  int i;
+
+  for (i = 0; i < 10; i++)	/* count(11) */
+    noop ();			/* count(10) */
+
+  return 0;			/* count(1) */
+}
+
+/* { dg-final { run-gcov gcov-1.c } } */
diff --git a/gcc/testsuite/gcc.misc-tests/gcov-2.c b/gcc/testsuite/gcc.misc-tests/gcov-2.c
new file mode 100644
index 00000000000..0cfeaec9d34
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/gcov-2.c
@@ -0,0 +1,21 @@
+/* Test Gcov basics.  */
+
+/* { dg-prms-id 8294 } */
+/* { dg-options "-fprofile-arcs -ftest-coverage -g" } */
+/* { dg-do run { target native } } */
+
+void noop ()
+{
+}
+
+int main ()
+{
+  int i;
+
+  for (i = 0; i < 10; i++)	/* count(11) */
+    noop ();			/* count(10) */
+
+  return 0;			/* count(1) */
+}
+
+int a_variable = 0;
diff --git a/gcc/testsuite/gcc.misc-tests/gcov.exp b/gcc/testsuite/gcc.misc-tests/gcov.exp
new file mode 100644
index 00000000000..747465d82ce
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/gcov.exp
@@ -0,0 +1,95 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# Gcov test driver.
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+global GCC_UNDER_TEST
+
+# For now find gcov in the same directory as $GCC_UNDER_TEST.
+if { ![is_remote host] && [string match "*/*" [lindex $GCC_UNDER_TEST 0]] } {
+    set GCOV [file dirname [lindex $GCC_UNDER_TEST 0]]/gcov
+} else {
+    set GCOV gcov
+}
+
+# Proc to delete the working files created by the compiler for gcov.
+
+proc clean-gcov { testcase } {
+    set basename [file tail $testcase]
+    set base [file rootname $basename]
+    remote_file host delete $base.bb $base.bbg $base.da $basename.gcov
+}
+
+# Called by dg-final to run gcov and analyze the results.
+
+proc run-gcov { testcase } {
+    global GCOV
+
+    verbose "Running $GCOV $testcase" 2
+    set testcase [remote_download host $testcase];
+    set result [remote_exec host $GCOV $testcase];
+    if { [lindex $result 0] != 0 } {
+	fail "gcov failed: [lindex $result 1]"
+	clean-gcov $testcase
+	return
+    }
+
+    remote_upload host $testcase.gcov $testcase.gcov;
+    set output [grep $testcase.gcov ".*count\\(\[0-9\]+\\)" line]
+    #send_user "output:$output\n"
+    set failed 0
+    foreach line $output {
+	verbose "Processing count line: $line" 3
+	#send_user "line:$line\n"
+	if [regexp "(\[0-9\]+) *(\[0-9\]+).*count\\((\[0-9\]+)\\)" "$line" all n is shouldbe] {
+	    #send_user "n $n:is $is:shouldbe $shouldbe\n"
+	    if { $is == "" } {
+		fail "$testcase:$n:no data available for this line"
+		incr failed
+	    } elseif { $is != $shouldbe } {
+		fail "$testcase:$n:is $is:should be $shouldbe"
+		incr failed
+	    }
+	} else {
+	    fail "$testcase: can't parse $line (in wrong place?)"
+	    incr failed
+	}
+    }
+    clean-gcov $testcase
+    if !$failed {
+	pass "gcov $testcase"
+    }
+}
+
+# Initialize harness.
+dg-init
+
+# Delete old .da files.
+set files [glob -nocomplain gcov-*.da];
+if { $files != "" } {
+    eval "remote_file build delete $files";
+}
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/gcov-*.c]] "" ""
+
+dg-finish
diff --git a/gcc/testsuite/gcc.misc-tests/m-un-1.c b/gcc/testsuite/gcc.misc-tests/m-un-1.c
new file mode 100644
index 00000000000..ad84d44ca15
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/m-un-1.c
@@ -0,0 +1,37 @@
+/* m-un-1.c: "un" for "uninitialized" */
+
+/*
+From: Jim Wilson <wilson@cygnus.com>
+Date: Wed, 6 Jul 1994 13:11:47 -0700
+To: dje@cygnus.com
+Subject: Re: devo/gcc ChangeLog.fsf stmt.c
+Cc: cvs-gcc@cygnus.com, tege@cygnus.com
+
+	How about a test case?  :-)
+
+Compile with -O -Wall and the broken compiler gives you:
+tmp.c:6: warning: `k' might be used uninitialized in this function
+The fixed compiler (and gcc 2.5.8) gives no warning.
+
+This happens to fix a performance regression in the code generated for
+while loops, but that is presumably much much harder to test for.
+*/
+
+/* { dg-do compile } */
+/* { dg-options "-O -Wall" } */
+
+int
+sub ()
+{
+  int i = 0;
+  int j = 0;
+  int k;	/* { dg-bogus "`k' might be used uninitialized" "uninitialized warning regression" } */
+
+  while (i == 0 && j == 0)
+    {
+      k = 10;
+      i = sub ();
+    }
+
+  return k;
+}
diff --git a/gcc/testsuite/gcc.misc-tests/m-un-2.c b/gcc/testsuite/gcc.misc-tests/m-un-2.c
new file mode 100644
index 00000000000..81d6dca363f
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/m-un-2.c
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-options "-W -Wall" } */
+
+typedef unsigned long size_t;
+extern void* malloc (size_t);
+extern void free (void*);
+extern void* realloc (void*, size_t);
+
+struct vtable {
+  void* (* _malloc) (size_t);
+  void (* _free) (void*);
+  void* (* _realloc) (void*, size_t);
+};
+
+struct vtable mtable = {
+  malloc,
+  free
+}; /* { dg-warning "missing initializer" "warning regression" { target native } {18} } */
+   /* { dg-warning "initialization for `mtable._realloc'" "warning regression" { target native } {18} } */
+
+struct vtable mtable2 = {
+  ._malloc = malloc,
+  ._realloc = realloc
+}; /* { dg-warning "missing initializer" "warning regression" { target native } {24} } */
+   /* { dg-warning "initialization for `mtable2._free'" "warning regression" { target native } {24} } */
+
+struct vtable mtable3 = {
+  ._free = free,
+  ._malloc = malloc,
+  ._realloc = realloc
+};
diff --git a/gcc/testsuite/gcc.misc-tests/matrix1.c b/gcc/testsuite/gcc.misc-tests/matrix1.c
new file mode 100644
index 00000000000..62c71150791
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/matrix1.c
@@ -0,0 +1,46 @@
+/*       Matrix operations      */
+
+#define BOUND 100
+
+int a[BOUND][BOUND],b[BOUND][BOUND],c[BOUND][BOUND];
+
+main()
+{
+int i,j,k;
+
+
+        
+        for (i=0; i<BOUND; i++)
+        {
+                for (j=0; j<BOUND; j++)
+                {
+                        a[i][j] = 1;
+                        b[i][j] = 1;
+                }
+        }
+        for (i=0; i<BOUND; i++)
+        {
+                for (j=0; j<BOUND; j++)
+                {
+                        c[i][j] = 0;
+                        for (k=0; k<BOUND; k++)
+                        {
+                                c[i][j] = c[i][j] + a[i][k] * b[k][j];
+                        }
+                }
+        }
+        for (i=0; i<BOUND; i++)
+        {
+                for (j=0; j<BOUND; j++)
+                {
+                        if (c[i][j] != BOUND)
+                        {
+                                /*printf("ERROR\n");*/
+                                return 0;
+                        }
+                }
+        }
+	i=5;
+
+	exit (0);
+}
diff --git a/gcc/testsuite/gcc.misc-tests/matrix1.exp b/gcc/testsuite/gcc.misc-tests/matrix1.exp
new file mode 100644
index 00000000000..a90ae5c64fe
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/matrix1.exp
@@ -0,0 +1,31 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+global PERF_TEST
+if { ![info exists PERF_TEST] || "$PERF_TEST" != "yes" } {
+    return
+}
+
+load_lib mike-gcc.exp
+
+prebase
+set actions run
+set compiler_output "^$"
+set program_output "^$"
+postbase matrix1.c $run $groups
diff --git a/gcc/testsuite/gcc.misc-tests/mg.c b/gcc/testsuite/gcc.misc-tests/mg.c
new file mode 100644
index 00000000000..5359714572f
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/mg.c
@@ -0,0 +1,8 @@
+/* PR 2981 */
+
+#include "nonexist.h"
+int
+main ()
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.misc-tests/mg.exp b/gcc/testsuite/gcc.misc-tests/mg.exp
new file mode 100644
index 00000000000..845e3e6eb6c
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/mg.exp
@@ -0,0 +1,27 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# Test the -MG flag.
+
+load_lib mike-gcc.exp
+
+prebase
+set actions none-of-the-above
+set compiler_output "mg.o ?: .*mg.c \[ \\\n\]*nonexist.h"
+postbase mg.c "" "" "-MM -MG 2>/dev/null"
diff --git a/gcc/testsuite/gcc.misc-tests/msgs.exp b/gcc/testsuite/gcc.misc-tests/msgs.exp
new file mode 100644
index 00000000000..dbe3f24a78e
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/msgs.exp
@@ -0,0 +1,33 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# Test gcc warning and error messages.
+# Our testcases are named m-*.c ("m" and not "msg" to avoid DOS problems).
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# Initialize harness.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/m-*.c]] "" ""
+
+# All done.
+dg-finish
diff --git a/gcc/testsuite/gcc.misc-tests/sieve.c b/gcc/testsuite/gcc.misc-tests/sieve.c
new file mode 100644
index 00000000000..41897f178c4
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/sieve.c
@@ -0,0 +1,26 @@
+
+#define TRUE 1
+#define FALSE 0
+#define SIZE 8190
+
+char flags[SIZE+1];
+
+main()
+{
+	register int i, prime, k, count, iter;
+	for (iter=1;iter<=100;iter++) 		{
+		count=0;
+		for (i=0;i<=SIZE;i++)
+			flags[i]=TRUE;
+		for (i=0;i<=SIZE;i++) {
+			if (flags[i]) {
+				prime=i+i+3;
+				for (k=i+prime;k<=SIZE;k+=prime)
+					flags[k]=FALSE;
+				count++;
+			}
+		}
+	}
+/* */	exit(0); /* */
+}
+
diff --git a/gcc/testsuite/gcc.misc-tests/sieve.exp b/gcc/testsuite/gcc.misc-tests/sieve.exp
new file mode 100644
index 00000000000..a6c7665bc52
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/sieve.exp
@@ -0,0 +1,31 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+global PERF_TEST
+if { ![info exists PERF_TEST] || "$PERF_TEST" != "yes" } {
+    return
+}
+
+load_lib mike-gcc.exp
+
+prebase
+set actions run
+set compiler_output "^$"
+set program_output "^$"
+postbase sieve.c $run $groups
diff --git a/gcc/testsuite/gcc.misc-tests/sort2.c b/gcc/testsuite/gcc.misc-tests/sort2.c
new file mode 100644
index 00000000000..3d86e1ecc24
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/sort2.c
@@ -0,0 +1,54 @@
+/* Simple test program:   bubble sort of a fixed table. 	*/
+/* This demonstrates some of the compiler's common-subexpression*/
+/* elimination capabilities.  For example, inspect the code	*/
+/* generated for procedure Sort_array.	See the Programmer's    */
+/* Guide for how to request an assembly listing on your host.	*/
+
+typedef unsigned char boolean;
+
+void Sort_array();
+int Tab[100];
+
+main () {
+   int I,J,K,L;
+
+for (L = 0; L < 1000; L++) {
+   /* Initialize the table that will be sorted. */
+   K = 0;
+   for (I = 9; I >= 0; I--)
+      for (J = I*10; J < (I+1)*10; J++)
+	 Tab[K++] = J&1 ? J+1 : J-1;
+
+/*   Print_array(); */
+   Sort_array(Tab,99);	   /* Sort it. */
+/*   Print_array(); */
+}
+/* */ exit(0); /* */
+}
+
+void Sort_array(Tab,Last) int Tab[]; int Last; {
+   boolean Swap;
+   int Temp,I;
+   do {
+      Swap = 0;
+      for (I = 0; I<Last; I++)
+	 if (Tab[I] > Tab[I+1]) {
+	    Temp = Tab[I];
+	    Tab[I] = Tab[I+1];
+	    Tab[I+1] = Temp;
+	    Swap = 1;
+	    }
+      }
+   while (Swap);
+}
+
+
+void Print_array() {
+   int I,J;
+   /*printf("\nArray Contents:\n");*/
+   for (I=0; I<=9; I++) {
+      /*printf("%5d:",10*I); */
+      for (J=0; J<=9; J++); /*printf("%5d",Tab[10*I+J]); */
+      /* printf("\n");*/
+      }
+}
diff --git a/gcc/testsuite/gcc.misc-tests/sort2.exp b/gcc/testsuite/gcc.misc-tests/sort2.exp
new file mode 100644
index 00000000000..ab5f0996426
--- /dev/null
+++ b/gcc/testsuite/gcc.misc-tests/sort2.exp
@@ -0,0 +1,31 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+global PERF_TEST
+if { ![info exists PERF_TEST] || "$PERF_TEST" != "yes" } {
+    return
+}
+
+load_lib mike-gcc.exp
+
+prebase
+set actions run
+set compiler_output "^$"
+set program_output "^$"
+postbase sort2.c $run $groups
diff --git a/gcc/testsuite/lib/c-torture.exp b/gcc/testsuite/lib/c-torture.exp
new file mode 100644
index 00000000000..e2031d87bcd
--- /dev/null
+++ b/gcc/testsuite/lib/c-torture.exp
@@ -0,0 +1,288 @@
+# Copyright (C) 1992-1998, 1999 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-dejagnu@gnu.org.
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+
+# The default option list can be overridden by
+# TORTURE_OPTIONS="{ { list1 } ... { listN } }"
+
+if ![info exists TORTURE_OPTIONS] {
+    # It is theoretically beneficial to group all of the O2/O3 options together,
+    # as in many cases the compiler will generate identical executables for
+    # all of them--and the c-torture testsuite will skip testing identical
+    # executables multiple times.
+    # Also note that -finline-functions is explicitly included in one of the
+    # items below, even though -O3 is also specified, because some ports may
+    # choose to disable inlining functions by default, even when optimizing.
+    set TORTURE_OPTIONS [list \
+	{ -O0 } \
+	{ -O1 } \
+	{ -O2 } \
+	{ -O3 -fomit-frame-pointer } \
+	{ -O3 -fomit-frame-pointer -funroll-loops } \
+	{ -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions } \
+	{ -O3 -g } \
+	{ -Os } ]
+}
+
+
+# Split TORTURE_OPTIONS into two choices: one for testcases with loops and
+# one for testcases without loops.
+
+set torture_with_loops $TORTURE_OPTIONS
+set torture_without_loops ""
+foreach option $TORTURE_OPTIONS {
+    if ![string match "*loop*" $option] {
+	lappend torture_without_loops $option
+    }
+}
+
+#
+# c-torture-compile -- runs the Tege C-torture test
+#
+# SRC is the full pathname of the testcase.
+# OPTION is the specific compiler flag we're testing (eg: -O2).
+#
+proc c-torture-compile { src option } {
+    global output
+    global srcdir tmpdir
+    global host_triplet
+
+    set output "$tmpdir/[file tail [file rootname $src]].o"
+
+    regsub "^$srcdir/?" $src "" testcase
+    # If we couldn't rip $srcdir out of `src' then just do the best we can.
+    # The point is to reduce the unnecessary noise in the logs.  Don't strip
+    # out too much because different testcases with the same name can confuse
+    # `test-tool'.
+    if [string match "/*" $testcase] {
+	set testcase "[file tail [file dirname $src]]/[file tail $src]"
+    }
+
+    verbose "Testing $testcase, $option" 1
+
+    # Run the compiler and analyze the results.
+    set options ""
+    lappend options "additional_flags=-w $option"
+
+    set comp_output [gcc_target_compile "$src" "$output" object $options];
+    gcc_check_compile $testcase $option $output $comp_output
+    remote_file build delete $output
+}
+
+#
+# c-torture-execute -- utility to compile and execute a testcase
+#
+# SRC is the full pathname of the testcase.
+#
+# If the testcase has an associated .x file, we source that to run the
+# test instead.  We use .x so that we don't lengthen the existing filename
+# to more than 14 chars.
+#
+proc c-torture-execute { src args } {
+    global tmpdir tool srcdir output 
+
+    if { [llength $args] > 0 } {
+	set additional_flags [lindex $args 0];
+    } else {
+	set additional_flags "";
+    }
+    # Check for alternate driver.
+    if [file exists [file rootname $src].x] {
+	verbose "Using alternate driver [file rootname [file tail $src]].x" 2
+	set done_p 0
+	catch "set done_p \[source [file rootname $src].x\]"
+	if { $done_p } {
+	    return
+	}
+    }
+   
+    # Look for a loop within the source code - if we don't find one,
+    # don't pass -funroll[-all]-loops.
+    global torture_with_loops torture_without_loops
+    if [expr [search_for $src "for*("]+[search_for $src "while*("]] then {
+	set option_list $torture_with_loops
+    } else {
+	set option_list $torture_without_loops
+    }
+
+    set executable $tmpdir/[file tail [file rootname $src].x]
+
+    regsub "^$srcdir/?" $src "" testcase
+    # If we couldn't rip $srcdir out of `src' then just do the best we can.
+    # The point is to reduce the unnecessary noise in the logs.  Don't strip
+    # out too much because different testcases with the same name can confuse
+    # `test-tool'.
+    if [string match "/*" $testcase] {
+	set testcase "[file tail [file dirname $src]]/[file tail $src]"
+    }
+
+    set count 0;
+    set oldstatus "foo";
+    foreach option $option_list {
+	if { $count > 0 } {
+	    set oldexec $execname;
+	}
+	set execname "${executable}${count}";
+	incr count;
+
+	# torture_{compile,execute}_xfail are set by the .x script
+	# (if present)
+	if [info exists torture_compile_xfail] {
+	    setup_xfail $torture_compile_xfail
+	}
+	
+	# torture_execute_before_{compile,execute} can be set by the .x script
+	# (if present)
+	if [info exists torture_eval_before_compile] {
+            set ignore_me [eval $torture_eval_before_compile]
+	}
+	
+	remote_file build delete $execname;
+	verbose "Testing $testcase, $option" 1
+
+	set options ""
+	lappend options "additional_flags=-w $option"
+	if { $additional_flags != "" } {
+	    lappend options "additional_flags=$additional_flags";
+	}
+	set comp_output [gcc_target_compile "$src" "${execname}" executable $options];
+
+	if ![gcc_check_compile "$testcase compilation" $option $execname $comp_output] {
+	    unresolved "$testcase execution, $option"
+	    remote_file build delete $execname
+	    continue
+	}
+
+	# See if this source file uses "long long" types, if it does, and
+	# no_long_long is set, skip execution of the test.
+	if [target_info exists no_long_long] then {
+	    if [expr [search_for $src "long long"]] then {
+		unsupported "$testcase execution, $option"
+		continue
+	    }
+	}
+
+	if [info exists torture_execute_xfail] {
+	    setup_xfail $torture_execute_xfail
+	}
+
+	if [info exists torture_eval_before_execute] {
+            set ignore_me [eval $torture_eval_before_execute]
+	}
+	
+	set skip 0;
+	if [info exists oldexec] {
+	    if { [remote_file build cmp $oldexec $execname] == 0 } {
+		set skip 1;
+	    }
+	}
+	if { $skip == 0 } {
+	    set result [gcc_load "$execname" "" ""]
+	    set status [lindex $result 0];
+	    set output [lindex $result 1];
+	}
+        if { $oldstatus == "pass" } {
+	    remote_file build delete $oldexec;
+        }
+	$status "$testcase execution, $option"
+	set oldstatus $status;
+    }
+    if [info exists status] {
+	if { $status == "pass" } {
+	    remote_file build delete $execname;
+	}
+    }
+}
+
+#
+# search_for -- looks for a string match in a file
+#
+proc search_for { file pattern } {
+    set fd [open $file r]
+    while { [gets $fd cur_line]>=0 } {
+	if [string match "*$pattern*" $cur_line] then {
+	    close $fd
+	    return 1
+	}
+    }
+    close $fd
+    return 0
+}
+
+#
+# c-torture -- the c-torture testcase source file processor
+#
+# This runs compilation only tests (no execute tests).
+# SRC is the full pathname of the testcase, or just a file name in which case
+# we prepend $srcdir/$subdir.
+#
+# If the testcase has an associated .x file, we source that to run the
+# test instead.  We use .x so that we don't lengthen the existing filename
+# to more than 14 chars.
+#
+proc c-torture { args } {
+    global srcdir subdir
+
+    set src [lindex $args 0];
+    if { [llength $args] > 1 } {
+	set options [lindex $args 1];
+    } else {
+	set options ""
+    }
+
+    # Prepend $srdir/$subdir if missing.
+    if ![string match "*/*" $src] {
+	set src "$srcdir/$subdir/$src"
+    }
+
+    # Check for alternate driver.
+    if [file exists [file rootname $src].x] {
+	verbose "Using alternate driver [file rootname [file tail $src]].x" 2
+	set done_p 0
+	catch "set done_p \[source [file rootname $src].x\]"
+	if { $done_p } {
+	    return
+	}
+    }
+   
+    # Look for a loop within the source code - if we don't find one,
+    # don't pass -funroll[-all]-loops.
+    global torture_with_loops torture_without_loops
+    if [expr [search_for $src "for*("]+[search_for $src "while*("]] then {
+	set option_list $torture_with_loops
+    } else {
+	set option_list $torture_without_loops
+    }
+
+    # loop through all the options
+    foreach option $option_list {
+	# torture_compile_xfail is set by the .x script (if present)
+	if [info exists torture_compile_xfail] {
+	    setup_xfail $torture_compile_xfail
+	}
+
+	# torture_execute_before_compile is set by the .x script (if present)
+	if [info exists torture_eval_before_compile] {
+            set ignore_me [eval $torture_eval_before_compile]
+	}
+	
+	c-torture-compile $src "$option $options"
+    }
+}
diff --git a/gcc/testsuite/lib/chill.exp b/gcc/testsuite/lib/chill.exp
new file mode 100644
index 00000000000..586e5c8cffd
--- /dev/null
+++ b/gcc/testsuite/lib/chill.exp
@@ -0,0 +1,365 @@
+#
+# Expect script for Chill Regression Tests
+#   Copyright (C) 1993, 1996, 1997 Free Software Foundation
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# Written by Jeffrey Wheat (cassidy@cygnus.com)
+#
+
+#
+# chill support library procedures and testsuite specific instructions
+#
+
+#
+# default_chill_version 
+# 	extract and print the version number of the chill compiler
+#	exits if compiler does not exist
+#
+proc default_chill_version { } {
+    global GCC_UNDER_TEST
+    
+    # ignore any arguments after the command 
+    set compiler [lindex $GCC_UNDER_TEST 0]
+    
+    # verify that the compiler exists
+    if {[which $compiler] != 0} then {
+        set tmp [ exec $compiler -v ]
+        regexp "version.*$" $tmp version
+	
+        if [info exists version] then {
+            clone_output "[which $compiler] $version\n"
+        }
+    } else {
+        warning "$compiler does not exist"
+	exit -1
+    }
+}
+
+#
+# chill_compile
+#	compile the specified file
+#
+#	returns values:
+#		return 0 on success
+#		return 1 on failure with $result containing compiler output
+#		exit with -1 if compiler doesn't exist
+#
+#	verbosity output:
+#		1 - indicate compile in progress
+#		2 - indicate compile, target name
+#		3 - indicate compile, target name, exec command, and result
+#
+proc chill_compile { src obj } {
+    global GCC_UNDER_TEST
+    global CFLAGS
+    
+    global errno
+    global result
+    global verbose
+
+    global subdir
+    global tmpdir
+   
+    set errno 0 
+    set cflags $CFLAGS
+    set dumpfile [file rootname $obj].cmp    ;# name of file to dump stderr in
+
+    # verify that the compiler exists
+    if { [which $GCC_UNDER_TEST] == 0 } then {
+	warning "$GCC_UNDER_TEST does not exist"
+	exit -1
+    }
+    
+    if { $verbose == 1 } then {
+	send_user "Compiling... "
+    } else {
+	verbose " -  CMPL: Compiling [file tail $src]" 2
+    }
+   
+    # if object type is a grt file, then only build a grant file
+    if [string match "*.grt" $obj] then {
+	set cflags [concat $cflags -fgrant-only]
+    }
+
+    # build command line
+    set commandline "$GCC_UNDER_TEST $cflags -I$subdir -c $src"
+
+    # write command line to logfile
+    send_log "\n### EXEC: $commandline\n"
+    
+    # tell us whats going on if verbose 
+    verbose "### EXEC: $commandline" 3
+    
+    # exec the compiler with the appropriate flags
+    set errno [catch "exec $commandline" result]
+
+    # dump compiler's stderr output into $dumpfile - this is a gross hack
+    set dumpfile [open $dumpfile w+]; puts $dumpfile $result; close $dumpfile
+
+    # log any compiler output unless its null
+    if ![string match "" $result] then { send_log "\n$result\n" }
+    unset cflags
+    return
+}
+
+#
+# chill_link
+#	link the specified files
+#
+#	returns values:
+#		return 0 on success
+#		return 1 on failure with $result containing compiler output
+#		exit with -1 if compiler doesn't exist
+#
+#	verbosity output:
+#		1 - indicate linking in progress
+#		2 - indicate linking, target name
+#		3 - indicate linking, target name, exec command, and result
+#
+proc chill_link { target } {
+    global GCC_UNDER_TEST
+    global CFLAGS
+    
+    global errno 
+    global result
+    global verbose
+    global tmptarget
+    
+    global crt0
+    global libs
+    global objs
+    
+    set errno 0
+    
+    # verify that the compiler exists
+    if { [which $GCC_UNDER_TEST] == 0 } then {
+	warning "$GCC_UNDER_TEST does not exist"
+	exit -1
+    }
+    
+    if { $verbose == 1 } then {
+	send_user "Linking... "
+    } else {
+	verbose " -  LINK: Linking [file tail $target]" 2
+    }
+    
+    # verify that the object exists
+    if ![file exists $target.o] then {
+	set errno 1
+	set result "file $target.o doesn't exist"
+	return
+    }
+    
+    # build command line
+    set commandline "$GCC_UNDER_TEST $CFLAGS -o $target $target.o $objs $crt0 $libs"
+
+    # write command line to logfile
+    send_log "\n### EXEC: $commandline\n"
+    
+    # tell us whats going on if we are verbose	
+    verbose "### EXEC: $commandline" 3
+    
+    # link the objects, sending any linker output to $result
+    set errno [catch "exec $commandline > $tmptarget.lnk" result]
+ 
+    # log any linker output unless its null
+    if ![string match "" $result] then { send_log "\n$result\n" }
+    return
+}
+
+#
+# default_chill_start
+#
+proc default_chill_start { } {
+    global srcdir
+    global subdir
+    global tmpdir
+    global verbose
+  
+    if { $verbose > 1 } then { send_user "Configuring testsuite... " }
+
+    # tmpdir is obtained from $objdir/site.exp. if not, set it to /tmp
+    if ![info exists tmpdir] then { set tmpdir /tmp }
+
+    # save and convert $srcdir to an absolute pathname, stomp on the old value
+    # stomp on $subdir and set to the absolute path to the subdirectory
+    global osrcdir; set osrcdir $srcdir; set srcdir [cd $srcdir; pwd]
+    global osubdir; set osubdir $subdir; set subdir $srcdir/$subdir
+
+    # cd the temporary directory, $tmpdir
+    cd $tmpdir; verbose "### PWD: [pwd]" 5
+
+    # copy init files to the tmpdir
+    foreach initfile [glob -nocomplain $subdir/*.init] {
+	set targfile $tmpdir/[file tail [file rootname $initfile]]
+	verbose "### EXEC: cp $initfile $targfile" 5
+	if [catch "exec cp $initfile $targfile"] then {
+	    send_user "\nConfigure failed.\n"
+	    exit -1
+	}
+    }
+    if { $verbose > 1 } then { send_user "Configuring finished.\n" }
+}
+    
+#
+# default_chill_exit
+#
+#
+proc default_chill_exit { } {
+    global srcdir
+    global objdir
+    global tmpdir
+    global osrcdir
+    global osubdir
+    
+    # reset directory variables
+    set srcdir $osrcdir; set subdir $osubdir
+
+    # remove all generated targets and objects	
+    verbose "### EXEC: rm -f $tmpdir/*" 3
+    catch "exec rm -f $tmpdir/*" result
+
+    # change back to the main object directory
+    cd $objdir
+    verbose "### SANITY: [pwd]" 5
+}
+
+#
+# chill_diff
+#	compare two files line-by-line
+#
+#	returns values:
+#		return 0 on success
+#		return 1 if different
+#		return -1 if output file doesn't exist
+#
+#	verbosity output:
+#		1 - indicate diffing in progress
+#		2 - indicate diffing, target names
+#		3 - indicate diffing, target names, and result
+#
+proc chill_diff { file_1 file_2 } {
+    global errno
+    global result
+    global target
+    global tmptarget
+
+    global verbose
+    
+    set eof -1
+    set errno 0
+    set differences 0
+    
+    if { $verbose == 1 } then {
+	send_user "Diffing... "
+    } else {
+	verbose " -  DIFF: Diffing [file tail $file_1] [file tail $file_2]" 2
+    }
+    
+    # write command line to logfile
+    send_log "### EXEC: diff $file_1 $file_2\n"
+    
+    # tell us whats going on if we are verbose	
+    verbose "### EXEC: diff $file_1 $file_2" 3
+    
+    # verify file exists and open it
+    if [file exists $file_1] then {
+	set file_a [open $file_1 r]
+    } else {
+	set errno -1; set result "$file_1 doesn't exist"
+	return
+    }
+    
+    # verify file exists and is not zero length, and then open it
+    if [file exists $file_2] then {
+        if [file size $file_2]!=0 then {
+	    set file_b [open $file_2 r]
+        } else {
+	    set errno -1; set result "$file_2 is zero bytes"; return
+        }
+    } else {
+	set errno -1; set result "$file_2 doesn't exist"; return
+    }
+    
+    # spoof the diff routine
+    lappend list_a $target
+
+    while { [gets $file_a line] != $eof } {
+	if [regexp "^#.*$" $line] then {
+	    continue
+	} else {
+	    lappend list_a $line
+	}
+    }
+    close $file_a
+
+    # spoof the diff routine
+    lappend list_b $target
+
+    while { [gets $file_b line] != $eof } {
+	if [regexp "^#.*$" $line] then {
+	    continue
+	} else {
+	    # use [file tail $line] to strip off pathname
+	    lappend list_b [file tail $line]
+	}
+    }
+    close $file_b
+    
+    for { set i 0 } { $i < [llength $list_a] } { incr i } {
+	set line_a [lindex $list_a $i]
+	set line_b [lindex $list_b $i]
+	
+	if [string compare $line_a $line_b] then {
+	    set errno 1
+	    set count [expr $i+1]
+	    set linenum [format %dc%d $count $count]
+	    verbose "$linenum" 3	    
+	    verbose "< $line_a" 3
+	    verbose "---" 3
+	    verbose "> $line_b" 3
+	    
+	    send_log "$file_1: < $count: $line_a\n"
+	    send_log "$file_2: > $count: $line_b\n"
+	    set result "differences found"
+	}
+    }
+    return
+}
+
+#
+# chill_fail
+#	a wrapper around the framework fail proc
+#
+proc chill_fail { target result } {
+    global verbose
+
+    if { $verbose == 1 } then { send_user "\n" }
+    fail $target
+    verbose "--------------------------------------------------" 3
+    verbose "### RESULT: $result" 3
+}
+
+#
+# chill_pass
+#       a wrapper around the framework fail proc
+#
+proc chill_pass { target } {
+    global verbose
+
+    if { $verbose == 1 } then { send_user "\n" }
+    pass $target
+}
diff --git a/gcc/testsuite/lib/f-torture.exp b/gcc/testsuite/lib/f-torture.exp
new file mode 100644
index 00000000000..6596b6f2354
--- /dev/null
+++ b/gcc/testsuite/lib/f-torture.exp
@@ -0,0 +1,317 @@
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-dejagnu@gnu.org.
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+
+# The default option list can be overridden by
+# TORTURE_OPTIONS="{ { list1 } ... { listN } }"
+
+if ![info exists TORTURE_OPTIONS] {
+    # FIXME: We should test -g at least once.
+    set TORTURE_OPTIONS [list \
+	{ -O0 } { -O1 } { -O2 } \
+	{ -O2 -fomit-frame-pointer -finline-functions } \
+	{ -O2 -fomit-frame-pointer -finline-functions -funroll-loops } \
+	{ -O2 -fomit-frame-pointer -finline-functions -funroll-all-loops } \
+	{ -Os }]
+}
+
+
+# Split TORTURE_OPTIONS into two choices: one for testcases with loops and
+# one for testcases without loops.
+
+set torture_with_loops $TORTURE_OPTIONS
+set torture_without_loops ""
+foreach option $TORTURE_OPTIONS {
+    if ![string match "*loop*" $option] {
+	lappend torture_without_loops $option
+    }
+}
+
+#
+# f-torture-compile -- runs the Tege C-torture test
+#
+# SRC is the full pathname of the testcase.
+# OPTION is the specific compiler flag we're testing (eg: -O2).
+#
+proc f-torture-compile { src option } {
+    global output
+    global srcdir tmpdir
+    global host_triplet
+
+    set output "$tmpdir/[file tail [file rootname $src]].o"
+
+    regsub "^$srcdir/?" $src "" testcase
+    # If we couldn't rip $srcdir out of `src' then just do the best we can.
+    # The point is to reduce the unnecessary noise in the logs.  Don't strip
+    # out too much because different testcases with the same name can confuse
+    # `test-tool'.
+    if [string match "/*" $testcase] {
+	set testcase "[file tail [file dirname $src]]/[file tail $src]"
+    }
+
+    verbose "Testing $testcase, $option" 1
+
+    # Run the compiler and analyze the results.
+    set options ""
+    lappend options "additional_flags=-w $option"
+
+    set comp_output [g77_target_compile "$src" "$output" object $options];
+    
+    # Set a few common compiler messages.
+    set fatal_signal "*77*: Internal compiler error: program*got fatal signal"
+ 
+    if [string match "$fatal_signal 6" $comp_output] then {
+	g77_fail $testcase "Got Signal 6, $option"
+	remote_file build delete $output
+	return
+    }
+
+    if [string match "$fatal_signal 11" $comp_output] then {
+	g77_fail $testcase "Got Signal 11, $option"
+	remote_file build delete $output
+	return
+    }
+
+    # We shouldn't get these because of -w, but just in case.
+    if [string match "*77*:*warning:*" $comp_output] then {
+	warning "$testcase: (with warnings) $option"
+	send_log "$comp_output\n"
+	unresolved "$testcase, $option"
+	remote_file build delete $output
+	return
+    }
+
+    set comp_output [prune_warnings $comp_output]
+
+    set unsupported_message [g77_check_unsupported_p $comp_output]
+    if { $unsupported_message != "" } {
+	unsupported "$testcase: $unsupported_message"
+	remote_file build delete $output
+	return
+    }
+
+    # remove any leftover LF/CR to make sure any output is legit
+    regsub -all -- "\[\r\n\]*" $comp_output "" comp_output
+    # If any message remains, we fail.
+    if ![string match "" $comp_output] then {
+	g77_fail $testcase $option
+	remote_file build delete $output
+	return
+    }
+
+    g77_pass $testcase $option
+    remote_file build delete $output
+}
+
+#
+# f-torture-execute -- utility to compile and execute a testcase
+#
+# SRC is the full pathname of the testcase.
+#
+# If the testcase has an associated .x file, we source that to run the
+# test instead.  We use .x so that we don't lengthen the existing filename
+# to more than 14 chars.
+#
+proc f-torture-execute { src } {
+    global tmpdir tool srcdir output 
+
+    # Check for alternate driver.
+    if [file exists [file rootname $src].x] {
+	verbose "Using alternate driver [file rootname [file tail $src]].x" 2
+	set done_p 0
+	catch "set done_p \[source [file rootname $src].x\]"
+	if { $done_p } {
+	    return
+	}
+    }
+   
+    # Look for a loop within the source code - if we don't find one,
+    # don't pass -funroll[-all]-loops.
+    global torture_with_loops torture_without_loops
+    if [expr [search_for $src "do *\[0-9\]"]+[search_for $src "end *do"]] then {
+	set option_list $torture_with_loops
+    } else {
+	set option_list $torture_without_loops
+    }
+
+    set executable $tmpdir/[file tail [file rootname $src].x]
+
+    regsub "^$srcdir/?" $src "" testcase
+    # If we couldn't rip $srcdir out of `src' then just do the best we can.
+    # The point is to reduce the unnecessary noise in the logs.  Don't strip
+    # out too much because different testcases with the same name can confuse
+    # `test-tool'.
+    if [string match "/*" $testcase] {
+	set testcase "[file tail [file dirname $src]]/[file tail $src]"
+    }
+
+    foreach option $option_list {
+	# torture_{compile,execute}_xfail are set by the .x script
+	# (if present)
+	if [info exists torture_compile_xfail] {
+	    setup_xfail $torture_compile_xfail
+	}
+	remote_file build delete $executable
+	verbose "Testing $testcase, $option" 1
+
+	set options ""
+	lappend options "additional_flags=-w $option"
+	set comp_output [g77_target_compile "$src" "$executable" executable $options];
+
+	# Set a few common compiler messages.
+	set fatal_signal "*77*: Internal compiler error: program*got fatal signal"
+	
+	if [string match "$fatal_signal 6" $comp_output] then {
+	    g77_fail $testcase "Got Signal 6, $option"
+	    remote_file build delete $executable
+	    continue
+	}
+	
+	if [string match "$fatal_signal 11" $comp_output] then {
+	    g77_fail $testcase "Got Signal 11, $option"
+	    remote_file build delete $executable
+	    continue
+	}
+	
+	# We shouldn't get these because of -w, but just in case.
+	if [string match "*77*:*warning:*" $comp_output] then {
+	    warning "$testcase: (with warnings) $option"
+	    send_log "$comp_output\n"
+	    unresolved "$testcase, $option"
+	    remote_file build delete $executable
+	    continue
+	}
+	
+	set comp_output [prune_warnings $comp_output]
+	
+	set unsupported_message [g77_check_unsupported_p $comp_output]
+
+	if { $unsupported_message != "" } {
+	    unsupported "$testcase: $unsupported_message"
+	    continue
+	} elseif ![file exists $executable] {
+	    if ![is3way] {
+		fail "$testcase compilation, $option"
+		untested "$testcase execution, $option"
+		continue
+	    } else {
+		# FIXME: since we can't test for the existance of a remote
+		# file without short of doing an remote file list, we assume
+		# that since we got no output, it must have compiled.
+		pass "$testcase compilation, $option"		
+	    }
+	} else {
+	    pass "$testcase compilation, $option"
+	}
+
+	# See if this source file uses "long long" types, if it does, and
+	# no_long_long is set, skip execution of the test.
+	if [target_info exists no_long_long] then {
+	    if [expr [search_for $src "integer\*8"]] then {
+		untested "$testcase execution, $option"
+		continue
+	    }
+	}
+
+	if [info exists torture_execute_xfail] {
+	    setup_xfail $torture_execute_xfail
+	}
+	
+	set result [g77_load "$executable" "" ""]
+	set status [lindex $result 0];
+	set output [lindex $result 1];
+        if { $status == "pass" } {
+	    remote_file build delete $executable
+        }
+	$status "$testcase execution, $option"
+    }
+}
+
+#
+# search_for -- looks for a string match in a file
+#
+proc search_for { file pattern } {
+    set fd [open $file r]
+    while { [gets $fd cur_line]>=0 } {
+	set lower [string tolower $cur_line]
+	if [regexp "$pattern" $lower] then {
+	    close $fd
+	    return 1
+	}
+    }
+    close $fd
+    return 0
+}
+
+#
+# f-torture -- the f-torture testcase source file processor
+#
+# This runs compilation only tests (no execute tests).
+# SRC is the full pathname of the testcase, or just a file name in which case
+# we prepend $srcdir/$subdir.
+#
+# If the testcase has an associated .x file, we source that to run the
+# test instead.  We use .x so that we don't lengthen the existing filename
+# to more than 14 chars.
+#
+proc f-torture { args } {
+    global srcdir subdir
+
+    set src [lindex $args 0];
+    if { [llength $args] > 1 } {
+	set options [lindex $args 1];
+    } else {
+	set options ""
+    }
+
+    # Prepend $srdir/$subdir if missing.
+    if ![string match "*/*" $src] {
+	set src "$srcdir/$subdir/$src"
+    }
+
+    # Check for alternate driver.
+    if [file exists [file rootname $src].x] {
+	verbose "Using alternate driver [file rootname [file tail $src]].x" 2
+	set done_p 0
+	catch "set done_p \[source [file rootname $src].x\]"
+	if { $done_p } {
+	    return
+	}
+    }
+   
+    # Look for a loop within the source code - if we don't find one,
+    # don't pass -funroll[-all]-loops.
+    global torture_with_loops torture_without_loops
+    if [expr [search_for $src "do *\[0-9\]"]+[search_for $src "end *do"]] then {
+	set option_list $torture_with_loops
+    } else {
+	set option_list $torture_without_loops
+    }
+
+    # loop through all the options
+    foreach option $option_list {
+	# torture_compile_xfail is set by the .x script (if present)
+	if [info exists torture_compile_xfail] {
+	    setup_xfail $torture_compile_xfail
+	}
+
+	f-torture-compile $src "$option $options"
+    }
+}
diff --git a/gcc/testsuite/lib/g++-dg.exp b/gcc/testsuite/lib/g++-dg.exp
new file mode 100644
index 00000000000..cad429e729e
--- /dev/null
+++ b/gcc/testsuite/lib/g++-dg.exp
@@ -0,0 +1,83 @@
+#   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-g++@prep.ai.mit.edu
+
+# Define g++ callbacks for dg.exp.
+
+load_lib dg.exp
+
+proc g++-dg-test { prog do_what extra_tool_flags } {
+    # Set up the compiler flags, based on what we're going to do.
+
+    switch $do_what {
+	"preprocess" {
+	    set compile_type "preprocess"
+	    set output_file "[file rootname [file tail $prog]].i"
+	}
+	"compile" {
+	    set compile_type "assembly"
+	    set output_file "[file rootname [file tail $prog]].s"
+	}
+	"assemble" {
+	    set compile_type "object"
+	    set output_file "[file rootname [file tail $prog]].o"
+	}
+	"link" {
+	    set compile_type "executable"
+	    set output_file "a.out"
+	    # The following line is needed for targets like the i960 where
+	    # the default output file is b.out.  Sigh.
+	}
+	"run" {
+	    set compile_type "executable"
+	    # FIXME: "./" is to cope with "." not being in $PATH.
+	    # Should this be handled elsewhere?
+	    # YES.
+	    set output_file "./a.out"
+	    # This is the only place where we care if an executable was
+	    # created or not.  If it was, dg.exp will try to run it.
+	    remote_file build delete $output_file;
+	}
+	default {
+	    perror "$do_what: not a valid dg-do keyword"
+	    return ""
+	}
+    }
+    set options ""
+    if { $extra_tool_flags != "" } {
+	lappend options "additional_flags=$extra_tool_flags"
+    }
+
+    set comp_output [g++_target_compile "$prog" "$output_file" "$compile_type" $options];
+
+    return [list $comp_output $output_file]
+}
+
+
+proc g++-dg-prune { system text } {
+
+    # If we see "region xxx is full" then the testcase is too big for ram.
+    # This is tricky to deal with in a large testsuite like c-torture so
+    # deal with it here.  Just mark the testcase as unsupported.
+    if [regexp "(^|\n)\[^\n\]*: region \[^\n\]* is full" $text] {
+	# The format here is important.  See dg.exp.
+	return "::unsupported::memory full"
+    }
+
+    return $text
+}
diff --git a/gcc/testsuite/lib/g++.exp b/gcc/testsuite/lib/g++.exp
new file mode 100644
index 00000000000..0cc681f3293
--- /dev/null
+++ b/gcc/testsuite/lib/g++.exp
@@ -0,0 +1,234 @@
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-g++@prep.ai.mit.edu
+
+# This file was written by Rob Savoye (rob@cygnus.com)
+# Many modifications by Jeffrey Wheat (cassidy@cygnus.com)
+# With modifications by Mike Stump <mrs@cygnus.com>.
+
+#
+# g++ support library routines
+#
+
+#
+# GXX_UNDER_TEST is the compiler under test.
+#
+
+
+set gpp_compile_options ""
+
+#
+# g++_version -- extract and print the version number of the compiler
+#
+proc g++_version { } {
+    global GXX_UNDER_TEST
+    
+    # ignore any arguments after the command
+    set compiler [lindex $GXX_UNDER_TEST 0]
+    
+    # verify that the compiler exists
+    if { [is_remote host] || [which $compiler] != 0 } then {
+	set tmp [remote_exec host "$compiler -v"]
+	set status [lindex $tmp 0];
+	set output [lindex $tmp 1];
+	regexp "version.*$" $output version
+	if { $status == 0 && [info exists version] } then {
+	    if [is_remote host] {
+		clone_output "$compiler $version\n"
+	    } else {
+		clone_output "[which $compiler] $version\n"
+	    }
+	} else {
+	    clone_output "Couldn't determine version of [which $compiler]\n"
+	}
+    } else {
+	# compiler does not exist (this should have already been detected)
+	warning "$compiler does not exist"
+    }
+}
+
+#
+# g++_init -- called at the start of each subdir of tests
+#
+
+proc g++_init { args } {
+    global subdir
+    global gpp_initialized
+    global base_dir
+    global tmpdir
+    global libdir
+    global gluefile wrap_flags;
+    global objdir srcdir
+    global ALWAYS_CXXFLAGS
+    global TOOL_EXECUTABLE TOOL_OPTIONS
+    global GXX_UNDER_TEST
+
+    if ![info exists GXX_UNDER_TEST] then {
+	if [info exists TOOL_EXECUTABLE] {
+	    set GXX_UNDER_TEST $TOOL_EXECUTABLE;
+	} else {
+	    if [is_remote host] {
+		set GXX_UNDER_TEST [transform c++]
+	    } else {
+		set GXX_UNDER_TEST [findfile $base_dir/../xgcc "$base_dir/../xgcc -B$base_dir/../" [findfile $base_dir/xgcc "$base_dir/xgcc -B$base_dir/" [transform c++]]]
+	    }
+	}
+    }
+
+    # Bleah, nasty. Bad taste.
+    if [ishost "*-dos-*" ] {
+	regsub "c\\+\\+" "$GXX_UNDER_TEST" "gcc" GXX_UNDER_TEST
+    }
+
+    if ![is_remote host] {
+	if { [which $GXX_UNDER_TEST] == 0 } then {
+	    perror "GXX_UNDER_TEST does not exist"
+	    exit 1
+	}
+    }
+    if ![info exists tmpdir] {
+	set tmpdir "/tmp"
+    }
+
+    if [info exists gluefile] {
+	unset gluefile
+    }
+
+    if { [target_info needs_status_wrapper] != "" } {
+	set gluefile ${tmpdir}/testglue.o;
+	set result [build_wrapper $gluefile];
+	if { $result != "" } {
+	    set gluefile [lindex $result 0];
+	    set wrap_flags [lindex $result 1];
+	} else {
+	    unset gluefile
+	}
+    }
+
+    set ALWAYS_CXXFLAGS ""
+
+    if ![is_remote host] {
+	lappend ALWAYS_CXXFLAGS "additional_flags=[g++_include_flags]";
+	lappend ALWAYS_CXXFLAGS "ldflags=[g++_link_flags]";
+    }
+
+    if [info exists TOOL_OPTIONS] {
+	lappend ALWAYS_CXXFLAGS "additional_flags=$TOOL_OPTIONS";
+    }
+
+    verbose -log "ALWAYS_CXXFLAGS set to $ALWAYS_CXXFLAGS"
+
+    verbose "g++ is initialized" 3
+}
+
+
+proc g++_target_compile { source dest type options } {
+    global tmpdir;
+    global gpp_compile_options
+    global gluefile wrap_flags
+    global ALWAYS_CXXFLAGS;
+    global GXX_UNDER_TEST;
+
+    if { [target_info needs_status_wrapper] != "" && [info exists gluefile] } {
+	lappend options "libs=${gluefile}"
+	lappend options "ldflags=${wrap_flags}"
+    }
+
+    lappend options "additional_flags=[libio_include_flags]"
+    lappend options "compiler=$GXX_UNDER_TEST";
+
+    set options [concat $options $gpp_compile_options]
+
+    set options [concat $options "$ALWAYS_CXXFLAGS"];
+
+    if { [regexp "(^| )-frepo( |$)" $options] && \
+	 [regexp "\.o(|bj)$" $dest] } then {
+	regsub "\.o(|bj)$" $dest ".rpo" rponame
+	exec rm -f $rponame
+    }
+
+    return [target_compile $source $dest $type $options]
+}
+
+proc g++_exit { args } {
+    global gluefile;
+
+    if [info exists gluefile] {
+	file_on_build delete $gluefile;
+	unset gluefile;
+    }
+}
+
+# If this is an older version of dejagnu (without runtest_file_p),
+# provide one and assume the old syntax: foo1.exp bar1.c foo2.exp bar2.c.
+# This can be deleted after the next dejagnu release.
+
+if { [info procs runtest_file_p] == "" } then {
+    proc runtest_file_p { runtests testcase } {
+	if { $runtests != "" && [regexp "\[.\]\[cC\]" $runtests] } then {
+	    if { [lsearch $runtests [file tail $testcase]] >= 0 } then {
+		return 1
+	    } else {
+		return 0
+	    }
+	}
+	return 1
+    }
+}
+
+# Provide a definition of this if missing (delete after next dejagnu release).
+
+if { [info procs prune_warnings] == "" } then {
+    proc prune_warnings { text } {
+	return $text
+    }
+}
+
+# Utility used by mike-g++.exp and old-dejagnu.exp.
+# Check the compiler(/assembler/linker) output for text indicating that
+# the testcase should be marked as "unsupported".
+#
+# When dealing with a large number of tests, it's difficult to weed out the
+# ones that are too big for a particular cpu (eg: 16 bit with a small amount
+# of memory).  There are various ways to deal with this.  Here's one.
+# Fortunately, all of the cases where this is likely to happen will be using
+# gld so we can tell what the error text will look like.
+
+proc ${tool}_check_unsupported_p { output } {
+    if [regexp "(^|\n)\[^\n\]*: region \[^\n\]* is full" $output] {
+	return "memory full"
+    }
+    return ""
+}
+
+proc ${tool}_option_help { } {
+    send_user "--additional_options,OPTIONS\t\tUse OPTIONS to compile the testcase files. OPTIONS should be comma-separated."
+}
+
+proc ${tool}_option_proc { option } {
+    if[regexp "^--additional_options," $option] {
+	global gpp_compile_options
+	regsub "--additional_options," $option "" option
+	foreach x [split $option ","] {
+	    lappend gpp_compile_options "additional_flags=$x"
+	}
+	return 1;
+    } else {
+	return 0
+    }
+}
diff --git a/gcc/testsuite/lib/g77.exp b/gcc/testsuite/lib/g77.exp
new file mode 100644
index 00000000000..3b2beb34b56
--- /dev/null
+++ b/gcc/testsuite/lib/g77.exp
@@ -0,0 +1,274 @@
+# Copyright (C) 1992, 1993, 1994, 1996, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-g77@prep.ai.mit.edu
+
+# This file was written by Rob Savoye (rob@cygnus.com)
+# Currently maintained by Doug Evans (dje@cygnus.com)
+
+# This file is loaded by the tool init file (eg: unix.exp).  It provides
+# default definitions for g77_start, etc. and other supporting cast members.
+
+# These globals are used by g77_start if no compiler arguments are provided.
+# They are also used by the various testsuites to define the environment:
+# where to find stdio.h, libc.a, etc.
+
+#
+# G77_UNDER_TEST is the compiler under test.
+#
+
+#
+# default_g77_version -- extract and print the version number of the compiler
+#
+
+proc default_g77_version { } {
+    global G77_UNDER_TEST
+
+    g77_init;
+
+    # ignore any arguments after the command
+    set compiler [lindex $G77_UNDER_TEST 0]
+
+    if ![is_remote host] {
+	set compiler_name [which $compiler];
+    } else {
+	set compiler_name $compiler;
+    }
+
+    # verify that the compiler exists
+    if { $compiler_name != 0 } then {
+        set options ""
+
+        lappend options "additional_flags=-v"
+        set tmp [g77_target_compile "" "" "none" $options]
+	regexp "g77 version\[^\n\]*" $tmp version
+	if { [info exists version] } then {
+	    clone_output "$compiler_name $version\n"
+	} else {
+	    clone_output "Couldn't determine version of $compiler_name: $tmp\n"
+	}
+    } else {
+	# compiler does not exist (this should have already been detected)
+	warning "$compiler does not exist"
+    }
+}
+
+#
+# Call g77_version. We do it this way so we can override it if needed.
+#
+proc g77_version { } {
+    default_g77_version;
+}
+
+#
+# g77_init -- called at the start of each .exp script.
+#
+# There currently isn't much to do, but always using it allows us to
+# make some enhancements without having to go back and rewrite the scripts.
+#
+
+set g77_initialized 0
+
+proc g77_init { args } {
+    global tmpdir
+    global libdir
+    global gluefile wrap_flags
+    global g77_initialized
+    global G77_UNDER_TEST
+    global TOOL_EXECUTABLE
+
+    if { $g77_initialized == 1 } { return; }
+
+    if ![info exists G77_UNDER_TEST] then {
+	if [info exists TOOL_EXECUTABLE] {
+	    set G77_UNDER_TEST $TOOL_EXECUTABLE;
+	} else {
+	    set G77_UNDER_TEST [find_g77]
+	}
+    }
+
+    if ![info exists tmpdir] then {
+	set tmpdir /tmp
+    }
+    if { [target_info needs_status_wrapper]!="" && ![info exists gluefile] } {
+	set gluefile ${tmpdir}/testglue.o;
+	set result [build_wrapper $gluefile];
+	if { $result != "" } {
+	    set gluefile [lindex $result 0];
+	    set wrap_flags [lindex $result 1];
+	} else {
+	    unset gluefile
+	}
+    }
+}
+
+proc g77_target_compile { source dest type options } {
+    global tmpdir;
+    global gluefile wrap_flags;
+    global G77_UNDER_TEST
+    global TOOL_OPTIONS
+
+    if { [target_info needs_status_wrapper]!="" && [info exists gluefile] } {
+	lappend options "libs=${gluefile}"
+	lappend options "ldflags=$wrap_flags"
+    }
+
+    if [target_info exists g77,stack_size] {
+	lappend options "additional_flags=-DSTACK_SIZE=[target_info g77,stack_size]"
+    }
+    if [target_info exists g77,no_trampolines] {
+	lappend options "additional_flags=-DNO_TRAMPOLINES"
+    }
+    if [target_info exists g77,no_label_values] {
+	lappend options "additional_flags=-DNO_LABEL_VALUES"
+    }
+    if [info exists TOOL_OPTIONS] {
+	lappend options "additional_flags=$TOOL_OPTIONS"
+    }
+    if [target_info exists g77,no_varargs] {
+	lappend options "additional_flags=-DNO_VARARGS"
+    }
+    if ![is_remote host] {
+      set gccpath "[get_multilibs]"
+      set libg2c_dir [lookfor_file ${gccpath} libf2c/libg2c.a]
+      if { $libg2c_dir != "" } {
+	set libg2c_link_flags "-L[file dirname ${libg2c_dir}]"
+	lappend options "additional_flags=${libg2c_link_flags}"
+      }
+    }
+    lappend options "compiler=$G77_UNDER_TEST"
+    return [target_compile $source $dest $type $options]
+}
+
+#
+# g77_pass -- utility to record a testcase passed
+#
+
+proc g77_pass { testcase cflags } {
+    if { "$cflags" == "" } {
+	pass "$testcase"
+    } else {
+	pass "$testcase, $cflags"
+    }
+}
+
+#
+# g77_fail -- utility to record a testcase failed
+#
+
+proc g77_fail { testcase cflags } {
+    if { "$cflags" == "" } {
+	fail "$testcase"
+    } else {
+	fail "$testcase, $cflags"
+    }
+}
+
+#
+# g77_finish -- called at the end of every .exp script that calls g77_init
+#
+# The purpose of this proc is to hide all quirks of the testing environment
+# from the testsuites.  It also exists to undo anything that g77_init did
+# (that needs undoing).
+#
+
+proc g77_finish { } {
+    # The testing harness apparently requires this.
+    global errorInfo;
+
+    if [info exists errorInfo] then {
+	unset errorInfo
+    }
+
+    # Might as well reset these (keeps our caller from wondering whether
+    # s/he has to or not).
+    global prms_id bug_id
+    set prms_id 0
+    set bug_id 0
+}
+
+proc g77_exit { } {
+    global gluefile;
+
+    if [info exists gluefile] {
+	file_on_build delete $gluefile;
+	unset gluefile;
+    }
+}
+    
+# If this is an older version of dejagnu (without runtest_file_p),
+# provide one and assume the old syntax: foo1.exp bar1.c foo2.exp bar2.c.
+# This can be deleted after next dejagnu release.
+
+if { [info procs runtest_file_p] == "" } then {
+    proc runtest_file_p { runtests testcase } {
+	if { $runtests != "" && [regexp "\[.\]\[cC\]" $runtests] } then {
+	    if { [lsearch $runtests [file tail $testcase]] >= 0 } then {
+		return 1
+	    } else {
+		return 0
+	    }
+	}
+	return 1
+    }
+}
+
+# Provide a definition of this if missing (delete after next dejagnu release).
+
+if { [info procs prune_warnings] == "" } then {
+    proc prune_warnings { text } {
+	return $text
+    }
+}
+
+# Utility used by mike-gcc.exp and c-torture.exp.
+# Check the compiler(/assembler/linker) output for text indicating that
+# the testcase should be marked as "unsupported".
+#
+# When dealing with a large number of tests, it's difficult to weed out the
+# ones that are too big for a particular cpu (eg: 16 bit with a small amount
+# of memory).  There are various ways to deal with this.  Here's one.
+# Fortunately, all of the cases where this is likely to happen will be using
+# gld so we can tell what the error text will look like.
+
+proc ${tool}_check_unsupported_p { output } {
+    if [regexp "(^|\n)\[^\n\]*: region \[^\n\]* is full" $output] {
+	return "memory full"
+    }
+    return ""
+}
+
+# Prune messages from g77 that aren't useful.
+
+proc prune_g77_output { text } {
+    #send_user "Before:$text\n"
+    regsub -all "(^|\n)\[^\n\]*: In (function|method) \[^\n\]*" $text "" text
+    regsub -all "(^|\n)\[^\n\]*: At top level:\[^\n\]*" $text "" text
+
+    # It would be nice to avoid passing anything to g77 that would cause it to
+    # issue these messages (since ignoring them seems like a hack on our part),
+    # but that's too difficult in the general case.  For example, sometimes
+    # you need to use -B to point g77 at crt0.o, but there are some targets
+    # that don't have crt0.o.
+    regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $text "" text
+    regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $text "" text
+
+    #send_user "After:$text\n"
+
+    return $text
+}
+
diff --git a/gcc/testsuite/lib/gcc-dg.exp b/gcc/testsuite/lib/gcc-dg.exp
new file mode 100644
index 00000000000..04cb8b798d1
--- /dev/null
+++ b/gcc/testsuite/lib/gcc-dg.exp
@@ -0,0 +1,84 @@
+#   Copyright (C) 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# Define gcc callbacks for dg.exp.
+
+load_lib dg.exp
+
+proc gcc-dg-test { prog do_what extra_tool_flags } {
+    # Set up the compiler flags, based on what we're going to do.
+
+    switch $do_what {
+	"preprocess" {
+	    set compile_type "preprocess"
+	    set output_file "[file rootname [file tail $prog]].i"
+	}
+	"compile" {
+	    set compile_type "assembly"
+	    set output_file "[file rootname [file tail $prog]].s"
+	}
+	"assemble" {
+	    set compile_type "object"
+	    set output_file "[file rootname [file tail $prog]].o"
+	}
+	"link" {
+	    set compile_type "executable"
+	    set output_file "a.out"
+	    # The following line is needed for targets like the i960 where
+	    # the default output file is b.out.  Sigh.
+	}
+	"run" {
+	    set compile_type "executable"
+	    # FIXME: "./" is to cope with "." not being in $PATH.
+	    # Should this be handled elsewhere?
+	    # YES.
+	    set output_file "./a.out"
+	    # This is the only place where we care if an executable was
+	    # created or not.  If it was, dg.exp will try to run it.
+	    remote_file build delete $output_file;
+	}
+	default {
+	    perror "$do_what: not a valid dg-do keyword"
+	    return ""
+	}
+    }
+    set options ""
+    if { $extra_tool_flags != "" } {
+	lappend options "additional_flags=$extra_tool_flags"
+    }
+
+    set comp_output [gcc_target_compile "$prog" "$output_file" "$compile_type" $options];
+
+    return [list $comp_output $output_file]
+}
+
+
+proc gcc-dg-prune { system text } {
+    set text [prune_gcc_output $text]
+
+    # If we see "region xxx is full" then the testcase is too big for ram.
+    # This is tricky to deal with in a large testsuite like c-torture so
+    # deal with it here.  Just mark the testcase as unsupported.
+    if [regexp "(^|\n)\[^\n\]*: region \[^\n\]* is full" $text] {
+	# The format here is important.  See dg.exp.
+	return "::unsupported::memory full"
+    }
+
+    return $text
+}
diff --git a/gcc/testsuite/lib/gcc.exp b/gcc/testsuite/lib/gcc.exp
new file mode 100644
index 00000000000..e9ad6782aef
--- /dev/null
+++ b/gcc/testsuite/lib/gcc.exp
@@ -0,0 +1,325 @@
+# Copyright (C) 1992, 1993, 1994, 1996, 1997, 1999 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# This file was written by Rob Savoye (rob@cygnus.com)
+# Currently maintained by Doug Evans (dje@cygnus.com)
+
+# This file is loaded by the tool init file (eg: unix.exp).  It provides
+# default definitions for gcc_start, etc. and other supporting cast members.
+
+# These globals are used by gcc_start if no compiler arguments are provided.
+# They are also used by the various testsuites to define the environment:
+# where to find stdio.h, libc.a, etc.
+
+# we want to use libgloss so we can get find_gcc.
+load_lib libgloss.exp
+
+#
+# GCC_UNDER_TEST is the compiler under test.
+#
+
+#
+# default_gcc_version -- extract and print the version number of the compiler
+#
+
+proc default_gcc_version { } {
+    global GCC_UNDER_TEST
+
+    gcc_init;
+
+    # ignore any arguments after the command
+    set compiler [lindex $GCC_UNDER_TEST 0]
+
+    if ![is_remote host] {
+	set compiler_name [which $compiler];
+    } else {
+	set compiler_name $compiler;
+    }
+
+    # verify that the compiler exists
+    if { $compiler_name != 0 } then {
+	set tmp [remote_exec host "$compiler -v"]
+	set status [lindex $tmp 0];
+	set output [lindex $tmp 1];
+	regexp "version.*$" $output version
+	if { $status == 0 && [info exists version] } then {
+	    clone_output "$compiler_name $version\n"
+	} else {
+	    clone_output "Couldn't determine version of $compiler_name: $output\n"
+	}
+    } else {
+	# compiler does not exist (this should have already been detected)
+	warning "$compiler does not exist"
+    }
+}
+
+#
+# Call gcc_version. We do it this way so we can override it if needed.
+#
+proc gcc_version { } {
+    default_gcc_version;
+}
+
+#
+# gcc_init -- called at the start of each .exp script.
+#
+# There currently isn't much to do, but always using it allows us to
+# make some enhancements without having to go back and rewrite the scripts.
+#
+
+set gcc_initialized 0
+
+proc gcc_init { args } {
+    global tmpdir
+    global libdir
+    global gluefile wrap_flags
+    global gcc_initialized
+    global GCC_UNDER_TEST
+    global TOOL_EXECUTABLE
+
+    if { $gcc_initialized == 1 } { return; }
+
+    if ![info exists GCC_UNDER_TEST] {
+	if [info exists TOOL_EXECUTABLE] {
+	    set GCC_UNDER_TEST $TOOL_EXECUTABLE;
+	} else {
+	    set GCC_UNDER_TEST "[find_gcc]"
+	}
+    }
+
+    if ![info exists tmpdir] then {
+	set tmpdir /tmp
+    }
+    if { [target_info needs_status_wrapper]!="" && ![info exists gluefile] } {
+	set gluefile ${tmpdir}/testglue.o;
+	set result [build_wrapper $gluefile];
+	if { $result != "" } {
+	    set gluefile [lindex $result 0];
+	    set wrap_flags [lindex $result 1];
+	} else {
+	    unset gluefile
+	}
+    }
+}
+
+proc gcc_target_compile { source dest type options } {
+    global tmpdir;
+    global gluefile wrap_flags;
+    global GCC_UNDER_TEST
+    global TOOL_OPTIONS
+
+    if { [target_info needs_status_wrapper]!="" && [info exists gluefile] } {
+	lappend options "libs=${gluefile}"
+	lappend options "ldflags=$wrap_flags"
+    }
+
+    if [target_info exists gcc,stack_size] {
+	lappend options "additional_flags=-DSTACK_SIZE=[target_info gcc,stack_size]"
+    }
+    if [target_info exists gcc,no_trampolines] {
+	lappend options "additional_flags=-DNO_TRAMPOLINES"
+    }
+    if [target_info exists gcc,no_label_values] {
+	lappend options "additional_flags=-DNO_LABEL_VALUES"
+    }
+    if [info exists TOOL_OPTIONS] {
+	lappend options "additional_flags=$TOOL_OPTIONS"
+    }
+    if [target_info exists gcc,no_varargs] {
+	lappend options "additional_flags=-DNO_VARARGS"
+    }
+    if [target_info exists gcc,timeout] {
+	lappend options "timeout=[target_info gcc,timeout]"
+    }
+    lappend options "compiler=$GCC_UNDER_TEST"
+    return [target_compile $source $dest $type $options]
+}
+
+
+# Reports pass/fail for a gcc compilation and returns true/false.
+proc gcc_check_compile {testcase option objname gcc_output} {
+
+    set fatal_signal "*cc: Internal compiler error: program*got fatal signal"
+ 
+    if [string match "$fatal_signal 6" $gcc_output] then {
+	gcc_fail $testcase "Got Signal 6, $option"
+	return 0
+    }
+
+    if [string match "$fatal_signal 11" $gcc_output] then {
+	gcc_fail $testcase "Got Signal 11, $option"
+	return 0
+    }
+
+    # We shouldn't get these because of -w, but just in case.
+    if [string match "*cc:*warning:*" $gcc_output] then {
+	warning "$testcase: (with warnings) $option"
+	send_log "$gcc_output\n"
+	unresolved "$testcase, $option"
+	return 0
+    }
+
+    set gcc_output [prune_warnings $gcc_output]
+
+    set unsupported_message [gcc_check_unsupported_p $gcc_output]
+    if { $unsupported_message != "" } {
+	unsupported "$testcase: $unsupported_message"
+	return 0
+    }
+
+    # remove any leftover LF/CR to make sure any output is legit
+    regsub -all -- "\[\r\n\]*" $gcc_output "" gcc_output
+
+    # If any message remains, we fail.
+    if ![string match "" $gcc_output] then {
+	gcc_fail $testcase $option
+	return 0
+    }
+
+    # fail if the desired object file doesn't exist.
+    # FIXME: there's no way of checking for existence on a remote host.
+    if {$objname != "" && ![is3way] && ![file exists $objname]} {
+	gcc_fail $testcase $option
+	return 0
+    }
+
+    gcc_pass $testcase $option
+    return 1
+}
+
+
+
+#
+# gcc_pass -- utility to record a testcase passed
+#
+
+proc gcc_pass { testcase cflags } {
+    if { "$cflags" == "" } {
+	pass "$testcase"
+    } else {
+	pass "$testcase, $cflags"
+    }
+}
+
+#
+# gcc_fail -- utility to record a testcase failed
+#
+
+proc gcc_fail { testcase cflags } {
+    if { "$cflags" == "" } {
+	fail "$testcase"
+    } else {
+	fail "$testcase, $cflags"
+    }
+}
+
+#
+# gcc_finish -- called at the end of every .exp script that calls gcc_init
+#
+# The purpose of this proc is to hide all quirks of the testing environment
+# from the testsuites.  It also exists to undo anything that gcc_init did
+# (that needs undoing).
+#
+
+proc gcc_finish { } {
+    # The testing harness apparently requires this.
+    global errorInfo;
+
+    if [info exists errorInfo] then {
+	unset errorInfo
+    }
+
+    # Might as well reset these (keeps our caller from wondering whether
+    # s/he has to or not).
+    global prms_id bug_id
+    set prms_id 0
+    set bug_id 0
+}
+
+proc gcc_exit { } {
+    global gluefile;
+
+    if [info exists gluefile] {
+	file_on_build delete $gluefile;
+	unset gluefile;
+    }
+}
+    
+# If this is an older version of dejagnu (without runtest_file_p),
+# provide one and assume the old syntax: foo1.exp bar1.c foo2.exp bar2.c.
+# This can be deleted after next dejagnu release.
+
+if { [info procs runtest_file_p] == "" } then {
+    proc runtest_file_p { runtests testcase } {
+	if { $runtests != "" && [regexp "\[.\]\[cC\]" $runtests] } then {
+	    if { [lsearch $runtests [file tail $testcase]] >= 0 } then {
+		return 1
+	    } else {
+		return 0
+	    }
+	}
+	return 1
+    }
+}
+
+# Provide a definition of this if missing (delete after next dejagnu release).
+
+if { [info procs prune_warnings] == "" } then {
+    proc prune_warnings { text } {
+	return $text
+    }
+}
+
+# Utility used by mike-gcc.exp and c-torture.exp.
+# Check the compiler(/assembler/linker) output for text indicating that
+# the testcase should be marked as "unsupported".
+#
+# When dealing with a large number of tests, it's difficult to weed out the
+# ones that are too big for a particular cpu (eg: 16 bit with a small amount
+# of memory).  There are various ways to deal with this.  Here's one.
+# Fortunately, all of the cases where this is likely to happen will be using
+# gld so we can tell what the error text will look like.
+
+proc ${tool}_check_unsupported_p { output } {
+    if [regexp "(^|\n)\[^\n\]*: region \[^\n\]* is full" $output] {
+	return "memory full"
+    }
+    return ""
+}
+
+# Prune messages from gcc that aren't useful.
+
+proc prune_gcc_output { text } {
+    #send_user "Before:$text\n"
+    regsub -all "(^|\n)\[^\n\]*: In (function|method) \[^\n\]*" $text "" text
+    regsub -all "(^|\n)\[^\n\]*: At top level:\[^\n\]*" $text "" text
+
+    # It would be nice to avoid passing anything to gcc that would cause it to
+    # issue these messages (since ignoring them seems like a hack on our part),
+    # but that's too difficult in the general case.  For example, sometimes
+    # you need to use -B to point gcc at crt0.o, but there are some targets
+    # that don't have crt0.o.
+    regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $text "" text
+    regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $text "" text
+
+    #send_user "After:$text\n"
+
+    return $text
+}
+
diff --git a/gcc/testsuite/lib/mike-g++.exp b/gcc/testsuite/lib/mike-g++.exp
new file mode 100644
index 00000000000..10a1d2bcbb9
--- /dev/null
+++ b/gcc/testsuite/lib/mike-g++.exp
@@ -0,0 +1,264 @@
+# Copyright (C) 1988, 90, 91, 92, 95, 96, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# This file was written by Mike Stump <mrs@cygnus.com>
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-g++@prep.ai.mit.edu
+
+#
+# mike_cleanup -- remove any files that are created by the testcase
+#
+proc mike_cleanup { src_code output_file assembly_file } {
+    remote_file build delete $output_file $assembly_file;
+}
+
+#
+# prebase -- sets up a Mike Stump (mrs@cygnus.com) style G++ test
+#
+proc prebase { } {
+    global compiler_output
+    global not_compiler_output
+    global compiler_result
+    global not_compiler_result
+    global program_output
+    global groups
+    global run 
+    global actions
+    global target_regexp
+
+    set compiler_output "^$"
+    set not_compiler_output ".*Internal compiler error.*"
+    set compiler_result ""
+    set not_compiler_result ""
+    set program_output ".*PASS.*"
+    set groups {}
+    set run no
+    set actions assemble
+    set target_regexp ".*"
+}
+
+#
+# run the test
+#
+proc postbase  { src_code run groups args } {
+    global verbose
+    global srcdir
+    global subdir
+    global not_compiler_output
+    global compiler_output
+    global compiler_result
+    global not_compiler_result
+    global program_output
+    global actions
+    global target_regexp
+    global host_triplet
+    global target_triplet
+    global tool
+    global tmpdir
+    global objdir
+    global base_dir
+
+    if ![regexp $target_regexp $target_triplet] {
+	unsupported $subdir/$src_code
+	return
+    }
+
+    if { [llength $args] > 0 } {
+	set comp_options [lindex $args 0];
+    } else {
+	set comp_options ""
+    }
+
+    set fail_message $subdir/$src_code
+    set pass_message $subdir/$src_code
+
+    if [info exists GROUP] {
+	if {[lsearch $groups $GROUP] == -1} {
+	    return
+	}
+    }
+
+    if [string match $run yes] {
+	set actions run
+    }
+
+    set output_file "$tmpdir/[file tail [file rootname $src_code]]"
+    set assembly_file "$output_file"
+    append assembly_file ".S"
+
+    set compile_type "none"
+
+    case $actions {
+	compile
+	{
+	    set compile_type "assembly";
+	    set output_file $assembly_file;
+	}
+	assemble
+	{
+	    set compile_type "object";
+	    append output_file ".o";
+	}
+	link
+	{
+	    set compile_type "executable";
+	    set output_file "$tmpdir/a.out";
+	}
+	run
+	{
+	    set compile_type "executable";
+	    set output_file "$tmpdir/a.out";
+	    set run yes;
+	}
+	default
+	{
+	    set output_file "";
+	    set compile_type "none";
+	}
+    }
+
+    set src_file "$srcdir/$subdir/$src_code"
+    set options ""
+
+    if { $comp_options != "" } {
+	lappend options "additional_flags=$comp_options"
+    }
+
+    if ![ishost "*-dos-*"] {
+	lappend options "libs=-lstdc++ -lg++"
+    } else {
+	lappend options "libs=-lstdcxx -lgxx"
+    }
+
+    set comp_output [g++_target_compile $src_file $output_file $compile_type $options]
+
+    set pass no
+
+    # Delete things like "ld.so warning" messages.
+    set comp_output [prune_warnings $comp_output]
+
+    if [regexp -- $not_compiler_output $comp_output] {
+	if { $verbose > 1 } {
+	    send_user "\nChecking:\n$not_compiler_output\nto make sure it does not match:\n$comp_output\nbut it does.\n\n"
+	} else {
+	    send_log "\nCompiler output:\n$comp_output\n\n"
+	}
+	fail $fail_message
+	# The framework doesn't like to see any error remnants,
+	# so remove them.
+	uplevel {
+	    if [info exists errorInfo] {
+		unset errorInfo
+	    }
+	}
+	mike_cleanup $src_code $output_file $assembly_file
+	return
+    }
+
+    # remove any leftover CRs.
+    regsub -all -- "\r" $comp_output "" comp_output
+
+    regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $comp_output "" comp_output
+    regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $comp_output "" comp_output
+
+    set unsupported_message [${tool}_check_unsupported_p $comp_output]
+    if { $unsupported_message != "" } {
+	unsupported "$subdir/$src_code: $unsupported_message"
+	mike_cleanup $src_code $output_file $assembly_file
+	return
+    }
+
+    if { $verbose > 1 } {
+	send_user "\nChecking:\n$compiler_output\nto see if it matches:\n$comp_output\n"
+    } else {
+	send_log "\nCompiler output:\n$comp_output\n\n"
+    }
+    if [regexp -- $compiler_output $comp_output] {
+	if { $verbose > 1 } {
+	    send_user "Yes, it matches.\n\n"
+	}
+	set pass yes
+	if [file exists [file rootname [file tail $src_code]].s] {
+	    set fd [open [file rootname [file tail $src_code]].s r]
+	    set dot_s [read $fd]
+	    close $fd
+	    if { $compiler_result != "" } {
+		verbose "Checking .s file for $compiler_result" 2
+		if [regexp -- $compiler_result $dot_s] {
+		    verbose "Yes, it matches." 2
+		} else {
+		    verbose "Nope, doesn't match." 2
+		    verbose $dot_s 4
+		    set pass no
+		}
+	    }
+	    if { $not_compiler_result != "" } {
+		verbose "Checking .s file for not $not_compiler_result" 2
+		if ![regexp -- $not_compiler_result $dot_s] {
+		    verbose "Nope, not found (that's good)." 2
+		} else {
+		    verbose "Uh oh, it was found." 2
+		    verbose $dot_s 4
+		    set pass no
+		}
+	    }
+	}
+	if [string match $run yes] {
+	    set result [g++_load $output_file]
+	    set status [lindex $result 0];
+	    set output [lindex $result 1];
+
+	    if { $status == -1 } {
+		mike_cleanup $src_code $output_file $assembly_file;
+		return;
+	    }
+	    if { $verbose > 1 } {
+		send_user "Checking:\n$program_output\nto see if it matches:\n$output\n\n"
+	    }
+	    if ![regexp -- $program_output $output] {
+		set pass no
+		if { $verbose > 1 } {
+		    send_user "Nope, does not match.\n\n"
+		}
+	    } else {
+		if { $verbose > 1 } {
+		    send_user "Yes, it matches.\n\n"
+		}
+	    }
+	}
+    } else {
+	if { $verbose > 1 } {
+	    send_user "Nope, does not match.\n\n"
+	}
+    }
+
+    if [string match $pass "yes"] {
+	pass $pass_message
+    } else {
+	fail $fail_message
+    }
+
+    # The framework doesn't like to see any error remnants,
+    # so remove them.
+    uplevel {
+	if [info exists errorInfo] {
+	    unset errorInfo
+	}
+    }
+
+    mike_cleanup $src_code $output_file $assembly_file
+}
diff --git a/gcc/testsuite/lib/mike-g77.exp b/gcc/testsuite/lib/mike-g77.exp
new file mode 100644
index 00000000000..a3e12d429f0
--- /dev/null
+++ b/gcc/testsuite/lib/mike-g77.exp
@@ -0,0 +1,262 @@
+# Copyright (C) 1988, 90, 91, 92, 95, 96, 97, 1998 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# This file was derived from mike-g++.exp written by Mike Stump <mrs@cygnus.com>
+
+# Please email any bugs, comments, and/or additions to this file to:
+# fortran@gnu.org
+
+#
+# mike_cleanup -- remove any files that are created by the testcase
+#
+proc mike_cleanup { src_code output_file assembly_file } {
+    remote_file build delete $output_file $assembly_file;
+}
+
+#
+# prebase -- sets up a Mike Stump (mrs@cygnus.com) style g77 test
+#
+proc prebase { } {
+    global compiler_output
+    global not_compiler_output
+    global compiler_result
+    global not_compiler_result
+    global program_output
+    global groups
+    global run 
+    global actions
+    global target_regexp
+
+    set compiler_output "^$"
+    set not_compiler_output ".*Internal compiler error.*"
+    set compiler_result ""
+    set not_compiler_result ""
+    set program_output ".*PASS.*"
+    set groups {}
+    set run no
+    set actions assemble
+    set target_regexp ".*"
+}
+
+#
+# run the test
+#
+proc postbase  { src_code run groups args } {
+    global verbose
+    global srcdir
+    global subdir
+    global not_compiler_output
+    global compiler_output
+    global compiler_result
+    global not_compiler_result
+    global program_output
+    global actions
+    global target_regexp
+    global host_triplet
+    global target_triplet
+    global tool
+    global tmpdir
+    global G77_UNDER_TEST
+    global GROUP
+
+    if ![info exists G77_UNDER_TEST] {
+	error "No compiler specified for testing."
+    }
+
+    if ![regexp $target_regexp $target_triplet] {
+	unsupported $subdir/$src_code
+	return
+    }
+
+    if { [llength $args] > 0 } {
+	set comp_options [lindex $args 0];
+    } else {
+	set comp_options ""
+    }
+
+    set fail_message $subdir/$src_code
+    set pass_message $subdir/$src_code
+
+    if [info exists GROUP] {
+	if {[lsearch $groups $GROUP] == -1} {
+	    return
+	}
+    }
+
+    if [string match $run yes] {
+	set actions run
+    }
+
+    set output_file "$tmpdir/[file tail [file rootname $src_code]]"
+    set assembly_file "$output_file"
+    append assembly_file ".S"
+
+    set compile_type "none"
+
+    case $actions {
+	compile
+	{
+	    set compile_type "assembly";
+	    set output_file $assembly_file;
+	}
+	assemble
+	{
+	    set compile_type "object";
+	    append output_file ".o";
+	}
+	link
+	{
+	    set compile_type "executable";
+	    set output_file "$tmpdir/a.out";
+	}
+	run
+	{
+	    set compile_type "executable";
+	    set output_file "$tmpdir/a.out";
+	    set run yes;
+	}
+	default
+	{
+	    set output_file "";
+	    set compile_type "none";
+	}
+    }
+
+    set src_file "$srcdir/$subdir/$src_code"
+    set options ""
+    lappend options "compiler=$G77_UNDER_TEST"
+
+    if { $comp_options != "" } {
+	lappend options "additional_flags=$comp_options"
+    }
+
+    set comp_output [g77_target_compile $src_file $output_file $compile_type $options];
+
+    set pass no
+
+    # Delete things like "ld.so warning" messages.
+    set comp_output [prune_warnings $comp_output]
+
+    if [regexp -- $not_compiler_output $comp_output] {
+	if { $verbose > 1 } {
+	    send_user "\nChecking:\n$not_compiler_output\nto make sure it does not match:\n$comp_output\nbut it does.\n\n"
+	} else {
+	    send_log "\nCompiler output:\n$comp_output\n\n"
+	}
+	fail $fail_message
+	# The framework doesn't like to see any error remnants,
+	# so remove them.
+	uplevel {
+	    if [info exists errorInfo] {
+		unset errorInfo
+	    }
+	}
+	mike_cleanup $src_code $output_file $assembly_file
+	return
+    }
+
+    # remove any leftover CRs.
+    regsub -all -- "\r" $comp_output "" comp_output
+
+    regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $comp_output "" comp_output
+    regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $comp_output "" comp_output
+
+    set unsupported_message [${tool}_check_unsupported_p $comp_output]
+    if { $unsupported_message != "" } {
+	unsupported "$subdir/$src_code: $unsupported_message"
+	mike_cleanup $src_code $output_file $assembly_file
+	return
+    }
+
+    if { $verbose > 1 } {
+	send_user "\nChecking:\n$compiler_output\nto see if it matches:\n$comp_output\n"
+    } else {
+	send_log "\nCompiler output:\n$comp_output\n\n"
+    }
+    if [regexp -- $compiler_output $comp_output] {
+	if { $verbose > 1 } {
+	    send_user "Yes, it matches.\n\n"
+	}
+	set pass yes
+	if [file exists [file rootname [file tail $src_code]].s] {
+	    set fd [open [file rootname [file tail $src_code]].s r]
+	    set dot_s [read $fd]
+	    close $fd
+	    if { $compiler_result != "" } {
+		verbose "Checking .s file for $compiler_result" 2
+		if [regexp -- $compiler_result $dot_s] {
+		    verbose "Yes, it matches." 2
+		} else {
+		    verbose "Nope, doesn't match." 2
+		    verbose $dot_s 4
+		    set pass no
+		}
+	    }
+	    if { $not_compiler_result != "" } {
+		verbose "Checking .s file for not $not_compiler_result" 2
+		if ![regexp -- $not_compiler_result $dot_s] {
+		    verbose "Nope, not found (that's good)." 2
+		} else {
+		    verbose "Uh oh, it was found." 2
+		    verbose $dot_s 4
+		    set pass no
+		}
+	    }
+	}
+	if [string match $run yes] {
+	    set result [g77_load $output_file]
+	    set status [lindex $result 0];
+	    set output [lindex $result 1];
+	    if { $status == -1 } {
+		mike_cleanup $src_code $output_file $assembly_file;
+		return;
+	    }
+	    if { $verbose > 1 } {
+		send_user "Checking:\n$program_output\nto see if it matches:\n$output\n\n"
+	    }
+	    if ![regexp -- $program_output $output] {
+		set pass no
+		if { $verbose > 1 } {
+		    send_user "Nope, does not match.\n\n"
+		}
+	    } else {
+		if { $verbose > 1 } {
+		    send_user "Yes, it matches.\n\n"
+		}
+	    }
+	}
+    } else {
+	if { $verbose > 1 } {
+	    send_user "Nope, does not match.\n\n"
+	}
+    }
+
+    if [string match $pass "yes"] {
+	pass $pass_message
+    } else {
+	fail $fail_message
+    }
+
+    # The framework doesn't like to see any error remnants,
+    # so remove them.
+    uplevel {
+	if [info exists errorInfo] {
+	    unset errorInfo
+	}
+    }
+
+    mike_cleanup $src_code $output_file $assembly_file
+}
diff --git a/gcc/testsuite/lib/mike-gcc.exp b/gcc/testsuite/lib/mike-gcc.exp
new file mode 100644
index 00000000000..f9c766a9026
--- /dev/null
+++ b/gcc/testsuite/lib/mike-gcc.exp
@@ -0,0 +1,262 @@
+# Copyright (C) 1988, 90, 91, 92, 95, 96, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# This file was derived from mike-g++.exp written by Mike Stump <mrs@cygnus.com>
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+#
+# mike_cleanup -- remove any files that are created by the testcase
+#
+proc mike_cleanup { src_code output_file assembly_file } {
+    remote_file build delete $output_file $assembly_file;
+}
+
+#
+# prebase -- sets up a Mike Stump (mrs@cygnus.com) style gcc test
+#
+proc prebase { } {
+    global compiler_output
+    global not_compiler_output
+    global compiler_result
+    global not_compiler_result
+    global program_output
+    global groups
+    global run 
+    global actions
+    global target_regexp
+
+    set compiler_output "^$"
+    set not_compiler_output ".*Internal compiler error.*"
+    set compiler_result ""
+    set not_compiler_result ""
+    set program_output ".*PASS.*"
+    set groups {}
+    set run no
+    set actions assemble
+    set target_regexp ".*"
+}
+
+#
+# run the test
+#
+proc postbase  { src_code run groups args } {
+    global verbose
+    global srcdir
+    global subdir
+    global not_compiler_output
+    global compiler_output
+    global compiler_result
+    global not_compiler_result
+    global program_output
+    global actions
+    global target_regexp
+    global host_triplet
+    global target_triplet
+    global tool
+    global tmpdir
+    global GCC_UNDER_TEST
+    global GROUP
+
+    if ![info exists GCC_UNDER_TEST] {
+	error "No compiler specified for testing."
+    }
+
+    if ![regexp $target_regexp $target_triplet] {
+	unsupported $subdir/$src_code
+	return
+    }
+
+    if { [llength $args] > 0 } {
+	set comp_options [lindex $args 0];
+    } else {
+	set comp_options ""
+    }
+
+    set fail_message $subdir/$src_code
+    set pass_message $subdir/$src_code
+
+    if [info exists GROUP] {
+	if {[lsearch $groups $GROUP] == -1} {
+	    return
+	}
+    }
+
+    if [string match $run yes] {
+	set actions run
+    }
+
+    set output_file "$tmpdir/[file tail [file rootname $src_code]]"
+    set assembly_file "$output_file"
+    append assembly_file ".S"
+
+    set compile_type "none"
+
+    case $actions {
+	compile
+	{
+	    set compile_type "assembly";
+	    set output_file $assembly_file;
+	}
+	assemble
+	{
+	    set compile_type "object";
+	    append output_file ".o";
+	}
+	link
+	{
+	    set compile_type "executable";
+	    set output_file "$tmpdir/a.out";
+	}
+	run
+	{
+	    set compile_type "executable";
+	    set output_file "$tmpdir/a.out";
+	    set run yes;
+	}
+	default
+	{
+	    set output_file "";
+	    set compile_type "none";
+	}
+    }
+
+    set src_file "$srcdir/$subdir/$src_code"
+    set options ""
+    lappend options "compiler=$GCC_UNDER_TEST"
+
+    if { $comp_options != "" } {
+	lappend options "additional_flags=$comp_options"
+    }
+
+    set comp_output [gcc_target_compile $src_file $output_file $compile_type $options];
+
+    set pass no
+
+    # Delete things like "ld.so warning" messages.
+    set comp_output [prune_warnings $comp_output]
+
+    if [regexp -- $not_compiler_output $comp_output] {
+	if { $verbose > 1 } {
+	    send_user "\nChecking:\n$not_compiler_output\nto make sure it does not match:\n$comp_output\nbut it does.\n\n"
+	} else {
+	    send_log "\nCompiler output:\n$comp_output\n\n"
+	}
+	fail $fail_message
+	# The framework doesn't like to see any error remnants,
+	# so remove them.
+	uplevel {
+	    if [info exists errorInfo] {
+		unset errorInfo
+	    }
+	}
+	mike_cleanup $src_code $output_file $assembly_file
+	return
+    }
+
+    # remove any leftover CRs.
+    regsub -all -- "\r" $comp_output "" comp_output
+
+    regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $comp_output "" comp_output
+    regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $comp_output "" comp_output
+
+    set unsupported_message [${tool}_check_unsupported_p $comp_output]
+    if { $unsupported_message != "" } {
+	unsupported "$subdir/$src_code: $unsupported_message"
+	mike_cleanup $src_code $output_file $assembly_file
+	return
+    }
+
+    if { $verbose > 1 } {
+	send_user "\nChecking:\n$compiler_output\nto see if it matches:\n$comp_output\n"
+    } else {
+	send_log "\nCompiler output:\n$comp_output\n\n"
+    }
+    if [regexp -- $compiler_output $comp_output] {
+	if { $verbose > 1 } {
+	    send_user "Yes, it matches.\n\n"
+	}
+	set pass yes
+	if [file exists [file rootname [file tail $src_code]].s] {
+	    set fd [open [file rootname [file tail $src_code]].s r]
+	    set dot_s [read $fd]
+	    close $fd
+	    if { $compiler_result != "" } {
+		verbose "Checking .s file for $compiler_result" 2
+		if [regexp -- $compiler_result $dot_s] {
+		    verbose "Yes, it matches." 2
+		} else {
+		    verbose "Nope, doesn't match." 2
+		    verbose $dot_s 4
+		    set pass no
+		}
+	    }
+	    if { $not_compiler_result != "" } {
+		verbose "Checking .s file for not $not_compiler_result" 2
+		if ![regexp -- $not_compiler_result $dot_s] {
+		    verbose "Nope, not found (that's good)." 2
+		} else {
+		    verbose "Uh oh, it was found." 2
+		    verbose $dot_s 4
+		    set pass no
+		}
+	    }
+	}
+	if [string match $run yes] {
+	    set result [gcc_load $output_file]
+	    set status [lindex $result 0];
+	    set output [lindex $result 1];
+	    if { $status == -1 } {
+		mike_cleanup $src_code $output_file $assembly_file;
+		return;
+	    }
+	    if { $verbose > 1 } {
+		send_user "Checking:\n$program_output\nto see if it matches:\n$output\n\n"
+	    }
+	    if ![regexp -- $program_output $output] {
+		set pass no
+		if { $verbose > 1 } {
+		    send_user "Nope, does not match.\n\n"
+		}
+	    } else {
+		if { $verbose > 1 } {
+		    send_user "Yes, it matches.\n\n"
+		}
+	    }
+	}
+    } else {
+	if { $verbose > 1 } {
+	    send_user "Nope, does not match.\n\n"
+	}
+    }
+
+    if [string match $pass "yes"] {
+	pass $pass_message
+    } else {
+	fail $fail_message
+    }
+
+    # The framework doesn't like to see any error remnants,
+    # so remove them.
+    uplevel {
+	if [info exists errorInfo] {
+	    unset errorInfo
+	}
+    }
+
+    mike_cleanup $src_code $output_file $assembly_file
+}
diff --git a/gcc/testsuite/lib/objc-torture.exp b/gcc/testsuite/lib/objc-torture.exp
new file mode 100644
index 00000000000..a3cc7d6fe9f
--- /dev/null
+++ b/gcc/testsuite/lib/objc-torture.exp
@@ -0,0 +1,316 @@
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-dejagnu.prep.ai.mit.edu
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+
+# The default option list can be overridden by
+# TORTURE_OPTIONS="{ { list1 } ... { listN } }"
+
+if ![info exists TORTURE_OPTIONS] {
+    # FIXME: We should test -g at least once.
+    set TORTURE_OPTIONS [list { -O }]
+}
+
+
+# Split TORTURE_OPTIONS into two choices: one for testcases with loops and
+# one for testcases without loops.
+
+set torture_with_loops $TORTURE_OPTIONS
+set torture_without_loops ""
+foreach option $TORTURE_OPTIONS {
+    if ![string match "*loop*" $option] {
+	lappend torture_without_loops $option
+    }
+}
+
+#
+# objc-torture-compile -- runs the Tege C-torture test
+#
+# SRC is the full pathname of the testcase.
+# OPTION is the specific compiler flag we're testing (eg: -O2).
+#
+proc objc-torture-compile { src option } {
+    global output
+    global srcdir tmpdir
+    global host_triplet
+
+    set output "$tmpdir/[file tail [file rootname $src]].o"
+
+    regsub "^$srcdir/?" $src "" testcase
+    # If we couldn't rip $srcdir out of `src' then just do the best we can.
+    # The point is to reduce the unnecessary noise in the logs.  Don't strip
+    # out too much because different testcases with the same name can confuse
+    # `test-tool'.
+    if [string match "/*" $testcase] {
+	set testcase "[file tail [file dirname $src]]/[file tail $src]"
+    }
+
+    verbose "Testing $testcase, $option" 1
+
+    # Run the compiler and analyze the results.
+    set options ""
+    lappend options "additional_flags=-w $option"
+
+    set comp_output [objc_target_compile "$src" "$output" object $options];
+    
+    # Set a few common compiler messages.
+    set fatal_signal "*Obj-C*: Internal compiler error: program*got fatal signal"
+ 
+    if [string match "$fatal_signal 6" $comp_output] then {
+	objc_fail $testcase "Got Signal 6, $option"
+	remote_file build delete $output
+	return
+    }
+
+    if [string match "$fatal_signal 11" $comp_output] then {
+	objc_fail $testcase "Got Signal 11, $option"
+	remote_file build delete $output
+	return
+    }
+
+    # We shouldn't get these because of -w, but just in case.
+    if [string match "*Obj-C*:*warning:*" $comp_output] then {
+	warning "$testcase: (with warnings) $option"
+	send_log "$comp_output\n"
+	unresolved "$testcase, $option"
+	remote_file build delete $output
+	return
+    }
+
+    set comp_output [prune_warnings $comp_output]
+
+    set unsupported_message [objc_check_unsupported_p $comp_output]
+    if { $unsupported_message != "" } {
+	unsupported "$testcase: $unsupported_message"
+	remote_file build delete $output
+	return
+    }
+
+    # remove any leftover LF/CR to make sure any output is legit
+    regsub -all -- "\[\r\n\]*" $comp_output "" comp_output
+    # If any message remains, we fail.
+    if ![string match "" $comp_output] then {
+	objc_fail $testcase $option
+	remote_file build delete $output
+	return
+    }
+
+    objc_pass $testcase $option
+    remote_file build delete $output
+}
+
+#
+# objc-torture-execute -- utility to compile and execute a testcase
+#
+# SRC is the full pathname of the testcase.
+#
+# If the testcase has an associated .cexp file, we source that to run the
+# test instead.  We use .cexp instead of .exp so that the testcase is still
+# controlled by the main .exp driver (this is useful when one wants to only
+# run the compile.exp tests for example - one need only pass compile.exp to
+# dejagnu, and not compile.exp, foo1.exp, foo2.exp, etc.).
+#
+proc objc-torture-execute { src } {
+    global tmpdir tool srcdir output 
+
+    # Check for alternate driver.
+    if [file exists [file rootname $src].cexp] {
+	verbose "Using alternate driver [file rootname [file tail $src]].cexp" 2
+	set done_p 0
+	catch "set done_p \[source [file rootname $src].cexp\]"
+	if { $done_p } {
+	    return
+	}
+    }
+   
+    # Look for a loop within the source code - if we don't find one,
+    # don't pass -funroll[-all]-loops.
+    global torture_with_loops torture_without_loops
+    if [expr [search_for $src "do *\[0-9\]"]+[search_for $src "end *do"]] then {
+	set option_list $torture_with_loops
+    } else {
+	set option_list $torture_without_loops
+    }
+
+    set executable $tmpdir/[file tail [file rootname $src].x]
+
+    regsub "^$srcdir/?" $src "" testcase
+    # If we couldn't rip $srcdir out of `src' then just do the best we can.
+    # The point is to reduce the unnecessary noise in the logs.  Don't strip
+    # out too much because different testcases with the same name can confuse
+    # `test-tool'.
+    if [string match "/*" $testcase] {
+	set testcase "[file tail [file dirname $src]]/[file tail $src]"
+    }
+
+    foreach option $option_list {
+	# torture_{compile,execute}_xfail are set by the .cexp script
+	# (if present)
+	if [info exists torture_compile_xfail] {
+	    setup_xfail $torture_compile_xfail
+	}
+	remote_file build delete $executable
+	verbose "Testing $testcase, $option" 1
+
+	set options ""
+	lappend options "additional_flags=-w $option -I${srcdir}/../../libobjc"
+	set comp_output [objc_target_compile "$src" "$executable" executable $options];
+
+	# Set a few common compiler messages.
+	set fatal_signal "*Obj-C*: Internal compiler error: program*got fatal signal"
+	
+	if [string match "$fatal_signal 6" $comp_output] then {
+	    objc_fail $testcase "Got Signal 6, $option"
+	    remote_file build delete $executable
+	    continue
+	}
+	
+	if [string match "$fatal_signal 11" $comp_output] then {
+	    objc_fail $testcase "Got Signal 11, $option"
+	    remote_file build delete $executable
+	    continue
+	}
+	
+	# We shouldn't get these because of -w, but just in case.
+	if [string match "*Obj-C*:*warning:*" $comp_output] then {
+	    warning "$testcase: (with warnings) $option"
+	    send_log "$comp_output\n"
+	    unresolved "$testcase, $option"
+	    remote_file build delete $executable
+	    continue
+	}
+	
+	set comp_output [prune_warnings $comp_output]
+	
+	set unsupported_message [objc_check_unsupported_p $comp_output]
+
+	if { $unsupported_message != "" } {
+	    unsupported "$testcase: $unsupported_message"
+	    continue
+	} elseif ![file exists $executable] {
+	    if ![is3way] {
+		fail "$testcase compilation, $option"
+		untested "$testcase execution, $option"
+		continue
+	    } else {
+		# FIXME: since we can't test for the existance of a remote
+		# file without short of doing an remote file list, we assume
+		# that since we got no output, it must have compiled.
+		pass "$testcase compilation, $option"		
+	    }
+	} else {
+	    pass "$testcase compilation, $option"
+	}
+
+	# See if this source file uses "long long" types, if it does, and
+	# no_long_long is set, skip execution of the test.
+	if [target_info exists no_long_long] then {
+	    if [expr [search_for $src "integer\*8"]] then {
+		untested "$testcase execution, $option"
+		continue
+	    }
+	}
+
+	if [info exists torture_execute_xfail] {
+	    setup_xfail $torture_execute_xfail
+	}
+	
+	set result [objc_load "$executable" "" ""]
+	set status [lindex $result 0];
+	set output [lindex $result 1];
+        if { $status == "pass" } {
+	    remote_file build delete $executable
+        }
+	$status "$testcase execution, $option"
+    }
+}
+
+#
+# search_for -- looks for a string match in a file
+#
+proc search_for { file pattern } {
+    set fd [open $file r]
+    while { [gets $fd cur_line]>=0 } {
+	set lower [string tolower $cur_line]
+	if [regexp "$pattern" $lower] then {
+	    close $fd
+	    return 1
+	}
+    }
+    close $fd
+    return 0
+}
+
+#
+# objc-torture -- the objc-torture testcase source file processor
+#
+# This runs compilation only tests (no execute tests).
+# SRC is the full pathname of the testcase, or just a file name in which case
+# we prepend $srcdir/$subdir.
+#
+# If the testcase has an associated .cexp file, we source that to run the
+# test instead.  We use .cexp instead of .exp so that the testcase is still
+# controlled by the main .exp driver (this is useful when one wants to only
+# run the compile.exp tests for example - one need only pass compile.exp to
+# dejagnu, and not compile.exp, foo1.exp, foo2.exp, etc.).
+#
+proc objc-torture { args } {
+    global srcdir subdir
+
+    set src [lindex $args 0];
+    if { [llength $args] > 1 } {
+	set options [lindex $args 1];
+    } else {
+	set options ""
+    }
+
+    # Prepend $srdir/$subdir if missing.
+    if ![string match "*/*" $src] {
+	set src "$srcdir/$subdir/$src"
+    }
+
+    # Check for alternate driver.
+    if [file exists [file rootname $src].cexp] {
+	verbose "Using alternate driver [file rootname [file tail $src]].cexp" 2
+	set done_p 0
+	catch "set done_p \[source [file rootname $src].cexp\]"
+	if { $done_p } {
+	    return
+	}
+    }
+   
+    # Look for a loop within the source code - if we don't find one,
+    # don't pass -funroll[-all]-loops.
+    global torture_with_loops torture_without_loops
+    if [expr [search_for $src "do *\[0-9\]"]+[search_for $src "end *do"]] then {
+	set option_list $torture_with_loops
+    } else {
+	set option_list $torture_without_loops
+    }
+
+    # loop through all the options
+    foreach option $option_list {
+	# torture_compile_xfail is set by the .cexp script (if present)
+	if [info exists torture_compile_xfail] {
+	    setup_xfail $torture_compile_xfail
+	}
+
+	objc-torture-compile $src "$option $options"
+    }
+}
diff --git a/gcc/testsuite/lib/objc.exp b/gcc/testsuite/lib/objc.exp
new file mode 100644
index 00000000000..d67ef04d72e
--- /dev/null
+++ b/gcc/testsuite/lib/objc.exp
@@ -0,0 +1,269 @@
+# Copyright (C) 1992, 1993, 1994, 1996, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# This file was written by Rob Savoye (rob@cygnus.com)
+# Currently maintained by Doug Evans (dje@cygnus.com)
+
+# This file is loaded by the tool init file (eg: unix.exp).  It provides
+# default definitions for objc_start, etc. and other supporting cast members.
+
+# These globals are used by objc_start if no compiler arguments are provided.
+# They are also used by the various testsuites to define the environment:
+# where to find stdio.h, libc.a, etc.
+
+#
+# OBJC_UNDER_TEST is the compiler under test.
+#
+
+#
+# default_objc_version -- extract and print the version number of the compiler
+#
+
+proc default_objc_version { } {
+    global OBJC_UNDER_TEST
+
+    objc_init;
+
+    # ignore any arguments after the command
+    set compiler [lindex $OBJC_UNDER_TEST 0]
+
+    if ![is_remote host] {
+	set compiler_name [which $compiler];
+    } else {
+	set compiler_name $compiler;
+    }
+
+    # verify that the compiler exists
+    if { $compiler_name != 0 } then {
+	set tmp [remote_exec host "$compiler -v"]
+	set status [lindex $tmp 0];
+	set output [lindex $tmp 1];
+	regexp "version.*$" $output version
+	if { $status == 0 && [info exists version] } then {
+	    clone_output "$compiler_name $version\n"
+	} else {
+	    clone_output "Couldn't determine version of $compiler_name: $output\n"
+	}
+    } else {
+	# compiler does not exist (this should have already been detected)
+	warning "$compiler does not exist"
+    }
+}
+
+#
+# Call objc_version. We do it this way so we can override it if needed.
+#
+proc objc_version { } {
+    default_objc_version;
+}
+
+#
+# objc_init -- called at the start of each .exp script.
+#
+# There currently isn't much to do, but always using it allows us to
+# make some enhancements without having to go back and rewrite the scripts.
+#
+
+set objc_initialized 0
+
+proc objc_init { args } {
+    global tmpdir
+    global libdir
+    global gluefile wrap_flags
+    global objc_initialized
+    global OBJC_UNDER_TEST
+    global TOOL_EXECUTABLE
+
+    if { $objc_initialized == 1 } { return; }
+
+    if ![info exists OBJC_UNDER_TEST] then {
+	if [info exists TOOL_EXECUTABLE] {
+	    set OBJC_UNDER_TEST $TOOL_EXECUTABLE;
+	} else {
+	    set OBJC_UNDER_TEST [find_gcc]
+	}
+    }
+
+    if ![info exists tmpdir] then {
+	set tmpdir /tmp
+    }
+    if { [target_info needs_status_wrapper]!="" && ![info exists gluefile] } {
+	set gluefile ${tmpdir}/testglue.o;
+	set result [build_wrapper $gluefile];
+	if { $result != "" } {
+	    set gluefile [lindex $result 0];
+	    set wrap_flags [lindex $result 1];
+	} else {
+	    unset gluefile
+	}
+    }
+}
+
+proc objc_target_compile { source dest type options } {
+    global tmpdir;
+    global gluefile wrap_flags;
+    global OBJC_UNDER_TEST
+    global TOOL_OPTIONS
+
+    lappend options "libs=-lobjc"
+    if { [target_info needs_status_wrapper]!="" && [info exists gluefile] } {
+	lappend options "libs=${gluefile}"
+	lappend options "ldflags=$wrap_flags"
+    }
+
+    if [target_info exists objc,stack_size] {
+	lappend options "additional_flags=-DSTACK_SIZE=[target_info objc,stack_size]"
+    }
+    if [target_info exists objc,no_trampolines] {
+	lappend options "additional_flags=-DNO_TRAMPOLINES"
+    }
+    if [target_info exists objc,no_label_values] {
+	lappend options "additional_flags=-DNO_LABEL_VALUES"
+    }
+    if [info exists TOOL_OPTIONS] {
+	lappend options "additional_flags=$TOOL_OPTIONS"
+    }
+    if [target_info exists objc,no_varargs] {
+	lappend options "additional_flags=-DNO_VARARGS"
+    }
+    set objcpath "[get_multilibs]"
+    set libobjc_dir [lookfor_file ${objcpath} libobjc/libobjc.a]
+    if { $libobjc_dir != "" } {
+	set objc_link_flags "-L[file dirname ${libobjc_dir}]"
+	lappend options "additional_flags=${objc_link_flags}"
+    }
+    lappend options "compiler=$OBJC_UNDER_TEST"
+    return [target_compile $source $dest $type $options]
+}
+
+#
+# objc_pass -- utility to record a testcase passed
+#
+
+proc objc_pass { testcase cflags } {
+    if { "$cflags" == "" } {
+	pass "$testcase"
+    } else {
+	pass "$testcase, $cflags"
+    }
+}
+
+#
+# objc_fail -- utility to record a testcase failed
+#
+
+proc objc_fail { testcase cflags } {
+    if { "$cflags" == "" } {
+	fail "$testcase"
+    } else {
+	fail "$testcase, $cflags"
+    }
+}
+
+#
+# objc_finish -- called at the end of every .exp script that calls objc_init
+#
+# The purpose of this proc is to hide all quirks of the testing environment
+# from the testsuites.  It also exists to undo anything that objc_init did
+# (that needs undoing).
+#
+
+proc objc_finish { } {
+    # The testing harness apparently requires this.
+    global errorInfo;
+
+    if [info exists errorInfo] then {
+	unset errorInfo
+    }
+
+    # Might as well reset these (keeps our caller from wondering whether
+    # s/he has to or not).
+    global prms_id bug_id
+    set prms_id 0
+    set bug_id 0
+}
+
+proc objc_exit { } {
+    global gluefile;
+
+    if [info exists gluefile] {
+	file_on_build delete $gluefile;
+	unset gluefile;
+    }
+}
+    
+# If this is an older version of dejagnu (without runtest_file_p),
+# provide one and assume the old syntax: foo1.exp bar1.c foo2.exp bar2.c.
+# This can be deleted after next dejagnu release.
+
+if { [info procs runtest_file_p] == "" } then {
+    proc runtest_file_p { runtests testcase } {
+	if { $runtests != "" && [regexp "\[.\]\[cC\]" $runtests] } then {
+	    if { [lsearch $runtests [file tail $testcase]] >= 0 } then {
+		return 1
+	    } else {
+		return 0
+	    }
+	}
+	return 1
+    }
+}
+
+# Provide a definition of this if missing (delete after next dejagnu release).
+
+if { [info procs prune_warnings] == "" } then {
+    proc prune_warnings { text } {
+	return $text
+    }
+}
+
+# Utility used by mike-gcc.exp and c-torture.exp.
+# Check the compiler(/assembler/linker) output for text indicating that
+# the testcase should be marked as "unsupported".
+#
+# When dealing with a large number of tests, it's difficult to weed out the
+# ones that are too big for a particular cpu (eg: 16 bit with a small amount
+# of memory).  There are various ways to deal with this.  Here's one.
+# Fortunately, all of the cases where this is likely to happen will be using
+# gld so we can tell what the error text will look like.
+
+proc ${tool}_check_unsupported_p { output } {
+    if [regexp "(^|\n)\[^\n\]*: region \[^\n\]* is full" $output] {
+	return "memory full"
+    }
+    return ""
+}
+
+# Prune messages from objc that aren't useful.
+
+proc prune_objc_output { text } {
+    #send_user "Before:$text\n"
+    regsub -all "(^|\n)\[^\n\]*: In (function|method) \[^\n\]*" $text "" text
+    regsub -all "(^|\n)\[^\n\]*: At top level:\[^\n\]*" $text "" text
+
+    # It would be nice to avoid passing anything to objc that would cause it to
+    # issue these messages (since ignoring them seems like a hack on our part),
+    # but that's too difficult in the general case.  For example, sometimes
+    # you need to use -B to point objc at crt0.o, but there are some targets
+    # that don't have crt0.o.
+    regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $text "" text
+    regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $text "" text
+
+    #send_user "After:$text\n"
+
+    return $text
+}
+
diff --git a/gcc/testsuite/lib/old-dejagnu.exp b/gcc/testsuite/lib/old-dejagnu.exp
new file mode 100644
index 00000000000..bfa29b0643c
--- /dev/null
+++ b/gcc/testsuite/lib/old-dejagnu.exp
@@ -0,0 +1,585 @@
+# Copyright (C) 1988, 90, 91, 92, 1994, 1996, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-g++@prep.ai.mit.edu
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+# With modifications by Mike Stump <mrs@cygnus.com>.
+
+# These tests come from the original DejaGnu test suite 
+# developed at Cygnus Support. If this isn't deja gnu, I
+# don't know what is.
+#
+# Language independence is achieved by:
+#
+# 1) Using global $tool to indicate the language (eg: gcc, g++, etc.).
+#    This should only be used to look up other objects.  We don't want to
+#    have to add code for each new language that is supported.  If this is
+#    done right, no code needs to be added here for each new language.
+#
+# 2) Passing compiler options in as arguments.
+#
+# We require a bit of smarts in our caller to isolate us from the vagaries of
+# each language.  See old-deja.exp for the g++ example.
+
+# Useful subroutines.
+
+# process-option -- Look for and process a test harness option in the testcase.
+#
+# PROG is the pathname of the testcase.
+# OPTION is the string to look for.
+# MESSAGE is what to print if $verbose > 1.
+# FLAG_NAME is one of ERROR, WARNING, etc.
+# PATTERN is ???
+
+proc process-option { prog option message flag_name pattern } {
+    global verbose
+
+    set result ""
+
+    set tmp [grep $prog "$option.*" line]
+    if ![string match "" $tmp] then {
+	foreach i $tmp {
+	    #send_user "Found: $i\n"
+	    set xfail_test 0
+	    set triplet_match 0
+	    regsub "\\*/$" [string trim $i] "" i
+	    if [regexp "LINE +\[0-9\]+" $i xopt] then {
+		regsub "LINE" $xopt "" xopt;
+		regsub "LINE +\[0-9\]+" $i "" i
+		set i [lreplace $i 0 0 [expr "${xopt}-0"]];
+	    }
+	    if [regexp "XFAIL( +\[^ \]+-\[^ \]+-\[^ \]+)*" $i xopt] then {
+		set xfail_test 1
+		regsub "XFAIL( +\[^ \]+-\[^ \]+-\[^ \]+)*" $i "" i
+		regsub "XFAIL" $xopt "" xopt
+		if ![string match "" [string trim $xopt]] then {
+		    foreach triplet $xopt {
+			if [istarget $triplet] {
+			    set triplet_match 1;
+			    break;
+			}
+		    }
+		} else {
+		    set triplet_match 1
+		}
+	    }
+	    set compos [expr [llength $option] + 1] ;# Start of comment, if any
+	    if { $xfail_test && $triplet_match } then {
+		lappend result [list [lindex $i 0] "X$flag_name" [lrange $i $compos end] "$pattern"]
+	    } else {
+		lappend result [list [lindex $i 0] "$flag_name" [lrange $i $compos end] "$pattern"]
+	    }
+	    if { $verbose > 1 } then {
+		if [string match "" [lrange $i $compos end]] then {
+		    send_user "Found $message for line [lindex $i 0]\n"
+		} else {
+		    send_user "Found $message \"[lrange $i $compos end]\" for line [lindex $i 0]\n"
+		}
+	    }
+	}
+    }
+
+    #send_user "Returning: $result\n"
+    return $result
+}
+
+# old-dejagnu-init -- set up some statistics collectors
+#
+# There currently isn't much to do, but always calling it allows us to add
+# enhancements without having to update our callers.
+# It must be run before calling `old-dejagnu'.
+
+proc old-dejagnu-init { } {
+}
+
+# old-dejagnu-stat -- print the stats of this run
+#
+# ??? This is deprecated, and can be removed.
+
+proc old-dejagnu-stat { } {
+}
+
+# old-dejagnu -- runs an old style DejaGnu test.
+#
+# Returns 0 if successful, 1 if their were any errors.
+# PROG is the full path name of the file to compile.
+#
+# CFLAGSX is the options to always pass to the compiler.
+#
+# DEFAULT_CFLAGS are additional options if the testcase has none.
+#
+# LIBS_VAR is the name of the global variable containing libraries (-lxxx's).
+# This is also ignored.
+#
+# LIBS is any additional libraries to link with.  This *cannot* be specified
+# with the compiler flags because otherwise gcc will issue, for example, a
+# "-lg++ argument not used since linking not done" warning which will screw up
+# the test for excess errors.  We could ignore such messages instead.
+#
+# Think of "cflags" here as "compiler flags", not "C compiler flags".
+
+proc old-dejagnu { compiler prog name cflagsx default_cflags libs } {
+    global verbose
+    global tool
+    global subdir		;# eg: g++.old-dejagnu
+    global host_triplet
+    global tmpdir
+
+    set runflag 1
+    set execbug_flag 0
+    set excessbug_flag 0
+    set pattern ""
+    set text "\[- A-Za-z0-9\.\;\"\_\:\'\`\(\)\!\#\=\+\?\&\*]*"
+
+    if ![info exists tmpdir] then {
+	set tmpdir "/tmp"
+    }
+
+# look for keywords that change the compiler options
+#
+# There are two types of test, negative and affirmative. Negative
+# tests have the keyword of "ERROR - " or "WARNING - " on the line
+# expected to produce an error. This is followed by the pattern. If
+# the desired error or warning message appears, then the test passes.
+# 
+# Affirmative test can have the following keywords "gets bogus error",
+# "causes invalid C code", "invalid assembly code", "causes abort",
+# "causes segfault", "causes linker error", "execution test fails". If
+# the pattern after the keyword matches, then the test is a failure.
+#
+# One can specify particular targets for expected failures of the above
+# keywords by putting "XFAIL target-triplet" after the keyword.
+#
+# Example:
+#
+# void f ()
+#{
+#  int i[2], j;
+#  A a (int (i[1]), j);		// gets bogus error - late parsing XFAIL *-*-*
+#  A b (int (i[1]), int j);	// function
+#  a.k = 0;			// gets bogus error - late parsing XFAIL *-*-*
+#  b (i, j);
+#}
+#
+# Note also, that one can add a comment with the keyword ("late parsing"
+# in the above example).
+#
+# If any of the tests contain the special pattern "FIXME -" that test is
+# not run because it will produce incorrect output.
+#
+# Testcases can supply special options to the compiler with a line containing
+# "Special.*Options: ...", where ".*" can be anything (eg: g++) and "..." are
+# the additional options to pass to the compiler.  Nothing else may appear
+# after the options.  IE: for a C testcase
+# /* Special Options: -fomit-frame-pointer */  /* Oops! */
+# is wrong,
+# /* Special Options: -fomit-frame-pointer */
+# is right.  If no such Special Options are found, $default_cflags is used.
+# FIXME: Can there be multiple lines of these?
+#
+# Other keywords: "Build don't link:", "Build don't run:", "Build then link:",
+#                 "Additional sources: <file>.cc ..."
+
+# $name is now passed in.
+#    set name "[file tail [file dirname $prog]]/[file tail $prog]"
+
+    set tmp [grep $prog "FIXME -.*"]
+    if ![string match "" $tmp] then {
+	foreach i $tmp {
+	    warning "[file tail [file dirname $prog]]/[file tail $prog] [lrange $i 2 end]"
+	}
+	return 1
+    }
+
+    set tmp [lindex [grep $prog "Special.*Options:.*"] 0]
+    set cflags ""
+
+    regsub -all "\n\[^\n\]+(\n|$)" $tmp "\n" tmp
+    set tmp [string trim $tmp]
+    if ![string match "" $tmp] then {
+	regsub "^.*Special.*Options:" $tmp "" tmp
+	lappend cflags "additional_flags=$tmp"
+	verbose "Adding special options $tmp" 2
+    } else {
+	lappend cflags "additional_flags=$default_cflags"
+    }
+
+    if { $cflagsx != "" } {
+	lappend cflags "additional_flags=$cflagsx"
+    }
+
+    set tmp [lindex [grep $prog "Additional sources: .*"] 0]
+    regsub -all "\n\[^\n\]+(\n|$)" $tmp "\n" tmp
+    set tmp [string trim $tmp]
+    if ![string match "" $tmp] then {
+	regsub "^.*Additional.*sources:" $tmp "" tmp
+	regsub -all " " $tmp " [file dirname $prog]/" tmp
+	lappend cflags "additional_flags=$tmp"
+	verbose "Adding sources $tmp"
+    }
+
+    lappend cflags "compiler=$compiler"
+
+    regsub -all "\[./\]" "$name" "-" output;
+    set output "$tmpdir/$output";
+    set compile_type "executable"
+
+    set tmp [lindex [grep $prog "Build don.t link:"] 0]
+    if ![string match "" $tmp] then {
+	set compile_type "object"
+	set runflag 0
+	set output "$tmpdir/[file tail [file rootname $prog]].o"
+	verbose "Will compile $prog to object" 3
+    }
+
+    set tmp [lindex [grep $prog "Build then link:"] 0]
+    if ![string match "" $tmp] then {
+	set compile_type "object"
+	set runflag 2
+	set final_output "$output"
+	set output "$tmpdir/[file tail [file rootname $prog]].o"
+	verbose "Will compile $prog to object, then link it" 3
+    }	
+
+    set tmp [lindex [grep $prog "Build don.t run:"] 0]
+    if ![string match "" $tmp] then {
+	set runflag 0
+	verbose "Will compile $prog to binary" 3
+    }
+
+    set tmp [grep $prog "Skip if (|not )feature:.*"];
+    if { $tmp != "" } {
+	foreach line $tmp {
+	    if [regexp "Skip if not feature" $line] {
+		set not 1;
+	    } else {
+		set not 0;
+	    }
+	    regsub "^.*Skip if (|not )feature:\[ 	\]*" "$line" "" i;
+	    set is_set 0;
+	    foreach j $i {
+		if [target_info exists $j] {
+		    set is_set 1;
+		    break;
+		}
+	    }
+	    if { $is_set != $not } {
+		untested "$name: Test skipped: ${line}($j set)"
+		return;
+	    }
+	}
+    }
+
+    set tmp [grep $prog "Skip if (|not )target:.*"];
+    if { $tmp != "" } {
+	foreach line $tmp {
+	    if [regexp "Skip if not target:" $line] {
+		set not 1;
+	    } else {
+		set not 0;
+	    }
+	    regsub "^.*Skip if (|not )target:\[ 	\]*" "$line" "" i;
+	    set ist 0;
+	    foreach j $i {
+		if [istarget $j] {
+		    set ist 1;
+		    break;
+		}
+	    }
+	    if { $ist != $not } {
+		untested "$name: Test skipped: ${line}"
+		return;
+	    }
+	}
+    }
+
+    if ![isnative] {
+	set tmp [lindex [grep $prog "Skip if not native"] 0];
+	if { $tmp != "" } {
+	    untested "$name: Test skipped because not native";
+	    return;
+	}
+    } else {
+	set tmp [lindex [grep $prog "Skip if native"] 0];
+	if { $tmp != "" } {
+	    untested "$name: Test skipped because native";
+	    return;
+	}
+    }
+
+    lappend cflags "libs=$libs"
+
+#
+# Look for the other keywords and extract the error messages.
+# `message' contains all the things we found.
+# ??? We'd like to use lappend below instead of concat, but that doesn't
+# work (adds an extra level of nesting to $tmp).
+#
+
+    set message ""
+
+    set tmp [process-option $prog "ERROR - " "an error message" ERROR "$text error$text"]
+    if ![string match "" $tmp] then {
+	set runflag 0
+	set message [concat $message $tmp]
+    }
+
+    set tmp [process-option $prog "WARNING - " "a warning message" WARNING "warning"]
+    if ![string match "" $tmp] then {
+	set runflag 0
+	set message [concat $message $tmp]
+    }
+
+    set tmp [process-option $prog "gets bogus error" "a bogus error" BOGUS $text]
+    if ![string match "" $tmp] then {
+	set message [concat $message $tmp]
+    }
+
+    set tmp [process-option $prog "causes invalid C code" "a bad C translation" BADC $text]
+    if ![string match "" $tmp] then {
+	set message [concat $message $tmp]
+    }
+
+    set tmp [process-option $prog "invalid assembly code" "some invalid assembly code" BADASM $text]
+    if ![string match "" $tmp] then {
+	set message [concat $message $tmp]
+    }
+
+    set tmp [process-option $prog "causes abort" "an abort cause" ABORT $text]
+    if ![string match "" $tmp] then {
+	set message [concat $message $tmp]
+    }
+
+    set tmp [process-option $prog "causes segfault" "a segfault cause" SEGFAULT $text]
+    if ![string match "" $tmp] then {
+	set message [concat $message $tmp]
+    }
+
+    set tmp [process-option $prog "causes linker error" "a linker error" LINKER $text]
+    if ![string match "" $tmp] then {
+	set message [concat $message $tmp]
+    }
+
+    set tmp [process-option $prog "execution test fails" "an execution failure" EXECO $text]
+    if ![string match "" $tmp] then {
+	set execbug_flag 1
+	set message [concat $message $tmp]
+	warning "please use execution test - XFAIL *-*-* in $prog instead"
+    }
+
+    set tmp [process-option $prog "execution test - " "an excess error failure" EXEC $text]
+    if ![string match "" $tmp] then {
+	set message [concat $message $tmp]
+    }
+
+    set tmp [process-option $prog "excess errors test fails" "an excess error failure" EXCESSO $text]
+    if ![string match "" $tmp] then {
+	set excessbug_flag 1
+	set message [concat $message $tmp]
+	warning "please use excess errors test - XFAIL *-*-* in $prog instead"
+    }
+
+    set tmp [process-option $prog "excess errors test - " "an excess error failure" EXCESS $text]
+    if ![string match "" $tmp] then {
+	set message [concat $message $tmp]
+    }
+
+    set expect_crash \
+      [process-option $prog "crash test - " "a crash" CRASH $text]
+    if {$expect_crash != "" 
+        && [lindex [lindex $expect_crash 0] 1] == "XCRASH"} then {
+       set expect_crash 1
+    } else {
+       set expect_crash 0
+    }
+
+#
+#  run the compiler and analyze the results
+#
+
+    # Since we don't check return status of the compiler, make sure
+    # we can't run a.out when the compilation fails.
+    remote_file build delete $output
+    set comp_output [${tool}_target_compile $prog $output $compile_type $cflags]
+    if { $runflag == 2 && [file exists $output] } then {
+	set runflag 0
+	set comp_output [concat $comp_output [${tool}_target_compile $output $final_output "executable" $cflags]]
+	set output $final_output
+    }
+
+    # Delete things like "ld.so: warning" messages.
+    set comp_output [prune_warnings $comp_output]
+
+    if [string match "*Internal compiler error*" $comp_output] then {
+        if $expect_crash then {
+	    setup_xfail "*-*-*"
+	}
+        fail "$name caused compiler crash"
+        remote_file build delete $output
+        return 1
+    }
+
+    #send_user "\nold_dejagnu.exp: comp_output1 = :$comp_output:\n\n"
+    #send_user "\nold_dejagnu.exp: message = :$message:\n\n"
+    #send_user "\nold_dejagnu.exp: message length = [llength $message]\n\n"
+
+    set last_line 0
+    foreach i $message {
+
+	#send_user "\nold_dejagnu.exp: i = :$i:\n\n"
+
+	# Remove all error messages for the line [lindex $i 0]
+	# in the source file.  If we find any, success!
+	set line [lindex $i 0]
+	set pattern [lindex $i 2]
+
+	# Multiple tests one one line don't work, because we remove all 
+	# messages on the line for the first test.  So skip later ones.
+	if { $line == $last_line } {
+	    continue
+	}
+	set last_line $line
+
+	if [regsub -all "(^|\n)\[^\n\]+:$line:\[^\n\]*" $comp_output "" comp_output] {
+            set comp_output [string trimleft $comp_output]
+	    set ok pass
+	    set uhoh fail
+	} else {
+	    set ok fail
+	    set uhoh pass
+	}
+
+	case [lindex $i 1] {
+	    "ERROR" {
+		$ok "$name $pattern (test for errors, line $line)"
+	    }
+	    "XERROR" {
+		x$ok "$name $pattern (test for errors, line $line)"
+	    }
+	    "WARNING" {
+		$ok "$name $pattern (test for warnings, line $line)"
+	    }
+	    "XWARNING" {
+		x$ok "$name $pattern (test for warnings, line $line)"
+	    }
+	    "BOGUS" {
+		$uhoh "$name $pattern (test for bogus messages, line $line)"
+	    }
+	    "XBOGUS" {
+		x$uhoh "$name $pattern (test for bogus messages, line $line)"
+	    }
+	    "ABORT" {
+		$uhoh "$name $pattern (test for compiler aborts, line $line)"
+	    }
+	    "XABORT" {
+		x$uhoh "$name $pattern (test for compiler aborts, line $line)"
+	    }
+	    "SEGFAULT" {
+		$uhoh "$name $pattern (test for compiler segfaults, line $line)"
+	    }
+	    "XSEGFAULT" {
+		x$uhoh "$name $pattern (test for compiler segfaults, line $line)"
+	    }
+	    "LINKER" {
+		$uhoh "$name $pattern (test for linker problems, line $line)"
+	    }
+	    "XLINKER" {
+		x$uhoh "$name $pattern (test for linker problems, line $line)"
+	    }
+	    "BADC" {
+		$uhoh "$name $pattern (test for Bad C code, line $line)"
+	    }
+	    "XBADC" {
+		x$uhoh "$name $pattern (test for Bad C code, line $line)"
+	    }
+	    "BADASM" {
+		$uhoh "$name $pattern (test for bad assembler, line $line)"
+	    }
+	    "XBADASM" {
+		x$uhoh "$name $pattern (test for bad assembler, line $line)"
+	    }
+	    "XEXEC" {
+		set execbug_flag 1
+	    }
+	    "XEXCESS" {
+		set excessbug_flag 1
+	    }
+	}
+	#send_user "\nold_dejagnu.exp: comp_output2= :$comp_output:\n\n"
+    }
+    #send_user "\nold_dejagnu.exp: comp_output3 = :$comp_output:\n\n"
+
+    #look to see if this is all thats left, if so, all messages have been handled
+    #send_user "comp_output: $comp_output\n"
+    regsub -all "(^|\n)\[^\n\]*: In (function|method) \[^\n\]*" $comp_output "" comp_output
+    regsub -all "(^|\n)\[^\n\]*: In instantiation of \[^\n\]*" $comp_output "" comp_output
+    regsub -all "(^|\n)\[^\n\]*:   instantiated from \[^\n\]*" $comp_output "" comp_output
+    regsub -all "(^|\n)\[^\n\]*: At top level:\[^\n\]*" $comp_output "" comp_output
+    regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $comp_output "" comp_output
+    regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $comp_output "" comp_output
+    regsub -all "(^|\n)collect: re(compiling|linking)\[^\n\]*" $comp_output "" comp_output
+
+    set unsupported_message [${tool}_check_unsupported_p $comp_output]
+    if { $unsupported_message != "" } {
+	unsupported "$name: $unsupported_message"
+	return
+    }
+
+    # someone forgot to delete the extra lines
+    regsub -all "\n+" $comp_output "\n" comp_output
+    regsub "^\n+" $comp_output "" comp_output
+    #send_user "comp_output: $comp_output\n"
+    
+    # excess errors
+    if $excessbug_flag then {
+	setup_xfail "*-*-*"
+    }
+    if ![string match "" $comp_output] then {
+	fail "$name (test for excess errors)"
+	send_log "$comp_output\n"
+    } else {
+	pass "$name (test for excess errors)"
+    }
+
+    # run the executable image
+    if $runflag then {
+	set executable $output
+	if ![file exists $executable] then {
+	    # Since we couldn't run it, we consider it an expected failure,
+	    # so that test cases don't appear to disappear, and reappear.
+	    setup_xfail "*-*-*"
+	    fail "$name $pattern Execution test"
+	} else {
+	    set status -1
+	    set result [eval [format "%s_load %s" $tool $executable]]
+	    set status [lindex $result 0];
+	    set output [lindex $result 1];
+	    if { $status == "pass" } {
+		remote_file build delete $executable;
+	    }
+	    if { $execbug_flag || $excessbug_flag } then {
+		setup_xfail "*-*-*"
+	    }
+	    $status "$name $pattern Execution test"
+	}
+    }
+
+    verbose "deleting $output"
+    remote_file build delete $output
+    return 0
+}
diff --git a/gcc/testsuite/objc/execute/bf-1.m b/gcc/testsuite/objc/execute/bf-1.m
new file mode 100644
index 00000000000..9a533a39b52
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-1.m
@@ -0,0 +1,24 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a;
+  struct {
+    int i:2;
+    int j:3;
+    int k:12;
+  } flags;
+  char c;
+//  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-10.m b/gcc/testsuite/objc/execute/bf-10.m
new file mode 100644
index 00000000000..77076da51ed
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-10.m
@@ -0,0 +1,22 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a[3];
+  int i:2;
+  int j:6;
+  char c;
+  int k:12;
+  char d;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-11.m b/gcc/testsuite/objc/execute/bf-11.m
new file mode 100644
index 00000000000..40d9b533a49
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-11.m
@@ -0,0 +1,23 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a[3];
+  int i:2;
+  int j:6;
+  short s;
+  int k:12;
+  char d;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-12.m b/gcc/testsuite/objc/execute/bf-12.m
new file mode 100644
index 00000000000..9e0a989ee75
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-12.m
@@ -0,0 +1,23 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a[3];
+  int i:2;
+  int j:6;
+  int s;
+  int k:12;
+  char d;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-13.m b/gcc/testsuite/objc/execute/bf-13.m
new file mode 100644
index 00000000000..f8349338b53
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-13.m
@@ -0,0 +1,25 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a[3];
+  struct {
+    int i:2;
+    int j:6;
+    char s;
+    int k:12;
+  } flags;
+  char d;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-14.m b/gcc/testsuite/objc/execute/bf-14.m
new file mode 100644
index 00000000000..0ceedc08dd8
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-14.m
@@ -0,0 +1,25 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a[3];
+  struct {
+    int i:2;
+    int j:6;
+    short s;
+    int k:12;
+  } flags;
+  char d;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-15.m b/gcc/testsuite/objc/execute/bf-15.m
new file mode 100644
index 00000000000..e6e7b30607d
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-15.m
@@ -0,0 +1,25 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a;
+  struct {
+    int i:2;
+    int j:6;
+    int s;
+    int k:12;
+  } flags;
+  char d;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-16.m b/gcc/testsuite/objc/execute/bf-16.m
new file mode 100644
index 00000000000..fb8b0c38f51
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-16.m
@@ -0,0 +1,26 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+struct A {
+  int i;
+  float f;
+  int a:3;
+  int b:2;
+};
+
+@interface MyObject
+{
+  Class isa;
+  int i;
+  float f[3];
+  struct A a, b;
+  char c;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-17.m b/gcc/testsuite/objc/execute/bf-17.m
new file mode 100644
index 00000000000..4c3b854962c
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-17.m
@@ -0,0 +1,25 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+struct A {
+  int i;
+  float f;
+  int a:3;
+  int b:2;
+};
+
+@interface MyObject
+{
+  Class isa;
+  int i;
+  float f[3];
+  struct A a;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-18.m b/gcc/testsuite/objc/execute/bf-18.m
new file mode 100644
index 00000000000..36a7ea6c61b
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-18.m
@@ -0,0 +1,17 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  int i;
+  char c[1];
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-19.m b/gcc/testsuite/objc/execute/bf-19.m
new file mode 100644
index 00000000000..21775e7c77e
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-19.m
@@ -0,0 +1,17 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  unsigned int i;
+  MyObject *object;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-2.m b/gcc/testsuite/objc/execute/bf-2.m
new file mode 100644
index 00000000000..eac0931549b
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-2.m
@@ -0,0 +1,24 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a[3];
+  struct {
+    int i:2;
+    int j:3;
+    int k:12;
+  } flags;
+  char c;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-3.m b/gcc/testsuite/objc/execute/bf-3.m
new file mode 100644
index 00000000000..04cf0836faa
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-3.m
@@ -0,0 +1,24 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a;
+  struct {
+    int i:2;
+    int j:6;
+    int k:12;
+  } flags;
+  char c;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-4.m b/gcc/testsuite/objc/execute/bf-4.m
new file mode 100644
index 00000000000..ae8017c688e
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-4.m
@@ -0,0 +1,24 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a[3];
+  struct {
+    int i:2;
+    int j:6;
+    int k:12;
+  } flags;
+  char c;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-5.m b/gcc/testsuite/objc/execute/bf-5.m
new file mode 100644
index 00000000000..e61d71f9ced
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-5.m
@@ -0,0 +1,22 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a;
+  int i:2;
+  int j:3;
+  int k:12;
+  char c;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-6.m b/gcc/testsuite/objc/execute/bf-6.m
new file mode 100644
index 00000000000..38222d3f676
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-6.m
@@ -0,0 +1,22 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a[3];
+  int i:2;
+  int j:3;
+  int k:12;
+  char c;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-7.m b/gcc/testsuite/objc/execute/bf-7.m
new file mode 100644
index 00000000000..80ee6cef763
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-7.m
@@ -0,0 +1,22 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a;
+  int i:2;
+  int j:6;
+  int k:12;
+  char c;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-8.m b/gcc/testsuite/objc/execute/bf-8.m
new file mode 100644
index 00000000000..cc472f96130
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-8.m
@@ -0,0 +1,22 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a[3];
+  int i:2;
+  int j:6;
+  int k:12;
+  char c;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-9.m b/gcc/testsuite/objc/execute/bf-9.m
new file mode 100644
index 00000000000..0f17727d6df
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-9.m
@@ -0,0 +1,23 @@
+#include <objc/objc.h>
+#include <objc/objc-api.h>
+#include <objc/Object.h>
+
+@interface MyObject
+{
+  Class isa;
+  float f;
+  char a[3];
+  int i:2;
+  int j:3;
+  char c;
+  int k:12;
+  char d;
+  void *pointer;
+}
+@end
+
+@implementation MyObject
+@end
+
+#include "bf-common.h"
+
diff --git a/gcc/testsuite/objc/execute/bf-common.h b/gcc/testsuite/objc/execute/bf-common.h
new file mode 100644
index 00000000000..123a45413d0
--- /dev/null
+++ b/gcc/testsuite/objc/execute/bf-common.h
@@ -0,0 +1,76 @@
+#include <objc/encoding.h>
+
+
+void print_ivars (Class class)
+{
+  struct objc_ivar_list* ivars = class->ivars;
+  int i;
+
+  for (i = 0; i < ivars->ivar_count; i++) {
+    struct objc_ivar *ivar = &(ivars->ivar_list[i]);
+    printf ("ivar '%s', type '%s', offset %d\n",
+	    ivar->ivar_name, ivar->ivar_type, ivar->ivar_offset);
+  }
+}
+
+void compare_structures (Class class, const char* type)
+{
+  struct objc_struct_layout layout;
+  struct objc_ivar_list* ivars = class->ivars;
+  int i = 0;
+  int position;
+
+  objc_layout_structure (type, &layout);
+
+  while (objc_layout_structure_next_member (&layout))
+    {
+      struct objc_ivar *ivar;
+      const char *ivar_type;
+
+      if (i > ivars->ivar_count)
+        {
+          printf ("too many ivars in type %s, layout = %s\n",
+                  type, layout.type);
+          exit (1);
+        }
+
+      ivar = &(ivars->ivar_list[i]);
+      objc_layout_structure_get_info (&layout, &position, NULL, &ivar_type);
+      printf ("real ivar '%s' offset %d\n",
+              ivar->ivar_name, ivar->ivar_offset);
+      printf ("computed type '%s' offset %d\n", ivar_type, position);
+      if (position != ivar->ivar_offset)
+        {
+          printf ("offset %d and computed position %d don't match on ivar '%s'"
+                  " (i = %d)\n",
+                  ivar->ivar_offset, position, ivar->ivar_name, i);
+          exit (1);
+        }
+      i++;
+    }
+  
+  printf ("%d ivars checked\n", i);
+}
+
+int main ()
+{
+  struct class_vars
+    {
+      @defs (MyObject);
+    };
+  int size1, size2;
+  Class class = [MyObject class];
+
+  printf ("type = %s\n", @encode (struct class_vars));
+  print_ivars (class);
+
+  compare_structures (class, @encode(struct class_vars));
+  if ((size1 = objc_sizeof_type (@encode(struct class_vars)))
+      != (size2 = sizeof (struct class_vars)))
+    {
+      printf ("sizes don't match (computed %d, exact %d)\n", size1, size2);
+      abort ();
+    }
+  
+  exit (0);
+}
diff --git a/gcc/testsuite/objc/execute/execute.exp b/gcc/testsuite/objc/execute/execute.exp
new file mode 100644
index 00000000000..0f598a3c5f4
--- /dev/null
+++ b/gcc/testsuite/objc/execute/execute.exp
@@ -0,0 +1,42 @@
+# Copyright (C) 1991, 1992, 1993, 1995, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gcc@prep.ai.mit.edu
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+# Modified by Ovidiu Predescu (ovidiu@aracnet.com)
+
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib objc-torture.exp
+
+#
+# main test loop
+#
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.m]] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $src] then {
+	continue
+    }
+
+    objc-torture-execute $src
+}
diff --git a/gcc/tm.texi b/gcc/tm.texi
index a13c6d97424..484c73c10dc 100644
--- a/gcc/tm.texi
+++ b/gcc/tm.texi
@@ -3464,6 +3464,13 @@ figure them out, compile a small program for profiling using the
 system's installed C compiler and look at the assembler code that
 results.
 
+@findex NO_PROFILE_COUNTERS
+@item NO_PROFILE_COUNTERS
+Define this macro if the @code{mcount} subroutine on your system does
+not need a counter variable allocated for each function.  This is true
+for almost all modern implementations.  If you define this macro, you
+must not use the @var{labelno} argument to @code{FUNCTION_PROFILER}.
+
 @findex PROFILE_BEFORE_PROLOGUE
 @item PROFILE_BEFORE_PROLOGUE
 Define this macro if the code for function profiling should come before
diff --git a/gcc/toplev.c b/gcc/toplev.c
index 5f8913fa3e5..a575dc6b6b8 100644
--- a/gcc/toplev.c
+++ b/gcc/toplev.c
@@ -137,8 +137,6 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!
 #define DIR_SEPARATOR '/'
 #endif
 
-extern int rtx_equal_function_value_matters;
-
 #if ! (defined (VMS) || defined (OS2))
 extern char **environ;
 #endif
diff --git a/gcc/varasm.c b/gcc/varasm.c
index b93506546bc..e5df1d8b52f 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -3495,6 +3495,9 @@ force_const_mem (mode, x)
 	  pop_obstacks ();
 	}
 
+      if (GET_CODE (x) == LABEL_REF)
+	LABEL_PRESERVE_P (XEXP (x, 0)) = 1;
+
       /* Allocate a pool constant descriptor, fill it in, and chain it in.  */
 
       pool = (struct pool_constant *) savealloc (sizeof (struct pool_constant));
diff --git a/libiberty/ChangeLog b/libiberty/ChangeLog
index 64fe9c07425..6a83a4401e0 100644
--- a/libiberty/ChangeLog
+++ b/libiberty/ChangeLog
@@ -1,3 +1,7 @@
+2001-03-27  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* memchr.c (memchr): Adjust condition to avoid infinite loop.
+
 Fri Mar 16 12:46:19 GMT 2001 Bernd Schmidt  (bernds@redhat.com)
 
 	* gcc-2.95.3 Released.
diff --git a/libiberty/memchr.c b/libiberty/memchr.c
index cce30039437..89aa98f1d94 100644
--- a/libiberty/memchr.c
+++ b/libiberty/memchr.c
@@ -50,7 +50,7 @@ memchr (src_void, c, length)
 {
   const unsigned char *src = (const unsigned char *)src_void;
   
-  while (--length >= 0)
+  while (length-- > 0)
   {
     if (*src == c)
      return (PTR)src;
diff --git a/libstdc++/ChangeLog b/libstdc++/ChangeLog
index 02b950c48ff..f8a71b39f70 100644
--- a/libstdc++/ChangeLog
+++ b/libstdc++/ChangeLog
@@ -1,3 +1,10 @@
+2001-04-06  Matthias Klose <doko@debian.org>
+
+	From <sicard@bigruth.solsoft.fr>:
+	* std/bastring.h: remove some compiler warnings.
+	* std/bastring.cc: Likewise.
+	* stl/stl_hashtable.h: Likewise.
+
 Fri Mar 16 12:46:19 GMT 2001 Bernd Schmidt  (bernds@redhat.com)
 
 	* gcc-2.95.3 Released.
diff --git a/libstdc++/std/bastring.cc b/libstdc++/std/bastring.cc
index f86f6d30157..c37941a0b1a 100644
--- a/libstdc++/std/bastring.cc
+++ b/libstdc++/std/bastring.cc
@@ -116,19 +116,19 @@ template <class charT, class traits, class Allocator>
 basic_string <charT, traits, Allocator>&
 basic_string <charT, traits, Allocator>::
 replace (size_type pos1, size_type n1,
-	 const basic_string& str, size_type pos2, size_type n2)
+	 const basic_string& _str, size_type pos2, size_type n2)
 {
-  const size_t len2 = str.length ();
+  const size_t len2 = _str.length ();
 
   if (pos1 == 0 && n1 >= length () && pos2 == 0 && n2 >= len2)
-    return operator= (str);
+    return operator= (_str);
 
   OUTOFRANGE (pos2 > len2);
 
   if (n2 > len2 - pos2)
     n2 = len2 - pos2;
 
-  return replace (pos1, n1, str.data () + pos2, n2);
+  return replace (pos1, n1, _str.data () + pos2, n2);
 }
 
 template <class charT, class traits, class Allocator>
@@ -394,21 +394,21 @@ find_last_not_of (charT c, size_type pos) const
 
 template <class charT, class traits, class Allocator>
 int basic_string <charT, traits, Allocator>::
-compare (const basic_string& str, size_type pos, size_type n) const
+compare (const basic_string& _str, size_type pos, size_type n) const
 {
   OUTOFRANGE (pos > length ());
 
   size_t rlen = length () - pos;
   if (rlen > n)
     rlen = n;
-  if (rlen > str.length ())
-    rlen = str.length ();
-  int r = traits::compare (data () + pos, str.data (), rlen);
+  if (rlen > _str.length ())
+    rlen = _str.length ();
+  int r = traits::compare (data () + pos, _str.data (), rlen);
   if (r != 0)
     return r;
   if (rlen == n)
     return 0;
-  return (length () - pos) - str.length ();
+  return (length () - pos) - _str.length ();
 }
 
 template <class charT, class traits, class Allocator>
@@ -476,7 +476,7 @@ getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
 {
   if (is.ipfx1 ())
     {
-      _IO_size_t count = 0;
+      _IO_size_t _count = 0;
       streambuf *sb = is.rdbuf ();
       s.resize (0);
 
@@ -485,13 +485,13 @@ getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
 	  int ch = sb->sbumpc ();
 	  if (ch == EOF)
 	    {
-	      is.setstate (count == 0
+	      is.setstate (_count == 0
 			   ? (ios::failbit|ios::eofbit)
 			   : ios::eofbit);
 	      break;
 	    }
 
-	  ++count;
+	  ++_count;
 
 	  if (ch == delim)
 	    break;
@@ -507,7 +507,7 @@ getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
     }
 
   // We need to be friends with istream to do this.
-  // is._gcount = count;
+  // is._gcount = _count;
   is.isfx ();
 
   return is;
diff --git a/libstdc++/std/bastring.h b/libstdc++/std/bastring.h
index bbe873085ea..2e99d41a2f9 100644
--- a/libstdc++/std/bastring.h
+++ b/libstdc++/std/bastring.h
@@ -169,9 +169,9 @@ public:
     }
 
   explicit basic_string (): dat (nilRep.grab ()) { }
-  basic_string (const basic_string& str): dat (str.rep ()->grab ()) { }
-  basic_string (const basic_string& str, size_type pos, size_type n = npos)
-    : dat (nilRep.grab ()) { assign (str, pos, n); }
+  basic_string (const basic_string& _str): dat (_str.rep ()->grab ()) { }
+  basic_string (const basic_string& _str, size_type pos, size_type n = npos)
+    : dat (nilRep.grab ()) { assign (_str, pos, n); }
   basic_string (const charT* s, size_type n)
     : dat (nilRep.grab ()) { assign (s, n); }
   basic_string (const charT* s)
@@ -191,9 +191,9 @@ public:
 
   void swap (basic_string &s) { charT *d = dat; dat = s.dat; s.dat = d; }
 
-  basic_string& append (const basic_string& str, size_type pos = 0,
+  basic_string& append (const basic_string& _str, size_type pos = 0,
 			size_type n = npos)
-    { return replace (length (), 0, str, pos, n); }
+    { return replace (length (), 0, _str, pos, n); }
   basic_string& append (const charT* s, size_type n)
     { return replace (length (), 0, s, n); }
   basic_string& append (const charT* s)
@@ -346,8 +346,8 @@ public:
   size_type find (const basic_string& str, size_type pos = 0) const
     { return find (str.data(), pos, str.length()); }
   size_type find (const charT* s, size_type pos, size_type n) const;
-  size_type find (const charT* s, size_type pos = 0) const
-    { return find (s, pos, traits::length (s)); }
+  size_type find (const charT* _s, size_type pos = 0) const
+    { return find (_s, pos, traits::length (_s)); }
   size_type find (charT c, size_type pos = 0) const;
 
   size_type rfind (const basic_string& str, size_type pos = npos) const
@@ -469,36 +469,36 @@ inline basic_string <charT, traits, Allocator>
 operator+ (const basic_string <charT, traits, Allocator>& lhs,
 	   const basic_string <charT, traits, Allocator>& rhs)
 {
-  basic_string <charT, traits, Allocator> str (lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
 inline basic_string <charT, traits, Allocator>
 operator+ (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
 {
-  basic_string <charT, traits, Allocator> str (lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
 inline basic_string <charT, traits, Allocator>
 operator+ (charT lhs, const basic_string <charT, traits, Allocator>& rhs)
 {
-  basic_string <charT, traits, Allocator> str (1, lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (1, lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
 inline basic_string <charT, traits, Allocator>
 operator+ (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
 {
-  basic_string <charT, traits, Allocator> str (lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
diff --git a/libstdc++/stl/stl_hashtable.h b/libstdc++/stl/stl_hashtable.h
index 78b36c1d5a0..c0354fa38e7 100644
--- a/libstdc++/stl/stl_hashtable.h
+++ b/libstdc++/stl/stl_hashtable.h
@@ -1014,14 +1014,14 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
   __STL_TRY {
     for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {
       if (const _Node* __cur = __ht._M_buckets[__i]) {
-        _Node* __copy = _M_new_node(__cur->_M_val);
-        _M_buckets[__i] = __copy;
+        _Node* ___copy = _M_new_node(__cur->_M_val);
+        _M_buckets[__i] = ___copy;
 
         for (_Node* __next = __cur->_M_next; 
              __next; 
              __cur = __next, __next = __cur->_M_next) {
-          __copy->_M_next = _M_new_node(__next->_M_val);
-          __copy = __copy->_M_next;
+          ___copy->_M_next = _M_new_node(__next->_M_val);
+          ___copy = ___copy->_M_next;
         }
       }
     }
