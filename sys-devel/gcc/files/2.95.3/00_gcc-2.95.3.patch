diff --git a/Makefile.in b/Makefile.in
index 7af1784..1013941 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -499,6 +499,7 @@ EXTRA_GCC_FLAGS = \
 	"`echo 'LIBGCC2_DEBUG_CFLAGS=$(LIBGCC2_DEBUG_CFLAGS)' | sed -e s/.*=$$/XFOO=/`" \
 	"`echo 'LIBGCC2_INCLUDES=$(LIBGCC2_INCLUDES)' | sed -e s/.*=$$/XFOO=/`" \
 	"`echo 'ENQUIRE=$(ENQUIRE)' | sed -e s/.*=$$/XFOO=/`" \
+	"`echo 'STAGE1_CFLAGS=$(STAGE1_CFLAGS)' | sed -e s/.*=$$/XFOO=/`" \
 	"`echo 'BOOT_CFLAGS=$(BOOT_CFLAGS)' | sed -e s/.*=$$/XFOO=/`"
 
 GCC_FLAGS_TO_PASS = $(BASE_FLAGS_TO_PASS) $(EXTRA_GCC_FLAGS)
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 85bf9f8..dcbbb6b 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -71,6 +71,7 @@ XCFLAGS =
 TCFLAGS =
 # -W -Wall warnings are disabled for releases.
 CFLAGS = -g
+STAGE1_CFLAGS = -g
 BOOT_CFLAGS = -O2 $(CFLAGS)
 #WARN_CFLAGS = -W -Wall
 # These exists to be overridden by the x-* and t-* files, respectively.
@@ -2938,7 +2939,7 @@ bootstrap bootstrap-lean: force
 # Only build the C compiler for stage1, because that is the only one that
 # we can guarantee will build with the native compiler, and also it is the
 # only thing useful for building stage2.
-	$(MAKE) CC="$(CC)" libdir=$(libdir) LANGUAGES="$(BOOT_LANGUAGES)"
+	$(MAKE) CC="$(CC)" CFLAGS="$(STAGE1_CFLAGS)" libdir=$(libdir) LANGUAGES="$(BOOT_LANGUAGES)"
 	$(MAKE) stage1
 # This used to define ALLOCA as empty, but that would lead to bad results
 # for a subsequent `make install' since that would not have ALLOCA empty.
diff --git a/gcc/c-common.c b/gcc/c-common.c
index 59dd407..2b98e0c 100644
--- a/gcc/c-common.c
+++ b/gcc/c-common.c
@@ -965,6 +965,15 @@ split_specs_attrs (specs_attrs, declspecs, prefix_attributes)
 {
   tree t, s, a, next, specs, attrs;
 
+  /* This can happen after an __extension__ in pedantic mode.  */
+  if (specs_attrs != NULL_TREE 
+      && TREE_CODE (specs_attrs) == INTEGER_CST)
+    {
+      *declspecs = NULL_TREE;
+      *prefix_attributes = NULL_TREE;
+      return;
+    }
+
   /* This can happen in c++ (eg: decl: typespec initdecls ';').  */
   if (specs_attrs != NULL_TREE
       && TREE_CODE (specs_attrs) != TREE_LIST)
diff --git a/gcc/c-lex.c b/gcc/c-lex.c
index 27c65f3..8ee2fe4 100644
--- a/gcc/c-lex.c
+++ b/gcc/c-lex.c
@@ -1812,7 +1812,11 @@ yylex ()
 
 	    type = flag_traditional ? traditional_type : ansi_type;
 
-	    if (warn_traditional && traditional_type != ansi_type)
+	    /* We assume that constants specified in a non-decimal
+	       base are bit patterns, and that the programmer really
+	       meant what they wrote.  */
+	    if (warn_traditional && base == 10
+		&& traditional_type != ansi_type)
 	      {
 		if (TYPE_PRECISION (traditional_type)
 		    != TYPE_PRECISION (ansi_type))
diff --git a/gcc/cccp.c b/gcc/cccp.c
index 023502f..455c239 100644
--- a/gcc/cccp.c
+++ b/gcc/cccp.c
@@ -1024,7 +1024,8 @@ static void print_help PROTO((void));
    retrying if necessary.  If MAX_READ_LEN is defined, read at most
    that bytes at a time.  Return a negative value if an error occurs,
    otherwise return the actual number of bytes read,
-   which must be LEN unless end-of-file was reached.  */
+   which may be < LEN if CRs have been skipped, though we try not to do
+   that.  */
 
 static int
 safe_read (desc, ptr, len)
@@ -1033,6 +1034,7 @@ safe_read (desc, ptr, len)
      int len;
 {
   int left, rcount, nchars;
+  char *rptr;
 
   left = len;
   while (left > 0) {
@@ -1052,8 +1054,20 @@ safe_read (desc, ptr, len)
       }
     if (nchars == 0)
       break;
-    ptr += nchars;
+
+    /* CRLF pairs, found with Unix when processing DOS files,
+       throw off backslash-newline removal.
+       Therefore, CRs are thrown away here. */
     left -= nchars;
+    rptr = ptr;
+    while(nchars--)
+      {
+	if(*rptr == '\r' && *(rptr+1) == '\n')
+	  left++;
+	else
+	  *ptr++ = *rptr;
+	rptr++;
+      }
   }
   return len - left;
 }
@@ -1124,7 +1138,7 @@ print_help ()
   printf ("Usage: %s [switches] input output\n", progname);
   printf ("Switches:\n");
   printf ("  -include <file>           Include the contents of <file> before other files\n");
-  printf ("  -imacros <file>           Accept definition of marcos in <file>\n");
+  printf ("  -imacros <file>           Accept definition of macros in <file>\n");
   printf ("  -iprefix <path>           Specify <path> as a prefix for next two options\n");
   printf ("  -iwithprefix <dir>        Add <dir> to the end of the system include paths\n");
   printf ("  -iwithprefixbefore <dir>  Add <dir> to the end of the main include paths\n");
@@ -1138,7 +1152,7 @@ print_help ()
   printf ("  -traditional              Follow K&R pre-processor behaviour\n");
   printf ("  -trigraphs                Support ANSI C trigraphs\n");
   printf ("  -lang-c                   Assume that the input sources are in C\n");
-  printf ("  -lang-c89                 Assume that the input is C89; depricated\n");
+  printf ("  -lang-c89                 Assume that the input is C89; deprecated\n");
   printf ("  -lang-c++                 Assume that the input sources are in C++\n");
   printf ("  -lang-objc                Assume that the input sources are in ObjectiveC\n");
   printf ("  -lang-objc++              Assume that the input sources are in ObjectiveC++\n");
@@ -2086,8 +2100,8 @@ main (argc, argv)
     for (;;) {
       cnt = safe_read (f, (char *) fp->buf + size, bsize - size);
       if (cnt < 0) goto perror;	/* error! */
+      if (cnt == 0) break; /* End of file */
       size += cnt;
-      if (size != bsize) break;	/* End of file */
       bsize *= 2;
       fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);
     }
@@ -5027,6 +5041,8 @@ read_name_map (dirname)
 	  map_list_ptr->map_list_map = ptr;
 
 	  while ((ch = getc (f)) != '\n')
+	    if (ch == '\r')
+		continue;
 	    if (ch == EOF)
 	      break;
 	}
@@ -5259,9 +5275,9 @@ finclude (f, inc, op, system_header_p, dirptr)
       i = safe_read (f, (char *) fp->buf + st_size, bsize - st_size);
       if (i < 0)
 	goto nope;      /* error! */
-      st_size += i;
-      if (st_size != bsize)
+      if (i == 0)
 	break;	/* End of file */
+      st_size += i;
       bsize *= 2;
       fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);
     }
diff --git a/gcc/combine.c b/gcc/combine.c
index eb75481..9445e30 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -7580,8 +7580,11 @@ nonzero_bits (x, mode)
 
       if (reg_last_set_value[REGNO (x)] != 0
 	  && reg_last_set_mode[REGNO (x)] == mode
-	  && (REG_N_SETS (REGNO (x)) == 1
-	      || reg_last_set_label[REGNO (x)] == label_tick)
+	  && (reg_last_set_label[REGNO (x)] == label_tick
+	      || (REGNO (x) >= FIRST_PSEUDO_REGISTER
+		  && REG_N_SETS (REGNO (x)) == 1
+		  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, 
+					REGNO (x))))
 	  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)
 	return reg_last_set_nonzero_bits[REGNO (x)];
 
@@ -7970,8 +7973,11 @@ num_sign_bit_copies (x, mode)
 
       if (reg_last_set_value[REGNO (x)] != 0
 	  && reg_last_set_mode[REGNO (x)] == mode
-	  && (REG_N_SETS (REGNO (x)) == 1
-	      || reg_last_set_label[REGNO (x)] == label_tick)
+	  && (reg_last_set_label[REGNO (x)] == label_tick
+	      || (REGNO (x) >= FIRST_PSEUDO_REGISTER
+		  && REG_N_SETS (REGNO (x)) == 1
+		  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start,
+					REGNO (x))))
 	  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)
 	return reg_last_set_sign_bit_copies[REGNO (x)];
 
@@ -10819,9 +10825,11 @@ get_last_value_validate (loc, insn, tick, replace)
 
       for (j = regno; j < endregno; j++)
 	if (reg_last_set_invalid[j]
-	    /* If this is a pseudo-register that was only set once, it is
-	       always valid.  */
-	    || (! (regno >= FIRST_PSEUDO_REGISTER && REG_N_SETS (regno) == 1)
+	    /* If this is a pseudo-register that was only set once and not
+	       live at the beginning of the function, it is always valid.  */
+	    || (! (regno >= FIRST_PSEUDO_REGISTER 
+		   && REG_N_SETS (regno) == 1
+		   && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, regno))
 		&& reg_last_set_label[j] > tick))
 	  {
 	    if (replace)
@@ -10880,12 +10888,21 @@ get_last_value (x)
   regno = REGNO (x);
   value = reg_last_set_value[regno];
 
-  /* If we don't have a value or if it isn't for this basic block,
-     return 0.  */
+  /* If we don't have a value, or if it isn't for this basic block and
+     it's either a hard register, set more than once, or it's a live
+     at the beginning of the function, return 0.  
+
+     Because if it's not live at the beginnning of the function then the reg 
+     is always set before being used (is never used without being set).
+     And, if it's set only once, and it's always set before use, then all
+     uses must have the same last value, even if it's not from this basic
+     block.  */
 
   if (value == 0
-      || (REG_N_SETS (regno) != 1
-	  && reg_last_set_label[regno] != label_tick))
+      || (reg_last_set_label[regno] != label_tick
+	  && (regno < FIRST_PSEUDO_REGISTER
+	      || REG_N_SETS (regno) != 1
+	      || REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, regno))))
     return 0;
 
   /* If the value was set in a later insn than the ones we are processing,
diff --git a/gcc/config/alpha/crtbegin.asm b/gcc/config/alpha/crtbegin.asm
index f954f1a..6350d47 100644
--- a/gcc/config/alpha/crtbegin.asm
+++ b/gcc/config/alpha/crtbegin.asm
@@ -68,6 +68,7 @@ __EH_FRAME_BEGIN__:
 	br      $29,1f
 1:	ldgp    $29,0($29)
 	jsr     $26,__do_global_dtors_aux
+	ldgp    $29,0($26)
 
 	# Ideally this call would go in crtend.o, except that we can't
 	# get hold of __EH_FRAME_BEGIN__ there.
diff --git a/gcc/config/i386/freebsd-elf.h b/gcc/config/i386/freebsd-elf.h
index e97d4ca..4e45020 100644
--- a/gcc/config/i386/freebsd-elf.h
+++ b/gcc/config/i386/freebsd-elf.h
@@ -135,6 +135,9 @@ Boston, MA 02111-1307, USA.  */
  : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \
  : (-1))
 
+#undef  NO_PROFILE_COUNTERS
+#define NO_PROFILE_COUNTERS
+
 /* Tell final.c that we don't need a label passed to mcount.  */
 
 #undef FUNCTION_PROFILER
diff --git a/gcc/config/mips/linux.h b/gcc/config/mips/linux.h
index f4ed424..dff5f9f 100644
--- a/gcc/config/mips/linux.h
+++ b/gcc/config/mips/linux.h
@@ -1,5 +1,5 @@
 /* Definitions for MIPS running Linux-based GNU systems with ELF format.
-   Copyright (C) 1998 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
 
 This file is part of GNU CC.
 
@@ -18,16 +18,106 @@ along with GNU CC; see the file COPYING.  If not, write to
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
-/* Required to keep collect2.c happy */
-#undef OBJECT_FORMAT_COFF 
+#undef TARGET_VERSION
+#if TARGET_ENDIAN_DEFAULT == 0
+#define TARGET_VERSION fprintf (stderr, " (MIPSel GNU/Linux with ELF)");
+#else
+#define TARGET_VERSION fprintf (stderr, " (MIPS GNU/Linux with ELF)");
+#endif
+
+#undef MD_EXEC_PREFIX
+#undef MD_STARTFILE_PREFIX
 
-#define HAVE_ATEXIT
+/* Output at beginning of assembler file.  */
+/* The .file command should always begin the output.  */
+#undef ASM_FILE_START
+#define ASM_FILE_START(FILE)						\
+  do {									\
+	mips_asm_file_start (FILE);					\
+	fprintf (FILE, "\t.version\t\"01.01\"\n");			\
+  } while (0)
+
+
+/* Required to keep collect2.c happy */
+#undef OBJECT_FORMAT_COFF
 
 /* If we don't set MASK_ABICALLS, we can't default to PIC. */
 #undef TARGET_DEFAULT
 #define TARGET_DEFAULT (MASK_ABICALLS|MASK_GAS)
 
 
+/* Handle #pragma weak and #pragma pack.  */
+#define HANDLE_SYSV_PRAGMA 1
+
+/* Use more efficient ``thunks'' to implement C++ vtables. */
+#undef DEFAULT_VTABLE_THUNKS
+#define DEFAULT_VTABLE_THUNKS 1
+
+/* Don't assume anything about the header files.  */
+#define NO_IMPLICIT_EXTERN_C
+
+/* Generate calls to memcpy, etc., not bcopy, etc.  */
+#define TARGET_MEM_FUNCTIONS
+
+/* Specify predefined symbols in preprocessor.  */
+#undef CPP_PREDEFINES
+#if TARGET_ENDIAN_DEFAULT == 0
+#define CPP_PREDEFINES "-DMIPSEL -D_MIPSEL -Dunix -Dmips -D_mips \
+-DR3000 -D_R3000 -Dlinux -Asystem(posix) -Acpu(mips) \
+-Amachine(mips) -D__ELF__ -D__PIC__ -D__pic__"
+#else
+#define CPP_PREDEFINES "-DMIPSEB -D_MIPSEB -Dunix -Dmips -D_mips \
+-DR3000 -D_R3000 -Dlinux -Asystem(posix) -Acpu(mips) \
+-Amachine(mips) -D__ELF__ -D__PIC__ -D__pic__"
+#endif
+
+#undef SUBTARGET_CPP_SIZE_SPEC
+#define SUBTARGET_CPP_SIZE_SPEC "\
+%{mabi=32: -D__SIZE_TYPE__=unsigned\\ int -D__PTRDIFF_TYPE__=int} \
+%{mabi=n32: -D__SIZE_TYPE__=unsigned\\ int -D__PTRDIFF_TYPE__=int} \
+%{mabi=64: -D__SIZE_TYPE__=long\\ unsigned\\ int -D__PTRDIFF_TYPE__=long\\ int} \
+%{!mabi*: -D__SIZE_TYPE__=unsigned\\ int -D__PTRDIFF_TYPE__=int}"
+
+/* We must make -mips3 do what -mlong64 used to do.  */
+/* ??? If no mipsX option given, but a mabi=X option is, then should set
+   _MIPS_ISA based on the mabi=X option.  */
+/* ??? If no mabi=X option give, but a mipsX option is, then should set
+   _MIPS_SIM based on the mipsX option.  */
+/* ??? Same for _MIPS_SZINT.  */
+/* ??? Same for _MIPS_SZPTR.  */
+/* ??? Same for __SIZE_TYPE and __PTRDIFF_TYPE.  */
+#undef SUBTARGET_CPP_SPEC
+#define SUBTARGET_CPP_SPEC "\
+%{mfp32: -D_MIPS_FPSET=16} \
+%{mfp64: -D_MIPS_FPSET=32} \
+%{!mfp*: -D_MIPS_FPSET=32} \
+%{mips1: -D_MIPS_ISA=_MIPS_ISA_MIPS1} \
+%{mips2: -D_MIPS_ISA=_MIPS_ISA_MIPS2} \
+%{mips3: -D_MIPS_ISA=_MIPS_ISA_MIPS3} \
+%{mips4: -D_MIPS_ISA=_MIPS_ISA_MIPS4} \
+%{!mips*: -D_MIPS_ISA=_MIPS_ISA_MIPS1} \
+%{mabi=32: -D_MIPS_SIM=_MIPS_SIM_ABI32}	\
+%{mabi=n32: -D_ABIN32=2 -D_MIPS_SIM=_ABIN32} \
+%{mabi=64: -D_ABI64=3 -D_MIPS_SIM=_ABI64} \
+%{!mabi*: -D_MIPS_SIM=_MIPS_SIM_ABI32}	\
+%{!mint64: -D_MIPS_SZINT=32}%{mint64: -D_MIPS_SZINT=64} \
+%{mabi=32: -D_MIPS_SZLONG=32} \
+%{mabi=n32: -D_MIPS_SZLONG=32} \
+%{mabi=64: -D_MIPS_SZLONG=64} \
+%{!mabi*: -D_MIPS_SZLONG=32} \
+%{mabi=32: -D_MIPS_SZPTR=32} \
+%{mabi=n32: -D_MIPS_SZPTR=32} \
+%{mabi=64: -D_MIPS_SZPTR=64} \
+%{!mabi*: -D_MIPS_SZPTR=32} \
+%{!mips*: -U__mips -D__mips} \
+%{mabi=32: -U__mips64} \
+%{mabi=n32: -D__mips64} \
+%{mabi=64: -U__mips64} \
+%{!mabi*: -U__mips64} \
+%{fno-PIC:-U__PIC__ -U__pic__} %{fno-pic:-U__PIC__ -U__pic__} \
+%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} \
+%{pthread:-D_REENTRANT}"
+
 /* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add
    the GNU/Linux magical crtbegin.o file (see crtstuff.c) which
    provides part of the support for getting C++ file-scope static
@@ -55,9 +145,18 @@ Boston, MA 02111-1307, USA.  */
 #undef MIPS_DEFAULT_GVALUE
 #define MIPS_DEFAULT_GVALUE 0
 
+#undef LIB_SPEC
+/* Taken from sparc/linux.h.  */
+#define LIB_SPEC \
+  "%{shared: -lc} \
+   %{!shared: %{mieee-fp:-lieee} %{pthread:-lpthread} \
+     %{profile:-lc_p} %{!profile: -lc}}"
+
 /* Borrowed from sparc/linux.h */
 #undef LINK_SPEC
-#define LINK_SPEC "-Y P,/usr/lib %{shared:-shared} \
+#define LINK_SPEC \
+ "%(endian_spec) \
+  %{shared:-shared} \
   %{!shared: \
     %{!ibcs: \
       %{!static: \
@@ -67,33 +166,24 @@ Boston, MA 02111-1307, USA.  */
 
 
 #undef SUBTARGET_ASM_SPEC
-#define SUBTARGET_ASM_SPEC "-KPIC"
+#define SUBTARGET_ASM_SPEC "\
+%{mabi=64: -64} \
+%{!fno-PIC:%{!fno-pic:-KPIC}} \
+%{fno-PIC:-non_shared} %{fno-pic:-non_shared}"
 
-/* Undefine the following which were defined in elf.h.  This will cause the linux
-   port to continue to use collect2 for constructors/destructors.  These may be removed
-   when .ctor/.dtor section support is desired. */
+/* On svr4, we *do* have support for the .init and .fini sections, and we
+   can put stuff in there to be executed before and after `main'.  We let
+   crtstuff.c and other files know this by defining the following symbols.
+   The definitions say how to change sections to the .init and .fini
+   sections.  This is the same for all known svr4 assemblers.  */
 
-#undef CTORS_SECTION_ASM_OP
-#undef DTORS_SECTION_ASM_OP
-
-#undef EXTRA_SECTIONS
-#define EXTRA_SECTIONS in_sdata, in_rdata
-
-#undef INVOKE__main
-#undef NAME__MAIN
-#undef SYMBOL__MAIN
-
-#undef EXTRA_SECTION_FUNCTIONS
-#define EXTRA_SECTION_FUNCTIONS                                         \
-  SECTION_FUNCTION_TEMPLATE(sdata_section, in_sdata, SDATA_SECTION_ASM_OP) \
-  SECTION_FUNCTION_TEMPLATE(rdata_section, in_rdata, RDATA_SECTION_ASM_OP)
-
-#undef ASM_OUTPUT_CONSTRUCTOR
-#undef ASM_OUTPUT_DESTRUCTOR
+#define INIT_SECTION_ASM_OP     "\t.section\t.init"
+#define FINI_SECTION_ASM_OP     "\t.section\t.fini"
 
+/* Undef junk imported from mips/elf.h.  */
 #undef CTOR_LIST_BEGIN
 #undef CTOR_LIST_END
 #undef DTOR_LIST_BEGIN
 #undef DTOR_LIST_END
 
-/*  End of undefines to turn off .ctor/.dtor section support */
+#undef INVOKE__main
diff --git a/gcc/config/mips/mips.h b/gcc/config/mips/mips.h
index 7360e1b..93d24a5 100644
--- a/gcc/config/mips/mips.h
+++ b/gcc/config/mips/mips.h
@@ -599,11 +599,11 @@ extern void		mips_select_section ();
    linker will default to using big-endian output files.  The OUTPUT_FORMAT
    line must be in the linker script, otherwise -EB/-EL will not work.  */
 
-#ifndef LINKER_ENDIAN_SPEC
+#ifndef ENDIAN_SPEC
 #if TARGET_ENDIAN_DEFAULT == 0
-#define LINKER_ENDIAN_SPEC "%{!EB:%{!meb:-EL}}"
+#define ENDIAN_SPEC "%{!EB:%{!meb:-EL}} %{EL} %{EB}"
 #else
-#define LINKER_ENDIAN_SPEC ""
+#define ENDIAN_SPEC "%{!EL:%{!mel:-EB}} %{EB} %{EL}"
 #endif
 #endif
 
@@ -821,7 +821,7 @@ while (0)
 /* GAS_ASM_SPEC is passed when using gas, rather than the MIPS
    assembler.  */
 
-#define GAS_ASM_SPEC "%{mcpu=*} %{m4650} %{mmad:-m4650} %{m3900} %{v}"
+#define GAS_ASM_SPEC "%{mcpu=*} %{m4650} %{mmad} %{m3900} %{v}"
 
 /* TARGET_ASM_SPEC is used to select either MIPS_AS_ASM_SPEC or
    GAS_ASM_SPEC as the default, depending upon the value of
@@ -871,7 +871,8 @@ while (0)
 /* ASM_SPEC is the set of arguments to pass to the assembler.  */
 
 #define ASM_SPEC "\
-%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{mips4} \
+%(endian_spec) \
+%{G*} %{mips1} %{mips2} %{mips3} %{mips4} \
 %{mips16:%{!mno-mips16:-mips16}} %{mno-mips16:-no-mips16} \
 %(subtarget_asm_optimizing_spec) \
 %(subtarget_asm_debugging_spec) \
@@ -925,9 +926,9 @@ while (0)
 
 #ifndef LINK_SPEC
 #define LINK_SPEC "\
-%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{mips4} \
-%{bestGnum} %{shared} %{non_shared} \
-%(linker_endian_spec)"
+%(endian_spec) \
+%{G*} %{mips1} %{mips2} %{mips3} %{mips4} \
+%{bestGnum} %{shared} %{non_shared}"
 #endif	/* LINK_SPEC defined */
 
 /* Specs for the compiler proper */
@@ -1035,7 +1036,7 @@ while (0)
   { "subtarget_asm_optimizing_spec", SUBTARGET_ASM_OPTIMIZING_SPEC },	\
   { "subtarget_asm_debugging_spec", SUBTARGET_ASM_DEBUGGING_SPEC },	\
   { "subtarget_asm_spec", SUBTARGET_ASM_SPEC },				\
-  { "linker_endian_spec", LINKER_ENDIAN_SPEC },				\
+  { "endian_spec", ENDIAN_SPEC },					\
   SUBTARGET_EXTRA_SPECS
 
 #ifndef SUBTARGET_EXTRA_SPECS
@@ -1934,7 +1935,7 @@ extern enum reg_class mips_regno_to_class[];
 
 extern enum reg_class mips_char_to_class[];
 
-#define REG_CLASS_FROM_LETTER(C) mips_char_to_class[ (C) ]
+#define REG_CLASS_FROM_LETTER(C) mips_char_to_class[(unsigned char)(C)]
 
 /* The letters I, J, K, L, M, N, O, and P in a register constraint
    string can be used to stand for particular ranges of immediate
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index 81c5cd3..9eb53ab 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -2441,17 +2441,11 @@
     {
       if (GENERATE_BRANCHLIKELY)
 	{
-          if (GET_CODE (operands[1]) == CONST_INT)
-	    return \"%(beql\\t%0,$0,1f\\n\\tbreak\\t%2\\n1:%)\";
-	  else
-	    return \"%(beql\\t%0,%1,1f\\n\\tbreak\\t%2\\n1:%)\";
+	  return \"%(beql\\t%0,%z1,1f\\n\\tbreak\\t%2\\n1:%)\";
 	}
       else
 	{
-          if (GET_CODE (operands[1]) == CONST_INT)
-	    return \"%(bne\\t%0,$0,1f\\n\\tnop\\n\\tbreak\\t%2\\n1:%)\";
-	  else
-	    return \"%(bne\\t%0,%1,1f\\n\\tnop\\n\\tbreak\\t%2\\n1:%)\";
+	  return \"%(bne\\t%0,%z1,1f\\n\\tnop\\n\\tbreak\\t%2\\n1:%)\";
 	}
     }
   return \"\";
@@ -2485,10 +2479,7 @@
   if (! have_dep_anti)
     {
       /* No branch delay slots on mips16. */ 
-      if (GET_CODE (operands[1]) == CONST_INT)
-        return \"%(bnez\\t%0,1f\\n\\tbreak\\t%2\\n1:%)\";
-      else
-        return \"%(bne\\t%0,%1,1f\\n\\tbreak\\t%2\\n1:%)\";
+      return \"%(bne\\t%0,%z1,1f\\n\\tbreak\\t%2\\n1:%)\";
     }
   return \"\";
 }"
@@ -4678,7 +4669,7 @@ move\\t%0,%z4\\n\\
 
   if ((INTVAL (offset) & 3) == 0
       && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))
-    return \"sw\\t%1,%0\";
+    return \"sw\\t%z1,%0\";
 
   return \"usw\\t%z1,%0\";
 }"
@@ -4737,7 +4728,7 @@ move\\t%0,%z4\\n\\
 
   if ((INTVAL (offset) & 7) == 0
       && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))
-    return \"sd\\t%1,%0\";
+    return \"sd\\t%z1,%0\";
 
   return \"usd\\t%z1,%0\";
 }"
@@ -10083,6 +10074,21 @@ move\\t%0,%z4\\n\\
   [(set_attr "type" "move")
    (set_attr "mode" "SF")])
 
+(define_insn ""
+  [(set (match_operand:SF 0 "register_operand" "=f,f")
+	(if_then_else:SF
+	 (match_operator 4 "equality_op"
+			 [(match_operand:DI 1 "se_register_operand" "d,d")
+			  (const_int 0)])
+	 (match_operand:SF 2 "register_operand" "f,0")
+	 (match_operand:SF 3 "register_operand" "0,f")))]
+  "mips_isa >= 4 && TARGET_HARD_FLOAT"
+  "@
+    mov%B4.s\\t%0,%2,%1
+    mov%b4.s\\t%0,%3,%1"
+  [(set_attr "type" "move")
+   (set_attr "mode" "SF")])
+
 (define_insn ""
   [(set (match_operand:SF 0 "register_operand" "=f,f")
 	(if_then_else:SF
@@ -10114,6 +10120,21 @@ move\\t%0,%z4\\n\\
   [(set_attr "type" "move")
    (set_attr "mode" "DF")])
 
+(define_insn ""
+  [(set (match_operand:DF 0 "register_operand" "=f,f")
+	(if_then_else:DF
+	 (match_operator 4 "equality_op"
+			 [(match_operand:DI 1 "se_register_operand" "d,d")
+			  (const_int 0)])
+	 (match_operand:DF 2 "register_operand" "f,0")
+	 (match_operand:DF 3 "register_operand" "0,f")))]
+  "mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT"
+  "@
+    mov%B4.d\\t%0,%2,%1
+    mov%b4.d\\t%0,%3,%1"
+  [(set_attr "type" "move")
+   (set_attr "mode" "DF")])
+
 (define_insn ""
   [(set (match_operand:DF 0 "register_operand" "=f,f")
 	(if_then_else:DF
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index 23a9715..38b465a 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -3759,7 +3759,7 @@
     FAIL;
   switch (code)
     {
-    case GE: case EQ: case NE:
+    case GE: case EQ:
       op0 = rs6000_compare_op0;
       op1 = rs6000_compare_op1;
       break;
@@ -3790,11 +3790,6 @@
 	  emit_insn (gen_negdf2 (temp, temp));
 	  emit_insn (gen_fseldfsf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negdf2 (temp, temp));
-	  emit_insn (gen_fseldfsf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   else
     {
@@ -3806,11 +3801,6 @@
 	  emit_insn (gen_negsf2 (temp, temp));
 	  emit_insn (gen_fselsfsf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negsf2 (temp, temp));
-	  emit_insn (gen_fselsfsf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   DONE;
 }")
@@ -4006,7 +3996,7 @@
     FAIL;
   switch (code)
     {
-    case GE: case EQ: case NE:
+    case GE: case EQ:
       op0 = rs6000_compare_op0;
       op1 = rs6000_compare_op1;
       break;
@@ -4037,11 +4027,6 @@
 	  emit_insn (gen_negdf2 (temp, temp));
 	  emit_insn (gen_fseldfdf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negdf2 (temp, temp));
-	  emit_insn (gen_fseldfdf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   else
     {
@@ -4053,11 +4038,6 @@
 	  emit_insn (gen_negsf2 (temp, temp));
 	  emit_insn (gen_fselsfdf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negsf2 (temp, temp));
-	  emit_insn (gen_fselsfdf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   DONE;
 }")
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 58e882c..315a35a 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -2899,6 +2899,11 @@
          crashes in output_constant_pool.  */
       if (operands [1] == const0_rtx)
         operands[1] = CONST0_RTX (SFmode);
+      /* We are able to build any SF constant in integer registers
+	 with at most 2 instructions.  */
+      if (REGNO (operands[0]) < 32)
+	goto movsf_is_ok;
+
       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),
                                                    operands[1]));
     }
@@ -3093,6 +3098,9 @@
          crashes in output_constant_pool.  */
       if (operands [1] == const0_rtx)
         operands[1] = CONST0_RTX (DFmode);
+      if (REGNO (operands[0]) < 32)
+	goto movdf_is_ok;
+
       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),
                                                    operands[1]));
     }
@@ -3277,17 +3285,11 @@
 (define_split
   [(set (match_operand:DF 0 "register_operand" "")
 	(match_operand:DF 1 "memory_operand" ""))]
-  "((! TARGET_V9
-     || (! TARGET_ARCH64
-         && ((GET_CODE (operands[0]) == REG
-              && REGNO (operands[0]) < 32)
-             || (GET_CODE (operands[0]) == SUBREG
-                 && GET_CODE (SUBREG_REG (operands[0])) == REG
-                 && REGNO (SUBREG_REG (operands[0])) < 32))))
-    && (reload_completed
-        && (((REGNO (operands[0])) % 2) != 0
-             || ! mem_min_alignment (operands[1], 8))
-        && offsettable_memref_p (operands[1])))"
+  "reload_completed
+   && ! TARGET_ARCH64
+   && (((REGNO (operands[0]) % 2) != 0)
+       || ! mem_min_alignment (operands[1], 8))
+   && offsettable_memref_p (operands[1])"
   [(clobber (const_int 0))]
   "
 {
@@ -3318,17 +3320,11 @@
 (define_split
   [(set (match_operand:DF 0 "memory_operand" "")
 	(match_operand:DF 1 "register_operand" ""))]
-  "((! TARGET_V9
-     || (! TARGET_ARCH64
-         && ((GET_CODE (operands[1]) == REG
-              && REGNO (operands[1]) < 32)
-             || (GET_CODE (operands[1]) == SUBREG
-                 && GET_CODE (SUBREG_REG (operands[1])) == REG
-                 && REGNO (SUBREG_REG (operands[1])) < 32))))
-    && (reload_completed
-        && (((REGNO (operands[1])) % 2) != 0
-             || ! mem_min_alignment (operands[0], 8))
-        && offsettable_memref_p (operands[0])))"
+  "reload_completed
+   && ! TARGET_ARCH64
+   && (((REGNO (operands[1]) % 2) != 0)
+       || ! mem_min_alignment (operands[0], 8))
+   && offsettable_memref_p (operands[0])"
   [(clobber (const_int 0))]
   "
 {
@@ -5211,7 +5207,7 @@
 (define_insn "muldi3_v8plus"
   [(set (match_operand:DI 0 "register_operand" "=r,h")
 	(mult:DI (match_operand:DI 1 "arith_double_operand" "%r,0")
-		 (match_operand:DI 2 "arith_double_operand" "rHI,rHI")))
+		 (match_operand:DI 2 "arith_double_operand" "rI,rI")))
    (clobber (match_scratch:SI 3 "=&h,X"))
    (clobber (match_scratch:SI 4 "=&h,X"))]
   "TARGET_V8PLUS"
@@ -5221,6 +5217,13 @@
     output_asm_insn (\"srl\\t%L1, 0, %L1\", operands);
   if (which_alternative == 1)
     output_asm_insn (\"sllx\\t%H1, 32, %H1\", operands);
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      if (which_alternative == 1)
+	return \"or\\t%L1, %H1, %H1\\n\\tmulx\\t%H1, %2, %L0\;srlx\\t%L0, 32, %H0\";
+      else
+	return \"sllx\\t%H1, 32, %3\\n\\tor\\t%L1, %3, %3\\n\\tmulx\\t%3, %2, %3\\n\\tsrlx\\t%3, 32, %H0\\n\\tmov\\t%3, %L0\";
+    }
   if (sparc_check_64 (operands[2], insn) <= 0)
     output_asm_insn (\"srl\\t%L2, 0, %L2\", operands);
   if (which_alternative == 1)
diff --git a/gcc/configure.in b/gcc/configure.in
index 55dcec7..890db32 100644
--- a/gcc/configure.in
+++ b/gcc/configure.in
@@ -2368,16 +2368,23 @@ changequote([,])dnl
 		# On NetBSD, the headers are already okay, except for math.h.
 		tmake_file=t-netbsd
 		;;
-       mips*-*-linux*)                         # Linux MIPS, either endian.
+	mips*-*-linux*)				# Linux MIPS, either endian.
 		xmake_file=x-linux
-		xm_file="xm-siglist.h ${xm_file}"
-               case $machine in
-                       mipsel-*)  tm_file="mips/elfl.h mips/linux.h" ;;
-                       *)         tm_file="mips/elf.h mips/linux.h" ;;
-               esac
-		extra_parts="crtbegin.o crtend.o"
+		case $machine in
+			mips*el-*)
+				tm_file="mips/elfl.h mips/linux.h"
+				;;
+			*)
+				tm_file="mips/elf.h mips/linux.h"
+				;;
+		esac
+		tmake_file=t-linux
+		extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
 		gnu_ld=yes
 		gas=yes
+		if test x$enable_threads = xyes; then
+			thread_file='posix'
+		fi
 		;;
 	mips*el-*-openbsd*)	# mips little endian
 		target_cpu_default="MASK_GAS|MASK_ABICALLS"
diff --git a/gcc/except.c b/gcc/except.c
index f7d78d6..9075226 100644
--- a/gcc/except.c
+++ b/gcc/except.c
@@ -723,21 +723,41 @@ static void
 receive_exception_label (handler_label)
      rtx handler_label;
 {
+  rtx around_label = NULL_RTX;
+
+  if (! flag_new_exceptions || exceptions_via_longjmp)
+    {
+      around_label = gen_label_rtx ();
+      emit_jump (around_label);
+      emit_barrier ();
+    }
+
   emit_label (handler_label);
-  
-#ifdef HAVE_exception_receiver
+
   if (! exceptions_via_longjmp)
-    if (HAVE_exception_receiver)
-      emit_insn (gen_exception_receiver ());
+    {
+#ifdef HAVE_exception_receiver
+      if (HAVE_exception_receiver)
+	emit_insn (gen_exception_receiver ());
+      else
 #endif
-
 #ifdef HAVE_nonlocal_goto_receiver
-  if (! exceptions_via_longjmp)
-    if (HAVE_nonlocal_goto_receiver)
-      emit_insn (gen_nonlocal_goto_receiver ());
+      if (HAVE_nonlocal_goto_receiver)
+	emit_insn (gen_nonlocal_goto_receiver ());
+      else
 #endif
-}
+	{ /* Nothing */ }
+    }
+  else
+    {
+#ifndef DONT_USE_BUILTIN_SETJMP
+      expand_builtin_setjmp_receiver (handler_label);
+#endif
+    }
 
+  if (around_label)
+    emit_label (around_label);
+}
 
 struct func_eh_entry 
 {
@@ -1320,7 +1340,7 @@ static void
 start_dynamic_handler ()
 {
   rtx dhc, dcc;
-  rtx x, arg, buf;
+  rtx arg, buf;
   int size;
 
 #ifndef DONT_USE_BUILTIN_SETJMP
@@ -1362,18 +1382,17 @@ start_dynamic_handler ()
   buf = plus_constant (XEXP (arg, 0), GET_MODE_SIZE (Pmode)*2);
 
 #ifdef DONT_USE_BUILTIN_SETJMP
-  x = emit_library_call_value (setjmp_libfunc, NULL_RTX, 1, SImode, 1,
-			       buf, Pmode);
-  /* If we come back here for a catch, transfer control to the handler.  */
-  jumpif_rtx (x, ehstack.top->entry->exception_handler_label);
-#else
   {
-    /* A label to continue execution for the no exception case.  */
-    rtx noex = gen_label_rtx();
-    x = expand_builtin_setjmp (buf, NULL_RTX, noex,
-			       ehstack.top->entry->exception_handler_label);
-    emit_label (noex);
+    rtx x;
+    x = emit_library_call_value (setjmp_libfunc, NULL_RTX, LCT_CONST,
+                                TYPE_MODE (integer_type_node), 1,
+                                buf, Pmode);
+    /* If we come back here for a catch, transfer control to the handler.  */
+    jumpif_rtx (x, ehstack.top->entry->exception_handler_label);
   }
+#else
+  expand_builtin_setjmp_setup (buf,
+                              ehstack.top->entry->exception_handler_label);
 #endif
 
   /* We are committed to this, so update the handler chain.  */
diff --git a/gcc/expr.c b/gcc/expr.c
index e3fe1f8..ef16c76 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -192,6 +192,7 @@ static rtx expand_builtin	PROTO((tree, rtx, rtx,
 static int apply_args_size	PROTO((void));
 static int apply_result_size	PROTO((void));
 static rtx result_vector	PROTO((int, rtx));
+static rtx expand_builtin_setjmp PROTO((tree, rtx));
 static rtx expand_builtin_apply_args PROTO((void));
 static rtx expand_builtin_apply	PROTO((rtx, rtx, rtx));
 static void expand_builtin_return PROTO((rtx));
@@ -449,6 +450,9 @@ protect_from_queue (x, modify)
 				QUEUED_INSN (y));
 	      return temp;
 	    }
+	  /* Copy the address into a pseudo, so that the returned value
+	     remains correct across calls to emit_queue.  */
+	  XEXP (new, 0) = copy_to_reg (XEXP (new, 0));
 	  return new;
 	}
       /* Otherwise, recursively protect the subexpressions of all
@@ -475,9 +479,11 @@ protect_from_queue (x, modify)
 	}
       return x;
     }
-  /* If the increment has not happened, use the variable itself.  */
+  /* If the increment has not happened, use the variable itself.  Copy it
+     into a new pseudo so that the value remains correct across calls to
+     emit_queue.  */
   if (QUEUED_INSN (x) == 0)
-    return QUEUED_VAR (x);
+    return copy_to_reg (QUEUED_VAR (x));
   /* If the increment has happened and a pre-increment copy exists,
      use that copy.  */
   if (QUEUED_COPY (x) != 0)
@@ -8076,7 +8082,9 @@ expand_expr (exp, target, tmode, modifier)
 	  if (ignore)
 	    return op0;
 
-	  op0 = protect_from_queue (op0, 0);
+	  /* Pass 1 for MODIFY, so that protect_from_queue doesn't get
+	     clever and returns a REG when given a MEM.  */
+	  op0 = protect_from_queue (op0, 1);
 
 	  /* We would like the object in memory.  If it is a constant,
 	     we can have it be statically allocated into memory.  For
@@ -8544,44 +8552,29 @@ expand_builtin_return_addr (fndecl_code, count, tem)
   return tem;
 }
 
-/* __builtin_setjmp is passed a pointer to an array of five words (not
-   all will be used on all machines).  It operates similarly to the C
-   library function of the same name, but is more efficient.  Much of
-   the code below (and for longjmp) is copied from the handling of
-   non-local gotos.
-
-   NOTE: This is intended for use by GNAT and the exception handling
-   scheme in the compiler and will only work in the method used by
-   them.  */
+/* Construct the leading half of a __builtin_setjmp call.  Control will
+   return to RECEIVER_LABEL.  This is used directly by sjlj exception
+   handling code.  */
 
-rtx
-expand_builtin_setjmp (buf_addr, target, first_label, next_label)
+void
+expand_builtin_setjmp_setup (buf_addr, receiver_label)
      rtx buf_addr;
-     rtx target;
-     rtx first_label, next_label;
+     rtx receiver_label;
 {
-  rtx lab1 = gen_label_rtx ();
   enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);
-  enum machine_mode value_mode;
   rtx stack_save;
 
-  value_mode = TYPE_MODE (integer_type_node);
-
 #ifdef POINTERS_EXTEND_UNSIGNED
   buf_addr = convert_memory_address (Pmode, buf_addr);
 #endif
 
   buf_addr = force_reg (Pmode, buf_addr);
 
-  if (target == 0 || GET_CODE (target) != REG
-      || REGNO (target) < FIRST_PSEUDO_REGISTER)
-    target = gen_reg_rtx (value_mode);
-
   emit_queue ();
 
-  /* We store the frame pointer and the address of lab1 in the buffer
-     and use the rest of it for the stack save area, which is
-     machine-dependent.  */
+  /* We store the frame pointer and the address of receiver_label in
+     the buffer and use the rest of it for the stack save area, which
+     is machine-dependent.  */
 
 #ifndef BUILTIN_SETJMP_FRAME_VALUE
 #define BUILTIN_SETJMP_FRAME_VALUE virtual_stack_vars_rtx
@@ -8593,7 +8586,7 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
 		  (gen_rtx_MEM (Pmode,
 				plus_constant (buf_addr,
 					       GET_MODE_SIZE (Pmode)))),
-		  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, lab1)));
+		  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, receiver_label)));
 
   stack_save = gen_rtx_MEM (sa_mode,
 			    plus_constant (buf_addr,
@@ -8606,20 +8599,22 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
     emit_insn (gen_builtin_setjmp_setup (buf_addr));
 #endif
 
-  /* Set TARGET to zero and branch to the first-time-through label.  */
-  emit_move_insn (target, const0_rtx);
-  emit_jump_insn (gen_jump (first_label));
-  emit_barrier ();
-  emit_label (lab1);
-
-  /* Tell flow about the strange goings on.  Putting `lab1' on
-     `nonlocal_goto_handler_labels' to indicates that function
-     calls may traverse the arc back to this label.  */
+  /* Tell optimize_save_area_alloca that extra work is going to
+     need to go on during alloca.  */
+  current_function_calls_setjmp = 1;
 
+  /* Set this so all the registers get saved in our frame; we need to be
+     able to copy the saved values for any registers from frames we unwind. */
   current_function_has_nonlocal_label = 1;
-  nonlocal_goto_handler_labels =
-    gen_rtx_EXPR_LIST (VOIDmode, lab1, nonlocal_goto_handler_labels);
+}
+
+/* Construct the trailing part of a __builtin_setjmp call.
+   This is used directly by sjlj exception handling code.  */
 
+void
+expand_builtin_setjmp_receiver (receiver_label)
+      rtx receiver_label ATTRIBUTE_UNUSED;
+{
   /* Clobber the FP when we get here, so we have to make sure it's
      marked as used by this function.  */
   emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));
@@ -8666,7 +8661,7 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
 
 #ifdef HAVE_builtin_setjmp_receiver
   if (HAVE_builtin_setjmp_receiver)
-    emit_insn (gen_builtin_setjmp_receiver (lab1));
+    emit_insn (gen_builtin_setjmp_receiver (receiver_label));
   else
 #endif
 #ifdef HAVE_nonlocal_goto_receiver
@@ -8678,10 +8673,66 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
 	; /* Nothing */
       }
 
-  /* Set TARGET, and branch to the next-time-through label.  */
-  emit_move_insn (target, const1_rtx);
-  emit_jump_insn (gen_jump (next_label));
+  /* @@@ This is a kludge.  Not all machine descriptions define a blockage
+     insn, but we must not allow the code we just generated to be reordered
+     by scheduling.  Specifically, the update of the frame pointer must
+     happen immediately, not later.  So emit an ASM_INPUT to act as blockage
+     insn.  */
+  emit_insn (gen_rtx_ASM_INPUT (VOIDmode, ""));
+}
+
+
+/* __builtin_setjmp is passed a pointer to an array of five words (not
+   all will be used on all machines).  It operates similarly to the C
+   library function of the same name, but is more efficient.  Much of
+   the code below (and for longjmp) is copied from the handling of
+   non-local gotos.
+
+   NOTE: This is intended for use by GNAT and the exception handling
+   scheme in the compiler and will only work in the method used by
+   them.  */
+
+static rtx
+expand_builtin_setjmp (arglist, target)
+     tree arglist;
+     rtx target;
+{
+  rtx buf_addr, next_lab, cont_lab;
+
+  if (arglist == 0
+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)
+    return NULL_RTX;
+
+  if (target == 0 || GET_CODE (target) != REG
+      || REGNO (target) < FIRST_PSEUDO_REGISTER)
+    target = gen_reg_rtx (TYPE_MODE (integer_type_node));
+
+  buf_addr = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);
+
+  next_lab = gen_label_rtx ();
+  cont_lab = gen_label_rtx ();
+
+  expand_builtin_setjmp_setup (buf_addr, next_lab);
+
+  /* Set TARGET to zero and branch to the continue label.  */
+  emit_move_insn (target, const0_rtx);
+  emit_jump_insn (gen_jump (cont_lab));
   emit_barrier ();
+  emit_label (next_lab);
+
+  expand_builtin_setjmp_receiver (next_lab);
+
+  /* Set TARGET to one.  */
+  emit_move_insn (target, const1_rtx);
+  emit_label (cont_lab);
+
+  /* Tell flow about the strange goings on.  Putting `next_lab' on
+     `nonlocal_goto_handler_labels' to indicates that function
+     calls may traverse the arc back to this label.  */
+
+  current_function_has_nonlocal_label = 1;
+  nonlocal_goto_handler_labels
+    = gen_rtx_EXPR_LIST (VOIDmode, next_lab, nonlocal_goto_handler_labels);
 
   return target;
 }
@@ -9703,18 +9754,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)
 #endif
 
     case BUILT_IN_SETJMP:
-      if (arglist == 0
-	  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)
-	break;
-      else
-	{
-	  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,
-				      VOIDmode, 0);
-	  rtx lab = gen_label_rtx ();
-	  rtx ret = expand_builtin_setjmp (buf_addr, target, lab, lab);
-	  emit_label (lab);
-	  return ret;
-	}
+      target = expand_builtin_setjmp (arglist, target);
+      if (target)
+	return target;
+      break;
 
       /* __builtin_longjmp is passed a pointer to an array of five words.
 	 It's similar to the C library longjmp function but works with
diff --git a/gcc/expr.h b/gcc/expr.h
index 55e82e6..c279774 100644
--- a/gcc/expr.h
+++ b/gcc/expr.h
@@ -831,7 +831,8 @@ extern rtx store_expr PROTO((tree, rtx, int));
    Useful after calling expand_expr with 1 as sum_ok.  */
 extern rtx force_operand PROTO((rtx, rtx));
 
-extern rtx expand_builtin_setjmp PROTO((rtx, rtx, rtx, rtx));
+extern void expand_builtin_setjmp_setup PARAMS ((rtx, rtx));
+extern void expand_builtin_setjmp_receiver PARAMS ((rtx));
 
 #ifdef TREE_CODE
 /* Generate code for computing expression EXP.
diff --git a/gcc/final.c b/gcc/final.c
index 11cfebf..7a31cde 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -1701,7 +1701,9 @@ static void
 profile_function (file)
      FILE *file;
 {
+#ifndef NO_PROFILE_COUNTERS
   int align = MIN (BIGGEST_ALIGNMENT, LONG_TYPE_SIZE);
+#endif
 #if defined(ASM_OUTPUT_REG_PUSH)
 #if defined(STRUCT_VALUE_INCOMING_REGNUM) || defined(STRUCT_VALUE_REGNUM)
   int sval = current_function_returns_struct;
@@ -1711,10 +1713,12 @@ profile_function (file)
 #endif
 #endif /* ASM_OUTPUT_REG_PUSH */
 
+#ifndef NO_PROFILE_COUNTERS
   data_section ();
   ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));
   ASM_OUTPUT_INTERNAL_LABEL (file, "LP", profile_label_no);
   assemble_integer (const0_rtx, LONG_TYPE_SIZE / BITS_PER_UNIT, 1);
+#endif
 
   function_section (current_function_decl);
 
@@ -3043,7 +3047,8 @@ cleanup_subreg_operands (insn)
       if (GET_CODE (recog_operand[i]) == SUBREG)
         recog_operand[i] = alter_subreg (recog_operand[i]);
       else if (GET_CODE (recog_operand[i]) == PLUS
-               || GET_CODE (recog_operand[i]) == MULT)
+               || GET_CODE (recog_operand[i]) == MULT
+	       || GET_CODE (recog_operand[i]) == MEM)
        recog_operand[i] = walk_alter_subreg (recog_operand[i]);
     }
 
@@ -3052,7 +3057,8 @@ cleanup_subreg_operands (insn)
       if (GET_CODE (*recog_dup_loc[i]) == SUBREG)
         *recog_dup_loc[i] = alter_subreg (*recog_dup_loc[i]);
       else if (GET_CODE (*recog_dup_loc[i]) == PLUS
-               || GET_CODE (*recog_dup_loc[i]) == MULT)
+               || GET_CODE (*recog_dup_loc[i]) == MULT
+	       || GET_CODE (*recog_dup_loc[i]) == MEM)
         *recog_dup_loc[i] = walk_alter_subreg (*recog_dup_loc[i]);
     }
 }
diff --git a/gcc/flow.c b/gcc/flow.c
index 432a990..f3b3213 100644
--- a/gcc/flow.c
+++ b/gcc/flow.c
@@ -2744,15 +2744,23 @@ propagate_block (old, first, last, final, significant, bnum, remove_dead_code)
 		{
 		  if (REG_NOTE_KIND (inote) == REG_LABEL)
 		    {
+		      int n_forced;
 		      rtx label = XEXP (inote, 0);
 		      rtx next;
 		      LABEL_NUSES (label)--;
 
+		      /* The label may be forced if it has been put in the
+		         constant pool.  We can't delete it in this case, but
+		         we still must discard a jump table following it.  */
+		      n_forced = 0;
+		      if (LABEL_PRESERVE_P (label))
+			n_forced++;
+
 		      /* If this label was attached to an ADDR_VEC, it's
 			 safe to delete the ADDR_VEC.  In fact, it's pretty much
 			 mandatory to delete it, because the ADDR_VEC may
 			 be referencing labels that no longer exist.  */
-		      if (LABEL_NUSES (label) == 0
+		      if (LABEL_NUSES (label) == n_forced
 			  && (next = next_nonnote_insn (label)) != NULL
 			  && GET_CODE (next) == JUMP_INSN
 			  && (GET_CODE (PATTERN (next)) == ADDR_VEC
diff --git a/gcc/frame.c b/gcc/frame.c
index 990a0ac..b3f6d29 100644
--- a/gcc/frame.c
+++ b/gcc/frame.c
@@ -51,11 +51,7 @@ Boston, MA 02111-1307, USA.  */
 #include "frame.h"
 #include "gthr.h"
 
-#ifdef __GTHREAD_MUTEX_INIT
-static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;
-#else
 static __gthread_mutex_t object_mutex;
-#endif
 
 /* Don't use `fancy_abort' here even if config.h says to use it.  */
 #ifdef abort
diff --git a/gcc/gcc.c b/gcc/gcc.c
index d4dbf5e..c5a312d 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -5040,48 +5040,53 @@ main (argc, argv)
 	  int len;
 
 	  if (cp->spec[0][0] == '#')
-	    error ("%s: %s compiler not installed on this system",
-		   input_filename, &cp->spec[0][1]);
-
-	  input_basename = input_filename;
-	  for (p = input_filename; *p; p++)
-	    if (IS_DIR_SEPARATOR (*p))
-	      input_basename = p + 1;
-
-	  /* Find a suffix starting with the last period,
-	     and set basename_length to exclude that suffix.  */
-	  basename_length = strlen (input_basename);
-	  p = input_basename + basename_length;
-	  while (p != input_basename && *p != '.') --p;
-	  if (*p == '.' && p != input_basename)
 	    {
-	      basename_length = p - input_basename;
-	      input_suffix = p + 1;
+	      error ("%s: %s compiler not installed on this system",
+		     input_filename, &cp->spec[0][1]);
+	      this_file_error = 1;
 	    }
 	  else
-	    input_suffix = "";
+	    {
+	      input_basename = input_filename;
+	      for (p = input_filename; *p; p++)
+		if (IS_DIR_SEPARATOR (*p))
+		  input_basename = p + 1;
+
+	      /* Find a suffix starting with the last period,
+		 and set basename_length to exclude that suffix.  */
+	      basename_length = strlen (input_basename);
+	      p = input_basename + basename_length;
+	      while (p != input_basename && *p != '.') --p;
+	      if (*p == '.' && p != input_basename)
+		{
+		  basename_length = p - input_basename;
+		  input_suffix = p + 1;
+		}
+	      else
+		input_suffix = "";
 
-	  len = 0;
-	  for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
-	    if (cp->spec[j])
-	      len += strlen (cp->spec[j]);
+	      len = 0;
+	      for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
+		if (cp->spec[j])
+		  len += strlen (cp->spec[j]);
 
-	  {
-	    char *p1 = (char *) xmalloc (len + 1);
+	      {
+		char *p1 = (char *) xmalloc (len + 1);
 	    
-	    len = 0;
-	    for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
-	      if (cp->spec[j])
-		{
-		  strcpy (p1 + len, cp->spec[j]);
-		  len += strlen (cp->spec[j]);
-		}
+		len = 0;
+		for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
+		  if (cp->spec[j])
+		    {
+		      strcpy (p1 + len, cp->spec[j]);
+		      len += strlen (cp->spec[j]);
+		    }
 	    
-	    value = do_spec (p1);
-	    free (p1);
-	  }
-	  if (value < 0)
-	    this_file_error = 1;
+		value = do_spec (p1);
+		free (p1);
+	      }
+	      if (value < 0)
+		this_file_error = 1;
+	    }
 	}
 
       /* If this file's name does not contain a recognized suffix,
diff --git a/gcc/gcse.c b/gcc/gcse.c
index cddd7ac..f72f075 100644
--- a/gcc/gcse.c
+++ b/gcc/gcse.c
@@ -1856,7 +1856,9 @@ hash_scan_set (pat, insn, set_p)
 	  /* Don't GCSE something if we can't do a reg/reg copy.  */
 	  && can_copy_p [GET_MODE (dest)]
 	  /* Is SET_SRC something we want to gcse?  */
-	  && want_to_gcse_p (src))
+	  && want_to_gcse_p (src)
+	  /* Copy between modes is prohibited */
+	  && GET_MODE (src) == GET_MODE (dest))
 	{
 	  /* An expression is not anticipatable if its operands are
 	     modified before this insn.  */
diff --git a/gcc/install.texi b/gcc/install.texi
index ac360e9..a667df6 100644
--- a/gcc/install.texi
+++ b/gcc/install.texi
@@ -1596,7 +1596,7 @@ linker that are fixed by using the GNU versions of these tools.
 Embedded PowerPC system in little endian mode for use in running under
 the PSIM simulator.
 
-@itemx powerpcle-*-eabi
+@item powerpcle-*-eabi
 Embedded PowerPC system in little endian mode.
 
 You can specify a default version for the @samp{-mcpu=}@var{cpu_type}
diff --git a/gcc/invoke.texi b/gcc/invoke.texi
index e97495e..9865a34 100644
--- a/gcc/invoke.texi
+++ b/gcc/invoke.texi
@@ -1694,6 +1694,12 @@ A @code{switch} statement has an operand of type @code{long}.
 @item
 A non-@code{static} function declaration follows a @code{static} one.
 This construct is not accepted by some traditional C compilers.
+
+@item
+The ANSI type of an integer constant has a different width or signedness
+from its traditional type.  This warning is only issued if the base of
+the constant is ten.  I.e. hexadecimal or octal values, which typically
+represent bit patterns, are not warned about.
 @end itemize
 
 @item -Wundef
diff --git a/gcc/jump.c b/gcc/jump.c
index 32eebd1..6e7e905 100644
--- a/gcc/jump.c
+++ b/gcc/jump.c
@@ -200,8 +200,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)
   if (flag_exceptions && cross_jump)
     init_insn_eh_region (f, max_uid);
 
-  delete_barrier_successors (f);
-
   /* Leave some extra room for labels and duplicate exit test insns
      we make.  */
   max_jump_chain = max_uid * 14 / 10;
@@ -224,6 +222,8 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)
   for (insn = exception_handler_labels; insn; insn = XEXP (insn, 1))
     LABEL_NUSES (XEXP (insn, 0))++;
 
+  delete_barrier_successors (f);
+
   /* Quit now if we just wanted to rebuild the JUMP_LABEL and REG_LABEL
      notes and recompute LABEL_NUSES.  */
   if (mark_labels_only)
@@ -2139,7 +2139,24 @@ delete_barrier_successors (f)
 	  insn = NEXT_INSN (insn);
 	  while (insn != 0 && GET_CODE (insn) != CODE_LABEL)
 	    {
-	      if (GET_CODE (insn) == NOTE
+	      if (GET_CODE (insn) == JUMP_INSN)
+		{
+		  /* Detect when we're deleting a tablejump; get rid of
+		     the jump table as well.  */
+		  rtx next1 = next_nonnote_insn (insn);
+		  rtx next2 = next1 ? next_nonnote_insn (next1) : 0;
+		  if (next2 && GET_CODE (next1) == CODE_LABEL
+		      && GET_CODE (next2) == JUMP_INSN
+		      && (GET_CODE (PATTERN (next2)) == ADDR_VEC
+			  || GET_CODE (PATTERN (next2)) == ADDR_DIFF_VEC))
+		    {
+		      delete_insn (insn);
+		      insn = next2;
+		    }
+		  else
+		    insn = delete_insn (insn);
+		}
+	      else if (GET_CODE (insn) == NOTE
 		  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END)
 		insn = NEXT_INSN (insn);
 	      else
diff --git a/gcc/regmove.c b/gcc/regmove.c
index 8008595..27c6d4a 100644
--- a/gcc/regmove.c
+++ b/gcc/regmove.c
@@ -693,6 +693,9 @@ optimize_reg_copy_3 (insn, dest, src)
     }
   if (! (set = single_set (p))
       || GET_CODE (SET_SRC (set)) != MEM
+      /* If there's a REG_EQUIV note, this must be an insn that loads an
+	 argument.  Prefer keeping the note over doing this optimization.  */
+      || find_reg_note (p, REG_EQUIV, NULL_RTX)
       || SET_DEST (set) != src_reg)
     return;
 
@@ -737,6 +740,12 @@ optimize_reg_copy_3 (insn, dest, src)
       PUT_MODE (src_reg, old_mode);
       XEXP (src, 0) = src_reg;
     }
+  else
+    {
+      rtx note = find_reg_note (p, REG_EQUAL, NULL_RTX);
+      if (note)
+	remove_note (p, note);
+    }
 }
 
 
diff --git a/gcc/reload1.c b/gcc/reload1.c
index e95ff5e..24eb011 100644
--- a/gcc/reload1.c
+++ b/gcc/reload1.c
@@ -4278,9 +4278,6 @@ reload_as_needed (live_known)
 			    spill_reg_order);
 	    }
 
-	  if (num_eliminable && chain->need_elim)
-	    update_eliminable_offsets ();
-
 	  if (n_reloads > 0)
 	    {
 	      rtx next = NEXT_INSN (insn);
@@ -4327,6 +4324,10 @@ reload_as_needed (live_known)
 		      NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;
 		    }
 	    }
+
+	  if (num_eliminable && chain->need_elim)
+	    update_eliminable_offsets ();
+
 	  /* Any previously reloaded spilled pseudo reg, stored in this insn,
 	     is no longer validly lying around to save a future reload.
 	     Note that this does not detect pseudos that were reloaded
@@ -8071,7 +8072,9 @@ delete_output_reload (insn, j, last_reload_reg)
     }
   n_occurrences = count_occurrences (PATTERN (insn), reg);
   if (substed)
-    n_occurrences += count_occurrences (PATTERN (insn), substed);
+    n_occurrences += count_occurrences (PATTERN (insn),
+					eliminate_regs (substed, 0,
+							NULL_RTX));
   if (n_occurrences > n_inherited)
     return;
 
@@ -9967,6 +9970,21 @@ reload_combine_note_use (xp, insn)
 	}
       break;
 
+    case USE:
+      /* If this is the USE of a return value, we can't change it.  */
+      if (GET_CODE (XEXP (x, 0)) == REG && REG_FUNCTION_VALUE_P (XEXP (x, 0)))
+	{
+	/* Mark the return register as used in an unknown fashion.  */
+	  rtx reg = XEXP (x, 0);
+	  int regno = REGNO (reg);
+	  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));
+
+	  while (--nregs >= 0)
+	    reg_state[regno + nregs].use_index = -1;
+	  return;
+	}
+      break;
+
     case CLOBBER:
       if (GET_CODE (SET_DEST (x)) == REG)
 	return;
@@ -9983,12 +10001,23 @@ reload_combine_note_use (xp, insn)
       {
 	int regno = REGNO (x);
 	int use_index;
+	int nregs;
 
 	/* Some spurious USEs of pseudo registers might remain.
 	   Just ignore them.  */
 	if (regno >= FIRST_PSEUDO_REGISTER)
 	  return;
 
+	nregs = HARD_REGNO_NREGS (regno, GET_MODE (x));
+
+	/* We can't substitute into multi-hard-reg uses.  */
+	if (nregs > 1)
+	  {
+	    while (--nregs >= 0)
+	      reg_state[regno + nregs].use_index = -1;
+	    return;
+	  }
+
 	/* If this register is already used in some unknown fashion, we
 	   can't do anything.
 	   If we decrement the index from zero to -1, we can't store more
diff --git a/gcc/tm.texi b/gcc/tm.texi
index a13c6d9..484c73c 100644
--- a/gcc/tm.texi
+++ b/gcc/tm.texi
@@ -3464,6 +3464,13 @@ figure them out, compile a small program for profiling using the
 system's installed C compiler and look at the assembler code that
 results.
 
+@findex NO_PROFILE_COUNTERS
+@item NO_PROFILE_COUNTERS
+Define this macro if the @code{mcount} subroutine on your system does
+not need a counter variable allocated for each function.  This is true
+for almost all modern implementations.  If you define this macro, you
+must not use the @var{labelno} argument to @code{FUNCTION_PROFILER}.
+
 @findex PROFILE_BEFORE_PROLOGUE
 @item PROFILE_BEFORE_PROLOGUE
 Define this macro if the code for function profiling should come before
diff --git a/libiberty/memchr.c b/libiberty/memchr.c
index cce3003..89aa98f 100644
--- a/libiberty/memchr.c
+++ b/libiberty/memchr.c
@@ -50,7 +50,7 @@ memchr (src_void, c, length)
 {
   const unsigned char *src = (const unsigned char *)src_void;
   
-  while (--length >= 0)
+  while (length-- > 0)
   {
     if (*src == c)
      return (PTR)src;
diff --git a/libobjc/Makefile.in b/libobjc/Makefile.in
index e1de9ae..cf8a04e 100644
--- a/libobjc/Makefile.in
+++ b/libobjc/Makefile.in
@@ -93,6 +93,7 @@ FLAGS_TO_PASS = \
 	"CC=$(CC)" \
 	"CFLAGS=$(CFLAGS)" \
 	"LIBCFLAGS=$(LIBCFLAGS)" \
+	"DESTDIR=$(DESTDIR)" \
 	"EXTRA_OFILES=$(EXTRA_OFILES)" \
 	"HDEFINES=$(HDEFINES)" \
 	"INSTALL=$(INSTALL)" \
@@ -271,33 +272,33 @@ install: install-libs copy-headers
 
 install-libs: installdirs
 	-if test -f libobjc.a ; then \
-	  rm -f $(libsubdir)/libobjc.a; \
-	  $(INSTALL_DATA) libobjc.a $(libsubdir)/libobjc.a; \
-	  chmod a-x $(libsubdir)/libobjc.a; \
+	  rm -f $(DESTDIR)$(libsubdir)/libobjc.a; \
+	  $(INSTALL_DATA) libobjc.a $(DESTDIR)$(libsubdir)/libobjc.a; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/libobjc.a; \
 	else true; fi
 	-if test -f libobjc_gc.a ; then \
-	  rm -f $(libsubdir)/libobjc_gc.a; \
-	  $(INSTALL_DATA) libobjc_gc.a $(libsubdir)/libobjc_gc.a; \
-	  chmod a-x $(libsubdir)/libobjc_gc.a; \
+	  rm -f $(DESTDIR)$(libsubdir)/libobjc_gc.a; \
+	  $(INSTALL_DATA) libobjc_gc.a $(DESTDIR)$(libsubdir)/libobjc_gc.a; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/libobjc_gc.a; \
 	else true; fi
 	-if test -f libobjc_s.a ; then \
-	  rm -f $(libsubdir)/libobjc_s.a; \
-	  $(INSTALL_DATA) libobjc_s.a $(libsubdir)/libobjc_s.a; \
-	  chmod a-x $(libsubdir)/libobjc_s.a; \
+	  rm -f $(DESTDIR)$(libsubdir)/libobjc_s.a; \
+	  $(INSTALL_DATA) libobjc_s.a $(DESTDIR)$(libsubdir)/libobjc_s.a; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/libobjc_s.a; \
 	else true; fi
 	  -if test -f libobjc.dll ; then \
-	  rm -f $(bindir)/libobjc.dll; \
-	  $(INSTALL_DATA) libobjc.dll $(bindir)/libobjc.dll; \
+	  rm -f $(DESTDIR)$(bindir)/libobjc.dll; \
+	  $(INSTALL_DATA) libobjc.dll $(DESTDIR)$(bindir)/libobjc.dll; \
 	else true; fi
 
 # Copy Objective C headers to installation include directory.
 copy-headers:
-	-rm -rf $(incinstalldir)/objc
-	-mkdir $(incinstalldir)/objc
+	-rm -rf $(DESTDIR)$(incinstalldir)/objc
+	-mkdir $(DESTDIR)$(incinstalldir)/objc
 	for file in $(OBJC_H); do \
 	  realfile=$(srcdir)/objc/$${file}; \
-	  cp $${realfile} $(incinstalldir)/objc; \
-	  chmod a+r $(incinstalldir)/objc/$${file}; \
+	  cp $${realfile} $(DESTDIR)$(incinstalldir)/objc; \
+	  chmod a+r $(DESTDIR)$(incinstalldir)/objc/$${file}; \
 	done
 
 check uninstall install-strip dist installcheck installdirs:
diff --git a/libstdc++/sstream b/libstdc++/sstream
index 45393b1..e421a80 100644
--- a/libstdc++/sstream
+++ b/libstdc++/sstream
@@ -106,7 +106,7 @@ namespace std
 	  if (c != EOF)
 	    {
 	      streamsize old_stream_len = stream_len;
-	      stream_len += 1;
+	      stream_len += stream_len + 1;
 	      char_type* new_stream = new char_type[stream_len];
 	      memcpy(new_stream, stream, old_stream_len);
 	      delete[] stream;
diff --git a/libstdc++/std/bastring.cc b/libstdc++/std/bastring.cc
index f86f6d3..c37941a 100644
--- a/libstdc++/std/bastring.cc
+++ b/libstdc++/std/bastring.cc
@@ -116,19 +116,19 @@ template <class charT, class traits, class Allocator>
 basic_string <charT, traits, Allocator>&
 basic_string <charT, traits, Allocator>::
 replace (size_type pos1, size_type n1,
-	 const basic_string& str, size_type pos2, size_type n2)
+	 const basic_string& _str, size_type pos2, size_type n2)
 {
-  const size_t len2 = str.length ();
+  const size_t len2 = _str.length ();
 
   if (pos1 == 0 && n1 >= length () && pos2 == 0 && n2 >= len2)
-    return operator= (str);
+    return operator= (_str);
 
   OUTOFRANGE (pos2 > len2);
 
   if (n2 > len2 - pos2)
     n2 = len2 - pos2;
 
-  return replace (pos1, n1, str.data () + pos2, n2);
+  return replace (pos1, n1, _str.data () + pos2, n2);
 }
 
 template <class charT, class traits, class Allocator>
@@ -394,21 +394,21 @@ find_last_not_of (charT c, size_type pos) const
 
 template <class charT, class traits, class Allocator>
 int basic_string <charT, traits, Allocator>::
-compare (const basic_string& str, size_type pos, size_type n) const
+compare (const basic_string& _str, size_type pos, size_type n) const
 {
   OUTOFRANGE (pos > length ());
 
   size_t rlen = length () - pos;
   if (rlen > n)
     rlen = n;
-  if (rlen > str.length ())
-    rlen = str.length ();
-  int r = traits::compare (data () + pos, str.data (), rlen);
+  if (rlen > _str.length ())
+    rlen = _str.length ();
+  int r = traits::compare (data () + pos, _str.data (), rlen);
   if (r != 0)
     return r;
   if (rlen == n)
     return 0;
-  return (length () - pos) - str.length ();
+  return (length () - pos) - _str.length ();
 }
 
 template <class charT, class traits, class Allocator>
@@ -476,7 +476,7 @@ getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
 {
   if (is.ipfx1 ())
     {
-      _IO_size_t count = 0;
+      _IO_size_t _count = 0;
       streambuf *sb = is.rdbuf ();
       s.resize (0);
 
@@ -485,13 +485,13 @@ getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
 	  int ch = sb->sbumpc ();
 	  if (ch == EOF)
 	    {
-	      is.setstate (count == 0
+	      is.setstate (_count == 0
 			   ? (ios::failbit|ios::eofbit)
 			   : ios::eofbit);
 	      break;
 	    }
 
-	  ++count;
+	  ++_count;
 
 	  if (ch == delim)
 	    break;
@@ -507,7 +507,7 @@ getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
     }
 
   // We need to be friends with istream to do this.
-  // is._gcount = count;
+  // is._gcount = _count;
   is.isfx ();
 
   return is;
diff --git a/libstdc++/std/bastring.h b/libstdc++/std/bastring.h
index bbe8730..9479d76 100644
--- a/libstdc++/std/bastring.h
+++ b/libstdc++/std/bastring.h
@@ -169,9 +169,9 @@ public:
     }
 
   explicit basic_string (): dat (nilRep.grab ()) { }
-  basic_string (const basic_string& str): dat (str.rep ()->grab ()) { }
-  basic_string (const basic_string& str, size_type pos, size_type n = npos)
-    : dat (nilRep.grab ()) { assign (str, pos, n); }
+  basic_string (const basic_string& _str): dat (_str.rep ()->grab ()) { }
+  basic_string (const basic_string& _str, size_type pos, size_type n = npos)
+    : dat (nilRep.grab ()) { assign (_str, pos, n); }
   basic_string (const charT* s, size_type n)
     : dat (nilRep.grab ()) { assign (s, n); }
   basic_string (const charT* s)
@@ -191,9 +191,9 @@ public:
 
   void swap (basic_string &s) { charT *d = dat; dat = s.dat; s.dat = d; }
 
-  basic_string& append (const basic_string& str, size_type pos = 0,
+  basic_string& append (const basic_string& _str, size_type pos = 0,
 			size_type n = npos)
-    { return replace (length (), 0, str, pos, n); }
+    { return replace (length (), 0, _str, pos, n); }
   basic_string& append (const charT* s, size_type n)
     { return replace (length (), 0, s, n); }
   basic_string& append (const charT* s)
@@ -335,7 +335,8 @@ private:
 
 public:
   const charT* c_str () const
-    { if (length () == 0) return ""; terminate (); return data (); }
+    { const charT* null_str = ""; 
+      if (length () == 0) return null_str; terminate (); return data (); }
   void resize (size_type n, charT c);
   void resize (size_type n)
     { resize (n, eos ()); }
@@ -346,8 +347,8 @@ public:
   size_type find (const basic_string& str, size_type pos = 0) const
     { return find (str.data(), pos, str.length()); }
   size_type find (const charT* s, size_type pos, size_type n) const;
-  size_type find (const charT* s, size_type pos = 0) const
-    { return find (s, pos, traits::length (s)); }
+  size_type find (const charT* _s, size_type pos = 0) const
+    { return find (_s, pos, traits::length (_s)); }
   size_type find (charT c, size_type pos = 0) const;
 
   size_type rfind (const basic_string& str, size_type pos = npos) const
@@ -469,36 +470,36 @@ inline basic_string <charT, traits, Allocator>
 operator+ (const basic_string <charT, traits, Allocator>& lhs,
 	   const basic_string <charT, traits, Allocator>& rhs)
 {
-  basic_string <charT, traits, Allocator> str (lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
 inline basic_string <charT, traits, Allocator>
 operator+ (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
 {
-  basic_string <charT, traits, Allocator> str (lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
 inline basic_string <charT, traits, Allocator>
 operator+ (charT lhs, const basic_string <charT, traits, Allocator>& rhs)
 {
-  basic_string <charT, traits, Allocator> str (1, lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (1, lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
 inline basic_string <charT, traits, Allocator>
 operator+ (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
 {
-  basic_string <charT, traits, Allocator> str (lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
diff --git a/libstdc++/stl/stl_alloc.h b/libstdc++/stl/stl_alloc.h
index 208309a..1647e83 100644
--- a/libstdc++/stl/stl_alloc.h
+++ b/libstdc++/stl/stl_alloc.h
@@ -38,7 +38,7 @@
 // The allocation primitives are intended to allocate individual objects,
 // not larger arenas as with the original STL allocators.
 
-#if 0
+#ifdef __STL_USE_EXCEPTIONS
 #   include <new>
 #   define __THROW_BAD_ALLOC throw bad_alloc()
 #elif !defined(__THROW_BAD_ALLOC)
diff --git a/libstdc++/stl/stl_hashtable.h b/libstdc++/stl/stl_hashtable.h
index 78b36c1..c0354fa 100644
--- a/libstdc++/stl/stl_hashtable.h
+++ b/libstdc++/stl/stl_hashtable.h
@@ -1014,14 +1014,14 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
   __STL_TRY {
     for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {
       if (const _Node* __cur = __ht._M_buckets[__i]) {
-        _Node* __copy = _M_new_node(__cur->_M_val);
-        _M_buckets[__i] = __copy;
+        _Node* ___copy = _M_new_node(__cur->_M_val);
+        _M_buckets[__i] = ___copy;
 
         for (_Node* __next = __cur->_M_next; 
              __next; 
              __cur = __next, __next = __cur->_M_next) {
-          __copy->_M_next = _M_new_node(__next->_M_val);
-          __copy = __copy->_M_next;
+          ___copy->_M_next = _M_new_node(__next->_M_val);
+          ___copy = ___copy->_M_next;
         }
       }
     }
diff --git a/libstdc++/string b/libstdc++/string
index fa6f1ab..523f435 100644
--- a/libstdc++/string
+++ b/libstdc++/string
@@ -7,7 +7,9 @@
 
 extern "C++" {
 typedef basic_string <char> string;
-// typedef basic_string <wchar_t> wstring;
+#ifdef __ENABLE_WSTRING
+typedef basic_string <wchar_t> wstring;
+#endif
 } // extern "C++"
 
 #endif
