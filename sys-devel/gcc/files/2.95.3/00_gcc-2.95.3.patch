diff --git a/Makefile.in b/Makefile.in
index 7af1784..881bbda 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -375,6 +375,7 @@ BASE_FLAGS_TO_PASS = \
 	"CXXFLAGS=$(CXXFLAGS)" \
 	"CXXFLAGS_FOR_TARGET=$(CXXFLAGS_FOR_TARGET)" \
 	"CXX_FOR_TARGET=$(CXX_FOR_TARGET)" \
+	"DESTDIR=$(DESTDIR)" \
 	"DLLTOOL_FOR_TARGET=$(DLLTOOL_FOR_TARGET)" \
 	"INSTALL=$(INSTALL)" \
 	"INSTALL_DATA=$(INSTALL_DATA)" \
@@ -499,6 +500,7 @@ EXTRA_GCC_FLAGS = \
 	"`echo 'LIBGCC2_DEBUG_CFLAGS=$(LIBGCC2_DEBUG_CFLAGS)' | sed -e s/.*=$$/XFOO=/`" \
 	"`echo 'LIBGCC2_INCLUDES=$(LIBGCC2_INCLUDES)' | sed -e s/.*=$$/XFOO=/`" \
 	"`echo 'ENQUIRE=$(ENQUIRE)' | sed -e s/.*=$$/XFOO=/`" \
+	"`echo 'STAGE1_CFLAGS=$(STAGE1_CFLAGS)' | sed -e s/.*=$$/XFOO=/`" \
 	"`echo 'BOOT_CFLAGS=$(BOOT_CFLAGS)' | sed -e s/.*=$$/XFOO=/`"
 
 GCC_FLAGS_TO_PASS = $(BASE_FLAGS_TO_PASS) $(EXTRA_GCC_FLAGS)
diff --git a/configure b/configure
index a7d3cb8..2b3e482 100755
--- a/configure
+++ b/configure
@@ -687,7 +687,7 @@ fi
 if test -f skip-this-dir; then
 	# Perform the same cleanup as the trap handler, minus the "exit 1" of course,
 	# and reset the trap handler.
-	trap 0
+	trap '' 0
 	rm -f Makefile* ${tmpfile}.com ${tmpfile}.tgt ${tmpfile}.hst ${tmpfile}.pos
 	# Execute the final clean-up actions
 	${config_shell} skip-this-dir
@@ -1599,7 +1599,7 @@ fi
 # Perform the same cleanup as the trap handler, minus the "exit 1" of course,
 # and reset the trap handler.
 rm -f ${tmpfile}.com ${tmpfile}.tgt ${tmpfile}.hst ${tmpfile}.pos
-trap 0
+trap '' 0
 
 exit 0
 
diff --git a/configure.in b/configure.in
index 7265f49..e3cca32 100644
--- a/configure.in
+++ b/configure.in
@@ -470,37 +470,6 @@ if [ x${with_stabs} = x ]; then
   esac
 fi
 
-# Handle ${copy_dirs}
-set fnord ${copy_dirs}
-shift
-while [ $# != 0 ]; do
-  if [ -f $2/COPIED ] && [ x"`cat $2/COPIED`" = x"$1" ]; then
-    :
-  else
-    echo Copying $1 to $2
-
-    # Use the install script to create the directory and all required
-    # parent directories.
-    if [ -d $2 ]; then
-      :
-    else
-      echo >config.temp
-      ${srcdir}/install-sh -c -m 644 config.temp $2/COPIED
-    fi
-
-    # Copy the directory, assuming we have tar.
-    # FIXME: Should we use B in the second tar?  Not all systems support it.
-    (cd $1; tar -cf - .) | (cd $2; tar -xpf -)
-
-    # It is the responsibility of the user to correctly adjust all
-    # symlinks.  If somebody can figure out how to handle them correctly
-    # here, feel free to add the code.
-
-    echo $1 > $2/COPIED
-  fi
-  shift; shift
-done
-
 # Configure extra directories which are host specific
 
 case "${host}" in
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 85bf9f8..e1f4f97 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -71,6 +71,7 @@ XCFLAGS =
 TCFLAGS =
 # -W -Wall warnings are disabled for releases.
 CFLAGS = -g
+STAGE1_CFLAGS = -g
 BOOT_CFLAGS = -O2 $(CFLAGS)
 #WARN_CFLAGS = -W -Wall
 # These exists to be overridden by the x-* and t-* files, respectively.
@@ -625,6 +626,7 @@ ORDINARY_FLAGS_TO_PASS = \
 	"BISONFLAGS=$(BISONFLAGS)" \
 	"CFLAGS=$(CFLAGS)" \
 	"CLIB=$(CLIB)" \
+	"DESTDIR=$(DESTDIR)" \
 	"GCC_FOR_TARGET=$(GCC_FOR_TARGET)" \
 	"LDFLAGS=$(LDFLAGS)" \
 	"LEX=$(LEX)" \
@@ -2178,13 +2180,6 @@ stmp-fixinc: fixinc.sh gsyslimits.h
 # exists.
 # We deliberately use tooldir instead of gcc_tooldir here.  gcc_tooldir
 # won't work because libsubdir doesn't exist yet.
-	if [ "$(SYSTEM_HEADER_DIR)" = "$(tooldir)/sys-include" ] \
-	   && [ -d $(tooldir)/sys-include ]; then \
-	  if [ -d $(libdir) ] ; then true ; else mkdir $(libdir) ; fi; \
-	  if [ -d $(libdir)/gcc-lib ] ; then true ; else mkdir $(libdir)/gcc-lib; fi; \
-	  if [ -d $(libdir)/gcc-lib/$(target_alias) ] ; then true ; else mkdir $(libdir)/gcc-lib/$(target_alias) ; fi; \
-	  if [ -d $(libdir)/gcc-lib/$(target_alias)/$(version) ] ; then true ; else mkdir $(libdir)/gcc-lib/$(target_alias)/$(version) ; fi; \
-	else true; fi
 
 	touch stmp-fixinc
 
@@ -2450,17 +2445,17 @@ install-cross-rest: install-float-h-cross
 
 # Handle cpp installation.
 install-cpp: cpp$(exeext)
-	-rm -f $(bindir)/$(CPP_INSTALL_NAME)$(exeext)
-	$(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	-rm -f $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
+	$(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext)
 	if [ x$(cpp_install_dir) != x ]; then \
-	  rm -f $(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
-	  $(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	  rm -f $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
+	  $(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(DESTDIR)$(prefix)/$(cpp_install_dir)/$(CPP_INSTALL_NAME)$(exeext); \
 	else true; fi
 
 uninstall-cpp:
-	-rm -f $(bindir)/cpp
+	-rm -f $(DESTDIR)$(BINDIR)/cpp
 	-if [ x$(cpp_install_dir) != x ]; then \
-	  rm -f $(prefix)/$(cpp_install_dir)/cpp; \
+	  rm -f $(DESTDIR)$(prefix)/$(cpp_install_dir)/cpp; \
 	else true; fi
 
 # Install float.h for cross compiler.
@@ -2470,163 +2465,164 @@ install-float-h-cross: installdirs
 #	if [ -f enquire ] ; then true; else false; fi
 # Note: don't use -.  We should fail right away if enquire was not made.
 	./enquire -f > $(tmpdir)/float.h
-	-rm -f $(libsubdir)/include/float.h
-	$(INSTALL_DATA) $(tmpdir)/float.h $(libsubdir)/include/float.h
+	-rm -f $(DESTDIR)$(libsubdir)/include/float.h
+	$(INSTALL_DATA) $(tmpdir)/float.h $(DESTDIR)$(libsubdir)/include/float.h
 	-rm -f $(tmpdir)/float.h
-	chmod a-x $(libsubdir)/include/float.h
+	chmod a-x $(DESTDIR)$(libsubdir)/include/float.h
 
 # Create the installation directories.
 installdirs:
-	-if [ -d $(prefix) ] ; then true ; else mkdir $(prefix) ; chmod a+rx $(prefix) ; fi
-	-if [ -d $(exec_prefix) ] ; then true ; else mkdir $(exec_prefix) ; chmod a+rx $(exec_prefix) ; fi
-	-if [ -d $(libdir) ] ; then true ; else mkdir $(libdir) ; chmod a+rx $(libdir) ; fi
-	-if [ -d $(libdir)/gcc-lib ] ; then true ; else mkdir $(libdir)/gcc-lib ; chmod a+rx $(libdir)/gcc-lib ; fi
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(prefix)
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(exec_prefix)
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(libdir)
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(libdir)/gcc-lib
 # This dir isn't currently searched by cpp.
 #	-if [ -d $(libdir)/gcc-lib/include ] ; then true ; else mkdir $(libdir)/gcc-lib/include ; chmod a+rx $(libdir)/gcc-lib/include ; fi
 	-fdir= ; for dir in `echo $(libsubdir) | tr '/' ' '`; do \
 	  fdir=$${fdir}/$${dir}; \
-	  if [ -d $${fdir} ] ; then true ; else mkdir $${fdir}; chmod a+rx $${fdir}; fi ; \
+	  if [ -d $(DESTDIR)$${fdir} ] ; then true ; else mkdir $(DESTDIR)$${fdir}; chmod a+rx $(DESTDIR)$${fdir}; fi ; \
 	done
-	-if [ -d $(bindir) ] ; then true ; else mkdir $(bindir) ; chmod a+rx $(bindir) ; fi
-	-if [ -d $(includedir) ] ; then true ; else mkdir $(includedir) ; chmod a+rx $(includedir) ; fi
-	-if [ -d $(gcc_tooldir) ] ; then true ; else mkdir $(gcc_tooldir) ; chmod a+rx $(gcc_tooldir) ; fi
-	-if [ -d $(assertdir) ] ; then true ; else mkdir $(assertdir) ; chmod a+rx $(assertdir) ; fi
-	-if [ -d $(infodir) ] ; then true ; else mkdir $(infodir) ; chmod a+rx $(infodir) ; fi
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(bindir)
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(includedir)
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(gcc_tooldir)
+	#$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(assertdir) moved to install-assert-h target
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(infodir)
 # We don't use mkdir -p to create the parents of man1dir,
 # because some systems don't support it.
 # Instead, we use this technique to create the immediate parent of man1dir.
 	-parent=`echo $(man1dir)|sed -e 's@/[^/]*$$@@'`; \
-	if [ -d $$parent ] ; then true ; else mkdir $$parent ; chmod a+rx $$parent ; fi
-	-if [ -d $(man1dir) ] ; then true ; else mkdir $(man1dir) ; chmod a+rx $(man1dir) ; fi
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$$parent
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(man1dir)
 
 # Install the compiler executables built during cross compilation.
 install-common: native installdirs $(EXTRA_PARTS) lang.install-common
 	for file in $(COMPILERS); do \
 	  if [ -f $$file ] ; then \
-	    rm -f $(libsubdir)/$$file; \
-	    $(INSTALL_PROGRAM) $$file $(libsubdir)/$$file; \
+	    rm -f $(DESTDIR)$(libsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libsubdir)/$$file; \
 	  else true; \
 	  fi; \
 	done
 	for file in $(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2) ..; do \
 	  if [ x"$$file" != x.. ]; then \
-	    rm -f $(libsubdir)/$$file; \
-	    $(INSTALL_PROGRAM) $$file $(libsubdir)/$$file; \
+	    rm -f $(DESTDIR)$(libsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libsubdir)/$$file; \
 	  else true; fi; \
 	done
 	for file in $(EXTRA_PARTS) ..; do \
 	  if [ x"$$file" != x.. ]; then \
-	    rm -f $(libsubdir)/$$file; \
-	    $(INSTALL_DATA) $$file $(libsubdir)/$$file; \
-	    chmod a-x $(libsubdir)/$$file; \
+	    rm -f $(DESTDIR)$(libsubdir)/$$file; \
+	    $(INSTALL_DATA) $$file $(DESTDIR)$(libsubdir)/$$file; \
+	    chmod a-x $(DESTDIR)$(libsubdir)/$$file; \
 	  else true; fi; \
 	done
 # Don't mess with specs if it doesn't exist yet.
 	-if [ -f specs ] ; then \
-	  rm -f $(libsubdir)/specs; \
-	  $(INSTALL_DATA) specs $(libsubdir)/specs; \
-	  chmod a-x $(libsubdir)/specs; \
+	  rm -f $(DESTDIR)$(libsubdir)/specs; \
+	  $(INSTALL_DATA) specs $(DESTDIR)$(libsubdir)/specs; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/specs; \
 	fi
 # Install protoize if it was compiled.
 	-if [ -f protoize$(exeext) ]; \
 	then \
 	    if [ -f gcc-cross$(exeext) ] ; then \
-		rm -f $(bindir)/$(PROTOIZE_CROSS_NAME)$(exeext); \
-		$(INSTALL_PROGRAM) protoize$(exeext) $(bindir)/$(PROTOIZE_CROSS_NAME)$(exeext); \
-		rm -f $(bindir)/$(UNPROTOIZE_CROSS_NAME)$(exeext); \
-		$(INSTALL_PROGRAM) unprotoize$(exeext) $(bindir)/$(UNPROTOIZE_CROSS_NAME)$(exeext); \
+		rm -f $(DESTDIR)$(bindir)/$(PROTOIZE_CROSS_NAME)$(exeext); \
+		$(INSTALL_PROGRAM) protoize$(exeext) $(DESTDIR)$(bindir)/$(PROTOIZE_CROSS_NAME)$(exeext); \
+		rm -f $(DESTDIR)$(bindir)/$(UNPROTOIZE_CROSS_NAME)$(exeext); \
+		$(INSTALL_PROGRAM) unprotoize$(exeext) $(DESTDIR)$(bindir)/$(UNPROTOIZE_CROSS_NAME)$(exeext); \
 	    else \
-		rm -f $(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext); \
-		$(INSTALL_PROGRAM) protoize$(exeext) $(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext); \
-		rm -f $(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext); \
-		$(INSTALL_PROGRAM) unprotoize$(exeext) $(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext); \
+		rm -f $(DESTDIR)$(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext); \
+		$(INSTALL_PROGRAM) protoize$(exeext) $(DESTDIR)$(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext); \
+		rm -f $(DESTDIR)$(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext); \
+		$(INSTALL_PROGRAM) unprotoize$(exeext) $(DESTDIR)$(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext); \
 	    fi ; \
-	    rm -f $(libsubdir)/SYSCALLS.c.X; \
-	    $(INSTALL_DATA) SYSCALLS.c.X $(libsubdir)/SYSCALLS.c.X; \
-	    chmod a-x $(libsubdir)/SYSCALLS.c.X; \
+	    rm -f $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	    $(INSTALL_DATA) SYSCALLS.c.X $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	    chmod a-x $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
 	fi
-	-rm -f $(libsubdir)/cpp0$(exeext)
-	$(INSTALL_PROGRAM) cpp0$(exeext) $(libsubdir)/cpp0$(exeext)
+	-rm -f $(DESTDIR)$(libsubdir)/cpp0$(exeext)
+	$(INSTALL_PROGRAM) cpp0$(exeext) $(DESTDIR)$(libsubdir)/cpp0$(exeext)
 # Install gcov if it was compiled.
 	-if [ -f gcov$(exeext) ]; \
 	then \
-	    rm -f $(bindir)/gcov$(exeext); \
-	    $(INSTALL_PROGRAM) gcov$(exeext) $(bindir)/$(GCOV_INSTALL_NAME)$(exeext); \
+	    rm -f $(DESTDIR)$(bindir)/gcov$(exeext); \
+	    $(INSTALL_PROGRAM) gcov$(exeext) $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext); \
 	fi
 
 # Install the driver program as $(target_alias)-gcc
 # and also as either gcc (if native) or $(gcc_tooldir)/bin/gcc.
 install-driver: xgcc$(exeext)
 	-if [ -f gcc-cross$(exeext) ] ; then \
-	  rm -f $(bindir)/$(GCC_CROSS_NAME)$(exeext); \
-	  $(INSTALL_PROGRAM) gcc-cross$(exeext) $(bindir)/$(GCC_CROSS_NAME)$(exeext); \
-	  if [ -d $(gcc_tooldir)/bin/. ] ; then \
-	    rm -f $(gcc_tooldir)/bin/gcc$(exeext); \
-	    $(INSTALL_PROGRAM) gcc-cross$(exeext) $(gcc_tooldir)/bin/gcc$(exeext); \
+	  rm -f $(DESTDIR)$(bindir)/$(GCC_CROSS_NAME)$(exeext); \
+	  $(INSTALL_PROGRAM) gcc-cross$(exeext) $(DESTDIR)$(bindir)/$(GCC_CROSS_NAME)$(exeext); \
+	  if [ -d $(DESTDIR)$(gcc_tooldir)/bin/. ] ; then \
+	    rm -f $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
+	    $(INSTALL_PROGRAM) gcc-cross$(exeext) $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
 	  else true; fi; \
 	else \
-	  rm -f $(bindir)/$(GCC_INSTALL_NAME)$(exeext); \
-	  $(INSTALL_PROGRAM) xgcc$(exeext) $(bindir)/$(GCC_INSTALL_NAME)$(exeext); \
-	  rm -f $(bindir)/$(target_alias)-gcc-1$(exeext); \
-	  $(LN) $(bindir)/$(GCC_INSTALL_NAME)$(exeext) $(bindir)/$(target_alias)-gcc-1$(exeext); \
-	  mv $(bindir)/$(target_alias)-gcc-1$(exeext) $(bindir)/$(target_alias)-gcc$(exeext); \
+	  rm -f $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext); \
+	  $(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext); \
+	  rm -f $(DESTDIR)$(bindir)/$(target_alias)-gcc-1$(exeext); \
+	  ( cd $(DESTDIR)$(bindir) && \
+	    $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_alias)-gcc-1$(exeext) ); \
+	  mv $(DESTDIR)$(bindir)/$(target_alias)-gcc-1$(exeext) $(DESTDIR)$(bindir)/$(target_alias)-gcc$(exeext); \
 	fi
 
 # Install the info files.
 # $(INSTALL_DATA) might be a relative pathname, so we can't cd into srcdir
 # to do the install.
 install-info: doc installdirs lang.install-info
-	-rm -f $(infodir)/cpp.info* $(infodir)/gcc.info*
+	-rm -f $(DESTDIR)$(infodir)/cpp.info* $(DESTDIR)$(infodir)/gcc.info*
 	for f in cpp.info* gcc.info*; do \
-	    $(INSTALL_DATA) $$f $(infodir)/$$f; \
+	    $(INSTALL_DATA) $$f $(DESTDIR)$(infodir)/$$f; \
 	done
 	-if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
-	  if [ -f $(infodir)/dir ] ; then \
+	  if [ -f $(DESTDIR)$(infodir)/dir ] ; then \
 	    for f in cpp.info gcc.info; do \
-		install-info --dir-file=$(infodir)/dir $(infodir)/$$f; \
+		install-info --dir-file=$(DESTDIR)$(infodir)/dir $(DESTDIR)$(infodir)/$$f; \
 	    done; \
 	  else true; fi; \
 	else true; fi;
-	-chmod a-x $(infodir)/cpp.info* $(infodir)/gcc.info*
+	-chmod a-x $(DESTDIR)$(infodir)/cpp.info* $(DESTDIR)$(infodir)/gcc.info*
 
 # Install the man pages.
 install-man: installdirs $(srcdir)/gcc.1 $(srcdir)/cccp.1 lang.install-man
 	-if [ -f gcc-cross$(exeext) ] ; then \
-	  rm -f $(man1dir)/$(GCC_CROSS_NAME)$(manext); \
-	  $(INSTALL_DATA) $(srcdir)/gcc.1 $(man1dir)/$(GCC_CROSS_NAME)$(manext); \
-	  chmod a-x $(man1dir)/$(GCC_CROSS_NAME)$(manext); \
+	  rm -f $(DESTDIR)$(man1dir)/$(GCC_CROSS_NAME)$(manext); \
+	  $(INSTALL_DATA) $(srcdir)/gcc.1 $(DESTDIR)$(man1dir)/$(GCC_CROSS_NAME)$(manext); \
+	  chmod a-x $(DESTDIR)$(man1dir)/$(GCC_CROSS_NAME)$(manext); \
 	else \
-	  rm -f $(man1dir)/$(GCC_INSTALL_NAME)$(manext); \
-	  $(INSTALL_DATA) $(srcdir)/gcc.1 $(man1dir)/$(GCC_INSTALL_NAME)$(manext); \
-	  chmod a-x $(man1dir)/$(GCC_INSTALL_NAME)$(manext); \
+	  rm -f $(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(manext); \
+	  $(INSTALL_DATA) $(srcdir)/gcc.1 $(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(manext); \
+	  chmod a-x $(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(manext); \
 	fi
-	-rm -f $(man1dir)/cccp$(manext)
-	-$(INSTALL_DATA) $(srcdir)/cccp.1 $(man1dir)/cccp$(manext)
-	-chmod a-x $(man1dir)/cccp$(manext)
+	-rm -f $(DESTDIR)$(man1dir)/cccp$(manext)
+	-$(INSTALL_DATA) $(srcdir)/cccp.1 $(DESTDIR)$(man1dir)/cccp$(manext)
+	-chmod a-x $(DESTDIR)$(man1dir)/cccp$(manext)
 
 # Install the library.
 install-libgcc: libgcc.a installdirs
 	-if [ -f libgcc.a ] ; then \
-	  rm -f $(libsubdir)/libgcc.a; \
-	  $(INSTALL_DATA) libgcc.a $(libsubdir)/libgcc.a; \
+	  rm -f $(DESTDIR)$(libsubdir)/libgcc.a; \
+	  $(INSTALL_DATA) libgcc.a $(DESTDIR)$(libsubdir)/libgcc.a; \
 	  if $(RANLIB_TEST_FOR_TARGET) ; then \
-	    (cd $(libsubdir); $(RANLIB_FOR_TARGET) libgcc.a); else true; fi; \
-	  chmod a-x $(libsubdir)/libgcc.a; \
+	    (cd $(DESTDIR)$(libsubdir); $(RANLIB_FOR_TARGET) libgcc.a); else true; fi; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/libgcc.a; \
 	else true; fi
 
 # Install multiple versions of libgcc.a.
 install-multilib: stmp-multilib installdirs
 	for i in `$(GCC_FOR_TARGET) --print-multi-lib`; do \
 	  dir=`echo $$i | sed -e 's/;.*$$//'`; \
-	  if [ -d $(libsubdir)/$${dir} ]; then true; else mkdir $(libsubdir)/$${dir}; fi; \
+	  if [ -d $(DESTDIR)$(libsubdir)/$${dir} ]; then true; else mkdir $(DESTDIR)$(libsubdir)/$${dir}; fi; \
 	  for f in libgcc.a $(EXTRA_MULTILIB_PARTS); do \
-	    rm -f $(libsubdir)/$${dir}/$${f}; \
-	    $(INSTALL_DATA) $${dir}/$${f} $(libsubdir)/$${dir}/$${f}; \
+	    rm -f $(DESTDIR)$(libsubdir)/$${dir}/$${f}; \
+	    $(INSTALL_DATA) $${dir}/$${f} $(DESTDIR)$(libsubdir)/$${dir}/$${f}; \
 	  done; \
 	  if $(RANLIB_TEST_FOR_TARGET); then \
-	    (cd $(libsubdir)/$${dir}; $(RANLIB_FOR_TARGET) libgcc.a); \
+	    (cd $(DESTDIR)$(libsubdir)/$${dir}; $(RANLIB_FOR_TARGET) libgcc.a); \
 	  else true; fi; \
-	  chmod a-x $(libsubdir)/$${dir}/libgcc.a; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/$${dir}/libgcc.a; \
 	done
 
 # Install all the header files built in the include subdirectory.
@@ -2634,23 +2630,23 @@ install-headers: install-include-dir $(INSTALL_HEADERS_DIR) $(INSTALL_ASSERT_H)
 # Fix symlinks to absolute paths in the installed include directory to
 # point to the installed directory, not the build directory.
 # Don't need to use LN_S here since we really do need ln -s and no substitutes.
-	-files=`cd $(libsubdir)/include; find . -type l -print 2>/dev/null`; \
+	-files=`cd $(DESTDIR)$(libsubdir)/include; find . -type l -print 2>/dev/null`; \
 	if [ $$? -eq 0 ]; then \
 	  dir=`cd include; pwd`; \
 	  for i in $$files; do \
 	    dest=`ls -ld $(libsubdir)/include/$$i | sed -n 's/.*-> //p'`; \
 	    if expr "$$dest" : "$$dir.*" > /dev/null; then \
-	      rm -f $(libsubdir)/include/$$i; \
-	      ln -s `echo $$i | sed "s|/[^/]*|/..|g" | sed 's|/..$$||'``echo "$$dest" | sed "s|$$dir||"` $(libsubdir)/include/$$i; \
+	      rm -f $(DESTDIR)$(libsubdir)/include/$$i; \
+	      ln -s `echo $$i | sed "s|/[^/]*|/..|g" | sed 's|/..$$||'``echo "$$dest" | sed "s|$$dir||"` $(DESTDIR)$(libsubdir)/include/$$i; \
 	    fi; \
 	  done; \
 	fi
 
 # Create or recreate the gcc private include file directory.
 install-include-dir: installdirs
-	-rm -rf $(libsubdir)/include
-	mkdir $(libsubdir)/include
-	-chmod a+rx $(libsubdir)/include
+	-rm -rf $(DESTDIR)$(libsubdir)/include
+	mkdir $(DESTDIR)$(libsubdir)/include
+	-chmod a+rx $(DESTDIR)$(libsubdir)/include
 
 # Install the include directory using tar.
 install-headers-tar: stmp-headers $(STMP_FIXPROTO) install-include-dir
@@ -2659,7 +2655,7 @@ install-headers-tar: stmp-headers $(STMP_FIXPROTO) install-include-dir
 # found in CDPATH, corrupting the output.  We could just redirect the
 # output of `cd', but some shells lose on redirection within `()'s
 	(cd `pwd`/include ; \
-	 tar -cf - .; exit 0) | (cd $(libsubdir)/include; tar $(TAROUTOPTS) - )
+	 tar -cf - .; exit 0) | (cd $(DESTDIR)$(libsubdir)/include; tar $(TAROUTOPTS) - )
 # /bin/sh on some systems returns the status of the first tar,
 # and that can lose with GNU tar which always writes a full block.
 # So use `exit 0' to ignore its exit status.
@@ -2668,7 +2664,7 @@ install-headers-tar: stmp-headers $(STMP_FIXPROTO) install-include-dir
 install-headers-cpio: stmp-headers $(STMP_FIXPROTO) install-include-dir
 # See discussion about the use of `pwd` above
 	cd `pwd`/include ; \
-	find . -print | cpio -pdum $(libsubdir)/include
+	find . -print | cpio -pdum $(DESTDIR)$(libsubdir)/include
 
 # Put assert.h where it won't override GNU libc's assert.h.
 # It goes in a dir that is searched after GNU libc's headers;
@@ -2678,43 +2674,43 @@ install-headers-cpio: stmp-headers $(STMP_FIXPROTO) install-include-dir
 ## This code would be simpler if it tested for -f ... && ! grep ...
 ## but supposedly the ! operator is missing in sh on some systems.
 install-assert-h: assert.h installdirs
-	if [ -f $(assertdir)/assert.h ]; \
+	$(SHELL) $(srcdir)/mkinstalldirs $(DESTDIR)$(assertdir) ; if [ -f $(DESTDIR)$(assertdir)/assert.h ]; \
 	then \
-	  if grep "__eprintf" $(assertdir)/assert.h >/dev/null; \
+	  if grep "__eprintf" $(DESTDIR)$(assertdir)/assert.h >/dev/null; \
 	    then \
-	    rm -f $(assertdir)/assert.h; \
-	    $(INSTALL_DATA) $(srcdir)/assert.h $(assertdir)/assert.h; \
-	    chmod a-x $(assertdir)/assert.h; \
+	    rm -f $(DESTDIR)$(assertdir)/assert.h; \
+	    $(INSTALL_DATA) $(srcdir)/assert.h $(DESTDIR)$(assertdir)/assert.h; \
+	    chmod a-x $(DESTDIR)$(assertdir)/assert.h; \
 	  else true; \
 	  fi; \
 	else \
-	  rm -f $(assertdir)/assert.h; \
-	  $(INSTALL_DATA) $(srcdir)/assert.h $(assertdir)/assert.h; \
-	  chmod a-x $(assertdir)/assert.h; \
+	  rm -f $(DESTDIR)$(assertdir)/assert.h; \
+	  $(INSTALL_DATA) $(srcdir)/assert.h $(DESTDIR)$(assertdir)/assert.h; \
+	  chmod a-x $(DESTDIR)$(assertdir)/assert.h; \
 	fi
 
 # Use this target to install the program `collect2' under the name `collect2'.
 install-collect2: collect2 installdirs
-	$(INSTALL_PROGRAM) collect2$(exeext) $(libsubdir)/collect2$(exeext)
+	$(INSTALL_PROGRAM) collect2$(exeext) $(DESTDIR)$(libsubdir)/collect2$(exeext)
 # Install the driver program as $(libsubdir)/gcc for collect2.
-	$(INSTALL_PROGRAM) xgcc$(exeext) $(libsubdir)/gcc$(exeext)
+	$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(libsubdir)/gcc$(exeext)
 
 # Cancel installation by deleting the installed files.
 uninstall: intl.uninstall lang.uninstall $(UNINSTALL_CPP)
-	-rm -rf $(libsubdir)
-	-rm -rf $(bindir)/$(GCC_INSTALL_NAME)$(exeext)
-	-rm -rf $(bindir)/$(GCC_CROSS_NAME)$(exeext)
-	-rm -rf $(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext)
-	-rm -rf $(bindir)/$(PROTOIZE_CROSS_NAME)$(exeext)
-	-rm -rf $(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext)
-	-rm -rf $(bindir)/$(UNPROTOIZE_CROSS_NAME)$(exeext)
-	-rm -rf $(bindir)/$(GCOV_INSTALL_NAME)$(exeext)
-	-rm -rf $(man1dir)/$(GCC_INSTALL_NAME)$(manext)
-	-rm -rf $(man1dir)/$(GCC_CROSS_NAME)$(manext)
-	-rm -rf $(man1dir)/cccp$(manext)
-	-rm -rf $(man1dir)/protoize$(manext)
-	-rm -rf $(man1dir)/unprotoize$(manext)
-	-rm -f $(infodir)/cpp.info* $(infodir)/gcc.info*
+	-rm -rf $(DESTDIR)$(libsubdir)
+	-rm -rf $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(GCC_CROSS_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(PROTOIZE_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(PROTOIZE_CROSS_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(UNPROTOIZE_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(UNPROTOIZE_CROSS_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(manext)
+	-rm -rf $(DESTDIR)$(man1dir)/$(GCC_CROSS_NAME)$(manext)
+	-rm -rf $(DESTDIR)$(man1dir)/cccp$(manext)
+	-rm -rf $(DESTDIR)$(man1dir)/protoize$(manext)
+	-rm -rf $(DESTDIR)$(man1dir)/unprotoize$(manext)
+	-rm -f $(DESTDIR)$(infodir)/cpp.info* $(infodir)/gcc.info*
 #
 # These targets are for the dejagnu testsuites. The file site.exp 
 # contains global variables that all the testsuites will use.
@@ -2938,7 +2934,7 @@ bootstrap bootstrap-lean: force
 # Only build the C compiler for stage1, because that is the only one that
 # we can guarantee will build with the native compiler, and also it is the
 # only thing useful for building stage2.
-	$(MAKE) CC="$(CC)" libdir=$(libdir) LANGUAGES="$(BOOT_LANGUAGES)"
+	$(MAKE) CC="$(CC)" CFLAGS="$(STAGE1_CFLAGS)" libdir=$(libdir) LANGUAGES="$(BOOT_LANGUAGES)"
 	$(MAKE) stage1
 # This used to define ALLOCA as empty, but that would lead to bad results
 # for a subsequent `make install' since that would not have ALLOCA empty.
diff --git a/gcc/c-common.c b/gcc/c-common.c
index 59dd407..4bc30fa 100644
--- a/gcc/c-common.c
+++ b/gcc/c-common.c
@@ -697,7 +697,23 @@ decl_attributes (node, attributes, prefix_attributes)
 	    if (exact_log2 (align) == -1)
 	      error ("requested alignment is not a power of 2");
 	    else if (is_type)
-	      TYPE_ALIGN (type) = align;
+	      {
+		/* If we have a TYPE_DECL, then copy the type, so that we
+		   don't accidentally modify a builtin type.  See pushdecl.  */
+		if (decl && TREE_TYPE (decl) != error_mark_node
+		    && DECL_ORIGINAL_TYPE (decl) == NULL_TREE)
+		  {
+		    tree tt = TREE_TYPE (decl);
+		    DECL_ORIGINAL_TYPE (decl) = tt;
+		    tt = build_type_copy (tt);
+		    TYPE_NAME (tt) = decl;
+		    TREE_USED (tt) = TREE_USED (decl);
+		    TREE_TYPE (decl) = tt;
+		    type = tt;
+		  }
+
+		TYPE_ALIGN (type) = align;
+	      }
 	    else if (TREE_CODE (decl) != VAR_DECL
 		     && TREE_CODE (decl) != FIELD_DECL)
 	      error_with_decl (decl,
@@ -965,6 +981,15 @@ split_specs_attrs (specs_attrs, declspecs, prefix_attributes)
 {
   tree t, s, a, next, specs, attrs;
 
+  /* This can happen after an __extension__ in pedantic mode.  */
+  if (specs_attrs != NULL_TREE 
+      && TREE_CODE (specs_attrs) == INTEGER_CST)
+    {
+      *declspecs = NULL_TREE;
+      *prefix_attributes = NULL_TREE;
+      return;
+    }
+
   /* This can happen in c++ (eg: decl: typespec initdecls ';').  */
   if (specs_attrs != NULL_TREE
       && TREE_CODE (specs_attrs) != TREE_LIST)
diff --git a/gcc/c-lex.c b/gcc/c-lex.c
index 27c65f3..8ee2fe4 100644
--- a/gcc/c-lex.c
+++ b/gcc/c-lex.c
@@ -1812,7 +1812,11 @@ yylex ()
 
 	    type = flag_traditional ? traditional_type : ansi_type;
 
-	    if (warn_traditional && traditional_type != ansi_type)
+	    /* We assume that constants specified in a non-decimal
+	       base are bit patterns, and that the programmer really
+	       meant what they wrote.  */
+	    if (warn_traditional && base == 10
+		&& traditional_type != ansi_type)
 	      {
 		if (TYPE_PRECISION (traditional_type)
 		    != TYPE_PRECISION (ansi_type))
diff --git a/gcc/calls.c b/gcc/calls.c
index bb7595a..4dccc05 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -1508,6 +1508,11 @@ load_register_parameters (args, num_actuals, call_fusage)
 			       validize_mem (args[i].value), nregs,
 			       args[i].mode);
 
+	  /* Indicate two regs used to hold a short complex arg.  */
+	  if (GET_MODE_CLASS (args[i].mode) == MODE_COMPLEX_FLOAT
+	      && GET_MODE_SIZE (args[i].mode) <= UNITS_PER_WORD)
+	    nregs = 2;
+
 	  /* Handle calls that pass values in multiple non-contiguous
 	     locations.  The Irix 6 ABI has examples of this.  */
 	  if (GET_CODE (reg) == PARALLEL)
diff --git a/gcc/cccp.c b/gcc/cccp.c
index 023502f..455c239 100644
--- a/gcc/cccp.c
+++ b/gcc/cccp.c
@@ -1024,7 +1024,8 @@ static void print_help PROTO((void));
    retrying if necessary.  If MAX_READ_LEN is defined, read at most
    that bytes at a time.  Return a negative value if an error occurs,
    otherwise return the actual number of bytes read,
-   which must be LEN unless end-of-file was reached.  */
+   which may be < LEN if CRs have been skipped, though we try not to do
+   that.  */
 
 static int
 safe_read (desc, ptr, len)
@@ -1033,6 +1034,7 @@ safe_read (desc, ptr, len)
      int len;
 {
   int left, rcount, nchars;
+  char *rptr;
 
   left = len;
   while (left > 0) {
@@ -1052,8 +1054,20 @@ safe_read (desc, ptr, len)
       }
     if (nchars == 0)
       break;
-    ptr += nchars;
+
+    /* CRLF pairs, found with Unix when processing DOS files,
+       throw off backslash-newline removal.
+       Therefore, CRs are thrown away here. */
     left -= nchars;
+    rptr = ptr;
+    while(nchars--)
+      {
+	if(*rptr == '\r' && *(rptr+1) == '\n')
+	  left++;
+	else
+	  *ptr++ = *rptr;
+	rptr++;
+      }
   }
   return len - left;
 }
@@ -1124,7 +1138,7 @@ print_help ()
   printf ("Usage: %s [switches] input output\n", progname);
   printf ("Switches:\n");
   printf ("  -include <file>           Include the contents of <file> before other files\n");
-  printf ("  -imacros <file>           Accept definition of marcos in <file>\n");
+  printf ("  -imacros <file>           Accept definition of macros in <file>\n");
   printf ("  -iprefix <path>           Specify <path> as a prefix for next two options\n");
   printf ("  -iwithprefix <dir>        Add <dir> to the end of the system include paths\n");
   printf ("  -iwithprefixbefore <dir>  Add <dir> to the end of the main include paths\n");
@@ -1138,7 +1152,7 @@ print_help ()
   printf ("  -traditional              Follow K&R pre-processor behaviour\n");
   printf ("  -trigraphs                Support ANSI C trigraphs\n");
   printf ("  -lang-c                   Assume that the input sources are in C\n");
-  printf ("  -lang-c89                 Assume that the input is C89; depricated\n");
+  printf ("  -lang-c89                 Assume that the input is C89; deprecated\n");
   printf ("  -lang-c++                 Assume that the input sources are in C++\n");
   printf ("  -lang-objc                Assume that the input sources are in ObjectiveC\n");
   printf ("  -lang-objc++              Assume that the input sources are in ObjectiveC++\n");
@@ -2086,8 +2100,8 @@ main (argc, argv)
     for (;;) {
       cnt = safe_read (f, (char *) fp->buf + size, bsize - size);
       if (cnt < 0) goto perror;	/* error! */
+      if (cnt == 0) break; /* End of file */
       size += cnt;
-      if (size != bsize) break;	/* End of file */
       bsize *= 2;
       fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);
     }
@@ -5027,6 +5041,8 @@ read_name_map (dirname)
 	  map_list_ptr->map_list_map = ptr;
 
 	  while ((ch = getc (f)) != '\n')
+	    if (ch == '\r')
+		continue;
 	    if (ch == EOF)
 	      break;
 	}
@@ -5259,9 +5275,9 @@ finclude (f, inc, op, system_header_p, dirptr)
       i = safe_read (f, (char *) fp->buf + st_size, bsize - st_size);
       if (i < 0)
 	goto nope;      /* error! */
-      st_size += i;
-      if (st_size != bsize)
+      if (i == 0)
 	break;	/* End of file */
+      st_size += i;
       bsize *= 2;
       fp->buf = (U_CHAR *) xrealloc (fp->buf, bsize + 2);
     }
diff --git a/gcc/collect2.c b/gcc/collect2.c
index 153ac6f..9cf4e06 100644
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -1759,7 +1759,7 @@ collect_execute (prog, argv, redir)
   if (redir)
     {
       /* Open response file.  */
-      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT);
+      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR);
 
       /* Duplicate the stdout and stderr file handles
 	 so they can be restored later.  */
diff --git a/gcc/combine.c b/gcc/combine.c
index eb75481..9445e30 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -7580,8 +7580,11 @@ nonzero_bits (x, mode)
 
       if (reg_last_set_value[REGNO (x)] != 0
 	  && reg_last_set_mode[REGNO (x)] == mode
-	  && (REG_N_SETS (REGNO (x)) == 1
-	      || reg_last_set_label[REGNO (x)] == label_tick)
+	  && (reg_last_set_label[REGNO (x)] == label_tick
+	      || (REGNO (x) >= FIRST_PSEUDO_REGISTER
+		  && REG_N_SETS (REGNO (x)) == 1
+		  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, 
+					REGNO (x))))
 	  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)
 	return reg_last_set_nonzero_bits[REGNO (x)];
 
@@ -7970,8 +7973,11 @@ num_sign_bit_copies (x, mode)
 
       if (reg_last_set_value[REGNO (x)] != 0
 	  && reg_last_set_mode[REGNO (x)] == mode
-	  && (REG_N_SETS (REGNO (x)) == 1
-	      || reg_last_set_label[REGNO (x)] == label_tick)
+	  && (reg_last_set_label[REGNO (x)] == label_tick
+	      || (REGNO (x) >= FIRST_PSEUDO_REGISTER
+		  && REG_N_SETS (REGNO (x)) == 1
+		  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start,
+					REGNO (x))))
 	  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)
 	return reg_last_set_sign_bit_copies[REGNO (x)];
 
@@ -10819,9 +10825,11 @@ get_last_value_validate (loc, insn, tick, replace)
 
       for (j = regno; j < endregno; j++)
 	if (reg_last_set_invalid[j]
-	    /* If this is a pseudo-register that was only set once, it is
-	       always valid.  */
-	    || (! (regno >= FIRST_PSEUDO_REGISTER && REG_N_SETS (regno) == 1)
+	    /* If this is a pseudo-register that was only set once and not
+	       live at the beginning of the function, it is always valid.  */
+	    || (! (regno >= FIRST_PSEUDO_REGISTER 
+		   && REG_N_SETS (regno) == 1
+		   && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, regno))
 		&& reg_last_set_label[j] > tick))
 	  {
 	    if (replace)
@@ -10880,12 +10888,21 @@ get_last_value (x)
   regno = REGNO (x);
   value = reg_last_set_value[regno];
 
-  /* If we don't have a value or if it isn't for this basic block,
-     return 0.  */
+  /* If we don't have a value, or if it isn't for this basic block and
+     it's either a hard register, set more than once, or it's a live
+     at the beginning of the function, return 0.  
+
+     Because if it's not live at the beginnning of the function then the reg 
+     is always set before being used (is never used without being set).
+     And, if it's set only once, and it's always set before use, then all
+     uses must have the same last value, even if it's not from this basic
+     block.  */
 
   if (value == 0
-      || (REG_N_SETS (regno) != 1
-	  && reg_last_set_label[regno] != label_tick))
+      || (reg_last_set_label[regno] != label_tick
+	  && (regno < FIRST_PSEUDO_REGISTER
+	      || REG_N_SETS (regno) != 1
+	      || REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, regno))))
     return 0;
 
   /* If the value was set in a later insn than the ones we are processing,
diff --git a/gcc/config/alpha/alpha.h b/gcc/config/alpha/alpha.h
index e9c3f6d..a109a05 100644
--- a/gcc/config/alpha/alpha.h
+++ b/gcc/config/alpha/alpha.h
@@ -622,7 +622,10 @@ extern void override_options ();
    but can be less for certain modes in special long registers.  */
 
 #define HARD_REGNO_NREGS(REGNO, MODE)   \
-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+ ((GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT			\
+   && GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)			\
+  ? 2								\
+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))
 
 /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.
    On Alpha, the integer registers can hold any mode.  The floating-point
@@ -1070,12 +1073,16 @@ extern int alpha_memory_latency;
 #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)  (CUM) = 0
 
 /* Define intermediate macro to compute the size (in registers) of an argument
-   for the Alpha.  */
+   for the Alpha.
+   A short complex arg takes two registers.  */
 
 #define ALPHA_ARG_SIZE(MODE, TYPE, NAMED)				\
-((MODE) != BLKmode							\
- ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD 	\
- : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)
+ ((GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT				\
+   && GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)				\
+  ? 2 									\
+  : ((MODE) != BLKmode							\
+     ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD 	\
+     : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))
 
 /* Update the data in CUM to advance over an argument
    of mode MODE and data type TYPE.
diff --git a/gcc/config/alpha/crtbegin.asm b/gcc/config/alpha/crtbegin.asm
index f954f1a..6350d47 100644
--- a/gcc/config/alpha/crtbegin.asm
+++ b/gcc/config/alpha/crtbegin.asm
@@ -68,6 +68,7 @@ __EH_FRAME_BEGIN__:
 	br      $29,1f
 1:	ldgp    $29,0($29)
 	jsr     $26,__do_global_dtors_aux
+	ldgp    $29,0($26)
 
 	# Ideally this call would go in crtend.o, except that we can't
 	# get hold of __EH_FRAME_BEGIN__ there.
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index fe7b411..2627040 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -722,6 +722,33 @@ arm_split_constant (code, mode, val, target, source, subtargets)
   return arm_gen_constant (code, mode, val, target, source, subtargets, 1);
 }
 
+static int
+count_insns_for_constant (HOST_WIDE_INT remainder, int i)
+{
+  HOST_WIDE_INT temp1;
+  int num_insns = 0;
+  do
+    {
+      int end;
+	  
+      if (i <= 0)
+	i += 32;
+      if (remainder & (3 << (i - 2)))
+	{
+	  end = i - 8;
+	  if (end < 0)
+	    end += 32;
+	  temp1 = remainder & ((0x0ff << end)
+				    | ((i < end) ? (0xff >> (32 - end)) : 0));
+	  remainder &= ~temp1;
+	  num_insns++;
+	  i -= 6;
+	}
+      i -= 2;
+    } while (remainder);
+  return num_insns;
+}
+
 /* As above, but extra parameter GENERATE which, if clear, suppresses
    RTL generation.  */
 int
@@ -1178,7 +1205,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)
      We start by looking for the largest block of zeros that are aligned on
      a 2-bit boundary, we then fill up the temps, wrapping around to the
      top of the word when we drop off the bottom.
-     In the worst case this code should produce no more than four insns. */
+     In the worst case this code should produce no more than four insns.  */
   {
     int best_start = 0;
     int best_consecutive_zeros = 0;
@@ -1187,9 +1214,9 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)
       {
 	int consecutive_zeros = 0;
 
-	if (! (remainder & (3 << i)))
+	if (!(remainder & (3 << i)))
 	  {
-	    while ((i < 32) && ! (remainder & (3 << i)))
+	    while ((i < 32) && !(remainder & (3 << i)))
 	      {
 		consecutive_zeros += 2;
 		i += 2;
@@ -1203,9 +1230,36 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)
 	  }
       }
 
-    /* Now start emitting the insns, starting with the one with the highest
-       bit set: we do this so that the smallest number will be emitted last;
-       this is more likely to be combinable with addressing insns. */
+    /* So long as it won't require any more insns to do so, it's
+       desirable to emit a small constant (in bits 0...9) in the last
+       insn.  This way there is more chance that it can be combined with
+       a later addressing insn to form a pre-indexed load or store
+       operation.  Consider:
+
+	       *((volatile int *)0xe0000100) = 1;
+	       *((volatile int *)0xe0000110) = 2;
+
+       We want this to wind up as:
+
+		mov rA, #0xe0000000
+		mov rB, #1
+		str rB, [rA, #0x100]
+		mov rB, #2
+		str rB, [rA, #0x110]
+
+       rather than having to synthesize both large constants from scratch.
+
+       Therefore, we calculate how many insns would be required to emit
+       the constant starting from `best_start', and also starting from 
+       zero (ie with bit 31 first to be output).  If `best_start' doesn't 
+       yield a shorter sequence, we may as well use zero.  */
+    if (best_start != 0
+	&& ((((unsigned HOST_WIDE_INT) 1) << best_start) < remainder)
+	&& (count_insns_for_constant (remainder, 0) <= 
+	    count_insns_for_constant (remainder, best_start)))
+      best_start = 0;
+
+    /* Now start emitting the insns.  */
     i = best_start;
     do
       {
@@ -1529,27 +1583,34 @@ legitimize_pic_address (orig, mode, reg)
       return gen_rtx_PLUS (Pmode, base, offset);
     }
   else if (GET_CODE (orig) == LABEL_REF)
-    current_function_uses_pic_offset_table = 1;
-
-  return orig;
-}
+    {
+      current_function_uses_pic_offset_table = 1;
 
-static rtx pic_rtx;
+      if (NEED_PLT_GOT)
+	{
+	  rtx pic_ref, address = gen_reg_rtx (Pmode);
+	  
+	  emit_insn (gen_pic_load_addr (address, orig));
+	  pic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx,
+				  address);
+	  emit_move_insn (address, pic_ref);
+	  return address;
+	}
+    }
 
-int
-is_pic(x)
-     rtx x;
-{
-  if (x == pic_rtx)
-    return 1;
-  return 0;
+  return orig;
 }
 
+/* Generate code to load the PIC register.  PROLOGUE is true if
+   called from arm_expand_prologue (in which case we want the 
+   generated insns at the start of the function);  false if called
+   by an exception receiver that needs the PIC register reloaded
+   (in which case the insns are just dumped at the current location).  */
 void
-arm_finalize_pic ()
+arm_finalize_pic (int prologue)
 {
 #ifndef AOF_ASSEMBLER
-  rtx l1, pic_tmp, pic_tmp2, seq;
+  rtx l1, pic_tmp, pic_tmp2, seq, pic_rtx;
   rtx global_offset_table;
 
   if (current_function_uses_pic_offset_table == 0)
@@ -1578,7 +1639,10 @@ arm_finalize_pic ()
 
   seq = gen_sequence ();
   end_sequence ();
-  emit_insn_after (seq, get_insns ());
+  if (prologue)
+    emit_insn_after (seq, get_insns ());
+  else
+    emit_insn (seq);
 
   /* Need to emit this whether or not we obey regdecls,
      since setjmp/longjmp can cause life info to screw up.  */
@@ -2406,6 +2470,11 @@ symbol_mentioned_p (x)
   if (GET_CODE (x) == SYMBOL_REF)
     return 1;
 
+  /* CONST_DOUBLE can contain a symbol ref for its in-memory
+     representation.  We are not interested about that case here.  */
+  if (GET_CODE (x) == CONST_DOUBLE)
+    return 0;
+
   fmt = GET_RTX_FORMAT (GET_CODE (x));
   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)
     {
@@ -5327,7 +5396,13 @@ output_return_instruction (operand, really_return, reverse)
   if (frame_pointer_needed)
     live_regs += 4;
 
-  if (live_regs)
+  if (live_regs == 1 && regs_ever_live[LR_REGNUM]
+      && ! lr_save_eliminated && ! really_return)
+    {
+      output_asm_insn (reverse ? "ldr%?%D0\t%|lr, [%|sp}, #4"
+      		       : "ldr%?%d0\t%|lr, [%|sp], #4", &operand);
+    }
+  else if (live_regs)
     {
       if (lr_save_eliminated || ! regs_ever_live[14])
         live_regs++;
@@ -5446,7 +5521,7 @@ arm_poke_function_name (stream, name)
   rtx           x;
 
   length = strlen (name);
-  alignlength = (length + 1) + 3 & ~3;
+  alignlength = ((length + 1) + 3) & ~3;
   
   ASM_OUTPUT_ASCII (stream, name, length + 1);
   ASM_OUTPUT_ALIGN (stream, 2);
@@ -5838,6 +5913,9 @@ arm_expand_prologue ()
   int store_arg_regs = 0;
   int volatile_func = (optimize > 0
 		       && TREE_THIS_VOLATILE (current_function_decl));
+  rtx ip_rtx;
+  int fp_offset = 0;
+  rtx insn;
 
   /* Naked functions don't have prologues.  */
   if (arm_naked_function_p (current_function_decl))
@@ -5859,11 +5937,59 @@ arm_expand_prologue ()
 	live_regs_mask |= 0x4000;
     }
 
+  ip_rtx = gen_rtx_REG (SImode, IP_REGNUM);
+
   if (frame_pointer_needed)
     {
+      if (current_function_needs_context)
+	{
+	  /* The Static chain register is the same as the IP register
+	     used as a scratch register during stack frame creation.
+	     To get around this need to find somewhere to store IP
+	     whilst the frame is being created.  We try the following
+	     places in order:
+	     
+	       1. An unused argument register.
+	       2. A slot on the stack above the frame.  (This only
+	          works if the function is not a varargs function).
+		  
+	     If neither of these places is available, we abort (for now).  */
+	  if (regs_ever_live[3] == 0)
+	    {
+	      insn = gen_rtx_REG (SImode, 3);
+	      insn = gen_rtx_SET (SImode, insn, ip_rtx);
+	      insn = emit_insn (insn);
+	      RTX_FRAME_RELATED_P (insn) = 1;	  
+	    }
+	  else if (current_function_pretend_args_size == 0)
+	    {
+	      insn = gen_rtx_PRE_DEC (SImode, stack_pointer_rtx);
+	      insn = gen_rtx_MEM (SImode, insn);
+	      insn = gen_rtx_SET (VOIDmode, insn, ip_rtx);
+	      insn = emit_insn (insn);
+	      RTX_FRAME_RELATED_P (insn) = 1;
+	      fp_offset = 4;
+	    }
+	  else
+	    /* FIXME - the way to handle this situation is to allow
+	       the pretend args to be dumped onto the stack, then
+	       reuse r3 to save IP.  This would involve moving the
+	       copying os SP into IP until after the pretend args
+	       have been dumped, but this is not too hard.  */
+	    error ("Unable to find a temporary location for static chanin register");
+	}
+
       live_regs_mask |= 0xD800;
-      emit_insn (gen_movsi (gen_rtx_REG (SImode, 12),
-			    stack_pointer_rtx));
+      if (fp_offset)
+	{
+	  insn = gen_rtx_PLUS (SImode, stack_pointer_rtx, GEN_INT (fp_offset));
+	  insn = gen_rtx_SET  (SImode, ip_rtx, insn);
+	}
+      else
+	insn = gen_movsi (ip_rtx, stack_pointer_rtx);
+      
+       insn = emit_insn (insn);
+       RTX_FRAME_RELATED_P (insn) = 1;
     }
 
   if (current_function_pretend_args_size)
@@ -5927,9 +6053,31 @@ arm_expand_prologue ()
     }
 
   if (frame_pointer_needed)
-    emit_insn (gen_addsi3 (hard_frame_pointer_rtx, gen_rtx_REG (SImode, 12),
-			   (GEN_INT
-			    (-(4 + current_function_pretend_args_size)))));
+    {
+      insn = GEN_INT (-(4 + current_function_pretend_args_size + fp_offset));
+      insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx, ip_rtx, insn));
+      RTX_FRAME_RELATED_P (insn) = 1;
+      
+      if (current_function_needs_context)
+	{
+	  /* Recover the static chain register.  */
+	  if (regs_ever_live [3] == 0)
+	    {
+	      insn = gen_rtx_REG (SImode, 3);
+	      insn = gen_rtx_SET (SImode, ip_rtx, insn);
+	      insn = emit_insn (insn);
+	      RTX_FRAME_RELATED_P (insn) = 1;	  
+	    }
+	  else /* if (current_function_pretend_args_size == 0) */
+	    {
+	      insn = gen_rtx_PLUS (SImode, hard_frame_pointer_rtx, GEN_INT (4));
+	      insn = gen_rtx_MEM (SImode, insn);
+	      insn = gen_rtx_SET (SImode, ip_rtx, insn);
+	      insn = emit_insn (insn);
+	      RTX_FRAME_RELATED_P (insn) = 1;	  
+	    }
+	}
+    }
 
   if (amount != const0_rtx)
     {
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index 02f0656..2c2784e 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -601,14 +601,20 @@ extern int arm_is_6_or_7;
   (TREE_CODE (EXP) == STRING_CST        \
    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))
 
+#ifndef STRUCTURE_SIZE_BOUNDARY
 /* Every structures size must be a multiple of 32 bits.  */
 /* This is for compatibility with ARMCC.  ARM SDT Reference Manual
    (ARM DUI 0020D) page 2-20 says "Structures are aligned on word
    boundaries".  */
-#ifndef STRUCTURE_SIZE_BOUNDARY
-#define STRUCTURE_SIZE_BOUNDARY 32
+/* Setting this to 32 produces more efficient code, but the value set in previous
+   versions of this toolchain was 8, which produces more compact structures. The
+   command line option -mstructure_size_boundary=<n> can be used to change this
+   value.  */
+#define STRUCTURE_SIZE_BOUNDARY arm_structure_size_boundary
 #endif
 
+extern int arm_structure_size_boundary;
+
 /* Used when parsing command line option -mstructure_size_boundary.  */
 extern const char * structure_size_string;
 
@@ -768,6 +774,9 @@ extern const char * structure_size_string;
 /* Specify the registers used for certain standard purposes.
    The values of these macros are register numbers.  */
 
+/* Register which holds return address from a subroutine call.  */
+#define LR_REGNUM		14
+
 /* Define this if the program counter is overloaded on a register.  */
 #define PC_REGNUM		15
 
@@ -777,6 +786,9 @@ extern const char * structure_size_string;
 /* Base register for access to local variables of the function.  */
 #define FRAME_POINTER_REGNUM	25
 
+/* Scratch register - used in all kinds of places, eg trampolines.  */
+#define IP_REGNUM		12
+
 /* Define this to be where the real frame pointer is if it is not possible to
    work out the offset between the frame pointer and the automatic variables
    until after register allocation has taken place.  FRAME_POINTER_REGNUM
@@ -798,7 +810,7 @@ extern const char * structure_size_string;
 /* The native (Norcroft) Pascal compiler for the ARM passes the static chain
    as an invisible last argument (possible since varargs don't exist in
    Pascal), so the following is not true.  */
-#define STATIC_CHAIN_REGNUM	8
+#define STATIC_CHAIN_REGNUM	12
 
 /* Register in which address to store a structure value
    is passed to a function.  */
@@ -1248,7 +1260,12 @@ do {									\
 {									\
   int volatile_func = arm_volatile_func ();				\
   if ((FROM) == ARG_POINTER_REGNUM && (TO) == HARD_FRAME_POINTER_REGNUM)\
-    (OFFSET) = 0;							\
+    {                                                                   \
+      if (! current_function_needs_context || ! frame_pointer_needed)   \
+        (OFFSET) = 0;                                                   \
+      else                                                              \
+        (OFFSET) = 4;                                                   \
+    }                                                                   \
   else if ((FROM) == FRAME_POINTER_REGNUM				\
 	   && (TO) == STACK_POINTER_REGNUM)				\
     (OFFSET) = (current_function_outgoing_args_size			\
@@ -1379,8 +1396,10 @@ do {									\
 
    On the ARM, allow any integer (invalid ones are removed later by insn
    patterns), nice doubles and symbol_refs which refer to the function's
-   constant pool XXX.  */
-#define LEGITIMATE_CONSTANT_P(X)	(! label_mentioned_p (X))
+   constant pool XXX.
+
+   When generating PIC code, allow anything.  */
+#define LEGITIMATE_CONSTANT_P(X)	(flag_pic || ! label_mentioned_p (X))
 
 /* Symbols in the text segment can be accessed without indirecting via the
    constant pool; it may take an extra binary operation, but this is still
@@ -1496,9 +1515,8 @@ do									\
 	      && INTVAL (op) <= 31)					\
 	    goto LABEL;							\
         }								\
-      /* NASTY: Since this limits the addressing of unsigned byte loads */      \
       range = ((MODE) == HImode || (MODE) == QImode)                    \
-              ? (arm_arch4 ? 256 : 4095) : 4096;                        \
+              ? (((MODE) == HImode && arm_arch4) ? 256 : 4095) : 4096;  \
       if (code == CONST_INT && INTVAL (INDEX) < range			\
 	  && INTVAL (INDEX) > -range)  	      				\
         goto LABEL;							\
@@ -1812,14 +1830,15 @@ extern int arm_pic_register;
    data addresses in memory.  */
 #define PIC_OFFSET_TABLE_REGNUM arm_pic_register
 
-#define FINALIZE_PIC arm_finalize_pic ()
+#define FINALIZE_PIC arm_finalize_pic (1)
 
-/* We can't directly access anything that contains a symbol,
+/* We can't directly access anything that contains a symbol or label,
    nor can we indirect via the constant pool.  */
 #define LEGITIMATE_PIC_OPERAND_P(X)				\
-	(! symbol_mentioned_p (X)				\
+	(! symbol_mentioned_p (X) && ! label_mentioned_p (X)	\
 	 && (! CONSTANT_POOL_ADDRESS_P (X)			\
-	     || ! symbol_mentioned_p (get_pool_constant (X))))
+	     || (! symbol_mentioned_p (get_pool_constant (X)))  \
+		&& (! label_mentioned_p (get_pool_constant (X)))))
  
 /* We need to know when we are making a constant pool; this determines
    whether data needs to be in the GOT or can be referenced via a GOT
@@ -2046,17 +2065,9 @@ extern struct rtx_def *arm_compare_op0, *arm_compare_op1;
   else output_addr_const(STREAM, X);					\
 }
 
-/* Handles PIC addr specially */
 #define OUTPUT_INT_ADDR_CONST(STREAM,X) \
   {									\
-    if (flag_pic && GET_CODE(X) == CONST && is_pic(X))			\
-      {									\
-	output_addr_const(STREAM, XEXP (XEXP (XEXP (X, 0), 0), 0));	\
-	fputs(" - (", STREAM);						\
-	output_addr_const(STREAM, XEXP (XEXP (XEXP (X, 0), 1), 0));	\
-	fputs(")", STREAM);						\
-      }									\
-    else output_addr_const(STREAM, X);					\
+    output_addr_const(STREAM, X);					\
 									\
     /* Mark symbols as position independent.  We only do this in the	\
       .text segment, not in the .data segment. */			\
@@ -2170,8 +2181,7 @@ Rcode  arm_canonicalize_comparison RTX_CODE_PROTO ((Rcode,  Rtx *));
 int    arm_return_in_memory PROTO ((Tree));
 int    legitimate_pic_operand_p PROTO ((Rtx));
 Rtx    legitimize_pic_address PROTO ((Rtx, Mmode, Rtx));
-int    is_pic PROTO ((Rtx));
-void   arm_finalize_pic PROTO ((void));
+void   arm_finalize_pic PROTO ((int));
 int    arm_rtx_costs RTX_CODE_PROTO ((Rtx, Rcode));
 int    arm_adjust_cost PROTO ((Rtx, Rtx, Rtx, int));
 int    const_double_rtx_ok_for_fpu PROTO ((Rtx));
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index de40322..3ace4e8 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -2629,7 +2629,8 @@
 			   : preserve_subexpressions_p ()));
       DONE;
     }
-  if (CONSTANT_P (operands[1]) && flag_pic)
+  if ((CONSTANT_P (operands[1]) || symbol_mentioned_p (operands[1])
+        || label_mentioned_p (operands[1])) && flag_pic)
     operands[1] = legitimize_pic_address (operands[1], SImode,
 					  ((reload_in_progress
 					    || reload_completed)
@@ -2721,6 +2722,15 @@
   return \"add%?\\t%0, %|pc, %0\";
 ")
 
+(define_expand "builtin_setjmp_receiver"
+  [(label_ref (match_operand 0 "" ""))]
+  "flag_pic"
+  "
+{
+  arm_finalize_pic (0);
+  DONE;
+}")
+
 ;; If copying one reg to another we can set the condition codes according to
 ;; its value.  Such a move is common after a return from subroutine and the
 ;; result is being tested against zero.
@@ -6184,15 +6194,20 @@
 	abort ();
       return \"\";
     }
-  strcpy (pattern, \"stmfd\\t%m0!, {%1\");
-  for (i = 1; i < XVECLEN (operands[2], 0); i++)
+  if (XVECLEN (operands[2], 0) > 1)
     {
-      strcat (pattern, \", %|\");
-      strcat (pattern, reg_names[REGNO (XEXP (XVECEXP (operands[2], 0, i),
+      strcpy (pattern, \"stmfd\\t%m0!, {%1\");
+      for (i = 1; i < XVECLEN (operands[2], 0); i++)
+        {
+           strcat (pattern, \", %|\");
+           strcat (pattern, reg_names[REGNO (XEXP (XVECEXP (operands[2], 0, i),
 					      0))]);
+        }
+      strcat (pattern, \"}\");
+      output_asm_insn (pattern, operands);
     }
-  strcat (pattern, \"}\");
-  output_asm_insn (pattern, operands);
+  else
+    output_asm_insn (\"str\\t%1, [%m0, #-4]!\", operands);
   return \"\";
 }"
 [(set_attr "type" "store4")])
diff --git a/gcc/config/arm/elf.h b/gcc/config/arm/elf.h
index 63ec125..65371ff 100644
--- a/gcc/config/arm/elf.h
+++ b/gcc/config/arm/elf.h
@@ -167,15 +167,6 @@ do {									 \
 #define MULTILIB_DEFAULTS { "mlittle-endian", "msoft-float", "mapcs-32", "mno-thumb-interwork" }
 #endif
 
-/* Setting this to 32 produces more efficient code, but the value set in previous
-   versions of this toolchain was 8, which produces more compact structures. The
-   command line option -mstructure_size_boundary=<n> can be used to change this
-   value.  */
-#undef  STRUCTURE_SIZE_BOUNDARY
-#define STRUCTURE_SIZE_BOUNDARY arm_structure_size_boundary
-
-extern int arm_structure_size_boundary;
-
 /* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS
    is a valid machine specific attribute for DECL.
    The attributes in ATTRIBUTES have previously been assigned to DECL.  */
diff --git a/gcc/config/arm/lib1funcs.asm b/gcc/config/arm/lib1funcs.asm
index 831914b..6092dad 100644
--- a/gcc/config/arm/lib1funcs.asm
+++ b/gcc/config/arm/lib1funcs.asm
@@ -215,6 +215,13 @@ Loop3:
 	@ then none of the below will match, since the bit in ip will not be
 	@ in the bottom nibble.
 	ands	overdone, overdone, #0xe0000000
+	@ If we terminated early, because dividend became zero, then the 
+	@ bit in ip will not be in the bottom nibble, and we should not
+	@ perform the additions below.  We must test for this though
+	@ (rather relying upon the TSTs to prevent the additions) since
+	@ the bit in ip could be in the top two bits which might then match
+	@ with one of the smaller RORs.
+	tstne	ip, #0x7
 	RETc(eq)	pc, lr				@ No fixups needed
 	tst	overdone, ip, ror #3
 	addne	dividend, dividend, divisor, lsr #3
@@ -397,6 +404,13 @@ Loop3:
 	@ then none of the below will match, since the bit in ip will not be
 	@ in the bottom nibble.
 	ands	overdone, overdone, #0xe0000000
+	@ If we terminated early, because dividend became zero, then the 
+	@ bit in ip will not be in the bottom nibble, and we should not
+	@ perform the additions below.  We must test for this though
+	@ (rather relying upon the TSTs to prevent the additions) since
+	@ the bit in ip could be in the top two bits which might then match
+	@ with one of the smaller RORs.
+	tstne	ip, #0x7
 	beq	Lgot_result
 	tst	overdone, ip, ror #3
 	addne	dividend, dividend, divisor, lsr #3
diff --git a/gcc/config/arm/linux-elf.h b/gcc/config/arm/linux-elf.h
index a7e9e28..108050d 100644
--- a/gcc/config/arm/linux-elf.h
+++ b/gcc/config/arm/linux-elf.h
@@ -263,3 +263,14 @@ const_section ()							\
 #undef  FP_DEFAULT
 #define FP_DEFAULT FP_SOFT3
 #endif
+
+/* Call the function profiler with a given profile label.  */
+#undef  FUNCTION_PROFILER
+#define FUNCTION_PROFILER(STREAM, LABELNO)  			\
+{									\
+  fprintf (STREAM, "\tbl\tmcount%s\n", NEED_PLT_GOT ? "(PLT)" : "");	\
+}
+
+#undef  CC1_SPEC
+#define CC1_SPEC "%{profile:-p}"
+
diff --git a/gcc/config/arm/linux-gas.h b/gcc/config/arm/linux-gas.h
index f2b5d42..64bfc23 100644
--- a/gcc/config/arm/linux-gas.h
+++ b/gcc/config/arm/linux-gas.h
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GNU compiler.
    ARM Linux-based GNU systems version.
-   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
    Contributed by Russell King  <rmk92@ecs.soton.ac.uk>.
 
 This file is part of GNU CC.
@@ -79,5 +79,7 @@ Boston, MA 02111-1307, USA.  */
   register unsigned long _beg __asm ("a1") = (unsigned long) (BEG);	\
   register unsigned long _end __asm ("a2") = (unsigned long) (END);	\
   register unsigned long _flg __asm ("a3") = 0;				\
-  __asm __volatile ("swi 0x9f0002");					\
+  __asm __volatile ("swi 0x9f0002		@ sys_cacheflush"	\
+		    : "=r" (_beg)					\
+		    : "0" (_beg), "r" (_end), "r" (_flg));		\
 }
diff --git a/gcc/config/arm/t-linux b/gcc/config/arm/t-linux
index 9b7c3e3..462ed7a 100644
--- a/gcc/config/arm/t-linux
+++ b/gcc/config/arm/t-linux
@@ -1,6 +1,6 @@
 # Just for these, we omit the frame pointer since it makes such a big
 # difference.  It is then pointless adding debugging.
-TARGET_LIBGCC2_CFLAGS = -fomit-frame-pointer -fPIC
+TARGET_LIBGCC2_CFLAGS = -fomit-frame-pointer -fPIC 
 LIBGCC2_DEBUG_CFLAGS = -g0
 
 # Don't build enquire
diff --git a/gcc/config/i386/freebsd-elf.h b/gcc/config/i386/freebsd-elf.h
index e97d4ca..4e45020 100644
--- a/gcc/config/i386/freebsd-elf.h
+++ b/gcc/config/i386/freebsd-elf.h
@@ -135,6 +135,9 @@ Boston, MA 02111-1307, USA.  */
  : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \
  : (-1))
 
+#undef  NO_PROFILE_COUNTERS
+#define NO_PROFILE_COUNTERS
+
 /* Tell final.c that we don't need a label passed to mcount.  */
 
 #undef FUNCTION_PROFILER
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 0333b19..d3977fa 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -291,7 +291,7 @@ override_options ()
 
   if (ix86_arch_string == 0)
     {
-      ix86_arch_string = PROCESSOR_PENTIUM_STRING;
+      ix86_arch_string = PROCESSOR_DEFAULT_STRING;
       if (ix86_cpu_string == 0)
 	ix86_cpu_string = PROCESSOR_DEFAULT_STRING;
     }
@@ -308,7 +308,7 @@ override_options ()
   if (i == ptt_size)
     {
       error ("bad value (%s) for -march= switch", ix86_arch_string);
-      ix86_arch_string = PROCESSOR_PENTIUM_STRING;
+      ix86_arch_string = PROCESSOR_DEFAULT_STRING;
       ix86_arch = PROCESSOR_DEFAULT;
     }
 
diff --git a/gcc/config/i386/linux.h b/gcc/config/i386/linux.h
index 7b368f8..165c013 100644
--- a/gcc/config/i386/linux.h
+++ b/gcc/config/i386/linux.h
@@ -234,3 +234,21 @@ Boston, MA 02111-1307, USA.  */
     }									\
   } while (0)
 #endif
+
+#if defined(__PIC__) && defined (USE_GNULIBC_1)
+/* This is a kludge. The i386 GNU/Linux dynamic linker needs ___brk_addr,
+   __environ and atexit (). We have to make sure they are in the .dynsym
+   section. We accomplish it by making a dummy call here. This
+   code is never reached.  */
+
+#define CRT_END_INIT_DUMMY             \
+  do                                   \
+    {                                  \
+      extern void *___brk_addr;                \
+      extern char **__environ;         \
+                                       \
+      ___brk_addr = __environ;         \
+      atexit (0);                      \
+    }                                  \
+  while (0)
+#endif
diff --git a/gcc/config/mips/linux.h b/gcc/config/mips/linux.h
index f4ed424..dff5f9f 100644
--- a/gcc/config/mips/linux.h
+++ b/gcc/config/mips/linux.h
@@ -1,5 +1,5 @@
 /* Definitions for MIPS running Linux-based GNU systems with ELF format.
-   Copyright (C) 1998 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
 
 This file is part of GNU CC.
 
@@ -18,16 +18,106 @@ along with GNU CC; see the file COPYING.  If not, write to
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
-/* Required to keep collect2.c happy */
-#undef OBJECT_FORMAT_COFF 
+#undef TARGET_VERSION
+#if TARGET_ENDIAN_DEFAULT == 0
+#define TARGET_VERSION fprintf (stderr, " (MIPSel GNU/Linux with ELF)");
+#else
+#define TARGET_VERSION fprintf (stderr, " (MIPS GNU/Linux with ELF)");
+#endif
+
+#undef MD_EXEC_PREFIX
+#undef MD_STARTFILE_PREFIX
 
-#define HAVE_ATEXIT
+/* Output at beginning of assembler file.  */
+/* The .file command should always begin the output.  */
+#undef ASM_FILE_START
+#define ASM_FILE_START(FILE)						\
+  do {									\
+	mips_asm_file_start (FILE);					\
+	fprintf (FILE, "\t.version\t\"01.01\"\n");			\
+  } while (0)
+
+
+/* Required to keep collect2.c happy */
+#undef OBJECT_FORMAT_COFF
 
 /* If we don't set MASK_ABICALLS, we can't default to PIC. */
 #undef TARGET_DEFAULT
 #define TARGET_DEFAULT (MASK_ABICALLS|MASK_GAS)
 
 
+/* Handle #pragma weak and #pragma pack.  */
+#define HANDLE_SYSV_PRAGMA 1
+
+/* Use more efficient ``thunks'' to implement C++ vtables. */
+#undef DEFAULT_VTABLE_THUNKS
+#define DEFAULT_VTABLE_THUNKS 1
+
+/* Don't assume anything about the header files.  */
+#define NO_IMPLICIT_EXTERN_C
+
+/* Generate calls to memcpy, etc., not bcopy, etc.  */
+#define TARGET_MEM_FUNCTIONS
+
+/* Specify predefined symbols in preprocessor.  */
+#undef CPP_PREDEFINES
+#if TARGET_ENDIAN_DEFAULT == 0
+#define CPP_PREDEFINES "-DMIPSEL -D_MIPSEL -Dunix -Dmips -D_mips \
+-DR3000 -D_R3000 -Dlinux -Asystem(posix) -Acpu(mips) \
+-Amachine(mips) -D__ELF__ -D__PIC__ -D__pic__"
+#else
+#define CPP_PREDEFINES "-DMIPSEB -D_MIPSEB -Dunix -Dmips -D_mips \
+-DR3000 -D_R3000 -Dlinux -Asystem(posix) -Acpu(mips) \
+-Amachine(mips) -D__ELF__ -D__PIC__ -D__pic__"
+#endif
+
+#undef SUBTARGET_CPP_SIZE_SPEC
+#define SUBTARGET_CPP_SIZE_SPEC "\
+%{mabi=32: -D__SIZE_TYPE__=unsigned\\ int -D__PTRDIFF_TYPE__=int} \
+%{mabi=n32: -D__SIZE_TYPE__=unsigned\\ int -D__PTRDIFF_TYPE__=int} \
+%{mabi=64: -D__SIZE_TYPE__=long\\ unsigned\\ int -D__PTRDIFF_TYPE__=long\\ int} \
+%{!mabi*: -D__SIZE_TYPE__=unsigned\\ int -D__PTRDIFF_TYPE__=int}"
+
+/* We must make -mips3 do what -mlong64 used to do.  */
+/* ??? If no mipsX option given, but a mabi=X option is, then should set
+   _MIPS_ISA based on the mabi=X option.  */
+/* ??? If no mabi=X option give, but a mipsX option is, then should set
+   _MIPS_SIM based on the mipsX option.  */
+/* ??? Same for _MIPS_SZINT.  */
+/* ??? Same for _MIPS_SZPTR.  */
+/* ??? Same for __SIZE_TYPE and __PTRDIFF_TYPE.  */
+#undef SUBTARGET_CPP_SPEC
+#define SUBTARGET_CPP_SPEC "\
+%{mfp32: -D_MIPS_FPSET=16} \
+%{mfp64: -D_MIPS_FPSET=32} \
+%{!mfp*: -D_MIPS_FPSET=32} \
+%{mips1: -D_MIPS_ISA=_MIPS_ISA_MIPS1} \
+%{mips2: -D_MIPS_ISA=_MIPS_ISA_MIPS2} \
+%{mips3: -D_MIPS_ISA=_MIPS_ISA_MIPS3} \
+%{mips4: -D_MIPS_ISA=_MIPS_ISA_MIPS4} \
+%{!mips*: -D_MIPS_ISA=_MIPS_ISA_MIPS1} \
+%{mabi=32: -D_MIPS_SIM=_MIPS_SIM_ABI32}	\
+%{mabi=n32: -D_ABIN32=2 -D_MIPS_SIM=_ABIN32} \
+%{mabi=64: -D_ABI64=3 -D_MIPS_SIM=_ABI64} \
+%{!mabi*: -D_MIPS_SIM=_MIPS_SIM_ABI32}	\
+%{!mint64: -D_MIPS_SZINT=32}%{mint64: -D_MIPS_SZINT=64} \
+%{mabi=32: -D_MIPS_SZLONG=32} \
+%{mabi=n32: -D_MIPS_SZLONG=32} \
+%{mabi=64: -D_MIPS_SZLONG=64} \
+%{!mabi*: -D_MIPS_SZLONG=32} \
+%{mabi=32: -D_MIPS_SZPTR=32} \
+%{mabi=n32: -D_MIPS_SZPTR=32} \
+%{mabi=64: -D_MIPS_SZPTR=64} \
+%{!mabi*: -D_MIPS_SZPTR=32} \
+%{!mips*: -U__mips -D__mips} \
+%{mabi=32: -U__mips64} \
+%{mabi=n32: -D__mips64} \
+%{mabi=64: -U__mips64} \
+%{!mabi*: -U__mips64} \
+%{fno-PIC:-U__PIC__ -U__pic__} %{fno-pic:-U__PIC__ -U__pic__} \
+%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} \
+%{pthread:-D_REENTRANT}"
+
 /* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add
    the GNU/Linux magical crtbegin.o file (see crtstuff.c) which
    provides part of the support for getting C++ file-scope static
@@ -55,9 +145,18 @@ Boston, MA 02111-1307, USA.  */
 #undef MIPS_DEFAULT_GVALUE
 #define MIPS_DEFAULT_GVALUE 0
 
+#undef LIB_SPEC
+/* Taken from sparc/linux.h.  */
+#define LIB_SPEC \
+  "%{shared: -lc} \
+   %{!shared: %{mieee-fp:-lieee} %{pthread:-lpthread} \
+     %{profile:-lc_p} %{!profile: -lc}}"
+
 /* Borrowed from sparc/linux.h */
 #undef LINK_SPEC
-#define LINK_SPEC "-Y P,/usr/lib %{shared:-shared} \
+#define LINK_SPEC \
+ "%(endian_spec) \
+  %{shared:-shared} \
   %{!shared: \
     %{!ibcs: \
       %{!static: \
@@ -67,33 +166,24 @@ Boston, MA 02111-1307, USA.  */
 
 
 #undef SUBTARGET_ASM_SPEC
-#define SUBTARGET_ASM_SPEC "-KPIC"
+#define SUBTARGET_ASM_SPEC "\
+%{mabi=64: -64} \
+%{!fno-PIC:%{!fno-pic:-KPIC}} \
+%{fno-PIC:-non_shared} %{fno-pic:-non_shared}"
 
-/* Undefine the following which were defined in elf.h.  This will cause the linux
-   port to continue to use collect2 for constructors/destructors.  These may be removed
-   when .ctor/.dtor section support is desired. */
+/* On svr4, we *do* have support for the .init and .fini sections, and we
+   can put stuff in there to be executed before and after `main'.  We let
+   crtstuff.c and other files know this by defining the following symbols.
+   The definitions say how to change sections to the .init and .fini
+   sections.  This is the same for all known svr4 assemblers.  */
 
-#undef CTORS_SECTION_ASM_OP
-#undef DTORS_SECTION_ASM_OP
-
-#undef EXTRA_SECTIONS
-#define EXTRA_SECTIONS in_sdata, in_rdata
-
-#undef INVOKE__main
-#undef NAME__MAIN
-#undef SYMBOL__MAIN
-
-#undef EXTRA_SECTION_FUNCTIONS
-#define EXTRA_SECTION_FUNCTIONS                                         \
-  SECTION_FUNCTION_TEMPLATE(sdata_section, in_sdata, SDATA_SECTION_ASM_OP) \
-  SECTION_FUNCTION_TEMPLATE(rdata_section, in_rdata, RDATA_SECTION_ASM_OP)
-
-#undef ASM_OUTPUT_CONSTRUCTOR
-#undef ASM_OUTPUT_DESTRUCTOR
+#define INIT_SECTION_ASM_OP     "\t.section\t.init"
+#define FINI_SECTION_ASM_OP     "\t.section\t.fini"
 
+/* Undef junk imported from mips/elf.h.  */
 #undef CTOR_LIST_BEGIN
 #undef CTOR_LIST_END
 #undef DTOR_LIST_BEGIN
 #undef DTOR_LIST_END
 
-/*  End of undefines to turn off .ctor/.dtor section support */
+#undef INVOKE__main
diff --git a/gcc/config/mips/mips.h b/gcc/config/mips/mips.h
index 7360e1b..93d24a5 100644
--- a/gcc/config/mips/mips.h
+++ b/gcc/config/mips/mips.h
@@ -599,11 +599,11 @@ extern void		mips_select_section ();
    linker will default to using big-endian output files.  The OUTPUT_FORMAT
    line must be in the linker script, otherwise -EB/-EL will not work.  */
 
-#ifndef LINKER_ENDIAN_SPEC
+#ifndef ENDIAN_SPEC
 #if TARGET_ENDIAN_DEFAULT == 0
-#define LINKER_ENDIAN_SPEC "%{!EB:%{!meb:-EL}}"
+#define ENDIAN_SPEC "%{!EB:%{!meb:-EL}} %{EL} %{EB}"
 #else
-#define LINKER_ENDIAN_SPEC ""
+#define ENDIAN_SPEC "%{!EL:%{!mel:-EB}} %{EB} %{EL}"
 #endif
 #endif
 
@@ -821,7 +821,7 @@ while (0)
 /* GAS_ASM_SPEC is passed when using gas, rather than the MIPS
    assembler.  */
 
-#define GAS_ASM_SPEC "%{mcpu=*} %{m4650} %{mmad:-m4650} %{m3900} %{v}"
+#define GAS_ASM_SPEC "%{mcpu=*} %{m4650} %{mmad} %{m3900} %{v}"
 
 /* TARGET_ASM_SPEC is used to select either MIPS_AS_ASM_SPEC or
    GAS_ASM_SPEC as the default, depending upon the value of
@@ -871,7 +871,8 @@ while (0)
 /* ASM_SPEC is the set of arguments to pass to the assembler.  */
 
 #define ASM_SPEC "\
-%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{mips4} \
+%(endian_spec) \
+%{G*} %{mips1} %{mips2} %{mips3} %{mips4} \
 %{mips16:%{!mno-mips16:-mips16}} %{mno-mips16:-no-mips16} \
 %(subtarget_asm_optimizing_spec) \
 %(subtarget_asm_debugging_spec) \
@@ -925,9 +926,9 @@ while (0)
 
 #ifndef LINK_SPEC
 #define LINK_SPEC "\
-%{G*} %{EB} %{EL} %{mips1} %{mips2} %{mips3} %{mips4} \
-%{bestGnum} %{shared} %{non_shared} \
-%(linker_endian_spec)"
+%(endian_spec) \
+%{G*} %{mips1} %{mips2} %{mips3} %{mips4} \
+%{bestGnum} %{shared} %{non_shared}"
 #endif	/* LINK_SPEC defined */
 
 /* Specs for the compiler proper */
@@ -1035,7 +1036,7 @@ while (0)
   { "subtarget_asm_optimizing_spec", SUBTARGET_ASM_OPTIMIZING_SPEC },	\
   { "subtarget_asm_debugging_spec", SUBTARGET_ASM_DEBUGGING_SPEC },	\
   { "subtarget_asm_spec", SUBTARGET_ASM_SPEC },				\
-  { "linker_endian_spec", LINKER_ENDIAN_SPEC },				\
+  { "endian_spec", ENDIAN_SPEC },					\
   SUBTARGET_EXTRA_SPECS
 
 #ifndef SUBTARGET_EXTRA_SPECS
@@ -1934,7 +1935,7 @@ extern enum reg_class mips_regno_to_class[];
 
 extern enum reg_class mips_char_to_class[];
 
-#define REG_CLASS_FROM_LETTER(C) mips_char_to_class[ (C) ]
+#define REG_CLASS_FROM_LETTER(C) mips_char_to_class[(unsigned char)(C)]
 
 /* The letters I, J, K, L, M, N, O, and P in a register constraint
    string can be used to stand for particular ranges of immediate
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index 81c5cd3..9eb53ab 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -2441,17 +2441,11 @@
     {
       if (GENERATE_BRANCHLIKELY)
 	{
-          if (GET_CODE (operands[1]) == CONST_INT)
-	    return \"%(beql\\t%0,$0,1f\\n\\tbreak\\t%2\\n1:%)\";
-	  else
-	    return \"%(beql\\t%0,%1,1f\\n\\tbreak\\t%2\\n1:%)\";
+	  return \"%(beql\\t%0,%z1,1f\\n\\tbreak\\t%2\\n1:%)\";
 	}
       else
 	{
-          if (GET_CODE (operands[1]) == CONST_INT)
-	    return \"%(bne\\t%0,$0,1f\\n\\tnop\\n\\tbreak\\t%2\\n1:%)\";
-	  else
-	    return \"%(bne\\t%0,%1,1f\\n\\tnop\\n\\tbreak\\t%2\\n1:%)\";
+	  return \"%(bne\\t%0,%z1,1f\\n\\tnop\\n\\tbreak\\t%2\\n1:%)\";
 	}
     }
   return \"\";
@@ -2485,10 +2479,7 @@
   if (! have_dep_anti)
     {
       /* No branch delay slots on mips16. */ 
-      if (GET_CODE (operands[1]) == CONST_INT)
-        return \"%(bnez\\t%0,1f\\n\\tbreak\\t%2\\n1:%)\";
-      else
-        return \"%(bne\\t%0,%1,1f\\n\\tbreak\\t%2\\n1:%)\";
+      return \"%(bne\\t%0,%z1,1f\\n\\tbreak\\t%2\\n1:%)\";
     }
   return \"\";
 }"
@@ -4678,7 +4669,7 @@ move\\t%0,%z4\\n\\
 
   if ((INTVAL (offset) & 3) == 0
       && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))
-    return \"sw\\t%1,%0\";
+    return \"sw\\t%z1,%0\";
 
   return \"usw\\t%z1,%0\";
 }"
@@ -4737,7 +4728,7 @@ move\\t%0,%z4\\n\\
 
   if ((INTVAL (offset) & 7) == 0
       && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))
-    return \"sd\\t%1,%0\";
+    return \"sd\\t%z1,%0\";
 
   return \"usd\\t%z1,%0\";
 }"
@@ -10083,6 +10074,21 @@ move\\t%0,%z4\\n\\
   [(set_attr "type" "move")
    (set_attr "mode" "SF")])
 
+(define_insn ""
+  [(set (match_operand:SF 0 "register_operand" "=f,f")
+	(if_then_else:SF
+	 (match_operator 4 "equality_op"
+			 [(match_operand:DI 1 "se_register_operand" "d,d")
+			  (const_int 0)])
+	 (match_operand:SF 2 "register_operand" "f,0")
+	 (match_operand:SF 3 "register_operand" "0,f")))]
+  "mips_isa >= 4 && TARGET_HARD_FLOAT"
+  "@
+    mov%B4.s\\t%0,%2,%1
+    mov%b4.s\\t%0,%3,%1"
+  [(set_attr "type" "move")
+   (set_attr "mode" "SF")])
+
 (define_insn ""
   [(set (match_operand:SF 0 "register_operand" "=f,f")
 	(if_then_else:SF
@@ -10114,6 +10120,21 @@ move\\t%0,%z4\\n\\
   [(set_attr "type" "move")
    (set_attr "mode" "DF")])
 
+(define_insn ""
+  [(set (match_operand:DF 0 "register_operand" "=f,f")
+	(if_then_else:DF
+	 (match_operator 4 "equality_op"
+			 [(match_operand:DI 1 "se_register_operand" "d,d")
+			  (const_int 0)])
+	 (match_operand:DF 2 "register_operand" "f,0")
+	 (match_operand:DF 3 "register_operand" "0,f")))]
+  "mips_isa >= 4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT"
+  "@
+    mov%B4.d\\t%0,%2,%1
+    mov%b4.d\\t%0,%3,%1"
+  [(set_attr "type" "move")
+   (set_attr "mode" "DF")])
+
 (define_insn ""
   [(set (match_operand:DF 0 "register_operand" "=f,f")
 	(if_then_else:DF
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index 23a9715..1238db2 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -3759,7 +3759,7 @@
     FAIL;
   switch (code)
     {
-    case GE: case EQ: case NE:
+    case GE: case EQ:
       op0 = rs6000_compare_op0;
       op1 = rs6000_compare_op1;
       break;
@@ -3790,11 +3790,6 @@
 	  emit_insn (gen_negdf2 (temp, temp));
 	  emit_insn (gen_fseldfsf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negdf2 (temp, temp));
-	  emit_insn (gen_fseldfsf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   else
     {
@@ -3806,11 +3801,6 @@
 	  emit_insn (gen_negsf2 (temp, temp));
 	  emit_insn (gen_fselsfsf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negsf2 (temp, temp));
-	  emit_insn (gen_fselsfsf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   DONE;
 }")
@@ -4006,7 +3996,7 @@
     FAIL;
   switch (code)
     {
-    case GE: case EQ: case NE:
+    case GE: case EQ:
       op0 = rs6000_compare_op0;
       op1 = rs6000_compare_op1;
       break;
@@ -4037,11 +4027,6 @@
 	  emit_insn (gen_negdf2 (temp, temp));
 	  emit_insn (gen_fseldfdf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negdf2 (temp, temp));
-	  emit_insn (gen_fseldfdf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   else
     {
@@ -4053,11 +4038,6 @@
 	  emit_insn (gen_negsf2 (temp, temp));
 	  emit_insn (gen_fselsfdf4 (operands[0], temp, operands[0], operands[3]));
 	}
-      else if (code == NE)
-	{
-	  emit_insn (gen_negsf2 (temp, temp));
-	  emit_insn (gen_fselsfdf4 (operands[0], temp, operands[3], operands[0]));
-	}
     }
   DONE;
 }")
@@ -6184,7 +6164,9 @@
      reg.  So expand it.  */
   if (GET_CODE (operands[0]) == SUBREG
       && GET_CODE (SUBREG_REG (operands[0])) == REG
-      && REGNO (SUBREG_REG (operands[0])) < FIRST_PSEUDO_REGISTER)
+      && REGNO (SUBREG_REG (operands[0])) < FIRST_PSEUDO_REGISTER
+      && (! REG_FUNCTION_VALUE_P (SUBREG_REG (operands[0]))
+	  || ! rtx_equal_function_value_matters))
     operands[0] = alter_subreg (operands[0]);
   if (GET_CODE (operands[1]) == SUBREG
       && GET_CODE (SUBREG_REG (operands[1])) == REG
diff --git a/gcc/config/rs6000/xm-darwin.h b/gcc/config/rs6000/xm-darwin.h
new file mode 100644
index 0000000..8d75cf0
--- /dev/null
+++ b/gcc/config/rs6000/xm-darwin.h
@@ -0,0 +1,9 @@
+/* Undo the USG definition in xm-rs6000.h, Darwin is a BSD flavor.  */
+
+#undef USG
+
+/* Override the usual setting, since Apple's GCC has lame bugs and
+   can't handle the initializers.  Someday the bugs will be fixed and
+   we can get rid of this silliness.  */
+
+#define HAVE_DESIGNATED_INITIALIZERS 0
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 58e882c..315a35a 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -2899,6 +2899,11 @@
          crashes in output_constant_pool.  */
       if (operands [1] == const0_rtx)
         operands[1] = CONST0_RTX (SFmode);
+      /* We are able to build any SF constant in integer registers
+	 with at most 2 instructions.  */
+      if (REGNO (operands[0]) < 32)
+	goto movsf_is_ok;
+
       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),
                                                    operands[1]));
     }
@@ -3093,6 +3098,9 @@
          crashes in output_constant_pool.  */
       if (operands [1] == const0_rtx)
         operands[1] = CONST0_RTX (DFmode);
+      if (REGNO (operands[0]) < 32)
+	goto movdf_is_ok;
+
       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),
                                                    operands[1]));
     }
@@ -3277,17 +3285,11 @@
 (define_split
   [(set (match_operand:DF 0 "register_operand" "")
 	(match_operand:DF 1 "memory_operand" ""))]
-  "((! TARGET_V9
-     || (! TARGET_ARCH64
-         && ((GET_CODE (operands[0]) == REG
-              && REGNO (operands[0]) < 32)
-             || (GET_CODE (operands[0]) == SUBREG
-                 && GET_CODE (SUBREG_REG (operands[0])) == REG
-                 && REGNO (SUBREG_REG (operands[0])) < 32))))
-    && (reload_completed
-        && (((REGNO (operands[0])) % 2) != 0
-             || ! mem_min_alignment (operands[1], 8))
-        && offsettable_memref_p (operands[1])))"
+  "reload_completed
+   && ! TARGET_ARCH64
+   && (((REGNO (operands[0]) % 2) != 0)
+       || ! mem_min_alignment (operands[1], 8))
+   && offsettable_memref_p (operands[1])"
   [(clobber (const_int 0))]
   "
 {
@@ -3318,17 +3320,11 @@
 (define_split
   [(set (match_operand:DF 0 "memory_operand" "")
 	(match_operand:DF 1 "register_operand" ""))]
-  "((! TARGET_V9
-     || (! TARGET_ARCH64
-         && ((GET_CODE (operands[1]) == REG
-              && REGNO (operands[1]) < 32)
-             || (GET_CODE (operands[1]) == SUBREG
-                 && GET_CODE (SUBREG_REG (operands[1])) == REG
-                 && REGNO (SUBREG_REG (operands[1])) < 32))))
-    && (reload_completed
-        && (((REGNO (operands[1])) % 2) != 0
-             || ! mem_min_alignment (operands[0], 8))
-        && offsettable_memref_p (operands[0])))"
+  "reload_completed
+   && ! TARGET_ARCH64
+   && (((REGNO (operands[1]) % 2) != 0)
+       || ! mem_min_alignment (operands[0], 8))
+   && offsettable_memref_p (operands[0])"
   [(clobber (const_int 0))]
   "
 {
@@ -5211,7 +5207,7 @@
 (define_insn "muldi3_v8plus"
   [(set (match_operand:DI 0 "register_operand" "=r,h")
 	(mult:DI (match_operand:DI 1 "arith_double_operand" "%r,0")
-		 (match_operand:DI 2 "arith_double_operand" "rHI,rHI")))
+		 (match_operand:DI 2 "arith_double_operand" "rI,rI")))
    (clobber (match_scratch:SI 3 "=&h,X"))
    (clobber (match_scratch:SI 4 "=&h,X"))]
   "TARGET_V8PLUS"
@@ -5221,6 +5217,13 @@
     output_asm_insn (\"srl\\t%L1, 0, %L1\", operands);
   if (which_alternative == 1)
     output_asm_insn (\"sllx\\t%H1, 32, %H1\", operands);
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      if (which_alternative == 1)
+	return \"or\\t%L1, %H1, %H1\\n\\tmulx\\t%H1, %2, %L0\;srlx\\t%L0, 32, %H0\";
+      else
+	return \"sllx\\t%H1, 32, %3\\n\\tor\\t%L1, %3, %3\\n\\tmulx\\t%3, %2, %3\\n\\tsrlx\\t%3, 32, %H0\\n\\tmov\\t%3, %L0\";
+    }
   if (sparc_check_64 (operands[2], insn) <= 0)
     output_asm_insn (\"srl\\t%L2, 0, %L2\", operands);
   if (which_alternative == 1)
diff --git a/gcc/configure b/gcc/configure
index 38d3db4..8ec7b17 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -853,9 +853,6 @@ fi
 # Check whether --enable-threads or --disable-threads was given.
 if test "${enable_threads+set}" = set; then
   enableval="$enable_threads"
-  if test x$enable_threads = xno; then
-	enable_threads=''
-fi
 else
   enable_threads=''
 fi
@@ -2929,6 +2926,9 @@ for machine in $build $host $target; do
 	i[34567]86-*-*)
 		cpu_type=i386
 		;;
+	x86_64-*-*)
+		cpu_type=i386
+		;;
 	hppa*-*-*)
 		cpu_type=pa
 		;;
@@ -3643,6 +3643,19 @@ for machine in $build $host $target; do
  			thread_file='posix'
  		fi
 		;;
+	x86_64-*-linux*)
+		xmake_file=x-linux
+		tm_file="i386/biarch64.h i386/i386.h i386/att.h linux.h i386/x86-64.h \
+			 i386/linux64.h"
+		tmake_file="t-slibgcc-elf-ver t-linux i386/t-crtstuff"
+		extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+		gnu_ld=yes
+		float_format=i386
+		if test x$enable_threads = xyes; then
+			thread_file='posix'
+		fi
+		;;
+
 	i[34567]86-*-gnu*)
 		float_format=i386
 		;;
@@ -4696,16 +4709,19 @@ for machine in $build $host $target; do
 		# On NetBSD, the headers are already okay, except for math.h.
 		tmake_file=t-netbsd
 		;;
-       mips*-*-linux*)                         # Linux MIPS, either endian.
+	mips*-*-linux*)				# Linux MIPS, either endian.
 		xmake_file=x-linux
-		xm_file="xm-siglist.h ${xm_file}"
-               case $machine in
-                       mipsel-*)  tm_file="mips/elfl.h mips/linux.h" ;;
-                       *)         tm_file="mips/elf.h mips/linux.h" ;;
-               esac
-		extra_parts="crtbegin.o crtend.o"
+		case $machine in
+			mips*el-*) tm_file="mips/elfl.h mips/linux.h" ;;
+			*)         tm_file="mips/elf.h mips/linux.h" ;;
+		esac
+		tmake_file=t-linux
+		extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
 		gnu_ld=yes
 		gas=yes
+		if test x$enable_threads = xyes; then
+			thread_file='posix'
+		fi
 		;;
 	mips*el-*-openbsd*)	# mips little endian
 		target_cpu_default="MASK_GAS|MASK_ABICALLS"
@@ -5079,6 +5095,10 @@ for machine in $build $host $target; do
 		tmake_file=rs6000/t-beos
 		xmake_file=rs6000/x-beos
 		;;
+	powerpc-*-darwin*)
+		xm_file="rs6000/xm-rs6000.h rs6000/xm-darwin.h"
+		xmake_file=rs6000/x-darwin
+		;;
 	powerpc-*-sysv* | powerpc-*-elf*)
 		tm_file=rs6000/sysv4.h
 		xm_file="xm-siglist.h rs6000/xm-sysv4.h"
diff --git a/gcc/configure.in b/gcc/configure.in
index 55dcec7..ec8f927 100644
--- a/gcc/configure.in
+++ b/gcc/configure.in
@@ -495,6 +495,9 @@ changequote(,)dnl
 changequote([,])dnl
 		cpu_type=i386
 		;;
+	x86_64-*-*)
+		cpu_type=i386
+		;;
 	hppa*-*-*)
 		cpu_type=pa
 		;;
@@ -1263,6 +1266,19 @@ changequote([,])dnl			# with ELF format using glibc 2
  			thread_file='posix'
  		fi
 		;;
+	x86_64-*-linux*)
+		xmake_file=x-linux
+		tm_file="i386/biarch64.h i386/i386.h i386/att.h linux.h i386/x86-64.h \
+			 i386/linux64.h"
+		tmake_file="t-slibgcc-elf-ver t-linux i386/t-crtstuff"
+		extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
+		gnu_ld=yes
+		float_format=i386
+		if test x$enable_threads = xyes; then
+			thread_file='posix'
+		fi
+		;;
+
 changequote(,)dnl
 	i[34567]86-*-gnu*)
 		float_format=i386
@@ -2368,16 +2384,19 @@ changequote([,])dnl
 		# On NetBSD, the headers are already okay, except for math.h.
 		tmake_file=t-netbsd
 		;;
-       mips*-*-linux*)                         # Linux MIPS, either endian.
+	mips*-*-linux*)				# Linux MIPS, either endian.
 		xmake_file=x-linux
-		xm_file="xm-siglist.h ${xm_file}"
-               case $machine in
-                       mipsel-*)  tm_file="mips/elfl.h mips/linux.h" ;;
-                       *)         tm_file="mips/elf.h mips/linux.h" ;;
-               esac
-		extra_parts="crtbegin.o crtend.o"
+		case $machine in
+			mips*el-*) tm_file="mips/elfl.h mips/linux.h" ;;
+			*)         tm_file="mips/elf.h mips/linux.h" ;;
+		esac
+		tmake_file=t-linux
+		extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
 		gnu_ld=yes
 		gas=yes
+		if test x$enable_threads = xyes; then
+			thread_file='posix'
+		fi
 		;;
 	mips*el-*-openbsd*)	# mips little endian
 		target_cpu_default="MASK_GAS|MASK_ABICALLS"
@@ -2763,6 +2782,10 @@ changequote([,])dnl
 		tmake_file=rs6000/t-beos
 		xmake_file=rs6000/x-beos
 		;;
+	powerpc-*-darwin*)
+		xm_file="rs6000/xm-rs6000.h rs6000/xm-darwin.h"
+		xmake_file=rs6000/x-darwin
+		;;
 	powerpc-*-sysv* | powerpc-*-elf*)
 		tm_file=rs6000/sysv4.h
 		xm_file="xm-siglist.h rs6000/xm-sysv4.h"
diff --git a/gcc/cp/Make-lang.in b/gcc/cp/Make-lang.in
index d5d4e4d..1d47ee3 100644
--- a/gcc/cp/Make-lang.in
+++ b/gcc/cp/Make-lang.in
@@ -214,27 +214,28 @@ c++.install-normal:
 c++.install-common:
 	-if [ -f cc1plus$(exeext) ] ; then \
 	  if [ -f g++-cross$(exeext) ] ; then \
-	    rm -f $(bindir)/$(GXX_CROSS_NAME)$(exeext); \
-	    $(INSTALL_PROGRAM) g++-cross$(exeext) $(bindir)/$(GXX_CROSS_NAME)$(exeext); \
-	    chmod a+x $(bindir)/$(GXX_CROSS_NAME)$(exeext); \
-	    rm -f $(bindir)/$(CXX_CROSS_NAME)$(exeext); \
-	    $(LN) $(bindir)/$(GXX_CROSS_NAME)$(exeext) $(bindir)/$(CXX_CROSS_NAME)$(exeext); \
+	    rm -f $(DESTDIR)$(bindir)/$(GXX_CROSS_NAME)$(exeext); \
+	    $(INSTALL_PROGRAM) g++-cross$(exeext) $(DESTDIR)$(bindir)/$(GXX_CROSS_NAME)$(exeext); \
+	    chmod a+x $(DESTDIR)$(bindir)/$(GXX_CROSS_NAME)$(exeext); \
+	    rm -f $(DESTDIR)$(bindir)/$(CXX_CROSS_NAME)$(exeext); \
+	    $(LN) $(DESTDIR)$(bindir)/$(GXX_CROSS_NAME)$(exeext) $(DESTDIR)$(bindir)/$(CXX_CROSS_NAME)$(exeext); \
 	  else \
-	    rm -f $(bindir)/$(GXX_INSTALL_NAME)$(exeext); \
-	    $(INSTALL_PROGRAM) g++$(exeext) $(bindir)/$(GXX_INSTALL_NAME)$(exeext); \
-	    chmod a+x $(bindir)/$(GXX_INSTALL_NAME)$(exeext); \
-	    rm -f $(bindir)/$(CXX_INSTALL_NAME)$(exeext); \
-	    $(LN) $(bindir)/$(GXX_INSTALL_NAME)$(exeext) $(bindir)/$(CXX_INSTALL_NAME)$(exeext); \
+	    rm -f $(DESTDIR)$(bindir)/$(GXX_INSTALL_NAME)$(exeext); \
+	    $(INSTALL_PROGRAM) g++$(exeext) $(DESTDIR)$(bindir)/$(GXX_INSTALL_NAME)$(exeext); \
+	    chmod a+x $(DESTDIR)$(bindir)/$(GXX_INSTALL_NAME)$(exeext); \
+	    rm -f $(DESTDIR)$(bindir)/$(CXX_INSTALL_NAME)$(exeext); \
+	    ( cd $(DESTDIR)$(bindir) && \
+	      $(LN) $(GXX_INSTALL_NAME)$(exeext) $(CXX_INSTALL_NAME)$(exeext) ); \
 	  fi ; \
 	  if [ x$(DEMANGLER_PROG) != x ] && [ -x "$(DEMANGLER_PROG)" ]; then \
 	    if [ -f g++-cross$(exeext) ] ; then \
-	      rm -f $(bindir)/$(DEMANGLER_CROSS_NAME)$(exeext); \
-	      $(INSTALL_PROGRAM) $(DEMANGLER_PROG) $(bindir)/$(DEMANGLER_CROSS_NAME)$(exeext); \
-	      chmod a+x $(bindir)/$(DEMANGLER_CROSS_NAME)$(exeext); \
+	      rm -f $(DESTDIR)$(bindir)/$(DEMANGLER_CROSS_NAME)$(exeext); \
+	      $(INSTALL_PROGRAM) $(DEMANGLER_PROG) $(DESTDIR)$(bindir)/$(DEMANGLER_CROSS_NAME)$(exeext); \
+	      chmod a+x $(DESTDIR)$(bindir)/$(DEMANGLER_CROSS_NAME)$(exeext); \
 	    else \
-	      rm -f $(bindir)/$(DEMANGLER_INSTALL_NAME)$(exeext); \
-	      $(INSTALL_PROGRAM) $(DEMANGLER_PROG) $(bindir)/$(DEMANGLER_INSTALL_NAME)$(exeext); \
-	      chmod a+x $(bindir)/$(DEMANGLER_INSTALL_NAME)$(exeext); \
+	      rm -f $(DESTDIR)$(bindir)/$(DEMANGLER_INSTALL_NAME)$(exeext); \
+	      $(INSTALL_PROGRAM) $(DEMANGLER_PROG) $(DESTDIR)$(bindir)/$(DEMANGLER_INSTALL_NAME)$(exeext); \
+	      chmod a+x $(DESTDIR)$(bindir)/$(DEMANGLER_INSTALL_NAME)$(exeext); \
 	    fi ; \
 	  fi ; \
 	fi
@@ -244,25 +245,25 @@ c++.install-info:
 c++.install-man: $(srcdir)/cp/g++.1
 	-if [ -f cc1plus$(exeext) ] ; then \
 	  if [ -f g++-cross$(exeext) ] ; then \
-	    rm -f $(man1dir)/$(GXX_CROSS_NAME)$(manext); \
-	    $(INSTALL_DATA) $(srcdir)/cp/g++.1 $(man1dir)/$(GXX_CROSS_NAME)$(manext); \
-	    chmod a-x $(man1dir)/$(GXX_CROSS_NAME)$(manext); \
+	    rm -f $(DESTDIR)$(man1dir)/$(GXX_CROSS_NAME)$(manext); \
+	    $(INSTALL_DATA) $(srcdir)/cp/g++.1 $(DESTDIR)$(man1dir)/$(GXX_CROSS_NAME)$(manext); \
+	    chmod a-x $(DESTDIR)$(man1dir)/$(GXX_CROSS_NAME)$(manext); \
 	  else \
-	    rm -f $(man1dir)/$(GXX_INSTALL_NAME)$(manext); \
-	    $(INSTALL_DATA) $(srcdir)/cp/g++.1 $(man1dir)/$(GXX_INSTALL_NAME)$(manext); \
-	    chmod a-x $(man1dir)/$(GXX_INSTALL_NAME)$(manext); \
+	    rm -f $(DESTDIR)$(man1dir)/$(GXX_INSTALL_NAME)$(manext); \
+	    $(INSTALL_DATA) $(srcdir)/cp/g++.1 $(DESTDIR)$(man1dir)/$(GXX_INSTALL_NAME)$(manext); \
+	    chmod a-x $(DESTDIR)$(man1dir)/$(GXX_INSTALL_NAME)$(manext); \
 	  fi; \
 	else true; fi
 
 c++.uninstall:
-	-rm -rf $(bindir)/$(CXX_INSTALL_NAME)$(exeext)
-	-rm -rf $(bindir)/$(CXX_CROSS_NAME)$(exeext)
-	-rm -rf $(bindir)/$(GXX_INSTALL_NAME)$(exeext)
-	-rm -rf $(bindir)/$(GXX_CROSS_NAME)$(exeext)
-	-rm -rf $(bindir)/$(DEMANGLER_INSTALL_NAME)$(exeext)
-	-rm -rf $(bindir)/$(DEMANGLER_CROSS_NAME)$(exeext)
-	-rm -rf $(man1dir)/$(GXX_INSTALL_NAME)$(manext)
-	-rm -rf $(man1dir)/$(GXX_CROSS_NAME)$(manext)
+	-rm -rf $(DESTDIR)$(bindir)/$(CXX_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(CXX_CROSS_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(GXX_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(GXX_CROSS_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(DEMANGLER_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(DEMANGLER_CROSS_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(man1dir)/$(GXX_INSTALL_NAME)$(manext)
+	-rm -rf $(DESTDIR)$(man1dir)/$(GXX_CROSS_NAME)$(manext)
 #
 # Clean hooks:
 # A lot of the ancillary files are deleted by the main makefile.
diff --git a/gcc/crtstuff.c b/gcc/crtstuff.c
index ccebde1..fedade6 100644
--- a/gcc/crtstuff.c
+++ b/gcc/crtstuff.c
@@ -55,6 +55,7 @@ Boston, MA 02111-1307, USA.  */
 #include "defaults.h"
 #include <stddef.h>
 #include "frame.h"
+#include "auto-host.h"
 
 /* We do not want to add the weak attribute to the declarations of these
    routines in frame.h because that will cause the definition of these
@@ -134,6 +135,29 @@ typedef void (*func_ptr) (void);
 #ifdef INIT_SECTION_ASM_OP
 
 #ifdef OBJECT_FORMAT_ELF
+/* Declare the __dso_handle variable.  It should have a unique value
+   in every shared-object; in a main program its value is zero.  The
+   object should in any case be protected.  This means the instance
+   in one DSO or the main program is not used in another object.  The
+   dynamic linker takes care of this.  */
+
+/* XXX Ideally the following should be implemented using
+   __attribute__ ((__visibility__ ("hidden")))
+   but the __attribute__ support is not yet there.  */
+#define HAVE_GAS_HIDDEN 1
+#ifdef HAVE_GAS_HIDDEN
+asm (".hidden\t__dso_handle");
+#endif
+
+#ifdef CRTSTUFFS_O
+void *__dso_handle = &__dso_handle;
+#else
+void *__dso_handle = 0;
+#endif
+
+/* The __cxa_finalize function may not be available so we use only a
+   weak declaration.  */
+extern void __cxa_finalize (void *) TARGET_ATTRIBUTE_WEAK;
 
 /* Run all the global destructors on exit from the program.  */
  
@@ -165,6 +189,11 @@ __do_global_dtors_aux (void)
   if (completed)
     return;
 
+#ifdef CRTSTUFFS_O
+  if (__cxa_finalize)
+    __cxa_finalize (__dso_handle);
+#endif
+
   while (*p)
     {
       p++;
@@ -379,20 +408,8 @@ init_dummy (void)
   FORCE_INIT_SECTION_ALIGN;
 #endif
   asm (TEXT_SECTION_ASM_OP);
-
-/* This is a kludge. The i386 GNU/Linux dynamic linker needs ___brk_addr,
-   __environ and atexit (). We have to make sure they are in the .dynsym
-   section. We accomplish it by making a dummy call here. This
-   code is never reached.  */
- 
-#if defined(__linux__) && defined(__PIC__) && defined(__i386__)
-  {
-    extern void *___brk_addr;
-    extern char **__environ;
-
-    ___brk_addr = __environ;
-    atexit ();
-  }
+#ifdef CRT_END_INIT_DUMMY
+  CRT_END_INIT_DUMMY;
 #endif
 }
 
diff --git a/gcc/cse.c b/gcc/cse.c
index ca40ab3..ff4d00f 100644
--- a/gcc/cse.c
+++ b/gcc/cse.c
@@ -695,8 +695,6 @@ static void check_fold_consts	PROTO((PTR));
 static struct cse_reg_info* get_cse_reg_info PROTO((int));
 static void free_cse_reg_info   PROTO((splay_tree_value));
 static void flush_hash_table	PROTO((void));
-
-extern int rtx_equal_function_value_matters;
 
 /* Dump the expressions in the equivalence class indicated by CLASSP.
    This function is used only for debugging.  */
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
index 7910472..88b6937 100644
--- a/gcc/emit-rtl.c
+++ b/gcc/emit-rtl.c
@@ -753,6 +753,15 @@ gen_lowpart_common (mode, x)
 	  && ! HARD_REGNO_MODE_OK (REGNO (x) + word, mode)
 	  && HARD_REGNO_MODE_OK (REGNO (x), GET_MODE (x)))
 	return 0;
+      else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_COMPLEX_FLOAT
+	       && GET_MODE_SIZE (GET_MODE (x)) <= UNITS_PER_WORD
+	       && REGNO (x) < FIRST_PSEUDO_REGISTER)
+	{
+	  if (REG_FUNCTION_VALUE_P (x))
+	    return gen_rtx (SUBREG, mode, x, 0);
+	  else
+	    return gen_rtx (REG, mode, REGNO (x));
+	}
       else if (REGNO (x) < FIRST_PSEUDO_REGISTER
 	       /* integrate.c can't handle parts of a return value register. */
 	       && (! REG_FUNCTION_VALUE_P (x)
@@ -976,11 +985,6 @@ gen_realpart (mode, x)
 {
   if (GET_CODE (x) == CONCAT && GET_MODE (XEXP (x, 0)) == mode)
     return XEXP (x, 0);
-  else if (WORDS_BIG_ENDIAN
-	   && GET_MODE_BITSIZE (mode) < BITS_PER_WORD
-	   && REG_P (x)
-	   && REGNO (x) < FIRST_PSEUDO_REGISTER)
-    fatal ("Unable to access real part of complex value in a hard register on this target");
   else if (WORDS_BIG_ENDIAN)
     return gen_highpart (mode, x);
   else
@@ -999,11 +1003,6 @@ gen_imagpart (mode, x)
     return XEXP (x, 1);
   else if (WORDS_BIG_ENDIAN)
     return gen_lowpart (mode, x);
-  else if (!WORDS_BIG_ENDIAN
-	   && GET_MODE_BITSIZE (mode) < BITS_PER_WORD
-	   && REG_P (x)
-	   && REGNO (x) < FIRST_PSEUDO_REGISTER)
-    fatal ("Unable to access imaginary part of complex value in a hard register on this target");
   else
     return gen_highpart (mode, x);
 }
@@ -1139,6 +1138,16 @@ gen_highpart (mode, x)
 		 - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD))
 		/ UNITS_PER_WORD);
 
+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_COMPLEX_FLOAT
+	  && GET_MODE_SIZE (GET_MODE (x)) <= UNITS_PER_WORD
+	  && REGNO (x) < FIRST_PSEUDO_REGISTER)
+	{
+	  if (REG_FUNCTION_VALUE_P (x))
+	    return gen_rtx (SUBREG, mode, x, 1);
+	  else
+	    return gen_rtx (REG, mode, REGNO (x) + 1);
+	}
+
       if (REGNO (x) < FIRST_PSEUDO_REGISTER
 	  /* integrate.c can't handle parts of a return value register.  */
 	  && (! REG_FUNCTION_VALUE_P (x)
diff --git a/gcc/except.c b/gcc/except.c
index f7d78d6..9075226 100644
--- a/gcc/except.c
+++ b/gcc/except.c
@@ -723,21 +723,41 @@ static void
 receive_exception_label (handler_label)
      rtx handler_label;
 {
+  rtx around_label = NULL_RTX;
+
+  if (! flag_new_exceptions || exceptions_via_longjmp)
+    {
+      around_label = gen_label_rtx ();
+      emit_jump (around_label);
+      emit_barrier ();
+    }
+
   emit_label (handler_label);
-  
-#ifdef HAVE_exception_receiver
+
   if (! exceptions_via_longjmp)
-    if (HAVE_exception_receiver)
-      emit_insn (gen_exception_receiver ());
+    {
+#ifdef HAVE_exception_receiver
+      if (HAVE_exception_receiver)
+	emit_insn (gen_exception_receiver ());
+      else
 #endif
-
 #ifdef HAVE_nonlocal_goto_receiver
-  if (! exceptions_via_longjmp)
-    if (HAVE_nonlocal_goto_receiver)
-      emit_insn (gen_nonlocal_goto_receiver ());
+      if (HAVE_nonlocal_goto_receiver)
+	emit_insn (gen_nonlocal_goto_receiver ());
+      else
 #endif
-}
+	{ /* Nothing */ }
+    }
+  else
+    {
+#ifndef DONT_USE_BUILTIN_SETJMP
+      expand_builtin_setjmp_receiver (handler_label);
+#endif
+    }
 
+  if (around_label)
+    emit_label (around_label);
+}
 
 struct func_eh_entry 
 {
@@ -1320,7 +1340,7 @@ static void
 start_dynamic_handler ()
 {
   rtx dhc, dcc;
-  rtx x, arg, buf;
+  rtx arg, buf;
   int size;
 
 #ifndef DONT_USE_BUILTIN_SETJMP
@@ -1362,18 +1382,17 @@ start_dynamic_handler ()
   buf = plus_constant (XEXP (arg, 0), GET_MODE_SIZE (Pmode)*2);
 
 #ifdef DONT_USE_BUILTIN_SETJMP
-  x = emit_library_call_value (setjmp_libfunc, NULL_RTX, 1, SImode, 1,
-			       buf, Pmode);
-  /* If we come back here for a catch, transfer control to the handler.  */
-  jumpif_rtx (x, ehstack.top->entry->exception_handler_label);
-#else
   {
-    /* A label to continue execution for the no exception case.  */
-    rtx noex = gen_label_rtx();
-    x = expand_builtin_setjmp (buf, NULL_RTX, noex,
-			       ehstack.top->entry->exception_handler_label);
-    emit_label (noex);
+    rtx x;
+    x = emit_library_call_value (setjmp_libfunc, NULL_RTX, LCT_CONST,
+                                TYPE_MODE (integer_type_node), 1,
+                                buf, Pmode);
+    /* If we come back here for a catch, transfer control to the handler.  */
+    jumpif_rtx (x, ehstack.top->entry->exception_handler_label);
   }
+#else
+  expand_builtin_setjmp_setup (buf,
+                              ehstack.top->entry->exception_handler_label);
 #endif
 
   /* We are committed to this, so update the handler chain.  */
diff --git a/gcc/expr.c b/gcc/expr.c
index e3fe1f8..ef16c76 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -192,6 +192,7 @@ static rtx expand_builtin	PROTO((tree, rtx, rtx,
 static int apply_args_size	PROTO((void));
 static int apply_result_size	PROTO((void));
 static rtx result_vector	PROTO((int, rtx));
+static rtx expand_builtin_setjmp PROTO((tree, rtx));
 static rtx expand_builtin_apply_args PROTO((void));
 static rtx expand_builtin_apply	PROTO((rtx, rtx, rtx));
 static void expand_builtin_return PROTO((rtx));
@@ -449,6 +450,9 @@ protect_from_queue (x, modify)
 				QUEUED_INSN (y));
 	      return temp;
 	    }
+	  /* Copy the address into a pseudo, so that the returned value
+	     remains correct across calls to emit_queue.  */
+	  XEXP (new, 0) = copy_to_reg (XEXP (new, 0));
 	  return new;
 	}
       /* Otherwise, recursively protect the subexpressions of all
@@ -475,9 +479,11 @@ protect_from_queue (x, modify)
 	}
       return x;
     }
-  /* If the increment has not happened, use the variable itself.  */
+  /* If the increment has not happened, use the variable itself.  Copy it
+     into a new pseudo so that the value remains correct across calls to
+     emit_queue.  */
   if (QUEUED_INSN (x) == 0)
-    return QUEUED_VAR (x);
+    return copy_to_reg (QUEUED_VAR (x));
   /* If the increment has happened and a pre-increment copy exists,
      use that copy.  */
   if (QUEUED_COPY (x) != 0)
@@ -8076,7 +8082,9 @@ expand_expr (exp, target, tmode, modifier)
 	  if (ignore)
 	    return op0;
 
-	  op0 = protect_from_queue (op0, 0);
+	  /* Pass 1 for MODIFY, so that protect_from_queue doesn't get
+	     clever and returns a REG when given a MEM.  */
+	  op0 = protect_from_queue (op0, 1);
 
 	  /* We would like the object in memory.  If it is a constant,
 	     we can have it be statically allocated into memory.  For
@@ -8544,44 +8552,29 @@ expand_builtin_return_addr (fndecl_code, count, tem)
   return tem;
 }
 
-/* __builtin_setjmp is passed a pointer to an array of five words (not
-   all will be used on all machines).  It operates similarly to the C
-   library function of the same name, but is more efficient.  Much of
-   the code below (and for longjmp) is copied from the handling of
-   non-local gotos.
-
-   NOTE: This is intended for use by GNAT and the exception handling
-   scheme in the compiler and will only work in the method used by
-   them.  */
+/* Construct the leading half of a __builtin_setjmp call.  Control will
+   return to RECEIVER_LABEL.  This is used directly by sjlj exception
+   handling code.  */
 
-rtx
-expand_builtin_setjmp (buf_addr, target, first_label, next_label)
+void
+expand_builtin_setjmp_setup (buf_addr, receiver_label)
      rtx buf_addr;
-     rtx target;
-     rtx first_label, next_label;
+     rtx receiver_label;
 {
-  rtx lab1 = gen_label_rtx ();
   enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);
-  enum machine_mode value_mode;
   rtx stack_save;
 
-  value_mode = TYPE_MODE (integer_type_node);
-
 #ifdef POINTERS_EXTEND_UNSIGNED
   buf_addr = convert_memory_address (Pmode, buf_addr);
 #endif
 
   buf_addr = force_reg (Pmode, buf_addr);
 
-  if (target == 0 || GET_CODE (target) != REG
-      || REGNO (target) < FIRST_PSEUDO_REGISTER)
-    target = gen_reg_rtx (value_mode);
-
   emit_queue ();
 
-  /* We store the frame pointer and the address of lab1 in the buffer
-     and use the rest of it for the stack save area, which is
-     machine-dependent.  */
+  /* We store the frame pointer and the address of receiver_label in
+     the buffer and use the rest of it for the stack save area, which
+     is machine-dependent.  */
 
 #ifndef BUILTIN_SETJMP_FRAME_VALUE
 #define BUILTIN_SETJMP_FRAME_VALUE virtual_stack_vars_rtx
@@ -8593,7 +8586,7 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
 		  (gen_rtx_MEM (Pmode,
 				plus_constant (buf_addr,
 					       GET_MODE_SIZE (Pmode)))),
-		  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, lab1)));
+		  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, receiver_label)));
 
   stack_save = gen_rtx_MEM (sa_mode,
 			    plus_constant (buf_addr,
@@ -8606,20 +8599,22 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
     emit_insn (gen_builtin_setjmp_setup (buf_addr));
 #endif
 
-  /* Set TARGET to zero and branch to the first-time-through label.  */
-  emit_move_insn (target, const0_rtx);
-  emit_jump_insn (gen_jump (first_label));
-  emit_barrier ();
-  emit_label (lab1);
-
-  /* Tell flow about the strange goings on.  Putting `lab1' on
-     `nonlocal_goto_handler_labels' to indicates that function
-     calls may traverse the arc back to this label.  */
+  /* Tell optimize_save_area_alloca that extra work is going to
+     need to go on during alloca.  */
+  current_function_calls_setjmp = 1;
 
+  /* Set this so all the registers get saved in our frame; we need to be
+     able to copy the saved values for any registers from frames we unwind. */
   current_function_has_nonlocal_label = 1;
-  nonlocal_goto_handler_labels =
-    gen_rtx_EXPR_LIST (VOIDmode, lab1, nonlocal_goto_handler_labels);
+}
+
+/* Construct the trailing part of a __builtin_setjmp call.
+   This is used directly by sjlj exception handling code.  */
 
+void
+expand_builtin_setjmp_receiver (receiver_label)
+      rtx receiver_label ATTRIBUTE_UNUSED;
+{
   /* Clobber the FP when we get here, so we have to make sure it's
      marked as used by this function.  */
   emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));
@@ -8666,7 +8661,7 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
 
 #ifdef HAVE_builtin_setjmp_receiver
   if (HAVE_builtin_setjmp_receiver)
-    emit_insn (gen_builtin_setjmp_receiver (lab1));
+    emit_insn (gen_builtin_setjmp_receiver (receiver_label));
   else
 #endif
 #ifdef HAVE_nonlocal_goto_receiver
@@ -8678,10 +8673,66 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)
 	; /* Nothing */
       }
 
-  /* Set TARGET, and branch to the next-time-through label.  */
-  emit_move_insn (target, const1_rtx);
-  emit_jump_insn (gen_jump (next_label));
+  /* @@@ This is a kludge.  Not all machine descriptions define a blockage
+     insn, but we must not allow the code we just generated to be reordered
+     by scheduling.  Specifically, the update of the frame pointer must
+     happen immediately, not later.  So emit an ASM_INPUT to act as blockage
+     insn.  */
+  emit_insn (gen_rtx_ASM_INPUT (VOIDmode, ""));
+}
+
+
+/* __builtin_setjmp is passed a pointer to an array of five words (not
+   all will be used on all machines).  It operates similarly to the C
+   library function of the same name, but is more efficient.  Much of
+   the code below (and for longjmp) is copied from the handling of
+   non-local gotos.
+
+   NOTE: This is intended for use by GNAT and the exception handling
+   scheme in the compiler and will only work in the method used by
+   them.  */
+
+static rtx
+expand_builtin_setjmp (arglist, target)
+     tree arglist;
+     rtx target;
+{
+  rtx buf_addr, next_lab, cont_lab;
+
+  if (arglist == 0
+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)
+    return NULL_RTX;
+
+  if (target == 0 || GET_CODE (target) != REG
+      || REGNO (target) < FIRST_PSEUDO_REGISTER)
+    target = gen_reg_rtx (TYPE_MODE (integer_type_node));
+
+  buf_addr = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);
+
+  next_lab = gen_label_rtx ();
+  cont_lab = gen_label_rtx ();
+
+  expand_builtin_setjmp_setup (buf_addr, next_lab);
+
+  /* Set TARGET to zero and branch to the continue label.  */
+  emit_move_insn (target, const0_rtx);
+  emit_jump_insn (gen_jump (cont_lab));
   emit_barrier ();
+  emit_label (next_lab);
+
+  expand_builtin_setjmp_receiver (next_lab);
+
+  /* Set TARGET to one.  */
+  emit_move_insn (target, const1_rtx);
+  emit_label (cont_lab);
+
+  /* Tell flow about the strange goings on.  Putting `next_lab' on
+     `nonlocal_goto_handler_labels' to indicates that function
+     calls may traverse the arc back to this label.  */
+
+  current_function_has_nonlocal_label = 1;
+  nonlocal_goto_handler_labels
+    = gen_rtx_EXPR_LIST (VOIDmode, next_lab, nonlocal_goto_handler_labels);
 
   return target;
 }
@@ -9703,18 +9754,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)
 #endif
 
     case BUILT_IN_SETJMP:
-      if (arglist == 0
-	  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)
-	break;
-      else
-	{
-	  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,
-				      VOIDmode, 0);
-	  rtx lab = gen_label_rtx ();
-	  rtx ret = expand_builtin_setjmp (buf_addr, target, lab, lab);
-	  emit_label (lab);
-	  return ret;
-	}
+      target = expand_builtin_setjmp (arglist, target);
+      if (target)
+	return target;
+      break;
 
       /* __builtin_longjmp is passed a pointer to an array of five words.
 	 It's similar to the C library longjmp function but works with
diff --git a/gcc/expr.h b/gcc/expr.h
index 55e82e6..c279774 100644
--- a/gcc/expr.h
+++ b/gcc/expr.h
@@ -831,7 +831,8 @@ extern rtx store_expr PROTO((tree, rtx, int));
    Useful after calling expand_expr with 1 as sum_ok.  */
 extern rtx force_operand PROTO((rtx, rtx));
 
-extern rtx expand_builtin_setjmp PROTO((rtx, rtx, rtx, rtx));
+extern void expand_builtin_setjmp_setup PARAMS ((rtx, rtx));
+extern void expand_builtin_setjmp_receiver PARAMS ((rtx));
 
 #ifdef TREE_CODE
 /* Generate code for computing expression EXP.
diff --git a/gcc/f/Make-lang.in b/gcc/f/Make-lang.in
index a531abb..ba47c07 100644
--- a/gcc/f/Make-lang.in
+++ b/gcc/f/Make-lang.in
@@ -312,18 +312,18 @@ f77.install-normal:
 # run, since we use libsubdir to store our `flag' file, lang-f77.
 f77.install-common: installdirs
 	case "$(LANGUAGES)" in \
-	  *[fF]77*) touch $(libsubdir)/lang-f77;; \
-	  *) rm -f $(libsubdir)/lang-f77;; \
+	  *[fF]77*) touch $(DESTDIR)$(libsubdir)/lang-f77;; \
+	  *) rm -f $(DESTDIR)$(libsubdir)/lang-f77;; \
 	esac
-	-if [ -f $(libsubdir)/lang-f77 -a -f f771$(exeext) ] ; then \
+	-if [ -f $(DESTDIR)$(libsubdir)/lang-f77 -a -f f771$(exeext) ] ; then \
 	  if [ -f g77-cross$(exeext) ] ; then \
-	    rm -f $(bindir)/$(G77_CROSS_NAME)$(exeext); \
-	    $(INSTALL_PROGRAM) g77-cross$(exeext) $(bindir)/$(G77_CROSS_NAME)$(exeext); \
-	    chmod a+x $(bindir)/$(G77_CROSS_NAME)$(exeext); \
+	    rm -f $(DESTDIR)$(bindir)/$(G77_CROSS_NAME)$(exeext); \
+	    $(INSTALL_PROGRAM) g77-cross$(exeext) $(DESTDIR)$(bindir)/$(G77_CROSS_NAME)$(exeext); \
+	    chmod a+x $(DESTDIR)$(bindir)/$(G77_CROSS_NAME)$(exeext); \
 	  else \
-	    rm -f $(bindir)/$(G77_INSTALL_NAME)$(exeext); \
-	    $(INSTALL_PROGRAM) g77$(exeext) $(bindir)/$(G77_INSTALL_NAME)$(exeext); \
-	    chmod a+x $(bindir)/$(G77_INSTALL_NAME)$(exeext); \
+	    rm -f $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \
+	    $(INSTALL_PROGRAM) g77$(exeext) $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \
+	    chmod a+x $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \
 	  fi ; \
 	else true; fi
 	@if [ -f f77-install-ok -o -f $(srcdir)/f77-install-ok ]; then \
@@ -335,7 +335,7 @@ f77.install-common: installdirs
 	  echo '         f77-install-ok in the source or build directory.)'; \
 	  echo ''; \
 	else true; fi
-	rm -f $(libsubdir)/lang-f77
+	rm -f $(DESTDIR)$(libsubdir)/lang-f77
 
 # $(INSTALL_DATA) might be a relative pathname, so we can't cd into srcdir
 # to do the install.  The sed rule was copied from stmp-int-hdrs.
@@ -343,66 +343,66 @@ f77.install-common: installdirs
 # run, since we use libsubdir to store our `flag' file, lang-f77.
 f77.install-info: f77.info installdirs
 	case "$(LANGUAGES)" in \
-	  *[fF]77*) touch $(libsubdir)/lang-f77;; \
-	  *) rm -f $(libsubdir)/lang-f77;; \
+	  *[fF]77*) touch $(DESTDIR)$(libsubdir)/lang-f77;; \
+	  *) rm -f $(DESTDIR)$(libsubdir)/lang-f77;; \
 	esac
-	if [ -f $(libsubdir)/lang-f77 -a -f f/g77.info ] ; then \
-	  rm -f $(infodir)/g77.info*; \
+	if [ -f $(DESTDIR)$(libsubdir)/lang-f77 -a -f f/g77.info ] ; then \
+	  rm -f $(DESTDIR)$(infodir)/g77.info*; \
 	  for f in f/g77.info*; do \
 	      realfile=`echo $$f | sed -e 's|.*/\([^/]*\)$$|\1|'`; \
-	      $(INSTALL_DATA) $$f $(infodir)/$$realfile; \
+	      $(INSTALL_DATA) $$f $(DESTDIR)$(infodir)/$$realfile; \
 	  done; \
-	  chmod a-x $(infodir)/g77.info*; \
+	  chmod a-x $(DESTDIR)$(infodir)/g77.info*; \
 	else true; fi
-	@if [ -f $(libsubdir)/lang-f77 -a -f $(srcdir)/f/g77.info ] ; then \
+	@if [ -f $(DESTDIR)$(libsubdir)/lang-f77 -a -f $(srcdir)/f/g77.info ] ; then \
 	  if $(SHELL) -c 'install-info --version | sed 1q | fgrep -s -v -i debian' >/dev/null 2>&1; then \
 	    echo " install-info --info-dir=$(infodir) $(infodir)/g77.info"; \
-	    install-info --info-dir=$(infodir) $(infodir)/g77.info || : ; \
+	    install-info --info-dir=$(DESTDIR)$(infodir) $(DESTDIR)$(infodir)/g77.info || : ; \
 	  else : ; fi; \
 	else : ; fi
-	rm -f $(libsubdir)/lang-f77
+	rm -f $(DESTDIR)$(libsubdir)/lang-f77
 
 # Make sure `installdirs' target (from gcc Makefile) has been
 # run, since we use libsubdir to store our `flag' file, lang-f77.
 f77.install-man: $(srcdir)/f/g77.1 installdirs
 	case "$(LANGUAGES)" in \
-	  *[fF]77*) touch $(libsubdir)/lang-f77;; \
-	  *) rm -f $(libsubdir)/lang-f77;; \
+	  *[fF]77*) touch $(DESTDIR)$(libsubdir)/lang-f77;; \
+	  *) rm -f $(DESTDIR)$(libsubdir)/lang-f77;; \
 	esac
-	-if [ -f $(libsubdir)/lang-f77 -a -f f771$(exeext) ] ; then \
+	-if [ -f $(DESTDIR)$(libsubdir)/lang-f77 -a -f f771$(exeext) ] ; then \
 	  if [ -f g77-cross$(exeext) ] ; then \
-	    rm -f $(man1dir)/$(G77_CROSS_NAME)$(manext); \
-	    $(INSTALL_DATA) $(srcdir)/f/g77.1 $(man1dir)/$(G77_CROSS_NAME)$(manext); \
-	    chmod a-x $(man1dir)/$(G77_CROSS_NAME)$(manext); \
+	    rm -f $(DESTDIR)$(man1dir)/$(G77_CROSS_NAME)$(manext); \
+	    $(INSTALL_DATA) $(srcdir)/f/g77.1 $(DESTDIR)$(man1dir)/$(G77_CROSS_NAME)$(manext); \
+	    chmod a-x $(DESTDIR)$(man1dir)/$(G77_CROSS_NAME)$(manext); \
 	  else \
-	    rm -f $(man1dir)/$(G77_INSTALL_NAME)$(manext); \
-	    $(INSTALL_DATA) $(srcdir)/f/g77.1 $(man1dir)/$(G77_INSTALL_NAME)$(manext); \
-	    chmod a-x $(man1dir)/$(G77_INSTALL_NAME)$(manext); \
+	    rm -f $(DESTDIR)$(man1dir)/$(G77_INSTALL_NAME)$(manext); \
+	    $(INSTALL_DATA) $(srcdir)/f/g77.1 $(DESTDIR)$(man1dir)/$(G77_INSTALL_NAME)$(manext); \
+	    chmod a-x $(DESTDIR)$(man1dir)/$(G77_INSTALL_NAME)$(manext); \
 	  fi; \
 	else true; fi
-	rm -f $(libsubdir)/lang-f77
+	rm -f $(DESTDIR)$(libsubdir)/lang-f77
 
 # Make sure `installdirs' target (from gcc Makefile) has been
 # run, since we use libsubdir to store our `flag' file, lang-f77.
 f77.uninstall: installdirs
 	case "$(LANGUAGES)" in \
-	  *[fF]77*) touch $(libsubdir)/lang-f77;; \
-	  *) rm -f $(libsubdir)/lang-f77;; \
+	  *[fF]77*) touch $(DESTDIR)$(libsubdir)/lang-f77;; \
+	  *) rm -f $(DESTDIR)$(libsubdir)/lang-f77;; \
 	esac
-	@if [ -f $(libsubdir)/lang-f77 ] ; then \
+	@if [ -f $(DESTDIR)$(libsubdir)/lang-f77 ] ; then \
 	  if $(SHELL) -c 'install-info --version | sed 1q | fgrep -s -v -i debian' >/dev/null 2>&1; then \
-	    echo " install-info --delete --info-dir=$(infodir) $(infodir)/g77.info"; \
-	    install-info --delete --info-dir=$(infodir) $(infodir)/g77.info || : ; \
+	    echo " install-info --delete --info-dir=$(DESTDIR)$(infodir) $(DESTDIR)$(infodir)/g77.info"; \
+	    install-info --delete --info-dir=$(DESTDIR)$(infodir) $(DESTDIR)$(infodir)/g77.info || : ; \
 	  else : ; fi; \
 	else : ; fi
-	-if [ -f $(libsubdir)/lang-f77 ]; then \
-	  rm -rf $(bindir)/$(G77_INSTALL_NAME)$(exeext); \
-	  rm -rf $(bindir)/$(G77_CROSS_NAME)$(exeext); \
-	  rm -rf $(man1dir)/$(G77_INSTALL_NAME)$(manext); \
-	  rm -rf $(man1dir)/$(G77_CROSS_NAME)$(manext); \
-	  rm -rf $(infodir)/g77.info*; \
+	-if [ -f $(DESTDIR)$(libsubdir)/lang-f77 ]; then \
+	  rm -rf $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \
+	  rm -rf $(DESTDIR)$(bindir)/$(G77_CROSS_NAME)$(exeext); \
+	  rm -rf $(DESTDIR)$(man1dir)/$(G77_INSTALL_NAME)$(manext); \
+	  rm -rf $(DESTDIR)$(man1dir)/$(G77_CROSS_NAME)$(manext); \
+	  rm -rf $(DESTDIR)$(infodir)/g77.info*; \
 	fi
-	rm -f $(libsubdir)/lang-f77
+	rm -f $(DESTDIR)$(libsubdir)/lang-f77
 #
 # Clean hooks:
 # A lot of the ancillary files are deleted by the main makefile.
diff --git a/gcc/f/com.h b/gcc/f/com.h
index baa2953..c2e8c3e 100644
--- a/gcc/f/com.h
+++ b/gcc/f/com.h
@@ -310,7 +310,7 @@ void ffecom_finish_decl (tree decl, tree init, bool is_top_level);
 void ffecom_finish_progunit (void);
 tree ffecom_get_invented_identifier (const char *pattern, const char *text,
 				     int number);
-ffeinfoKindtype ffecom_gfrt_basictype (ffecomGfrt ix);
+ffeinfoBasictype ffecom_gfrt_basictype (ffecomGfrt ix);
 ffeinfoKindtype ffecom_gfrt_kindtype (ffecomGfrt ix);
 void ffecom_init_0 (void);
 void ffecom_init_2 (void);
diff --git a/gcc/final.c b/gcc/final.c
index 11cfebf..c5b496f 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -1701,7 +1701,9 @@ static void
 profile_function (file)
      FILE *file;
 {
+#ifndef NO_PROFILE_COUNTERS
   int align = MIN (BIGGEST_ALIGNMENT, LONG_TYPE_SIZE);
+#endif
 #if defined(ASM_OUTPUT_REG_PUSH)
 #if defined(STRUCT_VALUE_INCOMING_REGNUM) || defined(STRUCT_VALUE_REGNUM)
   int sval = current_function_returns_struct;
@@ -1711,10 +1713,12 @@ profile_function (file)
 #endif
 #endif /* ASM_OUTPUT_REG_PUSH */
 
+#ifndef NO_PROFILE_COUNTERS
   data_section ();
   ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));
   ASM_OUTPUT_INTERNAL_LABEL (file, "LP", profile_label_no);
   assemble_integer (const0_rtx, LONG_TYPE_SIZE / BITS_PER_UNIT, 1);
+#endif
 
   function_section (current_function_decl);
 
@@ -3043,7 +3047,8 @@ cleanup_subreg_operands (insn)
       if (GET_CODE (recog_operand[i]) == SUBREG)
         recog_operand[i] = alter_subreg (recog_operand[i]);
       else if (GET_CODE (recog_operand[i]) == PLUS
-               || GET_CODE (recog_operand[i]) == MULT)
+               || GET_CODE (recog_operand[i]) == MULT
+	       || GET_CODE (recog_operand[i]) == MEM)
        recog_operand[i] = walk_alter_subreg (recog_operand[i]);
     }
 
@@ -3052,7 +3057,8 @@ cleanup_subreg_operands (insn)
       if (GET_CODE (*recog_dup_loc[i]) == SUBREG)
         *recog_dup_loc[i] = alter_subreg (*recog_dup_loc[i]);
       else if (GET_CODE (*recog_dup_loc[i]) == PLUS
-               || GET_CODE (*recog_dup_loc[i]) == MULT)
+               || GET_CODE (*recog_dup_loc[i]) == MULT
+	       || GET_CODE (*recog_dup_loc[i]) == MEM)
         *recog_dup_loc[i] = walk_alter_subreg (*recog_dup_loc[i]);
     }
 }
@@ -3652,8 +3658,9 @@ output_addr_const (file, x)
 
       output_addr_const (file, XEXP (x, 0));
       fprintf (file, "-");
-      if (GET_CODE (XEXP (x, 1)) == CONST_INT
-	  && INTVAL (XEXP (x, 1)) < 0)
+      if ((GET_CODE (XEXP (x, 1)) == CONST_INT
+	   && INTVAL (XEXP (x, 1)) < 0)
+	  || GET_CODE (XEXP (x, 1)) != CONST_INT)
 	{
 	  fprintf (file, ASM_OPEN_PAREN);
 	  output_addr_const (file, XEXP (x, 1));
diff --git a/gcc/flow.c b/gcc/flow.c
index 432a990..0f6c840 100644
--- a/gcc/flow.c
+++ b/gcc/flow.c
@@ -2744,15 +2744,23 @@ propagate_block (old, first, last, final, significant, bnum, remove_dead_code)
 		{
 		  if (REG_NOTE_KIND (inote) == REG_LABEL)
 		    {
+		      int n_forced;
 		      rtx label = XEXP (inote, 0);
 		      rtx next;
 		      LABEL_NUSES (label)--;
 
+		      /* The label may be forced if it has been put in the
+		         constant pool.  We can't delete it in this case, but
+		         we still must discard a jump table following it.  */
+		      n_forced = 0;
+		      if (LABEL_PRESERVE_P (label))
+			n_forced++;
+
 		      /* If this label was attached to an ADDR_VEC, it's
 			 safe to delete the ADDR_VEC.  In fact, it's pretty much
 			 mandatory to delete it, because the ADDR_VEC may
 			 be referencing labels that no longer exist.  */
-		      if (LABEL_NUSES (label) == 0
+		      if (LABEL_NUSES (label) == n_forced
 			  && (next = next_nonnote_insn (label)) != NULL
 			  && GET_CODE (next) == JUMP_INSN
 			  && (GET_CODE (PATTERN (next)) == ADDR_VEC
@@ -3044,6 +3052,10 @@ insn_dead_p (x, needed, call_ok, notes)
 	      while (--n > 0)
 		if (REGNO_REG_SET_P (needed, regno+n))
 		  return 0;
+
+ 	      /* Don't allow part of a complex number to be deleted.  */
+ 	      if (GET_MODE_CLASS (GET_MODE (r)) == MODE_COMPLEX_FLOAT)
+ 		return 0;
 	    }
 
 	  return 1;
diff --git a/gcc/frame.c b/gcc/frame.c
index 990a0ac..b3f6d29 100644
--- a/gcc/frame.c
+++ b/gcc/frame.c
@@ -51,11 +51,7 @@ Boston, MA 02111-1307, USA.  */
 #include "frame.h"
 #include "gthr.h"
 
-#ifdef __GTHREAD_MUTEX_INIT
-static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;
-#else
 static __gthread_mutex_t object_mutex;
-#endif
 
 /* Don't use `fancy_abort' here even if config.h says to use it.  */
 #ifdef abort
diff --git a/gcc/function.c b/gcc/function.c
index edd0bca..a427b87 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -3053,6 +3053,105 @@ static rtx purge_bitfield_addressof_replacements;
    extracted by usage MEM with narrower mode. */
 static rtx purge_addressof_replacements;
 
+/* Return 1 if X and Y are identical-looking rtx's.
+   This is the Lisp function EQUAL for rtx arguments.  */
+
+int
+rtx_equal_for_addressof_p (x, y)
+     rtx x, y;
+{
+  register int i;
+  register int j;
+  register enum rtx_code code;
+  register char *fmt;
+
+  if (x == y)
+    return 1;
+  if (x == 0 || y == 0)
+    return 0;
+
+  code = GET_CODE (x);
+  /* Rtx's of different codes cannot be equal.  */
+  if (code != GET_CODE (y))
+    return 0;
+
+  /* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.
+     (REG:SI x) and (REG:HI x) are NOT equivalent. 
+     But (MEM:SI x) and (MEM:HI x) are equivalent for our purposes.  */
+
+  if (code != MEM && (GET_MODE (x) != GET_MODE (y)))
+    return 0;
+
+  /* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */
+
+  if (code == REG)
+    return REGNO (x) == REGNO (y);
+  else if (code == LABEL_REF)
+    return XEXP (x, 0) == XEXP (y, 0);
+  else if (code == SYMBOL_REF)
+    return XSTR (x, 0) == XSTR (y, 0);
+  else if (code == SCRATCH || code == CONST_DOUBLE)
+    return 0;
+
+  /* Compare the elements.  If any pair of corresponding elements
+     fail to match, return 0 for the whole things.  */
+
+  fmt = GET_RTX_FORMAT (code);
+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
+    {
+      switch (fmt[i])
+	{
+	case 'w':
+	  if (XWINT (x, i) != XWINT (y, i))
+	    return 0;
+	  break;
+
+	case 'n':
+	case 'i':
+	  if (XINT (x, i) != XINT (y, i))
+	    return 0;
+	  break;
+
+	case 'V':
+	case 'E':
+	  /* Two vectors must have the same length.  */
+	  if (XVECLEN (x, i) != XVECLEN (y, i))
+	    return 0;
+
+	  /* And the corresponding elements must match.  */
+	  for (j = 0; j < XVECLEN (x, i); j++)
+	    if (rtx_equal_p (XVECEXP (x, i, j), XVECEXP (y, i, j)) == 0)
+	      return 0;
+	  break;
+
+	case 'e':
+	  if (rtx_equal_p (XEXP (x, i), XEXP (y, i)) == 0)
+	    return 0;
+	  break;
+
+	case 'S':
+	case 's':
+	  if (strcmp (XSTR (x, i), XSTR (y, i)))
+	    return 0;
+	  break;
+
+	case 'u':
+	  /* These are just backpointers, so they don't matter.  */
+	  break;
+
+	case '0':
+	  break;
+
+	  /* It is believed that rtx's at this level will never
+	     contain anything but integers and other rtx's,
+	     except for within LABEL_REFs and SYMBOL_REFs.  */
+	default:
+	  abort ();
+	}
+    }
+  return 1;
+}
+
 /* Helper function for purge_addressof.  See if the rtx expression at *LOC
    in INSN needs to be changed.  If FORCE, always put any ADDRESSOFs into
    the stack.  */
@@ -3133,7 +3232,7 @@ purge_addressof_1 (loc, insn, force, store, ht)
 	      for (tem = purge_bitfield_addressof_replacements;
 		   tem != NULL_RTX;
 		   tem = XEXP (XEXP (tem, 1), 1))
-		if (rtx_equal_p (x, XEXP (tem, 0)))
+		if (rtx_equal_for_addressof_p (x, XEXP (tem, 0)))
 		  {
 		    *loc = XEXP (XEXP (tem, 1), 0);
 		    return;
@@ -3143,7 +3242,7 @@ purge_addressof_1 (loc, insn, force, store, ht)
 	      for (tem = purge_addressof_replacements;
 		   tem != NULL_RTX;
 		   tem = XEXP (XEXP (tem, 1), 1))
-		if (rtx_equal_p (XEXP (x, 0), XEXP (tem, 0)))
+		if (rtx_equal_for_addressof_p (XEXP (x, 0), XEXP (tem, 0)))
 		  {
 		    rtx z = XEXP (XEXP (tem, 1), 0);
 
@@ -5292,7 +5391,18 @@ locate_and_pad_parm (passed_mode, type, in_regs, fndecl,
 				- offset_ptr->constant); 
     }
 #else /* !ARGS_GROW_DOWNWARD */
-  pad_to_arg_alignment (initial_offset_ptr, boundary);
+  if (!in_regs 
+#ifdef REG_PARM_STACK_SPACE
+      || REG_PARM_STACK_SPACE (fndecl) > 0
+#else
+      /* For the gcc-2_95-branch we want to make sure not to break something
+         on platforms which pass argument in registers but don't define
+         REG_PARM_STACK_SPACE. So we force the original behaviour here.  */
+      || 1
+#endif
+      )
+    pad_to_arg_alignment (initial_offset_ptr, boundary);
+
   *offset_ptr = *initial_offset_ptr;
 
 #ifdef PUSH_ROUNDING
diff --git a/gcc/gcc.c b/gcc/gcc.c
index d4dbf5e..c5a312d 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -5040,48 +5040,53 @@ main (argc, argv)
 	  int len;
 
 	  if (cp->spec[0][0] == '#')
-	    error ("%s: %s compiler not installed on this system",
-		   input_filename, &cp->spec[0][1]);
-
-	  input_basename = input_filename;
-	  for (p = input_filename; *p; p++)
-	    if (IS_DIR_SEPARATOR (*p))
-	      input_basename = p + 1;
-
-	  /* Find a suffix starting with the last period,
-	     and set basename_length to exclude that suffix.  */
-	  basename_length = strlen (input_basename);
-	  p = input_basename + basename_length;
-	  while (p != input_basename && *p != '.') --p;
-	  if (*p == '.' && p != input_basename)
 	    {
-	      basename_length = p - input_basename;
-	      input_suffix = p + 1;
+	      error ("%s: %s compiler not installed on this system",
+		     input_filename, &cp->spec[0][1]);
+	      this_file_error = 1;
 	    }
 	  else
-	    input_suffix = "";
+	    {
+	      input_basename = input_filename;
+	      for (p = input_filename; *p; p++)
+		if (IS_DIR_SEPARATOR (*p))
+		  input_basename = p + 1;
+
+	      /* Find a suffix starting with the last period,
+		 and set basename_length to exclude that suffix.  */
+	      basename_length = strlen (input_basename);
+	      p = input_basename + basename_length;
+	      while (p != input_basename && *p != '.') --p;
+	      if (*p == '.' && p != input_basename)
+		{
+		  basename_length = p - input_basename;
+		  input_suffix = p + 1;
+		}
+	      else
+		input_suffix = "";
 
-	  len = 0;
-	  for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
-	    if (cp->spec[j])
-	      len += strlen (cp->spec[j]);
+	      len = 0;
+	      for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
+		if (cp->spec[j])
+		  len += strlen (cp->spec[j]);
 
-	  {
-	    char *p1 = (char *) xmalloc (len + 1);
+	      {
+		char *p1 = (char *) xmalloc (len + 1);
 	    
-	    len = 0;
-	    for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
-	      if (cp->spec[j])
-		{
-		  strcpy (p1 + len, cp->spec[j]);
-		  len += strlen (cp->spec[j]);
-		}
+		len = 0;
+		for (j = 0; j < sizeof cp->spec / sizeof cp->spec[0]; j++)
+		  if (cp->spec[j])
+		    {
+		      strcpy (p1 + len, cp->spec[j]);
+		      len += strlen (cp->spec[j]);
+		    }
 	    
-	    value = do_spec (p1);
-	    free (p1);
-	  }
-	  if (value < 0)
-	    this_file_error = 1;
+		value = do_spec (p1);
+		free (p1);
+	      }
+	      if (value < 0)
+		this_file_error = 1;
+	    }
 	}
 
       /* If this file's name does not contain a recognized suffix,
diff --git a/gcc/gcse.c b/gcc/gcse.c
index cddd7ac..f72f075 100644
--- a/gcc/gcse.c
+++ b/gcc/gcse.c
@@ -1856,7 +1856,9 @@ hash_scan_set (pat, insn, set_p)
 	  /* Don't GCSE something if we can't do a reg/reg copy.  */
 	  && can_copy_p [GET_MODE (dest)]
 	  /* Is SET_SRC something we want to gcse?  */
-	  && want_to_gcse_p (src))
+	  && want_to_gcse_p (src)
+	  /* Copy between modes is prohibited */
+	  && GET_MODE (src) == GET_MODE (dest))
 	{
 	  /* An expression is not anticipatable if its operands are
 	     modified before this insn.  */
diff --git a/gcc/install.texi b/gcc/install.texi
index ac360e9..a667df6 100644
--- a/gcc/install.texi
+++ b/gcc/install.texi
@@ -1596,7 +1596,7 @@ linker that are fixed by using the GNU versions of these tools.
 Embedded PowerPC system in little endian mode for use in running under
 the PSIM simulator.
 
-@itemx powerpcle-*-eabi
+@item powerpcle-*-eabi
 Embedded PowerPC system in little endian mode.
 
 You can specify a default version for the @samp{-mcpu=}@var{cpu_type}
diff --git a/gcc/invoke.texi b/gcc/invoke.texi
index e97495e..9865a34 100644
--- a/gcc/invoke.texi
+++ b/gcc/invoke.texi
@@ -1694,6 +1694,12 @@ A @code{switch} statement has an operand of type @code{long}.
 @item
 A non-@code{static} function declaration follows a @code{static} one.
 This construct is not accepted by some traditional C compilers.
+
+@item
+The ANSI type of an integer constant has a different width or signedness
+from its traditional type.  This warning is only issued if the base of
+the constant is ten.  I.e. hexadecimal or octal values, which typically
+represent bit patterns, are not warned about.
 @end itemize
 
 @item -Wundef
diff --git a/gcc/java/Make-lang.in b/gcc/java/Make-lang.in
index 39397f2..25ac3f7 100644
--- a/gcc/java/Make-lang.in
+++ b/gcc/java/Make-lang.in
@@ -144,28 +144,28 @@ java.install-normal:
 java.install-common:
 	-if [ -f $(GCJ)$(exeext) ]; then \
 	  if [ -f $(GCJ)-cross$(exeext) ]; then \
-	    rm -f $(bindir)/$(JAVA_CROSS_NAME)$(exeext); \
-	    $(INSTALL_PROGRAM) $(GCJ)-cross$(exeext) $(bindir)/$(JAVA_CROSS_NAME)$(exeext); \
-	    chmod a+x $(bindir)/$(JAVA_CROSS_NAME)$(exeext); \
+	    rm -f $(DESTDIR)$(bindir)/$(JAVA_CROSS_NAME)$(exeext); \
+	    $(INSTALL_PROGRAM) $(GCJ)-cross$(exeext) $(DESTDIR)$(bindir)/$(JAVA_CROSS_NAME)$(exeext); \
+	    chmod a+x $(DESTDIR)$(bindir)/$(JAVA_CROSS_NAME)$(exeext); \
 	  else \
-	    rm -f $(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \
-	    $(INSTALL_PROGRAM) $(GCJ)$(exeext) $(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \
-	    chmod a+x $(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \
+	    rm -f $(DESTDIR)$(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \
+	    $(INSTALL_PROGRAM) $(GCJ)$(exeext) $(DESTDIR)$(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \
+	    chmod a+x $(DESTDIR)$(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \
 	  fi ; \
 	fi ; \
         for tool in $(JAVA_TARGET_INDEPENDENT_BIN_TOOLS); do \
           if [ -f $$tool$(exeext) ]; then \
-	    rm -f $(bindir)/$$tool$(exeext); \
-	    $(INSTALL_PROGRAM) $$tool$(exeext) $(bindir)/$$tool$(exeext); \
-	    chmod a+x $(bindir)/$$tool$(exeext); \
+	    rm -f $(DESTDIR)$(bindir)/$$tool$(exeext); \
+	    $(INSTALL_PROGRAM) $$tool$(exeext) $(DESTDIR)$(bindir)/$$tool$(exeext); \
+	    chmod a+x $(DESTDIR)$(bindir)/$$tool$(exeext); \
           fi ; \
        done
 
 java.install-man:
 
 java.uninstall:
-	-rm -rf $(bindir)/$(JAVA_INSTALL_NAME)$(exeext)
-	-rm -rf $(bindir)/$(JAVA_CROSS_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(JAVA_INSTALL_NAME)$(exeext)
+	-rm -rf $(DESTDIR)$(bindir)/$(JAVA_CROSS_NAME)$(exeext)
 
 java.install-info:
 
diff --git a/gcc/jump.c b/gcc/jump.c
index 32eebd1..5ddd512 100644
--- a/gcc/jump.c
+++ b/gcc/jump.c
@@ -115,7 +115,7 @@ static void mark_all_labels		PROTO((rtx, int));
 static rtx delete_unreferenced_labels	PROTO((rtx));
 static void delete_noop_moves		PROTO((rtx));
 static int calculate_can_reach_end	PROTO((rtx, int, int));
-static int duplicate_loop_exit_test	PROTO((rtx));
+static int duplicate_loop_exit_test	PROTO((rtx, int));
 static void find_cross_jump		PROTO((rtx, rtx, int, rtx *, rtx *));
 static void do_cross_jump		PROTO((rtx, rtx, rtx));
 static int jump_back_p			PROTO((rtx, rtx));
@@ -200,8 +200,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)
   if (flag_exceptions && cross_jump)
     init_insn_eh_region (f, max_uid);
 
-  delete_barrier_successors (f);
-
   /* Leave some extra room for labels and duplicate exit test insns
      we make.  */
   max_jump_chain = max_uid * 14 / 10;
@@ -224,6 +222,8 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)
   for (insn = exception_handler_labels; insn; insn = XEXP (insn, 1))
     LABEL_NUSES (XEXP (insn, 0))++;
 
+  delete_barrier_successors (f);
+
   /* Quit now if we just wanted to rebuild the JUMP_LABEL and REG_LABEL
      notes and recompute LABEL_NUSES.  */
   if (mark_labels_only)
@@ -338,7 +338,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)
 	      && simplejump_p (temp1))
 	    {
 	      temp = PREV_INSN (insn);
-	      if (duplicate_loop_exit_test (insn))
+	      if (duplicate_loop_exit_test (insn, after_regscan))
 		{
 		  changed = 1;
 		  next = NEXT_INSN (temp);
@@ -2139,7 +2139,24 @@ delete_barrier_successors (f)
 	  insn = NEXT_INSN (insn);
 	  while (insn != 0 && GET_CODE (insn) != CODE_LABEL)
 	    {
-	      if (GET_CODE (insn) == NOTE
+	      if (GET_CODE (insn) == JUMP_INSN)
+		{
+		  /* Detect when we're deleting a tablejump; get rid of
+		     the jump table as well.  */
+		  rtx next1 = next_nonnote_insn (insn);
+		  rtx next2 = next1 ? next_nonnote_insn (next1) : 0;
+		  if (next2 && GET_CODE (next1) == CODE_LABEL
+		      && GET_CODE (next2) == JUMP_INSN
+		      && (GET_CODE (PATTERN (next2)) == ADDR_VEC
+			  || GET_CODE (PATTERN (next2)) == ADDR_DIFF_VEC))
+		    {
+		      delete_insn (insn);
+		      insn = next2;
+		    }
+		  else
+		    insn = delete_insn (insn);
+		}
+	      else if (GET_CODE (insn) == NOTE
 		  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END)
 		insn = NEXT_INSN (insn);
 	      else
@@ -2548,8 +2565,9 @@ calculate_can_reach_end (last, check_deleted, delete_final_note)
    values of regno_first_uid and regno_last_uid.  */
 
 static int
-duplicate_loop_exit_test (loop_start)
+duplicate_loop_exit_test (loop_start, after_regscan)
      rtx loop_start;
+     int after_regscan;
 {
   rtx insn, set, reg, p, link;
   rtx copy = 0, first_copy = 0;
@@ -2663,6 +2681,9 @@ duplicate_loop_exit_test (loop_start)
 	  }
       }
 
+  if (after_regscan)
+    reg_scan_update (exitcode, lastexit, max_reg);
+
   /* Now copy each insn.  */
   for (insn = exitcode; insn != lastexit; insn = NEXT_INSN (insn))
     {
diff --git a/gcc/loop.c b/gcc/loop.c
index aca291d..c13d912 100644
--- a/gcc/loop.c
+++ b/gcc/loop.c
@@ -320,11 +320,12 @@ static int count_nonfixed_reads PROTO((rtx));
 static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx, rtx, int, int));
 static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));
 static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));
-static void find_mem_givs PROTO((rtx, rtx, int, rtx, rtx));
+static void find_mem_givs PROTO((rtx, rtx, int, int, rtx, rtx));
 static void record_biv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx *, int, int));
 static void check_final_value PROTO((struct induction *, rtx, rtx, 
 				     unsigned HOST_WIDE_INT));
-static void record_giv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx, int, enum g_types, int, rtx *, rtx, rtx));
+static void record_giv PROTO((struct induction *, rtx, rtx, rtx, rtx, rtx,
+			      int, enum g_types, int, int, rtx *, rtx, rtx));
 static void update_giv_derive PROTO((rtx));
 static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, rtx *, rtx **));
 static rtx simplify_giv_expr PROTO((rtx, int *));
@@ -4420,6 +4421,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,
      biv and a constant (or invariant), and it is not a biv.  */
 
   not_every_iteration = 0;
+  maybe_multiple = 0;
   loop_depth = 0;
   p = scan_start;
   while (1)
@@ -4439,6 +4441,40 @@ strength_reduce (scan_start, end, loop_top, insn_count,
 	    break;
 	}
 
+      if (GET_CODE (p) == CODE_LABEL)
+	{
+	  rtx insn = p;
+
+	  maybe_multiple = 0;
+
+	  while (1)
+	    {
+	      insn = NEXT_INSN (insn);
+	      if (insn == scan_start)
+		break;
+	      if (insn == end)
+		{
+		  if (loop_top != 0)
+		    insn = loop_top;
+		  else
+		    break;
+		  if (insn == scan_start)
+		    break;
+		}
+
+	      if (GET_CODE (insn) == JUMP_INSN
+		  && GET_CODE (PATTERN (insn)) != RETURN
+		  && (! condjump_p (insn)
+		      || (JUMP_LABEL (insn) != 0
+			  && JUMP_LABEL (insn) != scan_start
+			  && ! loop_insn_first_p (p, JUMP_LABEL (insn)))))
+		{
+		  maybe_multiple = 1;
+		  break;
+		}
+	    }
+	}
+
       /* Look for a general induction variable in a register.  */
       if (GET_CODE (p) == INSN
 	  && (set = single_set (p))
@@ -4489,8 +4525,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,
 		p = last_consec_insn;
 
 	      record_giv (v, p, src_reg, dest_reg, mult_val, add_val, benefit,
-			  DEST_REG, not_every_iteration, NULL_PTR, loop_start,
-			  loop_end);
+			  DEST_REG, not_every_iteration, maybe_multiple,
+			  NULL_PTR, loop_start, loop_end);
 
 	    }
 	}
@@ -4500,8 +4536,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,
       /* This resulted in worse code on a VAX 8600.  I wonder if it
 	 still does.  */
       if (GET_CODE (p) == INSN)
-	find_mem_givs (PATTERN (p), p, not_every_iteration, loop_start,
-		       loop_end);
+	find_mem_givs (PATTERN (p), p, not_every_iteration, maybe_multiple,
+		       loop_start, loop_end);
 #endif
 
       /* Update the status of whether giv can derive other givs.  This can
@@ -5240,10 +5276,12 @@ valid_initial_value_p (x, insn, call_seen, loop_start)
    every loop iteration.  */
 
 static void
-find_mem_givs (x, insn, not_every_iteration, loop_start, loop_end)
+find_mem_givs (x, insn, not_every_iteration, maybe_multiple,
+	       loop_start, loop_end)
      rtx x;
      rtx insn;
      int not_every_iteration;
+     int maybe_multiple;
      rtx loop_start, loop_end;
 {
   register int i, j;
@@ -5291,7 +5329,7 @@ find_mem_givs (x, insn, not_every_iteration, loop_start, loop_end)
 
 	    record_giv (v, insn, src_reg, addr_placeholder, mult_val,
 			add_val, benefit, DEST_ADDR, not_every_iteration,
-			&XEXP (x, 0), loop_start, loop_end);
+			maybe_multiple, &XEXP (x, 0), loop_start, loop_end);
 
 	    v->mem_mode = GET_MODE (x);
 	  }
@@ -5307,12 +5345,12 @@ find_mem_givs (x, insn, not_every_iteration, loop_start, loop_end)
   fmt = GET_RTX_FORMAT (code);
   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
     if (fmt[i] == 'e')
-      find_mem_givs (XEXP (x, i), insn, not_every_iteration, loop_start,
-		     loop_end);
+      find_mem_givs (XEXP (x, i), insn, not_every_iteration, maybe_multiple,
+		     loop_start, loop_end);
     else if (fmt[i] == 'E')
       for (j = 0; j < XVECLEN (x, i); j++)
 	find_mem_givs (XVECEXP (x, i, j), insn, not_every_iteration,
-		       loop_start, loop_end);
+		       maybe_multiple, loop_start, loop_end);
 }
 
 /* Fill in the data about one biv update.
@@ -5434,7 +5472,8 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,
 
 static void
 record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,
-	    type, not_every_iteration, location, loop_start, loop_end)
+	    type, not_every_iteration, maybe_multiple,
+	    location, loop_start, loop_end)
      struct induction *v;
      rtx insn;
      rtx src_reg;
@@ -5443,6 +5482,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,
      int benefit;
      enum g_types type;
      int not_every_iteration;
+     int maybe_multiple;
      rtx *location;
      rtx loop_start, loop_end;
 {
@@ -5460,7 +5500,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,
   v->location = location;
   v->cant_derive = 0;
   v->combined_with = 0;
-  v->maybe_multiple = 0;
+  v->maybe_multiple = maybe_multiple;
   v->maybe_dead = 0;
   v->derive_adjustment = 0;
   v->same = 0;
diff --git a/gcc/po/Makefile.in.in b/gcc/po/Makefile.in.in
index 746d521..f623a98 100644
--- a/gcc/po/Makefile.in.in
+++ b/gcc/po/Makefile.in.in
@@ -111,9 +111,9 @@ install-data: install-data-@USE_NLS@
 install-data-no: all
 install-data-yes: all
 	if test -r "$(MKINSTALLDIRS)"; then \
-	  $(MKINSTALLDIRS) $(datadir); \
+	  $(MKINSTALLDIRS) $(DESTDIR)$(datadir); \
 	else \
-	  $(SHELL) $(top_srcdir)/mkinstalldirs $(datadir); \
+	  $(SHELL) $(top_srcdir)/mkinstalldirs $(DESTDIR)$(datadir); \
 	fi
 	@catalogs='$(CATALOGS)'; \
 	for cat in $$catalogs; do \
@@ -125,27 +125,27 @@ install-data-yes: all
 	  lang=`echo $$cat | sed 's/\$(CATOBJEXT)$$//'`; \
 	  dir=$$destdir/$$lang/LC_MESSAGES; \
 	  if test -r "$(MKINSTALLDIRS)"; then \
-	    $(MKINSTALLDIRS) $$dir; \
+	    $(MKINSTALLDIRS) $(DESTDIR)$$dir; \
 	  else \
-	    $(SHELL) $(top_srcdir)/mkinstalldirs $$dir; \
+	    $(SHELL) $(top_srcdir)/mkinstalldirs $(DESTDIR)$$dir; \
 	  fi; \
 	  if test -r $$cat; then \
-	    $(INSTALL_DATA) $$cat $$dir/$(PACKAGE)$(INSTOBJEXT); \
-	    echo "installing $$cat as $$dir/$(PACKAGE)$(INSTOBJEXT)"; \
+	    $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/$(PACKAGE)$(INSTOBJEXT); \
+	    echo "installing $$cat as $(DESTDIR)$$dir/$(PACKAGE)$(INSTOBJEXT)"; \
 	  else \
-	    $(INSTALL_DATA) $(srcdir)/$$cat $$dir/$(PACKAGE)$(INSTOBJEXT); \
+	    $(INSTALL_DATA) $(srcdir)/$$cat $(DESTDIR)$$dir/$(PACKAGE)$(INSTOBJEXT); \
 	    echo "installing $(srcdir)/$$cat as" \
-		 "$$dir/$(PACKAGE)$(INSTOBJEXT)"; \
+		 "$(DESTDIR)$$dir/$(PACKAGE)$(INSTOBJEXT)"; \
 	  fi; \
 	  if test -r $$cat.m; then \
-	    $(INSTALL_DATA) $$cat.m $$dir/$(PACKAGE)$(INSTOBJEXT).m; \
-	    echo "installing $$cat.m as $$dir/$(PACKAGE)$(INSTOBJEXT).m"; \
+	    $(INSTALL_DATA) $$cat.m $(DESTDIR)$$dir/$(PACKAGE)$(INSTOBJEXT).m; \
+	    echo "installing $$cat.m as $(DESTDIR)$$dir/$(PACKAGE)$(INSTOBJEXT).m"; \
 	  else \
 	    if test -r $(srcdir)/$$cat.m ; then \
 	      $(INSTALL_DATA) $(srcdir)/$$cat.m \
-		$$dir/$(PACKAGE)$(INSTOBJEXT).m; \
+		$(DESTDIR)$$dir/$(PACKAGE)$(INSTOBJEXT).m; \
 	      echo "installing $(srcdir)/$$cat as" \
-		   "$$dir/$(PACKAGE)$(INSTOBJEXT).m"; \
+		   "$(DESTDIR)$$dir/$(PACKAGE)$(INSTOBJEXT).m"; \
 	    else \
 	      true; \
 	    fi; \
@@ -153,12 +153,12 @@ install-data-yes: all
 	done
 	if test "$(PACKAGE)" = "gettext"; then \
 	  if test -r "$(MKINSTALLDIRS)"; then \
-	    $(MKINSTALLDIRS) $(gettextsrcdir); \
+	    $(MKINSTALLDIRS) $(DESTDIR)$(gettextsrcdir); \
 	  else \
-	    $(SHELL) $(top_srcdir)/mkinstalldirs $(gettextsrcdir); \
+	    $(SHELL) $(top_srcdir)/mkinstalldirs $(DESTDIR)$(gettextsrcdir); \
 	  fi; \
 	  $(INSTALL_DATA) $(srcdir)/Makefile.in.in \
-			  $(gettextsrcdir)/Makefile.in.in; \
+			  $(DESTDIR)$(gettextsrcdir)/Makefile.in.in; \
 	else \
 	  : ; \
 	fi
@@ -171,12 +171,12 @@ uninstall:
 	for cat in $$catalogs; do \
 	  cat=`basename $$cat`; \
 	  lang=`echo $$cat | sed 's/\$(CATOBJEXT)$$//'`; \
-	  rm -f $(localedir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT); \
-	  rm -f $(localedir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT).m; \
-	  rm -f $(gnulocaledir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT); \
-	  rm -f $(gnulocaledir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT).m; \
+	  rm -f $(DESTDIR)$(localedir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT); \
+	  rm -f $(DESTDIR)$(localedir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT).m; \
+	  rm -f $(DESTDIR)$(gnulocaledir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT); \
+	  rm -f $(DESTDIR)$(gnulocaledir)/$$lang/LC_MESSAGES/$(PACKAGE)$(INSTOBJEXT).m; \
 	done
-	rm -f $(gettextsrcdir)/po-Makefile.in.in
+	rm -f $(DESTDIR)$(gettextsrcdir)/po-Makefile.in.in
 
 check: all
 
diff --git a/gcc/regmove.c b/gcc/regmove.c
index 8008595..27c6d4a 100644
--- a/gcc/regmove.c
+++ b/gcc/regmove.c
@@ -693,6 +693,9 @@ optimize_reg_copy_3 (insn, dest, src)
     }
   if (! (set = single_set (p))
       || GET_CODE (SET_SRC (set)) != MEM
+      /* If there's a REG_EQUIV note, this must be an insn that loads an
+	 argument.  Prefer keeping the note over doing this optimization.  */
+      || find_reg_note (p, REG_EQUIV, NULL_RTX)
       || SET_DEST (set) != src_reg)
     return;
 
@@ -737,6 +740,12 @@ optimize_reg_copy_3 (insn, dest, src)
       PUT_MODE (src_reg, old_mode);
       XEXP (src, 0) = src_reg;
     }
+  else
+    {
+      rtx note = find_reg_note (p, REG_EQUAL, NULL_RTX);
+      if (note)
+	remove_note (p, note);
+    }
 }
 
 
diff --git a/gcc/reload1.c b/gcc/reload1.c
index e95ff5e..24eb011 100644
--- a/gcc/reload1.c
+++ b/gcc/reload1.c
@@ -4278,9 +4278,6 @@ reload_as_needed (live_known)
 			    spill_reg_order);
 	    }
 
-	  if (num_eliminable && chain->need_elim)
-	    update_eliminable_offsets ();
-
 	  if (n_reloads > 0)
 	    {
 	      rtx next = NEXT_INSN (insn);
@@ -4327,6 +4324,10 @@ reload_as_needed (live_known)
 		      NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;
 		    }
 	    }
+
+	  if (num_eliminable && chain->need_elim)
+	    update_eliminable_offsets ();
+
 	  /* Any previously reloaded spilled pseudo reg, stored in this insn,
 	     is no longer validly lying around to save a future reload.
 	     Note that this does not detect pseudos that were reloaded
@@ -8071,7 +8072,9 @@ delete_output_reload (insn, j, last_reload_reg)
     }
   n_occurrences = count_occurrences (PATTERN (insn), reg);
   if (substed)
-    n_occurrences += count_occurrences (PATTERN (insn), substed);
+    n_occurrences += count_occurrences (PATTERN (insn),
+					eliminate_regs (substed, 0,
+							NULL_RTX));
   if (n_occurrences > n_inherited)
     return;
 
@@ -9967,6 +9970,21 @@ reload_combine_note_use (xp, insn)
 	}
       break;
 
+    case USE:
+      /* If this is the USE of a return value, we can't change it.  */
+      if (GET_CODE (XEXP (x, 0)) == REG && REG_FUNCTION_VALUE_P (XEXP (x, 0)))
+	{
+	/* Mark the return register as used in an unknown fashion.  */
+	  rtx reg = XEXP (x, 0);
+	  int regno = REGNO (reg);
+	  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));
+
+	  while (--nregs >= 0)
+	    reg_state[regno + nregs].use_index = -1;
+	  return;
+	}
+      break;
+
     case CLOBBER:
       if (GET_CODE (SET_DEST (x)) == REG)
 	return;
@@ -9983,12 +10001,23 @@ reload_combine_note_use (xp, insn)
       {
 	int regno = REGNO (x);
 	int use_index;
+	int nregs;
 
 	/* Some spurious USEs of pseudo registers might remain.
 	   Just ignore them.  */
 	if (regno >= FIRST_PSEUDO_REGISTER)
 	  return;
 
+	nregs = HARD_REGNO_NREGS (regno, GET_MODE (x));
+
+	/* We can't substitute into multi-hard-reg uses.  */
+	if (nregs > 1)
+	  {
+	    while (--nregs >= 0)
+	      reg_state[regno + nregs].use_index = -1;
+	    return;
+	  }
+
 	/* If this register is already used in some unknown fashion, we
 	   can't do anything.
 	   If we decrement the index from zero to -1, we can't store more
diff --git a/gcc/rtl.h b/gcc/rtl.h
index efbf588..16f0527 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -168,7 +168,8 @@ typedef struct rtx_def
      either changing how we compute the frame address or saving and
      restoring registers in the prologue and epilogue.  
      1 in a MEM if the MEM refers to a scalar, rather than a member of
-     an aggregate.  */
+     an aggregate.
+     1 in a SYMBOL_REF if the symbol is weak.  */
   unsigned frame_related : 1;
   /* The first element of the operands of this rtx.
      The number of operands and their types are controlled
@@ -661,6 +662,9 @@ extern char *note_insn_name[];
 /* 1 means a SYMBOL_REF has been the library function in emit_library_call.  */
 #define SYMBOL_REF_USED(RTX) ((RTX)->used)
 
+/* 1 means a SYMBOL_REF is weak.  */
+#define SYMBOL_REF_WEAK(RTX) ((RTX)->frame_related)
+
 /* For an INLINE_HEADER rtx, FIRST_FUNCTION_INSN is the first insn
    of the function that is not involved in copying parameters to
    pseudo-registers.  FIRST_PARM_INSN is the very first insn of
@@ -888,6 +892,12 @@ extern char *note_insn_name[];
 /* For a NOTE_INSN_LIVE note, the original basic block number.  */
 #define RANGE_LIVE_ORIG_BLOCK(INSN) (XINT (INSN, 1))
 
+/* Nonzero if we need to distinguish between the return value of this function
+   and the return value of a function called by this function.  This helps
+   integrate.c.
+   This is 1 until after the rtl generation pass.  */
+extern int rtx_equal_function_value_matters;
+
 /* Generally useful functions.  */
 
 /* The following functions accept a wide integer argument.  Rather than
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index d1b9432..05d7420 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -136,11 +136,9 @@ rtx_addr_can_trap_p (x)
   switch (code)
     {
     case SYMBOL_REF:
+      return SYMBOL_REF_WEAK (x);
+
     case LABEL_REF:
-      /* SYMBOL_REF is problematic due to the possible presence of
-	 a #pragma weak, but to say that loads from symbols can trap is
-	 *very* costly.  It's not at all clear what's best here.  For
-	 now, we ignore the impact of #pragma weak.  */
       return 0;
 
     case REG:
diff --git a/gcc/stor-layout.c b/gcc/stor-layout.c
index 798a795..7f886d1 100644
--- a/gcc/stor-layout.c
+++ b/gcc/stor-layout.c
@@ -264,8 +264,8 @@ layout_decl (decl, known_align)
       if (spec_size == 0 && DECL_NAME (decl) != 0)
 	abort ();
 
-      /* Size is specified number of bits.  */
-      DECL_SIZE (decl) = size_int (spec_size);
+      /* Size is specified in number of bits.  */
+      DECL_SIZE (decl) = bitsize_int (spec_size, 0);
     }
   /* Force alignment required for the data type.
      But if the decl itself wants greater alignment, don't override that.
@@ -301,7 +301,7 @@ layout_decl (decl, known_align)
 	  DECL_ALIGN (decl) = MAX ((unsigned) GET_MODE_ALIGNMENT (xmode),
 				   DECL_ALIGN (decl));
 	  DECL_MODE (decl) = xmode;
-	  DECL_SIZE (decl) = size_int (GET_MODE_BITSIZE (xmode));
+	  DECL_SIZE (decl) = bitsize_int (GET_MODE_BITSIZE (xmode), 0);
 	  /* This no longer needs to be accessed as a bit field.  */
 	  DECL_BIT_FIELD (decl) = 0;
 	}
@@ -520,7 +520,7 @@ layout_record (rec)
 	DECL_FIELD_BITPOS (field) = var_size;
       else
 	{
-	  DECL_FIELD_BITPOS (field) = size_int (const_size);
+	  DECL_FIELD_BITPOS (field) = bitsize_int (const_size, 0L);
 
 	  /* If this field ended up more aligned than we thought it
 	     would be (we approximate this by seeing if its position
@@ -562,7 +562,7 @@ layout_record (rec)
 
   if (var_size == 0)
     {
-      TYPE_SIZE (rec) = size_int (const_size);
+      TYPE_SIZE (rec) = bitsize_int (const_size, 0L);
     }
   else
     {
@@ -610,7 +610,7 @@ layout_union (rec)
   /* The size of the union, based on the fields scanned so far,
      is max (CONST_SIZE, VAR_SIZE).
      VAR_SIZE may be null; then CONST_SIZE by itself is the size.  */
-  register int const_size = 0;
+  register HOST_WIDE_INT const_size = 0;
   register tree var_size = 0;
 
 #ifdef STRUCTURE_SIZE_BOUNDARY
@@ -627,6 +627,8 @@ layout_union (rec)
 
   for (field = TYPE_FIELDS (rec); field; field = TREE_CHAIN (field))
     {
+      tree dsize;
+      
       /* Enums which are local to this class need not be laid out.  */
       if (TREE_CODE (field) == CONST_DECL || TREE_CODE (field) == TYPE_DECL)
 	continue;
@@ -645,19 +647,22 @@ layout_union (rec)
 	union_align = MAX (union_align, TYPE_ALIGN (TREE_TYPE (field)));
 #endif
 
+      dsize = DECL_SIZE (field);
       if (TREE_CODE (rec) == UNION_TYPE)
 	{
 	  /* Set union_size to max (decl_size, union_size).
 	     There are more and less general ways to do this.
 	     Use only CONST_SIZE unless forced to use VAR_SIZE.  */
 
-	  if (TREE_CODE (DECL_SIZE (field)) == INTEGER_CST)
+	  if (TREE_CODE (dsize) == INTEGER_CST
+              && ! TREE_CONSTANT_OVERFLOW (dsize)
+              && TREE_INT_CST_HIGH (dsize) == 0)
 	    const_size
-	      = MAX (const_size, TREE_INT_CST_LOW (DECL_SIZE (field)));
+	      = MAX (const_size, TREE_INT_CST_LOW (dsize));
 	  else if (var_size == 0)
-	    var_size = DECL_SIZE (field);
+	    var_size = dsize;
 	  else
-	    var_size = size_binop (MAX_EXPR, var_size, DECL_SIZE (field));
+	    var_size = size_binop (MAX_EXPR, var_size, dsize);
 	}
       else if (TREE_CODE (rec) == QUAL_UNION_TYPE)
 	var_size = fold (build (COND_EXPR, sizetype, DECL_QUALIFIER (field),
diff --git a/gcc/tm.texi b/gcc/tm.texi
index a13c6d9..484c73c 100644
--- a/gcc/tm.texi
+++ b/gcc/tm.texi
@@ -3464,6 +3464,13 @@ figure them out, compile a small program for profiling using the
 system's installed C compiler and look at the assembler code that
 results.
 
+@findex NO_PROFILE_COUNTERS
+@item NO_PROFILE_COUNTERS
+Define this macro if the @code{mcount} subroutine on your system does
+not need a counter variable allocated for each function.  This is true
+for almost all modern implementations.  If you define this macro, you
+must not use the @var{labelno} argument to @code{FUNCTION_PROFILER}.
+
 @findex PROFILE_BEFORE_PROLOGUE
 @item PROFILE_BEFORE_PROLOGUE
 Define this macro if the code for function profiling should come before
diff --git a/gcc/toplev.c b/gcc/toplev.c
index 5f8913f..a575dc6 100644
--- a/gcc/toplev.c
+++ b/gcc/toplev.c
@@ -137,8 +137,6 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!
 #define DIR_SEPARATOR '/'
 #endif
 
-extern int rtx_equal_function_value_matters;
-
 #if ! (defined (VMS) || defined (OS2))
 extern char **environ;
 #endif
diff --git a/gcc/varasm.c b/gcc/varasm.c
index b935065..4db6459 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -723,6 +723,8 @@ make_decl_rtl (decl, asmspec, top_level)
 	 Also handle vars declared register invalidly.  */
       if (DECL_RTL (decl) == 0)
 	{
+	  rtx x;
+
 	  /* Can't use just the variable's own name for a variable
 	     whose scope is less than the whole file.
 	     Concatenate a distinguishing number.  */
@@ -752,8 +754,10 @@ make_decl_rtl (decl, asmspec, top_level)
 	      			   new_name, strlen (new_name));
 	    }
 
-	  DECL_RTL (decl) = gen_rtx_MEM (DECL_MODE (decl),
-					 gen_rtx_SYMBOL_REF (Pmode, name));
+	  x = gen_rtx_SYMBOL_REF (Pmode, name);
+	  SYMBOL_REF_WEAK (x) = DECL_WEAK (decl);
+	  DECL_RTL (decl) = gen_rtx_MEM (DECL_MODE (decl), x);
+
 	  MEM_ALIAS_SET (DECL_RTL (decl)) = get_alias_set (decl);
 	    
 	  /* If this variable is to be treated as volatile, show its
@@ -3286,7 +3290,10 @@ decode_rtx_const (mode, x, value)
 	  value->un.addr.offset = - INTVAL (XEXP (x, 1));
 	}
       else
-	abort ();
+	{
+	  value->un.addr.base = x;
+	  value->un.addr.offset = 0;
+	}
       break;
 
     default:
diff --git a/libf2c/Makefile.in b/libf2c/Makefile.in
index 790e6cd..8f20a1c 100644
--- a/libf2c/Makefile.in
+++ b/libf2c/Makefile.in
@@ -197,10 +197,10 @@ check:
 	cd libU77; $(MAKE) G77DIR=../../../gcc/ check
 
 install: all
-	$(INSTALL_DATA) $(LIBG2C) $(libsubdir)/$(MULTISUBDIR)/$(LIBG2C).n
-	( cd $(libsubdir)/$(MULTISUBDIR) ; $(RANLIB) $(LIBG2C).n )
-	mv -f $(libsubdir)/$(MULTISUBDIR)/$(LIBG2C).n $(libsubdir)/$(MULTISUBDIR)/$(LIBG2C)
-	$(INSTALL_DATA) g2c.h $(libsubdir)/include/g2c.h
+	$(INSTALL_DATA) $(LIBG2C) $(DESTDIR)$(libsubdir)/$(MULTISUBDIR)/$(LIBG2C).n
+	( cd $(DESTDIR)$(libsubdir)/$(MULTISUBDIR) ; $(RANLIB) $(LIBG2C).n )
+	mv -f $(DESTDIR)$(libsubdir)/$(MULTISUBDIR)/$(LIBG2C).n $(DESTDIR)$(libsubdir)/$(MULTISUBDIR)/$(LIBG2C)
+	$(INSTALL_DATA) g2c.h $(DESTDIR)$(libsubdir)/include/g2c.h
 	@if [ -f f2c-install-ok -o -f $(srcdir)/f2c-install-ok ]; then \
 	  echo ''; \
 	  echo 'Warning: g77 no longer installs libf2c.a or f2c.h.'; \
@@ -216,7 +216,7 @@ install-strip:
 	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
 
 uninstall:
-	rm -f $(libsubdir)/$(MULTISUBDIR)/include/g2c.h $(libsubdir)/$(MULTISUBDIR)/$(LIBG2C)
+	rm -f $(DESTDIR)$(libsubdir)/$(MULTISUBDIR)/include/g2c.h $(DESTDIR)$(libsubdir)/$(MULTISUBDIR)/$(LIBG2C)
 	$(MULTIDO) $(FLAGS_TO_PASS) multi-do DO="$@"
 
 mostlyclean:
diff --git a/libiberty/Makefile.in b/libiberty/Makefile.in
index 5642058..a31677e 100644
--- a/libiberty/Makefile.in
+++ b/libiberty/Makefile.in
@@ -148,15 +148,15 @@ INSTALL_DEST = @INSTALL_DEST@
 install: install_to_$(INSTALL_DEST) install-subdir
 
 install_to_libdir: all
-	$(INSTALL_DATA) $(TARGETLIB) $(libdir)$(MULTISUBDIR)/$(TARGETLIB).n
-	( cd $(libdir)$(MULTISUBDIR) ; $(RANLIB) $(TARGETLIB).n )
-	mv -f $(libdir)$(MULTISUBDIR)/$(TARGETLIB).n $(libdir)$(MULTISUBDIR)/$(TARGETLIB)
+	$(INSTALL_DATA) $(TARGETLIB) $(DESTDIR)$(libdir)$(MULTISUBDIR)/$(TARGETLIB).n
+	( cd $(DESTDIR)$(libdir)$(MULTISUBDIR) ; $(RANLIB) $(TARGETLIB).n )
+	mv -f $(DESTDIR)$(libdir)$(MULTISUBDIR)/$(TARGETLIB).n $(DESTDIR)$(libdir)$(MULTISUBDIR)/$(TARGETLIB)
 	@$(MULTIDO) $(FLAGS_TO_PASS) multi-do DO=install
 
 install_to_tooldir: all
-	$(INSTALL_DATA) $(TARGETLIB) $(tooldir)/lib$(MULTISUBDIR)/$(TARGETLIB).n
-	( cd $(tooldir)/lib$(MULTISUBDIR) ; $(RANLIB) $(TARGETLIB).n )
-	mv -f $(tooldir)/lib$(MULTISUBDIR)/$(TARGETLIB).n $(tooldir)/lib$(MULTISUBDIR)/$(TARGETLIB)
+	$(INSTALL_DATA) $(TARGETLIB) $(DESTDIR)$(tooldir)/lib$(MULTISUBDIR)/$(TARGETLIB).n
+	( cd $(DESTDIR)$(tooldir)/lib$(MULTISUBDIR) ; $(RANLIB) $(TARGETLIB).n )
+	mv -f $(DESTDIR)$(tooldir)/lib$(MULTISUBDIR)/$(TARGETLIB).n $(DESTDIR)$(tooldir)/lib$(MULTISUBDIR)/$(TARGETLIB)
 	@$(MULTIDO) $(FLAGS_TO_PASS) multi-do DO=install
 
 # needed-list is used by libstdc++.  NEEDED is the list of functions
diff --git a/libiberty/argv.c b/libiberty/argv.c
index 85c17e9..f596ffd 100644
--- a/libiberty/argv.c
+++ b/libiberty/argv.c
@@ -35,12 +35,8 @@ Boston, MA 02111-1307, USA.  */
 #ifdef __STDC__
 
 #include <stddef.h>
-extern void *memcpy (void *s1, const void *s2, size_t n);	/* 4.11.2.1 */
-extern size_t strlen (const char *s);				/* 4.11.6.3 */
-extern void *malloc (size_t size);				/* 4.10.3.3 */
-extern void *realloc (void *ptr, size_t size);			/* 4.10.3.4 */
-extern void free (void *ptr);					/* 4.10.3.2 */
-extern char *strdup (const char *s);				/* Non-ANSI */
+#include <string.h>
+#include <stdlib.h>
 
 #else	/* !__STDC__ */
 
diff --git a/libiberty/choose-temp.c b/libiberty/choose-temp.c
index b1007bb..be02379 100644
--- a/libiberty/choose-temp.c
+++ b/libiberty/choose-temp.c
@@ -34,6 +34,9 @@ Boston, MA 02111-1307, USA.  */
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
 #ifdef HAVE_SYS_FILE_H
 #include <sys/file.h>   /* May get R_OK, etc. on some systems.  */
 #endif
diff --git a/libiberty/memchr.c b/libiberty/memchr.c
index cce3003..89aa98f 100644
--- a/libiberty/memchr.c
+++ b/libiberty/memchr.c
@@ -50,7 +50,7 @@ memchr (src_void, c, length)
 {
   const unsigned char *src = (const unsigned char *)src_void;
   
-  while (--length >= 0)
+  while (length-- > 0)
   {
     if (*src == c)
      return (PTR)src;
diff --git a/libiberty/objalloc.c b/libiberty/objalloc.c
index 57754a8..5099569 100644
--- a/libiberty/objalloc.c
+++ b/libiberty/objalloc.c
@@ -18,6 +18,8 @@ Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
 #include "ansidecl.h"
+#include "config.h"
+
 #include "objalloc.h"
 
 /* Get a definition for NULL.  */
@@ -33,11 +35,16 @@ Boston, MA 02111-1307, USA.  */
 #include <stddef.h>
 #endif
 
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#else
 /* For systems with larger pointers than ints, this must be declared.  */
 extern PTR malloc PARAMS ((size_t));
 extern void free PARAMS ((PTR));
 #endif
 
+#endif
+
 /* These routines allocate space for an object.  Freeing allocated
    space may or may not free all more recently allocated space.
 
diff --git a/libiberty/pexecute.c b/libiberty/pexecute.c
index 6f6a044..9d928db 100644
--- a/libiberty/pexecute.c
+++ b/libiberty/pexecute.c
@@ -32,6 +32,9 @@ Boston, MA 02111-1307, USA.  */
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
 #define ISSPACE (x) isspace(x)
 #ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
diff --git a/libiberty/setenv.c b/libiberty/setenv.c
index ba35aab..c3c09f1 100644
--- a/libiberty/setenv.c
+++ b/libiberty/setenv.c
@@ -64,7 +64,7 @@ setenv (name, value, replace)
      const char *value;
      int replace;
 {
-  register char **ep;
+  register char **ep = 0;
   register size_t size;
   const size_t namelen = strlen (name);
   const size_t vallen = strlen (value) + 1;
diff --git a/libiberty/sigsetmask.c b/libiberty/sigsetmask.c
index 2a09e6a..db6408d 100644
--- a/libiberty/sigsetmask.c
+++ b/libiberty/sigsetmask.c
@@ -12,6 +12,8 @@
 #include <sys/types.h>
 #include <signal.h>
 
+extern void abort PARAMS ((void)) ATTRIBUTE_NORETURN;
+
 #ifdef SIG_SETMASK
 int
 DEFUN(sigsetmask,(set),
diff --git a/libiberty/strerror.c b/libiberty/strerror.c
index 644cc75..ba837e3 100644
--- a/libiberty/strerror.c
+++ b/libiberty/strerror.c
@@ -13,6 +13,7 @@
    incompatible with our later declaration, perhaps by using const
    attributes.  So we hide the declaration in errno.h (if any) using a
    macro. */
+#define sys_nerr sys_nerr__
 #define sys_errlist sys_errlist__
 #endif
 
@@ -20,19 +21,23 @@
 #include <errno.h>
 
 #ifdef HAVE_SYS_ERRLIST
+#undef sys_nerr
 #undef sys_errlist
 #endif
 
 /*  Routines imported from standard C runtime libraries. */
 
-#ifdef __STDC__
-#include <stddef.h>
-extern void *malloc (size_t size);				/* 4.10.3.3 */
-extern void *memset (void *s, int c, size_t n);			/* 4.11.6.1 */
-#else	/* !__STDC__ */
-extern char *malloc ();		/* Standard memory allocater */
-extern char *memset ();
-#endif	/* __STDC__ */
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#else
+extern PTR malloc ();
+#endif
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#else
+extern PTR memset ();
+#endif
 
 #ifndef MAX
 #  define MAX(a,b) ((a) > (b) ? (a) : (b))
diff --git a/libiberty/strsignal.c b/libiberty/strsignal.c
index c7bb10c..5625323 100644
--- a/libiberty/strsignal.c
+++ b/libiberty/strsignal.c
@@ -23,14 +23,17 @@
 
 /*  Routines imported from standard C runtime libraries. */
 
-#ifdef __STDC__
-#include <stddef.h>
-extern void *malloc (size_t size);				/* 4.10.3.3 */
-extern void *memset (void *s, int c, size_t n);			/* 4.11.6.1 */
-#else	/* !__STDC__ */
-extern char *malloc ();		/* Standard memory allocater */
-extern char *memset ();
-#endif	/* __STDC__ */
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#else
+extern PTR malloc ();
+#endif
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#else
+extern PTR memset ();
+#endif
 
 /* Undefine the macro we used to hide the definition of sys_siglist
    found in the system header files.  */
diff --git a/libiberty/vasprintf.c b/libiberty/vasprintf.c
index eeb80e6..138806b 100644
--- a/libiberty/vasprintf.c
+++ b/libiberty/vasprintf.c
@@ -18,21 +18,31 @@ License along with libiberty; see the file COPYING.LIB.  If
 not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
-#ifdef __STDC__
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <ansidecl.h>
+#ifdef ANSI_PROTOTYPES
 #include <stdarg.h>
 #else
 #include <varargs.h>
 #endif
 #include <stdio.h>
 #include <string.h>
-#include <ansidecl.h>
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#else
+extern unsigned long strtoul ();
+extern PTR malloc ();
+#endif
+#include "libiberty.h"
 
 #ifdef TEST
 int global_total_width;
 #endif
 
-unsigned long strtoul ();
-char *malloc ();
+
+static int int_vasprintf PARAMS ((char **, const char *, va_list *));
 
 static int
 int_vasprintf (result, format, args)
@@ -60,7 +70,7 @@ int_vasprintf (result, format, args)
 	      total_width += abs (va_arg (ap, int));
 	    }
 	  else
-	    total_width += strtoul (p, &p, 10);
+	    total_width += strtoul (p, (char **) &p, 10);
 	  if (*p == '.')
 	    {
 	      ++p;
@@ -70,7 +80,7 @@ int_vasprintf (result, format, args)
 		  total_width += abs (va_arg (ap, int));
 		}
 	      else
-	      total_width += strtoul (p, &p, 10);
+	      total_width += strtoul (p, (char **) &p, 10);
 	    }
 	  while (strchr ("hlL", *p))
 	    ++p;
@@ -131,33 +141,33 @@ vasprintf (result, format, args)
 }
 
 #ifdef TEST
-void
-checkit
-#ifdef __STDC__
-     (const char* format, ...)
-#else
-     (va_alist)
-     va_dcl
-#endif
+static void checkit PARAMS ((const char *, ...));
+
+static void
+checkit VPARAMS ((const char* format, ...))
 {
   va_list args;
   char *result;
+#ifndef ANSI_PROTOTYPES
+  const char *format;
+#endif
 
-#ifdef __STDC__
-  va_start (args, format);
-#else
-  char *format;
-  va_start (args);
-  format = va_arg (args, char *);
+  VA_START (args, format);
+
+#ifndef ANSI_PROTOTYPES
+  format = va_arg (args, const char *);
 #endif
+
   vasprintf (&result, format, args);
-  if (strlen (result) < global_total_width)
+  if (strlen (result) < (size_t) global_total_width)
     printf ("PASS: ");
   else
     printf ("FAIL: ");
   printf ("%d %s\n", global_total_width, result);
 }
 
+extern int main PARAMS ((void));
+
 int
 main ()
 {
@@ -168,5 +178,7 @@ main ()
   checkit ("%s", "jjjjjjjjjiiiiiiiiiiiiiiioooooooooooooooooppppppppppppaa\n\
 777777777777777777333333333333366666666666622222222222777777777777733333");
   checkit ("%f%s%d%s", 1.0, "foo", 77, "asdjffffffffffffffiiiiiiiiiiixxxxx");
+
+  return 0;
 }
 #endif /* TEST */
diff --git a/libiberty/vfork.c b/libiberty/vfork.c
index 86c4591..5e87721 100644
--- a/libiberty/vfork.c
+++ b/libiberty/vfork.c
@@ -1,6 +1,10 @@
 /* Emulate vfork using just plain fork, for systems without a real vfork.
    This function is in the public domain. */
 
+#include "ansidecl.h"
+
+extern int fork PARAMS ((void));
+
 int
 vfork ()
 {
diff --git a/libiberty/xexit.c b/libiberty/xexit.c
index 431bbe0..e8b1ed1 100644
--- a/libiberty/xexit.c
+++ b/libiberty/xexit.c
@@ -17,10 +17,15 @@ License along with libiberty; see the file COPYING.LIB.  If not, write
 to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
-#include "ansidecl.h"
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <stdio.h>
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
 #include "libiberty.h"
 
-#include <stdio.h>
 
 /* This variable is set by xatexit if it is called.  This way, xmalloc
    doesn't drag xatexit into the link.  */
diff --git a/libio/Makefile.in b/libio/Makefile.in
index 1d4123b..4342beb 100644
--- a/libio/Makefile.in
+++ b/libio/Makefile.in
@@ -113,19 +113,19 @@ install:
 	if [ -z "$(MULTISUBDIR)" ]; then \
 	  if [ "$(_G_CONFIG_H)" != "" ]; then \
 	    if [ x$(enable_version_specific_runtime_libs) = xyes ]; then \
-	      rm -f $(gxx_include_dir)/_G_config.h ; \
-	      $(INSTALL_DATA) _G_config.h $(gxx_include_dir)/_G_config.h || exit 1; \
+	      rm -f $(DESTDIR)$(gxx_include_dir)/_G_config.h ; \
+	      $(INSTALL_DATA) _G_config.h $(DESTDIR)$(gxx_include_dir)/_G_config.h || exit 1; \
 	    else \
-	      rm -f $(tooldir)/include/_G_config.h ; \
-	      $(INSTALL_DATA) _G_config.h $(tooldir)/include/_G_config.h || exit 1; \
+	      rm -f $(DESTDIR)$(tooldir)/include/_G_config.h ; \
+	      $(INSTALL_DATA) _G_config.h $(DESTDIR)$(tooldir)/include/_G_config.h || exit 1; \
 	    fi; \
 	  else true; \
 	  fi ; \
 	  cd $(srcdir); \
 	  for FILE in $(USER_INCLUDES); do if [ $$FILE != _G_config.h ]; then \
-	    rm -f $(gxx_include_dir)/$$FILE ; \
-	    $(INSTALL_DATA) $$FILE $(gxx_include_dir)/$$FILE ; \
-	    chmod a-x $(gxx_include_dir)/$$FILE ; \
+	    rm -f $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
+	    $(INSTALL_DATA) $$FILE $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
+	    chmod a-x $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
 	  else true; fi; done ; \
 	else true; \
 	fi
diff --git a/libobjc/Makefile.in b/libobjc/Makefile.in
index e1de9ae..cf8a04e 100644
--- a/libobjc/Makefile.in
+++ b/libobjc/Makefile.in
@@ -93,6 +93,7 @@ FLAGS_TO_PASS = \
 	"CC=$(CC)" \
 	"CFLAGS=$(CFLAGS)" \
 	"LIBCFLAGS=$(LIBCFLAGS)" \
+	"DESTDIR=$(DESTDIR)" \
 	"EXTRA_OFILES=$(EXTRA_OFILES)" \
 	"HDEFINES=$(HDEFINES)" \
 	"INSTALL=$(INSTALL)" \
@@ -271,33 +272,33 @@ install: install-libs copy-headers
 
 install-libs: installdirs
 	-if test -f libobjc.a ; then \
-	  rm -f $(libsubdir)/libobjc.a; \
-	  $(INSTALL_DATA) libobjc.a $(libsubdir)/libobjc.a; \
-	  chmod a-x $(libsubdir)/libobjc.a; \
+	  rm -f $(DESTDIR)$(libsubdir)/libobjc.a; \
+	  $(INSTALL_DATA) libobjc.a $(DESTDIR)$(libsubdir)/libobjc.a; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/libobjc.a; \
 	else true; fi
 	-if test -f libobjc_gc.a ; then \
-	  rm -f $(libsubdir)/libobjc_gc.a; \
-	  $(INSTALL_DATA) libobjc_gc.a $(libsubdir)/libobjc_gc.a; \
-	  chmod a-x $(libsubdir)/libobjc_gc.a; \
+	  rm -f $(DESTDIR)$(libsubdir)/libobjc_gc.a; \
+	  $(INSTALL_DATA) libobjc_gc.a $(DESTDIR)$(libsubdir)/libobjc_gc.a; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/libobjc_gc.a; \
 	else true; fi
 	-if test -f libobjc_s.a ; then \
-	  rm -f $(libsubdir)/libobjc_s.a; \
-	  $(INSTALL_DATA) libobjc_s.a $(libsubdir)/libobjc_s.a; \
-	  chmod a-x $(libsubdir)/libobjc_s.a; \
+	  rm -f $(DESTDIR)$(libsubdir)/libobjc_s.a; \
+	  $(INSTALL_DATA) libobjc_s.a $(DESTDIR)$(libsubdir)/libobjc_s.a; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/libobjc_s.a; \
 	else true; fi
 	  -if test -f libobjc.dll ; then \
-	  rm -f $(bindir)/libobjc.dll; \
-	  $(INSTALL_DATA) libobjc.dll $(bindir)/libobjc.dll; \
+	  rm -f $(DESTDIR)$(bindir)/libobjc.dll; \
+	  $(INSTALL_DATA) libobjc.dll $(DESTDIR)$(bindir)/libobjc.dll; \
 	else true; fi
 
 # Copy Objective C headers to installation include directory.
 copy-headers:
-	-rm -rf $(incinstalldir)/objc
-	-mkdir $(incinstalldir)/objc
+	-rm -rf $(DESTDIR)$(incinstalldir)/objc
+	-mkdir $(DESTDIR)$(incinstalldir)/objc
 	for file in $(OBJC_H); do \
 	  realfile=$(srcdir)/objc/$${file}; \
-	  cp $${realfile} $(incinstalldir)/objc; \
-	  chmod a+r $(incinstalldir)/objc/$${file}; \
+	  cp $${realfile} $(DESTDIR)$(incinstalldir)/objc; \
+	  chmod a+r $(DESTDIR)$(incinstalldir)/objc/$${file}; \
 	done
 
 check uninstall install-strip dist installcheck installdirs:
diff --git a/libstdc++/Makefile.in b/libstdc++/Makefile.in
index f13eddc..bce932d 100644
--- a/libstdc++/Makefile.in
+++ b/libstdc++/Makefile.in
@@ -263,24 +263,24 @@ install:
 	if [ -z "$(MULTISUBDIR)" ]; then \
 	  cd $(srcdir); \
 	  for FILE in $(HEADERS); do \
-	    rm -f $(gxx_include_dir)/$$FILE ; \
+	    rm -f $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
 	    if [ -f stl/$$FILE ]; then \
-	      $(INSTALL_DATA) stl/$$FILE $(gxx_include_dir)/$$FILE ; \
+	      $(INSTALL_DATA) stl/$$FILE $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
 	    else \
-	      $(INSTALL_DATA) $$FILE $(gxx_include_dir)/$$FILE ; \
+	      $(INSTALL_DATA) $$FILE $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
 	    fi ; \
-	    chmod a-x $(gxx_include_dir)/$$FILE ; \
+	    chmod a-x $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
 	  done ; \
 	  for FILE in *.h std/*.h std/*.cc std/*.tcc; do \
-	    rm -f $(gxx_include_dir)/$$FILE ; \
-	    $(INSTALL_DATA) $$FILE $(gxx_include_dir)/$$FILE ; \
-	    chmod a-x $(gxx_include_dir)/$$FILE ; \
+	    rm -f $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
+	    $(INSTALL_DATA) $$FILE $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
+	    chmod a-x $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
 	  done ; \
 	  cd stl; \
 	  for FILE in *.h; do \
-	    rm -f $(gxx_include_dir)/$$FILE ; \
-	    $(INSTALL_DATA) $$FILE $(gxx_include_dir)/$$FILE ; \
-	    chmod a-x $(gxx_include_dir)/$$FILE ; \
+	    rm -f $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
+	    $(INSTALL_DATA) $$FILE $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
+	    chmod a-x $(DESTDIR)$(gxx_include_dir)/$$FILE ; \
 	  done ; \
 	else true ; \
 	fi
@@ -312,50 +312,50 @@ install:
 	    RELINSTALLDIR=../$${RELINSTALLDIR}$(target_alias)/lib/;; \
 	  esac; \
 	fi; \
-	rm -f $${INSTALLLINKDIR}$(MULTISUBDIR)/$(SHLINK) ; \
-	rm -f $${INSTALLLINKDIR}$(MULTISUBDIR)/$(ARLINK) ; \
+	rm -f $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$(SHLINK) ; \
+	rm -f $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$(ARLINK) ; \
 	for FILE in $(LIBS) ; do \
-	  rm -f $${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
+	  rm -f $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
 	  if [ $$FILE = $(SHLINK) ] ; then \
-	    if [ -f $${INSTALLDIR}/$(MSHLINK) ]; then \
-	      rm -f $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
-	      $(LN_S) $${RELINSTALLDIR}$(MSHLINK) $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE \
-		|| cp $${RELINSTALLDIR}$(MSHLINK) $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
+	    if [ -f $(DESTDIR)$${INSTALLDIR}/$(MSHLINK) ]; then \
+	      rm -f $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
+	      $(LN_S) $${RELINSTALLDIR}$(MSHLINK) $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE \
+		|| cp $${RELINSTALLDIR}$(MSHLINK) $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
 	    else \
-	      rm -f $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
-	      $(LN_S) $${RELINSTALLDIR}$(SHLIB) $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE \
-		|| cp $${RELINSTALLDIR}$(SHLIB) $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
+	      rm -f $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
+	      $(LN_S) $${RELINSTALLDIR}$(SHLIB) $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE \
+		|| cp $${RELINSTALLDIR}$(SHLIB) $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
 	    fi; \
 	  elif [ $$FILE = $(ARLINK) ] ; then \
-	    if [ -f $${INSTALLDIR}/$(MARLINK) ]; then \
-	      rm -f $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
-	      $(LN_S) $${RELINSTALLDIR}$(MARLINK) $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE \
-		|| cp $${RELINSTALLDIR}$(MARLINK) $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
+	    if [ -f $(DESTDIR)$${INSTALLDIR}/$(MARLINK) ]; then \
+	      rm -f $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
+	      $(LN_S) $${RELINSTALLDIR}$(MARLINK) $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE \
+		|| cp $${RELINSTALLDIR}$(MARLINK) $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
 	    else \
-	      rm -f $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
-	      $(LN_S) $${RELINSTALLDIR}$(ARLIB) $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE \
-		|| cp $${RELINSTALLDIR}$(ARLIB) $${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
+	      rm -f $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
+	      $(LN_S) $${RELINSTALLDIR}$(ARLIB) $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE \
+		|| cp $${RELINSTALLDIR}$(ARLIB) $(DESTDIR)$${INSTALLLINKDIR}$(MULTISUBDIR)/$$FILE ; \
 	    fi; \
 	  elif [ $$FILE = mshlink ]; then \
 	    for FILE in $(MSHLINK) ; do \
-	      rm -f $${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
-	      $(LN_S) $(SHLIB) $${INSTALLDIR}$(MULTISUBDIR)/$$FILE \
-		|| cp $(SHLIB) $${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
+	      rm -f $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
+	      $(LN_S) $(SHLIB) $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE \
+		|| cp $(SHLIB) $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
 	    done; \
 	  elif [ $$FILE = marlink ]; then \
 	    for FILE in $(MARLINK) ; do \
-	      rm -f $${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
-	      $(LN_S) $(ARLIB) $${INSTALLDIR}$(MULTISUBDIR)/$$FILE \
-		|| cp $(ARLIB) $${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
+	      rm -f $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
+	      $(LN_S) $(ARLIB) $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE \
+		|| cp $(ARLIB) $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
 	    done; \
 	  elif [ $$FILE = $(SHLIB) ]; then \
-	    $(INSTALL_PROGRAM) $$FILE $${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
+	    $(INSTALL_PROGRAM) $$FILE $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
 	    : On the HP, shared libraries must be mode 555. ;\
-	    chmod 555 $${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
+	    chmod 555 $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
 	  else \
-	    $(INSTALL_DATA) $$FILE $${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
-	    $(RANLIB) $${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
-	    chmod a-x $${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
+	    $(INSTALL_DATA) $$FILE $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
+	    $(RANLIB) $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
+	    chmod a-x $(DESTDIR)$${INSTALLDIR}$(MULTISUBDIR)/$$FILE ; \
 	  fi ; \
 	done
 	@rootme=`pwd`/ ; export rootme ; \
diff --git a/libstdc++/sstream b/libstdc++/sstream
index 45393b1..e421a80 100644
--- a/libstdc++/sstream
+++ b/libstdc++/sstream
@@ -106,7 +106,7 @@ namespace std
 	  if (c != EOF)
 	    {
 	      streamsize old_stream_len = stream_len;
-	      stream_len += 1;
+	      stream_len += stream_len + 1;
 	      char_type* new_stream = new char_type[stream_len];
 	      memcpy(new_stream, stream, old_stream_len);
 	      delete[] stream;
diff --git a/libstdc++/std/bastring.cc b/libstdc++/std/bastring.cc
index f86f6d3..c37941a 100644
--- a/libstdc++/std/bastring.cc
+++ b/libstdc++/std/bastring.cc
@@ -116,19 +116,19 @@ template <class charT, class traits, class Allocator>
 basic_string <charT, traits, Allocator>&
 basic_string <charT, traits, Allocator>::
 replace (size_type pos1, size_type n1,
-	 const basic_string& str, size_type pos2, size_type n2)
+	 const basic_string& _str, size_type pos2, size_type n2)
 {
-  const size_t len2 = str.length ();
+  const size_t len2 = _str.length ();
 
   if (pos1 == 0 && n1 >= length () && pos2 == 0 && n2 >= len2)
-    return operator= (str);
+    return operator= (_str);
 
   OUTOFRANGE (pos2 > len2);
 
   if (n2 > len2 - pos2)
     n2 = len2 - pos2;
 
-  return replace (pos1, n1, str.data () + pos2, n2);
+  return replace (pos1, n1, _str.data () + pos2, n2);
 }
 
 template <class charT, class traits, class Allocator>
@@ -394,21 +394,21 @@ find_last_not_of (charT c, size_type pos) const
 
 template <class charT, class traits, class Allocator>
 int basic_string <charT, traits, Allocator>::
-compare (const basic_string& str, size_type pos, size_type n) const
+compare (const basic_string& _str, size_type pos, size_type n) const
 {
   OUTOFRANGE (pos > length ());
 
   size_t rlen = length () - pos;
   if (rlen > n)
     rlen = n;
-  if (rlen > str.length ())
-    rlen = str.length ();
-  int r = traits::compare (data () + pos, str.data (), rlen);
+  if (rlen > _str.length ())
+    rlen = _str.length ();
+  int r = traits::compare (data () + pos, _str.data (), rlen);
   if (r != 0)
     return r;
   if (rlen == n)
     return 0;
-  return (length () - pos) - str.length ();
+  return (length () - pos) - _str.length ();
 }
 
 template <class charT, class traits, class Allocator>
@@ -476,7 +476,7 @@ getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
 {
   if (is.ipfx1 ())
     {
-      _IO_size_t count = 0;
+      _IO_size_t _count = 0;
       streambuf *sb = is.rdbuf ();
       s.resize (0);
 
@@ -485,13 +485,13 @@ getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
 	  int ch = sb->sbumpc ();
 	  if (ch == EOF)
 	    {
-	      is.setstate (count == 0
+	      is.setstate (_count == 0
 			   ? (ios::failbit|ios::eofbit)
 			   : ios::eofbit);
 	      break;
 	    }
 
-	  ++count;
+	  ++_count;
 
 	  if (ch == delim)
 	    break;
@@ -507,7 +507,7 @@ getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
     }
 
   // We need to be friends with istream to do this.
-  // is._gcount = count;
+  // is._gcount = _count;
   is.isfx ();
 
   return is;
diff --git a/libstdc++/std/bastring.h b/libstdc++/std/bastring.h
index bbe8730..9479d76 100644
--- a/libstdc++/std/bastring.h
+++ b/libstdc++/std/bastring.h
@@ -169,9 +169,9 @@ public:
     }
 
   explicit basic_string (): dat (nilRep.grab ()) { }
-  basic_string (const basic_string& str): dat (str.rep ()->grab ()) { }
-  basic_string (const basic_string& str, size_type pos, size_type n = npos)
-    : dat (nilRep.grab ()) { assign (str, pos, n); }
+  basic_string (const basic_string& _str): dat (_str.rep ()->grab ()) { }
+  basic_string (const basic_string& _str, size_type pos, size_type n = npos)
+    : dat (nilRep.grab ()) { assign (_str, pos, n); }
   basic_string (const charT* s, size_type n)
     : dat (nilRep.grab ()) { assign (s, n); }
   basic_string (const charT* s)
@@ -191,9 +191,9 @@ public:
 
   void swap (basic_string &s) { charT *d = dat; dat = s.dat; s.dat = d; }
 
-  basic_string& append (const basic_string& str, size_type pos = 0,
+  basic_string& append (const basic_string& _str, size_type pos = 0,
 			size_type n = npos)
-    { return replace (length (), 0, str, pos, n); }
+    { return replace (length (), 0, _str, pos, n); }
   basic_string& append (const charT* s, size_type n)
     { return replace (length (), 0, s, n); }
   basic_string& append (const charT* s)
@@ -335,7 +335,8 @@ private:
 
 public:
   const charT* c_str () const
-    { if (length () == 0) return ""; terminate (); return data (); }
+    { const charT* null_str = ""; 
+      if (length () == 0) return null_str; terminate (); return data (); }
   void resize (size_type n, charT c);
   void resize (size_type n)
     { resize (n, eos ()); }
@@ -346,8 +347,8 @@ public:
   size_type find (const basic_string& str, size_type pos = 0) const
     { return find (str.data(), pos, str.length()); }
   size_type find (const charT* s, size_type pos, size_type n) const;
-  size_type find (const charT* s, size_type pos = 0) const
-    { return find (s, pos, traits::length (s)); }
+  size_type find (const charT* _s, size_type pos = 0) const
+    { return find (_s, pos, traits::length (_s)); }
   size_type find (charT c, size_type pos = 0) const;
 
   size_type rfind (const basic_string& str, size_type pos = npos) const
@@ -469,36 +470,36 @@ inline basic_string <charT, traits, Allocator>
 operator+ (const basic_string <charT, traits, Allocator>& lhs,
 	   const basic_string <charT, traits, Allocator>& rhs)
 {
-  basic_string <charT, traits, Allocator> str (lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
 inline basic_string <charT, traits, Allocator>
 operator+ (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
 {
-  basic_string <charT, traits, Allocator> str (lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
 inline basic_string <charT, traits, Allocator>
 operator+ (charT lhs, const basic_string <charT, traits, Allocator>& rhs)
 {
-  basic_string <charT, traits, Allocator> str (1, lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (1, lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
 inline basic_string <charT, traits, Allocator>
 operator+ (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
 {
-  basic_string <charT, traits, Allocator> str (lhs);
-  str.append (rhs);
-  return str;
+  basic_string <charT, traits, Allocator> _str (lhs);
+  _str.append (rhs);
+  return _str;
 }
 
 template <class charT, class traits, class Allocator>
diff --git a/libstdc++/stl/stl_alloc.h b/libstdc++/stl/stl_alloc.h
index 208309a..1647e83 100644
--- a/libstdc++/stl/stl_alloc.h
+++ b/libstdc++/stl/stl_alloc.h
@@ -38,7 +38,7 @@
 // The allocation primitives are intended to allocate individual objects,
 // not larger arenas as with the original STL allocators.
 
-#if 0
+#ifdef __STL_USE_EXCEPTIONS
 #   include <new>
 #   define __THROW_BAD_ALLOC throw bad_alloc()
 #elif !defined(__THROW_BAD_ALLOC)
diff --git a/libstdc++/stl/stl_deque.h b/libstdc++/stl/stl_deque.h
index 24a8bfb..587ab8b 100644
--- a/libstdc++/stl/stl_deque.h
+++ b/libstdc++/stl/stl_deque.h
@@ -1052,7 +1052,7 @@ deque<_Tp,_Alloc,__bufsize>::erase(iterator __first, iterator __last)
       copy_backward(_M_start, __first, __last);
       iterator __new_start = _M_start + __n;
       destroy(_M_start, __new_start);
-      _M_destroy_nodes(__new_start._M_node, _M_start._M_node);
+      _M_destroy_nodes(_M_start._M_node, __new_start._M_node);  /* fixed per http://gcc.gnu.org/ml/libstdc++/2001-11/msg00139.html */
       _M_start = __new_start;
     }
     else {
diff --git a/libstdc++/stl/stl_hashtable.h b/libstdc++/stl/stl_hashtable.h
index 78b36c1..c0354fa 100644
--- a/libstdc++/stl/stl_hashtable.h
+++ b/libstdc++/stl/stl_hashtable.h
@@ -1014,14 +1014,14 @@ void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
   __STL_TRY {
     for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {
       if (const _Node* __cur = __ht._M_buckets[__i]) {
-        _Node* __copy = _M_new_node(__cur->_M_val);
-        _M_buckets[__i] = __copy;
+        _Node* ___copy = _M_new_node(__cur->_M_val);
+        _M_buckets[__i] = ___copy;
 
         for (_Node* __next = __cur->_M_next; 
              __next; 
              __cur = __next, __next = __cur->_M_next) {
-          __copy->_M_next = _M_new_node(__next->_M_val);
-          __copy = __copy->_M_next;
+          ___copy->_M_next = _M_new_node(__next->_M_val);
+          ___copy = ___copy->_M_next;
         }
       }
     }
diff --git a/libstdc++/string b/libstdc++/string
index fa6f1ab..523f435 100644
--- a/libstdc++/string
+++ b/libstdc++/string
@@ -7,7 +7,9 @@
 
 extern "C++" {
 typedef basic_string <char> string;
-// typedef basic_string <wchar_t> wstring;
+#ifdef __ENABLE_WSTRING
+typedef basic_string <wchar_t> wstring;
+#endif
 } // extern "C++"
 
 #endif
