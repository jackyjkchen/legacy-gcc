diff --git a/config/gxx-include-dir.m4 b/config/gxx-include-dir.m4
index 4f54d427f..74bb09ffe 100644
--- a/config/gxx-include-dir.m4
+++ b/config/gxx-include-dir.m4
@@ -8,15 +8,26 @@ dnl If you change the default here, you'll need to change the gcc and
 dnl libstdc++-v3 subdirectories too.
 AC_DEFUN([TL_AC_GXX_INCLUDE_DIR],
 [
+case "$host" in
+  *-msdosdjgpp*)
+    libstdcxx_incdir_base=cxx
+    gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+    ;;
+  *)
+    libstdcxx_incdir_base=c++
+    gcc_version_dir='$(gcc_version)'
+    ;;
+esac
+
 case "${with_gxx_include_dir}" in
   yes)
     AC_MSG_ERROR([--with-gxx-include-dir=[[dir]] requires a directory])
     ;;
   no | "")
     case "${enable_version_specific_runtime_libs}" in
-      yes) gxx_include_dir='$(libsubdir)/include/c++' ;;
+      yes) gxx_include_dir='$(libsubdir)/include/'${libstdcxx_incdir_base} ;;
       *)
-	libstdcxx_incdir='c++/$(gcc_version)'
+	libstdcxx_incdir=${libstdcxx_incdir_base}/${gcc_version_dir}
 	gxx_include_dir='include/$(libstdcxx_incdir)'
 	if test -n "$with_cross_host" && 
            test x"$with_cross_host" != x"no"; then	
diff --git a/fixincludes/Makefile.in b/fixincludes/Makefile.in
index b9857b957..3846e952d 100644
--- a/fixincludes/Makefile.in
+++ b/fixincludes/Makefile.in
@@ -41,6 +41,8 @@ VPATH = $(srcdir)
 libdir = @libdir@
 # Directory in which GCC puts its executables.
 libexecdir = @libexecdir@
+# GCC version for subdirectory names (editted if host requires it)
+gcc_version_dir = @gcc_version_dir@
 
 # End of variables for you to override.
 
@@ -52,9 +54,9 @@ target_noncanonical:=@target_noncanonical@
 gcc_version := $(shell cat $(srcdir)/../gcc/BASE-VER)
 
 # Directory in which the compiler finds libraries etc.
-libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)
+libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version_dir)
 # Directory in which the compiler finds executables
-libexecsubdir = $(libexecdir)/gcc/$(target_noncanonical)/$(gcc_version)
+libexecsubdir = $(libexecdir)/gcc/$(target_noncanonical)/$(gcc_version_dir)
 # Where our executable files go
 itoolsdir = $(libexecsubdir)/install-tools
 # Where our data files go
diff --git a/fixincludes/configure b/fixincludes/configure
index 7b7109a93..0122c40c7 100755
--- a/fixincludes/configure
+++ b/fixincludes/configure
@@ -590,6 +590,7 @@ ac_includes_default="\
 
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+gcc_version_dir
 MAINT
 EGREP
 GREP
@@ -5172,6 +5173,19 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+case $host in
+	i?86-*-msdosdjgpp*)
+		gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+		;;
+
+	* )
+		gcc_version_dir='$(gcc_version)'
+		;;
+esac
+
+
 ac_config_headers="$ac_config_headers config.h"
 
 ac_config_files="$ac_config_files Makefile mkheaders.almost:mkheaders.in"
diff --git a/fixincludes/configure.ac b/fixincludes/configure.ac
index 2c488e703..1cb43c07e 100644
--- a/fixincludes/configure.ac
+++ b/fixincludes/configure.ac
@@ -112,6 +112,19 @@ AC_SUBST(MAINT)
 AC_DEFINE_UNQUOTED([SED_PROGRAM], "${SED}",
    [Defined to the best working sed program on the host system])
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+[case $host in
+	i?86-*-msdosdjgpp*)
+		gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+		;;
+
+	* )
+		gcc_version_dir='$(gcc_version)'
+		;;
+esac]
+AC_SUBST(gcc_version_dir)
+
 AC_CONFIG_HEADERS(config.h, [echo timestamp > stamp-h])
 AC_CONFIG_FILES(Makefile mkheaders.almost:mkheaders.in)
 AC_OUTPUT
diff --git a/fixincludes/fixincl.c b/fixincludes/fixincl.c
index 9f399abdd..33bcf1cb4 100644
--- a/fixincludes/fixincl.c
+++ b/fixincludes/fixincl.c
@@ -829,7 +829,7 @@ fix_with_system (tFixDesc* p_fixd,
       /*
        *  Now add the fix number and file names that may be needed
        */
-      sprintf (pz_scan, " %ld '%s' '%s'",  (long) (p_fixd - fixDescList),
+      sprintf (pz_scan, " %ld '%s' '%s' '%s'",  (long) (p_fixd - fixDescList),
 	       pz_fix_file, pz_file_source, pz_temp_file);
     }
   else /* NOT an "internal" fix: */
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index e0b952ffd..4f9f9ac3c 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -618,6 +618,7 @@ man7ext = .7
 objext = .o
 exeext = @host_exeext@
 build_exeext = @build_exeext@
+libstdcxx_incdir_base=@libstdcxx_incdir_base@
 
 # Directory in which to put man pages.
 mandir = @mandir@
@@ -4157,7 +4158,7 @@ s-fixinc_list : $(GCC_PASSES)
 # Abort if no system headers available, unless building a crosscompiler.
 # FIXME: abort unless building --without-headers would be more accurate and less ugly
 stmp-fixinc: gsyslimits.h macro_list fixinc_list \
-  $(build_objdir)/fixincludes/fixincl \
+  $(build_objdir)/fixincludes/fixincl$(EXEEXT) \
   $(build_objdir)/fixincludes/fixinc.sh
 	rm -rf include-fixed; mkdir include-fixed
 	-chmod a+rx include-fixed
diff --git a/gcc/ada/adaint.c b/gcc/ada/adaint.c
index 855ce3489..9485d5478 100644
--- a/gcc/ada/adaint.c
+++ b/gcc/ada/adaint.c
@@ -84,7 +84,18 @@
 #include "version.h"
 #endif
 
-#if defined (__MINGW32__)
+#if defined (__DJGPP__)
+
+/* For isalpha-like tests in the compiler, we're expected to resort to
+   safe-ctype.h/ISALPHA.  This isn't available for the runtime library
+   build, so we fallback on ctype.h/isalpha there.  */
+
+#ifdef IN_RTS
+#include <ctype.h>
+#define ISALPHA isalpha
+#endif
+
+#elif defined (__MINGW32__)
 
 #if defined (RTX)
 #include <windows.h>
@@ -195,7 +206,7 @@ extern int LIB$GETSYI (int *, unsigned int *);
 #include <utime.h>
 #endif
 
-#if defined (_WIN32)
+#if defined(MSDOS) || defined (_WIN32)
 #include <process.h>
 #endif
 
@@ -477,7 +488,10 @@ __gnat_readlink (char *path ATTRIBUTE_UNUSED,
 		 char *buf ATTRIBUTE_UNUSED,
 		 size_t bufsiz ATTRIBUTE_UNUSED)
 {
-#if defined (_WIN32) || defined (VMS) \
+#if defined (__DJGPP__) && (__DJGPP__>2 || (__DJGPP__==2 && __DJGPP_MINOR__>=4))
+  /* Symbolic links are supported for DJGPP beginning with version 2.04pre */
+  return readlink (path, buf, bufsiz);
+#elif defined(MSDOS) || defined (_WIN32) || defined (VMS)     \
     || defined(__vxworks) || defined (__nucleus__)
   return -1;
 #else
@@ -493,7 +507,10 @@ int
 __gnat_symlink (char *oldpath ATTRIBUTE_UNUSED,
 		char *newpath ATTRIBUTE_UNUSED)
 {
-#if defined (_WIN32) || defined (VMS) \
+#if defined (__DJGPP__) && (__DJGPP__>2 || (__DJGPP__==2 && __DJGPP_MINOR__>=4))
+  /* Symbolic links are supported for DJGPP beginning with version 2.04pre */
+  return symlink (oldpath, newpath);
+#elif defined(MSDOS) || defined (_WIN32) || defined (VMS)   \
     || defined(__vxworks) || defined (__nucleus__)
   return -1;
 #else
@@ -576,7 +593,13 @@ __gnat_try_lock (char *dir, char *file)
 int
 __gnat_get_maximum_file_name_length (void)
 {
-#if defined (VMS)
+#if defined (MSDOS)
+#ifdef __DJGPP__
+  return (_use_lfn(".")) ? -1 : 8;
+#else
+  return 8;
+#endif
+#elif defined (VMS)
   if (getenv ("GNAT$EXTENDED_FILE_SPECIFICATIONS"))
     return -1;
   else
@@ -598,7 +621,7 @@ __gnat_get_file_names_case_sensitive (void)
       && sensitive[1] == '\0')
     return sensitive[0] - '0';
   else
-#if defined (VMS) || defined (WINNT) || defined (__APPLE__)
+#if defined (VMS) || defined (MSDOS) || defined (WINNT) || defined (__APPLE__)
     return 0;
 #else
     return 1;
@@ -610,7 +633,7 @@ __gnat_get_file_names_case_sensitive (void)
 int
 __gnat_get_env_vars_case_sensitive (void)
 {
-#if defined (VMS) || defined (WINNT)
+#if defined (VMS) || defined (MSDOS) || defined (WINNT)
  return 0;
 #else
  return 1;
@@ -620,7 +643,11 @@ __gnat_get_env_vars_case_sensitive (void)
 char
 __gnat_get_default_identifier_character_set (void)
 {
+#if defined (MSDOS)
+  return 'p';
+#else
   return '1';
+#endif
 }
 
 /* Return the current working directory.  */
@@ -1797,7 +1824,7 @@ __gnat_is_absolute_path (char *name, int length)
 #else
   return (length != 0) &&
      (*name == '/' || *name == DIR_SEPARATOR
-#if defined (WINNT)
+#if defined(MSDOS) || defined (WINNT)
       || (length > 1 && ISALPHA (name[0]) && name[1] == ':')
 #endif
 	  );
@@ -2262,6 +2289,8 @@ __gnat_is_symbolic_link_attr (char* name, struct file_attributes* attr)
 #if defined (__vxworks) || defined (__nucleus__)
       attr->symbolic_link = 0;
 
+#elif defined (__DJGPP__) && (__DJGPP__ < 2 || (__DJGPP__==2) && (__DJGPP_MINOR__<4))
+      return 0;
 #elif defined (_AIX) || defined (__APPLE__) || defined (__unix__)
       int ret;
       GNAT_STRUCT_STAT statbuf;
@@ -2300,7 +2329,7 @@ __gnat_portable_spawn (char *args[])
 #if defined (__vxworks) || defined(__nucleus__) || defined(RTX)
   return -1;
 
-#elif defined (_WIN32)
+#elif defined (MSDOS) || defined (_WIN32)
   /* args[0] must be quotes as it could contain a full pathname with spaces */
   char *args_0 = args[0];
   args[0] = (char *)xmalloc (strlen (args_0) + 3);
@@ -2408,6 +2437,7 @@ __gnat_number_of_cpus (void)
   status = LIB$GETSYI (&code, &res);
   if ((status & 1) != 0)
     cores = res;
+#elif defined (MSDOS)
 #endif
 
   return cores;
@@ -2619,6 +2649,20 @@ __gnat_portable_no_block_spawn (char *args[])
 #if defined (__vxworks) || defined (__nucleus__) || defined (RTX)
   return -1;
 
+#elif defined(MSDOS)
+  /* ??? For PC machines I (Franco) don't know the system calls to implement
+     this routine. So I'll fake it as follows. This routine will behave
+     exactly like the blocking portable_spawn and will systematically return
+     a pid of 0 unless the spawned task did not complete successfully, in
+     which case we return a pid of -1.  To synchronize with this the
+     portable_wait below systematically returns a pid of 0 and reports that
+     the subprocess terminated successfully. */
+
+  if (spawnvp (P_WAIT, args[0], args) != 0)
+    return -1;
+  else
+    return 0;
+
 #elif defined (_WIN32)
 
   HANDLE h = NULL;
@@ -2666,6 +2710,9 @@ __gnat_portable_wait (int *process_status)
 
   pid = win32_wait (&status);
 
+#elif defined (MSDOS)
+  /* ??? See corresponding comment in portable_no_block_spawn.  */
+
 #else
 
   pid = waitpid (-1, &status, 0);
diff --git a/gcc/ada/ctrl_c.c b/gcc/ada/ctrl_c.c
index a860b767c..af7a68677 100644
--- a/gcc/ada/ctrl_c.c
+++ b/gcc/ada/ctrl_c.c
@@ -75,7 +75,7 @@ __gnat_install_int_handler (void (*proc) (void))
   if (sigint_intercepted == 0)
     {
       act.sa_handler = __gnat_int_handler;
-#if defined (__Lynx__)
+#if defined (__Lynx__) || defined(__DJGPP__)
       /* LynxOS does not support SA_RESTART. */
       act.sa_flags = 0;
 #else
diff --git a/gcc/ada/env.c b/gcc/ada/env.c
index c53678ab8..f4d4f265e 100644
--- a/gcc/ada/env.c
+++ b/gcc/ada/env.c
@@ -275,6 +275,8 @@ void __gnat_unsetenv (char *name) {
   sprintf (expression, "%s=", name);
   putenv (expression);
   free (expression);
+#elif defined (__DJGPP__) && __DJGPP__==2 && __DJGPP_MINOR__<4
+  putenv(name);
 #else
   unsetenv (name);
 #endif
@@ -299,7 +301,8 @@ void __gnat_clearenv (void) {
   }
 #elif defined (__MINGW32__) || defined (__FreeBSD__) || defined (__APPLE__) \
    || (defined (__vxworks) && defined (__RTP__)) || defined (__CYGWIN__) \
-   || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__rtems__)
+   || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__rtems__) \
+   || defined (__DJGPP__)
   /* On Windows, FreeBSD and MacOS there is no function to clean all the
      environment but there is a "clean" way to unset a variable. So go
      through the environ table and call __gnat_unsetenv on all entries */
diff --git a/gcc/ada/gcc-interface/Makefile.in b/gcc/ada/gcc-interface/Makefile.in
index 77027dd82..08f9fa0c5 100644
--- a/gcc/ada/gcc-interface/Makefile.in
+++ b/gcc/ada/gcc-interface/Makefile.in
@@ -1583,6 +1583,14 @@ ifeq ($(strip $(filter-out avr none powerpc% eabispe leon% erc32% unknown elf,$(
   indepsw.adb<indepsw-gnu.adb
 endif
 
+ifeq ($(strip $(filter-out %djgpp,$(osys))),)
+  GNATRTL_SOCKETS_OBJS =
+  LIBGNAT_TARGET_PAIRS += $(DUMMY_SOCKETS_TARGET_PAIRS)
+
+  LIBGNAT_TARGET_PAIRS += system.ads<system-djgpp.ads
+  LIBGNAT_TARGET_PAIRS += s-os_lib.adb<s-os_lib-djgpp.adb
+endif
+
 ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)
   LIBGNAT_TARGET_PAIRS = \
   a-dirval.adb<a-dirval-mingw.adb \
diff --git a/gcc/ada/gsocket.h b/gcc/ada/gsocket.h
index 7763b1801..e20539a7b 100644
--- a/gcc/ada/gsocket.h
+++ b/gcc/ada/gsocket.h
@@ -29,7 +29,7 @@
  *                                                                          *
  ****************************************************************************/
 
-#if defined(__nucleus__) || defined(VTHREADS)
+#if defined(__nucleus__) || defined(VTHREADS) || defined(__DJGPP__)
 
 #warning Sockets not supported on these platforms
 #undef HAVE_SOCKETS
diff --git a/gcc/ada/init.c b/gcc/ada/init.c
index 431aa9095..15cf5061e 100644
--- a/gcc/ada/init.c
+++ b/gcc/ada/init.c
@@ -2349,6 +2349,37 @@ __gnat_install_handler (void)
   __gnat_handler_installed = 1;
 }
 
+#elif defined (__DJGPP__)
+
+/***************************************/
+/* FIXME: this is only a draft version */
+/***************************************/
+
+struct timestruc_t
+{
+   time_t  tv_sec;
+   long    tv_nsec;
+};
+
+
+int
+nanosleep (struct timestruc_t *Rqtp, struct timestruc_t *Rmtp);
+
+int
+nanosleep (struct timestruc_t *Rqtp, struct timestruc_t *Rmtp)
+{
+    usleep (1000000*Rqtp->tv_sec+Rqtp->tv_nsec/1000);
+    if (Rmtp) { Rmtp->tv_sec = Rmtp->tv_nsec=0; }
+    return 0;
+}
+
+
+void
+__gnat_install_handler ()
+{
+  __gnat_handler_installed = 1;
+}
+
 #else
 
 /* For all other versions of GNAT, the handler does nothing.  */
diff --git a/gcc/ada/s-os_lib-djgpp.adb b/gcc/ada/s-os_lib-djgpp.adb
new file mode 100644
index 000000000..0269b5e61
--- /dev/null
+++ b/gcc/ada/s-os_lib-djgpp.adb
@@ -0,0 +1,2738 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                        S Y S T E M . O S _ L I B                         --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 1995-2012, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+pragma Compiler_Unit;
+
+with Ada.Unchecked_Conversion;
+with Ada.Unchecked_Deallocation;
+with System; use System;
+with System.Case_Util;
+with System.CRTL;
+with System.Soft_Links;
+
+package body System.OS_Lib is
+
+   --  Imported procedures Dup and Dup2 are used in procedures Spawn and
+   --  Non_Blocking_Spawn.
+
+   function Dup (Fd : File_Descriptor) return File_Descriptor;
+   pragma Import (C, Dup, "__gnat_dup");
+
+   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);
+   pragma Import (C, Dup2, "__gnat_dup2");
+
+   On_Windows : constant Boolean := Directory_Separator = '\';
+   --  An indication that we are on Windows. Used in Normalize_Pathname, to
+   --  deal with drive letters in the beginning of absolute paths.
+
+   package SSL renames System.Soft_Links;
+
+   --  The following are used by Create_Temp_File
+
+   First_Temp_File_Name : constant String := "GA000000.TMP";
+   --  Used to initialize Current_Temp_File_Name and Temp_File_Name_Last_Digit
+
+   Current_Temp_File_Name : String := First_Temp_File_Name;
+   --  Name of the temp file last created
+
+   Temp_File_Name_Last_Digit : constant Positive :=
+                                 First_Temp_File_Name'Last - 4;
+   --  Position of the last digit in Current_Temp_File_Name
+
+   Max_Attempts : constant := 100;
+   --  The maximum number of attempts to create a new temp file
+
+   -----------------------
+   -- Local Subprograms --
+   -----------------------
+
+   function Args_Length (Args : Argument_List) return Natural;
+   --  Returns total number of characters needed to create a string of all Args
+   --  terminated by ASCII.NUL characters.
+
+   procedure Create_Temp_File_Internal
+     (FD     : out File_Descriptor;
+      Name   : out String_Access;
+      Stdout : Boolean);
+   --  Internal routine to implement two Create_Temp_File routines. If Stdout
+   --  is set to True the created descriptor is stdout-compatible, otherwise
+   --  it might not be depending on the OS (VMS is one example). The first two
+   --  parameters are as in Create_Temp_File.
+
+   function C_String_Length (S : Address) return Integer;
+   --  Returns the length of a C string. Does check for null address
+   --  (returns 0).
+
+   procedure Spawn_Internal
+     (Program_Name : String;
+      Args         : Argument_List;
+      Result       : out Integer;
+      Pid          : out Process_Id;
+      Blocking     : Boolean);
+   --  Internal routine to implement the two Spawn (blocking/non blocking)
+   --  routines. If Blocking is set to True then the spawn is blocking
+   --  otherwise it is non blocking. In this latter case the Pid contains the
+   --  process id number. The first three parameters are as in Spawn. Note that
+   --  Spawn_Internal normalizes the argument list before calling the low level
+   --  system spawn routines (see Normalize_Arguments).
+   --
+   --  Note: Normalize_Arguments is designed to do nothing if it is called more
+   --  than once, so calling Normalize_Arguments before calling one of the
+   --  spawn routines is fine.
+
+   function To_Path_String_Access
+     (Path_Addr : Address;
+      Path_Len  : Integer) return String_Access;
+   --  Converts a C String to an Ada String. We could do this making use of
+   --  Interfaces.C.Strings but we prefer not to import that entire package
+
+   ---------
+   -- "<" --
+   ---------
+
+   function "<"  (X, Y : OS_Time) return Boolean is
+   begin
+      return Long_Integer (X) < Long_Integer (Y);
+   end "<";
+
+   ----------
+   -- "<=" --
+   ----------
+
+   function "<="  (X, Y : OS_Time) return Boolean is
+   begin
+      return Long_Integer (X) <= Long_Integer (Y);
+   end "<=";
+
+   ---------
+   -- ">" --
+   ---------
+
+   function ">"  (X, Y : OS_Time) return Boolean is
+   begin
+      return Long_Integer (X) > Long_Integer (Y);
+   end ">";
+
+   ----------
+   -- ">=" --
+   ----------
+
+   function ">="  (X, Y : OS_Time) return Boolean is
+   begin
+      return Long_Integer (X) >= Long_Integer (Y);
+   end ">=";
+
+   -----------------
+   -- Args_Length --
+   -----------------
+
+   function Args_Length (Args : Argument_List) return Natural is
+      Len : Natural := 0;
+
+   begin
+      for J in Args'Range loop
+         Len := Len + Args (J)'Length + 1; --  One extra for ASCII.NUL
+      end loop;
+
+      return Len;
+   end Args_Length;
+
+   -----------------------------
+   -- Argument_String_To_List --
+   -----------------------------
+
+   function Argument_String_To_List
+     (Arg_String : String) return Argument_List_Access
+   is
+      Max_Args : constant Integer := Arg_String'Length;
+      New_Argv : Argument_List (1 .. Max_Args);
+      New_Argc : Natural := 0;
+      Idx      : Integer;
+
+   begin
+      Idx := Arg_String'First;
+
+      loop
+         exit when Idx > Arg_String'Last;
+
+         declare
+            Quoted  : Boolean := False;
+            Backqd  : Boolean := False;
+            Old_Idx : Integer;
+
+         begin
+            Old_Idx := Idx;
+
+            loop
+               --  An unquoted space is the end of an argument
+
+               if not (Backqd or Quoted)
+                 and then Arg_String (Idx) = ' '
+               then
+                  exit;
+
+               --  Start of a quoted string
+
+               elsif not (Backqd or Quoted)
+                 and then Arg_String (Idx) = '"'
+               then
+                  Quoted := True;
+
+               --  End of a quoted string and end of an argument
+
+               elsif (Quoted and not Backqd)
+                 and then Arg_String (Idx) = '"'
+               then
+                  Idx := Idx + 1;
+                  exit;
+
+               --  Following character is backquoted
+
+               elsif Arg_String (Idx) = '\' then
+                  Backqd := True;
+
+               --  Turn off backquoting after advancing one character
+
+               elsif Backqd then
+                  Backqd := False;
+
+               end if;
+
+               Idx := Idx + 1;
+               exit when Idx > Arg_String'Last;
+            end loop;
+
+            --  Found an argument
+
+            New_Argc := New_Argc + 1;
+            New_Argv (New_Argc) :=
+              new String'(Arg_String (Old_Idx .. Idx - 1));
+
+            --  Skip extraneous spaces
+
+            while Idx <= Arg_String'Last and then Arg_String (Idx) = ' ' loop
+               Idx := Idx + 1;
+            end loop;
+         end;
+      end loop;
+
+      return new Argument_List'(New_Argv (1 .. New_Argc));
+   end Argument_String_To_List;
+
+   ---------------------
+   -- C_String_Length --
+   ---------------------
+
+   function C_String_Length (S : Address) return Integer is
+      function Strlen (S : Address) return Integer;
+      pragma Import (C, Strlen, "strlen");
+   begin
+      if S = Null_Address then
+         return 0;
+      else
+         return Strlen (S);
+      end if;
+   end C_String_Length;
+
+   -----------
+   -- Close --
+   -----------
+
+   procedure Close (FD : File_Descriptor) is
+      procedure C_Close (FD : File_Descriptor);
+      pragma Import (C, C_Close, "close");
+   begin
+      C_Close (FD);
+   end Close;
+
+   procedure Close (FD : File_Descriptor; Status : out Boolean) is
+      function C_Close (FD : File_Descriptor) return Integer;
+      pragma Import (C, C_Close, "close");
+   begin
+      Status := (C_Close (FD) = 0);
+   end Close;
+
+   ---------------
+   -- Copy_File --
+   ---------------
+
+   procedure Copy_File
+     (Name     : String;
+      Pathname : String;
+      Success  : out Boolean;
+      Mode     : Copy_Mode := Copy;
+      Preserve : Attribute := Time_Stamps)
+   is
+      From : File_Descriptor;
+      To   : File_Descriptor;
+
+      Copy_Error : exception;
+      --  Internal exception raised to signal error in copy
+
+      function Build_Path (Dir : String; File : String) return String;
+      --  Returns pathname Dir concatenated with File adding the directory
+      --  separator only if needed.
+
+      procedure Copy (From, To : File_Descriptor);
+      --  Read data from From and place them into To. In both cases the
+      --  operations uses the current file position. Raises Constraint_Error
+      --  if a problem occurs during the copy.
+
+      procedure Copy_To (To_Name : String);
+      --  Does a straight copy from source to designated destination file
+
+      ----------------
+      -- Build_Path --
+      ----------------
+
+      function Build_Path (Dir : String; File : String) return String is
+         Res : String (1 .. Dir'Length + File'Length + 1);
+
+         Base_File_Ptr : Integer;
+         --  The base file name is File (Base_File_Ptr + 1 .. File'Last)
+
+         function Is_Dirsep (C : Character) return Boolean;
+         pragma Inline (Is_Dirsep);
+         --  Returns True if C is a directory separator. On Windows we
+         --  handle both styles of directory separator.
+
+         ---------------
+         -- Is_Dirsep --
+         ---------------
+
+         function Is_Dirsep (C : Character) return Boolean is
+         begin
+            return C = Directory_Separator or else C = '/';
+         end Is_Dirsep;
+
+      --  Start of processing for Build_Path
+
+      begin
+         --  Find base file name
+
+         Base_File_Ptr := File'Last;
+         while Base_File_Ptr >= File'First loop
+            exit when Is_Dirsep (File (Base_File_Ptr));
+            Base_File_Ptr := Base_File_Ptr - 1;
+         end loop;
+
+         declare
+            Base_File : String renames
+                          File (Base_File_Ptr + 1 .. File'Last);
+
+         begin
+            Res (1 .. Dir'Length) := Dir;
+
+            if Is_Dirsep (Dir (Dir'Last)) then
+               Res (Dir'Length + 1 .. Dir'Length + Base_File'Length) :=
+                 Base_File;
+               return Res (1 .. Dir'Length + Base_File'Length);
+
+            else
+               Res (Dir'Length + 1) := Directory_Separator;
+               Res (Dir'Length + 2 .. Dir'Length + 1 + Base_File'Length) :=
+                 Base_File;
+               return Res (1 .. Dir'Length + 1 + Base_File'Length);
+            end if;
+         end;
+      end Build_Path;
+
+      ----------
+      -- Copy --
+      ----------
+
+      procedure Copy (From, To : File_Descriptor) is
+         Buf_Size : constant := 200_000;
+         type Buf is array (1 .. Buf_Size) of Character;
+         type Buf_Ptr is access Buf;
+
+         Buffer : Buf_Ptr;
+         R      : Integer;
+         W      : Integer;
+
+         Status_From : Boolean;
+         Status_To   : Boolean;
+         --  Statuses for the calls to Close
+
+         procedure Free is new Ada.Unchecked_Deallocation (Buf, Buf_Ptr);
+
+      begin
+         --  Check for invalid descriptors, making sure that we do not
+         --  accidentally leave an open file descriptor around.
+
+         if From = Invalid_FD then
+            if To /= Invalid_FD then
+               Close (To, Status_To);
+            end if;
+
+            raise Copy_Error;
+
+         elsif To = Invalid_FD then
+            Close (From, Status_From);
+            raise Copy_Error;
+         end if;
+
+         --  Allocate the buffer on the heap
+
+         Buffer := new Buf;
+
+         loop
+            R := Read (From, Buffer (1)'Address, Buf_Size);
+
+            --  For VMS, the buffer may not be full. So, we need to try again
+            --  until there is nothing to read.
+
+            exit when R = 0;
+
+            W := Write (To, Buffer (1)'Address, R);
+
+            if W < R then
+
+               --  Problem writing data, could be a disk full. Close files
+               --  without worrying about status, since we are raising a
+               --  Copy_Error exception in any case.
+
+               Close (From, Status_From);
+               Close (To, Status_To);
+
+               Free (Buffer);
+
+               raise Copy_Error;
+            end if;
+         end loop;
+
+         Close (From, Status_From);
+         Close (To, Status_To);
+
+         Free (Buffer);
+
+         if not (Status_From and Status_To) then
+            raise Copy_Error;
+         end if;
+      end Copy;
+
+      -------------
+      -- Copy_To --
+      -------------
+
+      procedure Copy_To (To_Name : String) is
+
+         function Copy_Attributes
+           (From, To : System.Address;
+            Mode     : Integer) return Integer;
+         pragma Import (C, Copy_Attributes, "__gnat_copy_attribs");
+         --  Mode = 0 - copy only time stamps.
+         --  Mode = 1 - copy time stamps and read/write/execute attributes
+
+         C_From : String (1 .. Name'Length + 1);
+         C_To   : String (1 .. To_Name'Length + 1);
+
+      begin
+         From := Open_Read (Name, Binary);
+
+         --  Do not clobber destination file if source file could not be opened
+
+         if From /= Invalid_FD then
+            To := Create_File (To_Name, Binary);
+         end if;
+
+         Copy (From, To);
+
+         --  Copy attributes
+
+         C_From (1 .. Name'Length) := Name;
+         C_From (C_From'Last) := ASCII.NUL;
+
+         C_To (1 .. To_Name'Length) := To_Name;
+         C_To (C_To'Last) := ASCII.NUL;
+
+         case Preserve is
+
+            when Time_Stamps =>
+               if Copy_Attributes (C_From'Address, C_To'Address, 0) = -1 then
+                  raise Copy_Error;
+               end if;
+
+            when Full =>
+               if Copy_Attributes (C_From'Address, C_To'Address, 1) = -1 then
+                  raise Copy_Error;
+               end if;
+
+            when None =>
+               null;
+         end case;
+
+      end Copy_To;
+
+   --  Start of processing for Copy_File
+
+   begin
+      Success := True;
+
+      --  The source file must exist
+
+      if not Is_Regular_File (Name) then
+         raise Copy_Error;
+      end if;
+
+      --  The source file exists
+
+      case Mode is
+
+         --  Copy case, target file must not exist
+
+         when Copy =>
+
+            --  If the target file exists, we have an error
+
+            if Is_Regular_File (Pathname) then
+               raise Copy_Error;
+
+            --  Case of target is a directory
+
+            elsif Is_Directory (Pathname) then
+               declare
+                  Dest : constant String := Build_Path (Pathname, Name);
+
+               begin
+                  --  If target file exists, we have an error, else do copy
+
+                  if Is_Regular_File (Dest) then
+                     raise Copy_Error;
+                  else
+                     Copy_To (Dest);
+                  end if;
+               end;
+
+            --  Case of normal copy to file (destination does not exist)
+
+            else
+               Copy_To (Pathname);
+            end if;
+
+         --  Overwrite case (destination file may or may not exist)
+
+         when Overwrite =>
+            if Is_Directory (Pathname) then
+               Copy_To (Build_Path (Pathname, Name));
+            else
+               Copy_To (Pathname);
+            end if;
+
+         --  Append case (destination file may or may not exist)
+
+         when Append =>
+
+            --  Appending to existing file
+
+            if Is_Regular_File (Pathname) then
+
+               --  Append mode and destination file exists, append data at the
+               --  end of Pathname. But if we fail to open source file, do not
+               --  touch destination file at all.
+
+               From := Open_Read (Name, Binary);
+               if From /= Invalid_FD then
+                  To := Open_Read_Write (Pathname, Binary);
+               end if;
+
+               Lseek (To, 0, Seek_End);
+
+               Copy (From, To);
+
+            --  Appending to directory, not allowed
+
+            elsif Is_Directory (Pathname) then
+               raise Copy_Error;
+
+            --  Appending when target file does not exist
+
+            else
+               Copy_To (Pathname);
+            end if;
+      end case;
+
+   --  All error cases are caught here
+
+   exception
+      when Copy_Error =>
+         Success := False;
+   end Copy_File;
+
+   procedure Copy_File
+     (Name     : C_File_Name;
+      Pathname : C_File_Name;
+      Success  : out Boolean;
+      Mode     : Copy_Mode := Copy;
+      Preserve : Attribute := Time_Stamps)
+   is
+      Ada_Name     : String_Access :=
+                       To_Path_String_Access
+                         (Name, C_String_Length (Name));
+      Ada_Pathname : String_Access :=
+                       To_Path_String_Access
+                         (Pathname, C_String_Length (Pathname));
+   begin
+      Copy_File (Ada_Name.all, Ada_Pathname.all, Success, Mode, Preserve);
+      Free (Ada_Name);
+      Free (Ada_Pathname);
+   end Copy_File;
+
+   ----------------------
+   -- Copy_Time_Stamps --
+   ----------------------
+
+   procedure Copy_Time_Stamps (Source, Dest : String; Success : out Boolean) is
+
+      function Copy_Attributes
+        (From, To : System.Address;
+         Mode     : Integer) return Integer;
+      pragma Import (C, Copy_Attributes, "__gnat_copy_attribs");
+      --  Mode = 0 - copy only time stamps.
+      --  Mode = 1 - copy time stamps and read/write/execute attributes
+
+   begin
+      if Is_Regular_File (Source) and then Is_Writable_File (Dest) then
+         declare
+            C_Source : String (1 .. Source'Length + 1);
+            C_Dest   : String (1 .. Dest'Length + 1);
+
+         begin
+            C_Source (1 .. Source'Length) := Source;
+            C_Source (C_Source'Last)      := ASCII.NUL;
+
+            C_Dest (1 .. Dest'Length) := Dest;
+            C_Dest (C_Dest'Last)      := ASCII.NUL;
+
+            if Copy_Attributes (C_Source'Address, C_Dest'Address, 0) = -1 then
+               Success := False;
+            else
+               Success := True;
+            end if;
+         end;
+
+      else
+         Success := False;
+      end if;
+   end Copy_Time_Stamps;
+
+   procedure Copy_Time_Stamps
+     (Source, Dest : C_File_Name;
+      Success      : out Boolean)
+   is
+      Ada_Source : String_Access :=
+                     To_Path_String_Access
+                       (Source, C_String_Length (Source));
+      Ada_Dest   : String_Access :=
+                     To_Path_String_Access
+                       (Dest, C_String_Length (Dest));
+   begin
+      Copy_Time_Stamps (Ada_Source.all, Ada_Dest.all, Success);
+      Free (Ada_Source);
+      Free (Ada_Dest);
+   end Copy_Time_Stamps;
+
+   -----------------
+   -- Create_File --
+   -----------------
+
+   function Create_File
+     (Name  : C_File_Name;
+      Fmode : Mode) return File_Descriptor
+   is
+      function C_Create_File
+        (Name  : C_File_Name;
+         Fmode : Mode) return File_Descriptor;
+      pragma Import (C, C_Create_File, "__gnat_open_create");
+
+   begin
+      return C_Create_File (Name, Fmode);
+   end Create_File;
+
+   function Create_File
+     (Name  : String;
+      Fmode : Mode) return File_Descriptor
+   is
+      C_Name : String (1 .. Name'Length + 1);
+
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+      return Create_File (C_Name (C_Name'First)'Address, Fmode);
+   end Create_File;
+
+   ---------------------
+   -- Create_New_File --
+   ---------------------
+
+   function Create_New_File
+     (Name  : C_File_Name;
+      Fmode : Mode) return File_Descriptor
+   is
+      function C_Create_New_File
+        (Name  : C_File_Name;
+         Fmode : Mode) return File_Descriptor;
+      pragma Import (C, C_Create_New_File, "__gnat_open_new");
+
+   begin
+      return C_Create_New_File (Name, Fmode);
+   end Create_New_File;
+
+   function Create_New_File
+     (Name  : String;
+      Fmode : Mode) return File_Descriptor
+   is
+      C_Name : String (1 .. Name'Length + 1);
+
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+      return Create_New_File (C_Name (C_Name'First)'Address, Fmode);
+   end Create_New_File;
+
+   -----------------------------
+   -- Create_Output_Text_File --
+   -----------------------------
+
+   function Create_Output_Text_File (Name : String) return File_Descriptor is
+      function C_Create_File
+        (Name : C_File_Name) return File_Descriptor;
+      pragma Import (C, C_Create_File, "__gnat_create_output_file");
+
+      C_Name : String (1 .. Name'Length + 1);
+
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+      return C_Create_File (C_Name (C_Name'First)'Address);
+   end Create_Output_Text_File;
+
+   ----------------------
+   -- Create_Temp_File --
+   ----------------------
+
+   procedure Create_Temp_File
+     (FD   : out File_Descriptor;
+      Name : out Temp_File_Name)
+   is
+      function Open_New_Temp
+        (Name  : System.Address;
+         Fmode : Mode) return File_Descriptor;
+      pragma Import (C, Open_New_Temp, "__gnat_open_new_temp");
+
+   begin
+      FD := Open_New_Temp (Name'Address, Binary);
+   end Create_Temp_File;
+
+   procedure Create_Temp_File
+     (FD   : out File_Descriptor;
+      Name : out String_Access)
+   is
+   begin
+      Create_Temp_File_Internal (FD, Name, Stdout => False);
+   end Create_Temp_File;
+
+   procedure Create_Temp_Output_File
+     (FD   : out File_Descriptor;
+      Name : out String_Access)
+   is
+   begin
+      Create_Temp_File_Internal (FD, Name, Stdout => True);
+   end Create_Temp_Output_File;
+
+   -------------------------------
+   -- Create_Temp_File_Internal --
+   -------------------------------
+
+   procedure Create_Temp_File_Internal
+     (FD        : out File_Descriptor;
+      Name      : out String_Access;
+      Stdout    : Boolean)
+   is
+      Pos      : Positive;
+      Attempts : Natural := 0;
+      Current  : String (Current_Temp_File_Name'Range);
+
+      ---------------------------------
+      -- Create_New_Output_Text_File --
+      ---------------------------------
+
+      function Create_New_Output_Text_File
+        (Name : String) return File_Descriptor;
+      --  Similar to Create_Output_Text_File, except it fails if the file
+      --  already exists. We need this behavior to ensure we don't accidentally
+      --  open a temp file that has just been created by a concurrently running
+      --  process. There is no point exposing this function, as it's generally
+      --  not particularly useful.
+
+      function Create_New_Output_Text_File
+        (Name : String) return File_Descriptor is
+         function C_Create_File
+           (Name : C_File_Name) return File_Descriptor;
+         pragma Import (C, C_Create_File, "__gnat_create_output_file_new");
+
+         C_Name : String (1 .. Name'Length + 1);
+
+      begin
+         C_Name (1 .. Name'Length) := Name;
+         C_Name (C_Name'Last)      := ASCII.NUL;
+         return C_Create_File (C_Name (C_Name'First)'Address);
+      end Create_New_Output_Text_File;
+
+   begin
+      --  Loop until a new temp file can be created
+
+      File_Loop : loop
+         Locked : begin
+            --  We need to protect global variable Current_Temp_File_Name
+            --  against concurrent access by different tasks.
+
+            SSL.Lock_Task.all;
+
+            --  Start at the last digit
+
+            Pos := Temp_File_Name_Last_Digit;
+
+            Digit_Loop :
+            loop
+               --  Increment the digit by one
+
+               case Current_Temp_File_Name (Pos) is
+                  when '0' .. '8' =>
+                     Current_Temp_File_Name (Pos) :=
+                       Character'Succ (Current_Temp_File_Name (Pos));
+                     exit Digit_Loop;
+
+                  when '9' =>
+
+                     --  For 9, set the digit to 0 and go to the previous digit
+
+                     Current_Temp_File_Name (Pos) := '0';
+                     Pos := Pos - 1;
+
+                  when others =>
+
+                     --  If it is not a digit, then there are no available
+                     --  temp file names. Return Invalid_FD. There is almost
+                     --  no chance that this code will be ever be executed,
+                     --  since it would mean that there are one million temp
+                     --  files in the same directory!
+
+                     SSL.Unlock_Task.all;
+                     FD := Invalid_FD;
+                     Name := null;
+                     exit File_Loop;
+               end case;
+            end loop Digit_Loop;
+
+            Current := Current_Temp_File_Name;
+
+            --  We can now release the lock, because we are no longer
+            --  accessing Current_Temp_File_Name.
+
+            SSL.Unlock_Task.all;
+
+         exception
+            when others =>
+               SSL.Unlock_Task.all;
+               raise;
+         end Locked;
+
+         --  Attempt to create the file
+
+         if Stdout then
+            FD := Create_New_Output_Text_File (Current);
+         else
+            FD := Create_New_File (Current, Binary);
+         end if;
+
+         if FD /= Invalid_FD then
+            Name := new String'(Current);
+            exit File_Loop;
+         end if;
+
+         if not Is_Regular_File (Current) then
+
+            --  If the file does not already exist and we are unable to create
+            --  it, we give up after Max_Attempts. Otherwise, we try again with
+            --  the next available file name.
+
+            Attempts := Attempts + 1;
+
+            if Attempts >= Max_Attempts then
+               FD := Invalid_FD;
+               Name := null;
+               exit File_Loop;
+            end if;
+         end if;
+      end loop File_Loop;
+   end Create_Temp_File_Internal;
+
+   -----------------
+   -- Delete_File --
+   -----------------
+
+   procedure Delete_File (Name : Address; Success : out Boolean) is
+      R : Integer;
+   begin
+      R := System.CRTL.unlink (Name);
+      Success := (R = 0);
+   end Delete_File;
+
+   procedure Delete_File (Name : String; Success : out Boolean) is
+      C_Name : String (1 .. Name'Length + 1);
+
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+
+      Delete_File (C_Name'Address, Success);
+   end Delete_File;
+
+   ---------------------
+   -- File_Time_Stamp --
+   ---------------------
+
+   function File_Time_Stamp (FD : File_Descriptor) return OS_Time is
+      function File_Time (FD : File_Descriptor) return OS_Time;
+      pragma Import (C, File_Time, "__gnat_file_time_fd");
+   begin
+      return File_Time (FD);
+   end File_Time_Stamp;
+
+   function File_Time_Stamp (Name : C_File_Name) return OS_Time is
+      function File_Time (Name : Address) return OS_Time;
+      pragma Import (C, File_Time, "__gnat_file_time_name");
+   begin
+      return File_Time (Name);
+   end File_Time_Stamp;
+
+   function File_Time_Stamp (Name : String) return OS_Time is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return File_Time_Stamp (F_Name'Address);
+   end File_Time_Stamp;
+
+   ---------------------------
+   -- Get_Debuggable_Suffix --
+   ---------------------------
+
+   function Get_Debuggable_Suffix return String_Access is
+      procedure Get_Suffix_Ptr (Length, Ptr : Address);
+      pragma Import (C, Get_Suffix_Ptr, "__gnat_get_debuggable_suffix_ptr");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      Suffix_Ptr    : Address;
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Debuggable_Suffix;
+
+   ---------------------------
+   -- Get_Executable_Suffix --
+   ---------------------------
+
+   function Get_Executable_Suffix return String_Access is
+      procedure Get_Suffix_Ptr (Length, Ptr : Address);
+      pragma Import (C, Get_Suffix_Ptr, "__gnat_get_executable_suffix_ptr");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      Suffix_Ptr    : Address;
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Executable_Suffix;
+
+   -----------------------
+   -- Get_Object_Suffix --
+   -----------------------
+
+   function Get_Object_Suffix return String_Access is
+      procedure Get_Suffix_Ptr (Length, Ptr : Address);
+      pragma Import (C, Get_Suffix_Ptr, "__gnat_get_object_suffix_ptr");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      Suffix_Ptr    : Address;
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Object_Suffix;
+
+   ----------------------------------
+   -- Get_Target_Debuggable_Suffix --
+   ----------------------------------
+
+   function Get_Target_Debuggable_Suffix return String_Access is
+      Target_Exec_Ext_Ptr : Address;
+      pragma Import
+        (C, Target_Exec_Ext_Ptr, "__gnat_target_debuggable_extension");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      function Strlen (Cstring : Address) return Integer;
+      pragma Import (C, Strlen, "strlen");
+
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Target_Exec_Ext_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Target_Debuggable_Suffix;
+
+   ----------------------------------
+   -- Get_Target_Executable_Suffix --
+   ----------------------------------
+
+   function Get_Target_Executable_Suffix return String_Access is
+      Target_Exec_Ext_Ptr : Address;
+      pragma Import
+        (C, Target_Exec_Ext_Ptr, "__gnat_target_executable_extension");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      function Strlen (Cstring : Address) return Integer;
+      pragma Import (C, Strlen, "strlen");
+
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Target_Exec_Ext_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Target_Executable_Suffix;
+
+   ------------------------------
+   -- Get_Target_Object_Suffix --
+   ------------------------------
+
+   function Get_Target_Object_Suffix return String_Access is
+      Target_Object_Ext_Ptr : Address;
+      pragma Import
+        (C, Target_Object_Ext_Ptr, "__gnat_target_object_extension");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      function Strlen (Cstring : Address) return Integer;
+      pragma Import (C, Strlen, "strlen");
+
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Suffix_Length := Strlen (Target_Object_Ext_Ptr);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Target_Object_Ext_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Target_Object_Suffix;
+
+   ------------
+   -- Getenv --
+   ------------
+
+   function Getenv (Name : String) return String_Access is
+      procedure Get_Env_Value_Ptr (Name, Length, Ptr : Address);
+      pragma Import (C, Get_Env_Value_Ptr, "__gnat_getenv");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      Env_Value_Ptr    : aliased Address;
+      Env_Value_Length : aliased Integer;
+      F_Name           : aliased String (1 .. Name'Length + 1);
+      Result           : String_Access;
+
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+
+      Get_Env_Value_Ptr
+        (F_Name'Address, Env_Value_Length'Address, Env_Value_Ptr'Address);
+
+      Result := new String (1 .. Env_Value_Length);
+
+      if Env_Value_Length > 0 then
+         Strncpy (Result.all'Address, Env_Value_Ptr, Env_Value_Length);
+      end if;
+
+      return Result;
+   end Getenv;
+
+   ------------
+   -- GM_Day --
+   ------------
+
+   function GM_Day (Date : OS_Time) return Day_Type is
+      D  : Day_Type;
+
+      pragma Warnings (Off);
+      Y  : Year_Type;
+      Mo : Month_Type;
+      H  : Hour_Type;
+      Mn : Minute_Type;
+      S  : Second_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return D;
+   end GM_Day;
+
+   -------------
+   -- GM_Hour --
+   -------------
+
+   function GM_Hour (Date : OS_Time) return Hour_Type is
+      H  : Hour_Type;
+
+      pragma Warnings (Off);
+      Y  : Year_Type;
+      Mo : Month_Type;
+      D  : Day_Type;
+      Mn : Minute_Type;
+      S  : Second_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return H;
+   end GM_Hour;
+
+   ---------------
+   -- GM_Minute --
+   ---------------
+
+   function GM_Minute (Date : OS_Time) return Minute_Type is
+      Mn : Minute_Type;
+
+      pragma Warnings (Off);
+      Y  : Year_Type;
+      Mo : Month_Type;
+      D  : Day_Type;
+      H  : Hour_Type;
+      S  : Second_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return Mn;
+   end GM_Minute;
+
+   --------------
+   -- GM_Month --
+   --------------
+
+   function GM_Month (Date : OS_Time) return Month_Type is
+      Mo : Month_Type;
+
+      pragma Warnings (Off);
+      Y  : Year_Type;
+      D  : Day_Type;
+      H  : Hour_Type;
+      Mn : Minute_Type;
+      S  : Second_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return Mo;
+   end GM_Month;
+
+   ---------------
+   -- GM_Second --
+   ---------------
+
+   function GM_Second (Date : OS_Time) return Second_Type is
+      S  : Second_Type;
+
+      pragma Warnings (Off);
+      Y  : Year_Type;
+      Mo : Month_Type;
+      D  : Day_Type;
+      H  : Hour_Type;
+      Mn : Minute_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return S;
+   end GM_Second;
+
+   --------------
+   -- GM_Split --
+   --------------
+
+   procedure GM_Split
+     (Date   : OS_Time;
+      Year   : out Year_Type;
+      Month  : out Month_Type;
+      Day    : out Day_Type;
+      Hour   : out Hour_Type;
+      Minute : out Minute_Type;
+      Second : out Second_Type)
+   is
+      procedure To_GM_Time
+        (P_Time_T, P_Year, P_Month, P_Day, P_Hours, P_Mins, P_Secs : Address);
+      pragma Import (C, To_GM_Time, "__gnat_to_gm_time");
+
+      T  : OS_Time := Date;
+      Y  : Integer;
+      Mo : Integer;
+      D  : Integer;
+      H  : Integer;
+      Mn : Integer;
+      S  : Integer;
+
+   begin
+      --  Use the global lock because To_GM_Time is not thread safe
+
+      Locked_Processing : begin
+         SSL.Lock_Task.all;
+         To_GM_Time
+           (T'Address, Y'Address, Mo'Address, D'Address,
+            H'Address, Mn'Address, S'Address);
+         SSL.Unlock_Task.all;
+
+      exception
+         when others =>
+            SSL.Unlock_Task.all;
+            raise;
+      end Locked_Processing;
+
+      Year   := Y + 1900;
+      Month  := Mo + 1;
+      Day    := D;
+      Hour   := H;
+      Minute := Mn;
+      Second := S;
+   end GM_Split;
+
+   -------------
+   -- GM_Year --
+   -------------
+
+   function GM_Year (Date : OS_Time) return Year_Type is
+      Y  : Year_Type;
+
+      pragma Warnings (Off);
+      Mo : Month_Type;
+      D  : Day_Type;
+      H  : Hour_Type;
+      Mn : Minute_Type;
+      S  : Second_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return Y;
+   end GM_Year;
+
+   ----------------------
+   -- Is_Absolute_Path --
+   ----------------------
+
+   function Is_Absolute_Path (Name : String) return Boolean is
+      function Is_Absolute_Path
+        (Name   : Address;
+         Length : Integer) return Integer;
+      pragma Import (C, Is_Absolute_Path, "__gnat_is_absolute_path");
+   begin
+      return Is_Absolute_Path (Name'Address, Name'Length) /= 0;
+   end Is_Absolute_Path;
+
+   ------------------
+   -- Is_Directory --
+   ------------------
+
+   function Is_Directory (Name : C_File_Name) return Boolean is
+      function Is_Directory (Name : Address) return Integer;
+      pragma Import (C, Is_Directory, "__gnat_is_directory");
+   begin
+      return Is_Directory (Name) /= 0;
+   end Is_Directory;
+
+   function Is_Directory (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Directory (F_Name'Address);
+   end Is_Directory;
+
+   ----------------------
+   -- Is_Readable_File --
+   ----------------------
+
+   function Is_Readable_File (Name : C_File_Name) return Boolean is
+      function Is_Readable_File (Name : Address) return Integer;
+      pragma Import (C, Is_Readable_File, "__gnat_is_readable_file");
+   begin
+      return Is_Readable_File (Name) /= 0;
+   end Is_Readable_File;
+
+   function Is_Readable_File (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Readable_File (F_Name'Address);
+   end Is_Readable_File;
+
+   ------------------------
+   -- Is_Executable_File --
+   ------------------------
+
+   function Is_Executable_File (Name : C_File_Name) return Boolean is
+      function Is_Executable_File (Name : Address) return Integer;
+      pragma Import (C, Is_Executable_File, "__gnat_is_executable_file");
+   begin
+      return Is_Executable_File (Name) /= 0;
+   end Is_Executable_File;
+
+   function Is_Executable_File (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Executable_File (F_Name'Address);
+   end Is_Executable_File;
+
+   ---------------------
+   -- Is_Regular_File --
+   ---------------------
+
+   function Is_Regular_File (Name : C_File_Name) return Boolean is
+      function Is_Regular_File (Name : Address) return Integer;
+      pragma Import (C, Is_Regular_File, "__gnat_is_regular_file");
+   begin
+      return Is_Regular_File (Name) /= 0;
+   end Is_Regular_File;
+
+   function Is_Regular_File (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Regular_File (F_Name'Address);
+   end Is_Regular_File;
+
+   ----------------------
+   -- Is_Symbolic_Link --
+   ----------------------
+
+   function Is_Symbolic_Link (Name : C_File_Name) return Boolean is
+      function Is_Symbolic_Link (Name : Address) return Integer;
+      pragma Import (C, Is_Symbolic_Link, "__gnat_is_symbolic_link");
+   begin
+      return Is_Symbolic_Link (Name) /= 0;
+   end Is_Symbolic_Link;
+
+   function Is_Symbolic_Link (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Symbolic_Link (F_Name'Address);
+   end Is_Symbolic_Link;
+
+   ----------------------
+   -- Is_Writable_File --
+   ----------------------
+
+   function Is_Writable_File (Name : C_File_Name) return Boolean is
+      function Is_Writable_File (Name : Address) return Integer;
+      pragma Import (C, Is_Writable_File, "__gnat_is_writable_file");
+   begin
+      return Is_Writable_File (Name) /= 0;
+   end Is_Writable_File;
+
+   function Is_Writable_File (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Writable_File (F_Name'Address);
+   end Is_Writable_File;
+
+   -------------------------
+   -- Locate_Exec_On_Path --
+   -------------------------
+
+   function Locate_Exec_On_Path
+     (Exec_Name : String) return String_Access
+   is
+      function Locate_Exec_On_Path (C_Exec_Name : Address) return Address;
+      pragma Import (C, Locate_Exec_On_Path, "__gnat_locate_exec_on_path");
+
+      procedure Free (Ptr : System.Address);
+      pragma Import (C, Free, "free");
+
+      C_Exec_Name  : String (1 .. Exec_Name'Length + 1);
+      Path_Addr    : Address;
+      Path_Len     : Integer;
+      Result       : String_Access;
+
+   begin
+      C_Exec_Name (1 .. Exec_Name'Length)   := Exec_Name;
+      C_Exec_Name (C_Exec_Name'Last)        := ASCII.NUL;
+
+      Path_Addr := Locate_Exec_On_Path (C_Exec_Name'Address);
+      Path_Len  := C_String_Length (Path_Addr);
+
+      if Path_Len = 0 then
+         return null;
+
+      else
+         Result := To_Path_String_Access (Path_Addr, Path_Len);
+         Free (Path_Addr);
+
+         --  Always return an absolute path name
+
+         if not Is_Absolute_Path (Result.all) then
+            declare
+               Absolute_Path : constant String :=
+                                 Normalize_Pathname (Result.all);
+            begin
+               Free (Result);
+               Result := new String'(Absolute_Path);
+            end;
+         end if;
+
+         return Result;
+      end if;
+   end Locate_Exec_On_Path;
+
+   -------------------------
+   -- Locate_Regular_File --
+   -------------------------
+
+   function Locate_Regular_File
+     (File_Name : C_File_Name;
+      Path      : C_File_Name) return String_Access
+   is
+      function Locate_Regular_File
+        (C_File_Name, Path_Val : Address) return Address;
+      pragma Import (C, Locate_Regular_File, "__gnat_locate_regular_file");
+
+      procedure Free (Ptr : System.Address);
+      pragma Import (C, Free, "free");
+
+      Path_Addr    : Address;
+      Path_Len     : Integer;
+      Result       : String_Access;
+
+   begin
+      Path_Addr := Locate_Regular_File (File_Name, Path);
+      Path_Len  := C_String_Length (Path_Addr);
+
+      if Path_Len = 0 then
+         return null;
+
+      else
+         Result := To_Path_String_Access (Path_Addr, Path_Len);
+         Free (Path_Addr);
+         return Result;
+      end if;
+   end Locate_Regular_File;
+
+   function Locate_Regular_File
+     (File_Name : String;
+      Path      : String) return String_Access
+   is
+      C_File_Name : String (1 .. File_Name'Length + 1);
+      C_Path      : String (1 .. Path'Length + 1);
+      Result      : String_Access;
+
+   begin
+      C_File_Name (1 .. File_Name'Length)   := File_Name;
+      C_File_Name (C_File_Name'Last)        := ASCII.NUL;
+
+      C_Path    (1 .. Path'Length)          := Path;
+      C_Path    (C_Path'Last)               := ASCII.NUL;
+
+      Result := Locate_Regular_File (C_File_Name'Address, C_Path'Address);
+
+      --  Always return an absolute path name
+
+      if Result /= null and then not Is_Absolute_Path (Result.all) then
+         declare
+            Absolute_Path : constant String := Normalize_Pathname (Result.all);
+         begin
+            Free (Result);
+            Result := new String'(Absolute_Path);
+         end;
+      end if;
+
+      return Result;
+   end Locate_Regular_File;
+
+   ------------------------
+   -- Non_Blocking_Spawn --
+   ------------------------
+
+   function Non_Blocking_Spawn
+     (Program_Name : String;
+      Args         : Argument_List) return Process_Id
+   is
+      Pid  : Process_Id;
+      Junk : Integer;
+      pragma Warnings (Off, Junk);
+   begin
+      Spawn_Internal (Program_Name, Args, Junk, Pid, Blocking => False);
+      return Pid;
+   end Non_Blocking_Spawn;
+
+   function Non_Blocking_Spawn
+     (Program_Name           : String;
+      Args                   : Argument_List;
+      Output_File_Descriptor : File_Descriptor;
+      Err_To_Out             : Boolean := True) return Process_Id
+   is
+      Saved_Output : File_Descriptor;
+      Saved_Error  : File_Descriptor := Invalid_FD; -- prevent warning
+      Pid          : Process_Id;
+
+   begin
+      if Output_File_Descriptor = Invalid_FD then
+         return Invalid_Pid;
+      end if;
+
+      --  Set standard output and, if specified, error to the temporary file
+
+      Saved_Output := Dup (Standout);
+      Dup2 (Output_File_Descriptor, Standout);
+
+      if Err_To_Out then
+         Saved_Error  := Dup (Standerr);
+         Dup2 (Output_File_Descriptor, Standerr);
+      end if;
+
+      --  Spawn the program
+
+      Pid := Non_Blocking_Spawn (Program_Name, Args);
+
+      --  Restore the standard output and error
+
+      Dup2 (Saved_Output, Standout);
+
+      if Err_To_Out then
+         Dup2 (Saved_Error, Standerr);
+      end if;
+
+      --  And close the saved standard output and error file descriptors
+
+      Close (Saved_Output);
+
+      if Err_To_Out then
+         Close (Saved_Error);
+      end if;
+
+      return Pid;
+   end Non_Blocking_Spawn;
+
+   function Non_Blocking_Spawn
+     (Program_Name : String;
+      Args         : Argument_List;
+      Output_File  : String;
+      Err_To_Out   : Boolean := True) return Process_Id
+   is
+      Output_File_Descriptor : constant File_Descriptor :=
+                                 Create_Output_Text_File (Output_File);
+      Result : Process_Id;
+
+   begin
+      --  Do not attempt to spawn if the output file could not be created
+
+      if Output_File_Descriptor = Invalid_FD then
+         return Invalid_Pid;
+
+      else
+         Result := Non_Blocking_Spawn
+                     (Program_Name, Args, Output_File_Descriptor, Err_To_Out);
+
+         --  Close the file just created for the output, as the file descriptor
+         --  cannot be used anywhere, being a local value. It is safe to do
+         --  that, as the file descriptor has been duplicated to form
+         --  standard output and error of the spawned process.
+
+         Close (Output_File_Descriptor);
+
+         return Result;
+      end if;
+   end Non_Blocking_Spawn;
+
+   -------------------------
+   -- Normalize_Arguments --
+   -------------------------
+
+   procedure Normalize_Arguments (Args : in out Argument_List) is
+
+      procedure Quote_Argument (Arg : in out String_Access);
+      --  Add quote around argument if it contains spaces
+
+      C_Argument_Needs_Quote : Integer;
+      pragma Import (C, C_Argument_Needs_Quote, "__gnat_argument_needs_quote");
+      Argument_Needs_Quote : constant Boolean := C_Argument_Needs_Quote /= 0;
+
+      --------------------
+      -- Quote_Argument --
+      --------------------
+
+      procedure Quote_Argument (Arg : in out String_Access) is
+         Res          : String (1 .. Arg'Length * 2);
+         J            : Positive := 1;
+         Quote_Needed : Boolean  := False;
+
+      begin
+         if Arg (Arg'First) /= '"' or else Arg (Arg'Last) /= '"' then
+
+            --  Starting quote
+
+            Res (J) := '"';
+
+            for K in Arg'Range loop
+
+               J := J + 1;
+
+               if Arg (K) = '"' then
+                  Res (J) := '\';
+                  J := J + 1;
+                  Res (J) := '"';
+                  Quote_Needed := True;
+
+               elsif Arg (K) = ' ' then
+                  Res (J) := Arg (K);
+                  Quote_Needed := True;
+
+               else
+                  Res (J) := Arg (K);
+               end if;
+            end loop;
+
+            if Quote_Needed then
+
+               --  Case of null terminated string
+
+               if Res (J) = ASCII.NUL then
+
+                  --  If the string ends with \, double it
+
+                  if Res (J - 1) = '\' then
+                     Res (J) := '\';
+                     J := J + 1;
+                  end if;
+
+                  --  Put a quote just before the null at the end
+
+                  Res (J) := '"';
+                  J := J + 1;
+                  Res (J) := ASCII.NUL;
+
+               --  If argument is terminated by '\', then double it. Otherwise
+               --  the ending quote will be taken as-is. This is quite strange
+               --  spawn behavior from Windows, but this is what we see!
+
+               else
+                  if Res (J) = '\' then
+                     J := J + 1;
+                     Res (J) := '\';
+                  end if;
+
+                  --  Ending quote
+
+                  J := J + 1;
+                  Res (J) := '"';
+               end if;
+
+               declare
+                  Old : String_Access := Arg;
+
+               begin
+                  Arg := new String'(Res (1 .. J));
+                  Free (Old);
+               end;
+            end if;
+
+         end if;
+      end Quote_Argument;
+
+   --  Start of processing for Normalize_Arguments
+
+   begin
+      if Argument_Needs_Quote then
+         for K in Args'Range loop
+            if Args (K) /= null and then Args (K)'Length /= 0 then
+               Quote_Argument (Args (K));
+            end if;
+         end loop;
+      end if;
+   end Normalize_Arguments;
+
+   ------------------------
+   -- Normalize_Pathname --
+   ------------------------
+
+   function Normalize_Pathname
+     (Name           : String;
+      Directory      : String  := "";
+      Resolve_Links  : Boolean := True;
+      Case_Sensitive : Boolean := True) return String
+   is
+      Max_Path : Integer;
+      pragma Import (C, Max_Path, "__gnat_max_path_len");
+      --  Maximum length of a path name
+
+      procedure Get_Current_Dir
+        (Dir    : System.Address;
+         Length : System.Address);
+      pragma Import (C, Get_Current_Dir, "__gnat_get_current_dir");
+
+      Path_Buffer : String (1 .. Max_Path + Max_Path + 2);
+      End_Path    : Natural := 0;
+      Link_Buffer : String (1 .. Max_Path + 2);
+      Status      : Integer;
+      Last        : Positive;
+      Start       : Natural;
+      Finish      : Positive;
+
+      Max_Iterations : constant := 500;
+
+      function Get_File_Names_Case_Sensitive return Integer;
+      pragma Import
+        (C, Get_File_Names_Case_Sensitive,
+         "__gnat_get_file_names_case_sensitive");
+
+      Fold_To_Lower_Case : constant Boolean :=
+                             not Case_Sensitive
+                               and then Get_File_Names_Case_Sensitive = 0;
+
+      function Readlink
+        (Path   : System.Address;
+         Buf    : System.Address;
+         Bufsiz : Integer) return Integer;
+      pragma Import (C, Readlink, "__gnat_readlink");
+
+      function To_Canonical_File_Spec
+        (Host_File : System.Address) return System.Address;
+      pragma Import
+        (C, To_Canonical_File_Spec, "__gnat_to_canonical_file_spec");
+
+      The_Name : String (1 .. Name'Length + 1);
+      Canonical_File_Addr : System.Address;
+      Canonical_File_Len  : Integer;
+
+      function Strlen (S : System.Address) return Integer;
+      pragma Import (C, Strlen, "strlen");
+
+      function Final_Value (S : String) return String;
+      --  Make final adjustment to the returned string. This function strips
+      --  trailing directory separators, and folds returned string to lower
+      --  case if required.
+
+      function Get_Directory  (Dir : String) return String;
+      --  If Dir is not empty, return it, adding a directory separator
+      --  if not already present, otherwise return current working directory
+      --  with terminating directory separator.
+
+      -----------------
+      -- Final_Value --
+      -----------------
+
+      function Final_Value (S : String) return String is
+         S1 : String := S;
+         --  We may need to fold S to lower case, so we need a variable
+
+         Last : Natural;
+
+      begin
+         if Fold_To_Lower_Case then
+            System.Case_Util.To_Lower (S1);
+         end if;
+
+         --  Remove trailing directory separator, if any
+
+         Last := S1'Last;
+
+         if Last > 1
+           and then (S1 (Last) = '/'
+                       or else
+                     S1 (Last) = Directory_Separator)
+         then
+            --  Special case for Windows: C:\
+
+            if Last = 3
+              and then S1 (1) /= Directory_Separator
+              and then S1 (2) = ':'
+            then
+               null;
+
+            else
+               Last := Last - 1;
+            end if;
+         end if;
+
+         return S1 (1 .. Last);
+      end Final_Value;
+
+      -------------------
+      -- Get_Directory --
+      -------------------
+
+      function Get_Directory (Dir : String) return String is
+         Result : String (1 .. Dir'Length + 1);
+         Length : constant Natural := Dir'Length;
+
+      begin
+         --  Directory given, add directory separator if needed
+
+         if Length > 0 then
+            Result (1 .. Length) := Dir;
+
+            --  On Windows, change all '/' to '\'
+
+            if On_Windows then
+               for J in 1 .. Length loop
+                  if Result (J) = '/' then
+                     Result (J) := Directory_Separator;
+                  end if;
+               end loop;
+            end if;
+
+            --  Add directory separator, if needed
+
+            if Result (Length) = Directory_Separator then
+               return Result (1 .. Length);
+            else
+               Result (Result'Length) := Directory_Separator;
+               return Result;
+            end if;
+
+         --  Directory name not given, get current directory
+
+         else
+            declare
+               Buffer   : String (1 .. Max_Path + 2);
+               Path_Len : Natural := Max_Path;
+
+            begin
+               Get_Current_Dir (Buffer'Address, Path_Len'Address);
+
+               if Buffer (Path_Len) /= Directory_Separator then
+                  Path_Len := Path_Len + 1;
+                  Buffer (Path_Len) := Directory_Separator;
+               end if;
+
+               --  By default, the drive letter on Windows is in upper case
+
+               if On_Windows
+                 and then Path_Len >= 2
+                 and then Buffer (2) = ':'
+               then
+                  System.Case_Util.To_Upper (Buffer (1 .. 1));
+               end if;
+
+               return Buffer (1 .. Path_Len);
+            end;
+         end if;
+      end Get_Directory;
+
+   --  Start of processing for Normalize_Pathname
+
+   begin
+      --  Special case, if name is null, then return null
+
+      if Name'Length = 0 then
+         return "";
+      end if;
+
+      --  First, convert VMS file spec to Unix file spec.
+      --  If Name is not in VMS syntax, then this is equivalent
+      --  to put Name at the beginning of Path_Buffer.
+
+      VMS_Conversion : begin
+         The_Name (1 .. Name'Length) := Name;
+         The_Name (The_Name'Last) := ASCII.NUL;
+
+         Canonical_File_Addr := To_Canonical_File_Spec (The_Name'Address);
+         Canonical_File_Len  := Strlen (Canonical_File_Addr);
+
+         --  If VMS syntax conversion has failed, return an empty string
+         --  to indicate the failure.
+
+         if Canonical_File_Len = 0 then
+            return "";
+         end if;
+
+         declare
+            subtype Path_String is String (1 .. Canonical_File_Len);
+            type    Path_String_Access is access Path_String;
+
+            function Address_To_Access is new
+               Ada.Unchecked_Conversion (Source => Address,
+                                     Target => Path_String_Access);
+
+            Path_Access : constant Path_String_Access :=
+                            Address_To_Access (Canonical_File_Addr);
+
+         begin
+            Path_Buffer (1 .. Canonical_File_Len) := Path_Access.all;
+            End_Path := Canonical_File_Len;
+            Last := 1;
+         end;
+      end VMS_Conversion;
+
+      --  Replace all '/' by Directory Separators (this is for Windows)
+
+      if Directory_Separator /= '/' then
+         for Index in 1 .. End_Path loop
+            if Path_Buffer (Index) = '/' then
+               Path_Buffer (Index) := Directory_Separator;
+            end if;
+         end loop;
+      end if;
+
+      --  Resolve directory names for Windows (formerly also VMS)
+
+      --  On VMS, if we have a Unix path such as /temp/..., and TEMP is a
+      --  logical name, we must not try to resolve this logical name, because
+      --  it may have multiple equivalences and if resolved we will only
+      --  get the first one.
+
+      if On_Windows then
+
+         --  On Windows, if we have an absolute path starting with a directory
+         --  separator, we need to have the drive letter appended in front.
+
+         --  On Windows, Get_Current_Dir will return a suitable directory name
+         --  (path starting with a drive letter on Windows). So we take this
+         --  drive letter and prepend it to the current path.
+
+         if Path_Buffer (1) = Directory_Separator
+           and then Path_Buffer (2) /= Directory_Separator
+         then
+            declare
+               Cur_Dir : constant String := Get_Directory ("");
+               --  Get the current directory to get the drive letter
+
+            begin
+               if Cur_Dir'Length > 2
+                 and then Cur_Dir (Cur_Dir'First + 1) = ':'
+               then
+                  Path_Buffer (3 .. End_Path + 2) :=
+                    Path_Buffer (1 .. End_Path);
+                  Path_Buffer (1 .. 2) :=
+                    Cur_Dir (Cur_Dir'First .. Cur_Dir'First + 1);
+                  End_Path := End_Path + 2;
+               end if;
+            end;
+
+         --  We have a drive letter, ensure it is upper-case
+
+         elsif Path_Buffer (1) in 'a' .. 'z'
+           and then Path_Buffer (2) = ':'
+         then
+            System.Case_Util.To_Upper (Path_Buffer (1 .. 1));
+         end if;
+      end if;
+
+      --  On Windows, remove all double-quotes that are possibly part of the
+      --  path but can cause problems with other methods.
+
+      if On_Windows then
+         declare
+            Index : Natural;
+
+         begin
+            Index := Path_Buffer'First;
+            for Current in Path_Buffer'First .. End_Path loop
+               if Path_Buffer (Current) /= '"' then
+                  Path_Buffer (Index) := Path_Buffer (Current);
+                  Index := Index + 1;
+               end if;
+            end loop;
+
+            End_Path := Index - 1;
+         end;
+      end if;
+
+      --  Start the conversions
+
+      --  If this is not finished after Max_Iterations, give up and return an
+      --  empty string.
+
+      for J in 1 .. Max_Iterations loop
+
+         --  If we don't have an absolute pathname, prepend the directory
+         --  Reference_Dir.
+
+         if Last = 1
+           and then not Is_Absolute_Path (Path_Buffer (1 .. End_Path))
+         then
+            declare
+               Reference_Dir : constant String  := Get_Directory (Directory);
+               Ref_Dir_Len   : constant Natural := Reference_Dir'Length;
+               --  Current directory name specified and its length
+
+            begin
+               Path_Buffer (Ref_Dir_Len + 1 .. Ref_Dir_Len + End_Path) :=
+                 Path_Buffer (1 .. End_Path);
+               End_Path := Ref_Dir_Len + End_Path;
+               Path_Buffer (1 .. Ref_Dir_Len) := Reference_Dir;
+               Last := Ref_Dir_Len;
+            end;
+         end if;
+
+         Start  := Last + 1;
+         Finish := Last;
+
+         --  Ensure that Windows network drives are kept, e.g: \\server\drive-c
+
+         if Start = 2
+           and then Directory_Separator = '\'
+           and then Path_Buffer (1 .. 2) = "\\"
+         then
+            Start := 3;
+         end if;
+
+         --  If we have traversed the full pathname, return it
+
+         if Start > End_Path then
+            return Final_Value (Path_Buffer (1 .. End_Path));
+         end if;
+
+         --  Remove duplicate directory separators
+
+         while Path_Buffer (Start) = Directory_Separator loop
+            if Start = End_Path then
+               return Final_Value (Path_Buffer (1 .. End_Path - 1));
+
+            else
+               Path_Buffer (Start .. End_Path - 1) :=
+                 Path_Buffer (Start + 1 .. End_Path);
+               End_Path := End_Path - 1;
+            end if;
+         end loop;
+
+         --  Find the end of the current field: last character or the one
+         --  preceding the next directory separator.
+
+         while Finish < End_Path
+           and then Path_Buffer (Finish + 1) /= Directory_Separator
+         loop
+            Finish := Finish + 1;
+         end loop;
+
+         --  Remove "." field
+
+         if Start = Finish and then Path_Buffer (Start) = '.' then
+            if Start = End_Path then
+               if Last = 1 then
+                  return (1 => Directory_Separator);
+               else
+
+                  if Fold_To_Lower_Case then
+                     System.Case_Util.To_Lower (Path_Buffer (1 .. Last - 1));
+                  end if;
+
+                  return Path_Buffer (1 .. Last - 1);
+
+               end if;
+
+            else
+               Path_Buffer (Last + 1 .. End_Path - 2) :=
+                 Path_Buffer (Last + 3 .. End_Path);
+               End_Path := End_Path - 2;
+            end if;
+
+         --  Remove ".." fields
+
+         elsif Finish = Start + 1
+           and then Path_Buffer (Start .. Finish) = ".."
+         then
+            Start := Last;
+            loop
+               Start := Start - 1;
+               exit when Start < 1
+                 or else Path_Buffer (Start) = Directory_Separator;
+            end loop;
+
+            if Start <= 1 then
+               if Finish = End_Path then
+                  return (1 => Directory_Separator);
+
+               else
+                  Path_Buffer (1 .. End_Path - Finish) :=
+                    Path_Buffer (Finish + 1 .. End_Path);
+                  End_Path := End_Path - Finish;
+                  Last := 1;
+               end if;
+
+            else
+               if Finish = End_Path then
+                  return Final_Value (Path_Buffer (1 .. Start - 1));
+
+               else
+                  Path_Buffer (Start + 1 .. Start + End_Path - Finish - 1) :=
+                    Path_Buffer (Finish + 2 .. End_Path);
+                  End_Path := Start + End_Path - Finish - 1;
+                  Last := Start;
+               end if;
+            end if;
+
+         --  Check if current field is a symbolic link
+
+         elsif Resolve_Links then
+            declare
+               Saved : constant Character := Path_Buffer (Finish + 1);
+
+            begin
+               Path_Buffer (Finish + 1) := ASCII.NUL;
+               Status := Readlink (Path_Buffer'Address,
+                                   Link_Buffer'Address,
+                                   Link_Buffer'Length);
+               Path_Buffer (Finish + 1) := Saved;
+            end;
+
+            --  Not a symbolic link, move to the next field, if any
+
+            if Status <= 0 then
+               Last := Finish + 1;
+
+            --  Replace symbolic link with its value
+
+            else
+               if Is_Absolute_Path (Link_Buffer (1 .. Status)) then
+                  Path_Buffer (Status + 1 .. End_Path - (Finish - Status)) :=
+                  Path_Buffer (Finish + 1 .. End_Path);
+                  End_Path := End_Path - (Finish - Status);
+                  Path_Buffer (1 .. Status) := Link_Buffer (1 .. Status);
+                  Last := 1;
+
+               else
+                  Path_Buffer
+                    (Last + Status + 1 .. End_Path - Finish + Last + Status) :=
+                    Path_Buffer (Finish + 1 .. End_Path);
+                  End_Path := End_Path - Finish + Last + Status;
+                  Path_Buffer (Last + 1 .. Last + Status) :=
+                    Link_Buffer (1 .. Status);
+               end if;
+            end if;
+
+         else
+            Last := Finish + 1;
+         end if;
+      end loop;
+
+      --  Too many iterations: give up
+
+      --  This can happen when there is a circularity in the symbolic links: A
+      --  is a symbolic link for B, which itself is a symbolic link, and the
+      --  target of B or of another symbolic link target of B is A. In this
+      --  case, we return an empty string to indicate failure to resolve.
+
+      return "";
+   end Normalize_Pathname;
+
+   ---------------
+   -- Open_Read --
+   ---------------
+
+   function Open_Read
+     (Name  : C_File_Name;
+      Fmode : Mode) return File_Descriptor
+   is
+      function C_Open_Read
+        (Name  : C_File_Name;
+         Fmode : Mode) return File_Descriptor;
+      pragma Import (C, C_Open_Read, "__gnat_open_read");
+   begin
+      return C_Open_Read (Name, Fmode);
+   end Open_Read;
+
+   function Open_Read
+     (Name  : String;
+      Fmode : Mode) return File_Descriptor
+   is
+      C_Name : String (1 .. Name'Length + 1);
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+      return Open_Read (C_Name (C_Name'First)'Address, Fmode);
+   end Open_Read;
+
+   ---------------------
+   -- Open_Read_Write --
+   ---------------------
+
+   function Open_Read_Write
+     (Name  : C_File_Name;
+      Fmode : Mode) return File_Descriptor
+   is
+      function C_Open_Read_Write
+        (Name  : C_File_Name;
+         Fmode : Mode) return File_Descriptor;
+      pragma Import (C, C_Open_Read_Write, "__gnat_open_rw");
+   begin
+      return C_Open_Read_Write (Name, Fmode);
+   end Open_Read_Write;
+
+   function Open_Read_Write
+     (Name  : String;
+      Fmode : Mode) return File_Descriptor
+   is
+      C_Name : String (1 .. Name'Length + 1);
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+      return Open_Read_Write (C_Name (C_Name'First)'Address, Fmode);
+   end Open_Read_Write;
+
+   -------------
+   -- OS_Exit --
+   -------------
+
+   procedure OS_Exit (Status : Integer) is
+   begin
+      OS_Exit_Ptr (Status);
+      raise Program_Error;
+   end OS_Exit;
+
+   ---------------------
+   -- OS_Exit_Default --
+   ---------------------
+
+   procedure OS_Exit_Default (Status : Integer) is
+      procedure GNAT_OS_Exit (Status : Integer);
+      pragma Import (C, GNAT_OS_Exit, "__gnat_os_exit");
+      pragma No_Return (GNAT_OS_Exit);
+   begin
+      GNAT_OS_Exit (Status);
+   end OS_Exit_Default;
+
+   --------------------
+   -- Pid_To_Integer --
+   --------------------
+
+   function Pid_To_Integer (Pid : Process_Id) return Integer is
+   begin
+      return Integer (Pid);
+   end Pid_To_Integer;
+
+   ----------
+   -- Read --
+   ----------
+
+   function Read
+     (FD : File_Descriptor;
+      A  : System.Address;
+      N  : Integer) return Integer
+   is
+   begin
+      return
+        Integer (System.CRTL.read
+                   (System.CRTL.int (FD),
+                    System.CRTL.chars (A),
+                    System.CRTL.size_t (N)));
+   end Read;
+
+   -----------------
+   -- Rename_File --
+   -----------------
+
+   procedure Rename_File
+     (Old_Name : C_File_Name;
+      New_Name : C_File_Name;
+      Success  : out Boolean)
+   is
+      function rename (From, To : Address) return Integer;
+      pragma Import (C, rename, "__gnat_rename");
+      R : Integer;
+   begin
+      R := rename (Old_Name, New_Name);
+      Success := (R = 0);
+   end Rename_File;
+
+   procedure Rename_File
+     (Old_Name : String;
+      New_Name : String;
+      Success  : out Boolean)
+   is
+      C_Old_Name : String (1 .. Old_Name'Length + 1);
+      C_New_Name : String (1 .. New_Name'Length + 1);
+   begin
+      C_Old_Name (1 .. Old_Name'Length) := Old_Name;
+      C_Old_Name (C_Old_Name'Last)      := ASCII.NUL;
+      C_New_Name (1 .. New_Name'Length) := New_Name;
+      C_New_Name (C_New_Name'Last)      := ASCII.NUL;
+      Rename_File (C_Old_Name'Address, C_New_Name'Address, Success);
+   end Rename_File;
+
+   -----------------------
+   -- Set_Close_On_Exec --
+   -----------------------
+
+   procedure Set_Close_On_Exec
+     (FD            : File_Descriptor;
+      Close_On_Exec : Boolean;
+      Status        : out Boolean)
+   is
+      function C_Set_Close_On_Exec
+        (FD : File_Descriptor; Close_On_Exec : System.CRTL.int)
+         return System.CRTL.int;
+      pragma Import (C, C_Set_Close_On_Exec, "__gnat_set_close_on_exec");
+   begin
+      Status := C_Set_Close_On_Exec (FD, Boolean'Pos (Close_On_Exec)) = 0;
+   end Set_Close_On_Exec;
+
+   --------------------
+   -- Set_Executable --
+   --------------------
+
+   procedure Set_Executable (Name : String) is
+      procedure C_Set_Executable (Name : C_File_Name);
+      pragma Import (C, C_Set_Executable, "__gnat_set_executable");
+      C_Name : aliased String (Name'First .. Name'Last + 1);
+   begin
+      C_Name (Name'Range)  := Name;
+      C_Name (C_Name'Last) := ASCII.NUL;
+      C_Set_Executable (C_Name (C_Name'First)'Address);
+   end Set_Executable;
+
+   ----------------------
+   -- Set_Non_Readable --
+   ----------------------
+
+   procedure Set_Non_Readable (Name : String) is
+      procedure C_Set_Non_Readable (Name : C_File_Name);
+      pragma Import (C, C_Set_Non_Readable, "__gnat_set_non_readable");
+      C_Name : aliased String (Name'First .. Name'Last + 1);
+   begin
+      C_Name (Name'Range)  := Name;
+      C_Name (C_Name'Last) := ASCII.NUL;
+      C_Set_Non_Readable (C_Name (C_Name'First)'Address);
+   end Set_Non_Readable;
+
+   ----------------------
+   -- Set_Non_Writable --
+   ----------------------
+
+   procedure Set_Non_Writable (Name : String) is
+      procedure C_Set_Non_Writable (Name : C_File_Name);
+      pragma Import (C, C_Set_Non_Writable, "__gnat_set_non_writable");
+      C_Name : aliased String (Name'First .. Name'Last + 1);
+   begin
+      C_Name (Name'Range)  := Name;
+      C_Name (C_Name'Last) := ASCII.NUL;
+      C_Set_Non_Writable (C_Name (C_Name'First)'Address);
+   end Set_Non_Writable;
+
+   ------------------
+   -- Set_Readable --
+   ------------------
+
+   procedure Set_Readable (Name : String) is
+      procedure C_Set_Readable (Name : C_File_Name);
+      pragma Import (C, C_Set_Readable, "__gnat_set_readable");
+      C_Name : aliased String (Name'First .. Name'Last + 1);
+   begin
+      C_Name (Name'Range)  := Name;
+      C_Name (C_Name'Last) := ASCII.NUL;
+      C_Set_Readable (C_Name (C_Name'First)'Address);
+   end Set_Readable;
+
+   --------------------
+   -- Set_Writable --
+   --------------------
+
+   procedure Set_Writable (Name : String) is
+      procedure C_Set_Writable (Name : C_File_Name);
+      pragma Import (C, C_Set_Writable, "__gnat_set_writable");
+      C_Name : aliased String (Name'First .. Name'Last + 1);
+   begin
+      C_Name (Name'Range)  := Name;
+      C_Name (C_Name'Last) := ASCII.NUL;
+      C_Set_Writable (C_Name (C_Name'First)'Address);
+   end Set_Writable;
+
+   ------------
+   -- Setenv --
+   ------------
+
+   procedure Setenv (Name : String; Value : String) is
+      F_Name  : String (1 .. Name'Length + 1);
+      F_Value : String (1 .. Value'Length + 1);
+
+      procedure Set_Env_Value (Name, Value : System.Address);
+      pragma Import (C, Set_Env_Value, "__gnat_setenv");
+
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+
+      F_Value (1 .. Value'Length) := Value;
+      F_Value (F_Value'Last)      := ASCII.NUL;
+
+      Set_Env_Value (F_Name'Address, F_Value'Address);
+   end Setenv;
+
+   -----------
+   -- Spawn --
+   -----------
+
+   function Spawn
+     (Program_Name : String;
+      Args         : Argument_List) return Integer
+   is
+      Result : Integer;
+      Junk   : Process_Id;
+      pragma Warnings (Off, Junk);
+   begin
+      Spawn_Internal (Program_Name, Args, Result, Junk, Blocking => True);
+      return Result;
+   end Spawn;
+
+   procedure Spawn
+     (Program_Name : String;
+      Args         : Argument_List;
+      Success      : out Boolean)
+   is
+   begin
+      Success := (Spawn (Program_Name, Args) = 0);
+   end Spawn;
+
+   procedure Spawn
+     (Program_Name           : String;
+      Args                   : Argument_List;
+      Output_File_Descriptor : File_Descriptor;
+      Return_Code            : out Integer;
+      Err_To_Out             : Boolean := True)
+   is
+      Saved_Output : File_Descriptor;
+      Saved_Error  : File_Descriptor := Invalid_FD; -- prevent compiler warning
+
+   begin
+      --  Set standard output and error to the temporary file
+
+      Saved_Output := Dup (Standout);
+      Dup2 (Output_File_Descriptor, Standout);
+
+      if Err_To_Out then
+         Saved_Error  := Dup (Standerr);
+         Dup2 (Output_File_Descriptor, Standerr);
+      end if;
+
+      --  Spawn the program
+
+      Return_Code := Spawn (Program_Name, Args);
+
+      --  Restore the standard output and error
+
+      Dup2 (Saved_Output, Standout);
+
+      if Err_To_Out then
+         Dup2 (Saved_Error, Standerr);
+      end if;
+
+      --  And close the saved standard output and error file descriptors
+
+      Close (Saved_Output);
+
+      if Err_To_Out then
+         Close (Saved_Error);
+      end if;
+   end Spawn;
+
+   procedure Spawn
+     (Program_Name : String;
+      Args         : Argument_List;
+      Output_File  : String;
+      Success      : out Boolean;
+      Return_Code  : out Integer;
+      Err_To_Out   : Boolean := True)
+   is
+      FD : File_Descriptor;
+
+   begin
+      Success := True;
+      Return_Code := 0;
+
+      FD := Create_Output_Text_File (Output_File);
+
+      if FD = Invalid_FD then
+         Success := False;
+         return;
+      end if;
+
+      Spawn (Program_Name, Args, FD, Return_Code, Err_To_Out);
+
+      Close (FD, Success);
+   end Spawn;
+
+   --------------------
+   -- Spawn_Internal --
+   --------------------
+
+   procedure Spawn_Internal
+     (Program_Name : String;
+      Args         : Argument_List;
+      Result       : out Integer;
+      Pid          : out Process_Id;
+      Blocking     : Boolean)
+   is
+
+      procedure Spawn (Args : Argument_List);
+      --  Call Spawn with given argument list
+
+      N_Args : Argument_List (Args'Range);
+      --  Normalized arguments
+
+      -----------
+      -- Spawn --
+      -----------
+
+      procedure Spawn (Args : Argument_List) is
+         type Chars is array (Positive range <>) of aliased Character;
+         type Char_Ptr is access constant Character;
+
+         Command_Len  : constant Positive := Program_Name'Length + 1
+                                               + Args_Length (Args);
+         Command_Last : Natural := 0;
+         Command      : aliased Chars (1 .. Command_Len);
+         --  Command contains all characters of the Program_Name and Args, all
+         --  terminated by ASCII.NUL characters.
+
+         Arg_List_Len  : constant Positive := Args'Length + 2;
+         Arg_List_Last : Natural := 0;
+         Arg_List      : aliased array (1 .. Arg_List_Len) of Char_Ptr;
+         --  List with pointers to NUL-terminated strings of the Program_Name
+         --  and the Args and terminated with a null pointer. We rely on the
+         --  default initialization for the last null pointer.
+
+         procedure Add_To_Command (S : String);
+         --  Add S and a NUL character to Command, updating Last
+
+         function Portable_Spawn (Args : Address) return Integer;
+         pragma Import (C, Portable_Spawn, "__gnat_portable_spawn");
+
+         function Portable_No_Block_Spawn (Args : Address) return Process_Id;
+         pragma Import
+           (C, Portable_No_Block_Spawn, "__gnat_portable_no_block_spawn");
+
+         --------------------
+         -- Add_To_Command --
+         --------------------
+
+         procedure Add_To_Command (S : String) is
+            First : constant Natural := Command_Last + 1;
+
+         begin
+            Command_Last := Command_Last + S'Length;
+
+            --  Move characters one at a time, because Command has aliased
+            --  components.
+
+            --  But not volatile, so why is this necessary ???
+
+            for J in S'Range loop
+               Command (First + J - S'First) := S (J);
+            end loop;
+
+            Command_Last := Command_Last + 1;
+            Command (Command_Last) := ASCII.NUL;
+
+            Arg_List_Last := Arg_List_Last + 1;
+            Arg_List (Arg_List_Last) := Command (First)'Access;
+         end Add_To_Command;
+
+      --  Start of processing for Spawn
+
+      begin
+         Add_To_Command (Program_Name);
+
+         for J in Args'Range loop
+            Add_To_Command (Args (J).all);
+         end loop;
+
+         if Blocking then
+            Pid     := Invalid_Pid;
+            Result  := Portable_Spawn (Arg_List'Address);
+         else
+            Pid     := Portable_No_Block_Spawn (Arg_List'Address);
+            Result  := Boolean'Pos (Pid /= Invalid_Pid);
+         end if;
+      end Spawn;
+
+   --  Start of processing for Spawn_Internal
+
+   begin
+      --  Copy arguments into a local structure
+
+      for K in N_Args'Range loop
+         N_Args (K) := new String'(Args (K).all);
+      end loop;
+
+      --  Normalize those arguments
+
+      Normalize_Arguments (N_Args);
+
+      --  Call spawn using the normalized arguments
+
+      Spawn (N_Args);
+
+      --  Free arguments list
+
+      for K in N_Args'Range loop
+         Free (N_Args (K));
+      end loop;
+   end Spawn_Internal;
+
+   ---------------------------
+   -- To_Path_String_Access --
+   ---------------------------
+
+   function To_Path_String_Access
+     (Path_Addr : Address;
+      Path_Len  : Integer) return String_Access
+   is
+      subtype Path_String is String (1 .. Path_Len);
+      type    Path_String_Access is access Path_String;
+
+      function Address_To_Access is new Ada.Unchecked_Conversion
+        (Source => Address, Target => Path_String_Access);
+
+      Path_Access : constant Path_String_Access :=
+                      Address_To_Access (Path_Addr);
+
+      Return_Val  : String_Access;
+
+   begin
+      Return_Val := new String (1 .. Path_Len);
+
+      for J in 1 .. Path_Len loop
+         Return_Val (J) := Path_Access (J);
+      end loop;
+
+      return Return_Val;
+   end To_Path_String_Access;
+
+   ------------------
+   -- Wait_Process --
+   ------------------
+
+   procedure Wait_Process (Pid : out Process_Id; Success : out Boolean) is
+      Status : Integer;
+
+      function Portable_Wait (S : Address) return Process_Id;
+      pragma Import (C, Portable_Wait, "__gnat_portable_wait");
+
+   begin
+      Pid := Portable_Wait (Status'Address);
+      Success := (Status = 0);
+   end Wait_Process;
+
+   -----------
+   -- Write --
+   -----------
+
+   function Write
+     (FD : File_Descriptor;
+      A  : System.Address;
+      N  : Integer) return Integer
+   is
+   begin
+      return
+        Integer (System.CRTL.write
+                   (System.CRTL.int (FD),
+                    System.CRTL.chars (A),
+                    System.CRTL.size_t (N)));
+   end Write;
+
+end System.OS_Lib;
diff --git a/gcc/ada/s-os_lib_adb.patch b/gcc/ada/s-os_lib_adb.patch
new file mode 100644
index 000000000..b1021845f
--- /dev/null
+++ b/gcc/ada/s-os_lib_adb.patch
@@ -0,0 +1,11 @@
+--- s-os_lib.adb	2012-08-01 23:55:09.357901307 +0300
++++ s-os_lib-djgpp.adb	2012-06-23 13:36:27.000000000 +0300
+@@ -57,7 +57,7 @@
+ 
+    --  The following are used by Create_Temp_File
+ 
+-   First_Temp_File_Name : constant String := "GNAT-TEMP-000000.TMP";
++   First_Temp_File_Name : constant String := "GA000000.TMP";
+    --  Used to initialize Current_Temp_File_Name and Temp_File_Name_Last_Digit
+ 
+    Current_Temp_File_Name : String := First_Temp_File_Name;
diff --git a/gcc/ada/sysdep.c b/gcc/ada/sysdep.c
index aee200a8d..5d0be9743 100644
--- a/gcc/ada/sysdep.c
+++ b/gcc/ada/sysdep.c
@@ -158,7 +158,7 @@ extern struct tm *localtime_r(const time_t *, struct tm *);
 
 */
 
-#if defined(WINNT)
+#if defined(WINNT) || defined(MSDOS)
 static const char *mode_read_text = "rt";
 static const char *mode_write_text = "wt";
 static const char *mode_append_text = "at";
@@ -173,6 +173,11 @@ static const char *mode_write_binary_plus = "w+b";
 static const char *mode_append_binary_plus = "a+b";
 const char __gnat_text_translation_required = 1;
 
+#if defined(__DJGPP__)
+#include <io.h>
+#define _setmode setmode
+#endif /* __DJGPP__ */
+
 void
 __gnat_set_binary_mode (int handle)
 {
@@ -732,7 +737,29 @@ long __gnat_invalid_tzoff = 259273;
 
 /* Definition of __gnat_localtime_r used by a-calend.adb */
 
-#if defined (__MINGW32__)
+#if defined (__DJGPP__)
+
+/* FIXME: this is draft version only. Fix me if that is not correct  */
+/*        or not complete (AP)                                       */
+
+extern void
+__gnat_localtime_tzoff (const time_t *, long *);
+
+void
+__gnat_localtime_tzoff (const time_t *timer, long *off)
+{
+  struct tm *tmp;
+
+  tmp = localtime (timer);
+  *off = (long) -tmp->tm_gmtoff;
+
+  /* Correct the offset if Daylight Saving Time is in effect */
+
+  if (tmp->tm_isdst > 0)
+    *off = *off + 3600;
+}
+
+#elif defined (__MINGW32__)
 
 #ifdef CERT
 
diff --git a/gcc/ada/system-djgpp.ads b/gcc/ada/system-djgpp.ads
new file mode 100644
index 000000000..8ff3cbcbb
--- /dev/null
+++ b/gcc/ada/system-djgpp.ads
@@ -0,0 +1,170 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                            (Compiler Version)                            --
+--                                                                          --
+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This version of System is a generic version that is used in building the
+--  compiler. Right now, we have a host/target problem if we try to use the
+--  "proper" System, and since the compiler itself does not care about most
+--  System parameters, this generic version works fine.
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.01;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   --  Note that we do NOT add pragma Preelaborable_Initialization in this
+   --  version of System, since it is used for the compiler only, and typical
+   --  earlier bootstrap compilers don't support this pragma. We don't need
+   --  it in this context, so there is no problem in omitting it.
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := Standard'Storage_Unit;
+   Word_Size    : constant := Standard'Word_Size;
+   Memory_Size  : constant := 2 ** Standard'Address_Size;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order :=
+                         Bit_Order'Val (Standard'Default_Bit_Order);
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   --  This version of system.ads is used only for building the compiler.
+   --  We really ought to use the proper target system (i.e. the one that
+   --  corresponds to the host for the compiler), but that causes as yet
+   --  unsolved makefile problems. For the most part the setting of these
+   --  parameters is not too critical for the compiler version (e.g. we
+   --  do not use floating-point anyway in the compiler).
+
+   AAMP                      : constant Boolean := False;
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := False;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   OpenVMS                   : constant Boolean := False;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := False;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_64_Bit_Divides    : constant Boolean := True;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := True;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := False;
+   GCC_ZCX_Support           : constant Boolean := False;
+
+   --  Obsolete entries, to be removed eventually (bootstrap issues!)
+
+   Front_End_ZCX_Support     : constant Boolean := False;
+   High_Integrity_Mode       : constant Boolean := False;
+   Long_Shifts_Inlined       : constant Boolean := True;
+   Functions_Return_By_DSP   : constant Boolean := False;
+
+end System;
diff --git a/gcc/c-decl.c b/gcc/c-decl.c
index 44c0ec772..88226007d 100644
--- a/gcc/c-decl.c
+++ b/gcc/c-decl.c
@@ -1706,8 +1706,10 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,
 	      /* If types don't match for a built-in, throw away the
 		 built-in.  No point in calling locate_old_decl here, it
 		 won't print anything.  */
+#ifndef __DJGPP__
 	      warning (0, "conflicting types for built-in function %q+D",
 		       newdecl);
+#endif
 	      return false;
 	    }
 	}
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 6dc2427bc..181351e56 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -3674,6 +3674,9 @@ case ${target} in
 		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp i386/t-linux i386/t-gnu"
 		;;
 	i[34567]86-*-solaris2*)
+		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp"
+                ;;
+	i[34567]86-*-msdosdjgpp*)
 		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp"
 		;;
 	i[34567]86-*-cygwin* | i[34567]86-*-mingw* | x86_64-*-mingw*)
diff --git a/gcc/config.host b/gcc/config.host
index d0342b996..366f9d204 100644
--- a/gcc/config.host
+++ b/gcc/config.host
@@ -204,12 +204,17 @@ case ${host} in
   i[34567]86-pc-msdosdjgpp*)
     host_xm_file=i386/xm-djgpp.h
     host_exeext=.exe
+    host_xmake_file="${host_xmake_file} i386/x-djgpp"
     # Shorten $target_noncanonical for 8.3 filename conventions.
+    # Also update C++ include directory name
+    # due to the same restrictions
     case ${target} in
       *pc-msdosdjgpp*)
         target_noncanonical=djgpp
+	libstdcxx_incdir_base=cxx
         ;;
     esac
+	
     ;;
   i[34567]86-*-pe | i[34567]86-*-cygwin*)
     host_xm_file=i386/xm-cygwin.h
diff --git a/gcc/config/avr/avr-c.c b/gcc/config/avr/avr-c.c
index 05e8e8b30..57e92d1fb 100644
--- a/gcc/config/avr/avr-c.c
+++ b/gcc/config/avr/avr-c.c
@@ -1,85 +1,85 @@
-/* Copyright (C) 2009, 2010
-   Free Software Foundation, Inc.
-   Contributed by Anatoly Sokolov (aesok@post.ru)
-
-   This file is part of GCC.
-
-   GCC is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-   
-   GCC is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with GCC; see the file COPYING3.  If not see
-   <http://www.gnu.org/licenses/>.  */
-
-
-#include "config.h"
-#include "system.h"
-#include "coretypes.h"
-#include "tm.h"
-#include "tm_p.h"
-#include "cpplib.h"
-#include "tree.h"
-#include "c-family/c-common.h"
-
-/* Not included in avr.c since this requires C front end.  */
-
-/* Worker function for TARGET_CPU_CPP_BUILTINS.  */
-
-void
-avr_cpu_cpp_builtins (struct cpp_reader *pfile)
-{
-  builtin_define_std ("AVR");
-
-  if (avr_current_arch->macro)
-    cpp_define (pfile, avr_current_arch->macro);
-  if (avr_extra_arch_macro)
-    cpp_define (pfile, avr_extra_arch_macro);
-  if (avr_current_arch->have_elpm)
-    cpp_define (pfile, "__AVR_HAVE_RAMPZ__");
-  if (avr_current_arch->have_elpm)
-    cpp_define (pfile, "__AVR_HAVE_ELPM__");
-  if (avr_current_arch->have_elpmx)
-    cpp_define (pfile, "__AVR_HAVE_ELPMX__");
-  if (avr_current_arch->have_movw_lpmx)
-    {
-      cpp_define (pfile, "__AVR_HAVE_MOVW__");
-      cpp_define (pfile, "__AVR_HAVE_LPMX__");
-    }
-  if (avr_current_arch->asm_only)
-    cpp_define (pfile, "__AVR_ASM_ONLY__");
-  if (avr_current_arch->have_mul)
-    {
-      cpp_define (pfile, "__AVR_ENHANCED__");
-      cpp_define (pfile, "__AVR_HAVE_MUL__");
-    }
-  if (avr_current_arch->have_jmp_call)
-    {
-      cpp_define (pfile, "__AVR_MEGA__");
-      cpp_define (pfile, "__AVR_HAVE_JMP_CALL__");
-    }
-  if (avr_current_arch->have_eijmp_eicall)
-    {
-      cpp_define (pfile, "__AVR_HAVE_EIJMP_EICALL__");
-      cpp_define (pfile, "__AVR_3_BYTE_PC__");
-    }
-  else
-    {
-      cpp_define (pfile, "__AVR_2_BYTE_PC__");
-    }
-
-  if (avr_current_device->short_sp)
-    cpp_define (pfile, "__AVR_HAVE_8BIT_SP__");
-  else
-    cpp_define (pfile, "__AVR_HAVE_16BIT_SP__");
-
-  if (TARGET_NO_INTERRUPTS)
-    cpp_define (pfile, "__NO_INTERRUPTS__");
-}
-
+/* Copyright (C) 2009, 2010
+   Free Software Foundation, Inc.
+   Contributed by Anatoly Sokolov (aesok@post.ru)
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+   
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tm_p.h"
+#include "cpplib.h"
+#include "tree.h"
+#include "c-family/c-common.h"
+
+/* Not included in avr.c since this requires C front end.  */
+
+/* Worker function for TARGET_CPU_CPP_BUILTINS.  */
+
+void
+avr_cpu_cpp_builtins (struct cpp_reader *pfile)
+{
+  builtin_define_std ("AVR");
+
+  if (avr_current_arch->macro)
+    cpp_define (pfile, avr_current_arch->macro);
+  if (avr_extra_arch_macro)
+    cpp_define (pfile, avr_extra_arch_macro);
+  if (avr_current_arch->have_elpm)
+    cpp_define (pfile, "__AVR_HAVE_RAMPZ__");
+  if (avr_current_arch->have_elpm)
+    cpp_define (pfile, "__AVR_HAVE_ELPM__");
+  if (avr_current_arch->have_elpmx)
+    cpp_define (pfile, "__AVR_HAVE_ELPMX__");
+  if (avr_current_arch->have_movw_lpmx)
+    {
+      cpp_define (pfile, "__AVR_HAVE_MOVW__");
+      cpp_define (pfile, "__AVR_HAVE_LPMX__");
+    }
+  if (avr_current_arch->asm_only)
+    cpp_define (pfile, "__AVR_ASM_ONLY__");
+  if (avr_current_arch->have_mul)
+    {
+      cpp_define (pfile, "__AVR_ENHANCED__");
+      cpp_define (pfile, "__AVR_HAVE_MUL__");
+    }
+  if (avr_current_arch->have_jmp_call)
+    {
+      cpp_define (pfile, "__AVR_MEGA__");
+      cpp_define (pfile, "__AVR_HAVE_JMP_CALL__");
+    }
+  if (avr_current_arch->have_eijmp_eicall)
+    {
+      cpp_define (pfile, "__AVR_HAVE_EIJMP_EICALL__");
+      cpp_define (pfile, "__AVR_3_BYTE_PC__");
+    }
+  else
+    {
+      cpp_define (pfile, "__AVR_2_BYTE_PC__");
+    }
+
+  if (avr_current_device->short_sp)
+    cpp_define (pfile, "__AVR_HAVE_8BIT_SP__");
+  else
+    cpp_define (pfile, "__AVR_HAVE_16BIT_SP__");
+
+  if (TARGET_NO_INTERRUPTS)
+    cpp_define (pfile, "__NO_INTERRUPTS__");
+}
+
diff --git a/gcc/config/i386/djgpp-stack.c b/gcc/config/i386/djgpp-stack.c
new file mode 100644
index 000000000..893b5037a
--- /dev/null
+++ b/gcc/config/i386/djgpp-stack.c
@@ -0,0 +1,10 @@
+/*
+
+The default stack size (512KB) for DJGPP applications is not
+sufficient for several GCC executables like
+cc1.exe, cc1plus.exe, etc.
+
+Redefine it to larger value (2MB).
+
+*/
+int _stklen = 2097152;
diff --git a/gcc/config/i386/djgpp-stdint.h b/gcc/config/i386/djgpp-stdint.h
index 8fd3a2565..91d31e57e 100644
--- a/gcc/config/i386/djgpp-stdint.h
+++ b/gcc/config/i386/djgpp-stdint.h
@@ -22,21 +22,21 @@ along with GCC; see the file COPYING3.  If not see
 /* Exact-width integer types */
 
 #define INT8_TYPE "signed char"
-#define INT16_TYPE "signed short int"
-#define INT32_TYPE "signed long int"
-#define INT64_TYPE "signed long long int"
+#define INT16_TYPE "short int"
+#define INT32_TYPE "int"
+#define INT64_TYPE "long long int"
 
 #define UINT8_TYPE "unsigned char"
 #define UINT16_TYPE "short unsigned int"
-#define UINT32_TYPE "long unsigned int"
+#define UINT32_TYPE "unsigned int"
 #define UINT64_TYPE "long long unsigned int"
 
 /* Minimum-width integer types */
 
 #define INT_LEAST8_TYPE "signed char"
-#define INT_LEAST16_TYPE "signed short int"
-#define INT_LEAST32_TYPE "signed int"
-#define INT_LEAST64_TYPE "signed long long int"
+#define INT_LEAST16_TYPE "short int"
+#define INT_LEAST32_TYPE "int"
+#define INT_LEAST64_TYPE "long long int"
 
 #define UINT_LEAST8_TYPE "unsigned char"
 #define UINT_LEAST16_TYPE "short unsigned int"
@@ -46,12 +46,12 @@ along with GCC; see the file COPYING3.  If not see
 /* Fastest minimum-width integer types */
 
 #define INT_FAST8_TYPE "signed char"
-#define INT_FAST16_TYPE "signed int"
-#define INT_FAST32_TYPE "signed int"
-#define INT_FAST64_TYPE "long long signed int"
+#define INT_FAST16_TYPE "short int"
+#define INT_FAST32_TYPE "int"
+#define INT_FAST64_TYPE "long long int"
 
 #define UINT_FAST8_TYPE "unsigned char"
-#define UINT_FAST16_TYPE "unsigned int"
+#define UINT_FAST16_TYPE "short unsigned int"
 #define UINT_FAST32_TYPE "unsigned int"
 #define UINT_FAST64_TYPE "long long unsigned int"
 
diff --git a/gcc/config/i386/djgpp.h b/gcc/config/i386/djgpp.h
index 34a15facb..948971bf0 100644
--- a/gcc/config/i386/djgpp.h
+++ b/gcc/config/i386/djgpp.h
@@ -21,6 +21,11 @@ along with GCC; see the file COPYING3.  If not see
 /* Support generation of DWARF2 debugging info.  */
 #define DWARF2_DEBUGGING_INFO 1
 
+/* Use DWARF2 debugging info by default: comment out following  */
+/* 2 lines to default to COFF debugging info  */
+#undef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+
 /* Don't assume anything about the header files.  */
 #define NO_IMPLICIT_EXTERN_C
 
@@ -51,59 +56,27 @@ along with GCC; see the file COPYING3.  If not see
 #undef TEXT_SECTION_ASM_OP
 #define TEXT_SECTION_ASM_OP "\t.section .text"
 
-/* Define standard DJGPP installation paths.  */
-/* We override default /usr or /usr/local part with /dev/env/DJDIR which */
-/* points to actual DJGPP installation directory.  */
-
-/* Standard include directory */
-#undef STANDARD_INCLUDE_DIR
-#define STANDARD_INCLUDE_DIR "/dev/env/DJDIR/include/"
-
-/* Search for as.exe and ld.exe in DJGPP's binary directory.  */ 
-#undef MD_EXEC_PREFIX
-#define MD_EXEC_PREFIX "/dev/env/DJDIR/bin/"
-
-/* Standard DJGPP library and startup files */
-#undef MD_STARTFILE_PREFIX
-#define MD_STARTFILE_PREFIX "/dev/env/DJDIR/lib/"
-
-/* Correctly handle absolute filename detection in cp/xref.c */
-#define FILE_NAME_ABSOLUTE_P(NAME) \
-        (((NAME)[0] == '/') || ((NAME)[0] == '\\') || \
-        (((NAME)[0] >= 'A') && ((NAME)[0] <= 'z') && ((NAME)[1] == ':')))
-
 #define TARGET_OS_CPP_BUILTINS()		\
   do						\
     {						\
+        if (!flag_iso)                          \
+	   builtin_define_with_int_value ("DJGPP",2);  \
+	builtin_define_with_int_value ("__DJGPP",2);   \
+	builtin_define_with_int_value ("__DJGPP__",2); \
 	builtin_define_std ("MSDOS");		\
 	builtin_define_std ("GO32");		\
+	builtin_define_std ("unix");		\
 	builtin_assert ("system=msdos");	\
     }						\
   while (0)
 
 /* Include <sys/version.h> so __DJGPP__ and __DJGPP_MINOR__ are defined.  */
 #undef CPP_SPEC
-#define CPP_SPEC "-remap %{posix:-D_POSIX_SOURCE} \
-  -imacros %s../include/sys/version.h"
-
-/* We need to override link_command_spec in gcc.c so support -Tdjgpp.djl.
-   This cannot be done in LINK_SPECS as that LINK_SPECS is processed
-   before library search directories are known by the linker.
-   This avoids problems when specs file is not available. An alternate way,
-   suggested by Robert Hoehne, is to use SUBTARGET_EXTRA_SPECS instead.
-*/ 
-
-#undef LINK_COMMAND_SPEC
-#define LINK_COMMAND_SPEC \
-"%{!fsyntax-only: \
-%{!c:%{!M:%{!MM:%{!E:%{!S:%(linker) %l %X %{o*} %{e*} %{N} %{n} \
-\t%{r} %{s} %{t} %{u*} %{z} %{Z}\
-\t%{!nostdlib:%{!nostartfiles:%S}}\
-\t%{static:} %{L*} %D %o\
-\t%{!nostdlib:%{!nodefaultlibs:%G %L %G}}\
-\t%{!nostdlib:%{!nostartfiles:%E}}\
-\t-Tdjgpp.djl %{T*}}}}}}}\n\
-%{!c:%{!M:%{!MM:%{!E:%{!S:stubify %{v} %{o*:%*} %{!o*:a.out} }}}}}"
+#define CPP_SPEC "-remap %{posix:-D_POSIX_SOURCE}"
+  
+
+#undef POST_LINK_SPEC
+#define POST_LINK_SPEC "stubify %{v} %{o*:%*} %{!o*:a.out}"
 
 /* Always just link in 'libc.a'.  */
 #undef LIB_SPEC
@@ -113,10 +86,6 @@ along with GCC; see the file COPYING3.  If not see
 #undef STARTFILE_SPEC
 #define STARTFILE_SPEC "%{pg:gcrt0.o%s}%{!pg:crt0.o%s}"
 
-/* Make sure that gcc will not look for .h files in /usr/local/include 
-   unless user explicitly requests it.  */
-#undef LOCAL_INCLUDE_DIR
-
 /* Switch into a generic section.  */
 #define TARGET_ASM_NAMED_SECTION  default_coff_asm_named_section
 
@@ -180,3 +149,28 @@ while (0)
 /* Support for C++ templates.  */
 #undef MAKE_DECL_ONE_ONLY
 #define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)
+
+#undef DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(n) svr4_dbx_register_map[n]
+
+/* Default to pcc-struct-return.  */
+#define DEFAULT_PCC_STRUCT_RETURN 1
+
+/* Put all *tf routines in libgcc.  */
+#undef LIBGCC2_HAS_TF_MODE
+#define LIBGCC2_HAS_TF_MODE 1
+#define LIBGCC2_TF_CEXT q
+#define TF_SIZE 113
+
+/* Ignore (with warning) -fPIC for DJGPP */
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS                               \
+    do {                                                         \
+        if (flag_pic)                                            \
+        {                                                        \
+            warning(0, "-f%s ignored (not supported for DJGPP)", \
+                (flag_pic > 1) ? "PIC" : "pic");                 \
+            flag_pic = 0;                                        \
+        }                                                        \
+    }                                                            \
+    while (0)
diff --git a/gcc/config/i386/djgpp.opt b/gcc/config/i386/djgpp.opt
index 7e4affca9..8e7fd1cde 100644
--- a/gcc/config/i386/djgpp.opt
+++ b/gcc/config/i386/djgpp.opt
@@ -18,11 +18,5 @@
 ; along with GCC; see the file COPYING3.  If not see
 ; <http://www.gnu.org/licenses/>.
 
-;; -mbnu210 is now ignored and obsolete.  It was used to enable support for
-;; weak symbols, and .gnu.linkonce support.
-mbnu210
-Target Var(TARGET_BNU210)
-Ignored (obsolete)
-
 posix
 Driver
diff --git a/gcc/config/i386/nmalloc/cokusmt.c b/gcc/config/i386/nmalloc/cokusmt.c
new file mode 100644
index 000000000..d9685b756
--- /dev/null
+++ b/gcc/config/i386/nmalloc/cokusmt.c
@@ -0,0 +1,185 @@
+/* FILE cokusmt.c */
+/* This is a miniscule cleanup of the source downloaded from:  */
+/*       http://www.math.keio.ac.jp/~matumoto/ver980409.html   */
+
+/* This is the "Mersenne Twister" random number generator MT19937,
+// which generates pseudorandom integers uniformly distributed in
+// 0..(2^32 - 1) starting from any odd seed in 0..(2^32 - 1).  This
+// version is a recode by Shawn Cokus (Cokus@math.washington.edu) on
+// March 8, 1998 of a version by Takuji Nishimura (who had suggestions
+// from Topher Cooper and Marc Rieffel in July-August 1997).
+//
+// Effectiveness of the recoding (on Goedel2.math.washington.edu, a
+// DEC Alpha running OSF/1) using GCC -O3 as a compiler: before
+// recoding: 51.6 sec. to generate 300 million random numbers; after
+// recoding: 24.0 sec. for the same (i.e., 46.5% of original time),
+// so speed is now about 12.5 million random number generations per
+// second on this machine.
+//
+// According to URL <http://www.math.keio.ac.jp/~matumoto/emt.html>
+// (and paraphrasing a bit in places), the Mersenne Twister is
+// "designed with consideration of the flaws of various existing
+// generators," has a period of 2^19937 - 1, gives a sequence that
+// is 623-dimensionally equidistributed, and "has passed many
+// stringent tests, including the die-hard test of G. Marsaglia and
+// the load test of P. Hellekalek and S. Wegenkittl."  It is efficient
+// in memory usage (typically using 2506 to 5012 bytes of static data,
+// depending on data type sizes, and the code is quite short as well).
+// It generates random numbers in batches of 624 at a time, so the
+// caching and pipelining of modern systems is exploited. It is also
+// divide- and mod-free.
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public License
+// as published by the Free Software Foundation (either version 2 of
+// the License or, at your option, any later version).  This library
+// is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY, without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General
+// Public License for more details.  You should have received a copy
+// of the GNU Library General Public License along with this library;
+// if not, write to the Free Software Foundation, Inc., 59 Temple
+// Place, Suite 330, Boston, MA 02111-1307, USA.
+//
+// The code as Shawn received it included the following notice:
+//
+//  Copyright (C) 1997 Makoto Matsumoto and Takuji Nishimura.  When
+//  you use this, send an e-mail to <matumoto@math.keio.ac.jp> with
+//  an appropriate reference to your work.
+//
+// It would be nice to CC: <Cokus@math.washington.edu> when you write.
+*/
+
+/* uint32 must be an unsigned integer type capable of holding at least
+// 32 bits; exactly 32 should be fastest, but 64 is better on an Alpha
+// with GCC at -O3 optimization so try your options and see what's
+// best for you.
+*/
+
+#include "cokusmt.h"
+
+typedef unsigned long uint32;
+
+
+#define N             (624)               /* length of state vector */
+#define M             (397)                 /*   a period parameter */
+#define K             (0x9908B0DFU)         /*     a magic constant */
+#define hiBit(u)      ((u) & 0x80000000U)   /* mask all but highest */
+                                            /*            bit of u  */
+#define loBit(u)      ((u) & 0x00000001U)   /* mask all but lowest  */
+                                            /*            bit of u  */
+#define loBits(u)     ((u) & 0x7FFFFFFFU)   /* mask off the highest */
+                                            /*            bit of u  */
+#define mixBits(u, v) (hiBit(u) | loBits(v))  /* move hi bit of u   */
+                                              /*   to hi bit of v */
+
+static uint32 state[N+1]; /* state vector+1 to not violate ANSI C */
+static uint32 *next;      /* next random value computed from here */
+static int     left = -1; /* can *next++ this many times before */
+                          /* reloading */
+
+
+/* We initialize state[0..(N-1)] via the generator
+//
+//   x_new = (69069 * x_old) mod 2^32
+//
+// from Line 15 of Table 1, p. 106, Sec. 3.3.4 of Knuth's
+// _The Art of Computer Programming_, Volume 2, 3rd ed.
+//
+// Notes (SJC): I do not know what the initial state requirements
+// of the Mersenne Twister are, but it seems this seeding generator
+// could be better.  It achieves the maximum period for its modulus
+// (2^30) iff x_initial is odd (p. 20-21, Sec. 3.2.1.2, Knuth); if
+// x_initial can be even, you have sequences like 0, 0, 0, ...;
+// 2^31, 2^31, 2^31, ...; 2^30, 2^30, 2^30, ...; 2^29, 2^29 + 2^31,
+// 2^29, 2^29 + 2^31, ..., etc. so I force seed to be odd below.
+//
+// Even if x_initial is odd, if x_initial is 1 mod 4 then
+//
+//            low bit of x is always 1,
+//    next-to-low bit of x is always 0,
+//   2nd-from-low bit of x alternates   ... 0 1 0 1 0 1 0 1 ... ,
+//   3rd-from-low bit of x 4-cycles     ... 0 1 1 0 0 1 1 0 ... ,
+//   4th-from-low bit of x has 8-cycle  ... 0 0 0 1 1 1 1 0 ... ,
+//    ...
+//
+// and if x_initial is 3 mod 4 then
+//
+//            low bit of x is always 1,
+//    next-to-low bit of x is always 1,
+//   2nd-from-low bit of x alternates   ... 0 1 0 1 0 1 0 1 ... ,
+//   3rd-from-low bit of x 4-cycles     ... 0 0 1 1 0 0 1 1 ... ,
+//   4th-from-low bit of x has 8-cycle  ... 0 0 1 1 1 1 0 0 ... ,
+//    ...
+//
+// The generator's potency (min. s>=0 with (69069-1)^s = 0
+// mod 2^32) is 16, which seems to be alright by p. 25, Sec.
+// 3.2.1.3 of Knuth.  It also does well in the dimension 2..5
+// spectral tests, but it could be better in dimension 6
+// (Line 15, Table 1, p. 106, Sec. 3.3.4, Knuth).
+//
+// Note that the random number user does not see the values
+// generated here directly since reloadMT() will always munge
+// them first, so maybe none of all of this matters.  In fact,
+// the seed values made here could even be extra-special
+// desirable if the Mersenne Twister theory says so-- that's
+// why the only change I made is to restrict to odd seeds.
+*/
+void seedMT(uint32 seed)
+{
+   register uint32  x = (seed | 1U) & 0xFFFFFFFFU,
+                   *s = state;
+   register int     j;
+
+   for (left = 0, *s++ = x, j = N;
+        --j;
+        *s++ = (x *= 69069U) & 0xFFFFFFFFU);
+} /* seedMT */
+
+
+static uint32 reloadMT(void)
+{
+   register  uint32
+            *p0    = state,
+            *p2    = state + 2,
+            *pM    = state + M,
+            s0,
+            s1;
+   register int    j;
+
+   if (left < -1)  seedMT(4357U);        /* Autoseed on first use */
+
+   left = N - 1; next = state + 1;
+   for (s0 = state[0], s1 = state[1], j = N - M + 1;
+             --j;
+             s0 = s1, s1 = *p2++)
+      *p0++ = *pM++ ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);
+
+   for (pM = state, j = M;
+             --j;
+             s0 = s1, s1 = *p2++)
+      *p0++ = *pM++ ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);
+
+   s1 = state[0];
+   *p0 = *pM ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);
+   s1 ^= (s1 >> 11);
+   s1 ^= (s1 <<  7) & 0x9D2C5680U;
+   s1 ^= (s1 << 15) & 0xEFC60000U;
+   return (s1 ^ (s1 >> 18));
+} /* reloadMT */
+
+
+uint32 randomMT(void)
+{
+   uint32 y;
+
+   if (--left < 0)
+      return(reloadMT());
+
+   y  = *next++;
+   y ^= (y >> 11);
+   y ^= (y <<  7) & 0x9D2C5680U;
+   y ^= (y << 15) & 0xEFC60000U;
+   return (y ^ (y >> 18));
+} /* randomMT */
+
diff --git a/gcc/config/i386/nmalloc/cokusmt.h b/gcc/config/i386/nmalloc/cokusmt.h
new file mode 100644
index 000000000..c6df7d70c
--- /dev/null
+++ b/gcc/config/i386/nmalloc/cokusmt.h
@@ -0,0 +1,17 @@
+/* file cokusMT.h */
+
+#ifndef cokus_h
+#define cokus_h
+
+#include <limits.h>
+
+#if ULONG_MAX != 4294967295UL
+   #error System long word size not suitable for cokusMT
+#endif
+
+#define ranMTMAX ULONG_MAX
+
+void seedMT(unsigned long seed);
+unsigned long randomMT(void);
+
+#endif /* cokus_h */
diff --git a/gcc/config/i386/nmalloc/evilalg2.c b/gcc/config/i386/nmalloc/evilalg2.c
new file mode 100644
index 000000000..18b740a8e
--- /dev/null
+++ b/gcc/config/i386/nmalloc/evilalg2.c
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+int main(void)
+{
+   char    *p;
+   unsigned int i;
+
+   puts("Testing calloc(i, i).  Be patient");
+   for (i = 65535; i > 0; i--) {
+      if ((p = calloc(i,i))) {
+         printf("\n%d appears to be the largest succesful integer\n",
+                   i);
+         break;
+      }
+      if (0 == (i % 500)) {
+         if (0 == (i % 5000)) printf(" %8d\n", i);
+         else printf("\r%8d", i);
+         fflush(stdout);
+      }
+   }
+   return 0;
+}
diff --git a/gcc/config/i386/nmalloc/evilalgo.c b/gcc/config/i386/nmalloc/evilalgo.c
new file mode 100644
index 000000000..107c8c9ce
--- /dev/null
+++ b/gcc/config/i386/nmalloc/evilalgo.c
@@ -0,0 +1,35 @@
+/* From djgpp mail list - an evil algorithm */
+/* This shows up the difference between DJGPP2.03 malloc and
+   nmalloc, both in speed and in efficiency of memory use.
+   Snaffled/cleaned up for testing use by C.B. Falconer.
+
+   To use the new malloc, simply link it with the object module.
+*/
+#include <stdio.h>
+#include <stdlib.h>
+
+typedef struct {
+   char af[10];
+   char name[10];
+} record;
+
+record **dt, *d;
+
+int main(int argc, char ** argv)
+{
+   unsigned long n = 1000;  /* was 200000L */
+   unsigned int  count;
+   void         *v;
+
+   if (argc > 1) n = strtoul(argv[1], NULL, 10);
+
+   dt = NULL;
+   for (count = 0; count < n; count++){
+      if ((v = realloc(dt, (count + 1) * sizeof *dt))) dt = v;
+      else break;
+      if (!(d = dt[count] = calloc(10, sizeof *d))) break;
+      if (!(count & 0xfff)) putc('*', stderr);
+   }
+   printf("\ncount=%d\n", count);
+   return(0);
+} /* evilalgo */
diff --git a/gcc/config/i386/nmalloc/fakesbrk.h b/gcc/config/i386/nmalloc/fakesbrk.h
new file mode 100644
index 000000000..50bae6aa7
--- /dev/null
+++ b/gcc/config/i386/nmalloc/fakesbrk.h
@@ -0,0 +1 @@
+void *fakesbrk(int delta);
diff --git a/gcc/config/i386/nmalloc/makefile b/gcc/config/i386/nmalloc/makefile
new file mode 100644
index 000000000..e476dae2b
--- /dev/null
+++ b/gcc/config/i386/nmalloc/makefile
@@ -0,0 +1,88 @@
+# nmalloc makefile
+# This makefile was tested under W98 and DJGPP 2.03/gcc 2.953
+# and is a mess.  Feel free to create a better one.
+
+objects = nmalloc.o cokusmt.o
+sources = tnmalloc.c nmalloc.c nmalloc.h nmalloc.lst \
+          cokusmt.c cokusmt.h fakesbrk.h sysquery.h \
+          malldbg.c malldbg.h tmalldbg.c \
+	  makefile evilalgo.c nmalloc.txh
+utils   = xref.exe
+
+CFLAGS  = -W -Wall -gstabs+ -Dinline= 
+
+tnmalloc.exe : $(objects) tnmalloc.o
+	gcc -o tnmalloc.exe tnmalloc.o $(objects)
+	
+# this shows up all use of magic numbers	
+nmalloc.xrf : nmalloc.lst nmalloc.c nmalloc.h sysquery.h \
+              malldbg.h malldbg.c tmalldbg.c tnmalloc.c
+	xref -cfn8 nmalloc.lst nmalloc.xrf
+
+# profileable version. 50% slowdown
+mallocp.o   : nmalloc.c sysquery.h
+	gcc -W -Wall -pg -gstabs+ -O2 -o mallocp.o \
+	    -c nmalloc.c
+
+# production version	
+malloc.o    : nmalloc.c sysquery.h
+	gcc -W -Wall -gstabs+ -O2 -o malloc.o \
+	    -c nmalloc.c
+	    
+# production debug system
+malldbg.o   : malldbg.c sysquery.h malldbg.h
+	gcc -W -Wall -O1 -gstabs+ -c malldbg.c
+	
+# testing production debug version
+tmalldbg.o  : tmalldbg.c sysquery.h malldbg.h
+	gcc -W -Wall -gstabs+ -O1 -c tmalldbg.c
+	
+# testing production debug version
+tmalldbg.exe : tmalldbg.o malldbg.o malloc.o
+	gcc -o tmalldbg.exe tmalldbg.o malldbg.o malloc.o
+
+# profilable	
+tmallocp.o : tnmalloc.c nmalloc.h fakesbrk.h sysquery.h
+	gcc -W -Wall -pg -gstabs+ -O2 -o tmallocp.o \
+	    -c tnmalloc.c
+	
+# Use this to profile malloc under various tests. 50% slowdown
+tmallocp.exe : tmallocp.o cokusmt.o mallocp.o
+	gcc -pg -o tmallocp.exe tmallocp.o cokusmt.o mallocp.o
+
+tnmalloc.o  : tnmalloc.c cokusmt.h nmalloc.h fakesbrk.h sysquery.h
+cokusmt.o   : cokusmt.c cokusmt.h
+evilalgo.o  : evilalgo.c malloc.o
+
+# Development debug version
+nmalloc.o   : nmalloc.c nmalloc.h fakesbrk.h sysquery.h
+	gcc -W -Wall -DNEWMALLDBG -gstabs+ -O1 -c nmalloc.c
+
+# pack it all up for shipping
+nmalloc.zip   : $(sources) $(utils) readme.txt
+	zip -o -u nmalloc.zip $(sources) $(utils) readme.txt
+	
+#create a profile
+profile	: tmallocp.exe
+	tmallocp 5 100000 quiet > profile
+	gprof -b tmallocp.exe >> profile
+
+.PHONY : clean zip tnmalloc tmallocp tmalldbg all xrf
+
+clean :
+	rm -f tnmalloc.exe $(objects) tnmalloc.o malloc.o \
+	      mallocp.o nmalloc.xrf tmallocp.exe tmallocp.o \
+	      gmon.out evilalgo.o
+
+zip : nmalloc.zip
+
+tnmalloc : tnmalloc.exe
+
+tmallocp : tmallocp.exe
+
+tmalldbg : tmalldbg.exe
+
+# elide "zip" from this, to avoid destroying a backup
+all : tnmalloc malloc.o mallocp.o tmallocp tmalldbg
+
+xrf : nmalloc.xrf
diff --git a/gcc/config/i386/nmalloc/malldbg.c b/gcc/config/i386/nmalloc/malldbg.c
new file mode 100644
index 000000000..edf6cbf1a
--- /dev/null
+++ b/gcc/config/i386/nmalloc/malldbg.c
@@ -0,0 +1,429 @@
+/* -------- malldbg.c --------- */
+
+/* Copyright (c) 2003 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@worldnet.att.net>
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <signal.h>   /* raise, SIGABRT */
+#include "malldbg.h"  /* and sysquery.h */
+
+/* This is to be used in conjunction with a version of
+   nmalloc.c compiled with:
+
+     gcc -DNDEBUG -o malloc.o -c nmalloc.c
+*/
+
+static int   dbglevel;
+static FILE *dumpfile;
+static int   initialized;
+
+/* array of hook function pointers, for cleaner interface */
+/* This is purely a record of values set by sethook()     */
+static M_HOOKFN hookptr[HKCOUNT];
+
+/* Number of free lists in system */
+#define NFLISTS ((int)(CHAR_BIT * sizeof(size_t)))
+
+/* Loaded by initsysinfo() to access nmalloc guts */
+static struct _sysquery sysinfo;
+
+/* freehdrsp is pointer to array[NFLISTS] of void* */
+/* These are the headers of the actual free lists  */
+/* also loaded by initsysinfo() call               */
+static void          *(*freehdrsp)[NFLISTS];
+
+#define NONE          sysinfo.nilp
+#define lastsbrk      freehdrs[0]
+#define memblockp     void*
+typedef unsigned int  ulong;
+typedef unsigned char byte;
+
+/* conversion and access macros */
+#define DATAOFFSET sysinfo.data
+
+#define MEMBLKp(p) (memblockp)((byte*)(p) - DATAOFFSET)
+#define PTR(m)     (void*)((byte*)(m) + DATAOFFSET)
+
+/* This accesses the list of discrete memory chains     */
+/* which are created when sbrk returns unexpected value */
+#define SBRKBGN    ((void **)(sysinfo.anchors))
+
+/* field access macros (AFTER sysinfo loaded)    */
+/* Examples - replace "m->prv" by "fld(m, prv)"  */
+/*            replace "m->sz"  by "szof(m)"      */
+/* where field is prvf, nxtf, prv, nxt           */
+#define fld(m, field)   *((void**)((char*)m + sysinfo.field))
+#define szof(m)         *(ulong*)((char*)m + sysinfo.sz)
+#define freehdrs        (*freehdrsp)
+
+/* ----------------- */
+
+/* Set up the access to the nmalloc module */
+static void initsysinfo(void)
+{
+   sysinfo   = _sysmalloc();
+   freehdrsp = (void*)((byte*)(sysinfo.nilp)-sizeof(void*));
+   if (!dumpfile) dumpfile = stderr;
+   initialized = 1;
+} /* initsysinfo */
+
+/* 1------------------1 */
+
+/* m is the allocated ptr treated by MEMBLKp    */
+/* Fouls if sysinfo has not been initialized    */
+/* Display info about a particular memory block */
+static void xshowblock(FILE *f, void *m, const char *id)
+{
+   if (NULL == f) return;
+   if (m) {
+      fprintf(f, " %s %p", id, m);
+      fprintf(f, " sz=%u nxt=%p prv=%p nxtf=",
+             szof(m), fld(m, nxt), fld(m, prv));
+      if (fld(m, nxtf)) {
+         if (NONE == fld(m, nxtf))
+            fprintf(f, "NONE prvf=");
+         else
+            fprintf(f, "%p prvf=", fld(m, nxtf));
+         if (NONE == fld(m, prvf))
+            fprintf(f, "NONE");
+         else
+            fprintf(f, "%p", fld(m, prvf));
+      }
+      else fprintf(f, "0");
+   }
+   else
+      fprintf(f, " %s NULL", id);
+   fflush(f);  /* to coexist with internal debuggery */
+} /* xshowblock */
+
+/* 1------------------1 */
+
+/* dump the entire free chain group             */
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+static void xdumpfree(FILE *f)
+{
+   int       i;
+   memblockp m;
+   ulong     totfree;
+
+   if (NULL == f) return;
+   totfree = 0;
+   for (i = 0; i < NFLISTS; i++) {
+      if ((m = freehdrs[i])) {
+         fprintf(f, "\n%2d: ", i);
+         do {
+            fprintf(f, "%p(%u)->", m, szof(m));
+            totfree += szof(m);
+            m = fld(m, nxtf);
+         } while (m && (NONE != m));
+         fprintf(f, "0");
+         m = freehdrs[i];
+         while (m && (NONE !=m )) {
+            xshowblock(f, m, "\n     ");
+            m = fld(m, nxtf);
+         }
+      }
+   }
+   fprintf(f, "\nTotal Free = %u\n", totfree);
+   fflush(f);  /* to coexist with internal debuggery */
+} /* xdumpfree */
+
+/* ----------------- */
+
+/* show the content of a block, flag it as BAD */
+static void showbad(FILE *f, void * m)
+{
+   void *n;
+
+   if ((dbglevel >= 3) && (NULL == f)) f = dumpfile;
+   if (f) {
+      n = fld(m, nxt);
+      xshowblock(f, m, "\n BAD?:");
+      xshowblock(f, n, "\n BAD?:");
+      putc('\n', f);
+      fflush(f);
+   }
+} /* showbad */
+
+/* ----------------- */
+
+/* scans the complete malloc structures to collect
+   info.  If f is non-NULL outputs a detailed listing
+   returns NULL unless a bad block is found.
+   Any bad blocks are displayed on dumpfile */
+static void * mallocscan(FILE *f, struct mallinfo *mi)
+{
+   unsigned long totalmem, totalfree, blks, freeblks;
+   void *m, *n, *badblk;
+   int   i, valid;
+
+   valid = 1; badblk = NULL;
+   if (!initialized) initsysinfo();
+   mi->smblks = mi->hblks = mi->hblkhd = mi->usmblks = 0;
+   mi->fsmblks = mi->keepcost = 0;
+
+   /* this initialization accounts for the fact that
+      the lastsbrk field will be counted as used */
+   blks = 0; totalmem = 0;
+   mi->hblkhd = totalfree = szof(freehdrs[0]);
+   freeblks = 1;
+
+   for (i = 0; (m = SBRKBGN[i]); i++) {
+      if (f) fprintf(f, "\n\nGroup %d:", i);
+      do {
+         n = fld(m, nxt);
+         if (f) xshowblock(f, m, "\n ");
+         totalmem += szof(m);
+         blks++;
+         if (dbglevel && n)
+            if (m != fld(n, prv)) {
+               valid = 0; badblk = m;
+               showbad(dumpfile, m);
+               if (dbglevel >= 3) {
+                  fflush(dumpfile);
+                  raise(SIGABRT);
+               }
+            }
+         if (fld(m, nxtf)) { /* a free block */
+            freeblks++;
+            totalfree += szof(m);
+         }
+      } while ((m = n));
+   }
+   if (f) fprintf(f, "\n");
+
+   /* return the collected info in struct mi */
+   mi->arena    = totalmem;
+   mi->ordblks  = blks;
+   mi->hblks    = freeblks;
+   mi->uordblks = totalmem - totalfree
+                       - DATAOFFSET * (blks - freeblks);
+   mi->fordblks = totalfree;
+   mi->keepcost = DATAOFFSET * blks;
+   return badblk;
+} /* mallocscan */
+
+/* ----------------- */
+
+/* Return summary details about the arena */
+struct mallinfo mallinfo(void)
+{
+   struct mallinfo mi;
+   int    valid;
+
+   if (!initialized) initsysinfo();
+   valid = (NULL == mallocscan(NULL, &mi));
+   return mi;
+} /* mallinfo */
+
+/* ----------------- */
+
+/* Verify the integrity of the arena */
+int malloc_verify(void)
+{
+   struct mallinfo mi;
+   void  *badblk;
+
+   if (!initialized) initsysinfo();
+   badblk = mallocscan(NULL, &mi);
+   if (badblk) showbad(dumpfile, badblk);
+   return (NULL == badblk);
+} /* malloc_verify */
+
+/* ----------------- */
+
+/* dump a complete map of the arena */
+void mallocmap(void)
+{
+   struct mallinfo mi;
+   void  *badblk;
+
+   if (!initialized) initsysinfo();
+   fprintf(dumpfile, "\nmallocmap at level %d\n", dbglevel);
+   xdumpfree(dumpfile);
+   badblk = mallocscan(dumpfile, &mi);
+} /* mallocmap */
+
+/* ----------------- */
+
+/* Set the file on which to display results */
+FILE *malldbgdumpfile(FILE *fp)
+{
+   FILE *tmp;
+
+   if (!initialized) initsysinfo();
+   tmp = dumpfile;
+   if (fp) dumpfile = fp;
+   else dumpfile = stderr;
+   return tmp;
+} /* malldbgdumpfile */
+
+/* ----------------- */
+
+/* The following three functions are called by hooks */
+
+/* Do malloc_verify function via hook ptr */
+/* No output unless a bad block found     */
+/* This is suitable for setting hooks.    */
+static void checkarena(size_t sz, void *bk)
+{
+   struct mallinfo mi;
+   void  *badblk;
+
+   if (bk) sz = sz; /* anti warn */
+   if (dbglevel > 1) {  /* else ignore, safety */
+      if ((badblk = mallocscan(NULL, &mi)))
+         showbad(dumpfile, badblk);
+   }
+} /* checkarena */
+
+/* ----------------- */
+
+static void freenullalert(size_t sz, void *bk)
+{
+   if (bk) sz = sz; /* anti warn */
+   fputs("\n***Freeing NULL\n", dumpfile);
+} /* freenullalert */
+
+/* ----------------- */
+
+static void mallocfailalert(size_t sz, void *bk)
+{
+   if (bk)
+      fprintf(dumpfile,
+              "\n***realloc failed expanding %p to %lu bytes\n",
+              bk, (unsigned long)sz);
+   else
+      fprintf(dumpfile,
+              "\n***malloc failed allocating %lu bytes\n",
+              (unsigned long)sz);
+} /* mallocfailalert */
+
+/* ----------------- */
+
+/* Check that no hooks are presently in use */
+/* uses the locally stored copy of hooks so */
+/* mistakes are possible.  Maybe sysinfo    */
+/* should contain a pointer to the real tbl */
+/* Our own hooks are allowable              */
+static int somehookinuse(void)
+{
+   enum m_hook_kind hk;
+
+   for (hk = malloc_HK; hk < HKCOUNT; hk++) {
+      /* structured for ease of modification */
+      if (NULL            == hookptr[hk]) continue;
+      if (checkarena      == hookptr[hk]) continue;
+      if (freenullalert   == hookptr[hk]) continue;
+      if (mallocfailalert == hookptr[hk]) continue;
+      return 1;
+   }
+   return 0;
+} /* somehookinuse */
+
+/* ----------------- */
+
+/* sethook, bypassing validity checks */
+static M_HOOKFN sethook(enum m_hook_kind which,
+                        M_HOOKFN newhook)
+{
+   M_HOOKFN tmp;
+
+   hookptr[which] = newhook; /* keep local record */
+   tmp = (*sysinfo.hookset)(which, newhook);
+   return tmp;
+} /* sethook */
+
+/* ----------------- */
+
+M_HOOKFN mallsethook(enum m_hook_kind which,
+                     M_HOOKFN newhook)
+{
+   if (!initialized) initsysinfo();
+   if (which >= HKCOUNT) return NULL; /* validity check */
+   if (dbglevel != 1) return NULL;    /* in use, refuse */
+
+   return sethook(which, newhook);
+} /* mallsethook */
+
+/* ----------------- */
+
+static void releaseallhooks(void)
+{
+   enum m_hook_kind hk;
+
+   for (hk = malloc_HK; hk < HKCOUNT; hk++)
+      sethook(hk, NULL);
+} /* freeallhooks */
+
+/* ----------------- */
+
+static inline void setfreenullhook(void)
+{
+   sethook(free_null_HK, freenullalert);
+} /* setfreenullhook */
+
+/* ----------------- */
+
+static inline void setmallocfailhook(void)
+{
+   sethook(malloc_fail_HK, mallocfailalert);
+} /* setmallocfailhook */
+
+/* ----------------- */
+
+static inline void setverifyhooks(void)
+{
+   sethook(malloc_HK,  checkarena);
+   sethook(free_HK,    checkarena);
+   sethook(realloc_HK, checkarena);
+} /* setverifyhooks */
+
+/* ----------------- */
+
+/* level  action
+      0   Only passive checks
+      1   Passive checks, hook setting enabled
+      2   Checks on each alloc/realloc, no hooks allowed
+      3   Same, but aborts if fault found, signals malloc_fail
+      4   Same, but signals on free(NULL)
+
+   A level value outside 0..4 is rejected.
+   Returns current debug_level (before any change).
+*/
+int malloc_debug(int level)
+{
+   int oldlevel;
+
+   if (!initialized) initsysinfo();
+   oldlevel = dbglevel;
+   if ((level >= 0) && (level <= 4) && (level != oldlevel)) {
+      if ((oldlevel < 2) && (level >= 2)) {
+         if (somehookinuse()) { /* refuse */
+            fprintf(dumpfile, "\n***malldbglvl refused\n");
+            return oldlevel;
+         }
+      }
+      /* Either all hooks free or our own, or level < 2 */
+      /* The change is feasible, level is changed and valid */
+      dbglevel = level;
+      releaseallhooks();
+      switch (level) { /* falling through */
+case 4:  setfreenullhook();
+case 3:  setmallocfailhook();
+case 2:  setverifyhooks();
+default: break;
+      } /* switch (level) */
+   } /* valid level change */
+   return oldlevel;
+} /* malloc_debug */
+
+/* -------- malldbg.c ----------- */
diff --git a/gcc/config/i386/nmalloc/malldbg.h b/gcc/config/i386/nmalloc/malldbg.h
new file mode 100644
index 000000000..4bad8f425
--- /dev/null
+++ b/gcc/config/i386/nmalloc/malldbg.h
@@ -0,0 +1,50 @@
+/* -------- malldbg.h ----------- */
+
+/* Copyright (c) 2003 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@worldnet.att.net>
+*/
+
+#ifndef malldbg_h
+#define malldbg_h
+
+/* This is to be used in conjunction with a version of
+   nmalloc.c compiled with:
+
+     gcc -DNDEBUG -o malloc.o -c nmalloc.c
+
+   after which linking malldbg.o and malloc.o will
+   provide the usual malloc, free, realloc calls.
+   Both malloc.o and malldbg.o can be components
+   of the normal run time library.
+*/
+
+#include <stddef.h>
+#include "sysquery.h"
+
+struct mallinfo {
+   int arena;           /* Total space being managed */
+   int ordblks;         /* Count of allocated & free blocks */
+   int smblks;
+   int hblks;           /* Count of free blocks */
+   int hblkhd;          /* Size of the 'lastsbrk' block */
+   int usmblks;
+   int fsmblks;
+   int uordblks;        /* Heap space in use w/o overhead */
+   int fordblks;        /* Total space in free lists */
+   int keepcost;        /* Overhead in tracking storage */
+};
+
+struct mallinfo mallinfo(void);
+int             malloc_verify(void);
+int             malloc_debug(int level);
+void            mallocmap(void);
+FILE           *malldbgdumpfile(FILE *fp);
+M_HOOKFN        mallsethook(enum m_hook_kind which,
+                            M_HOOKFN newhook);
+
+#endif
+/* -------- malldbg.h ----------- */
diff --git a/gcc/config/i386/nmalloc/memalign.c b/gcc/config/i386/nmalloc/memalign.c
new file mode 100644
index 000000000..5389e8798
--- /dev/null
+++ b/gcc/config/i386/nmalloc/memalign.c
@@ -0,0 +1,137 @@
+
+/* 1------------------1 */
+
+/* The remaining code is an attempt to graft on the
+   memalign function.  It can do with improvement.
+   The idea is to do this without disturbing the
+   already checked and debugged package.
+
+   In units of ALIGN (== 8 here) bytes.  The value of
+   DATAOFFSET depends on SAVEMEMORY, either 2 or 3.  The
+   following assumes SAVEMEMORY is set and DATAOFFSET = 2.
+
+   Initial malloc block (alignment > ALIGN):
+    ____________________________________________________
+   |          |            |              |             |
+   |          |            |              |             |
+   |DATAOFFSET|   size     |  xtra for    |             |
+   | control  |            | realignment  |             |
+   |__________|____________|______________|_____________|
+              ^
+              ^
+A: If this point is aligned, then we simply cut the assignment.
+   Immediate use of realloc will avoid any data movement.
+
+B: Worst case when this is 1 (DELTA) above an alignment point.
+   becomes (since alignment > ALIGN and thus
+                  alignment >= DATAOFFSET):
+    ____________________________________________________
+   |          |            |              |             |
+   |alignment |DATAOFFSET  |              |     0       |
+   | - DELTA  |   for      |    size      |  nothing    |
+   |to freespc| control    |              | needed BUT: |
+   |________ _|____________|______________|_____________|
+                           ^              ^
+                           ^              ^
+   Now this point is suitably aligned     ^
+    ALIGNMENT - DELTA >= DATAOFFSET       ^
+                                          ^
+   For the intermediate cases make sure this block to be moved
+   to free space is at least 3 units long.  Easiest is to set
+   the initial extra value so that this worst case is 3, not 0
+ ?  This makes the initial extra size alignment+4 ??
+
+C: The initial alignment point is 1 low.  (DELTA = -1)
+    ____________________________________________________
+   |          |            |              |             |
+   |    3     |            |              |             |
+   |control+1 |    2       |    size      |  xtra-3     |
+   |to freespc|  control   |              |to freespc   |
+   |__________|____________|______________|_____________|
+                           ^              ^
+                           ^              ^
+   This point is aligned --^     This goes to freespace
+
+D: The initial alignment point is 2 low.  (DELTA = -2)
+    ____________________________________________________
+   |          |            |              |             |
+   |          |            |              |             |
+   |          |    2       |    size      |             |
+   |          |  control   |              |to freespc   |
+   |__________|____________|______________|_____________|
+                           ^              ^
+                           ^              ^
+   This point is aligned --^     This goes to freespace
+
+   The minimum of 3 units to freespace is because 2 are
+   required for control, and without further space the
+   block is useless.  In fact it needs the further space
+   to implement the free block linking mechanism.
+*/
+
+/* 1------------------1 */
+
+/* Check alignment is a non-zero power of two <= 65536. */
+/* Return 0 if so, else non-zero                        */
+static inline int invalid(size_t alignment)
+{
+   if (alignment && (alignment <= 65536))
+      return (alignment & (alignment - 1));
+   else return 1;  /* 0 is invalid */
+} /* invalid */
+
+/* 1------------------1 */
+
+/* define the XTRA storage needed to assure chopping up feasible
+   and that chopped off storage is large enough to be usable.
+   XTRA is always a multiple of ALIGN.
+*/
+
+#define XTRA (alignment + 3 * ALIGN)
+
+/* 1------------------1 */
+
+/* return memory aligned so that the return value is a */
+/* multiple of alignment.  Otherwise similar to malloc */
+/* alignment MUST be a power of two, max 65536.        */
+void *nmemalign(size_t size, size_t alignment)
+{
+   memblockp m = NULL, m1;
+   void     *minit;
+   ulong     misalign;
+   size_t    szneed, sz = size; /* preserve arg for hooks */
+
+   /* compute the rounded up size needed */
+   if (!sz) sz++;     /* avoid any 0 space allocation */
+   szneed = roundup(sz);
+   DBGPRTM("memalign(%5lu) [%5lu] %5lu", sz, szneed, alignment);
+   DBGEOLN;
+
+   if (size < ((ulong)(INT_MAX - 65536)) &&
+       !invalid(alignment)) {
+      /* parameters seem to be valid */
+      if (alignment <= ALIGN) {
+         DBGPRTM("  alignment value ignored"); DBGEOLN;
+         return nmalloc(szneed);                      /* EXIT */
+      }
+      else if ((minit = nmalloc(szneed + XTRA))) {
+         /* alignment >= 2*ALIGN and power of 2 if here */
+         misalign = (ulong)minit % alignment;
+         DBGPRTM("  misalignment = %d", misalign);
+         if (0 == misalign) { /* aligned, just return XTRA */
+            DBGPRTM(" Just realloc the block."); DBGEOLN;
+            return nrealloc(minit, size);             /* EXIT */
+         }
+         else {
+            /* two or more chunks to release */
+            /* for now, just return NULL and have a leak */
+            DBGPRTM("  Complex case, release multiple chunks");
+            DBGEOLN;
+         }
+      } /* alignment > ALIGN */
+   } /* valid parameters */
+   if (m) return PTR(m);
+   else return NULL;
+} /* nmemalign */
+
+/* --------- nmalloc.c ----------- */
diff --git a/gcc/config/i386/nmalloc/nmalloc.c b/gcc/config/i386/nmalloc/nmalloc.c
new file mode 100644
index 000000000..ecaf4eb80
--- /dev/null
+++ b/gcc/config/i386/nmalloc/nmalloc.c
@@ -0,0 +1,1032 @@
+/* --------- nmalloc.c ----------- */
+
+/* Copyright (c) 2003, 2007 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@maineline.net>
+     (html mail will probably be summarily ignored)
+
+   Revised 2007-01-04 to include calloc.
+   Revised 2007-01-28 per bug report by Florian Xaver. *f1*
+*/
+
+/* A re-implementation of malloc and friends for DJGPP 2.03/2.04
+   This includes many bits modeled after DJs original scheme.
+   This is NOT portable - it builds in knowledge of int size etc.
+   i.e. unsigned ints and pointers are both 32 bits (size 4)
+
+   The system is NOT thread and interrupt safe, although use of a
+   suitable critical section call could make it such.  Nothing
+   herein executes for any unusual length of time (with NDEBUG).
+*/
+
+/* Some critical tuning constants. Search for them:
+   MINSBRK    controls minimal access to sbrk
+   ALIGN      controls alignment of pointers
+   SAVEMEMORY reduces overhead at expense of checkability
+   INT_MAX    (system) controls maximum allocation quantum.
+*/
+
+/* To avoid unexpected problems, the default has been changed
+   so we now require NEWMALLDBG to enable the original action
+*/
+
+#ifndef NEWMALLDBG
+#  undef  NDEBUG
+#  define NDEBUG
+#else
+#  undef  NDEBUG
+#endif
+
+#ifndef NDEBUG
+   /* diddle these to control areas debugged */
+#  define DEBUGM 1     /* malloc */
+#  define DEBUGF 1     /* free */
+#  define DEBUGR 1     /* realloc */
+#else
+#  define DEBUGM 0
+#  define DEBUGF 0
+#  define DEBUGR 0
+   /* the HOOKABLE variant is only for development   */
+   /* It allows some other package to define malloc, */
+   /* free, realloc, and to call this package.       */
+#  ifndef HOOKABLE
+#     define nmalloc  malloc
+#     define nfree    free
+#     define nrealloc realloc
+#     define nmemalign memalign
+#     define ncalloc  calloc
+#  else
+#     define nmalloc  _malloc
+#     define nfree    _free
+#     define nrealloc _realloc
+#     define nmemalign _memalign
+#     define ncalloc   calloc  /* can't hook this */
+#  endif
+#  define fakesbrk sbrk
+#endif
+
+#define SAVEMEMORY 1  /* 0/1 to use/eliminate extra storage */
+
+typedef unsigned char byte;
+typedef unsigned int  ulong;
+
+#include <stddef.h> /* offsetof() */
+#include <stdlib.h> /* malloc, free, realloc, exit, EXIT_FAILURE */
+#include <unistd.h> /* sbrk, write */
+#include <signal.h> /* raise, SIGABRT */
+#include <string.h> /* strlen, memmove, memcpy, memset */
+#include <limits.h> /* CHAR_BIT, INT_MAX */
+#include "sysquery.h" /* available debugger linkages */
+
+/* system dependant magic.  Only STDIN, STDERR used */
+enum {STDIN = 0, STDOUT, STDERR, STDAUX, STDPRN}; /* handles */
+
+/* Incorporation into the system should require deleting the
+   following <nmalloc.h>, changing all references to nmalloc
+   to malloc, nfree to free, nrealloc to realloc.  Change the
+   single call to fakesbrk to sbrk.  Also normally set all
+   DEBUGx values above to 0 in place of 1.  Later many
+   routines will be made inline.  For debugging compilations
+   are done with "/Dinline= " switch.  For production use
+   the "/DNDEBUG=1" switch, which does all the above except
+   the inlining. But see NEWMALLDBG above.
+*/
+#ifndef NDEBUG
+#  include "nmalloc.h" /* while testing before name changes */
+#else
+#  ifdef HOOKABLE
+#     include "hookmem.h"
+#  endif
+#endif
+
+/* ============================================================
+   Macros and storage for debugging, works before init on DJGPP
+   WARNING - GNU extensions used here!!
+   Note: many messages are designed for easy search with grep
+         and also serve as comments.
+*/
+#if DEBUGM || DEBUGF || DEBUGR
+#  include <stdio.h>     /* sprintf, for DEBUG only */
+#  include "fakesbrk.h"  /* repeatable sbrk */
+#  define EOL "\n"       /* for DEBUG printouts only, allow crlf */
+   static char  dbgbuff[1024];
+   static char *dbgbp = dbgbuff;
+#  define DBGFLUSH do {if (dbgbp != dbgbuff) { \
+                         /* write it out */ \
+                         write(STDOUT, dbgbuff, strlen(dbgbuff)); \
+                         dbgbp = dbgbuff; \
+                      } \
+                   } while (0)
+#  define DBGEOLN do { \
+                     DBGPRT(EOL); \
+                     DBGFLUSH; \
+                  } while (0)
+#  define DBGPRT(msg, args...) do { \
+                    if ((dbgbp - dbgbuff) > 924) DBGFLUSH; \
+                    dbgbp +=sprintf(dbgbp, msg , ## args); \
+                 } while (0)
+#  define SHOWBLK(m, id) showblock(m, id)
+#  if DEBUGM
+#     define DBGPRTM(msg, args...) \
+                     dbgbp +=sprintf(dbgbp, msg , ## args)
+#     define SHOWBLKM(m, id) showblock(m, id)
+#  else
+#     define DBGPRTM(msg, args...)
+#     define SHOWBLKM(m, id)
+#  endif
+#  if DEBUGF
+#     define DBGPRTF(msg, args...) \
+                     dbgbp +=sprintf(dbgbp, msg , ## args)
+#     define SHOWBLKF(m, id) showblock(m, id)
+#  else
+#     define DBGPRTF(msg, args...)
+#     define SHOWBLKF(m, id)
+#  endif
+#  if DEBUGR
+#     define DBGPRTR(msg, args...) \
+                     dbgbp +=sprintf(dbgbp, msg , ## args)
+#     define SHOWBLKR(m, id) showblock(m, id)
+#  else
+#     define DBGPRTR(msg, args...)
+#     define SHOWBLKR(m, id)
+#  endif
+#else
+#  define DBGFLUSH
+#  define DBGEOLN
+#  define DBGPRT(msg, args...)
+#  define SHOWBLK(m, id)
+#  define DBGPRTM(msg, args...)
+#  define SHOWBLKM(m, id)
+#  define DBGPRTF(msg, args...)
+#  define SHOWBLKF(m, id)
+#  define DBGPRTR(msg, args...)
+#  define SHOWBLKR(m, id)
+#endif
+
+/* This is intended to allow finding the header area from
+   the address of the immediately adjacent memblocks.
+   The guardxx avoid destruction by an off by one pointer
+   and serve no real logical purpose.  Note that in some
+   cases sz may be recovered from next or next may be
+   recovered from sz.
+*/
+typedef struct memblock {
+   struct memblock *prev;   /* 1st, protect against overrun */
+   struct memblock *next;   /* makes this less clobberable  */
+   ulong            sz;                 /* of this memblock */
+   /* An allocated block has the next two (1) fields NULL */
+   /* A free block has them both non-NULL  */
+   struct memblock *nextfree;
+   struct memblock *prevfree; /* actually data w/SAVEMEMORY */
+#if SAVEMEMORY == 0
+   ulong            guardlo;     /* may hold size requested */
+#endif
+   /* here lies the actual assigned storage                 */
+   /* so the following must be addressed by adding offset   */
+   /* storage must always be a multiple of 8 in size        */
+   /* thus these items are fictional, i.e. for zero data    */
+} memblock, *memblockp;
+
+/* Notice that with SAVEMEMORY the prevfree field only
+   exists for free blocks; it reuses data space.  This
+   is why we cannot allow 0 sized blocks.
+*/
+#if SAVEMEMORY
+#  define DATAOFFSET (offsetof(memblock, prevfree))
+#else
+#  define DATAOFFSET sizeof(memblock)
+#endif
+
+/* conversion and access macros */
+#define MEMBLKp(p) (memblockp)((byte*)(p) - DATAOFFSET)
+#define PTR(m)     (void*)((byte*)(m) + DATAOFFSET)
+
+#define ALIGN 8
+#define ALIGNMASK (ALIGN-1)
+
+/* We can never use an allocation smaller than this */
+#define MINSAVE   (ALIGN + DATAOFFSET)
+
+/* Alternate form of NULL to distinguish free lists
+   This is self protection, because freehdrs[1] is otherwise
+   unused.  freehdrs[0] is reserved to hold lastsbrk.  In turn
+   this means that ALIGN must be >= 4.
+*/
+#define NONE (memblockp)&freehdrs[1]
+
+/* Magic constants.  MINSBRK must be MINSAVE or larger */
+enum {NFLISTS = (int)(CHAR_BIT * sizeof(size_t)), MINSBRK = 1024};
+
+/* ============== Globals ============= */
+
+/* Headers of lists holding free blocks of 2**2 thru 2**31 size */
+/* freehdr[n] holds items sized 2**n thru 2**(n+1) - 1          */
+
+static memblockp freehdrs[NFLISTS]; /* yes, low indices are waste */
+#define lastsbrk freehdrs[0]
+
+/* keep track of the bases of each new sbrk block */
+#define MAXSBRKS 100     /* I have never seen more than 5 needed */
+static int   lastsbrkbgn;       /* zeroed on load */
+static void *sbrkbgn[MAXSBRKS]; /* NULLS on load */
+
+/* This holds pointers to hooks, initialized to NULLs */
+/* see enum m_hook_kind for actual identifiers in sysquery.h */
+static M_HOOKFN hookptr[HKCOUNT];
+
+/* Forward declaration to allow sysquery init below */
+static M_HOOKFN sethook(enum m_hook_kind which,
+                        M_HOOKFN         newhook);
+
+/* This allows a clean connection to debugging software */
+static struct _sysquery sysquery = {
+        DATAOFFSET,
+#if SAVEMEMORY
+        0xff,
+#else
+        offsetof(memblock, guardlo),
+#endif
+        offsetof(memblock, sz),
+        offsetof(memblock, prevfree),
+        offsetof(memblock, nextfree),
+        offsetof(memblock, next),
+        offsetof(memblock, prev),
+        sizeof(memblock),
+        NONE,         /* also &freehds[1] */
+        &sbrkbgn,     /* anchors field */
+        sethook       /* hookset field */
+};
+
+/* 1------------------1 */
+
+/* This can return the above values, hopefully in a register */
+/* The use of NONE in nextfree, prevfree may cause confusion */
+struct _sysquery _sysmalloc(void)
+{
+   return sysquery;
+} /* _sysmalloc */
+
+/* 1------------------1 */
+
+#if DEBUGM || DEBUGF || DEBUGR
+
+/* These two routines are actually available in any user  */
+/* application by use of the _sysmalloc call above.  They */
+/* are retained here to show the derivation of user code, */
+/* and in case needed during system initialization.       */
+
+static void showblock(memblockp m, char *id)
+{
+   if (m) {
+      DBGPRT(" %s %p sz=%u nxt=%p prv=%p nxtf=",
+             id, m, m->sz, m->next, m->prev);
+      if (m->nextfree) {
+         if (NONE == m->nextfree)
+            DBGPRT("NONE prvf=");
+         else
+            DBGPRT("%p prvf=", m->nextfree);
+         if (NONE == m->prevfree)
+            DBGPRT("NONE");
+         else
+            DBGPRT("%p", m->prevfree);
+      }
+      else DBGPRT("0");
+   }
+   else
+      DBGPRT(" %s NULL", id);
+} /* showblock */
+
+/* 1------------------1 */
+
+/* dump the entire free chain group */
+static void dumpfree(void)
+{
+   int       i;
+   memblockp m;
+
+   for (i = 0; i < NFLISTS; i++) {
+      if ((m = freehdrs[i])) {
+         DBGPRT(EOL "%2d: ", i);
+         do {
+            DBGPRT("%p(%u)->", m, m->sz);
+            m = m->nextfree;
+         } while (m && (NONE != m));
+         DBGPRT("0");
+         m = freehdrs[i];
+         while (m && (NONE !=m )) {
+            SHOWBLK(m, EOL "     ");
+            m = m->nextfree;
+         }
+      }
+   }
+   DBGEOLN;
+} /* dumpfree */
+#endif
+
+/* 1------------------1 */
+
+/* This is accessible only through the pointer    */
+/* returned in the sysquery record by _sysmalloc. */
+/* Only of use in the malldbg package.            */
+/* No safeties implemented here - see malldbg     */
+static M_HOOKFN sethook(enum m_hook_kind which,
+                        M_HOOKFN         newhook)
+{
+   M_HOOKFN tmp = NULL;
+
+   if (which < HKCOUNT) {
+      tmp = hookptr[which];
+      hookptr[which] = newhook;
+   }
+   return tmp;
+} /* sethook */
+
+/* 1------------------1 */
+
+/* inserts bases of sbrk chains in sbrkbgn array  */
+/* This ensures we can find all controlled memory */
+/* gets called when we find an unexpected sbrk.   */
+/* Note that if the sbrk was unaligned bk has now */
+/* been aligned, and we have no record of wastage */
+/* As long as nothing is returned to sbrk this is */
+/* not a problem.  This only for the malldbg pkg. */
+static void recordnewsbrk(memblockp bk)
+{
+   int i;
+
+   if (lastsbrkbgn < MAXSBRKS - 1) {
+      /* This check for a previous entry is probably not
+         needed, but it is a rare occurance, so safety */
+      for (i = 0; i < lastsbrkbgn; i++) {
+         if (bk == sbrkbgn[i]) return;
+      }
+      sbrkbgn[lastsbrkbgn++] = bk;
+   }
+/* else we abandon trying to keep track */
+} /* recordnewsbrk */
+
+/* 1------------------1 */
+
+static inline ulong roundup(size_t sz)
+{
+   ulong size;
+
+   size = ((sz + ALIGNMASK) & ~ALIGNMASK) + DATAOFFSET;
+   return size;
+} /* roundup */
+
+/* 1------------------1 */
+
+static inline int size2bucket(ulong sz)
+{
+   int b;
+
+   for (b = 0; sz; sz >>= 1, b++) continue;
+   return b;
+} /* size2bucket */
+
+/* 1------------------1 */
+
+static void badcallabort(const char *msg, int lgh, memblockp m)
+{
+#if DEBUGM || DEBUGF || DEBUGR
+   DBGEOLN;
+#endif
+   write(STDERR, msg, lgh);
+   write(STDERR, ": memory fouled\n", 16);
+#if DEBUGM || DEBUGF || DEBUGR
+   SHOWBLK(m, "");
+   dumpfree();
+#else
+   (void)m;  /* anti unused warning */
+#endif
+   raise(SIGABRT);
+} /* badcallabort */
+
+/* 1------------------1 */
+
+#define ISFREE(m) (m && (m != NONE) && m->nextfree && m->prevfree)
+#if SAVEMEMORY
+#define FOULED(m) (!lastsbrk || m->nextfree)
+#else
+#define FOULED(m) (!lastsbrk || (m->guardlo != 0xDEADBEEF))
+#endif
+
+/* 1------------------1 */
+
+/* Unlike rmvfromfree, this extracts a block that */
+/* may be buried deep within the free list by     */
+/* unlinking.  m is already known a free block    */
+static void extractfree(memblockp m)
+{
+   int       b;
+   memblockp mnxtf, mprvf;
+
+   if (m) {
+      b = size2bucket(m->sz);
+      SHOWBLKF(m, EOL "  extractfree blk");
+
+      /* ease further tests */
+      if (NONE == (mnxtf = m->nextfree)) m->nextfree = NULL;
+      if (NONE == (mprvf = m->prevfree)) m->prevfree = NULL;
+
+      if      (m->nextfree) m->nextfree->prevfree = mprvf;
+
+      if      (m->prevfree) m->prevfree->nextfree = mnxtf;
+      else if (m->nextfree) freehdrs[b] = mnxtf;
+      else                  freehdrs[b] = NULL;
+
+      /* mark the block non-free */
+      m->nextfree = m->prevfree = NULL;
+
+      DBGPRTF(EOL "  freehdrs %d", b);
+      SHOWBLKF(freehdrs[b], "is blk");
+   }
+} /* extractfree */
+
+/* 1------------------1 */
+
+static inline memblockp combinelo(memblockp m)
+{
+   memblockp m1;
+
+   m1 = m;
+   if (ISFREE(m->prev)) {
+      if (m->prev->next != m) {
+         badcallabort("combinelo", 9, m);
+         exit(EXIT_FAILURE);  /* prevent user trapping SIGABRT */
+      }
+      m1 = m->prev;
+      extractfree(m1);
+      if (NULL != (m1->next = m->next))
+         m1->next->prev = m1;
+      m1->sz += m->sz;
+   }
+   return m1;
+} /* combinelo */
+
+/* 1------------------1 */
+
+/* used to combine with lastsbrk, so no ISFREE test */
+/* because lastsbrk is not kept in the free lists   */
+static memblockp combinehi(memblockp m)
+{
+   memblockp m1;
+
+   if (m && m->next) {
+      SHOWBLK(m,       EOL "  combinehi");
+      SHOWBLK(m->next, EOL "  with");
+      if (m->next->prev != m) {
+         badcallabort("combinehi", 9, m);
+         exit(EXIT_FAILURE);  /* prevent user trapping SIGABRT */
+      }
+      m1 = m->next;
+      if (m1 != lastsbrk) extractfree(m1);
+      if (NULL != (m->next = m->next->next))
+         m->next->prev = m;
+      m->sz += m1->sz;
+      SHOWBLK(m,       EOL "  giving");
+   }
+   return m;
+} /* combinehi */
+
+/* 1------------------1 */
+
+/* This takes care of marking the block as free */
+static void mv2freelist(memblockp m)
+{
+   int       b;
+
+   if (m) {
+      if (ISFREE(m->next)) m = combinehi(m);
+      b = size2bucket(m->sz);
+      DBGPRT(EOL "  mv2freelist %d", b); SHOWBLK(m, "blk");
+      if (lastsbrk && (m->next == lastsbrk)) {
+         SHOWBLKF(lastsbrk, EOL "  Combine with lastsbrk");
+         lastsbrk = combinehi(m);
+         lastsbrk->nextfree = lastsbrk->prevfree = NULL;
+         SHOWBLKF(lastsbrk, EOL "  Resulting in lastsbrk");
+         return;
+      }
+      else if (freehdrs[b]) {
+         m->nextfree = freehdrs[b];
+         freehdrs[b]->prevfree = m;
+      }
+      else {
+         m->nextfree = NONE;
+      }
+      m->prevfree = NONE;
+      if (freehdrs[b]) freehdrs[b]->prevfree = m;
+      freehdrs[b] = m;
+      DBGPRT(EOL "  Exit mv2freelist");
+   }
+} /* mv2freelist */
+
+/* 1------------------1 */
+
+/* this always marks the block as non-free */
+static inline void rmvfromfree(memblockp m)
+{
+   int b;
+
+   if (m) {
+      b = size2bucket(m->sz);
+      DBGPRTM(EOL "  rmvfromfree %d", b); SHOWBLKM(m, "blk");
+      if (m != freehdrs[b]) {
+         DBGPRTM(" NOT FREE");
+         badcallabort("rmvfromfree", 11, m);
+         exit(EXIT_FAILURE);  /* prevent user trapping SIGABRT */
+      }
+      else {
+         if (NONE == m->nextfree)
+            freehdrs[b] = NULL;
+         else {
+            freehdrs[b] = m->nextfree;
+            freehdrs[b]->prevfree = NONE;
+         }
+#if SAVEMEMORY
+         m->nextfree = NULL;
+#else
+         m->nextfree = m->prevfree = NULL;
+#endif
+         DBGPRTM(EOL "  freehdrs %d", b);
+         SHOWBLKM(freehdrs[b], "is blk");
+      }
+   }
+} /* rmvfromfree */
+
+/* 1------------------1 */
+
+static int searchfree(ulong szneed)
+{
+   int b;
+
+   b = size2bucket(szneed);
+   DBGPRT(EOL "  freelist search from bucket %d", b);
+
+   if (! freehdrs[b] || (freehdrs[b]->sz < szneed)) {
+      do {
+         b++;
+      } while ((b < NFLISTS) && ! freehdrs[b]);
+   }
+   /* if found we will break off a piece and housekeep */
+   if (b < NFLISTS)
+      DBGPRT(", using %d", b);
+   else {
+      b = 0;
+      DBGPRT(", none found");
+   }
+   return b;
+} /* searchfree */
+
+/* 1------------------1 */
+
+/* The higher portion is returned in *mp,     */
+/* the lower portion via the function return. */
+/* and the lower portion is marked non-free   */
+static memblockp split(memblockp *mp, ulong sz)
+{
+   memblockp m1, m;
+
+   m = *mp;
+   m1 = (memblockp)((char *)m + sz);
+   if (m->sz < (sz + DATAOFFSET)) {
+      badcallabort("memblockpsz", 11, m);
+      exit(EXIT_FAILURE);  /* prevent user trapping SIGABRT */
+   }
+   memcpy(m1, m, DATAOFFSET);
+   m1->prev = m;
+   m1->sz = m->sz - sz;
+   m->next = m1;
+   m->sz = sz;
+   m->nextfree = NULL;
+#if SAVEMEMORY
+#else
+   m->prevfree = NULL;
+#endif
+   *mp = m1;
+   if (m1->next) {
+      if (m1->next->prev != m) {
+         badcallabort("memblockpnxt", 12, m1);
+         exit(EXIT_FAILURE);  /* prevent user trapping SIGABRT */
+      }
+      m1->next->prev = m1;
+   }
+   SHOWBLKM(m, EOL "  split returns");
+   return m;
+} /* split */
+
+/* 1------------------1 */
+
+/* Get the memory, see if it extends the present lastsbrk
+   If not, put the old lastsbrk into the appropriate freelist
+      and replace lastsbrk by the new, setting the headers up
+   else update the size markers in lastsbrk.  When done either
+   lastsbrk can supply the memory szextra, or NULL is returned.
+   A revised lastsbrk block is marked as non-free.
+*/
+static memblockp extendsbrk(ulong szxtra)
+{
+   memblockp  m;
+   byte      *expected;
+   int        alignerr;
+   int        aligndelta;
+
+   DBGPRTM(", extending sbrk");
+
+   /* we have to ensure that the new lastsbrk always has    */
+   /* room to both realign and to leave a header when split */
+   szxtra += (2 * ALIGN + DATAOFFSET);
+   if (szxtra < MINSBRK) szxtra = MINSBRK;
+
+   if (lastsbrk)
+      expected = ((byte*)lastsbrk) + lastsbrk->sz;
+   else expected = NULL;
+
+   if ((aligndelta = (ulong)expected & ALIGNMASK)) {
+      /* lastsbrk end was misaligned, try to align end of this */
+      szxtra += ALIGN - aligndelta;
+      aligndelta = 0;
+   }
+
+   m = fakesbrk(szxtra);
+   if (-1 == (int)m) return NULL;
+   else {
+      if ((byte*)m == expected) {  /* Extending size of lastsbrk */
+         DBGPRTM(EOL "  sbrk(%4u=0x%05x) got expected %p"
+                     " lastsbrk %p sz %d",
+                       szxtra, szxtra, expected,
+                       lastsbrk, expected - (byte*)lastsbrk);
+         lastsbrk->sz += szxtra;
+         m = lastsbrk;
+      }
+      else {
+         /* Here we have to check & fix alignment */
+         DBGPRTM(EOL "=>sbrk(%4u=0x%05x) got UNEXPECTED %p/%p"
+                     " lastsbrk %p sz %d",
+                       szxtra, szxtra, m, expected,
+                       lastsbrk, expected - (byte*)lastsbrk);
+         if ((alignerr = (ALIGNMASK & (ulong)m))) {
+/*f1*/      m = (memblockp)((char*)m +
+                            (aligndelta = ALIGN - alignerr));
+            DBGPRTM(", szerr %d/%d", aligndelta, alignerr);
+         }
+         m->sz = szxtra - aligndelta; /* discard alignerr bytes */
+         m->prev = m->next = NULL;
+#if SAVEMEMORY
+         m->nextfree = NULL;
+#else
+         m->nextfree = m->prevfree = NULL;
+         m->guardlo    = 0xDEADBEEF;
+#endif
+         mv2freelist(lastsbrk);
+         lastsbrk = m;
+         recordnewsbrk(m); /* save in list of chains */
+      }
+   }
+   return m;
+} /* extendsbrk */
+
+/* 1------------------1 */
+
+/* The mechanism:
+   All available memory is kept on the free list, and all adjacent
+   blocks, assigned or free, are linked by next/prev fields in order
+   of address.  Freehdrs[n] holds the first of a list of free blocks
+   of sizes between 2**n and 2**n+1. A pointer to the free portion
+   of the block last acquired via sbrk is held in lastsbrk.
+
+   All blocks on the freelist are marked by having a non-NULL value
+   in the nextfree or prevfree fields.  The special value NONE is
+   used to replace NULL to terminate these lists.  Because of the
+   misalignment possibilities it is necessary to keep accurate byte
+   count lengths in the sz component of lastsbrk.
+
+   1.  An allocation is made from the first fit freehdrs list. Note
+   that there MAY be a usable piece in the next lower freehdr, but
+   that is ignored because we do not want to search possibly long
+   lists.  The block is removed from the freelist, and any excess
+   space is broken off (if large enough to be usable) and assigned
+   to the appropriate free list.
+
+   2.  If no suitable free block is found, allocation is attempted
+   from the last block created by an sbrk call.  Such a block must
+   be large enough to maintain an sbrk pointer after splitting off
+   the desired allocation.
+
+   3.  If this fails a new block is created (or extended) via an
+   sbrk call.  If possible, the previous lastsbrk block is extended.
+   If extension is not possible the remains of the old block alone
+   is placed in the freelist.  This (non-extension) case results in
+   the prev field of the lastsbrk block being NULL.  The next field
+   of the lastsbrk block is always NULL. In this case only it is
+   necessary to check and correct memory alignment.
+
+   Insertion is always done into the start of any given freelist.
+   Thus there is no list walking needed.  Similarly, any block is
+   always removed from the head of the appropriate freelist.
+
+   It is assumed that sbrk will never return a lower address than
+   did a previous sbrk.  I am not sure if this affects anything. I
+   believe it does not.
+*/
+void *nmalloc(size_t size)
+{
+   memblockp m = NULL, m1;
+   ulong     szneed;
+   int       b;
+   void     *p = NULL;
+   size_t    sz = size; /* preserve arg for hooks */
+
+   /* compute the rounded up size needed */
+   if (!sz) sz++;     /* avoid any 0 space allocation */
+   szneed = roundup(sz);
+   DBGPRTM("malloc(%5lu) [%5u]", sz, szneed);
+   SHOWBLKM(lastsbrk, EOL "  lastsbrk");
+
+   /* Check for oversize allocation request */
+   if (szneed < ((ulong)(INT_MAX - 65536))) {
+      /* search the free lists for one */
+      b = searchfree(szneed);
+
+      if (b) {
+         rmvfromfree(m1 = freehdrs[b]);
+         if (m1->sz < szneed + MINSAVE)
+            m = m1;
+         else {
+            m = split(&m1, szneed);
+            mv2freelist(m1);
+         }
+      }
+      else if (lastsbrk &&
+              (lastsbrk->sz >= (szneed + DATAOFFSET))) {
+         m = split(&lastsbrk, szneed);
+      }
+      /* if not found get more from system */
+      else if ((m1 = extendsbrk(szneed))) {
+         if (m1->sz < szneed + MINSAVE) {
+            m = m1;
+            DBGPRTM(EOL "**FOULED lastsbrk\a");
+         }
+         else {
+            m = split(&lastsbrk, szneed);
+         }
+      }
+   /* else abject_failure(); */
+   /* abject_failure COULD check the first possible freehdrs */
+   /* list as a last chance to find some suitable memory     */
+
+      if (m) p = PTR(m);
+      else {
+         DBGPRTM(dbgbp, ", FAILURE");
+         p = NULL;
+      }
+   }
+/* else m and p are NULL for oversize; */
+
+#if DEBUGM
+   DBGPRTM(EOL "returns %p", p);
+   if (m) DBGPRTM("(%lu)", m->sz - DATAOFFSET);
+   DBGEOLN;
+#endif
+
+   if (hookptr[malloc_HK]) hookptr[malloc_HK](size, p);
+   if (!p && hookptr[malloc_fail_HK])
+      hookptr[malloc_fail_HK](size, NULL);
+
+   return p;
+} /* nmalloc */
+
+/* 1------------------1 */
+
+static void dofree(memblockp m)
+{
+   /* mark the block free */
+   m->nextfree = m->prevfree = NONE;
+
+   /* try to combine with lower or higher blocks in memory */
+   if (ISFREE(m->next)) m = combinehi(m);
+   if (ISFREE(m->prev)) m = combinelo(m);
+
+   if (lastsbrk && (lastsbrk == m->prev) )
+      DBGPRTF(EOL "**Found decreasing sbrk!! FOUL");
+   else mv2freelist(m);
+} /* dofree */
+
+/* 1------------------1 */
+
+void nfree(void *ptr)
+{
+   memblockp m;
+
+   if (hookptr[free_HK]) hookptr[free_HK](0, ptr);
+
+   if (ptr) {
+      m = MEMBLKp(ptr);
+      DBGPRTF("free(%p)", ptr); SHOWBLKF(m, "");
+      if (ISFREE(m) ||     /* bad, refreeing block */
+          FOULED(m) ) {    /* block is fouled */
+         badcallabort("free", 4, m);
+         return;           /* he can trap this SIGABRT */
+      }
+      dofree(m);
+#if DEBUGF
+      DBGEOLN;
+#endif
+   }
+   else if (hookptr[free_null_HK])
+      hookptr[free_null_HK](0, NULL);
+} /* nfree */
+
+/* 1------------------1 */
+
+static memblockp mv2lastsbrk(memblockp m, ulong szneed)
+{
+   memblockp m1;
+
+   m1 = split(&lastsbrk, szneed);
+
+   /* Now m1 is the proposed new block, of the right size */
+   /* links are already revised so copy data from m to m2 */
+   memcpy(PTR(m1), PTR(m), m->sz - DATAOFFSET);
+
+   dofree(m);
+   return m1;
+} /* mv2lastsbrk */
+
+/* 1------------------1 */
+
+void *nrealloc(void *ptr, size_t size)
+{
+   memblockp m, m1, m2;
+   void     *p;
+   ulong     szneed;
+   int       b;
+   size_t    sz = size;
+
+   if (hookptr[realloc_HK]) hookptr[realloc_HK](sz, ptr);
+
+   if (!ptr) {
+      p = nmalloc(sz);
+      if (hookptr[realloc_exit_HK])
+         hookptr[realloc_exit_HK](size, p);
+      return p;
+   }
+
+   m = m1 = MEMBLKp(ptr);
+   if (!sz) sz++;     /* avoid any 0 space allocation */
+   szneed = roundup(sz);
+   DBGPRTR("realloc(%p:%lu[%u])", ptr, sz, szneed);
+   SHOWBLKR(m, EOL "  was");
+   if (ISFREE(m) ||     /* bad, realloc of free block */
+       FOULED(m) ) {    /* storage fouled */
+      badcallabort("realloc", 7, m);
+      p = NULL;
+      goto exeunt;      /* he can trap this SIGABRT */
+   }
+   SHOWBLKR(lastsbrk, EOL "  lastsbrk");
+
+   /* if decreasing simply reduce size and move excess to free */
+   if (szneed <= m->sz) {
+      DBGPRTR(EOL "  Realloc is reducing");
+      if ((m->sz - szneed) >= MINSAVE) {
+         m = split(&m1, szneed);
+         mv2freelist(m1);
+      }
+   /* else just return old pointer, i.e. NOP */
+   }
+   else if (szneed > ((ulong)(INT_MAX - 65536))) {
+      /* reject excessive size request */
+      p = NULL; goto exeunt;
+   }
+   else if (ISFREE(m->next) &&
+            (szneed <= (m->sz + m->next->sz)) ) {
+      /* the 'next' block is free and adequate so use it */
+      DBGPRTR(EOL "  Realloc is combining, next is free");
+      m = m1 = combinehi(m);
+      /* now split off the excess, if any */
+      if ((m->sz - szneed) >= MINSAVE) {
+         m = split(&m1, szneed);
+         mv2freelist(m1);
+      }
+   /* else m is the oversized return block */
+   }
+   else if ((lastsbrk == m->next)  &&
+            ((szneed + MINSAVE) <= (m->sz + lastsbrk->sz)) ) {
+      /* lastsbrk is adequate and adjacent so use it */
+      DBGPRTR(EOL "  Realloc is using lastsbrk to extend");
+      m = m1 = combinehi(m1);
+      m = split(&m1, szneed);
+      lastsbrk = m1;
+   }
+   else if (ISFREE(m->prev) &&
+            (szneed <= (m->sz + m->prev->sz)) ) {
+      /* the 'prev' block is free and adequate so use it */
+      DBGPRTR(EOL "  Realloc is combining low free, moving data");
+      m1 = m->prev;
+      extractfree(m1);
+      m1->sz += m->sz;     /* revise the links */
+      if ((m1->next = m->next)) m1->next->prev = m1;
+      /* we are now done with m links, except sz */
+
+      /* This involves copying the data, overlapping */
+      memmove(PTR(m1), PTR(m), m->sz - DATAOFFSET);
+
+      m = m1;        /* done with the old m value */
+      /* Is there something leftover */
+      if ((m->sz - szneed) >= MINSAVE) {
+         m = split(&m1, szneed);
+         mv2freelist(m1);
+      }
+   }
+   else if ((b = searchfree(szneed))) {
+      /* An adequate free block exists, copy over, free old */
+      DBGPRTR(EOL "  Realloc is using free block, copying");
+      rmvfromfree(m1 = freehdrs[b]);
+      if (m1->sz < szneed + MINSAVE) {
+         m2 = m1;
+      }
+      else {
+         m2 = split(&m1, szneed);
+         mv2freelist(m1);
+      }
+      /* Now m2 is the proposed new block, of the right size */
+      /* links are already revised so copy data from m to m2 */
+      memcpy(PTR(m2), PTR(m), m->sz - DATAOFFSET);
+
+      dofree(m);
+      m = m2;
+   }
+   else if (lastsbrk &&
+            ((szneed + MINSAVE) <= lastsbrk->sz) ) {
+      DBGPRTR(EOL "  Realloc is copying into lastsbrk");
+      m = mv2lastsbrk(m, szneed);
+   }
+   /* else malloc new size, copy data, and free old */
+   else if ((m1 = extendsbrk(szneed))) {
+      if (lastsbrk == m->next) {
+         DBGPRTR(EOL "  Realloc is now using lastsbrk extended");
+         /* last chance to avoid copying */
+         m = m1 = combinehi(m);
+         m = split(&m1, szneed);
+         lastsbrk = m1;
+      }
+      else {
+         /* At this point lastsbrk is adequate size */
+         /* split off, copy over, and free old      */
+         DBGPRTR(EOL "  Realloc is making complete new copy");
+         m = mv2lastsbrk(m, szneed);
+      }
+   }
+   else m = NULL;  /* failure */
+
+   if (m) p = PTR(m);
+   else {
+      DBGPRTR(dbgbp, ", FAILURE");
+      p = NULL;
+   }
+
+#if DEBUGR
+   DBGPRTR(EOL "returns %p", p);
+   if (m) DBGPRTR("(%lu)", m->sz - DATAOFFSET);
+   DBGEOLN;
+#endif
+
+exeunt:       /* label used on realloc of free block */
+              /* and on trap of oversize request */
+   if (!p && ptr && hookptr[malloc_fail_HK])
+      hookptr[malloc_fail_HK](size, ptr);
+   if (hookptr[realloc_exit_HK])
+      hookptr[realloc_exit_HK](size, p);
+
+   return p;
+} /* nrealloc */
+
+/* 1------------------1 */
+
+/* calloc included here to ensure that it handles the
+   same range of sizes (s * n) as does malloc.  The
+   multiplication n*s can wrap, yielding a too small
+   value, so we must ensure calloc rejects this.
+*/
+void *ncalloc(size_t n, size_t s)
+{
+   void   *result;
+   size_t  sz;
+
+   result = NULL;
+   if (!n || (((size_t)-1) / n) > s) {
+      sz = n * s;
+      if ((result = nmalloc(sz))) memset(result, 0, sz);
+      }
+   return result;
+} /* ncalloc */
+
+/* 1------------------1 */
+
+#ifdef MEMALIGN
+#  include "memalign.c"  /* further extension, when done */
+#endif
diff --git a/gcc/config/i386/nmalloc/nmalloc.h b/gcc/config/i386/nmalloc/nmalloc.h
new file mode 100644
index 000000000..909f02054
--- /dev/null
+++ b/gcc/config/i386/nmalloc/nmalloc.h
@@ -0,0 +1,25 @@
+/* -------- nmalloc.h ----------- */
+
+/* Copyright (c) 2003, 2006 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@maineline.net>
+*/
+
+#ifndef nmalloc_h
+#define nmalloc_h
+
+#include <stddef.h>
+
+void *nmalloc(size_t sz);
+void nfree(void *ptr);
+void *nrealloc(void *ptr, size_t sz);
+void *ncalloc(size_t n, size_t s);
+#ifdef MEMALIGN
+   void *nmemalign(size_t sz, size_t alignment);
+#endif
+
+#endif
+/* -------- nmalloc.h ----------- */
diff --git a/gcc/config/i386/nmalloc/nmalloc.lst b/gcc/config/i386/nmalloc/nmalloc.lst
new file mode 100644
index 000000000..d7e89d5f3
--- /dev/null
+++ b/gcc/config/i386/nmalloc/nmalloc.lst
@@ -0,0 +1,8 @@
+nmalloc.h
+sysquery.h
+malldbg.h
+malldbg.c
+nmalloc.c
+tmalldbg.c
+tnmalloc.c
+
diff --git a/gcc/config/i386/nmalloc/nmalloc.txh b/gcc/config/i386/nmalloc/nmalloc.txh
new file mode 100644
index 000000000..e35c7d659
--- /dev/null
+++ b/gcc/config/i386/nmalloc/nmalloc.txh
@@ -0,0 +1,636 @@
+@node malloc, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+
+void *malloc(size_t size);
+@end example
+
+@subheading Description
+
+This function allocates a chunk of memory from the heap large
+enough to hold any object that is @var{size} bytes in length.
+This memory must be returned to the heap with @code{free}
+(@pxref{free}).
+
+Note: excessively large requests are rejected.  At present
+excessively large means over @code(INT_MAX) - 65536.
+
+Note: this version of malloc is designed to reduce memory usage.
+A faster but less efficient version is available in the libc
+sources (@file{djlsr*.zip}) in the file
+@file{src/libc/ansi/stdlib/fmalloc.c}.
+
+@subheading Return Value
+
+A pointer to the allocated memory, or @code{NULL} if there isn't
+enough free memory to satisfy the request.
+
+@subheading Portability
+
+@portability ansi, posix
+
+@subheading Example
+
+@example
+char *c = malloc(100);
+@end example
+
+@c -------------------------------------------------------------
+
+@node free, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+
+void free(void *ptr);
+@end example
+
+@subheading Description
+
+Returns the allocated memory to the heap (@pxref{malloc}).  If
+the @var{ptr} is @code{NULL}, @code{free} does nothing.
+
+@subheading Return Value
+
+None.
+
+@subheading Portability
+
+@portability ansi, posix
+
+@subheading Example
+
+@example
+char *q = malloc(20);
+free(q);
+@end example
+
+@c -------------------------------------------------------------
+
+@node realloc, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+
+void *realloc(void *ptr, size_t size);
+@end example
+
+@subheading Description
+
+This function changes the size of the region pointed to by
+@var{ptr}. If it can, it will reuse the same memory space, but
+it may have to allocate a new memory space to satisfy the
+request.  In either case, it will return the pointer that you
+should use to refer to the (possibly new) memory area.  The
+pointer passed may be @code{NULL}, in which case this function
+acts just like @code{malloc} (@pxref{malloc}).
+
+An application that wants to be robust in the face of a possible
+failure of @code{realloc} to enlarge a buffer should save a copy
+of the old pointer in a local variable, to be able to use the
+original buffer in case @code{realloc} returns @code{NULL}.  See
+the example below for details.
+
+Note: excessively large requests are rejected.  At present
+excessively large means over @code(INT_MAX) - 65536.
+
+@subheading Return Value
+
+On success, a pointer is returned to the memory you should now
+refer to.  On failure, @code{NULL} is returned and the memory
+pointed to by @var{ptr} prior to the call is not freed.
+
+@subheading Portability
+
+@portability ansi, posix
+
+@subheading Example
+
+@example
+if (now + new > max)
+@{
+  char *old = p;
+
+  oldmax = max;
+  max = now + new;
+  p = realloc(p, max);
+  if (p == NULL) @{
+    p = old;  /* retain the old pointer */
+    max = oldmax;
+  @}
+@}
+@end example
+
+@c -------------------------------------------------------------
+
+@node mallinfo, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> /* on non-DJGPP systems */
+
+struct mallinfo mallinfo(void);
+@end example
+
+@subheading Description
+
+This function returns information about heap space usage.  It is
+intended to be used for debugging dynamic memory allocation and
+tracking heap usage.  The @code{struct mallinfo} structure is
+defined by @file{stdlib.h} as follows:
+
+@example
+ struct mallinfo @{
+   int arena;
+   int ordblks;
+   int smblks;
+   int hblks;
+   int hblkhd;
+   int usmblks;
+   int fsmblks;
+   int uordblks;
+   int fordblks;
+   int keepcost;
+ @};
+@end example
+
+@noindent
+whose members are:
+
+@table @code
+@item arena
+The total amount of space, in bytes, handed by @code{sbrk} to
+@code{malloc}.  Note that this is not the same as
+@code{sbrk(0)}, since @code{sbrk} allocates memory in large
+chunks and then subdivides them and passes them to @code{malloc}
+as required.  In particular, the result of @code{sbrk(0)} might
+be much larger than the @code{arena} member of @code{struct
+mallinfo} when the DPMI host allocates memory in non-contiguous
+regions (happens on MS-Windows).
+
+@item ordblks
+The number of ``ordinary blocks'': the total number of allocated
+and free blocks maintained by @code{malloc}.
+
+@item smblks
+The number of ``small blocks''.  This is normally zero, unless
+a special version of @code{malloc} was installed.
+
+@item hblks
+The count of freeblocks maintained in the malloc arena.  This
+is normally much smaller than the number of freed blocks, since
+such blocks have been combined into larger blocks.
+
+@itemx hblkhd
+The size of the currently available top portion of the memory
+assigned by @code(sbrk).  Sometimes known as @dfn(slop).
+
+@item usmblks
+The space (in bytes) in ``small blocks'' that are in use.  This
+is always zero in the DJGPP implementation.
+
+@item fsmblks
+The space in free ``small blocks''.  Normally zero in the DJGPP
+implementation.
+
+@item uordblks
+The amount of space, in bytes, in the heap space currently used
+by the application.  This does not include the small overhead
+used by @code{malloc} to maintain its hidden information in each
+allocated block.
+
+@item fordblks
+The amount of free heap space maintained by @code{malloc} in its
+free list of hblks chunks.
+
+@item keepcost
+The total overhead used by @code(malloc) in maintaining the
+currently allocated blocks.
+@end table
+
+@subheading Return Value
+
+The @code{mallinfo} structure filled with information.
+
+@subheading Portability
+
+@port-note posix This function is available on many Unix systems.
+@portability !ansi, !posix
+
+@subheading Example
+
+@example
+ struct mallinfo info = mallinfo();
+
+ printf("Memory in use: %d bytes\n",
+        info.usmblks + info.uordblks);
+ printf("Total heap size: %d bytes\n", info.arena);
+@end example
+
+@c -------------------------------------------------------------
+
+@node malloc_verify, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> /* on non-DJGPP systems */
+
+int malloc_verify(void);
+@end example
+
+@subheading Description
+This function attempts to determine if the heap has been
+corrupted.  It scans all the blocks allocated by @code{malloc}
+and handed to the application, and also all the free blocks
+maintained by @code{malloc} and @code{free} in the internal free
+list.  Each block is checked for consistency of the hidden
+bookkeeping information recorded in it by @code{malloc} and
+@code{free}.
+
+What happens when a bad block is found depends on the current
+@dfn{malloc diagnostics level}: for example, the block can be
+reported, or the program may be aborted.  @xref{malloc_debug},
+for the details.
+
+@subheading Return Value
+If the program isn't aborted during the function's run (this
+depends on the current diagnostics level), @code{malloc_verify}
+returns 1 if the heap passes all tests, or zero of some of the
+tests failed.
+
+@subheading Portability
+
+@port-note posix This function is available on many Unix systems.
+@portability !ansi, !posix
+
+@subheading Example
+
+@example
+ if (malloc_verify() == 0)
+   printf ("Heap corruption detected!\n");
+@end example
+
+@c -------------------------------------------------------------
+
+@node malloc_debug, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> /* on non-DJGPP systems */
+
+int malloc_debug(int level);
+@end example
+
+@subheading Description
+This function sets the level of error diagnosis and reporting
+during subsequent calls to @code{malloc}, @code{free},
+@code{realloc}, and all functions which call them internally.
+The argument @var{level} is interpreted as follows:
+
+@table @asis 
+@item Level 0
+The memory allocation functions behave as they do if
+@code{malloc_debug} was never called.  Only passive checks are
+allowed, including @code(malloc_verify), @code(mallocmap), and
+@code(malldbgdumpfile) (to set the output file).  In particular
+@code(mallsethook) is disabled, to avoid accidents.  The actual
+functioning of the malloc system remains unaffected.  Any malloc
+hooks @xref(mallsethook) are reset. If errors are detected by
+@code{malloc_verify}, it prints diagnostic messages to the
+@defn(dumpfile) (default standard error stream), with address
+and size of the offending block and other pertinent information.
+
+@item Level 1
+All the passive checks of level 0 are allowed.  In addition
+@code(mallsethook) is enabled, thus allowing construction of
+custom debugging packages.
+
+@item Level 2
+Similar to level 1, but the consistency of the entire heap is
+also verified (by calling @code{malloc_verify}) on every call to
+the memory allocation functions.  @emph{Warning: this may
+significantly slow down the application.}  Since the malloc
+hooks are in use to connect to this system, @code(mallsethook)
+is disabled.  If there are hooks already in use the change to
+level 2 or above is rejected.
+
+@item Level 3
+Similar to level 2, except that the program is aborted whenever
+a heap corruption is detected.  In addition, failed allocations
+(i.e.@: when @code{malloc} or @code(realloc) returns @code{NULL}
+because it cannot satisfy a request) are reported to the
+dumpfile (default standard error).
+
+@item Level 4
+Similar to level 3, but calls to @code{free} with a @code{NULL}
+pointer as an argument are also reported.
+
+@item Level -1
+Does not alter the debug level, but returns the current value.
+@end table
+
+@subheading Return Value
+
+@code{malloc_debug} returns the previous error diagnostic level.  The
+default level is 0.
+
+@subheading Portability
+
+@port-note posix This function is available on many Unix systems.
+@portability !ansi, !posix
+
+@subheading Example
+
+@example
+ malloc_debug(2);
+ ...
+ malloc_verify();
+@end example
+
+@c -------------------------------------------------------------
+
+@node mallocmap, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> /* on non-DJGPP systems */
+
+void mallocmap(void);
+@end example
+
+@subheading Description
+
+This function prints a map of the heap storage to the selected
+@file(dumpfile). @xref(malldbgdumpfile). For each block, its
+address and size are printed, as well as an indication whether
+it is free or in use, together with pointers to adjacent blocks.
+
+@subheading Return Value
+
+None.
+
+@subheading Portability
+
+@port-note posix This function is available on many Unix systems.
+@portability !ansi, !posix
+
+@c -------------------------------------------------------------
+
+@node mallsethook, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> /* on non-DJGPP systems */
+
+M_HOOKFN mallsethook(enum m_hook_kind which,
+                     M_HOOKFN newhook);
+@end example
+
+@subheading Description
+Several @defn(hooks) are provided for building custom
+@code{malloc} debugging packages.  Such packages typically need
+to be notified when memory is allocated and freed by the
+application, in order to be able to find memory leaks, code that
+writes beyond the limits of allocated buffers or attempts to
+@code(free) buffers which were not allocated by @code{malloc},
+etc. These hooks can be used to define callback functions which
+will be called by the library at strategic points.  Each
+callback is only called if it is non-@code{NULL}; by default,
+all of them are initialized to a @code{NULL} value.
+
+The actual hook to be set is described by the following
+constants, enumerated in @file(stdlib.h):
+
+@table @code
+@item malloc_HK = 0    
+on entry to malloc
+
+@item malloc_fail_HK   
+when malloc or realloc fails
+
+@item free_HK          
+on entry to free
+
+@item free_null_HK     
+when free is called with a NULL pointer
+
+@item realloc_HK       
+on entry to realloc
+
+@item realloc_exit_HK  
+when realloc exits.
+
+@item HKCOUNT          
+The first invalid value for a hook descriptor.
+@end @table
+
+@noindent
+and each ``callback'' function is described by:
+
+@example
+   typedef void (*M_HOOKFN)(size_t sz, void *ptr);
+@end
+
+@noindent
+in @file(stdlib.h).  Note that in some cases the parameters
+supplied to the ``callback'' function will be meaningless, in
+which case they will be zero or @code(NULL) as appropriate.  The
+callback function must @strong(NOT) call any of @code(malloc),
+@code(free), or @code(realloc).
+
+@code(mallsethook) action is disabled unless the debug_level is
+set to 1.  This interlock avoids accidental use before enabling
+the package, and avoids altering hooks that are already in use
+for debug_level of 2 or higher.
+
+For access to the internal storage of the malloc arena, see the
+@code(_sysmalloc) call and the @code(_sysinfo) struct.
+
+@table @code
+
+@item malloc_HK
+Called just before a chunk of memory is about to be returned to
+the application in response to an allocation request.
+@var{sz} is the size requested by the application
+(@strong{not} the actual size of the allocated buffer, which may
+be larger).  @var{ptr} is a pointer to the block that was
+allocated.
+
+@item malloc_fail_HK
+Called if @code{malloc} failed to find a free block large enough
+to satisfy a request, and also failed to obtain additional
+memory from @code{sbrk}.  @var{sz} is the requested allocation
+size.
+
+@item free_HK
+Called when a buffer is about to be freed.  @var{ptr} is a
+pointer to the block to be freed.  Its validity has not been
+checked.
+
+@item free_null_HK
+Called whenever a @code{NULL} pointer is passed to @code{free}.
+@acronym{ANSI} C specifically rules that this is allowed and
+should have no effect, but you might want to catch such cases if
+your program needs to be portable to old compilers whose
+libraries don't like @code{NULL} pointers in @code{free}.
+
+@item realloc_HK
+Called at entry to @code{realloc}, before the actual
+reallocation. @var{ptr} is the pointer whose contents are to be
+reallocated.  @var{sz} is the new size requested by the
+application.  (This hook is called @emph{in addition} to the
+other hooks which may be called by @code{malloc} if and when
+@code{realloc} calls them.)
+
+@item realloc_exit_HK
+Called at exit from @code(realloc).  @var(sz) is the requested
+size, and @var(ptr) is the (possibly) revised value of the user
+pointer which will be returned by @code(realloc).  This may be
+@code(NULL) if realloc was unable to allocate the space, in
+which case @emph(ONLY) the original value of @var(ptr) (as
+reported by @code(realloc_HK)) remains valid.
+
+@end table
+
+@subheading Return Value
+
+@code{mallsethook} returns the previous hook pointer, (usually
+@code(NULL)). If @code(mallsethook) is disabled it will also
+return @code(NULL).
+
+@subheading Portability
+
+@portability !ansi, !posix
+
+These hooks and the function are specific to DJGPP.
+
+@subheading Example
+
+@example
+
+ static void mallocfailalert(size_t sz, void *ptr)
+ @{
+    printf("Failed to malloc %lu bytes\n", (unsigned long)sz);
+ @}
+
+ malloc_debug(1);
+ mallsethook(malloc_fail_HK, mallocfailalert);
+ ...
+ /* any malloc failure will result in a message */
+ 
+@end example
+
+@c -------------------------------------------------------------
+
+@node malldbgdmpfile, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> (on non-DJGPP systems)
+
+FILE *malldbgdmpfile(FILE *fp);
+@end example
+
+@subheading Description
+
+This function allows diverting the output of the malldbg package
+to any suitable text file, known as the @defn(dumpfile).  By
+default the package uses @code(stderr).
+
+@subheading Return Value
+
+The previous identity of the dumpfile.
+
+@subheading Portability
+
+@portability !ansi, !posix
+
+This function is specific to DJGPP.
+
+@subheading Example
+
+@example
+FILE *oldfile = malldbgdmpfile(stdout);
+@end example
+
+@c -------------------------------------------------------------
+
+@node _sysmalloc, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h>  /* on non-DJGPP systems */
+#include <sysquery.h> /* alternative on non-DJGPP systems */
+
+struct _sysquery _sysmalloc(void);
+@end example
+
+@subheading Description
+
+This function exports the internal structure of the malloc arena
+and thus allows construction of such packages as malldbg.  It 
+avoids accidental exposure of system critical values, and also
+permits such values to be changed and reflected in external
+packages.
+
+@subheading Return Value
+
+A @code(struct _sysquery), described as follows:
+
+@example
+struct _sysquery @{
+  unsigned char data, gdlo, sz, prvf, nxtf, nxt, prv, ohead;
+  void         *nilp;
+  void         *anchors;
+  set_m_hook    hookset;
+@};
+@end example
+
+Any unsigned char field set to 255 signifies the value is
+meaningless.  The @code(ohead) value is not useful in the
+present implementation.  The remaining values are small offsets
+from the internal pointers to the appropriate fields.  In
+particular @code(data) is the offset between the internal
+pointer and the user pointers.  @code(nxt) and @code(prv) link
+all allocated memory blocks, while @code(nxtf) and @code(prvf)
+are used only to link free blocks. @code(sz) is the internal
+size of the block, not the user size, and is normally rounded
+upward.  Thus the @code(nxt) field is redundant to the @code(sz)
+field (except when no @code(nxt) exists) and is used in validity
+checking. A @code(NULL) value in @code(nxtf) field signifies
+that the block is not free. The special value @code(nilp) is
+used in @code(nxtf) and @code(prvf) as a @code(NULL) value
+distinguishable from @code(NULL).
+
+@code(anchors) points to a @code(NULL) terminated list of sets
+of chains of memory blocks.  These were allocated by @code(sbrk)
+and were not contiguous to any previous allocations.
+
+@code(hookset) is a pointer to a function that can set malloc
+hooks, as described in @code(mallsethook).  It is only available
+through this link.
+
+@subheading Portability
+
+@portability !ansi, !posix
+
+This function is specific to DJGPP.
+
+@subheading Example
+
+@example
+struct _sysquery sysinfo = _sysmalloc();
+@end example
+
+@c -------------------------------------------------------------
diff --git a/gcc/config/i386/nmalloc/readme.txt b/gcc/config/i386/nmalloc/readme.txt
new file mode 100644
index 000000000..0beffbee6
--- /dev/null
+++ b/gcc/config/i386/nmalloc/readme.txt
@@ -0,0 +1,56 @@
+This is intended to be prepared via the makefile.
+
+To create a testable debug version, enter "make tnmalloc".
+
+To create an object module for use in actual systems, enter 
+"make malloc.o".  This will have the normal names, malloc, free,
+realloc.
+
+To create a version for profiling, enter "make tmallocp".  The
+module mallocp.o created is generally suitable for profiling, 
+and has the usual names.
+
+To create a cross-reference, enter "make xrf" (under DOS boxes
+only)
+
+The various compile time flags are set up appropriately.  In
+particular malloc.o should be immediately ready for inclusion
+in a library.  It may be desirable to "strip" debugging
+information from the module.
+
+"make all" creates everything, "make clean" wipes them out.
+
+The little test 'evilalgo' can be linked to either the stock
+malloc system, or to the malloc.o generated above.  Then time
+execution for an argument of 200000.  The original library will
+probably fail where nmalloc will succeed, and nmalloc will do it
+a lot faster.
+
+To create the modules for the malloc_debug system, enter
+"make tmalldbg.exe".  Once this is done other systems with the
+debug mechanism can be created by linking malldbg and hookmem 
+(.o) ahead of the normal runtime library.  The system using it
+must #include malldbg.h.
+
+make zip doesn't work properly.
+
+The integration of the malldbg system is not complete, but
+should function correctly.  Future changes are expected to be
+fairly cosmetic, and improve performance slightly.  The
+hookmem.h file will disappear and the sysquery action will be 
+modified.
+
+2003-05-01
+
+The malldbg system now appears complete.  Documentation in
+info source form is included in nmalloc.txh.  I find the 
+following command useful for creating a viewable or printable
+(but imperfect) .htm doc file:
+
+makeinfo --force --no-split --no-validate --html
+         -o nmalloc.htm nmalloc.txh
+         
+(Above is all one line)         
+
+
+Bug reports to cbfalconer@worldnet.att.net.
diff --git a/gcc/config/i386/nmalloc/sysquery.h b/gcc/config/i386/nmalloc/sysquery.h
new file mode 100644
index 000000000..041ef13f0
--- /dev/null
+++ b/gcc/config/i386/nmalloc/sysquery.h
@@ -0,0 +1,53 @@
+/* -------- sysquery.h ------------ */
+
+/* Copyright (c) 2003 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@worldnet.att.net>
+*/
+
+#ifndef sysquery_h
+#define sysquery_h
+#ifdef __cplusplus
+   extern "C" {
+#endif
+
+/* The settable hooks, identifiers */
+/* HKCOUNT is illegal value */
+enum m_hook_kind {malloc_HK,  malloc_fail_HK,
+                  free_HK,    free_null_HK,
+                  realloc_HK, realloc_exit_HK,
+                  HKCOUNT};
+
+/* Depending on kind, some params may be meaningless */
+typedef void (*M_HOOKFN)(size_t sz, void *bk);
+
+/* returns previous value of the appropriate function */
+typedef M_HOOKFN (*set_m_hook)(enum m_hook_kind which,
+                               M_HOOKFN newhook);
+
+/* This allows a clean connection to debugging software      */
+/* NOTE: ANY value equivalent to -1 means data not available */
+/*       for the unsigned chars this means 0xffh.            */
+struct _sysquery {
+   unsigned char data, gdlo, sz, prvf, nxtf, nxt, prv, ohead;
+   void *        nilp;    /* dummy NULL, &freeptrs[1] */
+   void *        anchors; /* of memory chains */
+   set_m_hook    hookset; /* how to set a hook */
+};
+
+/* This can return the above values, hopefully in a register    */
+/* NONE is used in nextfree, prevfree as the equivalent of NULL */
+/* With the unclean knowledge that nil is actually a pointer to */
+/* freehdrs[1], and that lastsbrk is actually freehdrs[0], the  */
+/* entire malloc structure is open to debuggery.                */
+struct _sysquery _sysmalloc(void);
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif
+/* -------- sysquery.h ------------ */
diff --git a/gcc/config/i386/nmalloc/tmalldbg.c b/gcc/config/i386/nmalloc/tmalldbg.c
new file mode 100644
index 000000000..fb1e1e7ad
--- /dev/null
+++ b/gcc/config/i386/nmalloc/tmalldbg.c
@@ -0,0 +1,416 @@
+/* ------- tmalldbg -------- */
+
+/* Copyright (c) 2003 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@worldnet.att.net>
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+#include "malldbg.h"
+#include "sysquery.h"
+
+/*#include <string.h>
+#include <math.h>
+#include "cokusMT.h"
+*/
+
+/* Number of free lists in system */
+#define NFLISTS ((int)(CHAR_BIT * sizeof(size_t)))
+
+typedef struct testnode {
+   struct testnode *next;
+   char             string[30];
+} testnode;
+
+testnode *root;
+
+int notquiet;
+
+/* 1------------------1 */
+
+/* Build something to display the structure of */
+/* a linked list headed by the global var 'root' */
+static testnode *buildlist(int items, testnode *root)
+{
+   testnode *this;
+
+   while (items) {
+      this = malloc(items + sizeof *this);
+      this->next = root;
+      root = this;
+      sprintf(this->string, "item #%d", items);
+      items--;
+   }
+   return root;
+} /* buildlist */
+
+/* 1------------------1 */
+
+/* retains 1 in three of original list,
+   Ex: a -> b -> c -> d ::= a -> d, b & c freed
+   This allows exercizing the free list compaction */
+static void prunelist(testnode *root)
+{
+   testnode *this, *keep;
+
+   while (root) {
+      keep = root;
+      this = root->next;
+      if ((root = this)) {
+         this = root->next;
+         free(root);
+         if ((root = this)) {
+            this = root->next;
+            free(root);
+            root = this;
+         }
+      }
+      keep->next = root;
+   }
+} /* prunelist */
+
+/* 1------------------1 */
+
+static struct _sysquery sysinfo;
+void                 *(*freehdrsp)[NFLISTS];
+
+
+#define NONE          sysinfo.nilp
+#define lastsbrk      freehdrs[0]
+#define memblockp     void*
+typedef unsigned int  ulong;
+typedef unsigned char byte;
+
+/* conversion and access macros */
+#define DATAOFFSET sysinfo.data
+
+#define MEMBLKp(p) (memblockp)((byte*)(p) - DATAOFFSET)
+#define PTR(m)     (void*)((byte*)(m) + DATAOFFSET)
+
+/* field access macros (AFTER sysinfo loaded)    */
+/* Examples - replace "m->prv" by "fld(m, prv)"  */
+/*            replace "m->sz"  by "szof(m)"      */
+/* where field is prvf, nxtf, prv, nxt           */
+#define fld(m, field)   *((void**)((char*)m + sysinfo.field))
+#define szof(m)         *(ulong*)((char*)m + sysinfo.sz)
+#define freehdrs        (*freehdrsp)
+
+/* 1------------------1 */
+
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+void showsysquery(void)
+{
+   printf("sysinfo is: NONE = %p\n"
+          "     DATAOFFSET  = %d\n"
+          "     gdlo offset = %d\n"
+          "     sz   offset = %d\n"
+          "     prvf offset = %d\n"
+          "     nxtf offset = %d\n"
+          "     nxt  offset = %d\n"
+          "     prv  offset = %d\n"
+          "     ohead       = %d\n"
+          "     &freehdrs   = %p\n"
+          "     &anchors    = %p\n"
+          "     &hookset()  = %p\n",
+          sysinfo.nilp, sysinfo.data, sysinfo.gdlo,
+          sysinfo.sz,  sysinfo.prvf, sysinfo.nxtf,
+          sysinfo.nxt, sysinfo.prv,  sysinfo.ohead,
+          freehdrs, sysinfo.anchors, sysinfo.hookset);
+
+
+} /* showsysquery */
+
+/* 1------------------1 */
+
+/* m is the allocated ptr treated by MEMBLKp    */
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+static void xshowblock(void *m, char *id)
+{
+   if (m) {
+      printf(" %s %p", id, m);
+      printf(" sz=%u nxt=%p prv=%p nxtf=",
+             szof(m), fld(m, nxt), fld(m, prv));
+      if (fld(m, nxtf)) {
+         if (NONE == fld(m, nxtf))
+            printf("NONE prvf=");
+         else
+            printf("%p prvf=", fld(m, nxtf));
+         if (NONE == fld(m, prvf))
+            printf("NONE");
+         else
+            printf("%p", fld(m, prvf));
+      }
+      else printf("0");
+   }
+   else
+      printf(" %s NULL", id);
+   fflush(stdout);  /* to coexist with internal debuggery */
+} /* xshowblock */
+
+/* ========== End of debuggery examples ============= */
+/* ============== Start of tests ==================== */
+
+struct blkspace {
+   unsigned long totspace;
+   unsigned long blkcount;
+};
+
+/* 1------------------1 */
+
+struct blkspace freeblocks()
+{
+   struct blkspace blksp;
+   int             i;
+   memblockp       m;
+
+   blksp.totspace = blksp.blkcount = 0;
+   for (i = 0; i < NFLISTS; i++) {
+      if ((m = freehdrs[i])) {
+         while (m && (NONE !=m )) {
+            blksp.totspace += szof(m);
+            blksp.blkcount++;
+            m = fld(m, nxtf);
+         }
+      }
+   }
+   return blksp;
+} /* freeblocks */
+
+/* 1------------------1 */
+
+void printinfo(struct mallinfo *info)
+{
+   printf("   arena = %d\n", info->arena);
+   printf(" ordblks = %d\n", info->ordblks);
+   printf("  smblks = %d\n", info->smblks);
+   printf("   hblks = %d\n", info->hblks);
+   printf("  hblkhd = %d\n", info->hblkhd);
+   printf(" usmblks = %d\n", info->usmblks);
+   printf(" fsmblks = %d\n", info->fsmblks);
+   printf("uordblks = %d\n", info->uordblks);
+   printf("fordblks = %d\n", info->fordblks); /* free space */
+   printf("keepcost = %d\n", info->keepcost);
+} /* printinfo */
+
+/* 1------------------1 */
+
+void foul2ndlast(testnode *root)
+{
+   testnode *this, *prev;
+   void     *m;
+
+   this = prev = NULL;
+   while (root) {
+      prev = this; this = root; root = root->next;
+   }
+   /* Now prev=>this=>NULL */
+   m = MEMBLKp(prev);
+
+   xshowblock(m, "Fouling block: ");
+   puts("");
+
+   /* acts like a write past the previous block */
+   (*(char*)m)--;
+
+   xshowblock(m, " which became: ");
+   puts("\n");
+
+} /* foul2ndlast */
+
+/* 1------------------1 */
+
+void test01(unsigned long n)
+{
+   struct mallinfo info;
+   struct blkspace blkspace;
+   void  *m;
+
+   root = buildlist(n, root);
+   m = MEMBLKp(root);
+   xshowblock(m, "\nLAST allocated:");
+   puts("");
+
+   blkspace = freeblocks();
+   info = mallinfo();
+   printinfo(&info);
+
+   printf("\nnfreeblk = %lu\n", blkspace.blkcount);
+   printf(" holding ( %lu )\n", blkspace.totspace);
+} /* test01 */
+
+/* 1------------------1 */
+
+void test02(unsigned long n)
+{
+   root = buildlist(n, root);
+   mallocmap();
+} /* test02 */
+
+/* 1------------------1 */
+
+void test03(unsigned long n)
+{
+   struct mallinfo info;
+
+   root = buildlist(n, root);
+   info = mallinfo();
+   puts("\nBefore pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter repruning:");
+   printinfo(&info);
+   puts("\nComplete map:");
+   mallocmap();
+} /* test03 */
+
+/* 1------------------1 */
+
+void test04(unsigned long n)
+{
+   struct mallinfo info;
+   testnode       *this;
+
+   info = mallinfo();
+   puts("\nAt startup:");
+   printinfo(&info);
+   root = buildlist(n, root);
+   info = mallinfo();
+   puts("\nBefore pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter repruning:");
+   printinfo(&info);
+   free(NULL);         /* to check the alert */
+   while ((this = root)) {
+      root = root->next;
+      free(this);
+   }
+   info = mallinfo();
+   puts("\nAfter freeing all:");
+   printinfo(&info);
+   puts("\nComplete map:");
+   mallocmap();
+} /* test04 */
+
+/* 1------------------1 */
+
+void test06(unsigned long n)
+{
+   root = buildlist(n, root);
+   printf("malloc_verify() returns %d\n", malloc_verify());
+   mallocmap();
+} /* test06 */
+
+/* 1------------------1 */
+
+void test07(unsigned long n)
+{
+   root = buildlist(n, root);
+   foul2ndlast(root);
+   printf("malloc_verify() returns %d\n", malloc_verify());
+   mallocmap();
+} /* test07 */
+
+/* 1------------------1 */
+
+void test08(unsigned long n)
+{
+   struct mallinfo info;
+   void  *p, *p1;
+
+   info = mallinfo();
+   puts("\nAt startup:");
+   printinfo(&info);
+   root = buildlist(n, root);
+   info = mallinfo();
+   puts("\nBefore pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter repruning:");
+   printinfo(&info);
+   puts("\nAfter attempting malloc/realloc(INT_MAX):");
+   p = malloc(INT_MAX);
+   p = malloc(2);
+   if (p && (p1 = realloc(p, INT_MAX))) {
+      p = p1; /* shouldn't happen */
+      puts("\nSomething is wrong");
+   }
+   info = mallinfo();
+   printinfo(&info);
+   puts("\nComplete map:");
+   mallocmap();
+} /* test08 */
+
+/* 1------------------1 */
+
+int main(int argc, char *argv[])
+{
+   unsigned long t = 0, n = 0, dbglvl = 0;
+
+   if (argc > 1) t = strtoul(argv[1], NULL, 10);
+   if (argc > 2) n = strtoul(argv[2], NULL, 10);
+   if (argc > 3) dbglvl = strtoul(argv[3], NULL, 10);
+
+   if (0 == n) n = 10;
+
+   printf("test%02lu-%lu (%lu)\n", t, n, dbglvl);
+
+   sysinfo   = _sysmalloc();
+   freehdrsp = (void*)((byte*)(sysinfo.nilp)-sizeof(void*));
+   malloc_debug(dbglvl);
+   if (t != 5) malldbgdumpfile(stdout);
+
+   switch (t) {
+case 1: test01(n); break;
+case 2: test02(n); break;
+case 3: test03(n); break;
+case 4: test04(n); break;
+case 5: test04(n); break; /* see malldbgdumfile call above */
+case 6: test06(n); break;
+case 7: test07(n); break;
+case 8: test08(n); break;
+default:
+        printf("Usage: tmalldbg [testnumber [quantity [level]]]\n");
+        printf("CHAR_BIT * sizeof(size_t) = %lu\n",
+                (unsigned long)(CHAR_BIT * sizeof(size_t)));
+        showsysquery();
+        printf(
+           "\n"
+           "Test Purpose (usually to stdout)\n"
+           "  1  Allocate items, execute/show mallinfo\n"
+           "  2  Allocate items, execute mallocmap\n"
+           "  3  Allocate/prune items, do mallocmap & info\n"
+           "  4  As test 3, but all freed and free(NULL)\n"
+           "  5  As test 4, but dumps to stderr\n"
+           "  6  Allocate items, call malloc_verify / map\n"
+           "  7  As 6, but deliberately foul 2nd last malloc\n"
+           "  8  As 3, but attempt to malloc INT_MAX items\n"
+           );
+        break;
+   } /* switch (t) */
+   return 0;
+} /* main */
+
+/* ------- tmalldbg -------- */
diff --git a/gcc/config/i386/nmalloc/tnmalloc.c b/gcc/config/i386/nmalloc/tnmalloc.c
new file mode 100644
index 000000000..b5bc3e96d
--- /dev/null
+++ b/gcc/config/i386/nmalloc/tnmalloc.c
@@ -0,0 +1,618 @@
+/* ------- tstmalloc -------- */
+
+/* Copyright (c) 2003 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@worldnet.att.net>
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <math.h>
+#include "fakesbrk.h"
+#include "cokusMT.h"
+#include "sysquery.h"
+#include <unistd.h>     /* write */
+
+/* NDEBUG allows this to be used for profiling malloc.o */
+#ifndef NDEBUG
+#  include "nmalloc.h"
+#  define  INTERVAL 10  /* for emitting free list dumps */
+#else
+#  define nmalloc   malloc
+#  define nfree     free
+#  define nrealloc  realloc
+#  define nmemalign memalign
+#  define INTERVAL  1000 /* for emitting free list dumps */
+#endif
+
+/* Magic 1500 below must be > MINSBRK in nmalloc.c */
+enum {FAKESIZE = 1234567,
+      HIFAKESZ = 1500,
+      HIFAKE   = FAKESIZE - HIFAKESZ,
+      NFLISTS  = (int)(CHAR_BIT * sizeof(size_t))
+     };
+
+char fakearea[FAKESIZE];
+
+int notquiet;   /* 0 suppresses most output in this module */
+
+/* 1------------------1 */
+
+/* we can fool with this to generate test cases      */
+/* If I could only figure a way to peg the addresses */
+/* the test runs would be a good regression test.    */
+void *fakesbrk(int delta)
+{
+static char *unused = fakearea;
+static char *hiarea = fakearea + HIFAKE;
+char        *next, *p;
+
+   if (hiarea && (delta >= 32) && (delta < HIFAKESZ)) {
+      /* return something above normal use to test
+         action under decreasing sbrk values */
+      p = hiarea;
+      hiarea = 0;
+      return (void *)p;
+   }
+   /* otherwise just act normally */
+   next = unused + delta;
+   if ((unsigned) next > HIFAKE) return (void *)-1;
+   else {
+      p = unused;
+      unused = next;
+      return (void *)p;
+   }
+} /* fakesbrk */
+
+/* =====================================================
+   This portion is an example of using the _sysmalloc()
+   call to access the inner workings of the malloc pkg.
+   Note the exact parallel between these routines and
+   the corresponding ones in nmalloc.c.
+   =====================================================
+*/
+
+/* 1------------------1 */
+
+static struct _sysquery sysinfo;
+void                 *(*freehdrsp)[NFLISTS];
+
+
+#define NONE          sysinfo.nilp
+#define lastsbrk      freehdrs[0]
+#define memblockp     void*
+typedef unsigned int  ulong;
+typedef unsigned char byte;
+
+/* conversion and access macros */
+#define DATAOFFSET sysinfo.data
+
+#define MEMBLKp(p) (memblockp)((byte*)(p) - DATAOFFSET)
+#define PTR(m)     (void*)((byte*)(m) + DATAOFFSET)
+
+/* field access macros (AFTER sysinfo loaded)    */
+/* Examples - replace "m->prv" by "fld(m, prv)"  */
+/*            replace "m->sz"  by "szof(m)"      */
+/* where field is prvf, nxtf, prv, nxt           */
+#define fld(m, field)   *((void**)((char*)m + sysinfo.field))
+#define szof(m)         *(ulong*)((char*)m + sysinfo.sz)
+#define freehdrs        (*freehdrsp)
+
+/* 1------------------1 */
+
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+void showsysquery(void)
+{
+   printf("sysinfo is: nil = %p\n"
+          "    DATAOFFSET  = %d\n"
+          "    gdlo offset = %d\n"
+          "    sz   offset = %d\n"
+          "    prvf offset = %d\n"
+          "    nxtf offset = %d\n"
+          "    nxt  offset = %d\n"
+          "    prv  offset = %d\n"
+          "    ohead       = %d\n"
+          "    &freehdrs   = %p\n"
+          "    &anchors    = %p\n"
+          "    &hookset()  = %p\n",
+          sysinfo.nilp, sysinfo.data, sysinfo.gdlo,
+          sysinfo.sz,  sysinfo.prvf, sysinfo.nxtf,
+          sysinfo.nxt, sysinfo.prv,  sysinfo.ohead,
+          freehdrs, sysinfo.anchors, sysinfo.hookset);
+
+} /* showsysquery */
+
+/* 1------------------1 */
+
+/* m is the allocated ptr treated by MEMBLKp    */
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+static void xshowblock(void *m, char *id)
+{
+   if (m) {
+      printf(" %s %p", id, m);
+      printf(" sz=%u nxt=%p prv=%p nxtf=",
+             szof(m), fld(m, nxt), fld(m, prv));
+      if (fld(m, nxtf)) {
+         if (NONE == fld(m, nxtf))
+            printf("NONE prvf=");
+         else
+            printf("%p prvf=", fld(m, nxtf));
+         if (NONE == fld(m, prvf))
+            printf("NONE");
+         else
+            printf("%p", fld(m, prvf));
+      }
+      else printf("0");
+   }
+   else
+      printf(" %s NULL", id);
+   fflush(stdout);  /* to coexist with internal debuggery */
+} /* xshowblock */
+
+/* 1------------------1 */
+
+/* dump the entire free chain group             */
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+static void xdumpfree(void)
+{
+   int       i;
+   memblockp m;
+   ulong     totfree;
+
+   totfree = 0;
+   for (i = 0; i < NFLISTS; i++) {
+      if ((m = freehdrs[i])) {
+         printf("\n%2d: ", i);
+         do {
+            printf("%p(%u)->", m, szof(m));
+            totfree += szof(m);
+            m = fld(m, nxtf);
+         } while (m && (NONE != m));
+         printf("0");
+         m = freehdrs[i];
+         while (m && (NONE !=m )) {
+            xshowblock(m, "\n     ");
+            m = fld(m, nxtf);
+         }
+      }
+   }
+   printf("\nTotal Free = %u\n", totfree);
+   fflush(stdout);  /* to coexist with internal debuggery */
+} /* xdumpfree */
+
+/* ========== End of debuggery examples ============= */
+/* ============== Start of tests ==================== */
+
+/* Just allocate increasing sizes */
+void test01(int n)
+{
+   int   i;
+   void *m;
+
+   for (i = 0; i < n; i++) m = nmalloc(65 * i);
+} /* test01 */
+
+/* 1------------------1 */
+
+/* allocate increasing sizes, freeing what was allocated
+   10 items earlier.  Monitor free list every 10th.  Free
+   everything at end.  Perturb sbrk return values.
+*/
+void test02(int n)
+{
+   int   i;
+   void *m[10] = {0};
+
+   for (i = 0; i < n; i++) {
+      nfree(m[i % 10]);
+      m[i % 10] = nmalloc(15 * i);
+      if (0 == (i % 30)) (void)fakesbrk(3);
+      if ( (INTERVAL - 1) == (i % INTERVAL )
+          && notquiet)
+         xdumpfree();
+   }
+   for (i = 0; i < 10; i++) nfree(m[i]);
+   xdumpfree();
+} /* test02 */
+
+/* 1------------------1 */
+
+enum {STDIN = 0, STDOUT, STDERR, STDAUX, STDPRN}; /* handles */
+
+/* made to be compatible with nmalloc internal debugger */
+void inject(int i)
+{
+   char buf[20];
+
+#ifndef NDEBUG
+   sprintf(buf, "%03d: ", i);
+   write(STDOUT, buf, strlen(buf));
+#endif
+} /* inject */
+
+/* 1------------------1 */
+
+/* allocate random sizes, free, finally abort. Perturb sbrk */
+void test03(int n)
+{
+   int   i;
+   void *m[10] = {0};
+
+   if (0 == n) n = 10;
+
+   for (i = 0; i < n; i++) {
+      if (m[i % 10]) inject(i);
+      nfree(m[i % 10]);
+      if (notquiet) inject(i);
+      m[i % 10] = nmalloc(randomMT() % 10000);
+
+      if (0 == i) xshowblock(MEMBLKp(m[0]), "\n*testing*");
+
+      if (0 == (i % 30)) (void)fakesbrk(3);
+      if ( (INTERVAL - 1) == (i % INTERVAL )
+          && notquiet)
+         xdumpfree();
+   }
+   for (i = 0; i < 10; i++) {
+      if (m[i] && notquiet) inject(i);
+      nfree(m[i]);
+   }
+   xdumpfree();
+   if (n & 1) {
+      printf("\nDeliberately refreeing pointer, should abort\n\n");
+      fflush(stdout);
+      nfree(m[0]);
+   }
+} /* test03 */
+
+/* 1------------------1 */
+
+/* allocate random sizes, realloc, free. Perturb sbrk */
+void test04(int n)
+{
+   int   i;
+   void *m[10] = {0};
+   void *temp;
+
+   for (i = 0; i < n; i++) {
+      if (m[i % 10]) inject(i);
+      nfree(m[i % 10]);
+      if (notquiet) inject(i);
+      m[i % 10] = nmalloc(randomMT() % 10000);
+      if (notquiet) inject(i);
+      temp = nrealloc(m[i % 10], randomMT() % 10000);
+      if (temp) m[i % 10] = temp;
+      if (0 == (i % 30)) (void)fakesbrk(3);
+      if ( (INTERVAL - 1) == (i % INTERVAL)
+           && notquiet)
+         xdumpfree();
+   }
+   for (i = 0; i < 10; i++) {
+      if (m[i] && notquiet) inject(i);
+      nfree(m[i]);
+   }
+   xdumpfree();
+} /* test04 */
+
+/* 1------------------1 */
+
+/* made to be compatible with nmalloc internal debugger */
+void showijk(int i, int j, int k)
+{
+   char buf[20];
+
+#ifndef NDEBUG
+   sprintf(buf, "%03d:%d:%d ", i, j, k);
+   write(STDOUT, buf, strlen(buf));
+#endif
+} /* showijk */
+
+/* 1------------------1 */
+
+/* free 10 items, allocate 10 random sizes, realloc 10 random  */
+/* Much like test 4, but a different sequence. No sbrk perturb */
+void test05(int n)
+{
+   int   i, j, k, ix;
+   void *m[10] = {0};
+   void *temp;
+
+   for (i = 0; i < n; i++) {
+      j = (i / 10) % 3;   /* 0, 1, or 2 */
+      k = (i % 10);
+      ix = k + 10 * (i / 30);
+      if (0 == j) {
+         if (notquiet) showijk(i, j, k);
+         temp = nrealloc(m[k], randomMT() % 10000);
+         if (temp) m[k] = temp;
+         if ( (INTERVAL - 1) == (i % INTERVAL)
+             && notquiet)
+            xdumpfree();
+      }
+      if (1 == j) {
+         if (m[k]) {
+            if (notquiet) showijk(i, j, k);
+            nfree(m[k]);
+            m[k] = NULL;
+         }
+         if ( (INTERVAL - 1) == (i % INTERVAL)
+              && notquiet)
+            xdumpfree();
+      }
+      if (2 == j) {
+         if (notquiet) showijk(i, j, k);
+         m[k] = nmalloc(randomMT() % 10000);
+         if ( (INTERVAL - 1) == (i % INTERVAL)
+              && notquiet)
+            xdumpfree();
+      }
+      if (0 == i) (void)fakesbrk(3); /* make 2 blocks */
+   }
+   for (i = 0; i < 10; i++) {
+      if (m[i]) {
+         if (notquiet) inject(i);
+         nfree(m[i]);
+      }
+   }
+   xdumpfree();
+} /* test05 */
+
+/* 1------------------1 */
+
+/* reallocate random sizes continuously */
+void test06(int n)
+{
+   int   i;
+   void *m[10] = {0};
+   void *temp;
+
+   for (i = 0; i < n; i++) {
+      if (notquiet) inject(i);
+      temp = nrealloc(m[i % 10], randomMT() % 10000);
+      if (temp) m[i % 10] = temp;
+      if ( (INTERVAL - 1) == (i % INTERVAL)
+           && notquiet)
+         xdumpfree();
+   }
+   for (i = 0; i < 10; i++) {
+      if (m[i] && notquiet) inject(i);
+      nfree(m[i]);
+   }
+   xdumpfree();
+} /* test06 */
+
+/* 1------------------1 */
+
+/* reallocate random sizes continuously, check data unharmed */
+/* This writes over all allocated memory, so it is a fairly  */
+/* good test that nothing is out of place.                   */
+void test07(int n)
+{
+   int             i, j, k;
+   void           *m[10] = {0};
+   int             sz[10] = {0};
+   int             newsz, minsz;
+   unsigned char  *p;
+
+   void *temp;
+
+   for (i = 0; i < n; i++) {
+      if (notquiet) inject(i);
+      k = i % 10;
+      minsz = newsz = randomMT() % 10000;
+      if (sz[k] < minsz) minsz = sz[k];
+      if (m[k]) {
+         p = m[k];
+         for (j = 0; j < sz[k]; j++) {
+            /* null loop for initial access */
+            p[j] = j & 0xff;
+         }
+      }
+      temp = nrealloc(m[k], newsz);
+      if (temp) {
+         p = m[k] = temp;
+         sz[k] = newsz;
+         for (j = 0; j < minsz; j++) {
+            /* null loop for initial access */
+            if (p[j] != (j & 0xff)) {
+               printf("Data failure at index %d!!\n", j);
+               printf("is %d should be %d\n",
+                       p[j], j & 0xff);
+               fflush(stdout);
+               exit(EXIT_FAILURE);
+            }
+         }
+      }
+      if ( (INTERVAL - 1) == (i % INTERVAL)
+           && notquiet)
+         xdumpfree();
+   }
+   for (i = 0; i < 10; i++) {
+      if (m[i] && notquiet) inject(i);
+      nfree(m[i]);
+   }
+   xdumpfree();
+} /* test07 */
+
+/* 1------------------1 */
+
+/* From the C-FAQ, slightly modified
+ * Most likely value is 0, + or - 5 are rare
+ */
+double gaussrand(void)
+{
+   static double V2, X;
+   static int    phase = 0;
+   double        Y, U1, U2, V1, S;
+
+   if (phase) Y = V2 * X;
+   else {
+      do {
+         U1 = (double)randomMT() / ranMTMAX;
+         U2 = (double)randomMT() / ranMTMAX;
+
+         V1 = 2 * U1 - 1;
+         V2 = 2 * U2 - 1;
+         S = V1 * V1 + V2 * V2;
+      } while (S >= 1 || S == 0);
+
+      Y = V1 * (X = sqrt(-2 * log(S) / S));
+   }
+   phase = 1 - phase;
+   return Y;
+} /* gaussrand */
+
+/* 1------------------1 */
+
+/* maps gaussrand -inf .. 0 into 0..1 and
+ *                0 .. +inf into 1..inf.
+ * Most likely value is slightly less than 1
+ * 5.0 is fairly rare, 120.0 extremely rare
+ */
+double gausspos(void)
+{
+#define GAUSSLIMIT 10.0
+   double r;
+
+   if (GAUSSLIMIT < (r = gaussrand()))  /* limit */
+      r = GAUSSLIMIT;
+   return exp(r);
+} /* gausspos */
+
+/* 1------------------1 */
+
+typedef struct node {
+   struct node *next;
+   char        *wastage;
+} node, *nodeptr;
+
+/* Under development for long term thrashing */
+void test08(int n, int reps)
+{
+   int     i, j;
+   nodeptr root, temp;
+   size_t  sz, totalsz;
+
+   printf("Under development\n"); fflush(stdout);
+   j = 0;
+   do {
+      if (reps) {
+         printf("Repetion %d\n", j + 1); fflush(stdout);
+      }
+      root = NULL; totalsz = 0;
+      for (i = 0; i < n; i++) {
+         /* form singly linked list of various sizes */
+         if (!(temp = nmalloc(sizeof *temp))) {
+            fprintf(stderr, "malloc node failed\n");
+            exit(EXIT_FAILURE);
+         }
+         else {
+            sz = (1 + gausspos()) * 32.0;
+            if (!(temp->wastage = nmalloc(sz))) {
+               fprintf(stderr, "malloc wastage failed\n");
+               exit(EXIT_FAILURE);
+            }
+            else {
+               temp->next = root;
+               root = temp;
+               totalsz += sz;
+            }
+         }
+      } /* for, formed base list */
+
+      xdumpfree();
+
+      /* liberate it all */
+      while (root) {
+         nfree(root->wastage);
+         temp = root->next;
+         nfree(root);
+         root = temp;
+      } /* while */
+
+      xdumpfree();
+   } while (++j < reps);
+} /* test08 */
+
+/* 1------------------1 */
+
+/* Under development for memalign exercise */
+void test09(int n, int reps)
+{
+   int   i;
+   void *p;
+
+   printf("Under development\n"); fflush(stdout);
+   if (!reps) reps = 512;
+   for (i = 0; i < n; i++) {
+      p = nmemalign(65 * i, reps);
+   }
+} /* test09 */
+
+/* 1------------------1 */
+
+int main(int argc, char *argv[])
+{
+   unsigned long t = 0, n = 0, reps = 0;
+
+   if (argc > 1) t = strtoul(argv[1], NULL, 10);
+   if (argc > 2) n = strtoul(argv[2], NULL, 10);
+   if (argc < 4) notquiet = 1;
+   else {
+      reps = strtoul(argv[3], NULL, 10);
+      notquiet = !(reps & 1);
+   }
+
+   if (0 == n) n = 10;
+
+   printf("test%02lu-%lu (%lu)\n", t, n, reps);
+   fflush(stdout);  /* Needed to coexist with debug pkg */
+
+   sysinfo   = _sysmalloc();
+   freehdrsp = (void*)((byte*)(sysinfo.nilp)-sizeof(void*));
+
+   (void) fakesbrk(1);  /* start it off on odds */
+   switch (t) {
+case 1: test01(n); break;
+case 2: test02(n); break;
+case 3: test03(n); break;
+case 4: test04(n); break;
+case 5: test05(n); break;
+case 6: test06(n); break;
+case 7: test07(n); break;
+case 8: test08(n, reps); break;
+case 9: test09(n, reps); break;
+default:
+        printf("Usage: tnmalloc [testnumber [quantity [reps]]]\n");
+        printf("fakearea at %p through %p (was f594)\n",
+               &fakearea, &fakearea[FAKESIZE-1]);
+        printf("CHAR_BIT * sizeof(size_t) = %lu\n",
+                (unsigned long)(CHAR_BIT * sizeof(size_t)));
+        showsysquery();
+        printf(
+           "Test Purpose\n"
+           "  1  malloc only\n"
+           "  2  malloc and free\n"
+           "  3  malloc(random), free, aborts for odd quantity\n"
+           "  4  malloc(random), realloc(random), and free\n"
+           "  5  malloc(10 random), realloc(10 random) and free 10\n"
+           "  6  realloc(random), monitor free lists\n"
+           "  7  realloc(random), check data unharmed\n"
+           "  8  run a long faked sequence, not complete\n"
+           "  9  test memalign operation\n"
+           "Any odd entry for reps suppresses free list dumps\n"
+           );
+        break;
+   } /* switch (t) */
+   return 0;
+} /* main */
+
+/* ------- tstmalloc -------- */
diff --git a/gcc/config/i386/nmalloc/xref.exe b/gcc/config/i386/nmalloc/xref.exe
new file mode 100644
index 000000000..0823aa85c
Binary files /dev/null and b/gcc/config/i386/nmalloc/xref.exe differ
diff --git a/gcc/config/i386/x-djgpp b/gcc/config/i386/x-djgpp
new file mode 100644
index 000000000..467eb8343
--- /dev/null
+++ b/gcc/config/i386/x-djgpp
@@ -0,0 +1,41 @@
+#-----------------------------------------------------------------------------
+# The following code is copied from config/mh-djgpp as one may 
+# want to run make in gcc build directory instead of toplevel 
+# one (for example 'make restage2' or similar which are not available
+# from top level makefile and we should have the same substitutions 
+# in this case)           
+#-----------------------------------------------------------------------------
+
+# Shorten the target alias so when it is used to set 'libsubdir'
+# the name will work in both short and long filename environments.
+ifeq ($(findstring -pc-msdosdjgpp,$(target_alias)),-pc-msdosdjgpp)
+target_alias=djgpp
+endif
+
+# The version string must be modified to contain just one dot
+# because DOS filenames can only have one dot when long filenames
+# are not available.
+#
+version := $(shell echo $(version) | sed -e 's:\.::2g')
+
+# on DJGPP the 'ln -s' does not work correctly
+LN = cp -p
+LN_S = cp -p
+
+# Replace DJGPP malloc with nmalloc
+EXTRA_OBJS += malloc.o
+EXTRA_GCC_OBJS += malloc.o
+
+# Use a larger stack for CC1, CC1PLUS, etc.
+# One cannot use EXTRA_OBJS as djgpp-stack.o only contains data definition (_stklen)
+BACKEND += djgpp-stack.o
+
+# Some build tools also require larger stack
+BUILD_RTL += djgpp-stack.o
+
+malloc.o: $(srcdir)/config/i386/nmalloc/nmalloc.c $(srcdir)/config/i386/nmalloc/memalign.c \
+		$(srcdir)/config/i386/nmalloc/sysquery.h
+	$(CC) -c -O2 -W -Wall -DMEMALIGN $< -o $@
+
+djgpp-stack.o: $(srcdir)/config/i386/djgpp-stack.c
+	$(CC) -c -O2 -W -Wall $< -o $@
diff --git a/gcc/config/i386/xm-djgpp.h b/gcc/config/i386/xm-djgpp.h
index c3758ea9e..c2a3277c7 100644
--- a/gcc/config/i386/xm-djgpp.h
+++ b/gcc/config/i386/xm-djgpp.h
@@ -23,6 +23,28 @@ along with GCC; see the file COPYING3.  If not see
 
 #define HOST_EXECUTABLE_SUFFIX ".exe"
 
+/* Define standard DJGPP installation paths.  */
+/* We override default /usr or /usr/local part with /dev/env/DJDIR which */
+/* points to actual DJGPP installation directory.  */
+
+/* Standard include directory */
+#undef STANDARD_INCLUDE_DIR
+#define STANDARD_INCLUDE_DIR "/dev/env/DJDIR/include/"
+
+#undef PREFIX_INCLUDE_DIR
+
+/* Search for as.exe and ld.exe in DJGPP's binary directory.  */ 
+#undef MD_EXEC_PREFIX
+#define MD_EXEC_PREFIX "/dev/env/DJDIR/bin/"
+
+/* Standard DJGPP library and startup files */
+#undef MD_STARTFILE_PREFIX
+#define MD_STARTFILE_PREFIX "/dev/env/DJDIR/lib/"
+
+/* Make sure that gcc will not look for .h files in /usr/local/include 
+   unless user explicitly requests it.  */
+#undef LOCAL_INCLUDE_DIR
+
 /* System dependent initialization for collect2
    to tell system() to act like Unix.  */
 #define COLLECT2_HOST_INITIALIZATION \
@@ -58,12 +80,12 @@ along with GCC; see the file COPYING3.  If not see
            to try and figure out what's wrong.  */ \
         char *djgpp = getenv ("DJGPP"); \
         if (djgpp == NULL) \
-          fatal ("environment variable DJGPP not defined"); \
+          fatal_error ("environment variable DJGPP not defined"); \
         else if (access (djgpp, R_OK) == 0) \
-          fatal ("environment variable DJGPP points to missing file '%s'", \
+          fatal_error ("environment variable DJGPP points to missing file '%s'", \
                  djgpp); \
         else \
-          fatal ("environment variable DJGPP points to corrupt file '%s'", \
+          fatal_error ("environment variable DJGPP points to corrupt file '%s'", \
                   djgpp); \
       } \
   } while (0)
@@ -82,3 +104,15 @@ along with GCC; see the file COPYING3.  If not see
       strcat (fixed_path, "/");			\
       (PATH) = xstrdup (fixed_path);		\
     } 
+
+/* Rename libstdc++ to libstdcxx as the first name is not valid for DOS */
+#define LIBSTDCXX "stdcxx"
+#define LIBSTDCXX_PROFILE "stdcxx"
+#define LIBSTDCXX_STATIC "stdcxx"
+
+/* Definition is missing in DJGPP headers. That broke building
+   GNU Fortran compiler in GCC-4.1 */
+typedef unsigned int uint;
+
+#undef MAX_OFILE_ALIGNMENT
+#define MAX_OFILE_ALIGNMENT 128
diff --git a/gcc/configure b/gcc/configure
index c8caff252..15b7ab3be 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -797,6 +797,7 @@ LDFLAGS
 CFLAGS
 CC
 GENINSRC
+libstdcxx_incdir_base
 target_subdir
 host_subdir
 build_subdir
@@ -3299,11 +3300,14 @@ fi
 
 
 # This logic must match libstdc++-v3/acinclude.m4:GLIBCXX_EXPORT_INSTALL_INFO.
+libstdcxx_incdir_base=c++
+
+
 if test x${gcc_gxx_include_dir} = x; then
   if test x${enable_version_specific_runtime_libs} = xyes; then
-    gcc_gxx_include_dir='${libsubdir}/include/c++'
+    gcc_gxx_include_dir='${libsubdir}/include/$(libstdcxx_incdir_base)'
   else
-    libstdcxx_incdir='include/c++/$(version)'
+    libstdcxx_incdir='include/$(libstdcxx_incdir_base)/$(version)'
     if test x$host != x$target; then
        libstdcxx_incdir="$target_alias/$libstdcxx_incdir"
     fi
@@ -17527,7 +17531,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17530 "configure"
+#line 17534 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -17633,7 +17637,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17636 "configure"
+#line 17640 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 48605c851..899e89699 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -132,11 +132,14 @@ no)	;;
 esac])
 
 # This logic must match libstdc++-v3/acinclude.m4:GLIBCXX_EXPORT_INSTALL_INFO.
+libstdcxx_incdir_base=c++
+AC_SUBST(libstdcxx_incdir_base)
+
 if test x${gcc_gxx_include_dir} = x; then
   if test x${enable_version_specific_runtime_libs} = xyes; then
-    gcc_gxx_include_dir='${libsubdir}/include/c++'
+    gcc_gxx_include_dir='${libsubdir}/include/$(libstdcxx_incdir_base)'
   else
-    libstdcxx_incdir='include/c++/$(version)'
+    libstdcxx_incdir='include/$(libstdcxx_incdir_base)/$(version)'
     if test x$host != x$target; then
        libstdcxx_incdir="$target_alias/$libstdcxx_incdir"
     fi
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 6efd037c5..027295591 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -636,6 +636,10 @@ proper position among the other output files.  */
 #endif
 
 
+#ifndef POST_LINK_SPEC
+#define POST_LINK_SPEC ""
+#endif
+
 /* -u* was put back because both BSD and SysV seem to support it.  */
 /* %{static:} simply prevents an error message if the target machine
    doesn't handle -static.  */
@@ -664,7 +668,7 @@ proper position among the other output files.  */
     %(mflib) " STACK_SPLIT_SPEC "\
     %{fprofile-arcs|fprofile-generate*|coverage:-lgcov}\
     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
-    %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}"
+    %{!nostdlib:%{!nostartfiles:%E}} %{T*}  \n%(post_link) }}}}}}"
 #endif
 
 #ifndef LINK_LIBGCC_SPEC
@@ -708,6 +712,7 @@ static const char *linker_name_spec = LINKER_NAME;
 static const char *linker_plugin_file_spec = "";
 static const char *lto_wrapper_spec = "";
 static const char *lto_gcc_spec = "";
+static const char *post_link_spec = POST_LINK_SPEC;
 static const char *link_command_spec = LINK_COMMAND_SPEC;
 static const char *link_libgcc_spec = LINK_LIBGCC_SPEC;
 static const char *startfile_prefix_spec = STARTFILE_PREFIX_SPEC;
@@ -1114,10 +1119,12 @@ static const char *const standard_startfile_prefix = STANDARD_STARTFILE_PREFIX;
 static const char *md_exec_prefix = MD_EXEC_PREFIX;
 static const char *md_startfile_prefix = MD_STARTFILE_PREFIX;
 static const char *md_startfile_prefix_1 = MD_STARTFILE_PREFIX_1;
+#ifndef __DJGPP__
 static const char *const standard_startfile_prefix_1
   = STANDARD_STARTFILE_PREFIX_1;
 static const char *const standard_startfile_prefix_2
   = STANDARD_STARTFILE_PREFIX_2;
+#endif
 
 /* A relative path to be used in finding the location of tools
    relative to the driver.  */
@@ -1198,6 +1205,7 @@ static struct spec_list static_specs[] =
   INIT_STATIC_SPEC ("linker_plugin_file",	&linker_plugin_file_spec),
   INIT_STATIC_SPEC ("lto_wrapper",		&lto_wrapper_spec),
   INIT_STATIC_SPEC ("lto_gcc",			&lto_gcc_spec),
+  INIT_STATIC_SPEC ("post_link",                &post_link_spec),
   INIT_STATIC_SPEC ("link_libgcc",		&link_libgcc_spec),
   INIT_STATIC_SPEC ("md_exec_prefix",		&md_exec_prefix),
   INIT_STATIC_SPEC ("md_startfile_prefix",	&md_startfile_prefix),
@@ -6160,17 +6168,18 @@ main (int argc, char **argv)
 				   CL_DRIVER,
 				   &decoded_options, &decoded_options_count);
 
-#ifdef GCC_DRIVER_HOST_INITIALIZATION
-  /* Perform host dependent initialization when needed.  */
-  GCC_DRIVER_HOST_INITIALIZATION;
-#endif
-
   /* Unlock the stdio streams.  */
   unlock_std_streams ();
 
   gcc_init_libintl ();
 
   diagnostic_initialize (global_dc, 0);
+
+#ifdef GCC_DRIVER_HOST_INITIALIZATION
+  /* Perform host dependent initialization when needed.  */
+  GCC_DRIVER_HOST_INITIALIZATION;
+#endif
+
   if (atexit (delete_temp_files) != 0)
     fatal_error ("atexit failed");
 
@@ -6423,6 +6432,7 @@ main (int argc, char **argv)
 		      NULL, PREFIX_PRIORITY_LAST, 0, 1);
 	}
 
+#ifndef __DJGPP__
       /* Sysrooted prefixes are relocated because target_system_root is
 	 also relocated by gcc_exec_prefix.  */
       if (*standard_startfile_prefix_1)
@@ -6433,6 +6443,7 @@ main (int argc, char **argv)
 	add_sysrooted_prefix (&startfile_prefixes,
 			      standard_startfile_prefix_2, "BINUTILS",
 			      PREFIX_PRIORITY_LAST, 0, 1);
+#endif
     }
 
   /* Process any user specified specs in the order given on the command
diff --git a/gcc/ginclude/float.h b/gcc/ginclude/float.h
index b78cc0ca6..057b4019b 100644
--- a/gcc/ginclude/float.h
+++ b/gcc/ginclude/float.h
@@ -25,6 +25,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  * ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>
  */
 
+#ifdef __DJGPP__
+#include_next <float.h>
+#endif
+
 #ifndef _FLOAT_H___
 #define _FLOAT_H___
 
diff --git a/gcc/ginclude/stdint-wrap.h b/gcc/ginclude/stdint-wrap.h
index e45f8198b..779297f95 100644
--- a/gcc/ginclude/stdint-wrap.h
+++ b/gcc/ginclude/stdint-wrap.h
@@ -1,6 +1,15 @@
 #ifndef _GCC_WRAP_STDINT_H
 #if __STDC_HOSTED__
-# include_next <stdint.h>
+# if defined(__DJGPP__)
+#  include <sys/version.h>
+#  if __DJGPP__<2 || (__DJGPP__==2 && __DJGPP_MINOR__<=3)
+#   include "stdint-gcc.h"
+#  else
+#   include_next <stdint.h>
+#  endif   	
+# else
+#  include_next <stdint.h>
+# endif
 #else
 # include "stdint-gcc.h"
 #endif
diff --git a/gcc/gthr-posix.c b/gcc/gthr-posix.c
index 1987ba738..b143fcf30 100644
--- a/gcc/gthr-posix.c
+++ b/gcc/gthr-posix.c
@@ -177,7 +177,7 @@ pthread_cond_wait (pthread_cond_t *cond ATTRIBUTE_UNUSED,
 }
 
 int
-pthread_cond_timedwait (pthread_cond_t *cond ATTRIBUTE_UNUSED, 
+pthread_cond_timedwait (pthread_cond_t *cond ATTRIBUTE_UNUSED, 
 			pthread_mutex_t *mutex ATTRIBUTE_UNUSED,
 			const struct timespec *abstime ATTRIBUTE_UNUSED)
 {
diff --git a/include/libiberty.h b/include/libiberty.h
index 1cc7250bf..9c4880a66 100644
--- a/include/libiberty.h
+++ b/include/libiberty.h
@@ -102,7 +102,7 @@ extern int writeargv PARAMS ((char **, FILE *));
    to find the declaration so provide a fully prototyped one.  If it
    is 1, we found it so don't provide any declaration at all.  */
 #if !HAVE_DECL_BASENAME
-#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) || defined (HAVE_DECL_BASENAME)
+#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) || defined (__DJGPP__) || defined (HAVE_DECL_BASENAME)
 extern char *basename (const char *);
 #else
 /* Do not allow basename to be used if there is no prototype seen.  We
diff --git a/libada/Makefile.in b/libada/Makefile.in
index dbead7005..86bf8f15e 100644
--- a/libada/Makefile.in
+++ b/libada/Makefile.in
@@ -74,6 +74,12 @@ include $(GCC_DIR)/libgcc.mvars
 
 target_noncanonical:=@target_noncanonical@
 version := $(shell cat $(srcdir)/../gcc/BASE-VER)
+
+ifneq ($(findstring djgpp, $(build)),)
+tmp_version := $(shell echo $(version) | sed -e 's:\.::2g')
+version := $(tmp_version)
+endif
+
 libsubdir := $(libdir)/gcc/$(target_noncanonical)/$(version)$(MULTISUBDIR)
 ADA_RTS_DIR=$(GCC_DIR)/ada/rts$(subst /,_,$(MULTISUBDIR))
 ADA_RTS_SUBDIR=./rts$(subst /,_,$(MULTISUBDIR))
diff --git a/libcpp/files.c b/libcpp/files.c
index 456c0b0f1..da63e97f9 100644
--- a/libcpp/files.c
+++ b/libcpp/files.c
@@ -645,6 +645,10 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)
     cpp_error (pfile, CPP_DL_WARNING,
 	       "%s is shorter than expected", file->path);
 
+/* For DOS we should handle DOS EOF character (0x1A, ^Z). It is
+   only done if it is really the last character of the file  */
+  if (total>0 && buf[total-1]==0x1A) total--;
+
   file->buffer = _cpp_convert_input (pfile,
 				     CPP_OPTION (pfile, input_charset),
 				     buf, size, total,
diff --git a/libgcc/config.host b/libgcc/config.host
index 25e949e0f..c16323378 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -611,6 +611,7 @@ case ${host} in
 i[34567]86-*-darwin* | x86_64-*-darwin* | \
   i[34567]86-*-kfreebsd*-gnu | x86_64-*-kfreebsd*-gnu | \
   i[34567]86-*-linux* | x86_64-*-linux* | \
+  i[34567]86-*-msdosdjgpp* | \
   i[34567]86-*-gnu* | \
   i[34567]86-*-solaris2* | \
   i[34567]86-*-cygwin* | i[34567]86-*-mingw* | x86_64-*-mingw* | \
diff --git a/libgcc/config/avr/t-avr b/libgcc/config/avr/t-avr
index ee5707241..8f9e888da 100644
--- a/libgcc/config/avr/t-avr
+++ b/libgcc/config/avr/t-avr
@@ -1,19 +1,19 @@
-# Extra 16-bit integer functions.
-intfuncs16 = _absvXX2 _addvXX3 _subvXX3 _mulvXX3 _negvXX2 _ffsXX2 _clzXX2 \
-             _ctzXX2 _popcountXX2 _parityXX2
-hiintfuncs16 = $(subst XX,hi,$(intfuncs16))
-siintfuncs16 = $(subst XX,si,$(intfuncs16))
-
-iter-items := $(hiintfuncs16)
-iter-labels := $(siintfuncs16)
-iter-sizes := $(patsubst %,2,$(siintfuncs16)) $(patsubst %,2,$(hiintfuncs16))
-
-
-include $(srcdir)/empty.mk $(patsubst %,$(srcdir)/siditi-object.mk,$(iter-items))
-libgcc-objects += $(patsubst %,%$(objext),$(hiintfuncs16))
-
-ifeq ($(enable_shared),yes)
-libgcc-s-objects += $(patsubst %,%_s$(objext),$(hiintfuncs16))
-endif
-
-
+# Extra 16-bit integer functions.
+intfuncs16 = _absvXX2 _addvXX3 _subvXX3 _mulvXX3 _negvXX2 _ffsXX2 _clzXX2 \
+             _ctzXX2 _popcountXX2 _parityXX2
+hiintfuncs16 = $(subst XX,hi,$(intfuncs16))
+siintfuncs16 = $(subst XX,si,$(intfuncs16))
+
+iter-items := $(hiintfuncs16)
+iter-labels := $(siintfuncs16)
+iter-sizes := $(patsubst %,2,$(siintfuncs16)) $(patsubst %,2,$(hiintfuncs16))
+
+
+include $(srcdir)/empty.mk $(patsubst %,$(srcdir)/siditi-object.mk,$(iter-items))
+libgcc-objects += $(patsubst %,%$(objext),$(hiintfuncs16))
+
+ifeq ($(enable_shared),yes)
+libgcc-s-objects += $(patsubst %,%_s$(objext),$(hiintfuncs16))
+endif
+
+
diff --git a/libgfortran/Makefile.am b/libgfortran/Makefile.am
index d1e6d4f94..3fc460051 100644
--- a/libgfortran/Makefile.am
+++ b/libgfortran/Makefile.am
@@ -39,11 +39,21 @@ libgfortran_la_LINK = $(LINK) $(libgfortran_la_LDFLAGS)
 libgfortran_la_LDFLAGS = -version-info `grep -v '^\#' $(srcdir)/libtool-version` $(LTLDFLAGS) $(LIBQUADLIB) -lm $(extra_ldflags_libgfortran) $(version_arg)
 libgfortran_la_DEPENDENCIES = $(version_dep) libgfortran.spec $(LIBQUADLIB_DEP)
 
+if DJGPP
+myexeclib_LTLIBRARIES = libgf95begin.la
+else
 myexeclib_LTLIBRARIES = libgfortranbegin.la
-myexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)
+endif
+myexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version_alias)$(MULTISUBDIR)
+if DJGPP
+libgf95begin_la_SOURCES = fmain.c
+libgf95begin_la_LDFLAGS = -static
+libgf95begin_la_LINK = $(LINK) $(libgf95begin_la_LDFLAGS)
+else
 libgfortranbegin_la_SOURCES = fmain.c
 libgfortranbegin_la_LDFLAGS = -static
 libgfortranbegin_la_LINK = $(LINK) $(libgfortranbegin_la_LDFLAGS)
+endif
 
 ## io.h conflicts with a system header on some platforms, so
 ## use -iquote
diff --git a/libgfortran/Makefile.in b/libgfortran/Makefile.in
index dac8bb84c..564584f62 100644
--- a/libgfortran/Makefile.in
+++ b/libgfortran/Makefile.in
@@ -88,6 +88,10 @@ am__base_list = \
 am__installdirs = "$(DESTDIR)$(myexeclibdir)" \
 	"$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(toolexeclibdir)"
 LTLIBRARIES = $(myexeclib_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)
+libgf95begin_la_LIBADD =
+@DJGPP_TRUE@am_libgf95begin_la_OBJECTS = fmain.lo
+libgf95begin_la_OBJECTS = $(am_libgf95begin_la_OBJECTS)
+@DJGPP_TRUE@am_libgf95begin_la_rpath = -rpath $(myexeclibdir)
 libgfortran_la_LIBADD =
 am__objects_1 = backtrace.lo bounds.lo compile_options.lo \
 	convert_char.lo environ.lo error.lo fpu.lo main.lo memory.lo \
@@ -287,8 +291,9 @@ am__objects_48 = $(am__objects_1) $(am__objects_40) $(am__objects_41) \
 @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo
 libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)
 libgfortranbegin_la_LIBADD =
-am_libgfortranbegin_la_OBJECTS = fmain.lo
+@DJGPP_FALSE@am_libgfortranbegin_la_OBJECTS = fmain.lo
 libgfortranbegin_la_OBJECTS = $(am_libgfortranbegin_la_OBJECTS)
+@DJGPP_FALSE@am_libgfortranbegin_la_rpath = -rpath $(myexeclibdir)
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp = $(SHELL) $(top_srcdir)/../depcomp
 am__depfiles_maybe = depfiles
@@ -314,7 +319,8 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 FCCOMPILE = $(FC) $(AM_FCFLAGS) $(FCFLAGS)
 LTFCCOMPILE = $(LIBTOOL) --tag=FC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=compile $(FC) $(AM_FCFLAGS) $(FCFLAGS)
-SOURCES = $(libgfortran_la_SOURCES) $(libgfortranbegin_la_SOURCES)
+SOURCES = $(libgf95begin_la_SOURCES) $(libgfortran_la_SOURCES) \
+	$(libgfortranbegin_la_SOURCES)
 MULTISRCTOP = 
 MULTIBUILDTOP = 
 MULTIDIRS = 
@@ -432,6 +438,7 @@ enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
 extra_ldflags_libgfortran = @extra_ldflags_libgfortran@
+gcc_version_alias = @gcc_version_alias@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
@@ -487,11 +494,15 @@ toolexeclib_DATA = libgfortran.spec
 libgfortran_la_LINK = $(LINK) $(libgfortran_la_LDFLAGS)
 libgfortran_la_LDFLAGS = -version-info `grep -v '^\#' $(srcdir)/libtool-version` $(LTLDFLAGS) $(LIBQUADLIB) -lm $(extra_ldflags_libgfortran) $(version_arg)
 libgfortran_la_DEPENDENCIES = $(version_dep) libgfortran.spec $(LIBQUADLIB_DEP)
-myexeclib_LTLIBRARIES = libgfortranbegin.la
-myexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)
-libgfortranbegin_la_SOURCES = fmain.c
-libgfortranbegin_la_LDFLAGS = -static
-libgfortranbegin_la_LINK = $(LINK) $(libgfortranbegin_la_LDFLAGS)
+@DJGPP_FALSE@myexeclib_LTLIBRARIES = libgfortranbegin.la
+@DJGPP_TRUE@myexeclib_LTLIBRARIES = libgf95begin.la
+myexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version_alias)$(MULTISUBDIR)
+@DJGPP_TRUE@libgf95begin_la_SOURCES = fmain.c
+@DJGPP_TRUE@libgf95begin_la_LDFLAGS = -static
+@DJGPP_TRUE@libgf95begin_la_LINK = $(LINK) $(libgf95begin_la_LDFLAGS)
+@DJGPP_FALSE@libgfortranbegin_la_SOURCES = fmain.c
+@DJGPP_FALSE@libgfortranbegin_la_LDFLAGS = -static
+@DJGPP_FALSE@libgfortranbegin_la_LINK = $(LINK) $(libgfortranbegin_la_LDFLAGS)
 AM_CPPFLAGS = -iquote$(srcdir)/io -I$(srcdir)/$(MULTISRCTOP)../gcc \
 	      -I$(srcdir)/$(MULTISRCTOP)../gcc/config $(LIBQUADINCLUDE) \
 	      -I$(MULTIBUILDTOP)../../$(host_subdir)/gcc -D_GNU_SOURCE
@@ -1371,10 +1382,12 @@ clean-toolexeclibLTLIBRARIES:
 	  echo "rm -f \"$${dir}/so_locations\""; \
 	  rm -f "$${dir}/so_locations"; \
 	done
+libgf95begin.la: $(libgf95begin_la_OBJECTS) $(libgf95begin_la_DEPENDENCIES) 
+	$(libgf95begin_la_LINK) $(am_libgf95begin_la_rpath) $(libgf95begin_la_OBJECTS) $(libgf95begin_la_LIBADD) $(LIBS)
 libgfortran.la: $(libgfortran_la_OBJECTS) $(libgfortran_la_DEPENDENCIES) 
 	$(libgfortran_la_LINK) -rpath $(toolexeclibdir) $(libgfortran_la_OBJECTS) $(libgfortran_la_LIBADD) $(LIBS)
 libgfortranbegin.la: $(libgfortranbegin_la_OBJECTS) $(libgfortranbegin_la_DEPENDENCIES) 
-	$(libgfortranbegin_la_LINK) -rpath $(myexeclibdir) $(libgfortranbegin_la_OBJECTS) $(libgfortranbegin_la_LIBADD) $(LIBS)
+	$(libgfortranbegin_la_LINK) $(am_libgfortranbegin_la_rpath) $(libgfortranbegin_la_OBJECTS) $(libgfortranbegin_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
diff --git a/libgfortran/configure b/libgfortran/configure
index 1e61aeb49..76ba97686 100755
--- a/libgfortran/configure
+++ b/libgfortran/configure
@@ -645,6 +645,7 @@ AM_CFLAGS
 AM_FCFLAGS
 toolexeclibdir
 toolexecdir
+gcc_version_alias
 EGREP
 GREP
 CPP
@@ -664,6 +665,8 @@ CPPFLAGS
 LDFLAGS
 CFLAGS
 CC
+DJGPP_FALSE
+DJGPP_TRUE
 multi_basedir
 MAINT
 MAINTAINER_MODE_FALSE
@@ -3382,6 +3385,16 @@ fi
 ac_config_commands="$ac_config_commands default-1"
 
 
+# Add test for DJGPP
+ if echo $build | grep msdosdjgpp; then
+  DJGPP_TRUE=
+  DJGPP_FALSE='#'
+else
+  DJGPP_TRUE='#'
+  DJGPP_FALSE=
+fi
+
+
 # Handy for debugging:
 #AC_MSG_NOTICE($build / $host / $target / $host_alias / $target_alias); sleep 5
 
@@ -4839,6 +4852,19 @@ $as_echo "$ac_cv_safe_to_define___extensions__" >&6; }
 
 
 
+# Convert GCC version string (to be used as directory name)
+# Does nothing except for DJGPP
+case "$build" in
+  *-msdosdjgpp*)
+     gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+     ;;
+  *)
+     gcc_version_alias='$(gcc_version)'
+     ;;
+esac
+
+
+
 # Calculate toolexeclibdir
 # Also toolexecdir, though it's only used in toolexeclibdir
 case ${version_specific_libs} in
@@ -4847,7 +4873,7 @@ case ${version_specific_libs} in
     # and header files if --enable-version-specific-runtime-libs option
     # is selected.
     toolexecdir='$(libdir)/gcc/$(target_alias)'
-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version_alias)$(MULTISUBDIR)'
     ;;
   no)
     if test -n "$with_cross_host" &&
@@ -12112,7 +12138,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 12115 "configure"
+#line 12141 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -12218,7 +12244,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 12221 "configure"
+#line 12247 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -26033,6 +26059,10 @@ if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
   as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${DJGPP_TRUE}" && test -z "${DJGPP_FALSE}"; then
+  as_fn_error "conditional \"DJGPP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
   as_fn_error "conditional \"AMDEP\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
diff --git a/libgfortran/configure.ac b/libgfortran/configure.ac
index 86d716130..e08cf8d75 100644
--- a/libgfortran/configure.ac
+++ b/libgfortran/configure.ac
@@ -69,6 +69,9 @@ AM_INIT_AUTOMAKE([1.9.6 no-define foreign no-dist -Wall -Wno-portability])
 AM_MAINTAINER_MODE
 AM_ENABLE_MULTILIB(, ..)
 
+# Add test for DJGPP
+AM_CONDITIONAL(DJGPP,echo $build | grep msdosdjgpp)
+
 # Handy for debugging:
 #AC_MSG_NOTICE($build / $host / $target / $host_alias / $target_alias); sleep 5
 
@@ -84,6 +87,19 @@ fi
 
 AC_USE_SYSTEM_EXTENSIONS
 
+# Convert GCC version string (to be used as directory name)
+# Does nothing except for DJGPP
+case "$build" in
+  *-msdosdjgpp*)
+     gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+     ;;
+  *)
+     gcc_version_alias='$(gcc_version)'
+     ;; 
+esac
+
+AC_SUBST(gcc_version_alias)
+
 # Calculate toolexeclibdir
 # Also toolexecdir, though it's only used in toolexeclibdir
 case ${version_specific_libs} in
@@ -92,7 +108,7 @@ case ${version_specific_libs} in
     # and header files if --enable-version-specific-runtime-libs option
     # is selected.
     toolexecdir='$(libdir)/gcc/$(target_alias)'
-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version_alias)$(MULTISUBDIR)'
     ;;
   no)
     if test -n "$with_cross_host" &&
diff --git a/libgfortran/io/unix.c b/libgfortran/io/unix.c
index 26bb06a09..a03e6f65c 100644
--- a/libgfortran/io/unix.c
+++ b/libgfortran/io/unix.c
@@ -196,6 +196,9 @@ typedef struct
 }
 unix_stream;
 
+#ifdef __DJGPP__
+#include <io.h>
+#endif
 
 /* fix_fd()-- Given a file descriptor, make sure it is not one of the
  * standard descriptors, returning a non-standard descriptor.  If the
@@ -1045,7 +1048,7 @@ tempfile (st_parameter_open *opp)
   /* Check for special case that tempdir contains slash
      or backslash at end.  */
   if (*tempdir == 0 || tempdir[strlen (tempdir) - 1] == '/'
-#ifdef __MINGW32__
+#if defined(__MINGW32__) || defined(__DJGPP__)
       || tempdir[strlen (tempdir) - 1] == '\\'
 #endif
      )
@@ -1054,7 +1057,12 @@ tempfile (st_parameter_open *opp)
   template = get_mem (strlen (tempdir) + 20);
 
 #ifdef HAVE_MKSTEMP
+#ifdef __DJGPP__
+  /* Default filename is too long for DOS */
+  sprintf (template, "%s%sgfXXXXXX", tempdir, slash);
+#else
   sprintf (template, "%s%sgfortrantmpXXXXXX", tempdir, slash);
+#endif
 
   fd = mkstemp (template);
 
@@ -1262,6 +1270,13 @@ open_external (st_parameter_open *opp, unit_flags *flags)
     return NULL;
   fd = fix_fd (fd);
 
+#ifdef __DJGPP__
+  if (flags->form == FORM_UNFORMATTED)
+    {
+      setmode (fd, O_BINARY);
+    }
+#endif
+
   return fd_to_stream (fd);
 }
 
diff --git a/libiberty/config/mh-djgpp b/libiberty/config/mh-djgpp
new file mode 100644
index 000000000..829a268b6
--- /dev/null
+++ b/libiberty/config/mh-djgpp
@@ -0,0 +1,3 @@
+EXTRA_OFILES=asprintf.o mempcpy.o mkstemps.o sigsetmask.o strndup.o strverscmp.o vasprintf.o
+# Only DJGPP v2.04pre have snprinf() and vsnprintf(). Therefore take also them
+EXTRA_OFILES+=snprintf.o vsnprintf.o
diff --git a/libiberty/configure b/libiberty/configure
index bdabe8d1a..f4aac230e 100755
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -4834,6 +4834,7 @@ case "${host}" in
   *-*-freebsd2.2.[012])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[34567]86-*-windows*)	frag=mh-windows ;;
+  i[34567]86-*-msdosdjgpp)	frag=mh-djgpp ;;
 esac
 
 if [ -n "${frag}" ]; then
diff --git a/libiberty/configure.ac b/libiberty/configure.ac
index 9f1ff0493..fea57f423 100644
--- a/libiberty/configure.ac
+++ b/libiberty/configure.ac
@@ -185,6 +185,7 @@ case "${host}" in
   *-*-freebsd2.2.[[012]])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[[34567]]86-*-windows*)	frag=mh-windows ;;
+  i[[34567]]86-*-msdosdjgpp)	frag=mh-djgpp ;;
 esac
 
 if [[ -n "${frag}" ]]; then
diff --git a/libiberty/make-relative-prefix.c b/libiberty/make-relative-prefix.c
index 897ac5129..85dd7d0ef 100644
--- a/libiberty/make-relative-prefix.c
+++ b/libiberty/make-relative-prefix.c
@@ -82,6 +82,7 @@ relative prefix can be found, return @code{NULL}.
 #  define HAVE_DOS_BASED_FILE_SYSTEM
 #  define HAVE_HOST_EXECUTABLE_SUFFIX
 #  define HOST_EXECUTABLE_SUFFIX ".exe"
+#  define FILENAME_COMPARE strcasecmp
 #  ifndef DIR_SEPARATOR_2 
 #    define DIR_SEPARATOR_2 '\\'
 #  endif
@@ -97,6 +98,10 @@ relative prefix can be found, return @code{NULL}.
 	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
 #endif
 
+#ifndef FILENAME_COMPARE
+#  define FILENAME_COMPARE strcmp
+#endif
+
 #define DIR_UP ".."
 
 static char *save_string (const char *, int);
@@ -334,7 +339,7 @@ make_relative_prefix_1 (const char *progname, const char *bin_prefix,
     {
       for (i = 0; i < bin_num; i++)
 	{
-	  if (strcmp (prog_dirs[i], bin_dirs[i]) != 0)
+	  if (FILENAME_COMPARE (prog_dirs[i], bin_dirs[i]) != 0)
 	    break;
 	}
 
@@ -350,7 +355,7 @@ make_relative_prefix_1 (const char *progname, const char *bin_prefix,
   n = (prefix_num < bin_num) ? prefix_num : bin_num;
   for (common = 0; common < n; common++)
     {
-      if (strcmp (bin_dirs[common], prefix_dirs[common]) != 0)
+      if (FILENAME_COMPARE (bin_dirs[common], prefix_dirs[common]) != 0)
 	break;
     }
 
diff --git a/libiberty/make-temp-file.c b/libiberty/make-temp-file.c
index 7b74f8179..9272dccda 100644
--- a/libiberty/make-temp-file.c
+++ b/libiberty/make-temp-file.c
@@ -55,6 +55,29 @@ extern int mkstemps (char *, int);
 #define DIR_SEPARATOR '/'
 #endif
 
+#if defined (_WIN32) || defined (__MSDOS__) \
+    || defined (__DJGPP__) || defined (__OS2__)
+#  define HAVE_DOS_BASED_FILE_SYSTEM
+#  ifndef DIR_SEPARATOR_2 
+#    define DIR_SEPARATOR_2 '\\'
+#  endif
+#endif
+
+/* Define IS_DIR_SEPARATOR. VMS uses '::', ':', '[...]' and '<...>' to
+   separate the different components of a file specification.  It's a
+   bit of a stretch to call ':', ']' and '>' directory separators, so
+   just define the test to find the file name component.  */
+#ifdef VMS
+#  define IS_DIR_SEPARATOR(ch) ((ch) == ':' || (ch) == ']' || (ch) == '>')
+#else
+#  ifndef DIR_SEPARATOR_2
+#    define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
+#  else
+#    define IS_DIR_SEPARATOR(ch) \
+	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
+#  endif
+#endif
+
 /* Name of temporary file.
    mktemp requires 6 trailing X's.  */
 #define TEMP_FILE "ccXXXXXX"
@@ -143,7 +166,8 @@ choose_tmpdir (void)
       len = strlen (base);
       tmpdir = XNEWVEC (char, len + 2);
       strcpy (tmpdir, base);
-      tmpdir[len] = DIR_SEPARATOR;
+      if (len>0 && !IS_DIR_SEPARATOR(tmpdir[len-1]))   
+          tmpdir[len] = DIR_SEPARATOR;
       tmpdir[len+1] = '\0';
       memoized_tmpdir = tmpdir;
 #else /* defined(_WIN32) && !defined(__CYGWIN__) */
diff --git a/libobjc/Makefile.in b/libobjc/Makefile.in
index b33c989e6..0cd337fb9 100644
--- a/libobjc/Makefile.in
+++ b/libobjc/Makefile.in
@@ -39,6 +39,8 @@ multi_basedir = @multi_basedir@
 toolexecdir = @toolexecdir@
 # Toolexecdir is used only by toolexeclibdir
 toolexeclibdir = @toolexeclibdir@
+# Editted (if neccessary) GCC version string
+gcc_version_dir = @gcc_version_dir@
 
 includedirname = @includedirname@
 libsuffix = @libsuffix@
@@ -51,7 +53,7 @@ top_builddir = .
 -include ../boehm-gc/threads.mk
 
 libdir = $(exec_prefix)/lib
-libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)
+libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version_dir)
 
 # Multilib support variables.
 MULTISRCTOP =
diff --git a/libobjc/configure b/libobjc/configure
index e6f0afdfa..f260dde15 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -600,6 +600,7 @@ ac_includes_default="\
 
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+gcc_version_dir
 SET_MAKE
 CPP
 OTOOL64
@@ -10583,7 +10584,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10586 "configure"
+#line 10587 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10689,7 +10690,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10692 "configure"
+#line 10693 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11472,7 +11473,7 @@ if test "${enable_sjlj_exceptions+set}" = set; then :
   enableval=$enable_sjlj_exceptions; :
 else
   cat > conftest.$ac_ext << EOF
-#line 11475 "configure"
+#line 11476 "configure"
 @interface Frob
 @end
 @implementation Frob
@@ -11524,6 +11525,19 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_exception_model_name" >&5
 $as_echo "$ac_exception_model_name" >&6; }
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+case $build in
+	i?86-*-msdosdjgpp*)
+		gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+		;;
+
+	* )
+		gcc_version_dir='$(gcc_version)'
+		;;
+esac
+
+
 # ------
 # Output
 # ------
diff --git a/libobjc/configure.ac b/libobjc/configure.ac
index 494a289ec..566fc3208 100644
--- a/libobjc/configure.ac
+++ b/libobjc/configure.ac
@@ -273,6 +273,19 @@ fi
 AC_LANG_POP(C)
 AC_MSG_RESULT($ac_exception_model_name)
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+[case $build in
+	i?86-*-msdosdjgpp*)
+		gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+		;;
+
+	* )
+		gcc_version_dir='$(gcc_version)'
+		;;
+esac]
+AC_SUBST(gcc_version_dir)
+
 # ------
 # Output
 # ------
diff --git a/libquadmath/Makefile.am b/libquadmath/Makefile.am
index c7be3e554..a1a4dbad9 100644
--- a/libquadmath/Makefile.am
+++ b/libquadmath/Makefile.am
@@ -40,7 +40,7 @@ libquadmath_la_LDFLAGS = -version-info `grep -v '^\#' $(srcdir)/libtool-version`
 libquadmath_la_DEPENDENCIES = $(version_dep) $(libquadmath_la_LIBADD)
 
 nodist_libsubinclude_HEADERS = quadmath.h quadmath_weak.h
-libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include
+libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version_alias)/include
 
 libquadmath_la_SOURCES = \
   math/acoshq.c math/fmodq.c math/acosq.c math/frexpq.c \
diff --git a/libquadmath/Makefile.in b/libquadmath/Makefile.in
index 6e389cf6a..f1712df7e 100644
--- a/libquadmath/Makefile.in
+++ b/libquadmath/Makefile.in
@@ -266,6 +266,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
@@ -319,7 +320,7 @@ AUTOMAKE_OPTIONS = 1.8 foreign
 
 @BUILD_LIBQUADMATH_TRUE@libquadmath_la_DEPENDENCIES = $(version_dep) $(libquadmath_la_LIBADD)
 @BUILD_LIBQUADMATH_TRUE@nodist_libsubinclude_HEADERS = quadmath.h quadmath_weak.h
-@BUILD_LIBQUADMATH_TRUE@libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include
+@BUILD_LIBQUADMATH_TRUE@libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version_alias)/include
 @BUILD_LIBQUADMATH_TRUE@libquadmath_la_SOURCES = \
 @BUILD_LIBQUADMATH_TRUE@  math/acoshq.c math/fmodq.c math/acosq.c math/frexpq.c \
 @BUILD_LIBQUADMATH_TRUE@  math/rem_pio2q.c math/asinhq.c math/hypotq.c math/remainderq.c \
diff --git a/libquadmath/configure b/libquadmath/configure
index 9d979337d..3d8099c48 100755
--- a/libquadmath/configure
+++ b/libquadmath/configure
@@ -613,6 +613,7 @@ LIBQUAD_USE_SYMVER_FALSE
 LIBQUAD_USE_SYMVER_TRUE
 toolexeclibdir
 toolexecdir
+gcc_version_alias
 multi_basedir
 MAINT
 MAINTAINER_MODE_FALSE
@@ -10513,7 +10514,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10516 "configure"
+#line 10517 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10619,7 +10620,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10622 "configure"
+#line 10623 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11894,6 +11895,19 @@ ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
+# Convert GCC version string (to be used as directory name)
+# Does nothing except for DJGPP
+case "$build" in
+  *-msdosdjgpp*)
+     gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+     ;;
+  *)
+     gcc_version_alias='$(gcc_version)'
+     ;;
+esac
+
+
+
 # Calculate toolexeclibdir
 # Also toolexecdir, though it's only used in toolexeclibdir
 case ${version_specific_libs} in
@@ -11902,7 +11916,7 @@ case ${version_specific_libs} in
     # and header files if --enable-version-specific-runtime-libs option
     # is selected.
     toolexecdir='$(libdir)/gcc/$(target_alias)'
-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version_alias)$(MULTISUBDIR)'
     ;;
   no)
     if test -n "$with_cross_host" &&
diff --git a/libquadmath/configure.ac b/libquadmath/configure.ac
index 512b9f813..bf85fd57a 100644
--- a/libquadmath/configure.ac
+++ b/libquadmath/configure.ac
@@ -82,6 +82,19 @@ if test "x$GCC" != "xyes"; then
 fi
 AC_PROG_CPP
 
+# Convert GCC version string (to be used as directory name)
+# Does nothing except for DJGPP
+case "$build" in
+  *-msdosdjgpp*)
+     gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+     ;;
+  *)
+     gcc_version_alias='$(gcc_version)'
+     ;; 
+esac
+
+AC_SUBST(gcc_version_alias)
+
 # Calculate toolexeclibdir
 # Also toolexecdir, though it's only used in toolexeclibdir
 case ${version_specific_libs} in
@@ -90,7 +103,7 @@ case ${version_specific_libs} in
     # and header files if --enable-version-specific-runtime-libs option
     # is selected.
     toolexecdir='$(libdir)/gcc/$(target_alias)'
-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version_alias)$(MULTISUBDIR)'
     ;;
   no)
     if test -n "$with_cross_host" &&
diff --git a/libquadmath/printf/printf_fphex.c b/libquadmath/printf/printf_fphex.c
index 941e93307..db7230856 100644
--- a/libquadmath/printf/printf_fphex.c
+++ b/libquadmath/printf/printf_fphex.c
@@ -29,6 +29,11 @@
 #include "_itoa.h"
 #include "_itowa.h"
 
+#if defined(__DJGPP__) && __DJGPP__==2 && __DJGPP_MINOR__<4
+/* Have to somehow pull in ssize_t from sys/djtypes.h */
+#include <unistd.h>
+#endif
+
 
 /* Macros for doing the actual output.  */
 
diff --git a/libquadmath/printf/quadmath-printf.c b/libquadmath/printf/quadmath-printf.c
index b70f432cc..f0ddd91f0 100644
--- a/libquadmath/printf/quadmath-printf.c
+++ b/libquadmath/printf/quadmath-printf.c
@@ -24,6 +24,11 @@ Boston, MA 02110-1301, USA.  */
 #include <stdio.h>
 #include "quadmath-printf.h"
 
+#if defined(__DJGPP__) && __DJGPP__==2 && __DJGPP_MINOR__<4
+/* Have to somehow pull in ssize_t from sys/djtypes.h */
+#include <unistd.h>
+#endif
+
 /* Read a simple integer from a string and update the string pointer.
    It is assumed that the first character is a digit.  */
 static unsigned int
diff --git a/libquadmath/printf/quadmath-printf.h b/libquadmath/printf/quadmath-printf.h
index 32ebcec92..96498b7c4 100644
--- a/libquadmath/printf/quadmath-printf.h
+++ b/libquadmath/printf/quadmath-printf.h
@@ -29,7 +29,8 @@ Boston, MA 02110-1301, USA.  */
 #ifdef HAVE_CTYPE_H
 #include <ctype.h>
 #endif
-#ifdef HAVE_WCHAR_H
+#if defined(HAVE_WCHAR_H) && !defined(__DJGPP__)
+/* DJGPP wchar.h is not good enough */
 #include <wchar.h>
 #endif
 #ifdef HAVE_WCTYPE_H
@@ -44,7 +45,7 @@ Boston, MA 02110-1301, USA.  */
 #include "quadmath-imp.h"
 #include "gmp-impl.h"
 
-#ifdef HAVE_WCHAR_H
+#if defined(HAVE_WCHAR_H) && !defined(__DJGPP__)
 #define L_(x) L##x
 #else
 #define L_(x) x
diff --git a/libssp/Makefile.am b/libssp/Makefile.am
index 5a2ecac1f..3a5c240f0 100644
--- a/libssp/Makefile.am
+++ b/libssp/Makefile.am
@@ -39,7 +39,7 @@ AM_CFLAGS = -Wall
 toolexeclib_LTLIBRARIES = libssp.la libssp_nonshared.la
 
 target_noncanonical = @target_noncanonical@
-libsubincludedir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include
+libsubincludedir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version_dir)/include
 nobase_libsubinclude_HEADERS = ssp/ssp.h ssp/string.h ssp/stdio.h ssp/unistd.h
 
 libssp_la_SOURCES = \
diff --git a/libssp/Makefile.in b/libssp/Makefile.in
index a7db7a9c0..58551a20b 100644
--- a/libssp/Makefile.in
+++ b/libssp/Makefile.in
@@ -207,6 +207,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_dir = @gcc_version_dir@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
@@ -259,7 +260,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
 @LIBSSP_USE_SYMVER_SUN_TRUE@@LIBSSP_USE_SYMVER_TRUE@version_dep = ssp.map-sun
 AM_CFLAGS = -Wall
 toolexeclib_LTLIBRARIES = libssp.la libssp_nonshared.la
-libsubincludedir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include
+libsubincludedir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version_dir)/include
 nobase_libsubinclude_HEADERS = ssp/ssp.h ssp/string.h ssp/stdio.h ssp/unistd.h
 libssp_la_SOURCES = \
 	ssp.c gets-chk.c memcpy-chk.c memmove-chk.c mempcpy-chk.c \
diff --git a/libssp/configure b/libssp/configure
index bd3f5662c..6c5284614 100755
--- a/libssp/configure
+++ b/libssp/configure
@@ -602,6 +602,7 @@ ac_subst_vars='am__EXEEXT_FALSE
 am__EXEEXT_TRUE
 LTLIBOBJS
 LIBOBJS
+gcc_version_dir
 toolexeclibdir
 toolexecdir
 enable_static
@@ -10650,7 +10651,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10653 "configure"
+#line 10654 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10756,7 +10757,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10759 "configure"
+#line 10760 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11054,6 +11055,19 @@ else
   multilib_arg=
 fi
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+case $build in
+       i?86-*-msdosdjgpp*)
+               gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+               ;;
+
+       * )
+               gcc_version_dir='$(gcc_version)'
+               ;;
+esac
+
+
 ac_config_files="$ac_config_files Makefile ssp/ssp.h"
 
 cat >confcache <<\_ACEOF
diff --git a/libssp/configure.ac b/libssp/configure.ac
index 0eee36ce0..8194da3de 100644
--- a/libssp/configure.ac
+++ b/libssp/configure.ac
@@ -195,5 +195,18 @@ else
   multilib_arg=
 fi
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+[case $build in
+       i?86-*-msdosdjgpp*)
+               gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+               ;;
+
+       * )
+               gcc_version_dir='$(gcc_version)'
+               ;;
+esac]
+AC_SUBST(gcc_version_dir)
+
 AC_CONFIG_FILES([Makefile ssp/ssp.h])
 AC_OUTPUT
diff --git a/libstdc++-v3/Makefile.in b/libstdc++-v3/Makefile.in
index af62df5a6..207b14112 100644
--- a/libstdc++-v3/Makefile.in
+++ b/libstdc++-v3/Makefile.in
@@ -231,6 +231,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -253,6 +254,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index 788966c66..fb0669de4 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -755,9 +755,22 @@ AC_DEFUN([GLIBCXX_EXPORT_INSTALL_INFO], [
     [version_specific_libs=no])
   AC_MSG_RESULT($version_specific_libs)
 
+  # Convert GCC version string (to be used as directory name)
+  # Does nothing except for DJGPP
+  case "$build" in
+    *-msdosdjgpp*)
+       libstdcxx_incdir_base=cxx
+       gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+       ;;
+    *)
+       libstdcxx_incdir_base=c++
+       gcc_version_alias='$(gcc_version)'
+       ;; 
+  esac
+
   # Default case for install directory for include files.
   if test $version_specific_libs = no && test $gxx_include_dir = no; then
-    gxx_include_dir='include/c++/${gcc_version}'
+    gxx_include_dir='include/$(libstdcxx_incdir_base)/${gcc_version_alias}'
     if test -n "$with_cross_host" &&
        test x"$with_cross_host" != x"no"; then
       gxx_include_dir='${prefix}/${target_alias}/'"$gxx_include_dir"
@@ -773,10 +786,10 @@ AC_DEFUN([GLIBCXX_EXPORT_INSTALL_INFO], [
     # is selected.  FIXME: these variables are misnamed, there are
     # no executables installed in _toolexecdir or _toolexeclibdir.
     if test x"$gxx_include_dir" = x"no"; then
-      gxx_include_dir='${libdir}/gcc/${host_alias}/${gcc_version}/include/c++'
+      gxx_include_dir='${libdir}/gcc/${host_alias}/${gcc_version_alias}/include/${libstdcxx_incdir_base}'
     fi
     glibcxx_toolexecdir='${libdir}/gcc/${host_alias}'
-    glibcxx_toolexeclibdir='${toolexecdir}/${gcc_version}$(MULTISUBDIR)'
+    glibcxx_toolexeclibdir='${toolexecdir}/${gcc_version_alias}$(MULTISUBDIR)'
   fi
 
   # Calculate glibcxx_toolexecdir, glibcxx_toolexeclibdir
@@ -804,6 +817,8 @@ AC_DEFUN([GLIBCXX_EXPORT_INSTALL_INFO], [
   AC_SUBST(gxx_include_dir)
   AC_SUBST(glibcxx_toolexecdir)
   AC_SUBST(glibcxx_toolexeclibdir)
+  AC_SUBST(libstdcxx_incdir_base)
+  AC_SUBST(gcc_version_alias)
 ])
 
 
diff --git a/libstdc++-v3/config/os/djgpp/error_constants.h b/libstdc++-v3/config/os/djgpp/error_constants.h
index 4e87208d8..22716cfb1 100644
--- a/libstdc++-v3/config/os/djgpp/error_constants.h
+++ b/libstdc++-v3/config/os/djgpp/error_constants.h
@@ -66,7 +66,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       function_not_supported = 			ENOSYS,
 //    host_unreachable = 			EHOSTUNREACH,
 //    identifier_removed = 			EIDRM,
+#ifdef EILSEQ
       illegal_byte_sequence = 			EILSEQ,
+#endif
       inappropriate_io_control_operation = 	ENOTTY,
       interrupted = 				EINTR,
       invalid_argument = 			EINVAL,
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 84b6ea94a..0cc16bfc4 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -607,6 +607,8 @@ WARN_FLAGS
 OPTIMIZE_CXXFLAGS
 TOPLEVEL_INCLUDES
 GLIBCXX_INCLUDES
+gcc_version_alias
+libstdcxx_incdir_base
 glibcxx_toolexeclibdir
 glibcxx_toolexecdir
 gxx_include_dir
@@ -742,6 +744,8 @@ LN_S
 toplevel_srcdir
 glibcxx_srcdir
 glibcxx_builddir
+DJGPP_FALSE
+DJGPP_TRUE
 ac_ct_CXX
 CXXFLAGS
 CXX
@@ -4583,6 +4587,16 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 CXXFLAGS="$save_CXXFLAGS"
 
+# Add test for DJGPP environment
+ if echo $build | grep msdosdjgpp; then
+  DJGPP_TRUE=
+  DJGPP_FALSE='#'
+else
+  DJGPP_TRUE='#'
+  DJGPP_FALSE=
+fi
+
+
 # Runs configure.host, and assorted other critical bits.  Sets
 # up critical shell variables.
 
@@ -11484,7 +11498,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11487 "configure"
+#line 11501 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11590,7 +11604,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11593 "configure"
+#line 11607 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -14948,7 +14962,7 @@ fi
     #
     # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.
     cat > conftest.$ac_ext << EOF
-#line 14951 "configure"
+#line 14965 "configure"
 struct S { ~S(); };
 void bar();
 void foo()
@@ -15316,7 +15330,7 @@ $as_echo "$glibcxx_cv_atomic_long_long" >&6; }
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15319 "configure"
+#line 15333 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15353,7 +15367,7 @@ $as_echo "$glibcxx_cv_atomic_bool" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15356 "configure"
+#line 15370 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15390,7 +15404,7 @@ $as_echo "$glibcxx_cv_atomic_short" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15393 "configure"
+#line 15407 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15428,7 +15442,7 @@ $as_echo "$glibcxx_cv_atomic_int" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15431 "configure"
+#line 15445 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15504,7 +15518,7 @@ $as_echo "$as_me: WARNING: Performance of certain classes will degrade as a resu
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15507 "configure"
+#line 15521 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -65687,9 +65701,22 @@ fi
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $version_specific_libs" >&5
 $as_echo "$version_specific_libs" >&6; }
 
+  # Convert GCC version string (to be used as directory name)
+  # Does nothing except for DJGPP
+  case "$build" in
+    *-msdosdjgpp*)
+       libstdcxx_incdir_base=cxx
+       gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+       ;;
+    *)
+       libstdcxx_incdir_base=c++
+       gcc_version_alias='$(gcc_version)'
+       ;;
+  esac
+
   # Default case for install directory for include files.
   if test $version_specific_libs = no && test $gxx_include_dir = no; then
-    gxx_include_dir='include/c++/${gcc_version}'
+    gxx_include_dir='include/$(libstdcxx_incdir_base)/${gcc_version_alias}'
     if test -n "$with_cross_host" &&
        test x"$with_cross_host" != x"no"; then
       gxx_include_dir='${prefix}/${target_alias}/'"$gxx_include_dir"
@@ -65705,10 +65732,10 @@ $as_echo "$version_specific_libs" >&6; }
     # is selected.  FIXME: these variables are misnamed, there are
     # no executables installed in _toolexecdir or _toolexeclibdir.
     if test x"$gxx_include_dir" = x"no"; then
-      gxx_include_dir='${libdir}/gcc/${host_alias}/${gcc_version}/include/c++'
+      gxx_include_dir='${libdir}/gcc/${host_alias}/${gcc_version_alias}/include/${libstdcxx_incdir_base}'
     fi
     glibcxx_toolexecdir='${libdir}/gcc/${host_alias}'
-    glibcxx_toolexeclibdir='${toolexecdir}/${gcc_version}$(MULTISUBDIR)'
+    glibcxx_toolexeclibdir='${toolexecdir}/${gcc_version_alias}$(MULTISUBDIR)'
   fi
 
   # Calculate glibcxx_toolexecdir, glibcxx_toolexeclibdir
@@ -65740,6 +65767,8 @@ $as_echo "$gxx_include_dir" >&6; }
 
 
 
+
+
 # Export all the include and flag information to Makefiles.
 
   # Used for every C++ compile we perform.
@@ -65906,6 +65935,10 @@ else
   am__EXEEXT_FALSE=
 fi
 
+if test -z "${DJGPP_TRUE}" && test -z "${DJGPP_FALSE}"; then
+  as_fn_error "conditional \"DJGPP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
   as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
index 427cf0b88..c499de897 100644
--- a/libstdc++-v3/configure.ac
+++ b/libstdc++-v3/configure.ac
@@ -84,6 +84,9 @@ AC_PROG_CC
 AC_PROG_CXX
 CXXFLAGS="$save_CXXFLAGS"
 
+# Add test for DJGPP environment
+AM_CONDITIONAL(DJGPP,echo $build | grep msdosdjgpp)
+
 # Runs configure.host, and assorted other critical bits.  Sets
 # up critical shell variables.
 GLIBCXX_CONFIGURE
diff --git a/libstdc++-v3/doc/Makefile.in b/libstdc++-v3/doc/Makefile.in
index e17773370..125f5a3b0 100644
--- a/libstdc++-v3/doc/Makefile.in
+++ b/libstdc++-v3/doc/Makefile.in
@@ -207,6 +207,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -233,6 +234,7 @@ infodir = "$(DESTDIR)@infodir@"
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
index 3f1abd3e1..cd56d0b6a 100644
--- a/libstdc++-v3/include/Makefile.in
+++ b/libstdc++-v3/include/Makefile.in
@@ -205,6 +205,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -227,6 +228,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/libsupc++/Makefile.in b/libstdc++-v3/libsupc++/Makefile.in
index 18ba84018..6342aadda 100644
--- a/libstdc++-v3/libsupc++/Makefile.in
+++ b/libstdc++-v3/libsupc++/Makefile.in
@@ -264,6 +264,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -286,6 +287,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/po/Makefile.in b/libstdc++-v3/po/Makefile.in
index f552c6bf9..01ed0738f 100644
--- a/libstdc++-v3/po/Makefile.in
+++ b/libstdc++-v3/po/Makefile.in
@@ -205,6 +205,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -227,6 +228,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/python/Makefile.am b/libstdc++-v3/python/Makefile.am
index b603444ad..85dab6e33 100644
--- a/libstdc++-v3/python/Makefile.am
+++ b/libstdc++-v3/python/Makefile.am
@@ -23,7 +23,7 @@
 include $(top_srcdir)/fragment.am
 
 ## Where to install the module code.
-pythondir = $(datadir)/gcc-$(gcc_version)/python
+pythondir = $(datadir)/gcc-$(gcc_version_alias)/python
 
 all-local: gdb.py
 
@@ -32,6 +32,12 @@ nobase_python_DATA = \
     libstdcxx/v6/__init__.py \
     libstdcxx/__init__.py
 
+if DJGPP
+name_base=libstdcxx
+else
+name_base=libstdc++
+endif
+
 gdb.py: hook.in Makefile
 	sed -e 's,@pythondir@,$(pythondir),' \
 	    -e 's,@toolexeclibdir@,$(toolexeclibdir),' < $(srcdir)/hook.in > $@
@@ -44,7 +50,7 @@ install-data-local: gdb.py
 ## fragile, but there does not seem to be a better option, because
 ## libtool hides the real names from us.
 	@here=`pwd`; cd $(DESTDIR)$(toolexeclibdir); \
-	  for file in libstdc++*; do \
+	  for file in $(name_base)*; do \
 	    case $$file in \
 	      *-gdb.py) ;; \
 	      *.la) ;; \
diff --git a/libstdc++-v3/python/Makefile.in b/libstdc++-v3/python/Makefile.in
index b8ea31a8e..b25408015 100644
--- a/libstdc++-v3/python/Makefile.in
+++ b/libstdc++-v3/python/Makefile.in
@@ -229,6 +229,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -251,6 +252,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
@@ -298,12 +300,14 @@ WARN_CXXFLAGS = \
 
 # -I/-D flags to pass when compiling.
 AM_CPPFLAGS = $(GLIBCXX_INCLUDES)
-pythondir = $(datadir)/gcc-$(gcc_version)/python
+pythondir = $(datadir)/gcc-$(gcc_version_alias)/python
 nobase_python_DATA = \
     libstdcxx/v6/printers.py \
     libstdcxx/v6/__init__.py \
     libstdcxx/__init__.py
 
+@DJGPP_FALSE@name_base = libstdc++
+@DJGPP_TRUE@name_base = libstdcxx
 all: all-am
 
 .SUFFIXES:
@@ -495,7 +499,7 @@ gdb.py: hook.in Makefile
 install-data-local: gdb.py
 	@$(mkdir_p) $(DESTDIR)$(toolexeclibdir)
 	@here=`pwd`; cd $(DESTDIR)$(toolexeclibdir); \
-	  for file in libstdc++*; do \
+	  for file in $(name_base)*; do \
 	    case $$file in \
 	      *-gdb.py) ;; \
 	      *.la) ;; \
diff --git a/libstdc++-v3/scripts/create_testsuite_files b/libstdc++-v3/scripts/create_testsuite_files
index f4a0bcd80..de1cf9e42 100755
--- a/libstdc++-v3/scripts/create_testsuite_files
+++ b/libstdc++-v3/scripts/create_testsuite_files
@@ -33,8 +33,21 @@ cd $srcdir
 # what has to happen when find(1) doesn't support -mindepth, or -xtype.
 dlist=`echo [0-9][0-9]*`
 dlist="$dlist abi backward ext performance tr1 decimal"
-find $dlist "(" -type f -o -type l ")" -name "*.cc" -print > $tmp.01
-find $dlist "(" -type f -o -type l ")" -name "*.c" -print > $tmp.02
+
+#find $dlist "(" -type f -o -type l ")" -name "*.cc" -print > $tmp.01
+#find $dlist "(" -type f -o -type l ")" -name "*.c" -print > $tmp.02
+
+case $OSTYPE in
+  msdos*)
+     find $dlist "(" -type f ")" -name "*.cc" -print > $tmp.01
+     find $dlist "(" -type f ")" -name "*.c" -print > $tmp.02
+     ;;
+  *)
+     find $dlist "(" -type f -o -type l ")" -name "*.cc" -print > $tmp.01
+     find $dlist "(" -type f -o -type l ")" -name "*.c" -print > $tmp.02
+     ;;
+esac
+
 cat  $tmp.01 $tmp.02 | sort > $tmp.1
 if test ! -s "$tmp.1"; then
   exit 1
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index 9a3568551..b297ec45c 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -25,7 +25,11 @@
 include $(top_srcdir)/fragment.am
 
 # Cross compiler support.
+if DJGPP
+toolexeclib_LTLIBRARIES = libstdcxx.la
+else
 toolexeclib_LTLIBRARIES = libstdc++.la
+endif
 
 # Symbol versioning for shared libraries.
 if ENABLE_SYMVERS
@@ -240,12 +244,32 @@ sources = \
 vpath % $(top_srcdir)/src
 vpath % $(top_srcdir)
 
+if DJGPP
+libstdcxx_la_SOURCES = $(sources)
+else
 libstdc___la_SOURCES = $(sources)
+endif
 
+if DJGPP
+libstdcxx_la_LIBADD = \
+	$(GLIBCXX_LIBS) \
+	$(top_builddir)/libsupc++/libsupc++convenience.la
+else
 libstdc___la_LIBADD = \
 	$(GLIBCXX_LIBS) \
 	$(top_builddir)/libsupc++/libsupc++convenience.la
+endif
 
+if DJGPP
+libstdcxx_la_DEPENDENCIES = \
+	${version_dep} \
+	$(top_builddir)/libsupc++/libsupc++convenience.la
+
+libstdcxx_la_LDFLAGS = \
+	-version-info $(libtool_VERSION) ${version_arg} -lm
+
+libstdcxx_la_LINK = $(CXXLINK) $(libstdcxx_la_LDFLAGS)
+else
 libstdc___la_DEPENDENCIES = \
 	${version_dep} \
 	$(top_builddir)/libsupc++/libsupc++convenience.la
@@ -254,6 +278,7 @@ libstdc___la_LDFLAGS = \
 	-version-info $(libtool_VERSION) ${version_arg} -lm
 
 libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)
+endif
 
 # Use special rules for the deprecated source files so that they find
 # deprecated include files.
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index b454f66dc..e156caacd 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -119,15 +119,19 @@ am__objects_6 = atomic.lo bitmap_allocator.lo pool_allocator.lo \
 	placeholders.lo regex.lo shared_ptr.lo streambuf.lo mutex.lo \
 	condition_variable.lo chrono.lo thread.lo future.lo \
 	valarray.lo $(am__objects_1) $(am__objects_5)
-am_libstdc___la_OBJECTS = $(am__objects_6)
+@DJGPP_FALSE@am_libstdc___la_OBJECTS = $(am__objects_6)
 libstdc___la_OBJECTS = $(am_libstdc___la_OBJECTS)
+@DJGPP_FALSE@am_libstdc___la_rpath = -rpath $(toolexeclibdir)
+@DJGPP_TRUE@am_libstdcxx_la_OBJECTS = $(am__objects_6)
+libstdcxx_la_OBJECTS = $(am_libstdcxx_la_OBJECTS)
+@DJGPP_TRUE@am_libstdcxx_la_rpath = -rpath $(toolexeclibdir)
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
 am__depfiles_maybe =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 CXXLD = $(CXX)
-SOURCES = $(libstdc___la_SOURCES)
+SOURCES = $(libstdc___la_SOURCES) $(libstdcxx_la_SOURCES)
 ETAGS = etags
 CTAGS = ctags
 ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
@@ -269,6 +273,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -291,6 +296,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
@@ -338,9 +344,10 @@ WARN_CXXFLAGS = \
 
 # -I/-D flags to pass when compiling.
 AM_CPPFLAGS = $(GLIBCXX_INCLUDES)
+@DJGPP_FALSE@toolexeclib_LTLIBRARIES = libstdc++.la
 
 # Cross compiler support.
-toolexeclib_LTLIBRARIES = libstdc++.la
+@DJGPP_TRUE@toolexeclib_LTLIBRARIES = libstdcxx.la
 @ENABLE_SYMVERS_TRUE@CLEANFILES = libstdc++-symbols.ver $(version_dep)
 @ENABLE_SYMVERS_DARWIN_TRUE@@ENABLE_SYMVERS_TRUE@version_arg = -Wl,-exported_symbols_list,libstdc++-symbols.explist
 @ENABLE_SYMVERS_FALSE@version_arg = 
@@ -456,19 +463,32 @@ sources = \
 	${host_sources} \
 	${host_sources_extra}
 
-libstdc___la_SOURCES = $(sources)
-libstdc___la_LIBADD = \
-	$(GLIBCXX_LIBS) \
-	$(top_builddir)/libsupc++/libsupc++convenience.la
+@DJGPP_TRUE@libstdcxx_la_SOURCES = $(sources)
+@DJGPP_FALSE@libstdc___la_SOURCES = $(sources)
+@DJGPP_TRUE@libstdcxx_la_LIBADD = \
+@DJGPP_TRUE@	$(GLIBCXX_LIBS) \
+@DJGPP_TRUE@	$(top_builddir)/libsupc++/libsupc++convenience.la
 
-libstdc___la_DEPENDENCIES = \
-	${version_dep} \
-	$(top_builddir)/libsupc++/libsupc++convenience.la
+@DJGPP_FALSE@libstdc___la_LIBADD = \
+@DJGPP_FALSE@	$(GLIBCXX_LIBS) \
+@DJGPP_FALSE@	$(top_builddir)/libsupc++/libsupc++convenience.la
 
-libstdc___la_LDFLAGS = \
-	-version-info $(libtool_VERSION) ${version_arg} -lm
+@DJGPP_TRUE@libstdcxx_la_DEPENDENCIES = \
+@DJGPP_TRUE@	${version_dep} \
+@DJGPP_TRUE@	$(top_builddir)/libsupc++/libsupc++convenience.la
 
-libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)
+@DJGPP_TRUE@libstdcxx_la_LDFLAGS = \
+@DJGPP_TRUE@	-version-info $(libtool_VERSION) ${version_arg} -lm
+
+@DJGPP_TRUE@libstdcxx_la_LINK = $(CXXLINK) $(libstdcxx_la_LDFLAGS)
+@DJGPP_FALSE@libstdc___la_DEPENDENCIES = \
+@DJGPP_FALSE@	${version_dep} \
+@DJGPP_FALSE@	$(top_builddir)/libsupc++/libsupc++convenience.la
+
+@DJGPP_FALSE@libstdc___la_LDFLAGS = \
+@DJGPP_FALSE@	-version-info $(libtool_VERSION) ${version_arg} -lm
+
+@DJGPP_FALSE@libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)
 
 # Use special rules for the deprecated source files so that they find
 # deprecated include files.
@@ -590,7 +610,9 @@ clean-toolexeclibLTLIBRARIES:
 	  rm -f "$${dir}/so_locations"; \
 	done
 libstdc++.la: $(libstdc___la_OBJECTS) $(libstdc___la_DEPENDENCIES) 
-	$(libstdc___la_LINK) -rpath $(toolexeclibdir) $(libstdc___la_OBJECTS) $(libstdc___la_LIBADD) $(LIBS)
+	$(libstdc___la_LINK) $(am_libstdc___la_rpath) $(libstdc___la_OBJECTS) $(libstdc___la_LIBADD) $(LIBS)
+libstdcxx.la: $(libstdcxx_la_OBJECTS) $(libstdcxx_la_DEPENDENCIES) 
+	$(libstdcxx_la_LINK) $(am_libstdcxx_la_rpath) $(libstdcxx_la_OBJECTS) $(libstdcxx_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
diff --git a/libstdc++-v3/testsuite/Makefile.in b/libstdc++-v3/testsuite/Makefile.in
index 485db903a..30685adeb 100644
--- a/libstdc++-v3/testsuite/Makefile.in
+++ b/libstdc++-v3/testsuite/Makefile.in
@@ -205,6 +205,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -227,6 +228,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/lt~obsolete.m4 b/lt~obsolete.m4
deleted file mode 100644
index bf92b5e07..000000000
--- a/lt~obsolete.m4
+++ /dev/null
@@ -1,98 +0,0 @@
-# lt~obsolete.m4 -- aclocal satisfying obsolete definitions.    -*-Autoconf-*-
-#
-#   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.
-#   Written by Scott James Remnant, 2004.
-#
-# This file is free software; the Free Software Foundation gives
-# unlimited permission to copy and/or distribute it, with or without
-# modifications, as long as this notice is preserved.
-
-# serial 4 lt~obsolete.m4
-
-# These exist entirely to fool aclocal when bootstrapping libtool.
-#
-# In the past libtool.m4 has provided macros via AC_DEFUN (or AU_DEFUN)
-# which have later been changed to m4_define as they aren't part of the
-# exported API, or moved to Autoconf or Automake where they belong.
-#
-# The trouble is, aclocal is a bit thick.  It'll see the old AC_DEFUN
-# in /usr/share/aclocal/libtool.m4 and remember it, then when it sees us
-# using a macro with the same name in our local m4/libtool.m4 it'll
-# pull the old libtool.m4 in (it doesn't see our shiny new m4_define
-# and doesn't know about Autoconf macros at all.)
-#
-# So we provide this file, which has a silly filename so it's always
-# included after everything else.  This provides aclocal with the
-# AC_DEFUNs it wants, but when m4 processes it, it doesn't do anything
-# because those macros already exist, or will be overwritten later.
-# We use AC_DEFUN over AU_DEFUN for compatibility with aclocal-1.6. 
-#
-# Anytime we withdraw an AC_DEFUN or AU_DEFUN, remember to add it here.
-# Yes, that means every name once taken will need to remain here until
-# we give up compatibility with versions before 1.7, at which point
-# we need to keep only those names which we still refer to.
-
-# This is to help aclocal find these macros, as it can't see m4_define.
-AC_DEFUN([LTOBSOLETE_VERSION], [m4_if([1])])
-
-m4_ifndef([AC_LIBTOOL_LINKER_OPTION],	[AC_DEFUN([AC_LIBTOOL_LINKER_OPTION])])
-m4_ifndef([AC_PROG_EGREP],		[AC_DEFUN([AC_PROG_EGREP])])
-m4_ifndef([_LT_AC_PROG_ECHO_BACKSLASH],	[AC_DEFUN([_LT_AC_PROG_ECHO_BACKSLASH])])
-m4_ifndef([_LT_AC_SHELL_INIT],		[AC_DEFUN([_LT_AC_SHELL_INIT])])
-m4_ifndef([_LT_AC_SYS_LIBPATH_AIX],	[AC_DEFUN([_LT_AC_SYS_LIBPATH_AIX])])
-m4_ifndef([_LT_PROG_LTMAIN],		[AC_DEFUN([_LT_PROG_LTMAIN])])
-m4_ifndef([_LT_AC_TAGVAR],		[AC_DEFUN([_LT_AC_TAGVAR])])
-m4_ifndef([AC_LTDL_ENABLE_INSTALL],	[AC_DEFUN([AC_LTDL_ENABLE_INSTALL])])
-m4_ifndef([AC_LTDL_PREOPEN],		[AC_DEFUN([AC_LTDL_PREOPEN])])
-m4_ifndef([_LT_AC_SYS_COMPILER],	[AC_DEFUN([_LT_AC_SYS_COMPILER])])
-m4_ifndef([_LT_AC_LOCK],		[AC_DEFUN([_LT_AC_LOCK])])
-m4_ifndef([AC_LIBTOOL_SYS_OLD_ARCHIVE],	[AC_DEFUN([AC_LIBTOOL_SYS_OLD_ARCHIVE])])
-m4_ifndef([_LT_AC_TRY_DLOPEN_SELF],	[AC_DEFUN([_LT_AC_TRY_DLOPEN_SELF])])
-m4_ifndef([AC_LIBTOOL_PROG_CC_C_O],	[AC_DEFUN([AC_LIBTOOL_PROG_CC_C_O])])
-m4_ifndef([AC_LIBTOOL_SYS_HARD_LINK_LOCKS], [AC_DEFUN([AC_LIBTOOL_SYS_HARD_LINK_LOCKS])])
-m4_ifndef([AC_LIBTOOL_OBJDIR],		[AC_DEFUN([AC_LIBTOOL_OBJDIR])])
-m4_ifndef([AC_LTDL_OBJDIR],		[AC_DEFUN([AC_LTDL_OBJDIR])])
-m4_ifndef([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH], [AC_DEFUN([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH])])
-m4_ifndef([AC_LIBTOOL_SYS_LIB_STRIP],	[AC_DEFUN([AC_LIBTOOL_SYS_LIB_STRIP])])
-m4_ifndef([AC_PATH_MAGIC],		[AC_DEFUN([AC_PATH_MAGIC])])
-m4_ifndef([AC_PROG_LD_GNU],		[AC_DEFUN([AC_PROG_LD_GNU])])
-m4_ifndef([AC_PROG_LD_RELOAD_FLAG],	[AC_DEFUN([AC_PROG_LD_RELOAD_FLAG])])
-m4_ifndef([AC_DEPLIBS_CHECK_METHOD],	[AC_DEFUN([AC_DEPLIBS_CHECK_METHOD])])
-m4_ifndef([AC_LIBTOOL_PROG_COMPILER_NO_RTTI], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_NO_RTTI])])
-m4_ifndef([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE], [AC_DEFUN([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE])])
-m4_ifndef([AC_LIBTOOL_PROG_COMPILER_PIC], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_PIC])])
-m4_ifndef([AC_LIBTOOL_PROG_LD_SHLIBS],	[AC_DEFUN([AC_LIBTOOL_PROG_LD_SHLIBS])])
-m4_ifndef([AC_LIBTOOL_POSTDEP_PREDEP],	[AC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP])])
-m4_ifndef([LT_AC_PROG_EGREP],		[AC_DEFUN([LT_AC_PROG_EGREP])])
-m4_ifndef([LT_AC_PROG_SED],		[AC_DEFUN([LT_AC_PROG_SED])])
-m4_ifndef([_LT_CC_BASENAME],		[AC_DEFUN([_LT_CC_BASENAME])])
-m4_ifndef([_LT_COMPILER_BOILERPLATE],	[AC_DEFUN([_LT_COMPILER_BOILERPLATE])])
-m4_ifndef([_LT_LINKER_BOILERPLATE],	[AC_DEFUN([_LT_LINKER_BOILERPLATE])])
-m4_ifndef([_AC_PROG_LIBTOOL],		[AC_DEFUN([_AC_PROG_LIBTOOL])])
-m4_ifndef([AC_LIBTOOL_SETUP],		[AC_DEFUN([AC_LIBTOOL_SETUP])])
-m4_ifndef([_LT_AC_CHECK_DLFCN],		[AC_DEFUN([_LT_AC_CHECK_DLFCN])])
-m4_ifndef([AC_LIBTOOL_SYS_DYNAMIC_LINKER],	[AC_DEFUN([AC_LIBTOOL_SYS_DYNAMIC_LINKER])])
-m4_ifndef([_LT_AC_TAGCONFIG],		[AC_DEFUN([_LT_AC_TAGCONFIG])])
-m4_ifndef([AC_DISABLE_FAST_INSTALL],	[AC_DEFUN([AC_DISABLE_FAST_INSTALL])])
-m4_ifndef([_LT_AC_LANG_CXX],		[AC_DEFUN([_LT_AC_LANG_CXX])])
-m4_ifndef([_LT_AC_LANG_F77],		[AC_DEFUN([_LT_AC_LANG_F77])])
-m4_ifndef([_LT_AC_LANG_GCJ],		[AC_DEFUN([_LT_AC_LANG_GCJ])])
-m4_ifndef([AC_LIBTOOL_LANG_C_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_C_CONFIG])])
-m4_ifndef([_LT_AC_LANG_C_CONFIG],	[AC_DEFUN([_LT_AC_LANG_C_CONFIG])])
-m4_ifndef([AC_LIBTOOL_LANG_CXX_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_CXX_CONFIG])])
-m4_ifndef([_LT_AC_LANG_CXX_CONFIG],	[AC_DEFUN([_LT_AC_LANG_CXX_CONFIG])])
-m4_ifndef([AC_LIBTOOL_LANG_F77_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_F77_CONFIG])])
-m4_ifndef([_LT_AC_LANG_F77_CONFIG],	[AC_DEFUN([_LT_AC_LANG_F77_CONFIG])])
-m4_ifndef([AC_LIBTOOL_LANG_GCJ_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_GCJ_CONFIG])])
-m4_ifndef([_LT_AC_LANG_GCJ_CONFIG],	[AC_DEFUN([_LT_AC_LANG_GCJ_CONFIG])])
-m4_ifndef([AC_LIBTOOL_LANG_RC_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_RC_CONFIG])])
-m4_ifndef([_LT_AC_LANG_RC_CONFIG],	[AC_DEFUN([_LT_AC_LANG_RC_CONFIG])])
-m4_ifndef([AC_LIBTOOL_CONFIG],		[AC_DEFUN([AC_LIBTOOL_CONFIG])])
-m4_ifndef([_LT_AC_FILE_LTDLL_C],	[AC_DEFUN([_LT_AC_FILE_LTDLL_C])])
-m4_ifndef([_LT_REQUIRED_DARWIN_CHECKS],	[AC_DEFUN([_LT_REQUIRED_DARWIN_CHECKS])])
-m4_ifndef([_LT_AC_PROG_CXXCPP],		[AC_DEFUN([_LT_AC_PROG_CXXCPP])])
-m4_ifndef([_LT_PREPARE_SED_QUOTE_VARS],	[AC_DEFUN([_LT_PREPARE_SED_QUOTE_VARS])])
-m4_ifndef([_LT_PROG_ECHO_BACKSLASH],	[AC_DEFUN([_LT_PROG_ECHO_BACKSLASH])])
-m4_ifndef([_LT_PROG_F77],		[AC_DEFUN([_LT_PROG_F77])])
-m4_ifndef([_LT_PROG_FC],		[AC_DEFUN([_LT_PROG_FC])])
-m4_ifndef([_LT_PROG_CXX],		[AC_DEFUN([_LT_PROG_CXX])])
diff --git a/readme.DJGPP b/readme.DJGPP
new file mode 100644
index 000000000..bc986ce2a
--- /dev/null
+++ b/readme.DJGPP
@@ -0,0 +1,345 @@
+This is the DJGPP port of gcc-4.6.4
+
+Please read this file up to end (maybe skipping sections You don't need,
+for example You don't need to read how to build gcc-4.6.4 from sources
+if You only intend to use binary archives). Also consult DJGPP documentation
+and FAQ where needed.
+
+
+Requirements to use this binary release:
+    DJGPP-@DJVER@. 
+    binutils-2.16 or above (Earlier versions will NOT work any more due to
+	incompatible linker scripts as linker script is no more included
+	with DJGPP port of GCC)
+
+Requirements to build gcc-4.6.4 from sources:
+    Long filename support. I built it in DOS session under WinXP Pro (SP2).
+        Win95, Win98, WinME or Win2K should be OK. I myself haven't tested
+	whether it can be build under Win98, Win2k or Win2K.
+    perhaps at least 256Mb of RAM for building (Amount of available
+        DPMI memory for DOS session should be set to auto).
+    rebuilt stubify.exe with the default stack size increased (even 1024K was
+    not enough, but with stack size 2048K build succeeded).
+    DOS transfer buffer size increased to 32K for sime executables (I did it
+        for GNU make and LD).
+    at least DJGPP-2.03 patchlevel 2 required
+    other GNU utilities (see below)
+
+
+Source archives
+===============
+
+
+Archive gcc464s2.zip contains script which modifies original gcc-4.6.4
+and sources for DJGPP. You don't need it unless You want to recreate
+GCC source archive for DJGPP. If You are using this archive and original 
+sources of gcc-4.6.4.tar.gz, then You don't need gcc464s.zip.
+    
+The source archive gcc464s.zip contains all the sources to build
+all compilers (C, C++, Objective C, Objective C++, GNU Fortran) and also C++
+and Fortran libraries (libstdcxx.a, libgpp.a and libg2c.a). 
+libg++ is no more supported.
+
+Most users don't need source archives at all.
+
+Binary archives
+================
+
+Binary archives are split into 5 parts:
+
+  gcc464b.zip  : The gcc.exe driver program and the C compiler.
+                 It also contains the documentation.
+
+  gpp464b.zip  : The C++ compiler and libstdcxx.a together 
+                 with needed header files. Please note that one must
+		 recompile all C++ sources built with any earlier GCC version
+
+  objc464b.zip : The Objective C and Objective C++ compilers and 
+		 libobjc.a and the needed header files.
+
+  gfor464b.zip  : GNU Fortran compiler
+
+
+The archive gcc464b.zip is required by all other binary packages
+
+Binary packages includes following documentation files:
+  
+  Archive gcc464b.zip:  
+	info/gcc.info - the use and the internals of the GNU compiler
+	info/cpp.info - documentation of the GNU C preprocessor.
+	info/cppinternals.info  - internals of the GNU C Preprocessor.
+        info/gccinstall.info
+	info/gccint.info
+		(NEW: use install-info to add it to info/dir)
+  Archive gpp464b.zip:
+        gnu/gcc-4.64/libstdcxx/* - some documentation of libstdc++-v3
+		(HTML and text formats)
+  Archive gfor464b.zip:
+	info/gfortran.info - documentation of the GNU Fortran compiler
+
+
+Before you install gcc-4.6.4 binaries
+======================================
+
+You should remove previous installation of gcc or egcs completely
+(unless You really know what You are doing).
+
+Make sure You don't have following files from earlier versions
+(relative paths against to DJGPP directory are given):
+	bin/cc1.exe		(from gcc272b.zip or gcc2721b.zip)
+	bin/cc1plus.exe		(from gpp272b.zip or gpp2721b.zip)
+	lib/libgcc.a		(from gcc272b.zip or gcc2721b.zip)
+	lib/libobjc.a		
+	lib/specs		(from djdev201.zip or djdev202.zip) 
+	lib/libstdcxx.a		
+	lib/libgpp.a		
+
+Following packages are required for binaries:
+	binutils-2.16 or above. Linker script is no more included in DJGPP
+	    release of GCC and all earlier binutils releases for DJGPP
+	    had incompatible scripts. SO PLEASE UPGRADE.
+
+	DJGPP-@DJVER@ (djdev203.zip)
+
+
+Installing binaries of gcc-4.6.4
+=================================
+
+Needed archives for different programing languages
+	C 			: gcc464b.zip
+
+	C++			: gcc464b.zip, gpp464b.zip
+
+	Fortran	95              : gcc464b.zip, gfor464b.zip
+
+	Objective C		: gcc464b.zip, objc464b.zip
+
+Of course for ALL languages You also need at least binutils (bnu216b.zip
+or newer) and @DJDEV@.zip (or newer when it will be released)
+
+Unzip all the zip files from that directory, preserving the
+directory structure.  For example:
+
+	pkunzip -d @DJDEV@
+or
+	unzip386 @DJDEV@
+
+
+NOTE:   For debugging GDB version 6.3 or above is recommended. 
+        (gdb-6.3 is not released for DJGPP yet though).
+
+
+1. Only long filenames
+----------------------
+
+Unzip the binaries with an unzip program, which can restore the long filenames
+stored in the zip archive.
+
+2. Only short filenames
+-----------------------
+
+Unzip the binaries with an unzip program which doesn't know about long
+filenames, or if your unzipper knows about them, please follow first
+the steps described in the DJGPP FAQ in the section 
+about setting the NameNumericTail to 0 __BEFORE__!!! unzipping the archives.
+
+3. Long and short filenames at the same time
+--------------------------------------------
+
+Use an unzip program which can restore the long filenames and follow
+the instructions under 2. when the unzipper knows about long filenames.
+
+
+Note for users of C++ IO classes fstream, ifstream, ofstream
+============================================================
+
+There is a regression against earlier versions of GCC (gcc-2.95.3 and
+earlier): Member functions tellp(), tellg(), seekp() and seekg()
+are broken when stream is opened not in binary mode. If You are going
+to use any similar functions You should open stream in binary mode.
+
+Don't ask me when it will be fixed as I don't know that. I'm also 
+not sure I'll spend much time trying to fix that.
+
+
+Rebuilding gcc-4.6.4 from the sources
+======================================
+
+Requirements
+------------
+
+-  Long filename support is required. It means You should build gcc-4.6.4
+   under Win95, Win98, WinME, Win2000 or WinXP. I myself built gcc-4.6.4
+   under WinXP.
+
+-  Much of free disk space (more than 1Gb)
+
+-  perhaps 128Mb RAM (or more) to build gcc-4.6.4 under Win9X. 
+   DPMI memory amount for DOS session should be set to "Auto".
+   Building on machine with only 64 Mb of memory is not tested.
+   (I used machine with 1512Mb of memory, operating system WinXP Pro SP2)
+   
+-  One must rebuild stubify.exe to use larger stack size. The default
+   512Kb is not enough and the build not succeed in that case:
+   - download DJGPP runtime sources (djlsr203.zip or djlsr204.zip)
+   - patch src/stub/stub.asm to increase stack size to 1Mb
+   - rebuild stub and stubify.exe
+   See DJGPP FAQ for more information how to build DJGPP from sources.
+   stubify.exe is built very soon and further failures caused by incompatibility
+   with newer GCC version can safely be ignores.
+
+-  It is recommended to build and install MPFR-2.2.1 or above (http://www.mpfr.org/).
+   There is buggy version shipped inside GMP, GCC builds also in that case.
+
+-  rebuilt stubify.exe with the default stack size increased (I used 1024K).
+
+-  DOS transfer buffer size increased to 32K for sime executables (I did it
+   for GNU make and ld). I do not know whether both are needed. 
+        
+    at least DJGPP-2.03 patchlevel 2 required
+-  Many GNU packages.
+	bash-2.0.4 or above
+	GNU Diffutils 2.8 or above
+	GNU Fileutils-4.1
+	GNU Find 4.1.7 or above
+	GNU grep 2.5.1 or above
+	GNU Awk 3.1.1 or above
+	GNU Make 3.80 or above
+	GNU Sed 4.0.7 or above
+	GNU shell utils 2.0.11
+	GNU Textutils 2.0
+	GNU Texinfo 4.8 or above
+	GNU tar 1.1.2 or above
+	GNU binutils 2.22 (newer than to use GCC packages!!!)
+	GNU GMP 4.3.1 (required to build GNU Fortran compiler) or above
+	MPFR 2.3.0 or above
+	MPC-0.8.1 or above
+	Zlib-1.2.5 or above (Warning configure does not check for presence
+	     one only gets build error later)
+	working GNU C compiler (perhaps not earlier than gcc-3.3). 
+
+   If You modify some source files You may also need
+	autoconf-2.64 above
+	automake-1.11 or above
+	(No ports available for DJGPP yet. I did all patching GCC sources
+	and updating autoconf and automake related stuff in Linux)
+	
+   You need autoconf and automake also if You are using gcc464s2.zip.
+   However it's normally not needed for most users who builds gcc-4.6.4 from
+   contents of gcc464s.zip. In that case You need to edit script unpack-gcc
+   to specify place where old and new versions of autoconf and automake are
+   installed
+
+   Usually newer versions of these packages should also work unless
+   otherwise stated above. Older versions may work in some cases, but that
+   is not tested
+
+-  INFO-ZIP binary (compiled with DJGPP v2!!!) is needed for using build.sh 
+   to create binary distribution archives. There is no problems to compile 
+   it. See http://www.info-zip.org for additional information
+   about INFO-ZIP. You can find DJGPP compiled binary there. 
+
+-  Working DJGPP installation of course:
+	DJGPP-2.03 patchlevel 2 or above, 
+	working gcc installation (gcc-3.3.0 or above, You need
+                working Ada compiler to build Ada compiler).
+   NOTE: gcc-4.6.4 compiled using DJGPP-2.03 Patchelevel 2 must not be
+   used with DJGPP-2.04 and otherwise - gcc-4.6.4 compiled using 
+   for example recent DJGPP-2.04 CVS version can be used with DJGPP-2.04
+   Beta 1 but not with DJGPP-2.03 Patchlevel 2. This must be taken into
+   account when compiling gcc-4.6.4 for DJGPP from sources
+
+   NOTE: Building GCC-4.6.4 using DJGPP v2.03 patchlevel 2 requires rebuilding
+   several DJGPP packets before building GCC.
+
+-  You should have sh.exe in DJGPP bin directory as symbolic link to  
+   bash.exe (type 'ln -s bash.exe sh.exe' in that directory)
+
+
+Extracting the sources
+----------------------
+
+At first you should unzip the archive gcc464s.zip. The sources are _NOT_
+the complete sources like the original gcc-4.6.4 distribution. I have
+removed many files to save disk space which are not needed for the DJGPP
+port. However I left configuration of other machines in to make archives
+usable to build cross-to-DJGPP compilers and DJGPP hosted cross-compilers
+(I haven't tested it).
+
+
+Compiling gcc
+-------------
+
+Directory gnu/gcc-4.64 contains all sources of gcc-4.6.4
+
+Sources are NOT configured. 
+	
+Change to directory gnu/build.gcc and configure sources
+by running script djconfig.sh. 
+
+	sh djconfig.sh
+
+When this is done You can build gcc-4.6.4 by running script djmake.sh
+Under Win9X You'll have to restart it some times when it will crash 
+due to Win9X DPMI descriptor leaks. You may use redir to get output in file.
+
+	sh djmake.sh bootstrap
+
+When this successfully ends run script djinsttmp.sh which installs
+all into directory gnu/install.gcc
+
+After that change to this directory and run script makepkg.sh
+to create binary distribution packages
+
+
+Installing newly compiled gcc
+-----------------------------
+
+It's recommended to install binary packages which are generated 
+by makepkg.sh
+
+
+
+Available resources
+===================
+
+See following URL for additional information:
+gcc:		  http://gcc.gnu.org
+
+
+
+Reporting bugs
+==============
+
+If you found a bug in gcc-4.6.4 (gcc, gfortran, libstdc++, etc) please report it to 
+the GCC bug addresses and _NOT_ (or at least not only) in the DJGPP news group. 
+
+But if you think you found a bug in the DJGPP related things, then please 
+report it in comp.os.msdos.djgpp (the news group) or mail it to 
+djgpp@delorie.com, which is the gateway to the news group.
+
+Some possible situations:
+  - gcc says 'Internal compiler error' (or something similar)
+       more likely it is error of gcc if it is reproducible. It would 
+       be nice to test on some other system (e.g. Linux) and also with 
+       different version of compiler if possible and submit report to 
+       gcc bug address. 
+  - gcc crashes or freezes. 
+       In this situation it's hard to guess where is the problem. It may be
+       problem with gcc itself but it may be also DJGPP specific one.
+
+Please email me directly only in rare cases, if you think it is only of
+interest to me, since I'll see the reports in DJGPP mailing list.
+
+
+Thanks to
+=========
+
+To all who have contributed new features, test results, bug-fixes to GCC
+(see http://gcc.gnu.org/thanks.html) and also who helped with DJGPP port of 
+gcc-4.6.4
+
+
+Have fun with gcc
+
+Andris Pavenis <andris.pavenis@iki.fi>
