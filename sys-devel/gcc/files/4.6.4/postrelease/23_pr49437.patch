diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index c3c5aa168..47e36f3bc 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -14834,6 +14834,7 @@ arm_output_epilogue (rtx sibling)
 		  && !crtl->calls_eh_return
 		  && bit_count(saved_regs_mask) * 4 == count
 		  && !IS_INTERRUPT (func_type)
+		  && !IS_STACKALIGN (func_type)
 		  && !crtl->tail_call_emit)
 		{
 		  unsigned long mask;
diff --git a/gcc/testsuite/gcc.c-torture/execute/20101011-1.c b/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
index 7180e68b0..427a0e9ff 100644
--- a/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
+++ b/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
@@ -12,6 +12,9 @@
 #elif defined (__sh__)
   /* On SH division by zero does not trap.  */
 # define DO_TEST 0
+#elif defined (__arm__)
+ /* We cannot rely on division by zero generating a trap. */
+# define DO_TEST 0
 #elif defined (__mips__) && !defined(__linux__)
   /* MIPS divisions do trap by default, but libgloss targets do not
      intercept the trap and raise a SIGFPE.  The same is probably
diff --git a/gcc/testsuite/gcc.dg/torture/pr49169.c b/gcc/testsuite/gcc.dg/torture/pr49169.c
new file mode 100644
index 000000000..721b2ac64
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr49169.c
@@ -0,0 +1,13 @@
+#include <stdlib.h>
+#include <stdint.h>
+
+int
+main (void)
+{
+  void *p = main;
+  if ((intptr_t) p & 1)
+    abort ();
+  return 0;
+}
+
+/* { dg-final { scan-assembler "abort" } } */
diff --git a/gcc/testsuite/gcc.target/arm/handler-align.c b/gcc/testsuite/gcc.target/arm/handler-align.c
new file mode 100644
index 000000000..6c5187b20
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/handler-align.c
@@ -0,0 +1,42 @@
+/* Test epilogue of a realigned interrupt handler. */
+/* { dg-do run } */
+/* { dg-options "-mthumb -Os" } */
+/* { dg-skip-if "" { ! { arm_thumb1_ok || arm_thumb2_ok } } } */
+/* { dg-require-effective-target arm_cortex_m } */
+/* { dg-require-effective-target arm_eabi } */
+
+extern __attribute__((noreturn)) void abort(void);
+extern int snprintf(char *, int, const char *, ...);
+
+#define BUFF_LEN 256
+char buff[BUFF_LEN];
+
+char *get_buffer(void)
+{
+	return buff;
+}
+
+void __attribute__((interrupt)) foo(void)
+{
+        char *msg = get_buffer();
+        snprintf(msg, BUFF_LEN, "%d %p", 1, buff+BUFF_LEN);
+}
+
+volatile void * save_sp;
+int main()
+{
+	register volatile void * sp asm("sp");
+	/* Check stack pointer before/after calling the interrupt
+         * handler. Not equal means that handler doesn't restore
+         * stack correctly.  */
+	save_sp = sp;
+	foo();
+	/* Abort here instead of return non-zero. Due to wrong sp, lr value,
+	 * returning from main may not work.  */
+	if (save_sp != sp)
+	{
+		sp = save_sp;
+		abort();
+	}
+	return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr46934.c b/gcc/testsuite/gcc.target/arm/pr46934.c
new file mode 100644
index 000000000..22b8aa838
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr46934.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv5te -mthumb -Os" }  */
+/* { dg-require-effective-target arm_thumb1_ok } */
+
+int caller (unsigned int reg_type)
+{
+  switch (reg_type)
+    {
+    case 0x80000000:
+      return (int)foo();
+
+    case 0x80000003:
+      return (int) bar();
+
+    case 0x80000001:
+      return (int) baz();
+
+    case 0x80000004:
+      return (int) fooz();
+    }
+}
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index 7da4afd8f..d2f6b7df2 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -2022,6 +2022,19 @@ proc check_effective_target_arm_thumb1 { } {
     } ""]
 }
 
+# Return 1 if this is an ARM cortex-M profile cpu
+
+proc check_effective_target_arm_cortex_m { } {
+    return [check_no_compiler_messages arm_cortex_m assembly {
+	#if !defined(__ARM_ARCH_7M__) \
+            && !defined (__ARM_ARCH_7EM__) \
+            && !defined (__ARM_ARCH_6M__)
+	#error FOO
+	#endif
+	int i;
+    } "-mthumb"]
+}
+
 # Return 1 if the target supports executing NEON instructions, 0
 # otherwise.  Cache the result.
 
