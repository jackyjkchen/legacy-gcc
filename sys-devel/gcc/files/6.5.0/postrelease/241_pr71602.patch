diff --git a/gcc/builtins.c b/gcc/builtins.c
index 7a71a8725..71ff6d7d7 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -4117,10 +4117,6 @@ std_canonical_va_list_type (tree type)
 {
   tree wtype, htype;
 
-  if (INDIRECT_REF_P (type))
-    type = TREE_TYPE (type);
-  else if (POINTER_TYPE_P (type) && POINTER_TYPE_P (TREE_TYPE (type)))
-    type = TREE_TYPE (type);
   wtype = va_list_type_node;
   htype = type;
   /* Treat structure va_list types.  */
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index 0ea92dd5e..f94c7ec89 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -5711,20 +5711,11 @@ build_va_arg (location_t loc, tree expr, tree type)
     {
       /* Case 1: Not an array type.  */
 
-      /* Take the address, to get '&ap'.  */
+      /* Take the address, to get '&ap'.  Note that &ap is not a va_list
+	 type.  */
       mark_addressable (expr);
       expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (expr)), expr);
 
-      /* Verify that &ap is still recognized as having va_list type.  */
-      tree canon_expr_type
-	= targetm.canonical_va_list_type (TREE_TYPE (expr));
-      if (canon_expr_type == NULL_TREE)
-	{
-	  error_at (loc,
-		    "first argument to %<va_arg%> not of type %<va_list%>");
-	  return error_mark_node;
-	}
-
       return build_va_arg_1 (loc, type, expr);
     }
 
@@ -5791,12 +5782,7 @@ build_va_arg (location_t loc, tree expr, tree type)
       /* Verify that &ap is still recognized as having va_list type.  */
       tree canon_expr_type
 	= targetm.canonical_va_list_type (TREE_TYPE (expr));
-      if (canon_expr_type == NULL_TREE)
-	{
-	  error_at (loc,
-		    "first argument to %<va_arg%> not of type %<va_list%>");
-	  return error_mark_node;
-	}
+      gcc_assert (canon_expr_type != NULL_TREE);
     }
   else
     {
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 9b9229f9c..cd17685ea 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -53788,14 +53788,6 @@ ix86_fn_abi_va_list (tree fndecl)
 static tree
 ix86_canonical_va_list_type (tree type)
 {
-  /* Resolve references and pointers to va_list type.  */
-  if (TREE_CODE (type) == MEM_REF)
-    type = TREE_TYPE (type);
-  else if (POINTER_TYPE_P (type) && POINTER_TYPE_P (TREE_TYPE(type)))
-    type = TREE_TYPE (type);
-  else if (POINTER_TYPE_P (type) && TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)
-    type = TREE_TYPE (type);
-
   if (TARGET_64BIT)
     {
       if (lookup_attribute ("ms_abi va_list", TYPE_ATTRIBUTES (type)))
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index 3fde362ed..04cabf6d5 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -11916,6 +11916,11 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p,
   if (have_va_type == error_mark_node)
     return GS_ERROR;
   have_va_type = targetm.canonical_va_list_type (have_va_type);
+  if (have_va_type == NULL_TREE
+      && TREE_CODE (valist) == ADDR_EXPR)
+    /* Handle 'Case 1: Not an array type' from c-common.c/build_va_arg.  */
+    have_va_type
+      = targetm.canonical_va_list_type (TREE_TYPE (TREE_TYPE (valist)));
 
   if (have_va_type == NULL_TREE)
     {
diff --git a/gcc/testsuite/c-c++-common/va-arg-va-list-type.c b/gcc/testsuite/c-c++-common/va-arg-va-list-type.c
new file mode 100644
index 000000000..cdd97cfb0
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/va-arg-va-list-type.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+
+__builtin_va_list *pap;
+
+void
+fn1 (void)
+{
+  __builtin_va_arg (pap, double); /* { dg-error "first argument to 'va_arg' not of type 'va_list'" } */
+}
