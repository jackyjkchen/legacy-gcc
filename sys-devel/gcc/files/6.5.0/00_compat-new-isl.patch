diff --git a/configure b/configure
index f54636b8a..6491d12c1 100755
--- a/configure
+++ b/configure
@@ -650,7 +650,6 @@ extra_linker_plugin_flags
 extra_linker_plugin_configure_flags
 islinc
 isllibs
-islver
 poststage1_ldflags
 poststage1_libs
 stage1_ldflags
@@ -6024,15 +6023,15 @@ $as_echo "$as_me: WARNING: using in-tree isl, disabling version check" >&2;}
     LDFLAGS="${_isl_saved_LDFLAGS} ${isllibs} ${gmplibs}"
     LIBS="${_isl_saved_LIBS} -lisl -lgmp"
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for isl 0.16, 0.15, or deprecated 0.14" >&5
-$as_echo_n "checking for isl 0.16, 0.15, or deprecated 0.14... " >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for isl 0.15 or later" >&5
+$as_echo_n "checking for isl 0.15 or later... " >&6; }
     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <isl/ctx.h>
+#include <isl/schedule.h>
 int
 main ()
 {
-isl_ctx_get_max_operations (isl_ctx_alloc ());
+isl_options_set_schedule_serialize_sccs (NULL, 0);
   ;
   return 0;
 }
@@ -6048,36 +6047,8 @@ rm -f core conftest.err conftest.$ac_objext \
 $as_echo "$gcc_cv_isl" >&6; }
 
     if test "${gcc_cv_isl}" = no ; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: recommended isl version is 0.16 or 0.15, the minimum required isl version 0.14 is deprecated" >&5
-$as_echo "recommended isl version is 0.16 or 0.15, the minimum required isl version 0.14 is deprecated" >&6; }
-    fi
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for isl 0.16 or 0.15" >&5
-$as_echo_n "checking for isl 0.16 or 0.15... " >&6; }
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <isl/schedule.h>
-int
-main ()
-{
-isl_options_set_schedule_serialize_sccs (NULL, 0);
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_has_isl_options_set_schedule_serialize_sccs=yes
-else
-  ac_has_isl_options_set_schedule_serialize_sccs=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_has_isl_options_set_schedule_serialize_sccs" >&5
-$as_echo "$ac_has_isl_options_set_schedule_serialize_sccs" >&6; }
-
-    if test x"$ac_has_isl_options_set_schedule_serialize_sccs" = x"yes"; then
-      islver="0.15"
-
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: required isl version is 0.15 or later" >&5
+$as_echo "required isl version is 0.15 or later" >&6; }
     fi
 
     CFLAGS=$_isl_saved_CFLAGS
diff --git a/gcc/config.in b/gcc/config.in
index 59f4c3733..00850dbff 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -1403,12 +1403,6 @@
 #endif
 
 
-/* Define if isl_options_set_schedule_serialize_sccs exists. */
-#ifndef USED_FOR_TARGET
-#undef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-#endif
-
-
 /* Define to 1 if you have the `kill' function. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_KILL
diff --git a/gcc/configure b/gcc/configure
index bc52c9db5..6bae4376c 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -29186,47 +29186,6 @@ $as_echo "#define HAVE_isl 1" >>confdefs.h
 
 fi
 
-# Check whether isl_options_set_schedule_serialize_sccs is available;
-# it's new in isl 0.15.
-if test "x${ISLLIBS}" != "x" ; then
-  saved_CXXFLAGS="$CXXFLAGS"
-  CXXFLAGS="$CXXFLAGS $ISLINC $GMPINC"
-  saved_LIBS="$LIBS"
-  LIBS="$LIBS $ISLLIBS $GMPLIBS"
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking Checking for isl_options_set_schedule_serialize_sccs" >&5
-$as_echo_n "checking Checking for isl_options_set_schedule_serialize_sccs... " >&6; }
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <isl/schedule.h>
-int
-main ()
-{
-isl_options_set_schedule_serialize_sccs (NULL, 0);
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_has_isl_options_set_schedule_serialize_sccs=yes
-else
-  ac_has_isl_options_set_schedule_serialize_sccs=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_has_isl_options_set_schedule_serialize_sccs" >&5
-$as_echo "$ac_has_isl_options_set_schedule_serialize_sccs" >&6; }
-
-  LIBS="$saved_LIBS"
-  CXXFLAGS="$saved_CXXFLAGS"
-
-  if test x"$ac_has_isl_options_set_schedule_serialize_sccs" = x"yes"; then
-
-$as_echo "#define HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS 1" >>confdefs.h
-
-  fi
-fi
-
 # Check for plugin support
    # Check whether --enable-plugin was given.
 if test "${enable_plugin+set}" = set; then :
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 4bda5318c..f667aa4a7 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -6050,30 +6050,6 @@ if test "x${ISLLIBS}" != "x" ; then
    AC_DEFINE(HAVE_isl, 1, [Define if isl is in use.])
 fi
 
-# Check whether isl_options_set_schedule_serialize_sccs is available;
-# it's new in isl 0.15.
-if test "x${ISLLIBS}" != "x" ; then
-  saved_CXXFLAGS="$CXXFLAGS"
-  CXXFLAGS="$CXXFLAGS $ISLINC $GMPINC"
-  saved_LIBS="$LIBS"
-  LIBS="$LIBS $ISLLIBS $GMPLIBS"
-
-  AC_MSG_CHECKING([Checking for isl_options_set_schedule_serialize_sccs])
-  AC_TRY_LINK([#include <isl/schedule.h>],
-              [isl_options_set_schedule_serialize_sccs (NULL, 0);],
-              [ac_has_isl_options_set_schedule_serialize_sccs=yes],
-              [ac_has_isl_options_set_schedule_serialize_sccs=no])
-  AC_MSG_RESULT($ac_has_isl_options_set_schedule_serialize_sccs)
-
-  LIBS="$saved_LIBS"
-  CXXFLAGS="$saved_CXXFLAGS"
-
-  if test x"$ac_has_isl_options_set_schedule_serialize_sccs" = x"yes"; then
-     AC_DEFINE(HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS, 1,
-               [Define if isl_options_set_schedule_serialize_sccs exists.])
-  fi
-fi
-
 GCC_ENABLE_PLUGINS
 AC_SUBST(pluginlibs)
 AC_SUBST(enable_plugin)
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 5b6e2b7cb..0e4a9893f 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -383,7 +383,7 @@ installed but it is not in your default library search path, the
 @option{--with-mpc} configure option should be used.  See also
 @option{--with-mpc-lib} and @option{--with-mpc-include}.
 
-@item isl Library version 0.16, 0.15, or 0.14.
+@item isl Library version 0.15 or later.
 
 Necessary to build GCC with the Graphite loop optimizations.
 It can be downloaded from @uref{ftp://gcc.gnu.org/pub/gcc/infrastructure/}.
diff --git a/gcc/graphite-dependences.c b/gcc/graphite-dependences.c
index f9d5bc309..23cfafa65 100644
--- a/gcc/graphite-dependences.c
+++ b/gcc/graphite-dependences.c
@@ -168,28 +168,6 @@ scop_get_may_writes (scop_p scop)
   return isl_union_map_coalesce (res);
 }
 
-#ifndef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-/* Returns all the original schedules in SCOP.  */
-
-static isl_union_map *
-scop_get_original_schedule (scop_p scop, vec<poly_bb_p> pbbs)
-{
-  int i;
-  poly_bb_p pbb;
-  isl_space *space = isl_set_get_space (scop->param_context);
-  isl_union_map *res = isl_union_map_empty (space);
-
-  FOR_EACH_VEC_ELT (pbbs, i, pbb)
-    {
-      res = isl_union_map_add_map
-	(res, constrain_domain (isl_map_copy (pbb->schedule),
-				isl_set_copy (pbb->domain)));
-    }
-
-  return isl_union_map_coalesce (res);
-}
-#endif
-
 /* Helper function used on each MAP of a isl_union_map.  Computes the
    maximal output dimension.  */
 
@@ -311,7 +289,6 @@ carries_deps (__isl_keep isl_union_map *schedule,
   return res;
 }
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
 /* Compute the dependence relations for the SCOP:
    RAW are read after write dependences,
    WAR are write after read dependences,
@@ -398,133 +375,4 @@ scop_get_dependences (scop_p scop)
   scop->dependence = dependences;
 }
 
-#else
-
-/* Compute the original data dependences in SCOP for all the reads and
-   writes in PBBS.  */
-
-static void
-compute_deps (scop_p scop, vec<poly_bb_p> pbbs,
-	      isl_union_map **must_raw,
-	      isl_union_map **may_raw,
-	      isl_union_map **must_raw_no_source,
-	      isl_union_map **may_raw_no_source,
-	      isl_union_map **must_war,
-	      isl_union_map **may_war,
-	      isl_union_map **must_war_no_source,
-	      isl_union_map **may_war_no_source,
-	      isl_union_map **must_waw,
-	      isl_union_map **may_waw,
-	      isl_union_map **must_waw_no_source,
-	      isl_union_map **may_waw_no_source)
-{
-  isl_union_map *reads = scop_get_reads (scop);
-  isl_union_map *must_writes = scop_get_must_writes (scop);
-  isl_union_map *may_writes = scop_get_may_writes (scop);
-  isl_union_map *all_writes = isl_union_map_union
-    (isl_union_map_copy (must_writes), isl_union_map_copy (may_writes));
-  all_writes = isl_union_map_coalesce (all_writes);
-
-  isl_space *space = isl_union_map_get_space (all_writes);
-  isl_union_map *empty = isl_union_map_empty (space);
-  isl_union_map *original = scop_get_original_schedule (scop, pbbs);
-
-  if (dump_file)
-    {
-      fprintf (dump_file, "\n--- Documentation for datarefs dump: ---\n");
-      fprintf (dump_file, "Statements on the iteration domain are mapped to"
-	       " array references.\n");
-      fprintf (dump_file, "  To read the following data references:\n\n");
-      fprintf (dump_file, "  S_5[i0] -> [106] : i0 >= 0 and i0 <= 3\n");
-      fprintf (dump_file, "  S_8[i0] -> [1, i0] : i0 >= 0 and i0 <= 3\n\n");
-
-      fprintf (dump_file, "  S_5[i0] is the dynamic instance of statement"
-	       " bb_5 in a loop that accesses all iterations 0 <= i0 <= 3.\n");
-      fprintf (dump_file, "  [1, i0] is a 'memref' with alias set 1"
-	       " and first subscript access i0.\n");
-      fprintf (dump_file, "  [106] is a 'scalar reference' which is the sum of"
-	       " SSA_NAME_VERSION 6"
-	       " and --param graphite-max-arrays-per-scop=100\n");
-      fprintf (dump_file, "-----------------------\n\n");
-
-      fprintf (dump_file, "data references (\n");
-      fprintf (dump_file, "  reads: ");
-      print_isl_union_map (dump_file, reads);
-      fprintf (dump_file, "  must_writes: ");
-      print_isl_union_map (dump_file, must_writes);
-      fprintf (dump_file, "  may_writes: ");
-      print_isl_union_map (dump_file, may_writes);
-      fprintf (dump_file, "  all_writes: ");
-      print_isl_union_map (dump_file, all_writes);
-      fprintf (dump_file, ")\n");
-    }
-
-  isl_union_map_compute_flow (isl_union_map_copy (reads),
-			      isl_union_map_copy (must_writes),
-			      isl_union_map_copy (may_writes),
-			      isl_union_map_copy (original),
-			      must_raw, may_raw, must_raw_no_source,
-			      may_raw_no_source);
-  isl_union_map_compute_flow (isl_union_map_copy (all_writes),
-			      reads, empty,
-			      isl_union_map_copy (original),
-			      must_war, may_war, must_war_no_source,
-			      may_war_no_source);
-  isl_union_map_compute_flow (all_writes, must_writes, may_writes,
-			      original,
-			      must_waw, may_waw, must_waw_no_source,
-			      may_waw_no_source);
-}
-
-isl_union_map *
-scop_get_dependences (scop_p scop)
-{
-  if (scop->dependence)
-    return scop->dependence;
-
-  /* The original dependence relations:
-     RAW are read after write dependences,
-     WAR are write after read dependences,
-     WAW are write after write dependences.  */
-  isl_union_map *must_raw = NULL, *may_raw = NULL, *must_raw_no_source = NULL,
-      *may_raw_no_source = NULL, *must_war = NULL, *may_war = NULL,
-      *must_war_no_source = NULL, *may_war_no_source = NULL, *must_waw = NULL,
-      *may_waw = NULL, *must_waw_no_source = NULL, *may_waw_no_source = NULL;
-
-  compute_deps (scop, scop->pbbs,
-		  &must_raw, &may_raw,
-		  &must_raw_no_source, &may_raw_no_source,
-		  &must_war, &may_war,
-		  &must_war_no_source, &may_war_no_source,
-		  &must_waw, &may_waw,
-		  &must_waw_no_source, &may_waw_no_source);
-
-  isl_union_map *dependences = must_raw;
-  dependences = isl_union_map_union (dependences, must_war);
-  dependences = isl_union_map_union (dependences, must_waw);
-  dependences = isl_union_map_union (dependences, may_raw);
-  dependences = isl_union_map_union (dependences, may_war);
-  dependences = isl_union_map_union (dependences, may_waw);
-  dependences = isl_union_map_coalesce (dependences);
-
-  if (dump_file)
-    {
-      fprintf (dump_file, "data dependences (\n");
-      print_isl_union_map (dump_file, dependences);
-      fprintf (dump_file, ")\n");
-    }
-
-  isl_union_map_free (must_raw_no_source);
-  isl_union_map_free (may_raw_no_source);
-  isl_union_map_free (must_war_no_source);
-  isl_union_map_free (may_war_no_source);
-  isl_union_map_free (must_waw_no_source);
-  isl_union_map_free (may_waw_no_source);
-
-  scop->dependence = dependences;
-  return dependences;
-}
-
-#endif /* HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS */
-
 #endif /* HAVE_isl */
diff --git a/gcc/graphite-isl-ast-to-gimple.c b/gcc/graphite-isl-ast-to-gimple.c
index c616d216f..4861e11d4 100644
--- a/gcc/graphite-isl-ast-to-gimple.c
+++ b/gcc/graphite-isl-ast-to-gimple.c
@@ -115,8 +115,6 @@ static void ivs_params_clear (ivs_params &ip)
     }
 }
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-
 /* Set the "separate" option for the schedule node.  */
 
 static isl_schedule_node *
@@ -157,8 +155,6 @@ debug_schedule_ast (__isl_keep isl_schedule *s, scop_p scop)
   print_schedule_ast (stderr, s, scop);
 }
 
-#endif
-
 enum phi_node_kind
 {
   unknown_phi,
@@ -227,17 +223,7 @@ class translate_isl_ast_to_gimple
   void add_parameters_to_ivs_params (scop_p scop, ivs_params &ip);
   __isl_give isl_ast_build *generate_isl_context (scop_p scop);
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   __isl_give isl_ast_node * scop_to_isl_ast (scop_p scop);
-#else
-  int get_max_schedule_dimensions (scop_p scop);
-  __isl_give isl_map *extend_schedule (__isl_take isl_map *schedule,
-				       int nb_schedule_dims);
-  __isl_give isl_union_map *generate_isl_schedule (scop_p scop);
-  __isl_give isl_ast_build *set_options (__isl_take isl_ast_build *control,
-					 __isl_keep isl_union_map *schedule);
-  __isl_give isl_ast_node *scop_to_isl_ast (scop_p scop, ivs_params &ip);
-#endif
 
   bool is_valid_rename (tree rename, basic_block def_bb, basic_block use_bb,
 			phi_node_kind, tree old_name, basic_block old_bb) const;
@@ -400,10 +386,7 @@ binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)
 	}
       return fold_build2 (TRUNC_DIV_EXPR, type, tree_lhs_expr, tree_rhs_expr);
 
-#if HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-    /* isl 0.15 or later.  */
     case isl_ast_op_zdiv_r:
-#endif
     case isl_ast_op_pdiv_r:
       /* As isl operates on arbitrary precision numbers, we may end up with
 	 division by 2^64 that is folded to 0.  */
@@ -568,10 +551,7 @@ gcc_expression_from_isl_expr_op (tree type, __isl_take isl_ast_expr *expr,
     case isl_ast_op_pdiv_q:
     case isl_ast_op_pdiv_r:
     case isl_ast_op_fdiv_q:
-#if HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-    /* isl 0.15 or later.  */
     case isl_ast_op_zdiv_r:
-#endif
     case isl_ast_op_and:
     case isl_ast_op_or:
     case isl_ast_op_eq:
@@ -1043,7 +1023,6 @@ translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,
       return translate_isl_ast_node_block (context_loop, node,
 					   next_e, ip);
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
     case isl_ast_node_mark:
       {
 	isl_ast_node *n = isl_ast_node_mark_get_node (node);
@@ -1051,7 +1030,6 @@ translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,
 	isl_ast_node_free (n);
 	return e;
       }
-#endif
 
     default:
       gcc_unreachable ();
@@ -2904,8 +2882,6 @@ ast_build_before_for (__isl_keep isl_ast_build *build, void *user)
   return id;
 }
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-
 /* Generate isl AST from schedule of SCOP.  */
 
 __isl_give isl_ast_node *translate_isl_ast_to_gimple::
@@ -2932,138 +2908,6 @@ scop_to_isl_ast (scop_p scop)
   return ast_isl;
 }
 
-#else
-/* Get the maximal number of schedule dimensions in the scop SCOP.  */
-
-int translate_isl_ast_to_gimple::
-get_max_schedule_dimensions (scop_p scop)
-{
-  int i;
-  poly_bb_p pbb;
-  int schedule_dims = 0;
-
-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)
-    {
-      int pbb_schedule_dims = isl_map_dim (pbb->transformed, isl_dim_out);
-      if (pbb_schedule_dims > schedule_dims)
-	schedule_dims = pbb_schedule_dims;
-    }
-
-  return schedule_dims;
-}
-
-/* Extend the schedule to NB_SCHEDULE_DIMS schedule dimensions.
-
-   For schedules with different dimensionality, the isl AST generator can not
-   define an order and will just randomly choose an order.  The solution to this
-   problem is to extend all schedules to the maximal number of schedule
-   dimensions (using '0's for the remaining values).  */
-
-__isl_give isl_map *translate_isl_ast_to_gimple::
-extend_schedule (__isl_take isl_map *schedule, int nb_schedule_dims)
-{
-  int tmp_dims = isl_map_dim (schedule, isl_dim_out);
-  schedule =
-    isl_map_add_dims (schedule, isl_dim_out, nb_schedule_dims - tmp_dims);
-  isl_val *zero =
-    isl_val_int_from_si (isl_map_get_ctx (schedule), 0);
-  int i;
-  for (i = tmp_dims; i < nb_schedule_dims; i++)
-    {
-      schedule
-	= isl_map_fix_val (schedule, isl_dim_out, i, isl_val_copy (zero));
-    }
-  isl_val_free (zero);
-  return schedule;
-}
-
-/* Generates a schedule, which specifies an order used to
-   visit elements in a domain.  */
-
-__isl_give isl_union_map *translate_isl_ast_to_gimple::
-generate_isl_schedule (scop_p scop)
-{
-  int nb_schedule_dims = get_max_schedule_dimensions (scop);
-  int i;
-  poly_bb_p pbb;
-  isl_union_map *schedule_isl =
-    isl_union_map_empty (isl_set_get_space (scop->param_context));
-
-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)
-    {
-      /* Dead code elimination: when the domain of a PBB is empty,
-	 don't generate code for the PBB.  */
-      if (isl_set_is_empty (pbb->domain))
-	continue;
-
-      isl_map *bb_schedule = isl_map_copy (pbb->transformed);
-      bb_schedule = isl_map_intersect_domain (bb_schedule,
-					      isl_set_copy (pbb->domain));
-      bb_schedule = extend_schedule (bb_schedule, nb_schedule_dims);
-      bb_schedule = isl_map_coalesce (bb_schedule);
-      schedule_isl
-	= isl_union_map_union (schedule_isl,
-			       isl_union_map_from_map (bb_schedule));
-      schedule_isl = isl_union_map_coalesce (schedule_isl);
-    }
-  return schedule_isl;
-}
-
-/* Set the separate option for all dimensions.
-   This helps to reduce control overhead.  */
-
-__isl_give isl_ast_build *translate_isl_ast_to_gimple::
-set_options (__isl_take isl_ast_build *control,
-	     __isl_keep isl_union_map *schedule)
-{
-  isl_ctx *ctx = isl_union_map_get_ctx (schedule);
-  isl_space *range_space = isl_space_set_alloc (ctx, 0, 1);
-  range_space =
-    isl_space_set_tuple_name (range_space, isl_dim_set, "separate");
-  isl_union_set *range =
-    isl_union_set_from_set (isl_set_universe (range_space));
-  isl_union_set *domain = isl_union_map_range (isl_union_map_copy (schedule));
-  domain = isl_union_set_universe (domain);
-  isl_union_map *options = isl_union_map_from_domain_and_range (domain, range);
-  return isl_ast_build_set_options (control, options);
-}
-
-/* Generate isl AST from schedule of SCOP.  Also, collects IVS_PARAMS in IP.  */
-
-__isl_give isl_ast_node *translate_isl_ast_to_gimple::
-scop_to_isl_ast (scop_p scop, ivs_params &ip)
-{
-  /* Generate loop upper bounds that consist of the current loop iterator, an
-     operator (< or <=) and an expression not involving the iterator.  If this
-     option is not set, then the current loop iterator may appear several times
-     in the upper bound.  See the isl manual for more details.  */
-  isl_options_set_ast_build_atomic_upper_bound (scop->isl_context, true);
-
-  add_parameters_to_ivs_params (scop, ip);
-  isl_union_map *schedule_isl = generate_isl_schedule (scop);
-  isl_ast_build *context_isl = generate_isl_context (scop);
-  context_isl = set_options (context_isl, schedule_isl);
-  if (flag_loop_parallelize_all)
-    {
-      isl_union_map *dependence = scop_get_dependences (scop);
-      context_isl =
-	isl_ast_build_set_before_each_for (context_isl, ast_build_before_for,
-					   dependence);
-    }
-
-  isl_ast_node *ast_isl = isl_ast_build_ast_from_schedule (context_isl,
-							   schedule_isl);
-  if (scop->schedule)
-    {
-      isl_schedule_free (scop->schedule);
-      scop->schedule = NULL;
-    }
-
-  isl_ast_build_free (context_isl);
-  return ast_isl;
-}
-#endif
-
 /* Copy def from sese REGION to the newly created TO_REGION. TR is defined by
    DEF_STMT. GSI points to entry basic block of the TO_REGION.  */
 
@@ -3142,16 +2986,11 @@ graphite_regenerate_ast_isl (scop_p scop)
   ivs_params ip;
 
   timevar_push (TV_GRAPHITE_CODE_GEN);
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   t.add_parameters_to_ivs_params (scop, ip);
   root_node = t.scop_to_isl_ast (scop);
-#else
-  root_node = t.scop_to_isl_ast (scop, ip);
-#endif
 
   if (dump_file && (dump_flags & TDF_DETAILS))
     {
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
       fprintf (dump_file, "[scheduler] original schedule:\n");
       print_isl_schedule (dump_file, scop->original_schedule);
       fprintf (dump_file, "[scheduler] isl transformed schedule:\n");
@@ -3159,7 +2998,6 @@ graphite_regenerate_ast_isl (scop_p scop)
 
       fprintf (dump_file, "[scheduler] original ast:\n");
       print_schedule_ast (dump_file, scop->original_schedule, scop);
-#endif
       fprintf (dump_file, "[scheduler] AST generated by isl:\n");
       print_isl_ast (dump_file, root_node);
     }
diff --git a/gcc/graphite-optimize-isl.c b/gcc/graphite-optimize-isl.c
index fd1638bee..75faeddc4 100644
--- a/gcc/graphite-optimize-isl.c
+++ b/gcc/graphite-optimize-isl.c
@@ -39,8 +39,6 @@ along with GCC; see the file COPYING3.  If not see
 #include "dumpfile.h"
 #include "graphite.h"
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-/* isl 0.15 or later.  */
 
 /* get_schedule_for_node_st - Improve schedule for the schedule node.
    Only Simple loop tiling is considered.  */
@@ -206,322 +204,4 @@ apply_poly_transforms (scop_p scop)
   return true;
 }
 
-#else
-
-/* get_tile_map - Create a map that describes a n-dimensonal tiling.
-
-   get_tile_map creates a map from a n-dimensional scattering space into an
-   2*n-dimensional scattering space. The map describes a rectangular tiling.
-
-   Example:
-     SCHEDULE_DIMENSIONS = 2, PARAMETER_DIMENSIONS = 1, TILE_SIZE = 32
-
-    tile_map := [p0] -> {[s0, s1] -> [t0, t1, s0, s1]:
-			 t0 % 32 = 0 and t0 <= s0 < t0 + 32 and
-			 t1 % 32 = 0 and t1 <= s1 < t1 + 32}
-
-   Before tiling:
-
-   for (i = 0; i < N; i++)
-     for (j = 0; j < M; j++)
-	S(i,j)
-
-   After tiling:
-
-   for (t_i = 0; t_i < N; i+=32)
-     for (t_j = 0; t_j < M; j+=32)
-	for (i = t_i; i < min(t_i + 32, N); i++)  | Unknown that N % 32 = 0
-	  for (j = t_j; j < t_j + 32; j++)        |   Known that M % 32 = 0
-	    S(i,j)
-  */
-
-static isl_basic_map *
-get_tile_map (isl_ctx *ctx, int schedule_dimensions, int tile_size)
-{
-  /* We construct
-
-     tile_map := [p0] -> {[s0, s1] -> [t0, t1, p0, p1, a0, a1]:
-			s0 = a0 * 32 and s0 = p0 and t0 <= p0 < t0 + 32 and
-			s1 = a1 * 32 and s1 = p1 and t1 <= p1 < t1 + 32}
-
-     and project out the auxilary dimensions a0 and a1.  */
-  isl_space *space
-    = isl_space_alloc (ctx, 0, schedule_dimensions, schedule_dimensions * 3);
-  isl_basic_map *tile_map = isl_basic_map_universe (isl_space_copy (space));
-
-  isl_local_space *local_space = isl_local_space_from_space (space);
-
-  for (int x = 0; x < schedule_dimensions; x++)
-    {
-      int sX = x;
-      int tX = x;
-      int pX = schedule_dimensions + x;
-      int aX = 2 * schedule_dimensions + x;
-
-      isl_constraint *c;
-
-      /* sX = aX * tile_size; */
-      c = isl_equality_alloc (isl_local_space_copy (local_space));
-      isl_constraint_set_coefficient_si (c, isl_dim_out, sX, 1);
-      isl_constraint_set_coefficient_si (c, isl_dim_out, aX, -tile_size);
-      tile_map = isl_basic_map_add_constraint (tile_map, c);
-
-      /* pX = sX; */
-      c = isl_equality_alloc (isl_local_space_copy (local_space));
-      isl_constraint_set_coefficient_si (c, isl_dim_out, pX, 1);
-      isl_constraint_set_coefficient_si (c, isl_dim_in, sX, -1);
-      tile_map = isl_basic_map_add_constraint (tile_map, c);
-
-      /* tX <= pX */
-      c = isl_inequality_alloc (isl_local_space_copy (local_space));
-      isl_constraint_set_coefficient_si (c, isl_dim_out, pX, 1);
-      isl_constraint_set_coefficient_si (c, isl_dim_out, tX, -1);
-      tile_map = isl_basic_map_add_constraint (tile_map, c);
-
-      /* pX <= tX + (tile_size - 1) */
-      c = isl_inequality_alloc (isl_local_space_copy (local_space));
-      isl_constraint_set_coefficient_si (c, isl_dim_out, tX, 1);
-      isl_constraint_set_coefficient_si (c, isl_dim_out, pX, -1);
-      isl_constraint_set_constant_si (c, tile_size - 1);
-      tile_map = isl_basic_map_add_constraint (tile_map, c);
-    }
-
-  /* Project out auxiliary dimensions.
-
-     The auxiliary dimensions are transformed into existentially quantified
-     ones.
-     This reduces the number of visible scattering dimensions and allows isl
-     to produces better code.  */
-  tile_map =
-      isl_basic_map_project_out (tile_map, isl_dim_out,
-				 2 * schedule_dimensions, schedule_dimensions);
-  isl_local_space_free (local_space);
-  return tile_map;
-}
-
-/* get_schedule_for_band - Get the schedule for this BAND.
-
-   Polly applies transformations like tiling on top of the isl calculated
-   value.
-   This can influence the number of scheduling dimension. The number of
-   schedule dimensions is returned in DIMENSIONS.  */
-
-static isl_union_map *
-get_schedule_for_band (isl_band *band, int *dimensions)
-{
-  isl_union_map *partial_schedule;
-  isl_ctx *ctx;
-  isl_space *space;
-  isl_basic_map *tile_map;
-  isl_union_map *tile_umap;
-
-  partial_schedule = isl_band_get_partial_schedule (band);
-  *dimensions = isl_band_n_member (band);
-
-  /* It does not make any sense to tile a band with just one dimension.  */
-  if (*dimensions == 1)
-    {
-      if (dump_file && dump_flags)
-	fprintf (dump_file, "not tiled\n");
-      return partial_schedule;
-    }
-
-  if (dump_file && dump_flags)
-    fprintf (dump_file, "tiled by %d\n",
-	     PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));
-
-  ctx = isl_union_map_get_ctx (partial_schedule);
-  space = isl_union_map_get_space (partial_schedule);
-
-  tile_map = get_tile_map (ctx, *dimensions,
-			   PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));
-  tile_umap = isl_union_map_from_map (isl_map_from_basic_map (tile_map));
-  tile_umap = isl_union_map_align_params (tile_umap, space);
-  tile_umap = isl_union_map_coalesce (tile_umap);
-  *dimensions = 2 * *dimensions;
-
-  return isl_union_map_apply_range (partial_schedule, tile_umap);
-}
-
-
-/* get_schedule_for_band_list - Get the scheduling map for a list of bands.
-
-   We walk recursively the forest of bands to combine the schedules of the
-   individual bands to the overall schedule.  In case tiling is requested,
-   the individual bands are tiled.  */
-
-static isl_union_map *
-get_schedule_for_band_list (isl_band_list *band_list)
-{
-  int num_bands, i;
-  isl_union_map *schedule;
-  isl_ctx *ctx;
-
-  ctx = isl_band_list_get_ctx (band_list);
-  num_bands = isl_band_list_n_band (band_list);
-  schedule = isl_union_map_empty (isl_space_params_alloc (ctx, 0));
-
-  for (i = 0; i < num_bands; i++)
-    {
-      isl_band *band;
-      isl_union_map *partial_schedule;
-      int schedule_dimensions;
-      isl_space *space;
-
-      band = isl_band_list_get_band (band_list, i);
-      partial_schedule = get_schedule_for_band (band, &schedule_dimensions);
-      space = isl_union_map_get_space (partial_schedule);
-
-      if (isl_band_has_children (band))
-	{
-	  isl_band_list *children = isl_band_get_children (band);
-	  isl_union_map *suffixSchedule
-	    = get_schedule_for_band_list (children);
-	  partial_schedule
-	    = isl_union_map_flat_range_product (partial_schedule,
-						suffixSchedule);
-	  isl_band_list_free (children);
-	}
-
-      schedule = isl_union_map_union (schedule, partial_schedule);
-
-      isl_band_free (band);
-      isl_space_free (space);
-    }
-
-  return isl_union_map_coalesce (schedule);
-}
-
-static isl_union_map *
-get_schedule_map (isl_schedule *schedule)
-{
-  isl_band_list *band_list = isl_schedule_get_band_forest (schedule);
-  isl_union_map *schedule_map = get_schedule_for_band_list (band_list);
-  isl_band_list_free (band_list);
-  return schedule_map;
-}
-
-static isl_stat
-get_single_map (__isl_take isl_map *map, void *user)
-{
-  isl_map **single_map = (isl_map **)user;
-  *single_map = map;
-  return isl_stat_ok;
-}
-
-static void
-apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map)
-{
-  int i;
-  poly_bb_p pbb;
-
-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)
-    {
-      isl_set *domain = isl_set_copy (pbb->domain);
-      isl_map *stmt_schedule;
-
-      isl_union_map *stmt_band
-	= isl_union_map_intersect_domain (isl_union_map_copy (schedule_map),
-					  isl_union_set_from_set (domain));
-      stmt_band = isl_union_map_coalesce (stmt_band);
-      isl_union_map_foreach_map (stmt_band, get_single_map, &stmt_schedule);
-      isl_map_free (pbb->transformed);
-      pbb->transformed = isl_map_coalesce (stmt_schedule);
-      isl_union_map_free (stmt_band);
-    }
-}
-
-static isl_union_set *
-scop_get_domains (scop_p scop)
-{
-  int i;
-  poly_bb_p pbb;
-  isl_space *space = isl_set_get_space (scop->param_context);
-  isl_union_set *res = isl_union_set_empty (space);
-
-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)
-    res = isl_union_set_add_set (res, isl_set_copy (pbb->domain));
-
-  return res;
-}
-
-/* Compute the schedule for SCOP based on its parameters, domain and set of
-   constraints.  Then apply the schedule to SCOP.  */
-
-static bool
-optimize_isl (scop_p scop)
-{
-  int old_max_operations = isl_ctx_get_max_operations (scop->isl_context);
-  int max_operations = PARAM_VALUE (PARAM_MAX_ISL_OPERATIONS);
-  if (max_operations)
-    isl_ctx_set_max_operations (scop->isl_context, max_operations);
-  isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_CONTINUE);
-
-  isl_union_set *domain = scop_get_domains (scop);
-  scop_get_dependences (scop);
-  scop->dependence
-    = isl_union_map_gist_domain (scop->dependence, isl_union_set_copy (domain));
-  scop->dependence
-    = isl_union_map_gist_range (scop->dependence, isl_union_set_copy (domain));
-  isl_union_map *validity = isl_union_map_copy (scop->dependence);
-  isl_union_map *proximity = isl_union_map_copy (validity);
-
-  isl_options_set_schedule_fuse (scop->isl_context, ISL_SCHEDULE_FUSE_MIN);
-  isl_schedule *schedule
-    = isl_union_set_compute_schedule (domain, validity, proximity);
-
-  isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_ABORT);
-
-  isl_ctx_reset_operations (scop->isl_context);
-  isl_ctx_set_max_operations (scop->isl_context, old_max_operations);
-  if (!schedule || isl_ctx_last_error (scop->isl_context) == isl_error_quota)
-    {
-      if (dump_file && dump_flags)
-	{
-	  if (!schedule)
-	    fprintf (dump_file, "isl did not return any schedule.\n");
-	  else
-	    fprintf (dump_file, "isl timed out --param max-isl-operations=%d\n",
-		     max_operations);
-	}
-
-      if (schedule)
-	isl_schedule_free (schedule);
-      return false;
-    }
-
-  scop->schedule = schedule;
-
-  isl_union_map *schedule_map = get_schedule_map (schedule);
-  apply_schedule_map_to_scop (scop, schedule_map);
-  isl_union_map_free (schedule_map);
-
-  if (dump_file)
-    {
-      fprintf (dump_file, "isl end schedule:\n");
-      print_isl_schedule (dump_file, scop->schedule);
-    }
-
-  return true;
-}
-
-/* Apply graphite transformations to all the basic blocks of SCOP.  */
-
-bool
-apply_poly_transforms (scop_p scop)
-{
-  if (flag_loop_nest_optimize)
-    return optimize_isl (scop);
-
-  if (!flag_graphite_identity && !flag_loop_parallelize_all)
-    return false;
-
-  /* Generate code even if we did not apply any real transformation.
-     This also allows to check the performance for the identity
-     transformation: GIMPLE -> GRAPHITE -> GIMPLE.  */
-  return true;
-}
-
-#endif /* HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS */
-
 #endif /* HAVE_isl */
diff --git a/gcc/graphite-poly.c b/gcc/graphite-poly.c
index 4c3f55027..4fb138c19 100644
--- a/gcc/graphite-poly.c
+++ b/gcc/graphite-poly.c
@@ -136,13 +136,7 @@ new_poly_bb (scop_p scop, gimple_poly_bb_p black_box)
   poly_bb_p pbb = XNEW (struct poly_bb);
 
   pbb->domain = NULL;
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   pbb->iterators = NULL;
-#else
-  pbb->schedule = NULL;
-  pbb->transformed = NULL;
-  pbb->saved = NULL;
-#endif
   PBB_SCOP (pbb) = scop;
   pbb_set_black_box (pbb, black_box);
   PBB_DRS (pbb).create (3);
@@ -161,17 +155,8 @@ free_poly_bb (poly_bb_p pbb)
 
   isl_set_free (pbb->domain);
   pbb->domain = NULL;
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   isl_set_free (pbb->iterators);
   pbb->iterators = NULL;
-#else
-  isl_map_free (pbb->schedule);
-  pbb->schedule = NULL;
-  isl_map_free (pbb->transformed);
-  pbb->transformed = NULL;
-  isl_map_free (pbb->saved);
-  pbb->saved = NULL;
-#endif
 
   if (PBB_DRS (pbb).exists ())
     FOR_EACH_VEC_ELT (PBB_DRS (pbb), i, pdr)
@@ -273,12 +258,8 @@ new_scop (edge entry, edge exit)
   sese_info_p region = new_sese_info (entry, exit);
   scop_p s = XNEW (struct scop);
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   s->original_schedule = NULL;
   s->transformed_schedule = NULL;
-#else
-  s->schedule = NULL;
-#endif
   s->param_context = NULL;
   scop_set_region (s, region);
   s->pbbs.create (3);
@@ -308,14 +289,10 @@ free_scop (scop_p scop)
   scop->param_context = NULL;
   isl_union_map_free (scop->dependence);
   scop->dependence = NULL;
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   isl_schedule_free (scop->original_schedule);
   scop->original_schedule = NULL;
   isl_schedule_free (scop->transformed_schedule);
   scop->transformed_schedule = NULL;
-#else
-
-#endif
   XDELETE (scop);
 }
 
@@ -543,9 +520,7 @@ void
 print_isl_set (FILE *f, __isl_keep isl_set *set)
 {
   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);
-#endif
   p = isl_printer_print_set (p, set);
   p = isl_printer_print_str (p, "\n");
   isl_printer_free (p);
@@ -561,9 +536,7 @@ void
 print_isl_map (FILE *f, __isl_keep isl_map *map)
 {
   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);
-#endif
   p = isl_printer_print_map (p, map);
   p = isl_printer_print_str (p, "\n");
   isl_printer_free (p);
@@ -579,9 +552,7 @@ void
 print_isl_union_map (FILE *f, __isl_keep isl_union_map *map)
 {
   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);
-#endif
   p = isl_printer_print_union_map (p, map);
   p = isl_printer_print_str (p, "\n");
   isl_printer_free (p);
@@ -627,9 +598,7 @@ void
 print_isl_schedule (FILE *f, __isl_keep isl_schedule *s)
 {
   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);
-#endif
   p = isl_printer_print_schedule (p, s);
   p = isl_printer_print_str (p, "\n");
   isl_printer_free (p);
diff --git a/gcc/graphite-sese-to-poly.c b/gcc/graphite-sese-to-poly.c
index 163eef41f..5e5668f3c 100644
--- a/gcc/graphite-sese-to-poly.c
+++ b/gcc/graphite-sese-to-poly.c
@@ -77,153 +77,6 @@ isl_id_for_pbb (scop_p s, poly_bb_p pbb)
   return isl_id_alloc (s->isl_context, name, pbb);
 }
 
-#ifndef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-/* Converts the STATIC_SCHEDULE of PBB into a scattering polyhedron.
-   We generate SCATTERING_DIMENSIONS scattering dimensions.
-
-   The scattering polyhedron consists of these dimensions: scattering,
-   loop_iterators, parameters.
-
-   Example:
-
-   | scattering_dimensions = 5
-   | nb_iterators = 1
-   | scop_nb_params = 2
-   |
-   | Schedule:
-   |   i
-   | 4 5
-   |
-   | Scattering polyhedron:
-   |
-   | scattering: {s1, s2, s3, s4, s5}
-   | loop_iterators: {i}
-   | parameters: {p1, p2}
-   |
-   | s1  s2  s3  s4  s5  i   p1  p2  1
-   | 1   0   0   0   0   0   0   0  -4  = 0
-   | 0   1   0   0   0  -1   0   0   0  = 0
-   | 0   0   1   0   0   0   0   0  -5  = 0  */
-
-static void
-build_pbb_scattering_polyhedrons (isl_aff *static_sched,
-				  poly_bb_p pbb)
-{
-  isl_val *val;
-
-  int scattering_dimensions = isl_set_dim (pbb->domain, isl_dim_set) * 2 + 1;
-
-  isl_space *dc = isl_set_get_space (pbb->domain);
-  isl_space *dm = isl_space_add_dims (isl_space_from_domain (dc),
-				      isl_dim_out, scattering_dimensions);
-  pbb->schedule = isl_map_universe (dm);
-
-  for (int i = 0; i < scattering_dimensions; i++)
-    {
-      /* Textual order inside this loop.  */
-      if ((i % 2) == 0)
-	{
-	  isl_constraint *c = isl_equality_alloc
-	      (isl_local_space_from_space (isl_map_get_space (pbb->schedule)));
-
-	  val = isl_aff_get_coefficient_val (static_sched, isl_dim_in, i / 2);
-	  gcc_assert (val && isl_val_is_int (val));
-
-	  val = isl_val_neg (val);
-	  c = isl_constraint_set_constant_val (c, val);
-	  c = isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);
-	  pbb->schedule = isl_map_add_constraint (pbb->schedule, c);
-	}
-
-      /* Iterations of this loop.  */
-      else /* if ((i % 2) == 1) */
-	{
-	  int loop = (i - 1) / 2;
-	  pbb->schedule = isl_map_equate (pbb->schedule, isl_dim_in, loop,
-					  isl_dim_out, i);
-	}
-    }
-
-  /* Simplify the original schedule.  */
-  pbb->schedule = isl_map_coalesce (pbb->schedule);
-
-  /* At the beginning, set the transformed schedule to the original.  */
-  pbb->transformed = isl_map_copy (pbb->schedule);
-}
-
-/* Build for BB the static schedule.
-
-   The static schedule is a Dewey numbering of the abstract syntax
-   tree: http://en.wikipedia.org/wiki/Dewey_Decimal_Classification
-
-   The following example informally defines the static schedule:
-
-   A
-   for (i: ...)
-     {
-       for (j: ...)
-         {
-           B
-           C
-         }
-
-       for (k: ...)
-         {
-           D
-           E
-         }
-     }
-   F
-
-   Static schedules for A to F:
-
-     DEPTH
-     0 1 2
-   A 0
-   B 1 0 0
-   C 1 0 1
-   D 1 1 0
-   E 1 1 1
-   F 2
-*/
-
-static void
-build_scop_scattering (scop_p scop)
-{
-  gimple_poly_bb_p previous_gbb = NULL;
-  isl_space *dc = isl_set_get_space (scop->param_context);
-  isl_aff *static_sched;
-
-  dc = isl_space_add_dims (dc, isl_dim_set, number_of_loops (cfun));
-  static_sched = isl_aff_zero_on_domain (isl_local_space_from_space (dc));
-
-  /* We have to start schedules at 0 on the first component and
-     because we cannot compare_prefix_loops against a previous loop,
-     prefix will be equal to zero, and that index will be
-     incremented before copying.  */
-  static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in, 0, -1);
-
-  int i;
-  poly_bb_p pbb;
-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)
-    {
-      gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);
-      int prefix = 0;
-
-      if (previous_gbb)
-	prefix = nb_common_loops (scop->scop_info->region, previous_gbb, gbb);
-
-      previous_gbb = gbb;
-
-      static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in,
-						 prefix, 1);
-      build_pbb_scattering_polyhedrons (static_sched, pbb);
-    }
-
-  isl_aff_free (static_sched);
-}
-#endif
-
 static isl_pw_aff *extract_affine (scop_p, tree, __isl_take isl_space *space);
 
 /* Extract an affine expression from the chain of recurrence E.  */
@@ -1009,9 +862,7 @@ build_iteration_domains (scop_p scop, __isl_keep isl_set *context,
       loop_p loop = pbb_loop (pbb);
       if (current == loop)
 	{
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
 	  pbb->iterators = isl_set_copy (domain);
-#endif
 	  pbb->domain = isl_set_copy (domain);
 	  pbb->domain = isl_set_set_tuple_id (pbb->domain,
 					      isl_id_for_pbb (scop, pbb));
@@ -1069,8 +920,6 @@ build_scop_context (scop_p scop)
     add_param_constraints (scop, p);
 }
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-
 /* Return true when loop A is nested in loop B.  */
 
 static bool
@@ -1350,8 +1199,6 @@ build_original_schedule (scop_p scop)
   return true;
 }
 
-#endif
-
 /* Builds the polyhedral representation for a SESE region.  */
 
 bool
@@ -1365,11 +1212,7 @@ build_poly_scop (scop_p scop)
     i = build_iteration_domains (scop, scop->param_context, i, NULL);
 
   build_scop_drs (scop);
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   build_original_schedule (scop);
-#else
-  build_scop_scattering (scop);
-#endif
   return true;
 }
 #endif  /* HAVE_isl */
diff --git a/gcc/graphite.h b/gcc/graphite.h
index 431d0ed0a..c9abdea84 100644
--- a/gcc/graphite.h
+++ b/gcc/graphite.h
@@ -37,18 +37,10 @@ along with GCC; see the file COPYING3.  If not see
 #include <isl/schedule.h>
 #include <isl/ast_build.h>
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-/* isl 0.15 or later.  */
 #include <isl/schedule_node.h>
 #include <isl/id.h>
 #include <isl/space.h>
 
-#else
-/* isl 0.14 or 0.13.  */
-# define isl_stat int
-# define isl_stat_ok 0
-#endif
-
 typedef struct poly_dr *poly_dr_p;
 
 typedef struct poly_bb *poly_bb_p;
@@ -269,18 +261,7 @@ struct poly_bb
      The number of variables in the DOMAIN may change and is not
      related to the number of loops in the original code.  */
   isl_set *domain;
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   isl_set *iterators;
-#else
-  /* The original scattering.  */
-  isl_map *schedule;
-
-  /* The transformed scattering.  */
-  isl_map *transformed;
-
-  /* A copy of the transformed scattering.  */
-  isl_map *saved;
-#endif
 
   /* The data references we access.  */
   vec<poly_dr_p> drs;
@@ -427,16 +408,11 @@ struct scop
   /* The context used internally by isl.  */
   isl_ctx *isl_context;
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
   /* SCoP original schedule.  */
   isl_schedule *original_schedule;
 
   /* SCoP transformed schedule.  */
   isl_schedule *transformed_schedule;
-#else
-  /* SCoP final schedule.  */
-  isl_schedule *schedule;
-#endif
 
   /* The data dependence relation among the data references in this scop.  */
   isl_union_map *dependence;
@@ -472,11 +448,7 @@ scop_set_nb_params (scop_p scop, graphite_dim_t nb_params)
   scop->nb_params = nb_params;
 }
 
-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
 extern void scop_get_dependences (scop_p scop);
-#else
-extern isl_union_map *scop_get_dependences (scop_p scop);
-#endif
 
 bool
 carries_deps (__isl_keep isl_union_map *schedule,
diff --git a/gcc/toplev.c b/gcc/toplev.c
index d6f6c74ff..2178c3219 100644
--- a/gcc/toplev.c
+++ b/gcc/toplev.c
@@ -87,6 +87,10 @@ along with GCC; see the file COPYING3.  If not see
 #include "xcoffout.h"		/* Needed for external data declarations. */
 #endif
 
+#ifdef HAVE_isl
+#include <isl/version.h>
+#endif
+
 static void general_init (const char *, bool);
 static void do_compile ();
 static void process_options (void);
@@ -678,10 +682,8 @@ print_version (FILE *file, const char *indent, bool show_global_state)
 	   GCC_GMP_STRINGIFY_VERSION, MPFR_VERSION_STRING, MPC_VERSION_STRING,
 #ifndef HAVE_isl
 	   "none"
-#elif HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS
-	   "0.15"
 #else
-	   "0.14 or 0.13"
+	   isl_version ()
 #endif
 	   );
   if (strcmp (GCC_GMP_STRINGIFY_VERSION, gmp_version))
