diff --git a/gcc/cfgloopmanip.c b/gcc/cfgloopmanip.c
index 267eb8f18..dee09dd7f 100644
--- a/gcc/cfgloopmanip.c
+++ b/gcc/cfgloopmanip.c
@@ -306,10 +306,12 @@ remove_path (edge e)
      we belong to.  In this case first unloop the loops, then proceed
      normally.   We may assume that e->dest is not a header of any loop,
      as it now has exactly one predecessor.  */
-  while (loop_outer (e->src->loop_father)
-	 && dominated_by_p (CDI_DOMINATORS,
-			    e->src->loop_father->latch, e->dest))
-    unloop (e->src->loop_father, &irred_invalidated);
+  for (l = e->src->loop_father; loop_outer (l); l = f)
+    {
+      f = loop_outer (l);
+      if (dominated_by_p (CDI_DOMINATORS, l->latch, e->dest))
+        unloop (l, &irred_invalidated);
+    }
 
   /* Identify the path.  */
   nrem = find_path (e, &rem_bbs);
@@ -414,6 +416,7 @@ add_loop (struct loop *loop, struct loop *outer)
   struct loop *subloop;
   edge e;
   edge_iterator ei;
+  struct loop *l, *f;
 
   /* Add it to loop structure.  */
   place_new_loop (loop);
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr49710.c b/gcc/testsuite/gcc.c-torture/compile/pr49710.c
new file mode 100644
index 000000000..2a6e331db
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr49710.c
@@ -0,0 +1,35 @@
+int a, b, c, d;
+
+static void
+foo (int *x)
+{
+  c = 0;
+  while (1)
+    {
+      if (*x)
+break;
+      while (b)
+for (; c; c = 0);
+      for (d = 18; d != 18; d++)
+if (c)
+  {
+    foo (x);
+    return;
+  }
+    }
+}
+
+static void
+bar ()
+{
+  foo (0);
+  foo (0);
+  for (;;)
+    ;
+}
+
+baz ()
+{
+  for (; a;)
+    bar ();
+}
