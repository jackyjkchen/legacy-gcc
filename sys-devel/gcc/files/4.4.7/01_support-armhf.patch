diff --git a/ChangeLog.linaro b/ChangeLog.linaro
new file mode 100644
index 000000000..417878709
--- /dev/null
+++ b/ChangeLog.linaro
@@ -0,0 +1,8691 @@
+2011-02-04  Andrew Stubbs  <ams@codesourcery.com>
+
+	GCC Linaro 4.4-2011.02-0 released.
+
+	gcc/
+	* LINARO-VERSION: Update.
+
+2011-01-28  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>
+
+	LP: #709329
+	Backport from FSF trunk
+	2010-07-03  Jie Zhang  <jie@codesourcery.com>
+
+	* config/arm/arm.c (arm_attr_length_move_neon): New.
+	* config/arm/arm-protos.h (arm_attr_length_move_neon): Declare.
+	* config/arm/neon.md (define_mode_attr V_slen): Remove.
+	(neon_mov<mode> for VSTRUCT): Use arm_attr_length_move_neon
+	to compute length attribute.
+
+2011-01-07  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* LINARO-VERSION: Bump version.
+
+2011-01-07  Andrew Stubbs  <ams@codesourcery.com>
+
+	GCC Linaro 4.4-2011.01-0 released.
+
+	gcc/
+	* LINARO-VERSION: Update.
+
+2010-12-21  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	LP: #617384
+	Backport from mainline:
+
+	* config/arm/arm.c (require_pic_register): Set INSN_LOCATOR for all
+	instructions injected into the prologue to prologue_locator.
+
+2010-12-10  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* REVISION: Bump version.
+
+2010-12-10  Andrew Stubbs  <ams@codesourcery.com>
+
+	GCC Linaro 4.4-2010.12-0 released.
+
+	gcc/
+	* REVISION: Update.
+
+2010-12-03  Julian Brown  <julian@codesourcery.com>
+
+	Fix lp629671
+
+	gcc/
+	* config/arm/arm.h (REG_CLASS_CONTENTS): Remove soft frame pointer
+	from CORE_REGS and GENERAL_REGS classes.
+	* config/arm/arm.md (*thumb1_movsi_insn): Ignore all parts of final
+	constraint for register preferencing.
+
+2010-10-12  Michael Hope  <michael.hope@linaro.org>
+
+	gcc/
+	* REVISION: Bump version.
+
+2010-10-12  Michael Hope  <michael.hope@linaro.org>
+
+	GCC Linaro 4.4-2010.10-0 released.
+
+	gcc/
+	* REVISION: Update.
+
+2010-10-04  Michael Hope  <michael.hope@linaro.org>
+
+	Merged gcc_4_4_5_release from upstream (r164870)
+
+2010-09-30  Yao Qi  <yao@codesourcery.com>
+
+	Fix LP:#647597
+	gcc/
+	* c-common.c (fname_decl): Update decl's source location.
+
+2010-09-24  Yao Qi  <yao@codesourcery.com>
+
+	Backport from FSF to fix ICE found in LP:635409:
+	     
+	2010-07-07  Bernd Schmidt  <bernds@codesourcery.com>
+	
+	gcc/ 
+	PR rtl-optimization/44787
+	* config/arm/arm.md (arith_shiftsi): Allow stack pointer in operand 2.
+	* config/arm/thumb2.md (thumb2_arith_shiftsi): Likewise.
+	
+2010-09-10  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* REVISION: Bump version.
+
+2010-09-10  Andrew Stubbs  <ams@codesourcery.com>
+
+	GCC Linaro 4.4-2010.09-1 released.
+
+	gcc/
+	* REVISION: Update.
+
+2010-09-10  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	Backport from mainline:
+	2010-09-09  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR middle-end/45312
+	* reload1.c (merge_assigned_reloads): Remove.
+	(reload_as_needed): Don't call it.
+
+2010-09-10  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+        * REVISION: Bump version.
+
+2010-09-10  Andrew Stubbs  <ams@codesourcery.com>
+
+	GCC Linaro 4.4-2010.09-0 released.
+
+	gcc/
+	* REVISION: Update.
+
+2010-08-07  Andrew Stubbs  <ams@codesourcery.com>
+
+	Merge from FSF GCC 4.4 branch (pre 4.4.5).
+
+2010-08-06  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* REVISION: Bump version.
+
+2010-08-06  Andrew Stubbs  <ams@codesourcery.com>
+
+	GCC Linaro 4.4-2010.08-0 released.
+
+	gcc/
+	* REVISION: Update.
+
+2010-08-06  Yao Qi  <yao@codesourcery.com>
+
+	LP: #602285
+	gcc/testsuite
+	* gcc.dg/tree-ssa/predcom-3.c: Append param max-unroll-times=3
+	in dg-options to fix test failure.
+	* gcc.dg/tree-ssa/predcom-4.c: Likewise.
+	* gcc.dg/tree-ssa/predcom-5.c: Likewise.
+
+2010-08-03  Michael Hope  <michael.hope@linaro.org>
+
+	LP: #605080
+	* libjava/classpath/lib/gnu/javax/print/ipp/IppPrintService.class: Re-generated
+	after updating the corresponding .java file
+	* libjava/classpath/lib/gnu/javax/print/ipp/IppRequest$RequestWriter.class: Likewise
+	* libjava/classpath/lib/gnu/javax/print/ipp/IppRequest.class: Likewise
+	* libjava/classpath/lib/gnu/javax/print/ipp/IppResponse$ResponseReader.class: Likewise
+	* libjava/classpath/lib/gnu/javax/print/ipp/IppResponse.class: Likewise
+	* libjava/classpath/lib/java/util/concurrent/CopyOnWriteArrayList$1.class: Likewise
+	* libjava/classpath/lib/java/util/concurrent/CopyOnWriteArrayList$2.class: Likewise
+	* libjava/classpath/lib/java/util/concurrent/CopyOnWriteArrayList$3.class: Likewise
+	* libjava/classpath/lib/java/util/concurrent/CopyOnWriteArrayList$RandomAccessSubList.class: Likewise
+	* libjava/classpath/lib/java/util/concurrent/CopyOnWriteArrayList$SubList.class: Likewise
+	* libjava/classpath/lib/java/util/concurrent/CopyOnWriteArrayList.class: Likewise
+
+2010-08-02  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	LP: #500524
+
+	Backport from mainline:
+	2010-04-03  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/42509
+	* alias.c (nonoverlapping_memrefs_p): For spill-slot accesses
+	require a non-NULL MEM_OFFSET.
+
+2010-07-30  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	LP: #604874
+	Backport from mainline:
+
+	gcc/cp/
+	PR c++/45112
+	* decl.c (duplicate_decls): Merge DECL_USER_ALIGN and DECL_PACKED.
+
+	gcc/testsuite/
+	PR c++/45112
+	* testsuite/g++.dg/pr45112.C: New test.
+
+2010-08-06  Yao Qi  <yao@codesourcery.com>
+
+	LP: #612011
+	gcc/
+	* config/arm/arm.c (output_move_double): Fix typo generating 
+	instructions ('ldr'->'str').
+
+	gcc/testsuite/
+	* gcc.target/arm/pr45094.c: New test.
+
+2010-08-05  Yao Qi  <yao@codesourcery.com>
+
+	gcc/testsuite
+	* g++.dg/eh/ref1.C:  Change ARM triplet to a more
+	general form.
+	* g++.dg/eh/ref2.C: Likewise.
+	* g++.dg/ext/packed8.C: Likewise.
+	* g++.dg/init/array16.C: Likewise.
+	* g++.dg/other/crash-4.C: Likewise.
+	* g++.dg/other/packed1.C: Likewise.
+	* gcc.dg/builtin-stringop-chk-1.c: Likewise.
+	* gcc.dg/tree-ssa/loop-31.c: Likewise.
+
+2010-08-04  Yao Qi  <yao@codesourcery.com>
+
+	LP: #612406
+	gcc/testsuite
+	* gcc.c-torture/execute/bcp-1.x: Change ARM triplet to
+	 a more general form.
+
+2010-08-03  Yao Qi  <yao@codesourcery.com>
+
+	LP: #612405
+	gcc/testsuite
+	* gcc.c-torture/execute/990208-1.x: Change ARM triplet to
+	a more general form.
+
+2010-08-03  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	Backport from mainline for Launchpad Bug #602745:
+
+	2010-07-28  Chung-Lin Tang  <cltang@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (arm_pcs_default): Remove static.	
+	* config/arm/arm.h (TARGET_CPU_CPP_BUILTINS): Define __ARM_PCS or
+	__ARM_PCS_VFP to indicate soft/hard-float calling convention.
+	(arm_pcs_default): Declare.
+
+2010-07-23  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	Revert most PowerPC-related patches:
+
+	2010-05-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Issue #8729
+
+	Integrate <http://gcc.gnu.org/ml/gcc-patches/2010-03/msg01451.html>.
+	Drop the TARGET_TITAN_FPU and fsqrt changes.
+
+	XXXX-XX-XX  Philipp Tomsich  <philipp.tomsich@theobroma-systems.com>
+
+	NOT ASSIGNED TO FSF
+	COPYRIGHT Philipp Tomsich (Theobroma Systems Design und Consulting GmbH)
+
+	gcc/
+	* config.gcc: Recognize titan.
+	* config/rs6000/rs6000.c (titan_cost): New.
+	(rs6000_override_options, rs6000_issue_rate): Handle titan.
+	* config/rs6000/rs6000.h (processor_type): Register titan.
+	* config/rs6000/rs6000.md (cpu): Register titan.
+	Include "titan.md".
+	* config/rs6000/titan.md: New.
+	* doc/invoke.texi <mcpu>: Document titan.
+
+	2010-04-20  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgcc/
+	* config/rs6000/t-spe-fprules (spe-softfp-srcs): Don't add
+	$(gcc_srcdir)/config/soft-fp as a prefix.
+	(LIB2ADD): Use patterns with the source filenames as the filter.
+
+	2010-04-15  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgcc/
+	* config/rs6000/divdf3.S (__divdf3): Use JUMP_TARGET instead of L.
+	* config/rs6000/muldf3.S (__muldf3): Likewise.
+
+	2010-04-15  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgcc/
+	* config/rs6000/spe_muldiv_scale2.S (__spe_return_inf_mul_div):
+	New function.
+	* config/rs6000/divdf3.S (__divdf3): Call it.
+	* config/rs6000/muldf3.S (__muldf3): Likewise.
+
+	2010-04-15  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgcc/
+	* config/rs6000/spe_add_exception.S: Remove .file directive.
+	* config/rs6000/spe_adddf3.S: Likewise.
+	* config/rs6000/spe_cmpdf2.S: Likewise.
+	* config/rs6000/spe_divdf3.S: Likewise.
+	* config/rs6000/spe_eqdf2.S: Likewise.
+	* config/rs6000/spe_extendsfdf2.S: Likewise.
+	* config/rs6000/spe_fixdfdi.S: Likewise.
+	* config/rs6000/spe_fixdfsi.S: Likewise.
+	* config/rs6000/spe_fixunsdfdi.S: Likewise.
+	* config/rs6000/spe_fixunsdfsi.S: Likewise.
+	* config/rs6000/spe_floatdidf.S: Likewise.
+	* config/rs6000/spe_floatsidf.S: Likewise.
+	* config/rs6000/spe_floatundidf.S: Likewise.
+	* config/rs6000/spe_floatunsidf.S: Likewise.
+	* config/rs6000/spe_gedf2.S: Likewise.
+	* config/rs6000/spe_gtdf2.S: Likewise.
+	* config/rs6000/spe_ledf2.S: Likewise.
+	* config/rs6000/spe_ltdf2.S: Likewise.
+	* config/rs6000/spe_muldf3.S: Likewise.
+	* config/rs6000/spe_muldiv_scale2.S: Likewise.
+	* config/rs6000/spe_nedf2.S: Likewise.
+	* config/rs6000/spe_neg.S: Likewise.
+	* config/rs6000/spe_subdf3.S: Likewise.
+	* config/rs6000/spe_truncdfsf2.S: Likewise.
+	* config/rs6000/spe_unord_sub.S: Likewise.
+	* config/rs6000/spe_unorddf2.S: Likewise.
+
+	2010-04-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgcc/
+	* config/rs6000/spe_arith.S: Remove.  Split into:
+	* config/rs6000/spe_adddf3.S: ...this.
+	* config/rs6000/spe_subdf3.S: ...this.
+	* config/rs6000/spe_muldf3.S: ...this.
+	* config/rs6000/spe_divdf3.S: ...this.
+	* config/rs6000/spe_add_exception.S: ...this.
+	* config/rs6000/spe_muldiv_scale2.S: ...and this.
+	* config/rs6000/spe_cmp.S: Remove.  Split into:
+	* config/rs6000/spe_cmpdf2.S: ...this.
+	* config/rs6000/spe_eqdf2.S: ...this.
+	* config/rs6000/spe_nedf2.S: ...this.
+	* config/rs6000/spe_gedf2.S: ...this.
+	* config/rs6000/spe_gtdf2.S: ...this.
+	* config/rs6000/spe_ledf2.S: ...this.
+	* config/rs6000/spe_ltdf2.S: ...this.
+	* config/rs6000/spe_unorddf2.S: ...this.
+	* config/rs6000/spe_unord_sub.S: ...and this.
+	* config/rs6000/spe_cnv.S: Remove.  Split into:
+	* config/rs6000/fixdfdi.S: ...this.
+	* config/rs6000/fixdfsi.S: ...this.
+	* config/rs6000/fixunsdfdi.S: ...this.
+	* config/rs6000/fixunsdfsi.S: ...this.
+	* config/rs6000/floatdidf.S: ...this.
+	* config/rs6000/floatsidf.S: ...this.
+	* config/rs6000/floatundidf.S: ...this.
+	* config/rs6000/floatunsidf.S: ...this.
+	* config/rs6000/extendsfdf2.S: ...this.
+	* config/rs6000/truncdfsf2.S: ...this.
+	* config/rs6000/t-spe-fprules (spe-files): Remove removed files.
+	Add new files.
+
+	2010-04-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* config.gcc (powerpc-*-eabi*): Use soft-fp/t-softfp.
+
+	2010-04-02  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7937
+
+	* release-notes-csl.xml: New note.
+
+	libgcc/
+	* configure.ac: Check for __SPE__ when compiling for powerpc*.
+	* configure: Regenerate.
+	* config.host: Add t-spe-fprules if compiling for SPE.
+	* config/rs6000/t-spe-fprules: New file.
+	* config/rs6000/spe_arith.S: New file.
+	* config/rs6000/spe_cmp.S: New file.
+	* config/rs6000/spe_cnv.S: New file.
+	* config/rs6000?spe_neg.S: New file.
+
+	2010-04-02  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* config.gcc (powerpc-*-eabi*): Use rs6000/t-fprules-softfp.
+
+	2010-03-31  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from FSF:
+
+	gcc/
+	2009-10-10  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* configure.ac: Add test for dci instruction.
+	* configure: Regenerate.
+	* config.in: Likewise.
+	* config.gcc: Handle --with-cpu=476 and --with-cpu=476fp.
+	* doc/invoke.texi: Add cpu_type 476 and 476fp.
+	(-mmulhw): Add 476 to description.
+	(-mdlmzb): Likewise.
+	* config/rs6000/t-fprules (MULTILIB_MATCHES_FLOAT): Include -mcpu=476.
+	* config/rs6000/rs6000.c (processor_costs): Add ppc476_cost.
+	(processor_target_table): Add 476 and 476fp entries.
+	(rs6000_override_options): Use ppc476_cost for PROCESSOR_PPC476.
+	(rs6000_issue_rate): Add CPU_PPC476.
+	* config/rs6000/rs6000.h (ASM_CPU_476_SPEC): Define.
+	(ASM_CPU_SPEC): Pass %(asm_cpu_476) for -mcpu=476 and -mcpu=476fp.
+	(processor_type): Add PROCESSOR_PPC476.
+	(EXTRA_SPECS): Add asm_cpu_476 string.
+	* config/rs6000/rs6000.md: (define_attr "type"): Add isel attribute.
+	(define_attr "cpu"): Add ppc476.
+	Include 476.md.
+	Update comments for 476.
+	(isel_signed, isel_unsigned): Change to use "isel" type attribute.
+	* config/rs6000/vxworks.h (CPP_SPEC): Handle 464 and 476.
+	Update copyright year.
+	* config/rs6000/476.md: New file.
+	* config/rs6000/40x.md: Add description for "isel" attribute.
+	Update copyright year.
+	* config/rs6000/440.md: Likewise.
+	* config/rs6000/603.md: Likewise.
+	* config/rs6000/6xx.md: Likewise.
+	* config/rs6000/7450.md: Likewise.
+	* config/rs6000/7xx.md: Likewise.
+	* config/rs6000/8540.md: Likewise.
+	* config/rs6000/cell.md: Likewise.
+	* config/rs6000/e300c2c3.md: Likewise.
+	* config/rs6000/e500mc.md: Likewise.
+	* config/rs6000/mpc.md: Likewise.
+	* config/rs6000/power4.md: Likewise.
+	* config/rs6000/power5.md: Likewise.
+	* config/rs6000/power6.md: Likewise.
+	* config/rs6000/power7.md: Likewise.
+	* config/rs6000/rios1.md: Likewise.
+	* config/rs6000/rios2.md: Likewise.
+	* config/rs6000/rs64.md: Likewise.
+
+	2010-03-30  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #5851
+
+	Backport:
+
+	gcc/
+	2009-06-16  J"orn Rennecke  <joern.rennecke@arc.com>
+		    Janis Johnson  <janis187@us.ibm.com>
+
+	PR target/39254
+	* config/rs6000/rs6000.c (rs6000_emit_move): Don't emit a USE
+	for the symbol ref of a constant that is the source of a move
+	- nor for any other not-obvious-label-ref constants.
+
+	2010-03-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Revert:
+
+	gcc/
+	2010-03-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* config/rs6000/rs6000.md (define_insn ""): Disable on TARGET_ISEL targets.
+
+	2010-03-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/testsuite/
+	2009-12-07  Edmar Wienskoski  <edmar@freescale.com>
+
+	* gcc.target/powerpc/ppc-eq0-1.c: Adjust testcase for isel
+	targets.
+
+	2010-03-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.target/powerpc/block-move-1.c (memcpy): Declare.
+	* gcc.target/powerpc/block-move-2.c (memcpy): Likewise.
+
+	2010-03-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7183
+
+	* config/rs6000/rs6000.c (rs6000_emit_int_cmove): Don't force_reg on
+	const0_rtx operand.
+	* config/rs6000/rs6000.md (isel_signed, isel_unsigned): Permit
+	const_int 0 for the second operand; make third operand slightly more
+	lenient.
+	(define_insn ""): Disable on TARGET_ISEL targets.
+
+	2010-03-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7183
+
+	* release-notes-csl.xml: New notes.
+
+	gcc/
+	* doc/invoke.texi (mblock-move-inline-limit): Tweak @opindex directive.
+	Tweak text to reflect target-specific setting of this option.
+
+	2010-03-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7792
+
+	Backport from upstream:
+
+	gcc/
+	2009-09-10  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* config/rs6000/rs6000.h (DATA_ALIGNMENT): Check that we are dealing
+	with actual SPE/paired vector modes before using 64-bit alignment.
+	Check that TYPE is a REAL_TYPE for TARGET_E500_DOUBLE.
+
+	2010-03-04  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7183
+
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_emit_int_cmove): Change prototype.
+	Ensure that isel pattern is only emitted with proper conditions.
+	(rs6000_emit_cmove): Change call to rs6000_emit_int_cmove to match.
+	(output_isel): Check that condition is LT, GT, LTU, GTU, or EQ.
+	(rs6000_emit_sISEL): New function.
+	(rs6000_emit_sCOND): Call it if computing an SImode result.
+	(rs6000_rtx_costs): Alter costs for comparisons for TARGET_ISEL.
+	* config/rs6000/rs6000.md (abssi2_isel): Change pattern to use
+	lt rather than ge.
+	(isel_signed, isel_unsigned): Tighten constraints on comparison
+	operator.
+	(sne, sge, sgt, sle, slt): Check TARGET_ISEL.
+
+	2010-03-04  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7183
+
+	gcc/
+	* config/rs6000/rs6000.opt (mblock-move-inline-limit=): New option.
+	* config/rs6000/rs6000.c (rs6000_override_options): Set
+	rs6000_block_move_inline_limit.
+	* doc/invoke.texi (-mblock-move-inline-limit): Document.
+	
+	gcc/testsuite/
+	* gcc.target/powerpc/block-move-1.c: New test.
+	* gcc.target/powerpc/block-move-2.c: New test.
+
+	2010-02-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/
+	2009-06-25  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR target/38731
+	* config/rs6000/rs6000.c (LOCAL_ALIGNMENT): Redefine to just use
+	DATA_ALIGNMENT instead.
+
+	2010-02-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7587
+
+	* release-notes-csl.xml: New note.
+
+	Backport from mainline:
+
+	gcc/
+	2010-02-05  Nathan Froyd  <froydnj@codesourcery.com>
+	
+	* config/rs6000/rs6000.c (rs6000_override_options): Invert check
+	for rs6000_gen_cell_microcode.
+
+	2009-07-03  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-05-26  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+	gcc/
+	2008-04-30  Nathan Froyd  <froydnj@codesourcery.com>
+	* config/rs6000/t-ppccomm: Add build rules for new files.
+	(LIB2FUNCS_STATIC_EXTRA): Add new files.
+
+	libgcc/
+	2008-04-30  Nathan Froyd  <froydnj@codesourcery.com>
+	* config/rs6000/t-ppccomm: Add build rules for new files.
+	(LIB2ADD_ST): New variable.
+
+	2009-07-02  Andrew Jenner  <andrew@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-02-04  Andrew Jenner  <andrew@codesourcery.com>
+
+	gcc/
+	* config.gcc: Handle powerpc-montavista-linux-gnu.
+	* config/rs6000/t-montavista-linux: New file.
+	* config/rs6000/montavista-linux.h: New file.
+
+	2009-06-29  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+	2009-04-21  Andrew Jenner  <andrew@codesourcery.com>
+	gcc/testsuite/
+	* lib/target-supports.exp: Handle powerpc-*-elf.
+
+	2009-06-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-06-02  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.md (absv2sf2, negv2sf2, addv2sf3, subv2sf3,
+	mulv2sf3, divv2sf3): New expanders.
+	* config/rs6000/spe.md (spe_evabs, spe_evand, spe_evaddw,
+	spe_evdivws): Rename to use standard GCC names.
+	* config/rs6000/paired.md (negv2sf, absv2sf2, addv2sf3, subv2sf3,
+	mulv2sf3, divv2sf3): Rename to avoid conflict with the new expanders.
+
+	2007-09-19  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (bdesc_2arg, bdesc_1arg): Use new CODE_FOR_
+	names for renamed patterns.
+
+	2009-06-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-04-14  Daniel Jacobowitz  <dan@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_dwarf_register_span): Fix debug
+	output for other floating point modes.
+
+	2009-06-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-11-24  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_savres_strategy): Always use
+	inline saves and restores when compiling position-independent code.
+
+	2008-11-17  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_emit_epilogue): Adjust
+	computation of restore_lr.  Duplicate restoration of LR and
+	execute the appropriate one depending on whether GPRs are being
+	restored inline.
+
+	2008-11-17  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_savres_routine_sym): Fix
+	computation for cache selector.  Mark the generated symbol as a
+	function.
+	(rs6000_emit_prologue): Correct condition.
+	* config/rs6000/rs6000.md (*save_gpregs_<mode>): Use explicit
+	match for register 11.
+	(*save_fpregs_<mode>): Likewise.
+	(*restore_gpregs_<mode>): Likewise.
+	(*return_and_restore_gpregs_<mode>): Likewise.
+	(*return_and_restore_fpregs_<mode>): Likewise.
+	* config/rs6000/spe.md (*save_gpregs_spe): Use explicit match for
+	register 11.
+	(*restore_gpregs_spe): Likewise.
+	(*return_and_restore_gpregs_spe): Likewise.
+
+	2008-10-24  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (no_global_regs_above): Fix precedence
+	problem.
+
+	2009-06-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-07-02  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/eabi.h (NAME__MAIN, INVOKE__main): Remove.
+	* config/rs6000/t-ppccomm (LIB2FUNS_STATIC_EXTRA): Remove eabi.S.
+	(eabi.S): Remove rule.
+
+	2008-10-13  Andrew Stubbs  <ams@codesourcery.com>
+	gcc/
+	* doc/invoke.texi (PowerPC Options): -meabi option no longer places
+	__eabi function in main.
+
+	2009-06-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/
+	2009-06-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* config/rs6000/eabi.asm (__eabi_convert): Don't define if
+	_RELOCATABLE.
+	(__eabi_uconvert): Likewise.
+
+	2009-06-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2008-08-25  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/sysv4.h (LIB_SIM_SPEC): Use LIB_DEFAULT_SPEC.
+	(STARTFILE_SIM_SPEC): Remove sim-crt0.o%s.
+	(ENDFILE_SIM_SPEC): Add -Tsim-hosted.ld.
+	(LINK_OS_SIM_SPEC): Define to empty.
+
+	2009-06-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2008-02-12  Nathan Sidwell  <nathan@codesourcery.com>
+		    Daniel Jacobowitz  <dan@codesourcery.com>
+	gcc/
+	* config/rs6000/eabi-ci.asm (__init): Add _init func start.
+	(__fini): Also declare _fini for newlib.
+
+	2009-06-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-08-16  Daniel Jacobowitz  <dan@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_conditional_register_usage): Mark
+	call-saved AltiVec registers call-used if ! TARGET_ALTIVEC_ABI.
+	* config/rs6000/rs6000.h (CALL_USED_REGISTERS): Mark the first 20
+	AltiVec registers call-used.
+	(CALL_REALLY_USED_REGISTERS): Likewise.
+
+	gcc/testsuite/
+	* gcc.target/powerpc/altivec-consts.c: Remove -mabi=altivec.
+	* gcc.target/powerpc/altivec-varargs-1.c: Likewise.
+	* gcc.dg/vmx/vmx.exp: Likewise.
+
+	2009-05-15  Mark Mitchell  <mark@codesourcery.com>
+		    Joseph Myers  <joseph@codesourcery.com>
+		    Mark Shinwell  <shinwell@codesourcery.com>
+		    Vladimir Prus  <vladimir@codesourcery.com>
+		    Paul Brook  <paul@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	* config.gcc: Handle powerpc-wrs-linux-gnu.
+	* config/rs6000/t-wrs-linux, config/rs6000/wrs-linux.h: New.
+
+	2009-05-11  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Forward port 2009-02-12  Nathan Sidwell  <nathan@codesourcery.com>
+	Issue #4620
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_init_builtins): Set TYPE_NAME of
+	our distinct integral and vector types.
+	gcc/testsuite/
+	* g++.dg/ext/altivec-17.C: New.
+
+	2009-04-29  Nathan Froyd  <froydnj@codesourcery.com>
+		    Kazu Hirata <kazu@codesourcery.com>
+		    Daniel Jacobowitz  <dan@codesourcery.com>
+		    Nathan Sidwell  <nathan@codesourcery.com>
+		    Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/rs6000/e500mc.h, config/rs6000/t-cs-eabi,
+	config/rs6000/t-cs-eabi-lite, config/rs6000/t-cs-linux,
+	config/rs6000/t-ppc-e500mc: New.
+	* config.gcc: Add Power multilib configurations.
+	* config/rs6000/eabi.h (CC1_EXTRA_SPEC, ASM_DEFAULT_SPEC): Define.
+	* config/rs6000/linux.h (CC1_EXTRA_SPEC, ASM_DEFAULT_SPEC,
+	SYSROOT_SUFFIX_SPEC): Define.
+
+	2009-04-29  Joseph Myers  <joseph@codesourcery.com>
+		    Daniel Jacobowitz  <dan@codesourcery.com>
+		    Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	* config/rs6000/option-defaults.h (OPTION_DEFAULT_SPECS): Handle
+	-te500mc, -te500v1, -te500v2 and -te600.
+
+	2009-04-29  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	* config/rs6000/sysv4.h (CC1_EXTRA_SPEC): Define and use.
+
+	2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/
+	2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+	* config.gcc (powerpc*-*-* | rs6000-*-*): Add
+	rs6000/option-defaults.h to tm_file.  Support cpu_32, cpu_64,
+	tune_32 and tune_64.
+	* doc/install.texi (--with-cpu-32, --with-cpu-64): Document
+	support on PowerPC.
+	* config/rs6000/rs6000.h (OPTION_DEFAULT_SPECS): Move to ...
+	* config/rs6000/option-defaults.h: ... here.  New file.
+	(OPT_64, OPT_32): Define.
+	(MASK_64BIT): Define to 0 if not already defined.
+	(OPT_ARCH64, OPT_ARCH32): Define.
+	(OPTION_DEFAULT_SPECS): Add entries for cpu_32, cpu_64, tune_32
+	and tune_64.
+
+2010-07-20  Paul Brook  <paul@codesourcery.com>
+ 
+	gcc/
+	* config/arm/thumb2.md (thumb_andsi_not_shiftsi_si,
+	thumb2_notsi_shiftsi, thumb2_notsi_shiftsi_compare0,
+	thumb2_not_shiftsi_compare0_scratch, thumb2_cmpsi_shiftsi,
+	thumb2_cmpsi_shiftsi_swp, thumb2_cmpsi_neg_shiftsi,
+	thumb2_arith_shiftsi, thumb2_arith_shiftsi_compare0,
+	thumb2_arith_shiftsi_compare0_scratch, thumb2_sub_shiftsi,
+	thumb2_sub_shiftsi_compare0, thumb2_sub_shiftsi_compare0_scratch):
+	Use const_shift_count predicate for "M" constraints.
+	* config/arm/predicates.md (const_shift_operand): Remove.
+	(const_shift_count): New.
+
+	gcc/testsuite/
+	* gcc.dg/long-long-shift-1.c: New test.
+
+2010-07-13  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* REVISION: Bump version.
+
+2010-07-13  Andrew Stubbs  <ams@codesourcery.com>
+
+	GCC Linaro 4.4-2010.07-0 released.
+
+	gcc/
+	* REVISION: Update.
+
+2010-07-13  Andrew Stubbs  <ams@codesourcery.com>
+
+	* Makefile.tpl (install): Remove install-pdf and install-html
+	dependencies.
+	* Makefile.in: Regenerate.
+
+	gcc/
+	* Makefile.in (install): Remove install-pdf and install-html
+	dependencies.
+
+2010-07-13  Michael Hope  <michael.hope@linaro.org>
+
+	* libjava/Makefile.am (pkgconfigdir): Reverted changes to pkgconfigdir and
+	jardir back to the FSF version.
+	* libjava/Makefile.in (jardir): Likewise.
+
+2010-07-13  Michael Hope  <michael.hope@linaro.org>
+
+	LP: #602171
+	* gcc/testsuite/gcc.target/i386/pr9771-1.c: Merge r159776 from FSF
+	GCC into the Linaro branch.
+	* gcc/testsuite/gcc.target/arm/frame-pointer-1.c: Likewise.
+
+	Original entry:
+        2010-05-24  Paul Brook  <paul@codesourcery.com>
+
+	* gcc.target/arm/frame-pointer-1.c: New test.
+	* gcc.target/i386/pr9771-1.c: Move code out of main to allow frame
+	pointer elimination.
+
+	Note that the change was already present but the test cases hadn't
+	been updated.
+
+2010-07-12  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	Fix Launchpad Bug #602289
+
+	Backport from mainline:
+
+	2010-07-02  Sandra Loosemore  <sandra@codesourcery.com>
+	gcc/
+	* config/arm/neon.ml (Vand): Split DImode variants and mark them
+	as No_op to disable testing for exact instruction match.
+	(Vorr): Likewise.
+	(Veor): Likewise.
+	(Vbic): Likewise.
+	(Vorn): Likewise.
+	gcc/testsuite/
+	* gcc.target/arm/neon-vands64.c: New.
+	* gcc.target/arm/neon-vandu64.c: New.
+	* gcc.target/arm/neon-vbics64.c: New.
+	* gcc.target/arm/neon-vbicu64.c: New.
+	* gcc.target/arm/neon-veors64.c: New.
+	* gcc.target/arm/neon-veoru64.c: New.
+	* gcc.target/arm/neon-vorns64.c: New.
+	* gcc.target/arm/neon-vornu64.c: New.
+	* gcc.target/arm/neon-vorrs64.c: New.
+	* gcc.target/arm/neon-vorru64.c: New.
+
+	Backport from mainline:
+
+	2010-07-02  Sandra Loosemore  <sandra@codesourcery.com>
+		    Julian Brown  <julian@codesourcery.com>
+	gcc/
+	* config/arm/neon.ml (Vadd, Vsub): Split out 64-bit variants and add
+	No_op attribute to disable assembly output checks.
+	gcc/testsuite/
+	* gcc.target/arm/neon-vsubs64.c: New execution test.
+	* gcc.target/arm/neon-vsubu64.c: New execution test.
+	* gcc.target/arm/neon-vadds64.c: New execution test.
+	* gcc.target/arm/neon-vaddu64.c: New execution test.
+
+	Regenerate generated files:
+
+	gcc/
+	* doc/arm-neon-intrinsics.texi: Regenerate.
+	gcc/testsuite/
+	* gcc.target/arm/neon/vadds64.c: Regenerate.
+	* gcc.target/arm/neon/vaddu64.c: Regenerate.
+	* gcc.target/arm/neon/vands64.c: Regenerate.
+	* gcc.target/arm/neon/vandu64.c: Regenerate.
+	* gcc.target/arm/neon/vbics64.c: Regenerate.
+	* gcc.target/arm/neon/vbicu64.c: Regenerate.
+	* gcc.target/arm/neon/veors64.c: Regenerate.
+	* gcc.target/arm/neon/veoru64.c: Regenerate.
+	* gcc.target/arm/neon/vorns64.c: Regenerate.
+	* gcc.target/arm/neon/vornu64.c: Regenerate.
+	* gcc.target/arm/neon/vorrs64.c: Regenerate.
+	* gcc.target/arm/neon/vorru64.c: Regenerate.
+	* gcc.target/arm/neon/vsubs64.c: Regenerate.
+	* gcc.target/arm/neon/vsubu64.c: Regenerate.
+
+2010-07-09  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* config/arm/elf.h (ASM_SPEC): Pass -mimplicit-it=thumb if -mthumb.
+
+2010-07-08  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* DEV-PHASE: Set to "Linaro".
+	* REVISION: New file.
+
+2010-07-07  Yao Qi  <yao@codesourcery.com>
+
+	Revert a license patch.
+
+	2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* gcc.c (main): Add "const" to declaration of license_status.
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	2008-09-04  Julian Brown  <julian@codesourcery.com>
+	* Makefile.in (CSL_LICENSELIB): Remove space after -L to appease
+	Darwin ld.
+
+	gcc/
+	2007-10-16  Joseph Myers  <joseph@codesourcery.com>
+	* gcc.c (license_me_flag): Define to 1 if not TARGET_FLEXLM.
+
+	2007-08-10  Nathan Froyd  <froydnj@codesourcery.com>
+	* gcc.c (main): Consult license_me_flag to see if failure to
+	acquire a license implies bailing out entirely.
+
+	2007-08-24  Nathan Froyd  <froydnj@codesourcery.com>
+	Issue #1892
+	* gcc.c (main): Check license_me_flag before declaring failure.
+
+	2007-08-30  Nathan Sidwell  <nathan@codesourcery.com>
+	Issue #1892
+	* gcc.c (main): Don't complain if license fails without -flicense-me
+
+	2007-04-12  Richard Sandiford  <richard@codesourcery.com>
+	* gcc.c (main): If find_a_file fails, pass the original subproc
+	to csl_subproc_license_new.
+
+	2006-12-27  Mark Mitchell  <mark@codesourcery.com>
+	NOT ASSIGNED TO FSF
+	COPYRIGHT CODESOURCERY
+	* gcc.c (main): If the license check fails, remove the generated
+	file.
+
+	2006-12-22  Mark Mitchell  <mark@codesourcery.com>
+	NOT ASSIGNED TO FSF
+	COPYRIGHT CODESOURCERY
+	* aclocal.m4: Move licensing options ...
+	* acinclude.m4: ... here.
+
+	2006-12-13  Mark Mitchell  <mark@codesourcery.com>
+	NOT ASSIGNED TO FSF
+	COPYRIGHT CODESOURCERY
+	* gcc.c (csl/license.h): Include, if required.
+	(license_checked): New variable.
+	(no_license): Remove.
+	(process_command): Set license_checked, not no_license.
+	(main): Use CodeSourcery license library.  Remove most
+	TARGET_FLEXLM code.
+	* aclocal.m4 (--with-license): New option.
+	(--with-csl-license-feature): Likewise.
+	(--with-csl-license-version): Likewise.
+	* Makefile.in (CSL_LICENSEINC): Define it.
+	(CSL_LICENSELIB): Likewise.
+	(CSL_LICENSE_PROG): Likewise.
+	(LIBS): Depend on CSL_LICENSELIB.
+	(GCC_PASSES): Depend on CSL_LICENSE_PROG.
+	(INCLUDES): Add CSL_LICENSEINC.
+	* configure.ac (CSL_AC_LICENSE_VERSION): Use it.
+	(CSL_AC_LICENSE): Likewise.
+	(CSL_AC_LICENSE_FEATURE): Likewise.
+	* config.in: Regenerated.
+	* configure: Regenerated.
+
+	2006-10-29  Richard Sandiford  <richard@codesourcery.com>
+	            Joseph Myers  <joseph@codesourcery.com>
+	* gcc.c (license_me_flag): New variable.
+	(feature_proxy_flag): New variable.
+	(no_license): New variable.
+	(process_command): Handle -flicense-me, -ffeature-proxy and
+	-fno-feature-proxy.  Initialize no_license.
+	(main): Check licenses.
+
+2010-07-06  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	gcc/
+	2009-11-14  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/42031
+	* arm.md (adddi_sesidi_di): Place tied contraint first.
+	(adddi_zesidi_di, subdi_di_zesidi, subdi_di_sesidi): Likewise
+	(subdi_zesidi_di, subdi_sesidi_di): Likewise.
+	(mulsi3_compare0, mulsi_compare0_scratch): Likewise.
+	(mulsi3addsi, mulsi3addsi_compare0): Likewise. 
+	(mulsi3addsi_compare0_scratch, smulsi3_highpart_nov6): Likewise.
+	(umulsi3_highpart_nov6, anddi_zesidi_di, anddi_sesdi_di): Likewise.       
+	(anddi_notdi_di, iordi_sesidi_di, xordi_sesidi_di): Likewise.
+	(andsi_iorsi3_notsi, arm_ashldi3_1bit, arm_ashrdi3_1_bit): Likewise.
+	(arm_lshrdi3_1bit, one_cmpldi2): Likewise.
+	
+2010-07-05  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	gcc/ada/
+	2010-01-11  Mikael Pettersson  <mikpe@it.uu.se>
+
+	* gcc-interface/Makefile.in: Add arm*-*-linux-gnueabi.
+	* system-linux-armeb.ads, system-linux-armel.ads: New files.
+	
+2010-07-05  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	libjava/
+	2009-08-12  Andrew Haley  <aph@redhat.com>
+
+	* sysdep/arm/locks.h: Use atomic builtins For Linux EABI.
+	* configure.ac: Add ATOMICSPEC.
+	* libgcj.spec.in: Likewise.
+	* configure.host (arm*-linux*): Add -Wno-abi to cxxflags.
+	(testsuite/libjava.jvmti/jvmti-interp.exp): Likewise.
+	(testsuite/libjava.jvmti/jvmti.exp): Likewise.
+	(testsuite/libjava.jni/jni.exp): Likewise.
+	Set ATOMICSPEC.
+
+2010-07-05  Yao Qi  <yao@codesourcery.com>
+
+	boehm-gc/
+	* include/private/gc_locks.h: Patch arm-boehm-gc-locks.diff from Ubuntu.
+
+2010-07-05  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC: 
+	gcc/java/
+	2009-08-12  Andrew Haley  <aph@redhat.com>
+
+	* builtins.c (compareAndSwapInt_builtin): Use 
+	flag_use_atomic_builtins.
+	(compareAndSwapLong_builtin): Likewise.
+	(compareAndSwapObject_builtin): Likewise.
+	* jvspec.c: Add flag_use_atomic_builtins.
+	* gcj.texi: Likewise.
+	* java-tree.h: Likewise.
+	* lang.opt: Likewise.
+	
+2010-07-05  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	
+	libjava/classpath/
+	2010-04-27  Andrew Haley  <aph@redhat.com>
+
+	* java/util/concurrent/CopyOnWriteArrayList.java: Fix for empty        list.
+
+	2010-04-27  Andrew Haley  <aph@redhat.com>
+
+	* gnu/javax/print/ipp/IppResponse.java (parseAttributes): Handle
+	IppValueTag.UNKNOWN.
+	* gnu/javax/print/ipp/IppRequest.java (writeOperationAttributes):
+	Handle RequestedAttributes.
+	* gnu/javax/print/ipp/IppPrintService.java (processResponse): Add
+	DocFlavor.SERVICE_FORMATTED.PAGEABLE and
+	DocFlavor.SERVICE_FORMATTED.PRINTABLE.
+
+2010-07-02  Yao Qi  <yao@codesourcery.com>
+	Import from Ubuntu GCC:
+	gcc/
+	2009-10-05  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	* config/arm/arm.c (arm_override_options): Really initialize 
+	flag_dwarf2_cfi_asm to 0.
+	
+2010-07-02  Yao Qi  <yao@codesourcery.com>
+	
+	Import from Ubuntu GCC:
+
+	gcc/
+	2009-05-27  Julian Brown  <julian@codesourcery.com>
+	* gcse.c (target.h): Include.
+	(can_assign_to_reg_without_clobbers_p): Check that the target allows
+	copy of argument to a pseudo register.
+	
+2010-07-02  Yao Qi  <yao@codesourcery.com>
+
+	gcc/
+	* config.gcc: Patch pr40134.diff from Ubuntu.
+	* config/pa/pa-linux.h: Likewise.
+	
+2010-07-02  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	libstdc++-v3/
+	2009-12-09  Paolo Carlini  <paolo.carlini@oracle.com>
+	            Matthias Klose  <doko@ubuntu.com>
+
+	PR libstdc++/40133
+	* acinclude.m4 ([GLIBCXX_ENABLE_ATOMIC_BUILTINS]): On *-*-linux*,
+	*-*-kfreebsd*-gnu | *-*-gnu* targets do link tests when possible.
+	* configure: Regenerate.
+	
+2010-07-02  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	gcc/
+	2010-03-13  Mikael Pettersson  <mikpe@it.uu.se>
+	PR middle-end/43323
+	Backport from mainline:
+	2009-06-17  Adam Nemet  <anemet@caviumnetworks.com>
+
+	* tree.h (STRIP_NOPS, STRIP_SIGN_NOPS,
+	STRIP_USELESS_TYPE_CONVERSION): Use tree_strip_nop_conversions,
+	tree_strip_sign_nop_conversions and 
+	tree_ssa_strip_useless_type_conversions rather than stripping
+	the operations here.
+	(tree_strip_nop_conversions, tree_strip_sign_nop_conversions):Declare them.
+	* gimple.h (tree_ssa_strip_useless_type_conversions): Declare it.
+	* tree-ssa.c (tree_ssa_strip_useless_type_conversions): New function. 
+	* tree.c (tree_nop_conversion, tree_sign_nop_conversion,
+	tree_strip_nop_conversions, tree_strip_sign_nop_conversions): New functions.
+
+	gcc/testsuite/
+	2010-03-13  Mikael Pettersson  <mikpe@it.uu.se>
+	PR middle-end/43323
+	* gcc.c-torture/execute/pr43323.c: New test.
+
+	Backport from mainline:
+	2009-06-17  Adam Nemet  <anemet@caviumnetworks.com>
+
+	* gcc.c-torture/execute/bitfld-5.c: New test.
+
+2010-06-30  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	gcc/objc/
+	* lang-specs.h: Patch pr41848.diff from Ubuntu.
+	gcc/testsuite/
+	* objc/execute/forward-1.x: Patch pr41848.diff from Ubuntu.
+
+2010-06-30  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	gcc/
+	* configure.ac: Patch gcc-stack_chk_fail-check.diff from Ubuntu.
+
+2010-06-30  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	2010-04-27  Jakub Jelinek  <jakub@redhat.com>
+	gcc/
+	* unwind-dw2.c (_Unwind_DebugHook): Add used attribute.
+
+	2009-05-27  Tom Tromey  <tromey@redhat.com>
+	gcc/
+	* unwind-dw2.c (_Unwind_DebugHook): New function.
+	(uw_install_context): Call _Unwind_DebugHook.
+
+2010-06-30  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	2009-07-20  Mikael Pettersson  <mikpe@it.uu.se>
+	gcc/
+	Backport from mainline:
+	2009-04-20  Ian Lance Taylor  <ian@gcc.gnu.org>
+	Fix enum conversions which are invalid in C++.
+	* config/arm/arm.c (arm_rtx_costs_1) <case ABS>: Fix 
+	typo in call to GET_MODE_CLASS.
+
+2010-06-30  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	2009-07-20  Mikael Pettersson  <mikpe@it.uu.se>
+	gcc/
+	Backport from mainline:
+	2009-04-20  Ian Lance Taylor  <ian@gcc.gnu.org>
+	Fix enum conversions which are invalid in C++.
+
+	PR target/39429
+	* config/arm/arm.c (adjacent_mem_locations): Fix swapped
+	parameters in const_ok_for_op calls.
+
+	gcc/testsuite/
+	PR target/39429
+	* gcc.target/arm/pr39429.c: New test case.
+
+2010-06-30  Yao Qi  <yao@codesourcery.com>
+
+	Import from Ubuntu GCC:
+	gcc/
+	* configure.ac, config.in: Patch gcc-build-id.diff from Ubuntu.
+
+2010-06-16  Julian Brown  <julian@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.h (REG_CLASS_CONTENTS): Remove soft frame pointer
+	from CORE_REGS and GENERAL_REGS classes.
+	* config/arm/arm.md (*thumb1_movsi_insn): Ignore all parts of final
+	constraint for register preferencing.
+
+2010-06-07  Julian Brown  <julian@codesourcery.com>
+
+	Merge from GCC 4.4.4.
+
+2010-05-26  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.target/arm/pr42496.c: Remove duplicate concatenated copy of
+	testcase.
+
+2010-05-24  Paul Brook  <paul@codesourcery.com>
+
+	Issue #8426 - Avoid libsupc++ static vritable data
+	libstdc++-v3/
+	* libsupc++/unwind-cxx.h (__get_terminate_handler,
+	__get_terminate_handler): New.
+	* libsupc++/eh_throw.cc: Use them.
+	* libsupc++/eh_ptr.cc: Ditto.
+	* libsupc++/eh_terminate.cc: Ditto.
+	* libsupc++/eh_term_handler.cc: Avoid static initializer on SymbianOS.
+	* libsupc++/eh_unex_handler.cc: Avoid static initializer on SymbianOS.
+
+2010-05-22  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Issue #8729
+
+	* release-notes-csl.xml: New note.
+
+2010-05-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Issue #8729
+
+	Integrate <http://gcc.gnu.org/ml/gcc-patches/2010-03/msg01451.html>.
+	Drop the TARGET_TITAN_FPU and fsqrt changes.
+
+	XXXX-XX-XX  Philipp Tomsich  <philipp.tomsich@theobroma-systems.com>
+
+	NOT ASSIGNED TO FSF
+	COPYRIGHT Philipp Tomsich (Theobroma Systems Design und Consulting GmbH)
+
+	gcc/
+	* config.gcc: Recognize titan.
+	* config/rs6000/rs6000.c (titan_cost): New.
+	(rs6000_override_options, rs6000_issue_rate): Handle titan.
+	* config/rs6000/rs6000.h (processor_type): Register titan.
+	* config/rs6000/rs6000.md (cpu): Register titan.
+	Include "titan.md".
+	* config/rs6000/titan.md: New.
+	* doc/invoke.texi <mcpu>: Document titan.
+
+2010-05-18  Paul Brook  <paul@codesourcery.com>
+
+	Issue #8426 - Fix libsupc++ symbol visibility
+	gcc/
+	* config/arm/eabi-memset.c (__aeabi_memset): Remove bogus return value.
+
+	Import from Ubuntu GCC:
+
+	libstdc++-v3/
+	2009-07-06  Jason Merrill  <jason@redhat.com>
+
+	* libsupc++/vmi_class_type_info.cc (__do_dyncast): Use src2dst
+ hint 
+ 	to defer searching bases that don't overlap the desired address.
+	gcc/testsuite/
+	2009-07-06  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/rtti/dyncast[34].C: New.
+
+2010-07-02  Yao Qi  <yao@codesourcery.com>
+
+	libstdc++-v3/
+	* libsupc++/eh_arm.cc (__cxa_type_match): Use correct namespace.
+	(__cxa_begin_cleanup): Ditto.
+	* libsupc++/unwind-cxx.h (__cxa_call_unexpected, __cxa_call_terminate,
+	__cxa_type_match, __cxa_begin_cleanup): Use correct types on ARM EABI.
+	* libsupc++/cxxabi.h: Add prototypes for __aeabi routines.
+	* libsupc++/eh_personality.cc (PERSONALITY_FUNCTION): Export with
+	default visibility.
+	* libsupc++/eh_call.cc (__cxa_call_terminate, __cxa_call_unexpected):
+	Use correct namespace and types.
+
+2010-05-17  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #8513
+
+	gcc/
+	* config/arm/arm.c (arm_print_operand): Handle CONST
+	address.
+	* config/arm/arm.h (TARGET_USE_RELA): Define.
+	* config/arm/arm.md (define_split for SYMBOL_REF move):
+	Also split SYMBOL_REF + offset case.
+	* config/arm/vxworks.h (TARGET_USE_RELA): Define.
+
+2010-05-12  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #8483
+
+	gcc/
+	* targhooks.c (default_stack_protect_guard): Fix backporting mistake.
+
+2010-05-12  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #8483
+
+	* release-notes-csl.xml: Add a release note.
+
+	Backport from mainline:
+
+	gcc/
+	2010-05-12  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	* targhooks.c (default_stack_protect_guard): Avoid sharing RTL
+	for __stack_chk_guard.
+	2010-05-12  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	* gcc.target/m68k/20100512-1.c: New.
+
+2010-05-11  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #8473
+
+	* release-notes-csl.xml: Document.
+
+	Backport from mainline:
+
+	gcc/
+	2010-04-26  Jie Zhang  <jie@codesourcery.com>
+	PR tree-optimization/43833
+	* tree-vrp.c (range_int_cst_p): New.
+	(range_int_cst_singleton_p): New.
+	(extract_range_from_binary_expr): Optimize BIT_AND_EXPR case
+	when both operands are constants.  Use range_int_cst_p in
+	BIT_IOR_EXPR case.
+
+	gcc/testsuite/
+	2010-04-26  Jie Zhang  <jie@codesourcery.com>
+	PR tree-optimization/43833
+	gcc.dg/Warray-bounds-8.c: New test case.
+
+2010-05-06  Thomas Schwinge  <thomas@codesourcery.com>
+	    Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #8578
+
+	* release-notes-csl.xml (Fix for invalid code generation bug): New
+	note.
+
+2010-05-06  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Issue #8578
+
+	Backport from mainline branches/gcc-4_4-branch (r154046):
+
+	gcc/
+	2009-11-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/40946
+	Backport from mainline
+	2009-09-09  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/41317
+	* tree-ssa-ccp.c (maybe_fold_offset_to_component_ref): Remove
+	code dealing with plain pointer bases.
+	(maybe_fold_offset_to_reference): Likewise.
+	(maybe_fold_stmt_addition): Adjust.
+
+	gcc/testsuite/
+	2009-11-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/40946
+	* gcc.dg/pr40946.c: New test.
+
+	Backport from mainline
+	2009-09-09  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/41317
+	* gcc.c-torture/execute/pr41317.c: New testcase.
+
+2010-05-04  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/testsuite/
+	2009-11-23  Andy Hutchinson  <hutchinsonandy@gcc.gnu.org>
+
+	* gcc-dg/utf-array-short-wchar.c: Require-effective-target wchar.
+	* gcc-dg/utf-array.c: Ditto.
+
+2010-04-27  Paul Brook  <paul@codesourcery.com>
+
+	libstdc++-v3/
+	* configure.ac: Remove LIBSUPCXX_PRONLY.
+	* include/Makefile.am: Remove LIBSUPCXX_PRONLY.
+	* libsupc++/Makefile.am: Remove LIBSUPCXX_PRONLY.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+	* src/Makefile.in: Regenerate.
+	* doc/Makefile.in: Regenerate.
+	* po/Makefile.in: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* libsupc++/Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2010-04-27  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gcc/
+	* config/arm/nucleus.h (NUCLEUS_SHARED_CPP_BUILTINS): New.
+	(TARGET_OS_CPP_BUILTINS): Override.
+	* config/arm/unwind-arm.h (_Unwind_decode_target2): Target2 on
+	nucleus-shared is the same as linux.
+
+2010-04-20  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgcc/
+	* config/rs6000/t-spe-fprules (spe-softfp-srcs): Don't add
+	$(gcc_srcdir)/config/soft-fp as a prefix.
+	(LIB2ADD): Use patterns with the source filenames as the filter.
+
+2010-04-20  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-07-06  Nick Clifton  <nickc@redhat.com>
+		    DJ Delorie  <dj@redhat.com>
+
+	* config.sh/lib1funcs.h (FMOVD_WORKS): Only define if
+	__FMOVD_ENABLED__ is defined.
+	* config/sh/sh.h
+	(TARGET_FMOVD): Provide a default definition.
+	(MASK_FMOVD): Likewise.
+	(TARGET_CPU_CPP_BUILTINS): Define
+	__FMOVD_ENABLED__ if TARGET_FMOVD is true.
+	* config/sh/sh.md (movdf_i4): For alternative 0 use either one or
+	two fmov instructions depending upon whether TARGET_FMOVD is
+	enabled.
+	(split for DF load from memory into register): Also handle
+	MEMs which consist of REG+DISP addressing.
+	(split for DF store from register to memory): Likewise.
+	(movsf_ie): Always use single fp_mode.
+	* config/sh/sh.c (sh_override_options): Do not automatically
+	enable TARGET_MOVD for the SH2A when supporting doubles - leave
+	that to the -mfmovd command line switch.
+	(broken_move): Do not restrict fldi test to only the SH4 and SH4A.
+	(fldi_ok): Always allow.
+	* config/sh/sh.opt (mfmovd): Remove this switch.
+	* doc/invoke.texi (-mfmovd): Remove documentation of this switch.
+
+	2009-07-20  Christian Bruel  <christian.bruel@st.com>
+
+	gcc/
+	* config/sh/sh.opt (-mfmovd): Resurrect and document.
+	* doc/invoke.texi (-mfmovd): Likewise.
+	* config/sh/sh.h (TARGET_FMOVD, MASK_FMOVD): Remove default setting.
+
+	gcc/testsuite/
+	* gcc.target/sh/mfmovd.c: New test.
+
+2010-04-20  Andrew Stubbs  <ams@codesourcery.com>
+
+	* gcc/config/sh/sh.h (CRT_GET_RFIB_DATA): New define.
+	(ASM_PREFERRED_EH_DATA_FORMAT): Add FDPIC settings.
+	(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Likewise.
+
+2010-04-19  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #7944
+
+	Backporting from mainline:
+
+	gcc/
+	2010-04-19  Jie Zhang  <jie@codesourcery.com>
+
+	PR target/43662
+	* reginfo.c (reinit_regs): Set caller_save_initialized_p
+	to false.
+
+	gcc/testsuite/
+	2010-04-19  Jie Zhang  <jie@codesourcery.com>
+
+	PR target/43662
+	* gcc.target/i386/pr43662.c: New test.
+
+2010-04-19  Bernd Schmidt  <bernds@codesourcery.com>
+
+	gcc/
+	* ifcvt.c (move_across_if): Delete.
+	(find_if_header): Don't call it.
+
+2010-04-17  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #8442 - DImode ICE.
+
+	* release-notes-csl.xml (ARM internal compiler error fix): New note.
+
+	gcc/
+	* config/arm/arm.md (movsicc, movsfcc, movdfcc): Reverse
+	invalid DImode comparisons.
+
+	gcc/testsuite/
+	* gcc.c-torture/execute/20100416-1.c: New test.
+
+2010-04-15  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgcc/
+	* config/rs6000/divdf3.S (__divdf3): Use JUMP_TARGET instead of L.
+	* config/rs6000/muldf3.S (__muldf3): Likewise.
+
+2010-04-15  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgcc/
+	* config/rs6000/spe_muldiv_scale2.S (__spe_return_inf_mul_div):
+	New function.
+	* config/rs6000/divdf3.S (__divdf3): Call it.
+	* config/rs6000/muldf3.S (__muldf3): Likewise.
+
+2010-04-15  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgcc/
+	* config/rs6000/spe_add_exception.S: Remove .file directive.
+	* config/rs6000/spe_adddf3.S: Likewise.
+	* config/rs6000/spe_cmpdf2.S: Likewise.
+	* config/rs6000/spe_divdf3.S: Likewise.
+	* config/rs6000/spe_eqdf2.S: Likewise.
+	* config/rs6000/spe_extendsfdf2.S: Likewise.
+	* config/rs6000/spe_fixdfdi.S: Likewise.
+	* config/rs6000/spe_fixdfsi.S: Likewise.
+	* config/rs6000/spe_fixunsdfdi.S: Likewise.
+	* config/rs6000/spe_fixunsdfsi.S: Likewise.
+	* config/rs6000/spe_floatdidf.S: Likewise.
+	* config/rs6000/spe_floatsidf.S: Likewise.
+	* config/rs6000/spe_floatundidf.S: Likewise.
+	* config/rs6000/spe_floatunsidf.S: Likewise.
+	* config/rs6000/spe_gedf2.S: Likewise.
+	* config/rs6000/spe_gtdf2.S: Likewise.
+	* config/rs6000/spe_ledf2.S: Likewise.
+	* config/rs6000/spe_ltdf2.S: Likewise.
+	* config/rs6000/spe_muldf3.S: Likewise.
+	* config/rs6000/spe_muldiv_scale2.S: Likewise.
+	* config/rs6000/spe_nedf2.S: Likewise.
+	* config/rs6000/spe_neg.S: Likewise.
+	* config/rs6000/spe_subdf3.S: Likewise.
+	* config/rs6000/spe_truncdfsf2.S: Likewise.
+	* config/rs6000/spe_unord_sub.S: Likewise.
+	* config/rs6000/spe_unorddf2.S: Likewise.
+
+2010-04-13  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* regmove.c (fixup_match_2): Swap incorrect uses of src and dst.
+
+2010-04-13  Julian Brown  <julian@codesourcery.com>
+
+	* release-notes-csl.xml (Better use of NEON instructions on Cortex-A8)
+	(Optimization of ARM NEON vdupq_n* intrinsics): Fix target lines for
+	notes.
+
+2010-04-13  Julian Brown  <julian@codesourcery.com>
+
+	* release-notes-csl.xml (ARMv7-A performance improvements): Add note.
+
+2010-04-13  Bernd Schmidt  <bernds@codesourcery.com>
+
+	* release-notes-csl.xml: Document.
+
+	gcc/
+	PR target/21803
+	* ifcvt.c (cond_exec_process_if_block): Look for identical sequences
+	at the start and end of the then/else blocks, and omit them from the
+	conversion.
+	(move_across_if): New function.
+	(find_if_header): Call it.
+	* cfgcleanup.c (flow_find_cross_jump): No longer static.
+	(flow_find_head_matching_sequence): New function.
+	(old_insns_match_p): Check REG_EH_REGION notes for calls.
+	* basic-block.h (flow_find_cross_jump,
+	flow_find_head_matching_sequence): Declare functions.
+
+	gcc/testsuite/
+	PR target/21803
+	* gcc.target/arm/pr42496.c: New test.
+
+2010-04-13  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Revert buggy patch.
+
+	2010-04-04  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	PR middle-end/40815
+	gcc/
+	* tree-ssa-reassoc.c (broken_up_substracts): Rename to plus_negates.
+	(negate_value): Move code to push elements to broken_up_substracts ...
+	(eliminate_plus_minus_pair): ... here.  Push operands that have no
+	negative pair to plus_negates.
+	(repropagate_negates, init_reassoc, fini_reassoc): Update.
+	gcc/testsuite/
+	* gcc.dg/tree-ssa/reassoc-19.c: New.
+
+2010-04-11  Julian Brown  <julian@codesourcery.com>
+
+	Issue #7326
+
+	* release-notes-csl.xml (Improved code generation for
+	Cortex-A5): Add note.
+
+2010-04-11  Julian Brown  <julian@codesourcery.com>
+
+	Issue #7326
+
+	gcc/
+	* config/arm/arm.c (arm_issue_rate): Return 2 for Cortex-A5.
+	* config/arm/arm.md (generic_sched): No for Cortex-A5.
+	(generic_vfp): Likewise.
+	(cortex-a5.md): Include.
+	* config/arm/cortex-a5.md: New.
+
+2010-04-12  Andrew Stubbs  <ams@codesourcery.com>
+
+	Issue #7178
+
+	gcc/
+	* config/arm/arm.c (arm_init_libfuncs): Change __gnu_f2h_ieee to
+	__aeabi_f2h, __gnu_f2h_alternative to __aeabi_f2h_alt, __gnu_h2f_ieee
+	to __aeabi_h2f, and __gnu_h2f_alternative to __aeabi_h2f_alt.
+	* config/arm/fp16.c (__gnu_f2h_internal): Change return type to
+	unsigned int. Change 'sign' variable likewise.
+	(__gnu_h2f_internal): Set to static inline.
+	Change return type to unsigned int. Change 'sign' variable likewise.
+	(ALIAS): New define.
+	(__gnu_f2h_ieee): Change unsigned short to unsigned int.
+	(__gnu_h2f_ieee): Likewise.
+	(__gnu_f2h_alternative): Likewise.
+	(__gnu_h2f_alternative): Likewise.
+	(__aeabi_f2h, __aeabi_h2f): New aliases.
+	(__aeabi_f2h_alt, __aeabi_h2f_alt): Likewise.
+	* config/arm/sfp-machine.h (__extendhfsf2): Set to __aeabi_h2f.
+	(__truncsfhf2): Set to __aeabi_f2h.
+
+	testsuite/
+	* g++.dg/ext/arm-fp16/arm-fp16-ops-5.C: Check for __aeabi_h2f
+	and __aeabi_f2h.
+	* g++.dg/ext/arm-fp16/arm-fp16-ops-6.C: Likewise.
+	* gcc.dg/torture/arm-fp16-ops-5.c: Likewise.
+	* gcc.dg/torture/arm-fp16-ops-6.c: Likewise.
+
+2010-04-10  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #8368
+
+	gcc/testsuite/
+	PR target/43417
+	* gcc.target/sh/pr43417.c: New test.
+
+2010-04-10  Bernd Schmidt  <bernds@codesourcery.com>
+
+	Issue #8388
+
+	gcc/
+	* tree-ssa-remove-local-statics.c (pass_remove_local_statics):
+	Readd TODO_rebuild_alias and TODO_update_ssa.
+
+2010-04-10  Catherine Moore  <clm@codesourcery.com>
+
+	Issue #7474
+
+	* release-notes-csl.xml: New note.
+
+	gcc/
+	* gcc/config.gcc (mips-sde-elf): Enable soft-fp.
+	* gcc/config/mips/t-fprules-softfp: New.
+	* gcc/config/mips/sfp-machine: New.
+
+	* release-notes-csl.xml: New note.
+
+2010-04-09  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #8368
+
+	* release-notes-csl.xml: Document.
+
+	Backport from mainline 4.4:
+
+	gcc/
+	2010-03-21  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline:
+	2009-05-12  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR target/43417
+	* config/sh/sh.md (cbranchdi4_i): Use an "I08" constraint
+	instead of "i" constraint.
+
+2010-04-09  Jie Zhang  <jie@codesourcery.com>
+
+	* release-notes-csl.xml: Document.
+
+	Backport from mainline:
+
+	gcc/cp/
+	2010-04-07  Jie Zhang  <jie@codesourcery.com>
+
+	PR c++/42556
+	* typeck2.c (split_nonconstant_init_1): Drop empty CONSTRUCTOR
+	when all of its elements are non-constant and have been split out.
+
+	gcc/testsuite/
+	2010-04-07  Jie Zhang  <jie@codesourcery.com>
+
+	PR c++/42556
+	* g++.dg/init/pr42556.C: New test.
+
+2010-04-09  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #8224
+
+	* release-notes-csl.xml: Document.
+
+	gcc/
+	From Richard Earnshaw  <rearnsha@arm.com>
+
+	* doc/tm.texi (OVERLAPPING_REGISTER_NAMES): Document new macro.
+	* output.h (decode_reg_name_and_count): Declare.
+	* varasm.c (decode_reg_name_and_count): New function.
+	(decode_reg_name): Reimplement using decode_reg_name_and_count.
+	* reginfo.c (fix_register): Use decode_reg_name_and_count and 
+	iterate over all regs used.
+	* stmt.c (expand_asm_operands): Likewise.
+	* config/arm/aout.h (OVERLAPPING_REGISTER_NAMES): Define.
+	(ADDITIONAL_REGISTER_NAMES): Remove aliases that overlap
+	multiple machine registers.
+
+2010-04-09  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #8224
+
+	* release-notes-csl.xml: Document.
+
+	Backport from mainline:
+
+	gcc/
+	2010-03-21  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/42321
+	* arm.c (arm_output_epilogue): Correctly match VFP pop instructions
+	with their corresponding prologue pushes.
+
+2010-04-08  Bernd Schmidt  <bernds@codesourcery.com>
+
+	* release-notes-csl.xml: Fix spelling of NEON.
+
+2010-04-08  Bernd Schmidt  <bernds@codesourcery.com>
+
+	Issue #6952
+
+	* release-notes-csl.xml: Document.
+
+	gcc/
+	* ira-costs.c (record_reg_classes): Ignore alternatives that are 
+        not enabled. 
+	* config/arm/vfp.md (arm_movdi_vfp): Enable only when not tuning
+	for Cortex-A8.
+	(arm_movdi_vfp_cortexa8): New pattern.
+	* config/arm/neon.md (adddi3_neon, subdi3_neon, anddi3_neon,
+	iordi3_neon, xordi3_neon): Add alternatives to discourage Neon
+	instructions when tuning for Cortex-A8.  Set attribute "alt_tune".
+	* config/arm/arm.md (define_attr "alt_tune", define_attr "enabled"):
+	New.
+
+2010-04-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgcc/
+	* config/rs6000/spe_arith.S: Remove.  Split into:
+	* config/rs6000/spe_adddf3.S: ...this.
+	* config/rs6000/spe_subdf3.S: ...this.
+	* config/rs6000/spe_muldf3.S: ...this.
+	* config/rs6000/spe_divdf3.S: ...this.
+	* config/rs6000/spe_add_exception.S: ...this.
+	* config/rs6000/spe_muldiv_scale2.S: ...and this.
+	* config/rs6000/spe_cmp.S: Remove.  Split into:
+	* config/rs6000/spe_cmpdf2.S: ...this.
+	* config/rs6000/spe_eqdf2.S: ...this.
+	* config/rs6000/spe_nedf2.S: ...this.
+	* config/rs6000/spe_gedf2.S: ...this.
+	* config/rs6000/spe_gtdf2.S: ...this.
+	* config/rs6000/spe_ledf2.S: ...this.
+	* config/rs6000/spe_ltdf2.S: ...this.
+	* config/rs6000/spe_unorddf2.S: ...this.
+	* config/rs6000/spe_unord_sub.S: ...and this.
+	* config/rs6000/spe_cnv.S: Remove.  Split into:
+	* config/rs6000/fixdfdi.S: ...this.
+	* config/rs6000/fixdfsi.S: ...this.
+	* config/rs6000/fixunsdfdi.S: ...this.
+	* config/rs6000/fixunsdfsi.S: ...this.
+	* config/rs6000/floatdidf.S: ...this.
+	* config/rs6000/floatsidf.S: ...this.
+	* config/rs6000/floatundidf.S: ...this.
+	* config/rs6000/floatunsidf.S: ...this.
+	* config/rs6000/extendsfdf2.S: ...this.
+	* config/rs6000/truncdfsf2.S: ...this.
+	* config/rs6000/t-spe-fprules (spe-files): Remove removed files.
+	Add new files.
+
+2010-04-08  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #7122
+
+	gcc/
+	* config/arm/vfp.md (thumb2_movdf_vfp): Require that one of
+	the operands be a register.
+
+	gcc/testsuite/
+	* gcc.target/arm/neon-load-df0.c: Make it usable with
+	-mfloat-abi=softfp.
+
+2010-04-07  Thomas Schwinge  <thomas@codesourcery.com>
+	    Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #6715
+
+	PR debug/40521
+
+	gcc/
+	* dwarf2out.c (NEED_UNWIND_TABLES): Define.
+	(dwarf2out_do_frame, dwarf2out_do_cfi_asm, dwarf2out_begin_prologue)
+	(dwarf2out_frame_finish, dwarf2out_assembly_start): Use it.
+	(dwarf2out_assembly_start): Correct logic for TARGET_UNWIND_INFO.
+	* config/arm/arm.h (DWARF2_UNWIND_INFO): Remove definition.
+	* config/arm/bpabi.h (DWARF2_UNWIND_INFO): Define to zero.
+
+2010-04-07  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #7122
+
+	gcc/testsuite/
+	* gcc.target/arm/neon-vdup-1.c: Make it usable with
+	-mfloat-abi=softfp.
+	* gcc.target/arm/neon-vdup-2.c: Likewise.
+	* gcc.target/arm/neon-vdup-3.c: Likewise.
+	* gcc.target/arm/neon-vdup-4.c: Likewise.
+	* gcc.target/arm/neon-vdup-5.c: Likewise.
+	* gcc.target/arm/neon-vdup-6.c: Likewise.
+	* gcc.target/arm/neon-vdup-7.c: Likewise.
+	* gcc.target/arm/neon-vdup-8.c: Likewise.
+	* gcc.target/arm/neon-vdup-9.c: Likewise.
+	* gcc.target/arm/neon-vdup-10.c: Likewise.
+	* gcc.target/arm/neon-vdup-11.c: Likewise.
+	* gcc.target/arm/neon-vdup-12.c: Likewise.
+	* gcc.target/arm/neon-vdup-13.c: Likewise.
+	* gcc.target/arm/neon-vdup-14.c: Likewise.
+	* gcc.target/arm/neon-vdup-15.c: Likewise.
+	* gcc.target/arm/neon-vdup-16.c: Likewise.
+	* gcc.target/arm/neon-vdup-17.c: Likewise.
+	* gcc.target/arm/neon-vdup-18.c: Likewise.
+	* gcc.target/arm/neon-vdup-19.c: Likewise.
+
+2010-04-07  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #7122
+
+	* release-notes-csl.xml: Document.
+
+	gcc/
+	* config/arm/arm.c (arm_rtx_costs_1): Adjust cost for
+	CONST_VECTOR.
+	(arm_size_rtx_costs): Likewise.
+	(thumb2_size_rtx_costs): Likewise.
+	(neon_valid_immediate): Add a case for double 0.0.
+
+	gcc/testsuite/
+	* gcc.target/arm/neon-vdup-1.c: New test case.
+	* gcc.target/arm/neon-vdup-2.c: New test case.
+	* gcc.target/arm/neon-vdup-3.c: New test case.
+	* gcc.target/arm/neon-vdup-4.c: New test case.
+	* gcc.target/arm/neon-vdup-5.c: New test case.
+	* gcc.target/arm/neon-vdup-6.c: New test case.
+	* gcc.target/arm/neon-vdup-7.c: New test case.
+	* gcc.target/arm/neon-vdup-8.c: New test case.
+	* gcc.target/arm/neon-vdup-9.c: New test case.
+	* gcc.target/arm/neon-vdup-10.c: New test case.
+	* gcc.target/arm/neon-vdup-11.c: New test case.
+	* gcc.target/arm/neon-vdup-12.c: New test case.
+	* gcc.target/arm/neon-vdup-13.c: New test case.
+	* gcc.target/arm/neon-vdup-14.c: New test case.
+	* gcc.target/arm/neon-vdup-15.c: New test case.
+	* gcc.target/arm/neon-vdup-16.c: New test case.
+	* gcc.target/arm/neon-vdup-17.c: New test case.
+	* gcc.target/arm/neon-vdup-18.c: New test case.
+	* gcc.target/arm/neon-vdup-19.c: New test case.
+
+2010-04-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* config.gcc (powerpc-*-eabi*): Use soft-fp/t-softfp.
+
+2010-04-04  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	PR middle-end/40815
+
+	gcc/
+	* tree-ssa-reassoc.c (broken_up_substracts): Rename to plus_negates.
+	(negate_value): Move code to push elements to broken_up_substracts ...
+	(eliminate_plus_minus_pair): ... here.  Push operands that have no
+	negative pair to plus_negates.
+	(repropagate_negates, init_reassoc, fini_reassoc): Update.
+	gcc/testsuite/
+	* gcc.dg/tree-ssa/reassoc-19.c: New.
+
+2010-04-02  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7937
+
+	* release-notes-csl.xml: New note.
+
+	libgcc/
+	* configure.ac: Check for __SPE__ when compiling for powerpc*.
+	* configure: Regenerate.
+	* config.host: Add t-spe-fprules if compiling for SPE.
+	* config/rs6000/t-spe-fprules: New file.
+	* config/rs6000/spe_arith.S: New file.
+	* config/rs6000/spe_cmp.S: New file.
+	* config/rs6000/spe_cnv.S: New file.
+	* config/rs6000?spe_neg.S: New file.
+
+2010-04-02  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* config.gcc (powerpc-*-eabi*): Use rs6000/t-fprules-softfp.
+
+2010-04-01  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gcc/
+	* config/arm/nucleus.h (LINK_SPEC): Add -z defs alongside -shared.
+
+2010-04-01  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #7944
+
+	* release-notes-csl.xml: Document.
+
+	Backporting from mainline:
+
+	gcc/
+	2010-03-31  Jie Zhang  <jie@codesourcery.com>
+
+	PR 43562
+	* reload.h (caller_save_initialized_p): Declare.
+	* toplev.c (backend_init_target): Don't call
+	init_caller_save but set caller_save_initialized_p
+	to false.
+	* caller-save.c (caller_save_initialized_p): Define.
+	(init_caller_save): Check caller_save_initialized_p.
+	* ira.c (ira): Call init_caller_save if flag_caller_saves.
+
+	gcc/testsuite/
+	2010-03-31  Jie Zhang  <jie@codesourcery.com>
+
+	PR 43562
+	* gcc.dg/pr43562.c: New test.
+
+2010-04-01  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #8315
+
+	Backport from mainline:
+
+	gcc/cp/
+	2009-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/41183
+	* cp-tree.h (current_class_ptr): Give NULL even when cfun
+	has NULL cfun->language.
+
+	gcc/testsuite/
+	2009-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/41183
+	* g++.dg/torture/pr41183.C: New test.
+
+2010-03-31  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from FSF:
+
+	gcc/
+	2009-10-10  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* configure.ac: Add test for dci instruction.
+	* configure: Regenerate.
+	* config.in: Likewise.
+	* config.gcc: Handle --with-cpu=476 and --with-cpu=476fp.
+	* doc/invoke.texi: Add cpu_type 476 and 476fp.
+	(-mmulhw): Add 476 to description.
+	(-mdlmzb): Likewise.
+	* config/rs6000/t-fprules (MULTILIB_MATCHES_FLOAT): Include -mcpu=476.
+	* config/rs6000/rs6000.c (processor_costs): Add ppc476_cost.
+	(processor_target_table): Add 476 and 476fp entries.
+	(rs6000_override_options): Use ppc476_cost for PROCESSOR_PPC476.
+	(rs6000_issue_rate): Add CPU_PPC476.
+	* config/rs6000/rs6000.h (ASM_CPU_476_SPEC): Define.
+	(ASM_CPU_SPEC): Pass %(asm_cpu_476) for -mcpu=476 and -mcpu=476fp.
+	(processor_type): Add PROCESSOR_PPC476.
+	(EXTRA_SPECS): Add asm_cpu_476 string.
+	* config/rs6000/rs6000.md: (define_attr "type"): Add isel attribute.
+	(define_attr "cpu"): Add ppc476.
+	Include 476.md.
+	Update comments for 476.
+	(isel_signed, isel_unsigned): Change to use "isel" type attribute.
+	* config/rs6000/vxworks.h (CPP_SPEC): Handle 464 and 476.
+	Update copyright year.
+	* config/rs6000/476.md: New file.
+	* config/rs6000/40x.md: Add description for "isel" attribute.
+	Update copyright year.
+	* config/rs6000/440.md: Likewise.
+	* config/rs6000/603.md: Likewise.
+	* config/rs6000/6xx.md: Likewise.
+	* config/rs6000/7450.md: Likewise.
+	* config/rs6000/7xx.md: Likewise.
+	* config/rs6000/8540.md: Likewise.
+	* config/rs6000/cell.md: Likewise.
+	* config/rs6000/e300c2c3.md: Likewise.
+	* config/rs6000/e500mc.md: Likewise.
+	* config/rs6000/mpc.md: Likewise.
+	* config/rs6000/power4.md: Likewise.
+	* config/rs6000/power5.md: Likewise.
+	* config/rs6000/power6.md: Likewise.
+	* config/rs6000/power7.md: Likewise.
+	* config/rs6000/rios1.md: Likewise.
+	* config/rs6000/rios2.md: Likewise.
+	* config/rs6000/rs64.md: Likewise.
+
+2010-03-30  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #5851
+
+	Backport:
+
+	gcc/
+	2009-06-16  J"orn Rennecke  <joern.rennecke@arc.com>
+		    Janis Johnson  <janis187@us.ibm.com>
+
+	PR target/39254
+	* config/rs6000/rs6000.c (rs6000_emit_move): Don't emit a USE
+	for the symbol ref of a constant that is the source of a move
+	- nor for any other not-obvious-label-ref constants.
+
+2010-03-30  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/arm/t-wrs-linux (MULTILIB_OPTIONS, MULTILIB_DIRNAMES,
+	MULTILIB_EXCEPTIONS, MULTILIB_MATCHES, MULTILIB_ALIASES): Remove
+	handling of -tiwmmxt, -txscale, -tarm920t, -tthumb2 and
+	-tcortex-a8-be8.
+	* config/arm/wrs-linux.h (CC1_SPEC): Remove handling of -tiwmmxt,
+	-txscale, -tarm920t, -tthumb2 and -tcortex-a8-be8.
+	(SUBTARGET_EXTRA_ASM_SPEC, SUBTARGET_EXTRA_LINK_SPEC): Remove.
+	(SYSROOT_SUFFIX_SPEC): Remove handling of -tiwmmxt, -txscale,
+	-tarm920t, -tthumb2 and -tcortex-a8-be8.
+
+2010-03-30  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/mips/t-octeon-elf (MULTILIB_OPTIONS, MULTILIB_DIRNAMES,
+	MULTILIB_EXCEPTIONS): Add Octeon II multilibs.
+	* config/mips/t-wrs-linux (MULTILIB_OPTIONS, MULTILIB_DIRNAMES,
+	MULTILIB_EXCEPTIONS, MULTILIB_OSDIRNAMES): Add Octeon II
+	multilibs.
+	* config/mips/wrs-linux.h (SYSROOT_SUFFIX_SPEC): Handle
+	-march=octeon2.
+
+2010-03-26  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #7127
+
+	* release-notes-csl.xml: Document.
+
+	Backport from mainline:
+
+	gcc/cp/
+	2010-02-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/43024
+	* name-lookup.h (current_binding_level): Check for null
+	cp_function_chain.
+
+	gcc/testsuite/
+	2010-02-14  Volker Reichelt  <reichelt@gcc.gnu.org>
+
+	PR c++/43024
+	* g++.dg/opt/ice1.C: New.
+
+2010-03-24  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #7919
+
+	Backport:
+
+	fixincludes/
+	2010-03-24  Joseph Myers  <joseph@codesourcery.com>
+
+	* inclhack.def (glibc_strncpy): New fix.
+	* fixincl.x: Regenerate.
+	* tests/base/bits/string2.h: Update.
+
+	gcc/testsuite/
+	2010-03-24  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.dg/strncpy-fix-1.c: New test.
+
+2010-03-23  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/
+	* config/mips/mips.c (mips_cpu_info_table): Add m14kc.
+
+2010-03-21  Andrew Jenner  <andrew@codesourcery.com>
+
+	Issue #8092
+
+	libgfortran/
+	* io/unix.c (tempfile): Check fd for -1, not negative.
+	(regular_file): Likewise.
+	(open_external): Likewise.
+	(fallback_access): Likewise.
+
+2010-03-18  Jie Zhang  <jie@codesourcery.com>
+
+	Issue #7122
+
+	* release-notes-csl.xml: Document.
+
+	gcc/
+	* config/arm/vfp.md (movdf_vfp): Add load double 0.0 case.
+	(thumb2_movdf_vfp): Likewise.
+	* config/arm/constraints.md (D0): New constraint.
+
+	gcc/testsuite/
+	* gcc.target/arm/neon-load-df0.c: New test.
+
+2010-03-17  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #8002
+
+	* release-notes-csl.xml (Incorrect code generation bug fix): New note.
+
+	Backport from mainline:
+
+	gcc/
+	2009-11-30  Chao-ying Fu  <fu@mips.com>
+
+	* config/mips/mips-dsp.md (mips_lhx_<mode>): Use sign_extend.
+
+	gcc/testsuite/
+	2009-11-30  Chao-ying Fu  <fu@mips.com>
+
+	* gcc.target/mips/dsp-lhx.c: New test.
+	* gcc.target/mips/dsp-no-lhx.c: New test.
+
+2010-03-12  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/arm/t-wrs-linux (MULTILIB_EXCEPTIONS,  MULTILIB_ALIASES):
+	Enable -muclibc -tthumb2-v7-a-neon multilib.
+
+2010-03-11  Jie Zhang  <jie@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (arm_file_start): Remove unused
+	set_float_abi_attributes.
+
+2010-03-11  Jie Zhang  <jie@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (thumb2_size_rtx_costs): Add missing
+	GET_CODE ().
+
+2010-03-11  Jie Zhang  <jie@codesourcery.com>
+
+	Backport from upstream:
+
+	gcc/
+	2010-03-09  Jie Zhang  <jie@codesourcery.com>
+
+	* config/arm/arm.md (thumb_mulsi3_v6): Remove trailing
+	whitespaces in output template.
+
+2010-03-11  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #7999
+
+	libstdc++/
+	* configure.host (arm*-*-nucleauseabi): Add arm-eabi-extra.ver.
+	* config/os/nucleus/arm-eabi-extra.ver: New.
+
+2010-03-10  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/arm/t-wrs-linux (MULTILIB_OPTIONS, MULTILIB_DIRNAMES,
+	MULTILIB_EXCEPTIONS, MULTILIB_ALIASES): Add v7-A multilibs.
+	* config/arm/wrs-linux.h (CC1_SPEC, SYSROOT_SUFFIX_SPEC):
+	Likewise.
+
+2010-03-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Revert:
+
+	gcc/
+	2010-03-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* config/rs6000/rs6000.md (define_insn ""): Disable on TARGET_ISEL targets.
+
+2010-03-09  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #7940
+	Backport 2009-10-14  Jakub Jelinek  <jakub@redhat.com>
+	
+	gcc/
+	PR preprocessor/41543
+	* input.h (BUILTINS_LOCATION): Change to 1 from 2.
+	Assert BUILTINS_LOCATION < RESERVED_LOCATION_COUNT.
+	* tree.c: Include intl.h.
+	(expand_location): Handle BUILTINS_LOCATION.
+	* Makefile.in (tree.o): Depend on intl.h.
+
+	gcc/testsuite/
+	PR preprocessor/41543
+	* gcc.dg/debug/dwarf2/pr41543.c: New test.
+
+	libcpp/
+	PR preprocessor/41543
+	* include/line-map.h (RESERVED_LOCATION_COUNT): Define.
+	* line-map.c (linemap_init): Initialize highest_location and
+	highest_line to RESERVED_LOCATION_COUNT-1 instead of 0.
+
+	* release-notes-csl.xml: Document.
+
+2010-03-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/testsuite/
+	2009-12-07  Edmar Wienskoski  <edmar@freescale.com>
+
+	* gcc.target/powerpc/ppc-eq0-1.c: Adjust testcase for isel
+	targets.
+
+2010-03-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.target/powerpc/block-move-1.c (memcpy): Declare.
+	* gcc.target/powerpc/block-move-2.c (memcpy): Likewise.
+
+2010-03-09  Paul Brook  <paul@codesourcery.com>
+
+	* release-notes-csl.xml: Add missing Cortex-M4 note.
+
+2010-03-08  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* doc/invoke.texi: Document ARM -mcpu=cortex-m4.
+	* config/arm/arm.c (all_architectures): Change v7e-m default to
+	cortexm4.
+	* config/arm/arm-cores.def: Add cortex-m4.
+	* config/arm/arm-tune.md: Regenerate.
+
+2010-03-08  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config/arm/t-cs-eabi (MULTILIB_MATCHES): Add cortex-m4.
+	* config/arm/t-cs-eabi-lite (MULTILIB_MATCHES): Ditto.
+	* config/arm/t-cs-uclinux-eabi (MULTILIB_MATCHES): Ditto.
+
+2010-03-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7183
+
+	* config/rs6000/rs6000.c (rs6000_emit_int_cmove): Don't force_reg on
+	const0_rtx operand.
+	* config/rs6000/rs6000.md (isel_signed, isel_unsigned): Permit
+	const_int 0 for the second operand; make third operand slightly more
+	lenient.
+	(define_insn ""): Disable on TARGET_ISEL targets.
+
+2010-03-08  Julian Brown  <julian@codesourcery.com>
+
+	* release-notes-csl.xml (Thumb-2 size optimization improvements): Add
+	note.
+
+2010-03-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7183
+
+	* release-notes-csl.xml: New notes.
+
+	gcc/
+	* doc/invoke.texi (mblock-move-inline-limit): Tweak @opindex directive.
+	Tweak text to reflect target-specific setting of this option.
+
+2010-03-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7792
+
+	Backport from upstream:
+
+	gcc/
+	2009-09-10  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* config/rs6000/rs6000.h (DATA_ALIGNMENT): Check that we are dealing
+	with actual SPE/paired vector modes before using 64-bit alignment.
+	Check that TYPE is a REAL_TYPE for TARGET_E500_DOUBLE.
+
+2010-03-04  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7183
+
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_emit_int_cmove): Change prototype.
+	Ensure that isel pattern is only emitted with proper conditions.
+	(rs6000_emit_cmove): Change call to rs6000_emit_int_cmove to match.
+	(output_isel): Check that condition is LT, GT, LTU, GTU, or EQ.
+	(rs6000_emit_sISEL): New function.
+	(rs6000_emit_sCOND): Call it if computing an SImode result.
+	(rs6000_rtx_costs): Alter costs for comparisons for TARGET_ISEL.
+	* config/rs6000/rs6000.md (abssi2_isel): Change pattern to use
+	lt rather than ge.
+	(isel_signed, isel_unsigned): Tighten constraints on comparison
+	operator.
+	(sne, sge, sgt, sle, slt): Check TARGET_ISEL.
+
+2010-03-04  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7183
+
+	gcc/
+	* config/rs6000/rs6000.opt (mblock-move-inline-limit=): New option.
+	* config/rs6000/rs6000.c (rs6000_override_options): Set
+	rs6000_block_move_inline_limit.
+	* doc/invoke.texi (-mblock-move-inline-limit): Document.
+	
+	gcc/testsuite/
+	* gcc.target/powerpc/block-move-1.c: New test.
+	* gcc.target/powerpc/block-move-2.c: New test.
+
+2010-03-02  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* tree-ssa-remove-local-statics.c (check_definedness): Pass NO_INSERT
+	to htab_find_slot.  Make necessary changes as a result of doing so.
+	(compute_definedness_for_block): Likewise.
+
+2010-03-02  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #7928
+	
+	* libtool.4 (nucleuseabi): Set deplibs check method.
+
+	libstdc++-v3/
+	* configure: Rebuilt.
+
+2010-03-01  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7788
+
+	gcc/
+	* tree-ssa-remove-local-statics.c (check_definedness): Dump the
+	defined bitmap and information about the decl if debugging.
+	Do not clear the hash table slot; instead, set decl->optimizable_p
+	to false.
+	(unstaticize_variable): Finish if we can't optimize.
+	(execute_rls): Only do TODO_rebuild_alias and TODO_update_ssa if
+	we optimized anything.
+	(pass_remove_local_statics): Remove TODO_rebuild_alias and
+	TODO_update_ssa.
+
+2010-02-28  Mark Mitchell  <mark@codesourcery.com>
+
+	Issue #7791
+
+	Backport from mainline:
+
+	gcc/cp/
+	2010-02-27  Mark Mitchell  <mark@codesourcery.com>
+
+	PR c++/42748
+	* cp-tree.h (push_tinst_level): Declare.
+	(pop_tinst_level): Likewise.
+	* pt.c (push_tinst_level): Give it external linkage.
+	(pop_tinst_level): Likewise.
+	* mangle.c (mangle_decl_string): Set the source location to that
+	of the decl while mangling.
+
+	gcc/testsuite/
+	2010-02-27  Mark Mitchell  <mark@codesourcery.com>
+
+	PR c++/42748
+	* g++.dg/abi/mangle11.C: Adjust mangling warning locations.
+	* g++.dg/abi/mangle12.C: Likewise.
+	* g++.dg/abi/mangle20-2.C: Likewise.
+	* g++.dg/abi/mangle17.C: Likewise.
+	* g++.dg/template/cond2.C: Likewise.
+	* g++.dg/template/pr35240.C: Likewise.
+
+2010-02-25  Daniel Jacobowitz  <dan@codesourcery.com>
+	    Pedro Alves  <pedro@codesourcery.com>
+
+	libiberty/
+	* cygpath.c (IMAGE_IMPORT_MODULE_DIRECTORY)
+	(PIMAGE_IMPORT_MODULE_DIRECTORY, IMAGE_DIRECTORY_ENTRY_IMPORT): New.
+	(msvcrt_dll): Use GetModuleHandle instead of
+	LoadLibrary.  Check the import table to figure out which C
+	runtime to use.
+	(msvcrt_stat): New function.  Check for _stat32, _stat64i32,
+	and _stat.
+	(stat): Use msvcrt_stat.
+
+2010-02-25  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* config/sh/sh.c (sh_output_mi_thunk): Adjust sibcalls for FDPIC.
+	* config/sh/sh.md (sibcalli_pcrel): Add !TARGET_FDPIC condition.
+	(sibcalli_pcrel_fdpic): New insn.
+	(sibcall_pcrel_fdpic): New insn.
+	(sibcall): Adjust for FDPIC.
+	(sibcall_valuei_pcrel): Add !TARGET_FDPIC condition.
+	(sibcall_valuei_pcrel_fdpic): New insn.
+	(sibcall_value_pcrel): Add !TARGET_FDPIC condition.
+	(sibcall_value_pcrel_fdpic): New insn.
+	(sibcall_value): Adjust for FDPIC.
+
+2010-02-25  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gcc/
+	* tree.c (initializer_zerop): Handle STRING_CST.
+
+2010-02-24  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* config/sh/sh.c (legitimize_pic_address): Use GOTFUNCDESC for weak
+	symbols.
+
+2010-02-24  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/
+	* config/mips/t-sgxx-linux (MULTILIB_EXTRA_OPTS): Remove.
+	* config/mips/t-sgxxlite-linux (MULTILIB_EXTRA_OPTS): Remove.
+
+2010-02-24  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/
+	* config/mips/linux.h (SUBTARGET_CC1_SPEC): Pass -mno-jals
+	in the absence of -mjals.
+	* config/mips/mips.opt (mjals): Fix typo.
+
+	* release-notes-csl.xml: Document.
+
+2010-02-23  Julian Brown  <julian@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (thumb2_size_rtx_costs): New.
+	(arm_rtx_costs): Call above for Thumb-2.
+
+2010-02-23  Julian Brown  <julian@codesourcery.com>
+
+	gcc/
+	* calls.c (precompute_register_parameters): Avoid generating a
+	register move if optimizing for size.
+
+2010-02-20  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/mips/linux-unwind.h (mips_fallback_frame_state): Return
+	early if pc not 4-byte aligned.
+
+2010-02-19  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* configure.ac (gcc_cv_libc_provides_ssp): Set to yes for
+	GNU/Linux targets with libssp disabled.
+	* configure: Regenerate.
+
+2010-02-19  Julian Brown  <julian@codesourcery.com>
+
+	Issue #7760
+
+	gcc/cp/
+	* mangle.c (mangle_decl_string): Set input location to location of
+	decl.
+
+2010-02-18  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	* release-notes-csl.xml: s/M14KC/M14Kc/.
+
+2010-02-17  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gcc/
+	* config/arm/nucleus.h (STARTFILE_SPEC, ENDFILE_SPEC): Add shared
+	crtbegin, crtend bits.
+	* config/arm/t-nucleus: New.
+	* config.gcc (arm-samsung-nucleuseabi): Add t-nucleus fragment.
+
+2010-02-16  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config.gcc (arm*-*-symbianelf*): Add t-bpabi to t-symbian.
+	* config/arm/symbian.h (RENAME_LIBRARY): Remove.
+	* config/arm/lib1funcs.asm: Remove __symbian__ conditionals.
+	* config/arm/libunwind.S: Ditto.
+	* config/arm/t-symbian (LIB1ASMFUNCS): Remove.
+	(UNWIND_H, LIB2ADDEH, LIB2ADDEHDEP): Remove.
+	(LIB2FUNCS_STATIC_EXTRA): Remove.
+	(LIB2FUNCS_EXTRA): Add eabi-memcpy.c and eabi-memset.c.
+	* config/arm/eabi-memcpy.c: New file.
+	* config/arm/eabi-memset.c: New file.
+
+	libstdc++-v3/
+	* libsupc++/Makefile.am (sources): Add vec.cc when LIBSUPCXX_PRONLY.
+	* libsupc++/Makefile.in: Regenerate.
+
+2010-02-16  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	libiberty/
+	* cygpath.c (cygpath): If cygpath exits, retry on the next request.
+
+2010-02-16  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* release-notes-csl.xml: Document microMIPS.
+
+2010-02-15  Julian Brown  <julian@codesourcery.com>
+
+	Issue #7329
+
+	* release-notes-csl.xml (Improved code generation for Cortex-A9): Add
+	note.
+
+	Backport from mainline:
+
+	Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	gcc/
+	* config/arm/cortex-a9.md: New - integer pipeline description.
+
+2010-02-15  Julian Brown  <julian@codesourcery.com>
+
+	Issue #7486
+
+	gcc/
+	* config/arm/arm.c (arm_libcall_value, arm_init_cumulative_args):
+	Use correct ABI for double-precision helper functions in hard-float
+	mode if only single-precision arithmetic is supported in hardware.
+
+2010-02-11  Julian Brown  <julian@codesourcery.com>
+
+	Issue #3685
+
+	* release-notes-csl.xml (Thumb-2 function call optimization): Add
+	note.
+
+2010-02-11  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* config/sh/uclinux.h (STARTFILE_SPEC): Append FDPIC_STARTFILE_SPEC.
+	(FDPIC_STARTFILE_SPEC): New define.
+
+2010-02-09  Julian Brown  <julian@codesourcery.com>
+	    Mark Mitchell  <mark@codesourcery.com>
+
+	Issue #3685
+
+	gcc/
+	* config/arm/arm.c (arm_function_ok_for_sibcall): Allow sibling
+	calls for Thumb-2.
+	(output_return_instruction): Use pop not ldmfd for Thumb-2.
+	* config/arm/arm.h (USE_RETURN_INSN): Enable for Thumb-2.
+	* config/arm/arm.md (*call_symbol, *call_value_symbol): Use for
+	Thumb-2.
+	(*call_insn, *call_value_insn): Don't use for Thumb-2.
+	(sibcall, sibcall_value, *sibcall_insn, *sibcall_value_insn): Use
+	for Thumb-2.
+	(return): New expander.
+	(*arm_return): New name for ARM return insn.
+	(*thumb2_return): New insn pattern.
+
+2010-02-09  Julian Brown  <julian@codesourcery.com>
+
+	Issue #7336, #7568
+
+	* release-notes-csl.xml (Thumb-2 internal compiler error fix)
+	(Thumb-2 multiply fix): New notes.
+
+2010-02-09  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/mips/t-sgxxlite-linux (MULTILIB_OPTIONS,
+	MULTILIB_DIRNAMES): Add microMIPS multilibs.
+	(MULTILIB_EXCEPTIONS, MULTILIB_EXTRA_OPTS): New.
+	* config/mips/cs-sgxxlite-linux.h (SYSROOT_SUFFIX_SPEC): Update.
+	* config/mips/t-sgxx-linux (MULTILIB_OPTIONS, MULTILIB_DIRNAMES,
+	MULTILIB_EXCEPTIONS): Add microMIPS multilibs.
+	(MULTILIB_EXTRA_OPTS): New.
+	* config/mips/cs-sgxx-linux.h (SYSROOT_SUFFIX_SPEC): Update.
+
+2010-02-09  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gcc/
+	* config/arm/nucleus.h (LINK_SPEC): Check -shared too.
+
+2010-02-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/
+	2009-06-25  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR target/38731
+	* config/rs6000/rs6000.c (LOCAL_ALIGNMENT): Redefine to just use
+	DATA_ALIGNMENT instead.
+
+2010-02-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7587
+
+	* release-notes-csl.xml: New note.
+
+	Backport from mainline:
+
+	gcc/
+	2010-02-05  Nathan Froyd  <froydnj@codesourcery.com>
+	
+	* config/rs6000/rs6000.c (rs6000_override_options): Invert check
+	for rs6000_gen_cell_microcode.
+
+2010-02-04  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #7660
+
+	gcc/
+	* config/arm/arm.h (FUNCTION_BOUNDARY): Set minimal allowed alignment
+	for THUMB mode when optimizing for space.
+
+2010-02-04  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Backport from mainline (for thumb2 size reduction):
+
+	gcc/
+	2009-11-22  Richard Earnshaw  <rearnsha@arm.com>
+	* opts.c (decode_options): Don't enable flag_schedule_insns 
+	when optimizing for size.
+	* doc/invoke.texi: Document change.
+
+2010-02-04  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #7197 - backtrace() through throw()
+
+	* release-notes-csl.xml (Improved backtrace function): New
+	note.
+
+	libstdc++-v3/
+	* libsupc++/eh_personality.cc (PERSONALITY_FUNCTION): For
+	ARM EABI, skip handlers for _US_VIRTUAL_UNWIND_FRAME
+	| _US_FORCE_UNWIND.
+
+2010-02-03  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue #6472
+
+	gcc/
+	* config/arm/lib1funcs.asm (__ARM_ARCH__): __ARM_ARCH_7EM__
+	added to the preprocessor condition.
+
+2010-02-02  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/mips/linux.h (SUBTARGET_OVERRIDE_OPTIONS): Set
+	TARGET_INTERLINK_MIPS16.
+
+2010-02-01  Julian Brown  <julian@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.md (*arm_cmpdi_insn, *arm_cmpdi_zero)
+	(*thumb_cmpdi_zero): Remove extraneous parallel around rtx patterns.
+
+2010-01-29  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* libtool.m4 (nucleus*): Add shared library logic.
+
+	gcc/
+	* config.gcc (arm*-*-nucleuseabi*): Add nucleus and shared library
+	logic.
+	* config/arm/nucleus.h: New.
+
+	libstdc++-v3/
+	* configure: Regenerated.
+
+2010-01-24  Mark Mitchell  <mark@codesourcery.com>
+
+	Backport from mainline:
+	
+	2010-01-24  Mark Mitchell  <mark@codesourcery.com>
+
+	PR c++/42748
+	* config/arm/arm.c (arm_mangle_type): Do not warn about changes to
+	mangling of va_list in system headers.
+
+	2010-01-24  Mark Mitchell  <mark@codesourcery.com>
+
+	PR c++/42748
+	* g++.dg/abi/arm_va_list2.C: New test.
+	* g++.dg/abi/arm_va_list2.h: Companion header file.
+
+	* release-notes-csl.xml: Document.
+	
+2010-01-13  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #6401
+
+	Backport from mainline:
+
+	boehm-gc/
+	2009-07-17  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR boehm-gc/40785
+	* include/private/gc_locks.h (GC_test_and_set): If GCC 4.4, use
+	the __sync_lock_test_and _set and __sync_lock_release builtins on
+	the powerpc.  If not GCC 4.4, fix up the constraints so that it
+	builds without error.
+	(GC_clear): Ditto.
+
+2010-01-11  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #6964
+	* release-notes-csl.xml (Improved NEON code generation): New note.
+
+2010-01-11  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	Issue #4656
+	Backport from FSF:
+
+	gcc/
+	2009-04-18  Adam Nemet  <anemet@caviumnetworks.com>
+	* config/mips/mips.c (mips_final_postscan_insn): Make it static.
+
+	gcc/
+	2009-04-10  Chao-ying Fu  <fu@mips.com>
+	* doc/tm.texi (Instruction Output): Document
+	TARGET_ASM_FINAL_POSTSCAN_INSN.
+	* target.h (final_postscan_insn): New field in asm_out.
+	* target-def.h (TARGET_ASM_FINAL_POSTSCAN_INSN): New define.
+	(TARGET_ASM_OUT): Add TARGET_ASM_FINAL_POSTSCAN_INSN.
+	* final.c (final_scan_insn): Call
+	targetm.asm_out.final_postscan_insn after outputting
+	an asm macro and a normal instruction.
+
+	* config/mips/mips.h (FINAL_PRESCAN_INSN): New define.
+	* config/mips/mips-protos.h (mips_final_prescan_insn): Declare.
+	* config/mips/mips.c (mips_at_reg_p): New for_each_rtx callback.
+	(mips_final_prescan_insn, mips_final_postscan_insn): New functions.
+	(TARGET_ASM_FINAL_POSTSCAN_INSN): New define.
+
+	* release-notes-csl.xml
+	(Interrupt handler code generation bug fix): New.
+
+2010-01-08  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #6964
+
+	gcc/
+	* config/arm/neon.md (UNSPEC_VADD): Delete.
+	(UNSPEC_VMLA): Delete.
+	(UNSPEC_VMLS): Delete.
+	(UNSPEC_VMUL_N): Delete.
+	(UNSPEC_VSUB): Delete.
+	(adddi3_neon): New.
+	(subdi3_neon): New.
+	(mul<mode>3add<mode>_neon): Make a named insn.
+	(mul<mode>3<neg>add<mode>_neon): Likewise.
+	(neon_vadd<mode>): Turn into define_expand, get rid of unspec.
+	(neon_vmla<mode>): Likewise.
+	(neon_vmls<mode>): Likewise.
+	(neon_vsub<mode>): Likewise.
+	* config/arm/arm.md (arm_adddi3): Don't use for TARGET_NEON.
+	(arm_subdi3): Likewise.
+
+2010-01-08  Chao-ying Fu  <fu@mips.com>
+	    Catherine Moore  <clm@codesourcery.com>
+
+	gcc/
+	* config/mips/mips-protos.h (micromips_load_store_pair_p): Add
+	argument.
+	* config/mips/mips.c (micromips_load_store_pair_p): New
+	argument swap_p.  Check for base + offset.  Check for
+	anti-dependence.
+	* config/mips/micromips.md: Adjust callers of
+	micromips_load_store_p to pass additional argument.
+	
+2010-01-08  Daniel Jacobowitz  <dan@codesourcery.com>
+	    Julian Brown  <julian@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (arm_canonicalize_comparison): Canonicalize DImode
+	comparisons.  Adjust to take both operands.
+	(arm_select_cc_mode): Handle DImode comparisons.
+	(arm_gen_compare_reg): Generate a scratch register for DImode
+	comparisons which require one.  Use xor for Thumb equality checks.
+	(arm_const_double_by_immediates): New.
+	(arm_print_operand): Allow 'Q' and 'R' for constants.
+	(get_arm_condition_code): Handle new CC_CZmode and CC_NCVmode.
+	* config/arm/arm.h (CANONICALIZE_COMPARISON): Always use
+	arm_canonicalize_comparison.
+	* config/arm/arm-modes.def: Add CC_CZmode and CC_NCVmode
+	* config/arm/arm-protos.h (arm_const_double_by_immediates): Declare.
+	(arm_canonicalize_comparison): Update prototype.
+	* config/arm/constraints.md (Di): New constraint.
+	* config/arm/predicates.md (arm_immediate_di_operand)
+	(arm_di_operand, cmpdi_operand): New.
+	* config/arm/arm.md (*arm_cmpdi_insn, *arm_cmpdi_unsigned)
+	(*arm_cmpdi_zero, *thumb_cmpdi_zero): New insns.
+	(cmpdi): Handle non-Cirrus also.
+	(bgt, ble, bgtu, bleu, sgt, sle, sgtu, sleu): Reverse DImode
+	comparisons.
+
+2010-01-08  Julian Brown  <julian@codesourcery.com>
+
+	gcc/
+	* config/arm/thumb2.md (*thumb2_addsi3_compare0): New.
+	(*thumb2_addsi3_compare0_scratch): New.
+	* config/arm/constraints.md (Pu): New.
+	* config/arm/arm.md (*addsi3_compare0): Remove FIXME comment. Use
+	for ARM mode only.
+	(*addsi3_compare0_scratch): Likewise.
+
+2010-01-07  Julian Brown  <julian@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-12-05  Richard Earnshaw  <rearnsha@arm.com>
+
+	gcc/
+	* config/arm/thumb2.md (thumb2_mulsi_short_compare0_scratch): Use a
+	low register for the scratch.
+
+2010-01-07  Julian Brown  <julian@codesourcery.com>
+
+	Issue #7336
+	Backport from mainline:
+
+	2009-12-02  Richard Earnshaw  <rearnsha@arm.com>
+
+	gcc/
+	* config/arm/thumb2.md (thumb_andsi_not_shiftsi_si): Final condition
+	should be TARGET_THUMB2.
+
+2010-01-06  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #7450
+
+	* release-notes-csl.xml (-pthread compiler option fix): New note.
+
+	gcc/
+	* config/m68k/uclinux.h (LIB_SPEC): Bring in sync with config/linux.h.
+
+2010-01-05  Joseph Myers  <joseph@codesourcery.com>
+
+	* configure.ac: Handle arm*-*-nucleuseabi.
+	* configure: Regenerate.
+
+	gcc/
+	* config.gcc: Handle arm*-*-nucleuseabi*.
+
+	libgcc/
+	* config.host: Handle arm*-*-nucleuseabi*.
+
+2010-01-02  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/mips/t-sgxx-linux (MULTILIB_OPTIONS, MULTILIB_DIRNAMES,
+	MULTILIB_EXCEPTIONS): Add microMIPS multilibs.
+	(MULTILIB_EXTRA_OPTS): New.
+	* config/mips/cs-sgxx-linux.h (SYSROOT_SUFFIX_SPEC): Update.
+
+2009-12-30  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/mips/t-sgxxlite-linux (MULTILIB_OPTIONS,
+	MULTILIB_DIRNAMES): Add microMIPS multilibs.
+	(MULTILIB_EXCEPTIONS, MULTILIB_EXTRA_OPTS): New.
+	* config/mips/cs-sgxxlite-linux.h (SYSROOT_SUFFIX_SPEC): Update.
+
+2009-12-29  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #5785
+
+	* release-notes-csl.xml (Code size with -g): New note.
+
+	gcc/
+	Backport from FSF 4.4:
+
+	2009-10-19  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline:
+	2009-10-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/40521
+	* debug.h (struct gcc_debug_hooks): Add assembly_start hook.
+	* cgraphunit.c (cgraph_optimize): Call it.
+	* dwarf2out.c (dwarf2out_init): Move .cfi_sections printing into...
+	(dwarf2out_assembly_start): ... here.  New hook.
+	(dwarf2out_debug_hooks): Add dwarf2out_assembly_start.
+	* debug.c (do_nothing_debug_hooks): Do nothing for assembly_start
+	hook.
+	* dbxout.c (dbx_debug_hooks, xcoff_debug_hooks): Likewise.
+	* sdbout.c (sdb_debug_hooks): Likewise.
+	* vmsdbgout.c (vmsdbg_debug_hooks): Add vmsdbgout_assembly_start.
+	(vmsdbgout_assembly_start): New hook.
+
+	2009-10-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/40521
+	* dwarf2out.c (dwarf2out_init): Test whether
+	HAVE_GAS_CFI_SECTIONS_DIRECTIVE is non-zero instead of checking
+	it is defined.
+
+	2009-10-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/40521
+	* configure.ac (HAVE_GAS_CFI_SECTIONS_DIRECTIVE): New test.
+	* configure: Regenerated.
+	* config.in: Regenerated.
+	* dwarf2out.c (dwarf2out_do_cfi_asm): Return false if
+	!HAVE_GAS_CFI_SECTIONS_DIRECTIVE and not emitting .eh_frame.
+	(dwarf2out_init): If HAVE_GAS_CFI_SECTIONS_DIRECTIVE and
+	not emitting .eh_frame, emit .cfi_sections .debug_frame
+	directive.
+
+2009-12-28  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #7431
+
+	gcc/testsuite/
+	* gcc.target/arm/neon-vmov_ns64.c: Add explicit return statement.
+	* gcc.target/arm/neon-vmov_nu64.c: Likewise.
+	* gcc.target/arm/neon-vdup_ns64.c: Likewise.
+	* gcc.target/arm/neon-vdup_nu64.c: Likewise.
+	* gcc.target/arm/neon-vget_lanes64.c: Likewise.
+	* gcc.target/arm/neon-vget_laneu64.c: Likewise.
+	* gcc.target/arm/neon-vset_lanes64.c: Likewise.
+	* gcc.target/arm/neon-vset_laneu64.c: Likewise.
+
+2009-12-28  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #6964
+
+	gcc/
+	* config/arm/neon.md (UNSPEC_VDUP_LANE): Delete.
+	(V_double_vector_mode): New.
+	(neon_vdup_nv2di): Merge with neon_vdup_lanev2di, adjusting
+	the pattern from the latter to be predicable for consistency.
+	(neon_vdup_lane<mode>_internal): New.
+	(neon_vdup_lane<mode>): Turn into a define_expand and rewrite
+	to avoid using an unspec.
+	(neon_vdup_lanedi): Rewrite RTL pattern to avoid unspec.
+	(neon_vdup_lanev2di): Turn into a define_expand.
+	* config/arm/neon.ml (Vdup_n): Add No_op attribute for v2di case.
+	(Vmov_n): Likewise.
+	
+	gcc/testsuite/
+	* gcc.target/arm/neon/vmovQ_ns64.c: Regenerated.
+	* gcc.target/arm/neon/vmovQ_nu64.c: Regenerated.
+	* gcc.target/arm/neon/vdupQ_ns64.c: Regenerated.
+	* gcc.target/arm/neon/vdupQ_nu64.c: Regenerated.
+	* gcc.target/arm/neon-vdupQ_lanes64.c: New.
+	* gcc.target/arm/neon-vdupQ_laneu64.c: New.
+	* gcc.target/arm/neon-vdupQ_ns64.c: New.
+	* gcc.target/arm/neon-vdupQ_nu64.c: New.
+	* gcc.target/arm/neon-vmovQ_ns64.c: New.
+	* gcc.target/arm/neon-vmovQ_nu64.c: New.
+
+2009-12-22  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from micromips branch:
+
+	2009-10-23  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	gcc/
+	* config/mips/mips.opt (mjals): Fix a typo.
+
+	2009-10-23  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	gcc/
+	2009-10-01  Chao-ying Fu  <fu@mips.com>
+	* config/mips/mips.opt (TARGET_JALS): Set to 1 by default.
+	* config/mips/mips.md (indirect_jump<mode>): Use JR for
+	microMIPS.
+	(tablejump<mode>): Likewise.
+	* config/mips/micromips.md (peephole2): New patterns for the
+	MOVEP instruction.
+	(*movepsisi, *movepsisf, *movepsfsi, *movepsfsf): Likewise.
+	* config/mips/mips-protos.h (micromips_movep_target_p): New
+	prototype.
+	* config/mips/mips.c (micromips_movep_target_p): New function.
+
+	* passes.c (init_optimization_passes): Run pass_peephole2 after
+	pass_sched2 too.
+
+	gcc/testsuite/
+	2009-10-23  Maciej W. Rozycki  <macro@codesourcery.com>
+	* gcc.target/mips/near-far-1.c: Adjust scan-assembler to handle
+	the JALS instruction.
+	* gcc.target/mips/near-far-2.c: Likewise.
+
+	2009-10-23  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	gcc/
+	* config/mips/t-sgxx-sde (MULTILIB_EXTRA_OPTS): New variable,
+	set to "mno-jals".
+
+	2009-07-30  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	gcc/
+	2009-07-30  Chao-ying Fu  <fu@mips.com>
+	* config/mips/mips.h (MIPS_ISA_LEVEL_SPEC): Add march=m14k* to
+	-mips32r2 targets.
+
+	2009-07-17  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	gcc/
+	2009-07-17  Chao-ying Fu  <fu@mips.com>
+	* config/mips/mips.opt (mmucon): Rename to...
+	(mmcu): ... this.  Replace MUCON with MCU.
+	* config/mips/mips.h (TARGET_CPU_CPP_BUILTINS): Update
+	accordingly.
+	(ASM_SPEC): Likewise.
+	* doc/invoke.texi (MIPS Options): Likewise.
+
+	2009-07-17  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	gcc/
+	2009-07-17  Chao-ying Fu  <fu@mips.com>
+	* config/mips/mips.h (MIPS_ARCH_FLOAT_SPEC): Add march=m14k* to
+	-msoft-float targets.
+	* config/mips/sdemtk.h (MIPS_ARCH_FLOAT_SPEC): Likewise.
+	
+	2009-07-10  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* config/mips/mips.c (micromips_build_save_restore): Mark the
+	built PARALLEL as RTX_FRAME_RELATED_P.
+
+	2009-06-30  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/testsuite/
+	2009-06-30  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* gcc.dg/tree-ssa/gen-vect-25.c (n): New variable.
+	(main): Pass n to main_1 instead.
+	* gcc.dg/tree-ssa/gen-vect-28.c (off): New variable.
+	(main_1): New function, split off from...
+	(main): ...here.  Pass `off' to main_1 instead.
+
+	2009-06-30  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* config/mips/mips.md (clear_hazard): Remove TARGET_MICROMIPS code.
+
+	2009-06-30  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* config/mips/mips.md (clear_hazard): Don't use <d>.
+
+	2009-06-30  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* config/mips/mips-protos.h (micromips_load_store_pair_p): Adjust
+	prototype.
+	* config/mips/mips.c (micromips_load_store_pair_p): Add check for
+	invalid load instruction.
+	* config/mips/micromips.md (*lwp, *swp): Adjust calls to
+	micromips_load_store_pair_p.
+
+	2009-06-09  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Port 2009-05-28 Chao-ying Fu <fu@mips.com>
+	gcc/
+	* config/mips/mips.c (mips_address_insns): Add a new parameter
+	check_micromips_12bit_p.
+	(mips_load_store_insns): Pass false to mips_address_insns for the new
+	parameter.
+	(mips_rtx_costs): Pass false to mips_address_insns for the new
+	parameter.
+	(mips_address_costs): Pass false to mips_address_insns for the new
+	parameter.
+	* config/mips/constraints.md (YC): New memory constraint.
+	(YD): New address constraint.
+	* config/mips/mips-protos.h (mips_address_insns): Add a new parameter.
+	* doc/md.texi (Constraints for Particular Machines): Document YC.
+	* config/mips/mips.md (mov_<load>l, mov_<load>r, mov_<store>l,
+	mov_<store>r): Use YC, instead of m.
+	(prefetch): Use YD, instead of p.
+	(sync_compare_and_swap<mode>, sync_add<mode>, sync_sub<mode>,
+	sync_old_add<mode>, sync_old_sub<mode>, sync_new_add<mode>,
+	sync_new_sub<mode>, sync_<optab><mode>, sync_old_<optab><mode>,
+	sync_new_<optab><mode>, sync_nand<mode>, sync_old_nand<mode>,
+	sync_new_nand<mode>, sync_lock_test_and_set<mode>): Use YC,
+	instead of R for memory constraints.
+
+	gcc/
+	* config/mips/t-sgxx-sde (MULTILIB_OPTIONS): Add mmicromips.
+	(MULTILIB_DIRNAMES): Add micromips.
+	(MULTILIB_EXCLUSIONS): Exclude -mcode-readable=no when !mips16.
+	(MULTILIB_EXCEPTIONS): Remove no-float and fp-64 micromips libraries.
+
+	Port 2009-05-13  Chao-ying Fu  <fu@mips.com>
+	gcc/
+	* doc/extend.texi (Declare Attributes of Functions): Add "micromips"
+	and "nomicromips".
+	* doc/invoke.texi (MIPS Options): Add "-mmicromips"/"-mno-mmicromips",
+	"-mmucon"/"-mno-mucon", and "-mjals"/"-mno-jals".
+	Add "m14k" for processor names.
+	Update descriptions for "-minterlink-mips16" for microMIPS.
+	Document "-mmicromips"/"-mno-mmicromips".
+	Document "-mmucon"/"-mno-mucon".
+	Document "-mjals"/"-mno-jals".
+	* config/mips/micromips.md (*store_word_multiple, *load_word_multiple):
+	New instructions for save to/load from the stack.
+	New peephole2 to match load/store word pair.
+	(*lwp, *swp): New instructions for load/store word pair.
+	(mips_jraddiusp): New instruction.
+	* config/mips/crtn.asm: Add labels of "init" and "fini", as
+	objdump needs labels before microMIPS/MIPS16 instructions to dump
+	instructions correctly.
+	* config/mips/mips.md (micromips_type): New attribute for 16-bit
+	microMIPS instructions.
+	(*add<mode>3): Set micromips_type to add.
+	(sub<mode>3): Set micromips_type to sub.
+	(one_cmpl<mode>2): Set micromips_type to logical_not.
+	(*and<mode>3): Set micromips_type to logical_and.
+	(*ior<mode>3): Set micromips_type to logical_or.
+	Set micromips_type to logical_xor for unamed xor instructions.
+	(*zero_extend<SHORT:mode><GPR:mode>2): Set micromips_type to
+	zero_extend.
+	(mfhi<GPR:mode>_<HILO:mode>): Set micromips_type to mfhi.
+	(clear_hazard_<mode>): Use jrs.hb for microMIPS.
+	(*<optab><mode>3): Disable microMIPS for this instruction.
+	(*micromips_ashl<mode>3): New instruction for microMIPS.
+	(*micromips_ashr<mode>3): New instruction for microMIPS.
+	(*micromips_lshr<mode>3): New instruction for microMIPS.
+	(*branch_equality<mode>): Check if it is not
+	microMIPS.
+	(*branch_equality<mode>_micromips): New instruction for microMIPS.
+	(*branch_equality<mode>_inverted): Check if it is not microMIPS.
+	(*branch_equality<mode>_inverted_micromips): New isntruction for
+	microMIPS.
+	(jump): Use "b" for microMIPS to save code size.
+	(*return): Use "jr" for microMIPS to save code size.
+	(return_internal): Use "jr" for microMIPS to save code size.
+	(sibcall_internal): Use MICROMIPS_J to enable jrs.
+	(sibcall_value_internal): Use MICROMIPS_J to enable jrs.
+	(sibcall_value_multiple_internal): Use MICROMIPS_J to enable jrs.
+	(micromips.md): New include.
+	* config/mips/mips.opt (mjals, mmicromips, mmucon): New options.
+	* config/mips/mips16.S: Skip code when __mips_micromips is defined.
+	* config/mips/mips-protos.h (micromips_output_save_restore,
+	micromips_save_restore_pattern_p, micromips_load_store_pair_p,
+	micromips_output_load_store_pair): New prototypes.
+	* config/mips/mips.c (MIPS_MAX_FIRST_STACK_STEP): Use 0x7f0 for
+	microMIPS.
+	(mips_base_micromips): New variable.
+	(mips_attribute_table): Add "micromips" and "nomicromips".
+	(mips_cpu_info_table): Add "m14k".
+	(mips_micromips_decl_p, mips_nomicromips_decl_p): New functions.
+	(mips_use_micromips_mode_p): New function.
+	(mips_insert_attributes):  Add micromips_p and nomicromips_p.
+	Cannot use both mips16 and microMIPS.
+	(mips_start_function_definition): Set micromips/nomicromips.
+	(mips_function_ok_for_sibcall): Check if sibcall is ok for microMIPS.
+	For MIPS32, check if the called function is a microMIPS function.
+	(mips_print_operand_punctuation): Add ':' to support compact branches.
+	Add '!' to support branches with 16-bit delay slots.
+	(mips_init_print_operand_punct): Add ':' to generate compact branches.
+	Add '!' to generate branch with 16-bit delay slots by recognizing
+	16-bit instructions in delay slots.
+	(mips_init_print_operand_punct): Add : and !.
+	(mips_save_reg): Add prototype, because it will be used later.
+	(micromips_build_save_restore): New function.
+	(mips_for_each_saved_reg): Add support for microMIPS lwm/swm.
+	(mips_expand_epilogue): Add jraddiusp support.
+	(was_micromips_p, was_micromips_pch_p): New variables.
+	(mips_set_mips16_micromips_mode): Change it from mips_set_mips16_mode.
+	Support the microMIPS mode for functions.
+	For microMIPS, we disable branch likely instructions.
+	(mips_set_current_function): Rename mips_set_mips16_mode to
+	mips_set_mips16_micromips_mode.
+	(mips_override_options): Check mips16 and microMIPS.
+	Rename mips_set_mips16_mode to mips_set_mips16_micromips_mode.
+	(micromips_save_restore_pattern_p, micromips_output_save_restore,
+	micromips_load_store_pair_p, micromips_output_load_store_pair):
+	New functions.
+	* config/mips/mips.h (TARGET_CPU_CPP_BUILTINS): Add __mips_micromips
+	and __mips_mucon.
+	(ISA_HAS_LWXS): Enable for microMIPS.
+	(ASM_SPEC): Pass -mmicromips/-mno-micromips and -mmucon/-mno-mucon.
+	(M16STORE_REG_P): New define for microMIPS store source register.
+	(MIPS_CALL): For microMIPS, we try to enable jals and jalrs.
+	(MICROMIPS_J): New define for microMIPS to enable jrs.
+	* config/mips/t-sde (MULTILIB_OPTIONS): Add mmicromips.
+	(MULTILIB_DIRNAMES): Add micromips
+	Exclude -mcode-readable=no when !mips16.
+
+2009-12-21  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #6964
+
+	gcc/
+	* config/arm/arm.c (neon_expand_vector_init): Replace use of
+	UNSPEC_VSET_LANE with calls to appropriate gen_neon_vset_lane<mode>.
+	* config/arm/neon.md (UNSPEC_VCOMBINE): Delete.
+	(UNSPEC_VSET_LANE): Delete.
+	(vec_set<mode>_internal): Make code emitted match that for the
+	corresponding intrinsics.
+	(neon_vset_lane<mode>): Expand into vec_set<mode>_internal instead
+	of using UNSPEC_VSET_LANE.
+	(neon_vcombine): Rewrite pattern to eliminate UNPSEC_VCOMBINE.
+
+2009-12-18  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	libiberty/
+	* pex-common.c (pex_read_err): Set stderr_pipe to -1 if a
+	corresponding stream has been opened.
+	(pex_free): Close pipe file descriptors corresponding to child's
+	stdout and stderr before waiting.
+
+2009-12-17  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #6964
+
+	gcc/
+	* config/arm/neon.md (UNSPEC_VGET_HIGH, UNSPEC_VGET_LOW): Delete.
+	(neon_vget_high<mode>): Replace with....
+	(neon_vget_highv16qi): New pattern using canonical RTL.
+	(neon_vget_highv8hi): Likewise.
+	(neon_vget_highv4si): Likewise.
+	(neon_vget_highv4sf): Likewise.
+	(neon_vget_highv2di): Likewise.
+	(neon_vget_low<mode>): Replace with....
+	(neon_vget_lowv16qi): New pattern using canonical RTL.
+	(neon_vget_lowv8hi): Likewise.
+	(neon_vget_lowv4si): Likewise.
+	(neon_vget_lowv4sf): Likewise.
+	(neon_vget_lowv2di): Likewise.
+
+2009-12-15  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #6964
+
+	gcc/
+
+	* config/arm/neon.md (UNSPEC_VGET_LANE): Delete.
+	(vec_extractv2di): Correct error in register numbering.
+	Copy assembly pattern from neon_vget_lanev2di.
+	(neon_vget_lanedi): Rewrite to expand into emit_move_insn.
+	(neon_vget_lanev2di): Rewrite to expand into vec_extractv2di.
+	(neon_vset_lanedi): Rewrite to expand into emit_move_insn.
+	* config/arm/neon.ml (Vget_lane): Add No_op attribute to 64-bit
+	scalar variants to suppress test for this emitting vmov.
+	(Vset_lane): Likewise.
+	* doc/arm-neon-intrinsics.texi: Regenerated.
+
+	gcc/testsuite/
+	* gcc.target/arm/neon/vget_lanes64.c: Regenerated.
+	* gcc.target/arm/neon/vget_laneu64.c: Regenerated.
+	* gcc.target/arm/neon/vset_lanes64.c: Regenerated.
+	* gcc.target/arm/neon/vset_laneu64.c: Regenerated.
+	* gcc.target/arm/neon-vget_lanes64.c: New execution test.
+	* gcc.target/arm/neon-vget_laneu64.c: New execution test.
+	* gcc.target/arm/neon-vset_lanes64.c: New execution test.
+	* gcc.target/arm/neon-vset_laneu64.c: New execution test.
+
+2009-12-11  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #4955
+	Backport from upstream:
+
+	2009-12-11  Sebastian Andrzej Siewior  <bigeasy@linutronix.de>
+	PR target/36047
+	* config/m68k/linux.h: Remove LABELNO from the mcount statement. It is
+	not used by glibc/uclibc and does not work with large binaries.
+
+2009-12-10  Andrew Jenner  <andrew@codesourcery.com>
+
+	gcc/
+	* java/Make-lang.in (java.install-html): Add.
+	* objc/Make-lang.in (objc.install-html): Add.
+	* objcp/Make-lang.in (obj-c++.insatll-html): Add.
+	* cp/Make-lang.in (c++.install-html): Add.
+	* ada/gcc-interface/Make-lang.in (ada.install-html): Add.
+	* fortran/Make-lang.in: Update comment.
+
+2009-12-10  Pedro Alves  <pedro@codesourcery.com>
+
+	gcc/
+	* config/arm/mingw32.h (FORTRAN_INIT): Define.
+
+	revert:
+	2009-12-07  Andrew Jenner  <andrew@codesourcery.com>
+	gcc/
+	* fortran/gfortranspec.c (lang_specific_driver): Add -lmingw32 to
+	-lgfortranbegin group for CE.
+
+2009-12-10  Andrew Jenner  <andrew@codesourcery.com>
+
+	libgfortran/
+	* io/read.c: Use HAVE_ERRNO_H instead of HAVE_ERRNO.
+
+2009-12-10  Julian Brown  <julian@codesourcery.com>
+
+	Issue #7318
+
+	* release-notes-csl.xml (Indirect function call optimization): Add
+	note.
+
+	gcc/
+	* config/arm/arm.c (output_call_mem): Remove armv5 support.
+	* config/arm/arm.md (*call_mem): Disable for armv5. Add note.
+	(*call_value_mem): Likewise.
+
+2009-12-08  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/
+	2009-08-24  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	* config/arm/neon.md (vashl<mode>3): Rename from ashl<mode>3.
+	(vashr<mode>3): Rename from ashr<mode>3.
+	(vlshr<mode>3): Rename from lshr<mode>3.
+
+2009-12-08  Julian Brown  <julian@codesourcery.com>
+
+	Issue #6846
+
+	Backport from mainline:
+
+	gcc/
+	* config/arm/constraints.md (Ps, Pt): New constraint letters.
+	* config/arm/thumb2.md (*thumb2_addsi_short): Tighten constraints.
+
+2009-12-09  Andrew Jenner  <andrew@codesourcery.com>
+
+	gcc/
+	* configure.ac: Add install-html to target_list for Make-hooks.
+	* configure: Regenerate.
+	* fortran/Make-lang.in (F95_HTMLFILES): New.
+	(fortran.html): Use it.
+	(fortran.install-html): New.
+	* Makefile.in (install-html): Add lang.install-html.
+
+2009-12-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* release-notes-csl.xml: Fix duplicate UUID.
+
+2009-12-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #7244
+
+	* release-notes-csl.xml: New note.
+
+	gcc/
+	* tree-ssa-loop-promote.c (phi_nodes_to_promote): New variable.
+	(pli_cleanup): Free phi_nodes_to_promote if necessary.
+	(promote_short_indices): Allocate phi_nodes_to_promote.  Traverse it.
+	(rebuild_with_promotion): Add the phi node to phi_nodes_to_promote.
+	Move the promotion logic...
+	(promote_phi_node): ...here.  New function.
+
+	gcc/testsuite/
+	* gcc.dg/promote-short-11.c: New file.
+	* gcc.dg/promote-short-12.c: New file.
+
+2009-12-07  Andrew Jenner  <andrew@codesourcery.com>
+
+	libgfortran/
+	* io/unix.c (id_from_fd) [__MINGW32CE__]: Don't use _get_osfhandle.
+	(fd_to_stream) [__MINGW32CE__]: Don't use fstat or isatty.
+	(sstream_isatty) [__MINGW32CE__]: Don't use isatty.
+
+2009-12-07  Andrew Jenner  <andrew@codesourcery.com>
+
+	gcc/
+	* fortran/gfortranspec.c (lang_specific_driver): Add -lmingw32 to
+	-lgfortranbegin group for CE.
+
+2009-12-03  Pedro Alves  <pedro@codesourcery.com>
+
+	Windows CE port.
+
+	libgfortran/
+	* intrinsics/access.c: Don't include errno.h.
+	(access_func): Use get_oserrno.
+	* intrinsics/chdir.c, intrinsics/chmod.c: Only include errno.h if
+	HAVE_ERRNO_H.
+	* intrinsics/gerror.c: Only include errno.h if HAVE_ERRNO_H.
+	(gerror): Always build.  Constify local `p'.  Use get_oserror
+	instead of strerror.
+	* intrinsics/getcwd.c: Only include errno.h if HAVE_ERRNO_H.
+	* intrinsics/hostnm.c: Only include errno.h if HAVE_ERRNO_H.
+	(w32_gethostname) [__MINGW32CE__]: New.
+	(hostnm_i4_sub): Use get_oserrno.
+	* intrinsics/ierrno.c: Don't include errno.h.
+	(ierrno_i4, ierrno_i8): Use get_oserrno.
+	* intrinsics/kill.c: Only include errno.h if HAVE_ERRNO_H.
+	* intrinsics/link.c: Only include errno.h if HAVE_ERRNO_H.
+	* intrinsics/perror.c: Only include errno.h if HAVE_ERRNO_H.
+	(pwinerror) [__MINGW32CE__]: Declare.
+	(perror, HAVE_PERROR) [__MINGW32CE__]: Define.
+	* intrinsics/rename.c: Only include errno.h if HAVE_ERRNO_H.
+	(rename_i4_sub, rename_i8_sub): Use get_oserrno.
+	* intrinsics/signal.c: Only include errno.h if HAVE_ERRNO_H.
+	[__MINGW32CE__]: Include <windows.h>.
+	(not_supported): New function.
+	(signal_sub): Use `not_supported'.  Add __attribute__((unused))
+	markers to parameters.
+	(signal_sub_int, alarm_sub_i4, alarm_sub_i8, alarm_sub_int_i4)
+	(alarm_sub_int_i8): Ditto.
+	* intrinsics/sleep.c: Don't include errno.h.
+	* intrinsics/stat.c: Don't include errno.h.
+	(stat_i4_sub_0, stat_i8_sub_0, fstat_i4_sub, fstat_i8_sub): Use
+	get_oserrno.
+	* intrinsics/symlnk.c: Only include errno.h if HAVE_ERRNO_H.
+	* intrinsics/unlink.c: Don't include errno.h.
+	(unlink_i4_sub): Use get_oserrno.
+	* intrinsics/env.cd (getenv)
+	(get_environment_variable_i4) [__MINGW32CE__]: Always NULL.
+	* intrinsics/getXid.c: Include windows.h instead of process.h.
+	(getpid) [__MINGW32CE__]: Use GetCurrentProcessId.
+	* intrinsics/getlog.c: Don't define WIN32_LEAN_AND_MEAN.  Include
+	malloc.h.
+	(EXTENDED_NAME_FORMAT): New typedef.
+	(ce_GetUserNameA): New function.
+	(GetUserName): New define.
+	* intrinsics/system.c [__MINGW32CE__]: Include windows.h.
+	(system_sub) [__MINGW32CE__]: Return not-supported.
+	* intrinsics/umask.c (ce_umask) [__MINGW32CE__]: New function.
+	(umask): New define.
+
+	* io/open.c: Only include errno.h if HAVE_ERRNO_H.
+	[__MINGW32CE__]: Include <windows.h>.
+	(new_unit) [__MINGW32CE__]: Add error handling based on
+	GetLastError.
+	* io/read.c: Only include errno.h if HAVE_ERRNO_H.
+	[__MINGW32CE__]: Include <windows.h>.
+	(convert_real) [__MINGW32CE__]: Use SetLastError/GetLastError.
+	* io/transfer.c: Don't include errno.h.
+	(next_record_r): Use clear_oserrno, get_oserrno.
+	* io/unix.c: Only include errno.h if HAVE_ERRNO_H.
+	(id_from_path) [__MINGW32CE__]: Handle UNICODE.
+	(GFC_STDOUT_FILENO, GFC_STDERR_FILENO, GFC_STDIN_FILENO): New.
+	(flush_if_preconnected): Use them.
+	(COUNTOF): Define.
+	(strwinerror, pwinerror): New functions.
+	(get_oserror) [__MINGW32CE__]: Use strwinerror.
+	(get_oserrno): New function.
+	(clear_oserrno): New function.
+	(raw_write): Check if EINTR is defined.
+	(raw_close): Use GFC_STDOUT_FILENO, GFC_STDERR_FILENO and
+	GFC_STDIN_FILENO.
+	(buf_seek, mem_seek) [__MINGW32CE__]: Use SetLastError.
+	(fd_to_stream): Use GFC_STDOUT_FILENO, GFC_STDERR_FILENO and
+	GFC_STDIN_FILENO.
+	(ce_mktemp): New function.
+	(mktemp) [__MINGW32CE__]: Define to ce_mktemp.
+	(tempfile) [__MINGW32CE__]: Don't reference getenv.  Use
+	GetLastError.
+	(regular_file) [__MINGW32CE__]: Use GetLastError/SetLastError.
+	(open_external): Use GFC_STDIN_FILENO.
+	(setmode, HAVE_SETMODE) [__MINGW32CE__]: Define.
+	(_setmode) [__MINGW32CE__]: Declare.
+	(output_stream): Use GFC_STDOUT_FILENO.
+	(error_stream): Use GFC_STDERR_FILENO.
+	(st_vprintf): : Use GFC_STDOUT_FILENO and GFC_STDERR_FILENO.
+	(delete_file) [__MINGW32CE__]: Use SetLastError.
+	* io/write.c: Only include errno.h if HAVE_ERRNO_H.
+	(write_a_char4): Cast crlf to gfc_char4_t *.
+	* io/write_float.def (signbit) [__MINGW32CE__]: Define.
+
+	* runtime/error.c: Don't include errno.h.
+	(generate_error): Use get_oserrno.
+	* runtime/environ.c (ce_getenv) [__MINGW32CE__]: New function.
+	(getenv) [__MINGW32CE__]: New define.
+	* runtime/main.c (store_exe_path): Constify `cwd'.
+
+	* libgfortran.h (get_oserrno, clear_oserrno): Declare.
+
+	* configure.ac: Add check for errno.h.
+	* configure, config.h.in: Regenerate.
+
+2009-12-03  Pedro Alves  <pedro@codesourcery.com>
+
+	* configure.ac (arm*-*-mingw32*): New.  Skip target-libiberty.
+	* configure: Regenerate.
+
+2009-12-03  Andrew Jenner  <andrew@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (TARGET_ASM_UNALIGNED_HI_OP): Define.
+	(TARGET_ASM_UNALIGNED_SI_OP): Define.
+	(TARGET_ASM_UNALIGNED_DI_OP): Define.
+	(TARGET_ASM_UNALIGNED_TI_OP): Define.
+	* config/arm/wince-pe.h: Enable dwarf debugging info.
+
+2009-11-23  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue 1080.  Fix for non C/C++
+	gcc/
+	* targhooks.c: Include convert.h.
+	(hook_cxx_ttype_ref_in_bit0): Rewrite to avoid using C frontend
+	routines.
+
+2009-11-18  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #6609
+
+	Backport from upstream:
+
+	gcc/
+	2009-11-18  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* config/arm/neon-docgen.ml (analyze_shape_elt): Handle
+	Alternatives.
+
+	gcc/
+	2009-11-11  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* config/arm/arm.c (neon_vdup_constant, neon_make_constant): New.
+	(neon_expand_vector_init): Use them.  Also handle non-constant
+	vectors with identical elements and vectors with only one
+	non-constant element.
+	(arm_print_operand): Handle 'y' modifier.
+	* config/arm/arm-protos.h (neon_make_constant): Declare.
+	* config/arm/neon.md (neon_vdup_n<mode>): Split into two
+	patterns.  Use VX instead of VDQW for the first one.  Allow
+	a VFP alternative and V32 modes for the second one.
+	* config/arm/neon.ml (shape_elt): Add Alternatives.
+	(ops): Use Alternatives for vdup lane instructions.
+	* config/arm/neon-testgen.ml (analyze_shape): Handle Alternatives.
+	* config/arm/vec-common.md (mov<mode>): Use neon_make_constant.
+
+	gcc/testsuite/
+	* gcc.target/arm/neon: Regenerate generated tests.
+
+2009-11-18  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #6964
+
+	gcc/
+	* config/arm/neon.md (UNSPEC_VABA): Delete.
+	(UNSPEC_VABAL): Delete.
+	(UNSPEC_VABS): Delete.
+	(UNSPEC_VABAL): Delete.
+	(UNSPEC_VAND): Delete.
+	(UNSPEC_VBIC): Delete.
+	(UNSPEC_VCLZ): Delete.
+	(UNSPEC_VCNT): Delete.
+	(UNSPEC_VDUP_N): Delete.
+	(UNSPEC_VEOR): Delete.
+	(UNSPEC_VMVN): Delete.
+	(UNSPEC_VORN): Delete.
+	(UNSPEC_VORR): Delete.
+	(iordi3_neon): Rewrite RTL without unspec.  Add cases to handle
+	core registers too, to make this a replacement for the default.
+	(anddi3_neon): Likewise.
+	(orndi3_neon): Likewise.
+	(bicdi3_neon): Likewise.
+	(xordi3_neon): Likewise.
+	(neon_vabs<mode>): Rewrite as define_expand to get rid of unspec for
+	extra operand.
+	(neon_vaba<mode>): Rewrite to get rid of UNSPEC_VABA.
+	(neon_vabal<mode>): Rewrite to get rid of UNSPEC_VABAL.
+	(neon_vclz<mode>): Rewrite as define_expand and clz<mode>2 to get
+	rid of unspec and handle unused operand.
+	(neon_vcnt<mode>): Similarly, with popcount<mode>2.
+	(neon_vdup_n<mode>): Rewrite RTL without unspec.
+	(neon_vdup_ndi): Rewrite as define_expand and use emit_move_insn.
+	(neon_vdup_nv2di): Rewrite RTL without unspec.
+	* config/arm/arm.md (define_split for logical_binary_operator): 
+	Disable for NEON registers.
+	(anddi3): Add new define_expand, and rename the insn.  Disable
+	this insn for NEON.
+	(*anddi_notdi_di): Disable for TARGET_NEON, where bicdi3_neon applies.
+	(iordi3): As for anddi3.
+	(xordi3): Likewise.
+	* config/arm/predicates.md (imm_for_neon_logic_operand):
+	Require TARGET_NEON.
+	(imm_for_neon_inv_logic_operand): Likewise.
+	* config/arm/neon.ml (Vdup_n): Add No_op attribute to suppress test
+	for this emitting vmov.
+	(Vmov_n): Likewise.
+	* doc/arm-neon-intrinsics.texi: Regenerated.
+
+	gcc/testsuite/
+	* gcc.target/arm/neon/vdup_ns64.c: Regenerated.
+	* gcc.target/arm/neon/vdup_nu64.c: Regenerated.
+	* gcc.target/arm/neon/vmov_ns64.c: Regenerated.
+	* gcc.target/arm/neon/vmov_nu64.c: Regenerated.
+	* gcc.target/arm/neon-vdup_ns64.c: New execution test.
+	* gcc.target/arm/neon-vdup_nu64.c: New execution test.
+	* gcc.target/arm/neon-vmov_ns64.c: New execution test.
+	* gcc.target/arm/neon-vmov_nu64.c: New execution test.
+
+2009-11-11  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gcc/
+	* config/arm/neon.md (*movmisalign<mode>_neon_load): Use
+	memory_operand.
+
+2009-11-12  Andrew Jenner  <andrew@codesourcery.com>
+
+	libgcc/
+	* config.host: Handle arm*-*-mingw32ce* and arm*-*-cegcc*.
+
+	gcc/
+	* gthr-win32.h: Don't use errno.h or EINVAL under CE.
+	* config.gcc: Cleanup. Don't put msformat-c.o in src directory.
+	* config/i386/gthr-win32.c: Don't use 486 lock primitive or EINVAL
+	under CE.
+	* config/arm/pe-cxx.c: Update copyright message.
+	* config/arm/pe-stubs.c: Likewise.
+	* config/arm/t-mingw32: New file.
+	* config/arm/arm-protos.h (arm_major_arch): Declare.
+	(arm_thumb_arch_p): Declare.
+	(arm_pe_adjust_class_at_definition): Declare.
+	(arm_pe_type_dllimport_p): Declare.
+	(arm_pe_type_dllexport_p): Declare.
+	* config/arm/cygming.opt: Update copyright message.
+	* config/arm/wince-pe.h (FPUTYPE_DEFAULT): Change to "vfp".
+	Don't use DWARF2 debug information.
+	(TARGET_DEFAULT): Remove MASK_RETURN_AGGREGATES_IN_MEMORY.
+	* config/arm/mingw32.h: Update copyright message.
+	(STANDARD_INCLUDE_DIR): Define.
+	Include windows.h in libgcc2.
+	* config/arm/msformat-c.c: New file (copied from config/i386).
+	* tsystem.h: Don't use errno.h under CE.
+
+2009-11-11  Julian Brown  <julian@codesourcery.com>
+
+	* release-notes-csl.xml (Internal compiler error fix): Add note for
+	#7000 fix.
+
+2009-11-11  Julian Brown  <julian@codesourcery.com>
+
+	Issue #7000
+
+	gcc/
+	* config/arm/arm.h (PREFERRED_RELOAD_CLASS): Don't restrict Thumb-2
+	reloads to LO_REGS.
+
+2009-11-11  Julian Brown  <julian@codesourcery.com>
+
+	gcc/
+	* config/arm/thumb2.md (*thumb2_movdf_soft_insn): Fix pool ranges.
+
+2009-11-10  Andrew Jenner  <andrew@codesourcery.com>
+
+	NOT ASSIGNED TO FSF
+	Ported from CEGCC
+
+	gcc/
+	* config.gcc: Add arm-*-mingw32* from CEGCC.
+	* config/arm/pe-cxx.c: New file.
+	* config/arm/arm.c: Copied from CEGCC.
+	* config/arm/pe-stubs.c: New file.
+	* config/arm/wince-pe.h: Copied from CEGCC.
+	* config/arm/cygming.opt: New file.
+	* config/arm/t-cygming: New file.
+	* config/arm/mingw32.h: New file.
+	* config/arm/pe.opt: Copied from CEGCC.
+	* config/arm/t-wince-pe: Copied from CEGCC.
+
+2009-11-05  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.target/m68k/pr41302.c: Fix target triplet.
+
+2009-11-03  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Revert:
+
+	2009-09-09  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	gcc/
+	* config/m68k/m68k.h (TRANSFER_FROM_TRAMPOLINE): Avoid warning.	
+
+2009-11-01  Daniel Gutson  <dgutson@codesourcery.com>
+
+	gcc/testsuite/
+	* g++.dg/warn/miss-format-1.C: Updated line number.
+
+2009-11-01  Maxim Kuvyrkov  <maxim@codesourcery.com>
+            Carlos O'Donell  <carlos@codesourcery.com>
+
+	Issue #6954
+	PR target/41302
+
+	* release-notes-csl.xml: Add release note.
+	
+	gcc/
+	* config/m68k/m68k.c (m68k_reg_present_p): New static function.
+	(m68k_ok_for_sibcall_p): Handle different result return locations.
+
+	gcc/testsuite/
+	* gcc.target/m68k/pr41302.c: New test.
+
+2009-10-29  Paul Brook  <paul@codesourcery.com>
+
+	Issue #6654
+	gcc/
+	* config/arm/arm.c (arm_compute_save_reg0_reg12_mask): Add special
+	case for noreturn functions.
+	(arm_compute_save_reg_mask): Remove special noreturn handling.
+
+2009-10-28  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* config/sh/sh.md (movrt): Use SI mode for if_then_else.
+
+2009-10-25  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gcc/
+	* t-eglibc (EGLIBC_AWK): Handle empty list of configs.
+
+2009-10-21  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #6815
+
+	gcc/
+	* config/sh/uclinux.h (SUBTARGET_OVERRIDE_OPTIONS): Define.
+
+2009-10-21  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #6814
+
+	gcc/
+	* config/sh/sh.md (tls_global_dynamic, tls_local_dynamic,
+	tls_initial_exec): Don't initialize PIC register here.
+	* config/sh/sh.c (prepare_move_operands): Initialize PIC register
+	here before generating those insns.
+
+2009-10-21  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #6814
+
+	Backport:
+
+	gcc/
+	2009-10-21  Joseph Myers  <joseph@codesourcery.com>
+
+	* config/sh/sh.c (nonpic_symbol_mentioned_p): Allow UNSPEC_TPOFF.
+
+	gcc/testsuite/
+	2009-10-21  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.dg/tls/pie-1.c: New test.
+
+2009-10-19  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gcc/testsuite/
+	* g++.dg/torture/pr36191.C: Don't run with -fomit-frame-pointer on
+	m68k and fido.
+
+2009-10-16  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #6828
+
+	gcc/testsuite/
+	* gcc.dg/remove-local-statics-17.c: Change asm to be empty.
+	Change scan-tree-dump-times text to look for number of variables
+	removed.
+
+2009-10-16  Julian Brown  <julian@codesourcery.com>
+
+	Issue #6842
+
+	gcc/
+	* config/arm/thumb2.md (thumb2_addsi_short): Change length to 4.
+
+2009-10-15  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #6813
+
+	gcc/
+	* config/sh/sh.c (sh_our_fdpic_reg): New.
+	* config/sh/sh-protos.h (sh_our_fdpic_reg): Declare.
+	* config/sh/sh.h (OUR_FDPIC_REG): Define in terms of
+	sh_our_fdpic_reg.
+
+2009-10-15  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* ira.c (setup_eliminable_regset): Remove unused variable
+	regs_asm_clobbered.
+
+2009-10-13  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from FDPIC branch:
+
+	2008-06-12  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	libgcc/
+	* config.host (sh*-*-uclinux*): Add t-uclinux-fdpic.
+	* config/sh/t-uclinux-fdpic: New file.
+
+	gcc/
+	* config.gcc (sh*-*-uclinux*): Use t-slibgcc-elf-ver.
+	* config/sh/lib1funcs.asm (set_fpscr): Handle FDPIC.
+	* config/sh/t-uclinux (CRTSTUFF_T_CFLAGS_S): Set.
+	(EXTRA_MULTILIB_PARTS): Add crtbeginS.o crtendS.o crtbeginT.o.
+	* config/sh/uclinux.h (STARTFILE_SPEC, ENDFILE_SPEC): Update
+	for shared libraries.
+	(LINK_EH_SPEC): Define.
+
+	2008-06-12  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gcc/
+	* config/sh/sh-protos.h (function_symbol): Update prototype.
+	* config/sh/constraints.md: Add Ccl constraint.
+
+	* config/sh/lib1funcs.asm, config/sh/lib1funcs-4-300.asm,
+	config/sh/lib1funcs-Os-4-200.asm: Revert FDPIC hidden symbols.
+
+	* config/sh/sh.c (sh_reloc_rw_mask): New function.
+	(TARGET_ASM_RELOC_RW_MASK): Define.
+	(expand_block_move, expand_ashiftrt, sh_expand_prologue)
+	(sh_expand_epilogue, sh_initialize_trampoline): Update for
+	function_symbol change.
+	(function_symbol): Take a fourth argument.  Use the GOT for
+	FDPIC and SFUNC_GOT.  Use PC-relative calls for FDPIC and
+	SFUNC_STATIC.
+	* config/sh/sh.md: Update patterns affected by function_symbol
+	change.
+
+	2008-05-22  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gcc/
+	* config/sh/sh.h (TARGET_CPU_CPP_BUILTINS): Define __FDPIC__.
+
+	2008-04-23  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* sh.c (sh_load_function_descriptor): New.
+	* sh-protos.h (sh_load_function_descriptor): Declare.
+	* sh.md (calli, call_valuei, sibcalli, sibcall_valuei): Disable
+	for FDPIC.
+	(calli_fdpic, call_valuei_fdpic, sibcalli_fdpic,
+	sibcall_valuei_fdpic): New.
+	(call, call_value, sibcall, sibcall_value): Call
+	sh_load_function_descriptor and use new insns for FDPIC.
+
+	2008-04-23  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/sh/sh.c (legitimize_pic_address): Don't use @GOTOFF for
+	readonly data or code on FDPIC.
+
+	2008-04-22  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/sh/sh.c (function_symbol): Add comment.  Treat SFUNC_GOT
+	like SFUNC_STATIC for FDPIC.  Treat FDPIC like PIC.
+	* config/sh/lib1funcs.asm (sdivsi3, udivsi3_i4i, sdivsi3_i4i):
+	Make hidden.
+	* config/sh/lib1funcs-4-300.asm (udivsi3_i4i, sdivsi3_i4i): Make
+	hidden.
+	* config/sh/lib1funcs-Os-4-200.asm (udivsi3_i4i, sdivsi3_i4i):
+	Make hidden.
+
+	2008-04-22  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/sh/sh.c (sh_output_mi_thunk): Use PC-relative call for
+	FDPIC.
+
+	2008-04-21  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/sh/sh.c (sh_assemble_integer): New.
+	(TARGET_ASM_INTEGER): Define.
+	(prepare_move_operands): Legitimize PIC addresses for FDPIC.
+	(nonpic_symbol_mentioned_p): Handle UNSPEC_GOTFUNCDESC and
+	UNSPEC_GOTOFFFUNCDESC.
+	(legitimize_pic_address): Use GOTOFFFUNCDESC and GOTFUNCDESC for
+	function symbols for FDPIC.
+	(sh_illegitimate_symbolic_constant_p): Require constants to
+	satisfy LEGITIMATE_PIC_OPERAND_P for FDPIC.
+	* config/sh/sh.h (OUTPUT_ADDR_CONST_EXTRA): Handle
+	UNSPEC_GOTFUNCDESC and UNSPEC_GOTOFFFUNCDESC.
+	* config/sh/sh.md (UNSPEC_GOTFUNCDESC, UNSPEC_GOTOFFFUNCDESC,
+	sym2GOTFUNCDESC, symGOTFUNCDESC2reg, sym2GOTOFFFUNCDESC,
+	symGOTOFFFUNCDESC2reg): New.
+
+	2008-04-21  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	Revert:
+	* config/sh/sh.md (call_pcrel, call_value_pcrel): Don't always
+	require PLT entries for FDPIC without PIC.
+
+	2008-04-21  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/sh/sh.c (sh_cannot_copy_insn_p): Don't return false up
+	front for FDPIC.
+	(sh_expand_prologue): Don't generate GOTaddr2picreg instruction
+	for FDPIC.
+	* config/sh/sh.h (CONDITIONAL_REGISTER_USAGE): Also set
+	call_really_used_regs[PIC_REG] for FDPIC.
+	(override_options): Disallow non-SH2 FDPIC.  Set
+	flag_no_function_cse for FDPIC.
+	(OUR_FDPIC_REG): Define.
+	* config/sh/sh.md (call_pcrel, call_value_pcrel): Don't always
+	require PLT entries for FDPIC without PIC.
+	(call, call_value, sibcall, sibcall_value): Load PIC register and
+	use PC-relative calls for FDPIC.
+	(GOTaddr2picreg, symGOT_load, symGOTOFF2reg, tls_global_dynamic,
+	tls_local_dynamic, tls_initial_exec): Load PIC register for FDPIC.
+
+	2008-04-14  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* doc/tm.texi (PIC_OFFSET_TABLE_REG_CALL_CLOBBERED): Document to
+	be zero or nonzero.
+	* defaults.h (PIC_OFFSET_TABLE_REG_CALL_CLOBBERED): Define.
+	* df-scan.c (df_get_exit_block_use_set), regclass.c
+	(init_reg_sets_1), rtlanal.c (rtx_unstable_p, rtx_varies_p):
+	Handle new PIC_OFFSET_TABLE_REG_CALL_CLOBBERED semantics.
+	* config/ia64/ia64.h (PIC_OFFSET_TABLE_REG_CALL_CLOBBERED): Define
+	to 1.
+	* config/sh/sh.h (CONDITIONAL_REGISTER_USAGE): Mark PIC_REG as
+	fixed and call-used for FDPIC.
+	(PIC_OFFSET_TABLE_REG_CALL_CLOBBERED): Define.
+
+	2008-04-14  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/sh/uclinux.h (SUBTARGET_ASM_SPEC): Undefine before
+	defining.
+
+	2008-04-14  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/sh/uclinux.h (SUBTARGET_ASM_SPEC): Define if
+	FDPIC_DEFAULT.
+
+	2008-04-14  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* doc/invoke.texi (SH Options): Document -mfdpic.
+	* doc/install.texi (--enable-fdpic): Document.
+	* config.gcc (sh*-*-uclinux*): Handle --enable-fdpic.
+	* config/sh/sh.opt (mfdpic): New option.
+	* config/sh/sh.h (TARGET_CPU_CPP_BUILTINS): Define __SH_FDPIC__
+	for FDPIC.
+	(DRIVER_SELF_SPECS): Use SUBTARGET_DRIVER_SELF_SPECS.
+	(SUBTARGET_DRIVER_SELF_SPECS): Define.
+	* config/sh/uclinux.h (SUBTARGET_LINK_SPEC,
+	SUBTARGET_LINK_EMUL_SUFFIX): Define differently if FDPIC_DEFAULT.
+	(SUBTARGET_DRIVER_SELF_SPECS): Define if FDPIC_DEFAULT.
+
+	2008-04-02  Mark Shinwell  <shinwell@codesourcery.com>
+		    Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Update sh-uclinux port from GCC 4.1 branch.
+
+	libgcc/
+	* config.host: Handle sh-*-uclinux* | sh[12]-*-uclinux*.
+
+	gcc/testsuite/
+	* gcc.target/sh/sh-relax.c: XFAIL for uClinux.
+
+	gcc/
+	* config.gcc: Handle sh-*-uclinux* | sh[12]-*-uclinux*.
+	* config/sh/sh-protos.h (sh_illegitimate_symbolic_constant_p): Declare.
+	* config/sh/t-sh: Use MULTILIB_CFLAGS for unwind-dw2-Os-4-200.o.
+	* config/sh/t-uclinux: New file.
+	* config/sh/sh.c (TARGET_CANNOT_FORCE_CONST_MEM): Define.
+	(prepare_move_operands): Handle SH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P.
+	(sh_illegitimate_symbolic_constant_p): New function.
+	* config/sh/sh.h (SH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P): Define.
+	(LEGITIMATE_CONSTANT_P): Use sh_illegitimate_symbolic_constant_p.
+	* config/sh/uclinux.h: New file.
+
+2009-10-12  Paul Brook  <paul@codesourcery.com>
+
+	Issue #5767
+	gcc/
+	* config/arm/t-arm-elf (MULTILIB_MATCHES): Rename tag13 to armv7em.
+	* config/arm/t-cs-eabi (MULTILIB_MATCHES): Ditto.
+	* config/arm/t-cs-eabi-lite (MULTILIB_MATCHES): Ditto.
+	* config/arm/t-cs-uclinux-eabi (MULTILIB_MATCHES): Ditto.
+	* config/arm/t-cs-linux-lite (MULTILIB_MATCHES): Ditto.
+
+2009-10-12  Paul Brook  <paul@codesourcery.com>
+
+	Issue #5767
+	gcc/
+	* config.gcc: Add ARM --with-fpu=vfpv3-d16-fp16.
+	* config/arm/arm.c (FL_FOR_ARCHTAG13, arm_arch_tag13): Remove.
+	(FL_FOR_ARCH7EM, arm_arch7em): Define.
+	(all_architectures): Rename tag13 to armv7e-m.
+	(all_fpus): Add fpv4-sp-d16.
+	(arm_override_options): Use new names.
+	* config/arm/arm.h (arm_arch_tag13): Rename ...
+	(arm_arch7em): ...  to this.
+
+2009-10-13  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #6706
+
+	* release-notes-csl.xml (Optimizer bug fix): New note.
+
+	gcc/
+	* tree-ssa-loop-promote.c (insert_along_edge): New function.
+	(promote_variable_1): Move code for modifying GIMPLE_PHI
+	statements...
+	(rebuild_with_promotion): ...here.  Rebuild GIMPLE_PHI statements.
+	(promote_variable_1): Only rewrite uses of promotable variables.
+
+2009-10-12  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #6643
+
+	* release-notes-csl.xml: New note.
+
+	gcc/
+	* tree-ssa-remove-local-statics.c
+	(find_static_nonvolatile_declarations): Don't try to find definitions
+	in GIMPLE_ASM statements.
+
+	gcc/testsuite/
+	* gcc.dg/remove-local-statics-17.c: New test.
+
+2009-10-12  Paul Brook  <paul@codesourcery.com>
+
+	Issue #5767
+	gcc/
+	* config/arm/t-cs-eabi (MULTILIB_MATCHES): Add cortex-a5 and
+	neon-vfpv4.
+	* config/arm/t-cs-eabi-lite (MULTILIB_MATCHES): Add cortex-a5.
+	* config/arm/t-cs-linux (MULTILIB_MATCHES): Add cortex-a5 and
+	neon-vfpv4.
+	* config/arm/t-cs-uclinux-eabi (MULTILIB_MATCHES): Add cortex-a5.
+	* config/arm/t-cs-linux-lite (MULTILIB_MATCHES): Add cortex-a5.
+
+2009-10-12  Paul Brook  <paul@codesourcery.com>
+
+	Issue #5767
+	gcc/
+	* doc/invoke.texi: Document ARM -mcpu=cortex-a8.
+	* config/arm/bpabi.h (BE8_LINK_SPEC): Add mcpu=cortex-a5.
+	* config/arm/arm-cores.def: Add cortex-a5.
+	* config/arm/arm-tune.md: Regenerate.
+
+2009-10-12  Paul Brook  <paul@codesourcery.com>
+
+	Issue #5767
+	gcc/
+	* config/arm/arm.c (arm_fp_model, arm_fpu_arch, arm_fpu_tune): Remove.
+	(arm_fpu_attr, arm_fpu_desc): Define.
+	(all_fpus): Add FPU information.  Remove enums.
+	(fp_model_for_fpu): Remove.
+	(arm_override_options): Always lookup FPU by name.  Set arm_fpu_attr.
+	(arm_output_epilogue, arm_save_coproc_regs): Use TARGET_FPA_EMU2.
+	(arm_file_start): Use new FPU lookup table data.
+	* config/arm/arm.h (TARGET_FPA_EMU2): Define.
+	(TARGET_VFPD32, TARGET_VFP3, TARGET_VFP_SINGLE, TARGET_VFP_DOUBLE,
+	TARGET_NEON_FP16, TARGET_FP16, TARGET_NEON): Use arm_arch_vfp_*.
+	(enum fputype, arm_fpu_tune): Remove.
+	(vfp_reg_type, arm_fpu_desc): Define.
+	(arm_arch_vfp_rev, arm_arch_vfp_regs, arm_arch_vfp_neon,
+	arm_arch_vfp_fp16): Define.
+	* config/arm/arm.md (fpu): Remove superfluous entries.
+	* config/arm/fpa.md (movxf_fpa): Use TARGET_FPA_EMU2.
+	* config/arm/linux-elf.h (FPUTYPE_DEFAULT): Update.
+	* config/arm/bpabi.h (FPUTYPE_DEFAULT): Update.
+	* config/arm/netbsd-elf.h (FPUTYPE_DEFAULT): Update.
+	* config/arm/vxworks.h (FPUTYPE_DEFAULT): Update.
+	* doc/invoke.texi: Document ARM VFPv4 FPU options.
+	* config.gcc: Add ARM VFPv4 --with-fpu options.
+
+2009-10-11  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* release-notes-csl.xml (NEON improvements): New note, merged
+	from 4 old ones.
+	(Thumb-2 NEON bug fix): Delete.
+	(NEON store improvements): Delete.
+	(NEON vectorizer improvements): Delete.
+	(ARMv5 multilib improvements): Tweak wording.
+	(GCC NEON vector shift bug fix): Delete.
+
+2009-10-11  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #6429 - GDB test failures on ColdFire
+
+	* release-notes-csl.xml (Stack unwinding bug fix): New note.
+
+	gcc/
+	* dwarf2out.c (dwarf2out_frame_debug): Check for queued saves
+	again after processing insn.
+
+2009-10-10  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #6756
+
+	* config/arm/neon.md (*movmisalign<mode>_neon): Split into
+	*movmisalign<mode>_neon_store and *movmisalign<mode>_neon_load.
+	Narrow predicates.
+
+2009-10-09  Sandra Loosemore  <sandra@codesourcery.com>
+
+	* release-notes-csl.xml (Compiler errors with float32_t):
+	Rephrase to avoid bad line break.
+
+2009-10-09  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #6297
+
+	gcc/
+	* config/arm/t-cs-linux (MULTILIB_ALIASES): Don't map Thumb-2 NEON
+	to another library.
+	(MULTILIB_OSDIRNAMES): Add entry for Thumb-2 NEON.
+
+2009-10-09  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (output_move_neon): Use DImode in call to
+	adjust_address.
+
+2009-10-08  Joseph Myers  <joseph@codesourcery.com>
+
+	* release-notes-csl.xml (NEON store improvements): Only enable for
+	ARM targets supporting hardware floating point.
+
+2009-10-08  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #6439
+
+	Backport from mainline:
+	gcc/
+	2009-09-21  Jan Hubicka  <jh@suse.cz>
+	* dwarf2out.c (decl_loc_table_eq): Allow decl_loc_table to be NULL.
+	(dwarf2out_abstract_function): NULLify decl_loc_table at begginig and
+	restore at the end.
+
+2009-10-08  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #6472
+
+	gcc/
+	* config/arm/t-cs-eabi (MULTILIB_MATCHES): Map -mfpu=neon-fma-fp16
+	to -mfpu=neon.
+	* config/arm-t-cs-linux (MULTILIB_MATCHES): Likewise.
+
+2009-10-08  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue #6697
+
+	libiberty/
+	* argv.c (expandargv): Use xmalloc instead of malloc,
+	as suggested upstream.
+
+2009-10-07  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (arm_vector_always_misalign): Adjust FIXME
+	comment.
+
+2009-10-07  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #6722
+
+	gcc/
+	* config/arm/arm.c (arm_vector_always_misalign): Return false for
+	big endian.
+	* config/arm/neon.md (movmisalign): Disable for big endian.
+
+2009-10-07  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #6713
+
+	gcc/
+	* tree-sra.c (sra_type_can_be_decomposed_p): Disable SRA for bitfields
+	when compiling for BITS_BIG_ENDIAN target.
+
+2009-10-07  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* release-notes-csl.xml (NEON store improvements): New note.
+
+2009-10-07  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gcc/
+	* config/arm/neon.md (*neon_mov<mode>): Reject two non-register
+	operands.
+	(movti, mov<mode>): Call force_reg on one operand if required.
+	* config/arm/vec-common.md (mov<mode>): Likewise.
+
+2009-10-06  Paul Brook  <paul@codesourcery.com>
+
+	Issue #3869
+	gcc/
+	* target.h (gcc_target): Add warn_func_result.
+	* target-def.h (TARGET_WARN_FUNC_RESULT): Define and use.
+	* tree-cfg.h (execute_warn_function_return): Use
+	targetm.warn_func_result.
+	* config/arm/arm.c (TARGET_WARN_FUNC_RESULT): Define.
+	(arm_warn_func_result): New function.
+
+	gcc/testuite/
+	* gcc.target/arm/naked-3.c: New test.
+
+2009-10-05  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #6701
+	gcc/
+	* tree-ssa-structalias.c (get_constraint_for_component_ref): A
+	function decl may be the core of a component ref.
+
+	gcc/testsuite/
+	* g++.dg/opt/alias5.C: New.
+
+	* release-notes-csl.xml: Document.
+
+2009-10-05  Daniel Gutson  <dgutson@codedsourcery.com>
+	Daniel Jacobowitz  <dan@codesourcery.com>
+	Pedro Alves  <pedro@codesourcery.com>
+
+	Issue #6697
+
+	libiberty/
+	* argv.c (consume_whitespace): New function.
+	(only_whitespace): New function.
+	(buildargv): Always use ISSPACE by calling consume_whitespace.
+	(expandargv): Skip empty files.  Do not stop at the first empty
+	argument (calling only_whitespace)..
+	* testsuite/test-expandargv.c: (test_data): Test empty lines
+	and empty arguments.
+	(run_tests): Fix false positives due to shorter arguments. 
+
+	* release-config-csl.xml: Document.
+
+2009-10-02  Paul Brook  <paul@codesourcery.com>
+
+	Issue #6705
+	gcc/
+	* config/arm/arm.c (neon_vector_mem_operand): Disallow PRE_DEC for
+	array loads.
+	(output_move_neon): Remove bogus FIXME.
+
+2009-10-02  Paul Brook  <paul@codesourcery.com>
+
+	Issue #6223
+	gcc/
+	* targhooks.c (default_vector_min_alignment): New function.
+	* targhooks.h (default_vector_min_alignment): Add prototype.
+	* target.h (gcc_target): Add vectorize.vector_min_alignment and
+	vectorize.always_misalign.
+	* expr.c (expand_assignment): Handle MISALIGNED_INDIRECT_REF as a
+	destination.
+	(expand_expr_real_1): Handle writes to MISALIGNED_INDIRECT_REF.
+	* tree-vect-analyze.c (vect_compute_data_ref_alignment): Use
+	targetm.vectorize.vector_min_alignment.
+	* target-def.h (TARGET_VECTOR_MIN_ALIGNMENT): Define.
+	(TARGET_VECTOR_ALWAYS_MISALIGN): Define.
+	(TARGET_VECTORIZE): Use them.
+	* tree-vect-transform.c (vectorizable_store): Honor
+	targetm.vectorize.always_misalign.
+	(vectorizable_load): Ditto.
+	(vect_gen_niters_for_prolog_loop): Use
+	targetm.vectorize.vector_min_alignment.
+	* config/arm/arm.c (arm_vector_min_alignment,
+	arm_vector_always_misalign): New functions.
+	(TARGET_VECTOR_MIN_ALIGNMENT, TARGET_VECTOR_ALWAYS_MISALIGN): Define.
+	(arm_print_operand): Include alignment qualifier in %A.
+	* config/arm/neon.md (movmisalign): Enable on big-endian targets.
+
+	gcc/testsuite/
+	* lib/target-supports.exp (check_effective_target_vect_element_align):
+	New function.
+	* gcc.dg/vect/no-section-anchors-vect-31.c: Use vect_element_align.
+	* gcc.dg/vect/no-section-anchors-vect-64.c: Ditto.
+	* gcc.dg/vect/no-section-anchors-vect-66.c: Ditto.
+	* gcc.dg/vect/no-section-anchors-vect-68.c: Ditto.
+	* gcc.dg/vect/no-section-anchors-vect-69.c: Ditto.
+	* gcc.dg/vect/section-anchors-vect-69.c: Ditto.
+	* gcc.dg/vect/slp-25.c: Ditto.
+	* gcc.dg/vect/vect-109.c: Ditto.
+	* gcc.dg/vect/vect-26.c: Ditto.
+	* gcc.dg/vect/vect-27.c: Ditto.
+	* gcc.dg/vect/vect-28.c: Ditto.
+	* gcc.dg/vect/vect-29.c: Ditto.
+	* gcc.dg/vect/vect-33.c: Ditto.
+	* gcc.dg/vect/vect-42.c: Ditto.
+	* gcc.dg/vect/vect-44.c: Ditto.
+	* gcc.dg/vect/vect-48.c: Ditto.
+	* gcc.dg/vect/vect-50.c: Ditto.
+	* gcc.dg/vect/vect-52.c: Ditto.
+	* gcc.dg/vect/vect-54.c: Ditto.
+	* gcc.dg/vect/vect-56.c: Ditto.
+	* gcc.dg/vect/vect-58.c: Ditto.
+	* gcc.dg/vect/vect-60.c: Ditto.
+	* gcc.dg/vect/vect-70.c: Ditto.
+	* gcc.dg/vect/vect-72.c: Ditto.
+	* gcc.dg/vect/vect-75.c: Ditto.
+	* gcc.dg/vect/vect-87.c: Ditto.
+	* gcc.dg/vect/vect-88.c: Ditto.
+	* gcc.dg/vect/vect-89.c: Ditto.
+	* gcc.dg/vect/vect-91.c: Ditto.
+	* gcc.dg/vect/vect-92.c: Ditto.
+	* gcc.dg/vect/vect-93.c: Ditto.
+	* gcc.dg/vect/vect-95.c: Ditto.
+	* gcc.dg/vect/vect-align-2.c: Ditto.
+	* gcc.dg/vect/vect-multitypes-1.c: Ditto.
+	* gcc.dg/vect/vect-multitypes-3.c: Ditto.
+	* gcc.dg/vect/vect-multitypes-4.c: Ditto.
+	* gcc.dg/vect/vect-multitypes-6.c: Ditto.
+
+2009-10-02  Paul Brook  <paul@codesourcery.com>
+
+	Issue #4896
+	gcc/
+	* config/arm/t-cs-eabi: Change v5t multilib to v5te.
+	* config/arm/t-cs-linux: Ditto.
+	* config/arm/t-cs-linux-lite: Ditto.
+
+2009-10-01  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #5767
+	gcc/
+	* doc/extend.texi (Half-Precision): Update wording to reflect
+	that there are now multiple -mfpu options that enable fp16
+	hardware support.
+
+2009-09-30  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config/arm/neon.ml (vectype): Add T_floatSF.
+	(string_of_vectype): Add T_floatSF.
+	* config/arm/neon-gen.ml (signed_ctype): Add T_float32 -> T_floatSF.
+	(deftypes): Use float for float32_t.
+	* config/arm/arm_neon.h: Regenerate.
+
+	gcc/testsuite/
+	* g++.dg/other/arm-neon-1.C: New test.
+
+2009-09-29  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #4151 - CYGPATH support for the GDB input file.
+
+	libiberty/
+	* lrealpath.c (lrealpath): Use cygpath on Windows.
+
+2009-09-28  Daniel Gutson <dgutson@codesourcery.com>
+
+	Issue #6041
+
+	Backport from mainline (r148770):
+
+	gcc/
+	* lib1funcs.asm ([__ARM_EABI__]): Add an attribute describing stack
+	preservation properties of code. 
+
+2009-09-25  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/testuite/
+	2009-09-25  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* gcc.dg/vect/vect.exp: Append extra parameters as separate
+	parameters for alignment-sensitive -fsection-anchors tests.
+
+2009-09-25  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue #6409
+
+	gcc/
+	* config/arm/neon.md (neon_vshll_n<mode>): Checking Bounds
+	fixed.
+
+	gcc/testsuite/
+	* gcc.target/arm/neon/vfp-shift-a2t2.c: New test case.
+
+	* release-notes-csl.xml: Document.
+
+2009-09-24  Catherine Moore  <clm@codesourcery.com>
+
+	Issue #6412
+
+	Backport from gcc 4-4:
+
+	gcc/
+	2009-09-21  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	* config/mips/mips.c (mips_override_options): Force flag_dwarf2_cfi_asm
+	to zero.
+
+2009-09-24  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config/arm/arm_neon.h (float32_t): Define as "float".
+
+2009-09-23  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (use_vfp_abi): New function.
+	(aapcs_vfp_is_call_or_return_candidate): Avoid double precision regs
+	when undesirable.
+	(aapcs_vfp_is_return_candidate, aapcs_vfp_is_call_candidate,
+	aapcs_vfp_allocate_return_reg): Use use_vfp_abi.
+
+2009-09-23  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Revert, the sequence is buggy:
+
+	2009-09-09  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	gcc/
+	* config/m68k/linux-unwind.h (m68k_fallback_frame_state): Add
+	another rt_sigreturn sequence.
+
+2009-09-22  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	libstdc++-v3/
+	2009-09-17  Joseph Myers  <joseph@codesourcery.com>
+
+	* testsuite/lib/libstdc++.exp (check_v3_target_binary_io): New.
+	* testsuite/lib/dg-options.exp (dg-require-binary-io): New.
+	* testsuite/27_io/basic_filebuf/seekoff/char/1-io.cc,
+	testsuite/27_io/basic_filebuf/seekoff/char/2-io.cc,
+	testsuite/27_io/basic_filebuf/sgetn/char/1-in.cc,
+	testsuite/27_io/basic_filebuf/sgetn/char/1-io.cc,
+	testsuite/27_io/basic_filebuf/sgetn/char/2-in.cc,
+	testsuite/27_io/basic_filebuf/sgetn/char/2-io.cc,
+	testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc,
+	testsuite/27_io/basic_istream/readsome/char/6746-2.cc,
+	testsuite/27_io/basic_istream/readsome/wchar_t/6746-2.cc,
+	testsuite/27_io/objects/char/10.cc: Use dg-require-binary-io.
+
+2009-09-22  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/testsuite/
+	2009-09-08  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.dg/profile-dir-1.c, gcc.dg/profile-dir-2.c,
+	gcc.dg/profile-dir-3.c: Disable for remote-host testing.
+
+2009-09-19  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issues #6560, #4612
+
+	* release-notes-csl.xml (Preprocessor error handling): New note.
+
+	Backport from mainline:
+
+	gcc:
+	2009-03-29  Joseph Myers  <joseph@codesourcery.com>
+
+	PR preprocessor/34695
+	* Makefile.in (c-opts.o): Depend on c-tree.h.
+	* c-common.c: Move down include of diagnostic.h.
+	(done_lexing, c_cpp_error): New.
+	* c-common.h (done_lexing): Declare.
+	* c-decl.c (c_write_global_declarations): Don't check cpp_errors
+	(parse_in).
+	* c-opts.c: Include c-tree.h.
+	(c_common_init_options): Set preprocessor error callback.
+	(c_common_handle_option): Do not set preprocessor
+	inhibit_warnings, warnings_are_errors, warn_system_headers,
+	pedantic_errors or inhibit_warnings flags.
+	(c_common_post_options): Do not check cpp_errors (parse_in).
+	(c_common_finish): Do not output dependencies if there were
+	errors.  Do not check return value of cpp_finish.
+	* c-ppoutput.c (pp_file_change): Set input_location.
+	* c-tree.h (c_cpp_error): Declare.
+	* diagnostic.c (diagnostic_set_info_translated): Also initialize
+	override_column.
+	(diagnostic_build_prefix): Check override_column.
+	* diagnostic.h (diagnostic_info): Add override_column field.
+	(diagnostic_override_column): Define.
+
+	gcc/cp:
+	2009-03-29  Joseph Myers  <joseph@codesourcery.com>
+
+	PR preprocessor/34695
+	* cp-tree.h (cp_cpp_error): Remove.
+	* error.c (cp_cpp_error): Remove.
+	* parser.c (cp_lexer_new_main): Set done_lexing instead of
+	client_diagnostic and error callback.
+
+	gcc/fortran:
+	2009-03-29  Joseph Myers  <joseph@codesourcery.com>
+
+	PR preprocessor/34695
+	* cpp.c (cb_cpp_error): New.
+	(gfc_cpp_post_options): Don't set cpp_option->inhibit_warnings.
+	Don't check cpp_errors (cpp_in).
+	(gfc_cpp_init_0): Set cb->error.
+
+	gcc/testsuite:
+	2009-03-29  Joseph Myers  <joseph@codesourcery.com>
+
+	PR preprocessor/34695
+	* gcc.dg/builtin-redefine.c, gcc.dg/cpp/redef2.c,
+	gcc.dg/cpp/redef3.c, gcc.dg/cpp/trad/redef2.c: Use dg-message
+	instead of dg-warning for "previous definition" messages.
+	* gcc.dg/cpp/Wvariadic-1.c, gcc.dg/cpp/Wvariadic-3.c: Expect
+	"warnings being treated as errors" message.
+	* gcc.dg/fltconst-1.c: Use -fshow-column.
+
+	libcpp:
+	2009-03-29  Joseph Myers  <joseph@codesourcery.com>
+
+	PR preprocessor/34695
+	* makedepend.c: Remove.
+	* Makefile.in (makedepend_OBJS, makedepend$(EXEEXT)): Remove.
+	(all, clean, TAGS_SOURCES, include): Remove makedepend handling.
+	* directives.c (cpp_errors): Remove.
+	* errors.c (print_location, _cpp_begin_message, v_message):
+	Remove.
+	(cpp_error, cpp_error_with_line): Always use error callback.
+	(cpp_error, cpp_error_with_line, cpp_errno): Return bool.
+	* include/cpplib.h (cpp_options): Remove pedantic_errors,
+	inhibit_warnings, warn_system_headers, inhibit_errors,
+	warnings_are_errors, client_diagnostic.
+	(cpp_callbacks): Add extra arguments to error callback; make it
+	return bool.
+	(cpp_finish): Return void.
+	(cpp_destroy): Remove inaccurate comment about return value.
+	(cpp_errors, CPP_DL_EXTRACT, CPP_DL_WARNING_P): Remove.
+	(CPP_DL_NOTE): Define.
+	* include/line-map.h (linemap_print_containing_files): Remove.
+	* init.c (cpp_finish): Do not check for or return number of
+	errors.
+	* internal.h (cpp_reader): Remove errors field.
+	* line-map.c (linemap_print_containing_files): Remove.
+	* macro.c (_cpp_create_definition): Use CPP_DL_NOTE for message
+	about previous definition.  Only emit it if previous diagnostic
+	was emitted.
+
+	gcc:
+	2009-03-31  Joseph Myers  <joseph@codesourcery.com>
+
+	PR preprocessor/15638
+	* c-common.c (c_cpp_error): Handle CPP_DL_FATAL.
+
+	gcc/fortran:
+	2009-03-31  Joseph Myers  <joseph@codesourcery.com>
+
+	PR preprocessor/15638
+	* cpp.c (cb_cpp_error): Handle CPP_DL_FATAL.
+
+	gcc/testsuite:
+	2009-03-31  Joseph Myers  <joseph@codesourcery.com>
+
+	PR preprocessor/15638
+	* gcc.dg/cpp/missing-header-1.c: New test.
+	* gcc.dg/cpp/include2.c: Only test #include <>.  Expect
+	"compilation terminated" message.
+	* gcc.dg/cpp/include2a.c: New test.  Copy of include2.c but only
+	test #include "".
+	* gcc.dg/pch/counter-2.c, gcc.dg/pch/valid-1.c,
+	gcc.dg/pch/valid-2.c, gcc.dg/pch/warn-1.c: Expect "compilation
+	terminated" message.
+
+	libcpp:
+	2009-03-31  Joseph Myers  <joseph@codesourcery.com>
+
+	PR preprocessor/15638
+	* files.c (_cpp_find_file): Call open_file_failed after diagnosing
+	invalid PCH.
+	(open_file_failed): Make error for missing file fatal.
+	* include/cpplib.h (CPP_DL_FATAL): Define.
+
+	[libcpp/ChangeLog]
+	2009-09-18  Chris Demetriou  <cgd@google.com>
+
+	PR preprocessor/28435:
+	* include/cpplib.h (struct cpp_options): Add new member
+	deps.need_preprocessor_output.
+	* files.c (open_file_failed): If preprocessor output is needed
+	always report an error.
+
+	[gcc/ChangeLog]
+	2009-09-19  Chris Demetriou  <cgd@google.com>
+
+	PR preprocessor/28435:
+	* c-opts.c (c_common_handle_option): For -MD and -MMD, indicate
+	to cpplib that the preprocessor output is needed.
+
+	[gcc/testsuite/ChangeLog]
+	2009-09-19  Chris Demetriou  <cgd@google.com>
+
+	PR preprocessor/28435:
+	* gcc.dg/cpp/missing-header-MD.c: New test.
+	* gcc.dg/cpp/missing-header-MMD.c: New test.
+	* gcc.dg/cpp/missing-sysheader-MD.c: New test.
+	* gcc.dg/cpp/missing-sysheader-MMD.c: New test.
+
+2009-09-11  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #5767
+
+	gcc/
+	* config/arm/arm.c (all_fpus): Add tag-5, tag-6, and neon-fma-fp16.
+	(fp_model_for_fpu): Update.
+	(arm_file_start): Handle new FPUs.
+	* config/arm/arm.h (TARGET_VFPD32, TARGET_VFP3, TARGET_NEON_FP16)
+	(TARGET_NEON): Handle new FPUs.
+	(enum fputype): Add FPUTYPE_VFP_TAG5, FPUTYPE_VFP_TAG6, and
+	FPUTYPE_NEON_FMA_FP16.
+
+2009-09-10  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #5767
+
+	gcc/
+	* config/arm/arm.h (TARGET_VFP_SINGLE, TARGET_VFP_DOUBLE): Define.
+	(enum fputype): Add FPUTYPE_VFP3xD and FPUTYPE_VFP3xD_FP16.
+	* config/arm/arm.c (all_fpus): Handle FPUTYPE_VFP3xD and
+	FPUTYPE_VFP3xD_FP16.
+	(fp_model_for_fpu): Update.
+	(arm_rtx_costs_1, arm_size_rtx_costs, arm_fastmul_rtx_costs)
+	(arm_9e_rtx_costs): Only expect double-precision operations if the FPU
+	provides them.
+	(arm_print_operand): Handle 'p' modifier.
+	(arm_file_start): Handle new FPU types.
+	* config/arm/arm.md: Disable double-precision patterns if the FPU
+	does not provide them.
+	* config/arm/constraints.md: Add new "Dy" constraint for
+	double-precision constants.  Update description of "Dv".
+	* config/arm/vfp.md: Disable double-precision patterns if the FPU
+	does not provide them.
+	(*arm_movdi_vfp, *thumb2_movdi_vfp): Use fcpys to move
+	double-precision values on a single-precision FPU.
+	(*movdf_vfp, *thumb2_movdf_vfp): Likewise.  Use "Dy" for
+	double-precision constants.
+
+2009-09-10  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #5767
+
+	gcc/
+	* config/arm/t-cs-eabi, config/arm/t-cs-eabi-lite,
+	config/arm/t-cs-linux-lite, config/arm/t-cs-uclinux-eabi: Add
+	-march=tag13 to MULTILIB_MATCHES.
+
+2009-09-10  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #5767
+
+	gcc/
+	* config/arm/arm.c (FL_TAG13, FL_FOR_ARCHTAG13): New.
+	(arm_arch_tag13): New.
+	(all_architectures): Add tag13.
+	(arm_override_options): Set arm_arch_tag13.
+	* config/arm/arm.h (TARGET_DSP_MULTIPLY, TARGET_INT_SIMD): Check
+	arm_arch_tag13.
+	(arm_arch_tag13): Declare.
+	* gcc/config/arm/t-arm-elf: Add commented-out match for -march=tag13.
+
+2009-09-09  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #4203
+
+	* release-notes-csl.xml: Fix note.
+
+2009-09-09  Paul Brook  <paul@codesourcery.com>
+
+	Issue #5767
+	gcc/
+	* doc/invoke.texi: Update list of ARM -mfpu= options.
+	* config.gcc: Update ARM --with-fpu option list.
+	* config/arm/arm.c (all_fpus): Add vfpv3-fp16 and vfpv3-d16-fp16.
+	(fp_model_for_fpu): Add FPUTYPE_VFP3D16_FP16 and FPUTYPE_VFP3_FP16.
+	(coproc_secondary_reload_class): Reload HFmode via GENERAL_REGS if no
+	NEON.
+	(arm_hard_regno_mode_ok): Allows HFmode in VFP registers if
+	TARGET_FP16.
+	(arm_file_start): Add FPUTYPE_VFP3D16_FP16 and FPUTYPE_VFP3_FP16.
+	* config/arm/arm.h (TARGET_FP16): Define.
+	(fputype): Add FPUTYPE_VFP3D16_FP16 and FPUTYPE_VFP3_FP16.
+	* config/arm/vfp.md (movhf_vfp_neon): New pattern (was movhf_vfp).
+	(movhf_vfp): Remove NEON instructions.
+	(extendhfsf2, truncsfhf2): Change condition to TARGET_FP16.
+	* config/arm/arm.md (define_attr "fpu"): Add vfpv3d16fp16 and
+	vfpv3fp16.
+	(arm32_movhf): Change condition to !TARGET_FP16. 
+
+	* release-notes-csl.xml: Document.
+
+2009-09-09  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gcc/
+	* config/m68k/linux-unwind.h (m68k_fallback_frame_state): Add
+	another rt_sigreturn sequence.
+
+2009-09-09  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gcc/
+	* config/m68k/m68k.h (TRANSFER_FROM_TRAMPOLINE): Avoid warning.
+
+2009-09-08  Paul Brook  <paul@codesourcery.com>
+	    Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #6027
+
+	* release-notes-csl.xml (Optimizer improvements): New note.
+
+	Merge submitted patches:
+	http://gcc.gnu.org/ml/gcc-patches/2009-03/msg00250.html
+
+	2009-02-02  J"orn Rennecke <amylaar@spamcop.net>
+
+	gcc/
+	* tree-ssa-pre.c (ppre_n_insert_for_speed_p): New function.
+	* (do_partial_partial_insertion): Use it to throttle
+	insert_into_preds_of_block calls.
+	* common.opt (-ftree-pre-partial-partial-obliviously): New option.
+
+	2009-01-15  J"orn Rennecke  <joern.rennecke@arc.com>
+
+	gcc/
+	* common.opt (ftree-pre-partial-partial): New option.
+	* opts.c (decode_options): Initialize flag_tree_pre_partial_partial.
+	* tree-ssa-pre.c (execute_pre): Use flag_tree_pre_partial_partial.
+
+2009-09-08  Paul Brook  <paul@codesourcery.com>
+	    Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #6027
+
+	Merge submitted patch:
+	http://gcc.gnu.org/ml/gcc-patches/2008-12/msg00199.html
+
+	2008-12-03  Steven Bosscher  <stevenb.gcc@gmail.com>
+
+	gcc/
+	* opts.c (decode_options): Fix initialization of
+	flag_tree_switch_conversion.  Don't set optimize_size in block
+	that is conditional on optimize_size (sic).  Explicitly disable
+	PRE when optimizing for size (and add comment for rationale).
+	* tree-ssa-pre.c: Update outline of the algorithm.
+	(bitmap_set_and): Prototype.
+	(insert_into_preds_of_block): Don't report discovery of partial
+	redundancies here, do so from the callers instead (see below).
+	(do_regular_insertion): Add counter for an estimate for the number
+	of inserts required to eliminate a partial redundancy.  If the
+	current function is optimized for size, only perform the partial
+	redundancy elimination if this requires inserting in only one
+	predecessor.  Report all found partial redundancies from here.
+	(do_partial_partial_insertion): Report them from here too.
+	(insert_aux): Do not insert for partial-partial redundancies when
+	optimizing for size.
+	(execute_pre): Remove bogus ATTRIBUTE_UNUSED.
+	(do_pre): Run FRE at least, if PRE is disabled.
+	(gate_pre): Return true if flag_tree pre or flag_tree_fre is set.
+
+2009-09-08  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/testsuite/
+	2009-09-08  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.misc-tests/i386-prefetch.exp: Skip tests when multilib flags
+	contain -march.
+	* gcc.dg/tree-ssa/prefetch-7.c, gcc.target/i386/387-1.c,
+	gcc.target/i386/387-5.c, gcc.target/i386/cmov7.c,
+	gcc.target/i386/funcspec-1.c, gcc.target/i386/funcspec-8.c,
+	gcc.target/i386/gcc-have-sync-compare-and-swap-1.c,
+	gcc.target/i386/gcc-have-sync-compare-and-swap-2.c,
+	gcc.target/i386/isa-6.c, gcc.target/i386/lea.c,
+	gcc.target/i386/pentium4-not-mull.c, gcc.target/i386/sse-5.c,
+	gcc.target/i386/ssefn-1.c: Skip when multilib flags contain -march
+	options other than that used in dg-options.
+
+2009-09-07  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	* release-notes-csl.xml: Add note.
+	gcc/
+	* m68k/m68k-devices.def: Add MCF5441x family.
+
+2009-09-04  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* release-notes-csl.xml: Change <code> tag to </code> tag.
+
+2009-09-04  Daniel Gutson  <dgutson@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.md (ctzsi2): Added braces
+	to avoid warning that broke booststrap.
+
+2009-09-02  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	libstdc++-v3/
+	2009-09-02  Joseph Myers  <joseph@codesourcery.com>
+
+	* testsuite/lib/libstdc++.exp (libstdc++_init): Copy .tcc files
+	under util/ to remote host.  Copy .h and .hpp files at more levels
+	under util/ to remote host.
+
+2009-09-02  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	libgcc/
+	* shared-object.mk (c_flags-$(base)$(objext)): New.
+	($(base)$(objext)): Use above.
+	($(base)_s$(objext)): Likewise.
+	* static-object.mk (c_flags-$(base)$(objext)): New.
+	($(base)$(objext)): Use above.
+
+2009-08-26  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #6189 - Enable pre-reload scheduling for Thumb-2
+
+	* release-notes-csl.xml (Improved optimization for Thumb-2): New note.
+
+	gcc/
+	* config/arm/arm.c (arm_override_options): Enable scheduling for
+	Thumb-2.
+
+2009-08-26  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Issue #6131 - Enable additional optimizations by default in Lite
+	Issue #6103 - Reduce default unrolling parameters at -O3
+
+	* release-notes-csl.xml (Improved optimization for ARM): New note.
+
+	gcc/
+	* config/arm/arm.c (arm_override_options): If flag_unroll_loops has
+	the default value, adjust unrolling parameters.
+	(arm_optimization_options): Set flag_unroll_loops to a default value.
+	Enable flag_promote_loop_indices.
+
+2009-08-26  Julian Brown  <julian@codesourcery.com>
+
+	gcc/config/arm/
+	* uclinux-eabi.h (LINK_GCC_C_SEQUENCE_SPEC): Override definition
+	for uclinux.
+
+2009-08-26  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue #6089
+	gcc/
+	* config/arm/arm.c (arm_rtx_costs_1): Don't special case for
+	Thumb-2 in the MINUS case.
+
+2009-08-21  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Issue #6264
+
+	gcc/
+	* tree-ssa-remove-local-statics.c (maybe_discover_new_declaration):
+	Don't consider non-local statics as eligible for optimization.
+
+	gcc/cp/
+	* decl2.c (mark_used): Mark _DECLs as DECL_NONLOCAL if appropriate.
+
+	gcc/testsuite/
+	* g++.dg/remove-local-statics-1.C: New test.
+	* g++.dg/remove-local-statics-2.C: New test.
+
+2009-08-20  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+	2008-10-02  Maciej W. Rozycki  <macro@codesourcery.com>
+	Issue #3673
+	gcc/testsuite/
+	* lib/target-supports.exp
+	(check_effective_target_arm_iwmmxt_ok): New procedure.
+	* gcc.target/arm/mmx-1.c: Only run if arm_iwmmxt_ok.
+
+	gcc/testsuite/
+	* gcc.target/arm/mmx-1.c: Remove the exclusion for
+	-mfloat-abi=softfp.
+
+2009-08-18  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+	
+	gcc/testsuite/
+	2009-08-18  Nathan Froyd  <froydnj@codesourcery.com>
+	
+	* gcc.dg/vect/vect.exp: Add new stanza for aligned-section-anchors-*
+	tests.
+	* gcc.dg/vect/section-anchors-nest-1.c: Rename to...
+	* gcc.dg/vect/aligned-section-anchors-nest-1.c: ...this.  Remove
+	dg-options.  Fix dg-final clause.
+
+2009-08-16  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gcc/
+	* config/m68k/lb1sf68.asm (PICCALL): Use long branch to subroutine
+	for supporting ColdFire ISAs.
+
+2009-08-16  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gcc/
+	* config/m68k/linux-unwind.h (m68k_fallback_frame_state): Add
+	alternative rt_sigreturn sequence.
+
+2009-08-14  Andrew Stubbs  <ams@codesourcery.com>
+
+	Issue #6120
+
+	Backport from mainline:
+
+	gcc/
+	2009-08-11  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+	* reload.c (find_reloads_subreg_address): Check the original
+	req_equiv_mem address to detect the case where an address is
+	not valid in the outer mode.
+
+2009-08-14  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* longlong.h (SH udiv_qrnnd) Mark "t" register clobbered.:
+
+2009-08-14  Andrew Stubbs  <ams@codesourcery.com>
+
+	libstdc++-v3/
+	* config/cpu/sh/atomicity.h (__exchange_and_add): Set earlyclobber constraint.
+
+2009-08-13  Maciej W. Rozycki  <macro@codesourcery.com>
+
+	* release-notes-csl.xml (C++ exception matching): Use the correct
+	sequence to get the & character.
+
+2009-08-12  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.dg/tree-ssa/pr21559.c: Compile with -fno-remove-local-statics.
+	* gcc.dg/tree-ssa/ssa-dse-6.c: Likewise.
+
+2009-08-11  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue #6172
+	Backport from FSF:
+	gcc/
+	2009-07-15  Richard Earnshaw  <rearnsha@arm.com>
+	* arm.md (ior_xor): New code iterator.
+	(split for ior/xor with shift and zero-extend): New split pattern.
+	* arm/predicates.md (subreg_lowpart_operator): New special predicate.
+
+2009-08-11  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue #6172
+	Backport from FSF:
+	gcc/
+	2009-06-19  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	PR target/40482
+	* config/arm/arm.c (thumb_shiftable_const): Truncate val to 
+	32 bits.
+	* config/arm/arm.md: Likewise.
+
+	gcc/testsuite/
+	2009-06-19  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	PR target/40482
+	* gcc.target/arm/pr40482.c: New test.
+	
+2009-08-11  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue #6172
+	Backport from FSF:
+	gcc/
+	2009-06-13  Richard Earnshaw  <rearnsha@arm.com>
+	PR target/40327
+	* arm/constraints.md (Pa, Pb): New constraints.
+	* arm/arm.md (thumb1_addsi3): Support more complex additions.  Add a 
+	split pattern to deal with them.
+
+2009-08-11  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue #6172
+	Backport from FSF:
+	gcc/
+	2009-06-04  Richard Earnshaw  <rearnsha@arm.com>
+	PR target/10242
+	* arm.md (arm_addsi3): Don't try to split an add with an
+	eliminable register until after reload has completed.
+
+2009-08-11  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue #6172
+	Backport from FSF:
+	gcc/
+	2009-06-02  Richard Earnshaw  <rearnsha@arm.com>
+	* arm.c (arm_get_frame_offsets): Prefer using r3 for padding a
+	push/pop multiple to 8-byte alignment.
+
+2009-08-10  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/mips/t-sgxx-linux (MULTILIB_MATCHES),
+	config/mips/cs-sgxx-linux.h (SYSROOT_SUFFIX_SPEC): Handle new
+	pre-MIPS32 CPUs.  Correct "4ks" typo.  Handle MIPS64 CPUs.
+
+2009-08-06  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue 1080
+	gcc/testsuite/
+	* g++.dg/eh/ref1.C: Add dg-bogus for non-arm targets.
+
+2009-08-04  Catherine Moore  <clm@codesourcery.com>
+
+	* gcc/
+	* config/mips/linux.h (SUBTARGET_OVERRIDE_OPTIONS): Define.
+	* config/mips/mips.c (mips_override_options): Move the uclibc
+	check to SUBTARGET_OVERRIDE_OPTIONS.
+
+2009-08-04  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #6004
+
+	* release-notes-csl.xml (Support for MIPS 1004K cores): New note.
+
+	gcc/
+	* config/mips/sdemtk.h (MIPS_ARCH_FLOAT_SPEC): Add pattern for 1004K.
+
+2009-08-04  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #6004
+
+	Backport from FSF:
+	gcc/
+	* doc/invoke.texi (MIPS Options): Document new 1004K -march options.
+	* config/mips/mips.c (mips_cpu_info_table): Add 1004K cores.
+	* config/mips/mips.h (MIPS_ISA_LEVEL_SPEC): Add pattern for 1004K.
+	(MIPS_ARCH_FLOAT_SPEC): Likewise.
+	(BASE_DRIVER_SELF_SPECS): Likewise.
+
+2009-08-04  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* c.opt (fremove-local-statics): Enable for C++.
+
+2009-08-04  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/
+	* config/mips/mips.opt (muclibc): Delete.
+	* config/mips/mips.c (mips_override_options): Check
+	linux_uclibc instead of building_for_uclibc.
+
+2009-08-02  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #5176
+
+	* release-notes-csl.xml: Add release note for
+	-fremove-local-statics default.
+
+2009-07-29  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config/arm/lib1funcs.asm (ARM_DIV_BODY): Add Thumb-2 implementation.
+	(udivsi3, aeabi_uidivmod, divsi3, aeabi_idivmod): Only use Thumb-1
+	implementation on ARMv6-M.
+
+2009-07-29  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config/arm/lib1funcs.asm (clear_cache): Use ARM_FUNC_START and
+	do_push/do_pop.
+
+2009-07-27  Joseph Myers  <joseph@codesourcery.com>
+
+	* release-notes-csl.xml: Add release note for MinGW update.
+
+2009-07-27  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config/arm/t-cs-eabi: Remove ARMv4 VFP multilib. Add big-endian
+	ARMv5t VFP multilib.
+
+2009-07-24  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	libstdc++-v3/
+	2009-07-24  Joseph Myers  <joseph@codesourcery.com>
+
+	* include/c_global/cwchar (swprintf, vswprintf): Do not use if
+	_GLIBCXX_HAVE_BROKEN_VSWPRINTF.
+	* testsuite/lib/libstdc++.exp (check_v3_target_swprintf): New.
+	* testsuite/lib/dg-options.exp (dg-require-swprintf): New.
+	* testsuite/21_strings/headers/cwchar/functions_std.cc,
+	testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc,
+	testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc:
+	Use dg-require-swprintf.
+
+2009-07-24  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #1080
+	* release-notes-csl.xml: Dcoument.
+
+	gcc/
+	* targhooks.c (hook_cxx_ttype_ref_in_bit0): New.
+	* targhooks.h (hook_cxx_ttype_ref_in_bit0): Declare.
+	* target.h (ttype_ref_encode): New field for c++.
+	* target-def.h (TARGET_CXX_TTYPE_REF_ENCODE): New.
+	(TARGET_CXX): Add it.
+	* except.c (output_ttype): If the expression is POINTER_PLUS_EXPR
+	look at the first operand for the exception type object.
+	* config/arm/arm.c (TARGET_CXX_TTYPE_REF_ENCODE): Override.
+	* config/arm/unwind-arm.c (__gnu_unwind_pr_common): Add comment
+	about references.
+	* config/arm/unwind-arm.h (_Unwind_decode_target2): Propagate the
+	bottom 2 bits.
+
+	libstdc++-v3/
+	* libsupc++/eh_arm.cc (__cxa_type_match): Use is_reference
+	parameter.
+	* libsupc++/eh_personality.cc (get_ttype_entry): Add is_ref
+	parameter and set it appropriately.
+	(get_adjusted_ptr): Add is_ref parameter and use it.
+	(check_exception_spec): Pass referenceness to get_adjusted_ptr.
+	(PERSONALITY_FUNCTION): Process referenceness.
+
+	gcc/cp/
+	* rtti.c (get_tinfo_decl): Assert not reference type.
+	* except.c (build_eh_type_type): Use ttype_ref_encode if the type
+	is a reference.
+	(expand_start_catch_block): Preserve referenceness on pointers if
+	ttype_ref_encode is non-NULL.
+	(finish_eh_spec_block): Likewise.
+	(can_convert_eh): Implement exactly the same algorithm as the
+	runtime matcher.
+	* semantics.c (finish_handler_parms): Look through reference types
+	before marking the exception object type.
+
+	gcc/testsuite/
+	* g++.dg/eh/ref1.C: New.
+	* g++.dg/eh/ref2.C: New.
+	
+2009-07-23  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/testsuite/
+	2009-07-23  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.dg/dll-4.c: Allow foo1 and foo2 in either order in
+	scan-assembler.
+
+2009-07-23  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #5962
+
+	Backport:
+
+	gcc/
+	2009-05-28  Dave Korn  <dave.korn.cygwin@gmail.com>
+
+	PR target/37216
+
+	* configure.ac (HAVE_GAS_ALIGNED_COMM):  Add autoconf test and
+	macro definition for support of three-operand format aligned
+	.comm directive in assembler on cygwin/pe/mingw target OS.
+	* configure:  Regenerate.
+	* config.h:  Regenerate.
+
+	* config/i386/winnt.c (i386_pe_asm_output_aligned_decl_common):  Use
+	aligned form of .comm directive if -mpe-aligned-commons is in effect.
+	* config/i386/cygming.opt (-mpe-aligned-commons):  Add new option.
+
+	* doc/invoke.texi (-mpe-aligned-commons):  Document new target option.
+	* doc/tm.texi (ASM_OUTPUT_COMMON):  Document zero size commons.
+
+	gcc/testsuite/
+	2009-05-28  Dave Korn  <dave.korn.cygwin@gmail.com>
+	            Uros Bizjak  <ubizjak@gmail.com>
+	            Danny Smith  <dansmister@gmail.com>
+
+	PR target/37216
+
+	* lib/target-supports.exp (check_effective_target_pe_aligned_commons):
+	New function.
+	* gcc.target/i386/pr37216.c:  New test source file.
+	* gcc.dg/compat/struct-layout-1_generate.c (dg_options[]):  No longer
+	use -fno-common for testing Cygwin and MinGW targets.
+
+2009-07-23  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gcc/
+	* target-def.h (TARGET_ASM_TTYPE): Correct typo of TARGET_ARM_TTYPE.
+	* config/arm/arm-unwind.c (__gnu_Unwind_Backtrace): Remove unused
+	label.
+
+2009-07-22  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #5774
+	Merge from GCC 4.4.1.
+	* release-notes-csl.xml: Update release note for upgrade to 4.4.
+
+2009-07-22  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #4203
+
+	* release-notes-csl.xml: Add note for the previous commit.
+
+2009-07-22  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Issue #4203
+	Backport from upstream:
+
+	gcc/
+	2009-07-09  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	* varasm.c (build_constant_desc): Don't share RTL in pool entries.
+	gcc/testsuite/
+	2009-07-09  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	* gcc.target/m68k/20090709-1.c: New.
+
+2009-07-21  Paul Brook <paul@codesourcery.com>
+
+	Issue #6016
+
+	gcc/
+	* tree-vectorizer.c (increase_alignment): Handle nested arrays.
+	Terminate debug dump with newline.
+
+	gcc/testsuite/
+	* gcc.dg/vect/section-anchors-nest-1.c: New test.
+	* lib/target-supports.exp (check_effective_target_section_anchors):
+	Add arm*-*-*.
+
+2009-07-20  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #5565
+
+	fixincludes/
+	* fixincl.tpl (sed_cmd_z): Hardcode to "sed".
+	* fixincl.x: Regenerate.
+
+2009-07-20  Andrew Stubbs  <ams@codesourcery.com>
+
+	* release-notes-csl.xml: Document issue 6013 fix.
+
+2009-07-19  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/mips/t-wrs-linux (MULTILIB_OPTIONS, MULTILIB_DIRNAMES,
+	MULTILIB_EXCEPTIONS, MULTILIB_OSDIRNAMES): Add VR5500 multilib.
+	* config/mips/wrs-linux.h (SYSROOT_SUFFIX_SPEC: Update for VR5500
+	multilib.
+
+2009-07-19  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/i386/t-wrs-linux, config/i386/wrs-linux.h,
+	config/i386/wrs-linux.opt: New.
+	* config.gcc (i586-wrs-linux-gnu): Use these files.
+
+2009-07-17  Nathan Froyd  <froydnj@codesourcery.com>
+
+	gcc/
+	* tree-ssa-loop-promote.c (analyze_loop_index_defintion_pattern):
+	Don't call TREE_OPERAND.
+
+2009-07-17  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	config/
+	2009-07-17  Joseph Myers  <joseph@codesourcery.com>
+
+	PR other/40784
+	* tls.m4 (GCC_CHECK_TLS): Add extra quoting around argument to
+	AC_LINK_IFELSE.
+
+	libjava/
+	2009-07-17  Joseph Myers  <joseph@codesourcery.com>
+
+	PR other/40784
+	* configure: Regenerate.
+
+	libstdc++-v3/
+	2009-07-17  Joseph Myers  <joseph@codesourcery.com>
+
+	PR other/40784
+	* configure: Regenerate.
+
+2009-07-17  Andrew Stubbs  <ams@codesourcery.com>
+
+	Issue #6013
+
+	Backport from mainline:
+	gcc/
+	2009-05-12  Kaz Kojima  <kkojima@gcc.gnu.org>
+	* config/sh/sh.h (OVERRIDE_OPTIONS): Clear flag_schedule_insns
+	unless -fschedule-insns is specified.
+
+2009-07-16  Joseph Myers  <joseph@codesourcery.com>
+
+	config/
+	* tls.m4 (GCC_CHECK_TLS): Restrict shared library LDFLAGS to Linux
+	host (resync with upstream version).
+
+	libgomp/
+	* configure: Regenerate.
+
+	libjava/
+	* configure: Regenerate.
+
+	libmudflap/
+	* configure: Regenerate.
+
+	libstdc++-v3/
+	* configure: Regenerate.
+
+2009-07-14  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/testsuite/
+	2009-07-14  Joseph Myers  <joseph@codesourcery.com>
+
+	* gcc.target/i386/pr37843-1.c, gcc.target/i386/pr37843-2.c,
+	gcc.target/i386/pr37843-3.c: Allow leading underscore on function
+	name.
+
+2009-07-14  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Revert:
+	
+	2009-07-02  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	Merge from Sourcery G++ 4.3:
+	gcc/
+	* haifa-sched.c (max_issue): Fix handling of number of instruction to
+	try.
+
+2009-07-14  Paul Brook <paul@codesourcery.com>
+
+	Issue #5829
+
+	config/
+	* stdint.m4: Avoid pulling in headers when checking basic type sizes.
+
+	libstdc++-v3/
+	* configure: Regenerate.
+
+2009-07-13  Paul Brook <paul@codesourcery.com>
+
+	Issue #2335
+	gcc/
+	* doc/tm.texi (ARG_POINTER_CFA_OFFSET): Document new default.
+	* defaults.h (ARG_POINTER_CFA_OFFSET): Add pretend_args_size.
+	* config/spu/spu.h (ARG_POINTER_CFA_OFFSET): Add pretend_args_size.
+
+2009-07-10  Mark Mitchell  <mark@codesourcery.com>
+
+	Issue #6006
+	
+	* release-notes-csl.xml: Document.
+
+	Backport from mainline:
+	2009-07-10  Mark Mitchell  <mark@codesourcery.com>
+	* config/arm/thumb2.md (thumb2_cbz): Correct computation of length
+	attribute.
+	(thumb2_cbnz): Likewise.
+
+2009-07-10  Julian Brown  <julian@codesourcery.com>
+
+	Issue #5999
+
+	gcc/config/arm
+	* neon.md (movmisalign<mode>): Add neon_type attribute.
+
+2009-07-10  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue 4909
+
+	gcc/testsuite/
+	* gcc.target/arm/ctz.c: Fixed scan-assembler target.
+
+2009-07-09  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/testsuite/
+	* g++.dg/torture/pr36191.C: Don't attempt to test with
+	-fomit-frame-pointer.
+
+2009-07-09  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* config.gcc (sh*-*-*): Remove cs-sgxxlite-linux.opt.
+	* config/sh/cs-sgxxlite-linux.h (SUBTARGET_OVERRIDE_OPTIONS): Use
+	linux_uclibc instead of build_for_uclibc.
+	* config/sh/cs-sgxxlite-linux.opt: Delete file.
+
+2009-07-09  Julian Brown  <julian@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-05-16  Richard Earnshaw  <rearnsha@arm.com>
+
+	gcc/config/arm/
+	* arm.md (movdi2): Copy non-reg values to DImode registers.
+
+2009-07-08  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.dg/torture/type-generic-1.c: Link with floating point
+	emulation for target mips-sde-elf.
+
+2009-07-07  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/
+	* config/mips/mips.md (abs<mode>2):  Remove checks for HARD_FLOAT
+	and TARGET_SDE.
+
+2009-07-07  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.target/mips/clear-cache-2.c: Add target checks for
+	mips-sde-elf.
+
+2009-07-06  Paul Brook <paul@codesourcery.com>
+
+	Issue #3979
+	gcc/
+	* gengtype-lex.l (IWORD): Add HARD_REG_SET.
+	* expr.c (expand_expr_real_1): Record modified hard registers.
+	* function.h: Include hard-reg-set.h.
+	(rtl_data): Add asm_clobbers.
+	* ira.c (compute_regs_asm_clobbered): Use crtl->asm_clobbers.
+	(setup_eliminable_regset): Ditto.
+
+	gcc/testsuite/
+	* gcc.target/arm/frame-pointer-1.c: New test.
+
+2009-07-06  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/testsuite/
+	2009-07-06  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* lib/target-supports.exp
+	(check_effective_target_mips_newabi_large_long_double): New.
+	* gcc.target/mips/fpr-moves-5.c: Require mips_newabi_large_long_double
+	target.
+	* gcc.target/mips/fpr-moves-6.c: Likewise.
+
+2009-07-05  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	libstdc++-v3/
+	2009-07-05  Joseph Myers  <joseph@codesourcery.com>
+
+	*
+	testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stod.cc,
+	testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stof.cc,
+	testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoi.cc,
+	testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stol.cc,
+	testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stold.cc,
+	testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoll.cc,
+	testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoul.cc,
+	testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoull.cc,
+	testsuite/21_strings/basic_string/numeric_conversions/wchar_t/to_wstring.cc,
+	testsuite/ext/vstring/element_access/char/front_back.cc,
+	testsuite/ext/vstring/element_access/wchar_t/front_back.cc,
+	testsuite/ext/vstring/init-list.cc,
+	testsuite/ext/vstring/moveable.cc,
+	testsuite/ext/vstring/requirements/citerators.cc,
+	testsuite/ext/vstring/requirements/explicit_instantiation/char16_t/1.cc,
+	testsuite/ext/vstring/requirements/explicit_instantiation/char32_t/1.cc:
+	Use dg-require-string-conversions.
+
+2009-07-03  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #1063
+
+	config/
+	* tls.m4 (GCC_CHECK_TLS): Also test TLS in a shared library when
+	cross-compiling.
+
+	libgomp/
+	* configure: Regenerate.
+
+	libjava/
+	* configure: Regenerate.
+
+	libmudflap/
+	* configure: Regenerate.
+
+	libstdc++-v3/
+	* configure: Regenerate.
+
+2009-07-03  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-05-26  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+	gcc/
+	2008-04-30  Nathan Froyd  <froydnj@codesourcery.com>
+	* config/rs6000/t-ppccomm: Add build rules for new files.
+	(LIB2FUNCS_STATIC_EXTRA): Add new files.
+
+	libgcc/
+	2008-04-30  Nathan Froyd  <froydnj@codesourcery.com>
+	* config/rs6000/t-ppccomm: Add build rules for new files.
+	(LIB2ADD_ST): New variable.
+
+2009-07-03  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gcc/
+	* doc/tm.texi (TARGET_COMMUTATIVE_OPERAND_PRECEDENCE): Document.
+	* target.h (commutative_operand_precedence): New hook.
+	* target-def.h (TARGET_COMMUTATIVE_OPERAND_PRECEDENCE): Define
+	the default.
+	* rtlanal.c (commutative_operand_precedence): Use the new hook.
+	Move favoring of pointer objects to ...
+	* config/rs6000/rs6000.c (rs6000_commutative_operand_precedence):
+	... here.  Implement hook.
+
+2009-07-02  Andrew Jenner  <andrew@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-03-30  Andrew Jenner  <andrew@codesourcery.com>
+
+        gcc/
+        * config.gcc: Accept montavista*-, not just montavista-.
+        * config/mips/t-montavista-linux: Add Octeon multilibs.
+
+2009-07-02  Andrew Jenner  <andrew@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-02-04  Andrew Jenner  <andrew@codesourcery.com>
+
+        gcc/
+        * config.gcc: Handle arm-montavista-linux-gnueabi,
+        mips-montavista-linux-gnu, mips64octeon*-montavista-elf* and
+        powerpc-montavista-linux-gnu.
+        * config/rs6000/t-montavista-linux: New file.
+        * config/rs6000/montavista-linux.h: New file.
+        * config/arm/t-montavista-linux: New file.
+        * config/arm/montavista-linux.h: New file.
+        * config/mips/t-montavista-linux: New file.
+        * config/mips/t-montavista-elf: New file.
+        * config/mips/montavista-linux.h: New file.
+
+        libgcc/
+        * config.host: Handle mips64octeon-montavista-elf*.
+
+2009-07-02  Andrew Jenner  <andrew@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-02-17  Andrew Jenner  <andrew@codesourcery.com>
+		    Maciej Rozycki  <macro@codesourcery.com>
+
+        gcc/
+        * unwind.inc (_Unwind_RaiseException): Use return value of
+        uw_init_context.
+        * unwind-dw2.c (uw_init_context): Make macro an expression instead of
+        a statement.
+        (uw_init_context_1): Add return value.
+        * unwind-sjlj.c (uw_init_context): Add return value.
+
+2009-07-02  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/
+	* config/mips/mips.h (ISA_HAS_UL_US): Delete extraneous
+	definition.  Fix typo.
+	* config/mips/mips.c (mips_expand_ext_as_unaligned_load):
+	Generate mov_uld or mov_ulw if ISA_HAS_UL_US.
+	* config/mips/mips.md (UNSPEC_UNALIGNED_LOAD): Equate to 60.
+	(UNSPEC_UNALIGNED_STORE): Equate to 61.
+
+2009-07-02  Mark Mitchell  <mark@codesourcery.com>
+
+	Issue #5943
+	
+	Backport from mainline:
+
+	2009-07-02  Mark Mitchell  <mark@codesourcery.com>
+
+	gcc/cp/
+	* typeck.c (cp_build_binary_op): Move warnings about use of NULL
+	in arithmetic earlier and allow comparisions of NULL with
+	pointers-to-members.
+
+	gcc/testsuite/
+	* g++.dg/warn/null4.C: Extend.
+
+2009-07-02  Maxim Kuvyrkov  <maxim@codesourcery.com>
+        
+	Merge from Sourcery G++ 4.3:
+	
+	gcc/
+	* haifa-sched.c (max_issue): Fix handling of number of instruction to
+	try.
+
+2009-07-02  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+	
+	gcc/
+	* haifa-sched.c (insn_finishes_cycle_p): New static function.
+        (max_issue): Use it.
+        * sched-int.h (struct sched_info: insn_finishes_block_p): New
+        scheduler hook.
+        * sched-rgn.c (rgn_insn_finishes_block_p): Implement it.
+        (region_sched_info): Update.
+        * sched-ebb.c (ebb_sched_info): Update.
+        * modulo-sched.c (sms_sched_info): Update.
+	* sel-sched-ir.c (sched_sel_haifa_sched_info): Update.
+
+2009-07-01  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #4168
+
+	gcc/
+	* gcc.c (using_libgcc, executing_linker): New.
+	(execute): Check that libgcc.a exists in the multilib directory
+	when linking.
+	(process_command): Set using_libgcc to 0 for -nodefaultlibs,
+	-nostdlib and -B options.
+	(main): Set executing_linker when processing spec that may run the
+	linker.
+
+2009-07-01  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.target/mips/mips.exp (mips_option_groups): Add
+	-mocteon-useun.
+	* gcc.target/mips/octeon-useun.c: Change dg-mips-options to
+	dg-options.
+	* gcc.target/mips/branch-2.c: Likewise.
+
+2009-07-01  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.c-torture/execute/ieee/ieee.exp: Link with floating
+	point emulation for mips-sde-elf targets.
+
+2009-06-30  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-08-27  Daniel Gutson  <daniel@codesourcery.com>
+
+	Janus 2CC ARM shift fix:
+	gcc/
+	* config/arm/arm.md (*addsi3_carryin_shift): Added "length" clause
+	to handle the extra NOP.
+	(andsi_not_shiftsi_si): Likewise.
+	(*thumb1_ashlsi3): Likewise.
+	(*thumb1_ashrsi3): Likewise.
+	(*thumb1_lshrsi3): Likewise.
+	(*thumb1_rotrsi3): Likewise.
+	(*arm_shiftsi3): Likewise.
+	(*shiftsi3_compare0): Likewise.
+	(*shiftsi3_compare0_scratch): Likewise.
+	(*arm_notsi_shiftsi): Likewise.
+	(*arm_notsi_shiftsi_compare0): Likewise.
+	(*arm_not_shiftsi_compare0_scratch): Likewise.
+	(*arm_cmpsi_shiftsi): Likewise.
+	(*arm_cmpsi_shiftsi_swp): Likewise.
+	(*arm_cmpsi_negshiftsi_si): Likewise.
+	(*arith_shiftsi): Likewise.
+	(*arith_shiftsi_compare0): Likewise.
+	(*arith_shiftsi_compare0_scratch): Likewise.
+	(*sub_shiftsi): Likewise.
+	(*sub_shiftsi_compare0): Likewise.
+	(*sub_shiftsi_compare0_scratch): Likewise.
+	(*if_shift_move): Likewise.
+	(*if_move_shift): Likewise.
+	(*if_shift_shift): Likewise.
+	(*thumb1_ashlsi3_janus2): New. Duplicated pattern to handle the
+	extra NOP.
+	(*thumb1_ashrsi3_janus2): Likewise.
+	(*thumb1_lshrsi3_janus2): Likewise.
+	(*thumb1_rotrsi3_janus2): Likewise.
+	* config/arm/arm.c (arm_print_operand): Added the nop after the %S
+	pattern.
+	(arm_override_options): Added handling of the -mfix-janus-2cc flag
+	* config/arm/arm.h (janus2_code): Declare.
+	* config/arm/arm.opt (-mfix-janus-2cc): New.
+  
+	testsuite/
+	* lib/target-supports.exp (check_effective_target_arm_no_thumb):
+	New function.
+	* gcc.target/arm/janus-2cc-shift-1.c: New.
+	* gcc.target/arm/janus-2cc-shift-2.c: New.
+
+2009-06-29  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gcc/
+	* config/arm/neon-testgen.ml: Use dg-add-options arm_neon.
+
+	gcc/testsuite/
+	* gcc/target/arm/neon/: Regenerated test cases.
+
+	* gcc.target/arm/neon/polytypes.c,
+	gcc.target/arm/neon-vmla-1.c, gcc.target/arm/neon-vmls-1.c,
+	gcc.target/arm/neon-cond-1.c, gcc.dg/torture/arm-fp16-ops-8.c,
+	gcc.dg/torture/arm-fp16-ops-7.c, g++.dg/ext/arm-fp16/arm-fp16-ops-7.C,
+	g++.dg/ext/arm-fp16/arm-fp16-ops-8.C, g++.dg/abi/mangle-neon.C: Use
+	dg-add-options arm_neon.
+
+	* gcc.target/arm/fp16-compile-vcvt.c, gcc.dg/torture/arm-fp16-ops-5.c,
+	gcc.dg/torture/arm-fp16-ops-6.c, g++.dg/ext/arm-fp16/arm-fp16-ops-5.C,
+	g++.dg/ext/arm-fp16/arm-fp16-ops-6.C: Use dg-add-options arm_neon_fp16
+	and arm_neon_fp16_ok.
+
+	* gcc.dg/vect/vect.exp, g++.dg/vect/vect.exp,
+	gfortran.dg/vect/vect.exp: Use add_options_for_arm_neon.
+
+	* lib/target-supports.exp (add_options_for_arm_neon): New.
+	(check_effective_target_arm_neon_ok_nocache): New, from
+	check_effective_target_arm_neon_ok.  Check multiple possibilities.
+	(check_effective_target_arm_neon_ok): Use
+	check_effective_target_arm_neon_ok_nocache.
+	(add_options_for_arm_neon_fp16)
+	(check_effective_target_arm_neon_fp16_ok)
+	check_effective_target_arm_neon_fp16_ok_nocache): New.
+	(check_effective_target_arm_neon_hw): Use add_options_for_arm_neon.
+
+2009-06-29  Paul Brook <paul@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2005-03-10  Julian Brown  <julian@codesourcery.com>
+	libstdc++-v3/
+	* configure.ac (LIBSUPCXX_PRONLY): New AM_CONDITIONAL: yes
+	if we are compiling for SymbianOS on ARM.
+	* include/Makefile.am: Don't install C++ headers if
+	LIBSUPCXX_PRONLY is true.
+	* libsupc++/Makefile.am: Include only eh_personality.cc
+	in libsupc++ if LIBSUPCXX_PRONLY is true.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+	* include/Makefile.in: Regenerate.
+	* libmath/Makefile.in: Regenerate.
+	* libsupc++/Makefile.in: Regenerate.
+	* po/Makefile.in: Regenerate.
+	* src/Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2009-06-29  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+	2009-02-27  Daniel Gutson  <dgutson@codesourcery.com>
+	Issue #4459
+	gcc/
+	* config/arm/linux-eabi.h (LINK_SPEC): BE8_LINK_SPEC added.
+	* config/arm/arm-cores.def: Comment added.
+	* config/arm/bpapi.h (BE8_LINK_SPEC): New define.
+	(LINK_SPEC): BE_LINK_SPEC added.
+
+	Merge from Sourcery G++ 4.3:
+	2009-04-21  Andrew Jenner  <andrew@codesourcery.com>
+	gcc/testsuite/
+	* lib/target-supports.exp: Handle powerpc-*-elf.
+
+2009-06-26  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-08-10  Catherine Moore  <clm@codesourcery.com>
+	Merge from Sourcery G++ 4.2:
+	2008-02-28  Julian Brown  <julian@codesourcery.com>
+	Merge from MIPS:
+	gcc/
+	* Makefile.in (stmp-int-hdrs): Don't depend on
+	fixinc_list. Only
+	process fixincludes if fixinc_list is
+	present.
+	(install-mkheaders): Likewise.
+	
+2009-06-26  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+	
+	2008-08-10  Catherine Moore  <clm@codesourcery.com>
+	Merge from Sourcery G++ 4.2:
+	2008-02-11  Julian Brown  <julian@codesourcery.com>
+	Merge from MIPS:
+	2004-06-29  Nigel Stephens  <nigel@mips.com>
+	
+	* Makefile.in (libgcc.mk): Make this depend on
+	$(tmake_file), in
+	case new multilib options have been defined.
+	(s-mlib): Similarly.
+	
+2009-06-26  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-10-12  Catherine Moore  <clm@codesourcery.com>
+	gcc/
+	* config/mips/mips.opt (muclibc): New option entry.
+	* config/mips/mips.c (mips_override_options): Disable
+	__thread support when the -muclibc option is used.
+
+2009-06-26  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	gcc/
+	* config/m68k/linux-unwind.h (m68k_fallback_frame_state): Update to
+	handle 2.6.30 kernel.
+
+2009-06-26  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-02-26  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #4730
+
+	gcc/
+	* config/arm/arm.c (arm_libcall_value, arm_init_cumulative_args):
+	Use base ABI for conversion libfuncs between HFmode and SFmode.
+
+2009-06-26  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Backport fp16 support from FSF mainline:
+
+	2009-05-20  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* doc/tm.texi (Misc): Document TARGET_INVALID_PARAMETER_TYPE,
+	TARGET_INVALID_RETURN_TYPE, TARGET_PROMOTED_TYPE, and
+	TARGET_CONVERT_TO_TYPE.
+	* hooks.c (hook_tree_const_tree_null): Define.
+	* hooks.h (hook_tree_const_tree_null): Declare.
+	* target.h (struct gcc_target):  Add invalid_parameter_type,
+	invalid_return_type, promoted_type, and convert_to_type fields.
+	* target-def.h: (TARGET_INVALID_PARAMETER_TYPE): Define.
+	(TARGET_INVALID_RETURN_TYPE): Define.
+	(TARGET_PROMOTED_TYPE): Define.
+	(TARGET_CONVERT_TO_TYPE): Define.
+	(TARGET_INITIALIZER): Update for new fields.
+	* c-decl.c (grokdeclarator): Check targetm.invalid_return_type.
+	(grokparms): Check targetm.invalid_parameter_type.
+	* c-typeck.c (default_conversion): Check targetm.promoted_type.
+	* c-convert.c (convert): Check targetm.convert_to_type.
+
+	gcc/cp/
+	* typeck.c (default_conversion): Check targetm.promoted_type.
+	* decl.c (grokdeclarator): Check targetm.invalid_return_type.
+	(grokparms): Check targetm.invalid_parameter_type.
+	* cvt.c (ocp_convert): Check targetm.convert_to_type.
+	(build_expr_type_conversion): Check targetm.promoted_type.
+
+	2009-05-15  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* real.c (encode_ieee_half): Define.
+	(decode_ieee_half): Define.
+	(ieee_half_format): Define.
+	(arm_half_format): Define.
+	* real.h (ieee_half_format): Declare.
+	(arm_half_format): Declare.
+
+	2009-05-15  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* fold-const.c (fold_convert_const_real_from_real): Check for
+	overflow.
+
+	2009-06-18  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* doc/extend.texi (Half-Precision): New section.
+	* doc/invoke.texi (Option Summary): List -mfp16-format.
+	(ARM Options): List neon-fp16 as -mfpu value.  Document -mfp16-format.
+	* config/arm/arm.opt (mfp16-format=): New.
+	* config/arm/arm.c: Include intl.h.
+	(TARGET_INVALID_PARAMETER_TYPE): Redefine.
+	(TARGET_INVALID_RETURN_TYPE): Redefine.
+	(TARGET_PROMOTED_TYPE): Redefine.
+	(TARGET_CONVERT_TO_TYPE): Redefine.
+	(arm_fp16_format): Define.
+	(all_fpus): Add entry for neon-fp16.
+	(fp_model_for_fpu): Likewise.
+	(struct fp16_format): Declare.
+	(all_fp16_formats): Define.
+	(arm_init_libfuncs): Add entries for HFmode conversions and arithmetic
+	functions.
+	(arm_override_options): Set arm_fp16_format. Call sorry for fp16
+	and no ldrh.
+	(arm_legitimate_index_p): Treat HFmode like HImode.
+	(thumb1_legitimate_address_p): Make it recognize HFmode constants.
+	(coproc_secondary_reload_class): Special-case HFmode.
+	(arm_print_operand): Add 'z' specifier for vld1.16/vst1.16.
+	(arm_hard_regno_mode_ok): Allow HFmode values in VFP registers.
+	(arm_init_fp16_builtins): New.
+	(arm_init_builtins): Call it.
+	(arm_invalid_parameter_type): New.
+	(arm_invalid_return_type): New.
+	(arm_promoted_type): New.
+	(arm_convert_to_type).
+	(arm_file_start): Deal with neon-fp16 as fpu_name.  Emit tag for fp16
+	format.
+	(arm_emit_fp16_const): New function.
+	(arm_mangle_type): Mangle __fp16 as "Dh".
+	* config/arm/arm.h (TARGET_VFPD32): Make it know about
+	FPUTYPE_NEON_FP16.
+	(TARGET_NEON_FP16): New.
+	(TARGET_NEON): Make it know about FPUTYPE_NEON_FP16.
+	(enum fputype): Add FPUTYPE_NEON_FP16.
+	(enum arm_fp16_format_type): Declare.
+	(arm_fp16_format): Declare.
+	(LARGEST_EXPONENT_IS_NORMAL): Define.
+	* config/arm/arm-protos.h (arm_emit_fp16_const): Declare.
+	* config/arm/arm-modes.def (HFmode): Define.
+	* config/arm/vfp.md: (*movhf_vfp): New.
+	(extendhfsf2): New.
+	(truncsfhf2): New.
+	* config/arm/arm.md: (fpu): Add neon_fp16.
+	(floatsihf2, floatdihf2): New.
+	(fix_trunchfsi2, fix_trunchfdi2): New.
+	(truncdfhf2): New.
+	(extendhfdf2): New.
+	(movhf): New.
+	(*arm32_movhf): New.
+	(*thumb1_movhf): New.
+	(consttable_2): Add check for HFmode constants.
+	(consttable_4): Handle HFmode constants.
+
+	2009-06-18  Paul Brook  <paul@codesourcery.com>
+	    Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* config/arm/sfp-machine.h (_FP_NANFRAC_H, _FP_NANSIGN_H): Define.
+	(__extendhfsf2, __truncsfhf2): Define.
+	* config/arm/fp16.c: New file.
+	* config/arm/t-bpabi (LIB2FUNCS_STATIC_EXTRA): Add fp16.c.
+	* config/arm/t-symbian (LIB2FUNCS_STATIC_EXTRA):  Add fp16.c.
+
+	2009-06-18  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.target/arm/fp16-compile-alt-1.c: New.
+	* gcc.target/arm/fp16-compile-alt-2.c: New.
+	* gcc.target/arm/fp16-compile-alt-3.c: New.
+	* gcc.target/arm/fp16-compile-alt-4.c: New.
+	* gcc.target/arm/fp16-compile-alt-5.c: New.
+	* gcc.target/arm/fp16-compile-alt-6.c: New.
+	* gcc.target/arm/fp16-compile-alt-7.c: New.
+	* gcc.target/arm/fp16-compile-alt-8.c: New.
+	* gcc.target/arm/fp16-compile-alt-9.c: New.
+	* gcc.target/arm/fp16-compile-alt-10.c: New.
+	* gcc.target/arm/fp16-compile-alt-11.c: New.
+	* gcc.target/arm/fp16-compile-ieee-1.c: New.
+	* gcc.target/arm/fp16-compile-ieee-2.c: New.
+	* gcc.target/arm/fp16-compile-ieee-3.c: New.
+	* gcc.target/arm/fp16-compile-ieee-4.c: New.
+	* gcc.target/arm/fp16-compile-ieee-5.c: New.
+	* gcc.target/arm/fp16-compile-ieee-6.c: New.
+	* gcc.target/arm/fp16-compile-ieee-7.c: New.
+	* gcc.target/arm/fp16-compile-ieee-8.c: New.
+	* gcc.target/arm/fp16-compile-ieee-9.c: New.
+	* gcc.target/arm/fp16-compile-ieee-10.c: New.
+	* gcc.target/arm/fp16-compile-ieee-11.c: New.
+	* gcc.target/arm/fp16-compile-none-1.c: New.
+	* gcc.target/arm/fp16-compile-exprtype.c: New.
+	* gcc.target/arm/fp16-compile-vcvt.c: New.
+	* gcc.target/arm/fp16-builtins-1.c: New.
+	* gcc.target/arm/fp16-rounding-alt-1.c: New.
+	* gcc.target/arm/fp16-rounding-ieee-1.c: New.
+	* gcc.target/arm/fp16-param-1.c: New.
+	* gcc.target/arm/fp16-return-1.c: New.
+	* gcc.target/arm/fp16-unprototyped-1.c: New.
+	* gcc.target/arm/fp16-unprototyped-2.c: New.
+	* gcc.target/arm/fp16-variadic-1.c: New.
+	* gcc.dg/torture/arm-fp16-compile-assign.c: New.
+	* gcc.dg/torture/arm-fp16-compile-convert.c: New.
+	* gcc.dg/torture/arm-fp16-int-convert-alt.c: New.
+	* gcc.dg/torture/arm-fp16-int-convert-ieee.c: New.
+	* gcc.dg/torture/arm-fp16-ops.h: New.
+	* gcc.dg/torture/arm-fp16-ops-1.c: New.
+	* gcc.dg/torture/arm-fp16-ops-2.c: New.
+	* gcc.dg/torture/arm-fp16-ops-3.c: New.
+	* gcc.dg/torture/arm-fp16-ops-4.c: New.
+	* gcc.dg/torture/arm-fp16-ops-5.c: New.
+	* gcc.dg/torture/arm-fp16-ops-6.c: New.
+	* gcc.dg/torture/arm-fp16-ops-7.c: New.
+	* gcc.dg/torture/arm-fp16-ops-8.c: New.
+	* g++.dg/ext/arm-fp16/fp16-overload-1.C: New.
+	* g++.dg/ext/arm-fp16/fp16-return-1.C: New.
+	* g++.dg/ext/arm-fp16/fp16-param-1.C: New.
+	* g++.dg/ext/arm-fp16/fp16-mangle-1.C: New.
+	* g++.dg/ext/arm-fp16/arm-fp16-ops.h: New.
+	* g++.dg/ext/arm-fp16/arm-fp16-ops-1.C: New.
+	* g++.dg/ext/arm-fp16/arm-fp16-ops-2.C: New.
+	* g++.dg/ext/arm-fp16/arm-fp16-ops-3.C: New.
+	* g++.dg/ext/arm-fp16/arm-fp16-ops-4.C: New.
+	* g++.dg/ext/arm-fp16/arm-fp16-ops-5.C: New.
+	* g++.dg/ext/arm-fp16/arm-fp16-ops-6.C: New.
+	* g++.dg/ext/arm-fp16/arm-fp16-ops-7.C: New.
+	* g++.dg/ext/arm-fp16/arm-fp16-ops-8.C: New.
+
+	2009-06-18  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (TARGET_SCALAR_MODE_SUPPORTED_P): Redefine.
+	(arm_scalar_mode_supported_p): New function.
+
+	gcc/testsuite/
+	* gcc.target/arm/fp16-compile-none-2.c: New.
+	* gcc.target/arm/fp16-compile-ieee-12.c: New.
+	* gcc.target/arm/fp16-compile-alt-12.c: New.
+
+2009-06-24  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	Issue #4753
+
+	gcc/    
+	* config/arm/arm-cores.def: Added core cortex-m0.
+	* config/arm/arm-tune.md ("tune"): Aded cortexm0.
+	* doc/invoke.texi: Added entry for cpu ARM Cortex-M0.
+
+2009-06-24  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* release-notes-csl.xml (Mixed integer and floating-point code): New
+	note.
+
+	gcc/
+	* config/arm/arm.h (REGISTER_MOVE_COST): Increase VFP register
+	move cost.
+
+2009-06-23  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue 4909
+	gcc/
+	* config/arm/arm.h (CTZ_DEFINED_VALUE_AT_ZERO): New macro.
+
+2009-06-23  Kazu Hirata  <kazu@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	Issue #4613
+	gcc/
+	* config/arm/arm.c (arm_rtx_costs_1): Teach that the cost of MLS
+	is the same as its underlying multiplication.
+	* config/arm/arm.md (two splitters): New.
+	* config/arm/predicates.md (binary_operator): New.
+
+2009-06-22  Kazu Hirata  <kazu@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	Issue #5105
+	gcc/testsuite/
+	* gcc.target/m68k/pr36134.c: Use dg-skip-if to skip the testcase
+	if there is a conflict with -mcpu=.  Use -mcpu=5208.
+
+2009-06-22  Kazu Hirata  <kazu@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	Issue #3422
+	* config.gcc (mips64*-*-linux*, mipsisa64*-*-linux*,
+	mips*-*-linux*): Add mips/t-crtfm to tmake_file.
+	* config/mips/crtfastmath.c: New.
+	* config/mips/linux.h (ENDFILE_SPEC): New.
+	* config/mips/linux64.h (ENDFILE_SPEC): New.
+	* config/mips/t-crtfm: New.
+
+	libgcc/
+	* config.host (mips64*-*-linux*, mips*-*-linux*): Add mips/t-crtfm
+	to tmake_file.  Add crtfastmath.o to extra_parts.
+	* config/mips/t-crtfm: New.
+
+2009-06-22  Daniel Gutson  <dgutson@codesourcery.com>
+
+	Issue 4909
+
+	gcc/
+	* config/arm/arm.md (UNSPEC_RBIT): New constant.
+	(rbitsi2): New insn.
+	(ctzsi2): New expand.
+
+	gcc/testsuite/
+	* gcc.target/arm/ctz.c: New test case.
+
+	* release-notes-csl.xml: Document.
+
+2009-06-22  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-05-14  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	gcc/
+	* config/m68k/m68k-devices.def: Add line for MCF5221x.
+
+2009-06-19  Paul Brook  <paul@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-10-21  Paul Brook  <paul@codesourcery.com>
+	gcc/
+	* config/arm/arm.md (consttable_4): Handle (high ...).
+
+2009-06-19  Catherine Moore  <clm@codesourcery.com>
+
+	* release-notes-csl.xml:  Document interrupt attributes
+	for MIPS.
+
+2009-06-19  Paul Brook  <paul@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-06-04  Paul Brook  <paul@codesourcery.com>
+	Fix Issue #2917
+	gcc/
+	* config/arm/arm.c (neon_vector_mem_operand): Handle element/structure
+	loads.  Allow PRE_DEC.
+	(output_move_neon): Handle PRE_DEC.
+	(arm_print_operand): Add 'A' for neon structure loads.
+	* config/arm/arm-protos.h (neon_vector_mem_operand): Update prototype.
+	* config/arm/neon.md (movmisalign): Use Um constraint and %A.
+	* config/arm/constraints.md (Un, Us): Update neon_vector_mem_operand
+	calls.
+	(Um): New constraint.
+
+2009-06-19  Paul Brook  <paul@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+	Issue #1510
+	2007-04-27  Paul Brook  <paul@codesourcery.com>
+	gcc/
+	* cse.c (cse_process_notes): Make sure PLUS are canonical.
+
+2009-06-19  Paul Brook  <paul@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-05-28  Paul Brook  <paul@codesourcery.com>
+	Avoid Issue #2945
+	gcc/
+	* config/arm/arm.md (abssi2): Add TARGET_NO_SINGLE_COND_EXEC expander.
+	(arm_abssi2, arm_neg_abssi2): Enable for Thumb-2. Always split.
+	(arm_nocond_abssi2, arm_nocond_neg_abssi2): New patterns.
+	Add splitters for abssi patterns.
+	* config/arm/thumb2.md (thumb2_abssi2, thumb2_neg_abssi2): Remove.
+
+2009-06-19  Paul Brook  <paul@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+	2007-03-30  Paul Brook  <paul@codesourcery.com>
+	gcc/
+	* calls.c (store_one_arg): Check alignment of mode used for save.
+
+2009-06-19  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2007-02-16  Richard Sandiford  <richard@codesourcery.com>
+ 	gcc/
+	* config/m68k/m68k.h (INDEX_REG_CLASS): Delete in favor of...
+	(MODE_INDEX_REG_CLASS): ...this new macro.  Return NO_REGS unless
+	MODE_OK_FOR_INDEX_P.
+	(MODE_OK_FOR_INDEX_P): New macro.
+	(REGNO_OK_FOR_INDEX_P): Delete in favor of...
+	(REGNO_MODE_OK_FOR_INDEX_P): ...this new macro.  Return false
+	unless MODE_OK_FOR_INDEX_P.
+	(REG_OK_FOR_INDEX_P): Delete in favor of...
+	(REG_MODE_OK_FOR_INDEX_P): ...this new macro.  Return false
+	unless MODE_OK_FOR_INDEX_P.
+	* m68k-protos.h (m68k_legitimate_index_reg_p): Add mode argument.
+	* m68k.c (m68k_legitimate_index_reg_p, m68k_decompose_index):
+	Add mode argument.  Use it.
+	* config/m68k/m68k.md (tst<mode>_cf, cmp<mode>_cf, movsf_cf_hard)
+	(movdf_cf_hard, extendsfdf2_cf, truncdfsf2_cf, ftrunc<mode>2_cf)
+	(add<mode>3_cf, sub<mode>3_cf, fmul<mode>3_cf, div<mode>3_cf)
+	(neg<mode>2_cf, sqrt<mode>2_cf, abs<mode>2_cf): Replace "Q<U>"
+	constraints for FP addresses with "m" constraints.
+	
+	2007-02-16  Nathan Sidwell  <nathan@codesourcery.com>
+	gcc/testsuite/
+	* gcc.dg/m68k-fp-1.c: New.
+
+2009-06-19  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+  	Merge from Sourcery G++ 4.3:
+
+	2007-02-16  Richard Sandiford  <richard@codesourcery.com>
+
+	gcc/
+	* Makefile.in (postreload.o): Depend on addresses.h.
+	* addresses.h (index_reg_class, ok_for_index_p_1): New functions.
+	(regno_ok_for_index_p): New function.
+	* postreload.c: Include addresses.h.
+	(reload_combine): Use index_reg_class instead of INDEX_REG_CLASS.
+	* ira-costs.c (ok_for_index_p_nonstrict): Add a mode argument.
+	Use ok_for_index_p_1 instead of REGNO_OK_FOR_INDEX_P.
+	(record_address_regs): Use index_reg_class instead of INDEX_REG_CLASS.
+	Update calls to ok_for_index_p_nonstrict.
+	* regrename.c (scan_rtx_address): Use regno_ok_for_index_p instead of
+	REGNO_OK_FOR_INDEX_P and index_reg_class instead of INDEX_REG_CLASS.
+	(replace_oldest_value_addr): Likewise.
+	* reload.c (find_reloads_address): Use index_reg_class instead
+	of INDEX_REG_CLASS.  Do not push an index register reload if
+	index_reg_class returns NO_REGS.
+	(find_reloads_address_1): Use index_reg_class instead
+	of INDEX_REG_CLASS and regno_ok_for_index_p instead of
+	REGNO_OK_FOR_INDEX_P.
+	* doc/tm.texi (MODE_INDEX_REG_CLASS): Document new macro.
+	(REGNO_MODE_OK_FOR_INDEX_P): Likewise.
+
+2009-06-18  Catherine Moore  <clm@codesourcery.com>
+
+	Backport form mainline:
+
+	2009-04-02  Chao-ying Fu  <fu@mips.com>
+	    James Grosbach  <james.grosbach@microchip.com>
+
+	* config/mips/mips.c (mips_frame_info): Add acc_mask, num_acc,
+	num_cop0_regs, acc_save_offset, cop0_save_offset, acc_sp_offset,
+	cop0_sp_offset.
+	(machine_function): Add interrupt_handler_p, use_shadow_register_set_p,
+	keep_interrupts_masked_p, use_debug_exception_return_p.
+	(mips_attribute_table): Add interrupt, use_shadow_register_set,
+	keep_interrupts_masked, use_debug_exception_return.
+	(mips_interrupt_type_p, mips_use_shadow_register_set_p,
+	mips_keep_interrupts_masked_p, mips_use_debug_exception_return_p):
+	New functions.
+	(mips_function_ok_for_sibcall): Return false for interrupt handlers.
+	(mips_print_operand): Process COP0 registers to print $0 .. $31
+	correctly for GAS to process.
+	(mips_interrupt_extra_call_saved_reg_p): New function.
+	(mips_cfun_call_saved_reg_p): For interrupt handlers, we need to check
+	extra registers.
+	(mips_cfun_might_clobber_call_saved_reg_p): Likewise.
+	(mips_compute_frame_info): Add supports for interrupt context that
+	includes doubleword accumulators and COP0 registers.
+	(mips_for_each_saved_acc): New function.
+	(mips_for_each_saved_gpr_and_fpr): Change the function name from
+	mips_for_each_saved_reg.
+	(mips_save_reg): Save accumulators.
+	(mips_kernel_reg_p): A new for_each_rtx callback.
+	(mips_expand_prologue): Support interrupt handlers.
+	(mips_restore_reg): Restore accumulators.
+	(mips_expand_epilogue): Support interrupt handlers.
+	(mips_can_use_return_insn): Return false for interrupt handlers.
+	(mips_epilogue_uses): New function.
+	* config/mips/mips.md (UNSPEC_ERET, UNSPEC_DERET, UNSPEC_DI,
+	UNSPEC_EHB, UNSPEC_RDPGPR, UNSPEC_COP0): New UNSPEC.
+	(mips_eret, mips_deret, mips_di, mips_ehb, mips_rdpgpr,
+	cop0_move): New instructions.
+	* config/mips/mips-protos.h (mips_epilogue_uses): Declare.
+	* config/mips/mips.h (K0_REG_NUM, K1_REG_NUM, KERNEL_REG_P): New
+	defines.
+	(COP0_STATUS_REG_NUM, COP0_CAUSE_REG_NUM, COP0_EPC_REG_NUM):
+	New defines.
+	(CAUSE_IPL, SR_IPL, SR_EXL, SR_IE): New defines.
+	(MIPS_PROLOGUE_TEMP_REGNUM, MIPS_EPILOGUE_TEMP_REGNUM): For
+	interrupt handlers, we use K0 as the temporary register.
+	(EPILOGUE_USES): Change to a function call.
+	* config/mips/sde.h (MIPS_EPILOGUE_TEMP_REGNUM): For interrupt
+	handlers, we use K0 as the temporary register.
+
+	* doc/extend.texi (Function Attributes): Document interrupt,
+	use_shadow_register_set, keep_interrupts_masked,
+	use_debug_exception_return for MIPS attributes.
+
+2009-06-17  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/testsuite/
+	2009-06-10  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* gcc.target/arm/neon-modes-1.c: New test.
+
+2009-06-17  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #5768
+
+	gcc/
+	* config.gcc (i[34567]86-*-linux*): Use extra config files if
+	--enable-extra-sgxxlite-multilibs.
+	* config/i386/cs-linux-lite.h, config/i386/t-cs-linux-lite: New.
+
+2009-06-16  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from branches/ix86/gcc-4_4-branch:
+
+	gcc/
+	2009-05-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-05-21  H.J. Lu  <hongjiu.lu@intel.com>
+		    Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/cpuid.h (bit_MOVBE): New.
+
+	* config/i386/driver-i386.c (host_detect_local_cpu): Check movbe.
+
+	* config/i386/i386.c (OPTION_MASK_ISA_MOVBE_SET): New.
+	(OPTION_MASK_ISA_MOVBE_UNSET): Likewise.
+	(ix86_handle_option): Handle OPT_mmovbe.
+	(ix86_target_string): Add -mmovbe.
+	(pta_flags): Add PTA_MOVBE.
+	(processor_alias_table): Add PTA_MOVBE to "atom".
+	(override_options): Handle PTA_MOVBE.
+
+	* config/i386/i386.h (TARGET_MOVBE): New.
+
+	* config/i386/i386.md (bswapsi2): Check TARGET_MOVBE.
+	(*bswapsi_movbe): New.
+	(*bswapdi_movbe): Likewise.
+	(bswapdi2): Renamed to ...
+	(*bswapdi_1): This.
+	(bswapdi2): New expander.
+
+	* config/i386/i386.opt (mmovbe): New.
+
+	* doc/invoke.texi: Document -mmovbe.
+
+	2009-05-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-05-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/driver-i386.c (host_detect_local_cpu): Check
+	extended family and model for Intel processors.  Support Intel
+	Atom.
+
+	2009-04-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-04-20  Joey Ye  <joey.ye@intel.com>
+		    Xuepeng Guo <xuepeng.guo@intel.com>
+		    H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/atom.md: Add bypasses with ix86_dep_by_shift_count.
+
+	* config/i386/i386.c (LEA_SEARCH_THRESHOLD): New macro.
+	(IX86_LEA_PRIORITY): Likewise.
+	(distance_non_agu_define): New function.
+	(distance_agu_use): Likewise.
+	(ix86_lea_for_add_ok): Likewise.
+	(ix86_dep_by_shift_count): Likewise.
+
+	* config/i386/i386.md: Call ix86_lea_for_add_ok to decide we
+	should split for LEA.
+
+	* config/i386/i386-protos.h (ix86_lea_for_add_ok): Declare new
+	function.
+	(ix86_dep_by_shift_count): Likewise.
+
+	2009-04-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-04-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* doc/invoke.texi: Document Atom support.
+
+	2009-04-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386.md: Revert 2 accidental checkins.
+
+	2009-04-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-04-06  Joey Ye  <joey.ye@intel.com>
+		    Xuepeng Guo <xuepeng.guo@intel.com>
+		    H.J. Lu  <hongjiu.lu@intel.com>
+
+	Atom pipeline model, tuning and insn selection.
+	* config.gcc (atom): Add atom config options and target.
+
+	* config/i386/atom.md: New.
+
+	* config/i386/i386.c (atom_cost): New cost.
+	(m_ATOM): New macro flag.
+	(initial_ix86_tune_features): Set m_ATOM.
+	(x86_accumulate_outgoing_args): Likewise.
+	(x86_arch_always_fancy_math_387): Likewise.
+	(processor_target): Add Atom cost.
+	(cpu_names): Add Atom cpu name.
+	(override_options): Set Atom ISA.
+	(ix86_issue_rate): New case PROCESSOR_ATOM.
+	(ix86_adjust_cost): Likewise.
+
+	* config/i386/i386.h (TARGET_ATOM): New target macro.
+	(ix86_tune_indices): Add X86_TUNE_OPT_AGU.
+	(TARGET_OPT_AGU): New target option.
+	(target_cpu_default): Add TARGET_CPU_DEFAULT_atom.
+	(processor_type): Add PROCESSOR_ATOM.
+
+	* config/i386/i386.md (cpu): Add new value "atom".
+	(use_carry, movu): New attr.
+	(atom.md): Include atom.md.
+	(adddi3_carry_rex64): Set attr "use_carry".
+	(addqi3_carry): Likewise.
+	(addhi3_carry): Likewise.
+	(addsi3_carry): Likewise.
+	(*addsi3_carry_zext): Likewise.
+	(subdi3_carry_rex64): Likewise.
+	(subqi3_carry): Likewise.
+	(subhi3_carry): Likewise.
+	(subsi3_carry): Likewise.
+	(x86_movdicc_0_m1_rex64): Likewise.
+	(*x86_movdicc_0_m1_se): Likewise.
+	(x86_movsicc_0_m1): Likewise.
+	(*x86_movsicc_0_m1_se): Likewise.
+	(*adddi_1_rex64): Emit add insn as much as possible.
+	(*addsi_1): Likewise.
+	(return_internal): Set atom_unit.
+	(return_internal_long): Likewise.
+	(return_pop_internal): Likewise.
+	(*rcpsf2_sse): Set atom_sse_attr attr.
+	(*qrt<mode>2_sse): Likewise.
+
+	2009-04-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-04-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386.c (ix86_abi): Move initialization to ...
+	(override_options): Here.
+
+	2009-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386-protos.h (ix86_agi_dependent): New.
+
+	* config/i386/i386.c (ix86_agi_dependent): Rewrite.
+	(ix86_adjust_cost): Updated.
+
+	2009-03-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-03-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/39472
+	* config/i386/i386.c (ix86_abi): New.
+	(override_options): Handle -mabi=.
+	(ix86_function_arg_regno_p): Replace DEFAULT_ABI with
+	ix86_abi.
+	(ix86_call_abi_override): Likewise.
+	(init_cumulative_args): Likewise.
+	(function_arg_advance): Likewise.
+	(function_arg_64): Likewise.
+	(function_arg): Likewise.
+	(ix86_pass_by_reference): Likewise.
+	(ix86_function_value_regno_p): Likewise.
+	(ix86_build_builtin_va_list_abi): Likewise.
+	(setup_incoming_varargs_64): Likewise.
+	(is_va_list_char_pointer): Likewise.
+	(ix86_init_machine_status): Likewise.
+	(ix86_reg_parm_stack_space): Use enum calling_abi on
+	call_abi.
+	(ix86_function_type_abi): Return enum calling_abi.  Rewrite
+	for 64bit.  Replace DEFAULT_ABI with ix86_abi.
+	(ix86_function_abi): Make it static and return enum
+	calling_abi.
+	(ix86_cfun_abi): Return enum calling_abi.  Replace DEFAULT_ABI
+	with ix86_abi.
+	(ix86_fn_abi_va_list): Updated.
+
+	* config/i386/i386.h (ix86_abi): New.
+	(STACK_BOUNDARY): Replace DEFAULT_ABI with ix86_abi.
+	(CONDITIONAL_REGISTER_USAGE): Likewise.
+	(CUMULATIVE_ARGS): Change call_abi type to enum calling_abi.
+	(machine_function): Likewise.
+
+	* config/i386/i386.md (untyped_call): Replace DEFAULT_ABI
+	with ix86_abi.
+	* config/i386/cygming.h (TARGET_64BIT_MS_ABI): Likewise.
+	(STACK_BOUNDARY): Likewise.
+	* config/i386/mingw32.h (EXTRA_OS_CPP_BUILTINS): Likewise.
+
+	* config/i386/i386.opt (mabi=): New.
+
+	* config/i386/i386-protos.h (ix86_cfun_abi): Changed to
+	return enum calling_abi.
+	(ix86_function_type_abi): Likewise.
+	(ix86_function_abi): Removed.
+
+	2009-03-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-03-27  Vladimir Makarov  <vmakarov@redhat.com>
+
+	* genautomata.c: Add a new year to the copyright.  Add a new
+	reference.
+	(struct insn_reserv_decl): Add comments for member bypass_list.
+	(find_bypass): Remove.
+	(insert_bypass): New.
+	(process_decls): Use insert_bypass.
+	(output_internal_insn_latency_func): Output all bypasses with the
+	same input insn in one switch case.
+
+	* rtl.def (define_bypass): Describe bypass choice.
+	* doc/md.texi (define_bypass): Ditto.
+
+	gcc/testsuite/
+	2009-05-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-05-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* gcc.target/i386/movbe-1.c: New.
+	* gcc.target/i386/movbe-2.c: Likewise.
+
+	2009-03-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline:
+	2009-03-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/39472
+	* gcc.target/x86_64/abi/callabi/func-2a.c: New.
+	* gcc.target/x86_64/abi/callabi/func-2b.c: Likewise.
+	* gcc.target/x86_64/abi/callabi/func-indirect-2a.c: Likewise.
+	* gcc.target/x86_64/abi/callabi/func-indirect-2b.c: Likewise.
+	* gcc.target/x86_64/abi/callabi/vaarg-4a.c: Likewise.
+	* gcc.target/x86_64/abi/callabi/vaarg-4b.c: Likewise.
+	* gcc.target/x86_64/abi/callabi/vaarg-5a.c: Likewise.
+	* gcc.target/x86_64/abi/callabi/vaarg-5b.c: Likewise.
+
+2009-06-16  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-09-08  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gcc/
+	* config/arm/unwind-arm.c (__gnu_unwind_pr_common): Correct test
+	for barrier handlers.
+
+2009-06-16  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2006-12-15  Richard Sandiford  <richard@codesourcery.com>
+	gcc/testsuite/
+	* gcc.target/mips/octeon-useun.c: New test.
+
+2009-06-16  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-04-04  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.dg/pr34263.c: Add -fno-unroll-loops.
+
+2009-06-16  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-12-03  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.dg/vect/vect-shift-2.c, gcc.dg/vect/vect-shift-3.c: New.
+	* lib/target-supports.exp (check_effective_target_vect_shift_char): New
+	function.
+
+2009-06-16  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-04-04  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.md (insv): Do not share operands[0].
+
+2009-06-16  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/testsuite/
+	* gcc.target/sh/20080410-1.c: Remove obsolete -fira option.
+
+2009-06-16  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* config.gcc (sh*-*-*): Add sh/cs-sgxxlite-linux.opt when
+	--enable-extra-sgxxlite-multilibs.
+	* config/sh/cs-sgxxlite-linux.h: Define SUBTARGET_OVERRIDE_OPTIONS.
+	* config/sh/cs-sgxxlite-linux.opt: New file.
+
+2009-06-16  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Merge 2009-03-06  Mark Mitchell  <mark@codesourcery.com>
+	gcc/
+	* configure.ac (--with-specs): New option.
+	* configure: Regenerated.
+	* gcc.c (driver_self_specs): Include CONFIGURE_SPECS.
+	* Makefile.in (DRIVER_DEFINES): Add -DCONFIGURE_SPECS.
+
+	Merge 2009-04-04  Daniel Jacobowitz  <dan@codesourcery.com>
+	gcc/
+	* gcc.c (do_self_spec): Handle switches with arguments.
+
+	Merge 2008-07-25  Mark Mitchell  <mark@codesourcery.com>
+	Issue #3433
+	gcc/
+	* gcc.c (SWITCHES_NEED_SPACES): Define to "o".
+
+2009-06-15  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3.
+
+	Issue 3304
+	gcc/
+	* config/arm/arm.c (arm_print_operand): Deal with HIGH.
+	* config/arm/constraints.md (j): New constraint for movw operands.
+	(N): Remove thumb2 meaning.
+	* config/arm/arm.md (*arm_movw): Delete.
+	(*arm_movsi_insn): Use j constraint for movw instead of N constraint.
+	* config/arm/vfp.md (*arm_movsi_vfp, *thumb2_movsi_vfp): Likewise.
+	* config/arm/thumb2.md (*thumb2_movsi_insn): Likewise.
+
+2009-06-15  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2006-12-15  Richard Sandiford  <richard@codesourcery.com>
+	Adapted from a patch by Cavium Networks.
+	gcc/
+	* config/mips/mips.opt (mocteon-useun): New option.
+	* config/mips/mips.h: (ISA_HAS_UL_US): New macro.
+	(ASM_SPEC): Pass down -mocteon-useun and -mno-octeon-useun.
+	* config/mips/mips.c (mips_expand_ext_as_unaligned_load): Use
+	mov_ulw and mov_uld if ISA_HAS_UL_US.
+	(mips_expand_ins_as_unaligned_store): Likewise mov_usw and mov_usd.
+	* config/mips/mips.md: (UNSPEC_UNALIGNED_LOAD,
+	 UNSPEC_UNALIGNED_STORE): New constants.
+	(mov_<load>l, mov_<load>r, mov_<store>l, mov_<store>r): Require
+	ISA_HAS_UL_US.
+	(mov_u<load>, mov_u<store>): New patterns.
+
+2009-06-15  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/
+	* config/mips/mips.opt: Revert last patch.
+	* config/mips/mips-protos.h : Likewise.
+	* config/mips/mips.h: Likewise.
+	* config/mips/mips.md: Likewise.
+	* config/mips/mips.c: Likewise.
+
+2009-06-12  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2006-12-15  Richard Sandiford  <richard@codesourcery.com>
+	Adapted from a patch by Cavium Networks.
+	gcc/
+	* config/mips/mips.opt (mocteon-useun): New option.
+	* config/mips/mips-protos.h (mips_lower_sign_bit_p, mips_use_ext_p): Declare.
+	(mips_adjust_register_ext_operands): Likewise.
+	* config/mips/mips.h (ISA_HAS_SEB_SEH, ISA_HAS_INS_EXT): Include TARGET_OCTEON.
+	(ISA_HAS_UL_US): New macro.
+	(ASM_SPEC): Pass down -mocteon-useun and -mno-octeon-useun.
+	* config/mips/mips.c (mips_cpu_info_table): Add an octeon entry.
+	(mips_rtx_cost_data): Adjust octeon costs.
+	(mips_expand_ext_as_unaligned_load): Use mov_ulw and mov_uld if
+	ISA_HAS_UL_US.
+	(mips_expand_ins_as_unaligned_store): Likewise mov_usw and mov_usd.
+	(mips_lower_sign_bit_p, mips_use_ins_p, mips_use_ext_p): New functions.
+	(mips_adjust_register_ext_operands): Likewise.
+	* config/mips/mips.md: (UNSPEC_UNALIGNED_LOAD,
+	 UNSPEC_UNALIGNED_STORE): New constants.
+	(topbit): New mode attribute.
+	(any_extract ): New code macro.
+	(*<code>_trunc_exts<mode>): New pattern.
+	(zero_extendsidi2): Turn into a define_expand.  Rename old
+	define_insn_and_split to...
+	(*clear_upper32): Require !ISA_HAS_EXT_INS.
+	(*zero_extendsidi2_dext, *clear_upper32_dext): New patterns.
+	(*extv_truncdi<mode>): New pattern.
+	(extzv): Use mips_use_ext_p instead of mips_use_ins_ext_p.
+	Call mips_adjust_register_ext_operands.
+	(*extzv_truncdi<mode>, *extz_truncdi<mode>_exts): New patterns.
+	(insv):  Use mips_use_ins_p instead of mips_use_ins_ext_p.
+	Fix formatting.
+	(insv<mode>): Use mips_use_ins_p instead of mips_use_ins_ext_p.
+	(*insv<mode>di, *insv_<code>_<mode>di, *insvdi_clear_upper32)
+	(*cins): New patterns.
+	(mov_u<load>, mov_u<store>): New patterns.
+	(*truncsi_storeqi, *truncsi_storehi): Likewise.
+	* config/mips/predicates.md (mask_low_and_shift_operator): New
+	predicate.
+
+	2008-07-24  Joseph Myers  <joseph@codesourcery.com>
+	gcc/
+	* config/mips/mips.c (mips_expand_ins_as_unaligned_store): Restore
+	Octeon unaligned store support.
+
+	2008-07-29  Catherine Moore  <clm@codesourcery.com>
+		    Daniel Jacobowitz <dan@codesourcery.com>
+	gcc/
+	* config/mips/mips.h (ISA_HAS_BBIT):  Enable for TARGET_OCTEON.
+	* config/mips/mips.md (branch_with_likely): New attribute.
+	(branch_without_likely): New attribute.
+	(define_delay): Check for new branch_likely attributes.
+	(branch_bit<mode>): Set branch_without_likely to "yes".
+	(branch_bit_truncdi<mode>): Likewise.
+	(branch_bit<mode>_inverted): Likewise.
+	(branch_bit_truncdi<mode>_inverted): Likewise.
+
+2009-06-12  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-03-09  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* tree-ssa-loop-promote.c: New file.
+	* common.opt (fpromote-loop-indices): New option.
+	* timevar.def (TV_TREE_LOOP_PROMOTE): New timevar.
+	* Makefile.in (tree-ssa-loop-promote.o): New rule.
+	(OBJS-comon): Include it.
+	* tree-pass.h (pass_promote_short_indices): Declare.
+	* passes.c (init_optimization_passes): Add it.
+	* pointer-set.h (pointer_set_n_elements, pointer_set_clear,
+	pointer_map_n_elements, pointer_map_clear): Declare.
+	* pointer-set.c (pointer_set_n_elements, pointer_set_clear,
+	pointer_map_n_elements, pointer_map_clear): Define.
+
+	gcc/doc/
+	* invoke.texi (-fpromote-loop-indices): New entry.
+
+	gcc/testsuite/
+	* gcc.dg/promote-short-1.c: New file.
+	* gcc.dg/promote-short-2.c: New file.
+	* gcc.dg/promote-short-3.c: New file.
+	* gcc.dg/promote-short-4.c: New file.
+	* gcc.dg/promote-short-5.c: New file.
+	* gcc.dg/promote-short-6.c: New file.
+	* gcc.dg/promote-short-7.c: New file.
+	* gcc.dg/promote-short-8.c: New file.
+
+	2009-03-31  Daniel Jacobowitz  <dan@codesourcery.com>
+	gcc/
+	* common.opt (fpromote-loop-indices): Add Optimization keyword.
+
+	2009-04-08  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* tree-ssa-loop-promote.c (collection_promotion_candidates):
+	Delay allocation and initialization of new promote_info until we
+	know we have a candidate loop index.
+
+	2009-04-09  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* tree-ssa-loop-promote.c (rebuild_with_promotion_1): Load a memory
+	reference prior to promoting it.
+
+	gcc/testsuite/
+	* gcc.dg/promote-short-9.c: New test.
+
+	2009-04-09  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/testsuite/
+	* gcc.dg/promote-short-3.c: XFAIL test for x86, m68k, sh, and mips.
+
+	2009-04-13  Kazu Hirata  <kazu@codesourcery.com>
+	gcc/testsuite/
+	* gcc.dg/promote-short-3.c: XFAIL on fido.
+
+2009-06-11  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from SourceryG++ 4.3:
+	Merge from MIPS:
+	2007-11-29  Thiemo Seufer  <ths@mips.com>
+	gcc/
+	* config/mips/mips.c (override_options): Let -fpic imply
+	-mabicalls, forward port from SDE	.
+
+2009-06-11  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from upstream:
+
+	2009-06-10  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* tree.h (tree_base): Add packed_flag and user_align fields.
+	Decrease size of spare field.
+	(TYPE_USER_ALIGN): Use user_align from tree_base.
+	(DECL_USER_ALIGN): Likewise.
+	(TYPE_PACKED): Use packed_flag from tree_base.
+	(DECL_PACKED): Likewise.
+	(tree_type): Delete packed_flag and user_align fields.  Widen
+	precision field.  Widen mode field and shuffle fields to align
+	mode on an 8-bit boundary.
+	(tree_decl_common): Delete decl_flag_1 and user_align fields.
+	Renumber decl_flag_* fields.  Fix comments.  Widen
+	decl_common_unused field.
+	(DECL_HAS_VALUE_EXPR_P): Adjust for renumbering of decl_flag_*
+	fields.
+	(DECL_EXTERNAL): Likewise.
+	(DECL_BIT_FIELD): Likewise.
+	(DECL_NONADDRESSABLE_P): Likewise.
+	(TYPE_DECL_SUPRESS_DEBUG): Likewise.
+	* config/arm/arm-modes.def (XImode): Make it an INT_MODE.
+
+2009-06-11  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-01-14  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* tree-ssa-remove-local-statics.c (maybe_discover_new_declaration):
+	Avoid variables with aggregate and vector types.
+	(maybe_create_new_variable): Create the var_ann prior to marking
+	the symbol for renaming.
+
+	gcc/testsuite/
+	* gcc.dg/remove-local-statics-15.c: New test.
+	* gcc.dg/remove-local-statics-16.c: New test.
+
+	2008-07-21  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* tree-ssa-remove-local-statics.c
+	(find_static_nonvolatile_declarations): Don't check for potential
+	definitions if we're looking at a statement with a CALL_EXPR.
+	(compute_definedness_for_block): Reorganize logic.
+
+	gcc/testsuite/
+	* gcc.dg/remove-local-statics-13.c: New test.
+	* gcc.dg/remove-local-statics-14.c: New test.
+
+	2008-07-08  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* passes.c (init_optimization_passes): Move pass_remove_local_statics
+	later in the pass order.
+	* tree-ssa-remove-local-statics.c (rls_done): Conditionally free the
+	bitmaps and NULL out bb->aux.
+	(unstaticize_variable): Deal with GIMPLE_MODIFY_STMTs instead of
+	MODIFY_EXPRs.
+	(compute_definedness_for_block): Check for defines only if we haven't
+	found a CALL_EXPR.
+
+	2008-05-30  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* tree-ssa-remove-local-statics.c
+	(find_static_nonvolatile_declarations): Use SSA_OP_VDEF.
+	(unstaticize_variable): Likewise.
+	(dump_final_bitmaps): Remove.
+
+	2008-02-25  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* tree-ssa-remove-local-statics. (initialize_statement_dataflow):
+	Continue hash table traversal.
+	(compute_definedness_for_block): Delete useless return statement.
+	Adjust comment accordingly.
+
+	2007-03-05  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* tree-pass.h (pass_remove_local_statics): Declare.
+	* passes.c (init_optimization_passes): Add
+	pass_remove_local_statics to the optimization passes.
+	* Makefile.in (OBJS-common): Add tree-ssa-remove-local-statics.c.
+	(tree-ssa-remove-local-statics.o): New rule.
+	* tree-ssa-remove-local-statics.c: New file.
+	* c.opt (fremove-local-statics): New option.
+	* timevar.def (TV_RLS): New timevar.
+	* toplev.h (flag_remove_local_statics): Declare.
+	* cgraph.h (struct cgraph_node): Add 'ever_was_nested'.
+	* cgraph.c (cgraph_node): Set ever_was_nested in the node and
+	its parent when creating a new node.
+	gcc/doc/
+	* invoke.texi: Document -fremove-local-statics.
+	gcc/testsuite/
+	* gcc.dg/remove-local-statics-1.c: New file.
+	* gcc.dg/remove-local-statics-2.c: New file.
+	* gcc.dg/remove-local-statics-3.c: New file.
+	* gcc.dg/remove-local-statics-4.c: New file.
+	* gcc.dg/remove-local-statics-5.c: New file.
+	* gcc.dg/remove-local-statics-6.c: New file.
+	* gcc.dg/remove-local-statics-7.c: New file.
+	* gcc.dg/remove-local-statics-8.c: New file.
+	* gcc.dg/remove-local-statics-9.c: New file.
+	* gcc.dg/remove-local-statics-10.c: New file.
+	* gcc.dg/remove-local-statics-11.c: New file.
+	* gcc.dg/remove-local-statics-12.c: New file.
+
+2009-06-10  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	2008-11-23  Richard Sandiford  <rsandiford@googlemail.com>
+	* config/mips/mips.c (mips_legitimize_address): Handle
+	illegitimate CONST_INT addresses.
+
+2009-06-10  Catherine Moore  <clm@codesourcery.com>
+
+	gcc/
+	* config/mips/mips.c (mips_cp_restore_slot): Remove declaration
+	of intval and high.
+	(vr4130_swap_insns_p): Remove mis-applied patch.
+
+2009-06-10  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+	2008-03-25  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	    Julian Brown  <julian@codesourcery.com>
+	Merge from MIPS:
+	gcc/
+	* config/mips/mips-protos.h (dspalu_bypass_p): Add prototype.
+	* config/mips/mips.c (dspalu_bypass_table): New.
+	(dspalu_bypass_p): New.
+	* 24k.md (r24k_dsp_alu, r24k_dsp_mac, r24k_dsp_mac_sat)
+	(r24k_dsp_acc_ext, r24k_dsp_acc_mod): New insn reservations.
+	(r24k_int_mult, r24k_int_mthilo, r24k_dsp_mac, r24k_dsp_mac_sat)
+	(r24k_dsp_acc_ext, r24k_dsp_acc_mod, r24k_dsp_alu): New bypasses.
+	* config/mips/mips.md (dspmac, dspmacsat, accext, accmod, dspalu)
+	(dspalusat): Add insn types.
+	* config/mips/mips-dsp.md (add<DSPV:mode>3)
+	(mips_add<DSP:dspfmt1>_s_<DSP:dspfmt2>)
+	(sub<DSPV:mode>3, mips_sub<DSP:dspfmt1>_s_<DSP:dspfmt2>, mips_addsc)
+	(mips_addwc, mips_modsub, mips_raddu_w_qb, mips_absq_s_<DSPQ:dspfmt2>)
+	(mips_precrq_qb_ph, mips_precrq_ph_w, mips_precrq_rs_ph_w)
+	(mips_precrqu_s_qb_ph, mips_preceq_w_phl, mips_preceq_w_phr)
+	(mips_precequ_ph_qbl, mips_precequ_ph_qbr, mips_precequ_ph_qbla)
+	(mips_precequ_ph_qbra, mips_preceu_ph_qbl, mips_preceu_ph_qbr)
+	(mips_preceu_ph_qbla, mips_preceu_ph_qbra, mips_shll_<DSPV:dspfmt2>)
+	(mips_shll_s_<DSPQ:dspfmt2>, mips_shll_s_<DSPQ:dspfmt2>, mips_shrl_qb)
+	(mips_shra_ph, mips_shra_r_<DSPQ:dspfmt2>, mips_bitrev, mips_insv)
+	(mips_repl_qb, mips_repl_ph, mips_cmp<DSPV:dspfmt1_1>_eq_<DSPV:dspfmt2>)
+	(mips_cmp<DSPV:dspfmt1_1>_lt_<DSPV:dspfmt2>)
+	(mips_cmp<DSPV:dspfmt1_1>_le_<DSPV:dspfmt2>, mips_cmpgu_eq_qb)
+	(mips_cmpgu_lt_qb, mips_cmpgu_le_qb, mips_pick_<DSPV:dspfmt2>)
+	(mips_packrl_ph, mips_wrdsp, mips_rddsp): Change type to dspalu.
+	(mips_dpau_h_qbl, mips_dpau_h_qbr, mips_dpsu_h_qbl, mips_dpsu_h_qbr)
+	(mips_dpaq_s_w_ph, mips_dpsq_s_w_ph, mips_mulsaq_s_w_ph)
+	(mips_maq_s_w_phl, mips_maq_s_w_phr, mips_maq_sa_w_phr: Set type to
+	dspmac.
+	(mips_dpaq_sa_l_w, mips_dpsq_sa_l_w, mips_maq_sa_w_phl): Set type to
+	dspmacsat.
+	(mips_extr_w, mips_extr_r_w, mips_extr_rs_w, mips_extp, mips_extpdp):
+	Set type to accext.
+	(mips_shilo, mips_mthlip): Set type to accmod.
+	* config/mips/mips-dspr2.md (mips_absq_s_qb, mips_addu_s_ph)
+	(mips_adduh_r_qb): Set type to dspalusat.
+	(mips_addu_ph, mips_adduh_qb, mips_append, mips_balign)
+	(mips_cmpgdu_eq_qb, mips_cmpgdu_lt_qb, mips_cmpgdu_le_qb)
+	(mips_precr_qb_ph, mips_precr_sra_ph_w, mips_precr_sra_r_ph_w)
+	(mips_prepend, mips_shra_qb, mips_shra_r_qb, mips_shrl_ph)
+	(mips_subu_ph, mips_subuh_qb, mips_subuh_r_qb, mips_addqh_ph)
+	(mips_addqh_r_ph, mips_addqh_w, mips_addqh_r_w, mips_subqh_ph)
+	(mips_subqh_r_ph, mips_subqh_w, mips_subqh_r_w): Set type to dspalu.
+	(mips_dpa_w_ph, mips_dps_w_ph, mips_mulsa_w_ph, mips_dpax_w_ph)
+	(mips_dpsx_w_ph, mips_dpaqx_s_w_ph, mips_dpsqx_s_w_ph): Set type to
+	dspmac.
+	(mips_subu_s_ph): Set type to dspalusat.
+	(mips_dpaqx_sa_w_ph, mips_dpsqx_sa_w_ph): Set type to dspmacsat.
+
+	2008-02-15  Julian Brown  <julian@codesourcery.com>
+	Merge from MIPS:
+	2007-11-06  David Ung  <davidu@mips.com>
+	gcc/
+	* config/mips/mips.h (AC1HI_REGNUM, AC1LO_REGNUM, AC2HI_REGNUM)
+	(AC2LO_REGNUM, AC3HI_REGNUM, AC3LO_REGNUM): Define constants.
+
+	Merge from Sourcery G++ 4.2:
+	2008-03-25  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	    Julian Brown  <julian@codesourcery.com>
+	* 74k.md: (r74k_dsp_alu, r74k_dsp_alu_sat, r74k_dsp_mac, r74k_dsp_mac_sat)
+	(r74k_dsp_acc_ext, r74k_dsp_acc_mod): New insn reservations.
+	(r74k_dsp_mac, r74k_dsp_mac_sat, r74k_int_mult, r74k_int_mul3)
+	(r74k_dsp_mac, r74k_dsp_mac_sat): New bypasses.
+
+2009-06-10  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-02-12  Julian Brown  <julian@codesourcery.com>
+	Merge from MIPS:
+	2007-12-21  David Ung  <davidu@mips.com>
+	gcc/
+	* config/mips/mips.h (TARGET_MIPS_SDE): Define macro as 0.
+	* config/mips/mips.md (abs<mode>2): Enable abs.[sd] patterns if
+	TARGET_MIPS_SDE && TARGET_HARD_FLOAT.
+
+	2008-07-17  Catherine Moore  <clm@codesourcery.com>
+	gcc/
+	* config/mips/sde.h (TARGET_MIPS_SDE): Define to 1.
+
+2009-06-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-06-02  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.md (absv2sf2, negv2sf2, addv2sf3, subv2sf3,
+	mulv2sf3, divv2sf3): New expanders.
+	* config/rs6000/spe.md (spe_evabs, spe_evand, spe_evaddw,
+	spe_evdivws): Rename to use standard GCC names.
+	* config/rs6000/paired.md (negv2sf, absv2sf2, addv2sf3, subv2sf3,
+	mulv2sf3, divv2sf3): Rename to avoid conflict with the new expanders.
+
+	2007-09-19  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (bdesc_2arg, bdesc_1arg): Use new CODE_FOR_
+	names for renamed patterns.
+
+2009-06-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-04-14  Daniel Jacobowitz  <dan@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_dwarf_register_span): Fix debug
+	output for other floating point modes.
+
+2009-06-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-11-24  Nathan Froyd  <froydnj@codesourcery.com>
+  	gcc/
+	* config/rs6000/rs6000.c (rs6000_savres_strategy): Always use
+	inline saves and restores when compiling position-independent code.
+
+	2008-11-17  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_emit_epilogue): Adjust
+	computation of restore_lr.  Duplicate restoration of LR and
+	execute the appropriate one depending on whether GPRs are being
+	restored inline.
+
+	2008-11-17  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_savres_routine_sym): Fix
+	computation for cache selector.  Mark the generated symbol as a
+	function.
+	(rs6000_emit_prologue): Correct condition.
+	* config/rs6000/rs6000.md (*save_gpregs_<mode>): Use explicit
+	match for register 11.
+	(*save_fpregs_<mode>): Likewise.
+	(*restore_gpregs_<mode>): Likewise.
+	(*return_and_restore_gpregs_<mode>): Likewise.
+	(*return_and_restore_fpregs_<mode>): Likewise.
+	* config/rs6000/spe.md (*save_gpregs_spe): Use explicit match for
+	register 11.
+	(*restore_gpregs_spe): Likewise.
+	(*return_and_restore_gpregs_spe): Likewise.
+
+	2008-10-24  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (no_global_regs_above): Fix precedence
+	problem.
+
+2009-06-09  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-07-02  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/eabi.h (NAME__MAIN, INVOKE__main): Remove.
+	* config/rs6000/t-ppccomm (LIB2FUNS_STATIC_EXTRA): Remove eabi.S.
+	(eabi.S): Remove rule.
+
+	2008-10-13  Andrew Stubbs  <ams@codesourcery.com>
+	gcc/
+	* doc/invoke.texi (PowerPC Options): -meabi option no longer places
+	__eabi function in main.
+
+2009-06-09  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-02-11  David Ung  <davidu@mips.com>
+	gcc/
+	* config/mips/mips.c (mips_output_division): When
+	GENERATE_DIVIDE_TRAPS, generate the trap instrutions
+	against zero before the actual divide.  This is friendlier
+	to out-of-order cpus like the 74k.
+
+2009-06-09  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-03-25  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	            Julian Brown  <julian@codesourcery.com>
+	Merge from MIPS:
+	gcc/
+	* config/mips/mips.c (mips_mult_madd_chain_bypass_p): New.
+	* config/mips/mips-protos.h (mips_mult_madd_chain_bypass_p): Add
+	prototype.
+	* config/mips/74k.md: Add bypasses for r74k_int_mult, r74_int_madd,
+	r74k_int_mul3.
+
+2009-06-09  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Forward port 2009-01-27  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue #4428
+	gcc/
+	* config/mips/mips.md (jump): Deal with $gp restoration in delay
+	slot for o32 and o64 ABIs.
+
+	gcc/testsuite/
+	* gcc.target/mips/branch-2.c: New.
+
+2009-06-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+
+	gcc/
+	2009-06-05  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* config/rs6000/eabi.asm (__eabi_convert): Don't define if
+	_RELOCATABLE.
+	(__eabi_uconvert): Likewise.
+
+2009-06-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2008-08-25  Nathan Froyd  <froydnj@codesourcery.com>
+	gcc/
+	* config/rs6000/sysv4.h (LIB_SIM_SPEC): Use LIB_DEFAULT_SPEC.
+	(STARTFILE_SIM_SPEC): Remove sim-crt0.o%s.
+	(ENDFILE_SIM_SPEC): Add -Tsim-hosted.ld.
+	(LINK_OS_SIM_SPEC): Define to empty.
+
+2009-06-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2008-02-12  Nathan Sidwell  <nathan@codesourcery.com>
+		    Daniel Jacobowitz  <dan@codesourcery.com>
+	gcc/
+	* config/rs6000/eabi-ci.asm (__init): Add _init func start.
+	(__fini): Also declare _fini for newlib.
+
+2009-06-08  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-08-16  Daniel Jacobowitz  <dan@codesourcery.com>
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_conditional_register_usage): Mark
+	call-saved AltiVec registers call-used if ! TARGET_ALTIVEC_ABI.
+	* config/rs6000/rs6000.h (CALL_USED_REGISTERS): Mark the first 20
+	AltiVec registers call-used.
+	(CALL_REALLY_USED_REGISTERS): Likewise.
+
+	gcc/testsuite/
+	* gcc.target/powerpc/altivec-consts.c: Remove -mabi=altivec.
+	* gcc.target/powerpc/altivec-varargs-1.c: Likewise.
+	* gcc.dg/vmx/vmx.exp: Likewise.
+
+2009-06-03  Mark Mitchell  <mark@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2009-02-10  Mark Mitchell  <mark@codesourcery.com>
+	libjava/classpath/
+	* m4/acinclude.m4 (CLASSPATH_TOOLEXECLIBDIR): Match libjava.
+	* configure.ac (--enable-version-specific-runtime-libs): Support.
+	* Makefile.in, */Makefile.in: Regenerated.
+	libjava/
+	* Makefile.am (pkgconfigdir): Use toolexeclibdir, not $(libdir).
+	* configure.ac (dbexecdir): Likewise.
+	* configure: Regenerated.
+
+2009-06-03  Joseph Myers  <joseph@codesourcery.com>
+
+	fixincludes/
+	* inclhack.def (glibc_string2_memset): New fix.
+	* fixincl.x: Regenerate.
+	* tests/base/bits/string2.h: Update.
+
+2009-06-03  Mark Mitchell  <mark@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2009-02-10  Mark Mitchell  <mark@codesourcery.com>
+	libjava/
+	* Makefile.am (jardir): Set to a target-specific location.
+	gcc/java/
+	* Make-lang.in: Adjust to match.
+
+	Backport from mainline:
+
+	2009-06-02  Mark Mitchell  <mark@codesourcery.com>
+	* decl.c (maybe_deduce_size_from_array_init): Use relayout_decl.
+	2009-06-02  Mark Mitchell  <mark@codesourcery.com>
+	* g++.dg/init/ref15.C: Require unwrapped targets.
+
+2009-06-03  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport from mainline:
+	gcc/
+	2009-04-14  Kazu Hirata  <kazu@codesourcery.com>
+	* config/arm/arm.c (arm_rtx_costs_1): Treat a minus with a shift
+	the same as a minus without a shift.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2008-01-23  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (arm_final_prescan_insn): Use
+	TARGET_NO_SINGLE_COND_EXEC.
+	* config/arm/arm.h (TARGET_NO_SINGLE_COND_EXEC): Define.
+	* config/arm/arm.md: Add TARGET_NO_SINGLE_COND_EXEC conditions.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-03-12  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (arm_final_prescan_insn):  Skip this processing
+	if TARGET_NO_COND_EXEC is true.
+	* config/arm/arm.h (TARGET_NO_COND_EXEC):  Define.
+	* config/arm/arm.md (smaxsi3, *arm_smax_insn):  Disable if
+	TARGET_NO_COND_EXEC is set.
+	(sminsi3, *arm_smin_insn): Likewise.
+	(umaxsi3, *arm_umaxsi3): Likewise.
+	(uminsi3, *arm_uminsi3): Likewise.
+	(*store_minmaxsi): Likewise.
+	(seq, sne, sgt, sle, sge, slt): Likewise.
+	(sgtu, sleu, sgeu, sltu): Likewise.
+	(sunordered, sordered): Likewise.
+	(sungt, sunge, sunlt, sunle): Likewise.
+	(movsicc, movsfcc, movdfcc): Likewise.
+	(*cond_return, *cond_return_inverted): Likewise.
+	(*compare_scc): Likewise.
+	(*cond_arith): Likewise.
+	(movcond): Likewise.
+	(anonymous define_split patterns): Likewise.
+	(define_cond_exec): Likewise.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	gcc/
+	* config/arm/arm.md (movsi): Don't split symbol refs here.
+	(define_split): New.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	gcc/
+	* config/arm/arm.c (arm_override_options): Override alignments if
+	tuning for Cortex-A8.
+	(create_fix_barrier, arm_reorg): If aligning to jumps or loops,
+	make labels have a size.
+	* config/arm/arm.md (VUNSPEC_ALIGN16, VUNSPEC_ALIGN32): New constants.
+	(align_16, align_32): New patterns.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	gcc/
+	* config/arm/vfp.md (*arm_movsi_vfp, *thumb2_movsi_vfp)
+	(*arm_movdi_vfp, *thumb2_movdi_vfp, *movsf_vfp, *thumb2_movsf_vfp)
+	(*movdf_vfp, *thumb2_movdf_vfp, *movsfcc_vfp, *thumb2_movsfcc_vfp)
+	(*movdfcc_vfp, *thumb2_movdfcc_vfp): Add neon_type.
+	* config/arm/arm.md (neon_type): Update comment.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-07-05  Mark Shinwell  <shinwell@codesourcery.com>
+
+	gcc/
+	* config/arm/thumb2.md (thumb2_movsi_insn): Split ldr and
+	str alternatives according to use of high and low regs.
+	* config/arm/vfp.md (thumb2_movsi_vfp): Likewise.
+	* config/arm/arm.h (CONDITIONAL_REGISTER_USAGE): Use high
+	regs when optimizing for size on Thumb-2.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/testsuite/
+	* gcc.target/arm/vfp-ldmdbd.c, gcc.target/arm/vfp-ldmdbs.c,
+	gcc.target/arm/vfp-ldmiad.c, gcc.target/arm/vfp-ldmias.c,
+	gcc.target/arm/vfp-stmdbd.c, gcc.target/arm/vfp-stmdbs.c,
+	gcc.target/arm/vfp-stmiad.c, gcc.target/arm/vfp-stmias.c: New.
+	* g++.dg/other/armv7m-1.C: New.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-08-12  Mark Shinwell  <shinwell@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.h (CLASS_LIKELY_SPILLED_P): Check against
+	LO_REGS only for Thumb-1.
+	(MODE_BASE_REG_CLASS): Restrict base registers to low
+	registers for Thumb-2.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2008-01-09  Julian Brown  <julian@codesourcery.com>
+
+	gcc/
+	* config/arm/neon.md (UNSPEC_MISALIGNED_ACCESS): New constant.
+	(movmisalign<mode>): Define for D and Q width registers.
+
+	gcc/testsuite/
+	* lib/target-supports.exp
+	(check_effective_target_arm_vect_no_misalign): New function.
+	(check_effective_target_vect_no_align): Use above to determine
+	whether misaligned accesses are expected for ARM.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-0x-xx  Vladimir Prus  <vladimir@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (arm_override_options): Warn if mlow-irq-latency is
+	specified in thumb mode.
+	(load_multiple_sequence): Return 0 if low irq latency is requested.
+	(store_multiple_sequence): Likewise.
+	(arm_gen_load_multiple): Load registers one-by-one if low irq latency
+	is requested.
+	(arm_gen_store_multiple): Likewise.
+	(vfp_output_fldmd): When low_irq_latency is non zero, pop each
+	register separately.
+	(vfp_emit_fstmd): When low_irq_latency is non zero, save each register
+	separately.
+	(arm_get_vfp_saved_size): Adjust saved register size calculation for
+	the above changes.
+	(print_pop_reg_by_ldr): New.
+	(arm_output_epilogue): Use print_pop_reg_by_ldr when low irq latency
+	is requested.
+	(emit_multi_reg_push): Push registers separately if low irq latency
+	is requested.
+	* config/arm/arm.h (TARGET_CPU_CPP_BUILTINS): Set __low_irq_latency__.
+	(low_irq_latency): Define.
+	* config/arm/lib1funcs.asm (do_pop, do_push): Define as variadic
+	macros. When __low_irq_latency__ is defined, push and pop registers
+	individually.
+	(div0): Use correct punctuation.
+	* config/arm/ieee754-df.S: Adjust syntax of using do_push.
+	* config/arm/ieee754-sf.S: Likewise.
+	* config/arm/bpabi.S: Likewise.
+	* config/arm/arm.opt (mlow-irq-latency): New option.
+	* config/arm/predicates.md (load_multiple_operation): Return false is
+	low irq latency is requested.
+	(store_multiple_operation): Likewise.
+	* config/arm/arm.md (movmemqi): Don't use it if low irq latency is
+	requested.
+	* doc/invoke.texi (-mlow-irq-latency): Add documentation.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-03-20  Mark Shinwell  <shinwell@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.h (arm_arch_marvell_f): Delete.
+	* config/arm/arm.c (arm_override_options): Remove uses of
+	TARGET_MARVELL_F.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-02-02  Mark Shinwell  <shinwell@codesourcery.com>
+
+	gcc/
+	* config/arm/thumb2.md: Include hwdiv.md and move instruction patterns
+	for sdiv and udiv to that file.
+	* config/arm/arm.c (all_architectures): Add marvell-f entry.
+	(ARM_ARCH_NAME_SIZE): Define.
+	(arm_arch_name): Allocate ARM_ARCH_NAME_SIZE bytes of space.
+	(arm_override_options): Be more careful writing to arm_arch_name.
+	Take setting of -mmarvell-div and TARGET_THUMB2 into account when
+	setting arm_arch_hwdiv.  Cause error if -mmarvell-div is used when
+	not targeting a Marvell core.
+	* config/arm/arm.h (arm_arch_marvell_f): New.
+	* config/arm/hwdiv.md: New.
+	* config/arm/t-arm (MD_INCLUDES): Add hwdiv.md.
+	* config.gcc: Recognize marvell-f as a supported ARM architecture.
+	* doc/invoke.texi (ARM Options): Document -mcpu=marvell-f and
+	-mmarvell-div.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-01-10  Mark Shinwell  <shinwell@codesourcery.com>
+
+	gcc/
+	* config/arm/marvell-f.md: Fix FSF address and comment capitalization.
+	* config/arm/marvell-f-vfp.md: New.
+	* config/arm/arm-cores.def: Add FL_VFPV2 for marvell-f.
+	* config/arm/arm.md: Include marvell-f-vfp.md.
+	(generic_vfp): Don't set attribute to "yes" for marvell_f tuning.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-03-22  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.h (TARGET_CPU_CPP_BUILTINS): Add code to define
+	__ARM_TUNE_MARVELL_F__.
+	* config/arm/lib1funcs.asm (ARM_DIV_BODY):  Conditionalize for
+	__ARM_TUNE_MARVELL_F__.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-03-18  Mark Shinwell  <shinwell@codesourcery.com>
+
+	gcc/
+	* config/arm/vfp.md: When targeting a Marvell core, only
+	enable patterns involving multiply-accumulate type
+	instructions when optimizing for size.
+
+2009-05-29  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-01-03  Mark Shinwell  <shinwell@codesourcery.com>
+	2007-09-19  Paul Brook  <paul@codesourcery.com>
+
+	NOT ASSIGNED TO FSF
+	Port from Marvell compiler:
+	gcc/
+	* config/arm/arm.c (arm_issue_rate): Add Marvell-F support.
+	(arm_multipass_dfa_lookahead): New.
+	(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD): Define.
+	(FL_MARVELL_F, FL_COMPAT): New.
+	(arm_tune_marvell_f): New.
+	(arm_override_options): Set arm_tune_marvell_f as appropriate. Mask out
+	FL_COMPAT when checking cpu vs. arch.
+	* config/arm/arm.h (arm_tune_marvell_f): Declare.
+	* config/arm/arm-cores.def: Add marvell-f entry.
+	* config/arm/arm-tune.md: Regenerate.
+	* config/arm/t-arm (MD_INCLUDES): Add marvell-f.md.
+	* config/arm/arm.md: Don't use generic scheduler for marvell-f.
+	Include marvell-f.md.  Extend "insn" attribute with mov/mvn/
+	and/orr/eor cases and annotate instruction patterns accordingly.
+	* config/arm/vfp.md: Annotate likewise.
+	* config/arm/marvell-f.md: New.
+
+2009-05-28  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2008-02-18  Julian Brown  <julian@codesourcery.com>
+		    Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config/arm/bpabi.S (test_div_by_zero): New macro.
+	(aeabi_ldivmod): Use above macro to tailcall long long div-by-zero
+	handler.
+	(aeabi_uldivmod): Likewise.
+	* config/arm/bpabi-v6m.S (test_div_by_zero): New macro.
+	(aeabi_ldivmod, aeabi_uldivmod): Use above macro.
+	* config/arm/lib1funcs.asm (ARM_LDIV0): Tailcall int div-by-zero
+	handler. Add signed/unsigned argument, pass correct value to that
+	handler.
+	(THUMB_LDIV0): Same, for Thumb.
+	(DIV_FUNC_END): Add signed argument.
+	(WEAK): New macro.
+	(__udivsi3, __umodsi3): Add unsigned argument to DIV_FUNC_END.
+	(__divsi3, modsi3): Add signed argument to DIV_FUNC_END.
+	(__aeabi_uidivmod, __aeabi_idivmod): Check division by zero.
+	(__div0): Rename to __aeabi_idiv0, __aeabi_ldiv0 for EABI, and declare
+	those names weak.
+	* config/arm/t-bpabi (LIB1ASMFUNCS): Add _aeabi_idiv0, _aeabi_ldiv0.
+
+2009-05-28  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-06-06  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.h (VALID_IWMMXT_REG_MODE): Allow SImode.
+	(ARM_LEGITIMIZE_RELOAD_ADDRESS): Reduce range allowed for SImode
+	offsets with iWMMXt.
+	* config/arm/arm.c (arm_hard_regno_mode_ok): Update for change to
+	VALID_IWMMXT_REG_MODE.
+
+2009-05-28  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	gcc/
+	* config/arm/arm.h (ASM_OUTPUT_REG_PUSH): Handle STATIC_CHAIN_REGNUM
+	specially for Thumb-1.
+	(ASM_OUTPUT_REG_POP): Likewise.
+
+2009-05-28  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	Issue #5167
+
+	libiberty/
+	* pex-win32.c (pex_win32_pipe): Add _O_NOINHERIT.
+	(pex_win32_exec_child): Create inheritable duplicate descriptors to
+	pass to child process, and close originals (if non-stdin/stdout). Close
+	duplicates when child has spawned.
+
+2009-05-28  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-07-05  Mark Shinwell  <shinwell@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.h (BRANCH_COST): Set to 1 when optimizing for size
+	on Thumb-2.
+
+2009-05-28  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-09-19  Vladimir Prus  <vladimir@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (arm_optimization_options): Disable
+	-fmove-loop-invariants. Use very restrictive inlining heuristics.
+
+	gcc/testsuite/
+	* gcc.c-torture/execute/bcp-1.x: New.  Don't run bcp-1.c test on arm,
+	with -Os.
+	* gcc.c-torture/execute/990208-1.x: New.  Likewise.
+
+2009-05-28  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	libgcc/
+	* config.host (arm*-*-linux*, arm*-*-uclinux*, arm*-*-eabi*)
+	(arm*-*-symbianelf): Add arm/t-divmod-ef to tmake_file.
+	* Makefile.in (LIB2_DIVMOD_EXCEPTION_FLAGS): Set to previous
+	default if not set by a target-specific Makefile fragment.
+	(lib2-divmod-o, lib2-divmod-s-o): Use above.
+	* config/arm/t-divmod-ef: New.
+
+2009-05-28  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-04-17  Paul Brook  <paul@codesourcery.com>
+
+	gcc/
+	* config/arm/arm.c (TARGET_DWARF_REGISTER_SPAN): Define.
+	(arm_dwarf_register_span): New function.
+	(arm_dbx_register_number): Add VFPv3 dwarf numbering.
+
+2009-05-28  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	Issue #4515
+
+	gcc/
+	* config/arm/ieee754-df.S (cmpdf2): Avoid writing below SP.
+	* config/arm/ieee754-sf.S (cmpsf2): Likewise.
+
+2009-05-28  Julian Brown  <julian@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	gcc/
+	* config/arm/arm.c (arm_hard_regno_mode_ok): Allow 4-byte quantities
+	in core registers. Update comment.
+
+2009-05-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Issue #5266
+
+	Backport:
+	gcc/
+	2009-05-28  Joseph Myers  <joseph@codesourcery.com>
+	* config/arm/lib1funcs.asm (__clear_cache): Define if
+	L_clear_cache.
+	* config/arm/linux-eabi.h (CLEAR_INSN_CACHE): Define to give an
+	error if used.
+	* config/arm/t-linux-eabi (LIB1ASMFUNCS): Add _clear_cache.
+
+2009-05-27  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-03-05  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure.in (*-*-vxworks*): Remove target-libstdc++-v3 from
+	noconfigdirs.
+	* configure: Regenerated.
+
+2009-05-27  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-03-12  Richard Sandiford  <richard@codesourcery.com>
+
+	gcc/
+	* config/vx-common.h (TARGET_FLEXLM): Define.
+
+2009-05-27  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+ 	2007-08-26  Mark Mitchell  <mark@codesourcery.com>
+
+	gcc/testsuite/
+	* lib/prune.exp (prune_warnings): Extend the default
+	implementation to prune linker warnings about libm on Solaris.
+	libstdc++-v3/
+	* testsuite/lib/prune.exp (prune_g++_output): Prune linker
+	warnings about libm on Solaris.
+
+2009-05-27  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Merged from Sourcery G++ 4.3:
+
+	2007-08-26  Mark Mitchell  <mark@codesourcery.com>
+
+	fixincludes/
+	* inclhack.def (solaris_mutex_init_2): Remove precise machine
+	checks; look at <sys/types.h> to determine whether fix is
+	required.
+	(solaris_rwlock_init_1): Likewise.
+	(solaris_once_init_2): Likewise.
+	* tests/base/sys/types.h: Add output generated by
+	solaris_mutex_init_2.
+	* fixincl.x: Regenerated.
+
+2009-05-27  Catherine Moore  <clm@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	2008-11-23  Richard Sandiford  <rsandiford@googlemail.com>
+	* config/mips/mips.c (mips_legitimize_address): Handle
+	illegitimate CONST_INT addresses.
+
+2009-05-26  Sandra Loosemore  <sandra@codesourcery.com>
+	    Mark Shinwell  <shinwell@codesourcery.com>
+	    Joseph Myers  <joseph@codesourcery.com>
+
+	Revised patch merged from Sourcery G++ 4.3.
+
+	gcc/
+	* doc/invoke.texi (-falign-arrays): Document.
+	* function.h (alignment_for_aligned_arrays): Declare.
+	* function.c (get_stack_local_alignment): Use it.
+	(alignment_for_aligned_arrays): Define.
+	* cfgexpand.c (get_decl_align_unit): Use it here, too.
+	* common.opt (-falign-arrays): New.
+	* varasm.c (assemble_variable): Use alignment_for_aligned_arrays,
+	and use it irrespective of whether DATA_ALIGNMENT is defined.
+
+2009-05-26  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Forward port 2007-07-05  Richard Sandiford  <richard@codesourcery.com>
+
+	gcc/
+	* config/arm/neon-gen.ml: Include vxWorks.h rather than stdint.h
+	for VxWorks kernels.
+	* config/arm/arm_neon.h: Regenerate.
+
+2009-05-23  Mark Mitchell  <mark@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-05-23  Mark Mitchell  <mark@codesourcery.com>
+	* final.c (shorten_branches): Do not align labels for jump tables.
+	(final_scan_insn): Use JUMP_TABLE_DATA_P.
+	2009-05-23  Mark Mitchell  <mark@codesourcery.com>
+		    Maxim Kuvyrkov  <maxim@codesourcery.com>
+	* gcc.dg/falign-labels-1.c: New test.
+
+2009-05-22  Mark Mitchell  <mark@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-05-22  Mark Mitchell  <mark@codesourcery.com>
+	* config/arm/thumb2.md: Add 16-bit multiply instructions.
+	2009-05-22  Mark Mitchell  <mark@codesourcery.com>
+	* lib/target-supports.exp (check_effective_target_arm_thumb2_ok):
+	New function.
+	* gcc.target/arm/thumb2-mul-space.c: New file.
+	* gcc.target/arm/thumb2-mul-space-2.c: New file.
+	* gcc.target/arm/thumb2-mul-space-3.c: New file.
+	* gcc.target/arm/thumb2-mul-speed.c: New file.
+
+2009-05-22  Julian Brown  <julian@codesourcery.com>
+
+	gcc/
+	* gcse.c (hash_scan_set): Don't make copies of instructions the
+	target deems uncopyable.
+
+2009-05-22  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* release-notes-csl.xml: Remove notes erroneously ported from
+	4.3.  They will be picked up during the document build.
+
+	Forward port 2008-09-11  Mark Mitchell  <mark@codesourcery.com>
+
+	Issue #3606
+	* release-notes-csl.xml: Document dllexport fix.
+
+	gcc/
+	* tree.c (handle_dll_attribute): Mark dllexport'd inlines as
+	non-external.
+
+	gcc/cp
+	* decl2.c (decl_needed_p): Consider dllexport'd functions needed.
+	* semantics.c (expand_or_defer_fn): Similarly.
+
+	gcc/testsuite/
+	* gcc.dg/dll-6.c: New test.
+	* gcc.dg/dll-6a.c: Likewise.
+	* gcc.dg/dll-7.c: Likewise.
+	* gcc.dg/dll-7a.c: Likewise.
+	* g++.dg/ext/dllexport2.C: Likewise.
+	* g++.dg/ext/dllexport2a.cc: Likewise.
+
+2009-05-21  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #4289
+	Backport from mainline:
+
+	2009-03-27  Sandra Loosemore  <sandra@codesourcery.com>
+
+	fixincludes/
+	* server.c (run_shell): Quote directory name passed to cd.
+
+2009-05-21  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-04-04  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #5104
+	PR tree-optimization/39604
+
+	gcc/testsuite
+	* g++.dg/tree-ssa/sink-1.C: New.
+
+	gcc/
+	* tree_ssa-sink.c (sink_code_in_bb): Do not sink statements out
+	of a lexical block containing variable definitions.
+
+2009-05-21  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Issue #5174
+	Backport from mainline:
+
+	2009-04-09  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* doc/invoke.texi (Optimize Options): Add cross-reference to
+	-Q --help=optimizers examples.
+
+2009-05-21  Mark Mitchell  <mark@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-05-21  Mark Mitchell  <mark@codesourcery.com>
+	* config/arm/neon.md (*mul<mode>3add<mode>_neon): New pattern.
+	(*mul<mode>3neg<mode>add<mode>_neon): Likewise.
+	2009-05-21  Mark Mitchell  <mark@codesourcery.com>
+	* gcc.dg/target/arm/neon-vmla-1.c: New.
+	* gcc.dg/target/arm/neon-vmls-1.c: Likewise.
+
+2009-05-21  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* cp/decl.c (grokdeclarator): Fix merge error.
+
+2009-05-19  Catherine Moore  <clm@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-04-15  Catherine Moore  <clm@codesourcery.com>
+	* debug.h (set_name):  Declare.
+	* dwarf2out.c (dwarf2out_set_name): Declare.
+	(dwarf2_debug_hooks): Add set_name.
+	(find_AT_string): New.
+	(add_AT_string): Call find_AT_string.
+	(dwarf2out_set_name): New.
+	* cp/decl.c (grokdeclarator): Call set_name.
+	* vmsdbgout.c (vmsdbg_debug_hooks): Add set_name_debug_nothing.
+	* debug.c (do_nothing_debug_hooks):  Likewise.
+	* dbxout.c (dbx_debug_hooks): Likewise.
+	* sdbout.c (sdb_debug_hooks): Likewise.
+
+	2009-04-17  David Edelsohn  <edelsohn@gnu.org>
+	* dbxout.c (xcoff_debug_hooks): Add set_name_debug_nothing.
+
+	2009-04-28  Catherine Moore  <clm@codesourcery.com>
+	* debug.h (set_name): Add comment.
+
+2009-05-19  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-04-06  Andrew Stubbs  <ams@codesourcery.com>
+	gcc/testsuite/
+	* gcc.dg/pragma-isr-trapa2.c: Skip test for FPU-less architectures.
+
+2009-05-19  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-04-06  Andrew Stubbs  <ams@codesourcery.com>
+	gcc/testsuite/
+	* gcc.target/sh/sh4a-memmovua.c: Include string.h instead of stdlib.h.
+
+2009-05-19  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-04-06  Andrew Stubbs  <ams@codesourcery.com>
+	gcc/testsuite/
+	* gcc.target/sh/sh4a-bitmovua.c (y0): Rename to y_0 to avoid a clash
+	with the built-in y0, and the subsequent warning.
+	(y1): Likewise, rename to y_1.
+
+2009-05-19  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-04-06  Andrew Stubbs  <ams@codesourcery.com>
+	gcc/
+	* config/sh/lib1funcs.asm (ic_invalidate): Move ICBI out of the
+	delay slot.
+	(ic_invalidate_array): Likewise.
+
+2009-05-19  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-04-06  Andrew Stubbs  <ams@codesourcery.com>
+	gcc/libstdc++-v3/
+	* config/cpu/sh/atomicity.h: Put the SH4A specific functions in the
+	__gnu_cxx namespace.  Remove "static inline".
+
+2009-05-19  Andrew Stubbs  <ams@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-04-02  Andrew Stubbs  <ams@codesourcery.com>
+	gcc/
+	* config/sh/linux-unwind.h: Disable when inhibit_libc is defined.
+
+2009-05-18  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gcc/testsuite/
+	* g++.dg/ext/ms-1.C: Fix mixfixed misapplied patch.
+
+2009-05-18  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Backport from mainline:
+
+	2009-05-18  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	M68K TLS support.
+	gcc/
+	* configure.ac (m68k-*-*): Check if binutils support TLS.
+	* configure: Regenerate.
+	* config/m68k/predicates.md (symbolic_operand): Extend comment.
+	* config/m68k/constraints.md (Cu): New constraint.
+	* config/m68k/m68k.md (UNSPEC_GOTOFF): Remove.
+	(UNSPEC_RELOC16, UNSPEC_RELOC32): New constants.
+	(movsi): Handle TLS symbols.
+	(addsi3_5200): Handle XTLS symbols, indent.
+	* config/m68k/m68k-protos.h (m68k_legitimize_tls_address): Declare.
+	(m68k_tls_reference_p): Declare.
+	(m68k_legitimize_address): Declare.
+	(m68k_unwrap_symbol): Declare.
+	* config/m68k/m68k.opt (mxtls): New option.
+	* config/m68k/m68k.c (ggc.h): Include.
+	(m68k_output_dwarf_dtprel): Implement hook.
+	(TARGET_HAVE_TLS, TARGET_ASM_OUTPUT_DWARF_DTPREL): Define.
+	(m68k_expand_prologue): Load GOT pointer when function needs it.
+	(m68k_illegitimate_symbolic_constant_p): Handle TLS symbols.
+	(m68k_legitimate_constant_address_p): Same.
+	(m68k_decompose_address): Handle TLS references.
+	(m68k_get_gp): New static function.
+	(enum m68k_reloc): New contants.
+	(TLS_RELOC_P): New macro.
+	(m68k_wrap_symbol): New static function.
+	(m68k_unwrap_symbol): New function.
+	(m68k_final_prescan_insn_1): New static function.
+	(m68k_final_prescan_insn): New function.
+	(m68k_move_to_reg, m68k_wrap_symbol_into_got_ref): New static
+	functions.
+	(legitimize_pic_address): Handle TLS references..
+	(m68k_tls_get_addr, m68k_get_tls_get_addr)
+	(m68k_libcall_value_in_a0_p)
+	(m68k_call_tls_get_addr, m68k_read_tp, m68k_get_m68k_read_tp)
+	(m68k_call_m68k_read_tp): Helper variables and functions for ...
+	(m68k_legitimize_tls_address): Handle TLS references.
+	(m68k_tls_symbol_p, m68k_tls_reference_p_1, m68k_tls_reference_p):
+	New functions.
+	(m68k_legitimize_address): Handle TLS symbols.
+	(m68k_get_reloc_decoration): New static function.
+	(m68k_output_addr_const_extra): Handle UNSPEC_RELOC16 and
+	UNSPEC_RELOC32.
+	(m68k_output_dwarf_dtprel): Implement hook.
+	(print_operand_address): Handle UNSPEC_RELOC16 adn UNSPEC_RELOC32.
+	(m68k_libcall_value): Return result in A0 instead of D0 when asked by
+	m68k_call_* routines.
+	(sched_attr_op_type): Handle TLS symbols.
+	(gt-m68k.h): Include.
+	* config/m68k/m68k.h (FINAL_PRESCAN_INSN): Define.
+	(LEGITIMATE_PIC_OPERAND_P): Support TLS.
+	gcc/testsuite/
+	* gcc.target/m68k/tls-ie.c: New test.
+	* gcc.target/m68k/tls-le.c: New test.
+	* gcc.target/m68k/tls-gd.c: New test.
+	* gcc.target/m68k/tls-ld.c: New test.
+	* gcc.target/m68k/tls-ie-xgot.c: New test.
+	* gcc.target/m68k/tls-le-xtls.c: New test.
+	* gcc.target/m68k/tls-gd-xgot.c: New test.
+	* gcc.target/m68k/tls-ld-xgot.c: New test.
+	* gcc.target/m68k/tls-ld-xtls.c: New test.
+	* gcc.target/m68k/tls-ld-xgot-xtls.c: New test.
+
+	Merge from Sourcery G++ 4.3:
+	gcc/
+	* config/m68k/m68k.c (m68k_legitimize_address): New function.
+	* config/m68k/m68k.h (LEGITIMIZE_ADDRESS): Use it.
+	* config/m68k/m68k-proto.h (m68k_legitimize_address): Declare it.
+
+2009-05-15  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-10-23  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue 3852
+	gcc/
+	* config/arm/t-asa (MULTILIB_EXTRA_OPTS): New.
+
+	2008-05-28  Kazu Hirata  <kazu@codesourcery.com>
+
+	Issue 2895
+	gcc/
+	* config.gcc (arm*-*-linux*): Handle enable_extra_asa_multilibs.
+	enable_extra_asa_multilibs.
+	* config/arm/t-asa: New.
+
+	2008-05-28  Kazu Hirata  <kazu@codesourcery.com>
+
+	* config/arm/t-asa (MULTILIB_EXCEPTIONS): Remove
+	march=armv4t/mfpu=neon* and march=armv4t/*mfloat-abi=softfp.  Add
+	*march=armv4t*/*mfpu=neon* and *march=armv4t*/*mfloat-abi=softfp*.
+	(MULTILIB_ALIASES): Remove march?armv4t=mthumb/march?armv4t* and
+	march?armv6=mthumb/march?armv6*. Add
+	march?armv4t=mthumb/march?armv4t, march?armv6=mthumb/march?armv6,
+	and
+	march?armv6/mfloat-abi?softfp=mthumb/march?armv6/mfloat-abi?softfp.
+
+2009-05-15  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	NOT ASSIGNED TO FSF
+	COPYRIGHT CAVIUM
+	gcc/
+	* config/mips/octeon-elf-unwind.h, config/mips/octeon-elf.h,
+	config/mips/octeon.h, config/mips/t-octeon-elf: New.
+	* config.gcc: Handle mips64octeon*-wrs-elf*.
+	(mips-wrs-linux-gnu): Use mips/octeon.h.
+	* config/mips/mips-protos.h (octeon_output_shared_variable): New.
+	* config/mips/mips.c (octeon_handle_cvmx_shared_attribute,
+	octeon_select_section, octeon_unique_section,
+	octeon_output_shared_variable): New.
+	(mips_attribute_table): Add cvmx_shared.
+	(mips_in_small_data_p): Check for cvmx_shared attribute.
+
+	libgcc/
+	* config.host: Handle mips64octeon*-wrs-elf*.
+
+2009-05-15  Mark Mitchell  <mark@codesourcery.com>
+            Joseph Myers  <joseph@codesourcery.com>
+            Mark Shinwell  <shinwell@codesourcery.com>
+            Vladimir Prus  <vladimir@codesourcery.com>
+            Paul Brook  <paul@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	* config.gcc (arm-wrs-linux-gnueabi, i586-wrs-linux-gnu,
+	mips-wrs-linux-gnu, powerpc-wrs-linux-gnu, sparc-wrs-linux-gnu):
+	Handle new targets.
+	* config/arm/t-wrs-linux, config/arm/wrs-linux.h,
+	config/mips/t-wrs-linux, config/mips/wrs-linux.h,
+	config/rs6000/t-wrs-linux, config/rs6000/wrs-linux.h: New.
+	* config/sparc/linux64.h (TARGET_DEFAULT): Define differently for
+	BIARCH_32BIT_DEFAULT.
+
+2009-05-15  Sandra Loosemore  <sandra@codesourcery.com>
+
+	Backport from upstream:
+
+	2009-05-15  Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* optabs.c (prepare_float_lib_cmp):  Test that the comparison,
+	swapped, and reversed optabs exist before trying to use them.
+
+2009-05-12  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/arm/nocrt0.h (LIB_SPEC): Undefine before defining.
+
+2009-05-12  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from ARM/hard_vfp_4_4_branch:
+
+	gcc/
+	2009-05-12  Joseph Myers  <joseph@codesourcery.com>
+	* config/arm/arm.c (aapcs_vfp_sub_candidate): Use V2SImode and
+	V4SImode as representatives of all 64-bit and 128-bit vector
+	types.  Allow vector types without vector modes.
+	(aapcs_vfp_is_call_or_return_candidate): Handle vector types
+	without vector modes like BLKmode.
+	(aapcs_vfp_allocate): Handle TImode for non-TARGET_NEON like
+	BLKmode.  Avoid unsupported vector modes or TImode moves for
+	non-TARGET_NEON.
+	(aapcs_vfp_allocate_return_reg): Likewise.
+	(arm_vector_mode_supported_p): Only support V2SImode, V4HImode and
+	V8QImode if TARGET_NEON || TARGET_IWMMXT.
+
+	2009-05-12  Joseph Myers  <joseph@codesourcery.com>
+	* config/arm/arm.c (arm_handle_pcs_attribute): New.
+	(arm_get_pcs_model): Pass attribute arguments to
+	arm_pcs_from_attribute.
+	(arm_init_cumulative_args): Use base AAPCS for conversions from
+	floating-point types to DImode.
+	(arm_attribute_table): Add pcs attribute.
+	(arm_handle_pcs_attribute): New.
+	* config/arm/bpabi.h (DECLARE_LIBRARY_RENAMES): When renaming
+	conversions from floating-point types to DImode, also declare them
+	to use base AAPCS and declare functions they call to use base
+	AAPCS and their RTABI names.
+
+	2009-05-12  Joseph Myers  <joseph@codesourcery.com>
+	* doc/invoke.texi (-mfloat-abi=@var{name}): Remove statement about
+	-mfloat-abi=hard not being supported for VFP.
+
+	2009-05-11  Kazu Hirata  <kazu@codesourcery.com>
+	* config/sparc/sparc.c (sparc_emit_float_lib_cmp): Pass a libcall
+	SYMBOL_REF to hard_libcall_value.
+
+	2009-03-05  Joseph Myers  <joseph@codesourcery.com>
+		    Richard Earnshaw  <rearnsha@arm.com>
+	* config/arm/arm.c (aapcs_layout_arg): Once a co-processor argument
+	has been put on the stack, all remaining co-processory arguments for
+	that co-processor also go on the stack.
+
+	2009-03-05  Joseph Myers  <joseph@codesourcery.com>
+	* config/arm/arm.c (arm_return_in_memory): Handle returning
+	vectors of suitable size in registers also for AAPCS case.
+
+	2009-01-13  Richard Earnshaw <rearnsha@arm.com>
+	* doc/tm.texi (TARGET_LIBCALL_VALUE): Add missing end statement.
+
+	2008-12-09  Richard Earnshaw <rearnsha@arm.com>
+	ARM Hard-VFP calling convention
+	* target-def.h (TARGET_LIBCALL_VALUE): New hook.
+	* target.h (gcc_target): Add libcall_value to table of call hooks.
+	* targhooks.h (default_libcall_value): Default implementation.
+	* targhooks.c (default_libcall_value): Likewise.
+	* doc/tm.texi (TARGET_LIBCALL_VALUE): Document it.
+	* optabs.c (expand_unop): Use it.
+	* expr.h (hard_libcall_value): Pass the function RTX through.
+	* calls.c (emit_library_call_value_1): Update call to
+	hard_libcall_value.
+	* explow.c (hard_libcall_value): Use new target hook.
+	* testsuite/lib/target-supports.exp
+	(check_effective_target_arm_hard_vfp_ok): New hook.
+	(check_effective_target_arm_neon_ok): Improve test for neon
+	availability.
+	* testsuite/gcc.target/arm/eabi1.c: Only run test in base variant.
+	* config/arm/arm.c: Include cgraph.h
+	(TARGET_FUNCTION_VALUE): Override default hook.
+	(arm_pcs_default): New variable.
+	(arm_override_options): Don't fault hard calling convention with VFP.
+	Add support for AAPCS variants.
+	(arm_function_value): Make static.  Handle AAPCS variants.
+	(arm_libcall_value): New function.
+	(arm_apply_result_size): Handle VFP registers in results.
+	(arm_return_in_memory): Rework all AAPCS variants; handle hard-vfp
+	conventions.
+	(pcs_attribute_args): New variable.
+	(arm_pcs_from_attribute): New function.
+	(arm_get_pcs_model): New function.
+	(aapcs_vfp_cum_init): New function.
+	(aapcs_vfp_sub_candidate): New function.
+	(aapcs_vfp_is_return_candidate): New function.
+	(aapcs_vfp_is_call_candidate): New function.
+	(aapcs_vfp_allocate): New function.
+	(aapcs_vfp_allocate_return_reg): New function.
+	(aapcs_vfp_advance): New function.
+	(aapcs_cp_arg_layout): New variable.
+	(aapcs_select_call_coproc): New function.
+	(aapcs_select_return_coproc): New function.
+	(aapcs_allocate_return_reg): New function.
+	(aapcs_libcall_value): New function.
+	(aapcs_layout_arg): New function.
+	(arm_init_cumulative_args): Initialize AAPCS args data.
+	(arm_function_arg): Handle AAPCS variants using new interface.
+	(arm_arg_parital_bytes): Likewise.
+	(arm_function_arg_advance): New function.
+	(arm_function_ok_for_sibcall): Ensure that sibling calls agree on
+	calling conventions.
+	(arm_setup_incoming_varargs): Handle new AAPCS args data.
+	* arm.h (NUM_VFP_ARG_REGS): Define.
+	(LIBCALL_VALUE): Update.
+	(FUNCTION_VALUE): Delete.
+	(FUNCTION_VALUE_REGNO_P): Add VFP regs.
+	(arm_pcs): New enum.
+	(CUMULATIVE_ARGS): New data to support AAPCS argument marshalling.
+	(FUNCTION_ARG_ADVANCE): Call arm_function_arg_advance.
+	(FUNCTION_ARG_REGNO_P): Add VFP regs.
+	* arm-protos.h (arm_function_arg_advance): Add.
+	(aapcs_libcall_value): Add.
+	(arm_function_value): Delete.
+
+	gcc/testsuite/
+	2009-05-12  Joseph Myers  <joseph@codesourcery.com>
+	* gcc.target/arm/eabi1.c: Do not skip for non-base ABI variants.
+	(PCS): Define macro to use base AAPCS.
+	(decl_float, __aeabi_d2f, __aeabi_f2d): Use PCS macro.
+
+	2009-05-11  Daniel Jacobowitz  <dan@codesourcery.com>
+	* lib/target-supports.exp (check_effective_target_arm_neon_ok):
+	Correct arm_neon.h typo.
+
+	2009-03-06  Richard Earnshaw  <rearnsha@arm.com>
+	* lib/target-supports.exp (check_effective_target_hard_vfp_ok): Make
+	this a linkage test.
+	* gcc.target/arm/aapcs/aapcs.exp: New framework for testing AAPCS
+	argument marshalling.
+	* abitest.h: New file.
+	* vfp1.c, vfp2.c, vfp3.c, vfp4.c, vfp5.c, vfp6.c, vfp7.c: New tests.
+	* vfp8.c, vfp9.c, vfp10.c, vfp11.c, vfp12.c, vfp13.c, vfp14.c: New.
+
+2009-05-12  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gcc/testsuite/
+	* g++.dg/ext/ms-1.C: Fix misapplied patch.
+
+2009-05-12  Maxim Kuvyrkov  <maxim@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2009-05-12  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	* ChangeLog.csl: Add changelog for the previous commit.
+	gcc/
+	* configure: Regenerate with proper autoconf version.
+
+	2009-05-12  Maxim Kuvyrkov  <maxim@codesourcery.com>
+	gcc/
+	* common.opt (feglibc): New dummy option.
+	* opts.c (common_handle_option): Handle it.
+	* config.gcc: Handle 'eglibc' vendor.
+	* config/t-eglibc: Define multilibs for testing EGLIBC features.
+	* configure.ac (--with-eglibc-configs, EGLICB_CONFIGS): New option and
+	variable.
+	* configure: Regenerate.
+	* Makefile.in (EGLIBC_CONFIGS): Handle
+
+2009-05-11  Nathan Sidwell  <nathan@codesourcery.com>
+
+	gcc/
+	* config/m68k/t-uclinux (M68K_MLIB_CPU): Check for FL_UCLINUX.
+	* config/m68k/m68k-devices.def: Add FL_UCLINUX to 68020 and 54455
+	multilibs.
+	* config/m68k/m68k.h (FL_UCLINUX): Define.
+
+	* release-notes-csl.xml: Document.
+
+	gcc/
+	* config/m68k/m68k-devices.def (52274, 52277): New devices.
+	(5301x, 5225x): New devices.
+	(51xx): New devices.
+
+	* release-notes-csl.xml: Document new processors.
+
+	Forward port 2009-02-12  Nathan Sidwell  <nathan@codesourcery.com>
+	Issue #4620
+	gcc/
+	* config/rs6000/rs6000.c (rs6000_init_builtins): Set TYPE_NAME of
+	our distinct integral and vector types.
+	gcc/testsuite/
+	* g++.dg/ext/altivec-17.C: New.
+
+	* release-notes-csl.xml: Add note.
+
+2009-05-08  Nathan Sidwell  <nathan@codesourcery.com>
+
+	Issue 5335
+	gcc/
+	* class.c (resolve_address_of_overloaded_function): Use
+	OVL_CURRENT for error.
+	(instantiate_type): Allow FUNCTION_DECL when ms_extensions are
+	active.  Don't copy the rhs node.  Delete COMPOUND_EXPR code.
+	* typeck.c (build_compound_expr): Check RHS has known type.
+
+	gcc/testsuite/
+	* g++.dg/ext/ms-1.C: New.
+	* g++.old-deja/g++.other/overload11.C: Adjust.
+
+	* release-notes-csl.xml: Add two notes.
+
+2009-05-04  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport:
+	gcc/
+	2009-05-04  Kazu Hirata  <kazu@codesourcery.com>
+	* expmed.c (synth_mult): When trying out a shift, pass the result
+	of a signed shift.
+
+2009-05-04  Kazu Hirata  <kazu@codesourcery.com>
+
+	Backport:
+	gcc/
+	2009-05-04  Kazu Hirata  <kazu@codesourcery.com>
+	* expmed.c (shiftsub_cost): Rename to shiftsub0_cost.
+	(shiftsub1_cost): New.
+	(init_expmed): Compute shiftsub1_cost.
+	(synth_mult): Optimize multiplications by constants of the form
+	-(2^^m-1) for some constant positive integer m.
+
+2009-05-01  Andrew Stubbs  <ams@codesourcery.com>
+
+	gcc/
+	* config/sh/cs-sgxxlite-linux.h, config/sh/t-sgxxlite-linux: New.
+	* config.gcc: Add SH multilib configurations.
+
+2009-05-01  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/
+	2009-04-17  Andrew Stubbs  <ams@codesourcery.com>
+	* configure.ac: Add new AC_SUBST for TM_ENDIAN_CONFIG,
+	TM_MULTILIB_CONFIG and TM_MULTILIB_EXCEPTIONS_CONFIG.
+	(--with-multilib-list): Add default value.
+	* configure: Regenerate.
+	* Makefile.in (TM_ENDIAN_CONFIG): Define.
+	(TM_MULTILIB_CONFIG, TM_MULTILIB_EXCEPTIONS_CONFIG): Define.
+	* config.gcc (sh-*-*): Switch to using TM_ENDIAN_CONFIG,
+	TM_MULTILIB_CONFIG, and TM_MULTILIB_EXCEPTIONS_CONFIG.
+	Don't add default cpu to multilib list unnecessarily, but do enable
+	the relevant compiler option..
+	Add support for --with-multilib-list=<blank> and
+	--with-multilib-list=!<somelib> to supress unwanted multilibs.
+	* config/sh/t-sh (DEFAULT_ENDIAN, OTHER_ENDIAN): New variables.
+	(MULTILIB_ENDIAN, MULTILIB_CPUS): Delete variables.
+	(MULTILIB_OPTIONS): Redefine using OTHER_ENDIAN and
+	TM_MULTILIB_CONFIG.
+	(MULTILIB_EXCEPTIONS): Add TM_MULTILIB_EXCEPTIONS_CONFIG.
+	(MULTILIB_OSDIRNAMES): New variable.
+	* config/sh/t-1e: Delete file.
+	* config/sh/t-mlib-sh1: Delete file.
+	* config/sh/t-mlib-sh2: Delete file.
+	* config/sh/t-mlib-sh2a: Delete file.
+	* config/sh/t-mlib-sh2a-nofpu: Delete file.
+	* config/sh/t-mlib-sh2a-single: Delete file.
+	* config/sh/t-mlib-sh2a-single-only: Delete file.
+	* config/sh/t-mlib-sh2e: Delete file.
+	* config/sh/t-mlib-sh3e: Delete file.
+	* config/sh/t-mlib-sh4: Delete file.
+	* config/sh/t-mlib-sh4-nofpu: Delete file.
+	* config/sh/t-mlib-sh4-single: Delete file.
+	* config/sh/t-mlib-sh4-single-only: Delete file.
+	* config/sh/t-mlib-sh4a: Delete file.
+	* config/sh/t-mlib-sh4a-nofpu: Delete file.
+	* config/sh/t-mlib-sh4a-single: Delete file.
+	* config/sh/t-mlib-sh4a-single-only: Delete file.
+	* config/sh/t-mlib-sh4al: Delete file.
+	* config/sh/t-mlib-sh5-32media: Delete file.
+	* config/sh/t-mlib-sh5-32media-nofpu: Delete file.
+	* config/sh/t-mlib-sh5-64media: Delete file.
+	* config/sh/t-mlib-sh5-64media-nofpu: Delete file.
+	* config/sh/t-mlib-sh5-compact: Delete file.
+	* config/sh/t-mlib-sh5-compact-nofpu: Delete file.
+	* config/sh/t-linux: Don't override MULTILIB_EXCEPTIONS.
+	* doc/install.texi (Options specification): Add
+	--with-multilib-list and --with-endian.
+
+2009-05-01  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	2008-02-12  Julian Brown  <julian@codesourcery.com>
+
+	Merge from MIPS:
+
+	2008-01-16  David Ung  <davidu@mips.com>
+
+	* config/mips/sdemtk.h: Define macro TARGET_MIPS_SDEMTK.
+	* config/mips/mips.c (mips_file_start): Check against
+	TARGET_MIPS_SDEMTK which supports the TARGET_NO_FLOAT option.
+
+2009-05-01  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	2008-03-17  Julian Brown  <julian@codesourcery.com>
+	* config/mips/sdemtk.h (MIPS_ARCH_FLOAT_SPEC): Override, adding
+	-mno-float option.
+
+2009-05-01  Julian Brown  <julian@codesourcery.com>
+            Catherine Moore  <clm@codesourcery.com>
+            Sandra Loosemore  <sandra@codesourcery.com>
+            Richard Sandiford  <richard@codesourcery.com>
+            Nigel Stephens  <nigel@mips.com>
+            Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/mips/cs-sgxx-linux.h, config/mips/cs-sgxxlite-linux.h,
+	config/mips/t-sgxx-linux, config/mips/t-sgxx-sde,
+	config/mips/t-sgxxlite-linux: New.
+	* config.gcc: Add MIPS multilib configurations.
+	* config/mips/mips.opt (mips16e): Add as deprecated alias
+	for -mips16.
+	* doc/invoke.texi (Option Summary, MIPS Options): Document it.
+
+2009-04-29  Nathan Froyd  <froydnj@codesourcery.com>
+            Kazu Hirata <kazu@codesourcery.com>
+            Daniel Jacobowitz  <dan@codesourcery.com>
+            Nathan Sidwell  <nathan@codesourcery.com>
+            Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* config/rs6000/e500mc.h, config/rs6000/t-cs-eabi,
+	config/rs6000/t-cs-eabi-lite, config/rs6000/t-cs-linux,
+	config/rs6000/t-ppc-e500mc: New.
+	* config.gcc: Add Power multilib configurations.
+	* config/rs6000/eabi.h (CC1_EXTRA_SPEC, ASM_DEFAULT_SPEC): Define.
+	* config/rs6000/linux.h (CC1_EXTRA_SPEC, ASM_DEFAULT_SPEC,
+	SYSROOT_SUFFIX_SPEC): Define.
+
+2009-04-29  Joseph Myers  <joseph@codesourcery.com>
+            Daniel Jacobowitz  <dan@codesourcery.com>
+            Nathan Froyd  <froydnj@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	* config/rs6000/option-defaults.h (OPTION_DEFAULT_SPECS): Handle
+	-te500mc, -te500v1, -te500v2 and -te600.
+
+2009-04-29  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	* config/rs6000/sysv4.h (CC1_EXTRA_SPEC): Define and use.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	* config.gcc (mips*-*-*): Support arch_32 arch_64 tune_32 tune_64.
+	* config/mips/mips.h (OPTION_DEFAULT_SPECS): Add support for
+	arch_32 arch_64 tune_32 tune_64.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/
+	2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+	* config.gcc (powerpc*-*-* | rs6000-*-*): Add
+	rs6000/option-defaults.h to tm_file.  Support cpu_32, cpu_64,
+	tune_32 and tune_64.
+	* doc/install.texi (--with-cpu-32, --with-cpu-64): Document
+	support on PowerPC.
+	* config/rs6000/rs6000.h (OPTION_DEFAULT_SPECS): Move to ...
+	* config/rs6000/option-defaults.h: ... here.  New file.
+	(OPT_64, OPT_32): Define.
+	(MASK_64BIT): Define to 0 if not already defined.
+	(OPT_ARCH64, OPT_ARCH32): Define.
+	(OPTION_DEFAULT_SPECS): Add entries for cpu_32, cpu_64, tune_32
+	and tune_64.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+            Paul Brook  <paul@codesourcery.com>
+            Daniel Gutson  <dgutson@codesourcery.com>
+            Julian Brown  <julian@codesourcery.com>
+            Sandra Loosemore  <sandra@codesourcery.com>
+
+	gcc/
+	* config/arm/nocrt0.h, config/arm/t-cs-eabi,
+	config/arm/t-cs-eabi-lite, config/arm/t-cs-linux,
+	config/arm/t-cs-linux-lite, config/arm/t-cs-uclinux-eabi: New.
+	* config.gcc: Add ARM multilib configurations.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	2008-02-05  Paul Brook  <paul@codesourcery.com>
+	* doc/fragments.texi: Document MULTILIB_ALIASES.
+	* genmultilib: Add aliases.
+	* Makefile.in (s-mlib): Pass MULTILIB_ALIASES.
+
+	2009-02-03  Andrew Stubbs  <ams@codesourcery.com>
+	* config/print-sysroot-suffix.sh: Add support for MULTILIB_ALIASES.
+	* config/t-sysroot-suffix: Pass MULTILIB_ALIASES.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/
+	2009-04-07  Andrew Stubbs  <ams@codesourcery.com>
+	* config.gcc (sh-*-*): Add sysroot-suffix.h to tm_file.
+	Add t-sysroot-suffix to tmake_file.
+	* config/print-sysroot-suffix.sh: New file.
+	* config/t-sysroot-suffix: New file.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-08-18  Nathan Froyd  <froydnj@codesourcery.com>
+
+	libgomp/
+	* Makefile.am (LTLDFLAGS): Define.
+	(LINK): Define.
+	* Makefile.in: Regenerate.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	* config.gcc (i[34567]86-*-linux*): Use extra config files if
+	--enable-extra-sgxx-multilibs.
+	* config/i386/cs-linux.h, config/i386/cs-linux.opt,
+	config/i386/t-cs-linux: New.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/
+	2009-04-16  Joseph Myers  <joseph@codesourcery.com>
+	* config/mips/mips.c (mips_rtx_cost_data): Use SOFT_FP_COSTS in
+	XLR entry.
+	* config/mips/mips.h (MIPS_ISA_LEVEL_SPEC, MIPS_ARCH_FLOAT_SPEC):
+	Handle -march=xlr.
+	* config/mips/xlr.md (ir_xlr_alu): Also accept insn types move,
+	logical and signext.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport:
+
+	gcc/
+	2009-04-14  Joseph Myers  <joseph@codesourcery.com>
+	* config/sol2.h (LINK_ARCH32_SPEC_BASE): Use %R with absolute
+	library paths.
+	* config/sparc/sol2-bi.h (LINK_ARCH64_SPEC_BASE): Likewise.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	2008-07-02  Joseph Myers  <joseph@codesourcery.com>
+	* c-incpath.c: Include toplev.h.
+	(merge_include_chains): Use warning instead of cpp_error for
+	system directory poisoning diagnostic.
+	* Makefile.in (c-incpath.o): Depend on toplev.h.
+	* gcc.c (LINK_COMMAND_SPEC): Pass
+	--error-poison-system-directories if
+	-Werror=poison-system-directories.
+
+	2007-06-13  Joseph Myers  <joseph@codesourcery.com>
+	* common.opt (--Wno-poison-system-directories): New.
+	* doc/invoke.texi (-Wno-poison-system-directories): Document.
+	* c-incpath.c: Include flags.h.
+	(merge_include_chains): Check flag_poison_system_directories.
+	* gcc.c (LINK_COMMAND_SPEC): Pass --no-poison-system-directories
+	to linker if -Wno-poison-system-directories.
+	* Makefile.in (c-incpath.o): Depend on $(FLAGS_H).
+
+	2007-03-20  Daniel Jacobowitz  <dan@codesourcery.com>
+	            Joseph Myers  <joseph@codesourcery.com>
+	* configure.ac (--enable-poison-system-directories): New option.
+	* configure, config.in: Regenerate.
+	* c-incpath.c (merge_include_chains): If
+	ENABLE_POISON_SYSTEM_DIRECTORIES defined, warn for use of
+	/usr/include, /usr/local/include or /usr/X11R6/include.
+
+2009-04-28  Mark Mitchell  <mark@codesourcery.com>
+            Vladimir Prus  <vladimir@codesourcery.com>
+            Joseph Myers  <joseph@codesourcery.com>
+            Carlos O'Donell  <carlos@codesourcery.com>
+            Daniel Jacobowitz  <dan@codesourcery.com>
+            Kazu Hirata  <kazu@codesourcery.com>
+
+	libiberty/
+	* configure.ac: Add cygpath for mingw hosts.
+	* configure: Regenerate.
+	* Makefile.in: Add cygpath.
+	* cygpath.c: New.
+	* pex-win32.c (pex_win32_open_read, pex_win32_open_write): Use
+	open not _open.
+
+	include/
+	* libiberty.h (cygpath): Declare.
+
+	config/
+	* mh-mingw (CFLAGS, BOOT_CFLAGS): Do not use -D__USE_MINGW_ACCESS.
+	Add a comment.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	2008-05-01  Carlos O'Donell  <carlos@codesourcery.com>
+
+	* Makefile.tpl (install): Call install-html and install-pdf.
+	* Makefile.in: Regenerate.
+
+	gcc/
+	* Makefile.in (install): Depend on install-html and install-pdf.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	libgomp/
+	* Makefile.am (install-data-am): Do not depend on install-html and
+	install-pdf.
+	* Makefile.in: Regenerate.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from Sourcery G++ 4.3:
+
+	libgomp/
+	2008-09-03  Nathan Froyd  <froydnj@codesourcery.com>
+	* libgomp.texi (Library Index): Renamed from "Index" to prevent
+	conflict with index.html on case-insensitive file systems.
+
+	2008-08-18  Nathan Froyd  <froydnj@codesourcery.com>
+	* Makefile.am (datarootdir, docdir, htmldir, pdfdir): Define.
+	(HTMLS_INSTALL, HTMLS_BUILD): Define.
+	($(HTMLS_BUILD)): New rule.
+	(html__strip_dir): Define.
+	(install-data-am): Add install-html and install-pdf prerequsites.
+	(install-html): Add actions.
+	(TEXI2HTML): Define.
+	* Makefile.in: Regenerate.
+	* configure.ac (datarootdir, docdir, htmldir, pdfdir): Add
+	appropriate --with options and AC_SUBSTs.
+	* configure: Regenerate.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	gcc/
+	* gcc.c (main): Add "const" to declaration of license_status.
+
+	Merge from Sourcery G++ 4.3:
+
+	gcc/
+	2008-09-04  Julian Brown  <julian@codesourcery.com>
+	* Makefile.in (CSL_LICENSELIB): Remove space after -L to appease
+	Darwin ld.
+
+	gcc/
+	2007-10-16  Joseph Myers  <joseph@codesourcery.com>
+	* gcc.c (license_me_flag): Define to 1 if not TARGET_FLEXLM.
+
+	2007-08-10  Nathan Froyd  <froydnj@codesourcery.com>
+	* gcc.c (main): Consult license_me_flag to see if failure to
+	acquire a license implies bailing out entirely.
+
+	2007-08-24  Nathan Froyd  <froydnj@codesourcery.com>
+	Issue #1892
+	* gcc.c (main): Check license_me_flag before declaring failure.
+
+	2007-08-30  Nathan Sidwell  <nathan@codesourcery.com>
+	Issue #1892
+	* gcc.c (main): Don't complain if license fails without -flicense-me
+
+	2007-04-12  Richard Sandiford  <richard@codesourcery.com>
+	* gcc.c (main): If find_a_file fails, pass the original subproc
+	to csl_subproc_license_new.
+
+	2006-12-27  Mark Mitchell  <mark@codesourcery.com>
+	NOT ASSIGNED TO FSF
+	COPYRIGHT CODESOURCERY
+	* gcc.c (main): If the license check fails, remove the generated
+	file.
+
+	2006-12-22  Mark Mitchell  <mark@codesourcery.com>
+	NOT ASSIGNED TO FSF
+	COPYRIGHT CODESOURCERY
+	* aclocal.m4: Move licensing options ...
+	* acinclude.m4: ... here.
+
+	2006-12-13  Mark Mitchell  <mark@codesourcery.com>
+	NOT ASSIGNED TO FSF
+	COPYRIGHT CODESOURCERY
+	* gcc.c (csl/license.h): Include, if required.
+	(license_checked): New variable.
+	(no_license): Remove.
+	(process_command): Set license_checked, not no_license.
+	(main): Use CodeSourcery license library.  Remove most
+	TARGET_FLEXLM code.
+	* aclocal.m4 (--with-license): New option.
+	(--with-csl-license-feature): Likewise.
+	(--with-csl-license-version): Likewise.
+	* Makefile.in (CSL_LICENSEINC): Define it.
+	(CSL_LICENSELIB): Likewise.
+	(CSL_LICENSE_PROG): Likewise.
+	(LIBS): Depend on CSL_LICENSELIB.
+	(GCC_PASSES): Depend on CSL_LICENSE_PROG.
+	(INCLUDES): Add CSL_LICENSEINC.
+	* configure.ac (CSL_AC_LICENSE_VERSION): Use it.
+	(CSL_AC_LICENSE): Likewise.
+	(CSL_AC_LICENSE_FEATURE): Likewise.
+	* config.in: Regenerated.
+	* configure: Regenerated.
+
+	2006-10-29  Richard Sandiford  <richard@codesourcery.com>
+	            Joseph Myers  <joseph@codesourcery.com>
+	* gcc.c (license_me_flag): New variable.
+	(feature_proxy_flag): New variable.
+	(no_license): New variable.
+	(process_command): Handle -flicense-me, -ffeature-proxy and
+	-fno-feature-proxy.  Initialize no_license.
+	(main): Check licenses.
+
+2009-04-28  Joseph Myers  <joseph@codesourcery.com>
+
+	* release-notes-csl.xml: New.
+
+
+Local Variables:
+mode: change-log
+change-log-default-name: "ChangeLog.csl"
+End:
diff --git a/INSTALL/configure.html b/INSTALL/configure.html
index 40d681517..81c5b4f0b 100644
--- a/INSTALL/configure.html
+++ b/INSTALL/configure.html
@@ -423,6 +423,46 @@ sysv, aix.
 
      </dl>
 
+     <br><dt><code>--with-multilib-list=</code><var>list</var><dt><code>--without-multilib-list</code><dd>Specify what multilibs to build. 
+Currently only implemented for sh*-*-*.
+
+     <p><var>list</var> is a comma separated list of CPU names.  These must be of the
+form <code>sh*</code> or <code>m*</code> (in which case they match the compiler option
+for that processor).  The list should not contain any endian options -
+these are handled by <samp><span class="option">--with-endian</span></samp>.
+
+     <p>If <var>list</var> is empty, then there will be no multilibs for extra
+processors.  The multilib for the secondary endian remains enabled.
+
+     <p>As a special case, if an entry in the list starts with a <code>!</code>
+(exclamation point), then it is added to the list of excluded multilibs. 
+Entries of this sort should be compatible with &lsquo;<samp><span class="samp">MULTILIB_EXCLUDES</span></samp>&rsquo;
+(once the leading <code>!</code> has been stripped).
+
+     <p>If <samp><span class="option">--with-multilib-list</span></samp> is not given, then a default set of
+multilibs is selected based on the value of <samp><span class="option">--target</span></samp>.  This is
+usually the complete set of libraries, but some targets imply a more
+specialized subset.
+
+     <p>Example 1: to configure a compiler for SH4A only, but supporting both
+endians, with little endian being the default:
+     <pre class="smallexample">          --with-cpu=sh4a --with-endian=little,big --with-multilib-list=
+</pre>
+     <p>Example 2: to configure a compiler for both SH4A and SH4AL-DSP, but with
+only little endian SH4AL:
+     <pre class="smallexample">          --with-cpu=sh4a --with-endian=little,big --with-multilib-list=sh4al,!mb/m4al
+</pre>
+     <br><dt><code>--with-endian=</code><var>endians</var><dd>Specify what endians to use. 
+Currently only implemented for sh*-*-*.
+
+     <p><var>endians</var> may be one of the following:
+          <dl>
+<dt><code>big</code><dd>Use big endian exclusively. 
+<br><dt><code>little</code><dd>Use little endian exclusively. 
+<br><dt><code>big,little</code><dd>Use big endian by default.  Provide a multilib for little endian. 
+<br><dt><code>little,big</code><dd>Use little endian by default.  Provide a multilib for big endian. 
+</dl>
+
      <br><dt><code>--enable-threads</code><dd>Specify that the target
 supports threads.  This affects the Objective-C compiler and runtime
 library, and exception handling for other languages like C++ and Java. 
@@ -764,6 +804,9 @@ When neither of these configure options are used, the default will be
 128-bit <code>long double</code> when built against GNU C Library 2.4 and later,
 64-bit <code>long double</code> otherwise.
 
+     <br><dt><code>--enable-fdpic</code><dd>On SH uClinux systems, generate ELF FDPIC code rather than code
+expected to be postprocessed into the FLT binary format.
+
      <br><dt><code>--with-gmp=</code><var>pathname</var><dt><code>--with-gmp-include=</code><var>pathname</var><dt><code>--with-gmp-lib=</code><var>pathname</var><dt><code>--with-mpfr=</code><var>pathname</var><dt><code>--with-mpfr-include=</code><var>pathname</var><dt><code>--with-mpfr-lib=</code><var>pathname</var><dd>If you do not have GMP (the GNU Multiple Precision library) and the
 MPFR Libraries installed in a standard location and you want to build
 GCC, you can explicitly specify the directory where they are installed
diff --git a/boehm-gc/include/private/gc_locks.h b/boehm-gc/include/private/gc_locks.h
index 4e2b641b7..1534d44c7 100644
--- a/boehm-gc/include/private/gc_locks.h
+++ b/boehm-gc/include/private/gc_locks.h
@@ -139,49 +139,35 @@
 #      define GC_TEST_AND_SET_DEFINED
 #    endif
 #    if defined(POWERPC)
-#     if 0 /* CPP_WORDSZ == 64  totally broken to use int locks with ldarx */
-        inline static int GC_test_and_set(volatile unsigned int *addr) {
-          unsigned long oldval;
-          unsigned long temp = 1; /* locked value */
-
-          __asm__ __volatile__(
-               "1:\tldarx %0,0,%3\n"   /* load and reserve               */
-               "\tcmpdi %0, 0\n"       /* if load is                     */
-               "\tbne 2f\n"            /*   non-zero, return already set */
-               "\tstdcx. %2,0,%1\n"    /* else store conditional         */
-               "\tbne- 1b\n"           /* retry if lost reservation      */
-               "\tsync\n"              /* import barrier                 */
-               "2:\t\n"                /* oldval is zero if we set       */
-              : "=&r"(oldval), "=p"(addr)
-              : "r"(temp), "1"(addr)
-              : "cr0","memory");
-          return (int)oldval;
-        }
+#     define GC_TEST_AND_SET_DEFINED
+#     define GC_CLEAR_DEFINED
+#     if (__GNUC__>4)||((__GNUC__==4)&&(__GNUC_MINOR__>=4))
+#       define GC_test_and_set(addr) __sync_lock_test_and_set (addr, 1)
+#       define GC_clear(addr) __sync_lock_release (addr)
 #     else
         inline static int GC_test_and_set(volatile unsigned int *addr) {
           int oldval;
           int temp = 1; /* locked value */
 
           __asm__ __volatile__(
-               "1:\tlwarx %0,0,%3\n"   /* load and reserve               */
+               "\n1:\n"
+	       "\tlwarx %0,%y3\n"      /* load and reserve, 32-bits      */
                "\tcmpwi %0, 0\n"       /* if load is                     */
                "\tbne 2f\n"            /*   non-zero, return already set */
-               "\tstwcx. %2,0,%1\n"    /* else store conditional         */
+               "\tstwcx. %2,%y3\n"     /* else store conditional         */
                "\tbne- 1b\n"           /* retry if lost reservation      */
                "\tsync\n"              /* import barrier                 */
                "2:\t\n"                /* oldval is zero if we set       */
-              : "=&r"(oldval), "=p"(addr)
-              : "r"(temp), "1"(addr)
+              : "=&r"(oldval), "=m"(addr)
+              : "r"(temp), "Z"(addr)
               : "cr0","memory");
           return oldval;
         }
-#     endif
-#     define GC_TEST_AND_SET_DEFINED
       inline static void GC_clear(volatile unsigned int *addr) {
 	__asm__ __volatile__("lwsync" : : : "memory");
         *(addr) = 0;
       }
-#     define GC_CLEAR_DEFINED
+#    endif
 #    endif
 #    if defined(ALPHA) 
         inline static int GC_test_and_set(volatile unsigned int * addr)
@@ -221,6 +207,12 @@
 #       define GC_CLEAR_DEFINED
 #    endif /* ALPHA */
 #    ifdef ARM32
+#     define GC_TEST_AND_SET_DEFINED
+#     if (__GNUC__>4)||((__GNUC__==4)&&(__GNUC_MINOR__>=4)) && defined(__ARM_EABI__)
+#       define GC_CLEAR_DEFINED
+#       define GC_test_and_set(addr) __sync_lock_test_and_set (addr, 1)
+#       define GC_clear(addr) __sync_lock_release (addr)
+#     else
         inline static int GC_test_and_set(volatile unsigned int *addr) {
           int oldval;
           /* SWP on ARM is very similar to XCHG on x86.  Doesn't lock the
@@ -233,7 +225,7 @@
 			     : "memory");
           return oldval;
         }
-#       define GC_TEST_AND_SET_DEFINED
+#     endif
 #    endif /* ARM32 */
 #    ifdef CRIS
         inline static int GC_test_and_set(volatile unsigned int *addr) {
diff --git a/config/mh-mingw b/config/mh-mingw
index d91323ef5..fed49012e 100644
--- a/config/mh-mingw
+++ b/config/mh-mingw
@@ -1,6 +1,8 @@
 # Add -D__USE_MINGW_ACCESS to enable the built compiler to work on Windows
 # Vista (see PR33281 for details).
-BOOT_CFLAGS += -D__USE_MINGW_ACCESS -Wno-pedantic-ms-format
-CFLAGS += -D__USE_MINGW_ACCESS
+# Because we wrap access in libiberty/cygpath.c, we do not want to use
+# the MinGW wrappers for access.
+BOOT_CFLAGS += -Wno-pedantic-ms-format
+# CFLAGS += -D__USE_MINGW_ACCESS
 # Increase stack limit to same as Linux default.
 LDFLAGS += -Wl,--stack,8388608
diff --git a/config/stdint.m4 b/config/stdint.m4
index 025ffad9e..adaed19b9 100644
--- a/config/stdint.m4
+++ b/config/stdint.m4
@@ -115,19 +115,19 @@ AC_MSG_RESULT($acx_cv_header_stdint $acx_cv_header_stdint_kind)
 
 # Lacking an uintptr_t?  Test size of void *
 case "$acx_cv_header_stdint:$ac_cv_type_uintptr_t" in
-  stddef.h:* | *:no) AC_CHECK_SIZEOF(void *) ;;
+  stddef.h:* | *:no) AC_CHECK_SIZEOF(void *,,/* no standard headers */) ;;
 esac
 
 # Lacking an uint64_t?  Test size of long
 case "$acx_cv_header_stdint:$ac_cv_type_uint64_t:$ac_cv_type_u_int64_t" in
-  stddef.h:*:* | *:no:no) AC_CHECK_SIZEOF(long) ;;
+  stddef.h:*:* | *:no:no) AC_CHECK_SIZEOF(long,,/* no standard headers */) ;;
 esac
 
 if test $acx_cv_header_stdint = stddef.h; then
   # Lacking a good header?  Test size of everything and deduce all types.
-  AC_CHECK_SIZEOF(int)
-  AC_CHECK_SIZEOF(short)
-  AC_CHECK_SIZEOF(char)
+  AC_CHECK_SIZEOF(int,,/* no standard headers */)
+  AC_CHECK_SIZEOF(short,,/* no standard headers */)
+  AC_CHECK_SIZEOF(char,,/* no standard headers */)
 
   AC_MSG_CHECKING(for type equivalent to int8_t)
   case "$ac_cv_sizeof_char" in
diff --git a/config/tls.m4 b/config/tls.m4
index e77742c76..099bdc257 100644
--- a/config/tls.m4
+++ b/config/tls.m4
@@ -1,5 +1,6 @@
 dnl Check whether the target supports TLS.
 AC_DEFUN([GCC_CHECK_TLS], [
+  AC_REQUIRE([AC_CANONICAL_HOST])
   GCC_ENABLE(tls, yes, [], [Use thread-local storage])
   AC_CACHE_CHECK([whether the target supports thread-local storage],
 		 gcc_cv_have_tls, [
@@ -66,7 +67,24 @@ AC_DEFUN([GCC_CHECK_TLS], [
       [dnl This is the cross-compiling case. Assume libc supports TLS if the
        dnl binutils and the compiler do.
        AC_LINK_IFELSE([__thread int a; int b; int main() { return a = b; }],
-		      [gcc_cv_have_tls=yes], [gcc_cv_have_tls=no])
+	 [chktls_save_LDFLAGS="$LDFLAGS"
+	  dnl Shared library options may depend on the host; this check
+	  dnl is only known to be needed for GNU/Linux.
+	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  dnl If -shared works, test if TLS works in a shared library.
+	  AC_LINK_IFELSE([int f() { return 0; }],
+	    [AC_LINK_IFELSE([__thread int a; int b; int f() { return a = b; }],
+	      [gcc_cv_have_tls=yes],
+	      [gcc_cv_have_tls=no])],
+	    [gcc_cv_have_tls=yes])
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"], [gcc_cv_have_tls=no])
       ]
     )])
   if test "$enable_tls $gcc_cv_have_tls" = "yes yes"; then
diff --git a/configure b/configure
index 1d0000034..8718a2e3d 100755
--- a/configure
+++ b/configure
@@ -2277,7 +2277,7 @@ case "${target}" in
     noconfigdirs="$noconfigdirs target-newlib target-libgloss target-rda ${libgcj}"
     ;;
   *-*-vxworks*)
-    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty ${libgcj}"
     ;;
   alpha*-dec-osf*)
     # ld works, but does not support shared libraries.
@@ -2338,10 +2338,17 @@ case "${target}" in
     esac
     libgloss_dir=arm
     ;;
+  arm*-*-nucleuseabi)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    libgloss_dir=arm
+    ;;
   arm*-*-symbianelf*)
     noconfigdirs="$noconfigdirs ${libgcj} target-libiberty"
     libgloss_dir=arm
     ;;
+  arm*-*-mingw32*)
+    noconfigdirs="$noconfigdirs target-libgloss ${libgcj} target-libiberty"
+    ;;
   arm-*-pe*)
     noconfigdirs="$noconfigdirs target-libgloss ${libgcj}"
     ;;
diff --git a/configure.ac b/configure.ac
index 39c8c0601..c91f6f6cb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -512,7 +512,7 @@ case "${target}" in
     noconfigdirs="$noconfigdirs target-newlib target-libgloss target-rda ${libgcj}"
     ;;
   *-*-vxworks*)
-    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libiberty ${libgcj}"
     ;;
   alpha*-dec-osf*)
     # ld works, but does not support shared libraries.
@@ -566,17 +566,24 @@ case "${target}" in
     noconfigdirs="$noconfigdirs target-libffi target-qthreads"
     libgloss_dir=arm
     ;;
-  arm*-*-linux-gnueabi)
+  arm*-*-linux-*eabi*)
     noconfigdirs="$noconfigdirs target-qthreads"
     case ${with_newlib} in
       no) noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     esac
     libgloss_dir=arm
     ;;
+  arm*-*-nucleuseabi)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    libgloss_dir=arm
+    ;;
   arm*-*-symbianelf*)
     noconfigdirs="$noconfigdirs ${libgcj} target-libiberty"
     libgloss_dir=arm
     ;;
+  arm*-*-mingw32*)
+    noconfigdirs="$noconfigdirs target-libgloss ${libgcj} target-libiberty"
+    ;;
   arm-*-pe*)
     noconfigdirs="$noconfigdirs target-libgloss ${libgcj}"
     ;;
diff --git a/fixincludes/fixincl.tpl b/fixincludes/fixincl.tpl
index c8d4b2ce1..cf057e6fa 100644
--- a/fixincludes/fixincl.tpl
+++ b/fixincludes/fixincl.tpl
@@ -38,7 +38,7 @@ x=fixincl.x =]
 #ifndef SED_PROGRAM
 #define SED_PROGRAM "/usr/bin/sed"
 #endif
-static char const sed_cmd_z[] = SED_PROGRAM;
+static char const sed_cmd_z[] = "sed";
 [=
 
 FOR fix =]
diff --git a/fixincludes/inclhack.def b/fixincludes/inclhack.def
index d08455c45..26438ab9a 100644
--- a/fixincludes/inclhack.def
+++ b/fixincludes/inclhack.def
@@ -1302,6 +1302,43 @@ fix = {
 };
 
 
+/* glibc's bits/string2.h (before 2004-05-26) generates bogus
+   -Wstrict-aliasing warnings from calls to memset.  */
+fix = {
+    hackname  = glibc_string2_memset;
+    files     = "bits/string2.h";
+    select    = "#ifndef _HAVE_STRING_ARCH_memset\n# if _STRING_ARCH_unaligned";
+    c_fix     = format;
+    c_fix_arg = "%0 && 0";
+    test_text = "#ifndef _HAVE_STRING_ARCH_memset\n"
+                "# if _STRING_ARCH_unaligned\n"
+                "# endif\n"
+                "#endif\n";
+};
+
+
+/* Some versions of glibc have a version of bits/string2.h that
+   produces "value computed is not used" warnings from strncpy; fix
+   this definition by using __builtin_strncpy instead as in newer
+   versions.  */
+fix = {
+    hackname  = glibc_strncpy;
+    files     = bits/string2.h;
+    bypass    = "__builtin_strncpy";
+    c_fix     = format;
+    c_fix_arg = "#  define strncpy(dest, src, n) __builtin_strncpy (dest, src, n)";
+    c_fix_arg = "#  define strncpy([^\n]*\\\\\n)*[^\n]*";
+    test_text = <<-EOT
+	#  define strncpy(dest, src, n) \
+	  (__extension__ (__builtin_constant_p (src) && __builtin_constant_p (n)      \\
+			  ? (strlen (src) + 1 >= ((size_t) (n))			      \\
+			     ? (char *) memcpy (dest, src, n)			      \\
+			     : strncpy (dest, src, n))				      \\
+			  : strncpy (dest, src, n)))
+	EOT;
+
+};
+
 /*
  * Fix these files to use the types we think they should for
  * ptrdiff_t, size_t, and wchar_t.
@@ -3024,24 +3061,32 @@ fix = {
 };
 
 /*
- * Sun Solaris defines PTHREAD_MUTEX_INITIALIZER with a trailing
- * "0" for the last field of the pthread_mutex_t structure, which is
- * of type upad64_t, which itself is typedef'd to int64_t, but with
- * __STDC__ defined (e.g. by -ansi) it is a union. So change the
- * initializer to "{0}" instead
+ * Sun Solaris defines the last field of the pthread_mutex_t structure
+ * to have type upad64_t.  Whether upad64_t is an integer type or a
+ * union depends on whether or not the headers believe that a 64-bit
+ * integer type is available.  But, PTHREAD_MUTEX_INITIALIZER is not
+ * appropriately conditionalized; it always uses "0", and never "{0}".
+ * In order to avoid warnings/errors from the compiler, we must make
+ * the initializer use braces where appropriate.
+ *
+ * Prior to Solaris 10, if __STDC__ is 1 (as when compiling with
+ * -ansi), the definition would be a union.  Beginning with Solaris
+ * 10, the headers check for __GNUC__, and will never use a union with
+ * GCC.  We check /usr/include/sys/types.h to see if it checks for
+ * __STDC__.
+ *
+ * A "mach" test for Solaris 10 is undesirable because we want to
+ * allow a compiler built for Solaris <10 to be used on Solaris >=10,
+ * but the installed version of fixincludes hard-wires the target
+ * machine to the configure-time $target, rather than automatically
+ * determining it at installation time.
  */
 fix = {
     hackname = solaris_mutex_init_2;
     select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
     files = pthread.h;
-    /*
-     * On Solaris 10, this fix is unnecessary because upad64_t is
-     * always defined correctly regardless of the definition of the
-     * __STDC__ macro.  The first "mach" pattern matches up to
-     * solaris9.  The second "mach" pattern will not match any two (or
-     * more) digit solaris version, but it will match e.g. 2.5.1.
-     */
-    mach = '*-*-solaris2.[0-9]', '*-*-solaris2.[0-9][!0-9]*';
+    mach = '*-*-solaris*';
+    test = " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
     c_fix = format;
     c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                 "%0\n"
@@ -3052,6 +3097,7 @@ fix = {
                 "(|/\*.*\*/[ \t]*\\\\\n[ \t]*)\\{.*)"
                 ",[ \t]*0\\}" "(|[ \t].*)$";
     test_text =
+    "`mkdir -p sys; echo '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' >> sys/types.h`"
     '#ident "@(#)pthread.h  1.26  98/04/12 SMI"'"\n"
     "#define PTHREAD_MUTEX_INITIALIZER\t{{{0},0}, {{{0}}}, 0}\n"
     "#define PTHREAD_COND_INITIALIZER\t{{{0}, 0}, 0}\t/* DEFAULTCV */\n"
@@ -3063,17 +3109,14 @@ fix = {
 
 
 /*
- * Sun Solaris defines PTHREAD_RWLOCK_INITIALIZER with a "0" for some
- *  fields of the pthread_rwlock_t structure, which are of type
- *  upad64_t, which itself is typedef'd to int64_t, but with __STDC__
- *  defined (e.g. by -ansi) it is a union. So change the initializer
- *  to "{0}" instead.
+ * See comments for solaris_mutex_init_2 re. upad64_t.
  */
 fix = {
     hackname = solaris_rwlock_init_1;
     select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
     files = pthread.h;
     mach = '*-*-solaris*';
+    test = " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
     c_fix = format;
     c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                 "%0\n"
@@ -3109,24 +3152,14 @@ fix = {
 
 
 /*
- * Sun Solaris defines PTHREAD_ONCE_INIT with a "0" for some
- *  fields of the pthread_once_t structure, which are of type
- *  upad64_t, which itself is typedef'd to int64_t, but with __STDC__
- *  defined (e.g. by -ansi) it is a union. So change the initializer
- *  to "{0}" instead.  This test relies on solaris_once_init_1.
+ * See comments for solaris_mutex_init_2 re. upad64_t.
  */
 fix = {
     hackname = solaris_once_init_2;
     select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
     files = pthread.h;
-    /*
-     * On Solaris 10, this fix is unnecessary because upad64_t is
-     * always defined correctly regardless of the definition of the
-     * __STDC__ macro.  The first "mach" pattern matches up to
-     * solaris9.  The second "mach" pattern will not match any two (or
-     * more) digit solaris version, but it will match e.g. 2.5.1.
-     */
-    mach = '*-*-solaris2.[0-9]', '*-*-solaris2.[0-9][!0-9]*';
+    mach = '*-*-solaris*';
+    test = " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
     c_fix = format;
     c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                 "%0\n"
diff --git a/fixincludes/server.c b/fixincludes/server.c
index 6db8cf7e1..f600a15eb 100644
--- a/fixincludes/server.c
+++ b/fixincludes/server.c
@@ -266,7 +266,7 @@ run_shell (const char* pz_cmd)
   /*  Make sure the process will pay attention to us, send the
      supplied command, and then have it output a special marker that
      we can find.  */
-  fprintf (server_pair.pf_write, "cd %s\n%s\n\necho\necho %s\n",
+  fprintf (server_pair.pf_write, "cd '%s'\n%s\n\necho\necho %s\n",
            p_cur_dir, pz_cmd, z_done);
   fflush (server_pair.pf_write);
 
diff --git a/fixincludes/tests/base/bits/string2.h b/fixincludes/tests/base/bits/string2.h
index 1da54fdec..22b71bb0f 100644
--- a/fixincludes/tests/base/bits/string2.h
+++ b/fixincludes/tests/base/bits/string2.h
@@ -16,3 +16,17 @@
 #  define __STRING_INLINE extern __inline
 # endif
 #endif  /* GLIBC_C99_INLINE_3_CHECK */
+
+
+#if defined( GLIBC_STRING2_MEMSET_CHECK )
+#ifndef _HAVE_STRING_ARCH_memset
+# if _STRING_ARCH_unaligned && 0
+# endif
+#endif
+
+#endif  /* GLIBC_STRING2_MEMSET_CHECK */
+
+
+#if defined( GLIBC_STRNCPY_CHECK )
+#  define strncpy(dest, src, n) __builtin_strncpy (dest, src, n)
+#endif  /* GLIBC_STRNCPY_CHECK */
diff --git a/fixincludes/tests/base/sys/types.h b/fixincludes/tests/base/sys/types.h
index 683b5e93e..0bb088cc5 100644
--- a/fixincludes/tests/base/sys/types.h
+++ b/fixincludes/tests/base/sys/types.h
@@ -28,3 +28,4 @@ typedef __WCHAR_TYPE__ wchar_t;
 
 #endif /* ushort_t */
 #endif  /* GNU_TYPES_CHECK */
+#if  !defined(__STRICT_ANSI__) && !defined(_NO_LONGLONG)
diff --git a/gcc/LINARO-VERSION b/gcc/LINARO-VERSION
new file mode 100644
index 000000000..806ad73f2
--- /dev/null
+++ b/gcc/LINARO-VERSION
@@ -0,0 +1 @@
+4.4-2011.02-0
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 8bc4eb703..34363556c 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -327,6 +327,8 @@ GCC_FOR_TARGET = $(STAGE_CC_WRAPPER) ./xgcc -B./ -B$(build_tooldir)/bin/ -isyste
 # It also specifies -isystem ./include to find, e.g., stddef.h.
 GCC_CFLAGS=$(CFLAGS_FOR_TARGET) $(INTERNAL_CFLAGS) $(T_CFLAGS) $(LOOSE_WARN) -Wold-style-definition $($@-warn) -isystem ./include $(TCFLAGS)
 
+EGLIBC_CONFIGS = @EGLIBC_CONFIGS@
+
 # ---------------------------------------------------
 # Programs which produce files for the target machine
 # ---------------------------------------------------
@@ -408,6 +410,9 @@ TARGET_SYSTEM_ROOT = @TARGET_SYSTEM_ROOT@
 
 xmake_file=@xmake_file@
 tmake_file=@tmake_file@
+TM_ENDIAN_CONFIG=@TM_ENDIAN_CONFIG@
+TM_MULTILIB_CONFIG=@TM_MULTILIB_CONFIG@
+TM_MULTILIB_EXCEPTIONS_CONFIG=@TM_MULTILIB_EXCEPTIONS_CONFIG@
 out_file=$(srcdir)/config/@out_file@
 out_object_file=@out_object_file@
 md_file=$(srcdir)/config/@md_file@
@@ -1249,6 +1254,7 @@ OBJS-common = \
 	tree-ssa-loop-manip.o \
 	tree-ssa-loop-niter.o \
 	tree-ssa-loop-prefetch.o \
+	tree-ssa-loop-promote.o \
 	tree-ssa-loop-unswitch.o \
 	tree-ssa-loop.o \
 	tree-ssa-math-opts.o \
@@ -1258,6 +1264,7 @@ OBJS-common = \
 	tree-ssa-pre.o \
 	tree-ssa-propagate.o \
 	tree-ssa-reassoc.o \
+	tree-ssa-remove-local-statics.o \
 	tree-ssa-sccvn.o \
 	tree-ssa-sink.o \
 	tree-ssa-structalias.o \
@@ -1674,7 +1681,7 @@ libgcc-support: libgcc.mvars stmp-int-hdrs $(STMP_FIXPROTO) $(TCONFIG_H) \
 	$(MACHMODE_H) $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \
 	$(LIB2ADD_ST) $(LIB2ADDEH) $(srcdir)/emutls.c gcov-iov.h $(SFP_MACHINE)
 
-libgcc.mvars: config.status Makefile $(LIB2ADD) $(LIB2ADD_ST) specs \
+libgcc.mvars: config.status Makefile $(LIB2ADD) $(LIB2ADD_ST) specs $(tmake_file) \
 		xgcc$(exeext)
 	: > tmp-libgcc.mvars
 	echo LIB1ASMFUNCS = '$(LIB1ASMFUNCS)' >> tmp-libgcc.mvars
@@ -1728,7 +1735,7 @@ libgcc.mvars: config.status Makefile $(LIB2ADD) $(LIB2ADD_ST) specs \
 # driver program needs to select the library directory based on the
 # switches.
 multilib.h: s-mlib; @true
-s-mlib: $(srcdir)/genmultilib Makefile
+s-mlib: $(srcdir)/genmultilib Makefile $(tmakefile)
 	if test @enable_multilib@ = yes \
 	   || test -n "$(MULTILIB_OSDIRNAMES)"; then \
 	  $(SHELL) $(srcdir)/genmultilib \
@@ -1739,10 +1746,11 @@ s-mlib: $(srcdir)/genmultilib Makefile
 	    "$(MULTILIB_EXTRA_OPTS)" \
 	    "$(MULTILIB_EXCLUSIONS)" \
 	    "$(MULTILIB_OSDIRNAMES)" \
+	    "$(MULTILIB_ALIASES)" \
 	    "@enable_multilib@" \
 	    > tmp-mlib.h; \
 	else \
-	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' no \
+	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' '' no \
 	    > tmp-mlib.h; \
 	fi
 	$(SHELL) $(srcdir)/../move-if-change tmp-mlib.h multilib.h
@@ -1816,7 +1824,7 @@ gcc.srcextra: gengtype-lex.c
 
 incpath.o: incpath.c incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \
 		intl.h prefix.h coretypes.h $(TM_H) cppdefault.h $(TARGET_H) \
-		$(MACHMODE_H)
+		$(MACHMODE_H) $(FLAGS_H) toplev.h
 
 c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
     $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) $(FLAGS_H) $(FUNCTION_H) output.h \
@@ -1900,7 +1908,7 @@ c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)		\
         $(TREE_H) $(C_PRAGMA_H) $(FLAGS_H) $(TOPLEV_H) langhooks.h		\
         $(TREE_INLINE_H) $(DIAGNOSTIC_H) intl.h debug.h $(C_COMMON_H)	\
         opts.h options.h $(MKDEPS_H) incpath.h cppdefault.h $(TARGET_H) \
-	$(TM_P_H) $(VARRAY_H)
+	$(TM_P_H) $(VARRAY_H) $(C_TREE_H)
 	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
 		$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@
 
@@ -1953,7 +1961,8 @@ DRIVER_DEFINES = \
   -DTOOLDIR_BASE_PREFIX=\"$(libsubdir_to_prefix)$(prefix_to_exec_prefix)\" \
   @TARGET_SYSTEM_ROOT_DEFINE@ \
   $(VALGRIND_DRIVER_DEFINES) \
-  `test "X$${SHLIB_LINK}" = "X" || test "@enable_shared@" != "yes" || echo "-DENABLE_SHARED_LIBGCC"`
+  `test "X$${SHLIB_LINK}" = "X" || test "@enable_shared@" != "yes" || echo "-DENABLE_SHARED_LIBGCC"` \
+  -DCONFIGURE_SPECS="\"@CONFIGURE_SPECS@\""
 
 gcc.o: gcc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h multilib.h \
     Makefile $(lang_specs_files) specs.h prefix.h $(GCC_H) $(FLAGS_H) \
@@ -2058,7 +2067,7 @@ tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
    all-tree.def $(FLAGS_H) $(FUNCTION_H) $(PARAMS_H) \
    $(TOPLEV_H) $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \
    $(REAL_H) gt-tree.h tree-iterator.h $(BASIC_BLOCK_H) $(TREE_FLOW_H) \
-   $(OBSTACK_H) pointer-set.h fixed-value.h
+   $(OBSTACK_H) pointer-set.h fixed-value.h intl.h
 tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(TREE_H) langhooks.h $(TOPLEV_H) $(SPLAY_TREE_H) $(TREE_DUMP_H) \
    tree-iterator.h tree-pass.h $(DIAGNOSTIC_H) $(REAL_H) fixed-value.h
@@ -2176,6 +2185,9 @@ tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \
    alloc-pool.h $(BASIC_BLOCK_H) $(BITMAP_H) $(HASHTAB_H) $(GIMPLE_H) \
    $(TREE_INLINE_H) tree-iterator.h tree-ssa-sccvn.h $(PARAMS_H) \
    $(DBGCNT_H)
+tree-ssa-remove-local-statics.o: tree-ssa-remove-local-statics.c \
+   coretypes.h $(CONFIG_H) $(SYSTEM_H) $(BASIC_BLOCK_H) tree.h tree-pass.h \
+   $(TM_H) $(HASHTAB_H) $(BASIC_BLOCK_H)
 tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \
    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(FIBHEAP_H) \
    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H) \
@@ -2271,6 +2283,12 @@ tree-ssa-loop-prefetch.o: tree-ssa-loop-prefetch.c $(TREE_FLOW_H) $(CONFIG_H) \
    $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \
    tree-chrec.h $(TOPLEV_H) langhooks.h $(TREE_INLINE_H) $(TREE_DATA_REF_H) \
    $(OPTABS_H)
+tree-ssa-loop-promote.o: tree-ssa-loop-promote.c \
+   coretypes.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H) \
+   $(RTL_H) $(TM_P_H) hard-reg-set.h $(OBSTACK_H) $(BASIC_BLOCK_H) \
+   pointer-set.h intl.h $(TREE_H) $(GIMPLE_H) $(HASHTAB_H) $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(FLAGS_H) $(TIMEVAR_H) \
+   tree-pass.h $(TM_H)
 tree-predcom.o: tree-predcom.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_P_H) \
    $(CFGLOOP_H) $(TREE_FLOW_H) $(GGC_H) $(TREE_DATA_REF_H) $(SCEV_H) \
    $(PARAMS_H) $(DIAGNOSTIC_H) tree-pass.h $(TM_H) coretypes.h tree-affine.h \
@@ -2865,7 +2883,7 @@ postreload.o : postreload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(RTL_H) $(REAL_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) \
    hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) output.h \
    $(FUNCTION_H) $(TOPLEV_H) cselib.h $(TM_P_H) except.h $(TREE_H) $(MACHMODE_H) \
-   $(OBSTACK_H) $(TIMEVAR_H) tree-pass.h $(DF_H) $(DBGCNT_H)
+   $(OBSTACK_H) $(TIMEVAR_H) tree-pass.h addresses.h $(DF_H) $(DBGCNT_H)
 postreload-gcse.o : postreload-gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) \
@@ -3582,7 +3600,7 @@ gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)
 # be rebuilt.
 
 # Build the include directories.
-stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) $(UNWIND_H) fixinc_list
+stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) $(UNWIND_H)
 # Copy in the headers provided with gcc.
 # The sed command gets just the last file name component;
 # this is necessary because VPATH could add a dirname.
@@ -3601,21 +3619,23 @@ stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) $(UNWIND_H) fixinc_list
 	done
 	rm -f include/unwind.h
 	cp $(UNWIND_H) include/unwind.h
-	set -e; for ml in `cat fixinc_list`; do \
-	  sysroot_headers_suffix=`echo $${ml} | sed -e 's/;.*$$//'`; \
-	  multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
-	  fix_dir=include-fixed$${multi_dir}; \
-	  if $(LIMITS_H_TEST) ; then \
-	    cat $(srcdir)/limitx.h $(srcdir)/glimits.h $(srcdir)/limity.h > tmp-xlimits.h; \
-	  else \
-	    cat $(srcdir)/glimits.h > tmp-xlimits.h; \
-	  fi; \
-	  $(mkinstalldirs) $${fix_dir}; \
-	  chmod a+rx $${fix_dir} || true; \
-	  rm -f $${fix_dir}/limits.h; \
-	  mv tmp-xlimits.h $${fix_dir}/limits.h; \
-	  chmod a+r $${fix_dir}/limits.h; \
-	done
+	set -e; if [ -f fixinc_list ] ; then \
+	  for ml in `cat fixinc_list`; do \
+	    sysroot_headers_suffix=`echo $${ml} | sed -e 's/;.*$$//'`; \
+	    multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
+	    fix_dir=include-fixed$${multi_dir}; \
+	    if $(LIMITS_H_TEST) ; then \
+	      cat $(srcdir)/limitx.h $(srcdir)/glimits.h $(srcdir)/limity.h > tmp-xlimits.h; \
+	    else \
+	      cat $(srcdir)/glimits.h > tmp-xlimits.h; \
+	    fi; \
+	    $(mkinstalldirs) $${fix_dir}; \
+	    chmod a+rx $${fix_dir} || true; \
+	    rm -f $${fix_dir}/limits.h; \
+	    mv tmp-xlimits.h $${fix_dir}/limits.h; \
+	    chmod a+r $${fix_dir}/limits.h; \
+	  done; \
+	fi
 # Install the README
 	rm -f include-fixed/README
 	cp $(srcdir)/../fixincludes/README-fixinc include-fixed/README
@@ -3918,8 +3938,7 @@ doc/gccinstall.pdf: $(TEXI_GCCINSTALL_FILES)
 
 # List the directories or single hmtl files which are installed by
 # install-html. The lang.html file triggers language fragments to build
-# html documentation. Installing language fragment documentation is not
-# yet supported.
+# html documentation.
 HTMLS_INSTALL=$(build_htmldir)/cpp $(build_htmldir)/gcc \
        $(build_htmldir)/gccinstall $(build_htmldir)/gccint \
        $(build_htmldir)/cppinternals
@@ -4222,7 +4241,7 @@ install-pdf: $(PDFFILES) lang.install-pdf
 
 html__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
 
-install-html: $(HTMLS_BUILD)
+install-html: $(HTMLS_BUILD) lang.install-html
 	@$(NORMAL_INSTALL)
 	test -z "$(htmldir)" || $(mkinstalldirs) "$(DESTDIR)$(htmldir)"
 	@list='$(HTMLS_INSTALL)'; for p in $$list; do \
@@ -4340,16 +4359,18 @@ real-install-headers-cp:
 
 # Install supporting files for fixincludes to be run later.
 install-mkheaders: stmp-int-hdrs $(STMP_FIXPROTO) install-itoolsdirs \
-  macro_list fixinc_list
+  macro_list
 	$(INSTALL_DATA) $(srcdir)/gsyslimits.h \
 	  $(DESTDIR)$(itoolsdatadir)/gsyslimits.h
 	$(INSTALL_DATA) macro_list $(DESTDIR)$(itoolsdatadir)/macro_list
-	$(INSTALL_DATA) fixinc_list $(DESTDIR)$(itoolsdatadir)/fixinc_list
-	set -e; for ml in `cat fixinc_list`; do \
-	  multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
-	  $(mkinstalldirs) $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}; \
-	  $(INSTALL_DATA) include-fixed$${multidir}/limits.h $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}/limits.h; \
-	done
+	set -e; if [ -f fixinc_list ] ; then \
+	  $(INSTALL_DATA) fixinc_list $(DESTDIR)$(itoolsdatadir)/fixinc_list; \
+	  for ml in `cat fixinc_list`; do \
+	    multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \
+	    $(mkinstalldirs) $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}; \
+	    $(INSTALL_DATA) include-fixed$${multidir}/limits.h $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}/limits.h; \
+	  done; \
+	fi
 	$(INSTALL_SCRIPT) $(srcdir)/../mkinstalldirs \
 		$(DESTDIR)$(itoolsdir)/mkinstalldirs ; \
 	if [ x$(STMP_FIXPROTO) != x ] ; then \
diff --git a/gcc/ada/gcc-interface/Make-lang.in b/gcc/ada/gcc-interface/Make-lang.in
index a7470c9a2..270ba74bf 100644
--- a/gcc/ada/gcc-interface/Make-lang.in
+++ b/gcc/ada/gcc-interface/Make-lang.in
@@ -23,7 +23,7 @@
 #
 # foo.all.cross, foo.start.encap, foo.rest.encap,
 # foo.install-common, foo.install-man, foo.install-info, foo.install-pdf,
-# foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
+# foo.install-html, foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
 # foo.mostlyclean, foo.clean, foo.distclean,
 # foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4
 #
@@ -450,6 +450,8 @@ ada.install-pdf: $(ADA_PDFFILES)
 
 ada.html:
 
+ada.install-html:
+
 doc/gnat_ugn.dvi: doc/gnat_ugn.texi $(gcc_docdir)/include/fdl.texi	\
 	$(gcc_docdir)/include/gcc-common.texi gcc-vers.texi
 	$(TEXI2DVI) -c -I $(abs_docdir)/include -o $@ $<
diff --git a/gcc/ada/gcc-interface/Makefile.in b/gcc/ada/gcc-interface/Makefile.in
index d0c280f7d..28657c1dd 100644
--- a/gcc/ada/gcc-interface/Makefile.in
+++ b/gcc/ada/gcc-interface/Makefile.in
@@ -1,5 +1,5 @@
 # Makefile for GNU Ada Compiler (GNAT).
-#   Copyright (C) 1994-2009 Free Software Foundation, Inc.
+#   Copyright (C) 1994-2010 Free Software Foundation, Inc.
 
 #This file is part of GCC.
 
@@ -1533,6 +1533,41 @@ ifeq ($(strip $(filter-out powerpc% linux%,$(arch) $(osys))),)
   LIBRARY_VERSION := $(LIB_VERSION)
 endif
 
+ifeq ($(strip $(filter-out arm% linux-gnueabi,$(arch) $(osys)-$(word 4,$(targ)))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<a-intnam-linux.ads \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-linux.ads<s-linux.ads \
+  s-osinte.adb<s-osinte-posix.adb \
+  s-osinte.ads<s-osinte-linux.ads \
+  s-osprim.adb<s-osprim-posix.adb \
+  s-taprop.adb<s-taprop-linux.adb \
+  s-tasinf.ads<s-tasinf-linux.ads \
+  s-tasinf.adb<s-tasinf-linux.adb \
+  s-taspri.ads<s-taspri-posix-noaltstack.ads \
+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb
+
+  ifeq ($(strip $(filter-out arm%b,$(arch))),)
+    LIBGNAT_TARGET_PAIRS += \
+    system.ads<system-linux-armeb.ads
+  else
+    LIBGNAT_TARGET_PAIRS += \
+    system.ads<system-linux-armel.ads
+  endif
+
+  TOOLS_TARGET_PAIRS =  \
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb
+
+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o
+  EH_MECHANISM=
+  THREADSLIB = -lpthread
+  GNATLIB_SHARED = gnatlib-shared-dual
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+endif
+
 ifeq ($(strip $(filter-out sparc% linux%,$(arch) $(osys))),)
   LIBGNAT_TARGET_PAIRS_COMMON = \
   a-intnam.ads<a-intnam-linux.ads \
diff --git a/gcc/ada/system-linux-armeb.ads b/gcc/ada/system-linux-armeb.ads
new file mode 100644
index 000000000..aa57af87b
--- /dev/null
+++ b/gcc/ada/system-linux-armeb.ads
@@ -0,0 +1,153 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                        (GNU-Linux/ARMEB Version)                         --
+--                                                                          --
+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.000_001;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 32;
+   Memory_Size  : constant := 2 ** 32;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := High_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   --  0 .. 98 corresponds to the system priority range 1 .. 99.
+   --
+   --  If the scheduling policy is SCHED_FIFO or SCHED_RR the runtime makes use
+   --  of the entire range provided by the system.
+   --
+   --  If the scheduling policy is SCHED_OTHER the only valid system priority
+   --  is 1 and other values are simply ignored.
+
+   Max_Priority           : constant Positive := 97;
+   Max_Interrupt_Priority : constant Positive := 98;
+
+   subtype Any_Priority       is Integer      range  0 .. 98;
+   subtype Priority           is Any_Priority range  0 .. 97;
+   subtype Interrupt_Priority is Any_Priority range 98 .. 98;
+
+   Default_Priority : constant Priority := 48;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := False;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_64_Bit_Divides    : constant Boolean := True;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := False;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := False;
+   GCC_ZCX_Support           : constant Boolean := False;
+
+end System;
diff --git a/gcc/ada/system-linux-armel.ads b/gcc/ada/system-linux-armel.ads
new file mode 100644
index 000000000..64a82f1de
--- /dev/null
+++ b/gcc/ada/system-linux-armel.ads
@@ -0,0 +1,153 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                        (GNU-Linux/ARMEL Version)                         --
+--                                                                          --
+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.000_001;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 32;
+   Memory_Size  : constant := 2 ** 32;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := Low_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   --  0 .. 98 corresponds to the system priority range 1 .. 99.
+   --
+   --  If the scheduling policy is SCHED_FIFO or SCHED_RR the runtime makes use
+   --  of the entire range provided by the system.
+   --
+   --  If the scheduling policy is SCHED_OTHER the only valid system priority
+   --  is 1 and other values are simply ignored.
+
+   Max_Priority           : constant Positive := 97;
+   Max_Interrupt_Priority : constant Positive := 98;
+
+   subtype Any_Priority       is Integer      range  0 .. 98;
+   subtype Priority           is Any_Priority range  0 .. 97;
+   subtype Interrupt_Priority is Any_Priority range 98 .. 98;
+
+   Default_Priority : constant Priority := 48;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := False;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_64_Bit_Divides    : constant Boolean := True;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := False;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := False;
+   GCC_ZCX_Support           : constant Boolean := False;
+
+end System;
diff --git a/gcc/addresses.h b/gcc/addresses.h
index 7413a8563..dafe73322 100644
--- a/gcc/addresses.h
+++ b/gcc/addresses.h
@@ -78,3 +78,42 @@ regno_ok_for_base_p (unsigned regno, enum machine_mode mode,
 
   return ok_for_base_p_1 (regno, mode, outer_code, index_code);
 }
+
+/* Wrapper function to unify target macros MODE_INDEX_REG_CLASS and
+   INDEX_REG_CLASS.  Arguments as for the MODE_INDEX_REG_CLASS macro.  */
+
+static inline enum reg_class
+index_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+#ifdef MODE_INDEX_REG_CLASS
+  return MODE_INDEX_REG_CLASS (mode);
+#else
+  return INDEX_REG_CLASS;
+#endif
+}
+
+/* Wrapper function to unify target macros REGNO_MODE_OK_FOR_INDEX_P
+   and REGNO_OK_FOR_INDEX_P.  Arguments as for the
+   REGNO_MODE_OK_FOR_INDEX_P macro.  */
+
+static inline bool
+ok_for_index_p_1 (unsigned regno, enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+#ifdef REGNO_MODE_OK_FOR_INDEX_P
+  return REGNO_MODE_OK_FOR_INDEX_P (regno, mode);
+#else
+  return REGNO_OK_FOR_INDEX_P (regno);
+#endif
+}
+
+/* Wrapper around ok_for_index_p_1, for use after register allocation is
+   complete.  Arguments as for the called function.  */
+
+static inline bool
+regno_ok_for_index_p (unsigned regno, enum machine_mode mode)
+{
+  if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] >= 0)
+    regno = reg_renumber[regno];
+
+  return ok_for_index_p_1 (regno, mode);
+}
diff --git a/gcc/basic-block.h b/gcc/basic-block.h
index bd741b522..30d8ac8ab 100644
--- a/gcc/basic-block.h
+++ b/gcc/basic-block.h
@@ -900,6 +900,10 @@ extern void find_basic_blocks (rtx);
 
 /* In cfgcleanup.c.  */
 extern bool cleanup_cfg (int);
+extern int flow_find_cross_jump (int, basic_block, basic_block, rtx *, rtx *);
+extern int flow_find_head_matching_sequence (int, basic_block, basic_block,
+					     rtx *, rtx *, int);
+
 extern bool delete_unreachable_blocks (void);
 
 extern bool mark_dfs_back_edges (void);
diff --git a/gcc/c-common.c b/gcc/c-common.c
index 2d62a1cc1..915baa8c0 100644
--- a/gcc/c-common.c
+++ b/gcc/c-common.c
@@ -33,7 +33,6 @@ along with GCC; see the file COPYING3.  If not see
 #include "varray.h"
 #include "expr.h"
 #include "c-common.h"
-#include "diagnostic.h"
 #include "tm_p.h"
 #include "obstack.h"
 #include "cpplib.h"
@@ -42,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-inline.h"
 #include "c-tree.h"
 #include "toplev.h"
+#include "diagnostic.h"
 #include "tree-iterator.h"
 #include "hashtab.h"
 #include "tree-mudflap.h"
@@ -497,6 +497,10 @@ tree (*make_fname_decl) (tree, int);
    This is a count, since unevaluated expressions can nest.  */
 int skip_evaluation;
 
+/* Whether lexing has been completed, so subsequent preprocessor
+   errors should use the compiler's input_location.  */
+bool done_lexing = false;
+
 /* Information about how a function name is generated.  */
 struct fname_var_t
 {
@@ -1021,6 +1025,8 @@ fname_decl (location_t loc, unsigned int rid, tree id)
       if (!IS_EMPTY_STMT (stmts))
 	saved_function_name_decls
 	  = tree_cons (decl, stmts, saved_function_name_decls);
+      DECL_SOURCE_LOCATION (decl) = loc;
+
       *fname_vars[ix].decl = decl;
       input_location = saved_location;
     }
@@ -7516,6 +7522,68 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token, tree value)
 #undef catenate_messages
 }
 
+/* Callback from cpp_error for PFILE to print diagnostics from the
+   preprocessor.  The diagnostic is of type LEVEL, at location
+   LOCATION unless this is after lexing and the compiler's location
+   should be used instead, with column number possibly overridden by
+   COLUMN_OVERRIDE if not zero; MSG is the translated message and AP
+   the arguments.  Returns true if a diagnostic was emitted, false
+   otherwise.  */
+
+bool
+c_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level,
+	     location_t location, unsigned int column_override,
+	     const char *msg, va_list *ap)
+{
+  diagnostic_info diagnostic;
+  diagnostic_t dlevel;
+  int save_warn_system_headers = warn_system_headers;
+  bool ret;
+
+  switch (level)
+    {
+    case CPP_DL_WARNING_SYSHDR:
+      if (flag_no_output)
+	return false;
+      warn_system_headers = 1;
+      /* Fall through.  */
+    case CPP_DL_WARNING:
+      if (flag_no_output)
+	return false;
+      dlevel = DK_WARNING;
+      break;
+    case CPP_DL_PEDWARN:
+      if (flag_no_output && !flag_pedantic_errors)
+	return false;
+      dlevel = DK_PEDWARN;
+      break;
+    case CPP_DL_ERROR:
+      dlevel = DK_ERROR;
+      break;
+    case CPP_DL_ICE:
+      dlevel = DK_ICE;
+      break;
+    case CPP_DL_NOTE:
+      dlevel = DK_NOTE;
+      break;
+    case CPP_DL_FATAL:
+      dlevel = DK_FATAL;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  if (done_lexing)
+    location = input_location;
+  diagnostic_set_info_translated (&diagnostic, msg, ap,
+				  location, dlevel);
+  if (column_override)
+    diagnostic_override_column (&diagnostic, column_override);
+  ret = report_diagnostic (&diagnostic);
+  if (level == CPP_DL_WARNING_SYSHDR)
+    warn_system_headers = save_warn_system_headers;
+  return ret;
+}
+
 /* Walk a gimplified function and warn for functions whose return value is
    ignored and attribute((warn_unused_result)) is set.  This is done before
    inlining, so we don't have to worry about that.  */
diff --git a/gcc/c-common.h b/gcc/c-common.h
index 99460bdb1..3d97894fa 100644
--- a/gcc/c-common.h
+++ b/gcc/c-common.h
@@ -658,6 +658,11 @@ extern int max_tinst_depth;
 
 extern int skip_evaluation;
 
+/* Whether lexing has been completed, so subsequent preprocessor
+   errors should use the compiler's input_location.  */
+
+extern bool done_lexing;
+
 /* C types are partitioned into three subsets: object, function, and
    incomplete types.  */
 #define C_TYPE_OBJECT_P(type) \
diff --git a/gcc/c-convert.c b/gcc/c-convert.c
index d7e2e5d04..a3ff8bb02 100644
--- a/gcc/c-convert.c
+++ b/gcc/c-convert.c
@@ -70,6 +70,7 @@ convert (tree type, tree expr)
   tree e = expr;
   enum tree_code code = TREE_CODE (type);
   const char *invalid_conv_diag;
+  tree ret;
 
   if (type == error_mark_node
       || expr == error_mark_node
@@ -85,6 +86,9 @@ convert (tree type, tree expr)
 
   if (type == TREE_TYPE (expr))
     return expr;
+  ret = targetm.convert_to_type (type, expr);
+  if (ret)
+      return ret;
 
   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))
     return fold_convert (type, expr);
diff --git a/gcc/c-decl.c b/gcc/c-decl.c
index f2ba35990..aacf75365 100644
--- a/gcc/c-decl.c
+++ b/gcc/c-decl.c
@@ -4002,6 +4002,7 @@ grokdeclarator (const struct c_declarator *declarator,
   bool bitfield = width != NULL;
   tree element_type;
   struct c_arg_info *arg_info = 0;
+  const char *errmsg;
 
   if (decl_context == FUNCDEF)
     funcdef_flag = true, decl_context = NORMAL;
@@ -4539,6 +4540,12 @@ grokdeclarator (const struct c_declarator *declarator,
 		error ("%qs declared as function returning an array", name);
 		type = integer_type_node;
 	      }
+	    errmsg = targetm.invalid_return_type (type);
+	    if (errmsg)
+	      {
+		error (errmsg);
+		type = integer_type_node;
+	      }
 
 	    /* Construct the function type and go to the next
 	       inner layer of declarator.  */
@@ -5052,6 +5059,7 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)
     {
       tree parm, type, typelt;
       unsigned int parmno;
+      const char *errmsg;
 
       /* If there is a parameter of incomplete type in a definition,
 	 this is an error.  In a declaration this is valid, and a
@@ -5095,6 +5103,14 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)
 		}
 	    }
 
+	  errmsg = targetm.invalid_parameter_type (type);
+	  if (errmsg)
+	    {
+	      error (errmsg);
+	      TREE_VALUE (typelt) = error_mark_node;
+	      TREE_TYPE (parm) = error_mark_node;
+	    }
+
 	  if (DECL_NAME (parm) && TREE_USED (parm))
 	    warn_if_shadowing (parm);
 	}
@@ -8088,7 +8104,7 @@ c_write_global_declarations (void)
 
   /* Don't waste time on further processing if -fsyntax-only or we've
      encountered errors.  */
-  if (flag_syntax_only || errorcount || sorrycount || cpp_errors (parse_in))
+  if (flag_syntax_only || errorcount || sorrycount)
     return;
 
   /* Close the external scope.  */
diff --git a/gcc/c-opts.c b/gcc/c-opts.c
index 28bdc31d5..1cb8b77b6 100644
--- a/gcc/c-opts.c
+++ b/gcc/c-opts.c
@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "mkdeps.h"
 #include "target.h"
 #include "tm_p.h"
+#include "c-tree.h"		/* For c_cpp_error.  */
 
 #ifndef DOLLARS_IN_IDENTIFIERS
 # define DOLLARS_IN_IDENTIFIERS true
@@ -201,6 +202,7 @@ c_common_init_options (unsigned int argc, const char **argv)
 {
   static const unsigned int lang_flags[] = {CL_C, CL_ObjC, CL_CXX, CL_ObjCXX};
   unsigned int i, result;
+  struct cpp_callbacks *cb;
 
   /* This is conditionalized only because that is the way the front
      ends used to do it.  Maybe this should be unconditional?  */
@@ -216,6 +218,8 @@ c_common_init_options (unsigned int argc, const char **argv)
 
   parse_in = cpp_create_reader (c_dialect_cxx () ? CLK_GNUCXX: CLK_GNUC89,
 				ident_hash, line_table);
+  cb = cpp_get_callbacks (parse_in);
+  cb->error = c_cpp_error;
 
   cpp_opts = cpp_get_options (parse_in);
   cpp_opts->dollars_in_ident = DOLLARS_IN_IDENTIFIERS;
@@ -333,12 +337,12 @@ c_common_handle_option (size_t scode, const char *arg, int value)
 	 or environment var dependency generation is used.  */
       cpp_opts->deps.style = (code == OPT_M ? DEPS_SYSTEM: DEPS_USER);
       flag_no_output = 1;
-      cpp_opts->inhibit_warnings = 1;
       break;
 
     case OPT_MD:
     case OPT_MMD:
       cpp_opts->deps.style = (code == OPT_MD ? DEPS_SYSTEM: DEPS_USER);
+      cpp_opts->deps.need_preprocessor_output = true;
       deps_file = arg;
       break;
 
@@ -444,7 +448,6 @@ c_common_handle_option (size_t scode, const char *arg, int value)
       break;
 
     case OPT_Werror:
-      cpp_opts->warnings_are_errors = value;
       global_dc->warning_as_error_requested = value;
       break;
 
@@ -503,10 +506,6 @@ c_common_handle_option (size_t scode, const char *arg, int value)
       warn_strict_null_sentinel = value;
       break;
 
-    case OPT_Wsystem_headers:
-      cpp_opts->warn_system_headers = value;
-      break;
-
     case OPT_Wtraditional:
       cpp_opts->warn_traditional = value;
       break;
@@ -895,8 +894,6 @@ c_common_handle_option (size_t scode, const char *arg, int value)
 	 c_common_post_options, so that a subsequent -Wno-endif-labels
 	 is not overridden.  */
     case OPT_pedantic_errors:
-      cpp_opts->pedantic_errors = 1;
-      /* Fall through.  */
     case OPT_pedantic:
       cpp_opts->pedantic = 1;
       cpp_opts->warn_endif_labels = 1;
@@ -971,10 +968,6 @@ c_common_handle_option (size_t scode, const char *arg, int value)
       flag_undef = 1;
       break;
 
-    case OPT_w:
-      cpp_opts->inhibit_warnings = 1;
-      break;
-
     case OPT_v:
       verbose = true;
       break;
@@ -1159,10 +1152,6 @@ c_common_post_options (const char **pfilename)
 
   input_location = UNKNOWN_LOCATION;
 
-  /* If an error has occurred in cpplib, note it so we fail
-     immediately.  */
-  errorcount += cpp_errors (parse_in);
-
   *pfilename = this_input_filename
     = cpp_read_main_file (parse_in, in_fnames[0]);
   /* Don't do any compilation or preprocessing if there is no input file.  */
@@ -1274,7 +1263,8 @@ c_common_finish (void)
 {
   FILE *deps_stream = NULL;
 
-  if (cpp_opts->deps.style != DEPS_NONE)
+  /* Don't write the deps file if there are errors.  */
+  if (cpp_opts->deps.style != DEPS_NONE && errorcount == 0)
     {
       /* If -M or -MM was seen without -MF, default output to the
 	 output stream.  */
@@ -1290,7 +1280,7 @@ c_common_finish (void)
 
   /* For performance, avoid tearing down cpplib's internal structures
      with cpp_destroy ().  */
-  errorcount += cpp_finish (parse_in, deps_stream);
+  cpp_finish (parse_in, deps_stream);
 
   if (deps_stream && deps_stream != out_stream
       && (ferror (deps_stream) || fclose (deps_stream)))
diff --git a/gcc/c-ppoutput.c b/gcc/c-ppoutput.c
index f5a3a7882..8f882a571 100644
--- a/gcc/c-ppoutput.c
+++ b/gcc/c-ppoutput.c
@@ -521,6 +521,7 @@ pp_file_change (const struct line_map *map)
 
   if (map != NULL)
     {
+      input_location = map->start_location;
       if (print.first_time)
 	{
 	  /* Avoid printing foo.i when the main file is foo.c.  */
diff --git a/gcc/c-tree.h b/gcc/c-tree.h
index 26a274543..9adf1f9ca 100644
--- a/gcc/c-tree.h
+++ b/gcc/c-tree.h
@@ -647,4 +647,8 @@ extern void c_write_global_declarations (void);
 extern void pedwarn_c90 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_CDIAG(3,4);
 extern void pedwarn_c99 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_CDIAG(3,4);
 
+extern bool c_cpp_error (cpp_reader *, int, location_t, unsigned int,
+			 const char *, va_list *)
+     ATTRIBUTE_GCC_CDIAG(5,0);
+
 #endif /* ! GCC_C_TREE_H */
diff --git a/gcc/c-typeck.c b/gcc/c-typeck.c
index d9c0c1e22..fbd71346f 100644
--- a/gcc/c-typeck.c
+++ b/gcc/c-typeck.c
@@ -1765,6 +1765,7 @@ default_conversion (tree exp)
   tree orig_exp;
   tree type = TREE_TYPE (exp);
   enum tree_code code = TREE_CODE (type);
+  tree promoted_type;
 
   /* Functions and arrays have been converted during parsing.  */
   gcc_assert (code != FUNCTION_TYPE);
@@ -1801,6 +1802,10 @@ default_conversion (tree exp)
   if (exp == error_mark_node)
     return error_mark_node;
 
+  promoted_type = targetm.promoted_type (type);
+  if (promoted_type)
+    return convert (promoted_type, exp);
+
   if (INTEGRAL_TYPE_P (type))
     return perform_integral_promotions (exp);
 
diff --git a/gcc/c.opt b/gcc/c.opt
index 711710b99..949e1bfed 100644
--- a/gcc/c.opt
+++ b/gcc/c.opt
@@ -720,6 +720,10 @@ fpreprocessed
 C ObjC C++ ObjC++
 Treat the input file as already preprocessed
 
+fremove-local-statics
+C C++ Var(flag_remove_local_statics) Optimization
+Convert function-local static variables to automatic variables when it is safe to do so
+
 freplace-objc-classes
 ObjC ObjC++
 Used in Fix-and-Continue mode to indicate that object files may be swapped in at runtime
diff --git a/gcc/calls.c b/gcc/calls.c
index 16d829b9c..5f9671981 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -711,7 +711,9 @@ precompute_register_parameters (int num_actuals, struct arg_data *args,
 
 	   For small register classes, also do this if this call uses
 	   register parameters.  This is to avoid reload conflicts while
-	   loading the parameters registers.  */
+	   loading the parameters registers.
+	   
+	   Avoid creating the extra move if optimizing for size.  */
 
 	else if ((! (REG_P (args[i].value)
 		     || (GET_CODE (args[i].value) == SUBREG
@@ -719,6 +721,7 @@ precompute_register_parameters (int num_actuals, struct arg_data *args,
 		 && args[i].mode != BLKmode
 		 && rtx_cost (args[i].value, SET, optimize_insn_for_speed_p ())
 		    > COSTS_N_INSNS (1)
+		 && !optimize_size
 		 && ((SMALL_REGISTER_CLASSES && *reg_parm_seen)
 		     || optimize))
 	  args[i].value = copy_to_mode_reg (args[i].mode, args[i].value);
@@ -3806,7 +3809,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,
      cse'ing of library calls could delete a call and leave the pop.  */
   NO_DEFER_POP;
   valreg = (mem_value == 0 && outmode != VOIDmode
-	    ? hard_libcall_value (outmode) : NULL_RTX);
+	    ? hard_libcall_value (outmode, orgfun) : NULL_RTX);
 
   /* Stack must be properly aligned now.  */
   gcc_assert (!(stack_pointer_delta
@@ -4051,8 +4054,17 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,
 	      /* We need to make a save area.  */
 	      unsigned int size = arg->locate.size.constant * BITS_PER_UNIT;
 	      enum machine_mode save_mode = mode_for_size (size, MODE_INT, 1);
-	      rtx adr = memory_address (save_mode, XEXP (arg->stack_slot, 0));
-	      rtx stack_area = gen_rtx_MEM (save_mode, adr);
+	      rtx adr;
+	      rtx stack_area;
+
+	      /* We can only use save_mode if the arg is sufficiently
+	         aligned.  */
+	      if (STRICT_ALIGNMENT
+		  && GET_MODE_ALIGNMENT (save_mode) > arg->locate.boundary)
+		save_mode = BLKmode;
+
+	      adr = memory_address (save_mode, XEXP (arg->stack_slot, 0));
+	      stack_area = gen_rtx_MEM (save_mode, adr);
 
 	      if (save_mode == BLKmode)
 		{
diff --git a/gcc/cfgcleanup.c b/gcc/cfgcleanup.c
index 190bde668..9523bf326 100644
--- a/gcc/cfgcleanup.c
+++ b/gcc/cfgcleanup.c
@@ -68,7 +68,6 @@ static bool crossjumps_occured;
 static bool try_crossjump_to_edge (int, edge, edge);
 static bool try_crossjump_bb (int, basic_block);
 static bool outgoing_edges_match (int, basic_block, basic_block);
-static int flow_find_cross_jump (int, basic_block, basic_block, rtx *, rtx *);
 static bool old_insns_match_p (int, rtx, rtx);
 
 static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);
@@ -967,13 +966,27 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)
      be filled that clobbers a parameter expected by the subroutine.
 
      ??? We take the simple route for now and assume that if they're
-     equal, they were constructed identically.  */
+     equal, they were constructed identically.
 
-  if (CALL_P (i1)
-      && (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),
+     Also check for identical exception regions.  */
+
+  if (CALL_P (i1))
+    {
+      /* Ensure the same EH region.  */
+      rtx n1 = find_reg_note (i1, REG_EH_REGION, 0);
+      rtx n2 = find_reg_note (i2, REG_EH_REGION, 0);
+
+      if (!n1 && n2)
+	return false;
+
+      if (n1 && (!n2 || XEXP (n1, 0) != XEXP (n2, 0)))
+	return false;
+
+      if (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),
 			CALL_INSN_FUNCTION_USAGE (i2))
-	  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2)))
-    return false;
+	  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2))
+	return false;
+    }
 
 #ifdef STACK_REGS
   /* If cross_jump_death_matters is not 0, the insn's mode
@@ -1053,7 +1066,7 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)
    To simplify callers of this function, if the blocks match exactly,
    store the head of the blocks in *F1 and *F2.  */
 
-static int
+int
 flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,
 		      basic_block bb2, rtx *f1, rtx *f2)
 {
@@ -1159,6 +1172,108 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,
   return ninsns;
 }
 
+/* Like flow_find_cross_jump, except start looking for a matching sequence from
+   the head of the two blocks.  Do not include jumps at the end.
+   If STOP_AFTER is nonzero, stop after finding that many matching
+   instructions.  */
+
+int
+flow_find_head_matching_sequence (int mode ATTRIBUTE_UNUSED, basic_block bb1,
+				  basic_block bb2, rtx *f1, rtx *f2,
+				  int stop_after)
+{
+  rtx i1, i2, last1, last2, beforelast1, beforelast2;
+  int ninsns = 0;
+  edge e;
+  edge_iterator ei;
+  int nehedges1 = 0, nehedges2 = 0;
+
+  FOR_EACH_EDGE (e, ei, bb1->succs)
+    if (e->flags & EDGE_EH)
+      nehedges1++;
+  FOR_EACH_EDGE (e, ei, bb2->succs)
+    if (e->flags & EDGE_EH)
+      nehedges2++;
+
+  i1 = BB_HEAD (bb1);
+  i2 = BB_HEAD (bb2);
+  last1 = beforelast1 = last2 = beforelast2 = NULL_RTX;
+
+  while (true)
+    {
+
+      /* Ignore notes.  */
+      while (!INSN_P (i1) && i1 != BB_END (bb1))
+	i1 = NEXT_INSN (i1);
+
+      while (!INSN_P (i2) && i2 != BB_END (bb2))
+	i2 = NEXT_INSN (i2);
+
+      if (NOTE_P (i1) || NOTE_P (i2)
+	  || JUMP_P (i1) || JUMP_P (i2))
+	break;
+
+      if ((i1 == BB_END (bb1) && i2 != BB_END (bb2)
+	   && nehedges1 > 0)
+	  || (i2 == BB_END (bb2) && i1 != BB_END (bb1)
+	      && nehedges2 > 0)
+	  || (i1 == BB_END (bb1) && i2 == BB_END (bb2)
+	      && nehedges1 != nehedges2))
+	break;
+
+      if (!old_insns_match_p (mode, i1, i2))
+	break;
+
+      merge_memattrs (i1, i2);
+
+      /* Don't begin a cross-jump with a NOTE insn.  */
+      if (INSN_P (i1))
+	{
+	  /* If the merged insns have different REG_EQUAL notes, then
+	     remove them.  */
+	  rtx equiv1 = find_reg_equal_equiv_note (i1);
+	  rtx equiv2 = find_reg_equal_equiv_note (i2);
+
+	  if (equiv1 && !equiv2)
+	    remove_note (i1, equiv1);
+	  else if (!equiv1 && equiv2)
+	    remove_note (i2, equiv2);
+	  else if (equiv1 && equiv2
+		   && !rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))
+	    {
+	      remove_note (i1, equiv1);
+	      remove_note (i2, equiv2);
+	    }
+
+	  beforelast1 = last1, beforelast2 = last2;
+	  last1 = i1, last2 = i2;
+	  ninsns++;
+	}
+
+      if (i1 == BB_END (bb1) || i2 == BB_END (bb2)
+	  || (stop_after > 0 && ninsns == stop_after))
+	break;
+
+      i1 = NEXT_INSN (i1);
+      i2 = NEXT_INSN (i2);
+    }
+
+#ifdef HAVE_cc0
+  /* Don't allow a compare to be shared by cross-jumping unless the insn
+     after the compare is also shared.  */
+  if (ninsns && reg_mentioned_p (cc0_rtx, last1) && sets_cc0_p (last1))
+    last1 = beforelast1, last2 = beforelast2, ninsns--;
+#endif
+
+  if (ninsns)
+    {
+      *f1 = last1;
+      *f2 = last2;
+    }
+
+  return ninsns;
+}
+
 /* Return true iff outgoing edges of BB1 and BB2 match, together with
    the branch instruction.  This means that if we commonize the control
    flow before end of the basic block, the semantic remains unchanged.
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index 70325be17..988793cb4 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -448,7 +448,8 @@ get_decl_align_unit (tree decl)
 {
   unsigned int align;
 
-  align = LOCAL_DECL_ALIGNMENT (decl);
+  align = alignment_for_aligned_arrays (TREE_TYPE (decl),
+					LOCAL_DECL_ALIGNMENT (decl));
 
   if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
     align = MAX_SUPPORTED_STACK_ALIGNMENT;
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index b1eea0b08..60357d0c8 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -475,9 +475,11 @@ cgraph_node (tree decl)
   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)
     {
       node->origin = cgraph_node (DECL_CONTEXT (decl));
+      node->origin->ever_was_nested = 1;
       node->next_nested = node->origin->nested;
       node->origin->nested = node;
       node->master_clone = node;
+      node->ever_was_nested = 1;
     }
   if (assembler_name_hash)
     {
diff --git a/gcc/cgraph.h b/gcc/cgraph.h
index 29fc1ba4a..f1f2d3991 100644
--- a/gcc/cgraph.h
+++ b/gcc/cgraph.h
@@ -185,6 +185,8 @@ struct cgraph_node GTY((chain_next ("%h.next"), chain_prev ("%h.previous")))
   unsigned output : 1;
   /* Set for aliases once they got through assemble_alias.  */
   unsigned alias : 1;
+  /* Set if the function is a nested function or has nested functions.  */
+  unsigned ever_was_nested : 1;
 
   /* In non-unit-at-a-time mode the function body of inline candidates is saved
      into clone before compiling so the function in original form can be
diff --git a/gcc/common.opt b/gcc/common.opt
index 023d77358..35edae0a6 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -153,6 +153,10 @@ Wpadded
 Common Var(warn_padded) Warning
 Warn when padding is required to align structure members
 
+Wpoison-system-directories
+Common Var(flag_poison_system_directories) Init(1)
+Warn for -I and -L options using system directories if cross compiling
+
 Wshadow
 Common Var(warn_shadow) Warning
 Warn when one local variable shadows another
@@ -270,6 +274,12 @@ Common Separate
 fabi-version=
 Common Joined UInteger Var(flag_abi_version) Init(2)
 
+falign-arrays
+Target Report Var(flag_align_arrays)
+Set the minimum alignment for array variables to be the largest power
+of two less than or equal to their total storage size, or the biggest
+alignment used on the machine, whichever is smaller.
+
 falign-functions
 Common Report Var(align_functions,0) Optimization UInteger
 Align the start of functions
@@ -467,6 +477,10 @@ fearly-inlining
 Common Report Var(flag_early_inlining) Init(1) Optimization
 Perform early inlining
 
+feglibc=
+Common Report Joined Undocumented
+EGLIBC configuration specifier, serves multilib purposes.
+
 feliminate-dwarf2-dups
 Common Report Var(flag_eliminate_dwarf2_dups)
 Perform DWARF2 duplicate elimination
@@ -895,6 +909,10 @@ fprofile-values
 Common Report Var(flag_profile_values)
 Insert code to profile values of expressions
 
+fpromote-loop-indices
+Common Report Var(flag_promote_loop_indices) Optimization
+Promote loop indices to word-sized indices when safe
+
 frandom-seed
 Common
 
@@ -1227,6 +1245,15 @@ ftree-pre
 Common Report Var(flag_tree_pre) Optimization
 Enable SSA-PRE optimization on trees
 
+ftree-pre-partial-partial
+Common Report Var(flag_tree_pre_partial_partial) Optimization
+In SSA-PRE optimization on trees, enable partial-partial redundancy elimination.
+
+ftree-pre-partial-partial-obliviously
+Common Report Var(flag_tree_pre_partial_partial_obliviously) Optimization
+In SSA-PRE optimization on trees, enable partial-partial redundancy
+elimination without regard for the cost of the inserted phi nodes.
+
 ftree-reassoc
 Common Report Var(flag_tree_reassoc) Init(1) Optimization
 Enable reassociation on tree level
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 3f9951d27..889be18ff 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -209,6 +209,7 @@ case ${target} in
 # Avoid generic cases below matching.
    h8300-*-rtems* | h8300-*-elf* \
  | sh-*-elf* | sh-*-symbianelf* | sh-*-linux* | sh-*-netbsdelf* \
+ | sh-*-uclinux* \
  | sh-*-rtems* | sh-wrs-vxworks) ;;
    arm-*-coff*		\
  | armel-*-coff*	\
@@ -718,7 +719,7 @@ arm*-*-linux*)			# ARM GNU/Linux with ELF
 	esac
 	tmake_file="${tmake_file} t-linux arm/t-arm"
 	case ${target} in
-	arm*-*-linux-*eabi)
+	arm*-*-linux-*eabi*)
 	    tm_file="$tm_file arm/bpabi.h arm/linux-eabi.h"
 	    tmake_file="$tmake_file arm/t-arm-elf arm/t-bpabi arm/t-linux-eabi t-slibgcc-libgcc"
   	    # The BPABI long long divmod functions return a 128-bit value in
@@ -727,6 +728,28 @@ arm*-*-linux*)			# ARM GNU/Linux with ELF
 	    need_64bit_hwint=yes
 	    # The EABI requires the use of __cxa_atexit.
 	    default_use_cxa_atexit=yes
+	    case ${target} in
+	    arm-wrs-linux-gnueabi) 
+		tm_file="$tm_file arm/wrs-linux.h"
+		tmake_file="$tmake_file arm/t-wrs-linux"
+		tm_defines="$tm_defines TARGET_FLEXLM"
+		;;
+	    arm-montavista*-linux-gnueabi)
+		tm_file="$tm_file arm/montavista-linux.h"
+		tmake_file="$tmake_file arm/t-montavista-linux"
+		;;
+	    *)
+		if test x$enable_extra_asa_multilibs = xyes; then
+			tmake_file="${tmake_file} arm/t-asa"
+		elif test x$enable_extra_sgxx_multilibs = xyes; then
+			tmake_file="${tmake_file} arm/t-cs-linux"
+		elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+			tmake_file="${tmake_file} arm/t-cs-linux-lite"
+		fi
+		tm_file="$tm_file ./sysroot-suffix.h"
+		tmake_file="$tmake_file t-sysroot-suffix"
+		;;
+	    esac
 	    ;;
 	*)
 	    tmake_file="$tmake_file arm/t-linux"
@@ -739,7 +762,7 @@ arm*-*-uclinux*)		# ARM ucLinux
 	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/linux-gas.h arm/uclinux-elf.h"
 	tmake_file="arm/t-arm arm/t-arm-elf"
 	case ${target} in
-	arm*-*-uclinux*eabi)
+	arm*-*-uclinux*eabi*)
 	    tm_file="$tm_file arm/bpabi.h arm/uclinux-eabi.h"
 	    tmake_file="$tmake_file arm/t-bpabi"
   	    # The BPABI long long divmod functions return a 128-bit value in
@@ -748,6 +771,13 @@ arm*-*-uclinux*)		# ARM ucLinux
 	    need_64bit_hwint=yes
 	    # The EABI requires the use of __cxa_atexit.
 	    default_use_cxa_atexit=yes
+	    if test x$enable_extra_sgxx_multilibs = xyes; then
+		    tmake_file="${tmake_file} arm/t-cs-uclinux-eabi"
+	    elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+		    tmake_file="${tmake_file} arm/t-cs-uclinux-eabi"
+	    fi
+	    tm_file="$tm_file ./sysroot-suffix.h"
+	    tmake_file="$tmake_file t-sysroot-suffix"
 	esac
 	tm_file="$tm_file arm/aout.h arm/arm.h"
 	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
@@ -757,7 +787,7 @@ arm*-*-ecos-elf)
 	tmake_file="arm/t-arm arm/t-arm-elf"
 	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
 	;;
-arm*-*-eabi* | arm*-*-symbianelf* )
+arm*-*-eabi* | arm*-*-nucleuseabi* | arm*-*-symbianelf* )
 	# The BPABI long long divmod functions return a 128-bit value in
 	# registers r0-r3.  Correctly modeling that requires the use of
 	# TImode.
@@ -766,16 +796,31 @@ arm*-*-eabi* | arm*-*-symbianelf* )
 	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/bpabi.h"
 	tmake_file="arm/t-arm arm/t-arm-elf"
 	case ${target} in
-	arm*-*-eabi*)
+	arm*-*-eabi* | arm*-*-nucleuseabi*)
 	  tm_file="$tm_file arm/eabi.h"
+	  tm_file="${tm_file} arm/nocrt0.h"
+	  case ${target} in
+	    *samsung-nucleuseabi*)
+	      tm_file="$tm_file arm/nucleus.h"
+	      tmake_file="${tmake_file} t-slibgcc-elf-ver t-libc-ok"
+	      tmake_file="${tmake_file} t-libgcc-pic arm/t-nucleus"
+	      tm_defines="${tm_defines} NUCLEUS_SHARED_EXEC=1"
+	      ;;
+	    *nucleuseabi*)
+	      tm_file="$tm_file arm/nucleus.h"
+	      ;;
+	  esac
 	  tmake_file="${tmake_file} arm/t-bpabi"
 	  extra_options="${extra_options} arm/eabi.opt"
+	  if test x$enable_extra_sgxx_multilibs = xyes; then
+		  tmake_file="${tmake_file} arm/t-cs-eabi"
+	  elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+		  tmake_file="${tmake_file} arm/t-cs-eabi-lite"
+	  fi
 	  ;;
 	arm*-*-symbianelf*)
 	  tm_file="${tm_file} arm/symbian.h"
-	  # We do not include t-bpabi for Symbian OS because the system
-	  # provides its own implementation of the BPABI functions.
-	  tmake_file="${tmake_file} arm/t-symbian"
+	  tmake_file="${tmake_file} arm/t-bpabi arm/t-symbian"
 	  ;;
 	esac
 	tm_file="${tm_file} arm/aout.h arm/arm.h"
@@ -906,7 +951,7 @@ hppa*-*-linux*)
 	target_cpu_default="MASK_PA_11|MASK_NO_SPACE_REGS"
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h pa/pa-linux.h \
 		 pa/pa32-regs.h pa/pa32-linux.h"
-	tmake_file="${tmake_file} pa/t-linux"
+	tmake_file="${tmake_file} pa/t-linux t-slibgcc-libgcc"
 	# Set the libgcc version number
 	if test x$sjlj = x1; then
 	    tmake_file="$tmake_file pa/t-slibgcc-sjlj-ver"
@@ -1099,7 +1144,7 @@ i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i
 			tmake_file="${tmake_file} i386/t-linux64"
 			need_64bit_hwint=yes
 			case X"${with_cpu}" in
-			Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)
+			Xgeneric|Xatom|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)
 				;;
 			X)
 				if test x$with_cpu_64 = x; then
@@ -1108,13 +1153,29 @@ i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i
 				;;
 			*)
 				echo "Unsupported CPU used in --with-cpu=$with_cpu, supported values:" 1>&2
-				echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3" 1>&2
+				echo "generic atom core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3" 1>&2
 				exit 1
 				;;
 			esac
 		else
 			tm_file="${tm_file} i386/linux.h"
 		fi
+		case ${target} in
+		*-wrs-linux*)
+			tm_file="$tm_file i386/wrs-linux.h"
+			tmake_file="$tmake_file i386/t-wrs-linux"
+			extra_options="${extra_options} i386/wrs-linux.opt"
+			tm_defines="${tm_defines} TARGET_FLEXLM"
+			;;
+		esac
+		if test x$enable_extra_sgxx_multilibs = xyes; then
+			tm_file="${tm_file} i386/cs-linux.h"
+			tmake_file="${tmake_file} i386/t-cs-linux"
+			extra_options="${extra_options} i386/cs-linux.opt"
+		elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+			tm_file="${tm_file} i386/cs-linux-lite.h"
+			tmake_file="${tmake_file} i386/t-cs-linux-lite"
+		fi
 		;;
 	i[34567]86-*-knetbsd*-gnu) tm_file="${tm_file} i386/linux.h knetbsd-gnu.h i386/knetbsd-gnu.h" ;;
 	i[34567]86-*-kfreebsd*-gnu) tm_file="${tm_file} i386/linux.h kfreebsd-gnu.h i386/kfreebsd-gnu.h" ;;
@@ -1219,7 +1280,7 @@ i[34567]86-*-solaris2*)
 		# libgcc/configure.ac instead.
 		need_64bit_hwint=yes
 		case X"${with_cpu}" in
-		Xgeneric|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)
+		Xgeneric|Xatom|Xcore2|Xnocona|Xx86-64|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)
 			;;
 		X)
 			if test x$with_cpu_64 = x; then
@@ -1228,7 +1289,7 @@ i[34567]86-*-solaris2*)
 			;;
 		*)
 			echo "Unsupported CPU used in --with-cpu=$with_cpu, supported values:" 1>&2
-			echo "generic core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3" 1>&2
+			echo "generic atom core2 nocona x86-64 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3" 1>&2
 			exit 1
 			;;
 		esac
@@ -1276,6 +1337,23 @@ i[34567]86-*-pe | i[34567]86-*-cygwin*)
 		thread_file='posix'
 	fi
 	;;
+arm-*-mingw32*)
+        tm_file="arm/semi.h arm/aout.h ${tm_file} arm/coff.h dbxcoff.h arm/pe.h arm/wince-pe.h arm/mingw32.h"
+        tmake_file="${tmake_file} arm/t-arm arm/t-wince-pe arm/t-cygming arm/t-mingw32"
+        target_gtfiles="\$(srcdir)/config/arm/pe.c"
+        extra_options="${extra_options} arm/pe.opt arm/cygming.opt"
+        extra_objs="pe.o pe-stubs.o"
+        c_target_objs="${c_target_objs} msformat-c.o"
+        cxx_target_objs="pe-cxx.o msformat-c.o"
+        default_use_cxa_atexit=yes
+        case ${enable_threads} in
+          "" | yes | win32)
+          thread_file='win32'
+          tmake_file="${tmake_file} i386/t-gthr-win32"
+          ;;
+        esac
+        tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
+        ;;
 i[34567]86-*-mingw* | x86_64-*-mingw*)
 	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/mingw32.h"
 	xm_file=i386/xm-mingw32.h
@@ -1590,6 +1668,7 @@ mips64*-*-linux* | mipsisa64*-*-linux*)
 			tm_defines="${tm_defines} MIPS_ISA_DEFAULT=65"
 			;;
 	esac
+	tmake_file="$tmake_file mips/t-crtfm"
 	gnu_ld=yes
 	gas=yes
 	test x$with_llsc != x || with_llsc=yes
@@ -1603,8 +1682,28 @@ mips*-*-linux*)				# Linux MIPS, either endian.
                 ;;
         mipsisa32*)
 		tm_defines="${tm_defines} MIPS_ISA_DEFAULT=32"
+		;;
+	mips-wrs-linux-gnu) 
+		tmake_file="$tmake_file mips/t-linux64 mips/t-wrs-linux"
+		tm_file="$tm_file mips/linux64.h mips/octeon.h mips/wrs-linux.h"
+		tm_defines="$tm_defines TARGET_FLEXLM"
+		;;
+	mips-montavista*-linux-gnu)
+		tmake_file="$tmake_file mips/t-linux64 mips/t-montavista-linux"
+		tm_file="$tm_file mips/linux64.h mips/octeon.h mips/montavista-linux.h"
+		;;
+	*)
+		if test x$enable_extra_sgxx_multilibs = xyes; then
+		    tmake_file="$tmake_file mips/t-sgxx-linux"
+		    tm_file="$tm_file mips/cs-sgxx-linux.h"
+		elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+		    tmake_file="$tmake_file mips/t-sgxxlite-linux"
+		    tm_file="$tm_file mips/cs-sgxxlite-linux.h"
+		fi
+		;;
         esac
 	test x$with_llsc != x || with_llsc=yes
+	tmake_file="$tmake_file mips/t-crtfm"
 	;;
 mips*-*-openbsd*)
 	tm_defines="${tm_defines} OBSD_HAS_DECLARE_FUNCTION_NAME OBSD_HAS_DECLARE_OBJECT OBSD_HAS_CORRECT_SPECS"
@@ -1649,6 +1748,25 @@ mips*-sde-elf*)
 	    tm_defines="MIPS_ISA_DEFAULT=64 MIPS_ABI_DEFAULT=ABI_N32"
 	    ;;
 	esac
+	if [ "$enable_sgxx_sde_multilibs" = "yes" ]; then
+	  tm_file="$tm_file mips/sdemtk.h"
+	  extra_options="$extra_options mips/sdemtk.opt"
+	  tmake_file="$tmake_file mips/t-sgxx-sde"
+          # SourceryG++ is configured --with-arch=mips32r2.
+	  tm_defines="MIPS_ISA_DEFAULT=33 MIPS_ABI_DEFAULT=ABI_32"
+	fi
+	;;
+mips64octeon*-wrs-elf*)
+	tm_file="elfos.h ${tm_file} mips/elf.h mips/octeon.h mips/octeon-elf.h"
+	tmake_file=mips/t-octeon-elf
+	tm_defines="MIPS_ABI_DEFAULT=ABI_EABI MIPS_CPU_STRING_DEFAULT=\\\"octeon\\\" TARGET_FLEXLM"
+	default_use_cxa_atexit=no
+	;;
+mips64octeon*-montavista-elf*)
+	tm_file="elfos.h ${tm_file} mips/elf.h mips/octeon.h mips/octeon-elf.h"
+	tmake_file="mips/t-octeon-elf mips/t-montavista-elf"
+	tm_defines="MIPS_ABI_DEFAULT=ABI_EABI MIPS_CPU_STRING_DEFAULT=\\\"octeon\\\""
+	default_use_cxa_atexit=no
 	;;
 mipsisa32-*-elf* | mipsisa32el-*-elf* | \
 mipsisa32r2-*-elf* | mipsisa32r2el-*-elf* | \
@@ -1762,12 +1880,12 @@ powerpc64-*-linux*)
 		tm_file="rs6000/secureplt.h ${tm_file}"
 	fi
 	extra_options="${extra_options} rs6000/sysv4.opt rs6000/linux64.opt"
-	tmake_file="t-dfprules rs6000/t-fprules ${tmake_file} rs6000/t-ppccomm rs6000/t-linux64 rs6000/t-fprules-softfp soft-fp/t-softfp"
+	tmake_file="t-dfprules rs6000/t-fprules ${tmake_file} rs6000/t-ppccomm rs6000/t-linux64 t-slibgcc-libgcc rs6000/t-fprules-softfp soft-fp/t-softfp"
 	;;
 powerpc64-*-gnu*)
 	tm_file="${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux64.h rs6000/gnu.h"
 	extra_options="${extra_options} rs6000/sysv4.opt rs6000/linux64.opt"
-	tmake_file="rs6000/t-fprules t-slibgcc-elf-ver t-gnu rs6000/t-linux64 rs6000/t-fprules-softfp soft-fp/t-softfp"
+	tmake_file="rs6000/t-fprules t-slibgcc-elf-ver t-slibgcc-libgcc t-gnu rs6000/t-linux64 rs6000/t-fprules-softfp soft-fp/t-softfp"
 	;;
 powerpc-*-darwin*)
 	extra_options="${extra_options} rs6000/darwin.opt"
@@ -1873,7 +1991,7 @@ powerpc-*-linux*)
 		tm_file="${tm_file} rs6000/linux.h"
 		;;
 	esac
-	tmake_file="${tmake_file} rs6000/t-fprules-softfp soft-fp/t-softfp"
+	tmake_file="${tmake_file} t-slibgcc-libgcc rs6000/t-fprules-softfp soft-fp/t-softfp"
 	if test x${enable_secureplt} = xyes; then
 		tm_file="rs6000/secureplt.h ${tm_file}"
 	fi
@@ -1881,14 +1999,14 @@ powerpc-*-linux*)
 powerpc-*-gnu-gnualtivec*)
 	tm_file="${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxaltivec.h rs6000/gnu.h"
 	extra_options="${extra_options} rs6000/sysv4.opt"
-	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos t-slibgcc-elf-ver t-gnu rs6000/t-ppccomm"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos t-slibgcc-elf-ver t-slibgcc-libgcc t-gnu rs6000/t-ppccomm"
 	if test x$enable_threads = xyes; then
 		thread_file='posix'
 	fi
 	;;
 powerpc-*-gnu*)
 	tm_file="${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/gnu.h"
-	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos t-slibgcc-elf-ver t-gnu rs6000/t-ppccomm"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos t-slibgcc-elf-ver t-slibgcc-libgcc t-gnu rs6000/t-ppccomm"
 	extra_options="${extra_options} rs6000/sysv4.opt"
 	if test x$enable_threads = xyes; then
 		thread_file='posix'
@@ -2019,6 +2137,7 @@ score-*-elf)
 sh-*-elf* | sh[12346l]*-*-elf* | \
 sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \
   sh-*-linux* | sh[2346lbe]*-*-linux* | \
+  sh-*-uclinux* | sh[12]-*-uclinux* | \
   sh-*-netbsdelf* | shl*-*-netbsdelf* | sh5-*-netbsd* | sh5l*-*-netbsd* | \
    sh64-*-netbsd* | sh64l*-*-netbsd*)
 	tmake_file="${tmake_file} sh/t-sh sh/t-elf"
@@ -2033,9 +2152,14 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \
 		*)				   with_endian=big,little ;;
 		esac
 	fi
+	# TM_ENDIAN_CONFIG is used by t-sh to determine multilibs.
+	#  First word : the default endian.
+	#  Second word: the secondary endian (optional).
 	case ${with_endian} in
-	big|little)	tmake_file="${tmake_file} sh/t-1e" ;;
-	big,little|little,big) ;;
+	big)		TM_ENDIAN_CONFIG=mb ;;
+	little)		TM_ENDIAN_CONFIG=ml ;;
+	big,little)	TM_ENDIAN_CONFIG="mb ml" ;;
+	little,big)	TM_ENDIAN_CONFIG="ml mb" ;;
 	*)	echo "with_endian=${with_endian} not supported."; exit 1 ;;
 	esac
 	case ${with_endian} in
@@ -2051,6 +2175,13 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \
 	sh*-*-linux*)	tmake_file="${tmake_file} sh/t-linux"
 			tm_file="${tm_file} linux.h sh/linux.h" ;;
 	sh*-*-netbsd*)	tm_file="${tm_file} netbsd.h netbsd-elf.h sh/netbsd-elf.h" ;;
+	sh*-*-uclinux*)	if test x$enable_fdpic != xno; then
+				tmake_file="${tmake_file} t-slibgcc-elf-ver"
+				tm_file="${tm_file} sh/uclinux.h"
+				tm_defines="$tm_defines FDPIC_DEFAULT=1"
+			else
+				tm_file="${tm_file} flat.h sh/uclinux.h"
+			fi ;;
 	sh*-superh-elf)	if test x$with_libgloss != xno; then
 				with_libgloss=yes
 				tm_file="${tm_file} sh/newlib.h"
@@ -2076,6 +2207,7 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \
 	*-*-netbsd)
                 tmake_file="${tmake_file} sh/t-netbsd"
 		;;
+	sh*-*-uclinux*)	tmake_file="${tmake_file} sh/t-uclinux" ;;
 	sh64*-*-linux*)
 		tmake_file="${tmake_file} sh/t-sh64 sh/t-linux64"
 		tm_file="${tm_file} sh/sh64.h"
@@ -2142,7 +2274,7 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \
 	*)	echo "with_cpu=$with_cpu not supported"; exit 1 ;;
 	esac
 	sh_multilibs=${with_multilib_list}
-	if test x${sh_multilibs} = x ; then
+	if test "$sh_multilibs" = "default" ; then
 		case ${target} in
 		sh64-superh-linux* | \
 		sh[1234]*)	sh_multilibs=`cd ${srcdir}/config/sh ; echo t-mlib-sh[1-4]* | sed 's:t-mlib-sh:,m:g;s: ::g'` ;;
@@ -2158,28 +2290,43 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \
 	fi
 	target_cpu_default=SELECT_`echo ${sh_cpu_default}|tr abcdefghijklmnopqrstuvwxyz- ABCDEFGHIJKLMNOPQRSTUVWXYZ_`
 	tm_defines=${tm_defines}' SH_MULTILIB_CPU_DEFAULT=\"'`echo $sh_cpu_default|sed s/sh/m/`'\"'
-	sh_multilibs=`echo $sh_multilibs,$sh_cpu_default | sed -e 's/[ 	,/][ 	,]*/ /g' -e 's/ $//' -e 's/^m/sh/' -e 's/ m/ sh/g' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ_ abcdefghijklmnopqrstuvwxyz-`
+	tm_defines="$tm_defines SUPPORT_`echo $sh_cpu_default | sed 's/^m/sh/' | tr abcdefghijklmnopqrstuvwxyz- ABCDEFGHIJKLMNOPQRSTUVWXYZ_`=1"
+	sh_multilibs=`echo $sh_multilibs | sed -e 's/,/ /g' -e 's/^sh/m/i' -e 's/ sh/ m/gi' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ_ abcdefghijklmnopqrstuvwxyz-`
 	for sh_multilib in ${sh_multilibs}; do
 		case ${sh_multilib} in
-		sh1 | sh2 | sh2e | sh3 | sh3e | \
-		sh4 | sh4-single | sh4-single-only | sh4-nofpu | sh4-300 |\
-		sh4a | sh4a-single | sh4a-single-only | sh4a-nofpu | sh4al | \
-		sh2a | sh2a-single | sh2a-single-only | sh2a-nofpu | \
-		sh5-64media | sh5-64media-nofpu | \
-		sh5-32media | sh5-32media-nofpu | \
-		sh5-compact | sh5-compact-nofpu)
-			tmake_file="${tmake_file} sh/t-mlib-${sh_multilib}"
-			tm_defines="$tm_defines SUPPORT_`echo $sh_multilib|tr abcdefghijklmnopqrstuvwxyz- ABCDEFGHIJKLMNOPQRSTUVWXYZ_`=1"
-			;;
+		m1 | m2 | m2e | m3 | m3e | \
+		m4 | m4-single | m4-single-only | m4-nofpu | m4-300 |\
+		m4a | m4a-single | m4a-single-only | m4a-nofpu | m4al | \
+		m2a | m2a-single | m2a-single-only | m2a-nofpu | \
+		m5-64media | m5-64media-nofpu | \
+		m5-32media | m5-32media-nofpu | \
+		m5-compact | m5-compact-nofpu)
+			# TM_MULTILIB_CONFIG is used by t-sh for the non-endian multilib definition
+			# It is passed to MULTIILIB_OPTIONS verbatim.
+			TM_MULTILIB_CONFIG="${TM_MULTILIB_CONFIG}/${sh_multilib}"
+			tm_defines="$tm_defines SUPPORT_`echo $sh_multilib | sed 's/^m/sh/' | tr abcdefghijklmnopqrstuvwxyz- ABCDEFGHIJKLMNOPQRSTUVWXYZ_`=1"
+			;;
+		\!*)	# TM_MULTILIB_EXCEPTIONS_CONFIG is used by t-sh
+			# It is passed the MULTILIB_EXCEPTIONS verbatim.
+			TM_MULTILIB_EXCEPTIONS_CONFIG="${TM_MULTILIB_EXCEPTIONS_CONFIG} `echo $sh_multilib | sed 's/^!//'`" ;;
 		*)
 			echo "with_multilib_list=${sh_multilib} not supported."
 			exit 1
 			;;
 		esac
 	done
+	TM_MULTILIB_CONFIG=`echo $TM_MULTILIB_CONFIG | sed 's:^/::'`
 	if test x${enable_incomplete_targets} = xyes ; then
 		tm_defines="$tm_defines SUPPORT_SH1=1 SUPPORT_SH2E=1 SUPPORT_SH4=1 SUPPORT_SH4_SINGLE=1 SUPPORT_SH2A=1 SUPPORT_SH2A_SINGLE=1 SUPPORT_SH5_32MEDIA=1 SUPPORT_SH5_32MEDIA_NOFPU=1 SUPPORT_SH5_64MEDIA=1 SUPPORT_SH5_64MEDIA_NOFPU=1"
 	fi
+	if test x$enable_extra_sgxxlite_multilibs = xyes \
+	   || test x$enable_extra_sgxx_multilibs = xyes; then
+		# SG++ and Lite do not differ, as yet, so use the Lite files for both
+		tm_file="$tm_file sh/cs-sgxxlite-linux.h"
+		tmake_file="$tmake_file sh/t-sgxxlite-linux"
+	fi
+	tm_file="$tm_file ./sysroot-suffix.h"
+	tmake_file="$tmake_file t-sysroot-suffix"
 	;;
 sh-*-rtems*)
 	tmake_file="sh/t-sh sh/t-elf t-rtems sh/t-rtems"
@@ -2218,6 +2365,11 @@ sparc-*-linux*)		# SPARC's running GNU/Linux, libc6
 		tm_file="${tm_file} sparc/linux.h"
 	fi
 	tmake_file="${tmake_file} sparc/t-crtfm"
+	case ${target} in
+	sparc-wrs-linux-gnu)
+		tm_defines="$tm_defines BIARCH_32BIT_DEFAULT TARGET_FLEXLM"
+		;;
+	esac
 	;;
 sparc-*-rtems*)
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp-elf.h sparc/rtemself.h rtems.h"
@@ -2686,8 +2838,8 @@ case "${target}" in
 		| armv[23456] | armv2a | armv3m | armv4t | armv5t \
 		| armv5te | armv6j |armv6k | armv6z | armv6zk | armv6-m \
 		| armv7 | armv7-a | armv7-r | armv7-m \
-		| iwmmxt | ep9312)
-			# OK
+		| iwmmxt | ep9312 | marvell-f )
+ 			# OK
 			;;
 		*)
 			echo "Unknown arch used in --with-arch=$with_arch" 1>&2
@@ -2708,7 +2860,10 @@ case "${target}" in
 
 		case "$with_fpu" in
 		"" \
-		| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 | vfpv3 | vfpv3-d16 | neon )
+		| fpa | fpe2 | fpe3 | maverick \
+		| vfp | vfp3 | vfpv3 | vfpv3-fp16 | vfpv3-d16 \
+		| vfpv3-d16-fp16 | vfpv4 | vfpv4-d16 | fpv4-sp-d16 \
+		| neon | neon-fp16 | neon-vfpv4 )
 			# OK
 			;;
 		*)
@@ -2845,7 +3000,7 @@ case "${target}" in
 				esac
 				# OK
 				;;
-			"" | amdfam10 | barcelona | k8-sse3 | opteron-sse3 | athlon64-sse3 | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | generic)
+			"" | amdfam10 | barcelona | k8-sse3 | opteron-sse3 | athlon64-sse3 | k8 | opteron | athlon64 | athlon-fx | nocona | core2 | atom | generic)
 				# OK
 				;;
 			*)
@@ -2857,7 +3012,7 @@ case "${target}" in
 		;;
 
 	mips*-*-*)
-		supported_defaults="abi arch float tune divide llsc mips-plt"
+		supported_defaults="abi arch arch_32 arch_64 float tune tune_32 tune_64 divide llsc mips-plt"
 
 		case ${with_float} in
 		"" | soft | hard)
@@ -3119,10 +3274,16 @@ case ${target} in
 			tm_defines="US_SOFTWARE_GOFAST $tm_defines"
 			tmake_file="mips/t-gofast $tmake_file"
 		else
-			tmake_file="mips/t-mips $tmake_file"
+			case ${target} in
+				mips*-sde-elf*)
+					tmake_file="mips/t-fprules-softfp soft-fp/t-softfp $tmake_file"
+					;;
+				*)
+					tmake_file="mips/t-mips $tmake_file"
+					;;
+			esac
 		fi
 		;;
-
 	powerpc*-*-* | rs6000-*-*)
 		# FIXME: The PowerPC port uses the value set at compile time,
 		# although it's only cosmetic.
@@ -3173,6 +3334,22 @@ case ${target} in
 		;;
 esac
 
+case ${target} in
+    *-eglibc-*-*)
+	tmake_file="${tmake_file} t-eglibc"
+
+	case ${target} in
+	    arm-*)
+	     # ARM already includes below.
+		;;
+	    *)
+		tmake_file="${tmake_file} t-sysroot-suffix"
+		tm_file="${tm_file} ./sysroot-suffix.h"
+		;;
+	esac
+	;;
+esac
+
 t=
 all_defaults="abi cpu cpu_32 cpu_64 arch arch_32 arch_64 tune tune_32 tune_64 schedule float mode fpu divide llsc mips-plt"
 for option in $all_defaults
diff --git a/gcc/config.in b/gcc/config.in
index ea43afbb1..48856bd09 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -101,6 +101,12 @@
 #endif
 
 
+/* Define if gcc should always pass --build-id to linker. */
+#ifndef USED_FOR_TARGET
+#undef ENABLE_LD_BUILDID
+#endif
+
+
 /* Define to 1 if translation of program messages to the user's native
    language is requested. */
 #ifndef USED_FOR_TARGET
@@ -108,6 +114,12 @@
 #endif
 
 
+/* Define to warn for use of native system header directories */
+#ifndef USED_FOR_TARGET
+#undef ENABLE_POISON_SYSTEM_DIRECTORIES
+#endif
+
+
 /* Define if you want all operations on RTL (the basic data structure of the
    optimizer and back end) to be checked for dynamic type safety at runtime.
    This is quite expensive. */
@@ -833,6 +845,13 @@
 #endif
 
 
+/* Define if your assembler supports specifying the alignment of objects
+   allocated using the GAS .comm command. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_GAS_ALIGNED_COMM
+#endif
+
+
 /* Define if your assembler supports .balign and .p2align. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_GAS_BALIGN_AND_P2ALIGN
@@ -1032,6 +1051,12 @@
 #endif
 
 
+/* Define if your linker supports --build-id. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_LD_BUILDID
+#endif
+
+
 /* Define if your linker supports --demangle option. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_LD_DEMANGLE
diff --git a/gcc/config/arm/aout.h b/gcc/config/arm/aout.h
index e9104220f..dc53f32b3 100644
--- a/gcc/config/arm/aout.h
+++ b/gcc/config/arm/aout.h
@@ -163,31 +163,45 @@
   {"mvdx12", 39},				\
   {"mvdx13", 40},				\
   {"mvdx14", 41},				\
-  {"mvdx15", 42},				\
-  {"d0", 63}, {"q0", 63},			\
-  {"d1", 65},					\
-  {"d2", 67}, {"q1", 67},			\
-  {"d3", 69},					\
-  {"d4", 71}, {"q2", 71},			\
-  {"d5", 73},					\
-  {"d6", 75}, {"q3", 75},			\
-  {"d7", 77},					\
-  {"d8", 79}, {"q4", 79},			\
-  {"d9", 81},					\
-  {"d10", 83}, {"q5", 83},			\
-  {"d11", 85},					\
-  {"d12", 87}, {"q6", 87},			\
-  {"d13", 89},					\
-  {"d14", 91}, {"q7", 91},			\
-  {"d15", 93},					\
-  {"q8", 95},					\
-  {"q9", 99},					\
-  {"q10", 103},					\
-  {"q11", 107},					\
-  {"q12", 111},					\
-  {"q13", 115},					\
-  {"q14", 119},					\
-  {"q15", 123}					\
+  {"mvdx15", 42}				\
+}
+#endif
+
+#ifndef OVERLAPPING_REGISTER_NAMES
+#define OVERLAPPING_REGISTER_NAMES		\
+{						\
+  {"d0", 63, 2},				\
+  {"d1", 65, 2},				\
+  {"d2", 67, 2},				\
+  {"d3", 69, 2},				\
+  {"d4", 71, 2},				\
+  {"d5", 73, 2},				\
+  {"d6", 75, 2},				\
+  {"d7", 77, 2},				\
+  {"d8", 79, 2},				\
+  {"d9", 81, 2},				\
+  {"d10", 83, 2},				\
+  {"d11", 85, 2},				\
+  {"d12", 87, 2},				\
+  {"d13", 89, 2},				\
+  {"d14", 91, 2},				\
+  {"d15", 93, 2},				\
+  {"q0", 63, 4},				\
+  {"q1", 67, 4},				\
+  {"q2", 71, 4},				\
+  {"q3", 75, 4},				\
+  {"q4", 79, 4},				\
+  {"q5", 83, 4},				\
+  {"q6", 87, 4},				\
+  {"q7", 91, 4},				\
+  {"q8", 95, 4},				\
+  {"q9", 99, 4},				\
+  {"q10", 103, 4},				\
+  {"q11", 107, 4},				\
+  {"q12", 111, 4},				\
+  {"q13", 115, 4},				\
+  {"q14", 119, 4},				\
+  {"q15", 123, 4}				\
 }
 #endif
 
diff --git a/gcc/config/arm/arm-cores.def b/gcc/config/arm/arm-cores.def
index fba421272..06dd14592 100644
--- a/gcc/config/arm/arm-cores.def
+++ b/gcc/config/arm/arm-cores.def
@@ -104,6 +104,7 @@ ARM_CORE("arm1022e",      arm1022e,	5TE,				 FL_LDSCHED, fastmul)
 ARM_CORE("xscale",        xscale,	5TE,	                         FL_LDSCHED | FL_STRONG | FL_XSCALE, xscale)
 ARM_CORE("iwmmxt",        iwmmxt,	5TE,	                         FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_IWMMXT, xscale)
 ARM_CORE("iwmmxt2",       iwmmxt2,	5TE,	                         FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_IWMMXT, xscale)
+ARM_CORE("marvell-f",	  marvell_f,	5TE,				 FL_LDSCHED | FL_VFPV2 | FL_MARVELL_F, 9e)
 
 /* V5TEJ Architecture Processors */
 ARM_CORE("arm926ej-s",    arm926ejs,	5TEJ,	                         FL_LDSCHED, 9e)
@@ -117,9 +118,14 @@ ARM_CORE("arm1176jzf-s",  arm1176jzfs,	6ZK,				 FL_LDSCHED | FL_VFPV2, 9e)
 ARM_CORE("mpcorenovfp",	  mpcorenovfp,	6K,				 FL_LDSCHED, 9e)
 ARM_CORE("mpcore",	  mpcore,	6K,				 FL_LDSCHED | FL_VFPV2, 9e)
 ARM_CORE("arm1156t2-s",	  arm1156t2s,	6T2,				 FL_LDSCHED, 9e)
+
+/* V7 Architecture Processors */
+ARM_CORE("cortex-a5",	  cortexa5,	7A,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-a8",	  cortexa8,	7A,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-a9",	  cortexa9,	7A,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-r4",	  cortexr4,	7R,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-r4f",	  cortexr4f,	7R,				 FL_LDSCHED, 9e)
+ARM_CORE("cortex-m4",	  cortexm4,	7EM,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-m3",	  cortexm3,	7M,				 FL_LDSCHED, 9e)
 ARM_CORE("cortex-m1",	  cortexm1,	6M,				 FL_LDSCHED, 9e)
+ARM_CORE("cortex-m0",	  cortexm0,	6M,				 FL_LDSCHED, 9e)
diff --git a/gcc/config/arm/arm-modes.def b/gcc/config/arm/arm-modes.def
index 0ff876f62..5d6884afe 100644
--- a/gcc/config/arm/arm-modes.def
+++ b/gcc/config/arm/arm-modes.def
@@ -25,15 +25,26 @@
    FIXME What format is this?  */
 FLOAT_MODE (XF, 12, 0);
 
+/* Half-precision floating point */
+FLOAT_MODE (HF, 2, 0);
+ADJUST_FLOAT_FORMAT (HF, ((arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)
+			  ? &arm_half_format : &ieee_half_format));
+
 /* CCFPEmode should be used with floating inequalities,
    CCFPmode should be used with floating equalities.
    CC_NOOVmode should be used with SImode integer equalities.
    CC_Zmode should be used if only the Z flag is set correctly
    CC_Nmode should be used if only the N (sign) flag is set correctly
+   CC_CZmode should be used if only the C and Z flags are correct
+   (used for DImode unsigned comparisons).
+   CC_NCVmode should be used if only the N, C, and V flags are correct
+   (used for DImode signed comparisons).
    CCmode should be used otherwise.  */
 
 CC_MODE (CC_NOOV);
 CC_MODE (CC_Z);
+CC_MODE (CC_CZ);
+CC_MODE (CC_NCV);
 CC_MODE (CC_SWP);
 CC_MODE (CCFP);
 CC_MODE (CCFPE);
@@ -62,6 +73,4 @@ VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */
 INT_MODE (EI, 24);
 INT_MODE (OI, 32);
 INT_MODE (CI, 48);
-/* ??? This should actually have 512 bits but the precision only has 9
-   bits.  */
-FRACTIONAL_INT_MODE (XI, 511, 64);
+INT_MODE (XI, 64);
diff --git a/gcc/config/arm/arm-protos.h b/gcc/config/arm/arm-protos.h
index 8d03141e4..956339ca9 100644
--- a/gcc/config/arm/arm-protos.h
+++ b/gcc/config/arm/arm-protos.h
@@ -1,6 +1,7 @@
-/* Prototypes for exported functions defined in arm.c and pe.c
-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
-   Free Software Foundation, Inc.
+/* Prototypes for exported functions defined in arm.c, pe.c,
+   pe-cxx and pe-stubs.c.
+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
+   2009 Free Software Foundation, Inc.
    Contributed by Richard Earnshaw (rearnsha@arm.com)
    Minor hacks by Nick Clifton (nickc@cygnus.com)
 
@@ -42,6 +43,8 @@ extern HOST_WIDE_INT thumb_compute_initial_elimination_offset (unsigned int,
 extern unsigned int arm_dbx_register_number (unsigned int);
 extern void arm_output_fn_unwind (FILE *, bool);
   
+extern int arm_major_arch (void);
+extern bool arm_thumb_arch_p (void);
 
 #ifdef RTX_CODE
 extern bool arm_vector_mode_supported_p (enum machine_mode);
@@ -49,8 +52,7 @@ extern int arm_hard_regno_mode_ok (unsigned int, enum machine_mode);
 extern int const_ok_for_arm (HOST_WIDE_INT);
 extern int arm_split_constant (RTX_CODE, enum machine_mode, rtx,
 			       HOST_WIDE_INT, rtx, rtx, int);
-extern RTX_CODE arm_canonicalize_comparison (RTX_CODE, enum machine_mode,
-					     rtx *);
+extern RTX_CODE arm_canonicalize_comparison (RTX_CODE, rtx *, rtx *);
 extern int legitimate_pic_operand_p (rtx);
 extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);
 extern rtx legitimize_tls_address (rtx, rtx);
@@ -72,6 +74,7 @@ extern char *neon_output_logic_immediate (const char *, rtx *,
 					  enum machine_mode, int, int);
 extern void neon_pairwise_reduce (rtx, rtx, enum machine_mode,
 				  rtx (*) (rtx, rtx, rtx));
+extern rtx neon_make_constant (rtx);
 extern void neon_expand_vector_init (rtx, rtx);
 extern void neon_lane_bounds (rtx, HOST_WIDE_INT, HOST_WIDE_INT);
 extern void neon_const_bounds (rtx, HOST_WIDE_INT, HOST_WIDE_INT);
@@ -88,7 +91,7 @@ extern bool arm_cannot_force_const_mem (rtx);
 
 extern int cirrus_memory_offset (rtx);
 extern int arm_coproc_mem_operand (rtx, bool);
-extern int neon_vector_mem_operand (rtx, bool);
+extern int neon_vector_mem_operand (rtx, int);
 extern int neon_struct_mem_operand (rtx);
 extern int arm_no_early_store_addr_dep (rtx, rtx);
 extern int arm_no_early_alu_shift_dep (rtx, rtx);
@@ -119,6 +122,7 @@ extern void arm_reload_in_hi (rtx *);
 extern void arm_reload_out_hi (rtx *);
 extern int arm_const_double_inline_cost (rtx);
 extern bool arm_const_double_by_parts (rtx);
+extern bool arm_const_double_by_immediates (rtx);
 extern const char *fp_immediate_constant (rtx);
 extern void arm_emit_call_insn (rtx, rtx);
 extern const char *output_call (rtx *);
@@ -133,6 +137,7 @@ extern const char *output_move_double (rtx *);
 extern const char *output_move_quad (rtx *);
 extern const char *output_move_vfp (rtx *operands);
 extern const char *output_move_neon (rtx *operands);
+extern int arm_attr_length_move_neon (rtx);
 extern const char *output_add_immediate (rtx *);
 extern const char *arithmetic_instr (rtx, int);
 extern void output_ascii_pseudo_op (FILE *, const unsigned char *, int);
@@ -144,6 +149,7 @@ extern void arm_final_prescan_insn (rtx);
 extern int arm_debugger_arg_offset (int, rtx);
 extern bool arm_is_long_call_p (tree);
 extern int    arm_emit_vector_const (FILE *, rtx);
+extern void arm_emit_fp16_const (rtx c);
 extern const char * arm_output_load_gr (rtx *);
 extern const char *vfp_output_fstmd (rtx *);
 extern void arm_set_return_address (rtx, rtx);
@@ -154,13 +160,15 @@ extern bool arm_output_addr_const_extra (FILE *, rtx);
 
 #if defined TREE_CODE
 extern rtx arm_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);
+extern void arm_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,
+				      tree, bool);
 extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);
 extern bool arm_pad_arg_upward (enum machine_mode, const_tree);
 extern bool arm_pad_reg_upward (enum machine_mode, tree, int);
 extern bool arm_needs_doubleword_align (enum machine_mode, tree);
-extern rtx arm_function_value(const_tree, const_tree);
 #endif
 extern int arm_apply_result_size (void);
+extern rtx aapcs_libcall_value (enum machine_mode);
 
 #endif /* RTX_CODE */
 
@@ -193,6 +201,11 @@ extern const char *thumb2_output_casesi(rtx *);
 extern int arm_dllexport_name_p (const char *);
 extern int arm_dllimport_name_p (const char *);
 
+/* In pe-cxx.c and pe-stubs.c  */
+extern void arm_pe_adjust_class_at_definition (tree);
+extern bool arm_pe_type_dllimport_p (tree);
+extern bool arm_pe_type_dllexport_p (tree);
+
 #ifdef TREE_CODE
 extern void arm_pe_unique_section (tree, int);
 extern void arm_pe_encode_section_info (tree, rtx, int);
diff --git a/gcc/config/arm/arm-tune.md b/gcc/config/arm/arm-tune.md
index ea728dcb6..0d6f023f1 100644
--- a/gcc/config/arm/arm-tune.md
+++ b/gcc/config/arm/arm-tune.md
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from arm-cores.def
 (define_attr "tune"
-	"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,iwmmxt2,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2s,cortexa8,cortexa9,cortexr4,cortexr4f,cortexm3,cortexm1"
+	"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,iwmmxt2,marvell_f,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2s,cortexa5,cortexa8,cortexa9,cortexr4,cortexr4f,cortexm4,cortexm3,cortexm1,cortexm0"
 	(const (symbol_ref "arm_tune")))
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index eed5cfd1d..5c7f3fe12 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -43,6 +43,7 @@
 #include "optabs.h"
 #include "toplev.h"
 #include "recog.h"
+#include "cgraph.h"
 #include "ggc.h"
 #include "except.h"
 #include "c-pragma.h"
@@ -53,6 +54,8 @@
 #include "debug.h"
 #include "langhooks.h"
 #include "df.h"
+#include "intl.h"
+#include "params.h"
 #include "libfuncs.h"
 
 /* Forward definitions of types.  */
@@ -111,6 +114,7 @@ static unsigned long arm_compute_save_reg_mask (void);
 static unsigned long arm_isr_value (tree);
 static unsigned long arm_compute_func_type (void);
 static tree arm_handle_fndecl_attribute (tree *, tree, tree, int, bool *);
+static tree arm_handle_pcs_attribute (tree *, tree, tree, int, bool *);
 static tree arm_handle_isr_attribute (tree *, tree, tree, int, bool *);
 #if TARGET_DLLIMPORT_DECL_ATTRIBUTES
 static tree arm_handle_notshared_attribute (tree *, tree, tree, int, bool *);
@@ -124,11 +128,16 @@ static int arm_adjust_cost (rtx, rtx, rtx, int);
 static int count_insns_for_constant (HOST_WIDE_INT, int);
 static int arm_get_strip_length (int);
 static bool arm_function_ok_for_sibcall (tree, tree);
+static bool arm_return_in_memory (const_tree, const_tree);
+static rtx arm_function_value (const_tree, const_tree, bool);
+static rtx arm_libcall_value (enum machine_mode, rtx);
+
 static void arm_internal_label (FILE *, const char *, unsigned long);
 static void arm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,
 				 tree);
 static bool arm_rtx_costs_1 (rtx, enum rtx_code, int*, bool);
 static bool arm_size_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *);
+static bool thumb2_size_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *);
 static bool arm_slowmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);
 static bool arm_fastmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);
 static bool arm_xscale_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);
@@ -149,6 +158,9 @@ static void emit_constant_insn (rtx cond, rtx pattern);
 static rtx emit_set_insn (rtx, rtx);
 static int arm_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,
 				  tree, bool);
+static rtx aapcs_allocate_return_reg (enum machine_mode, const_tree,
+				      const_tree);
+static int aapcs_select_return_coproc (const_tree, const_tree);
 
 #ifdef OBJECT_FORMAT_ELF
 static void arm_elf_asm_constructor (rtx, int) ATTRIBUTE_UNUSED;
@@ -176,6 +188,7 @@ static void arm_unwind_emit (FILE *, rtx);
 static bool arm_output_ttype (rtx);
 #endif
 static void arm_dwarf_handle_frame_unspec (const char *, rtx, int);
+static rtx arm_dwarf_register_span(rtx);
 
 static tree arm_cxx_guard_type (void);
 static bool arm_cxx_guard_mask_bit (void);
@@ -198,6 +211,15 @@ static bool arm_tls_symbol_p (rtx x);
 static int arm_issue_rate (void);
 static void arm_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;
 static bool arm_allocate_stack_slots_for_args (void);
+static bool arm_warn_func_result (void);
+static int arm_multipass_dfa_lookahead (void);
+static const char *arm_invalid_parameter_type (const_tree t);
+static const char *arm_invalid_return_type (const_tree t);
+static tree arm_promoted_type (const_tree t);
+static tree arm_convert_to_type (tree type, tree expr);
+static bool arm_scalar_mode_supported_p (enum machine_mode);
+static int arm_vector_min_alignment (const_tree type);
+static bool arm_vector_always_misalign(const_tree);
 
 
 /* Initialize the GCC target structure.  */
@@ -219,6 +241,17 @@ static bool arm_allocate_stack_slots_for_args (void);
 #undef  TARGET_ASM_INTEGER
 #define TARGET_ASM_INTEGER arm_assemble_integer
 
+#ifdef ARM_PE
+#undef  TARGET_ASM_UNALIGNED_HI_OP
+#define TARGET_ASM_UNALIGNED_HI_OP "\t.2byte\t"
+#undef  TARGET_ASM_UNALIGNED_SI_OP
+#define TARGET_ASM_UNALIGNED_SI_OP "\t.4byte\t"
+#undef  TARGET_ASM_UNALIGNED_DI_OP
+#define TARGET_ASM_UNALIGNED_DI_OP "\t.8byte\t"
+#undef  TARGET_ASM_UNALIGNED_TI_OP
+#define TARGET_ASM_UNALIGNED_TI_OP NULL
+#endif
+
 #undef  TARGET_ASM_FUNCTION_PROLOGUE
 #define TARGET_ASM_FUNCTION_PROLOGUE arm_output_function_prologue
 
@@ -257,6 +290,12 @@ static bool arm_allocate_stack_slots_for_args (void);
 #undef  TARGET_FUNCTION_OK_FOR_SIBCALL
 #define TARGET_FUNCTION_OK_FOR_SIBCALL arm_function_ok_for_sibcall
 
+#undef  TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE arm_function_value
+
+#undef  TARGET_LIBCALL_VALUE
+#define TARGET_LIBCALL_VALUE arm_libcall_value
+
 #undef  TARGET_ASM_OUTPUT_MI_THUNK
 #define TARGET_ASM_OUTPUT_MI_THUNK arm_output_mi_thunk
 #undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK
@@ -300,6 +339,9 @@ static bool arm_allocate_stack_slots_for_args (void);
 #undef TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS
 #define TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS arm_allocate_stack_slots_for_args
 
+#undef TARGET_WARN_FUNC_RESULT
+#define TARGET_WARN_FUNC_RESULT arm_warn_func_result
+
 #undef TARGET_DEFAULT_SHORT_ENUMS
 #define TARGET_DEFAULT_SHORT_ENUMS arm_default_short_enums
 
@@ -354,6 +396,9 @@ static bool arm_allocate_stack_slots_for_args (void);
 #undef TARGET_ASM_TTYPE
 #define TARGET_ASM_TTYPE arm_output_ttype
 
+#undef TARGET_CXX_TTYPE_REF_ENCODE
+#define TARGET_CXX_TTYPE_REF_ENCODE hook_cxx_ttype_ref_in_bit0
+
 #undef TARGET_ARM_EABI_UNWINDER
 #define TARGET_ARM_EABI_UNWINDER true
 #endif /* TARGET_UNWIND_INFO */
@@ -361,6 +406,9 @@ static bool arm_allocate_stack_slots_for_args (void);
 #undef TARGET_DWARF_HANDLE_FRAME_UNSPEC
 #define TARGET_DWARF_HANDLE_FRAME_UNSPEC arm_dwarf_handle_frame_unspec
 
+#undef TARGET_DWARF_REGISTER_SPAN
+#define TARGET_DWARF_REGISTER_SPAN arm_dwarf_register_span
+
 #undef  TARGET_CANNOT_COPY_INSN_P
 #define TARGET_CANNOT_COPY_INSN_P arm_cannot_copy_insn_p
 
@@ -399,6 +447,30 @@ static bool arm_allocate_stack_slots_for_args (void);
 #define TARGET_ASM_OUTPUT_DWARF_DTPREL arm_output_dwarf_dtprel
 #endif
 
+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD arm_multipass_dfa_lookahead
+
+#undef TARGET_INVALID_PARAMETER_TYPE
+#define TARGET_INVALID_PARAMETER_TYPE arm_invalid_parameter_type
+
+#undef TARGET_INVALID_RETURN_TYPE
+#define TARGET_INVALID_RETURN_TYPE arm_invalid_return_type
+
+#undef TARGET_PROMOTED_TYPE
+#define TARGET_PROMOTED_TYPE arm_promoted_type
+
+#undef TARGET_CONVERT_TO_TYPE
+#define TARGET_CONVERT_TO_TYPE arm_convert_to_type
+
+#undef TARGET_SCALAR_MODE_SUPPORTED_P
+#define TARGET_SCALAR_MODE_SUPPORTED_P arm_scalar_mode_supported_p
+
+#undef TARGET_VECTOR_MIN_ALIGNMENT
+#define TARGET_VECTOR_MIN_ALIGNMENT arm_vector_min_alignment
+
+#undef TARGET_VECTOR_ALWAYS_MISALIGN
+#define TARGET_VECTOR_ALWAYS_MISALIGN arm_vector_always_misalign
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 /* Obstack for minipool constant handling.  */
@@ -424,18 +496,18 @@ enum processor_type arm_tune = arm_none;
 /* The default processor used if not overridden by commandline.  */
 static enum processor_type arm_default_cpu = arm_none;
 
-/* Which floating point model to use.  */
-enum arm_fp_model arm_fp_model;
-
-/* Which floating point hardware is available.  */
-enum fputype arm_fpu_arch;
-
 /* Which floating point hardware to schedule for.  */
-enum fputype arm_fpu_tune;
+int arm_fpu_attr;
+
+/* Which floating popint hardware to use.  */
+const struct arm_fpu_desc *arm_fpu_desc;
 
 /* Whether to use floating point hardware.  */
 enum float_abi_type arm_float_abi;
 
+/* Which __fp16 format to use.  */
+enum arm_fp16_format_type arm_fp16_format;
+
 /* Which ABI to use.  */
 enum arm_abi_type arm_abi;
 
@@ -474,9 +546,19 @@ static int thumb_call_reg_needed;
 #define FL_DIV	      (1 << 18)	      /* Hardware divide.  */
 #define FL_VFPV3      (1 << 19)       /* Vector Floating Point V3.  */
 #define FL_NEON       (1 << 20)       /* Neon instructions.  */
+#define FL_MARVELL_F  (1 << 21)       /* Marvell Feroceon.  */
+#define FL_ARCH7EM    (1 << 22)	      /* Instructions present in ARMv7E-M.  */
 
 #define FL_IWMMXT     (1 << 29)	      /* XScale v2 or "Intel Wireless MMX technology".  */
 
+/* Some flags are ignored when comparing -mcpu and -march:
+    FL_MARVELL_F so that -mcpu=marvell-f -march=v5te works.
+    FL_LDSCHED and FL_WBUF only effect tuning,
+    FL_CO_PROC, FL_VFPV2, FL_VFPV3 and FL_NEON because FP
+      coprocessors are handled separately.  */
+#define FL_COMPAT (FL_MARVELL_F | FL_LDSCHED | FL_WBUF | FL_CO_PROC | \
+		   FL_VFPV2 | FL_VFPV3 | FL_NEON)
+
 #define FL_FOR_ARCH2	FL_NOTM
 #define FL_FOR_ARCH3	(FL_FOR_ARCH2 | FL_MODE32)
 #define FL_FOR_ARCH3M	(FL_FOR_ARCH3 | FL_ARCH3M)
@@ -498,6 +580,7 @@ static int thumb_call_reg_needed;
 #define FL_FOR_ARCH7A	(FL_FOR_ARCH7 | FL_NOTM)
 #define FL_FOR_ARCH7R	(FL_FOR_ARCH7A | FL_DIV)
 #define FL_FOR_ARCH7M	(FL_FOR_ARCH7 | FL_DIV)
+#define FL_FOR_ARCH7EM  (FL_FOR_ARCH7M | FL_ARCH7EM)
 
 /* The bits in this mask specify which
    instructions we are allowed to generate.  */
@@ -534,6 +617,9 @@ int arm_arch6k = 0;
 /* Nonzero if instructions not present in the 'M' profile can be used.  */
 int arm_arch_notm = 0;
 
+/* Nonzero if instructions present in ARMv7E-M can be used.  */
+int arm_arch7em = 0;
+
 /* Nonzero if this chip can benefit from load scheduling.  */
 int arm_ld_sched = 0;
 
@@ -552,6 +638,9 @@ int arm_arch_xscale = 0;
 /* Nonzero if tuning for XScale  */
 int arm_tune_xscale = 0;
 
+/* Nonzero if tuning for Marvell Feroceon.  */
+int arm_tune_marvell_f = 0;
+
 /* Nonzero if we want to tune for stores that access the write-buffer.
    This typically means an ARM6 or ARM7 with MMU or MPU.  */
 int arm_tune_wbuf = 0;
@@ -562,6 +651,9 @@ int arm_tune_cortex_a9 = 0;
 /* Nonzero if generating Thumb instructions.  */
 int thumb_code = 0;
 
+/* Nonzero if generating code for Janus2. */
+int janus2_code = 0;
+
 /* Nonzero if we should define __THUMB_INTERWORK__ in the
    preprocessor.
    XXX This is a bit of a hack, it's intended to help work around
@@ -594,6 +686,8 @@ static int after_arm_reorg = 0;
 /* The maximum number of insns to be used when loading a constant.  */
 static int arm_constant_limit = 3;
 
+enum arm_pcs arm_pcs_default;
+
 /* For an explanation of these variables, see final_prescan_insn below.  */
 int arm_ccfsm_state;
 /* arm_current_cc is also used for Thumb-2 cond_exec blocks.  */
@@ -674,9 +768,11 @@ static const struct processors all_architectures[] =
   {"armv7-a", cortexa8,	  "7A",	 FL_CO_PROC |		  FL_FOR_ARCH7A, NULL},
   {"armv7-r", cortexr4,	  "7R",	 FL_CO_PROC |		  FL_FOR_ARCH7R, NULL},
   {"armv7-m", cortexm3,	  "7M",	 FL_CO_PROC |		  FL_FOR_ARCH7M, NULL},
+  {"armv7e-m", cortexm4,  "7EM", FL_CO_PROC |		  FL_FOR_ARCH7EM, NULL},
   {"ep9312",  ep9312,     "4T",  FL_LDSCHED | FL_CIRRUS | FL_FOR_ARCH4, NULL},
   {"iwmmxt",  iwmmxt,     "5TE", FL_LDSCHED | FL_STRONG | FL_FOR_ARCH5TE | FL_XSCALE | FL_IWMMXT , NULL},
   {"iwmmxt2", iwmmxt2,     "5TE", FL_LDSCHED | FL_STRONG | FL_FOR_ARCH5TE | FL_XSCALE | FL_IWMMXT , NULL},
+  {"marvell-f", marvell_f, "5TE", FL_CO_PROC | FL_FOR_ARCH5TE | FL_MARVELL_F, NULL},
   {NULL, arm_none, NULL, 0 , NULL}
 };
 
@@ -706,49 +802,34 @@ static struct arm_cpu_select arm_select[] =
 
 /* The name of the preprocessor macro to define for this architecture.  */
 
-char arm_arch_name[] = "__ARM_ARCH_0UNK__";
-
-struct fpu_desc
-{
-  const char * name;
-  enum fputype fpu;
-};
-
+#define ARM_ARCH_NAME_SIZE 25
+char arm_arch_name[ARM_ARCH_NAME_SIZE] = "__ARM_ARCH_0UNK__";
 
 /* Available values for -mfpu=.  */
 
-static const struct fpu_desc all_fpus[] =
-{
-  {"fpa",	FPUTYPE_FPA},
-  {"fpe2",	FPUTYPE_FPA_EMU2},
-  {"fpe3",	FPUTYPE_FPA_EMU2},
-  {"maverick",	FPUTYPE_MAVERICK},
-  {"vfp",	FPUTYPE_VFP},
-  {"vfp3",	FPUTYPE_VFP3},
-  {"vfpv3",	FPUTYPE_VFP3},
-  {"vfpv3-d16",	FPUTYPE_VFP3D16},
-  {"neon",	FPUTYPE_NEON}
+static const struct arm_fpu_desc all_fpus[] =
+{
+  {"fpa",		ARM_FP_MODEL_FPA, 0, 0, false, false},
+  {"fpe2",		ARM_FP_MODEL_FPA, 2, 0, false, false},
+  {"fpe3",		ARM_FP_MODEL_FPA, 3, 0, false, false},
+  {"maverick",		ARM_FP_MODEL_MAVERICK, 0, 0, false, false},
+  {"vfp",		ARM_FP_MODEL_VFP, 2, VFP_REG_D16, false, false},
+  {"vfpv3",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, false},
+  {"vfpv3-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, true },
+  {"vfpv3-d16",		ARM_FP_MODEL_VFP, 3, VFP_REG_D16, false, false},
+  {"vfpv3xd",		ARM_FP_MODEL_VFP, 3, VFP_REG_SINGLE, false, false},
+  {"vfpv3xd-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_SINGLE, false, true },
+  {"vfpv3-d16-fp16",	ARM_FP_MODEL_VFP, 3, VFP_REG_D16, false, true },
+  {"neon",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, true , false},
+  {"neon-fp16",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, true , true },
+  {"vfpv4",		ARM_FP_MODEL_VFP, 4, VFP_REG_D32, false, true },
+  {"vfpv4-d16",		ARM_FP_MODEL_VFP, 4, VFP_REG_D16, false, true },
+  {"fpv4-sp-d16",	ARM_FP_MODEL_VFP, 4, VFP_REG_SINGLE, false, true },
+  {"neon-vfpv4",	ARM_FP_MODEL_VFP, 4, VFP_REG_D32, true , true },
+  /* Compatibility aliases.  */
+  {"vfp3",		ARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, false},
 };
 
-
-/* Floating point models used by the different hardware.
-   See fputype in arm.h.  */
-
-static const enum fputype fp_model_for_fpu[] =
-{
-  /* No FP hardware.  */
-  ARM_FP_MODEL_UNKNOWN,		/* FPUTYPE_NONE  */
-  ARM_FP_MODEL_FPA,		/* FPUTYPE_FPA  */
-  ARM_FP_MODEL_FPA,		/* FPUTYPE_FPA_EMU2  */
-  ARM_FP_MODEL_FPA,		/* FPUTYPE_FPA_EMU3  */
-  ARM_FP_MODEL_MAVERICK,	/* FPUTYPE_MAVERICK  */
-  ARM_FP_MODEL_VFP,		/* FPUTYPE_VFP  */
-  ARM_FP_MODEL_VFP,		/* FPUTYPE_VFP3D16  */
-  ARM_FP_MODEL_VFP,		/* FPUTYPE_VFP3  */
-  ARM_FP_MODEL_VFP		/* FPUTYPE_NEON  */
-};
-
-
 struct float_abi
 {
   const char * name;
@@ -766,6 +847,23 @@ static const struct float_abi all_float_abis[] =
 };
 
 
+struct fp16_format
+{
+  const char *name;
+  enum arm_fp16_format_type fp16_format_type;
+};
+
+
+/* Available values for -mfp16-format=.  */
+
+static const struct fp16_format all_fp16_formats[] =
+{
+  {"none",		ARM_FP16_FORMAT_NONE},
+  {"ieee",		ARM_FP16_FORMAT_IEEE},
+  {"alternative",	ARM_FP16_FORMAT_ALTERNATIVE}
+};
+
+
 struct abi_name
 {
   const char *name;
@@ -924,6 +1022,44 @@ arm_init_libfuncs (void)
   set_optab_libfunc (smod_optab, SImode, NULL);
   set_optab_libfunc (umod_optab, SImode, NULL);
 
+  /* Half-precision float operations.  The compiler handles all operations
+     with NULL libfuncs by converting the SFmode.  */
+  switch (arm_fp16_format)
+    {
+    case ARM_FP16_FORMAT_IEEE:
+    case ARM_FP16_FORMAT_ALTERNATIVE:
+
+      /* Conversions.  */
+      set_conv_libfunc (trunc_optab, HFmode, SFmode,
+			(arm_fp16_format == ARM_FP16_FORMAT_IEEE
+			 ? "__aeabi_f2h"
+			 : "__aeabi_f2h_alt"));
+      set_conv_libfunc (sext_optab, SFmode, HFmode, 
+			(arm_fp16_format == ARM_FP16_FORMAT_IEEE
+			 ? "__aeabi_h2f"
+			 : "__aeabi_h2f_alt"));
+      
+      /* Arithmetic.  */
+      set_optab_libfunc (add_optab, HFmode, NULL);
+      set_optab_libfunc (sdiv_optab, HFmode, NULL);
+      set_optab_libfunc (smul_optab, HFmode, NULL);
+      set_optab_libfunc (neg_optab, HFmode, NULL);
+      set_optab_libfunc (sub_optab, HFmode, NULL);
+
+      /* Comparisons.  */
+      set_optab_libfunc (eq_optab, HFmode, NULL);
+      set_optab_libfunc (ne_optab, HFmode, NULL);
+      set_optab_libfunc (lt_optab, HFmode, NULL);
+      set_optab_libfunc (le_optab, HFmode, NULL);
+      set_optab_libfunc (ge_optab, HFmode, NULL);
+      set_optab_libfunc (gt_optab, HFmode, NULL);
+      set_optab_libfunc (unord_optab, HFmode, NULL);
+      break;
+
+    default:
+      break;
+    }
+
   if (TARGET_AAPCS_BASED)
     synchronize_libfunc = init_one_libfunc ("__sync_synchronize");
 }
@@ -1140,6 +1276,7 @@ void
 arm_override_options (void)
 {
   unsigned i;
+  int len;
   enum processor_type target_arch_cpu = arm_none;
   enum processor_type selected_cpu = arm_none;
 
@@ -1157,7 +1294,11 @@ arm_override_options (void)
               {
 		/* Set the architecture define.  */
 		if (i != ARM_OPT_SET_TUNE)
-		  sprintf (arm_arch_name, "__ARM_ARCH_%s__", sel->arch);
+		  {
+		    len = snprintf (arm_arch_name, ARM_ARCH_NAME_SIZE,
+				    "__ARM_ARCH_%s__", sel->arch);
+		    gcc_assert (len < ARM_ARCH_NAME_SIZE);
+		  }
 
 		/* Determine the processor core for which we should
 		   tune code-generation.  */
@@ -1183,8 +1324,8 @@ arm_override_options (void)
 		       make sure that they are compatible.  We only generate
 		       a warning though, and we prefer the CPU over the
 		       architecture.  */
-		    if (insn_flags != 0 && (insn_flags ^ sel->flags))
-		      warning (0, "switch -mcpu=%s conflicts with -march= switch",
+		    if (insn_flags != 0 && ((insn_flags ^ sel->flags) & ~FL_COMPAT))
+		      warning (0, "switch -mcpu=%s conflicts with -march= switch, assuming CPU feature set",
 			       ptr->string);
 
 		    insn_flags = sel->flags;
@@ -1284,7 +1425,11 @@ arm_override_options (void)
 
 	  insn_flags = sel->flags;
 	}
-      sprintf (arm_arch_name, "__ARM_ARCH_%s__", sel->arch);
+
+      len = snprintf (arm_arch_name, ARM_ARCH_NAME_SIZE,
+		      "__ARM_ARCH_%s__", sel->arch);
+      gcc_assert (len < ARM_ARCH_NAME_SIZE);
+
       arm_default_cpu = (enum processor_type) (sel - all_cores);
       if (arm_tune == arm_none)
 	arm_tune = arm_default_cpu;
@@ -1294,8 +1439,35 @@ arm_override_options (void)
      chosen.  */
   gcc_assert (arm_tune != arm_none);
 
+  if (arm_tune == cortexa8 && optimize >= 3)
+    {
+      /* These alignments were experimentally determined to improve SPECint
+	 performance on SPECCPU 2000.  */
+      if (align_functions <= 0)
+	align_functions = 16;
+      if (align_jumps <= 0)
+	align_jumps = 16;
+    }
+
   tune_flags = all_cores[(int)arm_tune].flags;
 
+  if (target_fp16_format_name)
+    {
+      for (i = 0; i < ARRAY_SIZE (all_fp16_formats); i++)
+	{
+	  if (streq (all_fp16_formats[i].name, target_fp16_format_name))
+	    {
+	      arm_fp16_format = all_fp16_formats[i].fp16_format_type;
+	      break;
+	    }
+	}
+      if (i == ARRAY_SIZE (all_fp16_formats))
+	error ("invalid __fp16 format option: -mfp16-format=%s",
+	       target_fp16_format_name);
+    }
+  else
+    arm_fp16_format = ARM_FP16_FORMAT_NONE;
+
   if (target_abi_name)
     {
       for (i = 0; i < ARRAY_SIZE (arm_all_abis); i++)
@@ -1388,6 +1560,7 @@ arm_override_options (void)
   arm_arch6 = (insn_flags & FL_ARCH6) != 0;
   arm_arch6k = (insn_flags & FL_ARCH6K) != 0;
   arm_arch_notm = (insn_flags & FL_NOTM) != 0;
+  arm_arch7em = (insn_flags & FL_ARCH7EM) != 0;
   arm_arch_thumb2 = (insn_flags & FL_THUMB2) != 0;
   arm_arch_xscale = (insn_flags & FL_XSCALE) != 0;
   arm_arch_cirrus = (insn_flags & FL_CIRRUS) != 0;
@@ -1395,12 +1568,25 @@ arm_override_options (void)
   arm_ld_sched = (tune_flags & FL_LDSCHED) != 0;
   arm_tune_strongarm = (tune_flags & FL_STRONG) != 0;
   thumb_code = (TARGET_ARM == 0);
+  janus2_code = (TARGET_FIX_JANUS != 0);
+  if (janus2_code && TARGET_THUMB2)
+    error ("janus2 fix is not applicable when targeting a thumb2 core");
   arm_tune_wbuf = (tune_flags & FL_WBUF) != 0;
   arm_tune_xscale = (tune_flags & FL_XSCALE) != 0;
+  arm_tune_marvell_f = (tune_flags & FL_MARVELL_F) != 0;
   arm_arch_iwmmxt = (insn_flags & FL_IWMMXT) != 0;
-  arm_arch_hwdiv = (insn_flags & FL_DIV) != 0;
   arm_tune_cortex_a9 = (arm_tune == cortexa9) != 0;
 
+ /* Hardware integer division is supported by some variants of the ARM
+    architecture in Thumb-2 mode.  In addition some (but not all) Marvell
+    CPUs support their own hardware integer division instructions.
+    The assembler will pick the correct encoding.  */
+  if (TARGET_MARVELL_DIV && (insn_flags & FL_MARVELL_F) == 0)
+    error ("-mmarvell-div is only supported when targeting a Marvell core");
+
+  arm_arch_hwdiv = (TARGET_ARM && TARGET_MARVELL_DIV)
+		   || (TARGET_THUMB2 && (insn_flags & FL_DIV) != 0);
+
   /* If we are not using the default (ARM mode) section anchor offset
      ranges, then set the correct ranges now.  */
   if (TARGET_THUMB1)
@@ -1439,7 +1625,6 @@ arm_override_options (void)
   if (TARGET_IWMMXT_ABI && !TARGET_IWMMXT)
     error ("iwmmxt abi requires an iwmmxt capable cpu");
 
-  arm_fp_model = ARM_FP_MODEL_UNKNOWN;
   if (target_fpu_name == NULL && target_fpe_name != NULL)
     {
       if (streq (target_fpe_name, "2"))
@@ -1450,46 +1635,52 @@ arm_override_options (void)
 	error ("invalid floating point emulation option: -mfpe=%s",
 	       target_fpe_name);
     }
-  if (target_fpu_name != NULL)
-    {
-      /* The user specified a FPU.  */
-      for (i = 0; i < ARRAY_SIZE (all_fpus); i++)
-	{
-	  if (streq (all_fpus[i].name, target_fpu_name))
-	    {
-	      arm_fpu_arch = all_fpus[i].fpu;
-	      arm_fpu_tune = arm_fpu_arch;
-	      arm_fp_model = fp_model_for_fpu[arm_fpu_arch];
-	      break;
-	    }
-	}
-      if (arm_fp_model == ARM_FP_MODEL_UNKNOWN)
-	error ("invalid floating point option: -mfpu=%s", target_fpu_name);
-    }
-  else
+
+  if (target_fpu_name == NULL)
     {
 #ifdef FPUTYPE_DEFAULT
-      /* Use the default if it is specified for this platform.  */
-      arm_fpu_arch = FPUTYPE_DEFAULT;
-      arm_fpu_tune = FPUTYPE_DEFAULT;
+      target_fpu_name = FPUTYPE_DEFAULT;
 #else
-      /* Pick one based on CPU type.  */
-      /* ??? Some targets assume FPA is the default.
-      if ((insn_flags & FL_VFP) != 0)
-	arm_fpu_arch = FPUTYPE_VFP;
-      else
-      */
       if (arm_arch_cirrus)
-	arm_fpu_arch = FPUTYPE_MAVERICK;
+	target_fpu_name = "maverick";
       else
-	arm_fpu_arch = FPUTYPE_FPA_EMU2;
+	target_fpu_name = "fpe2";
 #endif
-      if (tune_flags & FL_CO_PROC && arm_fpu_arch == FPUTYPE_FPA_EMU2)
-	arm_fpu_tune = FPUTYPE_FPA;
+    }
+
+  arm_fpu_desc = NULL;
+  for (i = 0; i < ARRAY_SIZE (all_fpus); i++)
+    {
+      if (streq (all_fpus[i].name, target_fpu_name))
+	{
+	  arm_fpu_desc = &all_fpus[i];
+	  break;
+	}
+    }
+  if (!arm_fpu_desc)
+    error ("invalid floating point option: -mfpu=%s", target_fpu_name);
+
+  switch (arm_fpu_desc->model)
+    {
+    case ARM_FP_MODEL_FPA:
+      if (arm_fpu_desc->rev == 2)
+	arm_fpu_attr = FPU_FPE2;
+      else if (arm_fpu_desc->rev == 3)
+	arm_fpu_attr = FPU_FPE3;
       else
-	arm_fpu_tune = arm_fpu_arch;
-      arm_fp_model = fp_model_for_fpu[arm_fpu_arch];
-      gcc_assert (arm_fp_model != ARM_FP_MODEL_UNKNOWN);
+	arm_fpu_attr = FPU_FPA;
+      break;
+
+    case ARM_FP_MODEL_MAVERICK:
+      arm_fpu_attr = FPU_MAVERICK;
+      break;
+
+    case ARM_FP_MODEL_VFP:
+      arm_fpu_attr = FPU_VFP;
+      break;
+
+    default:
+      gcc_unreachable();
     }
 
   if (target_float_abi_name != NULL)
@@ -1510,9 +1701,6 @@ arm_override_options (void)
   else
     arm_float_abi = TARGET_DEFAULT_FLOAT_ABI;
 
-  if (arm_float_abi == ARM_FLOAT_ABI_HARD && TARGET_VFP)
-    sorry ("-mfloat-abi=hard and VFP");
-
   /* FPA and iWMMXt are incompatible because the insn encodings overlap.
      VFP and iWMMXt can theoretically coexist, but it's unlikely such silicon
      will ever exist.  GCC makes no attempt to support this combination.  */
@@ -1523,15 +1711,40 @@ arm_override_options (void)
   if (TARGET_THUMB2 && TARGET_IWMMXT)
     sorry ("Thumb-2 iWMMXt");
 
+  /* __fp16 support currently assumes the core has ldrh.  */
+  if (!arm_arch4 && arm_fp16_format != ARM_FP16_FORMAT_NONE)
+    sorry ("__fp16 and no ldrh");
+
   /* If soft-float is specified then don't use FPU.  */
   if (TARGET_SOFT_FLOAT)
-    arm_fpu_arch = FPUTYPE_NONE;
+    arm_fpu_attr = FPU_NONE;
+
+  if (TARGET_AAPCS_BASED)
+    {
+      if (arm_abi == ARM_ABI_IWMMXT)
+	arm_pcs_default = ARM_PCS_AAPCS_IWMMXT;
+      else if (arm_float_abi == ARM_FLOAT_ABI_HARD
+	       && TARGET_HARD_FLOAT
+	       && TARGET_VFP)
+	arm_pcs_default = ARM_PCS_AAPCS_VFP;
+      else
+	arm_pcs_default = ARM_PCS_AAPCS;
+    }
+  else
+    {
+      if (arm_float_abi == ARM_FLOAT_ABI_HARD && TARGET_VFP)
+	sorry ("-mfloat-abi=hard and VFP");
+
+      if (arm_abi == ARM_ABI_APCS)
+	arm_pcs_default = ARM_PCS_APCS;
+      else
+	arm_pcs_default = ARM_PCS_ATPCS;
+    }
 
   /* For arm2/3 there is no need to do any scheduling if there is only
      a floating point emulator, or we are doing software floating-point.  */
   if ((TARGET_SOFT_FLOAT
-       || arm_fpu_tune == FPUTYPE_FPA_EMU2
-       || arm_fpu_tune == FPUTYPE_FPA_EMU3)
+       || (TARGET_FPA && arm_fpu_desc->rev))
       && (tune_flags & FL_MODE32) == 0)
     flag_schedule_insns = flag_schedule_insns_after_reload = 0;
 
@@ -1621,8 +1834,7 @@ arm_override_options (void)
 	fix_cm3_ldrd = 0;
     }
 
-  /* ??? We might want scheduling for thumb2.  */
-  if (TARGET_THUMB && flag_schedule_insns)
+  if (TARGET_THUMB1 && flag_schedule_insns)
     {
       /* Don't warn since it's on by default in -O2.  */
       flag_schedule_insns = 0;
@@ -1656,15 +1868,38 @@ arm_override_options (void)
         max_insns_skipped = 3;
     }
 
-  /* Ideally we would want to use CFI directives to generate
-     debug info.  However this also creates the .eh_frame
-     section, so disable them until GAS can handle
-     this properly.  See PR40521. */
-  if (TARGET_AAPCS_BASED)
-    flag_dwarf2_cfi_asm = 0;
-
   /* Register global variables with the garbage collector.  */
   arm_add_gc_roots ();
+
+  if (low_irq_latency && TARGET_THUMB)
+    {
+      warning (0, 
+	       "-low-irq-latency has no effect when compiling for the Thumb");
+      low_irq_latency = 0;
+    }
+
+  /* CSL LOCAL */
+  /* Loop unrolling can be a substantial win.  At -O2, limit to 2x
+     unrolling by default to prevent excessive code growth; at -O3,
+     limit to 4x unrolling by default.  We know we are not optimizing
+     for size if this is set (see arm_optimization_options).  */
+  if (flag_unroll_loops == 2)
+    {
+      if (optimize == 2)
+	{
+	  flag_unroll_loops = 1;
+	  if (!PARAM_SET_P (PARAM_MAX_UNROLL_TIMES))
+	    set_param_value ("max-unroll-times", 2);
+	}
+      else if (optimize > 2)
+	{
+	  flag_unroll_loops = 1;
+	  if (!PARAM_SET_P (PARAM_MAX_UNROLL_TIMES))
+	    set_param_value ("max-unroll-times", 4);
+	}
+      else
+	flag_unroll_loops = 0;
+    }
 }
 
 static void
@@ -1794,6 +2029,14 @@ arm_allocate_stack_slots_for_args (void)
   return !IS_NAKED (arm_current_func_type ());
 }
 
+static bool
+arm_warn_func_result (void)
+{
+  /* Naked functions are implemented entirely in assembly, including the
+     return sequence, so suppress warnings about this.  */
+  return !IS_NAKED (arm_current_func_type ());
+}
+
 
 /* Return 1 if it is possible to return using a single instruction.
    If SIBLING is non-null, this is a test for a return before a sibling
@@ -2822,13 +3065,82 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,
    immediate value easier to load.  */
 
 enum rtx_code
-arm_canonicalize_comparison (enum rtx_code code, enum machine_mode mode,
-			     rtx * op1)
+arm_canonicalize_comparison (enum rtx_code code, rtx *op0, rtx *op1)
 {
-  unsigned HOST_WIDE_INT i = INTVAL (*op1);
-  unsigned HOST_WIDE_INT maxval;
+  enum machine_mode mode;
+  unsigned HOST_WIDE_INT i, maxval;
+
+  mode = GET_MODE (*op0);
+  if (mode == VOIDmode)
+    mode = GET_MODE (*op1);
+
   maxval = (((unsigned HOST_WIDE_INT) 1) << (GET_MODE_BITSIZE(mode) - 1)) - 1;
 
+  /* For DImode, we have GE/LT/GEU/LTU comparisons.  In ARM mode
+     we can also use cmp/cmpeq for GTU/LEU.  GT/LE must be either
+     reversed or (for constant OP1) adjusted to GE/LT.  Similarly
+     for GTU/LEU in Thumb mode.  */
+  if (mode == DImode)
+    {
+      rtx tem;
+
+      /* To keep things simple, always use the Cirrus cfcmp64 if it is
+	 available.  */
+      if (TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK)
+	return code;
+
+      if (code == GT || code == LE
+	  || (!TARGET_ARM && (code == GTU || code == LEU)))
+	{
+	  /* Missing comparison.  First try to use an available
+	     comparison.  */
+	  if (GET_CODE (*op1) == CONST_INT)
+	    {
+	      i = INTVAL (*op1);
+	      switch (code)
+		{
+		case GT:
+		case LE:
+		  if (i != maxval
+		      && arm_const_double_by_immediates (GEN_INT (i + 1)))
+		    {
+		      *op1 = GEN_INT (i + 1);
+		      return code == GT ? GE : LT;
+		    }
+		  break;
+		case GTU:
+		case LEU:
+		  if (i != ~((unsigned HOST_WIDE_INT) 0)
+		      && arm_const_double_by_immediates (GEN_INT (i + 1)))
+		    {
+		      *op1 = GEN_INT (i + 1);
+		      return code == GTU ? GEU : LTU;
+		    }
+		  break;
+		default:
+		  gcc_unreachable ();
+		}
+	    }
+
+	  /* If that did not work, reverse the condition.  */
+	  tem = *op0;
+	  *op0 = *op1;
+	  *op1 = tem;
+	  return swap_condition (code);
+	}
+
+      return code;
+    }
+
+  /* Comparisons smaller than DImode.  Only adjust comparisons against
+     an out-of-range constant.  */
+  if (GET_CODE (*op1) != CONST_INT
+      || const_ok_for_arm (INTVAL (*op1))
+      || const_ok_for_arm (- INTVAL (*op1)))
+    return code;
+
+  i = INTVAL (*op1);
+
   switch (code)
     {
     case EQ:
@@ -2885,14 +3197,19 @@ arm_canonicalize_comparison (enum rtx_code code, enum machine_mode mode,
 
 /* Define how to find the value returned by a function.  */
 
-rtx
-arm_function_value(const_tree type, const_tree func ATTRIBUTE_UNUSED)
+static rtx
+arm_function_value(const_tree type, const_tree func,
+		   bool outgoing ATTRIBUTE_UNUSED)
 {
   enum machine_mode mode;
   int unsignedp ATTRIBUTE_UNUSED;
   rtx r ATTRIBUTE_UNUSED;
 
   mode = TYPE_MODE (type);
+
+  if (TARGET_AAPCS_BASED)
+    return aapcs_allocate_return_reg (mode, type, func);
+
   /* Promote integer types.  */
   if (INTEGRAL_TYPE_P (type))
     PROMOTE_FUNCTION_MODE (mode, unsignedp, type);
@@ -2909,7 +3226,57 @@ arm_function_value(const_tree type, const_tree func ATTRIBUTE_UNUSED)
 	}
     }
 
-  return LIBCALL_VALUE(mode);
+  return LIBCALL_VALUE (mode);
+}
+
+rtx
+arm_libcall_value (enum machine_mode mode, rtx libcall)
+{
+  if (TARGET_AAPCS_BASED && arm_pcs_default != ARM_PCS_AAPCS
+      && GET_MODE_CLASS (mode) == MODE_FLOAT)
+    {
+      /* The following libcalls return their result in integer registers,
+	 even though they return a floating point value.  */
+      if (rtx_equal_p (libcall,
+		       convert_optab_libfunc (sfloat_optab, mode, SImode))
+	  || rtx_equal_p (libcall,
+			  convert_optab_libfunc (ufloat_optab, mode, SImode))
+	  || rtx_equal_p (libcall,
+			  convert_optab_libfunc (sfloat_optab, mode, DImode))
+	  || rtx_equal_p (libcall,
+			  convert_optab_libfunc (ufloat_optab, mode, DImode))
+	  || rtx_equal_p (libcall,
+			  convert_optab_libfunc (trunc_optab, HFmode, SFmode))
+	  || rtx_equal_p (libcall,
+			  convert_optab_libfunc (sext_optab, SFmode, HFmode)))
+	return gen_rtx_REG (mode, ARG_REGISTER(1));
+
+      /* Values from double-precision helper functions are returned in core
+	 registers if the selected core only supports single-precision
+	 arithmetic, even if we are using the hard-float ABI.  */
+      if (TARGET_VFP
+	  && (rtx_equal_p (libcall, optab_libfunc (add_optab, DFmode))
+	      || rtx_equal_p (libcall, optab_libfunc (sdiv_optab, DFmode))
+	      || rtx_equal_p (libcall, optab_libfunc (smul_optab, DFmode))
+	      || rtx_equal_p (libcall, optab_libfunc (neg_optab, DFmode))
+	      || rtx_equal_p (libcall, optab_libfunc (sub_optab, DFmode))
+	      || rtx_equal_p (libcall, optab_libfunc (eq_optab, DFmode))
+	      || rtx_equal_p (libcall, optab_libfunc (lt_optab, DFmode))
+	      || rtx_equal_p (libcall, optab_libfunc (le_optab, DFmode))
+	      || rtx_equal_p (libcall, optab_libfunc (ge_optab, DFmode))
+	      || rtx_equal_p (libcall, optab_libfunc (gt_optab, DFmode))
+	      || rtx_equal_p (libcall, optab_libfunc (unord_optab, DFmode))
+	      || rtx_equal_p (libcall, convert_optab_libfunc (sext_optab,
+							      DFmode, SFmode))
+	      || rtx_equal_p (libcall, convert_optab_libfunc (trunc_optab,
+							      SFmode, DFmode))))
+        return gen_rtx_REG (mode, ARG_REGISTER (1));
+
+      /* XXX There are other libcalls that return in integer registers,
+	 but I think they are all handled by hard insns.  */
+    }
+
+  return LIBCALL_VALUE (mode);
 }
 
 /* Determine the amount of memory needed to store the possible return
@@ -2919,10 +3286,12 @@ arm_apply_result_size (void)
 {
   int size = 16;
 
-  if (TARGET_ARM)
+  if (TARGET_32BIT)
     {
       if (TARGET_HARD_FLOAT_ABI)
 	{
+	  if (TARGET_VFP)
+	    size += 32;
 	  if (TARGET_FPA)
 	    size += 12;
 	  if (TARGET_MAVERICK)
@@ -2935,27 +3304,56 @@ arm_apply_result_size (void)
   return size;
 }
 
-/* Decide whether a type should be returned in memory (true)
-   or in a register (false).  This is called as the target hook
-   TARGET_RETURN_IN_MEMORY.  */
+/* Decide whether TYPE should be returned in memory (true)
+   or in a register (false).  FNTYPE is the type of the function making
+   the call.  */
 static bool
-arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
+arm_return_in_memory (const_tree type, const_tree fntype)
 {
   HOST_WIDE_INT size;
 
-  size = int_size_in_bytes (type);
+  size = int_size_in_bytes (type);  /* Negative if not fixed size.  */
+
+  if (TARGET_AAPCS_BASED)
+    {
+      /* Simple, non-aggregate types (ie not including vectors and
+	 complex) are always returned in a register (or registers).
+	 We don't care about which register here, so we can short-cut
+	 some of the detail.  */
+      if (!AGGREGATE_TYPE_P (type)
+	  && TREE_CODE (type) != VECTOR_TYPE
+	  && TREE_CODE (type) != COMPLEX_TYPE)
+	return false;
+
+      /* Any return value that is no larger than one word can be
+	 returned in r0.  */
+      if (((unsigned HOST_WIDE_INT) size) <= UNITS_PER_WORD)
+	return false;
+
+      /* Check any available co-processors to see if they accept the
+	 type as a register candidate (VFP, for example, can return
+	 some aggregates in consecutive registers).  These aren't
+	 available if the call is variadic.  */
+      if (aapcs_select_return_coproc (type, fntype) >= 0)
+	return false;
+
+      /* Vector values should be returned using ARM registers, not
+	 memory (unless they're over 16 bytes, which will break since
+	 we only have four call-clobbered registers to play with).  */
+      if (TREE_CODE (type) == VECTOR_TYPE)
+	return (size < 0 || size > (4 * UNITS_PER_WORD));
+
+      /* The rest go in memory.  */
+      return true;
+    }
 
-  /* Vector values should be returned using ARM registers, not memory (unless
-     they're over 16 bytes, which will break since we only have four
-     call-clobbered registers to play with).  */
   if (TREE_CODE (type) == VECTOR_TYPE)
     return (size < 0 || size > (4 * UNITS_PER_WORD));
 
   if (!AGGREGATE_TYPE_P (type) &&
-      !(TARGET_AAPCS_BASED && TREE_CODE (type) == COMPLEX_TYPE))
-    /* All simple types are returned in registers.
-       For AAPCS, complex types are treated the same as aggregates.  */
-    return 0;
+      (TREE_CODE (type) != VECTOR_TYPE))
+    /* All simple types are returned in registers.  */
+    return false;
 
   if (arm_abi != ARM_ABI_APCS)
     {
@@ -2972,7 +3370,7 @@ arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
      the aggregate is either huge or of variable size, and in either case
      we will want to return it via memory and not in a register.  */
   if (size < 0 || size > UNITS_PER_WORD)
-    return 1;
+    return true;
 
   if (TREE_CODE (type) == RECORD_TYPE)
     {
@@ -2992,18 +3390,18 @@ arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 	continue;
 
       if (field == NULL)
-	return 0; /* An empty structure.  Allowed by an extension to ANSI C.  */
+	return false; /* An empty structure.  Allowed by an extension to ANSI C.  */
 
       /* Check that the first field is valid for returning in a register.  */
 
       /* ... Floats are not allowed */
       if (FLOAT_TYPE_P (TREE_TYPE (field)))
-	return 1;
+	return true;
 
       /* ... Aggregates that are not themselves valid for returning in
 	 a register are not allowed.  */
       if (arm_return_in_memory (TREE_TYPE (field), NULL_TREE))
-	return 1;
+	return true;
 
       /* Now check the remaining fields, if any.  Only bitfields are allowed,
 	 since they are not addressable.  */
@@ -3015,10 +3413,10 @@ arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 	    continue;
 
 	  if (!DECL_BIT_FIELD_TYPE (field))
-	    return 1;
+	    return true;
 	}
 
-      return 0;
+      return false;
     }
 
   if (TREE_CODE (type) == UNION_TYPE)
@@ -3035,18 +3433,18 @@ arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 	    continue;
 
 	  if (FLOAT_TYPE_P (TREE_TYPE (field)))
-	    return 1;
+	    return true;
 
 	  if (arm_return_in_memory (TREE_TYPE (field), NULL_TREE))
-	    return 1;
+	    return true;
 	}
 
-      return 0;
+      return false;
     }
 #endif /* not ARM_WINCE */
 
   /* Return all other types in memory.  */
-  return 1;
+  return true;
 }
 
 /* Indicate whether or not words of a double are in big-endian order.  */
@@ -3071,53 +3469,844 @@ arm_float_words_big_endian (void)
   return 1;
 }
 
-/* Initialize a variable CUM of type CUMULATIVE_ARGS
-   for a call to a function whose data type is FNTYPE.
-   For a library call, FNTYPE is NULL.  */
-void
-arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,
-			  rtx libname  ATTRIBUTE_UNUSED,
-			  tree fndecl ATTRIBUTE_UNUSED)
+const struct pcs_attribute_arg
 {
-  /* On the ARM, the offset starts at 0.  */
-  pcum->nregs = 0;
-  pcum->iwmmxt_nregs = 0;
-  pcum->can_split = true;
+  const char *arg;
+  enum arm_pcs value;
+} pcs_attribute_args[] =
+  {
+    {"aapcs", ARM_PCS_AAPCS},
+    {"aapcs-vfp", ARM_PCS_AAPCS_VFP},
+    {"aapcs-iwmmxt", ARM_PCS_AAPCS_IWMMXT},
+    {"atpcs", ARM_PCS_ATPCS},
+    {"apcs", ARM_PCS_APCS},
+    {NULL, ARM_PCS_UNKNOWN}
+  };
 
-  /* Varargs vectors are treated the same as long long.
-     named_count avoids having to change the way arm handles 'named' */
-  pcum->named_count = 0;
-  pcum->nargs = 0;
+static enum arm_pcs
+arm_pcs_from_attribute (tree attr)
+{
+  const struct pcs_attribute_arg *ptr;
+  const char *arg;
 
-  if (TARGET_REALLY_IWMMXT && fntype)
+  /* Get the value of the argument.  */
+  if (TREE_VALUE (attr) == NULL_TREE
+      || TREE_CODE (TREE_VALUE (attr)) != STRING_CST)
+    return ARM_PCS_UNKNOWN;
+
+  arg = TREE_STRING_POINTER (TREE_VALUE (attr));
+
+  /* Check it against the list of known arguments.  */
+  for (ptr = pcs_attribute_args; ptr->arg != NULL; ptr++)
+    if (streq (arg, ptr->arg))
+      return ptr->value;
+
+  /* An unrecognized interrupt type.  */
+  return ARM_PCS_UNKNOWN;
+}
+
+/* Get the PCS variant to use for this call.  TYPE is the function's type
+   specification, DECL is the specific declartion.  DECL may be null if
+   the call could be indirect or if this is a library call.  */
+static enum arm_pcs
+arm_get_pcs_model (const_tree type, const_tree decl)
+{
+  bool user_convention = false;
+  enum arm_pcs user_pcs = arm_pcs_default;
+  tree attr;
+
+  gcc_assert (type);
+
+  attr = lookup_attribute ("pcs", TYPE_ATTRIBUTES (type));
+  if (attr)
     {
-      tree fn_arg;
+      user_pcs = arm_pcs_from_attribute (TREE_VALUE (attr));
+      user_convention = true;
+    }
 
-      for (fn_arg = TYPE_ARG_TYPES (fntype);
-	   fn_arg;
-	   fn_arg = TREE_CHAIN (fn_arg))
-	pcum->named_count += 1;
+  if (TARGET_AAPCS_BASED)
+    {
+      /* Detect varargs functions.  These always use the base rules
+	 (no argument is ever a candidate for a co-processor
+	 register).  */
+      bool base_rules = (TYPE_ARG_TYPES (type) != 0
+			 && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (type)))
+			     != void_type_node));
+      
+      if (user_convention)
+	{
+	  if (user_pcs > ARM_PCS_AAPCS_LOCAL)
+	    sorry ("Non-AAPCS derived PCS variant");
+	  else if (base_rules && user_pcs != ARM_PCS_AAPCS)
+	    error ("Variadic functions must use the base AAPCS variant");
+	}
 
-      if (! pcum->named_count)
-	pcum->named_count = INT_MAX;
+      if (base_rules)
+	return ARM_PCS_AAPCS;
+      else if (user_convention)
+	return user_pcs;
+      else if (decl && flag_unit_at_a_time)
+	{
+	  /* Local functions never leak outside this compilation unit,
+	     so we are free to use whatever conventions are
+	     appropriate.  */
+	  /* FIXME: remove CONST_CAST_TREE when cgraph is constified.  */
+	  struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE(decl));
+	  if (i && i->local)
+	    return ARM_PCS_AAPCS_LOCAL;
+	}
     }
+  else if (user_convention && user_pcs != arm_pcs_default)
+    sorry ("PCS variant");
+
+  /* For everything else we use the target's default.  */
+  return arm_pcs_default;
 }
 
 
-/* Return true if mode/type need doubleword alignment.  */
-bool
-arm_needs_doubleword_align (enum machine_mode mode, tree type)
+static void
+aapcs_vfp_cum_init (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,
+		    const_tree fntype ATTRIBUTE_UNUSED,
+		    rtx libcall ATTRIBUTE_UNUSED, 
+		    const_tree fndecl ATTRIBUTE_UNUSED)
 {
-  return (GET_MODE_ALIGNMENT (mode) > PARM_BOUNDARY
-	  || (type && TYPE_ALIGN (type) > PARM_BOUNDARY));
+  /* Record the unallocated VFP registers.  */
+  pcum->aapcs_vfp_regs_free = (1 << NUM_VFP_ARG_REGS) - 1;
+  pcum->aapcs_vfp_reg_alloc = 0;
 }
 
+/* Walk down the type tree of TYPE counting consecutive base elements.
+   If *MODEP is VOIDmode, then set it to the first valid floating point
+   type.  If a non-floating point type is found, or if a floating point
+   type that doesn't match a non-VOIDmode *MODEP is found, then return -1,
+   otherwise return the count in the sub-tree.  */
+static int
+aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)
+{
+  enum machine_mode mode;
+  HOST_WIDE_INT size;
 
-/* Determine where to put an argument to a function.
-   Value is zero to push the argument on the stack,
-   or a hard register in which to store the argument.
+  switch (TREE_CODE (type))
+    {
+    case REAL_TYPE:
+      mode = TYPE_MODE (type);
+      if (mode != DFmode && mode != SFmode)
+	return -1;
 
-   MODE is the argument's machine mode.
+      if (*modep == VOIDmode)
+	*modep = mode;
+
+      if (*modep == mode)
+	return 1;
+
+      break;
+
+    case COMPLEX_TYPE:
+      mode = TYPE_MODE (TREE_TYPE (type));
+      if (mode != DFmode && mode != SFmode)
+	return -1;
+
+      if (*modep == VOIDmode)
+	*modep = mode;
+
+      if (*modep == mode)
+	return 2;
+
+      break;
+
+    case VECTOR_TYPE:
+      /* Use V2SImode and V4SImode as representatives of all 64-bit
+	 and 128-bit vector types, whether or not those modes are
+	 supported with the present options.  */
+      size = int_size_in_bytes (type);
+      switch (size)
+	{
+	case 8:
+	  mode = V2SImode;
+	  break;
+	case 16:
+	  mode = V4SImode;
+	  break;
+	default:
+	  return -1;
+	}
+
+      if (*modep == VOIDmode)
+	*modep = mode;
+
+      /* Vector modes are considered to be opaque: two vectors are
+	 equivalent for the purposes of being homogeneous aggregates
+	 if they are the same size.  */
+      if (*modep == mode)
+	return 1;
+
+      break;
+
+    case ARRAY_TYPE:
+      {
+	int count;
+	tree index = TYPE_DOMAIN (type);
+
+	/* Can't handle incomplete types.  */
+	if (!COMPLETE_TYPE_P(type))
+	  return -1;
+
+	count = aapcs_vfp_sub_candidate (TREE_TYPE (type), modep);
+	if (count == -1
+	    || !index
+	    || !TYPE_MAX_VALUE (index)
+	    || !host_integerp (TYPE_MAX_VALUE (index), 1)
+	    || !TYPE_MIN_VALUE (index)
+	    || !host_integerp (TYPE_MIN_VALUE (index), 1)
+	    || count < 0)
+	  return -1;
+
+	count *= (1 + tree_low_cst (TYPE_MAX_VALUE (index), 1)
+		      - tree_low_cst (TYPE_MIN_VALUE (index), 1));
+
+	/* There must be no padding.  */
+	if (!host_integerp (TYPE_SIZE (type), 1)
+	    || (tree_low_cst (TYPE_SIZE (type), 1)
+		!= count * GET_MODE_BITSIZE (*modep)))
+	  return -1;
+
+	return count;
+      }
+      
+    case RECORD_TYPE:
+      {
+	int count = 0;
+	int sub_count;
+	tree field;
+
+	/* Can't handle incomplete types.  */
+	if (!COMPLETE_TYPE_P(type))
+	  return -1;
+
+	for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))
+	  {
+	    if (TREE_CODE (field) != FIELD_DECL)
+	      continue;
+
+	    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep);
+	    if (sub_count < 0)
+	      return -1;
+	    count += sub_count;
+	  }
+
+	/* There must be no padding.  */
+	if (!host_integerp (TYPE_SIZE (type), 1)
+	    || (tree_low_cst (TYPE_SIZE (type), 1)
+		!= count * GET_MODE_BITSIZE (*modep)))
+	  return -1;
+
+	return count;
+      }
+
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      {
+	/* These aren't very interesting except in a degenerate case.  */
+	int count = 0;
+	int sub_count;
+	tree field;
+
+	/* Can't handle incomplete types.  */
+	if (!COMPLETE_TYPE_P(type))
+	  return -1;
+
+	for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))
+	  {
+	    if (TREE_CODE (field) != FIELD_DECL)
+	      continue;
+
+	    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep);
+	    if (sub_count < 0)
+	      return -1;
+	    count = count > sub_count ? count : sub_count;
+	  }
+
+	/* There must be no padding.  */
+	if (!host_integerp (TYPE_SIZE (type), 1)
+	    || (tree_low_cst (TYPE_SIZE (type), 1)
+		!= count * GET_MODE_BITSIZE (*modep)))
+	  return -1;
+
+	return count;
+      }
+
+    default:
+      break;
+    }
+
+  return -1;
+}
+
+/* Return true if PCS_VARIANT should use VFP registers.  */
+static bool
+use_vfp_abi (enum arm_pcs pcs_variant, bool is_double)
+{
+  if (pcs_variant == ARM_PCS_AAPCS_VFP)
+    return true;
+
+  if (pcs_variant != ARM_PCS_AAPCS_LOCAL)
+    return false;
+
+  return (TARGET_32BIT && TARGET_VFP && TARGET_HARD_FLOAT &&
+	  (TARGET_VFP_DOUBLE || !is_double));
+}
+
+static bool
+aapcs_vfp_is_call_or_return_candidate (enum arm_pcs pcs_variant,
+				       enum machine_mode mode, const_tree type,
+				       int *base_mode, int *count)
+{
+  enum machine_mode new_mode = VOIDmode;
+
+  if (GET_MODE_CLASS (mode) == MODE_FLOAT
+      || GET_MODE_CLASS (mode) == MODE_VECTOR_INT
+      || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)
+    {
+      *count = 1;
+      new_mode = mode;
+    }
+  else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)
+    {
+      *count = 2;
+      new_mode = (mode == DCmode ? DFmode : SFmode);
+    }
+  else if (type && (mode == BLKmode || TREE_CODE (type) == VECTOR_TYPE))
+    {
+      int ag_count = aapcs_vfp_sub_candidate (type, &new_mode);
+
+      if (ag_count > 0 && ag_count <= 4)
+	*count = ag_count;
+      else
+	return false;
+    }
+  else
+    return false;
+
+
+  if (!use_vfp_abi (pcs_variant, ARM_NUM_REGS (new_mode) > 1))
+    return false;
+
+  *base_mode = new_mode;
+  return true;
+}
+
+static bool
+aapcs_vfp_is_return_candidate (enum arm_pcs pcs_variant,
+			       enum machine_mode mode, const_tree type)
+{
+  int count ATTRIBUTE_UNUSED;
+  int ag_mode ATTRIBUTE_UNUSED;
+
+  if (!use_vfp_abi (pcs_variant, false))
+    return false;
+  return aapcs_vfp_is_call_or_return_candidate (pcs_variant, mode, type,
+						&ag_mode, &count);
+}
+
+static bool
+aapcs_vfp_is_call_candidate (CUMULATIVE_ARGS *pcum, enum machine_mode mode, 
+			     const_tree type)
+{
+  if (!use_vfp_abi (pcum->pcs_variant, false))
+    return false;
+
+  return aapcs_vfp_is_call_or_return_candidate (pcum->pcs_variant, mode, type,
+						&pcum->aapcs_vfp_rmode,
+						&pcum->aapcs_vfp_rcount);
+}
+
+static bool
+aapcs_vfp_allocate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
+		    const_tree type  ATTRIBUTE_UNUSED)
+{
+  int shift = GET_MODE_SIZE (pcum->aapcs_vfp_rmode) / GET_MODE_SIZE (SFmode);
+  unsigned mask = (1 << (shift * pcum->aapcs_vfp_rcount)) - 1;
+  int regno;
+  
+  for (regno = 0; regno < NUM_VFP_ARG_REGS; regno += shift)
+    if (((pcum->aapcs_vfp_regs_free >> regno) & mask) == mask)
+      {
+	pcum->aapcs_vfp_reg_alloc = mask << regno;
+	if (mode == BLKmode || (mode == TImode && !TARGET_NEON))
+	  {
+	    int i;
+	    int rcount = pcum->aapcs_vfp_rcount;
+	    int rshift = shift;
+	    enum machine_mode rmode = pcum->aapcs_vfp_rmode;
+	    rtx par;
+	    if (!TARGET_NEON)
+	      {
+		/* Avoid using unsupported vector modes.  */
+		if (rmode == V2SImode)
+		  rmode = DImode;
+		else if (rmode == V4SImode)
+		  {
+		    rmode = DImode;
+		    rcount *= 2;
+		    rshift /= 2;
+		  }
+	      }
+	    par = gen_rtx_PARALLEL (mode, rtvec_alloc (rcount));
+	    for (i = 0; i < rcount; i++)
+	      {
+		rtx tmp = gen_rtx_REG (rmode, 
+				       FIRST_VFP_REGNUM + regno + i * rshift);
+		tmp = gen_rtx_EXPR_LIST
+		  (VOIDmode, tmp, 
+		   GEN_INT (i * GET_MODE_SIZE (rmode)));
+		XVECEXP (par, 0, i) = tmp;
+	      }
+
+	    pcum->aapcs_reg = par;
+	  }
+	else
+	  pcum->aapcs_reg = gen_rtx_REG (mode, FIRST_VFP_REGNUM + regno);
+	return true;
+      }
+  return false;
+}
+
+static rtx
+aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,
+			       enum machine_mode mode,
+			       const_tree type ATTRIBUTE_UNUSED)
+{
+  if (!use_vfp_abi (pcs_variant, false))
+    return false;
+
+  if (mode == BLKmode || (mode == TImode && !TARGET_NEON))
+    {
+      int count;
+      int ag_mode;
+      int i;
+      rtx par;
+      int shift;
+      
+      aapcs_vfp_is_call_or_return_candidate (pcs_variant, mode, type,
+					     &ag_mode, &count);
+
+      if (!TARGET_NEON)
+	{
+	  if (ag_mode == V2SImode)
+	    ag_mode = DImode;
+	  else if (ag_mode == V4SImode)
+	    {
+	      ag_mode = DImode;
+	      count *= 2;
+	    }
+	}
+      shift = GET_MODE_SIZE(ag_mode) / GET_MODE_SIZE(SFmode);
+      par = gen_rtx_PARALLEL (mode, rtvec_alloc (count));
+      for (i = 0; i < count; i++)
+	{
+	  rtx tmp = gen_rtx_REG (ag_mode, FIRST_VFP_REGNUM + i * shift);
+	  tmp = gen_rtx_EXPR_LIST (VOIDmode, tmp, 
+				   GEN_INT (i * GET_MODE_SIZE (ag_mode)));
+	  XVECEXP (par, 0, i) = tmp;
+	}
+
+      return par;
+    }
+
+  return gen_rtx_REG (mode, FIRST_VFP_REGNUM);
+}
+
+static void
+aapcs_vfp_advance (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,
+		   enum machine_mode mode  ATTRIBUTE_UNUSED,
+		   const_tree type  ATTRIBUTE_UNUSED)
+{
+  pcum->aapcs_vfp_regs_free &= ~pcum->aapcs_vfp_reg_alloc;
+  pcum->aapcs_vfp_reg_alloc = 0;
+  return;
+}
+
+#define AAPCS_CP(X)				\
+  {						\
+    aapcs_ ## X ## _cum_init,			\
+    aapcs_ ## X ## _is_call_candidate,		\
+    aapcs_ ## X ## _allocate,			\
+    aapcs_ ## X ## _is_return_candidate,	\
+    aapcs_ ## X ## _allocate_return_reg,	\
+    aapcs_ ## X ## _advance			\
+  }
+
+/* Table of co-processors that can be used to pass arguments in
+   registers.  Idealy no arugment should be a candidate for more than
+   one co-processor table entry, but the table is processed in order
+   and stops after the first match.  If that entry then fails to put
+   the argument into a co-processor register, the argument will go on
+   the stack.  */
+static struct 
+{
+  /* Initialize co-processor related state in CUMULATIVE_ARGS structure.  */
+  void (*cum_init) (CUMULATIVE_ARGS *, const_tree, rtx, const_tree);
+
+  /* Return true if an argument of mode MODE (or type TYPE if MODE is
+     BLKmode) is a candidate for this co-processor's registers; this
+     function should ignore any position-dependent state in
+     CUMULATIVE_ARGS and only use call-type dependent information.  */
+  bool (*is_call_candidate) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);
+
+  /* Return true if the argument does get a co-processor register; it
+     should set aapcs_reg to an RTX of the register allocated as is
+     required for a return from FUNCTION_ARG.  */
+  bool (*allocate) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);
+
+  /* Return true if a result of mode MODE (or type TYPE if MODE is
+     BLKmode) is can be returned in this co-processor's registers.  */
+  bool (*is_return_candidate) (enum arm_pcs, enum machine_mode, const_tree);
+
+  /* Allocate and return an RTX element to hold the return type of a
+     call, this routine must not fail and will only be called if
+     is_return_candidate returned true with the same parameters.  */
+  rtx (*allocate_return_reg) (enum arm_pcs, enum machine_mode, const_tree);
+
+  /* Finish processing this argument and prepare to start processing
+     the next one.  */
+  void (*advance) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);
+} aapcs_cp_arg_layout[ARM_NUM_COPROC_SLOTS] =
+  {
+    AAPCS_CP(vfp)
+  };
+
+#undef AAPCS_CP
+
+static int
+aapcs_select_call_coproc (CUMULATIVE_ARGS *pcum, enum machine_mode mode, 
+			  tree type)
+{
+  int i;
+
+  for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)
+    if (aapcs_cp_arg_layout[i].is_call_candidate (pcum, mode, type))
+      return i;
+
+  return -1;
+}
+
+static int
+aapcs_select_return_coproc (const_tree type, const_tree fntype)
+{
+  /* We aren't passed a decl, so we can't check that a call is local.
+     However, it isn't clear that that would be a win anyway, since it
+     might limit some tail-calling opportunities.  */
+  enum arm_pcs pcs_variant;
+
+  if (fntype)
+    {
+      const_tree fndecl = NULL_TREE;
+
+      if (TREE_CODE (fntype) == FUNCTION_DECL)
+	{
+	  fndecl = fntype;
+	  fntype = TREE_TYPE (fntype);
+	}
+
+      pcs_variant = arm_get_pcs_model (fntype, fndecl);
+    }
+  else
+    pcs_variant = arm_pcs_default;
+
+  if (pcs_variant != ARM_PCS_AAPCS)
+    {
+      int i;
+
+      for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)
+	if (aapcs_cp_arg_layout[i].is_return_candidate (pcs_variant, 
+							TYPE_MODE (type),
+							type))
+	  return i;
+    }
+  return -1;
+}
+
+static rtx
+aapcs_allocate_return_reg (enum machine_mode mode, const_tree type,
+			   const_tree fntype)
+{
+  /* We aren't passed a decl, so we can't check that a call is local.
+     However, it isn't clear that that would be a win anyway, since it
+     might limit some tail-calling opportunities.  */
+  enum arm_pcs pcs_variant;
+
+  if (fntype)
+    {
+      const_tree fndecl = NULL_TREE;
+
+      if (TREE_CODE (fntype) == FUNCTION_DECL)
+	{
+	  fndecl = fntype;
+	  fntype = TREE_TYPE (fntype);
+	}
+
+      pcs_variant = arm_get_pcs_model (fntype, fndecl);
+    }
+  else
+    pcs_variant = arm_pcs_default;
+
+  /* Promote integer types.  */
+  if (type && INTEGRAL_TYPE_P (type))
+    PROMOTE_FUNCTION_MODE (mode, unsignedp, type);
+
+  if (pcs_variant != ARM_PCS_AAPCS)
+    {
+      int i;
+
+      for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)
+	if (aapcs_cp_arg_layout[i].is_return_candidate (pcs_variant, mode,
+							type))
+	  return aapcs_cp_arg_layout[i].allocate_return_reg (pcs_variant,
+							     mode, type);
+    }
+
+  /* Promotes small structs returned in a register to full-word size
+     for big-endian AAPCS.  */
+  if (type && arm_return_in_msb (type))
+    {
+      HOST_WIDE_INT size = int_size_in_bytes (type);
+      if (size % UNITS_PER_WORD != 0)
+	{
+	  size += UNITS_PER_WORD - size % UNITS_PER_WORD;
+	  mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);
+	}
+    }
+
+  return gen_rtx_REG (mode, R0_REGNUM);
+}
+
+rtx
+aapcs_libcall_value (enum machine_mode mode)
+{
+  return aapcs_allocate_return_reg (mode, NULL_TREE, NULL_TREE);
+}
+
+/* Lay out a function argument using the AAPCS rules.  The rule
+   numbers referred to here are those in the AAPCS.  */
+static void
+aapcs_layout_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
+		  tree type, int named)
+{
+  int nregs, nregs2;
+  int ncrn;
+
+  /* We only need to do this once per argument.  */
+  if (pcum->aapcs_arg_processed)
+    return;
+
+  pcum->aapcs_arg_processed = true;
+
+  /* Special case: if named is false then we are handling an incoming
+     anonymous argument which is on the stack.  */
+  if (!named)
+    return;
+  
+  /* Is this a potential co-processor register candidate?  */
+  if (pcum->pcs_variant != ARM_PCS_AAPCS)
+    {
+      int slot = aapcs_select_call_coproc (pcum, mode, type);
+      pcum->aapcs_cprc_slot = slot;
+
+      /* We don't have to apply any of the rules from part B of the
+	 preparation phase, these are handled elsewhere in the
+	 compiler.  */
+
+      if (slot >= 0)
+	{
+	  /* A Co-processor register candidate goes either in its own
+	     class of registers or on the stack.  */
+	  if (!pcum->aapcs_cprc_failed[slot])
+	    {
+	      /* C1.cp - Try to allocate the argument to co-processor
+		 registers.  */
+	      if (aapcs_cp_arg_layout[slot].allocate (pcum, mode, type))
+		return;
+
+	      /* C2.cp - Put the argument on the stack and note that we
+		 can't assign any more candidates in this slot.  We also
+		 need to note that we have allocated stack space, so that
+		 we won't later try to split a non-cprc candidate between
+		 core registers and the stack.  */
+	      pcum->aapcs_cprc_failed[slot] = true;
+	      pcum->can_split = false;
+	    }
+
+	  /* We didn't get a register, so this argument goes on the
+	     stack.  */
+	  gcc_assert (pcum->can_split == false);
+	  return;
+	}
+    }
+
+  /* C3 - For double-word aligned arguments, round the NCRN up to the
+     next even number.  */
+  ncrn = pcum->aapcs_ncrn;
+  if ((ncrn & 1) && arm_needs_doubleword_align (mode, type))
+    ncrn++;
+
+  nregs = ARM_NUM_REGS2(mode, type);
+
+  /* Sigh, this test should really assert that nregs > 0, but a GCC
+     extension allows empty structs and then gives them empty size; it
+     then allows such a structure to be passed by value.  For some of
+     the code below we have to pretend that such an argument has
+     non-zero size so that we 'locate' it correctly either in
+     registers or on the stack.  */
+  gcc_assert (nregs >= 0);
+
+  nregs2 = nregs ? nregs : 1;
+
+  /* C4 - Argument fits entirely in core registers.  */
+  if (ncrn + nregs2 <= NUM_ARG_REGS)
+    {
+      pcum->aapcs_reg = gen_rtx_REG (mode, ncrn);
+      pcum->aapcs_next_ncrn = ncrn + nregs;
+      return;
+    }
+
+  /* C5 - Some core registers left and there are no arguments already
+     on the stack: split this argument between the remaining core
+     registers and the stack.  */
+  if (ncrn < NUM_ARG_REGS && pcum->can_split)
+    {
+      pcum->aapcs_reg = gen_rtx_REG (mode, ncrn);
+      pcum->aapcs_next_ncrn = NUM_ARG_REGS;
+      pcum->aapcs_partial = (NUM_ARG_REGS - ncrn) * UNITS_PER_WORD;
+      return;
+    }
+
+  /* C6 - NCRN is set to 4.  */
+  pcum->aapcs_next_ncrn = NUM_ARG_REGS;
+
+  /* C7,C8 - arugment goes on the stack.  We have nothing to do here.  */
+  return;
+}
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is NULL.  */
+void
+arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,
+			  rtx libname,
+			  tree fndecl ATTRIBUTE_UNUSED)
+{
+  /* Long call handling.  */
+  if (fntype)
+    pcum->pcs_variant = arm_get_pcs_model (fntype, fndecl);
+  else
+    pcum->pcs_variant = arm_pcs_default;
+
+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)
+    {
+      /* XXX We should also detect some library calls here and handle
+	 them using the base rules too; for example the floating point
+	 support functions always work this way.  */
+
+       if (rtx_equal_p (libname,
+		       convert_optab_libfunc (sfix_optab, DImode, DFmode))
+	  || rtx_equal_p (libname,
+			  convert_optab_libfunc (ufix_optab, DImode, DFmode))
+	  || rtx_equal_p (libname,
+			  convert_optab_libfunc (sfix_optab, DImode, SFmode))
+	  || rtx_equal_p (libname,
+			  convert_optab_libfunc (ufix_optab, DImode, SFmode))
+	  || rtx_equal_p (libname,
+			  convert_optab_libfunc (trunc_optab, HFmode, SFmode))
+	  || rtx_equal_p (libname,
+			  convert_optab_libfunc (sext_optab, SFmode, HFmode)))
+	pcum->pcs_variant = ARM_PCS_AAPCS;
+ 
+      /* We must pass arguments to double-precision helper functions in core
+         registers if we only have hardware support for single-precision
+	 arithmetic, even if we are using the hard-float ABI.  */
+      if (TARGET_VFP
+          && (rtx_equal_p (libname, optab_libfunc (add_optab, DFmode))
+	      || rtx_equal_p (libname, optab_libfunc (sdiv_optab, DFmode))
+	      || rtx_equal_p (libname, optab_libfunc (smul_optab, DFmode))
+	      || rtx_equal_p (libname, optab_libfunc (neg_optab, DFmode))
+	      || rtx_equal_p (libname, optab_libfunc (sub_optab, DFmode))
+	      || rtx_equal_p (libname, optab_libfunc (eq_optab, DFmode))
+	      || rtx_equal_p (libname, optab_libfunc (lt_optab, DFmode))
+	      || rtx_equal_p (libname, optab_libfunc (le_optab, DFmode))
+	      || rtx_equal_p (libname, optab_libfunc (ge_optab, DFmode))
+	      || rtx_equal_p (libname, optab_libfunc (gt_optab, DFmode))
+	      || rtx_equal_p (libname, optab_libfunc (unord_optab, DFmode))
+	      || rtx_equal_p (libname, convert_optab_libfunc (sext_optab,
+							      DFmode, SFmode))
+	      || rtx_equal_p (libname, convert_optab_libfunc (trunc_optab,
+							      SFmode, DFmode))
+	      || rtx_equal_p (libname, convert_optab_libfunc (sfix_optab,
+							      SImode, DFmode))
+	      || rtx_equal_p (libname, convert_optab_libfunc (ufix_optab,
+							      SImode, DFmode))))
+        pcum->pcs_variant = ARM_PCS_AAPCS;
+ 
+      pcum->aapcs_ncrn = pcum->aapcs_next_ncrn = 0;
+      pcum->aapcs_reg = NULL_RTX;
+      pcum->aapcs_partial = 0;
+      pcum->aapcs_arg_processed = false;
+      pcum->aapcs_cprc_slot = -1;
+      pcum->can_split = true;
+
+      if (pcum->pcs_variant != ARM_PCS_AAPCS)
+	{
+	  int i;
+
+	  for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)
+	    {
+	      pcum->aapcs_cprc_failed[i] = false;
+	      aapcs_cp_arg_layout[i].cum_init (pcum, fntype, libname, fndecl);
+	    }
+	}
+      return;
+    }
+
+  /* Legacy ABIs */
+
+  /* On the ARM, the offset starts at 0.  */
+  pcum->nregs = 0;
+  pcum->iwmmxt_nregs = 0;
+  pcum->can_split = true;
+
+  /* Varargs vectors are treated the same as long long.
+     named_count avoids having to change the way arm handles 'named' */
+  pcum->named_count = 0;
+  pcum->nargs = 0;
+
+  if (TARGET_REALLY_IWMMXT && fntype)
+    {
+      tree fn_arg;
+
+      for (fn_arg = TYPE_ARG_TYPES (fntype);
+	   fn_arg;
+	   fn_arg = TREE_CHAIN (fn_arg))
+	pcum->named_count += 1;
+
+      if (! pcum->named_count)
+	pcum->named_count = INT_MAX;
+    }
+}
+
+
+/* Return true if mode/type need doubleword alignment.  */
+bool
+arm_needs_doubleword_align (enum machine_mode mode, tree type)
+{
+  return (GET_MODE_ALIGNMENT (mode) > PARM_BOUNDARY
+	  || (type && TYPE_ALIGN (type) > PARM_BOUNDARY));
+}
+
+
+/* Determine where to put an argument to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
    TYPE is the data type of the argument (as a tree).
     This is null for libcalls where that information may
     not be available.
@@ -3132,6 +4321,17 @@ arm_function_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
 {
   int nregs;
 
+  /* Handle the special case quickly.  Pick an arbitrary value for op2 of
+     a call insn (op3 of a call_value insn).  */
+  if (mode == VOIDmode)
+    return const0_rtx;
+
+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)
+    {
+      aapcs_layout_arg (pcum, mode, type, named);
+      return pcum->aapcs_reg;
+    }
+
   /* Varargs vectors are treated the same as long long.
      named_count avoids having to change the way arm handles 'named' */
   if (TARGET_IWMMXT_ABI
@@ -3173,10 +4373,16 @@ arm_function_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
 
 static int
 arm_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
-		       tree type, bool named ATTRIBUTE_UNUSED)
+		       tree type, bool named)
 {
   int nregs = pcum->nregs;
 
+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)
+    {
+      aapcs_layout_arg (pcum, mode, type, named);
+      return pcum->aapcs_partial;
+    }
+
   if (TARGET_IWMMXT_ABI && arm_vector_mode_supported_p (mode))
     return 0;
 
@@ -3188,6 +4394,39 @@ arm_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
   return 0;
 }
 
+void
+arm_function_arg_advance (CUMULATIVE_ARGS *pcum, enum machine_mode mode,
+			  tree type, bool named)
+{
+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)
+    {
+      aapcs_layout_arg (pcum, mode, type, named);
+
+      if (pcum->aapcs_cprc_slot >= 0)
+	{
+	  aapcs_cp_arg_layout[pcum->aapcs_cprc_slot].advance (pcum, mode,
+							      type);
+	  pcum->aapcs_cprc_slot = -1;
+	}
+
+      /* Generic stuff.  */
+      pcum->aapcs_arg_processed = false;
+      pcum->aapcs_ncrn = pcum->aapcs_next_ncrn;
+      pcum->aapcs_reg = NULL_RTX;
+      pcum->aapcs_partial = 0;
+    }
+  else
+    {
+      pcum->nargs += 1;
+      if (arm_vector_mode_supported_p (mode)
+	  && pcum->named_count > pcum->nargs
+	  && TARGET_IWMMXT_ABI)
+	pcum->iwmmxt_nregs += 1;
+      else
+	pcum->nregs += ARM_NUM_REGS2 (mode, type);
+    }
+}
+
 /* Variable sized types are passed by reference.  This is a GCC
    extension to the ARM ABI.  */
 
@@ -3238,6 +4477,8 @@ const struct attribute_spec arm_attribute_table[] =
   /* Whereas these functions are always known to reside within the 26 bit
      addressing range.  */
   { "short_call",   0, 0, false, true,  true,  NULL },
+  /* Specify the procedure call conventions for a function.  */
+  { "pcs",          1, 1, false, true,  true,  arm_handle_pcs_attribute },
   /* Interrupt Service Routines have special prologue and epilogue requirements.  */
   { "isr",          0, 1, false, false, false, arm_handle_isr_attribute },
   { "interrupt",    0, 1, false, false, false, arm_handle_isr_attribute },
@@ -3340,6 +4581,21 @@ arm_handle_isr_attribute (tree *node, tree name, tree args, int flags,
   return NULL_TREE;
 }
 
+/* Handle a "pcs" attribute; arguments as in struct
+   attribute_spec.handler.  */
+static tree
+arm_handle_pcs_attribute (tree *node ATTRIBUTE_UNUSED, tree name, tree args,
+			  int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)
+{
+  if (arm_pcs_from_attribute (args) == ARM_PCS_UNKNOWN)
+    {
+      warning (OPT_Wattributes, "%qs attribute ignored",
+	       IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+  return NULL_TREE;
+}
+
 #if TARGET_DLLIMPORT_DECL_ATTRIBUTES
 /* Handle the "notshared" attribute.  This attribute is another way of
    requesting hidden visibility.  ARM's compiler supports
@@ -3501,7 +4757,7 @@ arm_is_long_call_p (tree decl)
 
 /* Return nonzero if it is ok to make a tail-call to DECL.  */
 static bool
-arm_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)
+arm_function_ok_for_sibcall (tree decl, tree exp)
 {
   unsigned long func_type;
 
@@ -3509,8 +4765,8 @@ arm_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)
     return false;
 
   /* Never tailcall something for which we have no decl, or if we
-     are in Thumb mode.  */
-  if (decl == NULL || TARGET_THUMB)
+     are generating code for Thumb-1.  */
+  if (decl == NULL || !TARGET_32BIT)
     return false;
 
   /* The PIC register is live on entry to VxWorks PLT entries, so we
@@ -3534,6 +4790,21 @@ arm_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)
   if (IS_INTERRUPT (func_type))
     return false;
 
+  if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (cfun->decl))))
+    {
+      /* Check that the return value locations are the same.  For
+	 example that we aren't returning a value from the sibling in
+	 a VFP register but then need to transfer it to a core
+	 register.  */
+      rtx a, b;
+
+      a = arm_function_value (TREE_TYPE (exp), decl, false);
+      b = arm_function_value (TREE_TYPE (DECL_RESULT (cfun->decl)),
+			      cfun->decl, false);
+      if (!rtx_equal_p (a, b))
+	return false;
+    }
+
   /* Never tailcall if function may be called with a misaligned SP.  */
   if (IS_STACKALIGN (func_type))
     return false;
@@ -3586,7 +4857,7 @@ require_pic_register (void)
 	}
       else
 	{
-	  rtx seq;
+	  rtx seq, insn;
 
 	  if (!cfun->machine->pic_reg)
 	    cfun->machine->pic_reg = gen_reg_rtx (Pmode);
@@ -3603,6 +4874,11 @@ require_pic_register (void)
 
 	      seq = get_insns ();
 	      end_sequence ();
+
+	      for (insn = seq; insn; insn = NEXT_INSN (insn))
+		if (INSN_P (insn))
+		  INSN_LOCATOR (insn) = prologue_locator;
+
 	      emit_insn_after (seq, entry_of_function ());
 	    }
 	}
@@ -4132,6 +5408,7 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, RTX_CODE outer,
   if (GET_MODE_SIZE (mode) <= 4
       && ! (arm_arch4
 	    && (mode == HImode
+		|| mode == HFmode
 		|| (mode == QImode && outer == SIGN_EXTEND))))
     {
       if (code == MULT)
@@ -4160,13 +5437,15 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, RTX_CODE outer,
      load.  */
   if (arm_arch4)
     {
-      if (mode == HImode || (outer == SIGN_EXTEND && mode == QImode))
+      if (mode == HImode
+	  || mode == HFmode
+	  || (outer == SIGN_EXTEND && mode == QImode))
 	range = 256;
       else
 	range = 4096;
     }
   else
-    range = (mode == HImode) ? 4095 : 4096;
+    range = (mode == HImode || mode == HFmode) ? 4095 : 4096;
 
   return (code == CONST_INT
 	  && INTVAL (index) < range
@@ -4337,7 +5616,8 @@ thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)
     return 1;
 
   /* This is PC relative data after arm_reorg runs.  */
-  else if (GET_MODE_SIZE (mode) >= 4 && reload_completed
+  else if ((GET_MODE_SIZE (mode) >= 4 || mode == HFmode)
+	   && reload_completed
 	   && (GET_CODE (x) == LABEL_REF
 	       || (GET_CODE (x) == CONST
 		   && GET_CODE (XEXP (x, 0)) == PLUS
@@ -5036,7 +6316,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)
     case UMOD:
       if (TARGET_HARD_FLOAT && mode == SFmode)
 	*total = COSTS_N_INSNS (2);
-      else if (TARGET_HARD_FLOAT && mode == DFmode)
+      else if (TARGET_HARD_FLOAT && mode == DFmode && !TARGET_VFP_SINGLE)
 	*total = COSTS_N_INSNS (4);
       else
 	*total = COSTS_N_INSNS (20);
@@ -5075,23 +6355,6 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)
       return true;
 
     case MINUS:
-      if (TARGET_THUMB2)
-	{
-	  if (GET_MODE_CLASS (mode) == MODE_FLOAT)
-	    {
-	      if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
-		*total = COSTS_N_INSNS (1);
-	      else
-		*total = COSTS_N_INSNS (20);
-	    }
-	  else
-	    *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));
-	  /* Thumb2 does not have RSB, so all arguments must be
-	     registers (subtracting a constant is canonicalized as
-	     addition of the negated constant).  */
-	  return false;
-	}
-
       if (mode == DImode)
 	{
 	  *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));
@@ -5114,7 +6377,9 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)
 
       if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      if (GET_CODE (XEXP (x, 0)) == CONST_DOUBLE
@@ -5155,6 +6420,17 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)
 	  return true;
 	}
 
+      /* A shift as a part of RSB costs no more than RSB itself.  */
+      if (GET_CODE (XEXP (x, 0)) == MULT
+	  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT
+	  && ((INTVAL (XEXP (XEXP (x, 0), 1))
+	       & (INTVAL (XEXP (XEXP (x, 0), 1)) - 1)) == 0))
+	{
+	  *total += rtx_cost (XEXP (XEXP (x, 0), 0), code, speed);
+	  *total += rtx_cost (XEXP (x, 1), code, speed);
+	  return true;
+	}
+
       if (subcode == MULT
 	  && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT
 	  && ((INTVAL (XEXP (XEXP (x, 1), 1)) &
@@ -5176,6 +6452,19 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)
 	  return true;
 	}
 
+      /* MLS is just as expensive as its underlying multiplication.
+	 Exclude a shift by a constant, which is expressed as a
+	 multiplication.  */
+      if (TARGET_32BIT && arm_arch_thumb2
+	  && GET_CODE (XEXP (x, 1)) == MULT
+	  && ! (GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT
+		&& ((INTVAL (XEXP (XEXP (x, 1), 1)) &
+		     (INTVAL (XEXP (XEXP (x, 1), 1)) - 1)) == 0)))
+	{
+	  /* The cost comes from the cost of the multiply.  */
+	  return false;
+	}
+
       /* Fall through */
 
     case PLUS:
@@ -5204,7 +6493,9 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)
 
       if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      if (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE
@@ -5319,7 +6610,9 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)
     case NEG:
       if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      return false;
@@ -5470,9 +6763,11 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)
       return true;
 
     case ABS:
-      if (GET_MODE_CLASS (mode == MODE_FLOAT))
+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      return false;
@@ -5575,7 +6870,19 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)
       return true;
 
     case CONST_DOUBLE:
-      if (TARGET_HARD_FLOAT && vfp3_const_double_rtx (x))
+      if (TARGET_HARD_FLOAT && vfp3_const_double_rtx (x)
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
+	*total = COSTS_N_INSNS (1);
+      else
+	*total = COSTS_N_INSNS (4);
+      return true;
+
+    case CONST_VECTOR:
+      if (TARGET_NEON
+	  && TARGET_HARD_FLOAT
+	  && outer == SET
+	  && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))
+	  && neon_immediate_valid_for_move (x, mode, NULL, NULL))
 	*total = COSTS_N_INSNS (1);
       else
 	*total = COSTS_N_INSNS (4);
@@ -5650,7 +6957,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
       return false;
 
     case MINUS:
-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	{
 	  *total = COSTS_N_INSNS (1);
 	  return false;
@@ -5680,7 +6988,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
       return false;
 
     case PLUS:
-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	{
 	  *total = COSTS_N_INSNS (1);
 	  return false;
@@ -5710,7 +7019,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
       return false;
 
     case NEG:
-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	{
 	  *total = COSTS_N_INSNS (1);
 	  return false;
@@ -5734,7 +7044,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
       return false;
 
     case ABS:
-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
 	*total = COSTS_N_INSNS (1);
       else
 	*total = COSTS_N_INSNS (1 + ARM_NUM_REGS (mode));
@@ -5772,52 +7083,426 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
 	    }
 	}
 
-      if (mode == DImode)
-	*total += COSTS_N_INSNS (1);
+      if (mode == DImode)
+	*total += COSTS_N_INSNS (1);
+
+      return false;
+
+    case CONST_INT:
+      if (const_ok_for_arm (INTVAL (x)))
+	*total = COSTS_N_INSNS (outer_code == SET ? 1 : 0);
+      else if (const_ok_for_arm (~INTVAL (x)))
+	*total = COSTS_N_INSNS (outer_code == AND ? 0 : 1);
+      else if (const_ok_for_arm (-INTVAL (x)))
+	{
+	  if (outer_code == COMPARE || outer_code == PLUS
+	      || outer_code == MINUS)
+	    *total = 0;
+	  else
+	    *total = COSTS_N_INSNS (1);
+	}
+      else
+	*total = COSTS_N_INSNS (2);
+      return true;
+
+    case CONST:
+    case LABEL_REF:
+    case SYMBOL_REF:
+      *total = COSTS_N_INSNS (2);
+      return true;
+
+    case CONST_DOUBLE:
+      *total = COSTS_N_INSNS (4);
+      return true;
+
+    case CONST_VECTOR:
+      if (TARGET_NEON
+	  && TARGET_HARD_FLOAT
+	  && outer_code == SET
+	  && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))
+	  && neon_immediate_valid_for_move (x, mode, NULL, NULL))
+	*total = COSTS_N_INSNS (1);
+      else
+	*total = COSTS_N_INSNS (4);
+      return true;
+
+    case HIGH:
+    case LO_SUM:
+      /* We prefer constant pool entries to MOVW/MOVT pairs, so bump the
+	 cost of these slightly.  */
+      *total = COSTS_N_INSNS (1) + 1;
+      return true;
+
+    default:
+      if (mode != VOIDmode)
+	*total = COSTS_N_INSNS (ARM_NUM_REGS (mode));
+      else
+	*total = COSTS_N_INSNS (4); /* How knows?  */
+      return false;
+    }
+}
+
+static bool
+thumb2_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
+		       int *total)
+{
+  /* Attempt to give a lower cost to RTXs which can optimistically be
+     represented as short insns, assuming that the right conditions will hold
+     later (e.g. low registers will be chosen if a short insn requires them). 
+     
+     Note that we don't make wide insns cost twice as much as narrow insns,
+     because we can't prove that a particular RTX will actually use a narrow
+     insn, because not enough information is available (e.g., we don't know
+     which hard registers pseudos will be assigned).  Consider these to be
+     "expected" sizes/weightings.
+     
+     (COSTS_NARROW_INSNS has the same weight as COSTS_N_INSNS.)  */
+
+#define COSTS_NARROW_INSNS(N) ((N) * 4)
+#define COSTS_WIDE_INSNS(N) ((N) * 6)
+#define THUMB2_LIBCALL_COST COSTS_WIDE_INSNS (2)
+  enum machine_mode mode = GET_MODE (x);
+  
+  switch (code)
+    {
+    case MEM:
+      if (REG_P (XEXP (x, 0)))
+        {
+          /* Hopefully this will use a narrow ldm/stm insn.  */
+	  *total = COSTS_NARROW_INSNS (1);
+	  return true;
+	}
+      else if ((GET_CODE (XEXP (x, 0)) == SYMBOL_REF
+	        && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))
+	       || reg_mentioned_p (virtual_stack_vars_rtx, XEXP (x, 0))
+	       || reg_mentioned_p (stack_pointer_rtx, XEXP (x, 0)))
+	{
+          *total = COSTS_NARROW_INSNS (ARM_NUM_REGS (mode));
+	  return true;
+	}
+      else if (GET_CODE (XEXP (x, 0)) == PLUS)
+	{
+	  rtx plus = XEXP (x, 0);
+
+	  if (GET_CODE (XEXP (plus, 1)) == CONST_INT)
+            {
+	      HOST_WIDE_INT cst = INTVAL (XEXP (plus, 1));
+
+	      if (cst >= 0 && cst < 256)
+		*total = COSTS_NARROW_INSNS (ARM_NUM_REGS (mode));
+	      else
+		*total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
+	
+	      *total += rtx_cost (XEXP (plus, 0), code, false);
+	      
+	      return true;
+	    }
+	}
+
+      *total = COSTS_NARROW_INSNS (ARM_NUM_REGS (mode));
+      return false;
+
+    case DIV:
+    case MOD:
+    case UDIV:
+    case UMOD:
+      if (arm_arch_hwdiv)
+	*total = COSTS_WIDE_INSNS (1);
+      else
+	*total = THUMB2_LIBCALL_COST;
+      return false;
+    
+    case ROTATE:
+      if (mode == SImode && REG_P (XEXP (x, 1)))
+	{
+	  *total = COSTS_WIDE_INSNS (1) + COSTS_NARROW_INSNS (1)
+		   + rtx_cost (XEXP (x, 0), code, false);
+	  return true;
+	}
+      /* Fall through */
+
+    case ASHIFT:
+    case LSHIFTRT:
+    case ASHIFTRT:
+      if (mode == DImode && GET_CODE (XEXP (x, 1)) == CONST_INT)
+	{
+	  *total = COSTS_WIDE_INSNS (3) + rtx_cost (XEXP (x, 0), code, false);
+	  return true;
+	}
+      else if (mode == SImode)
+        {
+	  *total = COSTS_NARROW_INSNS (1);
+	  return false;
+	}
+
+      /* Needs a libcall.  */
+      *total = THUMB2_LIBCALL_COST;
+      return false;
+
+    case ROTATERT:
+      if (mode == DImode && GET_CODE (XEXP (x, 1)) == CONST_INT)
+	{
+	  *total = COSTS_WIDE_INSNS (3) + rtx_cost (XEXP (x, 0), code, false);
+	  return true;
+	}
+      else if (mode == SImode)
+        {
+	  if (GET_CODE (XEXP (x, 1)) == CONST_INT)
+	    *total = COSTS_WIDE_INSNS (1) + rtx_cost (XEXP (x, 0), code, false);
+	  else
+	    *total = COSTS_NARROW_INSNS (1)
+		     + rtx_cost (XEXP (x, 0), code, false);
+	  return true;
+	}
+
+      /* Needs a libcall.  */
+      *total = THUMB2_LIBCALL_COST;
+      return false;
+
+    case MINUS:
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
+	{
+	  *total = COSTS_WIDE_INSNS (1);
+	  return false;
+	}
+
+      if (mode == SImode)
+	{
+	  enum rtx_code subcode0 = GET_CODE (XEXP (x, 0));
+	  enum rtx_code subcode1 = GET_CODE (XEXP (x, 1));
+
+	  if (subcode0 == ROTATE || subcode0 == ROTATERT || subcode0 == ASHIFT
+	      || subcode0 == LSHIFTRT || subcode0 == ASHIFTRT
+	      || subcode1 == ROTATE || subcode1 == ROTATERT
+	      || subcode1 == ASHIFT || subcode1 == LSHIFTRT
+	      || subcode1 == ASHIFTRT)
+	    {
+	      /* It's just the cost of the two operands.  */
+	      *total = 0;
+	      return false;
+	    }
+
+	  if (subcode1 == CONST_INT)
+	    {
+	      HOST_WIDE_INT cst = INTVAL (XEXP (x, 1));
+
+	      if (cst >= 0 && cst < 256)
+		*total = COSTS_NARROW_INSNS (1);
+	      else
+		*total = COSTS_WIDE_INSNS (1);
+
+	      *total += rtx_cost (XEXP (x, 0), code, false);
+
+	      return true;
+	    }
+
+	  *total = COSTS_NARROW_INSNS (1);
+	  return false;
+	}
+
+      *total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
+      return false;
+
+    case PLUS:
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
+	{
+	  *total = COSTS_WIDE_INSNS (1);
+	  return false;
+	}
+
+      /* Fall through */
+    case AND: case XOR: case IOR:
+      if (mode == SImode)
+	{
+	  enum rtx_code subcode = GET_CODE (XEXP (x, 0));
+
+	  if (subcode == ROTATE || subcode == ROTATERT || subcode == ASHIFT
+	      || subcode == LSHIFTRT || subcode == ASHIFTRT
+	      || (code == AND && subcode == NOT))
+	    {
+	      /* It's just the cost of the two operands.  */
+	      *total = 0;
+	      return false;
+	    }
+
+	  if (code == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)
+	    {
+	      HOST_WIDE_INT cst = INTVAL (XEXP (x, 1));
+
+	      if ((reg_mentioned_p (virtual_stack_vars_rtx, XEXP (x, 0))
+		   || reg_mentioned_p (stack_pointer_rtx, XEXP (x, 0)))
+		  && cst > -512 && cst < 1024)
+		/* Only approximately correct, depending on destination
+		   register.  */
+		*total = COSTS_NARROW_INSNS (1);
+	      else if (cst > -256 && cst < 256)
+	        *total = COSTS_NARROW_INSNS (1);
+	      else
+		*total = COSTS_WIDE_INSNS (1);
+
+	      *total += rtx_cost (XEXP (x, 0), code, false);
+
+	      return true;
+	    }
+	  
+	  if (subcode == MULT
+	      && power_of_two_operand (XEXP (XEXP (x, 0), 1), mode))
+	    {
+	      *total = COSTS_WIDE_INSNS (1)
+		       + rtx_cost (XEXP (x, 1), code, false);
+	      return true;
+	    }
+	}
+
+      *total = COSTS_NARROW_INSNS (ARM_NUM_REGS (mode));
+      return false;
+
+    case MULT:
+      if (mode == SImode && GET_CODE (XEXP (x, 1)) != CONST_INT)
+	{
+	  /* Might be using muls.  */
+	  *total = COSTS_NARROW_INSNS (1);
+	  return false;
+	}
+      *total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
+      return false;
+
+    case NEG:
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
+	{
+	  *total = COSTS_WIDE_INSNS (1);
+	  return false;
+	}
+
+      /* Fall through */
+    case NOT:
+      if (mode == SImode)
+        {
+	  *total = COSTS_NARROW_INSNS (1);
+	  return false;
+	}
+      *total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
+      return false;
+
+    case IF_THEN_ELSE:
+      *total = COSTS_NARROW_INSNS (1);
+      return false;
+
+    case COMPARE:
+      if (cc_register (XEXP (x, 0), VOIDmode))
+	*total = 0;
+      else
+	*total = COSTS_NARROW_INSNS (1);
+      return false;
+
+    case ABS:
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
+	*total = COSTS_WIDE_INSNS (1);
+      else
+	*total = COSTS_NARROW_INSNS (ARM_NUM_REGS (mode)) * 2;
+      return false;
+
+    case SIGN_EXTEND:
+      if (GET_MODE_SIZE (mode) <= 4)
+        *total = GET_CODE (XEXP (x, 0)) == MEM ? 0 : COSTS_NARROW_INSNS (1);
+      else
+        *total = COSTS_NARROW_INSNS (1)
+		 + COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
+      return false;
 
+    case ZERO_EXTEND:
+      if (GET_MODE_SIZE (mode) > 4)
+        *total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode) - 1);
+      else if (GET_CODE (XEXP (x, 0)) == MEM)
+        *total = 0;
+      else
+        *total = COSTS_NARROW_INSNS (1);
       return false;
 
     case CONST_INT:
-      if (const_ok_for_arm (INTVAL (x)))
-	*total = COSTS_N_INSNS (outer_code == SET ? 1 : 0);
-      else if (const_ok_for_arm (~INTVAL (x)))
-	*total = COSTS_N_INSNS (outer_code == AND ? 0 : 1);
-      else if (const_ok_for_arm (-INTVAL (x)))
-	{
-	  if (outer_code == COMPARE || outer_code == PLUS
-	      || outer_code == MINUS)
+      {
+	HOST_WIDE_INT cst = INTVAL (x);
+
+	switch (outer_code)
+          {
+	  case PLUS:
+	    if (cst > -256 && cst < 256)
+	      *total = 0;
+	    else
+	      /* See note about optabs below.  */
+	      *total = COSTS_N_INSNS (1);
+	    return true;
+
+	  case MINUS:
+	  case COMPARE:
+	    if (cst >= 0 && cst < 256)
+	      *total = 0;
+	    else
+	      /* See note about optabs below.  */
+	      *total = COSTS_N_INSNS (1);
+	    return true;
+	  
+	  case ASHIFT:
+	  case ASHIFTRT:
+	  case LSHIFTRT:
 	    *total = 0;
-	  else
+	    return true;
+	  
+	  default:
+	    /* Constants are compared explicitly against COSTS_N_INSNS (1) in
+	       optabs.c, creating an alternative, larger code sequence for more
+	       expensive constants).  So, it doesn't pay to make some constants
+	       cost more than this.  */
 	    *total = COSTS_N_INSNS (1);
-	}
-      else
-	*total = COSTS_N_INSNS (2);
-      return true;
+	  }
+	return true;
+      }
 
     case CONST:
     case LABEL_REF:
     case SYMBOL_REF:
-      *total = COSTS_N_INSNS (2);
+      *total = COSTS_WIDE_INSNS (2);
       return true;
 
     case CONST_DOUBLE:
-      *total = COSTS_N_INSNS (4);
+      *total = COSTS_WIDE_INSNS (4);
+      return true;
+
+    case CONST_VECTOR:
+      if (TARGET_NEON
+	  && TARGET_HARD_FLOAT
+	  && outer_code == SET
+	  && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))
+	  && neon_immediate_valid_for_move (x, mode, NULL, NULL))
+	*total = COSTS_WIDE_INSNS (1);
+      else
+	*total = COSTS_WIDE_INSNS (4);
       return true;
 
     case HIGH:
     case LO_SUM:
       /* We prefer constant pool entries to MOVW/MOVT pairs, so bump the
 	 cost of these slightly.  */
-      *total = COSTS_N_INSNS (1) + 1;
+      *total = COSTS_WIDE_INSNS (1) + 1;
       return true;
 
     default:
       if (mode != VOIDmode)
-	*total = COSTS_N_INSNS (ARM_NUM_REGS (mode));
+	*total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
       else
-	*total = COSTS_N_INSNS (4); /* How knows?  */
+	/* A guess (inherited from arm_size_rtx_costs).  */
+	*total = COSTS_WIDE_INSNS (4);
       return false;
     }
+  
+  return true;
+#undef THUMB2_LIBCALL_COST
+#undef COSTS_WIDE_INSNS
+#undef COSTS_NARROW_INSNS
 }
 
 /* RTX costs when optimizing for size.  */
@@ -5826,7 +7511,12 @@ arm_rtx_costs (rtx x, int code, int outer_code, int *total,
 	       bool speed)
 {
   if (!speed)
-    return arm_size_rtx_costs (x, code, outer_code, total);
+    {
+      if (TARGET_THUMB2)
+	return thumb2_size_rtx_costs (x, code, outer_code, total);
+      else
+	return arm_size_rtx_costs (x, code, outer_code, total);
+    }
   else
     return all_cores[(int)arm_tune].rtx_costs (x, code, outer_code, total,
 					       speed);
@@ -5951,7 +7641,9 @@ arm_fastmul_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
 
       if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      return false;
@@ -6108,7 +7800,9 @@ arm_9e_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
 
       if (GET_MODE_CLASS (mode) == MODE_FLOAT)
 	{
-	  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))
+	  if (TARGET_HARD_FLOAT
+	      && (mode == SFmode
+		  || (mode == DFmode && !TARGET_VFP_SINGLE)))
 	    {
 	      *total = COSTS_N_INSNS (1);
 	      return false;
@@ -6454,11 +8148,14 @@ vfp3_const_double_rtx (rtx x)
    vmov  i64    17    aaaaaaaa bbbbbbbb cccccccc dddddddd
                       eeeeeeee ffffffff gggggggg hhhhhhhh
    vmov  f32    18    aBbbbbbc defgh000 00000000 00000000
+   vmov  f32    19    00000000 00000000 00000000 00000000
 
    For case 18, B = !b. Representable values are exactly those accepted by
    vfp3_const_double_index, but are output as floating-point numbers rather
    than indices.
 
+   For case 19, we will change it to vmov.i32 when assembling.
+
    Variants 0-5 (inclusive) may also be used as immediates for the second
    operand of VORR/VBIC instructions.
 
@@ -6501,7 +8198,7 @@ neon_valid_immediate (rtx op, enum machine_mode mode, int inverse,
       rtx el0 = CONST_VECTOR_ELT (op, 0);
       REAL_VALUE_TYPE r0;
 
-      if (!vfp3_const_double_rtx (el0))
+      if (!vfp3_const_double_rtx (el0) && el0 != CONST0_RTX (GET_MODE (el0)))
         return -1;
 
       REAL_VALUE_FROM_CONST_DOUBLE (r0, el0);
@@ -6523,7 +8220,10 @@ neon_valid_immediate (rtx op, enum machine_mode mode, int inverse,
       if (elementwidth)
         *elementwidth = 0;
 
-      return 18;
+      if (el0 == CONST0_RTX (GET_MODE (el0)))
+	return 19;
+      else
+	return 18;
     }
 
   /* Splat vector constant out into a byte vector.  */
@@ -6754,25 +8454,198 @@ neon_pairwise_reduce (rtx op0, rtx op1, enum machine_mode mode,
     }
 }
 
-/* Initialize a vector with non-constant elements.  FIXME: We can do better
-   than the current implementation (building a vector on the stack and then
-   loading it) in many cases.  See rs6000.c.  */
+/* If VALS is a vector constant that can be loaded into a register
+   using VDUP, generate instructions to do so and return an RTX to
+   assign to the register.  Otherwise return NULL_RTX.  */
+
+static rtx
+neon_vdup_constant (rtx vals)
+{
+  enum machine_mode mode = GET_MODE (vals);
+  enum machine_mode inner_mode = GET_MODE_INNER (mode);
+  int n_elts = GET_MODE_NUNITS (mode);
+  bool all_same = true;
+  rtx x;
+  int i;
+
+  if (GET_CODE (vals) != CONST_VECTOR || GET_MODE_SIZE (inner_mode) > 4)
+    return NULL_RTX;
+
+  for (i = 0; i < n_elts; ++i)
+    {
+      x = XVECEXP (vals, 0, i);
+      if (i > 0 && !rtx_equal_p (x, XVECEXP (vals, 0, 0)))
+	all_same = false;
+    }
+
+  if (!all_same)
+    /* The elements are not all the same.  We could handle repeating
+       patterns of a mode larger than INNER_MODE here (e.g. int8x8_t
+       {0, C, 0, C, 0, C, 0, C} which can be loaded using
+       vdup.i16).  */
+    return NULL_RTX;
+
+  /* We can load this constant by using VDUP and a constant in a
+     single ARM register.  This will be cheaper than a vector
+     load.  */
+
+  x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));
+  return gen_rtx_VEC_DUPLICATE (mode, x);
+}
+
+/* Generate code to load VALS, which is a PARALLEL containing only
+   constants (for vec_init) or CONST_VECTOR, efficiently into a
+   register.  Returns an RTX to copy into the register, or NULL_RTX
+   for a PARALLEL that can not be converted into a CONST_VECTOR.  */
+
+rtx
+neon_make_constant (rtx vals)
+{
+  enum machine_mode mode = GET_MODE (vals);
+  rtx target;
+  rtx const_vec = NULL_RTX;
+  int n_elts = GET_MODE_NUNITS (mode);
+  int n_const = 0;
+  int i;
+
+  if (GET_CODE (vals) == CONST_VECTOR)
+    const_vec = vals;
+  else if (GET_CODE (vals) == PARALLEL)
+    {
+      /* A CONST_VECTOR must contain only CONST_INTs and
+	 CONST_DOUBLEs, but CONSTANT_P allows more (e.g. SYMBOL_REF).
+	 Only store valid constants in a CONST_VECTOR.  */
+      for (i = 0; i < n_elts; ++i)
+	{
+	  rtx x = XVECEXP (vals, 0, i);
+	  if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)
+	    n_const++;
+	}
+      if (n_const == n_elts)
+	const_vec = gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0));
+    }
+  else
+    gcc_unreachable ();
+
+  if (const_vec != NULL
+      && neon_immediate_valid_for_move (const_vec, mode, NULL, NULL))
+    /* Load using VMOV.  On Cortex-A8 this takes one cycle.  */
+    return const_vec;
+  else if ((target = neon_vdup_constant (vals)) != NULL_RTX)
+    /* Loaded using VDUP.  On Cortex-A8 the VDUP takes one NEON
+       pipeline cycle; creating the constant takes one or two ARM
+       pipeline cycles.  */
+    return target;
+  else if (const_vec != NULL_RTX)
+    /* Load from constant pool.  On Cortex-A8 this takes two cycles
+       (for either double or quad vectors).  We can not take advantage
+       of single-cycle VLD1 because we need a PC-relative addressing
+       mode.  */
+    return const_vec;
+  else
+    /* A PARALLEL containing something not valid inside CONST_VECTOR.
+       We can not construct an initializer.  */
+    return NULL_RTX;
+}
+
+/* Initialize vector TARGET to VALS.  */
 
 void
 neon_expand_vector_init (rtx target, rtx vals)
 {
   enum machine_mode mode = GET_MODE (target);
-  enum machine_mode inner = GET_MODE_INNER (mode);
-  unsigned int i, n_elts = GET_MODE_NUNITS (mode);
-  rtx mem;
+  enum machine_mode inner_mode = GET_MODE_INNER (mode);
+  int n_elts = GET_MODE_NUNITS (mode);
+  int n_var = 0, one_var = -1;
+  bool all_same = true;
+  rtx x, mem;
+  int i;
+
+  for (i = 0; i < n_elts; ++i)
+    {
+      x = XVECEXP (vals, 0, i);
+      if (!CONSTANT_P (x))
+	++n_var, one_var = i;
+
+      if (i > 0 && !rtx_equal_p (x, XVECEXP (vals, 0, 0)))
+	all_same = false;
+    }
 
-  gcc_assert (VECTOR_MODE_P (mode));
+  if (n_var == 0)
+    {
+      rtx constant = neon_make_constant (vals);
+      if (constant != NULL_RTX)
+	{
+	  emit_move_insn (target, constant);
+	  return;
+	}
+    }
+
+  /* Splat a single non-constant element if we can.  */
+  if (all_same && GET_MODE_SIZE (inner_mode) <= 4)
+    {
+      x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));
+      emit_insn (gen_rtx_SET (VOIDmode, target,
+			      gen_rtx_VEC_DUPLICATE (mode, x)));
+      return;
+    }
+
+  /* One field is non-constant.  Load constant then overwrite varying
+     field.  This is more efficient than using the stack.  */
+  if (n_var == 1)
+    {
+      rtx copy = copy_rtx (vals);
+      rtx index = GEN_INT (one_var);
+
+      /* Load constant part of vector, substitute neighboring value for
+	 varying element.  */
+      XVECEXP (copy, 0, one_var) = XVECEXP (vals, 0, (one_var + 1) % n_elts);
+      neon_expand_vector_init (target, copy);
+
+      /* Insert variable.  */
+      x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, one_var));
+      switch (mode)
+	{
+	case V8QImode:
+	  emit_insn (gen_neon_vset_lanev8qi (target, x, target, index));
+	  break;
+	case V16QImode:
+	  emit_insn (gen_neon_vset_lanev16qi (target, x, target, index));
+	  break;
+	case V4HImode:
+	  emit_insn (gen_neon_vset_lanev4hi (target, x, target, index));
+	  break;
+	case V8HImode:
+	  emit_insn (gen_neon_vset_lanev8hi (target, x, target, index));
+	  break;
+	case V2SImode:
+	  emit_insn (gen_neon_vset_lanev2si (target, x, target, index));
+	  break;
+	case V4SImode:
+	  emit_insn (gen_neon_vset_lanev4si (target, x, target, index));
+	  break;
+	case V2SFmode:
+	  emit_insn (gen_neon_vset_lanev2sf (target, x, target, index));
+	  break;
+	case V4SFmode:
+	  emit_insn (gen_neon_vset_lanev4sf (target, x, target, index));
+	  break;
+	case V2DImode:
+	  emit_insn (gen_neon_vset_lanev2di (target, x, target, index));
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+      return;
+    }
 
+  /* Construct the vector in memory one field at a time
+     and load the whole vector.  */
   mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);
   for (i = 0; i < n_elts; i++)
-    emit_move_insn (adjust_address_nv (mem, inner, i * GET_MODE_SIZE (inner)),
-                   XVECEXP (vals, 0, i));
-
+    emit_move_insn (adjust_address_nv (mem, inner_mode,
+				    i * GET_MODE_SIZE (inner_mode)),
+		    XVECEXP (vals, 0, i));
   emit_move_insn (target, mem);
 }
 
@@ -6931,10 +8804,13 @@ arm_coproc_mem_operand (rtx op, bool wb)
 }
 
 /* Return TRUE if OP is a memory operand which we can load or store a vector
-   to/from. If CORE is true, we're moving from ARM registers not Neon
-   registers.  */
+   to/from. TYPE is one of the following values:
+    0 - Vector load/stor (vldr)
+    1 - Core registers (ldm)
+    2 - Element/structure loads (vld1)
+ */
 int
-neon_vector_mem_operand (rtx op, bool core)
+neon_vector_mem_operand (rtx op, int type)
 {
   rtx ind;
 
@@ -6967,23 +8843,16 @@ neon_vector_mem_operand (rtx op, bool core)
     return arm_address_register_rtx_p (ind, 0);
 
   /* Allow post-increment with Neon registers.  */
-  if (!core && GET_CODE (ind) == POST_INC)
+  if ((type != 1 && GET_CODE (ind) == POST_INC)
+      || (type == 0 && GET_CODE (ind) == PRE_DEC))
     return arm_address_register_rtx_p (XEXP (ind, 0), 0);
 
-#if 0
-  /* FIXME: We can support this too if we use VLD1/VST1.  */
-  if (!core
-      && GET_CODE (ind) == POST_MODIFY
-      && arm_address_register_rtx_p (XEXP (ind, 0), 0)
-      && GET_CODE (XEXP (ind, 1)) == PLUS
-      && rtx_equal_p (XEXP (XEXP (ind, 1), 0), XEXP (ind, 0)))
-    ind = XEXP (ind, 1);
-#endif
+  /* FIXME: vld1 allows register post-modify.  */
 
   /* Match:
      (plus (reg)
           (const)).  */
-  if (!core
+  if (type == 0
       && GET_CODE (ind) == PLUS
       && GET_CODE (XEXP (ind, 0)) == REG
       && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)
@@ -7050,10 +8919,19 @@ arm_eliminable_register (rtx x)
 enum reg_class
 coproc_secondary_reload_class (enum machine_mode mode, rtx x, bool wb)
 {
+  if (mode == HFmode)
+    {
+      if (!TARGET_NEON_FP16)
+	return GENERAL_REGS;
+      if (s_register_operand (x, mode) || neon_vector_mem_operand (x, 2))
+	return NO_REGS;
+      return GENERAL_REGS;
+    }
+
   if (TARGET_NEON
       && (GET_MODE_CLASS (mode) == MODE_VECTOR_INT
           || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)
-      && neon_vector_mem_operand (x, FALSE))
+      && neon_vector_mem_operand (x, 0))
      return NO_REGS;
 
   if (arm_coproc_mem_operand (x, wb) || s_register_operand (x, mode))
@@ -7413,7 +9291,7 @@ adjacent_mem_locations (rtx a, rtx b)
       /* Don't accept any offset that will require multiple
 	 instructions to handle, since this would cause the
 	 arith_adjacentmem pattern to output an overlong sequence.  */
-      if (!const_ok_for_op (PLUS, val0) || !const_ok_for_op (PLUS, val1))
+      if (!const_ok_for_op (val0, PLUS) || !const_ok_for_op (val1, PLUS))
 	return 0;
 
       /* Don't allow an eliminable register: register elimination can make
@@ -7450,6 +9328,9 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,
   int base_reg = -1;
   int i;
 
+  if (low_irq_latency)
+    return 0;
+
   /* Can only handle 2, 3, or 4 insns at present,
      though could be easily extended if required.  */
   gcc_assert (nops >= 2 && nops <= 4);
@@ -7679,6 +9560,9 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,
   int base_reg = -1;
   int i;
 
+  if (low_irq_latency)
+    return 0;
+
   /* Can only handle 2, 3, or 4 insns at present, though could be easily
      extended if required.  */
   gcc_assert (nops >= 2 && nops <= 4);
@@ -7886,7 +9770,7 @@ arm_gen_load_multiple (int base_regno, int count, rtx from, int up,
 
      As a compromise, we use ldr for counts of 1 or 2 regs, and ldm
      for counts of 3 or 4 regs.  */
-  if (arm_tune_xscale && count <= 2 && ! optimize_size)
+  if (low_irq_latency || (arm_tune_xscale && count <= 2 && ! optimize_size))
     {
       rtx seq;
 
@@ -7949,7 +9833,7 @@ arm_gen_store_multiple (int base_regno, int count, rtx to, int up,
 
   /* See arm_gen_load_multiple for discussion of
      the pros/cons of ldm/stm usage for XScale.  */
-  if (arm_tune_xscale && count <= 2 && ! optimize_size)
+  if (low_irq_latency || (arm_tune_xscale && count <= 2 && ! optimize_size))
     {
       rtx seq;
 
@@ -8420,6 +10304,55 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)
       && (rtx_equal_p (XEXP (x, 0), y) || rtx_equal_p (XEXP (x, 1), y)))
     return CC_Cmode;
 
+  if (GET_MODE (x) == DImode || GET_MODE (y) == DImode)
+    {
+      /* To keep things simple, always use the Cirrus cfcmp64 if it is
+	 available.  */
+      if (TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK)
+	return CCmode;
+
+      switch (op)
+	{
+	case EQ:
+	case NE:
+	  /* A DImode comparison against zero can be implemented by
+	     or'ing the two halves together.  */
+	  if (y == const0_rtx)
+	    return CC_Zmode;
+
+	  /* We can do an equality test in three Thumb instructions.  */
+	  if (!TARGET_ARM)
+	    return CC_Zmode;
+
+	  /* FALLTHROUGH */
+
+	case LTU:
+	case LEU:
+	case GTU:
+	case GEU:
+	  /* DImode unsigned comparisons can be implemented by cmp +
+	     cmpeq without a scratch register.  Not worth doing in
+	     Thumb-2.  */
+	  if (TARGET_ARM)
+	    return CC_CZmode;
+
+	  /* FALLTHROUGH */
+
+	case LT:
+	case LE:
+	case GT:
+	case GE:
+	  /* DImode signed and unsigned comparisons can be implemented
+	     by cmp + sbcs with a scratch register, but that does not
+	     set the Z flag - we must reverse GT/LE/GTU/LEU.  */
+	  gcc_assert (op != EQ && op != NE);
+	  return CC_NCVmode;
+
+	default:
+	  gcc_unreachable ();
+	}
+    }
+
   return CCmode;
 }
 
@@ -8429,10 +10362,39 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)
 rtx
 arm_gen_compare_reg (enum rtx_code code, rtx x, rtx y)
 {
-  enum machine_mode mode = SELECT_CC_MODE (code, x, y);
-  rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);
+  enum machine_mode mode;
+  rtx cc_reg;
+  int dimode_comparison = GET_MODE (x) == DImode || GET_MODE (y) == DImode;
 
-  emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));
+  /* We might have X as a constant, Y as a register because of the predicates
+     used for cmpdi.  If so, force X to a register here.  */
+  if (dimode_comparison && !REG_P (x))
+    x = force_reg (DImode, x);
+
+  mode = SELECT_CC_MODE (code, x, y);
+  cc_reg = gen_rtx_REG (mode, CC_REGNUM);
+
+  if (dimode_comparison
+      && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)
+      && mode != CC_CZmode)
+    {
+      rtx clobber, set;
+
+      /* To compare two non-zero values for equality, XOR them and
+	 then compare against zero.  Not used for ARM mode; there
+	 CC_CZmode is cheaper.  */
+      if (mode == CC_Zmode && y != const0_rtx)
+	{
+	  x = expand_binop (DImode, xor_optab, x, y, NULL_RTX, 0, OPTAB_WIDEN);
+	  y = const0_rtx;
+	}
+      /* A scratch register is required.  */
+      clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (SImode));
+      set = gen_rtx_SET (VOIDmode, cc_reg, gen_rtx_COMPARE (mode, x, y));
+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber)));
+    }
+  else
+    emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));
 
   return cc_reg;
 }
@@ -9567,7 +11529,10 @@ create_fix_barrier (Mfix *fix, HOST_WIDE_INT max_address)
       gcc_assert (GET_CODE (from) != BARRIER);
 
       /* Count the length of this insn.  */
-      count += get_attr_length (from);
+      if (LABEL_P (from) && (align_jumps > 0 || align_loops > 0))
+        count += MAX (align_jumps, align_loops);
+      else
+        count += get_attr_length (from);
 
       /* If there is a jump table, add its length.  */
       tmp = is_jump_table (from);
@@ -9761,6 +11726,34 @@ arm_const_double_by_parts (rtx val)
   return false;
 }
 
+/* Return true if it is possible to inline both the high and low parts
+   of a 64-bit constant into 32-bit data processing instructions.  */
+bool
+arm_const_double_by_immediates (rtx val)
+{
+  enum machine_mode mode = GET_MODE (val);
+  rtx part;
+
+  if (mode == VOIDmode)
+    mode = DImode;
+
+  part = gen_highpart_mode (SImode, mode, val);
+
+  gcc_assert (GET_CODE (part) == CONST_INT);
+
+  if (!const_ok_for_arm (INTVAL (part)))
+    return false;
+
+  part = gen_lowpart (SImode, val);
+
+  gcc_assert (GET_CODE (part) == CONST_INT);
+
+  if (!const_ok_for_arm (INTVAL (part)))
+    return false;
+
+  return true;
+}
+
 /* Scan INSN and note any of its operands that need fixing.
    If DO_PUSHES is false we do not actually push any of the fixups
    needed.  The function returns TRUE if any fixups were needed/pushed.
@@ -9879,6 +11872,8 @@ arm_reorg (void)
 	      insn = table;
 	    }
 	}
+      else if (LABEL_P (insn) && (align_jumps > 0 || align_loops > 0))
+	address += MAX (align_jumps, align_loops);
     }
 
   fix = minipool_fix_head;
@@ -10084,6 +12079,21 @@ static void
 vfp_output_fldmd (FILE * stream, unsigned int base, int reg, int count)
 {
   int i;
+  int offset;
+
+  if (low_irq_latency)
+    {
+      /* Output a sequence of FLDD instructions.  */
+      offset = 0;
+      for (i = reg; i < reg + count; ++i, offset += 8)
+	{
+	  fputc ('\t', stream);
+	  asm_fprintf (stream, "fldd\td%d, [%r,#%d]\n", i, base, offset);
+	}
+      asm_fprintf (stream, "\tadd\tsp, sp, #%d\n", count * 8);
+      return;
+    }
+
 
   /* Workaround ARM10 VFPr1 bug.  */
   if (count == 2 && !arm_arch6)
@@ -10154,6 +12164,56 @@ vfp_emit_fstmd (int base_reg, int count)
   rtx tmp, reg;
   int i;
 
+  if (low_irq_latency)
+    {
+      int saved_size;
+      rtx sp_insn;
+
+      if (!count)
+	return 0;
+
+      saved_size = count * GET_MODE_SIZE (DFmode);
+
+      /* Since fstd does not have postdecrement addressing mode,
+	 we first decrement stack pointer and then use base+offset
+	 stores for VFP registers. The ARM EABI unwind information 
+	 can't easily describe base+offset loads, so we attach
+	 a note for the effects of the whole block in the first insn, 
+	 and  avoid marking the subsequent instructions 
+	 with RTX_FRAME_RELATED_P.  */
+      sp_insn = gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
+			    GEN_INT (-saved_size));
+      sp_insn = emit_insn (sp_insn);
+      RTX_FRAME_RELATED_P (sp_insn) = 1;
+
+      dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (count + 1));
+      XVECEXP (dwarf, 0, 0) = 
+	gen_rtx_SET (VOIDmode, stack_pointer_rtx,
+		     plus_constant (stack_pointer_rtx, -saved_size));
+      
+      /* push double VFP registers to stack */
+      for (i = 0; i < count; ++i )
+	{
+	  rtx reg;
+	  rtx mem;
+	  rtx addr;
+	  rtx insn;
+	  reg = gen_rtx_REG (DFmode, base_reg + 2*i);
+	  addr = (i == 0) ? stack_pointer_rtx
+	    : gen_rtx_PLUS (SImode, stack_pointer_rtx,
+			    GEN_INT (i * GET_MODE_SIZE (DFmode)));
+	  mem = gen_frame_mem (DFmode, addr);
+	  insn = emit_move_insn (mem, reg);
+	  XVECEXP (dwarf, 0, i+1) = 
+	    gen_rtx_SET (VOIDmode, mem, reg);
+	}
+
+      REG_NOTES (sp_insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,
+					       REG_NOTES (sp_insn));
+      
+      return saved_size;
+    }
+
   /* Workaround ARM10 VFPr1 bug.  Data corruption can occur when exactly two
      register pairs are stored by a store multiple insn.  We avoid this
      by pushing an extra pair.  */
@@ -10704,13 +12764,13 @@ output_move_double (rtx *operands)
 	    {
 	      if (GET_CODE (XEXP (operands[0], 0)) == PRE_MODIFY)
 		{
-		  output_asm_insn ("ldr%?\t%0, [%1, %2]!", otherops);
-		  output_asm_insn ("ldr%?\t%H0, [%1, #4]", otherops);
+		  output_asm_insn ("str%?\t%0, [%1, %2]!", otherops);
+		  output_asm_insn ("str%?\t%H0, [%1, #4]", otherops);
 		}
 	      else
 		{
-		  output_asm_insn ("ldr%?\t%H0, [%1, #4]", otherops);
-		  output_asm_insn ("ldr%?\t%0, [%1], %2", otherops);
+		  output_asm_insn ("str%?\t%H0, [%1, #4]", otherops);
+		  output_asm_insn ("str%?\t%0, [%1], %2", otherops);
 		}
 	    }
 	  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_MODIFY)
@@ -10768,7 +12828,7 @@ output_move_double (rtx *operands)
 }
 
 /* Output a move, load or store for quad-word vectors in ARM registers.  Only
-   handles MEMs accepted by neon_vector_mem_operand with CORE=true.  */
+   handles MEMs accepted by neon_vector_mem_operand with TYPE=1.  */
 
 const char *
 output_move_quad (rtx *operands)
@@ -10964,6 +13024,12 @@ output_move_neon (rtx *operands)
       ops[1] = reg;
       break;
 
+    case PRE_DEC:
+      templ = "v%smdb%%?\t%%0!, %%h1";
+      ops[0] = XEXP (addr, 0);
+      ops[1] = reg;
+      break;
+    
     case POST_MODIFY:
       /* FIXME: Not currently enabled in neon_vector_mem_operand.  */
       gcc_unreachable ();
@@ -11013,6 +13079,57 @@ output_move_neon (rtx *operands)
   return "";
 }
 
+/* Compute and return the length of neon_mov<mode>, where <mode> is
+   one of VSTRUCT modes: EI, OI, CI or XI.  */
+int
+arm_attr_length_move_neon (rtx insn)
+{
+  rtx reg, mem, addr;
+  int regno, load;
+  enum machine_mode mode;
+
+  extract_insn_cached (insn);
+
+  if (REG_P (recog_data.operand[0]) && REG_P (recog_data.operand[1]))
+    {
+      mode = GET_MODE (recog_data.operand[0]);
+      switch (mode)
+	{
+	case EImode:
+	case OImode:
+	  return 8;
+	case CImode:
+	  return 12;
+	case XImode:
+	  return 16;
+	default:
+	  gcc_unreachable ();
+	}
+    }
+
+  load = REG_P (recog_data.operand[0]);
+  reg = recog_data.operand[!load];
+  mem = recog_data.operand[load];
+
+  gcc_assert (MEM_P (mem));
+
+  mode = GET_MODE (reg);
+  regno = REGNO (reg);
+  addr = XEXP (mem, 0);
+
+  /* Strip off const from addresses like (const (plus (...))).  */
+  if (GET_CODE (addr) == CONST && GET_CODE (XEXP (addr, 0)) == PLUS)
+    addr = XEXP (addr, 0);
+
+  if (GET_CODE (addr) == LABEL_REF || GET_CODE (addr) == PLUS)
+    {
+      int insns = HARD_REGNO_NREGS (REGNO (reg), mode) / 2;
+      return insns * 4;
+    }
+  else
+    return 4;
+}
+
 /* Output an ADD r, s, #n where n may be too big for one instruction.
    If adding zero to one register, output nothing.  */
 const char *
@@ -11319,6 +13436,20 @@ arm_compute_save_reg0_reg12_mask (void)
 	  && crtl->uses_pic_offset_table)
 	save_reg_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;
     }
+  else if (IS_VOLATILE(func_type))
+    {
+      /* For noreturn functions we historically omitted register saves
+	 altogether.  However this really messes up debugging.  As a
+	 compromise save just the fame pointers.  Combined with the link
+	 register saved elsewhere this should be sufficient to get
+	 a backtrace.  */
+      if (frame_pointer_needed)
+	save_reg_mask |= 1 << HARD_FRAME_POINTER_REGNUM;
+      if (df_regs_ever_live_p (ARM_HARD_FRAME_POINTER_REGNUM))
+	save_reg_mask |= 1 << ARM_HARD_FRAME_POINTER_REGNUM;
+      if (df_regs_ever_live_p (THUMB_HARD_FRAME_POINTER_REGNUM))
+	save_reg_mask |= 1 << THUMB_HARD_FRAME_POINTER_REGNUM;
+    }
   else
     {
       /* In the normal case we only need to save those registers
@@ -11405,11 +13536,6 @@ arm_compute_save_reg_mask (void)
       | (1 << LR_REGNUM)
       | (1 << PC_REGNUM);
 
-  /* Volatile functions do not return, so there
-     is no need to save any other registers.  */
-  if (IS_VOLATILE (func_type))
-    return save_reg_mask;
-
   save_reg_mask |= arm_compute_save_reg0_reg12_mask ();
 
   /* Decide if we need to save the link register.
@@ -11567,7 +13693,7 @@ arm_get_vfp_saved_size (void)
 	      if (count > 0)
 		{
 		  /* Workaround ARM10 VFPr1 bug.  */
-		  if (count == 2 && !arm_arch6)
+		  if (count == 2 && !arm_arch6 && !low_irq_latency)
 		    count++;
 		  saved += count * 8;
 		}
@@ -11707,8 +13833,10 @@ output_return_instruction (rtx operand, int really_return, int reverse)
 		  sprintf (instr, "ldm%sfd\t%%|sp, {", conditional);
 		}
 	    }
-	  else
+	  else if (TARGET_ARM)
 	    sprintf (instr, "ldm%sfd\t%%|sp!, {", conditional);
+	  else
+	    sprintf (instr, "pop\t{");
 
 	  p = instr + strlen (instr);
 
@@ -11896,6 +14024,41 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)
   return_used_this_function = 0;
 }
 
+/* Generate to STREAM a code sequence that pops registers identified 
+   in REGS_MASK from SP. SP is incremented as the result.
+*/
+static void
+print_pop_reg_by_ldr (FILE *stream, int regs_mask, int rfe)
+{
+  int reg;
+
+  gcc_assert (! (regs_mask & (1 << SP_REGNUM)));
+  
+  for (reg = 0; reg < PC_REGNUM; ++reg)
+    if (regs_mask & (1 << reg))
+      asm_fprintf (stream, "\tldr\t%r, [%r], #4\n",
+		   reg, SP_REGNUM); 
+
+  if (regs_mask & (1 << PC_REGNUM))
+    {
+      if (rfe)
+	/* When returning from exception, we need to
+	   copy SPSR to CPSR.  There are two ways to do
+	   that: the ldm instruction with "^" suffix,
+	   and movs instruction.  The latter would
+	   require that we load from stack to some
+	   scratch register, and then move to PC.
+	   Therefore, we'd need extra instruction and
+	   have to make sure we actually have a spare
+	   register.  Using ldm with a single register
+	   is simler.  */
+	asm_fprintf (stream, "\tldm\tsp!, {pc}^\n");
+      else
+	asm_fprintf (stream, "\tldr\t%r, [%r], #4\n",
+		     PC_REGNUM, SP_REGNUM); 
+    }
+}
+
 const char *
 arm_output_epilogue (rtx sibling)
 {
@@ -11956,7 +14119,7 @@ arm_output_epilogue (rtx sibling)
       /* This variable is for the Virtual Frame Pointer, not VFP regs.  */
       int vfp_offset = offsets->frame;
 
-      if (arm_fpu_arch == FPUTYPE_FPA_EMU2)
+      if (TARGET_FPA_EMU2)
 	{
 	  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)
 	    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])
@@ -12180,7 +14343,7 @@ arm_output_epilogue (rtx sibling)
 			 SP_REGNUM, HARD_FRAME_POINTER_REGNUM);
 	}
 
-      if (arm_fpu_arch == FPUTYPE_FPA_EMU2)
+      if (TARGET_FPA_EMU2)
 	{
 	  for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)
 	    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])
@@ -12221,24 +14384,29 @@ arm_output_epilogue (rtx sibling)
 
       if (TARGET_HARD_FLOAT && TARGET_VFP)
 	{
-	  start_reg = FIRST_VFP_REGNUM;
-	  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)
+	  int end_reg = LAST_VFP_REGNUM + 1;
+
+	  /* Scan the registers in reverse order.  We need to match
+	     any groupings made in the prologue and generate matching
+	     pop operations.  */
+	  for (reg = LAST_VFP_REGNUM - 1; reg >= FIRST_VFP_REGNUM; reg -= 2)
 	    {
 	      if ((!df_regs_ever_live_p (reg) || call_used_regs[reg])
-		  && (!df_regs_ever_live_p (reg + 1) || call_used_regs[reg + 1]))
+		  && (!df_regs_ever_live_p (reg + 1)
+		      || call_used_regs[reg + 1]))
 		{
-		  if (start_reg != reg)
+		  if (end_reg > reg + 2)
 		    vfp_output_fldmd (f, SP_REGNUM,
-				      (start_reg - FIRST_VFP_REGNUM) / 2,
-				      (reg - start_reg) / 2);
-		  start_reg = reg + 2;
+				      (reg + 2 - FIRST_VFP_REGNUM) / 2,
+				      (end_reg - (reg + 2)) / 2);
+		  end_reg = reg;
 		}
 	    }
-	  if (start_reg != reg)
-	    vfp_output_fldmd (f, SP_REGNUM,
-			      (start_reg - FIRST_VFP_REGNUM) / 2,
-			      (reg - start_reg) / 2);
+	  if (end_reg > reg + 2)
+	    vfp_output_fldmd (f, SP_REGNUM, 0,
+			      (end_reg - (reg + 2)) / 2);
 	}
+
       if (TARGET_IWMMXT)
 	for (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)
 	  if (df_regs_ever_live_p (reg) && !call_used_regs[reg])
@@ -12264,22 +14432,19 @@ arm_output_epilogue (rtx sibling)
 	 to load use the LDR instruction - it is faster.  For Thumb-2
 	 always use pop and the assembler will pick the best instruction.*/
       if (TARGET_ARM && saved_regs_mask == (1 << LR_REGNUM)
-	  && !IS_INTERRUPT(func_type))
+	  && !IS_INTERRUPT (func_type))
 	{
 	  asm_fprintf (f, "\tldr\t%r, [%r], #4\n", LR_REGNUM, SP_REGNUM);
 	}
       else if (saved_regs_mask)
 	{
-	  if (saved_regs_mask & (1 << SP_REGNUM))
-	    /* Note - write back to the stack register is not enabled
-	       (i.e. "ldmfd sp!...").  We know that the stack pointer is
-	       in the list of registers and if we add writeback the
-	       instruction becomes UNPREDICTABLE.  */
-	    print_multi_reg (f, "ldmfd\t%r, ", SP_REGNUM, saved_regs_mask,
-			     rfe);
-	  else if (TARGET_ARM)
-	    print_multi_reg (f, "ldmfd\t%r!, ", SP_REGNUM, saved_regs_mask,
-			     rfe);
+	  gcc_assert ( ! (saved_regs_mask & (1 << SP_REGNUM)));
+	  if (TARGET_ARM)
+	    if (low_irq_latency)
+	      print_pop_reg_by_ldr (f, saved_regs_mask, rfe);
+	    else
+	      print_multi_reg (f, "ldmfd\t%r!, ", SP_REGNUM, saved_regs_mask,
+			       rfe);
 	  else
 	    print_multi_reg (f, "pop\t", SP_REGNUM, saved_regs_mask, 0);
 	}
@@ -12400,6 +14565,32 @@ emit_multi_reg_push (unsigned long mask)
 
   gcc_assert (num_regs && num_regs <= 16);
 
+  if (low_irq_latency)
+    {
+      rtx insn = 0;
+
+      /* Emit a series of ldr instructions rather rather than a single ldm.  */
+      /* TODO: Use ldrd where possible.  */
+      gcc_assert (! (mask & (1 << SP_REGNUM)));
+
+      for (i = LAST_ARM_REGNUM; i >= 0; --i)
+        {
+          if (mask & (1 << i))
+
+            {
+              rtx reg, where, mem;
+
+	      reg = gen_rtx_REG (SImode, i);
+	      where = gen_rtx_PRE_DEC (SImode, stack_pointer_rtx);
+	      mem = gen_rtx_MEM (SImode, where);
+	      insn = emit_move_insn (mem, reg);
+	      RTX_FRAME_RELATED_P (insn) = 1;
+            }
+        }
+
+      return insn;
+    }
+
   /* We don't record the PC in the dwarf frame information.  */
   num_dwarf_regs = num_regs;
   if (mask & (1 << PC_REGNUM))
@@ -12748,22 +14939,23 @@ arm_get_frame_offsets (void)
 	{
 	  int reg = -1;
 
-	  for (i = 4; i <= (TARGET_THUMB1 ? LAST_LO_REGNUM : 11); i++)
-	    {
-	      if ((offsets->saved_regs_mask & (1 << i)) == 0)
-		{
-		  reg = i;
-		  break;
-		}
-	    }
-
-	  if (reg == -1 && arm_size_return_regs () <= 12
-	      && !crtl->tail_call_emit)
+	  /* If it is safe to use r3, then do so.  This sometimes 
+	     generates better code on Thumb-2 by avoiding the need to
+	     use 32-bit push/pop instructions.  */
+	  if (!crtl->tail_call_emit
+	      && arm_size_return_regs () <= 12)
 	    {
-	      /* Push/pop an argument register (r3) if all callee saved
-	         registers are already being pushed.  */
 	      reg = 3;
 	    }
+	  else
+	    for (i = 4; i <= (TARGET_THUMB1 ? LAST_LO_REGNUM : 11); i++)
+	      {
+		if ((offsets->saved_regs_mask & (1 << i)) == 0)
+		  {
+		    reg = i;
+		    break;
+		  }
+	      }
 
 	  if (reg != -1)
 	    {
@@ -12887,7 +15079,7 @@ arm_save_coproc_regs(void)
 
   /* Save any floating point call-saved registers used by this
      function.  */
-  if (arm_fpu_arch == FPUTYPE_FPA_EMU2)
+  if (TARGET_FPA_EMU2)
     {
       for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)
 	if (df_regs_ever_live_p (reg) && !call_used_regs[reg])
@@ -13431,6 +15623,7 @@ arm_print_operand (FILE *stream, rtx x, int code)
 	  fprintf (stream, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));
 	  break;
 
+	case CONST:
 	case SYMBOL_REF:
 	  output_addr_const (stream, x);
 	  break;
@@ -13494,7 +15687,11 @@ arm_print_operand (FILE *stream, rtx x, int code)
 	  {
 	    fprintf (stream, ", %s ", shift);
 	    if (val == -1)
-	      arm_print_operand (stream, XEXP (x, 1), 0);
+              {
+	        arm_print_operand (stream, XEXP (x, 1), 0);
+                if (janus2_code)
+                  fprintf(stream, "\n\tnop");
+              }
 	    else
 	      fprintf (stream, "#" HOST_WIDE_INT_PRINT_DEC, val);
 	  }
@@ -13527,8 +15724,18 @@ arm_print_operand (FILE *stream, rtx x, int code)
 	 the value being loaded is big-wordian or little-wordian.  The
 	 order of the two register loads can matter however, if the address
 	 of the memory location is actually held in one of the registers
-	 being overwritten by the load.  */
+	 being overwritten by the load.
+
+	 The 'Q' and 'R' constraints are also available for 64-bit
+	 constants.  */
     case 'Q':
+      if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)
+	{
+	  rtx part = gen_lowpart (SImode, x);
+	  fprintf (stream, "#" HOST_WIDE_INT_PRINT_DEC, INTVAL (part));
+	  return;
+	}
+
       if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)
 	{
 	  output_operand_lossage ("invalid operand for code '%c'", code);
@@ -13539,6 +15746,18 @@ arm_print_operand (FILE *stream, rtx x, int code)
       return;
 
     case 'R':
+      if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)
+	{
+	  enum machine_mode mode = GET_MODE (x);
+	  rtx part;
+
+	  if (mode == VOIDmode)
+	    mode = DImode;
+	  part = gen_highpart_mode (SImode, mode, x);
+	  fprintf (stream, "#" HOST_WIDE_INT_PRINT_DEC, INTVAL (part));
+	  return;
+	}
+
       if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)
 	{
 	  output_operand_lossage ("invalid operand for code '%c'", code);
@@ -13715,6 +15934,30 @@ arm_print_operand (FILE *stream, rtx x, int code)
 	}
       return;
 
+    /* Print the high single-precision register of a VFP double-precision
+       register.  */
+    case 'p':
+      {
+        int mode = GET_MODE (x);
+        int regno;
+
+        if (GET_MODE_SIZE (mode) != 8 || GET_CODE (x) != REG)
+          {
+	    output_operand_lossage ("invalid operand for code '%c'", code);
+	    return;
+          }
+
+        regno = REGNO (x);
+        if (!VFP_REGNO_OK_FOR_DOUBLE (regno))
+          {
+	    output_operand_lossage ("invalid operand for code '%c'", code);
+	    return;
+          }
+
+	fprintf (stream, "s%d", regno - FIRST_VFP_REGNUM + 1);
+      }
+      return;
+
     /* Print a VFP/Neon double precision or quad precision register name.  */
     case 'P':
     case 'q':
@@ -13832,6 +16075,81 @@ arm_print_operand (FILE *stream, rtx x, int code)
       }
       return;
 
+    /* Memory operand for vld1/vst1 instruction.  */
+    case 'A':
+      {
+	rtx addr;
+	bool postinc = FALSE;
+	unsigned align;
+
+	gcc_assert (GET_CODE (x) == MEM);
+	addr = XEXP (x, 0);
+	if (GET_CODE (addr) == POST_INC)
+	  {
+	    postinc = 1;
+	    addr = XEXP (addr, 0);
+	  }
+	align = MEM_ALIGN (x) >> 3;
+	asm_fprintf (stream, "[%r", REGNO (addr));
+	if (align > GET_MODE_SIZE (GET_MODE (x)))
+	  align = GET_MODE_SIZE (GET_MODE (x));
+	if (align >= 8)
+	  asm_fprintf (stream, ", :%d", align << 3);
+	asm_fprintf (stream, "]");
+	if (postinc)
+	  fputs("!", stream);
+      }
+      return;
+
+    /* Translate an S register number into a D register number and element index.  */
+    case 'y':
+      {
+        int mode = GET_MODE (x);
+        int regno;
+
+        if (GET_MODE_SIZE (mode) != 4 || GET_CODE (x) != REG)
+          {
+	    output_operand_lossage ("invalid operand for code '%c'", code);
+	    return;
+          }
+
+        regno = REGNO (x);
+        if (!VFP_REGNO_OK_FOR_SINGLE (regno))
+          {
+	    output_operand_lossage ("invalid operand for code '%c'", code);
+	    return;
+          }
+
+	regno = regno - FIRST_VFP_REGNUM;
+	fprintf (stream, "d%d[%d]", regno / 2, regno % 2);
+      }
+      return;
+
+    /* Register specifier for vld1.16/vst1.16.  Translate the S register
+       number into a D register number and element index.  */
+    case 'z':
+      {
+        int mode = GET_MODE (x);
+        int regno;
+
+        if (GET_MODE_SIZE (mode) != 2 || GET_CODE (x) != REG)
+          {
+	    output_operand_lossage ("invalid operand for code '%c'", code);
+	    return;
+          }
+
+        regno = REGNO (x);
+        if (!VFP_REGNO_OK_FOR_SINGLE (regno))
+          {
+	    output_operand_lossage ("invalid operand for code '%c'", code);
+	    return;
+          }
+
+	regno = regno - FIRST_VFP_REGNUM;
+	fprintf (stream, "d%d[%d]", regno/2, ((regno % 2) ? 2 : 0));
+      }
+      return;
+      
     default:
       if (x == 0)
 	{
@@ -13865,6 +16183,12 @@ arm_print_operand (FILE *stream, rtx x, int code)
 	default:
 	  gcc_assert (GET_CODE (x) != NEG);
 	  fputc ('#', stream);
+	  if (GET_CODE (x) == HIGH)
+	    {
+	      fputs (":lower16:", stream);
+	      x = XEXP (x, 0);
+	    }
+	    
 	  output_addr_const (stream, x);
 	  break;
 	}
@@ -14134,6 +16458,28 @@ get_arm_condition_code (rtx comparison)
       default: gcc_unreachable ();
       }
 
+    case CC_CZmode:
+      switch (comp_code)
+	{
+	case NE: return ARM_NE;
+	case EQ: return ARM_EQ;
+	case GEU: return ARM_CS;
+	case GTU: return ARM_HI;
+	case LEU: return ARM_LS;
+	case LTU: return ARM_CC;
+	default: gcc_unreachable ();
+	}
+
+    case CC_NCVmode:
+      switch (comp_code)
+	{
+	case GE: return ARM_GE;
+	case LT: return ARM_LT;
+	case GEU: return ARM_CS;
+	case LTU: return ARM_CC;
+	default: gcc_unreachable ();
+	}
+
     case CCmode:
       switch (comp_code)
 	{
@@ -14256,6 +16602,10 @@ arm_final_prescan_insn (rtx insn)
      first insn after the following code_label if REVERSE is true.  */
   rtx start_insn = insn;
 
+  /* Don't do this if we're not considering conditional execution.  */
+  if (TARGET_NO_SINGLE_COND_EXEC)
+    return;
+
   /* If in state 4, check if the target branch is reached, in order to
      change back to state 0.  */
   if (arm_ccfsm_state == 4)
@@ -14629,6 +16979,11 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)
       if (mode == DFmode)
 	return VFP_REGNO_OK_FOR_DOUBLE (regno);
 
+      /* VFP registers can hold HFmode values, but there is no point in
+	 putting them there unless we have hardware conversion insns. */
+      if (mode == HFmode)
+	return TARGET_FP16 && VFP_REGNO_OK_FOR_SINGLE (regno);
+
       if (TARGET_NEON)
         return (VALID_NEON_DREG_MODE (mode) && VFP_REGNO_OK_FOR_DOUBLE (regno))
                || (VALID_NEON_QREG_MODE (mode)
@@ -14648,16 +17003,16 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)
 	return mode == SImode;
 
       if (IS_IWMMXT_REGNUM (regno))
-	return VALID_IWMMXT_REG_MODE (mode);
+	return VALID_IWMMXT_REG_MODE (mode) && mode != SImode;
     }
   
-  /* We allow any value to be stored in the general registers.
+  /* We allow almost any value to be stored in the general registers.
      Restrict doubleword quantities to even register pairs so that we can
-     use ldrd.  Do not allow Neon structure opaque modes in general registers;
-     they would use too many.  */
+     use ldrd.  Do not allow very large Neon structure opaque modes in
+     general registers; they would use too many.  */
   if (regno <= LAST_ARM_REGNUM)
     return !(TARGET_LDRD && GET_MODE_SIZE (mode) > 4 && (regno & 1) != 0)
-      && !VALID_NEON_STRUCT_MODE (mode);
+      && ARM_NUM_REGS (mode) <= 4;
 
   if (regno == FRAME_POINTER_REGNUM
       || regno == ARG_POINTER_REGNUM)
@@ -16113,6 +18468,15 @@ arm_init_neon_builtins (void)
     }
 }
 
+static void
+arm_init_fp16_builtins (void)
+{
+  tree fp16_type = make_node (REAL_TYPE);
+  TYPE_PRECISION (fp16_type) = 16;
+  layout_type (fp16_type);
+  (*lang_hooks.types.register_builtin_type) (fp16_type, "__fp16");
+}
+
 static void
 arm_init_builtins (void)
 {
@@ -16123,6 +18487,71 @@ arm_init_builtins (void)
 
   if (TARGET_NEON)
     arm_init_neon_builtins ();
+
+  if (arm_fp16_format)
+    arm_init_fp16_builtins ();
+}
+
+/* Implement TARGET_INVALID_PARAMETER_TYPE.  */
+
+static const char *
+arm_invalid_parameter_type (const_tree t)
+{
+  if (SCALAR_FLOAT_TYPE_P (t) && TYPE_PRECISION (t) == 16)
+    return N_("function parameters cannot have __fp16 type");
+  return NULL;
+}
+
+/* Implement TARGET_INVALID_PARAMETER_TYPE.  */
+
+static const char *
+arm_invalid_return_type (const_tree t)
+{
+  if (SCALAR_FLOAT_TYPE_P (t) && TYPE_PRECISION (t) == 16)
+    return N_("functions cannot return __fp16 type");
+  return NULL;
+}
+
+/* Implement TARGET_PROMOTED_TYPE.  */
+
+static tree
+arm_promoted_type (const_tree t)
+{
+  if (SCALAR_FLOAT_TYPE_P (t) && TYPE_PRECISION (t) == 16)
+    return float_type_node;
+  return NULL_TREE;
+}
+
+/* Implement TARGET_CONVERT_TO_TYPE.
+   Specifically, this hook implements the peculiarity of the ARM
+   half-precision floating-point C semantics that requires conversions between
+   __fp16 to or from double to do an intermediate conversion to float.  */
+
+static tree
+arm_convert_to_type (tree type, tree expr)
+{
+  tree fromtype = TREE_TYPE (expr);
+  if (!SCALAR_FLOAT_TYPE_P (fromtype) || !SCALAR_FLOAT_TYPE_P (type))
+    return NULL_TREE;
+  if ((TYPE_PRECISION (fromtype) == 16 && TYPE_PRECISION (type) > 32)
+      || (TYPE_PRECISION (type) == 16 && TYPE_PRECISION (fromtype) > 32))
+    return convert (type, convert (float_type_node, expr));
+  return NULL_TREE;
+}
+
+/* Implement TARGET_SCALAR_MODE_SUPPORTED_P.
+   This simply adds HFmode as a supported mode; even though we don't
+   implement arithmetic on this type directly, it's supported by
+   optabs conversions, much the way the double-word arithmetic is
+   special-cased in the default hook.  */
+
+static bool
+arm_scalar_mode_supported_p (enum machine_mode mode)
+{
+  if (mode == HFmode)
+    return (arm_fp16_format != ARM_FP16_FORMAT_NONE);
+  else
+    return default_scalar_mode_supported_p (mode);
 }
 
 /* Errors in the source file can cause expand_expr to return const0_rtx
@@ -17202,6 +19631,7 @@ thumb_shiftable_const (unsigned HOST_WIDE_INT val)
   unsigned HOST_WIDE_INT mask = 0xff;
   int i;
 
+  val = val & (unsigned HOST_WIDE_INT)0xffffffffu;
   if (val == 0) /* XXX */
     return 0;
 
@@ -18289,41 +20719,8 @@ arm_file_start (void)
 	}
       else
 	{
-	  int set_float_abi_attributes = 0;
-	  switch (arm_fpu_arch)
-	    {
-	    case FPUTYPE_FPA:
-	      fpu_name = "fpa";
-	      break;
-	    case FPUTYPE_FPA_EMU2:
-	      fpu_name = "fpe2";
-	      break;
-	    case FPUTYPE_FPA_EMU3:
-	      fpu_name = "fpe3";
-	      break;
-	    case FPUTYPE_MAVERICK:
-	      fpu_name = "maverick";
-	      break;
-	    case FPUTYPE_VFP:
-	      fpu_name = "vfp";
-	      set_float_abi_attributes = 1;
-	      break;
-	    case FPUTYPE_VFP3D16:
-	      fpu_name = "vfpv3-d16";
-	      set_float_abi_attributes = 1;
-	      break;
-	    case FPUTYPE_VFP3:
-	      fpu_name = "vfpv3";
-	      set_float_abi_attributes = 1;
-	      break;
-	    case FPUTYPE_NEON:
-	      fpu_name = "neon";
-	      set_float_abi_attributes = 1;
-	      break;
-	    default:
-	      abort();
-	    }
-	  if (set_float_abi_attributes)
+	  fpu_name = arm_fpu_desc->name;
+	  if (arm_fp_model == ARM_FP_MODEL_VFP)
 	    {
 	      if (TARGET_HARD_FLOAT)
 		asm_fprintf (asm_out_file, "\t.eabi_attribute 27, 3\n");
@@ -18373,6 +20770,11 @@ arm_file_start (void)
 	val = 6;
       asm_fprintf (asm_out_file, "\t.eabi_attribute 30, %d\n", val);
 
+      /* Tag_ABI_FP_16bit_format.  */
+      if (arm_fp16_format)
+	asm_fprintf (asm_out_file, "\t.eabi_attribute 38, %d\n",
+		     (int)arm_fp16_format);
+
       if (arm_lang_output_object_attributes_hook)
 	arm_lang_output_object_attributes_hook();
     }
@@ -18602,6 +21004,23 @@ arm_emit_vector_const (FILE *file, rtx x)
   return 1;
 }
 
+/* Emit a fp16 constant appropriately padded to occupy a 4-byte word.
+   HFmode constant pool entries are actually loaded with ldr.  */
+void
+arm_emit_fp16_const (rtx c)
+{
+  REAL_VALUE_TYPE r;
+  long bits;
+
+  REAL_VALUE_FROM_CONST_DOUBLE (r, c);
+  bits = real_to_target (NULL, &r, HFmode);
+  if (WORDS_BIG_ENDIAN)
+    assemble_zeros (2);
+  assemble_integer (GEN_INT (bits), 2, BITS_PER_WORD, 1);
+  if (!WORDS_BIG_ENDIAN)
+    assemble_zeros (2);
+}
+
 const char *
 arm_output_load_gr (rtx *operands)
 {
@@ -18639,19 +21058,24 @@ arm_output_load_gr (rtx *operands)
    that way.  */
 
 static void
-arm_setup_incoming_varargs (CUMULATIVE_ARGS *cum,
+arm_setup_incoming_varargs (CUMULATIVE_ARGS *pcum,
 			    enum machine_mode mode,
 			    tree type,
 			    int *pretend_size,
 			    int second_time ATTRIBUTE_UNUSED)
 {
-  int nregs = cum->nregs;
-  if (nregs & 1
-      && ARM_DOUBLEWORD_ALIGN
-      && arm_needs_doubleword_align (mode, type))
-    nregs++;
-
+  int nregs;
+  
   cfun->machine->uses_anonymous_args = 1;
+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)
+    {
+      nregs = pcum->aapcs_ncrn;
+      if ((nregs & 1) && arm_needs_doubleword_align (mode, type))
+	nregs++;
+    }
+  else
+    nregs = pcum->nregs;
+  
   if (nregs < NUM_ARG_REGS)
     *pretend_size = (NUM_ARG_REGS - nregs) * UNITS_PER_WORD;
 }
@@ -19035,9 +21459,10 @@ arm_vector_mode_supported_p (enum machine_mode mode)
       || mode == V16QImode || mode == V4SFmode || mode == V2DImode))
     return true;
 
-  if ((mode == V2SImode)
-      || (mode == V4HImode)
-      || (mode == V8QImode))
+  if ((TARGET_NEON || TARGET_IWMMXT)
+      && ((mode == V2SImode)
+	  || (mode == V4HImode)
+	  || (mode == V8QImode)))
     return true;
 
   return false;
@@ -19068,9 +21493,14 @@ arm_dbx_register_number (unsigned int regno)
   if (IS_FPA_REGNUM (regno))
     return (TARGET_AAPCS_BASED ? 96 : 16) + regno - FIRST_FPA_REGNUM;
 
-  /* FIXME: VFPv3 register numbering.  */
   if (IS_VFP_REGNUM (regno))
-    return 64 + regno - FIRST_VFP_REGNUM;
+    {
+      /* See comment in arm_dwarf_register_span.  */
+      if (VFP_REGNO_OK_FOR_SINGLE (regno))
+	  return 64 + regno - FIRST_VFP_REGNUM;
+      else
+	  return 256 + (regno - FIRST_VFP_REGNUM) / 2;
+    }
 
   if (IS_IWMMXT_GR_REGNUM (regno))
     return 104 + regno - FIRST_IWMMXT_GR_REGNUM;
@@ -19081,6 +21511,39 @@ arm_dbx_register_number (unsigned int regno)
   gcc_unreachable ();
 }
 
+/* Dwarf models VFPv3 registers as 32 64-bit registers.
+   GCC models tham as 64 32-bit registers, so we need to describe this to
+   the DWARF generation code.  Other registers can use the default.  */
+static rtx
+arm_dwarf_register_span(rtx rtl)
+{
+    unsigned regno;
+    int nregs;
+    int i;
+    rtx p;
+
+    regno = REGNO (rtl);
+    if (!IS_VFP_REGNUM (regno))
+	return NULL_RTX;
+
+    /* The EABI defines two VFP register ranges:
+	  64-95: Legacy VFPv2 numbering for S0-S31 (obsolescent)
+	  256-287: D0-D31
+       The recommended encodings for s0-s31 is a DW_OP_bit_piece of the
+       corresponding D register.  However gdb6.6 does not support this, so
+       we use the legacy encodings.  We also use these encodings for D0-D15
+       for compatibility with older debuggers.  */
+    if (VFP_REGNO_OK_FOR_SINGLE (regno))
+	return NULL_RTX;
+
+    nregs = GET_MODE_SIZE (GET_MODE (rtl)) / 8;
+    p = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc(nregs));
+    regno = (regno - FIRST_VFP_REGNUM) / 2;
+    for (i = 0; i < nregs; i++)
+      XVECEXP (p, 0, i) = gen_rtx_REG (DImode, 256 + regno + i);
+
+    return p;
+}
 
 #ifdef TARGET_UNWIND_INFO
 /* Emit unwind directives for a store-multiple instruction or stack pointer
@@ -19565,8 +22028,10 @@ arm_issue_rate (void)
     {
     case cortexr4:
     case cortexr4f:
+    case cortexa5:
     case cortexa8:
     case cortexa9:
+    case marvell_f:
       return 2;
 
     default:
@@ -19622,7 +22087,7 @@ arm_mangle_type (const_tree type)
       && lang_hooks.types_compatible_p (CONST_CAST_TREE (type), va_list_type))
     {
       static bool warned;
-      if (!warned && warn_psabi)
+      if (!warned && warn_psabi && !in_system_header)
 	{
 	  warned = true;
 	  inform (input_location,
@@ -19631,6 +22096,10 @@ arm_mangle_type (const_tree type)
       return "St9__va_list";
     }
 
+  /* Half-precision float.  */
+  if (TREE_CODE (type) == REAL_TYPE && TYPE_PRECISION (type) == 16)
+    return "Dh";
+
   if (TREE_CODE (type) != VECTOR_TYPE)
     return NULL;
 
@@ -19687,6 +22156,110 @@ arm_optimization_options (int level, int size ATTRIBUTE_UNUSED)
      given on the command line.  */
   if (level > 0)
     flag_section_anchors = 2;
+
+  if (size)
+    {
+      /* Select optimizations that are a win for code size.
+
+	 The inlining options set below have two important
+	 consequences for functions not explicitly marked
+	 inline:
+	 - Static functions used once are inlined if
+	 sufficiently small.  Static functions used twice
+	 are not inlined.
+	 - Non-static functions are never inlined.
+	 So in effect, inlining will never cause two copies
+	 of function bodies to be created.  */
+      /* Empirical results show that these options benefit code
+	 size on arm.  */
+      /* FIXME: -fsee seems to be broken for Thumb-2.  */
+      /* flag_see = 1; */
+      flag_move_loop_invariants = 0;
+      /* In Thumb mode the function call code size overhead is typically very
+	 small, and narrow branch instructions have very limited range.
+	 Inlining even medium sized functions tends to bloat the caller and
+	 require the use of long branch instructions. On average the long
+	 branches cost more than eliminating the function call overhead saves,
+	 so we use extremely restrictive automatic inlining heuristics.  In ARM
+	 mode the results are fairly neutral, probably due to better constant
+	 pool placement. */
+      set_param_value ("max-inline-insns-single", 1);
+      set_param_value ("max-inline-insns-auto", 1);
+    }
+  else
+    {
+      /* CSL LOCAL */
+      /* Set flag_unroll_loops to a default value, so that we can tell
+	 if it was specified on the command line; see
+	 arm_override_options.  */
+      flag_unroll_loops = 2;
+      /* Promote loop indices to int where possible.  Consider moving this
+	 to -Os, also.  */
+      flag_promote_loop_indices = 1;
+    }
+}
+ 
+/* Return how many instructions to look ahead for better insn
+   scheduling.  */
+static int
+arm_multipass_dfa_lookahead (void)
+{
+  return (arm_tune == marvell_f) ? 4 : 0;
+}
+
+/* Return the minimum alignment required to load or store a
+   vector of the given type, which may be less than the
+   natural alignment of the type.  */
+
+static int
+arm_vector_min_alignment (const_tree type)
+{
+  if (TARGET_NEON)
+    {
+      /* The NEON element load and store instructions only require the
+	 alignment of the element type.  They can benefit from higher
+	 statically reported alignment, but we do not take advantage
+	 of that yet.  */
+      gcc_assert (TREE_CODE (type) == VECTOR_TYPE);
+      return TYPE_ALIGN_UNIT (TREE_TYPE (type));
+    }
+
+  return default_vector_min_alignment (type);
+}
+
+static bool
+arm_vector_always_misalign(const_tree type ATTRIBUTE_UNUSED)
+{
+  /* On big-endian targets array loads (vld1) and vector loads (vldm)
+     use a different format.  Always use the "misaligned" array variant.
+     FIXME: this still doesn't work for big-endian because of constant
+     loads and other operations using vldm ordering.  See
+     issue 6722.  */
+  return TARGET_NEON && !BYTES_BIG_ENDIAN;
+}
+
+int
+arm_major_arch (void)
+{
+  if ((insn_flags & FL_FOR_ARCH6) == FL_FOR_ARCH6)
+    return 6;
+  else if ((insn_flags & FL_FOR_ARCH5) == FL_FOR_ARCH5)
+    return 5;
+  else if ((insn_flags & FL_FOR_ARCH4) == FL_FOR_ARCH4)
+    return 4;
+  else if ((insn_flags & FL_FOR_ARCH3) == FL_FOR_ARCH3)
+    return 3;
+  else if ((insn_flags & FL_FOR_ARCH2) == FL_FOR_ARCH2)
+    return 2;
+  
+  /* This should gives us a nice ICE somewhere.  */
+  return -1;
+}
+
+bool
+arm_thumb_arch_p (void)
+{
+  return (insn_flags & FL_THUMB) == FL_THUMB;
 }
 
 #include "gt-arm.h"
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index f894d37fe..7b1fb925c 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -84,7 +84,17 @@ extern char arm_arch_name[];
 	if (arm_arch_iwmmxt)				\
 	  builtin_define ("__IWMMXT__");		\
 	if (TARGET_AAPCS_BASED)				\
-	  builtin_define ("__ARM_EABI__");		\
+ 	  {						\
+ 	    if (arm_pcs_default == ARM_PCS_AAPCS_VFP)	\
+ 	      builtin_define ("__ARM_PCS_VFP");		\
+ 	    else if (arm_pcs_default == ARM_PCS_AAPCS)	\
+ 	      builtin_define ("__ARM_PCS");		\
+ 	    builtin_define ("__ARM_EABI__");		\
+ 	  }						\
+	if (arm_tune_marvell_f)				\
+	  builtin_define ("__ARM_TUNE_MARVELL_F__");	\
+	if (low_irq_latency)				\
+	  builtin_define ("__low_irq_latency__");	\
     } while (0)
 
 /* The various ARM cores.  */
@@ -199,6 +209,13 @@ extern void (*arm_lang_output_object_attributes_hook)(void);
 #define TARGET_AAPCS_BASED \
     (arm_abi != ARM_ABI_APCS && arm_abi != ARM_ABI_ATPCS)
 
+/* True if we should avoid generating conditional execution instructions.  */
+#define TARGET_NO_COND_EXEC		(arm_tune_marvell_f && !optimize_size)
+/* Avoid most conditional instructions, but allow pairs with opposite
+   conditions and the same destination.  */
+#define TARGET_NO_SINGLE_COND_EXEC \
+  ((arm_tune_cortex_a9 || arm_tune_marvell_f) && !optimize_size)
+
 #define TARGET_HARD_TP			(target_thread_pointer == TP_CP15)
 #define TARGET_SOFT_TP			(target_thread_pointer == TP_SOFT)
 
@@ -211,35 +228,43 @@ extern void (*arm_lang_output_object_attributes_hook)(void);
 /* Thumb-1 only.  */
 #define TARGET_THUMB1_ONLY		(TARGET_THUMB1 && !arm_arch_notm)
 
+#define TARGET_FPA_EMU2			(TARGET_FPA && arm_fpu_desc->rev == 2)
 /* The following two macros concern the ability to execute coprocessor
    instructions for VFPv3 or NEON.  TARGET_VFP3/TARGET_VFPD32 are currently
    only ever tested when we know we are generating for VFP hardware; we need
    to be more careful with TARGET_NEON as noted below.  */
 
 /* FPU is has the full VFPv3/NEON register file of 32 D registers.  */
-#define TARGET_VFPD32 (arm_fp_model == ARM_FP_MODEL_VFP \
-		       && (arm_fpu_arch == FPUTYPE_VFP3 \
-			   || arm_fpu_arch == FPUTYPE_NEON))
+#define TARGET_VFPD32 (TARGET_VFP && arm_arch_vfp_regs == VFP_REG_D32)
 
 /* FPU supports VFPv3 instructions.  */
-#define TARGET_VFP3 (arm_fp_model == ARM_FP_MODEL_VFP \
-		     && (arm_fpu_arch == FPUTYPE_VFP3D16 \
-			 || TARGET_VFPD32))
+#define TARGET_VFP3 (TARGET_VFP && arm_arch_vfp_rev >= 3)
+
+/* FPU only supports VFP single-precision instructions.  */
+#define TARGET_VFP_SINGLE (TARGET_VFP && arm_arch_vfp_regs == VFP_REG_SINGLE)
+
+/* FPU supports VFP double-precision instructions.  */
+#define TARGET_VFP_DOUBLE (TARGET_VFP && arm_arch_vfp_regs != VFP_REG_SINGLE)
+
+/* FPU supports half-precision floating-point with NEON element load/store.  */
+#define TARGET_NEON_FP16 (TARGET_VFP && arm_arch_vfp_neon && arm_arch_vfp_fp16)
+
+/* FPU supports VFP half-precision floating-point.  */
+#define TARGET_FP16 (TARGET_VFP && arm_arch_vfp_fp16)
 
 /* FPU supports Neon instructions.  The setting of this macro gets
    revealed via __ARM_NEON__ so we add extra guards upon TARGET_32BIT
    and TARGET_HARD_FLOAT to ensure that NEON instructions are
    available.  */
 #define TARGET_NEON (TARGET_32BIT && TARGET_HARD_FLOAT \
-		     && arm_fp_model == ARM_FP_MODEL_VFP \
-		     && arm_fpu_arch == FPUTYPE_NEON)
+		     && TARGET_VFP && arm_arch_vfp_neon)
 
 /* "DSP" multiply instructions, eg. SMULxy.  */
 #define TARGET_DSP_MULTIPLY \
-  (TARGET_32BIT && arm_arch5e && arm_arch_notm)
+  (TARGET_32BIT && arm_arch5e && (arm_arch_notm || arm_arch7em))
 /* Integer SIMD instructions, and extend-accumulate instructions.  */
 #define TARGET_INT_SIMD \
-  (TARGET_32BIT && arm_arch6 && arm_arch_notm)
+  (TARGET_32BIT && arm_arch6 && (arm_arch_notm || arm_arch7em))
 
 /* Should MOVW/MOVT be used in preference to a constant pool.  */
 #define TARGET_USE_MOVT (arm_arch_thumb2 && !optimize_size)
@@ -289,40 +314,30 @@ enum arm_fp_model
   ARM_FP_MODEL_VFP
 };
 
-extern enum arm_fp_model arm_fp_model;
-
-/* Which floating point hardware is available.  Also update
-   fp_model_for_fpu in arm.c when adding entries to this list.  */
-enum fputype
-{
-  /* No FP hardware.  */
-  FPUTYPE_NONE,
-  /* Full FPA support.  */
-  FPUTYPE_FPA,
-  /* Emulated FPA hardware, Issue 2 emulator (no LFM/SFM).  */
-  FPUTYPE_FPA_EMU2,
-  /* Emulated FPA hardware, Issue 3 emulator.  */
-  FPUTYPE_FPA_EMU3,
-  /* Cirrus Maverick floating point co-processor.  */
-  FPUTYPE_MAVERICK,
-  /* VFP.  */
-  FPUTYPE_VFP,
-  /* VFPv3-D16.  */
-  FPUTYPE_VFP3D16,
-  /* VFPv3.  */
-  FPUTYPE_VFP3,
-  /* Neon.  */
-  FPUTYPE_NEON
+enum vfp_reg_type {
+    VFP_REG_D16,
+    VFP_REG_D32,
+    VFP_REG_SINGLE
 };
 
-/* Recast the floating point class to be the floating point attribute.  */
-#define arm_fpu_attr ((enum attr_fpu) arm_fpu_tune)
-
-/* What type of floating point to tune for */
-extern enum fputype arm_fpu_tune;
-
-/* What type of floating point instructions are available */
-extern enum fputype arm_fpu_arch;
+extern const struct arm_fpu_desc
+{
+  const char *name;
+  enum arm_fp_model model;
+  int rev;
+  enum vfp_reg_type myregs;
+  int neon;
+  int fp16;
+} *arm_fpu_desc;
+
+#define arm_fp_model arm_fpu_desc->model
+#define arm_arch_vfp_rev arm_fpu_desc->rev
+#define arm_arch_vfp_regs arm_fpu_desc->myregs
+#define arm_arch_vfp_neon arm_fpu_desc->neon
+#define arm_arch_vfp_fp16 arm_fpu_desc->fp16
+
+/* Which floating point hardware to schedule for.  */
+extern int arm_fpu_attr;
 
 enum float_abi_type
 {
@@ -337,6 +352,21 @@ extern enum float_abi_type arm_float_abi;
 #define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_SOFT
 #endif
 
+/* Which __fp16 format to use.
+   The enumeration values correspond to the numbering for the
+   Tag_ABI_FP_16bit_format attribute.
+ */
+enum arm_fp16_format_type
+{
+  ARM_FP16_FORMAT_NONE = 0,
+  ARM_FP16_FORMAT_IEEE = 1,
+  ARM_FP16_FORMAT_ALTERNATIVE = 2
+};
+
+extern enum arm_fp16_format_type arm_fp16_format;
+#define LARGEST_EXPONENT_IS_NORMAL(bits) \
+    ((bits) == 16 && arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)
+
 /* Which ABI to use.  */
 enum arm_abi_type
 {
@@ -383,12 +413,18 @@ extern int arm_arch6;
 /* Nonzero if instructions not present in the 'M' profile can be used.  */
 extern int arm_arch_notm;
 
+/* Nonzero if instructions present in ARMv7E-M can be used.  */
+extern int arm_arch7em;
+
 /* Nonzero if this chip can benefit from load scheduling.  */
 extern int arm_ld_sched;
 
 /* Nonzero if generating thumb code.  */
 extern int thumb_code;
 
+/* Nonzero if generating Janus2 code. */
+extern int janus2_code;
+
 /* Nonzero if this chip is a StrongARM.  */
 extern int arm_tune_strongarm;
 
@@ -404,6 +440,9 @@ extern int arm_arch_xscale;
 /* Nonzero if tuning for XScale.  */
 extern int arm_tune_xscale;
 
+/* Nonzero if tuning for Marvell Feroceon.  */
+extern int arm_tune_marvell_f;
+
 /* Nonzero if tuning for stores via the write buffer.  */
 extern int arm_tune_wbuf;
 
@@ -423,6 +462,10 @@ extern int arm_arch_thumb2;
 /* Nonzero if chip supports integer division instruction.  */
 extern int arm_arch_hwdiv;
 
+/* Nonzero if we should minimize interrupt latency of the
+   generated code.  */
+extern int low_irq_latency;
+
 #ifndef TARGET_DEFAULT
 #define TARGET_DEFAULT  (MASK_APCS_FRAME)
 #endif
@@ -537,7 +580,14 @@ extern int arm_arch_hwdiv;
 #define PREFERRED_STACK_BOUNDARY \
     (arm_abi == ARM_ABI_ATPCS ? 64 : STACK_BOUNDARY)
 
-#define FUNCTION_BOUNDARY  32
+/* There are two values that tweak function alignment: FUNCTION_BOUNDARY and
+   align_functions.  The former is used by default and the latter can override
+   the default, but only when optimizing for speed.  So FUNCTION_BOUNDARY is
+   the right place to tweak when optimizing for size.
+   In ARM mode, minimal allowed alignment is 32 bits.
+   In THUMB mode it is 16 bits; to avoid possible performance regressions
+   we use 16-bit alignment only when optimizing for size.  */
+#define FUNCTION_BOUNDARY  ((TARGET_THUMB && optimize_size) ? 16 : 32)
 
 /* The lowest bit is used to indicate Thumb-mode functions, so the
    vbit must go into the delta field of pointers to member
@@ -757,12 +807,11 @@ extern int arm_structure_size_boundary;
 	fixed_regs[regno] = call_used_regs[regno] = 1;		\
     }								\
 								\
-  if (TARGET_THUMB && optimize_size)				\
-    {								\
-      /* When optimizing for size, it's better not to use	\
-	 the HI regs, because of the overhead of stacking 	\
-	 them.  */						\
-      /* ??? Is this still true for thumb2?  */			\
+  if (TARGET_THUMB1 && optimize_size)				\
+    {                                                           \
+      /* When optimizing for size on Thumb-1, it's better not	\
+        to use the HI regs, because of the overhead of		\
+        stacking them.  */                                      \
       for (regno = FIRST_HI_REGNUM;				\
 	   regno <= LAST_HI_REGNUM; ++regno)			\
 	fixed_regs[regno] = call_used_regs[regno] = 1;		\
@@ -881,6 +930,9 @@ extern int arm_structure_size_boundary;
 /* The number of (integer) argument register available.  */
 #define NUM_ARG_REGS		4
 
+/* And similarly for the VFP.  */
+#define NUM_VFP_ARG_REGS	16
+
 /* Return the register number of the N'th (integer) argument.  */
 #define ARG_REGISTER(N) 	(N - 1)
 
@@ -901,9 +953,6 @@ extern int arm_structure_size_boundary;
 #define MUST_USE_SJLJ_EXCEPTIONS 1
 #endif
 
-/* We can generate DWARF2 Unwind info, even though we don't use it.  */
-#define DWARF2_UNWIND_INFO 1
-
 /* Use r0 and r1 to pass exception handling information.  */
 #define EH_RETURN_DATA_REGNO(N) (((N) < 2) ? N : INVALID_REGNUM)
 
@@ -1059,7 +1108,7 @@ extern int arm_structure_size_boundary;
   (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))
 
 #define VALID_IWMMXT_REG_MODE(MODE) \
- (arm_vector_mode_supported_p (MODE) || (MODE) == DImode)
+ (arm_vector_mode_supported_p (MODE) || (MODE) == DImode || (MODE) == SImode)
 
 /* Modes valid for Neon D registers.  */
 #define VALID_NEON_DREG_MODE(MODE) \
@@ -1191,8 +1240,8 @@ enum reg_class
   { 0x0000DF00, 0x00000000, 0x00000000, 0x00000000 }, /* HI_REGS */	\
   { 0x01000000, 0x00000000, 0x00000000, 0x00000000 }, /* CC_REG */	\
   { 0x00000000, 0x00000000, 0x00000000, 0x80000000 }, /* VFPCC_REG */	\
-  { 0x0200DFFF, 0x00000000, 0x00000000, 0x00000000 }, /* GENERAL_REGS */ \
-  { 0x0200FFFF, 0x00000000, 0x00000000, 0x00000000 }, /* CORE_REGS */	\
+  { 0x0000DFFF, 0x00000000, 0x00000000, 0x00000000 }, /* GENERAL_REGS */ \
+  { 0x0000FFFF, 0x00000000, 0x00000000, 0x00000000 }, /* CORE_REGS */	\
   { 0xFAFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF }  /* ALL_REGS */	\
 }
 
@@ -1230,11 +1279,14 @@ enum reg_class
      || reg_classes_intersect_p (VFP_REGS, (CLASS))	\
    : 0)
 
-/* We need to define this for LO_REGS on thumb.  Otherwise we can end up
-   using r0-r4 for function arguments, r7 for the stack frame and don't
-   have enough left over to do doubleword arithmetic.  */
+/* We need to define this for LO_REGS on Thumb-1.  Otherwise we can end up
+   using r0-r4 for function arguments, r7 for the stack frame and don't have
+   enough left over to do doubleword arithmetic.  For Thumb-2 all the
+   potentially problematic instructions accept high registers so this is not
+   necessary.  Care needs to be taken to avoid adding new Thumb-2 patterns
+   that require many low registers.  */
 #define CLASS_LIKELY_SPILLED_P(CLASS)	\
-    ((TARGET_THUMB && (CLASS) == LO_REGS)	\
+    ((TARGET_THUMB1 && (CLASS) == LO_REGS)	\
      || (CLASS) == CC_REG)
 
 /* The class value for index registers, and the one for base regs.  */
@@ -1245,7 +1297,7 @@ enum reg_class
    when addressing quantities in QI or HI mode; if we don't know the
    mode, then we must be conservative.  */
 #define MODE_BASE_REG_CLASS(MODE)					\
-    (TARGET_32BIT ? CORE_REGS :					\
+    (TARGET_32BIT ? (TARGET_THUMB2 ? LO_REGS : CORE_REGS) :					\
      (((MODE) == SImode) ? BASE_REGS : LO_REGS))
 
 /* For Thumb we can not support SP+reg addressing, so we return LO_REGS
@@ -1263,7 +1315,7 @@ enum reg_class
    In general this is just CLASS, but for the Thumb core registers and
    immediate constants we prefer a LO_REGS class or a subset.  */
 #define PREFERRED_RELOAD_CLASS(X, CLASS)		\
-  (TARGET_ARM ? (CLASS) :				\
+  (TARGET_32BIT ? (CLASS) :				\
    ((CLASS) == GENERAL_REGS || (CLASS) == HI_REGS	\
     || (CLASS) == NO_REGS || (CLASS) == STACK_REG	\
    ? LO_REGS : (CLASS)))
@@ -1346,6 +1398,9 @@ enum reg_class
 	  else if (TARGET_MAVERICK && TARGET_HARD_FLOAT)		   \
 	    /* Need to be careful, -256 is not a valid offset.  */	   \
 	    low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);		   \
+	  else if (TARGET_REALLY_IWMMXT && MODE == SImode)		   \
+	    /* Need to be careful, -1024 is not a valid offset.  */	   \
+	    low = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);		   \
 	  else if (MODE == SImode					   \
 		   || (MODE == SFmode && TARGET_SOFT_FLOAT)		   \
 		   || ((MODE == HImode || MODE == QImode) && ! arm_arch4)) \
@@ -1416,13 +1471,17 @@ do {									      \
 /* If defined, gives a class of registers that cannot be used as the
    operand of a SUBREG that changes the mode of the object illegally.  */
 
-/* Moves between FPA_REGS and GENERAL_REGS are two memory insns.  */
+/* Moves between FPA_REGS and GENERAL_REGS are two memory insns.
+   Moves between VFP_REGS and GENERAL_REGS are a single insn, but
+   it is typically more expensive than a single memory access.  We set
+   the cost to less than two memory accesses so that floating
+   point to integer conversion does not go through memory.  */
 #define REGISTER_MOVE_COST(MODE, FROM, TO)		\
   (TARGET_32BIT ?						\
    ((FROM) == FPA_REGS && (TO) != FPA_REGS ? 20 :	\
     (FROM) != FPA_REGS && (TO) == FPA_REGS ? 20 :	\
-    IS_VFP_CLASS (FROM) && !IS_VFP_CLASS (TO) ? 10 :	\
-    !IS_VFP_CLASS (FROM) && IS_VFP_CLASS (TO) ? 10 :	\
+    IS_VFP_CLASS (FROM) && !IS_VFP_CLASS (TO) ? 15 :	\
+    !IS_VFP_CLASS (FROM) && IS_VFP_CLASS (TO) ? 15 :	\
     (FROM) == IWMMXT_REGS && (TO) != IWMMXT_REGS ? 4 :  \
     (FROM) != IWMMXT_REGS && (TO) == IWMMXT_REGS ? 4 :  \
     (FROM) == IWMMXT_GR_REGS || (TO) == IWMMXT_GR_REGS ? 20 :  \
@@ -1491,9 +1550,10 @@ do {									      \
 
 /* Define how to find the value returned by a library function
    assuming the value has mode MODE.  */
-#define LIBCALL_VALUE(MODE)  \
-  (TARGET_32BIT && TARGET_HARD_FLOAT_ABI && TARGET_FPA			\
-   && GET_MODE_CLASS (MODE) == MODE_FLOAT				\
+#define LIBCALL_VALUE(MODE)  						\
+  (TARGET_AAPCS_BASED ? aapcs_libcall_value (MODE)			\
+   : (TARGET_32BIT && TARGET_HARD_FLOAT_ABI && TARGET_FPA		\
+      && GET_MODE_CLASS (MODE) == MODE_FLOAT)				\
    ? gen_rtx_REG (MODE, FIRST_FPA_REGNUM)				\
    : TARGET_32BIT && TARGET_HARD_FLOAT_ABI && TARGET_MAVERICK		\
      && GET_MODE_CLASS (MODE) == MODE_FLOAT				\
@@ -1502,22 +1562,16 @@ do {									      \
    ? gen_rtx_REG (MODE, FIRST_IWMMXT_REGNUM) 				\
    : gen_rtx_REG (MODE, ARG_REGISTER (1)))
 
-/* Define how to find the value returned by a function.
-   VALTYPE is the data type of the value (as a tree).
-   If the precise function being called is known, FUNC is its FUNCTION_DECL;
-   otherwise, FUNC is 0.  */
-#define FUNCTION_VALUE(VALTYPE, FUNC) \
-  arm_function_value (VALTYPE, FUNC);
-
-/* 1 if N is a possible register number for a function value.
-   On the ARM, only r0 and f0 can return results.  */
-/* On a Cirrus chip, mvf0 can return results.  */
-#define FUNCTION_VALUE_REGNO_P(REGNO)  \
-  ((REGNO) == ARG_REGISTER (1) \
-   || (TARGET_32BIT && ((REGNO) == FIRST_CIRRUS_FP_REGNUM)		\
-       && TARGET_HARD_FLOAT_ABI && TARGET_MAVERICK)			\
-   || ((REGNO) == FIRST_IWMMXT_REGNUM && TARGET_IWMMXT_ABI) \
-   || (TARGET_32BIT && ((REGNO) == FIRST_FPA_REGNUM)			\
+/* 1 if REGNO is a possible register number for a function value.  */
+#define FUNCTION_VALUE_REGNO_P(REGNO)				\
+  ((REGNO) == ARG_REGISTER (1)					\
+   || (TARGET_AAPCS_BASED && TARGET_32BIT 			\
+       && TARGET_VFP && TARGET_HARD_FLOAT			\
+       && (REGNO) == FIRST_VFP_REGNUM)				\
+   || (TARGET_32BIT && ((REGNO) == FIRST_CIRRUS_FP_REGNUM)	\
+       && TARGET_HARD_FLOAT_ABI && TARGET_MAVERICK)		\
+   || ((REGNO) == FIRST_IWMMXT_REGNUM && TARGET_IWMMXT_ABI)	\
+   || (TARGET_32BIT && ((REGNO) == FIRST_FPA_REGNUM)		\
        && TARGET_HARD_FLOAT_ABI && TARGET_FPA))
 
 /* Amount of memory needed for an untyped call to save all possible return
@@ -1617,9 +1671,30 @@ machine_function;
    that is in text_section.  */
 extern GTY(()) rtx thumb_call_via_label[14];
 
+/* The number of potential ways of assigning to a co-processor.  */
+#define ARM_NUM_COPROC_SLOTS 1
+
+/* Enumeration of procedure calling standard variants.  We don't really 
+   support all of these yet.  */
+enum arm_pcs
+{
+  ARM_PCS_AAPCS,	/* Base standard AAPCS.  */
+  ARM_PCS_AAPCS_VFP,	/* Use VFP registers for floating point values.  */
+  ARM_PCS_AAPCS_IWMMXT, /* Use iWMMXT registers for vectors.  */
+  /* This must be the last AAPCS variant.  */
+  ARM_PCS_AAPCS_LOCAL,	/* Private call within this compilation unit.  */
+  ARM_PCS_ATPCS,	/* ATPCS.  */
+  ARM_PCS_APCS,		/* APCS (legacy Linux etc).  */
+  ARM_PCS_UNKNOWN
+};
+
+/* Default procedure calling standard of current compilation unit. */
+extern enum arm_pcs arm_pcs_default;
+
+/* We can't define this inside a generator file because it needs enum
+   machine_mode.  */
 /* A C type for declaring a variable that is used as the first argument of
-   `FUNCTION_ARG' and other related values.  For some target machines, the
-   type `int' suffices and can hold the number of bytes of argument so far.  */
+   `FUNCTION_ARG' and other related values.  */
 typedef struct
 {
   /* This is the number of registers of arguments scanned so far.  */
@@ -1628,9 +1703,33 @@ typedef struct
   int iwmmxt_nregs;
   int named_count;
   int nargs;
-  int can_split;
+  /* Which procedure call variant to use for this call.  */
+  enum arm_pcs pcs_variant;
+
+  /* AAPCS related state tracking.  */
+  int aapcs_arg_processed;  /* No need to lay out this argument again.  */
+  int aapcs_cprc_slot;      /* Index of co-processor rules to handle
+			       this argument, or -1 if using core
+			       registers.  */
+  int aapcs_ncrn;
+  int aapcs_next_ncrn;
+  rtx aapcs_reg;	    /* Register assigned to this argument.  */
+  int aapcs_partial;	    /* How many bytes are passed in regs (if
+			       split between core regs and stack.
+			       Zero otherwise.  */
+  int aapcs_cprc_failed[ARM_NUM_COPROC_SLOTS];
+  int can_split;	    /* Argument can be split between core regs
+			       and the stack.  */
+  /* Private data for tracking VFP register allocation */
+  unsigned aapcs_vfp_regs_free;
+  unsigned aapcs_vfp_reg_alloc;
+  int aapcs_vfp_rcount;
+  /* Can't include insn-modes.h because this header is needed before we
+     generate it.  */
+  int /* enum machine_mode */ aapcs_vfp_rmode;
 } CUMULATIVE_ARGS;
 
+
 /* Define where to put the arguments to a function.
    Value is zero to push the argument on the stack,
    or a hard register in which to store the argument.
@@ -1674,13 +1773,7 @@ typedef struct
    of mode MODE and data type TYPE.
    (TYPE is null for libcalls where that information may not be available.)  */
 #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)	\
-  (CUM).nargs += 1;					\
-  if (arm_vector_mode_supported_p (MODE)		\
-      && (CUM).named_count > (CUM).nargs		\
-      && TARGET_IWMMXT_ABI)				\
-    (CUM).iwmmxt_nregs += 1;				\
-  else							\
-    (CUM).nregs += ARM_NUM_REGS2 (MODE, TYPE)
+  arm_function_arg_advance (&(CUM), (MODE), (TYPE), (NAMED))
 
 /* If defined, a C expression that gives the alignment boundary, in bits, of an
    argument with the specified mode and type.  If it is not defined,
@@ -1692,9 +1785,11 @@ typedef struct
 
 /* 1 if N is a possible register number for function argument passing.
    On the ARM, r0-r3 are used to pass args.  */
-#define FUNCTION_ARG_REGNO_P(REGNO)	\
-   (IN_RANGE ((REGNO), 0, 3)		\
-    || (TARGET_IWMMXT_ABI		\
+#define FUNCTION_ARG_REGNO_P(REGNO)					\
+   (IN_RANGE ((REGNO), 0, 3)						\
+    || (TARGET_AAPCS_BASED && TARGET_VFP && TARGET_HARD_FLOAT		\
+	&& IN_RANGE ((REGNO), FIRST_VFP_REGNUM, FIRST_VFP_REGNUM + 15))	\
+    || (TARGET_IWMMXT_ABI						\
 	&& IN_RANGE ((REGNO), FIRST_IWMMXT_REGNUM, FIRST_IWMMXT_REGNUM + 9)))
 
 
@@ -1763,10 +1858,8 @@ typedef struct
 
 /* Determine if the epilogue should be output as RTL.
    You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */
-/* This is disabled for Thumb-2 because it will confuse the
-   conditional insn counter.  */
 #define USE_RETURN_INSN(ISCOND)				\
-  (TARGET_ARM ? use_return_insn (ISCOND, NULL) : 0)
+  (TARGET_32BIT ? use_return_insn (ISCOND, NULL) : 0)
 
 /* Definitions for register eliminations.
 
@@ -1986,6 +2079,9 @@ typedef struct
 #define TARGET_DEFAULT_WORD_RELOCATIONS 0
 #endif
 
+/* Nonzero if the target uses RELA relocations.  */
+#define TARGET_USE_RELA 0
+
 /* Nonzero if the constant value X is a legitimate general operand.
    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.
 
@@ -2324,7 +2420,8 @@ do {							\
 /* Try to generate sequences that don't involve branches, we can then use
    conditional instructions */
 #define BRANCH_COST(speed_p, predictable_p) \
-  (TARGET_32BIT ? 4 : (optimize > 0 ? 2 : 0))
+  (TARGET_32BIT ? (TARGET_THUMB2 && optimize_size ? 1 : 4) \
+		: (optimize > 0 ? 2 : 0))
 
 /* Position Independent Code.  */
 /* We decide which register to use based on the compilation options and
@@ -2376,22 +2473,11 @@ extern int making_const_table;
    : reverse_condition (code))
 
 #define CANONICALIZE_COMPARISON(CODE, OP0, OP1)				\
-  do									\
-    {									\
-      if (GET_CODE (OP1) == CONST_INT					\
-          && ! (const_ok_for_arm (INTVAL (OP1))				\
-	        || (const_ok_for_arm (- INTVAL (OP1)))))		\
-        {								\
-          rtx const_op = OP1;						\
-          CODE = arm_canonicalize_comparison ((CODE), GET_MODE (OP0),	\
-					      &const_op);		\
-          OP1 = const_op;						\
-        }								\
-    }									\
-  while (0)
+  (CODE) = arm_canonicalize_comparison (CODE, &(OP0), &(OP1))
 
 /* The arm5 clz instruction returns 32.  */
 #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  ((VALUE) = 32, 1)
+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  ((VALUE) = 32, 1)
 
 #undef  ASM_APP_OFF
 #define ASM_APP_OFF (TARGET_THUMB1 ? "\t.code\t16\n" : \
@@ -2404,6 +2490,19 @@ extern int making_const_table;
       if (TARGET_ARM)					\
 	asm_fprintf (STREAM,"\tstmfd\t%r!,{%r}\n",	\
 		     STACK_POINTER_REGNUM, REGNO);	\
+      else if (TARGET_THUMB1				\
+	       && (REGNO) == STATIC_CHAIN_REGNUM)	\
+	{						\
+	  /* We can't push STATIC_CHAIN_REGNUM (r12) directly with Thumb-1.
+	     We know that ASM_OUTPUT_REG_PUSH will be matched with
+	     ASM_OUTPUT_REG_POP, and that r7 isn't used by the function
+	     profiler, so we can use it as a scratch reg.  WARNING: This isn't
+	     safe in the general case!  It may be sensitive to future changes
+	     in final.c:profile_function.  */		\
+	  asm_fprintf (STREAM, "\tpush\t{r7}\n");	\
+	  asm_fprintf (STREAM, "\tmov\tr7, %r\n", REGNO);\
+	  asm_fprintf (STREAM, "\tpush\t{r7}\n");	\
+	}						\
       else						\
 	asm_fprintf (STREAM, "\tpush {%r}\n", REGNO);	\
     } while (0)
@@ -2415,6 +2514,14 @@ extern int making_const_table;
       if (TARGET_ARM)					\
 	asm_fprintf (STREAM, "\tldmfd\t%r!,{%r}\n",	\
 		     STACK_POINTER_REGNUM, REGNO);	\
+      else if (TARGET_THUMB1				\
+	       && (REGNO) == STATIC_CHAIN_REGNUM)	\
+	{						\
+	  /* See comment in ASM_OUTPUT_REG_PUSH.  */	\
+	  asm_fprintf (STREAM, "\tpop\t{r7}\n");	\
+	  asm_fprintf (STREAM, "\tmov\t%r, r7\n", REGNO);\
+	  asm_fprintf (STREAM, "\tpop\t{r7}\n");	\
+	}						\
       else						\
 	asm_fprintf (STREAM, "\tpop {%r}\n", REGNO);	\
     } while (0)
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index 7f41d8f97..b04ce8ce8 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -99,6 +99,7 @@
 			  ; correctly for PIC usage.
    (UNSPEC_GOTSYM_OFF 24) ; The offset of the start of the the GOT from a
 			  ; a given symbolic address.
+   (UNSPEC_RBIT 25)	  ; rbit operation.
   ]
 )
 
@@ -131,6 +132,8 @@
    (VUNSPEC_WCMP_EQ  12) ; Used by the iWMMXt WCMPEQ instructions
    (VUNSPEC_WCMP_GTU 13) ; Used by the iWMMXt WCMPGTU instructions
    (VUNSPEC_WCMP_GT  14) ; Used by the iwMMXT WCMPGT instructions
+   (VUNSPEC_ALIGN16  15) ; Used to force 16-byte alignment.
+   (VUNSPEC_ALIGN32  16) ; Used to force 32-byte alignment.
    (VUNSPEC_EH_RETURN 20); Use to override the return address for exception
 			 ; handling.
   ]
@@ -144,6 +147,10 @@
 ; patterns that share the same RTL in both ARM and Thumb code.
 (define_attr "is_thumb" "no,yes" (const (symbol_ref "thumb_code")))
 
+; FIX_JANUS is set to 'yes' when compiling for Janus2, it causes to
+; add a nop after shifts, in order to work around a Janus2 bug
+(define_attr "fix_janus" "no,yes" (const (symbol_ref "janus2_code")))
+
 ; IS_STRONGARM is set to 'yes' when compiling for StrongARM, it affects
 ; scheduling decisions for the load unit and the multiplier.
 (define_attr "is_strongarm" "no,yes" (const (symbol_ref "arm_tune_strongarm")))
@@ -158,7 +165,7 @@
 ; Floating Point Unit.  If we only have floating point emulation, then there
 ; is no point in scheduling the floating point insns.  (Well, for best
 ; performance we should try and group them together).
-(define_attr "fpu" "none,fpa,fpe2,fpe3,maverick,vfp,vfpv3d16,vfpv3,neon"
+(define_attr "fpu" "none,fpa,fpe2,fpe3,maverick,vfp"
   (const (symbol_ref "arm_fpu_attr")))
 
 ; LENGTH of an instruction (in bytes)
@@ -185,7 +192,7 @@
 ;; scheduling information.
 
 (define_attr "insn"
-        "mov,mvn,smulxy,smlaxy,smlalxy,smulwy,smlawx,mul,muls,mla,mlas,umull,umulls,umlal,umlals,smull,smulls,smlal,smlals,smlawy,smuad,smuadx,smlad,smladx,smusd,smusdx,smlsd,smlsdx,smmul,smmulr,smmla,umaal,smlald,smlsld,clz,mrs,msr,xtab,sdiv,udiv,other"
+        "mov,mvn,and,orr,eor,smulxy,smlaxy,smlalxy,smulwy,smlawx,mul,muls,mla,mlas,umull,umulls,umlal,umlals,smull,smulls,smlal,smlals,smlawy,smuad,smuadx,smlad,smladx,smusd,smusdx,smlsd,smlsdx,smmul,smmulr,smmla,umaal,smlald,smlsld,clz,mrs,msr,xtab,sdiv,udiv,other"
         (const_string "other"))
 
 ; TYPE attribute is used to detect floating point instructions which, if
@@ -251,8 +258,6 @@
 (define_attr "ldsched" "no,yes" (const (symbol_ref "arm_ld_sched")))
 
 ;; Classification of NEON instructions for scheduling purposes.
-;; Do not set this attribute and the "type" attribute together in
-;; any one instruction pattern.
 (define_attr "neon_type"
    "neon_int_1,\
    neon_int_2,\
@@ -415,7 +420,7 @@
 
 (define_attr "generic_sched" "yes,no"
   (const (if_then_else 
-          (ior (eq_attr "tune" "arm926ejs,arm1020e,arm1026ejs,arm1136js,arm1136jfs,cortexa8,cortexa9")
+          (ior (eq_attr "tune" "arm926ejs,arm1020e,arm1026ejs,arm1136js,arm1136jfs,cortexa5,cortexa8,cortexa9,marvell_f")
 	      (eq_attr "tune_cortexr4" "yes"))
           (const_string "no")
           (const_string "yes"))))
@@ -423,20 +428,37 @@
 (define_attr "generic_vfp" "yes,no"
   (const (if_then_else
 	  (and (eq_attr "fpu" "vfp")
-	       (eq_attr "tune" "!arm1020e,arm1022e,cortexa8,cortexa9")
+	       (eq_attr "tune" "!arm1020e,arm1022e,cortexa5,cortexa8,cortexa9,marvell_f")
 	       (eq_attr "tune_cortexr4" "no"))
 	  (const_string "yes")
 	  (const_string "no"))))
 
+; Specifies which machine an alternative is tuned for.  Used to compute
+; attribute ENABLED.
+(define_attr "alt_tune" "all,onlya8,nota8" (const_string "all"))
+
+(define_attr "enabled" ""
+  (cond [(and (eq_attr "alt_tune" "onlya8")
+	      (not (eq_attr "tune" "cortexa8")))
+	 (const_int 0)
+
+	 (and (eq_attr "alt_tune" "nota8")
+	      (eq_attr "tune" "cortexa8"))
+	 (const_int 0)]
+	(const_int 1)))
+
 (include "arm-generic.md")
 (include "arm926ejs.md")
 (include "arm1020e.md")
 (include "arm1026ejs.md")
 (include "arm1136jfs.md")
+(include "cortex-a5.md")
 (include "cortex-a8.md")
 (include "cortex-a9.md")
 (include "cortex-r4.md")
 (include "cortex-r4f.md")
+(include "marvell-f.md")
+(include "marvell-f-vfp.md")
 (include "vfp11.md")
 
 
@@ -495,9 +517,10 @@
 	(plus:DI (match_operand:DI 1 "s_register_operand" "%0, 0")
 		 (match_operand:DI 2 "s_register_operand" "r,  0")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)"
+  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_MAVERICK) && !TARGET_NEON"
   "#"
-  "TARGET_32BIT && reload_completed"
+  "TARGET_32BIT && reload_completed
+   && ! (TARGET_NEON && IS_VFP_REGNUM (REGNO (operands[0])))"
   [(parallel [(set (reg:CC_C CC_REGNUM)
 		   (compare:CC_C (plus:SI (match_dup 1) (match_dup 2))
 				 (match_dup 1)))
@@ -521,7 +544,7 @@
   [(set (match_operand:DI 0 "s_register_operand" "=&r,&r")
 	(plus:DI (sign_extend:DI
 		  (match_operand:SI 2 "s_register_operand" "r,r"))
-		 (match_operand:DI 1 "s_register_operand" "r,0")))
+		 (match_operand:DI 1 "s_register_operand" "0,r")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)"
   "#"
@@ -550,7 +573,7 @@
   [(set (match_operand:DI 0 "s_register_operand" "=&r,&r")
 	(plus:DI (zero_extend:DI
 		  (match_operand:SI 2 "s_register_operand" "r,r"))
-		 (match_operand:DI 1 "s_register_operand" "r,0")))
+		 (match_operand:DI 1 "s_register_operand" "0,r")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)"
   "#"
@@ -620,10 +643,11 @@
    sub%?\\t%0, %1, #%n2
    sub%?\\t%0, %1, #%n2
    #"
-  "TARGET_32BIT &&
-   GET_CODE (operands[2]) == CONST_INT
+  "TARGET_32BIT
+   && GET_CODE (operands[2]) == CONST_INT
    && !(const_ok_for_arm (INTVAL (operands[2]))
-        || const_ok_for_arm (-INTVAL (operands[2])))"
+        || const_ok_for_arm (-INTVAL (operands[2])))
+   && (reload_completed || !arm_eliminable_register (operands[1]))"
   [(clobber (const_int 0))]
   "
   arm_split_constant (PLUS, SImode, curr_insn,
@@ -639,10 +663,10 @@
 ;; register.  Trying to reload it will always fail catastrophically,
 ;; so never allow those alternatives to match if reloading is needed.
 
-(define_insn "*thumb1_addsi3"
-  [(set (match_operand:SI          0 "register_operand" "=l,l,l,*rk,*hk,l,!k")
-	(plus:SI (match_operand:SI 1 "register_operand" "%0,0,l,*0,*0,!k,!k")
-		 (match_operand:SI 2 "nonmemory_operand" "I,J,lL,*hk,*rk,!M,!O")))]
+(define_insn_and_split "*thumb1_addsi3"
+  [(set (match_operand:SI          0 "register_operand" "=l,l,l,*rk,*hk,l,!k,l,l")
+	(plus:SI (match_operand:SI 1 "register_operand" "%0,0,l,*0,*0,!k,!k,0,l")
+		 (match_operand:SI 2 "nonmemory_operand" "I,J,lL,*hk,*rk,!M,!O,Pa,Pb")))]
   "TARGET_THUMB1"
   "*
    static const char * const asms[] = 
@@ -653,7 +677,9 @@
      \"add\\t%0, %0, %2\",
      \"add\\t%0, %0, %2\",
      \"add\\t%0, %1, %2\",
-     \"add\\t%0, %1, %2\"
+     \"add\\t%0, %1, %2\",
+     \"#\",
+     \"#\"
    };
    if ((which_alternative == 2 || which_alternative == 6)
        && GET_CODE (operands[2]) == CONST_INT
@@ -661,7 +687,22 @@
      return \"sub\\t%0, %1, #%n2\";
    return asms[which_alternative];
   "
-  [(set_attr "length" "2")]
+  "&& reload_completed && CONST_INT_P (operands[2])
+   && operands[1] != stack_pointer_rtx
+   && (INTVAL (operands[2]) > 255 || INTVAL (operands[2]) < -255)"
+  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))
+   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]
+  {
+    HOST_WIDE_INT offset = INTVAL (operands[2]);
+    if (offset > 255)
+      offset = 255;
+    else if (offset < -255)
+      offset = -255;
+    
+    operands[3] = GEN_INT (offset);
+    operands[2] = GEN_INT (INTVAL (operands[2]) - offset);
+  }
+  [(set_attr "length" "2,2,2,2,2,2,2,4,4")]
 )
 
 ;; Reloading and elimination of the frame pointer can
@@ -678,7 +719,6 @@
   ""
 )
 
-;; ??? Make Thumb-2 variants which prefer low regs
 (define_insn "*addsi3_compare0"
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV
@@ -687,7 +727,7 @@
 	 (const_int 0)))
    (set (match_operand:SI 0 "s_register_operand" "=r,r")
 	(plus:SI (match_dup 1) (match_dup 2)))]
-  "TARGET_32BIT"
+  "TARGET_ARM"
   "@
    add%.\\t%0, %1, %2
    sub%.\\t%0, %1, #%n2"
@@ -700,7 +740,7 @@
 	 (plus:SI (match_operand:SI 0 "s_register_operand" "r, r")
 		  (match_operand:SI 1 "arm_add_operand"    "rI,L"))
 	 (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_ARM"
   "@
    cmn%?\\t%0, %1
    cmp%?\\t%0, #%n1"
@@ -854,7 +894,11 @@
   [(set_attr "conds" "use")
    (set (attr "type") (if_then_else (match_operand 4 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*addsi3_carryin_alt1"
@@ -938,7 +982,7 @@
   [(set (match_operand:DF          0 "s_register_operand" "")
 	(plus:DF (match_operand:DF 1 "s_register_operand" "")
 		 (match_operand:DF 2 "arm_float_add_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   if (TARGET_MAVERICK
       && !cirrus_fp_register (operands[2], DFmode))
@@ -977,7 +1021,7 @@
 	(minus:DI (match_operand:DI 1 "s_register_operand" "0,r,0")
 		  (match_operand:DI 2 "s_register_operand" "r,0,0")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NEON"
   "subs\\t%Q0, %Q1, %Q2\;sbc\\t%R0, %R1, %R2"
   [(set_attr "conds" "clob")
    (set_attr "length" "8")]
@@ -995,7 +1039,7 @@
 
 (define_insn "*subdi_di_zesidi"
   [(set (match_operand:DI           0 "s_register_operand" "=&r,&r")
-	(minus:DI (match_operand:DI 1 "s_register_operand"  "?r,0")
+	(minus:DI (match_operand:DI 1 "s_register_operand"  "0,r")
 		  (zero_extend:DI
 		   (match_operand:SI 2 "s_register_operand"  "r,r"))))
    (clobber (reg:CC CC_REGNUM))]
@@ -1007,7 +1051,7 @@
 
 (define_insn "*subdi_di_sesidi"
   [(set (match_operand:DI            0 "s_register_operand" "=&r,&r")
-	(minus:DI (match_operand:DI  1 "s_register_operand"  "r,0")
+	(minus:DI (match_operand:DI  1 "s_register_operand"  "0,r")
 		  (sign_extend:DI
 		   (match_operand:SI 2 "s_register_operand"  "r,r"))))
    (clobber (reg:CC CC_REGNUM))]
@@ -1021,7 +1065,7 @@
   [(set (match_operand:DI            0 "s_register_operand" "=&r,&r")
 	(minus:DI (zero_extend:DI
 		   (match_operand:SI 2 "s_register_operand"  "r,r"))
-		  (match_operand:DI  1 "s_register_operand" "?r,0")))
+		  (match_operand:DI  1 "s_register_operand" "0,r")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_ARM"
   "rsbs\\t%Q0, %Q1, %2\;rsc\\t%R0, %R1, #0"
@@ -1033,7 +1077,7 @@
   [(set (match_operand:DI            0 "s_register_operand" "=&r,&r")
 	(minus:DI (sign_extend:DI
 		   (match_operand:SI 2 "s_register_operand"   "r,r"))
-		  (match_operand:DI  1 "s_register_operand"  "?r,0")))
+		  (match_operand:DI  1 "s_register_operand"  "0,r")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_ARM"
   "rsbs\\t%Q0, %Q1, %2\;rsc\\t%R0, %R1, %2, asr #31"
@@ -1176,7 +1220,7 @@
   [(set (match_operand:DF           0 "s_register_operand" "")
 	(minus:DF (match_operand:DF 1 "arm_float_rhs_operand" "")
 		  (match_operand:DF 2 "arm_float_rhs_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   if (TARGET_MAVERICK)
     {
@@ -1202,7 +1246,7 @@
 (define_insn "*arm_mulsi3"
   [(set (match_operand:SI          0 "s_register_operand" "=&r,&r")
 	(mult:SI (match_operand:SI 2 "s_register_operand" "r,r")
-		 (match_operand:SI 1 "s_register_operand" "%?r,0")))]
+		 (match_operand:SI 1 "s_register_operand" "%0,r")))]
   "TARGET_32BIT && !arm_arch6"
   "mul%?\\t%0, %2, %1"
   [(set_attr "insn" "mul")
@@ -1245,8 +1289,8 @@
 		 (match_operand:SI 2 "register_operand" "l,0,0")))]
   "TARGET_THUMB1 && arm_arch6"
   "@
-   mul\\t%0, %2 
-   mul\\t%0, %1 
+   mul\\t%0, %2
+   mul\\t%0, %1
    mul\\t%0, %1"
   [(set_attr "length" "2")
    (set_attr "insn" "mul")]
@@ -1256,7 +1300,7 @@
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV (mult:SI
 			  (match_operand:SI 2 "s_register_operand" "r,r")
-			  (match_operand:SI 1 "s_register_operand" "%?r,0"))
+			  (match_operand:SI 1 "s_register_operand" "%0,r"))
 			 (const_int 0)))
    (set (match_operand:SI 0 "s_register_operand" "=&r,&r")
 	(mult:SI (match_dup 2) (match_dup 1)))]
@@ -1284,7 +1328,7 @@
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV (mult:SI
 			  (match_operand:SI 2 "s_register_operand" "r,r")
-			  (match_operand:SI 1 "s_register_operand" "%?r,0"))
+			  (match_operand:SI 1 "s_register_operand" "%0,r"))
 			 (const_int 0)))
    (clobber (match_scratch:SI 0 "=&r,&r"))]
   "TARGET_ARM && !arm_arch6"
@@ -1312,8 +1356,8 @@
   [(set (match_operand:SI 0 "s_register_operand" "=&r,&r,&r,&r")
 	(plus:SI
 	  (mult:SI (match_operand:SI 2 "s_register_operand" "r,r,r,r")
-		   (match_operand:SI 1 "s_register_operand" "%r,0,r,0"))
-	  (match_operand:SI 3 "s_register_operand" "?r,r,0,0")))]
+		   (match_operand:SI 1 "s_register_operand" "%0,r,0,r"))
+	  (match_operand:SI 3 "s_register_operand" "r,r,0,0")))]
   "TARGET_32BIT && !arm_arch6"
   "mla%?\\t%0, %2, %1, %3"
   [(set_attr "insn" "mla")
@@ -1332,13 +1376,56 @@
    (set_attr "predicable" "yes")]
 )
 
+; The combiner cannot combine the first and last insns in the
+; following sequence because of the intervening insn, so help the
+; combiner with this splitter.  The combiner does attempt to split
+; this particular combination but does not know this exact split.
+; Note that the combiner puts the constant at the outermost operation
+; as a part of canonicalization.
+;
+; mul r3, r2, r1
+; <add/sub> r3, r3, <constant>
+; add r3, r3, r4
+
+(define_split
+  [(set (match_operand:SI 0 "s_register_operand" "")
+	(match_operator:SI 1 "plusminus_operator"
+	 [(plus:SI (mult:SI (match_operand:SI 2 "s_register_operand" "")
+			    (match_operand:SI 3 "s_register_operand" ""))
+		   (match_operand:SI 4 "s_register_operand" ""))
+	  (match_operand:SI 5 "arm_immediate_operand" "")]))]
+  "TARGET_32BIT"
+  [(set (match_dup 0)
+	(plus:SI (mult:SI (match_dup 2) (match_dup 3))
+		 (match_dup 4)))
+   (set (match_dup 0)
+	(match_op_dup:SI 1 [(match_dup 0) (match_dup 5)]))]
+  "")
+
+; Likewise for MLS.  MLS is available only on select architectures.
+
+(define_split
+  [(set (match_operand:SI 0 "s_register_operand" "")
+	(match_operator:SI 1 "plusminus_operator"
+	 [(minus:SI (match_operand:SI 2 "s_register_operand" "")
+		    (mult:SI (match_operand:SI 3 "s_register_operand" "")
+			     (match_operand:SI 4 "s_register_operand" "")))
+	  (match_operand:SI 5 "arm_immediate_operand" "")]))]
+  "TARGET_32BIT && arm_arch_thumb2"
+  [(set (match_dup 0)
+	(minus:SI (match_dup 2)
+		  (mult:SI (match_dup 3) (match_dup 4))))
+   (set (match_dup 0)
+	(match_op_dup:SI 1 [(match_dup 0) (match_dup 5)]))]
+  "")
+
 (define_insn "*mulsi3addsi_compare0"
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV
 	 (plus:SI (mult:SI
 		   (match_operand:SI 2 "s_register_operand" "r,r,r,r")
-		   (match_operand:SI 1 "s_register_operand" "%r,0,r,0"))
-		  (match_operand:SI 3 "s_register_operand" "?r,r,0,0"))
+		   (match_operand:SI 1 "s_register_operand" "%0,r,0,r"))
+		  (match_operand:SI 3 "s_register_operand" "r,r,0,0"))
 	 (const_int 0)))
    (set (match_operand:SI 0 "s_register_operand" "=&r,&r,&r,&r")
 	(plus:SI (mult:SI (match_dup 2) (match_dup 1))
@@ -1371,7 +1458,7 @@
 	(compare:CC_NOOV
 	 (plus:SI (mult:SI
 		   (match_operand:SI 2 "s_register_operand" "r,r,r,r")
-		   (match_operand:SI 1 "s_register_operand" "%r,0,r,0"))
+		   (match_operand:SI 1 "s_register_operand" "%0,r,0,r"))
 		  (match_operand:SI 3 "s_register_operand" "?r,r,0,0"))
 	 (const_int 0)))
    (clobber (match_scratch:SI 0 "=&r,&r,&r,&r"))]
@@ -1551,7 +1638,7 @@
 	(truncate:SI
 	 (lshiftrt:DI
 	  (mult:DI
-	   (sign_extend:DI (match_operand:SI 1 "s_register_operand" "%r,0"))
+	   (sign_extend:DI (match_operand:SI 1 "s_register_operand" "%0,r"))
 	   (sign_extend:DI (match_operand:SI 2 "s_register_operand" "r,r")))
 	  (const_int 32))))
    (clobber (match_scratch:SI 3 "=&r,&r"))]
@@ -1595,7 +1682,7 @@
 	(truncate:SI
 	 (lshiftrt:DI
 	  (mult:DI
-	   (zero_extend:DI (match_operand:SI 1 "s_register_operand" "%r,0"))
+	   (zero_extend:DI (match_operand:SI 1 "s_register_operand" "%0,r"))
 	   (zero_extend:DI (match_operand:SI 2 "s_register_operand" "r,r")))
 	  (const_int 32))))
    (clobber (match_scratch:SI 3 "=&r,&r"))]
@@ -1713,7 +1800,7 @@
   [(set (match_operand:DF          0 "s_register_operand" "")
 	(mult:DF (match_operand:DF 1 "s_register_operand" "")
 		 (match_operand:DF 2 "arm_float_rhs_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   if (TARGET_MAVERICK
       && !cirrus_fp_register (operands[2], DFmode))
@@ -1733,7 +1820,7 @@
   [(set (match_operand:DF 0 "s_register_operand" "")
 	(div:DF (match_operand:DF 1 "arm_float_rhs_operand" "")
 		(match_operand:DF 2 "arm_float_rhs_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)"
   "")
 
 ;; Modulo insns
@@ -1764,6 +1851,7 @@
 	  [(match_operand:DI 1 "s_register_operand" "")
 	   (match_operand:DI 2 "s_register_operand" "")]))]
   "TARGET_32BIT && reload_completed
+   && ! (TARGET_NEON && IS_VFP_REGNUM (REGNO (operands[0])))
    && ! IS_IWMMXT_REGNUM (REGNO (operands[0]))"
   [(set (match_dup 0) (match_op_dup:SI 6 [(match_dup 1) (match_dup 2)]))
    (set (match_dup 3) (match_op_dup:SI 6 [(match_dup 4) (match_dup 5)]))]
@@ -1837,11 +1925,19 @@
   }"
 )
 
-(define_insn "anddi3"
+(define_expand "anddi3"
+  [(set (match_operand:DI         0 "s_register_operand" "")
+	(and:DI (match_operand:DI 1 "s_register_operand" "")
+		(match_operand:DI 2 "neon_inv_logic_op2" "")))]
+  "TARGET_32BIT"
+  ""
+)
+
+(define_insn "*anddi3_insn"
   [(set (match_operand:DI         0 "s_register_operand" "=&r,&r")
 	(and:DI (match_operand:DI 1 "s_register_operand"  "%0,r")
 		(match_operand:DI 2 "s_register_operand"   "r,r")))]
-  "TARGET_32BIT && ! TARGET_IWMMXT"
+  "TARGET_32BIT && !TARGET_IWMMXT && !TARGET_NEON"
   "#"
   [(set_attr "length" "8")]
 )
@@ -1850,7 +1946,7 @@
   [(set (match_operand:DI 0 "s_register_operand" "=&r,&r")
 	(and:DI (zero_extend:DI
 		 (match_operand:SI 2 "s_register_operand" "r,r"))
-		(match_operand:DI 1 "s_register_operand" "?r,0")))]
+		(match_operand:DI 1 "s_register_operand" "0,r")))]
   "TARGET_32BIT"
   "#"
   "TARGET_32BIT && reload_completed"
@@ -1871,7 +1967,7 @@
   [(set (match_operand:DI          0 "s_register_operand" "=&r,&r")
 	(and:DI (sign_extend:DI
 		 (match_operand:SI 2 "s_register_operand" "r,r"))
-		(match_operand:DI  1 "s_register_operand" "?r,0")))]
+		(match_operand:DI  1 "s_register_operand" "0,r")))]
   "TARGET_32BIT"
   "#"
   [(set_attr "length" "8")]
@@ -1960,6 +2056,7 @@
   DONE;
   "
   [(set_attr "length" "4,4,16")
+   (set_attr "insn" "and")
    (set_attr "predicable" "yes")]
 )
 
@@ -1969,7 +2066,8 @@
 		(match_operand:SI 2 "register_operand" "l")))]
   "TARGET_THUMB1"
   "and\\t%0, %0, %2"
-  [(set_attr "length" "2")]
+  [(set_attr "length" "2")
+   (set_attr "insn" "and")]
 )
 
 (define_insn "*andsi3_compare0"
@@ -1984,7 +2082,8 @@
   "@
    and%.\\t%0, %1, %2
    bic%.\\t%0, %1, #%B2"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "and,*")]
 )
 
 (define_insn "*andsi3_compare0_scratch"
@@ -2280,7 +2379,7 @@
 	  }
       }
 
-    target = operands[0];
+    target = copy_rtx (operands[0]);
     /* Avoid using a subreg as a subtarget, and avoid writing a paradoxical 
        subreg as the final target.  */
     if (GET_CODE (target) == SUBREG)
@@ -2430,9 +2529,11 @@
   [(set (match_operand:DI 0 "s_register_operand" "=&r,&r")
 	(and:DI (not:DI (match_operand:DI 1 "s_register_operand" "r,0"))
 		(match_operand:DI 2 "s_register_operand" "0,r")))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NEON"
   "#"
-  "TARGET_32BIT && reload_completed && ! IS_IWMMXT_REGNUM (REGNO (operands[0]))"
+  "TARGET_32BIT && reload_completed
+   && ! (TARGET_NEON && IS_VFP_REGNUM (REGNO (operands[0])))
+   && ! IS_IWMMXT_REGNUM (REGNO (operands[0]))"
   [(set (match_dup 0) (and:SI (not:SI (match_dup 1)) (match_dup 2)))
    (set (match_dup 3) (and:SI (not:SI (match_dup 4)) (match_dup 5)))]
   "
@@ -2528,7 +2629,11 @@
    (set_attr "shift" "2")
    (set (attr "type") (if_then_else (match_operand 3 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*andsi_notsi_si_compare0"
@@ -2556,11 +2661,19 @@
   [(set_attr "conds" "set")]
 )
 
-(define_insn "iordi3"
+(define_expand "iordi3"
+  [(set (match_operand:DI         0 "s_register_operand" "")
+	(ior:DI (match_operand:DI 1 "s_register_operand" "")
+		(match_operand:DI 2 "neon_logic_op2" "")))]
+  "TARGET_32BIT"
+  ""
+)
+
+(define_insn "*iordi3_insn"
   [(set (match_operand:DI         0 "s_register_operand" "=&r,&r")
 	(ior:DI (match_operand:DI 1 "s_register_operand"  "%0,r")
 		(match_operand:DI 2 "s_register_operand"   "r,r")))]
-  "TARGET_32BIT && ! TARGET_IWMMXT"
+  "TARGET_32BIT && !TARGET_IWMMXT && !TARGET_NEON"
   "#"
   [(set_attr "length" "8")
    (set_attr "predicable" "yes")]
@@ -2576,6 +2689,7 @@
    orr%?\\t%Q0, %Q1, %2
    #"
   [(set_attr "length" "4,8")
+   (set_attr "insn" "orr")
    (set_attr "predicable" "yes")]
 )
 
@@ -2583,7 +2697,7 @@
   [(set (match_operand:DI 0 "s_register_operand" "=&r,&r")
 	(ior:DI (sign_extend:DI
 		 (match_operand:SI 2 "s_register_operand" "r,r"))
-		(match_operand:DI 1 "s_register_operand" "?r,0")))]
+		(match_operand:DI 1 "s_register_operand" "0,r")))]
   "TARGET_32BIT"
   "#"
   [(set_attr "length" "8")
@@ -2638,7 +2752,8 @@
 		(match_operand:SI 2 "register_operand" "l")))]
   "TARGET_THUMB1"
   "orr\\t%0, %0, %2"
-  [(set_attr "length" "2")]
+  [(set_attr "length" "2")
+   (set_attr "insn" "orr")]
 )
 
 (define_peephole2
@@ -2663,7 +2778,8 @@
 	(ior:SI (match_dup 1) (match_dup 2)))]
   "TARGET_32BIT"
   "orr%.\\t%0, %1, %2"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "orr")]
 )
 
 (define_insn "*iorsi3_compare0_scratch"
@@ -2674,14 +2790,23 @@
    (clobber (match_scratch:SI 0 "=r"))]
   "TARGET_32BIT"
   "orr%.\\t%0, %1, %2"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "orr")]
+)
+
+(define_expand "xordi3"
+  [(set (match_operand:DI         0 "s_register_operand" "")
+	(xor:DI (match_operand:DI 1 "s_register_operand" "")
+		(match_operand:DI 2 "s_register_operand" "")))]
+  "TARGET_32BIT"
+  ""
 )
 
-(define_insn "xordi3"
+(define_insn "*xordi3_insn"
   [(set (match_operand:DI         0 "s_register_operand" "=&r,&r")
 	(xor:DI (match_operand:DI 1 "s_register_operand"  "%0,r")
 		(match_operand:DI 2 "s_register_operand"   "r,r")))]
-  "TARGET_32BIT && !TARGET_IWMMXT"
+  "TARGET_32BIT && !TARGET_IWMMXT && !TARGET_NEON"
   "#"
   [(set_attr "length" "8")
    (set_attr "predicable" "yes")]
@@ -2697,14 +2822,15 @@
    eor%?\\t%Q0, %Q1, %2
    #"
   [(set_attr "length" "4,8")
-   (set_attr "predicable" "yes")]
+   (set_attr "predicable" "yes")
+   (set_attr "insn" "eor")]
 )
 
 (define_insn "*xordi_sesidi_di"
   [(set (match_operand:DI 0 "s_register_operand" "=&r,&r")
 	(xor:DI (sign_extend:DI
 		 (match_operand:SI 2 "s_register_operand" "r,r"))
-		(match_operand:DI 1 "s_register_operand" "?r,0")))]
+		(match_operand:DI 1 "s_register_operand" "0,r")))]
   "TARGET_32BIT"
   "#"
   [(set_attr "length" "8")
@@ -2728,7 +2854,8 @@
 		(match_operand:SI 2 "arm_rhs_operand" "rI")))]
   "TARGET_32BIT"
   "eor%?\\t%0, %1, %2"
-  [(set_attr "predicable" "yes")]
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "eor")]
 )
 
 (define_insn "*thumb1_xorsi3"
@@ -2737,7 +2864,8 @@
 		(match_operand:SI 2 "register_operand" "l")))]
   "TARGET_THUMB1"
   "eor\\t%0, %0, %2"
-  [(set_attr "length" "2")]
+  [(set_attr "length" "2")
+   (set_attr "insn" "eor")]
 )
 
 (define_insn "*xorsi3_compare0"
@@ -2749,7 +2877,8 @@
 	(xor:SI (match_dup 1) (match_dup 2)))]
   "TARGET_32BIT"
   "eor%.\\t%0, %1, %2"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "eor")]
 )
 
 (define_insn "*xorsi3_compare0_scratch"
@@ -2781,7 +2910,7 @@
 
 (define_insn "*andsi_iorsi3_notsi"
   [(set (match_operand:SI 0 "s_register_operand" "=&r,&r,&r")
-	(and:SI (ior:SI (match_operand:SI 1 "s_register_operand" "r,r,0")
+	(and:SI (ior:SI (match_operand:SI 1 "s_register_operand" "%0,r,r")
 			(match_operand:SI 2 "arm_rhs_operand" "rI,0,rI"))
 		(not:SI (match_operand:SI 3 "arm_rhs_operand" "rI,rI,rI"))))]
   "TARGET_32BIT"
@@ -2906,7 +3035,7 @@
 	 (smax:SI (match_operand:SI 1 "s_register_operand" "")
 		  (match_operand:SI 2 "arm_rhs_operand" "")))
     (clobber (reg:CC CC_REGNUM))])]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "
   if (operands[2] == const0_rtx || operands[2] == constm1_rtx)
     {
@@ -2933,7 +3062,8 @@
 		 (const_int -1)))]
   "TARGET_32BIT"
   "orr%?\\t%0, %1, %1, asr #31"
-  [(set_attr "predicable" "yes")]
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "orr")]
 )
 
 (define_insn "*arm_smax_insn"
@@ -2941,7 +3071,7 @@
 	(smax:SI (match_operand:SI 1 "s_register_operand"  "%0,?r")
 		 (match_operand:SI 2 "arm_rhs_operand"    "rI,rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_COND_EXEC"
   "@
    cmp\\t%1, %2\;movlt\\t%0, %2
    cmp\\t%1, %2\;movge\\t%0, %1\;movlt\\t%0, %2"
@@ -2955,7 +3085,7 @@
 	 (smin:SI (match_operand:SI 1 "s_register_operand" "")
 		  (match_operand:SI 2 "arm_rhs_operand" "")))
     (clobber (reg:CC CC_REGNUM))])]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "
   if (operands[2] == const0_rtx)
     {
@@ -2973,7 +3103,8 @@
 		 (const_int 0)))]
   "TARGET_32BIT"
   "and%?\\t%0, %1, %1, asr #31"
-  [(set_attr "predicable" "yes")]
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "and")]
 )
 
 (define_insn "*arm_smin_insn"
@@ -2981,7 +3112,7 @@
 	(smin:SI (match_operand:SI 1 "s_register_operand" "%0,?r")
 		 (match_operand:SI 2 "arm_rhs_operand" "rI,rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM  && !TARGET_NO_COND_EXEC"
   "@
    cmp\\t%1, %2\;movge\\t%0, %2
    cmp\\t%1, %2\;movlt\\t%0, %1\;movge\\t%0, %2"
@@ -2995,7 +3126,7 @@
 	 (umax:SI (match_operand:SI 1 "s_register_operand" "")
 		  (match_operand:SI 2 "arm_rhs_operand" "")))
     (clobber (reg:CC CC_REGNUM))])]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   ""
 )
 
@@ -3004,7 +3135,7 @@
 	(umax:SI (match_operand:SI 1 "s_register_operand" "0,r,?r")
 		 (match_operand:SI 2 "arm_rhs_operand" "rI,0,rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM  && !TARGET_NO_COND_EXEC"
   "@
    cmp\\t%1, %2\;movcc\\t%0, %2
    cmp\\t%1, %2\;movcs\\t%0, %1
@@ -3019,7 +3150,7 @@
 	 (umin:SI (match_operand:SI 1 "s_register_operand" "")
 		  (match_operand:SI 2 "arm_rhs_operand" "")))
     (clobber (reg:CC CC_REGNUM))])]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   ""
 )
 
@@ -3028,7 +3159,7 @@
 	(umin:SI (match_operand:SI 1 "s_register_operand" "0,r,?r")
 		 (match_operand:SI 2 "arm_rhs_operand" "rI,0,rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_COND_EXEC"
   "@
    cmp\\t%1, %2\;movcs\\t%0, %2
    cmp\\t%1, %2\;movcc\\t%0, %1
@@ -3043,7 +3174,7 @@
 	 [(match_operand:SI 1 "s_register_operand" "r")
 	  (match_operand:SI 2 "s_register_operand" "r")]))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "*
   operands[3] = gen_rtx_fmt_ee (minmax_code (operands[3]), SImode,
 				operands[1], operands[2]);
@@ -3135,7 +3266,7 @@
 
 (define_insn "arm_ashldi3_1bit"
   [(set (match_operand:DI            0 "s_register_operand" "=&r,r")
-        (ashift:DI (match_operand:DI 1 "s_register_operand" "?r,0")
+        (ashift:DI (match_operand:DI 1 "s_register_operand" "0,r")
                    (const_int 1)))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_32BIT"
@@ -3163,11 +3294,23 @@
   [(set (match_operand:SI            0 "register_operand" "=l,l")
 	(ashift:SI (match_operand:SI 1 "register_operand" "l,0")
 		   (match_operand:SI 2 "nonmemory_operand" "N,l")))]
-  "TARGET_THUMB1"
+  "TARGET_THUMB1 && !janus2_code"
   "lsl\\t%0, %1, %2"
   [(set_attr "length" "2")]
 )
 
+(define_insn "*thumb1_ashlsi3_janus2"
+  [(set (match_operand:SI            0 "register_operand" "=l,l")
+        (ashift:SI (match_operand:SI 1 "register_operand" "l,0")
+                   (match_operand:SI 2 "nonmemory_operand" "N,l")))]
+  "TARGET_THUMB1 && janus2_code"
+  "@
+  lsl\\t%0, %1, %2
+  lsl\\t%0, %1, %2\;nop"
+  [(set_attr "length" "2,4")]
+)
+
+
 (define_expand "ashrdi3"
   [(set (match_operand:DI              0 "s_register_operand" "")
         (ashiftrt:DI (match_operand:DI 1 "s_register_operand" "")
@@ -3194,12 +3337,13 @@
 
 (define_insn "arm_ashrdi3_1bit"
   [(set (match_operand:DI              0 "s_register_operand" "=&r,r")
-        (ashiftrt:DI (match_operand:DI 1 "s_register_operand" "?r,0")
+        (ashiftrt:DI (match_operand:DI 1 "s_register_operand" "0,r")
                      (const_int 1)))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_32BIT"
   "movs\\t%R0, %R1, asr #1\;mov\\t%Q0, %Q1, rrx"
   [(set_attr "conds" "clob")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -3219,11 +3363,22 @@
   [(set (match_operand:SI              0 "register_operand" "=l,l")
 	(ashiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
 		     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
-  "TARGET_THUMB1"
+  "TARGET_THUMB1 && !janus2_code"
   "asr\\t%0, %1, %2"
   [(set_attr "length" "2")]
 )
 
+(define_insn "*thumb1_ashrsi3_janus2"
+  [(set (match_operand:SI              0 "register_operand" "=l,l")
+        (ashiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
+                     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
+  "TARGET_THUMB1 && janus2_code"
+  "@
+  asr\\t%0, %1, %2
+  asr\\t%0, %1, %2\;nop"
+  [(set_attr "length" "2,4")]
+)
+
 (define_expand "lshrdi3"
   [(set (match_operand:DI              0 "s_register_operand" "")
         (lshiftrt:DI (match_operand:DI 1 "s_register_operand" "")
@@ -3250,12 +3405,13 @@
 
 (define_insn "arm_lshrdi3_1bit"
   [(set (match_operand:DI              0 "s_register_operand" "=&r,r")
-        (lshiftrt:DI (match_operand:DI 1 "s_register_operand" "?r,0")
+        (lshiftrt:DI (match_operand:DI 1 "s_register_operand" "0,r")
                      (const_int 1)))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_32BIT"
   "movs\\t%R0, %R1, lsr #1\;mov\\t%Q0, %Q1, rrx"
   [(set_attr "conds" "clob")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -3278,11 +3434,22 @@
   [(set (match_operand:SI              0 "register_operand" "=l,l")
 	(lshiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
 		     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
-  "TARGET_THUMB1"
+  "TARGET_THUMB1 && !janus2_code"
   "lsr\\t%0, %1, %2"
   [(set_attr "length" "2")]
 )
 
+(define_insn "*thumb1_lshrsi3_janus2"
+  [(set (match_operand:SI              0 "register_operand" "=l,l")
+        (lshiftrt:SI (match_operand:SI 1 "register_operand" "l,0")
+                     (match_operand:SI 2 "nonmemory_operand" "N,l")))]
+  "TARGET_THUMB1 && janus2_code"
+  "@
+  lsr\\t%0, %1, %2
+  lsr\\t%0, %1, %2; nop"
+  [(set_attr "length" "2,4")]
+)
+
 (define_expand "rotlsi3"
   [(set (match_operand:SI              0 "s_register_operand" "")
 	(rotatert:SI (match_operand:SI 1 "s_register_operand" "")
@@ -3324,11 +3491,20 @@
   [(set (match_operand:SI              0 "register_operand" "=l")
 	(rotatert:SI (match_operand:SI 1 "register_operand" "0")
 		     (match_operand:SI 2 "register_operand" "l")))]
-  "TARGET_THUMB1"
+  "TARGET_THUMB1 && !janus2_code"
   "ror\\t%0, %0, %2"
   [(set_attr "length" "2")]
 )
 
+(define_insn "*thumb1_rotrsi3_janus2"
+  [(set (match_operand:SI              0 "register_operand" "=l")
+        (rotatert:SI (match_operand:SI 1 "register_operand" "0")
+                     (match_operand:SI 2 "register_operand" "l")))]
+  "TARGET_THUMB1 && janus2_code"
+  "ror\\t%0, %0, %2; nop"
+  [(set_attr "length" "4")]
+)
+
 (define_insn "*arm_shiftsi3"
   [(set (match_operand:SI   0 "s_register_operand" "=r")
 	(match_operator:SI  3 "shift_operator"
@@ -3340,7 +3516,11 @@
    (set_attr "shift" "1")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*shiftsi3_compare0"
@@ -3357,7 +3537,11 @@
    (set_attr "shift" "1")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*shiftsi3_compare0_scratch"
@@ -3370,7 +3554,11 @@
   "TARGET_32BIT"
   "* return arm_output_shift(operands, 1);"
   [(set_attr "conds" "set")
-   (set_attr "shift" "1")]
+   (set_attr "shift" "1")
+   (set (attr "length") (if_then_else (and (match_operand 2 "s_register_operand" "")
+                                           (eq_attr "fix_janus" "yes"))
+                                      (const_int 8)
+                                      (const_int 4)))]
 )
 
 (define_insn "*arm_notsi_shiftsi"
@@ -3382,9 +3570,14 @@
   "mvn%?\\t%0, %1%S3"
   [(set_attr "predicable" "yes")
    (set_attr "shift" "1")
+   (set_attr "insn" "mvn")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*arm_notsi_shiftsi_compare0"
@@ -3399,9 +3592,14 @@
   "mvn%.\\t%0, %1%S3"
   [(set_attr "conds" "set")
    (set_attr "shift" "1")
+   (set_attr "insn" "mvn")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*arm_not_shiftsi_compare0_scratch"
@@ -3415,9 +3613,14 @@
   "mvn%.\\t%0, %1%S3"
   [(set_attr "conds" "set")
    (set_attr "shift" "1")
+   (set_attr "insn" "mvn")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 ;; We don't really have extzv, but defining this using shifts helps
@@ -3497,10 +3700,10 @@
 )
 
 ;; The constraints here are to prevent a *partial* overlap (where %Q0 == %R1).
-;; The second alternative is to allow the common case of a *full* overlap.
+;; The first alternative allows the common case of a *full* overlap.
 (define_insn "*arm_negdi2"
   [(set (match_operand:DI         0 "s_register_operand" "=&r,r")
-	(neg:DI (match_operand:DI 1 "s_register_operand"  "?r,0")))
+	(neg:DI (match_operand:DI 1 "s_register_operand"  "0,r")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_ARM"
   "rsbs\\t%Q0, %Q1, #0\;rsc\\t%R0, %R1, #0"
@@ -3550,12 +3753,12 @@
 (define_expand "negdf2"
   [(set (match_operand:DF         0 "s_register_operand" "")
 	(neg:DF (match_operand:DF 1 "s_register_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)"
   "")
 
 ;; abssi2 doesn't really clobber the condition codes if a different register
 ;; is being set.  To keep things simple, assume during rtl manipulations that
-;; it does, but tell the final scan operator the truth.  Similarly for
+;; it does, and the splitter will eliminate it.  Similarly for
 ;; (neg (abs...))
 
 (define_expand "abssi2"
@@ -3567,22 +3770,28 @@
   "
   if (TARGET_THUMB1)
     operands[2] = gen_rtx_SCRATCH (SImode);
+  else if (TARGET_NO_SINGLE_COND_EXEC)
+    {
+      emit_insn(gen_rtx_SET(VOIDmode, operands[0],
+			    gen_rtx_ABS(SImode, operands[1])));
+      DONE;
+    }
   else
     operands[2] = gen_rtx_REG (CCmode, CC_REGNUM);
 ")
 
 (define_insn "*arm_abssi2"
-  [(set (match_operand:SI 0 "s_register_operand" "=r,&r")
-	(abs:SI (match_operand:SI 1 "s_register_operand" "0,r")))
+  [(set (match_operand:SI         0 "s_register_operand" "=r")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "r")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
-  "@
-   cmp\\t%0, #0\;rsblt\\t%0, %0, #0
-   eor%?\\t%0, %1, %1, asr #31\;sub%?\\t%0, %0, %1, asr #31"
-  [(set_attr "conds" "clob,*")
-   (set_attr "shift" "1")
+  "TARGET_32BIT && !TARGET_NO_SINGLE_COND_EXEC"
+  "#"
+  [(set_attr "shift" "1")
    ;; predicable can't be set based on the variant, so left as no
-   (set_attr "length" "8")]
+   (set (attr "length")
+	(if_then_else (eq_attr "is_thumb" "yes")
+		      (const_int 10)
+		      (const_int 8)))]
 )
 
 (define_insn_and_split "*thumb1_abssi2"
@@ -3600,17 +3809,17 @@
 )
 
 (define_insn "*arm_neg_abssi2"
-  [(set (match_operand:SI 0 "s_register_operand" "=r,&r")
-	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "0,r"))))
+  [(set (match_operand:SI 0 "s_register_operand" "=r")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "r"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
-  "@
-   cmp\\t%0, #0\;rsbgt\\t%0, %0, #0
-   eor%?\\t%0, %1, %1, asr #31\;rsb%?\\t%0, %0, %1, asr #31"
-  [(set_attr "conds" "clob,*")
-   (set_attr "shift" "1")
+  "TARGET_32BIT && !TARGET_NO_SINGLE_COND_EXEC"
+  "#"
+  [(set_attr "shift" "1")
    ;; predicable can't be set based on the variant, so left as no
-   (set_attr "length" "8")]
+   (set (attr "length")
+	(if_then_else (eq_attr "is_thumb" "yes")
+		      (const_int 10)
+		      (const_int 8)))]
 )
 
 (define_insn_and_split "*thumb1_neg_abssi2"
@@ -3627,6 +3836,93 @@
   [(set_attr "length" "6")]
 )
 
+;; Simplified version for when avoiding conditional execution
+(define_insn "*arm_nocond_abssi2"
+  [(set (match_operand:SI         0 "s_register_operand" "=&r")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "r")))]
+  "TARGET_32BIT && TARGET_NO_SINGLE_COND_EXEC"
+  "#"
+  [(set_attr "shift" "1")
+   (set_attr "length" "8")
+   (set_attr "predicable" "yes")]
+)
+
+(define_insn "*arm_nocond_neg_abssi2"
+  [(set (match_operand:SI         0 "s_register_operand" "=&r")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "r"))))]
+  "TARGET_32BIT && TARGET_NO_SINGLE_COND_EXEC"
+  "#"
+  [(set_attr "shift" "1")
+   (set_attr "length" "8")
+   (set_attr "predicable" "yes")]
+)
+
+;; Splitters for ABS patterns.
+
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_32BIT && reload_completed && rtx_equal_p(operands[0], operands[1])"
+  [(set (reg:CC CC_REGNUM) (compare:CC (match_dup 1) (const_int 0)))
+   (cond_exec (lt (reg:CC CC_REGNUM) (const_int 0))
+	      (set (match_dup 0) (neg:SI (match_dup 1))))]
+)
+
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" ""))))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_32BIT && reload_completed && rtx_equal_p(operands[0], operands[1])"
+  [(set (reg:CC CC_REGNUM) (compare:CC (match_dup 1) (const_int 0)))
+   (cond_exec (gt (reg:CC CC_REGNUM) (const_int 0))
+	      (set (match_dup 0) (neg:SI (match_dup 1))))]
+)
+
+;; GCC does not add/remove clobbers when matching splitters, so we need
+;; variants with and without the CC clobber.
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "")))]
+  "TARGET_32BIT && reload_completed && !rtx_equal_p(operands[0], operands[1])"
+  [(set (match_dup 0) (xor:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+			      (match_dup 1)))
+   (set (match_dup 0) (minus:SI (match_dup 0)
+				(ashiftrt:SI (match_dup 1) (const_int 31))))]
+)
+
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(abs:SI (match_operand:SI 1 "s_register_operand" "")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_32BIT && reload_completed && !rtx_equal_p(operands[0], operands[1])"
+  [(set (match_dup 0) (xor:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+			      (match_dup 1)))
+   (set (match_dup 0) (minus:SI (match_dup 0)
+				(ashiftrt:SI (match_dup 1) (const_int 31))))]
+)
+
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" ""))))]
+  "TARGET_32BIT && reload_completed && !rtx_equal_p(operands[0], operands[1])"
+  [(set (match_dup 0) (xor:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+			      (match_dup 1)))
+   (set (match_dup 0) (minus:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+				(match_dup 0)))]
+)
+
+(define_split
+  [(set (match_operand:SI         0 "s_register_operand" "")
+	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" ""))))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_32BIT && reload_completed && !rtx_equal_p(operands[0], operands[1])"
+  [(set (match_dup 0) (xor:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+			      (match_dup 1)))
+   (set (match_dup 0) (minus:SI (ashiftrt:SI (match_dup 1) (const_int 31))
+				(match_dup 0)))]
+)
+
 (define_expand "abssf2"
   [(set (match_operand:SF         0 "s_register_operand" "")
 	(abs:SF (match_operand:SF 1 "s_register_operand" "")))]
@@ -3636,7 +3932,7 @@
 (define_expand "absdf2"
   [(set (match_operand:DF         0 "s_register_operand" "")
 	(abs:DF (match_operand:DF 1 "s_register_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "")
 
 (define_expand "sqrtsf2"
@@ -3648,12 +3944,12 @@
 (define_expand "sqrtdf2"
   [(set (match_operand:DF 0 "s_register_operand" "")
 	(sqrt:DF (match_operand:DF 1 "s_register_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)"
   "")
 
 (define_insn_and_split "one_cmpldi2"
   [(set (match_operand:DI 0 "s_register_operand" "=&r,&r")
-	(not:DI (match_operand:DI 1 "s_register_operand" "?r,0")))]
+	(not:DI (match_operand:DI 1 "s_register_operand" "0,r")))]
   "TARGET_32BIT"
   "#"
   "TARGET_32BIT && reload_completed"
@@ -3682,7 +3978,8 @@
 	(not:SI (match_operand:SI 1 "s_register_operand"  "r")))]
   "TARGET_32BIT"
   "mvn%?\\t%0, %1"
-  [(set_attr "predicable" "yes")]
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "mvn")]
 )
 
 (define_insn "*thumb1_one_cmplsi2"
@@ -3690,7 +3987,8 @@
 	(not:SI (match_operand:SI 1 "register_operand"  "l")))]
   "TARGET_THUMB1"
   "mvn\\t%0, %1"
-  [(set_attr "length" "2")]
+  [(set_attr "length" "2")
+   (set_attr "insn" "mvn")]
 )
 
 (define_insn "*notsi_compare0"
@@ -3701,7 +3999,8 @@
 	(not:SI (match_dup 1)))]
   "TARGET_32BIT"
   "mvn%.\\t%0, %1"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "mvn")]
 )
 
 (define_insn "*notsi_compare0_scratch"
@@ -3711,11 +4010,40 @@
    (clobber (match_scratch:SI 0 "=r"))]
   "TARGET_32BIT"
   "mvn%.\\t%0, %1"
-  [(set_attr "conds" "set")]
+  [(set_attr "conds" "set")
+   (set_attr "insn" "mvn")]
 )
 
 ;; Fixed <--> Floating conversion insns
 
+(define_expand "floatsihf2"
+  [(set (match_operand:HF           0 "general_operand" "")
+	(float:HF (match_operand:SI 1 "general_operand" "")))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1 = gen_reg_rtx (SFmode);
+    expand_float (op1, operands[1], 0);
+    op1 = convert_to_mode (HFmode, op1, 0);
+    emit_move_insn (operands[0], op1);
+    DONE;
+  }"
+)
+
+(define_expand "floatdihf2"
+  [(set (match_operand:HF           0 "general_operand" "")
+	(float:HF (match_operand:DI 1 "general_operand" "")))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1 = gen_reg_rtx (SFmode);
+    expand_float (op1, operands[1], 0);
+    op1 = convert_to_mode (HFmode, op1, 0);
+    emit_move_insn (operands[0], op1);
+    DONE;
+  }"
+)
+
 (define_expand "floatsisf2"
   [(set (match_operand:SF           0 "s_register_operand" "")
 	(float:SF (match_operand:SI 1 "s_register_operand" "")))]
@@ -3731,7 +4059,7 @@
 (define_expand "floatsidf2"
   [(set (match_operand:DF           0 "s_register_operand" "")
 	(float:DF (match_operand:SI 1 "s_register_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   if (TARGET_MAVERICK)
     {
@@ -3740,6 +4068,30 @@
     }
 ")
 
+(define_expand "fix_trunchfsi2"
+  [(set (match_operand:SI         0 "general_operand" "")
+	(fix:SI (fix:HF (match_operand:HF 1 "general_operand"  ""))))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1 = convert_to_mode (SFmode, operands[1], 0);
+    expand_fix (operands[0], op1, 0);
+    DONE;
+  }"
+)
+
+(define_expand "fix_trunchfdi2"
+  [(set (match_operand:DI         0 "general_operand" "")
+	(fix:DI (fix:HF (match_operand:HF 1 "general_operand"  ""))))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1 = convert_to_mode (SFmode, operands[1], 0);
+    expand_fix (operands[0], op1, 0);
+    DONE;
+  }"
+)
+
 (define_expand "fix_truncsfsi2"
   [(set (match_operand:SI         0 "s_register_operand" "")
 	(fix:SI (fix:SF (match_operand:SF 1 "s_register_operand"  ""))))]
@@ -3759,7 +4111,7 @@
 (define_expand "fix_truncdfsi2"
   [(set (match_operand:SI         0 "s_register_operand" "")
 	(fix:SI (fix:DF (match_operand:DF 1 "s_register_operand"  ""))))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   if (TARGET_MAVERICK)
     {
@@ -3776,9 +4128,25 @@
   [(set (match_operand:SF  0 "s_register_operand" "")
 	(float_truncate:SF
  	 (match_operand:DF 1 "s_register_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   ""
 )
+
+/* DFmode -> HFmode conversions have to go through SFmode.  */
+(define_expand "truncdfhf2"
+  [(set (match_operand:HF  0 "general_operand" "")
+	(float_truncate:HF
+ 	 (match_operand:DF 1 "general_operand" "")))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1;
+    op1 = convert_to_mode (SFmode, operands[1], 0);
+    op1 = convert_to_mode (HFmode, op1, 0);
+    emit_move_insn (operands[0], op1);
+    DONE;
+  }"
+)
 
 ;; Zero and sign extension instructions.
 
@@ -3800,6 +4168,7 @@
     return \"mov%?\\t%R0, #0\";
   "
   [(set_attr "length" "8")
+   (set_attr "insn" "mov")
    (set_attr "predicable" "yes")]
 )
 
@@ -3843,6 +4212,7 @@
   "
   [(set_attr "length" "8")
    (set_attr "shift" "1")
+   (set_attr "insn" "mov")
    (set_attr "predicable" "yes")]
 )
 
@@ -4123,6 +4493,28 @@
   ""
 )
 
+(define_code_iterator ior_xor [ior xor])
+
+(define_split
+  [(set (match_operand:SI 0 "s_register_operand" "")
+	(ior_xor:SI (and:SI (ashift:SI
+			     (match_operand:SI 1 "s_register_operand" "")
+			     (match_operand:SI 2 "const_int_operand" ""))
+			    (match_operand:SI 3 "const_int_operand" ""))
+		    (zero_extend:SI
+		     (match_operator 5 "subreg_lowpart_operator"
+		      [(match_operand:SI 4 "s_register_operand" "")]))))]
+  "TARGET_32BIT
+   && (INTVAL (operands[3])
+       == (GET_MODE_MASK (GET_MODE (operands[5]))
+           & (GET_MODE_MASK (GET_MODE (operands[5]))
+	      << (INTVAL (operands[2])))))"
+  [(set (match_dup 0) (ior_xor:SI (ashift:SI (match_dup 1) (match_dup 2))
+				  (match_dup 4)))
+   (set (match_dup 0) (zero_extend:SI (match_dup 5)))]
+  "operands[5] = gen_lowpart (GET_MODE (operands[5]), operands[0]);"
+)
+
 (define_insn "*compareqi_eq0"
   [(set (reg:CC_Z CC_REGNUM)
 	(compare:CC_Z (match_operand:QI 0 "s_register_operand" "r")
@@ -4639,9 +5031,24 @@
 (define_expand "extendsfdf2"
   [(set (match_operand:DF                  0 "s_register_operand" "")
 	(float_extend:DF (match_operand:SF 1 "s_register_operand"  "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   ""
 )
+
+/* HFmode -> DFmode conversions have to go through SFmode.  */
+(define_expand "extendhfdf2"
+  [(set (match_operand:DF                  0 "general_operand" "")
+	(float_extend:DF (match_operand:HF 1 "general_operand"  "")))]
+  "TARGET_EITHER"
+  "
+  {
+    rtx op1;
+    op1 = convert_to_mode (SFmode, operands[1], 0);
+    op1 = convert_to_mode (DFmode, op1, 0);
+    emit_insn (gen_movdf (operands[0], op1));
+    DONE;
+  }"
+)
 
 ;; Move insns (including loads and stores)
 
@@ -4877,6 +5284,7 @@
   }"
   [(set_attr "length" "4,4,6,2,2,6,4,4")
    (set_attr "type" "*,*,*,load2,store2,load2,store2,*")
+   (set_attr "insn" "*,mov,*,*,*,*,*,mov")
    (set_attr "pool_range" "*,*,*,*,*,1020,*,*")]
 )
 
@@ -4903,14 +5311,6 @@
 			       optimize && can_create_pseudo_p ());
           DONE;
         }
-
-      if (TARGET_USE_MOVT && !target_word_relocations
-	  && GET_CODE (operands[1]) == SYMBOL_REF
-	  && !flag_pic && !arm_tls_referenced_p (operands[1]))
-	{
-	  arm_emit_movpair (operands[0], operands[1]);
-	  DONE;
-	}
     }
   else /* TARGET_THUMB1...  */
     {
@@ -4984,18 +5384,9 @@
    (set_attr "length" "4")]
 )
 
-(define_insn "*arm_movw"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=r")
-	(high:SI (match_operand:SI 1 "general_operand"      "i")))]
-  "TARGET_32BIT"
-  "movw%?\t%0, #:lower16:%c1"
-  [(set_attr "predicable" "yes")
-   (set_attr "length" "4")]
-)
-
 (define_insn "*arm_movsi_insn"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,rk,m")
-	(match_operand:SI 1 "general_operand"      "rk, I,K,N,mi,rk"))]
+	(match_operand:SI 1 "general_operand"      "rk, I,K,j,mi,rk"))]
   "TARGET_ARM && ! TARGET_IWMMXT
    && !(TARGET_HARD_FLOAT && TARGET_VFP)
    && (   register_operand (operands[0], SImode)
@@ -5008,6 +5399,7 @@
    ldr%?\\t%0, %1
    str%?\\t%1, %0"
   [(set_attr "type" "*,*,*,*,load1,store1")
+   (set_attr "insn" "mov,mov,mvn,mov,*,*")
    (set_attr "predicable" "yes")
    (set_attr "pool_range" "*,*,*,*,4096,*")
    (set_attr "neg_pool_range" "*,*,*,*,4084,*")]
@@ -5027,9 +5419,33 @@
   "
 )
 
+(define_split
+  [(set (match_operand:SI 0 "arm_general_register_operand" "")
+	(match_operand:SI 1 "general_operand" ""))]
+  "TARGET_32BIT
+   && TARGET_USE_MOVT
+   && (GET_CODE (operands[1]) == SYMBOL_REF
+       || (GET_CODE (operands[1]) == CONST
+	   && GET_CODE (XEXP (operands[1], 0)) == PLUS
+	   && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF
+	   && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == CONST_INT
+	   /* The targets that use RELA relocations can have arbitrary
+	      offset.  The others targets, which use REL relocations,
+	      have limited offset encodings.  */
+	   && (TARGET_USE_RELA
+	       || (INTVAL (XEXP (XEXP (operands[1], 0), 1)) >= -0x8000
+		   && INTVAL (XEXP (XEXP (operands[1], 0), 1)) <= 0x7fff))))
+   && !flag_pic && !target_word_relocations
+   && !arm_tls_referenced_p (operands[1])"
+  [(clobber (const_int 0))]
+{
+  arm_emit_movpair (operands[0], operands[1]);
+  DONE;
+})
+
 (define_insn "*thumb1_movsi_insn"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=l,l,l,l,l,>,l, m,*lhk")
-	(match_operand:SI 1 "general_operand"      "l, I,J,K,>,l,mi,l,*lhk"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=l,l,l,l,l,>,l, m,*l*h*k")
+	(match_operand:SI 1 "general_operand"      "l, I,J,K,>,l,mi,l,*l*h*k"))]
   "TARGET_THUMB1
    && (   register_operand (operands[0], SImode) 
        || register_operand (operands[1], SImode))"
@@ -5065,7 +5481,7 @@
    (set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))]
   "
   {
-    unsigned HOST_WIDE_INT val = INTVAL (operands[1]);
+    unsigned HOST_WIDE_INT val = INTVAL (operands[1]) & 0xffffffffu;
     unsigned HOST_WIDE_INT mask = 0xff;
     int i;
     
@@ -5627,6 +6043,7 @@
    ldr%(h%)\\t%0, %1\\t%@ movhi"
   [(set_attr "type" "*,*,store1,load1")
    (set_attr "predicable" "yes")
+   (set_attr "insn" "mov,mvn,*,*")
    (set_attr "pool_range" "*,*,*,256")
    (set_attr "neg_pool_range" "*,*,*,244")]
 )
@@ -5638,7 +6055,8 @@
   "@
    mov%?\\t%0, %1\\t%@ movhi
    mvn%?\\t%0, #%B1\\t%@ movhi"
-  [(set_attr "predicable" "yes")]
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "mov,mvn")]
 )
 
 (define_expand "thumb_movhi_clobber"
@@ -5769,6 +6187,7 @@
    ldr%(b%)\\t%0, %1
    str%(b%)\\t%1, %0"
   [(set_attr "type" "*,*,load1,store1")
+   (set_attr "insn" "mov,mvn,*,*")
    (set_attr "predicable" "yes")]
 )
 
@@ -5787,9 +6206,111 @@
    mov\\t%0, %1"
   [(set_attr "length" "2")
    (set_attr "type" "*,load1,store1,*,*,*")
+   (set_attr "insn" "*,*,*,mov,mov,mov")
    (set_attr "pool_range" "*,32,*,*,*,*")]
 )
 
+;; HFmode moves
+(define_expand "movhf"
+  [(set (match_operand:HF 0 "general_operand" "")
+	(match_operand:HF 1 "general_operand" ""))]
+  "TARGET_EITHER"
+  "
+  if (TARGET_32BIT)
+    {
+      if (GET_CODE (operands[0]) == MEM)
+        operands[1] = force_reg (HFmode, operands[1]);
+    }
+  else /* TARGET_THUMB1 */
+    {
+      if (can_create_pseudo_p ())
+        {
+           if (GET_CODE (operands[0]) != REG)
+	     operands[1] = force_reg (HFmode, operands[1]);
+        }
+    }
+  "
+)
+
+(define_insn "*arm32_movhf"
+  [(set (match_operand:HF 0 "nonimmediate_operand" "=r,m,r,r")
+	(match_operand:HF 1 "general_operand"	   " m,r,r,F"))]
+  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_FP16)
+   && (	  s_register_operand (operands[0], HFmode)
+       || s_register_operand (operands[1], HFmode))"
+  "*
+  switch (which_alternative)
+    {
+    case 0:	/* ARM register from memory */
+      return \"ldr%(h%)\\t%0, %1\\t%@ __fp16\";
+    case 1:	/* memory from ARM register */
+      return \"str%(h%)\\t%1, %0\\t%@ __fp16\";
+    case 2:	/* ARM register from ARM register */
+      return \"mov%?\\t%0, %1\\t%@ __fp16\";
+    case 3:	/* ARM register from constant */
+      {
+	REAL_VALUE_TYPE r;
+	long bits;
+	rtx ops[4];
+
+	REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);
+	bits = real_to_target (NULL, &r, HFmode);
+	ops[0] = operands[0];
+	ops[1] = GEN_INT (bits);
+	ops[2] = GEN_INT (bits & 0xff00);
+	ops[3] = GEN_INT (bits & 0x00ff);
+
+	if (arm_arch_thumb2)
+	  output_asm_insn (\"movw%?\\t%0, %1\", ops);
+	else
+	  output_asm_insn (\"mov%?\\t%0, %2\;orr%?\\t%0, %0, %3\", ops);
+	return \"\";
+       }
+    default:
+      gcc_unreachable ();
+    }
+  "
+  [(set_attr "conds" "unconditional")
+   (set_attr "type" "load1,store1,*,*")
+   (set_attr "length" "4,4,4,8")
+   (set_attr "predicable" "yes")
+   ]
+)
+
+(define_insn "*thumb1_movhf"
+  [(set (match_operand:HF     0 "nonimmediate_operand" "=l,l,m,*r,*h")
+	(match_operand:HF     1 "general_operand"      "l,mF,l,*h,*r"))]
+  "TARGET_THUMB1
+   && (	  s_register_operand (operands[0], HFmode) 
+       || s_register_operand (operands[1], HFmode))"
+  "*
+  switch (which_alternative)
+    {
+    case 1:
+      {
+	rtx addr;
+	gcc_assert (GET_CODE(operands[1]) == MEM);
+	addr = XEXP (operands[1], 0);
+	if (GET_CODE (addr) == LABEL_REF
+	    || (GET_CODE (addr) == CONST
+		&& GET_CODE (XEXP (addr, 0)) == PLUS
+		&& GET_CODE (XEXP (XEXP (addr, 0), 0)) == LABEL_REF
+		&& GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT))
+	  {
+	    /* Constant pool entry.  */
+	    return \"ldr\\t%0, %1\";
+	  }
+	return \"ldrh\\t%0, %1\";
+      }
+    case 2: return \"strh\\t%1, %0\";
+    default: return \"mov\\t%0, %1\";
+    }
+  "
+  [(set_attr "length" "2")
+   (set_attr "type" "*,load1,store1,*,*")
+   (set_attr "pool_range" "*,1020,*,*,*")]
+)
+
 (define_expand "movsf"
   [(set (match_operand:SF 0 "general_operand" "")
 	(match_operand:SF 1 "general_operand" ""))]
@@ -5842,6 +6363,7 @@
   [(set_attr "length" "4,4,4")
    (set_attr "predicable" "yes")
    (set_attr "type" "*,load1,store1")
+   (set_attr "insn" "mov,*,*")
    (set_attr "pool_range" "*,4096,*")
    (set_attr "neg_pool_range" "*,4084,*")]
 )
@@ -6297,7 +6819,7 @@
    (match_operand:BLK 1 "general_operand" "")
    (match_operand:SI 2 "const_int_operand" "")
    (match_operand:SI 3 "const_int_operand" "")]
-  "TARGET_EITHER"
+  "TARGET_EITHER && !low_irq_latency"
   "
   if (TARGET_32BIT)
     {
@@ -7476,7 +7998,7 @@
 (define_expand "cmpdf"
   [(match_operand:DF 0 "s_register_operand" "")
    (match_operand:DF 1 "arm_float_compare_operand" "")]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
   "
   arm_compare_op0 = operands[0];
   arm_compare_op1 = operands[1];
@@ -7507,7 +8029,11 @@
    (set_attr "shift" "1")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*arm_cmpsi_shiftsi_swp"
@@ -7522,7 +8048,11 @@
    (set_attr "shift" "1")
    (set (attr "type") (if_then_else (match_operand 2 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*arm_cmpsi_negshiftsi_si"
@@ -7537,9 +8067,75 @@
   [(set_attr "conds" "set")
    (set (attr "type") (if_then_else (match_operand 3 "const_int_operand" "")
 				    (const_string "alu_shift")
-				    (const_string "alu_shift_reg")))]
+                                    (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
+)
+
+;; DImode comparisons.  The generic code generates branches that
+;; if-conversion can not reduce to a conditional compare, so we do
+;; that directly.
+
+(define_insn "*arm_cmpdi_insn"
+  [(set (reg:CC_NCV CC_REGNUM)
+	(compare:CC_NCV (match_operand:DI 0 "s_register_operand" "r")
+			(match_operand:DI 1 "arm_di_operand"	   "rDi")))
+   (clobber (match_scratch:SI 2 "=r"))]
+  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)"
+  "cmp\\t%Q0, %Q1\;sbcs\\t%2, %R0, %R1"
+  [(set_attr "conds" "set")
+   (set_attr "length" "8")]
+)
+
+(define_insn "*arm_cmpdi_unsigned"
+  [(set (reg:CC_CZ CC_REGNUM)
+	(compare:CC_CZ (match_operand:DI 0 "s_register_operand" "r")
+		       (match_operand:DI 1 "arm_di_operand"	"rDi")))]
+  "TARGET_ARM"
+  "cmp%?\\t%R0, %R1\;cmpeq\\t%Q0, %Q1"
+  [(set_attr "conds" "set")
+   (set_attr "length" "8")]
+)
+
+(define_insn "*arm_cmpdi_zero"
+  [(set (reg:CC_Z CC_REGNUM)
+	(compare:CC_Z (match_operand:DI 0 "s_register_operand" "r")
+		      (const_int 0)))
+   (clobber (match_scratch:SI 1 "=r"))]
+  "TARGET_32BIT"
+  "orr%.\\t%1, %Q0, %R0"
+  [(set_attr "conds" "set")
+   (set_attr "insn" "orr")]
 )
 
+(define_insn "*thumb_cmpdi_zero"
+  [(set (reg:CC_Z CC_REGNUM)
+	(compare:CC_Z (match_operand:DI 0 "s_register_operand" "l")
+		      (const_int 0)))
+   (clobber (match_scratch:SI 1 "=l"))]
+  "TARGET_THUMB1"
+  "orr\\t%1, %Q0, %R0"
+  [(set_attr "conds" "set")
+   (set_attr "insn" "orr")
+   (set_attr "length" "2")]
+)
+
+(define_expand "cmpdi"
+  [(match_operand:DI 0 "cmpdi_operand" "")
+   (match_operand:DI 1 "cmpdi_operand" "")]
+  "TARGET_32BIT"
+  "{
+     /* We should not have two constants.  */
+     gcc_assert (GET_MODE (operands[0]) == DImode
+		 || GET_MODE (operands[1]) == DImode);
+
+     arm_compare_op0 = operands[0];
+     arm_compare_op1 = operands[1];
+     DONE;
+   }")
+
 ;; Cirrus SF compare instruction
 (define_insn "*cirrus_cmpsf"
   [(set (reg:CCFP CC_REGNUM)
@@ -7562,17 +8158,6 @@
    (set_attr "cirrus" "compare")]
 )
 
-;; Cirrus DI compare instruction
-(define_expand "cmpdi"
-  [(match_operand:DI 0 "cirrus_fp_register" "")
-   (match_operand:DI 1 "cirrus_fp_register" "")]
-  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK"
-  "{
-     arm_compare_op0 = operands[0];
-     arm_compare_op1 = operands[1];
-     DONE;
-   }")
-
 (define_insn "*cirrus_cmpdi"
   [(set (reg:CC CC_REGNUM)
 	(compare:CC (match_operand:DI 0 "cirrus_fp_register" "v")
@@ -7624,8 +8209,18 @@
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   "TARGET_32BIT"
-  "operands[1] = arm_gen_compare_reg (GT, arm_compare_op0, arm_compare_op1);"
-)
+{
+  if (GET_MODE (arm_compare_op0) == DImode
+      || GET_MODE (arm_compare_op1) == DImode)
+    {
+      rtx tem = arm_compare_op0;
+      arm_compare_op0 = arm_compare_op1;
+      arm_compare_op1 = tem;
+      emit_insn (gen_blt (operands[0]));
+      DONE;
+    }
+  operands[1] = arm_gen_compare_reg (GT, arm_compare_op0, arm_compare_op1);
+})
 
 (define_expand "ble"
   [(set (pc)
@@ -7633,8 +8228,18 @@
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   "TARGET_32BIT"
-  "operands[1] = arm_gen_compare_reg (LE, arm_compare_op0, arm_compare_op1);"
-)
+{
+  if (GET_MODE (arm_compare_op0) == DImode
+      || GET_MODE (arm_compare_op1) == DImode)
+    {
+      rtx tem = arm_compare_op0;
+      arm_compare_op0 = arm_compare_op1;
+      arm_compare_op1 = tem;
+      emit_insn (gen_bge (operands[0]));
+      DONE;
+    }
+  operands[1] = arm_gen_compare_reg (LE, arm_compare_op0, arm_compare_op1);
+})
 
 (define_expand "bge"
   [(set (pc)
@@ -7660,8 +8265,18 @@
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   "TARGET_32BIT"
-  "operands[1] = arm_gen_compare_reg (GTU, arm_compare_op0, arm_compare_op1);"
-)
+{
+  if (!TARGET_ARM && (GET_MODE (arm_compare_op0) == DImode
+		      || GET_MODE (arm_compare_op1) == DImode))
+    {
+      rtx tem = arm_compare_op0;
+      arm_compare_op0 = arm_compare_op1;
+      arm_compare_op1 = tem;
+      emit_insn (gen_bltu (operands[0]));
+      DONE;
+    }
+  operands[1] = arm_gen_compare_reg (GTU, arm_compare_op0, arm_compare_op1);
+})
 
 (define_expand "bleu"
   [(set (pc)
@@ -7669,8 +8284,18 @@
 		      (label_ref (match_operand 0 "" ""))
 		      (pc)))]
   "TARGET_32BIT"
-  "operands[1] = arm_gen_compare_reg (LEU, arm_compare_op0, arm_compare_op1);"
-)
+{
+  if (!TARGET_ARM && (GET_MODE (arm_compare_op0) == DImode
+		      || GET_MODE (arm_compare_op1) == DImode))
+    {
+      rtx tem = arm_compare_op0;
+      arm_compare_op0 = arm_compare_op1;
+      arm_compare_op1 = tem;
+      emit_insn (gen_bgeu (operands[0]));
+      DONE;
+    }
+  operands[1] = arm_gen_compare_reg (LEU, arm_compare_op0, arm_compare_op1);
+})
 
 (define_expand "bgeu"
   [(set (pc)
@@ -7879,77 +8504,117 @@
 (define_expand "seq"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(eq:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (EQ, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sne"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(ne:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (NE, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sgt"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(gt:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
-  "operands[1] = arm_gen_compare_reg (GT, arm_compare_op0, arm_compare_op1);"
-)
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
+{
+  if (GET_MODE (arm_compare_op0) == DImode
+      || GET_MODE (arm_compare_op1) == DImode)
+    {
+      rtx tem = arm_compare_op0;
+      arm_compare_op0 = arm_compare_op1;
+      arm_compare_op1 = tem;
+      emit_insn (gen_slt (operands[0]));
+      DONE;
+    }
+  operands[1] = arm_gen_compare_reg (GT, arm_compare_op0, arm_compare_op1);
+})
 
 (define_expand "sle"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(le:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
-  "operands[1] = arm_gen_compare_reg (LE, arm_compare_op0, arm_compare_op1);"
-)
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
+{
+  if (GET_MODE (arm_compare_op0) == DImode
+      || GET_MODE (arm_compare_op1) == DImode)
+    {
+      rtx tem = arm_compare_op0;
+      arm_compare_op0 = arm_compare_op1;
+      arm_compare_op1 = tem;
+      emit_insn (gen_sge (operands[0]));
+      DONE;
+    }
+  operands[1] = arm_gen_compare_reg (LE, arm_compare_op0, arm_compare_op1);
+})
 
 (define_expand "sge"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(ge:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (GE, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "slt"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(lt:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (LT, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sgtu"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(gtu:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
-  "operands[1] = arm_gen_compare_reg (GTU, arm_compare_op0, arm_compare_op1);"
-)
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
+{
+  if (!TARGET_ARM && (GET_MODE (arm_compare_op0) == DImode
+		      || GET_MODE (arm_compare_op1) == DImode))
+    {
+      rtx tem = arm_compare_op0;
+      arm_compare_op0 = arm_compare_op1;
+      arm_compare_op1 = tem;
+      emit_insn (gen_sltu (operands[0]));
+      DONE;
+    }
+  operands[1] = arm_gen_compare_reg (GTU, arm_compare_op0, arm_compare_op1);
+})
 
 (define_expand "sleu"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(leu:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
-  "operands[1] = arm_gen_compare_reg (LEU, arm_compare_op0, arm_compare_op1);"
-)
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
+{
+  if (!TARGET_ARM && (GET_MODE (arm_compare_op0) == DImode
+		      || GET_MODE (arm_compare_op1) == DImode))
+    {
+      rtx tem = arm_compare_op0;
+      arm_compare_op0 = arm_compare_op1;
+      arm_compare_op1 = tem;
+      emit_insn (gen_sgeu (operands[0]));
+      DONE;
+    }
+  operands[1] = arm_gen_compare_reg (LEU, arm_compare_op0, arm_compare_op1);
+})
 
 (define_expand "sgeu"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(geu:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (GEU, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sltu"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(ltu:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (LTU, arm_compare_op0, arm_compare_op1);"
 )
 
 (define_expand "sunordered"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(unordered:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (UNORDERED, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -7957,7 +8622,7 @@
 (define_expand "sordered"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(ordered:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (ORDERED, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -7965,7 +8630,7 @@
 (define_expand "sungt"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(ungt:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (UNGT, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -7973,7 +8638,7 @@
 (define_expand "sunge"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(unge:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (UNGE, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -7981,7 +8646,7 @@
 (define_expand "sunlt"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(unlt:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (UNLT, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -7989,7 +8654,7 @@
 (define_expand "sunle"
   [(set (match_operand:SI 0 "s_register_operand" "")
 	(unle:SI (match_dup 1) (const_int 0)))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP) && !TARGET_NO_COND_EXEC"
   "operands[1] = arm_gen_compare_reg (UNLE, arm_compare_op0,
 				      arm_compare_op1);"
 )
@@ -8018,6 +8683,7 @@
   "TARGET_ARM"
   "mov%D1\\t%0, #0\;mov%d1\\t%0, #1"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -8028,6 +8694,7 @@
   "TARGET_ARM"
   "mov%D1\\t%0, #0\;mvn%d1\\t%0, #0"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -8038,6 +8705,7 @@
   "TARGET_ARM"
   "mov%D1\\t%0, #0\;mvn%d1\\t%0, #1"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -8241,7 +8909,7 @@
 	(if_then_else:SI (match_operand 1 "arm_comparison_operator" "")
 			 (match_operand:SI 2 "arm_not_operand" "")
 			 (match_operand:SI 3 "arm_not_operand" "")))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_COND_EXEC"
   "
   {
     enum rtx_code code = GET_CODE (operands[1]);
@@ -8250,6 +8918,16 @@
     if (code == UNEQ || code == LTGT)
       FAIL;
 
+    if ((code == GT || code == LE)
+	&& (GET_MODE (arm_compare_op0) == DImode
+	    || GET_MODE (arm_compare_op1) == DImode))
+      {
+	rtx tem = arm_compare_op0;
+	arm_compare_op0 = arm_compare_op1;
+	arm_compare_op1 = tem;
+	code = swap_condition (code);
+      }
+
     ccreg = arm_gen_compare_reg (code, arm_compare_op0, arm_compare_op1);
     operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);
   }"
@@ -8260,7 +8938,7 @@
 	(if_then_else:SF (match_operand 1 "arm_comparison_operator" "")
 			 (match_operand:SF 2 "s_register_operand" "")
 			 (match_operand:SF 3 "nonmemory_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_NO_COND_EXEC"
   "
   {
     enum rtx_code code = GET_CODE (operands[1]);
@@ -8269,6 +8947,16 @@
     if (code == UNEQ || code == LTGT)
       FAIL;
 
+    if ((code == GT || code == LE)
+	&& (GET_MODE (arm_compare_op0) == DImode
+	    || GET_MODE (arm_compare_op1) == DImode))
+      {
+	rtx tem = arm_compare_op0;
+	arm_compare_op0 = arm_compare_op1;
+	arm_compare_op1 = tem;
+	code = swap_condition (code);
+      }
+
     /* When compiling for SOFT_FLOAT, ensure both arms are in registers. 
        Otherwise, ensure it is a valid FP add operand */
     if ((!(TARGET_HARD_FLOAT && TARGET_FPA))
@@ -8285,7 +8973,7 @@
 	(if_then_else:DF (match_operand 1 "arm_comparison_operator" "")
 			 (match_operand:DF 2 "s_register_operand" "")
 			 (match_operand:DF 3 "arm_float_add_operand" "")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE) && !TARGET_NO_COND_EXEC"
   "
   {
     enum rtx_code code = GET_CODE (operands[1]);
@@ -8294,6 +8982,16 @@
     if (code == UNEQ || code == LTGT)
       FAIL;
 
+    if ((code == GT || code == LE)
+	&& (GET_MODE (arm_compare_op0) == DImode
+	    || GET_MODE (arm_compare_op1) == DImode))
+      {
+	rtx tem = arm_compare_op0;
+	arm_compare_op0 = arm_compare_op1;
+	arm_compare_op1 = tem;
+	code = swap_condition (code);
+      }
+
     ccreg = arm_gen_compare_reg (code, arm_compare_op0, arm_compare_op1);
     operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);
   }"
@@ -8317,7 +9015,8 @@
    mvn%d3\\t%0, #%B1\;mov%D3\\t%0, %2
    mvn%d3\\t%0, #%B1\;mvn%D3\\t%0, #%B2"
   [(set_attr "length" "4,4,4,4,8,8,8,8")
-   (set_attr "conds" "use")]
+   (set_attr "conds" "use")
+   (set_attr "insn" "mov,mvn,mov,mvn,mov,mov,mvn,mvn")]
 )
 
 (define_insn "*movsfcc_soft_insn"
@@ -8330,7 +9029,8 @@
   "@
    mov%D3\\t%0, %2
    mov%d3\\t%0, %1"
-  [(set_attr "conds" "use")]
+  [(set_attr "conds" "use")
+   (set_attr "insn" "mov")]
 )
 
 
@@ -8553,7 +9253,7 @@
    (set_attr "type" "call")]
 )
 
-;; Note: see *call_mem
+;; Note: see *call_mem.
 
 (define_insn "*call_value_mem"
   [(set (match_operand 0 "" "")
@@ -8610,7 +9310,7 @@
 	 (match_operand 1 "" ""))
    (use (match_operand 2 "" ""))
    (clobber (reg:SI LR_REGNUM))]
-  "TARGET_ARM
+  "TARGET_32BIT
    && (GET_CODE (operands[0]) == SYMBOL_REF)
    && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[0]))"
   "*
@@ -8626,7 +9326,7 @@
 	(match_operand:SI 2 "" "")))
    (use (match_operand 3 "" ""))
    (clobber (reg:SI LR_REGNUM))]
-  "TARGET_ARM
+  "TARGET_32BIT
    && (GET_CODE (operands[1]) == SYMBOL_REF)
    && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[1]))"
   "*
@@ -8641,7 +9341,7 @@
 	 (match_operand:SI 1 "" ""))
    (use (match_operand 2 "" ""))
    (clobber (reg:SI LR_REGNUM))]
-  "TARGET_THUMB
+  "TARGET_THUMB1
    && GET_CODE (operands[0]) == SYMBOL_REF
    && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[0]))"
   "bl\\t%a0"
@@ -8655,7 +9355,7 @@
 	      (match_operand 2 "" "")))
    (use (match_operand 3 "" ""))
    (clobber (reg:SI LR_REGNUM))]
-  "TARGET_THUMB
+  "TARGET_THUMB1
    && GET_CODE (operands[1]) == SYMBOL_REF
    && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[1]))"
   "bl\\t%a1"
@@ -8669,7 +9369,7 @@
 		    (match_operand 1 "general_operand" ""))
 	      (return)
 	      (use (match_operand 2 "" ""))])]
-  "TARGET_ARM"
+  "TARGET_32BIT"
   "
   {
     if (operands[2] == NULL_RTX)
@@ -8683,7 +9383,7 @@
 			 (match_operand 2 "general_operand" "")))
 	      (return)
 	      (use (match_operand 3 "" ""))])]
-  "TARGET_ARM"
+  "TARGET_32BIT"
   "
   {
     if (operands[3] == NULL_RTX)
@@ -8696,7 +9396,7 @@
 	(match_operand 1 "" ""))
   (return)
   (use (match_operand 2 "" ""))]
-  "TARGET_ARM && GET_CODE (operands[0]) == SYMBOL_REF"
+  "TARGET_32BIT && GET_CODE (operands[0]) == SYMBOL_REF"
   "*
   return NEED_PLT_RELOC ? \"b%?\\t%a0(PLT)\" : \"b%?\\t%a0\";
   "
@@ -8709,15 +9409,20 @@
 	     (match_operand 2 "" "")))
   (return)
   (use (match_operand 3 "" ""))]
-  "TARGET_ARM && GET_CODE (operands[1]) == SYMBOL_REF"
+  "TARGET_32BIT && GET_CODE (operands[1]) == SYMBOL_REF"
   "*
   return NEED_PLT_RELOC ? \"b%?\\t%a1(PLT)\" : \"b%?\\t%a1\";
   "
   [(set_attr "type" "call")]
 )
 
+(define_expand "return"
+  [(return)]
+  "TARGET_32BIT && USE_RETURN_INSN (FALSE)"
+  "")
+
 ;; Often the return insn will be the same as loading from memory, so set attr
-(define_insn "return"
+(define_insn "*arm_return"
   [(return)]
   "TARGET_ARM && USE_RETURN_INSN (FALSE)"
   "*
@@ -8734,13 +9439,26 @@
    (set_attr "predicable" "yes")]
 )
 
+;; Note: this is not predicable, to avoid issues with linker-generated
+;; interworking stubs.
+(define_insn "*thumb2_return"
+  [(return)]
+  "TARGET_THUMB2 && USE_RETURN_INSN (FALSE)"
+  "*
+  {
+    return output_return_instruction (const_true_rtx, TRUE, FALSE);
+  }"
+  [(set_attr "type" "load1")
+   (set_attr "length" "12")]
+)
+
 (define_insn "*cond_return"
   [(set (pc)
         (if_then_else (match_operator 0 "arm_comparison_operator"
 		       [(match_operand 1 "cc_register" "") (const_int 0)])
                       (return)
                       (pc)))]
-  "TARGET_ARM && USE_RETURN_INSN (TRUE)"
+  "TARGET_ARM && USE_RETURN_INSN (TRUE) && !TARGET_NO_COND_EXEC"
   "*
   {
     if (arm_ccfsm_state == 2)
@@ -8761,7 +9479,7 @@
 		       [(match_operand 1 "cc_register" "") (const_int 0)])
                       (pc)
 		      (return)))]
-  "TARGET_ARM && USE_RETURN_INSN (TRUE)"
+  "TARGET_ARM && USE_RETURN_INSN (TRUE) && !TARGET_NO_COND_EXEC"
   "*
   {
     if (arm_ccfsm_state == 2)
@@ -9072,14 +9790,18 @@
           [(match_operator:SI 3 "shift_operator"
              [(match_operand:SI 4 "s_register_operand" "r")
               (match_operand:SI 5 "reg_or_int_operand" "rI")])
-           (match_operand:SI 2 "s_register_operand" "r")]))]
+           (match_operand:SI 2 "s_register_operand" "rk")]))]
   "TARGET_ARM"
   "%i1%?\\t%0, %2, %4%S3"
   [(set_attr "predicable" "yes")
    (set_attr "shift" "4")
    (set (attr "type") (if_then_else (match_operand 5 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_split
@@ -9117,7 +9839,11 @@
    (set_attr "shift" "4")
    (set (attr "type") (if_then_else (match_operand 5 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*arith_shiftsi_compare0_scratch"
@@ -9135,7 +9861,11 @@
    (set_attr "shift" "4")
    (set (attr "type") (if_then_else (match_operand 5 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*sub_shiftsi"
@@ -9150,7 +9880,11 @@
    (set_attr "shift" "3")
    (set (attr "type") (if_then_else (match_operand 4 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*sub_shiftsi_compare0"
@@ -9170,7 +9904,11 @@
    (set_attr "shift" "3")
    (set (attr "type") (if_then_else (match_operand 4 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 (define_insn "*sub_shiftsi_compare0_scratch"
@@ -9188,7 +9926,11 @@
    (set_attr "shift" "3")
    (set (attr "type") (if_then_else (match_operand 4 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 8)
+                                        (const_int 4)))]
 )
 
 
@@ -9201,6 +9943,7 @@
   "TARGET_ARM"
   "mov%D1\\t%0, #0\;and%d1\\t%0, %2, #1"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mov")
    (set_attr "length" "8")]
 )
 
@@ -9214,6 +9957,7 @@
    orr%d2\\t%0, %1, #1
    mov%D2\\t%0, %1\;orr%d2\\t%0, %1, #1"
   [(set_attr "conds" "use")
+   (set_attr "insn" "orr")
    (set_attr "length" "4,8")]
 )
 
@@ -9223,7 +9967,7 @@
 	 [(match_operand:SI 2 "s_register_operand" "r,r")
 	  (match_operand:SI 3 "arm_add_operand" "rI,L")]))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_COND_EXEC"
   "*
     if (operands[3] == const0_rtx)
       {
@@ -9278,6 +10022,7 @@
     return \"\";
   "
   [(set_attr "conds" "use")
+   (set_attr "insn" "mov")
    (set_attr "length" "4,4,8")]
 )
 
@@ -9289,7 +10034,7 @@
 	    (match_operand:SI 3 "arm_rhs_operand" "rI,rI")])
           (match_operand:SI 1 "s_register_operand" "0,?r")]))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "*
     if (GET_CODE (operands[4]) == LT && operands[3] == const0_rtx)
       return \"%i5\\t%0, %1, %2, lsr #31\";
@@ -9685,7 +10430,7 @@
 	 (match_operand:SI 1 "arm_rhs_operand" "0,rI,?rI")
 	 (match_operand:SI 2 "arm_rhs_operand" "rI,0,rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_COND_EXEC"
   "*
   if (GET_CODE (operands[5]) == LT
       && (operands[4] == const0_rtx))
@@ -9751,7 +10496,7 @@
 			  (match_operand:SI 3 "arm_add_operand" "rIL,rIL"))
 			 (match_operand:SI 1 "arm_rhs_operand" "0,?rI")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -9787,7 +10532,7 @@
 			  (match_operand:SI 2 "s_register_operand" "r,r")
 			  (match_operand:SI 3 "arm_add_operand" "rIL,rIL"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -9825,7 +10570,7 @@
 			  [(match_operand:SI 3 "s_register_operand" "r")
 			   (match_operand:SI 4 "arm_rhs_operand" "rI")])))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "12")]
@@ -9975,7 +10720,7 @@
 	 (not:SI
 	  (match_operand:SI 2 "s_register_operand" "r,r"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -9994,6 +10739,7 @@
    mov%d4\\t%0, %1\;mvn%D4\\t%0, %2
    mvn%d4\\t%0, #%B1\;mvn%D4\\t%0, %2"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mvn")
    (set_attr "length" "4,8,8")]
 )
 
@@ -10007,7 +10753,7 @@
 	  (match_operand:SI 2 "s_register_operand" "r,r"))
 	 (match_operand:SI 1 "arm_not_operand" "0,?rIK")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -10026,6 +10772,7 @@
    mov%D4\\t%0, %1\;mvn%d4\\t%0, %2
    mvn%D4\\t%0, #%B1\;mvn%d4\\t%0, %2"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mvn")
    (set_attr "length" "4,8,8")]
 )
 
@@ -10040,7 +10787,7 @@
 	   (match_operand:SI 3 "arm_rhs_operand" "rM,rM")])
 	 (match_operand:SI 1 "arm_not_operand" "0,?rIK")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -10062,10 +10809,23 @@
    mvn%D5\\t%0, #%B1\;mov%d5\\t%0, %2%S4"
   [(set_attr "conds" "use")
    (set_attr "shift" "2")
-   (set_attr "length" "4,8,8")
+   (set_attr "insn" "mov")
    (set (attr "type") (if_then_else (match_operand 3 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set_attr_alternative "length"
+           [(if_then_else (and (eq_attr "type" "alu_shift_reg")
+                               (eq_attr "fix_janus" "yes"))
+                          (const_int 8)
+                          (const_int 4))
+            (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                               (eq_attr "fix_janus" "yes"))
+                          (const_int 12)
+                          (const_int 8))
+            (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                               (eq_attr "fix_janus" "yes"))
+                          (const_int 12)
+                          (const_int 8))])]
 )
 
 (define_insn "*ifcompare_move_shift"
@@ -10079,7 +10839,7 @@
 	  [(match_operand:SI 2 "s_register_operand" "r,r")
 	   (match_operand:SI 3 "arm_rhs_operand" "rM,rM")])))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -10101,10 +10861,24 @@
    mvn%d5\\t%0, #%B1\;mov%D5\\t%0, %2%S4"
   [(set_attr "conds" "use")
    (set_attr "shift" "2")
-   (set_attr "length" "4,8,8")
+   (set_attr "insn" "mov")
    (set (attr "type") (if_then_else (match_operand 3 "const_int_operand" "")
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set_attr_alternative "length"
+        [(if_then_else (and (eq_attr "type" "alu_shift_reg")
+                            (eq_attr "fix_janus" "yes"))
+                       (const_int 8)
+                       (const_int 4))
+         (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                            (eq_attr "fix_janus" "yes"))
+                       (const_int 12)
+                       (const_int 8))
+         (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                            (eq_attr "fix_janus" "yes"))
+                       (const_int 12)
+                       (const_int 8))])
+     (set_attr "insn" "mov")]
 )
 
 (define_insn "*ifcompare_shift_shift"
@@ -10120,7 +10894,7 @@
 	  [(match_operand:SI 3 "s_register_operand" "r")
 	   (match_operand:SI 4 "arm_rhs_operand" "rM")])))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "12")]
@@ -10141,12 +10915,16 @@
   "mov%d5\\t%0, %1%S6\;mov%D5\\t%0, %3%S7"
   [(set_attr "conds" "use")
    (set_attr "shift" "1")
-   (set_attr "length" "8")
+   (set_attr "insn" "mov")
    (set (attr "type") (if_then_else
 		        (and (match_operand 2 "const_int_operand" "")
                              (match_operand 4 "const_int_operand" ""))
 		      (const_string "alu_shift")
-		      (const_string "alu_shift_reg")))]
+                      (const_string "alu_shift_reg")))
+     (set (attr "length") (if_then_else (and (eq_attr "type" "alu_shift_reg")
+                                             (eq_attr "fix_janus" "yes"))
+                                        (const_int 16)
+                                        (const_int 8)))]
 )
 
 (define_insn "*ifcompare_not_arith"
@@ -10160,7 +10938,7 @@
 	  [(match_operand:SI 2 "s_register_operand" "r")
 	   (match_operand:SI 3 "arm_rhs_operand" "rI")])))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "12")]
@@ -10178,6 +10956,7 @@
   "TARGET_ARM"
   "mvn%d5\\t%0, %1\;%I6%D5\\t%0, %2, %3"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mvn")
    (set_attr "length" "8")]
 )
 
@@ -10192,7 +10971,7 @@
 	   (match_operand:SI 3 "arm_rhs_operand" "rI")])
 	 (not:SI (match_operand:SI 1 "s_register_operand" "r"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "12")]
@@ -10210,6 +10989,7 @@
   "TARGET_ARM"
   "mvn%D5\\t%0, %1\;%I6%d5\\t%0, %2, %3"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mvn")
    (set_attr "length" "8")]
 )
 
@@ -10222,7 +11002,7 @@
 	 (neg:SI (match_operand:SI 2 "s_register_operand" "r,r"))
 	 (match_operand:SI 1 "arm_not_operand" "0,?rIK")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -10253,7 +11033,7 @@
 	 (match_operand:SI 1 "arm_not_operand" "0,?rIK")
 	 (neg:SI (match_operand:SI 2 "s_register_operand" "r,r"))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM"
+  "TARGET_ARM && !TARGET_NO_SINGLE_COND_EXEC"
   "#"
   [(set_attr "conds" "clob")
    (set_attr "length" "8,12")]
@@ -10621,7 +11401,7 @@
 			 (match_dup 0)
 			 (match_operand 4 "" "")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM && reload_completed"
+  "TARGET_ARM && reload_completed && !TARGET_NO_SINGLE_COND_EXEC"
   [(set (match_dup 5) (match_dup 6))
    (cond_exec (match_dup 7)
 	      (set (match_dup 0) (match_dup 4)))]
@@ -10649,7 +11429,7 @@
 			 (match_operand 4 "" "")
 			 (match_dup 0)))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM && reload_completed"
+  "TARGET_ARM && reload_completed && !TARGET_NO_SINGLE_COND_EXEC"
   [(set (match_dup 5) (match_dup 6))
    (cond_exec (match_op_dup 1 [(match_dup 5) (const_int 0)])
 	      (set (match_dup 0) (match_dup 4)))]
@@ -10670,7 +11450,7 @@
 			 (match_operand 4 "" "")
 			 (match_operand 5 "" "")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM && reload_completed"
+  "TARGET_ARM && reload_completed && !TARGET_NO_SINGLE_COND_EXEC"
   [(set (match_dup 6) (match_dup 7))
    (cond_exec (match_op_dup 1 [(match_dup 6) (const_int 0)])
 	      (set (match_dup 0) (match_dup 4)))
@@ -10702,7 +11482,7 @@
 			 (not:SI
 			  (match_operand:SI 5 "s_register_operand" ""))))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_ARM && reload_completed"
+  "TARGET_ARM && reload_completed && !TARGET_NO_SINGLE_COND_EXEC"
   [(set (match_dup 6) (match_dup 7))
    (cond_exec (match_op_dup 1 [(match_dup 6) (const_int 0)])
 	      (set (match_dup 0) (match_dup 4)))
@@ -10737,6 +11517,7 @@
    mvn%D4\\t%0, %2
    mov%d4\\t%0, %1\;mvn%D4\\t%0, %2"
   [(set_attr "conds" "use")
+   (set_attr "insn" "mvn")
    (set_attr "length" "4,8")]
 )
 
@@ -10871,6 +11652,24 @@
   "
 )
 
+(define_insn "align_16"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_ALIGN16)]
+  "TARGET_EITHER"
+  "*
+  assemble_align (128);
+  return \"\";
+  "
+)
+
+(define_insn "align_32"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_ALIGN32)]
+  "TARGET_EITHER"
+  "*
+  assemble_align (256);
+  return \"\";
+  "
+)
+
 (define_insn "consttable_end"
   [(unspec_volatile [(const_int 0)] VUNSPEC_POOL_END)]
   "TARGET_EITHER"
@@ -10897,6 +11696,7 @@
   "TARGET_THUMB1"
   "*
   making_const_table = TRUE;
+  gcc_assert (GET_MODE_CLASS (GET_MODE (operands[0])) != MODE_FLOAT);
   assemble_integer (operands[0], 2, BITS_PER_WORD, 1);
   assemble_zeros (2);
   return \"\";
@@ -10909,19 +11709,30 @@
   "TARGET_EITHER"
   "*
   {
+    rtx x = operands[0];
     making_const_table = TRUE;
-    switch (GET_MODE_CLASS (GET_MODE (operands[0])))
+    switch (GET_MODE_CLASS (GET_MODE (x)))
       {
       case MODE_FLOAT:
-      {
-        REAL_VALUE_TYPE r;
-        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);
-        assemble_real (r, GET_MODE (operands[0]), BITS_PER_WORD);
-        break;
-      }
+        if (GET_MODE (x) == HFmode)
+	  arm_emit_fp16_const (x);
+	else
+ 	  {
+	    REAL_VALUE_TYPE r;
+	    REAL_VALUE_FROM_CONST_DOUBLE (r, x);
+	    assemble_real (r, GET_MODE (x), BITS_PER_WORD);
+	  }
+	break;
       default:
-        assemble_integer (operands[0], 4, BITS_PER_WORD, 1);
-	mark_symbol_refs_as_used (operands[0]);
+	/* XXX: Sometimes gcc does something really dumb and ends up with
+	   a HIGH in a constant pool entry, usually because it's trying to
+	   load into a VFP register.  We know this will always be used in
+	   combination with a LO_SUM which ignores the high bits, so just
+	   strip off the HIGH.  */
+	if (GET_CODE (x) == HIGH)
+	  x = XEXP (x, 0);
+        assemble_integer (x, 4, BITS_PER_WORD, 1);
+	mark_symbol_refs_as_used (x);
         break;
       }
     return \"\";
@@ -11015,6 +11826,28 @@
   [(set_attr "predicable" "yes")
    (set_attr "insn" "clz")])
 
+(define_insn "rbitsi2"
+  [(set (match_operand:SI 0 "s_register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "s_register_operand" "r")] UNSPEC_RBIT))]
+  "TARGET_32BIT && arm_arch_thumb2"
+  "rbit%?\\t%0, %1"
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "clz")])
+
+(define_expand "ctzsi2"
+ [(set (match_operand:SI           0 "s_register_operand" "")
+       (ctz:SI (match_operand:SI  1 "s_register_operand" "")))]
+  "TARGET_32BIT && arm_arch_thumb2"
+  "
+   {
+     rtx tmp = gen_reg_rtx (SImode); 
+     emit_insn (gen_rbitsi2 (tmp, operands[1]));
+     emit_insn (gen_clzsi2 (operands[0], tmp));
+   }
+   DONE;
+  "
+)
+
 ;; V5E instructions.
 
 (define_insn "prefetch"
@@ -11024,13 +11857,15 @@
   "TARGET_32BIT && arm_arch5e"
   "pld\\t%a0")
 
-;; General predication pattern
+;; General predication pattern.
+;; Conditional branches are available as both arm_cond_branch and
+;; predicated arm_jump, so it doesn't matter if we disable the latter.
 
 (define_cond_exec
   [(match_operator 0 "arm_comparison_operator"
     [(match_operand 1 "cc_register" "")
      (const_int 0)])]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NO_SINGLE_COND_EXEC"
   ""
 )
 
diff --git a/gcc/config/arm/arm.opt b/gcc/config/arm/arm.opt
index 6aca3950d..946dc9ced 100644
--- a/gcc/config/arm/arm.opt
+++ b/gcc/config/arm/arm.opt
@@ -78,6 +78,10 @@ Specify if floating point hardware should be used
 mfp=
 Target RejectNegative Joined Undocumented Var(target_fpe_name)
 
+mfp16-format=
+Target RejectNegative Joined Var(target_fp16_format_name)
+Specify the __fp16 floating-point format
+
 ;; Now ignored.
 mfpe
 Target RejectNegative Mask(FPE) Undocumented
@@ -93,6 +97,10 @@ mhard-float
 Target RejectNegative
 Alias for -mfloat-abi=hard
 
+mfix-janus-2cc
+Target Report Mask(FIX_JANUS)
+Work around hardware errata for Avalent Janus 2CC cores.
+
 mlittle-endian
 Target Report RejectNegative InverseMask(BIG_END)
 Assume target CPU is configured as little endian
@@ -101,6 +109,10 @@ mlong-calls
 Target Report Mask(LONG_CALLS)
 Generate call insns as indirect calls, if necessary
 
+mmarvell-div
+Target Report Mask(MARVELL_DIV)
+Generate hardware integer division instructions supported by some Marvell cores.
+
 mpic-register=
 Target RejectNegative Joined Var(arm_pic_register_string)
 Specify the register to be used for PIC addressing
@@ -157,6 +169,10 @@ mvectorize-with-neon-quad
 Target Report Mask(NEON_VECTORIZE_QUAD)
 Use Neon quad-word (rather than double-word) registers for vectorization
 
+mlow-irq-latency
+Target Report Var(low_irq_latency)
+Try to reduce interrupt latency of the generated code
+
 mword-relocations
 Target Report Var(target_word_relocations) Init(TARGET_DEFAULT_WORD_RELOCATIONS)
 Only generate absolute relocations on word sized values.
diff --git a/gcc/config/arm/arm_neon.h b/gcc/config/arm/arm_neon.h
index faaaf7bca..11463eefd 100644
--- a/gcc/config/arm/arm_neon.h
+++ b/gcc/config/arm/arm_neon.h
@@ -36,7 +36,11 @@
 extern "C" {
 #endif
 
+#if defined (__vxworks) && defined (_WRS_KERNEL)
+#include <vxWorks.h>
+#else
 #include <stdint.h>
+#endif
 
 typedef __builtin_neon_qi int8x8_t	__attribute__ ((__vector_size__ (8)));
 typedef __builtin_neon_hi int16x4_t	__attribute__ ((__vector_size__ (8)));
@@ -61,7 +65,7 @@ typedef __builtin_neon_uhi uint16x8_t	__attribute__ ((__vector_size__ (16)));
 typedef __builtin_neon_usi uint32x4_t	__attribute__ ((__vector_size__ (16)));
 typedef __builtin_neon_udi uint64x2_t	__attribute__ ((__vector_size__ (16)));
 
-typedef __builtin_neon_sf float32_t;
+typedef float float32_t;
 typedef __builtin_neon_poly8 poly8_t;
 typedef __builtin_neon_poly16 poly16_t;
 
@@ -5085,7 +5089,7 @@ vset_lane_s32 (int32_t __a, int32x2_t __b, const int __c)
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vset_lane_f32 (float32_t __a, float32x2_t __b, const int __c)
 {
-  return (float32x2_t)__builtin_neon_vset_lanev2sf (__a, __b, __c);
+  return (float32x2_t)__builtin_neon_vset_lanev2sf ((__builtin_neon_sf) __a, __b, __c);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -5151,7 +5155,7 @@ vsetq_lane_s32 (int32_t __a, int32x4_t __b, const int __c)
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vsetq_lane_f32 (float32_t __a, float32x4_t __b, const int __c)
 {
-  return (float32x4_t)__builtin_neon_vset_lanev4sf (__a, __b, __c);
+  return (float32x4_t)__builtin_neon_vset_lanev4sf ((__builtin_neon_sf) __a, __b, __c);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -5283,7 +5287,7 @@ vdup_n_s32 (int32_t __a)
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vdup_n_f32 (float32_t __a)
 {
-  return (float32x2_t)__builtin_neon_vdup_nv2sf (__a);
+  return (float32x2_t)__builtin_neon_vdup_nv2sf ((__builtin_neon_sf) __a);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -5349,7 +5353,7 @@ vdupq_n_s32 (int32_t __a)
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vdupq_n_f32 (float32_t __a)
 {
-  return (float32x4_t)__builtin_neon_vdup_nv4sf (__a);
+  return (float32x4_t)__builtin_neon_vdup_nv4sf ((__builtin_neon_sf) __a);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -5415,7 +5419,7 @@ vmov_n_s32 (int32_t __a)
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vmov_n_f32 (float32_t __a)
 {
-  return (float32x2_t)__builtin_neon_vdup_nv2sf (__a);
+  return (float32x2_t)__builtin_neon_vdup_nv2sf ((__builtin_neon_sf) __a);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -5481,7 +5485,7 @@ vmovq_n_s32 (int32_t __a)
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vmovq_n_f32 (float32_t __a)
 {
-  return (float32x4_t)__builtin_neon_vdup_nv4sf (__a);
+  return (float32x4_t)__builtin_neon_vdup_nv4sf ((__builtin_neon_sf) __a);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -6591,7 +6595,7 @@ vmul_n_s32 (int32x2_t __a, int32_t __b)
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vmul_n_f32 (float32x2_t __a, float32_t __b)
 {
-  return (float32x2_t)__builtin_neon_vmul_nv2sf (__a, __b, 3);
+  return (float32x2_t)__builtin_neon_vmul_nv2sf (__a, (__builtin_neon_sf) __b, 3);
 }
 
 __extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
@@ -6621,7 +6625,7 @@ vmulq_n_s32 (int32x4_t __a, int32_t __b)
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vmulq_n_f32 (float32x4_t __a, float32_t __b)
 {
-  return (float32x4_t)__builtin_neon_vmul_nv4sf (__a, __b, 3);
+  return (float32x4_t)__builtin_neon_vmul_nv4sf (__a, (__builtin_neon_sf) __b, 3);
 }
 
 __extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
@@ -6735,7 +6739,7 @@ vmla_n_s32 (int32x2_t __a, int32x2_t __b, int32_t __c)
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vmla_n_f32 (float32x2_t __a, float32x2_t __b, float32_t __c)
 {
-  return (float32x2_t)__builtin_neon_vmla_nv2sf (__a, __b, __c, 3);
+  return (float32x2_t)__builtin_neon_vmla_nv2sf (__a, __b, (__builtin_neon_sf) __c, 3);
 }
 
 __extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
@@ -6765,7 +6769,7 @@ vmlaq_n_s32 (int32x4_t __a, int32x4_t __b, int32_t __c)
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vmlaq_n_f32 (float32x4_t __a, float32x4_t __b, float32_t __c)
 {
-  return (float32x4_t)__builtin_neon_vmla_nv4sf (__a, __b, __c, 3);
+  return (float32x4_t)__builtin_neon_vmla_nv4sf (__a, __b, (__builtin_neon_sf) __c, 3);
 }
 
 __extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
@@ -6831,7 +6835,7 @@ vmls_n_s32 (int32x2_t __a, int32x2_t __b, int32_t __c)
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vmls_n_f32 (float32x2_t __a, float32x2_t __b, float32_t __c)
 {
-  return (float32x2_t)__builtin_neon_vmls_nv2sf (__a, __b, __c, 3);
+  return (float32x2_t)__builtin_neon_vmls_nv2sf (__a, __b, (__builtin_neon_sf) __c, 3);
 }
 
 __extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
@@ -6861,7 +6865,7 @@ vmlsq_n_s32 (int32x4_t __a, int32x4_t __b, int32_t __c)
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vmlsq_n_f32 (float32x4_t __a, float32x4_t __b, float32_t __c)
 {
-  return (float32x4_t)__builtin_neon_vmls_nv4sf (__a, __b, __c, 3);
+  return (float32x4_t)__builtin_neon_vmls_nv4sf (__a, __b, (__builtin_neon_sf) __c, 3);
 }
 
 __extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
@@ -7851,7 +7855,7 @@ vld1_s64 (const int64_t * __a)
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_f32 (const float32_t * __a)
 {
-  return (float32x2_t)__builtin_neon_vld1v2sf (__a);
+  return (float32x2_t)__builtin_neon_vld1v2sf ((const __builtin_neon_sf *) __a);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -7917,7 +7921,7 @@ vld1q_s64 (const int64_t * __a)
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_f32 (const float32_t * __a)
 {
-  return (float32x4_t)__builtin_neon_vld1v4sf (__a);
+  return (float32x4_t)__builtin_neon_vld1v4sf ((const __builtin_neon_sf *) __a);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -7977,7 +7981,7 @@ vld1_lane_s32 (const int32_t * __a, int32x2_t __b, const int __c)
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_lane_f32 (const float32_t * __a, float32x2_t __b, const int __c)
 {
-  return (float32x2_t)__builtin_neon_vld1_lanev2sf (__a, __b, __c);
+  return (float32x2_t)__builtin_neon_vld1_lanev2sf ((const __builtin_neon_sf *) __a, __b, __c);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -8043,7 +8047,7 @@ vld1q_lane_s32 (const int32_t * __a, int32x4_t __b, const int __c)
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_lane_f32 (const float32_t * __a, float32x4_t __b, const int __c)
 {
-  return (float32x4_t)__builtin_neon_vld1_lanev4sf (__a, __b, __c);
+  return (float32x4_t)__builtin_neon_vld1_lanev4sf ((const __builtin_neon_sf *) __a, __b, __c);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -8109,7 +8113,7 @@ vld1_dup_s32 (const int32_t * __a)
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vld1_dup_f32 (const float32_t * __a)
 {
-  return (float32x2_t)__builtin_neon_vld1_dupv2sf (__a);
+  return (float32x2_t)__builtin_neon_vld1_dupv2sf ((const __builtin_neon_sf *) __a);
 }
 
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
@@ -8175,7 +8179,7 @@ vld1q_dup_s32 (const int32_t * __a)
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_dup_f32 (const float32_t * __a)
 {
-  return (float32x4_t)__builtin_neon_vld1_dupv4sf (__a);
+  return (float32x4_t)__builtin_neon_vld1_dupv4sf ((const __builtin_neon_sf *) __a);
 }
 
 __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
@@ -8247,7 +8251,7 @@ vst1_s64 (int64_t * __a, int64x1_t __b)
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1_f32 (float32_t * __a, float32x2_t __b)
 {
-  __builtin_neon_vst1v2sf (__a, __b);
+  __builtin_neon_vst1v2sf ((__builtin_neon_sf *) __a, __b);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -8313,7 +8317,7 @@ vst1q_s64 (int64_t * __a, int64x2_t __b)
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1q_f32 (float32_t * __a, float32x4_t __b)
 {
-  __builtin_neon_vst1v4sf (__a, __b);
+  __builtin_neon_vst1v4sf ((__builtin_neon_sf *) __a, __b);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -8373,7 +8377,7 @@ vst1_lane_s32 (int32_t * __a, int32x2_t __b, const int __c)
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1_lane_f32 (float32_t * __a, float32x2_t __b, const int __c)
 {
-  __builtin_neon_vst1_lanev2sf (__a, __b, __c);
+  __builtin_neon_vst1_lanev2sf ((__builtin_neon_sf *) __a, __b, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -8439,7 +8443,7 @@ vst1q_lane_s32 (int32_t * __a, int32x4_t __b, const int __c)
 __extension__ static __inline void __attribute__ ((__always_inline__))
 vst1q_lane_f32 (float32_t * __a, float32x4_t __b, const int __c)
 {
-  __builtin_neon_vst1_lanev4sf (__a, __b, __c);
+  __builtin_neon_vst1_lanev4sf ((__builtin_neon_sf *) __a, __b, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -8512,7 +8516,7 @@ __extension__ static __inline float32x2x2_t __attribute__ ((__always_inline__))
 vld2_f32 (const float32_t * __a)
 {
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __rv;
-  __rv.__o = __builtin_neon_vld2v2sf (__a);
+  __rv.__o = __builtin_neon_vld2v2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -8600,7 +8604,7 @@ __extension__ static __inline float32x4x2_t __attribute__ ((__always_inline__))
 vld2q_f32 (const float32_t * __a)
 {
   union { float32x4x2_t __i; __builtin_neon_oi __o; } __rv;
-  __rv.__o = __builtin_neon_vld2v4sf (__a);
+  __rv.__o = __builtin_neon_vld2v4sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -8676,7 +8680,7 @@ vld2_lane_f32 (const float32_t * __a, float32x2x2_t __b, const int __c)
 {
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __bu = { __b };
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __rv;
-  __rv.__o = __builtin_neon_vld2_lanev2sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld2_lanev2sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -8748,7 +8752,7 @@ vld2q_lane_f32 (const float32_t * __a, float32x4x2_t __b, const int __c)
 {
   union { float32x4x2_t __i; __builtin_neon_oi __o; } __bu = { __b };
   union { float32x4x2_t __i; __builtin_neon_oi __o; } __rv;
-  __rv.__o = __builtin_neon_vld2_lanev4sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld2_lanev4sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -8807,7 +8811,7 @@ __extension__ static __inline float32x2x2_t __attribute__ ((__always_inline__))
 vld2_dup_f32 (const float32_t * __a)
 {
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __rv;
-  __rv.__o = __builtin_neon_vld2_dupv2sf (__a);
+  __rv.__o = __builtin_neon_vld2_dupv2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -8892,7 +8896,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst2_f32 (float32_t * __a, float32x2x2_t __b)
 {
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __bu = { __b };
-  __builtin_neon_vst2v2sf (__a, __bu.__o);
+  __builtin_neon_vst2v2sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -8969,7 +8973,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst2q_f32 (float32_t * __a, float32x4x2_t __b)
 {
   union { float32x4x2_t __i; __builtin_neon_oi __o; } __bu = { __b };
-  __builtin_neon_vst2v4sf (__a, __bu.__o);
+  __builtin_neon_vst2v4sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9032,7 +9036,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst2_lane_f32 (float32_t * __a, float32x2x2_t __b, const int __c)
 {
   union { float32x2x2_t __i; __builtin_neon_ti __o; } __bu = { __b };
-  __builtin_neon_vst2_lanev2sf (__a, __bu.__o, __c);
+  __builtin_neon_vst2_lanev2sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9088,7 +9092,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst2q_lane_f32 (float32_t * __a, float32x4x2_t __b, const int __c)
 {
   union { float32x4x2_t __i; __builtin_neon_oi __o; } __bu = { __b };
-  __builtin_neon_vst2_lanev4sf (__a, __bu.__o, __c);
+  __builtin_neon_vst2_lanev4sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9140,7 +9144,7 @@ __extension__ static __inline float32x2x3_t __attribute__ ((__always_inline__))
 vld3_f32 (const float32_t * __a)
 {
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __rv;
-  __rv.__o = __builtin_neon_vld3v2sf (__a);
+  __rv.__o = __builtin_neon_vld3v2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -9228,7 +9232,7 @@ __extension__ static __inline float32x4x3_t __attribute__ ((__always_inline__))
 vld3q_f32 (const float32_t * __a)
 {
   union { float32x4x3_t __i; __builtin_neon_ci __o; } __rv;
-  __rv.__o = __builtin_neon_vld3v4sf (__a);
+  __rv.__o = __builtin_neon_vld3v4sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -9304,7 +9308,7 @@ vld3_lane_f32 (const float32_t * __a, float32x2x3_t __b, const int __c)
 {
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __bu = { __b };
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __rv;
-  __rv.__o = __builtin_neon_vld3_lanev2sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld3_lanev2sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -9376,7 +9380,7 @@ vld3q_lane_f32 (const float32_t * __a, float32x4x3_t __b, const int __c)
 {
   union { float32x4x3_t __i; __builtin_neon_ci __o; } __bu = { __b };
   union { float32x4x3_t __i; __builtin_neon_ci __o; } __rv;
-  __rv.__o = __builtin_neon_vld3_lanev4sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld3_lanev4sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -9435,7 +9439,7 @@ __extension__ static __inline float32x2x3_t __attribute__ ((__always_inline__))
 vld3_dup_f32 (const float32_t * __a)
 {
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __rv;
-  __rv.__o = __builtin_neon_vld3_dupv2sf (__a);
+  __rv.__o = __builtin_neon_vld3_dupv2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -9520,7 +9524,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst3_f32 (float32_t * __a, float32x2x3_t __b)
 {
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __bu = { __b };
-  __builtin_neon_vst3v2sf (__a, __bu.__o);
+  __builtin_neon_vst3v2sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9597,7 +9601,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst3q_f32 (float32_t * __a, float32x4x3_t __b)
 {
   union { float32x4x3_t __i; __builtin_neon_ci __o; } __bu = { __b };
-  __builtin_neon_vst3v4sf (__a, __bu.__o);
+  __builtin_neon_vst3v4sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9660,7 +9664,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst3_lane_f32 (float32_t * __a, float32x2x3_t __b, const int __c)
 {
   union { float32x2x3_t __i; __builtin_neon_ei __o; } __bu = { __b };
-  __builtin_neon_vst3_lanev2sf (__a, __bu.__o, __c);
+  __builtin_neon_vst3_lanev2sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9716,7 +9720,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst3q_lane_f32 (float32_t * __a, float32x4x3_t __b, const int __c)
 {
   union { float32x4x3_t __i; __builtin_neon_ci __o; } __bu = { __b };
-  __builtin_neon_vst3_lanev4sf (__a, __bu.__o, __c);
+  __builtin_neon_vst3_lanev4sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -9768,7 +9772,7 @@ __extension__ static __inline float32x2x4_t __attribute__ ((__always_inline__))
 vld4_f32 (const float32_t * __a)
 {
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __rv;
-  __rv.__o = __builtin_neon_vld4v2sf (__a);
+  __rv.__o = __builtin_neon_vld4v2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -9856,7 +9860,7 @@ __extension__ static __inline float32x4x4_t __attribute__ ((__always_inline__))
 vld4q_f32 (const float32_t * __a)
 {
   union { float32x4x4_t __i; __builtin_neon_xi __o; } __rv;
-  __rv.__o = __builtin_neon_vld4v4sf (__a);
+  __rv.__o = __builtin_neon_vld4v4sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -9932,7 +9936,7 @@ vld4_lane_f32 (const float32_t * __a, float32x2x4_t __b, const int __c)
 {
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __bu = { __b };
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __rv;
-  __rv.__o = __builtin_neon_vld4_lanev2sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld4_lanev2sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -10004,7 +10008,7 @@ vld4q_lane_f32 (const float32_t * __a, float32x4x4_t __b, const int __c)
 {
   union { float32x4x4_t __i; __builtin_neon_xi __o; } __bu = { __b };
   union { float32x4x4_t __i; __builtin_neon_xi __o; } __rv;
-  __rv.__o = __builtin_neon_vld4_lanev4sf (__a, __bu.__o, __c);
+  __rv.__o = __builtin_neon_vld4_lanev4sf ((const __builtin_neon_sf *) __a, __bu.__o, __c);
   return __rv.__i;
 }
 
@@ -10063,7 +10067,7 @@ __extension__ static __inline float32x2x4_t __attribute__ ((__always_inline__))
 vld4_dup_f32 (const float32_t * __a)
 {
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __rv;
-  __rv.__o = __builtin_neon_vld4_dupv2sf (__a);
+  __rv.__o = __builtin_neon_vld4_dupv2sf ((const __builtin_neon_sf *) __a);
   return __rv.__i;
 }
 
@@ -10148,7 +10152,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst4_f32 (float32_t * __a, float32x2x4_t __b)
 {
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __bu = { __b };
-  __builtin_neon_vst4v2sf (__a, __bu.__o);
+  __builtin_neon_vst4v2sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -10225,7 +10229,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst4q_f32 (float32_t * __a, float32x4x4_t __b)
 {
   union { float32x4x4_t __i; __builtin_neon_xi __o; } __bu = { __b };
-  __builtin_neon_vst4v4sf (__a, __bu.__o);
+  __builtin_neon_vst4v4sf ((__builtin_neon_sf *) __a, __bu.__o);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -10288,7 +10292,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst4_lane_f32 (float32_t * __a, float32x2x4_t __b, const int __c)
 {
   union { float32x2x4_t __i; __builtin_neon_oi __o; } __bu = { __b };
-  __builtin_neon_vst4_lanev2sf (__a, __bu.__o, __c);
+  __builtin_neon_vst4_lanev2sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
@@ -10344,7 +10348,7 @@ __extension__ static __inline void __attribute__ ((__always_inline__))
 vst4q_lane_f32 (float32_t * __a, float32x4x4_t __b, const int __c)
 {
   union { float32x4x4_t __i; __builtin_neon_xi __o; } __bu = { __b };
-  __builtin_neon_vst4_lanev4sf (__a, __bu.__o, __c);
+  __builtin_neon_vst4_lanev4sf ((__builtin_neon_sf *) __a, __bu.__o, __c);
 }
 
 __extension__ static __inline void __attribute__ ((__always_inline__))
diff --git a/gcc/config/arm/bpabi-v6m.S b/gcc/config/arm/bpabi-v6m.S
index 77018e154..75d50d967 100644
--- a/gcc/config/arm/bpabi-v6m.S
+++ b/gcc/config/arm/bpabi-v6m.S
@@ -69,9 +69,52 @@ FUNC_START aeabi_ulcmp
 
 #endif /* L_aeabi_ulcmp */
 
+.macro test_div_by_zero signed
+	cmp	yyh, #0
+	bne	7f
+	cmp	yyl, #0
+	bne	7f
+	cmp	xxh, #0
+	bne	2f
+	cmp	xxl, #0
+2:
+	.ifc	\signed, unsigned
+	beq	3f
+	mov	xxh, #0
+	mvn	xxh, xxh		@ 0xffffffff
+	mov	xxl, xxh
+3:
+	.else
+	beq	5f
+	blt	6f
+	mov	xxl, #0
+	mvn	xxl, xxl		@ 0xffffffff
+	lsr	xxh, xxl, #1		@ 0x7fffffff
+	b	5f
+6:	mov	xxh, #0x80
+	lsl	xxh, xxh, #24		@ 0x80000000
+	mov	xxl, #0
+5:
+	.endif
+	@ tailcalls are tricky on v6-m.
+	push	{r0, r1, r2}
+	ldr	r0, 1f
+	adr	r1, 1f
+	add	r0, r1
+	str	r0, [sp, #8]
+	@ We know we are not on armv4t, so pop pc is safe.
+	pop	{r0, r1, pc}
+	.align	2
+1:
+	.word	__aeabi_ldiv0 - 1b
+7:
+.endm
+
 #ifdef L_aeabi_ldivmod
 
 FUNC_START aeabi_ldivmod
+	test_div_by_zero signed
+
 	push {r0, r1}
 	mov r0, sp
 	push {r0, lr}
@@ -89,6 +132,8 @@ FUNC_START aeabi_ldivmod
 #ifdef L_aeabi_uldivmod
 
 FUNC_START aeabi_uldivmod
+	test_div_by_zero unsigned
+
 	push {r0, r1}
 	mov r0, sp
 	push {r0, lr}
diff --git a/gcc/config/arm/bpabi.S b/gcc/config/arm/bpabi.S
index 850381e4a..9d25f3b24 100644
--- a/gcc/config/arm/bpabi.S
+++ b/gcc/config/arm/bpabi.S
@@ -64,20 +64,69 @@ ARM_FUNC_START aeabi_ulcmp
 
 #endif /* L_aeabi_ulcmp */
 
+.macro test_div_by_zero signed
+/* Tail-call to divide-by-zero handlers which may be overridden by the user,
+   so unwinding works properly.  */
+#if defined(__thumb2__)
+	cbnz	yyh, 1f
+	cbnz	yyl, 1f
+	cmp	xxh, #0
+	do_it	eq
+	cmpeq	xxl, #0
+	.ifc \signed, unsigned
+	beq	2f
+	mov	xxh, #0xffffffff
+	mov	xxl, xxh
+2:
+	.else
+	do_it	lt, t
+	movlt	xxl, #0
+	movlt	xxh, #0x80000000
+	do_it	gt, t
+	movgt	xxh, #0x7fffffff
+	movgt	xxl, #0xffffffff
+	.endif
+	b	SYM (__aeabi_ldiv0) __PLT__
+1:
+#else
+	/* Note: Thumb-1 code calls via an ARM shim on processors which
+	   support ARM mode.  */
+	cmp	yyh, #0
+	cmpeq	yyl, #0
+	bne	2f
+	cmp	xxh, #0
+	cmpeq	xxl, #0
+	.ifc \signed, unsigned
+	movne	xxh, #0xffffffff
+	movne	xxl, #0xffffffff
+	.else
+	movlt	xxh, #0x80000000
+	movlt	xxl, #0
+	movgt	xxh, #0x7fffffff
+	movgt	xxl, #0xffffffff
+	.endif
+	b	SYM (__aeabi_ldiv0) __PLT__
+2:
+#endif
+.endm
+
 #ifdef L_aeabi_ldivmod
 
 ARM_FUNC_START aeabi_ldivmod
+	test_div_by_zero signed
+
 	sub sp, sp, #8
-#if defined(__thumb2__)
+/* Low latency and Thumb-2 do_push implementations can't push sp directly.  */
+#if defined(__thumb2__) || defined(__irq_low_latency__)
 	mov ip, sp
-	push {ip, lr}
+	do_push (ip, lr)
 #else
-	do_push {sp, lr}
+	stmfd sp!, {sp, lr}
 #endif
 	bl SYM(__gnu_ldivmod_helper) __PLT__
 	ldr lr, [sp, #4]
 	add sp, sp, #8
-	do_pop {r2, r3}
+	do_pop (r2, r3)
 	RET
 	
 #endif /* L_aeabi_ldivmod */
@@ -85,17 +134,20 @@ ARM_FUNC_START aeabi_ldivmod
 #ifdef L_aeabi_uldivmod
 
 ARM_FUNC_START aeabi_uldivmod
+	test_div_by_zero unsigned
+
 	sub sp, sp, #8
-#if defined(__thumb2__)
+/* Low latency and Thumb-2 do_push implementations can't push sp directly.  */
+#if defined(__thumb2__) || defined(__irq_low_latency__)
 	mov ip, sp
-	push {ip, lr}
+	do_push (ip, lr)
 #else
-	do_push {sp, lr}
+	stmfd sp!, {sp, lr}
 #endif
 	bl SYM(__gnu_uldivmod_helper) __PLT__
 	ldr lr, [sp, #4]
 	add sp, sp, #8
-	do_pop {r2, r3}
+	do_pop (r2, r3)
 	RET
 	
 #endif /* L_aeabi_divmod */
diff --git a/gcc/config/arm/bpabi.h b/gcc/config/arm/bpabi.h
index 4d2974e32..8411b4b6e 100644
--- a/gcc/config/arm/bpabi.h
+++ b/gcc/config/arm/bpabi.h
@@ -26,11 +26,12 @@
 #define TARGET_BPABI (TARGET_AAPCS_BASED)
 
 /* BPABI targets use EABI frame unwinding tables.  */
+#define DWARF2_UNWIND_INFO 0
 #define TARGET_UNWIND_INFO 1
 
 /* Section 4.1 of the AAPCS requires the use of VFP format.  */
 #undef  FPUTYPE_DEFAULT
-#define FPUTYPE_DEFAULT FPUTYPE_VFP
+#define FPUTYPE_DEFAULT "vfp"
 
 /* TARGET_BIG_ENDIAN_DEFAULT is set in
    config.gcc for big endian configurations.  */
@@ -53,6 +54,8 @@
 
 #define TARGET_FIX_V4BX_SPEC " %{mcpu=arm8|mcpu=arm810|mcpu=strongarm*|march=armv4:--fix-v4bx}"
 
+#define BE8_LINK_SPEC " %{mbig-endian:%{march=armv7-a|mcpu=cortex-a5|mcpu=cortex-a8|mcpu=cortex-a9:%{!r:--be8}}}"
+
 /* Tell the assembler to build BPABI binaries.  */
 #undef  SUBTARGET_EXTRA_ASM_SPEC
 #define SUBTARGET_EXTRA_ASM_SPEC "%{mabi=apcs-gnu|mabi=atpcs:-meabi=gnu;:-meabi=5}" TARGET_FIX_V4BX_SPEC
@@ -65,7 +68,7 @@
 #define BPABI_LINK_SPEC \
   "%{mbig-endian:-EB} %{mlittle-endian:-EL} "		\
   "%{static:-Bstatic} %{shared:-shared} %{symbolic:-Bsymbolic} "	\
-  "-X" SUBTARGET_EXTRA_LINK_SPEC TARGET_FIX_V4BX_SPEC
+  "-X" SUBTARGET_EXTRA_LINK_SPEC TARGET_FIX_V4BX_SPEC BE8_LINK_SPEC
 
 #undef  LINK_SPEC
 #define LINK_SPEC BPABI_LINK_SPEC
@@ -90,16 +93,22 @@
 #define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (muldi3, lmul)
 #endif
 #ifdef L_fixdfdi
-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixdfdi, d2lz)
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixdfdi, d2lz) \
+  extern DWtype __fixdfdi (DFtype) __attribute__((pcs("aapcs"))); \
+  extern UDWtype __fixunsdfdi (DFtype) __asm__("__aeabi_d2ulz") __attribute__((pcs("aapcs")));
 #endif
 #ifdef L_fixunsdfdi
-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunsdfdi, d2ulz)
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunsdfdi, d2ulz) \
+  extern UDWtype __fixunsdfdi (DFtype) __attribute__((pcs("aapcs")));
 #endif
 #ifdef L_fixsfdi
-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixsfdi, f2lz)
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixsfdi, f2lz) \
+  extern DWtype __fixsfdi (SFtype) __attribute__((pcs("aapcs"))); \
+  extern UDWtype __fixunssfdi (SFtype) __asm__("__aeabi_f2ulz") __attribute__((pcs("aapcs")));
 #endif
 #ifdef L_fixunssfdi
-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunssfdi, f2ulz)
+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunssfdi, f2ulz) \
+  extern UDWtype __fixunssfdi (SFtype) __attribute__((pcs("aapcs")));
 #endif
 #ifdef L_floatdidf
 #define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatdidf, l2d)
diff --git a/gcc/config/arm/constraints.md b/gcc/config/arm/constraints.md
index d6c9dc49c..6ccc1bf53 100644
--- a/gcc/config/arm/constraints.md
+++ b/gcc/config/arm/constraints.md
@@ -25,15 +25,17 @@
 ;; In ARM state, 'l' is an alias for 'r'
 
 ;; The following normal constraints have been used:
-;; in ARM/Thumb-2 state: G, H, I, J, K, L, M
+;; in ARM/Thumb-2 state: G, H, I, j, J, K, L, M
 ;; in Thumb-1 state: I, J, K, L, M, N, O
 
 ;; The following multi-letter normal constraints have been used:
-;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv
+;; in ARM/Thumb-2 state: D0, Da, Db, Dc, Di, Dn, Dl, DL, Dv, Dy
+;; in Thumb-1 state: Pa, Pb
+;; in Thumb-2 state: Ps, Pt, Pu
 ;; in Thumb-2 state: Ps, Pt
 
 ;; The following memory constraints have been used:
-;; in ARM/Thumb-2 state: Q, Ut, Uv, Uy, Un, Us
+;; in ARM/Thumb-2 state: Q, Ut, Uv, Uy, Un, Um, Us
 ;; in ARM state: Uq
 
 
@@ -66,6 +68,13 @@
 (define_register_constraint "h" "TARGET_THUMB ? HI_REGS : NO_REGS"
  "In Thumb state the core registers @code{r8}-@code{r15}.")
 
+(define_constraint "j"
+ "A constant suitable for a MOVW instruction. (ARM/Thumb-2)"
+ (and (match_test "TARGET_32BIT && arm_arch_thumb2")
+      (ior (match_code "high")
+	   (and (match_code "const_int")
+                (match_test "(ival & 0xffff0000) == 0")))))
+
 (define_register_constraint "k" "STACK_REG"
  "@internal The stack register.")
 
@@ -117,11 +126,9 @@
 		   : ((ival >= 0 && ival <= 1020) && ((ival & 3) == 0))")))
 
 (define_constraint "N"
- "In ARM/Thumb-2 state a constant suitable for a MOVW instruction.
-  In Thumb-1 state a constant in the range 0-31."
+ "Thumb-1 state a constant in the range 0-31."
  (and (match_code "const_int")
-      (match_test "TARGET_32BIT ? arm_arch_thumb2 && ((ival & 0xffff0000) == 0)
-				: (ival >= 0 && ival <= 31)")))
+      (match_test "!TARGET_32BIT && (ival >= 0 && ival <= 31)")))
 
 (define_constraint "O"
  "In Thumb-1 state a constant that is a multiple of 4 in the range
@@ -130,6 +137,18 @@
       (match_test "TARGET_THUMB1 && ival >= -508 && ival <= 508
 		   && ((ival & 3) == 0)")))
 
+(define_constraint "Pa"
+  "@internal In Thumb-1 state a constant in the range -510 to +510"
+  (and (match_code "const_int")
+       (match_test "TARGET_THUMB1 && ival >= -510 && ival <= 510
+		    && (ival > 255 || ival < -255)")))
+
+(define_constraint "Pb"
+  "@internal In Thumb-1 state a constant in the range -262 to +262"
+  (and (match_code "const_int")
+       (match_test "TARGET_THUMB1 && ival >= -262 && ival <= 262
+		    && (ival > 255 || ival < -255)")))
+
 (define_constraint "Ps"
   "@internal In Thumb-2 state a constant in the range -255 to +255"
   (and (match_code "const_int")
@@ -140,6 +159,11 @@
   (and (match_code "const_int")
        (match_test "TARGET_THUMB2 && ival >= -7 && ival <= 7")))
 
+(define_constraint "Pu"
+  "@internal In Thumb-2 state a constant in the range -255 to 0"
+  (and (match_code "const_int")
+       (match_test "TARGET_THUMB2 && ival >= -255 && ival <= 0")))
+
 (define_constraint "G"
  "In ARM/Thumb-2 state a valid FPA immediate constant."
  (and (match_code "const_double")
@@ -150,6 +174,13 @@
  (and (match_code "const_double")
       (match_test "TARGET_32BIT && neg_const_double_rtx_ok_for_fpa (op)")))
 
+(define_constraint "D0"
+ "@internal
+  In ARM/Thumb-2 state a 0.0 floating point constant which can
+  be loaded with a Neon vmov immediate instruction."
+ (and (match_code "const_double")
+      (match_test "TARGET_NEON && op == CONST0_RTX (mode)")))
+
 (define_constraint "Da"
  "@internal
   In ARM/Thumb-2 state a const_int, const_double or const_vector that can
@@ -173,6 +204,13 @@
       (match_test "TARGET_32BIT && arm_const_double_inline_cost (op) == 4
 		   && !(optimize_size || arm_ld_sched)")))
 
+(define_constraint "Di"
+ "@internal
+  In ARM/Thumb-2 state a const_int or const_double where both the high
+  and low SImode words can be generated as immediates in 32-bit instructions."
+ (and (match_code "const_double,const_int")
+      (match_test "TARGET_32BIT && arm_const_double_by_immediates (op)")))
+
 (define_constraint "Dn"
  "@internal
   In ARM/Thumb-2 state a const_vector which can be loaded with a Neon vmov
@@ -200,10 +238,17 @@
 (define_constraint "Dv"
  "@internal
   In ARM/Thumb-2 state a const_double which can be used with a VFP fconsts
-  or fconstd instruction."
+  instruction."
  (and (match_code "const_double")
       (match_test "TARGET_32BIT && vfp3_const_double_rtx (op)")))
 
+(define_constraint "Dy"
+ "@internal
+  In ARM/Thumb-2 state a const_double which can be used with a VFP fconstd
+  instruction."
+ (and (match_code "const_double")
+      (match_test "TARGET_32BIT && TARGET_VFP_DOUBLE && vfp3_const_double_rtx (op)")))
+
 (define_memory_constraint "Ut"
  "@internal
   In ARM/Thumb-2 state an address valid for loading/storing opaque structure
@@ -224,18 +269,25 @@
       (match_test "TARGET_32BIT && arm_coproc_mem_operand (op, TRUE)")))
 
 (define_memory_constraint "Un"
+ "@internal
+  In ARM/Thumb-2 state a valid address for Neon doubleword vector
+  load/store instructions."
+ (and (match_code "mem")
+      (match_test "TARGET_32BIT && neon_vector_mem_operand (op, 0)")))
+
+(define_memory_constraint "Um"
  "@internal
   In ARM/Thumb-2 state a valid address for Neon element and structure
   load/store instructions."
  (and (match_code "mem")
-      (match_test "TARGET_32BIT && neon_vector_mem_operand (op, FALSE)")))
+      (match_test "TARGET_32BIT && neon_vector_mem_operand (op, 2)")))
 
 (define_memory_constraint "Us"
  "@internal
   In ARM/Thumb-2 state a valid address for non-offset loads/stores of
   quad-word values in four ARM registers."
  (and (match_code "mem")
-      (match_test "TARGET_32BIT && neon_vector_mem_operand (op, TRUE)")))
+      (match_test "TARGET_32BIT && neon_vector_mem_operand (op, 1)")))
 
 (define_memory_constraint "Uq"
  "@internal
diff --git a/gcc/config/arm/cortex-a5.md b/gcc/config/arm/cortex-a5.md
new file mode 100644
index 000000000..b17033a3c
--- /dev/null
+++ b/gcc/config/arm/cortex-a5.md
@@ -0,0 +1,310 @@
+;; ARM Cortex-A5 pipeline description
+;; Copyright (C) 2010 Free Software Foundation, Inc.
+;; Contributed by CodeSourcery.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful, but
+;; WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;; General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_automaton "cortex_a5")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Functional units.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; The integer (ALU) pipeline.  There are five DPU pipeline stages. However the
+;; decode/issue stages operate the same for all instructions, so do not model
+;; them.  We only need to model the first execute stage because instructions
+;; always advance one stage per cycle in order. Only branch instructions may
+;; dual-issue, so a single unit  covers all of the LS, ALU, MAC and FPU
+;; pipelines.
+
+(define_cpu_unit "cortex_a5_ex1" "cortex_a5")
+
+;; The branch pipeline.  Branches can dual-issue with other instructions
+;; (except when those instructions take multiple cycles to issue).
+
+(define_cpu_unit "cortex_a5_branch" "cortex_a5")
+
+;; Pseudo-unit for blocking the multiply pipeline when a double-precision
+;; multiply is in progress.
+
+(define_cpu_unit "cortex_a5_fpmul_pipe" "cortex_a5")
+
+;; The floating-point add pipeline (ex1/f1 stage), used to model the usage
+;; of the add pipeline by fmac instructions, etc.
+
+(define_cpu_unit "cortex_a5_fpadd_pipe" "cortex_a5")
+
+;; Floating-point div/sqrt (long latency, out-of-order completion).
+
+(define_cpu_unit "cortex_a5_fp_div_sqrt" "cortex_a5")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; ALU instructions.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(define_insn_reservation "cortex_a5_alu" 2
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "alu"))
+  "cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_alu_shift" 2
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "alu_shift,alu_shift_reg"))
+  "cortex_a5_ex1")
+
+;; Forwarding path for unshifted operands.
+
+(define_bypass 1 "cortex_a5_alu,cortex_a5_alu_shift"
+  "cortex_a5_alu")
+
+(define_bypass 1 "cortex_a5_alu,cortex_a5_alu_shift"
+  "cortex_a5_alu_shift"
+  "arm_no_early_alu_shift_dep")
+
+;; The multiplier pipeline can forward results from wr stage only (so I don't
+;; think there's any need to specify bypasses).
+
+(define_insn_reservation "cortex_a5_mul" 2
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "mult"))
+  "cortex_a5_ex1")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Load/store instructions.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; Address-generation happens in the issue stage, which is one stage behind
+;; the ex1 stage (the first stage we care about for scheduling purposes). The
+;; dc1 stage is parallel with ex1, dc2 with ex2 and rot with wr.
+
+;; FIXME: These might not be entirely accurate for load2, load3, load4. I think
+;; they make sense since there's a 32-bit interface between the DPU and the DCU,
+;; so we can't load more than that per cycle.  The store2, store3, store4
+;; reservations are similarly guessed.
+
+(define_insn_reservation "cortex_a5_load1" 2
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "load_byte,load1"))
+  "cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_store1" 0
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "store1"))
+  "cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_load2" 3
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "load2"))
+  "cortex_a5_ex1+cortex_a5_branch, cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_store2" 0
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "store2"))
+  "cortex_a5_ex1+cortex_a5_branch, cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_load3" 4
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "load3"))
+  "cortex_a5_ex1+cortex_a5_branch, cortex_a5_ex1+cortex_a5_branch,\
+   cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_store3" 0
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "store3"))
+  "cortex_a5_ex1+cortex_a5_branch, cortex_a5_ex1+cortex_a5_branch,\
+   cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_load4" 5
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "load3"))
+  "cortex_a5_ex1+cortex_a5_branch, cortex_a5_ex1+cortex_a5_branch,\
+   cortex_a5_ex1+cortex_a5_branch, cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_store4" 0
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "store3"))
+  "cortex_a5_ex1+cortex_a5_branch, cortex_a5_ex1+cortex_a5_branch,\
+   cortex_a5_ex1+cortex_a5_branch, cortex_a5_ex1")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Branches.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; Direct branches are the only instructions we can dual-issue (also IT and
+;; nop, but those aren't very interesting for scheduling).  (The latency here
+;; is meant to represent when the branch actually takes place, but may not be
+;; entirely correct.)
+
+(define_insn_reservation "cortex_a5_branch" 3
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "branch,call"))
+  "cortex_a5_branch")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Floating-point arithmetic.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(define_insn_reservation "cortex_a5_fpalu" 4
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "ffariths, fadds, ffarithd, faddd, fcpys, fmuls, f_cvt,\
+			fcmps, fcmpd"))
+  "cortex_a5_ex1+cortex_a5_fpadd_pipe")
+
+;; For fconsts and fconstd, 8-bit immediate data is passed directly from
+;; f1 to f3 (which I think reduces the latency by one cycle).
+
+(define_insn_reservation "cortex_a5_fconst" 3
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "fconsts,fconstd"))
+  "cortex_a5_ex1+cortex_a5_fpadd_pipe")
+
+;; We should try not to attempt to issue a single-precision multiplication in
+;; the middle of a double-precision multiplication operation (the usage of
+;; cortex_a5_fpmul_pipe).
+
+(define_insn_reservation "cortex_a5_fpmuls" 4
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "fmuls"))
+  "cortex_a5_ex1+cortex_a5_fpmul_pipe")
+
+;; For single-precision multiply-accumulate, the add (accumulate) is issued
+;; whilst the multiply is in F4.  The multiply result can then be forwarded
+;; from F5 to F1.  The issue unit is only used once (when we first start
+;; processing the instruction), but the usage of the FP add pipeline could
+;; block other instructions attempting to use it simultaneously.  We try to
+;; avoid that using cortex_a5_fpadd_pipe.
+
+(define_insn_reservation "cortex_a5_fpmacs" 8
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "fmacs"))
+  "cortex_a5_ex1+cortex_a5_fpmul_pipe, nothing*3, cortex_a5_fpadd_pipe")
+
+;; Non-multiply instructions can issue in the middle two instructions of a
+;; double-precision multiply.  Note that it isn't entirely clear when a branch
+;; can dual-issue when a multi-cycle multiplication is in progress; we ignore
+;; that for now though.
+
+(define_insn_reservation "cortex_a5_fpmuld" 7
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "fmuld"))
+  "cortex_a5_ex1+cortex_a5_fpmul_pipe, cortex_a5_fpmul_pipe*2,\
+   cortex_a5_ex1+cortex_a5_fpmul_pipe")
+
+(define_insn_reservation "cortex_a5_fpmacd" 11
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "fmacd"))
+  "cortex_a5_ex1+cortex_a5_fpmul_pipe, cortex_a5_fpmul_pipe*2,\
+   cortex_a5_ex1+cortex_a5_fpmul_pipe, nothing*3, cortex_a5_fpadd_pipe")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Floating-point divide/square root instructions.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; ??? Not sure if the 14 cycles taken for single-precision divide to complete
+;; includes the time taken for the special instruction used to collect the
+;; result to travel down the multiply pipeline, or not.  Assuming so.  (If
+;; that's wrong, the latency should be increased by a few cycles.)
+
+;; fsqrt takes one cycle less, but that is not modelled, nor is the use of the
+;; multiply pipeline to collect the divide/square-root result.
+
+(define_insn_reservation "cortex_a5_fdivs" 14
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "fdivs"))
+  "cortex_a5_ex1, cortex_a5_fp_div_sqrt * 13")
+
+;; ??? Similarly for fdivd.
+
+(define_insn_reservation "cortex_a5_fdivd" 29
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "fdivd"))
+  "cortex_a5_ex1, cortex_a5_fp_div_sqrt * 28")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; VFP to/from core transfers.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; FP loads take data from wr/rot/f3.  Might need to define bypasses to model
+;; this?
+
+;; Core-to-VFP transfers use the multiply pipeline.
+;; Not sure about this at all... I think we need some bypasses too.
+
+(define_insn_reservation "cortex_a5_r2f" 4
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "r_2_f"))
+  "cortex_a5_ex1")
+
+;; Not sure about this either. 6.8.7 says "Additionally, the store pipe used
+;; for store and FP->core register transfers can forward into the F2 and F3
+;; stages."
+;; This doesn't correspond to what we have though.
+
+(define_insn_reservation "cortex_a5_f2r" 2
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "f_2_r"))
+  "cortex_a5_ex1")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; VFP flag transfer.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; ??? The flag forwarding described in section 6.8.11 of the Cortex-A5 DPU
+;; specification (from fmstat to the ex2 stage of the second instruction) is
+;; not modeled at present.
+
+(define_insn_reservation "cortex_a5_f_flags" 4
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "f_flag"))
+  "cortex_a5_ex1")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; VFP load/store.
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(define_insn_reservation "cortex_a5_f_loads" 4
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "f_loads"))
+  "cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_f_loadd" 5
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "f_load,f_loadd"))
+  "cortex_a5_ex1+cortex_a5_branch, cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_f_stores" 0
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "f_stores"))
+  "cortex_a5_ex1")
+
+(define_insn_reservation "cortex_a5_f_stored" 0
+  (and (eq_attr "tune" "cortexa5")
+       (eq_attr "type" "f_store,f_stored"))
+  "cortex_a5_ex1+cortex_a5_branch, cortex_a5_ex1")
+
+;; Load-to-use for floating-point values has a penalty of one cycle, i.e. a
+;; latency of two (6.8.3).
+
+(define_bypass 2 "cortex_a5_f_loads"
+                 "cortex_a5_fpalu, cortex_a5_fpmacs, cortex_a5_fpmuld,\
+		  cortex_a5_fpmacd, cortex_a5_fdivs, cortex_a5_fdivd,\
+		  cortex_a5_f2r")
+
+(define_bypass 3 "cortex_a5_f_loadd"
+                 "cortex_a5_fpalu, cortex_a5_fpmacs, cortex_a5_fpmuld,\
+		  cortex_a5_fpmacd, cortex_a5_fdivs, cortex_a5_fdivd,\
+		  cortex_a5_f2r")
diff --git a/gcc/config/arm/cortex-a9.md b/gcc/config/arm/cortex-a9.md
index 121fd2da7..1fe72ce30 100644
--- a/gcc/config/arm/cortex-a9.md
+++ b/gcc/config/arm/cortex-a9.md
@@ -1,6 +1,8 @@
-;; ARM Cortex-A9 VFP pipeline description
-;; Copyright (C) 2008 Free Software Foundation, Inc.
-;; Written by CodeSourcery.
+;; ARM Cortex-A9 pipeline description
+;; Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+;; Originally written by CodeSourcery for VFP.
+;;
+;; Integer core pipeline description contributed by ARM Ltd.
 ;;
 ;; This file is part of GCC.
 ;;
@@ -20,9 +22,181 @@
 
 (define_automaton "cortex_a9")
 
-;; FIXME: We model a single pipeline for all instructions.
-;; Is dual-issue possible, and do we have other pipelines?
-(define_cpu_unit "cortex_a9_vfp" "cortex_a9")
+;; The Cortex-A9 integer core is modelled as a dual issue pipeline that has
+;; the following components.
+;; 1. 1 Load Store Pipeline.
+;; 2. P0 / main pipeline for data processing instructions.
+;; 3. P1 / Dual pipeline for Data processing instructions.
+;; 4. MAC pipeline for multiply as well as multiply
+;;    and accumulate instructions.
+;; 5. 1 VFP / Neon pipeline.
+;; The Load/Store and VFP/Neon pipeline are multiplexed.
+;; The P0 / main pipeline and M1 stage of the MAC pipeline are
+;;   multiplexed.
+;; The P1 / dual pipeline and M2 stage of the MAC pipeline are
+;;   multiplexed.
+;; There are only 4 register read ports and hence at any point of
+;; time we can't have issues down the E1 and the E2 ports unless
+;; of course there are bypass paths that get exercised.
+;; Both P0 and P1 have 2 stages E1 and E2.
+;; Data processing instructions issue to E1 or E2 depending on
+;; whether they have an early shift or not.
+
+
+(define_cpu_unit "cortex_a9_vfp, cortex_a9_ls" "cortex_a9")
+(define_cpu_unit "cortex_a9_p0_e1, cortex_a9_p0_e2" "cortex_a9")
+(define_cpu_unit "cortex_a9_p1_e1, cortex_a9_p1_e2" "cortex_a9")
+(define_cpu_unit "cortex_a9_p0_wb, cortex_a9_p1_wb" "cortex_a9")
+(define_cpu_unit "cortex_a9_mac_m1, cortex_a9_mac_m2" "cortex_a9")
+(define_cpu_unit "cortex_a9_branch, cortex_a9_issue_branch" "cortex_a9")
+
+(define_reservation "cortex_a9_p0_default" "cortex_a9_p0_e2, cortex_a9_p0_wb")
+(define_reservation "cortex_a9_p1_default" "cortex_a9_p1_e2, cortex_a9_p1_wb")
+(define_reservation "cortex_a9_p0_shift" "cortex_a9_p0_e1, cortex_a9_p0_default")
+(define_reservation "cortex_a9_p1_shift" "cortex_a9_p1_e1, cortex_a9_p1_default")
+
+(define_reservation "cortex_a9_multcycle1"
+  "cortex_a9_p0_e2 + cortex_a9_mac_m1 + cortex_a9_mac_m2 + \
+cortex_a9_p1_e2 + cortex_a9_p0_e1 + cortex_a9_p1_e1")
+
+(define_reservation "cortex_a9_mult16"
+  "cortex_a9_mac_m1, cortex_a9_mac_m2, cortex_a9_p0_wb")
+(define_reservation "cortex_a9_mac16"
+  "cortex_a9_multcycle1, cortex_a9_mac_m2, cortex_a9_p0_wb")
+(define_reservation "cortex_a9_mult"
+  "cortex_a9_mac_m1*2, cortex_a9_mac_m2, cortex_a9_p0_wb")
+(define_reservation "cortex_a9_mac"
+  "cortex_a9_multcycle1*2 ,cortex_a9_mac_m2, cortex_a9_p0_wb")
+
+
+;; Issue at the same time along the load store pipeline and
+;; the VFP / Neon pipeline is not possible.
+;; FIXME:: At some point we need to model the issue
+;; of the load store and the vfp being shared rather than anything else.
+
+(exclusion_set "cortex_a9_ls" "cortex_a9_vfp")
+
+
+;; Default data processing instruction without any shift
+;; The only exception to this is the mov instruction
+;; which can go down E2 without any problem.
+(define_insn_reservation "cortex_a9_dp" 2
+  (and (eq_attr "tune" "cortexa9")
+       (ior (eq_attr "type" "alu")
+	    (and (eq_attr "type" "alu_shift_reg, alu_shift")
+		 (eq_attr "insn" "mov"))))
+  "cortex_a9_p0_default|cortex_a9_p1_default")
+
+;; An instruction using the shifter will go down E1.
+(define_insn_reservation "cortex_a9_dp_shift" 3
+   (and (eq_attr "tune" "cortexa9")
+	(and (eq_attr "type" "alu_shift_reg, alu_shift")
+	     (not (eq_attr "insn" "mov"))))
+   "cortex_a9_p0_shift | cortex_a9_p1_shift")
+
+;; Loads have a latency of 4 cycles.
+;; We don't model autoincrement instructions. These
+;; instructions use the load store pipeline and 1 of
+;; the E2 units to write back the result of the increment.
+
+(define_insn_reservation "cortex_a9_load1_2" 4
+  (and (eq_attr "tune" "cortexa9")
+       (eq_attr "type" "load1, load2, load_byte"))
+  "cortex_a9_ls")
+
+;; Loads multiples and store multiples can't be issued for 2 cycles in a
+;; row. The description below assumes that addresses are 64 bit aligned.
+;; If not, there is an extra cycle latency which is not modelled.
+
+;; FIXME:: This bit might need to be reworked when we get to
+;; tuning for the VFP because strictly speaking the ldm
+;; is sent to the LSU unit as is and there is only an
+;; issue restriction between the LSU and the VFP/ Neon unit.
+
+(define_insn_reservation "cortex_a9_load3_4" 5
+  (and (eq_attr "tune" "cortexa9")
+       (eq_attr "type" "load3, load4"))
+  "cortex_a9_ls, cortex_a9_ls")
+
+(define_insn_reservation "cortex_a9_store1_2" 0
+  (and (eq_attr "tune" "cortexa9")
+       (eq_attr "type" "store1, store2"))
+  "cortex_a9_ls")
+
+;; Almost all our store multiples use an auto-increment
+;; form. Don't issue back to back load and store multiples
+;; because the load store unit will stall.
+(define_insn_reservation "cortex_a9_store3_4" 0
+  (and (eq_attr "tune" "cortexa9")
+       (eq_attr "type" "store3, store4"))
+  "cortex_a9_ls+(cortex_a9_p0_default | cortex_a9_p1_default), cortex_a9_ls")
+
+;; We get 16*16 multiply / mac results in 3 cycles.
+(define_insn_reservation "cortex_a9_mult16" 3
+  (and (eq_attr "tune" "cortexa9")
+       (eq_attr "insn" "smulxy"))
+       "cortex_a9_mult16")
+
+;; The 16*16 mac is slightly different that it
+;; reserves M1 and M2 in the same cycle.
+(define_insn_reservation "cortex_a9_mac16" 3
+  (and (eq_attr "tune" "cortexa9")
+       (eq_attr "insn" "smlaxy"))
+  "cortex_a9_mac16")
+
+
+(define_insn_reservation "cortex_a9_multiply" 4
+  (and (eq_attr "tune" "cortexa9")
+       (eq_attr "insn" "mul"))
+       "cortex_a9_mult")
+
+(define_insn_reservation "cortex_a9_mac" 4
+  (and (eq_attr "tune" "cortexa9")
+       (eq_attr "insn" "mla"))
+       "cortex_a9_mac")
+
+;; An instruction with a result in E2 can be forwarded
+;; to E2 or E1 or M1 or the load store unit in the next cycle.
+
+(define_bypass 1 "cortex_a9_dp"
+                 "cortex_a9_dp_shift, cortex_a9_multiply,
+ cortex_a9_load1_2, cortex_a9_dp, cortex_a9_store1_2,
+ cortex_a9_mult16, cortex_a9_mac16, cortex_a9_mac, cortex_a9_store3_4, cortex_a9_load3_4")
+
+(define_bypass 2 "cortex_a9_dp_shift"
+                 "cortex_a9_dp_shift, cortex_a9_multiply,
+ cortex_a9_load1_2, cortex_a9_dp, cortex_a9_store1_2,
+ cortex_a9_mult16, cortex_a9_mac16, cortex_a9_mac, cortex_a9_store3_4, cortex_a9_load3_4")
+
+;; An instruction in the load store pipeline can provide
+;; read access to a DP instruction in the P0 default pipeline
+;; before the writeback stage.
+
+(define_bypass 3 "cortex_a9_load1_2" "cortex_a9_dp, cortex_a9_load1_2,
+cortex_a9_store3_4, cortex_a9_store1_2")
+
+(define_bypass 4 "cortex_a9_load3_4" "cortex_a9_dp, cortex_a9_load1_2,
+cortex_a9_store3_4, cortex_a9_store1_2,  cortex_a9_load3_4")
+
+;; Calls and branches.
+
+;; Branch instructions
+
+(define_insn_reservation "cortex_a9_branch" 0
+  (and (eq_attr "tune" "cortexa9")
+       (eq_attr "type" "branch"))
+  "cortex_a9_branch")
+
+;; Call latencies are essentially 0 but make sure
+;; dual issue doesn't happen i.e the next instruction
+;; starts at the next cycle.
+(define_insn_reservation "cortex_a9_call"  0
+  (and (eq_attr "tune" "cortexa9")
+       (eq_attr "type" "call"))
+  "cortex_a9_issue_branch + cortex_a9_multcycle1 + cortex_a9_ls + cortex_a9_vfp")
+
+
+;; Pipelining for VFP instructions.
 
 (define_insn_reservation "cortex_a9_ffarith" 1
  (and (eq_attr "tune" "cortexa9")
diff --git a/gcc/config/arm/cygming.opt b/gcc/config/arm/cygming.opt
new file mode 100644
index 000000000..e1c9e0b25
--- /dev/null
+++ b/gcc/config/arm/cygming.opt
@@ -0,0 +1,36 @@
+; Cygwin- and MinGW-specific options.
+
+; Copyright (C) 2005 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+mcygwin
+Target
+Use the Cygwin interface
+
+; ### TODO make this work.
+; mnop-fun-dllimport
+; Target Report Var(TARGET_NOP_FUN_DLLIMPORT)
+; Ignore dllimport for functions
+
+mthreads
+Target RejectNegative
+Use Mingw-specific thread support
+
+mwin32
+Target
+Set Windows defines
diff --git a/gcc/config/arm/eabi-memcpy.c b/gcc/config/arm/eabi-memcpy.c
new file mode 100644
index 000000000..759852fce
--- /dev/null
+++ b/gcc/config/arm/eabi-memcpy.c
@@ -0,0 +1,108 @@
+/* Simple implementation of memcpy/memmove for targets that don't provide
+   their own.
+
+   copyright (c) 2010  free software foundation, inc.
+   contributed by codesourcery.
+
+   this file is free software; you can redistribute it and/or modify it
+   under the terms of the gnu general public license as published by the
+   free software foundation; either version 3, or (at your option) any
+   later version.
+
+   this file is distributed in the hope that it will be useful, but
+   without any warranty; without even the implied warranty of
+   merchantability or fitness for a particular purpose.  see the gnu
+   general public license for more details.
+
+   under section 7 of gpl version 3, you are granted additional
+   permissions described in the gcc runtime library exception, version
+   3.1, as published by the free software foundation.
+
+   you should have received a copy of the gnu general public license and
+   a copy of the gcc runtime library exception along with this program;
+   see the files copying3 and copying.runtime respectively.  if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+#define strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
+
+/* Nonzero if either X or Y is not aligned on a "long" boundary.  */
+#define UNALIGNED(X, Y) \
+  (((long)X & (sizeof (long) - 1)) | ((long)Y & (sizeof (long) - 1)))
+
+/* How many bytes are copied each iteration of the 4X unrolled loop.  */
+#define BIGBLOCKSIZE    (sizeof (long) << 2)
+
+/* How many bytes are copied each iteration of the word copy loop.  */
+#define LITTLEBLOCKSIZE (sizeof (long))
+
+/* Threshhold for punting to the byte copier.  */
+#define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)
+
+void
+__aeabi_memcpy (void *dst0, const void *src0, unsigned long len)
+{
+  char *dst = dst0;
+  const char *src = src0;
+  long *aligned_dst;
+  const long *aligned_src;
+
+  /* If the size is small, or either SRC or DST is unaligned,
+     then punt into the byte copy loop.  This should be rare.  */
+  if (!TOO_SMALL(len) && !UNALIGNED (src, dst))
+    {
+      aligned_dst = (long *)dst;
+      aligned_src = (const long *)src;
+
+      /* Copy 4X long words at a time if possible.  */
+      while (len >= BIGBLOCKSIZE)
+        {
+          *aligned_dst++ = *aligned_src++;
+          *aligned_dst++ = *aligned_src++;
+          *aligned_dst++ = *aligned_src++;
+          *aligned_dst++ = *aligned_src++;
+          len -= BIGBLOCKSIZE;
+        }
+
+      /* Copy one long word at a time if possible.  */
+      while (len >= LITTLEBLOCKSIZE)
+        {
+          *aligned_dst++ = *aligned_src++;
+          len -= LITTLEBLOCKSIZE;
+        }
+
+       /* Pick up any residual with a byte copier.  */
+      dst = (char *)aligned_dst;
+      src = (const char *)aligned_src;
+    }
+
+  while (len--)
+    *dst++ = *src++;
+}
+
+void
+__aeabi_memmove (void *dst_void, const void *src_void, unsigned long len)
+{
+  char *dst = dst_void;
+  const char *src = src_void;
+
+  if (src < dst && dst < src + len)
+    {
+      /* Destructive overlap...have to copy backwards */
+      src += len;
+      dst += len;
+      while (len--)
+	{
+	  *--dst = *--src;
+	}
+    }
+  else
+    __aeabi_memcpy (dst_void, src_void, len);
+}
+
+strong_alias(__aeabi_memcpy, __aeabi_memcpy4)
+strong_alias(__aeabi_memcpy, __aeabi_memcpy8)
+strong_alias(__aeabi_memmove, __aeabi_memmove4)
+strong_alias(__aeabi_memmove, __aeabi_memmove8)
diff --git a/gcc/config/arm/eabi-memset.c b/gcc/config/arm/eabi-memset.c
new file mode 100644
index 000000000..2036b898f
--- /dev/null
+++ b/gcc/config/arm/eabi-memset.c
@@ -0,0 +1,97 @@
+/* Simple implementation of memset/memclr for targets that don't provide
+   their own.
+
+   copyright (c) 2010  free software foundation, inc.
+   contributed by codesourcery.
+
+   this file is free software; you can redistribute it and/or modify it
+   under the terms of the gnu general public license as published by the
+   free software foundation; either version 3, or (at your option) any
+   later version.
+
+   this file is distributed in the hope that it will be useful, but
+   without any warranty; without even the implied warranty of
+   merchantability or fitness for a particular purpose.  see the gnu
+   general public license for more details.
+
+   under section 7 of gpl version 3, you are granted additional
+   permissions described in the gcc runtime library exception, version
+   3.1, as published by the free software foundation.
+
+   you should have received a copy of the gnu general public license and
+   a copy of the gcc runtime library exception along with this program;
+   see the files copying3 and copying.runtime respectively.  if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+#define strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
+
+#define LBLOCKSIZE (sizeof(long))
+#define UNALIGNED(X)   ((long)X & (LBLOCKSIZE - 1))
+#define TOO_SMALL(LEN) ((LEN) < LBLOCKSIZE)
+
+void
+__aeabi_memset (void *m, unsigned long n, int c)
+{
+  char *s = (char *)m;
+  int i;
+  unsigned long buffer;
+  unsigned long *aligned_addr;
+  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
+				   unsigned variable.  */
+
+  while (UNALIGNED (s))
+    {
+      if (n--)
+        *s++ = (char) c;
+      else
+        return;
+    }
+
+  if (!TOO_SMALL (n))
+    {
+      /* If we get this far, we know that n is large and s is word-aligned. */
+      aligned_addr = (unsigned long *)s;
+
+      /* Store D into each char sized location in BUFFER so that
+         we can set large blocks quickly.  */
+      buffer = (d << 8) | d;
+      buffer |= (buffer << 16);
+      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
+        buffer = (buffer << i) | buffer;
+
+      /* Unroll the loop.  */
+      while (n >= LBLOCKSIZE * 4)
+        {
+          *aligned_addr++ = buffer;
+          *aligned_addr++ = buffer;
+          *aligned_addr++ = buffer;
+          *aligned_addr++ = buffer;
+          n -= 4 * LBLOCKSIZE;
+        }
+
+      while (n >= LBLOCKSIZE)
+        {
+          *aligned_addr++ = buffer;
+          n -= LBLOCKSIZE;
+        }
+      /* Pick up the remainder with a bytewise loop.  */
+      s = (char *)aligned_addr;
+    }
+
+  while (n--)
+    *s++ = (char) c;
+}
+
+void
+__aeabi_memclr (void *m, unsigned long n)
+{
+  __aeabi_memset (m, n, 0);
+}
+
+strong_alias(__aeabi_memset, __aeabi_memset4)
+strong_alias(__aeabi_memset, __aeabi_memset8)
+strong_alias(__aeabi_memclr, __aeabi_memclr4)
+strong_alias(__aeabi_memclr, __aeabi_memclr8)
diff --git a/gcc/config/arm/elf.h b/gcc/config/arm/elf.h
index 7c3eddbe0..581923349 100644
--- a/gcc/config/arm/elf.h
+++ b/gcc/config/arm/elf.h
@@ -63,6 +63,7 @@
 %{mthumb-interwork:-mthumb-interwork} \
 %{msoft-float:-mfloat-abi=soft} %{mhard-float:-mfloat-abi=hard} \
 %{mfloat-abi=*} %{mfpu=*} \
+%{mthumb:%{!-mimplicit-it=*:-mimplicit-it=thumb}} \
 %(subtarget_extra_asm_spec)"
 #endif
 
diff --git a/gcc/config/arm/fp16.c b/gcc/config/arm/fp16.c
new file mode 100644
index 000000000..a49401d3d
--- /dev/null
+++ b/gcc/config/arm/fp16.c
@@ -0,0 +1,152 @@
+/* Half-float conversion routines.
+
+   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+   Contributed by CodeSourcery.
+
+   This file is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 3, or (at your option) any
+   later version.
+
+   This file is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+static inline unsigned int
+__gnu_f2h_internal(unsigned int a, int ieee)
+{
+  unsigned int sign = (a >> 16) & 0x8000;
+  int aexp = (a >> 23) & 0xff;
+  unsigned int mantissa = a & 0x007fffff;
+  unsigned int mask;
+  unsigned int increment;
+
+  if (aexp == 0xff)
+    {
+      if (!ieee)
+	return sign;
+      return sign | 0x7e00 | (mantissa >> 13);
+    }
+  
+  if (aexp == 0 && mantissa == 0)
+    return sign;
+
+  aexp -= 127;
+
+  /* Decimal point between bits 22 and 23.  */
+  mantissa |= 0x00800000;
+  if (aexp < -14)
+    {
+      mask = 0x007fffff;
+      if (aexp < -25)
+	aexp = -26;
+      else if (aexp != -25)
+	mask >>= 24 + aexp;
+    }
+  else
+    mask = 0x00001fff;
+
+  /* Round.  */
+  if (mantissa & mask)
+    {
+      increment = (mask + 1) >> 1;
+      if ((mantissa & mask) == increment)
+	increment = mantissa & (increment << 1);
+      mantissa += increment;
+      if (mantissa >= 0x01000000)
+       	{
+	  mantissa >>= 1;
+	  aexp++;
+	}
+    }
+
+  if (ieee)
+    {
+      if (aexp > 15)
+	return sign | 0x7c00;
+    }
+  else
+    {
+      if (aexp > 16)
+	return sign | 0x7fff;
+    }
+
+  if (aexp < -24)
+    return sign;
+
+  if (aexp < -14)
+    {
+      mantissa >>= -14 - aexp;
+      aexp = -14;
+    }
+
+  /* We leave the leading 1 in the mantissa, and subtract one
+     from the exponent bias to compensate.  */
+  return sign | (((aexp + 14) << 10) + (mantissa >> 13));
+}
+
+static inline unsigned int
+__gnu_h2f_internal(unsigned int a, int ieee)
+{
+  unsigned int sign = (a & 0x00008000) << 16;
+  int aexp = (a >> 10) & 0x1f;
+  unsigned int mantissa = a & 0x3ff;
+
+  if (aexp == 0x1f && ieee)
+    return sign | 0x7f800000 | (mantissa << 13);
+
+  if (aexp == 0)
+    {
+      int shift;
+
+      if (mantissa == 0)
+	return sign;
+
+      shift = __builtin_clz(mantissa) - 21;
+      mantissa <<= shift;
+      aexp = -shift;
+    }
+
+  return sign | (((aexp + 0x70) << 23) + (mantissa << 13));
+}
+
+#define ALIAS(src, dst) \
+  typeof (src) dst __attribute__ ((alias (#src)));
+
+unsigned int
+__gnu_f2h_ieee(unsigned int a)
+{
+  return __gnu_f2h_internal(a, 1);
+}
+ALIAS (__gnu_f2h_ieee, __aeabi_f2h)
+
+unsigned int
+__gnu_h2f_ieee(unsigned int a)
+{
+  return __gnu_h2f_internal(a, 1);
+}
+ALIAS (__gnu_h2f_ieee, __aeabi_h2f)
+
+unsigned int
+__gnu_f2h_alternative(unsigned int x)
+{
+  return __gnu_f2h_internal(x, 0);
+}
+ALIAS (__gnu_f2h_alternative, __aeabi_f2h_alt)
+
+unsigned int
+__gnu_h2f_alternative(unsigned int a)
+{
+  return __gnu_h2f_internal(a, 0);
+}
+ALIAS (__gnu_h2f_alternative, __aeabi_h2f_alt)
diff --git a/gcc/config/arm/fpa.md b/gcc/config/arm/fpa.md
index fcd92b002..515de43d2 100644
--- a/gcc/config/arm/fpa.md
+++ b/gcc/config/arm/fpa.md
@@ -599,10 +599,10 @@
     {
     default:
     case 0: return \"mvf%?e\\t%0, %1\";
-    case 1: if (arm_fpu_arch == FPUTYPE_FPA_EMU2)
+    case 1: if (TARGET_FPA_EMU2)
 	      return \"ldf%?e\\t%0, %1\";
 	    return \"lfm%?\\t%0, 1, %1\";
-    case 2: if (arm_fpu_arch == FPUTYPE_FPA_EMU2)
+    case 2: if (TARGET_FPA_EMU2)
 	      return \"stf%?e\\t%1, %0\";
 	    return \"sfm%?\\t%1, 1, %0\";
     }
diff --git a/gcc/config/arm/hwdiv.md b/gcc/config/arm/hwdiv.md
new file mode 100644
index 000000000..ffd19ca96
--- /dev/null
+++ b/gcc/config/arm/hwdiv.md
@@ -0,0 +1,41 @@
+;; ARM instruction patterns for hardware division 
+;; Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
+;; Written by CodeSourcery, LLC.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful, but
+;; WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;; General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+;; Boston, MA 02110-1301, USA.
+
+(define_insn "divsi3"
+  [(set (match_operand:SI	  0 "s_register_operand" "=r")
+	(div:SI (match_operand:SI 1 "s_register_operand"  "r")
+		(match_operand:SI 2 "s_register_operand"  "r")))]
+  "arm_arch_hwdiv"
+  "sdiv%?\t%0, %1, %2"
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "sdiv")]
+)
+
+(define_insn "udivsi3"
+  [(set (match_operand:SI	   0 "s_register_operand" "=r")
+	(udiv:SI (match_operand:SI 1 "s_register_operand"  "r")
+		 (match_operand:SI 2 "s_register_operand"  "r")))]
+  "arm_arch_hwdiv"
+  "udiv%?\t%0, %1, %2"
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "udiv")]
+)
+
diff --git a/gcc/config/arm/ieee754-df.S b/gcc/config/arm/ieee754-df.S
index eb0c38632..0cbb60de3 100644
--- a/gcc/config/arm/ieee754-df.S
+++ b/gcc/config/arm/ieee754-df.S
@@ -83,7 +83,7 @@ ARM_FUNC_ALIAS aeabi_dsub subdf3
 ARM_FUNC_START adddf3
 ARM_FUNC_ALIAS aeabi_dadd adddf3
 
-1:	do_push	{r4, r5, lr}
+1:	do_push	(r4, r5, lr)
 
 	@ Look for zeroes, equal values, INF, or NAN.
 	shift1	lsl, r4, xh, #1
@@ -427,7 +427,7 @@ ARM_FUNC_ALIAS aeabi_ui2d floatunsidf
 	do_it	eq, t
 	moveq	r1, #0
 	RETc(eq)
-	do_push	{r4, r5, lr}
+	do_push	(r4, r5, lr)
 	mov	r4, #0x400		@ initial exponent
 	add	r4, r4, #(52-1 - 1)
 	mov	r5, #0			@ sign bit is 0
@@ -447,7 +447,7 @@ ARM_FUNC_ALIAS aeabi_i2d floatsidf
 	do_it	eq, t
 	moveq	r1, #0
 	RETc(eq)
-	do_push	{r4, r5, lr}
+	do_push	(r4, r5, lr)
 	mov	r4, #0x400		@ initial exponent
 	add	r4, r4, #(52-1 - 1)
 	ands	r5, r0, #0x80000000	@ sign bit in r5
@@ -481,7 +481,7 @@ ARM_FUNC_ALIAS aeabi_f2d extendsfdf2
 	RETc(eq)			@ we are done already.
 
 	@ value was denormalized.  We can normalize it now.
-	do_push	{r4, r5, lr}
+	do_push	(r4, r5, lr)
 	mov	r4, #0x380		@ setup corresponding exponent
 	and	r5, xh, #0x80000000	@ move sign bit in r5
 	bic	xh, xh, #0x80000000
@@ -508,9 +508,9 @@ ARM_FUNC_ALIAS aeabi_ul2d floatundidf
 	@ compatibility.
 	adr	ip, LSYM(f0_ret)
 	@ Push pc as well so that RETLDM works correctly.
-	do_push	{r4, r5, ip, lr, pc}
+	do_push	(r4, r5, ip, lr, pc)
 #else
-	do_push	{r4, r5, lr}
+	do_push	(r4, r5, lr)
 #endif
 
 	mov	r5, #0
@@ -534,9 +534,9 @@ ARM_FUNC_ALIAS aeabi_l2d floatdidf
 	@ compatibility.
 	adr	ip, LSYM(f0_ret)
 	@ Push pc as well so that RETLDM works correctly.
-	do_push	{r4, r5, ip, lr, pc}
+	do_push	(r4, r5, ip, lr, pc)
 #else
-	do_push	{r4, r5, lr}
+	do_push	(r4, r5, lr)
 #endif
 
 	ands	r5, ah, #0x80000000	@ sign bit in r5
@@ -585,7 +585,7 @@ ARM_FUNC_ALIAS aeabi_l2d floatdidf
 	@ Legacy code expects the result to be returned in f0.  Copy it
 	@ there as well.
 LSYM(f0_ret):
-	do_push	{r0, r1}
+	do_push	(r0, r1)
 	ldfd	f0, [sp], #8
 	RETLDM
 
@@ -602,7 +602,7 @@ LSYM(f0_ret):
 
 ARM_FUNC_START muldf3
 ARM_FUNC_ALIAS aeabi_dmul muldf3
-	do_push	{r4, r5, r6, lr}
+	do_push	(r4, r5, r6, lr)
 
 	@ Mask out exponents, trap any zero/denormal/INF/NAN.
 	mov	ip, #0xff
@@ -910,7 +910,7 @@ LSYM(Lml_n):
 ARM_FUNC_START divdf3
 ARM_FUNC_ALIAS aeabi_ddiv divdf3
 	
-	do_push	{r4, r5, r6, lr}
+	do_push	(r4, r5, r6, lr)
 
 	@ Mask out exponents, trap any zero/denormal/INF/NAN.
 	mov	ip, #0xff
@@ -1195,7 +1195,7 @@ ARM_FUNC_ALIAS aeabi_cdcmple aeabi_cdcmpeq
 
 	@ The status-returning routines are required to preserve all
 	@ registers except ip, lr, and cpsr.
-6:	do_push	{r0, lr}
+6:	do_push	(r0, lr)
 	ARM_CALL cmpdf2
 	@ Set the Z flag correctly, and the C flag unconditionally.
 	cmp	r0, #0
diff --git a/gcc/config/arm/ieee754-sf.S b/gcc/config/arm/ieee754-sf.S
index c93f66d8f..0a3afc1e0 100644
--- a/gcc/config/arm/ieee754-sf.S
+++ b/gcc/config/arm/ieee754-sf.S
@@ -481,7 +481,7 @@ LSYM(Lml_x):
 	and	r3, ip, #0x80000000
 
 	@ Well, no way to make it shorter without the umull instruction.
-	do_push	{r3, r4, r5}
+	do_push	(r3, r4, r5)
 	mov	r4, r0, lsr #16
 	mov	r5, r1, lsr #16
 	bic	r0, r0, r4, lsl #16
@@ -492,7 +492,7 @@ LSYM(Lml_x):
 	mla	r0, r4, r1, r0
 	adds	r3, r3, r0, lsl #16
 	adc	r1, ip, r0, lsr #16
-	do_pop	{r0, r4, r5}
+	do_pop	(r0, r4, r5)
 
 #else
 
@@ -882,7 +882,7 @@ ARM_FUNC_ALIAS aeabi_cfcmple aeabi_cfcmpeq
 
 	@ The status-returning routines are required to preserve all
 	@ registers except ip, lr, and cpsr.
-6:	do_push	{r0, r1, r2, r3, lr}
+6:	do_push	(r0, r1, r2, r3, lr)
 	ARM_CALL cmpsf2
 	@ Set the Z flag correctly, and the C flag unconditionally.
 	cmp	r0, #0
diff --git a/gcc/config/arm/lib1funcs.asm b/gcc/config/arm/lib1funcs.asm
index d0e9203d4..e96d9aab3 100644
--- a/gcc/config/arm/lib1funcs.asm
+++ b/gcc/config/arm/lib1funcs.asm
@@ -27,8 +27,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #if defined(__ELF__) && defined(__linux__)
 .section .note.GNU-stack,"",%progbits
 .previous
-#endif
-
+#endif  /* __ELF__ and __linux__ */
+
+#ifdef __ARM_EABI__
+/* Some attributes that are common to all routines in this file.  */
+       /* Tag_ABI_align8_needed: This code does not require 8-byte
+          alignment from the caller.  */
+       /* .eabi_attribute 24, 0  -- default setting.  */
+       /* Tag_ABI_align8_preserved: This code preserves 8-byte 
+          alignment in any callee.  */
+       .eabi_attribute 25, 1
+#endif /* __ARM_EABI__ */
 /* ------------------------------------------------------------------------ */
 
 /* We need to know what prefix to add to function names.  */
@@ -234,8 +243,8 @@ LSYM(Lend_fde):
 .macro shift1 op, arg0, arg1, arg2
 	\op	\arg0, \arg1, \arg2
 .endm
-#define do_push	push
-#define do_pop	pop
+#define do_push(...)	push {__VA_ARGS__}
+#define do_pop(...)	pop {__VA_ARGS__}
 #define COND(op1, op2, cond) op1 ## op2 ## cond
 /* Perform an arithmetic operation with a variable shift operand.  This
    requires two instructions and a scratch register on Thumb-2.  */
@@ -249,24 +258,133 @@ LSYM(Lend_fde):
 .macro shift1 op, arg0, arg1, arg2
 	mov	\arg0, \arg1, \op \arg2
 .endm
-#define do_push	stmfd sp!,
-#define do_pop	ldmfd sp!,
+#if defined(__low_irq_latency__)        
+#define do_push(...) \
+  _buildN1(do_push, _buildC1(__VA_ARGS__))( __VA_ARGS__)
+#define _buildN1(BASE, X)	_buildN2(BASE, X)
+#define _buildN2(BASE, X)	BASE##X
+#define _buildC1(...)		_buildC2(__VA_ARGS__,9,8,7,6,5,4,3,2,1)
+#define _buildC2(a1,a2,a3,a4,a5,a6,a7,a8,a9,c,...) c
+        
+#define do_push1(r1) str r1, [sp, #-4]!
+#define do_push2(r1, r2) str r2, [sp, #-4]! ; str r1, [sp, #-4]!
+#define do_push3(r1, r2, r3) str r3, [sp, #-4]! ; str r2, [sp, #-4]!; str r1, [sp, #-4]!
+#define do_push4(r1, r2, r3, r4) \
+        do_push3 (r2, r3, r4);\
+        do_push1 (r1)
+#define do_push5(r1, r2, r3, r4, r5) \
+        do_push4 (r2, r3, r4, r5);\
+        do_push1 (r1)
+        
+#define do_pop(...) \
+_buildN1(do_pop, _buildC1(__VA_ARGS__))( __VA_ARGS__)
+        
+#define do_pop1(r1) ldr r1, [sp], #4
+#define do_pop2(r1, r2) ldr r1, [sp], #4 ; ldr r2, [sp], #4
+#define do_pop3(r1, r2, r3) ldr r1, [sp], #4 ; str r2, [sp], #4; str r3, [sp], #4
+#define do_pop4(r1, r2, r3, r4) \
+        do_pop1 (r1);\
+        do_pup3 (r2, r3, r4)
+#define do_pop5(r1, r2, r3, r4, r5) \
+        do_pop1 (r1);\
+        do_pop4 (r2, r3, r4, r5)
+#else
+#define do_push(...)    stmfd sp!, { __VA_ARGS__}
+#define do_pop(...)     ldmfd sp!, {__VA_ARGS__}
+#endif
+
+        
 #define COND(op1, op2, cond) op1 ## cond ## op2
 .macro shiftop name, dest, src1, src2, shiftop, shiftreg, tmp
 	\name \dest, \src1, \src2, \shiftop \shiftreg
 .endm
 #endif
 
-.macro ARM_LDIV0 name
+#ifdef __ARM_EABI__
+.macro ARM_LDIV0 name signed
+	cmp	r0, #0
+	.ifc	\signed, unsigned
+	movne	r0, #0xffffffff
+	.else
+	movgt	r0, #0x7fffffff
+	movlt	r0, #0x80000000
+	.endif
+	b	SYM (__aeabi_idiv0) __PLT__
+.endm
+#else
+.macro ARM_LDIV0 name signed
 	str	lr, [sp, #-8]!
 98:	cfi_push 98b - __\name, 0xe, -0x8, 0x8
 	bl	SYM (__div0) __PLT__
 	mov	r0, #0			@ About as wrong as it could be.
 	RETLDM	unwind=98b
 .endm
+#endif
 
 
-.macro THUMB_LDIV0 name
+#ifdef __ARM_EABI__
+.macro THUMB_LDIV0 name signed
+#if defined(__ARM_ARCH_6M__)
+	.ifc \signed, unsigned
+	cmp	r0, #0
+	beq	1f
+	mov	r0, #0
+	mvn	r0, r0		@ 0xffffffff
+1:
+	.else
+	cmp	r0, #0
+	beq	2f
+	blt	3f
+	mov	r0, #0
+	mvn	r0, r0
+	lsr	r0, r0, #1	@ 0x7fffffff
+	b	2f
+3:	mov	r0, #0x80
+	lsl	r0, r0, #24	@ 0x80000000
+2:
+	.endif
+	push	{r0, r1, r2}
+	ldr	r0, 4f
+	adr	r1, 4f
+	add	r0, r1
+	str	r0, [sp, #8]
+	@ We know we are not on armv4t, so pop pc is safe.
+	pop	{r0, r1, pc}
+	.align	2
+4:
+	.word	__aeabi_idiv0 - 4b
+#elif defined(__thumb2__)
+	.syntax unified
+	.ifc \signed, unsigned
+	cbz	r0, 1f
+	mov	r0, #0xffffffff
+1:
+	.else
+	cmp	r0, #0
+	do_it	gt
+	movgt	r0, #0x7fffffff
+	do_it	lt
+	movlt	r0, #0x80000000
+	.endif
+	b.w	SYM(__aeabi_idiv0) __PLT__
+#else
+	.align	2
+	bx	pc
+	nop
+	.arm
+	cmp	r0, #0
+	.ifc	\signed, unsigned
+	movne	r0, #0xffffffff
+	.else
+	movgt	r0, #0x7fffffff
+	movlt	r0, #0x80000000
+	.endif
+	b	SYM(__aeabi_idiv0) __PLT__
+	.thumb
+#endif
+.endm
+#else
+.macro THUMB_LDIV0 name signed
 	push	{ r1, lr }
 98:	cfi_push 98b - __\name, 0xe, -0x4, 0x8
 	bl	SYM (__div0)
@@ -278,18 +396,19 @@ LSYM(Lend_fde):
 	pop	{ r1, pc }
 #endif
 .endm
+#endif
 
 .macro FUNC_END name
 	SIZE (__\name)
 .endm
 
-.macro DIV_FUNC_END name
+.macro DIV_FUNC_END name signed
 	cfi_start	__\name, LSYM(Lend_div0)
 LSYM(Ldiv0):
 #ifdef __thumb__
-	THUMB_LDIV0 \name
+	THUMB_LDIV0 \name \signed
 #else
-	ARM_LDIV0 \name
+	ARM_LDIV0 \name \signed
 #endif
 	cfi_end	LSYM(Lend_div0)
 	FUNC_END \name
@@ -414,6 +533,12 @@ SYM (__\name):
 #define yyl r2
 #endif	
 
+#ifdef __ARM_EABI__
+.macro	WEAK name
+	.weak SYM (__\name)
+.endm
+#endif
+
 #ifdef __thumb__
 /* Register aliases.  */
 
@@ -438,6 +563,43 @@ pc		.req	r15
 
 #if __ARM_ARCH__ >= 5 && ! defined (__OPTIMIZE_SIZE__)
 
+#if defined (__thumb2__)
+	clz	\curbit, \dividend
+	clz	\result, \divisor
+	sub	\curbit, \result, \curbit
+	rsb	\curbit, \curbit, #31
+	adr	\result, 1f
+	add	\curbit, \result, \curbit, lsl #4
+	mov	\result, #0
+	mov	pc, \curbit
+.p2align 3
+1:
+	.set	shift, 32
+	.rept	32
+	.set	shift, shift - 1
+	cmp.w	\dividend, \divisor, lsl #shift
+	nop.n
+	adc.w	\result, \result, \result
+	it	cs
+	subcs.w	\dividend, \dividend, \divisor, lsl #shift
+	.endr
+#elif defined(__ARM_TUNE_MARVELL_F__)
+	clz	\curbit, \dividend
+	clz	\result, \divisor
+	sub	\curbit, \result, \curbit
+	mov	\divisor, \divisor, lsl \curbit
+	rsb	\curbit, \curbit, #31
+	mov	\curbit, \curbit, lsl #2
+	mov	\result, #0
+	add	pc, pc, \curbit, lsl #2
+	nop
+	.rept	32
+	cmp	\dividend, \divisor
+	subcs	\dividend, \dividend, \divisor
+	mov	\divisor, \divisor, lsr #1
+	adc	\result, \result, \result
+	.endr
+#else  /* ! defined(__ARM_TUNE_MARVELL_F__) */
 	clz	\curbit, \dividend
 	clz	\result, \divisor
 	sub	\curbit, \result, \curbit
@@ -453,6 +615,7 @@ pc		.req	r15
 	adc	\result, \result, \result
 	subcs	\dividend, \dividend, \divisor, lsl #shift
 	.endr
+#endif /* defined(__ARM_TUNE_MARVELL_F__) */
 
 #else /* __ARM_ARCH__ < 5 || defined (__OPTIMIZE_SIZE__) */
 #if __ARM_ARCH__ >= 5
@@ -500,18 +663,23 @@ pc		.req	r15
 
 	@ Division loop
 1:	cmp	\dividend, \divisor
+	do_it	hs, t
 	subhs	\dividend, \dividend, \divisor
 	orrhs	\result,   \result,   \curbit
 	cmp	\dividend, \divisor,  lsr #1
+	do_it	hs, t
 	subhs	\dividend, \dividend, \divisor, lsr #1
 	orrhs	\result,   \result,   \curbit,  lsr #1
 	cmp	\dividend, \divisor,  lsr #2
+	do_it	hs, t
 	subhs	\dividend, \dividend, \divisor, lsr #2
 	orrhs	\result,   \result,   \curbit,  lsr #2
 	cmp	\dividend, \divisor,  lsr #3
+	do_it	hs, t
 	subhs	\dividend, \dividend, \divisor, lsr #3
 	orrhs	\result,   \result,   \curbit,  lsr #3
 	cmp	\dividend, #0			@ Early termination?
+	do_it	ne, t
 	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
 	movne	\divisor,  \divisor, lsr #4
 	bne	1b
@@ -800,13 +968,14 @@ LSYM(Lgot_result):
 /* ------------------------------------------------------------------------ */
 #ifdef L_udivsi3
 
+#if defined(__ARM_ARCH_6M__)
+
 	FUNC_START udivsi3
 	FUNC_ALIAS aeabi_uidiv udivsi3
 
-#ifdef __thumb__
-
 	cmp	divisor, #0
 	beq	LSYM(Ldiv0)
+LSYM(udivsi3_nodiv0):
 	mov	curbit, #1
 	mov	result, #0
 	
@@ -820,9 +989,16 @@ LSYM(Lgot_result):
 	pop	{ work }
 	RET
 
-#else /* ARM version.  */
+#else /* ARM/Thumb-2 version.  */
+
+	ARM_FUNC_START udivsi3
+	ARM_FUNC_ALIAS aeabi_uidiv udivsi3
 
+	/* Note: if called via udivsi3_nodiv0, this will unnecessarily check
+	   for division-by-zero a second time.  */
+LSYM(udivsi3_nodiv0):
 	subs	r2, r1, #1
+	do_it	eq
 	RETc(eq)
 	bcc	LSYM(Ldiv0)
 	cmp	r0, r1
@@ -835,7 +1011,8 @@ LSYM(Lgot_result):
 	mov	r0, r2
 	RET	
 
-11:	moveq	r0, #1
+11:	do_it	eq, e
+	moveq	r0, #1
 	movne	r0, #0
 	RET
 
@@ -846,19 +1023,24 @@ LSYM(Lgot_result):
 
 #endif /* ARM version */
 
-	DIV_FUNC_END udivsi3
+	DIV_FUNC_END udivsi3 unsigned
 
+#if defined(__ARM_ARCH_6M__)
 FUNC_START aeabi_uidivmod
-#ifdef __thumb__
+	cmp	r1, #0
+	beq	LSYM(Ldiv0)
 	push	{r0, r1, lr}
-	bl	SYM(__udivsi3)
+	bl	LSYM(udivsi3_nodiv0)
 	POP	{r1, r2, r3}
 	mul	r2, r0
 	sub	r1, r1, r2
 	bx	r3
 #else
+ARM_FUNC_START aeabi_uidivmod
+	cmp	r1, #0
+	beq	LSYM(Ldiv0)
 	stmfd	sp!, { r0, r1, lr }
-	bl	SYM(__udivsi3)
+	bl	LSYM(udivsi3_nodiv0)
 	ldmfd	sp!, { r1, r2, lr }
 	mul	r3, r2, r0
 	sub	r1, r1, r3
@@ -905,19 +1087,20 @@ LSYM(Lover10):
 
 #endif /* ARM version.  */
 	
-	DIV_FUNC_END umodsi3
+	DIV_FUNC_END umodsi3 unsigned
 
 #endif /* L_umodsi3 */
 /* ------------------------------------------------------------------------ */
 #ifdef L_divsi3
 
+#if defined(__ARM_ARCH_6M__)
+
 	FUNC_START divsi3	
 	FUNC_ALIAS aeabi_idiv divsi3
 
-#ifdef __thumb__
 	cmp	divisor, #0
 	beq	LSYM(Ldiv0)
-	
+LSYM(divsi3_nodiv0):
 	push	{ work }
 	mov	work, dividend
 	eor	work, divisor		@ Save the sign of the result.
@@ -946,15 +1129,21 @@ LSYM(Lover12):
 	pop	{ work }
 	RET
 
-#else /* ARM version.  */
+#else /* ARM/Thumb-2 version.  */
 	
+	ARM_FUNC_START divsi3	
+	ARM_FUNC_ALIAS aeabi_idiv divsi3
+
 	cmp	r1, #0
-	eor	ip, r0, r1			@ save the sign of the result.
 	beq	LSYM(Ldiv0)
+LSYM(divsi3_nodiv0):
+	eor	ip, r0, r1			@ save the sign of the result.
+	do_it	mi
 	rsbmi	r1, r1, #0			@ loops below use unsigned.
 	subs	r2, r1, #1			@ division by 1 or -1 ?
 	beq	10f
 	movs	r3, r0
+	do_it	mi
 	rsbmi	r3, r0, #0			@ positive dividend value
 	cmp	r3, r1
 	bls	11f
@@ -964,14 +1153,18 @@ LSYM(Lover12):
 	ARM_DIV_BODY r3, r1, r0, r2
 	
 	cmp	ip, #0
+	do_it	mi
 	rsbmi	r0, r0, #0
 	RET	
 
 10:	teq	ip, r0				@ same sign ?
+	do_it	mi
 	rsbmi	r0, r0, #0
 	RET	
 
-11:	movlo	r0, #0
+11:	do_it	lo
+	movlo	r0, #0
+	do_it	eq,t
 	moveq	r0, ip, asr #31
 	orreq	r0, r0, #1
 	RET
@@ -980,24 +1173,30 @@ LSYM(Lover12):
 
 	cmp	ip, #0
 	mov	r0, r3, lsr r2
+	do_it	mi
 	rsbmi	r0, r0, #0
 	RET
 
 #endif /* ARM version */
 	
-	DIV_FUNC_END divsi3
+	DIV_FUNC_END divsi3 signed
 
+#if defined(__ARM_ARCH_6M__)
 FUNC_START aeabi_idivmod
-#ifdef __thumb__
+	cmp	r1, #0
+	beq	LSYM(Ldiv0)
 	push	{r0, r1, lr}
-	bl	SYM(__divsi3)
+	bl	LSYM(divsi3_nodiv0)
 	POP	{r1, r2, r3}
 	mul	r2, r0
 	sub	r1, r1, r2
 	bx	r3
 #else
+ARM_FUNC_START aeabi_idivmod
+	cmp	r1, #0
+	beq	LSYM(Ldiv0)
 	stmfd	sp!, { r0, r1, lr }
-	bl	SYM(__divsi3)
+	bl	LSYM(divsi3_nodiv0)
 	ldmfd	sp!, { r1, r2, lr }
 	mul	r3, r2, r0
 	sub	r1, r1, r3
@@ -1063,21 +1262,25 @@ LSYM(Lover12):
 
 #endif /* ARM version */
 	
-	DIV_FUNC_END modsi3
+	DIV_FUNC_END modsi3 signed
 
 #endif /* L_modsi3 */
 /* ------------------------------------------------------------------------ */
 #ifdef L_dvmd_tls
 
-	FUNC_START div0
-	FUNC_ALIAS aeabi_idiv0 div0
-	FUNC_ALIAS aeabi_ldiv0 div0
-
+#ifdef __ARM_EABI__
+	WEAK aeabi_idiv0
+	WEAK aeabi_ldiv0
+	FUNC_START aeabi_idiv0
+	FUNC_START aeabi_ldiv0
 	RET
-
 	FUNC_END aeabi_ldiv0
 	FUNC_END aeabi_idiv0
+#else
+	FUNC_START div0
+	RET
 	FUNC_END div0
+#endif
 	
 #endif /* L_divmodsi_tools */
 /* ------------------------------------------------------------------------ */
@@ -1087,16 +1290,49 @@ LSYM(Lover12):
 /* Constant taken from <asm/signal.h>.  */
 #define SIGFPE	8
 
+#ifdef __ARM_EABI__
+	WEAK aeabi_idiv0
+	WEAK aeabi_ldiv0
+	ARM_FUNC_START aeabi_idiv0
+	ARM_FUNC_START aeabi_ldiv0
+#else
 	ARM_FUNC_START div0
+#endif
 
-	do_push	{r1, lr}
+	do_push	(r1, lr)
 	mov	r0, #SIGFPE
 	bl	SYM(raise) __PLT__
 	RETLDM	r1
 
+#ifdef __ARM_EABI__
+	FUNC_END aeabi_ldiv0
+	FUNC_END aeabi_idiv0
+#else
 	FUNC_END div0
+#endif
 	
 #endif /* L_dvmd_lnx */
+#ifdef L_clear_cache
+#if defined __ARM_EABI__ && defined __linux__
+@ EABI GNU/Linux call to cacheflush syscall.
+	ARM_FUNC_START clear_cache
+	do_push	(r7)
+#if __ARM_ARCH__ >= 7 || defined(__ARM_ARCH_6T2__)
+	movw	r7, #2
+	movt	r7, #0xf
+#else
+	mov	r7, #0xf0000
+	add	r7, r7, #2
+#endif
+	mov	r2, #0
+	swi	0
+	do_pop	(r7)
+	RET
+	FUNC_END clear_cache
+#else
+#error "This is only for ARM EABI GNU/Linux"
+#endif
+#endif /* L_clear_cache */
 /* ------------------------------------------------------------------------ */
 /* Dword shift operations.  */
 /* All the following Dword shift variants rely on the fact that
@@ -1114,9 +1350,6 @@ LSYM(Lover12):
 #define ah	r1
 #endif
 
-/* Prevent __aeabi double-word shifts from being produced on SymbianOS.  */
-#ifndef __symbian__
-
 #ifdef L_lshrdi3
 
 	FUNC_START lshrdi3
@@ -1218,8 +1451,6 @@ LSYM(Lover12):
 
 #endif
 
-#endif /* __symbian__ */
-
 #if ((__ARM_ARCH__ > 5) && !defined(__ARM_ARCH_6M__)) \
     || defined(__ARM_ARCH_5E__) || defined(__ARM_ARCH_5TE__) \
     || defined(__ARM_ARCH_5TEJ__)
@@ -1293,7 +1524,7 @@ FUNC_START clzdi2
 	push	{r4, lr}
 # else
 ARM_FUNC_START clzdi2
-	do_push	{r4, lr}
+	do_push	(r4, lr)
 # endif
 	cmp	xxh, #0
 	bne	1f
@@ -1515,7 +1746,6 @@ LSYM(Lchange_\register):
 #endif /* !__thumb2__ */
 #endif /* Arch supports thumb.  */
 
-#ifndef __symbian__
 #ifndef __ARM_ARCH_6M__
 #include "ieee754-df.S"
 #include "ieee754-sf.S"
@@ -1523,4 +1753,3 @@ LSYM(Lchange_\register):
 #else /* __ARM_ARCH_6M__ */
 #include "bpabi-v6m.S"
 #endif /* __ARM_ARCH_6M__ */
-#endif /* !__symbian__ */
diff --git a/gcc/config/arm/libunwind.S b/gcc/config/arm/libunwind.S
index 800e7e0ca..45a97bcca 100644
--- a/gcc/config/arm/libunwind.S
+++ b/gcc/config/arm/libunwind.S
@@ -27,8 +27,6 @@
 .previous
 #endif
 
-#ifndef __symbian__
-
 #include "lib1funcs.asm"
 
 .macro UNPREFIX name
@@ -348,5 +346,3 @@ UNWIND_WRAPPER _Unwind_Resume 1
 UNWIND_WRAPPER _Unwind_Resume_or_Rethrow 1
 UNWIND_WRAPPER _Unwind_ForcedUnwind 3
 UNWIND_WRAPPER _Unwind_Backtrace 2
-
-#endif  /* ndef __symbian__ */
diff --git a/gcc/config/arm/linux-eabi.h b/gcc/config/arm/linux-eabi.h
index 62b0490ee..c85760c46 100644
--- a/gcc/config/arm/linux-eabi.h
+++ b/gcc/config/arm/linux-eabi.h
@@ -61,27 +61,23 @@
 /* Use ld-linux.so.3 so that it will be possible to run "classic"
    GNU/Linux binaries on an EABI system.  */
 #undef  GLIBC_DYNAMIC_LINKER
-#define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.3"
+#define GLIBC_DYNAMIC_LINKER_SOFT_FLOAT "/lib/ld-linux.so.3"
+#define GLIBC_DYNAMIC_LINKER_HARD_FLOAT "/lib/ld-linux-armhf.so.3"
+#define GLIBC_DYNAMIC_LINKER \
+   "%{mfloat-abi=hard:" GLIBC_DYNAMIC_LINKER_HARD_FLOAT "} \
+    %{!mfloat-abi=hard:" GLIBC_DYNAMIC_LINKER_SOFT_FLOAT "}"
 
 /* At this point, bpabi.h will have clobbered LINK_SPEC.  We want to
    use the GNU/Linux version, not the generic BPABI version.  */
 #undef  LINK_SPEC
-#define LINK_SPEC LINUX_TARGET_LINK_SPEC
+#define LINK_SPEC LINUX_TARGET_LINK_SPEC BE8_LINK_SPEC
 
 /* Use the default LIBGCC_SPEC, not the version in linux-elf.h, as we
    do not use -lfloat.  */
 #undef LIBGCC_SPEC
 
-/* Clear the instruction cache from `beg' to `end'.  This makes an
-   inline system call to SYS_cacheflush.  */
+/* Clear the instruction cache from `beg' to `end'.  This is
+   implemented in lib1funcs.asm, so ensure an error if this definition
+   is used.  */
 #undef  CLEAR_INSN_CACHE
-#define CLEAR_INSN_CACHE(BEG, END)					\
-{									\
-  register unsigned long _beg __asm ("a1") = (unsigned long) (BEG);	\
-  register unsigned long _end __asm ("a2") = (unsigned long) (END);	\
-  register unsigned long _flg __asm ("a3") = 0;				\
-  register unsigned long _scno __asm ("r7") = 0xf0002;			\
-  __asm __volatile ("swi 0		@ sys_cacheflush"		\
-		    : "=r" (_beg)					\
-		    : "0" (_beg), "r" (_end), "r" (_flg), "r" (_scno));	\
-}
+#define CLEAR_INSN_CACHE(BEG, END) not used
diff --git a/gcc/config/arm/linux-elf.h b/gcc/config/arm/linux-elf.h
index 07455ee87..9fdca414e 100644
--- a/gcc/config/arm/linux-elf.h
+++ b/gcc/config/arm/linux-elf.h
@@ -98,7 +98,7 @@
 
 /* NWFPE always understands FPA instructions.  */
 #undef  FPUTYPE_DEFAULT
-#define FPUTYPE_DEFAULT FPUTYPE_FPA_EMU3
+#define FPUTYPE_DEFAULT "fpe3"
 
 /* Call the function profiler with a given profile label.  */
 #undef  ARM_FUNCTION_PROFILER
diff --git a/gcc/config/arm/marvell-f-vfp.md b/gcc/config/arm/marvell-f-vfp.md
new file mode 100644
index 000000000..2ffd34d7a
--- /dev/null
+++ b/gcc/config/arm/marvell-f-vfp.md
@@ -0,0 +1,153 @@
+;; Marvell 2850 VFP pipeline description
+;; Copyright (C) 2007 Free Software Foundation, Inc.
+;; Written by CodeSourcery, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+;; Boston, MA 02110-1301, USA.
+
+;; This automaton provides a pipeline description for the Marvell
+;; 2850 core.
+;;
+;; The model given here assumes that the condition for all conditional
+;; instructions is "true", i.e., that all of the instructions are
+;; actually executed.
+
+(define_automaton "marvell_f_vfp")
+
+;; This is a single-issue VFPv2 implementation with the following execution
+;; units:
+;;
+;; 1. Addition/subtraction unit; takes three cycles, pipelined.
+;; 2. Multiplication unit; takes four cycles, pipelined.
+;; 3. Add buffer, used for multiply-accumulate (see below).
+;; 4. Divide/square root unit, not pipelined.
+;;    For single-precision: takes sixteen cycles, can accept another insn
+;;			    after fifteen cycles.
+;;    For double-precision: takes thirty-one cycles, can accept another insn
+;;			    after thirty cycles.
+;; 5. Single-cycle unit, pipelined.
+;;    This does absolute value/copy/negate/compare in one cycle and
+;;    conversion in two cycles.
+;;
+;; When all three operands of a multiply-accumulate instruction are ready,
+;; one is issued to the add buffer (which can hold six operands in a FIFO)
+;; and the two to be multiplied are issued to the multiply unit.  After
+;; four cycles in the multiply unit, one cycle is taken to issue the
+;; operand from the add buffer plus the multiplication result to the
+;; addition/subtraction unit.  That issue takes priority over any add/sub
+;; instruction waiting at the normal issue stage, but may be performed in
+;; parallel with the issue of a non-add/sub instruction.  The total time
+;; for a multiply-accumulate instruction to pass through the execution
+;; units is hence eight cycles.
+;;
+;; We do not need to explicitly model the add buffer because it can
+;; always issue the instruction at the head of its FIFO (due to the above
+;; priority rule) and there are more spaces in the add buffer (six) than
+;; there are stages (four) in the multiplication unit.
+;;
+;; Two instructions may be retired at once from the head of an 8-entry
+;; reorder buffer.  Data from these first two instructions only may be
+;; forwarded to the inputs of the issue unit.  We assume that the
+;; pressure on the reorder buffer will be sufficiently low that every
+;; instruction entering it will be eligible for data forwarding.  Since
+;; data is forwarded to the issue unit and not the execution units (so
+;; for example single-cycle instructions cannot be issued back-to-back),
+;; the latencies given below are the cycle counts above plus one.
+
+(define_cpu_unit "mf_vfp_issue" "marvell_f_vfp")
+(define_cpu_unit "mf_vfp_add" "marvell_f_vfp")
+(define_cpu_unit "mf_vfp_mul" "marvell_f_vfp")
+(define_cpu_unit "mf_vfp_div" "marvell_f_vfp")
+(define_cpu_unit "mf_vfp_single_cycle" "marvell_f_vfp")
+
+;; An attribute to indicate whether our reservations are applicable.
+
+(define_attr "marvell_f_vfp" "yes,no"
+  (const (if_then_else (and (eq_attr "tune" "marvell_f")
+                            (eq_attr "fpu" "vfp"))
+                       (const_string "yes") (const_string "no"))))
+
+;; Reservations of functional units.  The nothing*2 reservations at the
+;; start of many of the reservation strings correspond to the decode
+;; stages.  We need to have these reservations so that we can correctly
+;; reserve parts of the core's A1 pipeline for loads and stores.  For
+;; that case (since loads skip E1) the pipelines line up thus:
+;;	A1 pipe:	Issue	E2	OF	WR	WB	 ...
+;;	VFP pipe:	Fetch	Decode1	Decode2	Issue	Execute1 ...
+;; For a load, we need to make a reservation of E2, and thus we must
+;; use Decode1 as the starting point for all VFP reservations here.
+;;
+;; For reservations of pipelined VFP execution units we only reserve
+;; the execution unit for the first execution cycle, omitting any trailing
+;; "nothing" reservations.
+
+(define_insn_reservation "marvell_f_vfp_add" 4
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "farith"))
+  "nothing*2,mf_vfp_issue,mf_vfp_add")
+
+(define_insn_reservation "marvell_f_vfp_mul" 5
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "fmuls,fmuld"))
+  "nothing*2,mf_vfp_issue,mf_vfp_mul")
+
+(define_insn_reservation "marvell_f_vfp_divs" 17
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "fdivs"))
+  "nothing*2,mf_vfp_issue,mf_vfp_div*15")
+
+(define_insn_reservation "marvell_f_vfp_divd" 32
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "fdivd"))
+  "nothing*2,mf_vfp_issue,mf_vfp_div*30")
+
+;; The DFA lookahead is small enough that the "add" reservation here
+;; will always take priority over any addition/subtraction instruction
+;; issued five cycles after the multiply-accumulate instruction, as
+;; required.
+(define_insn_reservation "marvell_f_vfp_mac" 9
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "fmacs,fmacd"))
+  "nothing*2,mf_vfp_issue,mf_vfp_mul,nothing*4,mf_vfp_add")
+
+(define_insn_reservation "marvell_f_vfp_single" 2
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "ffarith"))
+  "nothing*2,mf_vfp_issue,mf_vfp_single_cycle")
+
+(define_insn_reservation "marvell_f_vfp_convert" 3
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "f_cvt"))
+  "nothing*2,mf_vfp_issue,mf_vfp_single_cycle")
+
+(define_insn_reservation "marvell_f_vfp_load" 2
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "f_loads,f_loadd"))
+  "a1_e2+sram,a1_of,a1_wr+mf_vfp_issue,a1_wb+mf_vfp_single_cycle")
+
+(define_insn_reservation "marvell_f_vfp_from_core" 2
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "r_2_f"))
+  "a1_e2,a1_of,a1_wr+mf_vfp_issue,a1_wb+mf_vfp_single_cycle")
+
+;; The interaction between the core and VFP pipelines during VFP
+;; store operations and core <-> VFP moves is not clear, so we guess.
+(define_insn_reservation "marvell_f_vfp_store" 3
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "f_stores,f_stored"))
+  "a1_e2,a1_of,mf_vfp_issue,a1_wr+sram+mf_vfp_single_cycle")
+
+(define_insn_reservation "marvell_f_vfp_to_core" 4
+  (and (eq_attr "marvell_f_vfp" "yes")
+       (eq_attr "type" "f_2_r"))
+  "a1_e2,a1_of,a1_wr+mf_vfp_issue,a1_wb+mf_vfp_single_cycle")
+
diff --git a/gcc/config/arm/marvell-f.md b/gcc/config/arm/marvell-f.md
new file mode 100644
index 000000000..ffd3ca173
--- /dev/null
+++ b/gcc/config/arm/marvell-f.md
@@ -0,0 +1,365 @@
+;; Marvell 2850 pipeline description
+;; Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
+;; Written by Marvell and CodeSourcery, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 2, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+;; Boston, MA 02110-1301, USA.
+
+;; This automaton provides a pipeline description for the Marvell
+;; 2850 core.
+;;
+;; The model given here assumes that the condition for all conditional
+;; instructions is "true", i.e., that all of the instructions are
+;; actually executed.
+
+(define_automaton "marvell_f")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Pipelines
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; This is a dual-issue processor with three pipelines:
+;;
+;; 1. Arithmetic and load/store pipeline A1.
+;;    Issue | E1 | E2 | OF | WR | WB  for load-store instructions
+;;    Issue | E1 | E2 | WB  for arithmetic instructions
+;;
+;; 2. Arithmetic pipeline A2.
+;;    Issue | E1 | E2 | WB
+;;
+;; 3. Multiply and multiply-accumulate pipeline.
+;;    Issue | MAC1 | MAC2 | MAC3 | WB
+;;
+;; There are various bypasses modelled to a greater or lesser extent.
+;;
+;; Latencies in this file correspond to the number of cycles after
+;; the issue stage that it takes for the result of the instruction to
+;; be computed, or for its side-effects to occur.
+
+(define_cpu_unit "a1_e1,a1_e2,a1_of,a1_wr,a1_wb" "marvell_f") ; ALU 1
+(define_cpu_unit "a2_e1,a2_e2,a2_wb" "marvell_f")             ; ALU 2
+(define_cpu_unit "m_1,m_2,m_3,m_wb" "marvell_f")              ; MAC
+
+;; We define an SRAM cpu unit to enable us to describe conflicts
+;; between loads at the E2 stage and stores at the WR stage.
+
+(define_cpu_unit "sram" "marvell_f")
+
+;; Handling of dual-issue constraints.
+;;
+;; Certain pairs of instructions can be issued in parallel, and certain
+;; pairs cannot.  We divide a subset of the instructions into groups as
+;; follows.
+;;
+;; - data processing 1 (mov, mvn);
+;; - data processing 2 (adc, add, and, bic, cmn, cmp, eor, orr, rsb,
+;;                      rsc, sbc, sub, teq, tst);
+;; - load single (ldr, ldrb, ldrbt, ldrt, ldrh, ldrsb, ldrsh);
+;; - store single (str, strb, strbt, strt, strh);
+;; - swap (swp, swpb);
+;; - pld;
+;; - count leading zeros and DSP add/sub (clz, qadd, qdadd, qsub, qdsub);
+;; - multiply 2 (mul, muls, smull, umull, smulxy, smulls, umulls);
+;; - multiply 3 (mla, mlas, smlal, umlal, smlaxy, smlalxy, smlawx,
+;;               smlawy, smlals, umlals);
+;; - branches (b, bl, blx, bx).
+;;
+;; Ignoring conditional execution, it is a good approximation to the core
+;; to model that two instructions may only be issued in parallel if the
+;; following conditions are met.
+;; I.   The instructions both fall into one of the above groups and their
+;;      corresponding groups have a entry in the matrix below that is not X.
+;; II.  The second instruction does not read any register updated by the
+;;      first instruction (already enforced by the GCC scheduler).
+;; III. The second instruction does not need the carry flag updated by the
+;;      first instruction.  Currently we do not model this.
+;;
+;; First	Second instruction group
+;; insn
+;;		DP1  DP2  L    S    SWP  PLD  CLZ  M2   M3   B
+;;
+;;	DP1	ok   ok   ok   ok   ok   ok   ok   ok   ok   ok
+;;	DP2(1)  ok   ok   ok   ok   ok   ok   ok   ok   ok   ok
+;;	DP2(2)  ok   (2)  ok   (4)  ok   ok   ok   ok   X    ok
+;;	L   }
+;;	SWP }   ok   ok   X    X    X    X    ok   ok   ok   ok
+;;	PLD }
+;;      S(3)	ok   ok   X    X    X    X    ok   ok   ok   ok
+;;      S(4)	ok   (2)  X    X    X    X    ok   ok   X    ok
+;;	CLZ     ok   ok   ok   ok   ok   ok   ok   ok   ok   ok
+;;	M2	ok   ok   ok   ok   ok   ok   ok   X    X    ok
+;;	M3	ok   (2)  ok   (4)  ok   ok   ok   X    X    ok
+;;	B	ok   ok   ok   ok   ok   ok   ok   ok   ok   ok
+;;
+;; (1) without register shift
+;; (2) with register shift
+;; (3) with immediate offset
+;; (4) with register offset
+;;
+;; We define a fake cpu unit "reg_shift_lock" to enforce constraints
+;; between instructions in groups DP2(2) and M3.  All other
+;; constraints are enforced automatically by virtue of the limited
+;; number of pipelines available for the various operations, with
+;; the exception of constraints involving S(4) that we do not model.
+
+(define_cpu_unit "reg_shift_lock" "marvell_f")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; ALU instructions
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; 1. Certain logic operations can be retired after the E1 stage if
+;; the pipeline is not already retiring another instruction.  In this
+;; model we assume this behaviour always holds for mov, mvn, and, orr, eor
+;; instructions.  If a register shift is involved and the instruction is
+;; not mov or mvn, then a dual-issue constraint must be enforced.
+
+;; The first two cases are separate so they can be identified for
+;; bypasses below.
+
+(define_insn_reservation "marvell_f_alu_early_retire" 1
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu")
+            (eq_attr "insn" "mov,mvn,and,orr,eor")))
+  "(a1_e1,a1_wb)|(a2_e1,a2_wb)")
+
+(define_insn_reservation "marvell_f_alu_early_retire_shift" 1
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu_shift_reg")
+            (eq_attr "insn" "mov,mvn,and,orr,eor")))
+  "(a1_e1,a1_wb)|(a2_e1,a2_wb)")
+
+(define_insn_reservation "marvell_f_alu_early_retire_reg_shift1" 1
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu_shift_reg")
+            (eq_attr "insn" "mov,mvn")))
+  "(a1_e1,a1_wb)|(a2_e1,a2_wb)")
+
+(define_insn_reservation "marvell_f_alu_early_retire_reg_shift2" 1
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu_shift_reg")
+            (eq_attr "insn" "and,orr,eor")))
+  "(reg_shift_lock+a1_e1,a1_wb)|(reg_shift_lock+a2_e1,a2_wb)")
+
+;; 2. ALU operations with no shifted operand.  These bypass the E1 stage if
+;; the E2 stage of the corresponding pipeline is clear; here, we always
+;; model this scenario [*].  We give the operation a latency of 1 yet reserve
+;; both E1 and E2 for it (thus preventing the GCC scheduler, in the case
+;; where both E1 and E2 of one pipeline are clear, from issuing one
+;; instruction to each).
+;;
+;; [*] The non-bypass case is a latency of two, reserving E1 on the first
+;;     cycle and E2 on the next.  Due to the way the scheduler works we
+;;     have to choose between taking this as the default and taking the
+;;     above case (with latency one) as the default; we choose the latter.
+
+(define_insn_reservation "marvell_f_alu_op_bypass_e1" 1
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu")
+            (not (eq_attr "insn" "mov,mvn,and,orr,eor"))))
+  "(a1_e1+a1_e2,a1_wb)|(a2_e1+a2_e2,a2_wb)")
+
+;; 3. ALU operations with a shift-by-constant operand.
+
+(define_insn_reservation "marvell_f_alu_shift_op" 2
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu_shift")
+            (not (eq_attr "insn" "mov,mvn,and,orr,eor"))))
+  "(a1_e1,a1_e2,a1_wb)|(a2_e1,a2_e2,a2_wb)")
+
+;; 4. ALU operations with a shift-by-register operand.  Since the
+;; instruction is never mov or mvn, a dual-issue constraint must
+;; be enforced.
+
+(define_insn_reservation "marvell_f_alu_shift_reg_op" 2
+  (and (eq_attr "tune" "marvell_f")
+       (and (eq_attr "type" "alu_shift_reg")
+            (not (eq_attr "insn" "mov,mvn,and,orr,eor"))))
+  "(reg_shift_lock+a1_e1,a1_e2,a1_wb)|(reg_shift_lock+a2_e1,a2_e2,a2_wb)")
+
+;; Given an ALU operation with shift (I1) followed by another ALU
+;; operation (I2), with I2 depending on the destination register Rd of I1
+;; and with I2 not using that value as the amount or the starting value for
+;; a shift, then I1 and I2 may be issued to the same pipeline on
+;; consecutive cycles.  In terms of this model that corresponds to I1
+;; having a latency of one cycle.  There are three cases for various
+;; I1 and I2 as follows.
+
+;; (a) I1 has a constant or register shift and I2 doesn't have a shift at all.
+(define_bypass 1 "marvell_f_alu_shift_op,\
+	          marvell_f_alu_shift_reg_op"
+	       "marvell_f_alu_op_bypass_e1,marvell_f_alu_early_retire")
+
+;; (b) I1 has a constant or register shift and I2 has a constant shift.
+;; Rd must not provide the starting value for the shift.
+(define_bypass 1 "marvell_f_alu_shift_op,\
+	          marvell_f_alu_shift_reg_op"
+	       "marvell_f_alu_shift_op,marvell_f_alu_early_retire_shift"
+	       "arm_no_early_alu_shift_value_dep")
+
+;; (c) I1 has a constant or register shift and I2 has a register shift.
+;; Rd must not provide the amount by which to shift.
+(define_bypass 1 "marvell_f_alu_shift_op,\
+	          marvell_f_alu_shift_reg_op"
+	       "marvell_f_alu_shift_reg_op,\
+	        marvell_f_alu_early_retire_reg_shift1,\
+	        marvell_f_alu_early_retire_reg_shift2"
+	       "arm_no_early_alu_shift_dep")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Multiplication instructions
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; Multiplication instructions in group "Multiply 2".
+
+(define_insn_reservation "marvell_f_multiply_2" 3
+  (and (eq_attr "tune" "marvell_f")
+       (eq_attr "insn" "mul,muls,smull,umull,smulxy,smulls,umulls"))
+  "m_1,m_2,m_3,m_wb")
+
+;; Multiplication instructions in group "Multiply 3".  There is a
+;; dual-issue constraint with non-multiplication ALU instructions
+;; to be respected here.
+
+(define_insn_reservation "marvell_f_multiply_3" 3
+  (and (eq_attr "tune" "marvell_f")
+       (eq_attr "insn" "mla,mlas,smlal,umlal,smlaxy,smlalxy,smlawx,\
+                        smlawy,smlals,umlals"))
+  "reg_shift_lock+m_1,m_2,m_3,m_wb")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Branch instructions
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; Conditional backward b instructions can have a zero-cycle penalty, and
+;; other conditional b and bl instructions have a one-cycle penalty if
+;; predicted correctly.  Currently we model the zero-cycle case for all
+;; branches.
+
+(define_insn_reservation "marvell_f_branches" 0
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "branch"))
+ "nothing")
+
+;; Call latencies are not predictable; a semi-arbitrary very large
+;; number is used as "positive infinity" for such latencies.
+
+(define_insn_reservation "marvell_f_call" 32 
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "call"))
+ "nothing")
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Load/store instructions
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; The models for load/store instructions do not accurately describe
+;; the difference between operations with a base register writeback.
+;; These models assume that all memory references hit in dcache.
+
+;; 1. Load/store for single registers.
+
+;; The worst case for a load is when the load result is needed in E1
+;; (for example for a register shift), giving a latency of four.  Loads
+;; skip E1 and access memory at the E2 stage.
+
+(define_insn_reservation "marvell_f_load1" 4
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "load1,load_byte"))
+ "a1_e2+sram,a1_of,a1_wr,a1_wb")
+
+;; The result for a load may be bypassed (to be available at the same
+;; time as the load arrives in the WR stage, so effectively at the OF
+;; stage) to the Rn operand at E2 with a latency of two.  The result may
+;; be bypassed to a non-Rn operand at E2 with a latency of three.  For
+;; instructions without shifts, detection of an Rn bypass situation is
+;; difficult (because some of the instruction patterns switch their
+;; operands), and so we do not model that here.  For instructions with
+;; shifts, the operand used at E2 will always be Rn, and so we can
+;; model the latency-two bypass for these.
+
+(define_bypass 2 "marvell_f_load1"
+               "marvell_f_alu_shift_op"
+	       "arm_no_early_alu_shift_value_dep")
+
+(define_bypass 2 "marvell_f_load1"
+               "marvell_f_alu_shift_reg_op"
+	       "arm_no_early_alu_shift_dep")
+
+;; Stores write at the WR stage and loads read at the E2 stage, giving
+;; a store latency of three.
+
+(define_insn_reservation "marvell_f_store1" 3
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "store1"))
+ "a1_e2,a1_of,a1_wr+sram,a1_wb")
+
+;; 2. Load/store for two consecutive registers.  These may be dealt
+;; with in the same number of cycles as single loads and stores.
+
+(define_insn_reservation "marvell_f_load2" 4
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "load2"))
+ "a1_e2+sram,a1_of,a1_wr,a1_wb")
+
+(define_insn_reservation "marvell_f_store2" 3
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "store2"))
+ "a1_e2,a1_of,a1_wr+sram,a1_wb")
+
+;; The first word of a doubleword load is eligible for the latency-two
+;; bypass described above for single loads, but this is not modelled here.
+;; We do however assume that either word may also be bypassed with
+;; latency three for ALU operations with shifts (where the shift value and
+;; amount do not depend on the loaded value) and latency four for ALU
+;; operations without shifts.  The latency four case is of course the default.
+
+(define_bypass 3 "marvell_f_load2"
+               "marvell_f_alu_shift_op"
+	       "arm_no_early_alu_shift_value_dep")
+
+(define_bypass 3 "marvell_f_load2"
+               "marvell_f_alu_shift_reg_op"
+	       "arm_no_early_alu_shift_dep")
+
+;; 3. Load/store for more than two registers.
+
+;; These instructions stall for an extra cycle in the decode stage;
+;; individual load/store instructions for each register are then issued.
+;; The load/store multiple instruction itself is removed from the decode
+;; stage at the same time as the final load/store instruction is issued.
+;; To complicate matters, pairs of loads/stores referencing two
+;; consecutive registers will be issued together as doubleword operations.
+;; We model a 3-word load as an LDR plus an LDRD, and a 4-word load
+;; as two LDRDs; thus, these are allocated the same latencies (the
+;; latency for two consecutive loads plus one for the setup stall).
+;; The extra stall is modelled by reserving E1.
+
+(define_insn_reservation "marvell_f_load3_4" 6
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "load3,load4"))
+ "a1_e1,a1_e1+a1_e2+sram,a1_e2+sram+a1_of,a1_of+a1_wr,a1_wr+a1_wb,a1_wb")
+
+;; Bypasses are possible for ldm as for single loads, but we do not
+;; model them here since the order of the constituent loads is
+;; difficult to predict.
+
+(define_insn_reservation "marvell_f_store3_4" 5
+ (and (eq_attr "tune" "marvell_f")
+      (eq_attr "type" "store3,store4"))
+ "a1_e1,a1_e1+a1_e2,a1_e2+a1_of,a1_of+a1_wr+sram,a1_wr+sram+a1_wb,a1_wb")
+
diff --git a/gcc/config/arm/mingw32.h b/gcc/config/arm/mingw32.h
new file mode 100644
index 000000000..0b3c8550d
--- /dev/null
+++ b/gcc/config/arm/mingw32.h
@@ -0,0 +1,140 @@
+/* Operating system specific defines to be used when targeting GCC for
+   hosting on Windows CE, using GNU tools and the Windows32 API Library.
+   Copyright (C) 2006
+   Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#undef TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (arm MinGW)"); 
+
+#undef EXTRA_OS_CPP_BUILTINS
+#define EXTRA_OS_CPP_BUILTINS()					\
+  do								\
+    {								\
+      builtin_define ("_WIN32");				\
+      builtin_define_std ("WIN32");				\
+      builtin_define_std ("WINNT");				\
+    }								\
+  while (0)
+
+#undef STANDARD_INCLUDE_DIR
+#define STANDARD_INCLUDE_DIR "/mingw/include"
+
+#undef CPP_SPEC
+#define CPP_SPEC "%{posix:-D_POSIX_SOURCE} %{mthreads:-D_MT} \
+-D__COREDLL__ -D__MINGW32__ -D__MINGW32CE__ -D__CEGCC_VERSION__ \
+%{!nostdinc: -idirafter ../include/w32api%s -idirafter ../../include/w32api%s }"
+
+#undef LIB_SPEC
+#define LIB_SPEC "%{pg:-lgmon} -lcoredll"
+
+/* Include in the mingw32 libraries with libgcc */
+#undef LINK_SPEC
+#define LINK_SPEC "%{shared|mdll: --shared} \
+  %{static:-Bstatic} %{!static:-Bdynamic} \
+  %{shared|mdll: -e DllMainCRTStartup}"
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "%{shared|mdll:dllcrt3%O%s} \
+  %{!shared:%{!mdll:crt3%O%s}} %{pg:gcrt3%O%s}"
+
+/* Override startfile prefix defaults.  */
+#ifndef STANDARD_STARTFILE_PREFIX_1
+#define STANDARD_STARTFILE_PREFIX_1 "/mingw/lib/"
+#endif
+#ifndef STANDARD_STARTFILE_PREFIX_2
+#define STANDARD_STARTFILE_PREFIX_2 ""
+#endif
+
+/* Output STRING, a string representing a filename, to FILE.
+   We canonicalize it to be in Unix format (backslashes are replaced
+   forward slashes.  */
+#undef OUTPUT_QUOTED_STRING
+#define OUTPUT_QUOTED_STRING(FILE, STRING)               \
+do {						         \
+  char c;					         \
+						         \
+  putc ('\"', asm_file);			         \
+						         \
+  while ((c = *string++) != 0)			         \
+    {						         \
+      if (c == '\\')				         \
+	c = '/';				         \
+						         \
+      if (ISPRINT (c))                                   \
+        {                                                \
+          if (c == '\"')			         \
+	    putc ('\\', asm_file);		         \
+          putc (c, asm_file);			         \
+        }                                                \
+      else                                               \
+        fprintf (asm_file, "\\%03o", (unsigned char) c); \
+    }						         \
+						         \
+  putc ('\"', asm_file);			         \
+} while (0)
+
+/*
+ * See the message from Dave Korn dated 2009/06/01 15:44 on the cegcc mailing
+ * list, and the gcc ChangeLog entry dated 2009-01-21, also by Dave.
+ *
+ * Based on that, we're replacing LIBGCC_SPEC by SHARED_LIBGCC_SPEC and
+ * REAL_GCC_SPEC. This is based on cygwin's definition, which we extend
+ * with the other libraries we need.
+ *
+ * The old definition :
+  "%{mthreads:-lmingwthrd} -lmingw32 -lgcc -lceoldname -lmingwex -lcoredll"
+ *
+ */
+#undef LIBGCC_SPEC
+
+#undef SHARED_LIBGCC_SPEC
+#ifdef ENABLE_SHARED_LIBGCC
+#define SHARED_LIBGCC_SPEC " \
+ %{mthreads:-lmingwthrd} -lmingw32 \
+ %{static|static-libgcc:-lgcc -lgcc_eh} \
+ %{!static: \
+   %{!static-libgcc: \
+     %{!shared: \
+       %{!shared-libgcc:-lgcc -lgcc_eh} \
+       %{shared-libgcc:-lgcc_s -lgcc} \
+      } \
+     %{shared:-lgcc_s -lgcc} \
+    } \
+  } \
+  -lceoldname -lmingwex -lcoredll"
+#else
+#define SHARED_LIBGCC_SPEC \
+  "%{mthreads:-lmingwthrd} -lmingw32 -lgcc -lceoldname -lmingwex -lcoredll"
+#endif
+
+#undef REAL_LIBGCC_SPEC
+#define REAL_LIBGCC_SPEC SHARED_LIBGCC_SPEC
+
+/* On mingw32ce, the reference chain goes like
+   WinMainCRTStartup(entry)->WinMain->main.  So,
+   libgfortranbegin.a(fmain.o:main) must be seen after
+   libmingw.a(WinMain).  */
+#define FORTRAN_INIT "-Wl,-lmingw32,-lgfortranbegin"
+
+/* Only include windows.h when needed, to avoid conflicts with
+   fp-bit.c in the definition of FLOAT.  */
+#if defined(IN_LIBGCC2) && (defined(L_trampoline))
+# define WIN32_LEAN_AND_MEAN
+# include <windows.h>
+#endif
diff --git a/gcc/config/arm/montavista-linux.h b/gcc/config/arm/montavista-linux.h
new file mode 100644
index 000000000..e5c172bb8
--- /dev/null
+++ b/gcc/config/arm/montavista-linux.h
@@ -0,0 +1,33 @@
+/* MontaVista GNU/Linux Configuration.
+   Copyright (C) 2009
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Add -tarmv6 and -tthumb2 options for convenience in generating multilibs.
+*/
+#undef CC1_SPEC
+#define CC1_SPEC "							\
+ %{tarmv6:      -march=armv6 -mfloat-abi=softfp ;			\
+   tthumb2:     -mthumb -march=armv7-a -mfloat-abi=softfp ;             \
+   :            -march=armv5t}"
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC					\
+  "%{tarmv6:/armv6 ;			                        \
+     tthumb2:/thumb2}"
diff --git a/gcc/config/arm/msformat-c.c b/gcc/config/arm/msformat-c.c
new file mode 100644
index 000000000..4648c8d58
--- /dev/null
+++ b/gcc/config/arm/msformat-c.c
@@ -0,0 +1,197 @@
+/* Check calls to formatted I/O functions (-Wformat).
+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+   2001, 2002, 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "flags.h"
+#include "c-common.h"
+#include "toplev.h"
+#include "intl.h"
+#include "diagnostic.h"
+#include "langhooks.h"
+#include "c-format.h"
+#include "alloc-pool.h"
+
+/* Mingw specific format attributes ms_printf, ms_scanf, and ms_strftime.  */
+
+static format_length_info ms_printf_length_specs[] =
+{
+  { "h", FMT_LEN_h, STD_C89, NULL, 0, 0 },
+  { "l", FMT_LEN_l, STD_C89, NULL, 0, 0 },
+  { "I32", FMT_LEN_l, STD_EXT, NULL, 0, 0 },
+  { "I64", FMT_LEN_ll, STD_EXT, NULL, 0, 0 },
+  { "I", FMT_LEN_L, STD_EXT, NULL, 0, 0 },
+  { NULL, 0, 0, NULL, 0, 0 }
+};
+
+static const format_flag_spec ms_printf_flag_specs[] =
+{
+  { ' ',  0, 0, N_("' ' flag"),        N_("the ' ' printf flag"),              STD_C89 },
+  { '+',  0, 0, N_("'+' flag"),        N_("the '+' printf flag"),              STD_C89 },
+  { '#',  0, 0, N_("'#' flag"),        N_("the '#' printf flag"),              STD_C89 },
+  { '0',  0, 0, N_("'0' flag"),        N_("the '0' printf flag"),              STD_C89 },
+  { '-',  0, 0, N_("'-' flag"),        N_("the '-' printf flag"),              STD_C89 },
+  { '\'', 0, 0, N_("''' flag"),        N_("the ''' printf flag"),              STD_EXT },
+  { 'w',  0, 0, N_("field width"),     N_("field width in printf format"),     STD_C89 },
+  { 'p',  0, 0, N_("precision"),       N_("precision in printf format"),       STD_C89 },
+  { 'L',  0, 0, N_("length modifier"), N_("length modifier in printf format"), STD_C89 },
+  { 0, 0, 0, NULL, NULL, 0 }
+};
+
+static const format_flag_pair ms_printf_flag_pairs[] =
+{
+  { ' ', '+', 1, 0   },
+  { '0', '-', 1, 0   }, { '0', 'p', 1, 'i' },
+  { 0, 0, 0, 0 }
+};
+
+static const format_flag_spec ms_scanf_flag_specs[] =
+{
+  { '*',  0, 0, N_("assignment suppression"), N_("the assignment suppression scanf feature"), STD_C89 },
+  { 'a',  0, 0, N_("'a' flag"),               N_("the 'a' scanf flag"),                       STD_EXT },
+  { 'w',  0, 0, N_("field width"),            N_("field width in scanf format"),              STD_C89 },
+  { 'L',  0, 0, N_("length modifier"),        N_("length modifier in scanf format"),          STD_C89 },
+  { '\'', 0, 0, N_("''' flag"),               N_("the ''' scanf flag"),                       STD_EXT },
+  { 0, 0, 0, NULL, NULL, 0 }
+};
+
+static const format_flag_pair ms_scanf_flag_pairs[] =
+{
+  { '*', 'L', 0, 0 },
+  { 0, 0, 0, 0 }
+};
+
+static const format_flag_spec ms_strftime_flag_specs[] =
+{
+  { '#', 0,   0, N_("'#' flag"),     N_("the '#' strftime flag"),          STD_EXT },
+  { 0, 0, 0, NULL, NULL, 0 }
+};
+
+static const format_flag_pair ms_strftime_flag_pairs[] =
+{
+  { 0, 0, 0, 0 }
+};
+
+static const format_char_info ms_print_char_table[] =
+{
+  /* C89 conversion specifiers.  */
+  { "di",  0, STD_C89, { T89_I,   BADLEN,  T89_S,   T89_L,   T9L_LL,  T99_SST,  BADLEN, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, "-wp0 +'",  "i",  NULL },
+  { "oxX", 0, STD_C89, { T89_UI,  BADLEN,  T89_US,  T89_UL,  T9L_ULL, T99_ST, BADLEN, BADLEN, BADLEN, BADLEN,  BADLEN,  BADLEN }, "-wp0#",     "i",  NULL },
+  { "u",   0, STD_C89, { T89_UI,  BADLEN,  T89_US,  T89_UL,  T9L_ULL, T99_ST, BADLEN, BADLEN, BADLEN, BADLEN,  BADLEN,  BADLEN }, "-wp0'",    "i",  NULL },
+  { "fgG", 0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN, BADLEN, BADLEN }, "-wp0 +#'", "",   NULL },
+  { "eE",  0, STD_C89, { T89_D,   BADLEN,  BADLEN,  T99_D,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN, BADLEN, BADLEN }, "-wp0 +#",  "",   NULL },
+  { "c",   0, STD_C89, { T89_I,   BADLEN,  T89_S,  T94_WI,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "-w",        "",   NULL },
+  { "s",   1, STD_C89, { T89_C,   BADLEN,  T89_S,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "-wp",       "cR", NULL },
+  { "p",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "-w",        "c",  NULL },
+  { "n",   1, STD_C89, { T89_I,   BADLEN,  T89_S,   T89_L,   T9L_LL,  BADLEN,  BADLEN, BADLEN,  T99_IM,  BADLEN,  BADLEN,  BADLEN }, "",          "W",  NULL },
+  /* X/Open conversion specifiers.  */
+  { "C",   0, STD_EXT, { TEX_WI,  BADLEN,  T89_S,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "-w",        "",   NULL },
+  { "S",   1, STD_EXT, { TEX_W,   BADLEN,  T89_S,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "-wp",       "R",  NULL },
+  { NULL,  0, 0, NOLENGTHS, NULL, NULL, NULL }
+};
+
+static const format_char_info ms_scan_char_table[] =
+{
+  /* C89 conversion specifiers.  */
+  { "di",    1, STD_C89, { T89_I,   BADLEN,  T89_S,   T89_L,   T9L_LL,  T99_SST,  BADLEN, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "*w'", "W",   NULL },
+  { "u",     1, STD_C89, { T89_UI,  BADLEN,  T89_US,  T89_UL,  T9L_ULL, T99_ST, BADLEN,  BADLEN, BADLEN, BADLEN,  BADLEN,  BADLEN }, "*w'", "W",   NULL },
+  { "oxX",   1, STD_C89, { T89_UI,  BADLEN,  T89_US,  T89_UL,  T9L_ULL, T99_ST, BADLEN,  BADLEN, BADLEN, BADLEN,  BADLEN,  BADLEN }, "*w",   "W",   NULL },
+  { "efgEG", 1, STD_C89, { T89_F,   BADLEN,  BADLEN,  T89_D,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN, BADLEN, BADLEN }, "*w'",  "W",   NULL },
+  { "c",     1, STD_C89, { T89_C,   BADLEN,  T89_S,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "*w",   "cW",  NULL },
+  { "s",     1, STD_C89, { T89_C,   BADLEN,  T89_S,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "*aw",  "cW",  NULL },
+  { "[",     1, STD_C89, { T89_C,   BADLEN,  BADLEN,  T94_W,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "*aw",  "cW[", NULL },
+  { "p",     2, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "*w",   "W",   NULL },
+  { "n",     1, STD_C89, { T89_I,   BADLEN,  T89_S,   T89_L,   T9L_LL,  BADLEN,  BADLEN, BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "",     "W",   NULL },
+  /* X/Open conversion specifiers.  */
+  { "C",     1, STD_EXT, { TEX_W,   BADLEN,  T89_S,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "*w",   "W",   NULL },
+  { "S",     1, STD_EXT, { TEX_W,   BADLEN,  T89_S,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN }, "*aw",  "W",   NULL },
+  { NULL, 0, 0, NOLENGTHS, NULL, NULL, NULL }
+};
+
+static const format_char_info ms_time_char_table[] =
+{
+  /* C89 conversion specifiers.  */
+  { "ABZab",		0, STD_C89, NOLENGTHS, "#",     "",   NULL },
+  { "cx",		0, STD_C89, NOLENGTHS, "#",      "3",  NULL },
+  { "HIMSUWdmw",	0, STD_C89, NOLENGTHS, "#",  "",   NULL },
+  { "j",		0, STD_C89, NOLENGTHS, "#",  "",  NULL },
+  { "p",		0, STD_C89, NOLENGTHS, "#",      "",   NULL },
+  { "X",		0, STD_C89, NOLENGTHS, "#",      "",   NULL },
+  { "y",		0, STD_C89, NOLENGTHS, "#", "4",  NULL },
+  { "Y",		0, STD_C89, NOLENGTHS, "#", "",  NULL },
+  { "%",		0, STD_C89, NOLENGTHS, "",       "",   NULL },
+  /* C99 conversion specifiers.  */
+  { "z",		0, STD_C99, NOLENGTHS, "#",      "",  NULL },
+  { NULL,		0, 0, NOLENGTHS, NULL, NULL, NULL }
+};
+
+const format_kind_info mingw_format_attributes[3] =
+{
+  { "ms_printf",   ms_printf_length_specs,  ms_print_char_table, " +#0-'", NULL,
+    ms_printf_flag_specs, ms_printf_flag_pairs,
+    FMT_FLAG_ARG_CONVERT|FMT_FLAG_DOLLAR_MULTIPLE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_EMPTY_PREC_OK,
+    'w', 0, 'p', 0, 'L', 0,
+    &integer_type_node, &integer_type_node
+  },
+  { "ms_scanf",    ms_printf_length_specs,   ms_scan_char_table,  "*'", NULL,
+    ms_scanf_flag_specs, ms_scanf_flag_pairs,
+    FMT_FLAG_ARG_CONVERT|FMT_FLAG_SCANF_A_KLUDGE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_ZERO_WIDTH_BAD|FMT_FLAG_DOLLAR_GAP_POINTER_OK,
+    'w', 0, 0, '*', 'L', 0,
+    NULL, NULL
+  },
+  { "ms_strftime", NULL,                 ms_time_char_table,  "", "#",
+    ms_strftime_flag_specs, ms_strftime_flag_pairs,
+    FMT_FLAG_FANCY_PERCENT_OK, 0, 0, 0, 0, 0, 0,
+    NULL, NULL
+  }
+};
+
+/* Default overrides for printf, scanf and strftime.  */
+const target_ovr_attr mingw_format_attribute_overrides[4] =
+{
+  { "ms_printf", "printf" },
+  { "ms_scanf", "scanf" },
+  { "ms_strftime", "strftime" }
+};
+
+/* Setup for option Wpedantic-ms-format.  */
+
+#ifdef TARGET_OVERRIDES_FORMAT_INIT
+
+/* Make sure TARGET_OVERRIDES_FORMAT_INIT is prototyped.  */
+extern void TARGET_OVERRIDES_FORMAT_INIT (void);
+
+/* Helper.  */
+#define C89_OR_EXT (warn_pedantic_ms_format ? STD_EXT : STD_C89)
+
+void
+TARGET_OVERRIDES_FORMAT_INIT (void)
+{
+  ms_printf_length_specs[2].std = C89_OR_EXT; /* I32 */
+  ms_printf_length_specs[3].std = C89_OR_EXT; /* I64 */
+  ms_printf_length_specs[4].std = C89_OR_EXT; /* I */
+}
+
+#undef C89_OR_EXT
+
+#endif
diff --git a/gcc/config/arm/neon-docgen.ml b/gcc/config/arm/neon-docgen.ml
index b4802fdd2..23e37b498 100644
--- a/gcc/config/arm/neon-docgen.ml
+++ b/gcc/config/arm/neon-docgen.ml
@@ -214,6 +214,7 @@ let rec analyze_shape shape =
     | Element_of_dreg -> (analyze_shape_elt reg_no Dreg) ^ "[@var{0}]"
     | Element_of_qreg -> (analyze_shape_elt reg_no Qreg) ^ "[@var{0}]"
     | All_elements_of_dreg -> (analyze_shape_elt reg_no Dreg) ^ "[]"
+    | Alternatives alts -> (analyze_shape_elt reg_no (List.hd alts))
   in
     match shape with
       All (n, elt) -> commas (analyze_shape_elt 0) (n_things n elt) ""
diff --git a/gcc/config/arm/neon-gen.ml b/gcc/config/arm/neon-gen.ml
index 9c8e2a89b..ebcea464e 100644
--- a/gcc/config/arm/neon-gen.ml
+++ b/gcc/config/arm/neon-gen.ml
@@ -122,6 +122,7 @@ let rec signed_ctype = function
   | T_uint16 | T_int16 -> T_intHI
   | T_uint32 | T_int32 -> T_intSI
   | T_uint64 | T_int64 -> T_intDI
+  | T_float32 -> T_floatSF
   | T_poly8 -> T_intQI
   | T_poly16 -> T_intHI
   | T_arrayof (n, elt) -> T_arrayof (n, signed_ctype elt)
@@ -320,7 +321,7 @@ let deftypes () =
     typeinfo;
   Format.print_newline ();
   (* Extra types not in <stdint.h>.  *)
-  Format.printf "typedef __builtin_neon_sf float32_t;\n";
+  Format.printf "typedef float float32_t;\n";
   Format.printf "typedef __builtin_neon_poly8 poly8_t;\n";
   Format.printf "typedef __builtin_neon_poly16 poly16_t;\n"
 
@@ -399,7 +400,11 @@ let _ =
 "extern \"C\" {";
 "#endif";
 "";
+"#if defined (__vxworks) && defined (_WRS_KERNEL)";
+"#include <vxWorks.h>";
+"#else";
 "#include <stdint.h>";
+"#endif";
 ""];
   deftypes ();
   arrtypes ();
diff --git a/gcc/config/arm/neon-testgen.ml b/gcc/config/arm/neon-testgen.ml
index 3be139742..63fbbbf2c 100644
--- a/gcc/config/arm/neon-testgen.ml
+++ b/gcc/config/arm/neon-testgen.ml
@@ -51,8 +51,8 @@ let emit_prologue chan test_name =
   Printf.fprintf chan "/* This file was autogenerated by neon-testgen.  */\n\n";
   Printf.fprintf chan "/* { dg-do assemble } */\n";
   Printf.fprintf chan "/* { dg-require-effective-target arm_neon_ok } */\n";
-  Printf.fprintf chan
-                 "/* { dg-options \"-save-temps -O0 -mfpu=neon -mfloat-abi=softfp\" } */\n";
+  Printf.fprintf chan "/* { dg-options \"-save-temps -O0\" } */\n";
+  Printf.fprintf chan "/* { dg-add-options arm_neon } */\n";
   Printf.fprintf chan "\n#include \"arm_neon.h\"\n\n";
   Printf.fprintf chan "void test_%s (void)\n{\n" test_name
 
@@ -181,6 +181,7 @@ let rec analyze_shape shape =
     | Element_of_dreg -> (analyze_shape_elt Dreg) ^ "\\\\\\[\\[0-9\\]+\\\\\\]"
     | Element_of_qreg -> (analyze_shape_elt Qreg) ^ "\\\\\\[\\[0-9\\]+\\\\\\]"
     | All_elements_of_dreg -> (analyze_shape_elt Dreg) ^ "\\\\\\[\\\\\\]"
+    | Alternatives (elts) -> "(" ^ (String.concat "|" (List.map analyze_shape_elt elts)) ^ ")"
   in
     match shape with
       All (n, elt) -> commas analyze_shape_elt (n_things n elt) ""
diff --git a/gcc/config/arm/neon.md b/gcc/config/arm/neon.md
index 19699a9a8..d9d6d428b 100644
--- a/gcc/config/arm/neon.md
+++ b/gcc/config/arm/neon.md
@@ -22,17 +22,11 @@
 (define_constants
   [(UNSPEC_ASHIFT_SIGNED	65)
    (UNSPEC_ASHIFT_UNSIGNED	66)
-   (UNSPEC_VABA			67)
-   (UNSPEC_VABAL		68)
    (UNSPEC_VABD			69)
    (UNSPEC_VABDL		70)
-   (UNSPEC_VABS			71)
-   (UNSPEC_VADD			72)
    (UNSPEC_VADDHN		73)
    (UNSPEC_VADDL		74)
    (UNSPEC_VADDW		75)
-   (UNSPEC_VAND			76)
-   (UNSPEC_VBIC			77)
    (UNSPEC_VBSL			78)
    (UNSPEC_VCAGE		79)
    (UNSPEC_VCAGT		80)
@@ -40,18 +34,9 @@
    (UNSPEC_VCGE			82)
    (UNSPEC_VCGT			83)
    (UNSPEC_VCLS			84)
-   (UNSPEC_VCLZ			85)
-   (UNSPEC_VCNT			86)
-   (UNSPEC_VCOMBINE		87)
    (UNSPEC_VCVT			88)
    (UNSPEC_VCVT_N		89)
-   (UNSPEC_VDUP_LANE		90)
-   (UNSPEC_VDUP_N		91)
-   (UNSPEC_VEOR			92)
    (UNSPEC_VEXT			93)
-   (UNSPEC_VGET_HIGH		94)
-   (UNSPEC_VGET_LANE		95)
-   (UNSPEC_VGET_LOW		96)
    (UNSPEC_VHADD		97)
    (UNSPEC_VHSUB		98)
    (UNSPEC_VLD1			99)
@@ -72,11 +57,9 @@
    (UNSPEC_VLD4_LANE		114)
    (UNSPEC_VMAX			115)
    (UNSPEC_VMIN			116)
-   (UNSPEC_VMLA			117)
    (UNSPEC_VMLAL		118)
    (UNSPEC_VMLA_LANE		119)
    (UNSPEC_VMLAL_LANE		120)
-   (UNSPEC_VMLS			121)
    (UNSPEC_VMLSL		122)
    (UNSPEC_VMLS_LANE		123)
    (UNSPEC_VMLSL_LANE		124)
@@ -86,10 +69,6 @@
    (UNSPEC_VMULL		128)
    (UNSPEC_VMUL_LANE		129)
    (UNSPEC_VMULL_LANE		130)
-   (UNSPEC_VMUL_N		131)
-   (UNSPEC_VMVN			132)
-   (UNSPEC_VORN			133)
-   (UNSPEC_VORR			134)
    (UNSPEC_VPADAL		135)
    (UNSPEC_VPADD		136)
    (UNSPEC_VPADDL		137)
@@ -125,7 +104,6 @@
    (UNSPEC_VREV64		167)
    (UNSPEC_VRSQRTE		168)
    (UNSPEC_VRSQRTS		169)
-   (UNSPEC_VSET_LANE		170)
    (UNSPEC_VSHL			171)
    (UNSPEC_VSHLL_N		172)
    (UNSPEC_VSHL_N		173)
@@ -147,7 +125,6 @@
    (UNSPEC_VST4B		189)
    (UNSPEC_VST4_LANE		190)
    (UNSPEC_VSTRUCTDUMMY		191)
-   (UNSPEC_VSUB			192)
    (UNSPEC_VSUBHN		193)
    (UNSPEC_VSUBL		194)
    (UNSPEC_VSUBW		195)
@@ -159,7 +136,8 @@
    (UNSPEC_VUZP1		201)
    (UNSPEC_VUZP2		202)
    (UNSPEC_VZIP1		203)
-   (UNSPEC_VZIP2		204)])
+   (UNSPEC_VZIP2		204)
+   (UNSPEC_MISALIGNED_ACCESS	205)])
 
 ;; Double-width vector modes.
 (define_mode_iterator VD [V8QI V4HI V2SI V2SF])
@@ -185,9 +163,6 @@
 ;; Opaque structure types wider than TImode.
 (define_mode_iterator VSTRUCT [EI OI CI XI])
 
-;; Number of instructions needed to load/store struct elements. FIXME!
-(define_mode_attr V_slen [(EI "2") (OI "2") (CI "3") (XI "4")])
-
 ;; Opaque structure types used in table lookups (except vtbl1/vtbx1).
 (define_mode_iterator VTAB [TI EI OI])
 
@@ -335,6 +310,14 @@
 				  (V4HI "V2SI") (V8HI "V4SI")
 				  (V2SI "DI")   (V4SI "V2DI")])
 
+;; Double-sized modes with the same element size.
+;; Used for neon_vdup_lane, where the second operand is double-sized
+;; even when the first one is quad.
+(define_mode_attr V_double_vector_mode [(V16QI "V8QI") (V8HI "V4HI")
+                                        (V4SI "V2SI") (V4SF "V2SF")
+                                        (V8QI "V8QI") (V4HI "V4HI")
+                                        (V2SI "V2SI") (V2SF "V2SF")])
+
 ;; Mode of result of comparison operations (and bit-select operand 1).
 (define_mode_attr V_cmp_result [(V8QI "V8QI") (V16QI "V16QI")
 			        (V4HI "V4HI") (V8HI  "V8HI")
@@ -459,7 +442,9 @@
 	  "=w,Uv,w, w,  ?r,?w,?r,?r, ?Us")
 	(match_operand:VD 1 "general_operand"
 	  " w,w, Dn,Uvi, w, r, r, Usi,r"))]
-  "TARGET_NEON"
+  "TARGET_NEON
+   && (register_operand (operands[0], <MODE>mode)
+       || register_operand (operands[1], <MODE>mode))"
 {
   if (which_alternative == 2)
     {
@@ -481,7 +466,7 @@
 
   /* FIXME: If the memory layout is changed in big-endian mode, output_move_vfp
      below must be changed to output_move_neon (which will use the
-     element/structure loads/stores), and the constraint changed to 'Un' instead
+     element/structure loads/stores), and the constraint changed to 'Um' instead
      of 'Uv'.  */
 
   switch (which_alternative)
@@ -506,7 +491,9 @@
   	  "=w,Un,w, w,  ?r,?w,?r,?r,  ?Us")
 	(match_operand:VQXMOV 1 "general_operand"
 	  " w,w, Dn,Uni, w, r, r, Usi, r"))]
-  "TARGET_NEON"
+  "TARGET_NEON
+   && (register_operand (operands[0], <MODE>mode)
+       || register_operand (operands[1], <MODE>mode))"
 {
   if (which_alternative == 2)
     {
@@ -549,6 +536,11 @@
 	(match_operand:TI 1 "general_operand" ""))]
   "TARGET_NEON"
 {
+  if (can_create_pseudo_p ())
+    {
+      if (GET_CODE (operands[0]) != REG)
+	operands[1] = force_reg (TImode, operands[1]);
+    }
 })
 
 (define_expand "mov<mode>"
@@ -556,12 +548,19 @@
 	(match_operand:VSTRUCT 1 "general_operand" ""))]
   "TARGET_NEON"
 {
+  if (can_create_pseudo_p ())
+    {
+      if (GET_CODE (operands[0]) != REG)
+	operands[1] = force_reg (<MODE>mode, operands[1]);
+    }
 })
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VSTRUCT 0 "nonimmediate_operand"	"=w,Ut,w")
 	(match_operand:VSTRUCT 1 "general_operand"	" w,w, Ut"))]
-  "TARGET_NEON"
+  "TARGET_NEON
+   && (register_operand (operands[0], <MODE>mode)
+       || register_operand (operands[1], <MODE>mode))"
 {
   switch (which_alternative)
     {
@@ -571,7 +570,7 @@
     }
 }
   [(set_attr "neon_type" "neon_int_1,neon_stm_2,neon_ldm_2")
-   (set_attr "length" "<V_slen>,<V_slen>,<V_slen>")])
+   (set (attr "length") (symbol_ref "arm_attr_length_move_neon (insn)"))])
 
 (define_split
   [(set (match_operand:EI 0 "s_register_operand" "")
@@ -658,6 +657,49 @@
   neon_disambiguate_copy (operands, dest, src, 4);
 })
 
+(define_expand "movmisalign<mode>"
+  [(set (match_operand:VDQX 0 "nonimmediate_operand"	      "")
+	(unspec:VDQX [(match_operand:VDQX 1 "general_operand" "")]
+		     UNSPEC_MISALIGNED_ACCESS))]
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
+{
+  if (!s_register_operand (operands[0], <MODE>mode)
+      && !s_register_operand (operands[1], <MODE>mode))
+    FAIL;
+})
+
+(define_insn "*movmisalign<mode>_neon_store"
+  [(set (match_operand:VDX 0 "memory_operand"                  "=Um")
+	(unspec:VDX [(match_operand:VDX 1 "s_register_operand" " w")]
+		    UNSPEC_MISALIGNED_ACCESS))]
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
+  "vst1.<V_sz_elem>\t{%P1}, %A0"
+  [(set_attr "neon_type" "neon_vst1_1_2_regs_vst2_2_regs")])
+
+(define_insn "*movmisalign<mode>_neon_load"
+  [(set (match_operand:VDX 0 "s_register_operand"          "=w")
+	(unspec:VDX [(match_operand:VDX 1 "memory_operand" " Um")]
+		    UNSPEC_MISALIGNED_ACCESS))]
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
+  "vld1.<V_sz_elem>\t{%P0}, %A1"
+  [(set_attr "neon_type" "neon_vld1_1_2_regs")])
+
+(define_insn "*movmisalign<mode>_neon_store"
+  [(set (match_operand:VQX 0 "memory_operand"                  "=Um")
+	(unspec:VQX [(match_operand:VQX 1 "s_register_operand" " w")]
+		    UNSPEC_MISALIGNED_ACCESS))]
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
+  "vst1.<V_sz_elem>\t{%q1}, %A0"
+  [(set_attr "neon_type" "neon_vst1_1_2_regs_vst2_2_regs")])
+
+(define_insn "*movmisalign<mode>_neon_load"
+  [(set (match_operand:VQX 0 "s_register_operand"           "=w")
+	(unspec:VQX [(match_operand:VQX 1 "memory_operand"  " Um")]
+		    UNSPEC_MISALIGNED_ACCESS))]
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
+  "vld1.<V_sz_elem>\t{%q0}, %A1"
+  [(set_attr "neon_type" "neon_vld1_1_2_regs")])
+
 (define_insn "vec_set<mode>_internal"
   [(set (match_operand:VD 0 "s_register_operand" "=w")
         (vec_merge:VD
@@ -672,7 +714,7 @@
     elt = GET_MODE_NUNITS (<MODE>mode) - 1 - elt;
   operands[2] = GEN_INT (elt);
   
-  return "vmov%?.<V_uf_sclr>\t%P0[%c2], %1";
+  return "vmov%?.<V_sz_elem>\t%P0[%c2], %1";
 }
   [(set_attr "predicable" "yes")
    (set_attr "neon_type" "neon_mcr")])
@@ -698,7 +740,7 @@
   operands[0] = gen_rtx_REG (<V_HALF>mode, regno + hi);
   operands[2] = GEN_INT (elt);
 
-  return "vmov%?.<V_uf_sclr>\t%P0[%c2], %1";
+  return "vmov%?.<V_sz_elem>\t%P0[%c2], %1";
 }
   [(set_attr "predicable" "yes")
    (set_attr "neon_type" "neon_mcr")]
@@ -718,7 +760,7 @@
 
   operands[0] = gen_rtx_REG (DImode, regno);
 
-  return "vmov%?.64\t%P0, %Q1, %R1";
+  return "vmov%?\t%P0, %Q1, %R1";
 }
   [(set_attr "predicable" "yes")
    (set_attr "neon_type" "neon_mcr_2_mcrr")]
@@ -786,11 +828,11 @@
           (parallel [(match_operand:SI 2 "immediate_operand" "i")])))]
   "TARGET_NEON"
 {
-  int regno = REGNO (operands[1]) + INTVAL (operands[2]);
+  int regno = REGNO (operands[1]) + 2 * INTVAL (operands[2]);
 
   operands[1] = gen_rtx_REG (DImode, regno);
 
-  return "vmov%?.64\t%Q0, %R0, %P1";
+  return "vmov%?\t%Q0, %R0, %P1  @ v2di";
 }
   [(set_attr "predicable" "yes")
    (set_attr "neon_type" "neon_int_1")]
@@ -807,11 +849,8 @@
 
 ;; Doubleword and quadword arithmetic.
 
-;; NOTE: vadd/vsub and some other instructions also support 64-bit integer
-;; element size, which we could potentially use for "long long" operations. We
-;; don't want to do this at present though, because moving values from the
-;; vector unit to the ARM core is currently slow and 64-bit addition (etc.) is
-;; easy to do with ARM instructions anyway.
+;; NOTE: some other instructions also support 64-bit integer
+;; element size, which we could potentially use for "long long" operations.
 
 (define_insn "*add<mode>3_neon"
   [(set (match_operand:VDQ 0 "s_register_operand" "=w")
@@ -827,6 +866,28 @@
                     (const_string "neon_int_1")))]
 )
 
+(define_insn "adddi3_neon"
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?w,&r,&r")
+        (plus:DI (match_operand:DI 1 "s_register_operand" "%w,w,0,0")
+                 (match_operand:DI 2 "s_register_operand" "w,w,r,0")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_NEON"
+{
+  switch (which_alternative)
+    {
+    case 0: /* fall through */
+    case 1: return "vadd.i64\t%P0, %P1, %P2";
+    case 2: return "#";
+    case 3: return "#";
+    default: gcc_unreachable ();
+    }
+}
+  [(set_attr "neon_type" "neon_int_1,neon_int_1,*,*")
+   (set_attr "conds" "*,*,clob,clob")
+   (set_attr "length" "*,*,8,8")
+   (set_attr "alt_tune" "nota8,onlya8,*,*")]
+)
+
 (define_insn "*sub<mode>3_neon"
   [(set (match_operand:VDQ 0 "s_register_operand" "=w")
         (minus:VDQ (match_operand:VDQ 1 "s_register_operand" "w")
@@ -841,6 +902,29 @@
                     (const_string "neon_int_2")))]
 )
 
+(define_insn "subdi3_neon"
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?w,&r,&r,&r")
+        (minus:DI (match_operand:DI 1 "s_register_operand" "w,w,0,r,0")
+                  (match_operand:DI 2 "s_register_operand" "w,w,r,0,0")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_NEON"
+{
+  switch (which_alternative)
+    {
+    case 0: /* fall through */
+    case 1: return "vsub.i64\t%P0, %P1, %P2";
+    case 2: /* fall through */ 
+    case 3: /* fall through */
+    case 4: return  "subs\\t%Q0, %Q1, %Q2\;sbc\\t%R0, %R1, %R2";
+    default: gcc_unreachable ();
+    }
+}
+  [(set_attr "neon_type" "neon_int_2,neon_int_2,*,*,*")
+   (set_attr "conds" "*,*,clob,clob,clob")
+   (set_attr "length" "*,*,8,8,8")
+   (set_attr "alt_tune" "nota8,onlya8,*,*,*")]
+)
+
 (define_insn "*mul<mode>3_neon"
   [(set (match_operand:VDQ 0 "s_register_operand" "=w")
         (mult:VDQ (match_operand:VDQ 1 "s_register_operand" "w")
@@ -862,6 +946,50 @@
                                     (const_string "neon_mul_qqq_8_16_32_ddd_32")))))]
 )
 
+(define_insn "mul<mode>3add<mode>_neon"
+  [(set (match_operand:VDQ 0 "s_register_operand" "=w")
+        (plus:VDQ (mult:VDQ (match_operand:VDQ 2 "s_register_operand" "w")
+                            (match_operand:VDQ 3 "s_register_operand" "w"))
+		  (match_operand:VDQ 1 "s_register_operand" "0")))]
+  "TARGET_NEON"
+  "vmla.<V_if_elem>\t%<V_reg>0, %<V_reg>2, %<V_reg>3"
+  [(set (attr "neon_type")
+      (if_then_else (ne (symbol_ref "<Is_float_mode>") (const_int 0))
+                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
+                                  (const_string "neon_fp_vmla_ddd")
+                                  (const_string "neon_fp_vmla_qqq"))
+                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
+                                  (if_then_else
+                                    (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
+                                    (const_string "neon_mla_ddd_8_16_qdd_16_8_long_32_16_long")
+                                    (const_string "neon_mla_ddd_32_qqd_16_ddd_32_scalar_qdd_64_32_long_scalar_qdd_64_32_long"))
+                                  (if_then_else (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
+                                    (const_string "neon_mla_qqq_8_16")
+                                    (const_string "neon_mla_qqq_32_qqd_32_scalar")))))]
+)
+
+(define_insn "mul<mode>3neg<mode>add<mode>_neon"
+  [(set (match_operand:VDQ 0 "s_register_operand" "=w")
+        (minus:VDQ (match_operand:VDQ 1 "s_register_operand" "0")
+                   (mult:VDQ (match_operand:VDQ 2 "s_register_operand" "w")
+                             (match_operand:VDQ 3 "s_register_operand" "w"))))]
+  "TARGET_NEON"
+  "vmls.<V_if_elem>\t%<V_reg>0, %<V_reg>2, %<V_reg>3"
+  [(set (attr "neon_type")
+      (if_then_else (ne (symbol_ref "<Is_float_mode>") (const_int 0))
+                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
+                                  (const_string "neon_fp_vmla_ddd")
+                                  (const_string "neon_fp_vmla_qqq"))
+                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
+                                  (if_then_else
+                                    (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
+                                    (const_string "neon_mla_ddd_8_16_qdd_16_8_long_32_16_long")
+                                    (const_string "neon_mla_ddd_32_qqd_16_ddd_32_scalar_qdd_64_32_long_scalar_qdd_64_32_long"))
+                                  (if_then_else (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
+                                    (const_string "neon_mla_qqq_8_16")
+                                    (const_string "neon_mla_qqq_32_qqd_32_scalar")))))]
+)
+
 (define_insn "ior<mode>3"
   [(set (match_operand:VDQ 0 "s_register_operand" "=w,w")
 	(ior:VDQ (match_operand:VDQ 1 "s_register_operand" "w,0")
@@ -880,21 +1008,26 @@
 )
 
 (define_insn "iordi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w,w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w,0")
-		    (match_operand:DI 2 "neon_logic_op2" "w,Dl")]
-                    UNSPEC_VORR))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?w,w,?w,&r,&r")
+        (ior:DI (match_operand:DI 1 "s_register_operand" "%w,w,0,0,0,r")
+		(match_operand:DI 2 "neon_logic_op2" "w,w,Dl,Dl,r,r")))]
   "TARGET_NEON"
 {
   switch (which_alternative)
     {
-    case 0: return "vorr\t%P0, %P1, %P2";
-    case 1: return neon_output_logic_immediate ("vorr", &operands[2],
+    case 0: /* fall through */
+    case 1: return "vorr\t%P0, %P1, %P2";
+    case 2: /* fall through */
+    case 3: return neon_output_logic_immediate ("vorr", &operands[2],
 		     DImode, 0, VALID_NEON_QREG_MODE (DImode));
+    case 4: return "#";
+    case 5: return "#";
     default: gcc_unreachable ();
     }
 }
-  [(set_attr "neon_type" "neon_int_1")]
+  [(set_attr "neon_type" "neon_int_1,neon_int_1,neon_int_1,neon_int_1,*,*")
+   (set_attr "length" "*,*,*,*,8,8")
+   (set_attr "alt_tune" "nota8,onlya8,nota8,onlya8,*,*")]
 )
 
 ;; The concrete forms of the Neon immediate-logic instructions are vbic and
@@ -920,21 +1053,26 @@
 )
 
 (define_insn "anddi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w,w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w,0")
-		    (match_operand:DI 2 "neon_inv_logic_op2" "w,DL")]
-                    UNSPEC_VAND))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?w,w,?w,&r,&r")
+        (and:DI (match_operand:DI 1 "s_register_operand" "%w,w,0,0,0,r")
+		(match_operand:DI 2 "neon_inv_logic_op2" "w,w,DL,DL,r,r")))]
   "TARGET_NEON"
 {
   switch (which_alternative)
     {
-    case 0: return "vand\t%P0, %P1, %P2";
-    case 1: return neon_output_logic_immediate ("vand", &operands[2],
+    case 0: /* fall through */
+    case 1: return "vand\t%P0, %P1, %P2";
+    case 2: /* fall through */
+    case 3: return neon_output_logic_immediate ("vand", &operands[2],
     		     DImode, 1, VALID_NEON_QREG_MODE (DImode));
+    case 4: return "#";
+    case 5: return "#";
     default: gcc_unreachable ();
     }
 }
-  [(set_attr "neon_type" "neon_int_1")]
+  [(set_attr "neon_type" "neon_int_1,neon_int_1,neon_int_1,neon_int_1,*,*")
+   (set_attr "length" "*,*,*,*,8,8")
+   (set_attr "alt_tune" "nota8,onlya8,nota8,onlya8,*,*")]
 )
 
 (define_insn "orn<mode>3_neon"
@@ -948,9 +1086,8 @@
 
 (define_insn "orndi3_neon"
   [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w")
-		    (match_operand:DI 2 "s_register_operand" "w")]
-                    UNSPEC_VORN))]
+	(ior:DI (match_operand:DI 1 "s_register_operand" "w")
+	         (not:DI (match_operand:DI 2 "s_register_operand" "w"))))]
   "TARGET_NEON"
   "vorn\t%P0, %P1, %P2"
   [(set_attr "neon_type" "neon_int_1")]
@@ -965,14 +1102,18 @@
   [(set_attr "neon_type" "neon_int_1")]
 )
 
+;; Compare to *anddi_notdi_di.
 (define_insn "bicdi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w")
-		     (match_operand:DI 2 "s_register_operand" "w")]
-                    UNSPEC_VBIC))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,=&r,&r")
+        (and:DI (not:DI (match_operand:DI 2 "s_register_operand" "w,r,0"))
+		(match_operand:DI 1 "s_register_operand" "w,0,r")))]
   "TARGET_NEON"
-  "vbic\t%P0, %P1, %P2"
-  [(set_attr "neon_type" "neon_int_1")]
+  "@
+   vbic\t%P0, %P1, %P2
+   #
+   #"
+  [(set_attr "neon_type" "neon_int_1,*,*")
+   (set_attr "length" "*,8,8")]
 )
 
 (define_insn "xor<mode>3"
@@ -985,13 +1126,18 @@
 )
 
 (define_insn "xordi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w")
-		     (match_operand:DI 2 "s_register_operand" "w")]
-                    UNSPEC_VEOR))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?w,&r,&r")
+        (xor:DI (match_operand:DI 1 "s_register_operand" "%w,w,0,r")
+	        (match_operand:DI 2 "s_register_operand" "w,w,r,r")))]
   "TARGET_NEON"
-  "veor\t%P0, %P1, %P2"
-  [(set_attr "neon_type" "neon_int_1")]
+  "@
+   veor\t%P0, %P1, %P2
+   veor\t%P0, %P1, %P2
+   #
+   #"
+  [(set_attr "neon_type" "neon_int_1,neon_int_1,*,*")
+   (set_attr "length" "*,*,8,8")
+   (set_attr "alt_tune" "nota8,onlya8,*,*")]
 )
 
 (define_insn "one_cmpl<mode>2"
@@ -1015,6 +1161,16 @@
                     (const_string "neon_int_3")))]
 )
 
+(define_expand "neon_vabs<mode>"
+  [(match_operand:VDQW 0 "s_register_operand" "")
+   (match_operand:VDQW 1 "s_register_operand" "")
+   (match_operand:SI 2 "immediate_operand" "")]
+  "TARGET_NEON"
+{
+  emit_insn (gen_abs<mode>2 (operands[0], operands[1]));
+  DONE;
+})
+
 (define_insn "neg<mode>2"
   [(set (match_operand:VDQW 0 "s_register_operand" "=w")
 	(neg:VDQW (match_operand:VDQW 1 "s_register_operand" "w")))]
@@ -1074,7 +1230,7 @@
 ; generic vectorizer code.  It ends up creating a V2DI constructor with
 ; SImode elements.
 
-(define_insn "ashl<mode>3"
+(define_insn "vashl<mode>3"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(ashift:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
 		      (match_operand:VDQIW 2 "s_register_operand" "w")))]
@@ -1120,7 +1276,7 @@
                     (const_string "neon_shift_3")))]
 )
 
-(define_expand "ashr<mode>3"
+(define_expand "vashr<mode>3"
   [(set (match_operand:VDQIW 0 "s_register_operand" "")
 	(ashiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "")
 			(match_operand:VDQIW 2 "s_register_operand" "")))]
@@ -1134,7 +1290,7 @@
   DONE;
 })
 
-(define_expand "lshr<mode>3"
+(define_expand "vlshr<mode>3"
   [(set (match_operand:VDQIW 0 "s_register_operand" "")
 	(lshiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "")
 			(match_operand:VDQIW 2 "s_register_operand" "")))]
@@ -1651,21 +1807,17 @@
 
 ; good for plain vadd, vaddq.
 
-(define_insn "neon_vadd<mode>"
-  [(set (match_operand:VDQX 0 "s_register_operand" "=w")
-        (unspec:VDQX [(match_operand:VDQX 1 "s_register_operand" "w")
-		      (match_operand:VDQX 2 "s_register_operand" "w")
-                      (match_operand:SI 3 "immediate_operand" "i")]
-                     UNSPEC_VADD))]
+(define_expand "neon_vadd<mode>"
+  [(match_operand:VDQX 0 "s_register_operand" "=w")
+   (match_operand:VDQX 1 "s_register_operand" "w")
+   (match_operand:VDQX 2 "s_register_operand" "w")
+   (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
-  "vadd.<V_if_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
-  [(set (attr "neon_type")
-      (if_then_else (ne (symbol_ref "<Is_float_mode>") (const_int 0))
-                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
-                                  (const_string "neon_fp_vadd_ddd_vabs_dd")
-                                  (const_string "neon_fp_vadd_qqq_vabs_qq"))
-                    (const_string "neon_int_1")))]
-)
+{
+  emit_insn (gen_add<mode>3 (operands[0], operands[1], operands[2]));
+  DONE;
+})
+
 
 ; operand 3 represents in bits:
 ;  bit 0: signed (vs unsigned).
@@ -1728,6 +1880,8 @@
   [(set_attr "neon_type" "neon_int_4")]
 )
 
+;; We cannot replace this unspec with mul<mode>3 because of the odd 
+;; polynomial multiplication case that can specified by operand 3.
 (define_insn "neon_vmul<mode>"
   [(set (match_operand:VDQW 0 "s_register_operand" "=w")
         (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "w")
@@ -1751,29 +1905,18 @@
                                     (const_string "neon_mul_qqq_8_16_32_ddd_32")))))]
 )
 
-(define_insn "neon_vmla<mode>"
-  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
-        (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")
-		      (match_operand:VDQW 2 "s_register_operand" "w")
-		      (match_operand:VDQW 3 "s_register_operand" "w")
-                     (match_operand:SI 4 "immediate_operand" "i")]
-                    UNSPEC_VMLA))]
+(define_expand "neon_vmla<mode>"
+  [(match_operand:VDQW 0 "s_register_operand" "=w")
+   (match_operand:VDQW 1 "s_register_operand" "0")
+   (match_operand:VDQW 2 "s_register_operand" "w")
+   (match_operand:VDQW 3 "s_register_operand" "w")
+   (match_operand:SI 4 "immediate_operand" "i")]
   "TARGET_NEON"
-  "vmla.<V_if_elem>\t%<V_reg>0, %<V_reg>2, %<V_reg>3"
-  [(set (attr "neon_type")
-      (if_then_else (ne (symbol_ref "<Is_float_mode>") (const_int 0))
-                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
-                                  (const_string "neon_fp_vmla_ddd")
-                                  (const_string "neon_fp_vmla_qqq"))
-                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
-                                  (if_then_else
-                                    (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
-                                    (const_string "neon_mla_ddd_8_16_qdd_16_8_long_32_16_long")
-                                    (const_string "neon_mla_ddd_32_qqd_16_ddd_32_scalar_qdd_64_32_long_scalar_qdd_64_32_long"))
-                                  (if_then_else (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
-                                    (const_string "neon_mla_qqq_8_16")
-                                    (const_string "neon_mla_qqq_32_qqd_32_scalar")))))]
-)
+{
+  emit_insn (gen_mul<mode>3add<mode>_neon (operands[0], operands[1],
+				           operands[2], operands[3]));
+  DONE;
+})
 
 (define_insn "neon_vmlal<mode>"
   [(set (match_operand:<V_widen> 0 "s_register_operand" "=w")
@@ -1790,30 +1933,18 @@
                    (const_string "neon_mla_ddd_32_qqd_16_ddd_32_scalar_qdd_64_32_long_scalar_qdd_64_32_long")))]
 )
 
-(define_insn "neon_vmls<mode>"
-  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
-        (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")
-		      (match_operand:VDQW 2 "s_register_operand" "w")
-		      (match_operand:VDQW 3 "s_register_operand" "w")
-                     (match_operand:SI 4 "immediate_operand" "i")]
-                    UNSPEC_VMLS))]
+(define_expand "neon_vmls<mode>"
+  [(match_operand:VDQW 0 "s_register_operand" "=w")
+   (match_operand:VDQW 1 "s_register_operand" "0")
+   (match_operand:VDQW 2 "s_register_operand" "w")
+   (match_operand:VDQW 3 "s_register_operand" "w")
+   (match_operand:SI 4 "immediate_operand" "i")]
   "TARGET_NEON"
-  "vmls.<V_if_elem>\t%<V_reg>0, %<V_reg>2, %<V_reg>3"
-  [(set (attr "neon_type")
-      (if_then_else (ne (symbol_ref "<Is_float_mode>") (const_int 0))
-                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
-                                  (const_string "neon_fp_vmla_ddd")
-                                  (const_string "neon_fp_vmla_qqq"))
-                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
-                                  (if_then_else
-                                    (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
-                                    (const_string "neon_mla_ddd_8_16_qdd_16_8_long_32_16_long")
-                                    (const_string "neon_mla_ddd_32_qqd_16_ddd_32_scalar_qdd_64_32_long_scalar_qdd_64_32_long"))
-                                  (if_then_else
-                                    (ne (symbol_ref "<Scalar_mul_8_16>") (const_int 0))
-                                    (const_string "neon_mla_qqq_8_16")
-                                    (const_string "neon_mla_qqq_32_qqd_32_scalar")))))]
-)
+{
+  emit_insn (gen_mul<mode>3neg<mode>add<mode>_neon (operands[0], operands[1],
+						    operands[2], operands[3]));
+  DONE;
+})
 
 (define_insn "neon_vmlsl<mode>"
   [(set (match_operand:<V_widen> 0 "s_register_operand" "=w")
@@ -1906,21 +2037,16 @@
                    (const_string "neon_mul_qdd_64_32_long_qqd_16_ddd_32_scalar_64_32_long_scalar")))]
 )
 
-(define_insn "neon_vsub<mode>"
-  [(set (match_operand:VDQX 0 "s_register_operand" "=w")
-        (unspec:VDQX [(match_operand:VDQX 1 "s_register_operand" "w")
-		      (match_operand:VDQX 2 "s_register_operand" "w")
-                      (match_operand:SI 3 "immediate_operand" "i")]
-                     UNSPEC_VSUB))]
+(define_expand "neon_vsub<mode>"
+  [(match_operand:VDQX 0 "s_register_operand" "=w")
+   (match_operand:VDQX 1 "s_register_operand" "w")
+   (match_operand:VDQX 2 "s_register_operand" "w")
+   (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
-  "vsub.<V_if_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
-  [(set (attr "neon_type")
-      (if_then_else (ne (symbol_ref "<Is_float_mode>") (const_int 0))
-                    (if_then_else (ne (symbol_ref "<Is_d_reg>") (const_int 0))
-                                  (const_string "neon_fp_vadd_ddd_vabs_dd")
-                                  (const_string "neon_fp_vadd_qqq_vabs_qq"))
-                    (const_string "neon_int_2")))]
-)
+{
+  emit_insn (gen_sub<mode>3 (operands[0], operands[1], operands[2]));
+  DONE;
+})
 
 (define_insn "neon_vsubl<mode>"
   [(set (match_operand:<V_widen> 0 "s_register_operand" "=w")
@@ -2093,11 +2219,11 @@
 
 (define_insn "neon_vaba<mode>"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
-        (unspec:VDQIW [(match_operand:VDQIW 1 "s_register_operand" "0")
-		       (match_operand:VDQIW 2 "s_register_operand" "w")
-		       (match_operand:VDQIW 3 "s_register_operand" "w")
-                       (match_operand:SI 4 "immediate_operand" "i")]
-		      UNSPEC_VABA))]
+        (plus:VDQIW (match_operand:VDQIW 1 "s_register_operand" "0")
+                    (unspec:VDQIW [(match_operand:VDQIW 2 "s_register_operand" "w")
+		                   (match_operand:VDQIW 3 "s_register_operand" "w")
+                                   (match_operand:SI 4 "immediate_operand" "i")]
+		                  UNSPEC_VABD)))]
   "TARGET_NEON"
   "vaba.%T4%#<V_sz_elem>\t%<V_reg>0, %<V_reg>2, %<V_reg>3"
   [(set (attr "neon_type")
@@ -2107,11 +2233,11 @@
 
 (define_insn "neon_vabal<mode>"
   [(set (match_operand:<V_widen> 0 "s_register_operand" "=w")
-        (unspec:<V_widen> [(match_operand:<V_widen> 1 "s_register_operand" "0")
-		           (match_operand:VW 2 "s_register_operand" "w")
-		           (match_operand:VW 3 "s_register_operand" "w")
-                           (match_operand:SI 4 "immediate_operand" "i")]
-                          UNSPEC_VABAL))]
+        (plus:<V_widen> (match_operand:<V_widen> 1 "s_register_operand" "0")
+                        (unspec:<V_widen> [(match_operand:VW 2 "s_register_operand" "w")
+                                           (match_operand:VW 3 "s_register_operand" "w")
+                                           (match_operand:SI 4 "immediate_operand" "i")]
+                          UNSPEC_VABDL)))]
   "TARGET_NEON"
   "vabal.%T4%#<V_sz_elem>\t%q0, %P2, %P3"
   [(set_attr "neon_type" "neon_vaba")]
@@ -2242,23 +2368,6 @@
                     (const_string "neon_fp_vrecps_vrsqrts_qqq")))]
 )
 
-(define_insn "neon_vabs<mode>"
-  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
-	(unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "w")
-		      (match_operand:SI 2 "immediate_operand" "i")]
-                     UNSPEC_VABS))]
-  "TARGET_NEON"
-  "vabs.<V_s_elem>\t%<V_reg>0, %<V_reg>1"
-  [(set (attr "neon_type")
-     (if_then_else (ior (ne (symbol_ref "<Is_float_mode>") (const_int 0))
-                        (ne (symbol_ref "<Is_float_mode>") (const_int 0)))
-                   (if_then_else
-                      (ne (symbol_ref "<Is_d_reg>") (const_int 0))
-                      (const_string "neon_fp_vadd_ddd_vabs_dd")
-                      (const_string "neon_fp_vadd_qqq_vabs_qq"))
-                   (const_string "neon_vqneg_vqabs")))]
-)
-
 (define_insn "neon_vqabs<mode>"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(unspec:VDQIW [(match_operand:VDQIW 1 "s_register_operand" "w")
@@ -2299,26 +2408,42 @@
   [(set_attr "neon_type" "neon_int_1")]
 )
 
-(define_insn "neon_vclz<mode>"
+(define_insn "clz<mode>2"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
-	(unspec:VDQIW [(match_operand:VDQIW 1 "s_register_operand" "w")
-		       (match_operand:SI 2 "immediate_operand" "i")]
-		      UNSPEC_VCLZ))]
+        (clz:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")))]
   "TARGET_NEON"
   "vclz.<V_if_elem>\t%<V_reg>0, %<V_reg>1"
   [(set_attr "neon_type" "neon_int_1")]
 )
 
-(define_insn "neon_vcnt<mode>"
+(define_expand "neon_vclz<mode>"
+  [(match_operand:VDQIW 0 "s_register_operand" "")
+   (match_operand:VDQIW 1 "s_register_operand" "")
+   (match_operand:SI 2 "immediate_operand" "")]
+  "TARGET_NEON"
+{
+  emit_insn (gen_clz<mode>2 (operands[0], operands[1]));
+  DONE;
+})
+
+(define_insn "popcount<mode>2"
   [(set (match_operand:VE 0 "s_register_operand" "=w")
-	(unspec:VE [(match_operand:VE 1 "s_register_operand" "w")
-                    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_VCNT))]
+        (popcount:VE (match_operand:VE 1 "s_register_operand" "w")))]
   "TARGET_NEON"
   "vcnt.<V_sz_elem>\t%<V_reg>0, %<V_reg>1"
   [(set_attr "neon_type" "neon_int_1")]
 )
 
+(define_expand "neon_vcnt<mode>"
+  [(match_operand:VE 0 "s_register_operand" "=w")
+   (match_operand:VE 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")]
+  "TARGET_NEON"
+{
+  emit_insn (gen_popcount<mode>2 (operands[0], operands[1]));
+  DONE;
+})
+
 (define_insn "neon_vrecpe<mode>"
   [(set (match_operand:V32 0 "s_register_operand" "=w")
 	(unspec:V32 [(match_operand:V32 1 "s_register_operand" "w")
@@ -2495,126 +2620,65 @@
 ; Operand 3 (info word) is ignored because it does nothing useful with 64-bit
 ; elements.
 
-(define_insn "neon_vget_lanedi"
-  [(set (match_operand:DI 0 "s_register_operand" "=r")
-       (unspec:DI [(match_operand:DI 1 "s_register_operand" "w")
-                   (match_operand:SI 2 "immediate_operand" "i")
-                   (match_operand:SI 3 "immediate_operand" "i")]
-                  UNSPEC_VGET_LANE))]
+(define_expand "neon_vget_lanedi"
+  [(match_operand:DI 0 "s_register_operand" "=r")
+   (match_operand:DI 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")
+   (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
 {
   neon_lane_bounds (operands[2], 0, 1);
-  return "vmov%?\t%Q0, %R0, %P1  @ di";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
+  emit_move_insn (operands[0], operands[1]);
+  DONE;
+})
 
-(define_insn "neon_vget_lanev2di"
-  [(set (match_operand:DI 0 "s_register_operand" "=r")
-       (unspec:DI [(match_operand:V2DI 1 "s_register_operand" "w")
-                   (match_operand:SI 2 "immediate_operand" "i")
-                   (match_operand:SI 3 "immediate_operand" "i")]
-                  UNSPEC_VGET_LANE))]
+(define_expand "neon_vget_lanev2di"
+  [(match_operand:DI 0 "s_register_operand" "=r")
+   (match_operand:V2DI 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")
+   (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
 {
-  rtx ops[2];
-  unsigned int regno = REGNO (operands[1]);
-  unsigned int elt = INTVAL (operands[2]);
-
   neon_lane_bounds (operands[2], 0, 2);
+  emit_insn (gen_vec_extractv2di (operands[0], operands[1], operands[2]));
+  DONE;
+})
 
-  ops[0] = operands[0];
-  ops[1] = gen_rtx_REG (DImode, regno + 2 * elt);
-  output_asm_insn ("vmov%?\t%Q0, %R0, %P1  @ v2di", ops);
-
-  return "";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
-
-(define_insn "neon_vset_lane<mode>"
-  [(set (match_operand:VD 0 "s_register_operand" "=w")
-	(unspec:VD [(match_operand:<V_elem> 1 "s_register_operand" "r")
-		    (match_operand:VD 2 "s_register_operand" "0")
-                    (match_operand:SI 3 "immediate_operand" "i")]
-                   UNSPEC_VSET_LANE))]
-  "TARGET_NEON"
-{
-  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));
-  return "vmov%?.<V_sz_elem>\t%P0[%c3], %1";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
-
-; See neon_vget_lanedi comment for reasons operands 2 & 3 are ignored.
-
-(define_insn "neon_vset_lanedi"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "r")
-		    (match_operand:DI 2 "s_register_operand" "0")
-                    (match_operand:SI 3 "immediate_operand" "i")]
-                   UNSPEC_VSET_LANE))]
-  "TARGET_NEON"
-{
-  neon_lane_bounds (operands[3], 0, 1);
-  return "vmov%?\t%P0, %Q1, %R1  @ di";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
-
-(define_insn "neon_vset_lane<mode>"
-  [(set (match_operand:VQ 0 "s_register_operand" "=w")
-	(unspec:VQ [(match_operand:<V_elem> 1 "s_register_operand" "r")
-		    (match_operand:VQ 2 "s_register_operand" "0")
-                    (match_operand:SI 3 "immediate_operand" "i")]
-                   UNSPEC_VSET_LANE))]
+(define_expand "neon_vset_lane<mode>"
+  [(match_operand:VDQ 0 "s_register_operand" "=w")
+   (match_operand:<V_elem> 1 "s_register_operand" "r")
+   (match_operand:VDQ 2 "s_register_operand" "0")
+   (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
 {
-  rtx ops[4];
-  unsigned int regno = REGNO (operands[0]);
-  unsigned int halfelts = GET_MODE_NUNITS (<MODE>mode) / 2;
   unsigned int elt = INTVAL (operands[3]);
+  neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));
 
-  neon_lane_bounds (operands[3], 0, halfelts * 2);
+  if (BYTES_BIG_ENDIAN)
+    {
+      unsigned int reg_nelts
+	= 64 / GET_MODE_BITSIZE (GET_MODE_INNER (<MODE>mode));
+      elt ^= reg_nelts - 1;
+    }
 
-  ops[0] = gen_rtx_REG (<V_HALF>mode, regno + 2 * (elt / halfelts));
-  ops[1] = operands[1];
-  ops[2] = GEN_INT (elt % halfelts);
-  output_asm_insn ("vmov%?.<V_sz_elem>\t%P0[%c2], %1", ops);
+  emit_insn (gen_vec_set<mode>_internal (operands[0], operands[1],
+                                         GEN_INT (1 << elt), operands[2]));
+  DONE;
+})
 
-  return "";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
+; See neon_vget_lanedi comment for reasons operands 2 & 3 are ignored.
 
-(define_insn "neon_vset_lanev2di"
-  [(set (match_operand:V2DI 0 "s_register_operand" "=w")
-	(unspec:V2DI [(match_operand:DI 1 "s_register_operand" "r")
-		      (match_operand:V2DI 2 "s_register_operand" "0")
-                      (match_operand:SI 3 "immediate_operand" "i")]
-                   UNSPEC_VSET_LANE))]
+(define_expand "neon_vset_lanedi"
+  [(match_operand:DI 0 "s_register_operand" "=w")
+   (match_operand:DI 1 "s_register_operand" "r")
+   (match_operand:DI 2 "s_register_operand" "0")
+   (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
 {
-  rtx ops[2];
-  unsigned int regno = REGNO (operands[0]);
-  unsigned int elt = INTVAL (operands[3]);
-
-  neon_lane_bounds (operands[3], 0, 2);
-
-  ops[0] = gen_rtx_REG (DImode, regno + 2 * elt);
-  ops[1] = operands[1];
-  output_asm_insn ("vmov%?\t%P0, %Q1, %R1  @ v2di", ops);
-
-  return "";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
+  neon_lane_bounds (operands[3], 0, 1);
+  emit_move_insn (operands[0], operands[1]);
+  DONE;
+})
 
 (define_expand "neon_vcreate<mode>"
   [(match_operand:VDX 0 "s_register_operand" "")
@@ -2627,9 +2691,8 @@
 })
 
 (define_insn "neon_vdup_n<mode>"
-  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
-	(unspec:VDQW [(match_operand:<V_elem> 1 "s_register_operand" "r")]
-                    UNSPEC_VDUP_N))]
+  [(set (match_operand:VX 0 "s_register_operand" "=w")
+        (vec_duplicate:VX (match_operand:<V_elem> 1 "s_register_operand" "r")))]
   "TARGET_NEON"
   "vdup%?.<V_sz_elem>\t%<V_reg>0, %1"
   ;; Assume this schedules like vmov.
@@ -2637,61 +2700,88 @@
    (set_attr "neon_type" "neon_bp_simple")]
 )
 
-(define_insn "neon_vdup_ndi"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "r")]
-                   UNSPEC_VDUP_N))]
+(define_insn "neon_vdup_n<mode>"
+  [(set (match_operand:V32 0 "s_register_operand" "=w,w")
+        (vec_duplicate:V32 (match_operand:<V_elem> 1 "s_register_operand" "r,t")))]
   "TARGET_NEON"
-  "vmov%?\t%P0, %Q1, %R1"
+  "@
+  vdup%?.<V_sz_elem>\t%<V_reg>0, %1
+  vdup%?.<V_sz_elem>\t%<V_reg>0, %y1"
+  ;; Assume this schedules like vmov.
   [(set_attr "predicable" "yes")
    (set_attr "neon_type" "neon_bp_simple")]
 )
 
+(define_expand "neon_vdup_ndi"
+  [(match_operand:DI 0 "s_register_operand" "=w")
+   (match_operand:DI 1 "s_register_operand" "r")]
+  "TARGET_NEON"
+{
+  emit_move_insn (operands[0], operands[1]);
+  DONE;
+}
+)
+
 (define_insn "neon_vdup_nv2di"
-  [(set (match_operand:V2DI 0 "s_register_operand" "=w")
-	(unspec:V2DI [(match_operand:DI 1 "s_register_operand" "r")]
-                     UNSPEC_VDUP_N))]
+  [(set (match_operand:V2DI 0 "s_register_operand" "=w,w")
+        (vec_duplicate:V2DI (match_operand:DI 1 "s_register_operand" "r,w")))]
   "TARGET_NEON"
-  "vmov%?\t%e0, %Q1, %R1\;vmov%?\t%f0, %Q1, %R1"
+  "@
+  vmov%?\t%e0, %Q1, %R1\;vmov%?\t%f0, %Q1, %R1
+  vmov%?\t%e0, %P1\;vmov%?\t%f0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "length" "8")
    (set_attr "neon_type" "neon_bp_simple")]
 )
 
-(define_insn "neon_vdup_lane<mode>"
-  [(set (match_operand:VD 0 "s_register_operand" "=w")
-	(unspec:VD [(match_operand:VD 1 "s_register_operand" "w")
-		    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_VDUP_LANE))]
+(define_insn "neon_vdup_lane<mode>_internal"
+  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
+  	(vec_duplicate:VDQW 
+          (vec_select:<V_elem>
+            (match_operand:<V_double_vector_mode> 1 "s_register_operand" "w")
+            (parallel [(match_operand:SI 2 "immediate_operand" "i")]))))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<MODE>mode));
-  return "vdup.<V_sz_elem>\t%P0, %P1[%c2]";
+  if (BYTES_BIG_ENDIAN)
+    {
+      int elt = INTVAL (operands[2]);
+      elt = GET_MODE_NUNITS (<V_double_vector_mode>mode) - 1 - elt;
+      operands[2] = GEN_INT (elt);
+    }
+  if (<Is_d_reg>)
+    return "vdup.<V_sz_elem>\t%P0, %P1[%c2]";
+  else
+    return "vdup.<V_sz_elem>\t%q0, %P1[%c2]";
 }
   ;; Assume this schedules like vmov.
   [(set_attr "neon_type" "neon_bp_simple")]
 )
 
-(define_insn "neon_vdup_lane<mode>"
-  [(set (match_operand:VQ 0 "s_register_operand" "=w")
-	(unspec:VQ [(match_operand:<V_HALF> 1 "s_register_operand" "w")
-		    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_VDUP_LANE))]
+(define_expand "neon_vdup_lane<mode>"
+  [(match_operand:VDQW 0 "s_register_operand" "=w")
+   (match_operand:<V_double_vector_mode> 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<V_HALF>mode));
-  return "vdup.<V_sz_elem>\t%q0, %P1[%c2]";
-}
-  ;; Assume this schedules like vmov.
-  [(set_attr "neon_type" "neon_bp_simple")]
-)
+  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<V_double_vector_mode>mode));
+  if (BYTES_BIG_ENDIAN)
+    {
+      unsigned int elt = INTVAL (operands[2]);
+      unsigned int reg_nelts
+	= 64 / GET_MODE_BITSIZE (GET_MODE_INNER (<V_double_vector_mode>mode));
+      elt ^= reg_nelts - 1;
+      operands[2] = GEN_INT (elt);
+    }
+    emit_insn (gen_neon_vdup_lane<mode>_internal (operands[0], operands[1],
+                                                  operands[2]));
+    DONE;
+})
 
 ; Scalar index is ignored, since only zero is valid here.
 (define_expand "neon_vdup_lanedi"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w")
-		    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_VDUP_LANE))]
+  [(match_operand:DI 0 "s_register_operand" "=w")
+   (match_operand:DI 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")]
   "TARGET_NEON"
 {
   neon_lane_bounds (operands[2], 0, 1);
@@ -2699,20 +2789,17 @@
   DONE;
 })
 
-; Likewise.
-(define_insn "neon_vdup_lanev2di"
-  [(set (match_operand:V2DI 0 "s_register_operand" "=w")
-	(unspec:V2DI [(match_operand:DI 1 "s_register_operand" "w")
-		      (match_operand:SI 2 "immediate_operand" "i")]
-                     UNSPEC_VDUP_LANE))]
+; Likewise for v2di, as the DImode second operand has only a single element.
+(define_expand "neon_vdup_lanev2di"
+  [(match_operand:V2DI 0 "s_register_operand" "=w")
+   (match_operand:DI 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")]
   "TARGET_NEON"
 {
   neon_lane_bounds (operands[2], 0, 1);
-  return "vmov\t%e0, %P1\;vmov\t%f0, %P1";
-}
-  [(set_attr "length" "8")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
+  emit_insn (gen_neon_vdup_nv2di (operands[0], operands[1]));
+  DONE;
+})
 
 ;; In this insn, operand 1 should be low, and operand 2 the high part of the
 ;; dest vector.
@@ -2723,9 +2810,8 @@
 
 (define_insn "neon_vcombine<mode>"
   [(set (match_operand:<V_DOUBLE> 0 "s_register_operand" "=w")
-	(unspec:<V_DOUBLE> [(match_operand:VDX 1 "s_register_operand" "w")
-			    (match_operand:VDX 2 "s_register_operand" "w")]
-                           UNSPEC_VCOMBINE))]
+        (vec_concat:<V_DOUBLE> (match_operand:VDX 1 "s_register_operand" "w")
+			       (match_operand:VDX 2 "s_register_operand" "w")))]
   "TARGET_NEON"
 {
   int dest = REGNO (operands[0]);
@@ -2765,10 +2851,13 @@
    (set_attr "neon_type" "neon_bp_simple")]
 )
 
-(define_insn "neon_vget_high<mode>"
-  [(set (match_operand:<V_HALF> 0 "s_register_operand" "=w")
-	(unspec:<V_HALF> [(match_operand:VQX 1 "s_register_operand" "w")]
-			 UNSPEC_VGET_HIGH))]
+(define_insn "neon_vget_highv16qi"
+  [(set (match_operand:V8QI 0 "s_register_operand" "=w")
+	(vec_select:V8QI (match_operand:V16QI 1 "s_register_operand" "w")
+                         (parallel [(const_int 8) (const_int 9)
+			            (const_int 10) (const_int 11)
+				    (const_int 12) (const_int 13)
+				    (const_int 14) (const_int 15)])))]
   "TARGET_NEON"
 {
   int dest = REGNO (operands[0]);
@@ -2782,10 +2871,151 @@
   [(set_attr "neon_type" "neon_bp_simple")]
 )
 
-(define_insn "neon_vget_low<mode>"
-  [(set (match_operand:<V_HALF> 0 "s_register_operand" "=w")
-	(unspec:<V_HALF> [(match_operand:VQX 1 "s_register_operand" "w")]
-			 UNSPEC_VGET_LOW))]
+(define_insn "neon_vget_highv8hi"
+  [(set (match_operand:V4HI 0 "s_register_operand" "=w")
+	(vec_select:V4HI (match_operand:V8HI 1 "s_register_operand" "w")
+	                 (parallel [(const_int 4) (const_int 5)
+			            (const_int 6) (const_int 7)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src + 2)
+    return "vmov\t%P0, %f1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_highv4si"
+  [(set (match_operand:V2SI 0 "s_register_operand" "=w")
+	(vec_select:V2SI (match_operand:V4SI 1 "s_register_operand" "w")
+	                 (parallel [(const_int 2) (const_int 3)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src + 2)
+    return "vmov\t%P0, %f1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_highv4sf"
+  [(set (match_operand:V2SF 0 "s_register_operand" "=w")
+	(vec_select:V2SF (match_operand:V4SF 1 "s_register_operand" "w")
+	                 (parallel [(const_int 2) (const_int 3)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src + 2)
+    return "vmov\t%P0, %f1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_highv2di"
+  [(set (match_operand:DI 0 "s_register_operand" "=w")
+	(vec_select:DI (match_operand:V2DI 1 "s_register_operand" "w")
+	               (parallel [(const_int 1)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src + 2)
+    return "vmov\t%P0, %f1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_lowv16qi"
+  [(set (match_operand:V8QI 0 "s_register_operand" "=w")
+	(vec_select:V8QI (match_operand:V16QI 1 "s_register_operand" "w")
+                         (parallel [(const_int 0) (const_int 1)
+			            (const_int 2) (const_int 3)
+				    (const_int 4) (const_int 5)
+				    (const_int 6) (const_int 7)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src)
+    return "vmov\t%P0, %e1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_lowv8hi"
+  [(set (match_operand:V4HI 0 "s_register_operand" "=w")
+	(vec_select:V4HI (match_operand:V8HI 1 "s_register_operand" "w")
+	                 (parallel [(const_int 0) (const_int 1)
+			            (const_int 2) (const_int 3)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src)
+    return "vmov\t%P0, %e1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_lowv4si"
+  [(set (match_operand:V2SI 0 "s_register_operand" "=w")
+	(vec_select:V2SI (match_operand:V4SI 1 "s_register_operand" "w")
+	                 (parallel [(const_int 0) (const_int 1)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src)
+    return "vmov\t%P0, %e1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_lowv4sf"
+  [(set (match_operand:V2SF 0 "s_register_operand" "=w")
+	(vec_select:V2SF (match_operand:V4SF 1 "s_register_operand" "w")
+	                 (parallel [(const_int 0) (const_int 1)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src)
+    return "vmov\t%P0, %e1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_lowv2di"
+  [(set (match_operand:DI 0 "s_register_operand" "=w")
+	(vec_select:DI (match_operand:V2DI 1 "s_register_operand" "w")
+	               (parallel [(const_int 0)])))]
   "TARGET_NEON"
 {
   int dest = REGNO (operands[0]);
diff --git a/gcc/config/arm/neon.ml b/gcc/config/arm/neon.ml
index 80cc4f149..b5b9cab73 100644
--- a/gcc/config/arm/neon.ml
+++ b/gcc/config/arm/neon.ml
@@ -50,7 +50,7 @@ type vectype = T_int8x8    | T_int8x16
              | T_ptrto of vectype | T_const of vectype
              | T_void      | T_intQI
              | T_intHI     | T_intSI
-             | T_intDI
+             | T_intDI     | T_floatSF
 
 (* The meanings of the following are:
      TImode : "Tetra", two registers (four words).
@@ -68,6 +68,7 @@ type shape_elt = Dreg | Qreg | Corereg | Immed | VecArray of int * shape_elt
 	       | Element_of_dreg	(* Used for "lane" variants.  *)
 	       | Element_of_qreg	(* Likewise.  *)
 	       | All_elements_of_dreg	(* Used for "dup" variants.  *)
+	       | Alternatives of shape_elt list (* Used for multiple valid operands *)
 
 type shape_form = All of int * shape_elt
                 | Long
@@ -708,7 +709,8 @@ let pf_su_8_64 = P8 :: P16 :: F32 :: su_8_64
 let ops =
   [
     (* Addition.  *)
-    Vadd, [], All (3, Dreg), "vadd", sign_invar_2, F32 :: su_8_64;
+    Vadd, [], All (3, Dreg), "vadd", sign_invar_2, F32 :: su_8_32;
+    Vadd, [No_op], All (3, Dreg), "vadd", sign_invar_2, [S64; U64];
     Vadd, [], All (3, Qreg), "vaddQ", sign_invar_2, F32 :: su_8_64;
     Vadd, [], Long, "vaddl", elts_same_2, su_8_32;
     Vadd, [], Wide, "vaddw", elts_same_2, su_8_32;
@@ -757,7 +759,8 @@ let ops =
     Vmls, [Saturating; Doubling], Long, "vqdmlsl", elts_same_io, [S16; S32];
 
     (* Subtraction.  *)
-    Vsub, [], All (3, Dreg), "vsub", sign_invar_2, F32 :: su_8_64;
+    Vsub, [], All (3, Dreg), "vsub", sign_invar_2, F32 :: su_8_32;
+    Vsub, [No_op], All (3, Dreg), "vsub", sign_invar_2,  [S64; U64];
     Vsub, [], All (3, Qreg), "vsubQ", sign_invar_2, F32 :: su_8_64;
     Vsub, [], Long, "vsubl", elts_same_2, su_8_32;
     Vsub, [], Wide, "vsubw", elts_same_2, su_8_32;
@@ -966,7 +969,8 @@ let ops =
       Use_operands [| Corereg; Dreg; Immed |],
       "vget_lane", get_lane, pf_su_8_32;
     Vget_lane,
-      [InfoWord;
+      [No_op;
+       InfoWord;
        Disassembles_as [Use_operands [| Corereg; Corereg; Dreg |]];
        Instruction_name ["vmov"]; Const_valuator (fun _ -> 0)],
       Use_operands [| Corereg; Dreg; Immed |],
@@ -988,7 +992,8 @@ let ops =
                 Instruction_name ["vmov"]],
       Use_operands [| Dreg; Corereg; Dreg; Immed |], "vset_lane",
       set_lane, pf_su_8_32;
-    Vset_lane, [Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]];
+    Vset_lane, [No_op;
+                Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]];
                 Instruction_name ["vmov"]; Const_valuator (fun _ -> 0)],
       Use_operands [| Dreg; Corereg; Dreg; Immed |], "vset_lane",
       set_lane_notype, [S64; U64];
@@ -1009,19 +1014,27 @@ let ops =
       pf_su_8_64;
 
     (* Set all lanes to the same value.  *)
-    Vdup_n, [],
+    Vdup_n,
+      [Disassembles_as [Use_operands [| Dreg;
+                                        Alternatives [ Corereg;
+                                                       Element_of_dreg ] |]]],
       Use_operands [| Dreg; Corereg |], "vdup_n", bits_1,
       pf_su_8_32;
     Vdup_n,
-      [Instruction_name ["vmov"];
+      [No_op;
+       Instruction_name ["vmov"];
        Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]]],
       Use_operands [| Dreg; Corereg |], "vdup_n", notype_1,
       [S64; U64];
-    Vdup_n, [],
+    Vdup_n,
+      [Disassembles_as [Use_operands [| Qreg;
+                                        Alternatives [ Corereg;
+                                                       Element_of_dreg ] |]]],
       Use_operands [| Qreg; Corereg |], "vdupQ_n", bits_1,
       pf_su_8_32;
     Vdup_n,
-      [Instruction_name ["vmov"];
+      [No_op;
+       Instruction_name ["vmov"];
        Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |];
                         Use_operands [| Dreg; Corereg; Corereg |]]],
       Use_operands [| Qreg; Corereg |], "vdupQ_n", notype_1,
@@ -1029,21 +1042,29 @@ let ops =
 
     (* These are just aliases for the above.  *)
     Vmov_n,
-      [Builtin_name "vdup_n"],
+      [Builtin_name "vdup_n";
+       Disassembles_as [Use_operands [| Dreg;
+                                        Alternatives [ Corereg;
+                                                       Element_of_dreg ] |]]],
       Use_operands [| Dreg; Corereg |],
       "vmov_n", bits_1, pf_su_8_32;
     Vmov_n,
-      [Builtin_name "vdup_n";
+      [No_op;
+       Builtin_name "vdup_n";
        Instruction_name ["vmov"];
        Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]]],
       Use_operands [| Dreg; Corereg |],
       "vmov_n", notype_1, [S64; U64];
     Vmov_n,
-      [Builtin_name "vdupQ_n"],
+      [Builtin_name "vdupQ_n";
+       Disassembles_as [Use_operands [| Qreg;
+                                        Alternatives [ Corereg;
+                                                       Element_of_dreg ] |]]],
       Use_operands [| Qreg; Corereg |],
       "vmovQ_n", bits_1, pf_su_8_32;
     Vmov_n,
-      [Builtin_name "vdupQ_n";
+      [No_op;
+       Builtin_name "vdupQ_n";
        Instruction_name ["vmov"];
        Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |];
                         Use_operands [| Dreg; Corereg; Corereg |]]],
@@ -1600,23 +1621,28 @@ let ops =
       store_3, [P16; F32; U16; U32; S16; S32];
 
     (* Logical operations. And.  *)
-    Vand, [], All (3, Dreg), "vand", notype_2, su_8_64;
+    Vand, [], All (3, Dreg), "vand", notype_2, su_8_32;
+    Vand, [No_op], All (3, Dreg), "vand", notype_2, [S64; U64];
     Vand, [], All (3, Qreg), "vandQ", notype_2, su_8_64;
 
     (* Or.  *)
-    Vorr, [], All (3, Dreg), "vorr", notype_2, su_8_64;
+    Vorr, [], All (3, Dreg), "vorr", notype_2, su_8_32;
+    Vorr, [No_op], All (3, Dreg), "vorr", notype_2, [S64; U64];
     Vorr, [], All (3, Qreg), "vorrQ", notype_2, su_8_64;
 
     (* Eor.  *)
-    Veor, [], All (3, Dreg), "veor", notype_2, su_8_64;
+    Veor, [], All (3, Dreg), "veor", notype_2, su_8_32;
+    Veor, [No_op], All (3, Dreg), "veor", notype_2, [S64; U64];
     Veor, [], All (3, Qreg), "veorQ", notype_2, su_8_64;
 
     (* Bic (And-not).  *)
-    Vbic, [], All (3, Dreg), "vbic", notype_2, su_8_64;
+    Vbic, [], All (3, Dreg), "vbic", notype_2, su_8_32;
+    Vbic, [No_op], All (3, Dreg), "vbic", notype_2, [S64; U64];
     Vbic, [], All (3, Qreg), "vbicQ", notype_2, su_8_64;
 
     (* Or-not.  *)
-    Vorn, [], All (3, Dreg), "vorn", notype_2, su_8_64;
+    Vorn, [], All (3, Dreg), "vorn", notype_2, su_8_32;
+    Vorn, [No_op], All (3, Dreg), "vorn", notype_2, [S64; U64];
     Vorn, [], All (3, Qreg), "vornQ", notype_2, su_8_64;
   ]
 
@@ -1698,6 +1724,7 @@ let string_of_vectype vt =
   | T_intHI -> "__builtin_neon_hi"
   | T_intSI -> "__builtin_neon_si"
   | T_intDI -> "__builtin_neon_di"
+  | T_floatSF -> "__builtin_neon_sf"
   | T_arrayof (num, base) ->
       let basename = name (fun x -> x) base in
       affix (Printf.sprintf "%sx%d" basename num)
diff --git a/gcc/config/arm/netbsd-elf.h b/gcc/config/arm/netbsd-elf.h
index 4c06fa1cb..9cf186b33 100644
--- a/gcc/config/arm/netbsd-elf.h
+++ b/gcc/config/arm/netbsd-elf.h
@@ -153,5 +153,5 @@ do									\
 while (0)
 
 #undef FPUTYPE_DEFAULT
-#define FPUTYPE_DEFAULT FPUTYPE_VFP
+#define FPUTYPE_DEFAULT "vfp"
 
diff --git a/gcc/config/arm/nocrt0.h b/gcc/config/arm/nocrt0.h
new file mode 100644
index 000000000..3a819b5ff
--- /dev/null
+++ b/gcc/config/arm/nocrt0.h
@@ -0,0 +1,25 @@
+/* Definitions for generic libgloss based cofigs where crt0 is supplied by
+   the linker script.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC	" crti%O%s crtbegin%O%s"
+
+#undef LIB_SPEC
+#define LIB_SPEC "-lc"
diff --git a/gcc/config/arm/nucleus.h b/gcc/config/arm/nucleus.h
new file mode 100644
index 000000000..e9e31f594
--- /dev/null
+++ b/gcc/config/arm/nucleus.h
@@ -0,0 +1,60 @@
+/* Configuration file for ARM nucleus targets.
+   Copyright (C) 2010
+   Free Software Foundation, Inc.
+   Contributed by Nathan Sidwell (nathan@codesourcery.com)
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#if NUCLEUS_SHARED_EXEC
+/* Executables are really shared objects, so default to building a .so
+ */
+#undef LINK_SPEC
+#define LINK_SPEC "%{!static:%{!shared:-shared -z defs}} " BPABI_LINK_SPEC
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "crti%O%s %{!static:crtbeginS%O%s;:crtbegin%O%s}"
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{!static:crtendS%O%s;:crtend%O%s} crtn%O%s"
+#define NUCLEUS_SHARED_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define_std ("shared");		\
+    }						\
+  while (0)
+#else
+#define NUCLEUS_SHARED_CPP_BUILTINS() do {} while (0)
+#endif
+/* On nucleaus EABI, we want both the BPABI builtins and a
+   nucleaus builtin.  */
+#undef  TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS() 		\
+  do 						\
+    {						\
+      TARGET_BPABI_CPP_BUILTINS();		\
+      builtin_define_std ("nucleus");		\
+      NUCLEUS_SHARED_CPP_BUILTINS();		\
+    }						\
+  while (0)
+
+/* wide chars are 16 bit */
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "short int"
+#define WCHAR_TYPE_SIZE 16
+
+/* Use --as-needed -lgcc_s for eh support.  */
+#ifdef HAVE_LD_AS_NEEDED
+#define USE_LD_AS_NEEDED 1
+#endif
diff --git a/gcc/config/arm/pe-cxx.c b/gcc/config/arm/pe-cxx.c
new file mode 100644
index 000000000..0e70cd8d0
--- /dev/null
+++ b/gcc/config/arm/pe-cxx.c
@@ -0,0 +1,167 @@
+/* Target support for C++ classes on Windows.
+   Contributed by Danny Smith (dannysmith@users.sourceforge.net)
+   Copyright (C) 2005
+   Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "output.h"
+#include "tree.h"
+#include "cp/cp-tree.h" /* this is why we're a separate module */
+#include "flags.h"
+#include "tm_p.h"
+#include "toplev.h"
+#include "hashtab.h"
+
+bool
+arm_pe_type_dllimport_p (tree decl)
+{
+   gcc_assert (TREE_CODE (decl) == VAR_DECL
+               || TREE_CODE (decl) == FUNCTION_DECL);
+
+   if (TARGET_NOP_FUN_DLLIMPORT && TREE_CODE (decl) == FUNCTION_DECL)
+     return false;
+
+   /* We ignore the dllimport attribute for inline member functions.
+      This differs from MSVC behavior which treats it like GNUC
+      'extern inline' extension.  Also ignore for template
+      instantiations with linkonce semantics and artificial methods.  */
+    if (TREE_CODE (decl) ==  FUNCTION_DECL
+        && (DECL_DECLARED_INLINE_P (decl)
+	    || DECL_TEMPLATE_INSTANTIATION (decl)
+	    || DECL_ARTIFICIAL (decl)))
+      return false;
+
+   /* Since we can't treat a pointer to a dllimport'd symbol as a
+       constant address, we turn off the attribute on C++ virtual
+       methods to allow creation of vtables using thunks.  */
+    else if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE
+	     && DECL_VIRTUAL_P (decl))
+      {
+	/* Even though we ignore the attribute from the start, warn if we later see
+	   an out-of class definition, as we do for other member functions in
+	   tree.c:merge_dllimport_decl_attributes.  If this is the key method, the
+	   definition may affect the import-export status of vtables, depending
+           on how we handle MULTIPLE_SYMBOL_SPACES in cp/decl2.c.   */
+	if (DECL_INITIAL (decl))
+	  {
+	    warning (OPT_Wattributes, "%q+D redeclared without dllimport attribute: "
+		    "previous dllimport ignored", decl);
+#ifdef PE_DLL_DEBUG
+	    if (decl == CLASSTYPE_KEY_METHOD (DECL_CONTEXT (decl)))            
+	      warning (OPT_Wattributes, "key method %q+D of dllimport'd class defined"
+		       decl);
+#endif
+	  }
+	return false;
+      }
+
+      /* Don't mark defined functions as dllimport.  This code will only be
+         reached if we see a non-inline function defined out-of-class.  */
+    else if (TREE_CODE (decl) ==  FUNCTION_DECL
+	     && (DECL_INITIAL (decl)))
+      return false;
+
+    /*  Don't allow definitions of static data members in dllimport class,
+        If vtable data is marked as DECL_EXTERNAL, import it; otherwise just
+        ignore the class attribute.  */
+    else if (TREE_CODE (decl) == VAR_DECL
+	     && TREE_STATIC (decl) && TREE_PUBLIC (decl)
+	     && !DECL_EXTERNAL (decl))
+      {
+	if (!DECL_VIRTUAL_P (decl))
+	     error ("definition of static data member %q+D of "
+		    "dllimport'd class", decl);
+	return false;
+      }
+
+    return true;
+}
+
+
+bool
+arm_pe_type_dllexport_p (tree decl)
+{
+   gcc_assert (TREE_CODE (decl) == VAR_DECL 
+               || TREE_CODE (decl) == FUNCTION_DECL);
+   /* Avoid exporting compiler-generated default dtors and copy ctors.
+      The only artificial methods that need to be exported are virtual
+      and non-virtual thunks.  */
+   if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE
+       && DECL_ARTIFICIAL (decl) && !DECL_THUNK_P (decl))
+     return false;
+   return true;
+}
+
+static inline void maybe_add_dllimport (tree decl)
+/* void maybe_add_dllimport (tree decl) */
+{
+  if (arm_pe_type_dllimport_p (decl))
+    DECL_DLLIMPORT_P (decl) = 1;   
+}
+
+void
+arm_pe_adjust_class_at_definition (tree t)
+{
+  tree member;
+
+  gcc_assert (CLASS_TYPE_P (t));
+
+ /* We only look at dllimport.  The only thing that dllexport does is
+    add stuff to a '.drectiv' section at end-of-file, so no need to do
+    anything for dllexport'd classes until we generate RTL. */  
+  if (lookup_attribute ("dllimport", TYPE_ATTRIBUTES (t)) == NULL_TREE)
+    return;
+
+  /* We don't actually add the attribute to the decl, just set the flag
+     that signals that the address of this symbol is not a compile-time
+     constant.   Any subsequent out-of-class declaration of members wil
+     cause the DECL_DLLIMPORT_P flag to be unset.
+     (See  tree.c: merge_dllimport_decl_attributes).
+     That is just right since out-of class declarations can only be a
+     definition.  We recheck the class members  at RTL generation to
+     emit warnings if this has happened.  Definition of static data member
+     of dllimport'd class always causes an error (as per MS compiler).
+     */
+
+  /* Check static VAR_DECL's.  */
+  for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))
+    if (TREE_CODE (member) == VAR_DECL)     
+      maybe_add_dllimport (member);
+    
+  /* Check FUNCTION_DECL's.  */
+  for (member = TYPE_METHODS (t); member;  member = TREE_CHAIN (member))
+    if (TREE_CODE (member) == FUNCTION_DECL)      
+      maybe_add_dllimport (member);
+ 
+  /* Check vtables  */
+  for (member = CLASSTYPE_VTABLES (t); member;  member = TREE_CHAIN (member))
+    if (TREE_CODE (member) == VAR_DECL) 
+      maybe_add_dllimport (member);
+
+/* We leave typeinfo tables alone.  We can't mark TI objects as
+     dllimport, since the address of a secondary VTT may be needed
+     for static initialization of a primary VTT.  VTT's  of
+     dllimport'd classes should always be link-once COMDAT.  */ 
+}
diff --git a/gcc/config/arm/pe-stubs.c b/gcc/config/arm/pe-stubs.c
new file mode 100644
index 000000000..8f13f0686
--- /dev/null
+++ b/gcc/config/arm/pe-stubs.c
@@ -0,0 +1,52 @@
+/* Dummy subroutines for language-specific support on Windows.
+   Contributed by Danny Smith (dannysmith@users.sourceforge.net)
+   Copyright (C) 2005
+   Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "output.h"
+#include "tree.h"
+#include "flags.h"
+#include "tm_p.h"
+#include "toplev.h"
+#include "hashtab.h"
+
+bool
+arm_pe_type_dllimport_p (tree decl ATTRIBUTE_UNUSED)
+{
+  return false;
+}
+
+
+bool
+arm_pe_type_dllexport_p (tree decl ATTRIBUTE_UNUSED)
+{
+  return false;
+}
+
+
+void
+arm_pe_adjust_class_at_definition (tree t ATTRIBUTE_UNUSED)
+{ }
diff --git a/gcc/config/arm/pe.opt b/gcc/config/arm/pe.opt
index 560a52a81..c66e13e50 100644
--- a/gcc/config/arm/pe.opt
+++ b/gcc/config/arm/pe.opt
@@ -21,3 +21,7 @@
 mnop-fun-dllimport
 Target Report Mask(NOP_FUN_DLLIMPORT)
 Ignore dllimport attribute for functions
+
+mms-bitfields
+Target Report Mask(MS_BITFIELD_LAYOUT)
+Use native (MS) bitfield layout
diff --git a/gcc/config/arm/predicates.md b/gcc/config/arm/predicates.md
index c7d63355d..26f5fd525 100644
--- a/gcc/config/arm/predicates.md
+++ b/gcc/config/arm/predicates.md
@@ -73,6 +73,10 @@
 	      || REGNO_REG_CLASS (REGNO (op)) == FPA_REGS));
 })
 
+(define_special_predicate "subreg_lowpart_operator"
+  (and (match_code "subreg")
+       (match_test "subreg_lowpart_p (op)")))
+
 ;; Reg, subreg(reg) or const_int.
 (define_predicate "reg_or_int_operand"
   (ior (match_code "const_int")
@@ -82,6 +86,12 @@
   (and (match_code "const_int")
        (match_test "const_ok_for_arm (INTVAL (op))")))
 
+;; A constant value which fits into two instructions, each taking
+;; an arithmetic constant operand for one of the words.
+(define_predicate "arm_immediate_di_operand"
+  (and (match_code "const_int,const_double")
+       (match_test "arm_const_double_by_immediates (op)")))
+
 (define_predicate "arm_neg_immediate_operand"
   (and (match_code "const_int")
        (match_test "const_ok_for_arm (-INTVAL (op))")))
@@ -111,6 +121,10 @@
   (ior (match_operand 0 "arm_rhs_operand")
        (match_operand 0 "arm_not_immediate_operand")))
 
+(define_predicate "arm_di_operand"
+  (ior (match_operand 0 "s_register_operand")
+       (match_operand 0 "arm_immediate_di_operand")))
+
 ;; True if the operand is a memory reference which contains an
 ;; offsettable address.
 (define_predicate "offsettable_memory_operand"
@@ -168,6 +182,11 @@
   (and (match_code "plus,minus,ior,xor,and")
        (match_test "mode == GET_MODE (op)")))
 
+;; True for plus/minus operators
+(define_special_predicate "plusminus_operator"
+  (and (match_code "plus,minus")
+       (match_test "mode == GET_MODE (op)")))
+
 ;; True for logical binary operators.
 (define_special_predicate "logical_binary_operator"
   (and (match_code "ior,xor,and")
@@ -280,10 +299,9 @@
        (and (match_code "reg,subreg,mem")
 	    (match_operand 0 "nonimmediate_soft_df_operand"))))
 
-(define_predicate "const_shift_operand"
+(define_predicate "const_shift_count"
   (and (match_code "const_int")
-       (ior (match_operand 0 "power_of_two_operand")
-	    (match_test "((unsigned HOST_WIDE_INT) INTVAL (op)) < 32"))))
+       (match_test "((unsigned HOST_WIDE_INT) INTVAL (op)) < 32")))
 
 
 (define_special_predicate "load_multiple_operation"
@@ -295,6 +313,9 @@
   HOST_WIDE_INT i = 1, base = 0;
   rtx elt;
 
+  if (low_irq_latency)
+    return false;
+
   if (count <= 1
       || GET_CODE (XVECEXP (op, 0, 0)) != SET)
     return false;
@@ -352,6 +373,9 @@
   HOST_WIDE_INT i = 1, base = 0;
   rtx elt;
 
+  if (low_irq_latency)
+    return false;
+
   if (count <= 1
       || GET_CODE (XVECEXP (op, 0, 0)) != SET)
     return false;
@@ -491,13 +515,15 @@
 (define_predicate "imm_for_neon_logic_operand"
   (match_code "const_vector")
 {
-  return neon_immediate_valid_for_logic (op, mode, 0, NULL, NULL);
+  return (TARGET_NEON
+          && neon_immediate_valid_for_logic (op, mode, 0, NULL, NULL));
 })
 
 (define_predicate "imm_for_neon_inv_logic_operand"
   (match_code "const_vector")
 {
-  return neon_immediate_valid_for_logic (op, mode, 1, NULL, NULL);
+  return (TARGET_NEON
+          && neon_immediate_valid_for_logic (op, mode, 1, NULL, NULL));
 })
 
 (define_predicate "neon_logic_op2"
@@ -513,3 +539,11 @@
   (and (match_code "const_int")
        (match_test "INTVAL (op) >= 0 && INTVAL (op) <= 7")))
 
+;; Predicates for named expanders that overlap multiple ISAs.
+
+(define_predicate "cmpdi_operand"
+  (if_then_else (match_test "TARGET_HARD_FLOAT && TARGET_MAVERICK")
+		(and (match_test "TARGET_ARM")
+		     (match_operand 0 "cirrus_fp_register"))
+		(and (match_test "TARGET_32BIT")
+		     (match_operand 0 "arm_di_operand"))))
diff --git a/gcc/config/arm/sfp-machine.h b/gcc/config/arm/sfp-machine.h
index bc75737d7..648db6074 100644
--- a/gcc/config/arm/sfp-machine.h
+++ b/gcc/config/arm/sfp-machine.h
@@ -14,9 +14,11 @@
 #define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
 #define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
 
+#define _FP_NANFRAC_H		((_FP_QNANBIT_H << 1) - 1)
 #define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
 #define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
 #define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_H		0
 #define _FP_NANSIGN_S		0
 #define _FP_NANSIGN_D		0
 #define _FP_NANSIGN_Q		0
@@ -92,5 +94,7 @@
 #define __fixdfdi	__aeabi_d2lz
 #define __fixunsdfdi	__aeabi_d2ulz
 #define __floatdidf	__aeabi_l2d
+#define __extendhfsf2	__aeabi_h2f
+#define __truncsfhf2	__aeabi_f2h
 
 #endif /* __ARM_EABI__ */
diff --git a/gcc/config/arm/symbian.h b/gcc/config/arm/symbian.h
index ff233a89f..defd3d26e 100644
--- a/gcc/config/arm/symbian.h
+++ b/gcc/config/arm/symbian.h
@@ -71,11 +71,6 @@
 #define SUBTARGET_ASM_FLOAT_SPEC \
   "%{!mfpu=*:-mfpu=vfp} %{!mcpu=*:%{!march=*:-march=armv5t}}"
   
-/* SymbianOS provides the BPABI routines in a separate library.
-   Therefore, we do not need to define any of them in libgcc.  */
-#undef RENAME_LIBRARY
-#define RENAME_LIBRARY(GCC_NAME, AEABI_NAME) /* empty */
-
 /* Define the __symbian__ macro.  */
 #undef TARGET_OS_CPP_BUILTINS
 #define TARGET_OS_CPP_BUILTINS()				\
diff --git a/gcc/config/arm/t-arm b/gcc/config/arm/t-arm
index 96e4e49a7..2e2c37821 100644
--- a/gcc/config/arm/t-arm
+++ b/gcc/config/arm/t-arm
@@ -13,7 +13,9 @@ MD_INCLUDES= 	$(srcdir)/config/arm/arm-tune.md \
 		$(srcdir)/config/arm/iwmmxt.md \
 		$(srcdir)/config/arm/vfp.md \
 		$(srcdir)/config/arm/neon.md \
-		$(srcdir)/config/arm/thumb2.md
+		$(srcdir)/config/arm/thumb2.md \
+		$(srcdir)/config/arm/marvell-f.md \
+		$(srcdir)/config/arm/hwdiv.md
 
 s-config s-conditions s-flags s-codes s-constants s-emit s-recog s-preds \
 	s-opinit s-extract s-peep s-attr s-attrtab s-output: $(MD_INCLUDES)
diff --git a/gcc/config/arm/t-arm-elf b/gcc/config/arm/t-arm-elf
index 334629399..063308ebe 100644
--- a/gcc/config/arm/t-arm-elf
+++ b/gcc/config/arm/t-arm-elf
@@ -24,10 +24,18 @@ MULTILIB_MATCHES     =
 #MULTILIB_MATCHES      += march?armv7=march?armv7-a
 #MULTILIB_MATCHES      += march?armv7=march?armv7-r
 #MULTILIB_MATCHES      += march?armv7=march?armv7-m
+#MULTILIB_MATCHES      += march?armv7=march?armv7e-m
 #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a8
 #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
 #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
 
+# Not quite true.  We can support hard-vfp calling in Thumb2, but how do we
+# express that here?  Also, we really need architecture v5e or later
+# (mcrr etc).
+MULTILIB_OPTIONS       += mfloat-abi=hard
+MULTILIB_DIRNAMES      += fpu
+MULTILIB_EXCEPTIONS    += *mthumb/*mfloat-abi=hard*
+
 # MULTILIB_OPTIONS    += mcpu=ep9312
 # MULTILIB_DIRNAMES   += ep9312
 # MULTILIB_EXCEPTIONS += *mthumb/*mcpu=ep9312*
diff --git a/gcc/config/arm/t-asa b/gcc/config/arm/t-asa
new file mode 100644
index 000000000..8ca5d8f06
--- /dev/null
+++ b/gcc/config/arm/t-asa
@@ -0,0 +1,45 @@
+# Overrides for ASA
+
+# Here is the expected output from xgcc -print-multi-lib.
+#
+# .;@fno-omit-frame-pointer@mapcs-frame
+# armv4t;@march=armv4t@fno-omit-frame-pointer@mapcs-frame
+# armv6;@march=armv6@fno-omit-frame-pointer@mapcs-frame
+# armv7a;@march=armv7-a@fno-omit-frame-pointer@mapcs-frame
+# armv6f;@march=armv6@mfloat-abi=softfp@fno-omit-frame-pointer@mapcs-frame
+# armv7af;@march=armv7-a@mfpu=neon@mfloat-abi=softfp@fno-omit-frame-pointer@mapcs-frame
+# thumb2;@mthumb@march=armv7-a@fno-omit-frame-pointer@mapcs-frame
+# thumb2f;@mthumb@march=armv7-a@mfpu=neon@mfloat-abi=softfp@fno-omit-frame-pointer@mapcs-frame
+
+MULTILIB_OPTIONS = mthumb march=armv4t/march=armv6/march=armv7-a mfpu=neon mfloat-abi=softfp
+MULTILIB_DIRNAMES = thumb v4t v6 v7a neon softfp
+MULTILIB_MATCHES =
+
+MULTILIB_EXTRA_OPTS = fno-omit-frame-pointer mapcs-frame
+
+MULTILIB_EXCEPTIONS  = mthumb
+MULTILIB_EXCEPTIONS += mfpu=neon*
+MULTILIB_EXCEPTIONS += mfloat-abi=softfp
+MULTILIB_EXCEPTIONS += *march=armv4t*/*mfpu=neon*
+MULTILIB_EXCEPTIONS += *march=armv4t*/*mfloat-abi=softfp*
+MULTILIB_EXCEPTIONS += march=armv6/*mfpu=neon*
+MULTILIB_EXCEPTIONS += mthumb/mfpu=neon
+MULTILIB_EXCEPTIONS += mthumb/mfloat-abi=softfp
+MULTILIB_EXCEPTIONS += mthumb/mfpu=neon*
+MULTILIB_EXCEPTIONS += mthumb/march=armv6/mfpu=neon*
+
+MULTILIB_OSDIRNAMES  = march.armv4t=!armv4t
+MULTILIB_OSDIRNAMES += march.armv6=!armv6
+MULTILIB_OSDIRNAMES += march.armv6/mfloat-abi.softfp=!armv6f
+MULTILIB_OSDIRNAMES += march.armv7-a=!armv7a
+MULTILIB_OSDIRNAMES += march.armv7-a/mfpu.neon/mfloat-abi.softfp=!armv7af
+MULTILIB_OSDIRNAMES += mthumb/march.armv7-a=!thumb2
+MULTILIB_OSDIRNAMES += mthumb/march.armv7-a/mfpu.neon/mfloat-abi.softfp=!thumb2f
+
+MULTILIB_ALIASES  = march?armv4t=mthumb/march?armv4t
+MULTILIB_ALIASES += march?armv6=mthumb/march?armv6
+MULTILIB_ALIASES += march?armv6/mfloat-abi?softfp=mthumb/march?armv6/mfloat-abi?softfp
+MULTILIB_ALIASES += march?armv7-a/mfpu?neon/mfloat-abi?softfp=march?armv7-a/mfpu?neon
+MULTILIB_ALIASES += march?armv7-a/mfpu?neon/mfloat-abi?softfp=march?armv7-a/mfloat-abi?softfp
+MULTILIB_ALIASES += mthumb/march?armv7-a/mfpu?neon/mfloat-abi?softfp=mthumb/march?armv7-a/mfpu?neon
+MULTILIB_ALIASES += mthumb/march?armv7-a/mfpu?neon/mfloat-abi?softfp=mthumb/march?armv7-a/mfloat-abi?softfp
diff --git a/gcc/config/arm/t-bpabi b/gcc/config/arm/t-bpabi
index b5c6a0b61..e24550389 100644
--- a/gcc/config/arm/t-bpabi
+++ b/gcc/config/arm/t-bpabi
@@ -1,10 +1,13 @@
 # Add the bpabi.S functions.
-LIB1ASMFUNCS += _aeabi_lcmp _aeabi_ulcmp _aeabi_ldivmod _aeabi_uldivmod
+LIB1ASMFUNCS += _aeabi_lcmp _aeabi_ulcmp _aeabi_ldivmod _aeabi_uldivmod \
+		_aeabi_idiv0 _aeabi_ldiv0
 
 # Add the BPABI C functions.
 LIB2FUNCS_EXTRA = $(srcdir)/config/arm/bpabi.c \
 		  $(srcdir)/config/arm/unaligned-funcs.c
 
+LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/arm/fp16.c
+
 UNWIND_H = $(srcdir)/config/arm/unwind-arm.h
 LIB2ADDEH = $(srcdir)/config/arm/unwind-arm.c \
   $(srcdir)/config/arm/libunwind.S \
diff --git a/gcc/config/arm/t-cs-eabi b/gcc/config/arm/t-cs-eabi
new file mode 100644
index 000000000..5cb26d7c2
--- /dev/null
+++ b/gcc/config/arm/t-cs-eabi
@@ -0,0 +1,199 @@
+# Multilibs for SourceryG++ arm-none-eabi
+
+MULTILIB_OPTIONS     = mthumb
+MULTILIB_DIRNAMES    = t
+MULTILIB_EXCEPTIONS  = 
+MULTILIB_MATCHES     =
+MULTILIB_ALIASES     =
+
+MULTILIB_OPTIONS      += march=armv7/march=armv7-a/march=armv5te/march=armv6-m
+MULTILIB_DIRNAMES     += v7 v7a v5te v6m
+MULTILIB_MATCHES      += march?armv7-a=march?armv7a
+MULTILIB_MATCHES      += march?armv7=march?armv7r
+MULTILIB_MATCHES      += march?armv7=march?armv7m
+MULTILIB_MATCHES      += march?armv7=march?armv7-r
+MULTILIB_MATCHES      += march?armv7=march?armv7-m
+MULTILIB_MATCHES      += march?armv7=march?armv7e-m
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a9
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a8
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a5
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4f
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m1
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m0
+MULTILIB_MATCHES      += march?armv5te=march?armv6
+MULTILIB_MATCHES      += march?armv5te=march?armv6j
+MULTILIB_MATCHES      += march?armv5te=march?armv6k
+MULTILIB_MATCHES      += march?armv5te=march?armv6z
+MULTILIB_MATCHES      += march?armv5te=march?armv6zk
+MULTILIB_MATCHES      += march?armv5te=march?armv6t2
+MULTILIB_MATCHES      += march?armv5te=march?iwmmxt
+MULTILIB_MATCHES      += march?armv5te=march?iwmmxt2
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm9e
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm946e-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm966e-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm968e-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm10e
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1020e
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1022e
+MULTILIB_MATCHES      += march?armv5te=mcpu?xscale
+MULTILIB_MATCHES      += march?armv5te=mcpu?iwmmxt
+MULTILIB_MATCHES      += march?armv5te=mcpu?iwmmxt2
+MULTILIB_MATCHES      += march?armv5te=mcpu?marvell-f
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm926ej-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1026ej-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1136j-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1136jf-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1176jz-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1176jzf-s
+MULTILIB_MATCHES      += march?armv5te=mcpu?mpcorenovfp
+MULTILIB_MATCHES      += march?armv5te=mcpu?mpcore
+MULTILIB_MATCHES      += march?armv5te=mcpu?arm1156t2-s
+
+MULTILIB_OPTIONS      += mfloat-abi=softfp/mfloat-abi=hard
+MULTILIB_DIRNAMES     += softfp hard
+MULTILIB_MATCHES      += mfloat-abi?hard=mhard-float
+
+MULTILIB_OPTIONS      += mfpu=neon
+MULTILIB_DIRNAMES     += neon
+MULTILIB_EXCEPTIONS   += mfpu=neon
+MULTILIB_MATCHES      += mfpu?neon=mfpu?neon-fp16
+MULTILIB_MATCHES      += mfpu?neon=mfpu?neon-vfpv4
+
+MULTILIB_ALIASES      += mthumb=mthumb/mfpu?neon
+MULTILIB_ALIASES      += mthumb=mthumb/march?armv5te/mfpu?neon
+MULTILIB_ALIASES      += mbig-endian=mthumb/mfpu?neon/mbig-endian
+#MULTILIB_ALIASES      += mfloat-abi?softfp=mthumb/mfloat-abi?softfp/mfpu?neon
+#MULTILIB_ALIASES      += mfloat-abi?softfp=mfloat-abi?softfp/mfpu?neon
+#MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=mfloat-abi?softfp/mfpu?neon/mbig-endian
+#MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=mthumb/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7-a/mfpu?neon
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7-a/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += march?armv7-a/mfloat-abi?softfp/mfpu?neon=mthumb/march?armv7-a/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv7-a/mfloat-abi?hard/mfpu?neon=mthumb/march?armv7-a/mfloat-abi?hard/mfpu?neon
+
+MULTILIB_OPTIONS      += mbig-endian
+MULTILIB_DIRNAMES     += be
+MULTILIB_ALIASES      += mbig-endian=mfpu?neon/mbig-endian
+
+# ARMv6-M  does not have ARM mode.
+MULTILIB_EXCEPTIONS   += march=armv6-m
+
+# Some ARMv7 variants have ARM mode.  Use the ARM libraries.
+MULTILIB_EXCEPTIONS   += march=armv7 march=armv7/*
+MULTILIB_ALIASES      += mbig-endian=march?armv7/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=march?armv7/mfloat-abi?softfp
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=march?armv7/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=march?armv7/mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=march?armv7/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=march?armv7/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7/mfpu?neon
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7/mfloat-abi?softfp/mfpu?neon/mbig-endian
+
+# ARMv7-A is specially useful used with VFPv3 (enabled by NEON). Rest of the cases behaves as ARMv7.
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7-a
+MULTILIB_ALIASES      += mbig-endian=march?armv7-a/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=march?armv7-a/mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=march?armv7-a/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7-a/mfloat-abi?softfp
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7-a/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7-a/mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7/mfloat-abi?softfp             
+MULTILIB_ALIASES      += march?armv5te=march?armv7-a
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=march?armv7-a/mfloat-abi?softfp
+MULTILIB_ALIASES      += march?armv5te=march?armv7-a/mfpu?neon
+MULTILIB_ALIASES      += mbig-endian=march?armv7-a/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7-a/mfloat-abi?softfp/mfpu?neon/mbig-endian
+
+# ARMv5T thumb uses the ARMv5T ARM libraries (with or without VFP).
+MULTILIB_ALIASES      += mthumb=mthumb/march?armv5te
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=mthumb/march?armv5te/mfloat-abi?softfp
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=march?armv5te/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp=mthumb/march?armv5te/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv5te=march?armv5te/mfpu?neon
+MULTILIB_ALIASES      += mbig-endian=march?armv5te/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=march?armv5te/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mthumb/march?armv5te/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=mthumb/march?armv5te/mfloat-abi?softfp/mfpu?neon/mbig-endian
+
+# ARMv6-M and VFP are incompatible.
+# FIXME:  The compiler should probably error.
+MULTILIB_EXCEPTIONS   += *march=armv6-m/mfloat-abi=softfp
+MULTILIB_ALIASES      += mthumb/march?armv6-m=mthumb/march?armv6-m/mfpu?neon
+MULTILIB_EXCEPTIONS   += march=armv6-m*mfpu=neon
+MULTILIB_EXCEPTIONS   += mthumb/march=armv6-m/mfloat-abi=softfp/mfpu=neon
+
+# ARMv4t VFP isn't really supported, so use the soft-float libraries.
+MULTILIB_EXCEPTIONS   += mfloat-abi?softfp
+MULTILIB_EXCEPTIONS   += mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += mthumb=mthumb/mfloat-abi?softfp
+MULTILIB_ALIASES      += mthumb=mthumb/mfloat-abi?softfp/mfpu?neon
+
+MULTILIB_ALIASES      += mbig-endian=mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mthumb/mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mthumb/mfloat-abi?softfp/mfpu?neon/mbig-endian
+
+# We don't have a big-endian ARMv6-M compatible multilibs.
+MULTILIB_EXCEPTIONS   += *march=armv6-m*mbig-endian
+
+# Use the generic libraries for big-endian ARMv5T
+MULTILIB_ALIASES      += mbig-endian=march?armv5te/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mthumb/march?armv5te/mbig-endian
+MULTILIB_ALIASES      += march?armv5te/mfloat-abi?softfp/mbig-endian=mthumb/march?armv5te/mfloat-abi?softfp/mbig-endian
+
+# Use ARM libraries for big-endian Thumb.
+MULTILIB_ALIASES      += mbig-endian=mthumb/mbig-endian
+
+# Don't bother with big-endian Thumb-2 VFP.  Use the soft-float libraries
+# for now.
+MULTILIB_ALIASES      += mthumb/march?armv7/mbig-endian=mthumb/march?armv7/mfloat-abi?softfp/mbig-endian
+
+# The only -mfloat-abi=hard libraries provided are for little-endian
+# v7-A NEON.
+MULTILIB_EXCEPTIONS   += mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *march=armv5te*mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *march=armv7/*mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *march=armv6-m*mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += mthumb/mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *mfloat-abi=hard*mbig-endian
+MULTILIB_EXCEPTIONS   += *mfloat-abi=hard
+
+# FIXME: We need a sane way of doing this.
+# This isn't really a multilib, it's a hack to add an extra option
+# to the v7-m multilib.
+MULTILIB_OPTIONS      += mfix-cortex-m3-ldrd
+MULTILIB_DIRNAMES     += broken_ldrd
+
+MULTILIB_EXCEPTIONS   += mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += mthumb/mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *march=armv6-m*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *march=armv7-a*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *mcpu=*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *mbig-endian*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *mfloat-abi=softfp*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *march=armv5te*mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *mfpu=neon*mfix-cortex-m3-ldrd
+
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7-a/mfix-cortex-m3-ldrd
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7/mfpu?neon/mfix-cortex-m3-ldrd
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7-a/mfpu?neon/mfix-cortex-m3-ldrd
+
+# As of at least 4.2, gcc passes the wrong -L options if some multilibs are
+# omitted from MULTILIB_OSDIRNAMES
+MULTILIB_OSDIRNAMES    = mthumb=!thumb
+MULTILIB_OSDIRNAMES   += mbig-endian=!be
+MULTILIB_OSDIRNAMES   += march.armv5te=!armv5te
+MULTILIB_OSDIRNAMES   += march.armv5te/mfloat-abi.softfp=!vfp
+MULTILIB_OSDIRNAMES   += march.armv5te/mfloat-abi.softfp/mbig-endian=!vfp-be
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7/mfix-cortex-m3-ldrd=!thumb2
+MULTILIB_OSDIRNAMES   += march.armv7-a/mfloat-abi.softfp/mfpu.neon=!armv7-a-neon
+MULTILIB_OSDIRNAMES   += march.armv7-a/mfloat-abi.hard/mfpu.neon=!armv7-a-hard
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7/mbig-endian=!thumb2-be
+MULTILIB_OSDIRNAMES   += mthumb/march.armv6-m=!armv6-m
diff --git a/gcc/config/arm/t-cs-eabi-lite b/gcc/config/arm/t-cs-eabi-lite
new file mode 100644
index 000000000..b0a849392
--- /dev/null
+++ b/gcc/config/arm/t-cs-eabi-lite
@@ -0,0 +1,48 @@
+# We build 4 multilibs:
+#  ./		  (default)
+#  thumb/	  -mthumb
+#  thumb2/	  -mthumb -march=armv7
+#  armv6-m/	  -mthumb -march=armv6-m
+
+MULTILIB_OPTIONS     = mthumb
+MULTILIB_DIRNAMES    = thumb
+MULTILIB_EXCEPTIONS  =
+MULTILIB_MATCHES     =
+MULTILIB_ALIASES     =
+
+MULTILIB_OPTIONS      += march=armv7/march=armv6-m
+MULTILIB_DIRNAMES     += v7 v6-m
+MULTILIB_EXCEPTIONS   += march=armv7*
+MULTILIB_MATCHES      += march?armv7=march?armv7-a
+MULTILIB_MATCHES      += march?armv7=march?armv7-r
+MULTILIB_MATCHES      += march?armv7=march?armv7-m
+MULTILIB_MATCHES      += march?armv7=march?armv7e-m
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a9
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a8
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a5
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4f
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
+
+MULTILIB_EXCEPTIONS   += march=armv6-m
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m1
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m0
+
+# FIXME: We need a sane way of doing this.
+# This isn't really a multilib, it's a hack to add an extra option
+# to the v7-m multilib.
+MULTILIB_OPTIONS      += mfix-cortex-m3-ldrd
+MULTILIB_DIRNAMES     += broken_ldrd
+
+MULTILIB_EXCEPTIONS   += mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += mthumb/mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *march=armv6-m*mfix-cortex-m3-ldrd
+
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7
+
+# As of at least 4.2, gcc passes the wrong -L options if some multilibs are
+# omitted from MULTILIB_OSDIRNAMES
+MULTILIB_OSDIRNAMES    = mthumb=!thumb
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7/mfix-cortex-m3-ldrd=!thumb2
+MULTILIB_OSDIRNAMES   += mthumb/march.armv6-m=!armv6-m
diff --git a/gcc/config/arm/t-cs-linux b/gcc/config/arm/t-cs-linux
new file mode 100644
index 000000000..70193ea04
--- /dev/null
+++ b/gcc/config/arm/t-cs-linux
@@ -0,0 +1,112 @@
+# Multilibs for SourceryG++ arm-none-linux-gnueabi
+
+MULTILIB_OPTIONS     = mthumb
+MULTILIB_DIRNAMES    = t
+MULTILIB_EXCEPTIONS  = 
+MULTILIB_MATCHES     =
+MULTILIB_ALIASES     =
+
+MULTILIB_OPTIONS      += march=armv4t/march=armv7-a
+MULTILIB_DIRNAMES     += v4t v7a
+
+MULTILIB_MATCHES      += march?armv7-a=march?armv7a
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a9
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a8
+MULTILIB_MATCHES      += march?armv7-a=mcpu?cortex-a5
+MULTILIB_MATCHES      += march?armv4t=march?ep9312
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm7tdmi
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm7tdmi-s
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm710t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm720t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm740t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm9
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm9tdmi
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm920
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm920t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm922t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm940t
+MULTILIB_MATCHES      += march?armv4t=mcpu?ep9312
+MULTILIB_MATCHES      += march?armv4t=march?armv5
+MULTILIB_MATCHES      += march?armv4t=march?armv5t
+MULTILIB_MATCHES      += march?armv4t=march?arm10tdmi
+MULTILIB_MATCHES      += march?armv4t=march?arm1020t
+
+MULTILIB_OPTIONS      += mfloat-abi=softfp/mfloat-abi=hard
+MULTILIB_DIRNAMES     += softfp hard
+MULTILIB_MATCHES      += mfloat-abi?hard=mhard-float
+
+MULTILIB_OPTIONS      += mfpu=neon
+MULTILIB_DIRNAMES     += neon
+MULTILIB_EXCEPTIONS   += mfpu=neon
+MULTILIB_MATCHES      += mfpu?neon=mfpu?neon-fp16
+MULTILIB_MATCHES      += mfpu?neon=mfpu?neon-vfpv4
+MULTILIB_ALIASES      += mfloat-abi?softfp=mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += mfloat-abi?softfp=mthumb/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv7-a/mfloat-abi?hard/mfpu?neon=mthumb/march?armv7-a/mfloat-abi?hard/mfpu?neon
+
+MULTILIB_OPTIONS      += mbig-endian
+MULTILIB_DIRNAMES     += be
+MULTILIB_ALIASES      += mbig-endian=mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=mthumb/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=mthumb/mfloat-abi?softfp/mfpu?neon/mbig-endian
+
+# Do not build Thumb libraries.
+MULTILIB_EXCEPTIONS   += mthumb
+MULTILIB_EXCEPTIONS   += mthumb/mfpu=neon
+
+# Use ARM libraries for ARMv4t Thumb and VFP.
+MULTILIB_ALIASES      += march?armv4t=mthumb/march?armv4t
+MULTILIB_ALIASES      += march?armv4t=march?armv4t/mfloat-abi?softfp
+MULTILIB_ALIASES      += march?armv4t=mthumb/march?armv4t/mfloat-abi?softfp
+MULTILIB_ALIASES      += march?armv4t=march?armv4t/mfpu?neon
+MULTILIB_ALIASES      += march?armv4t=march?armv4t/mfloat-abi?softfp/mfpu?neon
+MULTILIB_ALIASES      += march?armv4t=mthumb/march?armv4t/mfpu?neon
+MULTILIB_ALIASES      += march?armv4t=mthumb/march?armv4t/mfloat-abi?softfp/mfpu?neon
+
+# We do not support ARMv4t big-endian.
+MULTILIB_EXCEPTIONS   += *march=armv4t*mbig-endian
+
+# Behave ARMv7-A as ARMv7 for some cases.
+MULTILIB_EXCEPTIONS   += march=armv7-a
+MULTILIB_EXCEPTIONS   += march=armv7-a/mfpu=neon
+MULTILIB_ALIASES      += mfloat-abi?softfp=march?armv7-a/mfloat-abi?softfp
+MULTILIB_ALIASES      += mbig-endian=march?armv7-a/mbig-endian
+MULTILIB_ALIASES      += mbig-endian=march?armv7-a/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=march?armv7-a/mfloat-abi?softfp/mbig-endian
+MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=march?armv7-a/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7-a=mthumb/march?armv7-a/mfpu?neon
+MULTILIB_ALIASES      += mthumb/march?armv7-a/mbig-endian=mthumb/march?armv7-a/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7-a/mbig-endian=mthumb/march?armv7-a/mfloat-abi?softfp/mfpu?neon/mbig-endian
+MULTILIB_ALIASES      += mthumb/march?armv7-a=mthumb/march?armv7-a/mfloat-abi?softfp
+
+# Thumb-1 VFP isn't really a meaningful combination.  Use the ARM VFP.
+MULTILIB_ALIASES      += mfloat-abi?softfp=mthumb/mfloat-abi?softfp
+MULTILIB_ALIASES      += mfloat-abi?softfp/mbig-endian=mthumb/mfloat-abi?softfp/mbig-endian
+
+# Use ARM libraries for big-endian Thumb.
+MULTILIB_ALIASES      += mbig-endian=mthumb/mbig-endian
+
+# Don't bother with big-endian Thumb-2 VFP.  Use the soft-float libraries
+# for now.
+MULTILIB_ALIASES      += mthumb/march?armv7-a/mbig-endian=mthumb/march?armv7-a/mfloat-abi?softfp/mbig-endian
+
+# The only -mfloat-abi=hard libraries provided are for little-endian
+# v7-A NEON.
+MULTILIB_EXCEPTIONS   += mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *march=armv4t*mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += mthumb/mfloat-abi=hard*
+MULTILIB_EXCEPTIONS   += *mfloat-abi=hard*mbig-endian
+MULTILIB_EXCEPTIONS   += *mfloat-abi=hard
+
+# As of at least 4.2, gcc passes the wrong -L options if some multilibs are
+# omitted from MULTILIB_OSDIRNAMES
+MULTILIB_OSDIRNAMES    = march.armv4t=!armv4t
+MULTILIB_OSDIRNAMES   += mbig-endian=!be
+MULTILIB_OSDIRNAMES   += mfloat-abi.softfp=!vfp
+MULTILIB_OSDIRNAMES   += mfloat-abi.softfp/mbig-endian=!vfp-be
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7-a=!thumb2
+MULTILIB_OSDIRNAMES   += march.armv7-a/mfloat-abi.softfp/mfpu.neon=!armv7-a-neon
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7-a/mfloat-abi.softfp/mfpu.neon=!thumb2-neon
+MULTILIB_OSDIRNAMES   += march.armv7-a/mfloat-abi.hard/mfpu.neon=!armv7-a-hard
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7-a/mbig-endian=!thumb2-be
diff --git a/gcc/config/arm/t-cs-linux-lite b/gcc/config/arm/t-cs-linux-lite
new file mode 100644
index 000000000..ed87fe8ff
--- /dev/null
+++ b/gcc/config/arm/t-cs-linux-lite
@@ -0,0 +1,48 @@
+# We build 3 multilibs:
+#  ./		  (default)
+#  armv4t/	  -march=armv4t [-mthumb]
+#  thumb2/	  -mthumb -march=armv7
+MULTILIB_OPTIONS     = mthumb
+MULTILIB_DIRNAMES    = thumb
+MULTILIB_OPTIONS    += march=armv4t/march=armv7
+MULTILIB_DIRNAMES   += v4t v7
+MULTILIB_EXCEPTIONS += march=armv7
+MULTILIB_EXCEPTIONS += mthumb
+
+MULTILIB_ALIASES     = march?armv4t=mthumb/march?armv4t
+
+# As of at least 4.2, gcc passes the wrong -L options if some multilibs are
+# omitted from MULTILIB_OSDIRNAMES
+MULTILIB_OSDIRNAMES    = march.armv4t=!armv4t
+MULTILIB_OSDIRNAMES   += mthumb/march.armv7=!thumb2
+
+MULTILIB_MATCHES      += march?armv7=march?armv7a
+MULTILIB_MATCHES      += march?armv7=march?armv7r
+MULTILIB_MATCHES      += march?armv7=march?armv7m
+MULTILIB_MATCHES      += march?armv7=march?armv7-a
+MULTILIB_MATCHES      += march?armv7=march?armv7-r
+MULTILIB_MATCHES      += march?armv7=march?armv7-m
+MULTILIB_MATCHES      += march?armv7=march?armv7e-m
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a9
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a8
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a5
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4f
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
+MULTILIB_MATCHES      += march?armv4t=march?ep9312
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm7tdmi
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm7tdmi-s
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm710t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm720t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm740t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm9
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm9tdmi
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm920
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm920t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm922t
+MULTILIB_MATCHES      += march?armv4t=mcpu?arm940t
+MULTILIB_MATCHES      += march?armv4t=mcpu?ep9312
+MULTILIB_MATCHES      += march?armv4t=march?armv5
+MULTILIB_MATCHES      += march?armv4t=march?armv5t
+MULTILIB_MATCHES      += march?armv4t=march?arm10tdmi
+MULTILIB_MATCHES      += march?armv4t=march?arm1020t
diff --git a/gcc/config/arm/t-cs-uclinux-eabi b/gcc/config/arm/t-cs-uclinux-eabi
new file mode 100644
index 000000000..d12597b1d
--- /dev/null
+++ b/gcc/config/arm/t-cs-uclinux-eabi
@@ -0,0 +1,56 @@
+# EABI uClinux multilib selection.  Other setting are inherited from t-arm-elf
+
+# We build 3 multilibs:
+#  .	    (default)
+#  thumb2/  -mthumb -march=armv7 -mfix-cortex-m3-ldrd
+#  armv6-m/ -mthumb -march=armv6-m
+
+MULTILIB_OPTIONS     = mthumb
+MULTILIB_DIRNAMES    = thumb
+MULTILIB_EXCEPTIONS  = 
+MULTILIB_MATCHES     =
+
+MULTILIB_OPTIONS      += march=armv7/march=armv6-m
+MULTILIB_DIRNAMES     += armv7 armv6-m
+
+MULTILIB_EXCEPTIONS   += mthumb
+
+MULTILIB_EXCEPTIONS   += march=armv7
+MULTILIB_MATCHES      += march?armv7=march?armv7a
+MULTILIB_MATCHES      += march?armv7=march?armv7r
+MULTILIB_MATCHES      += march?armv7=march?armv7m
+MULTILIB_MATCHES      += march?armv7=march?armv7-a
+MULTILIB_MATCHES      += march?armv7=march?armv7-r
+MULTILIB_MATCHES      += march?armv7=march?armv7-m
+MULTILIB_MATCHES      += march?armv7=march?armv7e-m
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a9
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a8
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a5
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4f
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m4
+MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
+
+MULTILIB_EXCEPTIONS   += march=armv6-m
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m1
+MULTILIB_MATCHES      += march?armv6-m=mcpu?cortex-m0
+
+MULTILIB_ALIASES       =
+
+# FIXME: We need a sane way of doing this.
+# This isn't really a multilib, it's a hack to add an extra option
+# to the v7-m multilib.
+MULTILIB_OPTIONS      += mfix-cortex-m3-ldrd
+MULTILIB_DIRNAMES     += broken_ldrd
+
+MULTILIB_EXCEPTIONS   += mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += mthumb/mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += march=armv7/mfix-cortex-m3-ldrd
+MULTILIB_EXCEPTIONS   += *march=armv6-m*mfix-cortex-m3-ldrd
+
+MULTILIB_ALIASES      += mthumb/march?armv7/mfix-cortex-m3-ldrd=mthumb/march?armv7
+
+
+MULTILIB_OSDIRNAMES    = mthumb/march.armv7/mfix-cortex-m3-ldrd=!thumb2
+MULTILIB_OSDIRNAMES   += mthumb/march.armv6-m=!armv6-m
+
diff --git a/gcc/config/arm/t-cygming b/gcc/config/arm/t-cygming
new file mode 100644
index 000000000..be60c6417
--- /dev/null
+++ b/gcc/config/arm/t-cygming
@@ -0,0 +1,10 @@
+# cygwin and mingw always have a limits.h, but, depending upon how we are
+# doing the build, it may not be installed yet.
+LIMITS_H_TEST = true
+
+# If we are building next to winsup, this will let us find the real
+# limits.h when building libgcc2.  Otherwise, winsup must be installed
+# first.
+LIBGCC2_INCLUDES = -I$(srcdir)/../winsup/w32api/include
+
+STMP_FIXINC=stmp-fixinc
diff --git a/gcc/config/arm/t-linux-eabi b/gcc/config/arm/t-linux-eabi
index 5c364be94..ed379c9f2 100644
--- a/gcc/config/arm/t-linux-eabi
+++ b/gcc/config/arm/t-linux-eabi
@@ -6,8 +6,8 @@ TARGET_LIBGCC2_CFLAGS = -fPIC
 MULTILIB_OPTIONS	=
 MULTILIB_DIRNAMES	=
 
-# Use a version of div0 which raises SIGFPE.
-LIB1ASMFUNCS := $(filter-out _dvmd_tls,$(LIB1ASMFUNCS)) _dvmd_lnx
+# Use a version of div0 which raises SIGFPE, and a special __clear_cache.
+LIB1ASMFUNCS := $(filter-out _dvmd_tls,$(LIB1ASMFUNCS)) _dvmd_lnx _clear_cache
 
 # Multilib the standard Linux files.  Don't include crti.o or crtn.o,
 # which are provided by glibc.
diff --git a/gcc/config/arm/t-mingw32 b/gcc/config/arm/t-mingw32
new file mode 100644
index 000000000..6d043a37f
--- /dev/null
+++ b/gcc/config/arm/t-mingw32
@@ -0,0 +1,2 @@
+# Match SYSTEM_INCLUDE_DIR
+NATIVE_SYSTEM_HEADER_DIR = /mingw/include
diff --git a/gcc/config/arm/t-montavista-linux b/gcc/config/arm/t-montavista-linux
new file mode 100644
index 000000000..e77cef2e9
--- /dev/null
+++ b/gcc/config/arm/t-montavista-linux
@@ -0,0 +1,33 @@
+# MontaVista GNU/Linux Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = tarmv6/tthumb2
+MULTILIB_DIRNAMES = armv6 thumb2
+
+MULTILIB_EXCEPTIONS =
+
+MULTILIB_OSDIRNAMES =
+
+MULTILIB_ALIASES =
+
+MULTILIB_MATCHES =
+
+# These files must be built for each multilib.
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
diff --git a/gcc/config/arm/t-nucleus b/gcc/config/arm/t-nucleus
new file mode 100644
index 000000000..c4462364e
--- /dev/null
+++ b/gcc/config/arm/t-nucleus
@@ -0,0 +1,3 @@
+
+# Add shared object crtstuff
+EXTRA_MULTILIB_PARTS += crtbeginS.o crtendS.o
diff --git a/gcc/config/arm/t-symbian b/gcc/config/arm/t-symbian
index cadbd2236..679b83371 100644
--- a/gcc/config/arm/t-symbian
+++ b/gcc/config/arm/t-symbian
@@ -1,22 +1,3 @@
-LIB1ASMFUNCS = _bb_init_func _call_via_rX _interwork_call_via_rX _clzsi2 _clzdi2
-
-# These functions have __aeabi equivalents and will never be called by GCC.  
-# By putting them in LIB1ASMFUNCS, we avoid the standard libgcc2.c code being
-# used -- and we make sure that definitions are not available in lib1funcs.asm,
-# either, so they end up undefined.
-LIB1ASMFUNCS += \
-	_ashldi3 _ashrdi3 _divdi3 _floatdidf _udivmoddi4 _umoddi3 \
-	_udivdi3 _lshrdi3 _moddi3 _muldi3 _negdi2 _cmpdi2 \
-	_fixdfdi _fixsfdi _fixunsdfdi _fixunssfdi _floatdisf \
-	_negdf2 _addsubdf3 _muldivdf3 _cmpdf2 _unorddf2 _fixdfsi _fixunsdfsi \
-	_truncdfsf2 _negsf2 _addsubsf3 _muldivsf3 _cmpsf2 _unordsf2 \
-	_fixsfsi _fixunssfsi
-
-# Include the gcc personality routine
-UNWIND_H = $(srcdir)/config/arm/unwind-arm.h
-LIB2ADDEH = $(srcdir)/unwind-c.c $(srcdir)/config/arm/pr-support.c
-LIB2ADDEHDEP = $(UNWIND_H)
-
 # Create a multilib for processors with VFP floating-point, and a
 # multilib for those without -- using the soft-float ABI in both
 # cases.  Symbian OS object should be compiled with interworking
@@ -24,6 +5,9 @@ LIB2ADDEHDEP = $(UNWIND_H)
 MULTILIB_OPTIONS     = mfloat-abi=softfp
 MULTILIB_DIRNAMES    = softfp
 
+LIB2FUNCS_EXTRA += $(srcdir)/config/arm/eabi-memcpy.c \
+  $(srcdir)/config/arm/eabi-memset.c
+
 # There is no C library to link against on Symbian OS -- at least when 
 # building GCC.
 SHLIB_LC = 
diff --git a/gcc/config/arm/t-wince-pe b/gcc/config/arm/t-wince-pe
index 84b8170ec..24c5361f7 100644
--- a/gcc/config/arm/t-wince-pe
+++ b/gcc/config/arm/t-wince-pe
@@ -1,5 +1,50 @@
 LIB1ASMSRC = arm/lib1funcs.asm
-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX _clzsi2 _clzdi2
+
+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX \
+	_bb_init_func _lshrdi3 _ashrdi3 _ashldi3 \
+	_negdf2 _arm_addsubdf3 _arm_muldivdf3 _arm_cmpdf2 _arm_unorddf2 \
+	_arm_fixdfsi _arm_fixunsdfsi \
+	_arm_truncdfsf2 _arm_negsf2 _arm_addsubsf3 _arm_muldivsf3 _arm_cmpsf2 _arm_unordsf2 \
+	_arm_fixsfsi _arm_fixunssfsi _arm_floatdidf _arm_floatdisf \
+	_clzsi2 _clzdi2
+
+#
+# Filter out functions from dp-bit.c that are already in lib1funcs.asm
+#
+DPBIT_FUNCS := $(filter-out _mul_df _div_df _addsub_df _compare_df \
+	_eq_df _ne_df _gt_df _ge_df _lt_df _le_df \
+	_negate_df _unord_df \
+	_df_to_sf _si_to_df _df_to_si _usi_to_df, $(DPBIT_FUNCS))
+FPBIT_FUNCS := $(filter-out _mul_sf _div_sf _addsub_sf _compare_sf \
+	_eq_sf _ne_sf _gt_sf _ge_sf _lt_sf _le_sf \
+	_negate_sf _unord_sf \
+	_sf_to_df _si_to_sf _sf_to_si _usi_to_sf, $(FPBIT_FUNCS))
+
+LIB2FUNCS_EXCLUDE = _floatundisf _floatundidf _floatdidf _floatdisf \
+	_fixunssfsi _fixunsdfsi
+
+#LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX \
+#	_bb_init_func _lshrdi3 _ashrdi3 _ashldi3 \
+#	_arm_negdf2 _arm_addsubdf3 _arm_muldivdf3 _arm_cmpdf2 _arm_unorddf2 \
+#	_arm_fixdfsi _arm_fixunsdfsi \
+#	_arm_truncdfsf2 _arm_negsf2 _arm_addsubsf3 _arm_muldivsf3 _arm_cmpsf2 _arm_unordsf2 \
+#	_arm_fixsfsi _arm_fixunssfsi _arm_floatdidf _arm_floatdisf \
+#	_arm_fixunsdfsi \
+#	_clzsi2 _clzdi2
+
+# For most CPUs we have an assembly soft-float implementations.
+# However this is not true for ARMv6M.  Here we want to use the soft-fp C
+# implementation.  The soft-fp code is only build for ARMv6M.  This pulls
+# in the asm implementation for other CPUs.
+#LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func \
+#	_call_via_rX _interwork_call_via_rX \
+#	_lshrdi3 _ashrdi3 _ashldi3 \
+#	_arm_negdf2 _arm_addsubdf3 _arm_muldivdf3 _arm_cmpdf2 _arm_unorddf2 \
+#	_arm_fixdfsi _arm_fixunsdfsi \
+#	_arm_truncdfsf2 _arm_negsf2 _arm_addsubsf3 _arm_muldivsf3 \
+#	_arm_cmpsf2 _arm_unordsf2 _arm_fixsfsi _arm_fixunssfsi \
+#	_arm_floatdidf _arm_floatdisf _arm_floatundidf _arm_floatundisf \
+#	_clzsi2 _clzdi2
 
 # We want fine grained libraries, so use the new code to build the
 # floating point emulation libraries.
@@ -20,12 +65,34 @@ dp-bit.c: $(srcdir)/config/fp-bit.c
 	echo '#endif' >> dp-bit.c
 	cat $(srcdir)/config/fp-bit.c >> dp-bit.c
 
-pe.o: $(srcdir)/config/arm/pe.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
-  $(RTL_H) output.h flags.h $(TREE_H) expr.h toplev.h $(TM_P_H)
-	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/arm/pe.c
+pe.o: $(srcdir)/config/arm/pe.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h output.h $(TREE_H) flags.h \
+  $(TM_P_H) toplev.h $(HASHTAB_H) $(GGC_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	$(srcdir)/config/arm/pe.c
+
+pe-cxx.o: $(srcdir)/config/arm/pe-cxx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h output.h $(TREE_H) flags.h \
+  $(TM_P_H) toplev.h $(HASHTAB_H) $(GGC_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	$(srcdir)/config/arm/pe-cxx.c
+
+pe-stubs.o: $(srcdir)/config/arm/pe-stubs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h output.h $(TREE_H) flags.h \
+  $(TM_P_H) toplev.h $(HASHTAB_H) $(GGC_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	$(srcdir)/config/arm/pe-stubs.c
+
+#hack! using i386 file directly...
+msformat-c.o: $(srcdir)/config/i386/msformat-c.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h output.h $(TREE_H) flags.h \
+  $(TM_P_H) toplev.h $(HASHTAB_H) $(GGC_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	$(srcdir)/config/i386/msformat-c.c
+
+MULTILIB_OPTIONS =
+MULTILIB_DIRNAMES =
 
-MULTILIB_OPTIONS = mhard-float
-MULTILIB_DIRNAMES = fpu
 # Note - Thumb multilib omitted because Thumb support for
 # arm-wince-pe target does not appear to be working in binutils
 # yet... 
@@ -34,4 +101,65 @@ MULTILIB_DIRNAMES = fpu
 
 LIBGCC = stmp-multilib
 INSTALL_LIBGCC = install-multilib
-TARGET_LIBGCC2_CFLAGS = 
+# Currently there is a bug somewhere in GCC's alias analysis
+# or scheduling code that is breaking _fpmul_parts in fp-bit.c.
+# Disabling function inlining is a workaround for this problem.
+TARGET_LIBGCC2_CFLAGS = -fno-inline
+
+STMP_FIXINC=stmp-fixinc
+
+# Build a shared libgcc library for PECOFF with a DEF file
+# with the GNU linker.
+#
+# mkmap-flat.awk is used with the pe_dll option to produce a DEF instead
+# of an ELF map file.
+#
+# Warning: If SHLIB_SOVERSION or SHLIB_SONAME are updated, LIBGCC_SONAME
+# in mingw32.h and SHLIB_MKMAP_OPTS below must be updated also.
+
+SHLIB_EXT = .dll
+SHLIB_IMPLIB = @shlib_base_name@.a
+SHLIB_SOVERSION = 1
+SHLIB_SONAME = @shlib_base_name@_$(EH_MODEL)-$(SHLIB_SOVERSION)$(SHLIB_EXT)
+SHLIB_MAP = @shlib_map_file@
+SHLIB_OBJS = @shlib_objs@
+SHLIB_DIR = @multilib_dir@/shlib
+SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual@
+
+# Version for mingw32ce
+SHLIB_LC = -lmingw32 -lmingwex -lceoldname -lcoredll
+# Version for cegcc
+#SHLIB_LC = -lc -lcoredll
+
+# This should go somewhere else.
+# We are using SjLj EH.
+EH_MODEL = sjlj
+
+SHLIB_LINK = $(LN_S) -f $(SHLIB_MAP) $(SHLIB_MAP).def && \
+	if [ ! -d $(SHLIB_DIR) ]; then \
+		mkdir $(SHLIB_DIR); \
+	else true; fi && \
+	$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
+	$(SHLIB_MAP).def \
+	-Wl,--out-implib,$(SHLIB_DIR)/$(SHLIB_IMPLIB).tmp \
+	-o $(SHLIB_DIR)/$(SHLIB_SONAME).tmp @multilib_flags@ \
+	$(SHLIB_OBJS) $(SHLIB_LC) && \
+	if [ -f $(SHLIB_DIR)/$(SHLIB_SONAME) ]; then \
+	  mv -f $(SHLIB_DIR)/$(SHLIB_SONAME) \
+		$(SHLIB_DIR)/$(SHLIB_SONAME).backup; \
+	else true; fi && \
+	mv $(SHLIB_DIR)/$(SHLIB_SONAME).tmp $(SHLIB_DIR)/$(SHLIB_SONAME) && \
+	mv $(SHLIB_DIR)/$(SHLIB_IMPLIB).tmp $(SHLIB_DIR)/$(SHLIB_IMPLIB)
+# $(slibdir) double quoted to protect it from expansion while building
+# libgcc.mk.  We want this delayed until actual install time.
+SHLIB_INSTALL = \
+	$$(mkinstalldirs) $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL); \
+	$(INSTALL_PROGRAM) $(SHLIB_DIR)/$(SHLIB_SONAME) \
+	  $$(DESTDIR)$$(bindir)/$(SHLIB_SONAME); \
+	$(INSTALL_DATA) $(SHLIB_DIR)/$(SHLIB_IMPLIB) \
+	  $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_IMPLIB)
+SHLIB_MKMAP = $(srcdir)/mkmap-flat.awk
+# We'd like to use SHLIB_SONAME here too, but shlib_base_name
+# does not get substituted before mkmap-flat.awk is run.
+SHLIB_MKMAP_OPTS = -v pe_dll=libgcc_s_$(EH_MODEL)-$(SHLIB_SOVERSION)$(SHLIB_EXT)
+SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver
diff --git a/gcc/config/arm/t-wrs-linux b/gcc/config/arm/t-wrs-linux
new file mode 100644
index 000000000..54fbcd612
--- /dev/null
+++ b/gcc/config/arm/t-wrs-linux
@@ -0,0 +1,36 @@
+# Wind River GNU/Linux Configuration.
+# Copyright (C) 2006, 2007, 2008
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = muclibc
+MULTILIB_OPTIONS += tarm926ej-s/tthumb2-v7-a/tthumb2-v7-a-neon
+MULTILIB_OPTIONS += mfloat-abi=softfp
+MULTILIB_DIRNAMES = uclibc
+MULTILIB_DIRNAMES += tarm926ej-s thumb2-v7-a thumb2-v7-a-neon
+MULTILIB_DIRNAMES += softfp
+
+MULTILIB_EXCEPTIONS += *thumb2*/*mfloat-abi=softfp*
+
+MULTILIB_ALIASES = tthumb2-v7-a-neon=tthumb2-v7-a-neon/mfloat-abi?softfp
+MULTILIB_ALIASES += muclibc/tthumb2-v7-a-neon=muclibc/tthumb2-v7-a-neon/mfloat-abi?softfp
+MULTILIB_OSDIRNAMES =
+
+# These files must be built for each multilib.
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
diff --git a/gcc/config/arm/thumb2.md b/gcc/config/arm/thumb2.md
index 5d55a575c..7fee2eca3 100644
--- a/gcc/config/arm/thumb2.md
+++ b/gcc/config/arm/thumb2.md
@@ -24,6 +24,8 @@
 ;; changes made in armv5t as "thumb2".  These are considered part
 ;; the 16-bit Thumb-1 instruction set.
 
+(include "hwdiv.md")
+
 (define_insn "*thumb2_incscc"
   [(set (match_operand:SI 0 "s_register_operand" "=r,r")
         (plus:SI (match_operator:SI 2 "arm_comparison_operator"
@@ -55,7 +57,7 @@
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(and:SI (not:SI (match_operator:SI 4 "shift_operator"
 			 [(match_operand:SI 2 "s_register_operand" "r")
-			  (match_operand:SI 3 "const_int_operand" "M")]))
+			  (match_operand:SI 3 "const_shift_count" "M")]))
 		(match_operand:SI 1 "s_register_operand" "r")))]
   "TARGET_THUMB2"
   "bic%?\\t%0, %1, %2%S4"
@@ -124,7 +126,7 @@
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(not:SI (match_operator:SI 3 "shift_operator"
 		 [(match_operand:SI 1 "s_register_operand" "r")
-		  (match_operand:SI 2 "const_int_operand"  "M")])))]
+		  (match_operand:SI 2 "const_shift_count"  "M")])))]
   "TARGET_THUMB2"
   "mvn%?\\t%0, %1%S3"
   [(set_attr "predicable" "yes")
@@ -136,7 +138,7 @@
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV (not:SI (match_operator:SI 3 "shift_operator"
 			  [(match_operand:SI 1 "s_register_operand" "r")
-			   (match_operand:SI 2 "const_int_operand"  "M")]))
+			   (match_operand:SI 2 "const_shift_count"  "M")]))
 			 (const_int 0)))
    (set (match_operand:SI 0 "s_register_operand" "=r")
 	(not:SI (match_op_dup 3 [(match_dup 1) (match_dup 2)])))]
@@ -151,7 +153,7 @@
   [(set (reg:CC_NOOV CC_REGNUM)
 	(compare:CC_NOOV (not:SI (match_operator:SI 3 "shift_operator"
 			  [(match_operand:SI 1 "s_register_operand" "r")
-			   (match_operand:SI 2 "const_int_operand"  "M")]))
+			   (match_operand:SI 2 "const_shift_count"  "M")]))
 			 (const_int 0)))
    (clobber (match_scratch:SI 0 "=r"))]
   "TARGET_THUMB2"
@@ -172,34 +174,6 @@
    (set_attr "length" "8")]
 )
 
-(define_insn "*thumb2_abssi2"
-  [(set (match_operand:SI         0 "s_register_operand" "=r,&r")
-	(abs:SI (match_operand:SI 1 "s_register_operand" "0,r")))
-   (clobber (reg:CC CC_REGNUM))]
-  "TARGET_THUMB2"
-  "@
-   cmp\\t%0, #0\;it\tlt\;rsblt\\t%0, %0, #0
-   eor%?\\t%0, %1, %1, asr #31\;sub%?\\t%0, %0, %1, asr #31"
-  [(set_attr "conds" "clob,*")
-   (set_attr "shift" "1")
-   ;; predicable can't be set based on the variant, so left as no
-   (set_attr "length" "10,8")]
-)
-
-(define_insn "*thumb2_neg_abssi2"
-  [(set (match_operand:SI 0 "s_register_operand" "=r,&r")
-	(neg:SI (abs:SI (match_operand:SI 1 "s_register_operand" "0,r"))))
-   (clobber (reg:CC CC_REGNUM))]
-  "TARGET_THUMB2"
-  "@
-   cmp\\t%0, #0\;it\\tgt\;rsbgt\\t%0, %0, #0
-   eor%?\\t%0, %1, %1, asr #31\;rsb%?\\t%0, %0, %1, asr #31"
-  [(set_attr "conds" "clob,*")
-   (set_attr "shift" "1")
-   ;; predicable can't be set based on the variant, so left as no
-   (set_attr "length" "10,8")]
-)
-
 (define_insn "*thumb2_movdi"
   [(set (match_operand:DI 0 "nonimmediate_di_operand" "=r, r, r, r, m")
 	(match_operand:DI 1 "di_operand"              "rDa,Db,Dc,mi,r"))]
@@ -223,9 +197,14 @@
    (set_attr "neg_pool_range" "*,*,*,0,*")]
 )
 
+;; We have two alternatives here for memory loads (and similarly for stores)
+;; to reflect the fact that the permissible constant pool ranges differ
+;; between ldr instructions taking low regs and ldr instructions taking high
+;; regs.  The high register alternatives are not taken into account when
+;; choosing register preferences in order to reflect their expense.
 (define_insn "*thumb2_movsi_insn"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,rk,m")
-	(match_operand:SI 1 "general_operand"	   "rk ,I,K,N,mi,rk"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,l,*hk,m,*m")
+        (match_operand:SI 1 "general_operand"      "rk ,I,K,j,mi,*mi,l,*hk"))]
   "TARGET_THUMB2 && ! TARGET_IWMMXT
    && !(TARGET_HARD_FLOAT && TARGET_VFP)
    && (   register_operand (operands[0], SImode)
@@ -236,11 +215,13 @@
    mvn%?\\t%0, #%B1
    movw%?\\t%0, %1
    ldr%?\\t%0, %1
+   ldr%?\\t%0, %1
+   str%?\\t%1, %0
    str%?\\t%1, %0"
-  [(set_attr "type" "*,*,*,*,load1,store1")
+  [(set_attr "type" "*,*,*,*,load1,load1,store1,store1")
    (set_attr "predicable" "yes")
-   (set_attr "pool_range" "*,*,*,*,4096,*")
-   (set_attr "neg_pool_range" "*,*,*,*,0,*")]
+   (set_attr "pool_range" "*,*,*,*,1020,4096,*,*")
+   (set_attr "neg_pool_range" "*,*,*,*,0,0,*,*")]
 )
 
 ;; ??? We can probably do better with thumb2
@@ -329,8 +310,8 @@
   "
   [(set_attr "length" "8,12,16,8,8")
    (set_attr "type" "*,*,*,load2,store2")
-   (set_attr "pool_range" "1020")
-   (set_attr "neg_pool_range" "0")]
+   (set_attr "pool_range" "*,*,*,4096,*")
+   (set_attr "neg_pool_range" "*,*,*,0,*")]
 )
 
 (define_insn "*thumb2_cmpsi_shiftsi"
@@ -338,7 +319,7 @@
 	(compare:CC (match_operand:SI   0 "s_register_operand" "r")
 		    (match_operator:SI  3 "shift_operator"
 		     [(match_operand:SI 1 "s_register_operand" "r")
-		      (match_operand:SI 2 "const_int_operand"  "M")])))]
+		      (match_operand:SI 2 "const_shift_count"  "M")])))]
   "TARGET_THUMB2"
   "cmp%?\\t%0, %1%S3"
   [(set_attr "conds" "set")
@@ -350,7 +331,7 @@
   [(set (reg:CC_SWP CC_REGNUM)
 	(compare:CC_SWP (match_operator:SI 3 "shift_operator"
 			 [(match_operand:SI 1 "s_register_operand" "r")
-			  (match_operand:SI 2 "const_int_operand" "M")])
+			  (match_operand:SI 2 "const_shift_count" "M")])
 			(match_operand:SI 0 "s_register_operand" "r")))]
   "TARGET_THUMB2"
   "cmp%?\\t%0, %1%S3"
@@ -364,7 +345,7 @@
 	(compare:CC (match_operand:SI 0 "s_register_operand" "r")
 		    (neg:SI (match_operator:SI 3 "shift_operator"
 			     [(match_operand:SI 1 "s_register_operand" "r")
-			      (match_operand:SI 2 "const_int_operand" "M")]))))]
+			      (match_operand:SI 2 "const_shift_count" "M")]))))]
   "TARGET_THUMB2"
   "cmn%?\\t%0, %1%S3"
   [(set_attr "conds" "set")
@@ -476,8 +457,8 @@
         (match_operator:SI 1 "shiftable_operator"
           [(match_operator:SI 3 "shift_operator"
              [(match_operand:SI 4 "s_register_operand" "r")
-              (match_operand:SI 5 "const_int_operand" "M")])
-           (match_operand:SI 2 "s_register_operand" "r")]))]
+              (match_operand:SI 5 "const_shift_count" "M")])
+           (match_operand:SI 2 "s_register_operand" "rk")]))]
   "TARGET_THUMB2"
   "%i1%?\\t%0, %2, %4%S3"
   [(set_attr "predicable" "yes")
@@ -509,7 +490,7 @@
         (compare:CC_NOOV (match_operator:SI 1 "shiftable_operator"
 		          [(match_operator:SI 3 "shift_operator"
 		            [(match_operand:SI 4 "s_register_operand" "r")
-		             (match_operand:SI 5 "const_int_operand" "M")])
+		             (match_operand:SI 5 "const_shift_count" "M")])
 		           (match_operand:SI 2 "s_register_operand" "r")])
 			 (const_int 0)))
    (set (match_operand:SI 0 "s_register_operand" "=r")
@@ -527,7 +508,7 @@
         (compare:CC_NOOV (match_operator:SI 1 "shiftable_operator"
 		          [(match_operator:SI 3 "shift_operator"
 		            [(match_operand:SI 4 "s_register_operand" "r")
-		             (match_operand:SI 5 "const_int_operand" "M")])
+		             (match_operand:SI 5 "const_shift_count" "M")])
 		           (match_operand:SI 2 "s_register_operand" "r")])
 			 (const_int 0)))
    (clobber (match_scratch:SI 0 "=r"))]
@@ -543,7 +524,7 @@
 	(minus:SI (match_operand:SI 1 "s_register_operand" "r")
 		  (match_operator:SI 2 "shift_operator"
 		   [(match_operand:SI 3 "s_register_operand" "r")
-		    (match_operand:SI 4 "const_int_operand" "M")])))]
+		    (match_operand:SI 4 "const_shift_count" "M")])))]
   "TARGET_THUMB2"
   "sub%?\\t%0, %1, %3%S2"
   [(set_attr "predicable" "yes")
@@ -557,7 +538,7 @@
 	 (minus:SI (match_operand:SI 1 "s_register_operand" "r")
 		   (match_operator:SI 2 "shift_operator"
 		    [(match_operand:SI 3 "s_register_operand" "r")
-		     (match_operand:SI 4 "const_int_operand" "M")]))
+		     (match_operand:SI 4 "const_shift_count" "M")]))
 	 (const_int 0)))
    (set (match_operand:SI 0 "s_register_operand" "=r")
 	(minus:SI (match_dup 1) (match_op_dup 2 [(match_dup 3)
@@ -575,7 +556,7 @@
 	 (minus:SI (match_operand:SI 1 "s_register_operand" "r")
 		   (match_operator:SI 2 "shift_operator"
 		    [(match_operand:SI 3 "s_register_operand" "r")
-		     (match_operand:SI 4 "const_int_operand" "M")]))
+		     (match_operand:SI 4 "const_shift_count" "M")]))
 	 (const_int 0)))
    (clobber (match_scratch:SI 0 "=r"))]
   "TARGET_THUMB2"
@@ -1131,26 +1112,6 @@
    (set_attr "length" "2")]
 )
 
-(define_insn "divsi3"
-  [(set (match_operand:SI	  0 "s_register_operand" "=r")
-	(div:SI (match_operand:SI 1 "s_register_operand"  "r")
-		(match_operand:SI 2 "s_register_operand"  "r")))]
-  "TARGET_THUMB2 && arm_arch_hwdiv"
-  "sdiv%?\t%0, %1, %2"
-  [(set_attr "predicable" "yes")
-   (set_attr "insn" "sdiv")]
-)
-
-(define_insn "udivsi3"
-  [(set (match_operand:SI	   0 "s_register_operand" "=r")
-	(udiv:SI (match_operand:SI 1 "s_register_operand"  "r")
-		 (match_operand:SI 2 "s_register_operand"  "r")))]
-  "TARGET_THUMB2 && arm_arch_hwdiv"
-  "udiv%?\t%0, %1, %2"
-  [(set_attr "predicable" "yes")
-   (set_attr "insn" "udiv")]
-)
-
 (define_insn "*thumb2_subsi_short"
   [(set (match_operand:SI 0 "low_register_operand" "=l")
 	(minus:SI (match_operand:SI 1 "low_register_operand" "l")
@@ -1162,6 +1123,121 @@
    (set_attr "length" "2")]
 )
 
+(define_insn "*thumb2_addsi3_compare0"
+  [(set (reg:CC_NOOV CC_REGNUM)
+	(compare:CC_NOOV
+	  (plus:SI (match_operand:SI 1 "s_register_operand" "l,  0, r")
+		   (match_operand:SI 2 "arm_add_operand"    "lPt,Ps,rIL"))
+	  (const_int 0)))
+   (set (match_operand:SI 0 "s_register_operand" "=l,l,r")
+	(plus:SI (match_dup 1) (match_dup 2)))]
+  "TARGET_THUMB2"
+  "*
+    HOST_WIDE_INT val;
+
+    if (GET_CODE (operands[2]) == CONST_INT)
+      val = INTVAL (operands[2]);
+    else
+      val = 0;
+
+    if (val < 0 && const_ok_for_arm (ARM_SIGN_EXTEND (-val)))
+      return \"subs\\t%0, %1, #%n2\";
+    else
+      return \"adds\\t%0, %1, %2\";
+  "
+  [(set_attr "conds" "set")
+   (set_attr "length" "2,2,4")]
+)
+
+(define_insn "*thumb2_addsi3_compare0_scratch"
+  [(set (reg:CC_NOOV CC_REGNUM)
+	(compare:CC_NOOV
+	  (plus:SI (match_operand:SI 0 "s_register_operand" "l,  r")
+		   (match_operand:SI 1 "arm_add_operand"    "lPu,rIL"))
+	  (const_int 0)))]
+  "TARGET_THUMB2"
+  "*
+    HOST_WIDE_INT val;
+
+    if (GET_CODE (operands[1]) == CONST_INT)
+      val = INTVAL (operands[1]);
+    else
+      val = 0;
+
+    if (val < 0 && const_ok_for_arm (ARM_SIGN_EXTEND (-val)))
+      return \"cmp\\t%0, #%n1\";
+    else
+      return \"cmn\\t%0, %1\";
+  "
+  [(set_attr "conds" "set")
+   (set_attr "length" "2,4")]
+)
+
+;; 16-bit encodings of "muls" and "mul<c>".  We only use these when
+;; optimizing for size since "muls" is slow on all known
+;; implementations and since "mul<c>" will be generated by
+;; "*arm_mulsi3_v6" anyhow.  The assembler will use a 16-bit encoding
+;; for "mul<c>" whenever possible anyhow.
+(define_peephole2
+  [(set (match_operand:SI 0 "low_register_operand" "")
+        (mult:SI (match_operand:SI 1 "low_register_operand" "")
+                 (match_dup 0)))]
+  "TARGET_THUMB2 && optimize_size && peep2_regno_dead_p (0, CC_REGNUM)"
+  [(parallel
+    [(set (match_dup 0)
+           (mult:SI (match_dup 0) (match_dup 1)))
+     (clobber (reg:CC CC_REGNUM))])]
+  ""
+)
+
+(define_peephole2
+  [(set (match_operand:SI 0 "low_register_operand" "")
+        (mult:SI (match_dup 0)
+	         (match_operand:SI 1 "low_register_operand" "")))]
+  "TARGET_THUMB2 && optimize_size && peep2_regno_dead_p (0, CC_REGNUM)"
+  [(parallel
+    [(set (match_dup 0)
+           (mult:SI (match_dup 0) (match_dup 1)))
+     (clobber (reg:CC CC_REGNUM))])]
+  ""
+)
+
+(define_insn "*thumb2_mulsi_short"
+  [(set (match_operand:SI 0 "low_register_operand" "=l")
+        (mult:SI (match_operand:SI 1 "low_register_operand" "%0")
+                 (match_operand:SI 2 "low_register_operand" "l")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_THUMB2 && optimize_size && reload_completed"
+  "mul%!\\t%0, %2, %0"
+  [(set_attr "predicable" "yes")
+   (set_attr "length" "2")
+   (set_attr "insn" "muls")])
+
+(define_insn "*thumb2_mulsi_short_compare0"
+  [(set (reg:CC_NOOV CC_REGNUM)
+        (compare:CC_NOOV
+         (mult:SI (match_operand:SI 1 "register_operand" "%0")
+	          (match_operand:SI 2 "register_operand" "l"))
+         (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=l")
+	(mult:SI (match_dup 1) (match_dup 2)))]
+  "TARGET_THUMB2 && optimize_size"
+  "muls\\t%0, %2, %0"
+  [(set_attr "length" "2")
+   (set_attr "insn" "muls")])
+
+(define_insn "*thumb2_mulsi_short_compare0_scratch"
+  [(set (reg:CC_NOOV CC_REGNUM)
+        (compare:CC_NOOV
+         (mult:SI (match_operand:SI 1 "register_operand" "%0")
+	          (match_operand:SI 2 "register_operand" "l"))
+         (const_int 0)))
+   (clobber (match_scratch:SI 0 "=l"))]
+  "TARGET_THUMB2 && optimize_size"
+  "muls\\t%0, %2, %0"
+  [(set_attr "length" "2")
+   (set_attr "insn" "muls")])
+
 (define_insn "*thumb2_cbz"
   [(set (pc) (if_then_else
 	      (eq (match_operand:SI 0 "s_register_operand" "l,?r")
diff --git a/gcc/config/arm/uclinux-eabi.h b/gcc/config/arm/uclinux-eabi.h
index 4455288b8..8345b4156 100644
--- a/gcc/config/arm/uclinux-eabi.h
+++ b/gcc/config/arm/uclinux-eabi.h
@@ -50,6 +50,10 @@
 #undef ARM_DEFAULT_ABI
 #define ARM_DEFAULT_ABI ARM_ABI_AAPCS_LINUX
 
+#undef LINK_GCC_C_SEQUENCE_SPEC
+#define LINK_GCC_C_SEQUENCE_SPEC \
+  "--start-group %G %L --end-group"
+
 /* Clear the instruction cache from `beg' to `end'.  This makes an
    inline system call to SYS_cacheflush.  */
 #undef CLEAR_INSN_CACHE
diff --git a/gcc/config/arm/unwind-arm.c b/gcc/config/arm/unwind-arm.c
index 4eb18215f..6133cefce 100644
--- a/gcc/config/arm/unwind-arm.c
+++ b/gcc/config/arm/unwind-arm.c
@@ -1000,7 +1000,6 @@ __gnu_Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument,
   while (code != _URC_END_OF_STACK
 	 && code != _URC_FAILURE);
 
- finish:
   restore_non_core_regs (&saved_vrs);
   return code;
 }
@@ -1168,6 +1167,9 @@ __gnu_unwind_pr_common (_Unwind_State state,
 			{
 			  matched = (void *)(ucbp + 1);
 			  rtti = _Unwind_decode_target2 ((_uw) &data[i + 1]);
+			  /* There is no way to encode an exception
+			     specification for 'class X * &', so
+			     always pass false for is_reference.  */
 			  if (__cxa_type_match (ucbp, (type_info *) rtti, 0,
 						&matched))
 			    break;
@@ -1197,8 +1199,6 @@ __gnu_unwind_pr_common (_Unwind_State state,
 		  ucbp->barrier_cache.bitpattern[4] = (_uw) &data[1];
 
 		  if (data[0] & uint32_highbit)
-		    phase2_call_unexpected_after_unwind = 1;
-		  else
 		    {
 		      data += rtti_count + 1;
 		      /* Setup for entry to the handler.  */
@@ -1208,6 +1208,8 @@ __gnu_unwind_pr_common (_Unwind_State state,
 		      _Unwind_SetGR (context, 0, (_uw) ucbp);
 		      return _URC_INSTALL_CONTEXT;
 		    }
+		  else
+		    phase2_call_unexpected_after_unwind = 1;
 		}
 	      if (data[0] & uint32_highbit)
 		data++;
diff --git a/gcc/config/arm/unwind-arm.h b/gcc/config/arm/unwind-arm.h
index a9ba1267a..afb1c76bf 100644
--- a/gcc/config/arm/unwind-arm.h
+++ b/gcc/config/arm/unwind-arm.h
@@ -228,10 +228,12 @@ extern "C" {
       if (!tmp)
 	return 0;
 
-#if (defined(linux) && !defined(__uClinux__)) || defined(__NetBSD__)
-      /* Pc-relative indirect.  */
+#if (defined(linux) && !defined(__uClinux__)) || defined(__NetBSD__) \
+    || (defined (__nucleus__) && defined (__shared__))
+      /* Pc-relative indirect.  Propagate the bottom 2 bits, which can
+	 contain referenceness information in gnu unwinding tables.  */
       tmp += ptr;
-      tmp = *(_Unwind_Word *) tmp;
+      tmp = *(_Unwind_Word *) (tmp & ~(_Unwind_Word)3) | (tmp & 3);
 #elif defined(__symbian__) || defined(__uClinux__)
       /* Absolute pointer.  Nothing more to do.  */
 #else
diff --git a/gcc/config/arm/vec-common.md b/gcc/config/arm/vec-common.md
index 858d381ee..d33fdf99d 100644
--- a/gcc/config/arm/vec-common.md
+++ b/gcc/config/arm/vec-common.md
@@ -38,6 +38,16 @@
   "TARGET_NEON
    || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))"
 {
+  if (can_create_pseudo_p ())
+    {
+      if (GET_CODE (operands[0]) != REG)
+	operands[1] = force_reg (<MODE>mode, operands[1]);
+      else if (TARGET_NEON && CONSTANT_P (operands[1]))
+	{
+	  operands[1] = neon_make_constant (operands[1]);
+	  gcc_assert (operands[1] != NULL_RTX);
+	}
+    }
 })
 
 ;; Vector arithmetic. Expanders are blank, then unnamed insns implement
diff --git a/gcc/config/arm/vfp.md b/gcc/config/arm/vfp.md
index 737f81ccb..68609ddf6 100644
--- a/gcc/config/arm/vfp.md
+++ b/gcc/config/arm/vfp.md
@@ -51,7 +51,7 @@
 ;; problems because small constants get converted into adds.
 (define_insn "*arm_movsi_vfp"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,rk,m ,*t,r,*t,*t, *Uv")
-      (match_operand:SI 1 "general_operand"	   "rk, I,K,N,mi,rk,r,*t,*t,*Uvi,*t"))]
+      (match_operand:SI 1 "general_operand"	   "rk, I,K,j,mi,rk,r,*t,*t,*Uvi,*t"))]
   "TARGET_ARM && TARGET_VFP && TARGET_HARD_FLOAT
    && (   s_register_operand (operands[0], SImode)
        || s_register_operand (operands[1], SImode))"
@@ -82,13 +82,17 @@
   "
   [(set_attr "predicable" "yes")
    (set_attr "type" "*,*,*,*,load1,store1,r_2_f,f_2_r,fcpys,f_loads,f_stores")
+   (set_attr "neon_type" "*,*,*,*,*,*,neon_mcr,neon_mrc,neon_vmov,*,*")
+   (set_attr "insn" "mov,mov,mvn,mov,*,*,*,*,*,*,*")
    (set_attr "pool_range"     "*,*,*,*,4096,*,*,*,*,1020,*")
    (set_attr "neg_pool_range" "*,*,*,*,4084,*,*,*,*,1008,*")]
 )
 
+;; See thumb2.md:thumb2_movsi_insn for an explanation of the split
+;; high/low register alternatives for loads and stores here.
 (define_insn "*thumb2_movsi_vfp"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,rk,m,*t,r, *t,*t, *Uv")
-      (match_operand:SI 1 "general_operand"	   "rk, I,K,N,mi,rk,r,*t,*t,*Uvi,*t"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rk,r,r,r,l,*hk,m,*m,*t,r, *t,*t, *Uv")
+      (match_operand:SI 1 "general_operand"	   "rk, I,K,j,mi,*mi,l,*hk,r,*t,*t,*Uvi,*t"))]
   "TARGET_THUMB2 && TARGET_VFP && TARGET_HARD_FLOAT
    && (   s_register_operand (operands[0], SImode)
        || s_register_operand (operands[1], SImode))"
@@ -102,34 +106,38 @@
     case 3:
       return \"movw%?\\t%0, %1\";
     case 4:
-      return \"ldr%?\\t%0, %1\";
     case 5:
-      return \"str%?\\t%1, %0\";
+      return \"ldr%?\\t%0, %1\";
     case 6:
-      return \"fmsr%?\\t%0, %1\\t%@ int\";
     case 7:
-      return \"fmrs%?\\t%0, %1\\t%@ int\";
+      return \"str%?\\t%1, %0\";
     case 8:
+      return \"fmsr%?\\t%0, %1\\t%@ int\";
+    case 9:
+      return \"fmrs%?\\t%0, %1\\t%@ int\";
+    case 10:
       return \"fcpys%?\\t%0, %1\\t%@ int\";
-    case 9: case 10:
+    case 11: case 12:
       return output_move_vfp (operands);
     default:
       gcc_unreachable ();
     }
   "
   [(set_attr "predicable" "yes")
-   (set_attr "type" "*,*,*,*,load1,store1,r_2_f,f_2_r,fcpys,f_load,f_store")
-   (set_attr "pool_range"     "*,*,*,*,4096,*,*,*,*,1020,*")
-   (set_attr "neg_pool_range" "*,*,*,*,   0,*,*,*,*,1008,*")]
+   (set_attr "type" "*,*,*,*,load1,load1,store1,store1,r_2_f,f_2_r,fcpys,f_load,f_store")
+   (set_attr "neon_type" "*,*,*,*,*,*,*,*,neon_mcr,neon_mrc,neon_vmov,*,*")
+   (set_attr "insn" "mov,mov,mvn,mov,*,*,*,*,*,*,*,*,*")
+   (set_attr "pool_range"     "*,*,*,*,1020,4096,*,*,*,*,*,1020,*")
+   (set_attr "neg_pool_range" "*,*,*,*,   0,   0,*,*,*,*,*,1008,*")]
 )
 
 
 ;; DImode moves
 
 (define_insn "*arm_movdi_vfp"
-  [(set (match_operand:DI 0 "nonimmediate_di_operand" "=r, r,m,w,r,w,w, Uv")
+  [(set (match_operand:DI 0 "nonimmediate_di_operand" "=r, r, m,w,r,w,w, Uv")
 	(match_operand:DI 1 "di_operand"              "rIK,mi,r,r,w,w,Uvi,w"))]
-  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP
+  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP && arm_tune != cortexa8
    && (   register_operand (operands[0], DImode)
        || register_operand (operands[1], DImode))"
   "*
@@ -145,7 +153,10 @@
     case 4:
       return \"fmrrd%?\\t%Q0, %R0, %P1\\t%@ int\";
     case 5:
-      return \"fcpyd%?\\t%P0, %P1\\t%@ int\";
+      if (TARGET_VFP_SINGLE)
+	return \"fcpys%?\\t%0, %1\\t%@ int\;fcpys%?\\t%p0, %p1\\t%@ int\";
+      else
+	return \"fcpyd%?\\t%P0, %P1\\t%@ int\";
     case 6: case 7:
       return output_move_vfp (operands);
     default:
@@ -153,7 +164,56 @@
     }
   "
   [(set_attr "type" "*,load2,store2,r_2_f,f_2_r,ffarithd,f_loadd,f_stored")
-   (set_attr "length" "8,8,8,4,4,4,4,4")
+   (set_attr "neon_type" "*,*,*,neon_mcr_2_mcrr,neon_mrrc,neon_vmov,*,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "0,1,2") (const_int 8)
+			       (eq_attr "alternative" "5")
+				(if_then_else
+				 (eq (symbol_ref "TARGET_VFP_SINGLE") (const_int 1))
+				 (const_int 8)
+				 (const_int 4))]
+			      (const_int 4)))
+   (set_attr "pool_range"     "*,1020,*,*,*,*,1020,*")
+   (set_attr "neg_pool_range" "*,1008,*,*,*,*,1008,*")]
+)
+
+(define_insn "*arm_movdi_vfp_cortexa8"
+  [(set (match_operand:DI 0 "nonimmediate_di_operand" "=r, r,m,w,!r,w,w, Uv")
+	(match_operand:DI 1 "di_operand"              "rIK,mi,r,r,w,w,Uvi,w"))]
+  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP && arm_tune == cortexa8
+   && (   register_operand (operands[0], DImode)
+       || register_operand (operands[1], DImode))"
+  "*
+  switch (which_alternative)
+    {
+    case 0: 
+      return \"#\";
+    case 1:
+    case 2:
+      return output_move_double (operands);
+    case 3:
+      return \"fmdrr%?\\t%P0, %Q1, %R1\\t%@ int\";
+    case 4:
+      return \"fmrrd%?\\t%Q0, %R0, %P1\\t%@ int\";
+    case 5:
+      if (TARGET_VFP_SINGLE)
+	return \"fcpys%?\\t%0, %1\\t%@ int\;fcpys%?\\t%p0, %p1\\t%@ int\";
+      else
+	return \"fcpyd%?\\t%P0, %P1\\t%@ int\";
+    case 6: case 7:
+      return output_move_vfp (operands);
+    default:
+      gcc_unreachable ();
+    }
+  "
+  [(set_attr "type" "*,load2,store2,r_2_f,f_2_r,ffarithd,f_loadd,f_stored")
+   (set_attr "neon_type" "*,*,*,neon_mcr_2_mcrr,neon_mrrc,neon_vmov,*,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "0,1,2") (const_int 8)
+			       (eq_attr "alternative" "5")
+				(if_then_else
+				 (eq (symbol_ref "TARGET_VFP_SINGLE") (const_int 1))
+				 (const_int 8)
+				 (const_int 4))]
+			      (const_int 4)))
    (set_attr "pool_range"     "*,1020,*,*,*,*,1020,*")
    (set_attr "neg_pool_range" "*,1008,*,*,*,*,1008,*")]
 )
@@ -172,7 +232,10 @@
     case 4:
       return \"fmrrd%?\\t%Q0, %R0, %P1\\t%@ int\";
     case 5:
-      return \"fcpyd%?\\t%P0, %P1\\t%@ int\";
+      if (TARGET_VFP_SINGLE)
+	return \"fcpys%?\\t%0, %1\\t%@ int\;fcpys%?\\t%p0, %p1\\t%@ int\";
+      else
+	return \"fcpyd%?\\t%P0, %P1\\t%@ int\";
     case 6: case 7:
       return output_move_vfp (operands);
     default:
@@ -180,11 +243,123 @@
     }
   "
   [(set_attr "type" "*,load2,store2,r_2_f,f_2_r,ffarithd,f_load,f_store")
-   (set_attr "length" "8,8,8,4,4,4,4,4")
+   (set_attr "neon_type" "*,*,*,neon_mcr_2_mcrr,neon_mrrc,neon_vmov,*,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "0,1,2") (const_int 8)
+			       (eq_attr "alternative" "5")
+				(if_then_else
+				 (eq (symbol_ref "TARGET_VFP_SINGLE") (const_int 1))
+				 (const_int 8)
+				 (const_int 4))]
+			      (const_int 4)))
    (set_attr "pool_range"     "*,4096,*,*,*,*,1020,*")
    (set_attr "neg_pool_range" "*,   0,*,*,*,*,1008,*")]
 )
 
+;; HFmode moves
+(define_insn "*movhf_vfp_neon"
+  [(set (match_operand:HF 0 "nonimmediate_operand" "= t,Um,r,m,t,r,t,r,r")
+	(match_operand:HF 1 "general_operand"	   " Um, t,m,r,t,r,r,t,F"))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_NEON_FP16
+   && (   s_register_operand (operands[0], HFmode)
+       || s_register_operand (operands[1], HFmode))"
+  "*
+  switch (which_alternative)
+    {
+    case 0:     /* S register from memory */
+      return \"vld1.16\\t{%z0}, %A1\";
+    case 1:     /* memory from S register */
+      return \"vst1.16\\t{%z1}, %A0\";
+    case 2:     /* ARM register from memory */
+      return \"ldrh\\t%0, %1\\t%@ __fp16\";
+    case 3:     /* memory from ARM register */
+      return \"strh\\t%1, %0\\t%@ __fp16\";
+    case 4:	/* S register from S register */
+      return \"fcpys\\t%0, %1\";
+    case 5:	/* ARM register from ARM register */
+      return \"mov\\t%0, %1\\t%@ __fp16\";
+    case 6:	/* S register from ARM register */
+      return \"fmsr\\t%0, %1\";
+    case 7:	/* ARM register from S register */
+      return \"fmrs\\t%0, %1\";
+    case 8:	/* ARM register from constant */
+      {
+        REAL_VALUE_TYPE r;
+	long bits;
+	rtx ops[4];
+
+        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);
+	bits = real_to_target (NULL, &r, HFmode);
+	ops[0] = operands[0];
+	ops[1] = GEN_INT (bits);
+	ops[2] = GEN_INT (bits & 0xff00);
+	ops[3] = GEN_INT (bits & 0x00ff);
+
+	if (arm_arch_thumb2)
+	  output_asm_insn (\"movw\\t%0, %1\", ops);
+	else
+	  output_asm_insn (\"mov\\t%0, %2\;orr\\t%0, %0, %3\", ops);
+	return \"\";
+       }
+    default:
+      gcc_unreachable ();
+    }
+  "
+  [(set_attr "conds" "unconditional")
+   (set_attr "type" "*,*,load1,store1,fcpys,*,r_2_f,f_2_r,*")
+   (set_attr "neon_type" "neon_vld1_1_2_regs,neon_vst1_1_2_regs_vst2_2_regs,*,*,*,*,*,*,*")
+   (set_attr "length" "4,4,4,4,4,4,4,4,8")]
+)
+
+;; FP16 without element load/store instructions.
+(define_insn "*movhf_vfp"
+  [(set (match_operand:HF 0 "nonimmediate_operand" "=r,m,t,r,t,r,r")
+	(match_operand:HF 1 "general_operand"	   " m,r,t,r,r,t,F"))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16 && !TARGET_NEON_FP16
+   && (   s_register_operand (operands[0], HFmode)
+       || s_register_operand (operands[1], HFmode))"
+  "*
+  switch (which_alternative)
+    {
+    case 0:     /* ARM register from memory */
+      return \"ldrh\\t%0, %1\\t%@ __fp16\";
+    case 1:     /* memory from ARM register */
+      return \"strh\\t%1, %0\\t%@ __fp16\";
+    case 2:	/* S register from S register */
+      return \"fcpys\\t%0, %1\";
+    case 3:	/* ARM register from ARM register */
+      return \"mov\\t%0, %1\\t%@ __fp16\";
+    case 4:	/* S register from ARM register */
+      return \"fmsr\\t%0, %1\";
+    case 5:	/* ARM register from S register */
+      return \"fmrs\\t%0, %1\";
+    case 6:	/* ARM register from constant */
+      {
+        REAL_VALUE_TYPE r;
+	long bits;
+	rtx ops[4];
+
+        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);
+	bits = real_to_target (NULL, &r, HFmode);
+	ops[0] = operands[0];
+	ops[1] = GEN_INT (bits);
+	ops[2] = GEN_INT (bits & 0xff00);
+	ops[3] = GEN_INT (bits & 0x00ff);
+
+	if (arm_arch_thumb2)
+	  output_asm_insn (\"movw\\t%0, %1\", ops);
+	else
+	  output_asm_insn (\"mov\\t%0, %2\;orr\\t%0, %0, %3\", ops);
+	return \"\";
+       }
+    default:
+      gcc_unreachable ();
+    }
+  "
+  [(set_attr "conds" "unconditional")
+   (set_attr "type" "load1,store1,fcpys,*,r_2_f,f_2_r,*")
+   (set_attr "length" "4,4,4,4,4,4,8")]
+)
+
 
 ;; SFmode moves
 ;; Disparage the w<->r cases because reloading an invalid address is
@@ -222,6 +397,8 @@
   [(set_attr "predicable" "yes")
    (set_attr "type"
      "r_2_f,f_2_r,fconsts,f_loads,f_stores,load1,store1,fcpys,*")
+   (set_attr "neon_type" "neon_mcr,neon_mrc,*,*,*,*,*,neon_vmov,*")
+   (set_attr "insn" "*,*,*,*,*,*,*,*,mov")
    (set_attr "pool_range" "*,*,*,1020,*,4096,*,*,*")
    (set_attr "neg_pool_range" "*,*,*,1008,*,4080,*,*,*")]
 )
@@ -258,6 +435,8 @@
   [(set_attr "predicable" "yes")
    (set_attr "type"
      "r_2_f,f_2_r,fconsts,f_load,f_store,load1,store1,fcpys,*")
+   (set_attr "neon_type" "neon_mcr,neon_mrc,*,*,*,*,*,neon_vmov,*")
+   (set_attr "insn" "*,*,*,*,*,*,*,*,mov")
    (set_attr "pool_range" "*,*,*,1020,*,4092,*,*,*")
    (set_attr "neg_pool_range" "*,*,*,1008,*,0,*,*,*")]
 )
@@ -266,8 +445,8 @@
 ;; DFmode moves
 
 (define_insn "*movdf_vfp"
-  [(set (match_operand:DF 0 "nonimmediate_soft_df_operand" "=w,?r,w ,r, m,w  ,Uv,w,r")
-	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dv,mF,r,UvF,w, w,r"))]
+  [(set (match_operand:DF 0 "nonimmediate_soft_df_operand" "=w,?r,w ,w, r, m,w  ,Uv,w,r")
+	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dy,D0,mF,r,UvF,w, w,r"))]
   "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP
    && (   register_operand (operands[0], DFmode)
        || register_operand (operands[1], DFmode))"
@@ -280,14 +459,20 @@
       case 1:
 	return \"fmrrd%?\\t%Q0, %R0, %P1\";
       case 2:
+	gcc_assert (TARGET_VFP_DOUBLE);
         return \"fconstd%?\\t%P0, #%G1\";
-      case 3: case 4:
+      case 3:
+	return \"vmov.i32\\t%P0, #0\";
+      case 4: case 5:
 	return output_move_double (operands);
-      case 5: case 6:
+      case 6: case 7:
 	return output_move_vfp (operands);
-      case 7:
-	return \"fcpyd%?\\t%P0, %P1\";
       case 8:
+	if (TARGET_VFP_SINGLE)
+	  return \"fcpys%?\\t%0, %1\;fcpys%?\\t%p0, %p1\";
+	else
+	  return \"fcpyd%?\\t%P0, %P1\";
+      case 9:
         return \"#\";
       default:
 	gcc_unreachable ();
@@ -295,16 +480,25 @@
     }
   "
   [(set_attr "type"
-     "r_2_f,f_2_r,fconstd,f_loadd,f_stored,load2,store2,ffarithd,*")
-   (set_attr "length" "4,4,4,8,8,4,4,4,8")
-   (set_attr "pool_range" "*,*,*,1020,*,1020,*,*,*")
-   (set_attr "neg_pool_range" "*,*,*,1008,*,1008,*,*,*")]
+     "r_2_f,f_2_r,fconstd,*,f_loadd,f_stored,load2,store2,ffarithd,*")
+   (set_attr "neon_type" "neon_mcr_2_mcrr,neon_mrrc,*,neon_vmov,*,*,*,*,neon_vmov,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "4,5,9") (const_int 8)
+			       (eq_attr "alternative" "8")
+				(if_then_else
+				 (eq (symbol_ref "TARGET_VFP_SINGLE") (const_int 1))
+				 (const_int 8)
+				 (const_int 4))]
+			      (const_int 4)))
+   (set_attr "pool_range" "*,*,*,*,1020,*,1020,*,*,*")
+   (set_attr "neg_pool_range" "*,*,*,*,1008,*,1008,*,*,*")]
 )
 
 (define_insn "*thumb2_movdf_vfp"
-  [(set (match_operand:DF 0 "nonimmediate_soft_df_operand" "=w,?r,w ,r, m,w  ,Uv,w,r")
-	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dv,mF,r,UvF,w, w,r"))]
-  "TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP"
+  [(set (match_operand:DF 0 "nonimmediate_soft_df_operand" "=w,?r,w ,w, r, m,w  ,Uv,w,r")
+	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dy,D0,mF,r,UvF,w, w,r"))]
+  "TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP
+   && (   register_operand (operands[0], DFmode)
+       || register_operand (operands[1], DFmode))"
   "*
   {
     switch (which_alternative)
@@ -314,23 +508,36 @@
       case 1:
 	return \"fmrrd%?\\t%Q0, %R0, %P1\";
       case 2:
+	gcc_assert (TARGET_VFP_DOUBLE);
 	return \"fconstd%?\\t%P0, #%G1\";
-      case 3: case 4: case 8:
+      case 3:
+	return \"vmov.i32\\t%P0, #0\";
+      case 4: case 5: case 9:
 	return output_move_double (operands);
-      case 5: case 6:
+      case 6: case 7:
 	return output_move_vfp (operands);
-      case 7:
-	return \"fcpyd%?\\t%P0, %P1\";
+      case 8:
+	if (TARGET_VFP_SINGLE)
+	  return \"fcpys%?\\t%0, %1\;fcpys%?\\t%p0, %p1\";
+	else
+	  return \"fcpyd%?\\t%P0, %P1\";
       default:
 	abort ();
       }
     }
   "
   [(set_attr "type"
-     "r_2_f,f_2_r,fconstd,load2,store2,f_load,f_store,ffarithd,*")
-   (set_attr "length" "4,4,4,8,8,4,4,4,8")
-   (set_attr "pool_range" "*,*,*,4096,*,1020,*,*,*")
-   (set_attr "neg_pool_range" "*,*,*,0,*,1008,*,*,*")]
+     "r_2_f,f_2_r,fconstd,*,load2,store2,f_load,f_store,ffarithd,*")
+   (set_attr "neon_type" "neon_mcr_2_mcrr,neon_mrrc,*,neon_vmov,*,*,*,*,neon_vmov,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "4,5,9") (const_int 8)
+			       (eq_attr "alternative" "8")
+				(if_then_else
+				 (eq (symbol_ref "TARGET_VFP_SINGLE") (const_int 1))
+				 (const_int 8)
+				 (const_int 4))]
+			      (const_int 4)))
+   (set_attr "pool_range" "*,*,*,*,4096,*,1020,*,*,*")
+   (set_attr "neg_pool_range" "*,*,*,*,0,*,1008,*,*,*")]
 )
 
 
@@ -356,7 +563,8 @@
    fmrs%D3\\t%0, %2\;fmrs%d3\\t%0, %1"
    [(set_attr "conds" "use")
     (set_attr "length" "4,4,8,4,4,8,4,4,8")
-    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr,neon_mcr,neon_mcr,neon_mrc,neon_mrc,neon_mrc")]
 )
 
 (define_insn "*thumb2_movsfcc_vfp"
@@ -379,7 +587,8 @@
    ite\\t%D3\;fmrs%D3\\t%0, %2\;fmrs%d3\\t%0, %1"
    [(set_attr "conds" "use")
     (set_attr "length" "6,6,10,6,6,10,6,6,10")
-    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr,neon_mcr,neon_mcr,neon_mrc,neon_mrc,neon_mrc")]
 )
 
 (define_insn "*movdfcc_vfp"
@@ -389,7 +598,7 @@
 	    [(match_operand 4 "cc_register" "") (const_int 0)])
 	  (match_operand:DF 1 "s_register_operand" "0,w,w,0,?r,?r,0,w,w")
 	  (match_operand:DF 2 "s_register_operand" "w,0,w,?r,0,?r,w,0,w")))]
-  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "@
    fcpyd%D3\\t%P0, %P2
    fcpyd%d3\\t%P0, %P1
@@ -402,7 +611,8 @@
    fmrrd%D3\\t%Q0, %R0, %P2\;fmrrd%d3\\t%Q0, %R0, %P1"
    [(set_attr "conds" "use")
     (set_attr "length" "4,4,8,4,4,8,4,4,8")
-    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mrrc,neon_mrrc,neon_mrrc")]
 )
 
 (define_insn "*thumb2_movdfcc_vfp"
@@ -412,7 +622,7 @@
 	    [(match_operand 4 "cc_register" "") (const_int 0)])
 	  (match_operand:DF 1 "s_register_operand" "0,w,w,0,?r,?r,0,w,w")
 	  (match_operand:DF 2 "s_register_operand" "w,0,w,?r,0,?r,w,0,w")))]
-  "TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "@
    it\\t%D3\;fcpyd%D3\\t%P0, %P2
    it\\t%d3\;fcpyd%d3\\t%P0, %P1
@@ -425,7 +635,8 @@
    ite\\t%D3\;fmrrd%D3\\t%Q0, %R0, %P2\;fmrrd%d3\\t%Q0, %R0, %P1"
    [(set_attr "conds" "use")
     (set_attr "length" "6,6,10,6,6,10,6,6,10")
-    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mrrc,neon_mrrc,neon_mrrc")]
 )
 
 
@@ -443,7 +654,7 @@
 (define_insn "*absdf2_vfp"
   [(set (match_operand:DF	  0 "s_register_operand" "=w")
 	(abs:DF (match_operand:DF 1 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fabsd%?\\t%P0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "ffarithd")]
@@ -463,12 +674,12 @@
 (define_insn_and_split "*negdf2_vfp"
   [(set (match_operand:DF	  0 "s_register_operand" "=w,?r,?r")
 	(neg:DF (match_operand:DF 1 "s_register_operand" "w,0,r")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "@
    fnegd%?\\t%P0, %P1
    #
    #"
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP && reload_completed
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE && reload_completed
    && arm_general_register_operand (operands[0], DFmode)"
   [(set (match_dup 0) (match_dup 1))]
   "
@@ -523,7 +734,7 @@
   [(set (match_operand:DF	   0 "s_register_operand" "=w")
 	(plus:DF (match_operand:DF 1 "s_register_operand" "w")
 		 (match_operand:DF 2 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "faddd%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
    (set_attr "type" "faddd")]
@@ -544,7 +755,7 @@
   [(set (match_operand:DF	    0 "s_register_operand" "=w")
 	(minus:DF (match_operand:DF 1 "s_register_operand" "w")
 		  (match_operand:DF 2 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fsubd%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
    (set_attr "type" "faddd")]
@@ -567,7 +778,7 @@
   [(set (match_operand:DF	  0 "s_register_operand" "+w")
 	(div:DF (match_operand:DF 1 "s_register_operand" "w")
 		(match_operand:DF 2 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fdivd%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fdivd")]
@@ -590,7 +801,7 @@
   [(set (match_operand:DF	   0 "s_register_operand" "+w")
 	(mult:DF (match_operand:DF 1 "s_register_operand" "w")
 		 (match_operand:DF 2 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fmuld%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmuld")]
@@ -611,7 +822,7 @@
   [(set (match_operand:DF		   0 "s_register_operand" "+w")
 	(mult:DF (neg:DF (match_operand:DF 1 "s_register_operand" "w"))
 		 (match_operand:DF	   2 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fnmuld%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmuld")]
@@ -626,7 +837,8 @@
 	(plus:SF (mult:SF (match_operand:SF 2 "s_register_operand" "t")
 			  (match_operand:SF 3 "s_register_operand" "t"))
 		 (match_operand:SF	    1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP
+   && (!arm_tune_marvell_f || optimize_size)"
   "fmacs%?\\t%0, %2, %3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacs")]
@@ -637,7 +849,8 @@
 	(plus:DF (mult:DF (match_operand:DF 2 "s_register_operand" "w")
 			  (match_operand:DF 3 "s_register_operand" "w"))
 		 (match_operand:DF	    1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE
+   && (!arm_tune_marvell_f || optimize_size)"
   "fmacd%?\\t%P0, %P2, %P3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacd")]
@@ -649,7 +862,8 @@
 	(minus:SF (mult:SF (match_operand:SF 2 "s_register_operand" "t")
 			   (match_operand:SF 3 "s_register_operand" "t"))
 		  (match_operand:SF	     1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP
+   && (!arm_tune_marvell_f || optimize_size)"
   "fmscs%?\\t%0, %2, %3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacs")]
@@ -660,7 +874,8 @@
 	(minus:DF (mult:DF (match_operand:DF 2 "s_register_operand" "w")
 			   (match_operand:DF 3 "s_register_operand" "w"))
 		  (match_operand:DF	     1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE
+   && (!arm_tune_marvell_f || optimize_size)"
   "fmscd%?\\t%P0, %P2, %P3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacd")]
@@ -672,7 +887,8 @@
 	(minus:SF (match_operand:SF	     1 "s_register_operand" "0")
 		  (mult:SF (match_operand:SF 2 "s_register_operand" "t")
 			   (match_operand:SF 3 "s_register_operand" "t"))))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP
+   && (!arm_tune_marvell_f || optimize_size)"
   "fnmacs%?\\t%0, %2, %3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacs")]
@@ -683,7 +899,8 @@
 	(minus:DF (match_operand:DF	     1 "s_register_operand" "0")
 		  (mult:DF (match_operand:DF 2 "s_register_operand" "w")
 			   (match_operand:DF 3 "s_register_operand" "w"))))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE
+   && (!arm_tune_marvell_f || optimize_size)"
   "fnmacd%?\\t%P0, %P2, %P3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacd")]
@@ -697,7 +914,8 @@
 		    (neg:SF (match_operand:SF 2 "s_register_operand" "t"))
 		    (match_operand:SF	      3 "s_register_operand" "t"))
 		  (match_operand:SF	      1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP
+   && (!arm_tune_marvell_f || optimize_size)"
   "fnmscs%?\\t%0, %2, %3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacs")]
@@ -709,7 +927,8 @@
 		    (neg:DF (match_operand:DF 2 "s_register_operand" "w"))
 		    (match_operand:DF	      3 "s_register_operand" "w"))
 		  (match_operand:DF	      1 "s_register_operand" "0")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE
+   && (!arm_tune_marvell_f || optimize_size)"
   "fnmscd%?\\t%P0, %P2, %P3"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fmacd")]
@@ -721,7 +940,7 @@
 (define_insn "*extendsfdf2_vfp"
   [(set (match_operand:DF		   0 "s_register_operand" "=w")
 	(float_extend:DF (match_operand:SF 1 "s_register_operand" "t")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fcvtds%?\\t%P0, %1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
@@ -730,12 +949,30 @@
 (define_insn "*truncdfsf2_vfp"
   [(set (match_operand:SF		   0 "s_register_operand" "=t")
 	(float_truncate:SF (match_operand:DF 1 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fcvtsd%?\\t%0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
 )
 
+(define_insn "extendhfsf2"
+  [(set (match_operand:SF		   0 "s_register_operand" "=t")
+	(float_extend:SF (match_operand:HF 1 "s_register_operand" "t")))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16"
+  "vcvtb%?.f32.f16\\t%0, %1"
+  [(set_attr "predicable" "yes")
+   (set_attr "type" "f_cvt")]
+)
+
+(define_insn "truncsfhf2"
+  [(set (match_operand:HF		   0 "s_register_operand" "=t")
+	(float_truncate:HF (match_operand:SF 1 "s_register_operand" "t")))]
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16"
+  "vcvtb%?.f16.f32\\t%0, %1"
+  [(set_attr "predicable" "yes")
+   (set_attr "type" "f_cvt")]
+)
+
 (define_insn "*truncsisf2_vfp"
   [(set (match_operand:SI		  0 "s_register_operand" "=t")
 	(fix:SI (fix:SF (match_operand:SF 1 "s_register_operand" "t"))))]
@@ -748,7 +985,7 @@
 (define_insn "*truncsidf2_vfp"
   [(set (match_operand:SI		  0 "s_register_operand" "=t")
 	(fix:SI (fix:DF (match_operand:DF 1 "s_register_operand" "w"))))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "ftosizd%?\\t%0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
@@ -767,7 +1004,7 @@
 (define_insn "fixuns_truncdfsi2"
   [(set (match_operand:SI		  0 "s_register_operand" "=t")
 	(unsigned_fix:SI (fix:DF (match_operand:DF 1 "s_register_operand" "t"))))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "ftouizd%?\\t%0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
@@ -786,7 +1023,7 @@
 (define_insn "*floatsidf2_vfp"
   [(set (match_operand:DF	    0 "s_register_operand" "=w")
 	(float:DF (match_operand:SI 1 "s_register_operand" "t")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fsitod%?\\t%P0, %1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
@@ -805,7 +1042,7 @@
 (define_insn "floatunssidf2"
   [(set (match_operand:DF	    0 "s_register_operand" "=w")
 	(unsigned_float:DF (match_operand:SI 1 "s_register_operand" "t")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fuitod%?\\t%P0, %1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "f_cvt")]
@@ -826,7 +1063,7 @@
 (define_insn "*sqrtdf2_vfp"
   [(set (match_operand:DF	   0 "s_register_operand" "=w")
 	(sqrt:DF (match_operand:DF 1 "s_register_operand" "w")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fsqrtd%?\\t%P0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "type" "fdivd")]
@@ -878,9 +1115,9 @@
   [(set (reg:CCFP CC_REGNUM)
 	(compare:CCFP (match_operand:DF 0 "s_register_operand"  "w")
 		      (match_operand:DF 1 "vfp_compare_operand" "wG")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "#"
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   [(set (reg:CCFP VFPCC_REGNUM)
 	(compare:CCFP (match_dup 0)
 		       (match_dup 1)))
@@ -893,9 +1130,9 @@
   [(set (reg:CCFPE CC_REGNUM)
 	(compare:CCFPE (match_operand:DF 0 "s_register_operand"  "w")
 		       (match_operand:DF 1 "vfp_compare_operand" "wG")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "#"
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   [(set (reg:CCFPE VFPCC_REGNUM)
 	(compare:CCFPE (match_dup 0)
 		       (match_dup 1)))
@@ -935,7 +1172,7 @@
   [(set (reg:CCFP VFPCC_REGNUM)
 	(compare:CCFP (match_operand:DF 0 "s_register_operand"  "w,w")
 		      (match_operand:DF 1 "vfp_compare_operand" "w,G")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "@
    fcmpd%?\\t%P0, %P1
    fcmpzd%?\\t%P0"
@@ -947,7 +1184,7 @@
   [(set (reg:CCFPE VFPCC_REGNUM)
 	(compare:CCFPE (match_operand:DF 0 "s_register_operand"  "w,w")
 		       (match_operand:DF 1 "vfp_compare_operand" "w,G")))]
-  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
+  "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "@
    fcmped%?\\t%P0, %P1
    fcmpezd%?\\t%P0"
diff --git a/gcc/config/arm/vxworks.h b/gcc/config/arm/vxworks.h
index 8879fedb7..755f1d74f 100644
--- a/gcc/config/arm/vxworks.h
+++ b/gcc/config/arm/vxworks.h
@@ -97,7 +97,7 @@ along with GCC; see the file COPYING3.  If not see
 /* There is no default multilib.  */
 #undef MULTILIB_DEFAULTS
 
-#define FPUTYPE_DEFAULT FPUTYPE_VFP
+#define FPUTYPE_DEFAULT "vfp"
 
 #undef FUNCTION_PROFILER
 #define FUNCTION_PROFILER VXWORKS_FUNCTION_PROFILER
@@ -117,3 +117,10 @@ along with GCC; see the file COPYING3.  If not see
 
 #undef TARGET_DEFAULT_WORD_RELOCATIONS
 #define TARGET_DEFAULT_WORD_RELOCATIONS 1
+
+/* VxWorks uses RELA relocations.  It doesn't actually use movw/movt
+   relocations because the loader can't cope with them.  See
+   TARGET_DEFAULT_WORD_RELOCATIONS above.  In principle if it did
+   then they would accept arbitrary offsets.  */
+#undef TARGET_USE_RELA
+#define TARGET_USE_RELA 1
diff --git a/gcc/config/arm/wince-pe.h b/gcc/config/arm/wince-pe.h
index ffaa0c6c3..773e11b62 100644
--- a/gcc/config/arm/wince-pe.h
+++ b/gcc/config/arm/wince-pe.h
@@ -1,7 +1,11 @@
-/* Definitions of target machine for GNU compiler, for ARM with WINCE-PE obj format.
+/* Definitions of target machine for GNU compiler, for ARM with
+   WINCE-PE obj format.
+
    Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
    Contributed by Nick Clifton <nickc@redhat.com>
-   
+
+   Further development by Pedro Alves <pedro_alves@portugalmail.pt>
+
    This file is part of GCC.
 
    GCC is free software; you can redistribute it and/or modify it
@@ -18,9 +22,243 @@
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.  */
 
-#undef  TARGET_DEFAULT
-#define TARGET_DEFAULT	(MASK_NOP_FUN_DLLIMPORT)
+/* Enable WinCE specific code.  */
+#define ARM_WINCE 1
+
+#undef MATH_LIBRARY
+#define MATH_LIBRARY ""
+
+#define TARGET_EXECUTABLE_SUFFIX ".exe"
+
+#undef  TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (arm Windows CE/Native SDK)");
+
+#undef SUBTARGET_CONDITIONAL_REGISTER_USAGE
+#define SUBTARGET_CONDITIONAL_REGISTER_USAGE
 
 #undef  MULTILIB_DEFAULTS
 #define MULTILIB_DEFAULTS \
-  { "marm", "mlittle-endian", "msoft-float", "mno-thumb-interwork" }  
+  { "marm", "mlittle-endian", "msoft-float", "mno-thumb-interwork" }
+
+#undef SUBTARGET_CPU_DEFAULT
+#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm8
+
+/* We must store doubles in little endian order.  Specifying the
+   default of VFP assures that.  To guaranty VFP insns won't be
+   emitted by default, we default to float-abi=soft.  */
+#undef  FPUTYPE_DEFAULT
+#define FPUTYPE_DEFAULT "vfp"
+
+#undef CPP_SPEC
+#define CPP_SPEC "%(cpp_cpu) \
+-DWIN32 -D_WIN32 -D__WIN32 -D__WIN32__ \
+%{!nostdinc: -idirafter ../include/w32api%s -idirafter ../../include/w32api%s } \
+"
+
+#ifndef ASM_SPEC
+#define ASM_SPEC "\
+%{mbig-endian:-EB} \
+%{mlittle-endian:-EL} \
+%{mcpu=*:-mcpu=%*} \
+%{march=*:-march=%*} \
+%{mapcs-*:-mapcs-%*} \
+%(subtarget_asm_float_spec) \
+%{mthumb-interwork:-mthumb-interwork} \
+%{msoft-float:-mfloat-abi=soft} %{mhard-float:-mfloat-abi=hard} \
+%{mfloat-abi=*} %{mfpu=*} \
+%(subtarget_extra_asm_spec)"
+#endif
+
+#define EXTRA_OS_CPP_BUILTINS()
+
+#define TARGET_OS_CPP_BUILTINS()					\
+  do									\
+  {									\
+      /* We currently define UNDER_CE to a non-value, as it seems	\
+         MSVC2005 does the same.  */ 					\
+      builtin_define_std ("UNDER_CE");					\
+      builtin_define ("_UNICODE");					\
+      builtin_define_std ("UNICODE");					\
+	  /* Let's just ignore stdcall, and fastcall.  */ 		\
+      builtin_define ("__stdcall=__attribute__((__cdecl__))");		\
+      builtin_define ("__fastcall=__attribute__((__cdecl__))");		\
+      builtin_define ("__cdecl=__attribute__((__cdecl__))");		\
+      if (!flag_iso)							\
+        {								\
+          builtin_define ("_stdcall=__attribute__((__cdecl__))");	\
+          builtin_define ("_fastcall=__attribute__((__cdecl__))");	\
+          builtin_define ("_cdecl=__attribute__((__cdecl__))");		\
+        }								\
+      /* Even though linkonce works with static libs, this is needed 	\
+          to compare typeinfo symbols across dll boundaries.  */	\
+      builtin_define ("__GXX_MERGED_TYPEINFO_NAMES=0");			\
+      builtin_define ("__GXX_TYPEINFO_EQUALITY_INLINE=0");		\
+      EXTRA_OS_CPP_BUILTINS ();						\
+      {                                                       		\
+        /* Define these to be compatible MSFT's tools.  */    		\
+        char buf[64];                                         		\
+        int arch = arm_major_arch ();                         		\
+        sprintf (buf, "_M_ARM=%d", arch);                     		\
+        builtin_define (buf);                                 		\
+        if (arm_thumb_arch_p ())                              		\
+          {                                                   		\
+            sprintf (buf, "_M_ARMT=%d", arch);                		\
+            builtin_define (buf);                            		\
+          }                                                   		\
+        /* Always defined as empty.  */                       		\
+        builtin_define ("ARM=");                              		\
+      }                                                       		\
+  }                                                           		\
+  while (0)
+
+/* Now we define the strings used to build the spec file.  */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC ""
+
+#undef LIBGCC_SPEC
+#define LIBGCC_SPEC "-lgcc"
+
+/* Link with coredll, the main libc in the native SDK, and with
+   corelibc, a static lib that contains the start files, among other
+   basic crt stuff.  */
+
+#undef LIB_SPEC
+#define LIB_SPEC "-lcoredll -lcorelibc"
+
+#undef LINK_SPEC
+#define LINK_SPEC "\
+  %{shared: %{mdll: %eshared and mdll are not compatible}} \
+  %{shared: --shared} %{mdll:--dll} \
+  %{static:-Bstatic} %{!static:-Bdynamic} \
+  %{shared|mdll: -e DllMainCRTStartup} \
+  "
+
+
+/* Don't assume anything about the header files.  */
+#define NO_IMPLICIT_EXTERN_C
+
+
+/* Define types for compatibility with MS runtime.  */
+
+#undef DEFAULT_SIGNED_CHAR
+#define DEFAULT_SIGNED_CHAR 1
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE 16
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "short unsigned int"
+
+#undef WINT_TYPE
+#define WINT_TYPE "short unsigned int"
+
+
+#undef DWARF2_UNWIND_INFO
+#define DWARF2_UNWIND_INFO 0
+
+#define DWARF2_DEBUGGING_INFO 1
+
+#undef  PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+
+#undef HAVE_AS_DWARF2_DEBUG_LINE
+#define HAVE_AS_DWARF2_DEBUG_LINE 1
+
+/* Use section relative relocations for debugging offsets.  Unlike
+   other targets that fake this by putting the section VMA at 0, PE
+   won't allow it.  */
+#define ASM_OUTPUT_DWARF_OFFSET(FILE, SIZE, LABEL, SECTION)    \
+  do {                                                \
+    if (SIZE != 4)                                    \
+      abort ();                                       \
+                                                      \
+    fputs ("\t.secrel32\t", FILE);                    \
+    assemble_name (FILE, LABEL);                      \
+  } while (0)
+
+/* Align output to a power of two.  Note ".align 0" is redundant,
+   and also GAS will treat it as ".align 2" which we do not want.  */
+#undef ASM_OUTPUT_ALIGN
+#define ASM_OUTPUT_ALIGN(STREAM, POWER)			\
+  do							\
+    {							\
+      if ((POWER) > 0)					\
+	fprintf (STREAM, "\t.align\t%d\n", POWER);	\
+    }							\
+  while (0)
+
+/* Prefix for internally generated assembler labels.  If we aren't using
+   underscores, we are using prefix `.'s to identify labels that should
+   be ignored.  */
+/* If user-symbols don't have underscores,
+   then it must take more than `L' to identify
+   a label that should be ignored.  */
+
+#undef  LPREFIX
+#define LPREFIX ".L"
+
+#undef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX "."
+
+/* The prefix to add to user-visible assembler symbols.
+   Arm Windows CE is not underscored.  */
+
+#undef  USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX ""
+
+/* This is how to store into the string BUF
+   the symbol_ref name of an internal numbered label where
+   PREFIX is the class of label and NUM is the number within the class.
+   This is suitable for output with `assemble_name'.  */
+#undef  ASM_GENERATE_INTERNAL_LABEL
+#define ASM_GENERATE_INTERNAL_LABEL(BUF,PREFIX,NUMBER)	\
+  sprintf ((BUF), ".%s%ld", (PREFIX), (long)(NUMBER))
+
+/* We have to re-define this to prevent any conflicts.  */
+#undef ARM_MCOUNT_NAME
+#define ARM_MCOUNT_NAME "_mcount"
+
+
+/* Emit code to check the stack when allocating more than 4000
+   bytes in one go.  */
+/*#define CHECK_STACK_LIMIT 4000 */
+
+
+
+/* We do bitfields MSVC-compatibly by default.
+   We choose to be compatible with Microsoft's ARM and Thumb compilers,
+   which always return aggregates in memory.  */
+
+/* TODO: Maybe add MASK_STACK_PROBE ? and enable CHECK_STACK_LIMIT?  */
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT (MASK_NOP_FUN_DLLIMPORT | \
+                        MASK_MS_BITFIELD_LAYOUT)
+
+/* A bit-field declared as `int' forces `int' alignment for the struct.  */
+#undef PCC_BITFIELD_TYPE_MATTERS
+#define PCC_BITFIELD_TYPE_MATTERS 1
+#define GROUP_BITFIELDS_BY_ALIGN TYPE_NATIVE(rec)
+
+#undef DEFAULT_STRUCTURE_SIZE_BOUNDARY
+#define DEFAULT_STRUCTURE_SIZE_BOUNDARY 8
+
+#undef ARM_DOUBLEWORD_ALIGN
+#define ARM_DOUBLEWORD_ALIGN 0
+
+#undef BIGGEST_ALIGNMENT
+#define BIGGEST_ALIGNMENT 64
+
+/* defined in pe.h */
+#undef SYSV_PRAGMA
+
+#undef TREE
+
+#ifndef BUFSIZ
+# undef FILE
+#endif
diff --git a/gcc/config/arm/wrs-linux.h b/gcc/config/arm/wrs-linux.h
new file mode 100644
index 000000000..136ab0b50
--- /dev/null
+++ b/gcc/config/arm/wrs-linux.h
@@ -0,0 +1,52 @@
+/* Wind River GNU/Linux Configuration.
+   Copyright (C) 2006, 2007, 2008
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Use the ARM926EJ-S by default.  */
+#undef SUBTARGET_CPU_DEFAULT
+#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm926ejs
+
+/* Add a -tiwmmxt option for convenience in generating multilibs.
+   This option generates big-endian IWMMXT code.  */
+#undef CC1_SPEC
+#define CC1_SPEC "							\
+ %{tarm926ej-s:	-mcpu=arm926ej-s ;					\
+   tthumb2-v7-a: %{!mcpu=*:%{!march=*:-mcpu=cortex-a8}} -mthumb ;	\
+   tthumb2-v7-a-neon: %{!mcpu=*:%{!march=*:-mcpu=cortex-a8}}		\
+                      -mthumb -mfloat-abi=softfp -mfpu=neon }		\
+ %{profile:-p}"
+
+/* Since the ARM926EJ-S is the default processor, we do not need to
+   provide an explicit multilib for that processor.  */
+#undef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS \
+  { "tarm926ej-s" }
+
+/* The GLIBC headers are in /usr/include, relative to the sysroot; the
+   uClibc headers are in /uclibc/usr/include.  */
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC		\
+  "%{muclibc:/uclibc}" 
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC					\
+  "%{muclibc:/uclibc}%{tthumb2-v7-a:/thumb2-v7-a ;		\
+     tthumb2-v7-a-neon:/thumb2-v7-a-neon}%{!tthumb2*:%{mfloat-abi=softfp:/softfp}}"
+
diff --git a/gcc/config/i386/atom.md b/gcc/config/i386/atom.md
new file mode 100644
index 000000000..a9c4c5d05
--- /dev/null
+++ b/gcc/config/i386/atom.md
@@ -0,0 +1,795 @@
+;; Atom Scheduling
+;; Copyright (C) 2009 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+;;
+;; Atom is an in-order core with two integer pipelines.
+
+
+(define_attr "atom_unit" "sishuf,simul,jeu,complex,other" 
+  (const_string "other"))
+
+(define_attr "atom_sse_attr" "rcp,movdup,lfence,fence,prefetch,sqrt,mxcsr,other"
+  (const_string "other"))
+
+(define_automaton "atom")
+
+;;  Atom has two ports: port 0 and port 1 connecting to all execution units
+(define_cpu_unit "atom-port-0,atom-port-1" "atom")
+
+;;  EU: Execution Unit
+;;  Atom EUs are connected by port 0 or port 1. 
+
+(define_cpu_unit "atom-eu-0, atom-eu-1,
+                  atom-imul-1, atom-imul-2, atom-imul-3, atom-imul-4"
+                  "atom")
+
+;; Some EUs have duplicated copied and can be accessed via either
+;; port 0 or port 1
+;; (define_reservation "atom-port-either" "(atom-port-0 | atom-port-1)")
+
+;;; Some instructions is dual-pipe execution, need both ports
+;;; Complex multi-op macro-instructoins need both ports and all EUs
+(define_reservation "atom-port-dual" "(atom-port-0 + atom-port-1)")
+(define_reservation "atom-all-eu" "(atom-eu-0 + atom-eu-1 + 
+                                    atom-imul-1 + atom-imul-2 + atom-imul-3 +
+                                    atom-imul-4)")
+
+;;; Most of simple instructions have 1 cycle latency. Some of them
+;;; issue in port 0, some in port 0 and some in either port.
+(define_reservation "atom-simple-0" "(atom-port-0 + atom-eu-0)")
+(define_reservation "atom-simple-1" "(atom-port-1 + atom-eu-1)")
+(define_reservation "atom-simple-either" "(atom-simple-0 | atom-simple-1)")
+
+;;; Some insn issues in port 0 with 3 cycle latency and 1 cycle tput
+(define_reservation "atom-eu-0-3-1" "(atom-port-0 + atom-eu-0, nothing*2)")
+
+;;; fmul insn can have 4 or 5 cycles latency
+(define_reservation "atom-fmul-5c" "(atom-port-0 + atom-eu-0), nothing*4")
+(define_reservation "atom-fmul-4c" "(atom-port-0 + atom-eu-0), nothing*3")
+
+;;; fadd can has 5 cycles latency depends on instruction forms
+(define_reservation "atom-fadd-5c" "(atom-port-1 + atom-eu-1), nothing*5")
+
+;;; imul insn has 5 cycles latency
+(define_reservation "atom-imul-32" 
+                    "atom-imul-1, atom-imul-2, atom-imul-3, atom-imul-4, 
+                     atom-port-0")
+;;; imul instruction excludes other non-FP instructions.
+(exclusion_set "atom-eu-0, atom-eu-1" 
+               "atom-imul-1, atom-imul-2, atom-imul-3, atom-imul-4")
+
+;;; dual-execution instructions can have 1,2,4,5 cycles latency depends on 
+;;; instruction forms
+(define_reservation "atom-dual-1c" "(atom-port-dual + atom-eu-0 + atom-eu-1)")
+(define_reservation "atom-dual-2c"
+                    "(atom-port-dual + atom-eu-0 + atom-eu-1, nothing)")
+(define_reservation "atom-dual-5c"
+                    "(atom-port-dual + atom-eu-0 + atom-eu-1, nothing*4)")
+
+;;; Complex macro-instruction has variants of latency, and uses both ports.
+(define_reservation "atom-complex" "(atom-port-dual + atom-all-eu)")
+
+(define_insn_reservation  "atom_other" 9
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "other")
+            (eq_attr "atom_unit" "!jeu")))
+  "atom-complex, atom-all-eu*8")
+
+;; return has type "other" with atom_unit "jeu"
+(define_insn_reservation  "atom_other_2" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "other")
+            (eq_attr "atom_unit" "jeu")))
+  "atom-dual-1c")
+
+(define_insn_reservation  "atom_multi" 9
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "multi"))
+  "atom-complex, atom-all-eu*8")
+
+;; Normal alu insns without carry
+(define_insn_reservation  "atom_alu" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu")
+            (and (eq_attr "memory" "none")
+                 (eq_attr "use_carry" "0"))))
+  "atom-simple-either")
+
+;; Normal alu insns without carry
+(define_insn_reservation  "atom_alu_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu")
+            (and (eq_attr "memory" "!none")
+                 (eq_attr "use_carry" "0"))))
+  "atom-simple-either")
+
+;; Alu insn consuming CF, such as add/sbb
+(define_insn_reservation  "atom_alu_carry" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu")
+            (and (eq_attr "memory" "none")
+                 (eq_attr "use_carry" "1"))))
+  "atom-simple-either")
+
+;; Alu insn consuming CF, such as add/sbb
+(define_insn_reservation  "atom_alu_carry_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu")
+            (and (eq_attr "memory" "!none")
+                (eq_attr "use_carry" "1"))))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_alu1" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu1")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_alu1_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "alu1")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_negnot" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "negnot")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_negnot_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "negnot")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_imov" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imov")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_imov_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imov")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+;; 16<-16, 32<-32
+(define_insn_reservation  "atom_imovx" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imovx")
+            (and (eq_attr "memory" "none")
+                 (ior (and (match_operand:HI 0 "register_operand")
+                           (match_operand:HI 1 "general_operand"))
+                      (and (match_operand:SI 0 "register_operand")
+                           (match_operand:SI 1 "general_operand"))))))
+  "atom-simple-either")
+
+;; 16<-16, 32<-32, mem
+(define_insn_reservation  "atom_imovx_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imovx")
+            (and (eq_attr "memory" "!none")
+                 (ior (and (match_operand:HI 0 "register_operand")
+                           (match_operand:HI 1 "general_operand"))
+                      (and (match_operand:SI 0 "register_operand")
+                           (match_operand:SI 1 "general_operand"))))))
+  "atom-simple-either")
+
+;; 32<-16, 32<-8, 64<-16, 64<-8, 64<-32, 8<-8
+(define_insn_reservation  "atom_imovx_2" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imovx")
+            (and (eq_attr "memory" "none")
+                 (ior (match_operand:QI 0 "register_operand")
+                      (ior (and (match_operand:SI 0 "register_operand")
+                                (not (match_operand:SI 1 "general_operand")))
+                           (match_operand:DI 0 "register_operand"))))))
+  "atom-simple-0")
+
+;; 32<-16, 32<-8, 64<-16, 64<-8, 64<-32, 8<-8, mem
+(define_insn_reservation  "atom_imovx_2_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imovx")
+            (and (eq_attr "memory" "!none")
+                 (ior (match_operand:QI 0 "register_operand")
+                      (ior (and (match_operand:SI 0 "register_operand")
+                                (not (match_operand:SI 1 "general_operand")))
+                           (match_operand:DI 0 "register_operand"))))))
+  "atom-simple-0")
+
+;; 16<-8
+(define_insn_reservation  "atom_imovx_3" 3
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imovx")
+            (and (match_operand:HI 0 "register_operand")
+                 (match_operand:QI 1 "general_operand"))))
+  "atom-complex, atom-all-eu*2")
+
+(define_insn_reservation  "atom_lea" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "lea")
+            (eq_attr "mode" "!HI")))
+  "atom-simple-either")
+
+;; lea 16bit address is complex insn
+(define_insn_reservation  "atom_lea_2" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "lea")
+            (eq_attr "mode" "HI")))
+  "atom-complex, atom-all-eu")
+
+(define_insn_reservation  "atom_incdec" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "incdec")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_incdec_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "incdec")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+;; simple shift instruction use SHIFT eu, none memory
+(define_insn_reservation  "atom_ishift" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ishift")
+            (and (eq_attr "memory" "none") (eq_attr "prefix_0f" "0"))))
+  "atom-simple-0")
+
+;; simple shift instruction use SHIFT eu, memory
+(define_insn_reservation  "atom_ishift_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ishift")
+            (and (eq_attr "memory" "!none") (eq_attr "prefix_0f" "0"))))
+  "atom-simple-0")
+
+;; DF shift (prefixed with 0f) is complex insn with latency of 7 cycles
+(define_insn_reservation  "atom_ishift_3" 7
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ishift")
+            (eq_attr "prefix_0f" "1")))
+  "atom-complex, atom-all-eu*6")
+
+(define_insn_reservation  "atom_ishift1" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ishift1")
+            (eq_attr "memory" "none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_ishift1_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ishift1")
+            (eq_attr "memory" "!none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_rotate" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "rotate")
+            (eq_attr "memory" "none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_rotate_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "rotate")
+            (eq_attr "memory" "!none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_rotate1" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "rotate1")
+            (eq_attr "memory" "none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_rotate1_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "rotate1")
+            (eq_attr "memory" "!none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_imul" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imul")
+            (and (eq_attr "memory" "none") (eq_attr "mode" "SI"))))
+  "atom-imul-32")
+
+(define_insn_reservation  "atom_imul_mem" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imul")
+            (and (eq_attr "memory" "!none") (eq_attr "mode" "SI"))))
+  "atom-imul-32")
+
+;; latency set to 10 as common 64x64 imul
+(define_insn_reservation  "atom_imul_3" 10
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "imul")
+            (eq_attr "mode" "!SI")))
+  "atom-complex, atom-all-eu*9")
+
+(define_insn_reservation  "atom_idiv" 65
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "idiv"))
+  "atom-complex, atom-all-eu*32, nothing*32")
+
+(define_insn_reservation  "atom_icmp" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "icmp")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_icmp_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "icmp")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_test" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "test")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_test_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "test")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_ibr" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ibr")
+            (eq_attr "memory" "!load")))
+  "atom-simple-1")
+
+;; complex if jump target is from address
+(define_insn_reservation  "atom_ibr_2" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ibr")
+            (eq_attr "memory" "load")))
+  "atom-complex, atom-all-eu")
+
+(define_insn_reservation  "atom_setcc" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "setcc")
+            (eq_attr "memory" "!store")))
+  "atom-simple-either")
+
+;; 2 cycles complex if target is in memory
+(define_insn_reservation  "atom_setcc_2" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "setcc")
+            (eq_attr "memory" "store")))
+  "atom-complex, atom-all-eu")
+
+(define_insn_reservation  "atom_icmov" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "icmov")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_icmov_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "icmov")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+;; UCODE if segreg, ignored
+(define_insn_reservation  "atom_push" 2
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "push"))
+  "atom-dual-2c")
+
+;; pop r64 is 1 cycle. UCODE if segreg, ignored
+(define_insn_reservation  "atom_pop" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "pop")
+            (eq_attr "mode" "DI")))
+  "atom-dual-1c")
+
+;; pop non-r64 is 2 cycles. UCODE if segreg, ignored
+(define_insn_reservation  "atom_pop_2" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "pop")
+            (eq_attr "mode" "!DI")))
+  "atom-dual-2c")
+
+;; UCODE if segreg, ignored
+(define_insn_reservation  "atom_call" 1
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "call"))
+  "atom-dual-1c")
+
+(define_insn_reservation  "atom_callv" 1
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "callv"))
+  "atom-dual-1c")
+
+(define_insn_reservation  "atom_leave" 3
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "leave"))
+  "atom-complex, atom-all-eu*2")
+
+(define_insn_reservation  "atom_str" 3
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "str"))
+  "atom-complex, atom-all-eu*2")
+
+(define_insn_reservation  "atom_sselog" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sselog")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_sselog_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sselog")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_sselog1" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sselog1")
+            (eq_attr "memory" "none")))
+  "atom-simple-0")
+
+(define_insn_reservation  "atom_sselog1_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sselog1")
+            (eq_attr "memory" "!none")))
+  "atom-simple-0")
+
+;; not pmad, not psad
+(define_insn_reservation  "atom_sseiadd" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseiadd")
+            (and (not (match_operand:V2DI 0 "register_operand"))
+                 (and (eq_attr "atom_unit" "!simul")
+                      (eq_attr "atom_unit" "!complex")))))
+  "atom-simple-either")
+
+;; pmad, psad and 64
+(define_insn_reservation  "atom_sseiadd_2" 4
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseiadd")
+            (and (not (match_operand:V2DI 0 "register_operand"))
+                 (and (eq_attr "atom_unit" "simul" )
+                      (eq_attr "mode" "DI")))))
+  "atom-fmul-4c")
+
+;; pmad, psad and 128
+(define_insn_reservation  "atom_sseiadd_3" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseiadd")
+            (and (not (match_operand:V2DI 0 "register_operand"))
+                 (and (eq_attr "atom_unit" "simul" )
+                      (eq_attr "mode" "TI")))))
+  "atom-fmul-5c")
+
+;; if paddq(64 bit op), phadd/phsub
+(define_insn_reservation  "atom_sseiadd_4" 6
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseiadd")
+            (ior (match_operand:V2DI 0 "register_operand")
+                 (eq_attr "atom_unit" "complex"))))
+  "atom-complex, atom-all-eu*5")
+
+;; if immediate op. 
+(define_insn_reservation  "atom_sseishft" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseishft")
+            (and (eq_attr "atom_unit" "!sishuf")
+                 (match_operand 2 "immediate_operand"))))
+  "atom-simple-either")
+
+;; if palignr or psrldq
+(define_insn_reservation  "atom_sseishft_2" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseishft")
+            (and (eq_attr "atom_unit" "sishuf")
+                 (match_operand 2 "immediate_operand"))))
+  "atom-simple-0")
+
+;; if reg/mem op
+(define_insn_reservation  "atom_sseishft_3" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseishft")
+            (not (match_operand 2 "immediate_operand"))))
+  "atom-complex, atom-all-eu")
+
+(define_insn_reservation  "atom_sseimul" 1
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "sseimul"))
+  "atom-simple-0")
+
+;; rcpss or rsqrtss
+(define_insn_reservation  "atom_sse" 4
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sse")
+            (and (eq_attr "atom_sse_attr" "rcp") (eq_attr "mode" "SF"))))
+  "atom-fmul-4c")
+
+;; movshdup, movsldup. Suggest to type sseishft
+(define_insn_reservation  "atom_sse_2" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sse")
+            (eq_attr "atom_sse_attr" "movdup")))
+  "atom-simple-0")
+
+;; lfence
+(define_insn_reservation  "atom_sse_3" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sse")
+            (eq_attr "atom_sse_attr" "lfence")))
+  "atom-simple-either")
+
+;; sfence,clflush,mfence, prefetch
+(define_insn_reservation  "atom_sse_4" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sse")
+            (ior (eq_attr "atom_sse_attr" "fence")
+                 (eq_attr "atom_sse_attr" "prefetch"))))
+  "atom-simple-0")
+
+;; rcpps, rsqrtss, sqrt, ldmxcsr
+(define_insn_reservation  "atom_sse_5" 7
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sse")
+            (ior (ior (eq_attr "atom_sse_attr" "sqrt")
+                      (eq_attr "atom_sse_attr" "mxcsr"))
+                 (and (eq_attr "atom_sse_attr" "rcp")
+                      (eq_attr "mode" "V4SF")))))
+  "atom-complex, atom-all-eu*6")
+
+;; xmm->xmm
+(define_insn_reservation  "atom_ssemov" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemov")
+            (and (match_operand 0 "register_operand" "xy") (match_operand 1 "register_operand" "xy"))))
+  "atom-simple-either")
+
+;; reg->xmm
+(define_insn_reservation  "atom_ssemov_2" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemov")
+            (and (match_operand 0 "register_operand" "xy") (match_operand 1 "register_operand" "r"))))
+  "atom-simple-0")
+
+;; xmm->reg
+(define_insn_reservation  "atom_ssemov_3" 3
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemov")
+            (and (match_operand 0 "register_operand" "r") (match_operand 1 "register_operand" "xy"))))
+  "atom-eu-0-3-1")
+
+;; mov mem
+(define_insn_reservation  "atom_ssemov_4" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemov")
+            (and (eq_attr "movu" "0") (eq_attr "memory" "!none"))))
+  "atom-simple-0")
+
+;; movu mem
+(define_insn_reservation  "atom_ssemov_5" 2
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemov")
+            (ior (eq_attr "movu" "1") (eq_attr "memory" "!none"))))
+  "atom-complex, atom-all-eu")
+
+;; no memory simple
+(define_insn_reservation  "atom_sseadd" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseadd")
+            (and (eq_attr "memory" "none")
+                 (and (eq_attr "mode" "!V2DF")
+                      (eq_attr "atom_unit" "!complex")))))
+  "atom-fadd-5c")
+
+;; memory simple
+(define_insn_reservation  "atom_sseadd_mem" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseadd")
+            (and (eq_attr "memory" "!none")
+                 (and (eq_attr "mode" "!V2DF")
+                      (eq_attr "atom_unit" "!complex")))))
+  "atom-dual-5c")
+
+;; maxps, minps, *pd, hadd, hsub
+(define_insn_reservation  "atom_sseadd_3" 8
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseadd")
+            (ior (eq_attr "mode" "V2DF") (eq_attr "atom_unit" "complex"))))
+  "atom-complex, atom-all-eu*7")
+
+;; Except dppd/dpps
+(define_insn_reservation  "atom_ssemul" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemul")
+            (eq_attr "mode" "!SF")))
+  "atom-fmul-5c")
+
+;; Except dppd/dpps, 4 cycle if mulss
+(define_insn_reservation  "atom_ssemul_2" 4
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssemul")
+            (eq_attr "mode" "SF")))
+  "atom-fmul-4c")
+
+(define_insn_reservation  "atom_ssecmp" 1
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "ssecmp"))
+  "atom-simple-either")
+
+(define_insn_reservation  "atom_ssecomi" 10
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "ssecomi"))
+  "atom-complex, atom-all-eu*9")
+
+;; no memory and cvtpi2ps, cvtps2pi, cvttps2pi
+(define_insn_reservation  "atom_ssecvt" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssecvt")
+            (ior (and (match_operand:V2SI 0 "register_operand")
+                      (match_operand:V4SF 1 "register_operand"))
+                 (and (match_operand:V4SF 0 "register_operand")
+                      (match_operand:V2SI 1 "register_operand")))))
+  "atom-fadd-5c")
+
+;; memory and cvtpi2ps, cvtps2pi, cvttps2pi
+(define_insn_reservation  "atom_ssecvt_2" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssecvt")
+            (ior (and (match_operand:V2SI 0 "register_operand")
+                      (match_operand:V4SF 1 "memory_operand"))
+                 (and (match_operand:V4SF 0 "register_operand")
+                      (match_operand:V2SI 1 "memory_operand")))))
+  "atom-dual-5c")
+
+;; otherwise. 7 cycles average for cvtss2sd
+(define_insn_reservation  "atom_ssecvt_3" 7
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "ssecvt")
+            (not (ior (and (match_operand:V2SI 0 "register_operand")
+                           (match_operand:V4SF 1 "nonimmediate_operand"))
+                      (and (match_operand:V4SF 0 "register_operand")
+                           (match_operand:V2SI 1 "nonimmediate_operand"))))))
+  "atom-complex, atom-all-eu*6")
+
+;; memory and cvtsi2sd
+(define_insn_reservation  "atom_sseicvt" 5
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseicvt")
+            (and (match_operand:V2DF 0 "register_operand")
+                 (match_operand:SI 1 "memory_operand"))))
+  "atom-dual-5c")
+
+;; otherwise. 8 cycles average for cvtsd2si
+(define_insn_reservation  "atom_sseicvt_2" 8
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "sseicvt")
+            (not (and (match_operand:V2DF 0 "register_operand")
+                      (match_operand:SI 1 "memory_operand")))))
+  "atom-complex, atom-all-eu*7")
+
+(define_insn_reservation  "atom_ssediv" 62
+  (and (eq_attr "cpu" "atom")
+       (eq_attr "type" "ssediv"))
+  "atom-complex, atom-all-eu*12, nothing*49")
+
+;; simple for fmov
+(define_insn_reservation  "atom_fmov" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "fmov")
+            (eq_attr "memory" "none")))
+  "atom-simple-either")
+
+;; simple for fmov
+(define_insn_reservation  "atom_fmov_mem" 1
+  (and (eq_attr "cpu" "atom")
+       (and (eq_attr "type" "fmov")
+            (eq_attr "memory" "!none")))
+  "atom-simple-either")
+
+;; Define bypass here
+
+;; There will be no stall from lea to non-mem EX insns
+(define_bypass 0 "atom_lea"
+                 "atom_alu_carry,
+                  atom_alu,atom_alu1,atom_negnot,atom_imov,atom_imovx,
+                  atom_incdec, atom_setcc, atom_icmov, atom_pop")
+
+(define_bypass 0 "atom_lea"
+                 "atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_imovx_mem, atom_imovx_2_mem,
+                  atom_imov_mem, atom_icmov_mem, atom_fmov_mem"
+                 "!ix86_agi_dependent")
+
+;; There will be 3 cycles stall from EX insns to AGAN insns LEA
+(define_bypass 4 "atom_alu_carry,
+                  atom_alu,atom_alu1,atom_negnot,atom_imov,atom_imovx,
+                  atom_incdec,atom_ishift,atom_ishift1,atom_rotate,
+                  atom_rotate1, atom_setcc, atom_icmov, atom_pop,
+                  atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_imovx_mem, atom_imovx_2_mem,
+                  atom_imov_mem, atom_icmov_mem, atom_fmov_mem"
+                 "atom_lea")
+
+;; There will be 3 cycles stall from EX insns to insns need addr calculation
+(define_bypass 4 "atom_alu_carry,
+                  atom_alu,atom_alu1,atom_negnot,atom_imov,atom_imovx,
+                  atom_incdec,atom_ishift,atom_ishift1,atom_rotate,
+                  atom_rotate1, atom_setcc, atom_icmov, atom_pop,
+                  atom_imovx_mem, atom_imovx_2_mem,
+                  atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_imov_mem, atom_icmov_mem, atom_fmov_mem"
+                 "atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_negnot_mem, atom_imov_mem, atom_incdec_mem,
+                  atom_imovx_mem, atom_imovx_2_mem,
+                  atom_imul_mem, atom_icmp_mem,
+                  atom_test_mem, atom_icmov_mem, atom_sselog_mem,
+                  atom_sselog1_mem, atom_fmov_mem, atom_sseadd_mem,
+                  atom_ishift_mem, atom_ishift1_mem, 
+                  atom_rotate_mem, atom_rotate1_mem"
+                  "ix86_agi_dependent")
+
+;; Stall from imul to lea is 8 cycles.
+(define_bypass 9 "atom_imul, atom_imul_mem" "atom_lea")
+
+;; Stall from imul to memory address is 8 cycles.
+(define_bypass 9 "atom_imul, atom_imul_mem" 
+                 "atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_negnot_mem, atom_imov_mem, atom_incdec_mem,
+                  atom_ishift_mem, atom_ishift1_mem, atom_rotate_mem,
+                  atom_rotate1_mem, atom_imul_mem, atom_icmp_mem,
+                  atom_test_mem, atom_icmov_mem, atom_sselog_mem,
+                  atom_sselog1_mem, atom_fmov_mem, atom_sseadd_mem"
+                  "ix86_agi_dependent")
+
+;; There will be 0 cycle stall from cmp/test to jcc
+
+;; There will be 1 cycle stall from flag producer to cmov and adc/sbb
+(define_bypass 2 "atom_icmp, atom_test, atom_alu, atom_alu_carry,
+                  atom_alu1, atom_negnot, atom_incdec, atom_ishift,
+                  atom_ishift1, atom_rotate, atom_rotate1"
+                 "atom_icmov, atom_alu_carry")
+
+;; lea to shift count stall is 2 cycles
+(define_bypass 3 "atom_lea"
+                 "atom_ishift, atom_ishift1, atom_rotate, atom_rotate1,
+                  atom_ishift_mem, atom_ishift1_mem, 
+                  atom_rotate_mem, atom_rotate1_mem"
+                 "ix86_dep_by_shift_count")
+
+;; lea to shift source stall is 1 cycle
+(define_bypass 2 "atom_lea"
+                 "atom_ishift, atom_ishift1, atom_rotate, atom_rotate1"
+                 "!ix86_dep_by_shift_count")
+
+;; non-lea to shift count stall is 1 cycle
+(define_bypass 2 "atom_alu_carry,
+                  atom_alu,atom_alu1,atom_negnot,atom_imov,atom_imovx,
+                  atom_incdec,atom_ishift,atom_ishift1,atom_rotate,
+                  atom_rotate1, atom_setcc, atom_icmov, atom_pop,
+                  atom_alu_mem, atom_alu_carry_mem, atom_alu1_mem,
+                  atom_imovx_mem, atom_imovx_2_mem,
+                  atom_imov_mem, atom_icmov_mem, atom_fmov_mem"
+                 "atom_ishift, atom_ishift1, atom_rotate, atom_rotate1,
+                  atom_ishift_mem, atom_ishift1_mem, 
+                  atom_rotate_mem, atom_rotate1_mem"
+                 "ix86_dep_by_shift_count")
diff --git a/gcc/config/i386/cpuid.h b/gcc/config/i386/cpuid.h
index b5258652e..2d0916fb3 100644
--- a/gcc/config/i386/cpuid.h
+++ b/gcc/config/i386/cpuid.h
@@ -29,6 +29,7 @@
 #define bit_CMPXCHG16B	(1 << 13)
 #define bit_SSE4_1	(1 << 19)
 #define bit_SSE4_2	(1 << 20)
+#define bit_MOVBE	(1 << 22)
 #define bit_POPCNT	(1 << 23)
 #define bit_AES		(1 << 25)
 #define bit_XSAVE	(1 << 26)
diff --git a/gcc/config/i386/cs-linux-lite.h b/gcc/config/i386/cs-linux-lite.h
new file mode 100644
index 000000000..c3c873e7f
--- /dev/null
+++ b/gcc/config/i386/cs-linux-lite.h
@@ -0,0 +1,31 @@
+/* Sourcery G++ Lite IA32 GNU/Linux Configuration.
+   Copyright (C) 2009
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{march=atom:%{!m64:/atom} ;			\
+     march=core2:%{m64:/core2}}"
+
+/* See mips/wrs-linux.h for details on this use of
+   STARTFILE_PREFIX_SPEC.  */
+#undef STARTFILE_PREFIX_SPEC
+#define STARTFILE_PREFIX_SPEC				\
+  "%{m64: /usr/local/lib64/ /lib64/ /usr/lib64/}	\
+   %{!m64: /usr/local/lib/ /lib/ /usr/lib/}"
diff --git a/gcc/config/i386/cs-linux.h b/gcc/config/i386/cs-linux.h
new file mode 100644
index 000000000..8a0beb83c
--- /dev/null
+++ b/gcc/config/i386/cs-linux.h
@@ -0,0 +1,41 @@
+/* Sourcery G++ IA32 GNU/Linux Configuration.
+   Copyright (C) 2007
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* This configuration may be used either with the system glibc (in
+   system32 and system64 subdirectories) or with the included glibc
+   (in the sgxx-glibc subdirectory).  */
+
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{msgxx-glibc:/sgxx-glibc ;			\
+     m64:/system64 ;				\
+     mrhel3:/system64 ;				\
+     mrh73:/system32-old ;			\
+     :/system32}"
+
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC SYSROOT_SUFFIX_SPEC
+
+/* See mips/wrs-linux.h for details on this use of
+   STARTFILE_PREFIX_SPEC.  */
+#undef STARTFILE_PREFIX_SPEC
+#define STARTFILE_PREFIX_SPEC				\
+  "%{m64: /usr/local/lib64/ /lib64/ /usr/lib64/}	\
+   %{!m64: /usr/local/lib/ /lib/ /usr/lib/}"
diff --git a/gcc/config/i386/cs-linux.opt b/gcc/config/i386/cs-linux.opt
new file mode 100644
index 000000000..0c070777e
--- /dev/null
+++ b/gcc/config/i386/cs-linux.opt
@@ -0,0 +1,11 @@
+; Additional options for Sourcery G++.
+
+mrh73
+Target Undocumented
+
+mrhel3
+Target Undocumented
+
+msgxx-glibc
+Target
+Use included version of GLIBC
diff --git a/gcc/config/i386/cygming.h b/gcc/config/i386/cygming.h
index 4f508a776..39650b107 100644
--- a/gcc/config/i386/cygming.h
+++ b/gcc/config/i386/cygming.h
@@ -34,7 +34,7 @@ along with GCC; see the file COPYING3.  If not see
 #endif
 
 #undef TARGET_64BIT_MS_ABI
-#define TARGET_64BIT_MS_ABI (!cfun ? DEFAULT_ABI == MS_ABI : TARGET_64BIT && cfun->machine->call_abi == MS_ABI)
+#define TARGET_64BIT_MS_ABI (!cfun ? ix86_abi == MS_ABI : TARGET_64BIT && cfun->machine->call_abi == MS_ABI)
 
 #undef DEFAULT_ABI
 #define DEFAULT_ABI (TARGET_64BIT ? MS_ABI : SYSV_ABI)
@@ -202,7 +202,7 @@ do {						\
 #define CHECK_STACK_LIMIT 4000
 
 #undef STACK_BOUNDARY
-#define STACK_BOUNDARY	(DEFAULT_ABI == MS_ABI ? 128 : BITS_PER_WORD)
+#define STACK_BOUNDARY	(ix86_abi == MS_ABI ? 128 : BITS_PER_WORD)
 
 /* By default, target has a 80387, uses IEEE compatible arithmetic,
    returns float values in the 387 and needs stack probes.
diff --git a/gcc/config/i386/cygming.opt b/gcc/config/i386/cygming.opt
index 7c29eb89b..e845a0d58 100644
--- a/gcc/config/i386/cygming.opt
+++ b/gcc/config/i386/cygming.opt
@@ -45,3 +45,7 @@ Set Windows defines
 mwindows
 Target
 Create GUI application
+
+mpe-aligned-commons
+Target Var(use_pe_aligned_common) Init(HAVE_GAS_ALIGNED_COMM)
+Use the GNU extension to the PE format for aligned common data
diff --git a/gcc/config/i386/driver-i386.c b/gcc/config/i386/driver-i386.c
index 9aa33d27c..0364beaeb 100644
--- a/gcc/config/i386/driver-i386.c
+++ b/gcc/config/i386/driver-i386.c
@@ -378,7 +378,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)
   /* Extended features */
   unsigned int has_lahf_lm = 0, has_sse4a = 0;
   unsigned int has_longmode = 0, has_3dnowp = 0, has_3dnow = 0;
-  unsigned int has_sse4_1 = 0, has_sse4_2 = 0;
+  unsigned int has_movbe = 0, has_sse4_1 = 0, has_sse4_2 = 0;
   unsigned int has_popcnt = 0, has_aes = 0, has_avx = 0;
   unsigned int has_pclmul = 0;
 
@@ -398,9 +398,22 @@ const char *host_detect_local_cpu (int argc, const char **argv)
 
   __cpuid (1, eax, ebx, ecx, edx);
 
-  /* We don't care for extended family.  */
   model = (eax >> 4) & 0x0f;
   family = (eax >> 8) & 0x0f;
+  if (vendor == SIG_INTEL)
+    {
+      unsigned int extended_model, extended_family;
+
+      extended_model = (eax >> 12) & 0xf0;
+      extended_family = (eax >> 20) & 0xff;
+      if (family == 0x0f)
+	{
+	  family += extended_family;
+	  model += extended_model;
+	}
+      else if (family == 0x06)
+	model += extended_model;
+    }
 
   has_sse3 = ecx & bit_SSE3;
   has_ssse3 = ecx & bit_SSSE3;
@@ -408,6 +421,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)
   has_sse4_2 = ecx & bit_SSE4_2;
   has_avx = ecx & bit_AVX;
   has_cmpxchg16b = ecx & bit_CMPXCHG16B;
+  has_movbe = ecx & bit_MOVBE;
   has_popcnt = ecx & bit_POPCNT;
   has_aes = ecx & bit_AES;
   has_pclmul = ecx & bit_PCLMUL;
@@ -505,8 +519,8 @@ const char *host_detect_local_cpu (int argc, const char **argv)
       break;
     case PROCESSOR_PENTIUMPRO:
       if (has_longmode)
-	/* It is Core 2 Duo.  */
-	cpu = "core2";
+	/* It is Core 2 or Atom.  */
+	cpu = (model == 28) ? "atom" : "core2";
       else if (arch)
 	{
 	  if (has_sse3)
@@ -597,6 +611,8 @@ const char *host_detect_local_cpu (int argc, const char **argv)
 	options = concat (options, "-mcx16 ", NULL);
       if (has_lahf_lm)
 	options = concat (options, "-msahf ", NULL);
+      if (has_movbe)
+	options = concat (options, "-mmovbe ", NULL);
       if (has_aes)
 	options = concat (options, "-maes ", NULL);
       if (has_pclmul)
diff --git a/gcc/config/i386/gthr-win32.c b/gcc/config/i386/gthr-win32.c
index 46ecb0d4b..920b7c9dc 100644
--- a/gcc/config/i386/gthr-win32.c
+++ b/gcc/config/i386/gthr-win32.c
@@ -32,7 +32,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 # define __GTHREAD_HIDE_WIN32API 1
 #endif
 #undef  __GTHREAD_I486_INLINE_LOCK_PRIMITIVES
+#ifdef __i386__
 #define __GTHREAD_I486_INLINE_LOCK_PRIMITIVES
+#endif
 #include <gthr-win32.h>
 
 /* Windows32 threads specific definitions. The windows32 threading model
@@ -70,7 +72,11 @@ int
 __gthr_win32_once (__gthread_once_t *once, void (*func) (void))
 {
   if (once == NULL || func == NULL)
+#ifdef __MINGW32CE__
+    return -1;
+#else
     return EINVAL;
+#endif
 
   if (! once->done)
     {
diff --git a/gcc/config/i386/i386-c.c b/gcc/config/i386/i386-c.c
index 3d17c104e..0c59b2fef 100644
--- a/gcc/config/i386/i386-c.c
+++ b/gcc/config/i386/i386-c.c
@@ -119,6 +119,10 @@ ix86_target_macros_internal (int isa_flag,
       def_or_undef (parse_in, "__core2");
       def_or_undef (parse_in, "__core2__");
       break;
+    case PROCESSOR_ATOM:
+      def_or_undef (parse_in, "__atom");
+      def_or_undef (parse_in, "__atom__");
+      break;
     /* use PROCESSOR_max to not set/unset the arch macro.  */
     case PROCESSOR_max:
       break;
@@ -187,6 +191,9 @@ ix86_target_macros_internal (int isa_flag,
     case PROCESSOR_CORE2:
       def_or_undef (parse_in, "__tune_core2__");
       break;
+    case PROCESSOR_ATOM:
+      def_or_undef (parse_in, "__tune_atom__");
+      break;
     case PROCESSOR_GENERIC32:
     case PROCESSOR_GENERIC64:
       break;
diff --git a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
index 48e22f87e..01a2ac713 100644
--- a/gcc/config/i386/i386-protos.h
+++ b/gcc/config/i386/i386-protos.h
@@ -86,6 +86,9 @@ extern void ix86_fixup_binary_operands_no_copy (enum rtx_code,
 extern void ix86_expand_binary_operator (enum rtx_code,
 					 enum machine_mode, rtx[]);
 extern int ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);
+extern bool ix86_lea_for_add_ok (enum rtx_code, rtx, rtx[]);
+extern bool ix86_dep_by_shift_count (const_rtx set_insn, const_rtx use_insn);
+extern bool ix86_agi_dependent (rtx set_insn, rtx use_insn);
 extern void ix86_expand_unary_operator (enum rtx_code, enum machine_mode,
 					rtx[]);
 extern rtx ix86_build_const_vector (enum machine_mode, bool, rtx);
@@ -140,9 +143,8 @@ extern int ix86_function_arg_boundary (enum machine_mode, const_tree);
 extern bool ix86_solaris_return_in_memory (const_tree, const_tree);
 extern rtx ix86_force_to_memory (enum machine_mode, rtx);
 extern void ix86_free_from_memory (enum machine_mode);
-extern int ix86_cfun_abi (void);
-extern int ix86_function_abi (const_tree);
-extern int ix86_function_type_abi (const_tree);
+extern enum calling_abi ix86_cfun_abi (void);
+extern enum calling_abi ix86_function_type_abi (const_tree);
 extern void ix86_call_abi_override (const_tree);
 extern tree ix86_fn_abi_va_list (tree);
 extern tree ix86_canonical_va_list_type (tree);
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index e86f7cf7f..e49b041d0 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -1036,6 +1036,79 @@ struct processor_costs core2_cost = {
   1,                                    /* cond_not_taken_branch_cost.  */
 };
 
+static const
+struct processor_costs atom_cost = {
+  COSTS_N_INSNS (1),			/* cost of an add instruction */
+  COSTS_N_INSNS (1) + 1,		/* cost of a lea instruction */
+  COSTS_N_INSNS (1),			/* variable shift costs */
+  COSTS_N_INSNS (1),			/* constant shift costs */
+  {COSTS_N_INSNS (3),			/* cost of starting multiply for QI */
+   COSTS_N_INSNS (4),			/*                               HI */
+   COSTS_N_INSNS (3),			/*                               SI */
+   COSTS_N_INSNS (4),			/*                               DI */
+   COSTS_N_INSNS (2)},			/*                               other */
+  0,					/* cost of multiply per each bit set */
+  {COSTS_N_INSNS (18),			/* cost of a divide/mod for QI */
+   COSTS_N_INSNS (26),			/*                          HI */
+   COSTS_N_INSNS (42),			/*                          SI */
+   COSTS_N_INSNS (74),			/*                          DI */
+   COSTS_N_INSNS (74)},			/*                          other */
+  COSTS_N_INSNS (1),			/* cost of movsx */
+  COSTS_N_INSNS (1),			/* cost of movzx */
+  8,					/* "large" insn */
+  17,					/* MOVE_RATIO */
+  2,					/* cost for loading QImode using movzbl */
+  {4, 4, 4},				/* cost of loading integer registers
+					   in QImode, HImode and SImode.
+					   Relative to reg-reg move (2).  */
+  {4, 4, 4},				/* cost of storing integer registers */
+  4,					/* cost of reg,reg fld/fst */
+  {12, 12, 12},				/* cost of loading fp registers
+					   in SFmode, DFmode and XFmode */
+  {6, 6, 8},				/* cost of storing fp registers
+					   in SFmode, DFmode and XFmode */
+  2,					/* cost of moving MMX register */
+  {8, 8},				/* cost of loading MMX registers
+					   in SImode and DImode */
+  {8, 8},				/* cost of storing MMX registers
+					   in SImode and DImode */
+  2,					/* cost of moving SSE register */
+  {8, 8, 8},				/* cost of loading SSE registers
+					   in SImode, DImode and TImode */
+  {8, 8, 8},				/* cost of storing SSE registers
+					   in SImode, DImode and TImode */
+  5,					/* MMX or SSE register to integer */
+  32,					/* size of l1 cache.  */
+  256,					/* size of l2 cache.  */
+  64,					/* size of prefetch block */
+  6,					/* number of parallel prefetches */
+  3,					/* Branch cost */
+  COSTS_N_INSNS (8),			/* cost of FADD and FSUB insns.  */
+  COSTS_N_INSNS (8),			/* cost of FMUL instruction.  */
+  COSTS_N_INSNS (20),			/* cost of FDIV instruction.  */
+  COSTS_N_INSNS (8),			/* cost of FABS instruction.  */
+  COSTS_N_INSNS (8),			/* cost of FCHS instruction.  */
+  COSTS_N_INSNS (40),			/* cost of FSQRT instruction.  */
+  {{libcall, {{11, loop}, {-1, rep_prefix_4_byte}}},
+   {libcall, {{32, loop}, {64, rep_prefix_4_byte},
+          {8192, rep_prefix_8_byte}, {-1, libcall}}}},
+  {{libcall, {{8, loop}, {15, unrolled_loop},
+          {2048, rep_prefix_4_byte}, {-1, libcall}}},
+   {libcall, {{24, loop}, {32, unrolled_loop},
+          {8192, rep_prefix_8_byte}, {-1, libcall}}}},
+  1,                                    /* scalar_stmt_cost.  */
+  1,                                    /* scalar load_cost.  */
+  1,                                    /* scalar_store_cost.  */
+  1,                                    /* vec_stmt_cost.  */
+  1,                                    /* vec_to_scalar_cost.  */
+  1,                                    /* scalar_to_vec_cost.  */
+  1,                                    /* vec_align_load_cost.  */
+  2,                                    /* vec_unalign_load_cost.  */
+  1,                                    /* vec_store_cost.  */
+  3,                                    /* cond_taken_branch_cost.  */
+  1,                                    /* cond_not_taken_branch_cost.  */
+};
+
 /* Generic64 should produce code tuned for Nocona and K8.  */
 static const
 struct processor_costs generic64_cost = {
@@ -1194,6 +1267,7 @@ const struct processor_costs *ix86_cost = &pentium_cost;
 #define m_PENT4  (1<<PROCESSOR_PENTIUM4)
 #define m_NOCONA  (1<<PROCESSOR_NOCONA)
 #define m_CORE2  (1<<PROCESSOR_CORE2)
+#define m_ATOM  (1<<PROCESSOR_ATOM)
 
 #define m_GEODE  (1<<PROCESSOR_GEODE)
 #define m_K6  (1<<PROCESSOR_K6)
@@ -1231,10 +1305,11 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {
   m_486 | m_PENT,
 
   /* X86_TUNE_UNROLL_STRLEN */
-  m_486 | m_PENT | m_PPRO | m_AMD_MULTIPLE | m_K6 | m_CORE2 | m_GENERIC,
+  m_486 | m_PENT | m_ATOM | m_PPRO | m_AMD_MULTIPLE | m_K6
+  | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_DEEP_BRANCH_PREDICTION */
-  m_PPRO | m_K6_GEODE | m_AMD_MULTIPLE | m_PENT4 | m_GENERIC,
+  m_ATOM | m_PPRO | m_K6_GEODE | m_AMD_MULTIPLE | m_PENT4 | m_GENERIC,
 
   /* X86_TUNE_BRANCH_PREDICTION_HINTS: Branch hints were put in P4 based
      on simulation result. But after P4 was made, no performance benefit
@@ -1246,12 +1321,12 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {
   ~m_386,
 
   /* X86_TUNE_USE_SAHF */
-  m_PPRO | m_K6_GEODE | m_K8 | m_AMDFAM10 | m_PENT4
+  m_ATOM | m_PPRO | m_K6_GEODE | m_K8 | m_AMDFAM10 | m_PENT4
   | m_NOCONA | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_MOVX: Enable to zero extend integer registers to avoid
      partial dependencies.  */
-  m_AMD_MULTIPLE | m_PPRO | m_PENT4 | m_NOCONA
+  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_PENT4 | m_NOCONA
   | m_CORE2 | m_GENERIC | m_GEODE /* m_386 | m_K6 */,
 
   /* X86_TUNE_PARTIAL_REG_STALL: We probably ought to watch for partial
@@ -1271,13 +1346,13 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {
   m_386 | m_486 | m_K6_GEODE,
 
   /* X86_TUNE_USE_SIMODE_FIOP */
-  ~(m_PPRO | m_AMD_MULTIPLE | m_PENT | m_CORE2 | m_GENERIC),
+  ~(m_PPRO | m_AMD_MULTIPLE | m_PENT | m_ATOM | m_CORE2 | m_GENERIC),
 
   /* X86_TUNE_USE_MOV0 */
   m_K6,
 
   /* X86_TUNE_USE_CLTD */
-  ~(m_PENT | m_K6 | m_CORE2 | m_GENERIC),
+  ~(m_PENT | m_ATOM | m_K6 | m_CORE2 | m_GENERIC),
 
   /* X86_TUNE_USE_XCHGB: Use xchgb %rh,%rl instead of rolw/rorw $8,rx.  */
   m_PENT4,
@@ -1292,8 +1367,8 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {
   ~(m_PENT | m_PPRO),
 
   /* X86_TUNE_PROMOTE_QIMODE */
-  m_K6_GEODE | m_PENT | m_386 | m_486 | m_AMD_MULTIPLE | m_CORE2
-  | m_GENERIC /* | m_PENT4 ? */,
+  m_K6_GEODE | m_PENT | m_ATOM | m_386 | m_486 | m_AMD_MULTIPLE
+  | m_CORE2 | m_GENERIC /* | m_PENT4 ? */,
 
   /* X86_TUNE_FAST_PREFIX */
   ~(m_PENT | m_486 | m_386),
@@ -1317,26 +1392,28 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {
   m_PPRO,
 
   /* X86_TUNE_ADD_ESP_4: Enable if add/sub is preferred over 1/2 push/pop.  */
-  m_AMD_MULTIPLE | m_K6_GEODE | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
+  m_ATOM | m_AMD_MULTIPLE | m_K6_GEODE | m_PENT4 | m_NOCONA
+  | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_ADD_ESP_8 */
-  m_AMD_MULTIPLE | m_PPRO | m_K6_GEODE | m_386
+  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_K6_GEODE | m_386
   | m_486 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_SUB_ESP_4 */
-  m_AMD_MULTIPLE | m_PPRO | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
+  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_PENT4 | m_NOCONA | m_CORE2
+  | m_GENERIC,
 
   /* X86_TUNE_SUB_ESP_8 */
-  m_AMD_MULTIPLE | m_PPRO | m_386 | m_486
+  m_AMD_MULTIPLE | m_ATOM | m_PPRO | m_386 | m_486
   | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_INTEGER_DFMODE_MOVES: Enable if integer moves are preferred
      for DFmode copies */
-  ~(m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2
+  ~(m_AMD_MULTIPLE | m_ATOM | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2
     | m_GENERIC | m_GEODE),
 
   /* X86_TUNE_PARTIAL_REG_DEPENDENCY */
-  m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
+  m_AMD_MULTIPLE | m_ATOM | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY: In the Generic model we have a
      conflict here in between PPro/Pentium4 based chips that thread 128bit
@@ -1347,7 +1424,8 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {
      shows that disabling this option on P4 brings over 20% SPECfp regression,
      while enabling it on K8 brings roughly 2.4% regression that can be partly
      masked by careful scheduling of moves.  */
-  m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC | m_AMDFAM10,
+  m_ATOM | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC
+  | m_AMDFAM10,
 
   /* X86_TUNE_SSE_UNALIGNED_MOVE_OPTIMAL */
   m_AMDFAM10,
@@ -1365,13 +1443,13 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {
   m_PPRO | m_PENT4 | m_NOCONA,
 
   /* X86_TUNE_MEMORY_MISMATCH_STALL */
-  m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
+  m_AMD_MULTIPLE | m_ATOM | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_PROLOGUE_USING_MOVE */
-  m_ATHLON_K8 | m_PPRO | m_CORE2 | m_GENERIC,
+  m_ATHLON_K8 | m_ATOM | m_PPRO | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_EPILOGUE_USING_MOVE */
-  m_ATHLON_K8 | m_PPRO | m_CORE2 | m_GENERIC,
+  m_ATHLON_K8 | m_ATOM | m_PPRO | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_SHIFT1 */
   ~m_486,
@@ -1380,29 +1458,32 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {
   m_AMD_MULTIPLE,
 
   /* X86_TUNE_INTER_UNIT_MOVES */
-  ~(m_AMD_MULTIPLE | m_GENERIC),
+  ~(m_AMD_MULTIPLE | m_ATOM | m_GENERIC),
 
   /* X86_TUNE_INTER_UNIT_CONVERSIONS */
   ~(m_AMDFAM10),
 
   /* X86_TUNE_FOUR_JUMP_LIMIT: Some CPU cores are not able to predict more
      than 4 branch instructions in the 16 byte window.  */
-  m_PPRO | m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC,
+  m_ATOM | m_PPRO | m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_CORE2
+  | m_GENERIC,
 
   /* X86_TUNE_SCHEDULE */
-  m_PPRO | m_AMD_MULTIPLE | m_K6_GEODE | m_PENT | m_CORE2 | m_GENERIC,
+  m_PPRO | m_AMD_MULTIPLE | m_K6_GEODE | m_PENT | m_ATOM | m_CORE2
+  | m_GENERIC,
 
   /* X86_TUNE_USE_BT */
-  m_AMD_MULTIPLE | m_CORE2 | m_GENERIC,
+  m_AMD_MULTIPLE | m_ATOM | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_USE_INCDEC */
-  ~(m_PENT4 | m_NOCONA | m_GENERIC),
+  ~(m_PENT4 | m_NOCONA | m_GENERIC | m_ATOM),
 
   /* X86_TUNE_PAD_RETURNS */
   m_AMD_MULTIPLE | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_EXT_80387_CONSTANTS */
-  m_K6_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC,
+  m_K6_GEODE | m_ATHLON_K8 | m_ATOM | m_PENT4 | m_NOCONA | m_PPRO
+  | m_CORE2 | m_GENERIC,
 
   /* X86_TUNE_SHORTEN_X87_SSE */
   ~m_K8,
@@ -1447,6 +1528,10 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {
      with a subsequent conditional jump instruction into a single
      compare-and-branch uop.  */
   m_CORE2,
+
+  /* X86_TUNE_OPT_AGU: Optimize for Address Generation Unit. This flag
+     will impact LEA instruction selection. */
+  m_ATOM,
 };
 
 /* Feature tests against the various architecture variations.  */
@@ -1472,10 +1557,11 @@ static unsigned int initial_ix86_arch_features[X86_ARCH_LAST] = {
 };
 
 static const unsigned int x86_accumulate_outgoing_args
-  = m_AMD_MULTIPLE | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC;
+  = m_AMD_MULTIPLE | m_ATOM | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2
+    | m_GENERIC;
 
 static const unsigned int x86_arch_always_fancy_math_387
-  = m_PENT | m_PPRO | m_AMD_MULTIPLE | m_PENT4
+  = m_PENT | m_ATOM | m_PPRO | m_AMD_MULTIPLE | m_PENT4
     | m_NOCONA | m_CORE2 | m_GENERIC;
 
 static enum stringop_alg stringop_alg = no_stringop;
@@ -1743,6 +1829,9 @@ static unsigned int ix86_default_incoming_stack_boundary;
 /* Alignment for incoming stack boundary in bits.  */
 unsigned int ix86_incoming_stack_boundary;
 
+/* The abi used by target.  */
+enum calling_abi ix86_abi;
+
 /* Values 1-5: see jump.c */
 int ix86_branch_cost;
 
@@ -1819,6 +1908,8 @@ static bool ix86_valid_target_attribute_inner_p (tree, char *[]);
 static bool ix86_can_inline_p (tree, tree);
 static void ix86_set_current_function (tree);
 
+static enum calling_abi ix86_function_abi (const_tree);
+
 
 /* The svr4 ABI for the i386 says that records and unions are returned
    in memory.  */
@@ -1877,9 +1968,11 @@ static int ix86_isa_flags_explicit;
 
 #define OPTION_MASK_ISA_ABM_SET \
   (OPTION_MASK_ISA_ABM | OPTION_MASK_ISA_POPCNT)
+
 #define OPTION_MASK_ISA_POPCNT_SET OPTION_MASK_ISA_POPCNT
 #define OPTION_MASK_ISA_CX16_SET OPTION_MASK_ISA_CX16
 #define OPTION_MASK_ISA_SAHF_SET OPTION_MASK_ISA_SAHF
+#define OPTION_MASK_ISA_MOVBE_SET OPTION_MASK_ISA_MOVBE
 
 /* Define a set of ISAs which aren't available when a given ISA is
    disabled.  MMX and SSE ISAs are handled separately.  */
@@ -1921,6 +2014,7 @@ static int ix86_isa_flags_explicit;
 #define OPTION_MASK_ISA_POPCNT_UNSET OPTION_MASK_ISA_POPCNT
 #define OPTION_MASK_ISA_CX16_UNSET OPTION_MASK_ISA_CX16
 #define OPTION_MASK_ISA_SAHF_UNSET OPTION_MASK_ISA_SAHF
+#define OPTION_MASK_ISA_MOVBE_UNSET OPTION_MASK_ISA_MOVBE
 
 /* Vectorization library interface and handlers.  */
 tree (*ix86_veclib_handler)(enum built_in_function, tree, tree) = NULL;
@@ -1953,7 +2047,8 @@ static const struct ptt processor_target_table[PROCESSOR_max] =
   {&core2_cost, 16, 10, 16, 10, 16},
   {&generic32_cost, 16, 7, 16, 7, 16},
   {&generic64_cost, 16, 10, 16, 10, 16},
-  {&amdfam10_cost, 32, 24, 32, 7, 32}
+  {&amdfam10_cost, 32, 24, 32, 7, 32},
+  {&atom_cost, 16, 7, 16, 7, 16}
 };
 
 static const char *const cpu_names[TARGET_CPU_DEFAULT_max] =
@@ -1971,6 +2066,7 @@ static const char *const cpu_names[TARGET_CPU_DEFAULT_max] =
   "prescott",
   "nocona",
   "core2",
+  "atom",
   "geode",
   "k6",
   "k6-2",
@@ -2209,6 +2305,19 @@ ix86_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED, int value)
 	}
       return true;
 
+    case OPT_mmovbe:
+      if (value)
+	{
+	  ix86_isa_flags |= OPTION_MASK_ISA_MOVBE_SET;
+	  ix86_isa_flags_explicit |= OPTION_MASK_ISA_MOVBE_SET;
+	}
+      else
+	{
+	  ix86_isa_flags &= ~OPTION_MASK_ISA_MOVBE_UNSET;
+	  ix86_isa_flags_explicit |= OPTION_MASK_ISA_MOVBE_UNSET;
+	}
+      return true;
+
     case OPT_maes:
       if (value)
 	{
@@ -2271,6 +2380,7 @@ ix86_target_string (int isa, int flags, const char *arch, const char *tune,
     { "-mmmx",		OPTION_MASK_ISA_MMX },
     { "-mabm",		OPTION_MASK_ISA_ABM },
     { "-mpopcnt",	OPTION_MASK_ISA_POPCNT },
+    { "-mmovbe",	OPTION_MASK_ISA_MOVBE },
     { "-maes",		OPTION_MASK_ISA_AES },
     { "-mpclmul",	OPTION_MASK_ISA_PCLMUL },
   };
@@ -2487,7 +2597,8 @@ override_options (bool main_args_p)
       PTA_AES = 1 << 17,
       PTA_PCLMUL = 1 << 18,
       PTA_AVX = 1 << 19,
-      PTA_FMA = 1 << 20 
+      PTA_FMA = 1 << 20,
+      PTA_MOVBE = 1 << 21
     };
 
   static struct pta
@@ -2529,6 +2640,9 @@ override_options (bool main_args_p)
       {"core2", PROCESSOR_CORE2, CPU_CORE2,
 	PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3
 	| PTA_SSSE3 | PTA_CX16},
+      {"atom", PROCESSOR_ATOM, CPU_ATOM,
+	PTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3
+	| PTA_SSSE3 | PTA_CX16 | PTA_MOVBE},
       {"geode", PROCESSOR_GEODE, CPU_GEODE,
 	PTA_MMX | PTA_3DNOW | PTA_3DNOW_A |PTA_PREFETCH_SSE},
       {"k6", PROCESSOR_K6, CPU_K6, PTA_MMX},
@@ -2716,6 +2830,20 @@ override_options (bool main_args_p)
     error ("bad value (%s) for %sarch=%s %s",
 	   ix86_arch_string, prefix, suffix, sw);
 
+  /* Validate -mabi= value.  */
+  if (ix86_abi_string)
+    {
+      if (strcmp (ix86_abi_string, "sysv") == 0)
+	ix86_abi = SYSV_ABI;
+      else if (strcmp (ix86_abi_string, "ms") == 0)
+	ix86_abi = MS_ABI;
+      else
+	error ("unknown ABI (%s) for %sabi=%s %s",
+	       ix86_abi_string, prefix, suffix, sw);
+    }
+  else
+    ix86_abi = DEFAULT_ABI;
+
   if (ix86_cmodel_string != 0)
     {
       if (!strcmp (ix86_cmodel_string, "small"))
@@ -2828,6 +2956,9 @@ override_options (bool main_args_p)
 	if (!(TARGET_64BIT && (processor_alias_table[i].flags & PTA_NO_SAHF))
 	    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SAHF))
 	  ix86_isa_flags |= OPTION_MASK_ISA_SAHF;
+	if (processor_alias_table[i].flags & PTA_MOVBE
+	    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_MOVBE))
+	  ix86_isa_flags |= OPTION_MASK_ISA_MOVBE;
 	if (processor_alias_table[i].flags & PTA_AES
 	    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AES))
 	  ix86_isa_flags |= OPTION_MASK_ISA_AES;
@@ -4590,14 +4721,14 @@ ix86_function_arg_regno_p (int regno)
      default ABI.  */
 
   /* RAX is used as hidden argument to va_arg functions.  */
-  if (DEFAULT_ABI == SYSV_ABI && regno == AX_REG)
+  if (ix86_abi == SYSV_ABI && regno == AX_REG)
     return true;
 
-  if (DEFAULT_ABI == MS_ABI)
+  if (ix86_abi == MS_ABI)
     parm_regs = x86_64_ms_abi_int_parameter_registers;
   else
     parm_regs = x86_64_int_parameter_registers;
-  for (i = 0; i < (DEFAULT_ABI == MS_ABI ? X64_REGPARM_MAX
+  for (i = 0; i < (ix86_abi == MS_ABI ? X64_REGPARM_MAX
   					 : X86_64_REGPARM_MAX); i++)
     if (regno == parm_regs[i])
       return true;
@@ -4625,7 +4756,7 @@ ix86_must_pass_in_stack (enum machine_mode mode, const_tree type)
 int
 ix86_reg_parm_stack_space (const_tree fndecl)
 {
-  int call_abi = SYSV_ABI;
+  enum calling_abi call_abi = SYSV_ABI;
   if (fndecl != NULL_TREE && TREE_CODE (fndecl) == FUNCTION_DECL)
     call_abi = ix86_function_abi (fndecl);
   else
@@ -4637,37 +4768,39 @@ ix86_reg_parm_stack_space (const_tree fndecl)
 
 /* Returns value SYSV_ABI, MS_ABI dependent on fntype, specifying the
    call abi used.  */
-int
+enum calling_abi
 ix86_function_type_abi (const_tree fntype)
 {
   if (TARGET_64BIT && fntype != NULL)
     {
-      int abi;
-      if (DEFAULT_ABI == SYSV_ABI)
-        abi = lookup_attribute ("ms_abi", TYPE_ATTRIBUTES (fntype)) ? MS_ABI : SYSV_ABI;
-      else
-        abi = lookup_attribute ("sysv_abi", TYPE_ATTRIBUTES (fntype)) ? SYSV_ABI : MS_ABI;
-
+      enum calling_abi abi = ix86_abi;
+      if (abi == SYSV_ABI)
+	{
+	  if (lookup_attribute ("ms_abi", TYPE_ATTRIBUTES (fntype)))
+	    abi = MS_ABI;
+	}
+      else if (lookup_attribute ("sysv_abi", TYPE_ATTRIBUTES (fntype)))
+	abi = SYSV_ABI;
       return abi;
     }
-  return DEFAULT_ABI;
+  return ix86_abi;
 }
 
-int
+static enum calling_abi
 ix86_function_abi (const_tree fndecl)
 {
   if (! fndecl)
-    return DEFAULT_ABI;
+    return ix86_abi;
   return ix86_function_type_abi (TREE_TYPE (fndecl));
 }
 
 /* Returns value SYSV_ABI, MS_ABI dependent on cfun, specifying the
    call abi used.  */
-int
+enum calling_abi
 ix86_cfun_abi (void)
 {
   if (! cfun || ! TARGET_64BIT)
-    return DEFAULT_ABI;
+    return ix86_abi;
   return cfun->machine->call_abi;
 }
 
@@ -4681,7 +4814,7 @@ void
 ix86_call_abi_override (const_tree fndecl)
 {
   if (fndecl == NULL_TREE)
-    cfun->machine->call_abi = DEFAULT_ABI;
+    cfun->machine->call_abi = ix86_abi;
   else
     cfun->machine->call_abi = ix86_function_type_abi (TREE_TYPE (fndecl));
 }
@@ -4722,8 +4855,8 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */
   cum->nregs = ix86_regparm;
   if (TARGET_64BIT)
     {
-      if (cum->call_abi != DEFAULT_ABI)
-        cum->nregs = DEFAULT_ABI != SYSV_ABI ? X86_64_REGPARM_MAX
+      if (cum->call_abi != ix86_abi)
+        cum->nregs = ix86_abi != SYSV_ABI ? X86_64_REGPARM_MAX
         				     : X64_REGPARM_MAX;
     }
   if (TARGET_SSE)
@@ -4731,8 +4864,8 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */
       cum->sse_nregs = SSE_REGPARM_MAX;
       if (TARGET_64BIT)
         {
-          if (cum->call_abi != DEFAULT_ABI)
-            cum->sse_nregs = DEFAULT_ABI != SYSV_ABI ? X86_64_SSE_REGPARM_MAX
+          if (cum->call_abi != ix86_abi)
+            cum->sse_nregs = ix86_abi != SYSV_ABI ? X86_64_SSE_REGPARM_MAX
             					     : X64_SSE_REGPARM_MAX;
         }
     }
@@ -5701,7 +5834,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,
   if (type)
     mode = type_natural_mode (type, NULL);
 
-  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)
+  if (TARGET_64BIT && (cum ? cum->call_abi : ix86_abi) == MS_ABI)
     function_arg_advance_ms_64 (cum, bytes, words);
   else if (TARGET_64BIT)
     function_arg_advance_64 (cum, mode, type, words, named);
@@ -5847,9 +5980,9 @@ function_arg_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,
   if (mode == VOIDmode)
     return GEN_INT (cum->maybe_vaarg
 		    ? (cum->sse_nregs < 0
-		       ? (cum->call_abi == DEFAULT_ABI
+		       ? (cum->call_abi == ix86_abi
 		          ? SSE_REGPARM_MAX
-		          : (DEFAULT_ABI != SYSV_ABI ? X86_64_SSE_REGPARM_MAX
+		          : (ix86_abi != SYSV_ABI ? X86_64_SSE_REGPARM_MAX
 		          			     : X64_SSE_REGPARM_MAX))
  	       : cum->sse_regno)
 		    : -1);
@@ -5943,7 +6076,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,
   if (type && TREE_CODE (type) == VECTOR_TYPE)
     mode = type_natural_mode (type, cum);
 
-  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)
+  if (TARGET_64BIT && (cum ? cum->call_abi : ix86_abi) == MS_ABI)
     return function_arg_ms_64 (cum, mode, omode, named, bytes);
   else if (TARGET_64BIT)
     return function_arg_64 (cum, mode, omode, type, named);
@@ -5963,7 +6096,7 @@ ix86_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,
 			const_tree type, bool named ATTRIBUTE_UNUSED)
 {
   /* See Windows x64 Software Convention.  */
-  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)
+  if (TARGET_64BIT && (cum ? cum->call_abi : ix86_abi) == MS_ABI)
     {
       int msize = (int) GET_MODE_SIZE (mode);
       if (type)
@@ -6103,7 +6236,7 @@ ix86_function_value_regno_p (int regno)
       /* TODO: The function should depend on current function ABI but
        builtins.c would need updating then. Therefore we use the
        default ABI.  */
-      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)
+      if (TARGET_64BIT && ix86_abi == MS_ABI)
 	return false;
       return TARGET_FLOAT_RETURNS_IN_80387;
 
@@ -6499,13 +6632,13 @@ ix86_build_builtin_va_list_abi (enum calling_abi abi)
 static tree
 ix86_build_builtin_va_list (void)
 {
-  tree ret = ix86_build_builtin_va_list_abi (DEFAULT_ABI);
+  tree ret = ix86_build_builtin_va_list_abi (ix86_abi);
 
   /* Initialize abi specific va_list builtin types.  */
   if (TARGET_64BIT)
     {
       tree t;
-      if (DEFAULT_ABI == MS_ABI)
+      if (ix86_abi == MS_ABI)
         {
           t = ix86_build_builtin_va_list_abi (SYSV_ABI);
           if (TREE_CODE (t) != RECORD_TYPE)
@@ -6519,7 +6652,7 @@ ix86_build_builtin_va_list (void)
             t = build_variant_type_copy (t);
           sysv_va_list_type_node = t;
         }
-      if (DEFAULT_ABI != MS_ABI)
+      if (ix86_abi != MS_ABI)
         {
           t = ix86_build_builtin_va_list_abi (MS_ABI);
           if (TREE_CODE (t) != RECORD_TYPE)
@@ -6552,8 +6685,8 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)
   int i;
   int regparm = ix86_regparm;
 
-  if (cum->call_abi != DEFAULT_ABI)
-    regparm = DEFAULT_ABI != SYSV_ABI ? X86_64_REGPARM_MAX : X64_REGPARM_MAX;
+  if (cum->call_abi != ix86_abi)
+    regparm = ix86_abi != SYSV_ABI ? X86_64_REGPARM_MAX : X64_REGPARM_MAX;
 
   /* GPR size of varargs save area.  */
   if (cfun->va_list_gpr_size)
@@ -6710,7 +6843,7 @@ is_va_list_char_pointer (tree type)
     return true;
   canonic = ix86_canonical_va_list_type (type);
   return (canonic == ms_va_list_type_node
-          || (DEFAULT_ABI == MS_ABI && canonic == va_list_type_node));
+          || (ix86_abi == MS_ABI && canonic == va_list_type_node));
 }
 
 /* Implement va_start.  */
@@ -13034,6 +13167,316 @@ ix86_expand_unary_operator (enum rtx_code code, enum machine_mode mode,
     emit_move_insn (operands[0], dst);
 }
 
+#define LEA_SEARCH_THRESHOLD 12
+
+/* Search backward for non-agu definition of register number REGNO1
+   or register number REGNO2 in INSN's basic block until 
+   1. Pass LEA_SEARCH_THRESHOLD instructions, or
+   2. Reach BB boundary, or
+   3. Reach agu definition.
+   Returns the distance between the non-agu definition point and INSN.
+   If no definition point, returns -1.  */
+
+static int
+distance_non_agu_define (unsigned int regno1, unsigned int regno2,
+			 rtx insn)
+{
+  basic_block bb = BLOCK_FOR_INSN (insn);
+  int distance = 0;
+  df_ref *def_rec;
+  enum attr_type insn_type;
+
+  if (insn != BB_HEAD (bb))
+    {
+      rtx prev = PREV_INSN (insn);
+      while (prev && distance < LEA_SEARCH_THRESHOLD)
+	{
+	  if (INSN_P (prev))
+	    {
+	      distance++;
+              for (def_rec = DF_INSN_DEFS (prev); *def_rec; def_rec++)
+                if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF
+                    && !DF_REF_IS_ARTIFICIAL (*def_rec)
+                    && (regno1 == DF_REF_REGNO (*def_rec)
+			|| regno2 == DF_REF_REGNO (*def_rec)))
+		  {
+		    insn_type = get_attr_type (prev);
+		    if (insn_type != TYPE_LEA)
+		      goto done;
+		  }
+	    }
+	  if (prev == BB_HEAD (bb))
+	    break;
+	  prev = PREV_INSN (prev);
+	}
+    }
+  
+  if (distance < LEA_SEARCH_THRESHOLD)
+    {
+      edge e;
+      edge_iterator ei;
+      bool simple_loop = false;
+  
+      FOR_EACH_EDGE (e, ei, bb->preds)
+	if (e->src == bb)
+	  {
+	    simple_loop = true;
+	    break;
+	  }
+  
+      if (simple_loop)
+	{
+	  rtx prev = BB_END (bb);
+	  while (prev
+		 && prev != insn
+		 && distance < LEA_SEARCH_THRESHOLD)
+	    {
+	      if (INSN_P (prev))
+		{
+		  distance++;
+		  for (def_rec = DF_INSN_DEFS (prev); *def_rec; def_rec++)
+		    if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF
+			&& !DF_REF_IS_ARTIFICIAL (*def_rec)
+			&& (regno1 == DF_REF_REGNO (*def_rec)
+			    || regno2 == DF_REF_REGNO (*def_rec)))
+		      {
+			insn_type = get_attr_type (prev);
+			if (insn_type != TYPE_LEA)
+			  goto done;
+		      }
+		}
+	      prev = PREV_INSN (prev);
+	    }
+	}
+    }
+
+  distance = -1;
+
+done:
+  /* get_attr_type may modify recog data.  We want to make sure
+     that recog data is valid for instruction INSN, on which
+     distance_non_agu_define is called.  INSN is unchanged here.  */
+  extract_insn_cached (insn);
+  return distance;
+}
+
+/* Return the distance between INSN and the next insn that uses 
+   register number REGNO0 in memory address.  Return -1 if no such
+   a use is found within LEA_SEARCH_THRESHOLD or REGNO0 is set.  */
+
+static int
+distance_agu_use (unsigned int regno0, rtx insn)
+{
+  basic_block bb = BLOCK_FOR_INSN (insn);
+  int distance = 0;
+  df_ref *def_rec;
+  df_ref *use_rec;
+
+  if (insn != BB_END (bb))
+    {
+      rtx next = NEXT_INSN (insn);
+      while (next && distance < LEA_SEARCH_THRESHOLD)
+	{
+	  if (INSN_P (next))
+	    {
+	      distance++;
+
+	      for (use_rec = DF_INSN_USES (next); *use_rec; use_rec++)
+		if ((DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_LOAD
+		     || DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_STORE)
+		    && regno0 == DF_REF_REGNO (*use_rec))
+		  {
+		    /* Return DISTANCE if OP0 is used in memory
+		       address in NEXT.  */
+		    return distance;
+		  }
+
+	      for (def_rec = DF_INSN_DEFS (next); *def_rec; def_rec++)
+		if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF
+		    && !DF_REF_IS_ARTIFICIAL (*def_rec)
+		    && regno0 == DF_REF_REGNO (*def_rec))
+		  {
+		    /* Return -1 if OP0 is set in NEXT.  */
+		    return -1;
+		  }
+	    }
+	  if (next == BB_END (bb))
+	    break;
+	  next = NEXT_INSN (next);
+	}
+    }
+
+  if (distance < LEA_SEARCH_THRESHOLD)
+    {
+      edge e;
+      edge_iterator ei;
+      bool simple_loop = false;
+  
+      FOR_EACH_EDGE (e, ei, bb->succs)
+        if (e->dest == bb)
+	  {
+	    simple_loop = true;
+	    break;
+	  }
+  
+      if (simple_loop)
+	{
+	  rtx next = BB_HEAD (bb);
+	  while (next
+		 && next != insn
+		 && distance < LEA_SEARCH_THRESHOLD)
+	    {
+	      if (INSN_P (next))
+		{
+		  distance++;
+
+		  for (use_rec = DF_INSN_USES (next); *use_rec; use_rec++)
+		    if ((DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_LOAD
+			 || DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_STORE)
+			&& regno0 == DF_REF_REGNO (*use_rec))
+		      {
+			/* Return DISTANCE if OP0 is used in memory
+			   address in NEXT.  */
+			return distance;
+		      }
+
+		  for (def_rec = DF_INSN_DEFS (next); *def_rec; def_rec++)
+		    if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF
+			&& !DF_REF_IS_ARTIFICIAL (*def_rec)
+			&& regno0 == DF_REF_REGNO (*def_rec))
+		      {
+			/* Return -1 if OP0 is set in NEXT.  */
+			return -1;
+		      }
+
+		}
+	      next = NEXT_INSN (next);
+	    }
+	}
+    }  
+
+  return -1;
+}
+
+/* Define this macro to tune LEA priority vs ADD, it take effect when
+   there is a dilemma of choicing LEA or ADD
+   Negative value: ADD is more preferred than LEA
+   Zero: Netrual
+   Positive value: LEA is more preferred than ADD*/
+#define IX86_LEA_PRIORITY 2
+
+/* Return true if it is ok to optimize an ADD operation to LEA
+   operation to avoid flag register consumation.  For the processors
+   like ATOM, if the destination register of LEA holds an actual
+   address which will be used soon, LEA is better and otherwise ADD
+   is better.  */
+
+bool
+ix86_lea_for_add_ok (enum rtx_code code ATTRIBUTE_UNUSED,
+                     rtx insn, rtx operands[])
+{
+  unsigned int regno0 = true_regnum (operands[0]);
+  unsigned int regno1 = true_regnum (operands[1]);
+  unsigned int regno2;
+
+  if (!TARGET_OPT_AGU || optimize_function_for_size_p (cfun))
+    return regno0 != regno1;
+
+  regno2 = true_regnum (operands[2]);
+
+  /* If a = b + c, (a!=b && a!=c), must use lea form. */
+  if (regno0 != regno1 && regno0 != regno2)
+    return true;
+  else    
+    {
+      int dist_define, dist_use;
+      dist_define = distance_non_agu_define (regno1, regno2, insn);
+      if (dist_define <= 0)
+        return true;
+
+      /* If this insn has both backward non-agu dependence and forward
+         agu dependence, the one with short distance take effect. */
+      dist_use = distance_agu_use (regno0, insn);
+      if (dist_use <= 0
+	  || (dist_define + IX86_LEA_PRIORITY) < dist_use)
+        return false;
+
+      return true;
+    }
+}
+
+/* Return true if destination reg of SET_BODY is shift count of
+   USE_BODY.  */
+
+static bool
+ix86_dep_by_shift_count_body (const_rtx set_body, const_rtx use_body)
+{
+  rtx set_dest;
+  rtx shift_rtx;
+  int i;
+
+  /* Retrieve destination of SET_BODY.  */
+  switch (GET_CODE (set_body))
+    {
+    case SET:
+      set_dest = SET_DEST (set_body);
+      if (!set_dest || !REG_P (set_dest))
+	return false;
+      break;
+    case PARALLEL:
+      for (i = XVECLEN (set_body, 0) - 1; i >= 0; i--)
+	if (ix86_dep_by_shift_count_body (XVECEXP (set_body, 0, i),
+					  use_body))
+	  return true;
+    default:
+      return false;
+      break;
+    }
+
+  /* Retrieve shift count of USE_BODY.  */
+  switch (GET_CODE (use_body))
+    {
+    case SET:
+      shift_rtx = XEXP (use_body, 1);
+      break;
+    case PARALLEL:
+      for (i = XVECLEN (use_body, 0) - 1; i >= 0; i--)
+	if (ix86_dep_by_shift_count_body (set_body,
+					  XVECEXP (use_body, 0, i)))
+	  return true;
+    default:
+      return false;
+      break;
+    }
+
+  if (shift_rtx 
+      && (GET_CODE (shift_rtx) == ASHIFT
+	  || GET_CODE (shift_rtx) == LSHIFTRT
+	  || GET_CODE (shift_rtx) == ASHIFTRT
+	  || GET_CODE (shift_rtx) == ROTATE
+	  || GET_CODE (shift_rtx) == ROTATERT))
+    {
+      rtx shift_count = XEXP (shift_rtx, 1);
+
+      /* Return true if shift count is dest of SET_BODY.  */
+      if (REG_P (shift_count)
+	  && true_regnum (set_dest) == true_regnum (shift_count))
+	return true;
+    }
+
+  return false;
+}
+
+/* Return true if destination reg of SET_INSN is shift count of
+   USE_INSN.  */
+
+bool
+ix86_dep_by_shift_count (const_rtx set_insn, const_rtx use_insn)
+{
+  return ix86_dep_by_shift_count_body (PATTERN (set_insn),
+				       PATTERN (use_insn));
+}
+
 /* Return TRUE or FALSE depending on whether the unary operator meets the
    appropriate constraints.  */
 
@@ -18894,7 +19337,7 @@ ix86_init_machine_status (void)
   f = GGC_CNEW (struct machine_function);
   f->use_fast_prologue_epilogue_nregs = -1;
   f->tls_descriptor_call_expanded_p = 0;
-  f->call_abi = DEFAULT_ABI;
+  f->call_abi = ix86_abi;
 
   return f;
 }
@@ -19155,6 +19598,7 @@ ix86_issue_rate (void)
   switch (ix86_tune)
     {
     case PROCESSOR_PENTIUM:
+    case PROCESSOR_ATOM:
     case PROCESSOR_K6:
       return 2;
 
@@ -19221,41 +19665,21 @@ ix86_flags_dependent (rtx insn, rtx dep_insn, enum attr_type insn_type)
   return 1;
 }
 
-/* A subroutine of ix86_adjust_cost -- return true iff INSN has a memory
-   address with operands set by DEP_INSN.  */
+/* Return true iff USE_INSN has a memory address with operands set by
+   SET_INSN.  */
 
-static int
-ix86_agi_dependent (rtx insn, rtx dep_insn, enum attr_type insn_type)
+bool
+ix86_agi_dependent (rtx set_insn, rtx use_insn)
 {
-  rtx addr;
-
-  if (insn_type == TYPE_LEA
-      && TARGET_PENTIUM)
-    {
-      addr = PATTERN (insn);
-
-      if (GET_CODE (addr) == PARALLEL)
-	addr = XVECEXP (addr, 0, 0);
-
-      gcc_assert (GET_CODE (addr) == SET);
-
-      addr = SET_SRC (addr);
-    }
-  else
-    {
-      int i;
-      extract_insn_cached (insn);
-      for (i = recog_data.n_operands - 1; i >= 0; --i)
-	if (MEM_P (recog_data.operand[i]))
-	  {
-	    addr = XEXP (recog_data.operand[i], 0);
-	    goto found;
-	  }
-      return 0;
-    found:;
-    }
-
-  return modified_in_p (addr, dep_insn);
+  int i;
+  extract_insn_cached (use_insn);
+  for (i = recog_data.n_operands - 1; i >= 0; --i)
+    if (MEM_P (recog_data.operand[i]))
+      {
+	rtx addr = XEXP (recog_data.operand[i], 0);
+	return modified_in_p (addr, set_insn) != 0;
+      }
+  return false;
 }
 
 static int
@@ -19283,7 +19707,20 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)
     {
     case PROCESSOR_PENTIUM:
       /* Address Generation Interlock adds a cycle of latency.  */
-      if (ix86_agi_dependent (insn, dep_insn, insn_type))
+      if (insn_type == TYPE_LEA)
+	{
+	  rtx addr = PATTERN (insn);
+
+	  if (GET_CODE (addr) == PARALLEL)
+	    addr = XVECEXP (addr, 0, 0);
+
+	  gcc_assert (GET_CODE (addr) == SET);
+
+	  addr = SET_SRC (addr);
+	  if (modified_in_p (addr, dep_insn))
+	    cost += 1;
+	}
+      else if (ix86_agi_dependent (dep_insn, insn))
 	cost += 1;
 
       /* ??? Compares pair with jump/setcc.  */
@@ -19293,7 +19730,7 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)
       /* Floating point stores require value to be ready one cycle earlier.  */
       if (insn_type == TYPE_FMOV
 	  && get_attr_memory (insn) == MEMORY_STORE
-	  && !ix86_agi_dependent (insn, dep_insn, insn_type))
+	  && !ix86_agi_dependent (dep_insn, insn))
 	cost += 1;
       break;
 
@@ -19316,7 +19753,7 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)
 	 in parallel with previous instruction in case
 	 previous instruction is not needed to compute the address.  */
       if ((memory == MEMORY_LOAD || memory == MEMORY_BOTH)
-	  && !ix86_agi_dependent (insn, dep_insn, insn_type))
+	  && !ix86_agi_dependent (dep_insn, insn))
 	{
 	  /* Claim moves to take one cycle, as core can issue one load
 	     at time and the next load can start cycle later.  */
@@ -19345,7 +19782,7 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)
 	 in parallel with previous instruction in case
 	 previous instruction is not needed to compute the address.  */
       if ((memory == MEMORY_LOAD || memory == MEMORY_BOTH)
-	  && !ix86_agi_dependent (insn, dep_insn, insn_type))
+	  && !ix86_agi_dependent (dep_insn, insn))
 	{
 	  /* Claim moves to take one cycle, as core can issue one load
 	     at time and the next load can start cycle later.  */
@@ -19362,6 +19799,7 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)
     case PROCESSOR_ATHLON:
     case PROCESSOR_K8:
     case PROCESSOR_AMDFAM10:
+    case PROCESSOR_ATOM:
     case PROCESSOR_GENERIC32:
     case PROCESSOR_GENERIC64:
       memory = get_attr_memory (insn);
@@ -19370,7 +19808,7 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)
 	 in parallel with previous instruction in case
 	 previous instruction is not needed to compute the address.  */
       if ((memory == MEMORY_LOAD || memory == MEMORY_BOTH)
-	  && !ix86_agi_dependent (insn, dep_insn, insn_type))
+	  && !ix86_agi_dependent (dep_insn, insn))
 	{
 	  enum attr_unit unit = get_attr_unit (insn);
 	  int loadcost = 3;
@@ -29691,14 +30129,11 @@ x86_builtin_vectorization_cost (bool runtime_test)
 tree
 ix86_fn_abi_va_list (tree fndecl)
 {
-  int abi;
-
   if (!TARGET_64BIT)
     return va_list_type_node;
   gcc_assert (fndecl != NULL_TREE);
-  abi = ix86_function_abi ((const_tree) fndecl);
 
-  if (abi == MS_ABI)
+  if (ix86_function_abi ((const_tree) fndecl) == MS_ABI)
     return ms_va_list_type_node;
   else
     return sysv_va_list_type_node;
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index 9055c25c4..14ba9bdae 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -59,6 +59,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define TARGET_ABM	OPTION_ISA_ABM
 #define TARGET_POPCNT	OPTION_ISA_POPCNT
 #define TARGET_SAHF	OPTION_ISA_SAHF
+#define TARGET_MOVBE	OPTION_ISA_MOVBE
 #define TARGET_AES	OPTION_ISA_AES
 #define TARGET_PCLMUL	OPTION_ISA_PCLMUL
 #define TARGET_CMPXCHG16B OPTION_ISA_CX16
@@ -236,6 +237,7 @@ extern const struct processor_costs ix86_size_cost;
 #define TARGET_GENERIC64 (ix86_tune == PROCESSOR_GENERIC64)
 #define TARGET_GENERIC (TARGET_GENERIC32 || TARGET_GENERIC64)
 #define TARGET_AMDFAM10 (ix86_tune == PROCESSOR_AMDFAM10)
+#define TARGET_ATOM (ix86_tune == PROCESSOR_ATOM)
 
 /* Feature tests against the various tunings.  */
 enum ix86_tune_indices {
@@ -300,6 +302,7 @@ enum ix86_tune_indices {
   X86_TUNE_USE_VECTOR_FP_CONVERTS,
   X86_TUNE_USE_VECTOR_CONVERTS,
   X86_TUNE_FUSE_CMP_AND_BRANCH,
+  X86_TUNE_OPT_AGU,
 
   X86_TUNE_LAST
 };
@@ -387,6 +390,7 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];
 	ix86_tune_features[X86_TUNE_USE_VECTOR_CONVERTS]
 #define TARGET_FUSE_CMP_AND_BRANCH \
 	ix86_tune_features[X86_TUNE_FUSE_CMP_AND_BRANCH]
+#define TARGET_OPT_AGU ix86_tune_features[X86_TUNE_OPT_AGU]
 
 /* Feature tests against the various architecture variations.  */
 enum ix86_arch_indices {
@@ -470,7 +474,10 @@ enum calling_abi
   MS_ABI = 1
 };
 
-/* The default abi form used by target.  */
+/* The abi used by target.  */
+extern enum calling_abi ix86_abi;
+
+/* The default abi used by target.  */
 #define DEFAULT_ABI SYSV_ABI
 
 /* Subtargets may reset this to 1 in order to enable 96-bit long double
@@ -569,6 +576,7 @@ enum target_cpu_default
   TARGET_CPU_DEFAULT_prescott,
   TARGET_CPU_DEFAULT_nocona,
   TARGET_CPU_DEFAULT_core2,
+  TARGET_CPU_DEFAULT_atom,
 
   TARGET_CPU_DEFAULT_geode,
   TARGET_CPU_DEFAULT_k6,
@@ -658,7 +666,7 @@ enum target_cpu_default
 
 /* Boundary (in *bits*) on which stack pointer should be aligned.  */
 #define STACK_BOUNDARY \
- (TARGET_64BIT && DEFAULT_ABI == MS_ABI ? 128 : BITS_PER_WORD)
+ (TARGET_64BIT && ix86_abi == MS_ABI ? 128 : BITS_PER_WORD)
 
 /* Stack boundary of the main function guaranteed by OS.  */
 #define MAIN_STACK_BOUNDARY (TARGET_64BIT ? 128 : 32)
@@ -1584,7 +1592,7 @@ typedef struct ix86_args {
   int maybe_vaarg;		/* true for calls to possibly vardic fncts.  */
   int float_in_sse;		/* 1 if in 32-bit mode SFmode (2 for DFmode) should
 				   be passed in SSE registers.  Otherwise 0.  */
-  int call_abi;			/* Set to SYSV_ABI for sysv abi. Otherwise
+  enum calling_abi call_abi;	/* Set to SYSV_ABI for sysv abi. Otherwise
  				   MS_ABI for ms abi.  */
 } CUMULATIVE_ARGS;
 
@@ -2230,6 +2238,7 @@ enum processor_type
   PROCESSOR_GENERIC32,
   PROCESSOR_GENERIC64,
   PROCESSOR_AMDFAM10,
+  PROCESSOR_ATOM,
   PROCESSOR_max
 };
 
@@ -2403,7 +2412,7 @@ struct machine_function GTY(())
   int tls_descriptor_call_expanded_p;
   /* This value is used for amd64 targets and specifies the current abi
      to be used. MS_ABI means ms abi. Otherwise SYSV_ABI means sysv abi.  */
-  int call_abi;
+   enum calling_abi call_abi;
 };
 
 #define ix86_stack_locals (cfun->machine->stack_locals)
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 1de7b3a3a..574f69a6e 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -318,7 +318,7 @@
 
 
 ;; Processor type.
-(define_attr "cpu" "none,pentium,pentiumpro,geode,k6,athlon,k8,core2,
+(define_attr "cpu" "none,pentium,pentiumpro,geode,k6,athlon,k8,core2,atom,
 		    generic64,amdfam10"
   (const (symbol_ref "ix86_schedule")))
 
@@ -614,6 +614,12 @@
 (define_attr "i387_cw" "trunc,floor,ceil,mask_pm,uninitialized,any"
   (const_string "any"))
 
+;; Define attribute to classify add/sub insns that consumes carry flag (CF)
+(define_attr "use_carry" "0,1" (const_string "0"))
+
+;; Define attribute to indicate unaligned ssemov insns
+(define_attr "movu" "0,1" (const_string "0"))
+
 ;; Describe a user's asm statement.
 (define_asm_attributes
   [(set_attr "length" "128")
@@ -729,6 +735,7 @@
 (include "k6.md")
 (include "athlon.md")
 (include "geode.md")
+(include "atom.md")
 
 
 ;; Operand and operator predicates and constraints
@@ -5807,6 +5814,7 @@
   "TARGET_64BIT && ix86_binary_operator_ok (PLUS, DImode, operands)"
   "adc{q}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "DI")])
 
@@ -5881,6 +5889,7 @@
   "ix86_binary_operator_ok (PLUS, QImode, operands)"
   "adc{b}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "QI")])
 
@@ -5893,6 +5902,7 @@
   "ix86_binary_operator_ok (PLUS, HImode, operands)"
   "adc{w}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "HI")])
 
@@ -5905,6 +5915,7 @@
   "ix86_binary_operator_ok (PLUS, SImode, operands)"
   "adc{l}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
@@ -5918,6 +5929,7 @@
   "TARGET_64BIT && ix86_binary_operator_ok (PLUS, SImode, operands)"
   "adc{l}\t{%2, %k0|%k0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
@@ -6147,9 +6159,9 @@
    (set_attr "mode" "SI")])
 
 (define_insn "*adddi_1_rex64"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=r,rm,r")
-	(plus:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0,r")
-		 (match_operand:DI 2 "x86_64_general_operand" "rme,re,le")))
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=r,rm,r,r")
+	(plus:DI (match_operand:DI 1 "nonimmediate_operand" "%0,0,r,r")
+		 (match_operand:DI 2 "x86_64_general_operand" "rme,re,0,le")))
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT && ix86_binary_operator_ok (PLUS, DImode, operands)"
 {
@@ -6170,6 +6182,10 @@
 	}
 
     default:
+      /* Use add as much as possible to replace lea for AGU optimization. */
+      if (which_alternative == 2 && TARGET_OPT_AGU)
+        return "add{q}\t{%1, %0|%0, %1}";
+        
       gcc_assert (rtx_equal_p (operands[0], operands[1]));
 
       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.
@@ -6188,8 +6204,11 @@
     }
 }
   [(set (attr "type")
-     (cond [(eq_attr "alternative" "2")
+     (cond [(and (eq_attr "alternative" "2") 
+                 (eq (symbol_ref "TARGET_OPT_AGU") (const_int 0)))
 	      (const_string "lea")
+            (eq_attr "alternative" "3")
+              (const_string "lea")
 	    ; Current assemblers are broken and do not allow @GOTOFF in
 	    ; ought but a memory context.
 	    (match_operand:DI 2 "pic_symbolic_operand" "")
@@ -6206,8 +6225,8 @@
 	(plus:DI (match_operand:DI 1 "register_operand" "")
 		 (match_operand:DI 2 "x86_64_nonmemory_operand" "")))
    (clobber (reg:CC FLAGS_REG))]
-  "TARGET_64BIT && reload_completed
-   && true_regnum (operands[0]) != true_regnum (operands[1])"
+  "TARGET_64BIT && reload_completed 
+   && ix86_lea_for_add_ok (PLUS, insn, operands)"
   [(set (match_dup 0)
 	(plus:DI (match_dup 1)
 		 (match_dup 2)))]
@@ -6411,9 +6430,9 @@
 
 
 (define_insn "*addsi_1"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,rm,r")
-	(plus:SI (match_operand:SI 1 "nonimmediate_operand" "%0,0,r")
-		 (match_operand:SI 2 "general_operand" "g,ri,li")))
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,rm,r,r")
+	(plus:SI (match_operand:SI 1 "nonimmediate_operand" "%0,0,r,r")
+		 (match_operand:SI 2 "general_operand" "g,ri,0,li")))
    (clobber (reg:CC FLAGS_REG))]
   "ix86_binary_operator_ok (PLUS, SImode, operands)"
 {
@@ -6434,6 +6453,10 @@
 	}
 
     default:
+      /* Use add as much as possible to replace lea for AGU optimization. */
+      if (which_alternative == 2 && TARGET_OPT_AGU)
+        return "add{l}\t{%1, %0|%0, %1}";
+
       gcc_assert (rtx_equal_p (operands[0], operands[1]));
 
       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.
@@ -6450,7 +6473,10 @@
     }
 }
   [(set (attr "type")
-     (cond [(eq_attr "alternative" "2")
+     (cond [(and (eq_attr "alternative" "2") 
+                 (eq (symbol_ref "TARGET_OPT_AGU") (const_int 0)))
+               (const_string "lea")
+            (eq_attr "alternative" "3")
 	      (const_string "lea")
 	    ; Current assemblers are broken and do not allow @GOTOFF in
 	    ; ought but a memory context.
@@ -6468,8 +6494,7 @@
 	(plus (match_operand 1 "register_operand" "")
               (match_operand 2 "nonmemory_operand" "")))
    (clobber (reg:CC FLAGS_REG))]
-  "reload_completed
-   && true_regnum (operands[0]) != true_regnum (operands[1])"
+  "reload_completed && ix86_lea_for_add_ok (PLUS, insn, operands)" 
   [(const_int 0)]
 {
   rtx pat;
@@ -7570,6 +7595,7 @@
   "TARGET_64BIT && ix86_binary_operator_ok (MINUS, DImode, operands)"
   "sbb{q}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "DI")])
 
@@ -7618,6 +7644,7 @@
   "ix86_binary_operator_ok (MINUS, QImode, operands)"
   "sbb{b}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "QI")])
 
@@ -7630,6 +7657,7 @@
   "ix86_binary_operator_ok (MINUS, HImode, operands)"
   "sbb{w}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "HI")])
 
@@ -7642,6 +7670,7 @@
   "ix86_binary_operator_ok (MINUS, SImode, operands)"
   "sbb{l}\t{%2, %0|%0, %2}"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
@@ -15180,7 +15209,7 @@
 		     ? gen_rtx_REG (XCmode, FIRST_FLOAT_REG) : NULL),
 		    operands[0], const0_rtx,
 		    GEN_INT ((TARGET_64BIT
-			      ? (DEFAULT_ABI == SYSV_ABI
+			      ? (ix86_abi == SYSV_ABI
 				 ? X86_64_SSE_REGPARM_MAX
 				 : X64_SSE_REGPARM_MAX)
 			      : X86_32_SSE_REGPARM_MAX)
@@ -15260,6 +15289,7 @@
   "reload_completed"
   "ret"
   [(set_attr "length" "1")
+   (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
    (set_attr "modrm" "0")])
 
@@ -15272,6 +15302,7 @@
   "reload_completed"
   "rep\;ret"
   [(set_attr "length" "1")
+   (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
    (set_attr "prefix_rep" "1")
    (set_attr "modrm" "0")])
@@ -15282,6 +15313,7 @@
   "reload_completed"
   "ret\t%0"
   [(set_attr "length" "3")
+   (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "2")
    (set_attr "modrm" "0")])
 
@@ -15635,7 +15667,7 @@
 	(bswap:SI (match_operand:SI 1 "register_operand" "")))]
   ""
 {
-  if (!TARGET_BSWAP)
+  if (!(TARGET_BSWAP || TARGET_MOVBE))
     {
       rtx x = operands[0];
 
@@ -15647,6 +15679,21 @@
     }
 })
 
+(define_insn "*bswapsi_movbe"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,m")
+	(bswap:SI (match_operand:SI 1 "nonimmediate_operand" "0,m,r")))]
+  "TARGET_MOVBE && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
+  "@
+    bswap\t%0
+    movbe\t{%1, %0|%0, %1}
+    movbe\t{%1, %0|%0, %1}"
+  [(set_attr "type" "*,imov,imov")
+   (set_attr "modrm" "*,1,1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "prefix_extra" "*,1,1")
+   (set_attr "length" "2,*,*")
+   (set_attr "mode" "SI")])
+
 (define_insn "*bswapsi_1"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(bswap:SI (match_operand:SI 1 "register_operand" "0")))]
@@ -15675,7 +15722,29 @@
   [(set_attr "length" "4")
    (set_attr "mode" "HI")])
 
-(define_insn "bswapdi2"
+(define_expand "bswapdi2"
+  [(set (match_operand:DI 0 "register_operand" "")
+	(bswap:DI (match_operand:DI 1 "register_operand" "")))]
+  "TARGET_64BIT"
+  "")
+
+(define_insn "*bswapdi_movbe"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=r,r,m")
+	(bswap:DI (match_operand:DI 1 "nonimmediate_operand" "0,m,r")))]
+  "TARGET_64BIT && TARGET_MOVBE
+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
+  "@
+    bswap\t%0
+    movbe\t{%1, %0|%0, %1}
+    movbe\t{%1, %0|%0, %1}"
+  [(set_attr "type" "*,imov,imov")
+   (set_attr "modrm" "*,1,1")
+   (set_attr "prefix_0f" "1")
+   (set_attr "prefix_extra" "*,1,1")
+   (set_attr "length" "3,*,*")
+   (set_attr "mode" "DI")])
+
+(define_insn "*bswapdi_1"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(bswap:DI (match_operand:DI 1 "register_operand" "0")))]
   "TARGET_64BIT"
@@ -16381,6 +16450,7 @@
   "TARGET_SSE_MATH"
   "%vrcpss\t{%1, %d0|%d0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "rcp")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "SF")])
 
@@ -16732,6 +16802,7 @@
   "TARGET_SSE_MATH"
   "%vrsqrtss\t{%1, %d0|%d0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "rcp")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "SF")])
 
@@ -16752,6 +16823,7 @@
   "SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH"
   "%vsqrts<ssemodefsuffix>\t{%1, %d0|%d0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "sqrt")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "<MODE>")
    (set_attr "athlon_decode" "*")
@@ -19837,6 +19909,7 @@
   ; Since we don't have the proper number of operands for an alu insn,
   ; fill in all the blanks.
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "memory" "none")
    (set_attr "imm_disp" "false")
@@ -19852,6 +19925,7 @@
   ""
   "sbb{q}\t%0, %0"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "memory" "none")
    (set_attr "imm_disp" "false")
@@ -19895,6 +19969,7 @@
   ; Since we don't have the proper number of operands for an alu insn,
   ; fill in all the blanks.
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "memory" "none")
    (set_attr "imm_disp" "false")
@@ -19910,6 +19985,7 @@
   ""
   "sbb{l}\t%0, %0"
   [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
    (set_attr "pent_pair" "pu")
    (set_attr "memory" "none")
    (set_attr "imm_disp" "false")
@@ -20242,7 +20318,8 @@
     }
 }
   [(set (attr "type")
-	(cond [(eq_attr "alternative" "0")
+	(cond [(and (eq_attr "alternative" "0") 
+	            (eq (symbol_ref "TARGET_OPT_AGU") (const_int 0)))
 		 (const_string "alu")
 	       (match_operand:SI 2 "const0_operand" "")
 		 (const_string "imov")
@@ -20285,7 +20362,8 @@
     }
 }
   [(set (attr "type")
-	(cond [(eq_attr "alternative" "0")
+	(cond [(and (eq_attr "alternative" "0")
+	            (eq (symbol_ref "TARGET_OPT_AGU") (const_int 0)))
 		 (const_string "alu")
 	       (match_operand:DI 2 "const0_operand" "")
 		 (const_string "imov")
@@ -21773,6 +21851,7 @@
   return patterns[locality];
 }
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "prefetch")
    (set_attr "memory" "none")])
 
 (define_insn "*prefetch_sse_rex"
@@ -21791,6 +21870,7 @@
   return patterns[locality];
 }
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "prefetch")
    (set_attr "memory" "none")])
 
 (define_insn "*prefetch_3dnow"
diff --git a/gcc/config/i386/i386.opt b/gcc/config/i386/i386.opt
index 853059081..e9be268e0 100644
--- a/gcc/config/i386/i386.opt
+++ b/gcc/config/i386/i386.opt
@@ -228,6 +228,10 @@ mtune=
 Target RejectNegative Joined Var(ix86_tune_string)
 Schedule code for given CPU
 
+mabi=
+Target RejectNegative Joined Var(ix86_abi_string)
+Generate code that conforms to the given ABI
+
 mveclibabi=
 Target RejectNegative Joined Var(ix86_veclibabi_string)
 Vector library ABI to use
@@ -335,6 +339,10 @@ msahf
 Target Report Mask(ISA_SAHF) Var(ix86_isa_flags) VarExists Save
 Support code generation of sahf instruction in 64bit x86-64 code.
 
+mmovbe
+Target Report Mask(ISA_MOVBE) Var(ix86_isa_flags) VarExists Save
+Support code generation of movbe instruction.
+
 maes
 Target Report Mask(ISA_AES) Var(ix86_isa_flags) VarExists Save
 Support AES built-in functions and code generation
diff --git a/gcc/config/i386/mingw32.h b/gcc/config/i386/mingw32.h
index f3fbe8c58..746d7d105 100644
--- a/gcc/config/i386/mingw32.h
+++ b/gcc/config/i386/mingw32.h
@@ -38,7 +38,7 @@ along with GCC; see the file COPYING3.  If not see
       builtin_define_std ("WINNT");				\
       builtin_define_with_int_value ("_INTEGRAL_MAX_BITS",	\
 				     TYPE_PRECISION (intmax_type_node));\
-      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)			\
+      if (TARGET_64BIT && ix86_abi == MS_ABI)			\
 	{							\
 	  builtin_define ("__MINGW64__");			\
 	  builtin_define_std ("WIN64");				\
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index afe2b700a..6a98375cc 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -342,6 +342,7 @@
    && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "vmovup<avxmodesuffixf2c>\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "movu" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<MODE>")])
 
@@ -367,6 +368,7 @@
    && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "movup<ssemodesuffixf2c>\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "movu" "1")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "avx_movdqu<avxmodesuffix>"
@@ -377,6 +379,7 @@
   "TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "vmovdqu\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "movu" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<avxvecmode>")])
 
@@ -387,6 +390,7 @@
   "TARGET_SSE2 && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
   "movdqu\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssemov")
+   (set_attr "movu" "1")
    (set_attr "prefix_data16" "1")
    (set_attr "mode" "TI")])
 
@@ -428,7 +432,7 @@
 		     UNSPEC_MOVNT))]
   "TARGET_SSE2"
   "movntdq\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix_data16" "1")
    (set_attr "mode" "TI")])
 
@@ -438,7 +442,7 @@
 		   UNSPEC_MOVNT))]
   "TARGET_SSE2"
   "movnti\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "mode" "V2DF")])
 
 (define_insn "avx_lddqu<avxmodesuffix>"
@@ -449,6 +453,7 @@
   "TARGET_AVX"
   "vlddqu\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
+   (set_attr "movu" "1")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<avxvecmode>")])
 
@@ -458,7 +463,8 @@
 		      UNSPEC_LDDQU))]
   "TARGET_SSE3"
   "lddqu\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
+   (set_attr "movu" "1")
    (set_attr "prefix_rep" "1")
    (set_attr "mode" "TI")])
 
@@ -765,6 +771,7 @@
   "TARGET_SSE"
   "%vrcpps\t{%1, %0|%0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "rcp")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "V4SF")])
 
@@ -791,6 +798,7 @@
   "TARGET_SSE"
   "rcpss\t{%1, %0|%0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "rcp")
    (set_attr "mode" "SF")])
 
 (define_expand "sqrtv8sf2"
@@ -836,6 +844,7 @@
   "TARGET_SSE"
   "%vsqrtps\t{%1, %0|%0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "sqrt")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "V4SF")])
 
@@ -880,6 +889,7 @@
   "SSE_VEC_FLOAT_MODE_P (<MODE>mode)"
   "sqrts<ssemodesuffixf2c>\t{%1, %0|%0, %1}"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "sqrt")
    (set_attr "mode" "<ssescalarmode>")])
 
 (define_expand "rsqrtv8sf2"
@@ -1043,7 +1053,7 @@
 	 (const_int 1)))]
   "SSE_VEC_FLOAT_MODE_P (<MODE>mode)"
   "<maxminfprefix>s<ssemodesuffixf2c>\t{%2, %0|%0, %2}"
-  [(set_attr "type" "sse")
+  [(set_attr "type" "sseadd")
    (set_attr "mode" "<ssescalarmode>")])
 
 ;; These versions of the min/max patterns implement exactly the operations
@@ -1179,6 +1189,7 @@
   "TARGET_SSE3"
   "addsubpd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "mode" "V2DF")])
 
 (define_insn "avx_h<plusminus_insn>v4df3"
@@ -1302,6 +1313,7 @@
   "TARGET_SSE3"
   "h<plusminus_mnemonic>ps\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_rep" "1")
    (set_attr "mode" "V4SF")])
 
@@ -5086,6 +5098,7 @@
   "TARGET_SSE2 && ix86_binary_operator_ok (MULT, V8HImode, operands)"
   "pmaddwd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "simul")
    (set_attr "prefix_data16" "1")
    (set_attr "mode" "TI")])
 
@@ -7052,6 +7065,7 @@
    movq\t{%H1, %0|%0, %H1}
    mov{q}\t{%H1, %0|%0, %H1}"
   [(set_attr "type" "ssemov,sseishft,ssemov,imov")
+   (set_attr "atom_unit" "*,sishuf,*,*")
    (set_attr "memory" "*,none,*,*")
    (set_attr "mode" "V2SF,TI,TI,DI")])
 
@@ -7084,6 +7098,7 @@
    psrldq\t{$8, %0|%0, 8}
    movq\t{%H1, %0|%0, %H1}"
   [(set_attr "type" "ssemov,sseishft,ssemov")
+   (set_attr "atom_unit" "*,sishuf,*")
    (set_attr "memory" "*,none,*")
    (set_attr "mode" "V2SF,TI,TI")])
 
@@ -7641,6 +7656,7 @@
   "TARGET_SSE2"
   "psadbw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "simul")
    (set_attr "prefix_data16" "1")
    (set_attr "mode" "TI")])
 
@@ -7662,7 +7678,7 @@
 	  UNSPEC_MOVMSK))]
   "SSE_VEC_FLOAT_MODE_P (<MODE>mode)"
   "%vmovmskp<ssemodesuffixf2c>\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "<MODE>")])
 
@@ -7672,7 +7688,7 @@
 		   UNSPEC_MOVMSK))]
   "TARGET_SSE2"
   "%vpmovmskb\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "SI")])
@@ -7695,7 +7711,7 @@
   "TARGET_SSE2 && !TARGET_64BIT"
   ;; @@@ check ordering of operands in intel/nonintel syntax
   "%vmaskmovdqu\t{%2, %1|%1, %2}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
@@ -7709,7 +7725,7 @@
   "TARGET_SSE2 && TARGET_64BIT"
   ;; @@@ check ordering of operands in intel/nonintel syntax
   "%vmaskmovdqu\t{%2, %1|%1, %2}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
@@ -7720,6 +7736,7 @@
   "TARGET_SSE"
   "%vldmxcsr\t%0"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "mxcsr")
    (set_attr "prefix" "maybe_vex")
    (set_attr "memory" "load")])
 
@@ -7729,6 +7746,7 @@
   "TARGET_SSE"
   "%vstmxcsr\t%0"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "mxcsr")
    (set_attr "prefix" "maybe_vex")
    (set_attr "memory" "store")])
 
@@ -7747,6 +7765,7 @@
   "TARGET_SSE || TARGET_3DNOW_A"
   "sfence"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "fence")
    (set_attr "memory" "unknown")])
 
 (define_insn "sse2_clflush"
@@ -7755,6 +7774,7 @@
   "TARGET_SSE2"
   "clflush\t%a0"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "fence")
    (set_attr "memory" "unknown")])
 
 (define_expand "sse2_mfence"
@@ -7772,6 +7792,7 @@
   "TARGET_64BIT || TARGET_SSE2"
   "mfence"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "fence")
    (set_attr "memory" "unknown")])
 
 (define_expand "sse2_lfence"
@@ -7789,6 +7810,7 @@
   "TARGET_SSE2"
   "lfence"
   [(set_attr "type" "sse")
+   (set_attr "atom_sse_attr" "lfence")
    (set_attr "memory" "unknown")])
 
 (define_insn "sse3_mwait"
@@ -7912,6 +7934,7 @@
   "TARGET_SSSE3"
   "phaddw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -7940,6 +7963,7 @@
   "TARGET_SSSE3"
   "phaddw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -7994,6 +8018,7 @@
   "TARGET_SSSE3"
   "phaddd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8014,6 +8039,7 @@
   "TARGET_SSSE3"
   "phaddd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8100,6 +8126,7 @@
   "TARGET_SSSE3"
   "phaddsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8128,6 +8155,7 @@
   "TARGET_SSSE3"
   "phaddsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8214,6 +8242,7 @@
   "TARGET_SSSE3"
   "phsubw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8242,6 +8271,7 @@
   "TARGET_SSSE3"
   "phsubw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8296,6 +8326,7 @@
   "TARGET_SSSE3"
   "phsubd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8316,6 +8347,7 @@
   "TARGET_SSSE3"
   "phsubd\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8402,6 +8434,7 @@
   "TARGET_SSSE3"
   "phsubsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8430,6 +8463,7 @@
   "TARGET_SSSE3"
   "phsubsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "complex")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8536,6 +8570,7 @@
   "TARGET_SSSE3"
   "pmaddubsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "simul")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8574,6 +8609,7 @@
   "TARGET_SSSE3"
   "pmaddubsw\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseiadd")
+   (set_attr "atom_unit" "simul")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8781,6 +8817,7 @@
   return "palignr\t{%3, %2, %0|%0, %2, %3}";
 }
   [(set_attr "type" "sseishft")
+   (set_attr "atom_unit" "sishuf")
    (set_attr "prefix_data16" "1")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "TI")])
@@ -8797,6 +8834,7 @@
   return "palignr\t{%3, %2, %0|%0, %2, %3}";
 }
   [(set_attr "type" "sseishft")
+   (set_attr "atom_unit" "sishuf")
    (set_attr "prefix_extra" "1")
    (set_attr "mode" "DI")])
 
@@ -8983,7 +9021,7 @@
 		     UNSPEC_MOVNTDQA))]
   "TARGET_SSE4_1"
   "%vmovntdqa\t{%1, %0|%0, %1}"
-  [(set_attr "type" "ssecvt")
+  [(set_attr "type" "ssemov")
    (set_attr "prefix_extra" "1")
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "TI")])
diff --git a/gcc/config/i386/t-cs-linux b/gcc/config/i386/t-cs-linux
new file mode 100644
index 000000000..5b5b46f45
--- /dev/null
+++ b/gcc/config/i386/t-cs-linux
@@ -0,0 +1,25 @@
+# Sourcery G++ IA32 GNU/Linux Configuration.
+# Copyright (C) 2007
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = m64/m32 msgxx-glibc/mrh73/mrhel3
+MULTILIB_DIRNAMES = 64 32 sgxx-glibc rh73 rhel3
+MULTILIB_OSDIRNAMES = ../lib64 ../lib sgxx-glibc rh73 rhel3
+MULTILIB_EXCEPTIONS = m64/mrh73 m64/mrhel3
+
diff --git a/gcc/config/i386/t-cs-linux-lite b/gcc/config/i386/t-cs-linux-lite
new file mode 100644
index 000000000..2f73ee6e9
--- /dev/null
+++ b/gcc/config/i386/t-cs-linux-lite
@@ -0,0 +1,26 @@
+# Sourcery G++ Lite IA32 GNU/Linux Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = m64 march=atom/march=core2
+MULTILIB_DIRNAMES = 64 atom core2
+MULTILIB_EXCEPTIONS = m64/march=atom march=core2
+MULTILIB_ALIASES = m64=m64/march?atom
+MULTILIB_OSDIRNAMES = m64=../lib64 march.atom=atom m64/march.core2=../lib64/core2
+
diff --git a/gcc/config/i386/t-wrs-linux b/gcc/config/i386/t-wrs-linux
new file mode 100644
index 000000000..19958bff5
--- /dev/null
+++ b/gcc/config/i386/t-wrs-linux
@@ -0,0 +1,24 @@
+# Wind River GNU/Linux Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS = m64/m32 msystem-glibc
+MULTILIB_DIRNAMES = 64 32 system-glibc
+MULTILIB_OSDIRNAMES = ../lib64 ../lib system-glibc
+MULTILIB_EXCEPTIONS = m64/msystem-glibc
diff --git a/gcc/config/i386/winnt.c b/gcc/config/i386/winnt.c
index ae9196c59..c9f9f9a9b 100644
--- a/gcc/config/i386/winnt.c
+++ b/gcc/config/i386/winnt.c
@@ -499,8 +499,11 @@ i386_pe_asm_output_aligned_decl_common (FILE *stream, tree decl,
 {
   HOST_WIDE_INT rounded;
 
-  /* Compute as in assemble_noswitch_variable, since we don't actually
-     support aligned common.  */
+  /* Compute as in assemble_noswitch_variable, since we don't have
+     support for aligned common on older binutils.  We must also
+     avoid emitting a common symbol of size zero, as this is the
+     overloaded representation that indicates an undefined external
+     symbol in the PE object file format.  */
   rounded = size ? size : 1;
   rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;
   rounded = (rounded / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)
@@ -510,9 +513,13 @@ i386_pe_asm_output_aligned_decl_common (FILE *stream, tree decl,
 
   fprintf (stream, "\t.comm\t");
   assemble_name (stream, name);
-  fprintf (stream, ", " HOST_WIDE_INT_PRINT_DEC "\t" ASM_COMMENT_START
-	   " " HOST_WIDE_INT_PRINT_DEC "\n",
-	   rounded, size);
+  if (use_pe_aligned_common)
+    fprintf (stream, ", " HOST_WIDE_INT_PRINT_DEC ", %d\n",
+	   size ? size : (HOST_WIDE_INT) 1,
+	   exact_log2 (align) - exact_log2 (CHAR_BIT));
+  else
+    fprintf (stream, ", " HOST_WIDE_INT_PRINT_DEC "\t" ASM_COMMENT_START
+	   " " HOST_WIDE_INT_PRINT_DEC "\n", rounded, size);
 }
 
 /* The Microsoft linker requires that every function be marked as
diff --git a/gcc/config/i386/wrs-linux.h b/gcc/config/i386/wrs-linux.h
new file mode 100644
index 000000000..b9806c099
--- /dev/null
+++ b/gcc/config/i386/wrs-linux.h
@@ -0,0 +1,33 @@
+/* Wind River IA32 GNU/Linux Configuration.
+   Copyright (C) 2009
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{msystem-glibc:/system-glibc}"
+
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC SYSROOT_SUFFIX_SPEC
+
+/* See mips/wrs-linux.h for details on this use of
+   STARTFILE_PREFIX_SPEC.  */
+#undef STARTFILE_PREFIX_SPEC
+#define STARTFILE_PREFIX_SPEC				\
+  "%{m64: /usr/local/lib64/ /lib64/ /usr/lib64/}	\
+   %{!m64: /usr/local/lib/ /lib/ /usr/lib/}"
diff --git a/gcc/config/i386/wrs-linux.opt b/gcc/config/i386/wrs-linux.opt
new file mode 100644
index 000000000..cc8609258
--- /dev/null
+++ b/gcc/config/i386/wrs-linux.opt
@@ -0,0 +1,5 @@
+; Additional options for Wind River Linux Sourcery G++.
+
+msystem-glibc
+Target
+Use system version of GLIBC
diff --git a/gcc/config/ia64/ia64.h b/gcc/config/ia64/ia64.h
index 0e3c87bf6..568ea5d53 100644
--- a/gcc/config/ia64/ia64.h
+++ b/gcc/config/ia64/ia64.h
@@ -1436,7 +1436,7 @@ do {									\
 /* Define this macro if the register defined by `PIC_OFFSET_TABLE_REGNUM' is
    clobbered by calls.  */
 
-#define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
+#define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED 1
 
 
 /* The Overall Framework of an Assembler File.  */
diff --git a/gcc/config/m68k/constraints.md b/gcc/config/m68k/constraints.md
index 592112a15..57248fed0 100644
--- a/gcc/config/m68k/constraints.md
+++ b/gcc/config/m68k/constraints.md
@@ -124,6 +124,11 @@
   (and (match_code "const_int")
        (match_test "ival < -0x8000 || ival > 0x7FFF")))
 
+(define_constraint "Cu"
+  "16-bit offset for wrapped symbols"
+  (and (match_code "const")
+       (match_test "m68k_unwrap_symbol (op, false) != op")))
+
 (define_constraint "CQ"
   "Integers valid for mvq."
   (and (match_code "const_int")
diff --git a/gcc/config/m68k/lb1sf68.asm b/gcc/config/m68k/lb1sf68.asm
index 4bafbfb18..8b3f06f0b 100644
--- a/gcc/config/m68k/lb1sf68.asm
+++ b/gcc/config/m68k/lb1sf68.asm
@@ -163,6 +163,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #if defined (__mcoldfire__) && !defined (__mcfisab__) && !defined (__mcfisac__)
 	lea	\addr-.-8,a0
 	jsr	pc@(a0)
+#elif defined (__mcfisab__) || defined (__mcfisac__)
+	bsr.l	\addr
 #else
 	bsr	\addr
 #endif
@@ -202,6 +204,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #if defined (__mcoldfire__) && !defined (__mcfisab__) && !defined (__mcfisac__)
 	lea	\addr-.-8,a0
 	jsr	pc@(a0)
+#elif defined (__mcfisab__) || defined (__mcfisac__)
+	bsr.l	\addr
 #else
 	bsr	\addr
 #endif
diff --git a/gcc/config/m68k/linux-unwind.h b/gcc/config/m68k/linux-unwind.h
index 5cfa4afdc..ef956c933 100644
--- a/gcc/config/m68k/linux-unwind.h
+++ b/gcc/config/m68k/linux-unwind.h
@@ -77,9 +77,15 @@ m68k_fallback_frame_state (struct _Unwind_Context *context,
       fs->regs.reg[9].how = REG_SAVED_OFFSET;
       fs->regs.reg[9].loc.offset = (long) &sc->sc_a1 - cfa;
 
+#ifdef __uClinux__
+      fs->regs.reg[13].how = REG_SAVED_OFFSET;
+      fs->regs.reg[13].loc.offset = (long) &sc->sc_a5 - cfa;
+#endif
+
       fs->regs.reg[24].how = REG_SAVED_OFFSET;
       fs->regs.reg[24].loc.offset = (long) &sc->sc_pc - cfa;
 
+#if defined __mcffpu__ && !defined __uClinux__
       if (*(int *) sc->sc_fpstate)
 	{
 	  int *fpregs = (int *) sc->sc_fpregs;
@@ -89,11 +95,19 @@ m68k_fallback_frame_state (struct _Unwind_Context *context,
 	  fs->regs.reg[17].how = REG_SAVED_OFFSET;
 	  fs->regs.reg[17].loc.offset = (long) &fpregs[M68K_FP_SIZE/4] - cfa;
 	}
+#elif defined __mcffpu__
+# error Implement this when uClinux kernel is ported to an FPU architecture
+#endif
     }
 #ifdef __mcoldfire__
   /* move.l #__NR_rt_sigreturn,%d0; trap #0 */
-  else if (pc[0] == 0x203c && pc[1] == 0x0000 &&
-	   pc[2] == 0x00ad && pc[3] == 0x4e40)
+  else if ((pc[0] == 0x203c && pc[1] == 0x0000 &&
+	    pc[2] == 0x00ad && pc[3] == 0x4e40) ||
+	   /* Don't ask me why, this is just what some kernels do:
+	      moveq #-__NR_rt_sigreturn,%d0; andil 0xff,%d0; trap #0;
+	      Sigh...  */
+	   (pc[0] == 0x70ad && pc[1] == 0x0280 && pc[2] == 0x0000 &&
+	    pc[3] == 0x00ff && pc[4] == 0x4e40 && pc[5] == 0x0000))
 #else
   /* moveq #~__NR_rt_sigreturn,%d0; not.b %d0; trap #0 */
   else if (pc[0] == 0x7052 && pc[1] == 0x4600 && pc[2] == 0x4e40)
diff --git a/gcc/config/m68k/linux.h b/gcc/config/m68k/linux.h
index 2eb4641c9..c86c5652a 100644
--- a/gcc/config/m68k/linux.h
+++ b/gcc/config/m68k/linux.h
@@ -149,11 +149,10 @@ along with GCC; see the file COPYING3.  If not see
 
 /* Output assembler code to FILE to increment profiler label # LABELNO
    for profiling a function entry.  */
-
+#define NO_PROFILE_COUNTERS 1
 #undef FUNCTION_PROFILER
 #define FUNCTION_PROFILER(FILE, LABELNO) \
 {									\
-  asm_fprintf (FILE, "\tlea (%LLP%d,%Rpc),%Ra1\n", (LABELNO));		\
   if (flag_pic)								\
     fprintf (FILE, "\tbsr.l _mcount@PLTPC\n");				\
   else									\
diff --git a/gcc/config/m68k/m68k-devices.def b/gcc/config/m68k/m68k-devices.def
index 6f8f4c2e6..4838fb062 100644
--- a/gcc/config/m68k/m68k-devices.def
+++ b/gcc/config/m68k/m68k-devices.def
@@ -72,8 +72,8 @@
 /* 680x0 series processors.  */
 M68K_DEVICE ("68000", m68000,   "68000", "68000", 68000,    isa_00,    0)
 M68K_DEVICE ("68010", m68010,   "68010", "68000", 68010,    isa_10,    0)
-M68K_DEVICE ("68020", m68020,   "68020", "68020", 68020,    isa_20,    FL_MMU)
-M68K_DEVICE ("68030", m68030,   "68030", "68020", 68030,    isa_20,    FL_MMU)
+M68K_DEVICE ("68020", m68020,   "68020", "68020", 68020,    isa_20,    FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("68030", m68030,   "68030", "68020", 68030,    isa_20,    FL_MMU | FL_UCLINUX)
 M68K_DEVICE ("68040", m68040,   "68040", "68040", 68040,    isa_40,    FL_MMU)
 M68K_DEVICE ("68060", m68060,   "68060", "68060", 68060,    isa_40,    FL_MMU)
 M68K_DEVICE ("68302", m68302,   "68302", "68000", 68000,    isa_00,    FL_MMU)
@@ -81,7 +81,13 @@ M68K_DEVICE ("68332", m68332,   "68332", "cpu32", cpu32,    isa_cpu32, FL_MMU)
 M68K_DEVICE ("cpu32", cpu32,    "cpu32", "cpu32", cpu32,    isa_cpu32, FL_MMU)
 
 /* ColdFire CFV1 processor.  */
-M68K_DEVICE ("51qe",  mcf51qe,  "51qe",  "51qe",  cfv1,     isa_c,     FL_CF_USP)
+/* For historical reasons, the 51 multilib is named 51qe.  */
+M68K_DEVICE ("51",    mcf51,    "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51ac",  mcf51ac,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51cn",  mcf51cn,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51em",  mcf51em,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP | FL_CF_MAC)
+M68K_DEVICE ("51jm",  mcf51jm,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51qe",  mcf51qe,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
 
 /* ColdFire CFV2 processors.  */
 M68K_DEVICE ("5202",  mcf5202,  "5206",  "5206",  cfv2,     isa_a,     0)
@@ -97,6 +103,7 @@ M68K_DEVICE ("5212",  mcf5212,  "5213",  "5208",  cfv2,     isa_aplus, FL_CF_HWD
 M68K_DEVICE ("5213",  mcf5213,  "5213",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("5214",  mcf5214,  "5216",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5216",  mcf5216,  "5216",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("5221x", mcf5221x, "5221x", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("52221", mcf52221, "52223", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("52223", mcf52223, "52223", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("52230", mcf52230, "52235", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
@@ -107,6 +114,14 @@ M68K_DEVICE ("52234", mcf52234, "52235", "5208",  cfv2,     isa_aplus, FL_CF_HWD
 M68K_DEVICE ("52235", mcf52235, "52235", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5224",  mcf5224,  "5225",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("5225",  mcf5225,  "5225",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_MAC)
+M68K_DEVICE ("52252", mcf52252, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52254", mcf52254, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52255", mcf52255, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52256", mcf52256, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52258", mcf52258, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52259", mcf52259, "52259", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52274", mcf52274, "52277", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("52277", mcf52277, "52277", "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5232",  mcf5232,  "5235",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5233",  mcf5233,  "5235",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5234",  mcf5234,  "5235",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
@@ -126,6 +141,13 @@ M68K_DEVICE ("5282",  mcf5282,  "5282",  "5208",  cfv2,     isa_aplus, FL_CF_HWD
 M68K_DEVICE ("528x",  mcf528x,  "5282",  "5208",  cfv2,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 
 /* CFV3 processors.  */
+M68K_DEVICE ("53011", mcf53011, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53012", mcf53012, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53013", mcf53013, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53014", mcf53014, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53015", mcf53015, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53016", mcf53016, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
+M68K_DEVICE ("53017", mcf53017, "53017", "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5307",  mcf5307,  "5307",  "5307",  cfv3,     isa_a,     FL_CF_HWDIV | FL_CF_MAC)
 M68K_DEVICE ("5327",  mcf5327,  "5329",  "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
 M68K_DEVICE ("5328",  mcf5328,  "5329",  "5329",  cfv3,     isa_aplus, FL_CF_HWDIV | FL_CF_EMAC)
@@ -137,12 +159,17 @@ M68K_DEVICE ("537x",  mcf537x,  "5373",  "5329",  cfv3,     isa_aplus, FL_CF_HWD
 
 /* CFV4/CFV4e processors.  */
 M68K_DEVICE ("5407",  mcf5407,  "5407",  "5407",  cfv4,     isa_b,     FL_CF_MAC)
-M68K_DEVICE ("54450", mcf54450, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
-M68K_DEVICE ("54451", mcf54451, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
-M68K_DEVICE ("54452", mcf54452, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
-M68K_DEVICE ("54453", mcf54453, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
-M68K_DEVICE ("54454", mcf54454, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
-M68K_DEVICE ("54455", mcf54455, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU)
+M68K_DEVICE ("54410", mcf54410, "54418", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54415", mcf54415, "54418", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54416", mcf54416, "54418", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54417", mcf54417, "54418", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54418", mcf54418, "54418", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54450", mcf54450, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54451", mcf54451, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54452", mcf54452, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54453", mcf54453, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54454", mcf54454, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
+M68K_DEVICE ("54455", mcf54455, "54455", "54455", cfv4,     isa_c,     FL_CF_HWDIV | FL_CF_USP | FL_CF_EMAC | FL_MMU | FL_UCLINUX)
 M68K_DEVICE ("5470",  mcf5470,  "5475",  "5475",  cfv4e,    isa_b,     FL_CF_USP | FL_CF_EMAC | FL_CF_FPU | FL_MMU)
 M68K_DEVICE ("5471",  mcf5471,  "5475",  "5475",  cfv4e,    isa_b,     FL_CF_USP | FL_CF_EMAC | FL_CF_FPU | FL_MMU)
 M68K_DEVICE ("5472",  mcf5472,  "5475",  "5475",  cfv4e,    isa_b,     FL_CF_USP | FL_CF_EMAC | FL_CF_FPU | FL_MMU)
diff --git a/gcc/config/m68k/m68k-protos.h b/gcc/config/m68k/m68k-protos.h
index 43a457fe1..793613ae7 100644
--- a/gcc/config/m68k/m68k-protos.h
+++ b/gcc/config/m68k/m68k-protos.h
@@ -54,19 +54,27 @@ extern void print_operand (FILE *, rtx, int);
 extern bool m68k_output_addr_const_extra (FILE *, rtx);
 extern void notice_update_cc (rtx, rtx);
 extern bool m68k_legitimate_base_reg_p (rtx, bool);
-extern bool m68k_legitimate_index_reg_p (rtx, bool);
+extern bool m68k_legitimate_index_reg_p (enum machine_mode, rtx, bool);
 extern bool m68k_illegitimate_symbolic_constant_p (rtx);
 extern bool m68k_legitimate_address_p (enum machine_mode, rtx, bool);
 extern bool m68k_matches_q_p (rtx);
 extern bool m68k_matches_u_p (rtx);
 extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);
+extern rtx m68k_legitimize_tls_address (rtx);
+extern bool m68k_tls_reference_p (rtx, bool);
+extern rtx m68k_legitimize_address (rtx, rtx, enum machine_mode);
 extern int valid_dbcc_comparison_p_2 (rtx, enum machine_mode);
 extern rtx m68k_libcall_value (enum machine_mode);
 extern rtx m68k_function_value (const_tree, const_tree);
 extern int emit_move_sequence (rtx *, enum machine_mode, rtx);
 extern bool m68k_movem_pattern_p (rtx, rtx, HOST_WIDE_INT, bool);
 extern const char *m68k_output_movem (rtx *, rtx, HOST_WIDE_INT, bool);
+extern void m68k_final_prescan_insn (rtx, rtx *, int);
 
+/* Functions from m68k.c used in constraints.md.  */
+extern rtx m68k_unwrap_symbol (rtx, bool);
+
+/* Functions from m68k.c used in genattrtab.  */
 #ifdef HAVE_ATTR_cpu
 extern enum attr_cpu m68k_sched_cpu;
 extern enum attr_mac m68k_sched_mac;
diff --git a/gcc/config/m68k/m68k.c b/gcc/config/m68k/m68k.c
index 2f931c6be..6c94458df 100644
--- a/gcc/config/m68k/m68k.c
+++ b/gcc/config/m68k/m68k.c
@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see
 /* ??? Need to add a dependency between m68k.o and sched-int.h.  */
 #include "sched-int.h"
 #include "insn-codes.h"
+#include "ggc.h"
 
 enum reg_class regno_reg_class[] =
 {
@@ -146,10 +147,12 @@ static tree m68k_handle_fndecl_attribute (tree *node, tree name,
 static void m68k_compute_frame_layout (void);
 static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);
 static bool m68k_ok_for_sibcall_p (tree, tree);
+static bool m68k_tls_symbol_p (rtx);
 static bool m68k_rtx_costs (rtx, int, int, int *, bool);
 #if M68K_HONOR_TARGET_STRICT_ALIGNMENT
 static bool m68k_return_in_memory (const_tree, const_tree);
 #endif
+static void m68k_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;
 
 
 /* Specify the identification number of the library being built */
@@ -252,6 +255,14 @@ int m68k_last_compare_had_fp_operands;
 #define TARGET_RETURN_IN_MEMORY m68k_return_in_memory
 #endif
 
+#ifdef HAVE_AS_TLS
+#undef TARGET_HAVE_TLS
+#define TARGET_HAVE_TLS (true)
+
+#undef TARGET_ASM_OUTPUT_DWARF_DTPREL
+#define TARGET_ASM_OUTPUT_DWARF_DTPREL m68k_output_dwarf_dtprel
+#endif
+
 static const struct attribute_spec m68k_attribute_table[] =
 {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
@@ -1150,8 +1161,7 @@ m68k_expand_prologue (void)
 			    current_frame.reg_mask, true, true));
     }
 
-  if (flag_pic
-      && !TARGET_SEP_DATA
+  if (!TARGET_SEP_DATA
       && crtl->uses_pic_offset_table)
     insn = emit_insn (gen_load_got (pic_offset_table_rtx));
 }
@@ -1374,6 +1384,30 @@ flags_in_68881 (void)
   return cc_status.flags & CC_IN_68881;
 }
 
+/* Return true if PARALLEL contains register REGNO.  */
+static bool
+m68k_reg_present_p (const_rtx parallel, unsigned int regno)
+{
+  int i;
+
+  if (REG_P (parallel) && REGNO (parallel) == regno)
+    return true;
+
+  if (GET_CODE (parallel) != PARALLEL)
+    return false;
+
+  for (i = 0; i < XVECLEN (parallel, 0); ++i)
+    {
+      const_rtx x;
+
+      x = XEXP (XVECEXP (parallel, 0, i), 0);
+      if (REG_P (x) && REGNO (x) == regno)
+	return true;
+    }
+
+  return false;
+}
+
 /* Implement TARGET_FUNCTION_OK_FOR_SIBCALL_P.  */
 
 static bool
@@ -1386,6 +1420,26 @@ m68k_ok_for_sibcall_p (tree decl, tree exp)
   if (CALL_EXPR_STATIC_CHAIN (exp))
     return false;
 
+  if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (cfun->decl))))
+    {
+      /* Check that the return value locations are the same.  For
+	 example that we aren't returning a value from the sibling in
+	 a D0 register but then need to transfer it to a A0 register.  */
+      rtx cfun_value;
+      rtx call_value;
+
+      cfun_value = FUNCTION_VALUE (TREE_TYPE (DECL_RESULT (cfun->decl)),
+				   cfun->decl);
+      call_value = FUNCTION_VALUE (TREE_TYPE (exp), decl);
+
+      /* Check that the values are equal or that the result the callee
+	 function returns is superset of what the current function returns.  */
+      if (!(rtx_equal_p (cfun_value, call_value)
+	    || (REG_P (cfun_value)
+		&& m68k_reg_present_p (call_value, REGNO (cfun_value)))))
+	return false;
+    }
+
   kind = m68k_get_function_kind (current_function_decl);
   if (kind == m68k_fk_normal_function)
     /* We can always sibcall from a normal function, because it's
@@ -1425,6 +1479,86 @@ m68k_legitimize_sibcall_address (rtx x)
   return replace_equiv_address (x, gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM));
 }
 
+/* Convert X to a legitimate address and return it if successful.  Otherwise
+   return X.
+
+   For the 68000, we handle X+REG by loading X into a register R and
+   using R+REG.  R will go in an address reg and indexing will be used.
+   However, if REG is a broken-out memory address or multiplication,
+   nothing needs to be done because REG can certainly go in an address reg.  */
+
+rtx
+m68k_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)
+{
+  if (m68k_tls_symbol_p (x))
+    return m68k_legitimize_tls_address (x);
+
+  if (GET_CODE (x) == PLUS)
+    {
+      int ch = (x) != (oldx);
+      int copied = 0;
+
+#define COPY_ONCE(Y) if (!copied) { Y = copy_rtx (Y); copied = ch = 1; }
+
+      if (GET_CODE (XEXP (x, 0)) == MULT)
+	{
+	  COPY_ONCE (x);
+	  XEXP (x, 0) = force_operand (XEXP (x, 0), 0);
+	}
+      if (GET_CODE (XEXP (x, 1)) == MULT)
+	{
+	  COPY_ONCE (x);
+	  XEXP (x, 1) = force_operand (XEXP (x, 1), 0);
+	}
+      if (ch)
+	{
+          if (GET_CODE (XEXP (x, 1)) == REG
+	      && GET_CODE (XEXP (x, 0)) == REG)
+	    {
+	      if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (mode) == MODE_FLOAT)
+	        {
+	          COPY_ONCE (x);
+	          x = force_operand (x, 0);
+	        }
+	      return x;
+	    }
+	  if (memory_address_p (mode, x))
+	    return x;
+	}
+      if (GET_CODE (XEXP (x, 0)) == REG
+	  || (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND
+	      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG
+	      && GET_MODE (XEXP (XEXP (x, 0), 0)) == HImode))
+	{
+	  rtx temp = gen_reg_rtx (Pmode);
+	  rtx val = force_operand (XEXP (x, 1), 0);
+	  emit_move_insn (temp, val);
+	  COPY_ONCE (x);
+	  XEXP (x, 1) = temp;
+	  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (mode) == MODE_FLOAT
+	      && GET_CODE (XEXP (x, 0)) == REG)
+	    x = force_operand (x, 0);
+	}
+      else if (GET_CODE (XEXP (x, 1)) == REG
+	       || (GET_CODE (XEXP (x, 1)) == SIGN_EXTEND
+		   && GET_CODE (XEXP (XEXP (x, 1), 0)) == REG
+		   && GET_MODE (XEXP (XEXP (x, 1), 0)) == HImode))
+	{
+	  rtx temp = gen_reg_rtx (Pmode);
+	  rtx val = force_operand (XEXP (x, 0), 0);
+	  emit_move_insn (temp, val);
+	  COPY_ONCE (x);
+	  XEXP (x, 0) = temp;
+	  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (mode) == MODE_FLOAT
+	      && GET_CODE (XEXP (x, 1)) == REG)
+	    x = force_operand (x, 0);
+	}
+    }
+
+  return x;
+}
+
+
 /* Output a dbCC; jCC sequence.  Note we do not handle the 
    floating point version of this sequence (Fdbcc).  We also
    do not handle alternative conditions when CC_NO_OVERFLOW is
@@ -1713,15 +1847,16 @@ m68k_legitimate_base_reg_p (rtx x, bool strict_p)
    whether we need strict checking.  */
 
 bool
-m68k_legitimate_index_reg_p (rtx x, bool strict_p)
+m68k_legitimate_index_reg_p (enum machine_mode mode, rtx x, bool strict_p)
 {
   if (!strict_p && GET_CODE (x) == SUBREG)
     x = SUBREG_REG (x);
 
   return (REG_P (x)
 	  && (strict_p
-	      ? REGNO_OK_FOR_INDEX_P (REGNO (x))
-	      : REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO (x))));
+	      ? REGNO_MODE_OK_FOR_INDEX_P (REGNO (x), mode)
+	      : (MODE_OK_FOR_INDEX_P (mode)
+		 && REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO (x)))));
 }
 
 /* Return true if X is a legitimate index expression for a (d8,An,Xn) or
@@ -1729,7 +1864,8 @@ m68k_legitimate_index_reg_p (rtx x, bool strict_p)
    ADDRESS if so.  STRICT_P says whether we need strict checking.  */
 
 static bool
-m68k_decompose_index (rtx x, bool strict_p, struct m68k_address *address)
+m68k_decompose_index (enum machine_mode mode, rtx x, bool strict_p,
+		      struct m68k_address *address)
 {
   int scale;
 
@@ -1753,7 +1889,7 @@ m68k_decompose_index (rtx x, bool strict_p, struct m68k_address *address)
       && GET_MODE (XEXP (x, 0)) == HImode)
     x = XEXP (x, 0);
 
-  if (m68k_legitimate_index_reg_p (x, strict_p))
+  if (m68k_legitimate_index_reg_p (mode, x, strict_p))
     {
       address->scale = scale;
       address->index = x;
@@ -1777,7 +1913,7 @@ m68k_illegitimate_symbolic_constant_p (rtx x)
 	  && !offset_within_block_p (base, INTVAL (offset)))
 	return true;
     }
-  return false;
+  return m68k_tls_reference_p (x, false);
 }
 
 /* Return true if X is a legitimate constant address that can reach
@@ -1805,7 +1941,7 @@ m68k_legitimate_constant_address_p (rtx x, unsigned int reach, bool strict_p)
 	return false;
     }
 
-  return true;
+  return !m68k_tls_reference_p (x, false);
 }
 
 /* Return true if X is a LABEL_REF for a jump table.  Assume that unplaced
@@ -1872,15 +2008,17 @@ m68k_decompose_address (enum machine_mode mode, rtx x,
   /* Check for GOT loads.  These are (bd,An,Xn) addresses if
      TARGET_68020 && flag_pic == 2, otherwise they are (d16,An)
      addresses.  */
-  if (flag_pic
-      && GET_CODE (x) == PLUS
-      && XEXP (x, 0) == pic_offset_table_rtx
-      && (GET_CODE (XEXP (x, 1)) == SYMBOL_REF
-	  || GET_CODE (XEXP (x, 1)) == LABEL_REF))
+  if (GET_CODE (x) == PLUS
+      && XEXP (x, 0) == pic_offset_table_rtx)
     {
-      address->base = XEXP (x, 0);
-      address->offset = XEXP (x, 1);
-      return true;
+      /* As we are processing a PLUS, do not unwrap RELOC32 symbols --
+	 they are invalid in this context.  */
+      if (m68k_unwrap_symbol (XEXP (x, 1), false) != XEXP (x, 1))
+	{
+	  address->base = XEXP (x, 0);
+	  address->offset = XEXP (x, 1);
+	  return true;
+	}
     }
 
   /* The ColdFire FPU only accepts addressing modes 2-5.  */
@@ -1905,7 +2043,7 @@ m68k_decompose_address (enum machine_mode mode, rtx x,
      accesses to unplaced labels in other cases.  */
   if (GET_CODE (x) == PLUS
       && m68k_jump_table_ref_p (XEXP (x, 1))
-      && m68k_decompose_index (XEXP (x, 0), strict_p, address))
+      && m68k_decompose_index (mode, XEXP (x, 0), strict_p, address))
     {
       address->offset = XEXP (x, 1);
       return true;
@@ -1937,7 +2075,7 @@ m68k_decompose_address (enum machine_mode mode, rtx x,
 	 worse code.  */
       if (address->offset
 	  && symbolic_operand (address->offset, VOIDmode)
-	  && m68k_decompose_index (x, strict_p, address))
+	  && m68k_decompose_index (mode, x, strict_p, address))
 	return true;
     }
   else
@@ -1956,14 +2094,14 @@ m68k_decompose_address (enum machine_mode mode, rtx x,
   if (GET_CODE (x) == PLUS)
     {
       if (m68k_legitimate_base_reg_p (XEXP (x, 0), strict_p)
-	  && m68k_decompose_index (XEXP (x, 1), strict_p, address))
+	  && m68k_decompose_index (mode, XEXP (x, 1), strict_p, address))
 	{
 	  address->base = XEXP (x, 0);
 	  return true;
 	}
 
       if (m68k_legitimate_base_reg_p (XEXP (x, 1), strict_p)
-	  && m68k_decompose_index (XEXP (x, 0), strict_p, address))
+	  && m68k_decompose_index (mode, XEXP (x, 0), strict_p, address))
 	{
 	  address->base = XEXP (x, 1);
 	  return true;
@@ -2025,6 +2163,243 @@ m68k_matches_u_p (rtx x)
 	  && !address.index);
 }
 
+/* Return GOT pointer.  */
+
+static rtx
+m68k_get_gp (void)
+{
+  if (pic_offset_table_rtx == NULL_RTX)
+    pic_offset_table_rtx = gen_rtx_REG (Pmode, PIC_REG);
+
+  crtl->uses_pic_offset_table = 1;
+
+  return pic_offset_table_rtx;
+}
+
+/* M68K relocations, used to distinguish GOT and TLS relocations in UNSPEC
+   wrappers.  */
+enum m68k_reloc { RELOC_GOT, RELOC_TLSGD, RELOC_TLSLDM, RELOC_TLSLDO,
+		  RELOC_TLSIE, RELOC_TLSLE };
+
+#define TLS_RELOC_P(RELOC) ((RELOC) != RELOC_GOT)
+
+/* Wrap symbol X into unspec representing relocation RELOC.
+   BASE_REG - register that should be added to the result.
+   TEMP_REG - if non-null, temporary register.  */
+
+static rtx
+m68k_wrap_symbol (rtx x, enum m68k_reloc reloc, rtx base_reg, rtx temp_reg)
+{
+  bool use_x_p;
+
+  use_x_p = (base_reg == pic_offset_table_rtx) ? TARGET_XGOT : TARGET_XTLS;
+
+  if (TARGET_COLDFIRE && use_x_p)
+    /* When compiling with -mx{got, tls} switch the code will look like this:
+
+       move.l <X>@<RELOC>,<TEMP_REG>
+       add.l <BASE_REG>,<TEMP_REG>  */
+    {
+      /* Wrap X in UNSPEC_??? to tip m68k_output_addr_const_extra
+	 to put @RELOC after reference.  */
+      x = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x, GEN_INT (reloc)),
+			  UNSPEC_RELOC32);
+      x = gen_rtx_CONST (Pmode, x);
+
+      if (temp_reg == NULL)
+	{
+	  gcc_assert (can_create_pseudo_p ());
+	  temp_reg = gen_reg_rtx (Pmode);
+	}
+
+      emit_move_insn (temp_reg, x);
+      emit_insn (gen_addsi3 (temp_reg, temp_reg, base_reg));
+      x = temp_reg;
+    }
+  else
+    {
+      x = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x, GEN_INT (reloc)),
+			  UNSPEC_RELOC16);
+      x = gen_rtx_CONST (Pmode, x);
+
+      x = gen_rtx_PLUS (Pmode, base_reg, x);
+    }
+
+  return x;
+}
+
+/* Helper for m68k_unwrap_symbol.
+   Also, if unwrapping was successful (that is if (ORIG != <return value>)),
+   sets *RELOC_PTR to relocation type for the symbol.  */
+
+static rtx
+m68k_unwrap_symbol_1 (rtx orig, bool unwrap_reloc32_p,
+		      enum m68k_reloc *reloc_ptr)
+{
+  if (GET_CODE (orig) == CONST)
+    {
+      rtx x;
+      enum m68k_reloc dummy;
+
+      x = XEXP (orig, 0);
+
+      if (reloc_ptr == NULL)
+	reloc_ptr = &dummy;
+
+      /* Handle an addend.  */
+      if ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS)
+	  && CONST_INT_P (XEXP (x, 1)))
+	x = XEXP (x, 0);
+
+      if (GET_CODE (x) == UNSPEC)
+	{
+	  switch (XINT (x, 1))
+	    {
+	    case UNSPEC_RELOC16:
+	      orig = XVECEXP (x, 0, 0);
+	      *reloc_ptr = (enum m68k_reloc) INTVAL (XVECEXP (x, 0, 1));
+	      break;
+
+	    case UNSPEC_RELOC32:
+	      if (unwrap_reloc32_p)
+		{
+		  orig = XVECEXP (x, 0, 0);
+		  *reloc_ptr = (enum m68k_reloc) INTVAL (XVECEXP (x, 0, 1));
+		}
+	      break;
+
+	    default:
+	      break;
+	    }
+	}
+    }
+
+  return orig;
+}
+
+/* Unwrap symbol from UNSPEC_RELOC16 and, if unwrap_reloc32_p,
+   UNSPEC_RELOC32 wrappers.  */
+
+rtx
+m68k_unwrap_symbol (rtx orig, bool unwrap_reloc32_p)
+{
+  return m68k_unwrap_symbol_1 (orig, unwrap_reloc32_p, NULL);
+}
+
+/* Helper for m68k_final_prescan_insn.  */
+
+static int
+m68k_final_prescan_insn_1 (rtx *x_ptr, void *data ATTRIBUTE_UNUSED)
+{
+  rtx x = *x_ptr;
+
+  if (m68k_unwrap_symbol (x, true) != x)
+    /* For rationale of the below, see comment in m68k_final_prescan_insn.  */
+    {
+      rtx plus;
+
+      gcc_assert (GET_CODE (x) == CONST);
+      plus = XEXP (x, 0);
+
+      if (GET_CODE (plus) == PLUS || GET_CODE (plus) == MINUS)
+	{
+	  rtx unspec;
+	  rtx addend;
+
+	  unspec = XEXP (plus, 0);
+	  gcc_assert (GET_CODE (unspec) == UNSPEC);
+	  addend = XEXP (plus, 1);
+	  gcc_assert (CONST_INT_P (addend));
+
+	  /* We now have all the pieces, rearrange them.  */
+
+	  /* Move symbol to plus.  */
+	  XEXP (plus, 0) = XVECEXP (unspec, 0, 0);
+
+	  /* Move plus inside unspec.  */
+	  XVECEXP (unspec, 0, 0) = plus;
+
+	  /* Move unspec to top level of const.  */
+	  XEXP (x, 0) = unspec;
+	}
+
+      return -1;
+    }
+
+  return 0;
+}
+
+/* Prescan insn before outputing assembler for it.  */
+
+void
+m68k_final_prescan_insn (rtx insn ATTRIBUTE_UNUSED,
+			 rtx *operands, int n_operands)
+{
+  int i;
+
+  /* Combine and, possibly, other optimizations may do good job
+     converting
+       (const (unspec [(symbol)]))
+     into
+       (const (plus (unspec [(symbol)])
+                    (const_int N))).
+     The problem with this is emitting @TLS or @GOT decorations.
+     The decoration is emitted when processing (unspec), so the
+     result would be "#symbol@TLSLE+N" instead of "#symbol+N@TLSLE".
+
+     It seems that the easiest solution to this is to convert such
+     operands to
+       (const (unspec [(plus (symbol)
+                             (const_int N))])).
+     Note, that the top level of operand remains intact, so we don't have
+     to patch up anything outside of the operand.  */
+
+  for (i = 0; i < n_operands; ++i)
+    {
+      rtx op;
+
+      op = operands[i];
+
+      for_each_rtx (&op, m68k_final_prescan_insn_1, NULL);
+    }
+}
+
+/* Move X to a register and add REG_EQUAL note pointing to ORIG.
+   If REG is non-null, use it; generate new pseudo otherwise.  */
+
+static rtx
+m68k_move_to_reg (rtx x, rtx orig, rtx reg)
+{
+  rtx insn;
+
+  if (reg == NULL_RTX)
+    {
+      gcc_assert (can_create_pseudo_p ());
+      reg = gen_reg_rtx (Pmode);
+    }
+
+  insn = emit_move_insn (reg, x);
+  /* Put a REG_EQUAL note on this insn, so that it can be optimized
+     by loop.  */
+  set_unique_reg_note (insn, REG_EQUAL, orig);
+
+  return reg;
+}
+
+/* Does the same as m68k_wrap_symbol, but returns a memory reference to
+   GOT slot.  */
+
+static rtx
+m68k_wrap_symbol_into_got_ref (rtx x, enum m68k_reloc reloc, rtx temp_reg)
+{
+  x = m68k_wrap_symbol (x, reloc, m68k_get_gp (), temp_reg);
+
+  x = gen_rtx_MEM (Pmode, x);
+  MEM_READONLY_P (x) = 1;
+
+  return x;
+}
+
 /* Legitimize PIC addresses.  If the address is already
    position-independent, we return ORIG.  Newly generated
    position-independent addresses go to REG.  If we need more
@@ -2076,42 +2451,15 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,
     {
       gcc_assert (reg);
 
-      if (TARGET_COLDFIRE && TARGET_XGOT)
-	/* When compiling with -mxgot switch the code for the above
-	   example will look like this:
-
-	   movel a5, a0
-	   addl _foo@GOT, a0
-	   movel a0@, a0
-	   movel #12345, a0@  */
-	{
-	  rtx pic_offset;
-
-	  /* Wrap ORIG in UNSPEC_GOTOFF to tip m68k_output_addr_const_extra
-	     to put @GOT after reference.  */
-	  pic_offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, orig),
-				       UNSPEC_GOTOFF);
-	  pic_offset = gen_rtx_CONST (Pmode, pic_offset);
-	  emit_move_insn (reg, pic_offset);
-	  emit_insn (gen_addsi3 (reg, reg, pic_offset_table_rtx));
-	  pic_ref = gen_rtx_MEM (Pmode, reg);
-	}
-      else
-	pic_ref = gen_rtx_MEM (Pmode,
-			       gen_rtx_PLUS (Pmode,
-					     pic_offset_table_rtx, orig));
-      crtl->uses_pic_offset_table = 1;
-      MEM_READONLY_P (pic_ref) = 1;
-      emit_move_insn (reg, pic_ref);
-      return reg;
+      pic_ref = m68k_wrap_symbol_into_got_ref (orig, RELOC_GOT, reg);
+      pic_ref = m68k_move_to_reg (pic_ref, orig, reg);
     }
   else if (GET_CODE (orig) == CONST)
     {
       rtx base;
 
       /* Make sure this has not already been legitimized.  */
-      if (GET_CODE (XEXP (orig, 0)) == PLUS
-	  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)
+      if (m68k_unwrap_symbol (orig, true) != orig)
 	return orig;
 
       gcc_assert (reg);
@@ -2124,13 +2472,257 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,
 				     base == reg ? 0 : reg);
 
       if (GET_CODE (orig) == CONST_INT)
-	return plus_constant (base, INTVAL (orig));
-      pic_ref = gen_rtx_PLUS (Pmode, base, orig);
-      /* Likewise, should we set special REG_NOTEs here?  */
+	pic_ref = plus_constant (base, INTVAL (orig));
+      else
+	pic_ref = gen_rtx_PLUS (Pmode, base, orig);
     }
+
   return pic_ref;
 }
 
+/* The __tls_get_addr symbol.  */
+static GTY(()) rtx m68k_tls_get_addr;
+
+/* Return SYMBOL_REF for __tls_get_addr.  */
+
+static rtx
+m68k_get_tls_get_addr (void)
+{
+  if (m68k_tls_get_addr == NULL_RTX)
+    m68k_tls_get_addr = init_one_libfunc ("__tls_get_addr");
+
+  return m68k_tls_get_addr;
+}
+
+/* Return libcall result in A0 instead of usual D0.  */
+static bool m68k_libcall_value_in_a0_p = false;
+
+/* Emit instruction sequence that calls __tls_get_addr.  X is
+   the TLS symbol we are referencing and RELOC is the symbol type to use
+   (either TLSGD or TLSLDM).  EQV is the REG_EQUAL note for the sequence
+   emitted.  A pseudo register with result of __tls_get_addr call is
+   returned.  */
+
+static rtx
+m68k_call_tls_get_addr (rtx x, rtx eqv, enum m68k_reloc reloc)
+{
+  rtx a0;
+  rtx insns;
+  rtx dest;
+
+  /* Emit the call sequence.  */
+  start_sequence ();
+
+  /* FIXME: Unfortunately, emit_library_call_value does not
+     consider (plus (%a5) (const (unspec))) to be a good enough
+     operand for push, so it forces it into a register.  The bad
+     thing about this is that combiner, due to copy propagation and other
+     optimizations, sometimes can not later fix this.  As a consequence,
+     additional register may be allocated resulting in a spill.
+     For reference, see args processing loops in
+     calls.c:emit_library_call_value_1.
+     For testcase, see gcc.target/m68k/tls-{gd, ld}.c  */
+  x = m68k_wrap_symbol (x, reloc, m68k_get_gp (), NULL_RTX);
+
+  /* __tls_get_addr() is not a libcall, but emitting a libcall_value
+     is the simpliest way of generating a call.  The difference between
+     __tls_get_addr() and libcall is that the result is returned in D0
+     instead of A0.  To workaround this, we use m68k_libcall_value_in_a0_p
+     which temporarily switches returning the result to A0.  */ 
+
+  m68k_libcall_value_in_a0_p = true;
+  a0 = emit_library_call_value (m68k_get_tls_get_addr (), NULL_RTX, LCT_PURE,
+				Pmode, 1, x, Pmode);
+  m68k_libcall_value_in_a0_p = false;
+  
+  insns = get_insns ();
+  end_sequence ();
+
+  gcc_assert (can_create_pseudo_p ());
+  dest = gen_reg_rtx (Pmode);
+  emit_libcall_block (insns, dest, a0, eqv);
+
+  return dest;
+}
+
+/* The __tls_get_addr symbol.  */
+static GTY(()) rtx m68k_read_tp;
+
+/* Return SYMBOL_REF for __m68k_read_tp.  */
+
+static rtx
+m68k_get_m68k_read_tp (void)
+{
+  if (m68k_read_tp == NULL_RTX)
+    m68k_read_tp = init_one_libfunc ("__m68k_read_tp");
+
+  return m68k_read_tp;
+}
+
+/* Emit instruction sequence that calls __m68k_read_tp.
+   A pseudo register with result of __m68k_read_tp call is returned.  */
+
+static rtx 
+m68k_call_m68k_read_tp (void)
+{
+  rtx a0;
+  rtx eqv;
+  rtx insns;
+  rtx dest;
+
+  start_sequence ();
+
+  /* __m68k_read_tp() is not a libcall, but emitting a libcall_value
+     is the simpliest way of generating a call.  The difference between
+     __m68k_read_tp() and libcall is that the result is returned in D0
+     instead of A0.  To workaround this, we use m68k_libcall_value_in_a0_p
+     which temporarily switches returning the result to A0.  */ 
+
+  /* Emit the call sequence.  */
+  m68k_libcall_value_in_a0_p = true;
+  a0 = emit_library_call_value (m68k_get_m68k_read_tp (), NULL_RTX, LCT_PURE,
+				Pmode, 0);
+  m68k_libcall_value_in_a0_p = false;
+  insns = get_insns ();
+  end_sequence ();
+
+  /* Attach a unique REG_EQUIV, to allow the RTL optimizers to
+     share the m68k_read_tp result with other IE/LE model accesses.  */
+  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const1_rtx), UNSPEC_RELOC32);
+
+  gcc_assert (can_create_pseudo_p ());
+  dest = gen_reg_rtx (Pmode);
+  emit_libcall_block (insns, dest, a0, eqv);
+
+  return dest;
+}
+
+/* Return a legitimized address for accessing TLS SYMBOL_REF X.
+   For explanations on instructions sequences see TLS/NPTL ABI for m68k and
+   ColdFire.  */
+
+rtx
+m68k_legitimize_tls_address (rtx orig)
+{
+  switch (SYMBOL_REF_TLS_MODEL (orig))
+    {
+    case TLS_MODEL_GLOBAL_DYNAMIC:
+      orig = m68k_call_tls_get_addr (orig, orig, RELOC_TLSGD);
+      break;
+
+    case TLS_MODEL_LOCAL_DYNAMIC:
+      {
+	rtx eqv;
+	rtx a0;
+	rtx x;
+ 
+	/* Attach a unique REG_EQUIV, to allow the RTL optimizers to
+	   share the LDM result with other LD model accesses.  */
+	eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),
+			      UNSPEC_RELOC32);
+
+	a0 = m68k_call_tls_get_addr (orig, eqv, RELOC_TLSLDM);
+
+	x = m68k_wrap_symbol (orig, RELOC_TLSLDO, a0, NULL_RTX);
+
+	if (can_create_pseudo_p ())
+	  x = m68k_move_to_reg (x, orig, NULL_RTX);
+
+	orig = x;
+	break;
+      }
+
+    case TLS_MODEL_INITIAL_EXEC:
+      {
+	rtx a0;
+	rtx x;
+
+	a0 = m68k_call_m68k_read_tp ();
+
+	x = m68k_wrap_symbol_into_got_ref (orig, RELOC_TLSIE, NULL_RTX);
+	x = gen_rtx_PLUS (Pmode, x, a0);
+
+	if (can_create_pseudo_p ())
+	  x = m68k_move_to_reg (x, orig, NULL_RTX);
+
+	orig = x;
+	break;
+      }
+
+    case TLS_MODEL_LOCAL_EXEC:
+      {
+	rtx a0;
+	rtx x;
+
+	a0 = m68k_call_m68k_read_tp ();
+
+	x = m68k_wrap_symbol (orig, RELOC_TLSLE, a0, NULL_RTX);
+
+	if (can_create_pseudo_p ())
+	  x = m68k_move_to_reg (x, orig, NULL_RTX);
+
+	orig = x;
+	break;
+      }
+
+    default:
+      gcc_unreachable ();
+    }
+
+  return orig;
+}
+
+/* Return true if X is a TLS symbol.  */
+
+static bool
+m68k_tls_symbol_p (rtx x)
+{
+  if (!TARGET_HAVE_TLS)
+    return false;
+
+  if (GET_CODE (x) != SYMBOL_REF)
+    return false;
+
+  return SYMBOL_REF_TLS_MODEL (x) != 0;
+}
+
+/* Helper for m68k_tls_referenced_p.  */
+
+static int
+m68k_tls_reference_p_1 (rtx *x_ptr, void *data ATTRIBUTE_UNUSED)
+{
+  /* Note: this is not the same as m68k_tls_symbol_p.  */
+  if (GET_CODE (*x_ptr) == SYMBOL_REF)
+    return SYMBOL_REF_TLS_MODEL (*x_ptr) != 0 ? 1 : 0;
+
+  /* Don't recurse into legitimate TLS references.  */
+  if (m68k_tls_reference_p (*x_ptr, true))
+    return -1;
+
+  return 0;
+}
+
+/* If !LEGITIMATE_P, return true if X is a TLS symbol reference,
+   though illegitimate one.
+   If LEGITIMATE_P, return true if X is a legitimate TLS symbol reference.  */
+
+bool
+m68k_tls_reference_p (rtx x, bool legitimate_p)
+{
+  if (!TARGET_HAVE_TLS)
+    return false;
+
+  if (!legitimate_p)
+    return for_each_rtx (&x, m68k_tls_reference_p_1, NULL) == 1 ? true : false;
+  else
+    {
+      enum m68k_reloc reloc = RELOC_GOT;
+
+      return (m68k_unwrap_symbol_1 (x, true, &reloc) != x
+	      && TLS_RELOC_P (reloc));
+    }
+}
+
 
 
 #define USE_MOVQ(i)	((unsigned) ((i) + 128) <= 255)
@@ -3918,18 +4510,92 @@ print_operand (FILE *file, rtx op, int letter)
     }
 }
 
+/* Return string for TLS relocation RELOC.  */
+
+static const char *
+m68k_get_reloc_decoration (enum m68k_reloc reloc)
+{
+  /* To my knowledge, !MOTOROLA assemblers don't support TLS.  */
+  gcc_assert (MOTOROLA || reloc == RELOC_GOT);
+
+  switch (reloc)
+    {
+    case RELOC_GOT:
+      if (MOTOROLA)
+	{
+	  if (flag_pic == 1 && TARGET_68020)
+	    return "@GOT.w";
+	  else
+	    return "@GOT";
+	}
+      else
+	{
+	  if (TARGET_68020)
+	    {
+	      switch (flag_pic)
+		{
+		case 1:
+		  return ":w";
+		case 2:
+		  return ":l";
+		default:
+		  return "";
+		}
+	    }
+	}
+
+    case RELOC_TLSGD:
+      return "@TLSGD";
+
+    case RELOC_TLSLDM:
+      return "@TLSLDM";
+
+    case RELOC_TLSLDO:
+      return "@TLSLDO";
+
+    case RELOC_TLSIE:
+      return "@TLSIE";
+
+    case RELOC_TLSLE:
+      return "@TLSLE";
+
+    default:
+      gcc_unreachable ();
+    }
+}
+
 /* m68k implementation of OUTPUT_ADDR_CONST_EXTRA.  */
 
 bool
 m68k_output_addr_const_extra (FILE *file, rtx x)
 {
-  if (GET_CODE (x) != UNSPEC || XINT (x, 1) != UNSPEC_GOTOFF)
-    return false;
+  if (GET_CODE (x) == UNSPEC)
+    {
+      switch (XINT (x, 1))
+	{
+	case UNSPEC_RELOC16:
+	case UNSPEC_RELOC32:
+	  output_addr_const (file, XVECEXP (x, 0, 0));
+	  fputs (m68k_get_reloc_decoration (INTVAL (XVECEXP (x, 0, 1))), file);
+	  return true;
 
-  output_addr_const (file, XVECEXP (x, 0, 0));
-  /* ??? What is the non-MOTOROLA syntax?  */
-  fputs ("@GOT", file);
-  return true;
+	default:
+	  break;
+	}
+    }
+
+  return false;
+}
+
+/* M68K implementation of TARGET_ASM_OUTPUT_DWARF_DTPREL.  */
+
+static void
+m68k_output_dwarf_dtprel (FILE *file, int size, rtx x)
+{
+  gcc_assert (size == 4);
+  fputs ("\t.long\t", file);
+  output_addr_const (file, x);
+  fputs ("@TLSLDO+0x8000", file);
 }
 
 
@@ -4019,15 +4685,8 @@ print_operand_address (FILE *file, rtx addr)
 	  else
 	    {
 	      if (address.offset)
-		{
-		  output_addr_const (file, address.offset);
-		  if (flag_pic && address.base == pic_offset_table_rtx)
-		    {
-		      fprintf (file, "@GOT");
-		      if (flag_pic == 1 && TARGET_68020)
-			fprintf (file, ".w");
-		    }
-		}
+		output_addr_const (file, address.offset);
+
 	      putc ('(', file);
 	      if (address.base)
 		fputs (M68K_REGNAME (REGNO (address.base)), file);
@@ -4060,19 +4719,7 @@ print_operand_address (FILE *file, rtx addr)
 		    fputs (M68K_REGNAME (REGNO (address.base)), file);
 		  fprintf (file, "@(");
 		  if (address.offset)
-		    {
-		      output_addr_const (file, address.offset);
-		      if (address.base == pic_offset_table_rtx && TARGET_68020)
-			switch (flag_pic)
-			  {
-			  case 1:
-			    fprintf (file, ":w"); break;
-			  case 2:
-			    fprintf (file, ":l"); break;
-			  default:
-			    break;
-			  }
-		    }
+		    output_addr_const (file, address.offset);
 		}
 	      /* Print the ",index" component, if any.  */
 	      if (address.index)
@@ -4580,9 +5227,13 @@ m68k_libcall_value (enum machine_mode mode)
   default:
     break;
   }
-  return gen_rtx_REG (mode, D0_REG);
+
+  return gen_rtx_REG (mode, m68k_libcall_value_in_a0_p ? A0_REG : D0_REG);
 }
 
+/* Return location in which function value is returned.
+   NOTE: Due to differences in ABIs, don't call this function directly,
+   use FUNCTION_VALUE instead.  */
 rtx
 m68k_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)
 {
@@ -4846,9 +5497,8 @@ sched_attr_op_type (rtx insn, bool opx_p, bool address_p)
 	  return OP_TYPE_IMM_L;
 
 	default:
-	  if (GET_CODE (op) == SYMBOL_REF)
-	    /* ??? Just a guess.  Probably we can guess better using length
-	       attribute of the instructions.  */
+	  if (symbolic_operand (m68k_unwrap_symbol (op, false), VOIDmode))
+	    /* Just a guess.  */
 	    return OP_TYPE_IMM_W;
 
 	  return OP_TYPE_IMM_L;
@@ -5793,3 +6443,5 @@ m68k_sched_indexed_address_bypass_p (rtx pro, rtx con)
       return 0;
     }
 }
+
+#include "gt-m68k.h"
diff --git a/gcc/config/m68k/m68k.h b/gcc/config/m68k/m68k.h
index 8c0f4f20e..fcb748dcb 100644
--- a/gcc/config/m68k/m68k.h
+++ b/gcc/config/m68k/m68k.h
@@ -232,6 +232,7 @@ along with GCC; see the file COPYING3.  If not see
 #define FL_ISA_C     (1 << 16)
 #define FL_FIDOA     (1 << 17)
 #define FL_MMU 	     0   /* Used by multilib machinery.  */
+#define FL_UCLINUX   0   /* Used by multilib machinery.  */
 
 #define TARGET_68010		((m68k_cpu_flags & FL_ISA_68010) != 0)
 #define TARGET_68020		((m68k_cpu_flags & FL_ISA_68020) != 0)
@@ -501,7 +502,8 @@ enum reg_class {
 
 extern enum reg_class regno_reg_class[];
 #define REGNO_REG_CLASS(REGNO) (regno_reg_class[(REGNO)])
-#define INDEX_REG_CLASS GENERAL_REGS
+#define MODE_INDEX_REG_CLASS(MODE) \
+  (MODE_OK_FOR_INDEX_P (MODE) ? GENERAL_REGS : NO_REGS)
 #define BASE_REG_CLASS ADDR_REGS
 
 #define PREFERRED_RELOAD_CLASS(X,CLASS) \
@@ -675,6 +677,10 @@ __transfer_from_trampoline ()					\
 #define HAVE_POST_INCREMENT 1
 #define HAVE_PRE_DECREMENT 1
 
+/* Return true if addresses of mode MODE can have an index register.  */
+#define MODE_OK_FOR_INDEX_P(MODE) \
+  (!TARGET_COLDFIRE_FPU || GET_MODE_CLASS (MODE) != MODE_FLOAT)
+
 /* Macros to check register numbers against specific register classes.  */
 
 /* True for data registers, D0 through D7.  */
@@ -689,9 +695,10 @@ __transfer_from_trampoline ()					\
 /* True for floating point registers, FP0 through FP7.  */
 #define FP_REGNO_P(REGNO)	IN_RANGE (REGNO, 16, 23)
 
-#define REGNO_OK_FOR_INDEX_P(REGNO)			\
-  (INT_REGNO_P (REGNO)					\
-   || INT_REGNO_P (reg_renumber[REGNO]))
+#define REGNO_MODE_OK_FOR_INDEX_P(REGNO, MODE)		\
+  (MODE_OK_FOR_INDEX_P (MODE)				\
+   && (INT_REGNO_P (REGNO)				\
+       || INT_REGNO_P (reg_renumber[REGNO])))
 
 #define REGNO_OK_FOR_BASE_P(REGNO)			\
   (ADDRESS_REGNO_P (REGNO)				\
@@ -751,13 +758,14 @@ __transfer_from_trampoline ()					\
 
 #define LEGITIMATE_PIC_OPERAND_P(X)				\
   (!symbolic_operand (X, VOIDmode)				\
-   || (TARGET_PCREL && REG_STRICT_P))
+   || (TARGET_PCREL && REG_STRICT_P)				\
+   || m68k_tls_reference_p (X, true))
 
 #define REG_OK_FOR_BASE_P(X) \
   m68k_legitimate_base_reg_p (X, REG_STRICT_P)
 
-#define REG_OK_FOR_INDEX_P(X) \
-  m68k_legitimate_index_reg_p (X, REG_STRICT_P)
+#define REG_MODE_OK_FOR_INDEX_P(X, MODE)	\
+  m68k_legitimate_index_reg_p (MODE, X, REG_STRICT_P)
 
 #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)				\
   do									\
@@ -770,52 +778,19 @@ __transfer_from_trampoline ()					\
 /* This address is OK as it stands.  */
 #define PIC_CASE_VECTOR_ADDRESS(index) index
 
-/* For the 68000, we handle X+REG by loading X into a register R and
-   using R+REG.  R will go in an address reg and indexing will be used.
-   However, if REG is a broken-out memory address or multiplication,
-   nothing needs to be done because REG can certainly go in an address reg.  */
-#define COPY_ONCE(Y) if (!copied) { Y = copy_rtx (Y); copied = ch = 1; }
-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   \
-{ register int ch = (X) != (OLDX);					\
-  if (GET_CODE (X) == PLUS)						\
-    { int copied = 0;							\
-      if (GET_CODE (XEXP (X, 0)) == MULT)				\
-	{ COPY_ONCE (X); XEXP (X, 0) = force_operand (XEXP (X, 0), 0);}	\
-      if (GET_CODE (XEXP (X, 1)) == MULT)				\
-	{ COPY_ONCE (X); XEXP (X, 1) = force_operand (XEXP (X, 1), 0);}	\
-      if (ch && GET_CODE (XEXP (X, 1)) == REG				\
-	  && GET_CODE (XEXP (X, 0)) == REG)				\
-	{ if (TARGET_COLDFIRE_FPU					\
-	      && GET_MODE_CLASS (MODE) == MODE_FLOAT)			\
-	    { COPY_ONCE (X); X = force_operand (X, 0);}			\
-	  goto WIN; }							\
-      if (ch) { GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN); }		\
-      if (GET_CODE (XEXP (X, 0)) == REG					\
-	       || (GET_CODE (XEXP (X, 0)) == SIGN_EXTEND		\
-		   && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG		\
-		   && GET_MODE (XEXP (XEXP (X, 0), 0)) == HImode))	\
-	{ register rtx temp = gen_reg_rtx (Pmode);			\
-	  register rtx val = force_operand (XEXP (X, 1), 0);		\
-	  emit_move_insn (temp, val);					\
-	  COPY_ONCE (X);						\
-	  XEXP (X, 1) = temp;						\
-	  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT \
-	      && GET_CODE (XEXP (X, 0)) == REG)				\
-	    X = force_operand (X, 0);					\
-	  goto WIN; }							\
-      else if (GET_CODE (XEXP (X, 1)) == REG				\
-	       || (GET_CODE (XEXP (X, 1)) == SIGN_EXTEND		\
-		   && GET_CODE (XEXP (XEXP (X, 1), 0)) == REG		\
-		   && GET_MODE (XEXP (XEXP (X, 1), 0)) == HImode))	\
-	{ register rtx temp = gen_reg_rtx (Pmode);			\
-	  register rtx val = force_operand (XEXP (X, 0), 0);		\
-	  emit_move_insn (temp, val);					\
-	  COPY_ONCE (X);						\
-	  XEXP (X, 0) = temp;						\
-	  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT \
-	      && GET_CODE (XEXP (X, 1)) == REG)				\
-	    X = force_operand (X, 0);					\
-	  goto WIN; }}}
+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)		\
+do {							\
+  rtx __x;						\
+  							\
+  __x = m68k_legitimize_address (X, OLDX, MODE);	\
+  if (__x != NULL_RTX)					\
+    {							\
+      X = __x;						\
+							\
+      if (memory_address_p (MODE, X))			\
+	goto WIN;					\
+    }							\
+} while (0)
 
 /* On the 68000, only predecrement and postincrement address depend thus
    (the amount of decrement or increment being the length of the operand).
@@ -1028,6 +1003,9 @@ do { if (cc_prev_status.flags & CC_IN_68881)			\
   assemble_name ((FILE), (NAME)),		\
   fprintf ((FILE), ",%u\n", (int)(ROUNDED)))
 
+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \
+  m68k_final_prescan_insn (INSN, OPVEC, NOPERANDS)
+
 /* On the 68000, we use several CODE characters:
    '.' for dot needed in Motorola-style opcode names.
    '-' for an operand pushing on the stack:
diff --git a/gcc/config/m68k/m68k.md b/gcc/config/m68k/m68k.md
index 68442fd57..addffb6e5 100644
--- a/gcc/config/m68k/m68k.md
+++ b/gcc/config/m68k/m68k.md
@@ -116,7 +116,8 @@
    (UNSPEC_GOT 3)
    (UNSPEC_IB 4)
    (UNSPEC_TIE 5)
-   (UNSPEC_GOTOFF 6)
+   (UNSPEC_RELOC16 6)
+   (UNSPEC_RELOC32 7)
   ])
 
 ;; UNSPEC_VOLATILE usage:
@@ -414,7 +415,7 @@
 
 (define_insn "tst<mode>_cf"
   [(set (cc0)
-	(match_operand:FP 0 "general_operand" "f<FP:dreg><Q>U"))]
+	(match_operand:FP 0 "general_operand" "f<FP:dreg>m"))]
   "TARGET_COLDFIRE_FPU"
 {
   cc_status.flags = CC_IN_68881;
@@ -570,8 +571,8 @@
 
 (define_insn "*cmp<mode>_cf"
   [(set (cc0)
-	(compare (match_operand:FP 0 "fp_src_operand" "f,f,<FP:dreg><Q>U")
-		 (match_operand:FP 1 "fp_src_operand" "f,<FP:dreg><Q>U,f")))]
+	(compare (match_operand:FP 0 "fp_src_operand" "f,f,<FP:dreg>m")
+		 (match_operand:FP 1 "fp_src_operand" "f,<FP:dreg>m,f")))]
   "TARGET_COLDFIRE_FPU
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
@@ -779,7 +780,41 @@
 {
   rtx tmp, base, offset;
 
-  if (flag_pic && !TARGET_PCREL && symbolic_operand (operands[1], SImode))
+  /* Recognize the case where operand[1] is a reference to thread-local
+     data and load its address to a register.  */
+  if (!TARGET_PCREL && m68k_tls_reference_p (operands[1], false))
+    {
+      rtx tmp = operands[1];
+      rtx addend = NULL;
+
+      if (GET_CODE (tmp) == CONST && GET_CODE (XEXP (tmp, 0)) == PLUS)
+        {
+          addend = XEXP (XEXP (tmp, 0), 1);
+          tmp = XEXP (XEXP (tmp, 0), 0);
+        }
+
+      gcc_assert (GET_CODE (tmp) == SYMBOL_REF);
+      gcc_assert (SYMBOL_REF_TLS_MODEL (tmp) != 0);
+
+      tmp = m68k_legitimize_tls_address (tmp);
+
+      if (addend)
+        {
+	  if (!REG_P (tmp))
+	    {
+	      rtx reg;
+
+	      reg = gen_reg_rtx (Pmode);
+	      emit_move_insn (reg, tmp);
+	      tmp = reg;
+	    }
+
+          tmp = gen_rtx_PLUS (SImode, tmp, addend);
+	}
+
+      operands[1] = tmp;
+    }
+  else if (flag_pic && !TARGET_PCREL && symbolic_operand (operands[1], SImode))
     {
       /* The source is an address which requires PIC relocation.
          Call legitimize_pic_address with the source, mode, and a relocation
@@ -1070,10 +1105,8 @@
 ;; SFmode MEMs are restricted to modes 2-4 if TARGET_COLDFIRE_FPU.
 ;; The move instructions can handle all combinations.
 (define_insn "movsf_cf_hard"
-  [(set (match_operand:SF 0 "nonimmediate_operand" "=r<Q>U, f,    f,mr,f,r<Q>,f
-,m")
-        (match_operand:SF 1 "general_operand"      " f,     r<Q>U,f,rm,F,F,   m
-,f"))]
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=rm,f, f,rm,f,r<Q>,f,m")
+        (match_operand:SF 1 "general_operand"      " f, rm,f,rm,F,F,   m,f"))]
   "TARGET_COLDFIRE_FPU"
 {
   if (which_alternative == 4 || which_alternative == 5) {
@@ -1215,8 +1248,8 @@
 })
 
 (define_insn "movdf_cf_hard"
-  [(set (match_operand:DF 0 "nonimmediate_operand" "=f,    <Q>U,r,f,r,r,m,f")
-        (match_operand:DF 1 "general_operand"      " f<Q>U,f,   f,r,r,m,r,E"))]
+  [(set (match_operand:DF 0 "nonimmediate_operand" "=f, m,r,f,r,r,m,f")
+        (match_operand:DF 1 "general_operand"      " fm,f,f,r,r,m,r,E"))]
   "TARGET_COLDFIRE_FPU"
 {
   rtx xoperands[3];
@@ -1857,7 +1890,7 @@
 (define_insn "extendsfdf2_cf"
   [(set (match_operand:DF 0 "nonimmediate_operand" "=f,f")
 	(float_extend:DF
-	 (match_operand:SF 1 "general_operand" "f,<Q>U")))]
+	 (match_operand:SF 1 "general_operand" "f,m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[0]) && FP_REG_P (operands[1]))
@@ -1897,9 +1930,9 @@
 })
 
 (define_insn "truncdfsf2_cf"
-  [(set (match_operand:SF 0 "nonimmediate_operand" "=f,d<Q>U")
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=f,dm")
 	(float_truncate:SF
-	  (match_operand:DF 1 "general_operand" "<Q>U,f")))]
+	  (match_operand:DF 1 "general_operand" "m,f")))]
   "TARGET_COLDFIRE_FPU"
   "@
   fsmove%.d %1,%0
@@ -2045,7 +2078,7 @@
 
 (define_insn "ftrunc<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
-        (fix:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U")))]
+        (fix:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[1]))
@@ -2338,9 +2371,9 @@
   "* return output_addsi3 (operands);")
 
 (define_insn_and_split "*addsi3_5200"
-  [(set (match_operand:SI 0 "nonimmediate_operand"         "=mr,mr,a,m,r,  ?a, ?a,?a,?a")
-	(plus:SI (match_operand:SI 1 "general_operand"     "%0, 0, 0,0,0,   a,  a, r, a")
-		 (match_operand:SI 2 "general_src_operand" " I, L, J,d,mrKi,Cj, r, a, J")))]
+  [(set (match_operand:SI 0 "nonimmediate_operand"         "=mr,mr,a,  m,r,  ?a, ?a,?a,?a")
+	(plus:SI (match_operand:SI 1 "general_operand"     "%0, 0, 0,  0,0,   a,  a, r, a")
+		 (match_operand:SI 2 "general_src_operand" " I, L, JCu,d,mrKi,Cj, r, a, JCu")))]
   "TARGET_COLDFIRE"
 {
   switch (which_alternative)
@@ -2382,9 +2415,9 @@
 	(plus:SI (match_dup 0)
 		 (match_dup 1)))]
   ""
-  [(set_attr "type" "aluq_l,aluq_l,lea,alu_l,alu_l,*,lea,lea,lea")
-   (set_attr "opy" "2,2,*,2,2,*,*,*,*")
-   (set_attr "opy_type" "*,*,mem5,*,*,*,mem6,mem6,mem5")])
+  [(set_attr "type"     "aluq_l,aluq_l,lea, alu_l,alu_l,*,lea, lea, lea")
+   (set_attr "opy"      "2,     2,     *,   2,    2,    *,*,   *,   *")
+   (set_attr "opy_type" "*,     *,     mem5,*,    *,    *,mem6,mem6,mem5")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=a")
@@ -2666,7 +2699,7 @@
 (define_insn "add<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
 	(plus:FP (match_operand:FP 1 "general_operand" "%0")
-		 (match_operand:FP 2 "general_operand" "f<FP:dreg><Q>U")))]
+		 (match_operand:FP 2 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -2889,7 +2922,7 @@
 (define_insn "sub<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
         (minus:FP (match_operand:FP 1 "general_operand" "0")
-                  (match_operand:FP 2 "general_operand" "f<FP:dreg><Q>U")))]
+                  (match_operand:FP 2 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -3245,7 +3278,7 @@
 (define_insn "fmul<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
 	(mult:FP (match_operand:FP 1 "general_operand" "%0")
-		 (match_operand:FP 2 "general_operand" "f<Q>U<FP:dreg>")))]
+		 (match_operand:FP 2 "general_operand" "fm<FP:dreg>")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -3315,7 +3348,7 @@
 (define_insn "div<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
 	(div:FP (match_operand:FP 1 "general_operand" "0")
-		(match_operand:FP 2 "general_operand" "f<Q>U<FP:dreg>")))]
+		(match_operand:FP 2 "general_operand" "fm<FP:dreg>")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -4163,7 +4196,7 @@
 
 (define_insn "neg<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f,d")
-	(neg:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U,0")))]
+	(neg:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m,0")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (DATA_REG_P (operands[0]))
@@ -4197,7 +4230,7 @@
 
 (define_insn "sqrt<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
-	(sqrt:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U")))]
+	(sqrt:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[1]))
@@ -4316,7 +4349,7 @@
 
 (define_insn "abs<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f,d")
-	(abs:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U,0")))]
+	(abs:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m,0")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (DATA_REG_P (operands[0]))
diff --git a/gcc/config/m68k/m68k.opt b/gcc/config/m68k/m68k.opt
index b0d3b3c0d..d5aa9fa76 100644
--- a/gcc/config/m68k/m68k.opt
+++ b/gcc/config/m68k/m68k.opt
@@ -182,3 +182,7 @@ Tune for the specified target CPU or architecture
 mxgot
 Target Report Mask(XGOT)
 Support more than 8192 GOT entries on ColdFire
+
+mxtls
+Target Report Mask(XTLS)
+Support TLS segment larger than 64K
diff --git a/gcc/config/m68k/predicates.md b/gcc/config/m68k/predicates.md
index b43e55b89..229a13ae5 100644
--- a/gcc/config/m68k/predicates.md
+++ b/gcc/config/m68k/predicates.md
@@ -130,7 +130,9 @@
   (match_code "sign_extend,zero_extend"))
 
 ;; Returns true if OP is either a symbol reference or a sum of a
-;; symbol reference and a constant.
+;; symbol reference and a constant.  This predicate is for "raw"
+;; symbol references not yet processed by legitimize*_address,
+;; hence we do not handle UNSPEC_{XGOT, TLS, XTLS} here.
 
 (define_predicate "symbolic_operand"
   (match_code "symbol_ref,label_ref,const")
diff --git a/gcc/config/m68k/t-uclinux b/gcc/config/m68k/t-uclinux
index f86067233..fd1807603 100644
--- a/gcc/config/m68k/t-uclinux
+++ b/gcc/config/m68k/t-uclinux
@@ -1,8 +1,8 @@
 # crti and crtn are provided by uClibc.
 EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o
 
-# Only include multilibs for the 68020 and for CPUs without an MMU.
-M68K_MLIB_CPU += && (MLIB == "68020" || !match(FLAGS, "FL_MMU"))
+# Include multilibs for CPUs without an MMU or with FL_UCLINUX
+M68K_MLIB_CPU += && (!match(FLAGS, "FL_MMU") || match(FLAGS, "FL_UCLINUX"))
 
 # Add multilibs for execute-in-place and shared-library code.
 M68K_MLIB_OPTIONS += msep-data/mid-shared-library
diff --git a/gcc/config/m68k/uclinux.h b/gcc/config/m68k/uclinux.h
index 835c4433b..a33d39b8e 100644
--- a/gcc/config/m68k/uclinux.h
+++ b/gcc/config/m68k/uclinux.h
@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see
    profiling, or libg.a.  */
 #undef LIB_SPEC
 #define LIB_SPEC \
-"%{mid-shared-library:%{!static-libc:-R libc.gdb%s}} -lc"
+"%{mid-shared-library:%{!static-libc:-R libc.gdb%s}} %{pthread:-lpthread} -lc"
 
 /* Default to using -elf2flt with no options.  */
 #undef LINK_SPEC
diff --git a/gcc/config/mips/74k.md b/gcc/config/mips/74k.md
index b75bfc4b9..92792e775 100644
--- a/gcc/config/mips/74k.md
+++ b/gcc/config/mips/74k.md
@@ -118,8 +118,7 @@
 ;; stores
 (define_insn_reservation "r74k_int_store" 1
   (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
-       (and (eq_attr "type" "store")
-            (eq_attr "mode" "!unknown")))
+       (eq_attr "type" "store"))
   "r74k_agen")
 
 
@@ -145,33 +144,123 @@
 ;; load->load base:  4 cycles
 ;; load->store base: 4 cycles
 (define_bypass 4 "r74k_int_load" "r74k_int_load")
-(define_bypass 4 "r74k_int_load" "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 4 "r74k_int_load" "r74k_int_store" "!mips_store_data_bypass_p")
 
 ;; logical/move/slt/signext->next use :  1 cycles (Default)
 ;; logical/move/slt/signext->load base:  2 cycles
 ;; logical/move/slt/signext->store base: 2 cycles
 (define_bypass 2 "r74k_int_logical" "r74k_int_load")
-(define_bypass 2 "r74k_int_logical" "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 2 "r74k_int_logical" "r74k_int_store"
+  "!mips_store_data_bypass_p")
 
 ;; arith->next use :  2 cycles (Default)
 ;; arith->load base:  3 cycles
 ;; arith->store base: 3 cycles
 (define_bypass 3 "r74k_int_arith" "r74k_int_load")
-(define_bypass 3 "r74k_int_arith" "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 3 "r74k_int_arith" "r74k_int_store" "!mips_store_data_bypass_p")
 
 ;; cmove->next use :  4 cycles (Default)
 ;; cmove->load base:  5 cycles
 ;; cmove->store base: 5 cycles
 (define_bypass 5 "r74k_int_cmove"  "r74k_int_load")
-(define_bypass 5 "r74k_int_cmove"  "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 5 "r74k_int_cmove"  "r74k_int_store"
+  "!mips_store_data_bypass_p")
 
 ;; mult/madd/msub->int_mfhilo  : 4 cycles (default)
 ;; mult->madd/msub             : 1 cycles
 ;; madd/msub->madd/msub        : 1 cycles
-(define_bypass 1 "r74k_int_mult,r74k_int_mul3" "r74k_int_madd"
-  "mips_linked_madd_p")
-(define_bypass 1 "r74k_int_madd" "r74k_int_madd"
-  "mips_linked_madd_p")
+(define_bypass 1 "r74k_int_mult" "r74k_int_madd")
+(define_bypass 1 "r74k_int_madd" "r74k_int_madd")
+
+(define_bypass 1 "r74k_int_mul3" "r74k_int_madd"
+  "mips_mult_madd_chain_bypass_p")
+
+
+;; --------------------------------------------------------------
+;; DSP instructins
+;; --------------------------------------------------------------
+
+;; Non-saturating insn have the same latency as normal ALU operations,
+(define_insn_reservation "r74k_dsp_alu" 2
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspalu"))
+  "r74k_alu")
+
+;; Saturating insn takes an extra cycle.
+(define_insn_reservation "r74k_dsp_alu_sat" 3
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspalusat"))
+  "r74k_alu")
+
+;; dpaq_s, dpau, dpsq_s, dpsu, maq_s, mulsaq
+;; - delivers result to hi/lo in 6 cycle (bypass at M4)
+(define_insn_reservation "r74k_dsp_mac" 6
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspmac"))
+  "r74k_alu+r74k_mul")
+
+;; dpaq_sa, dpsq_sa, maq_sa
+;; - delivers result to hi/lo in 7 cycle (bypass at WB)
+(define_insn_reservation "r74k_dsp_mac_sat" 7
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspmacsat"))
+  "r74k_alu+r74k_mul")
+
+;; extp, extpdp, extpdpv, extpv, extr, extrv
+;; - same latency as "mul"
+(define_insn_reservation "r74k_dsp_acc_ext" 7
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "accext"))
+  "r74k_alu+r74k_mul")
+
+;; mthlip, shilo, shilov
+;; - same latency as "mul"
+(define_insn_reservation "r74k_dsp_acc_mod" 7
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "accmod"))
+  "r74k_alu+r74k_mul")
+
+;; dspalu   ->load/store base
+;; dspalusat->load/store base
+;; - we should never see these in real life.
+
+;; dsp_mac->dsp_mac     : 1 cycles (repeat rate of 1)
+;; dsp_mac->dsp_mac_sat : 1 cycles (repeat rate of 1)
+(define_bypass 1 "r74k_dsp_mac" "r74k_dsp_mac")
+(define_bypass 1 "r74k_dsp_mac" "r74k_dsp_mac_sat")
+
+;; dsp_mac_sat->dsp_mac_sat : 2 cycles (repeat rate of 2)
+;; dsp_mac_sat->dsp_mac     : 2 cycles (repeat rate of 2)
+(define_bypass 2 "r74k_dsp_mac_sat" "r74k_dsp_mac_sat")
+(define_bypass 2 "r74k_dsp_mac_sat" "r74k_dsp_mac")
+
+(define_bypass 1 "r74k_int_mult" "r74k_dsp_mac")
+(define_bypass 1 "r74k_int_mult" "r74k_dsp_mac_sat")
+
+;; Before reload, all multiplier is registered as imul3 (which has a long
+;;  latency).  We temporary jig the latency such that the macc groups
+;;  are scheduled closely together during the first scheduler pass.
+(define_bypass 1 "r74k_int_mul3" "r74k_dsp_mac"
+  "mips_mult_madd_chain_bypass_p")
+(define_bypass 1 "r74k_int_mul3" "r74k_dsp_mac_sat"
+  "mips_mult_madd_chain_bypass_p")
+
+;; Assuming the following is true (bypass at M4)
+;;  AP AF AM MB M1 M2 M3 M4 WB GR GC
+;;              AP AF AM MB M1 M2 M3 M4 WB GR GC
+;; dsp_mac->dsp_acc_ext : 4 cycles
+;; dsp_mac->dsp_acc_mod : 4 cycles
+(define_bypass 4 "r74k_dsp_mac" "r74k_dsp_acc_ext")
+(define_bypass 4 "r74k_dsp_mac" "r74k_dsp_acc_mod")
+
+;; Assuming the following is true (bypass at WB)
+;;  AP AF AM MB M1 M2 M3 M4 WB GR GC
+;;                 AP AF AM MB M1 M2 M3 M4 WB GR GC
+;; dsp_mac_sat->dsp_acc_ext : 5 cycles
+;; dsp_mac_sat->dsp_acc_mod : 5 cycles
+(define_bypass 5 "r74k_dsp_mac_sat" "r74k_dsp_acc_ext")
+(define_bypass 5 "r74k_dsp_mac_sat" "r74k_dsp_acc_mod")
+
 
 ;; --------------------------------------------------------------
 ;; Floating Point Instructions
diff --git a/gcc/config/mips/constraints.md b/gcc/config/mips/constraints.md
index a74985507..3d6c03c11 100644
--- a/gcc/config/mips/constraints.md
+++ b/gcc/config/mips/constraints.md
@@ -162,7 +162,7 @@
 (define_memory_constraint "R"
   "An address that can be used in a non-macro load or store."
   (and (match_code "mem")
-       (match_test "mips_address_insns (XEXP (op, 0), mode, false) == 1")))
+       (match_test "mips_address_insns (XEXP (op, 0), mode, false, false) == 1")))
 
 (define_constraint "S"
   "@internal
@@ -215,3 +215,13 @@
    A signed 10-bit constant."
   (and (match_code "const_int")
        (match_test "IMM10_OPERAND (ival)")))
+
+(define_memory_constraint "YC"
+  "For MIPS, it is the same as the constraint R.  For microMIPS, it matches an address within a 12-bit offset that can be used in ll, sc, etc."
+  (and (match_code "mem")
+       (match_test "mips_address_insns (XEXP (op, 0), mode, false, true) == 1")))
+
+(define_address_constraint "YD"
+  "@internal
+   For MIPS, it is the same as the constraint p.  For microMIPS, it matches a 12-bit offset address."
+  (match_test "mips_address_insns (op, mode, false, true) == 1"))
diff --git a/gcc/config/mips/crtfastmath.c b/gcc/config/mips/crtfastmath.c
new file mode 100644
index 000000000..9401ed4b0
--- /dev/null
+++ b/gcc/config/mips/crtfastmath.c
@@ -0,0 +1,53 @@
+/* Copyright (C) 2008, 2009 Free Software Foundation, Inc. 
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License
+   and a copy of the GCC Runtime Library Exception along with this
+   program; see the files COPYING3 and COPYING.RUNTIME respectively.
+   If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifdef __mips_hard_float
+
+/* flush denormalized numbers to zero */
+#define _FPU_FLUSH_TZ   0x1000000
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x0     /* RECOMMENDED */
+#define _FPU_RC_ZERO    0x1
+#define _FPU_RC_UP      0x2
+#define _FPU_RC_DOWN    0x3
+
+/* enable interrupts for IEEE exceptions */
+#define _FPU_IEEE     0x00000F80
+
+/* Macros for accessing the hardware control word.  */
+#define _FPU_GETCW(cw) __asm__ ("cfc1 %0,$31" : "=r" (cw))
+#define _FPU_SETCW(cw) __asm__ ("ctc1 %0,$31" : : "r" (cw))
+
+static void __attribute__((constructor))
+set_fast_math (void)
+{
+  unsigned int fcr;
+
+  /* fastmath: flush to zero, round to nearest, ieee exceptions disabled */
+  fcr = _FPU_FLUSH_TZ | _FPU_RC_NEAREST;
+
+  _FPU_SETCW(fcr);
+}
+
+#endif /* __mips_hard_float */
diff --git a/gcc/config/mips/crtn.asm b/gcc/config/mips/crtn.asm
index 5d41d3d7e..afbaeb60c 100644
--- a/gcc/config/mips/crtn.asm
+++ b/gcc/config/mips/crtn.asm
@@ -8,6 +8,7 @@
 #endif
 
 	.section .init,"ax",@progbits
+init:	
 #ifdef __mips64
 	ld      RA,40($sp)
 	daddu	$sp,$sp,48
@@ -18,6 +19,7 @@
 	j	RA
 
 	.section .fini,"ax",@progbits
+fini:	
 #ifdef	__mips64
 	ld	RA,40($sp)
 	daddu	$sp,$sp,48
diff --git a/gcc/config/mips/cs-sgxx-linux.h b/gcc/config/mips/cs-sgxx-linux.h
new file mode 100644
index 000000000..1329a9e40
--- /dev/null
+++ b/gcc/config/mips/cs-sgxx-linux.h
@@ -0,0 +1,45 @@
+/* MIPS SourceryG++ GNU/Linux Configuration.
+   Copyright (C) 2008
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* We do not need to provide an explicit big-endian multilib.  */
+#undef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS \
+  { "EB" }
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+"%{muclibc:/uclibc}\
+%{mmicromips:/micromips;\
+mips2|mips3|mips4|march=mips2|march=mips3|march=mips4|march=r6000|\
+march=r4000|march=vr4100|march=vr4111|march=vr4120|march=vr4130|\
+march=vr4300|march=r4400|march=r4600|march=orion|march=r4650|\
+march=loongson2e|march=loongson2f|march=r8000|march=r10000|\
+march=r12000|march=r14000|march=r16000|\
+march=vr5000|march=vr5400|march=vr5500|march=rm7000|\
+march=rm9000:/mips2;\
+mips32|march=mips32|march=4kc|march=4km|march=4kp|march=4ksc|\
+mips64|march=mips64|march=5kc|march=5kf|march=20kc|march=sb1|march=sb1a|\
+march=sr71000|march=xlr:/mips32}\
+%{msoft-float:/soft-float}%{mel|EL:/el}"
+
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC \
+  "%{muclibc:/uclibc}"
diff --git a/gcc/config/mips/cs-sgxxlite-linux.h b/gcc/config/mips/cs-sgxxlite-linux.h
new file mode 100644
index 000000000..a0a020872
--- /dev/null
+++ b/gcc/config/mips/cs-sgxxlite-linux.h
@@ -0,0 +1,33 @@
+/* MIPS SourceryG++ GNU/Linux Configuration.
+   Copyright (C) 2008
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* We do not need to provide an explicit big-endian multilib.  */
+#undef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS \
+  { "EB" }
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC \
+"%{muclibc:/uclibc}%{mmicromips:/micromips}%{msoft-float:/soft-float}%{mel|EL:/el}"
+
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC \
+  "%{muclibc:/uclibc}"
diff --git a/gcc/config/mips/linux-unwind.h b/gcc/config/mips/linux-unwind.h
index 69d96f13d..df74b1104 100644
--- a/gcc/config/mips/linux-unwind.h
+++ b/gcc/config/mips/linux-unwind.h
@@ -51,6 +51,11 @@ mips_fallback_frame_state (struct _Unwind_Context *context,
   _Unwind_Ptr new_cfa, reg_offset;
   int i;
 
+  /* microMIPS frame; the kernel does not have microMIPS signal
+     frames.  */
+  if ((_Unwind_Ptr) pc & 3)
+    return _URC_END_OF_STACK;
+
   /* 24021061 li v0, 0x1061 (rt_sigreturn)*/
   /* 0000000c syscall    */
   /*    or */
diff --git a/gcc/config/mips/linux.h b/gcc/config/mips/linux.h
index 0512ef7d1..2cabf78ef 100644
--- a/gcc/config/mips/linux.h
+++ b/gcc/config/mips/linux.h
@@ -56,7 +56,7 @@ along with GCC; see the file COPYING3.  If not see
    CC1_SPEC itself by config/linux.h, but mips.h overrides CC1_SPEC
    and provides this hook instead.  */
 #undef SUBTARGET_CC1_SPEC
-#define SUBTARGET_CC1_SPEC "%{profile:-p}"
+#define SUBTARGET_CC1_SPEC "%{profile:-p} %{!mjals:-mno-jals}"
 
 /* From iris5.h */
 /* -G is incompatible with -KPIC which is the default, so only allow objects
@@ -147,3 +147,19 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);
 #define DRIVER_SELF_SPECS \
   BASE_DRIVER_SELF_SPECS, \
   LINUX_DRIVER_SELF_SPECS
+
+/* Similar to standard Linux, but adding -ffast-math support.  */
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
+   %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS                                      \
+do {                                                                    \
+  /* microMIPS PLT entries are non-microMIPS.  */			\
+  TARGET_INTERLINK_MIPS16 = 1;						\
+  /* __thread_support is not supported by uClibc.  */                   \
+  if (linux_uclibc)                                             \
+    targetm.have_tls = 0;                                               \
+} while (0)
diff --git a/gcc/config/mips/linux64.h b/gcc/config/mips/linux64.h
index 2f24dfa14..fe804fc5a 100644
--- a/gcc/config/mips/linux64.h
+++ b/gcc/config/mips/linux64.h
@@ -69,3 +69,9 @@ along with GCC; see the file COPYING3.  If not see
    ieee_quad_format is the default, but let's put this here to make
    sure nobody thinks we just forgot to set it to something else.  */
 #define MIPS_TFMODE_FORMAT mips_quad_format
+
+/* Similar to standard Linux, but adding -ffast-math support.  */
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
+   %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
diff --git a/gcc/config/mips/micromips.md b/gcc/config/mips/micromips.md
new file mode 100644
index 000000000..d565fc13a
--- /dev/null
+++ b/gcc/config/mips/micromips.md
@@ -0,0 +1,275 @@
+(define_insn "*store_word_multiple"
+  [(match_parallel 0 ""
+       [(set (match_operand:SI 1 "memory_operand")
+	     (match_operand:SI 2 "register_operand"))])]
+  "TARGET_MICROMIPS
+   && micromips_save_restore_pattern_p (true, operands[0])"
+  { return micromips_output_save_restore (true, operands[0]); }
+  [(set_attr "type"	"multimem")
+   (set_attr "can_delay" "no")
+   (set_attr "mode"	"SI")])
+
+(define_insn "*load_word_multiple"
+  [(match_parallel 0 ""
+       [(set (match_operand:SI 1 "register_operand")
+	     (match_operand:SI 2 "memory_operand"))])]
+  "TARGET_MICROMIPS
+   && micromips_save_restore_pattern_p (false, operands[0])"
+  { return micromips_output_save_restore (false, operands[0]); }
+  [(set_attr "type"	"multimem")
+   (set_attr "can_delay" "no")
+   (set_attr "mode"	"SI")])
+
+; For lwp
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (match_operand:SI 1 "memory_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+        (match_operand:SI 3 "memory_operand" ""))]
+  "TARGET_MICROMIPS
+   && REGNO (operands[0]) <= GP_REG_LAST
+   && REGNO (operands[2]) <= GP_REG_LAST
+   && ((REGNO (operands[0]) + 1 == REGNO (operands[2])
+	&& micromips_load_store_pair_p (true, false, operands[0], operands[1], operands[3]))
+       || (REGNO (operands[2]) + 1 == REGNO (operands[0])
+	   && micromips_load_store_pair_p (true, true, operands[2], operands[3], operands[1])))"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+              (set (match_dup 2) (match_dup 3))])]
+)
+
+(define_insn "*lwp"
+  [(parallel [(set (match_operand:SI 0 "register_operand")
+		   (match_operand:SI 1 "memory_operand"))
+	      (set (match_operand:SI 2 "register_operand")
+		   (match_operand:SI 3 "memory_operand"))])]
+
+  "TARGET_MICROMIPS
+   && REGNO (operands[0]) <= GP_REG_LAST
+   && REGNO (operands[2]) <= GP_REG_LAST
+   && ((REGNO (operands[0]) + 1 == REGNO (operands[2])
+	&& micromips_load_store_pair_p (true, false, operands[0], operands[1], operands[3]))
+       || (REGNO (operands[2]) + 1 == REGNO (operands[0])
+	   && micromips_load_store_pair_p (true, true, operands[2], operands[3], operands[1])))"
+  {
+    if (REGNO (operands[0]) + 1 == REGNO (operands[2]))
+      micromips_output_load_store_pair (true, operands[0], operands[1]);
+    else
+      micromips_output_load_store_pair (true, operands[2], operands[3]);
+  }
+  [(set_attr "type"	"load")
+   (set_attr "can_delay" "no")
+   (set_attr "mode"	"SI")])
+
+; For swp
+(define_peephole2
+  [(set (match_operand:SI 0 "memory_operand" "")
+        (match_operand:SI 1 "register_operand" ""))
+   (set (match_operand:SI 2 "memory_operand" "")
+        (match_operand:SI 3 "register_operand" ""))]
+  "TARGET_MICROMIPS
+   && REGNO (operands[1]) <= GP_REG_LAST
+   && REGNO (operands[3]) <= GP_REG_LAST
+   && ((REGNO (operands[1]) + 1 == REGNO (operands[3])
+	&& micromips_load_store_pair_p (false, false, operands[1], operands[0], operands[2]))
+       || (REGNO (operands[3]) + 1 == REGNO (operands[1])
+	   && micromips_load_store_pair_p (false, true, operands[3], operands[2], operands[0])))"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+              (set (match_dup 2) (match_dup 3))])]
+)
+
+(define_insn "*swp"
+  [(parallel [(set (match_operand:SI 0 "memory_operand")
+		   (match_operand:SI 1 "register_operand"))
+	      (set (match_operand:SI 2 "memory_operand")
+		   (match_operand:SI 3 "register_operand"))])]
+
+  "TARGET_MICROMIPS
+   && REGNO (operands[1]) <= GP_REG_LAST
+   && REGNO (operands[3]) <= GP_REG_LAST
+   && ((REGNO (operands[1]) + 1 == REGNO (operands[3])
+	&& micromips_load_store_pair_p (false, false, operands[1], operands[0], operands[2]))
+       || (REGNO (operands[3]) + 1 == REGNO (operands[1])
+	   && micromips_load_store_pair_p (false, true, operands[3], operands[2], operands[0])))"
+  {
+    if (REGNO (operands[1]) + 1 == REGNO (operands[3]))
+      micromips_output_load_store_pair (false, operands[1], operands[0]);
+    else
+      micromips_output_load_store_pair (false, operands[3], operands[2]);
+  }
+  [(set_attr "type"	"store")
+   (set_attr "can_delay" "no")
+   (set_attr "mode"	"SI")])
+
+; For jraddiusp
+(define_insn "mips_jraddiusp"
+  [(parallel [(return)
+              (use (reg:SI 31))
+	      (set (reg:SI 29)
+		   (plus:SI (reg:SI 29)
+			    (match_operand 0 "const_int_operand")))])]
+  "TARGET_MICROMIPS"
+  "jraddiusp\t%0"
+  [(set_attr "type"	"trap")
+   (set_attr "can_delay" "no")
+   (set_attr "mode"	"SI")])
+
+; For movep
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (match_operand:SI 1 "reg_or_0_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+        (match_operand:SI 3 "reg_or_0_operand" ""))]
+  "TARGET_MICROMIPS
+   && micromips_movep_target_p (operands[0], operands[2])
+   && (operands[1] == CONST0_RTX (SImode)
+       || REGNO (operands[1]) == 0
+       || REGNO (operands[1]) == 2
+       || REGNO (operands[1]) == 3
+       || (REGNO (operands[1]) >= 16 && REGNO (operands[1]) <= 20))
+   && (operands[3] == CONST0_RTX (SImode)
+       || REGNO (operands[3]) == 0
+       || REGNO (operands[3]) == 2
+       || REGNO (operands[3]) == 3
+       || (REGNO (operands[3]) >= 16 && REGNO (operands[3]) <= 20))"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+              (set (match_dup 2) (match_dup 3))])]
+)
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (match_operand:SI 1 "reg_or_0_operand" ""))
+   (set (match_operand:SF 2 "register_operand" "")
+        (match_operand:SF 3 "const_0_operand" ""))]
+  "TARGET_MICROMIPS
+   && micromips_movep_target_p (operands[0], operands[2])
+   && (operands[1] == CONST0_RTX (SImode)
+       || REGNO (operands[1]) == 0
+       || REGNO (operands[1]) == 2
+       || REGNO (operands[1]) == 3
+       || (REGNO (operands[1]) >= 16 && REGNO (operands[1]) <= 20))
+   && operands[3] == CONST0_RTX (SFmode)"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+              (set (match_dup 2) (match_dup 3))])]
+)
+
+(define_peephole2
+  [(set (match_operand:SF 0 "register_operand" "")
+        (match_operand:SF 1 "const_0_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+        (match_operand:SI 3 "reg_or_0_operand" ""))]
+  "TARGET_MICROMIPS
+   && micromips_movep_target_p (operands[0], operands[2])
+   && operands[1] == CONST0_RTX (SFmode)
+   && (operands[3] == CONST0_RTX (SImode)
+       || REGNO (operands[3]) == 0
+       || REGNO (operands[3]) == 2
+       || REGNO (operands[3]) == 3
+       || (REGNO (operands[3]) >= 16 && REGNO (operands[3]) <= 20))"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+              (set (match_dup 2) (match_dup 3))])]
+)
+
+(define_peephole2
+  [(set (match_operand:SF 0 "register_operand" "")
+        (match_operand:SF 1 "const_0_operand" ""))
+   (set (match_operand:SF 2 "register_operand" "")
+        (match_operand:SF 3 "const_0_operand" ""))]
+  "TARGET_MICROMIPS
+   && micromips_movep_target_p (operands[0], operands[2])
+   && operands[1] == CONST0_RTX (SFmode)
+   && operands[3] == CONST0_RTX (SFmode)"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+              (set (match_dup 2) (match_dup 3))])]
+)
+
+(define_insn "*movepsisi"
+  [(parallel [(set (match_operand:SI 0 "register_operand")
+		   (match_operand:SI 1 "reg_or_0_operand"))
+	      (set (match_operand:SI 2 "register_operand")
+		   (match_operand:SI 3 "reg_or_0_operand"))])]
+  "TARGET_MICROMIPS
+   && micromips_movep_target_p (operands[0], operands[2])
+   && (operands[1] == CONST0_RTX (SImode)
+       || REGNO (operands[1]) == 0
+       || REGNO (operands[1]) == 2
+       || REGNO (operands[1]) == 3
+       || (REGNO (operands[1]) >= 16 && REGNO (operands[1]) <= 20))
+   && (operands[3] == CONST0_RTX (SImode)
+       || REGNO (operands[3]) == 0
+       || REGNO (operands[3]) == 2
+       || REGNO (operands[3]) == 3
+       || (REGNO (operands[3]) >= 16 && REGNO (operands[3]) <= 20))"
+{
+  if (REGNO (operands[0]) < REGNO (operands[2]))
+    return "movep\t%0,%2,%z1,%z3";
+  else
+    return "movep\t%2,%0,%z3,%z1";
+}
+  [(set_attr "type"	"move")
+   (set_attr "can_delay" "no")
+   (set_attr "mode"	"SI")])
+
+(define_insn "*movepsisf"
+  [(parallel [(set (match_operand:SI 0 "register_operand")
+		   (match_operand:SI 1 "reg_or_0_operand"))
+	      (set (match_operand:SF 2 "register_operand")
+		   (match_operand:SF 3 "const_0_operand"))])]
+  "TARGET_MICROMIPS
+   && micromips_movep_target_p (operands[0], operands[2])
+   && (operands[1] == CONST0_RTX (SImode)
+       || REGNO (operands[1]) == 0
+       || REGNO (operands[1]) == 2
+       || REGNO (operands[1]) == 3
+       || (REGNO (operands[1]) >= 16 && REGNO (operands[1]) <= 20))
+   && operands[3] == CONST0_RTX (SFmode)"
+{
+  if (REGNO (operands[0]) < REGNO (operands[2]))
+    return "movep\t%0,%2,%z1,%z3";
+  else
+    return "movep\t%2,%0,%z3,%z1";
+}
+  [(set_attr "type"	"move")
+   (set_attr "can_delay" "no")
+   (set_attr "mode"	"SF")])
+
+(define_insn "*movepsfsi"
+  [(parallel [(set (match_operand:SF 0 "register_operand")
+		   (match_operand:SF 1 "const_0_operand"))
+	      (set (match_operand:SI 2 "register_operand")
+		   (match_operand:SI 3 "reg_or_0_operand"))])]
+  "TARGET_MICROMIPS
+   && micromips_movep_target_p (operands[0], operands[2])
+   && operands[1] == CONST0_RTX (SFmode)
+   && (operands[3] == CONST0_RTX (SImode)
+       || REGNO (operands[3]) == 0
+       || REGNO (operands[3]) == 2
+       || REGNO (operands[3]) == 3
+       || (REGNO (operands[3]) >= 16 && REGNO (operands[3]) <= 20))"
+{
+  if (REGNO (operands[0]) < REGNO (operands[2]))
+    return "movep\t%0,%2,%z1,%z3";
+  else
+    return "movep\t%2,%0,%z3,%z1";
+}
+  [(set_attr "type"	"move")
+   (set_attr "can_delay" "no")
+   (set_attr "mode"	"SF")])
+
+(define_insn "*movepsfsf"
+  [(parallel [(set (match_operand:SF 0 "register_operand")
+		   (match_operand:SF 1 "const_0_operand"))
+	      (set (match_operand:SF 2 "register_operand")
+		   (match_operand:SF 3 "const_0_operand"))])]
+  "TARGET_MICROMIPS
+   && micromips_movep_target_p (operands[0], operands[2])
+   && operands[1] == CONST0_RTX (SFmode)
+   && operands[3] == CONST0_RTX (SFmode)"
+{
+  if (REGNO (operands[0]) < REGNO (operands[2]))
+    return "movep\t%0,%2,%z1,%z3";
+  else
+    return "movep\t%2,%0,%z3,%z1";
+}
+  [(set_attr "type"	"move")
+   (set_attr "can_delay" "no")
+   (set_attr "mode"	"SF")])
diff --git a/gcc/config/mips/mips-dsp.md b/gcc/config/mips/mips-dsp.md
index 03dd6e33f..303dd8e1f 100644
--- a/gcc/config/mips/mips-dsp.md
+++ b/gcc/config/mips/mips-dsp.md
@@ -42,9 +42,9 @@
 		     (match_operand:DSPV 2 "register_operand" "d")))
      (set (reg:CCDSP CCDSP_OU_REGNUM)
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDQ))])]
-  ""
+  "ISA_HAS_DSP"
   "add<DSPV:dspfmt1>.<DSPV:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_add<DSP:dspfmt1>_s_<DSP:dspfmt2>"
@@ -55,9 +55,9 @@
 		      UNSPEC_ADDQ_S))
      (set (reg:CCDSP CCDSP_OU_REGNUM)
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDQ_S))])]
-  ""
+  "ISA_HAS_DSP"
   "add<DSP:dspfmt1>_s.<DSP:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; SUBQ*
@@ -70,7 +70,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBQ))])]
   "ISA_HAS_DSP"
   "sub<DSPV:dspfmt1>.<DSPV:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_sub<DSP:dspfmt1>_s_<DSP:dspfmt2>"
@@ -83,7 +83,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBQ_S))])]
   "ISA_HAS_DSP"
   "sub<DSP:dspfmt1>_s.<DSP:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; ADDSC
@@ -97,7 +97,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDSC))])]
   "ISA_HAS_DSP"
   "addsc\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; ADDWC
@@ -112,7 +112,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDWC))])]
   "ISA_HAS_DSP"
   "addwc\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; MODSUB
@@ -123,7 +123,7 @@
 		   UNSPEC_MODSUB))]
   "ISA_HAS_DSP"
   "modsub\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; RADDU*
@@ -133,7 +133,7 @@
 		   UNSPEC_RADDU_W_QB))]
   "ISA_HAS_DSP"
   "raddu.w.qb\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; ABSQ*
@@ -146,7 +146,7 @@
 	  (unspec:CCDSP [(match_dup 1)] UNSPEC_ABSQ_S))])]
   "ISA_HAS_DSP"
   "absq_s.<DSPQ:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; PRECRQ*
@@ -157,7 +157,7 @@
 		     UNSPEC_PRECRQ_QB_PH))]
   "ISA_HAS_DSP"
   "precrq.qb.ph\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precrq_ph_w"
@@ -167,7 +167,7 @@
 		     UNSPEC_PRECRQ_PH_W))]
   "ISA_HAS_DSP"
   "precrq.ph.w\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precrq_rs_ph_w"
@@ -181,7 +181,7 @@
 			UNSPEC_PRECRQ_RS_PH_W))])]
   "ISA_HAS_DSP"
   "precrq_rs.ph.w\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PRECRQU*
@@ -196,7 +196,7 @@
 			UNSPEC_PRECRQU_S_QB_PH))])]
   "ISA_HAS_DSP"
   "precrqu_s.qb.ph\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; PRECEQ*
@@ -206,7 +206,7 @@
 		   UNSPEC_PRECEQ_W_PHL))]
   "ISA_HAS_DSP"
   "preceq.w.phl\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceq_w_phr"
@@ -215,7 +215,7 @@
 		   UNSPEC_PRECEQ_W_PHR))]
   "ISA_HAS_DSP"
   "preceq.w.phr\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PRECEQU*
@@ -225,7 +225,7 @@
 		     UNSPEC_PRECEQU_PH_QBL))]
   "ISA_HAS_DSP"
   "precequ.ph.qbl\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precequ_ph_qbr"
@@ -234,7 +234,7 @@
 		     UNSPEC_PRECEQU_PH_QBR))]
   "ISA_HAS_DSP"
   "precequ.ph.qbr\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precequ_ph_qbla"
@@ -243,7 +243,7 @@
 		     UNSPEC_PRECEQU_PH_QBLA))]
   "ISA_HAS_DSP"
   "precequ.ph.qbla\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precequ_ph_qbra"
@@ -252,7 +252,7 @@
 		     UNSPEC_PRECEQU_PH_QBRA))]
   "ISA_HAS_DSP"
   "precequ.ph.qbra\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PRECEU*
@@ -262,7 +262,7 @@
 		     UNSPEC_PRECEU_PH_QBL))]
   "ISA_HAS_DSP"
   "preceu.ph.qbl\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceu_ph_qbr"
@@ -271,7 +271,7 @@
 		     UNSPEC_PRECEU_PH_QBR))]
   "ISA_HAS_DSP"
   "preceu.ph.qbr\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceu_ph_qbla"
@@ -280,7 +280,7 @@
 		     UNSPEC_PRECEU_PH_QBLA))]
   "ISA_HAS_DSP"
   "preceu.ph.qbla\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceu_ph_qbra"
@@ -289,7 +289,7 @@
 		     UNSPEC_PRECEU_PH_QBRA))]
   "ISA_HAS_DSP"
   "preceu.ph.qbra\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-2. MIPS DSP ASE Instructions: Shift
@@ -313,7 +313,7 @@
     }
   return "shllv.<DSPV:dspfmt2>\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shll_s_<DSPQ:dspfmt2>"
@@ -335,7 +335,7 @@
     }
   return "shllv_s.<DSPQ:dspfmt2>\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; SHRL*
@@ -354,7 +354,7 @@
     }
   return "shrlv.qb\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; SHRA*
@@ -373,7 +373,7 @@
     }
   return "shrav.ph\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shra_r_<DSPQ:dspfmt2>"
@@ -392,7 +392,7 @@
     }
   return "shrav_r.<DSPQ:dspfmt2>\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-3. MIPS DSP ASE Instructions: Multiply
@@ -478,7 +478,7 @@
 		   UNSPEC_DPAU_H_QBL))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpau.h.qbl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpau_h_qbr"
@@ -489,7 +489,7 @@
 		   UNSPEC_DPAU_H_QBR))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpau.h.qbr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPSU*
@@ -501,7 +501,7 @@
 		   UNSPEC_DPSU_H_QBL))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsu.h.qbl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsu_h_qbr"
@@ -512,7 +512,7 @@
 		   UNSPEC_DPSU_H_QBR))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsu.h.qbr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPAQ*
@@ -528,7 +528,7 @@
 			UNSPEC_DPAQ_S_W_PH))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpaq_s.w.ph\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPSQ*
@@ -544,7 +544,7 @@
 			UNSPEC_DPSQ_S_W_PH))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsq_s.w.ph\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; MULSAQ*
@@ -560,7 +560,7 @@
 			UNSPEC_MULSAQ_S_W_PH))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "mulsaq_s.w.ph\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPAQ*
@@ -576,7 +576,7 @@
 			UNSPEC_DPAQ_SA_L_W))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpaq_sa.l.w\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 ;; DPSQ*
@@ -592,7 +592,7 @@
 			UNSPEC_DPSQ_SA_L_W))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsq_sa.l.w\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 ;; MAQ*
@@ -608,7 +608,7 @@
 			UNSPEC_MAQ_S_W_PHL))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_s.w.phl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_maq_s_w_phr"
@@ -623,7 +623,7 @@
 			UNSPEC_MAQ_S_W_PHR))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_s.w.phr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; MAQ_SA*
@@ -639,7 +639,7 @@
 			UNSPEC_MAQ_SA_W_PHL))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_sa.w.phl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_maq_sa_w_phr"
@@ -654,7 +654,7 @@
 			UNSPEC_MAQ_SA_W_PHR))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_sa.w.phr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-4. MIPS DSP ASE Instructions: General Bit/Manipulation
@@ -665,7 +665,7 @@
 		   UNSPEC_BITREV))]
   "ISA_HAS_DSP"
   "bitrev\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; INSV
@@ -678,7 +678,7 @@
 		   UNSPEC_INSV))]
   "ISA_HAS_DSP"
   "insv\t%0,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; REPL*
@@ -696,7 +696,7 @@
     }
   return "replv.qb\t%0,%1";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_repl_ph"
@@ -707,7 +707,7 @@
   "@
    repl.ph\t%0,%1
    replv.ph\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-5. MIPS DSP ASE Instructions: Compare-Pick
@@ -720,7 +720,7 @@
 		      UNSPEC_CMP_EQ))]
   "ISA_HAS_DSP"
   "cmp<DSPV:dspfmt1_1>.eq.<DSPV:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmp<DSPV:dspfmt1_1>_lt_<DSPV:dspfmt2>"
@@ -731,7 +731,7 @@
 		      UNSPEC_CMP_LT))]
   "ISA_HAS_DSP"
   "cmp<DSPV:dspfmt1_1>.lt.<DSPV:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmp<DSPV:dspfmt1_1>_le_<DSPV:dspfmt2>"
@@ -742,7 +742,7 @@
 		      UNSPEC_CMP_LE))]
   "ISA_HAS_DSP"
   "cmp<DSPV:dspfmt1_1>.le.<DSPV:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgu_eq_qb"
@@ -752,7 +752,7 @@
 		   UNSPEC_CMPGU_EQ_QB))]
   "ISA_HAS_DSP"
   "cmpgu.eq.qb\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgu_lt_qb"
@@ -762,7 +762,7 @@
 		   UNSPEC_CMPGU_LT_QB))]
   "ISA_HAS_DSP"
   "cmpgu.lt.qb\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgu_le_qb"
@@ -772,7 +772,7 @@
 		   UNSPEC_CMPGU_LE_QB))]
   "ISA_HAS_DSP"
   "cmpgu.le.qb\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PICK*
@@ -784,7 +784,7 @@
 		     UNSPEC_PICK))]
   "ISA_HAS_DSP"
   "pick.<DSPV:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PACKRL*
@@ -795,7 +795,7 @@
 		     UNSPEC_PACKRL_PH))]
   "ISA_HAS_DSP"
   "packrl.ph\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-6. MIPS DSP ASE Instructions: Accumulator and DSPControl Access
@@ -818,7 +818,7 @@
     }
   return "extrv.w\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_extr_r_w"
@@ -839,7 +839,7 @@
     }
   return "extrv_r.w\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_extr_rs_w"
@@ -860,7 +860,7 @@
     }
   return "extrv_rs.w\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 ;; EXTR*_S.H
@@ -882,7 +882,7 @@
     }
   return "extrv_s.h\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 ;; EXTP*
@@ -905,7 +905,7 @@
     }
   return "extpv\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_extpdp"
@@ -930,7 +930,7 @@
     }
   return "extpdpv\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 ;; SHILO*
@@ -949,7 +949,7 @@
     }
   return "shilov\t%q0,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accmod")
    (set_attr "mode"	"SI")])
 
 ;; MTHLIP*
@@ -965,7 +965,7 @@
 			 (reg:CCDSP CCDSP_PO_REGNUM)] UNSPEC_MTHLIP))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "mthlip\t%2,%q0"
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accmod")
    (set_attr "mode"	"SI")])
 
 ;; WRDSP
@@ -987,7 +987,7 @@
 	  (unspec:CCDSP [(match_dup 0) (match_dup 1)] UNSPEC_WRDSP))])]
   "ISA_HAS_DSP"
   "wrdsp\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; RDDSP
@@ -1003,7 +1003,7 @@
 		   UNSPEC_RDDSP))]
   "ISA_HAS_DSP"
   "rddsp\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-7. MIPS DSP ASE Instructions: Indexed-Load
diff --git a/gcc/config/mips/mips-dspr2.md b/gcc/config/mips/mips-dspr2.md
index 3cde900b6..d22dc4626 100644
--- a/gcc/config/mips/mips-dspr2.md
+++ b/gcc/config/mips/mips-dspr2.md
@@ -9,7 +9,7 @@
 	  (unspec:CCDSP [(match_dup 1)] UNSPEC_ABSQ_S_QB))])]
   "ISA_HAS_DSPR2"
   "absq_s.qb\t%0,%z1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addu_ph"
@@ -21,7 +21,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDU_PH))])]
   "ISA_HAS_DSPR2"
   "addu.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addu_s_ph"
@@ -34,7 +34,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDU_S_PH))])]
   "ISA_HAS_DSPR2"
   "addu_s.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_adduh_qb"
@@ -44,7 +44,7 @@
 		     UNSPEC_ADDUH_QB))]
   "ISA_HAS_DSPR2"
   "adduh.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_adduh_r_qb"
@@ -54,7 +54,7 @@
 		     UNSPEC_ADDUH_R_QB))]
   "ISA_HAS_DSPR2"
   "adduh_r.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_append"
@@ -69,7 +69,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "append\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_balign"
@@ -84,7 +84,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 3);
   return "balign\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgdu_eq_qb"
@@ -99,7 +99,7 @@
 			UNSPEC_CMPGDU_EQ_QB))])]
   "ISA_HAS_DSPR2"
   "cmpgdu.eq.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgdu_lt_qb"
@@ -114,7 +114,7 @@
 			UNSPEC_CMPGDU_LT_QB))])]
   "ISA_HAS_DSPR2"
   "cmpgdu.lt.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgdu_le_qb"
@@ -129,7 +129,7 @@
 			UNSPEC_CMPGDU_LE_QB))])]
   "ISA_HAS_DSPR2"
   "cmpgdu.le.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpa_w_ph"
@@ -140,7 +140,7 @@
 		   UNSPEC_DPA_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dps_w_ph"
@@ -151,7 +151,7 @@
 		   UNSPEC_DPS_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dps.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_expand "mips_madd<u>"
@@ -247,7 +247,7 @@
 		   UNSPEC_MULSA_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "mulsa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_mult"
@@ -277,7 +277,7 @@
 		     UNSPEC_PRECR_QB_PH))]
   "ISA_HAS_DSPR2"
   "precr.qb.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precr_sra_ph_w"
@@ -292,7 +292,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "precr_sra.ph.w\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precr_sra_r_ph_w"
@@ -307,7 +307,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "precr_sra_r.ph.w\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_prepend"
@@ -322,7 +322,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "prepend\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shra_qb"
@@ -340,7 +340,7 @@
     }
   return "shrav.qb\t%0,%z1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 
@@ -359,7 +359,7 @@
     }
   return "shrav_r.qb\t%0,%z1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shrl_ph"
@@ -377,7 +377,7 @@
     }
   return "shrlv.ph\t%0,%z1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subu_ph"
@@ -390,7 +390,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBU_PH))])]
   "ISA_HAS_DSPR2"
   "subu.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subu_s_ph"
@@ -403,7 +403,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBU_S_PH))])]
   "ISA_HAS_DSPR2"
   "subu_s.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subuh_qb"
@@ -413,7 +413,7 @@
 		     UNSPEC_SUBUH_QB))]
   "ISA_HAS_DSPR2"
   "subuh.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subuh_r_qb"
@@ -423,7 +423,7 @@
 		     UNSPEC_SUBUH_R_QB))]
   "ISA_HAS_DSPR2"
   "subuh_r.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_ph"
@@ -433,7 +433,7 @@
 		     UNSPEC_ADDQH_PH))]
   "ISA_HAS_DSPR2"
   "addqh.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_r_ph"
@@ -443,7 +443,7 @@
 		     UNSPEC_ADDQH_R_PH))]
   "ISA_HAS_DSPR2"
   "addqh_r.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_w"
@@ -453,7 +453,7 @@
 		   UNSPEC_ADDQH_W))]
   "ISA_HAS_DSPR2"
   "addqh.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_r_w"
@@ -463,7 +463,7 @@
 		   UNSPEC_ADDQH_R_W))]
   "ISA_HAS_DSPR2"
   "addqh_r.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_ph"
@@ -473,7 +473,7 @@
 		     UNSPEC_SUBQH_PH))]
   "ISA_HAS_DSPR2"
   "subqh.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_r_ph"
@@ -483,7 +483,7 @@
 		     UNSPEC_SUBQH_R_PH))]
   "ISA_HAS_DSPR2"
   "subqh_r.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_w"
@@ -493,7 +493,7 @@
 		   UNSPEC_SUBQH_W))]
   "ISA_HAS_DSPR2"
   "subqh.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_r_w"
@@ -503,7 +503,7 @@
 		   UNSPEC_SUBQH_R_W))]
   "ISA_HAS_DSPR2"
   "subqh_r.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpax_w_ph"
@@ -514,7 +514,7 @@
 		   UNSPEC_DPAX_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpax.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsx_w_ph"
@@ -525,7 +525,7 @@
 		   UNSPEC_DPSX_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpsx.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpaqx_s_w_ph"
@@ -540,7 +540,7 @@
 			UNSPEC_DPAQX_S_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpaqx_s.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpaqx_sa_w_ph"
@@ -555,7 +555,7 @@
 			UNSPEC_DPAQX_SA_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpaqx_sa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsqx_s_w_ph"
@@ -570,7 +570,7 @@
 			UNSPEC_DPSQX_S_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpsqx_s.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsqx_sa_w_ph"
@@ -585,5 +585,43 @@
 			UNSPEC_DPSQX_SA_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpsqx_sa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
+   (set_attr "mode"	"SI")])
+
+;; Convert  mtlo $ac[1-3],$0  =>  mult $ac[1-3],$0,$0
+;;          mthi $ac[1-3],$0
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(const_int 0))
+   (set (match_operand:SI 1 "register_operand" "")
+	(const_int 0))]
+  "ISA_HAS_DSPR2
+   && !TARGET_MIPS16
+   && !TARGET_64BIT
+   && (((true_regnum (operands[0]) == AC1LO_REGNUM
+		     && true_regnum (operands[1]) == AC1HI_REGNUM)
+	|| (true_regnum (operands[0]) == AC1HI_REGNUM
+			&& true_regnum (operands[1]) == AC1LO_REGNUM))
+       || ((true_regnum (operands[0]) == AC2LO_REGNUM
+			&& true_regnum (operands[1]) == AC2HI_REGNUM)
+	   || (true_regnum (operands[0]) == AC2HI_REGNUM
+			&& true_regnum (operands[1]) == AC2LO_REGNUM))
+       || ((true_regnum (operands[0]) == AC3LO_REGNUM
+		     && true_regnum (operands[1]) == AC3HI_REGNUM)
+	   || (true_regnum (operands[0]) == AC3HI_REGNUM
+			   && true_regnum (operands[1]) == AC3LO_REGNUM)))"
+  [(parallel [(set (match_dup 0) (const_int 0))
+	      (set (match_dup 1) (const_int 0))])]
+)
+
+(define_insn "*mips_acc_init"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "=a")
+	      (const_int 0))
+	      (set (match_operand:SI 1 "register_operand" "=a")
+	      (const_int 0))])]
+  "ISA_HAS_DSPR2
+   && !TARGET_MIPS16
+   && !TARGET_64BIT"
+  "mult\t%q0,$0,$0\t\t# Clear ACC HI/LO"
+  [(set_attr "type"	"imul")
    (set_attr "mode"	"SI")])
diff --git a/gcc/config/mips/mips-protos.h b/gcc/config/mips/mips-protos.h
index d00b368d9..a5cffb751 100644
--- a/gcc/config/mips/mips-protos.h
+++ b/gcc/config/mips/mips-protos.h
@@ -186,7 +186,7 @@ extern bool mips_symbolic_constant_p (rtx, enum mips_symbol_context,
 extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, bool);
 extern bool mips_legitimate_address_p (enum machine_mode, rtx, bool);
 extern bool mips_stack_address_p (rtx, enum machine_mode);
-extern int mips_address_insns (rtx, enum machine_mode, bool);
+extern int mips_address_insns (rtx, enum machine_mode, bool, bool);
 extern int mips_const_insns (rtx);
 extern int mips_split_const_insns (rtx);
 extern int mips_load_store_insns (rtx, rtx);
@@ -261,6 +261,8 @@ extern void mips_print_operand_address (FILE *, rtx);
 extern void mips_output_external (FILE *, tree, const char *);
 extern void mips_output_filename (FILE *, const char *);
 extern void mips_output_ascii (FILE *, const char *, size_t);
+extern void octeon_output_shared_variable (FILE *, tree, const char *,
+					   unsigned HOST_WIDE_INT, int);
 extern void mips_output_aligned_decl_common (FILE *, tree, const char *,
 					     unsigned HOST_WIDE_INT,
 					     unsigned int);
@@ -307,6 +309,8 @@ extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);
 extern bool mips_linked_madd_p (rtx, rtx);
 extern bool mips_store_data_bypass_p (rtx, rtx);
 extern rtx mips_prefetch_cookie (rtx, rtx);
+extern int mips_mult_madd_chain_bypass_p (rtx, rtx);
+extern int mips_dspalu_bypass_p (rtx, rtx);
 
 extern void irix_asm_output_align (FILE *, unsigned);
 extern const char *current_section_name (void);
@@ -331,5 +335,13 @@ extern void mips_expand_atomic_qihi (union mips_gen_fn_ptrs,
 				     rtx, rtx, rtx, rtx);
 
 extern void mips_expand_vector_init (rtx, rtx);
+extern const char *micromips_output_save_restore (bool, rtx);
+extern bool micromips_save_restore_pattern_p (bool, rtx);
+extern bool micromips_load_store_pair_p (bool, bool, rtx, rtx, rtx);
+extern const char *micromips_output_load_store_pair (bool, rtx, rtx);
+extern bool micromips_movep_target_p (rtx, rtx);
+
+extern bool mips_epilogue_uses (unsigned int);
+extern void mips_final_prescan_insn (rtx, rtx *, int);
 
 #endif /* ! GCC_MIPS_PROTOS_H */
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index c6654f726..6226932a7 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -81,6 +81,10 @@ along with GCC; see the file COPYING3.  If not see
    preserve the maximum stack alignment.  We therefore use a value
    of 0x7ff0 in this case.
 
+   microMIPS LWM and SWM support 12-bit offsets (from -2048 to 2047) and
+   to preserve the maximum stack alignment, so 0x7f0 is used when
+   TARGET_MICROMIPS.
+
    MIPS16e SAVE and RESTORE instructions can adjust the stack pointer by
    up to 0x7f8 bytes and can usually save or restore all the registers
    that we need to save or restore.  (Note that we can only use these
@@ -91,7 +95,8 @@ along with GCC; see the file COPYING3.  If not see
    to save and restore registers, and to allocate and deallocate the top
    part of the frame.  */
 #define MIPS_MAX_FIRST_STACK_STEP					\
-  (!TARGET_MIPS16 ? 0x7ff0						\
+  ((!TARGET_MIPS16 && !TARGET_MICROMIPS) ? 0x7ff0			\
+   : TARGET_MICROMIPS ? 0x7f0						\
    : GENERATE_MIPS16E_SAVE_RESTORE ? 0x7f8				\
    : TARGET_64BIT ? 0x100 : 0x400)
 
@@ -261,18 +266,29 @@ struct mips_frame_info GTY(()) {
   /* Likewise FPR X.  */
   unsigned int fmask;
 
-  /* The number of GPRs and FPRs saved.  */
+  /* Likewise doubleword accumulator X ($acX).  */
+  unsigned int acc_mask;
+
+  /* The number of GPRs, FPRs, doubleword accumulators and COP0
+     registers saved.  */
   unsigned int num_gp;
   unsigned int num_fp;
+  unsigned int num_acc;
+  unsigned int num_cop0_regs;
 
-  /* The offset of the topmost GPR and FPR save slots from the top of
-     the frame, or zero if no such slots are needed.  */
+  /* The offset of the topmost GPR, FPR, accumulator and COP0-register
+     save slots from the top of the frame, or zero if no such slots are
+     needed.  */
   HOST_WIDE_INT gp_save_offset;
   HOST_WIDE_INT fp_save_offset;
+  HOST_WIDE_INT acc_save_offset;
+  HOST_WIDE_INT cop0_save_offset;
 
   /* Likewise, but giving offsets from the bottom of the frame.  */
   HOST_WIDE_INT gp_sp_offset;
   HOST_WIDE_INT fp_sp_offset;
+  HOST_WIDE_INT acc_sp_offset;
+  HOST_WIDE_INT cop0_sp_offset;
 
   /* The offset of arg_pointer_rtx from frame_pointer_rtx.  */
   HOST_WIDE_INT arg_pointer_offset;
@@ -310,6 +326,20 @@ struct machine_function GTY(()) {
   /* True if we have emitted an instruction to initialize
      mips16_gp_pseudo_rtx.  */
   bool initialized_mips16_gp_pseudo_p;
+
+  /* True if this is an interrupt handler.  */
+  bool interrupt_handler_p;
+
+  /* True if this is an interrupt handler that uses shadow registers.  */
+  bool use_shadow_register_set_p;
+
+  /* True if this is an interrupt handler that should keep interrupts
+     masked.  */
+  bool keep_interrupts_masked_p;
+
+  /* True if this is an interrupt handler that should use DERET
+     instead of ERET.  */
+  bool use_debug_exception_return_p;
 };
 
 /* Information about a single argument.  */
@@ -452,6 +482,9 @@ static int mips_base_target_flags;
 /* True if MIPS16 is the default mode.  */
 bool mips_base_mips16;
 
+/* True if microMIPS is the default mode.  */
+bool mips_base_micromips;
+
 /* The ambient values of other global variables.  */
 static int mips_base_schedule_insns; /* flag_schedule_insns */
 static int mips_base_reorder_blocks_and_partition; /* flag_reorder... */
@@ -542,9 +575,16 @@ const enum reg_class mips_regno_to_class[FIRST_PSEUDO_REGISTER] = {
   ALL_REGS,	ALL_REGS,	ALL_REGS,	ALL_REGS
 };
 
+#ifdef CVMX_SHARED_BSS_FLAGS
+static tree octeon_handle_cvmx_shared_attribute (tree *, tree, tree, int, bool *);
+#endif
+
 /* The value of TARGET_ATTRIBUTE_TABLE.  */
 const struct attribute_spec mips_attribute_table[] = {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
+#ifdef CVMX_SHARED_BSS_FLAGS
+  { "cvmx_shared", 0, 0, true, false, false, octeon_handle_cvmx_shared_attribute },
+#endif
   { "long_call",   0, 0, false, true,  true,  NULL },
   { "far",     	   0, 0, false, true,  true,  NULL },
   { "near",        0, 0, false, true,  true,  NULL },
@@ -554,6 +594,13 @@ const struct attribute_spec mips_attribute_table[] = {
      code generation but don't carry other semantics.  */
   { "mips16", 	   0, 0, true,  false, false, NULL },
   { "nomips16",    0, 0, true,  false, false, NULL },
+  { "micromips",   0, 0, true,  false, false, NULL },
+  { "nomicromips", 0, 0, true,  false, false, NULL },
+  /* Allow functions to be specified as interrupt handlers */
+  { "interrupt",   0, 0, false, true,  true, NULL },
+  { "use_shadow_register_set",	0, 0, false, true,  true, NULL },
+  { "keep_interrupts_masked",	0, 0, false, true,  true, NULL },
+  { "use_debug_exception_return", 0, 0, false, true,  true, NULL },
   { NULL,	   0, 0, false, false, false, NULL }
 };
 
@@ -625,6 +672,8 @@ static const struct mips_cpu_info mips_cpu_info_table[] = {
 
   /* MIPS32 Release 2 processors.  */
   { "m4k", PROCESSOR_M4K, 33, 0 },
+  { "m14kc", PROCESSOR_M4K, 33, 0 },
+  { "m14k", PROCESSOR_M4K, 33, 0 },
   { "4kec", PROCESSOR_4KC, 33, 0 },
   { "4kem", PROCESSOR_4KC, 33, 0 },
   { "4kep", PROCESSOR_4KP, 33, 0 },
@@ -659,6 +708,11 @@ static const struct mips_cpu_info mips_cpu_info_table[] = {
   { "74kx", PROCESSOR_74KF1_1, 33, 0 },
   { "74kf3_2", PROCESSOR_74KF3_2, 33, 0 },
 
+  { "1004kc", PROCESSOR_24KC, 33, 0 }, /* 1004K with MT/DSP.  */
+  { "1004kf2_1", PROCESSOR_24KF2_1, 33, 0 },
+  { "1004kf", PROCESSOR_24KF2_1, 33, 0 },
+  { "1004kf1_1", PROCESSOR_24KF1_1, 33, 0 },
+
   /* MIPS64 processors.  */
   { "5kc", PROCESSOR_5KC, 64, 0 },
   { "5kf", PROCESSOR_5KF, 64, 0 },
@@ -1064,13 +1118,7 @@ static const struct mips_rtx_cost_data mips_rtx_cost_data[PROCESSOR_MAX] = {
     DEFAULT_COSTS
   },
   { /* XLR */
-    /* Need to replace first five with the costs of calling the appropriate 
-       libgcc routine.  */
-    COSTS_N_INSNS (256),          /* fp_add */
-    COSTS_N_INSNS (256),          /* fp_mult_sf */
-    COSTS_N_INSNS (256),          /* fp_mult_df */
-    COSTS_N_INSNS (256),          /* fp_div_sf */
-    COSTS_N_INSNS (256),          /* fp_div_df */
+    SOFT_FP_COSTS,
     COSTS_N_INSNS (8),            /* int_mult_si */
     COSTS_N_INSNS (8),            /* int_mult_di */
     COSTS_N_INSNS (72),           /* int_div_si */
@@ -1172,6 +1220,42 @@ mips_nomips16_decl_p (const_tree decl)
   return lookup_attribute ("nomips16", DECL_ATTRIBUTES (decl)) != NULL;
 }
 
+/* Check if the interrupt attribute is set for a function.  */
+
+static bool
+mips_interrupt_type_p (tree type)
+{
+  return lookup_attribute ("interrupt", TYPE_ATTRIBUTES (type)) != NULL;
+}
+
+/* Check if the attribute to use shadow register set is set for a function.  */
+
+static bool
+mips_use_shadow_register_set_p (tree type)
+{
+  return lookup_attribute ("use_shadow_register_set",
+			   TYPE_ATTRIBUTES (type)) != NULL;
+}
+
+/* Check if the attribute to keep interrupts masked is set for a function.  */
+
+static bool
+mips_keep_interrupts_masked_p (tree type)
+{
+  return lookup_attribute ("keep_interrupts_masked",
+			   TYPE_ATTRIBUTES (type)) != NULL;
+}
+
+/* Check if the attribute to use debug exception return is set for
+   a function.  */
+
+static bool
+mips_use_debug_exception_return_p (tree type)
+{
+  return lookup_attribute ("use_debug_exception_return",
+			   TYPE_ATTRIBUTES (type)) != NULL;
+}
+
 /* Return true if function DECL is a MIPS16 function.  Return the ambient
    setting if DECL is null.  */
 
@@ -1193,6 +1277,41 @@ mips_use_mips16_mode_p (tree decl)
   return mips_base_mips16;
 }
 
+/* Similar predicates for "micromips"/"nomicromips" function attributes.  */
+
+static bool
+mips_micromips_decl_p (const_tree decl)
+{
+  return lookup_attribute ("micromips", DECL_ATTRIBUTES (decl)) != NULL;
+}
+
+static bool
+mips_nomicromips_decl_p (const_tree decl)
+{
+  return lookup_attribute ("nomicromips", DECL_ATTRIBUTES (decl)) != NULL;
+}
+
+/* Return true if function DECL is a microMIPS function.  Return the ambient
+   setting if DECL is null.  */
+
+static bool
+mips_use_micromips_mode_p (tree decl)
+{
+  if (decl)
+    {
+      /* Nested functions must use the same frame pointer as their
+	 parent and must therefore use the same ISA mode.  */
+      tree parent = decl_function_context (decl);
+      if (parent)
+	decl = parent;
+      if (mips_micromips_decl_p (decl))
+	return true;
+      if (mips_nomicromips_decl_p (decl))
+	return false;
+    }
+  return mips_base_micromips;
+}
+
 /* Implement TARGET_COMP_TYPE_ATTRIBUTES.  */
 
 static int
@@ -1213,16 +1332,23 @@ mips_insert_attributes (tree decl, tree *attributes)
 {
   const char *name;
   bool mips16_p, nomips16_p;
+  bool micromips_p, nomicromips_p;
 
   /* Check for "mips16" and "nomips16" attributes.  */
   mips16_p = lookup_attribute ("mips16", *attributes) != NULL;
   nomips16_p = lookup_attribute ("nomips16", *attributes) != NULL;
+  micromips_p = lookup_attribute ("micromips", *attributes) != NULL;
+  nomicromips_p = lookup_attribute ("nomicromips", *attributes) != NULL;
   if (TREE_CODE (decl) != FUNCTION_DECL)
     {
       if (mips16_p)
 	error ("%qs attribute only applies to functions", "mips16");
       if (nomips16_p)
 	error ("%qs attribute only applies to functions", "nomips16");
+      if (micromips_p)
+	error ("%qs attribute only applies to functions", "micromips");
+      if (nomicromips_p)
+	error ("%qs attribute only applies to functions", "nomicromips");
     }
   else
     {
@@ -1244,6 +1370,21 @@ mips_insert_attributes (tree decl, tree *attributes)
 	  name = mflip_mips16_use_mips16_p (decl) ? "mips16" : "nomips16";
 	  *attributes = tree_cons (get_identifier (name), NULL, *attributes);
 	}
+
+      micromips_p |= mips_micromips_decl_p (decl);
+      nomicromips_p |= mips_nomicromips_decl_p (decl);
+      if (micromips_p || nomicromips_p)
+	{
+	  /* DECL cannot be simultaneously "micromips" and "nomicromips".  */
+	  if (micromips_p && nomicromips_p)
+	    error ("%qs cannot have both %<micromips%> and "
+		   "%<nomicromips%> attributes",
+		   IDENTIFIER_POINTER (DECL_NAME (decl)));
+	}
+
+      if (mips16_p && micromips_p)
+	error ("%qs cannot have both %<mips16%> and %<micromips%> attributes",
+	       IDENTIFIER_POINTER (DECL_NAME (decl)));
     }
 }
 
@@ -2132,10 +2273,14 @@ mips16_unextended_reference_p (enum machine_mode mode, rtx base,
    if MIGHT_SPLIT_P, otherwise assume that a single load or store is
    enough.
 
+   If CHECK_MICROMIPS_12BIT_P, we check if the address is within a 12-bit
+   offset for microMIPS.
+
    For MIPS16 code, count extended instructions as two instructions.  */
 
 int
-mips_address_insns (rtx x, enum machine_mode mode, bool might_split_p)
+mips_address_insns (rtx x, enum machine_mode mode, bool might_split_p,
+		    bool check_micromips_12bit_p)
 {
   struct mips_address_info addr;
   int factor;
@@ -2153,6 +2298,12 @@ mips_address_insns (rtx x, enum machine_mode mode, bool might_split_p)
     switch (addr.type)
       {
       case ADDRESS_REG:
+	if (TARGET_MICROMIPS && check_micromips_12bit_p
+	    && (!CONST_INT_P (addr.offset)
+		|| INTVAL (addr.offset) < -2048
+		|| INTVAL (addr.offset) > 2047))
+	      return 0;
+
 	if (TARGET_MIPS16
 	    && !mips16_unextended_reference_p (mode, addr.reg,
 					       UINTVAL (addr.offset)))
@@ -2160,12 +2311,21 @@ mips_address_insns (rtx x, enum machine_mode mode, bool might_split_p)
 	return factor;
 
       case ADDRESS_LO_SUM:
+	if (TARGET_MICROMIPS && check_micromips_12bit_p)
+	  return 0;
+
 	return TARGET_MIPS16 ? factor * 2 : factor;
 
       case ADDRESS_CONST_INT:
+	if (TARGET_MICROMIPS && check_micromips_12bit_p)
+	  return 0;
+
 	return factor;
 
       case ADDRESS_SYMBOLIC:
+	if (TARGET_MICROMIPS && check_micromips_12bit_p)
+	  return 0;
+
 	return factor * mips_symbol_insns (addr.symbol_type, mode);
       }
   return 0;
@@ -2290,7 +2450,7 @@ mips_load_store_insns (rtx mem, rtx insn)
 	might_split_p = false;
     }
 
-  return mips_address_insns (XEXP (mem, 0), mode, might_split_p);
+  return mips_address_insns (XEXP (mem, 0), mode, might_split_p, false);
 }
 
 /* Return the number of instructions needed for an integer division.  */
@@ -2817,7 +2977,7 @@ bool
 mips_legitimize_address (rtx *xloc, enum machine_mode mode)
 {
   rtx base, addr;
-  HOST_WIDE_INT offset;
+  HOST_WIDE_INT intval, high, offset;
 
   if (mips_tls_symbol_p (*xloc))
     {
@@ -2842,6 +3002,32 @@ mips_legitimize_address (rtx *xloc, enum machine_mode mode)
       *xloc = mips_force_address (addr, mode);
       return true;
     }
+
+ /* Handle references to constant addresses by loading the high part
+    into a register and using an offset for the low part.  */
+ if (GET_CODE (base) == CONST_INT)
+   {
+     intval = INTVAL (base);
+     high = trunc_int_for_mode (CONST_HIGH_PART (intval), Pmode);
+     offset = CONST_LOW_PART (intval);
+     /* Ignore cases in which a positive address would be accessed by a
+	negative offset from a negative address.  The required wraparound
+	does not occur for 32-bit addresses on 64-bit targets, and it is
+	very unlikely that such an access would occur in real code anyway.
+
+	If the low offset is not legitimate for MODE, prefer to load
+	the constant normally, instead of using mips_force_address on
+	the legitimized address.  The latter option would cause us to
+	use (D)ADDIU unconditionally, but LUI/ORI is more efficient
+	than LUI/ADDIU on some targets.  */
+     if ((intval < 0 || high > 0)
+	  && mips_valid_offset_p (GEN_INT (offset), mode))
+	{
+	  base = mips_force_temporary (NULL, GEN_INT (high));
+	  *xloc = plus_constant (base, offset);
+	  return true;
+	}
+   }
   return false;
 }
 
@@ -3461,7 +3647,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total,
       /* If the address is legitimate, return the number of
 	 instructions it needs.  */
       addr = XEXP (x, 0);
-      cost = mips_address_insns (addr, mode, true);
+      cost = mips_address_insns (addr, mode, true, false);
       if (cost > 0)
 	{
 	  *total = COSTS_N_INSNS (cost + 1);
@@ -3723,7 +3909,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total,
 static int
 mips_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)
 {
-  return mips_address_insns (addr, SImode, false);
+  return mips_address_insns (addr, SImode, false, false);
 }
 
 /* Return one word of double-word value OP, taking into account the fixed
@@ -5434,6 +5620,11 @@ mips_start_function_definition (const char *name, bool mips16_p)
   else
     fprintf (asm_out_file, "\t.set\tnomips16\n");
 
+  if (TARGET_MICROMIPS)
+    fprintf (asm_out_file, "\t.set\tmicromips\n");
+  else
+    fprintf (asm_out_file, "\t.set\tnomicromips\n");
+
   if (!flag_inhibit_size_directive)
     {
       fputs ("\t.ent\t", asm_out_file);
@@ -6210,12 +6401,40 @@ mips_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)
   if (!TARGET_SIBCALLS)
     return false;
 
+  /* Interrupt handlers need special epilogue code and therefore can't
+     use sibcalls.  */
+  if (mips_interrupt_type_p (TREE_TYPE (current_function_decl)))
+    return false;
+
+  if (TARGET_MICROMIPS)
+    {
+      /* We can't do a sibcall if the called function is a MIPS32 function.  */
+      if (decl
+	  && !mips_use_micromips_mode_p (decl)
+	  && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode))
+	return false;
+
+      /* When -minterlink-mips16 is in effect, assume that non-locally-binding
+	 functions could be MIPS32 ones unless an attribute explicitly tells
+	 us otherwise.  */
+      if (TARGET_INTERLINK_MIPS16
+	  && decl
+	  && (DECL_EXTERNAL (decl) || !targetm.binds_local_p (decl))
+	  && !mips_micromips_decl_p (decl)
+	  && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode))
+	return false;
+
+      /* Otherwise OK.  */
+      return true;
+    }
+
   /* We can't do a sibcall if the called function is a MIPS16 function
      because there is no direct "jx" instruction equivalent to "jalx" to
      switch the ISA mode.  We only care about cases where the sibling
      and normal calls would both be direct.  */
   if (decl
-      && mips_use_mips16_mode_p (decl)
+      && (mips_use_mips16_mode_p (decl)
+          || mips_use_micromips_mode_p (decl))
       && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode))
     return false;
 
@@ -6226,6 +6445,7 @@ mips_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)
       && decl
       && (DECL_EXTERNAL (decl) || !targetm.binds_local_p (decl))
       && !mips_nomips16_decl_p (decl)
+      && !mips_nomicromips_decl_p (decl)
       && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode))
     return false;
 
@@ -6655,6 +6875,15 @@ mips_expand_ext_as_unaligned_load (rtx dest, rtx src, HOST_WIDE_INT width,
   if (!mips_get_unaligned_mem (&src, width, bitpos, &left, &right))
     return false;
 
+  if (ISA_HAS_UL_US)
+    {
+      if (GET_MODE (dest) == DImode)
+	emit_insn (gen_mov_uld (dest, src, left));
+      else
+	emit_insn (gen_mov_ulw (dest, src, left));
+      return true;
+    }
+
   temp = gen_reg_rtx (GET_MODE (dest));
   if (GET_MODE (dest) == DImode)
     {
@@ -6689,6 +6918,16 @@ mips_expand_ins_as_unaligned_store (rtx dest, rtx src, HOST_WIDE_INT width,
 
   mode = mode_for_size (width, MODE_INT, 0);
   src = gen_lowpart (mode, src);
+
+  if (ISA_HAS_UL_US)
+    {
+      if (GET_MODE (src) == DImode)
+        emit_insn (gen_mov_usd (dest, src, left));
+      else
+        emit_insn (gen_mov_usw (dest, src, left));
+      return true;
+    }
+
   if (mode == DImode)
     {
       emit_insn (gen_mov_sdl (dest, src, left));
@@ -6968,6 +7207,9 @@ mips_print_operand_reloc (FILE *file, rtx op, enum mips_symbol_context context,
    '$'	Print the name of the stack pointer register (sp or $29).
    '|'	Print ".set push; .set mips2" if !ISA_HAS_LL_SC.
    '-'	Print ".set pop" under the same conditions for '|'.
+   ':'	Print "c" to use the compact version if the delay slot is a nop.
+   '!'	Print "s" to use the short version if the delay slot contains a
+	16-bit instruction.
 
    See also mips_init_print_operand_pucnt.  */
 
@@ -7070,6 +7312,378 @@ mips_print_operand_punctuation (FILE *file, int ch)
 	fputs ("\n\t.set\tpop", file);
       break;
 
+    case ':':
+      /* When reorder or noreorder with final_squence 0, the delay slot will
+	 be a nop, so we just use the compact version for microMIPS.  */
+      if (set_noreorder == 0 || final_sequence == 0)
+	putc ('c', file);
+      break;
+
+    case '!':
+      /* When reorder or noreorder with final_squence 0, the delay slot will
+	 be a nop, so we just use the compact version for microMIPS.  */
+      if (set_noreorder == 0 || final_sequence == 0)
+	putc ('s', file);
+      else
+	{
+	  /* Try to find out if the delay slot instruction is 16-bit.  */
+
+	  struct recog_data old_recog_data = recog_data;
+	  rtx insn = XVECEXP (final_sequence, 0, 1);
+	  enum attr_mode mode = get_attr_mode (insn);
+	  enum attr_micromips_type micromips_type
+	    = get_attr_micromips_type (insn);
+
+	  recog_memoized (insn);
+	  cleanup_subreg_operands (insn);
+	  
+	  if (0
+
+	      /* move16 rd, rs.  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && (REG_P (XEXP (PATTERN (insn), 1))
+		      || GET_CODE (XEXP (PATTERN (insn), 1)) == CONST_DOUBLE)
+		  && REG_P (recog_data.operand[0])
+		  && GP_REG_P (REGNO (recog_data.operand[0]))
+		  && ((REG_P (recog_data.operand[1])
+		       && GP_REG_P (REGNO (recog_data.operand[1])))
+		      || (recog_data.operand[1] == CONST0_RTX(SFmode))))
+
+	      /* move16 rd, $0.  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && GET_CODE (XEXP (PATTERN (insn), 1)) == CONST_INT
+		  && REG_P (recog_data.operand[0])
+		  && GP_REG_P (REGNO (recog_data.operand[0]))
+		  && CONST_INT_P (recog_data.operand[1])
+		  && INTVAL (recog_data.operand[1]) == 0)
+
+	      /* li16 rd, imm.  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && GET_CODE (XEXP (PATTERN (insn), 1)) == CONST_INT
+		  && mode == MODE_SI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && CONST_INT_P (recog_data.operand[1])
+		  && INTVAL (recog_data.operand[1]) >= -1
+		  && INTVAL (recog_data.operand[1]) <= 126)
+
+	      /* lw16 rt, offset(base).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && MEM_P (XEXP (PATTERN (insn), 1))
+		  && ((mode == MODE_SI
+		       && GET_MODE (recog_data.operand[1]) == SImode)
+		      || (mode == MODE_SF
+			  && GET_MODE (recog_data.operand[1]) == SFmode))
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && MEM_P (recog_data.operand[1])
+		  && ((REG_P (XEXP (recog_data.operand[1], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[1], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[1], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[1], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[1], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[1], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) & 3) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) <= 60)))
+
+	      /* lwsp rt, offset($29).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && MEM_P (XEXP (PATTERN (insn), 1))
+		  && ((mode == MODE_SI
+		       && GET_MODE (recog_data.operand[1]) == SImode)
+		      || (mode == MODE_SF
+			  && GET_MODE (recog_data.operand[1]) == SFmode))
+		  && REG_P (recog_data.operand[0])
+		  && GP_REG_P (REGNO (recog_data.operand[0]))
+		  && MEM_P (recog_data.operand[1])
+		  && ((REG_P (XEXP (recog_data.operand[1], 0))
+		       && (REGNO (XEXP (recog_data.operand[1], 0))) == 29)
+		      || (GET_CODE (XEXP (recog_data.operand[1], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[1], 0), 0))
+			  && REGNO (XEXP (XEXP (recog_data.operand[1], 0), 0)) == 29
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[1], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) & 3) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) <= 124)))
+
+	      /* lhu16 rt, offset(base).  */
+	      || (micromips_type == MICROMIPS_TYPE_ZERO_EXTEND
+		  && mode == MODE_SI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && MEM_P (recog_data.operand[1])
+		  && GET_MODE (recog_data.operand[1]) == HImode
+		  && ((REG_P (XEXP (recog_data.operand[1], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[1], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[1], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[1], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[1], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[1], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) & 1) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) <= 30)))
+
+	      /* lbu16 rt, offset(base).  */
+	      || (micromips_type == MICROMIPS_TYPE_ZERO_EXTEND
+		  && mode == MODE_SI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && MEM_P (recog_data.operand[1])
+		  && GET_MODE (recog_data.operand[1]) == QImode
+		  && ((REG_P (XEXP (recog_data.operand[1], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[1], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[1], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[1], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[1], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[1], 0), 1))
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) >= -1
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) <= 14)))
+
+	      /* sw16 rt, offset(base).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && MEM_P (XEXP (PATTERN (insn), 0))
+		  && ((mode == MODE_SI
+		       && GET_MODE (recog_data.operand[0]) == SImode)
+		      || (mode == MODE_SF
+			  && GET_MODE (recog_data.operand[0]) == SFmode))
+		  && ((CONST_INT_P (recog_data.operand[1])
+		       && INTVAL (recog_data.operand[1]) == 0)
+		      || (REG_P (recog_data.operand[1])
+			  && M16STORE_REG_P (REGNO (recog_data.operand[1]))))
+		  && MEM_P (recog_data.operand[0])
+		  && ((REG_P (XEXP (recog_data.operand[0], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[0], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[0], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[0], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[0], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[0], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) & 3) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) <= 60)))
+
+	      /* swsp rt, offset($29).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && MEM_P (XEXP (PATTERN (insn), 0))
+		  && ((mode == MODE_SI
+		       && GET_MODE (recog_data.operand[0]) == SImode)
+		      || (mode == MODE_SF
+			  && GET_MODE (recog_data.operand[0]) == SFmode))
+		  && ((CONST_INT_P (recog_data.operand[1])
+		       && INTVAL (recog_data.operand[1]) == 0)
+		      || (REG_P (recog_data.operand[1])
+			  && GP_REG_P (REGNO (recog_data.operand[1]))))
+		  && MEM_P (recog_data.operand[0])
+		  && ((REG_P (XEXP (recog_data.operand[0], 0))
+		       && (REGNO (XEXP (recog_data.operand[0], 0))) == 29)
+		      || (GET_CODE (XEXP (recog_data.operand[0], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[0], 0), 0))
+			  && (REGNO (XEXP (XEXP (recog_data.operand[0], 0), 0)) == 29)
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[0], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) & 3) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) <= 124)))
+
+	      /* sh16 rt, offset(base).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && MEM_P (XEXP (PATTERN (insn), 0))
+		  && mode == MODE_HI
+		  && ((CONST_INT_P (recog_data.operand[1])
+		       && INTVAL (recog_data.operand[1]) == 0)
+		      || (REG_P (recog_data.operand[1])
+			  && M16STORE_REG_P (REGNO (recog_data.operand[1]))))
+		  && MEM_P (recog_data.operand[0])
+		  && GET_MODE (recog_data.operand[0]) == HImode
+		  && ((REG_P (XEXP (recog_data.operand[0], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[0], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[0], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[0], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[0], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[0], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) & 1) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) <= 30)))
+
+	      /* sb16 rt, offset(base).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && MEM_P (XEXP (PATTERN (insn), 0))
+		  && mode == MODE_QI
+		  && ((CONST_INT_P (recog_data.operand[1])
+		       && INTVAL (recog_data.operand[1]) == 0)
+		      || (REG_P (recog_data.operand[1])
+			  && M16STORE_REG_P (REGNO (recog_data.operand[1]))))
+		  && MEM_P (recog_data.operand[0])
+		  && GET_MODE (recog_data.operand[0]) == QImode
+		  && ((REG_P (XEXP (recog_data.operand[0], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[0], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[0], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[0], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[0], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[0], 0), 1))
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) <= 15)))
+
+	      /* addu16 rd, rs, rt.  */
+	      || (micromips_type == MICROMIPS_TYPE_ADD
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && REG_P (recog_data.operand[2])
+		  && M16_REG_P (REGNO (recog_data.operand[2])))
+
+	      /* addius5 rd, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_ADD
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && REG_P (recog_data.operand[1])
+		  && GP_REG_P (REGNO (recog_data.operand[0]))
+		  && (REGNO (recog_data.operand[0])
+		      == REGNO (recog_data.operand[1]))
+		  && CONST_INT_P (recog_data.operand[2])
+		  && INTVAL (recog_data.operand[2]) >= -8
+		  && INTVAL (recog_data.operand[2]) <= 7)
+
+	      /* addiusp $29, $29, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_ADD
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && REGNO (recog_data.operand[0]) == 29
+		  && REG_P (recog_data.operand[1])
+		  && REGNO (recog_data.operand[1]) == 29
+		  && CONST_INT_P (recog_data.operand[2])
+		  && ((INTVAL (recog_data.operand[2]) >= 2
+		       && INTVAL (recog_data.operand[2]) <= 257)
+		      || (INTVAL (recog_data.operand[2]) >= -258
+			  && INTVAL (recog_data.operand[2]) <= -3)))
+
+	      /* addiur1sp rd, $29, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_ADD
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && REGNO (recog_data.operand[1]) == 29
+		  && CONST_INT_P (recog_data.operand[2])
+		  && (INTVAL (recog_data.operand[2])  & 3) == 0
+		  && INTVAL (recog_data.operand[2]) >= 0
+		  && INTVAL (recog_data.operand[2]) <= 252)
+
+	      /* addiur2 rd, rs, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_ADD
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && CONST_INT_P (recog_data.operand[2])
+		  && (INTVAL (recog_data.operand[2]) == 1
+		      || INTVAL (recog_data.operand[2]) == 4
+		      || INTVAL (recog_data.operand[2]) == 8
+		      || INTVAL (recog_data.operand[2]) == 12
+		      || INTVAL (recog_data.operand[2]) == 16
+		      || INTVAL (recog_data.operand[2]) == 20
+		      || INTVAL (recog_data.operand[2]) == 24
+		      || INTVAL (recog_data.operand[2]) == -1))
+
+	      /* subu16 rd, rs, rt.  */
+	      || (micromips_type == MICROMIPS_TYPE_SUB
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && REG_P (recog_data.operand[2])
+		  && M16_REG_P (REGNO (recog_data.operand[2])))
+
+	      /* sll16/srl16 rd, rt, sa.  */
+	      || (micromips_type == MICROMIPS_TYPE_SHIFT
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && CONST_INT_P (recog_data.operand[2])
+		  && INTVAL (recog_data.operand[2]) >= 1
+		  && INTVAL (recog_data.operand[2]) <= 8)
+
+	      /* andi16 rd, rs, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_LOGICAL_AND
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && CONST_INT_P (recog_data.operand[2])
+		  && (INTVAL (recog_data.operand[2]) == 128
+		      || INTVAL (recog_data.operand[2]) == 1
+		      || INTVAL (recog_data.operand[2]) == 2
+		      || INTVAL (recog_data.operand[2]) == 3
+		      || INTVAL (recog_data.operand[2]) == 4
+		      || INTVAL (recog_data.operand[2]) == 7
+		      || INTVAL (recog_data.operand[2]) == 8
+		      || INTVAL (recog_data.operand[2]) == 15
+		      || INTVAL (recog_data.operand[2]) == 16
+		      || INTVAL (recog_data.operand[2]) == 31
+		      || INTVAL (recog_data.operand[2]) == 32
+		      || INTVAL (recog_data.operand[2]) == 63
+		      || INTVAL (recog_data.operand[2]) == 64
+		      || INTVAL (recog_data.operand[2]) == 255
+		      || INTVAL (recog_data.operand[2]) == 32768
+		      || INTVAL (recog_data.operand[2]) == 65535))
+
+	      /* andi16 rd, rs, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_ZERO_EXTEND
+		  && mode == MODE_SI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1])))
+
+	      /* and16/xor16/or16 rd, rs, rt.  */
+	      || ((micromips_type == MICROMIPS_TYPE_LOGICAL_AND
+		   || micromips_type == MICROMIPS_TYPE_LOGICAL_XOR
+		   || micromips_type == MICROMIPS_TYPE_LOGICAL_OR)
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && REG_P (recog_data.operand[2])
+		  && M16_REG_P (REGNO (recog_data.operand[2]))
+		  && (REGNO (recog_data.operand[0])
+			== REGNO (recog_data.operand[1])
+		      || REGNO (recog_data.operand[0])
+			   == REGNO (recog_data.operand[2])))
+
+	      /* mfhi rd.  */
+	      || (micromips_type == MICROMIPS_TYPE_MFHI
+		  && REG_P (recog_data.operand[0])
+		  && GP_REG_P (REGNO (recog_data.operand[0])))
+
+	      /* mflo rd.  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && REG_P (XEXP (PATTERN (insn), 0))
+		  && REG_P (XEXP (PATTERN (insn), 1))
+		  && REG_P (recog_data.operand[0])
+		  && GP_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && REGNO (recog_data.operand[1]) == LO_REGNUM)
+
+	      /* not rt, rs.  */
+	      || (micromips_type == MICROMIPS_TYPE_LOGICAL_NOT
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1])))
+
+	      || 0)
+
+	    putc ('s', file);
+
+	  recog_data = old_recog_data;
+	}
+      break;
+
     default:
       gcc_unreachable ();
       break;
@@ -7083,7 +7697,7 @@ mips_init_print_operand_punct (void)
 {
   const char *p;
 
-  for (p = "()[]<>*#/?~.@^+$|-"; *p; p++)
+  for (p = "()[]<>*#/?~.@^+$|-:!"; *p; p++)
     mips_print_operand_punct[(unsigned char) *p] = true;
 }
 
@@ -7276,7 +7890,11 @@ mips_print_operand (FILE *file, rtx op, int letter)
 		|| (letter == 'L' && TARGET_BIG_ENDIAN)
 		|| letter == 'D')
 	      regno++;
-	    fprintf (file, "%s", reg_names[regno]);
+	    /* We need to print $0 .. $31 for COP0 registers.  */
+	    if (COP0_REG_P (regno))
+	      fprintf (file, "$%s", &reg_names[regno][4]);
+	    else
+	      fprintf (file, "%s", reg_names[regno]);
 	  }
 	  break;
 
@@ -7416,6 +8034,12 @@ mips_in_small_data_p (const_tree decl)
   if (TARGET_ABICALLS || TARGET_VXWORKS_RTP)
     return false;
 
+#ifdef CVMX_SHARED_BSS_FLAGS
+  if (TARGET_OCTEON && TREE_CODE (decl) == VAR_DECL
+      && lookup_attribute ("cvmx_shared", DECL_ATTRIBUTES (decl)))
+    return false;
+#endif
+
   if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl) != 0)
     {
       const char *name;
@@ -7642,6 +8266,37 @@ mips_dwarf_register_span (rtx reg)
   return NULL_RTX;
 }
 
+/* DSP ALU can bypass data with no delays for the following pairs. */
+enum insn_code dspalu_bypass_table[][2] =
+{
+  {CODE_FOR_mips_addsc, CODE_FOR_mips_addwc},
+  {CODE_FOR_mips_cmpu_eq_qb, CODE_FOR_mips_pick_qb},
+  {CODE_FOR_mips_cmpu_lt_qb, CODE_FOR_mips_pick_qb},
+  {CODE_FOR_mips_cmpu_le_qb, CODE_FOR_mips_pick_qb},
+  {CODE_FOR_mips_cmp_eq_ph, CODE_FOR_mips_pick_ph},
+  {CODE_FOR_mips_cmp_lt_ph, CODE_FOR_mips_pick_ph},
+  {CODE_FOR_mips_cmp_le_ph, CODE_FOR_mips_pick_ph},
+  {CODE_FOR_mips_wrdsp, CODE_FOR_mips_insv}
+};
+
+int
+mips_dspalu_bypass_p (rtx out_insn, rtx in_insn)
+{
+  int i;
+  int num_bypass = (sizeof (dspalu_bypass_table)
+		    / (2 * sizeof (enum insn_code)));
+  enum insn_code out_icode = INSN_CODE (out_insn);
+  enum insn_code in_icode = INSN_CODE (in_insn);
+
+  for (i = 0; i < num_bypass; i++)
+    {
+      if (out_icode == dspalu_bypass_table[i][0]
+	  && in_icode == dspalu_bypass_table[i][1])
+       return true;
+    }
+
+  return false;
+}
 /* Implement ASM_OUTPUT_ASCII.  */
 
 void
@@ -7866,10 +8521,18 @@ mips_file_start (void)
 		 "\t.previous\n", TARGET_LONG64 ? 64 : 32);
 
 #ifdef HAVE_AS_GNU_ATTRIBUTE
+#ifdef TARGET_MIPS_SDEMTK
+     fprintf (asm_out_file, "\t.gnu_attribute 4, %d\n",
+             (!TARGET_NO_FLOAT
+              ? (TARGET_HARD_FLOAT
+                 ? (TARGET_DOUBLE_FLOAT
+                    ? ((!TARGET_64BIT && TARGET_FLOAT64) ? 4 : 1) : 2) : 3) : 0));
+#else
       fprintf (asm_out_file, "\t.gnu_attribute 4, %d\n",
 	       (TARGET_HARD_FLOAT_ABI
 		? (TARGET_DOUBLE_FLOAT
 		   ? ((!TARGET_64BIT && TARGET_FLOAT64) ? 4 : 1) : 2) : 3));
+#endif
 #endif
     }
 
@@ -8483,12 +9146,53 @@ mips_global_pointer (void)
   return GLOBAL_POINTER_REGNUM;
 }
 
+/* Return true if REGNO is a register that is ordinarily call-clobbered
+   but must nevertheless be preserved by an interrupt handler.  */
+
+static bool
+mips_interrupt_extra_call_saved_reg_p (unsigned int regno)
+{
+  if (MD_REG_P (regno))
+    return true;
+
+  if (TARGET_DSP && DSP_ACC_REG_P (regno))
+    return true;
+
+  if (GP_REG_P (regno) && !cfun->machine->use_shadow_register_set_p)
+    {
+      /* $0 is hard-wired.  */
+      if (regno == GP_REG_FIRST)
+	return false;
+
+      /* The interrupt handler can treat kernel registers as
+	 scratch registers.  */
+      if (KERNEL_REG_P (regno))
+	return false;
+
+      /* The function will return the stack pointer to its original value
+	 anyway.  */
+      if (regno == STACK_POINTER_REGNUM)
+	return false;
+
+      /* Otherwise, return true for registers that aren't ordinarily
+	 call-clobbered.  */
+      return call_really_used_regs[regno];
+    }
+
+  return false;
+}
+
 /* Return true if the current function should treat register REGNO
    as call-saved.  */
 
 static bool
 mips_cfun_call_saved_reg_p (unsigned int regno)
 {
+  /* Interrupt handlers need to save extra registers.  */
+  if (cfun->machine->interrupt_handler_p
+      && mips_interrupt_extra_call_saved_reg_p (regno))
+    return true;
+
   /* call_insns preserve $28 unless they explicitly say otherwise,
      so call_really_used_regs[] treats $28 as call-saved.  However,
      we want the ABI property rather than the default call_insn
@@ -8537,6 +9241,13 @@ mips_cfun_might_clobber_call_saved_reg_p (unsigned int regno)
   if (regno == GP_REG_FIRST + 31 && mips16_cfun_returns_in_fpr_p ())
     return true;
 
+  /* If REGNO is ordinarily call-clobbered, we must assume that any
+     called function could modify it.  */
+  if (cfun->machine->interrupt_handler_p
+      && !current_function_is_leaf
+      && mips_interrupt_extra_call_saved_reg_p (regno))
+    return true;
+
   return false;
 }
 
@@ -8592,6 +9303,14 @@ mips_save_reg_p (unsigned int regno)
       C |  callee-allocated save area   |
 	|  for register varargs         |
 	|                               |
+	+-------------------------------+ <-- frame_pointer_rtx
+	|                               |       + cop0_sp_offset
+	|  COP0 reg save area           |	+ UNITS_PER_WORD
+	|                               |
+	+-------------------------------+ <-- frame_pointer_rtx + acc_sp_offset
+	|                               |       + UNITS_PER_WORD
+	|  accumulator save area        |
+	|                               |
 	+-------------------------------+ <-- frame_pointer_rtx + fp_sp_offset
 	|                               |       + UNITS_PER_HWFPVALUE
 	|  FPR save area                |
@@ -8635,6 +9354,28 @@ mips_compute_frame_info (void)
   HOST_WIDE_INT offset, size;
   unsigned int regno, i;
 
+  /* Set this function's interrupt properties.  */
+  if (mips_interrupt_type_p (TREE_TYPE (current_function_decl)))
+    {
+      if (!ISA_MIPS32R2)
+	error ("the %<interrupt%> attribute requires a MIPS32r2 processor");
+      else if (TARGET_HARD_FLOAT)
+	error ("the %<interrupt%> attribute requires %<-msoft-float%>");
+      else if (TARGET_MIPS16)
+	error ("interrupt handlers cannot be MIPS16 functions");
+      else
+	{
+	  cfun->machine->interrupt_handler_p = true;
+	  cfun->machine->use_shadow_register_set_p =
+	    mips_use_shadow_register_set_p (TREE_TYPE (current_function_decl));
+	  cfun->machine->keep_interrupts_masked_p =
+	    mips_keep_interrupts_masked_p (TREE_TYPE (current_function_decl));
+	  cfun->machine->use_debug_exception_return_p =
+	    mips_use_debug_exception_return_p (TREE_TYPE
+					       (current_function_decl));
+	}
+    }
+
   frame = &cfun->machine->frame;
   memset (frame, 0, sizeof (*frame));
   size = get_frame_size ();
@@ -8704,7 +9445,7 @@ mips_compute_frame_info (void)
     }
 
   /* Find out which FPRs we need to save.  This loop must iterate over
-     the same space as its companion in mips_for_each_saved_reg.  */
+     the same space as its companion in mips_for_each_saved_gpr_and_fpr.  */
   if (TARGET_HARD_FLOAT)
     for (regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno += MAX_FPRS_PER_FMT)
       if (mips_save_reg_p (regno))
@@ -8720,6 +9461,47 @@ mips_compute_frame_info (void)
       frame->fp_sp_offset = offset - UNITS_PER_HWFPVALUE;
     }
 
+  /* Add in space for the interrupt context information.  */
+  if (cfun->machine->interrupt_handler_p)
+    {
+      /* Check HI/LO.  */
+      if (mips_save_reg_p (LO_REGNUM) || mips_save_reg_p (HI_REGNUM))
+	{
+	  frame->num_acc++;
+	  frame->acc_mask |= (1 << 0);
+	}
+
+      /* Check accumulators 1, 2, 3.  */
+      for (i = DSP_ACC_REG_FIRST; i <= DSP_ACC_REG_LAST; i += 2)
+	if (mips_save_reg_p (i) || mips_save_reg_p (i + 1))
+	  {
+	    frame->num_acc++;
+	    frame->acc_mask |= 1 << (((i - DSP_ACC_REG_FIRST) / 2) + 1);
+	  }
+
+      /* All interrupt context functions need space to preserve STATUS.  */
+      frame->num_cop0_regs++;
+
+      /* If we don't keep interrupts masked, we need to save EPC.  */
+      if (!cfun->machine->keep_interrupts_masked_p)
+	frame->num_cop0_regs++;
+    }
+
+  /* Move above the accumulator save area.  */
+  if (frame->num_acc > 0)
+    {
+      /* Each accumulator needs 2 words.  */
+      offset += frame->num_acc * 2 * UNITS_PER_WORD;
+      frame->acc_sp_offset = offset - UNITS_PER_WORD;
+    }
+
+  /* Move above the COP0 register save area.  */
+  if (frame->num_cop0_regs > 0)
+    {
+      offset += frame->num_cop0_regs * UNITS_PER_WORD;
+      frame->cop0_sp_offset = offset - UNITS_PER_WORD;
+    }
+
   /* Move above the callee-allocated varargs save area.  */
   offset += MIPS_STACK_ALIGN (cfun->machine->varargs_size);
   frame->arg_pointer_offset = offset;
@@ -8733,6 +9515,10 @@ mips_compute_frame_info (void)
     frame->gp_save_offset = frame->gp_sp_offset - offset;
   if (frame->fp_sp_offset > 0)
     frame->fp_save_offset = frame->fp_sp_offset - offset;
+  if (frame->acc_sp_offset > 0)
+    frame->acc_save_offset = frame->acc_sp_offset - offset;
+  if (frame->num_cop0_regs > 0)
+    frame->cop0_save_offset = frame->cop0_sp_offset - offset;
 
   /* MIPS16 code offsets the frame pointer by the size of the outgoing
      arguments.  This tends to increase the chances of using unextended
@@ -8929,12 +9715,160 @@ mips_save_restore_reg (enum machine_mode mode, int regno,
   fn (gen_rtx_REG (mode, regno), mem);
 }
 
+/* Call FN for each accumlator that is saved by the current function.
+   SP_OFFSET is the offset of the current stack pointer from the start
+   of the frame.  */
+
+static void
+mips_for_each_saved_acc (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)
+{
+  HOST_WIDE_INT offset;
+  int regno;
+
+  offset = cfun->machine->frame.acc_sp_offset - sp_offset;
+  if (BITSET_P (cfun->machine->frame.acc_mask, 0))
+    {
+      mips_save_restore_reg (word_mode, LO_REGNUM, offset, fn);
+      offset -= UNITS_PER_WORD;
+      mips_save_restore_reg (word_mode, HI_REGNUM, offset, fn);
+      offset -= UNITS_PER_WORD;
+    }
+
+  for (regno = DSP_ACC_REG_FIRST; regno <= DSP_ACC_REG_LAST; regno++)
+    if (BITSET_P (cfun->machine->frame.acc_mask,
+		  ((regno - DSP_ACC_REG_FIRST) / 2) + 1))
+      {
+	mips_save_restore_reg (word_mode, regno, offset, fn);
+	offset -= UNITS_PER_WORD;
+      }
+}
+
+static void mips_save_reg (rtx reg, rtx mem);
+
+/* Build microMIPS save or restore.  FN is save or restore function.
+   OFFSET is the current stack offset.
+   Return true if we succeed creating save or restore.  */
+
+static bool
+micromips_build_save_restore (mips_save_restore_fn fn,
+			      HOST_WIDE_INT offset)
+{
+  int i, num_of_reg;
+  unsigned int j;
+  rtx pattern, set, reg, mem;
+  HOST_WIDE_INT this_offset;
+  rtx this_base;
+  unsigned int type[19] = {0x00010000, 0x00030000, 0x00070000, 0x000f0000,
+			   0x001f0000, 0x003f0000, 0x007f0000, 0x00ff0000,
+			   0x40ff0000, 0x80000000, 0x80010000, 0x80030000,
+			   0x80070000, 0x800f0000, 0x801f0000, 0x803f0000,
+			   0x807f0000, 0x80ff0000, 0xc0ff0000};
+  unsigned int encode[19] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19,
+			     20, 21, 22, 23, 24, 25};
+
+  /* LWM/SWM can only support offsets from -2048 to 2047.  */
+  if (offset < -2048 || offset > 2047)
+    return false;
+
+  /* Try matching $16 to $31 (s0 to ra).  */
+  for (i = 0; i < 19; i++)
+    if ((cfun->machine->frame.mask & 0xffff0000) == type[i])
+      break;
+
+  if (i == 19)
+    {
+      /* Try matching $16 to $23 (s0 to s7) only.  */
+      for (i = 0; i < 8; i ++)
+	if ((cfun->machine->frame.mask & 0x00ff0000) == type[i])
+	  break;
+
+      if (i == 8)
+	return false;
+    }
+
+  /* For only one register, we use normal sw/lw for speed.  */
+  if (i == 0 || i == 9)
+    return false;
+
+  /* For $31 to $24.  */
+  if (i < 8 && (cfun->machine->frame.mask & 0xff000000))
+    {
+      int regno;
+      for (regno = GP_REG_LAST; regno > GP_REG_LAST - 8; regno--)
+	if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))
+	  {
+	    mips_save_restore_reg (word_mode, regno, offset, fn);
+	    offset -= UNITS_PER_WORD;
+	  }
+    }
+
+  /* Adjust offset for output.  */
+  num_of_reg = (encode[i] & 0xf) + (encode[i] >> 4);
+  offset -= (UNITS_PER_WORD * (num_of_reg - 1));
+
+  /* Create the final PARALLEL.  */
+  pattern = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num_of_reg));
+
+  this_base = stack_pointer_rtx;
+  this_offset = offset;
+
+  /* For $16-$23, $30.  */
+  for (j = 0; j < (encode[i] & 0xf); j++)
+    {
+      unsigned int regno;
+      mem = gen_frame_mem (SImode, plus_constant (this_base,
+			   this_offset + j * UNITS_PER_WORD));
+      regno = (j != 8) ? 16 + j : 30;
+      reg = gen_rtx_REG (SImode, regno);
+      if (fn == mips_save_reg)
+	set = mips_frame_set (mem, reg);
+      else
+	set = gen_rtx_SET (VOIDmode, reg, mem);
+      XVECEXP (pattern, 0, j) = set;
+    }
+
+  /* For $31.  */
+  if (encode[i] >> 4)
+    {
+      mem = gen_frame_mem (SImode, plus_constant (this_base,
+			   this_offset + j * UNITS_PER_WORD));
+      reg = gen_rtx_REG (SImode, 31);
+      if (fn == mips_save_reg)
+	set = mips_frame_set (mem, reg);
+      else
+	set = gen_rtx_SET (VOIDmode, reg, mem);
+      XVECEXP (pattern, 0, j) = set;
+    }
+
+  pattern = emit_insn (pattern);
+  if (fn == mips_save_reg)
+    RTX_FRAME_RELATED_P(pattern) = 1;  
+
+  /* Adjust the last offset.  */
+  offset -= UNITS_PER_WORD;
+
+  /* For $15 to $0.  */
+  if (cfun->machine->frame.mask & 0xffff)
+    {
+      int regno;
+      for (regno = GP_REG_FIRST + 15; regno >= GP_REG_FIRST; regno--)
+	if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))
+	  {
+	    mips_save_restore_reg (word_mode, regno, offset, fn);
+	    offset -= UNITS_PER_WORD;
+	  }
+    }
+
+  return true;
+}
+
 /* Call FN for each register that is saved by the current function.
    SP_OFFSET is the offset of the current stack pointer from the start
    of the frame.  */
 
 static void
-mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)
+mips_for_each_saved_gpr_and_fpr (HOST_WIDE_INT sp_offset,
+				 mips_save_restore_fn fn)
 {
   enum machine_mode fpr_mode;
   HOST_WIDE_INT offset;
@@ -8945,6 +9879,13 @@ mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)
      need a nop in the epilogue if at least one register is reloaded in
      addition to return address.  */
   offset = cfun->machine->frame.gp_sp_offset - sp_offset;
+
+  if (TARGET_MICROMIPS)
+    {
+      if (micromips_build_save_restore (fn, offset))
+	goto save_restore_fp_reg;
+    }
+
   for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)
     if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))
       {
@@ -8952,6 +9893,8 @@ mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)
 	offset -= UNITS_PER_WORD;
       }
 
+  save_restore_fp_reg:
+
   /* This loop must iterate over the same space as its companion in
      mips_compute_frame_info.  */
   offset = cfun->machine->frame.fp_sp_offset - sp_offset;
@@ -9122,13 +10065,24 @@ mips_save_reg (rtx reg, rtx mem)
     }
   else
     {
-      if (TARGET_MIPS16
-	  && REGNO (reg) != GP_REG_FIRST + 31
-	  && !M16_REG_P (REGNO (reg)))
+      if (REGNO (reg) == HI_REGNUM)
+	{
+	  if (TARGET_64BIT)
+	    emit_insn (gen_mfhidi_ti (MIPS_PROLOGUE_TEMP (DImode),
+				      gen_rtx_REG (TImode, MD_REG_FIRST)));
+	  else
+	    emit_insn (gen_mfhisi_di (MIPS_PROLOGUE_TEMP (SImode),
+				      gen_rtx_REG (DImode, MD_REG_FIRST)));
+	  mips_emit_move (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));
+	}
+      else if ((TARGET_MIPS16
+		&& REGNO (reg) != GP_REG_FIRST + 31
+		&& !M16_REG_P (REGNO (reg)))
+	       || ACC_REG_P (REGNO (reg)))
 	{
-	  /* Save a non-MIPS16 register by moving it through a temporary.
-	     We don't need to do this for $31 since there's a special
-	     instruction for it.  */
+	  /* If the register has no direct store instruction, move it
+	     through a temporary.  Note that there's a special MIPS16
+	     instruction to save $31.  */
 	  mips_emit_move (MIPS_PROLOGUE_TEMP (GET_MODE (reg)), reg);
 	  mips_emit_move (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));
 	}
@@ -9200,6 +10154,14 @@ mips_emit_loadgp (void)
     emit_insn (gen_loadgp_blockage ());
 }
 
+/* A for_each_rtx callback.  Stop the search if *X is a kernel register.  */
+
+static int
+mips_kernel_reg_p (rtx *x, void *data ATTRIBUTE_UNUSED)
+{
+  return GET_CODE (*x) == REG && KERNEL_REG_P (REGNO (*x));
+}
+
 /* Expand the "prologue" pattern.  */
 
 void
@@ -9219,7 +10181,8 @@ mips_expand_prologue (void)
   /* Save the registers.  Allocate up to MIPS_MAX_FIRST_STACK_STEP
      bytes beforehand; this is enough to cover the register save area
      without going out of range.  */
-  if ((frame->mask | frame->fmask) != 0)
+  if (((frame->mask | frame->fmask | frame->acc_mask) != 0)
+      || frame->num_cop0_regs > 0)
     {
       HOST_WIDE_INT step1;
 
@@ -9250,24 +10213,109 @@ mips_expand_prologue (void)
  	}
       else
  	{
-	  insn = gen_add3_insn (stack_pointer_rtx,
-				stack_pointer_rtx,
-				GEN_INT (-step1));
-	  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
-	  size -= step1;
-	  mips_for_each_saved_reg (size, mips_save_reg);
-	}
-    }
+	  if (cfun->machine->interrupt_handler_p)
+	    {
+	      HOST_WIDE_INT offset;
+	      rtx mem;
 
-  /* Allocate the rest of the frame.  */
-  if (size > 0)
-    {
-      if (SMALL_OPERAND (-size))
-	RTX_FRAME_RELATED_P (emit_insn (gen_add3_insn (stack_pointer_rtx,
-						       stack_pointer_rtx,
-						       GEN_INT (-size)))) = 1;
-      else
-	{
+	      /* If this interrupt is using a shadow register set, we need to
+		 get the stack pointer from the previous register set.  */
+	      if (cfun->machine->use_shadow_register_set_p)
+		emit_insn (gen_mips_rdpgpr (stack_pointer_rtx,
+					    stack_pointer_rtx));
+
+	      if (!cfun->machine->keep_interrupts_masked_p)
+		{
+		  /* Move from COP0 Cause to K0.  */
+		  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K0_REG_NUM),
+					    gen_rtx_REG (SImode,
+							 COP0_CAUSE_REG_NUM)));
+		  /* Move from COP0 EPC to K1.  */
+		  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K1_REG_NUM),
+					    gen_rtx_REG (SImode,
+							 COP0_EPC_REG_NUM)));
+		}
+
+	      /* Allocate the first part of the frame.  */
+	      insn = gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,
+				    GEN_INT (-step1));
+	      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
+	      size -= step1;
+
+	      /* Start at the uppermost location for saving.  */
+	      offset = frame->cop0_sp_offset - size;
+	      if (!cfun->machine->keep_interrupts_masked_p)
+		{
+		  /* Push EPC into its stack slot.  */
+		  mem = gen_frame_mem (word_mode,
+				       plus_constant (stack_pointer_rtx,
+						      offset));
+		  mips_emit_move (mem, gen_rtx_REG (word_mode, K1_REG_NUM));
+		  offset -= UNITS_PER_WORD;
+		}
+
+	      /* Move from COP0 Status to K1.  */
+	      emit_insn (gen_cop0_move (gen_rtx_REG (SImode, K1_REG_NUM),
+					gen_rtx_REG (SImode,
+						     COP0_STATUS_REG_NUM)));
+
+	      /* Right justify the RIPL in k0.  */
+	      if (!cfun->machine->keep_interrupts_masked_p)
+		emit_insn (gen_lshrsi3 (gen_rtx_REG (SImode, K0_REG_NUM),
+					gen_rtx_REG (SImode, K0_REG_NUM),
+					GEN_INT (CAUSE_IPL)));
+
+	      /* Push Status into its stack slot.  */
+	      mem = gen_frame_mem (word_mode,
+				   plus_constant (stack_pointer_rtx, offset));
+	      mips_emit_move (mem, gen_rtx_REG (word_mode, K1_REG_NUM));
+	      offset -= UNITS_PER_WORD;
+
+	      /* Insert the RIPL into our copy of SR (k1) as the new IPL.  */
+	      if (!cfun->machine->keep_interrupts_masked_p)
+		emit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),
+				       GEN_INT (6),
+				       GEN_INT (SR_IPL),
+				       gen_rtx_REG (SImode, K0_REG_NUM)));
+
+	      if (!cfun->machine->keep_interrupts_masked_p)
+		/* Enable interrupts by clearing the KSU ERL and EXL bits.
+		   IE is already the correct value, so we don't have to do
+		   anything explicit.  */
+		emit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),
+				       GEN_INT (4),
+				       GEN_INT (SR_EXL),
+				       gen_rtx_REG (SImode, GP_REG_FIRST)));
+	      else
+		/* Disable interrupts by clearing the KSU, ERL, EXL,
+		   and IE bits.  */
+		emit_insn (gen_insvsi (gen_rtx_REG (SImode, K1_REG_NUM),
+				       GEN_INT (5),
+				       GEN_INT (SR_IE),
+				       gen_rtx_REG (SImode, GP_REG_FIRST)));
+	    }
+	  else
+	    {
+	      insn = gen_add3_insn (stack_pointer_rtx,
+				    stack_pointer_rtx,
+				    GEN_INT (-step1));
+	      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
+	      size -= step1;
+	    }
+	  mips_for_each_saved_acc (size, mips_save_reg);
+	  mips_for_each_saved_gpr_and_fpr (size, mips_save_reg);
+	}
+    }
+
+  /* Allocate the rest of the frame.  */
+  if (size > 0)
+    {
+      if (SMALL_OPERAND (-size))
+	RTX_FRAME_RELATED_P (emit_insn (gen_add3_insn (stack_pointer_rtx,
+						       stack_pointer_rtx,
+						       GEN_INT (-size)))) = 1;
+      else
+	{
 	  mips_emit_move (MIPS_PROLOGUE_TEMP (Pmode), GEN_INT (size));
 	  if (TARGET_MIPS16)
 	    {
@@ -9340,6 +10388,20 @@ mips_expand_prologue (void)
 			pic_offset_table_rtx);
     }
 
+  /* We need to search back to the last use of K0 or K1.  */
+  if (cfun->machine->interrupt_handler_p)
+    {
+      for (insn = get_last_insn (); insn != NULL_RTX; insn = PREV_INSN (insn))
+	if (INSN_P (insn)
+	    && for_each_rtx (&PATTERN (insn), mips_kernel_reg_p, NULL))
+	  break;
+      /* Emit a move from K1 to COP0 Status after insn.  */
+      gcc_assert (insn != NULL_RTX);
+      emit_insn_after (gen_cop0_move (gen_rtx_REG (SImode, COP0_STATUS_REG_NUM),
+				      gen_rtx_REG (SImode, K1_REG_NUM)),
+		       insn);
+    }
+
   /* If we are profiling, make sure no instructions are scheduled before
      the call to mcount.  */
   if (crtl->profile)
@@ -9356,7 +10418,20 @@ mips_restore_reg (rtx reg, rtx mem)
   if (TARGET_MIPS16 && REGNO (reg) == GP_REG_FIRST + 31)
     reg = gen_rtx_REG (GET_MODE (reg), GP_REG_FIRST + 7);
 
-  if (TARGET_MIPS16 && !M16_REG_P (REGNO (reg)))
+  if (REGNO (reg) == HI_REGNUM)
+    {
+      mips_emit_move (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);
+      if (TARGET_64BIT)
+	emit_insn (gen_mthisi_di (gen_rtx_REG (TImode, MD_REG_FIRST),
+				  MIPS_EPILOGUE_TEMP (DImode),
+				  gen_rtx_REG (DImode, LO_REGNUM)));
+      else
+	emit_insn (gen_mthisi_di (gen_rtx_REG (DImode, MD_REG_FIRST),
+				  MIPS_EPILOGUE_TEMP (SImode),
+				  gen_rtx_REG (SImode, LO_REGNUM)));
+    }
+  else if ((TARGET_MIPS16 && !M16_REG_P (REGNO (reg)))
+	   || ACC_REG_P (REGNO (reg)))
     {
       /* Can't restore directly; move through a temporary.  */
       mips_emit_move (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);
@@ -9392,7 +10467,8 @@ mips_expand_epilogue (bool sibcall_p)
 {
   const struct mips_frame_info *frame;
   HOST_WIDE_INT step1, step2;
-  rtx base, target;
+  rtx base, target, insn;
+  bool use_jraddiusp_p = false;
 
   if (!sibcall_p && mips_can_use_return_insn ())
     {
@@ -9425,7 +10501,8 @@ mips_expand_epilogue (bool sibcall_p)
 
   /* If we need to restore registers, deallocate as much stack as
      possible in the second step without going out of range.  */
-  if ((frame->mask | frame->fmask) != 0)
+  if ((frame->mask | frame->fmask | frame->acc_mask) != 0
+      || frame->num_cop0_regs > 0)
     {
       step2 = MIN (step1, MIPS_MAX_FIRST_STACK_STEP);
       step1 -= step2;
@@ -9487,13 +10564,61 @@ mips_expand_epilogue (bool sibcall_p)
   else
     {
       /* Restore the registers.  */
-      mips_for_each_saved_reg (frame->total_size - step2, mips_restore_reg);
+      mips_for_each_saved_acc (frame->total_size - step2, mips_restore_reg);
+      mips_for_each_saved_gpr_and_fpr (frame->total_size - step2,
+				       mips_restore_reg);
+
+      /* Check if we can use jraddiusp.  */
+      use_jraddiusp_p = (TARGET_MICROMIPS
+			 && !crtl->calls_eh_return
+			 && !sibcall_p
+			 && step2 > 0
+			 && (step2 & 3) == 0
+			 && step2 <= (31 << 2));
+
+      if (cfun->machine->interrupt_handler_p)
+	{
+	  HOST_WIDE_INT offset;
+	  rtx mem;
 
-      /* Deallocate the final bit of the frame.  */
-      if (step2 > 0)
-	emit_insn (gen_add3_insn (stack_pointer_rtx,
-				  stack_pointer_rtx,
-				  GEN_INT (step2)));
+	  offset = frame->cop0_sp_offset - (frame->total_size - step2);
+	  if (!cfun->machine->keep_interrupts_masked_p)
+	    {
+	      /* Restore the original EPC.  */
+	      mem = gen_frame_mem (word_mode,
+				   plus_constant (stack_pointer_rtx, offset));
+	      mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);
+	      offset -= UNITS_PER_WORD;
+
+	      /* Move to COP0 EPC.  */
+	      emit_insn (gen_cop0_move (gen_rtx_REG (SImode, COP0_EPC_REG_NUM),
+					gen_rtx_REG (SImode, K0_REG_NUM)));
+	    }
+
+	  /* Restore the original Status.  */
+	  mem = gen_frame_mem (word_mode,
+			       plus_constant (stack_pointer_rtx, offset));
+	  mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);
+	  offset -= UNITS_PER_WORD;
+
+	  /* If we don't use shoadow register set, we need to update SP.  */
+	  if (!cfun->machine->use_shadow_register_set_p && step2 > 0)
+	    emit_insn (gen_add3_insn (stack_pointer_rtx,
+				      stack_pointer_rtx,
+				      GEN_INT (step2)));
+
+	  /* Move to COP0 Status.  */
+	  emit_insn (gen_cop0_move (gen_rtx_REG (SImode, COP0_STATUS_REG_NUM),
+				    gen_rtx_REG (SImode, K0_REG_NUM)));
+	}
+      else
+	{
+	  /* Deallocate the final bit of the frame.  */
+	  if (step2 > 0 && !use_jraddiusp_p)
+	    emit_insn (gen_add3_insn (stack_pointer_rtx,
+				      stack_pointer_rtx,
+				      GEN_INT (step2)));
+	}
     }
 
   /* Add in the __builtin_eh_return stack adjustment.  We need to
@@ -9516,18 +10641,48 @@ mips_expand_epilogue (bool sibcall_p)
 
   if (!sibcall_p)
     {
-      unsigned int regno;
-
-      /* When generating MIPS16 code, the normal mips_for_each_saved_reg
-	 path will restore the return address into $7 rather than $31.  */
-      if (TARGET_MIPS16
-	  && !GENERATE_MIPS16E_SAVE_RESTORE
-	  && BITSET_P (frame->mask, 31))
-	regno = GP_REG_FIRST + 7;
-      else
-	regno = GP_REG_FIRST + 31;
       mips_expand_before_return ();
-      emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, regno)));
+      if (cfun->machine->interrupt_handler_p)
+	{
+	  /* Interrupt handlers generate eret or deret.  */
+	  if (cfun->machine->use_debug_exception_return_p)
+	    emit_jump_insn (gen_mips_deret ());
+	  else
+	    emit_jump_insn (gen_mips_eret ());
+	}
+      else
+	{
+	  unsigned int regno;
+
+	  /* When generating MIPS16 code, the normal
+	     mips_for_each_saved_gpr_and_fpr path will restore the return
+	     address into $7 rather than $31.  */
+	  if (TARGET_MIPS16
+	      && !GENERATE_MIPS16E_SAVE_RESTORE
+	      && BITSET_P (frame->mask, 31))
+	    regno = GP_REG_FIRST + 7;
+	  else
+	    regno = GP_REG_FIRST + 31;
+
+	  if (use_jraddiusp_p)
+	    emit_jump_insn (gen_mips_jraddiusp (GEN_INT (step2)));
+	  else
+	    emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, regno)));
+	}
+    }
+
+  /* Search from the beginning to the first use of K0 or K1.  */
+  if (cfun->machine->interrupt_handler_p
+      && !cfun->machine->keep_interrupts_masked_p)
+    {
+      for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))
+	if (INSN_P (insn)
+	    && for_each_rtx (&PATTERN(insn), mips_kernel_reg_p, NULL))
+	  break;
+      gcc_assert (insn != NULL_RTX);
+      /* Insert disable interrupts before the first use of K0 or K1.  */
+      emit_insn_before (gen_mips_di (), insn);
+      emit_insn_before (gen_mips_ehb (), insn);
     }
 }
 
@@ -9538,6 +10693,10 @@ mips_expand_epilogue (bool sibcall_p)
 bool
 mips_can_use_return_insn (void)
 {
+  /* Interrupt handlers need to go through the epilogue.  */
+  if (cfun->machine->interrupt_handler_p)
+    return false;
+
   if (!reload_completed)
     return false;
 
@@ -10469,10 +11628,15 @@ mips_output_division (const char *division, rtx *operands)
 	  s = "bnez\t%2,1f\n\tbreak\t7\n1:";
 	}
       else if (GENERATE_DIVIDE_TRAPS)
-        {
-	  output_asm_insn (s, operands);
-	  s = "teq\t%2,%.,7";
-        }
+	{
+	  if (TUNE_74K)
+	    output_asm_insn ("teq\t%2,%.,7", operands);
+	  else
+	    {
+	      output_asm_insn (s, operands);
+	      s = "teq\t%2,%.,7";
+	    }
+	}
       else
 	{
 	  output_asm_insn ("%(bne\t%2,%.,1f", operands);
@@ -10784,7 +11948,17 @@ mips_maybe_swap_ready (rtx *ready, int pos1, int pos2, int limit)
       ready[pos2] = temp;
     }
 }
-
+
+int
+mips_mult_madd_chain_bypass_p (rtx out_insn ATTRIBUTE_UNUSED,
+			       rtx in_insn ATTRIBUTE_UNUSED)
+{
+  if (reload_completed)
+    return false;
+  else
+    return true;
+}
+
 /* Used by TUNE_MACC_CHAINS to record the last scheduled instruction
    that may clobber hi or lo.  */
 static rtx mips_macc_chains_last_hilo;
@@ -13483,7 +14657,7 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   reload_completed = 0;
 }
 
-/* The last argument passed to mips_set_mips16_mode, or negative if the
+/* The last argument passed to mips_set_mips16_micromips_mode, or negative if the
    function hasn't been called yet.
 
    There are two copies of this information.  One is saved and restored
@@ -13491,16 +14665,20 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
    invocation.  The information calculated by mips_set_mips16_mode
    is invalid unless the two variables are the same.  */
 static int was_mips16_p = -1;
+static int was_micromips_p = -1;
 static GTY(()) int was_mips16_pch_p = -1;
+static GTY(()) int was_micromips_pch_p = -1;
 
 /* Set up the target-dependent global state so that it matches the
    current function's ISA mode.  */
 
 static void
-mips_set_mips16_mode (int mips16_p)
+mips_set_mips16_micromips_mode (int mips16_p, int micromips_p)
 {
   if (mips16_p == was_mips16_p
-      && mips16_p == was_mips16_pch_p)
+      && micromips_p == was_micromips_p
+      && mips16_p == was_mips16_pch_p
+      && micromips_p == was_micromips_pch_p)
     return;
 
   /* Restore base settings of various flags.  */
@@ -13556,6 +14734,18 @@ mips_set_mips16_mode (int mips16_p)
       /* Switch to normal (non-MIPS16) mode.  */
       target_flags &= ~MASK_MIPS16;
 
+      if (micromips_p)
+	{
+	  /* Switch to microMIPS mode.  */
+	  target_flags |= MASK_MICROMIPS;
+
+	  /* Avoid branch likely.  */
+	  target_flags &= ~MASK_BRANCHLIKELY;
+	}
+      else
+	/* Switch to normal (non-microMIPS) mode.  */
+	target_flags &= ~MASK_MICROMIPS;
+
       /* Provide default values for align_* for 64-bit targets.  */
       if (TARGET_64BIT)
 	{
@@ -13578,8 +14768,10 @@ mips_set_mips16_mode (int mips16_p)
     /* Reinitialize target-dependent state.  */
     target_reinit ();
 
+  was_micromips_p = micromips_p;
   was_mips16_p = mips16_p;
   was_mips16_pch_p = mips16_p;
+  was_micromips_pch_p = micromips_p;
 }
 
 /* Implement TARGET_SET_CURRENT_FUNCTION.  Decide whether the current
@@ -13588,7 +14780,48 @@ mips_set_mips16_mode (int mips16_p)
 static void
 mips_set_current_function (tree fndecl)
 {
-  mips_set_mips16_mode (mips_use_mips16_mode_p (fndecl));
+  mips_set_mips16_micromips_mode (mips_use_mips16_mode_p (fndecl),
+				  mips_use_micromips_mode_p (fndecl));
+}
+
+/* A for_each_rtx callback.  Stop the search if *X is an AT register.  */
+
+static int
+mips_at_reg_p (rtx *x, void *data ATTRIBUTE_UNUSED)
+{
+  return GET_CODE (*x) == REG && REGNO (*x) == AT_REGNUM;
+}
+
+
+/* Implement FINAL_PRESCAN_INSN.  */
+
+void
+mips_final_prescan_insn (rtx insn, rtx *opvec, int noperands)
+{
+  int i;
+
+  /* We need to emit ".set noat" before an instruction that accesses
+     $1 (AT).  */
+  if (recog_memoized (insn) >= 0)
+    for (i = 0; i < noperands; i++)
+      if (for_each_rtx (&opvec[i], mips_at_reg_p, NULL))
+	if (set_noat++ == 0)
+	  fprintf (asm_out_file, "\t.set\tnoat\n");
+}
+
+/* Implement TARGET_ASM_FINAL_POSTSCAN_INSN.  */
+
+static void
+mips_final_postscan_insn (FILE *file, rtx insn, rtx *opvec, int noperands)
+{
+  int i;
+
+  /* Close any ".set noat" block opened by mips_final_prescan_insn.  */
+  if (recog_memoized (insn) >= 0)
+    for (i = 0; i < noperands; i++)
+      if (for_each_rtx (&opvec[i], mips_at_reg_p, NULL))
+	if (--set_noat == 0)
+	  fprintf (file, "\t.set\tat\n");
 }
 
 /* Allocate a chunk of memory for per-function machine-dependent data.  */
@@ -13800,6 +15033,13 @@ mips_override_options (void)
   mips_base_mips16 = TARGET_MIPS16;
   target_flags &= ~MASK_MIPS16;
 
+  mips_base_micromips = TARGET_MICROMIPS;
+  target_flags &= ~MASK_MICROMIPS;
+
+  /* MIPS16 and microMIPS cannot coexist  */
+  if (TARGET_MICROMIPS && TARGET_MIPS16)
+    error ("unsupported combination: %s", "-mips16 -mmicromips");
+
 #ifdef SUBTARGET_OVERRIDE_OPTIONS
   SUBTARGET_OVERRIDE_OPTIONS;
 #endif
@@ -13957,6 +15197,14 @@ mips_override_options (void)
        long as any indirect jumps use $25.  */
     flag_pic = 1;
 
+  /* For SDE, switch on ABICALLS mode if -fpic or -fpie were used, and the
+     user hasn't explicitly disabled these modes.  */
+  if (TARGET_MIPS_SDE
+      && (flag_pic || flag_pie) && !TARGET_ABICALLS
+      && !((target_flags_explicit & MASK_ABICALLS))
+      && mips_abi != ABI_EABI)
+    target_flags |= MASK_ABICALLS;
+
   /* -mvr4130-align is a "speed over size" optimization: it usually produces
      faster code, but at the expense of more nops.  Enable it at -O3 and
      above.  */
@@ -14157,7 +15405,7 @@ mips_override_options (void)
 
      Do all CPP-sensitive stuff in non-MIPS16 mode; we'll switch to
      MIPS16 mode afterwards if need be.  */
-  mips_set_mips16_mode (false);
+  mips_set_mips16_micromips_mode (mips_base_mips16, mips_base_micromips);
 }
 
 /* Swap the register information for registers I and I + 1, which
@@ -14309,6 +15557,431 @@ mips_order_regs_for_local_alloc (void)
       reg_alloc_order[24] = 0;
     }
 }
+
+/* Implement EPILOGUE_USES.  */
+
+bool
+mips_epilogue_uses (unsigned int regno)
+{
+  /* Say that the epilogue uses the return address register.  Note that
+     in the case of sibcalls, the values "used by the epilogue" are
+     considered live at the start of the called function.  */
+  if (regno == 31)
+    return true;
+
+  /* If using a GOT, say that the epilogue also uses GOT_VERSION_REGNUM.
+     See the comment above load_call<mode> for details.  */
+  if (TARGET_USE_GOT && (regno) == GOT_VERSION_REGNUM)
+    return true;
+
+  /* An interrupt handler must preserve some registers that are
+     ordinarily call-clobbered.  */
+  if (cfun->machine->interrupt_handler_p
+      && mips_interrupt_extra_call_saved_reg_p (regno))
+    return true;
+
+  return false;
+}
+
+/* Return true if PATTERN matches the kind of instruction generated by
+   micromips_build_save_restore.  SAVE_P is true for store.  */
+
+bool
+micromips_save_restore_pattern_p (bool save_p, rtx pattern)
+{
+  int n;
+  HOST_WIDE_INT first_offset = 0;
+  rtx first_base = 0;
+  unsigned int first_regno = 0;
+
+  for (n = 0; n < XVECLEN (pattern, 0); n++)
+    {
+      rtx set, reg, mem, this_base;
+      HOST_WIDE_INT this_offset;
+      unsigned int this_regno;
+
+      /* Check that we have a SET.  */
+      set = XVECEXP (pattern, 0, n);
+      if (GET_CODE (set) != SET)
+	return false;
+
+      /* Check that the SET is a load (if restoring) or a store
+	 (if saving).  */
+      mem = save_p ? SET_DEST (set) : SET_SRC (set);
+      if (!MEM_P (mem))
+	return false;
+
+      /* Check that the address is the sum of base and a
+	 possibly-zero constant offset.  */
+      mips_split_plus (XEXP (mem, 0), &this_base, &this_offset);
+      if (!REG_P (this_base))
+	return false;
+
+      if (n == 0)
+	{
+	  first_base = this_base;
+	  first_offset = this_offset;
+	}
+      else
+	{
+	  /* Check if this_base is the same as first_base.  */
+	  if (REGNO (this_base) != REGNO (first_base))
+	    return false;
+
+	  /* Check if this_offset is first_offset + UNITS_PER_WORD * n.  */
+	  if (this_offset != first_offset + UNITS_PER_WORD * n)
+	    return false;
+	}
+
+      /* Check that SET's other operand is a register.  */
+      reg = save_p ? SET_SRC (set) : SET_DEST (set);
+      if (!REG_P (reg))
+	return false;
+
+      /* Make sure the order of regno is "$16-$23, $30, $31", "$16-$23, $30",
+	 or "$31".  */
+      this_regno = REGNO (reg);
+      if (n == 0)
+	{
+	  if (this_regno != 16 && this_regno != 31)
+	    return false;
+	  first_regno = this_regno;
+	}
+      else if (n == 8) /* For s8.  */
+	{
+	  if (n == XVECLEN (pattern, 0) - 1)
+	    {
+	      if (this_regno != 30 && this_regno != 31)
+		return false;
+	    }
+	  else
+	    {
+	      if (this_regno != 30)
+		return false;
+	    }
+	}
+      else if (n != XVECLEN (pattern, 0) - 1)
+	{
+	  if (this_regno != first_regno + n)
+	    return false;
+	}
+      else /* The last item.  */
+	{
+	  if ((this_regno != first_regno + n) && this_regno != 31)
+	    return false;
+	}
+    }
+
+  return true;
+}
+
+/* Return the assembly instruction for microMIPS lwm or swm.
+   SAVE_P and PATTERN are as for micromips_save_restore_pattern_p.  */
+
+const char *
+micromips_output_save_restore (bool save_p, rtx pattern)
+{
+  static char buffer[300];
+  char *s;
+  int n;
+  HOST_WIDE_INT offset;
+  rtx base, mem, set, reg, last_set, last_reg;
+
+  /* Parse the pattern.  */
+  if (!micromips_save_restore_pattern_p (save_p, pattern))
+    gcc_unreachable ();
+
+  s = strcpy (buffer, save_p ? "swm\t" : "lwm\t");
+  s += strlen (s);
+  n = XVECLEN (pattern, 0);
+
+  set = XVECEXP (pattern, 0, 0);
+  reg = save_p ? SET_SRC (set) : SET_DEST (set);
+  mem = save_p ? SET_DEST (set) : SET_SRC (set);
+  mips_split_plus (XEXP (mem, 0), &base, &offset);
+
+  last_set = XVECEXP (pattern, 0, n - 1);
+  last_reg = save_p ? SET_SRC (last_set) : SET_DEST (last_set);
+
+  if (REGNO (last_reg) == 31)
+    n--;
+
+  if (n == 0)
+    ;
+  else if (n == 1)
+    s += sprintf (s, "%s,", reg_names[16]);
+  else if (n < 9)
+    s += sprintf (s, "%s-%s,", reg_names[16], reg_names[15 + n]);
+  else if (n == 9)
+    s += sprintf (s, "%s-%s,%s,", reg_names[16], reg_names[23],
+		  reg_names[30]);
+  else
+    gcc_unreachable ();
+
+  if (REGNO (last_reg) == 31)
+    s += sprintf (s, "%s,", reg_names[31]);
+
+  s += sprintf (s, "%d(%s)", (int)offset, reg_names[REGNO (base)]);
+  return buffer;
+}
+
+/* Return true if MEM1 and MEM2 use the same base register, and the
+   offset of MEM2 equals the offset of MEM1 plus 4.  FIRST_REG is the
+   register into (from) which the contents of MEM1 will be loaded
+   (stored), depending on the value of LOAD_P.
+   SWAP_P is true when the 1st and 2nd instructions are swapped.  */
+
+bool
+micromips_load_store_pair_p (bool load_p, bool swap_p, rtx first_reg, rtx mem1, rtx mem2)
+{
+  rtx base1, base2, mem1_temp, mem2_temp;
+  HOST_WIDE_INT offset1, offset2;
+
+  if (!MEM_P (mem1) || !MEM_P (mem2))
+    return false;
+
+  mem1_temp = XEXP (mem1, 0);
+  mem2_temp = XEXP (mem2, 0);
+
+  /* Make sure memory is base plus offset.  */
+  if (GET_CODE (mem1_temp) != PLUS
+      || GET_CODE (mem2_temp) != PLUS
+      || GET_CODE (XEXP (mem1_temp, 1)) != CONST_INT
+      || GET_CODE (XEXP (mem2_temp, 1)) != CONST_INT)
+    return false;
+
+  mips_split_plus (mem1_temp, &base1, &offset1);
+  mips_split_plus (mem2_temp, &base2, &offset2);
+
+  if (!REG_P (base1) || !REG_P (base2))
+    return false;
+
+  if (REGNO (base1) != REGNO (base2))
+    return false;
+
+  /* Avoid invalid load pair instructions.  */
+  if (load_p && REGNO (first_reg) == REGNO (base1))
+    return false;
+
+  /* We must avoid this case for anti-dependence.
+     Ex:  lw $3, 4($3)
+          lw $2, 0($3)
+     first_reg is $2, but the base is $3.  */
+  if (load_p && swap_p && (REGNO (first_reg) + 1) == REGNO (base1))
+    return false;
+
+  if (offset1 + 4 != offset2)
+    return false;
+
+  if (offset1 < -2048 || offset1 > 2047)
+    return false;
+
+  return true;
+}
+
+/* Return the assembly instruction for microMIPS lwp or swp.
+   LOAD_P is true for load.  */
+
+const char *
+micromips_output_load_store_pair (bool load_p, rtx reg, rtx mem)
+{
+  static char buffer[300];
+  HOST_WIDE_INT offset;
+  rtx base;
+
+  if (!REG_P (reg) || !MEM_P (mem))
+    gcc_unreachable ();
+
+  mips_split_plus (XEXP (mem, 0), &base, &offset);
+  if (!REG_P (base))
+    gcc_unreachable ();
+
+  sprintf (buffer, "%s\t%s,%d(%s)", load_p ? "lwp" : "swp",
+	   reg_names [REGNO (reg)], (int) offset, reg_names [REGNO (base)]);
+  return buffer;
+}
+
+/* Return true if reg1 and reg2 can be target of movep.  */
+
+bool
+micromips_movep_target_p (rtx reg1, rtx reg2)
+{
+  int regno1, regno2, pair, i;
+  int match[8] = {0x00000060,	/* 5, 6 */
+		  0x000000a0,	/* 5, 7 */
+		  0x000000c0,	/* 6, 7 */
+		  0x00200010,	/* 4, 21 */
+		  0x00400010,	/* 4, 22 */
+		  0x00000030,	/* 4, 5 */
+		  0x00000050,	/* 4, 6 */
+		  0x00000090};	/* 4, 7 */
+
+  if (!REG_P (reg1) || !REG_P (reg2))
+    return false;
+
+  regno1 = REGNO (reg1);
+  regno2 = REGNO (reg2);
+
+  if (!GP_REG_P (regno1)  || !GP_REG_P (regno2))
+    return false;
+
+  pair = (1 << regno1) | (1 << regno2);
+
+  for (i = 0; i < 8; i++)
+    {
+      if (pair == match[i])
+	return true;
+    }
+
+  return false;
+}
+
+#ifdef CVMX_SHARED_BSS_FLAGS
+/* Handle a "cvmx_shared" attribute; arguments as in 
+   struct attribute_spec.handler.  */
+
+static tree
+octeon_handle_cvmx_shared_attribute (tree *node, tree name, 
+				     tree args ATTRIBUTE_UNUSED, 
+				     int flags ATTRIBUTE_UNUSED, 
+				     bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) != VAR_DECL)
+    {
+      warning (OPT_Wattributes, "%qs attribute only applies to variables",
+              IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
+/* Switch to the appropriate section for output of DECL.
+   DECL is either a `VAR_DECL' node or a constant of some sort.
+   RELOC indicates whether forming the initial value of DECL requires
+   link-time relocations.  */
+
+static section *
+octeon_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)
+{
+  if (decl && TREE_CODE (decl) == VAR_DECL 
+      && lookup_attribute ("cvmx_shared", DECL_ATTRIBUTES (decl)))
+    {
+      const char *sname = NULL;
+      unsigned int flags = SECTION_WRITE;
+
+      switch (categorize_decl_for_section (decl, reloc))
+        {
+	  case SECCAT_DATA:
+	  case SECCAT_SDATA:
+	  case SECCAT_RODATA:
+	  case SECCAT_SRODATA:
+	  case SECCAT_RODATA_MERGE_STR:
+	  case SECCAT_RODATA_MERGE_STR_INIT:
+	  case SECCAT_RODATA_MERGE_CONST:
+	  case SECCAT_DATA_REL:
+	  case SECCAT_DATA_REL_LOCAL:
+	  case SECCAT_DATA_REL_RO:
+	  case SECCAT_DATA_REL_RO_LOCAL:
+	    sname = ".cvmx_shared";
+	    break;
+	  case SECCAT_BSS:
+	  case SECCAT_SBSS:
+	    sname = ".cvmx_shared_bss";
+	    flags |= SECTION_BSS;
+	    break;
+	  case SECCAT_TEXT:
+	  case SECCAT_TDATA:
+	  case SECCAT_TBSS:
+            break;
+        }
+      if (sname)
+	{
+	  return get_section (sname, flags, decl);
+	}
+    }
+  return default_elf_select_section (decl, reloc, align);
+}
+
+/* Build up a unique section name, expressed as a
+   STRING_CST node, and assign it to DECL_SECTION_NAME (decl).
+   RELOC indicates whether the initial value of EXP requires
+   link-time relocations.  */
+
+static void 
+octeon_unique_section (tree decl, int reloc)
+{
+  if (decl && TREE_CODE (decl) == VAR_DECL 
+      && lookup_attribute ("cvmx_shared", DECL_ATTRIBUTES (decl)))
+    {
+      const char *sname = NULL;
+
+      if (! DECL_ONE_ONLY (decl))
+	{
+	  section *sect;
+	  sect = octeon_select_section (decl, reloc, DECL_ALIGN (decl));
+	  DECL_SECTION_NAME (decl) = build_string (strlen (sect->named.name),
+						   sect->named.name);
+	  return;
+	}
+
+      switch (categorize_decl_for_section (decl, reloc))
+        {
+	  case SECCAT_BSS:
+	  case SECCAT_SBSS:
+	    sname = ".cvmx_shared_bss.linkonce."; 
+	    break;
+	  case SECCAT_SDATA:
+	  case SECCAT_DATA:
+	  case SECCAT_DATA_REL:
+	  case SECCAT_DATA_REL_LOCAL:
+	  case SECCAT_DATA_REL_RO:
+	  case SECCAT_DATA_REL_RO_LOCAL:
+	  case SECCAT_RODATA:
+	  case SECCAT_SRODATA:
+	  case SECCAT_RODATA_MERGE_STR:
+	  case SECCAT_RODATA_MERGE_STR_INIT:
+	  case SECCAT_RODATA_MERGE_CONST:
+	    sname = ".cvmx_shared.linkonce.";
+	    break;
+	  case SECCAT_TEXT:
+	  case SECCAT_TDATA:
+	  case SECCAT_TBSS:
+	    break; 
+	}
+      if (sname)
+        {
+	  const char *name;
+	  size_t plen, nlen;
+	  char *string;
+	  plen = strlen (sname);
+
+	  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+	  name = targetm.strip_name_encoding (name);
+	  nlen = strlen (name);
+
+	  string = alloca (plen + nlen + 1);
+	  memcpy (string, sname, plen);
+	  memcpy (string + plen, name, nlen + 1);
+	  DECL_SECTION_NAME (decl) = build_string (nlen + plen, string);
+	  return;
+        }
+    }
+  default_unique_section (decl, reloc);
+}
+
+/* Emit an uninitialized cvmx_shared variable.  */
+void
+octeon_output_shared_variable (FILE *stream, tree decl, const char *name,
+                               unsigned HOST_WIDE_INT size, int align)
+{
+  switch_to_section (get_section (".cvmx_shared_bss", CVMX_SHARED_BSS_FLAGS,
+				  NULL_TREE));
+  ASM_OUTPUT_ALIGN (stream, floor_log2 (align / BITS_PER_UNIT));
+  ASM_DECLARE_OBJECT_NAME (stream, name, decl);
+  ASM_OUTPUT_SKIP (stream, size != 0 ? size : 1);
+}
+#endif
 
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
@@ -14477,6 +16150,9 @@ mips_order_regs_for_local_alloc (void)
 #undef TARGET_IRA_COVER_CLASSES
 #define TARGET_IRA_COVER_CLASSES mips_ira_cover_classes
 
+#undef TARGET_ASM_FINAL_POSTSCAN_INSN
+#define TARGET_ASM_FINAL_POSTSCAN_INSN mips_final_postscan_insn
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-mips.h"
diff --git a/gcc/config/mips/mips.h b/gcc/config/mips/mips.h
index c2533c49e..2e121ebc4 100644
--- a/gcc/config/mips/mips.h
+++ b/gcc/config/mips/mips.h
@@ -342,6 +342,9 @@ enum mips_code_readable_setting {
 #define TARGET_IRIX	   0
 #define TARGET_IRIX6	   0
 
+/* SDE specific stuff.  */
+#define TARGET_MIPS_SDE    0
+
 /* Define preprocessor macros for the -march and -mtune options.
    PREFIX is either _MIPS_ARCH or _MIPS_TUNE, INFO is the selected
    processor.  If INFO's canonical name is "foo", define PREFIX to
@@ -416,6 +419,12 @@ enum mips_code_readable_setting {
       if (TARGET_SMARTMIPS)						\
 	builtin_define ("__mips_smartmips");				\
 									\
+      if (TARGET_MICROMIPS)						\
+	builtin_define ("__mips_micromips");				\
+									\
+      if (TARGET_MCU)							\
+	builtin_define ("__mips_mcu");					\
+									\
       if (TARGET_DSP)							\
 	{								\
 	  builtin_define ("__mips_dsp");				\
@@ -708,8 +717,9 @@ enum mips_code_readable_setting {
        |march=r10000|march=r12000|march=r14000|march=r16000:-mips4} \
      %{march=mips32|march=4kc|march=4km|march=4kp|march=4ksc:-mips32} \
      %{march=mips32r2|march=m4k|march=4ke*|march=4ksd|march=24k* \
-       |march=34k*|march=74k*: -mips32r2} \
-     %{march=mips64|march=5k*|march=20k*|march=sb1*|march=sr71000: -mips64} \
+       |march=34k*|march=74k*|march=m14k*|march=1004k*: -mips32r2} \
+     %{march=mips64|march=5k*|march=20k*|march=sb1*|march=sr71000 \
+       |march=xlr: -mips64} \
      %{march=mips64r2|march=octeon: -mips64r2} \
      %{!march=*: -" MULTILIB_ISA_DEFAULT "}}"
 
@@ -720,7 +730,8 @@ enum mips_code_readable_setting {
 #define MIPS_ARCH_FLOAT_SPEC \
   "%{mhard-float|msoft-float|march=mips*:; \
      march=vr41*|march=m4k|march=4k*|march=24kc|march=24kec \
-     |march=34kc|march=74kc|march=5kc|march=octeon: -msoft-float; \
+     |march=34kc|march=74kc|march=1004kc|march=5kc|march=m14k* \
+     |march=octeon|march=xlr: -msoft-float;		  \
      march=*: -mhard-float}"
 
 /* A spec condition that matches 32-bit options.  It only works if
@@ -731,8 +742,9 @@ enum mips_code_readable_setting {
 
 /* Support for a compile-time default CPU, et cetera.  The rules are:
    --with-arch is ignored if -march is specified or a -mips is specified
-     (other than -mips16).
-   --with-tune is ignored if -mtune is specified.
+     (other than -mips16); likewise --with-arch-32 and --with-arch-64.
+   --with-tune is ignored if -mtune is specified; likewise
+     --with-tune-32 and --with-tune-64.
    --with-abi is ignored if -mabi is specified.
    --with-float is ignored if -mhard-float or -msoft-float are
      specified.
@@ -740,7 +752,11 @@ enum mips_code_readable_setting {
      specified. */
 #define OPTION_DEFAULT_SPECS \
   {"arch", "%{" MIPS_ARCH_OPTION_SPEC ":;: -march=%(VALUE)}" }, \
+  {"arch_32", "%{!mabi=*|mabi=32:%{" MIPS_ARCH_OPTION_SPEC ":;: -march=%(VALUE)}}" }, \
+  {"arch_64", "%{mabi=n32|mabi=64:%{" MIPS_ARCH_OPTION_SPEC ":;: -march=%(VALUE)}}" }, \
   {"tune", "%{!mtune=*:-mtune=%(VALUE)}" }, \
+  {"tune_32", "%{!mabi=*|mabi=32:%{!mtune=*:-mtune=%(VALUE)}}" }, \
+  {"tune_64", "%{mabi=n32|mabi=64:%{!mtune=*:-mtune=%(VALUE)}}" }, \
   {"abi", "%{!mabi=*:-mabi=%(VALUE)}" }, \
   {"float", "%{!msoft-float:%{!mhard-float:-m%(VALUE)-float}}" }, \
   {"divide", "%{!mdivide-traps:%{!mdivide-breaks:-mdivide-%(VALUE)}}" }, \
@@ -750,7 +766,7 @@ enum mips_code_readable_setting {
 
 /* A spec that infers the -mdsp setting from an -march argument.  */
 #define BASE_DRIVER_SELF_SPECS \
-  "%{!mno-dsp:%{march=24ke*|march=34k*|march=74k*: -mdsp}}"
+  "%{!mno-dsp:%{march=24ke*|march=34k*|march=74k*|march=1004k*: -mdsp}}"
 
 #define DRIVER_SELF_SPECS BASE_DRIVER_SELF_SPECS
 
@@ -969,7 +985,8 @@ enum mips_code_readable_setting {
 				     || ISA_MIPS64R2))
 
 /* ISA has lwxs instruction (load w/scaled index address.  */
-#define ISA_HAS_LWXS		(TARGET_SMARTMIPS && !TARGET_MIPS16)
+#define ISA_HAS_LWXS		((TARGET_SMARTMIPS || TARGET_MICROMIPS) \
+				 && !TARGET_MIPS16)
 
 /* The DSP ASE is available.  */
 #define ISA_HAS_DSP		(TARGET_DSP && !TARGET_MIPS16)
@@ -1038,6 +1055,11 @@ enum mips_code_readable_setting {
 /* ISA includes the bbit* instructions.  */
 #define ISA_HAS_BBIT		(TARGET_OCTEON && !TARGET_MIPS16)
 
+/* ISA has single-instruction unaligned load/store support.  */
+#define ISA_HAS_UL_US          (TARGET_OCTEON \
+                                && TARGET_OCTEON_UNALIGNED \
+                                && !TARGET_MIPS16)
+ 
 /* ISA includes the cins instruction.  */
 #define ISA_HAS_CINS		(TARGET_OCTEON && !TARGET_MIPS16)
 
@@ -1055,6 +1077,7 @@ enum mips_code_readable_setting {
 
 /* The CACHE instruction is available.  */
 #define ISA_HAS_CACHE (TARGET_CACHE_BUILTIN && !TARGET_MIPS16)
+ 
 
 /* Add -G xx support.  */
 
@@ -1137,6 +1160,8 @@ enum mips_code_readable_setting {
 %{G*} %(endian_spec) %{mips1} %{mips2} %{mips3} %{mips4} \
 %{mips32*} %{mips64*} \
 %{mips16} %{mno-mips16:-no-mips16} \
+%{mmicromips} %{mno-micromips} \
+%{mmcu} %{mno-mcu} \
 %{mips3d} %{mno-mips3d:-no-mips3d} \
 %{mdmx} %{mno-mdmx:-no-mdmx} \
 %{mdsp} %{mno-dsp} \
@@ -1152,6 +1177,7 @@ enum mips_code_readable_setting {
 %{mshared} %{mno-shared} \
 %{msym32} %{mno-sym32} \
 %{mtune=*} %{v} \
+%{mocteon-useun} %{mno-octeon-useun} \
 %(subtarget_asm_spec)"
 
 /* Extra switches sometimes passed to the linker.  */
@@ -1622,6 +1648,9 @@ enum mips_code_readable_setting {
 #define GP_REG_LAST  31
 #define GP_REG_NUM   (GP_REG_LAST - GP_REG_FIRST + 1)
 #define GP_DBX_FIRST 0
+#define K0_REG_NUM   (GP_REG_FIRST + 26)
+#define K1_REG_NUM   (GP_REG_FIRST + 27)
+#define KERNEL_REG_P(REGNO)	(IN_RANGE (REGNO, K0_REG_NUM, K1_REG_NUM))
 
 #define FP_REG_FIRST 32
 #define FP_REG_LAST  63
@@ -1649,6 +1678,10 @@ enum mips_code_readable_setting {
 #define COP0_REG_LAST 111
 #define COP0_REG_NUM (COP0_REG_LAST - COP0_REG_FIRST + 1)
 
+#define COP0_STATUS_REG_NUM	(COP0_REG_FIRST + 12)
+#define COP0_CAUSE_REG_NUM	(COP0_REG_FIRST + 13)
+#define COP0_EPC_REG_NUM	(COP0_REG_FIRST + 14)
+
 #define COP2_REG_FIRST 112
 #define COP2_REG_LAST 143
 #define COP2_REG_NUM (COP2_REG_LAST - COP2_REG_FIRST + 1)
@@ -1666,6 +1699,29 @@ enum mips_code_readable_setting {
 #define AT_REGNUM	(GP_REG_FIRST + 1)
 #define HI_REGNUM	(TARGET_BIG_ENDIAN ? MD_REG_FIRST : MD_REG_FIRST + 1)
 #define LO_REGNUM	(TARGET_BIG_ENDIAN ? MD_REG_FIRST + 1 : MD_REG_FIRST)
+#define AC1HI_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST : DSP_ACC_REG_FIRST + 1)
+#define AC1LO_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 1 : DSP_ACC_REG_FIRST)
+#define AC2HI_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 2 : DSP_ACC_REG_FIRST + 3)
+#define AC2LO_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 3 : DSP_ACC_REG_FIRST + 2)
+#define AC3HI_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 4 : DSP_ACC_REG_FIRST + 5)
+#define AC3LO_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 5 : DSP_ACC_REG_FIRST + 4)
+
+/* A few bitfield locations for the coprocessor registers.  */
+/* Request Interrupt Priority Level is from bit 10 to bit 15 of
+   the cause register for the EIC interrupt mode.  */
+#define CAUSE_IPL	10
+/* Interrupt Priority Level is from bit 10 to bit 15 of the status register.  */
+#define SR_IPL		10
+/* Exception Level is at bit 1 of the status register.  */
+#define SR_EXL		1
+/* Interrupt Enable is at bit 0 of the status register.  */
+#define SR_IE		0
 
 /* FPSW_REGNUM is the single condition code used if !ISA_HAS_8CC.
    If ISA_HAS_8CC, it should not be used, and an arbitrary ST_REG
@@ -1676,6 +1732,8 @@ enum mips_code_readable_setting {
   ((unsigned int) ((int) (REGNO) - GP_REG_FIRST) < GP_REG_NUM)
 #define M16_REG_P(REGNO) \
   (((REGNO) >= 2 && (REGNO) <= 7) || (REGNO) == 16 || (REGNO) == 17)
+#define M16STORE_REG_P(REGNO) \
+  (((REGNO) >= 2 && (REGNO) <= 7) || (REGNO) == 0 || (REGNO) == 17)
 #define FP_REG_P(REGNO)  \
   ((unsigned int) ((int) (REGNO) - FP_REG_FIRST) < FP_REG_NUM)
 #define MD_REG_P(REGNO) \
@@ -1754,11 +1812,18 @@ enum mips_code_readable_setting {
    incoming arguments, the static chain pointer, or the frame pointer.
    The epilogue temporary mustn't conflict with the return registers,
    the PIC call register ($25), the frame pointer, the EH stack adjustment,
-   or the EH data registers.  */
+   or the EH data registers.
+
+   If we're generating interrupt handlers, we use K0 as a temporary register
+   in prologue/epilogue code.  */
 
 #define MIPS16_PIC_TEMP_REGNUM (GP_REG_FIRST + 2)
-#define MIPS_PROLOGUE_TEMP_REGNUM (GP_REG_FIRST + 3)
-#define MIPS_EPILOGUE_TEMP_REGNUM (GP_REG_FIRST + (TARGET_MIPS16 ? 6 : 8))
+#define MIPS_PROLOGUE_TEMP_REGNUM \
+  (cfun->machine->interrupt_handler_p ? K0_REG_NUM : GP_REG_FIRST + 3)
+#define MIPS_EPILOGUE_TEMP_REGNUM		\
+  (cfun->machine->interrupt_handler_p		\
+   ? K0_REG_NUM					\
+   : GP_REG_FIRST + (TARGET_MIPS16 ? 6 : 8))
 
 #define MIPS16_PIC_TEMP gen_rtx_REG (Pmode, MIPS16_PIC_TEMP_REGNUM)
 #define MIPS_PROLOGUE_TEMP(MODE) gen_rtx_REG (MODE, MIPS_PROLOGUE_TEMP_REGNUM)
@@ -2284,14 +2349,7 @@ typedef struct mips_args {
 	(mips_abi == ABI_EABI && UNITS_PER_FPVALUE >= UNITS_PER_DOUBLE)
 
 
-/* Say that the epilogue uses the return address register.  Note that
-   in the case of sibcalls, the values "used by the epilogue" are
-   considered live at the start of the called function.
-
-   If using a GOT, say that the epilogue also uses GOT_VERSION_REGNUM.
-   See the comment above load_call<mode> for details.  */
-#define EPILOGUE_USES(REGNO) \
-  ((REGNO) == 31 || (TARGET_USE_GOT && (REGNO) == GOT_VERSION_REGNUM))
+#define EPILOGUE_USES(REGNO)	mips_epilogue_uses (REGNO)
 
 /* Treat LOC as a byte offset from the stack pointer and round it up
    to the next fully-aligned offset.  */
@@ -2660,18 +2718,48 @@ typedef struct mips_args {
    all calls should use assembly macros.  Otherwise, all indirect
    calls should use "jr" or "jalr"; we will arrange to restore $gp
    afterwards if necessary.  Finally, we can only generate direct
-   calls for -mabicalls by temporarily switching to non-PIC mode.  */
+   calls for -mabicalls by temporarily switching to non-PIC mode.
+
+   For microMIPS jal(r), we try to generate jal(r)s when a 16-bit
+   instruction is in the delay slot of jal(r).  */
 #define MIPS_CALL(INSN, OPERANDS, OPNO)				\
+  (TARGET_MICROMIPS						\
+   ? (TARGET_USE_GOT && !TARGET_EXPLICIT_RELOCS			\
+      ? (TARGET_JALS ? "%*" INSN "%!\t%" #OPNO "%/"		\
+		     : "%*" INSN "\t%" #OPNO "%/")		\
+      : REG_P (OPERANDS[OPNO])					\
+      ? "%*" INSN "r%!\t%" #OPNO "%/"				\
+      : TARGET_ABICALLS && flag_pic				\
+      ? (TARGET_JALS ? (".option\tpic0\n\t"			\
+			"%*" INSN "%!\t%" #OPNO "%/\n\t"	\
+         		".option\tpic2")			\
+		     : (".option\tpic0\n\t"			\
+			"%*" INSN "\t%" #OPNO "%/\n\t"		\
+			".option\tpic2"))			\
+      : (TARGET_JALS ? "%*" INSN "%!\t%" #OPNO "%/"		\
+		     : "%*" INSN "\t%" #OPNO "%/"))		\
+  : (TARGET_USE_GOT && !TARGET_EXPLICIT_RELOCS			\
+     ? "%*" INSN "\t%" #OPNO "%/"				\
+     : REG_P (OPERANDS[OPNO])					\
+     ? "%*" INSN "r\t%" #OPNO "%/"				\
+     : TARGET_ABICALLS && flag_pic				\
+     ? (".option\tpic0\n\t"					\
+        "%*" INSN "\t%" #OPNO "%/\n\t"				\
+        ".option\tpic2")					\
+     : "%*" INSN "\t%" #OPNO "%/"))
+
+/* Similar to MIPS_CALL, but this is for MICROMIPS "j" to generate
+   "jrc" when nop is in the delay slot of "jr".  */
+#define MICROMIPS_J(OPERANDS, OPNO)				\
   (TARGET_USE_GOT && !TARGET_EXPLICIT_RELOCS			\
-   ? "%*" INSN "\t%" #OPNO "%/"					\
+   ? "%*j\t%" #OPNO "%/"					\
    : REG_P (OPERANDS[OPNO])					\
-   ? "%*" INSN "r\t%" #OPNO "%/"				\
-   : TARGET_ABICALLS_PIC2					\
+   ? "%*jr%:\t%" #OPNO						\
+   : TARGET_ABICALLS && flag_pic				\
    ? (".option\tpic0\n\t"					\
-      "%*" INSN "\t%" #OPNO "%/\n\t"				\
+      "%*j\t%" #OPNO "%/\n\t"					\
       ".option\tpic2")						\
-   : "%*" INSN "\t%" #OPNO "%/")
-
+   : "%*j\t%" #OPNO "%/")
 /* Control the assembler format that we output.  */
 
 /* Output to assembler file text saying following lines
@@ -3441,3 +3529,6 @@ extern enum mips_code_readable_setting mips_code_readable;
 
 /* Enable querying of DFA units.  */
 #define CPU_UNITS_QUERY 1
+
+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)	\
+  mips_final_prescan_insn (INSN, OPVEC, NOPERANDS)
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index 68eb31124..2a1433236 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -67,7 +67,16 @@
    (UNSPEC_SET_GOT_VERSION	46)
    (UNSPEC_UPDATE_GOT_VERSION	47)
    (UNSPEC_COPYGP		48)
+   (UNSPEC_ERET			49)
+   (UNSPEC_DERET		50)
+   (UNSPEC_DI			51)
+   (UNSPEC_EHB			52)
+   (UNSPEC_RDPGPR		53)
+   (UNSPEC_COP0			54)
    
+   (UNSPEC_UNALIGNED_LOAD	60)
+   (UNSPEC_UNALIGNED_STORE	61)
+
    (UNSPEC_ADDRESS_FIRST	100)
 
    (TLS_GET_TP_REGNUM		3)
@@ -372,6 +381,12 @@
 ;; frsqrt       floating point reciprocal square root
 ;; frsqrt1      floating point reciprocal square root step1
 ;; frsqrt2      floating point reciprocal square root step2
+;; dspmac       DSP MAC instructions not saturating the accumulator
+;; dspmacsat    DSP MAC instructions that saturate the accumulator
+;; accext       DSP accumulator extract instructions
+;; accmod       DSP accumulator modify instructions
+;; dspalu       DSP ALU instructions not saturating the result
+;; dspalusat    DSP ALU instructions that saturate the result
 ;; multi	multiword sequence (or user asm statements)
 ;; nop		no operation
 ;; ghost	an instruction that produces no real code
@@ -380,7 +395,7 @@
    prefetch,prefetchx,condmove,mtc,mfc,mthilo,mfhilo,const,arith,logical,
    shift,slt,signext,clz,pop,trap,imul,imul3,imul3nc,imadd,idiv,idiv3,move,
    fmove,fadd,fmul,fmadd,fdiv,frdiv,frdiv1,frdiv2,fabs,fneg,fcmp,fcvt,fsqrt,
-   frsqrt,frsqrt1,frsqrt2,multi,nop,ghost"
+   frsqrt,frsqrt1,frsqrt2,dspmac,dspmacsat,accext,accmod,dspalu,dspalusat,multi,nop,ghost,multimem"
   (cond [(eq_attr "jal" "!unset") (const_string "call")
 	 (eq_attr "got" "load") (const_string "load")
 
@@ -436,6 +451,12 @@
 		(const_string "yes")
 		(const_string "no")))
 
+;; Types for 16-bit microMIPS instructions.
+(define_attr "micromips_type"
+  "none,mfhi,logical_not,logical_and,logical_or,logical_xor,zero_extend,
+   add,sub,shift"
+  (const_string "none"))
+
 ;; Length of instruction in bytes.
 (define_attr "length" ""
    (cond [(and (eq_attr "extended_mips16" "yes")
@@ -493,6 +514,9 @@
 	  (eq_attr "got" "xgot_high")
 	  (const_int 8)
 
+	  (eq_attr "type" "multimem")
+	  (const_int 4)
+
 	  ;; In general, constant-pool loads are extended instructions.
 	  (eq_attr "move_type" "loadpool")
 	  (const_int 8)
@@ -1041,6 +1065,7 @@
     <d>addu\t%0,%1,%2
     <d>addiu\t%0,%1,%2"
   [(set_attr "type" "arith")
+   (set_attr "micromips_type" "add")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*add<mode>3_mips16"
@@ -1267,6 +1292,7 @@
   ""
   "<d>subu\t%0,%1,%2"
   [(set_attr "type" "arith")
+   (set_attr "micromips_type" "sub")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*subsi3_extended"
@@ -2543,6 +2569,7 @@
     return "nor\t%0,%.,%1";
 }
   [(set_attr "type" "logical")
+   (set_attr "micromips_type" "logical_not")
    (set_attr "mode" "<MODE>")])
 
 ;;
@@ -2575,6 +2602,7 @@
    and\t%0,%1,%2
    andi\t%0,%1,%x2"
   [(set_attr "type" "logical")
+   (set_attr "micromips_type" "logical_and")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*and<mode>3_mips16"
@@ -2605,6 +2633,7 @@
    or\t%0,%1,%2
    ori\t%0,%1,%x2"
   [(set_attr "type" "logical")
+   (set_attr "micromips_type" "logical_or")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*ior<mode>3_mips16"
@@ -2632,6 +2661,7 @@
    xor\t%0,%1,%2
    xori\t%0,%1,%x2"
   [(set_attr "type" "logical")
+   (set_attr "micromips_type" "logical_xor")
    (set_attr "mode" "<MODE>")])
 
 (define_insn ""
@@ -2898,6 +2928,7 @@
    andi\t%0,%1,<SHORT:mask>
    l<SHORT:size>u\t%0,%1"
   [(set_attr "move_type" "andi,load")
+   (set_attr "micromips_type" "zero_extend")
    (set_attr "mode" "<GPR:MODE>")])
 
 (define_insn "*zero_extend<SHORT:mode><GPR:mode>2_mips16e"
@@ -3563,9 +3594,11 @@
 (define_insn "mov_<load>l"
   [(set (match_operand:GPR 0 "register_operand" "=d")
 	(unspec:GPR [(match_operand:BLK 1 "memory_operand" "m")
-		     (match_operand:QI 2 "memory_operand" "m")]
+		     (match_operand:QI 2 "memory_operand" "YC")]
 		    UNSPEC_LOAD_LEFT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "!TARGET_MIPS16
+   && !ISA_HAS_UL_US
+   && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
   "<load>l\t%0,%2"
   [(set_attr "move_type" "load")
    (set_attr "mode" "<MODE>")])
@@ -3573,10 +3606,12 @@
 (define_insn "mov_<load>r"
   [(set (match_operand:GPR 0 "register_operand" "=d")
 	(unspec:GPR [(match_operand:BLK 1 "memory_operand" "m")
-		     (match_operand:QI 2 "memory_operand" "m")
+		     (match_operand:QI 2 "memory_operand" "YC")
 		     (match_operand:GPR 3 "register_operand" "0")]
 		    UNSPEC_LOAD_RIGHT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "!TARGET_MIPS16
+   && !ISA_HAS_UL_US
+   && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
   "<load>r\t%0,%2"
   [(set_attr "move_type" "load")
    (set_attr "mode" "<MODE>")])
@@ -3584,9 +3619,11 @@
 (define_insn "mov_<store>l"
   [(set (match_operand:BLK 0 "memory_operand" "=m")
 	(unspec:BLK [(match_operand:GPR 1 "reg_or_0_operand" "dJ")
-		     (match_operand:QI 2 "memory_operand" "m")]
+		     (match_operand:QI 2 "memory_operand" "YC")]
 		    UNSPEC_STORE_LEFT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
+  "!TARGET_MIPS16
+   && !ISA_HAS_UL_US
+   && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
   "<store>l\t%z1,%2"
   [(set_attr "move_type" "store")
    (set_attr "mode" "<MODE>")])
@@ -3594,7 +3631,7 @@
 (define_insn "mov_<store>r"
   [(set (match_operand:BLK 0 "memory_operand" "+m")
 	(unspec:BLK [(match_operand:GPR 1 "reg_or_0_operand" "dJ")
-		     (match_operand:QI 2 "memory_operand" "m")
+		     (match_operand:QI 2 "memory_operand" "YC")
 		     (match_dup 0)]
 		    UNSPEC_STORE_RIGHT))]
   "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
@@ -3602,6 +3639,28 @@
   [(set_attr "move_type" "store")
    (set_attr "mode" "<MODE>")])
 
+;; Unaligned load and store patterns.
+
+(define_insn "mov_u<load>"
+  [(set (match_operand:GPR 0 "register_operand" "=d")
+	(unspec:GPR [(match_operand:BLK 1 "memory_operand" "m")
+		     (match_operand:QI 2 "memory_operand" "m")]
+		    UNSPEC_UNALIGNED_LOAD))]
+  "ISA_HAS_UL_US && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "u<load>\t%0,%2"
+  [(set_attr "type" "load")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "mov_u<store>"
+  [(set (match_operand:BLK 0 "memory_operand" "=m")
+	(unspec:BLK [(match_operand:GPR 1 "reg_or_0_operand" "dJ")
+		     (match_operand:QI 2 "memory_operand" "m")]
+		    UNSPEC_UNALIGNED_STORE))]
+  "ISA_HAS_UL_US && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
+  "u<store>\t%z1,%2"
+  [(set_attr "type" "store")
+   (set_attr "mode" "<MODE>")])
+
 ;; An instruction to calculate the high part of a 64-bit SYMBOL_ABSOLUTE.
 ;; The required value is:
 ;;
@@ -4491,6 +4550,7 @@
   ""
   { return ISA_HAS_MACCHI ? "<GPR:d>macchi\t%0,%.,%." : "mfhi\t%0"; }
   [(set_attr "move_type" "mfhilo")
+   (set_attr "micromips_type" "mfhi")
    (set_attr "mode" "<GPR:MODE>")])
 
 ;; Set the high part of a HI/LO value, given that the low part has
@@ -4842,7 +4902,7 @@
   [(set (match_operand:GPR 0 "register_operand" "=d")
 	(any_shift:GPR (match_operand:GPR 1 "register_operand" "d")
 		       (match_operand:SI 2 "arith_operand" "dI")))]
-  "!TARGET_MIPS16"
+  "!TARGET_MIPS16 && !TARGET_MICROMIPS"
 {
   if (GET_CODE (operands[2]) == CONST_INT)
     operands[2] = GEN_INT (INTVAL (operands[2])
@@ -4853,6 +4913,53 @@
   [(set_attr "type" "shift")
    (set_attr "mode" "<MODE>")])
 
+(define_insn "*micromips_ashl<mode>3"
+  [(set (match_operand:GPR 0 "register_operand" "=d")
+	(ashift:GPR (match_operand:GPR 1 "register_operand" "d")
+		       (match_operand:SI 2 "arith_operand" "dI")))]
+  "TARGET_MICROMIPS"
+{
+  if (GET_CODE (operands[2]) == CONST_INT)
+    operands[2] = GEN_INT (INTVAL (operands[2])
+			   & (GET_MODE_BITSIZE (<MODE>mode) - 1));
+
+  return "<d>sll\t%0,%1,%2";
+}
+  [(set_attr "type" "shift")
+   (set_attr "micromips_type" "shift")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "*micromips_ashr<mode>3"
+  [(set (match_operand:GPR 0 "register_operand" "=d")
+	(ashiftrt:GPR (match_operand:GPR 1 "register_operand" "d")
+		       (match_operand:SI 2 "arith_operand" "dI")))]
+  "TARGET_MICROMIPS"
+{
+  if (GET_CODE (operands[2]) == CONST_INT)
+    operands[2] = GEN_INT (INTVAL (operands[2])
+			   & (GET_MODE_BITSIZE (<MODE>mode) - 1));
+
+  return "<d>sra\t%0,%1,%2";
+}
+  [(set_attr "type" "shift")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "*micromips_lshr<mode>3"
+  [(set (match_operand:GPR 0 "register_operand" "=d")
+	(lshiftrt:GPR (match_operand:GPR 1 "register_operand" "d")
+		       (match_operand:SI 2 "arith_operand" "dI")))]
+  "TARGET_MICROMIPS"
+{
+  if (GET_CODE (operands[2]) == CONST_INT)
+    operands[2] = GEN_INT (INTVAL (operands[2])
+			   & (GET_MODE_BITSIZE (<MODE>mode) - 1));
+
+  return "<d>srl\t%0,%1,%2";
+}
+  [(set_attr "type" "shift")
+   (set_attr "micromips_type" "shift")
+   (set_attr "mode" "<MODE>")])
+
 (define_insn "*<optab>si3_extend"
   [(set (match_operand:DI 0 "register_operand" "=d")
 	(sign_extend:DI
@@ -5124,8 +5231,34 @@
 			  (match_operand:GPR 3 "reg_or_0_operand" "dJ")])
 	 (label_ref (match_operand 1 "" ""))
 	 (pc)))]
-  "!TARGET_MIPS16"
+  "!TARGET_MIPS16 && !TARGET_MICROMIPS"
+{
+  return mips_output_conditional_branch (insn, operands,
+					 MIPS_BRANCH ("b%C0", "%2,%z3,%1"),
+					 MIPS_BRANCH ("b%N0", "%2,%z3,%1"));
+}
+  [(set_attr "type" "branch")
+   (set_attr "mode" "none")])
+
+(define_insn "*branch_equality<mode>_micromips"
+  [(set (pc)
+	(if_then_else
+	 (match_operator 0 "equality_operator"
+			 [(match_operand:GPR 2 "register_operand" "d")
+			  (match_operand:GPR 3 "reg_or_0_operand" "dJ")])
+	 (label_ref (match_operand 1 "" ""))
+	 (pc)))]
+  "TARGET_MICROMIPS"
 {
+  /* For a simple bnez or beqz microMIPS branch.  */
+  if (!TARGET_BRANCHLIKELY
+      && get_attr_length (insn) <= 8
+      && GET_CODE (operands[3]) == CONST_INT
+      && INTVAL (operands[3]) == 0)
+    return mips_output_conditional_branch (insn, operands,
+					   "%*b%C0z%:\t%2,%1",
+					   "%*b%N0z%:\t%2,%1");
+
   return mips_output_conditional_branch (insn, operands,
 					 MIPS_BRANCH ("b%C0", "%2,%z3,%1"),
 					 MIPS_BRANCH ("b%N0", "%2,%z3,%1"));
@@ -5141,7 +5274,7 @@
 			  (match_operand:GPR 3 "reg_or_0_operand" "dJ")])
 	 (pc)
 	 (label_ref (match_operand 1 "" ""))))]
-  "!TARGET_MIPS16"
+  "!TARGET_MIPS16 && !TARGET_MICROMIPS"
 {
   return mips_output_conditional_branch (insn, operands,
 					 MIPS_BRANCH ("b%N0", "%2,%z3,%1"),
@@ -5199,6 +5332,32 @@
 		      (label_ref (match_operand 1))
 		      (pc)))])
 
+(define_insn "*branch_equality<mode>_inverted_micromips"
+  [(set (pc)
+	(if_then_else
+	 (match_operator 0 "equality_operator"
+			 [(match_operand:GPR 2 "register_operand" "d")
+			  (match_operand:GPR 3 "reg_or_0_operand" "dJ")])
+	 (pc)
+	 (label_ref (match_operand 1 "" ""))))]
+  "TARGET_MICROMIPS"
+{
+  /* For a simple bnez or beqz microMIPS branch.  */
+  if (!TARGET_BRANCHLIKELY
+      && get_attr_length (insn) <= 8
+      && GET_CODE (operands[3]) == CONST_INT
+      && INTVAL (operands[3]) == 0)
+    return mips_output_conditional_branch (insn, operands,
+					   "%*b%N0z%:\t%2,%1",
+					   "%*b%C0z%:\t%2,%1");
+
+  return mips_output_conditional_branch (insn, operands,
+					 MIPS_BRANCH ("b%N0", "%2,%z3,%1"),
+					 MIPS_BRANCH ("b%C0", "%2,%z3,%1"));
+}
+  [(set_attr "type" "branch")
+   (set_attr "mode" "none")])
+
 ;; Branch if bit is set/clear.
 
 (define_insn "*branch_bit<bbv><mode>"
@@ -5472,12 +5631,39 @@
 	return "%*b\t%l0%/";
       else
 	{
+	  if (final_sequence && (mips_abi == ABI_32 || mips_abi == ABI_O64))
+	    {
+              /* If the delay slot contains a $gp restore, we need to
+                 do that first, because we need it for the load
+		 label.  Other ABIs do not have caller-save $gp.  */
+	      rtx next = NEXT_INSN (insn);
+	      if (INSN_P (next) && !INSN_DELETED_P (next))
+		{
+		  rtx pat = PATTERN (next);
+		  if (GET_CODE (pat) == SET
+		      && REG_P (SET_DEST (pat))
+		      && REGNO (SET_DEST (pat)) == PIC_OFFSET_TABLE_REGNUM)
+		    {
+		      rtx ops[2];
+		      ops[0] = SET_DEST (pat);
+		      ops[1] = SET_SRC (pat);
+		      output_asm_insn (mips_output_move (ops[0], ops[1]), ops);
+		    }
+		}
+	    }
 	  output_asm_insn (mips_output_load_label (), operands);
 	  return "%*jr\t%@%/%]";
 	}
     }
   else
-    return "%*j\t%l0%/";
+    {
+      /* We prefer using branches for microMIPS, because the assembler can
+	 use 16-bit branches, 32-bit branches, or 32-bit jumps.  */
+      if (TARGET_MICROMIPS)
+	return "%*b\t%l0%/";
+      else
+	return "%*j\t%l0%/";
+    }
 }
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
@@ -5490,7 +5676,13 @@
 	      (lt (abs (minus (match_dup 0)
 			      (plus (pc) (const_int 4))))
 		  (const_int 131072)))
-	 (const_int 4) (const_int 16)))])
+	 (const_int 4)
+         (if_then_else
+	    ;; for these two ABIs we may need to move a restore of $gp
+	    (ior (eq (symbol_ref "mips_abi") (symbol_ref "ABI_32"))
+		 (eq (symbol_ref "mips_abi") (symbol_ref "ABI_O64")))
+	    (const_int 20)
+	    (const_int 16))))])
 
 ;; We need a different insn for the mips16, because a mips16 branch
 ;; does not have a delay slot.
@@ -5518,7 +5710,12 @@
 (define_insn "indirect_jump<mode>"
   [(set (pc) (match_operand:P 0 "register_operand" "d"))]
   ""
-  "%*j\t%0%/"
+{
+  if (TARGET_MICROMIPS)
+    return "%*jr%:\t%0";
+  else
+    return "%*j\t%0%/";
+}
   [(set_attr "type" "jump")
    (set_attr "mode" "none")])
 
@@ -5558,7 +5755,12 @@
 	(match_operand:P 0 "register_operand" "d"))
    (use (label_ref (match_operand 1 "" "")))]
   ""
-  "%*j\t%0%/"
+{
+  if (TARGET_MICROMIPS)
+    return "%*jr%:\t%0";
+  else
+    return "%*j\t%0%/";
+}
   [(set_attr "type" "jump")
    (set_attr "mode" "none")])
 
@@ -5665,7 +5867,12 @@
 (define_insn "*return"
   [(return)]
   "mips_can_use_return_insn ()"
-  "%*j\t$31%/"
+{
+  if (TARGET_MICROMIPS)
+    return "%*jr%:\t$31";
+  else
+    return "%*j\t$31%/";
+}
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")])
 
@@ -5675,10 +5882,69 @@
   [(return)
    (use (match_operand 0 "pmode_register_operand" ""))]
   ""
-  "%*j\t%0%/"
+{
+  if (TARGET_MICROMIPS)
+    return "%*jr%:\t%0";
+  else
+    return "%*j\t%0%/";
+}
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")])
 
+;; Exception return.
+(define_insn "mips_eret"
+  [(return)
+   (unspec_volatile [(const_int 0)] UNSPEC_ERET)]
+  ""
+  "eret"
+  [(set_attr "type"	"trap")
+   (set_attr "mode"	"none")])
+
+;; Debug exception return.
+(define_insn "mips_deret"
+  [(return)
+   (unspec_volatile [(const_int 0)] UNSPEC_DERET)]
+  ""
+  "deret"
+  [(set_attr "type"	"trap")
+   (set_attr "mode"	"none")])
+
+;; Disable interrupts.
+(define_insn "mips_di"
+  [(unspec_volatile [(const_int 0)] UNSPEC_DI)]
+  ""
+  "di"
+  [(set_attr "type"	"trap")
+   (set_attr "mode"	"none")])
+
+;; Execution hazard barrier.
+(define_insn "mips_ehb"
+  [(unspec_volatile [(const_int 0)] UNSPEC_EHB)]
+  ""
+  "ehb"
+  [(set_attr "type"	"trap")
+   (set_attr "mode"	"none")])
+
+;; Read GPR from previous shadow register set.
+(define_insn "mips_rdpgpr"
+  [(set (match_operand:SI 0 "register_operand" "=d")
+	(unspec_volatile:SI [(match_operand:SI 1 "register_operand" "d")]
+			    UNSPEC_RDPGPR))]
+  ""
+  "rdpgpr\t%0,%1"
+  [(set_attr "type"	"move")
+   (set_attr "mode"	"SI")])
+
+;; Move involving COP0 registers.
+(define_insn "cop0_move"
+  [(set (match_operand:SI 0 "register_operand" "=B,d")
+	(unspec_volatile:SI [(match_operand:SI 1 "register_operand" "d,B")]
+			    UNSPEC_COP0))]
+  ""
+{ return mips_output_move (operands[0], operands[1]); }
+  [(set_attr "type"	"mtc,mfc")
+   (set_attr "mode"	"SI")])
+
 ;; This is used in compiling the unwind routines.
 (define_expand "eh_return"
   [(use (match_operand 0 "general_operand"))]
@@ -5867,7 +6133,12 @@
   [(call (mem:SI (match_operand 0 "call_insn_operand" "j,S"))
 	 (match_operand 1 "" ""))]
   "TARGET_SIBCALLS && SIBLING_CALL_P (insn)"
-  { return MIPS_CALL ("j", operands, 0); }
+  {
+    if (TARGET_MICROMIPS)
+      return MICROMIPS_J (operands, 0);
+    else
+      return MIPS_CALL ("j", operands, 0);
+  }
   [(set_attr "type" "call")])
 
 (define_expand "sibcall_value"
@@ -5887,7 +6158,12 @@
         (call (mem:SI (match_operand 1 "call_insn_operand" "j,S"))
               (match_operand 2 "" "")))]
   "TARGET_SIBCALLS && SIBLING_CALL_P (insn)"
-  { return MIPS_CALL ("j", operands, 1); }
+  {
+    if (TARGET_MICROMIPS)
+      return MICROMIPS_J (operands, 1);
+    else
+      return MIPS_CALL ("j", operands, 1);
+  }
   [(set_attr "type" "call")])
 
 (define_insn "sibcall_value_multiple_internal"
@@ -5898,7 +6174,12 @@
 	(call (mem:SI (match_dup 1))
 	      (match_dup 2)))]
   "TARGET_SIBCALLS && SIBLING_CALL_P (insn)"
-  { return MIPS_CALL ("j", operands, 1); }
+  {
+    if (TARGET_MICROMIPS)
+      return MICROMIPS_J (operands, 1);
+    else
+     return MIPS_CALL ("j", operands, 1);
+  }
   [(set_attr "type" "call")])
 
 (define_expand "call"
@@ -6140,7 +6421,7 @@
 
 
 (define_insn "prefetch"
-  [(prefetch (match_operand:QI 0 "address_operand" "p")
+  [(prefetch (match_operand:QI 0 "address_operand" "YD")
 	     (match_operand 1 "const_int_operand" "n")
 	     (match_operand 2 "const_int_operand" "n"))]
   "ISA_HAS_PREFETCH && TARGET_EXPLICIT_RELOCS"
@@ -6371,5 +6652,8 @@
 ; MIPS fixed-point instructions.
 (include "mips-fixed.md")
 
+; microMIPS patterns.
+(include "micromips.md")
+
 ; ST-Microelectronics Loongson-2E/2F-specific patterns.
 (include "loongson.md")
diff --git a/gcc/config/mips/mips.opt b/gcc/config/mips/mips.opt
index 901675427..6de20ec75 100644
--- a/gcc/config/mips/mips.opt
+++ b/gcc/config/mips/mips.opt
@@ -176,6 +176,10 @@ minterlink-mips16
 Target Report Var(TARGET_INTERLINK_MIPS16) Init(0)
 Generate code that can be safely linked with MIPS16 code.
 
+mjals
+Target Report Var(TARGET_JALS) Init(1)
+Generate jals for microMIPS by recognizing that the branch delay slot instruction can be 16 bits.  This implies that the function call cannot switch the current mode during the linking stage, because we don't have jalxs that supports 16-bit branch delay slot instructions.
+
 mips
 Target RejectNegative Joined
 -mipsN	Generate code for ISA level N
@@ -184,6 +188,10 @@ mips16
 Target Report RejectNegative Mask(MIPS16)
 Generate MIPS16 code
 
+mips16e
+Target Report RejectNegative Mask(MIPS16) MaskExists
+Deprecated; alias for -mips16
+
 mips3d
 Target Report RejectNegative Mask(MIPS3D)
 Use MIPS-3D instructions
@@ -212,6 +220,10 @@ mmemcpy
 Target Report Mask(MEMCPY)
 Don't optimize block moves
 
+mmicromips
+Target Report Mask(MICROMIPS)
+Use microMIPS instructions
+
 mmips-tfile
 Target
 Use the mips-tfile postpass
@@ -220,6 +232,10 @@ mmt
 Target Report Var(TARGET_MT)
 Allow the use of MT instructions
 
+mmcu
+Target Report Mask(MCU)
+Use MCU instructions
+
 mno-flush-func
 Target RejectNegative
 Do not use a cache-flushing function before calling stack trampolines
@@ -236,6 +252,10 @@ mno-mips3d
 Target Report RejectNegative InverseMask(MIPS3D)
 Do not use MIPS-3D instructions
 
+mocteon-useun
+Target Report Mask(OCTEON_UNALIGNED)
+Use Octeon-specific unaligned loads/stores for 32/64-bit data
+
 mpaired-single
 Target Report Mask(PAIRED_SINGLE_FLOAT)
 Use paired-single floating-point instructions
diff --git a/gcc/config/mips/mips16.S b/gcc/config/mips/mips16.S
index bab7b7942..8f836fe58 100644
--- a/gcc/config/mips/mips16.S
+++ b/gcc/config/mips/mips16.S
@@ -21,6 +21,10 @@ a copy of the GCC Runtime Library Exception along with this program;
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
+#ifdef __mips_micromips
+  /* DO NOTHING */
+#else
+
 /* This file contains mips16 floating point support functions.  These
    functions are called by mips16 code to handle floating point when
    -msoft-float is not used.  They accept the arguments and return
@@ -29,6 +33,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #if defined _MIPS_SIM && (_MIPS_SIM == _ABIO32 || _MIPS_SIM == _ABIO64)
 
+
 /* This file contains 32-bit assembly code.  */
 	.set nomips16
 
@@ -707,3 +712,4 @@ CALL_STUB_RET (__mips16_call_stub_dc_10, 10, DC)
 #endif
 #endif /* !__mips_single_float */
 #endif
+#endif /* __mips_micromips */
diff --git a/gcc/config/mips/montavista-linux.h b/gcc/config/mips/montavista-linux.h
new file mode 100644
index 000000000..5fa0106a4
--- /dev/null
+++ b/gcc/config/mips/montavista-linux.h
@@ -0,0 +1,54 @@
+/* MontaVista GNU/Linux Configuration.
+   Copyright (C) 2009
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Override linux64.h to default to O32.  */
+#undef SUBTARGET_SELF_SPECS
+#define SUBTARGET_SELF_SPECS \
+NO_SHARED_SPECS, \
+"%{!EB:%{!EL:%(endian_spec)}}", \
+"%{!mabi=*: -mabi=32}"
+
+/* We do not need to provide an explicit big-endian multilib.  */
+#undef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS \
+  { "meb", "mabi=32" }
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC			\
+  "%{mel:%{msoft-float:/mel/soft-float ;	\
+           :/mel} ;				\
+     msoft-float:/soft-float}"
+
+/* MULTILIB_OSDIRNAMES provides directory names used in two ways:
+   relative to $target/lib/ in the GCC installation, and relative to
+   lib/ and usr/lib/ in a sysroot.  For the latter, we want names such
+   as plain ../lib64, but these cannot be used outside the sysroot
+   because different multilibs would be mapped to the same directory.
+   Directories are searched both with and without the multilib suffix,
+   so it suffices if the directory without the suffix is correct
+   within the sysroot while the directory with the suffix doesn't
+   exist.  We use STARTFILE_PREFIX_SPEC to achieve the desired
+   effect.  */
+#undef STARTFILE_PREFIX_SPEC
+#define STARTFILE_PREFIX_SPEC				\
+  "%{mabi=32: /usr/local/lib/ /lib/ /usr/lib/} 		\
+   %{mabi=n32: /usr/local/lib32/ /lib32/ /usr/lib32/}	\
+   %{mabi=64: /usr/local/lib64/ /lib64/ /usr/lib64/}"
diff --git a/gcc/config/mips/octeon-elf-unwind.h b/gcc/config/mips/octeon-elf-unwind.h
new file mode 100644
index 000000000..411cb44f2
--- /dev/null
+++ b/gcc/config/mips/octeon-elf-unwind.h
@@ -0,0 +1,57 @@
+/* Stack unwinding support through the first exception frame.
+   Copyright (C) 2007 Cavium Networks.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+#define MD_FALLBACK_FRAME_STATE_FOR octeon_elf_fallback_frame_state
+
+/* Check whether this is the cvmx_interrupt_stage2 frame.  If the
+   function call was dispatched via k0 assume we are in
+   cvmx_interrupt_stage2.  In this case the sp in point to the saved
+   register array.  */
+
+static _Unwind_Reason_Code
+octeon_elf_fallback_frame_state (struct _Unwind_Context *context,
+				 _Unwind_FrameState *fs)
+{
+  unsigned i;
+  unsigned *pc = context->ra;
+
+  /* Look for "jalr k0".  */
+  if (pc[-2] != 0x0340f809)
+    return _URC_END_OF_STACK;
+  
+  for (i = 0; i < 32; i++)
+    {
+      fs->regs.reg[i].how = REG_SAVED_OFFSET;
+      fs->regs.reg[i].loc.offset = 8 * i;
+    }
+
+  /* Keep the next frame's sp.  This way we have a CFA that points
+     exactly to the register array.  */
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = STACK_POINTER_REGNUM;
+  fs->regs.cfa_offset = 0;
+
+  /* DEPC is saved as the 35. register.  */
+  fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].how = REG_SAVED_OFFSET;
+  fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].loc.offset = 8 * 35;
+  fs->retaddr_column = DWARF_ALT_FRAME_RETURN_COLUMN;
+
+  return _URC_NO_REASON;
+}
diff --git a/gcc/config/mips/octeon-elf.h b/gcc/config/mips/octeon-elf.h
new file mode 100644
index 000000000..cb951f902
--- /dev/null
+++ b/gcc/config/mips/octeon-elf.h
@@ -0,0 +1,98 @@
+/* Macros for mips*-octeon-elf target.
+   Copyright (C) 2004, 2005, 2006 Cavium Networks.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+/* Add MASK_SOFT_FLOAT and MASK_OCTEON_UNALIGNED.  */
+
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT (MASK_SOFT_FLOAT_ABI | MASK_OCTEON_UNALIGNED)
+
+/* Forward -m*octeon-useun.  */
+
+#undef SUBTARGET_ASM_SPEC
+#define SUBTARGET_ASM_SPEC "%{mno-octeon-useun} %{!mno-octeon-useun:-mocteon-useun}"
+
+/* Enable backtrace including on machine exceptions by default.  */
+
+#undef SUBTARGET_CC1_SPEC
+#define SUBTARGET_CC1_SPEC "%{!fno-asynchronous-unwind-tables:-fasynchronous-unwind-tables}"
+
+/* Without ASM_PREFERRED_EH_DATA_FORMAT, output_call_frame_info emits
+   pointer-sized addresses for FDE addresses.  For 64-bit targets, it does
+   it without properly "switching over" to 64-bit as described in the DWARF3
+   spec. GDB can fall back on .eh_frames and misinterpret FDE addresses.
+   Instead let's be explicit and use augmentation to describe the encoding if
+   pointer size is 64.  */
+
+#undef ASM_PREFERRED_EH_DATA_FORMAT
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
+  ((CODE) == 1 && POINTER_SIZE == 64                                    \
+   ? (ABI_HAS_64BIT_SYMBOLS ? DW_EH_PE_udata8 : DW_EH_PE_udata4)        \
+   : DW_EH_PE_absptr)
+
+/* Link to libc library.  */
+
+#undef LIB_SPEC
+#define LIB_SPEC "-lc"
+
+/* Link to startup file.  */
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "crti%O%s crtbegin%O%s crt0%O%s"
+
+/* Default our test-only n64 configuration to -G0 since that is what
+   the kernel uses.  */
+
+#undef SUBTARGET_SELF_SPECS
+#define SUBTARGET_SELF_SPECS \
+"%{mabi=64:%{!G*: -G0}}"
+
+/* Pass linker emulation mode for N32.  */
+
+#undef LINK_SPEC
+#define LINK_SPEC "\
+%(endian_spec) \
+%{G*} %{mips1} %{mips2} %{mips3} %{mips4} %{mips32} %{mips32r2} %{mips64} \
+%{mips64r2} %{bestGnum} %{shared} %{non_shared} \
+%{mabi=n32:-melf32e%{!EL:b}%{EL:l}octeonn32} \
+%{mabi=64:-melf64e%{!EL:b}%{EL:l}octeon}"
+
+/* Override because of N32.  */
+
+#undef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX ((mips_abi == ABI_N32) ? "." : "$")
+
+/* Append the core number to the GCOV filename FN.  */
+
+#define GCOV_TARGET_SUFFIX_LENGTH 2
+#define ADD_GCOV_TARGET_SUFFIX(FN)		\
+do						\
+  {						\
+    char *fn = FN;				\
+    int core;					\
+    char s[3];					\
+						\
+    asm ("rdhwr %0, $0" : "=r"(core));		\
+    sprintf (s, "%d", core);			\
+    strcat (fn, s);				\
+  }						\
+while (0)
+
+/* Code to unwind through the exception frame.  */
+#define MD_UNWIND_SUPPORT "config/mips/octeon-elf-unwind.h"
diff --git a/gcc/config/mips/octeon.h b/gcc/config/mips/octeon.h
new file mode 100644
index 000000000..f21325063
--- /dev/null
+++ b/gcc/config/mips/octeon.h
@@ -0,0 +1,68 @@
+/* Macros for mips*-octeon-* target.
+   Copyright (C) 2004, 2005, 2006 Cavium Networks.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+#define CVMX_SHARED_BSS_FLAGS (SECTION_WRITE | SECTION_BSS)
+
+#undef TARGET_ASM_SELECT_SECTION
+#define TARGET_ASM_SELECT_SECTION octeon_select_section
+
+#undef TARGET_ASM_UNIQUE_SECTION
+#define TARGET_ASM_UNIQUE_SECTION octeon_unique_section
+
+/* Implement ASM_OUTPUT_ALIGNED_DECL_LOCAL. This differs from the 
+   generic version only in the use of cvmx_shared attribute.  */
+ 
+#undef ASM_OUTPUT_ALIGNED_DECL_LOCAL
+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(STREAM, DECL, NAME, SIZE, ALIGN) \
+  do									\
+    {									\
+      if ((DECL) && TREE_CODE ((DECL)) == VAR_DECL 			\
+	  && lookup_attribute ("cvmx_shared", DECL_ATTRIBUTES (DECL)))	\
+	{  								\
+           fprintf ((STREAM), "%s", LOCAL_ASM_OP);			\
+           assemble_name ((STREAM), (NAME));				\
+           fprintf ((STREAM), "\n");					\
+	   octeon_output_shared_variable ((STREAM), (DECL), (NAME),     \
+					  (SIZE), (ALIGN));             \
+	 } 								\
+      else 								\
+	ASM_OUTPUT_ALIGNED_LOCAL (STREAM, NAME, SIZE, ALIGN);		\
+    }									\
+  while (0) 
+
+
+/* Implement ASM_OUTPUT_ALIGNED_DECL_COMMON.  This differs from the mips 
+   version only in the use of cvmx_shared attribute.  */
+
+#undef ASM_OUTPUT_ALIGNED_DECL_COMMON
+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(STREAM, DECL, NAME, SIZE, ALIGN)	   \
+  {									   \
+    if (TREE_CODE ((DECL)) == VAR_DECL			   		   \
+        && lookup_attribute ("cvmx_shared", DECL_ATTRIBUTES ((DECL))))	   \
+      {									   \
+	if (TREE_PUBLIC ((DECL)) && DECL_NAME ((DECL)))			   \
+	  targetm.asm_out.globalize_label (asm_out_file, (NAME));	   \
+	octeon_output_shared_variable ((STREAM), (DECL), (NAME),	   \
+				       (SIZE), (ALIGN));		   \
+      }									   \
+    else								   \
+      mips_output_aligned_decl_common ((STREAM), (DECL), (NAME), (SIZE),   \
+				       (ALIGN));			   \
+   }
diff --git a/gcc/config/mips/predicates.md b/gcc/config/mips/predicates.md
index aaebdded6..e45ad0d6b 100644
--- a/gcc/config/mips/predicates.md
+++ b/gcc/config/mips/predicates.md
@@ -211,6 +211,20 @@
     }
 })
 
+(define_predicate "mask_low_and_shift_operator"
+  (and (match_code "and")
+       (match_test "GET_CODE (XEXP (op, 0)) == ASHIFT
+		    && GET_CODE (XEXP (op, 1)) == CONST_INT
+		    && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT"))
+{
+  int len;
+
+  len = mask_low_and_shift_len (GET_MODE (op),
+			        INTVAL (XEXP (XEXP (op, 0), 1)),
+				INTVAL (XEXP (op, 1)));
+  return 0 < len && len <= 32;
+})
+
 (define_predicate "consttable_operand"
   (match_test "CONSTANT_P (op)"))
 
diff --git a/gcc/config/mips/sde.h b/gcc/config/mips/sde.h
index 3640883e0..a3264ca7a 100644
--- a/gcc/config/mips/sde.h
+++ b/gcc/config/mips/sde.h
@@ -19,6 +19,9 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#undef TARGET_MIPS_SDE
+#define TARGET_MIPS_SDE 1
+
 #undef DRIVER_SELF_SPECS
 #define DRIVER_SELF_SPECS						\
   /* Make sure a -mips option is present.  This helps us to pick	\
@@ -90,7 +93,8 @@ along with GCC; see the file COPYING3.  If not see
 
 /* Use $5 as a temporary for both MIPS16 and non-MIPS16.  */
 #undef MIPS_EPILOGUE_TEMP_REGNUM
-#define MIPS_EPILOGUE_TEMP_REGNUM (GP_REG_FIRST + 5)
+#define MIPS_EPILOGUE_TEMP_REGNUM \
+  (cfun->machine->interrupt_handler_p ? K0_REG_NUM : GP_REG_FIRST + 5)
 
 /* Using long will always be right for size_t and ptrdiff_t, since
    sizeof(long) must equal sizeof(void *), following from the setting
diff --git a/gcc/config/mips/sdemtk.h b/gcc/config/mips/sdemtk.h
index 3e4e58fdd..c1588776c 100644
--- a/gcc/config/mips/sdemtk.h
+++ b/gcc/config/mips/sdemtk.h
@@ -19,6 +19,8 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#define TARGET_MIPS_SDEMTK	1
+
 #define TARGET_OS_CPP_BUILTINS()			\
   do							\
     {							\
@@ -113,3 +115,12 @@ extern void mips_sync_icache (void *beg, unsigned long len);
 /* ...nor does the call sequence preserve $31.  */
 #undef MIPS_SAVE_REG_FOR_PROFILING_P
 #define MIPS_SAVE_REG_FOR_PROFILING_P(REGNO) ((REGNO) == GP_REG_FIRST + 31)
+
+/* From mips.h, with mno-float option added.  */
+
+#undef MIPS_ARCH_FLOAT_SPEC
+#define MIPS_ARCH_FLOAT_SPEC \
+  "%{mhard-float|msoft-float|mno-float|march=mips*:; \
+     march=vr41*|march=m4k|march=4k*|march=24kc|march=24kec|march=m14k* \
+     |march=34kc|march=74kc|march=1004kc|march=5kc|march=octeon|march=xlr: -msoft-float; \
+     march=*: -mhard-float}"
diff --git a/gcc/config/mips/sfp-machine.h b/gcc/config/mips/sfp-machine.h
new file mode 100644
index 000000000..328724b69
--- /dev/null
+++ b/gcc/config/mips/sfp-machine.h
@@ -0,0 +1,70 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define FP_EX_INVALID           (1 << 4)
+#define FP_EX_DIVZERO           (1 << 3)
+#define FP_EX_OVERFLOW          (1 << 2)
+#define FP_EX_UNDERFLOW         (1 << 1)
+#define FP_EX_INEXACT           (1 << 0)
+
+#define       __LITTLE_ENDIAN 1234
+#define       __BIG_ENDIAN    4321
+
+#if defined  MIPS_EB || defined __MIPSEB__ || defined MIPSEB || defined _MIPSEB
+# if defined  MIPS_EL || defined __MIPSEL__ || defined MIPSEL || defined _MIPSEL
+#  error "Both BIG_ENDIAN and LITTLE_ENDIAN defined!"
+# endif
+# define __BYTE_ORDER __BIG_ENDIAN
+#else
+# if defined  MIPS_EL || defined __MIPSEL__ || defined MIPSEL || defined _MIPSEL
+#  define __BYTE_ORDER __LITTLE_ENDIAN
+# else
+#  error "Cannot determine current byte order"
+# endif
+#endif
+
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
+
diff --git a/gcc/config/mips/sync.md b/gcc/config/mips/sync.md
index cd3fdc65a..c271fa4df 100644
--- a/gcc/config/mips/sync.md
+++ b/gcc/config/mips/sync.md
@@ -44,7 +44,7 @@
 
 (define_insn "sync_compare_and_swap<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YC,YC"))
    (set (match_dup 1)
 	(unspec_volatile:GPR [(match_operand:GPR 2 "reg_or_0_operand" "dJ,dJ")
 			      (match_operand:GPR 3 "arith_operand" "I,d")]
@@ -75,7 +75,7 @@
 ;; Helper insn for mips_expand_atomic_qihi.
 (define_insn "compare_and_swap_12"
   [(set (match_operand:SI 0 "register_operand" "=&d,&d")
-	(match_operand:SI 1 "memory_operand" "+R,R"))
+	(match_operand:SI 1 "memory_operand" "+YC,YC"))
    (set (match_dup 1)
 	(unspec_volatile:SI [(match_operand:SI 2 "register_operand" "d,d")
 			     (match_operand:SI 3 "register_operand" "d,d")
@@ -94,7 +94,7 @@
   [(set_attr "length" "40,36")])
 
 (define_insn "sync_add<mode>"
-  [(set (match_operand:GPR 0 "memory_operand" "+R,R")
+  [(set (match_operand:GPR 0 "memory_operand" "+YC,YC")
 	(unspec_volatile:GPR
           [(plus:GPR (match_dup 0)
 		     (match_operand:GPR 1 "arith_operand" "I,d"))]
@@ -125,7 +125,7 @@
 
 ;; Helper insn for sync_<optab><mode>
 (define_insn "sync_<optab>_12"
-  [(set (match_operand:SI 0 "memory_operand" "+R")
+  [(set (match_operand:SI 0 "memory_operand" "+YC")
 	(unspec_volatile:SI
           [(match_operand:SI 1 "register_operand" "d")
 	   (match_operand:SI 2 "register_operand" "d")
@@ -161,7 +161,7 @@
 ;; Helper insn for sync_old_<optab><mode>
 (define_insn "sync_old_<optab>_12"
   [(set (match_operand:SI 0 "register_operand" "=&d")
-	(match_operand:SI 1 "memory_operand" "+R"))
+	(match_operand:SI 1 "memory_operand" "+YC"))
    (set (match_dup 1)
 	(unspec_volatile:SI
           [(match_operand:SI 2 "register_operand" "d")
@@ -200,7 +200,7 @@
 (define_insn "sync_new_<optab>_12"
   [(set (match_operand:SI 0 "register_operand" "=&d")
 	(unspec_volatile:SI
-          [(match_operand:SI 1 "memory_operand" "+R")
+          [(match_operand:SI 1 "memory_operand" "+YC")
 	   (match_operand:SI 2 "register_operand" "d")
 	   (match_operand:SI 3 "register_operand" "d")
 	   (atomic_hiqi_op:SI (match_dup 0)
@@ -236,7 +236,7 @@
 
 ;; Helper insn for sync_nand<mode>
 (define_insn "sync_nand_12"
-  [(set (match_operand:SI 0 "memory_operand" "+R")
+  [(set (match_operand:SI 0 "memory_operand" "+YC")
 	(unspec_volatile:SI
           [(match_operand:SI 1 "register_operand" "d")
 	   (match_operand:SI 2 "register_operand" "d")
@@ -271,7 +271,7 @@
 ;; Helper insn for sync_old_nand<mode>
 (define_insn "sync_old_nand_12"
   [(set (match_operand:SI 0 "register_operand" "=&d")
-	(match_operand:SI 1 "memory_operand" "+R"))
+	(match_operand:SI 1 "memory_operand" "+YC"))
    (set (match_dup 1)
 	(unspec_volatile:SI
           [(match_operand:SI 2 "register_operand" "d")
@@ -308,7 +308,7 @@
 (define_insn "sync_new_nand_12"
   [(set (match_operand:SI 0 "register_operand" "=&d")
 	(unspec_volatile:SI
-          [(match_operand:SI 1 "memory_operand" "+R")
+          [(match_operand:SI 1 "memory_operand" "+YC")
 	   (match_operand:SI 2 "register_operand" "d")
 	   (match_operand:SI 3 "register_operand" "d")
 	   (match_operand:SI 4 "register_operand" "dJ")]
@@ -327,7 +327,7 @@
   [(set_attr "length" "40")])
 
 (define_insn "sync_sub<mode>"
-  [(set (match_operand:GPR 0 "memory_operand" "+R")
+  [(set (match_operand:GPR 0 "memory_operand" "+YC")
 	(unspec_volatile:GPR
           [(minus:GPR (match_dup 0)
 			      (match_operand:GPR 1 "register_operand" "d"))]
@@ -340,7 +340,7 @@
 
 (define_insn "sync_old_add<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YC,YC"))
    (set (match_dup 1)
 	(unspec_volatile:GPR
           [(plus:GPR (match_dup 1)
@@ -357,7 +357,7 @@
 
 (define_insn "sync_old_sub<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d")
-	(match_operand:GPR 1 "memory_operand" "+R"))
+	(match_operand:GPR 1 "memory_operand" "+YC"))
    (set (match_dup 1)
 	(unspec_volatile:GPR
           [(minus:GPR (match_dup 1)
@@ -371,7 +371,7 @@
 
 (define_insn "sync_new_add<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-        (plus:GPR (match_operand:GPR 1 "memory_operand" "+R,R")
+        (plus:GPR (match_operand:GPR 1 "memory_operand" "+YC,YC")
 		  (match_operand:GPR 2 "arith_operand" "I,d")))
    (set (match_dup 1)
 	(unspec_volatile:GPR
@@ -388,7 +388,7 @@
 
 (define_insn "sync_new_sub<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d")
-        (minus:GPR (match_operand:GPR 1 "memory_operand" "+R")
+        (minus:GPR (match_operand:GPR 1 "memory_operand" "+YC")
 		   (match_operand:GPR 2 "register_operand" "d")))
    (set (match_dup 1)
 	(unspec_volatile:GPR
@@ -401,7 +401,7 @@
   [(set_attr "length" "28")])
 
 (define_insn "sync_<optab><mode>"
-  [(set (match_operand:GPR 0 "memory_operand" "+R,R")
+  [(set (match_operand:GPR 0 "memory_operand" "+YC,YC")
 	(unspec_volatile:GPR
           [(fetchop_bit:GPR (match_operand:GPR 1 "uns_arith_operand" "K,d")
 			      (match_dup 0))]
@@ -417,7 +417,7 @@
 
 (define_insn "sync_old_<optab><mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YC,YC"))
    (set (match_dup 1)
 	(unspec_volatile:GPR
           [(fetchop_bit:GPR (match_operand:GPR 2 "uns_arith_operand" "K,d")
@@ -435,7 +435,7 @@
 
 (define_insn "sync_new_<optab><mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YC,YC"))
    (set (match_dup 1)
 	(unspec_volatile:GPR
           [(fetchop_bit:GPR (match_operand:GPR 2 "uns_arith_operand" "K,d")
@@ -452,7 +452,7 @@
   [(set_attr "length" "28")])
 
 (define_insn "sync_nand<mode>"
-  [(set (match_operand:GPR 0 "memory_operand" "+R,R")
+  [(set (match_operand:GPR 0 "memory_operand" "+YC,YC")
 	(unspec_volatile:GPR [(match_operand:GPR 1 "uns_arith_operand" "K,d")]
 	 UNSPEC_SYNC_OLD_OP))]
   "GENERATE_LL_SC"
@@ -466,7 +466,7 @@
 
 (define_insn "sync_old_nand<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YC,YC"))
    (set (match_dup 1)
         (unspec_volatile:GPR [(match_operand:GPR 2 "uns_arith_operand" "K,d")]
 	 UNSPEC_SYNC_OLD_OP))]
@@ -481,7 +481,7 @@
 
 (define_insn "sync_new_nand<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YC,YC"))
    (set (match_dup 1)
 	(unspec_volatile:GPR [(match_operand:GPR 2 "uns_arith_operand" "K,d")]
 	 UNSPEC_SYNC_NEW_OP))]
@@ -496,7 +496,7 @@
 
 (define_insn "sync_lock_test_and_set<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YC,YC"))
    (set (match_dup 1)
 	(unspec_volatile:GPR [(match_operand:GPR 2 "arith_operand" "I,d")]
 	 UNSPEC_SYNC_EXCHANGE))]
@@ -524,7 +524,7 @@
 
 (define_insn "test_and_set_12"
   [(set (match_operand:SI 0 "register_operand" "=&d,&d")
-	(match_operand:SI 1 "memory_operand" "+R,R"))
+	(match_operand:SI 1 "memory_operand" "+YC,YC"))
    (set (match_dup 1)
 	(unspec_volatile:SI [(match_operand:SI 2 "register_operand" "d,d")
 			     (match_operand:SI 3 "register_operand" "d,d")
diff --git a/gcc/config/mips/t-crtfm b/gcc/config/mips/t-crtfm
new file mode 100644
index 000000000..d2a1fd744
--- /dev/null
+++ b/gcc/config/mips/t-crtfm
@@ -0,0 +1,9 @@
+
+EXTRA_MULTILIB_PARTS += crtfastmath.o
+
+EXTRA_PARTS += crtfastmath.o
+
+$(T)crtfastmath.o: $(srcdir)/config/mips/crtfastmath.c $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crtfastmath.o $(srcdir)/config/mips/crtfastmath.c
+
diff --git a/gcc/config/mips/t-fprules-softfp b/gcc/config/mips/t-fprules-softfp
new file mode 100644
index 000000000..69a5dc7ca
--- /dev/null
+++ b/gcc/config/mips/t-fprules-softfp
@@ -0,0 +1,6 @@
+softfp_float_modes := sf df
+softfp_int_modes := si di
+softfp_extensions := sfdf
+softfp_truncations := dfsf
+softfp_machine_header := mips/sfp-machine.h
+softfp_exclude_libgcc2 := y
diff --git a/gcc/config/mips/t-montavista-elf b/gcc/config/mips/t-montavista-elf
new file mode 100644
index 000000000..f966858f4
--- /dev/null
+++ b/gcc/config/mips/t-montavista-elf
@@ -0,0 +1,22 @@
+# MontaVista ELF Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS =
+MULTILIB_DIRNAMES =
diff --git a/gcc/config/mips/t-montavista-linux b/gcc/config/mips/t-montavista-linux
new file mode 100644
index 000000000..0c8640626
--- /dev/null
+++ b/gcc/config/mips/t-montavista-linux
@@ -0,0 +1,43 @@
+# MontaVista GNU/Linux Configuration.
+# Copyright (C) 2009
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Build big-endian and little-endian support libraries.
+MULTILIB_OPTIONS = mel msoft-float march=octeon mabi=n32/mabi=64
+MULTILIB_DIRNAMES = mel soft-float octeon n32 64
+MULTILIB_EXCEPTIONS = *mel*/*mabi=n32* *mel*/*mabi=64*
+MULTILIB_EXCEPTIONS += *mel*/*march=octeon* march=octeon march=octeon/mabi=n32
+MULTILIB_EXCEPTIONS += march=octeon/mabi=64 msoft-float/march=octeon
+
+# These files must be built for each multilib.
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
+# See comment in montavista-linux.h on STARTFILE_PREFIX_SPEC for how the real
+# directories used in the sysroots are determined.  These directories
+# are specified so that (a) they are distinct and (b) removing the
+# components that form part of the sysroot suffix leaves the real
+# directory within the sysroot.
+MULTILIB_OSDIRNAMES = msoft-float/mabi.n32=../lib32/soft-float
+MULTILIB_OSDIRNAMES += msoft-float/mabi.64=../lib64/soft-float
+MULTILIB_OSDIRNAMES += msoft-float/march.octeon/mabi.n32=../lib32/soft-float/octeon
+MULTILIB_OSDIRNAMES += msoft-float/march.octeon/mabi.64=../lib64/soft-float/octeon
+MULTILIB_OSDIRNAMES += mel/msoft-float=!mel/soft-float
+MULTILIB_OSDIRNAMES += msoft-float=!soft-float
+MULTILIB_OSDIRNAMES += mabi.64=../lib64
+MULTILIB_OSDIRNAMES += mabi.n32=../lib32
diff --git a/gcc/config/mips/t-octeon-elf b/gcc/config/mips/t-octeon-elf
new file mode 100644
index 000000000..984d18f3a
--- /dev/null
+++ b/gcc/config/mips/t-octeon-elf
@@ -0,0 +1,42 @@
+# Don't let CTOR_LIST end up in sdata section.
+
+CRTSTUFF_T_CFLAGS = -G 0 -fno-asynchronous-unwind-tables
+
+# Assemble startup files.
+
+$(T)crti.o: $(srcdir)/config/mips/crti.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/mips/crti.asm
+
+$(T)crtn.o: $(srcdir)/config/mips/crtn.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/mips/crtn.asm
+
+# N32 uses TFmode for long double.
+
+TPBIT = tp-bit.c
+
+tp-bit.c: $(srcdir)/config/fp-bit.c
+	echo '#ifdef __MIPSEL__' > tp-bit.c
+	echo '# define FLOAT_BIT_ORDER_MISMATCH' >> tp-bit.c
+	echo '#endif' >> tp-bit.c
+	echo '#if __LDBL_MANT_DIG__ == 113' >> tp-bit.c
+	echo '#define QUIET_NAN_NEGATED' >> tp-bit.c
+	echo '# define TFLOAT' >> tp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> tp-bit.c
+	echo '#endif' >> tp-bit.c
+
+# We must build libgcc2.a with -G 0, in case the user wants to link
+# without the $gp register.
+
+TARGET_LIBGCC2_CFLAGS = -G 0
+ 
+# Build both ABIs.
+
+MULTILIB_OPTIONS = mabi=n32/mabi=eabi/mabi=64 march=octeon2
+MULTILIB_DIRNAMES = n32 eabi n64 octeon2
+MULTILIB_EXCEPTIONS = mabi=64/march=octeon2
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
diff --git a/gcc/config/mips/t-sde b/gcc/config/mips/t-sde
index 64180d9ec..6fda5809d 100644
--- a/gcc/config/mips/t-sde
+++ b/gcc/config/mips/t-sde
@@ -10,8 +10,8 @@ $(T)crtn.o: $(srcdir)/config/mips/crtn.asm $(GCC_PASSES)
 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
 	-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/mips/crtn.asm
 
-MULTILIB_OPTIONS = EL/EB mips32/mips32r2/mips64/mips64r2 mips16 msoft-float/mfp64 mcode-readable=no
-MULTILIB_DIRNAMES = el eb mips32 mips32r2 mips64 mips64r2 mips16 sof f64 spram
+MULTILIB_OPTIONS = EL/EB mips32/mips32r2/mips64/mips64r2 mips16/micromips msoft-float/mfp64 mcode-readable=no
+MULTILIB_DIRNAMES = el eb mips32 mips32r2 mips64 mips64r2 mips16 micromips sof f64 spram
 MULTILIB_MATCHES = EL=mel EB=meb
 
 # The -mfp64 option is only valid in conjunction with -mips32r2.
@@ -28,6 +28,9 @@ else
 MULTILIB_EXCLUSIONS += mips64/mips16 mips64r2/mips16
 endif
 
+# The -mcode-readable=no is only in conjunction with -mips16.
+MULTILIB_EXCLUSIONS += mcode-readable=no/!mips16
+
 EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o
 
 # Build the multilibs.
diff --git a/gcc/config/mips/t-sgxx-linux b/gcc/config/mips/t-sgxx-linux
new file mode 100644
index 000000000..9e379ba1c
--- /dev/null
+++ b/gcc/config/mips/t-sgxx-linux
@@ -0,0 +1,13 @@
+MULTILIB_OPTIONS = muclibc mmicromips/march=mips2/march=mips32 msoft-float EL/EB
+MULTILIB_DIRNAMES = uclibc micromips mips2 mips32 soft-float el eb
+MULTILIB_MATCHES := EL=mel EB=meb \
+  march?mips2=mips2 march?mips2=mips3 march?mips2=mips4 \
+  $(foreach cpu,mips3 mips4 r6000 r4000 vr4100 vr4111 vr4120 vr4130 vr4300 \
+                r4400 r4600 orion r4650 loongson2e loongson2f r8000 r10000 \
+                r12000 r14000 r16000 vr5000 vr5400 vr5500 rm7000 \
+                rm9000,march?mips2=march?$(cpu)) \
+  march?mips32=mips32 march?mips32=mips64 \
+  $(foreach cpu,4kc 4km 4kp 4ksc mips64 5kc 5kf 20kc sb1 sb1a sr71000 \
+                xlr,march?mips32=march?$(cpu))
+MULTILIB_EXCEPTIONS = *muclibc*/*mmicromips* *muclibc*/*march?mips2* *muclibc*/*march?mips32*
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o 
diff --git a/gcc/config/mips/t-sgxx-sde b/gcc/config/mips/t-sgxx-sde
new file mode 100644
index 000000000..ee8fea024
--- /dev/null
+++ b/gcc/config/mips/t-sgxx-sde
@@ -0,0 +1,17 @@
+# SourceryG++ overrides for SDE builds
+
+# We must build libgcc2.a with -G 0, in case the user wants to link
+# without the $gp register. Use -fno-optimize-sibling-calls in case
+# we have a mixed mips16/non-mips16 environment where a plain "jump"
+# instuction won't work across the divide (no jx instruction).
+# Compile libraries with -mcode-xonly, so that they are link-compatible
+# with both -mcode-readable=pcrel and -mcode-readable=yes.
+TARGET_LIBGCC2_CFLAGS = -G 0 -fno-optimize-sibling-calls -mcode-xonly
+
+MULTILIB_OPTIONS = EL/EB mips16/mmicromips mfp64/msoft-float/mno-float mcode-readable=no
+MULTILIB_DIRNAMES = el eb mips16 micromips fp64 sof nof spram
+MULTILIB_MATCHES = EL=mel EB=meb mips16=mips16e
+MULTILIB_EXTRA_OPTS = mno-jals
+MULTILIB_EXCLUSIONS = mcode-readable=no/!mips16
+# Only hard and soft float micromips
+MULTILIB_EXCEPTIONS = *mmicromips/mfp64* *mmicromips/mno-float*
diff --git a/gcc/config/mips/t-sgxxlite-linux b/gcc/config/mips/t-sgxxlite-linux
new file mode 100644
index 000000000..a24956c68
--- /dev/null
+++ b/gcc/config/mips/t-sgxxlite-linux
@@ -0,0 +1,6 @@
+MULTILIB_OPTIONS = muclibc mmicromips msoft-float EL/EB
+MULTILIB_DIRNAMES = uclibc micromips soft-float el eb
+MULTILIB_MATCHES := EL=mel EB=meb
+MULTILIB_EXCEPTIONS = *muclibc*/*mmicromips*
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
diff --git a/gcc/config/mips/t-wrs-linux b/gcc/config/mips/t-wrs-linux
new file mode 100644
index 000000000..9bb4e35f1
--- /dev/null
+++ b/gcc/config/mips/t-wrs-linux
@@ -0,0 +1,58 @@
+# Wind River GNU/Linux Configuration.
+# Copyright (C) 2006, 2007
+# Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Build big-endian and little-endian support libraries.
+MULTILIB_OPTIONS = muclibc mel mhard-float march=octeon/march=octeon2/march=vr5500 mabi=n32/mabi=64
+MULTILIB_DIRNAMES = uclibc mel hard-float octeon octeon2 vr5500 n32 64
+MULTILIB_EXCEPTIONS = *muclibc*/*mhard-float*
+MULTILIB_EXCEPTIONS += *muclibc*/*mabi=n32*
+MULTILIB_EXCEPTIONS += *muclibc*/*mabi=64*
+MULTILIB_EXCEPTIONS += *muclibc*/*march=vr5500*
+MULTILIB_EXCEPTIONS += *mel*/*march=vr5500*
+MULTILIB_EXCEPTIONS += march=vr5500*
+MULTILIB_EXCEPTIONS += mhard-float/march=vr5500/*
+MULTILIB_EXCEPTIONS += */march=octeon* */march=octeon2*
+MULTILIB_EXCEPTIONS += march=octeon march=octeon/mabi=32
+MULTILIB_EXCEPTIONS += march=octeon2 march=octeon2/mabi=32
+MULTILIB_EXCEPTIONS += mel/mabi=n32 mel/mabi=64
+MULTILIB_EXCEPTIONS += mabi=n32
+# These files must be built for each multilib.
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
+# See comment in wrs-linux.h on STARTFILE_PREFIX_SPEC for how the real
+# directories used in the sysroots are determined.  These directories
+# are specified so that (a) they are distinct and (b) removing the
+# components that form part of the sysroot suffix leaves the real
+# directory within the sysroot.
+MULTILIB_OSDIRNAMES = mel/mhard-float/mabi.n32=../lib32/mel/hard-float
+MULTILIB_OSDIRNAMES += mel/mhard-float/mabi.64=../lib64/mel/hard-float
+MULTILIB_OSDIRNAMES += mhard-float/mabi.n32=../lib32/hard-float
+MULTILIB_OSDIRNAMES += mhard-float/mabi.64=../lib64/hard-float
+MULTILIB_OSDIRNAMES += mel/mhard-float=!mel/hard-float
+MULTILIB_OSDIRNAMES += mhard-float/march.vr5500=!hard-float/vr5500
+MULTILIB_OSDIRNAMES += mhard-float=!hard-float
+MULTILIB_OSDIRNAMES += mabi.64=../lib64
+MULTILIB_OSDIRNAMES += march.octeon/mabi.n32=../lib32/octeon
+MULTILIB_OSDIRNAMES += march.octeon/mabi.64=../lib64/octeon
+MULTILIB_OSDIRNAMES += march.octeon2/mabi.n32=../lib32/octeon2
+MULTILIB_OSDIRNAMES += march.octeon2/mabi.64=../lib64/octeon2
+MULTILIB_OSDIRNAMES += muclibc/mel=!uclibc/mel
+MULTILIB_OSDIRNAMES += muclibc=!uclibc
+
diff --git a/gcc/config/mips/wrs-linux.h b/gcc/config/mips/wrs-linux.h
new file mode 100644
index 000000000..2ae858f69
--- /dev/null
+++ b/gcc/config/mips/wrs-linux.h
@@ -0,0 +1,66 @@
+/* Wind River GNU/Linux Configuration.
+   Copyright (C) 2006, 2007
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Override linux64.h to default to O32.  */
+#undef DRIVER_SELF_SPECS
+#define DRIVER_SELF_SPECS \
+  BASE_DRIVER_SELF_SPECS, \
+  LINUX_DRIVER_SELF_SPECS \
+  " %{!EB:%{!EL:%(endian_spec)}}" \
+  " %{!mabi=*: -mabi=32}"
+
+/* We do not need to provide an explicit big-endian multilib.  */
+#undef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS \
+  { "meb", "mabi=32" }
+
+/* The GLIBC headers are in /usr/include, relative to the sysroot; the
+   uClibc headers are in /uclibc/usr/include.  */
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC		\
+  "%{muclibc:/uclibc}" 
+
+/* The various C libraries each have their own subdirectory.  */
+#undef SYSROOT_SUFFIX_SPEC
+#define SYSROOT_SUFFIX_SPEC				\
+  "%{muclibc:%{mel:/uclibc/mel ;			\
+               :/uclibc} ;				\
+     mel:%{mhard-float:/mel/hard-float ;		\
+           :/mel} ;					\
+     march=octeon:/octeon ;				\
+     march=octeon2:/octeon2 ;				\
+     march=vr5500:%{mhard-float:/hard-float/vr5500} ;	\
+     mhard-float:/hard-float}"
+
+/* MULTILIB_OSDIRNAMES provides directory names used in two ways:
+   relative to $target/lib/ in the GCC installation, and relative to
+   lib/ and usr/lib/ in a sysroot.  For the latter, we want names such
+   as plain ../lib64, but these cannot be used outside the sysroot
+   because different multilibs would be mapped to the same directory.
+   Directories are searched both with and without the multilib suffix,
+   so it suffices if the directory without the suffix is correct
+   within the sysroot while the directory with the suffix doesn't
+   exist.  We use STARTFILE_PREFIX_SPEC to achieve the desired
+   effect.  */
+#undef STARTFILE_PREFIX_SPEC
+#define STARTFILE_PREFIX_SPEC				\
+  "%{mabi=32: /usr/local/lib/ /lib/ /usr/lib/} 		\
+   %{mabi=n32: /usr/local/lib32/ /lib32/ /usr/lib32/}	\
+   %{mabi=64: /usr/local/lib64/ /lib64/ /usr/lib64/}"
diff --git a/gcc/config/mips/xlr.md b/gcc/config/mips/xlr.md
index 21550ba12..69913b7b2 100644
--- a/gcc/config/mips/xlr.md
+++ b/gcc/config/mips/xlr.md
@@ -1,5 +1,5 @@
 ;; DFA-based pipeline description for the XLR.
-;;   Copyright (C) 2008 Free Software Foundation, Inc.
+;;   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
 ;;
 ;; xlr.md   Machine Description for the RMI XLR Microprocessor
 ;; This file is part of GCC.
@@ -31,7 +31,7 @@
 ;; Integer arithmetic instructions.
 (define_insn_reservation "ir_xlr_alu" 1
   (and (eq_attr "cpu" "xlr") 
-       (eq_attr "type" "arith,shift,clz,const,unknown,multi,nop,trap"))
+       (eq_attr "type" "move,arith,shift,clz,logical,signext,const,unknown,multi,nop,trap"))
   "xlr_main_pipe")
 
 ;; Integer arithmetic instructions.
diff --git a/gcc/config/pa/pa-linux.h b/gcc/config/pa/pa-linux.h
index 8af089a4d..ab5809e41 100644
--- a/gcc/config/pa/pa-linux.h
+++ b/gcc/config/pa/pa-linux.h
@@ -31,12 +31,6 @@ along with GCC; see the file COPYING3.  If not see
 #undef CPP_SPEC
 #define CPP_SPEC "%{posix:-D_POSIX_SOURCE}"
 
-#undef	LIB_SPEC
-#define LIB_SPEC \
-  "%{pthread:-lpthread} \
-   %{shared:-lgcc -lc} \
-   %{!shared:%{mieee-fp:-lieee} %{shared-libgcc:-lgcc} %{profile:-lc_p}%{!profile:-lc}}"
-
 #undef ASM_SPEC
 #define ASM_SPEC \
   "%{v:-V} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}"
diff --git a/gcc/config/print-sysroot-suffix.sh b/gcc/config/print-sysroot-suffix.sh
new file mode 100644
index 000000000..9211a4a92
--- /dev/null
+++ b/gcc/config/print-sysroot-suffix.sh
@@ -0,0 +1,154 @@
+#! /bin/sh
+# Script to generate SYSROOT_SUFFIX_SPEC equivalent to MULTILIB_OSDIRNAMES
+# Arguments are MULTILIB_OSDIRNAMES, MULTILIB_OPTIONS, MULTILIB_MATCHES
+# and MULTILIB_ALIASES.
+
+# Copyright (C) 2009 Free Software Foundation, Inc.
+
+# This file is part of GCC.
+
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 3, or (at your option) any later
+# version.
+
+# GCC is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.  
+
+# This shell script produces a header file fragment that defines
+# SYSROOT_SUFFIX_SPEC.  It assumes that the sysroots will have the same
+# structure and names used by the multilibs.
+
+# Invocation:
+#   print-sysroot-suffix.sh \
+#          MULTILIB_OSDIRNAMES \
+#          MULTILIB_OPTIONS \
+#          MULTILIB_MATCHES \
+#      > t-sysroot-suffix.h
+
+# The three options exactly correspond to the variables of the same
+# names defined in the tmake_file fragments.
+
+# Example:
+#   sh ./gcc/config/print-sysroot-suffix.sh "a=A" "a b/c/d" ""
+# =>
+#   #undef SYSROOT_SUFFIX_SPEC
+#   #define SYSROOT_SUFFIX_SPEC "" \
+#   "%{a:" \
+#     "%{b:A/b/;" \
+#     "c:A/c/;" \
+#     "d:A/d/;" \
+#     ":A/};" \
+#   ":}"
+
+# The script uses temporary subscripts in order to permit a recursive
+# algorithm without the use of functions.
+
+set -e
+
+dirnames="$1"
+options="$2"
+matches="$3"
+aliases="$4"
+
+cat > print-sysroot-suffix3.sh <<\EOF
+#! /bin/sh
+# Print all the multilib matches for this option
+result="$1"
+EOF
+for x in $matches; do
+  l=`echo $x | sed -e 's/=.*$//' -e 's/?/=/g'`
+  r=`echo $x | sed -e 's/^.*=//' -e 's/?/=/g'`
+  echo "[ \"\$1\" = \"$l\" ] && result=\"\$result|$r\"" >> print-sysroot-suffix3.sh
+done
+echo 'echo $result' >> print-sysroot-suffix3.sh
+chmod +x print-sysroot-suffix3.sh
+
+cat > print-sysroot-suffix2.sh <<\EOF
+#! /bin/sh
+# Recursive script to enumerate all multilib combinations, match against
+# multilib directories and output a spec string of the result.
+# Will fold identical trees.
+
+padding="$1"
+optstring="$2"
+shift 2
+n="\" \\
+$padding\""
+if [ $# = 0 ]; then
+  case $optstring in
+EOF
+for x in $aliases; do
+  l=`echo $x | sed -e 's/=.*$//' -e 's/?/=/g'`
+  r=`echo $x | sed -e 's/^.*=//' -e 's/?/=/g'`
+  echo "/$r/) optstring=\"/$l/\" ;;" >> print-sysroot-suffix2.sh
+done
+echo "  esac" >> print-sysroot-suffix2.sh
+
+pat=
+for x in $dirnames; do
+  p=`echo $x | sed -e 's,=!,/$=/,'`
+  pat="$pat -e 's=^//$p='"
+done
+echo '  optstring=`echo "/$optstring" | sed '"$pat\`" >> print-sysroot-suffix2.sh
+cat >> print-sysroot-suffix2.sh <<\EOF
+  case $optstring in
+  //*)
+    ;;
+  *)
+    echo "$optstring"
+    ;;
+  esac
+else
+  thisopt="$1"
+  shift
+  bit=
+  lastcond=
+  result=
+  for x in `echo "$thisopt" | sed -e 's,/, ,g'`; do
+    case $x in
+EOF
+for x in `echo "$options" | sed -e 's,/, ,g'`; do
+  match=`./print-sysroot-suffix3.sh "$x"`
+  echo "$x) optmatch=\"$match\" ;;" >> print-sysroot-suffix2.sh
+done
+cat >> print-sysroot-suffix2.sh <<\EOF
+    esac
+    bit=`"$0" "$padding  " "$optstring$x/" "$@"`
+    if [ -z "$lastopt" ]; then
+      lastopt="$optmatch"
+    else
+      if [ "$lastbit" = "$bit" ]; then
+	lastopt="$lastopt|$optmatch"
+      else
+	result="$result$lastopt:$lastbit;$n"
+	lastopt="$optmatch"
+      fi
+    fi
+    lastbit="$bit"
+  done
+  bit=`"$0" "$padding  " "$optstring" "$@"`
+  if [ "$bit" = "$lastbit" ]; then
+    if [ -z "$result" ]; then
+      echo "$bit"
+    else
+      echo "$n%{$result:$bit}"
+    fi
+  else
+    echo "$n%{$result$lastopt:$lastbit;$n:$bit}"
+  fi
+fi
+EOF
+
+chmod +x ./print-sysroot-suffix2.sh
+result=`./print-sysroot-suffix2.sh "" "/" $options`
+echo "#undef SYSROOT_SUFFIX_SPEC"
+echo "#define SYSROOT_SUFFIX_SPEC \"$result\""
+rm print-sysroot-suffix2.sh
+rm print-sysroot-suffix3.sh
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index f0450d831..f2b5ebf93 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -920,6 +920,7 @@ int easy_vector_constant (rtx, enum machine_mode);
 static bool rs6000_is_opaque_type (const_tree);
 static rtx rs6000_dwarf_register_span (rtx);
 static void rs6000_init_dwarf_reg_sizes_extra (tree);
+static int rs6000_commutative_operand_precedence (const_rtx, int);
 static rtx rs6000_legitimize_tls_address (rtx, enum tls_model);
 static void rs6000_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;
 static rtx rs6000_tls_get_addr (void);
@@ -1195,6 +1196,10 @@ static const char alt_reg_names[][8] =
 #undef TARGET_VECTOR_OPAQUE_P
 #define TARGET_VECTOR_OPAQUE_P rs6000_is_opaque_type
 
+#undef TARGET_COMMUTATIVE_OPERAND_PRECEDENCE
+#define TARGET_COMMUTATIVE_OPERAND_PRECEDENCE \
+  rs6000_commutative_operand_precedence
+
 #undef TARGET_DWARF_REGISTER_SPAN
 #define TARGET_DWARF_REGISTER_SPAN rs6000_dwarf_register_span
 
@@ -22226,6 +22231,30 @@ rs6000_memory_move_cost (enum machine_mode mode, enum reg_class rclass,
     return 4 + rs6000_register_move_cost (mode, rclass, GENERAL_REGS);
 }
 
+/* Return a value indicating whether OP, an operand of a commutative
+   operation, is preferred as the first or second operand.  The higher
+   the value, the stronger the preference for being the first operand.
+   We use negative values to indicate a preference for the first operand
+   and positive values for the second operand.
+   VALUE is the default precedence for OP; see rtlanal.c:
+   commutative_operand_precendece.  */
+
+static int
+rs6000_commutative_operand_precedence (const_rtx op, int value)
+{
+  /* Prefer pointer objects over non pointer objects.
+     For rationale see PR28690.  */
+  if (GET_RTX_CLASS (GET_CODE (op)) == RTX_OBJ
+      && ((REG_P (op) && REG_POINTER (op))
+	  || (MEM_P (op) && MEM_POINTER (op))))
+    /* value = -1 */;
+  else
+    /* value = -2 */
+    --value;
+
+  return value;
+}
+
 /* Returns a code for a target-specific builtin that implements
    reciprocal of the function, or NULL_TREE if not available.  */
 
diff --git a/gcc/config/sh/constraints.md b/gcc/config/sh/constraints.md
index 6b0e5d27c..640b28ef0 100644
--- a/gcc/config/sh/constraints.md
+++ b/gcc/config/sh/constraints.md
@@ -22,6 +22,7 @@
 ;;  Bsc: SCRATCH - for the scratch register in movsi_ie in the
 ;;       fldi0 / fldi0 cases
 ;; Cxx: Constants other than only CONST_INT
+;;  Ccl: call site label
 ;;  Css: signed 16-bit constant, literal or symbolic
 ;;  Csu: unsigned 16-bit constant, literal or symbolic
 ;;  Csy: label or symbol
@@ -183,6 +184,11 @@
    hence mova is being used, hence do not select this pattern."
   (match_code "scratch"))
 
+(define_constraint "Ccl"
+  "A call site label, for bsrf."
+  (and (match_code "unspec")
+       (match_test "XINT (op, 1) == UNSPEC_CALLER")))
+
 (define_constraint "Css"
   "A signed 16-bit constant, literal or symbolic."
   (and (match_code "const")
diff --git a/gcc/config/sh/cs-sgxxlite-linux.h b/gcc/config/sh/cs-sgxxlite-linux.h
new file mode 100644
index 000000000..3b5b8b278
--- /dev/null
+++ b/gcc/config/sh/cs-sgxxlite-linux.h
@@ -0,0 +1,31 @@
+/* SH SourceryG++ GNU/Linux Configuration.
+   Copyright (C) 2008
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef SYSROOT_HEADERS_SUFFIX_SPEC
+#define SYSROOT_HEADERS_SUFFIX_SPEC \
+  "%{muclibc:/uclibc}"
+
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  /* __thread_support is not supported by uClibc.  */			\
+  if (linux_uclibc)						\
+    targetm.have_tls = 0;						\
+} while (0)
diff --git a/gcc/config/sh/cs-sgxxlite-linux.opt b/gcc/config/sh/cs-sgxxlite-linux.opt
new file mode 100644
index 000000000..08089b0be
--- /dev/null
+++ b/gcc/config/sh/cs-sgxxlite-linux.opt
@@ -0,0 +1,23 @@
+; Options for SH SourceryG++ GNU/Linux
+
+; Copyright (C) 2009 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+muclibc
+Target RejectNegative Var(building_for_uclibc)
+Building with -muclibc
diff --git a/gcc/config/sh/lib1funcs.asm b/gcc/config/sh/lib1funcs.asm
index 6e0a12c57..8e5522830 100644
--- a/gcc/config/sh/lib1funcs.asm
+++ b/gcc/config/sh/lib1funcs.asm
@@ -1973,7 +1973,10 @@ GLOBAL(moddi3):
 	HIDDEN_FUNC(GLOBAL(set_fpscr))
 GLOBAL(set_fpscr):
 	lds r4,fpscr
-#ifdef __PIC__
+#if defined(__SH_FDPIC__)
+	mov.l	LOCAL(set_fpscr_L1),r0
+	mov.l	@(r0,r12),r1
+#elif defined(__PIC__)
 	mov.l	r12,@-r15
 #ifdef __vxworks
 	mov.l	LOCAL(set_fpscr_L0_base),r12
@@ -2019,6 +2022,7 @@ GLOBAL(set_fpscr):
 #endif
 	.align 2
 #ifdef __PIC__
+#ifndef __SH_FDPIC__
 #ifdef __vxworks
 LOCAL(set_fpscr_L0_base):
 	.long ___GOTT_BASE__
@@ -2028,6 +2032,7 @@ LOCAL(set_fpscr_L0_index):
 LOCAL(set_fpscr_L0):
 	.long _GLOBAL_OFFSET_TABLE_
 #endif
+#endif /* __SH_FDPIC__ */
 LOCAL(set_fpscr_L1):
 	.long GLOBAL(fpscr_values@GOT)
 #else
@@ -2085,8 +2090,9 @@ GLOBAL(ic_invalidate):
 GLOBAL(ic_invalidate):
 	ocbwb	@r4
 	synco
-	rts
 	icbi	@r4
+	rts
+	  nop
 	ENDFUNC(GLOBAL(ic_invalidate))
 #elif defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) || (defined(__SH4_NOFPU__) && !defined(__SH5__))
 	/* For system code, we use ic_invalidate_line_i, but user code
@@ -2152,8 +2158,10 @@ GLOBAL(ic_invalidate):
 GLOBAL(ic_invalidate_array):
 	add	r1,r4
 	synco
-	rts
 	icbi	@r4
+	rts
+	  nop
+	.align 2
 	.long	0
 	ENDFUNC(GLOBAL(ic_invalidate_array))
 #elif defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) || (defined(__SH4_NOFPU__) && !defined(__SH5__))
diff --git a/gcc/config/sh/lib1funcs.h b/gcc/config/sh/lib1funcs.h
index d16a18b81..af4b41cc3 100644
--- a/gcc/config/sh/lib1funcs.h
+++ b/gcc/config/sh/lib1funcs.h
@@ -42,8 +42,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #define ALIAS(X,Y)	.global GLOBAL(X); .set GLOBAL(X),GLOBAL(Y)
 
-#ifdef __SH2A__
-#undef FMOVD_WORKS
+#if defined __SH2A__ && defined __FMOVD_ENABLED__
+#undef  FMOVD_WORKS
 #define FMOVD_WORKS
 #endif
 
diff --git a/gcc/config/sh/linux-unwind.h b/gcc/config/sh/linux-unwind.h
index 9f9beb928..7e1193179 100644
--- a/gcc/config/sh/linux-unwind.h
+++ b/gcc/config/sh/linux-unwind.h
@@ -24,7 +24,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 
 /* Do code reading to identify a signal frame, and set the frame
-   state data appropriately.  See unwind-dw2.c for the structs.  */
+   state data appropriately.  See unwind-dw2.c for the structs.
+   Don't use this at all if inhibit_libc is used.  */
+
+#ifndef inhibit_libc
 
 #include <signal.h>
 #include <sys/ucontext.h>
@@ -248,3 +251,5 @@ sh_fallback_frame_state (struct _Unwind_Context *context,
   return _URC_NO_REASON;
 }
 #endif /* defined (__SH5__) */
+
+#endif /* inhibit_libc */
diff --git a/gcc/config/sh/sh-protos.h b/gcc/config/sh/sh-protos.h
index 5b971960f..140d96e83 100644
--- a/gcc/config/sh/sh-protos.h
+++ b/gcc/config/sh/sh-protos.h
@@ -152,7 +152,7 @@ extern void fpscr_set_from_mem (int, HARD_REG_SET);
 extern void sh_pr_interrupt (struct cpp_reader *);
 extern void sh_pr_trapa (struct cpp_reader *);
 extern void sh_pr_nosave_low_regs (struct cpp_reader *);
-extern rtx function_symbol (rtx, const char *, enum sh_function_kind);
+extern rtx function_symbol (rtx, const char *, enum sh_function_kind, rtx *);
 extern rtx sh_get_pr_initial_val (void);
 
 extern rtx sh_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);
@@ -175,6 +175,9 @@ extern int sh2a_get_function_vector_number (rtx);
 extern int sh2a_is_function_vector_call (rtx);
 extern void sh_fix_range (const char *);
 extern bool sh_hard_regno_mode_ok (unsigned int, enum machine_mode);
+extern bool sh_illegitimate_symbolic_constant_p (rtx);
+extern rtx sh_load_function_descriptor (rtx);
+extern rtx sh_our_fdpic_reg (void);
 #endif /* ! GCC_SH_PROTOS_H */
 
 #ifdef SYMBIAN
diff --git a/gcc/config/sh/sh.c b/gcc/config/sh/sh.c
index 9b662d3f3..937300202 100644
--- a/gcc/config/sh/sh.c
+++ b/gcc/config/sh/sh.c
@@ -233,6 +233,7 @@ static void sh_media_init_builtins (void);
 static rtx sh_expand_builtin (tree, rtx, rtx, enum machine_mode, int);
 static void sh_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);
 static void sh_file_start (void);
+static bool sh_assemble_integer (rtx, unsigned, int);
 static int flow_dependent_p (rtx, rtx);
 static void flow_dependent_p_1 (rtx, const_rtx, void *);
 static int shiftcosts (rtx);
@@ -272,6 +273,7 @@ static bool sh_scalar_mode_supported_p (enum machine_mode);
 static int sh_dwarf_calling_convention (const_tree);
 static void sh_encode_section_info (tree, rtx, int);
 static int sh2a_function_vector_p (tree);
+static int sh_reloc_rw_mask (void);
 
 
 /* Initialize the GCC target structure.  */
@@ -304,6 +306,9 @@ static int sh2a_function_vector_p (tree);
 #undef TARGET_ASM_FILE_START_FILE_DIRECTIVE
 #define TARGET_ASM_FILE_START_FILE_DIRECTIVE true
 
+#undef TARGET_ASM_INTEGER
+#define TARGET_ASM_INTEGER sh_assemble_integer
+
 #undef TARGET_DEFAULT_TARGET_FLAGS
 #define TARGET_DEFAULT_TARGET_FLAGS TARGET_DEFAULT
 #undef TARGET_HANDLE_OPTION
@@ -483,6 +488,12 @@ static int sh2a_function_vector_p (tree);
 /* Machine-specific symbol_ref flags.  */
 #define SYMBOL_FLAG_FUNCVEC_FUNCTION    (SYMBOL_FLAG_MACH_DEP << 0)
 
+#undef TARGET_CANNOT_FORCE_CONST_MEM
+#define TARGET_CANNOT_FORCE_CONST_MEM sh_illegitimate_symbolic_constant_p
+
+#undef TARGET_ASM_RELOC_RW_MASK
+#define TARGET_ASM_RELOC_RW_MASK sh_reloc_rw_mask
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 /* Implement TARGET_HANDLE_OPTION.  */
@@ -1132,11 +1143,13 @@ expand_block_move (rtx *operands)
 	  rtx func_addr_rtx = gen_reg_rtx (Pmode);
 	  rtx r4 = gen_rtx_REG (SImode, 4);
 	  rtx r5 = gen_rtx_REG (SImode, 5);
+	  rtx lab;
 
-	  function_symbol (func_addr_rtx, "__movmemSI12_i4", SFUNC_STATIC);
+	  function_symbol (func_addr_rtx, "__movmemSI12_i4", SFUNC_STATIC,
+			   &lab);
 	  force_into (XEXP (operands[0], 0), r4);
 	  force_into (XEXP (operands[1], 0), r5);
-	  emit_insn (gen_block_move_real_i4 (func_addr_rtx));
+	  emit_insn (gen_block_move_real_i4 (func_addr_rtx, lab));
 	  return 1;
 	}
       else if (! TARGET_SMALLCODE)
@@ -1147,15 +1160,16 @@ expand_block_move (rtx *operands)
 	  rtx r4 = gen_rtx_REG (SImode, 4);
 	  rtx r5 = gen_rtx_REG (SImode, 5);
 	  rtx r6 = gen_rtx_REG (SImode, 6);
+	  rtx lab;
 
 	  entry_name = (bytes & 4 ? "__movmem_i4_odd" : "__movmem_i4_even");
-	  function_symbol (func_addr_rtx, entry_name, SFUNC_STATIC);
+	  function_symbol (func_addr_rtx, entry_name, SFUNC_STATIC, &lab);
 	  force_into (XEXP (operands[0], 0), r4);
 	  force_into (XEXP (operands[1], 0), r5);
 
 	  dwords = bytes >> 3;
 	  emit_insn (gen_move_insn (r6, GEN_INT (dwords - 1)));
-	  emit_insn (gen_block_lump_real_i4 (func_addr_rtx));
+	  emit_insn (gen_block_lump_real_i4 (func_addr_rtx, lab));
 	  return 1;
 	}
       else
@@ -1167,12 +1181,13 @@ expand_block_move (rtx *operands)
       rtx func_addr_rtx = gen_reg_rtx (Pmode);
       rtx r4 = gen_rtx_REG (SImode, 4);
       rtx r5 = gen_rtx_REG (SImode, 5);
+      rtx lab;
 
       sprintf (entry, "__movmemSI%d", bytes);
-      function_symbol (func_addr_rtx, entry, SFUNC_STATIC);
+      function_symbol (func_addr_rtx, entry, SFUNC_STATIC, &lab);
       force_into (XEXP (operands[0], 0), r4);
       force_into (XEXP (operands[1], 0), r5);
-      emit_insn (gen_block_move_real (func_addr_rtx));
+      emit_insn (gen_block_move_real (func_addr_rtx, lab));
       return 1;
     }
 
@@ -1185,8 +1200,9 @@ expand_block_move (rtx *operands)
       rtx r4 = gen_rtx_REG (SImode, 4);
       rtx r5 = gen_rtx_REG (SImode, 5);
       rtx r6 = gen_rtx_REG (SImode, 6);
+      rtx lab;
 
-      function_symbol (func_addr_rtx, "__movmem", SFUNC_STATIC);
+      function_symbol (func_addr_rtx, "__movmem", SFUNC_STATIC, &lab);
       force_into (XEXP (operands[0], 0), r4);
       force_into (XEXP (operands[1], 0), r5);
 
@@ -1199,7 +1215,7 @@ expand_block_move (rtx *operands)
       final_switch = 16 - ((bytes / 4) % 16);
       while_loop = ((bytes / 4) / 16 - 1) * 16;
       emit_insn (gen_move_insn (r6, GEN_INT (while_loop + final_switch)));
-      emit_insn (gen_block_lump_real (func_addr_rtx));
+      emit_insn (gen_block_lump_real (func_addr_rtx, lab));
       return 1;
     }
 
@@ -1212,8 +1228,10 @@ expand_block_move (rtx *operands)
 int
 prepare_move_operands (rtx operands[], enum machine_mode mode)
 {
+  rtx tmp, base, offset;
+
   if ((mode == SImode || mode == DImode)
-      && flag_pic
+      && (flag_pic || TARGET_FDPIC)
       && ! ((mode == Pmode || mode == ptr_mode)
 	    && tls_symbolic_operand (operands[1], Pmode) != 0))
     {
@@ -1303,12 +1321,22 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)
 	    {
 	    case TLS_MODEL_GLOBAL_DYNAMIC:
 	      tga_ret = gen_rtx_REG (Pmode, R0_REG);
+	      if (TARGET_FDPIC)
+		{
+		  rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+		  emit_move_insn (pic_reg, OUR_FDPIC_REG);
+		}
 	      emit_call_insn (gen_tls_global_dynamic (tga_ret, op1));
 	      op1 = tga_ret;
 	      break;
 
 	    case TLS_MODEL_LOCAL_DYNAMIC:
 	      tga_ret = gen_rtx_REG (Pmode, R0_REG);
+	      if (TARGET_FDPIC)
+		{
+		  rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+		  emit_move_insn (pic_reg, OUR_FDPIC_REG);
+		}
 	      emit_call_insn (gen_tls_local_dynamic (tga_ret, op1));
 
 	      tmp = gen_reg_rtx (Pmode);
@@ -1338,6 +1366,11 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)
 		}
 	      tga_op1 = !can_create_pseudo_p () ? op0 : gen_reg_rtx (Pmode);
 	      tmp = gen_sym2GOTTPOFF (op1);
+	      if (TARGET_FDPIC)
+		{
+		  rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+		  emit_move_insn (pic_reg, OUR_FDPIC_REG);
+		}
 	      emit_insn (gen_tls_initial_exec (tga_op1, tmp));
 	      op1 = tga_op1;
 	      break;
@@ -1365,6 +1398,21 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)
 	}
     }
 
+  if (SH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)
+    {
+      split_const (operands[1], &base, &offset);
+      if (GET_CODE (base) == SYMBOL_REF
+	  && !offset_within_block_p (base, INTVAL (offset)))
+	{
+	  tmp = can_create_pseudo_p () ? gen_reg_rtx (mode) : operands[0];
+	  emit_move_insn (tmp, base);
+	  if (!arith_operand (offset, mode))
+	    offset = force_reg (mode, offset);
+	  emit_insn (gen_add3_insn (operands[0], tmp, offset));
+	  return 1;
+	}
+    }
+
   return 0;
 }
 
@@ -2150,6 +2198,26 @@ sh_file_start (void)
     }
 }
 
+/* Implementation of TARGET_ASM_INTEGER for SH.  Pointers to functions
+   need to be output as pointers to function descriptors for
+   FDPIC.  */
+
+static bool
+sh_assemble_integer (rtx value, unsigned int size, int aligned_p)
+{
+  if (TARGET_FDPIC
+      && size == UNITS_PER_WORD
+      && GET_CODE (value) == SYMBOL_REF
+      && SYMBOL_REF_FUNCTION_P (value))
+    {
+      fputs ("\t.long\t", asm_out_file);
+      output_addr_const (asm_out_file, value);
+      fputs ("@FUNCDESC\n", asm_out_file);
+      return true;
+    }
+  return default_assemble_integer (value, size, aligned_p);
+}
+
 /* Check if PAT includes UNSPEC_CALLER unspec pattern.  */
 
 static bool
@@ -2178,7 +2246,7 @@ sh_cannot_copy_insn_p (rtx insn)
 {
   rtx pat;
 
-  if (!reload_completed || !flag_pic)
+  if (!reload_completed || (!flag_pic && !TARGET_FDPIC))
     return false;
 
   if (GET_CODE (insn) != INSN)
@@ -2717,6 +2785,7 @@ expand_ashiftrt (rtx *operands)
   rtx wrk;
   char func[18];
   int value;
+  rtx lab;
 
   if (TARGET_SH3)
     {
@@ -2782,8 +2851,8 @@ expand_ashiftrt (rtx *operands)
   /* Load the value into an arg reg and call a helper.  */
   emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);
   sprintf (func, "__ashiftrt_r4_%d", value);
-  function_symbol (wrk, func, SFUNC_STATIC);
-  emit_insn (gen_ashrsi3_n (GEN_INT (value), wrk));
+  function_symbol (wrk, func, SFUNC_STATIC, &lab);
+  emit_insn (gen_ashrsi3_n (GEN_INT (value), wrk, lab));
   emit_move_insn (operands[0], gen_rtx_REG (SImode, 4));
   return 1;
 }
@@ -3742,14 +3811,13 @@ broken_move (rtx insn)
 		&& GET_CODE (SET_SRC (pat)) == CONST_DOUBLE
 		&& (fp_zero_operand (SET_SRC (pat))
 		    || fp_one_operand (SET_SRC (pat)))
-		/* ??? If this is a -m4 or -m4-single compilation, in general
-		   we don't know the current setting of fpscr, so disable fldi.
+		/* In general we don't know the current setting of fpscr, so disable fldi.
 		   There is an exception if this was a register-register move
 		   before reload - and hence it was ascertained that we have
 		   single precision setting - and in a post-reload optimization
 		   we changed this to do a constant load.  In that case
 		   we don't have an r0 clobber, hence we must use fldi.  */
-		&& (! TARGET_SH4 || TARGET_FMOVD
+		&& (TARGET_FMOVD
 		    || (GET_CODE (XEXP (XVECEXP (PATTERN (insn), 0, 2), 0))
 			== SCRATCH))
 		&& GET_CODE (SET_DEST (pat)) == REG
@@ -6535,7 +6603,9 @@ sh_expand_prologue (void)
   else
     push_regs (&live_regs_mask, current_function_interrupt);
 
-  if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))
+  if (flag_pic
+      && !TARGET_FDPIC
+      && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))
     emit_insn (gen_GOTaddr2picreg ());
 
   if (SHMEDIA_REGS_STACK_ADJUST ())
@@ -6545,7 +6615,7 @@ sh_expand_prologue (void)
       function_symbol (gen_rtx_REG (Pmode, R0_REG),
 		       (TARGET_FPU_ANY
 			? "__GCC_push_shmedia_regs"
-			: "__GCC_push_shmedia_regs_nofpu"), SFUNC_GOT);
+			: "__GCC_push_shmedia_regs_nofpu"), SFUNC_GOT, NULL);
       emit_insn (gen_shmedia_save_restore_regs_compact
 		 (GEN_INT (-SHMEDIA_REGS_STACK_ADJUST ())));
     }
@@ -6567,7 +6637,7 @@ sh_expand_prologue (void)
       /* This must NOT go through the PLT, otherwise mach and macl
 	 may be clobbered.  */
       function_symbol (gen_rtx_REG (Pmode, R0_REG),
-		      "__GCC_shcompact_incoming_args", SFUNC_GOT);
+		      "__GCC_shcompact_incoming_args", SFUNC_GOT, NULL);
       emit_insn (gen_shcompact_incoming_args ());
     }
 }
@@ -6646,7 +6716,7 @@ sh_expand_epilogue (bool sibcall_p)
       function_symbol (gen_rtx_REG (Pmode, R0_REG),
 		       (TARGET_FPU_ANY
 			? "__GCC_pop_shmedia_regs"
-			: "__GCC_pop_shmedia_regs_nofpu"), SFUNC_GOT);
+			: "__GCC_pop_shmedia_regs_nofpu"), SFUNC_GOT, NULL);
       /* This must NOT go through the PLT, otherwise mach and macl
 	 may be clobbered.  */
       emit_insn (gen_shmedia_save_restore_regs_compact
@@ -8461,7 +8531,7 @@ fp_one_operand (rtx op)
   return REAL_VALUES_EQUAL (r, dconst1);
 }
 
-/* For -m4 and -m4-single-only, mode switching is used.  If we are
+/* In general mode switching is used.  If we are
    compiling without -mfmovd, movsf_ie isn't taken into account for
    mode switching.  We could check in machine_dependent_reorg for
    cases where we know we are in single precision mode, but there is
@@ -8471,7 +8541,7 @@ fp_one_operand (rtx op)
 int
 fldi_ok (void)
 {
-  return ! TARGET_SH4 || TARGET_FMOVD || reload_completed;
+  return 1;
 }
 
 int
@@ -8841,9 +8911,12 @@ nonpic_symbol_mentioned_p (rtx x)
 	  || XINT (x, 1) == UNSPEC_GOTPLT
 	  || XINT (x, 1) == UNSPEC_GOTTPOFF
 	  || XINT (x, 1) == UNSPEC_DTPOFF
+	  || XINT (x, 1) == UNSPEC_TPOFF
 	  || XINT (x, 1) == UNSPEC_PLT
 	  || XINT (x, 1) == UNSPEC_SYMOFF
-	  || XINT (x, 1) == UNSPEC_PCREL_SYMOFF))
+	  || XINT (x, 1) == UNSPEC_PCREL_SYMOFF
+	  || XINT (x, 1) == UNSPEC_GOTFUNCDESC
+	  || XINT (x, 1) == UNSPEC_GOTOFFFUNCDESC))
     return 0;
 
   fmt = GET_RTX_FORMAT (GET_CODE (x));
@@ -8879,7 +8952,26 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,
       if (reg == 0)
 	reg = gen_reg_rtx (Pmode);
 
-      emit_insn (gen_symGOTOFF2reg (reg, orig));
+      if (TARGET_FDPIC
+	  && GET_CODE (orig) == SYMBOL_REF
+	  && SYMBOL_REF_FUNCTION_P (orig))
+	{
+	  /* Weak functions may be NULL which doesn't work with
+	     GOTOFFFUNCDESC because the runtime offset is not known.  */
+	  if (SYMBOL_REF_WEAK (orig))
+	    emit_insn (gen_symGOTFUNCDESC2reg (reg, orig));
+	  else
+	    emit_insn (gen_symGOTOFFFUNCDESC2reg (reg, orig));
+	}
+      else if (TARGET_FDPIC
+	       && (GET_CODE (orig) == LABEL_REF
+		   || (GET_CODE (orig) == SYMBOL_REF
+		       && SYMBOL_REF_DECL (orig)
+		       && TREE_READONLY (SYMBOL_REF_DECL (orig)))))
+	/* In FDPIC, GOTOFF can only be used for writable data.  */
+	emit_insn (gen_symGOT2reg (reg, orig));
+      else
+	emit_insn (gen_symGOTOFF2reg (reg, orig));
       return reg;
     }
   else if (GET_CODE (orig) == SYMBOL_REF)
@@ -8887,7 +8979,10 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,
       if (reg == 0)
 	reg = gen_reg_rtx (Pmode);
 
-      emit_insn (gen_symGOT2reg (reg, orig));
+      if (TARGET_FDPIC && SYMBOL_REF_FUNCTION_P (orig))
+	emit_insn (gen_symGOTFUNCDESC2reg (reg, orig));
+      else
+	emit_insn (gen_symGOT2reg (reg, orig));
       return reg;
     }
   return orig;
@@ -9837,7 +9932,7 @@ sh_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)
       if (!TARGET_INLINE_IC_INVALIDATE
 	  || (!(TARGET_SH4A_ARCH || TARGET_SH4_300) && TARGET_USERMODE))
 	emit_library_call (function_symbol (NULL, "__ic_invalidate",
-					    FUNCTION_ORDINARY),
+					    FUNCTION_ORDINARY, NULL),
 			   0, VOIDmode, 1, tramp, SImode);
       else
 	emit_insn (gen_ic_invalidate_line (tramp));
@@ -10608,10 +10703,18 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
     sibcall = gen_sibcalli_thunk (funexp, const0_rtx);
   else
 #endif
-  if (TARGET_SH2 && flag_pic)
+  if (TARGET_SH2 && (flag_pic || TARGET_FDPIC))
     {
-      sibcall = gen_sibcall_pcrel (funexp, const0_rtx);
-      XEXP (XVECEXP (sibcall, 0, 2), 0) = scratch2;
+      if (TARGET_FDPIC)
+        {
+	  sibcall = gen_sibcall_pcrel_fdpic (funexp, const0_rtx);
+          XEXP (XVECEXP (sibcall, 0, 3), 0) = scratch2;
+        }
+      else
+        {
+	  sibcall = gen_sibcall_pcrel (funexp, const0_rtx);
+          XEXP (XVECEXP (sibcall, 0, 2), 0) = scratch2;
+        }
     }
   else
     {
@@ -10687,11 +10790,24 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
   epilogue_completed = 0;
 }
 
+/* Return an RTX for the address of a function NAME of kind KIND,
+   placing the result in TARGET if not NULL.  LAB should be non-NULL
+   for SFUNC_STATIC, if FDPIC; it will be set to (const_int 0) if jsr
+   should be used, or a label_ref if bsrf should be used.  For FDPIC,
+   both SFUNC_GOT and SFUNC_STATIC will return the address of the
+   function itself, not a function descriptor, so they can only be
+   used with functions not using the FDPIC register that are known to
+   be called directory without a PLT entry.  */
+
 rtx
-function_symbol (rtx target, const char *name, enum sh_function_kind kind)
+function_symbol (rtx target, const char *name, enum sh_function_kind kind,
+		 rtx *lab)
 {
   rtx sym;
 
+  if (lab)
+    *lab = const0_rtx;
+
   /* If this is not an ordinary function, the name usually comes from a
      string literal or an sprintf buffer.  Make sure we use the same
      string consistently, so that cse will be able to unify address loads.  */
@@ -10699,7 +10815,7 @@ function_symbol (rtx target, const char *name, enum sh_function_kind kind)
     name = IDENTIFIER_POINTER (get_identifier (name));
   sym = gen_rtx_SYMBOL_REF (Pmode, name);
   SYMBOL_REF_FLAGS (sym) = SYMBOL_FLAG_FUNCTION;
-  if (flag_pic)
+  if (flag_pic || TARGET_FDPIC)
     switch (kind)
       {
       case FUNCTION_ORDINARY:
@@ -10714,14 +10830,27 @@ function_symbol (rtx target, const char *name, enum sh_function_kind kind)
 	}
       case SFUNC_STATIC:
 	{
-	  /* ??? To allow cse to work, we use GOTOFF relocations.
-	     we could add combiner patterns to transform this into
-	     straight pc-relative calls with sym2PIC / bsrf when
-	     label load and function call are still 1:1 and in the
-	     same basic block during combine.  */
 	  rtx reg = target ? target : gen_reg_rtx (Pmode);
 
-	  emit_insn (gen_symGOTOFF2reg (reg, sym));
+	  if (TARGET_FDPIC)
+	    {
+	      /* We use PC-relative calls, since GOTOFF can only refer
+		 to writable data.  This works along with
+		 sh_sfunc_call.  */
+	      gcc_assert (lab != NULL);
+	      *lab = PATTERN (gen_call_site ());
+	      emit_insn (gen_sym_label2reg (reg, sym, *lab));
+	    }
+	  else
+	    {
+	      /* ??? To allow cse to work, we use GOTOFF relocations.
+		 we could add combiner patterns to transform this into
+		 straight pc-relative calls with sym2PIC / bsrf when
+		 label load and function call are still 1:1 and in the
+		 same basic block during combine.  */
+	      emit_insn (gen_symGOTOFF2reg (reg, sym));
+	    }
+
 	  sym = reg;
 	  break;
 	}
@@ -11361,4 +11490,61 @@ sh_secondary_reload (bool in_p, rtx x, enum reg_class rclass,
 
 enum sh_divide_strategy_e sh_div_strategy = SH_DIV_STRATEGY_DEFAULT;
 
+bool
+sh_illegitimate_symbolic_constant_p (rtx x)
+{
+  rtx base, offset;
+
+  if (TARGET_FDPIC && !LEGITIMATE_PIC_OPERAND_P (x))
+    return true;
+
+  if (SH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)
+    {
+      split_const (x, &base, &offset);
+      if (GET_CODE (base) == SYMBOL_REF
+	  && !offset_within_block_p (base, INTVAL (offset)))
+	return true;
+    }
+  return false;
+}
+
+/* Emit insns to load the function address from FUNCDESC (an FDPIC
+   function descriptor) into r1 and the GOT address into r12,
+   returning an rtx for r1.  */
+
+rtx
+sh_load_function_descriptor (rtx funcdesc)
+{
+  rtx r1 = gen_rtx_REG (Pmode, R1_REG);
+  rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+  rtx fnaddr = gen_rtx_MEM (Pmode, funcdesc);
+  rtx gotaddr = gen_rtx_MEM (Pmode, plus_constant (funcdesc, 4));
+
+  emit_move_insn (r1, fnaddr);
+  /* The ABI requires the entry point address to be loaded first, so
+     prevent the load from being moved after that of the GOT
+     address.  */
+  emit_insn (gen_blockage ());
+  emit_move_insn (pic_reg, gotaddr);
+  return r1;
+}
+
+/* Return an rtx holding the initial value of the FDPIC register (the
+   FDPIC pointer passed in from the caller).  */
+
+rtx
+sh_our_fdpic_reg (void)
+{
+  return get_hard_reg_initial_val (Pmode, PIC_REG);
+}
+
+/* Relocatable data for FDPIC binaries is not permitted in read-only
+   segments.  */
+
+static int
+sh_reloc_rw_mask (void)
+{
+  return (flag_pic || TARGET_FDPIC) ? 3 : 0;
+}
+
 #include "gt-sh.h"
diff --git a/gcc/config/sh/sh.h b/gcc/config/sh/sh.h
index 6a4ccb0f0..3de04d26c 100644
--- a/gcc/config/sh/sh.h
+++ b/gcc/config/sh/sh.h
@@ -91,6 +91,13 @@ do { \
     builtin_define ("__SH_FPU_DOUBLE__"); \
   if (TARGET_HITACHI) \
     builtin_define ("__HITACHI__"); \
+  if (TARGET_FMOVD) \
+    builtin_define ("__FMOVD_ENABLED__"); \
+  if (TARGET_FDPIC) \
+    { \
+      builtin_define ("__SH_FDPIC__"); \
+      builtin_define ("__FDPIC__"); \
+    } \
   builtin_define (TARGET_LITTLE_ENDIAN \
 		  ? "__LITTLE_ENDIAN__" : "__BIG_ENDIAN__"); \
 } while (0)
@@ -123,6 +130,12 @@ do { \
       fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;				\
       call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;			\
     }									\
+  if (TARGET_FDPIC)							\
+    {									\
+      fixed_regs[PIC_REG] = 1;						\
+      call_used_regs[PIC_REG] = 1;					\
+      call_really_used_regs[PIC_REG] = 1;				\
+    }									\
   /* Renesas saves and restores mac registers on call.  */		\
   if (TARGET_HITACHI && ! TARGET_NOMACSAVE)				\
     {									\
@@ -458,7 +471,10 @@ do { \
 #define SH_DIV_STR_FOR_SIZE "call"
 #endif
 
-#define DRIVER_SELF_SPECS "%{m2a:%{ml:%eSH2a does not support little-endian}}"
+#define DRIVER_SELF_SPECS SUBTARGET_DRIVER_SELF_SPECS \
+  "%{m2a:%{ml:%eSH2a does not support little-endian}}"
+#define SUBTARGET_DRIVER_SELF_SPECS
+
 #define OPTIMIZATION_OPTIONS(LEVEL,SIZE)				\
 do {									\
   if (LEVEL)								\
@@ -552,11 +568,7 @@ do {									\
   if (TARGET_SH2E)							\
     sh_cpu = CPU_SH2E;							\
   if (TARGET_SH2A)							\
-    {									\
-      sh_cpu = CPU_SH2A;						\
-      if (TARGET_SH2A_DOUBLE)						\
-        target_flags |= MASK_FMOVD;					\
-    }									\
+    sh_cpu = CPU_SH2A;						\
   if (TARGET_SH3)							\
     sh_cpu = CPU_SH3;							\
   if (TARGET_SH3E)							\
@@ -684,6 +696,10 @@ do {									\
     sh_branch_cost							\
       = TARGET_SH5 ? 1 : ! TARGET_SH2 || TARGET_HARD_SH4 ? 2 : 1;	\
 									\
+  if (TARGET_FDPIC							\
+      && (TARGET_SHMEDIA || TARGET_SHCOMPACT || !TARGET_SH2))		\
+    sorry ("non-SH2 FDPIC");						\
+									\
   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)		\
     if (! VALID_REGISTER_P (regno))					\
       sh_register_names[regno][0] = '\0';				\
@@ -703,7 +719,7 @@ do {									\
       flag_omit_frame_pointer = 0;					\
    }									\
 									\
-  if ((flag_pic && ! TARGET_PREFERGOT)					\
+  if (((flag_pic || TARGET_FDPIC) && ! TARGET_PREFERGOT)		\
       || (TARGET_SHMEDIA && !TARGET_PT_FIXED))				\
     flag_no_function_cse = 1;						\
 									\
@@ -712,8 +728,9 @@ do {									\
       /* Never run scheduling before reload, since that can		\
 	 break global alloc, and generates slower code anyway due	\
 	 to the pressure on R0.  */					\
-      /* Enable sched1 for SH4; ready queue will be reordered by	\
-	 the target hooks when pressure is high. We can not do this for \
+      /* Enable sched1 for SH4 if the user explicitly requests.		\
+	 When sched1 is enabled, the ready queue will be reordered by	\
+	 the target hooks if pressure is high.  We can not do this for	\
 	 PIC, SH3 and lower as they give spill failures for R0.  */	\
       if (!TARGET_HARD_SH4 || flag_pic)					\
         flag_schedule_insns = 0;		 			\
@@ -728,6 +745,8 @@ do {									\
 	    warning (0, "ignoring -fschedule-insns because of exception handling bug");	\
 	  flag_schedule_insns = 0;		 			\
 	}								\
+      else if (flag_schedule_insns == 2)				\
+	flag_schedule_insns = 0;		 			\
     }									\
 									\
   if (align_loops == 0)							\
@@ -1260,6 +1279,14 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \
    code access to data items.  */
 #define PIC_OFFSET_TABLE_REGNUM	(flag_pic ? PIC_REG : INVALID_REGNUM)
 
+/* For FDPIC, the FDPIC register is call-clobbered (otherwise PLT
+   entries would need to handle saving and restoring it).  */
+#define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED TARGET_FDPIC
+
+/* An rtx holding the initial value of the FDPIC register (the FDPIC
+   pointer passed in from the caller).  */
+#define OUR_FDPIC_REG		sh_our_fdpic_reg ()
+
 #define GOT_SYMBOL_NAME "*_GLOBAL_OFFSET_TABLE_"
 
 /* Value should be nonzero if functions must have frame pointers.
@@ -2172,6 +2199,10 @@ struct sh_args {
       || GENERAL_REGISTER_P ((unsigned) reg_renumber[(REGNO)])) \
    : (REGNO) == R0_REG || (unsigned) reg_renumber[(REGNO)] == R0_REG)
 
+/* True if SYMBOL + OFFSET constants must refer to something within
+   SYMBOL's section.  */
+#define SH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P 0
+
 /* Maximum number of registers that can appear in a valid memory
    address.  */
 
@@ -2185,7 +2216,7 @@ struct sh_args {
 /* can_store_by_pieces constructs VOIDmode CONST_DOUBLEs.  */
 
 #define LEGITIMATE_CONSTANT_P(X) \
-  (TARGET_SHMEDIA							\
+  ((TARGET_SHMEDIA							\
    ? ((GET_MODE (X) != DFmode						\
        && GET_MODE_CLASS (GET_MODE (X)) != MODE_VECTOR_FLOAT)		\
       || (X) == CONST0_RTX (GET_MODE (X))				\
@@ -2193,7 +2224,8 @@ struct sh_args {
       || TARGET_SHMEDIA64)						\
    : (GET_CODE (X) != CONST_DOUBLE					\
       || GET_MODE (X) == DFmode || GET_MODE (X) == SFmode		\
-      || GET_MODE (X) == DImode || GET_MODE (X) == VOIDmode))
+      || GET_MODE (X) == DImode || GET_MODE (X) == VOIDmode))		\
+   && !sh_illegitimate_symbolic_constant_p (X))
 
 /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx
    and check its validity for a certain class.
@@ -3132,6 +3164,14 @@ struct sh_args {
 	    output_addr_const (STREAM, XVECEXP (X, 0, 1));		\
 	    fputs ("-.)", STREAM);					\
 	    break;							\
+	  case UNSPEC_GOTFUNCDESC:					\
+	    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));		\
+	    fputs ("@GOTFUNCDESC", (STREAM));				\
+	    break;							\
+	  case UNSPEC_GOTOFFFUNCDESC:					\
+	    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));		\
+	    fputs ("@GOTOFFFUNCDESC", (STREAM));			\
+	    break;							\
 	  default:							\
 	    goto FAIL;							\
 	  }								\
@@ -3279,12 +3319,20 @@ extern int current_function_interrupt;
 #define EH_RETURN_STACKADJ_REGNO STATIC_CHAIN_REGNUM
 #define EH_RETURN_STACKADJ_RTX	gen_rtx_REG (Pmode, EH_RETURN_STACKADJ_REGNO)
 
+#ifdef __SH_FDPIC__
+#define CRT_GET_RFIB_DATA(dbase) \
+  ({ register int r12 __asm__("r12"); (dbase) = r12; })
+#endif
+
 /* We have to distinguish between code and data, so that we apply
    datalabel where and only where appropriate.  Use sdataN for data.  */
 #define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
- ((flag_pic && (GLOBAL) ? DW_EH_PE_indirect : 0) \
-  | (flag_pic ? DW_EH_PE_pcrel : DW_EH_PE_absptr) \
-  | ((CODE) ? 0 : (TARGET_SHMEDIA64 ? DW_EH_PE_sdata8 : DW_EH_PE_sdata4)))
+  ((TARGET_FDPIC \
+    ? ((GLOBAL) ? DW_EH_PE_indirect | DW_EH_PE_datarel \
+       : DW_EH_PE_pcrel) \
+    : ((flag_pic && (GLOBAL) ? DW_EH_PE_indirect : 0) \
+       | (flag_pic ? DW_EH_PE_pcrel : DW_EH_PE_absptr))) \
+   | ((CODE) ? 0 : (TARGET_SHMEDIA64 ? DW_EH_PE_sdata8 : DW_EH_PE_sdata4)))
 
 /* Handle special EH pointer encodings.  Absolute, pc-relative, and
    indirect are handled automatically.  */
@@ -3297,6 +3345,17 @@ extern int current_function_interrupt;
 	SYMBOL_REF_FLAGS (ADDR) |= SYMBOL_FLAG_FUNCTION; \
 	if (0) goto DONE; \
       } \
+    if (TARGET_FDPIC \
+        && ((ENCODING) & 0xf0) == (DW_EH_PE_indirect | DW_EH_PE_datarel)) \
+      { \
+        fputs ("\t.ualong ", FILE); \
+        output_addr_const (FILE, ADDR); \
+        if (GET_CODE (ADDR) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (ADDR)) \
+          fputs ("@GOTFUNCDESC", FILE); \
+        else \
+          fputs ("@GOT", FILE); \
+        goto DONE; \
+      } \
   } while (0)
 
 #if (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__
diff --git a/gcc/config/sh/sh.md b/gcc/config/sh/sh.md
index 37c671def..ac0639ee6 100644
--- a/gcc/config/sh/sh.md
+++ b/gcc/config/sh/sh.md
@@ -164,6 +164,9 @@
   ;; (unspec [OFFSET ANCHOR] UNSPEC_PCREL_SYMOFF) == OFFSET - (ANCHOR - .).
   (UNSPEC_PCREL_SYMOFF	46)
 
+  (UNSPEC_GOTFUNCDESC	50)
+  (UNSPEC_GOTOFFFUNCDESC	51)
+
   ;; These are used with unspec_volatile.
   (UNSPECV_BLOCKAGE	0)
   (UNSPECV_ALIGN	1)
@@ -1751,14 +1754,17 @@
 ;; If we let reload allocate r0, then this problem can never happen.
 
 (define_insn "udivsi3_i1"
-  [(set (match_operand:SI 0 "register_operand" "=z")
+  [(set (match_operand:SI 0 "register_operand" "=z,z")
 	(udiv:SI (reg:SI R4_REG) (reg:SI R5_REG)))
    (clobber (reg:SI T_REG))
    (clobber (reg:SI PR_REG))
    (clobber (reg:SI R4_REG))
-   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+   (use (match_operand:SI 1 "arith_reg_operand" "r,r"))
+   (use (match_operand 2 "" "Z,Ccl"))]
   "TARGET_SH1 && ! TARGET_SH4"
-  "jsr	@%1%#"
+  "@
+   jsr	@%1%#
+   bsrf	%1\\n%O2:%#"
   [(set_attr "type" "sfunc")
    (set_attr "needs_delay_slot" "yes")])
 
@@ -1808,7 +1814,7 @@
 }")
 
 (define_insn "udivsi3_i4"
-  [(set (match_operand:SI 0 "register_operand" "=y")
+  [(set (match_operand:SI 0 "register_operand" "=y,y")
 	(udiv:SI (reg:SI R4_REG) (reg:SI R5_REG)))
    (clobber (reg:SI T_REG))
    (clobber (reg:SI PR_REG))
@@ -1820,15 +1826,18 @@
    (clobber (reg:SI R4_REG))
    (clobber (reg:SI R5_REG))
    (use (reg:PSI FPSCR_REG))
-   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+   (use (match_operand:SI 1 "arith_reg_operand" "r,r"))
+   (use (match_operand 2 "" "Z,Ccl"))]
   "TARGET_SH4 && ! TARGET_FPU_SINGLE"
-  "jsr	@%1%#"
+  "@
+   jsr	@%1%#
+   bsrf	%1\\n%O2:%#"
   [(set_attr "type" "sfunc")
    (set_attr "fp_mode" "double")
    (set_attr "needs_delay_slot" "yes")])
 
 (define_insn "udivsi3_i4_single"
-  [(set (match_operand:SI 0 "register_operand" "=y")
+  [(set (match_operand:SI 0 "register_operand" "=y,y")
 	(udiv:SI (reg:SI R4_REG) (reg:SI R5_REG)))
    (clobber (reg:SI T_REG))
    (clobber (reg:SI PR_REG))
@@ -1839,9 +1848,12 @@
    (clobber (reg:SI R1_REG))
    (clobber (reg:SI R4_REG))
    (clobber (reg:SI R5_REG))
-   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+   (use (match_operand:SI 1 "arith_reg_operand" "r,r"))
+   (use (match_operand 2 "" "Z,Ccl"))]
   "(TARGET_HARD_SH4 || TARGET_SHCOMPACT) && TARGET_FPU_SINGLE"
-  "jsr	@%1%#"
+  "@
+   jsr	@%1%#
+   bsrf	%1\\n%O2:%#"
   [(set_attr "type" "sfunc")
    (set_attr "needs_delay_slot" "yes")])
 
@@ -1895,16 +1907,17 @@
 	  emit_move_insn (operands[0], operands[2]);
 	  DONE;
 	}
-      function_symbol (operands[3], \"__udivsi3_i4i\", SFUNC_GOT);
+      function_symbol (operands[3], \"__udivsi3_i4i\", SFUNC_GOT, NULL);
       last = gen_udivsi3_i4_int (operands[0], operands[3]);
     }
   else if (TARGET_DIVIDE_CALL_FP)
     {
-      function_symbol (operands[3], \"__udivsi3_i4\", SFUNC_STATIC);
+      rtx lab;
+      function_symbol (operands[3], \"__udivsi3_i4\", SFUNC_STATIC, &lab);
       if (TARGET_FPU_SINGLE)
-	last = gen_udivsi3_i4_single (operands[0], operands[3]);
+	last = gen_udivsi3_i4_single (operands[0], operands[3], lab);
       else
-	last = gen_udivsi3_i4 (operands[0], operands[3]);
+	last = gen_udivsi3_i4 (operands[0], operands[3], lab);
     }
   else if (TARGET_SHMEDIA_FPU)
     {
@@ -1924,19 +1937,20 @@
     {
       function_symbol (operands[3],
 		       TARGET_FPU_ANY ? \"__udivsi3_i4\" : \"__udivsi3\",
-		       SFUNC_STATIC);
+		       SFUNC_STATIC, NULL);
 
       if (TARGET_SHMEDIA)
 	last = gen_udivsi3_i1_media (operands[0], operands[3]);
       else if (TARGET_FPU_ANY)
-	last = gen_udivsi3_i4_single (operands[0], operands[3]);
+	last = gen_udivsi3_i4_single (operands[0], operands[3], const0_rtx);
       else
-	last = gen_udivsi3_i1 (operands[0], operands[3]);
+	last = gen_udivsi3_i1 (operands[0], operands[3], const0_rtx);
     }
   else
     {
-      function_symbol (operands[3], \"__udivsi3\", SFUNC_STATIC);
-      last = gen_udivsi3_i1 (operands[0], operands[3]);
+      rtx lab;
+      function_symbol (operands[3], \"__udivsi3\", SFUNC_STATIC, &lab);
+      last = gen_udivsi3_i1 (operands[0], operands[3], lab);
     }
   emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);
   emit_move_insn (gen_rtx_REG (SImode, 5), operands[2]);
@@ -2065,7 +2079,7 @@
       emit_move_insn (gen_rtx_REG (DImode, R20_REG), x);
       break;
     }
-  sym = function_symbol (NULL, name, kind);
+  sym = function_symbol (NULL, name, kind, NULL);
   emit_insn (gen_divsi3_media_2 (operands[0], sym));
   DONE;
 }"
@@ -2086,29 +2100,35 @@
 }")
 
 (define_insn "divsi3_i4"
-  [(set (match_operand:SI 0 "register_operand" "=y")
+  [(set (match_operand:SI 0 "register_operand" "=y,y")
 	(div:SI (reg:SI R4_REG) (reg:SI R5_REG)))
    (clobber (reg:SI PR_REG))
    (clobber (reg:DF DR0_REG))
    (clobber (reg:DF DR2_REG))
    (use (reg:PSI FPSCR_REG))
-   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+   (use (match_operand:SI 1 "arith_reg_operand" "r,r"))
+   (use (match_operand 2 "" "Z,Ccl"))]
   "TARGET_SH4 && ! TARGET_FPU_SINGLE"
-  "jsr	@%1%#"
+  "@
+   jsr	@%1%#
+   bsrf	%1\\n%O2:%#"
   [(set_attr "type" "sfunc")
    (set_attr "fp_mode" "double")
    (set_attr "needs_delay_slot" "yes")])
 
 (define_insn "divsi3_i4_single"
-  [(set (match_operand:SI 0 "register_operand" "=y")
+  [(set (match_operand:SI 0 "register_operand" "=y,y")
 	(div:SI (reg:SI R4_REG) (reg:SI R5_REG)))
    (clobber (reg:SI PR_REG))
    (clobber (reg:DF DR0_REG))
    (clobber (reg:DF DR2_REG))
    (clobber (reg:SI R2_REG))
-   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+   (use (match_operand:SI 1 "arith_reg_operand" "r,r"))
+   (use (match_operand 2 "" "Z,Ccl"))]
   "(TARGET_HARD_SH4 || TARGET_SHCOMPACT) && TARGET_FPU_SINGLE"
-  "jsr	@%1%#"
+  "@
+   jsr	@%1%#
+   bsrf	%1\\n%O2:%#"
   [(set_attr "type" "sfunc")
    (set_attr "needs_delay_slot" "yes")])
 
@@ -2148,16 +2168,17 @@
   /* Emit the move of the address to a pseudo outside of the libcall.  */
   if (TARGET_DIVIDE_CALL_TABLE)
     {
-      function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_GOT);
+      function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_GOT, NULL);
       last = gen_divsi3_i4_int (operands[0], operands[3]);
     }
   else if (TARGET_DIVIDE_CALL_FP)
     {
-      function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_STATIC);
+      rtx lab;
+      function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_STATIC, &lab);
       if (TARGET_FPU_SINGLE)
-	last = gen_divsi3_i4_single (operands[0], operands[3]);
+	last = gen_divsi3_i4_single (operands[0], operands[3], lab);
       else
-	last = gen_divsi3_i4 (operands[0], operands[3]);
+	last = gen_divsi3_i4 (operands[0], operands[3], lab);
     }
   else if (TARGET_SH2A)
     {
@@ -2262,23 +2283,23 @@
 	  emit_move_insn (gen_rtx_REG (Pmode, R20_REG), tab_base);
 	}
       if (TARGET_FPU_ANY && TARGET_SH1)
-	function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_STATIC);
+	function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_STATIC, NULL);
       else if (TARGET_DIVIDE_CALL2)
-	function_symbol (operands[3], \"__sdivsi3_2\", SFUNC_STATIC);
+	function_symbol (operands[3], \"__sdivsi3_2\", SFUNC_STATIC, NULL);
       else
-	function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_GOT);
+	function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_GOT, NULL);
 
       if (TARGET_SHMEDIA)
 	last = ((TARGET_DIVIDE_CALL2 ? gen_divsi3_media_2 : gen_divsi3_i1_media)
 		(operands[0], operands[3]));
       else if (TARGET_FPU_ANY)
-	last = gen_divsi3_i4_single (operands[0], operands[3]);
+	last = gen_divsi3_i4_single (operands[0], operands[3], const0_rtx);
       else
 	last = gen_divsi3_i1 (operands[0], operands[3]);
     }
   else
     {
-      function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_GOT);
+      function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_GOT, NULL);
       last = gen_divsi3_i1 (operands[0], operands[3]);
     }
   emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);
@@ -2870,7 +2891,7 @@ label:
     {
       /* The address must be set outside the libcall,
 	 since it goes into a pseudo.  */
-      rtx sym = function_symbol (NULL, \"__mulsi3\", SFUNC_STATIC);
+      rtx sym = function_symbol (NULL, \"__mulsi3\", SFUNC_STATIC, NULL);
       rtx addr = force_reg (SImode, sym);
       rtx insns = gen_mulsi3_call (operands[0], operands[1],
 				   operands[2], addr);
@@ -3841,12 +3862,15 @@ label:
 (define_insn "ashrsi3_n"
   [(set (reg:SI R4_REG)
 	(ashiftrt:SI (reg:SI R4_REG)
-		     (match_operand:SI 0 "const_int_operand" "i")))
+		     (match_operand:SI 0 "const_int_operand" "i,i")))
    (clobber (reg:SI T_REG))
    (clobber (reg:SI PR_REG))
-   (use (match_operand:SI 1 "arith_reg_operand" "r"))]
+   (use (match_operand:SI 1 "arith_reg_operand" "r,r"))
+   (use (match_operand 2 "" "Z,Ccl"))]
   "TARGET_SH1"
-  "jsr	@%1%#"
+  "@
+   jsr	@%1%#
+   bsrf	%1\\n%O2:%#"
   [(set_attr "type" "sfunc")
    (set_attr "needs_delay_slot" "yes")])
 
@@ -5265,7 +5289,8 @@ label:
     }
   else if (TARGET_SHCOMPACT)
     {
-      operands[1] = function_symbol (NULL, \"__ic_invalidate\", SFUNC_STATIC);
+      operands[1] = function_symbol (NULL, \"__ic_invalidate\", SFUNC_STATIC,
+				     NULL);
       operands[1] = force_reg (Pmode, operands[1]);
       emit_insn (gen_ic_invalidate_line_compact (operands[0], operands[1]));
       DONE;
@@ -5334,7 +5359,7 @@ label:
 
   tramp = force_reg (Pmode, operands[0]);
   sfun = force_reg (Pmode, function_symbol (NULL, \"__init_trampoline\",
-					    SFUNC_STATIC));
+					    SFUNC_STATIC, NULL));
   emit_move_insn (gen_rtx_REG (SImode, R2_REG), operands[1]);
   emit_move_insn (gen_rtx_REG (SImode, R3_REG), operands[2]);
 
@@ -5929,25 +5954,31 @@ label:
 ;; up pcloads, so we need usable length information for that.
 (define_insn "movdf_i4"
   [(set (match_operand:DF 0 "general_movdst_operand" "=d,r,d,d,m,r,r,m,!??r,!???d")
-	(match_operand:DF 1 "general_movsrc_operand" "d,r,F,m,d,FQ,m,r,d,r"))
-   (use (match_operand:PSI 2 "fpscr_operand" "c,c,c,c,c,c,c,c,c,c"))
-   (clobber (match_scratch:SI 3 "=X,X,&z,X,X,X,X,X,X,X"))]
+	(match_operand:DF 1 "general_movsrc_operand"  "d,r,F,m,d,FQ,m,r,d,r"))
+   (use (match_operand:PSI 2 "fpscr_operand"          "c,c,c,c,c,c,c,c,c,c"))
+   (clobber (match_scratch:SI 3                      "=X,X,&z,X,X,X,X,X,X,X"))]
   "(TARGET_SH4 || TARGET_SH2A_DOUBLE)
    && (arith_reg_operand (operands[0], DFmode)
        || arith_reg_operand (operands[1], DFmode))"
-  "@
-	fmov	%1,%0
-	#
-	#
-	fmov.d	%1,%0
-	fmov.d	%1,%0
-	#
-	#
-	#
-	#
-	#"
+  {
+    switch (which_alternative)
+    {
+    case 0:
+      if (TARGET_FMOVD)
+	return "fmov	%1,%0";
+      else if (REGNO (operands[0]) != REGNO (operands[1]) + 1)
+	return "fmov	%R1,%R0\n\tfmov	%S1,%S0";
+      else
+	return "fmov	%S1,%S0\n\tfmov	%R1,%R0";
+    case 3:
+    case 4:
+      return "fmov.d	%1,%0";
+    default:
+      return "#";
+    }
+  }
   [(set_attr_alternative "length"
-     [(if_then_else (eq_attr "fmovd" "yes") (const_int 2) (const_int 4))
+     [(if_then_else (eq_attr "fmovd" "yes") (const_int 4) (const_int 8))
       (const_int 4)
       (if_then_else (eq_attr "fmovd" "yes") (const_int 4) (const_int 6))
       (if_then_else (eq_attr "fmovd" "yes") (const_int 4) (const_int 6))
@@ -6181,37 +6212,63 @@ label:
   "(TARGET_SH4 || TARGET_SH2A_DOUBLE) && ! TARGET_FMOVD && reload_completed
    && FP_OR_XD_REGISTER_P (true_regnum (operands[0]))"
   [(const_int 0)]
-  "
 {
   int regno = true_regnum (operands[0]);
-  rtx addr, insn, adjust = NULL_RTX;
+  rtx addr, insn;
   rtx mem2 = change_address (operands[1], SFmode, NULL_RTX);
-  rtx reg0 = gen_rtx_REG (SFmode, regno + !! TARGET_LITTLE_ENDIAN);
-  rtx reg1 = gen_rtx_REG (SFmode, regno + ! TARGET_LITTLE_ENDIAN);
+  rtx reg0 = gen_rtx_REG (SFmode, regno + (TARGET_LITTLE_ENDIAN ? 1 : 0));
+  rtx reg1 = gen_rtx_REG (SFmode, regno + (TARGET_LITTLE_ENDIAN ? 0 : 1));
 
   operands[1] = copy_rtx (mem2);
   addr = XEXP (mem2, 0);
-  if (GET_CODE (addr) != POST_INC)
+
+  switch (GET_CODE (addr))
     {
-      /* If we have to modify the stack pointer, the value that we have
-	 read with post-increment might be modified by an interrupt,
-	 so write it back.  */
-      if (REGNO (addr) == STACK_POINTER_REGNUM)
-	adjust = gen_push_e (reg0);
-      else
-	adjust = gen_addsi3 (addr, addr, GEN_INT (-4));
-      XEXP (mem2, 0) = addr = gen_rtx_POST_INC (SImode, addr);
-    }
-  addr = XEXP (addr, 0);
-  insn = emit_insn (gen_movsf_ie (reg0, mem2, operands[2]));
-  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC, addr, NULL_RTX);
-  insn = emit_insn (gen_movsf_ie (reg1, operands[1], operands[2]));
-  if (adjust)
-    emit_insn (adjust);
-  else
-    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC, addr, NULL_RTX);
+    case REG:
+      /* This is complicated.  If the register is an arithmetic register
+         we can just fall through to the REG+DISP case below.  Otherwise
+	 we have to use a combination of POST_INC and REG addressing...  */
+      if (! arith_reg_operand (operands[1], SFmode))
+        {
+          XEXP (mem2, 0) = addr = gen_rtx_POST_INC (SImode, addr);
+          insn = emit_insn (gen_movsf_ie (reg0, mem2, operands[2]));
+          add_reg_note (insn, REG_INC, XEXP (addr, 0));
+	  
+	  emit_insn (gen_movsf_ie (reg1, operands[1], operands[2]));
+
+          /* If we have modified the stack pointer, the value that we have
+  	     read with post-increment might be modified by an interrupt,
+	     so write it back.  */
+          if (REGNO (addr) == STACK_POINTER_REGNUM)
+	    emit_insn (gen_push_e (reg0));
+          else
+	    emit_insn (gen_addsi3 (XEXP (operands[1], 0), XEXP (operands[1], 0), GEN_INT (-4)));
+	  break;
+        }
+      /* Fall through.  */
+	 
+    case PLUS:
+      emit_insn (gen_movsf_ie (reg0, operands[1], operands[2]));
+      operands[1] = copy_rtx (operands[1]);
+      XEXP (operands[1], 0) = plus_constant (addr, 4);
+      emit_insn (gen_movsf_ie (reg1, operands[1], operands[2]));
+      break;
+      
+    case POST_INC:
+      insn = emit_insn (gen_movsf_ie (reg0, operands[1], operands[2]));
+      add_reg_note (insn, REG_INC, XEXP (addr, 0));
+    
+      insn = emit_insn (gen_movsf_ie (reg1, operands[1], operands[2]));
+      add_reg_note (insn, REG_INC, XEXP (addr, 0));
+      break;
+
+    default:
+      debug_rtx (addr);
+      gcc_unreachable ();
+    }
+
   DONE;
-}")
+})
 
 (define_split
   [(set (match_operand:DF 0 "memory_operand" "")
@@ -6221,35 +6278,70 @@ label:
   "(TARGET_SH4 || TARGET_SH2A_DOUBLE) && ! TARGET_FMOVD && reload_completed
    && FP_OR_XD_REGISTER_P (true_regnum (operands[1]))"
   [(const_int 0)]
-  "
 {
   int regno = true_regnum (operands[1]);
-  rtx insn, addr, adjust = NULL_RTX;
+  rtx insn, addr;
+  rtx reg0 = gen_rtx_REG (SFmode, regno + (TARGET_LITTLE_ENDIAN ? 1 : 0));
+  rtx reg1 = gen_rtx_REG (SFmode, regno + (TARGET_LITTLE_ENDIAN ? 0 : 1));
 
   operands[0] = copy_rtx (operands[0]);
   PUT_MODE (operands[0], SFmode);
-  insn = emit_insn (gen_movsf_ie (operands[0],
-				  gen_rtx_REG (SFmode,
-					   regno + ! TARGET_LITTLE_ENDIAN),
-				  operands[2]));
-  operands[0] = copy_rtx (operands[0]);
   addr = XEXP (operands[0], 0);
-  if (GET_CODE (addr) != PRE_DEC)
+
+  switch (GET_CODE (addr))
     {
-      adjust = gen_addsi3 (addr, addr, GEN_INT (4));
-      emit_insn_before (adjust, insn);
-      XEXP (operands[0], 0) = addr = gen_rtx_PRE_DEC (SImode, addr);
+    case REG:
+      /* This is complicated.  If the register is an arithmetic register
+         we can just fall through to the REG+DISP case below.  Otherwise
+	 we have to use a combination of REG and PRE_DEC addressing...  */
+      if (! arith_reg_operand (operands[0], SFmode))
+        {
+	  emit_insn (gen_addsi3 (addr, addr, GEN_INT (4)));
+          emit_insn (gen_movsf_ie (operands[0], reg1, operands[2]));
+
+	  operands[0] = copy_rtx (operands[0]);
+          XEXP (operands[0], 0) = addr = gen_rtx_PRE_DEC (SImode, addr);
+	  
+          insn = emit_insn (gen_movsf_ie (operands[0], reg0, operands[2]));
+          add_reg_note (insn, REG_INC, XEXP (addr, 0));
+	  break;
+        }
+      /* Fall through.  */
+      
+    case PLUS:
+      /* Since REG+DISP addressing has already been decided upon by gcc
+         we can rely upon it having chosen an arithmetic register as the
+	 register component of the address.  Just emit the lower numbered
+	 register first, to the lower address, then the higher numbered
+	 register to the higher address.  */
+      emit_insn (gen_movsf_ie (operands[0], reg0, operands[2]));
+
+      operands[0] = copy_rtx (operands[0]);
+      XEXP (operands[0], 0) = plus_constant (addr, 4);
+
+      emit_insn (gen_movsf_ie (operands[0], reg1, operands[2]));	 
+      break;
+      
+    case PRE_DEC:
+      /* This is easy.  Output the word to go to the higher address
+         first (ie the word in the higher numbered register) then the
+	 word to go to the lower address.  */
+
+      insn = emit_insn (gen_movsf_ie (operands[0], reg1, operands[2]));
+      add_reg_note (insn, REG_INC, XEXP (addr, 0));
+
+      insn = emit_insn (gen_movsf_ie (operands[0], reg0, operands[2]));
+      add_reg_note (insn, REG_INC, XEXP (addr, 0));
+      break;
+      
+    default:
+      /* FAIL; */
+      debug_rtx (addr);
+      gcc_unreachable ();
     }
-  addr = XEXP (addr, 0);
-  if (! adjust)
-    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC, addr, NULL_RTX);
-  insn = emit_insn (gen_movsf_ie (operands[0],
-				  gen_rtx_REG (SFmode,
-					   regno + !! TARGET_LITTLE_ENDIAN),
-				  operands[2]));
-  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC, addr, NULL_RTX);
+
   DONE;
-}")
+})
 
 ;; If the output is a register and the input is memory or a register, we have
 ;; to be careful and see which word needs to be loaded first.
@@ -6711,7 +6803,7 @@ label:
       (const_int 0)])
    (set (attr "fp_mode") (if_then_else (eq_attr "fmovd" "yes")
 					   (const_string "single")
-					   (const_string "none")))])
+					   (const_string "single")))])
 
 (define_split
   [(set (match_operand:SF 0 "register_operand" "")
@@ -7524,7 +7616,29 @@ label:
 	 (match_operand 1 "" ""))
    (use (reg:PSI FPSCR_REG))
    (clobber (reg:SI PR_REG))]
-  "TARGET_SH1"
+  "TARGET_SH1 && !TARGET_FDPIC"
+  "*
+   {
+     if (TARGET_SH2A && (dbr_sequence_length () == 0))
+	return \"jsr/n\\t@%0\";
+     else
+	return \"jsr\\t@%0%#\";
+   }"
+
+  [(set_attr "type" "call")
+   (set (attr "fp_mode")
+	(if_then_else (eq_attr "fpu_single" "yes")
+		      (const_string "single") (const_string "double")))
+   (set_attr "needs_delay_slot" "yes")
+   (set_attr "fp_set" "unknown")])
+
+(define_insn "calli_fdpic"
+  [(call (mem:SI (match_operand:SI 0 "arith_reg_operand" "r"))
+	 (match_operand 1 "" ""))
+   (use (reg:PSI FPSCR_REG))
+   (use (reg:SI PIC_REG))
+   (clobber (reg:SI PR_REG))]
+  "TARGET_SH1 && TARGET_FDPIC"
   "*
    {
      if (TARGET_SH2A && (dbr_sequence_length () == 0))
@@ -7659,7 +7773,29 @@ label:
 	      (match_operand 2 "" "")))
    (use (reg:PSI FPSCR_REG))
    (clobber (reg:SI PR_REG))]
-  "TARGET_SH1"
+  "TARGET_SH1 && !TARGET_FDPIC"
+  "*
+   {
+     if (TARGET_SH2A && (dbr_sequence_length () == 0))
+	return \"jsr/n\\t@%1\";
+     else
+	return \"jsr\\t@%1%#\";
+   }"
+  [(set_attr "type" "call")
+   (set (attr "fp_mode")
+	(if_then_else (eq_attr "fpu_single" "yes")
+		      (const_string "single") (const_string "double")))
+   (set_attr "needs_delay_slot" "yes")
+   (set_attr "fp_set" "unknown")])
+
+(define_insn "call_valuei_fdpic"
+  [(set (match_operand 0 "" "=rf")
+	(call (mem:SI (match_operand:SI 1 "arith_reg_operand" "r"))
+	      (match_operand 2 "" "")))
+   (use (reg:PSI FPSCR_REG))
+   (use (reg:SI PIC_REG))
+   (clobber (reg:SI PR_REG))]
+  "TARGET_SH1 && TARGET_FDPIC"
   "*
    {
      if (TARGET_SH2A && (dbr_sequence_length () == 0))
@@ -7801,6 +7937,12 @@ label:
   ""
   "
 {
+  if (TARGET_FDPIC)
+    {
+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+      emit_move_insn (pic_reg, OUR_FDPIC_REG);
+    }
+
   if (TARGET_SHMEDIA)
     {
       operands[0] = shmedia_prepare_call_address (operands[0], 0);
@@ -7837,7 +7979,7 @@ label:
 
       operands[0]
 	= function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",
-			   SFUNC_GOT);
+			   SFUNC_GOT, NULL);
       operands[0] = force_reg (SImode, operands[0]);
 
       emit_move_insn (r0, func);
@@ -7861,7 +8003,7 @@ label:
       emit_insn (gen_symGOTPLT2reg (reg, XEXP (operands[0], 0)));
       XEXP (operands[0], 0) = reg;
     }
-  if (!flag_pic && TARGET_SH2A
+  if (!flag_pic && !TARGET_FDPIC && TARGET_SH2A
       && GET_CODE (operands[0]) == MEM
       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)
     {
@@ -7872,7 +8014,7 @@ label:
 	  DONE;
 	}
     }
-  if (flag_pic && TARGET_SH2
+  if ((flag_pic || TARGET_FDPIC) && TARGET_SH2
       && GET_CODE (operands[0]) == MEM
       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)
     {
@@ -7885,7 +8027,13 @@ label:
     operands[1] = operands[2];
   }
 
-  emit_call_insn (gen_calli (operands[0], operands[1]));
+  if (TARGET_FDPIC)
+    {
+      operands[0] = sh_load_function_descriptor (operands[0]);
+      emit_call_insn (gen_calli_fdpic (operands[0], operands[1]));
+    }
+  else
+    emit_call_insn (gen_calli (operands[0], operands[1]));
   DONE;
 }")
 
@@ -7966,7 +8114,7 @@ label:
   emit_insn (gen_force_mode_for_call ());
 
   operands[0] = function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",
-				 SFUNC_GOT);
+				 SFUNC_GOT, NULL);
   operands[0] = force_reg (SImode, operands[0]);
 
   emit_move_insn (r0, func);
@@ -7992,6 +8140,12 @@ label:
   ""
   "
 {
+  if (TARGET_FDPIC)
+    {
+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+      emit_move_insn (pic_reg, OUR_FDPIC_REG);
+    }
+
   if (TARGET_SHMEDIA)
     {
       operands[1] = shmedia_prepare_call_address (operands[1], 0);
@@ -8029,7 +8183,7 @@ label:
 
       operands[1]
 	= function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",
-			   SFUNC_GOT);
+			   SFUNC_GOT, NULL);
       operands[1] = force_reg (SImode, operands[1]);
 
       emit_move_insn (r0, func);
@@ -8055,7 +8209,7 @@ label:
       emit_insn (gen_symGOTPLT2reg (reg, XEXP (operands[1], 0)));
       XEXP (operands[1], 0) = reg;
     }
-  if (!flag_pic && TARGET_SH2A
+  if (!flag_pic && !TARGET_FDPIC && TARGET_SH2A
       && GET_CODE (operands[1]) == MEM
       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)
     {
@@ -8066,7 +8220,7 @@ label:
 	  DONE;
 	}
     }
-  if (flag_pic && TARGET_SH2
+  if ((flag_pic || TARGET_FDPIC) && TARGET_SH2
       && GET_CODE (operands[1]) == MEM
       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)
     {
@@ -8077,7 +8231,14 @@ label:
   else
     operands[1] = force_reg (SImode, XEXP (operands[1], 0));
 
-  emit_call_insn (gen_call_valuei (operands[0], operands[1], operands[2]));
+  if (TARGET_FDPIC)
+    {
+      operands[1] = sh_load_function_descriptor (operands[1]);
+      emit_call_insn (gen_call_valuei_fdpic (operands[0], operands[1],
+					     operands[2]));
+    }
+  else
+    emit_call_insn (gen_call_valuei (operands[0], operands[1], operands[2]));
   DONE;
 }")
 
@@ -8086,7 +8247,21 @@ label:
 	 (match_operand 1 "" ""))
    (use (reg:PSI FPSCR_REG))
    (return)]
-  "TARGET_SH1"
+  "TARGET_SH1 && !TARGET_FDPIC"
+  "jmp	@%0%#"
+  [(set_attr "needs_delay_slot" "yes")
+   (set (attr "fp_mode")
+	(if_then_else (eq_attr "fpu_single" "yes")
+		      (const_string "single") (const_string "double")))
+   (set_attr "type" "jump_ind")])
+
+(define_insn "sibcalli_fdpic"
+  [(call (mem:SI (match_operand:SI 0 "register_operand" "k"))
+	 (match_operand 1 "" ""))
+   (use (reg:PSI FPSCR_REG))
+   (use (reg:SI PIC_REG))
+   (return)]
+  "TARGET_SH1 && TARGET_FDPIC"
   "jmp	@%0%#"
   [(set_attr "needs_delay_slot" "yes")
    (set (attr "fp_mode")
@@ -8100,7 +8275,22 @@ label:
    (use (match_operand 2 "" ""))
    (use (reg:PSI FPSCR_REG))
    (return)]
-  "TARGET_SH2"
+  "TARGET_SH2 && !TARGET_FDPIC"
+  "braf	%0\\n%O2:%#"
+  [(set_attr "needs_delay_slot" "yes")
+   (set (attr "fp_mode")
+	(if_then_else (eq_attr "fpu_single" "yes")
+		      (const_string "single") (const_string "double")))
+   (set_attr "type" "jump_ind")])
+
+(define_insn "sibcalli_pcrel_fdpic"
+  [(call (mem:SI (match_operand:SI 0 "arith_reg_operand" "k"))
+	 (match_operand 1 "" ""))
+   (use (match_operand 2 "" ""))
+   (use (reg:PSI FPSCR_REG))
+   (use (reg:SI PIC_REG))
+   (return)]
+  "TARGET_SH2 && TARGET_FDPIC"
   "braf	%0\\n%O2:%#"
   [(set_attr "needs_delay_slot" "yes")
    (set (attr "fp_mode")
@@ -8130,7 +8320,7 @@ label:
    (use (reg:PSI FPSCR_REG))
    (clobber (match_scratch:SI 2 "=k"))
    (return)]
-  "TARGET_SH2"
+  "TARGET_SH2 && !TARGET_FDPIC"
   "#"
   "reload_completed"
   [(const_int 0)]
@@ -8151,6 +8341,34 @@ label:
 		      (const_string "single") (const_string "double")))
    (set_attr "type" "jump_ind")])
 
+(define_insn_and_split "sibcall_pcrel_fdpic"
+  [(call (mem:SI (match_operand:SI 0 "symbol_ref_operand" ""))
+	 (match_operand 1 "" ""))
+   (use (reg:PSI FPSCR_REG))
+   (use (reg:SI PIC_REG))
+   (clobber (match_scratch:SI 2 "=k"))
+   (return)]
+  "TARGET_SH2 && TARGET_FDPIC"
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "
+{
+  rtx lab = PATTERN (gen_call_site ());
+  rtx call_insn;
+
+  emit_insn (gen_sym_label2reg (operands[2], operands[0], lab));
+  call_insn = emit_call_insn (gen_sibcalli_pcrel_fdpic (operands[2], operands[1],
+						  copy_rtx (lab)));
+  SIBLING_CALL_P (call_insn) = 1;
+  DONE;
+}"
+  [(set_attr "needs_delay_slot" "yes")
+   (set (attr "fp_mode")
+	(if_then_else (eq_attr "fpu_single" "yes")
+		      (const_string "single") (const_string "double")))
+   (set_attr "type" "jump_ind")])
+
 (define_insn "sibcall_compact"
   [(call (mem:SI (match_operand:SI 0 "register_operand" "k,k"))
 	 (match_operand 1 "" ""))
@@ -8189,6 +8407,12 @@ label:
   ""
   "
 {
+  if (TARGET_FDPIC)
+    {
+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+      emit_move_insn (pic_reg, OUR_FDPIC_REG);
+    }
+
   if (TARGET_SHMEDIA)
     {
       operands[0] = shmedia_prepare_call_address (operands[0], 1);
@@ -8235,7 +8459,7 @@ label:
 
       operands[0]
 	= function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",
-			   SFUNC_GOT);
+			   SFUNC_GOT, NULL);
       operands[0] = force_reg (SImode, operands[0]);
 
       /* We don't need a return trampoline, since the callee will
@@ -8261,7 +8485,7 @@ label:
       emit_insn (gen_symGOT2reg (reg, XEXP (operands[0], 0)));
       XEXP (operands[0], 0) = reg;
     }
-  if (flag_pic && TARGET_SH2
+  if ((flag_pic || TARGET_FDPIC) && TARGET_SH2
       && GET_CODE (operands[0]) == MEM
       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF
       /* The PLT needs the PIC register, but the epilogue would have
@@ -8269,13 +8493,24 @@ label:
 	 static functions.  */
       && SYMBOL_REF_LOCAL_P (XEXP (operands[0], 0)))
     {
-      emit_call_insn (gen_sibcall_pcrel (XEXP (operands[0], 0), operands[1]));
+      if (TARGET_FDPIC)
+        emit_call_insn (gen_sibcall_pcrel_fdpic (XEXP (operands[0], 0),
+       	                                         operands[1]));
+      else
+        emit_call_insn (gen_sibcall_pcrel (XEXP (operands[0], 0),
+                                           operands[1]));
       DONE;
     }
   else
     operands[0] = force_reg (SImode, XEXP (operands[0], 0));
 
-  emit_call_insn (gen_sibcalli (operands[0], operands[1]));
+  if (TARGET_FDPIC)
+    {
+      operands[0] = sh_load_function_descriptor (operands[0]);
+      emit_call_insn (gen_sibcalli_fdpic (operands[0], operands[1]));
+    }
+  else
+    emit_call_insn (gen_sibcalli (operands[0], operands[1]));
   DONE;
 }")
 
@@ -8285,7 +8520,22 @@ label:
 	      (match_operand 2 "" "")))
    (use (reg:PSI FPSCR_REG))
    (return)]
-  "TARGET_SH1"
+  "TARGET_SH1 && !TARGET_FDPIC"
+  "jmp	@%1%#"
+  [(set_attr "needs_delay_slot" "yes")
+   (set (attr "fp_mode")
+	(if_then_else (eq_attr "fpu_single" "yes")
+		      (const_string "single") (const_string "double")))
+   (set_attr "type" "jump_ind")])
+
+(define_insn "sibcall_valuei_fdpic"
+  [(set (match_operand 0 "" "=rf")
+	(call (mem:SI (match_operand:SI 1 "register_operand" "k"))
+	      (match_operand 2 "" "")))
+   (use (reg:PSI FPSCR_REG))
+   (use (reg:SI PIC_REG))
+   (return)]
+  "TARGET_SH1 && TARGET_FDPIC"
   "jmp	@%1%#"
   [(set_attr "needs_delay_slot" "yes")
    (set (attr "fp_mode")
@@ -8300,7 +8550,23 @@ label:
    (use (match_operand 3 "" ""))
    (use (reg:PSI FPSCR_REG))
    (return)]
-  "TARGET_SH2"
+  "TARGET_SH2 && !TARGET_FDPIC"
+  "braf	%1\\n%O3:%#"
+  [(set_attr "needs_delay_slot" "yes")
+   (set (attr "fp_mode")
+	(if_then_else (eq_attr "fpu_single" "yes")
+		      (const_string "single") (const_string "double")))
+   (set_attr "type" "jump_ind")])
+
+(define_insn "sibcall_valuei_pcrel_fdpic"
+  [(set (match_operand 0 "" "=rf")
+	(call (mem:SI (match_operand:SI 1 "arith_reg_operand" "k"))
+	      (match_operand 2 "" "")))
+   (use (match_operand 3 "" ""))
+   (use (reg:PSI FPSCR_REG))
+   (use (reg:PSI PIC_REG))
+   (return)]
+  "TARGET_SH2 && TARGET_FDPIC"
   "braf	%1\\n%O3:%#"
   [(set_attr "needs_delay_slot" "yes")
    (set (attr "fp_mode")
@@ -8315,7 +8581,7 @@ label:
    (use (reg:PSI FPSCR_REG))
    (clobber (match_scratch:SI 3 "=k"))
    (return)]
-  "TARGET_SH2"
+  "TARGET_SH2 && !TARGET_FDPIC"
   "#"
   "reload_completed"
   [(const_int 0)]
@@ -8329,6 +8595,39 @@ label:
 							operands[3],
 							operands[2],
 							copy_rtx (lab)));
+							  
+  SIBLING_CALL_P (call_insn) = 1;
+  DONE;
+}"
+  [(set_attr "needs_delay_slot" "yes")
+   (set (attr "fp_mode")
+	(if_then_else (eq_attr "fpu_single" "yes")
+		      (const_string "single") (const_string "double")))
+   (set_attr "type" "jump_ind")])
+
+(define_insn_and_split "sibcall_value_pcrel_fdpic"
+  [(set (match_operand 0 "" "=rf")
+	(call (mem:SI (match_operand:SI 1 "symbol_ref_operand" ""))
+	      (match_operand 2 "" "")))
+   (use (reg:PSI FPSCR_REG))
+   (use (reg:PSI PIC_REG))
+   (clobber (match_scratch:SI 3 "=k"))
+   (return)]
+  "TARGET_SH2 && TARGET_FDPIC"
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "
+{
+  rtx lab = PATTERN (gen_call_site ());
+  rtx call_insn;
+
+  emit_insn (gen_sym_label2reg (operands[3], operands[1], lab));
+  call_insn = emit_call_insn (gen_sibcall_valuei_pcrel_fdpic (operands[0],
+							      operands[3],
+							      operands[2],
+							      copy_rtx (lab)));
+							  
   SIBLING_CALL_P (call_insn) = 1;
   DONE;
 }"
@@ -8379,6 +8678,12 @@ label:
   ""
   "
 {
+  if (TARGET_FDPIC)
+    {
+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+      emit_move_insn (pic_reg, OUR_FDPIC_REG);
+    }
+
   if (TARGET_SHMEDIA)
     {
       operands[1] = shmedia_prepare_call_address (operands[1], 1);
@@ -8426,7 +8731,7 @@ label:
 
       operands[1]
 	= function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",
-			   SFUNC_GOT);
+			   SFUNC_GOT, NULL);
       operands[1] = force_reg (SImode, operands[1]);
 
       /* We don't need a return trampoline, since the callee will
@@ -8453,7 +8758,7 @@ label:
       emit_insn (gen_symGOT2reg (reg, XEXP (operands[1], 0)));
       XEXP (operands[1], 0) = reg;
     }
-  if (flag_pic && TARGET_SH2
+  if ((flag_pic || TARGET_FDPIC) && TARGET_SH2
       && GET_CODE (operands[1]) == MEM
       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF
       /* The PLT needs the PIC register, but the epilogue would have
@@ -8461,15 +8766,28 @@ label:
 	 static functions.  */
       && SYMBOL_REF_LOCAL_P (XEXP (operands[1], 0)))
     {
-      emit_call_insn (gen_sibcall_value_pcrel (operands[0],
-					       XEXP (operands[1], 0),
-					       operands[2]));
+      if (TARGET_FDPIC)
+	emit_call_insn (gen_sibcall_value_pcrel_fdpic (operands[0],
+						       XEXP (operands[1], 0),
+						       operands[2]));
+      else
+	emit_call_insn (gen_sibcall_value_pcrel (operands[0],
+						 XEXP (operands[1], 0),
+						 operands[2]));
       DONE;
     }
   else
     operands[1] = force_reg (SImode, XEXP (operands[1], 0));
 
-  emit_call_insn (gen_sibcall_valuei (operands[0], operands[1], operands[2]));
+  if (TARGET_FDPIC)
+    {
+      operands[1] = sh_load_function_descriptor (operands[1]);
+      emit_call_insn (gen_sibcall_valuei_fdpic (operands[0], operands[1],
+						operands[2]));
+    }
+  else
+    emit_call_insn (gen_sibcall_valuei (operands[0], operands[1],
+					operands[2]));
   DONE;
 }")
 
@@ -8554,7 +8872,7 @@ label:
   emit_insn (gen_force_mode_for_call ());
 
   operands[1] = function_symbol (NULL, \"__GCC_shcompact_call_trampoline\",
-				 SFUNC_GOT);
+				 SFUNC_GOT, NULL);
   operands[1] = force_reg (SImode, operands[1]);
 
   emit_move_insn (r0, func);
@@ -8739,6 +9057,13 @@ label:
       DONE;
     }
 
+  if (TARGET_FDPIC)
+    {
+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+      emit_move_insn (pic_reg, OUR_FDPIC_REG);
+      DONE;
+    }
+
   operands[0] = gen_rtx_REG (Pmode, PIC_REG);
   operands[1] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);
 
@@ -8853,6 +9178,12 @@ label:
 {
   rtx insn, mem;
 
+  if (TARGET_FDPIC)
+    {
+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+      emit_move_insn (pic_reg, OUR_FDPIC_REG);
+    }
+
   operands[2] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);
   operands[3] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);
 
@@ -8926,6 +9257,27 @@ label:
   DONE;
 }")
 
+(define_expand "sym2GOTFUNCDESC"
+  [(const (unspec [(match_operand 0 "" "")] UNSPEC_GOTFUNCDESC))]
+  "TARGET_FDPIC"
+  "")
+
+(define_expand "symGOTFUNCDESC2reg"
+  [(match_operand 0 "" "") (match_operand 1 "" "")]
+  "TARGET_FDPIC"
+  "
+{
+  rtx gotsym, insn;
+
+  gotsym = gen_sym2GOTFUNCDESC (operands[1]);
+  PUT_MODE (gotsym, Pmode);
+  insn = emit_insn (gen_symGOT_load (operands[0], gotsym));
+
+  MEM_READONLY_P (SET_SRC (PATTERN (insn))) = 1;
+
+  DONE;
+}")
+
 (define_expand "symGOTPLT2reg"
   [(match_operand 0 "" "") (match_operand 1 "" "")]
   ""
@@ -8954,6 +9306,12 @@ label:
 	   ? operands[0]
 	   : gen_reg_rtx (GET_MODE (operands[0])));
 
+  if (TARGET_FDPIC)
+    {
+      rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+      emit_move_insn (pic_reg, OUR_FDPIC_REG);
+    }
+
   gotoffsym = gen_sym2GOTOFF (operands[1]);
   PUT_MODE (gotoffsym, Pmode);
   emit_move_insn (t, gotoffsym);
@@ -8966,6 +9324,33 @@ label:
   DONE;
 }")
 
+(define_expand "sym2GOTOFFFUNCDESC"
+  [(const (unspec [(match_operand 0 "" "")] UNSPEC_GOTOFFFUNCDESC))]
+  "TARGET_FDPIC"
+  "")
+
+(define_expand "symGOTOFFFUNCDESC2reg"
+  [(match_operand 0 "" "") (match_operand 1 "" "")]
+  "TARGET_FDPIC"
+  "
+{
+  rtx gotoffsym;
+  rtx t = (!can_create_pseudo_p ()
+	   ? operands[0]
+	   : gen_reg_rtx (GET_MODE (operands[0])));
+
+  rtx pic_reg = gen_rtx_REG (Pmode, PIC_REG);
+  emit_move_insn (pic_reg, OUR_FDPIC_REG);
+
+  gotoffsym = gen_sym2GOTOFFFUNCDESC (operands[1]);
+  PUT_MODE (gotoffsym, Pmode);
+  emit_move_insn (t, gotoffsym);
+  emit_move_insn (operands[0],
+		  gen_rtx_PLUS (Pmode, t,
+				gen_rtx_REG (Pmode, PIC_REG)));
+  DONE;
+}")
+
 (define_expand "symPLT_label2reg"
   [(set (match_operand:SI 0 "" "")
 	(const:SI
@@ -9440,7 +9825,8 @@ mov.l\\t1f,r0\\n\\
 {
   rtx reg = gen_rtx_REG (Pmode, R0_REG);
 
-  function_symbol (reg, \"__GCC_shcompact_return_trampoline\", SFUNC_STATIC);
+  function_symbol (reg, \"__GCC_shcompact_return_trampoline\", SFUNC_STATIC,
+		   NULL);
   emit_jump_insn (gen_shcompact_return_tramp_i ());
   DONE;
 }")
@@ -9611,7 +9997,7 @@ mov.l\\t1f,r0\\n\\
 ;; complements the T bit and stores the result in a register
 (define_insn "movrt"
   [(set (match_operand:SI 0 "arith_reg_dest" "=r")
-        (if_then_else (eq:SI (reg:SI T_REG) (const_int 0))
+        (if_then_else:SI (eq:SI (reg:SI T_REG) (const_int 0))
         (const_int 1)
         (const_int 0)))]
   "TARGET_SH2A"
@@ -10416,18 +10802,22 @@ mov.l\\t1f,r0\\n\\
 (define_insn "block_move_real"
   [(parallel [(set (mem:BLK (reg:SI R4_REG))
 		   (mem:BLK (reg:SI R5_REG)))
-	      (use (match_operand:SI 0 "arith_reg_operand" "r"))
+	      (use (match_operand:SI 0 "arith_reg_operand" "r,r"))
+	      (use (match_operand 1 "" "Z,Ccl"))
 	      (clobber (reg:SI PR_REG))
 	      (clobber (reg:SI R0_REG))])]
   "TARGET_SH1 && ! TARGET_HARD_SH4"
-  "jsr	@%0%#"
+  "@
+   jsr	@%0%#
+   bsrf	%0\\n%O1:%#"
   [(set_attr "type" "sfunc")
    (set_attr "needs_delay_slot" "yes")])
 
 (define_insn "block_lump_real"
   [(parallel [(set (mem:BLK (reg:SI R4_REG))
 		   (mem:BLK (reg:SI R5_REG)))
-	      (use (match_operand:SI 0 "arith_reg_operand" "r"))
+	      (use (match_operand:SI 0 "arith_reg_operand" "r,r"))
+	      (use (match_operand 1 "" "Z,Ccl"))
 	      (use (reg:SI R6_REG))
 	      (clobber (reg:SI PR_REG))
 	      (clobber (reg:SI T_REG))
@@ -10436,27 +10826,33 @@ mov.l\\t1f,r0\\n\\
 	      (clobber (reg:SI R6_REG))
 	      (clobber (reg:SI R0_REG))])]
   "TARGET_SH1 && ! TARGET_HARD_SH4"
-  "jsr	@%0%#"
+  "@
+   jsr	@%0%#
+   bsrf	%0\\n%O1:%#"
   [(set_attr "type" "sfunc")
    (set_attr "needs_delay_slot" "yes")])
 
 (define_insn "block_move_real_i4"
   [(parallel [(set (mem:BLK (reg:SI R4_REG))
 		   (mem:BLK (reg:SI R5_REG)))
-	      (use (match_operand:SI 0 "arith_reg_operand" "r"))
+	      (use (match_operand:SI 0 "arith_reg_operand" "r,r"))
+	      (use (match_operand 1 "" "Z,Ccl"))
 	      (clobber (reg:SI PR_REG))
 	      (clobber (reg:SI R0_REG))
 	      (clobber (reg:SI R1_REG))
 	      (clobber (reg:SI R2_REG))])]
   "TARGET_HARD_SH4"
-  "jsr	@%0%#"
+  "@
+   jsr	@%0%#
+   bsrf	%0\\n%O1:%#"
   [(set_attr "type" "sfunc")
    (set_attr "needs_delay_slot" "yes")])
 
 (define_insn "block_lump_real_i4"
   [(parallel [(set (mem:BLK (reg:SI R4_REG))
 		   (mem:BLK (reg:SI R5_REG)))
-	      (use (match_operand:SI 0 "arith_reg_operand" "r"))
+	      (use (match_operand:SI 0 "arith_reg_operand" "r,r"))
+	      (use (match_operand 1 "" "Z,Ccl"))
 	      (use (reg:SI R6_REG))
 	      (clobber (reg:SI PR_REG))
 	      (clobber (reg:SI T_REG))
@@ -10468,7 +10864,9 @@ mov.l\\t1f,r0\\n\\
 	      (clobber (reg:SI R2_REG))
 	      (clobber (reg:SI R3_REG))])]
   "TARGET_HARD_SH4"
-  "jsr	@%0%#"
+  "@
+   jsr	@%0%#
+   bsrf	%0\\n%O1:%#"
   [(set_attr "type" "sfunc")
    (set_attr "needs_delay_slot" "yes")])
 
diff --git a/gcc/config/sh/sh.opt b/gcc/config/sh/sh.opt
index 9aaba6c15..983cff39e 100644
--- a/gcc/config/sh/sh.opt
+++ b/gcc/config/sh/sh.opt
@@ -248,12 +248,17 @@ mdivsi3_libfunc=
 Target RejectNegative Joined Var(sh_divsi3_libfunc) Init("")
 Specify name for 32 bit signed division function
 
+mfmovd
+Target RejectNegative Mask(FMOVD)
+Enable the use of 64-bit floating point registers in fmov instructions.  See -mdalign if 64-bit alignment is required.
+
 mfixed-range=
 Target RejectNegative Joined Var(sh_fixed_range_str)
 Specify range of registers to make fixed
 
-mfmovd
-Target RejectNegative Mask(FMOVD) Undocumented
+mfdpic
+Target Report Mask(FDPIC)
+Generate ELF FDPIC code
 
 mfused-madd
 Target Var(TARGET_FMAC)
@@ -319,7 +324,7 @@ Follow Renesas (formerly Hitachi) / SuperH calling conventions
 
 mspace
 Target Report RejectNegative Mask(SMALLCODE)
-Deprecated. Use -Os instead
+Deprecated.  Use -Os instead
 
 multcost=
 Target RejectNegative Joined UInteger Var(sh_multcost) Init(-1)
diff --git a/gcc/config/sh/t-1e b/gcc/config/sh/t-1e
index 74b0f9a60..e69de29bb 100644
--- a/gcc/config/sh/t-1e
+++ b/gcc/config/sh/t-1e
@@ -1 +0,0 @@
-MULTILIB_ENDIAN =
diff --git a/gcc/config/sh/t-linux b/gcc/config/sh/t-linux
index b7a3d7c97..13ff848dd 100644
--- a/gcc/config/sh/t-linux
+++ b/gcc/config/sh/t-linux
@@ -4,6 +4,5 @@ LIB2FUNCS_EXTRA= $(srcdir)/config/sh/linux-atomic.asm
 
 MULTILIB_DIRNAMES= 
 MULTILIB_MATCHES = 
-MULTILIB_EXCEPTIONS=
 
 EXTRA_MULTILIB_PARTS= crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
diff --git a/gcc/config/sh/t-mlib-sh1 b/gcc/config/sh/t-mlib-sh1
index 9ba70541c..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh1
+++ b/gcc/config/sh/t-mlib-sh1
@@ -1 +0,0 @@
-ML_sh1=m1/
diff --git a/gcc/config/sh/t-mlib-sh2 b/gcc/config/sh/t-mlib-sh2
index d8857bab6..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh2
+++ b/gcc/config/sh/t-mlib-sh2
@@ -1 +0,0 @@
-ML_sh2=m2/
diff --git a/gcc/config/sh/t-mlib-sh2a b/gcc/config/sh/t-mlib-sh2a
index e276ac995..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh2a
+++ b/gcc/config/sh/t-mlib-sh2a
@@ -1 +0,0 @@
-ML_sh2a=m2a/
diff --git a/gcc/config/sh/t-mlib-sh2a-nofpu b/gcc/config/sh/t-mlib-sh2a-nofpu
index a84874efc..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh2a-nofpu
+++ b/gcc/config/sh/t-mlib-sh2a-nofpu
@@ -1 +0,0 @@
-ML_sh2a_nofpu=m2a-nofpu/
diff --git a/gcc/config/sh/t-mlib-sh2a-single b/gcc/config/sh/t-mlib-sh2a-single
index b3432fa83..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh2a-single
+++ b/gcc/config/sh/t-mlib-sh2a-single
@@ -1 +0,0 @@
-ML_sh2a_single=m2a-single/
diff --git a/gcc/config/sh/t-mlib-sh2a-single-only b/gcc/config/sh/t-mlib-sh2a-single-only
index e34afe2f2..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh2a-single-only
+++ b/gcc/config/sh/t-mlib-sh2a-single-only
@@ -1 +0,0 @@
-ML_sh2a_single_only=m2a-single-only/
diff --git a/gcc/config/sh/t-mlib-sh2e b/gcc/config/sh/t-mlib-sh2e
index 58841327c..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh2e
+++ b/gcc/config/sh/t-mlib-sh2e
@@ -1 +0,0 @@
-ML_sh2e=m2e/
diff --git a/gcc/config/sh/t-mlib-sh3 b/gcc/config/sh/t-mlib-sh3
index 2c89d749a..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh3
+++ b/gcc/config/sh/t-mlib-sh3
@@ -1 +0,0 @@
-ML_sh3=m3/
diff --git a/gcc/config/sh/t-mlib-sh3e b/gcc/config/sh/t-mlib-sh3e
index ca18b1bcf..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh3e
+++ b/gcc/config/sh/t-mlib-sh3e
@@ -1 +0,0 @@
-ML_sh3e=m3e/
diff --git a/gcc/config/sh/t-mlib-sh4 b/gcc/config/sh/t-mlib-sh4
index be7f5c4fe..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh4
+++ b/gcc/config/sh/t-mlib-sh4
@@ -1 +0,0 @@
-ML_sh4=m4/
diff --git a/gcc/config/sh/t-mlib-sh4-nofpu b/gcc/config/sh/t-mlib-sh4-nofpu
index fa1243371..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh4-nofpu
+++ b/gcc/config/sh/t-mlib-sh4-nofpu
@@ -1 +0,0 @@
-ML_sh4_nofpu=m4-nofpu/
diff --git a/gcc/config/sh/t-mlib-sh4-single b/gcc/config/sh/t-mlib-sh4-single
index f81bddd1e..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh4-single
+++ b/gcc/config/sh/t-mlib-sh4-single
@@ -1 +0,0 @@
-ML_sh4_single=m4-single/
diff --git a/gcc/config/sh/t-mlib-sh4-single-only b/gcc/config/sh/t-mlib-sh4-single-only
index 121d598d6..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh4-single-only
+++ b/gcc/config/sh/t-mlib-sh4-single-only
@@ -1 +0,0 @@
-ML_sh4_single_only=m4-single-only/
diff --git a/gcc/config/sh/t-mlib-sh4a b/gcc/config/sh/t-mlib-sh4a
index 788b85296..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh4a
+++ b/gcc/config/sh/t-mlib-sh4a
@@ -1 +0,0 @@
-ML_sh4a=m4a/
diff --git a/gcc/config/sh/t-mlib-sh4a-nofpu b/gcc/config/sh/t-mlib-sh4a-nofpu
index c9dc28bb8..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh4a-nofpu
+++ b/gcc/config/sh/t-mlib-sh4a-nofpu
@@ -1 +0,0 @@
-ML_sh4a_nofpu=m4a-nofpu/
diff --git a/gcc/config/sh/t-mlib-sh4a-single b/gcc/config/sh/t-mlib-sh4a-single
index 036a4cc0a..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh4a-single
+++ b/gcc/config/sh/t-mlib-sh4a-single
@@ -1 +0,0 @@
-ML_sh4a_single=m4a-single/
diff --git a/gcc/config/sh/t-mlib-sh4a-single-only b/gcc/config/sh/t-mlib-sh4a-single-only
index 5709e8ef7..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh4a-single-only
+++ b/gcc/config/sh/t-mlib-sh4a-single-only
@@ -1 +0,0 @@
-ML_sh4a_single_only=m4a-single-only/
diff --git a/gcc/config/sh/t-mlib-sh4al b/gcc/config/sh/t-mlib-sh4al
index e8e36ba5b..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh4al
+++ b/gcc/config/sh/t-mlib-sh4al
@@ -1 +0,0 @@
-ML_sh4al=m4al/
diff --git a/gcc/config/sh/t-mlib-sh5-32media b/gcc/config/sh/t-mlib-sh5-32media
index f03fd2911..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh5-32media
+++ b/gcc/config/sh/t-mlib-sh5-32media
@@ -1 +0,0 @@
-ML_sh5_32media=m5-32media/
diff --git a/gcc/config/sh/t-mlib-sh5-32media-nofpu b/gcc/config/sh/t-mlib-sh5-32media-nofpu
index 0d84f0eed..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh5-32media-nofpu
+++ b/gcc/config/sh/t-mlib-sh5-32media-nofpu
@@ -1 +0,0 @@
-ML_sh5_32media_nofpu=m5-32media-nofpu/
diff --git a/gcc/config/sh/t-mlib-sh5-64media b/gcc/config/sh/t-mlib-sh5-64media
index d324f62b5..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh5-64media
+++ b/gcc/config/sh/t-mlib-sh5-64media
@@ -1 +0,0 @@
-ML_sh5_64media=m5-64media/
diff --git a/gcc/config/sh/t-mlib-sh5-64media-nofpu b/gcc/config/sh/t-mlib-sh5-64media-nofpu
index 127bc47e4..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh5-64media-nofpu
+++ b/gcc/config/sh/t-mlib-sh5-64media-nofpu
@@ -1 +0,0 @@
-ML_sh5_64media_nofpu=m5-64media-nofpu/
diff --git a/gcc/config/sh/t-mlib-sh5-compact b/gcc/config/sh/t-mlib-sh5-compact
index e330c25e6..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh5-compact
+++ b/gcc/config/sh/t-mlib-sh5-compact
@@ -1 +0,0 @@
-ML_sh5_compact=m5-compact/
diff --git a/gcc/config/sh/t-mlib-sh5-compact-nofpu b/gcc/config/sh/t-mlib-sh5-compact-nofpu
index cf6afdc4d..e69de29bb 100644
--- a/gcc/config/sh/t-mlib-sh5-compact-nofpu
+++ b/gcc/config/sh/t-mlib-sh5-compact-nofpu
@@ -1 +0,0 @@
-ML_sh5_compact_nofpu=m5-compact-nofpu/
diff --git a/gcc/config/sh/t-sgxxlite-linux b/gcc/config/sh/t-sgxxlite-linux
new file mode 100644
index 000000000..cdc40dd5d
--- /dev/null
+++ b/gcc/config/sh/t-sgxxlite-linux
@@ -0,0 +1,3 @@
+MULTILIB_OPTIONS += muclibc
+MULTILIB_OSDIRNAMES += muclibc=!uclibc m4al/muclibc=!m4al/uclibc mb/muclibc=!mb/uclibc
+MULTILIB_EXCEPTIONS += mb/m4al/muclibc
diff --git a/gcc/config/sh/t-sh b/gcc/config/sh/t-sh
index 5f1e8fb0e..1511d2f68 100644
--- a/gcc/config/sh/t-sh
+++ b/gcc/config/sh/t-sh
@@ -27,10 +27,10 @@ fp-bit.c: $(srcdir)/config/fp-bit.c
 	echo '#endif' 		>> fp-bit.c
 	cat $(srcdir)/config/fp-bit.c >> fp-bit.c
 
-MULTILIB_ENDIAN = ml/mb
-MULTILIB_CPUS= $(ML_sh1)$(ML_sh2a)$(ML_sh2a_nofpu)$(ML_sh2a_single_only)$(ML_sh2a_single)$(ML_sh2e)$(ML_sh2)$(ML_sh3e)$(ML_sh3)$(ML_sh4_nofpu)$(ML_sh4_single_only)$(ML_sh4_single)$(ML_sh4)$(ML_sh4a_nofpu)$(ML_sh4a_single_only)$(ML_sh4a_single)$(ML_sh4a)$(ML_sh5_32media)$(ML_sh5_32media_nofpu)$(ML_sh5_compact)$(ML_sh5_compact_nofpu)$(ML_sh5_64media)$(ML_sh5_64media_nofpu)
+DEFAULT_ENDIAN = $(word 1,$(TM_ENDIAN_CONFIG))
+OTHER_ENDIAN = $(word 2,$(TM_ENDIAN_CONFIG))
 
-MULTILIB_OPTIONS= $(MULTILIB_ENDIAN) $(MULTILIB_CPUS:/=)
+MULTILIB_OPTIONS= $(OTHER_ENDIAN) $(TM_MULTILIB_CONFIG)
 MULTILIB_DIRNAMES= 
 
 # The separate entries for m2a-nofpu and m2a-single-only with
@@ -58,7 +58,34 @@ MULTILIB_MATCHES = $(shell \
   done)
 
 # SH1 only supports big endian.
-MULTILIB_EXCEPTIONS = ml/m1 ml/m2a*
+MULTILIB_EXCEPTIONS = ml/m1 ml/m2a* $(TM_MULTILIB_EXCEPTIONS_CONFIG)
+
+MULTILIB_OSDIRNAMES = \
+	$(OTHER_ENDIAN)=!$(OTHER_ENDIAN) \
+	m1=!m1 $(OTHER_ENDIAN)/m1=!$(OTHER_ENDIAN)/m1 \
+	m2a=!m2a $(OTHER_ENDIAN)/m2a=!$(OTHER_ENDIAN)/m2a \
+	m2a-nofpu=!m2a-nofpu $(OTHER_ENDIAN)/m2a-nofpu=!$(OTHER_ENDIAN)/m2a-nofpu \
+	m2a-single-only=!m2a-single-only $(OTHER_ENDIAN)/m2a-single-only=!$(OTHER_ENDIAN)/m2a-single-only \
+	m2a-single=!m2a-single $(OTHER_ENDIAN)/m2a-single=!$(OTHER_ENDIAN)/m2a-single \
+	m2e=!m2e $(OTHER_ENDIAN)/m2e=!$(OTHER_ENDIAN)/m2e \
+	m2=!m2 $(OTHER_ENDIAN)/m2=!$(OTHER_ENDIAN)/m2 \
+	m3e=!m3e $(OTHER_ENDIAN)/m3e=!$(OTHER_ENDIAN)/m3e \
+	m3=!m3 $(OTHER_ENDIAN)/m3=!$(OTHER_ENDIAN)/m3 \
+	m4-nofpu=!m4-nofpu $(OTHER_ENDIAN)/m4-nofpu=!$(OTHER_ENDIAN)/m4-nofpu \
+	m4-single-only=!m4-single-only $(OTHER_ENDIAN)/m4-single-only=!$(OTHER_ENDIAN)/m4-single-only \
+	m4-single=!m4-single $(OTHER_ENDIAN)/m4-single=!$(OTHER_ENDIAN)/m4-single \
+	m4=!m4 $(OTHER_ENDIAN)/m4=!$(OTHER_ENDIAN)/m4 \
+	m4a-nofpu=!m4a-nofpu $(OTHER_ENDIAN)/m4a-nofpu=!$(OTHER_ENDIAN)/m4a-nofpu \
+	m4a-single-only=!m4a-single-only $(OTHER_ENDIAN)/m4a-single-only=!$(OTHER_ENDIAN)/m4a-single-only \
+	m4a-single=!m4a-single $(OTHER_ENDIAN)/m4a-single=!$(OTHER_ENDIAN)/m4a-single \
+	m4a=!m4a $(OTHER_ENDIAN)/m4a=!$(OTHER_ENDIAN)/m4a \
+	m4al=!m4al $(OTHER_ENDIAN)/m4al=!$(OTHER_ENDIAN)/m4al \
+	m5-32media=!m5-32media $(OTHER_ENDIAN)/m5-32media=!$(OTHER_ENDIAN)/m5-32media \
+	m5-32media-nofpu=!m5-32media-nofpu $(OTHER_ENDIAN)/m5-32media-nofpu=!$(OTHER_ENDIAN)/m5-32media-nofpu \
+	m5-compact=!m5-compact $(OTHER_ENDIAN)/m5-compact=!$(OTHER_ENDIAN)/m5-compact \
+	m5-compact-nofpu=!m5-compact-nofpu $(OTHER_ENDIAN)/m5-compact-nofpu=!$(OTHER_ENDIAN)/m5-compact-nofpu \
+	m5-64media=!m5-64media $(OTHER_ENDIAN)/m5-64media=!$(OTHER_ENDIAN)/m5-64media \
+	m5-64media-nofpu=!m5-64media-nofpu $(OTHER_ENDIAN)/m5-64media-nofpu=!$(OTHER_ENDIAN)/m5-64media-nofpu
 
 LIBGCC = stmp-multilib
 INSTALL_LIBGCC = install-multilib
diff --git a/gcc/config/sh/t-uclinux b/gcc/config/sh/t-uclinux
new file mode 100644
index 000000000..13f006a54
--- /dev/null
+++ b/gcc/config/sh/t-uclinux
@@ -0,0 +1,4 @@
+# Compile crtbeginS.o and crtendS.o with pic.
+CRTSTUFF_T_CFLAGS_S = $(CRTSTUFF_T_CFLAGS) -fPIC
+
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o $(OPT_EXTRA_PARTS)
diff --git a/gcc/config/sh/uclinux.h b/gcc/config/sh/uclinux.h
new file mode 100644
index 000000000..4247a188f
--- /dev/null
+++ b/gcc/config/sh/uclinux.h
@@ -0,0 +1,104 @@
+/* Definitions for SH based uClinux system using ELF objects with
+   special linker post-processing to produce FLAT executables.
+
+   Copyright (C) 2008
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "%{!shared:crt1.o%s} crti.o%s \
+   %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}" \
+   FDPIC_STARTFILE_SPEC
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+
+#define LINK_EH_SPEC "%{mfdpic:%{!static:--eh-frame-hdr}} "
+
+#ifdef FDPIC_DEFAULT
+#undef SUBTARGET_LINK_SPEC
+#define SUBTARGET_LINK_SPEC \
+  "%{shared:-shared} \
+   %{!static: \
+     %{rdynamic:-export-dynamic} \
+     %{!dynamic-linker:-dynamic-linker /lib/ld-uClibc.so.0}} \
+   %{static:-static}"
+#undef SUBTARGET_LINK_EMUL_SUFFIX
+#define SUBTARGET_LINK_EMUL_SUFFIX "_fd"
+#undef SUBTARGET_DRIVER_SELF_SPECS
+#define SUBTARGET_DRIVER_SELF_SPECS "%{!mno-fdpic:-mfdpic} "
+#undef SUBTARGET_ASM_SPEC
+#define SUBTARGET_ASM_SPEC "%{!mno-fdpic:--fdpic}"
+#define FDPIC_STARTFILE_SPEC "%{!mno-fdpic: crtreloc.o%s}"
+#else
+#undef SUBTARGET_LINK_SPEC
+#define SUBTARGET_LINK_SPEC "%{shared:-shared} %{static:-static} %{!elf2flt*:-elf2flt}"
+#undef SUBTARGET_LINK_EMUL_SUFFIX
+#define SUBTARGET_LINK_EMUL_SUFFIX "_uclinux"
+#define FDPIC_STARTFILE_SPEC "%{mfdpic: crtreloc.o%s}"
+#endif
+
+/* While the speed-optimized implementations of udivsi3_i4i / sdivsi3_i4i
+   in libgcc are not available for SH2, the space-optimized ones in
+   libgcc-Os-4-200 are.  Thus, when not optimizing for space, link
+   libgcc-Os-4-200 after libgcc, so that -mdiv=call-table works for -m2.  */
+#undef LIBGCC_SPEC
+#define LIBGCC_SPEC "%{Os: -lgcc-Os-4-200} -lgcc %{!Os: -lgcc-Os-4-200}"
+
+/* we have init/fini section. */
+#define HAS_INIT_SECTION
+
+/* Bring in standard linux defines */
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+	builtin_define ("__gnu_linux__");	\
+	builtin_define_std ("linux");		\
+	builtin_define_std ("unix");		\
+	builtin_assert ("system=linux");	\
+	builtin_assert ("system=unix");		\
+	builtin_assert ("system=posix");	\
+	builtin_define ("__uClinux__");		\
+    }						\
+  while (0)
+
+/* The GNU C++ standard library requires that these macros be defined.  */
+#undef CPLUSPLUS_CPP_SPEC
+#define CPLUSPLUS_CPP_SPEC "-D_GNU_SOURCE %(cpp)"
+
+/* Since libgcc is compiled with -fpic for this target, we can't use
+   __sdivsi3_1 as the division strategy for -O0 and -Os.  */
+#undef SH_DIV_STRATEGY_DEFAULT
+#define SH_DIV_STRATEGY_DEFAULT SH_DIV_CALL2
+#undef SH_DIV_STR_FOR_SIZE
+#define SH_DIV_STR_FOR_SIZE "call2"
+
+/* The uclinux binary format relies on relocations against a segment being
+   within that segment.  Conservatively apply this rule to individual
+   sections.  */
+#undef SH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P
+#define SH_OFFSETS_MUST_BE_WITHIN_SECTIONS_P 1
+
+/* CSL LOCAL */
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  /* __thread is not supported by uClibc.  */				\
+  targetm.have_tls = 0;							\
+} while (0)
diff --git a/gcc/config/sol2.h b/gcc/config/sol2.h
index ba3b927ac..0256eeafa 100644
--- a/gcc/config/sol2.h
+++ b/gcc/config/sol2.h
@@ -123,12 +123,12 @@ along with GCC; see the file COPYING3.  If not see
    %{YP,*} \
    %{R*} \
    %{compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,/usr/ucblib:/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \
-             %{!p:%{!pg:-Y P,/usr/ucblib:/usr/ccs/lib:/usr/lib}}} \
-             -R /usr/ucblib} \
+     %{!YP,*:%{p|pg:-Y P,%R/usr/ucblib:%R/usr/ccs/lib/libp:%R/usr/lib/libp:%R/usr/ccs/lib:%R/usr/lib} \
+             %{!p:%{!pg:-Y P,%R/usr/ucblib:%R/usr/ccs/lib:%R/usr/lib}}} \
+             -R %R/usr/ucblib} \
    %{!compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \
-             %{!p:%{!pg:-Y P,/usr/ccs/lib:/usr/lib}}}}"
+     %{!YP,*:%{p|pg:-Y P,%R/usr/ccs/lib/libp:%R/usr/lib/libp:%R/usr/ccs/lib:%R/usr/lib} \
+             %{!p:%{!pg:-Y P,%R/usr/ccs/lib:%R/usr/lib}}}}"
 
 #undef LINK_ARCH32_SPEC
 #define LINK_ARCH32_SPEC LINK_ARCH32_SPEC_BASE
diff --git a/gcc/config/sparc/linux64.h b/gcc/config/sparc/linux64.h
index 9d0799f93..771f9488c 100644
--- a/gcc/config/sparc/linux64.h
+++ b/gcc/config/sparc/linux64.h
@@ -40,10 +40,15 @@ along with GCC; see the file COPYING3.  If not see
    in a Medium/Low code model environment.  */
 
 #undef TARGET_DEFAULT
+#ifdef BIARCH_32BIT_DEFAULT
+#define TARGET_DEFAULT \
+  (MASK_APP_REGS + MASK_FPU)
+#else
 #define TARGET_DEFAULT \
   (MASK_V9 + MASK_PTR64 + MASK_64BIT /* + MASK_HARD_QUAD */ \
    + MASK_STACK_BIAS + MASK_APP_REGS + MASK_FPU + MASK_LONG_DOUBLE_128)
 #endif
+#endif
 
 /* This must be v9a not just v9 because by default we enable
    -mvis.  */
diff --git a/gcc/config/sparc/sol2-bi.h b/gcc/config/sparc/sol2-bi.h
index 91d5e130b..bfaa88184 100644
--- a/gcc/config/sparc/sol2-bi.h
+++ b/gcc/config/sparc/sol2-bi.h
@@ -172,12 +172,12 @@
    %{YP,*} \
    %{R*} \
    %{compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,/usr/ucblib/sparcv9:/usr/lib/libp/sparcv9:/usr/lib/sparcv9} \
-       %{!p:%{!pg:-Y P,/usr/ucblib/sparcv9:/usr/lib/sparcv9}}} \
-     -R /usr/ucblib/sparcv9} \
+     %{!YP,*:%{p|pg:-Y P,%R/usr/ucblib/sparcv9:%R/usr/lib/libp/sparcv9:%R/usr/lib/sparcv9} \
+       %{!p:%{!pg:-Y P,%R/usr/ucblib/sparcv9:%R/usr/lib/sparcv9}}} \
+     -R %R/usr/ucblib/sparcv9} \
    %{!compat-bsd: \
-     %{!YP,*:%{p|pg:-Y P,/usr/lib/libp/sparcv9:/usr/lib/sparcv9} \
-       %{!p:%{!pg:-Y P,/usr/lib/sparcv9}}}}"
+     %{!YP,*:%{p|pg:-Y P,%R/usr/lib/libp/sparcv9:%R/usr/lib/sparcv9} \
+       %{!p:%{!pg:-Y P,%R/usr/lib/sparcv9}}}}"
 
 #define LINK_ARCH64_SPEC LINK_ARCH64_SPEC_BASE
 
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 6e640f6a2..7743f1ff7 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -6102,7 +6102,7 @@ enum rtx_code
 sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)
 {
   const char *qpfunc;
-  rtx slot0, slot1, result, tem, tem2;
+  rtx slot0, slot1, result, tem, tem2, libfunc;
   enum machine_mode mode;
   enum rtx_code new_comparison;
 
@@ -6165,7 +6165,8 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)
 	  emit_move_insn (slot1, y);
 	}
 
-      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, qpfunc), LCT_NORMAL,
+      libfunc = gen_rtx_SYMBOL_REF (Pmode, qpfunc);
+      emit_library_call (libfunc, LCT_NORMAL,
 			 DImode, 2,
 			 XEXP (slot0, 0), Pmode,
 			 XEXP (slot1, 0), Pmode);
@@ -6173,7 +6174,8 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)
     }
   else
     {
-      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, qpfunc), LCT_NORMAL,
+      libfunc = gen_rtx_SYMBOL_REF (Pmode, qpfunc);
+      emit_library_call (libfunc, LCT_NORMAL,
 			 SImode, 2,
 			 x, TFmode, y, TFmode);
       mode = SImode;
@@ -6184,7 +6186,7 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)
      register so reload doesn't clobber the value if it needs
      the return register for a spill reg.  */
   result = gen_reg_rtx (mode);
-  emit_move_insn (result, hard_libcall_value (mode));
+  emit_move_insn (result, hard_libcall_value (mode, libfunc));
 
   switch (comparison)
     {
diff --git a/gcc/config/spu/spu.h b/gcc/config/spu/spu.h
index 2489ac471..c4c73b7be 100644
--- a/gcc/config/spu/spu.h
+++ b/gcc/config/spu/spu.h
@@ -270,7 +270,8 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;	\
 
 #define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (LINK_REGISTER_REGNUM)
 
-#define ARG_POINTER_CFA_OFFSET(FNDECL) (-STACK_POINTER_OFFSET)
+#define ARG_POINTER_CFA_OFFSET(FNDECL) \
+  (crtl->args.pretend_args_size - STACK_POINTER_OFFSET)
 
 
 /* Stack Checking */
diff --git a/gcc/config/t-eglibc b/gcc/config/t-eglibc
new file mode 100644
index 000000000..3ba81fcc7
--- /dev/null
+++ b/gcc/config/t-eglibc
@@ -0,0 +1,25 @@
+# multilibs  -*- mode:Makefile -*-
+
+MULTILIB_EXCEPTIONS :=
+MULTILIB_MATCHES    :=
+MULTILIB_ALIASES    :=
+
+# For all items in EGLIBC_CONFIGS except for the last one
+# do $1.  For the last one do $2.  The items are separated with ",".
+EGLIBC_AWK = $(shell echo $(EGLIBC_CONFIGS) | $(AWK) \
+	'{ \
+	N=split ($$0, configs, ","); \
+	for (i = 1; i < N; ++i) $1; \
+	if (N > 0) $2; \
+	}')
+
+MULTILIB_OPTIONS    := $(call EGLIBC_AWK, \
+	printf ("feglibc=%s/", configs[i]), \
+	printf ("feglibc=%s\n", configs[i]))
+MULTILIB_DIRNAMES   := $(call EGLIBC_AWK, \
+	printf ("%s ", configs[i]), \
+	printf ("%s\n", configs[i]))
+MULTILIB_OSDIRNAMES := $(call EGLIBC_AWK, \
+	printf ("feglibc.%s=!%s ", configs[i], configs[i]), \
+	printf ("feglibc.%s=!%s\n", configs[i], configs[i]))
+
diff --git a/gcc/config/t-sysroot-suffix b/gcc/config/t-sysroot-suffix
new file mode 100644
index 000000000..5ebd9f0a1
--- /dev/null
+++ b/gcc/config/t-sysroot-suffix
@@ -0,0 +1,7 @@
+# Generate SYSROOT_SUFFIX_SPEC from MULTILIB_OSDIRNAMES
+
+sysroot-suffix.h: $(srcdir)/config/print-sysroot-suffix.sh
+	$(SHELL) $(srcdir)/config/print-sysroot-suffix.sh \
+	  "$(MULTILIB_OSDIRNAMES)" "$(MULTILIB_OPTIONS)" \
+	  "$(MULTILIB_MATCHES)" "$(MULTILIB_ALIASES)" > tmp-sysroot-suffix.h
+	mv tmp-sysroot-suffix.h $@
diff --git a/gcc/config/vx-common.h b/gcc/config/vx-common.h
index 6a6d1097f..f1aad2e6e 100644
--- a/gcc/config/vx-common.h
+++ b/gcc/config/vx-common.h
@@ -92,3 +92,6 @@ along with GCC; see the file COPYING3.  If not see
 /* We occasionally need to distinguish between the VxWorks variants.  */
 #define VXWORKS_KIND_NORMAL  1
 #define VXWORKS_KIND_AE      2
+
+/* Enable get_feature license checking.  */
+#define TARGET_FLEXLM
diff --git a/gcc/configure b/gcc/configure
index 4a42eaf3e..09be82611 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -458,7 +458,7 @@ ac_includes_default="\
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP EGREP loose_warn strict_warn warn_cflags nocommon_flag TREEBROWSER valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_decimal_float enable_fixed_point enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR onestep PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI datarootdir docdir htmldir SET_MAKE AWK LN_S LN RANLIB ac_ct_RANLIB ranlib_flags INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON NM AR COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB TARGET_GETGROUPS_T LIBICONV LTLIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file extra_opt_files USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CROSS ALL SYSTEM_HEADER_DIR inhibit_libc CC_FOR_BUILD BUILD_CFLAGS BUILD_LDFLAGS STMP_FIXINC STMP_FIXPROTO collect2 LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN OBJDUMP ac_ct_OBJDUMP ac_ct_AR STRIP ac_ct_STRIP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 objdir enable_fast_install gcc_cv_as ORIGINAL_AS_FOR_TARGET gcc_cv_ld ORIGINAL_LD_FOR_TARGET gcc_cv_nm ORIGINAL_NM_FOR_TARGET gcc_cv_objdump gcc_cv_readelf libgcc_visibility GGC zlibdir zlibinc MAINT gcc_tooldir dollar slibdir subdirs srcdir all_compilers all_gtfiles all_lang_makefrags all_lang_makefiles all_languages all_selected_languages build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines build_file_translate check_languages cpp_install_dir xmake_file tmake_file extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines c_target_objs cxx_target_objs fortran_target_objs target_cpu_default GMPLIBS GMPINC PPLLIBS PPLINC CLOOGLIBS CLOOGINC LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical build_libsubdir build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT GNATBIND ac_ct_GNATBIND GNATMAKE ac_ct_GNATMAKE NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP EGREP loose_warn strict_warn warn_cflags nocommon_flag TREEBROWSER valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_decimal_float enable_fixed_point enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR EGLIBC_CONFIGS CONFIGURE_SPECS onestep PKGVERSION REPORT_BUGS_TO REPORT_BUGS_TEXI datarootdir docdir htmldir SET_MAKE AWK LN_S LN RANLIB ac_ct_RANLIB ranlib_flags INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON NM AR COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB TARGET_GETGROUPS_T LIBICONV LTLIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file extra_opt_files USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT CROSS ALL SYSTEM_HEADER_DIR inhibit_libc CC_FOR_BUILD BUILD_CFLAGS BUILD_LDFLAGS STMP_FIXINC STMP_FIXPROTO collect2 LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN OBJDUMP ac_ct_OBJDUMP ac_ct_AR STRIP ac_ct_STRIP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 objdir enable_fast_install gcc_cv_as ORIGINAL_AS_FOR_TARGET gcc_cv_ld ORIGINAL_LD_FOR_TARGET gcc_cv_nm ORIGINAL_NM_FOR_TARGET gcc_cv_objdump gcc_cv_readelf libgcc_visibility GGC zlibdir zlibinc MAINT gcc_tooldir dollar slibdir subdirs srcdir all_compilers all_gtfiles all_lang_makefrags all_lang_makefiles all_languages all_selected_languages build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines build_file_translate check_languages cpp_install_dir xmake_file tmake_file TM_ENDIAN_CONFIG TM_MULTILIB_CONFIG TM_MULTILIB_EXCEPTIONS_CONFIG extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines c_target_objs cxx_target_objs fortran_target_objs target_cpu_default GMPLIBS GMPINC PPLLIBS PPLINC CLOOGLIBS CLOOGINC LIBOBJS LTLIBOBJS'
 ac_subst_files='language_hooks'
 ac_pwd=`pwd`
 
@@ -1078,12 +1078,16 @@ Optional Features:
   --enable-fast-install[=PKGS]
                           optimize for fast installation [default=yes]
   --disable-libtool-lock  avoid locking (might break parallel builds)
+  --enable-linker-build-id
+                          compiler will always pass --build-id to linker
   --enable-maintainer-mode
                           enable make rules and dependencies not useful
                           (and sometimes confusing) to the casual installer
   --enable-version-specific-runtime-libs
                           specify that runtime libraries should be
                           installed in a compiler-specific directory
+  --enable-poison-system-directories
+                          warn for use of native system header directories
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
@@ -1105,8 +1109,13 @@ Optional Packages:
   --with-build-sysroot=sysroot
                           use sysroot as the system root during the build
   --with-sysroot=DIR Search for usr/lib, usr/include, et al, within DIR.
-  --with-pkgversion=PKG   Use PKG in the version string in place of "GCC"
+  --with-eglibc-configs=CONFIGS
+                          build multilibs for these EGLIBC configurations
+  --with-specs=SPECS      add SPECS to driver command-line processing
+  --with-pkgversion=PKG   Use PKG in the version string in place of "Linaro
+                          GCC `cat $srcdir/LINARO-VERSION`"
   --with-bugurl=URL       Direct users to URL to report a bug
+  --with-multilib-list    Select multilibs (SH only)
   --with-gnu-ld           assume the C compiler uses GNU ld default=no
   --with-libiconv-prefix[=DIR]  search for libiconv in DIR/include and DIR/lib
   --without-libiconv-prefix     don't search for libiconv in includedir and libdir
@@ -8042,6 +8051,28 @@ fi;
 
 
 
+
+# Check whether --with-eglibc-configs or --without-eglibc-configs was given.
+if test "${with_eglibc_configs+set}" = set; then
+  withval="$with_eglibc_configs"
+  EGLIBC_CONFIGS=$withval
+else
+  EGLIBC_CONFIGS=
+
+fi;
+
+
+
+# Check whether --with-specs or --without-specs was given.
+if test "${with_specs+set}" = set; then
+  withval="$with_specs"
+  CONFIGURE_SPECS=$withval
+else
+  CONFIGURE_SPECS=
+
+fi;
+
+
 # Build with intermodule optimisations
 # Check whether --enable-intermodule or --disable-intermodule was given.
 if test "${enable_intermodule+set}" = set; then
@@ -8068,7 +8099,7 @@ echo "$as_me: error: package version not specified" >&2;}
       *)   PKGVERSION="($withval) " ;;
      esac
 else
-  PKGVERSION="(GCC) "
+  PKGVERSION="(Linaro GCC `cat $srcdir/LINARO-VERSION`) "
 
 fi;
 
@@ -8137,6 +8168,15 @@ fi;
 
 
 
+
+# Check whether --with-multilib-list or --without-multilib-list was given.
+if test "${with_multilib_list+set}" = set; then
+  withval="$with_multilib_list"
+  :
+else
+  with_multilib_list=default
+fi;
+
 # -------------------------
 # Checks for other programs
 # -------------------------
@@ -14509,13 +14549,13 @@ if test "${lt_cv_nm_interface+set}" = set; then
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:14512: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:14552: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:14515: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:14555: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:14518: output\"" >&5)
+  (eval echo "\"\$as_me:14558: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
@@ -14911,6 +14951,10 @@ cegcc)
   lt_cv_file_magic_cmd='$OBJDUMP -f'
   ;;
 
+nucleuseabi*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 darwin* | rhapsody*)
   lt_cv_deplibs_check_method=pass_all
   ;;
@@ -15672,7 +15716,7 @@ ia64-*-hpux*)
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 15675 "configure"' > conftest.$ac_ext
+  echo '#line 15719 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -16971,11 +17015,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:16974: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17018: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:16978: \$? = $ac_status" >&5
+   echo "$as_me:17022: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -17310,11 +17354,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17313: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17357: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:17317: \$? = $ac_status" >&5
+   echo "$as_me:17361: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -17415,11 +17459,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17418: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17462: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:17422: \$? = $ac_status" >&5
+   echo "$as_me:17466: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -17470,11 +17514,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17473: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17517: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:17477: \$? = $ac_status" >&5
+   echo "$as_me:17521: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -19369,6 +19413,21 @@ newsos6)
   shlibpath_overrides_runpath=yes
   ;;
 
+nucleus*)
+  case $host_vendor in
+    samsung)
+      version_type=linux
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+      soname_spec='$libname${shared_ext}$major'
+      shlibpath_var=LD_LIBRARY_PATH
+      hardcode_into_libs=yes
+      ;;
+    *)
+      dynamic_linker=no
+      ;;
+  esac
+  ;;
+
 *nto* | *qnx*)
   version_type=qnx
   need_lib_prefix=no
@@ -20282,7 +20341,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 20285 "configure"
+#line 20344 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -20378,7 +20437,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 20381 "configure"
+#line 20440 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -22188,6 +22247,22 @@ x:
 	tls_first_minor=16
 	tls_as_opt='-32 --fatal-warnings'
 	;;
+  m68k-*-*)
+    conftest_s='
+	.section .tdata,"awT",@progbits
+x:
+	.word 2
+	.text
+foo:
+	move.l x@TLSGD(%a5),%a0
+	move.l x@TLSLDM(%a5),%a0
+	move.l x@TLSLDO(%a5),%a0
+	move.l x@TLSIE(%a5),%a0
+	move.l x@TLSLE(%a5),%a0'
+	tls_first_major=2
+	tls_first_minor=19
+	tls_as_opt='--fatal-warnings'
+	;;
   powerpc-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
@@ -22831,6 +22906,44 @@ fi
   i[34567]86-*-* | x86_64-*-*)
     case $target_os in
       cygwin* | pe | mingw32*)
+	# Recent binutils allows the three-operand form of ".comm" on PE.  This
+	# definition is used unconditionally to initialise the default state of
+	# the target option variable that governs usage of the feature.
+	echo "$as_me:$LINENO: checking assembler for .comm with alignment" >&5
+echo $ECHO_N "checking assembler for .comm with alignment... $ECHO_C" >&6
+if test "${gcc_cv_as_comm_has_align+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  gcc_cv_as_comm_has_align=no
+    if test $in_tree_gas = yes; then
+    if test $gcc_cv_gas_vers -ge `expr \( \( 2 \* 1000 \) + 19 \) \* 1000 + 52`
+  then gcc_cv_as_comm_has_align=yes
+fi
+  elif test x$gcc_cv_as != x; then
+    echo '.comm foo,1,32' > conftest.s
+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }
+    then
+	gcc_cv_as_comm_has_align=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+echo "$as_me:$LINENO: result: $gcc_cv_as_comm_has_align" >&5
+echo "${ECHO_T}$gcc_cv_as_comm_has_align" >&6
+
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_GAS_ALIGNED_COMM `if test $gcc_cv_as_comm_has_align = yes; then echo 1; else echo 0; fi`
+_ACEOF
+
 	# Used for DWARF 2 in PE
 	echo "$as_me:$LINENO: checking assembler for .secrel32 relocs" >&5
 echo $ECHO_N "checking assembler for .secrel32 relocs... $ECHO_C" >&6
@@ -24369,6 +24482,56 @@ _ACEOF
 
 fi
 
+echo "$as_me:$LINENO: checking linker --build-id support" >&5
+echo $ECHO_N "checking linker --build-id support... $ECHO_C" >&6
+if test "${gcc_cv_ld_buildid+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  gcc_cv_ld_buildid=no
+  if test $in_tree_ld = yes ; then
+    if test "$gcc_cv_gld_major_version" -eq 2 -a \
+       "$gcc_cv_gld_minor_version" -ge 18 -o \
+       "$gcc_cv_gld_major_version" -gt 2 \
+       && test $in_tree_ld_is_elf = yes; then
+      gcc_cv_ld_buildid=yes
+    fi
+  elif test x$gcc_cv_ld != x; then
+    if $gcc_cv_ld --help 2>/dev/null | grep build-id > /dev/null; then
+      gcc_cv_ld_buildid=yes
+    fi
+  fi
+fi
+echo "$as_me:$LINENO: result: $gcc_cv_ld_buildid" >&5
+echo "${ECHO_T}$gcc_cv_ld_buildid" >&6
+if test x"$gcc_cv_ld_buildid" = xyes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_LD_BUILDID 1
+_ACEOF
+
+fi
+
+# Check whether --enable-linker-build-id or --disable-linker-build-id was given.
+if test "${enable_linker_build_id+set}" = set; then
+  enableval="$enable_linker_build_id"
+
+else
+  enable_linker_build_id=no
+fi;
+
+if test x"$enable_linker_build_id" = xyes; then
+  if test x"$gcc_cv_ld_buildid" = xyes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_LD_BUILDID 1
+_ACEOF
+
+  else
+    { echo "$as_me:$LINENO: WARNING: --build-id is not supported by your linker; --enable-linker-build-id ignored" >&5
+echo "$as_me: WARNING: --build-id is not supported by your linker; --enable-linker-build-id ignored" >&2;}
+  fi
+fi
+
 echo "$as_me:$LINENO: checking linker --sysroot support" >&5
 echo $ECHO_N "checking linker --sysroot support... $ECHO_C" >&6
 if test "${gcc_cv_ld_sysroot+set}" = set; then
@@ -24415,7 +24578,9 @@ else
     case "$target" in
        *-*-linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu)
       if test x$host != x$target || test "x$TARGET_SYSTEM_ROOT" != x; then
-	if test "x$with_sysroot" = x; then
+	if test "x$with_headers" != x; then
+	  glibc_header_dir=$with_headers
+	elif test "x$with_sysroot" = x; then
 	  glibc_header_dir="${exec_prefix}/${target_noncanonical}/sys-include"
 	elif test "x$with_build_sysroot" != "x"; then
 	  glibc_header_dir="${with_build_sysroot}/usr/include"
@@ -24427,6 +24592,9 @@ else
       else
 	glibc_header_dir=/usr/include
       fi
+      if test "x$enable_libssp" = "xno"; then
+	gcc_cv_libc_provides_ssp=yes
+      fi
       # glibc 2.4 and later provides __stack_chk_fail and
       # either __stack_chk_guard, or TLS access to stack guard canary.
       if test -f $glibc_header_dir/features.h \
@@ -24811,8 +24979,8 @@ done
 rm -f Make-hooks
 touch Make-hooks
 target_list="all.cross start.encap rest.encap tags \
-	install-common install-man install-info install-pdf dvi pdf \
-	html uninstall info man srcextra srcman srcinfo \
+	install-common install-man install-info install-pdf install-html dvi \
+	pdf html uninstall info man srcextra srcman srcinfo \
 	mostlyclean clean distclean maintainer-clean"
 
 for t in $target_list
@@ -24903,6 +25071,21 @@ else
 fi;
 
 
+# Check whether --enable-poison-system-directories or --disable-poison-system-directories was given.
+if test "${enable_poison_system_directories+set}" = set; then
+  enableval="$enable_poison_system_directories"
+
+else
+  enable_poison_system_directories=no
+fi;
+if test "x${enable_poison_system_directories}" = "xyes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_POISON_SYSTEM_DIRECTORIES 1
+_ACEOF
+
+fi
+
 # Substitute configuration variables
 
 
@@ -24957,6 +25140,9 @@ fi;
 
 
 
+
+
+
 
 
 
@@ -25679,6 +25865,8 @@ s,@enable_shared@,$enable_shared,;t t
 s,@TARGET_SYSTEM_ROOT@,$TARGET_SYSTEM_ROOT,;t t
 s,@TARGET_SYSTEM_ROOT_DEFINE@,$TARGET_SYSTEM_ROOT_DEFINE,;t t
 s,@CROSS_SYSTEM_HEADER_DIR@,$CROSS_SYSTEM_HEADER_DIR,;t t
+s,@EGLIBC_CONFIGS@,$EGLIBC_CONFIGS,;t t
+s,@CONFIGURE_SPECS@,$CONFIGURE_SPECS,;t t
 s,@onestep@,$onestep,;t t
 s,@PKGVERSION@,$PKGVERSION,;t t
 s,@REPORT_BUGS_TO@,$REPORT_BUGS_TO,;t t
@@ -25798,6 +25986,9 @@ s,@check_languages@,$check_languages,;t t
 s,@cpp_install_dir@,$cpp_install_dir,;t t
 s,@xmake_file@,$xmake_file,;t t
 s,@tmake_file@,$tmake_file,;t t
+s,@TM_ENDIAN_CONFIG@,$TM_ENDIAN_CONFIG,;t t
+s,@TM_MULTILIB_CONFIG@,$TM_MULTILIB_CONFIG,;t t
+s,@TM_MULTILIB_EXCEPTIONS_CONFIG@,$TM_MULTILIB_EXCEPTIONS_CONFIG,;t t
 s,@extra_gcc_objs@,$extra_gcc_objs,;t t
 s,@extra_headers_list@,$extra_headers_list,;t t
 s,@extra_objs@,$extra_objs,;t t
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 99950d717..55105d664 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -770,6 +770,22 @@ AC_SUBST(TARGET_SYSTEM_ROOT)
 AC_SUBST(TARGET_SYSTEM_ROOT_DEFINE)
 AC_SUBST(CROSS_SYSTEM_HEADER_DIR)
 
+AC_ARG_WITH(eglibc-configs,
+  [AS_HELP_STRING([--with-eglibc-configs=CONFIGS],
+                  [build multilibs for these EGLIBC configurations])],
+  [EGLIBC_CONFIGS=$withval],
+  [EGLIBC_CONFIGS=]
+)
+AC_SUBST(EGLIBC_CONFIGS)
+
+AC_ARG_WITH(specs,
+  [AS_HELP_STRING([--with-specs=SPECS],
+                  [add SPECS to driver command-line processing])],
+  [CONFIGURE_SPECS=$withval],
+  [CONFIGURE_SPECS=]
+)
+AC_SUBST(CONFIGURE_SPECS)
+
 # Build with intermodule optimisations
 AC_ARG_ENABLE(intermodule,
 [  --enable-intermodule    build the compiler in one step],
@@ -780,7 +796,7 @@ esac],
 [onestep=""])
 AC_SUBST(onestep)
 
-ACX_PKGVERSION([GCC])
+ACX_PKGVERSION([Linaro GCC `cat $srcdir/LINARO-VERSION`])
 ACX_BUGURL([http://gcc.gnu.org/bugs.html])
 
 # Sanity check enable_languages in case someone does not run the toplevel
@@ -810,6 +826,11 @@ AC_SUBST(datarootdir)
 AC_SUBST(docdir)
 AC_SUBST(htmldir)
 
+AC_ARG_WITH(multilib-list,
+[  --with-multilib-list    Select multilibs (SH only)],
+:,
+with_multilib_list=default)
+
 # -------------------------
 # Checks for other programs
 # -------------------------
@@ -2631,6 +2652,22 @@ x:
 	tls_first_minor=16
 	tls_as_opt='-32 --fatal-warnings'
 	;;
+  m68k-*-*)
+    conftest_s='
+	.section .tdata,"awT",@progbits
+x:
+	.word 2
+	.text
+foo:
+	move.l x@TLSGD(%a5),%a0
+	move.l x@TLSLDM(%a5),%a0
+	move.l x@TLSLDO(%a5),%a0
+	move.l x@TLSIE(%a5),%a0
+	move.l x@TLSLE(%a5),%a0'
+	tls_first_major=2
+	tls_first_minor=19
+	tls_as_opt='--fatal-warnings'
+	;;
   powerpc-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
@@ -3011,6 +3048,15 @@ changequote(,)dnl
 changequote([,])dnl
     case $target_os in
       cygwin* | pe | mingw32*)
+	# Recent binutils allows the three-operand form of ".comm" on PE.  This
+	# definition is used unconditionally to initialise the default state of
+	# the target option variable that governs usage of the feature.
+	gcc_GAS_CHECK_FEATURE([.comm with alignment], gcc_cv_as_comm_has_align,
+	 [2,19,52],,[.comm foo,1,32])
+	AC_DEFINE_UNQUOTED(HAVE_GAS_ALIGNED_COMM,
+	  [`if test $gcc_cv_as_comm_has_align = yes; then echo 1; else echo 0; fi`],
+	  [Define if your assembler supports specifying the alignment
+	   of objects allocated using the GAS .comm command.])
 	# Used for DWARF 2 in PE
 	gcc_GAS_CHECK_FEATURE([.secrel32 relocs],
 	  gcc_cv_as_ix86_pe_secrel32,
@@ -3610,6 +3656,41 @@ if test x"$gcc_cv_ld_sol2_emulation" = xyes; then
   [Define if your linker supports the *_sol2 emulations.])
 fi
 
+AC_CACHE_CHECK(linker --build-id support,
+  gcc_cv_ld_buildid,
+  [gcc_cv_ld_buildid=no
+  if test $in_tree_ld = yes ; then
+    if test "$gcc_cv_gld_major_version" -eq 2 -a \
+       "$gcc_cv_gld_minor_version" -ge 18 -o \
+       "$gcc_cv_gld_major_version" -gt 2 \
+       && test $in_tree_ld_is_elf = yes; then
+      gcc_cv_ld_buildid=yes
+    fi
+  elif test x$gcc_cv_ld != x; then
+    if $gcc_cv_ld --help 2>/dev/null | grep build-id > /dev/null; then
+      gcc_cv_ld_buildid=yes
+    fi
+  fi])
+if test x"$gcc_cv_ld_buildid" = xyes; then
+  AC_DEFINE(HAVE_LD_BUILDID, 1,
+  [Define if your linker supports --build-id.])
+fi
+
+AC_ARG_ENABLE(linker-build-id,
+[  --enable-linker-build-id
+                          compiler will always pass --build-id to linker],
+[],
+enable_linker_build_id=no)
+
+if test x"$enable_linker_build_id" = xyes; then
+  if test x"$gcc_cv_ld_buildid" = xyes; then
+    AC_DEFINE(ENABLE_LD_BUILDID, 1,
+    [Define if gcc should always pass --build-id to linker.])
+  else
+    AC_MSG_WARN(--build-id is not supported by your linker; --enable-linker-build-id ignored)
+  fi
+fi
+
 AC_CACHE_CHECK(linker --sysroot support,
   gcc_cv_ld_sysroot,
   [gcc_cv_ld_sysroot=no
@@ -3641,7 +3722,9 @@ AC_CACHE_CHECK(__stack_chk_fail in target C library,
     case "$target" in
        *-*-linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu)
       if test x$host != x$target || test "x$TARGET_SYSTEM_ROOT" != x; then
-	if test "x$with_sysroot" = x; then
+	if test "x$with_headers" != x; then
+	  glibc_header_dir=$with_headers
+	elif test "x$with_sysroot" = x; then
 	  glibc_header_dir="${exec_prefix}/${target_noncanonical}/sys-include"
 	elif test "x$with_build_sysroot" != "x"; then
 	  glibc_header_dir="${with_build_sysroot}/usr/include"
@@ -3653,6 +3736,9 @@ AC_CACHE_CHECK(__stack_chk_fail in target C library,
       else
 	glibc_header_dir=/usr/include
       fi
+      if test "x$enable_libssp" = "xno"; then
+	gcc_cv_libc_provides_ssp=yes
+      fi
       # glibc 2.4 and later provides __stack_chk_fail and
       # either __stack_chk_guard, or TLS access to stack guard canary.
       if test -f $glibc_header_dir/features.h \
@@ -3922,8 +4008,8 @@ done
 rm -f Make-hooks
 touch Make-hooks
 target_list="all.cross start.encap rest.encap tags \
-	install-common install-man install-info install-pdf dvi pdf \
-	html uninstall info man srcextra srcman srcinfo \
+	install-common install-man install-info install-pdf install-html dvi \
+	pdf html uninstall info man srcextra srcman srcinfo \
 	mostlyclean clean distclean maintainer-clean"
 
 for t in $target_list
@@ -3997,6 +4083,16 @@ htmldir="\${prefix}/$with_htmldir",
 htmldir='$(docdir)')
 AC_SUBST(htmldir)
 
+AC_ARG_ENABLE([poison-system-directories],
+	      AS_HELP_STRING([--enable-poison-system-directories],
+			     [warn for use of native system header directories]),,
+	      [enable_poison_system_directories=no])
+if test "x${enable_poison_system_directories}" = "xyes"; then
+  AC_DEFINE([ENABLE_POISON_SYSTEM_DIRECTORIES],
+	    [1],
+	    [Define to warn for use of native system header directories])
+fi
+
 # Substitute configuration variables
 AC_SUBST(subdirs)
 AC_SUBST(srcdir)
@@ -4016,6 +4112,9 @@ AC_SUBST(check_languages)
 AC_SUBST(cpp_install_dir)
 AC_SUBST(xmake_file)
 AC_SUBST(tmake_file)
+AC_SUBST(TM_ENDIAN_CONFIG)
+AC_SUBST(TM_MULTILIB_CONFIG)
+AC_SUBST(TM_MULTILIB_EXCEPTIONS_CONFIG)
 AC_SUBST(extra_gcc_objs)
 AC_SUBST(extra_headers_list)
 AC_SUBST(extra_objs)
diff --git a/gcc/cp/Make-lang.in b/gcc/cp/Make-lang.in
index 626a63e16..f5c8d7b0c 100644
--- a/gcc/cp/Make-lang.in
+++ b/gcc/cp/Make-lang.in
@@ -24,7 +24,7 @@
 #
 # foo.all.cross, foo.start.encap, foo.rest.encap,
 # foo.install-common, foo.install-man, foo.install-info, foo.install-pdf,
-# foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
+# foo.install-html, foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
 # foo.mostlyclean, foo.clean, foo.distclean,
 # foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4
 #
@@ -120,6 +120,7 @@ c++.install-info:
 c++.dvi:
 c++.pdf:
 c++.install-pdf:
+c++.install-html:
 c++.html:
 c++.srcinfo:
 c++.srcextra:
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index 2d41cd575..0b7047d02 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -6136,7 +6136,7 @@ resolve_address_of_overloaded_function (tree target_type,
       if (flags & tf_error)
 	{
 	  error ("no matches converting function %qD to type %q#T",
-		 DECL_NAME (OVL_FUNCTION (overload)),
+		 DECL_NAME (OVL_CURRENT (overload)),
 		 target_type);
 
 	  /* print_candidates expects a chain with the functions in
@@ -6299,13 +6299,8 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)
      dependent on overload resolution.  */
   gcc_assert (TREE_CODE (rhs) == ADDR_EXPR
 	      || TREE_CODE (rhs) == COMPONENT_REF
-	      || TREE_CODE (rhs) == COMPOUND_EXPR
-	      || really_overloaded_fn (rhs));
-
-  /* We don't overwrite rhs if it is an overloaded function.
-     Copying it would destroy the tree link.  */
-  if (TREE_CODE (rhs) != OVERLOAD)
-    rhs = copy_node (rhs);
+	      || really_overloaded_fn (rhs)
+	      || (flag_ms_extensions && TREE_CODE (rhs) == FUNCTION_DECL));
 
   /* This should really only be used when attempting to distinguish
      what sort of a pointer to function we have.  For now, any
@@ -6357,19 +6352,6 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)
 						/*explicit_targs=*/NULL_TREE,
 						access_path);
 
-    case COMPOUND_EXPR:
-      TREE_OPERAND (rhs, 0)
-	= instantiate_type (lhstype, TREE_OPERAND (rhs, 0), flags);
-      if (TREE_OPERAND (rhs, 0) == error_mark_node)
-	return error_mark_node;
-      TREE_OPERAND (rhs, 1)
-	= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);
-      if (TREE_OPERAND (rhs, 1) == error_mark_node)
-	return error_mark_node;
-
-      TREE_TYPE (rhs) = lhstype;
-      return rhs;
-
     case ADDR_EXPR:
     {
       if (PTRMEM_OK_P (rhs))
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index 7b244026a..a386aa27b 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -43,9 +43,6 @@ along with GCC; see the file COPYING3.  If not see
 #else
 #define ATTRIBUTE_GCC_CXXDIAG(m, n) ATTRIBUTE_NONNULL(m)
 #endif
-extern void cp_cpp_error			(cpp_reader *, int,
-						 const char *, va_list *)
-     ATTRIBUTE_GCC_CXXDIAG(3,0);
 #ifdef GCC_TOPLEV_H
 #error \
 In order for the format checking to accept the C++ front end diagnostic \
@@ -4620,6 +4617,8 @@ extern tree build_non_dependent_args		(tree);
 extern bool reregister_specialization		(tree, tree, tree);
 extern tree fold_non_dependent_expr		(tree);
 extern bool explicit_class_specialization_p     (tree);
+extern int push_tinst_level                     (tree);
+extern void pop_tinst_level                     (void);
 extern struct tinst_level *outermost_tinst_level(void);
 extern bool parameter_of_template_p		(tree, tree);
 
diff --git a/gcc/cp/cvt.c b/gcc/cp/cvt.c
index 1e45dc711..c266fd874 100644
--- a/gcc/cp/cvt.c
+++ b/gcc/cp/cvt.c
@@ -581,6 +581,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)
   tree e = expr;
   enum tree_code code = TREE_CODE (type);
   const char *invalid_conv_diag;
+  tree e1;
 
   if (error_operand_p (e) || type == error_mark_node)
     return error_mark_node;
@@ -629,6 +630,10 @@ ocp_convert (tree type, tree expr, int convtype, int flags)
 	}
     }
 
+  e1 = targetm.convert_to_type (type, e);
+  if (e1)
+    return e1;
+
   if (code == VOID_TYPE && (convtype & CONV_STATIC))
     {
       e = convert_to_void (e, /*implicit=*/NULL, tf_warning_or_error);
@@ -1231,11 +1236,18 @@ build_expr_type_conversion (int desires, tree expr, bool complain)
 tree
 type_promotes_to (tree type)
 {
+  tree promoted_type;
+
   if (type == error_mark_node)
     return error_mark_node;
 
   type = TYPE_MAIN_VARIANT (type);
 
+  /* Check for promotions of target-defined types first.  */
+  promoted_type = targetm.promoted_type (type);
+  if (promoted_type)
+    return promoted_type;
+
   /* bool always promotes to int (not unsigned), even if it's the same
      size.  */
   if (type == boolean_type_node)
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 5b05d5627..1a2a35fa4 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -2068,6 +2068,10 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)
       SET_DECL_INIT_PRIORITY (olddecl, DECL_INIT_PRIORITY (newdecl));
       DECL_HAS_INIT_PRIORITY_P (olddecl) = 1;
     }
+  /* Likewise for DECL_USER_ALIGN and DECL_PACKED.  */
+  DECL_USER_ALIGN (olddecl) = DECL_USER_ALIGN (newdecl);
+  if (TREE_CODE (newdecl) == FIELD_DECL)
+    DECL_PACKED (olddecl) = DECL_PACKED (newdecl);
 
   /* The DECL_LANG_SPECIFIC information in OLDDECL will be replaced
      with that from NEWDECL below.  */
@@ -4510,7 +4514,7 @@ maybe_deduce_size_from_array_init (tree decl, tree init)
 
       cp_apply_type_quals_to_decl (cp_type_quals (TREE_TYPE (decl)), decl);
 
-      layout_decl (decl, 0);
+      relayout_decl (decl);
     }
 }
 
@@ -7624,6 +7628,7 @@ grokdeclarator (const cp_declarator *declarator,
   bool type_was_error_mark_node = false;
   bool parameter_pack_p = declarator? declarator->parameter_pack_p : false;
   bool template_type_arg = false;
+  const char *errmsg;
 
   signed_p = declspecs->specs[(int)ds_signed];
   unsigned_p = declspecs->specs[(int)ds_unsigned];
@@ -8302,6 +8307,12 @@ grokdeclarator (const cp_declarator *declarator,
 		   decl, but to its return type.  */
 		type_quals = TYPE_UNQUALIFIED;
 	      }
+	    errmsg = targetm.invalid_return_type (type);
+	    if (errmsg)
+	      {
+		error (errmsg);
+		type = integer_type_node;
+	      }
 
 	    /* Error about some types functions can't return.  */
 
@@ -8872,8 +8883,13 @@ grokdeclarator (const cp_declarator *declarator,
 
 	  /* Replace the anonymous name with the real name everywhere.  */
 	  for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))
-	    if (TYPE_NAME (t) == oldname)
-	      TYPE_NAME (t) = decl;
+	    {
+	      if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))
+		{
+		  debug_hooks->set_name (t, decl);
+		  TYPE_NAME (t) = decl;
+		}
+	    }
 
 	  if (TYPE_LANG_SPECIFIC (type))
 	    TYPE_WAS_ANONYMOUS (type) = 1;
@@ -9709,6 +9725,7 @@ grokparms (tree parmlist, tree *parms)
       tree type = NULL_TREE;
       tree init = TREE_PURPOSE (parm);
       tree decl = TREE_VALUE (parm);
+      const char *errmsg;
 
       if (parm == void_list_node)
 	break;
@@ -9742,6 +9759,14 @@ grokparms (tree parmlist, tree *parms)
 	  init = NULL_TREE;
 	}
 
+      if (type != error_mark_node
+	  && (errmsg = targetm.invalid_parameter_type (type)))
+	{
+	  error (errmsg);
+	  type = error_mark_node;
+	  TREE_TYPE (decl) = error_mark_node;
+	}
+
       if (type != error_mark_node)
 	{
 	  if (deprecated_state != DEPRECATED_SUPPRESS)
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 744209e87..9933ad0ed 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -1724,6 +1724,10 @@ decl_needed_p (tree decl)
       || (DECL_ASSEMBLER_NAME_SET_P (decl)
 	  && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))
       return true;
+  /* Functions marked "dllexport" must be emitted so that they are
+     visible to other DLLs.  */
+  if (lookup_attribute ("dllexport", DECL_ATTRIBUTES (decl)))
+    return true;
   /* Otherwise, DECL does not need to be emitted -- yet.  A subsequent
      reference to DECL might cause it to be emitted later.  */
   return false;
@@ -3814,6 +3818,15 @@ mark_used (tree decl)
     }
 
   TREE_USED (decl) = 1;
+  if (current_function_decl != NULL_TREE
+      && (TREE_CODE (decl) == VAR_DECL
+	  || TREE_CODE (decl) == PARM_DECL
+	  || TREE_CODE (decl) == FUNCTION_DECL))
+    {
+      tree context = decl_function_context (decl);
+      if (context != NULL_TREE && context != current_function_decl)
+	DECL_NONLOCAL (decl) = 1;
+    }
   if (DECL_CLONED_FUNCTION_P (decl))
     TREE_USED (DECL_CLONED_FUNCTION (decl)) = 1;
   if (TREE_CODE (decl) == FUNCTION_DECL
diff --git a/gcc/cp/error.c b/gcc/cp/error.c
index 5d60f67ba..e15f78140 100644
--- a/gcc/cp/error.c
+++ b/gcc/cp/error.c
@@ -2672,39 +2672,6 @@ cp_printer (pretty_printer *pp, text_info *text, const char *spec,
 #undef next_int
 }
 
-/* Callback from cpp_error for PFILE to print diagnostics arising from
-   interpreting strings.  The diagnostic is of type LEVEL; MSG is the
-   translated message and AP the arguments.  */
-
-void
-cp_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level,
-	      const char *msg, va_list *ap)
-{
-  diagnostic_info diagnostic;
-  diagnostic_t dlevel;
-  switch (level)
-    {
-    case CPP_DL_WARNING:
-    case CPP_DL_WARNING_SYSHDR:
-      dlevel = DK_WARNING;
-      break;
-    case CPP_DL_PEDWARN:
-      dlevel = DK_PEDWARN;
-      break;
-    case CPP_DL_ERROR:
-      dlevel = DK_ERROR;
-      break;
-    case CPP_DL_ICE:
-      dlevel = DK_ICE;
-      break;
-    default:
-      gcc_unreachable ();
-    }
-  diagnostic_set_info_translated (&diagnostic, msg, ap,
-				  input_location, dlevel);
-  report_diagnostic (&diagnostic);
-}
-
 /* Warn about the use of C++0x features when appropriate.  */
 void
 maybe_warn_cpp0x (const char* str)
diff --git a/gcc/cp/except.c b/gcc/cp/except.c
index 7813d0874..57d3bf307 100644
--- a/gcc/cp/except.c
+++ b/gcc/cp/except.c
@@ -146,14 +146,26 @@ eh_type_info (tree type)
 static tree
 build_eh_type_type (tree type)
 {
-  tree exp = eh_type_info (type);
+  bool is_ref = TREE_CODE (type) == REFERENCE_TYPE;
+  tree exp;
+  
+  if (is_ref)
+    type = TREE_TYPE (type);
+  
+  exp = eh_type_info (type);
 
   if (!exp)
     return NULL;
 
   mark_used (exp);
 
-  return convert (ptr_type_node, build_address (exp));
+  exp = build_address (exp);
+  
+  if (is_ref)
+    exp = targetm.cxx.ttype_ref_encode (exp);
+
+  exp = convert (ptr_type_node, exp);
+  return exp;
 }
 
 tree
@@ -495,6 +507,16 @@ expand_start_catch_block (tree decl)
       initialize_handler_parm (decl, exp);
     }
 
+  /* Preserve the reference type on the exception, as this affects
+     derived-to-base conversions in catch matching.  Only do this when
+     the ABI supports it, as originally this case was (incorrectly)
+     treated just as catching a pointer-to-class by value. */
+  if (targetm.cxx.ttype_ref_encode
+      && decl && TREE_CODE (type) == POINTER_TYPE
+      && CLASS_TYPE_P (TREE_TYPE (type))
+      && TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)
+    type = build_reference_type (type);
+
   return type;
 }
 
@@ -538,10 +560,20 @@ finish_eh_spec_block (tree raw_raises, tree eh_spec_block)
        raw_raises && TREE_VALUE (raw_raises);
        raw_raises = TREE_CHAIN (raw_raises))
     {
-      tree type = prepare_eh_type (TREE_VALUE (raw_raises));
+      tree orig_type = TREE_VALUE (raw_raises);
+      tree type = prepare_eh_type (orig_type);
       tree tinfo = eh_type_info (type);
 
       mark_used (tinfo);
+      /* Preserve the reference type on the exception, as this affects
+	 derived-to-base conversions in catch matching.  Only do this when
+	 the ABI supports it, as originally this case was (incorrectly)
+	 treated just as catching a pointer-to-class by value. */
+      if (targetm.cxx.ttype_ref_encode
+	  && TREE_CODE (orig_type) == REFERENCE_TYPE
+	  && TREE_CODE (type) == POINTER_TYPE
+	  && CLASS_TYPE_P (TREE_TYPE (type)))
+	type = build_reference_type (type);
       raises = tree_cons (NULL_TREE, type, raises);
     }
 
@@ -956,24 +988,40 @@ nothrow_libfn_p (const_tree fn)
 static int
 can_convert_eh (tree to, tree from)
 {
-  to = non_reference (to);
-  from = non_reference (from);
+  bool to_ref = TREE_CODE (to) == REFERENCE_TYPE;
+  int depth = to_ref;
+  bool outer_const = true;
 
-  if (TREE_CODE (to) == POINTER_TYPE && TREE_CODE (from) == POINTER_TYPE)
+  if (to_ref)
+    to = TREE_TYPE (to);
+  from = non_reference (from);
+  
+  while (TREE_CODE (to) == POINTER_TYPE && TREE_CODE (from) == POINTER_TYPE)
     {
+      unsigned to_quals, from_quals;
+      
+      depth++;
+      
       to = TREE_TYPE (to);
       from = TREE_TYPE (from);
+      to_quals = TYPE_QUALS (to);
+      from_quals = TYPE_QUALS (from);
 
-      if (! at_least_as_qualified_p (to, from))
+      if ((from_quals & ~to_quals)
+	  || (!outer_const && to_quals & ~from_quals))
 	return 0;
-
-      if (TREE_CODE (to) == VOID_TYPE)
-	return 1;
-
-      /* Else fall through.  */
+	
+      if (!(to_quals & TYPE_QUAL_CONST))
+	outer_const = false;
     }
 
-  if (CLASS_TYPE_P (to) && CLASS_TYPE_P (from)
+  if (same_type_ignoring_top_level_qualifiers_p (from, to))
+    return 1;
+
+  if (depth == to_ref + 1 && TREE_CODE (to) == VOID_TYPE)
+    return 1;
+  
+  if (depth < 2 && CLASS_TYPE_P (to) && CLASS_TYPE_P (from)
       && PUBLICLY_UNIQUELY_DERIVED_P (to, from))
     return 1;
 
diff --git a/gcc/cp/mangle.c b/gcc/cp/mangle.c
index ee32239a9..374a13a95 100644
--- a/gcc/cp/mangle.c
+++ b/gcc/cp/mangle.c
@@ -2780,6 +2780,22 @@ static tree
 mangle_decl_string (const tree decl)
 {
   tree result;
+  location_t saved_loc = input_location;
+  tree saved_fn = NULL_TREE;
+  bool template_p = false;
+
+  if (DECL_LANG_SPECIFIC (decl) && DECL_USE_TEMPLATE (decl))
+    {
+      struct tinst_level *tl = current_instantiation ();
+      if (!tl || tl->decl != decl)
+	{
+	  template_p = true;
+	  saved_fn = current_function_decl;
+	  push_tinst_level (decl);
+	  current_function_decl = NULL_TREE;
+	}
+    }
+  input_location = DECL_SOURCE_LOCATION (decl);
 
   start_mangling (decl);
 
@@ -2792,6 +2808,14 @@ mangle_decl_string (const tree decl)
   if (DEBUG_MANGLE)
     fprintf (stderr, "mangle_decl_string = '%s'\n\n",
 	     IDENTIFIER_POINTER (result));
+
+  if (template_p)
+    {
+      pop_tinst_level ();
+      current_function_decl = saved_fn;
+    }
+  input_location = saved_loc;
+
   return result;
 }
 
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index f219b1b59..28aab4f08 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -309,8 +309,7 @@ cp_lexer_new_main (void)
 
   /* Subsequent preprocessor diagnostics should use compiler
      diagnostic functions to get the compiler source location.  */
-  cpp_get_options (parse_in)->client_diagnostic = true;
-  cpp_get_callbacks (parse_in)->error = cp_cpp_error;
+  done_lexing = true;
 
   gcc_assert (lexer->next_token->type != CPP_PURGED);
   return lexer;
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 45db33e07..d41e26410 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -105,8 +105,6 @@ static int try_one_overload (tree, tree, tree, tree, tree,
 			     unification_kind_t, int, bool);
 static int unify (tree, tree, tree, tree, int);
 static void add_pending_template (tree);
-static int push_tinst_level (tree);
-static void pop_tinst_level (void);
 static tree reopen_tinst_level (struct tinst_level *);
 static tree tsubst_initializer_list (tree, tree);
 static tree get_class_bindings (tree, tree, tree);
@@ -6433,7 +6431,7 @@ static int last_template_error_tick;
 /* We're starting to instantiate D; record the template instantiation context
    for diagnostics and to restore it later.  */
 
-static int
+int
 push_tinst_level (tree d)
 {
   struct tinst_level *new_level;
@@ -6476,7 +6474,7 @@ push_tinst_level (tree d)
 /* We're done instantiating this template; return to the instantiation
    context.  */
 
-static void
+void
 pop_tinst_level (void)
 {
   /* Restore the filename and line number stashed away when we started
diff --git a/gcc/cp/rtti.c b/gcc/cp/rtti.c
index 1d5da6714..c77a18883 100644
--- a/gcc/cp/rtti.c
+++ b/gcc/cp/rtti.c
@@ -393,6 +393,7 @@ get_tinfo_decl (tree type)
 	return d;
     }
 
+  gcc_assert (TREE_CODE (type) != REFERENCE_TYPE);
   name = mangle_typeinfo_for_type (type);
 
   d = IDENTIFIER_GLOBAL_VALUE (name);
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index 5a16ac5c8..f5518fda6 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -1120,7 +1120,11 @@ finish_handler_parms (tree decl, tree handler)
     type = expand_start_catch_block (decl);
   HANDLER_TYPE (handler) = type;
   if (!processing_template_decl && type)
-    mark_used (eh_type_info (type));
+    {
+      if (TREE_CODE (type) == REFERENCE_TYPE)
+	type = TREE_TYPE (type);
+      mark_used (eh_type_info (type));
+    }
 }
 
 /* Finish a handler, which may be given by HANDLER.  The BLOCKs are
@@ -3248,8 +3252,10 @@ expand_or_defer_fn (tree fn)
 
       /* If the user wants us to keep all inline functions, then mark
 	 this function as needed so that finish_file will make sure to
-	 output it later.  */
-      if (flag_keep_inline_functions && DECL_DECLARED_INLINE_P (fn))
+	 output it later.  Similarly, all dllexport'd functions must
+	 be emitted; there may be callers in other DLLs.  */
+      if ((flag_keep_inline_functions && DECL_DECLARED_INLINE_P (fn))
+	  || lookup_attribute ("dllexport", DECL_ATTRIBUTES (fn)))
 	mark_needed (fn);
     }
 
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 1c0689eb3..7d259012c 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -1707,10 +1707,14 @@ decay_conversion (tree exp)
 tree
 default_conversion (tree exp)
 {
+  /* Check for target-specific promotions.  */
+  tree promoted_type = targetm.promoted_type (TREE_TYPE (exp));
+  if (promoted_type)
+    exp = cp_convert (promoted_type, exp);
   /* Perform the integral promotions first so that bitfield
      expressions (which may promote to "int", even if the bitfield is
      declared "unsigned") are promoted correctly.  */
-  if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (exp)))
+  else if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (exp)))
     exp = perform_integral_promotions (exp);
   /* Perform the other conversions.  */
   exp = decay_conversion (exp);
@@ -3378,7 +3382,6 @@ cp_build_binary_op (location_t location,
 
   /* If an error was already reported for one of the arguments,
      avoid reporting another error.  */
-
   if (code0 == ERROR_MARK || code1 == ERROR_MARK)
     return error_mark_node;
 
@@ -3389,6 +3392,25 @@ cp_build_binary_op (location_t location,
       return error_mark_node;
     }
 
+  /* Issue warnings about peculiar, but valid, uses of NULL.  */
+  if ((orig_op0 == null_node || orig_op1 == null_node)
+      /* It's reasonable to use pointer values as operands of &&
+	 and ||, so NULL is no exception.  */
+      && code != TRUTH_ANDIF_EXPR && code != TRUTH_ORIF_EXPR 
+      && ( /* Both are NULL (or 0) and the operation was not a
+	      comparison or a pointer subtraction.  */
+	  (null_ptr_cst_p (orig_op0) && null_ptr_cst_p (orig_op1) 
+	   && code != EQ_EXPR && code != NE_EXPR && code != MINUS_EXPR) 
+	  /* Or if one of OP0 or OP1 is neither a pointer nor NULL.  */
+	  || (!null_ptr_cst_p (orig_op0)
+	      && !TYPE_PTR_P (type0) && !TYPE_PTR_TO_MEMBER_P (type0))
+	  || (!null_ptr_cst_p (orig_op1) 
+	      && !TYPE_PTR_P (type1) && !TYPE_PTR_TO_MEMBER_P (type1)))
+      && (complain & tf_warning))
+    /* Some sort of arithmetic operation involving NULL was
+       performed.  */
+    warning (OPT_Wpointer_arith, "NULL used in arithmetic");
+
   switch (code)
     {
     case MINUS_EXPR:
@@ -3979,25 +4001,6 @@ cp_build_binary_op (location_t location,
 	}
     }
 
-  /* Issue warnings about peculiar, but valid, uses of NULL.  */
-  if ((orig_op0 == null_node || orig_op1 == null_node)
-      /* It's reasonable to use pointer values as operands of &&
-	 and ||, so NULL is no exception.  */
-      && code != TRUTH_ANDIF_EXPR && code != TRUTH_ORIF_EXPR 
-      && ( /* Both are NULL (or 0) and the operation was not a comparison.  */
-	  (null_ptr_cst_p (orig_op0) && null_ptr_cst_p (orig_op1) 
-	   && code != EQ_EXPR && code != NE_EXPR) 
-	  /* Or if one of OP0 or OP1 is neither a pointer nor NULL.  */
-	  || (!null_ptr_cst_p (orig_op0) && TREE_CODE (TREE_TYPE (op0)) != POINTER_TYPE)
-	  || (!null_ptr_cst_p (orig_op1) && TREE_CODE (TREE_TYPE (op1)) != POINTER_TYPE))
-      && (complain & tf_warning))
-    /* Some sort of arithmetic operation involving NULL was
-       performed.  Note that pointer-difference and pointer-addition
-       have already been handled above, and so we don't end up here in
-       that case.  */
-    warning (OPT_Wpointer_arith, "NULL used in arithmetic");
-  
-
   /* If CONVERTED is zero, both args will be converted to type RESULT_TYPE.
      Then the expression will be built.
      It will be given type FINAL_TYPE if that is nonzero;
@@ -5024,6 +5027,12 @@ cp_build_compound_expr (tree lhs, tree rhs, tsubst_flags_t complain)
       return rhs;
     }
 
+  if (type_unknown_p (rhs))
+    {
+      error ("no context to resolve type of %qE", rhs);
+      return error_mark_node;
+    }
+  
   return build2 (COMPOUND_EXPR, TREE_TYPE (rhs), lhs, rhs);
 }
 
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index 021f11f3f..3ac21948f 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -451,13 +451,15 @@ cxx_incomplete_type_error (const_tree value, const_tree type)
    expression to which INIT should be assigned.  INIT is a CONSTRUCTOR.  */
 
 static void
-split_nonconstant_init_1 (tree dest, tree init)
+split_nonconstant_init_1 (tree dest, tree *initp)
 {
   unsigned HOST_WIDE_INT idx;
+  tree init = *initp;
   tree field_index, value;
   tree type = TREE_TYPE (dest);
   tree inner_type = NULL;
   bool array_type_p = false;
+  HOST_WIDE_INT num_type_elements, num_initialized_elements;
 
   switch (TREE_CODE (type))
     {
@@ -469,6 +471,7 @@ split_nonconstant_init_1 (tree dest, tree init)
     case RECORD_TYPE:
     case UNION_TYPE:
     case QUAL_UNION_TYPE:
+      num_initialized_elements = 0;
       FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), idx,
 				field_index, value)
 	{
@@ -491,12 +494,13 @@ split_nonconstant_init_1 (tree dest, tree init)
 		sub = build3 (COMPONENT_REF, inner_type, dest, field_index,
 			      NULL_TREE);
 
-	      split_nonconstant_init_1 (sub, value);
+	      split_nonconstant_init_1 (sub, &value);
 	    }
 	  else if (!initializer_constant_valid_p (value, inner_type))
 	    {
 	      tree code;
 	      tree sub;
+	      HOST_WIDE_INT inner_elements;
 
 	      /* FIXME: Ordered removal is O(1) so the whole function is
 		 worst-case quadratic. This could be fixed using an aside
@@ -519,9 +523,22 @@ split_nonconstant_init_1 (tree dest, tree init)
 	      code = build2 (INIT_EXPR, inner_type, sub, value);
 	      code = build_stmt (EXPR_STMT, code);
 	      add_stmt (code);
+
+	      inner_elements = count_type_elements (inner_type, true);
+	      if (inner_elements < 0)
+		num_initialized_elements = -1;
+	      else if (num_initialized_elements >= 0)
+		num_initialized_elements += inner_elements;
 	      continue;
 	    }
 	}
+
+      num_type_elements = count_type_elements (type, true);
+      /* If all elements of the initializer are non-constant and
+	 have been split out, we don't need the empty CONSTRUCTOR.  */
+      if (num_type_elements > 0
+	  && num_type_elements == num_initialized_elements)
+	*initp = NULL;
       break;
 
     case VECTOR_TYPE:
@@ -557,7 +574,7 @@ split_nonconstant_init (tree dest, tree init)
   if (TREE_CODE (init) == CONSTRUCTOR)
     {
       code = push_stmt_list ();
-      split_nonconstant_init_1 (dest, init);
+      split_nonconstant_init_1 (dest, &init);
       code = pop_stmt_list (code);
       DECL_INITIAL (dest) = init;
       TREE_READONLY (dest) = 0;
diff --git a/gcc/cse.c b/gcc/cse.c
index c16181e37..4e4c222e0 100644
--- a/gcc/cse.c
+++ b/gcc/cse.c
@@ -5754,6 +5754,11 @@ cse_process_notes_1 (rtx x, rtx object, bool *changed)
       validate_change (object, &XEXP (x, i),
 		       cse_process_notes (XEXP (x, i), object, changed), 0);
 
+  /* Rebuild a PLUS expression in canonical form if the first operand
+     ends up as a constant.  */
+  if (code == PLUS && GET_CODE (XEXP (x, 0)) == CONST_INT)
+    return plus_constant (XEXP(x, 1), INTVAL (XEXP (x, 0)));
+
   return x;
 }
 
diff --git a/gcc/dbxout.c b/gcc/dbxout.c
index 9fda9712d..ec3c15c71 100644
--- a/gcc/dbxout.c
+++ b/gcc/dbxout.c
@@ -377,6 +377,7 @@ const struct gcc_debug_hooks dbx_debug_hooks =
   dbxout_handle_pch,		         /* handle_pch */
   debug_nothing_rtx,		         /* var_location */
   debug_nothing_void,                    /* switch_text_section */
+  debug_nothing_tree_tree,		 /* set_name */
   0                                      /* start_end_main_source_file */
 };
 #endif /* DBX_DEBUGGING_INFO  */
@@ -410,6 +411,7 @@ const struct gcc_debug_hooks xcoff_debug_hooks =
   dbxout_handle_pch,		         /* handle_pch */
   debug_nothing_rtx,		         /* var_location */
   debug_nothing_void,                    /* switch_text_section */
+  debug_nothing_tree_tree,	         /* set_name */
   0                                      /* start_end_main_source_file */
 };
 #endif /* XCOFF_DEBUGGING_INFO  */
diff --git a/gcc/debug.c b/gcc/debug.c
index 26d6b7b5d..f47d2955b 100644
--- a/gcc/debug.c
+++ b/gcc/debug.c
@@ -51,6 +51,7 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =
   debug_nothing_int,		         /* handle_pch */
   debug_nothing_rtx,		         /* var_location */
   debug_nothing_void,                    /* switch_text_section */
+  debug_nothing_tree_tree,		 /* set_name */
   0                                      /* start_end_main_source_file */
 };
 
@@ -67,6 +68,12 @@ debug_nothing_tree (tree decl ATTRIBUTE_UNUSED)
 {
 }
 
+void
+debug_nothing_tree_tree (tree t1 ATTRIBUTE_UNUSED,
+			 tree t2 ATTRIBUTE_UNUSED)
+{
+}
+
 void
 debug_nothing_tree_tree_tree_bool (tree t1 ATTRIBUTE_UNUSED,
 				   tree t2 ATTRIBUTE_UNUSED,
diff --git a/gcc/debug.h b/gcc/debug.h
index e6235cfed..799849f2e 100644
--- a/gcc/debug.h
+++ b/gcc/debug.h
@@ -130,6 +130,10 @@ struct gcc_debug_hooks
      text sections.  */
   void (* switch_text_section) (void);
 
+  /* Called from grokdeclarator.  Replaces the anonymous name with the
+     type name.  */
+  void (* set_name) (tree, tree);
+
   /* This is 1 if the debug writer wants to see start and end commands for the
      main source files, and 0 otherwise.  */
   int start_end_main_source_file;
@@ -144,6 +148,7 @@ extern void debug_nothing_int_charstar (unsigned int, const char *);
 extern void debug_nothing_int (unsigned int);
 extern void debug_nothing_int_int (unsigned int, unsigned int);
 extern void debug_nothing_tree (tree);
+extern void debug_nothing_tree_tree (tree, tree);
 extern void debug_nothing_tree_int (tree, int);
 extern void debug_nothing_tree_tree_tree_bool (tree, tree, tree, bool);
 extern bool debug_true_const_tree (const_tree);
diff --git a/gcc/defaults.h b/gcc/defaults.h
index dcf29fdf5..187425331 100644
--- a/gcc/defaults.h
+++ b/gcc/defaults.h
@@ -501,6 +501,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define PIC_OFFSET_TABLE_REGNUM INVALID_REGNUM
 #endif
 
+#ifndef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
+#define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED 0
+#endif
+
 #ifndef TARGET_DLLIMPORT_DECL_ATTRIBUTES
 #define TARGET_DLLIMPORT_DECL_ATTRIBUTES 0
 #endif
@@ -902,7 +906,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 /* On most machines, the CFA coincides with the first incoming parm.  */
 #ifndef ARG_POINTER_CFA_OFFSET
-#define ARG_POINTER_CFA_OFFSET(FNDECL) FIRST_PARM_OFFSET (FNDECL)
+#define ARG_POINTER_CFA_OFFSET(FNDECL) \
+  (FIRST_PARM_OFFSET (FNDECL) + crtl->args.pretend_args_size)
 #endif
 
 /* On most machines, we use the CFA as DW_AT_frame_base.  */
diff --git a/gcc/df-scan.c b/gcc/df-scan.c
index aa632cbda..eb3e24e7f 100644
--- a/gcc/df-scan.c
+++ b/gcc/df-scan.c
@@ -3952,14 +3952,13 @@ df_get_exit_block_use_set (bitmap exit_block_uses)
 #endif
     }
 
-#ifndef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
   /* Many architectures have a GP register even without flag_pic.
      Assume the pic register is not in use, or will be handled by
      other means, if it is not fixed.  */
-  if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM
+  if (!PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
+      && (unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM
       && fixed_regs[PIC_OFFSET_TABLE_REGNUM])
     bitmap_set_bit (exit_block_uses, PIC_OFFSET_TABLE_REGNUM);
-#endif
   
   /* Mark all global registers, and all registers used by the
      epilogue as being live at the end of the function since they
diff --git a/gcc/diagnostic.c b/gcc/diagnostic.c
index f323f363a..62f4fae32 100644
--- a/gcc/diagnostic.c
+++ b/gcc/diagnostic.c
@@ -126,6 +126,7 @@ diagnostic_set_info_translated (diagnostic_info *diagnostic, const char *msg,
   diagnostic->message.args_ptr = args;
   diagnostic->message.format_spec = msg;
   diagnostic->location = location;
+  diagnostic->override_column = 0;
   diagnostic->kind = kind;
   diagnostic->option_index = 0;
 }
@@ -153,6 +154,8 @@ diagnostic_build_prefix (diagnostic_info *diagnostic)
   };
   const char *text = _(diagnostic_kind_text[diagnostic->kind]);
   expanded_location s = expand_location (diagnostic->location);
+  if (diagnostic->override_column)
+    s.column = diagnostic->override_column;
   gcc_assert (diagnostic->kind < DK_LAST_DIAGNOSTIC_KIND);
 
   return
diff --git a/gcc/diagnostic.h b/gcc/diagnostic.h
index 19bc5e9c8..8c2e540ef 100644
--- a/gcc/diagnostic.h
+++ b/gcc/diagnostic.h
@@ -41,6 +41,7 @@ typedef struct diagnostic_info
 {
   text_info message;
   location_t location;
+  unsigned int override_column;
   /* TREE_BLOCK if the diagnostic is to be reported in some inline
      function inlined into other function, otherwise NULL.  */
   tree abstract_origin;
@@ -185,6 +186,10 @@ extern diagnostic_context *global_dc;
 
 #define report_diagnostic(D) diagnostic_report_diagnostic (global_dc, D)
 
+/* Override the column number to be used for reporting a
+   diagnostic.  */
+#define diagnostic_override_column(DI, COL) (DI)->override_column = (COL)
+
 /* Diagnostic related functions.  */
 extern void diagnostic_initialize (diagnostic_context *);
 extern void diagnostic_report_current_module (diagnostic_context *);
diff --git a/gcc/doc/arm-neon-intrinsics.texi b/gcc/doc/arm-neon-intrinsics.texi
index c35662c01..a75e5821e 100644
--- a/gcc/doc/arm-neon-intrinsics.texi
+++ b/gcc/doc/arm-neon-intrinsics.texi
@@ -43,20 +43,18 @@
 
 
 @itemize @bullet
-@item uint64x1_t vadd_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vadd.i64 @var{d0}, @var{d0}, @var{d0}}
+@item float32x2_t vadd_f32 (float32x2_t, float32x2_t)
+@*@emph{Form of expected instruction(s):} @code{vadd.f32 @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
-@item int64x1_t vadd_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vadd.i64 @var{d0}, @var{d0}, @var{d0}}
+@item uint64x1_t vadd_u64 (uint64x1_t, uint64x1_t)
 @end itemize
 
 
 @itemize @bullet
-@item float32x2_t vadd_f32 (float32x2_t, float32x2_t)
-@*@emph{Form of expected instruction(s):} @code{vadd.f32 @var{d0}, @var{d0}, @var{d0}}
+@item int64x1_t vadd_s64 (int64x1_t, int64x1_t)
 @end itemize
 
 
@@ -1013,20 +1011,18 @@
 
 
 @itemize @bullet
-@item uint64x1_t vsub_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vsub.i64 @var{d0}, @var{d0}, @var{d0}}
+@item float32x2_t vsub_f32 (float32x2_t, float32x2_t)
+@*@emph{Form of expected instruction(s):} @code{vsub.f32 @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
-@item int64x1_t vsub_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vsub.i64 @var{d0}, @var{d0}, @var{d0}}
+@item uint64x1_t vsub_u64 (uint64x1_t, uint64x1_t)
 @end itemize
 
 
 @itemize @bullet
-@item float32x2_t vsub_f32 (float32x2_t, float32x2_t)
-@*@emph{Form of expected instruction(s):} @code{vsub.f32 @var{d0}, @var{d0}, @var{d0}}
+@item int64x1_t vsub_s64 (int64x1_t, int64x1_t)
 @end itemize
 
 
@@ -4696,7 +4692,7 @@
 
 @itemize @bullet
 @item uint32_t vget_lane_u32 (uint32x2_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov.u32 @var{r0}, @var{d0}[@var{0}]}
+@*@emph{Form of expected instruction(s):} @code{vmov.32 @var{r0}, @var{d0}[@var{0}]}
 @end itemize
 
 
@@ -4714,7 +4710,7 @@
 
 @itemize @bullet
 @item int32_t vget_lane_s32 (int32x2_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov.s32 @var{r0}, @var{d0}[@var{0}]}
+@*@emph{Form of expected instruction(s):} @code{vmov.32 @var{r0}, @var{d0}[@var{0}]}
 @end itemize
 
 
@@ -4732,7 +4728,7 @@
 
 @itemize @bullet
 @item float32_t vget_lane_f32 (float32x2_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov.f32 @var{r0}, @var{d0}[@var{0}]}
+@*@emph{Form of expected instruction(s):} @code{vmov.32 @var{r0}, @var{d0}[@var{0}]}
 @end itemize
 
 
@@ -4750,19 +4746,17 @@
 
 @itemize @bullet
 @item uint64_t vget_lane_u64 (uint64x1_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{r0}, @var{r0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64_t vget_lane_s64 (int64x1_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{r0}, @var{r0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item uint32_t vgetq_lane_u32 (uint32x4_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov.u32 @var{r0}, @var{d0}[@var{0}]}
+@*@emph{Form of expected instruction(s):} @code{vmov.32 @var{r0}, @var{d0}[@var{0}]}
 @end itemize
 
 
@@ -4780,7 +4774,7 @@
 
 @itemize @bullet
 @item int32_t vgetq_lane_s32 (int32x4_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov.s32 @var{r0}, @var{d0}[@var{0}]}
+@*@emph{Form of expected instruction(s):} @code{vmov.32 @var{r0}, @var{d0}[@var{0}]}
 @end itemize
 
 
@@ -4798,7 +4792,7 @@
 
 @itemize @bullet
 @item float32_t vgetq_lane_f32 (float32x4_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov.f32 @var{r0}, @var{d0}[@var{0}]}
+@*@emph{Form of expected instruction(s):} @code{vmov.32 @var{r0}, @var{d0}[@var{0}]}
 @end itemize
 
 
@@ -4886,13 +4880,11 @@
 
 @itemize @bullet
 @item uint64x1_t vset_lane_u64 (uint64_t, uint64x1_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vset_lane_s64 (int64_t, int64x1_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
@@ -5081,13 +5073,11 @@
 
 @itemize @bullet
 @item uint64x1_t vdup_n_u64 (uint64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vdup_n_s64 (int64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
@@ -5147,13 +5137,11 @@
 
 @itemize @bullet
 @item uint64x2_t vdupq_n_u64 (uint64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x2_t vdupq_n_s64 (int64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
@@ -5213,13 +5201,11 @@
 
 @itemize @bullet
 @item uint64x1_t vmov_n_u64 (uint64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vmov_n_s64 (int64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
@@ -5279,13 +5265,11 @@
 
 @itemize @bullet
 @item uint64x2_t vmovq_n_u64 (uint64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x2_t vmovq_n_s64 (int64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
@@ -5572,32 +5556,30 @@
 
 
 @itemize @bullet
-@item uint64x1_t vget_low_u64 (uint64x2_t)
+@item float32x2_t vget_low_f32 (float32x4_t)
 @*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
-@item int64x1_t vget_low_s64 (int64x2_t)
+@item poly16x4_t vget_low_p16 (poly16x8_t)
 @*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
-@item float32x2_t vget_low_f32 (float32x4_t)
+@item poly8x8_t vget_low_p8 (poly8x16_t)
 @*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
-@item poly16x4_t vget_low_p16 (poly16x8_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{d0}}
+@item uint64x1_t vget_low_u64 (uint64x2_t)
 @end itemize
 
 
 @itemize @bullet
-@item poly8x8_t vget_low_p8 (poly8x16_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{d0}}
+@item int64x1_t vget_low_s64 (int64x2_t)
 @end itemize
 
 
@@ -9727,13 +9709,11 @@
 
 @itemize @bullet
 @item uint64x1_t vand_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vand @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vand_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vand @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
@@ -9827,13 +9807,11 @@
 
 @itemize @bullet
 @item uint64x1_t vorr_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vorr @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vorr_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vorr @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
@@ -9927,13 +9905,11 @@
 
 @itemize @bullet
 @item uint64x1_t veor_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{veor @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t veor_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{veor @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
@@ -10027,13 +10003,11 @@
 
 @itemize @bullet
 @item uint64x1_t vbic_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vbic @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vbic_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vbic @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
@@ -10127,13 +10101,11 @@
 
 @itemize @bullet
 @item uint64x1_t vorn_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vorn @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vorn_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vorn @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index e9360cf63..f28e9d8fb 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -35,6 +35,7 @@ extensions, accepted by GCC in C89 mode and in C++.
 * Long Long::           Double-word integers---@code{long long int}.
 * Complex::             Data types for complex numbers.
 * Floating Types::      Additional Floating Types.
+* Half-Precision::      Half-Precision Floating Point.
 * Decimal Float::       Decimal Floating Types. 
 * Hex Floats::          Hexadecimal floating-point constants.
 * Fixed-Point::         Fixed-Point Types.
@@ -916,6 +917,56 @@ typedef _Complex float __attribute__((mode(XC))) _Complex80;
 Not all targets support additional floating point types.  @code{__float80}
 and @code{__float128} types are supported on i386, x86_64 and ia64 targets.
 
+@node Half-Precision
+@section Half-Precision Floating Point
+@cindex half-precision floating point
+@cindex @code{__fp16} data type
+
+On ARM targets, GCC supports half-precision (16-bit) floating point via
+the @code{__fp16} type.  You must enable this type explicitly 
+with the @option{-mfp16-format} command-line option in order to use it.
+
+ARM supports two incompatible representations for half-precision
+floating-point values.  You must choose one of the representations and
+use it consistently in your program.
+
+Specifying @option{-mfp16-format=ieee} selects the IEEE 754-2008 format.
+This format can represent normalized values in the range of @math{2^{-14}} to 65504.
+There are 11 bits of significand precision, approximately 3
+decimal digits.
+
+Specifying @option{-mfp16-format=alternative} selects the ARM
+alternative format.  This representation is similar to the IEEE
+format, but does not support infinities or NaNs.  Instead, the range
+of exponents is extended, so that this format can represent normalized
+values in the range of @math{2^{-14}} to 131008.
+
+The @code{__fp16} type is a storage format only.  For purposes
+of arithmetic and other operations, @code{__fp16} values in C or C++
+expressions are automatically promoted to @code{float}.  In addition,
+you cannot declare a function with a return value or parameters 
+of type @code{__fp16}.
+
+Note that conversions from @code{double} to @code{__fp16}
+involve an intermediate conversion to @code{float}.  Because
+of rounding, this can sometimes produce a different result than a
+direct conversion.
+
+ARM provides hardware support for conversions between 
+@code{__fp16} and @code{float} values
+as an extension to VFP and NEON (Advanced SIMD).  GCC generates
+code using these hardware instructions if you compile with
+options to select an FPU that provides them; 
+for example, @option{-mfpu=neon-fp16 -mfloat-abi=softfp},
+in addition to the @option{-mfp16-format} option to select
+a half-precision format.  
+
+Language-level support for the @code{__fp16} data type is
+independent of whether GCC generates code using hardware floating-point
+instructions.  In cases where hardware support is not specified, GCC
+implements conversions between @code{__fp16} and @code{float} values
+as library calls.
+
 @node Decimal Float
 @section Decimal Floating Types
 @cindex decimal floating types
@@ -2397,7 +2448,7 @@ This attribute is ignored for R8C target.
 
 @item interrupt
 @cindex interrupt handler functions
-Use this attribute on the ARM, AVR, CRX, M32C, M32R/D, m68k,
+Use this attribute on the ARM, AVR, CRX, M32C, M32R/D, m68k, MIPS
 and Xstormy16 ports to indicate that the specified function is an
 interrupt handler.  The compiler will generate function entry and exit
 sequences suitable for use in an interrupt handler when this attribute
@@ -2420,6 +2471,42 @@ Permissible values for this parameter are: IRQ, FIQ, SWI, ABORT and UNDEF@.
 On ARMv7-M the interrupt type is ignored, and the attribute means the function
 may be called with a word aligned stack pointer.
 
+On MIPS targets, you can use the following attributes to modify the behavior
+of an interrupt handler:
+@table @code
+@item use_shadow_register_set
+@cindex @code{use_shadow_register_set} attribute
+Assume that the handler uses a shadow register set, instead of
+the main general-purpose registers.
+
+@item keep_interrupts_masked
+@cindex @code{keep_interrupts_masked} attribute
+Keep interrupts masked for the whole function.  Without this attribute,
+GCC tries to reenable interrupts for as much of the function as it can.
+
+@item use_debug_exception_return
+@cindex @code{use_debug_exception_return} attribute
+Return using the @code{deret} instruction.  Interrupt handlers that don't
+have this attribute return using @code{eret} instead.
+@end table
+
+You can use any combination of these attributes, as shown below:
+@smallexample
+void __attribute__ ((interrupt)) v0 ();
+void __attribute__ ((interrupt, use_shadow_register_set)) v1 ();
+void __attribute__ ((interrupt, keep_interrupts_masked)) v2 ();
+void __attribute__ ((interrupt, use_debug_exception_return)) v3 ();
+void __attribute__ ((interrupt, use_shadow_register_set,
+		     keep_interrupts_masked)) v4 ();
+void __attribute__ ((interrupt, use_shadow_register_set,
+		     use_debug_exception_return)) v5 ();
+void __attribute__ ((interrupt, keep_interrupts_masked,
+		     use_debug_exception_return)) v6 ();
+void __attribute__ ((interrupt, use_shadow_register_set,
+		     keep_interrupts_masked,
+		     use_debug_exception_return)) v7 ();
+@end smallexample
+
 @item interrupt_handler
 @cindex interrupt handler functions on the Blackfin, m68k, H8/300 and SH processors
 Use this attribute on the Blackfin, m68k, H8/300, H8/300H, H8S, and SH to
@@ -2518,6 +2605,25 @@ not that within individual functions.  Mixed MIPS16 and non-MIPS16 code
 may interact badly with some GCC extensions such as @code{__builtin_apply}
 (@pxref{Constructing Calls}).
 
+@item micromips/nomicromips
+@cindex @code{micromips} attribute
+@cindex @code{nomicromips} attribute
+
+On MIPS targets, you can use the @code{micromips} and @code{nomicromips}
+function attributes to locally select or turn off microMIPS code generation.
+A function with the @code{micromips} attribute is emitted as microMIPS code,
+while microMIPS code generation is disabled for functions with the
+@code{nomicromips} attribute.  These attributes override the
+@option{-mmicromips} and @option{-mno-micromips} options on the command line
+(@pxref{MIPS Options}).
+
+When compiling files containing mixed microMIPS and non-microMIPS code, the
+preprocessor symbol @code{__mips_micromips} reflects the setting on the
+command line,
+not that within individual functions.  Mixed microMIPS and non-microMIPS code
+may interact badly with some GCC extensions such as @code{__builtin_apply}
+(@pxref{Constructing Calls}).
+
 @item model (@var{model-name})
 @cindex function addressability on the M32R/D
 @cindex variable addressability on the IA-64
diff --git a/gcc/doc/fragments.texi b/gcc/doc/fragments.texi
index ff89d513d..8c242908f 100644
--- a/gcc/doc/fragments.texi
+++ b/gcc/doc/fragments.texi
@@ -143,6 +143,22 @@ options enabled.  Therefore @code{MULTILIB_EXCEPTIONS} is set to:
 *mthumb/*mhard-float*
 @end smallexample
 
+@findex MULTILIB_ALIASES
+@item MULTILIB_ALIASES
+Sometimes it is desirable to support a large set of multilib options, but
+only build libraries for a subset of those multilibs.  The remaining
+combinations use a sutiable alternative multilb.  In that case, set
+@code{MULTILIB_ALIASES} to a list of the form @samp{realname=aliasname}.
+
+For example, consider a little-endian ARM toolchain with big-endian and
+Thumb multilibs.  If a big-endian Thumb multilib is not wanted, then
+setting @code{MULTILIB_ALIASES} to @samp{mbig-endian=mbig-endian/mthumb} 
+makes this combination use the big-endian ARM libraries instead.
+
+If the multilib is instead excluded by setting @code{MULTILIB_EXCEPTIONS}
+then big-endian Thumb code uses the default multilib as none of the
+remaining multilibs match.
+
 @findex MULTILIB_EXTRA_OPTS
 @item MULTILIB_EXTRA_OPTS
 Sometimes it is desirable that when building multiple versions of
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 44b609d9a..760b228d3 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -988,6 +988,57 @@ sysv, aix.
 
 @end table
 
+@item --with-multilib-list=@var{list}
+@itemx --without-multilib-list
+Specify what multilibs to build.
+Currently only implemented for sh*-*-*.
+
+@var{list} is a comma separated list of CPU names.  These must be of the
+form @code{sh*} or @code{m*} (in which case they match the compiler option
+for that processor).  The list should not contain any endian options -
+these are handled by @option{--with-endian}.
+
+If @var{list} is empty, then there will be no multilibs for extra
+processors.  The multilib for the secondary endian remains enabled.
+
+As a special case, if an entry in the list starts with a @code{!}
+(exclamation point), then it is added to the list of excluded multilibs.
+Entries of this sort should be compatible with @samp{MULTILIB_EXCLUDES}
+(once the leading @code{!} has been stripped).
+
+If @option{--with-multilib-list} is not given, then a default set of
+multilibs is selected based on the value of @option{--target}.  This is
+usually the complete set of libraries, but some targets imply a more
+specialized subset.
+
+Example 1: to configure a compiler for SH4A only, but supporting both
+endians, with little endian being the default:
+@smallexample
+--with-cpu=sh4a --with-endian=little,big --with-multilib-list=
+@end smallexample
+
+Example 2: to configure a compiler for both SH4A and SH4AL-DSP, but with
+only little endian SH4AL:
+@smallexample
+--with-cpu=sh4a --with-endian=little,big --with-multilib-list=sh4al,!mb/m4al
+@end smallexample
+
+@item --with-endian=@var{endians}
+Specify what endians to use.
+Currently only implemented for sh*-*-*.
+
+@var{endians} may be one of the following:
+@table @code
+@item big
+Use big endian exclusively.
+@item little
+Use little endian exclusively.
+@item big,little
+Use big endian by default.  Provide a multilib for little endian.
+@item little,big
+Use little endian by default.  Provide a multilib for big endian.
+@end table
+
 @item --enable-threads
 Specify that the target
 supports threads.  This affects the Objective-C compiler and runtime
@@ -1436,6 +1487,10 @@ When neither of these configure options are used, the default will be
 128-bit @code{long double} when built against GNU C Library 2.4 and later,
 64-bit @code{long double} otherwise.
 
+@item --enable-fdpic
+On SH uClinux systems, generate ELF FDPIC code rather than code
+expected to be postprocessed into the FLT binary format.
+
 @item --with-gmp=@var{pathname}
 @itemx --with-gmp-include=@var{pathname}
 @itemx --with-gmp-lib=@var{pathname}
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 8f8dbe704..aaa8186a9 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -251,6 +251,7 @@ Objective-C and Objective-C++ Dialects}.
 -Woverlength-strings  -Wpacked  -Wpacked-bitfield-compat  -Wpadded @gol
 -Wparentheses  -Wpedantic-ms-format -Wno-pedantic-ms-format @gol
 -Wpointer-arith  -Wno-pointer-to-int-cast @gol
+-Wno-poison-system-directories @gol
 -Wredundant-decls @gol
 -Wreturn-type  -Wsequence-point  -Wshadow @gol
 -Wsign-compare  -Wsign-conversion  -Wstack-protector @gol
@@ -321,7 +322,7 @@ Objective-C and Objective-C++ Dialects}.
 @item Optimization Options
 @xref{Optimize Options,,Options that Control Optimization}.
 @gccoptlist{
--falign-functions[=@var{n}] -falign-jumps[=@var{n}] @gol
+-falign-arrays -falign-functions[=@var{n}] -falign-jumps[=@var{n}] @gol
 -falign-labels[=@var{n}] -falign-loops[=@var{n}] -fassociative-math @gol
 -fauto-inc-dec -fbranch-probabilities -fbranch-target-load-optimize @gol
 -fbranch-target-load-optimize2 -fbtr-bb-exclusive -fcaller-saves @gol
@@ -438,8 +439,11 @@ Objective-C and Objective-C++ Dialects}.
 -msched-prolog  -mno-sched-prolog @gol
 -mlittle-endian  -mbig-endian  -mwords-little-endian @gol
 -mfloat-abi=@var{name}  -msoft-float  -mhard-float  -mfpe @gol
+-mfp16-format=@var{name}
 -mthumb-interwork  -mno-thumb-interwork @gol
+-mfix-janus-2cc @gol
 -mcpu=@var{name}  -march=@var{name}  -mfpu=@var{name}  @gol
+-mmarvell-div @gol
 -mstructure-size-boundary=@var{n} @gol
 -mabort-on-noreturn @gol
 -mlong-calls  -mno-long-calls @gol
@@ -452,6 +456,7 @@ Objective-C and Objective-C++ Dialects}.
 -mtpcs-frame  -mtpcs-leaf-frame @gol
 -mcaller-super-interworking  -mcallee-super-interworking @gol
 -mtp=@var{name} @gol
+-mlow-irq-latency @gol
 -mword-relocations @gol
 -mfix-cortex-m3-ldrd}
 
@@ -574,7 +579,7 @@ Objective-C and Objective-C++ Dialects}.
 -mno-wide-multiply  -mrtd  -malign-double @gol
 -mpreferred-stack-boundary=@var{num}
 -mincoming-stack-boundary=@var{num}
--mcld -mcx16 -msahf -mrecip @gol
+-mcld -mcx16 -msahf -mmovbe -mrecip @gol
 -mmmx  -msse  -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -msse4 -mavx @gol
 -maes -mpclmul @gol
 -msse4a -m3dnow -mpopcnt -mabm -msse5 @gol
@@ -584,7 +589,7 @@ Objective-C and Objective-C++ Dialects}.
 -m96bit-long-double  -mregparm=@var{num}  -msseregparm @gol
 -mveclibabi=@var{type} -mpc32 -mpc64 -mpc80 -mstackrealign @gol
 -momit-leaf-frame-pointer  -mno-red-zone -mno-tls-direct-seg-refs @gol
--mcmodel=@var{code-model} @gol
+-mcmodel=@var{code-model} -mabi=@var{name} @gol
 -m32  -m64 -mlarge-data-threshold=@var{num} @gol
 -mfused-madd -mno-fused-madd -msse2avx}
 
@@ -652,12 +657,13 @@ Objective-C and Objective-C++ Dialects}.
 @gccoptlist{-EL  -EB  -march=@var{arch}  -mtune=@var{arch} @gol
 -mips1  -mips2  -mips3  -mips4  -mips32  -mips32r2 @gol
 -mips64  -mips64r2 @gol
--mips16  -mno-mips16  -mflip-mips16 @gol
+-mips16  -mips16e  -mno-mips16  -mflip-mips16 @gol
 -minterlink-mips16  -mno-interlink-mips16 @gol
 -mabi=@var{abi}  -mabicalls  -mno-abicalls @gol
 -mshared  -mno-shared  -mplt  -mno-plt  -mxgot  -mno-xgot @gol
 -mgp32  -mgp64  -mfp32  -mfp64  -mhard-float  -msoft-float @gol
 -msingle-float  -mdouble-float  -mdsp  -mno-dsp  -mdspr2  -mno-dspr2 @gol
+-mmicromips -mno-micromips -mmcu -mmno-mcu @gol
 -mfpu=@var{fpu-type} @gol
 -msmartmips  -mno-smartmips @gol
 -mpaired-single  -mno-paired-single  -mdmx  -mno-mdmx @gol
@@ -673,6 +679,7 @@ Objective-C and Objective-C++ Dialects}.
 -mcheck-zero-division  -mno-check-zero-division @gol
 -mdivide-traps  -mdivide-breaks @gol
 -mmemcpy  -mno-memcpy  -mlong-calls  -mno-long-calls @gol
+-mjals -mno-jals @gol
 -mmad  -mno-mad  -mfused-madd  -mno-fused-madd  -nocpp @gol
 -mfix-r4000  -mno-fix-r4000  -mfix-r4400  -mno-fix-r4400 @gol
 -mfix-r10000 -mno-fix-r10000  -mfix-vr4120  -mno-fix-vr4120 @gol
@@ -778,12 +785,12 @@ See RS/6000 and PowerPC Options.
 -m5-32media  -m5-32media-nofpu @gol
 -m5-compact  -m5-compact-nofpu @gol
 -mb  -ml  -mdalign  -mrelax @gol
--mbigtable  -mfmovd  -mhitachi -mrenesas -mno-renesas -mnomacsave @gol
+-mbigtable -mfmovd -mhitachi -mrenesas -mno-renesas -mnomacsave @gol
 -mieee  -mbitops  -misize  -minline-ic_invalidate -mpadstruct  -mspace @gol
 -mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol
 -mdivsi3_libfunc=@var{name} -mfixed-range=@var{register-range} @gol
 -madjust-unroll -mindexed-addressing -mgettrcost=@var{number} -mpt-fixed @gol
--minvalid-symbols}
+-minvalid-symbols  -mfdpic}
 
 @emph{SPARC Options}
 @gccoptlist{-mcpu=@var{cpu-type} @gol
@@ -1189,8 +1196,8 @@ This will display the values recognized by the @option{--param}
 option.
 
 @item @var{language}
-This will display the options supported for @var{language}, where 
-@var{language} is the name of one of the languages supported in this 
+This will display the options supported for @var{language}, where
+@var{language} is the name of one of the languages supported in this
 version of GCC.
 
 @item @samp{common}
@@ -1390,7 +1397,7 @@ affected.
 @opindex std
 Determine the language standard. @xref{Standards,,Language Standards
 Supported by GCC}, for details of these standard versions.  This option
-is currently only supported when compiling C or C++. 
+is currently only supported when compiling C or C++.
 
 The compiler can accept several base standards, such as @samp{c89} or
 @samp{c++98}, and GNU dialects of those standards, such as
@@ -2816,21 +2823,21 @@ following cases:
 A pointer is compared against integer zero with @samp{<}, @samp{<=},
 @samp{>}, or @samp{>=}.
 
-@item 
+@item
 (C++ only) An enumerator and a non-enumerator both appear in a
 conditional expression.
 
-@item 
+@item
 (C++ only) Ambiguous virtual bases.
 
-@item 
+@item
 (C++ only) Subscripting an array which has been declared @samp{register}.
 
-@item 
+@item
 (C++ only) Taking the address of a variable which has been declared
 @samp{register}.
 
-@item 
+@item
 (C++ only) A base class is not initialized in a derived class' copy
 constructor.
 
@@ -3366,9 +3373,9 @@ with n=3.
 
 Level 1: Most aggressive, quick, least accurate.
 Possibly useful when higher levels
-do not warn but -fstrict-aliasing still breaks the code, as it has very few 
+do not warn but -fstrict-aliasing still breaks the code, as it has very few
 false negatives.  However, it has many false positives.
-Warns for all pointer conversions between possibly incompatible types, 
+Warns for all pointer conversions between possibly incompatible types,
 even if never dereferenced.  Runs in the frontend only.
 
 Level 2: Aggressive, quick, not too precise.
@@ -3377,12 +3384,12 @@ and few false negatives (but possibly more than level 1).
 Unlike level 1, it only warns when an address is taken.  Warns about
 incomplete types.  Runs in the frontend only.
 
-Level 3 (default for @option{-Wstrict-aliasing}): 
-Should have very few false positives and few false 
+Level 3 (default for @option{-Wstrict-aliasing}):
+Should have very few false positives and few false
 negatives.  Slightly slower than levels 1 or 2 when optimization is enabled.
 Takes care of the common punn+dereference pattern in the frontend:
 @code{*(int*)&some_float}.
-If optimization is enabled, it also runs in the backend, where it deals 
+If optimization is enabled, it also runs in the backend, where it deals
 with multiple statement cases using flow-sensitive points-to information.
 Only warns when the converted pointer is dereferenced.
 Does not warn about incomplete types.
@@ -3469,6 +3476,14 @@ code.  However, note that using @option{-Wall} in conjunction with this
 option will @emph{not} warn about unknown pragmas in system
 headers---for that, @option{-Wunknown-pragmas} must also be used.
 
+@item -Wno-poison-system-directories
+@opindex Wno-poison-system-directories
+Do not warn for @option{-I} or @option{-L} options using system
+directories such as @file{/usr/include} when cross compiling.  This
+option is intended for use in chroot environments when such
+directories contain the correct headers and libraries for the target
+system rather than the host.
+
 @item -Wfloat-equal
 @opindex Wfloat-equal
 @opindex Wno-float-equal
@@ -4563,7 +4578,7 @@ Print the name and the counter upperbound for all debug counters.
 
 @item -fdbg-cnt=@var{counter-value-list}
 @opindex fdbg-cnt
-Set the internal debug counter upperbound. @var{counter-value-list} 
+Set the internal debug counter upperbound. @var{counter-value-list}
 is a comma-separated list of @var{name}:@var{value} pairs
 which sets the upperbound of each debug counter @var{name} to @var{value}.
 All debug counters have the initial upperbound of @var{UINT_MAX},
@@ -4643,7 +4658,7 @@ Dump after duplicating the computed gotos.
 @opindex fdump-rtl-ce3
 @option{-fdump-rtl-ce1}, @option{-fdump-rtl-ce2}, and
 @option{-fdump-rtl-ce3} enable dumping after the three
-if conversion passes. 
+if conversion passes.
 
 @itemx -fdump-rtl-cprop_hardreg
 @opindex fdump-rtl-cprop_hardreg
@@ -4772,7 +4787,7 @@ Dump after sign extension elimination.
 
 @item -fdump-rtl-seqabstr
 @opindex fdump-rtl-seqabstr
-Dump after common sequence discovery. 
+Dump after common sequence discovery.
 
 @item -fdump-rtl-shorten
 @opindex fdump-rtl-shorten
@@ -5345,7 +5360,13 @@ the compiler to use information gained from all of the files when compiling
 each of them.
 
 Not all optimizations are controlled directly by a flag.  Only
-optimizations that have a flag are listed.
+optimizations that have a flag are listed in this section.
+
+Depending on the target and how GCC was configured, a slightly different
+set of optimizations may be enabled at each @option{-O} level than
+those listed here.  You can invoke GCC with @samp{-Q --help=optimizers}
+to find out the exact set of optimizations that are enabled at each level.
+@xref{Overall Options}, for examples.
 
 @table @gcctabopt
 @item -O
@@ -5949,7 +5970,7 @@ helps machines that have slow floating point or memory load instructions
 by allowing other instructions to be issued until the result of the load
 or floating point instruction is required.
 
-Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
+Enabled at levels @option{-O2}, @option{-O3}.
 
 @item -fschedule-insns2
 @opindex fschedule-insns2
@@ -6054,8 +6075,8 @@ scheduling runs instead of the second scheduler pass.
 
 @item -fsel-sched-pipelining
 @opindex fsel-sched-pipelining
-Enable software pipelining of innermost loops during selective scheduling.  
-This option has no effect until one of @option{-fselective-scheduling} or 
+Enable software pipelining of innermost loops during selective scheduling.
+This option has no effect until one of @option{-fselective-scheduling} or
 @option{-fselective-scheduling2} is turned on.
 
 @item -fsel-sched-pipelining-outer-loops
@@ -6119,9 +6140,9 @@ Enabled by default at @option{-O} and higher.
 
 @item -fipa-struct-reorg
 @opindex fipa-struct-reorg
-Perform structure reorganization optimization, that change C-like structures 
-layout in order to better utilize spatial locality.  This transformation is 
-effective for programs containing arrays of structures.  Available in two 
+Perform structure reorganization optimization, that change C-like structures
+layout in order to better utilize spatial locality.  This transformation is
+effective for programs containing arrays of structures.  Available in two
 compilation modes: profile-based (enabled with @option{-fprofile-generate})
 or static (which uses built-in heuristics).  Require @option{-fipa-type-escape}
 to provide the safety of this transformation.  It works only in whole program
@@ -6140,7 +6161,7 @@ and does not affect generated code.
 @opindex fipa-cp
 Perform interprocedural constant propagation.
 This optimization analyzes the program to determine when values passed
-to functions are constants and then optimizes accordingly.  
+to functions are constants and then optimizes accordingly.
 This optimization can substantially increase performance
 if the application has constants passed to functions.
 This flag is enabled by default at @option{-O2}, @option{-Os} and @option{-O3}.
@@ -6164,10 +6185,9 @@ This reduces the level of indirection needed for accessing the elements
 of the matrix. The second optimization is matrix transposing that
 attempts to change the order of the matrix's dimensions in order to
 improve cache locality.
-Both optimizations need the @option{-fwhole-program} flag. 
+Both optimizations need the @option{-fwhole-program} flag.
 Transposing is enabled only if profiling information is available.
 
-
 @item -ftree-sink
 @opindex ftree-sink
 Perform forward store motion  on trees.  This flag is
@@ -6191,9 +6211,9 @@ default at @option{-O} and higher.
 
 @item -ftree-builtin-call-dce
 @opindex ftree-builtin-call-dce
-Perform conditional dead code elimination (DCE) for calls to builtin functions 
-that may set @code{errno} but are otherwise side-effect free.  This flag is 
-enabled by default at @option{-O2} and higher if @option{-Os} is not also 
+Perform conditional dead code elimination (DCE) for calls to builtin functions
+that may set @code{errno} but are otherwise side-effect free.  This flag is
+enabled by default at @option{-O2} and higher if @option{-Os} is not also
 specified.
 
 @item -ftree-dominator-opts
@@ -6258,8 +6278,8 @@ Graphite loop transformation infrastructure.
 
 @item -floop-strip-mine
 Perform loop strip mining transformations on loops.  Strip mining
-splits a loop into two nested loops.  The outer loop has strides 
-equal to the strip size and the inner loop has strides of the 
+splits a loop into two nested loops.  The outer loop has strides
+equal to the strip size and the inner loop has strides of the
 original loop within a strip.  For example, given a loop like:
 @smallexample
 DO I = 1, N
@@ -6621,6 +6641,14 @@ arithmetic on constants, the overflowed value can still be used with
 The @option{-fstrict-overflow} option is enabled at levels
 @option{-O2}, @option{-O3}, @option{-Os}.
 
+@item -falign-arrays
+@opindex falign-arrays
+Set the minimum alignment for array variables to be the largest power
+of two less than or equal to their total storage size, or the biggest
+alignment used on the machine, whichever is smaller.  This option may be
+helpful when compiling legacy code that uses type punning on arrays that
+does not strictly conform to the C standard.
+
 @item -falign-functions
 @itemx -falign-functions=@var{n}
 @opindex falign-functions
@@ -6756,7 +6784,7 @@ default, GCC will emit an error message when an inconsistent profile is detected
 Set the directory to search the profile data files in to @var{path}.
 This option affects only the profile data generated by
 @option{-fprofile-generate}, @option{-ftest-coverage}, @option{-fprofile-arcs}
-and used by @option{-fprofile-use} and @option{-fbranch-probabilities} 
+and used by @option{-fprofile-use} and @option{-fbranch-probabilities}
 and its related options.
 By default, GCC will use the current directory as @var{path}
 thus the profile data file will appear in the same directory as the object file.
@@ -7185,6 +7213,21 @@ int foo (void)
 
 Not all targets support this option.
 
+@item -fremove-local-statics
+@opindex fremove-local-statics
+Converts function-local static variables to automatic variables when it
+is safe to do so.  This transformation can reduce the number of
+instructions executed due to automatic variables being cheaper to
+read/write than static variables.
+
+@item -fpromote-loop-indices
+@opindex fpromote-loop-indices
+Converts loop indices that have a type shorter than the word size to
+word-sized quantities.  This transformation can reduce the overhead
+associated with sign/zero-extension and truncation of such variables.
+Using @option{-funsafe-loop-optimizations} with this option may result
+in more effective optimization.
+
 @item --param @var{name}=@var{value}
 @opindex param
 In some places, GCC uses various constants to control the amount of
@@ -7218,8 +7261,8 @@ default is 75.
 The threshold ratio (as a percentage) between a structure frequency
 and the frequency of the hottest structure in the program.  This parameter
 is used by struct-reorg optimization enabled by @option{-fipa-struct-reorg}.
-We say that if the ratio of a structure frequency, calculated by profiling, 
-to the hottest structure frequency in the program is less than this 
+We say that if the ratio of a structure frequency, calculated by profiling,
+to the hottest structure frequency in the program is less than this
 parameter, then structure reorganization is not applied to this structure.
 The default is 10.
 
@@ -7692,8 +7735,8 @@ depth of search for available instructions.
 The default value is 50.
 
 @item selsched-max-sched-times
-The maximum number of times that an instruction will be scheduled during 
-selective scheduling.  This is the limit on the number of iterations 
+The maximum number of times that an instruction will be scheduled during
+selective scheduling.  This is the limit on the number of iterations
 through which the instruction may be pipelined.  The default value is 2.
 
 @item selsched-max-insns-to-rename
@@ -8065,7 +8108,7 @@ this option.
 @cindex linker script
 Use @var{script} as the linker script.  This option is supported by most
 systems using the GNU linker.  On some targets, such as bare-board
-targets without an operating system, the @option{-T} option may be required 
+targets without an operating system, the @option{-T} option may be required
 when linking to avoid references to undefined symbols.
 
 @item -Xlinker @var{option}
@@ -8081,7 +8124,7 @@ For example, to pass @option{-assert definitions}, you must write
 @option{-Xlinker "-assert definitions"}, because this passes the entire
 string as a single argument, which is not what the linker expects.
 
-When using the GNU linker, it is usually more convenient to pass 
+When using the GNU linker, it is usually more convenient to pass
 arguments to linker options using the @option{@var{option}=@var{value}}
 syntax than as separate arguments.  For example, you can specify
 @samp{-Xlinker -Map=output.map} rather than
@@ -8092,7 +8135,7 @@ this syntax for command-line options.
 @opindex Wl
 Pass @var{option} as an option to the linker.  If @var{option} contains
 commas, it is split into multiple options at the commas.  You can use this
-syntax to pass an argument to the option.  
+syntax to pass an argument to the option.
 For example, @samp{-Wl,-Map,output.map} passes @samp{-Map output.map} to the
 linker.  When using the GNU linker, you can also get the same effect with
 @samp{-Wl,-Map=output.map}.
@@ -8740,6 +8783,12 @@ be as many clauses as you need.  This may be combined with @code{.},
 @code{,}, @code{!}, @code{|}, and @code{*} as needed.
 
 
+@item -mlow-irq-latency
+@opindex mlow-irq-latency
+Avoid instructions with high interrupt latency when generating
+code.  This can increase code size and reduce performance.
+The option is off by default.
+
 @end table
 
 The conditional text @code{X} in a %@{@code{S}:@code{X}@} or similar
@@ -9019,11 +9068,6 @@ instructions, but still uses the soft-float calling conventions.
 @samp{hard} allows generation of floating-point instructions 
 and uses FPU-specific calling conventions.
 
-Using @option{-mfloat-abi=hard} with VFP coprocessors is not supported.
-Use @option{-mfloat-abi=softfp} with the appropriate @option{-mfpu} option
-to allow the compiler to generate code that makes use of the hardware
-floating-point capabilities for these CPUs.
-
 The default depends on the specific target configuration.  Note that
 the hard-float and soft-float ABIs are not link-compatible; you must
 compile your entire program with the same ABI, and link with a
@@ -9077,10 +9121,10 @@ assembly code.  Permissible names are: @samp{arm2}, @samp{arm250},
 @samp{arm10e}, @samp{arm1020e}, @samp{arm1022e},
 @samp{arm1136j-s}, @samp{arm1136jf-s}, @samp{mpcore}, @samp{mpcorenovfp},
 @samp{arm1156t2-s}, @samp{arm1176jz-s}, @samp{arm1176jzf-s},
-@samp{cortex-a8}, @samp{cortex-a9},
-@samp{cortex-r4}, @samp{cortex-r4f}, @samp{cortex-m3},
-@samp{cortex-m1},
-@samp{xscale}, @samp{iwmmxt}, @samp{iwmmxt2}, @samp{ep9312}.
+@samp{cortex-a5}, @samp{cortex-a8}, @samp{cortex-a9},
+@samp{cortex-r4}, @samp{cortex-r4f}, @samp{cortex-m4}, @samp{cortex-m3},
+@samp{cortex-m1}, @samp{cortex-m0},
+@samp{xscale}, @samp{iwmmxt}, @samp{iwmmxt2}, @samp{ep9312}, @samp{marvell-f}.
 
 @item -mtune=@var{name}
 @opindex mtune
@@ -9114,14 +9158,26 @@ of the @option{-mcpu=} option.  Permissible names are: @samp{armv2},
 @opindex mfp
 This specifies what floating point hardware (or hardware emulation) is
 available on the target.  Permissible names are: @samp{fpa}, @samp{fpe2},
-@samp{fpe3}, @samp{maverick}, @samp{vfp}, @samp{vfpv3}, @samp{vfpv3-d16} and
-@samp{neon}.  @option{-mfp} and @option{-mfpe}
+@samp{fpe3}, @samp{maverick}, @samp{vfp}, @samp{vfpv3}, @samp{vfpv3-fp16},
+@samp{vfpv3-d16}, @samp{vfpv3-d16-fp16}, @samp{vfpv4}, @samp{vfpv4-d16}, @samp{neon}, @samp{neon-fp16} and @samp{neon-vfpv4}.
+@option{-mfp} and @option{-mfpe}
 are synonyms for @option{-mfpu}=@samp{fpe}@var{number}, for compatibility
 with older versions of GCC@.
 
 If @option{-msoft-float} is specified this specifies the format of
 floating point values.
 
+@item -mfp16-format=@var{name}
+@opindex mfp16-format
+Specify the format of the @code{__fp16} half-precision floating-point type.
+Permissible names are @samp{none}, @samp{ieee}, and @samp{alternative}; 
+the default is @samp{none}, in which case the @code{__fp16} type is not 
+defined.  @xref{Half-Precision}, for more information.
+
+@item -mmarvell-div
+@opindex mmarvell-div
+Generate hardware integer division instructions supported by some Marvell cores.
+
 @item -mstructure-size-boundary=@var{n}
 @opindex mstructure-size-boundary
 The size of all structures and unions will be rounded up to a multiple
@@ -9225,6 +9281,10 @@ This option automatically enables either 16-bit Thumb-1 or
 mixed 16/32-bit Thumb-2 instructions based on the @option{-mcpu=@var{name}}
 and @option{-march=@var{name}} options.
 
+@item -mfix-janus-2cc
+@opindex mfix-janus-2cc
+Work around hardware errata for Avalent Janus 2CC cores.
+
 @item -mtpcs-frame
 @opindex mtpcs-frame
 Generate a stack frame that is compliant with the Thumb Procedure Call
@@ -9513,7 +9573,7 @@ one application per core programming model. Proper start files
 and link scripts will be used to support Core B. This option
 defines @code{__BFIN_COREB}. When this option is used, coreb_main
 should be used instead of main. It must be used with
-@option{-mmulticore}. 
+@option{-mmulticore}.
 
 @item -msdram
 @opindex msdram
@@ -10980,6 +11040,9 @@ SSE2 and SSE3 instruction set support.
 @item core2
 Intel Core2 CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3 and SSSE3
 instruction set support.
+@item atom
+Intel Atom CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3 and SSSE3
+instruction set support.
 @item k6
 AMD K6 CPU with MMX instruction set support.
 @item k6-2, k6-3
@@ -11247,7 +11310,7 @@ Setting the rounding of floating-point operations to less than the default
 libraries assume that extended precision (80 bit) floating-point operations
 are enabled by default; routines in such libraries could suffer significant
 loss of accuracy, typically through so-called "catastrophic cancellation",
-when this option is used to set the precision to less than extended precision. 
+when this option is used to set the precision to less than extended precision.
 
 @item -mstackrealign
 @opindex mstackrealign
@@ -11379,6 +11442,11 @@ SAHF are load and store instructions, respectively, for certain status flags.
 In 64-bit mode, SAHF instruction is used to optimize @code{fmod}, @code{drem}
 or @code{remainder} built-in functions: see @ref{Other Builtins} for details.
 
+@item -mmovbe
+@opindex mmovbe
+This option will enable GCC to use movbe instruction to implement
+@code{__builtin_bswap32} and @code{__builtin_bswap64}.
+
 @item -mrecip
 @opindex mrecip
 This option will enable GCC to use RCPSS and RSQRTSS instructions (and their
@@ -11415,6 +11483,16 @@ when @option{-mveclibabi=acml} is used. Both @option{-ftree-vectorize} and
 @option{-funsafe-math-optimizations} have to be enabled. A SVML or ACML ABI
 compatible library will have to be specified at link time.
 
+@item -mabi=@var{name}
+@opindex mabi
+Generate code for the specified calling convention.  Permissible values
+are: @samp{sysv} for the ABI used on GNU/Linux and other systems and
+@samp{ms} for the Microsoft ABI.  The default is to use the Microsoft
+ABI when targeting Windows.  On all other systems, the default is the
+SYSV ABI.  You can control this behavior for a specific function by
+using the function attribute @samp{ms_abi}/@samp{sysv_abi}.
+@xref{Function Attributes}.
+
 @item -mpush-args
 @itemx -mno-push-args
 @opindex mpush-args
@@ -11612,6 +11690,15 @@ This option is available for Cygwin and MinGW targets.  It
 specifies that a GUI application is to be generated by
 instructing the linker to set the PE header subsystem type
 appropriately.
+
+@item -mpe-aligned-commons
+@opindex mpe-aligned-commons
+This option is available for Cygwin and MinGW targets.  It
+specifies that the GNU extension to the PE file format that
+permits the correct alignment of COMMON variables should be
+used when generating code.  It will be enabled by default if
+GCC detects that the target assembler found during configuration
+supports the feature.
 @end table
 
 See also under @ref{i386 and x86-64 Options} for standard options.
@@ -12068,7 +12155,7 @@ below, which also classifies the CPUs into families:
 
 @multitable @columnfractions 0.20 0.80
 @item @strong{Family} @tab @strong{@samp{-mcpu} arguments}
-@item @samp{51qe} @tab @samp{51qe}
+@item @samp{51} @tab @samp{51} @samp{51ac} @samp{51cn} @samp{51em} @samp{51qe}
 @item @samp{5206} @tab @samp{5202} @samp{5204} @samp{5206}
 @item @samp{5206e} @tab @samp{5206e}
 @item @samp{5208} @tab @samp{5207} @samp{5208}
@@ -12077,6 +12164,7 @@ below, which also classifies the CPUs into families:
 @item @samp{5216} @tab @samp{5214} @samp{5216}
 @item @samp{52235} @tab @samp{52230} @samp{52231} @samp{52232} @samp{52233} @samp{52234} @samp{52235}
 @item @samp{5225} @tab @samp{5224} @samp{5225}
+@item @samp{52259} @tab @samp{52252} @samp{52254} @samp{52255} @samp{52256} @samp{52258} @samp{52259}
 @item @samp{5235} @tab @samp{5232} @samp{5233} @samp{5234} @samp{5235} @samp{523x}
 @item @samp{5249} @tab @samp{5249}
 @item @samp{5250} @tab @samp{5250}
@@ -12084,6 +12172,7 @@ below, which also classifies the CPUs into families:
 @item @samp{5272} @tab @samp{5272}
 @item @samp{5275} @tab @samp{5274} @samp{5275}
 @item @samp{5282} @tab @samp{5280} @samp{5281} @samp{5282} @samp{528x}
+@item @samp{53017} @tab @samp{53011} @samp{53012} @samp{53013} @samp{53014} @samp{53015} @samp{53016} @samp{53017}
 @item @samp{5307} @tab @samp{5307}
 @item @samp{5329} @tab @samp{5327} @samp{5328} @samp{5329} @samp{532x}
 @item @samp{5373} @tab @samp{5372} @samp{5373} @samp{537x}
@@ -12583,8 +12672,9 @@ The processor names are:
 @samp{24kec}, @samp{24kef2_1}, @samp{24kef1_1},
 @samp{34kc}, @samp{34kf2_1}, @samp{34kf1_1},
 @samp{74kc}, @samp{74kf2_1}, @samp{74kf1_1}, @samp{74kf3_2},
+@samp{1004kc}, @samp{1004kf2_1}, @samp{1004kf1_1},
 @samp{loongson2e}, @samp{loongson2f},
-@samp{m4k},
+@samp{m4k}, @samp{m14k},
 @samp{octeon},
 @samp{orion},
 @samp{r2000}, @samp{r3000}, @samp{r3900}, @samp{r4000}, @samp{r4400},
@@ -12682,11 +12772,14 @@ Equivalent to @samp{-march=mips64}.
 Equivalent to @samp{-march=mips64r2}.
 
 @item -mips16
+@itemx -mips16e
 @itemx -mno-mips16
 @opindex mips16
+@opindex mips16e
 @opindex mno-mips16
 Generate (do not generate) MIPS16 code.  If GCC is targetting a
 MIPS32 or MIPS64 architecture, it will make use of the MIPS16e ASE@.
+@option{-mips16e} is a deprecated alias for @option{-mips16}.
 
 MIPS16 code generation can also be controlled on a per-function basis
 by means of @code{mips16} and @code{nomips16} attributes.  
@@ -12702,13 +12795,14 @@ not intended for ordinary use in compiling user code.
 @itemx -mno-interlink-mips16
 @opindex minterlink-mips16
 @opindex mno-interlink-mips16
-Require (do not require) that non-MIPS16 code be link-compatible with
-MIPS16 code.
+Require (do not require) that non-MIPS16/non-microMIPS code be link-compatible
+with MIPS16/microMIPS code.
 
-For example, non-MIPS16 code cannot jump directly to MIPS16 code;
+For example, non-MIPS16/non-microMIPS code cannot jump directly to
+MIPS16/microMIPS code;
 it must either use a call or an indirect jump.  @option{-minterlink-mips16}
 therefore disables direct jumps unless GCC knows that the target of the
-jump is not MIPS16.
+jump is not MIPS16/non microMIPS.
 
 @item -mabi=32
 @itemx -mabi=o64
@@ -12911,12 +13005,29 @@ hardware floating-point support to be enabled.
 Use (do not use) the MIPS-3D ASE@.  @xref{MIPS-3D Built-in Functions}.
 The option @option{-mips3d} implies @option{-mpaired-single}.
 
+@item -mmicromips
+@itemx -mno-micromips
+@opindex mmicromips
+@opindex mno-mmicromips
+Generate (do not generate) microMIPS code.  If GCC is targetting a
+MIPS32 or MIPS64 architecture, it will make use of the microMIPS ASE@.
+
+MicroMIPS code generation can also be controlled on a per-function basis
+by means of @code{micromips} and @code{nomicromips} attributes.
+@xref{Function Attributes}, for more information.
+
 @item -mmt
 @itemx -mno-mt
 @opindex mmt
 @opindex mno-mt
 Use (do not use) MT Multithreading instructions.
 
+@item -mmcu
+@itemx -mno-mcu
+@opindex mmcu
+@opindex mno-mcu
+Use (do not use) the MIPS MCU ASE instructions.
+
 @item -mlong64
 @opindex mlong64
 Force @code{long} types to be 64 bits wide.  See @option{-mlong32} for
@@ -13112,6 +13223,16 @@ and callee to be in the same 256 megabyte segment.
 This option has no effect on abicalls code.  The default is
 @option{-mno-long-calls}.
 
+@item -mjals
+@itemx -mno-jals
+@opindex mjals
+@opindex mno-jals
+Generate (do not generate) the @code{jals} instruction for microMIPS
+by recognizing that the branch delay slot instruction can be 16 bits.
+This implies that the funciton call cannot switch the current mode
+during the linking stage, because we don't have the @code{jalxs}
+instruction that supports 16-bit branch delay slot instructions.
+
 @item -mmad
 @itemx -mno-mad
 @opindex mmad
@@ -14033,8 +14154,8 @@ Software floating point emulation is provided if you use the
 @itemx -mdouble-float
 @opindex msingle-float
 @opindex mdouble-float
-Generate code for single or double-precision floating point operations. 
-@option{-mdouble-float} implies @option{-msingle-float}. 
+Generate code for single or double-precision floating point operations.
+@option{-mdouble-float} implies @option{-msingle-float}.
 
 @item -msimple-fpu
 @opindex msimple-fpu
@@ -14042,7 +14163,7 @@ Do not generate sqrt and div instructions for hardware floating point unit.
 
 @item -mfpu
 @opindex mfpu
-Specify type of floating point unit.  Valid values are @var{sp_lite} 
+Specify type of floating point unit.  Valid values are @var{sp_lite}
 (equivalent to -msingle-float -msimple-fpu), @var{dp_lite} (equivalent
 to -mdouble-float -msimple-fpu), @var{sp_full} (equivalent to -msingle-float),
 and @var{dp_full} (equivalent to -mdouble-float).
@@ -14685,7 +14806,7 @@ Compile code for big endian mode.  This is the default.
 
 @item -mel
 @opindex mel
-Compile code for little endian mode. 
+Compile code for little endian mode.
 
 @item -mnhwloop
 @opindex mnhwloop
@@ -14697,7 +14818,7 @@ Enable generate unaligned load and store instruction.
 
 @item -mmac
 @opindex mmac
-Enable the use of multiply-accumulate instructions. Disabled by default. 
+Enable the use of multiply-accumulate instructions. Disabled by default.
 
 @item -mscore5
 @opindex mscore5
@@ -14814,7 +14935,8 @@ Enable the use of bit manipulation instructions on SH2A.
 
 @item -mfmovd
 @opindex mfmovd
-Enable the use of the instruction @code{fmovd}.
+Enable the use of the instruction @code{fmovd}.  Check @option{-mdalign} for
+alignment constraints.
 
 @item -mhitachi
 @opindex mhitachi
@@ -14989,6 +15111,11 @@ to generate symbols that will cause ptabs / ptrel to trap.
 This option is only meaningful when @option{-mno-pt-fixed} is in effect.
 It will then prevent cross-basic-block cse, hoisting and most scheduling
 of symbol loads.  The default is @option{-mno-invalid-symbols}.
+
+@item -mfdpic
+@opindex fdpic
+Generate code using the FDPIC ABI for uClinux, as documented at
+@w{@uref{http://www.codesourcery.com/public/docs/sh-fdpic/sh-fdpic-abi.txt}}.
 @end table
 
 @node SPARC Options
@@ -15350,7 +15477,7 @@ generate the branch hint.
 @opindex mhint-max-distance
 The encoding of the branch hint instruction limits the hint to be within
 256 instructions of the branch it is effecting.  By default, GCC makes
-sure it is within 125. 
+sure it is within 125.
 
 @item -msafe-hints
 @opindex msafe-hints
@@ -15817,19 +15944,19 @@ Use it to conform to a non-default application binary interface.
 In C code, controls the placement of uninitialized global variables.
 Unix C compilers have traditionally permitted multiple definitions of
 such variables in different compilation units by placing the variables
-in a common block.  
-This is the behavior specified by @option{-fcommon}, and is the default 
-for GCC on most targets.  
+in a common block.
+This is the behavior specified by @option{-fcommon}, and is the default
+for GCC on most targets.
 On the other hand, this behavior is not required by ISO C, and on some
 targets may carry a speed or code size penalty on variable references.
-The @option{-fno-common} option specifies that the compiler should place 
+The @option{-fno-common} option specifies that the compiler should place
 uninitialized global variables in the data section of the object file,
 rather than generating them as common blocks.
-This has the effect that if the same variable is declared 
+This has the effect that if the same variable is declared
 (without @code{extern}) in two different compilations,
 you will get a multiple-definition error when you link them.
-In this case, you must compile with @option{-fcommon} instead.  
-Compiling with @option{-fno-common} is useful on targets for which 
+In this case, you must compile with @option{-fcommon} instead.
+Compiling with @option{-fno-common} is useful on targets for which
 it provides better performance, or if you wish to verify that the
 program will work on other systems which always treat uninitialized
 variable declarations this way.
diff --git a/gcc/doc/md.texi b/gcc/doc/md.texi
index cdfe379fb..5a818a9c4 100644
--- a/gcc/doc/md.texi
+++ b/gcc/doc/md.texi
@@ -2574,6 +2574,9 @@ Floating-point zero.
 
 @item R
 An address that can be used in a non-macro load or store.
+
+@item YC
+For MIPS, it is the same as the constraint @code{R}.  For microMIPS, it matches an address within a 12-bit offset that can be used for microMIPS @code{ll}, @code{sc}, etc.
 @end table
 
 @item Motorola 680x0---@file{config/m68k/constraints.md}
@@ -7504,6 +7507,11 @@ be ignored for this case.  The additional guard is necessary to
 recognize complicated bypasses, e.g.@: when the consumer is only an address
 of insn @samp{store} (not a stored value).
 
+If there are more one bypass with the same output and input insns, the
+chosen bypass is the first bypass with a guard in description whose
+guard function returns nonzero.  If there is no such bypass, then
+bypass without the guard function is chosen.
+
 @findex exclusion_set
 @findex presence_set
 @findex final_presence_set
diff --git a/gcc/doc/tm.texi b/gcc/doc/tm.texi
index b303c1d97..0b96a9793 100644
--- a/gcc/doc/tm.texi
+++ b/gcc/doc/tm.texi
@@ -2472,6 +2472,15 @@ address where its value is either multiplied by a scale factor or
 added to another register (as well as added to a displacement).
 @end defmac
 
+@defmac MODE_INDEX_REG_CLASS (@var{mode})
+This is a variation of the @code{INDEX_REG_CLASS} macro which allows
+the selection of an index register in a mode dependent manner.  It can
+return @code{NO_REGS} for modes that do not support any form of index
+register.  If @var{mode} is @code{VOIDmode} then the macro should
+return a class of registers that is suitable for all addresses in
+which an index register of some form is allowed.
+@end defmac
+
 @defmac REGNO_OK_FOR_BASE_P (@var{num})
 A C expression which is nonzero if register number @var{num} is
 suitable for use as a base register in operand addresses.  It may be
@@ -2531,6 +2540,14 @@ looking for one that is valid, and will reload one or both registers
 only if neither labeling works.
 @end defmac
 
+@defmac REGNO_MODE_OK_FOR_INDEX_P (@var{num}, @var{mode})
+A C expression that is just like @code{REGNO_OK_FOR_INDEX_P}, except
+that the expression may examine the mode of the memory reference
+in @var{mode}.  If @var{mode} is @code{VOIDmode}, the macro should
+return true if @var{x} is suitable for all modes in which some
+form of index register is allowed.
+@end defmac
+
 @defmac PREFERRED_RELOAD_CLASS (@var{x}, @var{class})
 A C expression that places additional restrictions on the register class
 to use when it is necessary to copy value @var{x} into a register in class
@@ -3266,7 +3283,8 @@ final value should coincide with that calculated by
 @code{INCOMING_FRAME_SP_OFFSET}.  Which is unfortunately not usable
 during virtual register instantiation.
 
-The default value for this macro is @code{FIRST_PARM_OFFSET (fundecl)},
+The default value for this macro is
+@code{FIRST_PARM_OFFSET (fundecl) + crtl->args.pretend_args_size},
 which is correct for most machines; in general, the arguments are found
 immediately before the stack frame.  Note that this is not the case on
 some targets that save registers into the caller's frame, such as SPARC
@@ -4332,6 +4350,18 @@ specially by the compiler and was not mentioned in the C code being
 compiled.
 @end defmac
 
+@deftypefn {Target Hook} rtx TARGET_LIBCALL_VALUE (enum machine_mode
+@var{mode}, rtx @var{fun})
+Define this hook if the back-end needs to know the name of the libcall
+function in order to determine where the result should be returned.  
+
+The mode of the result is given by @var{mode} and the name of the called
+library function is given by @var{fun}.  The hook should return an RTX 
+representing the place where the library function result will be returned.
+
+If this hook is not defined, then LIBCALL_VALUE will be used.
+@end deftypefn
+
 @defmac FUNCTION_VALUE_REGNO_P (@var{regno})
 A C expression that is nonzero if @var{regno} is the number of a hard
 register in which the values of called function may come back.
@@ -6851,8 +6881,9 @@ when @code{flag_pic} is true).
 @end defmac
 
 @defmac PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
-Define this macro if the register defined by
-@code{PIC_OFFSET_TABLE_REGNUM} is clobbered by calls.  Do not define
+A C expression that is nonzero if the register defined by
+@code{PIC_OFFSET_TABLE_REGNUM} is clobbered by calls.  If not defined,
+the default is zero.  Do not define
 this macro if @code{PIC_OFFSET_TABLE_REGNUM} is not defined.
 @end defmac
 
@@ -7250,7 +7281,14 @@ outputting a single uninitialized variable.
 A C statement (sans semicolon) to output to the stdio stream
 @var{stream} the assembler definition of a common-label named
 @var{name} whose size is @var{size} bytes.  The variable @var{rounded}
-is the size rounded up to whatever alignment the caller wants.
+is the size rounded up to whatever alignment the caller wants.  It is
+possible that @var{size} may be zero, for instance if a struct with no
+other member than a zero-length array is defined.  In this case, the
+backend must output a symbol definition that allocates at least one
+byte, both so that the address of the resulting object does not compare
+equal to any other, and because some object formats cannot even express
+the concept of a zero-sized common symbol, as that is how they represent
+an ordinary undefined external.
 
 Use the expression @code{assemble_name (@var{stream}, @var{name})} to
 output the name itself; before and after that, output the additional
@@ -8107,6 +8145,22 @@ registers, thus allowing the @code{asm} option in declarations to refer
 to registers using alternate names.
 @end defmac
 
+@defmac OVERLAPPING_REGISTER_NAMES
+If defined, a C initializer for an array of structures containing a
+name, a register number and a count of the number of consecutive
+machine registers the name overlaps.  This macro defines additional
+names for hard registers, thus allowing the @code{asm} option in
+declarations to refer to registers using alternate names.  Unlike
+@code{ADDITIONAL_REGISTER_NAMES}, this macro should be used when the
+register name implies multiple underlying registers.
+
+This macro should be used when it is important that a clobber in an
+@code{asm} statement clobbers all the underlying values implied by the
+register name.  For example, on ARM, clobbering the double-precision
+VFP register ``d0'' implies clobbering both single-precision registers
+``s0'' and ``s1''.
+@end defmac
+
 @defmac ASM_OUTPUT_OPCODE (@var{stream}, @var{ptr})
 Define this macro if you are using an unusual assembler that
 requires different names for the machine instructions.
@@ -8156,6 +8210,19 @@ writing conditional output routines in those patterns.
 If this macro is not defined, it is equivalent to a null statement.
 @end defmac
 
+@deftypefn {Target Hook} void TARGET_ASM_FINAL_POSTSCAN_INSN (FILE *@var{FILE}, rtx @var{insn}, rtx *@var{opvec}, int @var{noperands})
+If defined, this target hook is a function which is executed just after the
+output of assembler code for @var{insn}, to change the mode of the assembler
+if necessary.
+
+Here the argument @var{opvec} is the vector containing the operands
+extracted from @var{insn}, and @var{noperands} is the number of
+elements of the vector which contain meaningful data for this insn.
+The contents of this vector are what was used to convert the insn
+template into assembler code, so you can change the assembler mode
+by checking the contents of the vector.
+@end deftypefn
+
 @defmac PRINT_OPERAND (@var{stream}, @var{x}, @var{code})
 A C compound statement to output to stdio stream @var{stream} the
 assembler syntax for an instruction operand @var{x}.  @var{x} is an
@@ -10426,6 +10493,18 @@ to analyze inner elements of @var{x} in which case @var{flags} should be
 passed along.
 @end deftypefn
 
+@deftypefn {Target Hook} int TARGET_COMMUTATIVE_OPERAND_PRECEDENCE (const_rtx @var{op}, int @var{value})
+This target hook returns a value indicating whether @var{OP}, an operand of
+a commutative operation, is preferred as the first or second operand.
+The higher the value, the stronger the preference for being the first operand.
+Negative values are used to indicate a preference for the first operand
+and positive values for the second operand.  Usually the hook will return
+@var{VALUE}, which is the default precedence for @var{OP}
+(see @file{rtlanal.c}:@code{commutative_operand_precedence()}), but sometimes
+backends may wish certain operands to appear at the right places within
+instructions.
+@end deftypefn
+
 @deftypefn {Target Hook} void TARGET_SET_CURRENT_FUNCTION (tree @var{decl})
 The compiler invokes this hook whenever it changes its current function 
 context (@code{cfun}).  You can define this function if
@@ -10622,6 +10701,38 @@ and @var{type2}, or @code{NULL} if validity should be determined by
 the front end.
 @end deftypefn
 
+@deftypefn {Target Hook} {const char *} TARGET_INVALID_PARAMETER_TYPE (tree @var{type})
+If defined, this macro returns the diagnostic message when it is
+invalid for functions to include parameters of type @var{type}, 
+or @code{NULL} if validity should be determined by
+the front end.  This is currently used only by the C and C++ front ends.
+@end deftypefn
+
+@deftypefn {Target Hook} {const char *} TARGET_INVALID_RETURN_TYPE (tree @var{type})
+If defined, this macro returns the diagnostic message when it is
+invalid for functions to have return type @var{type}, 
+or @code{NULL} if validity should be determined by
+the front end.  This is currently used only by the C and C++ front ends.
+@end deftypefn
+
+@deftypefn {Target Hook} {tree} TARGET_PROMOTED_TYPE (tree @var{type})
+If defined, this target hook returns the type to which values of 
+@var{type} should be promoted when they appear in expressions, 
+analogous to the integer promotions, or @code{NULL_TREE} to use the
+front end's normal promotion rules.  This hook is useful when there are
+target-specific types with special promotion rules.
+This is currently used only by the C and C++ front ends.
+@end deftypefn
+
+@deftypefn {Target Hook} {tree} TARGET_CONVERT_TO_TYPE (tree @var{type}, tree @var{expr})
+If defined, this hook returns the result of converting @var{expr} to 
+@var{type}.  It should return the converted expression, 
+or @code{NULL_TREE} to apply the front end's normal conversion rules.
+This hook is useful when there are target-specific types with special 
+conversion rules.
+This is currently used only by the C and C++ front ends.
+@end deftypefn
+
 @defmac TARGET_USE_JCR_SECTION
 This macro determines whether to use the JCR section to register Java
 classes. By default, TARGET_USE_JCR_SECTION is defined to 1 if both
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index db31f7574..0c5610168 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -104,6 +104,9 @@ static void dwarf2out_source_line (unsigned int, const char *);
 # endif
 #endif
 
+#define NEED_UNWIND_TABLES \
+  (flag_unwind_tables || (flag_exceptions && ! USING_SJLJ_EXCEPTIONS))
+
 /* Map register numbers held in the call frame info that gcc has
    collected using DWARF_FRAME_REGNUM to those that should be output in
    .debug_frame and .eh_frame.  */
@@ -127,9 +130,7 @@ dwarf2out_do_frame (void)
 	  || write_symbols == VMS_AND_DWARF2_DEBUG
 	  || DWARF2_FRAME_INFO || saved_do_cfi_asm
 #ifdef DWARF2_UNWIND_INFO
-	  || (DWARF2_UNWIND_INFO
-	      && (flag_unwind_tables
-		  || (flag_exceptions && ! USING_SJLJ_EXCEPTIONS)))
+	  || (DWARF2_UNWIND_INFO && NEED_UNWIND_TABLES)
 #endif
 	  );
 }
@@ -2486,6 +2487,12 @@ dwarf2out_frame_debug (rtx insn, bool after_p)
     insn = PATTERN (insn);
 
   dwarf2out_frame_debug_expr (insn, label);
+
+  /* Check again.  A parallel can save and update the same register.
+     We could probably check just once, here, but this is safer than
+     removing the check above.  */
+  if (clobbers_queued_reg_save (insn))
+    flush_queued_reg_saves ();
 }
 
 #endif
@@ -3245,8 +3252,7 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,
   /* ??? current_function_func_begin_label is also used by except.c
      for call-site information.  We must emit this label if it might
      be used.  */
-  if ((! flag_exceptions || USING_SJLJ_EXCEPTIONS)
-      && ! dwarf2out_do_frame ())
+  if (! NEED_UNWIND_TABLES && ! dwarf2out_do_frame ())
     return;
 #else
   if (! dwarf2out_do_frame ())
@@ -3404,7 +3410,7 @@ dwarf2out_frame_finish (void)
 
 #ifndef TARGET_UNWIND_INFO
   /* Output another copy for the unwinder.  */
-  if (! USING_SJLJ_EXCEPTIONS && (flag_unwind_tables || flag_exceptions))
+  if (NEED_UNWIND_TABLES)
     output_call_frame_info (1);
 #endif
 }
@@ -4611,6 +4617,7 @@ static void dwarf2out_imported_module_or_decl_1 (tree, tree, tree,
 static void dwarf2out_abstract_function (tree);
 static void dwarf2out_var_location (rtx);
 static void dwarf2out_begin_function (tree);
+static void dwarf2out_set_name (tree, tree);
 
 /* The debug hooks structure.  */
 
@@ -4645,6 +4652,7 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =
   debug_nothing_int,		/* handle_pch */
   dwarf2out_var_location,
   dwarf2out_switch_text_section,
+  dwarf2out_set_name,
   1                             /* start_end_main_source_file */
 };
 #endif
@@ -5989,12 +5997,9 @@ debug_str_eq (const void *x1, const void *x2)
 		 (const char *)x2) == 0;
 }
 
-/* Add a string attribute value to a DIE.  */
-
-static inline void
-add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)
+static struct indirect_string_node *
+find_AT_string (const char *str)
 {
-  dw_attr_node attr;
   struct indirect_string_node *node;
   void **slot;
 
@@ -6015,6 +6020,18 @@ add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)
     node = (struct indirect_string_node *) *slot;
 
   node->refcount++;
+  return node;
+}
+
+/* Add a string attribute value to a DIE.  */
+
+static inline void
+add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)
+{
+  dw_attr_node attr;
+  struct indirect_string_node *node;
+
+  node = find_AT_string (str);
 
   attr.dw_attr = attr_kind;
   attr.dw_attr_val.val_class = dw_val_class_str;
@@ -6651,6 +6668,8 @@ decl_loc_table_eq (const void *x, const void *y)
 static inline var_loc_list *
 lookup_decl_loc (const_tree decl)
 {
+  if (!decl_loc_table)
+    return NULL;
   return (var_loc_list *)
     htab_find_with_hash (decl_loc_table, decl, DECL_UID (decl));
 }
@@ -13504,6 +13523,7 @@ dwarf2out_abstract_function (tree decl)
   tree save_fn;
   tree context;
   int was_abstract = DECL_ABSTRACT (decl);
+  htab_t old_decl_loc_table;
 
   /* Make sure we have the actual abstract inline, not a clone.  */
   decl = DECL_ORIGIN (decl);
@@ -13513,6 +13533,12 @@ dwarf2out_abstract_function (tree decl)
     /* We've already generated the abstract instance.  */
     return;
 
+  /* We can be called while recursively when seeing block defining inlined subroutine
+     DIE.  Be sure to not clobber the outer location table nor use it or we would
+     get locations in abstract instantces.  */
+  old_decl_loc_table = decl_loc_table;
+  decl_loc_table = NULL;
+
   /* Be sure we've emitted the in-class declaration DIE (if any) first, so
      we don't get confused by DECL_ABSTRACT.  */
   if (debug_info_level > DINFO_LEVEL_TERSE)
@@ -13534,6 +13560,7 @@ dwarf2out_abstract_function (tree decl)
     set_decl_abstract_flags (decl, 0);
 
   current_function_decl = save_fn;
+  decl_loc_table = old_decl_loc_table;
   pop_cfun ();
 }
 
@@ -15883,6 +15910,31 @@ maybe_emit_file (struct dwarf_file_data * fd)
   return fd->emitted_number;
 }
 
+/* Replace DW_AT_name for the decl with name.  */
+ 
+static void
+dwarf2out_set_name (tree decl, tree name)
+{
+  dw_die_ref die;
+  dw_attr_ref attr;
+
+  die = TYPE_SYMTAB_DIE (decl);
+  if (!die)
+    return;
+
+  attr = get_AT (die, DW_AT_name);
+  if (attr)
+    {
+      struct indirect_string_node *node;
+
+      node = find_AT_string (dwarf2_name (name, 0));
+      /* replace the string.  */
+      attr->dw_attr_val.v.val_str = node;
+    }
+
+  else
+    add_name_attribute (die, dwarf2_name (name, 0));
+}
 /* Called by the final INSN scan whenever we see a var location.  We
    use it to drop labels in the right places, and throw the location in
    our lookup table.  */
diff --git a/gcc/except.c b/gcc/except.c
index e6466918a..4e54ee478 100644
--- a/gcc/except.c
+++ b/gcc/except.c
@@ -3572,6 +3572,12 @@ output_ttype (tree type, int tt_format, int tt_format_size)
 	 paths below go through assemble_integer, which would take
 	 care of this for us.  */
       STRIP_NOPS (type);
+      if (TREE_CODE (type) == POINTER_PLUS_EXPR)
+	{
+	  gcc_assert (TREE_CODE (TREE_OPERAND (type, 1)) == INTEGER_CST);
+	  type = TREE_OPERAND (type, 0);
+	  STRIP_NOPS (type);
+	}
       if (TREE_CODE (type) == ADDR_EXPR)
 	{
 	  type = TREE_OPERAND (type, 0);
diff --git a/gcc/explow.c b/gcc/explow.c
index c9bf675d3..d43aad00d 100644
--- a/gcc/explow.c
+++ b/gcc/explow.c
@@ -1491,9 +1491,9 @@ hard_function_value (const_tree valtype, const_tree func, const_tree fntype,
    in which a scalar value of mode MODE was returned by a library call.  */
 
 rtx
-hard_libcall_value (enum machine_mode mode)
+hard_libcall_value (enum machine_mode mode, rtx fun)
 {
-  return LIBCALL_VALUE (mode);
+  return targetm.calls.libcall_value (mode, fun);
 }
 
 /* Look up the tree code for a given rtx code
diff --git a/gcc/expmed.c b/gcc/expmed.c
index b36d67bfb..09a93b53c 100644
--- a/gcc/expmed.c
+++ b/gcc/expmed.c
@@ -103,7 +103,8 @@ static int add_cost[2][NUM_MACHINE_MODES];
 static int neg_cost[2][NUM_MACHINE_MODES];
 static int shift_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];
 static int shiftadd_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];
-static int shiftsub_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];
+static int shiftsub0_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];
+static int shiftsub1_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];
 static int mul_cost[2][NUM_MACHINE_MODES];
 static int sdiv_cost[2][NUM_MACHINE_MODES];
 static int udiv_cost[2][NUM_MACHINE_MODES];
@@ -130,7 +131,8 @@ init_expmed (void)
     struct rtx_def shift;	rtunion shift_fld1;
     struct rtx_def shift_mult;	rtunion shift_mult_fld1;
     struct rtx_def shift_add;	rtunion shift_add_fld1;
-    struct rtx_def shift_sub;	rtunion shift_sub_fld1;
+    struct rtx_def shift_sub0;	rtunion shift_sub0_fld1;
+    struct rtx_def shift_sub1;	rtunion shift_sub1_fld1;
   } all;
 
   rtx pow2[MAX_BITS_PER_WORD];
@@ -201,9 +203,13 @@ init_expmed (void)
   XEXP (&all.shift_add, 0) = &all.shift_mult;
   XEXP (&all.shift_add, 1) = &all.reg;
 
-  PUT_CODE (&all.shift_sub, MINUS);
-  XEXP (&all.shift_sub, 0) = &all.shift_mult;
-  XEXP (&all.shift_sub, 1) = &all.reg;
+  PUT_CODE (&all.shift_sub0, MINUS);
+  XEXP (&all.shift_sub0, 0) = &all.shift_mult;
+  XEXP (&all.shift_sub0, 1) = &all.reg;
+
+  PUT_CODE (&all.shift_sub1, MINUS);
+  XEXP (&all.shift_sub1, 0) = &all.reg;
+  XEXP (&all.shift_sub1, 1) = &all.shift_mult;
 
   for (speed = 0; speed < 2; speed++)
     {
@@ -226,7 +232,8 @@ init_expmed (void)
 	  PUT_MODE (&all.shift, mode);
 	  PUT_MODE (&all.shift_mult, mode);
 	  PUT_MODE (&all.shift_add, mode);
-	  PUT_MODE (&all.shift_sub, mode);
+	  PUT_MODE (&all.shift_sub0, mode);
+	  PUT_MODE (&all.shift_sub1, mode);
 
 	  add_cost[speed][mode] = rtx_cost (&all.plus, SET, speed);
 	  neg_cost[speed][mode] = rtx_cost (&all.neg, SET, speed);
@@ -254,8 +261,8 @@ init_expmed (void)
 	    }
 
 	  shift_cost[speed][mode][0] = 0;
-	  shiftadd_cost[speed][mode][0] = shiftsub_cost[speed][mode][0]
-	    = add_cost[speed][mode];
+	  shiftadd_cost[speed][mode][0] = shiftsub0_cost[speed][mode][0]
+	    = shiftsub1_cost[speed][mode][0] = add_cost[speed][mode];
 
 	  n = MIN (MAX_BITS_PER_WORD, GET_MODE_BITSIZE (mode));
 	  for (m = 1; m < n; m++)
@@ -265,7 +272,8 @@ init_expmed (void)
 
 	      shift_cost[speed][mode][m] = rtx_cost (&all.shift, SET, speed);
 	      shiftadd_cost[speed][mode][m] = rtx_cost (&all.shift_add, SET, speed);
-	      shiftsub_cost[speed][mode][m] = rtx_cost (&all.shift_sub, SET, speed);
+	      shiftsub0_cost[speed][mode][m] = rtx_cost (&all.shift_sub0, SET, speed);
+	      shiftsub1_cost[speed][mode][m] = rtx_cost (&all.shift_sub1, SET, speed);
 	    }
 	}
     }
@@ -2397,6 +2405,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,
   struct mult_cost best_cost;
   struct mult_cost new_limit;
   int op_cost, op_latency;
+  unsigned HOST_WIDE_INT orig_t = t;
   unsigned HOST_WIDE_INT q;
   int maxm = MIN (BITS_PER_WORD, GET_MODE_BITSIZE (mode));
   int hash_index;
@@ -2542,6 +2551,38 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,
 	      best_alg->log[best_alg->ops] = m;
 	      best_alg->op[best_alg->ops] = alg_shift;
 	    }
+
+	  /* See if treating ORIG_T as a signed number yields a better
+	     sequence.  Try this sequence only for a negative ORIG_T
+	     as it would be useless for a non-negative ORIG_T.  */
+	  if ((HOST_WIDE_INT) orig_t < 0)
+	    {
+	      /* Shift ORIG_T as follows because a right shift of a
+		 negative-valued signed type is implementation
+		 defined.  */
+	      q = ~(~orig_t >> m);
+	      /* The function expand_shift will choose between a shift
+		 and a sequence of additions, so the observed cost is
+		 given as MIN (m * add_cost[speed][mode],
+		 shift_cost[speed][mode][m]).  */
+	      op_cost = m * add_cost[speed][mode];
+	      if (shift_cost[speed][mode][m] < op_cost)
+		op_cost = shift_cost[speed][mode][m];
+	      new_limit.cost = best_cost.cost - op_cost;
+	      new_limit.latency = best_cost.latency - op_cost;
+	      synth_mult (alg_in, q, &new_limit, mode);
+
+	      alg_in->cost.cost += op_cost;
+	      alg_in->cost.latency += op_cost;
+	      if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))
+		{
+		  struct algorithm *x;
+		  best_cost = alg_in->cost;
+		  x = alg_in, alg_in = best_alg, best_alg = x;
+		  best_alg->log[best_alg->ops] = m;
+		  best_alg->op[best_alg->ops] = alg_shift;
+		}
+	    }
 	}
       if (cache_hit)
 	goto done;
@@ -2604,6 +2645,29 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,
 	      best_alg->op[best_alg->ops] = alg_add_t_m2;
 	    }
 	}
+
+      /* We may be able to calculate a * -7, a * -15, a * -31, etc
+	 quickly with a - a * n for some appropriate constant n.  */
+      m = exact_log2 (-orig_t + 1);
+      if (m >= 0 && m < maxm)
+	{
+	  op_cost = shiftsub1_cost[speed][mode][m];
+	  new_limit.cost = best_cost.cost - op_cost;
+	  new_limit.latency = best_cost.latency - op_cost;
+	  synth_mult (alg_in, (unsigned HOST_WIDE_INT) (-orig_t + 1) >> m, &new_limit, mode);
+
+	  alg_in->cost.cost += op_cost;
+	  alg_in->cost.latency += op_cost;
+	  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))
+	    {
+	      struct algorithm *x;
+	      best_cost = alg_in->cost;
+	      x = alg_in, alg_in = best_alg, best_alg = x;
+	      best_alg->log[best_alg->ops] = m;
+	      best_alg->op[best_alg->ops] = alg_sub_t_m2;
+	    }
+	}
+
       if (cache_hit)
 	goto done;
     }
@@ -2673,9 +2737,9 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,
 	     hardware the shift may be executed concurrently with the
 	     earlier steps in the algorithm.  */
 	  op_cost = add_cost[speed][mode] + shift_cost[speed][mode][m];
-	  if (shiftsub_cost[speed][mode][m] < op_cost)
+	  if (shiftsub0_cost[speed][mode][m] < op_cost)
 	    {
-	      op_cost = shiftsub_cost[speed][mode][m];
+	      op_cost = shiftsub0_cost[speed][mode][m];
 	      op_latency = op_cost;
 	    }
 	  else
@@ -2738,7 +2802,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,
       m = exact_log2 (q);
       if (m >= 0 && m < maxm)
 	{
-	  op_cost = shiftsub_cost[speed][mode][m];
+	  op_cost = shiftsub0_cost[speed][mode][m];
 	  new_limit.cost = best_cost.cost - op_cost;
 	  new_limit.latency = best_cost.latency - op_cost;
 	  synth_mult (alg_in, (t + 1) >> m, &new_limit, mode);
diff --git a/gcc/expr.c b/gcc/expr.c
index 8cc28fb88..6374a9bbd 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -4391,6 +4391,29 @@ expand_assignment (tree to, tree from, bool nontemporal)
 
   /* Compute FROM and store the value in the rtx we got.  */
 
+  if (TREE_CODE (to) == MISALIGNED_INDIRECT_REF)
+    {
+      rtx insn;
+      rtx from_rtx;
+      enum insn_code icode;
+      enum machine_mode mode = GET_MODE (to_rtx);
+
+      icode = optab_handler (movmisalign_optab, mode)->insn_code;
+      gcc_assert (icode != CODE_FOR_nothing);
+
+      from_rtx = expand_expr (from, NULL_RTX, mode, EXPAND_NORMAL);
+      insn = GEN_FCN (icode) (to_rtx, from_rtx);
+      /* If that failed then force the source into a reg and try again.  */
+      if (!insn)
+	{
+	  from_rtx = copy_to_mode_reg(mode, from_rtx);
+	  insn = GEN_FCN (icode) (to_rtx, from_rtx);
+	  gcc_assert(insn);
+	}
+      emit_insn (insn);
+      return;
+    }
+
   push_temp_slots ();
   result = store_expr (from, to_rtx, 0, nontemporal);
   preserve_temp_slots (result);
@@ -7294,6 +7317,19 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,
       decl_rtl = DECL_RTL (exp);
       gcc_assert (decl_rtl);
       decl_rtl = copy_rtx (decl_rtl);
+      /* Record writes to register variables.  */
+      if (modifier == EXPAND_WRITE && REG_P(decl_rtl)
+	  && REGNO(decl_rtl) < FIRST_PSEUDO_REGISTER)
+	{
+	    int i = REGNO(decl_rtl);
+	    int nregs = hard_regno_nregs[i][GET_MODE(decl_rtl)];
+	    while (nregs)
+	      {
+		SET_HARD_REG_BIT(crtl->asm_clobbers, i);
+		i++;
+		nregs--;
+	      }
+	}
 
       /* Ensure variable marked as used even if it doesn't go through
 	 a parser.  If it hasn't be used yet, write out an external
@@ -7541,14 +7577,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,
 
 	/* Resolve the misalignment now, so that we don't have to remember
 	   to resolve it later.  Of course, this only works for reads.  */
-	/* ??? When we get around to supporting writes, we'll have to handle
-	   this in store_expr directly.  The vectorizer isn't generating
-	   those yet, however.  */
 	if (code == MISALIGNED_INDIRECT_REF)
 	  {
 	    int icode;
 	    rtx reg, insn;
 
+	    /* For writes produce a MEM, and expand_assignment will DTRT.  */
+	    if (modifier == EXPAND_WRITE)
+	      return temp;
+
 	    gcc_assert (modifier == EXPAND_NORMAL
 			|| modifier == EXPAND_STACK_PARM);
 
diff --git a/gcc/expr.h b/gcc/expr.h
index 79543ccec..426027b96 100644
--- a/gcc/expr.h
+++ b/gcc/expr.h
@@ -757,7 +757,7 @@ extern void probe_stack_range (HOST_WIDE_INT, rtx);
 
 /* Return an rtx that refers to the value returned by a library call
    in its original home.  This becomes invalid if any more code is emitted.  */
-extern rtx hard_libcall_value (enum machine_mode);
+extern rtx hard_libcall_value (enum machine_mode, rtx);
 
 /* Return the mode desired by operand N of a particular bitfield
    insert/extract insn, or MAX_MACHINE_MODE if no such insn is
diff --git a/gcc/final.c b/gcc/final.c
index c4812eac0..68c058a55 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -891,6 +891,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)
       if (LABEL_P (insn))
 	{
 	  rtx next;
+	  bool next_is_jumptable;
 
 	  /* Merge in alignments computed by compute_alignments.  */
 	  log = LABEL_TO_ALIGNMENT (insn);
@@ -900,31 +901,30 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)
 	      max_skip = LABEL_TO_MAX_SKIP (insn);
 	    }
 
-	  log = LABEL_ALIGN (insn);
-	  if (max_log < log)
+	  next = next_nonnote_insn (insn);
+	  next_is_jumptable = next && JUMP_TABLE_DATA_P (next);
+	  if (!next_is_jumptable)
 	    {
-	      max_log = log;
-	      max_skip = LABEL_ALIGN_MAX_SKIP;
+	      log = LABEL_ALIGN (insn);
+	      if (max_log < log)
+		{
+		  max_log = log;
+		  max_skip = LABEL_ALIGN_MAX_SKIP;
+		}
 	    }
-	  next = next_nonnote_insn (insn);
 	  /* ADDR_VECs only take room if read-only data goes into the text
 	     section.  */
-	  if (JUMP_TABLES_IN_TEXT_SECTION
-	      || readonly_data_section == text_section)
-	    if (next && JUMP_P (next))
-	      {
-		rtx nextbody = PATTERN (next);
-		if (GET_CODE (nextbody) == ADDR_VEC
-		    || GET_CODE (nextbody) == ADDR_DIFF_VEC)
-		  {
-		    log = ADDR_VEC_ALIGN (next);
-		    if (max_log < log)
-		      {
-			max_log = log;
-			max_skip = LABEL_ALIGN_MAX_SKIP;
-		      }
-		  }
-	      }
+	  if ((JUMP_TABLES_IN_TEXT_SECTION
+	       || readonly_data_section == text_section)
+	      && next_is_jumptable)
+	    {
+	      log = ADDR_VEC_ALIGN (next);
+	      if (max_log < log)
+		{
+		  max_log = log;
+		  max_skip = LABEL_ALIGN_MAX_SKIP;
+		}
+	    }
 	  LABEL_TO_ALIGNMENT (insn) = max_log;
 	  LABEL_TO_MAX_SKIP (insn) = max_skip;
 	  max_log = 0;
@@ -2013,48 +2013,41 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,
       app_disable ();
 
       next = next_nonnote_insn (insn);
-      if (next != 0 && JUMP_P (next))
+      /* If this label is followed by a jump-table, make sure we put
+	 the label in the read-only section.  Also possibly write the
+	 label and jump table together.  */
+      if (next != 0 && JUMP_TABLE_DATA_P (next))
 	{
-	  rtx nextbody = PATTERN (next);
-
-	  /* If this label is followed by a jump-table,
-	     make sure we put the label in the read-only section.  Also
-	     possibly write the label and jump table together.  */
-
-	  if (GET_CODE (nextbody) == ADDR_VEC
-	      || GET_CODE (nextbody) == ADDR_DIFF_VEC)
-	    {
 #if defined(ASM_OUTPUT_ADDR_VEC) || defined(ASM_OUTPUT_ADDR_DIFF_VEC)
-	      /* In this case, the case vector is being moved by the
-		 target, so don't output the label at all.  Leave that
-		 to the back end macros.  */
+	  /* In this case, the case vector is being moved by the
+	     target, so don't output the label at all.  Leave that
+	     to the back end macros.  */
 #else
-	      if (! JUMP_TABLES_IN_TEXT_SECTION)
-		{
-		  int log_align;
+	  if (! JUMP_TABLES_IN_TEXT_SECTION)
+	    {
+	      int log_align;
 
-		  switch_to_section (targetm.asm_out.function_rodata_section
-				     (current_function_decl));
+	      switch_to_section (targetm.asm_out.function_rodata_section
+				 (current_function_decl));
 
 #ifdef ADDR_VEC_ALIGN
-		  log_align = ADDR_VEC_ALIGN (next);
+	      log_align = ADDR_VEC_ALIGN (next);
 #else
-		  log_align = exact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT);
+	      log_align = exact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT);
 #endif
-		  ASM_OUTPUT_ALIGN (file, log_align);
-		}
-	      else
-		switch_to_section (current_function_section ());
+	      ASM_OUTPUT_ALIGN (file, log_align);
+	    }
+	  else
+	    switch_to_section (current_function_section ());
 
 #ifdef ASM_OUTPUT_CASE_LABEL
-	      ASM_OUTPUT_CASE_LABEL (file, "L", CODE_LABEL_NUMBER (insn),
-				     next);
+	  ASM_OUTPUT_CASE_LABEL (file, "L", CODE_LABEL_NUMBER (insn),
+				 next);
 #else
-	      targetm.asm_out.internal_label (file, "L", CODE_LABEL_NUMBER (insn));
+	  targetm.asm_out.internal_label (file, "L", CODE_LABEL_NUMBER (insn));
 #endif
 #endif
-	      break;
-	    }
+	  break;
 	}
       if (LABEL_ALT_ENTRY_P (insn))
 	output_alternate_entry_point (file, insn);
@@ -2240,6 +2233,10 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,
 #endif
 	      }
 
+	    if (targetm.asm_out.final_postscan_insn)
+	      targetm.asm_out.final_postscan_insn (file, insn, ops,
+						   insn_noperands);
+
 	    this_is_asm_operands = 0;
 	    break;
 	  }
@@ -2642,6 +2639,12 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,
 	/* Output assembler code from the template.  */
 	output_asm_insn (templ, recog_data.operand);
 
+	/* Some target machines need to postscan each insn after
+	   it is output.  */
+	if (targetm.asm_out.final_postscan_insn)
+	  targetm.asm_out.final_postscan_insn (file, insn, recog_data.operand,
+					       recog_data.n_operands);
+
 	/* If necessary, report the effect that the instruction has on
 	   the unwind info.   We've already done this for delay slots
 	   and call instructions.  */
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 5c549c589..ab48f1c4a 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -2293,7 +2293,24 @@ fold_convert_const_real_from_real (tree type, const_tree arg1)
   real_convert (&value, TYPE_MODE (type), &TREE_REAL_CST (arg1));
   t = build_real (type, value);
 
-  TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1);
+  /* If converting an infinity or NAN to a representation that doesn't
+     have one, set the overflow bit so that we can produce some kind of
+     error message at the appropriate point if necessary.  It's not the
+     most user-friendly message, but it's better than nothing.  */
+  if (REAL_VALUE_ISINF (TREE_REAL_CST (arg1))
+      && !MODE_HAS_INFINITIES (TYPE_MODE (type)))
+    TREE_OVERFLOW (t) = 1;
+  else if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1))
+	   && !MODE_HAS_NANS (TYPE_MODE (type)))
+    TREE_OVERFLOW (t) = 1;
+  /* Regular overflow, conversion produced an infinity in a mode that
+     can't represent them.  */
+  else if (!MODE_HAS_INFINITIES (TYPE_MODE (type))
+	   && REAL_VALUE_ISINF (value)
+	   && !REAL_VALUE_ISINF (TREE_REAL_CST (arg1)))
+    TREE_OVERFLOW (t) = 1;
+  else
+    TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1);
   return t;
 }
 
diff --git a/gcc/fortran/Make-lang.in b/gcc/fortran/Make-lang.in
index 1600d18b3..cda2e9713 100644
--- a/gcc/fortran/Make-lang.in
+++ b/gcc/fortran/Make-lang.in
@@ -26,7 +26,7 @@
 #
 # foo.all.cross, foo.start.encap, foo.rest.encap,
 # foo.install-common, foo.install-man, foo.install-info, foo.install-pdf,
-# foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
+# foo.install-html, foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
 # foo.mostlyclean, foo.clean, foo.distclean,
 # foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4
 #
@@ -118,7 +118,27 @@ fortran.tags: force
 
 fortran.info: doc/gfortran.info doc/gfc-internals.info
 fortran.dvi: doc/gfortran.dvi doc/gfc-internals.dvi
-fortran.html: $(build_htmldir)/gfortran/index.html
+
+F95_HTMLFILES = $(build_htmldir)/gfortran
+
+fortran.html: $(F95_HTMLFILES)/index.html
+
+fortran.install-html: $(F95_HTMLFILES)
+	@$(NORMAL_INSTALL)
+	test -z "$(htmldir)" || $(mkinstalldirs) "$(DESTDIR)$(htmldir)"
+	@list='$(F95_HTMLFILES)'; for p in $$list; do \
+	  if test -f "$$p" || test -d "$$p"; then d=""; else d="$(srcdir)/"; fi; \
+	  f=$(html__strip_dir) \
+	  if test -d "$$d$$p"; then \
+	    echo " $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(mkinstalldirs) "$(DESTDIR)$(htmldir)/$$f" || exit 1; \
+	    echo " $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p"/* "$(DESTDIR)$(htmldir)/$$f"; \
+	  else \
+	    echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(htmldir)/$$f"; \
+	  fi; \
+	done
 
 F95_PDFFILES = doc/gfortran.pdf
 
diff --git a/gcc/fortran/cpp.c b/gcc/fortran/cpp.c
index d8cdc333b..1d1177a52 100644
--- a/gcc/fortran/cpp.c
+++ b/gcc/fortran/cpp.c
@@ -144,6 +144,9 @@ static void cb_include (cpp_reader *, source_location, const unsigned char *,
 static void cb_ident (cpp_reader *, source_location, const cpp_string *);
 static void cb_used_define (cpp_reader *, source_location, cpp_hashnode *);
 static void cb_used_undef (cpp_reader *, source_location, cpp_hashnode *);
+static bool cb_cpp_error (cpp_reader *, int, location_t, unsigned int,
+			  const char *, va_list *)
+     ATTRIBUTE_GCC_DIAG(5,0);
 void pp_dir_change (cpp_reader *, const char *);
 
 static int dump_macro (cpp_reader *, cpp_hashnode *, void *);
@@ -523,7 +526,6 @@ gfc_cpp_post_options (void)
   cpp_option->cplusplus_comments = 0;
 
   cpp_option->pedantic = pedantic;
-  cpp_option->inhibit_warnings = inhibit_warnings;
 
   cpp_option->dollars_in_ident = gfc_option.flag_dollar_ok;
   cpp_option->discard_comments = gfc_cpp_option.discard_comments;
@@ -547,9 +549,6 @@ gfc_cpp_post_options (void)
 
   cpp_post_options (cpp_in);
 
-  /* If an error has occurred in cpplib, note it so we fail immediately.  */
-  errorcount += cpp_errors (cpp_in);
-
   gfc_cpp_register_include_paths ();
 }
 
@@ -564,6 +563,7 @@ gfc_cpp_init_0 (void)
   cb->line_change = cb_line_change;
   cb->ident = cb_ident;
   cb->def_pragma = cb_def_pragma;
+  cb->error = cb_cpp_error;
 
   if (gfc_cpp_option.dump_includes)
     cb->include = cb_include;
@@ -1059,6 +1059,57 @@ cb_used_define (cpp_reader *pfile, source_location line ATTRIBUTE_UNUSED,
   cpp_define_queue = q;
 }
 
+/* Callback from cpp_error for PFILE to print diagnostics from the
+   preprocessor.  The diagnostic is of type LEVEL, at location
+   LOCATION, with column number possibly overridden by COLUMN_OVERRIDE
+   if not zero; MSG is the translated message and AP the arguments.
+   Returns true if a diagnostic was emitted, false otherwise.  */
+
+static bool
+cb_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level,
+	      location_t location, unsigned int column_override,
+	      const char *msg, va_list *ap)
+{
+  diagnostic_info diagnostic;
+  diagnostic_t dlevel;
+  int save_warn_system_headers = warn_system_headers;
+  bool ret;
+
+  switch (level)
+    {
+    case CPP_DL_WARNING_SYSHDR:
+      warn_system_headers = 1;
+      /* Fall through.  */
+    case CPP_DL_WARNING:
+      dlevel = DK_WARNING;
+      break;
+    case CPP_DL_PEDWARN:
+      dlevel = DK_PEDWARN;
+      break;
+    case CPP_DL_ERROR:
+      dlevel = DK_ERROR;
+      break;
+    case CPP_DL_ICE:
+      dlevel = DK_ICE;
+      break;
+    case CPP_DL_NOTE:
+      dlevel = DK_NOTE;
+      break;
+    case CPP_DL_FATAL:
+      dlevel = DK_FATAL;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  diagnostic_set_info_translated (&diagnostic, msg, ap,
+				  location, dlevel);
+  if (column_override)
+    diagnostic_override_column (&diagnostic, column_override);
+  ret = report_diagnostic (&diagnostic);
+  if (level == CPP_DL_WARNING_SYSHDR)
+    warn_system_headers = save_warn_system_headers;
+  return ret;
+}
 
 /* Callback called when -fworking-director and -E to emit working
    directory in cpp output file.  */
diff --git a/gcc/function.c b/gcc/function.c
index cba4a0509..13147d395 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -276,7 +276,10 @@ get_stack_local_alignment (tree type, enum machine_mode mode)
   if (! type)
     type = lang_hooks.types.type_for_mode (mode, 0);
 
-  return STACK_SLOT_ALIGNMENT (type, mode, alignment);
+  return alignment_for_aligned_arrays (type,
+				       STACK_SLOT_ALIGNMENT (type,
+							     mode,
+							     alignment));
 }
 
 /* Allocate a stack slot of SIZE bytes and return a MEM rtx for it
@@ -5359,6 +5362,57 @@ current_function_assembler_name (void)
 {
   return IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (cfun->decl));
 }
+
+/* This function adjusts alignments as appropriate according to the
+   setting of -falign-arrays.  If that is specified then the minimum
+   alignment for array variables is set to be the largest power of two
+   less than or equal to their total storage size, or the biggest
+   alignment used on the machine, whichever is smaller.  */
+
+unsigned int
+alignment_for_aligned_arrays (tree ty, unsigned int existing_alignment)
+{
+  unsigned int min_alignment;
+  tree size;
+
+  /* Return the existing alignment if not using -falign-arrays or if
+     the type is not an array type.  */
+  if (!flag_align_arrays || !ty || TREE_CODE (ty) != ARRAY_TYPE)
+    return existing_alignment;
+
+  /* Extract the total storage size of the array in bits.  */
+  size = TYPE_SIZE (ty);
+  gcc_assert (size);
+
+  /* At least for variable-length arrays, TREE_CODE (size) might not be an
+     integer constant; check it now.  If it is not, give the array at
+     least BIGGEST_ALIGNMENT just to be safe.   Furthermore, we assume that
+     alignments always fit into a host integer.  So if we can't fit the
+     size of the array in bits into a host integer, it must also be large
+     enough to deserve at least BIGGEST_ALIGNMENT (see below).  */
+  if (TREE_CODE (size) != INTEGER_CST || !host_integerp (size, 1))
+    min_alignment = BIGGEST_ALIGNMENT;
+  else
+    {
+      unsigned HOST_WIDE_INT bits = TREE_INT_CST_LOW (size);
+      bits = (bits ? bits : 1);
+
+      /* An array with size greater than BIGGEST_ALIGNMENT is assigned
+	 at least that alignment.  In all other cases the minimum
+	 alignment of the array is set to be the largest power of two
+	 less than or equal to the total storage size of the array.
+	 We assume that BIGGEST_ALIGNMENT fits in "unsigned int"; thus,
+	 the shift below will not overflow.  */
+      if (bits >= BIGGEST_ALIGNMENT)
+	min_alignment = BIGGEST_ALIGNMENT;
+      else
+	min_alignment = 1 << (floor_log2 (bits));
+    }
+
+  /* Having computed the minimum permissible alignment, enlarge it
+     if EXISTING_ALIGNMENT is greater.  */
+  return MAX (min_alignment, existing_alignment); 
+}
 
 
 static unsigned int
diff --git a/gcc/function.h b/gcc/function.h
index 95753194a..b7e44ac87 100644
--- a/gcc/function.h
+++ b/gcc/function.h
@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree.h"
 #include "hashtab.h"
 #include "varray.h"
+#include "hard-reg-set.h"
 
 /* Stack of pending (incomplete) sequences saved by `start_sequence'.
    Each element describes one pending sequence.
@@ -441,6 +442,8 @@ struct rtl_data GTY(())
 
   /* True if dbr_schedule has already been called for this function.  */
   bool dbr_scheduled_p;
+
+  HARD_REG_SET asm_clobbers;
 };
 
 #define return_label (crtl->x_return_label)
@@ -709,4 +712,7 @@ extern bool reference_callee_copied (CUMULATIVE_ARGS *, enum machine_mode,
 extern void used_types_insert (tree);
 
 extern int get_next_funcdef_no (void);
+
+extern unsigned int alignment_for_aligned_arrays (tree, unsigned int);
+
 #endif  /* GCC_FUNCTION_H */
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 1f1d85f0e..20d1df7f4 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -229,6 +229,16 @@ static int combine_flag = 0;
 
 static int use_pipes;
 
+/* Nonzero means that libgcc is being linked automatically by the
+   compiler from its normal installed location; that is, neither -B,
+   -nostdlib nor -nodefaultlibs was passed.  */
+
+static int using_libgcc = 1;
+
+/* Nonzero means that the current spec is executing the linker.  */
+
+static int executing_linker = 0;
+
 /* The compiler version.  */
 
 static const char *compiler_version;
@@ -651,8 +661,32 @@ proper position among the other output files.  */
 
 /* config.h can define SWITCHES_NEED_SPACES to control which options
    require spaces between the option and the argument.  */
+/* GCC Bugzilla PR11810 indicates that GCC does not correctly handle
+   "-ofoo.o", in that it records "-ofoo.o" as a temporary file to
+   delete, rather than "foo.o".  
+
+   Unfortunately, Eclipse's makefile generators use the "-ofoo.o"
+   form.  See also CS Issue #3433.  So, although most users probably
+   use "-o foo.o", the "-ofoo.o" form is used in practice.
+
+   See this email thread for additional information:
+
+     http://gcc.gnu.org/ml/gcc/2008-07/msg00395.html
+
+   Therefore, we define SWITCHES_NEED_SPACES to include "o" by
+   default.  This causes "-ofoo.o" to be split into "-o foo.o" during
+   the initial processing of the command-line, before being seen by
+   the specs machinery.
+ 
+   A risk of this change is that tools which *require* the "-ofoo.o"
+   form will no longer work.  However, we know of no such tools, and
+   they would not have worked with the "-o foo.o" form anyhow.  
+
+   If this general strategy is acceptable upstream, the best approach
+   might be simply to eliminate this macro, since the only definitions
+   in target files are also to the value "o".  */
 #ifndef SWITCHES_NEED_SPACES
-#define SWITCHES_NEED_SPACES ""
+#define SWITCHES_NEED_SPACES "o"
 #endif
 
 /* config.h can define ENDFILE_SPEC to override the default crtn files.  */
@@ -717,6 +751,13 @@ proper position among the other output files.  */
 #endif
 #endif
 
+#ifndef LINK_BUILDID_SPEC
+# if defined(HAVE_LD_BUILDID) && defined(ENABLE_LD_BUILDID)
+#  define LINK_BUILDID_SPEC "%{!r:--build-id} "
+# endif
+#endif
+
+
 /* -u* was put back because both BSD and SysV seem to support it.  */
 /* %{static:} simply prevents an error message if the target machine
    doesn't handle -static.  */
@@ -728,6 +769,8 @@ proper position among the other output files.  */
 %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
     %(linker) %l " LINK_PIE_SPEC "%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\
     %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\
+    %{Wno-poison-system-directories:--no-poison-system-directories}\
+    %{Werror=poison-system-directories:--error-poison-system-directories}\
     %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\
     %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)} %(mflib)\
     %{fprofile-arcs|fprofile-generate|coverage:-lgcov}\
@@ -882,7 +925,7 @@ static const char *const multilib_defaults_raw[] = MULTILIB_DEFAULTS;
 #endif
 
 static const char *const driver_self_specs[] = {
-  DRIVER_SELF_SPECS, GOMP_SELF_SPECS
+  DRIVER_SELF_SPECS, CONFIGURE_SPECS, GOMP_SELF_SPECS
 };
 
 #ifndef OPTION_DEFAULT_SPECS
@@ -1831,9 +1874,16 @@ init_spec (void)
     asm_spec = XOBFINISH (&obstack, const char *);
   }
 #endif
-#ifdef LINK_EH_SPEC
+
+#if defined LINK_EH_SPEC || defined LINK_BUILDID_SPEC
+# ifdef LINK_BUILDID_SPEC
+  /* Prepend LINK_BUILDID_SPEC to whatever link_spec we had before.  */
+  obstack_grow (&obstack, LINK_BUILDID_SPEC, sizeof(LINK_BUILDID_SPEC) - 1);
+# endif
+# ifdef LINK_EH_SPEC
   /* Prepend LINK_EH_SPEC to whatever link_spec we had before.  */
   obstack_grow (&obstack, LINK_EH_SPEC, sizeof(LINK_EH_SPEC) - 1);
+# endif
   obstack_grow0 (&obstack, link_spec, strlen (link_spec));
   link_spec = XOBFINISH (&obstack, const char *);
 #endif
@@ -2853,6 +2903,29 @@ execute (void)
 
   gcc_assert (!processing_spec_function);
 
+  if (executing_linker && using_libgcc)
+    {
+      const char *libgcc_a_filename;
+
+      /* Verify that the multilib being used is actually installed.  */
+      libgcc_a_filename = (gcc_exec_prefix
+			   ? gcc_exec_prefix
+			   : concat (standard_exec_prefix,
+				     machine_suffix, NULL));
+      if (multilib_dir && strcmp (multilib_dir, ".") != 0)
+	libgcc_a_filename = concat (libgcc_a_filename, multilib_dir,
+				    dir_separator_str, NULL);
+      libgcc_a_filename = concat (libgcc_a_filename, "libgcc.a", NULL);
+      if (access (libgcc_a_filename, R_OK) != 0)
+	{
+	  if (errno == ENOENT)
+	    fatal ("selected multilib '%s' not installed",
+		   multilib_dir ? multilib_dir : ".");
+	  else
+	    pfatal_with_name (libgcc_a_filename);
+	}
+    }
+
   if (wrapper_string)
     {
       string = find_a_file (&exec_prefixes, argbuf[0], X_OK, false);
@@ -3688,6 +3761,16 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
 	  add_assembler_option ("--target-help", 13);
 	  add_linker_option ("--target-help", 13);
 	}
+      else if (! strcmp (argv[i], "-nodefaultlibs"))
+	{
+	  using_libgcc = 0;
+	  n_switches++;
+	}
+      else if (! strcmp (argv[i], "-nostdlib"))
+	{
+	  using_libgcc = 0;
+	  n_switches++;
+	}
       else if (! strcmp (argv[i], "-pass-exit-codes"))
 	{
 	  pass_exit_codes = 1;
@@ -3905,6 +3988,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
 			    PREFIX_PRIORITY_B_OPT, 0, 0);
 		add_prefix (&include_prefixes, value, NULL,
 			    PREFIX_PRIORITY_B_OPT, 0, 0);
+		using_libgcc = 0;
 		n_switches++;
 	      }
 	      break;
@@ -4616,27 +4700,53 @@ do_self_spec (const char *spec)
 
   if (argbuf_index > 0)
     {
-      int i, first;
+      int i, first, n;
 
       first = n_switches;
-      n_switches += argbuf_index;
-      switches = XRESIZEVEC (struct switchstr, switches, n_switches + 1);
+      n = n_switches + argbuf_index;
+      switches = XRESIZEVEC (struct switchstr, switches, n + 1);
+      switches[n] = switches[first];
 
       switches[n_switches] = switches[first];
       for (i = 0; i < argbuf_index; i++)
 	{
 	  struct switchstr *sw;
+	  const char *p = &argbuf[i][1];
+	  int c = *p;
 
 	  /* Each switch should start with '-'.  */
 	  if (argbuf[i][0] != '-')
 	    fatal ("switch '%s' does not start with '-'", argbuf[i]);
 
-	  sw = &switches[i + first];
+	  sw = &switches[n_switches];
 	  sw->part1 = &argbuf[i][1];
 	  sw->args = 0;
 	  sw->live_cond = 0;
 	  sw->validated = 0;
 	  sw->ordering = 0;
+
+	  /* Deal with option arguments in separate argv elements.  */
+	  if ((SWITCH_TAKES_ARG (c) > (p[1] != 0))
+	      || WORD_SWITCH_TAKES_ARG (p))
+	    {
+	      int j = 0;
+	      int n_args = WORD_SWITCH_TAKES_ARG (p);
+
+	      if (n_args == 0)
+		{
+		  /* Count only the option arguments in separate argv elements.  */
+		  n_args = SWITCH_TAKES_ARG (c) - (p[1] != 0);
+		}
+	      if (i + n_args >= argbuf_index)
+		fatal ("argument to '-%s' is missing", p);
+	      switches[n_switches].args
+		= XNEWVEC (const char *, n_args + 1);
+	      while (j < n_args)
+		switches[n_switches].args[j++] = argbuf[++i];
+	      /* Null-terminate the vector.  */
+	      switches[n_switches].args[j] = 0;
+	    }
+	  n_switches++;
 	}
     }
 }
@@ -6873,7 +6983,9 @@ main (int argc, char **argv)
 		    " to the linker.\n\n"));
 	  fflush (stdout);
 	}
+      executing_linker = 1;
       value = do_spec (link_command_spec);
+      executing_linker = 0;
       if (value < 0)
 	error_count = 1;
       linker_was_run = (tmp != execution_count);
diff --git a/gcc/gcse.c b/gcc/gcse.c
index 1869ea716..6b44b0b4c 100644
--- a/gcc/gcse.c
+++ b/gcc/gcse.c
@@ -172,6 +172,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "hashtab.h"
 #include "df.h"
 #include "dbgcnt.h"
+#include "target.h"
 
 /* Propagate flow information through back edges and thus enable PRE's
    moving loop invariant calculations out of loops.
@@ -1203,7 +1204,11 @@ want_to_gcse_p (rtx x)
 
 static GTY(()) rtx test_insn;
 
-/* Return true if we can assign X to a pseudo register.  */
+/* Return true if we can assign X to a pseudo register.
+
+   Additionally, if the target requires it, check that the resulting insn
+   can be copied.  If it cannot, this means that X is special and probably
+   has hidden side-effects we don't want to mess with.  */
 
 static bool
 can_assign_to_reg_p (rtx x)
@@ -1233,8 +1238,18 @@ can_assign_to_reg_p (rtx x)
      valid.  */
   PUT_MODE (SET_DEST (PATTERN (test_insn)), GET_MODE (x));
   SET_SRC (PATTERN (test_insn)) = x;
-  return ((icode = recog (PATTERN (test_insn), test_insn, &num_clobbers)) >= 0
-	  && (num_clobbers == 0 || ! added_clobbers_hard_reg_p (icode)));
+  
+  icode = recog (PATTERN (test_insn), test_insn, &num_clobbers);
+  if (icode < 0)
+    return false;
+  
+  if (num_clobbers > 0 && added_clobbers_hard_reg_p (icode))
+    return false;
+  
+  if (targetm.cannot_copy_insn_p && targetm.cannot_copy_insn_p (test_insn))
+    return false;
+  
+  return true;
 }
 
 /* Return nonzero if the operands of expression X are unchanged from the
@@ -1744,7 +1759,9 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)
 	     REG_EQUIV notes and if the argument slot is used somewhere
 	     explicitly, it means address of parameter has been taken,
 	     so we should not extend the lifetime of the pseudo.  */
-	  && (note == NULL_RTX || ! MEM_P (XEXP (note, 0))))
+	  && (note == NULL_RTX || ! MEM_P (XEXP (note, 0)))
+	  && ! (targetm.cannot_copy_insn_p && INSN_P (insn)
+		&& targetm.cannot_copy_insn_p (insn)))
 	{
 	  /* An expression is not anticipatable if its operands are
 	     modified before this insn or if this is not the only SET in
diff --git a/gcc/genautomata.c b/gcc/genautomata.c
index d314b8f22..1d742f4dc 100644
--- a/gcc/genautomata.c
+++ b/gcc/genautomata.c
@@ -1,5 +1,5 @@
 /* Pipeline hazard description translator.
-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
    Free Software Foundation, Inc.
 
    Written by Vladimir Makarov <vmakarov@redhat.com>
@@ -22,21 +22,25 @@ along with GCC; see the file COPYING3.  If not see
 
 /* References:
 
-   1. Detecting pipeline structural hazards quickly. T. Proebsting,
+   1. The finite state automaton based pipeline hazard recognizer and
+      instruction scheduler in GCC.  V. Makarov.  Proceedings of GCC
+      summit, 2003.
+
+   2. Detecting pipeline structural hazards quickly. T. Proebsting,
       C. Fraser. Proceedings of ACM SIGPLAN-SIGACT Symposium on
       Principles of Programming Languages, pages 280--286, 1994.
 
       This article is a good start point to understand usage of finite
       state automata for pipeline hazard recognizers.  But I'd
-      recommend the 2nd article for more deep understanding.
+      recommend the 1st and 3rd article for more deep understanding.
 
-   2. Efficient Instruction Scheduling Using Finite State Automata:
+   3. Efficient Instruction Scheduling Using Finite State Automata:
       V. Bala and N. Rubin, Proceedings of MICRO-28.  This is the best
       article about usage of finite state automata for pipeline hazard
       recognizers.
 
-   The current implementation is different from the 2nd article in the
-   following:
+   The current implementation is described in the 1st article and it
+   is different from the 3rd article in the following:
 
    1. New operator `|' (alternative) is permitted in functional unit
       reservation which can be treated deterministically and
@@ -463,7 +467,10 @@ struct insn_reserv_decl
      insn.  */
   int insn_num;
   /* The following field value is list of bypasses in which given insn
-     is output insn.  */
+     is output insn.  Bypasses with the same input insn stay one after
+     another in the list in the same order as their occurrences in the
+     description but the bypass without a guard stays always the last
+     in a row of bypasses with the same input insn.  */
   struct bypass_decl *bypass_list;
 
   /* The following fields are defined by automaton generator.  */
@@ -2367,18 +2374,67 @@ add_presence_absence (unit_set_el_t dest_list,
 }
 
 
-/* The function searches for bypass with given IN_INSN_RESERV in given
-   BYPASS_LIST.  */
-static struct bypass_decl *
-find_bypass (struct bypass_decl *bypass_list,
-	     struct insn_reserv_decl *in_insn_reserv)
+/* The function inserts BYPASS in the list of bypasses of the
+   corresponding output insn.  The order of bypasses in the list is
+   decribed in a comment for member `bypass_list' (see above).  If
+   there is already the same bypass in the list the function reports
+   this and does nothing.  */
+static void
+insert_bypass (struct bypass_decl *bypass)
 {
-  struct bypass_decl *bypass;
-
-  for (bypass = bypass_list; bypass != NULL; bypass = bypass->next)
-    if (bypass->in_insn_reserv == in_insn_reserv)
-      break;
-  return bypass;
+  struct bypass_decl *curr, *last;
+  struct insn_reserv_decl *out_insn_reserv = bypass->out_insn_reserv;
+  struct insn_reserv_decl *in_insn_reserv = bypass->in_insn_reserv;
+  
+  for (curr = out_insn_reserv->bypass_list, last = NULL;
+       curr != NULL;
+       last = curr, curr = curr->next)
+    if (curr->in_insn_reserv == in_insn_reserv)
+      {
+	if ((bypass->bypass_guard_name != NULL
+	     && curr->bypass_guard_name != NULL
+	     && ! strcmp (bypass->bypass_guard_name, curr->bypass_guard_name))
+	    || bypass->bypass_guard_name == curr->bypass_guard_name)
+	  {
+	    if (bypass->bypass_guard_name == NULL)
+	      {
+		if (!w_flag)
+		  error ("the same bypass `%s - %s' is already defined",
+			 bypass->out_insn_name, bypass->in_insn_name);
+		else
+		  warning (0, "the same bypass `%s - %s' is already defined",
+			   bypass->out_insn_name, bypass->in_insn_name);
+	      }
+	    else if (!w_flag)
+	      error ("the same bypass `%s - %s' (guard %s) is already defined",
+		     bypass->out_insn_name, bypass->in_insn_name,
+		     bypass->bypass_guard_name);
+	    else
+	      warning
+		(0, "the same bypass `%s - %s' (guard %s) is already defined",
+		 bypass->out_insn_name, bypass->in_insn_name,
+		 bypass->bypass_guard_name);
+	    return;
+	  }
+	if (curr->bypass_guard_name == NULL)
+	  break;
+	if (curr->next == NULL || curr->next->in_insn_reserv != in_insn_reserv)
+	  {
+	    last = curr;
+	    break;
+	  }
+	  
+      }
+  if (last == NULL)
+    {
+      bypass->next = out_insn_reserv->bypass_list;
+      out_insn_reserv->bypass_list = bypass;
+    }
+  else
+    {
+      bypass->next = last->next;
+      last->next = bypass;
+    }
 }
 
 /* The function processes pipeline description declarations, checks
@@ -2391,7 +2447,6 @@ process_decls (void)
   decl_t decl_in_table;
   decl_t out_insn_reserv;
   decl_t in_insn_reserv;
-  struct bypass_decl *bypass;
   int automaton_presence;
   int i;
 
@@ -2514,36 +2569,7 @@ process_decls (void)
 		= DECL_INSN_RESERV (out_insn_reserv);
 	      DECL_BYPASS (decl)->in_insn_reserv
 		= DECL_INSN_RESERV (in_insn_reserv);
-	      bypass
-		= find_bypass (DECL_INSN_RESERV (out_insn_reserv)->bypass_list,
-			       DECL_BYPASS (decl)->in_insn_reserv);
-	      if (bypass != NULL)
-		{
-		  if (DECL_BYPASS (decl)->latency == bypass->latency)
-		    {
-		      if (!w_flag)
-			error
-			  ("the same bypass `%s - %s' is already defined",
-			   DECL_BYPASS (decl)->out_insn_name,
-			   DECL_BYPASS (decl)->in_insn_name);
-		      else
-			warning
-			  (0, "the same bypass `%s - %s' is already defined",
-			   DECL_BYPASS (decl)->out_insn_name,
-			   DECL_BYPASS (decl)->in_insn_name);
-		    }
-		  else
-		    error ("bypass `%s - %s' is already defined",
-			   DECL_BYPASS (decl)->out_insn_name,
-			   DECL_BYPASS (decl)->in_insn_name);
-		}
-	      else
-		{
-		  DECL_BYPASS (decl)->next
-		    = DECL_INSN_RESERV (out_insn_reserv)->bypass_list;
-		  DECL_INSN_RESERV (out_insn_reserv)->bypass_list
-		    = DECL_BYPASS (decl);
-		}
+	      insert_bypass (DECL_BYPASS (decl));
 	    }
 	}
     }
@@ -8159,19 +8185,32 @@ output_internal_insn_latency_func (void)
 			    (advance_cycle_insn_decl)->insn_num));
 	    fprintf (output_file, "        case %d:\n",
 		     bypass->in_insn_reserv->insn_num);
-	    if (bypass->bypass_guard_name == NULL)
-	      fprintf (output_file, "          return %d;\n",
-		       bypass->latency);
-	    else
+	    for (;;)
 	      {
-		fprintf (output_file,
-			 "          if (%s (%s, %s))\n",
-			 bypass->bypass_guard_name, INSN_PARAMETER_NAME,
-			 INSN2_PARAMETER_NAME);
-		fprintf (output_file,
-			 "            return %d;\n          break;\n",
-			 bypass->latency);
+		if (bypass->bypass_guard_name == NULL)
+		  {
+		    gcc_assert (bypass->next == NULL
+				|| (bypass->in_insn_reserv
+				    != bypass->next->in_insn_reserv));
+		    fprintf (output_file, "          return %d;\n",
+			     bypass->latency);
+		  }
+		else
+		  {
+		    fprintf (output_file,
+			     "          if (%s (%s, %s))\n",
+			     bypass->bypass_guard_name, INSN_PARAMETER_NAME,
+			     INSN2_PARAMETER_NAME);
+		    fprintf (output_file, "            return %d;\n",
+			     bypass->latency);
+		  }
+		if (bypass->next == NULL
+		    || bypass->in_insn_reserv != bypass->next->in_insn_reserv)
+		  break;
+		bypass = bypass->next;
 	      }
+	    if (bypass->bypass_guard_name != NULL)
+	      fprintf (output_file, "          break;\n");
 	  }
 	fputs ("        }\n      break;\n", output_file);
       }
diff --git a/gcc/gengtype-lex.l b/gcc/gengtype-lex.l
index d9f1996cc..439305078 100644
--- a/gcc/gengtype-lex.l
+++ b/gcc/gengtype-lex.l
@@ -48,7 +48,7 @@ update_lineno (const char *l, size_t len)
 ID	[[:alpha:]_][[:alnum:]_]*
 WS	[[:space:]]+
 HWS	[ \t\r\v\f]*
-IWORD	short|long|(un)?signed|char|int|HOST_WIDE_INT|HOST_WIDEST_INT|bool|size_t|BOOL_BITFIELD|CPPCHAR_SIGNED_T|ino_t|dev_t
+IWORD	short|long|(un)?signed|char|int|HOST_WIDE_INT|HOST_WIDEST_INT|bool|size_t|BOOL_BITFIELD|CPPCHAR_SIGNED_T|ino_t|dev_t|HARD_REG_SET
 ITYPE	{IWORD}({WS}{IWORD})*
 EOID	[^[:alnum:]_]
 
diff --git a/gcc/genmultilib b/gcc/genmultilib
index 270de2b2a..ad0770284 100644
--- a/gcc/genmultilib
+++ b/gcc/genmultilib
@@ -73,6 +73,20 @@
 # the os directory names are used exclusively.  Use the mapping when
 # there is no one-to-one equivalence between GCC levels and the OS.
 
+# The optional eighth option is a list of multilib aliases.  This takes the
+# same form as the third argument.  It specifies that the second multilib is
+# a synonym for the first.  This allows a suitable multilib to be selected
+# for all option combinations while only building a subset of all possible
+# multilibs.
+# For example:
+#   genmultilib "mbig-endian mthumb" "eb thumb" "" "" "" "" "" \
+#		"mbig-endian=mbig-endian/mthumb" yes
+# This produces:
+#   ". !mbig-endian !mthumb;",
+#   "be mbig-endian !mthumb;",
+#   "be mbig-endian mthumb;",
+#   "thumb !mbig-endian mthumb;",
+
 # The last option should be "yes" if multilibs are enabled.  If it is not
 # "yes", all GCC multilib dir names will be ".".
 
@@ -121,7 +135,8 @@ exceptions=$4
 extra=$5
 exclusions=$6
 osdirnames=$7
-enable_multilib=$8
+aliases=$8
+enable_multilib=$9
 
 echo "static const char *const multilib_raw[] = {"
 
@@ -129,6 +144,23 @@ mkdir tmpmultilib.$$ || exit 1
 # Use cd ./foo to avoid CDPATH output.
 cd ./tmpmultilib.$$ || exit 1
 
+# Handle aliases
+cat >tmpmultilib3 <<\EOF
+#!/bin/sh
+# Output a list of aliases (including the original name) for a multilib.
+
+echo $1
+EOF
+for a in ${aliases}; do
+  l=`echo $a | sed -e 's/=.*$//' -e 's/?/=/g'`
+  r=`echo $a | sed -e 's/^.*=//' -e 's/?/=/g'`
+  echo "[ \$1 == /$l/ ] && echo /$r/" >>tmpmultilib3
+  
+  # Also add the alias to the exclusion list
+  exceptions="${exceptions} $r"
+done
+chmod +x tmpmultilib3
+
 # What we want to do is select all combinations of the sets in
 # options.  Each combination which includes a set of mutually
 # exclusive options must then be output multiple times, once for each
@@ -195,6 +227,21 @@ EOF
   combinations=`./tmpmultilib2 ${combinations}`
 fi
 
+# Check that all the aliases actually exist
+for a in ${aliases}; do
+  l=`echo $a | sed -e 's/=.*$//' -e 's/?/=/g'`
+  for c in ${combinations}; do
+    if [ "/$l/" = "$c" ]; then
+      l=""
+      break;
+    fi
+  done
+  if [ -n "$l" ] ;then
+    echo "Missing multilib $l for alias $a" 1>&2
+    exit 1
+  fi
+done
+
 # Construct a sed pattern which will convert option names to directory
 # names.
 todirnames=
@@ -343,23 +390,25 @@ for combo in ${combinations}; do
     fi
   fi
 
-  # Look through the options.  We must output each option that is
-  # present, and negate each option that is not present.
-  optout=
-  for set in ${options}; do
-    setopts=`echo ${set} | sed -e 's_[/|]_ _g'`
-    for opt in ${setopts}; do
-      if expr "${combo} " : ".*/${opt}/.*" > /dev/null; then
-	optout="${optout} ${opt}"
-      else
-	optout="${optout} !${opt}"
-      fi
+  for optcombo in `./tmpmultilib3 ${combo}`; do
+    # Look through the options.  We must output each option that is
+    # present, and negate each option that is not present.
+    optout=
+    for set in ${options}; do
+      setopts=`echo ${set} | sed -e 's_[/|]_ _g'`
+      for opt in ${setopts}; do
+	if expr "${optcombo} " : ".*/${opt}/.*" > /dev/null; then
+	  optout="${optout} ${opt}"
+	else
+	  optout="${optout} !${opt}"
+	fi
+      done
     done
-  done
-  optout=`echo ${optout} | sed -e 's/^ //'`
+    optout=`echo ${optout} | sed -e 's/^ //'`
 
-  # Output the line with all appropriate matches.
-  dirout="${dirout}" optout="${optout}" ./tmpmultilib2
+    # Output the line with all appropriate matches.
+    dirout="${dirout}" optout="${optout}" ./tmpmultilib2
+  done
 done
 
 # Terminate the list of string.
diff --git a/gcc/gimple.h b/gcc/gimple.h
index ef1b2acca..68046862f 100644
--- a/gcc/gimple.h
+++ b/gcc/gimple.h
@@ -1020,6 +1020,7 @@ extern void gimple_add_to_addresses_taken (gimple, tree);
 
 /* In tree-ssa.c  */
 extern bool tree_ssa_useless_type_conversion (tree);
+extern tree tree_ssa_strip_useless_type_conversions (tree);
 extern bool useless_type_conversion_p (tree, tree);
 extern bool types_compatible_p (tree, tree);
 
diff --git a/gcc/gthr-win32.h b/gcc/gthr-win32.h
index a4fd32b6a..fe93fc284 100644
--- a/gcc/gthr-win32.h
+++ b/gcc/gthr-win32.h
@@ -67,7 +67,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #define __GTHREADS 1
 
+#ifndef __MINGW32CE__
 #include <errno.h>
+#endif
 #ifdef __MINGW32__
 #include <_mingw.h>
 #endif
@@ -535,7 +537,9 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
 #else /* ! __GTHREAD_HIDE_WIN32API */
 
 #include <windows.h>
+#ifndef __MINGW32CE__
 #include <errno.h>
+#endif
 
 static inline int
 __gthread_once (__gthread_once_t *__once, void (*__func) (void))
@@ -543,7 +547,11 @@ __gthread_once (__gthread_once_t *__once, void (*__func) (void))
   if (! __gthread_active_p ())
     return -1;
   else if (__once == NULL || __func == NULL)
+#ifdef __MINGW32CE__
+    return -1;
+#else
     return EINVAL;
+#endif
 
   if (! __once->done)
     {
diff --git a/gcc/haifa-sched.c b/gcc/haifa-sched.c
index a3931a591..f26d47c77 100644
--- a/gcc/haifa-sched.c
+++ b/gcc/haifa-sched.c
@@ -1990,6 +1990,23 @@ move_insn (rtx insn, rtx last, rtx nt)
   SCHED_GROUP_P (insn) = 0;  
 }
 
+/* Return true if scheduling INSN will finish current clock cycle.  */
+static bool
+insn_finishes_cycle_p (rtx insn)
+{
+  if (SCHED_GROUP_P (insn))
+    /* After issuing INSN, rest of the sched_group will be forced to issue
+       in order.  Don't make any plans for the rest of cycle.  */
+    return true;
+
+  /* Finishing the block will, apparently, finish the cycle.  */
+  if (current_sched_info->insn_finishes_block_p
+      && current_sched_info->insn_finishes_block_p (insn))
+    return true;
+
+  return false;
+}
+
 /* The following structure describe an entry of the stack of choices.  */
 struct choice_entry
 {
@@ -2168,7 +2185,10 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,
 	  delay = state_transition (state, insn);
 	  if (delay < 0)
 	    {
-	      if (state_dead_lock_p (state))
+	      if (state_dead_lock_p (state)
+		  || insn_finishes_cycle_p (insn))
+ 		/* We won't issue any more instructions in the next
+ 		   choice_state.  */
 		top->rest = 0;
 	      else
 		top->rest--;
diff --git a/gcc/hooks.c b/gcc/hooks.c
index 78e0ad221..0d29184e2 100644
--- a/gcc/hooks.c
+++ b/gcc/hooks.c
@@ -335,3 +335,10 @@ hook_constcharptr_int_const_tree_const_tree_null (int i ATTRIBUTE_UNUSED,
 {
   return NULL;
 }
+
+/* Generic hook that takes a const_tree and returns NULL_TREE.  */
+tree
+hook_tree_const_tree_null (const_tree t ATTRIBUTE_UNUSED)
+{
+  return NULL;
+}
diff --git a/gcc/hooks.h b/gcc/hooks.h
index b47a6d980..f46c30e49 100644
--- a/gcc/hooks.h
+++ b/gcc/hooks.h
@@ -64,6 +64,8 @@ extern int hook_int_rtx_bool_0 (rtx, bool);
 extern int hook_int_size_t_constcharptr_int_0 (size_t, const char *, int);
 extern int hook_int_void_no_regs (void);
 
+extern tree hook_tree_const_tree_null (const_tree);
+
 extern tree hook_tree_tree_tree_null (tree, tree);
 extern tree hook_tree_tree_tree_tree_null (tree, tree, tree);
 extern tree hook_tree_tree_tree_tree_3rd_identity (tree, tree, tree);
diff --git a/gcc/ifcvt.c b/gcc/ifcvt.c
index a6db2114b..66a219beb 100644
--- a/gcc/ifcvt.c
+++ b/gcc/ifcvt.c
@@ -390,7 +390,11 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,
   rtx false_expr;		/* test for then block insns */
   rtx true_prob_val;		/* probability of else block */
   rtx false_prob_val;		/* probability of then block */
-  int n_insns;
+  rtx then_last_head = NULL_RTX;	/* Last match at the head of THEN */
+  rtx else_last_head = NULL_RTX;	/* Last match at the head of ELSE */
+  rtx then_first_tail = NULL_RTX;	/* First match at the tail of THEN */
+  rtx else_first_tail = NULL_RTX;	/* First match at the tail of ELSE */
+  int then_n_insns, else_n_insns, n_insns;
   enum rtx_code false_code;
 
   /* If test is comprised of && or || elements, and we've failed at handling
@@ -423,15 +427,80 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,
      number of insns and see if it is small enough to convert.  */
   then_start = first_active_insn (then_bb);
   then_end = last_active_insn (then_bb, TRUE);
-  n_insns = ce_info->num_then_insns = count_bb_insns (then_bb);
+  then_n_insns = ce_info->num_then_insns = count_bb_insns (then_bb);
+  n_insns = then_n_insns;
   max = MAX_CONDITIONAL_EXECUTE;
 
   if (else_bb)
     {
+      int n_matching;
+
       max *= 2;
       else_start = first_active_insn (else_bb);
       else_end = last_active_insn (else_bb, TRUE);
-      n_insns += ce_info->num_else_insns = count_bb_insns (else_bb);
+      else_n_insns = ce_info->num_else_insns = count_bb_insns (else_bb);
+      n_insns += else_n_insns;
+
+      /* Look for matching sequences at the head and tail of the two blocks,
+	 and limit the range of insns to be converted if possible.  */
+      n_matching = flow_find_cross_jump (0, then_bb, else_bb,
+					 &then_first_tail, &else_first_tail);
+      if (then_first_tail == BB_HEAD (then_bb))
+	then_start = then_end = NULL_RTX;
+      if (else_first_tail == BB_HEAD (else_bb))
+	else_start = else_end = NULL_RTX;
+
+      if (n_matching > 0)
+	{
+	  if (then_end)
+	    then_end = prev_active_insn (then_first_tail);
+	  if (else_end)
+	    else_end = prev_active_insn (else_first_tail);
+	  n_insns -= 2 * n_matching;
+	}
+
+      if (then_start && else_start)
+	{
+	  int longest_match = MIN (then_n_insns - n_matching,
+				   else_n_insns - n_matching);
+	  n_matching
+	    = flow_find_head_matching_sequence (0, then_bb, else_bb,
+						&then_last_head,
+						&else_last_head,
+						longest_match);
+      
+	  if (then_last_head == then_end)
+	    then_start = then_end = NULL_RTX;
+	  if (else_last_head == else_end)
+	    else_start = else_end = NULL_RTX;
+
+	  if (n_matching > 0)
+	    {
+	      rtx insn;
+
+	      if (then_start)
+		then_start = next_active_insn (then_last_head);
+	      if (else_start)
+		else_start = next_active_insn (else_last_head);
+	      n_insns -= 2 * n_matching;
+
+	      /* We won't pass the insns in the head sequence to
+		 cond_exec_process_insns, so we need to test them here
+		 to make sure that they don't clobber the condition.  */
+	      insn = BB_HEAD (then_bb);
+	      for (;;)
+		{
+		  if (!LABEL_P (insn) && !NOTE_P (insn))
+		    {
+		      if (modified_in_p (test_expr, insn))
+			return FALSE;
+		    }
+		  if (insn == then_last_head)
+		    break;
+		  insn = NEXT_INSN (insn);
+		}
+	    }
+	}
     }
 
   if (n_insns > max)
@@ -575,7 +644,18 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,
     fprintf (dump_file, "%d insn%s converted to conditional execution.\n",
 	     n_insns, (n_insns == 1) ? " was" : "s were");
 
-  /* Merge the blocks!  */
+  /* Merge the blocks!  If we had matching sequences, make sure to delete one
+     copy at the appropriate location first.  */
+  if (then_first_tail)
+    {
+      rtx from = then_first_tail;
+      if (!INSN_P (from))
+	from = next_active_insn (from);
+      delete_insn_chain (from, BB_END (then_bb), false);
+    }
+  if (else_last_head)
+    delete_insn_chain (first_active_insn (else_bb), else_last_head, false);
+
   merge_if_block (ce_info);
   cond_exec_changed_p = TRUE;
   return TRUE;
diff --git a/gcc/incpath.c b/gcc/incpath.c
index a5619781b..b83db2b04 100644
--- a/gcc/incpath.c
+++ b/gcc/incpath.c
@@ -30,6 +30,8 @@
 #include "intl.h"
 #include "incpath.h"
 #include "cppdefault.h"
+#include "flags.h"
+#include "toplev.h"
 
 /* Microsoft Windows does not natively support inodes.
    VMS has non-numeric inodes.  */
@@ -353,6 +355,24 @@ merge_include_chains (const char *sysroot, cpp_reader *pfile, int verbose)
 	}
       fprintf (stderr, _("End of search list.\n"));
     }
+
+#ifdef ENABLE_POISON_SYSTEM_DIRECTORIES
+  if (flag_poison_system_directories)
+    {
+	struct cpp_dir *p;
+
+	for (p = heads[QUOTE]; p; p = p->next)
+	  {
+	   if ((!strncmp (p->name, "/usr/include", 12))
+	       || (!strncmp (p->name, "/usr/local/include", 18))
+	       || (!strncmp (p->name, "/usr/X11R6/include", 18)))
+	     warning (OPT_Wpoison_system_directories,
+		      "include location \"%s\" is unsafe for "
+		      "cross-compilation",
+		      p->name);
+	  }
+    }
+#endif
 }
 
 /* Use given -I paths for #include "..." but not #include <...>, and
diff --git a/gcc/input.h b/gcc/input.h
index 299f56c3c..7f00dc7cd 100644
--- a/gcc/input.h
+++ b/gcc/input.h
@@ -1,6 +1,6 @@
 /* Declarations for variables relating to reading the source file.
    Used by parsers, lexical analyzers, and error message routines.
-   Copyright (C) 1993, 1997, 1998, 2000, 2003, 2004, 2007, 2008
+   Copyright (C) 1993, 1997, 1998, 2000, 2003, 2004, 2007, 2008, 2009
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -30,7 +30,12 @@ extern GTY(()) struct line_maps *line_table;
 #define UNKNOWN_LOCATION ((source_location) 0)
 
 /* The location for declarations in "<built-in>" */
-#define BUILTINS_LOCATION ((source_location) 2)
+#define BUILTINS_LOCATION ((source_location) 1)
+
+/* line-map.c reserves RESERVED_LOCATION_COUNT to the user.  Ensure
+   both UNKNOWN_LOCATION and BUILTINS_LOCATION fit into that.  */
+extern char builtins_location_check[(BUILTINS_LOCATION
+				     < RESERVED_LOCATION_COUNT) ? 1 : -1];
 
 typedef struct GTY (())
 {
diff --git a/gcc/ira-costs.c b/gcc/ira-costs.c
index 58700b75f..f118bf108 100644
--- a/gcc/ira-costs.c
+++ b/gcc/ira-costs.c
@@ -209,6 +209,14 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,
       int alt_fail = 0;
       int alt_cost = 0, op_cost_add;
 
+      if (!recog_data.alternative_enabled_p[alt])
+	{
+	  for (i = 0; i < recog_data.n_operands; i++)
+	    constraints[i] = skip_alternative (constraints[i]);
+
+	  continue;
+	}
+
       for (i = 0; i < n_ops; i++)
 	{
 	  unsigned char c;
@@ -706,11 +714,11 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,
 
 /* Wrapper around REGNO_OK_FOR_INDEX_P, to allow pseudo registers.  */
 static inline bool
-ok_for_index_p_nonstrict (rtx reg)
+ok_for_index_p_nonstrict (rtx reg, enum machine_mode mode)
 {
   unsigned regno = REGNO (reg);
 
-  return regno >= FIRST_PSEUDO_REGISTER || REGNO_OK_FOR_INDEX_P (regno);
+  return regno >= FIRST_PSEUDO_REGISTER || ok_for_index_p_1 (regno, mode);
 }
 
 /* A version of regno_ok_for_base_p for use here, when all
@@ -748,7 +756,7 @@ record_address_regs (enum machine_mode mode, rtx x, int context,
   enum reg_class rclass;
 
   if (context == 1)
-    rclass = INDEX_REG_CLASS;
+    rclass = index_reg_class (mode);
   else
     rclass = base_reg_class (mode, outer_code, index_code);
 
@@ -795,7 +803,8 @@ record_address_regs (enum machine_mode mode, rtx x, int context,
 	   just record registers in any non-constant operands.  We
 	   assume here, as well as in the tests below, that all
 	   addresses are in canonical form.  */
-	else if (INDEX_REG_CLASS == base_reg_class (VOIDmode, PLUS, SCRATCH))
+	else if (index_reg_class (mode)
+		 == base_reg_class (mode, PLUS, SCRATCH))
 	  {
 	    record_address_regs (mode, arg0, context, PLUS, code1, scale);
 	    if (! CONSTANT_P (arg1))
@@ -816,7 +825,7 @@ record_address_regs (enum machine_mode mode, rtx x, int context,
 	else if (code0 == REG && code1 == REG
 		 && REGNO (arg0) < FIRST_PSEUDO_REGISTER
 		 && (ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)
-		     || ok_for_index_p_nonstrict (arg0)))
+		     || ok_for_index_p_nonstrict (arg0, mode)))
 	  record_address_regs (mode, arg1,
 			       ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)
 			       ? 1 : 0,
@@ -824,7 +833,7 @@ record_address_regs (enum machine_mode mode, rtx x, int context,
 	else if (code0 == REG && code1 == REG
 		 && REGNO (arg1) < FIRST_PSEUDO_REGISTER
 		 && (ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)
-		     || ok_for_index_p_nonstrict (arg1)))
+		     || ok_for_index_p_nonstrict (arg1, mode)))
 	  record_address_regs (mode, arg0,
 			       ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)
 			       ? 1 : 0,
diff --git a/gcc/ira.c b/gcc/ira.c
index cf55524a0..d4c669436 100644
--- a/gcc/ira.c
+++ b/gcc/ira.c
@@ -1349,14 +1349,12 @@ insn_contains_asm (rtx insn)
   return for_each_rtx (&insn, insn_contains_asm_1, NULL);
 }
 
-/* Set up regs_asm_clobbered.  */
+/* Add register clobbers from asm statements.  */
 static void
-compute_regs_asm_clobbered (char *regs_asm_clobbered)
+compute_regs_asm_clobbered (void)
 {
   basic_block bb;
 
-  memset (regs_asm_clobbered, 0, sizeof (char) * FIRST_PSEUDO_REGISTER);
-  
   FOR_EACH_BB (bb)
     {
       rtx insn;
@@ -1377,7 +1375,7 @@ compute_regs_asm_clobbered (char *regs_asm_clobbered)
 		      + hard_regno_nregs[dregno][mode] - 1;
 
 		    for (i = dregno; i <= end; ++i)
-		      regs_asm_clobbered[i] = 1;
+		      SET_HARD_REG_BIT(crtl->asm_clobbers, i);
 		  }
 	      }
 	}
@@ -1389,12 +1387,6 @@ compute_regs_asm_clobbered (char *regs_asm_clobbered)
 static void
 setup_eliminable_regset (void)
 {
-  /* Like regs_ever_live, but 1 if a reg is set or clobbered from an
-     asm.  Unlike regs_ever_live, elements of this array corresponding
-     to eliminable regs (like the frame pointer) are set if an asm
-     sets them.  */
-  char *regs_asm_clobbered
-    = (char *) alloca (FIRST_PSEUDO_REGISTER * sizeof (char));
 #ifdef ELIMINABLE_REGS
   int i;
   static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;
@@ -1415,7 +1407,8 @@ setup_eliminable_regset (void)
   COPY_HARD_REG_SET (ira_no_alloc_regs, no_unit_alloc_regs);
   CLEAR_HARD_REG_SET (eliminable_regset);
 
-  compute_regs_asm_clobbered (regs_asm_clobbered);
+  compute_regs_asm_clobbered ();
+
   /* Build the regset of all eliminable registers and show we can't
      use those that we already know won't be eliminated.  */
 #ifdef ELIMINABLE_REGS
@@ -1425,7 +1418,7 @@ setup_eliminable_regset (void)
 	= (! CAN_ELIMINATE (eliminables[i].from, eliminables[i].to)
 	   || (eliminables[i].to == STACK_POINTER_REGNUM && need_fp));
 
-      if (! regs_asm_clobbered[eliminables[i].from])
+      if (!TEST_HARD_REG_BIT (crtl->asm_clobbers, eliminables[i].from))
 	{
 	    SET_HARD_REG_BIT (eliminable_regset, eliminables[i].from);
 
@@ -1439,7 +1432,7 @@ setup_eliminable_regset (void)
 	df_set_regs_ever_live (eliminables[i].from, true);
     }
 #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM
-  if (! regs_asm_clobbered[HARD_FRAME_POINTER_REGNUM])
+  if (!TEST_HARD_REG_BIT (crtl->asm_clobbers, HARD_FRAME_POINTER_REGNUM))
     {
       SET_HARD_REG_BIT (eliminable_regset, HARD_FRAME_POINTER_REGNUM);
       if (need_fp)
@@ -1453,7 +1446,7 @@ setup_eliminable_regset (void)
 #endif
 
 #else
-  if (! regs_asm_clobbered[FRAME_POINTER_REGNUM])
+  if (!TEST_HARD_REG_BIT (crtl->asm_clobbers, HARD_FRAME_POINTER_REGNUM))
     {
       SET_HARD_REG_BIT (eliminable_regset, FRAME_POINTER_REGNUM);
       if (need_fp)
diff --git a/gcc/java/Make-lang.in b/gcc/java/Make-lang.in
index 605f7e343..e7b195ce2 100644
--- a/gcc/java/Make-lang.in
+++ b/gcc/java/Make-lang.in
@@ -28,7 +28,7 @@
 #
 # foo.all.cross, foo.start.encap, foo.rest.encap,
 # foo.install-common, foo.install-man, foo.install-info, foo.install-pdf,
-# foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
+# foo.install-html, foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
 # foo.mostlyclean, foo.clean, foo.distclean,
 # foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4
 #
@@ -137,7 +137,9 @@ JAVA_PDFFILES = doc/gcj.pdf
 
 java.pdf: $(JAVA_PDFFILES)
 
-java.html: $(build_htmldir)/java/index.html
+JAVA_HTMLFILES = $(build_htmldir)/java
+
+java.html: $(JAVA_HTMLFILES)/index.html
 
 JAVA_MANFILES = doc/gcj.1 doc/jcf-dump.1 doc/gij.1 \
                 doc/jv-convert.1 doc/grmic.1 \
@@ -203,6 +205,22 @@ java.install-pdf: $(JAVA_PDFFILES)
 	  $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(pdfdir)/$$f"; \
 	done
 
+java.install-html: $(JAVA_HTMLFILES)
+	@$(NORMAL_INSTALL)
+	test -z "$(htmldir)" || $(mkinstalldirs) "$(DESTDIR)$(htmldir)"
+	@list='$(JAVA_HTMLFILES)'; for p in $$list; do \
+	  if test -f "$$p" || test -d "$$p"; then d=""; else d="$(srcdir)/"; fi; \
+	  f=$(html__strip_dir) \
+	  if test -d "$$d$$p"; then \
+	    echo " $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(mkinstalldirs) "$(DESTDIR)$(htmldir)/$$f" || exit 1; \
+	    echo " $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p"/* "$(DESTDIR)$(htmldir)/$$f"; \
+	  else \
+	    echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(htmldir)/$$f"; \
+	  fi; \
+	done
 #
 # Clean hooks:
 # A lot of the ancillary files are deleted by the main makefile.
diff --git a/gcc/java/builtins.c b/gcc/java/builtins.c
index c9f9f4a2a..b2aba3de2 100644
--- a/gcc/java/builtins.c
+++ b/gcc/java/builtins.c
@@ -305,7 +305,8 @@ compareAndSwapInt_builtin (tree method_return_type ATTRIBUTE_UNUSED,
 {
   enum machine_mode mode = TYPE_MODE (int_type_node);
   if (sync_compare_and_swap_cc[mode] != CODE_FOR_nothing 
-      || sync_compare_and_swap[mode] != CODE_FOR_nothing)
+      || sync_compare_and_swap[mode] != CODE_FOR_nothing
+      || flag_use_atomic_builtins)
     {
       tree addr, stmt;
       UNMARSHAL5 (orig_call);
@@ -325,7 +326,12 @@ compareAndSwapLong_builtin (tree method_return_type ATTRIBUTE_UNUSED,
 {
   enum machine_mode mode = TYPE_MODE (long_type_node);
   if (sync_compare_and_swap_cc[mode] != CODE_FOR_nothing 
-      || sync_compare_and_swap[mode] != CODE_FOR_nothing)
+      || sync_compare_and_swap[mode] != CODE_FOR_nothing
+      || (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (word_mode)
+	  && flag_use_atomic_builtins))
+    /* We don't trust flag_use_atomic_builtins for multi-word
+       compareAndSwap.  Some machines such as ARM have atomic libfuncs
+       but not the multi-word versions.  */
     {
       tree addr, stmt;
       UNMARSHAL5 (orig_call);
@@ -344,7 +350,8 @@ compareAndSwapObject_builtin (tree method_return_type ATTRIBUTE_UNUSED,
 {
   enum machine_mode mode = TYPE_MODE (ptr_type_node);
   if (sync_compare_and_swap_cc[mode] != CODE_FOR_nothing 
-      || sync_compare_and_swap[mode] != CODE_FOR_nothing)
+      || sync_compare_and_swap[mode] != CODE_FOR_nothing
+      || flag_use_atomic_builtins)
   {
     tree addr, stmt;
     int builtin;
diff --git a/gcc/java/gcj.texi b/gcc/java/gcj.texi
index 00ac9f7de..46b0899e8 100644
--- a/gcc/java/gcj.texi
+++ b/gcc/java/gcj.texi
@@ -607,6 +607,13 @@ On some systems it's necessary to insert inline checks whenever
 accessing an object via a reference.  On other systems you won't need
 this because null pointer accesses are caught automatically by the
 processor.
+
+@item -fuse-atomic-builtins
+On some systems, gcc can generate code for built-in atomic operations.
+Use this option to force gcj to use these builtins when compiling Java
+code.  Where this capability is present it should be automatically
+detected, so you won't usually need to use this option.
+
 @end table
 
 @c man end
diff --git a/gcc/java/java-tree.h b/gcc/java/java-tree.h
index 7ae71d9e4..f3a5fc27a 100644
--- a/gcc/java/java-tree.h
+++ b/gcc/java/java-tree.h
@@ -145,6 +145,9 @@ extern int flag_newer;
 /* When nonzero, call a library routine to do integer divisions. */
 extern int flag_use_divide_subroutine;
 
+/* When nonzero, use atomic builtins. */
+extern int flag_use_atomic_builtins;
+
 /* When nonzero, generate code for the Boehm GC.  */
 extern int flag_use_boehm_gc;
 
diff --git a/gcc/java/jvspec.c b/gcc/java/jvspec.c
index 24f2e166a..9e57dab65 100644
--- a/gcc/java/jvspec.c
+++ b/gcc/java/jvspec.c
@@ -73,6 +73,7 @@ static const char jvgenmain_spec[] =
 		   %<fclasspath* %<fCLASSPATH* %<fbootclasspath*\
 		   %<fextdirs*\
 		   %<fuse-divide-subroutine %<fno-use-divide-subroutine\
+		   %<fuse-atomic-builtins %<fno-use-atomic-builtins\
 		   %<fcheck-references %<fno-check-references\
 		   %<ffilelist-file %<fsaw-java-file %<fsource* %<ftarget*\
 		   %{f*} -fdollars-in-identifiers\
diff --git a/gcc/java/lang.opt b/gcc/java/lang.opt
index 8af1bd59e..9e9a8cb52 100644
--- a/gcc/java/lang.opt
+++ b/gcc/java/lang.opt
@@ -192,6 +192,10 @@ fuse-divide-subroutine
 Java Var(flag_use_divide_subroutine) Init(1)
 Call a library routine to do integer divisions
 
+fuse-atomic-builtins
+Java Var(flag_use_atomic_builtins) Init(0)
+Generate code for built-in atomic operations
+
 fbootstrap-classes
 Java Var(flag_bootstrap_classes)
 Generated should be loaded by bootstrap loader
diff --git a/gcc/modulo-sched.c b/gcc/modulo-sched.c
index 7134bfc0d..3601bb25b 100644
--- a/gcc/modulo-sched.c
+++ b/gcc/modulo-sched.c
@@ -270,6 +270,7 @@ static struct haifa_sched_info sms_sched_info =
   NULL,
   sms_print_insn,
   NULL,
+  NULL, /* insn_finishes_block_p */
   NULL, NULL,
   NULL, NULL,
   0, 0,
diff --git a/gcc/objc/Make-lang.in b/gcc/objc/Make-lang.in
index 4f854ea78..cf28364c0 100644
--- a/gcc/objc/Make-lang.in
+++ b/gcc/objc/Make-lang.in
@@ -24,7 +24,7 @@
 #
 # foo.all.cross, foo.start.encap, foo.rest.encap,
 # foo.install-common, foo.install-man, foo.install-info, foo.install-pdf,
-# foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
+# foo.install-html, foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
 # foo.mostlyclean, foo.clean, foo.distclean,
 # foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4
 #
@@ -95,6 +95,7 @@ objc.dvi:
 objc.pdf:
 objc.install-pdf:
 objc.html:
+objc.install-html:
 objc.man:
 objc.srcinfo:
 objc.srcman:
diff --git a/gcc/objc/lang-specs.h b/gcc/objc/lang-specs.h
index 62ffb9954..46a082837 100644
--- a/gcc/objc/lang-specs.h
+++ b/gcc/objc/lang-specs.h
@@ -26,29 +26,33 @@ along with GCC; see the file COPYING3.  If not see
   {"@objective-c",
      "%{E|M|MM:cc1obj -E %{traditional|ftraditional|traditional-cpp:-traditional-cpp}\
           %(cpp_options) %(cpp_debug_options)}\
+        %{fsection-anchors: %eGNU Objective C can't use -fsection-anchors} \
       %{!E:%{!M:%{!MM:\
 	%{traditional|ftraditional|traditional-cpp:\
 %eGNU Objective C no longer supports traditional compilation}\
 	%{save-temps|no-integrated-cpp:cc1obj -E %(cpp_options) -o %{save-temps:%b.mi} %{!save-temps:%g.mi} \n\
-	    cc1obj -fpreprocessed %{save-temps:%b.mi} %{!save-temps:%g.mi} %(cc1_options) %{print-objc-runtime-info} %{gen-decls}}\
+           cc1obj -fpreprocessed -fno-section-anchors %{save-temps:%b.mi} %{!save-temps:%g.mi} %(cc1_options) %{print-objc-runtime-info} %{gen-decls}}\
 	%{!save-temps:%{!no-integrated-cpp:\
-	    cc1obj %(cpp_unique_options) %(cc1_options) %{print-objc-runtime-info} %{gen-decls}}}\
+	    cc1obj %(cpp_unique_options) -fno-section-anchors %(cc1_options) %{print-objc-runtime-info} %{gen-decls}}}\
         %{!fsyntax-only:%(invoke_as)}}}}", 0, 0, 0},
   {".mi", "@objc-cpp-output", 0, 0, 0},
   {"@objc-cpp-output",
-     "%{!M:%{!MM:%{!E:cc1obj -fpreprocessed %i %(cc1_options) %{print-objc-runtime-info} %{gen-decls}\
-			     %{!fsyntax-only:%(invoke_as)}}}}", 0, 0, 0},
+     "%{!M:%{!MM:%{!E:cc1obj -fno-section-anchors -fpreprocessed %i %(cc1_options) %{print-objc-runtime-info} %{gen-decls}\
+			     %{!fsyntax-only:%(invoke_as)}}}}   \
+    %{fsection-anchors: %eGNU Objective C can't use -fsection-anchors} ", 0, 0, 0},
   {"@objective-c-header",
      "%{E|M|MM:cc1obj -E %{traditional|ftraditional|traditional-cpp:-traditional-cpp}\
           %(cpp_options) %(cpp_debug_options)}\
+        %{fsection-anchors: %eGNU Objective C can't use -fsection-anchors} \
       %{!E:%{!M:%{!MM:\
 	%{traditional|ftraditional|traditional-cpp:\
 %eGNU Objective C no longer supports traditional compilation}\
 	%{save-temps|no-integrated-cpp:cc1obj -E %(cpp_options) -o %{save-temps:%b.mi} %{!save-temps:%g.mi} \n\
-	    cc1obj -fpreprocessed %b.mi %(cc1_options) %{print-objc-runtime-info} %{gen-decls}\
+	    cc1obj -fpreprocessed %b.mi %(cc1_options) -fno-section-anchors %{print-objc-runtime-info} %{gen-decls}\
                         -o %g.s %{!o*:--output-pch=%i.gch}\
                         %W{o*:--output-pch=%*}%V}\
+        %{fsection-anchors: %eGNU Objective C can't use -fsection-anchors} \
 	%{!save-temps:%{!no-integrated-cpp:\
-	    cc1obj %(cpp_unique_options) %(cc1_options) %{print-objc-runtime-info} %{gen-decls}\
+	    cc1obj %(cpp_unique_options) -fno-section-anchors %(cc1_options) %{print-objc-runtime-info} %{gen-decls}\
                         -o %g.s %{!o*:--output-pch=%i.gch}\
                         %W{o*:--output-pch=%*}%V}}}}}", 0, 0, 0},
diff --git a/gcc/objcp/Make-lang.in b/gcc/objcp/Make-lang.in
index 6e3290cf6..3d9dbfadc 100644
--- a/gcc/objcp/Make-lang.in
+++ b/gcc/objcp/Make-lang.in
@@ -24,7 +24,7 @@
 #
 # foo.all.cross, foo.start.encap, foo.rest.encap,
 # foo.install-common, foo.install-man, foo.install-info, foo.install-pdf,
-# foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
+# foo.install-html, foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
 # foo.mostlyclean, foo.clean, foo.distclean,
 # foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4
 #
@@ -103,6 +103,7 @@ obj-c++.dvi:
 obj-c++.pdf:
 obj-c++.install-pdf:
 obj-c++.html:
+obj-c++.install-html:
 obj-c++.srcinfo:
 obj-c++.srcextra:
 obj-c++.man:
diff --git a/gcc/optabs.c b/gcc/optabs.c
index 74fe09fe5..118c0e293 100644
--- a/gcc/optabs.c
+++ b/gcc/optabs.c
@@ -3300,7 +3300,8 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,
       if (unoptab == ffs_optab || unoptab == clz_optab || unoptab == ctz_optab
 	  || unoptab == popcount_optab || unoptab == parity_optab)
 	outmode
-	    = GET_MODE (hard_libcall_value (TYPE_MODE (integer_type_node)));
+	  = GET_MODE (hard_libcall_value (TYPE_MODE (integer_type_node),
+					  optab_libfunc (unoptab, mode)));
 
       start_sequence ();
 
@@ -4357,10 +4358,12 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,
        mode != VOIDmode;
        mode = GET_MODE_WIDER_MODE (mode))
     {
-      if ((libfunc = optab_libfunc (code_to_optab[comparison], mode)))
+      if (code_to_optab[comparison]
+	  && (libfunc = optab_libfunc (code_to_optab[comparison], mode)))
 	break;
 
-      if ((libfunc = optab_libfunc (code_to_optab[swapped] , mode)))
+      if (code_to_optab[swapped]
+	  && (libfunc = optab_libfunc (code_to_optab[swapped], mode)))
 	{
 	  rtx tmp;
 	  tmp = x; x = y; y = tmp;
@@ -4368,7 +4371,8 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,
 	  break;
 	}
 
-      if ((libfunc = optab_libfunc (code_to_optab[reversed], mode))
+      if (code_to_optab[reversed]
+	  && (libfunc = optab_libfunc (code_to_optab[reversed], mode))
 	  && FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, reversed))
 	{
 	  comparison = reversed;
diff --git a/gcc/opts.c b/gcc/opts.c
index a75db6691..104ca6d11 100644
--- a/gcc/opts.c
+++ b/gcc/opts.c
@@ -894,7 +894,8 @@ decode_options (unsigned int argc, const char **argv)
   flag_caller_saves = opt2;
   flag_peephole2 = opt2;
 #ifdef INSN_SCHEDULING
-  flag_schedule_insns = opt2;
+  /* Only run the pre-regalloc scheduling pass if optimizing for speed.  */
+  flag_schedule_insns = opt2 && ! optimize_size;
   flag_schedule_insns_after_reload = opt2;
 #endif
   flag_regmove = opt2;
@@ -906,7 +907,7 @@ decode_options (unsigned int argc, const char **argv)
   flag_tree_vrp = opt2;
   flag_tree_builtin_call_dce = opt2;
   flag_tree_pre = opt2;
-  flag_tree_switch_conversion = 1;
+  flag_tree_switch_conversion = opt2;
   flag_ipa_cp = opt2;
 
   /* Allow more virtual operators to increase alias precision.  */
@@ -930,6 +931,7 @@ decode_options (unsigned int argc, const char **argv)
   flag_gcse_after_reload = opt3;
   flag_tree_vectorize = opt3;
   flag_ipa_cp_clone = opt3;
+  flag_tree_pre_partial_partial = opt3;
   if (flag_ipa_cp_clone)
     flag_ipa_cp = 1;
 
@@ -953,10 +955,13 @@ decode_options (unsigned int argc, const char **argv)
 	 being declared inline.  */
       flag_inline_functions = 1;
 
-      /* Basic optimization options.  */
-      optimize_size = 1;
+      /* Basic optimization options at -Os are almost the same as -O2.  The
+	 only difference is that we disable PRE, because it sometimes still
+	 increases code size.  If the user want to run PRE with -Os, he/she
+	 will have to indicate so explicitly.  */
       if (optimize > 2)
 	optimize = 2;
+      flag_tree_pre = 0;
 
       /* We want to crossjump as much as possible.  */
       set_param_value ("min-crossjump-insns", 1);
@@ -2062,6 +2067,10 @@ common_handle_option (size_t scode, const char *arg, int value,
       /* These are no-ops, preserved for backward compatibility.  */
       break;
 
+    case OPT_feglibc_:
+      /* This is a no-op at the moment.  */
+      break;
+
     default:
       /* If the flag was handled in a standard way, assume the lack of
 	 processing here is intentional.  */
diff --git a/gcc/output.h b/gcc/output.h
index 79b628fd3..c447434b5 100644
--- a/gcc/output.h
+++ b/gcc/output.h
@@ -169,6 +169,11 @@ extern void emutls_finish (void);
    Prefixes such as % are optional.  */
 extern int decode_reg_name (const char *);
 
+/* Similar to decode_reg_name, but takes an extra parameter that is a
+   pointer to the number of (internal) registers described by the
+   external name.  */
+extern int decode_reg_name_and_count (const char *, int *);
+
 extern void assemble_alias (tree, tree);
 
 extern void default_assemble_visibility (tree, int);
diff --git a/gcc/passes.c b/gcc/passes.c
index 4358b8202..208107029 100644
--- a/gcc/passes.c
+++ b/gcc/passes.c
@@ -591,6 +591,7 @@ init_optimization_passes (void)
       NEXT_PASS (pass_rename_ssa_copies);
       NEXT_PASS (pass_complete_unrolli);
       NEXT_PASS (pass_ccp);
+      NEXT_PASS (pass_promote_indices);
       NEXT_PASS (pass_forwprop);
       /* Ideally the function call conditional
 	 dead code elimination phase can be delayed
@@ -605,6 +606,7 @@ init_optimization_passes (void)
 	 alias information also rewrites no longer addressed
 	 locals into SSA form if possible.  */
       NEXT_PASS (pass_build_alias);
+      NEXT_PASS (pass_remove_local_statics);
       NEXT_PASS (pass_return_slot);
       NEXT_PASS (pass_phiprop);
       NEXT_PASS (pass_fre);
@@ -791,6 +793,7 @@ init_optimization_passes (void)
 	  NEXT_PASS (pass_leaf_regs);
 	  NEXT_PASS (pass_split_before_sched2);
 	  NEXT_PASS (pass_sched2);
+	  NEXT_PASS (pass_peephole2);
 	  NEXT_PASS (pass_stack_regs);
 	    {
 	      struct opt_pass **p = &pass_stack_regs.pass.sub;
diff --git a/gcc/pointer-set.c b/gcc/pointer-set.c
index b57c404f6..d2d207857 100644
--- a/gcc/pointer-set.c
+++ b/gcc/pointer-set.c
@@ -181,6 +181,23 @@ void pointer_set_traverse (const struct pointer_set_t *pset,
       break;
 }
 
+/* Return the number of elements in PSET.  */
+
+size_t
+pointer_set_n_elements (struct pointer_set_t *pset)
+{
+  return pset->n_elements;
+}
+
+/* Remove all entries from PSET.  */
+
+void
+pointer_set_clear (struct pointer_set_t *pset)
+{
+  pset->n_elements = 0;
+  memset (pset->slots, 0, sizeof (pset->slots[0]) * pset->n_slots);
+}
+
 
 /* A pointer map is represented the same way as a pointer_set, so
    the hash code is based on the address of the key, rather than
@@ -301,3 +318,20 @@ void pointer_map_traverse (const struct pointer_map_t *pmap,
     if (pmap->keys[i] && !fn (pmap->keys[i], &pmap->values[i], data))
       break;
 }
+
+/* Return the number of elements in PMAP.  */
+
+size_t
+pointer_map_n_elements (struct pointer_map_t *pmap)
+{
+  return pmap->n_elements;
+}
+
+/* Remove all entries from PMAP.  */
+
+void pointer_map_clear (struct pointer_map_t *pmap)
+{
+  pmap->n_elements = 0;
+  memset (pmap->keys, 0, sizeof (pmap->keys[0]) * pmap->n_slots);
+  memset (pmap->values, 0, sizeof (pmap->values[0]) * pmap->n_slots);
+}
diff --git a/gcc/pointer-set.h b/gcc/pointer-set.h
index f6b085c03..75630dfe7 100644
--- a/gcc/pointer-set.h
+++ b/gcc/pointer-set.h
@@ -29,6 +29,8 @@ int pointer_set_insert (struct pointer_set_t *pset, const void *p);
 void pointer_set_traverse (const struct pointer_set_t *,
 			   bool (*) (const void *, void *),
 			   void *);
+size_t pointer_set_n_elements (struct pointer_set_t *);
+void pointer_set_clear (struct pointer_set_t *);
 
 struct pointer_map_t;
 struct pointer_map_t *pointer_map_create (void);
@@ -38,5 +40,7 @@ void **pointer_map_contains (const struct pointer_map_t *pmap, const void *p);
 void **pointer_map_insert (struct pointer_map_t *pmap, const void *p);
 void pointer_map_traverse (const struct pointer_map_t *,
 			   bool (*) (const void *, void **, void *), void *);
+size_t pointer_map_n_elements (struct pointer_map_t *);
+void pointer_map_clear (struct pointer_map_t *);
 
 #endif  /* POINTER_SET_H  */
diff --git a/gcc/postreload.c b/gcc/postreload.c
index 8abc90f83..88e017ef5 100644
--- a/gcc/postreload.c
+++ b/gcc/postreload.c
@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree.h"
 #include "timevar.h"
 #include "tree-pass.h"
+#include "addresses.h"
 #include "df.h"
 #include "dbgcnt.h"
 
@@ -708,17 +709,19 @@ reload_combine (void)
   int last_label_ruid;
   int min_labelno, n_labels;
   HARD_REG_SET ever_live_at_start, *label_live;
+  enum reg_class index_regs;
 
   /* If reg+reg can be used in offsetable memory addresses, the main chunk of
      reload has already used it where appropriate, so there is no use in
      trying to generate it now.  */
-  if (double_reg_address_ok && INDEX_REG_CLASS != NO_REGS)
+  index_regs = index_reg_class (VOIDmode);
+  if (double_reg_address_ok && index_regs != NO_REGS)
     return;
 
   /* To avoid wasting too much time later searching for an index register,
      determine the minimum and maximum index register numbers.  */
   for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)
-    if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], r))
+    if (TEST_HARD_REG_BIT (reg_class_contents[index_regs], r))
       {
 	if (first_index_reg == -1)
 	  first_index_reg = r;
@@ -826,8 +829,8 @@ reload_combine (void)
 	     substitute uses of REG (typically in MEMs) with.
 	     First check REG and BASE for being index registers;
 	     we can use them even if they are not dead.  */
-	  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], regno)
-	      || TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],
+	  if (TEST_HARD_REG_BIT (reg_class_contents[index_regs], regno)
+	      || TEST_HARD_REG_BIT (reg_class_contents[index_regs],
 				    REGNO (base)))
 	    {
 	      const_reg = reg;
@@ -841,8 +844,7 @@ reload_combine (void)
 		 two registers.  */
 	      for (i = first_index_reg; i <= last_index_reg; i++)
 		{
-		  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],
-					 i)
+		  if (TEST_HARD_REG_BIT (reg_class_contents[index_regs], i)
 		      && reg_state[i].use_index == RELOAD_COMBINE_MAX_USES
 		      && reg_state[i].store_ruid <= reg_state[regno].use_ruid
 		      && hard_regno_nregs[i][GET_MODE (reg)] == 1)
diff --git a/gcc/real.c b/gcc/real.c
index d4a3941e6..1b1df049c 100644
--- a/gcc/real.c
+++ b/gcc/real.c
@@ -4576,6 +4576,167 @@ const struct real_format decimal_quad_format =
     false
   };
 
+/* Encode half-precision floats.  This routine is used both for the IEEE
+   ARM alternative encodings.  */
+static void
+encode_ieee_half (const struct real_format *fmt, long *buf,
+		  const REAL_VALUE_TYPE *r)
+{
+  unsigned long image, sig, exp;
+  unsigned long sign = r->sign;
+  bool denormal = (r->sig[SIGSZ-1] & SIG_MSB) == 0;
+
+  image = sign << 15;
+  sig = (r->sig[SIGSZ-1] >> (HOST_BITS_PER_LONG - 11)) & 0x3ff;
+
+  switch (r->cl)
+    {
+    case rvc_zero:
+      break;
+
+    case rvc_inf:
+      if (fmt->has_inf)
+	image |= 31 << 10;
+      else
+	image |= 0x7fff;
+      break;
+
+    case rvc_nan:
+      if (fmt->has_nans)
+	{
+	  if (r->canonical)
+	    sig = (fmt->canonical_nan_lsbs_set ? (1 << 9) - 1 : 0);
+	  if (r->signalling == fmt->qnan_msb_set)
+	    sig &= ~(1 << 9);
+	  else
+	    sig |= 1 << 9;
+	  if (sig == 0)
+	    sig = 1 << 8;
+
+	  image |= 31 << 10;
+	  image |= sig;
+	}
+      else
+	image |= 0x3ff;
+      break;
+
+    case rvc_normal:
+      /* Recall that IEEE numbers are interpreted as 1.F x 2**exp,
+	 whereas the intermediate representation is 0.F x 2**exp.
+	 Which means we're off by one.  */
+      if (denormal)
+	exp = 0;
+      else
+	exp = REAL_EXP (r) + 15 - 1;
+      image |= exp << 10;
+      image |= sig;
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+
+  buf[0] = image;
+}
+
+/* Decode half-precision floats.  This routine is used both for the IEEE
+   ARM alternative encodings.  */
+static void
+decode_ieee_half (const struct real_format *fmt, REAL_VALUE_TYPE *r,
+		  const long *buf)
+{
+  unsigned long image = buf[0] & 0xffff;
+  bool sign = (image >> 15) & 1;
+  int exp = (image >> 10) & 0x1f;
+
+  memset (r, 0, sizeof (*r));
+  image <<= HOST_BITS_PER_LONG - 11;
+  image &= ~SIG_MSB;
+
+  if (exp == 0)
+    {
+      if (image && fmt->has_denorm)
+	{
+	  r->cl = rvc_normal;
+	  r->sign = sign;
+	  SET_REAL_EXP (r, -14);
+	  r->sig[SIGSZ-1] = image << 1;
+	  normalize (r);
+	}
+      else if (fmt->has_signed_zero)
+	r->sign = sign;
+    }
+  else if (exp == 31 && (fmt->has_nans || fmt->has_inf))
+    {
+      if (image)
+	{
+	  r->cl = rvc_nan;
+	  r->sign = sign;
+	  r->signalling = (((image >> (HOST_BITS_PER_LONG - 2)) & 1)
+			   ^ fmt->qnan_msb_set);
+	  r->sig[SIGSZ-1] = image;
+	}
+      else
+	{
+	  r->cl = rvc_inf;
+	  r->sign = sign;
+	}
+    }
+  else
+    {
+      r->cl = rvc_normal;
+      r->sign = sign;
+      SET_REAL_EXP (r, exp - 15 + 1);
+      r->sig[SIGSZ-1] = image | SIG_MSB;
+    }
+}
+
+/* Half-precision format, as specified in IEEE 754R.  */
+const struct real_format ieee_half_format =
+  {
+    encode_ieee_half,
+    decode_ieee_half,
+    2,
+    11,
+    11,
+    -13,
+    16,
+    15,
+    15,
+    false,
+    true,
+    true,
+    true,
+    true,
+    true,
+    true,
+    false
+  };
+
+/* ARM's alternative half-precision format, similar to IEEE but with
+   no reserved exponent value for NaNs and infinities; rather, it just
+   extends the range of exponents by one.  */
+const struct real_format arm_half_format =
+  {
+    encode_ieee_half,
+    decode_ieee_half,
+    2,
+    11,
+    11,
+    -13,
+    17,
+    15,
+    15,
+    false,
+    true,
+    false,
+    false,
+    true,
+    true,
+    false,
+    false
+  };
+
 /* A synthetic "format" for internal arithmetic.  It's the size of the
    internal significand minus the two bits needed for proper rounding.
    The encode and decode routines exist only to satisfy our paranoia
diff --git a/gcc/real.h b/gcc/real.h
index 5a6865366..5e8b8a0af 100644
--- a/gcc/real.h
+++ b/gcc/real.h
@@ -304,6 +304,8 @@ extern const struct real_format real_internal_format;
 extern const struct real_format decimal_single_format;
 extern const struct real_format decimal_double_format;
 extern const struct real_format decimal_quad_format;
+extern const struct real_format ieee_half_format;
+extern const struct real_format arm_half_format;
 
 
 /* ====================================================================== */
diff --git a/gcc/reginfo.c b/gcc/reginfo.c
index ed6373a3c..b4af4a419 100644
--- a/gcc/reginfo.c
+++ b/gcc/reginfo.c
@@ -559,10 +559,9 @@ init_reg_sets_1 (void)
       else if (i == ARG_POINTER_REGNUM && fixed_regs[i])
 	;
 #endif
-#ifndef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
-      else if (i == (unsigned) PIC_OFFSET_TABLE_REGNUM && fixed_regs[i])
+      else if (!PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
+	       && i == (unsigned) PIC_OFFSET_TABLE_REGNUM && fixed_regs[i])
 	;
-#endif
       else if (CALL_REALLY_USED_REGNO_P (i))
         {
 	  SET_HARD_REG_BIT (regs_invalidated_by_call, i);
@@ -800,36 +799,41 @@ void
 fix_register (const char *name, int fixed, int call_used)
 {
   int i;
+  int reg, nregs;
 
   /* Decode the name and update the primary form of
      the register info.  */
 
-  if ((i = decode_reg_name (name)) >= 0)
+  if ((reg = decode_reg_name_and_count (name, &nregs)) >= 0)
     {
-      if ((i == STACK_POINTER_REGNUM
+      gcc_assert (nregs >= 1);
+      for (i = reg; i < reg + nregs; i++)
+	{
+	  if ((i == STACK_POINTER_REGNUM
 #ifdef HARD_FRAME_POINTER_REGNUM
-	   || i == HARD_FRAME_POINTER_REGNUM
+	       || i == HARD_FRAME_POINTER_REGNUM
 #else
-	   || i == FRAME_POINTER_REGNUM
+	       || i == FRAME_POINTER_REGNUM
 #endif
-	   )
-	  && (fixed == 0 || call_used == 0))
-	{
-	  static const char * const what_option[2][2] = {
-	    { "call-saved", "call-used" },
-	    { "no-such-option", "fixed" }};
+	       )
+	      && (fixed == 0 || call_used == 0))
+	    {
+	      static const char * const what_option[2][2] = {
+		{ "call-saved", "call-used" },
+		{ "no-such-option", "fixed" }};
 
-	  error ("can't use '%s' as a %s register", name,
-		 what_option[fixed][call_used]);
-	}
-      else
-	{
-	  fixed_regs[i] = fixed;
-	  call_used_regs[i] = call_used;
+	      error ("can't use '%s' as a %s register", name,
+		     what_option[fixed][call_used]);
+	    }
+	  else
+	    {
+	      fixed_regs[i] = fixed;
+	      call_used_regs[i] = call_used;
 #ifdef CALL_REALLY_USED_REGISTERS
-	  if (fixed == 0)
-	    call_really_used_regs[i] = call_used;
+	      if (fixed == 0)
+		call_really_used_regs[i] = call_used;
 #endif
+	    }
 	}
     }
   else
diff --git a/gcc/regmove.c b/gcc/regmove.c
index d5f5c4d84..389dea107 100644
--- a/gcc/regmove.c
+++ b/gcc/regmove.c
@@ -855,7 +855,7 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)
 	break;
 
       /* If we have passed a call instruction, and the
-         pseudo-reg SRC is not already live across a call,
+         pseudo-reg DST is not already live across a call,
          then don't perform the optimization.  */
       /* reg_set_p is overly conservative for CALL_INSNS, thinks that all
 	 hard regs are clobbered.  Thus, we only use it for src for
@@ -868,11 +868,11 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)
 	      freq_calls += REG_FREQ_FROM_BB  (BLOCK_FOR_INSN (p));
 	    }
 
-	  if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)
+	  if (REG_N_CALLS_CROSSED (REGNO (dst)) == 0)
 	    break;
 
-	  if ((HARD_REGISTER_P (dst) && call_used_regs [REGNO (dst)])
-	      || find_reg_fusage (p, CLOBBER, dst))
+	  if ((HARD_REGISTER_P (src) && call_used_regs [REGNO (src)])
+	      || find_reg_fusage (p, CLOBBER, src))
 	    break;
 	}
       else if (reg_set_p (src, PATTERN (p)))
diff --git a/gcc/regrename.c b/gcc/regrename.c
index c678a093c..24d50ba65 100644
--- a/gcc/regrename.c
+++ b/gcc/regrename.c
@@ -567,14 +567,14 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,
 	    int index_op;
 	    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);
 
-	    if (REGNO_OK_FOR_INDEX_P (regno1)
+	    if (regno_ok_for_index_p (regno1, mode)
 		&& regno_ok_for_base_p (regno0, mode, PLUS, REG))
 	      index_op = 1;
-	    else if (REGNO_OK_FOR_INDEX_P (regno0)
+	    else if (regno_ok_for_index_p (regno0, mode)
 		     && regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
 	    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG)
-		     || REGNO_OK_FOR_INDEX_P (regno1))
+		     || regno_ok_for_index_p (regno1, mode))
 	      index_op = 1;
 	    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
@@ -599,7 +599,7 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,
 	  }
 
 	if (locI)
-	  scan_rtx_address (insn, locI, INDEX_REG_CLASS, action, mode);
+	  scan_rtx_address (insn, locI, index_reg_class (mode), action, mode);
 	if (locB)
 	  scan_rtx_address (insn, locB, base_reg_class (mode, PLUS, index_code),
 			    action, mode);
@@ -1488,14 +1488,14 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,
 	    int index_op;
 	    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);
 
-	    if (REGNO_OK_FOR_INDEX_P (regno1)
+	    if (regno_ok_for_index_p (regno1, mode)
 		&& regno_ok_for_base_p (regno0, mode, PLUS, REG))
 	      index_op = 1;
-	    else if (REGNO_OK_FOR_INDEX_P (regno0)
+	    else if (regno_ok_for_index_p (regno0, mode)
 		     && regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
 	    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG)
-		     || REGNO_OK_FOR_INDEX_P (regno1))
+		     || regno_ok_for_index_p (regno1, mode))
 	      index_op = 1;
 	    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
@@ -1520,8 +1520,8 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,
 	  }
 
 	if (locI)
-	  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS, mode,
-						insn, vd);
+	  changed |= replace_oldest_value_addr (locI, index_reg_class (mode),
+						mode, insn, vd);
 	if (locB)
 	  changed |= replace_oldest_value_addr (locB,
 						base_reg_class (mode, PLUS,
diff --git a/gcc/reload.c b/gcc/reload.c
index eadaa50b3..d42d25b8a 100644
--- a/gcc/reload.c
+++ b/gcc/reload.c
@@ -5046,7 +5046,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,
 	    loc = &XEXP (*loc, 0);
 	}
 
-      if (double_reg_address_ok)
+      if (double_reg_address_ok && index_reg_class (mode) != NO_REGS)
 	{
 	  /* Unshare the sum as well.  */
 	  *loc = ad = copy_rtx (ad);
@@ -5054,8 +5054,8 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,
 	  /* Reload the displacement into an index reg.
 	     We assume the frame pointer or arg pointer is a base reg.  */
 	  find_reloads_address_part (XEXP (ad, 1), &XEXP (ad, 1),
-				     INDEX_REG_CLASS, GET_MODE (ad), opnum,
-				     type, ind_levels);
+				     index_reg_class (mode), GET_MODE (ad),
+				     opnum, type, ind_levels);
 	  return 0;
 	}
       else
@@ -5448,13 +5448,13 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,
 #define REG_OK_FOR_CONTEXT(CONTEXT, REGNO, MODE, OUTER, INDEX)		\
   ((CONTEXT) == 0							\
    ? regno_ok_for_base_p (REGNO, MODE, OUTER, INDEX)			\
-   : REGNO_OK_FOR_INDEX_P (REGNO))					
+   : regno_ok_for_index_p (REGNO, MODE))
 
   enum reg_class context_reg_class;
   RTX_CODE code = GET_CODE (x);
 
   if (context == 1)
-    context_reg_class = INDEX_REG_CLASS;
+    context_reg_class = index_reg_class (mode);
   else
     context_reg_class = base_reg_class (mode, outer_code, index_code);
 
@@ -5546,17 +5546,17 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,
 
 	else if (code0 == REG && code1 == REG)
 	  {
-	    if (REGNO_OK_FOR_INDEX_P (REGNO (op1))
+	    if (regno_ok_for_index_p (REGNO (op1), mode)
 		&& regno_ok_for_base_p (REGNO (op0), mode, PLUS, REG))
 	      return 0;
-	    else if (REGNO_OK_FOR_INDEX_P (REGNO (op0))
+	    else if (regno_ok_for_index_p (REGNO (op0), mode)
 		     && regno_ok_for_base_p (REGNO (op1), mode, PLUS, REG))
 	      return 0;
 	    else if (regno_ok_for_base_p (REGNO (op0), mode, PLUS, REG))
 	      find_reloads_address_1 (mode, orig_op1, 1, PLUS, SCRATCH,
 				      &XEXP (x, 1), opnum, type, ind_levels,
 				      insn);
-	    else if (REGNO_OK_FOR_INDEX_P (REGNO (op1)))
+	    else if (regno_ok_for_index_p (REGNO (op1), mode))
 	      find_reloads_address_1 (mode, orig_op0, 0, PLUS, REG,
 				      &XEXP (x, 0), opnum, type, ind_levels,
 				      insn);
@@ -5564,7 +5564,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,
 	      find_reloads_address_1 (mode, orig_op0, 1, PLUS, SCRATCH,
 				      &XEXP (x, 0), opnum, type, ind_levels,
 				      insn);
-	    else if (REGNO_OK_FOR_INDEX_P (REGNO (op0)))
+	    else if (regno_ok_for_index_p (REGNO (op0), mode))
 	      find_reloads_address_1 (mode, orig_op1, 0, PLUS, REG,
 				      &XEXP (x, 1), opnum, type, ind_levels,
 				      insn);
@@ -5634,7 +5634,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,
 	   need to live longer than a TYPE reload normally would, so be
 	   conservative and class it as RELOAD_OTHER.  */
 	if ((REG_P (XEXP (op1, 1))
-	     && !REGNO_OK_FOR_INDEX_P (REGNO (XEXP (op1, 1))))
+	     && !regno_ok_for_index_p (REGNO (XEXP (op1, 1)), mode))
 	    || GET_CODE (XEXP (op1, 1)) == PLUS)
 	  find_reloads_address_1 (mode, XEXP (op1, 1), 1, code, SCRATCH,
 				  &XEXP (op1, 1), opnum, RELOAD_OTHER,
@@ -6131,18 +6131,26 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,
 	      /* For some processors an address may be valid in the
 		 original mode but not in a smaller mode.  For
 		 example, ARM accepts a scaled index register in
-		 SImode but not in HImode.  Similarly, the address may
-		 have been valid before the subreg offset was added,
-		 but not afterwards.  find_reloads_address
-		 assumes that we pass it a valid address, and doesn't
-		 force a reload.  This will probably be fine if
-		 find_reloads_address finds some reloads.  But if it
-		 doesn't find any, then we may have just converted a
-		 valid address into an invalid one.  Check for that
-		 here.  */
+		 SImode but not in HImode.  Note that this is only
+		 a problem if the address in reg_equiv_mem is already
+		 invalid in the new mode; other cases would be fixed
+		 by find_reloads_address as usual.
+
+		 ??? We attempt to handle such cases here by doing an
+		 additional reload of the full address after the
+		 usual processing by find_reloads_address.  Note that
+		 this may not work in the general case, but it seems
+		 to cover the cases where this situation currently
+		 occurs.  A more general fix might be to reload the
+		 *value* instead of the address, but this would not
+		 be expected by the callers of this routine as-is.
+
+		 If find_reloads_address already completed replaced
+		 the address, there is nothing further to do.  */
 	      if (reloaded == 0
-		  && !strict_memory_address_p (GET_MODE (tem),
-					       XEXP (tem, 0)))
+		  && reg_equiv_mem[regno] != 0
+		  && !strict_memory_address_p (GET_MODE (x),
+					       XEXP (reg_equiv_mem[regno], 0)))
 		push_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,
 			     base_reg_class (GET_MODE (tem), MEM, SCRATCH),
 			     GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0,
diff --git a/gcc/rtl.def b/gcc/rtl.def
index 33bf6bd18..662a9f0c8 100644
--- a/gcc/rtl.def
+++ b/gcc/rtl.def
@@ -1088,7 +1088,11 @@ DEF_RTL_EXPR(FINAL_ABSENCE_SET, "final_absence_set", "ss", RTX_EXTRA)
    guard for the bypass.  The function will get the two insns as
    parameters.  If the function returns zero the bypass will be
    ignored for this case.  Additional guard is necessary to recognize
-   complicated bypasses, e.g. when consumer is load address.  */
+   complicated bypasses, e.g. when consumer is load address.  If there
+   are more one bypass with the same output and input insns, the
+   chosen bypass is the first bypass with a guard in description whose
+   guard function returns nonzero.  If there is no such bypass, then
+   bypass without the guard function is chosen.  */
 DEF_RTL_EXPR(DEFINE_BYPASS, "define_bypass", "issS", RTX_EXTRA)
 
 /* (define_automaton string) describes names of automata generated and
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index e6cec483b..488b899d3 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -132,13 +132,11 @@ rtx_unstable_p (const_rtx x)
 	  /* The arg pointer varies if it is not a fixed register.  */
 	  || (x == arg_pointer_rtx && fixed_regs[ARG_POINTER_REGNUM]))
 	return 0;
-#ifndef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
       /* ??? When call-clobbered, the value is stable modulo the restore
 	 that must happen after a call.  This currently screws up local-alloc
 	 into believing that the restore is not needed.  */
-      if (x == pic_offset_table_rtx)
+      if (!PIC_OFFSET_TABLE_REG_CALL_CLOBBERED && x == pic_offset_table_rtx)
 	return 0;
-#endif
       return 1;
 
     case ASM_OPERANDS:
@@ -211,14 +209,11 @@ rtx_varies_p (const_rtx x, bool for_alias)
 	  || (x == arg_pointer_rtx && fixed_regs[ARG_POINTER_REGNUM]))
 	return 0;
       if (x == pic_offset_table_rtx
-#ifdef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
 	  /* ??? When call-clobbered, the value is stable modulo the restore
 	     that must happen after a call.  This currently screws up
 	     local-alloc into believing that the restore is not needed, so we
 	     must return 0 only if we are called from alias analysis.  */
-	  && for_alias
-#endif
-	  )
+	  && (!PIC_OFFSET_TABLE_REG_CALL_CLOBBERED || for_alias))
 	return 0;
       return 1;
 
@@ -2913,62 +2908,78 @@ int
 commutative_operand_precedence (rtx op)
 {
   enum rtx_code code = GET_CODE (op);
+  int value;
   
   /* Constants always come the second operand.  Prefer "nice" constants.  */
   if (code == CONST_INT)
-    return -8;
-  if (code == CONST_DOUBLE)
-    return -7;
-  if (code == CONST_FIXED)
-    return -7;
-  op = avoid_constant_pool_reference (op);
-  code = GET_CODE (op);
-
-  switch (GET_RTX_CLASS (code))
+    value = -8;
+  else if (code == CONST_DOUBLE)
+    value = -7;
+  else if (code == CONST_FIXED)
+    value = -7;
+  else
     {
-    case RTX_CONST_OBJ:
-      if (code == CONST_INT)
-        return -6;
-      if (code == CONST_DOUBLE)
-        return -5;
-      if (code == CONST_FIXED)
-        return -5;
-      return -4;
-
-    case RTX_EXTRA:
-      /* SUBREGs of objects should come second.  */
-      if (code == SUBREG && OBJECT_P (SUBREG_REG (op)))
-        return -3;
-      return 0;
+      op = avoid_constant_pool_reference (op);
+      code = GET_CODE (op);
 
-    case RTX_OBJ:
-      /* Complex expressions should be the first, so decrease priority
-         of objects.  Prefer pointer objects over non pointer objects.  */
-      if ((REG_P (op) && REG_POINTER (op))
-	  || (MEM_P (op) && MEM_POINTER (op)))
-	return -1;
-      return -2;
-
-    case RTX_COMM_ARITH:
-      /* Prefer operands that are themselves commutative to be first.
-         This helps to make things linear.  In particular,
-         (and (and (reg) (reg)) (not (reg))) is canonical.  */
-      return 4;
-
-    case RTX_BIN_ARITH:
-      /* If only one operand is a binary expression, it will be the first
-         operand.  In particular,  (plus (minus (reg) (reg)) (neg (reg)))
-         is canonical, although it will usually be further simplified.  */
-      return 2;
+      switch (GET_RTX_CLASS (code))
+	{
+	case RTX_CONST_OBJ:
+	  if (code == CONST_INT)
+	    value = -6;
+	  else if (code == CONST_DOUBLE)
+	    value = -5;
+	  else if (code == CONST_FIXED)
+	    value = -5;
+	  else
+	    value = -4;
+	  break;
+
+	case RTX_EXTRA:
+	  /* SUBREGs of objects should come second.  */
+	  if (code == SUBREG && OBJECT_P (SUBREG_REG (op)))
+	    value = -3;
+	  else
+	    value = 0;
+	  break;
+
+	case RTX_OBJ:
+	  /* Complex expressions should be the first, so decrease priority
+	     of objects.  */
+	  value = -1;
+	  break;
+
+	case RTX_COMM_ARITH:
+	  /* Prefer operands that are themselves commutative to be first.
+	     This helps to make things linear.  In particular,
+	     (and (and (reg) (reg)) (not (reg))) is canonical.  */
+	  value = 4;
+	  break;
+
+	case RTX_BIN_ARITH:
+	  /* If only one operand is a binary expression, it will be the first
+	     operand.  In particular,  (plus (minus (reg) (reg)) (neg (reg)))
+	     is canonical, although it will usually be further simplified.  */
+	  value = 2;
+	  break;
   
-    case RTX_UNARY:
-      /* Then prefer NEG and NOT.  */
-      if (code == NEG || code == NOT)
-        return 1;
+	case RTX_UNARY:
+	  /* Then prefer NEG and NOT.  */
+	  if (code == NEG || code == NOT)
+	    value = 1;
+	  else
+	    value = 0;
+	  break;
 
-    default:
-      return 0;
+	default:
+	  value = 0;
+	}
     }
+
+  if (targetm.commutative_operand_precedence)
+    value = targetm.commutative_operand_precedence (op, value);
+
+  return value;
 }
 
 /* Return 1 iff it is necessary to swap operands of commutative operation
diff --git a/gcc/sched-ebb.c b/gcc/sched-ebb.c
index c90e3afc8..fb790fd1d 100644
--- a/gcc/sched-ebb.c
+++ b/gcc/sched-ebb.c
@@ -286,6 +286,7 @@ static struct haifa_sched_info ebb_sched_info =
   rank,
   ebb_print_insn,
   ebb_contributes_to_priority,
+  NULL, /* insn_finishes_block_p */
 
   NULL, NULL,
   NULL, NULL,
diff --git a/gcc/sched-int.h b/gcc/sched-int.h
index a64b3ea6a..90d569ac4 100644
--- a/gcc/sched-int.h
+++ b/gcc/sched-int.h
@@ -558,6 +558,10 @@ struct haifa_sched_info
      calculations.  */
   int (*contributes_to_priority) (rtx, rtx);
 
+  /* Return true if scheduling insn (passed as the parameter) will trigger
+     finish of scheduling current block.  */
+  bool (*insn_finishes_block_p) (rtx);
+
   /* The boundaries of the set of insns to be scheduled.  */
   rtx prev_head, next_tail;
 
diff --git a/gcc/sched-rgn.c b/gcc/sched-rgn.c
index 958f22e0c..59256395f 100644
--- a/gcc/sched-rgn.c
+++ b/gcc/sched-rgn.c
@@ -2338,6 +2338,19 @@ static const struct sched_deps_info_def rgn_const_sel_sched_deps_info =
     0, 0, 0
   };
 
+/* Return true if scheduling INSN will trigger finish of scheduling
+   current block.  */
+static bool
+rgn_insn_finishes_block_p (rtx insn)
+{
+  if (INSN_BB (insn) == target_bb
+      && sched_target_n_insns + 1 == target_n_insns)
+    /* INSN is the last not-scheduled instruction in the current block.  */
+    return true;
+
+  return false;
+}
+
 /* Used in schedule_insns to initialize current_sched_info for scheduling
    regions (or single basic blocks).  */
 
@@ -2350,6 +2363,7 @@ static const struct haifa_sched_info rgn_const_sched_info =
   rgn_rank,
   rgn_print_insn,
   contributes_to_priority,
+  rgn_insn_finishes_block_p,
 
   NULL, NULL,
   NULL, NULL,
diff --git a/gcc/sdbout.c b/gcc/sdbout.c
index eece5da97..cbc6ca078 100644
--- a/gcc/sdbout.c
+++ b/gcc/sdbout.c
@@ -338,6 +338,7 @@ const struct gcc_debug_hooks sdb_debug_hooks =
   debug_nothing_int,		         /* handle_pch */
   debug_nothing_rtx,		         /* var_location */
   debug_nothing_void,                    /* switch_text_section */
+  debug_nothing_tree_tree,		 /* set_name */
   0                                      /* start_end_main_source_file */
 };
 
diff --git a/gcc/sel-sched-ir.c b/gcc/sel-sched-ir.c
index ab2742fd8..03dd75ed7 100644
--- a/gcc/sel-sched-ir.c
+++ b/gcc/sel-sched-ir.c
@@ -5545,6 +5545,7 @@ static struct haifa_sched_info sched_sel_haifa_sched_info =
   NULL, /* rgn_rank */
   sel_print_insn, /* rgn_print_insn */
   contributes_to_priority,
+  NULL, /* insn_finishes_block_p */
 
   NULL, NULL,
   NULL, NULL,
diff --git a/gcc/stmt.c b/gcc/stmt.c
index 565ee5a63..9175698f1 100644
--- a/gcc/stmt.c
+++ b/gcc/stmt.c
@@ -681,13 +681,14 @@ expand_asm_operands (tree string, tree outputs, tree inputs,
   for (tail = clobbers; tail; tail = TREE_CHAIN (tail))
     {
       const char *regname;
+      int nregs;
 
       if (TREE_VALUE (tail) == error_mark_node)
 	return;
       regname = TREE_STRING_POINTER (TREE_VALUE (tail));
 
-      i = decode_reg_name (regname);
-      if (i >= 0 || i == -4)
+      i = decode_reg_name_and_count (regname, &nregs);
+      if (i == -4)
 	++nclobbers;
       else if (i == -2)
 	error ("unknown register name %qs in %<asm%>", regname);
@@ -695,14 +696,21 @@ expand_asm_operands (tree string, tree outputs, tree inputs,
       /* Mark clobbered registers.  */
       if (i >= 0)
         {
-	  /* Clobbering the PIC register is an error.  */
-	  if (i == (int) PIC_OFFSET_TABLE_REGNUM)
+	  int reg;
+
+	  for (reg = i; reg < i + nregs; reg++)
 	    {
-	      error ("PIC register %qs clobbered in %<asm%>", regname);
-	      return;
-	    }
+	      ++nclobbers;
+
+	      /* Clobbering the PIC register is an error.  */
+	      if (reg == (int) PIC_OFFSET_TABLE_REGNUM)
+		{
+		  error ("PIC register clobbered by %qs in %<asm%>", regname);
+		  return;
+		}
 
-	  SET_HARD_REG_BIT (clobbered_regs, i);
+	      SET_HARD_REG_BIT (clobbered_regs, reg);
+	    }
 	}
     }
 
@@ -1012,7 +1020,8 @@ expand_asm_operands (tree string, tree outputs, tree inputs,
       for (tail = clobbers; tail; tail = TREE_CHAIN (tail))
 	{
 	  const char *regname = TREE_STRING_POINTER (TREE_VALUE (tail));
-	  int j = decode_reg_name (regname);
+	  int reg, nregs;
+	  int j = decode_reg_name_and_count (regname, &nregs);
 	  rtx clobbered_reg;
 
 	  if (j < 0)
@@ -1034,30 +1043,39 @@ expand_asm_operands (tree string, tree outputs, tree inputs,
 	      continue;
 	    }
 
-	  /* Use QImode since that's guaranteed to clobber just one reg.  */
-	  clobbered_reg = gen_rtx_REG (QImode, j);
-
-	  /* Do sanity check for overlap between clobbers and respectively
-	     input and outputs that hasn't been handled.  Such overlap
-	     should have been detected and reported above.  */
-	  if (!clobber_conflict_found)
+	  for (reg = j; reg < j + nregs; reg++)
 	    {
-	      int opno;
-
-	      /* We test the old body (obody) contents to avoid tripping
-		 over the under-construction body.  */
-	      for (opno = 0; opno < noutputs; opno++)
-		if (reg_overlap_mentioned_p (clobbered_reg, output_rtx[opno]))
-		  internal_error ("asm clobber conflict with output operand");
-
-	      for (opno = 0; opno < ninputs - ninout; opno++)
-		if (reg_overlap_mentioned_p (clobbered_reg,
-					     ASM_OPERANDS_INPUT (obody, opno)))
-		  internal_error ("asm clobber conflict with input operand");
-	    }
+	      /* Use QImode since that's guaranteed to clobber just
+	       * one reg.  */
+	      clobbered_reg = gen_rtx_REG (QImode, reg);
+
+	      /* Do sanity check for overlap between clobbers and
+		 respectively input and outputs that hasn't been
+		 handled.  Such overlap should have been detected and
+		 reported above.  */
+	      if (!clobber_conflict_found)
+		{
+		  int opno;
+
+		  /* We test the old body (obody) contents to avoid
+		     tripping over the under-construction body.  */
+		  for (opno = 0; opno < noutputs; opno++)
+		    if (reg_overlap_mentioned_p (clobbered_reg,
+						 output_rtx[opno]))
+		      internal_error
+			("asm clobber conflict with output operand");
+
+		  for (opno = 0; opno < ninputs - ninout; opno++)
+		    if (reg_overlap_mentioned_p (clobbered_reg,
+						 ASM_OPERANDS_INPUT (obody,
+								     opno)))
+		      internal_error
+			("asm clobber conflict with input operand");
+		}
 
-	  XVECEXP (body, 0, i++)
-	    = gen_rtx_CLOBBER (VOIDmode, clobbered_reg);
+	      XVECEXP (body, 0, i++)
+		= gen_rtx_CLOBBER (VOIDmode, clobbered_reg);
+	    }
 	}
 
       emit_insn (body);
diff --git a/gcc/target-def.h b/gcc/target-def.h
index e19cde3f0..b647a5fb8 100644
--- a/gcc/target-def.h
+++ b/gcc/target-def.h
@@ -84,7 +84,7 @@
 #define TARGET_ASM_INTERNAL_LABEL default_internal_label
 #endif
 
-#ifndef TARGET_ARM_TTYPE
+#ifndef TARGET_ASM_TTYPE
 #define TARGET_ASM_TTYPE hook_bool_rtx_false
 #endif
 
@@ -208,6 +208,10 @@
 #define TARGET_EXTRA_LIVE_ON_ENTRY hook_void_bitmap
 #endif
 
+#ifndef TARGET_WARN_FUNC_RESULT
+#define TARGET_WARN_FUNC_RESULT hook_bool_void_true
+#endif
+
 #ifndef TARGET_ASM_FILE_START_APP_OFF
 #define TARGET_ASM_FILE_START_APP_OFF false
 #endif
@@ -236,6 +240,10 @@
 #define TARGET_ASM_OUTPUT_DWARF_DTPREL NULL
 #endif
 
+#ifndef TARGET_ASM_FINAL_POSTSCAN_INSN
+#define TARGET_ASM_FINAL_POSTSCAN_INSN NULL
+#endif
+
 #ifndef TARGET_ASM_RECORD_GCC_SWITCHES
 #define TARGET_ASM_RECORD_GCC_SWITCHES NULL
 #endif
@@ -291,7 +299,8 @@
 			TARGET_ASM_RECORD_GCC_SWITCHES,		\
 			TARGET_ASM_RECORD_GCC_SWITCHES_SECTION,	\
 			TARGET_ASM_OUTPUT_ANCHOR,		\
-			TARGET_ASM_OUTPUT_DWARF_DTPREL}
+			TARGET_ASM_OUTPUT_DWARF_DTPREL,		\
+			TARGET_ASM_FINAL_POSTSCAN_INSN}
 
 /* Scheduler hooks.  All of these default to null pointers, which
    haifa-sched.c looks for and handles.  */
@@ -383,6 +392,9 @@
 #define TARGET_VECTOR_ALIGNMENT_REACHABLE \
   default_builtin_vector_alignment_reachable
 #define TARGET_VECTORIZE_BUILTIN_VEC_PERM 0
+#define TARGET_VECTOR_MIN_ALIGNMENT \
+  default_vector_min_alignment
+#define TARGET_VECTOR_ALWAYS_MISALIGN hook_bool_const_tree_false
 
 #define TARGET_VECTORIZE                                                \
   {									\
@@ -393,7 +405,9 @@
     TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD,				\
     TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST,			\
     TARGET_VECTOR_ALIGNMENT_REACHABLE,                                  \
-    TARGET_VECTORIZE_BUILTIN_VEC_PERM                                   \
+    TARGET_VECTORIZE_BUILTIN_VEC_PERM,                                  \
+    TARGET_VECTOR_MIN_ALIGNMENT,                                        \
+    TARGET_VECTOR_ALWAYS_MISALIGN,                                      \
   }
 
 #define TARGET_DEFAULT_TARGET_FLAGS 0
@@ -504,6 +518,7 @@
 #define TARGET_ALLOCATE_INITIAL_VALUE NULL
 
 #define TARGET_UNSPEC_MAY_TRAP_P default_unspec_may_trap_p
+#define TARGET_COMMUTATIVE_OPERAND_PRECEDENCE NULL
 
 #ifndef TARGET_SET_CURRENT_FUNCTION
 #define TARGET_SET_CURRENT_FUNCTION hook_void_tree
@@ -532,6 +547,10 @@
 #define TARGET_INVALID_CONVERSION hook_constcharptr_const_tree_const_tree_null
 #define TARGET_INVALID_UNARY_OP hook_constcharptr_int_const_tree_null
 #define TARGET_INVALID_BINARY_OP hook_constcharptr_int_const_tree_const_tree_null
+#define TARGET_INVALID_PARAMETER_TYPE hook_constcharptr_const_tree_null
+#define TARGET_INVALID_RETURN_TYPE hook_constcharptr_const_tree_null
+#define TARGET_PROMOTED_TYPE hook_tree_const_tree_null
+#define TARGET_CONVERT_TO_TYPE hook_tree_tree_tree_null
 
 #define TARGET_FIXED_CONDITION_CODE_REGS hook_bool_uintp_uintp_false
 
@@ -590,6 +609,7 @@
 #define TARGET_ARG_PARTIAL_BYTES hook_int_CUMULATIVE_ARGS_mode_tree_bool_0
 
 #define TARGET_FUNCTION_VALUE default_function_value
+#define TARGET_LIBCALL_VALUE default_libcall_value
 #define TARGET_INTERNAL_ARG_POINTER default_internal_arg_pointer
 #define TARGET_UPDATE_STACK_BOUNDARY NULL
 #define TARGET_GET_DRAP_RTX NULL
@@ -613,6 +633,7 @@
    TARGET_ARG_PARTIAL_BYTES,					\
    TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN,			\
    TARGET_FUNCTION_VALUE,					\
+   TARGET_LIBCALL_VALUE,					\
    TARGET_INTERNAL_ARG_POINTER,					\
    TARGET_UPDATE_STACK_BOUNDARY,				\
    TARGET_GET_DRAP_RTX,						\
@@ -716,6 +737,11 @@
 #define TARGET_CXX_ADJUST_CLASS_AT_DEFINITION hook_void_tree
 #endif
 
+
+#ifndef TARGET_CXX_TTYPE_REF_ENCODE
+#define TARGET_CXX_TTYPE_REF_ENCODE NULL
+#endif
+
 #define TARGET_CXX				\
   {						\
     TARGET_CXX_GUARD_TYPE,			\
@@ -730,7 +756,8 @@
     TARGET_CXX_LIBRARY_RTTI_COMDAT,	        \
     TARGET_CXX_USE_AEABI_ATEXIT,		\
     TARGET_CXX_USE_ATEXIT_FOR_CXA_ATEXIT,	\
-    TARGET_CXX_ADJUST_CLASS_AT_DEFINITION	\
+    TARGET_CXX_ADJUST_CLASS_AT_DEFINITION,	\
+    TARGET_CXX_TTYPE_REF_ENCODE			\
   }
 
 /* EMUTLS specific */
@@ -886,6 +913,7 @@
   TARGET_ADDRESS_COST,				\
   TARGET_ALLOCATE_INITIAL_VALUE,		\
   TARGET_UNSPEC_MAY_TRAP_P,                     \
+  TARGET_COMMUTATIVE_OPERAND_PRECEDENCE,        \
   TARGET_DWARF_REGISTER_SPAN,                   \
   TARGET_INIT_DWARF_REG_SIZES_EXTRA,		\
   TARGET_FIXED_CONDITION_CODE_REGS,		\
@@ -913,6 +941,10 @@
   TARGET_INVALID_CONVERSION,			\
   TARGET_INVALID_UNARY_OP,			\
   TARGET_INVALID_BINARY_OP,			\
+  TARGET_INVALID_PARAMETER_TYPE,		\
+  TARGET_INVALID_RETURN_TYPE,			\
+  TARGET_PROMOTED_TYPE,				\
+  TARGET_CONVERT_TO_TYPE,			\
   TARGET_IRA_COVER_CLASSES,			\
   TARGET_SECONDARY_RELOAD,			\
   TARGET_EXPAND_TO_RTL_HOOK,			\
@@ -923,6 +955,7 @@
   TARGET_EMUTLS,				\
   TARGET_OPTION_HOOKS,				\
   TARGET_EXTRA_LIVE_ON_ENTRY,			\
+  TARGET_WARN_FUNC_RESULT,			\
   TARGET_UNWIND_TABLES_DEFAULT,			\
   TARGET_HAVE_NAMED_SECTIONS,			\
   TARGET_HAVE_SWITCHABLE_BSS_SECTIONS,		\
diff --git a/gcc/target.h b/gcc/target.h
index 4fb379465..93ddac0da 100644
--- a/gcc/target.h
+++ b/gcc/target.h
@@ -245,6 +245,8 @@ struct gcc_target
     /* Output a DTP-relative reference to a TLS symbol.  */
     void (*output_dwarf_dtprel) (FILE *file, int size, rtx x);
 
+    /* Some target machines need to postscan each insn after it is output.  */
+    void (*final_postscan_insn) (FILE *, rtx, rtx *, int);
   } asm_out;
 
   /* Functions relating to instruction scheduling.  */
@@ -473,7 +475,16 @@ struct gcc_target
 
     /* Target builtin that implements vector permute.  */
     tree (* builtin_vec_perm) (tree, tree*);
-} vectorize;
+
+    /* Return the minimum alignment required to load or store a
+       vector of the given type, which may be less than the
+       natural alignment of the type.  */
+    int (* vector_min_alignment) (const_tree);
+
+    /* Return true if "movmisalign" patterns should be used for all
+       loads/stores from data arrays.  */
+    bool (* always_misalign) (const_tree);
+  } vectorize;
 
   /* The initial value of target_flags.  */
   int default_target_flags;
@@ -694,6 +705,10 @@ struct gcc_target
      FLAGS has the same meaning as in rtlanal.c: may_trap_p_1.  */
   int (* unspec_may_trap_p) (const_rtx x, unsigned flags);
 
+  /* Return a value indicating whether an operand of a commutative
+     operation is preferred as the first or second operand.  */
+  int (* commutative_operand_precedence) (const_rtx, int);
+
   /* Given a register, this hook should return a parallel of registers
      to represent where to find the register pieces.  Define this hook
      if the register and its mode are represented in Dwarf in
@@ -870,6 +885,10 @@ struct gcc_target
     rtx (*function_value) (const_tree ret_type, const_tree fn_decl_or_type,
 			   bool outgoing);
 
+    /* Return the rtx for the result of a libcall of mode MODE,
+       calling the function FN_NAME.  */
+    rtx (*libcall_value) (enum machine_mode, rtx);
+
     /* Return an rtx for the argument pointer incoming to the
        current function.  */
     rtx (*internal_arg_pointer) (void);
@@ -899,6 +918,24 @@ struct gcc_target
      is not permitted on TYPE1 and TYPE2, NULL otherwise.  */
   const char *(*invalid_binary_op) (int op, const_tree type1, const_tree type2);
 
+  /* Return the diagnostic message string if TYPE is not valid as a
+     function parameter type, NULL otherwise.  */
+  const char *(*invalid_parameter_type) (const_tree type);
+
+  /* Return the diagnostic message string if TYPE is not valid as a
+     function return type, NULL otherwise.  */
+  const char *(*invalid_return_type) (const_tree type);
+
+  /* If values of TYPE are promoted to some other type when used in
+     expressions (analogous to the integer promotions), return that type,
+     or NULL_TREE otherwise.  */
+  tree (*promoted_type) (const_tree type);
+
+  /* Convert EXPR to TYPE, if target-specific types with special conversion
+     rules are involved.  Return the converted expression, or NULL to apply
+     the standard conversion rules.  */
+  tree (*convert_to_type) (tree type, tree expr);
+
   /* Return the array of IRA cover classes for the current target.  */
   const enum reg_class *(*ira_cover_classes) (void);
 
@@ -977,6 +1014,11 @@ struct gcc_target
        class  (eg, tweak visibility or perform any other required
        target modifications).  */
     void (*adjust_class_at_definition) (tree type);
+    /* Encode a reference type info, used for catching pointer
+       references.  The provided expression will be the address of the
+       type info object of the type to which a reference is being
+       caught.  */
+    tree (* ttype_ref_encode) (tree);
   } cxx;
 
   /* Functions and data for emulated TLS support.  */
@@ -1040,6 +1082,10 @@ struct gcc_target
      bits in the bitmap passed in. */  
   void (*live_on_entry) (bitmap); 
 
+  /* Return false if warnings about missing return statements or suspect
+     noreturn attributes should be suppressed for the current function.  */
+  bool (*warn_func_result) (void);
+
   /* True if unwinding tables should be generated by default.  */
   bool unwind_tables_default;
 
diff --git a/gcc/targhooks.c b/gcc/targhooks.c
index 5b7b8751b..14a82d0d5 100644
--- a/gcc/targhooks.c
+++ b/gcc/targhooks.c
@@ -65,7 +65,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "reload.h"
 #include "optabs.h"
 #include "recog.h"
-
+#include "convert.h"
 
 void
 default_external_libcall (rtx fun ATTRIBUTE_UNUSED)
@@ -441,6 +441,18 @@ hook_invalid_arg_for_unprototyped_fn (
   return NULL;
 }
 
+tree
+hook_cxx_ttype_ref_in_bit0 (tree exp)
+{
+  tree pointer_type = build_pointer_type (char_type_node);
+  tree one = convert (sizetype, integer_one_node);
+  
+  exp = convert_to_pointer (pointer_type, exp);
+  exp = fold_build2 (POINTER_PLUS_EXPR, pointer_type, exp, one);
+  
+  return exp;
+}
+
 /* Initialize the stack protection decls.  */
 
 /* Stack protection related decls living in libgcc.  */
@@ -453,6 +465,8 @@ default_stack_protect_guard (void)
 
   if (t == NULL)
     {
+      rtx x;
+
       t = build_decl (VAR_DECL, get_identifier ("__stack_chk_guard"),
 		      ptr_type_node);
       TREE_STATIC (t) = 1;
@@ -463,6 +477,11 @@ default_stack_protect_guard (void)
       DECL_ARTIFICIAL (t) = 1;
       DECL_IGNORED_P (t) = 1;
 
+      /* Do not share RTL as the declaration is visible outside of
+	 current function.  */
+      x = DECL_RTL (t);
+      RTX_FLAG (x, used) = 1;
+
       stack_chk_guard_decl = t;
     }
 
@@ -560,6 +579,12 @@ default_function_value (const_tree ret_type ATTRIBUTE_UNUSED,
 #endif
 }
 
+rtx
+default_libcall_value (enum machine_mode mode, rtx fun ATTRIBUTE_UNUSED)
+{
+  return LIBCALL_VALUE (mode);
+}
+
 rtx
 default_internal_arg_pointer (void)
 {
@@ -712,6 +737,12 @@ default_builtin_vector_alignment_reachable (const_tree type, bool is_packed)
   return true;
 }
 
+int
+default_vector_min_alignment (const_tree type)
+{
+  return TYPE_ALIGN_UNIT (type);
+}
+
 bool
 default_hard_regno_scratch_ok (unsigned int regno ATTRIBUTE_UNUSED)
 {
diff --git a/gcc/targhooks.h b/gcc/targhooks.h
index 07ade39a7..7c47bc60e 100644
--- a/gcc/targhooks.h
+++ b/gcc/targhooks.h
@@ -48,6 +48,7 @@ extern enum machine_mode default_mode_for_suffix (char);
 
 extern tree default_cxx_guard_type (void);
 extern tree default_cxx_get_cookie_size (tree);
+extern tree hook_cxx_ttype_ref_in_bit0 (tree);
 
 extern bool hook_pass_by_reference_must_pass_in_stack
   (CUMULATIVE_ARGS *, enum machine_mode mode, const_tree, bool);
@@ -71,6 +72,8 @@ extern tree default_builtin_reciprocal (enum built_in_function, bool, bool);
 
 extern bool default_builtin_vector_alignment_reachable (const_tree, bool);
 
+extern int default_vector_min_alignment (const_tree);
+
 /* These are here, and not in hooks.[ch], because not all users of
    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */
 
@@ -87,6 +90,7 @@ extern const char *hook_invalid_arg_for_unprototyped_fn
   (const_tree, const_tree, const_tree);
 extern bool hook_bool_const_rtx_commutative_p (const_rtx, int);
 extern rtx default_function_value (const_tree, const_tree, bool);
+extern rtx default_libcall_value (enum machine_mode, rtx);
 extern rtx default_internal_arg_pointer (void);
 #ifdef IRA_COVER_CLASSES
 extern const enum reg_class *default_ira_cover_classes (void);
diff --git a/gcc/testsuite/g++.dg/abi/arm_va_list2.C b/gcc/testsuite/g++.dg/abi/arm_va_list2.C
new file mode 100644
index 000000000..f5e4ca43d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/abi/arm_va_list2.C
@@ -0,0 +1,7 @@
+// { dg-do compile }
+// { dg-options "-Wpsabi" }
+// { dg-require-effective-target arm_eabi }
+
+#include <stdarg.h>
+#include "arm_va_list2.h"
+
diff --git a/gcc/testsuite/g++.dg/abi/arm_va_list2.h b/gcc/testsuite/g++.dg/abi/arm_va_list2.h
new file mode 100644
index 000000000..ebfb2deac
--- /dev/null
+++ b/gcc/testsuite/g++.dg/abi/arm_va_list2.h
@@ -0,0 +1,4 @@
+// The mangling of va_list changed in GCC 4.4.  We want to warn about
+// that -- but not in a system header.
+#pragma GCC system_header
+void f(va_list) {}
diff --git a/gcc/testsuite/g++.dg/abi/mangle-neon.C b/gcc/testsuite/g++.dg/abi/mangle-neon.C
index a3fa65c10..af1fe49f1 100644
--- a/gcc/testsuite/g++.dg/abi/mangle-neon.C
+++ b/gcc/testsuite/g++.dg/abi/mangle-neon.C
@@ -2,7 +2,7 @@
 
 // { dg-do compile }
 // { dg-require-effective-target arm_neon_ok }
-// { dg-options "-mfpu=neon -mfloat-abi=softfp" }
+// { dg-add-options arm_neon }
 
 #include <arm_neon.h>
 
diff --git a/gcc/testsuite/g++.dg/abi/mangle11.C b/gcc/testsuite/g++.dg/abi/mangle11.C
index 6d09b51a6..3152c256f 100644
--- a/gcc/testsuite/g++.dg/abi/mangle11.C
+++ b/gcc/testsuite/g++.dg/abi/mangle11.C
@@ -7,4 +7,4 @@ struct S {
   typedef int X;
 };
 
-template void f<S> (int);
+template void f<S> (int); // { dg-message "instantiated" }
diff --git a/gcc/testsuite/g++.dg/abi/mangle12.C b/gcc/testsuite/g++.dg/abi/mangle12.C
index a3bd9ff6f..ba76ac021 100644
--- a/gcc/testsuite/g++.dg/abi/mangle12.C
+++ b/gcc/testsuite/g++.dg/abi/mangle12.C
@@ -8,4 +8,4 @@ struct S {
   typedef int X;
 };
 
-template void f<S> (int); 
+template void f<S> (int); // { dg-message "instantiated" }
diff --git a/gcc/testsuite/g++.dg/abi/mangle17.C b/gcc/testsuite/g++.dg/abi/mangle17.C
index 134b976a2..57f1a045c 100644
--- a/gcc/testsuite/g++.dg/abi/mangle17.C
+++ b/gcc/testsuite/g++.dg/abi/mangle17.C
@@ -5,7 +5,7 @@ enum E { e = 3 };
 template <int I> struct S {};
 
 template <int I> void f (S<I + e + int (3.7)>) {} // { dg-warning "mangle" }
-template void f<7>(S<7 + e + int (3.7)>);  
+template void f<7>(S<7 + e + int (3.7)>); // { dg-message "instantiated" }
 
 template <int I> void g (S<I + e + int (3.7)>) {} // { dg-warning "mangle" }
-template void g<7>(S<7 + e + int (3.7)>); 
+template void g<7>(S<7 + e + int (3.7)>); // { dg-message "instantiated" }
diff --git a/gcc/testsuite/g++.dg/abi/mangle20-2.C b/gcc/testsuite/g++.dg/abi/mangle20-2.C
index 38ac52371..b244e2e79 100644
--- a/gcc/testsuite/g++.dg/abi/mangle20-2.C
+++ b/gcc/testsuite/g++.dg/abi/mangle20-2.C
@@ -10,7 +10,7 @@
 template <int I> void f(int (*)[2]) {} // { dg-warning "mangled name" }
 template <int I> void g(int (*)[I+2]) {}
 
-template void f<1>(int (*)[2]);  
+template void f<1>(int (*)[2]);  // { dg-message "instantiated" }
 //  { dg-final { scan-assembler "\n_?_Z1fILi1EEvPALi2E_i\[: \t\n\]" } }
 template void g<1>(int (*)[3]);
 //  { dg-final { scan-assembler "\n_?_Z1gILi1EEvPAplT_Li2E_i\[: \t\n\]" } }
diff --git a/gcc/testsuite/g++.dg/eh/ref1.C b/gcc/testsuite/g++.dg/eh/ref1.C
new file mode 100644
index 000000000..41f1bc341
--- /dev/null
+++ b/gcc/testsuite/g++.dg/eh/ref1.C
@@ -0,0 +1,61 @@
+// { dg-do run { xfail { ! arm*-*-*eabi } } }
+
+// catching a pointer to class by reference prohibits derived->base
+// transformation.   The generic C++ ABI gets this wrong.  ARM EABI
+// gets this right, except for exception specifications where a bug is
+// acknowledged. 
+
+#include <stdio.h>
+
+struct A {};
+
+struct B : A {};
+
+int Foo ()
+{
+  B b;
+  
+  try
+    {
+      throw &b;
+    }
+  catch (A *&a)  // { dg-bogus "earlier handler" "" { xfail { ! arm*-*-*eabi } } }
+    {
+      printf ("fail, caught A*&%p\n", a);
+      return 1;
+    }
+  catch (B *&b)  // { dg-bogus "will be caught" "" { xfail { ! arm*-*-*eabi } } }
+    {
+      printf ("pass, caught B*&%p\n", b);
+    }
+  catch (...)
+    {
+      printf ("fail, caught ...");
+      return 2;
+    }
+  try
+    {
+      throw &b;
+    }
+  catch (A *a) // { dg-warning "by earlier handler" }
+    {
+      printf ("pass, caught A*%p\n", a);
+    }
+  catch (B *b) // { dg-warning "will be caught" }
+    {
+      printf ("fail, caught B*%p\n", b);
+      return 3;
+    }
+  catch (...)
+    {
+      printf ("fail, caught ...");
+      return 4;
+    }
+  return 0;
+}
+
+
+int main ()
+{
+  return Foo ();
+}
diff --git a/gcc/testsuite/g++.dg/eh/ref2.C b/gcc/testsuite/g++.dg/eh/ref2.C
new file mode 100644
index 000000000..c59affdfd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/eh/ref2.C
@@ -0,0 +1,70 @@
+// { dg-do run { xfail { ! arm*-*-*eabi } } }
+
+// catching a pointer to class by reference prohibits derived->base
+// transformation.   The generic C++ ABI gets this wrong.  ARM EABI
+// gets this right, except for exception specifications where a bug is
+// acknowledged. 
+
+#include <stdio.h>
+#include <exception>
+#include <stdlib.h>
+
+struct A {};
+
+struct B : A {};
+
+B b;
+
+void One () throw (A *&)
+{
+  throw &b;
+}
+
+void Two () throw (A *&, B *&)
+{
+  throw &b;
+}
+
+void Three () throw (A *)
+{
+  throw &b;
+}
+
+int Foo (void (*fn)())
+{
+  try
+    {
+      fn ();
+    }
+  catch (B *b)
+    {
+      printf ("pass, caught B*%p\n", b);
+    }
+  catch (...)
+    {
+      printf ("fail, caught ...");
+      return 1;
+    }
+  return 0;
+}
+
+void handler ()
+{
+  printf ("pass, got unexpected exception\n");
+  exit (0);
+}
+
+int main ()
+{
+  if (Foo (&Three))
+    return 1;
+
+  if (Foo (&Two))
+    return 2;
+
+  std::set_unexpected (handler);
+  if (Foo (&One))
+    return 3;
+  printf ("fail, did not get unexpected exception\n");
+  return 4;
+}
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-1.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-1.C
new file mode 100644
index 000000000..0c601e68c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-1.C
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+#include "arm-fp16-ops.h"
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-2.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-2.C
new file mode 100644
index 000000000..244e31082
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-2.C
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+
+#include "arm-fp16-ops.h"
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-3.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-3.C
new file mode 100644
index 000000000..8f9ab64bc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-3.C
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+#include "arm-fp16-ops.h"
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-4.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-4.C
new file mode 100644
index 000000000..4877f392c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-4.C
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=alternative -ffast-math" } */
+
+#include "arm-fp16-ops.h"
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C
new file mode 100644
index 000000000..98a1230a7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C
@@ -0,0 +1,17 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_fp16_ok } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-add-options arm_neon_fp16 } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, including fp16 support, so
+   we should not see any calls to libfuncs here.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_h2f" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_f2h" } } */
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C
new file mode 100644
index 000000000..bd2f4db7b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C
@@ -0,0 +1,17 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_fp16_ok } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+/* { dg-add-options arm_neon_fp16 } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, including fp16 support, so
+   we should not see any calls to libfuncs here.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_h2f" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_f2h" } } */
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-7.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-7.C
new file mode 100644
index 000000000..ed8089bd6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-7.C
@@ -0,0 +1,13 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, so we should not see any 
+   calls to libfuncs here except for those to the conversion functions.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-8.C b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-8.C
new file mode 100644
index 000000000..b138ca187
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-8.C
@@ -0,0 +1,13 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, so we should not see any 
+   calls to libfuncs here except for those to the conversion functions.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops.h b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops.h
new file mode 100644
index 000000000..320494ee7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops.h
@@ -0,0 +1,135 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+
+#include <assert.h>
+
+#define CHECK(e,r) assert ((e) == r)
+#define CHECK2(e,r) (assert ((e) == r), temp = (e), assert (temp == r))
+#define TEST(e) assert (e)
+#define TESTNOT(e) assert (!(e))
+
+volatile __fp16 h0 = 0.0;
+volatile __fp16 h1 = 1.0;
+volatile __fp16 h42 = 42.0;
+volatile __fp16 hm2 = -2.0;
+volatile __fp16 temp;
+
+volatile float f0 = 0.0;
+volatile float f1 = 1.0;
+volatile float f42 = 42.0;
+volatile float fm2 = -2.0;
+
+int main (void)
+{
+  TEST (h1);
+  TESTNOT (h0);
+  TEST (!h0);
+  TESTNOT (!h1);
+
+  CHECK2 (-h1, -1.0);
+  CHECK2 (+h1, 1.0);
+
+  CHECK (h1++, 1.0);
+  CHECK (h1, 2.0);
+  CHECK (++h1, 3.0);
+  CHECK (h1, 3.0);
+
+  CHECK (--h1, 2.0);
+  CHECK (h1, 2.0);
+  CHECK (h1--, 2.0);
+  CHECK (h1, 1.0);
+
+  CHECK2 (h42 * hm2, -84.0);
+  CHECK2 (h42 * (__fp16) -2.0, -84.0);
+  CHECK2 (h42 * fm2, -84.0);
+  CHECK2 (f42 * hm2, -84.0);
+
+  CHECK2 (h42 / hm2, -21.0);
+  CHECK2 (h42 / (__fp16) -2.0, -21.0);
+  CHECK2 (h42 / fm2, -21.0);
+  CHECK2 (f42 / hm2, -21.0);
+
+  CHECK2 (hm2 + h42, 40.0);
+  CHECK2 ((__fp16)-2.0 + h42, 40.0);
+  CHECK2 (hm2 + f42, 40.0);
+  CHECK2 (fm2 + h42, 40.0);
+
+  CHECK2 (hm2 - h42, -44.0);
+  CHECK2 ((__fp16)-2.0 - h42, -44.0);
+  CHECK2 (hm2 - f42, -44.0);
+  CHECK2 (fm2 - h42, -44.0);
+
+  TEST (hm2 < h42);
+  TEST (hm2 < (__fp16)42.0);
+  TEST (hm2 < f42);
+  TEST (fm2 < h42);
+
+  TEST (h42 > hm2);
+  TEST ((__fp16)42.0 > hm2);
+  TEST (h42 > fm2);
+  TEST (f42 > hm2);
+
+  TEST (hm2 <= h42);
+  TEST (hm2 <= (__fp16)42.0);
+  TEST (hm2 <= f42);
+  TEST (fm2 <= h42);
+
+  TEST (h42 >= hm2);
+  TEST (h42 >= (__fp16)-2.0);
+  TEST (h42 >= fm2);
+  TEST (f42 >= hm2);
+
+  TESTNOT (h1 == hm2);
+  TEST (h1 == h1);
+  TEST (h1 == (__fp16)1.0);
+  TEST (h1 == f1);
+  TEST (f1 == h1);
+
+  TEST (h1 != hm2);
+  TESTNOT (h1 != h1);
+  TESTNOT (h1 != (__fp16)1.0);
+  TESTNOT (h1 != f1);
+  TESTNOT (f1 != h1);
+
+  CHECK2 ((h1 ? hm2 : h42), -2.0);
+  CHECK2 ((h0 ? hm2 : h42), 42.0);
+
+  CHECK (h0 = h42, 42.0);
+  CHECK (h0, 42.0);
+  CHECK (h0 = (__fp16)-2.0, -2.0);
+  CHECK (h0, -2.0);
+  CHECK (h0 = f0, 0.0);
+  CHECK (h0, 0.0);
+
+  CHECK (h0 += h1, 1.0);
+  CHECK (h0, 1.0);
+  CHECK (h0 += (__fp16)1.0, 2.0);
+  CHECK (h0, 2.0);
+  CHECK (h0 += fm2, 0.0);
+  CHECK (h0, 0.0);
+
+  CHECK (h0 -= h1, -1.0);
+  CHECK (h0, -1.0);
+  CHECK (h0 -= (__fp16)1.0, -2.0);
+  CHECK (h0, -2.0);
+  CHECK (h0 -= fm2, 0.0);
+  CHECK (h0, 0.0);
+
+  h0 = hm2;
+  CHECK (h0 *= hm2, 4.0);
+  CHECK (h0, 4.0);
+  CHECK (h0 *= (__fp16)-2.0, -8.0);
+  CHECK (h0, -8.0);
+  CHECK (h0 *= fm2, 16.0);
+  CHECK (h0, 16.0);
+
+  CHECK (h0 /= hm2, -8.0);
+  CHECK (h0, -8.0);
+  CHECK (h0 /= (__fp16)-2.0, 4.0);
+  CHECK (h0, 4.0);
+  CHECK (h0 /= fm2, -2.0);
+  CHECK (h0, -2.0);
+
+  CHECK ((h0, h1), 1.0);
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-mangle-1.C b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-mangle-1.C
new file mode 100644
index 000000000..25a872af6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-mangle-1.C
@@ -0,0 +1,14 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Test mangling */
+
+/* { dg-final { scan-assembler "\t.global\t_Z1fPDh" } } */
+void f (__fp16 *x) { }
+
+/* { dg-final { scan-assembler "\t.global\t_Z1gPDhS_" } } */
+void g (__fp16 *x, __fp16 *y) { }
+
+/* { dg-final { scan-assembler "\t.global\t_ZN1SIDhDhE1iE" } } */
+template <typename T, typename U> struct S { static int i; }; 
+template <> int S<__fp16, __fp16>::i = 3;
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-overload-1.C b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-overload-1.C
new file mode 100644
index 000000000..bf0139d7c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-overload-1.C
@@ -0,0 +1,16 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* __fp16 values are autoconverted to float and should therefore be treated
+ * just like float for overloading purposes.  */
+
+extern int frobnify (float x);
+extern int frobnify (double x);
+
+int g (void)
+{
+  return frobnify ((__fp16)1.0);
+}
+
+/* { dg-final { scan-assembler "_Z8frobnifyf" } } */
+/* { dg-final { scan-assembler-not " _Z8frobnifyd" } } */
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-param-1.C b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-param-1.C
new file mode 100644
index 000000000..03feb1a4d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-param-1.C
@@ -0,0 +1,10 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Functions cannot have parameters of type __fp16.  */
+extern void f (__fp16);		/* { dg-error "parameters cannot have __fp16 type" } */
+extern void (*pf) (__fp16);	/* { dg-error "parameters cannot have __fp16 type" } */
+
+/* These should be OK.  */
+extern void g (__fp16 *);
+extern void (*pg) (__fp16 *);
diff --git a/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-return-1.C b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-return-1.C
new file mode 100644
index 000000000..406dfacd3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/arm-fp16/fp16-return-1.C
@@ -0,0 +1,10 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Functions cannot return type __fp16.  */
+extern __fp16 f (void);		/* { dg-error "cannot return __fp16" } */
+extern __fp16 (*pf) (void);	/* { dg-error "cannot return __fp16" } */
+
+/* These should be OK.  */
+extern __fp16 *g (void);
+extern __fp16 *(*pg) (void);
diff --git a/gcc/testsuite/g++.dg/ext/dllexport2.C b/gcc/testsuite/g++.dg/ext/dllexport2.C
new file mode 100644
index 000000000..71ccf670b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/dllexport2.C
@@ -0,0 +1,52 @@
+// { dg-do link }
+// { dg-require-dll "" }
+// { dg-additional-sources "dllexport2a.cc" }
+// { dg-options "-O2" }
+
+/* Test that inline functions declared "dllexport" appear in object
+   files, even if they are not called.
+
+   This behavior is required by the ARM C++ ABI:
+
+     Exporting a function that can be inlined should force the
+     creation and export of an out-of-line copy of it.
+
+   and should presumably also apply.
+
+   Visual Studio 2005 also honors that rule.  */
+
+__declspec(dllexport) inline void i1() {}
+
+__declspec(dllexport) extern inline void e1() {}
+
+/* It is invalid to declare the function inline after its definition.  */
+#if 0
+__declspec(dllexport) void i2() {}
+inline void i2();
+
+__declspec(dllexport) extern void e2() {}
+inline void e2();
+#endif
+
+__declspec(dllexport) inline void i3() {}
+void i3();
+
+__declspec(dllexport) inline void e3() {}
+extern void e3();
+
+__declspec(dllexport) void i4();
+inline void i4() {};
+
+__declspec(dllexport) extern void e4();
+inline void e4() {};
+
+__declspec(dllexport) inline void i5();
+void i5() {};
+
+__declspec(dllexport) inline void e5();
+extern void e5() {};
+
+/* Make sure that just declaring the function -- without defining it
+   -- does not cause errors.  */
+__declspec(dllexport) inline void i6();
+__declspec(dllexport) extern inline void e6();
diff --git a/gcc/testsuite/g++.dg/ext/dllexport2a.cc b/gcc/testsuite/g++.dg/ext/dllexport2a.cc
new file mode 100644
index 000000000..80caf3217
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/dllexport2a.cc
@@ -0,0 +1,21 @@
+extern void i1();
+extern void i3();
+extern void i4();
+extern void i5();
+
+extern void e1();
+extern void e3();
+extern void e4();
+extern void e5();
+
+int main () {
+  i1();
+  i3();
+  i4();
+  i5();
+
+  e1();
+  e3();
+  e4();
+  e5();
+}
diff --git a/gcc/testsuite/g++.dg/ext/ms-1.C b/gcc/testsuite/g++.dg/ext/ms-1.C
new file mode 100644
index 000000000..dcd1d0466
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/ms-1.C
@@ -0,0 +1,17 @@
+
+// MS allows more things to be pointers to member functions
+// { dg-options "-fms-extensions" }
+
+struct X
+{
+  void Foo (X *);
+  void Bar ();
+};
+
+void Quux (void (X::*) ());
+
+void X::Foo (X *ptr)  // { dg-message "candidates" }
+{
+  Quux (Foo); // { dg-error "no matches" }
+  Quux (Bar);
+}
diff --git a/gcc/testsuite/g++.dg/ext/packed8.C b/gcc/testsuite/g++.dg/ext/packed8.C
index 1f86cfc0a..91ee8b3ee 100644
--- a/gcc/testsuite/g++.dg/ext/packed8.C
+++ b/gcc/testsuite/g++.dg/ext/packed8.C
@@ -2,7 +2,7 @@
 // NOTE: This test assumes packed structure layout differs from unpacked
 //       structure layout.  This isn't true, e.g., with the default
 //       arm-none-elf options.
-// { dg-options "-mstructure-size-boundary=8" { target arm-*-* } }
+// { dg-options "-mstructure-size-boundary=8" { target arm*-*-* } }
 
 class A
 {
diff --git a/gcc/testsuite/g++.dg/init/array16.C b/gcc/testsuite/g++.dg/init/array16.C
index be6521907..188d1a84f 100644
--- a/gcc/testsuite/g++.dg/init/array16.C
+++ b/gcc/testsuite/g++.dg/init/array16.C
@@ -1,7 +1,7 @@
 // Causes timeout for the MMIX simulator on a 3GHz P4 and we can't
 // have "compile" for some targets and "run" for others.
 // { dg-do run { target { ! mmix-*-* } } }
-// { dg-options "-mstructure-size-boundary=8" { target arm-*-* } }
+// { dg-options "-mstructure-size-boundary=8" { target arm*-*-* } }
 
 // Copyright (C) 2004 Free Software Foundation, Inc.
 // Contributed by Nathan Sidwell 8 Dec 2004 <nathan@codesourcery.com>
diff --git a/gcc/testsuite/g++.dg/init/pr42556.C b/gcc/testsuite/g++.dg/init/pr42556.C
new file mode 100644
index 000000000..27370af79
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/pr42556.C
@@ -0,0 +1,10 @@
+// { dg-do compile }
+// { dg-options "-fdump-tree-gimple" }
+
+void foo (int a, int b, int c, int d)
+{
+  int v[4] = {a, b, c, d};
+}
+
+// { dg-final { scan-tree-dump-not "v = {}"  "gimple" } }
+// { dg-final { cleanup-tree-dump "gimple" } }
diff --git a/gcc/testsuite/g++.dg/init/ref15.C b/gcc/testsuite/g++.dg/init/ref15.C
index d3a94227f..bc9c01dc2 100644
--- a/gcc/testsuite/g++.dg/init/ref15.C
+++ b/gcc/testsuite/g++.dg/init/ref15.C
@@ -1,6 +1,8 @@
 // PR c++/20416.  We correctly constructed the temporary S in foo(),
 // but incorrectly destroyed it every time foo() was called.
-// { dg-do run }
+// When using a wrapped target, there is no way to override the exit
+// code after returning from main.
+// { dg-do run { target unwrapped } }
 extern "C" void abort (void);
 extern "C" void _exit (int);
 
diff --git a/gcc/testsuite/g++.dg/opt/alias5.C b/gcc/testsuite/g++.dg/opt/alias5.C
new file mode 100644
index 000000000..24454def8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/alias5.C
@@ -0,0 +1,24 @@
+// { dg-options "-O2" }
+// ICE in struct-alias
+
+typedef int (*PFN)(void);
+int f (void);
+struct Container
+{
+  PFN ptr;
+};
+
+inline PFN Get (struct Container *tpl)
+{
+  return tpl->ptr;
+}
+void Other (PFN);
+
+inline void Foo (PFN pfn)
+{
+  Other (Get ((struct Container *)&pfn));
+}
+void Bar (void)
+{
+  Foo (f);
+}
diff --git a/gcc/testsuite/g++.dg/other/arm-neon-1.C b/gcc/testsuite/g++.dg/other/arm-neon-1.C
new file mode 100644
index 000000000..33cc04b69
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/arm-neon-1.C
@@ -0,0 +1,18 @@
+/* Basic smoke test for arm_neon.h */
+
+/* { dg-do assemble } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+
+float a[4];
+
+void test(void)
+{
+  float32x2x2_t v;
+  float32x2_t res;
+  v = vld2_f32(a);
+  res = vadd_f32(v.val[0], v.val[1]);
+  vst1_f32(a, res);
+}
diff --git a/gcc/testsuite/g++.dg/other/armv7m-1.C b/gcc/testsuite/g++.dg/other/armv7m-1.C
new file mode 100644
index 000000000..6aa686b10
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/armv7m-1.C
@@ -0,0 +1,69 @@
+/* { dg-do run { target arm*-*-* } } */
+/* Test Armv7m interrupt routines.  */
+#include <stdlib.h>
+
+#ifdef __ARM_ARCH_7M__
+void __attribute__((interrupt))
+foo(void)
+{
+  long long n;
+  long p;
+  asm volatile ("" : "=r" (p) : "0" (&n));
+  if (p & 4)
+    abort ();
+  return;
+}
+
+void __attribute__((interrupt))
+bar(void)
+{
+  throw 42;
+}
+
+int main()
+{
+  int a;
+  int before;
+  int after;
+  volatile register int sp asm("sp");
+
+  asm volatile ("mov %0, sp\n"
+		"blx %2\n"
+		"mov %1, sp\n"
+		: "=&r" (before), "=r" (after) : "r" (foo)
+		: "memory", "cc", "r0", "r1", "r2", "r3", "ip", "lr");
+  if (before != after)
+    abort();
+  asm volatile ("mov %0, sp\n"
+		"sub sp, sp, #4\n"
+		"blx %2\n"
+		"add sp, sp, #4\n"
+		"mov %1, sp\n"
+		: "=&r" (before), "=r" (after) : "r" (foo)
+		: "memory", "cc", "r0", "r1", "r2", "r3", "ip", "lr");
+  if (before != after)
+    abort();
+  before = sp;
+  try
+    {
+      bar();
+    }
+  catch (int i)
+    {
+      if (i != 42)
+	abort();
+    }
+  catch (...)
+    {
+      abort();
+    }
+  if (before != sp)
+    abort();
+  exit(0);
+}
+#else
+int main()
+{
+  exit (0);
+}
+#endif
diff --git a/gcc/testsuite/g++.dg/other/crash-4.C b/gcc/testsuite/g++.dg/other/crash-4.C
index bc2c457f1..ec280a600 100644
--- a/gcc/testsuite/g++.dg/other/crash-4.C
+++ b/gcc/testsuite/g++.dg/other/crash-4.C
@@ -7,7 +7,7 @@
 // NOTE: This test assumes packed structure layout differs from unpacked
 //       structure layout.  This isn't true, e.g., with the default
 //       arm-none-elf options.
-// { dg-options "-mstructure-size-boundary=8" { target arm-*-* } }
+// { dg-options "-mstructure-size-boundary=8" { target arm*-*-* } }
 
 struct a
 {
diff --git a/gcc/testsuite/g++.dg/other/packed1.C b/gcc/testsuite/g++.dg/other/packed1.C
index b1b829b22..5e0296fa1 100644
--- a/gcc/testsuite/g++.dg/other/packed1.C
+++ b/gcc/testsuite/g++.dg/other/packed1.C
@@ -1,4 +1,4 @@
-// { dg-do run { xfail arm-*-* sh-*-* } }
+// { dg-do run { xfail arm*-*-* sh-*-* } }
 
 // NMS:2003-04-21 this fails on strict aligned architectures again,
 // the patch was reverted because it broke something more important.
diff --git a/gcc/testsuite/g++.dg/pr45112.C b/gcc/testsuite/g++.dg/pr45112.C
new file mode 100644
index 000000000..34dd3e1bc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr45112.C
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+
+struct JSString
+{
+  unsigned char mLength;
+  static JSString unitStringTable[];
+};
+
+JSString JSString::unitStringTable[] __attribute__ ((aligned (8))) = { 1 };
+
+int bug [__alignof__ (JSString::unitStringTable) >= 8 ? 1 : -1];
+
diff --git a/gcc/testsuite/g++.dg/remove-local-statics-1.C b/gcc/testsuite/g++.dg/remove-local-statics-1.C
new file mode 100644
index 000000000..f4a269efa
--- /dev/null
+++ b/gcc/testsuite/g++.dg/remove-local-statics-1.C
@@ -0,0 +1,21 @@
+/* Verify that we do not eliminate a static variable in
+   main::Local::Foo.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int
+main (void)
+{
+   static int thestatic = 0;
+   struct Local {
+     __attribute__((__noinline__))
+     static void Foo () { thestatic = 1; }
+   };
+
+   thestatic = 2;
+   Local::Foo();
+
+   return thestatic++;
+}
diff --git a/gcc/testsuite/g++.dg/remove-local-statics-2.C b/gcc/testsuite/g++.dg/remove-local-statics-2.C
new file mode 100644
index 000000000..52d3a0516
--- /dev/null
+++ b/gcc/testsuite/g++.dg/remove-local-statics-2.C
@@ -0,0 +1,21 @@
+/* Verify that we do not eliminate a static variable in
+   main due to its use in Local::Foo.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int
+main (void)
+{
+   static int thestatic = 0;
+   struct Local {
+     __attribute__((__noinline__))
+     static int Foo () { return thestatic; }
+   };
+
+   thestatic = 2;
+   thestatic = Local::Foo();
+
+   return thestatic++;
+}
diff --git a/gcc/testsuite/g++.dg/rtti/dyncast3.C b/gcc/testsuite/g++.dg/rtti/dyncast3.C
new file mode 100644
index 000000000..08352599b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/rtti/dyncast3.C
@@ -0,0 +1,81 @@
+// This testcase used to crash while looking in A for my_module.  I'm still
+// not sure it's well-formed, but it works now because of the optimization
+// to look at the expected address first.
+
+// { dg-do run }
+
+extern "C" int puts (const char *);
+extern "C" void abort ();
+
+struct my_object
+{
+  my_object() { puts ("in my_object ctor");}
+  virtual ~my_object() { puts ("in my_object dtor"); }
+};
+
+my_object* my_module_ptr = 0;
+
+struct my_module : my_object
+{
+  my_module()
+  {
+    puts ("in my_module ctor, setting up ptr");
+    my_module_ptr = this;
+  }
+  ~my_module() { puts ("in my_module dtor");}
+};
+
+struct D
+{
+  D() { puts ("in D ctor"); }
+  virtual ~D();
+};
+
+D::~D()
+{
+  puts ("in D dtor");
+  puts ("before DCASTing to my_module*");
+  my_module* m = dynamic_cast<my_module*>(my_module_ptr);
+  if (m != my_module_ptr)
+    abort ();
+  puts ("after DCASTing to my_module*");
+}
+
+struct my_interface
+{
+  my_interface() { puts ("in my_interface ctor");}
+  ~my_interface() { puts ("in my_interface dtor");}
+};
+
+struct myif : virtual my_interface
+{
+  myif() { puts ("in myif ctor");}
+  ~myif() { puts ("in myif dtor");}
+};
+
+struct A: virtual myif
+{
+  A() { puts ("in A ctor"); }
+  ~A() { puts ("in A dtor"); }
+
+  D d;
+};
+
+struct B: virtual myif
+{
+  B() { puts ("in B ctor"); }
+  ~B() { puts ("in B dtor"); }
+
+  D d;
+};
+
+struct C : my_module, A, B
+{
+  C() { puts ("in C ctor");}
+  ~C() { puts ("in C dtor"); }
+};
+
+int main(int, char**)
+{
+  C t;
+}
diff --git a/gcc/testsuite/g++.dg/rtti/dyncast4.C b/gcc/testsuite/g++.dg/rtti/dyncast4.C
new file mode 100644
index 000000000..2a5fd2b3b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/rtti/dyncast4.C
@@ -0,0 +1,26 @@
+// Test to make sure that we keep searching if we don't find the type we
+// want at the expected address.
+
+// { dg-do run }
+
+struct A
+{
+  virtual void f() {};
+};
+
+struct B: A { };
+
+struct C: A { };
+
+struct D: B, C { };
+
+int main()
+{
+  D d;
+  A* ap = static_cast<B*>(&d);
+  C* cp = dynamic_cast<C*>(ap);
+  if (cp == 0)
+    return 1;
+  else
+    return 0;
+}
diff --git a/gcc/testsuite/g++.dg/template/cond2.C b/gcc/testsuite/g++.dg/template/cond2.C
index abb6ebb5d..cf8df8cd9 100644
--- a/gcc/testsuite/g++.dg/template/cond2.C
+++ b/gcc/testsuite/g++.dg/template/cond2.C
@@ -3,8 +3,8 @@
 
 template<int X> class c;
 
-template<int X, int Y> int test(c<X ? : Y>&);
+template<int X, int Y> int test(c<X ? : Y>&); // { dg-error "omitted" }
 
 void test(c<2>*c2) {
-	test<0, 2>(*c2); // { dg-error "omitted" }
+	test<0, 2>(*c2); // { dg-message "instantiated" }	
 }
diff --git a/gcc/testsuite/g++.dg/template/overload9.C b/gcc/testsuite/g++.dg/template/overload9.C
index cef8ebe9f..8aeab9eaa 100644
--- a/gcc/testsuite/g++.dg/template/overload9.C
+++ b/gcc/testsuite/g++.dg/template/overload9.C
@@ -7,12 +7,12 @@ template <typename T> A<T>& operator<<(A<T>&, const B<T>&);
 template <typename T>
 struct A 
 {
-  A<T>& operator<<(A<T>& (*)(A<T>&)); // { dg-message "candidate" }
+  A<T>& operator<<(A<T>& (*)(A<T>&));
 };
 
 template <typename T> A<T>& foo(A<T>&);
 extern A<char> c;
 
 int main () {
-  c << (1, foo); // { dg-error "no match" }
+  c << (1, foo); // { dg-error "no context" }
 }
diff --git a/gcc/testsuite/g++.dg/template/pr35240.C b/gcc/testsuite/g++.dg/template/pr35240.C
index de82897f6..47455b658 100644
--- a/gcc/testsuite/g++.dg/template/pr35240.C
+++ b/gcc/testsuite/g++.dg/template/pr35240.C
@@ -4,9 +4,9 @@
 
 template<int> struct A {};
 
-template<int N> A<sizeof(new int[N][N])> foo();
+template<int N> A<sizeof(new int[N][N])> foo(); // { dg-message "unimplemented" }
 
 void bar()
 {
-  foo<1>();	// { dg-message "unimplemented" }
+  foo<1>(); // { dg-message "instantiated" }
 }
diff --git a/gcc/testsuite/g++.dg/torture/pr36191.C b/gcc/testsuite/g++.dg/torture/pr36191.C
index 18051cedf..125d8a122 100644
--- a/gcc/testsuite/g++.dg/torture/pr36191.C
+++ b/gcc/testsuite/g++.dg/torture/pr36191.C
@@ -1,6 +1,7 @@
 // PR c++/36191
 // { dg-do compile }
 // { dg-options "-fnon-call-exceptions" }
+// { dg-skip-if "Frame pointer required for unwind tables" { sh*-*-* m68k*-*-* fido*-*-* } "-fomit-frame-pointer" "" }
 
 __complex__ double
 foo (__complex__ double x, double y)
diff --git a/gcc/testsuite/g++.dg/tree-ssa/sink-1.C b/gcc/testsuite/g++.dg/tree-ssa/sink-1.C
new file mode 100644
index 000000000..9fb0faf2a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-ssa/sink-1.C
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+
+class A {
+ public:
+  A() {}
+  virtual ~A() {}  
+  void * dostuff();
+  
+  virtual int dovirtual() = 0;
+};
+
+
+class B : public A {
+ public:
+  B() {}
+  int dovirtual() { return 0;}
+  virtual ~B() {};
+}; 
+
+class C : public B {
+ public:
+  C() {}
+  virtual ~C() {};
+};
+
+void* A::dostuff()
+{
+  return (void*)dovirtual();
+}
+
+/* tree-ssa-sink was sinking the inlined destructor for STUFF out of
+   the first inner block and into the second one, where it was ending up
+   after the inlined constructor for STUFF2.  This is bad because
+   cfgexpand aliases STUFF and STUFF2 to the same storage at -O1
+   (i.e., without -fstrict-aliasing), with the result that STUFF2's
+   vtable was getting trashed. */
+
+int main() {
+  {
+    B stuff;
+    stuff.dostuff();
+  }
+  {
+    C stuff2;
+    stuff2.dostuff();
+  }
+  return 0;
+}
+
diff --git a/gcc/testsuite/g++.dg/vect/vect.exp b/gcc/testsuite/g++.dg/vect/vect.exp
index 6ebfc8a26..087a7d311 100644
--- a/gcc/testsuite/g++.dg/vect/vect.exp
+++ b/gcc/testsuite/g++.dg/vect/vect.exp
@@ -108,7 +108,7 @@ if  [istarget "powerpc-*paired*"]  {
 } elseif [istarget "ia64-*-*"] {
     set dg-do-what-default run
 } elseif [is-effective-target arm_neon_ok] {
-    lappend DEFAULT_VECTCFLAGS "-mfpu=neon" "-mfloat-abi=softfp"
+    eval lappend DEFAULT_VECTCFLAGS [add_options_for_arm_neon ""]
     if [is-effective-target arm_neon_hw] {
       set dg-do-what-default run
     } else {
diff --git a/gcc/testsuite/g++.dg/warn/null4.C b/gcc/testsuite/g++.dg/warn/null4.C
index 785f27904..6aa4a097f 100644
--- a/gcc/testsuite/g++.dg/warn/null4.C
+++ b/gcc/testsuite/g++.dg/warn/null4.C
@@ -11,9 +11,22 @@ int foo (void)
   if (NULL < NULL) return -1; // { dg-warning "NULL used in arithmetic" } 
   if (NULL >= 0) return -1;   // { dg-warning "NULL used in arithmetic" } 
   if (NULL <= 0) return -1;   // { dg-warning "NULL used in arithmetic" } 
+  // Adding to the NULL pointer, which has no specific type, should
+  // result in a warning; the type of the resulting expression is
+  // actually "int", not a pointer type.
+  if (NULL + 1) return -1;    // { dg-warning "NULL used in arithmetic" }
+  if (1 + NULL) return -1;    // { dg-warning "NULL used in arithmetic" }
   return 0;
 }
 
+int *ip;
+
+struct S {};
+typedef int S::*SPD;
+typedef void (S::*SPF)(void);
+SPD spd;
+SPF spf;
+
 int bar (void) 
 {
   if (NULL) return -1;
@@ -25,5 +38,18 @@ int bar (void)
   if (NULL != NULL) return -1;
   if (NULL == 0) return -1;
   if (NULL != 0) return -1;
+  // Subtraction of pointers is vaild, so using NULL is OK.
+  if (ip - NULL) return -1;
+  if (NULL - NULL) return -1;
+  // Comparing NULL with a pointer-to-member is OK.
+  if (NULL == spd) return -1;
+  if (spd == NULL) return -1;
+  if (NULL != spd) return -1;
+  if (spd != NULL) return -1;
+  if (NULL == spf) return -1;
+  if (spf == NULL) return -1;
+  if (NULL != spf) return -1;
+  if (spf != NULL) return -1;
+
   return 0;
 }
diff --git a/gcc/testsuite/g++.old-deja/g++.other/overload11.C b/gcc/testsuite/g++.old-deja/g++.other/overload11.C
index 3b0cab79f..e8c88fd58 100644
--- a/gcc/testsuite/g++.old-deja/g++.other/overload11.C
+++ b/gcc/testsuite/g++.old-deja/g++.other/overload11.C
@@ -54,11 +54,10 @@ int main (int argc, char **argv)
   
   ptr = (ovl);              // ok
   ptr = (&ovl);             // ok
-  // 13.4 indicates these are ok.
-  ptr = (0, ovl);           // ok { dg-bogus "" "" { xfail *-*-* } }
-  ptr = (0, &ovl);          // ok { dg-bogus "" "" { xfail *-*-* } }
-  ptr = (argc ? ovl : ovl); // ok { dg-bogus "" "" { xfail *-*-* } }
-  ptr = (argc ? &ovl : &ovl);// ok { dg-bogus "" "" { xfail *-*-* } }
+  ptr = (0, ovl);           // ok { dg-error "no context" }
+  ptr = (0, &ovl);          // ok { dg-error "no context" }
+  ptr = (argc ? ovl : ovl); // ok { dg-error "no context" }
+  ptr = (argc ? &ovl : &ovl);// ok { dg-error "no context" }
   
   vptr = (ovl);              // { dg-error "" } no matching candidates
   vptr = (&ovl);             // { dg-error "" } no matching candidates
diff --git a/gcc/testsuite/gcc.c-torture/execute/20100416-1.c b/gcc/testsuite/gcc.c-torture/execute/20100416-1.c
new file mode 100644
index 000000000..8b5a6f45e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20100416-1.c
@@ -0,0 +1,40 @@
+void abort(void);
+
+int
+movegt(int x, int y, long long a)
+{
+  int i;
+  int ret = 0;
+  for (i = 0; i < y; i++)
+    {
+      if (a >= (long long) 0xf000000000000000LL)
+	ret = x;
+      else
+	ret = y;
+    }
+  return ret;
+}
+
+struct test
+{
+  long long val;
+  int ret;
+} tests[] = {
+  { 0xf000000000000000LL, -1 },
+  { 0xefffffffffffffffLL, 1 },
+  { 0xf000000000000001LL, -1 },
+  { 0x0000000000000000LL, -1 },
+  { 0x8000000000000000LL, 1 },
+};
+
+int
+main()
+{
+  int i;
+  for (i = 0; i < sizeof (tests) / sizeof (tests[0]); i++)
+    {
+      if (movegt (-1, 1, tests[i].val) != tests[i].ret)
+	abort ();
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/990208-1.x b/gcc/testsuite/gcc.c-torture/execute/990208-1.x
new file mode 100644
index 000000000..2cd80f137
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/990208-1.x
@@ -0,0 +1,12 @@
+
+# On ARM, with -Os, some of the functions that this test
+# expects to be inlined are not inlined for code size
+# reasons.  This is not a bug, it's intentional,
+# so stop this test from running.
+set torture_eval_before_compile {
+  if { [istarget "arm*-*-*"] && [string match {*-Os*} "$option"] } {
+    continue
+  }
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/bcp-1.x b/gcc/testsuite/gcc.c-torture/execute/bcp-1.x
new file mode 100644
index 000000000..2cd80f137
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bcp-1.x
@@ -0,0 +1,12 @@
+
+# On ARM, with -Os, some of the functions that this test
+# expects to be inlined are not inlined for code size
+# reasons.  This is not a bug, it's intentional,
+# so stop this test from running.
+set torture_eval_before_compile {
+  if { [istarget "arm*-*-*"] && [string match {*-Os*} "$option"] } {
+    continue
+  }
+}
+
+return 0
diff --git a/gcc/testsuite/gcc.c-torture/execute/bitfld-5.c b/gcc/testsuite/gcc.c-torture/execute/bitfld-5.c
new file mode 100644
index 000000000..ca88d9221
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/bitfld-5.c
@@ -0,0 +1,35 @@
+/* See http://gcc.gnu.org/ml/gcc/2009-06/msg00072.html.  */
+
+extern void abort (void);
+
+struct s
+{
+  unsigned long long a:2;
+  unsigned long long b:40;
+  unsigned long long c:22;
+};
+
+__attribute__ ((noinline)) void
+g (unsigned long long a, unsigned long long b)
+{
+  asm ("");
+  if (a != b)
+    abort ();
+}
+
+__attribute__ ((noinline)) void
+f (struct s s, unsigned long long b)
+{
+  asm ("");
+  g (((unsigned long long) (s.b-8)) + 8, b);
+}
+
+int
+main ()
+{
+  struct s s = {1, 10, 3};
+  struct s t = {1, 2, 3};
+  f (s, 10);
+  f (t, 0x10000000002);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp b/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp
index 048e65f6e..435e9ed40 100644
--- a/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp
@@ -54,6 +54,9 @@ if { [istarget "alpha*-*-*"]
      || [istarget "sh*-*-*"] } then {
   lappend additional_flags "-mieee"
 }
+if [istarget "mips*-sde-*"] then {
+  lappend additional_flags "-Wl,--defsym=__cs3_mips_float_type=2" "-lcs3-mips-cp1" "-lcs3-mips-fpemu"
+}
 
 # load support procs
 load_lib c-torture.exp
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr43323.c b/gcc/testsuite/gcc.c-torture/execute/pr43323.c
new file mode 100644
index 000000000..ed93ea576
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr43323.c
@@ -0,0 +1,14 @@
+/* PR middle-end/43323 */
+
+extern void abort (void);
+
+int main()
+{
+  struct { unsigned bar:1; } foo;
+  foo.bar = 0x1;
+  if ((unsigned char)(foo.bar * 0xfe) != 0xfeu)
+    abort ();
+  if ((unsigned char)(foo.bar * 0xff) != 0xffu)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/Warray-bounds-8.c b/gcc/testsuite/gcc.dg/Warray-bounds-8.c
new file mode 100644
index 000000000..85839f3f0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Warray-bounds-8.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -Wall" } */
+/* based on PR 43833 */
+
+extern unsigned char data[5];
+
+unsigned char
+foo (char *str)
+{
+  int i, j;
+  unsigned char c = 0;
+
+  for (i = 0; i < 8; i++)
+    {
+      j = i * 5;
+      if ((j % 8) > 3)
+	c |= data[(j / 8) + 1];
+    }
+  return c;
+}
diff --git a/gcc/testsuite/gcc.dg/builtin-redefine.c b/gcc/testsuite/gcc.dg/builtin-redefine.c
index f94d3f3d8..1d0f29da8 100644
--- a/gcc/testsuite/gcc.dg/builtin-redefine.c
+++ b/gcc/testsuite/gcc.dg/builtin-redefine.c
@@ -28,7 +28,7 @@
 #define __TIME__ "X"         /* Re-define while defined.  */
 
 #define __TIME__ "Y"         /* { dg-warning "\"__TIME__\" redefined" } */
-/* { dg-warning "previous definition" "" { target *-*-* } 28 } */
+/* { dg-message "previous definition" "" { target *-*-* } 28 } */
 
 #undef __TIME__              /* Undefine while defined.  */
 
@@ -39,7 +39,7 @@
 #define __DATE__ "X"         /* Re-define while defined.  */
 
 #define __DATE__ "Y"         /* { dg-warning "\"__DATE__\" redefined" } */
-/* { dg-warning "previous definition" "" { target *-*-* } 39 } */
+/* { dg-message "previous definition" "" { target *-*-* } 39 } */
 
 #undef __DATE__              /* Undefine while defined.  */
 
@@ -48,7 +48,7 @@
 #define __TIMESTAMP__ "X"    /* Re-define while defined.  */
 
 #define __TIMESTAMP__ "Y"    /* { dg-warning "\"__TIMESTAMP__\" redefined" } */
-/* { dg-warning "previous definition" "" { target *-*-* } 48 } */
+/* { dg-message "previous definition" "" { target *-*-* } 48 } */
 
 #undef __TIMESTAMP__         /* Undefine while defined.  */
 
diff --git a/gcc/testsuite/gcc.dg/builtin-stringop-chk-1.c b/gcc/testsuite/gcc.dg/builtin-stringop-chk-1.c
index f401d39c2..e9fb7db52 100644
--- a/gcc/testsuite/gcc.dg/builtin-stringop-chk-1.c
+++ b/gcc/testsuite/gcc.dg/builtin-stringop-chk-1.c
@@ -2,7 +2,7 @@
    are emitted properly.  */
 /* { dg-do compile } */
 /* { dg-options "-O2 -std=gnu99" } */
-/* { dg-options "-mstructure-size-boundary=8 -O2 -std=gnu99" { target arm-*-* } } */
+/* { dg-options "-mstructure-size-boundary=8 -O2 -std=gnu99" { target arm*-*-* } } */
 
 extern void abort (void);
 
diff --git a/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c b/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c
index f563c2774..4f5315df2 100644
--- a/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c
+++ b/gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c
@@ -46,7 +46,7 @@ const char *dg_options[] = {
 "/* { dg-options \"%s-I%s\" } */\n",
 "/* { dg-options \"%s-I%s -Wno-abi\" } */\n",
 "/* { dg-options \"%s-I%s -mno-mmx -Wno-abi\" { target i?86-*-* x86_64-*-* } } */\n",
-"/* { dg-options \"%s-I%s -fno-common\" { target hppa*-*-hpux* powerpc*-*-darwin* *-*-mingw32* *-*-cygwin* } } */\n",
+"/* { dg-options \"%s-I%s -fno-common\" { target hppa*-*-hpux* powerpc*-*-darwin* } } */\n",
 "/* { dg-options \"%s-I%s -mno-mmx -fno-common -Wno-abi\" { target i?86-*-darwin* x86_64-*-darwin* } } */\n",
 "/* { dg-options \"%s-I%s -mno-base-addresses\" { target mmix-*-* } } */\n",
 "/* { dg-options \"%s-I%s -mlongcalls -mtext-section-literals\" { target xtensa*-*-* } } */\n"
diff --git a/gcc/testsuite/gcc.dg/cpp/Wvariadic-1.c b/gcc/testsuite/gcc.dg/cpp/Wvariadic-1.c
index 88e27932e..b034aacd2 100644
--- a/gcc/testsuite/gcc.dg/cpp/Wvariadic-1.c
+++ b/gcc/testsuite/gcc.dg/cpp/Wvariadic-1.c
@@ -4,3 +4,4 @@
 #define f(x,...)	/* { dg-error "variadic" } */
 #define g(x,y...)	/* { dg-error "variadic" } */
 int not_empty;
+/* { dg-message "warnings being treated as errors" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/cpp/Wvariadic-3.c b/gcc/testsuite/gcc.dg/cpp/Wvariadic-3.c
index 056af8389..0317c3c6d 100644
--- a/gcc/testsuite/gcc.dg/cpp/Wvariadic-3.c
+++ b/gcc/testsuite/gcc.dg/cpp/Wvariadic-3.c
@@ -4,3 +4,4 @@
 #define f(x,...)
 #define g(x,y...)	/* { dg-error "variadic" } */
 int not_empty;
+/* { dg-message "warnings being treated as errors" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/cpp/include2.c b/gcc/testsuite/gcc.dg/cpp/include2.c
index cda818ed5..67f1065ae 100644
--- a/gcc/testsuite/gcc.dg/cpp/include2.c
+++ b/gcc/testsuite/gcc.dg/cpp/include2.c
@@ -8,9 +8,8 @@
 /* Source: Neil Booth, 4 Nov 2000.  */
 
 #include <silly\>>  /* { dg-error "extra tokens" "" } */
-#include "silly\""  /* { dg-error "extra tokens" "" } */
 
 /* These error is No such file or directory, just once.  However, this
    message is locale-dependent, so don't test for it.  */
 /* { dg-error "silly" "" { target *-*-* } 10 } */
-/* { dg-error "missing" "" { target *-*-* } 11 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/cpp/include2a.c b/gcc/testsuite/gcc.dg/cpp/include2a.c
new file mode 100644
index 000000000..974f3f332
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp/include2a.c
@@ -0,0 +1,16 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.  */
+
+/* { dg-do preprocess } */
+
+/* Tests that #include does not allow the terminating '>' or '"' to be
+   escaped, as per the standard.  */
+
+/* Source: Neil Booth, 4 Nov 2000.  */
+
+#include "silly\""  /* { dg-error "extra tokens" "" } */
+
+/* These error is No such file or directory, just once.  However, this
+   message is locale-dependent, so don't test for it.  */
+/* { dg-error "silly" "" { target *-*-* } 10 } */
+/* { dg-error "missing" "" { target *-*-* } 10 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/cpp/missing-header-1.c b/gcc/testsuite/gcc.dg/cpp/missing-header-1.c
new file mode 100644
index 000000000..5445d4c4f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp/missing-header-1.c
@@ -0,0 +1,9 @@
+/* Test that missing headers are fatal errors.  PR 15638.  */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+#include "nonexistent.h" /* { dg-error "nonexistent.h" } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
+
+/* This declaration should not receive any diagnostic.  */
+foo bar;
diff --git a/gcc/testsuite/gcc.dg/cpp/missing-header-MD.c b/gcc/testsuite/gcc.dg/cpp/missing-header-MD.c
new file mode 100644
index 000000000..198352537
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp/missing-header-MD.c
@@ -0,0 +1,6 @@
+/* Test that missing user headers are fatal errors with -MD.  */
+/* { dg-do compile } */
+/* { dg-options "-MD" } */
+
+#include "nonexistent.h" /* { dg-error "nonexistent.h" } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/cpp/missing-header-MMD.c b/gcc/testsuite/gcc.dg/cpp/missing-header-MMD.c
new file mode 100644
index 000000000..aff8d3955
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp/missing-header-MMD.c
@@ -0,0 +1,6 @@
+/* Test that missing user headers are fatal errors with -MMD.  */
+/* { dg-do compile } */
+/* { dg-options "-MMD" } */
+
+#include "nonexistent.h" /* { dg-error "nonexistent.h" } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MD.c b/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MD.c
new file mode 100644
index 000000000..bf255a499
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MD.c
@@ -0,0 +1,6 @@
+/* Test that missing system headers are fatal errors with -MD.  */
+/* { dg-do compile } */
+/* { dg-options "-MD" } */
+
+#include <nonexistent.h> /* { dg-error "nonexistent.h" } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MMD.c b/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MMD.c
new file mode 100644
index 000000000..10cd870ad
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp/missing-sysheader-MMD.c
@@ -0,0 +1,6 @@
+/* Test that missing system headers are fatal errors with -MMD.  */
+/* { dg-do compile } */
+/* { dg-options "-MMD" } */
+
+#include <nonexistent.h> /* { dg-error "nonexistent.h" } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/cpp/redef2.c b/gcc/testsuite/gcc.dg/cpp/redef2.c
index b0068d916..57fa3b193 100644
--- a/gcc/testsuite/gcc.dg/cpp/redef2.c
+++ b/gcc/testsuite/gcc.dg/cpp/redef2.c
@@ -23,9 +23,9 @@
    { dg-warning "redefined" "redef ro"      { target *-*-* } 12 }
    { dg-warning "redefined" "redef va"      { target *-*-* } 15 }
 
-   { dg-warning "previous"  "prev def mac"  { target *-*-* } 6  }
-   { dg-warning "previous"  "prev def mac"  { target *-*-* } 7  }
-   { dg-warning "previous"  "prev def mac"  { target *-*-* } 8  }
-   { dg-warning "previous"  "prev def ro"   { target *-*-* } 11 }
-   { dg-warning "previous"  "prev def va"   { target *-*-* } 14 }
+   { dg-message "previous"  "prev def mac"  { target *-*-* } 6  }
+   { dg-message "previous"  "prev def mac"  { target *-*-* } 7  }
+   { dg-message "previous"  "prev def mac"  { target *-*-* } 8  }
+   { dg-message "previous"  "prev def ro"   { target *-*-* } 11 }
+   { dg-message "previous"  "prev def va"   { target *-*-* } 14 }
 */
diff --git a/gcc/testsuite/gcc.dg/cpp/redef3.c b/gcc/testsuite/gcc.dg/cpp/redef3.c
index 78ee71e65..1c541a45b 100644
--- a/gcc/testsuite/gcc.dg/cpp/redef3.c
+++ b/gcc/testsuite/gcc.dg/cpp/redef3.c
@@ -15,7 +15,7 @@
    { dg-warning "redefined" "redef B"      { target *-*-* } 9  }
    { dg-warning "redefined" "redef D"      { target *-*-* } 11 }
    { dg-warning "redefined" "redef E"      { target *-*-* } 12 }
-   { dg-warning "previous"  "prev def A"   { target *-*-* } 6  }
-   { dg-warning "previous"  "prev def B"   { target *-*-* } 8  }
-   { dg-warning "previous"  "prev def D/E" { target *-*-* } 0  }
+   { dg-message "previous"  "prev def A"   { target *-*-* } 6  }
+   { dg-message "previous"  "prev def B"   { target *-*-* } 8  }
+   { dg-message "previous"  "prev def D/E" { target *-*-* } 0  }
 */
diff --git a/gcc/testsuite/gcc.dg/cpp/trad/redef2.c b/gcc/testsuite/gcc.dg/cpp/trad/redef2.c
index 269a84626..5fcd5eb32 100644
--- a/gcc/testsuite/gcc.dg/cpp/trad/redef2.c
+++ b/gcc/testsuite/gcc.dg/cpp/trad/redef2.c
@@ -2,31 +2,31 @@
 
 /* { dg-do preprocess } */
 
-#define foo bar    /* { dg-warning "previous def" "foo prev def" } */
+#define foo bar    /* { dg-message "previous def" "foo prev def" } */
 #define foo barr   /* { dg-warning "redefined" "foo redefined" } */
 
 #undef foo
-#define foo bar    /* { dg-warning "previous def" "foo prev def 2" } */
+#define foo bar    /* { dg-message "previous def" "foo prev def 2" } */
 #define foo() bar    /* { dg-warning "redefined" "foo redefined 2" } */
 
 #undef foo
-#define foo() bar    /* { dg-warning "previous def" "foo prev def" } */
+#define foo() bar    /* { dg-message "previous def" "foo prev def" } */
 #define foo() barr   /* { dg-warning "redefined" "foo redefined" } */
 
-#define quux(thud) a thud b /* { dg-warning "previous def" "quux prev def" } */
+#define quux(thud) a thud b /* { dg-message "previous def" "quux prev def" } */
 #define quux(thu) a thud b   /* { dg-warning "redefined" "quux redefined" } */
 
-#define bar(x, y) x+y /* { dg-warning "previous def" "bar prev def" } */
+#define bar(x, y) x+y /* { dg-message "previous def" "bar prev def" } */
 #define bar(x, y) x+x   /* { dg-warning "redefined" "bar redefined" } */
 
-#define bat(x, y) x+y  /* { dg-warning "previous def" "bat prev def" } */
+#define bat(x, y) x+y  /* { dg-message "previous def" "bat prev def" } */
 #define bat(x, y) x+ y   /* { dg-warning "redefined" "bat redefined" } */
 
-#define baz(x, y) x+y  /* { dg-warning "previous def" "baz prev def" } */
+#define baz(x, y) x+y  /* { dg-message "previous def" "baz prev def" } */
 #define baz(x, y) x +y   /* { dg-warning "redefined" "baz redefined" } */
 
-#define f(x, y) "x y"  /* { dg-warning "previous def" "f prev def" } */
+#define f(x, y) "x y"  /* { dg-message "previous def" "f prev def" } */
 #define f(x, y) "x  y"   /* { dg-warning "redefined" "f redefined" } */
 
-#define g(x, y) 'x'  /* { dg-warning "previous def" "g prev def" } */
+#define g(x, y) 'x'  /* { dg-message "previous def" "g prev def" } */
 #define g(x, y) ' x'   /* { dg-warning "redefined" "g redefined" } */
diff --git a/gcc/testsuite/gcc.dg/dll-4.c b/gcc/testsuite/gcc.dg/dll-4.c
index 9fcc8e9ad..897b5506d 100644
--- a/gcc/testsuite/gcc.dg/dll-4.c
+++ b/gcc/testsuite/gcc.dg/dll-4.c
@@ -11,5 +11,6 @@ int foo2 = 5;	/* { dg-warning "redeclared without dllimport" } */
 int f () { return foo1 + foo2; }
 
 /* FIXME: We should scan the output of nm for this case.  */
-/* { dg-final { scan-assembler "(foo2:.*\.comm\[ \t_\]*foo1)" } } */
+/* { dg-final { scan-assembler "(foo2:)" } } */
+/* { dg-final { scan-assembler "(\.comm\[ \t_\]*foo1)" } } */
 /* { dg-final { scan-assembler-not "(__imp_|_imp__)" } } */
diff --git a/gcc/testsuite/gcc.dg/dll-6.c b/gcc/testsuite/gcc.dg/dll-6.c
new file mode 100644
index 000000000..7907f40d1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dll-6.c
@@ -0,0 +1,52 @@
+/* { dg-do link } */
+/* { dg-require-dll "" } */
+/* { dg-additional-sources "dll-6a.c" } */
+/* { dg-options "-w -O2 -std=gnu89" } */
+
+/* Test that inline functions declared "dllexport" appear in object
+   files, even if they are not called.
+
+   This behavior is required by the ARM C++ ABI:
+
+     Exporting a function that can be inlined should force the
+     creation and export of an out-of-line copy of it.
+
+   and should presumably also apply.
+
+   Visual Studio 2005 also honors that rule.  */
+
+__declspec(dllexport) inline void i1() {}
+
+__declspec(dllexport) extern inline void e1() {}
+
+/* It is invalid to declare the function inline after its definition.  */
+#if 0
+__declspec(dllexport) void i2() {}
+inline void i2();
+
+__declspec(dllexport) extern void e2() {}
+inline void e2();
+#endif
+
+__declspec(dllexport) inline void i3() {}
+void i3();
+
+__declspec(dllexport) inline void e3() {}
+extern void e3();
+
+__declspec(dllexport) void i4();
+inline void i4() {};
+
+__declspec(dllexport) extern void e4();
+inline void e4() {};
+
+__declspec(dllexport) inline void i5();
+void i5() {};
+
+__declspec(dllexport) inline void e5();
+extern void e5() {};
+
+/* Make sure that just declaring the function -- without defining it
+   -- does not cause errors.  */
+__declspec(dllexport) inline void i6();
+__declspec(dllexport) extern inline void e6();
diff --git a/gcc/testsuite/gcc.dg/dll-6a.c b/gcc/testsuite/gcc.dg/dll-6a.c
new file mode 100644
index 000000000..80caf3217
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dll-6a.c
@@ -0,0 +1,21 @@
+extern void i1();
+extern void i3();
+extern void i4();
+extern void i5();
+
+extern void e1();
+extern void e3();
+extern void e4();
+extern void e5();
+
+int main () {
+  i1();
+  i3();
+  i4();
+  i5();
+
+  e1();
+  e3();
+  e4();
+  e5();
+}
diff --git a/gcc/testsuite/gcc.dg/dll-7.c b/gcc/testsuite/gcc.dg/dll-7.c
new file mode 100644
index 000000000..c3a5957ae
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dll-7.c
@@ -0,0 +1,52 @@
+/* { dg-do link } */
+/* { dg-require-dll "" } */
+/* { dg-additional-sources "dll-7a.c" } */
+/* { dg-options "-w -O2 -std=gnu99" } */
+
+/* Test that inline functions declared "dllexport" appear in object
+   files, even if they are not called.
+
+   This behavior is required by the ARM C++ ABI:
+
+     Exporting a function that can be inlined should force the
+     creation and export of an out-of-line copy of it.
+
+   and should presumably also apply.
+
+   Visual Studio 2005 also honors that rule.  */
+
+__declspec(dllexport) inline void i1() {}
+
+__declspec(dllexport) extern inline void e1() {}
+
+/* It is invalid to declare the function inline after its definition.  */
+#if 0
+__declspec(dllexport) void i2() {}
+inline void i2();
+
+__declspec(dllexport) extern void e2() {}
+inline void e2();
+#endif
+
+__declspec(dllexport) inline void i3() {}
+void i3();
+
+__declspec(dllexport) inline void e3() {}
+extern void e3();
+
+__declspec(dllexport) void i4();
+inline void i4() {};
+
+__declspec(dllexport) extern void e4();
+inline void e4() {};
+
+__declspec(dllexport) inline void i5();
+void i5() {};
+
+__declspec(dllexport) inline void e5();
+extern void e5() {};
+
+/* Make sure that just declaring the function -- without defining it
+   -- does not cause errors.  */
+__declspec(dllexport) inline void i6();
+__declspec(dllexport) extern inline void e6();
diff --git a/gcc/testsuite/gcc.dg/dll-7a.c b/gcc/testsuite/gcc.dg/dll-7a.c
new file mode 100644
index 000000000..80caf3217
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dll-7a.c
@@ -0,0 +1,21 @@
+extern void i1();
+extern void i3();
+extern void i4();
+extern void i5();
+
+extern void e1();
+extern void e3();
+extern void e4();
+extern void e5();
+
+int main () {
+  i1();
+  i3();
+  i4();
+  i5();
+
+  e1();
+  e3();
+  e4();
+  e5();
+}
diff --git a/gcc/testsuite/gcc.dg/falign-labels-1.c b/gcc/testsuite/gcc.dg/falign-labels-1.c
new file mode 100644
index 000000000..1e9661790
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/falign-labels-1.c
@@ -0,0 +1,39 @@
+/* { dg-do run } */
+/* { dg-options "-falign-labels=8" { target { ! { m68k*-*-* || fido*-*-* } } } } */
+
+/* On ARMv7-A CPUs, this test resulted in incorrect code generation.
+   The code generated for the switch statement expected the jump table
+   to immediately follow the jump instruction, but -falign-labels
+   caused the label preceding the table to be aligned.  */
+/* M68K and fido only support -falign-labels argument <= 2.  */
+
+volatile int x;
+
+int main(void)
+{
+  int y;
+
+  x = 0;
+
+  switch(x)
+    {
+    case 0:
+      y = 2 * x;
+      break;
+    case 1:
+      y = -3 * x;
+      break;
+    case 2:
+      y = x + 5;
+      break;
+    case 3:
+      y = x - 7;
+      break;
+    default:
+      break;
+    }
+
+  x = y;
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/fltconst-1.c b/gcc/testsuite/gcc.dg/fltconst-1.c
index 85e1d34a5..1b75210e9 100644
--- a/gcc/testsuite/gcc.dg/fltconst-1.c
+++ b/gcc/testsuite/gcc.dg/fltconst-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-std=gnu99" } */
+/* { dg-options "-std=gnu99 -fshow-column" } */
 
 double a = 1.ld;	/* { dg-error "12:invalid suffix" } */
 double b = 1.fd;	/* { dg-error "12:invalid suffix" } */
diff --git a/gcc/testsuite/gcc.dg/long-long-shift-1.c b/gcc/testsuite/gcc.dg/long-long-shift-1.c
new file mode 100644
index 000000000..d00438b46
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/long-long-shift-1.c
@@ -0,0 +1,18 @@
+/* The initial >> 39 is hoisted out of the loop by the RTL loop passes.
+   When the 39 is propagated into the variable shift code, this results
+   in an immediate left shift by -7 (assuming no native 64-bit shift operator).
+   This will eventially be eliminated by DCE, but lasts long enough to
+   cause problems in the Thumb-2 shift-arith patterns.  */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+long long
+test (long long pat, long long mask, int n)
+{
+  long long z = 0;
+  int i;
+
+  for (i = 39; i < 62; i++)
+    z += (pat >> i) + mask ^ mask;
+
+  return z;
+}
diff --git a/gcc/testsuite/gcc.dg/m68k-fp-1.c b/gcc/testsuite/gcc.dg/m68k-fp-1.c
new file mode 100644
index 000000000..e650c9121
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/m68k-fp-1.c
@@ -0,0 +1,13 @@
+/* ColdFire has restricted addressing modes for float operands.  */
+/* { dg-do compile { target m68k-*-* } }  */
+/* { dg-options "-O0 -mcpu=547x -mhard-float" }  */
+
+double Foo (unsigned a)
+{
+  unsigned local_data[16384] __attribute__((unused));
+  double d;
+
+  d = a;
+
+  return d;
+}
diff --git a/gcc/testsuite/gcc.dg/pch/counter-2.c b/gcc/testsuite/gcc.dg/pch/counter-2.c
index 22ba245b6..6dd2245d7 100644
--- a/gcc/testsuite/gcc.dg/pch/counter-2.c
+++ b/gcc/testsuite/gcc.dg/pch/counter-2.c
@@ -10,6 +10,7 @@
 #include "counter-2.h" /* { dg-warning "not used because `__COUNTER__' is invalid" } */
 /* { dg-error "counter-2.h: No such file or directory" "no such file" { target *-*-* } 10 } */
 /* { dg-error "one or more PCH files were found, but they were invalid" "invalid files" { target *-*-* } 10 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
 
 int main(void) 
 {
diff --git a/gcc/testsuite/gcc.dg/pch/valid-1.c b/gcc/testsuite/gcc.dg/pch/valid-1.c
index 1bf7d9144..3ee909165 100644
--- a/gcc/testsuite/gcc.dg/pch/valid-1.c
+++ b/gcc/testsuite/gcc.dg/pch/valid-1.c
@@ -3,5 +3,6 @@
 #include "valid-1.h"/* { dg-warning "created with -gnone, but used with -g" } */
 /* { dg-error "No such file" "no such file" { target *-*-* } 3 } */
 /* { dg-error "they were invalid" "invalid files" { target *-*-* } 3 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
 
 int x;
diff --git a/gcc/testsuite/gcc.dg/pch/valid-2.c b/gcc/testsuite/gcc.dg/pch/valid-2.c
index 4dbc4b2d3..34269a879 100644
--- a/gcc/testsuite/gcc.dg/pch/valid-2.c
+++ b/gcc/testsuite/gcc.dg/pch/valid-2.c
@@ -3,4 +3,5 @@
 #include "valid-2.h" /* { dg-warning "settings for -fexceptions do not match" } */
 /* { dg-error "No such file" "no such file" { target *-*-* } 3 } */
 /* { dg-error "they were invalid" "invalid files" { target *-*-* } 3 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
 int x;
diff --git a/gcc/testsuite/gcc.dg/pch/warn-1.c b/gcc/testsuite/gcc.dg/pch/warn-1.c
index eaa9cafc3..64944c776 100644
--- a/gcc/testsuite/gcc.dg/pch/warn-1.c
+++ b/gcc/testsuite/gcc.dg/pch/warn-1.c
@@ -5,6 +5,7 @@
 #include "warn-1.h"/* { dg-warning "not used because .DEFINED_VALUE. is defined" } */
 /* { dg-error "No such file" "no such file" { target *-*-* } 5 } */
 /* { dg-error "they were invalid" "invalid files" { target *-*-* } 5 } */
+/* { dg-message "terminated" "" { target *-*-* } 0 } */
 
 
 int main(void) 
diff --git a/gcc/testsuite/gcc.dg/pr34263.c b/gcc/testsuite/gcc.dg/pr34263.c
index 10df9d81f..389a7b8a5 100644
--- a/gcc/testsuite/gcc.dg/pr34263.c
+++ b/gcc/testsuite/gcc.dg/pr34263.c
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-options "-O2 -fdump-tree-optimized -fno-unroll-loops" } */
 /* Same test as 990128-1.c.  */
 
 extern int printf (const char *,...);
diff --git a/gcc/testsuite/gcc.dg/pragma-isr-trapa2.c b/gcc/testsuite/gcc.dg/pragma-isr-trapa2.c
index 7b68185fc..a1165893b 100644
--- a/gcc/testsuite/gcc.dg/pragma-isr-trapa2.c
+++ b/gcc/testsuite/gcc.dg/pragma-isr-trapa2.c
@@ -1,4 +1,6 @@
 /* { dg-do compile { target { { sh-*-* sh4*-*-* } && nonpic } } } */
+/* { dg-skip-if "FPU Required" { "sh*-*-*" } { "-m*nofpu*" } { "" } } */
+/* { dg-skip-if "FPU Required" { "sh*-*-*" } { "-m4al*" } { "" } } */
 /* { dg-options "-O -m4" } */
 
 extern void foo ();
diff --git a/gcc/testsuite/gcc.dg/profile-dir-1.c b/gcc/testsuite/gcc.dg/profile-dir-1.c
index a0a22ffb0..6745c3b0d 100644
--- a/gcc/testsuite/gcc.dg/profile-dir-1.c
+++ b/gcc/testsuite/gcc.dg/profile-dir-1.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O -fprofile-generate=. -fdump-tree-tree_profile" } */
+/* { dg-require-host-local "" } */
 /* { dg-final { scan-tree-dump " ./profile-dir-1.gcda" "tree_profile" } } */
 
 int
diff --git a/gcc/testsuite/gcc.dg/profile-dir-2.c b/gcc/testsuite/gcc.dg/profile-dir-2.c
index 454f0641a..2bfbee3f4 100644
--- a/gcc/testsuite/gcc.dg/profile-dir-2.c
+++ b/gcc/testsuite/gcc.dg/profile-dir-2.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O -fprofile-generate -fdump-tree-tree_profile" } */
+/* { dg-require-host-local "" } */
 /* { dg-final { scan-tree-dump "/profile-dir-2.gcda" "tree_profile" } } */
 
 int
diff --git a/gcc/testsuite/gcc.dg/profile-dir-3.c b/gcc/testsuite/gcc.dg/profile-dir-3.c
index 29b0a5587..8de891f03 100644
--- a/gcc/testsuite/gcc.dg/profile-dir-3.c
+++ b/gcc/testsuite/gcc.dg/profile-dir-3.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O -fprofile-generate -fprofile-dir=. -fdump-tree-tree_profile" } */
+/* { dg-require-host-local "" } */
 /* { dg-final { scan-tree-dump " ./profile-dir-3.gcda" "tree_profile" } } */
 
 int
diff --git a/gcc/testsuite/gcc.dg/promote-short-1.c b/gcc/testsuite/gcc.dg/promote-short-1.c
new file mode 100644
index 000000000..70ee24cc1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-1.c
@@ -0,0 +1,15 @@
+/* Verify that we promote a short loop index variable.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 1 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (short n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    x[i] = 0;
+}
diff --git a/gcc/testsuite/gcc.dg/promote-short-10.c b/gcc/testsuite/gcc.dg/promote-short-10.c
new file mode 100644
index 000000000..2e7eacc74
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-10.c
@@ -0,0 +1,20 @@
+/* Verify that we do not promote a short loop index variable when its
+   address is taken.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Found 0 candidates" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+extern void outside (short *);
+
+void
+test1 (int n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    {
+      outside (&i);
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/promote-short-11.c b/gcc/testsuite/gcc.dg/promote-short-11.c
new file mode 100644
index 000000000..fd44d3771
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-11.c
@@ -0,0 +1,24 @@
+/* We used to ICE due to badness while rebuilding phi nodes.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Inserting downcast" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+int bar (void);
+
+unsigned char
+foo (int a)
+{
+  unsigned char i, ret = 0;
+
+  for (i = 0; i < 8; i++)
+      if (bar() && bar())
+        {
+          if (a)
+            ret = i;
+        }
+
+  return ret;
+}
+
diff --git a/gcc/testsuite/gcc.dg/promote-short-12.c b/gcc/testsuite/gcc.dg/promote-short-12.c
new file mode 100644
index 000000000..24b307ce9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-12.c
@@ -0,0 +1,27 @@
+/* We used to miss getting both assignments to ret correct.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Inserting downcast" 2 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+int bar (void);
+
+unsigned char
+foo (int a)
+{
+  unsigned char i, j, ret = 0;
+
+  for (i = 0; i < 8; i++)
+    for (j = 0; j < 8; j++)
+      if (bar() && bar())
+        {
+          if (a)
+            ret = i;
+          else
+            ret = j;
+        }
+
+  return ret;
+}
+
diff --git a/gcc/testsuite/gcc.dg/promote-short-2.c b/gcc/testsuite/gcc.dg/promote-short-2.c
new file mode 100644
index 000000000..3a6111802
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-2.c
@@ -0,0 +1,16 @@
+/* Verify that we do not promote a short loop index variable when it is
+   being stored to memory.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 0 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (short n, short *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    x[i] = i;
+}
diff --git a/gcc/testsuite/gcc.dg/promote-short-3.c b/gcc/testsuite/gcc.dg/promote-short-3.c
new file mode 100644
index 000000000..aa7a1d581
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-3.c
@@ -0,0 +1,18 @@
+/* Verify that we do not promote a short loop index variable when it is
+   being passed as a function parameter.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 0 variables" 1 "promoteshort" { xfail m68k*-*-* fido*-*-* i?86-*-* x86_64-*-* mips*-*-* sh*-*-* } } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+extern void outside (short);
+
+void
+test1 (short n)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    outside (i);
+}
diff --git a/gcc/testsuite/gcc.dg/promote-short-4.c b/gcc/testsuite/gcc.dg/promote-short-4.c
new file mode 100644
index 000000000..b2f2f5300
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-4.c
@@ -0,0 +1,19 @@
+/* Verify that we do not promote a short loop index variable when it is
+   modified within the loop.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 0 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (short n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    {
+      i++;
+      x[i] = 0;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/promote-short-5.c b/gcc/testsuite/gcc.dg/promote-short-5.c
new file mode 100644
index 000000000..5bb717209
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-5.c
@@ -0,0 +1,18 @@
+/* Verify that we do not promote a short loop index variable when it has
+   a non-unit-increment.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 0 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (short n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i+=2)
+    {
+      x[i] = 0;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/promote-short-6.c b/gcc/testsuite/gcc.dg/promote-short-6.c
new file mode 100644
index 000000000..8244fb022
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-6.c
@@ -0,0 +1,18 @@
+/* Verify that we do promote a short loop index variable when it has
+   a non-unit-increment and -funsafe-loop-optimizations is in effect.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -funsafe-loop-optimizations -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 1 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (short n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i+=2)
+    {
+      x[i] = 0;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/promote-short-7.c b/gcc/testsuite/gcc.dg/promote-short-7.c
new file mode 100644
index 000000000..772f46b70
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-7.c
@@ -0,0 +1,18 @@
+/* Verify that we do not promote a short loop index variable when the
+   loop in which it is used has a bound of wider type.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 0 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (int n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    {
+      x[i] = 0;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/promote-short-8.c b/gcc/testsuite/gcc.dg/promote-short-8.c
new file mode 100644
index 000000000..9da6f899b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-8.c
@@ -0,0 +1,19 @@
+/* Verify that we do promote a short loop index variable when the loop
+   in which it is used has a bound of wider type and
+   -funsafe-loop-optimizations is in effect.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices -funsafe-loop-optimizations -fdump-tree-promoteshort" } */
+/* { dg-final { scan-tree-dump-times "Promoting 1 variables" 1 "promoteshort" } } */
+/* { dg-final { cleanup-tree-dump "promoteshort" } } */
+
+void
+test1 (int n, int *x)
+{
+  short i;
+
+  for (i = 0; i < n; i++)
+    {
+      x[i] = 0;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/promote-short-9.c b/gcc/testsuite/gcc.dg/promote-short-9.c
new file mode 100644
index 000000000..e8ad2716d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/promote-short-9.c
@@ -0,0 +1,15 @@
+/* -fpromote-loop-indices used to ICE on this.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fpromote-loop-indices" } */
+
+char
+lookup (char *haystack, char *needle)
+{
+  char x;
+
+  for (x = haystack[-2]; x < *needle; x++)
+    haystack[x] = needle[x];
+
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-1.c b/gcc/testsuite/gcc.dg/remove-local-statics-1.c
new file mode 100644
index 000000000..affdec478
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-1.c
@@ -0,0 +1,16 @@
+/* Verify that we eliminate a static local variable where its uses
+   are dominated by a def.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler-not "thestatic" } } */
+
+int
+test1 (int x)
+{
+  static int thestatic;
+
+  thestatic = x;
+
+  return thestatic + x;
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-10.c b/gcc/testsuite/gcc.dg/remove-local-statics-10.c
new file mode 100644
index 000000000..6db5b380c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-10.c
@@ -0,0 +1,32 @@
+/* Verify that we do not eliminate a static local variable when it is
+   live on return from a function call that recursively calls the
+   function in which the variable is defined.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int
+test2 (int x)
+{
+  if (x < 0)
+    return 0;
+  else
+    return test1 (x - 1);
+}
+
+int
+test1 (int x)
+{
+  static int thestatic;
+  int y;
+
+  thestatic = x;
+
+  y = test2 (x - 1);
+
+  y += thestatic;
+
+  return y + x;
+}
+  
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-11.c b/gcc/testsuite/gcc.dg/remove-local-statics-11.c
new file mode 100644
index 000000000..d6b1694c9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-11.c
@@ -0,0 +1,16 @@
+/* Verify that we do not eliminate a static local variable when its
+   address is taken.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int *
+test1 (int x)
+{
+  static int thestatic;
+
+  thestatic = x;
+
+  return &thestatic + x;
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-12.c b/gcc/testsuite/gcc.dg/remove-local-statics-12.c
new file mode 100644
index 000000000..b510d6386
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-12.c
@@ -0,0 +1,20 @@
+/* Verify that we do not eliminate a static variable when it is declared
+   in a function that has nested functions.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int test1 (int x)
+{
+  static int thestatic;
+
+  int nested_test1 (int x)
+  {
+    return x + thestatic;
+  }
+
+  thestatic = x;
+
+  return thestatic + x + nested_test1 (x);
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-13.c b/gcc/testsuite/gcc.dg/remove-local-statics-13.c
new file mode 100644
index 000000000..a6c4bcca1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-13.c
@@ -0,0 +1,24 @@
+/* We used to ICE on this test, because the call to BAR appeared to
+   define both static variables in FOO.  Verify that we no longer do
+   this.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "static1" } } */
+/* { dg-final { scan-assembler-not "static2" } } */
+
+int foo(int i) {
+  static int static1 = 0;
+  static int static2;
+
+  if (static2 = bar(i))
+    static1 = 1;
+  static2 = static1 + 30;
+
+  return static1 + static2;
+}
+
+int bar(int i) {
+  if (i) { foo(i-1); return 0; }
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-14.c b/gcc/testsuite/gcc.dg/remove-local-statics-14.c
new file mode 100644
index 000000000..1343366b2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-14.c
@@ -0,0 +1,29 @@
+/* Verify that we do eliminate a static local variable whose last use is
+   in a statement containing a call expression.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler-not "thestatic" } } */
+
+int
+test2 (int x)
+{
+  if (x < 0)
+    return 0;
+  else
+    return test1 (x - 1);
+}
+
+int
+test1 (int x)
+{
+  static int thestatic;
+  int y;
+
+  thestatic = x;
+
+  y = test2 (thestatic - 1);
+
+  return y + x;
+}
+  
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-15.c b/gcc/testsuite/gcc.dg/remove-local-statics-15.c
new file mode 100644
index 000000000..b938565d6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-15.c
@@ -0,0 +1,17 @@
+/* Verify that we do not consider an array variable for local static
+   elimination.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics -fdump-tree-remlocstatic-details" } */
+
+int foo (void)
+{
+  static int a[1];
+
+  a[0] = 0;
+
+  return a[0];
+}
+
+/* { dg-final { scan-tree-dump-times "static variables to consider" 0 "remlocstatic" } } */
+/* { dg-final { cleanup-tree-dump "remlocstatic" } } */
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-16.c b/gcc/testsuite/gcc.dg/remove-local-statics-16.c
new file mode 100644
index 000000000..8423b5eaf
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-16.c
@@ -0,0 +1,20 @@
+/* Verify that we do not consider an structure variable for local static
+   elimination.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics -fdump-tree-remlocstatic-details" } */
+
+int foo (void)
+{
+  static struct {
+    int x;
+    int y;
+  } a;
+
+  a.x = 0;
+
+  return a.y;
+}
+
+/* { dg-final { scan-tree-dump-times "static variables to consider" 0 "remlocstatic" } } */
+/* { dg-final { cleanup-tree-dump "remlocstatic" } } */
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-17.c b/gcc/testsuite/gcc.dg/remove-local-statics-17.c
new file mode 100644
index 000000000..c9f81fc8d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-17.c
@@ -0,0 +1,19 @@
+/* Verify that we do not eliminate a static variable that is "defined"
+   by an asm that clobbers memory.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics -fdump-tree-remlocstatic-details" } */
+
+int foo (void)
+{
+  static int foo = 0;
+
+  __asm__ __volatile__ ("" : : : "memory");
+
+  foo++;
+
+  return foo;
+}
+
+/* { dg-final { scan-tree-dump-times "removed 0 static variables" 1 "remlocstatic" } } */
+/* { dg-final { cleanup-tree-dump "remlocstatic" } } */
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-2.c b/gcc/testsuite/gcc.dg/remove-local-statics-2.c
new file mode 100644
index 000000000..5decb9c4c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-2.c
@@ -0,0 +1,19 @@
+/* Verify that we do not eliminate a static local variable when its uses
+   are not dominated by a def.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "first_time" } } */
+
+int
+test1 (int x)
+{
+  static int first_time;
+
+  if (x == 1)
+    first_time = 1;
+  else if (x > 0)
+    first_time = 2;
+
+  return first_time + x;
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-3.c b/gcc/testsuite/gcc.dg/remove-local-statics-3.c
new file mode 100644
index 000000000..00e328093
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-3.c
@@ -0,0 +1,16 @@
+/* Verify that we do not eliminate a static local variable whose uses
+   are dominated by a def when the variable is volatile.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int
+test1 (int x)
+{
+  static volatile int thestatic;
+
+  thestatic = x;
+
+  return thestatic + x;
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-4.c b/gcc/testsuite/gcc.dg/remove-local-statics-4.c
new file mode 100644
index 000000000..0ccb6f7d1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-4.c
@@ -0,0 +1,15 @@
+/* Verify that we don't eliminate a global static variable.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "global_static" } } */
+
+static int global_static;
+
+int
+test1 (int x)
+{
+  global_static = x;
+
+  return global_static + x;
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-5.c b/gcc/testsuite/gcc.dg/remove-local-statics-5.c
new file mode 100644
index 000000000..26e64fa4e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-5.c
@@ -0,0 +1,24 @@
+/* Verify that we do not eliminate a static local variable whose uses
+   are dominated by a def when the function calls setjmp.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+#include <setjmp.h>
+
+int
+foo (int x)
+{
+  static int thestatic;
+  int retval;
+  jmp_buf env;
+
+  thestatic = x;
+
+  retval = thestatic + x;
+
+  setjmp (env);
+
+  return retval;
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-6.c b/gcc/testsuite/gcc.dg/remove-local-statics-6.c
new file mode 100644
index 000000000..83552ed85
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-6.c
@@ -0,0 +1,16 @@
+/* Verify that we do not eliminate a static local variable whose uses
+   are dominated by a def when the variable is addressed.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler "thestatic" } } */
+
+int *
+test1 (int x)
+{
+  static int thestatic;
+
+  thestatic = x;
+
+  return &thestatic + x;
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-7.c b/gcc/testsuite/gcc.dg/remove-local-statics-7.c
new file mode 100644
index 000000000..1c3b2bb42
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-7.c
@@ -0,0 +1,21 @@
+/* Verify that we eliminate a static local variable where it is defined
+   along all paths leading to a use.
+
+   XFAIL'd because our analysis is currently too weak.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler-not "thestatic" } } */
+
+int
+test1 (int x)
+{
+  static int thestatic;
+
+  if (x < 0)
+    thestatic = x;
+  else
+    thestatic = -x;
+
+  return thestatic + x;
+}
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-8.c b/gcc/testsuite/gcc.dg/remove-local-statics-8.c
new file mode 100644
index 000000000..63051ec38
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-8.c
@@ -0,0 +1,33 @@
+/* Verify that we eliminate a static local variable when it is dead on
+   return from a function call that recursively calls the function in
+   which the variable is defined.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler-not "thestatic" } } */
+
+int test1 (int);
+int test2 (int);
+
+int
+test2 (int x)
+{
+  if (x < 0)
+    return 0;
+  else
+    return test1 (x - 1);
+}
+
+int
+test1 (int x)
+{
+  static int thestatic;
+  int y;
+
+  thestatic = x;
+
+  y = thestatic;
+
+  return y + x + test1 (x - 1) + test2 (x - 1);
+}
+  
diff --git a/gcc/testsuite/gcc.dg/remove-local-statics-9.c b/gcc/testsuite/gcc.dg/remove-local-statics-9.c
new file mode 100644
index 000000000..0bb0cf0c6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/remove-local-statics-9.c
@@ -0,0 +1,34 @@
+/* Verify that we eliminate a static local variable when it is live
+   on return from a function call that does not recursively call the
+   function in which the variable is defined.  */
+
+/* XFAIL'd because we don't utilize the callgraph properly.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -fremove-local-statics" } */
+/* { dg-final { scan-assembler-not "thestatic" { xfail *-*-* } } } */
+
+static int
+test2 (int x)
+{
+  if (x < 0)
+    return 0;
+  else
+    return x + test2 (x - 1);
+}
+
+int
+test1 (int x)
+{
+  static int thestatic;
+  int y;
+
+  thestatic = x;
+
+  y = test2 (x - 1);
+
+  y += thestatic;
+
+  return y + x;
+}
+  
diff --git a/gcc/testsuite/gcc.dg/strncpy-fix-1.c b/gcc/testsuite/gcc.dg/strncpy-fix-1.c
new file mode 100644
index 000000000..b8bc916e0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/strncpy-fix-1.c
@@ -0,0 +1,11 @@
+/* Test that use of strncpy does not result in a "value computed is
+   not used" warning.  */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall" } */
+
+#include <string.h>
+void
+f (char *s)
+{
+  strncpy (s, "::", 2);
+}
diff --git a/gcc/testsuite/gcc.dg/tls/pie-1.c b/gcc/testsuite/gcc.dg/tls/pie-1.c
new file mode 100644
index 000000000..07eb5f1ad
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/pie-1.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-fpie" } */
+/* { dg-require-effective-target tls } */
+
+__thread int a; int b; int main() { return a = b; }
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-assign.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-assign.c
new file mode 100644
index 000000000..d6143d278
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-assign.c
@@ -0,0 +1,29 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Test basic assignments and conversions for __fp16.  */
+
+__fp16 h0 = -1.0;
+__fp16 h1 = 0.0;
+__fp16 h2 = 1234.0;
+__fp16 h3 = 42.0;
+float f1 = 2.0;
+float f2 = -999.9;
+
+void f (__fp16 *p)
+{
+  __fp16 t;
+
+  h0 = 1.0;
+  h1 = h2;
+  h2 = f1;
+  f2 = h2;
+
+  t = *p;
+  *p = h3;
+  h3 = t;
+}
+
+/* Make sure we are not falling through to undefined libcalls.  */
+/* { dg-final { scan-assembler-not "__truncsfhf" } } */
+/* { dg-final { scan-assembler-not "__extendhfsf" } } */
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-convert.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-convert.c
new file mode 100644
index 000000000..04341959f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-compile-convert.c
@@ -0,0 +1,41 @@
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Test basic assignments and conversions for __fp16.  */
+
+__fp16 h1 = 0.0;
+__fp16 h2 = 1234.0;
+char c1 = 1;
+char c2 = 2;
+short s1 = 10;
+short s2 = 20;
+int i1 = -100;
+int i2 = -200;
+long long l1 = 1000.0;
+long long l2 = 2000.0;
+double d1 = -10000.0;
+double d2 = -20000.0;
+
+void f (void)
+{
+  c1 = h1;
+  h2 = c2;
+
+  h1 = s1;
+  s2 = h2;
+
+  i1 = h1;
+  h2 = i2;
+
+  h1 = l1;
+  l2 = h2;
+  
+  d1 = h1;
+  h2 = d2;
+}
+
+/* Make sure we are not falling through to undefined libcalls.  */
+/* { dg-final { scan-assembler-not "__float.ihf" } } */
+/* { dg-final { scan-assembler-not "__fixhf.i" } } */
+/* { dg-final { scan-assembler-not "__trunc.fhf" } } */
+/* { dg-final { scan-assembler-not "__extendhf.f" } } */
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-alt.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-alt.c
new file mode 100644
index 000000000..bcd7aeff1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-alt.c
@@ -0,0 +1,17 @@
+/* Test floating-point conversions.  Standard types and __fp16.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+#include "fp-int-convert.h"
+#define FP16_MANT_DIG 11
+
+int
+main (void)
+{
+  TEST_I_F(signed char, unsigned char, float, FP16_MANT_DIG);
+  TEST_I_F(signed short, unsigned short, float, FP16_MANT_DIG);
+  TEST_I_F(signed int, unsigned int, float, FP16_MANT_DIG);
+  TEST_I_F(signed long, unsigned long, float, FP16_MANT_DIG);
+  TEST_I_F(signed long long, unsigned long long, float, FP16_MANT_DIG);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-ieee.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-ieee.c
new file mode 100644
index 000000000..1314d4b0e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-int-convert-ieee.c
@@ -0,0 +1,17 @@
+/* Test floating-point conversions.  Standard types and __fp16.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+#include "fp-int-convert.h"
+#define FP16_MANT_DIG 11
+
+int
+main (void)
+{
+  TEST_I_F(signed char, unsigned char, float, FP16_MANT_DIG);
+  TEST_I_F(signed short, unsigned short, float, FP16_MANT_DIG);
+  TEST_I_F(signed int, unsigned int, float, FP16_MANT_DIG);
+  TEST_I_F(signed long, unsigned long, float, FP16_MANT_DIG);
+  TEST_I_F(signed long long, unsigned long long, float, FP16_MANT_DIG);
+  exit (0);
+}
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-1.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-1.c
new file mode 100644
index 000000000..0c601e68c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-1.c
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+#include "arm-fp16-ops.h"
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-2.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-2.c
new file mode 100644
index 000000000..244e31082
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-2.c
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+
+#include "arm-fp16-ops.h"
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-3.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-3.c
new file mode 100644
index 000000000..8f9ab64bc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-3.c
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+#include "arm-fp16-ops.h"
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-4.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-4.c
new file mode 100644
index 000000000..4877f392c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-4.c
@@ -0,0 +1,5 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do run { target arm*-*-* } } */
+/* { dg-options "-mfp16-format=alternative -ffast-math" } */
+
+#include "arm-fp16-ops.h"
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c
new file mode 100644
index 000000000..98a1230a7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c
@@ -0,0 +1,17 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_fp16_ok } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-add-options arm_neon_fp16 } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, including fp16 support, so
+   we should not see any calls to libfuncs here.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_h2f" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_f2h" } } */
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c
new file mode 100644
index 000000000..bd2f4db7b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c
@@ -0,0 +1,17 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_fp16_ok } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+/* { dg-add-options arm_neon_fp16 } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, including fp16 support, so
+   we should not see any calls to libfuncs here.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_h2f" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_f2h" } } */
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-7.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-7.c
new file mode 100644
index 000000000..ed8089bd6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-7.c
@@ -0,0 +1,13 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, so we should not see any 
+   calls to libfuncs here except for those to the conversion functions.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-8.c b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-8.c
new file mode 100644
index 000000000..b138ca187
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-8.c
@@ -0,0 +1,13 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+/* { dg-do compile { target arm*-*-* } } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mfp16-format=ieee -ffast-math" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm-fp16-ops.h"
+
+/* We've specified options for hardware float, so we should not see any 
+   calls to libfuncs here except for those to the conversion functions.  */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf2" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__.*hf3" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
diff --git a/gcc/testsuite/gcc.dg/torture/arm-fp16-ops.h b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops.h
new file mode 100644
index 000000000..320494ee7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/arm-fp16-ops.h
@@ -0,0 +1,135 @@
+/* Test various operators on __fp16 and mixed __fp16/float operands.  */
+
+#include <assert.h>
+
+#define CHECK(e,r) assert ((e) == r)
+#define CHECK2(e,r) (assert ((e) == r), temp = (e), assert (temp == r))
+#define TEST(e) assert (e)
+#define TESTNOT(e) assert (!(e))
+
+volatile __fp16 h0 = 0.0;
+volatile __fp16 h1 = 1.0;
+volatile __fp16 h42 = 42.0;
+volatile __fp16 hm2 = -2.0;
+volatile __fp16 temp;
+
+volatile float f0 = 0.0;
+volatile float f1 = 1.0;
+volatile float f42 = 42.0;
+volatile float fm2 = -2.0;
+
+int main (void)
+{
+  TEST (h1);
+  TESTNOT (h0);
+  TEST (!h0);
+  TESTNOT (!h1);
+
+  CHECK2 (-h1, -1.0);
+  CHECK2 (+h1, 1.0);
+
+  CHECK (h1++, 1.0);
+  CHECK (h1, 2.0);
+  CHECK (++h1, 3.0);
+  CHECK (h1, 3.0);
+
+  CHECK (--h1, 2.0);
+  CHECK (h1, 2.0);
+  CHECK (h1--, 2.0);
+  CHECK (h1, 1.0);
+
+  CHECK2 (h42 * hm2, -84.0);
+  CHECK2 (h42 * (__fp16) -2.0, -84.0);
+  CHECK2 (h42 * fm2, -84.0);
+  CHECK2 (f42 * hm2, -84.0);
+
+  CHECK2 (h42 / hm2, -21.0);
+  CHECK2 (h42 / (__fp16) -2.0, -21.0);
+  CHECK2 (h42 / fm2, -21.0);
+  CHECK2 (f42 / hm2, -21.0);
+
+  CHECK2 (hm2 + h42, 40.0);
+  CHECK2 ((__fp16)-2.0 + h42, 40.0);
+  CHECK2 (hm2 + f42, 40.0);
+  CHECK2 (fm2 + h42, 40.0);
+
+  CHECK2 (hm2 - h42, -44.0);
+  CHECK2 ((__fp16)-2.0 - h42, -44.0);
+  CHECK2 (hm2 - f42, -44.0);
+  CHECK2 (fm2 - h42, -44.0);
+
+  TEST (hm2 < h42);
+  TEST (hm2 < (__fp16)42.0);
+  TEST (hm2 < f42);
+  TEST (fm2 < h42);
+
+  TEST (h42 > hm2);
+  TEST ((__fp16)42.0 > hm2);
+  TEST (h42 > fm2);
+  TEST (f42 > hm2);
+
+  TEST (hm2 <= h42);
+  TEST (hm2 <= (__fp16)42.0);
+  TEST (hm2 <= f42);
+  TEST (fm2 <= h42);
+
+  TEST (h42 >= hm2);
+  TEST (h42 >= (__fp16)-2.0);
+  TEST (h42 >= fm2);
+  TEST (f42 >= hm2);
+
+  TESTNOT (h1 == hm2);
+  TEST (h1 == h1);
+  TEST (h1 == (__fp16)1.0);
+  TEST (h1 == f1);
+  TEST (f1 == h1);
+
+  TEST (h1 != hm2);
+  TESTNOT (h1 != h1);
+  TESTNOT (h1 != (__fp16)1.0);
+  TESTNOT (h1 != f1);
+  TESTNOT (f1 != h1);
+
+  CHECK2 ((h1 ? hm2 : h42), -2.0);
+  CHECK2 ((h0 ? hm2 : h42), 42.0);
+
+  CHECK (h0 = h42, 42.0);
+  CHECK (h0, 42.0);
+  CHECK (h0 = (__fp16)-2.0, -2.0);
+  CHECK (h0, -2.0);
+  CHECK (h0 = f0, 0.0);
+  CHECK (h0, 0.0);
+
+  CHECK (h0 += h1, 1.0);
+  CHECK (h0, 1.0);
+  CHECK (h0 += (__fp16)1.0, 2.0);
+  CHECK (h0, 2.0);
+  CHECK (h0 += fm2, 0.0);
+  CHECK (h0, 0.0);
+
+  CHECK (h0 -= h1, -1.0);
+  CHECK (h0, -1.0);
+  CHECK (h0 -= (__fp16)1.0, -2.0);
+  CHECK (h0, -2.0);
+  CHECK (h0 -= fm2, 0.0);
+  CHECK (h0, 0.0);
+
+  h0 = hm2;
+  CHECK (h0 *= hm2, 4.0);
+  CHECK (h0, 4.0);
+  CHECK (h0 *= (__fp16)-2.0, -8.0);
+  CHECK (h0, -8.0);
+  CHECK (h0 *= fm2, 16.0);
+  CHECK (h0, 16.0);
+
+  CHECK (h0 /= hm2, -8.0);
+  CHECK (h0, -8.0);
+  CHECK (h0 /= (__fp16)-2.0, 4.0);
+  CHECK (h0, 4.0);
+  CHECK (h0 /= fm2, -2.0);
+  CHECK (h0, -2.0);
+
+  CHECK ((h0, h1), 1.0);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/type-generic-1.c b/gcc/testsuite/gcc.dg/torture/type-generic-1.c
index 96b5d01e5..8a669d12d 100644
--- a/gcc/testsuite/gcc.dg/torture/type-generic-1.c
+++ b/gcc/testsuite/gcc.dg/torture/type-generic-1.c
@@ -3,6 +3,7 @@
 
 /* { dg-do run } */
 /* { dg-options "-mieee" { target alpha*-*-* sh*-*-* } } */
+/* { dg-options "-Wl,--defsym=__cs3_mips_float_type=2 -lcs3-mips-cp1 -lcs3-mips-fpemu" { target mips*-*sde*-* } } */
 /* { dg-skip-if "No Inf/NaN support" { spu-*-* } } */
 
 #include "../tg-tests.h"
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c
index e7cb925e8..ee7cf02c6 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c
@@ -47,9 +47,11 @@ int main_1 (int n, int *p)
   return 0;
 }
 
-int main (int n)
+static volatile int n = 1;
+
+int main (void)
 {
-  return main_1 (n + 2, &n);
+  return main_1 (n + 2, (int *) &n);
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c
index 77623919e..33814da2a 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-28.c
@@ -9,7 +9,7 @@
 
 /* unaligned store.  */
 
-int main (int off)
+int main_1 (int off)
 {
   int i;
   char ia[N+OFF];
@@ -29,6 +29,13 @@ int main (int off)
   return 0;
 }
 
+static volatile int off = 1;
+
+int main (void)
+{
+  return main_1 (off);
+}
+
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/loop-31.c b/gcc/testsuite/gcc.dg/tree-ssa/loop-31.c
index cf5843ca7..1623b5548 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/loop-31.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/loop-31.c
@@ -15,5 +15,5 @@ short foo (int len, int v)
 
 /* When we do not have addressing mode including multiplication,
    the memory access should be strength-reduced.  */
-/* { dg-final { scan-tree-dump-times " \\+ 2" 1 "optimized" { target arm-*-* ia64-*-* } } } */
+/* { dg-final { scan-tree-dump-times " \\+ 2" 1 "optimized" { target arm*-*-* ia64-*-* } } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c b/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c
index 34f4a01db..117d2173f 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-vrp1-details" } */
+/* { dg-options "-O2 -fdump-tree-vrp1-details -fno-remove-local-statics" } */
 
 static int blocksize = 4096;
 
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c b/gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c
index d5002346e..1b126fd5c 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details" } */
+/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details --param max-unroll-times=3" } */
 
 int a[1000], b[1000];
 
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c b/gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c
index 6f06b7f8b..dd6223cfe 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-do run } */
-/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details" } */
+/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details --param max-unroll-times=3" } */
 
 /* Test for predictive commoning of expressions, without reassociation.  */
 
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c b/gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c
index 134fc3765..adf7cfe93 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-do run } */
-/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details" } */
+/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details --param max-unroll-times=3" } */
 
 /* Test for predictive commoning of expressions, with reassociation.  */
 
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c b/gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c
index 674fd4d67..c404df2bf 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c
@@ -1,6 +1,7 @@
 /* { dg-do compile { target i?86-*-* x86_64-*-* } } */
 /* { dg-require-effective-target ilp32 } */
 /* { dg-require-effective-target sse2 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=athlon" } } */
 /* { dg-options "-O2 -fprefetch-loop-arrays -march=athlon -msse2 -mfpmath=sse --param simultaneous-prefetches=100 --param max-unrolled-insns=1 -fdump-tree-aprefetch-details -fdump-tree-final_cleanup" } */
 
 #define K 1000000
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c b/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c
index 3d020067c..232cfca2f 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-dse1" } */
+/* { dg-options "-O2 -fdump-tree-dse1 -fno-remove-local-statics" } */
 
 int foo11 (int c)
 {
diff --git a/gcc/testsuite/gcc.dg/utf-array-short-wchar.c b/gcc/testsuite/gcc.dg/utf-array-short-wchar.c
index 55d164fc2..ec478121a 100644
--- a/gcc/testsuite/gcc.dg/utf-array-short-wchar.c
+++ b/gcc/testsuite/gcc.dg/utf-array-short-wchar.c
@@ -1,6 +1,7 @@
 /* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */
 /* Expected errors for char16_t/char32_t string literals. */
 /* { dg-do compile } */
+/* { dg-require-effective-target wchar } */
 /* { dg-options "-std=gnu99 -fshort-wchar" } */
 
 #include <wchar.h>
diff --git a/gcc/testsuite/gcc.dg/utf-array.c b/gcc/testsuite/gcc.dg/utf-array.c
index bbe0976a5..433ddcfaf 100644
--- a/gcc/testsuite/gcc.dg/utf-array.c
+++ b/gcc/testsuite/gcc.dg/utf-array.c
@@ -1,6 +1,7 @@
 /* Contributed by Kris Van Hees <kris.van.hees@oracle.com> */
 /* Expected errors for char16_t/char32_t string literals. */
 /* { dg-do compile } */
+/* { dg-require-effective-target wchar } */
 /* { dg-options "-std=gnu99" } */
 
 #include <wchar.h>
diff --git a/gcc/testsuite/gcc.dg/vect/aligned-section-anchors-nest-1.c b/gcc/testsuite/gcc.dg/vect/aligned-section-anchors-nest-1.c
new file mode 100644
index 000000000..670e45491
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/aligned-section-anchors-nest-1.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target section_anchors } */
+/* { dg-require-effective-target vect_int } */
+
+#include <stdarg.h>
+#include "tree-vect.h"
+
+#define N 32
+
+static int a[N][N];
+static int b[N][N];
+static int c[N][N];
+
+void clobber(int *);
+
+int *foo(void)
+{
+  int i;
+  int j;
+
+  clobber (&a[0][0]);
+  clobber (&b[0][0]);
+  clobber (&c[0][0]);
+
+  for (i = 0; i < N; i++) {
+      for (j = 0; j < N; j++) {
+	  c[j][i] += a[j][i] + c[j][i];
+      }
+  }
+  return &c[0][0];
+}
+
+/* { dg-final { scan-ipa-dump-times "Increasing alignment of decl" 3 "increase_alignment" } } */
+/* { dg-final { cleanup-ipa-dump "increase_alignment" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c
index 21b87a396..373384f2d 100644
--- a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c
+++ b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c
@@ -88,5 +88,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c
index 1ce3fa7f2..6679fb2f6 100644
--- a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c
+++ b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c
@@ -84,5 +84,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c
index d590975e5..0e338ba0c 100644
--- a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c
+++ b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-66.c
@@ -79,5 +79,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c
index de036e88e..e38acf27c 100644
--- a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c
+++ b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c
@@ -88,5 +88,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c
index c63ae2fd2..c78017c2e 100644
--- a/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c
+++ b/gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c
@@ -114,7 +114,7 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 4 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail {! vector_alignment_reachable} } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_element_align || {! vector_alignment_reachable} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target {! vector_alignment_reachable} } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target {! vector_alignment_reachable} } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { { ! vector_alignment_reachable } && { ! vect_element_align } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c b/gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c
index 7b5ce7348..13c86392a 100644
--- a/gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c
+++ b/gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c
@@ -115,6 +115,6 @@ int main (void)
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
 /* Alignment forced using versioning until the pass that increases alignment
   is extended to handle structs.  */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 4 "vect" { target {vect_int && vector_alignment_reachable } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 4 "vect" { target { {vect_int && vector_alignment_reachable } && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 4 "vect" { target {vect_int && {! vector_alignment_reachable} } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/slp-25.c b/gcc/testsuite/gcc.dg/vect/slp-25.c
index 23022fd2b..f0b7f2e3b 100644
--- a/gcc/testsuite/gcc.dg/vect/slp-25.c
+++ b/gcc/testsuite/gcc.dg/vect/slp-25.c
@@ -56,5 +56,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-109.c b/gcc/testsuite/gcc.dg/vect/vect-109.c
index d4e017f1f..74de99f02 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-109.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-109.c
@@ -73,6 +73,6 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 2 "vect" } } */
-/* { dg-final { scan-tree-dump-times "not vectorized: unsupported unaligned store" 2 "vect" } } */
+/* { dg-final { scan-tree-dump-times "not vectorized: unsupported unaligned store" 2 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-26.c b/gcc/testsuite/gcc.dg/vect/vect-26.c
index 3cb9fb674..3ad3a3785 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-26.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-26.c
@@ -37,5 +37,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-27.c b/gcc/testsuite/gcc.dg/vect/vect-27.c
index 4a2da227e..cb84d258b 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-27.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-27.c
@@ -45,6 +45,6 @@ int main (void)
 /* The initialization induction loop (with aligned access) is also vectorized.  */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-28.c b/gcc/testsuite/gcc.dg/vect/vect-28.c
index e698eef93..5d4911802 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-28.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-28.c
@@ -40,6 +40,6 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { ! vector_alignment_reachable } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-29.c b/gcc/testsuite/gcc.dg/vect/vect-29.c
index 0ad284880..136fac5c7 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-29.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-29.c
@@ -50,7 +50,7 @@ int main (void)
 
 /* The initialization induction loop (with aligned access) is also vectorized.  */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" {target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-33.c b/gcc/testsuite/gcc.dg/vect/vect-33.c
index c1e89c44c..ba10adc00 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-33.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-33.c
@@ -39,6 +39,6 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { ! vector_alignment_reachable } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-42.c b/gcc/testsuite/gcc.dg/vect/vect-42.c
index 324e2f8da..35e4a4a90 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-42.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-42.c
@@ -57,6 +57,6 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { vect_no_align || { ! vector_alignment_reachable } } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || { ! vector_alignment_reachable } } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail {vect_no_align || { ! vector_alignment_reachable } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { { vect_no_align || vect_element_align } || { ! vector_alignment_reachable } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align || vect_element_align } || { ! vector_alignment_reachable } } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-44.c b/gcc/testsuite/gcc.dg/vect/vect-44.c
index d80df10bf..f4d9b3f78 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-44.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-44.c
@@ -65,8 +65,8 @@ int main (void)
    two loads to be aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align || vect_element_align } || {! vector_alignment_reachable} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { {! vector_alignment_reachable} && {! vect_no_align} } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-48.c b/gcc/testsuite/gcc.dg/vect/vect-48.c
index 011b86863..475f5024c 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-48.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-48.c
@@ -54,7 +54,7 @@ int main (void)
    (The store is aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect"  } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-50.c b/gcc/testsuite/gcc.dg/vect/vect-50.c
index ea4d7ff47..aee9ae0ee 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-50.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-50.c
@@ -61,8 +61,8 @@ int main (void)
    two loads to be aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { { vect_no_align || vect_element_align } || {! vector_alignment_reachable} } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" { target vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 1 "vect" { target { {! vector_alignment_reachable} && {! vect_no_align} } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-52.c b/gcc/testsuite/gcc.dg/vect/vect-52.c
index 207e7007c..38cf80c8b 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-52.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-52.c
@@ -55,7 +55,7 @@ int main (void)
    (The store is aligned).  */
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 2 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-54.c b/gcc/testsuite/gcc.dg/vect/vect-54.c
index 6e1aa549a..0e8178f97 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-54.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-54.c
@@ -59,5 +59,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-56.c b/gcc/testsuite/gcc.dg/vect/vect-56.c
index 387bd3ab8..7e4b0382b 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-56.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-56.c
@@ -67,6 +67,6 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-58.c b/gcc/testsuite/gcc.dg/vect/vect-58.c
index 94cc3efa4..a3ca3d609 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-58.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-58.c
@@ -58,5 +58,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-60.c b/gcc/testsuite/gcc.dg/vect/vect-60.c
index 97e614c06..0e8df4024 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-60.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-60.c
@@ -68,6 +68,6 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-70.c b/gcc/testsuite/gcc.dg/vect/vect-70.c
index df7de31f3..c8a149d8a 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-70.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-70.c
@@ -64,6 +64,6 @@ int main (void)
           
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" {target {! vector_alignment_reachable} } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-72.c b/gcc/testsuite/gcc.dg/vect/vect-72.c
index 67a197519..983555cb9 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-72.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-72.c
@@ -46,6 +46,6 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-75.c b/gcc/testsuite/gcc.dg/vect/vect-75.c
index 03c1868e4..7f1e27a99 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-75.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-75.c
@@ -45,5 +45,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-87.c b/gcc/testsuite/gcc.dg/vect/vect-87.c
index 20a0d2ded..e710597b9 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-87.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-87.c
@@ -51,6 +51,6 @@ int main (void)
 /* Fails for targets that don't vectorize PLUS (e.g alpha).  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" {target {! vector_alignment_reachable} } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-88.c b/gcc/testsuite/gcc.dg/vect/vect-88.c
index 8c231c092..ebe041874 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-88.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-88.c
@@ -51,6 +51,6 @@ int main (void)
 /* Fails for targets that don't vectorize PLUS (e.g alpha).  */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" {target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" {target {! vector_alignment_reachable} } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-89.c b/gcc/testsuite/gcc.dg/vect/vect-89.c
index 131efeab5..4589e4c9f 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-89.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-89.c
@@ -46,5 +46,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-91.c b/gcc/testsuite/gcc.dg/vect/vect-91.c
index 750736324..99619da2a 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-91.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-91.c
@@ -59,6 +59,6 @@ main3 ()
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" { xfail vect_no_int_add } } } */
 /* { dg-final { scan-tree-dump-times "accesses have the same alignment." 3 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" {target vector_alignment_reachable } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" {target { vector_alignment_reachable && { ! vect_element_align } } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" {target {! vector_alignment_reachable} } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-92.c b/gcc/testsuite/gcc.dg/vect/vect-92.c
index 94fff9800..13dee73c8 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-92.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-92.c
@@ -92,5 +92,5 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 3 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-93.c b/gcc/testsuite/gcc.dg/vect/vect-93.c
index b2245c85a..b0a6ea440 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-93.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-93.c
@@ -72,7 +72,7 @@ int main (void)
 /* main && main1 together: */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 2 "vect" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target { vect_no_align && {! vector_alignment_reachable} } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" { xfail { { vect_no_align || vect_element_align } || {! vector_alignment_reachable} } } } } */
 
 /* in main1: */
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target !powerpc*-*-* !i?86-*-* !x86_64-*-* } } } */
@@ -80,6 +80,6 @@ int main (void)
 
 /* in main: */
 /* { dg-final { scan-tree-dump-times "vectorized 0 loops" 1 "vect" { target vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-95.c b/gcc/testsuite/gcc.dg/vect/vect-95.c
index aeb5042ec..dc1204e87 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-95.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-95.c
@@ -62,8 +62,8 @@ int main (void)
    stores and generate misaligned accesses for the loads. For targets that 
    don't support unaligned loads we version for all four accesses.  */
 
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /*  { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target vect_no_align } } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 4 "vect" { target vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-align-2.c b/gcc/testsuite/gcc.dg/vect/vect-align-2.c
index ec2f3eefb..7517ad327 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-align-2.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-align-2.c
@@ -43,6 +43,6 @@ int main (void)
 
 
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 1 "vect" { target { ! vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c
index 2ebececc8..d8dab63e3 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c
@@ -78,11 +78,11 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail { ! vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c
index 22711aa0a..bfd34952b 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-3.c
@@ -54,6 +54,6 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 3 "vect" { target vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" {xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 3 "vect" {xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c
index 7ac336723..0069e7575 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c
@@ -85,11 +85,11 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 2 "vect" { xfail { ! vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 8 "vect" { xfail *-*-* } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 4 "vect" { xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c b/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
index 56bba706b..f81c19114 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-multitypes-6.c
@@ -61,6 +61,6 @@ int main (void)
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { sparc*-*-* && ilp32 } }} } */
 /*  { dg-final { scan-tree-dump-times "Alignment of access forced using versioning" 6 "vect" { target vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 6 "vect" {xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 6 "vect" {xfail { vect_no_align || vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/vect-shift-2.c b/gcc/testsuite/gcc.dg/vect/vect-shift-2.c
new file mode 100644
index 000000000..e705feadd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/vect-shift-2.c
@@ -0,0 +1,37 @@
+/* { dg-require-effective-target vect_shift_char } */
+/* { dg-require-effective-target vect_int } */
+
+#include "tree-vect.h"
+
+#define N 32
+
+unsigned char dst[N] __attribute__((aligned(N)));
+unsigned char src[N] __attribute__((aligned(N)));
+
+__attribute__ ((noinline))
+void array_shift(void)
+{
+  int i;
+  for (i = 0; i < N; i++)
+    dst[i] = src[i] >> 3;
+}
+
+int main()
+{
+  volatile int i;
+  check_vect ();
+
+  for (i = 0; i < N; i++)
+    src[i] = i << 3;
+
+  array_shift ();
+
+  for (i = 0; i < N; i++)
+    if (dst[i] != i)
+      abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect-shift-3.c b/gcc/testsuite/gcc.dg/vect/vect-shift-3.c
new file mode 100644
index 000000000..78ed935ae
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/vect-shift-3.c
@@ -0,0 +1,37 @@
+/* { dg-require-effective-target vect_shift } */
+/* { dg-require-effective-target vect_int } */
+
+#include "tree-vect.h"
+
+#define N 32
+
+unsigned short dst[N] __attribute__((aligned(N)));
+unsigned short src[N] __attribute__((aligned(N)));
+
+__attribute__ ((noinline))
+void array_shift(void)
+{
+  int i;
+  for (i = 0; i < N; i++)
+    dst[i] = src[i] >> 3;
+}
+
+int main()
+{
+  volatile int i;
+  check_vect ();
+
+  for (i = 0; i < N; i++)
+    src[i] = i << 3;
+
+  array_shift ();
+
+  for (i = 0; i < N; i++)
+    if (dst[i] != i)
+      abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect.exp b/gcc/testsuite/gcc.dg/vect/vect.exp
index 224ea6447..846d9ae39 100644
--- a/gcc/testsuite/gcc.dg/vect/vect.exp
+++ b/gcc/testsuite/gcc.dg/vect/vect.exp
@@ -100,7 +100,7 @@ if  [istarget "powerpc-*paired*"]  {
 } elseif [istarget "ia64-*-*"] {
     set dg-do-what-default run
 } elseif [is-effective-target arm_neon_ok] {
-    lappend DEFAULT_VECTCFLAGS "-mfpu=neon" "-mfloat-abi=softfp"
+    eval lappend DEFAULT_VECTCFLAGS [add_options_for_arm_neon ""]
     if [is-effective-target arm_neon_hw] {
       set dg-do-what-default run
     } else {
@@ -186,6 +186,12 @@ lappend DEFAULT_VECTCFLAGS "-fsection-anchors"
 dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/section-anchors-*.\[cS\]]]  \
 	"" $DEFAULT_VECTCFLAGS
 
+# alignment-sensitive -fsection-anchors tests
+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS
+lappend DEFAULT_VECTCFLAGS "-fsection-anchors" "-fdump-ipa-increase_alignment"
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/aligned-section-anchors-*.\[cS\]]]  \
+	"" $DEFAULT_VECTCFLAGS
+
 # -fno-section-anchors tests
 set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS
 lappend DEFAULT_VECTCFLAGS "-fno-section-anchors"
diff --git a/gcc/testsuite/gcc.misc-tests/i386-prefetch.exp b/gcc/testsuite/gcc.misc-tests/i386-prefetch.exp
index e9909845c..a9f767cde 100644
--- a/gcc/testsuite/gcc.misc-tests/i386-prefetch.exp
+++ b/gcc/testsuite/gcc.misc-tests/i386-prefetch.exp
@@ -90,6 +90,13 @@ load_lib torture-options.exp
 dg-init
 torture-init
 
+if { [board_info target exists multilib_flags]
+     && [string match "* -march=*" " [board_info target multilib_flags] "] } {
+    # Multilib flags come after the -march flags we pass and override
+    # them, so skip these tests when such flags are passed.
+    return
+}
+
 set-torture-options $PREFETCH_NONE
 gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/i386-pf-none-*.c]] ""
 
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/aapcs.exp b/gcc/testsuite/gcc.target/arm/aapcs/aapcs.exp
new file mode 100644
index 000000000..fcc433346
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/aapcs.exp
@@ -0,0 +1,35 @@
+# Copyright (C) 1997, 2004, 2006, 2007 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Exit immediately if this isn't an ARM target.
+if ![istarget arm*-*-*] then {
+  return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cCS\]]] \
+	"" ""
+
+# All done.
+dg-finish
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/abitest.h b/gcc/testsuite/gcc.target/arm/aapcs/abitest.h
new file mode 100644
index 000000000..f6474a988
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/abitest.h
@@ -0,0 +1,118 @@
+#define IN_FRAMEWORK
+
+#ifdef VFP
+#define D0	0
+#define D1	8
+#define D2	16
+#define D3	24
+#define D4	32
+#define D5	40
+#define D6	48
+#define D7	56
+
+#define S0	64
+#define S1	68
+#define S2	72
+#define S3	76
+#define S4	80
+#define S5	84
+#define S6	88
+#define S7	92
+#define S8      86
+#define S9	100
+#define S10	104
+#define S11	108
+#define S12	112
+#define S13	116
+#define S14	120
+#define S15	124
+
+#define R0	128
+#define R1	132
+#define R2	136
+#define R3	140
+
+#define STACK	144
+
+#else
+
+#define R0	0
+#define R1	4
+#define R2	8
+#define R3	12
+
+#define STACK   16
+
+#endif
+
+extern void abort (void);
+
+__attribute__((naked))  void dumpregs () __asm("myfunc");
+__attribute__((naked))  void dumpregs ()
+{
+  asm(
+      "mov	ip, sp\n\t"
+      "stmfd	sp!, {r0-r3}\n\t"
+#ifdef VFP
+      "fstmdbs	sp!, {s0-s15}\n\t"
+      "fstmdbd	sp!, {d0-d7}\n\t"
+#endif
+      "mov	r0, sp\n\t"
+      "stmfd	sp!, {ip, r14}\n\t"
+      "bl	testfunc\n\t"
+      "ldmfd	sp!, {r0, r14}\n\t"
+      "mov	sp, r0\n\t"
+      "bx	lr");
+}
+
+
+#define LAST_ARG(type,val,offset) { type __x = val; if (memcmp(&__x, stack+offset, sizeof(type)) != 0) abort(); }
+#define ARG(type,val,offset) LAST_ARG(type, val, offset)
+#define ANON(type,val,offset) LAST_ARG(type, val, offset)
+#define LAST_ANON(type,val,offset) LAST_ARG(type, val, offset)
+#define DOTS
+
+void testfunc(char* stack)
+{
+#include TESTFILE
+  return;
+}
+
+#undef LAST_ARG
+#undef ARG
+#undef DOTS
+#undef ANON
+#undef LAST_ANON
+#define LAST_ARG(type,val,offset) type
+#define ARG(type,val,offset) LAST_ARG(type, val, offset),
+#define DOTS ...
+#define ANON(type,val, offset)
+#define LAST_ANON(type,val, offset)
+
+#ifndef MYFUNCTYPE
+#define MYFUNCTYPE void
+#endif
+
+MYFUNCTYPE myfunc(
+#include TESTFILE
+);
+
+#undef LAST_ARG
+#undef ARG
+#undef DOTS
+#undef ANON
+#undef LAST_ANON
+#define LAST_ARG(type,val,offset) val
+#define ARG(type,val,offset) LAST_ARG(type, val, offset),
+#define DOTS
+#define LAST_ANON(type,val,offset) LAST_ARG(type, val, offset)
+#define ANON(type,val,offset) LAST_ARG(type, val, offset),
+
+
+int main()
+{
+  myfunc(
+#include TESTFILE
+);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp1.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp1.c
new file mode 100644
index 000000000..380a3244d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp1.c
@@ -0,0 +1,17 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp1.c"
+#include "abitest.h"
+
+#else
+  ARG(int, 4, R0)
+  ARG(double, 4.0, D0)
+  LAST_ARG(int, 3, R1)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp10.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp10.c
new file mode 100644
index 000000000..58561aac9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp10.c
@@ -0,0 +1,38 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp10.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  /* A variadic function passes using the base ABI */
+  ARG(double, 11.0, R0)
+  DOTS
+  ANON(struct z, a, R2)
+  ANON(struct z, b, STACK+24)
+  LAST_ANON(double, 0.5, STACK+56)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp11.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp11.c
new file mode 100644
index 000000000..2c143bafb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp11.c
@@ -0,0 +1,39 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp11.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#define MYFUNCTYPE struct y
+
+#include "abitest.h"
+#else
+  ARG(int, 7, R1)
+  ARG(struct y, v, R2)
+  ARG(struct z, a, D0)
+  ARG(struct z, b, D4)
+  LAST_ARG(double, 0.5, STACK+8)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp12.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp12.c
new file mode 100644
index 000000000..7b6b4cd54
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp12.c
@@ -0,0 +1,38 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp12.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  ARG(int, 7, R0)
+  ARG(struct y, v, R1)
+  ARG(struct z, a, D0)
+  ARG(double, 1.0, D4)
+  ARG(struct z, b, STACK+8)
+  LAST_ARG(double, 0.5, STACK+40)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp13.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp13.c
new file mode 100644
index 000000000..ca0c5be7c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp13.c
@@ -0,0 +1,39 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp13.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  ARG(int, 7, R0)
+  ARG(int, 9, R1)
+  ARG(struct z, a, D0)
+  ARG(double, 1.0, D4)
+  ARG(struct z, b, STACK)
+  ARG(int, 4, R2)
+  LAST_ARG(double, 0.5, STACK+32)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp14.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp14.c
new file mode 100644
index 000000000..b5131d7fc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp14.c
@@ -0,0 +1,24 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp14.c"
+
+#include "abitest.h"
+#else
+  ARG(double, 1.0, D0)
+  ARG(double, 2.0, D1)
+  ARG(double, 3.0, D2)
+  ARG(double, 4.0, D3)
+  ARG(double, 5.0, D4)
+  ARG(double, 6.0, D5)
+  ARG(double, 7.0, D6)
+  ARG(double, 8.0, D7)
+  ARG(double, 9.0, STACK)
+  LAST_ARG(double, 10.0, STACK+8)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp2.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp2.c
new file mode 100644
index 000000000..a2db349e4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp2.c
@@ -0,0 +1,19 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp2.c"
+#include "abitest.h"
+
+#else
+  ARG(float, 1.0f, S0)
+  ARG(double, 4.0, D1)
+  ARG(float, 2.0f, S1)
+  ARG(double, 5.0, D2)
+  LAST_ARG(int, 3, R0)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp3.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp3.c
new file mode 100644
index 000000000..807292b57
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp3.c
@@ -0,0 +1,21 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp3.c"
+
+__complex__ x = 1.0+2.0i;
+
+#include "abitest.h"
+#else
+  ARG(float, 1.0f, S0)
+  ARG(__complex__ double, x, D1)
+  ARG(float, 2.0f, S1)
+  ARG(double, 5.0, D3)
+  LAST_ARG(int, 3, R0)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp4.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp4.c
new file mode 100644
index 000000000..8bb2a5678
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp4.c
@@ -0,0 +1,20 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp4.c"
+
+__complex__ float x = 1.0f + 2.0fi;
+#include "abitest.h"
+#else
+  ARG(float, 1.0f, S0)
+  ARG(__complex__ float, x, S1)
+  ARG(float, 2.0f, S3)
+  ARG(double, 5.0, D2)
+  LAST_ARG(int, 3, R0)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp5.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp5.c
new file mode 100644
index 000000000..0adc17fde
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp5.c
@@ -0,0 +1,30 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp5.c"
+
+__complex__ float x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+#include "abitest.h"
+#else
+  ARG(float, 1.0f, S0)
+  ARG(__complex__ float, x, S1)
+  ARG(float, 2.0f, S3)
+  ARG(double, 5.0, D2)
+  ARG(struct y, v, R0)
+  LAST_ARG(int, 3, STACK)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp6.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp6.c
new file mode 100644
index 000000000..6d8df0d62
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp6.c
@@ -0,0 +1,30 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp6.c"
+
+__complex__ float x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+#include "abitest.h"
+#else
+  ARG(struct y, v, R0)
+  ARG(float, 1.0f, S0)
+  ARG(__complex__ float, x, S1)
+  ARG(float, 2.0f, S3)
+  ARG(double, 5.0, D2)
+  LAST_ARG(int, 3, STACK)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp7.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp7.c
new file mode 100644
index 000000000..de4bdb4c4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp7.c
@@ -0,0 +1,37 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp7.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  ARG(struct z, a, D0)
+  ARG(struct z, b, D4)
+  ARG(double, 0.5, STACK)
+  ARG(int, 7, R0)
+  LAST_ARG(struct y, v, STACK+8)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp8.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp8.c
new file mode 100644
index 000000000..7865844eb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp8.c
@@ -0,0 +1,37 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp8.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  ARG(int, 7, R0)
+  ARG(struct y, v, R1)
+  ARG(struct z, a, D0)
+  ARG(struct z, b, D4)
+  LAST_ARG(double, 0.5, STACK+8)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/aapcs/vfp9.c b/gcc/testsuite/gcc.target/arm/aapcs/vfp9.c
new file mode 100644
index 000000000..f9aa2960c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/aapcs/vfp9.c
@@ -0,0 +1,38 @@
+/* Test AAPCS layout (VFP variant) */
+
+/* { dg-do run { target arm*-*-eabi* } } */
+/* { dg-require-effective-target arm_hard_vfp_ok } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O -mfpu=vfp -mfloat-abi=hard" } */
+
+#ifndef IN_FRAMEWORK
+#define VFP
+#define TESTFILE "vfp9.c"
+
+__complex__ x = 1.0+2.0i;
+
+struct y
+{
+  int p;
+  int q;
+  int r;
+  int s;
+} v = { 1, 2, 3, 4 };
+
+struct z
+{
+  double x[4];
+};
+
+struct z a = { 5.0, 6.0, 7.0, 8.0 };
+struct z b = { 9.0, 10.0, 11.0, 12.0 };
+
+#include "abitest.h"
+#else
+  /* A variadic function passes using the base ABI */
+  ARG(int, 7, R0)
+  DOTS
+  ANON(struct z, a, R2)
+  ANON(struct z, b, STACK+24)
+  LAST_ANON(double, 0.5, STACK+56)
+#endif
diff --git a/gcc/testsuite/gcc.target/arm/ctz.c b/gcc/testsuite/gcc.target/arm/ctz.c
new file mode 100644
index 000000000..63e9d0266
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/ctz.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm32 } */
+/* { dg-options "-O2 -march=armv6t2" } */
+
+unsigned int functest(unsigned int x)
+{
+	return __builtin_ctz(x);
+}
+
+/* { dg-final { scan-assembler "rbit" } } */
+/* { dg-final { scan-assembler "clz" } } */
+/* { dg-final { scan-assembler-not "rsb" } } */
diff --git a/gcc/testsuite/gcc.target/arm/eabi1.c b/gcc/testsuite/gcc.target/arm/eabi1.c
index e88ba021f..c90f5ff08 100644
--- a/gcc/testsuite/gcc.target/arm/eabi1.c
+++ b/gcc/testsuite/gcc.target/arm/eabi1.c
@@ -30,43 +30,48 @@
 #include <stdlib.h>
 #include <math.h>
 
-#define decl_float(code, type)					\
-  extern type __aeabi_ ## code ## add (type, type);		\
-  extern type __aeabi_ ## code ## div (type, type);		\
-  extern type __aeabi_ ## code ## mul (type, type);		\
-  extern type __aeabi_ ## code ## neg (type);			\
-  extern type __aeabi_ ## code ## rsub (type, type);		\
-  extern type __aeabi_ ## code ## sub (type, type);		\
-  extern int __aeabi_ ## code ## cmpeq (type, type);		\
-  extern int __aeabi_ ## code ## cmplt (type, type);		\
-  extern int __aeabi_ ## code ## cmple (type, type);		\
-  extern int __aeabi_ ## code ## cmpge (type, type);		\
-  extern int __aeabi_ ## code ## cmpgt (type, type);		\
-  extern int __aeabi_ ## code ## cmpun (type, type);		\
-  extern int __aeabi_ ## code ## 2iz (type);			\
-  extern unsigned int __aeabi_ ## code ## 2uiz (type);		\
-  extern long long __aeabi_ ## code ## 2lz (type);		\
-  extern unsigned long long __aeabi_ ## code ## 2ulz (type);	\
-  extern type __aeabi_i2 ## code (int);				\
-  extern type __aeabi_ui2 ## code (int);			\
-  extern type __aeabi_l2 ## code (long long);			\
-  extern type __aeabi_ul2 ## code (unsigned long long);		\
-								\
-  type code ## zero = 0.0;					\
-  type code ## one = 1.0;					\
-  type code ## two = 2.0;					\
-  type code ## four = 4.0;					\
-  type code ## minus_one = -1.0;				\
-  type code ## minus_two = -2.0;				\
-  type code ## minus_four = -4.0;				\
-  type code ## epsilon = 1E-32;					\
-  type code ## NaN = 0.0 / 0.0;				
+/* All these functions are defined to use the base ABI, so use the
+   attribute to ensure the tests use the base ABI to call them even
+   when the VFP ABI is otherwise in effect.  */
+#define PCS __attribute__((pcs("aapcs")))
+
+#define decl_float(code, type)						\
+  extern type __aeabi_ ## code ## add (type, type) PCS;			\
+  extern type __aeabi_ ## code ## div (type, type) PCS;			\
+  extern type __aeabi_ ## code ## mul (type, type) PCS;			\
+  extern type __aeabi_ ## code ## neg (type) PCS;			\
+  extern type __aeabi_ ## code ## rsub (type, type) PCS;		\
+  extern type __aeabi_ ## code ## sub (type, type) PCS;			\
+  extern int __aeabi_ ## code ## cmpeq (type, type) PCS;		\
+  extern int __aeabi_ ## code ## cmplt (type, type) PCS;		\
+  extern int __aeabi_ ## code ## cmple (type, type) PCS;		\
+  extern int __aeabi_ ## code ## cmpge (type, type) PCS;		\
+  extern int __aeabi_ ## code ## cmpgt (type, type) PCS;		\
+  extern int __aeabi_ ## code ## cmpun (type, type) PCS;		\
+  extern int __aeabi_ ## code ## 2iz (type) PCS;			\
+  extern unsigned int __aeabi_ ## code ## 2uiz (type) PCS;		\
+  extern long long __aeabi_ ## code ## 2lz (type) PCS;			\
+  extern unsigned long long __aeabi_ ## code ## 2ulz (type) PCS;	\
+  extern type __aeabi_i2 ## code (int) PCS;				\
+  extern type __aeabi_ui2 ## code (int) PCS;				\
+  extern type __aeabi_l2 ## code (long long) PCS;			\
+  extern type __aeabi_ul2 ## code (unsigned long long) PCS;		\
+									\
+  type code ## zero = 0.0;						\
+  type code ## one = 1.0;						\
+  type code ## two = 2.0;						\
+  type code ## four = 4.0;						\
+  type code ## minus_one = -1.0;					\
+  type code ## minus_two = -2.0;					\
+  type code ## minus_four = -4.0;					\
+  type code ## epsilon = 1E-32;						\
+  type code ## NaN = 0.0 / 0.0;
 
 decl_float (d, double)
 decl_float (f, float)
 
-extern float __aeabi_d2f (double);
-extern double __aeabi_f2d (float);
+extern float __aeabi_d2f (double) PCS;
+extern double __aeabi_f2d (float) PCS;
 extern long long __aeabi_lmul (long long, long long);
 extern long long __aeabi_llsl (long long, int);
 extern long long __aeabi_llsr (long long, int);
diff --git a/gcc/testsuite/gcc.target/arm/fp16-builtins-1.c b/gcc/testsuite/gcc.target/arm/fp16-builtins-1.c
new file mode 100644
index 000000000..868768028
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-builtins-1.c
@@ -0,0 +1,92 @@
+/* Test type-generic builtins with __fp16 arguments.
+   Except as otherwise noted, they should behave exactly
+   the same as those with float arguments.  */
+
+/* { dg-do run } */
+/* { dg-options "-mfp16-format=ieee -std=gnu99" } */
+
+#include <stdlib.h>
+#include <math.h>
+
+volatile __fp16 h1, h2;
+volatile float f1, f2;
+
+void
+set1 (double x)
+{
+  h1 = x;
+  f1 = h1;
+}
+
+void
+set2 (double x, double y)
+{
+  h1 = x;
+  f1 = h1;
+  h2 = y;
+  f2 = h2;
+}
+
+#define test1(p,x)				\
+  set1 (x);					\
+  hp = (p (h1) ? 1 : 0);			\
+  fp = (p (f1) ? 1 : 0);			\
+  if (hp ^ fp) abort ()
+
+#define test2(p,x,y)				\
+  set2 (x,y);					\
+  hp = (p (h1, h2) ? 1 : 0);			\
+  fp = (p (f1, f2) ? 1 : 0);			\
+  if (hp ^ fp) abort ()
+
+int
+main (void)
+{
+  int hp, fp;
+
+  test1 (__builtin_isfinite, 17.0);
+  test1 (__builtin_isfinite, INFINITY);
+  test1 (__builtin_isinf, -0.5);
+  test1 (__builtin_isinf, INFINITY);
+  test1 (__builtin_isnan, 493.0);
+  test1 (__builtin_isnan, NAN);
+  test1 (__builtin_isnormal, 3.14159);
+
+  test2 (__builtin_isgreater, 5.0, 3.0);
+  test2 (__builtin_isgreater, 3.0, 5.0);
+  test2 (__builtin_isgreater, 73.5, 73.5);
+  test2 (__builtin_isgreater, 1.0, NAN);
+
+  test2 (__builtin_isgreaterequal, 5.0, 3.0);
+  test2 (__builtin_isgreaterequal, 3.0, 5.0);
+  test2 (__builtin_isgreaterequal, 73.5, 73.5);
+  test2 (__builtin_isgreaterequal, 1.0, NAN);
+
+  test2 (__builtin_isless, 5.0, 3.0);
+  test2 (__builtin_isless, 3.0, 5.0);
+  test2 (__builtin_isless, 73.5, 73.5);
+  test2 (__builtin_isless, 1.0, NAN);
+
+  test2 (__builtin_islessequal, 5.0, 3.0);
+  test2 (__builtin_islessequal, 3.0, 5.0);
+  test2 (__builtin_islessequal, 73.5, 73.5);
+  test2 (__builtin_islessequal, 1.0, NAN);
+
+  test2 (__builtin_islessgreater, 5.0, 3.0);
+  test2 (__builtin_islessgreater, 3.0, 5.0);
+  test2 (__builtin_islessgreater, 73.5, 73.5);
+  test2 (__builtin_islessgreater, 1.0, NAN);
+
+  test2 (__builtin_isunordered, 5.0, 3.0);
+  test2 (__builtin_isunordered, 3.0, 5.0);
+  test2 (__builtin_isunordered, 73.5, 73.5);
+  test2 (__builtin_isunordered, 1.0, NAN);
+
+  /* Test that __builtin_isnormal recognizes a denormalized __fp16 value,
+     even if it's representable as a normalized float.  */
+  h1 = 5.96046E-8;
+  if (__builtin_isnormal (h1))
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-1.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-1.c
new file mode 100644
index 000000000..3abcd947a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-1.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+__fp16 xx = 0.0;
+
+/* { dg-final { scan-assembler "\t.eabi_attribute 38, 2" } } */
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.space\t2" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-10.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-10.c
new file mode 100644
index 000000000..2e3d31fdf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-10.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative -pedantic -std=gnu99" } */
+
+#include <math.h>
+
+/* NaNs are not representable in the alternative format; we should get a
+   diagnostic.  */
+__fp16 xx = NAN; /* { dg-warning "overflow" } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-11.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-11.c
new file mode 100644
index 000000000..62a7a3df5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-11.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative -pedantic -std=gnu99" } */
+
+#include <math.h>
+
+/* Infinities are not representable in the alternative format;
+   we should get a diagnostic, and the value set to the largest
+   representable value.  */
+/* 0x7fff = 32767 */
+__fp16 xx = INFINITY; /* { dg-warning "overflow" } */
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t32767" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-12.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-12.c
new file mode 100644
index 000000000..09586e9b8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-12.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+float xx __attribute__((mode(HF))) = 0.0;
+
+/* { dg-final { scan-assembler "\t.eabi_attribute 38, 2" } } */
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.space\t2" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-2.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-2.c
new file mode 100644
index 000000000..b7fe99d53
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-2.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x3c00 = 15360 */
+__fp16 xx = 1.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t15360" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-3.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-3.c
new file mode 100644
index 000000000..f325a84fe
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-3.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0xc000 = 49152 */
+__fp16 xx = -2.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t49152" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-4.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-4.c
new file mode 100644
index 000000000..4b9b33117
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-4.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x7bff = 31743 */
+__fp16 xx = 65504.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t31743" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-5.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-5.c
new file mode 100644
index 000000000..458f5073b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-5.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x3555 = 13653 */
+__fp16 xx = (1.0/3.0);
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t13653" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-6.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-6.c
new file mode 100644
index 000000000..dbb4a9999
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-6.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* This number is the maximum value representable in the alternative
+   encoding.  */
+/* 0x7fff = 32767 */
+__fp16 xx = 131008.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t32767" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-7.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-7.c
new file mode 100644
index 000000000..40940a634
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-7.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative -pedantic" } */
+
+/* This number overflows the range of the alternative encoding.  Since this
+   encoding doesn't have infinities, we should get a pedantic warning,
+   and the value should be set to the largest representable value.  */
+/* 0x7fff = 32767 */
+__fp16 xx = 123456789.0;  /* { dg-warning "overflow" } */
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t32767" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-8.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-8.c
new file mode 100644
index 000000000..cbc0a3947
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-8.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This is the minimum normalized value.  */
+/* 0x0400 = 1024 */
+__fp16 xx = 6.10352E-5;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t1024" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-alt-9.c b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-9.c
new file mode 100644
index 000000000..6487c8d67
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-alt-9.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This is the minimum denormalized value.  */
+/* 0x0001 = 1 */
+__fp16 xx = 5.96046E-8;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t1" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-exprtype.c b/gcc/testsuite/gcc.target/arm/fp16-compile-exprtype.c
new file mode 100644
index 000000000..1d8953b48
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-exprtype.c
@@ -0,0 +1,29 @@
+/* Test that expressions involving __fp16 values have the right types.  */
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* This produces a diagnostic if EXPR doesn't have type TYPE.  */
+#define CHECK(expr,type)			\
+  do {						\
+    type v;					\
+    __typeof (expr) *p = &v;			\
+  } while (0);
+
+volatile __fp16 f1;
+volatile __fp16 f2;
+
+int
+main (void)
+{
+  CHECK (f1, __fp16);
+  CHECK (+f1, float);
+  CHECK (-f1, float);
+  CHECK (f1+f2, float);
+  CHECK ((__fp16)(f1+f2), __fp16);
+  CHECK ((__fp16)99.99, __fp16);
+  CHECK ((f1+f2, f1), __fp16);
+}
+
+
+
+
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-1.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-1.c
new file mode 100644
index 000000000..d5d0ba2e4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-1.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+__fp16 xx = 0.0;
+
+/* { dg-final { scan-assembler "\t.eabi_attribute 38, 1" } } */
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.space\t2" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-10.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-10.c
new file mode 100644
index 000000000..51604374e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-10.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee -std=gnu99" } */
+
+#include <math.h>
+
+/* 0x7e00 = 32256 */
+__fp16 xx = NAN;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t32256" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-11.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-11.c
new file mode 100644
index 000000000..afab518b9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-11.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee -std=gnu99" } */
+
+#include <math.h>
+
+/* 0x7c00 = 31744 */
+__fp16 xx = INFINITY;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t31744" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-12.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-12.c
new file mode 100644
index 000000000..244c96ffd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-12.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+float xx __attribute__((mode(HF))) = 0.0;
+
+/* { dg-final { scan-assembler "\t.eabi_attribute 38, 1" } } */
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.space\t2" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-2.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-2.c
new file mode 100644
index 000000000..35f2031c7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-2.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x3c00 = 15360 */
+__fp16 xx = 1.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t15360" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-3.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-3.c
new file mode 100644
index 000000000..90edd0119
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-3.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0xc000 = 49152 */
+__fp16 xx = -2.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t49152" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-4.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-4.c
new file mode 100644
index 000000000..20676d89d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-4.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x7bff = 31743 */
+__fp16 xx = 65504.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t31743" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-5.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-5.c
new file mode 100644
index 000000000..aff9e1356
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-5.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* 0x3555 = 13653 */
+__fp16 xx = (1.0/3.0);
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t13653" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-6.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-6.c
new file mode 100644
index 000000000..c736e63a3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-6.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This number is too big and is represented as infinity.  */
+/* 0x7c00 = 31744 */
+__fp16 xx = 131008.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t31744" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-7.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-7.c
new file mode 100644
index 000000000..93163772b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-7.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee -pedantic" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This number is too big and is represented as infinity.  */
+/* We should *not* get an overflow warning here.  */
+/* 0x7c00 = 31744 */
+__fp16 xx = 123456789.0;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t31744" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-8.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-8.c
new file mode 100644
index 000000000..a9646739f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-8.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This is the minimum normalized value.  */
+/* 0x0400 = 1024 */
+__fp16 xx = 6.10352E-5;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t1024" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-9.c b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-9.c
new file mode 100644
index 000000000..11b31ce40
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-ieee-9.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Encoding taken from:  http://en.wikipedia.org/wiki/Half_precision */
+/* This is the minimum denormalized value.  */
+/* 0x0001 = 1 */
+__fp16 xx = 5.96046E-8;
+
+/* { dg-final { scan-assembler "\t.size\txx, 2" } } */
+/* { dg-final { scan-assembler "\t.short\t1" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-none-1.c b/gcc/testsuite/gcc.target/arm/fp16-compile-none-1.c
new file mode 100644
index 000000000..ca2912333
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-none-1.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=none" } */
+
+/* __fp16 type name is not recognized unless you explicitly enable it
+   by selecting -mfp16-format=ieee or -mfp16-format=alternative.  */
+__fp16 xx = 0.0;  /* { dg-error "expected" } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-none-2.c b/gcc/testsuite/gcc.target/arm/fp16-compile-none-2.c
new file mode 100644
index 000000000..eb7eef5ea
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-none-2.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=none" } */
+
+/* mode(HF) attributes are not recognized unless you explicitly enable
+   half-precision floating point by selecting -mfp16-format=ieee or
+   -mfp16-format=alternative.  */
+float xx __attribute__((mode(HF))) = 0.0;  /* { dg-error "HF" } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-compile-vcvt.c b/gcc/testsuite/gcc.target/arm/fp16-compile-vcvt.c
new file mode 100644
index 000000000..15614c5a6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-compile-vcvt.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_fp16_ok } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-add-options arm_neon_fp16 } */
+
+/* Test generation of VFP __fp16 instructions.  */
+
+__fp16 h1 = 0.0;
+__fp16 h2 = 1234.0;
+float f1 = 2.0;
+float f2 = -999.9;
+
+void f (void)
+{
+  h1 = f1;
+  f2 = h2;
+}
+
+/* { dg-final { scan-assembler "\tvcvtb.f32.f16" } } */
+/* { dg-final { scan-assembler "\tvcvtb.f16.f32" } } */
diff --git a/gcc/testsuite/gcc.target/arm/fp16-param-1.c b/gcc/testsuite/gcc.target/arm/fp16-param-1.c
new file mode 100644
index 000000000..af4845f9f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-param-1.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Functions cannot have parameters of type __fp16.  */
+extern void f (__fp16);		/* { dg-error "parameters cannot have __fp16 type" } */
+extern void (*pf) (__fp16);	/* { dg-error "parameters cannot have __fp16 type" } */
+
+/* These should be OK.  */
+extern void g (__fp16 *);
+extern void (*pg) (__fp16 *);
diff --git a/gcc/testsuite/gcc.target/arm/fp16-return-1.c b/gcc/testsuite/gcc.target/arm/fp16-return-1.c
new file mode 100644
index 000000000..f76394126
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-return-1.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+/* Functions cannot return type __fp16.  */
+extern __fp16 f (void);		/* { dg-error "cannot return __fp16" } */
+extern __fp16 (*pf) (void);	/* { dg-error "cannot return __fp16" } */
+
+/* These should be OK.  */
+extern __fp16 *g (void);
+extern __fp16 *(*pg) (void);
diff --git a/gcc/testsuite/gcc.target/arm/fp16-rounding-alt-1.c b/gcc/testsuite/gcc.target/arm/fp16-rounding-alt-1.c
new file mode 100644
index 000000000..f50b4475f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-rounding-alt-1.c
@@ -0,0 +1,47 @@
+/* Test intermediate rounding of double to float and then to __fp16, using
+   an example of a number that would round differently if it went directly
+   from double to __fp16.  */
+
+/* { dg-do run } */
+/* { dg-options "-mfp16-format=alternative" } */
+
+#include <stdlib.h>
+
+/* The original double value.  */
+#define ORIG 0x1.0020008p0
+
+/* The expected (double)((__fp16)((float)ORIG)) value.  */
+#define ROUNDED 0x1.0000000p0
+
+typedef union u {
+  __fp16 f;
+  unsigned short h;
+} ufh;
+
+ufh s = { ORIG };
+ufh r = { ROUNDED };
+
+double d = ORIG;
+
+int
+main (void)
+{
+  ufh x;
+
+  /* Test that the rounding is correct for static initializers.  */
+  if (s.h != r.h)
+    abort ();
+
+  /* Test that the rounding is correct for a casted constant expression
+     not in a static initializer.  */
+  x.f = (__fp16)ORIG;
+  if (x.h != r.h)
+    abort ();
+
+  /* Test that the rounding is correct for a runtime conversion.  */
+  x.f = (__fp16)d;
+  if (x.h != r.h)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/fp16-rounding-ieee-1.c b/gcc/testsuite/gcc.target/arm/fp16-rounding-ieee-1.c
new file mode 100644
index 000000000..866d4d824
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-rounding-ieee-1.c
@@ -0,0 +1,47 @@
+/* Test intermediate rounding of double to float and then to __fp16, using
+   an example of a number that would round differently if it went directly
+   from double to __fp16.  */
+
+/* { dg-do run } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+#include <stdlib.h>
+
+/* The original double value.  */
+#define ORIG 0x1.0020008p0
+
+/* The expected (double)((__fp16)((float)ORIG)) value.  */
+#define ROUNDED 0x1.0000000p0
+
+typedef union u {
+  __fp16 f;
+  unsigned short h;
+} ufh;
+
+ufh s = { ORIG };
+ufh r = { ROUNDED };
+
+double d = ORIG;
+
+int
+main (void)
+{
+  ufh x;
+
+  /* Test that the rounding is correct for static initializers.  */
+  if (s.h != r.h)
+    abort ();
+
+  /* Test that the rounding is correct for a casted constant expression
+     not in a static initializer.  */
+  x.f = (__fp16)ORIG;
+  if (x.h != r.h)
+    abort ();
+
+  /* Test that the rounding is correct for a runtime conversion.  */
+  x.f = (__fp16)d;
+  if (x.h != r.h)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/fp16-unprototyped-1.c b/gcc/testsuite/gcc.target/arm/fp16-unprototyped-1.c
new file mode 100644
index 000000000..70c295648
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-unprototyped-1.c
@@ -0,0 +1,21 @@
+/* Test promotion of __fp16 to double as arguments to unprototyped
+   function in another compilation unit.  */
+
+/* { dg-do run } */
+/* { dg-options "-mfp16-format=ieee" } */
+/* { dg-additional-sources "fp16-unprototyped-2.c" } */
+
+#include <stdlib.h>
+
+extern int f ();
+
+static __fp16 x = 42.0;
+static __fp16 y = -42.0;
+
+int
+main (void)
+{
+  if (!f (x, y))
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/fp16-unprototyped-2.c b/gcc/testsuite/gcc.target/arm/fp16-unprototyped-2.c
new file mode 100644
index 000000000..0c0f9cda6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-unprototyped-2.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+extern int f ();
+
+int
+f (double xx, double yy)
+{
+  if (xx == 42.0 && yy == -42.0)
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/fp16-variadic-1.c b/gcc/testsuite/gcc.target/arm/fp16-variadic-1.c
new file mode 100644
index 000000000..52b438638
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/fp16-variadic-1.c
@@ -0,0 +1,37 @@
+/* Test promotion of __fp16 to double as arguments to variadic function.  */
+
+/* { dg-do run } */
+/* { dg-options "-mfp16-format=ieee" } */
+
+#include <stdlib.h>
+#include <stdarg.h>
+
+extern int f (int n, ...);
+
+int 
+f (int n, ...)
+{
+  if (n == 2)
+    {
+      double xx, yy;
+      va_list ap;
+      va_start (ap, n);
+      xx = va_arg (ap, double);
+      yy = va_arg (ap, double);
+      va_end (ap);
+      if (xx == 42.0 && yy == -42.0)
+	return 1;
+    }
+  return 0;
+}
+
+static __fp16 x = 42.0;
+static __fp16 y = -42.0;
+
+int
+main (void)
+{
+  if (!f (2, x, y))
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/frame-pointer-1.c b/gcc/testsuite/gcc.target/arm/frame-pointer-1.c
new file mode 100644
index 000000000..bb1888e38
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/frame-pointer-1.c
@@ -0,0 +1,42 @@
+/* Check local register variables using a register conventionally 
+   used as the frame pointer aren't clobbered under high register pressure.  */
+/* { dg-do run } */
+/* { dg-options "-Os -mthumb -fomit-frame-pointer" } */
+
+#include <stdlib.h>
+
+int global=5;
+
+void __attribute__((noinline)) foo(int p1, int p2, int p3, int p4)
+{
+  if (global != 5 || p1 != 1 || p2 != 2 || p3 != 3 || p4 != 4)
+    abort();
+}
+
+int __attribute__((noinline)) test(int a, int b, int c, int d)
+{
+  register unsigned long r __asm__("r7") = 0xdeadbeef;
+  int e;
+
+  /* ABCD are live after the call which should be enough
+     to cause r7 to be used if it weren't for the register variable.  */
+  foo(a,b,c,d);
+
+  e = 0;
+  __asm__ __volatile__ ("mov %0, %2"
+			: "=r" (e)
+			: "0" (e), "r" (r));
+
+  global = a+b+c+d;
+
+  return e;
+}
+
+int main()
+{
+  if (test(1, 2, 3, 4) != 0xdeadbeef)
+    abort();
+  if (global != 10)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/janus-2cc-shift-1.c b/gcc/testsuite/gcc.target/arm/janus-2cc-shift-1.c
new file mode 100644
index 000000000..8f73be8d0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/janus-2cc-shift-1.c
@@ -0,0 +1,17 @@
+/* Check that a nop is inserted after a shift taking a register operand.  */
+/* { dg-do compile } */
+/* { dg-options "-mfix-janus-2cc" } */
+/* { dg-require-effective-target arm_not_thumb } */
+int foo(int x)
+{
+  int y;
+  int z;
+  
+  y = x << 4;
+  z = y << x;
+
+  return y+z;
+}
+/* { dg-final { scan-assembler "\tmov\tr\[0-9], r\[0-9], asl r\[0-9]\n\tnop\n" } } */
+/* { dg-final { scan-assembler-not "\tmov\tr\[0-9], r\[0-9], asl #4\n\tnop\n" } } */
+
diff --git a/gcc/testsuite/gcc.target/arm/janus-2cc-shift-2.c b/gcc/testsuite/gcc.target/arm/janus-2cc-shift-2.c
new file mode 100644
index 000000000..75d38a6fb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/janus-2cc-shift-2.c
@@ -0,0 +1,17 @@
+/* Check that a nop is inserted after a shift taking a register operand.  */
+/* { dg-do compile } */
+/* { dg-options "-mfix-janus-2cc -mthumb" } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+int foo(int x)
+{
+  int y;
+  int z;
+  
+  y = x << 4;
+  z = y << x;
+
+  return y+z;
+}
+/* { dg-final { scan-assembler "\tlsl\tr\[0-9], r\[0-9], r\[0-9]\n\tnop\n" } } */
+/* { dg-final { scan-assembler-not "\tlsl\tr\[0-9], r\[0-9], #4\n\tnop\n" } } */
+
diff --git a/gcc/testsuite/gcc.target/arm/mmx-1.c b/gcc/testsuite/gcc.target/arm/mmx-1.c
index 21cc47912..c2eca7f78 100644
--- a/gcc/testsuite/gcc.target/arm/mmx-1.c
+++ b/gcc/testsuite/gcc.target/arm/mmx-1.c
@@ -3,10 +3,10 @@
 /* { dg-do compile } */
 /* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-mcpu=*" } { "-mcpu=iwmmxt" } } */
 /* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-mabi=*" } { "-mabi=iwmmxt" } } */
-/* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-mfloat-abi=softfp" } { "" } } */
 /* { dg-skip-if "Test is specific to the iWMMXt" { arm*-*-* } { "-march=*" } { "-march=iwmmxt" } } */
 /* { dg-options "-O -mno-apcs-frame -mcpu=iwmmxt -mabi=iwmmxt" } */
 /* { dg-require-effective-target arm32 } */
+/* { dg-require-effective-target arm_iwmmxt_ok } */
 /* { dg-final { scan-assembler "ldmfd\[ 	]sp!.*ip,\[ ]*pc" } } */
 
 /* This function uses all the call-saved registers, namely r4, r5, r6,
diff --git a/gcc/testsuite/gcc.target/arm/naked-3.c b/gcc/testsuite/gcc.target/arm/naked-3.c
new file mode 100644
index 000000000..2559a7da9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/naked-3.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall" } */
+/* Check that we do not get warnings about missing return statements
+   or bogus looking noreturn functions.  */
+int __attribute__((naked))
+foo(void)
+{
+  __asm__ volatile ("mov r0, #1\r\nbx lr\n");
+}
+
+int __attribute__((naked,noreturn))
+bar(void)
+{
+  __asm__ volatile ("frob r0\n");
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-cond-1.c b/gcc/testsuite/gcc.target/arm/neon-cond-1.c
index 7d87b6e12..a67625014 100644
--- a/gcc/testsuite/gcc.target/arm/neon-cond-1.c
+++ b/gcc/testsuite/gcc.target/arm/neon-cond-1.c
@@ -1,6 +1,7 @@
 /* { dg-do run } */
 /* { dg-require-effective-target arm_neon_hw } */
-/* { dg-options "-O2 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
 /* Check that the arm_final_prescan_insn ccfsm code does not try to
  * conditionally execute NEON instructions.  */
 #include <arm_neon.h>
diff --git a/gcc/testsuite/gcc.target/arm/neon-load-df0.c b/gcc/testsuite/gcc.target/arm/neon-load-df0.c
new file mode 100644
index 000000000..ee5f6236b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-load-df0.c
@@ -0,0 +1,14 @@
+/* Test the optimization of loading 0.0 for ARM Neon.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+double x;
+void bar ()
+{
+  x = 0.0;
+}
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[dD\]\[0-9\]+, #0\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-modes-1.c b/gcc/testsuite/gcc.target/arm/neon-modes-1.c
new file mode 100644
index 000000000..6ee13af01
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-modes-1.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O1" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+void neon_internal_error(int *dst, int *src)
+{
+  uint16x8x4_t sval;
+
+  sval = vld4q_u16((void *)src);
+  vst4q_u16((void *)dst,sval);
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vadds64.c b/gcc/testsuite/gcc.target/arm/neon-vadds64.c
new file mode 100644
index 000000000..284a1d8ad
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vadds64.c
@@ -0,0 +1,21 @@
+/* Test the `vadd_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)0x00000000deadbeefLL;
+
+  out_int64x1_t = vadd_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdeadbeefdeadbeefLL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vaddu64.c b/gcc/testsuite/gcc.target/arm/neon-vaddu64.c
new file mode 100644
index 000000000..05bda8b04
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vaddu64.c
@@ -0,0 +1,21 @@
+/* Test the `vadd_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)0x00000000deadbeefLL;
+
+  out_uint64x1_t = vadd_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdeadbeefdeadbeefLL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vands64.c b/gcc/testsuite/gcc.target/arm/neon-vands64.c
new file mode 100644
index 000000000..8b6975db6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vands64.c
@@ -0,0 +1,21 @@
+/* Test the `vand_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)0xdead00000000beefLL;
+
+  out_int64x1_t = vand_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdead000000000000LL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vandu64.c b/gcc/testsuite/gcc.target/arm/neon-vandu64.c
new file mode 100644
index 000000000..a8ec3a28b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vandu64.c
@@ -0,0 +1,21 @@
+/* Test the `vand_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)0xdead00000000beefLL;
+
+  out_uint64x1_t = vand_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdead000000000000LL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vbics64.c b/gcc/testsuite/gcc.target/arm/neon-vbics64.c
new file mode 100644
index 000000000..ec3438bae
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vbics64.c
@@ -0,0 +1,21 @@
+/* Test the `vbic_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)(~0xdead00000000beefLL);
+
+  out_int64x1_t = vbic_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdead000000000000LL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vbicu64.c b/gcc/testsuite/gcc.target/arm/neon-vbicu64.c
new file mode 100644
index 000000000..a0c1b85b4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vbicu64.c
@@ -0,0 +1,21 @@
+/* Test the `vbic_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)(~0xdead00000000beefLL);
+
+  out_uint64x1_t = vbic_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdead000000000000LL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-1.c b/gcc/testsuite/gcc.target/arm/neon-vdup-1.c
new file mode 100644
index 000000000..41799a25c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-1.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_f32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+float32x4_t out_float32x4_t;
+void test_vdupq_nf32 (void)
+{
+  out_float32x4_t = vdupq_n_f32 (0.0);
+}
+
+/* { dg-final { scan-assembler "vmov\.f32\[ 	\]+\[qQ\]\[0-9\]+, #0\.0\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-10.c b/gcc/testsuite/gcc.target/arm/neon-vdup-10.c
new file mode 100644
index 000000000..a06b0647a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-10.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (~0x12000000);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #3992977407\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-11.c b/gcc/testsuite/gcc.target/arm/neon-vdup-11.c
new file mode 100644
index 000000000..07d08896a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-11.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u16' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint16x8_t out_uint16x8_t;
+void test_vdupq_nu16 (void)
+{
+  out_uint16x8_t = vdupq_n_u16 (0x12);
+}
+
+/* { dg-final { scan-assembler "vmov\.i16\[ 	\]+\[qQ\]\[0-9\]+, #18\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-12.c b/gcc/testsuite/gcc.target/arm/neon-vdup-12.c
new file mode 100644
index 000000000..27b418682
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-12.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u16' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint16x8_t out_uint16x8_t;
+void test_vdupq_nu16 (void)
+{
+  out_uint16x8_t = vdupq_n_u16 (0x1200);
+}
+
+/* { dg-final { scan-assembler "vmov\.i16\[ 	\]+\[qQ\]\[0-9\]+, #4608\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-13.c b/gcc/testsuite/gcc.target/arm/neon-vdup-13.c
new file mode 100644
index 000000000..4d38bc088
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-13.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u16' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint16x8_t out_uint16x8_t;
+void test_vdupq_nu16 (void)
+{
+  out_uint16x8_t = vdupq_n_u16 (~0x12);
+}
+
+/* { dg-final { scan-assembler "vmov\.i16\[ 	\]+\[qQ\]\[0-9\]+, #65517\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-14.c b/gcc/testsuite/gcc.target/arm/neon-vdup-14.c
new file mode 100644
index 000000000..a16659fda
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-14.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u16' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint16x8_t out_uint16x8_t;
+void test_vdupq_nu16 (void)
+{
+  out_uint16x8_t = vdupq_n_u16 (~0x1200);
+}
+
+/* { dg-final { scan-assembler "vmov\.i16\[ 	\]+\[qQ\]\[0-9\]+, #60927\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-15.c b/gcc/testsuite/gcc.target/arm/neon-vdup-15.c
new file mode 100644
index 000000000..84a6fe04f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-15.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u8' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint8x16_t out_uint8x16_t;
+void test_vdupq_nu8 (void)
+{
+  out_uint8x16_t = vdupq_n_u8 (0x12);
+}
+
+/* { dg-final { scan-assembler "vmov\.i8\[ 	\]+\[qQ\]\[0-9\]+, #18\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-16.c b/gcc/testsuite/gcc.target/arm/neon-vdup-16.c
new file mode 100644
index 000000000..70bec0336
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-16.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (0x12ff);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4863\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-17.c b/gcc/testsuite/gcc.target/arm/neon-vdup-17.c
new file mode 100644
index 000000000..e0283f1fb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-17.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (0x12ffff);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #1245183\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-18.c b/gcc/testsuite/gcc.target/arm/neon-vdup-18.c
new file mode 100644
index 000000000..7dcf85d39
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-18.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (~0x12ff);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4294962432\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-19.c b/gcc/testsuite/gcc.target/arm/neon-vdup-19.c
new file mode 100644
index 000000000..09804373f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-19.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (~0x12ffff);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4293722112\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-2.c b/gcc/testsuite/gcc.target/arm/neon-vdup-2.c
new file mode 100644
index 000000000..f9e6a72ae
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-2.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_f32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+float32x4_t out_float32x4_t;
+void test_vdupq_nf32 (void)
+{
+  out_float32x4_t = vdupq_n_f32 (0.125);
+}
+
+/* { dg-final { scan-assembler "vmov\.f32\[ 	\]+\[qQ\]\[0-9\]+, #1\.25e-1\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-3.c b/gcc/testsuite/gcc.target/arm/neon-vdup-3.c
new file mode 100644
index 000000000..d40731643
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-3.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (0x12);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #18\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-4.c b/gcc/testsuite/gcc.target/arm/neon-vdup-4.c
new file mode 100644
index 000000000..bc1be079f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-4.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (0x1200);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4608\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-5.c b/gcc/testsuite/gcc.target/arm/neon-vdup-5.c
new file mode 100644
index 000000000..9b04f16d5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-5.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (0x120000);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #1179648\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-6.c b/gcc/testsuite/gcc.target/arm/neon-vdup-6.c
new file mode 100644
index 000000000..0889b80af
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-6.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (0x12000000);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #301989888\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-7.c b/gcc/testsuite/gcc.target/arm/neon-vdup-7.c
new file mode 100644
index 000000000..f7b1dc861
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-7.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (~0x12);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4294967277\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-8.c b/gcc/testsuite/gcc.target/arm/neon-vdup-8.c
new file mode 100644
index 000000000..9d494c355
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-8.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (~0x1200);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4294962687\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup-9.c b/gcc/testsuite/gcc.target/arm/neon-vdup-9.c
new file mode 100644
index 000000000..799e95ed9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup-9.c
@@ -0,0 +1,17 @@
+/* Test the optimization of `vdupq_n_u32' ARM Neon intrinsic.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint32x4_t out_uint32x4_t;
+void test_vdupq_nu32 (void)
+{
+  out_uint32x4_t = vdupq_n_u32 (~0x120000);
+}
+
+/* { dg-final { scan-assembler "vmov\.i32\[ 	\]+\[qQ\]\[0-9\]+, #4293787647\(\[ \]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdupQ_lanes64.c b/gcc/testsuite/gcc.target/arm/neon-vdupQ_lanes64.c
new file mode 100644
index 000000000..da24eaca6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdupQ_lanes64.c
@@ -0,0 +1,22 @@
+/* Test the `vdupq_lanes64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x2_t out_int64x2_t = {0, 0};
+  int64_t arg0_int64_t = (int64_t) 0xdeadbeef;
+
+  out_int64x2_t = vdupq_lane_s64 ((int64x1_t)arg0_int64_t, 0);
+  if (vgetq_lane_s64 (out_int64x2_t, 0) != arg0_int64_t)
+    abort();
+  if (vgetq_lane_s64 (out_int64x2_t, 1) != arg0_int64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdupQ_laneu64.c b/gcc/testsuite/gcc.target/arm/neon-vdupQ_laneu64.c
new file mode 100644
index 000000000..cc19ea512
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdupQ_laneu64.c
@@ -0,0 +1,22 @@
+/* Test the `vdupq_laneu64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x2_t out_uint64x2_t = {0, 0};
+  uint64_t arg0_uint64_t = (uint64_t) 0xdeadbeef;
+
+  out_uint64x2_t = vdupq_lane_u64 ((uint64x1_t)arg0_uint64_t, 0);
+  if (vgetq_lane_u64 (out_uint64x2_t, 0) != arg0_uint64_t)
+    abort();
+  if (vgetq_lane_u64 (out_uint64x2_t, 1) != arg0_uint64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdupQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon-vdupQ_ns64.c
new file mode 100644
index 000000000..79b4d4eb6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdupQ_ns64.c
@@ -0,0 +1,22 @@
+/* Test the `vdupq_ns64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x2_t out_int64x2_t = {0, 0};
+  int64_t arg0_int64_t = (int64_t) 0xdeadbeef;
+
+  out_int64x2_t = vdupq_n_s64 (arg0_int64_t);
+  if (vgetq_lane_s64 (out_int64x2_t, 0) != arg0_int64_t)
+    abort();
+  if (vgetq_lane_s64 (out_int64x2_t, 1) != arg0_int64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdupQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon-vdupQ_nu64.c
new file mode 100644
index 000000000..ef6f47fd3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdupQ_nu64.c
@@ -0,0 +1,22 @@
+/* Test the `vdupq_nu64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x2_t out_uint64x2_t = {0, 0};
+  uint64_t arg0_uint64_t = (uint64_t) 0xdeadbeef;
+
+  out_uint64x2_t = vdupq_n_u64 (arg0_uint64_t);
+  if (vgetq_lane_u64 (out_uint64x2_t, 0) != arg0_uint64_t)
+    abort();
+  if (vgetq_lane_u64 (out_uint64x2_t, 1) != arg0_uint64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup_ns64.c b/gcc/testsuite/gcc.target/arm/neon-vdup_ns64.c
new file mode 100644
index 000000000..589ea2293
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup_ns64.c
@@ -0,0 +1,20 @@
+/* Test the `vdup_ns64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64_t arg0_int64_t = (int64_t) 0xdeadbeef;
+
+  out_int64x1_t = vdup_n_s64 (arg0_int64_t);
+  if ((int64_t)out_int64x1_t != arg0_int64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vdup_nu64.c b/gcc/testsuite/gcc.target/arm/neon-vdup_nu64.c
new file mode 100644
index 000000000..8bed5a0c7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vdup_nu64.c
@@ -0,0 +1,20 @@
+/* Test the `vdup_nu64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64_t arg0_uint64_t = (uint64_t) 0xdeadbeef;
+
+  out_uint64x1_t = vdup_n_u64 (arg0_uint64_t);
+  if ((uint64_t)out_uint64x1_t != arg0_uint64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-veors64.c b/gcc/testsuite/gcc.target/arm/neon-veors64.c
new file mode 100644
index 000000000..59d5baa35
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-veors64.c
@@ -0,0 +1,21 @@
+/* Test the `veor_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)0xdead00000000beefLL;
+
+  out_int64x1_t = veor_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0x0000beef0000beefLL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-veoru64.c b/gcc/testsuite/gcc.target/arm/neon-veoru64.c
new file mode 100644
index 000000000..b7ff77af0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-veoru64.c
@@ -0,0 +1,21 @@
+/* Test the `veor_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)0xdead00000000beefLL;
+
+  out_uint64x1_t = veor_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0x0000beef0000beefLL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vget_lanes64.c b/gcc/testsuite/gcc.target/arm/neon-vget_lanes64.c
new file mode 100644
index 000000000..5891e6619
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vget_lanes64.c
@@ -0,0 +1,20 @@
+/* Test the `vget_lane_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64_t out_int64_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t) 0xdeadbeefbadf00dLL;
+
+  out_int64_t = vget_lane_s64 (arg0_int64x1_t, 0);
+  if (out_int64_t != (int64_t)arg0_int64x1_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vget_laneu64.c b/gcc/testsuite/gcc.target/arm/neon-vget_laneu64.c
new file mode 100644
index 000000000..b0ce070d3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vget_laneu64.c
@@ -0,0 +1,20 @@
+/* Test the `vget_lane_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64_t out_uint64_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t) 0xdeadbeefbadf00dLL;
+
+  out_uint64_t = vget_lane_u64 (arg0_uint64x1_t, 0);
+  if (out_uint64_t != (uint64_t)arg0_uint64x1_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vmla-1.c b/gcc/testsuite/gcc.target/arm/neon-vmla-1.c
new file mode 100644
index 000000000..336a53bb4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vmla-1.c
@@ -0,0 +1,11 @@
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O2 -ftree-vectorize" } */
+/* { dg-add-options arm_neon } */
+/* { dg-final { scan-assembler "vmla\\.f32" } } */
+
+/* Verify that VMLA is used.  */
+void f1(int n, float a, float x[], float y[]) {
+  int i;
+  for (i = 0; i < n; ++i)
+    y[i] = a * x[i] + y[i];
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vmls-1.c b/gcc/testsuite/gcc.target/arm/neon-vmls-1.c
new file mode 100644
index 000000000..5e5e0c757
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vmls-1.c
@@ -0,0 +1,11 @@
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O2 -ftree-vectorize" } */
+/* { dg-add-options arm_neon } */
+/* { dg-final { scan-assembler "vmls\\.f32" } } */
+
+/* Verify that VMLS is used.  */
+void f1(int n, float a, float x[], float y[]) {
+  int i;
+  for (i = 0; i < n; ++i)
+    y[i] = y[i] - a * x[i];
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vmovQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon-vmovQ_ns64.c
new file mode 100644
index 000000000..5a8abdce0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vmovQ_ns64.c
@@ -0,0 +1,22 @@
+/* Test the `vmovq_ns64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x2_t out_int64x2_t = {0, 0};
+  int64_t arg0_int64_t = (int64_t) 0xdeadbeef;
+
+  out_int64x2_t = vmovq_n_s64 (arg0_int64_t);
+  if (vgetq_lane_s64 (out_int64x2_t, 0) != arg0_int64_t)
+    abort();
+  if (vgetq_lane_s64 (out_int64x2_t, 1) != arg0_int64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vmovQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon-vmovQ_nu64.c
new file mode 100644
index 000000000..8012fc175
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vmovQ_nu64.c
@@ -0,0 +1,23 @@
+/* Test the `vmovq_nu64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x2_t out_uint64x2_t = {0, 0};
+  uint64_t arg0_uint64_t = (uint64_t) 0xdeadbeef;
+
+  out_uint64x2_t = vmovq_n_u64 (arg0_uint64_t);
+  if (vgetq_lane_u64 (out_uint64x2_t, 0) != arg0_uint64_t)
+    abort();
+  if (vgetq_lane_u64 (out_uint64x2_t, 1) != arg0_uint64_t)
+    abort();
+  return 0;
+}
+
diff --git a/gcc/testsuite/gcc.target/arm/neon-vmov_ns64.c b/gcc/testsuite/gcc.target/arm/neon-vmov_ns64.c
new file mode 100644
index 000000000..c125f4a24
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vmov_ns64.c
@@ -0,0 +1,20 @@
+/* Test the `vmov_ns64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64_t arg0_int64_t = (int64_t) 0xdeadbeef;
+
+  out_int64x1_t = vmov_n_s64 (arg0_int64_t);
+  if ((int64_t)out_int64x1_t != arg0_int64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vmov_nu64.c b/gcc/testsuite/gcc.target/arm/neon-vmov_nu64.c
new file mode 100644
index 000000000..71ecaed13
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vmov_nu64.c
@@ -0,0 +1,20 @@
+/* Test the `vmov_nu64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64_t arg0_uint64_t = (uint64_t) 0xdeadbeef;
+
+  out_uint64x1_t = vmov_n_u64 (arg0_uint64_t);
+  if ((uint64_t)out_uint64x1_t != arg0_uint64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vorns64.c b/gcc/testsuite/gcc.target/arm/neon-vorns64.c
new file mode 100644
index 000000000..364dbd190
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vorns64.c
@@ -0,0 +1,21 @@
+/* Test the `vorn_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)(~0xdead00000000beefLL);
+
+  out_int64x1_t = vorn_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdeadbeef0000beefLL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vornu64.c b/gcc/testsuite/gcc.target/arm/neon-vornu64.c
new file mode 100644
index 000000000..b35286846
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vornu64.c
@@ -0,0 +1,21 @@
+/* Test the `vorn_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)(~0xdead00000000beefLL);
+
+  out_uint64x1_t = vorn_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdeadbeef0000beefLL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vorrs64.c b/gcc/testsuite/gcc.target/arm/neon-vorrs64.c
new file mode 100644
index 000000000..90ced9e9c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vorrs64.c
@@ -0,0 +1,21 @@
+/* Test the `vorr_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)0xdead00000000beefLL;
+
+  out_int64x1_t = vorr_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdeadbeef0000beefLL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vorru64.c b/gcc/testsuite/gcc.target/arm/neon-vorru64.c
new file mode 100644
index 000000000..5b44afb07
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vorru64.c
@@ -0,0 +1,21 @@
+/* Test the `vorr_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)0xdead00000000beefLL;
+
+  out_uint64x1_t = vorr_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdeadbeef0000beefLL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vset_lanes64.c b/gcc/testsuite/gcc.target/arm/neon-vset_lanes64.c
new file mode 100644
index 000000000..101139327
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vset_lanes64.c
@@ -0,0 +1,21 @@
+/* Test the `vset_lane_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64_t arg0_int64_t = 0xf00f00f00LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t) 0xdeadbeefbadf00dLL;
+
+  out_int64x1_t = vset_lane_s64 (arg0_int64_t, arg1_int64x1_t, 0);
+  if ((int64_t)out_int64x1_t != arg0_int64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vset_laneu64.c b/gcc/testsuite/gcc.target/arm/neon-vset_laneu64.c
new file mode 100644
index 000000000..cafc26076
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vset_laneu64.c
@@ -0,0 +1,21 @@
+/* Test the `vset_lane_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64_t arg0_uint64_t = 0xf00f00f00LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t) 0xdeadbeefbadf00dLL;
+
+  out_uint64x1_t = vset_lane_u64 (arg0_uint64_t, arg1_uint64x1_t, 0);
+  if ((uint64_t)out_uint64x1_t != arg0_uint64_t)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vsubs64.c b/gcc/testsuite/gcc.target/arm/neon-vsubs64.c
new file mode 100644
index 000000000..239470041
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vsubs64.c
@@ -0,0 +1,21 @@
+/* Test the `vsub_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeefdeadbeefLL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)0x0000beefdead0000LL;
+
+  out_int64x1_t = vsub_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdead00000000beefLL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon-vsubu64.c b/gcc/testsuite/gcc.target/arm/neon-vsubu64.c
new file mode 100644
index 000000000..0162e206e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon-vsubu64.c
@@ -0,0 +1,21 @@
+/* Test the `vsub_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeefdeadbeefLL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)0x0000beefdead0000LL;
+
+  out_uint64x1_t = vsub_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdead00000000beefLL)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/neon/polytypes.c b/gcc/testsuite/gcc.target/arm/neon/polytypes.c
index 12e9b0a7f..7ee169e27 100644
--- a/gcc/testsuite/gcc.target/arm/neon/polytypes.c
+++ b/gcc/testsuite/gcc.target/arm/neon/polytypes.c
@@ -3,7 +3,7 @@
 
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-add-options arm_neon } */
 
 #include <arm_neon.h>
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c
index 68834af06..8a8032d01 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c
index afa4307f3..45b577631 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c
index efa777cd0..4e564ee10 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c
index 2406ba614..f036e0438 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c
index 3266f8b16..f9fbb869d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c
index e77356f27..853ab7fcb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c
index dae4fe9b6..1be084ede 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c
index bcd72ab60..acc6c0176 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c
index 0c5874e13..bfac186e4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c
index 175211091..10dcdfe12 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c
index 92fb39911..9c6178135 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c
index 39a8e0106..ac8488498 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c b/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c
index 2a301d482..a1207e2d6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c b/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c
index 91d6494e9..758572982 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c b/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c
index 25703e55b..c6048c2e1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c
index b655963d0..41e03fe6d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c
index 7ab8d5b50..f0cdae6d3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c b/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c
index 8f1cae990..278496f28 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c
index 81c79b16f..622cd3843 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c
index a91618cc0..9d6c8b849 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c
index f20de10fd..d9f1accae 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c
index 4c63dc470..695e9e17f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c
index fe8981e1b..1abf88844 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c
index cdb4c323f..ee517d83b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c
index 877150415..ec46e7632 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c b/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c
index 6ab254e60..3abdefcd8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshls16.c b/gcc/testsuite/gcc.target/arm/neon/vRshls16.c
index e33198833..5d13fac3c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshls32.c b/gcc/testsuite/gcc.target/arm/neon/vRshls32.c
index 2ba12c4ab..71ed3401f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshls64.c b/gcc/testsuite/gcc.target/arm/neon/vRshls64.c
index 360c0c1d1..c6e20c0dc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshls64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshls64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshls8.c b/gcc/testsuite/gcc.target/arm/neon/vRshls8.c
index a9b68eba4..b4cc42739 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c b/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c
index d493b441a..42c77250c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c b/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c
index 82edc7eed..dfc5da7f4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c b/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c
index b821e2c27..030b5eed3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c b/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c
index f609ce00e..2e091b39b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c
index 3ea1a5f4b..f844a5bfd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c
index e66dec53f..a651bf484 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c
index 8d4d23c55..2e78282d3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c
index 3ac4b093b..376fcf1d8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c
index 2454b80eb..ae1555dcf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c
index 8a8b35129..18ec347c1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c
index 1388e75aa..370ae502f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c
index 0218268b2..5c5149ed0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c
index 45be077f0..3045dddee 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c
index 1921daa9c..2c3c12665 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c
index 8369afb68..182c56b86 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c
index 3632be0f3..1e41c26be 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c
index 262783de5..c34b54e22 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c
index ed480252b..c07863ec1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c
index 5e66caa4c..910d7de54 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c
index 720f9cab6..25b5a6b5f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c
index 864aa5e6f..966e6c78e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c
index a313892e7..6227223e3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c
index e95ef9230..d219e9482 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c
index 09e3299b6..9f59e8c3c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c
index 548d89e93..d7904ea56 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c
index 9a67f2d8e..33d390157 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c
index 803eab09d..cb7c469a9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c
index 541528fe5..3ac2e316e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c
index 26f404982..d0b6a9272 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c
index 9d701f3f1..af402f4f6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c
index a3ff5f035..b8c0fbf1e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c
index 7830c435a..7bec98340 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c
index bd12da149..167a27c4a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c
index 928dcd8a3..14a6251fd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c
index e7b2d1a1f..31d6f0ca3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c
index dd3c11536..43fa61aac 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c
index 98944d675..1b28f926a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c
index 187bbc015..fc810c2cd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c
index 56009bb29..d951b266b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c
index f7879dbcd..f7f74c3c8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c
index 25d25d55c..713c7bb1b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c
index 07f587a55..4b19bd846 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c
index ec62a28f4..8ba5a2075 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c
index a049aab22..26fa452c0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c
index 515bac135..ed990790f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c
index 0e5294601..b5e7b28ec 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c
index f4ec78887..5275c97b3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c
index 1b41a20ad..3951ff0c3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c b/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c
index e15a611df..4fe8aa303 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c b/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c
index b14068ab5..0e2b06fdd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c b/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c
index 91a1582ff..679805ad6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c b/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c
index 61642ac1e..87e5f2232 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c b/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c
index 2227524cd..91ee45dfa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c b/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c
index 4e92d0345..f4adb3272 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabals16.c b/gcc/testsuite/gcc.target/arm/neon/vabals16.c
index 65f1b9d41..14f8aa0d4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabals16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabals16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabals32.c b/gcc/testsuite/gcc.target/arm/neon/vabals32.c
index 13a696b13..980b27e6d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabals32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabals32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabals8.c b/gcc/testsuite/gcc.target/arm/neon/vabals8.c
index c7275b357..85dcb40b6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabals8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabals8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabalu16.c b/gcc/testsuite/gcc.target/arm/neon/vabalu16.c
index 0be2473dc..9cf105ee3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabalu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabalu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabalu32.c b/gcc/testsuite/gcc.target/arm/neon/vabalu32.c
index 508420b4b..dc9925f58 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabalu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabalu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabalu8.c b/gcc/testsuite/gcc.target/arm/neon/vabalu8.c
index 0580eb3df..464e2cdad 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabalu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabalu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabas16.c b/gcc/testsuite/gcc.target/arm/neon/vabas16.c
index 4122be9a1..21f5adbdd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabas16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabas16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabas32.c b/gcc/testsuite/gcc.target/arm/neon/vabas32.c
index ca089864f..f9a41481e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabas32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabas32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabas8.c b/gcc/testsuite/gcc.target/arm/neon/vabas8.c
index e03f2285a..609680a05 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabas8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabas8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabau16.c b/gcc/testsuite/gcc.target/arm/neon/vabau16.c
index f67beca53..0896900fd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabau16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabau16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabau32.c b/gcc/testsuite/gcc.target/arm/neon/vabau32.c
index b57d1cf39..4f4f25abd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabau32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabau32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabau8.c b/gcc/testsuite/gcc.target/arm/neon/vabau8.c
index 03ce6665b..91dfc1a83 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabau8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabau8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c b/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c
index 0cec3095b..50c1acc63 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c b/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c
index cd7cedbde..7ef3f2edd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c b/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c
index 06a2d6a81..673b01f2f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c b/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c
index dc52032a7..5d24d228f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c b/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c
index 72cfd3a32..222384e1f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c b/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c
index cd0c36193..ef5716b69 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c b/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c
index 15afaa9e6..065a5f3be 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdf32.c b/gcc/testsuite/gcc.target/arm/neon/vabdf32.c
index 58465a617..8fc0be271 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdls16.c b/gcc/testsuite/gcc.target/arm/neon/vabdls16.c
index a9c495df9..e9df745b2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdls32.c b/gcc/testsuite/gcc.target/arm/neon/vabdls32.c
index 8f189479e..b4ad32735 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdls8.c b/gcc/testsuite/gcc.target/arm/neon/vabdls8.c
index 1696bbca0..75ca12502 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c b/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c
index cb26a67ad..692962ede 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c b/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c
index 34541ee54..f5a7ef691 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c b/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c
index b84a0457a..221729ae6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabds16.c b/gcc/testsuite/gcc.target/arm/neon/vabds16.c
index 209b6daeb..2d76a286d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabds16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabds16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabds32.c b/gcc/testsuite/gcc.target/arm/neon/vabds32.c
index e7d5d4023..9ca6e5d8d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabds32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabds32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabds8.c b/gcc/testsuite/gcc.target/arm/neon/vabds8.c
index aba217882..561687047 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabds8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabds8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdu16.c b/gcc/testsuite/gcc.target/arm/neon/vabdu16.c
index bbb779ad8..e23873494 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdu32.c b/gcc/testsuite/gcc.target/arm/neon/vabdu32.c
index d51068cb6..61871dda4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabdu8.c b/gcc/testsuite/gcc.target/arm/neon/vabdu8.c
index 066c6555f..bff9f9cf7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabdu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabdu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c b/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c
index 137a568fd..36e145d08 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c b/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c
index 47cf5a66f..befade576 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c b/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c
index f775b5a24..8d1270012 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c b/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c
index 131244923..a69d7a89e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabsf32.c b/gcc/testsuite/gcc.target/arm/neon/vabsf32.c
index 53d6c0c5d..e60dd896d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabsf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabsf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabss16.c b/gcc/testsuite/gcc.target/arm/neon/vabss16.c
index 8f91a70c6..9cc1ab561 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabss16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabss16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabss32.c b/gcc/testsuite/gcc.target/arm/neon/vabss32.c
index 75033665a..5f3c6353e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabss32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabss32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vabss8.c b/gcc/testsuite/gcc.target/arm/neon/vabss8.c
index c7e77f665..05ae5241a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vabss8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vabss8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c b/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c
index 7a232f85e..fb856385d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c b/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c
index a034cfcb1..839af2433 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c b/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c
index e99ddb589..f93a83221 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c b/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c
index 381ce4d74..fdc99171a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c b/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c
index 28a26765f..49fe47812 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c b/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c
index dd860af23..2f6ac31a3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c b/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c
index d04f60663..3c279b4ae 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c b/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c
index ed5b54a71..c525a85d9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c b/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c
index 94c27aa81..975dfa37c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddf32.c b/gcc/testsuite/gcc.target/arm/neon/vaddf32.c
index 646674ed9..15364b77c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c b/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c
index 1328a850f..d39d14a27 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c b/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c
index 7b54f1500..52d622164 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c b/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c
index 5bd6cc02d..cb593a2ee 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c b/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c
index 87661d821..59d311fa0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c b/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c
index db1860df0..570b8855b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c b/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c
index 461d4ba94..2156254e0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddls16.c b/gcc/testsuite/gcc.target/arm/neon/vaddls16.c
index 042eb51eb..0ee3e4908 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddls32.c b/gcc/testsuite/gcc.target/arm/neon/vaddls32.c
index b2364250e..3cd0978cb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddls8.c b/gcc/testsuite/gcc.target/arm/neon/vaddls8.c
index b04da8a98..50e5197ac 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c b/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c
index 813a8714f..671fc9250 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c b/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c
index 9815f81ca..5a69ba320 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c b/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c
index 269f1c2c5..723b45e80 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vadds16.c b/gcc/testsuite/gcc.target/arm/neon/vadds16.c
index 2cf2e53aa..4f2250e8f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vadds16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vadds16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vadds32.c b/gcc/testsuite/gcc.target/arm/neon/vadds32.c
index a2ec12196..bc030289d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vadds32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vadds32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vadds64.c b/gcc/testsuite/gcc.target/arm/neon/vadds64.c
index 21a917dae..fb17e0ea3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vadds64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vadds64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vadds64 (void)
   out_int64x1_t = vadd_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vadds8.c b/gcc/testsuite/gcc.target/arm/neon/vadds8.c
index a14e94b6f..e928b1250 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vadds8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vadds8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddu16.c b/gcc/testsuite/gcc.target/arm/neon/vaddu16.c
index bcf484eae..9564df38e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddu32.c b/gcc/testsuite/gcc.target/arm/neon/vaddu32.c
index d92147666..2bc009e3b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddu64.c b/gcc/testsuite/gcc.target/arm/neon/vaddu64.c
index 6684785d3..18fc500b9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vaddu64 (void)
   out_uint64x1_t = vadd_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddu8.c b/gcc/testsuite/gcc.target/arm/neon/vaddu8.c
index c06ea4bc3..625931b3c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddws16.c b/gcc/testsuite/gcc.target/arm/neon/vaddws16.c
index 2ca47d0de..b99025334 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddws16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddws16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddws32.c b/gcc/testsuite/gcc.target/arm/neon/vaddws32.c
index 87a8090b3..447b8919b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddws32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddws32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddws8.c b/gcc/testsuite/gcc.target/arm/neon/vaddws8.c
index 1ebe6a856..f604c1ebf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddws8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddws8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c b/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c
index bfea209aa..f374bef96 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c b/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c
index 738171969..211f79897 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c b/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c
index f87802bee..ae9601608 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandQs16.c b/gcc/testsuite/gcc.target/arm/neon/vandQs16.c
index b3778cf52..87c030442 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandQs32.c b/gcc/testsuite/gcc.target/arm/neon/vandQs32.c
index b153d2cd6..3ae1a5218 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandQs64.c b/gcc/testsuite/gcc.target/arm/neon/vandQs64.c
index 6a804e5e7..cca486875 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandQs8.c b/gcc/testsuite/gcc.target/arm/neon/vandQs8.c
index bcc3c6fa4..4d0ce17cb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandQu16.c b/gcc/testsuite/gcc.target/arm/neon/vandQu16.c
index 4f1b03c77..ff7d646a3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandQu32.c b/gcc/testsuite/gcc.target/arm/neon/vandQu32.c
index 3979f264c..a99a525b1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandQu64.c b/gcc/testsuite/gcc.target/arm/neon/vandQu64.c
index cc523d809..2484dd04c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandQu8.c b/gcc/testsuite/gcc.target/arm/neon/vandQu8.c
index 84f098524..c20979fcb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vands16.c b/gcc/testsuite/gcc.target/arm/neon/vands16.c
index ee77d193b..dbb2c622f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vands16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vands16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vands32.c b/gcc/testsuite/gcc.target/arm/neon/vands32.c
index 26abfdff6..61c0c4113 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vands32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vands32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vands64.c b/gcc/testsuite/gcc.target/arm/neon/vands64.c
index 5a680a897..13e18fb0c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vands64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vands64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vands64 (void)
   out_int64x1_t = vand_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vands8.c b/gcc/testsuite/gcc.target/arm/neon/vands8.c
index 6404bf515..526a50072 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vands8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vands8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandu16.c b/gcc/testsuite/gcc.target/arm/neon/vandu16.c
index 470c90fa0..5c998856f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandu32.c b/gcc/testsuite/gcc.target/arm/neon/vandu32.c
index f8369cf38..8a936e673 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandu64.c b/gcc/testsuite/gcc.target/arm/neon/vandu64.c
index 6c1c0ee10..d9ddf847a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vandu64 (void)
   out_uint64x1_t = vand_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vandu8.c b/gcc/testsuite/gcc.target/arm/neon/vandu8.c
index fa4cfb6b6..728c5a6d1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vandu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vandu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c b/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c
index 2da6e98e2..e15a260ef 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c b/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c
index 0457f4019..f376bf077 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c b/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c
index 22095ccb3..87049f129 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c b/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c
index 4baa0e2be..4f64e8817 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c b/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c
index 4ae91ea48..f92f9b384 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c b/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c
index 2c74f88e5..06d10da23 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c b/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c
index 61839b92a..7cd63c035 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c b/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c
index b39f91caf..3f44418d7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbics16.c b/gcc/testsuite/gcc.target/arm/neon/vbics16.c
index f8b5cb13f..943e30534 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbics16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbics16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbics32.c b/gcc/testsuite/gcc.target/arm/neon/vbics32.c
index 63e854cee..30df639e3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbics32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbics32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbics64.c b/gcc/testsuite/gcc.target/arm/neon/vbics64.c
index 10a0b5a11..379db45f4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbics64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbics64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vbics64 (void)
   out_int64x1_t = vbic_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbics8.c b/gcc/testsuite/gcc.target/arm/neon/vbics8.c
index d1e6db56b..3b4bc8a8d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbics8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbics8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicu16.c b/gcc/testsuite/gcc.target/arm/neon/vbicu16.c
index c961e8026..e9952bc52 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicu32.c b/gcc/testsuite/gcc.target/arm/neon/vbicu32.c
index 8c95eb4e1..9334f403f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicu64.c b/gcc/testsuite/gcc.target/arm/neon/vbicu64.c
index e77701680..c276d65eb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vbicu64 (void)
   out_uint64x1_t = vbic_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbicu8.c b/gcc/testsuite/gcc.target/arm/neon/vbicu8.c
index c121432a9..5e42c5237 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbicu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbicu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c b/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c
index 76e50053e..33bc0257e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c b/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c
index ba97cbe61..06db6555d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c b/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c
index 475739a6d..52d498b8f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c b/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c
index 6780fdad0..f8f090f52 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c b/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c
index 6f2835caa..194ecdb35 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c b/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c
index 017f07370..cba963da0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c b/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c
index e2ed40219..fe8a64c5d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c b/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c
index 99d379c30..121ce1edc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c b/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c
index 7fc71bd76..dc213f1a8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c b/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c
index 89e19ea70..6635e652f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c b/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c
index c2ea8dd96..0fc6eb820 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslf32.c b/gcc/testsuite/gcc.target/arm/neon/vbslf32.c
index edbe7dfc1..ea8750da5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslp16.c b/gcc/testsuite/gcc.target/arm/neon/vbslp16.c
index bd02dac04..632fea22f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslp8.c b/gcc/testsuite/gcc.target/arm/neon/vbslp8.c
index 2456c53d2..a867a3b12 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbsls16.c b/gcc/testsuite/gcc.target/arm/neon/vbsls16.c
index f21d509b1..849b8ff85 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbsls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbsls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbsls32.c b/gcc/testsuite/gcc.target/arm/neon/vbsls32.c
index 81a797525..734560180 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbsls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbsls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbsls64.c b/gcc/testsuite/gcc.target/arm/neon/vbsls64.c
index fd5e6842a..79516cd89 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbsls64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbsls64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbsls8.c b/gcc/testsuite/gcc.target/arm/neon/vbsls8.c
index 1e7b39a36..7cfd379b9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbsls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbsls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslu16.c b/gcc/testsuite/gcc.target/arm/neon/vbslu16.c
index 8c6480f32..aef15fa6f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslu32.c b/gcc/testsuite/gcc.target/arm/neon/vbslu32.c
index 16938cd37..e04e349ae 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslu64.c b/gcc/testsuite/gcc.target/arm/neon/vbslu64.c
index 1370691f6..a4a53af2e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vbslu8.c b/gcc/testsuite/gcc.target/arm/neon/vbslu8.c
index a3ab7662c..154ea961d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vbslu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vbslu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c
index 667f0c4ff..8b5995525 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcagef32.c b/gcc/testsuite/gcc.target/arm/neon/vcagef32.c
index 58feeadc3..0d45e320e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcagef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcagef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c
index 6ef7e1450..cef77b38c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c b/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c
index a6bc406cd..89b875927 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c
index b26f68d4c..8cfef154d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcalef32.c b/gcc/testsuite/gcc.target/arm/neon/vcalef32.c
index 8a3b87db1..1101fde68 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcalef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcalef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c
index 6bab9d7c8..1d2cf7445 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c b/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c
index 7862aa485..6a8a8171e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c b/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c
index f8666c297..14ad3e7dd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c b/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c
index 5c7976c5c..80a8f6233 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c b/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c
index d072120d3..843bfe0ee 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c b/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c
index 5e6e2a5f9..f25faa5ff 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c b/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c
index 3b141ec2e..77bda24d5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c b/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c
index 85a0d890d..c6293f285 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c b/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c
index 20824d43e..7090033be 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c b/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c
index 7a1bb2592..3ff24d546 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqf32.c b/gcc/testsuite/gcc.target/arm/neon/vceqf32.c
index 5f341e6ff..b150b32c1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqp8.c b/gcc/testsuite/gcc.target/arm/neon/vceqp8.c
index 8a9496041..2e4e608d8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqs16.c b/gcc/testsuite/gcc.target/arm/neon/vceqs16.c
index 6bb327628..3cf450228 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqs32.c b/gcc/testsuite/gcc.target/arm/neon/vceqs32.c
index 254cb0737..989484130 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vceqs8.c b/gcc/testsuite/gcc.target/arm/neon/vceqs8.c
index f54eb7703..825214ae4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vceqs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vceqs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcequ16.c b/gcc/testsuite/gcc.target/arm/neon/vcequ16.c
index f183aa562..b7dd5450d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcequ16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcequ16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcequ32.c b/gcc/testsuite/gcc.target/arm/neon/vcequ32.c
index 2c15f6fb5..7864cfdf8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcequ32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcequ32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcequ8.c b/gcc/testsuite/gcc.target/arm/neon/vcequ8.c
index 049158578..8b8b26fba 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcequ8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcequ8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c
index 52d77b3e8..b0eb53cfc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c
index 97c6ba820..2ef989ac1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c
index e0d33743e..2bef01abb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c
index d655943d5..15083d35e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c
index 58887c8bb..59c609b65 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c
index af891ba48..fa4d67cf1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c b/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c
index a42747c46..39dee295c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgef32.c b/gcc/testsuite/gcc.target/arm/neon/vcgef32.c
index 6b3e502c6..797f43f6a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcges16.c b/gcc/testsuite/gcc.target/arm/neon/vcges16.c
index 7294f37ab..52984c796 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcges16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcges16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcges32.c b/gcc/testsuite/gcc.target/arm/neon/vcges32.c
index 3310b9e8c..935bde799 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcges32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcges32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcges8.c b/gcc/testsuite/gcc.target/arm/neon/vcges8.c
index d4f2b4e8b..15abad3fa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcges8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcges8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c b/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c
index 1ddc763f3..ec96ebc74 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c b/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c
index dd18404c3..12c67bf7f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c b/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c
index 38484e16b..5457b91a0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c
index 2fecd4f6a..9f6e6dc2d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c
index d6830cb52..b733e6ffa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c
index b6ad60d4f..eae07ad12 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c
index 357e33ee2..2f82a9539 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c
index 875e30ffb..080a7af7f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c
index 691a65dc6..0dfb361b4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c b/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c
index d5148f776..0643e22e8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c b/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c
index ea5a97d72..833bf1f55 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgts16.c b/gcc/testsuite/gcc.target/arm/neon/vcgts16.c
index 24ae89b5d..141df1061 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgts16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgts16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgts32.c b/gcc/testsuite/gcc.target/arm/neon/vcgts32.c
index b724e6669..6350041d7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgts32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgts32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgts8.c b/gcc/testsuite/gcc.target/arm/neon/vcgts8.c
index 9ab5955b8..1ad43968a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgts8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgts8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c b/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c
index c13c5cb29..e3b2c80c1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c b/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c
index a9e709d0c..60e6a9f1b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c b/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c
index 0c4a6aa59..858647548 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c
index 6adad811d..770da7b04 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c b/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c
index 076ae2de1..f4f69e2b4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c b/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c
index e0ac85874..49d6cc0f8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c b/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c
index 20fe30c78..32447e67a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c b/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c
index 8d264811c..3c8ae5217 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c b/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c
index 627078190..e2556e38e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c b/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c
index 38500e088..48e3ee239 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclef32.c b/gcc/testsuite/gcc.target/arm/neon/vclef32.c
index 02256e753..88fa76483 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcles16.c b/gcc/testsuite/gcc.target/arm/neon/vcles16.c
index 029d2a0a0..885c5d510 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcles16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcles16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcles32.c b/gcc/testsuite/gcc.target/arm/neon/vcles32.c
index f29b6eede..5bbd0d2d6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcles32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcles32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcles8.c b/gcc/testsuite/gcc.target/arm/neon/vcles8.c
index d3de08f2a..e247608db 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcles8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcles8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcleu16.c b/gcc/testsuite/gcc.target/arm/neon/vcleu16.c
index f6d8f805a..6fcacbadd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcleu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcleu32.c b/gcc/testsuite/gcc.target/arm/neon/vcleu32.c
index 853222033..568f56f99 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcleu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcleu8.c b/gcc/testsuite/gcc.target/arm/neon/vcleu8.c
index 6043941ea..81884bf72 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcleu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcleu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c b/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c
index 34ab6f438..22009dce0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c b/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c
index 2db0d672f..a4e2d70c2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c b/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c
index 191a2d009..91394e198 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclss16.c b/gcc/testsuite/gcc.target/arm/neon/vclss16.c
index c765308b6..c98508412 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclss16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclss16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclss32.c b/gcc/testsuite/gcc.target/arm/neon/vclss32.c
index 1eae0d404..4f3e16f88 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclss32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclss32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclss8.c b/gcc/testsuite/gcc.target/arm/neon/vclss8.c
index 9c405a876..3c363745f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclss8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclss8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c b/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c
index 7cdb46ab0..1616849a1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c b/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c
index e7bfb19bf..794d2c4b2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c b/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c
index abe15d2ca..871519b14 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c b/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c
index 209bdee63..41d32111f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c b/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c
index 03d1abbc6..209bc3d0a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c b/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c
index 221fe483a..797c62a81 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c b/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c
index 69c63fd6e..5a067fedf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltf32.c b/gcc/testsuite/gcc.target/arm/neon/vcltf32.c
index ad0463bc0..82ef84fb6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclts16.c b/gcc/testsuite/gcc.target/arm/neon/vclts16.c
index 65cf14e50..b6aaeabb3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclts16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclts16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclts32.c b/gcc/testsuite/gcc.target/arm/neon/vclts32.c
index a349dce64..cb66ca98e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclts32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclts32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclts8.c b/gcc/testsuite/gcc.target/arm/neon/vclts8.c
index 48f2bfb55..60bbf636c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclts8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclts8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltu16.c b/gcc/testsuite/gcc.target/arm/neon/vcltu16.c
index b98f8bb53..e5d2918cb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltu32.c b/gcc/testsuite/gcc.target/arm/neon/vcltu32.c
index cd219eea9..936e6b867 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcltu8.c b/gcc/testsuite/gcc.target/arm/neon/vcltu8.c
index 88f66a251..ab73e1f18 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcltu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcltu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c b/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c
index 11cb6c504..24df7b676 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c b/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c
index 13ffe35c7..1e01ee9e4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c b/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c
index 80040052f..80e40fd86 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c b/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c
index 23069ad99..2b023fa24 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c b/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c
index 48d27fdb6..529cbcf58 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c b/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c
index f5249ef0e..2be4915ea 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzs16.c b/gcc/testsuite/gcc.target/arm/neon/vclzs16.c
index 004dce96f..b024559f4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzs32.c b/gcc/testsuite/gcc.target/arm/neon/vclzs32.c
index 5b650f367..b01e429c3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzs8.c b/gcc/testsuite/gcc.target/arm/neon/vclzs8.c
index 460f1ff49..b23be0c1d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzu16.c b/gcc/testsuite/gcc.target/arm/neon/vclzu16.c
index 90fb91bb0..4f2516326 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzu32.c b/gcc/testsuite/gcc.target/arm/neon/vclzu32.c
index 1b7fffc95..4dd898345 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vclzu8.c b/gcc/testsuite/gcc.target/arm/neon/vclzu8.c
index df256ce1e..4bfe49878 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vclzu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vclzu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c b/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c
index 5622ffc9e..15a4f7154 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c b/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c
index 61d13f20c..fb6511903 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c b/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c
index 4a72cbb1a..dea80786b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcntp8.c b/gcc/testsuite/gcc.target/arm/neon/vcntp8.c
index 39acf6e06..39e0d1100 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcntp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcntp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcnts8.c b/gcc/testsuite/gcc.target/arm/neon/vcnts8.c
index cc51c60f3..89ae7b7b9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcnts8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcnts8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcntu8.c b/gcc/testsuite/gcc.target/arm/neon/vcntu8.c
index 925f74147..9a5f2f045 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcntu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcntu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombinef32.c b/gcc/testsuite/gcc.target/arm/neon/vcombinef32.c
index 4e6236c0d..a177288dd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombinef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombinef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombinep16.c b/gcc/testsuite/gcc.target/arm/neon/vcombinep16.c
index 5d966ee52..79b4440b5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombinep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombinep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombinep8.c b/gcc/testsuite/gcc.target/arm/neon/vcombinep8.c
index 4c5b7e408..0fa1af6df 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombinep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombinep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombines16.c b/gcc/testsuite/gcc.target/arm/neon/vcombines16.c
index 066bd8c9c..9799f99b1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombines16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombines16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombines32.c b/gcc/testsuite/gcc.target/arm/neon/vcombines32.c
index e20b4c429..d68676c3f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombines32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombines32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombines64.c b/gcc/testsuite/gcc.target/arm/neon/vcombines64.c
index 2a36c3130..389941540 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombines64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombines64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombines8.c b/gcc/testsuite/gcc.target/arm/neon/vcombines8.c
index 16985c64b..b3c8d3a7b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombines8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombines8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombineu16.c b/gcc/testsuite/gcc.target/arm/neon/vcombineu16.c
index 3a850b057..f35528b6a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombineu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombineu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombineu32.c b/gcc/testsuite/gcc.target/arm/neon/vcombineu32.c
index bf4689918..9c10e8597 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombineu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombineu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombineu64.c b/gcc/testsuite/gcc.target/arm/neon/vcombineu64.c
index b9417c480..fac517b48 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombineu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombineu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcombineu8.c b/gcc/testsuite/gcc.target/arm/neon/vcombineu8.c
index 156b67855..808a9f299 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcombineu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcombineu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreatef32.c b/gcc/testsuite/gcc.target/arm/neon/vcreatef32.c
index bbd88782a..68fe67e50 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreatef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreatef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreatep16.c b/gcc/testsuite/gcc.target/arm/neon/vcreatep16.c
index 3a90e4dae..b02247259 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreatep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreatep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreatep8.c b/gcc/testsuite/gcc.target/arm/neon/vcreatep8.c
index c91a1dc70..7a3f607dc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreatep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreatep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreates16.c b/gcc/testsuite/gcc.target/arm/neon/vcreates16.c
index 912d19b04..2adfeb31e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreates16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreates16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreates32.c b/gcc/testsuite/gcc.target/arm/neon/vcreates32.c
index 18455b3d0..4212dcba5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreates32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreates32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreates64.c b/gcc/testsuite/gcc.target/arm/neon/vcreates64.c
index a46d2c26f..77e4a51b9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreates64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreates64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreates8.c b/gcc/testsuite/gcc.target/arm/neon/vcreates8.c
index eb13d0822..0c0d546aa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreates8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreates8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreateu16.c b/gcc/testsuite/gcc.target/arm/neon/vcreateu16.c
index e7f78b4b5..d8004802b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreateu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreateu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreateu32.c b/gcc/testsuite/gcc.target/arm/neon/vcreateu32.c
index 5014d0f22..42d72adc3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreateu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreateu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreateu64.c b/gcc/testsuite/gcc.target/arm/neon/vcreateu64.c
index 917fe77ee..5b0b37865 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreateu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreateu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcreateu8.c b/gcc/testsuite/gcc.target/arm/neon/vcreateu8.c
index d47561868..ea4114617 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcreateu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcreateu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c
index 90fbf2b0e..85916e770 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c
index 483d5a894..ab20ff0ed 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c
index 0f111f541..76ce86a0a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c
index 4f2a40719..16de37fe1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c
index bd81d8b5c..1160edeab 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c
index 8ccf41ef2..285e1dd89 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c
index f6e762363..562137430 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c
index 6d1eed6fc..f2ea8f541 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c
index fee5b805d..403fe621c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c
index 24e1e5f0e..dc344a3ab 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c
index 526b95035..b50b20e01 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c
index 059e3de10..b003f0097 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c
index fe71a254f..e0ca9b062 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c
index d257a46ca..b3b44bedf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c
index e6b6d91d8..b626fbf74 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c
index 6f331e959..8c86d47af 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c
index 30f8fee5b..8593d871a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c
index bc923571d..b48966b76 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c
index edba0c156..ebe7a0da5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c
index b987ac112..dae7cb568 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c
index 1180bce9b..4ef5cb789 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes64.c
index 568bf7a08..9c41050e0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c
index 114bf3251..428dfc404 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c
index 73a173cf8..840e6e2b8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c
index 1266c9f86..76f3c756f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu64.c
index ec7742f15..8a6487135 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c
index 14b3d5b80..c4886e62d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c
index c38959a3f..5f7305aca 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdupQ_nf32 (void)
   out_float32x4_t = vdupq_n_f32 (arg0_float32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c
index 6e3e72641..bd73329cc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdupQ_np16 (void)
   out_poly16x8_t = vdupq_n_p16 (arg0_poly16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c
index 647ff2c08..7c90d560d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdupQ_np8 (void)
   out_poly8x16_t = vdupq_n_p8 (arg0_poly8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c
index 1fb27efb7..de837d919 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdupQ_ns16 (void)
   out_int16x8_t = vdupq_n_s16 (arg0_int16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c
index a0e8f7f91..00f175cec 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdupQ_ns32 (void)
   out_int32x4_t = vdupq_n_s32 (arg0_int32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c
index 7147960f4..ab749a7bb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,6 +16,4 @@ void test_vdupQ_ns64 (void)
   out_int64x2_t = vdupq_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c
index 6f2aea7bd..3794d6eb1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdupQ_ns8 (void)
   out_int8x16_t = vdupq_n_s8 (arg0_int8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c
index bbf502016..fed6ea227 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdupQ_nu16 (void)
   out_uint16x8_t = vdupq_n_u16 (arg0_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c
index e14933578..5b96fbcdd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdupQ_nu32 (void)
   out_uint32x4_t = vdupq_n_u32 (arg0_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c
index d989e6f58..0ddb72dec 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,6 +16,4 @@ void test_vdupQ_nu64 (void)
   out_uint64x2_t = vdupq_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c
index 81cf6264f..a490472fb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdupQ_nu8 (void)
   out_uint8x16_t = vdupq_n_u8 (arg0_uint8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c
index 4f21c51e0..495f189bf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c
index eba3a1b39..f951fac35 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c
index 90bdc97cc..dad99e4fd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c
index ee7f855e1..046d440ca 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c
index f16262410..f249a626a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes64.c
index 5d26382a9..628140fd3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c
index 8874bc836..9ca250152 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c
index 244b5a258..1b3dd02a2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c
index 8fd5c6a59..520757873 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu64.c
index 5939b33c3..a9de614c2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c
index 2ba6a866d..5687c0b47 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c
index 277b200f9..ba99fdce5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdup_nf32 (void)
   out_float32x2_t = vdup_n_f32 (arg0_float32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c
index 76f1c1740..55bca29b9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdup_np16 (void)
   out_poly16x4_t = vdup_n_p16 (arg0_poly16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c
index ea66a607d..80d29e860 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdup_np8 (void)
   out_poly8x8_t = vdup_n_p8 (arg0_poly8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c
index 89794c3e6..4d1ea6a6e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdup_ns16 (void)
   out_int16x4_t = vdup_n_s16 (arg0_int16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c
index 8b0fed938..9fb1fc289 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdup_ns32 (void)
   out_int32x2_t = vdup_n_s32 (arg0_int32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c
index 53b71216a..033f1b474 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,4 @@ void test_vdup_ns64 (void)
   out_int64x1_t = vdup_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c
index 0d39eec6d..eba462c79 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdup_ns8 (void)
   out_int8x8_t = vdup_n_s8 (arg0_int8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c
index eb02c3766..24015e592 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdup_nu16 (void)
   out_uint16x4_t = vdup_n_u16 (arg0_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c
index 84e8c76fe..78374d42a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdup_nu32 (void)
   out_uint32x2_t = vdup_n_u32 (arg0_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c
index 863fc785c..6888125c6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,4 @@ void test_vdup_nu64 (void)
   out_uint64x1_t = vdup_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c
index 4d6ab331a..ee35ff37b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vdup_nu8 (void)
   out_uint8x8_t = vdup_n_u8 (arg0_uint8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/veorQs16.c b/gcc/testsuite/gcc.target/arm/neon/veorQs16.c
index a2f4ece04..a0428bee7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veorQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veorQs32.c b/gcc/testsuite/gcc.target/arm/neon/veorQs32.c
index 8f9cacb19..7b24ea477 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veorQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veorQs64.c b/gcc/testsuite/gcc.target/arm/neon/veorQs64.c
index e50bd8c60..fd023171a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veorQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veorQs8.c b/gcc/testsuite/gcc.target/arm/neon/veorQs8.c
index be5c56b8a..17da85c6b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veorQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veorQu16.c b/gcc/testsuite/gcc.target/arm/neon/veorQu16.c
index 6ef6b6a8b..d2865e9fb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veorQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veorQu32.c b/gcc/testsuite/gcc.target/arm/neon/veorQu32.c
index b95ac5039..76370677d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veorQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veorQu64.c b/gcc/testsuite/gcc.target/arm/neon/veorQu64.c
index f9f8b1317..156b07b34 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veorQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veorQu8.c b/gcc/testsuite/gcc.target/arm/neon/veorQu8.c
index 4aa85679e..b3ff98343 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veorQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veorQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veors16.c b/gcc/testsuite/gcc.target/arm/neon/veors16.c
index d6e488f6d..8af437edf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veors16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veors16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veors32.c b/gcc/testsuite/gcc.target/arm/neon/veors32.c
index 6b897db41..105780393 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veors32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veors32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veors64.c b/gcc/testsuite/gcc.target/arm/neon/veors64.c
index b82f054e8..2781be1b2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veors64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veors64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_veors64 (void)
   out_int64x1_t = veor_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/veors8.c b/gcc/testsuite/gcc.target/arm/neon/veors8.c
index 8a33c1e1d..cda05c7e6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veors8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veors8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veoru16.c b/gcc/testsuite/gcc.target/arm/neon/veoru16.c
index 418cf80f8..d89d87302 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veoru16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veoru16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veoru32.c b/gcc/testsuite/gcc.target/arm/neon/veoru32.c
index 06f843739..7804a8c16 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veoru32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veoru32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/veoru64.c b/gcc/testsuite/gcc.target/arm/neon/veoru64.c
index d73173ecd..19d081489 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veoru64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veoru64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_veoru64 (void)
   out_uint64x1_t = veor_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/veoru8.c b/gcc/testsuite/gcc.target/arm/neon/veoru8.c
index 87001b746..aad32de44 100644
--- a/gcc/testsuite/gcc.target/arm/neon/veoru8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/veoru8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQf32.c b/gcc/testsuite/gcc.target/arm/neon/vextQf32.c
index e7d67ce74..92597f9bd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQp16.c b/gcc/testsuite/gcc.target/arm/neon/vextQp16.c
index 8714a1c3f..546da6990 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQp8.c b/gcc/testsuite/gcc.target/arm/neon/vextQp8.c
index b33fbaf04..f9273c2d1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQs16.c b/gcc/testsuite/gcc.target/arm/neon/vextQs16.c
index 81e157bc4..d95ff2976 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQs32.c b/gcc/testsuite/gcc.target/arm/neon/vextQs32.c
index bb964dd5f..b6824ff6b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQs64.c b/gcc/testsuite/gcc.target/arm/neon/vextQs64.c
index dd57bf305..226aa207f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQs8.c b/gcc/testsuite/gcc.target/arm/neon/vextQs8.c
index 2f334cb91..274279a2d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQu16.c b/gcc/testsuite/gcc.target/arm/neon/vextQu16.c
index de8d65ae7..36fcb5273 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQu32.c b/gcc/testsuite/gcc.target/arm/neon/vextQu32.c
index bac73954e..082592a0a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQu64.c b/gcc/testsuite/gcc.target/arm/neon/vextQu64.c
index 31ef034e7..ac496db0d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextQu8.c b/gcc/testsuite/gcc.target/arm/neon/vextQu8.c
index a894ccef8..e77b9a2e3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextf32.c b/gcc/testsuite/gcc.target/arm/neon/vextf32.c
index 53218b287..5f7ef947c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextp16.c b/gcc/testsuite/gcc.target/arm/neon/vextp16.c
index a352a6e8d..f1e176efb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextp8.c b/gcc/testsuite/gcc.target/arm/neon/vextp8.c
index 5465cc487..feb2fdd07 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vexts16.c b/gcc/testsuite/gcc.target/arm/neon/vexts16.c
index 0aa791b5e..1d3eb7980 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vexts16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vexts16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vexts32.c b/gcc/testsuite/gcc.target/arm/neon/vexts32.c
index 1087e8aa8..e83a0de6a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vexts32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vexts32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vexts64.c b/gcc/testsuite/gcc.target/arm/neon/vexts64.c
index ca0256da8..e594beca5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vexts64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vexts64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vexts8.c b/gcc/testsuite/gcc.target/arm/neon/vexts8.c
index 145f80930..0575bd349 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vexts8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vexts8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextu16.c b/gcc/testsuite/gcc.target/arm/neon/vextu16.c
index ca751abfe..b94afdf61 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextu32.c b/gcc/testsuite/gcc.target/arm/neon/vextu32.c
index 4a3d01ef4..39bdf31ff 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextu64.c b/gcc/testsuite/gcc.target/arm/neon/vextu64.c
index 3f37d94ea..17afbd751 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vextu8.c b/gcc/testsuite/gcc.target/arm/neon/vextu8.c
index e2dcc5925..5176a7201 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vextu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vextu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c b/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c
new file mode 100644
index 000000000..7ddf4a3af
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c
@@ -0,0 +1,27 @@
+/* Check that NEON vector shifts support immediate values == size.  /*
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-add-options arm_neon } */
+
+#include <arm_neon.h>
+
+uint16x8_t test_vshll_n_u8 (uint8x8_t a)
+{
+    return vshll_n_u8(a, 8);
+}
+
+uint32x4_t test_vshll_n_u16 (uint16x4_t a)
+{   
+    return vshll_n_u16(a, 16);
+}
+
+uint64x2_t test_vshll_n_u32 (uint32x2_t a)
+{
+    return vshll_n_u32(a, 32);
+}
+
+/* { dg-final { scan-assembler "vshll\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c
index 4d0561b1e..54e04c50a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c
index a18a38452..cfb5447bf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c
index 2e6c7d29b..7325dd744 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c
index f341ae0e3..f992d17a8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c
index 0f87fdb3b..36cb88ff4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c
index ec361e795..b7f7f3350 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c
index fa2726a9f..7ce2cc651 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c
index 2c2a94063..d44f05f2b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c
index 5a9344a80..3004f503c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c
index 8cdab031f..33c463e64 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c
index df63fc110..57528f2f2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highf32.c b/gcc/testsuite/gcc.target/arm/neon/vget_highf32.c
index 5176c5bb0..60f935e97 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highp16.c b/gcc/testsuite/gcc.target/arm/neon/vget_highp16.c
index e58700839..660b83e34 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highp8.c b/gcc/testsuite/gcc.target/arm/neon/vget_highp8.c
index 0feab86eb..e9519606e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highs16.c b/gcc/testsuite/gcc.target/arm/neon/vget_highs16.c
index 786428a0b..ca4e7706e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highs32.c b/gcc/testsuite/gcc.target/arm/neon/vget_highs32.c
index 515ba139d..77ead1ac8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highs64.c b/gcc/testsuite/gcc.target/arm/neon/vget_highs64.c
index f191556f8..cb6a48480 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highs8.c b/gcc/testsuite/gcc.target/arm/neon/vget_highs8.c
index 1c057b7df..ec249f823 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highu16.c b/gcc/testsuite/gcc.target/arm/neon/vget_highu16.c
index d3f070244..263a920aa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highu32.c b/gcc/testsuite/gcc.target/arm/neon/vget_highu32.c
index bd9cb4bbc..4797a132e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highu64.c b/gcc/testsuite/gcc.target/arm/neon/vget_highu64.c
index b791863c8..899309f1a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_highu8.c b/gcc/testsuite/gcc.target/arm/neon/vget_highu8.c
index f8c804ba5..a0c689736 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_highu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_highu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c
index e469c6ec4..908adeb70 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c
index 22851e7b2..0dcf90b57 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c
index 83c9a15be..22b06bdf7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c
index d7feb6ec7..4a86bf465 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c
index 50b8f40cb..8559da7ea 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c
index f70a47793..5dc99424f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,4 @@ void test_vget_lanes64 (void)
   out_int64_t = vget_lane_s64 (arg0_int64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[rR\]\[0-9\]+, \[rR\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c
index 86fcf63e3..be6110408 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c
index 363fa2ba4..66f645e32 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c
index fd09ad4d0..b19de8d28 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c
index 3f1891067..496a057fc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,4 @@ void test_vget_laneu64 (void)
   out_uint64_t = vget_lane_u64 (arg0_uint64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[rR\]\[0-9\]+, \[rR\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c
index f244a75c9..1affae83a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c
index a14a57636..81982d438 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c
index 5c130f0b4..395461196 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c
index 4b4f599fc..e4bf2f1d6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c b/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c
index ee6e9904b..d2a07c63e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c b/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c
index 08315286d..4278e2bcb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lows64.c b/gcc/testsuite/gcc.target/arm/neon/vget_lows64.c
index 9c1440ceb..53d26e7e4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lows64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lows64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c b/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c
index 7d324f337..a4ad63371 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c
index b0c438453..c9e0a51a6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c
index fdd8e79e9..841a619cf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c
index e6f7627cb..ab2b42c2c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c b/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c
index d4e3c714d..fd2537bbf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c
index 69e15afc3..2bd30cd1b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c
index 76f5c0a94..04bbf03bd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c
index 403c77c54..86c3db518 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c
index aebfc02cb..75aae10e7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c
index 72f237395..c7ec45a2f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c b/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c
index bcfe44c09..8668d141b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhadds16.c b/gcc/testsuite/gcc.target/arm/neon/vhadds16.c
index d412ccced..61344cff5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhadds16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhadds16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhadds32.c b/gcc/testsuite/gcc.target/arm/neon/vhadds32.c
index db1749e03..03d090292 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhadds32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhadds32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhadds8.c b/gcc/testsuite/gcc.target/arm/neon/vhadds8.c
index 086f5690a..90e79daa7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhadds8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhadds8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c b/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c
index 1f230e136..971778b78 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c b/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c
index fbdc8efb5..70865fad0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c b/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c
index 38b82bc9e..b541b87d1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c
index df790e430..5647c6297 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c
index 044217375..44e780e01 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c
index b98ada251..8162a1014 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c
index b8ded58eb..1a84876ed 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c
index f8e2bfe0b..ae52afd29 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c b/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c
index b3ca8b4f5..ef43a4f3f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c b/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c
index 841f9f24b..786c8d389 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c b/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c
index 8564c4c7d..4c7e9c8b2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c b/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c
index 7bd4ec3fd..c8c1ada08 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c b/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c
index e5fab5165..bf83c7ce0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c b/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c
index ea6bf12d7..f224eaf07 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c b/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c
index d4569d83f..fe145a9b5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c
index 0989045f7..073d88f2b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c
index ba9e56fd2..1202e929a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c
index b914ff2a6..27d755097 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c
index 6be2a73f5..df1e00880 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c
index 37b47a667..b371299bd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c
index a7199f096..b4c3a8cc9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c
index b540c2d98..badeb3b80 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c
index 23a6adefb..d247fea56 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c
index 4b8c2ba60..1160f9820 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c
index 7c1f803a1..8cbc89c94 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c
index 94e47c299..c6d52a3d7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c
index c1bd1d9ee..bccdd26c2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c
index 2c0a1a9b1..f080107a6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c
index 171954966..4887ebcd0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c
index 9342b196b..aeb824c23 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c
index 3751aa641..90556ac9b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c
index b5fafa9f8..db68bd087 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c
index 44c39177b..3494c077d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c
index 19fd69f98..eb791e7d3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c
index b66d4e418..3841c9b96 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c
index ef77c5b9b..082e6a625 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c
index 70f1b6e3b..194f74912 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c
index d41bfc68f..1c84b9127 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c
index 2be07496d..f470da6bc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c
index f6ddd396e..a46d48bc2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c
index 790c3714b..39ab3fe55 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c
index 66c28eb01..e12e8d97a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c
index 4ee914516..1c6aca4a8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c
index 28aad33fb..64e6b0064 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c
index cbf758c18..191deb0d7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c
index 6f7c45aa4..e3e01a612 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c
index 90a191b3b..24b55bab1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c
index b55be21ac..47e6ad07d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c
index dc0380180..41eec0ef0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c
index cb87a398b..b38b29c72 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c
index 9dd5be305..69017c4ac 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c
index ca5b29153..61e0377fa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c
index b5652054f..0429ee513 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c
index 723ae79e8..90ee403d6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c
index ca78ecf5b..aacac04bb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c
index f6ffab61f..64d736298 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c
index 8a769b06c..6f3fd967e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c
index 8108c6d49..262147d79 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c
index dac97a6b4..6038bec9c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c
index 512db1c10..3d4b0a4de 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c
index 60abc9b2d..832abbd2a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c
index 60b2f1ece..04823322e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c
index 25f07cf93..571f87673 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c
index a166c431d..057a7ffc3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c
index 09b658a8c..1e46d6a1f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c
index 12eb7a0f9..eeebc9bbd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c
index 2295380cf..116a35f03 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c
index 6c540e131..f4907d202 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c
index 4507ae895..b5058b0f8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c
index 5dc352d83..caa08f637 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1f32.c b/gcc/testsuite/gcc.target/arm/neon/vld1f32.c
index 6b493547a..17deac967 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1p16.c b/gcc/testsuite/gcc.target/arm/neon/vld1p16.c
index 80c2240b6..ef2e73ac5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1p8.c b/gcc/testsuite/gcc.target/arm/neon/vld1p8.c
index 588ee4f2f..048bdeb06 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1s16.c b/gcc/testsuite/gcc.target/arm/neon/vld1s16.c
index cc8277b8b..39e12d76c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1s32.c b/gcc/testsuite/gcc.target/arm/neon/vld1s32.c
index 575bf39b8..80fbfd07d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1s64.c b/gcc/testsuite/gcc.target/arm/neon/vld1s64.c
index 0af7c1c20..3ea125d36 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1s8.c b/gcc/testsuite/gcc.target/arm/neon/vld1s8.c
index d63836b4d..599c32345 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1u16.c b/gcc/testsuite/gcc.target/arm/neon/vld1u16.c
index 6419661cf..550ca118b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1u32.c b/gcc/testsuite/gcc.target/arm/neon/vld1u32.c
index 20306f3f0..e0b673cf8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1u64.c b/gcc/testsuite/gcc.target/arm/neon/vld1u64.c
index f992088a9..eba002cd7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld1u8.c b/gcc/testsuite/gcc.target/arm/neon/vld1u8.c
index d8bac1f49..a63bcf2cd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld1u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld1u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c
index c2c32cc04..de05fd78f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c
index 5b5dec000..30dd2d9b7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c
index 43582692c..bc256dd67 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c
index 27c4ee83f..bf184df22 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c
index 909df9693..37919becf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c
index 72cdaa92c..d42638cd1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c
index dcd895a47..6e7d1d3d5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c
index 96d74ebe6..18ee43169 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c
index 6d51f75ce..4751de7b8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c
index 01c80a087..638f24acc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c
index cd1d22b9c..51d7dc87f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c
index b67f87a55..b3fb47d55 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c
index a5f7b0b90..7955de6ae 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c
index 9b4e1c089..6099c06c6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c
index 952cf65f6..82632ed38 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c
index ffba7c837..aa74e38ec 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c
index 1e40efcc6..71be4c127 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c
index f33424f26..17d4ec1b7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c
index e647bab93..128e715be 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c
index 818a5bfd1..41461be87 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c
index eaf82c307..e9d4b5382 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c
index 4fb209521..8b3f7979a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c
index 3ffdc1f99..6b9df90eb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c
index bed506a60..d34acecf5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c
index 5535a58d8..16b046574 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c
index 6722befce..94c80a981 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c
index 1daf7311b..2e02a2831 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c
index 5384d2c79..d52864b89 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c
index f26b55f3b..07938a187 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c
index f9596353c..c19aacf51 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c
index f3147c026..6394d9a34 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c
index 60de66309..603d3234c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c
index 9f5fbb1de..e6a873b12 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c
index 12425bd42..58e806faa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c
index 2c6fb34d4..b662354f8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2f32.c b/gcc/testsuite/gcc.target/arm/neon/vld2f32.c
index f66cd947a..75974376a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2p16.c b/gcc/testsuite/gcc.target/arm/neon/vld2p16.c
index f01c101b7..f166d3554 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2p8.c b/gcc/testsuite/gcc.target/arm/neon/vld2p8.c
index 972af50d3..612fab6fa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2s16.c b/gcc/testsuite/gcc.target/arm/neon/vld2s16.c
index 0c678bc7f..70f6af946 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2s32.c b/gcc/testsuite/gcc.target/arm/neon/vld2s32.c
index cc18c1922..4a84effcc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2s64.c b/gcc/testsuite/gcc.target/arm/neon/vld2s64.c
index 4534bc467..0a388d090 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2s8.c b/gcc/testsuite/gcc.target/arm/neon/vld2s8.c
index 36f18038c..110e88320 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2u16.c b/gcc/testsuite/gcc.target/arm/neon/vld2u16.c
index b1c7ab73e..f2e721bf8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2u32.c b/gcc/testsuite/gcc.target/arm/neon/vld2u32.c
index 3f01c2632..f0f069e98 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2u64.c b/gcc/testsuite/gcc.target/arm/neon/vld2u64.c
index 5f16b330a..1d2a3bccb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld2u8.c b/gcc/testsuite/gcc.target/arm/neon/vld2u8.c
index 9bdf75bc1..eb0c5a6d4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld2u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld2u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c
index dc02a4dee..6c6f52032 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c
index 3013d933a..e4e60bc65 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c
index df711767d..0456d3b4b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c
index fd1ceefb1..fca11ae20 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c
index fcf07f2cb..56c94b2f2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c
index 5f3e89256..a73a5a266 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c
index 97c499f78..458991769 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c
index 14c202e24..8c3e5beb4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c
index d58ee32fb..0197f5175 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c
index 6adc17603..ea7709690 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c
index 92f191c79..10896957f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c
index a9de5d6f7..ca389ad1c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c
index 50c4d51d0..efef26fd7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c
index 6678a87e2..077533c2b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c
index 6a97f7c24..c8093b8c1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c
index 2bbf936b1..e38a13541 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c
index 301888451..d9f3d14bc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c
index 76aba84c0..43c7fe8e2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c
index 08b7c09b1..8fec7c512 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c
index 016ade44f..1118d2467 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c
index 9292d59de..2e49c0ed9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c
index 959ea3d62..7327c9fca 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c
index 633fff514..d188fad75 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c
index 88133e44a..17436e047 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c
index 3eb502461..cedf05829 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c
index b9a0d9ebb..1ebe61594 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c
index 30590edad..3ee94ed0b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c
index ea1d05e49..3c8598869 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c
index 1f2674e43..f5f9761d0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c
index 076128c6f..51cf8a3cf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c
index bd3b3d6f7..59a29f77e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c
index 551cc39a3..e4513aeb9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c
index 13855ec6d..86a787c09 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c
index c3b274a9e..e4bca9e39 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c
index ddfabd3f5..554178a73 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3f32.c b/gcc/testsuite/gcc.target/arm/neon/vld3f32.c
index 7e52b37b4..ba18fe0d3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3p16.c b/gcc/testsuite/gcc.target/arm/neon/vld3p16.c
index 123deeb77..513a3ad77 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3p8.c b/gcc/testsuite/gcc.target/arm/neon/vld3p8.c
index 8fabf5e38..c93984ea7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3s16.c b/gcc/testsuite/gcc.target/arm/neon/vld3s16.c
index 2b7212ec3..f9e6212bd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3s32.c b/gcc/testsuite/gcc.target/arm/neon/vld3s32.c
index 9dfc6189c..cd1256649 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3s64.c b/gcc/testsuite/gcc.target/arm/neon/vld3s64.c
index b4b452709..5a62f84cc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3s8.c b/gcc/testsuite/gcc.target/arm/neon/vld3s8.c
index 2526f1906..b3c3125f9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3u16.c b/gcc/testsuite/gcc.target/arm/neon/vld3u16.c
index 54ea8b57d..0cd549986 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3u32.c b/gcc/testsuite/gcc.target/arm/neon/vld3u32.c
index d6ab84cb0..bdb66e000 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3u64.c b/gcc/testsuite/gcc.target/arm/neon/vld3u64.c
index f31c4804d..ba9465d4e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld3u8.c b/gcc/testsuite/gcc.target/arm/neon/vld3u8.c
index 3a6f3cc44..ec6e2a4db 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld3u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld3u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c
index 2d37f626d..9e596b71b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c
index 5af87b48a..3ca293a88 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c
index 355f11238..f6de5e378 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c
index d8908b68e..0c3c07151 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c
index 17750856f..301cf8f24 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c
index 78ffe9035..4ff7a9d7b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c
index 4ebabb3ed..2b59415cc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c
index 9f22715ad..510e0f20c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c
index b1ff16019..c89ae6349 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c
index 2416bf472..98f42705f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c
index 29e68e734..16d6133c6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c
index 8dc99383b..3a4620f78 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c
index d12817c9b..197adf811 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c
index 4122cb654..942ccfb74 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c
index bde99675a..93dad1603 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c
index b8e38be28..c7fe78ff6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c
index b5a990050..b88a76c2f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c
index d85c25276..cc9d17e70 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c
index 1b90af65b..c167f01c4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c
index bf448d200..8279d31b8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c
index 9c14ca182..30b1b2b9a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c
index 25f32d702..1775b524c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c
index f2d714fe6..43571141f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c
index 88ad8baae..aefcac61b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c
index 70186d89e..59f6e04c3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c
index c4332e55f..7ace026a5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c
index 88996ae7f..1fd272630 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c
index 5c11a675a..0f021aff0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c
index 2fdbbc869..a6d6a9f6a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c
index 370a256fe..3b29ec8c9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c
index b0baefd08..86383dbdb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c
index f3383ee30..80586c3d6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c
index 7cfddaf0f..4425b5e19 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c
index 3c9397d11..09d27220e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c
index ef429680a..5c1a76f28 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4f32.c b/gcc/testsuite/gcc.target/arm/neon/vld4f32.c
index 04a40c68e..e3315813e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4p16.c b/gcc/testsuite/gcc.target/arm/neon/vld4p16.c
index 7852b45e2..d5b415eca 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4p8.c b/gcc/testsuite/gcc.target/arm/neon/vld4p8.c
index a13719b67..785e86a2f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4s16.c b/gcc/testsuite/gcc.target/arm/neon/vld4s16.c
index bf50d09f8..b725e5d9c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4s32.c b/gcc/testsuite/gcc.target/arm/neon/vld4s32.c
index eaea85c12..eaa7b36d5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4s64.c b/gcc/testsuite/gcc.target/arm/neon/vld4s64.c
index f3572a9ab..3bc5e43f1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4s8.c b/gcc/testsuite/gcc.target/arm/neon/vld4s8.c
index 077650dec..94789dca9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4u16.c b/gcc/testsuite/gcc.target/arm/neon/vld4u16.c
index 7820fb353..bd4cef90b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4u32.c b/gcc/testsuite/gcc.target/arm/neon/vld4u32.c
index 32c821927..d98f0d476 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4u64.c b/gcc/testsuite/gcc.target/arm/neon/vld4u64.c
index f8946a58d..55418309a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vld4u8.c b/gcc/testsuite/gcc.target/arm/neon/vld4u8.c
index c66b105c3..af2e686e0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vld4u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vld4u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c
index 8af37bc2e..83a2f44d1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c
index 8de85673d..c8edb7bd6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c
index 0fb3731de..d40f05ee2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c
index b50939f0d..55fdce62b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c
index bfa6394f7..587a7f1c1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c
index 0ea042e2b..dbbe70cc8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c b/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c
index 7e53e6220..f785ac8d1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c
index f668f2433..ab8cacc3e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c b/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c
index 94a663930..047d77b49 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c
index 4ffbdc43b..43ff8874b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c b/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c
index b633aabdc..54cec995f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c b/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c
index 60b058b65..8970ba591 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c b/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c
index 0acc33a63..e7094cdff 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c b/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c
index 17a2ede6a..4e68c3426 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminQf32.c b/gcc/testsuite/gcc.target/arm/neon/vminQf32.c
index 3fe60bac5..c1a93c6f6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminQs16.c b/gcc/testsuite/gcc.target/arm/neon/vminQs16.c
index 07c413875..889bd4175 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminQs32.c b/gcc/testsuite/gcc.target/arm/neon/vminQs32.c
index 7bec8e75c..dd92bcc49 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminQs8.c b/gcc/testsuite/gcc.target/arm/neon/vminQs8.c
index fb7b544c3..dc62e26d5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminQu16.c b/gcc/testsuite/gcc.target/arm/neon/vminQu16.c
index be13f5ecc..8b32ee617 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminQu32.c b/gcc/testsuite/gcc.target/arm/neon/vminQu32.c
index 1ab6fc51a..bc2bb6a32 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminQu8.c b/gcc/testsuite/gcc.target/arm/neon/vminQu8.c
index 5039f2146..4f7c5c63d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminf32.c b/gcc/testsuite/gcc.target/arm/neon/vminf32.c
index 4f4e772d4..4b69eb92f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmins16.c b/gcc/testsuite/gcc.target/arm/neon/vmins16.c
index 2ada1c10e..33d080c73 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmins16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmins16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmins32.c b/gcc/testsuite/gcc.target/arm/neon/vmins32.c
index b0172fa02..ba9920272 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmins32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmins32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmins8.c b/gcc/testsuite/gcc.target/arm/neon/vmins8.c
index 99697d5c8..956729db5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmins8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmins8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminu16.c b/gcc/testsuite/gcc.target/arm/neon/vminu16.c
index 62a8367b0..eba01626f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminu32.c b/gcc/testsuite/gcc.target/arm/neon/vminu32.c
index a6b3dd042..079c4ca71 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vminu8.c b/gcc/testsuite/gcc.target/arm/neon/vminu8.c
index e53ea9d8f..0a2241821 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vminu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vminu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c
index a8dc703e2..594c1ebdc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c
index 45735bb46..151943896 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c
index 4567e5474..7ba19cb74 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c
index 2f816b7c2..d8885876a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c
index e01352e34..e96e9a7ff 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c
index 39fb23037..3e4057913 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c
index 54b5c86fc..28e0d462d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c
index 52c21915d..9b5ecf73b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c
index 2691478fc..94481f947 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c
index 2ad903e74..3b1926ab9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c
index 207b3300c..336d56967 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c
index f8d3d7289..339db8763 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c
index 52300484f..579b2921d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c
index 14597748f..f0e5b60e9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c
index 82b5e4493..246df1d8c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c
index 7b8bbed47..3108c90b7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c b/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c
index d6c22f54a..b87b44872 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c
index 65947891f..8d68f1c79 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c
index 0b3b49500..a426e1138 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c
index 67c03f326..998c06bdf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c
index 9a028e5f6..9274af803 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c
index 820410ca5..17e96cb82 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c
index b138b4f38..3a707c7d2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c
index 79c8cd76d..04f2493f2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c
index af04a34a8..464c09450 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c
index 66ed0b588..b2eb2ed11 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c
index 4574fbdd2..6f11e99a5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c
index 3da54850b..8b1ac6a97 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c
index d27decf86..61f3c7ba9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c
index 67d8651f0..d7348de60 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c
index 5645d066b..93fc8bf55 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c
index 6afa8e8dd..12103d125 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c
index 03e1f9710..968aef746 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c
index 9b7623295..d4b3e46be 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c
index 7b423f113..9bec57879 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c
index 4195d1ea6..4fadfe94f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlals16.c b/gcc/testsuite/gcc.target/arm/neon/vmlals16.c
index d3ccb6b2a..a62162000 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlals16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlals16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlals32.c b/gcc/testsuite/gcc.target/arm/neon/vmlals32.c
index 257462e2a..e64db5959 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlals32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlals32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlals8.c b/gcc/testsuite/gcc.target/arm/neon/vmlals8.c
index 8be8a4010..22f4bdbed 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlals8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlals8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c
index 614f314fa..874fd87b1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c
index 6d7c9e4e6..593c06b45 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c b/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c
index fbb30c644..efb4312cc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlas16.c b/gcc/testsuite/gcc.target/arm/neon/vmlas16.c
index 88630ba64..b37272b89 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlas16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlas16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlas32.c b/gcc/testsuite/gcc.target/arm/neon/vmlas32.c
index 281502d9c..65c2e9af2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlas32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlas32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlas8.c b/gcc/testsuite/gcc.target/arm/neon/vmlas8.c
index 05e17f3b8..fcb1fd38d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlas8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlas8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlau16.c b/gcc/testsuite/gcc.target/arm/neon/vmlau16.c
index a39e61d93..c1dceab97 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlau16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlau16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlau32.c b/gcc/testsuite/gcc.target/arm/neon/vmlau32.c
index 35943a9bd..6acbea572 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlau32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlau32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlau8.c b/gcc/testsuite/gcc.target/arm/neon/vmlau8.c
index 2876021ac..9fc36666b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlau8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlau8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c
index e7b50dc9a..64ef449a3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c
index 6f33fb4b0..3788e7f82 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c
index 989f085de..952638079 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c
index f47f5d010..a176265ca 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c
index b1283eb60..094b9fd17 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c
index fd628ffd6..292a32874 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c
index 71d3ed728..02da0712a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c
index 4a9d26ca6..b09aaec97 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c
index bbac90eb6..a42471171 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c
index dfd44bae7..b84ff6f6e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c
index 7670dd1bc..af2ca68fa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c
index 502647b63..4c83d9f31 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c
index 9a7cd058e..575ae0c39 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c
index 5516a562b..227ad9b21 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c
index 4a6109ab7..9d785da73 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c
index 1e5192d71..55a56a0de 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c b/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c
index 1d92cf0c1..fc589718e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c
index 6e7acc43c..f4b9c306c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c
index 35c4f657c..827178e4b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c
index 6bac73488..5e226c1db 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c
index 4a3e246c6..dbc1e8bba 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c
index c20cbd6c6..7e6406ec0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c
index 7567a17ee..fca965b90 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c
index ebc4c9c08..712cfbb8b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c
index 7dec64d31..6d977ec22 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c
index 3ef90d1ad..772d3f97c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c
index 9716ede80..4f1368d78 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c
index 5c37698d0..2f44ee0ce 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c
index 306111bcc..b36355acf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c
index c36675522..dfab11895 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c
index bf239d43f..aff34beac 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c
index 8a4b82aea..c9738747d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c
index ab0feb220..22a045515 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c
index 685e0175a..83370fdc0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c
index 63fe4a79f..232f7fe74 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c
index ad7ff60d5..b64226659 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c
index 86b498148..6ec259efe 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c
index 9e399e41c..b7dd71427 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c b/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c
index a5fd648ea..ca6960bc0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c
index 95f8f1540..47cbfb32a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c
index 7bdbdcb0d..9765e5139 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c b/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c
index 64ab744b4..dcb55162b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlss16.c b/gcc/testsuite/gcc.target/arm/neon/vmlss16.c
index 9f05cbb76..5655a1584 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlss16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlss16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlss32.c b/gcc/testsuite/gcc.target/arm/neon/vmlss32.c
index 19a701e4a..1a467dcd3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlss32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlss32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlss8.c b/gcc/testsuite/gcc.target/arm/neon/vmlss8.c
index 4e449c731..db95bdc47 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlss8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlss8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c b/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c
index edf534bfa..dfb918b6b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c b/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c
index 8d0e65a80..0afbc089f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c b/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c
index cc77dd341..4da7a41d4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c
index 7776b34d4..751910996 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmovQ_nf32 (void)
   out_float32x4_t = vmovq_n_f32 (arg0_float32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c
index 72fbeda4c..48361e99e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmovQ_np16 (void)
   out_poly16x8_t = vmovq_n_p16 (arg0_poly16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c
index d908658d7..a3de68fde 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmovQ_np8 (void)
   out_poly8x16_t = vmovq_n_p8 (arg0_poly8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c
index 77a2a41a7..1cec77735 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmovQ_ns16 (void)
   out_int16x8_t = vmovq_n_s16 (arg0_int16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c
index 13ba030f7..59178b799 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmovQ_ns32 (void)
   out_int32x4_t = vmovq_n_s32 (arg0_int32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c
index 7141de1ca..35936cbd4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,6 +16,4 @@ void test_vmovQ_ns64 (void)
   out_int64x2_t = vmovq_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c
index 999d709f1..e6883aed5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmovQ_ns8 (void)
   out_int8x16_t = vmovq_n_s8 (arg0_int8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c
index f02aca6ea..66b459a74 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmovQ_nu16 (void)
   out_uint16x8_t = vmovq_n_u16 (arg0_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c
index 3c01d39c9..958bb97f3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmovQ_nu32 (void)
   out_uint32x4_t = vmovq_n_u32 (arg0_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c
index 84a4b0421..e373a1218 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,6 +16,4 @@ void test_vmovQ_nu64 (void)
   out_uint64x2_t = vmovq_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c
index 30136192a..53120a8dc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmovQ_nu8 (void)
   out_uint8x16_t = vmovq_n_u8 (arg0_uint8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c
index 88fa47b85..589911947 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmov_nf32 (void)
   out_float32x2_t = vmov_n_f32 (arg0_float32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c b/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c
index 5a726bf8b..02c906c10 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmov_np16 (void)
   out_poly16x4_t = vmov_n_p16 (arg0_poly16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c b/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c
index d49655c31..afd6b46f8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmov_np8 (void)
   out_poly8x8_t = vmov_n_p8 (arg0_poly8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c
index faa4d547e..7691e1f4b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmov_ns16 (void)
   out_int16x4_t = vmov_n_s16 (arg0_int16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c
index 9f31a5c56..b1454ca29 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmov_ns32 (void)
   out_int32x2_t = vmov_n_s32 (arg0_int32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c
index c57a0a447..7b0112828 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,4 @@ void test_vmov_ns64 (void)
   out_int64x1_t = vmov_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c
index f68b01bd7..46a5dc8f5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmov_ns8 (void)
   out_int8x8_t = vmov_n_s8 (arg0_int8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c
index a6053ebbe..00ad860b0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmov_nu16 (void)
   out_uint16x4_t = vmov_n_u16 (arg0_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c
index 9f0634eaf..c8424c204 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmov_nu32 (void)
   out_uint32x2_t = vmov_n_u32 (arg0_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c
index 6d6d7c439..b9613e06f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,4 @@ void test_vmov_nu64 (void)
   out_uint64x1_t = vmov_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c
index 62f9d4ad2..38d80bcd0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -15,5 +16,5 @@ void test_vmov_nu8 (void)
   out_uint8x8_t = vmov_n_u8 (arg0_uint8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovls16.c b/gcc/testsuite/gcc.target/arm/neon/vmovls16.c
index 08f4a4de3..31d5ef14a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovls32.c b/gcc/testsuite/gcc.target/arm/neon/vmovls32.c
index 69d6cc8bb..0d95e2eb9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovls8.c b/gcc/testsuite/gcc.target/arm/neon/vmovls8.c
index 6619eb0d9..b27db8300 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c b/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c
index 50978bca7..acca55af2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c b/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c
index 190fc0c5c..f1eee8ee0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c b/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c
index b8483e7a8..2bf08e1e1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovns16.c b/gcc/testsuite/gcc.target/arm/neon/vmovns16.c
index 9ce728e74..abd648bda 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovns32.c b/gcc/testsuite/gcc.target/arm/neon/vmovns32.c
index e5d6ca1f5..82c1c3714 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovns64.c b/gcc/testsuite/gcc.target/arm/neon/vmovns64.c
index 5030a42dc..091bddc2a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c b/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c
index 85de70c0c..85fca5f57 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c b/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c
index 72577c4c6..6bdf0d453 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c b/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c
index 96ada07a9..41019fb7d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c
index c06916f79..cc4651be0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c
index 82b4c622c..e4620490d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c
index a4a4269e5..0e0e52734 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c
index aa8e3372e..d8897a599 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c
index 04f060f15..f336710cd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c
index ff3f18aef..e37e9ae40 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c
index 7db9c73bc..ff81b43ee 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c
index cc46dc667..714bef43a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c
index bff55011d..ef05b9378 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c
index 9ab5bf108..2af6d757a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c
index 6cd786852..3e9ceb056 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c b/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c
index b46627c22..fe19f13da 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c
index e83d127ca..5d4ac7b1a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c
index 282808589..3f8027270 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c b/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c
index ddc36f1f2..8e49dbcf2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c b/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c
index b5aceec51..e73bc6dd0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c b/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c
index 4926b5cb7..d041a0d8b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c b/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c
index 431540f46..75b3c67d3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c
index d5761b38d..967117975 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c
index 63f91aa39..b1a089274 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c
index 34c99641f..dce5e9a94 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c
index acca1fe54..d73a2514d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c
index 712b27385..c77268bca 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c
index b2353e2e5..8f7522402 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c
index 1be1ac54b..cf24912d1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c
index 8ff82bbc6..9c0a35e53 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c
index 4821925f3..5d2c60b48 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c
index e55330aa7..9957837e4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulf32.c b/gcc/testsuite/gcc.target/arm/neon/vmulf32.c
index b2078b933..7081b2f07 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c
index 2f6cabb91..4467bca7e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c
index 711bc3dbb..db1655faa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c
index 31151a276..c723df2ac 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c
index be4b6b096..adea5cc3c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c
index 6b7f0803d..9de27deb9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c
index 19a24d7c8..0fe16d16f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c
index 32a22aedf..b3e9c1932 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c
index 80ba52188..6cf18d24a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmullp8.c b/gcc/testsuite/gcc.target/arm/neon/vmullp8.c
index 849537eef..72c288392 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmullp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmullp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulls16.c b/gcc/testsuite/gcc.target/arm/neon/vmulls16.c
index 84f8abc48..cb7327886 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulls32.c b/gcc/testsuite/gcc.target/arm/neon/vmulls32.c
index 38ca3bccc..816f3abc0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulls8.c b/gcc/testsuite/gcc.target/arm/neon/vmulls8.c
index c8652084a..4c0d2b4aa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmullu16.c b/gcc/testsuite/gcc.target/arm/neon/vmullu16.c
index 1ff7232b7..8dad8be65 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmullu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmullu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmullu32.c b/gcc/testsuite/gcc.target/arm/neon/vmullu32.c
index 39f910221..6010fa92c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmullu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmullu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmullu8.c b/gcc/testsuite/gcc.target/arm/neon/vmullu8.c
index 679395efc..05eb05ac3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmullu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmullu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulp8.c b/gcc/testsuite/gcc.target/arm/neon/vmulp8.c
index 2ec17dd73..3a9857271 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmuls16.c b/gcc/testsuite/gcc.target/arm/neon/vmuls16.c
index 1fb5047d5..b2ac4c8c0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmuls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmuls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmuls32.c b/gcc/testsuite/gcc.target/arm/neon/vmuls32.c
index 2724c389a..7cac98d82 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmuls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmuls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmuls8.c b/gcc/testsuite/gcc.target/arm/neon/vmuls8.c
index 79de6b737..08fd311ac 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmuls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmuls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulu16.c b/gcc/testsuite/gcc.target/arm/neon/vmulu16.c
index 8c8aeff89..141d72fbf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulu32.c b/gcc/testsuite/gcc.target/arm/neon/vmulu32.c
index c00bb003c..5c36ffb9a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmulu8.c b/gcc/testsuite/gcc.target/arm/neon/vmulu8.c
index a6349f4db..51d4a1708 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmulu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmulu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c
index 82a159848..47d50b64f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c
index 32fff2ec7..e60488447 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c
index 9dea79d65..ccad86944 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c
index 223367159..164907c7b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c
index 7517830f1..ce18a4907 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c
index 58ebc8ddb..34795c776 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c b/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c
index 5cb87429d..d93aa36b0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c b/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c
index 56e01901a..46e3cf910 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvns16.c b/gcc/testsuite/gcc.target/arm/neon/vmvns16.c
index d543e3465..8464b2b95 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvns32.c b/gcc/testsuite/gcc.target/arm/neon/vmvns32.c
index 03b8999e6..7a4dd9a79 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvns8.c b/gcc/testsuite/gcc.target/arm/neon/vmvns8.c
index 8e368e368..c09872092 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c b/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c
index 25209de01..ab600a0a8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c b/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c
index 9a8133211..df2bd4b5a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c b/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c
index 0668576ab..729ab71c6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c b/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c
index 203232d74..c1e116913 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c b/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c
index dbe927730..c8b149789 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c b/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c
index 6f1d81cc5..e8b3e925c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c b/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c
index 88ae9eb01..4e8e80d31 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vnegf32.c b/gcc/testsuite/gcc.target/arm/neon/vnegf32.c
index 30834574d..82e95399f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vnegf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vnegs16.c b/gcc/testsuite/gcc.target/arm/neon/vnegs16.c
index bf7e9fcef..ff2315180 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vnegs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vnegs32.c b/gcc/testsuite/gcc.target/arm/neon/vnegs32.c
index e0cae01b2..82108678e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vnegs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vnegs8.c b/gcc/testsuite/gcc.target/arm/neon/vnegs8.c
index 242174cc1..952e34010 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vnegs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vnegs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornQs16.c b/gcc/testsuite/gcc.target/arm/neon/vornQs16.c
index 3a5a97fad..519da3ccc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornQs32.c b/gcc/testsuite/gcc.target/arm/neon/vornQs32.c
index ade713492..cec659911 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornQs64.c b/gcc/testsuite/gcc.target/arm/neon/vornQs64.c
index da1e06233..05166ba4e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornQs8.c b/gcc/testsuite/gcc.target/arm/neon/vornQs8.c
index d585a1f95..99982aefd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornQu16.c b/gcc/testsuite/gcc.target/arm/neon/vornQu16.c
index b6f38e407..761e72d7b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornQu32.c b/gcc/testsuite/gcc.target/arm/neon/vornQu32.c
index 5904f8f99..18a968539 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornQu64.c b/gcc/testsuite/gcc.target/arm/neon/vornQu64.c
index ff977d64f..84c9f895d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornQu8.c b/gcc/testsuite/gcc.target/arm/neon/vornQu8.c
index f60434ba0..ffe6766d4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorns16.c b/gcc/testsuite/gcc.target/arm/neon/vorns16.c
index eb26f74b0..b860142dc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorns32.c b/gcc/testsuite/gcc.target/arm/neon/vorns32.c
index de81c7976..826e0d288 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorns64.c b/gcc/testsuite/gcc.target/arm/neon/vorns64.c
index 6e8b8e3ca..d7b8e60d2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vorns64 (void)
   out_int64x1_t = vorn_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorns8.c b/gcc/testsuite/gcc.target/arm/neon/vorns8.c
index dfb773070..c71a6bb0a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornu16.c b/gcc/testsuite/gcc.target/arm/neon/vornu16.c
index 8575f9bee..d4983eebf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornu32.c b/gcc/testsuite/gcc.target/arm/neon/vornu32.c
index 02bac35fc..aba68841a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornu64.c b/gcc/testsuite/gcc.target/arm/neon/vornu64.c
index ce666533c..6fb3a9502 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vornu64 (void)
   out_uint64x1_t = vorn_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vornu8.c b/gcc/testsuite/gcc.target/arm/neon/vornu8.c
index 4e3c59393..6fdb7331c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vornu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vornu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c b/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c
index 428f30c68..20ae7342e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c b/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c
index 787a61814..ba42dccd5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c b/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c
index 73ff15f52..f46e7c16e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c b/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c
index 223419925..d58607c84 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c b/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c
index 5b074abce..ce29c4ad7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c b/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c
index 55434037a..8b1a64845 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c b/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c
index 4b0997999..55cf57ae5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c b/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c
index 679556309..7be85fc43 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrs16.c b/gcc/testsuite/gcc.target/arm/neon/vorrs16.c
index 6f5d139ed..8e942cc1c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrs32.c b/gcc/testsuite/gcc.target/arm/neon/vorrs32.c
index 3410bc2f1..f940a6530 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrs64.c b/gcc/testsuite/gcc.target/arm/neon/vorrs64.c
index 53725423a..a1c7e5ee2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vorrs64 (void)
   out_int64x1_t = vorr_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorrs8.c b/gcc/testsuite/gcc.target/arm/neon/vorrs8.c
index be6136cbc..2d6b70cbe 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorrs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorrs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorru16.c b/gcc/testsuite/gcc.target/arm/neon/vorru16.c
index ffd2b40d9..5d50d7aad 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorru16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorru16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorru32.c b/gcc/testsuite/gcc.target/arm/neon/vorru32.c
index f7688ea9d..60c847649 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorru32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorru32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorru64.c b/gcc/testsuite/gcc.target/arm/neon/vorru64.c
index cf8352fac..1991b0215 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorru64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorru64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vorru64 (void)
   out_uint64x1_t = vorr_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vorru8.c b/gcc/testsuite/gcc.target/arm/neon/vorru8.c
index c80b2e25d..e47d465e5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vorru8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vorru8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c
index c7cc96f2d..35dcdbbad 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c
index 5051917a2..a82551a28 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c
index 631e3155c..182ea46c8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c
index dbe27b50a..c9f7833d9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c
index fb13006d2..80cf323ea 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c b/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c
index 044ac0420..8e1dac223 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadals16.c b/gcc/testsuite/gcc.target/arm/neon/vpadals16.c
index 130c63c1f..88c3cb179 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadals16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadals16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadals32.c b/gcc/testsuite/gcc.target/arm/neon/vpadals32.c
index 73f8d1ffc..95897f5cc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadals32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadals32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadals8.c b/gcc/testsuite/gcc.target/arm/neon/vpadals8.c
index 54f04c8ac..3cc18459d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadals8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadals8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c b/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c
index e1e186e4d..280e4d611 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c b/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c
index 44f1f267d..1792b43d8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c b/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c
index e4a4a18bf..f3fb6b031 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c
index 7e999ddf8..f08c8506a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c
index ee4590be6..b3fc9aa13 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c
index 63f2f007c..00399e804 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c
index fde7218c7..09191ab3f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c
index 7bbff2021..d65754b0c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c
index 0d707a1af..b93bfd3f9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c
index 7ec49a5a7..15f8a18a7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c b/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c
index 2cf1f207c..57d93b50d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c
index 990f9ad8d..5abb48994 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c b/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c
index 31aaec3d9..0107bfa1f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c
index eda1abd3f..01c1fac9e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c
index dfd53c063..6c47b0582 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c b/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c
index 405b00f34..47fbc738a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadds16.c b/gcc/testsuite/gcc.target/arm/neon/vpadds16.c
index 008762d03..6d9ad1afd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadds16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadds16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadds32.c b/gcc/testsuite/gcc.target/arm/neon/vpadds32.c
index 03deb9d13..36d8aad1e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadds32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadds32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpadds8.c b/gcc/testsuite/gcc.target/arm/neon/vpadds8.c
index 49a470057..ea6bcae85 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpadds8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpadds8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c b/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c
index d9e9b804d..1a19916e8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c b/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c
index 5452e6497..3bf215c71 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c b/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c
index fe967a172..e1b6c5987 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c
index fe8c16728..267fc3862 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c
index 26effea76..7476f2462 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c
index ca26deec0..d2c3e81f8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c
index 6b6fab5e5..c15c0b0a9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c
index c498274bf..8fbad8694 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c
index e2218c347..2869fd339 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c b/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c
index 20da6295a..75a29f27b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpminf32.c b/gcc/testsuite/gcc.target/arm/neon/vpminf32.c
index 0952bdbf3..59836f78f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpminf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpminf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpmins16.c b/gcc/testsuite/gcc.target/arm/neon/vpmins16.c
index fcf8e1eae..14af72840 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpmins16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmins16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpmins32.c b/gcc/testsuite/gcc.target/arm/neon/vpmins32.c
index 0ca2213e5..c34afbdff 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpmins32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmins32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpmins8.c b/gcc/testsuite/gcc.target/arm/neon/vpmins8.c
index b103cb901..b0212ff90 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpmins8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpmins8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpminu16.c b/gcc/testsuite/gcc.target/arm/neon/vpminu16.c
index f21479125..a9fa87c7e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpminu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpminu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpminu32.c b/gcc/testsuite/gcc.target/arm/neon/vpminu32.c
index 5dcc5a573..2c2cb75ba 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpminu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpminu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vpminu8.c b/gcc/testsuite/gcc.target/arm/neon/vpminu8.c
index f2627fa65..726fa72fa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vpminu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vpminu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c
index e0a48afd0..75cbc0a2c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c
index c82b8a5c5..12978d383 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c
index 410d2918c..55f9037f4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c
index 512a64313..7323fe22a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c
index e841e0e08..f6c3d1fdf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c
index e694c4f2a..2801f4ffc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c
index 57aa08555..3567a8ced 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c
index 910b08280..04d8fe750 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c
index f2e1c2c2d..1ab2c5ab6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c
index 736e3d622..16a0de031 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c
index ce7542a5d..d27b4bce3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c
index 00b054c07..e4dc0b90d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c
index daa4f3b59..ed3dc442a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c
index 08afba1f3..54bd77781 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c
index af2a3668f..47dc81e8b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c
index 92cb8f211..4bd258949 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c
index 534d6ffc1..b150120eb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c
index fa084993a..f38f38396 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c
index 8f5d5fb93..0c2da6d42 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c
index 4c2b7d286..e2e515577 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c
index c6fa26ec6..c0c456c34 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c
index 3d5e0135c..275150c86 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c
index ea48f7a15..6e67b57d5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c b/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c
index f2fdc51c5..a81c9eaf2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c
index 49c6ffde9..2c2a7bfcd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c
index 7475bf1e9..65dd695fa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c
index 20064fdbe..3757279e2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c b/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c
index 24fd9de4c..01565bba5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c
index 740c885c2..ff5902f6c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c
index 1fc90b709..7a01d6b7a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c
index 4b3412730..ddb866280 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c
index be40d437c..5147ac90f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c
index 887085593..8d682946b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c
index 41898b425..7f7eacba8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c
index 85a7e10c9..547ffd1b5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c
index ffd2053c9..a8f7904a9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c
index bb47b08b9..fde62bcbb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c
index 5d230ed88..a31b5cb51 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c
index a5ef813ee..3ef17b938 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c
index 9f3a4c7f8..e4ddbb666 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqabss16.c b/gcc/testsuite/gcc.target/arm/neon/vqabss16.c
index 597e20f26..9bcab766b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqabss16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabss16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqabss32.c b/gcc/testsuite/gcc.target/arm/neon/vqabss32.c
index 958587461..20ecb7eea 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqabss32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabss32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqabss8.c b/gcc/testsuite/gcc.target/arm/neon/vqabss8.c
index 086ff4902..e4ee27ce6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqabss8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqabss8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c
index 649a7047d..d5e1fc289 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c
index 3c80d27b8..f408a3e04 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c
index fd4655196..8f1a1a8b9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c
index 583439e4a..e94dc13d3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c
index 3b1a87437..84f567748 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c
index c4e22fabc..5055627d6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c
index 80ad826bd..cc3da0faa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c b/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c
index c9ec1a762..d64daf408 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqadds16.c b/gcc/testsuite/gcc.target/arm/neon/vqadds16.c
index b8d9e8dd4..4a4df0be8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqadds16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqadds16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqadds32.c b/gcc/testsuite/gcc.target/arm/neon/vqadds32.c
index 1cb7d2ba4..b1a022fd5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqadds32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqadds32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqadds64.c b/gcc/testsuite/gcc.target/arm/neon/vqadds64.c
index fd0a4013e..48b4a6ebc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqadds64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqadds64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqadds8.c b/gcc/testsuite/gcc.target/arm/neon/vqadds8.c
index b64cbf081..3b408bc8f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqadds8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqadds8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c b/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c
index 41664ecaf..b3d720483 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c b/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c
index 3fdeebada..dbe9038a1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c b/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c
index 7a4809216..08230f833 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c b/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c
index ceb70e2cc..c465022f4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c
index 02e5b0ac2..d2567c092 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c
index 925622449..7a9cfe8bc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c
index 24ce9838c..43a096265 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c
index 885fecc74..2031a60db 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c
index a1bdf951d..6391a7988 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c
index ac858e31c..e7ff0d849 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c
index bba7153eb..aa32c490b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c
index 2c1181470..c88b81a5c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c
index 56da4c2e8..3981f508b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c
index dad599dd5..36c200be8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c
index 80ea5abdd..06aeb8e14 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c
index daf9a6e17..fac2fb654 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c
index 9c5651266..70ee8a3f4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c
index e5a0bf1d3..ea74a9172 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c
index 7ae3a222a..10009f0d1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c
index e742ff540..1884c9528 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c
index 75b7951a6..c9cacfc1e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c
index b9a19abb4..ff6eb74e6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c
index 597032f6b..5b8e4c54e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c
index 1314664f1..507bde891 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c
index 537be4eb6..e16030c2a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c
index 407e61649..be38f92ae 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c
index 20c1611ea..ef591cba6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c
index 3e76e8ec4..cb51f4be9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c
index 69309b1f4..f9476a2f5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c
index ffa26d805..2d5ee0064 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c
index 032a9a6f1..1e980f1ba 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c
index 02eec1e8f..947aa9635 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c
index e3224c596..72ba7c2ab 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c b/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c
index 7c306985b..6a6b2e2d6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c b/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c
index 49d103a3f..8807b5909 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c b/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c
index ed48f200b..a921575e3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c b/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c
index f3e23481f..3c5285b11 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c b/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c
index 5ee9b9cd3..ce74646fb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c b/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c
index 7bdfb5d6f..74e1b8a08 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c b/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c
index 93c6eb850..2e312505b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c b/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c
index 3a92133d4..845af1fa9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c b/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c
index be303c92d..6fa8d97a8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c b/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c
index 660ac6bd3..cb9b462b2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c
index eb5ac374b..c5f523858 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c
index d84a5fe06..cc32b2138 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c
index 3907ccdd6..755847d0b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c b/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c
index 2d9d99bc1..a05a1fc8c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c b/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c
index e68a827ea..30c43ef5f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c b/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c
index 70312003b..d9f23ad83 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c
index 75e9cc377..1383779fe 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c
index 4b5933ad4..acafc1c28 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c
index 1b5628037..ec90a8866 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c
index 31cf319b5..e2a25e93d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c
index 56101c239..b01497d40 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c
index 107756673..613d3dc66 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c
index d199c1d9b..1d9bea8b7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c
index 55510f52c..1f0e739b7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c
index b4e8a5e84..80f3644a1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c
index 200e2c4e2..6c5bd1606 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c
index 8379c254b..6819d8286 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c
index 1804b81f7..27c5c1d26 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c
index 14f5362a1..163e02def 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c
index 344e654b1..b6f46d096 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c
index bbc4efec5..15ecce049 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c
index 69eb05f08..058095b36 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c
index 7992aaf57..de81ba00e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c
index c7e5b8e72..fac6fdb49 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c
index f5de9108c..0860a4463 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c
index 70d06838f..4e49ad352 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c
index 9a0610890..483aa8179 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c
index 85f231cab..ad09efda2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c
index b91be64f5..9abc96025 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c
index 71b86c75d..d02d6f7c8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshls16.c b/gcc/testsuite/gcc.target/arm/neon/vqshls16.c
index 45ff5de39..cf288a078 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshls32.c b/gcc/testsuite/gcc.target/arm/neon/vqshls32.c
index f4ee413ef..39e38bfc8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshls64.c b/gcc/testsuite/gcc.target/arm/neon/vqshls64.c
index 590aa7fc2..6057b3589 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshls64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshls64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshls8.c b/gcc/testsuite/gcc.target/arm/neon/vqshls8.c
index a42fe1532..4d3332fd6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c
index ca5c1a44a..cbae9aaec 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c
index 0ad2e7297..89ba48a23 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c
index 18b5a794b..df91fa9b9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c
index ac6a2fb9c..f7ea9231b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c
index 2cb5910d4..26feb6474 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c
index d27c3e830..70a156d6a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c
index c8d397292..bed332d60 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c
index 7edcd394c..96e434752 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c
index bf439bae7..2ec926ee2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c
index e91e9fc70..b9c156ad0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c
index 10ff898ec..5003573d1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c
index 0bcb6046f..649588e97 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c
index 545397922..4a0d5095b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c
index 69c17e6b9..e9a10f6d1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c
index 71f1cf1ef..32e9aef2c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c
index 59da1e5d5..6582d8fea 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c
index 23b03ca68..39eef07f7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c
index 7cf626a9e..b479526ce 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c
index 18943f9dd..94d6b60e8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c
index 705b31491..9d04d51a5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c
index 097d4d32a..37085e97c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c
index c270c666b..72943b2e1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c
index e319ba2d4..be37e9115 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c
index 0b718f67d..019b0a696 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c
index fc1aba499..a08c1404d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c
index 0e1201973..979f7c173 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c
index 30c5aeca9..b0de08699 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c
index ee0953594..e03c2b236 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c b/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c
index 506c4448b..a447931a6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c b/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c
index f6b70bd06..89a87e5b8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c b/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c
index 0ddfe5a80..fdc563c19 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c b/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c
index ad2c75f76..f8ba1ed00 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c b/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c
index b39ed08c6..c16cb1a9b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c b/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c
index d19df3ea0..51b58df63 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c b/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c
index 50c298f46..799a3e38d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c b/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c
index 77faa60d1..673c8174b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c b/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c
index a3cdcc671..5a1eb44cc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c
index d1010bca5..d35cbd6e4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c
index 35a258856..9f0949e0a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c
index f296b9553..edd17ee47 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c
index 3e57d3503..d59e810ed 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c
index 213021c69..d3452e96e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c b/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c
index 6e7e41945..c8d885b07 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p16.c
index 998c3f0ce..58049ac5b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p8.c
index c68861c11..fc5676001 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s16.c
index 99548c85e..dc2227fe2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s32.c
index 13ce5b5c4..d0781f467 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s64.c
index 6cb0d85d1..1528c711e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s8.c
index a0b01cfdc..eb3a46bd4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u16.c
index b1ef77da8..5562dfff4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u32.c
index bde7baf0d..8b43c6693 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u64.c
index a72ed95da..71e6a5f9a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u8.c
index e77bb9817..569316344 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQf32_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_f32.c
index 019cf583b..b94f8f6ae 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p8.c
index 1b51eecb2..d284b595c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s16.c
index 8ae9b9dfc..fedcfa8de 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s32.c
index 09f2264e9..8c56fee74 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s64.c
index f7c7af0a4..03c391a73 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s8.c
index 1727461bf..11b6c915d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u16.c
index 23c0f9926..80ba65f7c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u32.c
index ad218958c..f1c9aeb75 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u64.c
index 72b5f2559..c2365d1bd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u8.c
index ce056f527..8333c2f16 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp16_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_f32.c
index ffe9956cd..e27080efd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p16.c
index f02d2820c..86dd6a4a2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s16.c
index dbbf983b5..608e27293 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s32.c
index 2881005b7..7900676d0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s64.c
index 2e0242328..27483dcf4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s8.c
index 61bbc8558..d4be56f6a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u16.c
index 0b98d6af1..c00a55fe0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u32.c
index aab2dc1b2..e5b580b44 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u64.c
index 9c1a59add..5e80ed7d2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u8.c
index 8674e986e..321e8f8dc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQp8_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_f32.c
index 8f0667825..08d6b6afc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p16.c
index 8a7a8f03e..1505b725e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p8.c
index e14288d6b..48c54f212 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s32.c
index 911c95e09..15f54fa94 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s64.c
index 86eaf663b..eb8e53516 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s8.c
index baa8ee2a9..f353c9268 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u16.c
index 436f9e6f9..8ea96b7b3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u32.c
index a7bd6f35e..ac571b126 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u64.c
index 7d0a8a609..73959abd9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u8.c
index feb8a5528..45e85b131 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs16_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_f32.c
index 366893d16..795db0753 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p16.c
index 85dca2f74..473c12350 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p8.c
index 19fff80c6..819e1d122 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s16.c
index 52bf8e5f4..7d2b5a0b6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s64.c
index 4f8df90dd..8116033e0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s8.c
index a955553a4..6786ddbfd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u16.c
index 36f7a3ce8..104e22d68 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u32.c
index b3200bf20..8385fd8a8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u64.c
index 009c9311d..90b91a74a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u8.c
index 59b13bf4d..60ad32a44 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs32_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_f32.c
index 27c6c5a88..212005fab 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p16.c
index ad92c9caf..0003a1f72 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p8.c
index 3850ba2cb..02d7174b4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s16.c
index b929cd3ed..26350eeb8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s32.c
index f095c80df..471db5cc2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s8.c
index 48cda7b3a..903be8ff6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u16.c
index 175f18c4e..cbb49098f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u32.c
index 4ad87457b..882cf77bd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u64.c
index 5a5218805..f9bc43ae4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u8.c
index 82d075779..3af2f0138 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs64_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_f32.c
index 851500f98..6a31442cf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p16.c
index 9f4b632b8..6491c795a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p8.c
index 79d860c14..914321d55 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s16.c
index 84349328d..fee5e2723 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s32.c
index c16a14290..2bf941aa5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s64.c
index f38396315..1e6557174 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u16.c
index 19278ff6c..84b86eaae 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u32.c
index d5943f25c..e5f85ccd7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u64.c
index 6e066376c..9f299b366 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u8.c
index 1e95d1955..f04a53733 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQs8_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_f32.c
index 6068d0c5c..cb4a2e502 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p16.c
index 6ee38c3d5..5667d60c2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p8.c
index feea098d4..d45442d9a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s16.c
index 59e49b312..9b6615909 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s32.c
index 38c292406..9a6d0f44a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s64.c
index 5fe8ddafd..c5a5378e8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s8.c
index 1afbd474b..4ca22dceb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u32.c
index 59c5b9765..516c94957 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u64.c
index 61d2b7bd0..816da82c5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u8.c
index 243b99140..ac5e98fa8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu16_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_f32.c
index c6d318fd2..7453f24b2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p16.c
index 288654a92..27989c53c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p8.c
index cc8eec4c4..2b3e01843 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s16.c
index 9418c2f02..3a6f20f0c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s32.c
index 69719d8fb..3079729aa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s64.c
index 5b70d30c1..927cd3a60 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s8.c
index 90a2c7d91..5b546ccac 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u16.c
index a331c9f00..055739e8e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u64.c
index 5c0e26c34..ddf51f8ec 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u8.c
index 4b3378393..2f860c193 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu32_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_f32.c
index 17f89d0e9..5224dcf87 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p16.c
index 50fbbdef0..fc592b78d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p8.c
index cc1d1e1a1..503c44393 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s16.c
index c17c80057..430694abc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s32.c
index dc8208b75..acfc69e74 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s64.c
index a4a08b211..033c6516e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s8.c
index 357ceabbf..b6c312fbb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u16.c
index 62f933748..dbe9d5160 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u32.c
index 5d3a874f6..58b3c67e4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u8.c
index 7618eb166..c20fef185 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu64_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_f32.c
index 4a21da5aa..f7b470415 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p16.c
index 297736953..758f10bea 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p8.c
index d8dd6de39..29f2aa19e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s16.c
index 362a7766a..1d79abb9a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s32.c
index f864b1b5c..9f7c4f2f7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s64.c
index 7cb682c07..a01fb1d1d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s8.c
index 8d803c5f0..0d65f31d8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u16.c
index 14d94dea7..dd9306192 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u32.c
index 0d8b46987..30f4b4559 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u64.c
index 8afdabf39..3f04c7192 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretQu8_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p16.c
index e05ef3108..92ede4949 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p8.c
index 6a807751c..ee2e6a92e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s16.c
index d86ee6511..39ec36947 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s32.c
index 10d230bc3..008598f14 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s64.c
index c78cb7853..6a5ede493 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s8.c
index bf130bdb7..cc645e5d4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u16.c
index 29f83cfdc..fbb96790f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u32.c
index 4da99af1c..f87c885c5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u64.c
index 5bc91f647..610f77ad4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u8.c
index 655ed88a2..bfd81b171 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretf32_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_f32.c
index 78a6dc8ff..91508a6d8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p8.c
index cd8c7921e..a2f7207ef 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s16.c
index 3638a18d5..3f22296cd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s32.c
index 4d131a377..393246cca 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s64.c
index 3d7e5d6d1..f5c99711a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s8.c
index f72f660db..6cf01b280 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u16.c
index f4b36ec84..4cdeeac44 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u32.c
index 627eeef72..5b1094097 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u64.c
index e7dbf8305..b036ff475 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u8.c
index c00b7264f..d165cafb4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp16_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_f32.c
index c486793ba..b73599085 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p16.c
index c8ff231d5..28a04a3e7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s16.c
index d179eaec7..2a559c8d9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s32.c
index 54deb03b8..a3c627085 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s64.c
index 0788af995..1a5cbbbcd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s8.c
index e201471c6..0f8af3e5c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u16.c
index 34bc38d0f..f3cdaab48 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u32.c
index 103963d37..210e063c2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u64.c
index 4521146b6..bf83e5df9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u8.c
index 52321f279..17d8d8c87 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretp8_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_f32.c
index 7cbe159c9..380947bcc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p16.c
index 42533bf94..3742001b3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p8.c
index 6d2e15e5f..5970dc86c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s32.c
index 019eb9b57..bee17e4c6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s64.c
index 56cdaede7..4a8feda9c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s8.c
index f94745e9a..e079c6158 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u16.c
index 4dc4f80eb..cf86bd4a1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u32.c
index bf5442eb4..853e7ab2b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u64.c
index 42cc2c5d8..a72786ded 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u8.c
index 5f4baaf02..9c8459e46 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets16_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_f32.c
index 5d646cf8a..73fe251e6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p16.c
index 7be758c46..36df97c5c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p8.c
index 3b3e34ac6..54e9dee78 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s16.c
index deb72ba85..f5e3fb6fd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s64.c
index 9a1799d7f..f1430843f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s8.c
index f8a6db98d..a336577d4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u16.c
index 3a1457d59..2f078613e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u32.c
index 5c0cf56cc..4087e9c78 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u64.c
index 7ce200dcf..826bb8efb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u8.c
index 9c1ebc18e..31589a8a8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets32_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_f32.c
index b852607a5..0096e368a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p16.c
index aa49ee775..bdbe4302f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p8.c
index 0a9ff26cc..76da59f39 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s16.c
index beedbf451..0f978f390 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s32.c
index 7d9060dc1..aefa689a3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s8.c
index 98401192a..a7e0adad9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u16.c
index 66313a494..110818567 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u32.c
index a993b5813..978a6e480 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u64.c
index 67497a24e..0546f26dd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u8.c
index 16ba5dae1..601b5988d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets64_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_f32.c
index b2f535bc5..05d921d7f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p16.c
index 0ddbbbfa9..38e812a16 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p8.c
index 282fc9394..402484411 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s16.c
index a23cdd5e3..df368e370 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s32.c
index e9299291a..caefc38dc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s64.c
index 3288e02f5..a8c7c333e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u16.c
index d24bd11bf..dbd1eec43 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u32.c
index 7665a3081..40e1475ce 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u64.c
index e0fcde95d..6d53d41e8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u8.c
index a4da614d3..8f31a4c76 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterprets8_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_f32.c
index 462d41b34..f960624d7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p16.c
index 2d901d611..e787a969e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p8.c
index b49141b75..c332e9450 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s16.c
index 553deb1e8..d72ec3452 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s32.c
index 97ddbe39f..b6d86c011 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s64.c
index 901288b98..87f494bec 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s8.c
index 10fec133e..11695c169 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u32.c
index 3cc777d92..9f0171a05 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u64.c
index 67ea82edb..0db76c692 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u8.c
index b548558ad..71b555ac5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu16_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_f32.c
index 5a0bd3615..813b8b961 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p16.c
index 23e885c40..3662cc3cd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p8.c
index 24df01f90..73ddff115 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s16.c
index 8e4baeb5f..02ec84c91 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s32.c
index 5251786ae..2a964c830 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s64.c
index 0f0b4894c..ad9493856 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s8.c
index f2ca01dc7..8ff896e70 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u16.c
index 9ff8649d6..5c4883422 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u64.c
index a7ab80893..8fd55f24b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u8.c
index 6dc3a30f0..ab192091d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu32_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_f32.c
index 9d079aa57..7ded8687a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p16.c
index 50a89b7a3..c48213439 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p8.c
index 4d47d2505..858af4624 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s16.c
index f55f9ea39..e07c4e83e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s32.c
index 6ff562a54..0fa51a1a2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s64.c
index 1e705d00a..1f1f62e43 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s8.c
index d80646728..299b45ce5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u16.c
index 97826c238..dd2c1550d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u32.c
index 10a6b550f..8dbe9e200 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u8.c
index d577d5657..fe0724a8c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu64_u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_f32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_f32.c
index e0e6a594a..e82cba753 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p16.c
index d4e9852c4..08516125c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p8.c
index ac17dd9a3..91d3d0eaa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s16.c
index 9182d4efc..50a2cd187 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s32.c
index 3eee2f886..a5db01b62 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s64.c
index 46c65b2b7..f906e018b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s8.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s8.c
index c309adfe5..bd2ba481f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u16.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u16.c
index e0c0bbe97..eb38ca82f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u32.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u32.c
index 4f61486de..6fb11b26f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u64.c b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u64.c
index a9df64a74..cf7ff27ce 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vreinterpretu8_u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c
index 36af44e1a..b815c199f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c
index 3a6b903e4..7167fec30 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c
index 859b1f11d..d43613079 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c
index 842519275..15086d584 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c
index c236a4875..b2c7ca88e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c b/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c
index 9d640b60e..10ba66f7f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c
index 108571340..af213d91e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c
index 4d28282ed..926068f10 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c
index d8af7a485..bfd8ec2e7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c
index 85fe2b29b..74fc2470d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c
index 8e26466dc..cf0220a86 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c
index 4cd1024bf..ad5dba31c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c
index 41f4cf7de..93f19405e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c
index e1d714333..b19ce01c3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c
index f01317218..08bf6f258 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c
index 8d14e6ae6..47b8a591d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c b/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c
index abc5cdeb8..928c1d45c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c b/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c
index 716a546f5..ac5c63690 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c
index a75d7dad5..c9ab7008d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c
index bbee8de17..2d5d2f86b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c
index f0f162801..019b6d419 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c
index 0e24cc0ec..5923b2d2f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c
index 1c7c89274..93ffd5818 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c
index e492a4e3b..9353e7057 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c
index 1ed83305a..590d833fb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c
index 723a1340d..014da6812 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c
index 4a6df7770..4b7d8e495 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c
index 3a7c21e9c..3ea280e90 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c
index 03c7e9029..1b30d60e1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c
index 91f1ea4f9..370f49854 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c
index c5e49d770..ee4206ba7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c
index 952365c1f..f7057ce49 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c
index 8b4dc987f..c073b0b68 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c b/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c
index 6d9291638..4fdd2697c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c b/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c
index 3759bb985..61d21b69d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c b/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c
index 3328ec0e3..71a6af177 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c
index a8ba1fb2e..05b92b0aa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c
index 609d78976..5d51dec60 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c
index 1a2b771f6..6e1bf7532 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c
index 6f4138d8b..1e4908e46 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c
index 28d300e90..ee38e04fa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c b/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c
index f02c99ee7..36cb69def 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c
index c52ebb160..c6b18495e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c
index 0ce862292..dda571aaf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c
index f8ef936a8..873c8cfe4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c
index 823bbfc90..f6ade301c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c
index 003e16922..c825da15e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c
index 16b1bc4e1..af8f2853c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c
index 9c784cbe8..55dca359b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c
index 8ff74a26e..f671e1e4b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c
index 9a2272276..27a0f7225 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c
index 447f078ec..b30b26748 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c
index c22690b04..d6e5817d0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c
index c044b54a5..340614cd5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c
index 49d09040d..d02118a25 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c
index c41b330e7..e63a197df 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c
index 76d164266..6f4f4d379 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c
index 8f8c9e87e..77c22056b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c
index 57cb6f6dc..5c5454f98 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vset_lanes64 (void)
   out_int64x1_t = vset_lane_s64 (arg0_int64_t, arg1_int64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c
index 45725c2ce..fd09e21d6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c
index 6f699c693..783cc82c4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c
index 663960298..0d5a89ec1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c
index e22621ae9..3bff5d232 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vset_laneu64 (void)
   out_uint64x1_t = vset_lane_u64 (arg0_uint64_t, arg1_uint64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c
index 7bcfb67ce..0e4853190 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c
index 7c50d641f..31344a6e8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c
index e98bc6e88..dd11cd54b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c
index b4eeae627..2fdbc0d01 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c
index aacac035f..078ffd41b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c
index 01e3cfbe9..a330ae3d9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c
index 828bcdf33..cdf26269a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c
index 9e51c60d9..70fe6ccf1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c
index 37fc479f5..06e6b52d2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c b/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c
index eca26b5bc..ed3d4a4a6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c b/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c
index 8d20024ef..6413ef8d0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c b/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c
index 2d6a12416..8dc0bd470 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c b/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c
index c74b1ad8b..58a6dbb97 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c b/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c
index 1cd61e27c..584ef1270 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c b/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c
index 6601481ba..77e6e0160 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c b/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c
index 845cb5d84..6138ad3dc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c b/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c
index 1994c0787..65bfdb1d6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c
index caacaa32d..59a91bdec 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c
index 553cd0423..66f4c3119 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c
index b9081d15e..f7a49f4bd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c
index ae26970e0..634e66739 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c
index dbe74e173..7d71f84f4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c
index 271cc2a88..ae1f85ae9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c
index fdec91913..c4e11a18b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c
index 3c196122c..12378ebfe 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c
index fb68e3288..cc2c7d5f6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c
index ebd7ceff0..6591e42c5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c
index 1b1fba40a..94d904506 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c
index 7bc3b1077..eabc7928c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c
index 20bf36382..f205caf00 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c
index a4a141cb2..bf8240fde 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshls16.c b/gcc/testsuite/gcc.target/arm/neon/vshls16.c
index 80ab6f45b..2c8941f9a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshls32.c b/gcc/testsuite/gcc.target/arm/neon/vshls32.c
index f2cd655b1..fb6be6ea0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshls64.c b/gcc/testsuite/gcc.target/arm/neon/vshls64.c
index 23c910f7f..b5a61033f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshls64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshls64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshls8.c b/gcc/testsuite/gcc.target/arm/neon/vshls8.c
index 798a23f5d..a807191ed 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlu16.c b/gcc/testsuite/gcc.target/arm/neon/vshlu16.c
index 6d7fbea47..14f2428d4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlu32.c b/gcc/testsuite/gcc.target/arm/neon/vshlu32.c
index be05c003a..596327584 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlu64.c b/gcc/testsuite/gcc.target/arm/neon/vshlu64.c
index 687cae2ef..f29dedc14 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshlu8.c b/gcc/testsuite/gcc.target/arm/neon/vshlu8.c
index cb0070544..1b900396b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshlu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshlu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c
index 9bd0a8040..286edb14b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c
index 65c41a625..d47d574e8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c
index 9ee9e483d..66b693e73 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c
index f8de705db..f92da931d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c
index 588ffb2f3..8f81e7896 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c
index 5044cbf5e..e5fbf44f8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c
index 89d2c4dc0..a8ff5f7d7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c
index 80ee3f559..673d90e4f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c
index 7576615b8..0a14a00df 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c
index 7b3c4fa31..545478909 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c
index 96ace08a7..3fd27fc98 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c
index f8649d7c7..069978d47 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c
index 4ea2a5317..43c610b62 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c
index 86ab08c84..1b7bb5d33 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c
index 331a99707..a78b9fcf7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c
index 6c94eaff4..cdb968693 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c
index 6ba1e4f21..832dc831a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c
index b84ddc78d..314ba2516 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c
index 6cb52f521..465592a65 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c
index 458698cec..614451a68 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c
index b797205b3..6fe4066ac 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c
index f8368410a..901b17c31 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c
index d15239f1b..601ee13c1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c
index 9151aba8f..8e5a256e8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c
index 82c1f6a48..d3c67ac77 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c
index 2496254b0..12b69848f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c
index 30139f29e..441996f8d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c
index abbe0c39d..8f393b4c9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c
index 00e7cfab2..0936eb759 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c
index 155c70515..23b1dddcf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c
index 19570e22a..b14a16592 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c
index 85a77b862..d6a86a6e3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c b/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c
index d0395f9a3..30d206e79 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c b/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c
index 22eef0f3f..ffcacb25b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c
index 12ba95508..1d58cc7ec 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c
index 7cb9804ee..1920c9115 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c
index 822b05da3..4bef7bc91 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c
index dc01f5051..7b0260f4e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c
index 5bd43815b..addda9c20 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c
index ba4236343..0bdaef3a4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c
index 84ef9f338..3733d7055 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c
index c62744d9e..020e5959b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c
index 7e6796961..d1f6100e4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c
index db0869a10..9d44cca6b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c
index f5ff91d21..bcda76849 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c
index 909c73bad..0dbf181c4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c
index f437b338c..4b6553314 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c
index 41e1b54d2..721459583 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c
index b70347f4d..8a982d205 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c
index 62afb6158..523e5a09b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c
index 6a19cd7e8..37c97c562 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c
index 3ed528cb0..e79430804 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c
index 9a5ce9676..6381a13e3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c
index f1de791ab..6f46eef22 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c
index 0143526c3..42ad77321 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c
index d7e3bc52c..baaab7e48 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c
index bf9e1df59..dc63a5ad9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c
index bc05cc552..5555f75d5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c
index efa39e31a..39a96c080 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c
index 376e8d7c1..d17d7e724 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c
index f69c52b6a..c7375409c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c
index 6108d3641..1b17696aa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c
index d78710f8a..d959c341b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c
index ba4bd196d..b04c800cf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c
index c15a1f6e8..2d3f1d6b7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c
index 634be975f..19c87fec7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c
index 85812e59d..b747b2237 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c
index d83121f23..1e949e5e3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c b/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c
index 7080997ec..a1aac08f1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c b/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c
index abb742f9d..bd102bf98 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c b/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c
index 5eaee7861..bb0687220 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c b/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c
index c813765e5..8712857ba 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c b/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c
index 552c5db77..f54fca4dd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c b/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c
index 9bec2eabd..405e03522 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c b/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c
index 001bc33cf..4c751e792 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c b/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c
index 8bb73bf35..b82f63b59 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c b/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c
index bad5816d0..20381bfd2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c b/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c
index c2cc93dcb..87293317c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c
index e1de667c4..4b0996419 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c
index f2a4f5969..d619d5fc9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c
index f4a56b14e..9bc250bef 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c
index 0a7de3e10..81281a25d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c
index 5211c9ab6..43f769e6d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c
index ab1bda9d4..7ea5940d4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c
index 215c5af52..f34faa5e2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c
index 4e88d26e7..e90dccf96 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c
index 2d416c0ef..42816c043 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c
index 46fe4c345..8b87921a1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c
index 9536e3742..4eeee81bb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c
index e8bab5ae2..bd25c0656 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c
index b83669507..a055bb63a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c
index bdbf4b078..fa98e7ab8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c
index c3c04aaea..4265f3118 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c
index 54fc0bb4b..d252f9a34 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c
index 696b4ce5d..01aeebf98 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c
index 6de3700a3..860b8c5f2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c
index b0667fb9a..2c3cc222d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c
index 88456cf99..f67fc1abe 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c
index 8a390f79f..e0a4d9841 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c
index 0e815e36e..ff9c66fc9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c
index 03fe37db9..57f110600 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c
index 793b8a159..a5fc94fe1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c
index 50de02d2e..6a5ca7ea9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c
index e8d31d3f2..9e1ee3a7f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c
index 73bbe63c5..251b8a968 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c
index 61b08a901..fb48c8b62 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c
index 263113b8a..bc932aed4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c
index 8fe92a508..0ba3d3838 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c
index 65785ee99..bf953c4b2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c
index 6f54cc106..4f486d3f1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c
index 2e96ddfb9..144864f78 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1f32.c b/gcc/testsuite/gcc.target/arm/neon/vst1f32.c
index fc6829b88..3690958bc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1p16.c b/gcc/testsuite/gcc.target/arm/neon/vst1p16.c
index 138b7f806..aa38de111 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1p8.c b/gcc/testsuite/gcc.target/arm/neon/vst1p8.c
index ae57e3b06..bfef51d6d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1s16.c b/gcc/testsuite/gcc.target/arm/neon/vst1s16.c
index 7c2931200..a5e785d3e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1s32.c b/gcc/testsuite/gcc.target/arm/neon/vst1s32.c
index 968447a32..a0088ae51 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1s64.c b/gcc/testsuite/gcc.target/arm/neon/vst1s64.c
index 2e694366b..fc304f92a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1s8.c b/gcc/testsuite/gcc.target/arm/neon/vst1s8.c
index ab8daca15..b63274004 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1u16.c b/gcc/testsuite/gcc.target/arm/neon/vst1u16.c
index 77265c490..381a47e89 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1u32.c b/gcc/testsuite/gcc.target/arm/neon/vst1u32.c
index ef9268460..ec73ac681 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1u64.c b/gcc/testsuite/gcc.target/arm/neon/vst1u64.c
index 6cc6d2ee4..8cd9a28d8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst1u8.c b/gcc/testsuite/gcc.target/arm/neon/vst1u8.c
index 92a37cdab..ff557cee4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst1u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst1u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c
index 4d36a80b5..2d35d1ce4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c
index c3247d075..8a8a84672 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c
index 60c0c14d9..5b01c0ce7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c
index 82c309489..81e125f20 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c
index f966f8fcf..ed4a1e610 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c
index 936009256..d2f39ffd1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c
index 5109dc217..426a19570 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c
index dba266d77..aeae48c0f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c
index 1de005241..d18410cb5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c
index 83fe85290..9fad004eb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c
index ea8411f0c..6cd063d75 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c
index 1eb70b24a..c09dea2e3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c
index 61dfaeebd..6a5cf5635 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c
index ec8556039..4b4d27fb4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c
index c3e5c5db3..e1b32e84e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c
index 4dc5258f5..5aa11e799 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c
index dedaec7fe..27fe65056 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c
index ff88aebef..b6ee44109 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c
index 80aedbaf1..00303752f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c
index 150686d80..6f2cf260d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c
index a71f186b3..5e32ccb61 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c
index 303b8ecf5..bfdf447b1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c
index e1402fcc8..22580003f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c
index 37f320b02..b10c78abf 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2f32.c b/gcc/testsuite/gcc.target/arm/neon/vst2f32.c
index 4b1d03d63..45c084f08 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2p16.c b/gcc/testsuite/gcc.target/arm/neon/vst2p16.c
index 9e788b259..9f29ddf26 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2p8.c b/gcc/testsuite/gcc.target/arm/neon/vst2p8.c
index d40ca694e..92ae9c40a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2s16.c b/gcc/testsuite/gcc.target/arm/neon/vst2s16.c
index 56cdbf811..30b6a2b04 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2s32.c b/gcc/testsuite/gcc.target/arm/neon/vst2s32.c
index 9519eec9b..208e2586b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2s64.c b/gcc/testsuite/gcc.target/arm/neon/vst2s64.c
index e4fda8dc5..4cc53b467 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2s8.c b/gcc/testsuite/gcc.target/arm/neon/vst2s8.c
index 9553e4f5a..e56b49341 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2u16.c b/gcc/testsuite/gcc.target/arm/neon/vst2u16.c
index c0af478d2..7d8d83ec5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2u32.c b/gcc/testsuite/gcc.target/arm/neon/vst2u32.c
index dbde9a6b5..dafab12ca 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2u64.c b/gcc/testsuite/gcc.target/arm/neon/vst2u64.c
index 2487ff238..64f433b18 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst2u8.c b/gcc/testsuite/gcc.target/arm/neon/vst2u8.c
index e35a3ccd1..1b1b6e266 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst2u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst2u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c
index c8409af83..334bc26ad 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c
index 1c058b487..c108bac1d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c
index a6c0c1ae3..c32ffb6fc 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c
index 982d4de45..faafb9333 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c
index c44b1a6d5..f3fc1c60d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c
index 7ddf8887e..e11f4a395 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c
index c8d5d220f..61dc577d7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c
index 6b416bd94..87d769642 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c
index 7b034fd4a..0681c9a47 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c
index c191ea011..e9b864075 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c
index 5fad79bc2..2ec2ef0b7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c
index ba5807e94..d6362573a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c
index 7d23e10b6..f10c69f4d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c
index c6233c087..08820891e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c
index a72a4a822..919a1cbbb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c
index f4e4a4806..d527c7803 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c
index af61dcdbb..491f8eb39 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c
index b5d21c1a3..0546c3ab5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c
index 0f5d9d5a1..482578919 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c
index 9bd76f2e3..51da4144d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c
index b7f5996eb..b75f2109b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c
index d00856247..968605497 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c
index 2e4bf4f68..da1af4052 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c
index c001b0921..47eccc0df 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3f32.c b/gcc/testsuite/gcc.target/arm/neon/vst3f32.c
index 6cd851817..ac871786a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3p16.c b/gcc/testsuite/gcc.target/arm/neon/vst3p16.c
index d3deb3b26..08a861b9f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3p8.c b/gcc/testsuite/gcc.target/arm/neon/vst3p8.c
index 41f9608c7..d357fdfad 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3s16.c b/gcc/testsuite/gcc.target/arm/neon/vst3s16.c
index 73cb6932b..4fc940e69 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3s32.c b/gcc/testsuite/gcc.target/arm/neon/vst3s32.c
index 46feb60a8..82b4cfa6a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3s64.c b/gcc/testsuite/gcc.target/arm/neon/vst3s64.c
index 93834d6dd..a8e86d236 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3s8.c b/gcc/testsuite/gcc.target/arm/neon/vst3s8.c
index f093584f1..563534db2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3u16.c b/gcc/testsuite/gcc.target/arm/neon/vst3u16.c
index dc634f00a..679d7b833 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3u32.c b/gcc/testsuite/gcc.target/arm/neon/vst3u32.c
index a7eeef402..8705c5eb6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3u64.c b/gcc/testsuite/gcc.target/arm/neon/vst3u64.c
index 4cd844068..4b15e68b3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst3u8.c b/gcc/testsuite/gcc.target/arm/neon/vst3u8.c
index 83c6155cb..0e31b3b3a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst3u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst3u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c
index 937168e8b..cb2de05bb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c
index 549360c88..3d0f81d0c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c
index b9b25fbfd..6e174a0c9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c
index cab45ab99..323626c92 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c
index 61aba31c0..5a396ac3e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c
index 98144c11d..4c3dd6a85 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c
index ad51afdcb..4da79bff1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c
index 1ab633799..4892d6df4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c
index 3e32382d9..3d51e9713 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c
index 8581c41d9..9fccc6a62 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c
index 8a66e9647..faa1db202 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c
index 14e8ab8ff..c68fc821d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c
index 5f14fa80d..98f9b094d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c
index e42744648..c9bfd05f2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c b/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c
index b67bb19ff..8b86161fa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c
index 8d0eab5bb..4bdde6ea5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c
index 7dbddf3c1..c9889b382 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c
index 1791964da..3d8ef6e4f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c
index 46a4c92f5..255b4b9b7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c
index 1a9491c10..fc5217381 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c
index 15cbab1f8..e9dec5d88 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c
index 96a0182ac..ee513a640 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c
index c8b19220e..516d04c88 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c
index 0dbcd5483..531c2b974 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4f32.c b/gcc/testsuite/gcc.target/arm/neon/vst4f32.c
index 9e37af218..e3268f9b8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4f32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4f32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4p16.c b/gcc/testsuite/gcc.target/arm/neon/vst4p16.c
index f07d43524..67f32f296 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4p16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4p16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4p8.c b/gcc/testsuite/gcc.target/arm/neon/vst4p8.c
index ddee22802..2ed766a8d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4s16.c b/gcc/testsuite/gcc.target/arm/neon/vst4s16.c
index 8ca806078..94794662d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4s16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4s16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4s32.c b/gcc/testsuite/gcc.target/arm/neon/vst4s32.c
index 9619e4b50..8d22a0406 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4s32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4s32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4s64.c b/gcc/testsuite/gcc.target/arm/neon/vst4s64.c
index 0b470ad84..c9dffec77 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4s64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4s64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4s8.c b/gcc/testsuite/gcc.target/arm/neon/vst4s8.c
index 796c44663..0dbdfc047 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4u16.c b/gcc/testsuite/gcc.target/arm/neon/vst4u16.c
index 3ce82b70c..4eddaf6d6 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4u16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4u16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4u32.c b/gcc/testsuite/gcc.target/arm/neon/vst4u32.c
index 36df64969..06a5d33cb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4u32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4u32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4u64.c b/gcc/testsuite/gcc.target/arm/neon/vst4u64.c
index 3d11dd06d..063a046af 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4u64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4u64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vst4u8.c b/gcc/testsuite/gcc.target/arm/neon/vst4u8.c
index 4d4dde14e..d4da67b92 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vst4u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vst4u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c b/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c
index bacf30471..88caa2898 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c b/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c
index 01b4f6d97..d33790b9c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c b/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c
index 1de3a942a..77b2a743f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c b/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c
index 1ac90a0e5..1b0c5a198 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c b/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c
index e3b819b8c..11b2f6a8b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c b/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c
index 46ad52bf2..e3f750406 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c b/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c
index 391f54c56..5fe1d0b4a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c b/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c
index f542d37e5..19536b992 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c b/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c
index 1f8ec0f5b..c9f5d95b4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubf32.c b/gcc/testsuite/gcc.target/arm/neon/vsubf32.c
index ee29262a8..442828abd 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c b/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c
index 034e87a8b..06e6189be 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c b/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c
index 5c5d0bdce..42e8b5740 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c b/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c
index 2e7e5ca7f..f314a40d5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c b/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c
index 91f6aa0b4..5c3f82624 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c b/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c
index 36ce23e67..1bd62fc15 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c b/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c
index bde5a7a34..35fa65afa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubls16.c b/gcc/testsuite/gcc.target/arm/neon/vsubls16.c
index f346d0047..1db042d94 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubls16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubls16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubls32.c b/gcc/testsuite/gcc.target/arm/neon/vsubls32.c
index db6189018..e8acf9240 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubls32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubls32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubls8.c b/gcc/testsuite/gcc.target/arm/neon/vsubls8.c
index e3cad6fb5..7b457cadb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubls8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubls8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsublu16.c b/gcc/testsuite/gcc.target/arm/neon/vsublu16.c
index cb3012922..b9cc873ec 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsublu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsublu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsublu32.c b/gcc/testsuite/gcc.target/arm/neon/vsublu32.c
index e9541f92e..afb456e65 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsublu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsublu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsublu8.c b/gcc/testsuite/gcc.target/arm/neon/vsublu8.c
index 51f68dcfe..890925437 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsublu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsublu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubs16.c b/gcc/testsuite/gcc.target/arm/neon/vsubs16.c
index 1b97aef20..0638a7dfe 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubs32.c b/gcc/testsuite/gcc.target/arm/neon/vsubs32.c
index 11e1a373c..0c9b6a360 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubs64.c b/gcc/testsuite/gcc.target/arm/neon/vsubs64.c
index 85074fb94..57bcd33d4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubs64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubs64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vsubs64 (void)
   out_int64x1_t = vsub_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubs8.c b/gcc/testsuite/gcc.target/arm/neon/vsubs8.c
index 4cfe5db3e..cb927d615 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubu16.c b/gcc/testsuite/gcc.target/arm/neon/vsubu16.c
index d1039ac17..80985e247 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubu32.c b/gcc/testsuite/gcc.target/arm/neon/vsubu32.c
index eca7e86af..47d595ba1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubu64.c b/gcc/testsuite/gcc.target/arm/neon/vsubu64.c
index e6307c231..3a8ae462e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubu64.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubu64.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
@@ -16,5 +17,4 @@ void test_vsubu64 (void)
   out_uint64x1_t = vsub_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubu8.c b/gcc/testsuite/gcc.target/arm/neon/vsubu8.c
index 02b945c61..b359e1655 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubws16.c b/gcc/testsuite/gcc.target/arm/neon/vsubws16.c
index a821ae65a..90cbe20a4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubws16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubws16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubws32.c b/gcc/testsuite/gcc.target/arm/neon/vsubws32.c
index 4e1e7ddb7..963e5933c 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubws32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubws32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubws8.c b/gcc/testsuite/gcc.target/arm/neon/vsubws8.c
index 223050899..103b8fcb3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubws8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubws8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c b/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c
index e35073ba2..98e5cdac3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c b/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c
index e4270aa2f..ccd2a7b09 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c b/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c
index 5d8aa55cd..c89e73331 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c
index 177db25a9..225159c3a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c
index 1e77e3078..a8ecd46e1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c
index 8719c2854..1d2ea7d0d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c
index 07bdc05d3..bb748f95b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c
index 04a824d84..29dc16190 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c
index ce29a23a0..493538461 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c
index dce7bbb04..4bc77fa1f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c
index 1b62f6d29..f088f3777 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c
index 9837e5320..3f84d0062 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c
index c60e2dcc0..2cdc37d04 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c
index c89d2b101..870c9bd4e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c
index 1e98a31eb..461fc9569 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c
index 136d80e64..a081f169e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c
index 23e59836e..400ef33ca 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c
index 46320636a..da4a65d43 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c
index 2b46e7ea9..ffc07b470 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c
index 6efb84ffe..96c9104a1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c
index a74568942..4b5606448 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c
index a8f9a2910..8f06ef92e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c
index 9de0184cd..996277476 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c
index 45e7e05d1..b6785512a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c
index a283be7bc..c021cf823 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c
index f64198c9f..c06b1aaf9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c b/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c
index de5ebd706..e43ca46f9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c
index c011dc9a6..690fa19d8 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c
index 3f86f8ad8..58f156eab 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c
index 2406d8852..0819bfbf2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c
index 971977af4..dc4f76e8e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c
index b89558668..fe71416de 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c
index c7a62b6e1..5ddd827d4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c
index e36b18d76..1d66dae84 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c
index dee79ce16..2712dd513 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c b/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c
index 7fbffd9e6..58f6f64e9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c b/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c
index c31e250c5..a0c352e10 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c b/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c
index f2d0357ae..b970a6a26 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c b/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c
index 97eb848e8..615bd5750 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrns16.c b/gcc/testsuite/gcc.target/arm/neon/vtrns16.c
index 98ddc529c..068720c86 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrns16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrns16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrns32.c b/gcc/testsuite/gcc.target/arm/neon/vtrns32.c
index ae02e6a1e..2966ca5f1 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrns32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrns32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrns8.c b/gcc/testsuite/gcc.target/arm/neon/vtrns8.c
index 6d45572b6..bf900a107 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrns8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrns8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c b/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c
index 4f7a6dae2..aa98b4026 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c b/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c
index b9a9dbcdf..9875ad3c4 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c b/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c
index 4de249665..f4766be76 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c b/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c
index 38f8a4b7a..69e876328 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c b/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c
index 607a01ef6..a41fd7df9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c b/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c
index b2b3def48..b5e46b442 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c b/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c
index d5faf9a9e..f3bf7004a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c b/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c
index 8dfa203e9..7024ebe1e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c b/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c
index 024e57859..717ffd1ef 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c b/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c
index 0d7f3b255..bc3729961 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstp8.c b/gcc/testsuite/gcc.target/arm/neon/vtstp8.c
index 93327b9d7..6bd7cae15 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtsts16.c b/gcc/testsuite/gcc.target/arm/neon/vtsts16.c
index 30b788470..1637af486 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtsts16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtsts16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtsts32.c b/gcc/testsuite/gcc.target/arm/neon/vtsts32.c
index f5dafb227..e8037b977 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtsts32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtsts32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtsts8.c b/gcc/testsuite/gcc.target/arm/neon/vtsts8.c
index f4c416214..ec3379adb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtsts8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtsts8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstu16.c b/gcc/testsuite/gcc.target/arm/neon/vtstu16.c
index 6f8005cea..629855f61 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstu32.c b/gcc/testsuite/gcc.target/arm/neon/vtstu32.c
index b98e12c32..a8b774b7b 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vtstu8.c b/gcc/testsuite/gcc.target/arm/neon/vtstu8.c
index 0c7f38043..51480d8ab 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vtstu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vtstu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c
index 29339566c..2f429394e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c
index 51a90d337..31760090a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c
index f9765651a..e5d7a2de5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c
index aeb29673d..b0a427e4d 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c
index 3bf1ad938..b883174b9 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c
index 194b596b8..84d2a8afb 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c
index 6312ca702..f583a5082 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c
index f7d854c3d..3c96ef362 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c b/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c
index eef40e53f..f385a56ce 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c b/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c
index 056795eac..ca92c7e9a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c b/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c
index d198675cc..cf2b796ef 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c b/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c
index 292a22899..da46ec058 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzps16.c b/gcc/testsuite/gcc.target/arm/neon/vuzps16.c
index 3d6590341..4d0a90670 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzps16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzps16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzps32.c b/gcc/testsuite/gcc.target/arm/neon/vuzps32.c
index 68767dc8a..b337fad20 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzps32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzps32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzps8.c b/gcc/testsuite/gcc.target/arm/neon/vuzps8.c
index ef9704c36..73da12852 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzps8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzps8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c b/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c
index f6d463630..259a141e7 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c b/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c
index 33b75c55e..1d5fae6a2 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c b/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c
index 99fec5c19..e5e368039 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c b/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c
index f1d0393fb..fee46b793 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c b/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c
index d378c5166..1a0b0803e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c b/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c
index ce557b78a..c0cca6074 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c b/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c
index b629a40c6..2979d1a0e 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c b/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c
index 09c0ef6a7..4a96c4aa3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c b/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c
index 6bc9461c4..718756774 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c b/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c
index 743929027..b4641de3a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c b/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c
index d499070e6..c8fee60c5 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c b/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c
index 35d0ef6a1..eee6bc54f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipf32.c b/gcc/testsuite/gcc.target/arm/neon/vzipf32.c
index e1f7ff1d7..d270aa13a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipf32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipf32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipp16.c b/gcc/testsuite/gcc.target/arm/neon/vzipp16.c
index e8a62b107..726500ed3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipp16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipp16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipp8.c b/gcc/testsuite/gcc.target/arm/neon/vzipp8.c
index 553b69127..4a5dd76b0 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipp8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipp8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzips16.c b/gcc/testsuite/gcc.target/arm/neon/vzips16.c
index 0693ee7af..795bab6d3 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzips16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzips16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzips32.c b/gcc/testsuite/gcc.target/arm/neon/vzips32.c
index 29990f3ac..ce3e8117f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzips32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzips32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzips8.c b/gcc/testsuite/gcc.target/arm/neon/vzips8.c
index 9546ad88d..cca6933aa 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzips8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzips8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipu16.c b/gcc/testsuite/gcc.target/arm/neon/vzipu16.c
index ebcb9f23c..53822f93a 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipu16.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipu16.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipu32.c b/gcc/testsuite/gcc.target/arm/neon/vzipu32.c
index 6ba6c32aa..1e6d3844f 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipu32.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipu32.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/neon/vzipu8.c b/gcc/testsuite/gcc.target/arm/neon/vzipu8.c
index 94a280cd4..056898939 100644
--- a/gcc/testsuite/gcc.target/arm/neon/vzipu8.c
+++ b/gcc/testsuite/gcc.target/arm/neon/vzipu8.c
@@ -3,7 +3,8 @@
 
 /* { dg-do assemble } */
 /* { dg-require-effective-target arm_neon_ok } */
-/* { dg-options "-save-temps -O0 -mfpu=neon -mfloat-abi=softfp" } */
+/* { dg-options "-save-temps -O0" } */
+/* { dg-add-options arm_neon } */
 
 #include "arm_neon.h"
 
diff --git a/gcc/testsuite/gcc.target/arm/pr39429.c b/gcc/testsuite/gcc.target/arm/pr39429.c
new file mode 100644
index 000000000..e69584354
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr39429.c
@@ -0,0 +1,28 @@
+/* PR target/39429 */
+/* { dg-do run } */
+/* { dg-options "-O2 -mtune=arm740t" } */
+
+struct obj {
+    unsigned int _filler[270];
+    unsigned int mapsize;
+    unsigned int size;
+};
+
+int __attribute__((noinline)) useOffScreen(struct obj *obj)
+{
+    unsigned int size = obj->size;
+    unsigned int mapsize = obj->mapsize;
+
+    return (mapsize - size) < 16*1024 ? 0 : 1;
+}
+
+int main(void)
+{
+    struct obj obj;
+
+    obj.mapsize = 0;
+    obj.size = 0;
+    if (useOffScreen(&obj) != 0)
+	__builtin_abort();
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr40482.c b/gcc/testsuite/gcc.target/arm/pr40482.c
new file mode 100644
index 000000000..4303a4f2e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr40482.c
@@ -0,0 +1,7 @@
+/* { dg-options "-mthumb -Os" }  */
+/* { dg-final { scan-assembler-not "ldr" } } */
+
+unsigned int foo (unsigned int i )
+{
+  return i | 0xff000000;
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr42496.c b/gcc/testsuite/gcc.target/arm/pr42496.c
new file mode 100644
index 000000000..c6d8a1f39
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr42496.c
@@ -0,0 +1,16 @@
+/* { dg-options "-O2" }  */
+
+void foo(int i)
+{
+    extern int j;
+
+    if (i) {
+         j = 10;
+    }
+    else {
+          j = 20;
+    }
+}
+
+/* { dg-final { scan-assembler-not "strne" } } */
+/* { dg-final { scan-assembler-not "streq" } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr45094.c b/gcc/testsuite/gcc.target/arm/pr45094.c
new file mode 100644
index 000000000..05f16d802
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr45094.c
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O2 -mcpu=cortex-a8" } */
+/* { dg-add-options arm_neon } */
+
+#include <stdlib.h>
+
+long long buffer[32];
+
+void __attribute__((noinline)) f(long long *p, int n)
+{
+  while (--n >= 0)
+    {
+      *p = 1;
+      p += 32;
+    }
+}
+
+int main(void)
+{
+  f(buffer, 1);
+  
+  if (!buffer[0])
+    abort();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/thumb2-mul-space-2.c b/gcc/testsuite/gcc.target/arm/thumb2-mul-space-2.c
new file mode 100644
index 000000000..b53df2fa1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/thumb2-mul-space-2.c
@@ -0,0 +1,15 @@
+/* In Thumb-2 mode, when optimizing for size, generate a "muls"
+   instruction and use the resulting condition flags rather than a
+   separate compare instruction.  */
+/* { dg-options "-mthumb -Os" }  */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-final { scan-assembler "muls" } } */
+/* { dg-final { scan-assembler-not "cmp" } } */
+
+int x;
+
+void f(int i, int j)
+{
+  if (i * j < 0)
+    x = 1;
+}
diff --git a/gcc/testsuite/gcc.target/arm/thumb2-mul-space-3.c b/gcc/testsuite/gcc.target/arm/thumb2-mul-space-3.c
new file mode 100644
index 000000000..143a6deee
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/thumb2-mul-space-3.c
@@ -0,0 +1,17 @@
+/* In Thumb-2 mode, when optimizing for size, generate a "muls"
+   instruction and use the resulting condition flags rather than a
+   separate compare instruction.  */
+/* { dg-options "-mthumb -Os" }  */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-final { scan-assembler "muls" } } */
+/* { dg-final { scan-assembler-not "cmp" } } */
+
+int x;
+
+int f(int i, int j)
+{
+  i = i * j;
+  if (i < 0)
+    x = 1;
+  return i;
+}
diff --git a/gcc/testsuite/gcc.target/arm/thumb2-mul-space.c b/gcc/testsuite/gcc.target/arm/thumb2-mul-space.c
new file mode 100644
index 000000000..8cf0cb40f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/thumb2-mul-space.c
@@ -0,0 +1,10 @@
+/* Use 16-bit multiply instruction in Thumb-2 mode when optimizing for
+   size.  */
+/* { dg-options "-mthumb -Os" }  */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-final { scan-assembler "muls" } } */
+
+int f(int i, int j) 
+{
+  return i * j;
+}
diff --git a/gcc/testsuite/gcc.target/arm/thumb2-mul-speed.c b/gcc/testsuite/gcc.target/arm/thumb2-mul-speed.c
new file mode 100644
index 000000000..03cccdb65
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/thumb2-mul-speed.c
@@ -0,0 +1,27 @@
+/* Do not use 16-bit multiply instructions in Thumb-2 mode when
+   optimizing for speed.  */
+/* { dg-options "-mthumb -O2" }  */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-final { scan-assembler-not "muls" } } */
+
+int f(int i, int j) 
+{
+  return i * j;
+}
+
+int x;
+
+void g(int i, int j)
+{
+  if (i * j < 0)
+    x = 1;
+}
+
+int h(int i, int j)
+{
+  i = i * j;
+  if (i < 0)
+    x = 1;
+  return i;
+}
+
diff --git a/gcc/testsuite/gcc.target/arm/vfp-ldmdbd.c b/gcc/testsuite/gcc.target/arm/vfp-ldmdbd.c
new file mode 100644
index 000000000..c54010872
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/vfp-ldmdbd.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+extern void bar (double);
+
+void
+foo (double *p, double a, int n)
+{
+  do
+    bar (*--p + a);
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fldmdbd" } } */
diff --git a/gcc/testsuite/gcc.target/arm/vfp-ldmdbs.c b/gcc/testsuite/gcc.target/arm/vfp-ldmdbs.c
new file mode 100644
index 000000000..83849c8b5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/vfp-ldmdbs.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+extern void baz (float);
+
+void
+foo (float *p, float a, int n)
+{
+  do
+    bar (*--p + a);
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fldmdbs" } } */
diff --git a/gcc/testsuite/gcc.target/arm/vfp-ldmiad.c b/gcc/testsuite/gcc.target/arm/vfp-ldmiad.c
new file mode 100644
index 000000000..1f849194f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/vfp-ldmiad.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+extern void bar (double);
+
+void
+foo (double *p, double a, int n)
+{
+  do
+    bar (*p++ + a);
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fldmiad" } } */
diff --git a/gcc/testsuite/gcc.target/arm/vfp-ldmias.c b/gcc/testsuite/gcc.target/arm/vfp-ldmias.c
new file mode 100644
index 000000000..061cdd956
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/vfp-ldmias.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+extern void baz (float);
+
+void
+foo (float *p, float a, int n)
+{
+  do
+    bar (*p++ + a);
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fldmias" } } */
diff --git a/gcc/testsuite/gcc.target/arm/vfp-stmdbd.c b/gcc/testsuite/gcc.target/arm/vfp-stmdbd.c
new file mode 100644
index 000000000..f80c40383
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/vfp-stmdbd.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+void
+foo (double *p, double a, double b, int n)
+{
+  double c = a + b;
+  do
+    *--p = c;
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fstmdbd" } } */
diff --git a/gcc/testsuite/gcc.target/arm/vfp-stmdbs.c b/gcc/testsuite/gcc.target/arm/vfp-stmdbs.c
new file mode 100644
index 000000000..79b3c81e3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/vfp-stmdbs.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+void
+foo (float *p, float a, float b, int n)
+{
+  float c = a + b;
+  do
+    *--p = c;
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fstmdbs" } } */
diff --git a/gcc/testsuite/gcc.target/arm/vfp-stmiad.c b/gcc/testsuite/gcc.target/arm/vfp-stmiad.c
new file mode 100644
index 000000000..20742c266
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/vfp-stmiad.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+void
+foo (double *p, double a, double b, int n)
+{
+  double c = a + b;
+  do
+    *p++ = c;
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fstmiad" } } */
diff --git a/gcc/testsuite/gcc.target/arm/vfp-stmias.c b/gcc/testsuite/gcc.target/arm/vfp-stmias.c
new file mode 100644
index 000000000..05ce39987
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/vfp-stmias.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_vfp_ok } */
+/* { dg-options "-O2 -mfpu=vfp -mfloat-abi=softfp" } */
+
+void
+foo (float *p, float a, float b, int n)
+{
+  float c = a + b;
+  do
+    *p++ = c;
+  while (n--);
+}
+
+/* { dg-final { scan-assembler "fstmias" } } */
diff --git a/gcc/testsuite/gcc.target/i386/387-1.c b/gcc/testsuite/gcc.target/i386/387-1.c
index 2b3ca0b06..83af71f96 100644
--- a/gcc/testsuite/gcc.target/i386/387-1.c
+++ b/gcc/testsuite/gcc.target/i386/387-1.c
@@ -1,6 +1,7 @@
 /* Verify that -mno-fancy-math-387 works.  */
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-O -ffast-math -mfpmath=387 -mno-fancy-math-387 -march=i386" } */
 /* { dg-final { scan-assembler "call\t(.*)sin" } } */
 /* { dg-final { scan-assembler "call\t(.*)cos" } } */
diff --git a/gcc/testsuite/gcc.target/i386/387-5.c b/gcc/testsuite/gcc.target/i386/387-5.c
index 0a0500817..027799a87 100644
--- a/gcc/testsuite/gcc.target/i386/387-5.c
+++ b/gcc/testsuite/gcc.target/i386/387-5.c
@@ -1,6 +1,7 @@
 /* Verify that -mno-fancy-math-387 works.  */
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-O -ffast-math -mfpmath=387 -mno-fancy-math-387 -march=i386" } */
 /* { dg-final { scan-assembler "call\t(.*)atan" } } */
 /* { dg-final { scan-assembler "call\t(.*)log1p" } } */
diff --git a/gcc/testsuite/gcc.target/i386/cmov7.c b/gcc/testsuite/gcc.target/i386/cmov7.c
index 31b481654..433bf57f8 100644
--- a/gcc/testsuite/gcc.target/i386/cmov7.c
+++ b/gcc/testsuite/gcc.target/i386/cmov7.c
@@ -1,6 +1,7 @@
 /* PR middle-end/33187 */
 
 /* { dg-do compile } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=k8" } } */
 /* { dg-options "-O2 -ffast-math -march=k8 -mbranch-cost=5 -mfpmath=387" } */
 /* { dg-final { scan-assembler "fcmov" } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/funcspec-1.c b/gcc/testsuite/gcc.target/i386/funcspec-1.c
index 1416c75f3..52420ec93 100644
--- a/gcc/testsuite/gcc.target/i386/funcspec-1.c
+++ b/gcc/testsuite/gcc.target/i386/funcspec-1.c
@@ -3,6 +3,7 @@
    for a function that doesn't use attribute((option)).  */
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-O3 -ftree-vectorize -march=i386" } */
 /* { dg-final { scan-assembler "addps\[ \t\]" } } */
 /* { dg-final { scan-assembler "fsubs\[ \t\]" } } */
diff --git a/gcc/testsuite/gcc.target/i386/funcspec-8.c b/gcc/testsuite/gcc.target/i386/funcspec-8.c
index 2478c672d..6e707ba77 100644
--- a/gcc/testsuite/gcc.target/i386/funcspec-8.c
+++ b/gcc/testsuite/gcc.target/i386/funcspec-8.c
@@ -1,6 +1,7 @@
 /* Test whether using target specific options, we can use the x86 builtin
    functions in functions with the appropriate function specific options.  */
 /* { dg-do compile } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=k8" } } */
 /* { dg-options "-O2 -march=k8 -mfpmath=sse" } */
 
 typedef float     __m128  __attribute__ ((__vector_size__ (16), __may_alias__));
diff --git a/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-1.c b/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-1.c
index 598f2ddbc..d20a71760 100644
--- a/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-1.c
+++ b/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-1.c
@@ -1,5 +1,6 @@
 /* { dg-do preprocess } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-march=i386" } */
 
 #ifdef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1
diff --git a/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-2.c b/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-2.c
index fa6e7c654..01a49b64a 100644
--- a/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-2.c
+++ b/gcc/testsuite/gcc.target/i386/gcc-have-sync-compare-and-swap-2.c
@@ -1,5 +1,6 @@
 /* { dg-do preprocess } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i486" } } */
 /* { dg-options "-march=i486" } */
 
 #ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1
diff --git a/gcc/testsuite/gcc.target/i386/isa-10.c b/gcc/testsuite/gcc.target/i386/isa-10.c
index 76fe35593..e95e0975c 100644
--- a/gcc/testsuite/gcc.target/i386/isa-10.c
+++ b/gcc/testsuite/gcc.target/i386/isa-10.c
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=x86-64" } } */
 /* { dg-options "-march=x86-64 -msse5 -mno-sse4" } */
 
 extern void abort (void);
diff --git a/gcc/testsuite/gcc.target/i386/isa-6.c b/gcc/testsuite/gcc.target/i386/isa-6.c
index ec1fbeaa4..7f01a884e 100644
--- a/gcc/testsuite/gcc.target/i386/isa-6.c
+++ b/gcc/testsuite/gcc.target/i386/isa-6.c
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=amdfam10" } } */
 /* { dg-options "-march=amdfam10 -mno-sse4" } */
 
 extern void abort (void);
diff --git a/gcc/testsuite/gcc.target/i386/isa-7.c b/gcc/testsuite/gcc.target/i386/isa-7.c
index 76ea31ed2..799671d7f 100644
--- a/gcc/testsuite/gcc.target/i386/isa-7.c
+++ b/gcc/testsuite/gcc.target/i386/isa-7.c
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=amdfam10" } } */
 /* { dg-options "-march=amdfam10 -msse5 -mno-sse4" } */
 
 extern void abort (void);
diff --git a/gcc/testsuite/gcc.target/i386/isa-8.c b/gcc/testsuite/gcc.target/i386/isa-8.c
index fb37669dc..66cf25b10 100644
--- a/gcc/testsuite/gcc.target/i386/isa-8.c
+++ b/gcc/testsuite/gcc.target/i386/isa-8.c
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=amdfam10" } } */
 /* { dg-options "-march=amdfam10 -msse5 -mno-sse4a" } */
 
 extern void abort (void);
diff --git a/gcc/testsuite/gcc.target/i386/isa-9.c b/gcc/testsuite/gcc.target/i386/isa-9.c
index fefdef6a0..dd9bc4d02 100644
--- a/gcc/testsuite/gcc.target/i386/isa-9.c
+++ b/gcc/testsuite/gcc.target/i386/isa-9.c
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=amdfam10" } } */
 /* { dg-options "-march=amdfam10 -mno-sse5" } */
 
 extern void abort (void);
diff --git a/gcc/testsuite/gcc.target/i386/lea.c b/gcc/testsuite/gcc.target/i386/lea.c
index afbbfa4fb..f8f967e00 100644
--- a/gcc/testsuite/gcc.target/i386/lea.c
+++ b/gcc/testsuite/gcc.target/i386/lea.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=pentiumpro" } } */
 /* { dg-options "-O2 -march=pentiumpro" } */
 /* { dg-final { scan-assembler "leal" } } */
 typedef struct {
diff --git a/gcc/testsuite/gcc.target/i386/movbe-1.c b/gcc/testsuite/gcc.target/i386/movbe-1.c
new file mode 100644
index 000000000..391d4ad98
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/movbe-1.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mmovbe" } */
+
+extern int x;
+
+void
+foo (int i)
+{
+  x = __builtin_bswap32 (i);
+}
+
+int
+bar ()
+{
+  return __builtin_bswap32 (x);
+}
+
+/* { dg-final { scan-assembler-times "movbe\[ \t\]" 2 } } */
diff --git a/gcc/testsuite/gcc.target/i386/movbe-2.c b/gcc/testsuite/gcc.target/i386/movbe-2.c
new file mode 100644
index 000000000..d898f20dc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/movbe-2.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mmovbe" } */
+
+extern long long x;
+
+void
+foo (long long i)
+{
+  x = __builtin_bswap64 (i);
+}
+
+long long
+bar ()
+{
+  return __builtin_bswap64 (x);
+}
+
+/* { dg-final { scan-assembler-times "movbe\[ \t\]" 4 { target ilp32 } } } */
+/* { dg-final { scan-assembler-times "movbe\[ \t\]" 2 { target lp64 } } } */
diff --git a/gcc/testsuite/gcc.target/i386/pentium4-not-mull.c b/gcc/testsuite/gcc.target/i386/pentium4-not-mull.c
index be48185a8..a846aae61 100644
--- a/gcc/testsuite/gcc.target/i386/pentium4-not-mull.c
+++ b/gcc/testsuite/gcc.target/i386/pentium4-not-mull.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=pentium4" } } */
 /* { dg-options "-O2 -march=pentium4" } */
 /* { dg-final { scan-assembler-not "imull" } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/pr37216.c b/gcc/testsuite/gcc.target/i386/pr37216.c
new file mode 100644
index 000000000..5c847a70c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr37216.c
@@ -0,0 +1,17 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -msse2" } */
+/* { dg-options "-O3 -msse2 -mpe-aligned-commons" { target pe_aligned_commons } } */
+
+#include "sse2-check.h"
+
+int iarr[64];
+int iint = 0;
+
+void
+sse2_test (void)
+{
+  int i;
+
+  for (i = 0; i < 64; i++)
+    iarr[i] = -2;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr37843-1.c b/gcc/testsuite/gcc.target/i386/pr37843-1.c
index e37ea9df2..981988223 100644
--- a/gcc/testsuite/gcc.target/i386/pr37843-1.c
+++ b/gcc/testsuite/gcc.target/i386/pr37843-1.c
@@ -2,8 +2,8 @@
 /* { dg-do compile { target nonpic } } */
 /* { dg-options "-O2 -mpreferred-stack-boundary=6 -mincoming-stack-boundary=5" } */
 /* { dg-final { scan-assembler "and\[lq\]?\[\\t \]*\\$-64,\[\\t \]*%\[re\]?sp" } } */
-/* { dg-final { scan-assembler "call\[\\t \]*foo" } } */
-/* { dg-final { scan-assembler-not "jmp\[\\t \]*foo" } } */
+/* { dg-final { scan-assembler "call\[\\t \]*_?foo" } } */
+/* { dg-final { scan-assembler-not "jmp\[\\t \]*_?foo" } } */
 
 extern int foo (void);
 
diff --git a/gcc/testsuite/gcc.target/i386/pr37843-2.c b/gcc/testsuite/gcc.target/i386/pr37843-2.c
index e36cb0d95..fa177714a 100644
--- a/gcc/testsuite/gcc.target/i386/pr37843-2.c
+++ b/gcc/testsuite/gcc.target/i386/pr37843-2.c
@@ -2,8 +2,8 @@
 /* { dg-do compile { target nonpic } } */
 /* { dg-options "-O2 -mpreferred-stack-boundary=6 -mincoming-stack-boundary=6" } */
 /* { dg-final { scan-assembler-not "and\[lq\]?\[\\t \]*\\$-64,\[\\t \]*%\[re\]?sp" } } */
-/* { dg-final { scan-assembler-not "call\[\\t \]*foo" } } */
-/* { dg-final { scan-assembler "jmp\[\\t \]*foo" } } */
+/* { dg-final { scan-assembler-not "call\[\\t \]*_?foo" } } */
+/* { dg-final { scan-assembler "jmp\[\\t \]*_?foo" } } */
 
 extern int foo (void);
 
diff --git a/gcc/testsuite/gcc.target/i386/pr37843-3.c b/gcc/testsuite/gcc.target/i386/pr37843-3.c
index bfb2ffe06..ed6478ee5 100644
--- a/gcc/testsuite/gcc.target/i386/pr37843-3.c
+++ b/gcc/testsuite/gcc.target/i386/pr37843-3.c
@@ -3,8 +3,8 @@
 /* { dg-options "-O2 -msse2 -mpreferred-stack-boundary=4 -mstackrealign" } */
 /* { dg-require-effective-target sse2 } */
 /* { dg-final { scan-assembler-not "andl\[\\t \]*\\$-16,\[\\t \]*%\[re\]?sp" } } */
-/* { dg-final { scan-assembler-not "call\[\\t \]*foo" } } */
-/* { dg-final { scan-assembler "jmp\[\\t \]*foo" } } */
+/* { dg-final { scan-assembler-not "call\[\\t \]*_?foo" } } */
+/* { dg-final { scan-assembler "jmp\[\\t \]*_?foo" } } */
 
 #include <emmintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/pr9771-1.c b/gcc/testsuite/gcc.target/i386/pr9771-1.c
index 01f2f2975..37ec49022 100644
--- a/gcc/testsuite/gcc.target/i386/pr9771-1.c
+++ b/gcc/testsuite/gcc.target/i386/pr9771-1.c
@@ -28,7 +28,10 @@ void foo()
   *adr = save;
 }
 
-int main()
+/* This must not be inlined becuase main() requires the frame pointer
+   for stack alignment.  */
+void test(void) __attribute__((noinline));
+void test(void)
 {
   B = &x;
 
@@ -42,3 +45,9 @@ int main()
   exit(0);
 }
 
+int main()
+{
+  test();
+  return 0;
+
+}
diff --git a/gcc/testsuite/gcc.target/i386/sse-5.c b/gcc/testsuite/gcc.target/i386/sse-5.c
index c3ed8f267..bdbd5012e 100644
--- a/gcc/testsuite/gcc.target/i386/sse-5.c
+++ b/gcc/testsuite/gcc.target/i386/sse-5.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-Winline -O2 -march=i386" } */
 
 typedef double v2df __attribute__ ((vector_size (16)));
diff --git a/gcc/testsuite/gcc.target/i386/ssefn-1.c b/gcc/testsuite/gcc.target/i386/ssefn-1.c
index 07e634e33..37bbf6f5e 100644
--- a/gcc/testsuite/gcc.target/i386/ssefn-1.c
+++ b/gcc/testsuite/gcc.target/i386/ssefn-1.c
@@ -8,6 +8,7 @@
 /* { dg-final { scan-assembler "mulss" } } */
 /* { dg-final { scan-assembler-not "movsd" } } */
 /* { dg-final { scan-assembler-not "mulsd" } } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=i386" } } */
 /* { dg-options "-O2 -march=i386 -msse -mfpmath=sse -fno-inline" } */
 
 static float xs (void)
diff --git a/gcc/testsuite/gcc.target/m68k/20090709-1.c b/gcc/testsuite/gcc.target/m68k/20090709-1.c
new file mode 100644
index 000000000..fda05b756
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/20090709-1.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* There should be 3 occurrences of .LC0 in the code:
+   one for the definition of "0",
+   one for use in test1() and
+   one for use in test2().
+   FIXME: At the moment m68k GCC does not optimize test1() to nop
+   for some reason.  */
+/* { dg-final { scan-assembler-times ".LC0" 3 } } */
+
+void dummy(char *arg);
+
+void test1(void)
+{
+  char tmp[2] = "0";
+}
+
+void test2(void)
+{
+  dummy("0");
+}
diff --git a/gcc/testsuite/gcc.target/m68k/20100512-1.c b/gcc/testsuite/gcc.target/m68k/20100512-1.c
new file mode 100644
index 000000000..d07bb519a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/20100512-1.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fstack-protector" } */
+/* { dg-require-effective-target fstack_protector } */
+/* There should be 2 references to __stack_chk_guard in every function.  */
+/* { dg-final { scan-assembler-times "__stack_chk_guard" 4 } } */
+
+#include <stdlib.h>
+#include <string.h>
+void doTest1(void) {
+  volatile char foo[10];
+  memset((void *)foo, 1, 100);
+}
+void doTest2(void) {
+  volatile char foo[10];
+  memset((void *)foo, 1, 100);
+}
diff --git a/gcc/testsuite/gcc.target/m68k/pr36134.c b/gcc/testsuite/gcc.target/m68k/pr36134.c
index d8d65c16c..c91956b5c 100644
--- a/gcc/testsuite/gcc.target/m68k/pr36134.c
+++ b/gcc/testsuite/gcc.target/m68k/pr36134.c
@@ -1,10 +1,15 @@
 /* pr36134.c
 
    This test ensures that the shorter LEA instruction is used in preference
-   to the longer ADD instruction.  */
+   to the longer ADD instruction.
+
+   This preference is applicable to ColdFire only.  On CPU32, we can
+   use a sequence of two ADDQ instructions, which is faster than the
+   LEA instruction.  */
 
 /* { dg-do compile }  */
-/* { dg-options "-O2" }  */
+/* { dg-skip-if "" { *-*-* } { "-mcpu=*" } { "-mcpu=5208" } } */
+/* { dg-options "-O2 -mcpu=5208" }  */
 /* { dg-final { scan-assembler "lea" } } */
 /* { dg-final { scan-assembler-not "add" } } */
 
diff --git a/gcc/testsuite/gcc.target/m68k/pr41302.c b/gcc/testsuite/gcc.target/m68k/pr41302.c
new file mode 100644
index 000000000..c3679923e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/pr41302.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "move.l \%d0,\%a0" { target *-*-*linux* } } } */
+
+struct pts {
+  int c;
+};
+
+unsigned int bar (struct pts *a, int b);
+
+struct pts * foo (struct pts *a, int b)
+{
+  return (struct pts *) bar (a, b);
+}
diff --git a/gcc/testsuite/gcc.target/m68k/tls-gd-xgot.c b/gcc/testsuite/gcc.target/m68k/tls-gd-xgot.c
new file mode 100644
index 000000000..2a4900b5a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/tls-gd-xgot.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic -mxgot" } */
+/* { dg-final { scan-assembler "#foo@TLSGD,\%\[ad\]\[0-7\]" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+
+extern int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff --git a/gcc/testsuite/gcc.target/m68k/tls-gd.c b/gcc/testsuite/gcc.target/m68k/tls-gd.c
new file mode 100644
index 000000000..2b69fbdc1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/tls-gd.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic" } */
+/* { dg-final { scan-assembler "foo@TLSGD\\(\%a5\\)" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+
+extern int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff --git a/gcc/testsuite/gcc.target/m68k/tls-ie-xgot.c b/gcc/testsuite/gcc.target/m68k/tls-ie-xgot.c
new file mode 100644
index 000000000..d3fbfdaa4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/tls-ie-xgot.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -mxgot" } */
+/* { dg-final { scan-assembler "jsr __m68k_read_tp" } } */
+/* { dg-final { scan-assembler "#foo@TLSIE,\%\[ad\]\[0-7\]" } } */
+
+extern int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff --git a/gcc/testsuite/gcc.target/m68k/tls-ie.c b/gcc/testsuite/gcc.target/m68k/tls-ie.c
new file mode 100644
index 000000000..2661f9fc0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/tls-ie.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "jsr __m68k_read_tp" } } */
+/* { dg-final { scan-assembler "foo@TLSIE\\(\%a5\\)" } } */
+
+extern int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff --git a/gcc/testsuite/gcc.target/m68k/tls-ld-xgot-xtls.c b/gcc/testsuite/gcc.target/m68k/tls-ld-xgot-xtls.c
new file mode 100644
index 000000000..4817de01d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/tls-ld-xgot-xtls.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic -mxgot -mxtls" } */
+/* { dg-final { scan-assembler "#foo@TLSLDM,\%\[ad\]\[0-7\]" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+/* { dg-final { scan-assembler "#foo@TLSLDO,\%\[ad\]\[0-7\]" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff --git a/gcc/testsuite/gcc.target/m68k/tls-ld-xgot.c b/gcc/testsuite/gcc.target/m68k/tls-ld-xgot.c
new file mode 100644
index 000000000..f95f71928
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/tls-ld-xgot.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic -mxgot" } */
+/* { dg-final { scan-assembler "#foo@TLSLDM,\%\[ad\]\[0-7\]" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+/* { dg-final { scan-assembler "lea \\(foo@TLSLDO,\%a0\\)" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff --git a/gcc/testsuite/gcc.target/m68k/tls-ld-xtls.c b/gcc/testsuite/gcc.target/m68k/tls-ld-xtls.c
new file mode 100644
index 000000000..1bc3eaf7d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/tls-ld-xtls.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic -mxtls" } */
+/* { dg-final { scan-assembler "foo@TLSLDM\\(\%a5\\)" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+/* { dg-final { scan-assembler "#foo@TLSLDO,\%\[ad\]\[0-7\]" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff --git a/gcc/testsuite/gcc.target/m68k/tls-ld.c b/gcc/testsuite/gcc.target/m68k/tls-ld.c
new file mode 100644
index 000000000..556a11718
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/tls-ld.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -fpic" } */
+/* { dg-final { scan-assembler "foo@TLSLDM\\(\%a5\\)" } } */
+/* { dg-final { scan-assembler "bsr.l __tls_get_addr@PLTPC" } } */
+/* { dg-final { scan-assembler "lea \\(foo@TLSLDO,\%a0\\)" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff --git a/gcc/testsuite/gcc.target/m68k/tls-le-xtls.c b/gcc/testsuite/gcc.target/m68k/tls-le-xtls.c
new file mode 100644
index 000000000..90061153f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/tls-le-xtls.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2 -mxtls" } */
+/* { dg-final { scan-assembler "jsr __m68k_read_tp" } } */
+/* { dg-final { scan-assembler "#foo@TLSLE,\%\[ad\]\[0-7\]" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff --git a/gcc/testsuite/gcc.target/m68k/tls-le.c b/gcc/testsuite/gcc.target/m68k/tls-le.c
new file mode 100644
index 000000000..1c0eab238
--- /dev/null
+++ b/gcc/testsuite/gcc.target/m68k/tls-le.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { ! *-linux-* } { "*" } { "" } } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "jsr __m68k_read_tp" } } */
+/* { dg-final { scan-assembler "lea \\(foo@TLSLE,\%a0\\)" } } */
+
+static int __thread foo;
+
+int *
+bar (void)
+{
+  return &foo;
+}
diff --git a/gcc/testsuite/gcc.target/mips/branch-2.c b/gcc/testsuite/gcc.target/mips/branch-2.c
new file mode 100644
index 000000000..7acad43ee
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/branch-2.c
@@ -0,0 +1,44 @@
+/* Check that we correctly expand out-of-range branches */
+/* { dg-do run } */
+/* { dg-options "-O2 -mabi=32 -fPIC" } */
+
+#include <stdlib.h>
+
+/* This is weak so the compiler cannot assume that calls from this TU
+   necessarily arrive here.   And hence that $gp may be clobbered in
+   o32 and o64 ABIs.  */
+
+void __attribute__ ((weak)) Foo (int i)
+{
+  static int once = 0;
+
+  if (!i && once++)
+    exit (0);
+
+#if (_ABIO32 || _ABIO64)
+  /* Clobber $gp */
+  __asm volatile ("li $gp,0");
+#endif
+}
+
+#define N1(X)  (Foo (X))
+#define N2(X)  (N1 (X), N1 (X+(1<<0)))
+#define N3(X)  (N2 (X), N2 (X+(1<<1)))
+#define N4(X)  (N3 (X), N3 (X+(1<<2)))
+#define N5(X)  (N4 (X), N4 (X+(1<<3)))
+#define N6(X)  (N5 (X), N5 (X+(1<<4)))
+#define N7(X)  (N6 (X), N6 (X+(1<<5)))
+#define N8(X)  (N7 (X), N7 (X+(1<<6)))
+#define N9(X)  (N8 (X), N8 (X+(1<<7)))
+#define N10(X)  (N9 (X), N9 (X+(1<<8)))
+#define N11(X)  (N10 (X), N10 (X+(1<<9)))
+#define N12(X)  (N11 (X), N11 (X+(1<<10)))
+#define N13(X)  (N12 (X), N12 (X+(1<<11)))
+#define N14(X)  (N13 (X), N13 (X+(1<<12)))
+
+int main (void)
+{
+  while (1)
+    N14 (0);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/mips/clear-cache-2.c b/gcc/testsuite/gcc.target/mips/clear-cache-2.c
index 2c925b860..25c18ece1 100644
--- a/gcc/testsuite/gcc.target/mips/clear-cache-2.c
+++ b/gcc/testsuite/gcc.target/mips/clear-cache-2.c
@@ -2,7 +2,8 @@
 /* { dg-options "-O2 -mips32" } */
 /* { dg-final { scan-assembler-not "synci" } } */
 /* { dg-final { scan-assembler-not "jr.hb" } } */
-/* { dg-final { scan-assembler "_flush_cache" } } */
+/* { dg-final { scan-assembler "mips_sync_icache" { target { *-sde-* } } } } */
+/* { dg-final { scan-assembler "_flush_cache" { target { ! *-sde-* } } } } */
 
 void f()
 {
diff --git a/gcc/testsuite/gcc.target/mips/fpr-moves-5.c b/gcc/testsuite/gcc.target/mips/fpr-moves-5.c
index 848e5ea25..8f685750f 100644
--- a/gcc/testsuite/gcc.target/mips/fpr-moves-5.c
+++ b/gcc/testsuite/gcc.target/mips/fpr-moves-5.c
@@ -1,4 +1,5 @@
 /* { dg-options "-mabi=64 -mhard-float -O2 -EL" } */
+/* { dg-require-effective-target mips_newabi_large_long_double } */
 
 NOMIPS16 void
 foo (long double d, long double *x)
diff --git a/gcc/testsuite/gcc.target/mips/fpr-moves-6.c b/gcc/testsuite/gcc.target/mips/fpr-moves-6.c
index 7f2611397..f89a40a3b 100644
--- a/gcc/testsuite/gcc.target/mips/fpr-moves-6.c
+++ b/gcc/testsuite/gcc.target/mips/fpr-moves-6.c
@@ -1,4 +1,5 @@
 /* { dg-options "-mabi=64 -mhard-float -O2 -EB" } */
+/* { dg-require-effective-target mips_newabi_large_long_double } */
 
 NOMIPS16 void
 foo (long double d, long double *x)
diff --git a/gcc/testsuite/gcc.target/mips/mips.exp b/gcc/testsuite/gcc.target/mips/mips.exp
index 7befff5a1..1d63e9d0a 100644
--- a/gcc/testsuite/gcc.target/mips/mips.exp
+++ b/gcc/testsuite/gcc.target/mips/mips.exp
@@ -229,6 +229,7 @@ foreach option {
     gpopt
     local-sdata
     long-calls
+    octeon-useun
     paired-single
     plt
     shared
diff --git a/gcc/testsuite/gcc.target/mips/near-far-1.c b/gcc/testsuite/gcc.target/mips/near-far-1.c
index ac0cc1ef7..141139313 100644
--- a/gcc/testsuite/gcc.target/mips/near-far-1.c
+++ b/gcc/testsuite/gcc.target/mips/near-far-1.c
@@ -16,5 +16,5 @@ int test ()
 
 /* { dg-final { scan-assembler-not "\tjal\tlong_call_func\n" } } */
 /* { dg-final { scan-assembler-not "\tjal\tfar_func\n" } } */
-/* { dg-final { scan-assembler     "\tjal\tnear_func\n" } } */
+/* { dg-final { scan-assembler     "\tjals?\tnear_func\n" } } */
 /* { dg-final { scan-assembler-not "\tjal\tnormal_func\n" } } */
diff --git a/gcc/testsuite/gcc.target/mips/near-far-2.c b/gcc/testsuite/gcc.target/mips/near-far-2.c
index c954b444c..b8c0ed1c3 100644
--- a/gcc/testsuite/gcc.target/mips/near-far-2.c
+++ b/gcc/testsuite/gcc.target/mips/near-far-2.c
@@ -16,5 +16,5 @@ int test ()
 
 /* { dg-final { scan-assembler-not "\tjal\tlong_call_func\n" } } */
 /* { dg-final { scan-assembler-not "\tjal\tfar_func\n" } } */
-/* { dg-final { scan-assembler     "\tjal\tnear_func\n" } } */
-/* { dg-final { scan-assembler     "\tjal\tnormal_func\n" } } */
+/* { dg-final { scan-assembler     "\tjals?\tnear_func\n" } } */
+/* { dg-final { scan-assembler     "\tjals?\tnormal_func\n" } } */
diff --git a/gcc/testsuite/gcc.target/mips/octeon-useun.c b/gcc/testsuite/gcc.target/mips/octeon-useun.c
new file mode 100644
index 000000000..2584a60cc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/octeon-useun.c
@@ -0,0 +1,16 @@
+/* Check the mov_u[ls][dw] patterns.  */
+/* { dg-options "-march=octeon -O2 -mabi=64 -mocteon-useun -meb" } */
+struct __attribute__((packed)) sl { unsigned long x; };
+struct __attribute__((packed)) si { unsigned int x; };
+unsigned long f1 (struct sl *s) { return s[0].x; };
+unsigned int f2 (struct si *s) { return s[1].x; };
+void f3 (struct sl *s, unsigned long x) { s[10].x = x; }
+void f4 (struct si *s, unsigned int x) { s[11].x = x; }
+void f5 (struct sl *s) { s[100].x = 0; }
+void f6 (struct si *s) { s[101].x = 0; }
+/* { dg-final { scan-assembler "\tjr?\t\\\$31\n\tuld\t\\\$2,0\\(\\\$4\\)\n" } } */
+/* { dg-final { scan-assembler "\tulw\t\\\$2,4\\(\\\$4\\)\n" } } */
+/* { dg-final { scan-assembler "\tjr?\t\\\$31\n\tusd\t\\\$5,80\\(\\\$4\\)\n" } } */
+/* { dg-final { scan-assembler "\tjr?\t\\\$31\n\tusw\t\\\$5,44\\(\\\$4\\)\n" } } */
+/* { dg-final { scan-assembler "\tjr?\t\\\$31\n\tusd\t\\\$0,800\\(\\\$4\\)\n" } } */
+/* { dg-final { scan-assembler "\tjr?\t\\\$31\n\tusw\t\\\$0,404\\(\\\$4\\)\n" } } */
diff --git a/gcc/testsuite/gcc.target/sh/20080410-1.c b/gcc/testsuite/gcc.target/sh/20080410-1.c
index ebd783dd0..0ba7792c0 100644
--- a/gcc/testsuite/gcc.target/sh/20080410-1.c
+++ b/gcc/testsuite/gcc.target/sh/20080410-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target "sh-*-*" } } */
-/* { dg-options "-O0 -m4 -ml -fira" } */
+/* { dg-options "-O0 -m4 -ml" } */
 /* { dg-final { scan-assembler-not "add\tr0,r0" } } */
 
 /* This test checks that chain reloads conflict.  I they don't
diff --git a/gcc/testsuite/gcc.target/sh/mfmovd.c b/gcc/testsuite/gcc.target/sh/mfmovd.c
new file mode 100644
index 000000000..c8e0094f0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sh/mfmovd.c
@@ -0,0 +1,13 @@
+/* { dg-do compile { target "sh*-*-*" } } */
+/* { dg-options "-mfmovd" } */
+/* { dg-skip-if "No double precision FPU support" { "sh*-*-*" } "-m2a-nofpu -m2a-single-only -m4-nofpu -m4-single-only -m4a-nofpu -m4a-single-only" { "" } }  */
+/* { dg-final { scan-assembler "fmov.d"} }  */
+
+extern double g;
+
+void
+f (double d)
+{
+  g = d;
+}
+
diff --git a/gcc/testsuite/gcc.target/sh/sh-relax.c b/gcc/testsuite/gcc.target/sh/sh-relax.c
index 54422de46..f9b2da203 100644
--- a/gcc/testsuite/gcc.target/sh/sh-relax.c
+++ b/gcc/testsuite/gcc.target/sh/sh-relax.c
@@ -1,6 +1,7 @@
 /* Check that -mrelax works.  */
 /* { dg-do run { target { { sh-*-* sh?-*-* } && { ! { sh*-*-vxworks* && nonpic } } } } } */
 /* { dg-options "-O1 -mrelax" } */
+/* { dg-xfail-if "" { "sh*-*-uclinux" } { "*" } { "" } } */
 
 extern void abort (void);
 extern int qwerty (int);
diff --git a/gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c b/gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c
index b7081bf71..761c7b0b5 100644
--- a/gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c
+++ b/gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c
@@ -35,15 +35,15 @@ long long f4() {
 }
 
 /* Aligned.  */
-struct u0 { unsigned long long d : 32; } y0;
+struct u0 { unsigned long long d : 32; } y_0;
 unsigned long long g0() {
-  return y0.d;
+  return y_0.d;
 }
 
 /* Unaligned load.  */
-struct u1 { long long c : 8; unsigned long long d : 32; } y1;
+struct u1 { long long c : 8; unsigned long long d : 32; } y_1;
 unsigned long long g1() {
-  return y1.d;
+  return y_1.d;
 }
 
 /* Unaligned load.  */
diff --git a/gcc/testsuite/gcc.target/sh/sh4a-memmovua.c b/gcc/testsuite/gcc.target/sh/sh4a-memmovua.c
index 689279298..ec5c0bdab 100644
--- a/gcc/testsuite/gcc.target/sh/sh4a-memmovua.c
+++ b/gcc/testsuite/gcc.target/sh/sh4a-memmovua.c
@@ -5,7 +5,7 @@
 /* { dg-final { scan-assembler-times "\tmovua\\.l\t(.*)+" 2 } } */
 
 #ifdef __SH4A__
-#include <stdlib.h>
+#include <string.h>
 
 struct s { int i; char a[10], b[10]; } x;
 int f() {
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2a.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2a.c
new file mode 100644
index 000000000..048da6e56
--- /dev/null
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2a.c
@@ -0,0 +1,27 @@
+/* Test for cross x86_64<->w64 abi standard calls.  */
+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* } } */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -ffast-math -fno-builtin" } */
+/* { dg-additional-sources "func-2b.c" } */
+
+extern void __attribute__ ((sysv_abi)) abort (void);
+long double func_cross (long double, double, float, long, int, char);
+
+long double __attribute__ ((sysv_abi))
+func_native (long double a, double b, float c, long d, int e, char f)
+{
+  long double ret;
+  ret = a + (long double) b + (long double) c;
+  ret *= (long double) (d + (long) e);
+  if (f>0)
+    ret += func_native (a,b,c,d,e,-f);
+  return ret;
+}
+
+int __attribute__ ((sysv_abi))
+main ()
+{
+  if (func_cross (1.0,2.0,3.0,1,2,3)
+      != func_native (1.0,2.0,3.0,1,2,3))
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2b.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2b.c
new file mode 100644
index 000000000..fe85dd186
--- /dev/null
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-2b.c
@@ -0,0 +1,13 @@
+/* Test for cross x86_64<->w64 abi standard calls.  */
+/* { dg-options "-mabi=ms -std=gnu99 -ffast-math -fno-builtin" } */
+
+long double func_cross (long double a, double b, float c, long d, int e,
+			char f)
+{
+  long double ret;
+  ret = a + (long double) b + (long double) c;
+  ret *= (long double) (d + (long) e);
+  if (f>0)
+    ret += func_cross (a,b,c,d,e,-f);
+  return ret;
+}
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2a.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2a.c
new file mode 100644
index 000000000..730b8db9c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2a.c
@@ -0,0 +1,17 @@
+/* Test for cross x86_64<->w64 abi standard calls via variable.  */
+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* } } */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -ffast-math -fno-builtin" } */
+/* { dg-additional-sources "func-indirect-2b.c" } */
+
+extern void __attribute__ ((sysv_abi)) abort (void);
+typedef int (*func)(void *, char *, char *, short, long long);
+extern func get_callback (void);
+
+int __attribute__ ((sysv_abi))
+main ()
+{
+  func callme = get_callback ();
+  if (callme (0, 0, 0, 0x1234, 0x1234567890abcdefLL))
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2b.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2b.c
new file mode 100644
index 000000000..1a9fccd97
--- /dev/null
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/func-indirect-2b.c
@@ -0,0 +1,24 @@
+/* Test for cross x86_64<->w64 abi standard calls via variable.  */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -ffast-math -fno-builtin" } */
+
+typedef int (*func)(void *, char *, char *, short, long long);
+
+static int
+callback (void *ptr, char *string1, char *string2, short number,
+	  long long rand)
+{
+  if (ptr != 0
+      || string1 != 0
+      || string2 != 0
+      || number != 0x1234
+      || rand != 0x1234567890abcdefLL)
+    return 1;
+  else
+    return 0;
+}
+
+func
+get_callback (void)
+{
+  return callback;
+}
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4a.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4a.c
new file mode 100644
index 000000000..a44470431
--- /dev/null
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4a.c
@@ -0,0 +1,24 @@
+/* Test for cross x86_64<->w64 abi va_list calls.  */
+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* } } */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -fno-builtin" } */
+/* { dg-additional-sources "vaarg-4b.c" } */
+
+extern __SIZE_TYPE__ __attribute__ ((sysv_abi)) strlen (const char *);
+extern int __attribute__ ((sysv_abi)) sprintf (char *,const char *, ...);
+extern void __attribute__ ((sysv_abi)) abort (void);
+
+extern void do_cpy (char *, ...);
+
+int __attribute__ ((sysv_abi))
+main ()
+{
+  char s[256];
+
+  do_cpy (s, "1","2","3","4", "5", "6", "7", "");
+
+  if (s[0] != '1' || s[1] !='2' || s[2] != '3' || s[3] != '4'
+      || s[4] != '5' || s[5] != '6' || s[6] != '7' || s[7] != 0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4b.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4b.c
new file mode 100644
index 000000000..f33906bd2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-4b.c
@@ -0,0 +1,31 @@
+/* Test for cross x86_64<->w64 abi va_list calls.  */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -fno-builtin" } */
+
+#include <stdarg.h>
+
+extern __SIZE_TYPE__ __attribute__ ((sysv_abi)) strlen (const char *);
+extern int __attribute__ ((sysv_abi)) sprintf (char *, const char *, ...);
+
+static void
+vdo_cpy (char *s, va_list argp)
+{
+  __SIZE_TYPE__ len;
+  char *r = s;
+  char *e;
+  *r = 0;
+  for (;;) {
+    e = va_arg (argp, char *);
+    if (*e == 0) break;
+    sprintf (r,"%s", e);
+    r += strlen (r);
+  }
+}
+
+void
+do_cpy (char *s, ...)
+{
+  va_list argp;
+  va_start (argp, s);
+  vdo_cpy (s, argp);
+  va_end (argp);
+}
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5a.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5a.c
new file mode 100644
index 000000000..e9912957e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5a.c
@@ -0,0 +1,17 @@
+/* Test for cross x86_64<->w64 abi va_list calls.  */
+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* } } */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -fno-builtin" } */
+/* { dg-additional-sources "vaarg-5b.c" } */
+
+extern void __attribute__ ((sysv_abi)) abort (void);
+extern int fct2 (int, ...);
+
+#define SZ_ARGS	1ll,2ll,3ll,4ll,5ll,6ll,7ll,0ll
+
+int __attribute__ ((sysv_abi))
+main()
+{
+  if (fct2 (-1, SZ_ARGS) != 0)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5b.c b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5b.c
new file mode 100644
index 000000000..e5dd4727b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/x86_64/abi/callabi/vaarg-5b.c
@@ -0,0 +1,37 @@
+/* Test for cross x86_64<->w64 abi va_list calls.  */
+/* { dg-options "-O2 -mabi=ms -std=gnu99 -fno-builtin" } */
+
+#include <stdarg.h>
+
+#define SZ_ARGS	1ll,2ll,3ll,4ll,5ll,6ll,7ll,0ll
+
+static int __attribute__ ((sysv_abi))
+fct1 (va_list argp, ...)
+{
+  long long p1,p2;
+  int ret = 1;
+  __builtin_sysv_va_list argp_2;
+
+  __builtin_sysv_va_start (argp_2, argp);
+  do {
+    p1 = va_arg (argp_2, long long);
+    p2 = va_arg (argp, long long);
+    if (p1 != p2)
+      ret = 0;
+  } while (ret && p1 != 0);
+  __builtin_sysv_va_end (argp_2);
+
+  return ret;
+}
+
+int
+fct2 (int dummy, ...)
+{
+  va_list argp;
+  int ret = dummy;
+
+  va_start (argp, dummy);
+  ret += fct1 (argp, SZ_ARGS);
+  va_end (argp);
+  return ret;
+}
diff --git a/gcc/testsuite/gfortran.dg/vect/vect.exp b/gcc/testsuite/gfortran.dg/vect/vect.exp
index 650273bd3..be622630c 100644
--- a/gcc/testsuite/gfortran.dg/vect/vect.exp
+++ b/gcc/testsuite/gfortran.dg/vect/vect.exp
@@ -101,7 +101,7 @@ if  [istarget "powerpc-*paired*"]  {
 } elseif [istarget "ia64-*-*"] {
     set dg-do-what-default run
 } elseif [is-effective-target arm_neon_ok] {
-    lappend DEFAULT_VECTCFLAGS "-mfpu=neon" "-mfloat-abi=softfp"
+    eval lappend DEFAULT_VECTCFLAGS [add_options_for_arm_neon ""]
     if [is-effective-target arm_neon_hw] {
       set dg-do-what-default run
     } else {
diff --git a/gcc/testsuite/lib/prune.exp b/gcc/testsuite/lib/prune.exp
index 72b27f4ce..fe02f31c2 100644
--- a/gcc/testsuite/lib/prune.exp
+++ b/gcc/testsuite/lib/prune.exp
@@ -60,3 +60,34 @@ if { [info procs prune_warnings] == "" } then {
 	return $text
     }
 }
+
+# Extend prune_warnings (provided by DejaGNU itself) to prune more
+# things.  The prune_gcc_output function above is called only by some
+# tests; prune_warnings is used by all.
+if { [info procs prune_warnings_orig] == "" } {
+    rename prune_warnings prune_warnings_orig
+    
+    proc prune_warnings { text } {
+	set text [prune_warnings_orig $text]
+	
+	if { [ishost "sparc*-*-solaris2*"] } {
+	    # When testing a compiler built for SPARC Solaris 2.9 (or earlier)
+	    # on a host running Solaris 2.10 (or later), we get this warning 
+	    # from the static linker when building with g++:
+	    #
+	    #   libm.so.1, needed by .../libstdc++.so may conflict with
+	    #   libm.so
+	    #
+	    # The warning is issued because libstdc++ is linked against
+	    # libm.so.1 (from the Solaris 2.9 sysroot), whereas Solaris 2.10
+	    # provides both libm.so.2 and libm.so.1.  On Solaris 2.10, libc.so
+	    # depends on libm.so.2, so all programs pull in libm.so.2.
+	    #
+	    # Pulling both libraries must in fact be harmless, as, otherwise,
+	    # programs built for Solaris 2.9 would break on Solaris 2.10.
+	    regsub -all "(^|\n)\[^\n\]*: warning: libm.so.1, needed by \[^\n\]*, may conflict with libm.so.2" $text "" text
+	}
+
+	return $text
+    }
+}
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index f628af177..e28aca443 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -611,6 +611,18 @@ proc check_effective_target_pthread {} {
     } "-pthread"]
 }
 
+# Return 1 if compilation with -mpe-aligned-commons is error-free
+# for trivial code, 0 otherwise.
+
+proc check_effective_target_pe_aligned_commons {} {
+    if { [istarget *-*-cygwin*] || [istarget *-*-mingw*] } {
+	return [check_no_compiler_messages pe_aligned_commons object {
+	    int foo;
+	} "-mpe-aligned-commons"]
+    }
+    return 0
+}
+
 # Return 1 if the target supports -static
 proc check_effective_target_static {} {
     return [check_no_compiler_messages static executable {
@@ -727,6 +739,15 @@ proc check_effective_target_mips16_attribute { } {
     } [add_options_for_mips16_attribute ""]]
 }
 
+# Return 1 if the target supports long double larger than double when
+# using the new ABI, 0 otherwise.
+
+proc check_effective_target_mips_newabi_large_long_double { } {
+    return [check_no_compiler_messages mips_newabi_large_long_double object {
+	int dummy[sizeof(long double) > sizeof(double) ? 1 : -1];
+    } "-mabi=64"]
+}
+
 # Return 1 if the current multilib does not generate PIC by default.
 
 proc check_effective_target_nonpic { } {
@@ -1567,6 +1588,18 @@ proc check_effective_target_arm32 { } {
     }]
 }
 
+# Return 1 if this is an ARM target that only supports aligned vector accesses
+proc check_effective_target_arm_vect_no_misalign { } {
+    return [check_no_compiler_messages arm_vect_no_misalign assembly {
+	#if !defined(__arm__) \
+	    || (defined(__ARMEL__) \
+	        && (!defined(__thumb__) || defined(__thumb2__)))
+	#error FOO
+	#endif
+    }]
+}
+
+
 # Return 1 if this is an ARM target supporting -mfpu=vfp
 # -mfloat-abi=softfp.  Some multilibs may be incompatible with these
 # options.
@@ -1581,20 +1614,112 @@ proc check_effective_target_arm_vfp_ok { } {
     }
 }
 
-# Return 1 if this is an ARM target supporting -mfpu=neon
-# -mfloat-abi=softfp.  Some multilibs may be incompatible with these
+# Return 1 if this is an ARM target supporting -mfpu=vfp
+# -mfloat-abi=hard.  Some multilibs may be incompatible with these
 # options.
 
-proc check_effective_target_arm_neon_ok { } {
+proc check_effective_target_arm_hard_vfp_ok { } {
     if { [check_effective_target_arm32] } {
-        return [check_no_compiler_messages arm_neon_ok object {
-            int dummy;
-        } "-mfpu=neon -mfloat-abi=softfp"]
+	return [check_no_compiler_messages arm_hard_vfp_ok executable {
+	    int main() { return 0;}
+	} "-mfpu=vfp -mfloat-abi=hard"]
     } else {
-        return 0
+	return 0
     }
 }
 
+# Add the options needed for NEON.  We need either -mfloat-abi=softfp
+# or -mfloat-abi=hard, but if one is already specified by the
+# multilib, use it.  Similarly, if a -mfpu option already enables
+# NEON, do not add -mfpu=neon.
+
+proc add_options_for_arm_neon { flags } {
+    if { ! [check_effective_target_arm_neon_ok] } {
+	return "$flags"
+    }
+    global et_arm_neon_flags
+    return "$flags $et_arm_neon_flags"
+}
+
+# Return 1 if this is an ARM target supporting -mfpu=neon
+# -mfloat-abi=softfp or equivalent options.  Some multilibs may be
+# incompatible with these options.  Also set et_arm_neon_flags to the
+# best options to add.
+
+proc check_effective_target_arm_neon_ok_nocache { } {
+    global et_arm_neon_flags
+    set et_arm_neon_flags ""
+    if { [check_effective_target_arm32] } {
+	foreach flags {"" "-mfloat-abi=softfp" "-mfpu=neon" "-mfpu=neon -mfloat-abi=softfp"} {
+	    if { [check_no_compiler_messages_nocache arm_neon_ok object {
+		#include "arm_neon.h"
+		int dummy;
+	    } "$flags"] } {
+		set et_arm_neon_flags $flags
+		return 1
+	    }
+	}
+    }
+
+    return 0
+}
+
+proc check_effective_target_arm_neon_ok { } {
+    return [check_cached_effective_target arm_neon_ok \
+		check_effective_target_arm_neon_ok_nocache]
+}
+
+# Add the options needed for NEON.  We need either -mfloat-abi=softfp
+# or -mfloat-abi=hard, but if one is already specified by the
+# multilib, use it.
+
+proc add_options_for_arm_neon_fp16 { flags } {
+    if { ! [check_effective_target_arm_neon_fp16_ok] } {
+	return "$flags"
+    }
+    global et_arm_neon_fp16_flags
+    return "$flags $et_arm_neon_fp16_flags"
+}
+
+# Return 1 if this is an ARM target supporting -mfpu=neon-fp16
+# -mfloat-abi=softfp or equivalent options.  Some multilibs may be
+# incompatible with these options.  Also set et_arm_neon_flags to the
+# best options to add.
+
+proc check_effective_target_arm_neon_fp16_ok_nocache { } {
+    global et_arm_neon_fp16_flags
+    set et_arm_neon_fp16_flags ""
+    if { [check_effective_target_arm32] } {
+	# Always add -mfpu=neon-fp16, since there is no preprocessor
+	# macro for FP16 support.
+	foreach flags {"-mfpu=neon-fp16" "-mfpu=neon-fp16 -mfloat-abi=softfp"} {
+	    if { [check_no_compiler_messages_nocache arm_neon_fp16_ok object {
+		#include "arm_neon.h"
+		int dummy;
+	    } "$flags"] } {
+		set et_arm_neon_fp16_flags $flags
+		return 1
+	    }
+	}
+    }
+
+    return 0
+}
+
+proc check_effective_target_arm_neon_fp16_ok { } {
+    return [check_cached_effective_target arm_neon_fp16_ok \
+		check_effective_target_arm_neon_fp16_ok_nocache]
+}
+
+# Return 1 if this is an arm target using 32-bit instructions, but not thumb
+proc check_effective_target_arm_not_thumb { } {
+    return [check_no_compiler_messages arm_not_thumb assembly {
+      #if !defined(__arm__) || defined(__thumb__)
+      #error FOO
+      #endif
+    }]
+}
+
 # Return 1 is this is an ARM target where -mthumb causes Thumb-1 to be
 # used.
 
@@ -1606,6 +1731,17 @@ proc check_effective_target_arm_thumb1_ok { } {
     } "-mthumb"]
 }
 
+# Return 1 is this is an ARM target where -mthumb causes Thumb-2 to be
+# used.
+
+proc check_effective_target_arm_thumb2_ok { } {
+    return [check_no_compiler_messages arm_thumb2_ok assembly {
+	#if !defined(__thumb2__)
+	#error FOO
+	#endif
+    } "-mthumb"]
+}
+
 # Return 1 if the target supports executing NEON instructions, 0
 # otherwise.  Cache the result.
 
@@ -1620,7 +1756,7 @@ proc check_effective_target_arm_neon_hw { } {
 	       : "0" (a), "w" (b));
 	  return (a != 1);
 	}
-    } "-mfpu=neon -mfloat-abi=softfp"]
+    } [add_options_for_arm_neon ""]]
 }
 
 # Return 1 if this is a ARM target with NEON enabled.
@@ -1663,6 +1799,19 @@ proc check_effective_target_arm_eabi { } {
     }]
 }
 
+# Return 1 if this is an ARM target supporting -mcpu=iwmmxt.
+# Some multilibs may be incompatible with this option.
+
+proc check_effective_target_arm_iwmmxt_ok { } {
+    if { [check_effective_target_arm32] } {
+	return [check_no_compiler_messages arm_iwmmxt_ok object {
+	    int dummy;
+	} "-mcpu=iwmmxt"]
+    } else {
+	return 0
+    }
+}
+
 # Return 1 if this is a PowerPC target with floating-point registers.
 
 proc check_effective_target_powerpc_fprs { } {
@@ -1859,6 +2008,26 @@ proc check_effective_target_vect_shift { } {
     return $et_vect_shift_saved
 }
 
+# Return 1 if the target supports hardware vector shift operation for char.
+
+proc check_effective_target_vect_shift_char { } {
+    global et_vect_shift_char_saved
+
+    if [info exists et_vect_shift_char_saved] {
+	verbose "check_effective_target_vect_shift_char: using cached result" 2
+    } else {
+	set et_vect_shift_char_saved 0
+	if { ([istarget powerpc*-*-*]
+             && ![istarget powerpc-*-linux*paired*])
+	     || [check_effective_target_arm32] } {
+	   set et_vect_shift_char_saved 1
+	}
+    }
+
+    verbose "check_effective_target_vect_shift_char: returning $et_vect_shift_char_saved" 2
+    return $et_vect_shift_char_saved
+}
+
 # Return 1 if the target supports hardware vectors of long, 0 otherwise.
 #
 # This can change for different subtargets so do not cache the result.
@@ -2318,7 +2487,7 @@ proc check_effective_target_vect_no_align { } {
 	if { [istarget mipsisa64*-*-*]
 	     || [istarget sparc*-*-*]
 	     || [istarget ia64-*-*]
-	     || [check_effective_target_arm32] } { 
+	     || [check_effective_target_arm_vect_no_misalign] } { 
 	    set et_vect_no_align_saved 1
 	}
     }
@@ -2432,6 +2601,24 @@ proc check_effective_target_vector_alignment_reachable_for_64bit { } {
     return $et_vector_alignment_reachable_for_64bit_saved
 }
 
+# Return 1 if the target only requires element alignment for vector accesses
+
+proc check_effective_target_vect_element_align { } {
+    global et_vect_element_align
+
+    if [info exists et_vect_element_align] {
+	verbose "check_effective_target_vect_elemetn_align: using cached result" 2
+    } else {
+	set et_vect_element_align 0
+	if { [istarget arm*-*-*] } {
+	   set et_vect_element_align 1
+	}
+    }
+
+    verbose "check_effective_target_vect_element_align: returning $et_vect_element_align" 2
+    return $et_vect_element_align
+}
+
 # Return 1 if the target supports vector conditional operations, 0 otherwise.
 
 proc check_effective_target_vect_condition { } {
@@ -2627,7 +2814,8 @@ proc check_effective_target_section_anchors { } {
         verbose "check_effective_target_section_anchors: using cached result" 2
     } else {
         set et_section_anchors_saved 0
-        if { [istarget powerpc*-*-*] } {
+        if { [istarget powerpc*-*-*] 
+	      || [istarget arm*-*-*] } {
            set et_section_anchors_saved 1
         }
     }
@@ -2651,7 +2839,7 @@ proc check_effective_target_sync_int_long { } {
 	     || [istarget i?86-*-*]
 	     || [istarget x86_64-*-*]
 	     || [istarget alpha*-*-*] 
-	     || [istarget arm*-*-linux-gnueabi] 
+	     || [istarget arm*-*-linux-*eabi*] 
 	     || [istarget s390*-*-*] 
 	     || [istarget powerpc*-*-*]
 	     || [istarget sparc64-*-*]
@@ -2680,7 +2868,7 @@ proc check_effective_target_sync_char_short { } {
 	     || [istarget i?86-*-*]
 	     || [istarget x86_64-*-*]
 	     || [istarget alpha*-*-*] 
-	     || [istarget arm*-*-linux-gnueabi] 
+	     || [istarget arm*-*-linux-*eabi*] 
 	     || [istarget s390*-*-*] 
 	     || [istarget powerpc*-*-*]
 	     || [istarget sparc64-*-*]
diff --git a/gcc/testsuite/objc/execute/forward-1.x b/gcc/testsuite/objc/execute/forward-1.x
index 0a9bde6ba..605d56a2a 100644
--- a/gcc/testsuite/objc/execute/forward-1.x
+++ b/gcc/testsuite/objc/execute/forward-1.x
@@ -4,6 +4,7 @@ load_lib target-supports.exp
 
 if { ([istarget x86_64-*-linux*] && [check_effective_target_lp64] )
      || [istarget powerpc*-*-linux*]
+     || [istarget arm*]
      || [istarget powerpc*-*-aix*]
      || [istarget s390*-*-*-linux*]
      || [istarget sh4-*-linux*]
diff --git a/gcc/timevar.def b/gcc/timevar.def
index c27ee1618..202e0b6b8 100644
--- a/gcc/timevar.def
+++ b/gcc/timevar.def
@@ -134,6 +134,7 @@ DEFTIMEVAR (TV_TREE_LOOP_IVOPTS	     , "tree iv optimization")
 DEFTIMEVAR (TV_PREDCOM		     , "predictive commoning")
 DEFTIMEVAR (TV_TREE_LOOP_INIT	     , "tree loop init")
 DEFTIMEVAR (TV_TREE_LOOP_FINI	     , "tree loop fini")
+DEFTIMEVAR (TV_TREE_LOOP_PROMOTE     , "tree loop index promotion")
 DEFTIMEVAR (TV_TREE_CH		     , "tree copy headers")
 DEFTIMEVAR (TV_TREE_SSA_UNCPROP	     , "tree SSA uncprop")
 DEFTIMEVAR (TV_TREE_SSA_TO_NORMAL    , "tree SSA to normal")
@@ -141,6 +142,7 @@ DEFTIMEVAR (TV_TREE_NRV		     , "tree NRV optimization")
 DEFTIMEVAR (TV_TREE_COPY_RENAME	     , "tree rename SSA copies")
 DEFTIMEVAR (TV_TREE_SSA_VERIFY       , "tree SSA verifier")
 DEFTIMEVAR (TV_TREE_STMT_VERIFY      , "tree STMT verifier")
+DEFTIMEVAR (TV_TREE_RLS              , "tree local static removal")
 DEFTIMEVAR (TV_TREE_SWITCH_CONVERSION, "tree switch initialization conversion")
 DEFTIMEVAR (TV_CGRAPH_VERIFY         , "callgraph verifier")
 DEFTIMEVAR (TV_DOM_FRONTIERS         , "dominance frontiers")
diff --git a/gcc/toplev.h b/gcc/toplev.h
index 15feb8db8..a541eb382 100644
--- a/gcc/toplev.h
+++ b/gcc/toplev.h
@@ -139,6 +139,7 @@ extern int flag_unroll_loops;
 extern int flag_unroll_all_loops;
 extern int flag_unswitch_loops;
 extern int flag_cprop_registers;
+extern int flag_remove_local_statics;
 extern int time_report;
 extern int flag_ira_coalesce;
 extern int flag_ira_move_spills;
diff --git a/gcc/tree-cfg.c b/gcc/tree-cfg.c
index d3597fae7..532b6ed17 100644
--- a/gcc/tree-cfg.c
+++ b/gcc/tree-cfg.c
@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "value-prof.h"
 #include "pointer-set.h"
 #include "tree-inline.h"
+#include "target.h"
 
 /* This file contains functions for building the Control Flow Graph (CFG)
    for a function tree.  */
@@ -7052,6 +7053,9 @@ execute_warn_function_return (void)
   edge e;
   edge_iterator ei;
 
+  if (!targetm.warn_func_result())
+    return 0;
+
   /* If we have a path to EXIT, then we do return.  */
   if (TREE_THIS_VOLATILE (cfun->decl)
       && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0)
diff --git a/gcc/tree-pass.h b/gcc/tree-pass.h
index db437a625..7f4e631ae 100644
--- a/gcc/tree-pass.h
+++ b/gcc/tree-pass.h
@@ -323,6 +323,7 @@ extern struct gimple_opt_pass pass_scev_cprop;
 extern struct gimple_opt_pass pass_empty_loop;
 extern struct gimple_opt_pass pass_record_bounds;
 extern struct gimple_opt_pass pass_graphite_transforms;
+extern struct gimple_opt_pass pass_promote_indices;
 extern struct gimple_opt_pass pass_if_conversion;
 extern struct gimple_opt_pass pass_loop_distribution;
 extern struct gimple_opt_pass pass_vectorize;
@@ -388,6 +389,7 @@ extern struct gimple_opt_pass pass_reassoc;
 extern struct gimple_opt_pass pass_rebuild_cgraph_edges;
 extern struct gimple_opt_pass pass_build_cgraph_edges;
 extern struct gimple_opt_pass pass_reset_cc_flags;
+extern struct gimple_opt_pass pass_remove_local_statics;
 
 /* IPA Passes */
 extern struct ipa_opt_pass pass_ipa_inline;
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index b0200cd1f..2fbdd17fe 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -274,6 +274,12 @@ sra_type_can_be_decomposed_p (tree type)
 		      != TYPE_PRECISION (TREE_TYPE (t))))
 		goto fail;
 
+	      /* Disable optimization of bitfields on BITS_BIG_ENDIAN
+		 architectures.  SRA doesn't properly handle padding bits
+		 at the bottom, see issue6713.  */
+	      if (DECL_BIT_FIELD (t) && BITS_BIG_ENDIAN)
+		goto fail;
+
 	      saw_one_field = true;
 	    }
 
diff --git a/gcc/tree-ssa-loop-promote.c b/gcc/tree-ssa-loop-promote.c
new file mode 100644
index 000000000..e745f20d7
--- /dev/null
+++ b/gcc/tree-ssa-loop-promote.c
@@ -0,0 +1,1692 @@
+/* Promotion of shorter-than-word-size loop indices.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   
+This file is part of GCC.
+   
+GCC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+   
+GCC is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+   
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* This pass finds loop indices that are declared as
+   shorter-than-word-size and replaces them with word-sized loop
+   indices.  (It assumes that word-sized quantities are the most
+   efficient type on which to do arithmetic.)  The loop optimization
+   machinery has a difficult time seeing through the casts required to
+   promote such indices to word-sized quantities for memory addressing
+   and/or preserving the semantics of the source language (such as C).
+   The transformation also helps eliminate unnecessary
+   {sign,zero}-extensions required for the same.
+
+   Although this is most naturally expressed as a loop optimization
+   pass, we choose to place this pass some ways before the loop
+   optimization passes proper, so that other scalar optimizations will
+   run on our "cleaned-up" code.  This decision has the negative of
+   requiring us to build and destroy all the loop optimization
+   infrastructure.
+
+   The algorithm is relatively simple.  For each single-exit loop, we
+   identify the loop index variable.  If the loop index variable is
+   shorter than the word size, then we have a candidate for promotion.
+   We determine whether the scalar evolution of the loop index fits a
+   particular pattern (incremented by 1, compared against a
+   similarly-typed loop bound, and only modified by a single increment
+   within the loop), as well as examining the uses of the loop index to
+   ensure we are able to safely promote those uses (e.g. the loop index
+   must not be stored to memory or passed to function calls).  If these
+   conditions are satisfied, we create an appropriate word-sized type
+   and replace all uses and defs of the loop index variable with the new
+   variable.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+
+#include "toplev.h"
+#include "rtl.h"
+#include "tm_p.h"
+#include "hard-reg-set.h"
+#include "obstack.h"
+#include "basic-block.h"
+#include "pointer-set.h"
+#include "intl.h"
+
+#include "tree.h"
+#include "gimple.h"
+#include "hashtab.h"
+#include "diagnostic.h"
+#include "tree-flow.h"
+#include "tree-dump.h"
+#include "cfgloop.h"
+#include "flags.h"
+#include "timevar.h"
+#include "tree-pass.h"
+
+struct promote_info {
+  /* The loop being analyzed.  */
+  struct loop *loop;
+
+  /* The GIMPLE_COND controlling exit from the loop.  */
+  gimple exit_expr;
+
+  /* The loop index variable's SSA_NAME that is defined in a phi node in
+     LOOP->HEADER.  Note that this SSA_NAME may be different than the
+     one appearing in EXIT_EXPR.  */
+  tree loop_index_name;
+
+  /* The bound of the loop.  */
+  tree loop_limit;
+
+  /* Whether we've warned about things with
+     warn_unsafe_loop_optimizations.  */
+  bool warned;
+
+  /* LOOP_INDEX_NAME's underlying VAR_DECL.  */
+  tree var_decl;
+
+  /* The types to which defs/uses of LOOP_INDEX_NAME are cast via
+     NOP_EXPRs.  */
+  VEC(tree, heap) *cast_types;
+
+  /* The number of times we have seen a cast to the corresponding type
+     (as determined by types_compatible_p) in CAST_TYPES.  */
+  VEC(int, heap) *cast_counts;
+
+  /* Whether LOOP_INDEX_NAME is suitable for promotion.  */
+  bool can_be_promoted_p;
+
+  /* If CAN_BE_PROMOTED_P, the promoted type.  */
+  tree promoted_type;
+
+  /* If CAN_BE_PROMOTED_P, the promoted VAR_DECL.  */
+  tree promoted_var;
+};
+
+/* A set of `struct promote_info'.  */
+
+static struct pointer_set_t *promotion_info;
+
+/* A set of all potentially promotable SSA_NAMEs, used for quick
+decision-making during analysis.  */
+
+static struct pointer_set_t *promotable_names;
+
+/* A map from SSA_NAMEs to the VAR_DECL to which they will be
+   promoted.  */
+
+static struct pointer_map_t *variable_map;
+
+/* A set of the stmts that we have already rebuilt with promoted variables.  */
+
+static struct pointer_set_t *promoted_stmts;
+
+/* Phi nodes that we have to fix up after we've promoted everything else.  */
+
+static struct pointer_set_t *phi_nodes_to_promote;
+
+
+/* Add CASTED to PI->CAST_TYPES if we haven't seen CASTED before.  */
+
+static void
+add_casted_type (struct promote_info *pi, tree casted)
+{
+  int i;
+  tree type;
+
+  /* For this information to be useful later, CASTED must be wider than
+     the type of the variable.  */
+  if (TYPE_PRECISION (casted) <= TYPE_PRECISION (TREE_TYPE (pi->var_decl)))
+    return;
+
+  for (i = 0; VEC_iterate (tree, pi->cast_types, i, type); i++)
+    if (types_compatible_p (casted, type))
+      {
+       int c = VEC_index(int, pi->cast_counts, i);
+       VEC_replace(int, pi->cast_counts, i, ++c);
+       return;
+      }
+
+  /* Haven't see the type before.  */
+  VEC_safe_push (tree, heap, pi->cast_types, casted);
+  VEC_safe_push (int, heap, pi->cast_counts, 1);
+}
+
+/* Return the most-casted-to type in PI->CAST_TYPES.  Return an
+   appropriately signed variant of size_type_node if the variable wasn't
+   cast in some fashion.  */
+
+static tree
+choose_profitable_promoted_type (struct promote_info *pi)
+{
+  int i;
+  int count;
+  tree type = NULL_TREE;
+  int maxuse = -1;
+
+  for (i = 0; VEC_iterate (int, pi->cast_counts, i, count); i++)
+    if (count > maxuse)
+      {
+       maxuse = count;
+       type = VEC_index (tree, pi->cast_types, i);
+      }
+
+  if (type == NULL_TREE)
+    {
+      if (dump_file)
+       {
+         fprintf (dump_file, "Warning, failed to find upcast type for ");
+         print_generic_expr (dump_file, pi->loop_index_name, 0);
+         fprintf (dump_file, "\n");
+       }
+      return (TYPE_UNSIGNED (TREE_TYPE (pi->var_decl))
+             ? size_type_node
+             : signed_type_for (size_type_node));
+    }
+  else
+    return signed_type_for (type);
+}
+
+/* Intuit the loop index for LOOP from PHI.  There must be a path that
+   only goes through NOP_EXPRs or CONVERT_EXPRs from the result of PHI
+   to one of the operands of COND.  If such a path cannot be found,
+   return NULL_TREE.  If LIMIT is not NULL and a path can be found,
+   store the other operand of COND into LIMIT.  */
+
+static tree
+find_promotion_candidate_from_phi (struct loop *loop, gimple cond,
+                                  gimple phi, tree *limit)
+{
+  tree op0, op1;
+  tree result, candidate;
+
+  result = candidate = PHI_RESULT (phi);
+  /* Must be an integer variable.  */
+  if (TREE_CODE (TREE_TYPE (candidate)) != INTEGER_TYPE)
+    return NULL_TREE;
+
+  op0 = gimple_cond_lhs (cond);
+  op1 = gimple_cond_rhs (cond);
+
+  /* See if there's a path from CANDIDATE to an operand of COND.  */
+  while (true)
+    {
+      use_operand_p use;
+      imm_use_iterator iui;
+      gimple use_stmt = NULL;
+
+      if (candidate == op0)
+       {
+         if (limit) *limit = op1;
+         break;
+       }
+      if (candidate == op1)
+       {
+         if (limit) *limit = op0;
+         break;
+       }
+
+      /* Find a single use in the loop header.  Give up if there's
+        multiple ones.  */
+      FOR_EACH_IMM_USE_FAST (use, iui, candidate)
+       {
+         gimple stmt = USE_STMT (use);
+
+         if (gimple_bb (stmt) == loop->header)
+           {
+             if (use_stmt)
+               {
+                 if (dump_file)
+                   {
+                     fprintf (dump_file, "Rejecting ");
+                     print_generic_expr (dump_file, candidate, 0);
+                     fprintf (dump_file, " because it has multiple uses in the loop header (bb #%d).\n",
+                              loop->header->index);
+                     fprintf (dump_file, "first use: ");
+                     print_gimple_stmt (dump_file, use_stmt, 0, 0);
+                     fprintf (dump_file, "\nsecond use: ");
+                     print_gimple_stmt (dump_file, stmt, 0, 0);
+                     fprintf (dump_file, "\n(possibly more, but unanalyzed)\n");
+                   }
+                 return NULL_TREE;
+               }
+             else
+               use_stmt = stmt;
+           }
+       }
+
+      /* No uses in the loop header, bail.  */
+      if (use_stmt == NULL)
+       return NULL_TREE;
+
+      if (gimple_code (use_stmt) != GIMPLE_ASSIGN
+         || TREE_CODE (gimple_assign_lhs (use_stmt)) != SSA_NAME
+         || (gimple_assign_rhs_code (use_stmt) != NOP_EXPR
+             && gimple_assign_rhs_code (use_stmt) != CONVERT_EXPR))
+       {
+         if (dump_file)
+           {
+             fprintf (dump_file, "Rejecting ");
+             print_generic_expr (dump_file, candidate, 0);
+             fprintf (dump_file, " because of use in ");
+             print_gimple_stmt (dump_file, use_stmt, 0, 0);
+             fprintf (dump_file, "\n");
+           }
+         return NULL_TREE;
+       }
+
+      candidate = gimple_assign_lhs (use_stmt);
+    }
+
+  /* CANDIDATE is now what we believe to be the loop index variable.  There
+     are two possibilities:
+
+     - CANDIDATE is not the "true" loop index variable, but rather is a
+       promoted version of RESULT, done for purposes of satisfying a
+       language's semantics;
+
+     - CANDIDATE is the "true" loop index variable.  */
+  if (!types_compatible_p (TREE_TYPE (result), TREE_TYPE (candidate)))
+    candidate = result;
+
+  /* The type of candidate must be "short" to consider promoting it.  */
+  if (TREE_CODE (TREE_TYPE (candidate)) != INTEGER_TYPE
+      || TYPE_PRECISION (TREE_TYPE (candidate)) >= TYPE_PRECISION (size_type_node))
+    return NULL_TREE;
+
+  return candidate;
+}
+
+/* Find the loop index variable of LOOP.  LOOP's exit is controlled by
+   the COND_EXPR EXPR.  IF we can't determine what the loop index
+   variable is, or EXPR does not appear to be analyzable, then return
+   NULL_TREE.  */
+
+static tree
+find_promotion_candidate (struct loop *loop, gimple cond, tree *limit)
+{
+  tree candidate = NULL_TREE;
+  gimple_stmt_iterator gsi;
+
+  switch (gimple_cond_code (cond))
+    {
+    case GT_EXPR:
+    case GE_EXPR:
+    case NE_EXPR:
+    case LT_EXPR:
+    case LE_EXPR:
+      break;
+
+    default:
+      return NULL_TREE;
+    }
+
+  /* We'd like to examine COND and intuit the loop index variable from
+     there.  Instead, we're going to start from the phi nodes in BB and
+     attempt to work our way forwards to one of the operands of COND,
+     since starting from COND might yield an upcast loop index.  If we
+     find multiple phi nodes whose results reach COND, then give up.  */
+  for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+      gimple phi = gsi_stmt (gsi);
+      tree t = find_promotion_candidate_from_phi (loop, cond, phi, limit);
+
+      if (t == NULL_TREE)
+       continue;
+      else if (candidate == NULL_TREE)
+       candidate = t;
+      else
+       {
+         if (dump_file)
+           {
+             fprintf (dump_file, "Can't find a candidate from ");
+             print_gimple_stmt (dump_file, cond, 0, 0);
+             fprintf (dump_file, "\n  because too many phi node results reach the condition.\n");
+           }
+         return NULL_TREE;
+       }
+    }
+
+  return candidate;
+}
+
+/* Return true if X is something that could be promoted.  */
+
+static bool
+could_be_promoted (tree x)
+{
+  return (TREE_CODE (x) == INTEGER_CST
+         || (TREE_CODE (x) == SSA_NAME
+             && pointer_set_contains (promotable_names, x)));
+}
+
+/* Examine the RHS of STMT's suitability with respect to being able to
+   promote VAR.  */
+
+static bool
+check_rhs_for_promotability (struct promote_info *pi, tree var, gimple stmt,
+                            bool is_assign)
+{
+  enum tree_code subcode = gimple_assign_rhs_code (stmt);
+
+  bool ok = true;
+
+  switch (subcode)
+    {
+    case PLUS_EXPR:
+    case MINUS_EXPR:
+    case MULT_EXPR:
+    case EQ_EXPR:
+    case NE_EXPR:
+    case LT_EXPR:
+    case LE_EXPR:
+    case GT_EXPR:
+    case GE_EXPR:
+      {
+       tree op0 = gimple_assign_rhs1 (stmt);
+       tree op1 = gimple_assign_rhs2 (stmt);
+
+       ok = ((op0 == var && could_be_promoted (op1))
+             || (op1 == var && could_be_promoted (op0)));
+       break;
+      }
+    case COND_EXPR:
+      if (gimple_expr_type (stmt) == NULL
+         || gimple_expr_type (stmt) == void_type_node)
+       ok = true;
+      else
+       /* This is conservative; it's possible that these sorts of nodes
+          could be promoted, but we'd have to be very careful about
+          checking in which parts of the COND_EXPR the promotable
+          variable(s) are.  */
+       ok = false;
+      break;
+    case SSA_NAME:
+      {
+       tree expr = gimple_assign_rhs1 (stmt);
+       ok = (expr == var || could_be_promoted (expr));
+      }
+      break;
+    case INTEGER_CST:
+      break;
+    case NOP_EXPR:
+    case CONVERT_EXPR:
+      if (!is_assign)
+       {
+         add_casted_type (pi, gimple_expr_type (stmt));
+         break;
+       }
+      /* Fallthrough.  */
+    default:
+      ok = false;
+      break;
+    }
+
+  return ok;
+}
+
+/* Analyze the loop index VAR for promotability.  The rules for
+   promotability are:
+
+   For uses:
+
+   - The underlying variable may be used in NOP_EXPRs.
+
+   - The underlying variable may be used in simple arithmmetic
+     expressions so long as the other parts are potentially promotable
+     variables or constants (so we don't go willy-nilly on promoting
+     things).
+
+   - The underlying variable may not be stored to memory.
+
+   - All uses must occur inside the loop.
+
+   For defs:
+
+   - The underlying variable may not be loaded from memory; and
+
+   - The underlying variable may only be formed from expressions
+     involving potentially promotable varibles or constants.
+
+   Note that defs may occur outside of the loop; we do this to handle
+   initial conditions before entering the loop.  */
+
+static void
+analyze_loop_index_uses (tree var, struct promote_info *pi)
+{
+  imm_use_iterator iui;
+  use_operand_p use;
+  gimple bad_stmt = NULL;
+  const char *reason = NULL;
+
+  FOR_EACH_IMM_USE_FAST (use, iui, var)
+    {
+      basic_block bb;
+      gimple use_stmt = USE_STMT (use);
+
+      /* Uses must exist only within the loop.  */
+      bb = gimple_bb (use_stmt);
+
+      if (dump_file)
+       {
+         fprintf (dump_file, "Checking ");
+         print_gimple_stmt (dump_file, use_stmt, 0, 0);
+         fprintf (dump_file, "\n");
+       }
+
+      if (!flow_bb_inside_loop_p (pi->loop, bb))
+       {
+         bad_stmt = use_stmt;
+         reason = " is involved in stmt outside loop ";
+         break;
+       }
+
+      /* We cannot store the index to memory.  */
+      if (gimple_references_memory_p (use_stmt))
+       {
+         bad_stmt = use_stmt;
+         reason = " is stored to memory in ";
+         break;
+       }
+
+      if (gimple_code (use_stmt) == GIMPLE_CALL)
+       {
+         /* We cannot pass the variable to a function.  */
+         bad_stmt = use_stmt;
+         reason = " is passed to function in ";
+         break;
+       }
+      else if (gimple_code (use_stmt) == GIMPLE_ASSIGN)
+       {
+         tree lhs = gimple_assign_lhs (use_stmt);
+
+         if (!check_rhs_for_promotability (pi, var, use_stmt,
+                                           /*is_assign=*/false))
+           {
+             bad_stmt = use_stmt;
+             reason = " is involved in non-promotable expression ";
+             break;
+           }
+         else if ((TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt)) == tcc_binary
+                   || gimple_assign_rhs_code (use_stmt) == SSA_NAME)
+                  && !could_be_promoted (lhs))
+           {
+             bad_stmt = use_stmt;
+             reason = " is being assigned to non-promotable variable ";
+             break;
+           }
+       }
+      else if (gimple_code (use_stmt) != GIMPLE_COND
+              && gimple_code (use_stmt) != GIMPLE_PHI)
+       {
+         /* Use of the variable in some statement we don't know how to
+            analyze.  */
+         bad_stmt = use_stmt;
+         reason = " is used in unanalyzable expression in ";
+         break;
+       }
+    }
+
+  if (bad_stmt && reason)
+    {
+      if (dump_file)
+       {
+         fprintf (dump_file, "Loop index ");
+         print_generic_expr (dump_file, var, 0);
+         fprintf (dump_file, "%s", reason);
+         print_gimple_stmt (dump_file, bad_stmt, 0, 0);
+         fprintf (dump_file, "\n");
+       }
+      pi->can_be_promoted_p = false;
+    }
+}
+
+/* Check that the uses and def of VAR, defined in STMT, conform to the
+   rules given above.  */
+
+static bool
+analyze_loop_index (tree var, gimple stmt, void *data)
+{
+  struct promote_info *pi = (struct promote_info *) data;
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Analyzing loop index ");
+      print_generic_expr (dump_file, var, 0);
+      fprintf (dump_file, " defined in ");
+      print_gimple_stmt (dump_file, stmt, 0, 0);
+      fprintf (dump_file, "\n");
+    }
+
+  /* Check the definition.  */
+  switch (gimple_code (stmt))
+    {
+    case GIMPLE_PHI:
+      /* Phi nodes are OK.  */
+      break;
+
+    case GIMPLE_ASSIGN:
+      if (!check_rhs_for_promotability (pi, var, stmt,
+                                       /*is_assign=*/true))
+       break;
+      /* Fallthrough.  */
+
+    default:
+      /* Something we can't handle or the variable is being loaded from
+        memory.  */
+      pi->can_be_promoted_p = false;
+      goto done;
+    }
+
+  if (gimple_code (stmt) == GIMPLE_PHI)
+    {
+      unsigned int i;
+
+      for (i = 0; i < gimple_phi_num_args (stmt); i++)
+       {
+         tree arg = PHI_ARG_DEF (stmt, i);
+
+         if (TREE_CODE (arg) == SSA_NAME)
+           pointer_set_insert (promotable_names, arg);
+       }
+
+      analyze_loop_index_uses (PHI_RESULT (stmt), pi);
+    }
+  else
+    analyze_loop_index_uses (var, pi);
+
+  /* Only worth continuing if we think the loop index can be
+     promoted.  */
+ done:
+  if (dump_file)
+    {
+      fprintf (dump_file, "Done analyzing ");
+      print_generic_expr (dump_file, var, 0);
+      fprintf (dump_file, " defined in ");
+      print_gimple_stmt (dump_file, stmt, 0, 0);
+      fprintf (dump_file, "...%s to analyze\n\n",
+              pi->can_be_promoted_p ? "continuing" : "not continuing");
+    }
+  return !pi->can_be_promoted_p;
+}
+
+/* Determine whether T is an INTEGER_CST or a single-use SSA_NAME
+   defined as the result of a NOP_EXPR or CONVERT_EXPR.  Return the
+   operand of the NOP_EXPR or CONVERT_EXPR if so.  */
+
+static tree
+upcast_operand_p (tree t)
+{
+  gimple def;
+
+  if (TREE_CODE (t) == INTEGER_CST)
+    return t;
+
+  if (TREE_CODE (t) != SSA_NAME
+      || !has_single_use (t))
+    return NULL_TREE;
+
+  def = SSA_NAME_DEF_STMT (t);
+  if (gimple_code (def) != GIMPLE_ASSIGN)
+    return NULL_TREE;
+
+  if (gimple_assign_rhs_code (def) != CONVERT_EXPR
+      && gimple_assign_rhs_code (def) != NOP_EXPR)
+    return NULL_TREE;
+
+  return gimple_assign_rhs1 (def);
+}
+
+/* Check for the idiom:
+
+     short x, y;
+     unsigned short x.2, y.2, tmp;
+     ...
+     x.2 = (unsigned short) x;
+     y.2 = (unsigned short) y;
+     tmp = x.2 + y.2;
+     x = (short) tmp;
+
+   which is generated by convert for avoiding signed arithmetic
+   overflow.  RHS is TMP in the above statement.  If RHS is
+   defined via such an idiom, store x and y into *OP0 and *OP1,
+   respectively.  We permit y.2 to be a constant if necessary.  */
+
+static bool
+signed_arithmetic_overflow_idiom_p (tree rhs, tree *op0, tree *op1)
+{
+  gimple op_stmt = SSA_NAME_DEF_STMT (rhs);
+  tree x2, y2;
+  bool yes = false;
+  enum tree_code code;
+
+  if (!has_single_use (rhs)
+      || gimple_code (op_stmt) != GIMPLE_ASSIGN)
+    goto done;
+
+  /* This could probably profitably be expanded to consider
+     MINUS_EXPR, MULT_EXPR, etc.  */
+  code = gimple_assign_rhs_code (op_stmt);
+  if (code != PLUS_EXPR)
+    goto done;
+  x2 = gimple_assign_rhs1 (op_stmt);
+  y2 = gimple_assign_rhs2 (op_stmt);
+
+  x2 = upcast_operand_p (x2);
+  if (x2 == NULL_TREE)
+    goto done;
+  y2 = upcast_operand_p (y2);
+  if (y2 == NULL_TREE)
+    goto done;
+
+  *op0 = x2;
+  *op1 = y2;
+  yes = true;
+
+ done:
+  return yes;
+}
+
+/* Simple wrapper around flow_bb_inside_loop_p that handles NULL
+   statements and initial definitions of variables.  */
+
+static bool
+stmt_in_loop_p (gimple t, struct loop *loop)
+{
+  basic_block bb;
+
+  if (t == NULL)
+    return false;
+
+  bb = gimple_bb (t);
+  if (bb == NULL)
+    return false;
+
+  return flow_bb_inside_loop_p (loop, bb);
+}
+
+/* The loop index should have a specific usage pattern:
+
+   - It should be defined in a phi node with two incoming values:
+
+     LI_phi = PHI (LI_out, LI_in)
+
+   - One incoming value, LI_out, should be from outside the loop.
+
+   - The other incoming value, LI_in, should be defined thusly:
+
+     LI_in = LI_phi + increment
+
+   - increment should be 1.  We permit other increments with
+     -funsafe-loop-optimizations.
+
+   - Finally, in the comparison to exit the loop, the loop index must be
+     compared against a variable that has a type at least as precise as
+     the loop index's type.  For instance, something like:
+
+       char limit;
+       short i;
+
+       for (i = 0; i < limit; i++) ... 
+
+     would not be permitted.  */
+
+static bool
+analyze_loop_index_definition_pattern (struct promote_info *pi)
+{
+  gimple phi = SSA_NAME_DEF_STMT (pi->loop_index_name);
+  bool ok = false, warn = false;
+  tree in0, in1;
+  bool inside0, inside1;
+  gimple def0, def1;
+  tree op0, op1, increment = NULL_TREE;
+
+  if (gimple_code (phi) != GIMPLE_PHI
+      || gimple_phi_num_args (phi) != 2)
+    goto done;
+
+  in0 = PHI_ARG_DEF (phi, 0);
+  in1 = PHI_ARG_DEF (phi, 1);
+
+  /* Figure out which value comes from outside the loop.  */
+  def0 = TREE_CODE (in0) == SSA_NAME ? SSA_NAME_DEF_STMT (in0) : NULL;
+  def1 = TREE_CODE (in1) == SSA_NAME ? SSA_NAME_DEF_STMT (in1) : NULL;
+
+  inside0 = stmt_in_loop_p (def0, pi->loop);
+  inside1 = stmt_in_loop_p (def1, pi->loop);
+
+  if (inside0 && inside1)
+    goto done;
+  else if (inside0)
+    {
+      tree t = in0;
+      gimple g;
+      in0 = in1;
+      in1 = t;
+      g = def0;
+      def0 = def1;
+      def1 = g;
+    }
+  else if (!inside1)
+    goto done;
+
+  /* IN0 comes from outside the loop, IN1 from inside.  Analyze IN1.  */
+  if (gimple_code (def1) != GIMPLE_ASSIGN)
+    goto done;
+
+  switch (gimple_assign_rhs_code (def1))
+    {
+    case CONVERT_EXPR:
+    case NOP_EXPR:
+      if (!signed_arithmetic_overflow_idiom_p (gimple_assign_rhs1 (def1),
+                                              &op0, &op1))
+       goto done;
+      goto plus;
+    case PLUS_EXPR:
+      op0 = gimple_assign_rhs1 (def1);
+      op1 = gimple_assign_rhs2 (def1);
+    plus:
+      {
+       bool op0_li = op0 == PHI_RESULT (phi);
+       bool op1_li = op1 == PHI_RESULT (phi);
+       if (op0_li && op1_li)
+         /* This is weird, and definitely is not a case we can support
+            for promotion.  */
+         goto done;
+       else if (op0_li)
+         increment = op1;
+       else if (op1_li)
+         increment = op0;
+       else
+         goto done;
+       break;
+      }
+    default:
+      break;
+    }
+
+
+  /* Check that the exit condition for the loop is OK.  */
+  {
+    enum tree_code code = gimple_cond_code (pi->exit_expr);
+
+    op0 = gimple_cond_lhs (pi->exit_expr);
+    op1 = gimple_cond_rhs (pi->exit_expr);
+
+    if (op0 == pi->loop_limit)
+      {
+       tree t = op0;
+       op0 = op1;
+       op1 = t;
+       code = swap_tree_comparison (code);
+      }
+
+    if (code != LT_EXPR && code != LE_EXPR)
+      goto done;
+
+    if (!types_compatible_p (TREE_TYPE (pi->loop_index_name),
+                            TREE_TYPE (pi->loop_limit)))
+      {
+       switch (TREE_CODE (pi->loop_limit))
+         {
+         case INTEGER_CST:
+           if (!int_fits_type_p (pi->loop_limit,
+                                 TREE_TYPE (pi->loop_index_name)))
+             goto done;
+           break;
+         case SSA_NAME:
+           {
+             tree v = pi->loop_limit;
+             gimple def = SSA_NAME_DEF_STMT (v);
+
+             /* Backtrack through CONVERT_EXPRs and/or NOP_EXPRs to
+                determine if the variables "started out" as the same
+                type.  */
+             while (gimple_code (def) == GIMPLE_ASSIGN)
+               {
+                 enum tree_code rhs_code = gimple_assign_rhs_code (def);
+
+                 if (rhs_code != NOP_EXPR && rhs_code != CONVERT_EXPR)
+                   break;
+
+                 v = gimple_assign_rhs1 (def);
+                 def = SSA_NAME_DEF_STMT (v);
+               }
+             /* Permit comparisons between non-compatible types with
+                flag_unsafe_loop_optimizations, since we can assume the
+                loop index does not overflow.  */
+             if (types_compatible_p (TREE_TYPE (pi->loop_index_name),
+                                     TREE_TYPE (v))
+                 || flag_unsafe_loop_optimizations)
+               break;
+             /* Fallthrough.  */
+           default:
+             goto done;
+           }
+         }
+      }
+  }
+
+  if (increment == NULL_TREE)
+    goto done;
+  if (TREE_CODE (increment) != INTEGER_CST
+      || compare_tree_int (increment, 1) != 0)
+    {
+      warn = true;
+      if (!flag_unsafe_loop_optimizations)
+       goto done;
+    }
+
+  ok = true;
+ done:
+  if (warn && !pi->warned)
+    {
+      pi->warned = true;
+      /* We can promote unsigned indices only if -funsafe-loop-optimizations
+        is in effect, since the user might be depending on the modulo
+        wraparound behavior of unsigned types.  */
+      if (warn_unsafe_loop_optimizations)
+       {
+         const char *wording;
+
+         wording = (flag_unsafe_loop_optimizations
+                    ? N_("assuming that the loop counter does not overflow")
+                    : N_("cannot optimize loop, the loop counter may overflow"));
+         warning (OPT_Wunsafe_loop_optimizations, "%s", gettext (wording));
+       }
+    }
+
+  return ok;
+}
+
+/* Analyze the loop associated with PI_ to see if its loop index can be
+   promoted.  */
+
+static bool
+analyze_loop (const void *pi_, void *data)
+{
+  struct promote_info *pi = CONST_CAST (struct promote_info *,
+                                       (const struct promote_info *) pi_);
+  bool *changed = (bool *) data;
+
+  /* We previously determined we can't promote this; go ahead and
+     continue iterating.  */
+  if (pi->loop_index_name == NULL_TREE)
+    return true;
+
+  /* Assume we can always promote the loop index, even if it doesn't
+     exist.  */
+  pi->can_be_promoted_p = true;
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Analyzing ");
+      print_generic_expr (dump_file, pi->loop_index_name, 0);
+      fprintf (dump_file, "\n");
+    }
+
+  if (pi->loop_index_name
+      && analyze_loop_index_definition_pattern (pi))
+    {
+      /* Clear any previously gathered information.  */
+      VEC_truncate (tree, pi->cast_types, 0);
+      VEC_truncate (int, pi->cast_counts, 0);
+
+      walk_use_def_chains (pi->loop_index_name, analyze_loop_index, pi, false);
+    }
+  else
+    pi->can_be_promoted_p = false;
+
+  /* If we determined the loop index is used in strange ways, clear it
+     so we don't examine it again.  */
+  if (!pi->can_be_promoted_p)
+    pi->loop_index_name = NULL_TREE;
+
+  /* Let our caller know whether to re-do the analysis.  */
+  *changed = *changed || !pi->can_be_promoted_p;
+  /* Continue if PI is promotable.  */
+  return pi->can_be_promoted_p;
+}
+
+/* Add PI_->LOOP_INDEX_NAME to the set of variables, DATA, that we are
+   considering for promotion.  */
+
+static bool
+add_variable (const void *pi_, void *data ATTRIBUTE_UNUSED)
+{
+  const struct promote_info *pi = (const struct promote_info *) pi_;
+  struct pointer_set_t *pset = (struct pointer_set_t *) data;
+  int presentp;
+
+  if (pi->loop_index_name != NULL_TREE)
+    {
+      presentp = pointer_set_insert (pset, pi->loop_index_name);
+      gcc_assert (!presentp);
+    }
+
+  /* Continue traversal.  */
+  return true;
+}
+
+/* For each promotable variable:
+
+   - create a new, promoted VAR_DECL;
+
+   - walk through all the uses and defs and create new statements using
+     the promoted variables.  We don't create new phi nodes; post-pass
+     SSA update will handle those for us.  */
+
+/* Make dump files readable.  */
+#define PROMOTED_VAR_SUFFIX ".promoted"
+
+/* Create a variable NAME with TYPE and do the necessary work to inform
+   the SSA machinery about it.  */
+
+static tree
+create_pli_var (tree type, char *name)
+{
+  tree var = create_tmp_var (type, name);
+  create_var_ann (var);
+  mark_sym_for_renaming (var);
+  add_referenced_var (var);
+  return var;
+}
+
+/* Associate the SSA_NAME VAR with the promoted variable DATA.  */
+
+static bool
+associate_name_with_var (tree var, gimple def_stmt, void *data)
+{
+  tree promoted_var = (tree) data;
+  void **p;
+
+  gcc_assert (promoted_var != NULL_TREE);
+
+  if (gimple_code (def_stmt) == GIMPLE_PHI)
+    var = PHI_RESULT (def_stmt);
+
+  p = pointer_map_insert (variable_map, var);
+
+  if (!*p)
+    {
+      if (dump_file)
+       {
+         fprintf (dump_file, "Associating ");
+         print_generic_expr (dump_file, var, 0);
+         fprintf (dump_file, " with ");
+         print_generic_expr (dump_file, promoted_var, 0);
+         fprintf (dump_file, "\n\n");
+       }
+      *(tree *)p = promoted_var;
+    }
+
+  /* Continue traversal.  */
+  return false;
+}
+
+/* Create a promoted variable for the variable from PI_.  */
+
+static bool
+create_promoted_variable (const void *pi_, void *data ATTRIBUTE_UNUSED)
+{
+  struct promote_info *pi = CONST_CAST (struct promote_info *,
+                                       (const struct promote_info *) pi_);
+
+  if (pi->can_be_promoted_p)
+    {
+      tree type = choose_profitable_promoted_type (pi);
+      tree orig_name = DECL_NAME (pi->var_decl);
+      size_t id_len = IDENTIFIER_LENGTH (orig_name);
+      size_t name_len = id_len + strlen (PROMOTED_VAR_SUFFIX) + 1;
+      char *name;
+
+      name = (char *) alloca (name_len);
+      strcpy (name, IDENTIFIER_POINTER (orig_name));
+      strcpy (name + id_len, PROMOTED_VAR_SUFFIX);
+
+      pi->promoted_type = type;
+      pi->promoted_var = create_pli_var (type, name);
+
+      if (dump_file)
+       {
+         fprintf (dump_file, "Created new variable ");
+         print_generic_expr (dump_file, pi->promoted_var, 0);
+         fprintf (dump_file, " to stand in for ");
+         print_generic_expr (dump_file, pi->loop_index_name, 0);
+         fprintf (dump_file, "\n\n");
+       }
+
+      walk_use_def_chains (pi->loop_index_name,
+                          associate_name_with_var,
+                          pi->promoted_var, false);
+    }
+
+  /* Continue traversal.  */
+  return true;
+}
+
+/* Rebuild T with newly promoted variables; STMT is the original
+   statement in which T appeared and may be equivalent to T.  TYPE is
+   non-null when rebuilding the rhs of a GIMPLE_ASSIGN and indicates the
+   type of the lhs.  */
+
+static tree
+rebuild_tree_with_promotion (tree t, gimple stmt, tree type,
+                            gimple_stmt_iterator gsi,
+                            struct promote_info *pi)
+{
+  tree op0, op1;
+
+  switch (TREE_CODE (t))
+    {
+    case NOP_EXPR:
+    case CONVERT_EXPR:
+      {
+       tree pvar = rebuild_tree_with_promotion (TREE_OPERAND (t, 0), stmt, type, gsi, pi);
+
+       if (types_compatible_p (type, TREE_TYPE (pvar)))
+         return pvar;
+       else
+         return build1 (TREE_CODE (t), type, pvar);
+      }
+    case INTEGER_CST:
+      {
+       return build_int_cst_wide (pi->promoted_type,
+                                  TREE_INT_CST_LOW (t),
+                                  TREE_INT_CST_HIGH (t));
+      }
+    case COND_EXPR:
+      {
+       tree orig_op0 = TREE_OPERAND (t, 0);
+       op0 = rebuild_tree_with_promotion (orig_op0, stmt, type, gsi, pi);
+       gcc_assert (orig_op0 != op0);
+       TREE_OPERAND (t, 0) = op0;
+       return t;
+      }
+    case PLUS_EXPR:
+    case MINUS_EXPR:
+    case MULT_EXPR:
+      type = pi->promoted_type;
+      goto binary_expr;
+    case EQ_EXPR:
+    case NE_EXPR:
+    case LT_EXPR:
+    case LE_EXPR:
+    case GT_EXPR:
+    case GE_EXPR:
+      type = TREE_TYPE (t);
+    binary_expr:
+      op0 = TREE_OPERAND (t, 0);
+      op1 = TREE_OPERAND (t, 1);
+      op0 = rebuild_tree_with_promotion (op0, stmt, type, gsi, pi);
+      op1 = rebuild_tree_with_promotion (op1, stmt, type, gsi, pi);
+      return build2 (TREE_CODE (t), type, op0, op1);
+    case SSA_NAME:
+      {
+       void **p = pointer_map_contains (variable_map, t);
+
+       if (p == NULL)
+         {
+           /* This is unexpected, but it does happen if we were dealing
+              with COND_EXPRs and such.  Just go ahead and create a
+              temporary for it.  */
+           if (types_compatible_p (TREE_TYPE (t), pi->promoted_type)
+               || SSA_NAME_DEF_STMT (t) == stmt)
+             return t;
+           else
+             goto insert_cast;
+         }
+       else
+         return *(tree *)p;
+      }
+    case VAR_DECL:
+      return t;
+    default:
+    insert_cast:
+      {
+       gimple cast;
+       tree tmp, nop;
+       tree to_upcast = t;
+
+       /* If we are dealing with a memory reference, then we can't have
+          wrap it in a NOP_EXPR; we need to load the value from memory
+          first, then convert it.  */
+       if (!is_gimple_reg (to_upcast))
+         {
+           tree tmp = create_pli_var (TREE_TYPE (to_upcast),
+                                      CONST_CAST (char *, "loadtmp"));
+           gimple stmt = gimple_build_assign (tmp, to_upcast);
+           gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
+           to_upcast = tmp;
+         }
+
+       tmp = create_pli_var (pi->promoted_type,
+                             CONST_CAST (char *, "promotetmp"));
+       nop = build1 (NOP_EXPR, pi->promoted_type, to_upcast);
+       cast = gimple_build_assign (tmp, nop);
+       if (dump_file)
+         {
+           fprintf (dump_file, "Inserting cast ");
+           print_gimple_stmt (dump_file, cast, 0, 0);
+           fprintf (dump_file, " prior to ");
+           print_gimple_stmt (dump_file, stmt, 0, 0);
+           fprintf (dump_file, "\n");
+         }
+       gsi_insert_before (&gsi, cast, GSI_SAME_STMT);
+       return tmp;
+      }
+    }
+}
+
+/* Split E and place STMT in the block created by doing so.  */
+
+static void
+insert_along_edge (gimple stmt, edge e)
+{
+  basic_block bb = split_edge (e);
+
+  gimple_set_bb (stmt, bb);
+  set_bb_seq (bb, gimple_seq_alloc_with_stmt (stmt));
+}
+
+/* Rebuild STMT, which contains uses or a def of the promotable variable
+   associated with PI.  */
+
+static void
+rebuild_with_promotion (gimple stmt, struct promote_info *pi)
+{
+  gimple_stmt_iterator gsi;
+
+  if (pointer_set_insert (promoted_stmts, stmt))
+    return;
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Rebuilding stmt ");
+      print_gimple_stmt (dump_file, stmt, 0, 0);
+      fprintf (dump_file, "\n");
+    }
+
+  gsi = gsi_for_stmt (stmt);
+  
+  switch (gimple_code (stmt))
+    {
+    case GIMPLE_ASSIGN:
+      {
+       enum tree_code subcode = gimple_assign_rhs_code (stmt);
+       enum tree_code newcode = subcode;
+       tree lhs = gimple_assign_lhs (stmt);
+       tree rhs1 = gimple_assign_rhs1 (stmt);
+       tree rhs2 = gimple_assign_rhs2 (stmt);
+       tree x, y;
+       void **v;
+
+       /* If we are defining a promotable variable, check for special
+          idioms.  */
+       v = pointer_map_contains (variable_map, lhs);
+       if (v != NULL
+           && *(tree *)v == pi->promoted_var
+           && (subcode == NOP_EXPR || subcode == CONVERT_EXPR)
+           && signed_arithmetic_overflow_idiom_p (rhs1, &x, &y))
+         {
+           void **xp;
+           void **yp;
+           if (TYPE_PRECISION (TREE_TYPE (rhs1))
+               >= TYPE_PRECISION (pi->promoted_type))
+             goto done;
+
+           /* It's possible that we've already promoted the operands of
+              one or both of the NOP_EXPRs.  In that case, we can
+              bypass the logic below and go straight to rebuilding the
+              rhs that we really want to transform.  */
+           if (TREE_CODE (x) == VAR_DECL
+               || TREE_CODE (y) == VAR_DECL)
+             goto build_fake;
+           xp = pointer_map_contains (variable_map, x);
+           yp = pointer_map_contains (variable_map, y);
+
+           /* Nothing to see here.  */
+           if (!types_compatible_p (TREE_TYPE (x),
+                                    TREE_TYPE (y))
+               || (xp == NULL && yp == NULL))
+             goto done;
+           x = (xp == NULL ? NULL_TREE : *(tree *)xp);
+           y = (yp == NULL ? NULL_TREE : *(tree *)yp);
+
+           if (x != pi->promoted_var && y != pi->promoted_var)
+             goto done;
+
+         build_fake:
+           newcode = PLUS_EXPR;
+           rhs1 = x;
+           rhs2 = y;
+           if (dump_file)
+             {
+               fprintf (dump_file, "Substituting ");
+               print_generic_expr (dump_file, x, 0);
+               fprintf (dump_file, " + ");
+               print_generic_expr (dump_file, y, 0);
+               fprintf (dump_file, " for rhs of original statement\n");
+             }
+
+         done:
+           ;
+         }
+
+       lhs = rebuild_tree_with_promotion (lhs, stmt, NULL, gsi, pi);
+       rhs1 = rebuild_tree_with_promotion (rhs1, stmt, NULL, gsi, pi);
+       if (rhs2)
+         rhs2 = rebuild_tree_with_promotion (rhs2, stmt, NULL, gsi, pi);
+
+       if (newcode != subcode)
+         {
+           gimple newstmt = gimple_build_assign_with_ops (newcode,
+                                                          lhs, rhs1, rhs2);
+           gsi_replace (&gsi, newstmt, true);
+           stmt = newstmt;
+         }
+       else
+         {
+           gimple_assign_set_lhs (stmt, lhs);
+           gimple_assign_set_rhs1 (stmt, rhs1);
+           if (rhs2)
+             gimple_assign_set_rhs2 (stmt, rhs2);
+         }
+      }
+      break;
+    case GIMPLE_COND:
+      {
+       tree lhs = gimple_cond_lhs (stmt);
+       tree rhs = gimple_cond_rhs (stmt);
+
+       lhs = rebuild_tree_with_promotion (lhs, stmt, NULL, gsi, pi);
+       rhs = rebuild_tree_with_promotion (rhs, stmt, NULL, gsi, pi);
+
+       gimple_cond_set_lhs (stmt, lhs);
+       gimple_cond_set_rhs (stmt, rhs);
+      }
+      break;
+    case GIMPLE_PHI:
+      /* Save for later rebuilding.  Any rebuilding of a phi node will
+	 cause an incoming edge to be split, which means that the phi
+	 node may be reallocated, which means that keeping track of
+	 which statements have been rebuilt (by pointer equality) breaks
+	 down.  */
+      gsi = gsi_for_stmt (stmt);
+      pointer_set_insert (phi_nodes_to_promote, gsi_stmt_ptr (&gsi));
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Converted stmt ");
+      print_gimple_stmt (dump_file, stmt, 0, 0);
+      fprintf (dump_file, "\n\n");
+    }
+  update_stmt (stmt);
+}
+
+/* Helper function for promote_variable that walks over use/def
+   chains.  */
+
+static bool
+promote_variable_1 (tree var, gimple stmt, void *data)
+{
+  struct promote_info *pi = (struct promote_info *) data;
+  imm_use_iterator imi;
+  gimple use_stmt;
+
+  rebuild_with_promotion (stmt, pi);
+
+  if (gimple_code (stmt) == GIMPLE_PHI)
+    var = PHI_RESULT (stmt);
+
+  if (could_be_promoted (var))
+    FOR_EACH_IMM_USE_STMT (use_stmt, imi, var)
+      {
+	rebuild_with_promotion (use_stmt, pi);
+      }
+
+  return false;
+}
+
+/* Convert all uses and defs of PI_->LOOP_INDEX_NAME as linked by
+   use-def chains to uses and defs of PI_->PROMOTED_VAR.  */
+
+static bool
+promote_variable (const void *pi_, void *data ATTRIBUTE_UNUSED)
+{
+  const struct promote_info *pi = (const struct promote_info *) pi_;
+
+  if (pi->can_be_promoted_p)
+    {
+      walk_use_def_chains (pi->loop_index_name, promote_variable_1,
+                          CONST_CAST (struct promote_info *, pi), false);
+    }
+
+  /* Continue traversal.  */
+  return true;
+}
+
+static bool
+promote_phi_node (const void *phi_, void *data ATTRIBUTE_UNUSED)
+{
+  const gimple *cphi = (const gimple *) phi_;
+  gimple_stmt_iterator gsi = gsi_for_stmt (*cphi);
+  gimple *phi_p = gsi_stmt_ptr (&gsi);
+  gimple phi = *phi_p;
+  unsigned int i;
+  bool promoted_result = could_be_promoted (PHI_RESULT (phi));
+
+  /* There are two cases we have to be concerned about:
+
+     - If the result can be promoted, then any incoming INTEGER_CSTs
+       need to be assigned to the newly promoted variable, rather than
+       the promotable variable;
+
+     - If the result cannot be promoted, then we need to check if any of
+       the arguments are promotable.  For each argument that is, we need
+       to insert a truncating assignment to convert from the type of the
+       promoted variable to the type of the PHI_RESULT.
+
+     In both cases, we have to regrab the phi node after we've inserted
+     the new assignment along the appropriate edge, since
+     insert_along_edge might have reallocated the phi node.  */
+  for (i = 0; i < gimple_phi_num_args (phi); i++)
+    {
+      tree var = gimple_phi_arg_def (phi, i);
+      edge e = gimple_phi_arg_edge (phi, i);
+      gimple assign = NULL;
+
+      if (TREE_CODE (var) == INTEGER_CST && promoted_result)
+	{
+	  tree promoted, cst;
+	  void **p;
+	  
+	  p = pointer_map_contains (variable_map, PHI_RESULT (phi));
+	  gcc_assert (p);
+	  promoted = (tree) *p;
+	  cst = build_int_cst_wide (TREE_TYPE (promoted),
+				    TREE_INT_CST_LOW (var),
+				    TREE_INT_CST_HIGH (var));
+
+	  assign = gimple_build_assign (promoted, cst);
+	}
+      else if (!promoted_result
+	       && TREE_CODE (var) == SSA_NAME
+	       && could_be_promoted (var))
+	{
+	  tree promoted, t, name;
+	  void **p;
+
+	  p = pointer_map_contains (variable_map, var);
+	  gcc_assert (p);
+	  promoted = (tree) *p;
+
+	  if (dump_file)
+	    {
+	      fprintf (dump_file, "Inserting downcast of promoted variable ");
+	      print_generic_expr (dump_file, promoted, 0);
+	      fprintf (dump_file, "\n");
+	    }
+
+	  t = create_pli_var (TREE_TYPE (PHI_RESULT (phi)),
+			      CONST_CAST (char *, "promote_cast_tmp"));
+	  assign = gimple_build_assign_with_ops (CONVERT_EXPR,
+						 t, promoted,
+						 NULL_TREE);
+
+	  name = make_ssa_name (t, assign);
+	  gimple_assign_set_lhs (assign, name);
+	  SET_PHI_ARG_DEF (phi, i, name);
+	}
+
+      if (assign != NULL)
+	{
+	  insert_along_edge (assign, e);
+	  phi = *phi_p;
+	}
+    }
+
+  /* Continue traversal.  */
+  return true;
+}
+
+/* Free PI_ and its associated data.  */
+
+static bool
+free_pi_entries (const void *pi_, void *data ATTRIBUTE_UNUSED)
+{
+  struct promote_info *pi = CONST_CAST (struct promote_info *,
+                                       (const struct promote_info *) pi_);
+
+  VEC_free (tree, heap, pi->cast_types);
+  VEC_free (int, heap, pi->cast_counts);
+  free (pi);
+
+  /* Continue traversal.  */
+  return true;
+}
+
+/* Collect information about variables that we believe to be loop
+   indices in PROMOTION_INFO.  */
+
+static void
+collect_promotion_candidates (void)
+{
+  loop_iterator li;
+  struct loop *loop;
+
+  FOR_EACH_LOOP (li, loop, 0)
+    {
+      basic_block header = loop->header;
+      gimple exit_cond = last_stmt (header);
+      
+      if (exit_cond && gimple_code (exit_cond) == GIMPLE_COND)
+       {
+         tree loop_index;
+         tree limit = NULL_TREE;
+         tree decl;
+         struct promote_info *pi;
+
+         loop_index = find_promotion_candidate (loop, exit_cond, &limit);
+         if (loop_index == NULL_TREE)
+           continue;
+         decl = SSA_NAME_VAR (loop_index);
+         if (TREE_ADDRESSABLE (decl))
+           continue;
+
+         if (dump_file)
+           {
+             fprintf (dump_file, "Found loop index ");
+             print_generic_expr (dump_file, loop_index, 0);
+             fprintf (dump_file, " involved in ");
+             print_gimple_stmt (dump_file, exit_cond, 0, 0);
+             fprintf (dump_file, "\n\n");
+           }
+
+         pi = XCNEW (struct promote_info);
+         pi->loop = loop;
+         pi->exit_expr = exit_cond;
+         pi->loop_index_name = loop_index;
+         pi->loop_limit = limit;
+         pi->var_decl = decl;
+         /* We think so, anyway...  */
+         pi->can_be_promoted_p = true;
+         pointer_set_insert (promotion_info, pi);
+       }
+      else if (dump_file)
+       {
+         fprintf (dump_file, "\nSkipping analysis of loop %d (header bb #%d)\n",
+                  loop->num, loop->header->index);
+         if (exit_cond)
+           {
+             fprintf (dump_file, "Exit condition was ");
+             print_gimple_stmt (dump_file, exit_cond, 0, 0);
+             fprintf (dump_file, "\n");
+           }
+       }
+    }
+}
+
+/* Free memory associated with global variables that we used.  */
+
+static void
+pli_cleanup (void)
+{
+  if (phi_nodes_to_promote)
+    {
+      pointer_set_destroy (phi_nodes_to_promote);
+      phi_nodes_to_promote = NULL;
+    }
+  if (promoted_stmts)
+    {
+      pointer_set_destroy (promoted_stmts);
+      promoted_stmts = NULL;
+    }
+  if (variable_map)
+    {
+      pointer_map_destroy (variable_map);
+      variable_map = NULL;
+    }
+  if (promotable_names)
+    {
+      pointer_set_destroy (promotable_names);
+      promotable_names = NULL;
+    }
+  if (promotion_info)
+    {
+      pointer_set_traverse (promotion_info, free_pi_entries, NULL);
+      pointer_set_destroy (promotion_info);
+      promotion_info = NULL;
+    }
+}
+
+/* The guts of the pass.  */
+
+static unsigned int
+promote_short_indices (void)
+{
+  bool did_something = false;
+  bool changed;
+  size_t max_iterations, i, n_promoted;
+
+  promotion_info = pointer_set_create ();
+  collect_promotion_candidates ();
+
+  if (dump_file)
+    fprintf (dump_file, "Found %d candidates for promotion\n",
+            (int) pointer_set_n_elements (promotion_info));
+
+  /* Nothing to do.  */
+  if (pointer_set_n_elements (promotion_info) == 0)
+    goto cleanup;
+
+  /* We have information about which variables are loop index variables.
+     We now need to determine the promotability of the loop indices.
+     Since the promotability of loop indices may depend on other loop
+     indices, we need to repeat this until we reach a fixed point.  */
+  changed = true;
+  max_iterations = pointer_set_n_elements (promotion_info);
+  i = 0;
+
+  promotable_names = pointer_set_create ();
+
+  while (changed)
+    {
+      changed = false;
+      pointer_set_clear (promotable_names);
+      pointer_set_traverse (promotion_info, add_variable,
+                           promotable_names);
+      n_promoted = pointer_set_n_elements (promotable_names);
+
+      if (dump_file)
+       fprintf (dump_file, "\nIteration %d, have %d variables to consider\n",
+                (int) i, (int) n_promoted);
+
+      if (n_promoted == 0)
+       break;
+      gcc_assert (i < max_iterations);
+      pointer_set_traverse (promotion_info, analyze_loop, &changed);
+      i++;
+    }
+
+  if (dump_file)
+    fprintf (dump_file, "Promoting %d variables\n",
+            (int) n_promoted);
+
+  if (n_promoted != 0)
+    {
+      did_something = true;
+      variable_map = pointer_map_create ();
+      promoted_stmts = pointer_set_create ();
+      phi_nodes_to_promote = pointer_set_create ();
+      pointer_set_traverse (promotion_info, create_promoted_variable, NULL);
+      pointer_set_traverse (promotion_info, promote_variable, NULL);
+      pointer_set_traverse (phi_nodes_to_promote, promote_phi_node, NULL);
+    }
+
+ cleanup:
+  pli_cleanup ();
+  return did_something ? TODO_update_ssa : 0;
+}
+
+/* Entry point for the short loop index promotion pass.  */
+
+static unsigned int
+tree_short_index_promotion (void)
+{
+  unsigned int changed = 0;
+
+  /* Initialize all the necessary loop infrastructure.  */
+  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES | LOOPS_HAVE_RECORDED_EXITS);
+  add_noreturn_fake_exit_edges ();
+  connect_infinite_loops_to_exit ();
+
+  if (number_of_loops () > 1)
+    changed = promote_short_indices ();
+
+  /* Tear down loop optimization infrastructure.  */
+  remove_fake_exit_edges ();
+  free_numbers_of_iterations_estimates ();
+  loop_optimizer_finalize ();
+
+  return changed;
+}
+
+static bool
+gate_short_index_promotion (void)
+{
+  return optimize > 0 && flag_promote_loop_indices;
+}
+
+struct gimple_opt_pass pass_promote_indices =
+{
+  {
+    GIMPLE_PASS,
+    "promoteshort",                    /* name */
+    gate_short_index_promotion,                /* gate */
+    tree_short_index_promotion,                /* execute */
+    NULL,                              /* sub */
+    NULL,                              /* next */
+    0,                                 /* static_pass_number */
+    TV_TREE_LOOP_PROMOTE,              /* tv_id */
+    PROP_cfg | PROP_ssa,               /* properties_required */
+    0,                                 /* properties_provided */
+    0,                                 /* properties_destroyed */
+    0,                                 /* todo_flags_start */
+    TODO_dump_func | TODO_verify_loops 
+    | TODO_ggc_collect                 /* todo_flags_finish */
+  }
+};
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
index 0041d22e4..55dfc3373 100644
--- a/gcc/tree-ssa-pre.c
+++ b/gcc/tree-ssa-pre.c
@@ -104,6 +104,10 @@ along with GCC; see the file COPYING3.  If not see
    In order to make it fully redundant, we insert the expression into
    the predecessors where it is not available, but is ANTIC.
 
+   When optimizing for size, we only eliminate the partial redundancy
+   if we need to insert in only one predecessor.  This avoids almost
+   completely the code size increase that PRE usually causes.
+
    For the partial anticipation case, we only perform insertion if it
    is partially anticipated in some block, and fully available in all
    of the predecessors.
@@ -425,6 +429,7 @@ static pre_expr bitmap_find_leader (bitmap_set_t, unsigned int, gimple);
 static void bitmap_value_insert_into_set (bitmap_set_t, pre_expr);
 static void bitmap_value_replace_in_set (bitmap_set_t, pre_expr);
 static void bitmap_set_copy (bitmap_set_t, bitmap_set_t);
+static void bitmap_set_and (bitmap_set_t, bitmap_set_t);
 static bool bitmap_set_contains_value (bitmap_set_t, unsigned int);
 static void bitmap_insert_into_set (bitmap_set_t, pre_expr);
 static void bitmap_insert_into_set_1 (bitmap_set_t, pre_expr, bool);
@@ -2989,13 +2994,6 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,
   tree temp;
   gimple phi;
 
-  if (dump_file && (dump_flags & TDF_DETAILS))
-    {
-      fprintf (dump_file, "Found partial redundancy for expression ");
-      print_pre_expr (dump_file, expr);
-      fprintf (dump_file, " (%04d)\n", val);
-    }
-
   /* Make sure we aren't creating an induction variable.  */
   if (block->loop_depth > 0 && EDGE_COUNT (block->preds) == 2
       && expr->kind != REFERENCE)
@@ -3193,6 +3191,47 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,
 }
 
 
+/* Indicate if, when optimizing for speed, it is appropriate to make
+   INSERTS_NEEDED insertions in order to make EXPR in BLOCK redundant.  */
+static bool
+ppre_n_insert_for_speed_p (pre_expr expr, basic_block block,
+			   unsigned int inserts_needed)
+{
+  /* The more expensive EXPR is, the more we should be prepared to insert
+     in the predecessors of BLOCK to make EXPR fully redundant.
+     For now, only recognize AND, OR, XOR, PLUS and MINUS of a multiple-use
+     SSA_NAME with a constant as cheap.  */
+  int cost;
+
+  if (flag_tree_pre_partial_partial_obliviously)
+    return true;
+  if (expr->kind == NARY)
+    {
+      vn_nary_op_t nary = PRE_EXPR_NARY (expr);
+      switch (nary->opcode)
+	{
+	  tree name, cnst;
+	case BIT_AND_EXPR: case BIT_IOR_EXPR: case BIT_XOR_EXPR:
+	case PLUS_EXPR: case MINUS_EXPR:
+
+	  gcc_assert (nary->length == 2);
+	  name = nary->op[0];
+	  cnst = nary->op[1];
+	  if (TREE_CODE (name) != SSA_NAME || has_single_use (name))
+	    return true;
+	  if (!is_gimple_min_invariant (cnst))
+	    return true;
+	  cost = 1;
+	  break;
+	default:
+	  return true;
+	}
+    }
+  else
+    return true;
+  return EDGE_COUNT (block->preds) * cost >= inserts_needed;
+
+}
 
 /* Perform insertion of partially redundant values.
    For BLOCK, do the following:
@@ -3227,6 +3266,7 @@ do_regular_insertion (basic_block block, basic_block dom)
 	  pre_expr *avail;
 	  unsigned int val;
 	  bool by_some = false;
+	  unsigned int inserts_needed = 0;
 	  bool cant_insert = false;
 	  bool all_same = true;
 	  pre_expr first_s = NULL;
@@ -3281,6 +3321,7 @@ do_regular_insertion (basic_block block, basic_block dom)
 		{
 		  avail[bprime->index] = eprime;
 		  all_same = false;
+		  inserts_needed++;
 		}
 	      else
 		{
@@ -3290,6 +3331,11 @@ do_regular_insertion (basic_block block, basic_block dom)
 		    first_s = edoubleprime;
 		  else if (!pre_expr_eq (first_s, edoubleprime))
 		    all_same = false;
+		  /* If the available value is not a NAME, PREing this
+		     value will probably result in a copy on the edge
+		     to assign the expression to a register.  */
+		  if (edoubleprime->kind != NAME)
+		    inserts_needed++;
 		}
 	    }
 	  /* If we can insert it, it's not the same value
@@ -3298,9 +3344,27 @@ do_regular_insertion (basic_block block, basic_block dom)
 	     partially redundant.  */
 	  if (!cant_insert && !all_same && by_some && dbg_cnt (treepre_insert))
 	    {
-	      if (insert_into_preds_of_block (block, get_expression_id (expr),
-					      avail))
-		new_stuff = true;
+  	      if (dump_file && (dump_flags & TDF_DETAILS))
+		{
+		  fprintf (dump_file,
+			   "Found partial redundancy for expression ");
+		  print_pre_expr (dump_file, expr);
+		  fprintf (dump_file, " (%04d)\n", get_expr_value_id (expr));
+		}
+
+	      /* If optimizing for size, insert at most one
+		 new expression to avoid increasing code size.  */
+	      if (optimize_function_for_speed_p (cfun)
+		  ? 1 : EDGE_COUNT (block->preds) - inserts_needed == 1)
+		new_stuff |=
+		  insert_into_preds_of_block (block,
+					      get_expression_id (expr),
+					      avail);
+	      else if (dump_file && (dump_flags & TDF_DETAILS))
+		fprintf (dump_file, "Not inserting (optimizing for %s)\n",
+			 optimize_function_for_speed_p (cfun)
+			 ? "speed" : "size");
+
 	    }
 	  /* If all edges produce the same value and that value is
 	     an invariant, then the PHI has the same value on all
@@ -3429,9 +3493,28 @@ do_partial_partial_insertion (basic_block block, basic_block dom)
 	  if (!cant_insert && by_all && dbg_cnt (treepre_insert))
 	    {
 	      pre_stats.pa_insert++;
-	      if (insert_into_preds_of_block (block, get_expression_id (expr),
-					      avail))
-		new_stuff = true;
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		{
+		  fprintf (dump_file,
+			   "Found partial redundancy for expression ");
+		  print_pre_expr (dump_file, expr);
+		  fprintf (dump_file, " (%04d)\n", get_expr_value_id (expr));
+		}
+	      /* Assuming the expression is 50% anticipatable, we have to
+		 multiply the number of insertions needed by two for a cost
+		 comparison.  */
+	      if (!optimize_function_for_speed_p (cfun)
+		  || ppre_n_insert_for_speed_p (expr, block,
+						2 * EDGE_COUNT (block->preds)))
+		new_stuff |=
+		  insert_into_preds_of_block (block,
+					      get_expression_id (expr),
+					      avail);
+	      else if (dump_file && (dump_flags & TDF_DETAILS))
+		fprintf (dump_file, "Not inserting (optimizing for %s)\n",
+			 optimize_function_for_speed_p (cfun)
+			 ? "speed" : "size");
+
 	    }
 	  free (avail);
 	}
@@ -3472,7 +3555,9 @@ insert_aux (basic_block block)
 	  if (!single_pred_p (block))
 	    {
 	      new_stuff |= do_regular_insertion (block, dom);
-	      if (do_partial_partial)
+	      /* Don't bother with partial-partial redundancies when
+		 optimizing for size.  */
+	      if (do_partial_partial && ! optimize_function_for_size_p (cfun))
 		new_stuff |= do_partial_partial_insertion (block, dom);
 	    }
 	}
@@ -4212,11 +4297,11 @@ fini_pre (bool do_fre)
    only wants to do full redundancy elimination.  */
 
 static unsigned int
-execute_pre (bool do_fre ATTRIBUTE_UNUSED)
+execute_pre (bool do_fre)
 {
   unsigned int todo = 0;
 
-  do_partial_partial = optimize > 2;
+  do_partial_partial = flag_tree_pre_partial_partial;
 
   /* This has to happen before SCCVN runs because
      loop_optimizer_init may create new phis, etc.  */
@@ -4288,19 +4373,20 @@ execute_pre (bool do_fre ATTRIBUTE_UNUSED)
   return todo;
 }
 
-/* Gate and execute functions for PRE.  */
+/* Gate and execute functions for FRE/PRE.  */
 
 static unsigned int
 do_pre (void)
 {
-  return TODO_rebuild_alias | execute_pre (false);
+  return TODO_rebuild_alias
+	 | execute_pre (! flag_tree_pre);
 }
 
 static bool
 gate_pre (void)
 {
-  /* PRE tends to generate bigger code.  */
-  return flag_tree_pre != 0 && optimize_function_for_speed_p (cfun);
+  /* Run FRE even if we don't run PRE.  */
+  return (flag_tree_fre || flag_tree_pre);
 }
 
 struct gimple_opt_pass pass_pre =
diff --git a/gcc/tree-ssa-remove-local-statics.c b/gcc/tree-ssa-remove-local-statics.c
new file mode 100644
index 000000000..d9755fee1
--- /dev/null
+++ b/gcc/tree-ssa-remove-local-statics.c
@@ -0,0 +1,885 @@
+/* Local static variable elimination pass.
+   Copyright (C) 2007 Free Software Foundation, Inc.
+   Contributed by Nathan Froyd <froydnj@codesourcery.com>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Converting static function-local variables to automatic variables.
+
+   The motivating example is a function like:
+
+   void
+   foo (unsigned n)
+   {
+     static int var;
+     unsigned i;
+
+     for (i = 0; i != n; i++)
+       {
+         var = ...
+
+         do other things with var...
+       }
+   }
+
+   Because VAR is static, doing things like code motion to loads and
+   stores of VAR is difficult.  Furthermore, accesses to VAR are
+   inefficient.  This pass aims to recognize the cases where it is not
+   necessary for VAR to be static and modify the code so that later
+   passes will do the appropriate optimizations.
+
+   The criteria for a static function-local variable V in a function F
+   being converted to an automatic variable are:
+
+   1. F does not call setjmp; and
+   2. V's address is never taken; and
+   3. V is not declared volatile; and
+   4. V is not used in any nested function;
+   5. V is not an aggregate value (union, struct, array, etc.); and
+   6. Every use of V is defined along all paths leading to the use.
+
+   NOTE: For ease of implementation, we currently treat a function call
+   as killing all previous definitions of static variables, since we
+   could have:
+
+   static void
+   foo (...)
+   {
+     static int x;
+
+     x = ...;       (1)
+
+    f (...);        (2)
+
+     ... = x;       (3)
+   }
+
+   The use at (3) needs to pick up a possible definition made by the
+   call at (2).  If the call at (2) does not call back into 'foo',
+   then the call is not a killing call.  We currently treat it as
+   though it is.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+
+#include "rtl.h"
+#include "tm_p.h"
+#include "hard-reg-set.h"
+#include "obstack.h"
+#include "basic-block.h"
+
+#include "tree.h"
+#include "gimple.h"
+#include "hashtab.h"
+#include "diagnostic.h"
+#include "tree-flow.h"
+#include "tree-dump.h"
+#include "flags.h"
+#include "timevar.h"
+#include "tree-pass.h"
+
+struct rls_decl_info
+{
+  /* The variable declaration.  */
+  tree orig_var;
+
+  /* Its index in rls_block_local_data.  */
+  int index;
+
+  /* Whether we can optimize this variable.  */
+  bool optimizable_p;
+
+  /* The new variable declaration, if we can optimize away the staticness
+     of 'orig_var'.  */
+  tree new_var;
+};
+
+/* Filled with 'struct rls_decl_info'; keyed off ORIG_VAR.  */
+static htab_t static_variables;
+
+struct rls_stmt_info
+{
+  /* The variable declaration.  */
+  tree var;
+
+  /* The statement in which we found a def or a use of the variable.  */
+  gimple stmt;
+
+  /* Whether STMT represents a use of VAR.  */
+  bool use_p;
+
+  /* A bitmap whose entries denote what variables have been defined
+     when execution arrives at STMT.  This field is only used when
+     USE_P is true.  */
+  sbitmap defined;
+};
+
+/* Filled with 'struct rls_stmt_info'; keyed off STMT.  */
+static htab_t defuse_statements;
+
+static struct
+{
+  /* The number of static variables we found.  */
+  size_t n_statics;
+
+  /* The number of optimizable variables we found.  */
+  size_t n_optimizable;
+} stats;
+
+struct rls_block_dataflow_data {
+  /* A bitmap whose entries denote what variables have been defined on
+     entry to this block.  */
+  sbitmap defined_in;
+
+  /* A bitmap whose entries denote what variables have been defined on
+     exit from this block.  */
+  sbitmap defined_out;
+};
+
+/* Parameters for the 'static_variables' hash table.  */
+
+static hashval_t
+rls_hash_decl_info (const void *x)
+{
+  return htab_hash_pointer
+    ((const void *) ((const struct rls_decl_info *) x)->orig_var);
+}
+
+static int
+rls_eq_decl_info (const void *x, const void *y)
+{
+  const struct rls_decl_info *a = (const struct rls_decl_info *) x;
+  const struct rls_decl_info *b = (const struct rls_decl_info *) y;
+
+  return a->orig_var == b->orig_var;
+}
+
+static void
+rls_free_decl_info (void *info)
+{
+  free (info);
+}
+
+/* Parameters for the 'defuse_statements' hash table.  */
+
+static hashval_t
+rls_hash_use_info (const void *x)
+{
+  return htab_hash_pointer
+    ((const void *) ((const struct rls_stmt_info *) x)->stmt);
+}
+
+static int
+rls_eq_use_info (const void *x, const void *y)
+{
+  const struct rls_stmt_info *a = (const struct rls_stmt_info *) x;
+  const struct rls_stmt_info *b = (const struct rls_stmt_info *) y;
+
+  return a->stmt == b->stmt;
+}
+
+static void
+rls_free_use_info (void *info)
+{
+  struct rls_stmt_info *stmt_info = (struct rls_stmt_info *) info;
+
+  if (stmt_info->defined)
+    sbitmap_free (stmt_info->defined);
+
+  free (stmt_info);
+}
+
+/* Initialize data structures and statistics.  */
+
+static void
+rls_init (void)
+{
+  basic_block bb;
+
+  /* We expect relatively few static variables, hence the small
+     initial size for the hash table.  */
+  static_variables = htab_create (8, rls_hash_decl_info,
+                                  rls_eq_decl_info, rls_free_decl_info);
+
+  /* We expect quite a few statements.  */
+  defuse_statements = htab_create (128, rls_hash_use_info,
+                                   rls_eq_use_info, rls_free_use_info);
+
+  FOR_ALL_BB (bb)
+    {
+      struct rls_block_dataflow_data *data;
+
+      data = XNEW (struct rls_block_dataflow_data);
+      memset (data, 0, sizeof (*data));
+      bb->aux = data;
+    }
+
+  stats.n_statics = 0;
+  stats.n_optimizable = 0;
+}
+
+/* Free data structures.  */
+
+static void
+rls_done (void)
+{
+  basic_block bb;
+
+  htab_delete (static_variables);
+  htab_delete (defuse_statements);
+
+  FOR_ALL_BB (bb)
+    {
+      struct rls_block_dataflow_data *data
+	= (struct rls_block_dataflow_data *) bb->aux;
+
+      gcc_assert (data);
+
+      if (data->defined_in)
+	sbitmap_free (data->defined_in);
+      if (data->defined_out)
+	sbitmap_free (data->defined_out);
+      free (data);
+      bb->aux = NULL;
+    }
+}
+
+
+/* Doing the initial work to find static variables.  */
+
+/* Examine the defining statement for VAR and determine whether it is a
+   static variable we could potentially optimize.  If so, stick in it
+   in the 'static_variables' hashtable.
+
+   STMT is the statement in which a definition or use of VAR occurs.
+   USE_P indicates whether VAR is used or defined in STMT.  Enter STMT
+   into 'defuse_statements' as well for use during dataflow
+   analysis.  */
+
+static void
+maybe_discover_new_declaration (tree var, gimple stmt, bool use_p)
+{
+  tree def_stmt = SSA_NAME_VAR (var);
+
+  if (TREE_CODE (def_stmt) == VAR_DECL
+      && DECL_CONTEXT (def_stmt) != NULL_TREE
+      && TREE_CODE (DECL_CONTEXT (def_stmt)) == FUNCTION_DECL
+      /* We cannot optimize away a static used in multiple functions (as
+	 might happen in C++).  */
+      && !DECL_NONLOCAL(def_stmt)
+      && TREE_STATIC (def_stmt)
+      /* We cannot optimize away aggregate statics, as we would have to
+	 prove that definitions of every field of the aggregate dominate
+	 uses.  */
+      && !AGGREGATE_TYPE_P (TREE_TYPE (def_stmt))
+      /* GCC doesn't normally treat vectors as aggregates; we need to,
+	 though, since a user could use intrinsics to read/write
+	 particular fields of the vector, thereby treating it as an
+	 array.  */
+      && TREE_CODE (TREE_TYPE (def_stmt)) != VECTOR_TYPE
+      && !TREE_ADDRESSABLE (def_stmt)
+      && !TREE_THIS_VOLATILE (def_stmt))
+    {
+      struct rls_decl_info dummy;
+      void **slot;
+
+      dummy.orig_var = def_stmt;
+      slot = htab_find_slot (static_variables, &dummy, INSERT);
+
+      if (*slot == NULL)
+        {
+          /* Found a use or a def of a new declaration.  */
+          struct rls_decl_info *info = XNEW (struct rls_decl_info);
+
+          info->orig_var = def_stmt;
+          info->index = stats.n_statics++;
+          /* Optimistically assume that we can optimize.  */
+          info->optimizable_p = true;
+          info->new_var = NULL_TREE;
+          *slot = (void *) info;
+        }
+
+      /* Enter the statement into DEFUSE_STATEMENTS.  */
+      {
+        struct rls_stmt_info dummy;
+        struct rls_stmt_info *info;
+
+        dummy.stmt = stmt;
+        slot = htab_find_slot (defuse_statements, &dummy, INSERT);
+
+        /* We should never insert the same statement into the
+           hashtable twice.  */
+        gcc_assert (*slot == NULL
+		    || ((struct rls_stmt_info *)(*slot))->stmt == stmt);
+
+	if (*slot != NULL && ((struct rls_stmt_info *)(*slot))->stmt == stmt)
+	  return;
+
+        info = XNEW (struct rls_stmt_info);
+        info->var = def_stmt;
+        info->stmt = stmt;
+        if (dump_file)
+          {
+            fprintf (dump_file, "entering as %s ", use_p ? "use" : "def");
+            print_gimple_stmt (dump_file, stmt, 0, TDF_DETAILS | TDF_VOPS);
+          }
+        info->use_p = use_p;
+        /* We don't know how big to make the bitmap yet.  */
+        info->defined = NULL;
+        *slot = (void *) info;
+      }
+    }
+}
+
+/* Grovel through all the statements in the program, looking for
+   SSA_NAMEs whose SSA_NAME_VAR is a VAR_DECL.  We look at both use and
+   def SSA_NAMEs.  */
+
+static void
+find_static_nonvolatile_declarations (void)
+{
+  basic_block bb;
+
+  FOR_EACH_BB (bb)
+    {
+      gimple_stmt_iterator i;
+
+      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))
+        {
+          tree var;
+          ssa_op_iter iter;
+	  gimple stmt = gsi_stmt (i);
+
+	  /* If there's a call expression in STMT, then previous passes
+	     will have determined if the call transitively defines some
+	     static variable.  However, we need more precise
+	     information--we need to know whether static variables are
+	     live out after the call.
+
+	     Since we'll never see something like:
+
+	       staticvar = foo (bar, baz);
+
+	     in GIMPLE (the result of the call will be assigned to a
+	     normal, non-static local variable which is then assigned to
+	     STATICVAR in a subsequent statement), don't bother finding
+	     new declarations if we see a GIMPLE_CALL.
+	     
+	     In a similar fashion, asm statements that clobber memory
+	     will appear to define static variables.  In general,
+	     however, assuming that asm statements define static
+	     variables would cause us to see that in the following
+	     situation:
+
+	       static int foo = 0;
+
+	       __asm__ (... : "memory");
+	       foo++;
+
+	     foo could be unstaticized because the asm has "defined"
+	     foo.  This is likely false.  (Even if the asm does happen
+	     to define foo--and only foo--that situation would be
+	     sufficiently unusual that not optimizing it seems OK.)  */
+	  if (gimple_code (stmt) != GIMPLE_CALL
+	      && gimple_code (stmt) != GIMPLE_ASM)
+	    FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_VDEF)
+	      {
+		maybe_discover_new_declaration (var, stmt, false);
+	      }
+
+          FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_VUSE)
+            {
+              maybe_discover_new_declaration (var, stmt, true);
+            }
+        }
+    }
+}
+
+
+/* Determining if we have anything to optimize.  */
+
+/* Examine *SLOT (which is a 'struct rls_decl_info *') to see whether
+   the associated variable is optimizable.  If it is, create a new,
+   non-static declaration for the variable; this new variable will be
+   used during a subsequent rewrite of the function.  */
+
+#define NEW_VAR_PREFIX ".unstatic"
+
+static int
+maybe_create_new_variable (void **slot, void *data ATTRIBUTE_UNUSED)
+{
+  struct rls_decl_info *info = (struct rls_decl_info *) *slot;
+  tree id_node = DECL_NAME (info->orig_var);
+  size_t id_len = IDENTIFIER_LENGTH (id_node);
+  size_t name_len = id_len + strlen (NEW_VAR_PREFIX) + 1;
+  char *name;
+
+  /* Don't create a new variable multiple times.  */
+  gcc_assert (!info->new_var);
+
+  /* Tie the new name to the old one to aid debugging dumps.  */
+  name = (char *) alloca (name_len);
+  strcpy (name, IDENTIFIER_POINTER (id_node));
+  strcpy (name + id_len, NEW_VAR_PREFIX);
+  info->new_var = create_tmp_var (TREE_TYPE (info->orig_var), name);
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "new variable ");
+      print_generic_expr (dump_file, info->new_var, 0);
+      fprintf (dump_file, "\n");
+    }
+
+  /* Inform SSA about this new variable.  */
+  create_var_ann (info->new_var);
+  mark_sym_for_renaming (info->new_var);
+  /* We need to make sure we rebuild bits for the original variable,
+     such as virtual operands attached to statements.  */
+  mark_sym_for_renaming (info->orig_var);
+  add_referenced_var (info->new_var);
+
+  /* Always continue scanning.  */
+  return 1;
+}
+
+#undef NEW_VAR_PREFIX
+
+/* Traverse the 'defuse_statements' hash table.  For every use,
+   determine if the associated variable is defined along all paths
+   leading to said use.  Remove the associated variable from
+   'static_variables' if it is not.  */
+
+static int
+check_definedness (void **slot, void *data ATTRIBUTE_UNUSED)
+{
+  struct rls_stmt_info *info = (struct rls_stmt_info *) *slot;
+  struct rls_decl_info dummy;
+  struct rls_decl_info *decl;
+
+  /* We don't need to look at definitions.  Continue scanning.  */
+  if (!info->use_p)
+    return 1;
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "defined bitmap for ");
+      print_gimple_stmt (dump_file, info->stmt, 0, 0);
+      fprintf (dump_file, " : ");
+      dump_sbitmap (dump_file, info->defined);
+    }
+
+  dummy.orig_var = info->var;
+  slot = htab_find_slot (static_variables, &dummy, NO_INSERT);
+
+  gcc_assert (slot);
+
+  decl = (struct rls_decl_info *) *slot;
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "with index %d for var ", decl->index);
+      print_generic_expr (dump_file, decl->orig_var, 0);
+      fprintf (dump_file, "\n\n");
+    }
+
+  if (decl->optimizable_p && !TEST_BIT (info->defined, decl->index))
+    {
+      if (dump_file)
+	{
+	  fprintf (dump_file, "not optimizing ");
+	  print_generic_expr (dump_file, decl->orig_var, 0);
+	  fprintf (dump_file, " due to uncovered use in ");
+	  print_gimple_stmt (dump_file, info->stmt, 0, 0);
+	  fprintf (dump_file, "\n");
+	}
+
+      decl->optimizable_p = false;
+      stats.n_optimizable--;
+    }
+
+  /* Continue scan.  */
+  return 1;
+}
+
+/* Check all statements in 'defuse_statements' to see if all the
+   statements that use a static variable have that variable defined
+   along all paths leading to the statement.  Once that's done, go
+   through and create new, non-static variables for any static variables
+   that can be optimized.  */
+
+static size_t
+determine_optimizable_statics (void)
+{
+  htab_traverse (defuse_statements, check_definedness, NULL);
+
+  htab_traverse (static_variables, maybe_create_new_variable, NULL);
+
+  return stats.n_optimizable;
+}
+
+/* Look at STMT to see if we have uses or defs of a static variable.
+   STMT is passed in DATA.  Definitions of a static variable are found
+   by the presence of a V_MUST_DEF, while uses are found by the presence
+   of a VUSE.  */
+
+static int
+unstaticize_variable (void **slot, void *data)
+{
+  struct rls_decl_info *info = (struct rls_decl_info *) *slot;
+  gimple stmt = (gimple) data;
+  tree vdef;
+  tree vuse;
+  int continue_scan = 1;
+
+  /* Can't do anything to this variable.  */
+  if (!info->optimizable_p)
+    goto done;
+
+  /* Check for virtual definitions first.  */
+  vdef = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_VDEF);
+
+  if (vdef != NULL
+      && ZERO_SSA_OPERANDS (stmt, SSA_OP_DEF)
+      && gimple_code (stmt) == GIMPLE_ASSIGN
+      && TREE_CODE (gimple_assign_lhs (stmt)) == VAR_DECL
+      && gimple_assign_lhs(stmt) == info->orig_var)
+    {
+      /* Make the statement define the new name.  The new name has
+         already been marked for renaming, so no need to do that
+         here.  */
+      gimple_assign_set_lhs (stmt, info->new_var);
+      if (dump_file)
+	{
+	  fprintf (dump_file, "found virtual definition!\n");
+	  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS | TDF_DETAILS);
+	  fprintf (dump_file, "\n");
+	}
+      continue_scan = 0;
+      goto done;
+    }
+
+  /* Check for virtual uses.  */
+  vuse = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_VUSE);
+
+  if (vuse != NULL
+      && gimple_code (stmt) == GIMPLE_ASSIGN
+      && gimple_assign_rhs_code (stmt) == VAR_DECL
+      && gimple_assign_rhs1 (stmt) == info->orig_var)
+    {
+      /* Make the statement use the new name.  */
+      gimple_assign_set_rhs1 (stmt, info->new_var);
+      if (dump_file)
+	{
+	  fprintf (dump_file, "found virtual use!\n");
+	  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS | TDF_DETAILS);
+	  fprintf (dump_file, "\n");
+	}
+      continue_scan = 0;
+      goto done;
+    }
+
+ done:
+  if (!continue_scan)
+    {
+      /* None of the other optimizable static variables can occur
+         in this statement.  Stop the scan.  */
+      update_stmt (stmt);
+
+      if (dump_file)
+	{
+	  fprintf (dump_file, "updated stmt\n");
+	  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS | TDF_DETAILS);
+	}
+    }
+
+  return continue_scan;
+}
+
+/* Determine if we have any static variables we can optimize.  If so,
+   replace any defs or uses of those variables in their defining/using
+   statements.  */
+
+static void
+maybe_remove_static_from_declarations (void)
+{
+  size_t n_optimizable = determine_optimizable_statics ();
+  basic_block bb;
+
+  if (n_optimizable)
+    /* Replace any optimizable variables with new, non-static variables.  */
+    FOR_EACH_BB (bb)
+      {
+        gimple_stmt_iterator gsi;
+
+        for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+          {
+            gimple stmt = gsi_stmt (gsi);
+
+            htab_traverse (static_variables, unstaticize_variable, stmt);
+          }
+      }
+}
+
+/* Callback for htab_traverse to initialize the bitmap for *SLOT, which
+   is a 'struct rls_stmt_info'.  */
+
+static int
+initialize_statement_dataflow (void **slot, void *data ATTRIBUTE_UNUSED)
+{
+  struct rls_stmt_info *info = (struct rls_stmt_info *) *slot;
+
+  gcc_assert (!info->defined);
+
+  if (info->use_p)
+    {
+      info->defined = sbitmap_alloc (stats.n_statics);
+      /* Assume defined along all paths until otherwise informed.  */
+      sbitmap_ones (info->defined);
+    }
+
+  /* Continue traversal.  */
+  return 1;
+}
+
+/* We have N_STATICS static variables to consider.  Go through all the
+   blocks and all the use statements to initialize their bitmaps.  */
+
+static void
+initialize_block_and_statement_dataflow (size_t n_statics)
+{
+  basic_block bb;
+
+  FOR_ALL_BB (bb)
+    {
+      struct rls_block_dataflow_data *data
+	= (struct rls_block_dataflow_data *) bb->aux;
+
+      gcc_assert (data);
+
+      data->defined_in = sbitmap_alloc (n_statics);
+      sbitmap_zero (data->defined_in);
+      data->defined_out = sbitmap_alloc (n_statics);
+      sbitmap_zero (data->defined_out);
+    }
+
+  htab_traverse (defuse_statements, initialize_statement_dataflow, NULL);
+}
+
+/* Apply the individual effects of the stmts in BB to update the
+   dataflow analysis information for BB.  */
+
+static void
+compute_definedness_for_block (basic_block bb)
+{
+  bool changed_p = false;
+  struct rls_block_dataflow_data *data
+	= (struct rls_block_dataflow_data *) bb->aux;
+  gimple_stmt_iterator gsi;
+
+  sbitmap_copy (data->defined_out, data->defined_in);
+
+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+      gimple stmt = gsi_stmt (gsi);
+
+      if (gimple_code (stmt) == GIMPLE_CALL)
+	/* If there's a call expression in STMT, then previous passes
+	   will have determined if the call transitively defines some
+	   static variable.  However, we need more precise
+	   information--we need to know whether static variables are
+	   live out after the call.  In the absence of such information,
+	   simply declare that all static variables are clobbered by the
+	   call.  A better analysis would be interprocedural and compute
+	   the liveness information we require, but for now, we're being
+	   pessimistic.  */
+	sbitmap_zero (data->defined_out);
+      else 
+	{
+	  struct rls_stmt_info dummy;
+	  void **slot;
+
+	  /* See if this statement uses or defines a static variable.  */
+	  dummy.stmt = stmt;
+	  slot = htab_find_slot (defuse_statements, &dummy, NO_INSERT);
+
+	  /* Check for uses.  */
+	  if (slot)
+	    {
+	      struct rls_stmt_info *info = (struct rls_stmt_info *) *slot;
+
+	      if (info->use_p)
+		{
+		  gcc_assert (info->defined);
+
+		  /* Found a statement that uses a function-local static
+		     variable.  Copy the current state of definedness.  */
+		  sbitmap_copy (info->defined, data->defined_out);
+		}
+	      else
+		{
+		  struct rls_decl_info dummy;
+		  struct rls_decl_info *decl;
+
+		  gcc_assert (!info->defined);
+
+		  /* Found a statement that defines a function-local static
+		     variable.  Look up the associated variable's information
+		     and mark it as defined in the block.  */
+		  dummy.orig_var = info->var;
+		  slot = htab_find_slot (static_variables, &dummy, NO_INSERT);
+
+		  gcc_assert (slot);
+
+		  decl = (struct rls_decl_info *) *slot;
+
+		  SET_BIT (data->defined_out, decl->index);
+		  changed_p |= true;
+		}
+	    }
+	}
+    }
+}
+
+/* Solve the dataflow equations:
+
+   DEFINED_IN(b) = intersect DEFINED_OUT(p) for p in preds(b)
+   DEFINED_OUT(b) = VARIABLES_DEFINED (b, DEFINED_IN (b))
+
+   via a simple iterative solver.  VARIABLES_DEFINED is computed by
+   'compute_definedness_for_block'.  */
+
+static void
+compute_definedness (void)
+{
+  basic_block bb;
+  bool changed_p;
+  sbitmap tmp_bitmap = sbitmap_alloc (stats.n_statics);
+
+  /* Compute initial sets.  */
+  FOR_EACH_BB (bb)
+    {
+      compute_definedness_for_block (bb);
+    }
+
+  /* Iterate.  */
+  do {
+    changed_p = false;
+
+    FOR_EACH_BB (bb)
+      {
+        edge e;
+        edge_iterator ei;
+        struct rls_block_dataflow_data *data
+	  = (struct rls_block_dataflow_data *) bb->aux;
+        bool bitmap_changed_p = false;
+
+        sbitmap_ones (tmp_bitmap);
+
+        gcc_assert (data);
+
+        /* We require information about whether a variable was defined
+           over all paths leading to a particular use.  Therefore, we
+           intersect the DEFINED sets of all predecessors.  */
+        FOR_EACH_EDGE (e, ei, bb->preds)
+          {
+            struct rls_block_dataflow_data *pred_data
+	      = (struct rls_block_dataflow_data *) e->src->aux;
+
+            gcc_assert (pred_data);
+
+            sbitmap_a_and_b (tmp_bitmap, tmp_bitmap, pred_data->defined_out);
+          }
+
+        bitmap_changed_p = !sbitmap_equal (tmp_bitmap, data->defined_in);
+
+        if (bitmap_changed_p)
+          {
+            sbitmap_copy (data->defined_in, tmp_bitmap);
+            compute_definedness_for_block (bb);
+          }
+
+        changed_p |= bitmap_changed_p;
+      }
+  } while (changed_p);
+
+  sbitmap_free (tmp_bitmap);
+}
+
+static unsigned int
+execute_rls (void)
+{
+  rls_init ();
+
+  find_static_nonvolatile_declarations ();
+
+  /* Can we optimize anything?  */
+  if (stats.n_statics != 0)
+    {
+      stats.n_optimizable = stats.n_statics;
+
+      if (dump_file)
+        fprintf (dump_file, "found %d static variables to consider\n",
+                 stats.n_statics);
+
+      initialize_block_and_statement_dataflow (stats.n_statics);
+
+      compute_definedness ();
+
+      maybe_remove_static_from_declarations ();
+
+      if (dump_file)
+        fprintf (dump_file, "removed %d static variables\n",
+                 stats.n_optimizable);
+    }
+
+  rls_done ();
+
+  if (stats.n_optimizable > 0)
+    return TODO_rebuild_alias | TODO_update_ssa;
+  else
+    return 0;
+}
+
+static bool
+gate_rls (void)
+{
+  return (flag_remove_local_statics != 0
+          && !cfun->calls_setjmp
+          && !cgraph_node (current_function_decl)->ever_was_nested);
+}
+
+struct gimple_opt_pass pass_remove_local_statics =
+{
+  {
+    GIMPLE_PASS,
+    "remlocstatic",               /* name */
+    gate_rls,                     /* gate */
+    execute_rls,                  /* execute */
+    NULL,                         /* sub */
+    NULL,                         /* next */
+    0,                            /* static_pass_number */
+    TV_TREE_RLS,                  /* tv_id */
+    PROP_cfg | PROP_ssa,          /* properties_required */
+    0,                            /* properties_provided */
+    0,                            /* properties_destroyed */
+    0,                            /* todo_flags_start */
+    TODO_dump_func | TODO_verify_ssa | TODO_verify_stmts
+    | TODO_rebuild_alias | TODO_update_ssa /* todo_flags_finish */
+  }
+};
diff --git a/gcc/tree-ssa-sink.c b/gcc/tree-ssa-sink.c
index a190a22f5..e0d9d7bd3 100644
--- a/gcc/tree-ssa-sink.c
+++ b/gcc/tree-ssa-sink.c
@@ -449,6 +449,47 @@ sink_code_in_bb (basic_block bb)
 	  last = false;
 	  continue;
 	}      
+
+      /* We cannot move statements that contain references to block-scope
+	 variables out of that block, as this may lead to incorrect aliasing
+	 when we lay out the stack frame in cfgexpand.c.
+	 In lieu of more sophisticated analysis, be very conservative here
+	 and prohibit moving any statement that references memory out of a
+	 block with variables.  */
+      if (gimple_references_memory_p (stmt))
+	{
+	  tree fromblock = gimple_block (stmt);
+	  while (fromblock
+		 && fromblock != current_function_decl
+		 && !BLOCK_VARS (fromblock))
+	    fromblock = BLOCK_SUPERCONTEXT (fromblock);
+	  if (fromblock && fromblock != current_function_decl)
+	    {
+	      gimple tostmt;
+	      tree toblock;
+
+	      if (gsi_end_p (togsi))
+		tostmt = gimple_seq_last_stmt (gsi_seq (togsi));
+	      else
+		tostmt = gsi_stmt (togsi);
+	      if (tostmt)
+		toblock = gimple_block (tostmt);
+	      else
+		toblock = NULL;
+	      while (toblock
+		     && toblock != current_function_decl
+		     && toblock != fromblock)
+		toblock = BLOCK_SUPERCONTEXT (toblock);
+	      if (!toblock || toblock != fromblock)
+		{
+		  if (!gsi_end_p (gsi))
+		    gsi_prev (&gsi);
+		  last = false;
+		  continue;
+		}
+	    }
+	}
+
       if (dump_file)
 	{
 	  fprintf (dump_file, "Sinking ");
diff --git a/gcc/tree-ssa.c b/gcc/tree-ssa.c
index 9d8f99deb..17d368288 100644
--- a/gcc/tree-ssa.c
+++ b/gcc/tree-ssa.c
@@ -1271,6 +1271,18 @@ tree_ssa_useless_type_conversion (tree expr)
   return false;
 }
 
+/* Strip conversions from EXP according to
+   tree_ssa_useless_type_conversion and return the resulting
+   expression.  */
+
+tree
+tree_ssa_strip_useless_type_conversions (tree exp)
+{
+  while (tree_ssa_useless_type_conversion (exp))
+    exp = TREE_OPERAND (exp, 0);
+  return exp;
+}
+
 
 /* Internal helper for walk_use_def_chains.  VAR, FN and DATA are as
    described in walk_use_def_chains.
diff --git a/gcc/tree-vect-analyze.c b/gcc/tree-vect-analyze.c
index 8174851b7..7b19052db 100644
--- a/gcc/tree-vect-analyze.c
+++ b/gcc/tree-vect-analyze.c
@@ -1459,7 +1459,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)
     }
 
   base = build_fold_indirect_ref (base_addr);
-  alignment = ssize_int (TYPE_ALIGN (vectype)/BITS_PER_UNIT);
+  alignment = ssize_int (targetm.vectorize.vector_min_alignment (vectype));
 
   if ((aligned_to && tree_int_cst_compare (aligned_to, alignment) < 0)
       || !misalign)
@@ -1510,7 +1510,8 @@ vect_compute_data_ref_alignment (struct data_reference *dr)
   /* At this point we assume that the base is aligned.  */
   gcc_assert (base_aligned
 	      || (TREE_CODE (base) == VAR_DECL 
-		  && DECL_ALIGN (base) >= TYPE_ALIGN (vectype)));
+		  && (DECL_ALIGN (base)
+		      >= targetm.vectorize.vector_min_alignment (vectype))));
 
   /* Modulo alignment.  */
   misalign = size_binop (TRUNC_MOD_EXPR, misalign, alignment);
diff --git a/gcc/tree-vect-transform.c b/gcc/tree-vect-transform.c
index 294af740d..412f8e208 100644
--- a/gcc/tree-vect-transform.c
+++ b/gcc/tree-vect-transform.c
@@ -5444,7 +5444,21 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,
 	       vect_permute_store_chain().  */
 	    vec_oprnd = VEC_index (tree, result_chain, i);
 
-	  data_ref = build_fold_indirect_ref (dataref_ptr);
+	  if (alignment_support_scheme == dr_aligned
+	      && !targetm.vectorize.always_misalign(vectype))
+	    {
+	      data_ref = build_fold_indirect_ref (dataref_ptr);
+	    }
+	  else
+	    {
+	      /* TODO: Record actual alignment in always_misalign case.  */
+	      int mis = DR_MISALIGNMENT (first_dr);
+	      tree tmis;
+	      tmis = (mis == -1 ? size_zero_node : size_int (mis));
+	      tmis = size_binop (MULT_EXPR, tmis, size_int(BITS_PER_UNIT));
+	      data_ref =
+		build2 (MISALIGNED_INDIRECT_REF, vectype, dataref_ptr, tmis);
+	    }
 
 	  /* Arguments are ready. Create the new vector stmt.  */
 	  new_stmt = gimple_build_assign (data_ref, vec_oprnd);
@@ -6623,10 +6637,15 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,
 	    {
 	    case dr_aligned:
 	      gcc_assert (aligned_access_p (first_dr));
-	      data_ref = build_fold_indirect_ref (dataref_ptr);
-	      break;
+	      if (!targetm.vectorize.always_misalign(vectype))
+		{
+		  data_ref = build_fold_indirect_ref (dataref_ptr);
+		  break;
+		}
+	      /* Fall through... */
 	    case dr_unaligned_supported:
 	      {
+		/* TODO: Record actual alignment in always_misalign case.  */
 		int mis = DR_MISALIGNMENT (first_dr);
 		tree tmis = (mis == -1 ? size_zero_node : size_int (mis));
 
@@ -7597,7 +7616,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)
   gimple dr_stmt = DR_STMT (dr);
   stmt_vec_info stmt_info = vinfo_for_stmt (dr_stmt);
   tree vectype = STMT_VINFO_VECTYPE (stmt_info);
-  int vectype_align = TYPE_ALIGN (vectype) / BITS_PER_UNIT;
+  int vectype_align = targetm.vectorize.vector_min_alignment (vectype);
   tree niters_type = TREE_TYPE (loop_niters);
   int step = 1;
   int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));
diff --git a/gcc/tree-vectorizer.c b/gcc/tree-vectorizer.c
index 2c5d9cca1..37723ff93 100644
--- a/gcc/tree-vectorizer.c
+++ b/gcc/tree-vectorizer.c
@@ -2868,11 +2868,13 @@ increase_alignment (void)
        vnode = vnode->next_needed)
     {
       tree vectype, decl = vnode->decl;
+      tree t;
       unsigned int alignment;
 
-      if (TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE)
+      t = TREE_TYPE(decl);
+      if (TREE_CODE (t) != ARRAY_TYPE)
 	continue;
-      vectype = get_vectype_for_scalar_type (TREE_TYPE (TREE_TYPE (decl)));
+      vectype = get_vectype_for_scalar_type (strip_array_types (t));
       if (!vectype)
 	continue;
       alignment = TYPE_ALIGN (vectype);
@@ -2887,6 +2889,7 @@ increase_alignment (void)
 	    { 
 	      fprintf (dump_file, "Increasing alignment of decl: ");
 	      print_generic_expr (dump_file, decl, TDF_SLIM);
+	      fprintf (dump_file, "\n");
 	    }
 	}
     }
diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
index ed31a9892..5d70d87ae 100644
--- a/gcc/tree-vrp.c
+++ b/gcc/tree-vrp.c
@@ -775,6 +775,27 @@ range_is_null (value_range_t *vr)
 	 && integer_zerop (vr->max);
 }
 
+/* Return true if max and min of VR are INTEGER_CST.  It's not necessary
+   a singleton.  */
+
+static inline bool
+range_int_cst_p (value_range_t *vr)
+{
+  return (vr->type == VR_RANGE
+	  && TREE_CODE (vr->max) == INTEGER_CST
+	  && TREE_CODE (vr->min) == INTEGER_CST
+	  && !TREE_OVERFLOW (vr->max)
+	  && !TREE_OVERFLOW (vr->min));
+}
+
+/* Return true if VR is a INTEGER_CST singleton.  */
+
+static inline bool
+range_int_cst_singleton_p (value_range_t *vr)
+{
+  return (range_int_cst_p (vr)
+	  && tree_int_cst_equal (vr->min, vr->max));
+}
 
 /* Return true if value range VR involves at least one symbol.  */
 
@@ -2521,19 +2542,20 @@ extract_range_from_binary_expr (value_range_t *vr,
     }
   else if (code == BIT_AND_EXPR)
     {
-      if (vr0.type == VR_RANGE
-	  && vr0.min == vr0.max
-	  && TREE_CODE (vr0.max) == INTEGER_CST
-	  && !TREE_OVERFLOW (vr0.max)
-	  && tree_int_cst_sgn (vr0.max) >= 0)
+      bool vr0_int_cst_singleton_p, vr1_int_cst_singleton_p;
+
+      vr0_int_cst_singleton_p = range_int_cst_singleton_p (&vr0);
+      vr1_int_cst_singleton_p = range_int_cst_singleton_p (&vr1);
+
+      if (vr0_int_cst_singleton_p && vr1_int_cst_singleton_p)
+	min = max = int_const_binop (code, vr0.max, vr1.max, 0);
+      else if (vr0_int_cst_singleton_p
+	       && tree_int_cst_sgn (vr0.max) >= 0)
 	{
 	  min = build_int_cst (expr_type, 0);
 	  max = vr0.max;
 	}
-      else if (vr1.type == VR_RANGE
-	       && vr1.min == vr1.max
-	       && TREE_CODE (vr1.max) == INTEGER_CST
-	       && !TREE_OVERFLOW (vr1.max)
+      else if (vr1_int_cst_singleton_p
 	       && tree_int_cst_sgn (vr1.max) >= 0)
 	{
 	  type = VR_RANGE;
@@ -2548,12 +2570,8 @@ extract_range_from_binary_expr (value_range_t *vr,
     }
   else if (code == BIT_IOR_EXPR)
     {
-      if (vr0.type == VR_RANGE
-          && vr1.type == VR_RANGE
-	  && TREE_CODE (vr0.min) == INTEGER_CST
-	  && TREE_CODE (vr1.min) == INTEGER_CST
-	  && TREE_CODE (vr0.max) == INTEGER_CST
-	  && TREE_CODE (vr1.max) == INTEGER_CST
+      if (range_int_cst_p (&vr0)
+	  && range_int_cst_p (&vr1)
 	  && tree_int_cst_sgn (vr0.min) >= 0
 	  && tree_int_cst_sgn (vr1.min) >= 0)
 	{
diff --git a/gcc/tree.c b/gcc/tree.c
index af5f0a104..3d0193805 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "params.h"
 #include "pointer-set.h"
 #include "fixed-value.h"
+#include "intl.h"
 
 /* Tree code classes.  */
 
@@ -3572,9 +3573,9 @@ expanded_location
 expand_location (source_location loc)
 {
   expanded_location xloc;
-  if (loc == 0)
+  if (loc <= BUILTINS_LOCATION)
     {
-      xloc.file = NULL;
+      xloc.file = loc == UNKNOWN_LOCATION ? NULL : _("<built-in>");
       xloc.line = 0;
       xloc.column = 0;
       xloc.sysp = 0;
@@ -4066,6 +4067,7 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,
 		      bool *no_add_attrs)
 {
   tree node = *pnode;
+  bool is_dllimport;
 
   /* These attributes may apply to structure and union types being created,
      but otherwise should pass to the declaration involved.  */
@@ -4113,9 +4115,11 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,
       return NULL_TREE;
     }
 
+  is_dllimport = is_attribute_p ("dllimport", name);
+
   /* Report error on dllimport ambiguities seen now before they cause
      any damage.  */
-  else if (is_attribute_p ("dllimport", name))
+  if (is_dllimport)
     {
       /* Honor any target-specific overrides. */ 
       if (!targetm.valid_dllimport_attribute_p (node))
@@ -4157,6 +4161,9 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,
       if (*no_add_attrs == false)
         DECL_DLLIMPORT_P (node) = 1;
     }
+  else if (DECL_DECLARED_INLINE_P (node))
+    /* An exported function, even if inline, must be emitted.  */
+    DECL_EXTERNAL (node) = 0;
 
   /*  Report error if symbol is not accessible at global scope.  */
   if (!TREE_PUBLIC (node)
@@ -7994,6 +8001,19 @@ initializer_zerop (const_tree init)
 	return true;
       }
 
+    case STRING_CST:
+      {
+	int i;
+
+	/* We need to loop through all elements to handle cases like
+	   "\0" and "\0foobar".  */
+	for (i = 0; i < TREE_STRING_LENGTH (init); ++i)
+	  if (TREE_STRING_POINTER (init)[i] != '\0')
+	    return false;
+
+	return true;
+      }
+
     default:
       return false;
     }
@@ -9098,6 +9118,79 @@ tree_nonartificial_location (tree exp)
     return EXPR_LOCATION (exp);
 }
 
+/* Return true iff conversion in EXP generates no instruction.  Mark
+   it inline so that we fully inline into the stripping functions even
+   though we have two uses of this function.  */
+
+static inline bool
+tree_nop_conversion (const_tree exp)
+{
+  tree outer_type, inner_type;
+
+  if (!CONVERT_EXPR_P (exp)
+      && TREE_CODE (exp) != NON_LVALUE_EXPR)
+    return false;
+  if (TREE_OPERAND (exp, 0) == error_mark_node)
+    return false;
+
+  outer_type = TREE_TYPE (exp);
+  inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));
+
+  /* Use precision rather then machine mode when we can, which gives
+     the correct answer even for submode (bit-field) types.  */
+  if ((INTEGRAL_TYPE_P (outer_type)
+       || POINTER_TYPE_P (outer_type)
+       || TREE_CODE (outer_type) == OFFSET_TYPE)
+      && (INTEGRAL_TYPE_P (inner_type)
+	  || POINTER_TYPE_P (inner_type)
+	  || TREE_CODE (inner_type) == OFFSET_TYPE))
+    return TYPE_PRECISION (outer_type) == TYPE_PRECISION (inner_type);
+
+  /* Otherwise fall back on comparing machine modes (e.g. for
+     aggregate types, floats).  */
+  return TYPE_MODE (outer_type) == TYPE_MODE (inner_type);
+}
+
+/* Return true iff conversion in EXP generates no instruction.  Don't
+   consider conversions changing the signedness.  */
+
+static bool
+tree_sign_nop_conversion (const_tree exp)
+{
+  tree outer_type, inner_type;
+
+  if (!tree_nop_conversion (exp))
+    return false;
+
+  outer_type = TREE_TYPE (exp);
+  inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));
+
+  return (TYPE_UNSIGNED (outer_type) == TYPE_UNSIGNED (inner_type)
+	  && POINTER_TYPE_P (outer_type) == POINTER_TYPE_P (inner_type));
+}
+
+/* Strip conversions from EXP according to tree_nop_conversion and
+   return the resulting expression.  */
+
+tree
+tree_strip_nop_conversions (tree exp)
+{
+  while (tree_nop_conversion (exp))
+    exp = TREE_OPERAND (exp, 0);
+  return exp;
+}
+
+/* Strip conversions from EXP according to tree_sign_nop_conversion
+   and return the resulting expression.  */
+
+tree
+tree_strip_sign_nop_conversions (tree exp)
+{
+  while (tree_sign_nop_conversion (exp))
+    exp = TREE_OPERAND (exp, 0);
+  return exp;
+}
+
 
 /* These are the hash table functions for the hash table of OPTIMIZATION_NODEq
    nodes.  */
diff --git a/gcc/tree.h b/gcc/tree.h
index e7f15e16b..b0059da80 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -381,8 +381,10 @@ struct tree_base GTY(())
   unsigned lang_flag_5 : 1;
   unsigned lang_flag_6 : 1;
   unsigned visited : 1;
+  unsigned packed_flag : 1;
+  unsigned user_align : 1;
 
-  unsigned spare : 23;
+  unsigned spare : 21;
 
   union tree_ann_d *ann;
 };
@@ -974,30 +976,17 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,
   case NOP_EXPR:						\
   case CONVERT_EXPR
 
-/* Given an expression as a tree, strip any NON_LVALUE_EXPRs and NOP_EXPRs
-   that don't change the machine mode.  */
+/* Given an expression as a tree, strip any conversion that generates
+   no instruction.  Accepts both tree and const_tree arguments since
+   we are not modifying the tree itself.  */
 
-#define STRIP_NOPS(EXP)						\
-  while ((CONVERT_EXPR_P (EXP)					\
-	  || TREE_CODE (EXP) == NON_LVALUE_EXPR)		\
-	 && TREE_OPERAND (EXP, 0) != error_mark_node		\
-	 && (TYPE_MODE (TREE_TYPE (EXP))			\
-	     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0))))) \
-    (EXP) = TREE_OPERAND (EXP, 0)
+#define STRIP_NOPS(EXP) \
+  (EXP) = tree_strip_nop_conversions (CONST_CAST_TREE (EXP))
 
 /* Like STRIP_NOPS, but don't let the signedness change either.  */
 
 #define STRIP_SIGN_NOPS(EXP) \
-  while ((CONVERT_EXPR_P (EXP)					\
-	  || TREE_CODE (EXP) == NON_LVALUE_EXPR)		\
-	 && TREE_OPERAND (EXP, 0) != error_mark_node		\
-	 && (TYPE_MODE (TREE_TYPE (EXP))			\
-	     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0))))	\
-	 && (TYPE_UNSIGNED (TREE_TYPE (EXP))			\
-	     == TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (EXP, 0)))) \
-	 && (POINTER_TYPE_P (TREE_TYPE (EXP))			\
-	     == POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (EXP, 0))))) \
-    (EXP) = TREE_OPERAND (EXP, 0)
+  (EXP) = tree_strip_sign_nop_conversions (CONST_CAST_TREE (EXP))
 
 /* Like STRIP_NOPS, but don't alter the TREE_TYPE either.  */
 
@@ -1012,9 +1001,8 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,
 /* Remove unnecessary type conversions according to
    tree_ssa_useless_type_conversion.  */
 
-#define STRIP_USELESS_TYPE_CONVERSION(EXP)				\
-      while (tree_ssa_useless_type_conversion (EXP))			\
-	EXP = TREE_OPERAND (EXP, 0)
+#define STRIP_USELESS_TYPE_CONVERSION(EXP) \
+  (EXP) = tree_ssa_strip_useless_type_conversions (EXP)
 
 /* Nonzero if TYPE represents an integral type.  Note that we do not
    include COMPLEX types here.  Keep these checks in ascending code
@@ -2140,7 +2128,7 @@ extern enum machine_mode vector_type_mode (const_tree);
 
 /* 1 if the alignment for this type was requested by "aligned" attribute,
    0 if it is the default for this type.  */
-#define TYPE_USER_ALIGN(NODE) (TYPE_CHECK (NODE)->type.user_align)
+#define TYPE_USER_ALIGN(NODE) (TYPE_CHECK (NODE)->common.base.user_align)
 
 /* The alignment for NODE, in bytes.  */
 #define TYPE_ALIGN_UNIT(NODE) (TYPE_ALIGN (NODE) / BITS_PER_UNIT)
@@ -2246,7 +2234,7 @@ extern enum machine_mode vector_type_mode (const_tree);
 
 /* Indicated that objects of this type should be laid out in as
    compact a way as possible.  */
-#define TYPE_PACKED(NODE) (TYPE_CHECK (NODE)->type.packed_flag)
+#define TYPE_PACKED(NODE) (TYPE_CHECK (NODE)->common.base.packed_flag)
 
 /* Used by type_contains_placeholder_p to avoid recomputation.
    Values are: 0 (unknown), 1 (false), 2 (true).  Never access
@@ -2265,17 +2253,16 @@ struct tree_type GTY(())
   tree attributes;
   unsigned int uid;
 
-  unsigned int precision : 9;
-  ENUM_BITFIELD(machine_mode) mode : 7;
-
-  unsigned string_flag : 1;
+  unsigned int precision : 10;
   unsigned no_force_blk_flag : 1;
   unsigned needs_constructing_flag : 1;
   unsigned transparent_union_flag : 1;
-  unsigned packed_flag : 1;
   unsigned restrict_flag : 1;
   unsigned contains_placeholder_bits : 2;
 
+  ENUM_BITFIELD(machine_mode) mode : 8;
+
+  unsigned string_flag : 1;
   unsigned lang_flag_0 : 1;
   unsigned lang_flag_1 : 1;
   unsigned lang_flag_2 : 1;
@@ -2283,7 +2270,6 @@ struct tree_type GTY(())
   unsigned lang_flag_4 : 1;
   unsigned lang_flag_5 : 1;
   unsigned lang_flag_6 : 1;
-  unsigned user_align : 1;
 
   unsigned int align;
   alias_set_type alias_set;
@@ -2584,7 +2570,7 @@ struct tree_memory_partition_tag GTY(())
 #define DECL_ALIGN_UNIT(NODE) (DECL_ALIGN (NODE) / BITS_PER_UNIT)
 /* Set if the alignment of this DECL has been set by the user, for
    example with an 'aligned' attribute.  */
-#define DECL_USER_ALIGN(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.user_align)
+#define DECL_USER_ALIGN(NODE) (DECL_COMMON_CHECK (NODE)->common.base.user_align)
 /* Holds the machine mode corresponding to the declaration of a variable or
    field.  Always equal to TYPE_MODE (TREE_TYPE (decl)) except for a
    FIELD_DECL.  */
@@ -2621,7 +2607,7 @@ struct tree_memory_partition_tag GTY(())
    example, for a FUNCTION_DECL, DECL_SAVED_TREE may be non-NULL and
    DECL_EXTERNAL may be true simultaneously; that can be the case for
    a C99 "extern inline" function.  */
-#define DECL_EXTERNAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.decl_flag_2)
+#define DECL_EXTERNAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.decl_flag_1)
 
 /* Nonzero in a ..._DECL means this variable is ref'd from a nested function.
    For VAR_DECL nodes, PARM_DECL nodes, and FUNCTION_DECL nodes.
@@ -2696,7 +2682,6 @@ struct tree_decl_common GTY(())
   unsigned ignored_flag : 1;
   unsigned abstract_flag : 1;
   unsigned artificial_flag : 1;
-  unsigned user_align : 1;
   unsigned preserve_flag: 1;
   unsigned debug_expr_is_from : 1;
 
@@ -2712,22 +2697,20 @@ struct tree_decl_common GTY(())
   /* In LABEL_DECL, this is DECL_ERROR_ISSUED.
      In VAR_DECL and PARM_DECL, this is DECL_REGISTER.  */
   unsigned decl_flag_0 : 1;
-  /* In FIELD_DECL, this is DECL_PACKED.  */
-  unsigned decl_flag_1 : 1;
   /* In FIELD_DECL, this is DECL_BIT_FIELD
      In VAR_DECL and FUNCTION_DECL, this is DECL_EXTERNAL.
-     In TYPE_DECL, this is TYPE_DECL_SUPRESS_DEBUG.  */
-  unsigned decl_flag_2 : 1;
+     In TYPE_DECL, this is TYPE_DECL_SUPPRESS_DEBUG.  */
+  unsigned decl_flag_1 : 1;
   /* In FIELD_DECL, this is DECL_NONADDRESSABLE_P
-     In VAR_DECL and PARM_DECL, this is DECL_HAS_VALUE_EXPR.  */
-  unsigned decl_flag_3 : 1;
+     In VAR_DECL and PARM_DECL, this is DECL_HAS_VALUE_EXPR_P.  */
+  unsigned decl_flag_2 : 1;
   /* Logically, these two would go in a theoretical base shared by var and
      parm decl. */
   unsigned gimple_reg_flag : 1;
   /* In a DECL with pointer type, set if no TBAA should be done.  */
   unsigned no_tbaa_flag : 1;
   /* Padding so that 'align' can be on a 32-bit boundary.  */
-  unsigned decl_common_unused : 2;
+  unsigned decl_common_unused : 4;
 
   unsigned int align : 24;
   /* DECL_OFFSET_ALIGN, used only for FIELD_DECLs.  */
@@ -2751,7 +2734,7 @@ extern void decl_value_expr_insert (tree, tree);
    decl itself.  This should only be used for debugging; once this field has
    been set, the decl itself may not legitimately appear in the function.  */
 #define DECL_HAS_VALUE_EXPR_P(NODE) \
-  (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)->decl_common.decl_flag_3)
+  (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)->decl_common.decl_flag_2)
 #define DECL_VALUE_EXPR(NODE) \
   (decl_value_expr_lookup (DECL_WRTL_CHECK (NODE)))
 #define SET_DECL_VALUE_EXPR(NODE, VAL)			\
@@ -2830,11 +2813,11 @@ struct tree_decl_with_rtl GTY(())
 #define DECL_FCONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.fcontext)
 
 /* In a FIELD_DECL, indicates this field should be bit-packed.  */
-#define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_1)
+#define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->common.base.packed_flag)
 
 /* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed
    specially.  */
-#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_2)
+#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_1)
 
 /* Used in a FIELD_DECL to indicate that we cannot form the address of
    this component.  This makes it possible for Type-Based Alias Analysis
@@ -2852,7 +2835,7 @@ struct tree_decl_with_rtl GTY(())
    accesses to s.i must not be given the alias set of the type of 'i'
    (int) but instead directly that of the type of 's' (struct S).  */
 #define DECL_NONADDRESSABLE_P(NODE) \
-  (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_3)
+  (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_2)
 
 struct tree_field_decl GTY(())
 {
@@ -3337,7 +3320,7 @@ struct tree_function_decl GTY(())
    into stabs.  Instead it will generate cross reference ('x') of names.
    This uses the same flag as DECL_EXTERNAL.  */
 #define TYPE_DECL_SUPPRESS_DEBUG(NODE) \
-  (TYPE_DECL_CHECK (NODE)->decl_common.decl_flag_2)
+  (TYPE_DECL_CHECK (NODE)->decl_common.decl_flag_1)
 
 /* Getter of the imported declaration associated to the
    IMPORTED_DECL node.  */
@@ -4702,6 +4685,8 @@ extern bool stdarg_p (tree);
 extern bool prototype_p (tree);
 extern int function_args_count (tree);
 extern bool auto_var_in_fn_p (const_tree, const_tree);
+extern tree tree_strip_nop_conversions (tree);
+extern tree tree_strip_sign_nop_conversions (tree);
 
 /* In gimplify.c */
 extern tree unshare_expr (tree);
diff --git a/gcc/tsystem.h b/gcc/tsystem.h
index 60df5242c..d97b669e5 100644
--- a/gcc/tsystem.h
+++ b/gcc/tsystem.h
@@ -89,12 +89,14 @@ extern void *memset (void *, int, size_t);
 /* All systems have this header.  */
 #include <sys/types.h>
 
-/* All systems have this header.  */
+#ifndef __MINGW32CE__
+/* All systems except Windows CE have this header.  */
 #include <errno.h>
 
 #ifndef errno
 extern int errno;
 #endif
+#endif
 
 /* GCC (fixproto) guarantees these system headers exist.  */
 #include <string.h>
diff --git a/gcc/unwind-dw2.c b/gcc/unwind-dw2.c
index f5c2126ed..462cb370f 100644
--- a/gcc/unwind-dw2.c
+++ b/gcc/unwind-dw2.c
@@ -1416,16 +1416,12 @@ uw_advance_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)
 /* Fill in CONTEXT for top-of-stack.  The only valid registers at this
    level will be the return address and the CFA.  */
 
-#define uw_init_context(CONTEXT)					   \
-  do									   \
-    {									   \
-      /* Do any necessary initialization to access arbitrary stack frames. \
-	 On the SPARC, this means flushing the register windows.  */	   \
-      __builtin_unwind_init ();						   \
-      uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),		   \
-			 __builtin_return_address (0));			   \
-    }									   \
-  while (0)
+#define uw_init_context(CONTEXT)					\
+  /* Do any necessary initialization to access arbitrary stack frames.	\
+     On the SPARC, this means flushing the register windows.  */	\
+  (__builtin_unwind_init (),						\
+   uw_init_context_1 ((CONTEXT), __builtin_dwarf_cfa (),		\
+		      __builtin_return_address (0)))
 
 static inline void
 init_dwarf_reg_size_table (void)
@@ -1433,7 +1429,7 @@ init_dwarf_reg_size_table (void)
   __builtin_init_dwarf_reg_size_table (dwarf_reg_size_table);
 }
 
-static void
+static _Unwind_Reason_Code
 uw_init_context_1 (struct _Unwind_Context *context,
 		   void *outer_cfa, void *outer_ra)
 {
@@ -1447,7 +1443,8 @@ uw_init_context_1 (struct _Unwind_Context *context,
   context->flags = EXTENDED_CONTEXT_BIT;
 
   code = uw_frame_state_for (context, &fs);
-  gcc_assert (code == _URC_NO_REASON);
+  if (code != _URC_NO_REASON)
+    return code;
 
 #if __GTHREADS
   {
@@ -1473,20 +1470,36 @@ uw_init_context_1 (struct _Unwind_Context *context,
      initialization context, then we can't see it in the given
      call frame data.  So have the initialization context tell us.  */
   context->ra = __builtin_extract_return_addr (outer_ra);
+
+  return _URC_NO_REASON;
 }
 
+static void _Unwind_DebugHook (void *, void *)
+  __attribute__ ((__noinline__, __used__));
+
+/* This function is called during unwinding.  It is intended as a hook
+   for a debugger to intercept exceptions.  CFA is the CFA of the
+   target frame.  HANDLER is the PC to which control will be
+   transferred.  */
+static void
+_Unwind_DebugHook (void *cfa __attribute__ ((__unused__)),
+		   void *handler __attribute__ ((__unused__)))
+{
+  asm ("");
+}
 
 /* Install TARGET into CURRENT so that we can return to it.  This is a
    macro because __builtin_eh_return must be invoked in the context of
    our caller.  */
 
-#define uw_install_context(CURRENT, TARGET)				 \
-  do									 \
-    {									 \
-      long offset = uw_install_context_1 ((CURRENT), (TARGET));		 \
-      void *handler = __builtin_frob_return_addr ((TARGET)->ra);	 \
-      __builtin_eh_return (offset, handler);				 \
-    }									 \
+#define uw_install_context(CURRENT, TARGET)				\
+  do									\
+    {									\
+      long offset = uw_install_context_1 ((CURRENT), (TARGET));		\
+      void *handler = __builtin_frob_return_addr ((TARGET)->ra);	\
+      _Unwind_DebugHook ((TARGET)->cfa, handler);			\
+      __builtin_eh_return (offset, handler);				\
+    }									\
   while (0)
 
 static long
diff --git a/gcc/unwind-sjlj.c b/gcc/unwind-sjlj.c
index c71e79858..4ef81a673 100644
--- a/gcc/unwind-sjlj.c
+++ b/gcc/unwind-sjlj.c
@@ -292,10 +292,11 @@ uw_advance_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)
   uw_update_context (context, fs);
 }
 
-static inline void
+static inline _Unwind_Reason_Code
 uw_init_context (struct _Unwind_Context *context)
 {
   context->fc = _Unwind_SjLj_GetContext ();
+  return _URC_NO_REASON;
 }
 
 static void __attribute__((noreturn))
diff --git a/gcc/unwind.inc b/gcc/unwind.inc
index 5e2ec29c7..562f6b123 100644
--- a/gcc/unwind.inc
+++ b/gcc/unwind.inc
@@ -85,7 +85,8 @@ _Unwind_RaiseException(struct _Unwind_Exception *exc)
   _Unwind_Reason_Code code;
 
   /* Set up this_context to describe the current stack frame.  */
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   /* Phase 1: Search.  Unwind the stack, calling the personality routine
@@ -198,7 +199,8 @@ _Unwind_ForcedUnwind (struct _Unwind_Exception *exc,
   struct _Unwind_Context this_context, cur_context;
   _Unwind_Reason_Code code;
 
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   exc->private_1 = (_Unwind_Ptr) stop;
@@ -221,7 +223,8 @@ _Unwind_Resume (struct _Unwind_Exception *exc)
   struct _Unwind_Context this_context, cur_context;
   _Unwind_Reason_Code code;
 
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   /* Choose between continuing to process _Unwind_RaiseException
@@ -251,7 +254,8 @@ _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exc)
   if (exc->private_1 == 0)
     return _Unwind_RaiseException (exc);
 
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);
@@ -280,7 +284,9 @@ _Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument)
   struct _Unwind_Context context;
   _Unwind_Reason_Code code;
 
-  uw_init_context (&context);
+  code = uw_init_context (&context);
+  if (code != _URC_NO_REASON)
+    return _URC_FATAL_PHASE1_ERROR;
 
   while (1)
     {
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 9385b4770..179dba49d 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -1031,8 +1031,11 @@ set_user_assembler_name (tree decl, const char *name)
    Prefixes such as % are optional.  */
 
 int
-decode_reg_name (const char *asmspec)
+decode_reg_name_and_count (const char *asmspec, int *pnregs)
 {
+  /* Presume just one register is clobbered.  */
+  *pnregs = 1;
+
   if (asmspec != 0)
     {
       int i;
@@ -1058,6 +1061,25 @@ decode_reg_name (const char *asmspec)
 	    && ! strcmp (asmspec, strip_reg_name (reg_names[i])))
 	  return i;
 
+#ifdef OVERLAPPING_REGISTER_NAMES
+      {
+	static const struct
+	{
+	  const char *const name;
+	  const int number;
+	  const int nregs;
+	} table[] = OVERLAPPING_REGISTER_NAMES;
+
+	for (i = 0; i < (int) ARRAY_SIZE (table); i++)
+	  if (table[i].name[0]
+	      && ! strcmp (asmspec, table[i].name))
+	    {
+	      *pnregs = table[i].nregs;
+	      return table[i].number;
+	    }
+      }
+#endif /* OVERLAPPING_REGISTER_NAMES */
+
 #ifdef ADDITIONAL_REGISTER_NAMES
       {
 	static const struct { const char *const name; const int number; } table[]
@@ -1081,6 +1103,14 @@ decode_reg_name (const char *asmspec)
 
   return -1;
 }
+
+int
+decode_reg_name (const char *name)
+{
+  int count;
+  return decode_reg_name_and_count (name, &count);
+}
+
 
 /* Return true if DECL's initializer is suitable for a BSS section.  */
 
@@ -1126,11 +1156,14 @@ align_variable (tree decl, bool dont_output_data)
     {
 #ifdef DATA_ALIGNMENT
       unsigned int data_align = DATA_ALIGNMENT (TREE_TYPE (decl), align);
+#else
+      unsigned int data_align = align;
+#endif
+      data_align = alignment_for_aligned_arrays (TREE_TYPE (decl), data_align);
       /* Don't increase alignment too much for TLS variables - TLS space
 	 is too precious.  */
       if (! DECL_THREAD_LOCAL_P (decl) || data_align <= BITS_PER_WORD)
 	align = data_align;
-#endif
 #ifdef CONSTANT_ALIGNMENT
       if (DECL_INITIAL (decl) != 0 && DECL_INITIAL (decl) != error_mark_node)
 	{
@@ -3198,6 +3231,10 @@ build_constant_desc (tree exp)
   set_mem_alias_set (rtl, 0);
   set_mem_alias_set (rtl, const_alias_set);
 
+  /* We cannot share RTX'es in pool entries.
+     Mark this piece of RTL as required for unsharing.  */
+  RTX_FLAG (rtl, used) = 1;
+
   /* Set flags or add text to the name to record information, such as
      that it is a local symbol.  If the name is changed, the macro
      ASM_OUTPUT_LABELREF will have to know how to strip this
diff --git a/gcc/vmsdbgout.c b/gcc/vmsdbgout.c
index 246ab7270..a5095e162 100644
--- a/gcc/vmsdbgout.c
+++ b/gcc/vmsdbgout.c
@@ -213,6 +213,7 @@ const struct gcc_debug_hooks vmsdbg_debug_hooks
    debug_nothing_int,		  /* handle_pch */
    debug_nothing_rtx,		  /* var_location */
    debug_nothing_void,            /* switch_text_section */
+   debug_nothing_tree_tree,	  /* set_name */
    0                              /* start_end_main_source_file */
 };
 
diff --git a/include/libiberty.h b/include/libiberty.h
index b7b9a248c..dcf2b92a9 100644
--- a/include/libiberty.h
+++ b/include/libiberty.h
@@ -591,6 +591,10 @@ extern int pexecute (const char *, char * const *, const char *,
 
 extern int pwait (int, int *, int);
 
+/* Convert a Cygwin path to a Windows path.  */
+
+extern int cygpath (const char *, char []);
+
 #if !HAVE_DECL_ASPRINTF
 /* Like sprintf but provides a pointer to malloc'd storage, which must
    be freed by the caller.  */
diff --git a/libcpp/Makefile.in b/libcpp/Makefile.in
index cd2f92412..68f5892d0 100644
--- a/libcpp/Makefile.in
+++ b/libcpp/Makefile.in
@@ -72,13 +72,12 @@ ALL_CFLAGS = $(CFLAGS) $(WARN_CFLAGS) $(INCLUDES) $(CPPFLAGS)
 libcpp_a_OBJS = charset.o directives.o directives-only.o errors.o \
 	expr.o files.o identifiers.o init.o lex.o line-map.o macro.o \
 	mkdeps.o pch.o symtab.o traditional.o
-makedepend_OBJS = makedepend.o
 
 libcpp_a_SOURCES = charset.c directives.c directives-only.c errors.c \
 	expr.c files.c identifiers.c init.c lex.c line-map.c macro.c \
 	mkdeps.c pch.c symtab.c traditional.c
 
-all: libcpp.a makedepend$(EXEEXT) $(USED_CATALOGS)
+all: libcpp.a $(USED_CATALOGS)
 
 .SUFFIXES:
 .SUFFIXES: .c .gmo .o .obj .po .pox
@@ -88,12 +87,6 @@ libcpp.a: $(libcpp_a_OBJS)
 	$(AR) $(ARFLAGS) libcpp.a $(libcpp_a_OBJS)
 	$(RANLIB) libcpp.a
 
-makedepend$(EXEEXT): $(makedepend_OBJS) libcpp.a ../libiberty/libiberty.a
-	@rm -f makedepend$(EXEEXT)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o makedepend$(EXEEXT) \
-	  $(makedepend_OBJS) libcpp.a ../libiberty/libiberty.a \
-	  $(LIBINTL) $(LIBICONV)
-
 # Rules to rebuild the configuration
 
 Makefile: $(srcdir)/Makefile.in config.status
@@ -165,7 +158,7 @@ mostlyclean:
 	-rm -f *.o
 
 clean: mostlyclean
-	-rm -rf makedepend$(EXEEXT) libcpp.a $(srcdir)/autom4te.cache
+	-rm -rf libcpp.a $(srcdir)/autom4te.cache
 
 distclean: clean
 	-rm -f config.h stamp-h1 config.status config.cache config.log \
@@ -247,7 +240,7 @@ po/$(PACKAGE).pot: $(libcpp_a_SOURCES)
 	sed 's:$(srcdir)/::g' <po/$(PACKAGE).pot.tmp >po/$(PACKAGE).pot
 	rm po/$(PACKAGE).pot.tmp
 
-TAGS_SOURCES = $(libcpp_a_SOURCES) makedepend.c internal.h ucnid.h \
+TAGS_SOURCES = $(libcpp_a_SOURCES) internal.h ucnid.h \
     include/line-map.h include/symtab.h include/cpp-id-data.h \
     include/cpplib.h include/mkdeps.h system.h
 
@@ -259,7 +252,7 @@ TAGS: $(TAGS_SOURCES)
 .NOEXPORT:
 
 # Dependencies
--include $(patsubst %.o, $(DEPDIR)/%.Po, $(libcpp_a_OBJS) $(makedepend_OBJS))
+-include $(patsubst %.o, $(DEPDIR)/%.Po, $(libcpp_a_OBJS))
 
 # Dependencies on generated headers have to be explicit.
 init.o: localedir.h
diff --git a/libcpp/directives.c b/libcpp/directives.c
index 412a214a2..707fbd61a 100644
--- a/libcpp/directives.c
+++ b/libcpp/directives.c
@@ -2377,13 +2377,6 @@ handle_assertion (cpp_reader *pfile, const char *str, int type)
   run_directive (pfile, type, str, count);
 }
 
-/* The number of errors for a given reader.  */
-unsigned int
-cpp_errors (cpp_reader *pfile)
-{
-  return pfile->errors;
-}
-
 /* The options structure.  */
 cpp_options *
 cpp_get_options (cpp_reader *pfile)
diff --git a/libcpp/errors.c b/libcpp/errors.c
index 7c379dfea..bc8528949 100644
--- a/libcpp/errors.c
+++ b/libcpp/errors.c
@@ -28,171 +28,69 @@ along with this program; see the file COPYING3.  If not see
 #include "cpplib.h"
 #include "internal.h"
 
-static void print_location (cpp_reader *, source_location, unsigned int);
-
-/* Print the logical file location (LINE, COL) in preparation for a
-   diagnostic.  Outputs the #include chain if it has changed.  A line
-   of zero suppresses the include stack, and outputs the program name
-   instead.  */
-static void
-print_location (cpp_reader *pfile, source_location line, unsigned int col)
-{
-  if (line == 0)
-    fprintf (stderr, "%s: ", progname);
-  else
-    {
-      const struct line_map *map;
-      linenum_type lin;
-
-      map = linemap_lookup (pfile->line_table, line);
-      linemap_print_containing_files (pfile->line_table, map);
-
-      lin = SOURCE_LINE (map, line);
-      if (col == 0)
-	{
-	  col = SOURCE_COLUMN (map, line);
-	  if (col == 0)
-	    col = 1;
-	}
-
-      if (lin == 0)
-	fprintf (stderr, "%s:", map->to_file);
-      else if (CPP_OPTION (pfile, show_column) == 0)
-	fprintf (stderr, "%s:%u:", map->to_file, lin);
-      else
-	fprintf (stderr, "%s:%u:%u:", map->to_file, lin, col);
-
-      fputc (' ', stderr);
-    }
-}
-
-/* Set up for a diagnostic: print the file and line, bump the error
-   counter, etc.  SRC_LOC is the logical line number; zero means to print
-   at the location of the previously lexed token, which tends to be
-   the correct place by default.  The column number can be specified either
-   using COLUMN or (if COLUMN==0) extracting SOURCE_COLUMN from SRC_LOC.
-   (This may seem redundant, but is useful when pre-scanning (cleaning) a line,
-   when we haven't yet verified whether the current line_map has a
-   big enough max_column_hint.)
-
-   Returns 0 if the error has been suppressed.  */
-static int
-_cpp_begin_message (cpp_reader *pfile, int code,
-		    source_location src_loc, unsigned int column)
-{
-  int level = CPP_DL_EXTRACT (code);
-
-  switch (level)
-    {
-    case CPP_DL_WARNING:
-    case CPP_DL_PEDWARN:
-      if (cpp_in_system_header (pfile)
-	  && ! CPP_OPTION (pfile, warn_system_headers))
-	return 0;
-      /* Fall through.  */
-
-    case CPP_DL_WARNING_SYSHDR:
-      if (CPP_OPTION (pfile, warnings_are_errors)
-	  || (level == CPP_DL_PEDWARN && CPP_OPTION (pfile, pedantic_errors)))
-	{
-	  if (CPP_OPTION (pfile, inhibit_errors))
-	    return 0;
-	  level = CPP_DL_ERROR;
-	  pfile->errors++;
-	}
-      else if (CPP_OPTION (pfile, inhibit_warnings))
-	return 0;
-      break;
-
-    case CPP_DL_ERROR:
-      if (CPP_OPTION (pfile, inhibit_errors))
-	return 0;
-      /* ICEs cannot be inhibited.  */
-    case CPP_DL_ICE:
-      pfile->errors++;
-      break;
-    }
-
-  print_location (pfile, src_loc, column);
-  if (CPP_DL_WARNING_P (level))
-    fputs (_("warning: "), stderr);
-  else if (level == CPP_DL_ICE)
-    fputs (_("internal error: "), stderr);
-  else
-    fputs (_("error: "), stderr);
-
-  return 1;
-}
-
-/* Don't remove the blank before do, as otherwise the exgettext
-   script will mistake this as a function definition */
-#define v_message(msgid, ap) \
- do { vfprintf (stderr, _(msgid), ap); putc ('\n', stderr); } while (0)
-
-/* Exported interface.  */
-
 /* Print an error at the location of the previously lexed token.  */
-void
+bool
 cpp_error (cpp_reader * pfile, int level, const char *msgid, ...)
 {
   source_location src_loc;
   va_list ap;
-  
+  bool ret;
+
   va_start (ap, msgid);
 
-  if (CPP_OPTION (pfile, client_diagnostic))
-    pfile->cb.error (pfile, level, _(msgid), &ap);
-  else
+  if (CPP_OPTION (pfile, traditional))
     {
-      if (CPP_OPTION (pfile, traditional))
-	{
-	  if (pfile->state.in_directive)
-	    src_loc = pfile->directive_line;
-	  else
-	    src_loc = pfile->line_table->highest_line;
-	}
-      /* We don't want to refer to a token before the beginning of the
-	 current run -- that is invalid.  */
-      else if (pfile->cur_token == pfile->cur_run->base)
-	{
-	  if (pfile->cur_run->prev != NULL)
-	    src_loc = pfile->cur_run->prev->limit->src_loc;
-	  else
-	    src_loc = 0;
-	}
+      if (pfile->state.in_directive)
+	src_loc = pfile->directive_line;
       else
-	{
-	  src_loc = pfile->cur_token[-1].src_loc;
-	}
-
-      if (_cpp_begin_message (pfile, level, src_loc, 0))
-	v_message (msgid, ap);
+	src_loc = pfile->line_table->highest_line;
+    }
+  /* We don't want to refer to a token before the beginning of the
+     current run -- that is invalid.  */
+  else if (pfile->cur_token == pfile->cur_run->base)
+    {
+      if (pfile->cur_run->prev != NULL)
+	src_loc = pfile->cur_run->prev->limit->src_loc;
+      else
+	src_loc = 0;
     }
+  else
+    {
+      src_loc = pfile->cur_token[-1].src_loc;
+    }
+
+  if (!pfile->cb.error)
+    abort ();
+  ret = pfile->cb.error (pfile, level, src_loc, 0, _(msgid), &ap);
 
   va_end (ap);
+  return ret;
 }
 
 /* Print an error at a specific location.  */
-void
+bool
 cpp_error_with_line (cpp_reader *pfile, int level,
 		     source_location src_loc, unsigned int column,
 		     const char *msgid, ...)
 {
   va_list ap;
+  bool ret;
   
   va_start (ap, msgid);
 
-  if (_cpp_begin_message (pfile, level, src_loc, column))
-    v_message (msgid, ap);
+  if (!pfile->cb.error)
+    abort ();
+  ret = pfile->cb.error (pfile, level, src_loc, column, _(msgid), &ap);
 
   va_end (ap);
+  return ret;
 }
 
-void
+bool
 cpp_errno (cpp_reader *pfile, int level, const char *msgid)
 {
   if (msgid[0] == '\0')
     msgid = _("stdout");
 
-  cpp_error (pfile, level, "%s: %s", msgid, xstrerror (errno));
+  return cpp_error (pfile, level, "%s: %s", msgid, xstrerror (errno));
 }
diff --git a/libcpp/files.c b/libcpp/files.c
index 6ad83b934..34600001e 100644
--- a/libcpp/files.c
+++ b/libcpp/files.c
@@ -488,7 +488,6 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir, bool f
 	      return file;
 	    }
 
-	  open_file_failed (pfile, file, angle_brackets);
 	  if (invalid_pch)
 	    {
 	      cpp_error (pfile, CPP_DL_ERROR,
@@ -497,6 +496,7 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir, bool f
 		cpp_error (pfile, CPP_DL_ERROR,
 			   "use -Winvalid-pch for more information");
 	    }
+	  open_file_failed (pfile, file, angle_brackets);
 	  break;
 	}
 
@@ -934,15 +934,28 @@ open_file_failed (cpp_reader *pfile, _cpp_file *file, int angle_brackets)
 
   errno = file->err_no;
   if (print_dep && CPP_OPTION (pfile, deps.missing_files) && errno == ENOENT)
-    deps_add_dep (pfile->deps, file->name);
+    {
+      deps_add_dep (pfile->deps, file->name);
+      /* If the preprocessor output (other than dependency information) is
+         being used, we must also flag an error.  */
+      if (CPP_OPTION (pfile, deps.need_preprocessor_output))
+	cpp_errno (pfile, CPP_DL_FATAL, file->path);
+    }
   else
     {
-      /* If we are outputting dependencies but not for this file then
-	 don't error because we can still produce correct output.  */
-      if (CPP_OPTION (pfile, deps.style) && ! print_dep)
-	cpp_errno (pfile, CPP_DL_WARNING, file->path);
+      /* If we are not outputting dependencies, or if we are and dependencies
+         were requested for this file, or if preprocessor output is needed
+         in addition to dependency information, this is an error.
+
+         Otherwise (outputting dependencies but not for this file, and not
+         using the preprocessor output), we can still produce correct output
+         so it's only a warning.  */
+      if (CPP_OPTION (pfile, deps.style) == DEPS_NONE
+          || print_dep
+          || CPP_OPTION (pfile, deps.need_preprocessor_output))
+	cpp_errno (pfile, CPP_DL_FATAL, file->path);
       else
-	cpp_errno (pfile, CPP_DL_ERROR, file->path);
+	cpp_errno (pfile, CPP_DL_WARNING, file->path);
     }
 }
 
diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
index a29dbea8f..0c532bdfd 100644
--- a/libcpp/include/cpplib.h
+++ b/libcpp/include/cpplib.h
@@ -302,22 +302,9 @@ struct cpp_options
   /* Nonzero means print names of header files (-H).  */
   unsigned char print_include_names;
 
-  /* Nonzero means cpp_pedwarn causes a hard error.  */
-  unsigned char pedantic_errors;
-
-  /* Nonzero means don't print warning messages.  */
-  unsigned char inhibit_warnings;
-
   /* Nonzero means complain about deprecated features.  */
   unsigned char warn_deprecated;
 
-  /* Nonzero means don't suppress warnings from system headers.  */
-  unsigned char warn_system_headers;
-
-  /* Nonzero means don't print error messages.  Has no option to
-     select it, but can be set by a user of cpplib (e.g. fix-header).  */
-  unsigned char inhibit_errors;
-
   /* Nonzero means warn if slash-star appears in a comment.  */
   unsigned char warn_comments;
 
@@ -353,9 +340,6 @@ struct cpp_options
      explicitly undefined.  */
   unsigned char warn_builtin_macro_redefined;
 
-  /* Nonzero means turn warnings into errors.  */
-  unsigned char warnings_are_errors;
-
   /* Nonzero means we should look for header.gcc files that remap file
      names.  */
   unsigned char remap;
@@ -432,6 +416,10 @@ struct cpp_options
 
     /* If true, no dependency is generated on the main file.  */
     bool ignore_main_file;
+
+    /* If true, intend to use the preprocessor output (e.g., for compilation)
+       in addition to the dependency info.  */
+    bool need_preprocessor_output;
   } deps;
 
   /* Target-specific features set by the front end or client.  */
@@ -450,9 +438,6 @@ struct cpp_options
   /* Nonzero means __STDC__ should have the value 0 in system headers.  */
   unsigned char stdc_0_in_system_headers;
 
-  /* True means error callback should be used for diagnostics.  */
-  bool client_diagnostic;
-
   /* True disables tokenization outside of preprocessing directives. */
   bool directives_only;
 };
@@ -492,10 +477,11 @@ struct cpp_callbacks
      be expanded.  */
   cpp_hashnode * (*macro_to_expand) (cpp_reader *, const cpp_token *);
 
-  /* Called to emit a diagnostic if client_diagnostic option is true.
-     This callback receives the translated message.  */
-  void (*error) (cpp_reader *, int, const char *, va_list *)
-       ATTRIBUTE_FPTR_PRINTF(3,0);
+  /* Called to emit a diagnostic.  This callback receives the
+     translated message.  */
+  bool (*error) (cpp_reader *, int, source_location, unsigned int,
+		 const char *, va_list *)
+       ATTRIBUTE_FPTR_PRINTF(5,0);
 
   /* Callbacks for when a macro is expanded, or tested (whether
      defined or not at the time) in #ifdef, #ifndef or "defined".  */
@@ -697,19 +683,13 @@ extern void cpp_init_iconv (cpp_reader *);
 
 /* Call this to finish preprocessing.  If you requested dependency
    generation, pass an open stream to write the information to,
-   otherwise NULL.  It is your responsibility to close the stream.
-
-   Returns cpp_errors (pfile).  */
-extern int cpp_finish (cpp_reader *, FILE *deps_stream);
+   otherwise NULL.  It is your responsibility to close the stream.  */
+extern void cpp_finish (cpp_reader *, FILE *deps_stream);
 
 /* Call this to release the handle at the end of preprocessing.  Any
-   use of the handle after this function returns is invalid.  Returns
-   cpp_errors (pfile).  */
+   use of the handle after this function returns is invalid.  */
 extern void cpp_destroy (cpp_reader *);
 
-/* Error count.  */
-extern unsigned int cpp_errors (cpp_reader *);
-
 extern unsigned int cpp_token_len (const cpp_token *);
 extern unsigned char *cpp_token_as_text (cpp_reader *, const cpp_token *);
 extern unsigned char *cpp_spell_token (cpp_reader *, const cpp_token *,
@@ -835,24 +815,23 @@ cpp_num cpp_num_sign_extend (cpp_num, size_t);
 /* An internal consistency check failed.  Prints "internal error: ",
    otherwise the same as CPP_DL_ERROR.  */
 #define CPP_DL_ICE		0x04
-/* Extracts a diagnostic level from an int.  */
-#define CPP_DL_EXTRACT(l)	(l & 0xf)
-/* Nonzero if a diagnostic level is one of the warnings.  */
-#define CPP_DL_WARNING_P(l)	(CPP_DL_EXTRACT (l) >= CPP_DL_WARNING \
-				 && CPP_DL_EXTRACT (l) <= CPP_DL_PEDWARN)
+/* An informative note following a warning.  */
+#define CPP_DL_NOTE		0x05
+/* A fatal error.  */
+#define CPP_DL_FATAL		0x06
 
 /* Output a diagnostic of some kind.  */
-extern void cpp_error (cpp_reader *, int, const char *msgid, ...)
+extern bool cpp_error (cpp_reader *, int, const char *msgid, ...)
   ATTRIBUTE_PRINTF_3;
 
 /* Output a diagnostic with "MSGID: " preceding the
    error string of errno.  No location is printed.  */
-extern void cpp_errno (cpp_reader *, int, const char *msgid);
+extern bool cpp_errno (cpp_reader *, int, const char *msgid);
 
 /* Same as cpp_error, except additionally specifies a position as a
    (translation unit) physical line and physical column.  If the line is
    zero, then no location is printed.  */
-extern void cpp_error_with_line (cpp_reader *, int, source_location, unsigned,
+extern bool cpp_error_with_line (cpp_reader *, int, source_location, unsigned,
 				 const char *msgid, ...) ATTRIBUTE_PRINTF_5;
 
 /* In lex.c */
diff --git a/libcpp/include/line-map.h b/libcpp/include/line-map.h
index 539214564..610892a32 100644
--- a/libcpp/include/line-map.h
+++ b/libcpp/include/line-map.h
@@ -144,11 +144,10 @@ extern const struct line_map *linemap_add
 extern const struct line_map *linemap_lookup
   (struct line_maps *, source_location);
 
-/* Print the file names and line numbers of the #include commands
-   which led to the map MAP, if any, to stderr.  Nothing is output if
-   the most recently listed stack is the same as the current one.  */
-extern void linemap_print_containing_files (struct line_maps *,
-					    const struct line_map *);
+/* source_location values from 0 to RESERVED_LOCATION_COUNT-1 will
+   be reserved for libcpp user as special values, no token from libcpp
+   will contain any of those locations.  */
+#define RESERVED_LOCATION_COUNT	2
 
 /* Converts a map and a source_location to source line.  */
 #define SOURCE_LINE(MAP, LOC) \
diff --git a/libcpp/init.c b/libcpp/init.c
index 550d97ebb..11b77401b 100644
--- a/libcpp/init.c
+++ b/libcpp/init.c
@@ -631,12 +631,11 @@ read_original_directory (cpp_reader *pfile)
 }
 
 /* This is called at the end of preprocessing.  It pops the last
-   buffer and writes dependency output, and returns the number of
-   errors.
+   buffer and writes dependency output.
 
    Maybe it should also reset state, such that you could call
    cpp_start_read with a new filename to restart processing.  */
-int
+void
 cpp_finish (cpp_reader *pfile, FILE *deps_stream)
 {
   /* Warn about unused macros before popping the final buffer.  */
@@ -651,9 +650,8 @@ cpp_finish (cpp_reader *pfile, FILE *deps_stream)
   while (pfile->buffer)
     _cpp_pop_buffer (pfile);
 
-  /* Don't write the deps file if there are errors.  */
   if (CPP_OPTION (pfile, deps.style) != DEPS_NONE
-      && deps_stream && pfile->errors == 0)
+      && deps_stream)
     {
       deps_write (pfile->deps, deps_stream, 72);
 
@@ -664,8 +662,6 @@ cpp_finish (cpp_reader *pfile, FILE *deps_stream)
   /* Report on headers that could use multiple include guards.  */
   if (CPP_OPTION (pfile, print_include_names))
     _cpp_report_missing_guards (pfile);
-
-  return pfile->errors;
 }
 
 static void
diff --git a/libcpp/internal.h b/libcpp/internal.h
index 370ce576e..8f145a3a2 100644
--- a/libcpp/internal.h
+++ b/libcpp/internal.h
@@ -398,9 +398,6 @@ struct cpp_reader
   /* Nonzero prevents the lexer from re-using the token runs.  */
   unsigned int keep_tokens;
 
-  /* Error counter for exit code.  */
-  unsigned int errors;
-
   /* Buffer to hold macro definition string.  */
   unsigned char *macro_buffer;
   unsigned int macro_buffer_len;
diff --git a/libcpp/line-map.c b/libcpp/line-map.c
index 3e25511e6..908e385e3 100644
--- a/libcpp/line-map.c
+++ b/libcpp/line-map.c
@@ -38,8 +38,8 @@ linemap_init (struct line_maps *set)
   set->trace_includes = false;
   set->depth = 0;
   set->cache = 0;
-  set->highest_location = 0;
-  set->highest_line = 0;
+  set->highest_location = RESERVED_LOCATION_COUNT - 1;
+  set->highest_line = RESERVED_LOCATION_COUNT - 1;
   set->max_column_hint = 0;
 }
 
@@ -302,45 +302,6 @@ linemap_lookup (struct line_maps *set, source_location line)
   return &set->maps[mn];
 }
 
-/* Print the file names and line numbers of the #include commands
-   which led to the map MAP, if any, to stderr.  Nothing is output if
-   the most recently listed stack is the same as the current one.  */
-
-void
-linemap_print_containing_files (struct line_maps *set,
-				const struct line_map *map)
-{
-  if (MAIN_FILE_P (map) || set->last_listed == map->included_from)
-    return;
-
-  set->last_listed = map->included_from;
-  map = INCLUDED_FROM (set, map);
-
-  fprintf (stderr,  _("In file included from %s:%u"),
-	   map->to_file, LAST_SOURCE_LINE (map));
-
-  while (! MAIN_FILE_P (map))
-    {
-      map = INCLUDED_FROM (set, map);
-      /* Translators note: this message is used in conjunction
-	 with "In file included from %s:%ld" and some other
-	 tricks.  We want something like this:
-
-	 | In file included from sys/select.h:123,
-	 |                  from sys/types.h:234,
-	 |                  from userfile.c:31:
-	 | bits/select.h:45: <error message here>
-
-	 with all the "from"s lined up.
-	 The trailing comma is at the beginning of this message,
-	 and the trailing colon is not translated.  */
-      fprintf (stderr, _(",\n                 from %s:%u"),
-	       map->to_file, LAST_SOURCE_LINE (map));
-    }
-
-  fputs (":\n", stderr);
-}
-
 /* Print an include trace, for e.g. the -H option of the preprocessor.  */
 
 static void
diff --git a/libcpp/macro.c b/libcpp/macro.c
index d74b80fad..562731872 100644
--- a/libcpp/macro.c
+++ b/libcpp/macro.c
@@ -1833,11 +1833,13 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)
 
       if (warn_of_redefinition (pfile, node, macro))
 	{
-	  cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->directive_line, 0,
-			       "\"%s\" redefined", NODE_NAME (node));
+	  bool warned;
+	  warned = cpp_error_with_line (pfile, CPP_DL_PEDWARN,
+					pfile->directive_line, 0,
+					"\"%s\" redefined", NODE_NAME (node));
 
-	  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))
-	    cpp_error_with_line (pfile, CPP_DL_PEDWARN,
+	  if (warned && node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))
+	    cpp_error_with_line (pfile, CPP_DL_NOTE,
 				 node->value.macro->line, 0,
 			 "this is the location of the previous definition");
 	}
diff --git a/libcpp/makedepend.c b/libcpp/makedepend.c
index c67f64e23..e69de29bb 100644
--- a/libcpp/makedepend.c
+++ b/libcpp/makedepend.c
@@ -1,206 +0,0 @@
-/* Dependency generator utility.
-   Copyright (C) 2004 Free Software Foundation, Inc.
-   Contributed by Zack Weinberg, May 2004
-
-This program is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
- In other words, you are welcome to use, share and improve this program.
- You are forbidden to forbid anyone else to use, share and improve
- what you give them.   Help stamp out software-hoarding!  */
-
-#include "config.h"
-#include "system.h"
-#include "line-map.h"
-#include "cpplib.h"
-#include "getopt.h"
-#include "mkdeps.h"
-
-const char *progname;
-const char *vpath;
-
-static const char *output_file;
-static bool had_errors;
-
-/* Option lists, to give to cpplib before each input file.  */
-struct cmd_line_macro
-{
-  struct cmd_line_macro *next;
-  bool is_undef;
-  const char *macro;
-};
-
-static struct cmd_line_macro *cmd_line_macros;
-static cpp_dir *cmd_line_searchpath;
-
-static void
-add_clm (const char *macro, bool is_undef)
-{
-  struct cmd_line_macro *clm = XNEW (struct cmd_line_macro);
-  clm->next = cmd_line_macros;
-  clm->is_undef = is_undef;
-  clm->macro = macro;
-  cmd_line_macros = clm;
-}
-
-static void
-add_dir (char *name, bool sysp)
-{
-  cpp_dir *dir = XNEW (cpp_dir);
-  dir->next = cmd_line_searchpath;
-  dir->name = name;
-  dir->sysp = sysp;
-  dir->construct = 0;
-  dir->user_supplied_p = 1;
-  cmd_line_searchpath = dir;
-}
-
-/* Command line processing.  */
-
-static void ATTRIBUTE_NORETURN
-usage (int errcode)
-{
-  fprintf (stderr,
-"usage: %s [-vh] [-V vpath] [-Dname[=def]...] [-Uname] [-Idir...] [-o file] sources...\n",
-	   progname);
-  exit (errcode);
-}
-
-static int
-parse_options (int argc, char **argv)
-{
-  static const struct option longopts[] = {
-    { "--help", no_argument, 0, 'h' },
-    { 0, 0, 0, 0 }
-  };
-
-  for (;;)
-    switch (getopt_long (argc, argv, "hD:U:I:J:o:V:", longopts, 0))
-      {
-      case 'h': usage (0);
-      case 'D': add_clm (optarg, false); break;
-      case 'U': add_clm (optarg, true);  break;
-      case 'I': add_dir (optarg, false); break;
-      case 'J': add_dir (optarg, true);  break;
-      case 'o':
-	if (output_file)
-	  {
-	    fprintf (stderr, "%s: too many output files\n", progname);
-	    usage (2);
-	  }
-	output_file = optarg;
-	break;
-      case 'V':
-	if (vpath)
-	  {
-	    fprintf (stderr, "%s: too many vpaths\n", progname);
-	    usage (2);
-	  }
-	vpath = optarg;
-	break;
-      case '?':
-	usage (2);  /* getopt has issued the error message.  */
-
-      case -1: /* end of options */
-	if (optind == argc)
-	  {
-	    fprintf (stderr, "%s: no input files\n", progname);
-	    usage (2);
-	  }
-	return optind;
-
-      default:
-	abort ();
-      }
-}
-
-/* Set up cpplib from command line options.  */
-static cpp_reader *
-reader_init (struct line_maps *line_table)
-{
-  cpp_reader *reader;
-  cpp_options *options;
-
-  linemap_init (line_table);
-  reader = cpp_create_reader (CLK_GNUC89, 0, line_table);
-
-  /* Ignore warnings and errors (we don't have access to system
-     headers).  Request dependency output.  */
-  options = cpp_get_options (reader);
-  options->inhibit_warnings = 1;
-  options->inhibit_errors = 1;
-  options->deps.style = DEPS_USER;
-
-  /* Further initialization.  */
-  cpp_post_options (reader);
-  cpp_init_iconv (reader);
-  cpp_set_include_chains (reader, cmd_line_searchpath, cmd_line_searchpath,
-			  false);
-  if (vpath)
-    {
-      struct deps *deps = cpp_get_deps (reader);
-      deps_add_vpath (deps, vpath);
-    }
-
-  return reader;
-}
-
-/* Process one input source file.  */
-static void
-process_file (const char *file)
-{
-  struct line_maps line_table;
-  cpp_reader *reader = reader_init (&line_table);
-
-  if (!cpp_read_main_file (reader, file))
-    had_errors = true;
-  else
-    {
-      struct cmd_line_macro *clm;
-
-      cpp_init_builtins (reader, true);
-      for (clm = cmd_line_macros; clm; clm = clm->next)
-	(clm->is_undef ? cpp_undef : cpp_define) (reader, clm->macro);
-
-      cpp_scan_nooutput (reader);
-      if (cpp_finish (reader, stdout))
-	had_errors = true;
-    }
-  cpp_destroy (reader);
-  linemap_free (&line_table);
-}
-
-/* Master control.  */
-
-int
-main(int argc, char **argv)
-{
-  int first_input, i;
-
-  progname = argv[0];
-  xmalloc_set_program_name (progname);
-
-  first_input = parse_options (argc, argv);
-  if (output_file)
-    if (!freopen (output_file, "w", stdout))
-      {
-	perror (output_file);
-	return 1;
-      }
-
-  for (i = first_input; i < argc; i++)
-    process_file (argv[i]);
-
-  return had_errors;
-}
diff --git a/libgcc/Makefile.in b/libgcc/Makefile.in
index b6d088164..c2dabbf35 100644
--- a/libgcc/Makefile.in
+++ b/libgcc/Makefile.in
@@ -389,18 +389,24 @@ libgcc-s-objects += $(patsubst %,%_s$(objext),$(sifuncs) $(difuncs) $(tifuncs))
 endif
 endif
 
+ifeq ($(LIB2_DIVMOD_EXCEPTION_FLAGS),)
+# Provide default flags for compiling divmod functions, if they haven't been
+# set already by a target-specific Makefile fragment.
+LIB2_DIVMOD_EXCEPTION_FLAGS := -fexceptions -fnon-call-exceptions
+endif
+
 # Build LIB2_DIVMOD_FUNCS.
 lib2-divmod-o = $(patsubst %,%$(objext),$(LIB2_DIVMOD_FUNCS))
 $(lib2-divmod-o): %$(objext): $(gcc_srcdir)/libgcc2.c
 	$(gcc_compile) -DL$* -c $(gcc_srcdir)/libgcc2.c \
-	  -fexceptions -fnon-call-exceptions $(vis_hide)
+	  $(LIB2_DIVMOD_EXCEPTION_FLAGS) $(vis_hide)
 libgcc-objects += $(lib2-divmod-o)
 
 ifeq ($(enable_shared),yes)
 lib2-divmod-s-o = $(patsubst %,%_s$(objext),$(LIB2_DIVMOD_FUNCS))
 $(lib2-divmod-s-o): %_s$(objext): $(gcc_srcdir)/libgcc2.c
 	$(gcc_s_compile) -DL$* -c $(gcc_srcdir)/libgcc2.c \
-	  -fexceptions -fnon-call-exceptions
+	  $(LIB2_DIVMOD_EXCEPTION_FLAGS)
 libgcc-s-objects += $(lib2-divmod-s-o)
 endif
 
diff --git a/libgcc/config.host b/libgcc/config.host
index 55af65160..533cf5f99 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -203,12 +203,15 @@ arm*-*-netbsdelf*)
 arm*-*-netbsd*)
 	;;
 arm*-*-linux*)			# ARM GNU/Linux with ELF
+	tmake_file="${tmake_file} arm/t-divmod-ef"
 	;;
 arm*-*-uclinux*)		# ARM ucLinux
+	tmake_file="${tmake_file} arm/t-divmod-ef"
 	;;
 arm*-*-ecos-elf)
 	;;
-arm*-*-eabi* | arm*-*-symbianelf* )
+arm*-*-eabi* | arm*-*-nucleuseabi* | arm*-*-symbianelf* )
+	tmake_file="${tmake_file} arm/t-divmod-ef"
 	;;
 arm*-*-rtems*)
 	;;
@@ -216,6 +219,8 @@ arm*-*-elf)
 	;;
 arm*-wince-pe*)
 	;;
+arm*-*-mingw32ce* | arm*-*-cegcc*)
+	;;
 arm-*-pe*)
 	;;
 avr-*-rtems*)
@@ -394,8 +399,12 @@ mips-sgi-irix[56]*)
 mips*-*-netbsd*)			# NetBSD/mips, either endian.
 	;;
 mips64*-*-linux*)
+	extra_parts="$extra_parts crtfastmath.o"
+	tmake_file="{$tmake_file} mips/t-crtfm"
 	;;
 mips*-*-linux*)				# Linux MIPS, either endian.
+	extra_parts="$extra_parts crtfastmath.o"
+	tmake_file="{$tmake_file} mips/t-crtfm"
 	;;
 mips*-*-openbsd*)
 	;;
@@ -419,6 +428,10 @@ mips64vr-*-elf* | mips64vrel-*-elf*)
         ;;
 mips64orion-*-elf* | mips64orionel-*-elf*)
 	;;
+mips64octeon-wrs-elf* | mips64octeonel-wrs-elf*)
+	;;
+mips64octeon-montavista-elf*)
+	;;
 mips*-*-rtems*)
 	;;
 mips-wrs-vxworks)
@@ -507,12 +520,20 @@ score-*-elf)
 sh-*-elf* | sh[12346l]*-*-elf* | \
 sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \
   sh-*-linux* | sh[2346lbe]*-*-linux* | \
+  sh-*-uclinux* | sh[12]-*-uclinux* | \
   sh-*-netbsdelf* | shl*-*-netbsdelf* | sh5-*-netbsd* | sh5l*-*-netbsd* | \
    sh64-*-netbsd* | sh64l*-*-netbsd*)
 	case ${host} in
 	sh*-*-linux*)
 		tmake_file="${tmake_file} sh/t-linux"
 		;;
+	sh*-*-uclinux*)
+		# Upstream submission question: do we even need the
+		# pre-FDPIC configuration?
+		if test x$enable_fdpic != xno; then
+			tmake_file="${tmake_file} sh/t-uclinux-fdpic"
+		fi
+		;;
 	esac
 	;;
 sh-*-rtems*)
diff --git a/libgcc/config/arm/t-divmod-ef b/libgcc/config/arm/t-divmod-ef
new file mode 100644
index 000000000..cd4b3e120
--- /dev/null
+++ b/libgcc/config/arm/t-divmod-ef
@@ -0,0 +1,4 @@
+# On ARM, specifying -fnon-call-exceptions will needlessly pull in
+# the unwinder in simple programs which use 64-bit division.  Omitting
+# the option is safe.
+LIB2_DIVMOD_EXCEPTION_FLAGS := -fexceptions
diff --git a/libgcc/config/mips/t-crtfm b/libgcc/config/mips/t-crtfm
new file mode 100644
index 000000000..fe2e06619
--- /dev/null
+++ b/libgcc/config/mips/t-crtfm
@@ -0,0 +1,3 @@
+crtfastmath.o: $(gcc_srcdir)/config/mips/crtfastmath.c
+	$(gcc_compile) -c $(gcc_srcdir)/config/mips/crtfastmath.c
+
diff --git a/libgcc/config/sh/t-uclinux-fdpic b/libgcc/config/sh/t-uclinux-fdpic
new file mode 100644
index 000000000..5eace60f0
--- /dev/null
+++ b/libgcc/config/sh/t-uclinux-fdpic
@@ -0,0 +1,40 @@
+# FIXME: -DNO_FPSCR_VALUES is probably appropriate (we have shared libs).
+# But it requires __fpscr_values be provided by libc.so.
+HOST_LIBGCC2_CFLAGS = -fpic
+
+# Do we need unwind-dw2-fde-glibc for EH?  It does not currently
+# build.
+#LIB2ADDEH = $(gcc_srcdir)/unwind-dw2.c $(gcc_srcdir)/unwind-dw2-fde-glibc.c \
+#  $(gcc_srcdir)/unwind-sjlj.c $(gcc_srcdir)/gthr-gnat.c \
+#  $(gcc_srcdir)/unwind-c.c
+
+# Override t-slibgcc-elf-ver to hide some lib1func routines which
+# should not be called via PLT.
+SHLIB_MAPFILES += $(gcc_srcdir)/config/sh/libgcc-excl.ver
+
+# Override SHLIB_LINK and SHLIB_INSTALL to use linker script
+# libgcc_s.so.
+SHLIB_LINK = $(CC) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
+	-Wl,--soname=@shlib_base_name@.so.1 \
+	-Wl,--version-script=@shlib_map_file@ \
+	-o @multilib_dir@/@shlib_base_name@.so.1.tmp @multilib_flags@ \
+	@shlib_objs@ -lc && \
+	rm -f @multilib_dir@/@shlib_base_name@.so && \
+	if [ -f @multilib_dir@/@shlib_base_name@.so.1 ]; then \
+	  mv -f @multilib_dir@/@shlib_base_name@.so.1 \
+		@multilib_dir@/@shlib_base_name@.so.1.backup; \
+	else true; fi && \
+	mv @multilib_dir@/@shlib_base_name@.so.1.tmp \
+	   @multilib_dir@/@shlib_base_name@.so.1 && \
+	(echo "/* GNU ld script"; \
+	 echo "   Use the shared library, but some functions are only in"; \
+	 echo "   the static library.  */"; \
+	 echo "GROUP ( @shlib_base_name@.so.1 libgcc.a )" \
+	) > @multilib_dir@/@shlib_base_name@.so
+SHLIB_INSTALL = \
+	$(mkinstalldirs) $(DESTDIR)$(slibdir)@shlib_slibdir_qual@; \
+	$(INSTALL_DATA) @multilib_dir@/@shlib_base_name@.so.1 \
+	  $(DESTDIR)$(slibdir)@shlib_slibdir_qual@/@shlib_base_name@.so.1; \
+	rm -f $(DESTDIR)$(slibdir)@shlib_slibdir_qual@/@shlib_base_name@.so; \
+	$(INSTALL_DATA) @multilib_dir@/@shlib_base_name@.so \
+	  $(DESTDIR)$(slibdir)@shlib_slibdir_qual@/@shlib_base_name@.so
diff --git a/libgcc/shared-object.mk b/libgcc/shared-object.mk
index 65171b6aa..ea49dc29d 100644
--- a/libgcc/shared-object.mk
+++ b/libgcc/shared-object.mk
@@ -8,11 +8,13 @@ base := $(basename $(notdir $o))
 
 ifeq ($(suffix $o),.c)
 
+c_flags-$(base)$(objext) := $(c_flags)
 $(base)$(objext): $o
-	$(gcc_compile) $(c_flags) -c $< $(vis_hide)
+	$(gcc_compile) $(c_flags-$@) -c $< $(vis_hide)
 
+c_flags-$(base)_s$(objext) := $(c_flags)
 $(base)_s$(objext): $o
-	$(gcc_s_compile) $(c_flags) -c $<
+	$(gcc_s_compile) $(c_flags-$@) -c $<
 
 else
 
diff --git a/libgcc/static-object.mk b/libgcc/static-object.mk
index ab75d3288..3a168c4b5 100644
--- a/libgcc/static-object.mk
+++ b/libgcc/static-object.mk
@@ -8,8 +8,9 @@ base := $(basename $(notdir $o))
 
 ifeq ($(suffix $o),.c)
 
+c_flags-$(base)$(objext) := $(c_flags)
 $(base)$(objext): $o
-	$(gcc_compile) $(c_flags) -c $< $(vis_hide)
+	$(gcc_compile) $(c_flags-$@) -c $< $(vis_hide)
 
 else
 
diff --git a/libgfortran/config.h.in b/libgfortran/config.h.in
index 3542638b0..e370ddbd9 100644
--- a/libgfortran/config.h.in
+++ b/libgfortran/config.h.in
@@ -300,6 +300,9 @@
 /* libm includes erfl */
 #undef HAVE_ERFL
 
+/* errno.h exists */
+#undef HAVE_ERRNO_H
+
 /* Define to 1 if you have the <execinfo.h> header file. */
 #undef HAVE_EXECINFO_H
 
diff --git a/libgfortran/configure b/libgfortran/configure
index ef19d153b..938c9d0dd 100755
--- a/libgfortran/configure
+++ b/libgfortran/configure
@@ -15652,6 +15652,152 @@ _ACEOF
 fi
 
 
+if test "${ac_cv_header_errno_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for errno.h" >&5
+echo $ECHO_N "checking for errno.h... $ECHO_C" >&6
+if test "${ac_cv_header_errno_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_errno_h" >&5
+echo "${ECHO_T}$ac_cv_header_errno_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking errno.h usability" >&5
+echo $ECHO_N "checking errno.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <errno.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking errno.h presence" >&5
+echo $ECHO_N "checking errno.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <errno.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: errno.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: errno.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: errno.h: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: errno.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: errno.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: errno.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: errno.h:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: errno.h:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: errno.h: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: errno.h: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: errno.h:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: errno.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: errno.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: errno.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: errno.h: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: errno.h: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------------------ ##
+## Report this to the GNU Fortran Runtime Library lists.  ##
+## ------------------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for errno.h" >&5
+echo $ECHO_N "checking for errno.h... $ECHO_C" >&6
+if test "${ac_cv_header_errno_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_errno_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_errno_h" >&5
+echo "${ECHO_T}$ac_cv_header_errno_h" >&6
+
+fi
+if test $ac_cv_header_errno_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ERRNO_H 1
+_ACEOF
+
+fi
+
+
 
 
 inttype_headers=`echo inttypes.h sys/inttypes.h  | sed -e 's/,/ /g'`
@@ -16361,7 +16507,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16425,7 +16572,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16466,7 +16614,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16523,7 +16672,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16564,7 +16714,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16629,7 +16780,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16697,7 +16849,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (void *)); }
 unsigned long ulongval () { return (long) (sizeof (void *)); }
 #include <stdio.h>
@@ -16785,7 +16938,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16849,7 +17003,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16890,7 +17045,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16947,7 +17103,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16988,7 +17145,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17053,7 +17211,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17121,7 +17280,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (long)); }
 unsigned long ulongval () { return (long) (sizeof (long)); }
 #include <stdio.h>
@@ -17209,7 +17369,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17273,7 +17434,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17314,7 +17476,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17371,7 +17534,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17412,7 +17576,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17477,7 +17642,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17545,7 +17711,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (int)); }
 unsigned long ulongval () { return (long) (sizeof (int)); }
 #include <stdio.h>
@@ -17629,7 +17796,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17693,7 +17861,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17734,7 +17903,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17791,7 +17961,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17832,7 +18003,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17897,7 +18069,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17965,7 +18138,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (short)); }
 unsigned long ulongval () { return (long) (sizeof (short)); }
 #include <stdio.h>
@@ -18049,7 +18223,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -18113,7 +18288,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -18154,7 +18330,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -18211,7 +18388,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -18252,7 +18430,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -18317,7 +18496,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -18385,7 +18565,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (char)); }
 unsigned long ulongval () { return (long) (sizeof (char)); }
 #include <stdio.h>
diff --git a/libgfortran/configure.ac b/libgfortran/configure.ac
index 2fe297cb3..f8efc82fa 100644
--- a/libgfortran/configure.ac
+++ b/libgfortran/configure.ac
@@ -193,6 +193,7 @@ AC_CHECK_HEADERS(time.h sys/time.h sys/times.h sys/resource.h)
 AC_CHECK_HEADERS(sys/types.h sys/stat.h sys/wait.h floatingpoint.h ieeefp.h)
 AC_CHECK_HEADERS(fenv.h fptrap.h float.h execinfo.h pwd.h)
 AC_CHECK_HEADER([complex.h],[AC_DEFINE([HAVE_COMPLEX_H], [1], [complex.h exists])])
+AC_CHECK_HEADER([errno.h],[AC_DEFINE([HAVE_ERRNO_H], [1], [errno.h exists])])
 GCC_HEADER_STDINT(gstdint.h)
 
 AC_CHECK_MEMBERS([struct stat.st_blksize])
diff --git a/libgfortran/intrinsics/access.c b/libgfortran/intrinsics/access.c
index 9d44531e2..32f472060 100644
--- a/libgfortran/intrinsics/access.c
+++ b/libgfortran/intrinsics/access.c
@@ -25,7 +25,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
-#include <errno.h>
 #include <string.h>
 
 #ifdef HAVE_UNISTD_H
@@ -85,6 +84,6 @@ access_func (char *name, char *mode, gfc_charlen_type name_len,
   file[name_len] = '\0';
 
   /* And make the call to access().  */
-  return (access (file, m) == 0 ? 0 : errno);
+  return (access (file, m) == 0 ? 0 : get_oserrno ());
 }
 #endif
diff --git a/libgfortran/intrinsics/chdir.c b/libgfortran/intrinsics/chdir.c
index 62f46931b..626b468ba 100644
--- a/libgfortran/intrinsics/chdir.c
+++ b/libgfortran/intrinsics/chdir.c
@@ -25,7 +25,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 #include <string.h>
 
 #ifdef HAVE_UNISTD_H
diff --git a/libgfortran/intrinsics/chmod.c b/libgfortran/intrinsics/chmod.c
index cf768ff00..cfbac8dcf 100644
--- a/libgfortran/intrinsics/chmod.c
+++ b/libgfortran/intrinsics/chmod.c
@@ -25,7 +25,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 #include <string.h>
 
 #ifdef HAVE_UNISTD_H
diff --git a/libgfortran/intrinsics/env.c b/libgfortran/intrinsics/env.c
index 883603848..102b669e3 100644
--- a/libgfortran/intrinsics/env.c
+++ b/libgfortran/intrinsics/env.c
@@ -61,7 +61,11 @@ PREFIX(getenv) (char * name, char * value, gfc_charlen_type name_len,
   memcpy (name_nt, name, name_len);
   name_nt[name_len] = '\0'; 
 
-  res = getenv(name_nt);
+#ifndef __MINGW32CE__
+  res = getenv (name_nt);
+#else
+  res = NULL;
+#endif
 
   /* If res is NULL, it means that the environment variable didn't 
      exist, so just return.  */
@@ -137,7 +141,11 @@ get_environment_variable_i4 (char *name, char *value, GFC_INTEGER_4 *length,
   memcpy (name_nt, name, name_len);
   name_nt[name_len] = '\0'; 
   
-  res = getenv(name_nt);
+#ifndef __MINGW32CE__
+  res = getenv (name_nt);
+#else
+  res = NULL;
+#endif
 
   if (res == NULL)
     stat = GFC_NAME_DOES_NOT_EXIST;
diff --git a/libgfortran/intrinsics/gerror.c b/libgfortran/intrinsics/gerror.c
index ccb5c3efd..b01d966ba 100644
--- a/libgfortran/intrinsics/gerror.c
+++ b/libgfortran/intrinsics/gerror.c
@@ -25,7 +25,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 #include <string.h>
 
 
@@ -33,7 +35,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    message corresponding to the last system error (C errno).
    CHARACTER(len=*), INTENT(OUT) :: MESSAGE  */
 
-#ifdef HAVE_STRERROR
 void PREFIX(gerror) (char *, gfc_charlen_type);
 export_proto_np(PREFIX(gerror));
 
@@ -41,11 +42,11 @@ void
 PREFIX(gerror) (char * msg, gfc_charlen_type msg_len)
 {
   int p_len;
-  char *p;
+  const char *p;
 
   memset (msg, ' ', msg_len); /* Blank the string.  */
 
-  p = strerror (errno);
+  p = get_oserror ();
   if (p == NULL)
     return;
 
@@ -55,4 +56,3 @@ PREFIX(gerror) (char * msg, gfc_charlen_type msg_len)
   else
     memcpy (msg, p, p_len);
 }
-#endif
diff --git a/libgfortran/intrinsics/getXid.c b/libgfortran/intrinsics/getXid.c
index 9eb60f039..a58d7ee41 100644
--- a/libgfortran/intrinsics/getXid.c
+++ b/libgfortran/intrinsics/getXid.c
@@ -30,7 +30,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #ifdef __MINGW32__
 #define HAVE_GETPID 1
-#include <process.h>
+#include <windows.h>
 #endif
 
 #ifdef HAVE_GETGID
@@ -51,7 +51,11 @@ export_proto_np(PREFIX(getpid));
 GFC_INTEGER_4
 PREFIX(getpid) (void)
 {
+#ifdef __MINGW32CE__
+  return (GFC_INTEGER_4) GetCurrentProcessId ();
+#else
   return getpid ();
+#endif
 }
 #endif
 
diff --git a/libgfortran/intrinsics/getcwd.c b/libgfortran/intrinsics/getcwd.c
index 15e8e8f7b..3aa668da5 100644
--- a/libgfortran/intrinsics/getcwd.c
+++ b/libgfortran/intrinsics/getcwd.c
@@ -26,7 +26,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "libgfortran.h"
 
 #include <string.h>
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
diff --git a/libgfortran/intrinsics/getlog.c b/libgfortran/intrinsics/getlog.c
index 0456c5796..fdbc6e431 100644
--- a/libgfortran/intrinsics/getlog.c
+++ b/libgfortran/intrinsics/getlog.c
@@ -36,9 +36,60 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 /* Windows32 version */
 #if defined __MINGW32__ && !defined  HAVE_GETLOGIN
-#define WIN32_LEAN_AND_MEAN
 #include <windows.h>
-#include <lmcons.h>  /* for UNLEN */ 
+#include <lmcons.h>  /* for UNLEN */
+#include <malloc.h>
+
+#ifdef __MINGW32CE__
+
+/* GetUserNameExA is only available on CE >= 4.  Load it
+   dynamically.  */
+typedef enum
+{
+  NameUnknown = 0,
+  /* ... */
+  NameWindowsCeLocal = 0x80000001
+} EXTENDED_NAME_FORMAT;
+
+static BOOLEAN
+ce_GetUserNameA (LPSTR lpNameBuffer, PULONG nSize)
+{
+  static HMODULE dll = INVALID_HANDLE_VALUE;
+  static BOOLEAN (*pGetUserNameEx) (EXTENDED_NAME_FORMAT, LPTSTR, PULONG);
+
+  WCHAR *wbuf = alloca (*nSize * 2);
+
+  if (dll == INVALID_HANDLE_VALUE)
+    {
+      dll = GetModuleHandle (L"coredll.dll");
+      if (dll == NULL)
+	{
+	  /* paranoia */
+	  SetLastError (ERROR_NOT_SUPPORTED);
+	  return FALSE;
+	}
+
+      pGetUserNameEx = (void*) GetProcAddress (dll, L"GetUserNameExW");
+    }
+
+  if (pGetUserNameEx == NULL)
+    {
+      SetLastError (ERROR_NOT_SUPPORTED);
+      return FALSE;
+    }
+
+  *nSize *= 2;
+  if (!(*pGetUserNameEx) (NameWindowsCeLocal, wbuf, nSize))
+    return FALSE;
+
+  *nSize /= 2;
+  wcstombs (lpNameBuffer, wbuf, *nSize);
+  return TRUE;
+}
+
+#undef GetUserName
+#define GetUserName ce_GetUserNameA
+#endif
 
 static char *
 w32_getlogin (void)
diff --git a/libgfortran/intrinsics/hostnm.c b/libgfortran/intrinsics/hostnm.c
index 99ab18dcb..143679849 100644
--- a/libgfortran/intrinsics/hostnm.c
+++ b/libgfortran/intrinsics/hostnm.c
@@ -25,7 +25,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 #include <string.h>
 
 #ifdef HAVE_UNISTD_H
@@ -37,8 +39,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #if defined __MINGW32__ && !defined  HAVE_GETHOSTNAME
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
-#include <errno.h>
 
+#ifndef __MINGW32CE__
+
+/* Windows (non-CE) version.  */
 static int
 w32_gethostname (char *name, size_t len)
 {
@@ -67,6 +71,55 @@ w32_gethostname (char *name, size_t len)
   return 0;
 }
 
+#else
+
+/* There's no GetComputerName on Windows CE, but, we can read the
+   computer name from the registry, at "HKLM\\Ident\\Name".  The
+   Internet claims this is what's WinSock's gethostname does too.  */
+
+static int
+w32_gethostname (char *name, size_t len)
+{
+  DWORD res;
+  HKEY hKey;
+
+/* XXX: Is this limit valid on CE?  */
+#ifndef MAX_COMPUTERNAME_LENGTH
+#define MAX_COMPUTERNAME_LENGTH 15
+#endif
+
+  res = RegOpenKeyEx (HKEY_LOCAL_MACHINE, L"Ident", 0, KEY_READ, &hKey);
+  if (res == ERROR_SUCCESS)
+    {
+      WCHAR buffer[MAX_COMPUTERNAME_LENGTH + 1];
+      DWORD type;
+      DWORD nbytes;
+
+      nbytes = sizeof (buffer);
+      res = RegQueryValueEx (hKey, L"Name", NULL, &type, (LPBYTE) buffer,
+			     &nbytes);
+      RegCloseKey (hKey);
+
+      if (res == ERROR_SUCCESS)
+	{
+	  if (((nbytes / 2) + 1) > len)
+	    {
+	      SetLastError (ERROR_INVALID_PARAMETER);
+	      /* Truncate as per POSIX spec.  We do not
+		 NUL-terminate. */
+	      nbytes = len * 2;
+	    }
+
+	  wcstombs (name, buffer, nbytes / 2);
+	  return 0;
+	}
+    }
+
+  return -1;
+}
+
+#endif
+
 #undef gethostname
 #define gethostname w32_gethostname
 #define  HAVE_GETHOSTNAME 1
@@ -101,7 +154,7 @@ hostnm_i4_sub (char *name, GFC_INTEGER_4 *status, gfc_charlen_type name_len)
   }
 
   if (status != NULL) 
-    *status = (val == 0) ? 0 : errno;
+    *status = (val == 0) ? 0 : get_oserrno ();
 }
 iexport(hostnm_i4_sub);
 
@@ -127,7 +180,7 @@ hostnm_i8_sub (char *name, GFC_INTEGER_8 *status, gfc_charlen_type name_len)
   }
 
   if (status != NULL) 
-    *status = (val == 0) ? 0 : errno;
+    *status = (val == 0) ? 0 : get_oserrno ();
 }
 iexport(hostnm_i8_sub);
 
diff --git a/libgfortran/intrinsics/ierrno.c b/libgfortran/intrinsics/ierrno.c
index 2f5e44fa6..5f0a93d00 100644
--- a/libgfortran/intrinsics/ierrno.c
+++ b/libgfortran/intrinsics/ierrno.c
@@ -25,9 +25,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
-#include <errno.h>
-
-
 /* INTEGER FUNCTION IERRNO()  */
 
 extern GFC_INTEGER_4 ierrno_i4 (void);
@@ -36,7 +33,7 @@ export_proto(ierrno_i4);
 GFC_INTEGER_4
 ierrno_i4 (void)
 {
-  return (GFC_INTEGER_4) errno;
+  return get_oserrno ();
 }
 
 extern GFC_INTEGER_8 ierrno_i8 (void);
@@ -45,5 +42,5 @@ export_proto(ierrno_i8);
 GFC_INTEGER_8
 ierrno_i8 (void)
 {
-  return (GFC_INTEGER_8) errno;
+  return (GFC_INTEGER_8) get_oserrno ();
 }
diff --git a/libgfortran/intrinsics/kill.c b/libgfortran/intrinsics/kill.c
index 83e8b2838..3c4620617 100644
--- a/libgfortran/intrinsics/kill.c
+++ b/libgfortran/intrinsics/kill.c
@@ -24,7 +24,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
 #include "libgfortran.h"
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 
 #ifdef HAVE_SIGNAL_H
 #include <signal.h>
diff --git a/libgfortran/intrinsics/link.c b/libgfortran/intrinsics/link.c
index 21bae400a..05a3ed3fb 100644
--- a/libgfortran/intrinsics/link.c
+++ b/libgfortran/intrinsics/link.c
@@ -25,7 +25,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 #include <string.h>
 
 #ifdef HAVE_UNISTD_H
diff --git a/libgfortran/intrinsics/perror.c b/libgfortran/intrinsics/perror.c
index 10348bd08..1d8c3e1b1 100644
--- a/libgfortran/intrinsics/perror.c
+++ b/libgfortran/intrinsics/perror.c
@@ -25,9 +25,18 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 #include <string.h>
 
+#ifdef __MINGW32CE__
+extern void pwinerror (const char *s);
+internal_proto(pwinerror);
+#define perror pwinerror
+#define HAVE_PERROR 1
+#endif
+
 /* SUBROUTINE PERROR(STRING)
    CHARACTER(len=*), INTENT(IN) :: STRING   */
 
diff --git a/libgfortran/intrinsics/rename.c b/libgfortran/intrinsics/rename.c
index 0d7dd166b..10d1f33c5 100644
--- a/libgfortran/intrinsics/rename.c
+++ b/libgfortran/intrinsics/rename.c
@@ -25,7 +25,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 #include <string.h>
 
 /* SUBROUTINE RENAME(PATH1, PATH2, STATUS)
@@ -61,7 +63,7 @@ rename_i4_sub (char *path1, char *path2, GFC_INTEGER_4 *status,
   val = rename (str1, str2);
 
   if (status != NULL) 
-    *status = (val == 0) ? 0 : errno;
+    *status = (val == 0) ? 0 : get_oserrno ();
 }
 iexport(rename_i4_sub);
 
@@ -94,7 +96,7 @@ rename_i8_sub (char *path1, char *path2, GFC_INTEGER_8 *status,
   val = rename (str1, str2);
 
   if (status != NULL) 
-    *status = (val == 0) ? 0 : errno;
+    *status = (val == 0) ? 0 : get_oserrno ();
 }
 iexport(rename_i8_sub);
 
diff --git a/libgfortran/intrinsics/signal.c b/libgfortran/intrinsics/signal.c
index 66e54f33a..c4f5ba9b8 100644
--- a/libgfortran/intrinsics/signal.c
+++ b/libgfortran/intrinsics/signal.c
@@ -37,14 +37,32 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include <inttypes.h>
 #endif
 
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
+
+#ifdef __MINGW32CE__
+# include <windows.h>
+#endif
+
+static void
+not_supported (void)
+{
+#if defined __MINGW32CE__
+  SetLastError (ERROR_NOT_SUPPORTED);
+#else
+  errno = ENOSYS;
+#endif
+}
 
 /* SIGNAL subroutine with PROCEDURE as handler  */
 extern void signal_sub (int *, void (*)(int), int *);
 iexport_proto(signal_sub);
 
 void
-signal_sub (int *number, void (*handler)(int), int *status)
+signal_sub (int *number __attribute__ ((unused)),
+	    void (*handler)(int) __attribute__ ((unused)),
+	    int *status)
 {
 #ifdef HAVE_SIGNAL
   intptr_t ret;
@@ -57,7 +75,7 @@ signal_sub (int *number, void (*handler)(int), int *status)
   else
     signal (*number, handler);
 #else
-  errno = ENOSYS;
+  not_supported ();
   if (status != NULL)
     *status = -1;
 #endif
@@ -70,7 +88,9 @@ extern void signal_sub_int (int *, int *, int *);
 iexport_proto(signal_sub_int);
 
 void
-signal_sub_int (int *number, int *handler, int *status)
+signal_sub_int (int *number __attribute__ ((unused)),
+		int *handler __attribute__ ((unused)),
+		int *status)
 {
 #ifdef HAVE_SIGNAL
   intptr_t ptr = *handler, ret;
@@ -83,7 +103,7 @@ signal_sub_int (int *number, int *handler, int *status)
   else
     signal (*number, (void (*)(int)) ptr);
 #else
-  errno = ENOSYS;
+  not_supported ();
   if (status != NULL)
     *status = -1;
 #endif
@@ -143,7 +163,7 @@ alarm_sub_i4 (int * seconds __attribute__ ((unused)),
       alarm (*seconds);
     }
 #else
-  errno = ENOSYS;
+  not_supported ();
   if (status != NULL)
     *status = -1;
 #endif
@@ -173,7 +193,7 @@ alarm_sub_i8 (int *seconds __attribute__ ((unused)),
       alarm (*seconds);
     }
 #else
-  errno = ENOSYS;
+  not_supported ();
   if (status != NULL)
     *status = -1;
 #endif
@@ -204,7 +224,7 @@ alarm_sub_int_i4 (int *seconds __attribute__ ((unused)),
       alarm (*seconds);
     }
 #else
-  errno = ENOSYS;
+  not_supported ();
   if (status != NULL)
     *status = -1;
 #endif
@@ -234,7 +254,7 @@ alarm_sub_int_i8 (int *seconds __attribute__ ((unused)),
       alarm (*seconds);
     }
 #else
-  errno = ENOSYS;
+  not_supported ();
   if (status != NULL)
     *status = -1;
 #endif
diff --git a/libgfortran/intrinsics/sleep.c b/libgfortran/intrinsics/sleep.c
index 6f7ea227d..ecf6bb617 100644
--- a/libgfortran/intrinsics/sleep.c
+++ b/libgfortran/intrinsics/sleep.c
@@ -25,8 +25,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
-#include <errno.h>
-
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
diff --git a/libgfortran/intrinsics/stat.c b/libgfortran/intrinsics/stat.c
index 5d0f3b63b..b5c056d38 100644
--- a/libgfortran/intrinsics/stat.c
+++ b/libgfortran/intrinsics/stat.c
@@ -26,7 +26,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "libgfortran.h"
 
 #include <string.h>
-#include <errno.h>
 
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
@@ -141,7 +140,7 @@ stat_i4_sub_0 (char *name, gfc_array_i4 *sarray, GFC_INTEGER_4 *status,
     }
 
   if (status != NULL)
-    *status = (val == 0) ? 0 : errno;
+    *status = (val == 0) ? 0 : get_oserrno ();
 }
 
 
@@ -260,7 +259,7 @@ stat_i8_sub_0 (char *name, gfc_array_i8 *sarray, GFC_INTEGER_8 *status,
     }
 
   if (status != NULL)
-    *status = (val == 0) ? 0 : errno;
+    *status = (val == 0) ? 0 : get_oserrno ();
 }
 
 
@@ -439,7 +438,7 @@ fstat_i4_sub (GFC_INTEGER_4 *unit, gfc_array_i4 *sarray, GFC_INTEGER_4 *status)
     }
 
   if (status != NULL)
-    *status = (val == 0) ? 0 : errno;
+    *status = (val == 0) ? 0 : get_oserrno ();
 }
 iexport(fstat_i4_sub);
 
@@ -520,7 +519,7 @@ fstat_i8_sub (GFC_INTEGER_8 *unit, gfc_array_i8 *sarray, GFC_INTEGER_8 *status)
     }
 
   if (status != NULL)
-    *status = (val == 0) ? 0 : errno;
+    *status = (val == 0) ? 0 : get_oserrno ();
 }
 iexport(fstat_i8_sub);
 
diff --git a/libgfortran/intrinsics/symlnk.c b/libgfortran/intrinsics/symlnk.c
index 095520f05..d648495b4 100644
--- a/libgfortran/intrinsics/symlnk.c
+++ b/libgfortran/intrinsics/symlnk.c
@@ -25,7 +25,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "libgfortran.h"
 
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 #include <string.h>
 
 #ifdef HAVE_UNISTD_H
diff --git a/libgfortran/intrinsics/system.c b/libgfortran/intrinsics/system.c
index 831823ffc..034e25aed 100644
--- a/libgfortran/intrinsics/system.c
+++ b/libgfortran/intrinsics/system.c
@@ -30,6 +30,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include <stdlib.h>
 #endif
 
+#ifdef __MINGW32CE__
+#include <windows.h>
+#endif
+
 extern void system_sub (const char *fcmd, GFC_INTEGER_4 * status,
 			gfc_charlen_type cmd_len);
 iexport_proto(system_sub);
@@ -45,8 +49,14 @@ system_sub (const char *fcmd, GFC_INTEGER_4 *status, gfc_charlen_type cmd_len)
 
   memcpy (cmd, fcmd, cmd_len);
   cmd[cmd_len] = '\0';
-
+#ifndef __MINGW32CE__
   stat = system (cmd);
+#else
+  /* XXX: We could use ShellExecuteEx or
+     CreateProcess/WaitForSingleObject to implement this.  */
+  stat = -1;
+  SetLastError (ERROR_NOT_SUPPORTED);
+#endif
   if (status)
     *status = stat;
 }
diff --git a/libgfortran/intrinsics/umask.c b/libgfortran/intrinsics/umask.c
index 9df684bfc..dcc2dfe94 100644
--- a/libgfortran/intrinsics/umask.c
+++ b/libgfortran/intrinsics/umask.c
@@ -38,6 +38,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include <unistd.h>
 #endif
 
+#ifdef __MINGW32CE__
+
+static mode_t
+ce_umask (mode_t m)
+{
+  /* XXX: Is there anything more sensible to do?  */
+  return 0 * m; /* avoid unused warning */
+}
+
+#define umask ce_umask
+#endif
 
 /* SUBROUTINE UMASK(MASK, OLD)
    INTEGER, INTENT(IN) :: MASK
diff --git a/libgfortran/intrinsics/unlink.c b/libgfortran/intrinsics/unlink.c
index 7b17dfe3f..80261742c 100644
--- a/libgfortran/intrinsics/unlink.c
+++ b/libgfortran/intrinsics/unlink.c
@@ -26,7 +26,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "libgfortran.h"
 
 #include <string.h>
-#include <errno.h>
 
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
@@ -58,7 +57,7 @@ unlink_i4_sub (char *name, GFC_INTEGER_4 *status, gfc_charlen_type name_len)
   stat = unlink (str);
 
   if (status != NULL)
-    *status = (stat == 0) ? stat : errno;
+    *status = (stat == 0) ? stat : get_oserrno ();
 }
 iexport(unlink_i4_sub);
 
diff --git a/libgfortran/io/open.c b/libgfortran/io/open.c
index 99c923882..0fed66546 100644
--- a/libgfortran/io/open.c
+++ b/libgfortran/io/open.c
@@ -27,8 +27,13 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "io.h"
 #include <unistd.h>
 #include <string.h>
+#ifdef HAVE_ERRNO_H
 #include <errno.h>
+#endif
 
+#ifdef __MINGW32CE__
+#include <windows.h>
+#endif
 
 static const st_option access_opt[] = {
   {"sequential", ACCESS_SEQUENTIAL},
@@ -505,9 +510,28 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)
       msg = (char *) gfc_alloca (opp->file_len + 51);
       unpack_filename (path, opp->file, opp->file_len);
 
+#ifdef _WIN32_WCE
+      switch (GetLastError ())
+	{
+	case ERROR_FILE_NOT_FOUND:
+	  sprintf (msg, "File '%s' does not exist", path);
+	  break;
+
+	case ERROR_FILE_EXISTS:
+	  sprintf (msg, "File '%s' already exists", path);
+	  break;
+
+	case ERROR_ACCESS_DENIED:
+	  sprintf (msg, "Permission denied trying to open file '%s'", path);
+	  break;
+
+	default:
+	  msg = NULL;
+	}
+#else
       switch (errno)
 	{
-	case ENOENT: 
+	case ENOENT:
 	  sprintf (msg, "File '%s' does not exist", path);
 	  break;
 
@@ -526,6 +550,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)
 	default:
 	  msg = NULL;
 	}
+#endif
 
       generate_error (&opp->common, LIBERROR_OS, msg);
       goto cleanup;
diff --git a/libgfortran/io/read.c b/libgfortran/io/read.c
index 16ab21209..f58c0186e 100644
--- a/libgfortran/io/read.c
+++ b/libgfortran/io/read.c
@@ -25,11 +25,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "io.h"
 #include <string.h>
-#include <errno.h>
+#ifdef HAVE_ERRNO_H
+# include <errno.h>
+#endif
 #include <ctype.h>
 #include <stdlib.h>
 #include <assert.h>
 
+#ifdef __MINGW32CE__
+# include <windows.h>
+#endif
+
 typedef unsigned char uchar;
 
 /* read.c -- Deal with formatted reads */
@@ -134,7 +140,11 @@ max_value (int length, int signed_flag)
 int
 convert_real (st_parameter_dt *dtp, void *dest, const char *buffer, int length)
 {
+#ifdef __MINGW32CE__
+  SetLastError (0);
+#else
   errno = 0;
+#endif
 
   switch (length)
     {
@@ -167,7 +177,13 @@ convert_real (st_parameter_dt *dtp, void *dest, const char *buffer, int length)
       internal_error (&dtp->common, "Unsupported real kind during IO");
     }
 
+#ifndef __MINGW32CE__
   if (errno == EINVAL)
+#else
+    /* TESTME: It is not clear if CE ever sets a last error at
+       all.  */
+  if (GetLastError () == ERROR_INVALID_PARAMETER)
+#endif
     {
       generate_error (&dtp->common, LIBERROR_READ_VALUE,
 		      "Error during floating point read");
diff --git a/libgfortran/io/transfer.c b/libgfortran/io/transfer.c
index 0b8793b38..09016d03e 100644
--- a/libgfortran/io/transfer.c
+++ b/libgfortran/io/transfer.c
@@ -32,8 +32,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include <string.h>
 #include <assert.h>
 #include <stdlib.h>
-#include <errno.h>
-
 
 /* Calling conventions:  Data transfer statements are unlike other
    library calls in that they extend over several calls.
@@ -2750,11 +2748,11 @@ next_record_r (st_parameter_dt *dtp, int done)
 	{
 	  do
 	    {
-              errno = 0;
+	      clear_oserrno ();
               cc = fbuf_getc (dtp->u.p.current_unit);
 	      if (cc == EOF) 
 		{
-                  if (errno != 0)
+		  if (get_oserrno () != 0)
                     generate_error (&dtp->common, LIBERROR_OS, NULL);
 		  else
 		    {
diff --git a/libgfortran/io/unix.c b/libgfortran/io/unix.c
index f80fb564a..d44527856 100644
--- a/libgfortran/io/unix.c
+++ b/libgfortran/io/unix.c
@@ -36,8 +36,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include <assert.h>
 
 #include <string.h>
-#include <errno.h>
 
+#if HAVE_ERRNO_H
+#include <errno.h>
+#endif
 
 /* For mingw, we don't identify files by their inode number, but by a
    64-bit identifier created from a BY_HANDLE_FILE_INFORMATION. */
@@ -68,13 +70,23 @@ id_from_path (const char *path)
 {
   HANDLE hFile;
   uint64_t res;
+#ifdef __MINGW32CE__
+  WCHAR wpath[MAX_PATH];
+#endif
 
   if (!path || !*path || access (path, F_OK))
     return (uint64_t) -1;
 
-  hFile = CreateFile (path, 0, 0, NULL, OPEN_EXISTING,
-		      FILE_FLAG_BACKUP_SEMANTICS | FILE_ATTRIBUTE_READONLY,
-		      NULL);
+#ifdef __MINGW32CE__
+  MultiByteToWideChar (CP_ACP, 0, path, -1, wpath, MAX_PATH);
+  hFile = CreateFileW (wpath,
+#else
+  hFile = CreateFileA (path,
+#endif
+		       0, 0, NULL, OPEN_EXISTING,
+		       FILE_FLAG_BACKUP_SEMANTICS | FILE_ATTRIBUTE_READONLY,
+		       NULL);
+
   res = id_from_handle (hFile);
   CloseHandle (hFile);
   return res;
@@ -84,7 +96,11 @@ id_from_path (const char *path)
 static uint64_t
 id_from_fd (const int fd)
 {
+#ifdef __MINGW32CE__
+  return id_from_handle ((HANDLE) fd);
+#else
   return id_from_handle ((HANDLE) _get_osfhandle (fd));
+#endif
 }
 
 #endif
@@ -190,6 +206,14 @@ fix_fd (int fd)
   return fd;
 }
 
+/* On Windows CE, file descriptors are actually pointers.  For the
+   most part, we pretend they're integers (sizeof(void*) == sizeof
+   (int), and INVALID_FILE_HANDLE is (void*)-1.  These hide a bit the
+   fact, avoiding integer/pointer comparison warnings.  */
+
+#define GFC_STDOUT_FILENO ((int) STDOUT_FILENO)
+#define GFC_STDERR_FILENO ((int) STDERR_FILENO)
+#define GFC_STDIN_FILENO ((int) STDIN_FILENO)
 
 /* If the stream corresponds to a preconnected unit, we flush the
    corresponding C stream.  This is bugware for mixed C-Fortran codes
@@ -200,22 +224,127 @@ flush_if_preconnected (stream * s)
   int fd;
 
   fd = ((unix_stream *) s)->fd;
-  if (fd == STDIN_FILENO)
+  if (fd == GFC_STDIN_FILENO)
     fflush (stdin);
-  else if (fd == STDOUT_FILENO)
+  else if (fd == GFC_STDOUT_FILENO)
     fflush (stdout);
-  else if (fd == STDERR_FILENO)
+  else if (fd == GFC_STDERR_FILENO)
     fflush (stderr);
 }
 
+#ifdef _WIN32
+
+#include <stdio.h>
+#include <windows.h>
+
+#ifndef COUNTOF
+#define COUNTOF(ARRAY) (sizeof (ARRAY) / sizeof ((ARRAY)[0]))
+#endif
+
+/* Map the Windows error number in ERROR to a locale-dependent error
+   message string and return a pointer to it.  Typically, the values
+   for ERROR come from GetLastError.
+
+   The string pointed to shall not be modified by the application, but
+   may be overwritten by a subsequent call to strwinerror
+
+   The strwinerror function does not change the current setting of
+   GetLastError.  */
+
+static char *
+strwinerror (DWORD error)
+{
+  static char buf[1024];
+  TCHAR *msgbuf;
+  DWORD lasterr = GetLastError ();
+  DWORD chars = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
+			       | FORMAT_MESSAGE_ALLOCATE_BUFFER,
+			       NULL,
+			       error,
+			       0, /* Default language */
+			       (LPVOID)&msgbuf,
+			       0,
+			       NULL);
+  if (chars != 0)
+    {
+      /* If there is an \r\n appended, zap it.  */
+      if (chars >= 2
+	  && msgbuf[chars - 2] == '\r'
+	  && msgbuf[chars - 1] == '\n')
+	{
+	  chars -= 2;
+	  msgbuf[chars] = 0;
+	}
+
+      if (chars > ((COUNTOF (buf)) - 1))
+	{
+	  chars = COUNTOF (buf) - 1;
+	  msgbuf [chars] = 0;
+	}
+
+#ifdef UNICODE
+      wcstombs (buf, msgbuf, chars + 1);
+#else
+      strncpy (buf, msgbuf, chars + 1);
+#endif
+      LocalFree (msgbuf);
+    }
+  else
+    sprintf (buf, "unknown win32 error (%ld)", error);
+
+  SetLastError (lasterr);
+  return buf;
+}
+
+extern void pwinerror (const char *s);
+internal_proto(pwinerror);
+
+void
+pwinerror (const char *s)
+{
+  if (s && *s)
+    fprintf (stderr, "%s: %s\n", s, strwinerror (GetLastError ()));
+  else
+    fprintf (stderr, "%s\n", strwinerror (GetLastError ()));
+}
+
+#endif
 
 /* get_oserror()-- Get the most recent operating system error.  For
- * unix, this is errno. */
+ * unix, this is errno; for Windows CE, this is GetLastError.  */
 
 const char *
 get_oserror (void)
 {
+#ifdef __MINGW32CE__
+  return strwinerror (GetLastError ());
+#else
   return strerror (errno);
+#endif
+}
+
+/* get_oserrno()-- Get the most recent operating system error.  For
+ * unix and Windows, this is errno; for Windows CE, this is
+ * GetLastError.  */
+
+GFC_INTEGER_4
+get_oserrno (void)
+{
+#ifdef __MINGW32CE__
+  return (GFC_INTEGER_4) GetLastError ();
+#else
+  return errno;
+#endif
+}
+
+void
+clear_oserrno (void)
+{
+#ifdef __MINGW32CE__
+  SetLastError (0);
+#else
+  errno = 0;
+#endif
 }
 
 
@@ -261,10 +390,11 @@ raw_write (unix_stream * s, const void * buf, ssize_t nbyte)
       trans = write (s->fd, buf_st, bytes_left);
       if (trans < 0)
 	{
+#ifdef EINTR
 	  if (errno == EINTR)
 	    continue;
-	  else
-	    return trans;
+#endif
+	  return trans;
 	}
       buf_st += trans;
       bytes_left -= trans;
@@ -303,9 +433,9 @@ raw_close (unix_stream * s)
 {
   int retval;
   
-  if (s->fd != STDOUT_FILENO
-      && s->fd != STDERR_FILENO
-      && s->fd != STDIN_FILENO)
+  if (s->fd != GFC_STDOUT_FILENO
+      && s->fd != GFC_STDERR_FILENO
+      && s->fd != GFC_STDIN_FILENO)
     retval = close (s->fd);
   else
     retval = 0;
@@ -491,7 +621,11 @@ buf_seek (unix_stream * s, off_t offset, int whence)
     }
   if (offset < 0)
     {
+#ifdef __MINGW32CE__
+      SetLastError (ERROR_INVALID_PARAMETER);
+#else
       errno = EINVAL;
+#endif
       return -1;
     }
   s->logical_offset = offset;
@@ -656,7 +790,11 @@ mem_seek (stream * strm, off_t offset, int whence)
      negative offset, so don't check for that.  */
   if (offset > s->file_length)
     {
+#ifdef __MINGW32CE__
+      SetLastError (ERROR_INVALID_PARAMETER);
+#else
       errno = EINVAL;
+#endif
       return -1;
     }
 
@@ -751,6 +889,9 @@ open_internal (char *base, int length, gfc_offset offset)
 static stream *
 fd_to_stream (int fd, int prot)
 {
+#ifdef __MINGW32CE__
+  BY_HANDLE_FILE_INFORMATION fi;
+#endif
   struct stat statbuf;
   unix_stream *s;
 
@@ -765,7 +906,28 @@ fd_to_stream (int fd, int prot)
 
   /* Get the current length of the file. */
 
+#ifdef __MINGW32CE__
+  /* mingw32ce's implementation of fstat is currently incorrect.  */
+  statbuf.st_mode = 0;
+  statbuf.st_size = -1;
+  if (fd == GFC_STDIN_FILENO || fd == GFC_STDOUT_FILENO
+      || fd == GFC_STDERR_FILENO)
+    statbuf.st_mode = S_IFCHR;
+  else
+      if (GetFileInformationByHandle ((HANDLE) fd, &fi))
+	{
+	  if (fi.dwFileAttributes & FILE_ATTRIBUTE_DEVICE)
+	    statbuf.st_mode = S_IFCHR;
+	  else
+	    if (fi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+	      statbuf.st_mode = S_IFDIR;
+	    else
+	      statbuf.st_mode = S_IFREG;
+	  statbuf.st_size = fi.nFileSizeLow;
+	}
+#else
   fstat (fd, &statbuf);
+#endif
 
   if (lseek (fd, 0, SEEK_CUR) == (off_t) -1)
     s->file_length = -1;
@@ -774,14 +936,25 @@ fd_to_stream (int fd, int prot)
 
   s->special_file = !S_ISREG (statbuf.st_mode);
 
+#ifdef __MINGW32CE__
+  if (options.all_unbuffered
+      ||(options.unbuffered_preconnected &&
+         (s->fd == GFC_STDIN_FILENO
+          || s->fd == GFC_STDOUT_FILENO
+          || s->fd == GFC_STDERR_FILENO)))
+    raw_init (s);
+  else
+    buf_init (s);
+#else
   if (isatty (s->fd) || options.all_unbuffered
       ||(options.unbuffered_preconnected && 
-         (s->fd == STDIN_FILENO 
-          || s->fd == STDOUT_FILENO 
-          || s->fd == STDERR_FILENO)))
+         (s->fd == GFC_STDIN_FILENO
+          || s->fd == GFC_STDOUT_FILENO
+          || s->fd == GFC_STDERR_FILENO)))
     raw_init (s);
   else
     buf_init (s);
+#endif
 
   return (stream *) s;
 }
@@ -822,6 +995,55 @@ unpack_filename (char *cstring, const char *fstring, int len)
   return 0;
 }
 
+#ifdef __MINGW32CE__
+
+static char *
+ce_mktemp (char *temp)
+{
+  char *string = temp;
+  unsigned number;
+  int letter = 'a';
+  int xcount = 0;
+  DWORD old_lasterror;
+
+  number = GetCurrentProcessId ();
+
+  while (*string != '\0')
+    string++;
+
+  while (*--string == 'X')
+    {
+      xcount++;
+      *string = (char) ((number % 10) + '0');
+      number /= 10;
+    }
+
+  /* FIXME: process ids on CE are really handles/pointers, so 6 digits
+     isn't enough.  Write hex over the XXXXXX instead?  */
+  if (*++string == '\0' || xcount != 6)
+    return NULL;
+
+  old_lasterror = GetLastError ();
+  SetLastError (0);
+
+  while (access (temp, F_OK) == 0)
+    {
+      if (letter == 'z' + 1)
+	{
+	  temp = NULL;
+	  break;
+	}
+
+      SetLastError (0);
+      *string = (char) letter++;
+    }
+
+  SetLastError (old_lasterror);
+  return temp;
+}
+
+#define mktemp ce_mktemp
+#endif
 
 /* tempfile()-- Generate a temporary filename for a scratch file and
  * open it.  mkstemp() opens the file for reading and writing, but the
@@ -833,15 +1055,17 @@ unpack_filename (char *cstring, const char *fstring, int len)
 static int
 tempfile (st_parameter_open *opp)
 {
-  const char *tempdir;
+  const char *tempdir = NULL;
   char *template;
   int fd;
 
+#ifndef __MINGW32CE__
   tempdir = getenv ("GFORTRAN_TMPDIR");
   if (tempdir == NULL)
     tempdir = getenv ("TMP");
   if (tempdir == NULL)
     tempdir = getenv ("TEMP");
+#endif
   if (tempdir == NULL)
     tempdir = DEFAULT_TEMPDIR;
 
@@ -855,6 +1079,14 @@ tempfile (st_parameter_open *opp)
 
 #else /* HAVE_MKSTEMP */
 
+#ifndef __MINGW32CE__
+# define error_file_exists (errno == EEXIST)
+#else
+# define error_file_exists			\
+  (GetLastError () == ERROR_FILE_EXISTS		\
+   || GetLastError () == ERROR_ALREADY_EXISTS)
+#endif
+
   if (mktemp (template))
     do
 #if defined(HAVE_CRLF) && defined(O_BINARY)
@@ -863,13 +1095,14 @@ tempfile (st_parameter_open *opp)
 #else
       fd = open (template, O_RDWR | O_CREAT | O_EXCL, S_IREAD | S_IWRITE);
 #endif
-    while (!(fd == -1 && errno == EEXIST) && mktemp (template));
+    while (!(fd == -1 && error_file_exists) && mktemp (template));
   else
     fd = -1;
 
 #endif /* HAVE_MKSTEMP */
 
-  if (fd < 0)
+  /* Values < -1 are forbidden by POSIX but indicate success on Windows CE.  */
+  if (fd == -1)
     free_mem (template);
   else
     {
@@ -897,7 +1130,12 @@ regular_file (st_parameter_open *opp, unit_flags *flags)
 
   if (unpack_filename (path, opp->file, opp->file_len))
     {
-      errno = ENOENT;		/* Fake an OS error */
+      /* Fake an OS error */
+#ifndef __MINGW32CE__
+      errno = ENOENT;
+#else
+      SetLastError (ERROR_FILE_NOT_FOUND);
+#endif
       return -1;
     }
 
@@ -956,30 +1194,58 @@ regular_file (st_parameter_open *opp, unit_flags *flags)
   if (flags->action != ACTION_UNSPECIFIED)
     return fd;
 
-  if (fd >= 0)
+  /* Values < -1 are forbidden by POSIX but indicate success on Windows CE.  */
+  if (fd != -1)
     {
       flags->action = ACTION_READWRITE;
       return fd;
     }
+#ifndef __MINGW32CE__
   if (errno != EACCES && errno != EROFS)
-     return fd;
+    return fd;
+#else
+  switch (GetLastError ())
+    {
+    case ERROR_WRITE_PROTECT:
+    case ERROR_ACCESS_DENIED:
+    case ERROR_LOCK_VIOLATION:
+    case ERROR_SHARING_VIOLATION:
+      break;
+    default:
+      return fd;
+    }
+#endif
 
   /* retry for read-only access */
   rwflag = O_RDONLY;
   fd = open (path, rwflag | crflag, mode);
-  if (fd >=0)
+  /* Values < -1 are forbidden by POSIX but indicate success on Windows CE.  */
+  if (fd != -1)
     {
       flags->action = ACTION_READ;
       return fd;		/* success */
     }
   
+#ifndef __MINGW32CE__
   if (errno != EACCES)
     return fd;			/* failure */
+#else
+  switch (GetLastError ())
+    {
+    case ERROR_ACCESS_DENIED:
+    case ERROR_LOCK_VIOLATION:
+    case ERROR_SHARING_VIOLATION:
+      break;
+    default:
+      return fd;	        /* failure */
+    }
+#endif
 
   /* retry for write-only access */
   rwflag = O_WRONLY;
   fd = open (path, rwflag | crflag, mode);
-  if (fd >=0)
+  /* Values < -1 are forbidden by POSIX but indicate success on Windows CE.  */
+  if (fd != -1)
     {
       flags->action = ACTION_WRITE;
       return fd;		/* success */
@@ -1005,7 +1271,9 @@ open_external (st_parameter_open *opp, unit_flags *flags)
 
 #if HAVE_UNLINK_OPEN_FILE
       /* We can unlink scratch files now and it will go away when closed. */
-      if (fd >= 0)
+      /* Values < -1 are forbidden by POSIX but indicate success on Windows
+	 CE.  */
+      if (fd != -1)
 	unlink (opp->file);
 #endif
     }
@@ -1016,7 +1284,7 @@ open_external (st_parameter_open *opp, unit_flags *flags)
       fd = regular_file (opp, flags);
     }
 
-  if (fd < 0)
+  /* Values < -1 are forbidden by POSIX but indicate success on Windows CE.  */  if (fd == -1)
     return NULL;
   fd = fix_fd (fd);
 
@@ -1048,9 +1316,17 @@ open_external (st_parameter_open *opp, unit_flags *flags)
 stream *
 input_stream (void)
 {
-  return fd_to_stream (STDIN_FILENO, PROT_READ);
+  return fd_to_stream (GFC_STDIN_FILENO, PROT_READ);
 }
 
+#ifdef __MINGW32CE__
+/* libcoredll.a exports this, and MSDN claims it exists on CE, but,
+   the mingw32ce headers don't export it.  We should fix the headers.
+   Meanwhile, this is easier.  */
+# define setmode _setmode
+int _setmode (int, int);
+#define HAVE_SETMODE 1
+#endif
 
 /* output_stream()-- Return a stream pointer to the default output stream.
  * Called on initialization. */
@@ -1061,10 +1337,10 @@ output_stream (void)
   stream * s;
 
 #if defined(HAVE_CRLF) && defined(HAVE_SETMODE)
-  setmode (STDOUT_FILENO, O_BINARY);
+  setmode (GFC_STDOUT_FILENO, O_BINARY);
 #endif
 
-  s = fd_to_stream (STDOUT_FILENO, PROT_WRITE);
+  s = fd_to_stream (GFC_STDOUT_FILENO, PROT_WRITE);
   return s;
 }
 
@@ -1078,10 +1354,10 @@ error_stream (void)
   stream * s;
 
 #if defined(HAVE_CRLF) && defined(HAVE_SETMODE)
-  setmode (STDERR_FILENO, O_BINARY);
+  setmode (GFC_STDERR_FILENO, O_BINARY);
 #endif
 
-  s = fd_to_stream (STDERR_FILENO, PROT_WRITE);
+  s = fd_to_stream (GFC_STDERR_FILENO, PROT_WRITE);
   return s;
 }
 
@@ -1102,7 +1378,7 @@ st_vprintf (const char *format, va_list ap)
   int written;
   int fd;
 
-  fd = options.use_stderr ? STDERR_FILENO : STDOUT_FILENO;
+  fd = options.use_stderr ? GFC_STDERR_FILENO : GFC_STDOUT_FILENO;
 #ifdef HAVE_VSNPRINTF
   written = vsnprintf(buffer, ST_VPRINTF_SIZE, format, ap);
 #else
@@ -1369,7 +1645,11 @@ delete_file (gfc_unit * u)
 
   if (unpack_filename (path, u->file, u->file_len))
     {				/* Shouldn't be possible */
+#ifndef __MINGW32CE__
       errno = ENOENT;
+#else
+      SetLastError (ERROR_FILE_NOT_FOUND);
+#endif
       return 1;
     }
 
@@ -1515,10 +1795,11 @@ inquire_unformatted (const char *string, int len)
 static int
 fallback_access (const char *path, int mode)
 {
-  if ((mode & R_OK) && open (path, O_RDONLY) < 0)
+  /* Values < -1 are forbidden by POSIX but indicate success on Windows CE.  */
+  if ((mode & R_OK) && open (path, O_RDONLY) == -1)
     return -1;
 
-  if ((mode & W_OK) && open (path, O_WRONLY) < 0)
+  if ((mode & W_OK) && open (path, O_WRONLY) == -1)
     return -1;
 
   return 0;
@@ -1616,7 +1897,13 @@ is_special (stream *s)
 int
 stream_isatty (stream *s)
 {
+#ifdef __MINGW32CE__
+  return (((unix_stream *) s)->fd == GFC_STDIN_FILENO
+	  || ((unix_stream *) s)->fd == GFC_STDOUT_FILENO
+	  || ((unix_stream *) s)->fd == GFC_STDERR_FILENO);
+#else
   return isatty (((unix_stream *) s)->fd);
+#endif
 }
 
 char *
diff --git a/libgfortran/io/write.c b/libgfortran/io/write.c
index 730f08173..1312b08c2 100644
--- a/libgfortran/io/write.c
+++ b/libgfortran/io/write.c
@@ -31,7 +31,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include <ctype.h>
 #include <stdlib.h>
 #include <stdbool.h>
+#if HAVE_ERRNO_H
 #include <errno.h>
+#endif
 #define star_fill(p, n) memset(p, '*', n)
 
 #include "write_float.def"
@@ -325,7 +327,7 @@ write_a_char4 (st_parameter_dt *dtp, const fnode *f, const char *source, int len
 		}
 
 	      /* Write out the CR_LF sequence.  */ 
-	      write_default_char4 (dtp, crlf, 2, 0);
+	      write_default_char4 (dtp, (gfc_char4_t *) crlf, 2, 0);
 	    }
 	  else
 	    bytes++;
diff --git a/libgfortran/io/write_float.def b/libgfortran/io/write_float.def
index 557364a2f..ae5ccd54e 100644
--- a/libgfortran/io/write_float.def
+++ b/libgfortran/io/write_float.def
@@ -752,6 +752,11 @@ sprintf (buffer, "%+-#" STR(MIN_FIELD_WIDTH) ".*" \
 
 #endif
 
+#if defined (__MINGW32CE__) && !defined (signbit)
+/* Should use __builtin_signbit on all targets? */
+# define signbit(x) __builtin_signbit (x)
+#endif
+
 #define WRITE_FLOAT(x,y)\
 {\
 	GFC_REAL_ ## x tmp;\
diff --git a/libgfortran/libgfortran.h b/libgfortran/libgfortran.h
index 3591fa9c2..13d4ab328 100644
--- a/libgfortran/libgfortran.h
+++ b/libgfortran/libgfortran.h
@@ -659,6 +659,12 @@ internal_proto(internal_error);
 extern const char *get_oserror (void);
 internal_proto(get_oserror);
 
+extern GFC_INTEGER_4 get_oserrno (void);
+internal_proto(get_oserrno);
+
+extern void clear_oserrno (void);
+internal_proto(clear_oserrno);
+
 extern const char *translate_error (int);
 internal_proto(translate_error);
 
diff --git a/libgfortran/runtime/environ.c b/libgfortran/runtime/environ.c
index a6ce645e0..f8abd0b28 100644
--- a/libgfortran/runtime/environ.c
+++ b/libgfortran/runtime/environ.c
@@ -41,6 +41,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 options_t options;
 
+#ifdef __MINGW32CE__
+/* No environ on CE.  Force all defaults.  */
+static char *
+ce_getenv (const char *name __attribute ((unused)))
+{
+  return NULL;
+}
+#define getenv ce_getenv
+#endif
 
 typedef struct variable
 {
diff --git a/libgfortran/runtime/error.c b/libgfortran/runtime/error.c
index 07da6df36..6e8364d6a 100644
--- a/libgfortran/runtime/error.c
+++ b/libgfortran/runtime/error.c
@@ -27,7 +27,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "libgfortran.h"
 #include <assert.h>
 #include <string.h>
-#include <errno.h>
 
 #ifdef HAVE_SIGNAL_H
 #include <signal.h>
@@ -398,7 +397,7 @@ generate_error (st_parameter_common *cmp, int family, const char *message)
 
   /* Set the error status.  */
   if ((cmp->flags & IOPARM_HAS_IOSTAT))
-    *cmp->iostat = (family == LIBERROR_OS) ? errno : family;
+    *cmp->iostat = (family == LIBERROR_OS) ? get_oserrno () : family;
 
   if (message == NULL)
     message =
diff --git a/libgfortran/runtime/main.c b/libgfortran/runtime/main.c
index 3cccc3d03..e6d12fe0c 100644
--- a/libgfortran/runtime/main.c
+++ b/libgfortran/runtime/main.c
@@ -104,7 +104,8 @@ store_exe_path (const char * argv0)
 #define DIR_SEPARATOR '/'
 #endif
 
-  char buf[PATH_MAX], *cwd, *path;
+  char buf[PATH_MAX], *path;
+  const char *cwd;
 
   /* On the simulator argv is not set.  */
   if (argv0 == NULL || argv0[0] == '/')
diff --git a/libgomp/Makefile.am b/libgomp/Makefile.am
index d1967a028..bdf34fe96 100644
--- a/libgomp/Makefile.am
+++ b/libgomp/Makefile.am
@@ -1,5 +1,10 @@
 ## Process this file with automake to produce Makefile.in
 
+datarootdir = @datarootdir@
+docdir = @docdir@
+htmldir = @htmldir@
+pdfdir = @pdfdir@
+
 ACLOCAL_AMFLAGS = -I .. -I ../config
 SUBDIRS = testsuite
 
@@ -41,6 +46,12 @@ if USE_FORTRAN
 nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod
 endif
 
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+
+LINK = $(LIBTOOL) --tag CC --mode=link $(CCLD) $(AM_CCFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LTLDFLAGS) -o $@
+
+
 omp_lib_kinds.mod: omp_lib.mod
 	:
 omp_lib.mod: omp_lib.f90
@@ -50,10 +61,30 @@ fortran.o: libgomp_f.h
 env.lo: libgomp_f.h
 env.o: libgomp_f.h
 
+HTMLS_INSTALL=libgomp
+HTMLS_BUILD=libgomp/index.html
 
-# No install-html or install-pdf support in automake yet
-.PHONY: install-html install-pdf
-install-html:
+$(HTMLS_BUILD): $(info_TEXINFOS)
+	$(TEXI2HTML) $(MAKEINFOFLAGS) -I$(srcdir) -o $(@D) $<
+
+html__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+
+install-html: $(HTMLS_BUILD)
+	@$(NORMAL_INSTALL)
+	test -z "$(htmldir)" || $(mkinstalldirs) "$(DESTDIR)$(htmldir)"
+	@list='$(HTMLS_INSTALL)'; for p in $$list; do \
+	  if test -f "$$p" || test -d "$$p"; then d=""; else d="$(srcdir)/"; fi; \
+	  f=$(html__strip_dir) \
+	  if test -d "$$d$$p"; then \
+	    echo " $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(mkinstalldirs) "$(DESTDIR)$(htmldir)/$$f" || exit 1; \
+	    echo " $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p"/* "$(DESTDIR)$(htmldir)/$$f"; \
+	  else \
+	    echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(htmldir)/$$f"; \
+	  fi; \
+	done
 
 install-pdf: $(PDFS)
 	@$(NORMAL_INSTALL)
@@ -71,6 +102,7 @@ install-pdf: $(PDFS)
 # `texinfo.tex' for your package. The value of this variable should be
 # the relative path from the current `Makefile.am' to `texinfo.tex'.
 TEXINFO_TEX   = ../gcc/doc/include/texinfo.tex
+TEXI2HTML = $(MAKEINFO) --html
 
 # Defines info, dvi, pdf and html targets
 MAKEINFOFLAGS = -I $(srcdir)/../gcc/doc/include
diff --git a/libgomp/Makefile.in b/libgomp/Makefile.in
index ef9b42f25..a6bbf7808 100644
--- a/libgomp/Makefile.in
+++ b/libgomp/Makefile.in
@@ -97,8 +97,6 @@ LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
 	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 SOURCES = $(libgomp_la_SOURCES)
 MULTISRCTOP = 
 MULTIBUILDTOP = 
@@ -247,6 +245,8 @@ build_os = @build_os@
 build_vendor = @build_vendor@
 config_path = @config_path@
 datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
@@ -255,6 +255,7 @@ host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
+htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
@@ -268,6 +269,7 @@ mandir = @mandir@
 mkdir_p = @mkdir_p@
 multi_basedir = @multi_basedir@
 oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 sbindir = @sbindir@
@@ -305,6 +307,13 @@ libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \
 nodist_noinst_HEADERS = libgomp_f.h
 nodist_libsubinclude_HEADERS = omp.h
 @USE_FORTRAN_TRUE@nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+LINK = $(LIBTOOL) --tag CC --mode=link $(CCLD) $(AM_CCFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LTLDFLAGS) -o $@
+
+HTMLS_INSTALL = libgomp
+HTMLS_BUILD = libgomp/index.html
+html__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
 
 # Automake Documentation:
 # If your package has Texinfo files in many directories, you can use the
@@ -312,6 +321,7 @@ nodist_libsubinclude_HEADERS = omp.h
 # `texinfo.tex' for your package. The value of this variable should be
 # the relative path from the current `Makefile.am' to `texinfo.tex'.
 TEXINFO_TEX = ../gcc/doc/include/texinfo.tex
+TEXI2HTML = $(MAKEINFO) --html
 
 # Defines info, dvi, pdf and html targets
 MAKEINFOFLAGS = -I $(srcdir)/../gcc/doc/include
@@ -924,9 +934,25 @@ fortran.o: libgomp_f.h
 env.lo: libgomp_f.h
 env.o: libgomp_f.h
 
-# No install-html or install-pdf support in automake yet
-.PHONY: install-html install-pdf
-install-html:
+$(HTMLS_BUILD): $(info_TEXINFOS)
+	$(TEXI2HTML) $(MAKEINFOFLAGS) -I$(srcdir) -o $(@D) $<
+
+install-html: $(HTMLS_BUILD)
+	@$(NORMAL_INSTALL)
+	test -z "$(htmldir)" || $(mkinstalldirs) "$(DESTDIR)$(htmldir)"
+	@list='$(HTMLS_INSTALL)'; for p in $$list; do \
+	  if test -f "$$p" || test -d "$$p"; then d=""; else d="$(srcdir)/"; fi; \
+	  f=$(html__strip_dir) \
+	  if test -d "$$d$$p"; then \
+	    echo " $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(mkinstalldirs) "$(DESTDIR)$(htmldir)/$$f" || exit 1; \
+	    echo " $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p"/* "$(DESTDIR)$(htmldir)/$$f"; \
+	  else \
+	    echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(htmldir)/$$f"; \
+	  fi; \
+	done
 
 install-pdf: $(PDFS)
 	@$(NORMAL_INSTALL)
diff --git a/libgomp/configure b/libgomp/configure
index 3274f1fc1..fab5079e4 100755
--- a/libgomp/configure
+++ b/libgomp/configure
@@ -457,7 +457,7 @@ ac_includes_default="\
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS GENINSRC_TRUE GENINSRC_FALSE build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar multi_basedir toolexecdir toolexeclibdir CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS AR ac_ct_AR RANLIB ac_ct_RANLIB PERL BUILD_INFO_TRUE BUILD_INFO_FALSE LIBTOOL SED EGREP FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM LN_S OBJDUMP ac_ct_OBJDUMP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CPP CPPFLAGS enable_shared enable_static MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT FC FCFLAGS LDFLAGS ac_ct_FC libtool_VERSION SECTION_LDFLAGS OPT_LDFLAGS LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE config_path XCFLAGS XLDFLAGS link_gomp USE_FORTRAN_TRUE USE_FORTRAN_FALSE OMP_LOCK_SIZE OMP_LOCK_ALIGN OMP_NEST_LOCK_SIZE OMP_NEST_LOCK_ALIGN OMP_LOCK_KIND OMP_NEST_LOCK_KIND OMP_LOCK_25_SIZE OMP_LOCK_25_ALIGN OMP_NEST_LOCK_25_SIZE OMP_NEST_LOCK_25_ALIGN OMP_LOCK_25_KIND OMP_NEST_LOCK_25_KIND LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS GENINSRC_TRUE GENINSRC_FALSE build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar multi_basedir toolexecdir toolexeclibdir datarootdir docdir pdfdir htmldir CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS AR ac_ct_AR RANLIB ac_ct_RANLIB PERL BUILD_INFO_TRUE BUILD_INFO_FALSE LIBTOOL SED EGREP FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM LN_S OBJDUMP ac_ct_OBJDUMP lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CPP CPPFLAGS enable_shared enable_static MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT FC FCFLAGS LDFLAGS ac_ct_FC libtool_VERSION SECTION_LDFLAGS OPT_LDFLAGS LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE config_path XCFLAGS XLDFLAGS link_gomp USE_FORTRAN_TRUE USE_FORTRAN_FALSE OMP_LOCK_SIZE OMP_LOCK_ALIGN OMP_NEST_LOCK_SIZE OMP_NEST_LOCK_ALIGN OMP_LOCK_KIND OMP_NEST_LOCK_KIND OMP_LOCK_25_SIZE OMP_LOCK_25_ALIGN OMP_NEST_LOCK_25_SIZE OMP_NEST_LOCK_25_ALIGN OMP_LOCK_25_KIND OMP_NEST_LOCK_25_KIND LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 ac_pwd=`pwd`
 
@@ -1029,6 +1029,10 @@ Optional Features:
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-datarootdir=DIR  Use DIR as the data root [PREFIX/share]
+  --with-docdir=DIR       Install documentation in DIR [DATAROOTDIR]
+  --with-pdfdir           install pdf in this directory.
+  --with-htmldir=DIR      html documentation in in DIR [DOCDIR]
   --with-pic              try to use only PIC/non-PIC objects [default=use
                           both]
   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
@@ -2201,6 +2205,46 @@ esac
 
 
 
+
+# Check whether --with-datarootdir or --without-datarootdir was given.
+if test "${with_datarootdir+set}" = set; then
+  withval="$with_datarootdir"
+  datarootdir="\${prefix}/$with_datarootdir"
+else
+  datarootdir='$(prefix)/share'
+fi;
+
+
+
+# Check whether --with-docdir or --without-docdir was given.
+if test "${with_docdir+set}" = set; then
+  withval="$with_docdir"
+  docdir="\${prefix}/$with_docdir"
+else
+  docdir='$(datarootdir)'
+fi;
+
+
+
+# Check whether --with-pdfdir or --without-pdfdir was given.
+if test "${with_pdfdir+set}" = set; then
+  withval="$with_pdfdir"
+  pdfdir="\${prefix}/${withval}"
+else
+  pdfdir="\${docdir}"
+fi;
+
+
+
+# Check whether --with-htmldir or --without-htmldir was given.
+if test "${with_htmldir+set}" = set; then
+  withval="$with_htmldir"
+  htmldir="\${prefix}/$with_htmldir"
+else
+  htmldir='$(docdir)'
+fi;
+
+
 # Check the compiler.
 # The same as in boehm-gc and libstdc++. Have to borrow it from there.
 # We must force CC to /not/ be precious variables; otherwise
@@ -4156,13 +4200,13 @@ if test "${lt_cv_nm_interface+set}" = set; then
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:4159: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:4203: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:4162: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:4206: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:4165: output\"" >&5)
+  (eval echo "\"\$as_me:4209: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
@@ -5320,7 +5364,7 @@ ia64-*-hpux*)
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 5323 "configure"' > conftest.$ac_ext
+  echo '#line 5367 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -7101,11 +7145,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7104: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7148: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7108: \$? = $ac_status" >&5
+   echo "$as_me:7152: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -7440,11 +7484,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7443: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7487: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7447: \$? = $ac_status" >&5
+   echo "$as_me:7491: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -7545,11 +7589,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7548: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7592: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:7552: \$? = $ac_status" >&5
+   echo "$as_me:7596: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -7600,11 +7644,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7603: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7647: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:7607: \$? = $ac_status" >&5
+   echo "$as_me:7651: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -10412,7 +10456,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10415 "configure"
+#line 10459 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10508,7 +10552,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10511 "configure"
+#line 10555 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10859,7 +10903,7 @@ fi
 
 
 # Provide some information about the compiler.
-echo "$as_me:10862:" \
+echo "$as_me:10906:" \
      "checking for Fortran compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
 { (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
@@ -11095,7 +11139,7 @@ fi
 
 
 # Provide some information about the compiler.
-echo "$as_me:11098:" \
+echo "$as_me:11142:" \
      "checking for Fortran compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
 { (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
@@ -11835,11 +11879,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:11838: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:11882: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:11842: \$? = $ac_status" >&5
+   echo "$as_me:11886: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -11934,11 +11978,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:11937: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:11981: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:11941: \$? = $ac_status" >&5
+   echo "$as_me:11985: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -11986,11 +12030,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:11989: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:12033: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:11993: \$? = $ac_status" >&5
+   echo "$as_me:12037: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -15133,7 +15177,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15197,7 +15242,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15238,7 +15284,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15295,7 +15342,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15336,7 +15384,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15401,7 +15450,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15469,7 +15519,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (void *)); }
 unsigned long ulongval () { return (long) (sizeof (void *)); }
 #include <stdio.h>
@@ -15557,7 +15608,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15621,7 +15673,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15662,7 +15715,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15719,7 +15773,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15760,7 +15815,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15825,7 +15881,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -15893,7 +15950,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (long)); }
 unsigned long ulongval () { return (long) (sizeof (long)); }
 #include <stdio.h>
@@ -15981,7 +16039,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16045,7 +16104,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16086,7 +16146,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16143,7 +16204,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16184,7 +16246,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16249,7 +16312,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16317,7 +16381,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (int)); }
 unsigned long ulongval () { return (long) (sizeof (int)); }
 #include <stdio.h>
@@ -16401,7 +16466,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16465,7 +16531,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16506,7 +16573,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16563,7 +16631,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16604,7 +16673,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16669,7 +16739,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16737,7 +16808,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (short)); }
 unsigned long ulongval () { return (long) (sizeof (short)); }
 #include <stdio.h>
@@ -16821,7 +16893,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16885,7 +16958,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16926,7 +17000,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -16983,7 +17058,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17024,7 +17100,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17089,7 +17166,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -17157,7 +17235,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (char)); }
 unsigned long ulongval () { return (long) (sizeof (char)); }
 #include <stdio.h>
@@ -17859,6 +17938,7 @@ fi
 
 # See if we support thread-local storage.
 
+
    # Check whether --enable-tls or --disable-tls was given.
 if test "${enable_tls+set}" = set; then
   enableval="$enable_tls"
@@ -17885,6 +17965,64 @@ else
 __thread int a; int b; int main() { return a = b; }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>conftest.er1
   ac_status=$?
@@ -17911,6 +18049,24 @@ else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 gcc_cv_have_tls=no
 fi
 rm -f conftest.err conftest.$ac_objext \
@@ -22801,6 +22957,10 @@ s,@am__untar@,$am__untar,;t t
 s,@multi_basedir@,$multi_basedir,;t t
 s,@toolexecdir@,$toolexecdir,;t t
 s,@toolexeclibdir@,$toolexeclibdir,;t t
+s,@datarootdir@,$datarootdir,;t t
+s,@docdir@,$docdir,;t t
+s,@pdfdir@,$pdfdir,;t t
+s,@htmldir@,$htmldir,;t t
 s,@CC@,$CC,;t t
 s,@ac_ct_CC@,$ac_ct_CC,;t t
 s,@EXEEXT@,$EXEEXT,;t t
diff --git a/libgomp/configure.ac b/libgomp/configure.ac
index dbf171830..9c25e4f9d 100644
--- a/libgomp/configure.ac
+++ b/libgomp/configure.ac
@@ -94,6 +94,30 @@ esac
 AC_SUBST(toolexecdir)
 AC_SUBST(toolexeclibdir)
 
+AC_ARG_WITH(datarootdir,
+[  --with-datarootdir=DIR  Use DIR as the data root [[PREFIX/share]]],
+datarootdir="\${prefix}/$with_datarootdir",
+datarootdir='$(prefix)/share')
+AC_SUBST(datarootdir)
+
+AC_ARG_WITH(docdir,
+[  --with-docdir=DIR       Install documentation in DIR [[DATAROOTDIR]]],
+docdir="\${prefix}/$with_docdir",
+docdir='$(datarootdir)')
+AC_SUBST(docdir)
+
+AC_ARG_WITH(pdfdir,
+[  --with-pdfdir           install pdf in this directory.],
+[pdfdir="\${prefix}/${withval}"],
+[pdfdir="\${docdir}"])
+AC_SUBST(pdfdir)
+
+AC_ARG_WITH(htmldir,
+[  --with-htmldir=DIR      html documentation in in DIR [[DOCDIR]]],
+htmldir="\${prefix}/$with_htmldir",
+htmldir='$(docdir)')
+AC_SUBST(htmldir)
+
 # Check the compiler.
 # The same as in boehm-gc and libstdc++. Have to borrow it from there.
 # We must force CC to /not/ be precious variables; otherwise
diff --git a/libgomp/libgomp.texi b/libgomp/libgomp.texi
index 5e68aad62..44c96f3f6 100644
--- a/libgomp/libgomp.texi
+++ b/libgomp/libgomp.texi
@@ -94,7 +94,7 @@ for multi-platform shared-memory parallel programming in C/C++ and Fortran.
                                How you can copy and share this manual.
 * Funding::                    How to help assure continued work for free 
                                software.
-* Index::                      Index of this documentation.
+* Library Index::              Index of this documentation.
 @end menu
 
 
@@ -1713,8 +1713,8 @@ Bugs in the GNU OpenMP implementation should be reported via
 @c Index
 @c ---------------------------------------------------------------------
 
-@node Index
-@unnumbered Index
+@node Library Index
+@unnumbered Library Index
 
 @printindex cp
 
diff --git a/libgomp/testsuite/Makefile.in b/libgomp/testsuite/Makefile.in
index 284fa75cd..c4e0da591 100644
--- a/libgomp/testsuite/Makefile.in
+++ b/libgomp/testsuite/Makefile.in
@@ -177,6 +177,8 @@ build_os = @build_os@
 build_vendor = @build_vendor@
 config_path = @config_path@
 datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
@@ -185,6 +187,7 @@ host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
+htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
@@ -198,6 +201,7 @@ mandir = @mandir@
 mkdir_p = @mkdir_p@
 multi_basedir = @multi_basedir@
 oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 sbindir = @sbindir@
diff --git a/libiberty/Makefile.in b/libiberty/Makefile.in
index f68a7a662..81f7dca3e 100644
--- a/libiberty/Makefile.in
+++ b/libiberty/Makefile.in
@@ -124,7 +124,7 @@ COMPILE.c = $(CC) -c @DEFS@ $(CFLAGS) $(CPPFLAGS) -I. -I$(INCDIR) $(HDEFINES) @a
 CFILES = alloca.c argv.c asprintf.c atexit.c				\
 	basename.c bcmp.c bcopy.c bsearch.c bzero.c			\
 	calloc.c choose-temp.c clock.c concat.c cp-demangle.c		\
-	 cp-demint.c cplus-dem.c					\
+	 cp-demint.c cplus-dem.c cygpath.c				\
 	dyn-string.c							\
 	fdmatch.c ffs.c fibheap.c filename_cmp.c floatformat.c		\
 	fnmatch.c fopen_unlocked.c					\
@@ -182,7 +182,7 @@ REQUIRED_OFILES =							\
 # maint-missing" and "make check".
 CONFIGURED_OFILES = ./asprintf.o ./atexit.o				\
 	./basename.o ./bcmp.o ./bcopy.o ./bsearch.o ./bzero.o		\
-	./calloc.o ./clock.o ./copysign.o				\
+	./calloc.o ./clock.o ./copysign.o ./cygpath.o			\
 	./_doprnt.o							\
 	./ffs.o								\
 	./getcwd.o ./getpagesize.o ./gettimeofday.o			\
@@ -620,6 +620,13 @@ $(CONFIGURED_OFILES): stamp-picdir
 	else true; fi
 	$(COMPILE.c) $(srcdir)/cplus-dem.c $(OUTPUT_OPTION)
 
+./cygpath.o: $(srcdir)/cygpath.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cygpath.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cygpath.c $(OUTPUT_OPTION)
+
 ./dyn-string.o: $(srcdir)/dyn-string.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/dyn-string.h $(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
diff --git a/libiberty/argv.c b/libiberty/argv.c
index 38bd44970..3084248b9 100644
--- a/libiberty/argv.c
+++ b/libiberty/argv.c
@@ -119,6 +119,24 @@ void freeargv (char **vector)
     }
 }
 
+static void
+consume_whitespace (const char **input)
+{
+  while (ISSPACE (**input))
+    {
+      (*input)++;
+    }
+}
+
+static int
+only_whitespace (const char* input)
+{
+  while (*input != EOS && ISSPACE (*input))
+    input++;
+
+  return (*input == EOS);
+}
+
 /*
 
 @deftypefn Extension char** buildargv (char *@var{sp})
@@ -179,10 +197,8 @@ char **buildargv (const char *input)
       do
 	{
 	  /* Pick off argv[argc] */
-	  while (ISBLANK (*input))
-	    {
-	      input++;
-	    }
+	  consume_whitespace (&input);
+
 	  if ((maxargc == 0) || (argc >= (maxargc - 1)))
 	    {
 	      /* argv needs initialization, or expansion */
@@ -278,10 +294,7 @@ char **buildargv (const char *input)
 	  argc++;
 	  argv[argc] = NULL;
 
-	  while (ISSPACE (*input))
-	    {
-	      input++;
-	    }
+	  consume_whitespace (&input);
 	}
       while (*input != EOS);
     }
@@ -420,8 +433,17 @@ expandargv (int *argcp, char ***argvp)
 	goto error;
       /* Add a NUL terminator.  */
       buffer[len] = '\0';
-      /* Parse the string.  */
-      file_argv = buildargv (buffer);
+      /* If the file is empty or contains only whitespace, buildargv would
+	 return a single empty argument.  In this context we want no arguments,
+	 instead.  */
+      if (only_whitespace (buffer))
+	{
+	  file_argv = (char **) xmalloc (sizeof (char *));
+	  file_argv[0] = NULL;
+	}
+      else
+	/* Parse the string.  */
+	file_argv = buildargv (buffer);
       /* If *ARGVP is not already dynamically allocated, copy it.  */
       if (!argv_dynamic)
 	{
@@ -434,7 +456,7 @@ expandargv (int *argcp, char ***argvp)
 	}
       /* Count the number of arguments.  */
       file_argc = 0;
-      while (file_argv[file_argc] && *file_argv[file_argc])
+      while (file_argv[file_argc])
 	++file_argc;
       /* Now, insert FILE_ARGV into ARGV.  The "+1" below handles the
 	 NULL terminator at the end of ARGV.  */ 
diff --git a/libiberty/configure b/libiberty/configure
index 4cdcd7219..c5d723395 100755
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -8891,6 +8891,20 @@ case "${host}" in
 esac
 
 
+# On MinGW, add support for Cygwin paths.
+case "${host}" in
+     *-*-mingw*)
+	case $LIBOBJS in
+    "cygpath.$ac_objext"   | \
+  *" cygpath.$ac_objext"   | \
+    "cygpath.$ac_objext "* | \
+  *" cygpath.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS cygpath.$ac_objext" ;;
+esac
+
+	;;
+esac
+
 if test x$gcc_no_link = xyes; then
   if test "x${ac_cv_func_mmap_fixed_mapped+set}" != xset; then
     ac_cv_func_mmap_fixed_mapped=no
diff --git a/libiberty/configure.ac b/libiberty/configure.ac
index fac534762..dddae15ac 100644
--- a/libiberty/configure.ac
+++ b/libiberty/configure.ac
@@ -663,6 +663,13 @@ case "${host}" in
 esac
 AC_SUBST(pexecute)
 
+# On MinGW, add support for Cygwin paths.
+case "${host}" in
+     *-*-mingw*)
+	AC_LIBOBJ([cygpath])
+	;;
+esac
+
 libiberty_AC_FUNC_STRNCMP
 
 # Install a library built with a cross compiler in $(tooldir) rather
diff --git a/libiberty/cygpath.c b/libiberty/cygpath.c
new file mode 100644
index 000000000..e3cb41d55
--- /dev/null
+++ b/libiberty/cygpath.c
@@ -0,0 +1,684 @@
+/* Support Cygwin paths under MinGW.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   Written by CodeSourcery.
+
+This file is part of the libiberty library.
+Libiberty is free software; you can redistribute it and/or modify it
+under the terms of the GNU Library General Public License as published
+by the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+Libiberty is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with libiberty; see the file COPYING.LIB.  If not, write
+to the Free Software Foundation, Inc., 51 Franklin Street - Fifth
+Floor, Boston, MA 02110-1301, USA.  */
+
+#include <windows.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <io.h>
+#include <process.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "libiberty.h"
+
+/* If non-zero, we have attempted to use cygpath.  CYGPATH_PEX may
+   still be NULL, if cygpath is unavailable.  */
+static int cygpath_initialized;
+
+/* If non-NULL, an instance of cygpath connected via a pipe.  */
+static struct pex_obj *cygpath_pex;
+
+/* The input to cygpath.  */
+static FILE *cygpath_in;
+
+/* The output from cygpath.  */
+static FILE *cygpath_out;
+
+/* If non-NULL, a file to which path translations are logged.  */
+static FILE *cygpath_log;
+
+/* Record MESSAGE in the CYGPATH_LOG.  MESSAGE is a format string,
+   which is expected to have a single "%s" field, to be replaced by
+   ARG.  */
+static void
+cygpath_log_msg_arg (const char *message, const char *arg)
+{
+  if (!cygpath_log)
+    return;
+  fprintf (cygpath_log, "[%d] cygpath: ", _getpid ());
+  fprintf (cygpath_log, message, arg);
+  fprintf (cygpath_log, "\n");
+  fflush (cygpath_log);
+}
+
+/* Record MESSAGE in the CYGPATH_LOG.  */
+static void
+cygpath_log_msg (const char *message)
+{
+  cygpath_log_msg_arg ("%s", message);
+}
+
+/* An error has occured.  Add the MESSAGE to the CYGPATH_LOG, noting
+   the cause of the error based on errno.  */
+static void
+cygpath_perror (const char *message)
+{
+  if (!cygpath_log)
+    return;
+  fprintf (cygpath_log, "[%d] cygpath: error: %s: %s\n",
+	   _getpid(), message, strerror (errno));
+  fflush (cygpath_log);
+}
+
+/* Closes CYGPATH_PEX and frees all associated
+   resoures.  */
+static void
+cygpath_close (void)
+{
+  /* Free resources.  */
+  if (cygpath_out)
+    {
+      fclose (cygpath_out);
+      cygpath_out = NULL;
+    }
+  if (cygpath_in)
+    {
+      fclose (cygpath_in);
+      cygpath_in = NULL;
+    }
+  if (cygpath_pex)
+    {
+      pex_free (cygpath_pex);
+      cygpath_pex = NULL;
+    }
+  if (cygpath_log)
+    {
+      cygpath_log_msg ("end");
+      cygpath_log = NULL;
+    }
+}
+
+/* CYG_PATH is a pointer to a Cygwin path.  This function converts the
+   Cygwin path to a Windows path, storing the result in
+   WIN32_PATH.  Returns true if the conversion was successful; false
+   otherwise.  */
+int
+cygpath (const char *cyg_path, char win32_path[MAX_PATH + 1])
+{
+  bool ok;
+  bool retrying;
+  
+  /* Special-case the empty path.  cygpath cannot handle the empty
+     path correctly.  It ignores the empty line, waiting for a
+     non-empty line, which in turn causes an application using this
+     function to appear stuck.  */
+  if (cyg_path[0] == '\0')
+    {
+      win32_path[0] = '\0';
+      return true;
+    }
+  
+  retrying = false;
+
+ retry:
+  if (!cygpath_initialized) 
+    {
+      const char *argv[] = { "cygpath", "-w", "-f", "-", NULL };
+      const char *cygpath_path;
+      const char *log;
+      int err;
+
+      /* If we are unable to invoke cygpath, we do not want to try
+	 again.  So, we set the initialized flag at this point; if
+	 errors occur during the invocation, it will remain set.  */
+      cygpath_initialized = 1;
+      /* Check to see if the user wants cygpath support.  */
+      cygpath_path = getenv ("CYGPATH");
+      if (!cygpath_path)
+	/* The user doesn't need to support Cygwin paths.  */
+	goto error;
+      /* If debugging, open the log file.  */
+      log = getenv ("CSL_DEBUG_CYGPATH");
+      if (log && log[0])
+	{
+	  /* The log file is opened for "append" so that multiple
+	     processes (perhaps invoked from "make") can share it.  */
+	  cygpath_log = fopen (log, "a");
+	  if (cygpath_log)
+	    cygpath_log_msg ("begin");
+	}
+      /* If the environment variable is set to a non-empty string, use
+	 that string as the path to cygpath.  */ 
+      if (cygpath_path[0] != '\0')
+	argv[0] = cygpath_path;
+      /* Create the pex object.  */
+      cygpath_pex = pex_init (PEX_SEARCH | PEX_USE_PIPES, 
+			      "cygpath", NULL);
+      if (!cygpath_pex)
+	goto error;
+      /* Get the FILE we will use to write to the child.  */
+      cygpath_in = pex_input_pipe (cygpath_pex, /*binary=*/0);
+      if (!cygpath_in)
+	goto error;
+      /* Start the child process.  */
+      if (pex_run (cygpath_pex, PEX_SEARCH | PEX_USE_PIPES, 
+		   argv[0], (char**) argv, 
+		   NULL, NULL,
+		   &err) != NULL)
+	goto error;
+      /* Get the FILE we will use to read from the child.  */
+      cygpath_out = pex_read_output (cygpath_pex, /*binary=*/1);
+      if (!cygpath_out)
+	goto error;
+    }
+  else if (!cygpath_pex) 
+    /* We previously tried to use cygpath, but something went wrong.  */
+    return false;
+
+  /* Write CYG_PATH to the child, on a line by itself.  */
+  cygpath_log_msg_arg ("-> %s", cyg_path);
+  if (fprintf (cygpath_in, "%s\n", cyg_path) < 0)
+    {
+      cygpath_perror ("write failed");
+      goto error;
+    }
+  /* Flush the output.  (We cannot set the stream into line-buffered
+     mode with setvbuf because Windows treats _IOLBF as a synonym for
+     _IOFBF.)  */
+  if (fflush (cygpath_in))
+    cygpath_perror ("flush failed");
+  /* Read the output.  */
+  ok = true;
+  while (1)
+    {
+      size_t pathlen;
+      if (!fgets (win32_path, MAX_PATH, cygpath_out))
+	{
+	  if (ferror (cygpath_out))
+	    cygpath_perror ("read failed");
+	  else
+	    {
+	      cygpath_log_msg ("error: EOF");
+	      /* Unfortunately, cygpath sometimes crashes for no
+		 apparent reason.  We give it two chances... */
+	      if (!retrying)
+		{
+		  retrying = true;
+		  cygpath_log_msg ("retrying");
+		  cygpath_close ();
+		  cygpath_initialized = 0;
+		  goto retry;
+		}
+	      else
+		{
+		  /* Give up, but in case the error is specific to
+		     this path, reopen at the next request.  */
+		  cygpath_close ();
+		  cygpath_initialized = 0;
+		}
+	    }
+	  goto error;
+	}
+      pathlen = strlen (win32_path);
+      if (pathlen == 0 && ok)
+	/* This isn't a well-formed response from cygpath.  */
+	goto error;
+      if (win32_path[pathlen - 1] == '\n')
+	{
+	  win32_path[pathlen - 1] = '\0';
+	  cygpath_log_msg_arg ("<- %s", win32_path);
+	  break;
+	}
+      /* We didn't reach the end of the line.  There's no point in
+	 trying to use this output, since we know the length of
+	 paths are limited to MAX_PATH characters, but we read the
+	 entire line so that we are still in sync with
+	 cygpath.  */
+      ok = false;
+      if (cygpath_log)
+	cygpath_log_msg_arg ("error: invalid response: %s",
+			     win32_path);
+    }
+  
+  return ok;
+  
+ error:
+  cygpath_close();
+  return false;
+}
+
+typedef struct
+{
+  DWORD dwRVAFunctionNameList;
+  DWORD dwUseless1;
+  DWORD dwUseless2;
+  DWORD dwRVAModuleName;
+  DWORD dwRVAFunctionAddressList;
+} IMAGE_IMPORT_MODULE_DIRECTORY, *PIMAGE_IMPORT_MODULE_DIRECTORY;
+
+#define IMAGE_DIRECTORY_ENTRY_IMPORT 1
+
+/* Returns the handle for the MVCRT DLL, or NULL if it is not
+   available.  */
+static HMODULE
+msvcrt_dll (void)
+{
+  static HMODULE dll = (HMODULE)(-1);
+  PIMAGE_OPTIONAL_HEADER opth;
+  PIMAGE_IMPORT_MODULE_DIRECTORY impdir;
+  HANDLE image;
+
+  /* After we call GetModuleHandle, DLL will be either a valid handle
+     or NULL, so this check ensures that we only try to load the
+     library once.  */
+  if (dll != (HMODULE)(-1))
+    return dll;
+
+  dll = NULL;
+
+  /* Check which C runtime is loaded by this executable.  Do that by
+     looking at the import directory for DLLs the EXE links to that
+     looks like msvcr*.  This catches e.g., `msvcr90.dll' and
+     `msvcrt.dll'.  */
+
+  image = GetModuleHandle (NULL);
+
+  /* Get to the PE optional header.  */
+  opth = (PIMAGE_OPTIONAL_HEADER)
+    ((DWORD) image + ((PIMAGE_DOS_HEADER) image)->e_lfanew
+     + sizeof (DWORD) + sizeof (IMAGE_FILE_HEADER));
+  impdir = (PIMAGE_IMPORT_MODULE_DIRECTORY)
+    (opth->ImageBase
+     + opth->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
+
+  for (; impdir->dwRVAModuleName; impdir++)
+    {
+      char *dllname;
+
+      dllname = (char *) opth->ImageBase + impdir->dwRVAModuleName;
+      if (strncasecmp (dllname, "msvcr", sizeof ("msvcr") - 1) == 0)
+	{
+	  dll = GetModuleHandle (dllname);
+	  if (dll == NULL)
+	    {
+	      if (cygpath_log)
+		cygpath_log_msg ("error: GetModuleHandle failed");
+	    }
+	  break;
+	}
+    }
+
+  return dll;
+}
+
+/* Call the underlying MSVCRT fopen with PATH and MODE, and return
+   what it returns.  */
+static FILE *
+msvcrt_fopen (const char *path, const char *mode)
+{
+  typedef FILE *(fopen_type)(const char *path, 
+			     const char *mode);
+
+  static fopen_type *f = NULL;
+
+  /* Get the address of "fopen".  */
+  if (!f) 
+    {
+      HMODULE dll = msvcrt_dll ();
+      if (!dll)
+	{
+	  errno = ENOSYS;
+	  return NULL;
+	}
+      f = (fopen_type *) GetProcAddress (dll, "fopen");
+      if (!f)
+	{
+	  errno = ENOSYS;
+	  return NULL;
+	}
+    }
+
+  /* Call fopen.  */
+  return (*f)(path, mode);
+}
+
+FILE *
+fopen (const char *path, const char *mode)
+{
+  FILE *f;
+  char win32_path[MAX_PATH + 1];
+
+  /* Assume PATH is a Windows path.  */
+  f = msvcrt_fopen (path, mode);
+  if (f || errno != ENOENT)
+    return f;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    f = msvcrt_fopen (win32_path, mode);
+  return f;
+}
+
+int 
+open (const char *path, int oflag, ...)
+{
+  int fd;
+  char win32_path[MAX_PATH + 1];
+  int pmode = 0;
+
+  if ((oflag & _O_CREAT))
+    {
+      va_list ap;
+      va_start (ap, oflag);
+      pmode = va_arg (ap, int); 
+      va_end (ap);
+    }
+
+  /* Assume PATH is a Windows path.  */
+  fd = _open (path, oflag, pmode);
+  if (fd != -1 || errno != ENOENT)
+    return fd;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    fd = _open (win32_path, oflag, pmode);
+  return fd;
+}
+
+/* Call the underlying MSVCRT stat with PATH and MODE, and return
+   what it returns.  */
+int
+msvcrt_stat (const char *path, struct stat *buffer)
+{
+  typedef int *(stat_type)(const char *path,
+			   struct stat *buffer);
+
+  static stat_type *f = NULL;
+
+  /* Get the address of "stat".  */
+  if (!f)
+    {
+      HMODULE dll = msvcrt_dll ();
+      if (!dll)
+	{
+	  errno = ENOSYS;
+	  return NULL;
+	}
+      if (sizeof (time_t) == 8)
+	f = (stat_type *) GetProcAddress (dll, "_stat64i32");
+      else
+	{
+	  f = (stat_type *) GetProcAddress (dll, "_stat32");
+	  if (!f)
+	    f = (stat_type *) GetProcAddress (dll, "_stat");
+	}
+      if (!f)
+	{
+	  errno = ENOSYS;
+	  return NULL;
+	}
+    }
+
+  /* Call fopen.  */
+  return (*f)(path, buffer);
+}
+
+int
+stat (const char *path, struct stat *buffer)
+{
+  int r;
+  char win32_path[MAX_PATH + 1];
+
+  /* Assume PATH is a Windows path.  */
+  r = msvcrt_stat (path, (struct _stat *) buffer);
+  if (r != -1 || errno != ENOENT)
+    return r;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    r = msvcrt_stat (win32_path, (struct _stat *) buffer);
+  return r;
+}
+
+int
+access (const char *path, int mode)
+{
+  int r;
+  char win32_path[MAX_PATH + 1];
+
+#ifdef _WIN32
+  /* Some GNU tools mistakenly defined X_OK to 1 on Windows.  */
+  mode = mode & ~1;
+#endif
+  /* Assume PATH is a Windows path.  */
+  r = _access (path, mode);
+  if (r != -1 || errno != ENOENT)
+    return r;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    r = _access (win32_path, mode);
+  return r;
+}
+
+/* Given the WINDOWS_CODE (typically the result of GetLastError), set
+   ERRNO to the corresponding error code.  If there is no obvious
+   correspondence, ERRNO will be set to EACCES.  */
+static void
+set_errno_from_windows_code (DWORD windows_code)
+{
+  int mapping[][2] = {
+    {ERROR_ACCESS_DENIED, EACCES},
+    {ERROR_ACCOUNT_DISABLED, EACCES},
+    {ERROR_ACCOUNT_RESTRICTION, EACCES},
+    {ERROR_ALREADY_ASSIGNED, EBUSY},
+    {ERROR_ALREADY_EXISTS, EEXIST},
+    {ERROR_ARITHMETIC_OVERFLOW, ERANGE},
+    {ERROR_BAD_COMMAND, EIO},
+    {ERROR_BAD_DEVICE, ENODEV},
+    {ERROR_BAD_DRIVER_LEVEL, ENXIO},
+    {ERROR_BAD_EXE_FORMAT, ENOEXEC},
+    {ERROR_BAD_FORMAT, ENOEXEC},
+    {ERROR_BAD_LENGTH, EINVAL},
+    {ERROR_BAD_PATHNAME, ENOENT},
+    {ERROR_BAD_PIPE, EPIPE},
+    {ERROR_BAD_UNIT, ENODEV},
+    {ERROR_BAD_USERNAME, EINVAL},
+    {ERROR_BROKEN_PIPE, EPIPE},
+    {ERROR_BUFFER_OVERFLOW, ENOMEM},
+    {ERROR_BUSY, EBUSY},
+    {ERROR_BUSY_DRIVE, EBUSY},
+    {ERROR_CALL_NOT_IMPLEMENTED, ENOSYS},
+    {ERROR_CRC, EIO},
+    {ERROR_CURRENT_DIRECTORY, EINVAL},
+    {ERROR_DEVICE_IN_USE, EBUSY},
+    {ERROR_DIR_NOT_EMPTY, EEXIST},
+    {ERROR_DIRECTORY, ENOENT},
+    {ERROR_DISK_CHANGE, EIO},
+    {ERROR_DISK_FULL, ENOSPC},
+    {ERROR_DRIVE_LOCKED, EBUSY},
+    {ERROR_ENVVAR_NOT_FOUND, EINVAL},
+    {ERROR_EXE_MARKED_INVALID, ENOEXEC},
+    {ERROR_FILE_EXISTS, EEXIST},
+    {ERROR_FILE_INVALID, ENODEV},
+    {ERROR_FILE_NOT_FOUND, ENOENT},
+    {ERROR_FILENAME_EXCED_RANGE, ENAMETOOLONG},
+    {ERROR_GEN_FAILURE, EIO},
+    {ERROR_HANDLE_DISK_FULL, ENOSPC},
+    {ERROR_INSUFFICIENT_BUFFER,  ENOMEM},
+    {ERROR_INVALID_ACCESS, EINVAL},
+    {ERROR_INVALID_ADDRESS, EFAULT},
+    {ERROR_INVALID_BLOCK, EFAULT},
+    {ERROR_INVALID_DATA, EINVAL},
+    {ERROR_INVALID_DRIVE, ENODEV},
+    {ERROR_INVALID_EXE_SIGNATURE,  ENOEXEC},
+    {ERROR_INVALID_FLAGS, EINVAL},
+    {ERROR_INVALID_FUNCTION,  ENOSYS},
+    {ERROR_INVALID_HANDLE, EBADF},
+    {ERROR_INVALID_LOGON_HOURS,  EACCES},
+    {ERROR_INVALID_NAME, ENOENT},
+    {ERROR_INVALID_OWNER, EINVAL},
+    {ERROR_INVALID_PARAMETER, EINVAL},
+    {ERROR_INVALID_PASSWORD, EPERM},
+    {ERROR_INVALID_PRIMARY_GROUP, EINVAL},
+    {ERROR_INVALID_SIGNAL_NUMBER, EINVAL},
+    {ERROR_INVALID_TARGET_HANDLE, EIO},
+    {ERROR_INVALID_WORKSTATION, EACCES},
+    {ERROR_IO_DEVICE, EIO},
+    {ERROR_IO_INCOMPLETE, EINTR},
+    {ERROR_LOCKED, EBUSY},
+    {ERROR_LOGON_FAILURE, EACCES},
+    {ERROR_MAPPED_ALIGNMENT, EINVAL},
+    {ERROR_META_EXPANSION_TOO_LONG, E2BIG},
+    {ERROR_MORE_DATA, EPIPE},
+    {ERROR_NEGATIVE_SEEK, ESPIPE},
+    {ERROR_NO_DATA, EPIPE},
+    {ERROR_NO_MORE_SEARCH_HANDLES, EIO},
+    {ERROR_NO_PROC_SLOTS, EAGAIN},
+    {ERROR_NO_SUCH_PRIVILEGE, EACCES},
+    {ERROR_NOACCESS, EFAULT},
+    {ERROR_NONE_MAPPED, EINVAL},
+    {ERROR_NOT_ENOUGH_MEMORY, ENOMEM},
+    {ERROR_NOT_READY, ENODEV},
+    {ERROR_NOT_SAME_DEVICE, EXDEV},
+    {ERROR_OPEN_FAILED, EIO},
+    {ERROR_OPERATION_ABORTED, EINTR},
+    {ERROR_OUTOFMEMORY,  ENOMEM},
+    {ERROR_PASSWORD_EXPIRED, EACCES},
+    {ERROR_PATH_BUSY,  EBUSY},
+    {ERROR_PATH_NOT_FOUND, ENOTDIR},
+    {ERROR_PIPE_BUSY, EBUSY},
+    {ERROR_PIPE_CONNECTED, EPIPE},
+    {ERROR_PIPE_LISTENING, EPIPE},
+    {ERROR_PIPE_NOT_CONNECTED, EPIPE},
+    {ERROR_PRIVILEGE_NOT_HELD, EACCES},
+    {ERROR_READ_FAULT, EIO},
+    {ERROR_SEEK, ESPIPE},
+    {ERROR_SEEK_ON_DEVICE, ESPIPE},
+    {ERROR_SHARING_BUFFER_EXCEEDED, ENFILE},
+    {ERROR_STACK_OVERFLOW, ENOMEM},
+    {ERROR_SWAPERROR, ENOENT},
+    {ERROR_TOO_MANY_MODULES, EMFILE},
+    {ERROR_TOO_MANY_OPEN_FILES, EMFILE},
+    {ERROR_UNRECOGNIZED_MEDIA,  ENXIO},
+    {ERROR_UNRECOGNIZED_VOLUME,  ENODEV},
+    {ERROR_WAIT_NO_CHILDREN,  ECHILD},
+    {ERROR_WRITE_FAULT, EIO},
+    {ERROR_WRITE_PROTECT, EROFS}
+/*  MinGW does not define ETXTBSY as yet.  
+    {ERROR_LOCK_VIOLATION, ETXTBSY},
+    {ERROR_SHARING_VIOLATION, ETXTBSY}, 
+*/
+  };
+
+  size_t i;
+
+  for (i = 0; i < sizeof (mapping)/sizeof (mapping[0]); ++i)
+    if (mapping[i][0] == windows_code)
+      {
+	errno = mapping[i][1];
+	return;
+      }
+
+  /* Unrecognized error. Use EACCESS to have some error code,
+     not misleading "No error" thing.  */
+  errno = EACCES;      
+}
+
+int rename (const char *oldpath, const char *newpath)
+{
+  BOOL r;
+  int oldpath_converted = 0;
+  char win32_oldpath[MAX_PATH + 1];
+  char win32_newpath[MAX_PATH + 1];
+
+  /* Older versions of the cygpath program called FindFirstFile, but
+     not FindClose.  As a result, a long-running cygpath program ends
+     up leaking these handles, and, as a result, the Windows kernel
+     will not let us remove or rename things in directories.  Therefore,
+     we kill the child cygpath program now.
+
+     The defect in cygpath was corrected by this patch:
+
+       http://cygwin.com/ml/cygwin-patches/2007-q1/msg00033.html
+
+     but older versions of cygpath will be in use for the forseeable
+     future.  */
+
+  cygpath_close ();
+  cygpath_initialized = 0;
+
+  /* Assume all paths are Windows paths.  */
+  r = MoveFileEx (oldpath, newpath, MOVEFILE_REPLACE_EXISTING);
+  if (r)
+      return 0;
+  else if (GetLastError () != ERROR_PATH_NOT_FOUND)
+    goto error;
+
+  /* Perhaps the old path is a cygwin path?  */
+  if (cygpath (oldpath, win32_oldpath))
+    {
+      oldpath_converted = 1;
+      r = MoveFileEx (win32_oldpath, newpath, MOVEFILE_REPLACE_EXISTING);      
+      if (r)
+          return 0;
+      else if (GetLastError () != ERROR_PATH_NOT_FOUND)
+          goto error;
+    }
+
+  /* Perhaps the new path is a cygwin path?  */
+  if (cygpath (newpath, win32_newpath))
+    {
+      r = MoveFileEx (oldpath_converted ? win32_oldpath : oldpath,
+		      win32_newpath, MOVEFILE_REPLACE_EXISTING);
+      if (r == TRUE)
+	return 0;
+    }
+error:
+  set_errno_from_windows_code (GetLastError ());
+  return -1;      
+}
+
+int remove (const char *pathname)
+{
+  int r;
+  char win32_path[MAX_PATH + 1];
+
+  cygpath_close ();
+  cygpath_initialized = 0;
+
+  /* Assume PATH is a Windows path.  */
+  r = _unlink (pathname);
+  if (r != -1 || errno != ENOENT)
+    return r;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (pathname, win32_path))
+    r = _unlink (win32_path);
+  return r;
+}
+
+int unlink(const char *pathname)
+{
+    return remove (pathname);
+}
+
+int
+chdir (const char *path)
+{
+  int ret;
+  char win32_path[MAX_PATH + 1];
+
+  /* Assume PATH is a Windows path.  */
+  ret = _chdir (path);
+  if (ret != -1 || errno != ENOENT)
+    return ret;
+  /* Perhaps it is a Cygwin path?  */
+  if (cygpath (path, win32_path))
+    ret = _chdir (win32_path);
+  return ret;
+}
diff --git a/libiberty/lrealpath.c b/libiberty/lrealpath.c
index b27c8de99..0406bb050 100644
--- a/libiberty/lrealpath.c
+++ b/libiberty/lrealpath.c
@@ -138,6 +138,17 @@ lrealpath (const char *filename)
   {
     char buf[MAX_PATH];
     char* basename;
+
+    if (_access (filename, F_OK) != 0)
+      {
+	char cygbuf[MAX_PATH + 1];
+	/* The file does not exist.  It's fine to call lrealpath
+	   on a non-existing path... but if this would be an existing
+	   path after cygpath conversion, use that instead.  */
+	if (cygpath (filename, cygbuf) && _access (cygbuf, F_OK) == 0)
+	  filename = cygbuf;
+      }
+
     DWORD len = GetFullPathName (filename, MAX_PATH, buf, &basename);
     if (len == 0 || len > MAX_PATH - 1)
       return strdup (filename);
diff --git a/libiberty/pex-common.c b/libiberty/pex-common.c
index 7f355365e..ce111f0f7 100644
--- a/libiberty/pex-common.c
+++ b/libiberty/pex-common.c
@@ -505,6 +505,7 @@ pex_read_err (struct pex_obj *obj, int binary)
   if (o < 0 || o == STDIN_FILE_NO)
     return NULL;
   obj->read_err = obj->funcs->fdopenr (obj, o, binary);
+  obj->stderr_pipe = -1;
   return obj->read_err;    
 }
 
@@ -597,8 +598,17 @@ pex_get_times (struct pex_obj *obj, int count, struct pex_time *vector)
 void
 pex_free (struct pex_obj *obj)
 {
+  /* Close pipe file descriptors corresponding to child's stdout and
+     stderr so that the child does not hang trying to output anything
+     while we're waiting for it.  */
   if (obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)
     obj->funcs->close (obj, obj->next_input);
+  if (obj->stderr_pipe >= 0 && obj->stderr_pipe != STDIN_FILE_NO)
+    obj->funcs->close (obj, obj->stderr_pipe);
+  if (obj->read_output != NULL)
+    fclose (obj->read_output);
+  if (obj->read_err != NULL)
+    fclose (obj->read_err);
 
   /* If the caller forgot to wait for the children, we do it here, to
      avoid zombies.  */
@@ -619,10 +629,6 @@ pex_free (struct pex_obj *obj)
     free (obj->status);
   if (obj->time != NULL)
     free (obj->time);
-  if (obj->read_output != NULL)
-    fclose (obj->read_output);
-  if (obj->read_err != NULL)
-    fclose (obj->read_err);
 
   if (obj->remove_count > 0)
     {
diff --git a/libiberty/pex-win32.c b/libiberty/pex-win32.c
index 589786634..e69461c66 100644
--- a/libiberty/pex-win32.c
+++ b/libiberty/pex-win32.c
@@ -119,7 +119,7 @@ static int
 pex_win32_open_read (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
 		     int binary)
 {
-  return _open (name, _O_RDONLY | (binary ? _O_BINARY : _O_TEXT));
+  return open (name, _O_RDONLY | (binary ? _O_BINARY : _O_TEXT));
 }
 
 /* Open a file for writing.  */
@@ -130,10 +130,10 @@ pex_win32_open_write (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
 {
   /* Note that we can't use O_EXCL here because gcc may have already
      created the temporary file via make_temp_file.  */
-  return _open (name,
-		(_O_WRONLY | _O_CREAT | _O_TRUNC
-		 | (binary ? _O_BINARY : _O_TEXT)),
-		_S_IREAD | _S_IWRITE);
+  return open (name,
+	       (_O_WRONLY | _O_CREAT | _O_TRUNC
+		| (binary ? _O_BINARY : _O_TEXT)),
+	       _S_IREAD | _S_IWRITE);
 }
 
 /* Close a file.  */
@@ -746,6 +746,28 @@ pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,
   OSVERSIONINFO version_info;
   STARTUPINFO si;
   PROCESS_INFORMATION pi;
+  int orig_out, orig_in, orig_err;
+  BOOL separate_stderr = !(flags & PEX_STDERR_TO_STDOUT);
+
+  /* Ensure we have inheritable descriptors to pass to the child, and close the
+     original descriptors.  */
+  orig_in = in;
+  in = _dup (orig_in);
+  if (orig_in != STDIN_FILENO)
+    _close (orig_in);
+  
+  orig_out = out;
+  out = _dup (orig_out);
+  if (orig_out != STDOUT_FILENO)
+    _close (orig_out);
+  
+  if (separate_stderr)
+    {
+      orig_err = errdes;
+      errdes = _dup (orig_err);
+      if (orig_err != STDERR_FILENO)
+	_close (orig_err);
+    }
 
   stdin_handle = INVALID_HANDLE_VALUE;
   stdout_handle = INVALID_HANDLE_VALUE;
@@ -753,7 +775,7 @@ pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,
 
   stdin_handle = (HANDLE) _get_osfhandle (in);
   stdout_handle = (HANDLE) _get_osfhandle (out);
-  if (!(flags & PEX_STDERR_TO_STDOUT))
+  if (separate_stderr)
     stderr_handle = (HANDLE) _get_osfhandle (errdes);
   else
     stderr_handle = stdout_handle;
@@ -822,12 +844,13 @@ pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,
       *errmsg = "CreateProcess";
     }
 
-  /* Close the standard output and standard error handles in the
-     parent.  */ 
-  if (out != STDOUT_FILENO)
-    obj->funcs->close (obj, out);
-  if (errdes != STDERR_FILENO)
-    obj->funcs->close (obj, errdes);
+  /* Close the standard input, standard output and standard error handles
+     in the parent.  */ 
+
+  _close (in);
+  _close (out);
+  if (separate_stderr)
+    _close (errdes);
 
   return pid;
 }
@@ -883,7 +906,7 @@ static int
 pex_win32_pipe (struct pex_obj *obj ATTRIBUTE_UNUSED, int *p,
 		int binary)
 {
-  return _pipe (p, 256, binary ? _O_BINARY : _O_TEXT);
+  return _pipe (p, 256, (binary ? _O_BINARY : _O_TEXT) | _O_NOINHERIT);
 }
 
 /* Get a FILE pointer to read from a file descriptor.  */
diff --git a/libiberty/testsuite/test-expandargv.c b/libiberty/testsuite/test-expandargv.c
index 9d1af0145..c16a0322a 100644
--- a/libiberty/testsuite/test-expandargv.c
+++ b/libiberty/testsuite/test-expandargv.c
@@ -107,6 +107,38 @@ const char *test_data[] = {
   ARGV0,
   0,
 
+  /* Test 4 - Check for options beginning with an empty line.  */
+  "\na\nb",	/* Test 4 data */
+  ARGV0,
+  "@test-expandargv-4.lst",
+  0,
+  ARGV0,
+  "a",
+  "b",
+  0,
+
+  /* Test 5 - Check for options containing an empty argument.  */
+  "a\n''\nb",    /* Test 5 data */
+  ARGV0,
+  "@test-expandargv-5.lst",
+  0,
+  ARGV0,
+  "a",
+  "",
+  "b",
+  0,
+
+  /* Test 6 - Check for options containing a quoted newline.  */
+  "a\n'a\n\nb'\nb",    /* Test 6 data */
+  ARGV0,
+  "@test-expandargv-6.lst",
+  0,
+  ARGV0,
+  "a",
+  "a\n\nb",
+  "b",
+  0,
+
   0 /* Test done marker, don't remove. */
 };
 
@@ -246,7 +278,7 @@ run_tests (const char **test_data)
       /* Compare each of the argv's ... */
       else
         for (k = 0; k < argc_after; k++)
-          if (strncmp (argv_before[k], argv_after[k], strlen(argv_after[k])) != 0)
+          if (strcmp (argv_before[k], argv_after[k]) != 0)
             {
               printf ("FAIL: test-expandargv-%d. Arguments don't match.\n", i);
               failed++;
diff --git a/libjava/classpath/Makefile.in b/libjava/classpath/Makefile.in
index 1fed8f95d..a4235de23 100644
--- a/libjava/classpath/Makefile.in
+++ b/libjava/classpath/Makefile.in
@@ -360,9 +360,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 
diff --git a/libjava/classpath/configure b/libjava/classpath/configure
index 466fa46bd..dec754f5d 100755
--- a/libjava/classpath/configure
+++ b/libjava/classpath/configure
@@ -461,7 +461,7 @@ ac_includes_default="\
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os JAVA_MAINTAINER_MODE_TRUE JAVA_MAINTAINER_MODE_FALSE GENINSRC_TRUE GENINSRC_FALSE multi_basedir INSTALL_BINARIES_TRUE INSTALL_BINARIES_FALSE LIBVERSION CLASSPATH_MODULE CLASSPATH_CONVENIENCE INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CREATE_COLLECTIONS_TRUE CREATE_COLLECTIONS_FALSE CREATE_JNI_LIBRARIES_TRUE CREATE_JNI_LIBRARIES_FALSE CREATE_CORE_JNI_LIBRARIES_TRUE CREATE_CORE_JNI_LIBRARIES_FALSE CREATE_GCONF_PEER_LIBRARIES_TRUE CREATE_GCONF_PEER_LIBRARIES_FALSE CREATE_GSTREAMER_PEER_LIBRARIES_TRUE CREATE_GSTREAMER_PEER_LIBRARIES_FALSE default_toolkit CREATE_XMLJ_LIBRARY_TRUE CREATE_XMLJ_LIBRARY_FALSE CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CPP EGREP CREATE_ALSA_LIBRARIES_TRUE CREATE_ALSA_LIBRARIES_FALSE CREATE_DSSI_LIBRARIES_TRUE CREATE_DSSI_LIBRARIES_FALSE CREATE_GTK_PEER_LIBRARIES_TRUE CREATE_GTK_PEER_LIBRARIES_FALSE CREATE_QT_PEER_LIBRARIES_TRUE CREATE_QT_PEER_LIBRARIES_FALSE CREATE_PLUGIN_TRUE CREATE_PLUGIN_FALSE CREATE_GJDOC_TRUE CREATE_GJDOC_FALSE toolexeclibdir nativeexeclibdir glibjdir CREATE_JNI_HEADERS_TRUE CREATE_JNI_HEADERS_FALSE CREATE_GJDOC_PARSER_TRUE CREATE_GJDOC_PARSER_FALSE CREATE_WRAPPERS_TRUE CREATE_WRAPPERS_FALSE LN_S LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM OBJDUMP ac_ct_OBJDUMP AR ac_ct_AR RANLIB ac_ct_RANLIB lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE CXXCPP PERL COLLECTIONS_PREFIX LIBMAGIC LIBICONV LTLIBICONV WARNING_CFLAGS EXTRA_CFLAGS STRICT_WARNING_CFLAGS ERROR_CFLAGS PKG_CONFIG XML_CFLAGS XML_LIBS XSLT_CFLAGS XSLT_LIBS X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS GTK_CFLAGS GTK_LIBS FREETYPE2_CFLAGS FREETYPE2_LIBS PANGOFT2_CFLAGS PANGOFT2_LIBS CAIRO_CFLAGS CAIRO_LIBS XTEST_LIBS GCONF_CFLAGS GCONF_LIBS GDK_CFLAGS GDK_LIBS GSTREAMER_CFLAGS GSTREAMER_LIBS GSTREAMER_BASE_CFLAGS GSTREAMER_BASE_LIBS GSTREAMER_PLUGINS_BASE_CFLAGS GSTREAMER_PLUGINS_BASE_LIBS GST_PLUGIN_LDFLAGS GSTREAMER_FILE_READER GSTREAMER_MIXER_PROVIDER QT_CFLAGS QT_LIBS MOC MOZILLA_CFLAGS MOZILLA_LIBS GLIB_CFLAGS GLIB_LIBS PLUGIN_DIR GMP_CFLAGS GMP_LIBS USER_JAVAH CLASSPATH_INCLUDES vm_classes MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LIBDEBUG INIT_LOAD_LIBRARY ECJ_JAR JAVA_LANG_SYSTEM_EXPLICIT_INITIALIZATION REMOVE MKDIR CP DATE FIND ZIP JAR WITH_JAR_TRUE WITH_JAR_FALSE INSTALL_GLIBJ_ZIP_TRUE INSTALL_GLIBJ_ZIP_FALSE INSTALL_CLASS_FILES_TRUE INSTALL_CLASS_FILES_FALSE BUILD_CLASS_FILES_TRUE BUILD_CLASS_FILES_FALSE EXAMPLESDIR TOOLSDIR GJDOC CREATE_API_DOCS_TRUE CREATE_API_DOCS_FALSE JAY JAY_SKELETON REGEN_PARSERS_TRUE REGEN_PARSERS_FALSE USE_PREBUILT_GLIBJ_ZIP_TRUE USE_PREBUILT_GLIBJ_ZIP_FALSE PATH_TO_GLIBJ_ZIP JAVA uudecode JAVAC JAVAC_IS_GCJ GCJ_JAVAC_TRUE GCJ_JAVAC_FALSE ANTLR_JAR ANTLR ac_ct_ANTLR JAVAC_MEM_OPT USE_ESCHER_TRUE USE_ESCHER_FALSE PATH_TO_ESCHER ENABLE_LOCAL_SOCKETS_TRUE ENABLE_LOCAL_SOCKETS_FALSE DEFAULT_PREFS_PEER WANT_NATIVE_BIG_INTEGER CREATE_GMPBI_LIBRARY_TRUE CREATE_GMPBI_LIBRARY_FALSE LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os JAVA_MAINTAINER_MODE_TRUE JAVA_MAINTAINER_MODE_FALSE GENINSRC_TRUE GENINSRC_FALSE multi_basedir INSTALL_BINARIES_TRUE INSTALL_BINARIES_FALSE LIBVERSION CLASSPATH_MODULE CLASSPATH_CONVENIENCE INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CREATE_COLLECTIONS_TRUE CREATE_COLLECTIONS_FALSE CREATE_JNI_LIBRARIES_TRUE CREATE_JNI_LIBRARIES_FALSE CREATE_CORE_JNI_LIBRARIES_TRUE CREATE_CORE_JNI_LIBRARIES_FALSE CREATE_GCONF_PEER_LIBRARIES_TRUE CREATE_GCONF_PEER_LIBRARIES_FALSE CREATE_GSTREAMER_PEER_LIBRARIES_TRUE CREATE_GSTREAMER_PEER_LIBRARIES_FALSE default_toolkit CREATE_XMLJ_LIBRARY_TRUE CREATE_XMLJ_LIBRARY_FALSE CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CPP EGREP CREATE_ALSA_LIBRARIES_TRUE CREATE_ALSA_LIBRARIES_FALSE CREATE_DSSI_LIBRARIES_TRUE CREATE_DSSI_LIBRARIES_FALSE CREATE_GTK_PEER_LIBRARIES_TRUE CREATE_GTK_PEER_LIBRARIES_FALSE CREATE_QT_PEER_LIBRARIES_TRUE CREATE_QT_PEER_LIBRARIES_FALSE CREATE_PLUGIN_TRUE CREATE_PLUGIN_FALSE CREATE_GJDOC_TRUE CREATE_GJDOC_FALSE target_noncanonical toolexecdir toolexecmainlibdir toolexeclibdir nativeexeclibdir glibjdir CREATE_JNI_HEADERS_TRUE CREATE_JNI_HEADERS_FALSE CREATE_GJDOC_PARSER_TRUE CREATE_GJDOC_PARSER_FALSE CREATE_WRAPPERS_TRUE CREATE_WRAPPERS_FALSE LN_S LIBTOOL SED FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM OBJDUMP ac_ct_OBJDUMP AR ac_ct_AR RANLIB ac_ct_RANLIB lt_ECHO DSYMUTIL ac_ct_DSYMUTIL NMEDIT ac_ct_NMEDIT LIPO ac_ct_LIPO OTOOL ac_ct_OTOOL OTOOL64 ac_ct_OTOOL64 CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE CXXCPP PERL COLLECTIONS_PREFIX LIBMAGIC LIBICONV LTLIBICONV WARNING_CFLAGS EXTRA_CFLAGS STRICT_WARNING_CFLAGS ERROR_CFLAGS PKG_CONFIG XML_CFLAGS XML_LIBS XSLT_CFLAGS XSLT_LIBS X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS GTK_CFLAGS GTK_LIBS FREETYPE2_CFLAGS FREETYPE2_LIBS PANGOFT2_CFLAGS PANGOFT2_LIBS CAIRO_CFLAGS CAIRO_LIBS XTEST_LIBS GCONF_CFLAGS GCONF_LIBS GDK_CFLAGS GDK_LIBS GSTREAMER_CFLAGS GSTREAMER_LIBS GSTREAMER_BASE_CFLAGS GSTREAMER_BASE_LIBS GSTREAMER_PLUGINS_BASE_CFLAGS GSTREAMER_PLUGINS_BASE_LIBS GST_PLUGIN_LDFLAGS GSTREAMER_FILE_READER GSTREAMER_MIXER_PROVIDER QT_CFLAGS QT_LIBS MOC MOZILLA_CFLAGS MOZILLA_LIBS GLIB_CFLAGS GLIB_LIBS PLUGIN_DIR GMP_CFLAGS GMP_LIBS USER_JAVAH CLASSPATH_INCLUDES vm_classes MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LIBDEBUG INIT_LOAD_LIBRARY ECJ_JAR JAVA_LANG_SYSTEM_EXPLICIT_INITIALIZATION REMOVE MKDIR CP DATE FIND ZIP JAR WITH_JAR_TRUE WITH_JAR_FALSE INSTALL_GLIBJ_ZIP_TRUE INSTALL_GLIBJ_ZIP_FALSE INSTALL_CLASS_FILES_TRUE INSTALL_CLASS_FILES_FALSE BUILD_CLASS_FILES_TRUE BUILD_CLASS_FILES_FALSE EXAMPLESDIR TOOLSDIR GJDOC CREATE_API_DOCS_TRUE CREATE_API_DOCS_FALSE JAY JAY_SKELETON REGEN_PARSERS_TRUE REGEN_PARSERS_FALSE USE_PREBUILT_GLIBJ_ZIP_TRUE USE_PREBUILT_GLIBJ_ZIP_FALSE PATH_TO_GLIBJ_ZIP JAVA uudecode JAVAC JAVAC_IS_GCJ GCJ_JAVAC_TRUE GCJ_JAVAC_FALSE ANTLR_JAR ANTLR ac_ct_ANTLR JAVAC_MEM_OPT USE_ESCHER_TRUE USE_ESCHER_FALSE PATH_TO_ESCHER ENABLE_LOCAL_SOCKETS_TRUE ENABLE_LOCAL_SOCKETS_FALSE DEFAULT_PREFS_PEER WANT_NATIVE_BIG_INTEGER CREATE_GMPBI_LIBRARY_TRUE CREATE_GMPBI_LIBRARY_FALSE LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 ac_pwd=`pwd`
 
@@ -1063,6 +1063,9 @@ Optional Features:
                           (disabled by --disable-gmp) default=yes
   --disable-gjdoc         compile GJDoc (disabled by --disable-gjdoc)
                           default=yes
+  --enable-version-specific-runtime-libs
+                          specify that runtime libraries should be installed
+                          in a compiler-specific directory
   --enable-regen-headers  automatically regenerate JNI headers default=yes if
                           headers don't exist
   --enable-regen-gjdoc-parser
@@ -4838,16 +4841,64 @@ else
 fi
 
 
+# Check whether --enable-version-specific-runtime-libs or --disable-version-specific-runtime-libs was given.
+if test "${enable_version_specific_runtime_libs+set}" = set; then
+  enableval="$enable_version_specific_runtime_libs"
+  case "$enableval" in
+      yes) version_specific_libs=yes ;;
+      no)  version_specific_libs=no ;;
+      *)   { { echo "$as_me:$LINENO: error: Unknown argument to enable/disable version-specific libs" >&5
+echo "$as_me: error: Unknown argument to enable/disable version-specific libs" >&2;}
+   { (exit 1); exit 1; }; };;
+     esac
+else
+  version_specific_libs=no
+
+fi;
+
+  case ${host_alias} in
+    "") host_noncanonical=${build_noncanonical} ;;
+    *) host_noncanonical=${host_alias} ;;
+  esac
+  case ${target_alias} in
+    "") target_noncanonical=${host_noncanonical} ;;
+    *) target_noncanonical=${target_alias} ;;
+  esac
 
-  multi_os_directory=`$CC -print-multi-os-directory`
-  case $multi_os_directory in
-    .) toolexeclibdir=${libdir} ;; # Avoid trailing /.
-    *) toolexeclibdir=${libdir}/${multi_os_directory} ;;
+
+  case ${version_specific_libs} in
+    yes)
+      # Need the gcc compiler version to know where to install libraries
+      # and header files if --enable-version-specific-runtime-libs option
+      # is selected.
+      includedir='$(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include/'
+      toolexecdir='$(libdir)/gcc/$(target_noncanonical)'
+      toolexecmainlibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+      toolexeclibdir=$toolexecmainlibdir
+      ;;
+    no)
+      if test -n "$with_cross_host" &&
+	 test x"$with_cross_host" != x"no"; then
+	# Install a library built with a cross compiler in tooldir, not libdir.
+	toolexecdir='$(exec_prefix)/$(target_noncanonical)'
+	toolexecmainlibdir='$(toolexecdir)/lib'
+      else
+	toolexecdir='$(libdir)/gcc-lib/$(target_noncanonical)'
+	toolexecmainlibdir='$(libdir)'
+      fi
+      multi_os_directory=`$CC -print-multi-os-directory`
+      case $multi_os_directory in
+	.) toolexeclibdir=$toolexecmainlibdir ;; # Avoid trailing /.
+	*) toolexeclibdir=$toolexecmainlibdir/$multi_os_directory ;;
+      esac
+      ;;
   esac
 
 
 
 
+
+
 # Check whether --with-native-libdir or --without-native-libdir was given.
 if test "${with_native_libdir+set}" = set; then
   withval="$with_native_libdir"
@@ -5753,13 +5804,13 @@ if test "${lt_cv_nm_interface+set}" = set; then
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:5756: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:5807: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:5759: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:5810: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:5762: output\"" >&5)
+  (eval echo "\"\$as_me:5813: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
@@ -6905,7 +6956,7 @@ ia64-*-hpux*)
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 6908 "configure"' > conftest.$ac_ext
+  echo '#line 6959 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -8191,11 +8242,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8194: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8245: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8198: \$? = $ac_status" >&5
+   echo "$as_me:8249: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8530,11 +8581,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8533: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8584: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8537: \$? = $ac_status" >&5
+   echo "$as_me:8588: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8635,11 +8686,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8638: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8689: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8642: \$? = $ac_status" >&5
+   echo "$as_me:8693: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -8690,11 +8741,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8693: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8744: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8697: \$? = $ac_status" >&5
+   echo "$as_me:8748: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -11557,7 +11608,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11560 "configure"
+#line 11611 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11653,7 +11704,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11656 "configure"
+#line 11707 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -16084,11 +16135,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:16087: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:16138: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:16091: \$? = $ac_status" >&5
+   echo "$as_me:16142: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -16183,11 +16234,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:16186: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:16237: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:16190: \$? = $ac_status" >&5
+   echo "$as_me:16241: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -16235,11 +16286,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:16238: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:16289: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:16242: \$? = $ac_status" >&5
+   echo "$as_me:16293: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -29270,7 +29321,7 @@ EOF
 if uudecode$EXEEXT Test.uue; then
         ac_cv_prog_uudecode_base64=yes
 else
-        echo "configure: 29273: uudecode had trouble decoding base 64 file 'Test.uue'" >&5
+        echo "configure: 29324: uudecode had trouble decoding base 64 file 'Test.uue'" >&5
         echo "configure: failed file was:" >&5
         cat Test.uue >&5
         ac_cv_prog_uudecode_base64=no
@@ -29417,7 +29468,7 @@ else
 JAVA_TEST=Object.java
 CLASS_TEST=Object.class
 cat << \EOF > $JAVA_TEST
-/* #line 29420 "configure" */
+/* #line 29471 "configure" */
 package java.lang;
 
 public class Object
@@ -29466,7 +29517,7 @@ JAVA_TEST=Test.java
 CLASS_TEST=Test.class
 TEST=Test
 cat << \EOF > $JAVA_TEST
-/* [#]line 29469 "configure" */
+/* [#]line 29520 "configure" */
 public class Test {
 public static void main (String args[]) {
         System.exit (0);
@@ -29786,7 +29837,7 @@ else
 JAVA_TEST=Object.java
 CLASS_TEST=Object.class
 cat << \EOF > $JAVA_TEST
-/* #line 29789 "configure" */
+/* #line 29840 "configure" */
 package java.lang;
 
 public class Object
@@ -29827,7 +29878,7 @@ fi
   JAVA_TEST=Test.java
   CLASS_TEST=Test.class
   cat << \EOF > $JAVA_TEST
-  /* #line 29830 "configure" */
+  /* #line 29881 "configure" */
   public class Test
   {
     public static void main(String args)
@@ -31681,6 +31732,9 @@ s,@CREATE_PLUGIN_TRUE@,$CREATE_PLUGIN_TRUE,;t t
 s,@CREATE_PLUGIN_FALSE@,$CREATE_PLUGIN_FALSE,;t t
 s,@CREATE_GJDOC_TRUE@,$CREATE_GJDOC_TRUE,;t t
 s,@CREATE_GJDOC_FALSE@,$CREATE_GJDOC_FALSE,;t t
+s,@target_noncanonical@,$target_noncanonical,;t t
+s,@toolexecdir@,$toolexecdir,;t t
+s,@toolexecmainlibdir@,$toolexecmainlibdir,;t t
 s,@toolexeclibdir@,$toolexeclibdir,;t t
 s,@nativeexeclibdir@,$nativeexeclibdir,;t t
 s,@glibjdir@,$glibjdir,;t t
diff --git a/libjava/classpath/configure.ac b/libjava/classpath/configure.ac
index 9ab476895..f5add0d0d 100644
--- a/libjava/classpath/configure.ac
+++ b/libjava/classpath/configure.ac
@@ -316,6 +316,16 @@ dnl defined to the same value for all multilibs.  We define toolexeclibdir
 dnl so that we can refer to the multilib installation directories from
 dnl classpath's build files.
 dnl -----------------------------------------------------------
+AC_ARG_ENABLE(version-specific-runtime-libs,
+  AS_HELP_STRING([--enable-version-specific-runtime-libs],    
+                 [specify that runtime libraries should be installed in a compiler-specific directory]),
+    [case "$enableval" in
+      yes) version_specific_libs=yes ;;
+      no)  version_specific_libs=no ;;
+      *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs]);;
+     esac],
+    [version_specific_libs=no]
+)
 CLASSPATH_TOOLEXECLIBDIR
 
 dnl -----------------------------------------------------------
diff --git a/libjava/classpath/doc/Makefile.in b/libjava/classpath/doc/Makefile.in
index 1344025f5..5e79a6edd 100644
--- a/libjava/classpath/doc/Makefile.in
+++ b/libjava/classpath/doc/Makefile.in
@@ -357,9 +357,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 SUBDIRS = api
diff --git a/libjava/classpath/doc/api/Makefile.in b/libjava/classpath/doc/api/Makefile.in
index 78770f67c..9a493bb4b 100644
--- a/libjava/classpath/doc/api/Makefile.in
+++ b/libjava/classpath/doc/api/Makefile.in
@@ -334,9 +334,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 @CREATE_API_DOCS_TRUE@noinst_DATA = html
diff --git a/libjava/classpath/examples/Makefile.in b/libjava/classpath/examples/Makefile.in
index c81f28206..d03259525 100644
--- a/libjava/classpath/examples/Makefile.in
+++ b/libjava/classpath/examples/Makefile.in
@@ -343,9 +343,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 GLIBJ_CLASSPATH = '$(top_builddir)/lib/glibj.zip:$(top_builddir)/lib'
diff --git a/libjava/classpath/external/Makefile.in b/libjava/classpath/external/Makefile.in
index 6f85bb297..ee992cf5f 100644
--- a/libjava/classpath/external/Makefile.in
+++ b/libjava/classpath/external/Makefile.in
@@ -341,9 +341,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 SUBDIRS = sax w3c_dom relaxngDatatype jsr166
diff --git a/libjava/classpath/external/jsr166/Makefile.in b/libjava/classpath/external/jsr166/Makefile.in
index 1bccd4cdc..15204176d 100644
--- a/libjava/classpath/external/jsr166/Makefile.in
+++ b/libjava/classpath/external/jsr166/Makefile.in
@@ -332,9 +332,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 EXTRA_DIST = IMPORTING \
diff --git a/libjava/classpath/external/relaxngDatatype/Makefile.in b/libjava/classpath/external/relaxngDatatype/Makefile.in
index 69cb69264..ff39a245c 100644
--- a/libjava/classpath/external/relaxngDatatype/Makefile.in
+++ b/libjava/classpath/external/relaxngDatatype/Makefile.in
@@ -332,9 +332,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 EXTRA_DIST = README.txt \
diff --git a/libjava/classpath/external/sax/Makefile.in b/libjava/classpath/external/sax/Makefile.in
index 314142a70..220a0afd7 100644
--- a/libjava/classpath/external/sax/Makefile.in
+++ b/libjava/classpath/external/sax/Makefile.in
@@ -332,9 +332,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 EXTRA_DIST = README \
diff --git a/libjava/classpath/external/w3c_dom/Makefile.in b/libjava/classpath/external/w3c_dom/Makefile.in
index 71c0807e9..add20851f 100644
--- a/libjava/classpath/external/w3c_dom/Makefile.in
+++ b/libjava/classpath/external/w3c_dom/Makefile.in
@@ -332,9 +332,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 EXTRA_DIST = README \
diff --git a/libjava/classpath/include/Makefile.in b/libjava/classpath/include/Makefile.in
index 40872ee6a..10b58a1fe 100644
--- a/libjava/classpath/include/Makefile.in
+++ b/libjava/classpath/include/Makefile.in
@@ -333,9 +333,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 @CREATE_JNI_HEADERS_FALSE@DISTCLEANFILES = jni_md.h config-int.h
diff --git a/libjava/classpath/lib/Makefile.in b/libjava/classpath/lib/Makefile.in
index 8c8f29805..f2f97379c 100644
--- a/libjava/classpath/lib/Makefile.in
+++ b/libjava/classpath/lib/Makefile.in
@@ -337,9 +337,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 JAVA_DEPEND = java.dep
diff --git a/libjava/classpath/m4/acinclude.m4 b/libjava/classpath/m4/acinclude.m4
index 65cb8fc47..7dbf3246c 100644
--- a/libjava/classpath/m4/acinclude.m4
+++ b/libjava/classpath/m4/acinclude.m4
@@ -247,11 +247,45 @@ dnl GCJ LOCAL: Calculate toolexeclibdir
 dnl -----------------------------------------------------------
 AC_DEFUN([CLASSPATH_TOOLEXECLIBDIR],
 [
-  multi_os_directory=`$CC -print-multi-os-directory`
-  case $multi_os_directory in
-    .) toolexeclibdir=${libdir} ;; # Avoid trailing /.
-    *) toolexeclibdir=${libdir}/${multi_os_directory} ;;
+  case ${host_alias} in
+    "") host_noncanonical=${build_noncanonical} ;;
+    *) host_noncanonical=${host_alias} ;;
   esac
+  case ${target_alias} in
+    "") target_noncanonical=${host_noncanonical} ;;
+    *) target_noncanonical=${target_alias} ;;
+  esac
+  AC_SUBST(target_noncanonical)
+
+  case ${version_specific_libs} in
+    yes)
+      # Need the gcc compiler version to know where to install libraries
+      # and header files if --enable-version-specific-runtime-libs option
+      # is selected.
+      includedir='$(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include/'
+      toolexecdir='$(libdir)/gcc/$(target_noncanonical)'
+      toolexecmainlibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+      toolexeclibdir=$toolexecmainlibdir
+      ;;
+    no)
+      if test -n "$with_cross_host" &&
+	 test x"$with_cross_host" != x"no"; then
+	# Install a library built with a cross compiler in tooldir, not libdir.
+	toolexecdir='$(exec_prefix)/$(target_noncanonical)'
+	toolexecmainlibdir='$(toolexecdir)/lib'
+      else
+	toolexecdir='$(libdir)/gcc-lib/$(target_noncanonical)'
+	toolexecmainlibdir='$(libdir)'
+      fi
+      multi_os_directory=`$CC -print-multi-os-directory`
+      case $multi_os_directory in
+	.) toolexeclibdir=$toolexecmainlibdir ;; # Avoid trailing /.
+	*) toolexeclibdir=$toolexecmainlibdir/$multi_os_directory ;;
+      esac
+      ;;
+  esac
+  AC_SUBST(toolexecdir)
+  AC_SUBST(toolexecmainlibdir)
   AC_SUBST(toolexeclibdir)
 ])
 
diff --git a/libjava/classpath/native/Makefile.in b/libjava/classpath/native/Makefile.in
index 8d22204f7..3f0ea7fee 100644
--- a/libjava/classpath/native/Makefile.in
+++ b/libjava/classpath/native/Makefile.in
@@ -340,9 +340,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 @CREATE_JNI_LIBRARIES_TRUE@JNIDIR = jni
diff --git a/libjava/classpath/native/fdlibm/Makefile.in b/libjava/classpath/native/fdlibm/Makefile.in
index 691da27b3..8803c1a78 100644
--- a/libjava/classpath/native/fdlibm/Makefile.in
+++ b/libjava/classpath/native/fdlibm/Makefile.in
@@ -359,9 +359,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 noinst_LTLIBRARIES = libfdlibm.la 
diff --git a/libjava/classpath/native/jawt/Makefile.in b/libjava/classpath/native/jawt/Makefile.in
index c20a940a7..ece65a548 100644
--- a/libjava/classpath/native/jawt/Makefile.in
+++ b/libjava/classpath/native/jawt/Makefile.in
@@ -359,9 +359,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjawt.la
diff --git a/libjava/classpath/native/jni/Makefile.in b/libjava/classpath/native/jni/Makefile.in
index bf2608fc3..d361bd26f 100644
--- a/libjava/classpath/native/jni/Makefile.in
+++ b/libjava/classpath/native/jni/Makefile.in
@@ -340,9 +340,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 @CREATE_CORE_JNI_LIBRARIES_TRUE@JNIDIRS = native-lib java-io java-lang java-net java-nio java-util
diff --git a/libjava/classpath/native/jni/classpath/Makefile.in b/libjava/classpath/native/jni/classpath/Makefile.in
index 017edd8ae..f4f45b972 100644
--- a/libjava/classpath/native/jni/classpath/Makefile.in
+++ b/libjava/classpath/native/jni/classpath/Makefile.in
@@ -350,9 +350,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 
diff --git a/libjava/classpath/native/jni/gconf-peer/Makefile.in b/libjava/classpath/native/jni/gconf-peer/Makefile.in
index 3f77b6ae3..e4564c880 100644
--- a/libjava/classpath/native/jni/gconf-peer/Makefile.in
+++ b/libjava/classpath/native/jni/gconf-peer/Makefile.in
@@ -359,9 +359,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgconfpeer.la
diff --git a/libjava/classpath/native/jni/gstreamer-peer/Makefile.in b/libjava/classpath/native/jni/gstreamer-peer/Makefile.in
index 0719b3a98..f8ecc8461 100644
--- a/libjava/classpath/native/jni/gstreamer-peer/Makefile.in
+++ b/libjava/classpath/native/jni/gstreamer-peer/Makefile.in
@@ -361,9 +361,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgstreamerpeer.la
diff --git a/libjava/classpath/native/jni/gtk-peer/Makefile.in b/libjava/classpath/native/jni/gtk-peer/Makefile.in
index d277f150f..4b6cd3c61 100644
--- a/libjava/classpath/native/jni/gtk-peer/Makefile.in
+++ b/libjava/classpath/native/jni/gtk-peer/Makefile.in
@@ -397,9 +397,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgtkpeer.la
diff --git a/libjava/classpath/native/jni/java-io/Makefile.in b/libjava/classpath/native/jni/java-io/Makefile.in
index a7398bceb..3c68909ce 100644
--- a/libjava/classpath/native/jni/java-io/Makefile.in
+++ b/libjava/classpath/native/jni/java-io/Makefile.in
@@ -361,9 +361,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavaio.la 
diff --git a/libjava/classpath/native/jni/java-lang/Makefile.in b/libjava/classpath/native/jni/java-lang/Makefile.in
index cbf37b7b3..37e44e30e 100644
--- a/libjava/classpath/native/jni/java-lang/Makefile.in
+++ b/libjava/classpath/native/jni/java-lang/Makefile.in
@@ -375,9 +375,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavalang.la libjavalangreflect.la libjavalangmanagement.la
diff --git a/libjava/classpath/native/jni/java-math/Makefile.in b/libjava/classpath/native/jni/java-math/Makefile.in
index 710ea1046..9d4140996 100644
--- a/libjava/classpath/native/jni/java-math/Makefile.in
+++ b/libjava/classpath/native/jni/java-math/Makefile.in
@@ -359,9 +359,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavamath.la
diff --git a/libjava/classpath/native/jni/java-net/Makefile.in b/libjava/classpath/native/jni/java-net/Makefile.in
index f40a7f006..0be112f47 100644
--- a/libjava/classpath/native/jni/java-net/Makefile.in
+++ b/libjava/classpath/native/jni/java-net/Makefile.in
@@ -371,9 +371,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavanet.la
diff --git a/libjava/classpath/native/jni/java-nio/Makefile.in b/libjava/classpath/native/jni/java-nio/Makefile.in
index 242d92302..18f08dd86 100644
--- a/libjava/classpath/native/jni/java-nio/Makefile.in
+++ b/libjava/classpath/native/jni/java-nio/Makefile.in
@@ -369,9 +369,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavanio.la
diff --git a/libjava/classpath/native/jni/java-util/Makefile.in b/libjava/classpath/native/jni/java-util/Makefile.in
index 0c397fef6..2309dede8 100644
--- a/libjava/classpath/native/jni/java-util/Makefile.in
+++ b/libjava/classpath/native/jni/java-util/Makefile.in
@@ -358,9 +358,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libjavautil.la
diff --git a/libjava/classpath/native/jni/midi-alsa/Makefile.in b/libjava/classpath/native/jni/midi-alsa/Makefile.in
index 2d09a6792..913da4dc2 100644
--- a/libjava/classpath/native/jni/midi-alsa/Makefile.in
+++ b/libjava/classpath/native/jni/midi-alsa/Makefile.in
@@ -361,9 +361,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgjsmalsa.la 
diff --git a/libjava/classpath/native/jni/midi-dssi/Makefile.in b/libjava/classpath/native/jni/midi-dssi/Makefile.in
index 25f9c9e23..355185f71 100644
--- a/libjava/classpath/native/jni/midi-dssi/Makefile.in
+++ b/libjava/classpath/native/jni/midi-dssi/Makefile.in
@@ -361,9 +361,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgjsmdssi.la 
diff --git a/libjava/classpath/native/jni/native-lib/Makefile.in b/libjava/classpath/native/jni/native-lib/Makefile.in
index d56d058af..69769a957 100644
--- a/libjava/classpath/native/jni/native-lib/Makefile.in
+++ b/libjava/classpath/native/jni/native-lib/Makefile.in
@@ -350,9 +350,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 noinst_LTLIBRARIES = libclasspathnative.la
diff --git a/libjava/classpath/native/jni/qt-peer/Makefile.in b/libjava/classpath/native/jni/qt-peer/Makefile.in
index 36c0bf141..fa9182d94 100644
--- a/libjava/classpath/native/jni/qt-peer/Makefile.in
+++ b/libjava/classpath/native/jni/qt-peer/Makefile.in
@@ -376,9 +376,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 noinst_LTLIBRARIES = libqtpeer.la
diff --git a/libjava/classpath/native/jni/xmlj/Makefile.in b/libjava/classpath/native/jni/xmlj/Makefile.in
index 351536a06..61fd93aa3 100644
--- a/libjava/classpath/native/jni/xmlj/Makefile.in
+++ b/libjava/classpath/native/jni/xmlj/Makefile.in
@@ -360,9 +360,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libxmlj.la
diff --git a/libjava/classpath/native/plugin/Makefile.in b/libjava/classpath/native/plugin/Makefile.in
index 8f07d0e64..e7d11cd60 100644
--- a/libjava/classpath/native/plugin/Makefile.in
+++ b/libjava/classpath/native/plugin/Makefile.in
@@ -358,9 +358,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 nativeexeclib_LTLIBRARIES = libgcjwebplugin.la
diff --git a/libjava/classpath/resource/Makefile.in b/libjava/classpath/resource/Makefile.in
index 2618f2797..24ef94773 100644
--- a/libjava/classpath/resource/Makefile.in
+++ b/libjava/classpath/resource/Makefile.in
@@ -343,9 +343,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 logging_DATA = java/util/logging/logging.properties
diff --git a/libjava/classpath/scripts/Makefile.in b/libjava/classpath/scripts/Makefile.in
index f343150e6..3e3b76c00 100644
--- a/libjava/classpath/scripts/Makefile.in
+++ b/libjava/classpath/scripts/Makefile.in
@@ -333,9 +333,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 EXTRA_DIST = generate-locale-list.sh import-cacerts.sh
diff --git a/libjava/classpath/tools/Makefile.in b/libjava/classpath/tools/Makefile.in
index 43d374a52..6284763bb 100644
--- a/libjava/classpath/tools/Makefile.in
+++ b/libjava/classpath/tools/Makefile.in
@@ -448,9 +448,12 @@ sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 uudecode = @uudecode@
 vm_classes = @vm_classes@
 @CREATE_GJDOC_TRUE@gjdoc_gendir = ${top_srcdir}/tools/generated
diff --git a/libjava/configure b/libjava/configure
index c79986852..aa3f8c00d 100755
--- a/libjava/configure
+++ b/libjava/configure
@@ -26568,10 +26568,10 @@ gcjsubdir=gcj-$gcjversion-$libgcj_soversion
 multi_os_directory=`$CC -print-multi-os-directory`
 case $multi_os_directory in
   .)
-   dbexecdir='$(libdir)/'$gcjsubdir # Avoid /.
+   dbexecdir='$(toolexeclibdir)/'$gcjsubdir # Avoid /.
    ;;
   *)
-   dbexecdir='$(libdir)/'$multi_os_directory/$gcjsubdir
+   dbexecdir='$(toolexeclibdir)/'$multi_os_directory/$gcjsubdir
    ;;
 esac
 
@@ -27667,6 +27667,7 @@ fi
 
 # See if we support thread-local storage.
 
+
    # Check whether --enable-tls or --disable-tls was given.
 if test "${enable_tls+set}" = set; then
   enableval="$enable_tls"
@@ -27698,6 +27699,74 @@ cat >conftest.$ac_ext <<_ACEOF
 __thread int a; int b; int main() { return a = b; }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>conftest.er1
   ac_status=$?
@@ -27724,6 +27793,24 @@ else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 gcc_cv_have_tls=no
 fi
 rm -f conftest.err conftest.$ac_objext \
diff --git a/libjava/configure.ac b/libjava/configure.ac
index 5f8fc3f8d..b7f5b2c56 100644
--- a/libjava/configure.ac
+++ b/libjava/configure.ac
@@ -879,7 +879,7 @@ case "${host}" in
     # on Darwin -single_module speeds up loading of the dynamic libraries.
     extra_ldflags_libjava=-Wl,-single_module
     ;;
-arm*linux*eabi)
+arm*-*-linux-*eabi*)
     # Some of the ARM unwinder code is actually in libstdc++.  We
     # could in principle replicate it in libgcj, but it's better to
     # have a dependency on libstdc++.
@@ -1459,6 +1459,7 @@ AC_SUBST(CHECKREFSPEC)
 AC_SUBST(EXCEPTIONSPEC)
 AC_SUBST(BACKTRACESPEC)
 AC_SUBST(IEEESPEC)
+AC_SUBST(ATOMICSPEC)
 
 AM_CONDITIONAL(NATIVE, test "$NATIVE" = yes)
 AM_CONDITIONAL(ENABLE_SHARED, test "$enable_shared" = yes)
@@ -1512,10 +1513,10 @@ gcjsubdir=gcj-$gcjversion-$libgcj_soversion
 multi_os_directory=`$CC -print-multi-os-directory`
 case $multi_os_directory in
   .)
-   dbexecdir='$(libdir)/'$gcjsubdir # Avoid /.
+   dbexecdir='$(toolexeclibdir)/'$gcjsubdir # Avoid /.
    ;;
   *)
-   dbexecdir='$(libdir)/'$multi_os_directory/$gcjsubdir
+   dbexecdir='$(toolexeclibdir)/'$multi_os_directory/$gcjsubdir
    ;;
 esac
 AC_SUBST(dbexecdir)
diff --git a/libjava/configure.host b/libjava/configure.host
index 6f3f865cf..9110f1c33 100644
--- a/libjava/configure.host
+++ b/libjava/configure.host
@@ -69,6 +69,7 @@ DIVIDESPEC=-fuse-divide-subroutine
 EXCEPTIONSPEC=-fnon-call-exceptions
 CHECKREFSPEC=
 BACKTRACESPEC=
+ATOMICSPEC=
 
 # This case statement supports per-CPU defaults.
 case "${host}" in
@@ -88,6 +89,7 @@ case "${host}" in
 	sysdeps_dir=arm
 	fallback_backtrace_h=sysdep/arm/backtrace.h
 	libgcj_cxxflags=-Wno-abi
+	ATOMICSPEC=-fuse-atomic-builtins
 	;;
   mips-tx39-*|mipstx39-unknown-*)
 	libgcj_flags="${libgcj_flags} -G 0"
diff --git a/libjava/libgcj.spec.in b/libjava/libgcj.spec.in
index 72d715f5a..b6850eb1e 100644
--- a/libjava/libgcj.spec.in
+++ b/libjava/libgcj.spec.in
@@ -9,4 +9,4 @@
 %rename lib liborig
 *lib: @LD_START_STATIC_SPEC@ @LIBGCJ_SPEC@ @LD_FINISH_STATIC_SPEC@ -lm @LIBICONV@ @GCSPEC@ @THREADSPEC@ @ZLIBSPEC@ @SYSTEMSPEC@ %(libgcc) @LIBSTDCXXSPEC@ %(liborig)
 
-*jc1: @HASH_SYNC_SPEC@ @DIVIDESPEC@ @CHECKREFSPEC@ @JC1GCSPEC@ @EXCEPTIONSPEC@ @BACKTRACESPEC@ @IEEESPEC@ -fkeep-inline-functions
+*jc1: @HASH_SYNC_SPEC@ @DIVIDESPEC@ @CHECKREFSPEC@ @JC1GCSPEC@ @EXCEPTIONSPEC@ @BACKTRACESPEC@ @IEEESPEC@ @ATOMICSPEC@ -fkeep-inline-functions
diff --git a/libjava/stacktrace.cc b/libjava/stacktrace.cc
index d8d1f38ae..c10539fe3 100644
--- a/libjava/stacktrace.cc
+++ b/libjava/stacktrace.cc
@@ -110,6 +110,9 @@ _Jv_StackTrace::UnwindTraceFn (struct _Unwind_Context *context, void *state_ptr)
   // Check if the trace buffer needs to be extended.
   if (pos == state->length)
     {
+      // http://gcc.gnu.org/ml/java/2008-06/msg00010.html
+      return _URC_END_OF_STACK;
+
       int newLength = state->length * 2;
       void *newFrames = _Jv_AllocBytes (newLength * sizeof(_Jv_StackFrame));
       memcpy (newFrames, state->frames, state->length * sizeof(_Jv_StackFrame));      
diff --git a/libjava/sysdep/arm/locks.h b/libjava/sysdep/arm/locks.h
index 1f7763de3..2a81e1111 100644
--- a/libjava/sysdep/arm/locks.h
+++ b/libjava/sysdep/arm/locks.h
@@ -13,6 +13,59 @@ details.  */
 
 typedef size_t obj_addr_t;	/* Integer type big enough for object	*/
 				/* address.				*/
+#if (__ARM_EABI__ && __linux)
+
+// Atomically replace *addr by new_val if it was initially equal to old.
+// Return true if the comparison succeeded.
+// Assumed to have acquire semantics, i.e. later memory operations
+// cannot execute before the compare_and_swap finishes.
+inline static bool
+compare_and_swap(volatile obj_addr_t *addr,
+                 obj_addr_t old,
+                 obj_addr_t new_val)
+{
+  return __sync_bool_compare_and_swap(addr, old, new_val);
+}
+
+// Set *addr to new_val with release semantics, i.e. making sure
+// that prior loads and stores complete before this
+// assignment.
+inline static void
+release_set(volatile obj_addr_t *addr, obj_addr_t new_val)
+{
+  __sync_synchronize();
+  *(addr) = new_val;
+}
+
+// Compare_and_swap with release semantics instead of acquire semantics.
+// On many architecture, the operation makes both guarantees, so the
+// implementation can be the same.
+inline static bool
+compare_and_swap_release(volatile obj_addr_t *addr,
+			 obj_addr_t old,
+			 obj_addr_t new_val)
+{
+  return __sync_bool_compare_and_swap(addr, old, new_val);
+}
+
+// Ensure that subsequent instructions do not execute on stale
+// data that was loaded from memory before the barrier.
+// On X86, the hardware ensures that reads are properly ordered.
+inline static void
+read_barrier()
+{
+  __sync_synchronize();
+}
+
+// Ensure that prior stores to memory are completed with respect to other
+// processors.
+inline static void
+write_barrier()
+{
+  __sync_synchronize();
+}
+
+#else
 
 /* Atomic compare and exchange.  These sequences are not actually
    atomic; there is a race if *ADDR != OLD_VAL and we are preempted
@@ -54,8 +107,8 @@ release_set(volatile obj_addr_t *addr, obj_addr_t new_val)
 
 inline static bool
 compare_and_swap_release(volatile obj_addr_t *addr,
-		  				     obj_addr_t old,
-						     obj_addr_t new_val)
+			 obj_addr_t old,
+			 obj_addr_t new_val)
 {
   return compare_and_swap(addr, old, new_val);
 }
@@ -77,3 +130,4 @@ write_barrier()
 }
 
 #endif
+#endif
diff --git a/libmudflap/configure b/libmudflap/configure
index ae1be92e2..74e8e6101 100755
--- a/libmudflap/configure
+++ b/libmudflap/configure
@@ -12740,6 +12740,7 @@ fi
 
 # See if we support thread-local storage.
 
+
    # Check whether --enable-tls or --disable-tls was given.
 if test "${enable_tls+set}" = set; then
   enableval="$enable_tls"
@@ -12766,6 +12767,64 @@ else
 __thread int a; int b; int main() { return a = b; }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>conftest.er1
   ac_status=$?
@@ -12792,6 +12851,24 @@ else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 gcc_cv_have_tls=no
 fi
 rm -f conftest.err conftest.$ac_objext \
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index 186916c2e..9073acc0b 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -2429,8 +2429,7 @@ dnl is intended to be an all-or-nothing switch, so all the atomic operations
 dnl that are used should be checked.
 dnl
 dnl Note:
-dnl libgomp and libgfortran do this with a link test, instead of an asm test.
-dnl see: CHECK_SYNC_FETCH_AND_ADD
+dnl libgomp and libgfortran use a link test, see CHECK_SYNC_FETCH_AND_ADD.
 dnl
 dnl Defines:
 dnl  _GLIBCXX_ATOMIC_BUILTINS_1 
@@ -2442,12 +2441,120 @@ AC_DEFUN([GLIBCXX_ENABLE_ATOMIC_BUILTINS], [
   AC_LANG_SAVE
   AC_LANG_CPLUSPLUS
   old_CXXFLAGS="$CXXFLAGS"
-  
+
+  # Do link tests if possible, instead asm tests, limited to some platforms
+  atomic_builtins_link_tests=no
+  if test x$gcc_no_link != xyes; then
+    # Can do link tests. Limit to some tested platforms
+    case "$host" in
+      *-*-linux* | *-*-kfreebsd*-gnu | *-*-gnu*)
+	atomic_builtins_link_tests=yes
+        ;;
+    esac
+  fi
+
+  if test x$atomic_builtins_link_tests = xyes; then
+
+  # Do link tests.
+
+  CXXFLAGS="$CXXFLAGS -fno-exceptions"
+
+  AC_MSG_CHECKING([for atomic builtins for bool])
+  AC_CACHE_VAL(glibcxx_cv_atomic_bool, [
+    AC_TRY_LINK(
+      [ ],
+      [typedef bool atomic_type;
+       atomic_type c1;
+       atomic_type c2;
+       const atomic_type c3(0);
+       __sync_fetch_and_add(&c1, c2);
+       __sync_val_compare_and_swap(&c1, c3, c2);
+       __sync_lock_test_and_set(&c1, c3);
+       __sync_lock_release(&c1);
+       __sync_synchronize();],
+      [glibcxx_cv_atomic_bool=yes],
+      [glibcxx_cv_atomic_bool=no])
+  ])    
+  if test $glibcxx_cv_atomic_bool = yes; then
+    AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_1, 1,
+      [Define if builtin atomic operations for bool are supported on this host.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_atomic_bool)
+
+  AC_MSG_CHECKING([for atomic builtins for short])
+  AC_CACHE_VAL(glibcxx_cv_atomic_short, [
+    AC_TRY_LINK(
+      [ ],
+      [typedef short atomic_type;
+       atomic_type c1;
+       atomic_type c2;
+       const atomic_type c3(0);
+       __sync_fetch_and_add(&c1, c2);
+       __sync_val_compare_and_swap(&c1, c3, c2);
+       __sync_lock_test_and_set(&c1, c3);
+       __sync_lock_release(&c1);
+       __sync_synchronize();],
+      [glibcxx_cv_atomic_short=yes],
+      [glibcxx_cv_atomic_short=no])
+  ])    
+  if test $glibcxx_cv_atomic_short = yes; then
+    AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_2, 1,
+      [Define if builtin atomic operations for short are supported on this host.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_atomic_short)
+
+  AC_MSG_CHECKING([for atomic builtins for int])
+  AC_CACHE_VAL(glibcxx_cv_atomic_int, [
+    AC_TRY_LINK(
+      [ ],
+      [typedef int atomic_type;
+       atomic_type c1;
+       atomic_type c2;
+       const atomic_type c3(0);
+       __sync_fetch_and_add(&c1, c2);
+       __sync_val_compare_and_swap(&c1, c3, c2);
+       __sync_lock_test_and_set(&c1, c3);
+       __sync_lock_release(&c1);
+       __sync_synchronize();],
+      [glibcxx_cv_atomic_int=yes],
+      [glibcxx_cv_atomic_int=no])
+  ])    
+  if test $glibcxx_cv_atomic_int = yes; then
+    AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_4, 1,
+      [Define if builtin atomic operations for int are supported on this host.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_atomic_int)
+
+  AC_MSG_CHECKING([for atomic builtins for long long])
+  AC_CACHE_VAL(glibcxx_cv_atomic_long_long, [
+    AC_TRY_LINK(
+      [ ],
+      [typedef long long atomic_type;
+       atomic_type c1;
+       atomic_type c2;
+       const atomic_type c3(0);
+       __sync_fetch_and_add(&c1, c2);
+       __sync_val_compare_and_swap(&c1, c3, c2);
+       __sync_lock_test_and_set(&c1, c3);
+       __sync_lock_release(&c1);
+       __sync_synchronize();],
+      [glibcxx_cv_atomic_long_long=yes],
+      [glibcxx_cv_atomic_long_long=no])
+  ])    
+  if test $glibcxx_cv_atomic_long_long = yes; then
+    AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_8, 1,
+      [Define if builtin atomic operations for long long are supported on this host.])
+  fi
+  AC_MSG_RESULT($glibcxx_cv_atomic_long_long)
+
+  else
+
+  # Do asm tests.
+
   # Compile unoptimized.
   CXXFLAGS='-O0 -S'
 
-  # Fake what AC_TRY_COMPILE does, without linking as this is
-  # unnecessary for a builtins test.
+  # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
 [#]line __oline__ "configure"
@@ -2469,14 +2576,14 @@ EOF
     AC_MSG_CHECKING([for atomic builtins for bool])
     if AC_TRY_EVAL(ac_compile); then
       if grep __sync_ conftest.s >/dev/null 2>&1 ; then
-        enable_atomic_builtinsb=no
+        glibcxx_cv_atomic_bool=no
       else
       AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_1, 1,
       [Define if builtin atomic operations for bool are supported on this host.])
-        enable_atomic_builtinsb=yes
+        glibcxx_cv_atomic_bool=yes
       fi
     fi
-    AC_MSG_RESULT($enable_atomic_builtinsb)
+    AC_MSG_RESULT($glibcxx_cv_atomic_bool)
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
@@ -2499,14 +2606,14 @@ EOF
     AC_MSG_CHECKING([for atomic builtins for short])
     if AC_TRY_EVAL(ac_compile); then
       if grep __sync_ conftest.s >/dev/null 2>&1 ; then
-        enable_atomic_builtinss=no
+        glibcxx_cv_atomic_short=no
       else
       AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_2, 1,
       [Define if builtin atomic operations for short are supported on this host.])
-        enable_atomic_builtinss=yes
+        glibcxx_cv_atomic_short=yes
       fi
     fi
-    AC_MSG_RESULT($enable_atomic_builtinss)
+    AC_MSG_RESULT($glibcxx_cv_atomic_short)
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
@@ -2530,14 +2637,14 @@ EOF
     AC_MSG_CHECKING([for atomic builtins for int])
     if AC_TRY_EVAL(ac_compile); then
       if grep __sync_ conftest.s >/dev/null 2>&1 ; then
-        enable_atomic_builtinsi=no
+        glibcxx_cv_atomic_int=no
       else
       AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_4, 1,
         [Define if builtin atomic operations for int are supported on this host.])
-        enable_atomic_builtinsi=yes
+        glibcxx_cv_atomic_int=yes
       fi
     fi
-    AC_MSG_RESULT($enable_atomic_builtinsi)
+    AC_MSG_RESULT($glibcxx_cv_atomic_int)
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
@@ -2560,22 +2667,23 @@ EOF
     AC_MSG_CHECKING([for atomic builtins for long long])
     if AC_TRY_EVAL(ac_compile); then
       if grep __sync_ conftest.s >/dev/null 2>&1 ; then
-        enable_atomic_builtinsll=no
+        glibcxx_cv_atomic_long_long=no
       else
       AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_8, 1,
       [Define if builtin atomic operations for long long are supported on this host.])
-        enable_atomic_builtinsll=yes
+        glibcxx_cv_atomic_long_long=yes
       fi
     fi
-    AC_MSG_RESULT($enable_atomic_builtinsll)
+    AC_MSG_RESULT($glibcxx_cv_atomic_long_long)
     rm -f conftest*
 
+  fi
 
   CXXFLAGS="$old_CXXFLAGS"
   AC_LANG_RESTORE
 
   # Set atomicity_dir to builtins if either of above tests pass.
-  if test $enable_atomic_builtinsi = yes || test $enable_atomic_builtinsb = yes ; then
+  if test $glibcxx_cv_atomic_int = yes || test $glibcxx_cv_atomic_bool = yes ; then
     atomicity_dir=cpu/generic/atomicity_builtins
   fi
 
diff --git a/libstdc++-v3/config/cpu/sh/atomicity.h b/libstdc++-v3/config/cpu/sh/atomicity.h
index cecbf555e..7fb0f5733 100644
--- a/libstdc++-v3/config/cpu/sh/atomicity.h
+++ b/libstdc++-v3/config/cpu/sh/atomicity.h
@@ -25,47 +25,48 @@
 
 #ifdef __SH4A__
 
-#ifndef _GLIBCXX_ATOMICITY_H
-#define _GLIBCXX_ATOMICITY_H	1
+#include <ext/atomicity.h>
 
-typedef int _Atomic_word;
+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)
 
-static inline _Atomic_word
-__attribute__ ((__unused__))
-__exchange_and_add (volatile _Atomic_word* __mem, int __val)
-{
-  _Atomic_word __result;
-
-  __asm__ __volatile__
-    ("0:\n"
-     "\tmovli.l\t@%2,r0\n"
-     "\tmov\tr0,%1\n"
-     "\tadd\t%3,r0\n"
-     "\tmovco.l\tr0,@%2\n"
-     "\tbf\t0b"
-     : "+m" (*__mem), "=r" (__result)
-     : "r" (__mem), "rI08" (__val)
-     : "r0");
-
-  return __result;
-}
-
-
-static inline void
-__attribute__ ((__unused__))
-__atomic_add (volatile _Atomic_word* __mem, int __val)
-{
-  asm("0:\n"
-      "\tmovli.l\t@%1,r0\n"
-      "\tadd\t%2,r0\n"
-      "\tmovco.l\tr0,@%1\n"
-      "\tbf\t0b"
-      : "+m" (*__mem)
-      : "r" (__mem), "rI08" (__val)
-      : "r0");
-}
-
-#endif
+  typedef int _Atomic_word;
+
+  _Atomic_word
+  __attribute__ ((__unused__))
+  __exchange_and_add (volatile _Atomic_word* __mem, int __val)
+  {
+    _Atomic_word __result;
+
+    __asm__ __volatile__
+      ("0:\n"
+       "\tmovli.l\t@%2,r0\n"
+       "\tmov\tr0,%1\n"
+       "\tadd\t%3,r0\n"
+       "\tmovco.l\tr0,@%2\n"
+       "\tbf\t0b"
+       : "+m" (*__mem), "=&r" (__result)
+       : "r" (__mem), "rI08" (__val)
+       : "r0");
+
+    return __result;
+  }
+
+
+  void
+  __attribute__ ((__unused__))
+  __atomic_add (volatile _Atomic_word* __mem, int __val)
+  {
+    asm("0:\n"
+	"\tmovli.l\t@%1,r0\n"
+	"\tadd\t%2,r0\n"
+	"\tmovco.l\tr0,@%1\n"
+	"\tbf\t0b"
+	: "+m" (*__mem)
+	: "r" (__mem), "rI08" (__val)
+	: "r0");
+  }
+
+_GLIBCXX_END_NAMESPACE
 
 #else /* !__SH4A__ */
 
diff --git a/libstdc++-v3/config/os/nucleus/arm-eabi-extra.ver b/libstdc++-v3/config/os/nucleus/arm-eabi-extra.ver
new file mode 100644
index 000000000..5c7dc19e6
--- /dev/null
+++ b/libstdc++-v3/config/os/nucleus/arm-eabi-extra.ver
@@ -0,0 +1,18 @@
+# Appended to version file.
+
+CXXABI_ARM_1.3.3 {
+   # ARM ABI helper functions provided in libsupc++.
+   __aeabi_atexit;
+   __aeabi_vec_ctor_nocookie_nodtor;
+   __aeabi_vec_ctor_cookie_nodtor;
+   __aeabi_vec_cctor_nocookie_nodtor;
+   __aeabi_vec_new_cookie_noctor;
+   __aeabi_vec_new_nocookie;
+   __aeabi_vec_new_cookie_nodtor;
+   __aeabi_vec_new_cookie;
+   __aeabi_vec_dtor;
+   __aeabi_vec_dtor_cookie;
+   __aeabi_vec_delete;
+   __aeabi_vec_delete3;
+   __aeabi_vec_delete3_nodtor;
+};
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 20803a6ea..2d70646b3 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -4969,6 +4969,10 @@ cegcc)
   lt_cv_file_magic_cmd='$OBJDUMP -f'
   ;;
 
+nucleuseabi*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 darwin* | rhapsody*)
   lt_cv_deplibs_check_method=pass_all
   ;;
@@ -5730,7 +5734,7 @@ ia64-*-hpux*)
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 5733 "configure"' > conftest.$ac_ext
+  echo '#line 5737 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -7876,11 +7880,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7879: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7883: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7883: \$? = $ac_status" >&5
+   echo "$as_me:7887: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8215,11 +8219,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8218: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8222: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8222: \$? = $ac_status" >&5
+   echo "$as_me:8226: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8320,11 +8324,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8323: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8327: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8327: \$? = $ac_status" >&5
+   echo "$as_me:8331: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -8375,11 +8379,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8378: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8382: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8382: \$? = $ac_status" >&5
+   echo "$as_me:8386: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -10294,6 +10298,21 @@ newsos6)
   shlibpath_overrides_runpath=yes
   ;;
 
+nucleus*)
+  case $host_vendor in
+    samsung)
+      version_type=linux
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+      soname_spec='$libname${shared_ext}$major'
+      shlibpath_var=LD_LIBRARY_PATH
+      hardcode_into_libs=yes
+      ;;
+    *)
+      dynamic_linker=no
+      ;;
+  esac
+  ;;
+
 *nto* | *qnx*)
   version_type=qnx
   need_lib_prefix=no
@@ -11242,7 +11261,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11245 "configure"
+#line 11264 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11338,7 +11357,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11341 "configure"
+#line 11360 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -13364,11 +13383,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13367: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13386: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:13371: \$? = $ac_status" >&5
+   echo "$as_me:13390: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -13463,11 +13482,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13466: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13485: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:13470: \$? = $ac_status" >&5
+   echo "$as_me:13489: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -13515,11 +13534,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13518: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13537: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:13522: \$? = $ac_status" >&5
+   echo "$as_me:13541: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -14220,6 +14239,21 @@ newsos6)
   shlibpath_overrides_runpath=yes
   ;;
 
+nucleus*)
+  case $host_vendor in
+    samsung)
+      version_type=linux
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+      soname_spec='$libname${shared_ext}$major'
+      shlibpath_var=LD_LIBRARY_PATH
+      hardcode_into_libs=yes
+      ;;
+    *)
+      dynamic_linker=no
+      ;;
+  esac
+  ;;
+
 *nto* | *qnx*)
   version_type=qnx
   need_lib_prefix=no
@@ -14592,7 +14626,7 @@ fi;
     #
     # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.
     cat > conftest.$ac_ext << EOF
-#line 14595 "configure"
+#line 14629 "configure"
 struct S { ~S(); };
 void bar();
 void foo()
@@ -14764,7 +14798,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
   # unnecessary for a builtins test.
 
     cat > conftest.$ac_ext << EOF
-#line 14767 "configure"
+#line 14801 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -14803,7 +14837,7 @@ echo "${ECHO_T}$enable_atomic_builtinsb" >&6
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 14806 "configure"
+#line 14840 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -14842,7 +14876,7 @@ echo "${ECHO_T}$enable_atomic_builtinss" >&6
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 14845 "configure"
+#line 14879 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -14882,7 +14916,7 @@ echo "${ECHO_T}$enable_atomic_builtinsi" >&6
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 14885 "configure"
+#line 14919 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -40678,6 +40712,7 @@ _ACEOF
 
   # For TLS support.
 
+
    # Check whether --enable-tls or --disable-tls was given.
 if test "${enable_tls+set}" = set; then
   enableval="$enable_tls"
@@ -40709,6 +40744,74 @@ cat >conftest.$ac_ext <<_ACEOF
 __thread int a; int b; int main() { return a = b; }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>conftest.er1
   ac_status=$?
@@ -40735,6 +40838,24 @@ else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 gcc_cv_have_tls=no
 fi
 rm -f conftest.err conftest.$ac_objext \
@@ -76874,6 +76995,7 @@ _ACEOF
 
 
 
+
    # Check whether --enable-tls or --disable-tls was given.
 if test "${enable_tls+set}" = set; then
   enableval="$enable_tls"
@@ -76905,6 +77027,74 @@ cat >conftest.$ac_ext <<_ACEOF
 __thread int a; int b; int main() { return a = b; }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>conftest.er1
   ac_status=$?
@@ -76931,6 +77121,24 @@ else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 gcc_cv_have_tls=no
 fi
 rm -f conftest.err conftest.$ac_objext \
@@ -94489,6 +94697,7 @@ done
 _ACEOF
 
 
+
    # Check whether --enable-tls or --disable-tls was given.
 if test "${enable_tls+set}" = set; then
   enableval="$enable_tls"
@@ -94520,6 +94729,74 @@ cat >conftest.$ac_ext <<_ACEOF
 __thread int a; int b; int main() { return a = b; }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  chktls_save_LDFLAGS="$LDFLAGS"
+	  	  	  case $host in
+	    *-*-linux*)
+	      LDFLAGS="-shared -Wl,--no-undefined $LDFLAGS"
+	      ;;
+	  esac
+	  chktls_save_CFLAGS="$CFLAGS"
+	  CFLAGS="-fPIC $CFLAGS"
+	  	  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+int f() { return 0; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+__thread int a; int b; int f() { return a = b; }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>conftest.er1
   ac_status=$?
@@ -94546,6 +94823,24 @@ else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+gcc_cv_have_tls=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gcc_cv_have_tls=yes
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+	  CFLAGS="$chktls_save_CFLAGS"
+	  LDFLAGS="$chktls_save_LDFLAGS"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 gcc_cv_have_tls=no
 fi
 rm -f conftest.err conftest.$ac_objext \
@@ -114470,7 +114765,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114534,7 +114830,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114575,7 +114872,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114632,7 +114930,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114673,7 +114972,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114738,7 +115038,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114806,7 +115107,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (void *)); }
 unsigned long ulongval () { return (long) (sizeof (void *)); }
 #include <stdio.h>
@@ -114894,7 +115196,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114958,7 +115261,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -114999,7 +115303,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115056,7 +115361,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115097,7 +115403,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115162,7 +115469,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115230,7 +115538,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (long)); }
 unsigned long ulongval () { return (long) (sizeof (long)); }
 #include <stdio.h>
@@ -115318,7 +115627,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115382,7 +115692,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115423,7 +115734,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115480,7 +115792,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115521,7 +115834,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115586,7 +115900,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115654,7 +115969,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (int)); }
 unsigned long ulongval () { return (long) (sizeof (int)); }
 #include <stdio.h>
@@ -115738,7 +116054,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115802,7 +116119,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115843,7 +116161,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115900,7 +116219,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -115941,7 +116261,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116006,7 +116327,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116074,7 +116396,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (short)); }
 unsigned long ulongval () { return (long) (sizeof (short)); }
 #include <stdio.h>
@@ -116158,7 +116481,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116222,7 +116546,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116263,7 +116588,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116320,7 +116646,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116361,7 +116688,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116426,7 +116754,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 int
 main ()
 {
@@ -116494,7 +116823,8 @@ _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+/* no standard headers */
+
 long longval () { return (long) (sizeof (char)); }
 unsigned long ulongval () { return (long) (sizeof (char)); }
 #include <stdio.h>
diff --git a/libstdc++-v3/configure.host b/libstdc++-v3/configure.host
index 68ba288ec..aec80c5cd 100644
--- a/libstdc++-v3/configure.host
+++ b/libstdc++-v3/configure.host
@@ -312,11 +312,14 @@ case "${host}" in
         fi
     esac
     case "${host}" in
-      arm*-*-linux-*eabi)
+      arm*-*-linux-*eabi*)
 	port_specific_symbol_files="\$(srcdir)/../config/os/gnu-linux/arm-eabi-extra.ver"
 	;;
     esac
     ;;
+  arm*-*-nucleuseabi)
+    port_specific_symbol_files="\$(srcdir)/../config/os/nucleus/arm-eabi-extra.ver"
+    ;;
   powerpc*-*-darwin*)
     port_specific_symbol_files="\$(srcdir)/../config/os/bsd/darwin/ppc-extra.ver"
     ;;
diff --git a/libstdc++-v3/include/c_global/cwchar b/libstdc++-v3/include/c_global/cwchar
index e5ea07e7d..0c3e542a8 100644
--- a/libstdc++-v3/include/c_global/cwchar
+++ b/libstdc++-v3/include/c_global/cwchar
@@ -156,14 +156,18 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   using ::mbsrtowcs;
   using ::putwc;
   using ::putwchar;
+#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
   using ::swprintf;
+#endif
   using ::swscanf;
   using ::ungetwc;
   using ::vfwprintf;
 #if _GLIBCXX_HAVE_VFWSCANF
   using ::vfwscanf;
 #endif
+#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
   using ::vswprintf;
+#endif
 #if _GLIBCXX_HAVE_VSWSCANF
   using ::vswscanf;
 #endif
diff --git a/libstdc++-v3/libsupc++/Makefile.am b/libstdc++-v3/libsupc++/Makefile.am
index 5c86a1efd..6f63162f6 100644
--- a/libstdc++-v3/libsupc++/Makefile.am
+++ b/libstdc++-v3/libsupc++/Makefile.am
@@ -30,7 +30,6 @@ toolexeclib_LTLIBRARIES = libsupc++.la
 # 2) integrated libsupc++convenience.la that is to be a part of libstdc++.a
 noinst_LTLIBRARIES = libsupc++convenience.la
 
-
 headers = \
 	exception new typeinfo cxxabi.h cxxabi-forced.h exception_defines.h \
 	initializer_list exception_ptr.h
diff --git a/libstdc++-v3/libsupc++/cxxabi.h b/libstdc++-v3/libsupc++/cxxabi.h
index bfdd8e589..e2fbb88e8 100644
--- a/libstdc++-v3/libsupc++/cxxabi.h
+++ b/libstdc++-v3/libsupc++/cxxabi.h
@@ -601,6 +601,82 @@ namespace __cxxabiv1
 */
 namespace abi = __cxxabiv1;
 
+#if defined(__arm__) && defined(__ARM_EABI__)
+
+// Also include the ARM specific routines.  This gives ensures they have
+// the correct visibility arrtibutes.
+
+namespace __aeabiv1
+{
+  extern "C" void *
+  __aeabi_vec_ctor_nocookie_nodtor (void *array_address,
+				    abi::__cxa_cdtor_type constructor,
+				    size_t element_size,
+				    size_t element_count);
+  extern "C" void *
+  __aeabi_vec_ctor_cookie_nodtor (void *array_address,
+				  abi::__cxa_cdtor_type constructor,
+				  size_t element_size,
+				  size_t element_count);
+  
+  extern "C" void *
+  __aeabi_vec_cctor_nocookie_nodtor (void *dest_array,
+				     void *src_array, 
+				     size_t element_size, 
+				     size_t element_count,
+				     void *(*constructor) (void *, void *));
+
+  extern "C" void *
+  __aeabi_vec_new_cookie_noctor (size_t element_size, 
+				 size_t element_count);
+
+  extern "C" void *
+  __aeabi_vec_new_nocookie (size_t element_size, 
+			    size_t element_count,
+			    abi::__cxa_cdtor_type constructor);
+
+  extern "C" void *
+  __aeabi_vec_new_cookie_nodtor (size_t element_size, 
+				 size_t element_count,
+				 abi::__cxa_cdtor_type constructor);
+
+  extern "C" void *
+  __aeabi_vec_new_cookie(size_t element_size, 
+			 size_t element_count,
+			 abi::__cxa_cdtor_type constructor,
+			 abi::__cxa_cdtor_type destructor);
+  
+  extern "C" void *
+  __aeabi_vec_dtor (void *array_address, 
+		    abi::__cxa_cdtor_type destructor,
+		    size_t element_size, 
+		    size_t element_count);
+
+  extern "C" void *
+  __aeabi_vec_dtor_cookie (void *array_address, 
+			   abi::__cxa_cdtor_type destructor);
+  
+  extern "C" void
+  __aeabi_vec_delete (void *array_address, 
+		      abi::__cxa_cdtor_type destructor);
+
+  extern "C" void
+  __aeabi_vec_delete3 (void *array_address, 
+		       abi::__cxa_cdtor_type destructor,
+		       void (*dealloc) (void *, size_t));
+
+  extern "C" void
+  __aeabi_vec_delete3_nodtor (void *array_address,
+			      void (*dealloc) (void *, size_t));
+
+  extern "C" int
+  __aeabi_atexit (void *object, 
+		  void (*destructor) (void *),
+		  void *dso_handle) throw ();
+} // namespace __aeabiv1
+
+#endif // defined(__arm__) && defined(__ARM_EABI__)
+
 #endif // __cplusplus
 
 #pragma GCC visibility pop
diff --git a/libstdc++-v3/libsupc++/dyncast.cc b/libstdc++-v3/libsupc++/dyncast.cc
index f565ed459..cb97bc50e 100644
--- a/libstdc++-v3/libsupc++/dyncast.cc
+++ b/libstdc++-v3/libsupc++/dyncast.cc
@@ -28,12 +28,26 @@ namespace __cxxabiv1 {
 
 
 // this is the external interface to the dynamic cast machinery
+/* sub: source address to be adjusted; nonnull, and since the
+ *      source object is polymorphic, *(void**)sub is a virtual pointer.
+ * src: static type of the source object.
+ * dst: destination type (the "T" in "dynamic_cast<T>(v)").
+ * src2dst_offset: a static hint about the location of the
+ *    source subobject with respect to the complete object;
+ *    special negative values are:
+ *       -1: no hint
+ *       -2: src is not a public base of dst
+ *       -3: src is a multiple public base type but never a
+ *           virtual base type
+ *    otherwise, the src type is a unique public nonvirtual
+ *    base type of dst at offset src2dst_offset from the
+ *    origin of dst.  */
 extern "C" void *
 __dynamic_cast (const void *src_ptr,    // object started from
                 const __class_type_info *src_type, // type of the starting object
                 const __class_type_info *dst_type, // desired target type
                 ptrdiff_t src2dst) // how src and dst are related
-{
+  {
   const void *vtable = *static_cast <const void *const *> (src_ptr);
   const vtable_prefix *prefix =
       adjust_pointer <vtable_prefix> (vtable, 
diff --git a/libstdc++-v3/libsupc++/eh_arm.cc b/libstdc++-v3/libsupc++/eh_arm.cc
index 58997cc17..0aecacb8e 100644
--- a/libstdc++-v3/libsupc++/eh_arm.cc
+++ b/libstdc++-v3/libsupc++/eh_arm.cc
@@ -22,6 +22,7 @@
 // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
+#include <typeinfo>
 #include <cxxabi.h>
 #include "unwind-cxx.h"
 
@@ -29,16 +30,15 @@
 
 using namespace __cxxabiv1;
 
-
 // Given the thrown type THROW_TYPE, pointer to a variable containing a
 // pointer to the exception object THROWN_PTR_P and a type CATCH_TYPE to
 // compare against, return whether or not there is a match and if so,
 // update *THROWN_PTR_P.
 
 extern "C" __cxa_type_match_result
-__cxa_type_match(_Unwind_Exception* ue_header,
-		 const std::type_info* catch_type,
-		 bool is_reference __attribute__((__unused__)),
+__cxxabiv1::__cxa_type_match(_Unwind_Exception* ue_header,
+			     const std::type_info* catch_type,
+			     bool is_reference,
 		 void** thrown_ptr_p)
 {
   bool forced_unwind = __is_gxx_forced_unwind_class(ue_header->exception_class);
@@ -68,11 +68,11 @@ __cxa_type_match(_Unwind_Exception* ue_header,
   if (throw_type->__is_pointer_p())
     thrown_ptr = *(void**) thrown_ptr;
 
-  if (catch_type->__do_catch(throw_type, &thrown_ptr, 1))
+  if (catch_type->__do_catch (throw_type, &thrown_ptr, 1 + is_reference * 2))
     {
       *thrown_ptr_p = thrown_ptr;
 
-      if (typeid(*catch_type) == typeid (typeid(void*)))
+      if (typeid (*catch_type) == typeid (typeid(void*)))
 	{
 	  const __pointer_type_info *catch_pointer_type =
 	    static_cast<const __pointer_type_info *> (catch_type);
@@ -93,7 +93,7 @@ __cxa_type_match(_Unwind_Exception* ue_header,
 
 // ABI defined routine called at the start of a cleanup handler.
 extern "C" bool
-__cxa_begin_cleanup(_Unwind_Exception* ue_header)
+__cxxabiv1::__cxa_begin_cleanup(_Unwind_Exception* ue_header)
 {
   __cxa_eh_globals *globals = __cxa_get_globals();
   __cxa_exception *header = __get_exception_header_from_ue(ue_header);
diff --git a/libstdc++-v3/libsupc++/eh_call.cc b/libstdc++-v3/libsupc++/eh_call.cc
index a737eb889..203e5bd29 100644
--- a/libstdc++-v3/libsupc++/eh_call.cc
+++ b/libstdc++-v3/libsupc++/eh_call.cc
@@ -37,8 +37,10 @@ using namespace __cxxabiv1;
 // terminate.
 
 extern "C" void
-__cxa_call_terminate(_Unwind_Exception* ue_header)
+__cxxabiv1::__cxa_call_terminate(__gnu_cxa_call_arg exc_obj_in)
 {
+  _Unwind_Exception* ue_header
+    = reinterpret_cast<_Unwind_Exception*>(exc_obj_in);
 
   if (ue_header)
     {
@@ -64,7 +66,7 @@ __cxa_call_terminate(_Unwind_Exception* ue_header)
 // The ARM EABI __cxa_call_unexpected has the same semantics as the generic
 // routine, but the exception specification has a different format.
 extern "C" void
-__cxa_call_unexpected(void* exc_obj_in)
+__cxxabiv1::__cxa_call_unexpected(_Unwind_Control_Block* exc_obj_in)
 {
   _Unwind_Exception* exc_obj
     = reinterpret_cast<_Unwind_Exception*>(exc_obj_in);
diff --git a/libstdc++-v3/libsupc++/eh_personality.cc b/libstdc++-v3/libsupc++/eh_personality.cc
index befb26c9d..fa163d102 100644
--- a/libstdc++-v3/libsupc++/eh_personality.cc
+++ b/libstdc++-v3/libsupc++/eh_personality.cc
@@ -89,20 +89,22 @@ parse_lsda_header (_Unwind_Context *context, const unsigned char *p,
 // Return an element from a type table.
 
 static const std::type_info*
-get_ttype_entry(lsda_header_info* info, _uleb128_t i)
+get_ttype_entry(lsda_header_info* info, _uleb128_t i, bool &is_ref)
 {
   _Unwind_Ptr ptr;
 
   ptr = (_Unwind_Ptr) (info->TType - (i * 4));
   ptr = _Unwind_decode_target2(ptr);
   
-  return reinterpret_cast<const std::type_info *>(ptr);
+  is_ref = ptr & 1;
+  
+  return reinterpret_cast<const std::type_info *>(ptr & ~1);
 }
 
 // The ABI provides a routine for matching exception object types.
 typedef _Unwind_Control_Block _throw_typet;
-#define get_adjusted_ptr(catch_type, throw_type, thrown_ptr_p) \
-  (__cxa_type_match (throw_type, catch_type, false, thrown_ptr_p) \
+#define get_adjusted_ptr(catch_type, throw_type, is_ref, thrown_ptr_p) \
+  (__cxa_type_match (throw_type, catch_type, is_ref, thrown_ptr_p) \
    != ctm_failed)
 
 // Return true if THROW_TYPE matches one if the filter types.
@@ -118,6 +120,7 @@ check_exception_spec(lsda_header_info* info, _throw_typet* throw_type,
     {
       const std::type_info* catch_type;
       _uleb128_t tmp;
+      bool is_ref;
 
       tmp = *e;
       
@@ -129,13 +132,14 @@ check_exception_spec(lsda_header_info* info, _throw_typet* throw_type,
       tmp = _Unwind_decode_target2((_Unwind_Word) e);
 
       // Match a ttype entry.
-      catch_type = reinterpret_cast<const std::type_info*>(tmp);
+      is_ref = tmp & 1;
+      catch_type = reinterpret_cast<const std::type_info*>(tmp & ~1);
 
       // ??? There is currently no way to ask the RTTI code about the
       // relationship between two types without reference to a specific
       // object.  There should be; then we wouldn't need to mess with
       // thrown_ptr here.
-      if (get_adjusted_ptr(catch_type, throw_type, &thrown_ptr))
+      if (get_adjusted_ptr(catch_type, throw_type, is_ref, &thrown_ptr))
 	return true;
 
       // Advance to the next entry.
@@ -207,7 +211,7 @@ typedef const std::type_info _throw_typet;
 // Return an element from a type table.
 
 static const std::type_info *
-get_ttype_entry (lsda_header_info *info, _uleb128_t i)
+get_ttype_entry (lsda_header_info *info, _uleb128_t i, bool &is_ref)
 {
   _Unwind_Ptr ptr;
 
@@ -215,7 +219,9 @@ get_ttype_entry (lsda_header_info *info, _uleb128_t i)
   read_encoded_value_with_base (info->ttype_encoding, info->ttype_base,
 				info->TType - i, &ptr);
 
-  return reinterpret_cast<const std::type_info *>(ptr);
+  is_ref = ptr & 1;
+  
+  return reinterpret_cast<const std::type_info *>(ptr & ~1);
 }
 
 // Given the thrown type THROW_TYPE, pointer to a variable containing a
@@ -226,6 +232,7 @@ get_ttype_entry (lsda_header_info *info, _uleb128_t i)
 static bool
 get_adjusted_ptr (const std::type_info *catch_type,
 		  const std::type_info *throw_type,
+		  bool is_ref,
 		  void **thrown_ptr_p)
 {
   void *thrown_ptr = *thrown_ptr_p;
@@ -237,7 +244,7 @@ get_adjusted_ptr (const std::type_info *catch_type,
   if (throw_type->__is_pointer_p ())
     thrown_ptr = *(void **) thrown_ptr;
 
-  if (catch_type->__do_catch (throw_type, &thrown_ptr, 1))
+  if (catch_type->__do_catch (throw_type, &thrown_ptr, 1 + is_ref * 2))
     {
       *thrown_ptr_p = thrown_ptr;
       return true;
@@ -267,13 +274,15 @@ check_exception_spec(lsda_header_info* info, _throw_typet* throw_type,
         return false;
 
       // Match a ttype entry.
-      catch_type = get_ttype_entry (info, tmp);
+      bool is_ref;
+      
+      catch_type = get_ttype_entry (info, tmp, is_ref);
 
       // ??? There is currently no way to ask the RTTI code about the
       // relationship between two types without reference to a specific
       // object.  There should be; then we wouldn't need to mess with
       // thrown_ptr here.
-      if (get_adjusted_ptr (catch_type, throw_type, &thrown_ptr))
+      if (get_adjusted_ptr (catch_type, throw_type, is_ref, &thrown_ptr))
 	return true;
     }
 }
@@ -346,6 +355,8 @@ namespace __cxxabiv1
 #define PERSONALITY_FUNCTION	__gxx_personality_v0
 #endif
 
+#pragma GCC visibility push(default)
+
 extern "C" _Unwind_Reason_Code
 #ifdef __ARM_EABI_UNWINDER__
 PERSONALITY_FUNCTION (_Unwind_State state,
@@ -383,6 +394,8 @@ PERSONALITY_FUNCTION (int version,
   switch (state & _US_ACTION_MASK)
     {
     case _US_VIRTUAL_UNWIND_FRAME:
+      if (state & _US_FORCE_UNWIND)
+	CONTINUE_UNWINDING;
       actions = _UA_SEARCH_PHASE;
       break;
 
@@ -582,14 +595,16 @@ PERSONALITY_FUNCTION (int version,
 	  else if (ar_filter > 0)
 	    {
 	      // Positive filter values are handlers.
-	      catch_type = get_ttype_entry (&info, ar_filter);
+	      bool is_ref;
+	      
+	      catch_type = get_ttype_entry (&info, ar_filter, is_ref);
 
 	      // Null catch type is a catch-all handler; we can catch foreign
 	      // exceptions with this.  Otherwise we must match types.
 	      if (! catch_type
 		  || (throw_type
 		      && get_adjusted_ptr (catch_type, throw_type,
-					   &thrown_ptr)))
+					   is_ref, &thrown_ptr)))
 		{
 		  saw_handler = true;
 		  break;
@@ -715,6 +730,8 @@ PERSONALITY_FUNCTION (int version,
   return _URC_INSTALL_CONTEXT;
 }
 
+#pragma GCC visibility pop
+
 /* The ARM EABI implementation of __cxa_call_unexpected is in a
    different file so that the personality routine (PR) can be used
    standalone.  The generic routine shared datastructures with the PR
diff --git a/libstdc++-v3/libsupc++/eh_ptr.cc b/libstdc++-v3/libsupc++/eh_ptr.cc
index a16b61e09..06d3769f1 100644
--- a/libstdc++-v3/libsupc++/eh_ptr.cc
+++ b/libstdc++-v3/libsupc++/eh_ptr.cc
@@ -223,8 +223,8 @@ std::rethrow_exception(std::exception_ptr ep)
   dep->primaryException = obj;
   __sync_add_and_fetch (&eh->referenceCount, 1);
 
-  dep->unexpectedHandler = __unexpected_handler;
-  dep->terminateHandler = __terminate_handler;
+  dep->unexpectedHandler = __get_unexpected_handler ();
+  dep->terminateHandler = __get_terminate_handler ();
   __GXX_INIT_DEPENDENT_EXCEPTION_CLASS(dep->unwindHeader.exception_class);
   dep->unwindHeader.exception_cleanup = __gxx_dependent_exception_cleanup;
 
diff --git a/libstdc++-v3/libsupc++/eh_term_handler.cc b/libstdc++-v3/libsupc++/eh_term_handler.cc
index 52a074596..4bf590a99 100644
--- a/libstdc++-v3/libsupc++/eh_term_handler.cc
+++ b/libstdc++-v3/libsupc++/eh_term_handler.cc
@@ -36,11 +36,21 @@
 # include <cstdlib>
 #endif
 
-/* The current installed user handler.  */
-std::terminate_handler __cxxabiv1::__terminate_handler =
 #if _GLIBCXX_HOSTED
-	__gnu_cxx::__verbose_terminate_handler;
+#define DEFAULT_TERMINATE_HANDLER __gnu_cxx::__verbose_terminate_handler
 #else
-	std::abort;
+#define DEFAULT_TERMINATE_HANDLER std::abort
 #endif
+/* The current installed user handler.  */
+#ifdef __symbian__
+/* SymbianOS does not allow initialized data, so use a constructor function.  */
+std::terminate_handler __cxxabiv1::__terminate_handler;
 
+void __cxxabiv1::__init_terminate_handler(void)
+{
+  __cxxabiv1::__terminate_handler = DEFAULT_TERMINATE_HANDLER;
+}
+#else /* !__symbian__ */
+std::terminate_handler __cxxabiv1::__terminate_handler =
+  DEFAULT_TERMINATE_HANDLER;
+#endif
diff --git a/libstdc++-v3/libsupc++/eh_terminate.cc b/libstdc++-v3/libsupc++/eh_terminate.cc
index d0c846100..fc05cbc42 100644
--- a/libstdc++-v3/libsupc++/eh_terminate.cc
+++ b/libstdc++-v3/libsupc++/eh_terminate.cc
@@ -45,7 +45,7 @@ __cxxabiv1::__terminate (std::terminate_handler handler)
 void
 std::terminate ()
 {
-  __terminate (__terminate_handler);
+  __terminate (__get_terminate_handler ());
 }
 
 void
@@ -58,7 +58,7 @@ __cxxabiv1::__unexpected (std::unexpected_handler handler)
 void
 std::unexpected ()
 {
-  __unexpected (__unexpected_handler);
+  __unexpected (__get_unexpected_handler ());
 }
 
 std::terminate_handler
diff --git a/libstdc++-v3/libsupc++/eh_throw.cc b/libstdc++-v3/libsupc++/eh_throw.cc
index 78cfc1395..45f17d137 100644
--- a/libstdc++-v3/libsupc++/eh_throw.cc
+++ b/libstdc++-v3/libsupc++/eh_throw.cc
@@ -67,8 +67,8 @@ __cxxabiv1::__cxa_throw (void *obj, std::type_info *tinfo,
   header->referenceCount = 1;
   header->exc.exceptionType = tinfo;
   header->exc.exceptionDestructor = dest;
-  header->exc.unexpectedHandler = __unexpected_handler;
-  header->exc.terminateHandler = __terminate_handler;
+  header->exc.unexpectedHandler = __get_unexpected_handler ();
+  header->exc.terminateHandler = __get_terminate_handler ();
   __GXX_INIT_PRIMARY_EXCEPTION_CLASS(header->exc.unwindHeader.exception_class);
   header->exc.unwindHeader.exception_cleanup = __gxx_exception_cleanup;
 
diff --git a/libstdc++-v3/libsupc++/eh_unex_handler.cc b/libstdc++-v3/libsupc++/eh_unex_handler.cc
index e4f390620..d048d12b4 100644
--- a/libstdc++-v3/libsupc++/eh_unex_handler.cc
+++ b/libstdc++-v3/libsupc++/eh_unex_handler.cc
@@ -25,5 +25,14 @@
 #include "unwind-cxx.h"
 
 /* The current installed user handler.  */
-std::unexpected_handler __cxxabiv1::__unexpected_handler = std::terminate;
+#ifdef __symbian__
+/* SymbianOS does not allow initialized data, so use a constructor function.  */
+std::unexpected_handler __cxxabiv1::__unexpected_handler;
 
+void __cxxabiv1::__init_unexpected_handler (void)
+{
+  __cxxabiv1::__unexpected_handler = std::terminate;
+}
+#else /* !__symbian__ */
+std::unexpected_handler __cxxabiv1::__unexpected_handler = std::terminate;
+#endif
diff --git a/libstdc++-v3/libsupc++/unwind-cxx.h b/libstdc++-v3/libsupc++/unwind-cxx.h
index 1420db368..999f34a35 100644
--- a/libstdc++-v3/libsupc++/unwind-cxx.h
+++ b/libstdc++-v3/libsupc++/unwind-cxx.h
@@ -183,12 +183,6 @@ extern "C" void __cxa_bad_typeid ();
 
 // @@@ These are not directly specified by the IA-64 C++ ABI.
 
-// Handles re-checking the exception specification if unexpectedHandler
-// throws, and if bad_exception needs to be thrown.  Called from the
-// compiler.
-extern "C" void __cxa_call_unexpected (void *) __attribute__((noreturn));
-extern "C" void __cxa_call_terminate (void*) __attribute__((noreturn));
-
 #ifdef __ARM_EABI_UNWINDER__
 // Arm EABI specified routines.
 typedef enum {
@@ -196,12 +190,24 @@ typedef enum {
   ctm_succeeded = 1,
   ctm_succeeded_with_ptr_to_base = 2
 } __cxa_type_match_result;
-extern "C" bool __cxa_type_match(_Unwind_Exception*, const std::type_info*,
-				 bool, void**);
-extern "C" void __cxa_begin_cleanup (_Unwind_Exception*);
+extern "C" __cxa_type_match_result
+__cxa_type_match(_Unwind_Exception*, const std::type_info*, bool, void**);
+extern "C" bool __cxa_begin_cleanup (_Unwind_Exception*);
 extern "C" void __cxa_end_cleanup (void);
+#define __gnu_cxa_call_arg _Unwind_Control_Block*
+#else
+#define __gnu_cxa_call_arg void*
 #endif
 
+// Handles re-checking the exception specification if unexpectedHandler
+// throws, and if bad_exception needs to be thrown.  Called from the
+// compiler.
+#define __cxa_call_arg
+extern "C" void
+__cxa_call_unexpected (__gnu_cxa_call_arg) __attribute__((noreturn));
+extern "C" void
+__cxa_call_terminate (__gnu_cxa_call_arg) __attribute__((noreturn));
+
 // Invokes given handler, dying appropriately if the user handler was
 // so inconsiderate as to return.
 extern void __terminate(std::terminate_handler) __attribute__((noreturn));
@@ -211,6 +217,29 @@ extern void __unexpected(std::unexpected_handler) __attribute__((noreturn));
 extern std::terminate_handler __terminate_handler;
 extern std::unexpected_handler __unexpected_handler;
 
+#ifdef __symbian__
+extern "C" void __init_terminate_handler(void);
+extern "C" void __init_unexpected_handler(void);
+#endif
+
+static inline std::terminate_handler __get_terminate_handler(void)
+{
+#ifdef __symbian__
+  if (!__terminate_handler)
+    __init_terminate_handler();
+#endif
+  return __terminate_handler;
+}
+
+static inline std::unexpected_handler __get_unexpected_handler(void)
+{
+#ifdef __symbian__
+  if (!__unexpected_handler)
+    __init_unexpected_handler();
+#endif
+  return __unexpected_handler;
+}
+
 // These are explicitly GNU C++ specific.
 
 // Acquire the C++ exception header from the C++ object.
diff --git a/libstdc++-v3/libsupc++/vmi_class_type_info.cc b/libstdc++-v3/libsupc++/vmi_class_type_info.cc
index 6904f7723..195061d72 100644
--- a/libstdc++-v3/libsupc++/vmi_class_type_info.cc
+++ b/libstdc++-v3/libsupc++/vmi_class_type_info.cc
@@ -108,7 +108,17 @@ __do_dyncast (ptrdiff_t src2dst,
       return false;
     }
 
+  // If src_type is a unique non-virtual base of dst_type, we have a good
+  // guess at the address we want, so in the first pass try skipping any
+  // bases which don't contain that address.
+  const void *dst_cand = NULL;
+  if (src2dst >= 0)
+    dst_cand = adjust_pointer<void>(src_ptr, -src2dst);
+  bool first_pass = true;
+  bool skipped = false;
+
   bool result_ambig = false;
+ again:
   for (std::size_t i = __base_count; i--;)
     {
       __dyncast_result result2 (result.whole_details);
@@ -121,6 +131,20 @@ __do_dyncast (ptrdiff_t src2dst,
         base_access = __sub_kind (base_access | __contained_virtual_mask);
       base = convert_to_base (base, is_virtual, offset);
 
+      if (dst_cand)
+	{
+	  bool skip_on_first_pass = base > dst_cand;
+	  if (skip_on_first_pass == first_pass)
+	    {
+	      // We aren't interested in this base on this pass: either
+	      // we're on the first pass and this base doesn't contain the
+	      // likely address, or we're on the second pass and we checked
+	      // this base on the first pass.
+	      skipped = true;
+	      continue;
+	    }
+	}
+
       if (!__base_info[i].__is_public_p ())
         {
           if (src2dst == -2 &&
@@ -267,6 +291,14 @@ __do_dyncast (ptrdiff_t src2dst,
         return result_ambig;
     }
 
+  if (skipped && first_pass)
+    {
+      // We didn't find dst where we expected it, so let's go back and try
+      // the bases we skipped (if any).
+      first_pass = false;
+      goto again;
+    }
+
   return result_ambig;
 }
 
diff --git a/libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs-2.cc b/libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs-2.cc
index cb40b7bff..6147d66f1 100644
--- a/libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs-2.cc
+++ b/libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs-2.cc
@@ -1,5 +1,5 @@
 // { dg-options "-std=gnu++0x -funsigned-char -fshort-enums" }
-// { dg-options "-std=gnu++0x -funsigned-char -fshort-enums -Wl,--no-enum-size-warning" { target arm*-*-linux*eabi } }
+// { dg-options "-std=gnu++0x -funsigned-char -fshort-enums -Wl,--no-enum-size-warning" { target arm*-*-linux-*eabi* } }
 
 // 2007-05-03  Benjamin Kosnik  <bkoz@redhat.com>
 //
diff --git a/libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs-2.cc b/libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs-2.cc
index d71c01282..1086a1809 100644
--- a/libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs-2.cc
+++ b/libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs-2.cc
@@ -1,5 +1,5 @@
 // { dg-options "-std=gnu++0x -funsigned-char -fshort-enums" }
-// { dg-options "-std=gnu++0x -funsigned-char -fshort-enums -Wl,--no-enum-size-warning" { target arm*-*-linux*eabi } }
+// { dg-options "-std=gnu++0x -funsigned-char -fshort-enums -Wl,--no-enum-size-warning" { target arm*-*-linux-*eabi* } }
 
 // 2007-05-03  Benjamin Kosnik  <bkoz@redhat.com>
 //
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stod.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stod.cc
index c5c7bdd44..e18e7434d 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stod.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stod.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stof.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stof.cc
index ffc0867b5..338aa5062 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stof.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stof.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoi.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoi.cc
index b37cc757b..6ab66e47c 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoi.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoi.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stol.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stol.cc
index 3cd3df677..eb74d1227 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stol.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stol.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stold.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stold.cc
index 4757f0c08..f99659341 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stold.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stold.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoll.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoll.cc
index 55f484a57..e954b13df 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoll.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoll.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoul.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoul.cc
index 5498a9620..b1edae4d1 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoul.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoul.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoull.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoull.cc
index f2d8fb172..c65683071 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoull.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/stoull.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/to_wstring.cc b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/to_wstring.cc
index dd46736ea..31af58f05 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/to_wstring.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/numeric_conversions/wchar_t/to_wstring.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 // 2008-06-15  Paolo Carlini  <paolo.carlini@oracle.com>
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/21_strings/headers/cwchar/functions_std.cc b/libstdc++-v3/testsuite/21_strings/headers/cwchar/functions_std.cc
index d309d437c..e1de06d99 100644
--- a/libstdc++-v3/testsuite/21_strings/headers/cwchar/functions_std.cc
+++ b/libstdc++-v3/testsuite/21_strings/headers/cwchar/functions_std.cc
@@ -1,5 +1,6 @@
 // { dg-do compile }
 // { dg-require-c-std "" }
+// { dg-require-swprintf "" }
 
 // Copyright (C) 2007, 2009 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/1-io.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/1-io.cc
index e08a48a6b..bb1751505 100644
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/1-io.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/1-io.cc
@@ -20,6 +20,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/2-io.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/2-io.cc
index 5d30517cb..67a376e67 100644
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/2-io.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/seekoff/char/2-io.cc
@@ -20,6 +20,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-in.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-in.cc
index 23f438fc1..47c0597cb 100644
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-in.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-in.cc
@@ -24,6 +24,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-io.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-io.cc
index 26b8bd21e..ffcdc2c14 100644
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-io.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/1-io.cc
@@ -24,6 +24,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-in.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-in.cc
index 7831128ec..dda7c67e3 100644
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-in.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-in.cc
@@ -24,6 +24,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-io.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-io.cc
index 2f7657f82..d401f8732 100644
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-io.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/sgetn/char/2-io.cc
@@ -24,6 +24,7 @@
 // 27.8.1.4 Overridden virtual functions
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <fstream>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc b/libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc
index 8bf915deb..116c404a5 100644
--- a/libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/11603.cc
@@ -17,6 +17,8 @@
 
 // 27.8.1.4 Overridden virtual functions
 
+// { dg-require-binary-io "" }
+
 #include <fstream>
 #include <locale>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/readsome/char/6746-2.cc b/libstdc++-v3/testsuite/27_io/basic_istream/readsome/char/6746-2.cc
index 9a6875ba3..ed74751dc 100644
--- a/libstdc++-v3/testsuite/27_io/basic_istream/readsome/char/6746-2.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/readsome/char/6746-2.cc
@@ -26,6 +26,7 @@
 // @diff@ %-*.tst %-*.txt
 
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <istream>
 #include <fstream>
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/readsome/wchar_t/6746-2.cc b/libstdc++-v3/testsuite/27_io/basic_istream/readsome/wchar_t/6746-2.cc
index 6338be674..c77031322 100644
--- a/libstdc++-v3/testsuite/27_io/basic_istream/readsome/wchar_t/6746-2.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/readsome/wchar_t/6746-2.cc
@@ -19,6 +19,8 @@
 // causes "in_avail" to return an incorrect value.
 // { dg-do run { xfail arm*-*-elf arm*-*-eabi } }
 
+// { dg-require-binary-io "" }
+
 // 27.6.1.3 unformatted input functions
 // @require@ %-*.tst %-*.txt
 // @diff@ %-*.tst %-*.txt
diff --git a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc
index bf891fab1..54b339e99 100644
--- a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc
@@ -1,3 +1,5 @@
+// { dg-require-swprintf "" }
+
 // Copyright (C) 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
diff --git a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc
index 6d7e9d1a6..5df2990fc 100644
--- a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/error_code.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-swprintf "" }
 
 // Copyright (C) 2007, 2008, 2009 Free Software Foundation
 //
diff --git a/libstdc++-v3/testsuite/27_io/objects/char/10.cc b/libstdc++-v3/testsuite/27_io/objects/char/10.cc
index cfa21c817..a744e787a 100644
--- a/libstdc++-v3/testsuite/27_io/objects/char/10.cc
+++ b/libstdc++-v3/testsuite/27_io/objects/char/10.cc
@@ -18,6 +18,7 @@
 // <http://www.gnu.org/licenses/>.
  
 // { dg-require-fileio "" }
+// { dg-require-binary-io "" }
 
 #include <iostream>
 #include <cstdio>
diff --git a/libstdc++-v3/testsuite/Makefile.in b/libstdc++-v3/testsuite/Makefile.in
index 31bd0add1..c0dfc5cba 100644
--- a/libstdc++-v3/testsuite/Makefile.in
+++ b/libstdc++-v3/testsuite/Makefile.in
@@ -556,6 +556,7 @@ $(check_DEJAGNU_normal_targets): check-DEJAGNUnormal%: normal%/site.exp
 
 # Run the testsuite in normal mode.
 check-DEJAGNU $(check_DEJAGNU_normal_targets): check-DEJAGNU%: site.exp
+	case "${target}" in arm*-*-linux-gnueabi) exit 0;; esac; \
 	AR=$(AR); export AR; \
 	RANLIB=$(RANLIB); export RANLIB; \
 	if [ -z "$*$(filter-out --target_board=%, $(RUNTESTFLAGS))" ] \
diff --git a/libstdc++-v3/testsuite/ext/vstring/element_access/char/front_back.cc b/libstdc++-v3/testsuite/ext/vstring/element_access/char/front_back.cc
index 7b089d380..a1d4c5f02 100644
--- a/libstdc++-v3/testsuite/ext/vstring/element_access/char/front_back.cc
+++ b/libstdc++-v3/testsuite/ext/vstring/element_access/char/front_back.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 
 // 2007-10-16  Paolo Carlini  <pcarlini@suse.de>
 
diff --git a/libstdc++-v3/testsuite/ext/vstring/element_access/wchar_t/front_back.cc b/libstdc++-v3/testsuite/ext/vstring/element_access/wchar_t/front_back.cc
index 60252241b..6e45bc55e 100644
--- a/libstdc++-v3/testsuite/ext/vstring/element_access/wchar_t/front_back.cc
+++ b/libstdc++-v3/testsuite/ext/vstring/element_access/wchar_t/front_back.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 
 // 2007-10-16  Paolo Carlini  <pcarlini@suse.de>
 
diff --git a/libstdc++-v3/testsuite/ext/vstring/init-list.cc b/libstdc++-v3/testsuite/ext/vstring/init-list.cc
index 7d2babc57..1d9279f0f 100644
--- a/libstdc++-v3/testsuite/ext/vstring/init-list.cc
+++ b/libstdc++-v3/testsuite/ext/vstring/init-list.cc
@@ -17,6 +17,7 @@
 //
 
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 
 #include <ext/vstring.h>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/ext/vstring/moveable.cc b/libstdc++-v3/testsuite/ext/vstring/moveable.cc
index 41b409c53..824863685 100644
--- a/libstdc++-v3/testsuite/ext/vstring/moveable.cc
+++ b/libstdc++-v3/testsuite/ext/vstring/moveable.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 
 // Copyright (C) 2007, 2009 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/ext/vstring/requirements/citerators.cc b/libstdc++-v3/testsuite/ext/vstring/requirements/citerators.cc
index 10807b5c4..125cefd71 100644
--- a/libstdc++-v3/testsuite/ext/vstring/requirements/citerators.cc
+++ b/libstdc++-v3/testsuite/ext/vstring/requirements/citerators.cc
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-require-string-conversions "" }
 
 // 2007-10-15  Paolo Carlini  <pcarlini@suse.de>
 
diff --git a/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char16_t/1.cc b/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char16_t/1.cc
index 347db028d..f6f7d4141 100644
--- a/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char16_t/1.cc
+++ b/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char16_t/1.cc
@@ -1,6 +1,7 @@
 // { dg-do compile }
 // { dg-options "-std=gnu++0x" }
 // { dg-require-cstdint "" }
+// { dg-require-string-conversions "" }
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char32_t/1.cc b/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char32_t/1.cc
index 5d01845f4..0020792cc 100644
--- a/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char32_t/1.cc
+++ b/libstdc++-v3/testsuite/ext/vstring/requirements/explicit_instantiation/char32_t/1.cc
@@ -1,6 +1,7 @@
 // { dg-do compile }
 // { dg-options "-std=gnu++0x" }
 // { dg-require-cstdint "" }
+// { dg-require-string-conversions "" }
 
 // Copyright (C) 2008, 2009 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/lib/dg-options.exp b/libstdc++-v3/testsuite/lib/dg-options.exp
index 8b2824746..5826705fe 100644
--- a/libstdc++-v3/testsuite/lib/dg-options.exp
+++ b/libstdc++-v3/testsuite/lib/dg-options.exp
@@ -143,6 +143,24 @@ proc dg-require-string-conversions { args } {
     return
 }
 
+proc dg-require-swprintf { args } {
+    if { ![ check_v3_target_swprintf ] } {
+        upvar dg-do-what dg-do-what
+        set dg-do-what [list [lindex ${dg-do-what} 0] "N" "P"]
+        return
+    }
+    return
+}
+
+proc dg-require-binary-io { args } {
+    if { ![ check_v3_target_binary_io ] } {
+        upvar dg-do-what dg-do-what
+        set dg-do-what [list [lindex ${dg-do-what} 0] "N" "P"]
+        return
+    }
+    return
+}
+
 proc add_options_for_no_pch { flags } {
     # This forces any generated and possibly included PCH to be invalid.
     return "-D__GLIBCXX__=99999999"
diff --git a/libstdc++-v3/testsuite/lib/libstdc++.exp b/libstdc++-v3/testsuite/lib/libstdc++.exp
index 2344885bf..be54e7c0c 100644
--- a/libstdc++-v3/testsuite/lib/libstdc++.exp
+++ b/libstdc++-v3/testsuite/lib/libstdc++.exp
@@ -204,14 +204,23 @@ proc libstdc++_init { testfile } {
 	# directory, and then add that to the search path.
 	foreach src [glob "${srcdir}/util/*.h" \
 		          "${srcdir}/util/*.cc" \
- 		          "${srcdir}/util/*/*.hpp" \
+		          "${srcdir}/util/*.tcc" \
+		          "${srcdir}/util/*.hpp" \
+ 		          "${srcdir}/util/*/*.h" \
 		          "${srcdir}/util/*/*.cc" \
+		          "${srcdir}/util/*/*.tcc" \
 			  "${srcdir}/util/*/*.hpp" \
+		          "${srcdir}/util/*/*/*.h" \
 		          "${srcdir}/util/*/*/*.cc" \
+		          "${srcdir}/util/*/*/*.tcc" \
 			  "${srcdir}/util/*/*/*.hpp" \
+		          "${srcdir}/util/*/*/*/*.h" \
 		          "${srcdir}/util/*/*/*/*.cc" \
+		          "${srcdir}/util/*/*/*/*.tcc" \
   			  "${srcdir}/util/*/*/*/*.hpp" \
+		          "${srcdir}/util/*/*/*/*/*.h" \
 		          "${srcdir}/util/*/*/*/*/*.cc" \
+		          "${srcdir}/util/*/*/*/*/*.tcc" \
   			  "${srcdir}/util/*/*/*/*/*.hpp" ] {
 	    # Remove everything up to "util/..."
 	    set dst [string range $src [string length "${srcdir}/"] end]
@@ -237,6 +246,10 @@ proc libstdc++_init { testfile } {
     }
     append cxxflags " "
     append cxxflags [getenv CXXFLAGS]
+    # ARM C++ emits an ABI warning for varargs.
+    if [istarget "arm*"] {
+        append cxxflags " -Wno-abi"
+    }
     v3track cxxflags 2
 
     # Always use MO files built by this test harness.
@@ -1383,3 +1396,119 @@ proc check_v3_target_string_conversions { } {
     verbose "check_v3_target_string_conversions: $et_string_conversions" 2
     return $et_string_conversions
 }
+
+proc check_v3_target_swprintf { } {
+    global cxxflags
+    global DEFAULT_CXXFLAGS
+    global et_swprintf
+
+    global tool
+
+    if { ![info exists et_swprintf_target_name] } {
+        set et_swprintf_target_name ""
+    }
+
+    # If the target has changed since we set the cached value, clear it.
+    set current_target [current_target_name]
+    if { $current_target != $et_swprintf_target_name } {
+        verbose "check_v3_target_swprintf: `$et_swprintf_target_name'" 2
+        set et_swprintf_target_name $current_target
+        if [info exists et_swprintf] {
+            verbose "check_v3_target_swprintf: removing cached result" 2
+            unset et_swprintf
+        }
+    }
+
+    if [info exists et_swprintf] {
+        verbose "check_v3_target_swprintf: using cached result" 2
+    } else {
+        set et_swprintf 0
+	
+	# Set up and compile a C++0x test program that depends
+        # on a standard swprintf function to be available.
+        set src swprintf[pid].cc
+        set exe swprintf[pid].exe
+
+        set f [open $src "w"]
+        puts $f "#include <bits/c++config.h>"
+        puts $f "int main()"
+        puts $f "#if !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF)"
+        puts $f "{ return 0; }"
+        puts $f "#endif"
+        close $f
+
+        set cxxflags_saved $cxxflags
+        set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"
+
+        set lines [v3_target_compile $src $exe executable ""]
+        set cxxflags $cxxflags_saved
+        file delete $src
+
+        if [string match "" $lines] {
+            # No error message, compilation succeeded.
+            set et_swprintf 1
+        } else {
+            verbose "check_v3_target_swprintf: compilation failed" 2
+        }
+    }
+    verbose "check_v3_target_swprintf: $et_swprintf" 2
+    return $et_swprintf
+}
+
+proc check_v3_target_binary_io { } {
+    global cxxflags
+    global DEFAULT_CXXFLAGS
+    global et_binary_io
+
+    global tool
+
+    if { ![info exists et_binary_io_target_name] } {
+        set et_binary_io_target_name ""
+    }
+
+    # If the target has changed since we set the cached value, clear it.
+    set current_target [current_target_name]
+    if { $current_target != $et_binary_io_target_name } {
+        verbose "check_v3_target_binary_io: `$et_binary_io_target_name'" 2
+        set et_binary_io_target_name $current_target
+        if [info exists et_binary_io] {
+            verbose "check_v3_target_binary_io: removing cached result" 2
+            unset et_binary_io
+        }
+    }
+
+    if [info exists et_binary_io] {
+        verbose "check_v3_target_binary_io: using cached result" 2
+    } else {
+        set et_binary_io 0
+	
+	# Set up and compile a C++0x test program that depends
+        # on text and binary I/O being the same.
+        set src binary_io[pid].cc
+        set exe binary_io[pid].exe
+
+        set f [open $src "w"]
+        puts $f "#include <bits/c++config.h>"
+        puts $f "int main()"
+        puts $f "#if !defined(_GLIBCXX_HAVE_DOS_BASED_FILESYSTEM)"
+        puts $f "{ return 0; }"
+        puts $f "#endif"
+        close $f
+
+        set cxxflags_saved $cxxflags
+        set cxxflags "$cxxflags $DEFAULT_CXXFLAGS -Werror"
+
+        set lines [v3_target_compile $src $exe executable ""]
+        set cxxflags $cxxflags_saved
+        file delete $src
+
+        if [string match "" $lines] {
+            # No error message, compilation succeeded.
+            set et_binary_io 1
+        } else {
+            verbose "check_v3_target_binary_io: compilation failed" 2
+        }
+    }
+    verbose "check_v3_target_binary_io: $et_binary_io" 2
+    return $et_binary_io
+}
diff --git a/libstdc++-v3/testsuite/lib/prune.exp b/libstdc++-v3/testsuite/lib/prune.exp
index 6c7368d10..c68721870 100644
--- a/libstdc++-v3/testsuite/lib/prune.exp
+++ b/libstdc++-v3/testsuite/lib/prune.exp
@@ -30,5 +30,23 @@ proc prune_g++_output { text } {
     regsub -all "(^|\n)\[^\n\]*: Additional NOP may be necessary to workaround Itanium processor A/B step errata" $text "" text
     regsub -all "(^|\n)\[^\n*\]*: Assembler messages:\[^\n\]*" $text "" text
 
+    if { [ishost "sparc*-*-solaris2*"] } {
+	# When testing a compiler built for SPARC Solaris 2.9 (or earlier)
+	# on a host running Solaris 2.10 (or later), we get this warning 
+	# from the static linker when building with g++:
+	#
+	#   libm.so.1, needed by .../libstdc++.so may conflict with
+	#   libm.so
+	#
+	# The warning is issued because libstdc++ is linked against
+	# libm.so.1 (from the Solaris 2.9 sysroot), whereas Solaris 2.10
+	# provides both libm.so.2 and libm.so.1.  On Solaris 2.10, libc.so
+	# depends on libm.so.2, so all programs pull in libm.so.2.
+	#
+	# Pulling both libraries must in fact be harmless, as, otherwise,
+	# programs built for Solaris 2.9 would break on Solaris 2.10.
+	regsub -all "(^|\n)\[^\n\]*: warning: libm.so.1, needed by \[^\n\]*, may conflict with libm.so.2" $text "" text
+    }
+
     return $text
 }
diff --git a/libtool.m4 b/libtool.m4
index c17514b92..858aaf2c5 100644
--- a/libtool.m4
+++ b/libtool.m4
@@ -2515,6 +2515,21 @@ newsos6)
   shlibpath_overrides_runpath=yes
   ;;
 
+nucleus*)
+  case $host_vendor in
+    samsung)
+      version_type=linux
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+      soname_spec='$libname${shared_ext}$major'
+      shlibpath_var=LD_LIBRARY_PATH
+      hardcode_into_libs=yes
+      ;;
+    *)
+      dynamic_linker=no
+      ;;
+  esac
+  ;;
+
 *nto* | *qnx*)
   version_type=qnx
   need_lib_prefix=no
@@ -3019,6 +3034,10 @@ cegcc)
   lt_cv_file_magic_cmd='$OBJDUMP -f'
   ;;
 
+nucleuseabi*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 darwin* | rhapsody*)
   lt_cv_deplibs_check_method=pass_all
   ;;
