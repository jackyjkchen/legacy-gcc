diff --git a/Makefile.in b/Makefile.in
index 73a7734..888819c 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -50,7 +50,7 @@ T_CFLAGS =
 X_CPPFLAGS =
 T_CPPFLAGS =
 
-CC = cc
+CC = @CC@
 BISON = bison
 BISONFLAGS =
 AR = ar
@@ -78,7 +78,7 @@ RANLIB_TEST = [ -f /usr/bin/ranlib -o -f /bin/ranlib ]
 # OLDCC should not be the GNU C compiler,
 # since that would compile typical libgcc1.a functions such as mulsi3
 # into infinite recursions.
-OLDCC = cc
+OLDCC = ${CC}
 
 # CFLAGS for use with OLDCC, for compiling libgcc1.a.
 # NOTE: -O does not work on some Unix systems!
@@ -114,19 +114,26 @@ CROSS_TOOLS =
 target= ... `configure' substitutes actual target name here.
 xmake_file= ... `configure' substitutes actual x- file name here.
 tmake_file= ... `configure' substitutes actual t- file name here.
-version=`awk '{printf "%s", substr ($$4, 2, length ($$4) - 3); }' $(srcdir)/version.c`
+version=2.0
 
 # Directory where sources are, from where we are.
 srcdir = .
 # Common prefix for installation directories.
 # NOTE: This directory must exist when you start installation.
 prefix = /usr/local
+# Directory in which to put localized header files. On the systems with
+# gcc as the native cc, `local_prefix' may not be `prefix' which is
+# `/usr'.
+# NOTE: local_prefix *should not* default from prefix.
+local_prefix = /usr/local
+# Directory in which to put host dependent programs and libraries
+exec_prefix = $(prefix)
 # Directory in which to put the executable for the command `gcc'
 bindir = $(prefix)/bin
 # Directory in which to put the directories used by the compiler.
-libdir = $(prefix)/lib
+libdir = $(exec_prefix)/lib
 # Directory in which the compiler finds executables, libraries, etc.
-libsubdir = $(libdir)/gcc/$(target)/$(version)
+libsubdir = $(libdir)/gcc-lib/$(target)/$(version)
 # Extension (if any) to put in installed man-page filename.
 manext = .1
 # Directory in which to put man pages.
@@ -444,7 +451,7 @@ enquire: enquire.o $(GCC_PARTS)
 enquire.o: $(srcdir)/enquire.c $(GCC_PASSES)
 	-cp $(srcdir)/enquire.c . > /dev/null 2>&1
 # Breaking this line caused a problem with one version of GNU make.
-	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) $(ENQUIRE_CFLAGS) -I. -c enquire.c
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) $(ENQUIRE_CFLAGS) -I. -I$(srcdir) -c enquire.c
 
 # Build libgcc.a.
 # This is done in two parts because some functions, in libgcc1.c,
@@ -589,13 +596,20 @@ libgcc.a: $(LIBGCC1) $(LIBGCC2)
 # linked using GCC on system V, for the sake of C++ constructors.
 crtbegin.o:	crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h
 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) -DCRT_BEGIN \
-	  -finhibit-size-directive -g0 -c $(srcdir)/crtstuff.c
-	mv crtstuff.o crtbegin.o
+	  -finhibit-size-directive -g0 -c $(srcdir)/crtstuff.c -o crtbegin.o
 
 crtend.o:	crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h
 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) -DCRT_END \
-	  -finhibit-size-directive -g0 -c $(srcdir)/crtstuff.c
-	mv crtstuff.o crtend.o
+	  -finhibit-size-directive -g0 -c $(srcdir)/crtstuff.c -o crtend.o
+
+crtbeginS.o:	crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) -DCRT_BEGIN -fPIC \
+	-DCRTSTUFFS_O -finhibit-size-directive -g0 -c $(srcdir)/crtstuff.c -o crtbeginS.o
+
+crtendS.o:	crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) -DCRT_END -fPIC \
+	-DCRTSTUFFS_O  -finhibit-size-directive -g0 -c $(srcdir)/crtstuff.c -o crtendS.o
+
 
 # Compiling object files from source files.
 
@@ -683,8 +697,10 @@ c-common.o : c-common.c $(CONFIG_H) $(TREE_H) c-tree.h c-lex.h flags.h
 gcc.o: gcc.c $(CONFIG_H) gvarargs.h obstack.h
 	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
   -DSTANDARD_STARTFILE_PREFIX=\"$(libdir)/\" \
-  -DSTANDARD_EXEC_PREFIX=\"$(libdir)/gcc/\" \
+  -DSTANDARD_EXEC_PREFIX=\"$(libdir)/gcc-lib/\" \
   -DDEFAULT_TARGET_MACHINE=\"$(target)\" \
+  -DTOOLDIR_BASE_PREFIX=\"$(exec_prefix)/\" \
+  -DTOOLDIR=\"$(tooldir)/\" \
   -c `echo $(srcdir)/gcc.c | sed 's,^\./,,'`
 
 dumpvers: dumpvers.c
@@ -697,6 +713,9 @@ print-tree.o : print-tree.c $(CONFIG_H) $(TREE_H)
 stor-layout.o : stor-layout.c $(CONFIG_H) $(TREE_H) function.h
 fold-const.o : fold-const.c $(CONFIG_H) $(TREE_H) flags.h 
 toplev.o : toplev.c $(CONFIG_H) $(TREE_H) $(RTL_H) flags.h input.h insn-attr.h
+	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	$(MAYBE_TARGET_DEFAULT) \
+	-c `echo $(srcdir)/toplev.c | sed 's,^\./,,'`
 
 rtl.o : rtl.c $(CONFIG_H) $(RTL_H)
 
@@ -760,7 +779,7 @@ reload1.o : reload1.c $(CONFIG_H) $(RTL_H) flags.h expr.h \
    reload.h regs.h hard-reg-set.h insn-config.h insn-flags.h insn-codes.h \
    basic-block.h recog.h output.h
 caller-save.o : caller-save.c $(CONFIG_H) $(RTL_H) flags.h \
-   regs.h hard-reg-set.h insn-config.h basic-block.h recog.h reload.h expr.h
+   regs.h hard-reg-set.h insn-codes.h insn-config.h basic-block.h recog.h reload.h expr.h
 reorg.o : reorg.c $(CONFIG_H) $(RTL_H) conditions.h hard-reg-set.h \
    basic-block.h regs.h insn-config.h insn-attr.h insn-flags.h recog.h \
    flags.h output.h
@@ -1021,8 +1040,10 @@ cccp.o: cccp.c $(CONFIG_H) pcp.h version.c
 	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
           -DGCC_INCLUDE_DIR=\"$(libsubdir)/include\" \
           -DGPLUSPLUS_INCLUDE_DIR=\"$(libdir)/g++-include\" \
-	  -DLOCAL_INCLUDE_DIR=\"$(prefix)/include\" \
+	  -DLOCAL_INCLUDE_DIR=\"$(local_prefix)/include\" \
           -DCROSS_INCLUDE_DIR=\"$(libsubdir)/sys-include\" \
+          -DTOOL_INCLUDE_DIR=\"$(tooldir)/include\" \
+          -DTOOLDIR=\"$(tooldir)/\" \
 	  -c `echo $(srcdir)/cccp.c | sed 's,^\./,,'`
 
 proto: config.status protoize unprotoize SYSCALLS.c.X protoize.1 unprotoize.1
@@ -1035,7 +1056,8 @@ protoize.o:	$(srcdir)/protoize.c getopt.h $(CONFIG_H)
           -DGCC_INCLUDE_DIR=\"$(libsubdir)/include\" \
           -DGPLUSPLUS_INCLUDE_DIR=\"$(libdir)/g++-include\" \
           -DCROSS_INCLUDE_DIR=\"$(libsubdir)/sys-include\" \
-	  -DLOCAL_INCLUDE_DIR=\"$(prefix)/include\" \
+          -DTOOL_INCLUDE_DIR=\"$(tooldir)/include\" \
+	  -DLOCAL_INCLUDE_DIR=\"$(local_prefix)/include\" \
 	  -DSTD_PROTO_DIR=\"$(libsubdir)\" \
 	  $(srcdir)/protoize.c
 
@@ -1048,7 +1070,8 @@ unprotoize.o:	$(srcdir)/protoize.c getopt.h $(CONFIG_H)
           -DGCC_INCLUDE_DIR=\"$(libsubdir)/include\" \
           -DGPLUSPLUS_INCLUDE_DIR=\"$(libdir)/g++-include\" \
           -DCROSS_INCLUDE_DIR=\"$(libsubdir)/sys-include\" \
-	  -DLOCAL_INCLUDE_DIR=\"$(prefix)/include\" \
+	  -DTOOL_INCLUDE_DIR=\"$(tooldir)/include\" \
+	  -DLOCAL_INCLUDE_DIR=\"$(local_prefix)/include\" \
 	  -DSTD_PROTO_DIR=\"$(libsubdir)\" \
 	  -DUNPROTOIZE unprotoize.c
 	rm -f unprotoize.c
@@ -1154,7 +1177,7 @@ install: $(INSTALL_TARGET)
 
 # Copy the files of native compiler into directories where they will be run.
 install-native: install-common install-libgcc $(INSTALL_HEADERS) \
-   install-man install-proto
+   install-man
 
 # Copy the files of cross compiler into directories where they will be run.
 install-cross: install-common install-common-headers \
@@ -1172,32 +1195,32 @@ install-cross-tools: install-dir
 # leading us to overwrite the real file through the symlink.
 	-if [ -f gcc-cross ] ; \
 	then \
-	  if [ -d $(tooldir)/. ] ; \
+	  if [ -d $(DESTDIR)$(tooldir)/. ] ; \
 	  then \
 	    for file in as ld ar ranlib; do \
-	      if [ -f $(libsubdir)/$$file ] ; \
+	      if [ -f $(DESTDIR)$(libsubdir)/$$file ] ; \
 	      then true; \
 	      else  \
-		$(SYMLINK) $(tooldir)/bin/$$file $(libsubdir)/$$file \
-		|| (echo "#!/bin/sh"; echo $(tooldir)/bin/$$file "$$@") > $(libsubdir)/$$file; \
+		$(SYMLINK) $(DESTDIR)$(tooldir)/bin/$$file $(DESTDIR)$(libsubdir)/$$file \
+		|| (echo "#!/bin/sh"; echo $(DESTDIR)$(tooldir)/bin/$$file "$$@") > $(DESTDIR)$(libsubdir)/$$file; \
 	      fi; \
 	    done; \
-	    for file in $(tooldir)/lib/*; do \
+	    for file in $(DESTDIR)$(tooldir)/lib/*; do \
 	      if [ -f $$file ] ; \
 	      then \
-		if [ -f $(libsubdir)/`basename $$file` ] ; \
+		if [ -f $(DESTDIR)$(libsubdir)/`basename $$file` ] ; \
 		then true; \
 		else  \
-		  $(SYMLINK) $$file $(libsubdir)/`basename $$file` \
-		  || $(INSTALL_DATA) $$file $(libsubdir)/`basename $$file`; \
+		  $(SYMLINK) $$file $(DESTDIR)$(libsubdir)/`basename $$file` \
+		  || $(INSTALL_DATA) $$file $(DESTDIR)$(libsubdir)/`basename $$file`; \
 		fi; \
 	      else true; \
 	      fi; \
 	    done; \
-	    if [ -d $(tooldir)/include/. ] ; then \
-	      $(SYMLINK) $(tooldir)/include $(libsubdir)/sys-include \
-	      || (if [ -d $(libsubdir)/sys-include ] ; then true ; else mkdir $(libsubdir)/sys-include ; fi; \
-		  cd $(tooldir)/include; tar cf - . | (cd $(libsubdir)/sys-include; tar xpf -)); \
+	    if [ -d $(DESTDIR)$(tooldir)/include/. ] ; then \
+	      $(SYMLINK) $(DESTDIR)$(tooldir)/include $(libsubdir)/sys-include \
+	      || (if [ -d $(DESTDIR)$(libsubdir)/sys-include ] ; then true ; else mkdir $(DESTDIR)$(libsubdir)/sys-include ; fi; \
+		  cd $(DESTDIR)$(tooldir)/include; tar cf - . | (cd $(DESTDIR)$(libsubdir)/sys-include; tar xpf -)); \
 	    else true; fi; \
 	  else true; \
 	  fi; \
@@ -1213,91 +1236,97 @@ install-cross-rest: install-float-h-cross
 install-float-h-cross:
 	if [ -f enquire ] ; then true; else false; done
 	-./enquire -f > float.h
-	-rm -f $(libsubdir)/include/float.h
-	$(INSTALL_DATA) float.h $(libsubdir)/include/float.h
-	chmod a-x $(libsubdir)/include/float.h
+	-rm -f $(DESTDIR)$(libsubdir)/include/float.h
+	$(INSTALL_DATA) float.h $(DESTDIR)$(libsubdir)/include/float.h
+	chmod a-x $(DESTDIR)$(libsubdir)/include/float.h
 
 # Create the installation directory.
 install-dir:
-	if [ -d $(libdir) ] ; then true ; else mkdir $(libdir) ; fi
-	if [ -d $(libdir)/gcc ] ; then true ; else mkdir $(libdir)/gcc ; fi
-	if [ -d $(libdir)/gcc/$(target) ] ; then true ; else mkdir $(libdir)/gcc/$(target) ; fi
-	if [ -d $(libdir)/gcc/$(target)/$(version) ] ; then true ; else mkdir $(libdir)/gcc/$(target)/$(version) ; fi
-	if [ -d $(bindir) ] ; then true ; else mkdir $(bindir) ; fi
+	if [ -d $(DESTDIR)$(libdir) ] ; then true ; else mkdir -p $(DESTDIR)$(libdir) ; fi
+	if [ -d $(DESTDIR)$(libdir)/gcc-lib ] ; then true ; else mkdir -p $(DESTDIR)$(libdir)/gcc-lib ; fi
+	if [ -d $(DESTDIR)$(libdir)/gcc-lib/$(target) ] ; then true ; else mkdir -p $(DESTDIR)$(libdir)/gcc-lib/$(target) ; fi
+	if [ -d $(DESTDIR)$(libdir)/gcc-lib/$(target)/$(version) ] ; then true ; else mkdir -p $(DESTDIR)$(libdir)/gcc-lib/$(target)/$(version) ; fi
+	if [ -d $(DESTDIR)$(bindir) ] ; then true ; else mkdir -p $(DESTDIR)$(bindir) ; fi
 # We don't use mkdir -p to create the parents of mandir,
 # because some systems don't support it.
 # Instead, we use this technique to create the immediate parent of mandir.
-	parent=`echo $(mandir)|sed -e 's@/[^/]*$$@@'`; \
-	if [ -d $$parent ] ; then true ; else mkdir $$parent ; fi
-	-if [ -d $(mandir) ] ; then true ; else mkdir $(mandir) ; fi
+	parent=`echo $(DESTDIR)$(mandir)|sed -e 's@/[^/]*$$@@'`; \
+	if [ -d $$parent ] ; then true ; else mkdir -p $$parent ; fi
+	-if [ -d $(DESTDIR)$(mandir) ] ; then true ; else mkdir -p $(DESTDIR)$(mandir) ; fi
 
 # Install the compiler executables built during cross compilation.
 install-common: native install-dir
 	for file in $(COMPILERS); do \
 	  if [ -f $$file ] ; then \
-	    rm -f $(libsubdir)/$$file; \
-	    $(INSTALL_PROGRAM) $$file $(libsubdir)/$$file; \
+	    rm -f $(DESTDIR)$(libsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libsubdir)/$$file; \
 	  else true; \
 	  fi; \
 	done
 	for file in $(EXTRA_PASSES) $(EXTRA_PARTS) ..; do \
 	  if [ x"$$file" != x.. ]; then \
-	    rm -f $(libsubdir)/$$file; \
-	    $(INSTALL_PROGRAM) $$file $(libsubdir)/$$file; \
+	    rm -f $(DESTDIR)$(libsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libsubdir)/$$file; \
 	  else true; fi; \
 	done
-	-rm -f $(libsubdir)/specs
-	$(INSTALL_DATA) specs $(libsubdir)/specs
+	-rm -f $(DESTDIR)$(libsubdir)/specs
+	$(INSTALL_DATA) specs $(DESTDIR)$(libsubdir)/specs
 # Install the driver program as gcc-$(target)
 # and also as either gcc (if native) or $(tooldir)/bin/gcc.
 	-if [ -f gcc-cross ] ; then \
-	  if [ -d $(tooldir)/bin/. ] ; then \
-	    rm -f $(tooldir)/bin/gcc; \
-	    $(INSTALL_PROGRAM) gcc-cross $(tooldir)/bin/gcc; \
-	    $(INSTALL_PROGRAM) gcc-cross $(bindir)/gcc-$(target); \
+	  if [ -d $(DESTDIR)$(tooldir)/bin/. ] ; then \
+	    rm -f $(DESTDIR)$(tooldir)/bin/gcc; \
+	    $(INSTALL_PROGRAM) gcc-cross $(DESTDIR)$(tooldir)/bin/gcc; \
+	    $(INSTALL_PROGRAM) gcc-cross $(DESTDIR)$(bindir)/gcc-$(target); \
 	  else true; fi; \
 	else \
-	  rm -f $(bindir)/gcc; \
-	  $(INSTALL_PROGRAM) gcc $(bindir)/gcc; \
-	  rm -f $(bindir)/gcc-$(target)-1; \
-	  ln $(bindir)/gcc $(bindir)/gcc-$(target)-1; \
-	  mv $(bindir)/gcc-$(target)-1 $(bindir)/gcc-$(target); \
+	  rm -f $(DESTDIR)$(bindir)/gcc; \
+	  $(INSTALL_PROGRAM) gcc $(DESTDIR)$(bindir)/gcc; \
+	  rm -f $(DESTDIR)$(bindir)/$(target)-gcc-1; \
+	  ln $(DESTDIR)$(bindir)/gcc $(DESTDIR)$(bindir)/$(target)-gcc-1; \
+	  mv $(DESTDIR)$(bindir)/$(target)-gcc-1 $(DESTDIR)$(bindir)/$(target)-gcc; \
+	fi
+	-if [ -f cc1plus ] ; then \
+	  $(INSTALL_PROGRAM) $(srcdir)/c++ $(DESTDIR)$(bindir)/c++; \
+	  $(INSTALL_PROGRAM) $(srcdir)/g++ $(DESTDIR)$(bindir)/g++; \
 	fi
-	$(INSTALL_PROGRAM) $(srcdir)/c++ $(bindir)/c++
-	$(INSTALL_PROGRAM) $(srcdir)/g++ $(bindir)/g++
-	-rm -f $(libsubdir)/cpp
-	$(INSTALL_PROGRAM) cpp $(libsubdir)/cpp
+	-rm -f $(DESTDIR)$(libsubdir)/cpp
+	$(INSTALL_PROGRAM) cpp $(DESTDIR)$(libsubdir)/cpp
 
 # Install protoize.
 install-proto: proto install-dir
-	-rm -f $(bindir)/protoize
-	$(INSTALL_PROGRAM) protoize $(bindir)/protoize
-	-rm -f $(bindir)/unprotoize
-	$(INSTALL_PROGRAM) unprotoize $(bindir)/unprotoize
-	-rm -f $(libsubdir)/SYSCALLS.c.X
-	$(INSTALL_DATA) SYSCALLS.c.X $(libsubdir)/SYSCALLS.c.X
-	chmod a-x $(libsubdir)/SYSCALLS.c.X
+	-if [ -f protoize ]; then \
+	  rm -f $(DESTDIR)$(bindir)/protoize; \
+	  $(INSTALL_PROGRAM) protoize $(DESTDIR)$(bindir)/protoize; \
+	  rm -f $(DESTDIR)$(bindir)/unprotoize; \
+	  $(INSTALL_PROGRAM) unprotoize $(DESTDIR)$(bindir)/unprotoize; \
+	  rm -f $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	  $(INSTALL_DATA) SYSCALLS.c.X $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	else true; fi
 
 # Install the man pages.
 install-man: install-dir $(srcdir)/gcc.1 protoize.1 unprotoize.1
-	-rm -f $(mandir)/gcc$(manext)
-	$(INSTALL_DATA) $(srcdir)/gcc.1 $(mandir)/gcc$(manext)
-	chmod a-x $(mandir)/gcc$(manext)
-	-rm -f $(mandir)/protoize$(manext)
-	$(INSTALL_DATA) protoize.1 $(mandir)/protoize$(manext)
-	chmod a-x $(mandir)/protoize$(manext)
-	-rm -f $(mandir)/unprotoize$(manext)
-	$(INSTALL_DATA) unprotoize.1 $(mandir)/unprotoize$(manext)
-	chmod a-x $(mandir)/unprotoize$(manext)
+	-rm -f $(DESTDIR)$(mandir)/gcc$(manext)
+	$(INSTALL_DATA) $(srcdir)/gcc.1 $(DESTDIR)$(mandir)/gcc$(manext)
+	chmod a-x $(DESTDIR)$(mandir)/gcc$(manext)
+	-if [ -f protoize ]; then \
+	  rm -f $(DESTDIR)$(mandir)/protoize$(manext); \
+	  $(INSTALL_DATA) protoize.1 $(DESTDIR)$(mandir)/protoize$(manext); \
+	  chmod a-x $(DESTDIR)$(mandir)/protoize$(manext); \
+	  rm -f $(DESTDIR)$(mandir)/unprotoize$(manext); \
+	  $(INSTALL_DATA) unprotoize.1 $(DESTDIR)$(mandir)/unprotoize$(manext); \
+	  chmod a-x $(DESTDIR)$(mandir)/unprotoize$(manext); \
+	fi
 
 # Install the library.
 install-libgcc: libgcc.a
 	-if [ -f libgcc.a ] ; then \
-	  rm -f $(libsubdir)/libgcc.a; \
-	  $(INSTALL_DATA) libgcc.a $(libsubdir)/libgcc.a; \
+	  rm -f $(DESTDIR)$(libsubdir)/libgcc.a; \
+	  $(INSTALL_DATA) libgcc.a $(DESTDIR)$(libsubdir)/libgcc.a; \
 	  if $(RANLIB_TEST) ; then \
-	    (cd $(libsubdir); $(RANLIB) libgcc.a); else true; fi; \
-	  chmod a-x $(libsubdir)/libgcc.a; \
+	    (cd $(DESTDIR)$(libsubdir); $(RANLIB) libgcc.a); else true; fi; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/libgcc.a; \
 	else true; fi
 
 # Install all the header files for native compiler.
@@ -1305,93 +1334,83 @@ install-headers: install-common-headers install-float-h install-limits-h
 
 # Install float.h for native compiler.
 install-float-h: float.h
-	-rm -f $(libsubdir)/include/float.h
-	$(INSTALL_DATA) float.h $(libsubdir)/include/float.h
-	chmod a-x $(libsubdir)/include/float.h
+	-rm -f $(DESTDIR)$(libsubdir)/include/float.h
+	$(INSTALL_DATA) float.h $(DESTDIR)$(libsubdir)/include/float.h
+	chmod a-x $(DESTDIR)$(libsubdir)/include/float.h
 
 # Install limits.h, optionally inheriting from the standard system version.
-install-limits-h: limits.h limitx.h
-	-rm -f $(libsubdir)/include/limits.h tmp-limits.h
+install-limits-h: limits.h limitx.h limity.h
+	-rm -f $(DESTDIR)$(libsubdir)/include/limits.h tmp-limits.h
 	if [ -f /usr/include/limits.h ] ; then \
-	  cat $(srcdir)/limitx.h $(srcdir)/limits.h > tmp-limits.h; \
+	  cat $(srcdir)/limitx.h $(srcdir)/limits.h $(srcdir)/limity.h > tmp-limits.h; \
 	else \
 	  cat $(srcdir)/limits.h > tmp-limits.h; \
 	fi
-	$(INSTALL_DATA) tmp-limits.h $(libsubdir)/include/limits.h
-	chmod a-x $(libsubdir)/include/limits.h
+	$(INSTALL_DATA) tmp-limits.h $(DESTDIR)$(libsubdir)/include/limits.h
+	chmod a-x $(DESTDIR)$(libsubdir)/include/limits.h
 	rm tmp-limits.h
 
 # Install the fixed headers that are the same for all machines.
 install-common-headers: install-dir $(USER_H) gvarargs.h gstdarg.h gstddef.h
-	if [ -d $(libsubdir)/include ] ; then true ; else mkdir $(libsubdir)/include ; fi
-	-chmod ugo+rx $(libsubdir)/include
+	if [ -d $(DESTDIR)$(libsubdir)/include ] ; then true ; else mkdir $(DESTDIR)$(libsubdir)/include ; fi
+	-chmod ugo+rx $(DESTDIR)$(libsubdir)/include
 # Must compute $(libsubdir) before the cd; the awk script won't work after.
-	shelllibsubdir=$(libsubdir); \
+	shelllibsubdir=$(DESTDIR)$(libsubdir); \
 	cd $(srcdir); \
 	for file in $(USER_H); do \
 	   rm -f $$shelllibsubdir/include/`basename $$file`; \
 	   $(INSTALL_DATA) `basename $$file` $$shelllibsubdir/include/`basename $$file`; \
 	   chmod a-x $$shelllibsubdir/include/`basename $$file`; \
 	done
-	-rm -f $(libsubdir)/include/varargs.h
-	$(INSTALL_DATA) $(srcdir)/gvarargs.h $(libsubdir)/include/varargs.h
-	chmod a-x $(libsubdir)/include/varargs.h
-	-rm -f $(libsubdir)/include/stdarg.h
-	$(INSTALL_DATA) $(srcdir)/gstdarg.h $(libsubdir)/include/stdarg.h
-	chmod a-x $(libsubdir)/include/stdarg.h
-	-rm -f $(libsubdir)/include/stddef.h
-	$(INSTALL_DATA) $(srcdir)/gstddef.h $(libsubdir)/include/stddef.h
-	chmod a-x $(libsubdir)/include/stddef.h
+	-rm -f $(DESTDIR)$(libsubdir)/include/varargs.h
+	$(INSTALL_DATA) $(srcdir)/gvarargs.h $(DESTDIR)$(libsubdir)/include/varargs.h
+	chmod a-x $(DESTDIR)$(libsubdir)/include/varargs.h
+	-rm -f $(DESTDIR)$(libsubdir)/include/stdarg.h
+	$(INSTALL_DATA) $(srcdir)/gstdarg.h $(DESTDIR)$(libsubdir)/include/stdarg.h
+	chmod a-x $(DESTDIR)$(libsubdir)/include/stdarg.h
+	-rm -f $(DESTDIR)$(libsubdir)/include/stddef.h
+	$(INSTALL_DATA) $(srcdir)/gstddef.h $(DESTDIR)$(libsubdir)/include/stddef.h
+	chmod a-x $(DESTDIR)$(libsubdir)/include/stddef.h
 # Copy byteorder.h into the object file directory 
 # so that fixinc.svr4 can get at it if necessary.
 # If the dirs are the same, this won't do anything.
 	-cp $(srcdir)/byteorder.h .
 
-# $(libsubdir)/include:
-#	if [ -d $(libsubdir)/include ] ; then true ; else mkdir $(libsubdir)/include ; fi
-#	-chmod ugo+rx $(libsubdir)/include
-
-# This appears not to work.  It isn't clear how to fix it.
-# $(libsubdir)/include/README: $(libsubdir)/include $(srcdir)/fixincludes
-#	LIB=$(libsubdir)/include $(srcdir)/fixincludes
-#	$(INSTALL_DATA) $(srcdir)/fixincludes-README $@
-#	chmod a-x $@
-
 # Run fixincludes in the proper directory.
 install-fixincludes: install-headers
-	rm -rf $(libsubdir)/tmp
-	mkdir $(libsubdir)/tmp
+	rm -rf $(DESTDIR)$(libsubdir)/tmp
+	mkdir $(DESTDIR)$(libsubdir)/tmp
 # Move aside the headers that come from GCC; delete all else.
-	cd $(libsubdir)/include; mv $(INSTALLED_H) ../tmp; rm -rf *
+	cd $(DESTDIR)$(libsubdir)/include; mv $(INSTALLED_H) ../tmp; rm -rf *
 # Install fixed copies of system files.
-	$(srcdir)/$(FIXINCLUDES) $(libsubdir)/include
+	$(srcdir)/$(FIXINCLUDES) $(DESTDIR)$(libsubdir)/include
 # Bring back gcc's header files.
-	cd $(libsubdir)/include; mv ../tmp/* .; rmdir ../tmp
+	cd $(DESTDIR)$(libsubdir)/include; mv ../tmp/* .; rmdir ../tmp
 # Install the README
-	$(INSTALL_DATA) $(srcdir)/README-fixinc $(libsubdir)/include/README
-	chmod a-x $(libsubdir)/include/README
+	$(INSTALL_DATA) $(srcdir)/README-fixinc $(DESTDIR)$(libsubdir)/include/README
+	chmod a-x $(DESTDIR)$(libsubdir)/include/README
 
 # Use this target to install the program `collect2' under the name `ld'.
 install-collect2: collect2
-	$(INSTALL_PROGRAM) collect2 $(libsubdir)/ld
+	$(INSTALL_PROGRAM) collect2 $(DESTDIR)$(libsubdir)/ld
 # Install the driver program as $(libsubdir)/gcc for collect2.
 	-if [ -f gcc-cross ] ; then \
-	  $(INSTALL_PROGRAM) gcc-cross $(libsubdir)/gcc; \
+	  $(INSTALL_PROGRAM) gcc-cross $(DESTDIR)$(libsubdir)/gcc; \
 	else \
-	  $(INSTALL_PROGRAM) gcc $(libsubdir)/gcc; \
+	  $(INSTALL_PROGRAM) gcc $(DESTDIR)$(libsubdir)/gcc; \
 	fi
 
 # Cancel installation by deleting the installed files.
 uninstall:
-	-rm -rf $(libsubdir)
-	-rm -rf $(bindir)/gcc
-	-rm -rf $(mandir)/protoize$(manext)
-	-rm -rf $(mandir)/unprotoize$(manext)
-	-rm -rf $(bindir)/protoize
-	-rm -rf $(bindir)/unprotoize
-	-rm -rf $(mandir)/gcc$(manext)
-	-rm -rf $(mandir)/protoize$(manext)
-	-rm -rf $(mandir)/unprotoize$(manext)
+	-rm -rf $(DESTDIR)$(libsubdir)
+	-rm -rf $(DESTDIR)$(bindir)/gcc
+	-rm -rf $(DESTDIR)$(mandir)/protoize$(manext)
+	-rm -rf $(DESTDIR)$(mandir)/unprotoize$(manext)
+	-rm -rf $(DESTDIR)$(bindir)/protoize
+	-rm -rf $(DESTDIR)$(bindir)/unprotoize
+	-rm -rf $(DESTDIR)$(mandir)/gcc$(manext)
+	-rm -rf $(DESTDIR)$(mandir)/protoize$(manext)
+	-rm -rf $(DESTDIR)$(mandir)/unprotoize$(manext)
 
 # These exist for maintenance purposes.
 
diff --git a/c++ b/c++
index db72410..48c445a 100755
--- a/c++
+++ b/c++
@@ -66,10 +66,4 @@ then
   exit 1
 fi
 
-progname=`echo $0 |sed -e 's|/[^/]*$|/gcc|'`
-if [ -f ${progname} ]
-then
-exec ${progname} $newargs $library
-else
-exec gcc $newargs $library
-fi
+exec gcc-2.1 $newargs $library
diff --git a/cccp.c b/cccp.c
index 5ecc219..d2d63b9 100644
--- a/cccp.c
+++ b/cccp.c
@@ -63,10 +63,11 @@ typedef unsigned char U_CHAR;
 #include <ctype.h>
 #include <stdio.h>
 #include <signal.h>
+#include <errno.h>
 
 #ifndef VMS
-#include <sys/file.h>
 #ifndef USG
+#include <time.h>
 #include <sys/time.h>		/* for __DATE__ and __TIME__ */
 #include <sys/resource.h>
 #else
@@ -131,8 +132,13 @@ extern char *getenv ();
 extern FILE *fdopen ();
 extern char *version_string;
 extern struct tm *localtime ();
+
+#ifndef HAVE_STRERROR
 extern int sys_nerr;
 extern char *sys_errlist[];
+#else
+char *strerror ();
+#endif
 
 #ifndef errno
 extern int errno;
@@ -328,9 +334,6 @@ static enum {dump_none, dump_only, dump_names, dump_definitions}
    where they are defined.  */
 static int debug_output = 0;
 
-/* Holds local startup time.  */
-static struct tm *timebuf = NULL;
-
 /* Nonzero indicates special processing used by the pcp program.  The
    special effects of this mode are: 
      
@@ -479,13 +482,25 @@ static struct default_include { char *fname; int cplusplus; } include_defaults_a
   = {
     /* Pick up GNU C++ specific include files.  */
     { GPLUSPLUS_INCLUDE_DIR, 1},
-    { GCC_INCLUDE_DIR, 0},
 #ifdef CROSS_COMPILE
+    /* This is the dir for fixincludes.  Put it just before
+       the files that we fix.  */
+    { GCC_INCLUDE_DIR, 0},
     /* For cross-compilation, this dir name is generated
        automatically in Makefile.in.  */
     { CROSS_INCLUDE_DIR, 0 },
+    /* This is another place that the target system's headers might be.  */
+    { TOOL_INCLUDE_DIR, 0},
 #else /* not CROSS_COMPILE */
+    /* This should be /use/local/include and should come before
+       the fixincludes-fixed header files.  */
     { LOCAL_INCLUDE_DIR, 0},
+    /* This is here ahead of GCC_INCLUDE_DIR because assert.h goes here.
+       Likewise, behind LOCAL_INCLUDE_DIR, where glibc puts its assert.h.  */
+    { TOOL_INCLUDE_DIR, 0},
+    /* This is the dir for fixincludes.  Put it just before
+       the files that we fix.  */
+    { GCC_INCLUDE_DIR, 0},
     /* Some systems have an extra dir of include files.  */
 #ifdef SYSTEM_INCLUDE_DIR
     { SYSTEM_INCLUDE_DIR, 0},
@@ -3384,6 +3399,18 @@ handle_directive (ip, op)
      That is the responsibility of cc1.  */
   return 0;
 }
+
+static struct tm *
+timestamp ()
+{
+  static struct tm *timebuf;
+  if (!timebuf) {
+    time_t t = time (0);
+    timebuf = localtime (&t);
+  }
+  return timebuf;
+}
+
 
 static char *monthnames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
 			     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
@@ -3403,6 +3430,7 @@ special_symbol (hp, op)
   int i, len;
   int true_indepth;
   FILE_BUF *ip = NULL;
+  struct tm *timebuf;
 
   int paren = 0;		/* For special `defined' keyword */
 
@@ -3488,6 +3516,7 @@ special_symbol (hp, op)
   case T_DATE:
   case T_TIME:
     buf = (char *) alloca (20);
+    timebuf = timestamp ();
     if (hp->type == T_DATE)
       sprintf (buf, "\"%s %2d %4d\"", monthnames[timebuf->tm_mon],
 	      timebuf->tm_mday, timebuf->tm_year + 1900);
@@ -7345,6 +7374,27 @@ delete_newlines (start, length)
   return obp - start;
 }
 
+/*
+ * my_strerror - return the descriptive text associated with an `errno' code.
+ */
+
+char *
+my_strerror (errnum)
+     int errnum;
+{
+  char *result;
+
+#ifndef HAVE_STRERROR
+  result = (char *) ((errnum < sys_nerr) ? sys_errlist[errnum] : 0);
+#else
+  result = strerror (errnum);
+#endif
+  if (!result)
+    result = "undocumented I/O error";
+
+  return result;
+}
+
 /*
  * error - print error message and increment count of errors.
  */
@@ -7390,11 +7440,7 @@ error_from_errno (name)
 
   if (ip != NULL)
     fprintf (stderr, "%s:%d: ", ip->nominal_fname, ip->lineno);
-
-  if (errno < sys_nerr)
-    fprintf (stderr, "%s: %s\n", name, sys_errlist[errno]);
-  else
-    fprintf (stderr, "%s: undocumented I/O error\n", name);
+  fprintf (stderr, "%s: %s\n", name, my_strerror (errno));
 
   errors++;
 }
@@ -7924,11 +7970,6 @@ initialize_builtins (inp, outp)
      FILE_BUF *inp;
      FILE_BUF *outp;
 {
-  time_t t;
-
-  t = time (0);
-  timebuf = localtime (&t);
-
   install ("__LINE__", -1, T_SPECLINE, 0, -1);
   install ("__DATE__", -1, T_DATE, 0, -1);
   install ("__FILE__", -1, T_FILE, 0, -1);
@@ -7951,6 +7992,7 @@ initialize_builtins (inp, outp)
     {
       char directive[2048];
       register struct directive *dp = &directive_table[0];
+      struct tm *timebuf = timestamp ();
 
       sprintf (directive, " __BASE_FILE__ \"%s\"",
 	       instack[0].nominal_fname);
@@ -8294,10 +8336,7 @@ perror_with_name (name)
      char *name;
 {
   fprintf (stderr, "%s: ", progname);
-  if (errno < sys_nerr)
-    fprintf (stderr, "%s: %s\n", name, sys_errlist[errno]);
-  else
-    fprintf (stderr, "%s: undocumented I/O error\n", name);
+  fprintf (stderr, "%s: %s\n", name, my_strerror (errno));
   errors++;
 }
 
diff --git a/collect2.c b/collect2.c
index 9cbd1c3..7895187 100644
--- a/collect2.c
+++ b/collect2.c
@@ -151,6 +151,9 @@ generic *xmalloc ();
 char *strerror (e)
      int e;
 {
+#ifdef HAVE_STRERROR
+  return strerror (e);
+#else
   extern char *sys_errlist[];
   extern int sys_nerr;
   static char buffer[30];
@@ -163,6 +166,7 @@ char *strerror (e)
 
   sprintf (buffer, "Unknown error %d", e);
   return buffer;
+#endif
 }
 
 #endif
diff --git a/combine.c b/combine.c
index 9f1c65a..1274410 100644
--- a/combine.c
+++ b/combine.c
@@ -76,7 +76,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include <stdio.h>
 
 #include "config.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
 #include "rtl.h"
 #include "flags.h"
 #include "regs.h"
@@ -365,7 +369,7 @@ static int merge_outer_ops ();
 static rtx simplify_shift_const ();
 static int recog_for_combine ();
 static rtx gen_lowpart_for_combine ();
-static rtx gen_rtx_combine ();
+static rtx gen_rtx_combine PVPROTO((enum rtx_code code, enum machine_mode mode, ...));
 static rtx gen_binary ();
 static rtx gen_unary ();
 static enum rtx_code simplify_comparison ();
@@ -6000,21 +6004,26 @@ gen_lowpart_for_combine (mode, x)
 
 /*VARARGS2*/
 static rtx
-gen_rtx_combine (va_alist)
-     va_dcl
+gen_rtx_combine VPROTO((enum rtx_code code, enum machine_mode mode, ...))
 {
-  va_list p;
+#ifndef __STDC__
   enum rtx_code code;
   enum machine_mode mode;
+#endif
+  va_list p;
   int n_args;
   rtx args[3];
   int i, j;
   char *fmt;
   rtx rt;
 
-  va_start (p);
+  VA_START (p, mode);
+
+#ifndef __STDC__
   code = va_arg (p, enum rtx_code);
   mode = va_arg (p, enum machine_mode);
+#endif
+
   n_args = GET_RTX_LENGTH (code);
   fmt = GET_RTX_FORMAT (code);
 
diff --git a/config/i386.h b/config/i386.h
index c0cd287..474061c 100644
--- a/config/i386.h
+++ b/config/i386.h
@@ -43,6 +43,11 @@ extern int target_flags;
 
 /* Macros used in the machine description to test the flags.  */
 
+/* configure can arrage to make this 2, to force a 486.  */
+#ifndef TARGET_CPU_DEFAULT
+#define TARGET_CPU_DEFAULT 0
+#endif
+
 /* Compile 80387 insns for floating point (not library calls).  */
 #define TARGET_80387 (target_flags & 1)
 /* Compile code for an i486. */
@@ -57,6 +62,11 @@ extern int target_flags;
    and is not intended to be usable on this cpu.  */
 #define TARGET_REGPARM (target_flags & 020)
 
+/* Functions that return a floating point value may return that value
+   in the 387 FPU or in 386 integer registers.  If set, this flag causes
+   the 387 to be used, which is compatible with most calling conventions. */
+#define TARGET_FLOAT_RETURNS_IN_80387 (target_flags & 0200)
+
 /* Macro to define tables used to set the flags.
    This is a list in braces of pairs in braces,
    each pair being { "NAME", VALUE }
@@ -73,7 +83,7 @@ extern int target_flags;
     { "nortd", -8},				\
     { "regparm", 020},				\
     { "noregparm", -020},			\
-    { "", TARGET_DEFAULT}}
+    { "", TARGET_DEFAULT | TARGET_CPU_DEFAULT }}
 
 /* target machine storage layout */
 
diff --git a/config/i386.md b/config/i386.md
index 95b3adb..7bae7a5 100644
--- a/config/i386.md
+++ b/config/i386.md
@@ -2074,11 +2074,30 @@
 ;; shift pair, instead using moves and sign extension for counts greater
 ;; than 31.
 
-(define_insn "ashldi3"
-  [(set (match_operand:DI 0 "general_operand" "=&r")
-	(ashift:DI (match_operand:DI 1 "general_operand" "0")
-		   (match_operand:QI 2 "general_operand" "cJ")))
-   (clobber (match_dup 2))]
+(define_expand "ashldi3"
+  [(set (match_operand:DI 0 "register_operand" "")
+	(ashift:DI (match_operand:DI 1 "register_operand" "")
+		   (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  "
+{
+  if (GET_CODE (operands[2]) != CONST_INT
+      || ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J'))
+    {
+      operands[2] = copy_to_mode_reg (QImode, operands[2]);
+      emit_insn (gen_ashldi3_non_const_int (operands[0], operands[1],
+					    operands[2]));
+    }
+  else
+    emit_insn (gen_ashldi3_const_int (operands[0], operands[1], operands[2]));
+
+  DONE;
+}")
+
+(define_insn "ashldi3_const_int"
+  [(set (match_operand:DI 0 "register_operand" "=&r")
+	(ashift:DI (match_operand:DI 1 "register_operand" "0")
+		   (match_operand:QI 2 "const_int_operand" "J")))]
   ""
   "*
 {
@@ -2092,42 +2111,58 @@
   xops[2] = low[0];
   xops[3] = high[0];
 
-  if (REG_P (xops[0]))	/* If shift count in %cl */
+  if (INTVAL (xops[0]) > 31)
     {
-      output_asm_insn (AS2 (ror%B0,%1,%0), xops);	/* shift count / 2 */
+      output_asm_insn (AS2 (mov%L3,%2,%3), xops);	/* Fast shift by 32 */
+      output_asm_insn (AS2 (xor%L2,%2,%2), xops);
 
-      output_asm_insn (AS2 (shld%L3,%2,%3), xops);
-      output_asm_insn (AS2 (sal%L2,%0,%2), xops);
-      output_asm_insn (AS2 (shld%L3,%2,%3), xops);
+      if (INTVAL (xops[0]) > 32)
+        {
+	  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);
+
+	  output_asm_insn (AS2 (sal%L3,%0,%3), xops); /* Remaining shift */
+	}
+    }
+  else
+    {
+      output_asm_insn (AS3 (shld%L3,%0,%2,%3), xops);
       output_asm_insn (AS2 (sal%L2,%0,%2), xops);
+    }
+  RET;
+}")
 
-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);	/* shift count & 1 */
+(define_insn "ashldi3_non_const_int"
+  [(set (match_operand:DI 0 "register_operand" "=&r")
+	(ashift:DI (match_operand:DI 1 "register_operand" "0")
+		   (match_operand:QI 2 "register_operand" "c")))
+   (clobber (match_dup 2))]
+  ""
+  "*
+{
+  rtx xops[4], low[1], high[1];
 
-      output_asm_insn (AS2 (shr%B0,%1,%0), xops);
+  CC_STATUS_INIT;
 
-      output_asm_insn (AS2 (shld%L3,%2,%3), xops);
-      output_asm_insn (AS2 (sal%L2,%0,%2), xops);
-    }
-  else if (GET_CODE (xops[0]) == CONST_INT)
-    {
-      if (INTVAL (xops[0]) > 31)
-	{
-	  output_asm_insn (AS2 (mov%L3,%2,%3), xops);	/* Fast shift by 32 */
-	  output_asm_insn (AS2 (xor%L2,%2,%2), xops);
+  split_di (operands, 1, low, high);
+  xops[0] = operands[2];
+  xops[1] = const1_rtx;
+  xops[2] = low[0];
+  xops[3] = high[0];
 
-	  if (INTVAL (xops[0]) > 32)
-	    {
-	      xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);
+  output_asm_insn (AS2 (ror%B0,%1,%0), xops);	/* shift count / 2 */
+
+  output_asm_insn (AS3_SHIFT_DOUBLE (shld%L3,%0,%2,%3), xops);
+  output_asm_insn (AS2 (sal%L2,%0,%2), xops);
+  output_asm_insn (AS3_SHIFT_DOUBLE (shld%L3,%0,%2,%3), xops);
+  output_asm_insn (AS2 (sal%L2,%0,%2), xops);
+
+  xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);	/* shift count & 1 */
+
+  output_asm_insn (AS2 (shr%B0,%1,%0), xops);
+
+  output_asm_insn (AS3_SHIFT_DOUBLE (shld%L3,%0,%2,%3), xops);
+  output_asm_insn (AS2 (sal%L2,%0,%2), xops);
 
-	      output_asm_insn (AS2 (sal%3,%0,%3), xops); /* Remaining shift */
-	    }
-	}
-      else
-        {
-	  output_asm_insn (AS3 (shld%L3,%0,%2,%3), xops);
-	  output_asm_insn (AS2 (sal%L2,%0,%2), xops);
-	}
-    }
   RET;
 }")
 
@@ -2138,7 +2173,7 @@
 (define_insn "ashlsi3"
   [(set (match_operand:SI 0 "general_operand" "=r,rm")
 	(ashift:SI (match_operand:SI 1 "general_operand" "r,0")
-		   (match_operand:SI 2 "general_operand" "M,cI")))]
+		   (match_operand:SI 2 "nonmemory_operand" "M,cI")))]
   ""
   "*
 {
@@ -2171,7 +2206,7 @@
 (define_insn "ashlhi3"
   [(set (match_operand:HI 0 "general_operand" "=rm")
 	(ashift:HI (match_operand:HI 1 "general_operand" "0")
-		   (match_operand:HI 2 "general_operand" "cI")))]
+		   (match_operand:HI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2187,7 +2222,7 @@
 (define_insn "ashlqi3"
   [(set (match_operand:QI 0 "general_operand" "=qm")
 	(ashift:QI (match_operand:QI 1 "general_operand" "0")
-		   (match_operand:QI 2 "general_operand" "cI")))]
+		   (match_operand:QI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2202,15 +2237,34 @@
 
 ;; See comment above `ashldi3' about how this works.
 
-(define_insn "ashrdi3"
-  [(set (match_operand:DI 0 "general_operand" "=&r")
-	(ashiftrt:DI (match_operand:DI 1 "general_operand" "0")
-		     (match_operand:QI 2 "general_operand" "cJ")))
-   (clobber (match_dup 2))]
+(define_expand "ashrdi3"
+  [(set (match_operand:DI 0 "register_operand" "")
+	(ashiftrt:DI (match_operand:DI 1 "register_operand" "")
+		     (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  "
+{
+  if (GET_CODE (operands[2]) != CONST_INT
+      || ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J'))
+    {
+      operands[2] = copy_to_mode_reg (QImode, operands[2]);
+      emit_insn (gen_ashrdi3_non_const_int (operands[0], operands[1],
+					    operands[2]));
+    }
+  else
+    emit_insn (gen_ashrdi3_const_int (operands[0], operands[1], operands[2]));
+
+  DONE;
+}")
+
+(define_insn "ashrdi3_const_int"
+  [(set (match_operand:DI 0 "register_operand" "=&r")
+	(ashiftrt:DI (match_operand:DI 1 "register_operand" "0")
+		     (match_operand:QI 2 "const_int_operand" "J")))]
   ""
   "*
 {
-  rtx xops[5], low[1], high[1];
+  rtx xops[4], low[1], high[1];
 
   CC_STATUS_INIT;
 
@@ -2220,50 +2274,67 @@
   xops[2] = low[0];
   xops[3] = high[0];
 
-  if (REG_P (xops[0]))	/* If shift count in %cl */
+  if (INTVAL (xops[0]) > 31)
     {
-      output_asm_insn (AS2 (ror%B0,%1,%0), xops);	/* shift count / 2 */
+      xops[1] = gen_rtx (CONST_INT, VOIDmode, 31);
+      output_asm_insn (AS2 (mov%L2,%3,%2), xops);
+      output_asm_insn (AS2 (sar%L3,%1,%3), xops);	/* shift by 32 */
 
-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);
-      output_asm_insn (AS2 (sar%L3,%0,%3), xops);
-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);
+      if (INTVAL (xops[0]) > 32)
+        {
+	  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);
+
+	  output_asm_insn (AS2 (sar%L2,%0,%2), xops); /* Remaining shift */
+	}
+    }
+  else
+    {
+      output_asm_insn (AS3 (shrd%L2,%0,%3,%2), xops);
       output_asm_insn (AS2 (sar%L3,%0,%3), xops);
+    }
+
+  RET;
+}")
+
+(define_insn "ashrdi3_non_const_int"
+  [(set (match_operand:DI 0 "register_operand" "=&r")
+	(ashiftrt:DI (match_operand:DI 1 "register_operand" "0")
+		     (match_operand:QI 2 "register_operand" "c")))
+   (clobber (match_dup 2))]
+  ""
+  "*
+{
+  rtx xops[4], low[1], high[1];
 
-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);	/* shift count & 1 */
+  CC_STATUS_INIT;
 
-      output_asm_insn (AS2 (shr%B0,%1,%0), xops);
+  split_di (operands, 1, low, high);
+  xops[0] = operands[2];
+  xops[1] = const1_rtx;
+  xops[2] = low[0];
+  xops[3] = high[0];
 
-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);
-      output_asm_insn (AS2 (sar%L3,%0,%3), xops);
-    }
-  else if (GET_CODE (xops[0]) == CONST_INT)
-    {
-      if (INTVAL (xops[0]) > 31)
-	{
-	  xops[1] = gen_rtx (CONST_INT, VOIDmode, 31);
-	  output_asm_insn (AS2 (mov%L2,%3,%2), xops);
-	  output_asm_insn (AS2 (sar%L3,%1,%3), xops);	/* shift by 32 */
+  output_asm_insn (AS2 (ror%B0,%1,%0), xops);	/* shift count / 2 */
 
-	  if (INTVAL (xops[0]) > 32)
-	    {
-	      xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);
+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);
+  output_asm_insn (AS2 (sar%L3,%0,%3), xops);
+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);
+  output_asm_insn (AS2 (sar%L3,%0,%3), xops);
+
+  xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);	/* shift count & 1 */
+
+  output_asm_insn (AS2 (shr%B0,%1,%0), xops);
+
+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);
+  output_asm_insn (AS2 (sar%L3,%0,%3), xops);
 
-	      output_asm_insn (AS2 (sar%2,%0,%2), xops); /* Remaining shift */
-	    }
-	}
-      else
-        {
-	  output_asm_insn (AS3 (shrd%L2,%0,%3,%2), xops);
-	  output_asm_insn (AS2 (sar%L3,%0,%3), xops);
-        }
-    }
   RET;
 }")
 
 (define_insn "ashrsi3"
   [(set (match_operand:SI 0 "general_operand" "=rm")
 	(ashiftrt:SI (match_operand:SI 1 "general_operand" "0")
-		     (match_operand:SI 2 "general_operand" "cI")))]
+		     (match_operand:SI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2276,7 +2347,7 @@
 (define_insn "ashrhi3"
   [(set (match_operand:HI 0 "general_operand" "=rm")
 	(ashiftrt:HI (match_operand:HI 1 "general_operand" "0")
-		     (match_operand:HI 2 "general_operand" "cI")))]
+		     (match_operand:HI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2289,7 +2360,7 @@
 (define_insn "ashrqi3"
   [(set (match_operand:QI 0 "general_operand" "=qm")
 	(ashiftrt:QI (match_operand:QI 1 "general_operand" "0")
-		     (match_operand:QI 2 "general_operand" "cI")))]
+		     (match_operand:QI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2303,15 +2374,34 @@
 
 ;; See comment above `ashldi3' about how this works.
 
-(define_insn "lshrdi3"
-  [(set (match_operand:DI 0 "general_operand" "=&r")
-	(lshiftrt:DI (match_operand:DI 1 "general_operand" "0")
-		     (match_operand:QI 2 "general_operand" "cJ")))
-   (clobber (match_dup 2))]
+(define_expand "lshrdi3"
+  [(set (match_operand:DI 0 "register_operand" "")
+	(lshiftrt:DI (match_operand:DI 1 "register_operand" "")
+		     (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  "
+{
+  if (GET_CODE (operands[2]) != CONST_INT
+      || ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J'))
+    {
+      operands[2] = copy_to_mode_reg (QImode, operands[2]);
+      emit_insn (gen_lshrdi3_non_const_int (operands[0], operands[1],
+					    operands[2]));
+    }
+  else
+    emit_insn (gen_lshrdi3_const_int (operands[0], operands[1], operands[2]));
+
+  DONE;
+}")
+
+(define_insn "lshrdi3_const_int"
+  [(set (match_operand:DI 0 "register_operand" "=&r")
+	(lshiftrt:DI (match_operand:DI 1 "register_operand" "0")
+		     (match_operand:QI 2 "const_int_operand" "J")))]
   ""
   "*
 {
-  rtx xops[5], low[1], high[1];
+  rtx xops[4], low[1], high[1];
 
   CC_STATUS_INIT;
 
@@ -2321,49 +2411,66 @@
   xops[2] = low[0];
   xops[3] = high[0];
 
-  if (REG_P (xops[0]))	/* If shift count in %cl */
+  if (INTVAL (xops[0]) > 31)
     {
-      output_asm_insn (AS2 (ror%B0,%1,%0), xops);	/* shift count / 2 */
+      output_asm_insn (AS2 (mov%L2,%3,%2), xops);	/* Fast shift by 32 */
+      output_asm_insn (AS2 (xor%L3,%3,%3), xops);
 
-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);
-      output_asm_insn (AS2 (shr%L3,%0,%3), xops);
-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);
+      if (INTVAL (xops[0]) > 32)
+        {
+	  xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);
+
+	  output_asm_insn (AS2 (shr%L2,%0,%2), xops); /* Remaining shift */
+	}
+    }
+  else
+    {
+      output_asm_insn (AS3 (shrd%L2,%0,%3,%2), xops);
       output_asm_insn (AS2 (shr%L3,%0,%3), xops);
+    }
 
-      xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);	/* shift count & 1 */
+  RET;
+}")
 
-      output_asm_insn (AS2 (shr%B0,%1,%0), xops);
+(define_insn "lshrdi3_non_const_int"
+  [(set (match_operand:DI 0 "register_operand" "=&r")
+	(lshiftrt:DI (match_operand:DI 1 "register_operand" "0")
+		     (match_operand:QI 2 "register_operand" "c")))
+   (clobber (match_dup 2))]
+  ""
+  "*
+{
+  rtx xops[4], low[1], high[1];
 
-      output_asm_insn (AS2 (shrd%L2,%3,%2), xops);
-      output_asm_insn (AS2 (shr%L3,%0,%3), xops);
-    }
-  else if (GET_CODE (xops[0]) == CONST_INT)
-    {
-      if (INTVAL (xops[0]) > 31)
-	{
-	  output_asm_insn (AS2 (mov%L2,%3,%2), xops);	/* Fast shift by 32 */
-	  output_asm_insn (AS2 (xor%L3,%3,%3), xops);
+  CC_STATUS_INIT;
 
-	  if (INTVAL (xops[0]) > 32)
-	    {
-	      xops[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (xops[0]) - 32);
+  split_di (operands, 1, low, high);
+  xops[0] = operands[2];
+  xops[1] = const1_rtx;
+  xops[2] = low[0];
+  xops[3] = high[0];
+
+  output_asm_insn (AS2 (ror%B0,%1,%0), xops);	/* shift count / 2 */
+
+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);
+  output_asm_insn (AS2 (shr%L3,%0,%3), xops);
+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);
+  output_asm_insn (AS2 (shr%L3,%0,%3), xops);
+
+  xops[1] = gen_rtx (CONST_INT, VOIDmode, 7);	/* shift count & 1 */
+
+  output_asm_insn (AS2 (shr%B0,%1,%0), xops);
+
+  output_asm_insn (AS3_SHIFT_DOUBLE (shrd%L2,%0,%3,%2), xops);
+  output_asm_insn (AS2 (shr%L3,%0,%3), xops);
 
-	      output_asm_insn (AS2 (shr%2,%0,%2), xops); /* Remaining shift */
-	    }
-	}
-      else
-        {
-	  output_asm_insn (AS3 (shrd%L2,%0,%3,%2), xops);
-	  output_asm_insn (AS2 (shr%L3,%0,%3), xops);
-        }
-    }
   RET;
 }")
 
 (define_insn "lshrsi3"
   [(set (match_operand:SI 0 "general_operand" "=rm")
 	(lshiftrt:SI (match_operand:SI 1 "general_operand" "0")
-		     (match_operand:SI 2 "general_operand" "cI")))]
+		     (match_operand:SI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2376,7 +2483,7 @@
 (define_insn "lshrhi3"
   [(set (match_operand:HI 0 "general_operand" "=rm")
 	(lshiftrt:HI (match_operand:HI 1 "general_operand" "0")
-		     (match_operand:HI 2 "general_operand" "cI")))]
+		     (match_operand:HI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2389,7 +2496,7 @@
 (define_insn "lshrqi3"
   [(set (match_operand:QI 0 "general_operand" "=qm")
 	(lshiftrt:QI (match_operand:QI 1 "general_operand" "0")
-		     (match_operand:QI 2 "general_operand" "cI")))]
+		     (match_operand:QI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2404,7 +2511,7 @@
 (define_insn "rotlsi3"
   [(set (match_operand:SI 0 "general_operand" "=rm")
 	(rotate:SI (match_operand:SI 1 "general_operand" "0")
-		   (match_operand:SI 2 "general_operand" "cI")))]
+		   (match_operand:SI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2417,7 +2524,7 @@
 (define_insn "rotlhi3"
   [(set (match_operand:HI 0 "general_operand" "=rm")
 	(rotate:HI (match_operand:HI 1 "general_operand" "0")
-		   (match_operand:HI 2 "general_operand" "cI")))]
+		   (match_operand:HI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2430,7 +2537,7 @@
 (define_insn "rotlqi3"
   [(set (match_operand:QI 0 "general_operand" "=qm")
 	(rotate:QI (match_operand:QI 1 "general_operand" "0")
-		   (match_operand:QI 2 "general_operand" "cI")))]
+		   (match_operand:QI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2443,7 +2550,7 @@
 (define_insn "rotrsi3"
   [(set (match_operand:SI 0 "general_operand" "=rm")
 	(rotatert:SI (match_operand:SI 1 "general_operand" "0")
-		     (match_operand:SI 2 "general_operand" "cI")))]
+		     (match_operand:SI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2456,7 +2563,7 @@
 (define_insn "rotrhi3"
   [(set (match_operand:HI 0 "general_operand" "=rm")
 	(rotatert:HI (match_operand:HI 1 "general_operand" "0")
-		     (match_operand:HI 2 "general_operand" "cI")))]
+		     (match_operand:HI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
@@ -2469,7 +2576,7 @@
 (define_insn "rotrqi3"
   [(set (match_operand:QI 0 "general_operand" "=qm")
 	(rotatert:QI (match_operand:QI 1 "general_operand" "0")
-		     (match_operand:QI 2 "general_operand" "cI")))]
+		     (match_operand:QI 2 "nonmemory_operand" "cI")))]
   ""
   "*
 {
diff --git a/config/i386gas.h b/config/i386gas.h
index f9f98d1..3f3b18f 100644
--- a/config/i386gas.h
+++ b/config/i386gas.h
@@ -128,3 +128,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
       (PTR) += 4;							\
     }									\
 }
+
+/* Define macro used to output shift-double opcodes when the shift
+   count is in %cl.  Some assemblers require %cl as an argument;
+   some don't.
+
+   GAS requires the %cl argument, so override unx386.h. */
+
+#undef AS3_SHIFT_DOUBLE
+#define AS3_SHIFT_DOUBLE(a,b,c,d) AS3 (a,b,c,d)
+
diff --git a/config/i386linux-aout.h b/config/i386linux-aout.h
new file mode 100644
index 0000000..a469c58
--- /dev/null
+++ b/config/i386linux-aout.h
@@ -0,0 +1,76 @@
+/* Definitions for Intel 386 running Linux
+   Copyright (C) 1992, 1994, 1995 Free Software Foundation, Inc.
+   Contributed by H.J. Lu (hjl@nynexst.com)
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This is tested by i386/gas.h.  */
+#define YES_UNDERSCORES
+
+#include <i386gstabs.h>
+#include <linux-aout.h>	/* some common stuff */
+
+/* Specify predefined symbols in preprocessor.  */
+
+#undef CPP_PREDEFINES
+#define CPP_PREDEFINES "-Dunix -Di386 -Dlinux -Asystem(unix) -Asystem(posix) -Acpu(i386) -Amachine(i386)"
+
+#undef CPP_SPEC
+#if TARGET_CPU_DEFAULT == 2
+#define CPP_SPEC "%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{!m386:-D__i486__} %{posix:-D_POSIX_SOURCE}"
+#else
+#define CPP_SPEC "%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{m486:-D__i486__} %{posix:-D_POSIX_SOURCE}"
+#endif
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "long int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+/* Don't default to pcc-struct-return, because gcc is the only compiler,
+   and we want to retain compatibility with older gcc versions.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+#undef LIB_SPEC
+
+#if 1
+/* We no longer link with libc_p.a or libg.a by default. If you
+ * want to profile or debug the Linux C library, please add
+ * -lc_p or -ggdb to LDFLAGS at the link time, respectively.
+ */
+#define LIB_SPEC \
+"%{mieee-fp:-lieee} %{p:-lgmon} %{pg:-lgmon} %{!ggdb:-lc} %{ggdb:-lg}"
+#else    
+#define LIB_SPEC \
+"%{mieee-fp:-lieee} %{p:-lgmon -lc_p} %{pg:-lgmon -lc_p} \
+ %{!p:%{!pg:%{!g*:-lc} %{g*:-lg -static}}}" 
+#endif
+
+
+#undef LINK_SPEC
+#define LINK_SPEC	"-m i386linux"
+
+/* Get perform_* macros to build libgcc.a.  */
+#include "i386perform.h"
diff --git a/config/i386linux.h b/config/i386linux.h
new file mode 100644
index 0000000..4503fce
--- /dev/null
+++ b/config/i386linux.h
@@ -0,0 +1,236 @@
+/* Definitions for Intel 386 running Linux with ELF format
+   Copyright (C) 1994, 1995 Free Software Foundation, Inc.
+   Contributed by Eric Youngdale.
+   Modified for stabs-in-ELF by H.J. Lu.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#define LINUX_DEFAULT_ELF
+
+/* A lie, I guess, but the general idea behind linux/ELF is that we are
+   supposed to be outputting something that will assemble under SVr4.
+   This gets us pretty close.  */
+#include <i386.h>	/* Base i386 target machine definitions */
+#include <att386.h>	/* Use the i386 AT&T assembler syntax */
+#include <linux.h>	/* some common stuff */
+
+#undef TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (i386 Linux/ELF)");
+
+/* The svr4 ABI for the i386 says that records and unions are returned
+   in memory.  */
+#undef DEFAULT_PCC_STRUCT_RETURN
+#define DEFAULT_PCC_STRUCT_RETURN 1
+
+/* This is how to output an element of a case-vector that is relative.
+   This is only used for PIC code.  See comments by the `casesi' insn in
+   i386.md for an explanation of the expression this outputs. */
+#undef ASM_OUTPUT_ADDR_DIFF_ELT
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \
+  fprintf (FILE, "\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\n", LPREFIX, VALUE)
+
+/* Indicate that jump tables go in the text section.  This is
+   necessary when compiling PIC code.  */
+#define JUMP_TABLES_IN_TEXT_SECTION
+
+/* Copy this from the svr4 specifications... */
+/* Define the register numbers to be used in Dwarf debugging information.
+   The SVR4 reference port C compiler uses the following register numbers
+   in its Dwarf output code:
+	0 for %eax (gnu regno = 0)
+	1 for %ecx (gnu regno = 2)
+	2 for %edx (gnu regno = 1)
+	3 for %ebx (gnu regno = 3)
+	4 for %esp (gnu regno = 7)
+	5 for %ebp (gnu regno = 6)
+	6 for %esi (gnu regno = 4)
+	7 for %edi (gnu regno = 5)
+   The following three DWARF register numbers are never generated by
+   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4
+   believes these numbers have these meanings.
+	8  for %eip    (no gnu equivalent)
+	9  for %eflags (no gnu equivalent)
+	10 for %trapno (no gnu equivalent)
+   It is not at all clear how we should number the FP stack registers
+   for the x86 architecture.  If the version of SDB on x86/svr4 were
+   a bit less brain dead with respect to floating-point then we would
+   have a precedent to follow with respect to DWARF register numbers
+   for x86 FP registers, but the SDB on x86/svr4 is so completely
+   broken with respect to FP registers that it is hardly worth thinking
+   of it as something to strive for compatibility with.
+   The version of x86/svr4 SDB I have at the moment does (partially)
+   seem to believe that DWARF register number 11 is associated with
+   the x86 register %st(0), but that's about all.  Higher DWARF
+   register numbers don't seem to be associated with anything in
+   particular, and even for DWARF regno 11, SDB only seems to under-
+   stand that it should say that a variable lives in %st(0) (when
+   asked via an `=' command) if we said it was in DWARF regno 11,
+   but SDB still prints garbage when asked for the value of the
+   variable in question (via a `/' command).
+   (Also note that the labels SDB prints for various FP stack regs
+   when doing an `x' command are all wrong.)
+   Note that these problems generally don't affect the native SVR4
+   C compiler because it doesn't allow the use of -O with -g and
+   because when it is *not* optimizing, it allocates a memory
+   location for each floating-point variable, and the memory
+   location is what gets described in the DWARF AT_location
+   attribute for the variable in question.
+   Regardless of the severe mental illness of the x86/svr4 SDB, we
+   do something sensible here and we use the following DWARF
+   register numbers.  Note that these are all stack-top-relative
+   numbers.
+	11 for %st(0) (gnu regno = 8)
+	12 for %st(1) (gnu regno = 9)
+	13 for %st(2) (gnu regno = 10)
+	14 for %st(3) (gnu regno = 11)
+	15 for %st(4) (gnu regno = 12)
+	16 for %st(5) (gnu regno = 13)
+	17 for %st(6) (gnu regno = 14)
+	18 for %st(7) (gnu regno = 15)
+*/
+#undef DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(n) \
+((n) == 0 ? 0 \
+ : (n) == 1 ? 2 \
+ : (n) == 2 ? 1 \
+ : (n) == 3 ? 3 \
+ : (n) == 4 ? 6 \
+ : (n) == 5 ? 7 \
+ : (n) == 6 ? 5 \
+ : (n) == 7 ? 4 \
+ : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \
+ : (-1))
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry.  */
+
+#undef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(FILE, LABELNO)  \
+{									\
+  if (flag_pic)								\
+    {									\
+      fprintf (FILE, "\tleal %sP%d@GOTOFF(%%ebx),%%edx\n",		\
+	       LPREFIX, (LABELNO));					\
+      fprintf (FILE, "\tcall *mcount@GOT(%%ebx)\n");			\
+    }									\
+  else									\
+    {									\
+      fprintf (FILE, "\tmovl $%sP%d,%%edx\n", LPREFIX, (LABELNO));	\
+      fprintf (FILE, "\tcall mcount\n");				\
+    }									\
+}
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "long int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+#undef CPP_PREDEFINES
+#define CPP_PREDEFINES "-D__ELF__ -Dunix -Di386 -Dlinux -Asystem(unix) -Asystem(posix) -Acpu(i386) -Amachine(i386)"
+
+#undef CPP_SPEC
+#ifdef USE_GNULIBC_1
+#if TARGET_CPU_DEFAULT == 2
+#define CPP_SPEC "%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{!m386:-D__i486__} %{posix:-D_POSIX_SOURCE}"
+#else
+#define CPP_SPEC "%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{m486:-D__i486__} %{posix:-D_POSIX_SOURCE}"
+#endif
+#else /* not USE_GNULIBC_1 */
+#define CPP_SPEC "%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}"
+#endif /* not USE_GNULIBC_1 */
+
+#undef LIBGCC_SPEC
+#define LIBGCC_SPEC "-lgcc"
+
+#undef	LIB_SPEC
+#ifdef USE_GNULIBC_1
+#if 1
+/* We no longer link with libc_p.a or libg.a by default. If you
+ * want to profile or debug the Linux C library, please add
+ * -lc_p or -ggdb to LDFLAGS at the link time, respectively.
+ */
+#define LIB_SPEC \
+  "%{!shared: %{mieee-fp:-lieee} %{p:-lgmon} %{pg:-lgmon} \
+     %{!ggdb:-lc} %{ggdb:-lg}}"
+#else
+#define LIB_SPEC \
+  "%{!shared: \
+     %{mieee-fp:-lieee} %{p:-lgmon -lc_p} %{pg:-lgmon -lc_p} \
+       %{!p:%{!pg:%{!g*:-lc} %{g*:-lg}}}}"
+#endif
+#else
+#define LIB_SPEC \
+  "%{shared: -lc} \
+   %{!shared: %{mieee-fp:-lieee} %{pthread:-lpthread} \
+	%{profile:-lc_p} %{!profile: -lc}}"
+#endif /* not USE_GNULIBC_1 */
+
+/* Provide a LINK_SPEC appropriate for Linux.  Here we provide support
+   for the special GCC options -static and -shared, which allow us to
+   link things in one of these three modes by applying the appropriate
+   combinations of options at link-time. We like to support here for
+   as many of the other GNU linker options as possible. But I don't
+   have the time to search for those flags. I am sure how to add
+   support for -soname shared_object_name. H.J.
+
+   I took out %{v:%{!V:-V}}. It is too much :-(. They can use
+   -Wl,-V.
+
+   When the -shared link option is used a final link is not being
+   done.  */
+
+/* If ELF is the default format, we should not use /lib/elf. */
+
+#undef	LINK_SPEC
+#ifdef USE_GNULIBC_1
+#ifndef LINUX_DEFAULT_ELF
+#define LINK_SPEC "-m elf_i386 %{shared:-shared} \
+  %{!shared: \
+    %{!ibcs: \
+      %{!static: \
+	%{rdynamic:-export-dynamic} \
+	%{!dynamic-linker:-dynamic-linker /lib/elf/ld-linux.so.1} \
+	%{!rpath:-rpath /lib/elf/}} %{static:-static}}}"
+#else
+#define LINK_SPEC "-m elf_i386 %{shared:-shared} \
+  %{!shared: \
+    %{!ibcs: \
+      %{!static: \
+	%{rdynamic:-export-dynamic} \
+	%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.1}} \
+	%{static:-static}}}"
+#endif
+#else /* not USE_GNULIBC_1 */
+#define LINK_SPEC "-m elf_i386 %{shared:-shared} \
+  %{!shared: \
+    %{!ibcs: \
+      %{!static: \
+	%{rdynamic:-export-dynamic} \
+	%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \
+	%{static:-static}}}"
+#endif /* not USE_GNULIBC_1 */
+
+/* Get perform_* macros to build libgcc.a.  */
+#include "i386perform.h"
diff --git a/config/i386perform.h b/config/i386perform.h
new file mode 100644
index 0000000..c1a4170
--- /dev/null
+++ b/config/i386perform.h
@@ -0,0 +1,93 @@
+/* Definitions for AT&T assembler syntax for the Intel 80386.
+   Copyright (C) 1988 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+/* Defines to be able to build libgcc.a with GCC.  */
+
+/* It might seem that these are not important, since gcc 2 will never
+   call libgcc for these functions.  But programs might be linked with
+   code compiled by gcc 1, and then these will be used.  */
+
+/* The arg names used to be a and b, but `a' appears inside strings
+   and that confuses non-ANSI cpp.  */
+
+#define perform_udivsi3(arg0,arg1)					\
+{									\
+  register int dx asm("dx");						\
+  register int ax asm("ax");						\
+									\
+  dx = 0;								\
+  ax = arg0;								\
+  asm ("divl %3" : "=a" (ax), "=d" (dx) : "a" (ax), "g" (arg1), "d" (dx)); \
+  return ax;								\
+}
+
+#define perform_divsi3(arg0,arg1)					\
+{									\
+  register int dx asm("dx");						\
+  register int ax asm("ax");						\
+									\
+  ax = arg0;								\
+  asm ("cltd\n\tidivl %3" : "=a" (ax), "=d" (dx) : "a" (ax), "g" (arg1)); \
+  return ax;								\
+}
+
+#define perform_umodsi3(arg0,arg1)					\
+{									\
+  register int dx asm("dx");						\
+  register int ax asm("ax");						\
+									\
+  dx = 0;								\
+  ax = arg0;								\
+  asm ("divl %3" : "=a" (ax), "=d" (dx) : "a" (ax), "g" (arg1), "d" (dx)); \
+  return dx;								\
+}
+
+#define perform_modsi3(arg0,arg1)					\
+{									\
+  register int dx asm("dx");						\
+  register int ax asm("ax");						\
+									\
+  ax = arg0;								\
+  asm ("cltd\n\tidivl %3" : "=a" (ax), "=d" (dx) : "a" (ax), "g" (arg1)); \
+  return dx;								\
+}
+
+#define perform_fixdfsi(arg0)						\
+{									\
+  auto unsigned short ostatus;						\
+  auto unsigned short nstatus;						\
+  auto int ret;								\
+  auto double tmp;							\
+									\
+  &ostatus;			/* guarantee these land in memory */	\
+  &nstatus;								\
+  &ret;									\
+  &tmp;									\
+									\
+  asm volatile ("fnstcw %0" : "=m" (ostatus));				\
+  nstatus = ostatus | 0x0c00;						\
+  asm volatile ("fldcw %0" : /* no outputs */ : "m" (nstatus));		\
+  tmp = arg0;								\
+  asm volatile ("fldl %0" : /* no outputs */ : "m" (tmp));		\
+  asm volatile ("fistpl %0" : "=m" (ret));				\
+  asm volatile ("fldcw %0" : /* no outputs */ : "m" (ostatus));		\
+									\
+  return ret;								\
+}
+
diff --git a/config/linux-aout.h b/config/linux-aout.h
new file mode 100644
index 0000000..29fb8e9
--- /dev/null
+++ b/config/linux-aout.h
@@ -0,0 +1,51 @@
+/* Definitions for Linux
+   Copyright (C) 1995 Free Software Foundation, Inc.
+   Contributed by H.J. Lu (hjl@nynexst.com)
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Don't assume anything about the header files. */
+#define NO_IMPLICIT_EXTERN_C
+
+#undef HAVE_ATEXIT
+#define HAVE_ATEXIT
+
+/* Linux uses ctype from glibc.a. I am not sure how complete it is.
+   For now, we play safe. It may change later. */
+
+#if 0
+#undef MULTIBYTE_CHARS
+#define MULTIBYTE_CHARS	1
+#endif
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC  "%{pg:gcrt0.o%s} %{!pg:%{p:gcrt0.o%s} %{!p:crt0.o%s}} %{static:-static}"
+
+/* There are conflicting reports about whether this system uses
+   a different assembler syntax.  wilson@cygnus.com says # is right.  */
+#undef COMMENT_BEGIN
+#define COMMENT_BEGIN "#"
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+/* We need that too. */
+#define HANDLE_SYSV_PRAGMA
diff --git a/config/linux.h b/config/linux.h
new file mode 100644
index 0000000..c82cfe2
--- /dev/null
+++ b/config/linux.h
@@ -0,0 +1,88 @@
+/* Definitions for Linux with ELF format
+   Copyright (C) 1995 Free Software Foundation, Inc.
+   Contributed by Eric Youngdale.
+   Modified for stabs-in-ELF by H.J. Lu.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Don't assume anything about the header files. */
+#define NO_IMPLICIT_EXTERN_C
+
+#undef HAVE_ATEXIT
+#define HAVE_ATEXIT
+
+/* Linux uses ctype from glibc.a. I am not sure how complete it is.
+   For now, we play safe. It may change later. */
+
+#if 0
+#undef MULTIBYTE_CHARS
+#define MULTIBYTE_CHARS 1
+#endif
+
+/* There are conflicting reports about whether this system uses
+   a different assembler syntax.  wilson@cygnus.com says # is right.  */
+#undef COMMENT_BEGIN
+#define COMMENT_BEGIN "#"
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+/* Use stabs instead of DWARF debug format.  */
+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG
+#include "svr4.h"
+
+#undef MD_EXEC_PREFIX
+#undef MD_STARTFILE_PREFIX
+
+/* Output at beginning of assembler file.  */
+/* The .file command should always begin the output.  */
+#undef ASM_FILE_START
+#define ASM_FILE_START(FILE)						\
+  do {									\
+	output_file_directive (FILE, main_input_filename);		\
+	fprintf (FILE, "\t.version\t\"01.01\"\n");			\
+  } while (0)
+
+#undef	LIBGCC_SPEC
+#define LIBGCC_SPEC \
+  "%{!shared:-lgcc}"
+
+
+/* Provide a STARTFILE_SPEC appropriate for Linux.  Here we add
+   the Linux magical crtbegin.o file (see crtstuff.c) which
+   provides part of the support for getting C++ file-scope static
+   object constructed before entering `main'. */
+   
+#undef	STARTFILE_SPEC
+#define STARTFILE_SPEC \
+  "%{!shared: \
+     %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}}\
+   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+
+/* Provide a ENDFILE_SPEC appropriate for Linux.  Here we tack on
+   the Linux magical crtend.o file (see crtstuff.c) which
+   provides part of the support for getting C++ file-scope static
+   object constructed before entering `main', followed by a normal
+   Linux "finalizer" file, `crtn.o'.  */
+
+#undef	ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s"
diff --git a/config/svr4.h b/config/svr4.h
index 7db294c..7377944 100644
--- a/config/svr4.h
+++ b/config/svr4.h
@@ -1,8 +1,7 @@
-/* svr4.h  --  operating system specific defines to be used when
-   targeting GCC for some generic System V Release 4 system.
-   Copyright (C) 1991 Free Software Foundation, Inc.
-
-   Written by Ron Guilmette (rfg@ncd.com).
+/* Operating system specific defines to be used when targeting GCC for some
+   generic System V Release 4 system.
+   Copyright (C) 1991, 1994, 1995 Free Software Foundation, Inc.
+   Contributed by Ron Guilmette (rfg@segfault.us.com).
 
 This file is part of GNU CC.
 
@@ -18,7 +17,8 @@ GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with GNU CC; see the file COPYING.  If not, write to
-the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
 
    To use this file, make up a file with a name like:
 
@@ -39,11 +39,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
    appropriate define for the type of hardware that you are targeting.
 */
 
-/* Define a symbol so that libgcc* can know what sort of operating
-   environment and assembler syntax we are targeting for.  */
-#ifndef SVR4
-#define SVR4
-#endif
+/* Define a symbol indicating that we are using svr4.h.  */
+#define USING_SVR4_H
 
 /* For the sake of libgcc2.c, indicate target supports atexit.  */
 #define HAVE_ATEXIT
@@ -68,12 +65,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
    || (CHAR) == 'h' \
    || (CHAR) == 'z')
 
-/* This defines which multi-letter switches take arguments.  On svr4,
-   there are no such switches except those implemented by GCC itself.  */
-
-#define WORD_SWITCH_TAKES_ARG(STR)			\
- (!strcmp (STR, "include") || !strcmp (STR, "imacros"))
-
 /* You should redefine CPP_PREDEFINES in any file which includes this one.
    The definition should be appropriate for the type of target system
    involved, and it should include any -A (assertion) options which are
@@ -111,24 +102,38 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 #undef ASM_FINAL_SPEC
 #define ASM_FINAL_SPEC "%{pipe:-}"
 
+/* Under svr4, the normal location of the `ld' and `as' programs is the
+   /usr/ccs/bin directory.  */
+
+#undef MD_EXEC_PREFIX
+#define MD_EXEC_PREFIX "/usr/ccs/bin/"
+
 /* Under svr4, the normal location of the various *crt*.o files is the
    /usr/ccs/lib directory.  */
 
 #undef MD_STARTFILE_PREFIX
 #define MD_STARTFILE_PREFIX "/usr/ccs/lib/"
 
-/* Provide a LIB_SPEC appropropriate for svr4.  Here we tack on the default
-   standard C library (unless we are building a shared library) followed by
-   our own magical crtend.o file (see crtstuff.c) which provides part of
-   the support for getting C++ file-scope static object constructed before
+/* Provide a LIB_SPEC appropriate for svr4.  Here we tack on the default
+   standard C library (unless we are building a shared library).  */
+
+#undef	LIB_SPEC
+#define LIB_SPEC "%{!shared:%{!symbolic:-lc}}"
+
+/* Provide a LIBGCC_SPEC appropriate for svr4.  We also want to exclude
+   libgcc when -symbolic.  */
+
+#undef  LIBGCC_SPEC
+#define LIBGCC_SPEC "%{!shared:%{!symbolic:-lgcc}}"
+
+/* Provide an ENDFILE_SPEC appropriate for svr4.  Here we tack on our own
+   magical crtend.o file (see crtstuff.c) which provides part of the
+   support for getting C++ file-scope static object constructed before
    entering `main', followed by the normal svr3/svr4 "finalizer" file,
    which is either `gcrtn.o' or `crtn.o'.  */
 
-#undef	LIB_SPEC
-#define LIB_SPEC \
-  "%{!shared:%{!symbolic:-lc}} \
-  crtend.o%s \
-  %{!shared:%{!symbolic:%{pg:gcrtn.o}%{!pg:crtn.o%s}}}"
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "crtend.o%s %{pg:gcrtn.o}%{!pg:crtn.o%s}"
 
 /* Provide a LINK_SPEC appropriate for svr4.  Here we provide support
    for the special GCC options -static, -shared, and -symbolic which
@@ -154,11 +159,12 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
    not being done.  */
 
 #undef	LINK_SPEC
-#define LINK_SPEC "%{z*} %{h*} %{V} %{v:%{!V:-V}} \
-		   %{b} %{t} %{Wl,*:%*} \
+#define LINK_SPEC "%{h*} %{V} %{v:%{!V:-V}} \
+		   %{b} %{Wl,*:%*} \
 		   %{static:-dn -Bstatic} \
-		   %{shared:-G -dy} \
-		   %{symbolic:-Bsymbolic -G -dy} \
+		   %{shared:-G -dy -z text %{!h*:%{o*:-h %*}}} \
+		   %{symbolic:-Bsymbolic -G -dy -z text %{!h*:%{o*:-h %*}}} \
+		   %{G:-G} \
 		   %{YP,*} \
 		   %{!YP,*:%{p:-Y P,/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \
 		    %{!p:-Y P,/usr/ccs/lib:/usr/lib}} \
@@ -173,28 +179,31 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
    The SVR4 library routines query the value of `_lib_version' at run
    to decide how they should behave.  Specifically, they decide (based
    upon the value of `_lib_version') if they will act in a strictly ANSI
-   conformant manner or not.
+   conforming manner or not.
 */
 
 #undef	STARTFILE_SPEC
 #define STARTFILE_SPEC "%{!shared: \
 			 %{!symbolic: \
-			  %{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}} \
-			  %{pg:gcrti.o%s}%{!pg:crti.o%s} \
-			  %{ansi:values-Xc.o%s} \
-			  %{!ansi: \
-			   %{traditional:values-Xt.o%s} \
-			   %{!traditional:values-Xa.o%s}}}} crtbegin.o%s"
-
-/* Attach a sepcial .ident directive to the end of the file to identify
+			  %{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}}}}\
+			%{pg:gcrti.o%s}%{!pg:crti.o%s} \
+			%{ansi:values-Xc.o%s} \
+			%{!ansi: \
+			 %{traditional:values-Xt.o%s} \
+			 %{!traditional:values-Xa.o%s}} \
+ 			crtbegin.o%s"
+
+/* Attach a special .ident directive to the end of the file to identify
    the version of GCC which compiled this code.  The format of the
-   .ident string is patterened after the ones produced by native svr4
+   .ident string is patterned after the ones produced by native svr4
    C compilers.  */
 
+#define IDENT_ASM_OP ".ident"
+
 #define ASM_FILE_END(FILE)					\
 do {				 				\
-     fprintf ((FILE), "\t.ident\t\"GCC: (GNU) %s\"\n",		\
-	      version_string);					\
+     fprintf ((FILE), "\t%s\t\"GCC: (GNU) %s\"\n",		\
+	      IDENT_ASM_OP, version_string);			\
    } while (0)
 
 /* Allow #sccs in preprocessor.  */
@@ -204,7 +213,7 @@ do {				 				\
 /* Output #ident as a .ident.  */
 
 #define ASM_OUTPUT_IDENT(FILE, NAME) \
-  fprintf (FILE, "\t.ident \"%s\"\n", NAME);
+  fprintf (FILE, "\t%s\t\"%s\"\n", IDENT_ASM_OP, NAME);
 
 /* Use periods rather than dollar signs in special g++ assembler names.  */
 
@@ -218,6 +227,10 @@ do {				 				\
 
 #define TARGET_MEM_FUNCTIONS
 
+/* Handle #pragma weak and #pragma pack.  */
+
+#define HANDLE_SYSV_PRAGMA
+
 /* System V Release 4 uses DWARF debugging info.  */
 
 #define DWARF_DEBUGGING_INFO
@@ -233,6 +246,59 @@ do {				 				\
 
 #undef DBX_REGISTER_NUMBER
 
+/* gas on SVR4 supports the use of .stabs.  Permit -gstabs to be used
+   in general, although it will only work when using gas.  */
+
+#define DBX_DEBUGGING_INFO
+
+/* Use DWARF debugging info by default.  */
+
+#ifndef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG
+#endif
+
+/* Make LBRAC and RBRAC addresses relative to the start of the
+   function.  The native Solaris stabs debugging format works this
+   way, gdb expects it, and it reduces the number of relocation
+   entries.  */
+
+#define DBX_BLOCKS_FUNCTION_RELATIVE 1
+
+/* When using stabs, gcc2_compiled must be a stabs entry, not an
+   ordinary symbol, or gdb won't see it.  Furthermore, since gdb reads
+   the input piecemeal, starting with each N_SO, it's a lot easier if
+   the gcc2 flag symbol is *after* the N_SO rather than before it.  So
+   we emit an N_OPT stab there.  */
+
+#define ASM_IDENTIFY_GCC(FILE)						\
+do									\
+  {									\
+    if (write_symbols != DBX_DEBUG)					\
+      fputs ("gcc2_compiled.:\n", FILE);				\
+  }									\
+while (0)
+
+#define ASM_IDENTIFY_GCC_AFTER_SOURCE(FILE)				\
+do									\
+  {									\
+    if (write_symbols == DBX_DEBUG)					\
+      fputs ("\t.stabs\t\"gcc2_compiled.\", 0x3c, 0, 0, 0\n", FILE);	\
+  }									\
+while (0)
+
+/* In order for relative line numbers to work, we must output the
+   stabs entry for the function name first.  */
+
+#define DBX_FUNCTION_FIRST
+
+/* Generate a blank trailing N_SO to mark the end of the .o file, since
+   we can't depend upon the linker to mark .o file boundaries with
+   embedded stabs.  */
+
+#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)			\
+  fprintf (FILE,							\
+	   "\t.text\n\t.stabs \"\",%d,0,0,.Letext\n.Letext:\n", N_SO)
+
 /* Define the actual types of some ANSI-mandated types.  (These
    definitions should work for most SVR4 systems).  */
 
@@ -248,8 +314,15 @@ do {				 				\
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE BITS_PER_WORD
 
+/* This causes trouble, because it requires the host machine
+   to support ANSI C.  */
+/* #define MULTIBYTE_CHARS */
+
 #undef ASM_BYTE_OP
-#define ASM_BYTE_OP	"\t.byte"
+#define ASM_BYTE_OP	".byte"
+
+#undef SET_ASM_OP
+#define SET_ASM_OP	".set"
 
 /* This is how to begin an assembly language file.  Most svr4 assemblers want
    at least a .file directive to come first, and some want to see a .version
@@ -265,8 +338,11 @@ do {				 				\
 /* This is how to allocate empty space in some section.  The .zero
    pseudo-op is used for this on most svr4 assemblers.  */
 
+#define SKIP_ASM_OP	".zero"
+
 #undef ASM_OUTPUT_SKIP
-#define ASM_OUTPUT_SKIP(FILE,SIZE) fprintf (FILE, "\t.zero\t%u\n", (SIZE))
+#define ASM_OUTPUT_SKIP(FILE,SIZE) \
+  fprintf (FILE, "\t%s\t%u\n", SKIP_ASM_OP, (SIZE))
 
 /* This is how to output a reference to a user-level label named NAME.
    `assemble_name' uses this.
@@ -277,6 +353,54 @@ do {				 				\
 #undef ASM_OUTPUT_LABELREF
 #define ASM_OUTPUT_LABELREF(FILE,NAME) fprintf (FILE, "%s", NAME)
 
+/* This is how to output an internal numbered label where
+   PREFIX is the class of label and NUM is the number within the class.
+
+   For most svr4 systems, the convention is that any symbol which begins
+   with a period is not put into the linker symbol table by the assembler.  */
+
+#undef ASM_OUTPUT_INTERNAL_LABEL
+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)			\
+do {									\
+  fprintf (FILE, ".%s%d:\n", PREFIX, NUM);				\
+} while (0)
+
+/* This is how to store into the string LABEL
+   the symbol_ref name of an internal numbered label where
+   PREFIX is the class of label and NUM is the number within the class.
+   This is suitable for output with `assemble_name'.
+
+   For most svr4 systems, the convention is that any symbol which begins
+   with a period is not put into the linker symbol table by the assembler.  */
+
+#undef ASM_GENERATE_INTERNAL_LABEL
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)			\
+do {									\
+  sprintf (LABEL, "*.%s%d", PREFIX, NUM);				\
+} while (0)
+
+/* Output the label which precedes a jumptable.  Note that for all svr4
+   systems where we actually generate jumptables (which is to say every
+   svr4 target except i386, where we use casesi instead) we put the jump-
+   tables into the .rodata section and since other stuff could have been
+   put into the .rodata section prior to any given jumptable, we have to
+   make sure that the location counter for the .rodata section gets pro-
+   perly re-aligned prior to the actual beginning of the jump table.  */
+
+#define ALIGN_ASM_OP ".align"
+
+#ifndef ASM_OUTPUT_BEFORE_CASE_LABEL
+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \
+  ASM_OUTPUT_ALIGN ((FILE), 2);
+#endif
+
+#undef ASM_OUTPUT_CASE_LABEL
+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,JUMPTABLE)		\
+  do {									\
+    ASM_OUTPUT_BEFORE_CASE_LABEL (FILE, PREFIX, NUM, JUMPTABLE)		\
+    ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);			\
+  } while (0)
+
 /* The standard SVR4 assembler seems to require that certain builtin
    library routines (e.g. .udiv) be explicitly declared as .globl
    in each assembly file where they are referenced.  */
@@ -289,10 +413,12 @@ do {				 				\
    the linker seems to want the alignment of data objects
    to depend on their types.  We do exactly that here.  */
 
+#define COMMON_ASM_OP	".comm"
+
 #undef ASM_OUTPUT_ALIGNED_COMMON
 #define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)		\
 do {									\
-  fputs ("\t.comm\t", (FILE));						\
+  fprintf ((FILE), "\t%s\t", COMMON_ASM_OP);				\
   assemble_name ((FILE), (NAME));					\
   fprintf ((FILE), ",%u,%u\n", (SIZE), (ALIGN) / BITS_PER_UNIT);	\
 } while (0)
@@ -302,20 +428,22 @@ do {									\
    the linker seems to want the alignment of data objects
    to depend on their types.  We do exactly that here.  */
 
-#define BSS_ASM_OP	"\t.bss"
+#define LOCAL_ASM_OP	".local"
 
 #undef ASM_OUTPUT_ALIGNED_LOCAL
 #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
 do {									\
-  fprintf ((FILE), "%s\t%s,%u,%u\n",					\
-	   BSS_ASM_OP, (NAME), (SIZE), (ALIGN) / BITS_PER_UNIT);	\
+  fprintf ((FILE), "\t%s\t", LOCAL_ASM_OP);				\
+  assemble_name ((FILE), (NAME));					\
+  fprintf ((FILE), "\n");						\
+  ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);			\
 } while (0)
 
 /* This is the pseudo-op used to generate a 32-bit word of data with a
    specific value in some section.  This is the same for all known svr4
    assemblers.  */
 
-#define INT_ASM_OP		"\t.long\t"
+#define INT_ASM_OP		".long"
 
 /* This is the pseudo-op used to generate a contiguous sequence of byte
    values from a double-quoted string WITHOUT HAVING A TERMINATING NUL
@@ -334,17 +462,34 @@ do {									\
 
 #define USE_CONST_SECTION	1
 
-#define CONST_SECTION_ASM_OP	"\t.section\t.rodata"
-#define CTORS_SECTION_ASM_OP	"\t.section\t.ctors,\"a\",@progbits\n"
-#define DTORS_SECTION_ASM_OP	"\t.section\t.dtors,\"a\",@progbits\n"
+#define CONST_SECTION_ASM_OP	".section\t.rodata"
+
+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.
+
+   Note that we want to give these sections the SHF_WRITE attribute
+   because these sections will actually contain data (i.e. tables of
+   addresses of functions in the current root executable or shared library
+   file) and, in the case of a shared library, the relocatable addresses
+   will have to be properly resolved/relocated (and then written into) by
+   the dynamic linker when it actually attaches the given shared library
+   to the executing process.  (Note that on SVR4, you may wish to use the
+   `-z text' option to the ELF linker, when building a shared library, as
+   an additional check that you are doing everything right.  But if you do
+   use the `-z text' option when building a shared library, you will get
+   errors unless the .ctors and .dtors sections are marked as writable
+   via the SHF_WRITE attribute.)  */
+
+#define CTORS_SECTION_ASM_OP	".section\t.ctors,\"aw\""
+#define DTORS_SECTION_ASM_OP	".section\t.dtors,\"aw\""
 
-/* On svr4, we *do* have support for the .init section, and we can put
-   stuff in there to be executed before `main'.  We let crtstuff.c and
-   other files know this by defining the following symbol.  The definition
-   says how to change sections to the .init section.  This is the same
-   for all know svr4 assemblers.  */
+/* On svr4, we *do* have support for the .init and .fini sections, and we
+   can put stuff in there to be executed before and after `main'.  We let
+   crtstuff.c and other files know this by defining the following symbols.
+   The definitions say how to change sections to the .init and .fini
+   sections.  This is the same for all known svr4 assemblers.  */
 
-#define INIT_SECTION_ASM_OP	"\t.section\t.init"
+#define INIT_SECTION_ASM_OP	".section\t.init"
+#define FINI_SECTION_ASM_OP	".section\t.fini"
 
 /* A default list of other sections which we might be "in" at any given
    time.  For targets that use additional sections (e.g. .tdesc) you
@@ -366,7 +511,7 @@ do {									\
 
 #define READONLY_DATA_SECTION() const_section ()
 
-extern void text_section();
+extern void text_section ();
 
 #define CONST_SECTION_FUNCTION						\
 void									\
@@ -387,7 +532,7 @@ ctors_section ()							\
 {									\
   if (in_section != in_ctors)						\
     {									\
-      fprintf (asm_out_file, CTORS_SECTION_ASM_OP);			\
+      fprintf (asm_out_file, "%s\n", CTORS_SECTION_ASM_OP);		\
       in_section = in_ctors;						\
     }									\
 }
@@ -398,7 +543,7 @@ dtors_section ()							\
 {									\
   if (in_section != in_dtors)						\
     {									\
-      fprintf (asm_out_file, DTORS_SECTION_ASM_OP);			\
+      fprintf (asm_out_file, "%s\n", DTORS_SECTION_ASM_OP);		\
       in_section = in_dtors;						\
     }									\
 }
@@ -408,7 +553,7 @@ dtors_section ()							\
 #define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)				\
   do {									\
     ctors_section ();							\
-    fprintf (FILE, "%s\t ", INT_ASM_OP);				\
+    fprintf (FILE, "\t%s\t ", INT_ASM_OP);				\
     assemble_name (FILE, NAME);						\
     fprintf (FILE, "\n");						\
   } while (0)
@@ -418,7 +563,7 @@ dtors_section ()							\
 #define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       				\
   do {									\
     dtors_section ();                   				\
-    fprintf (FILE, "%s\t ", INT_ASM_OP);				\
+    fprintf (FILE, "\t%s\t ", INT_ASM_OP);				\
     assemble_name (FILE, NAME);              				\
     fprintf (FILE, "\n");						\
   } while (0)
@@ -440,7 +585,10 @@ dtors_section ()							\
   else if (TREE_CODE (DECL) == VAR_DECL)				\
     {									\
       if ((flag_pic && RELOC)						\
-	  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL))		\
+	  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)		\
+	  || !DECL_INITIAL (DECL)					\
+	  || (DECL_INITIAL (DECL) != error_mark_node			\
+	      && !TREE_CONSTANT (DECL_INITIAL (DECL))))			\
 	data_section ();						\
       else								\
 	const_section ();						\
@@ -464,8 +612,14 @@ dtors_section ()							\
    different pseudo-op names for these, they may be overridden in the
    file which includes this one.  */
 
-#define TYPE_ASM_OP	"\t.type"
-#define SIZE_ASM_OP	"\t.size"
+#define TYPE_ASM_OP	".type"
+#define SIZE_ASM_OP	".size"
+
+/* This is how we tell the assembler that a symbol is weak.  */
+
+#define ASM_WEAKEN_LABEL(FILE,NAME) \
+  do { fputs ("\t.weak\t", FILE); assemble_name (FILE, NAME); \
+       fputc ('\n', FILE); } while (0)
 
 /* The following macro defines the format used to output the second
    operand of the .type assembler directive.  Different svr4 assemblers
@@ -475,37 +629,31 @@ dtors_section ()							\
 
 #define TYPE_OPERAND_FMT	"@%s"
 
+/* Write the extra assembler code needed to declare a function's result.
+   Most svr4 assemblers don't require any special declaration of the
+   result value, but there are exceptions.  */
+
+#ifndef ASM_DECLARE_RESULT
+#define ASM_DECLARE_RESULT(FILE, RESULT)
+#endif
+
 /* These macros generate the special .type and .size directives which
    are used to set the corresponding fields of the linker symbol table
-   entries in an ELF object file under SVR4.  */
+   entries in an ELF object file under SVR4.  These macros also output
+   the starting labels for the relevant functions/objects.  */
 
-/* Write the extra assembler code needed to declare a function properly.  */
+/* Write the extra assembler code needed to declare a function properly.
+   Some svr4 assemblers need to also have something extra said about the
+   function's return value.  We allow for that here.  */
 
 #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)			\
   do {									\
-    fprintf (FILE, "%s\t ", TYPE_ASM_OP);				\
+    fprintf (FILE, "\t%s\t ", TYPE_ASM_OP);				\
     assemble_name (FILE, NAME);						\
     putc (',', FILE);							\
     fprintf (FILE, TYPE_OPERAND_FMT, "function");			\
     putc ('\n', FILE);							\
-    ASM_OUTPUT_LABEL(FILE, NAME);					\
-  } while (0)
-
-/* Write the extra assembler code needed to declare an object properly.  */
-
-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)			\
-  do {									\
-    fprintf (FILE, "%s\t ", TYPE_ASM_OP);				\
-    assemble_name (FILE, NAME);						\
-    putc (',', FILE);							\
-    fprintf (FILE, TYPE_OPERAND_FMT, "object");				\
-    putc ('\n', FILE);							\
-    if (!flag_inhibit_size_directive)					\
-      {									\
-	fprintf (FILE, "%s\t ", SIZE_ASM_OP);				\
-	assemble_name (FILE, NAME);					\
-	fprintf (FILE, ",%d\n",  int_size_in_bytes (TREE_TYPE (decl)));	\
-      }									\
+    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));			\
     ASM_OUTPUT_LABEL(FILE, NAME);					\
   } while (0)
 
@@ -520,12 +668,12 @@ dtors_section ()							\
 	labelno++;							\
 	ASM_GENERATE_INTERNAL_LABEL (label, "Lfe", labelno);		\
 	ASM_OUTPUT_INTERNAL_LABEL (FILE, "Lfe", labelno);		\
-	fprintf (FILE, "%s\t ", SIZE_ASM_OP);				\
+	fprintf (FILE, "\t%s\t ", SIZE_ASM_OP);				\
 	assemble_name (FILE, (FNAME));					\
         fprintf (FILE, ",");						\
 	assemble_name (FILE, label);					\
         fprintf (FILE, "-");						\
-	ASM_OUTPUT_LABELREF (FILE, (FNAME));				\
+	assemble_name (FILE, (FNAME));					\
 	putc ('\n', FILE);						\
       }									\
   } while (0)
@@ -541,10 +689,11 @@ dtors_section ()							\
    in the table.  Note that we can use standard UN*X escape
    sequences for many control characters, but we don't use
    \a to represent BEL because some svr4 assemblers (e.g. on
-   the i386) don't know about that.   */
+   the i386) don't know about that.  Also, we don't use \v
+   since some versions of gas, such as 2.2 did not accept it.  */
 
 #define ESCAPES \
-"\1\1\1\1\1\1\1\1btnvfr\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+"\1\1\1\1\1\1\1\1btn\1fr\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
 \0\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\0\0\
 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\
@@ -558,7 +707,7 @@ dtors_section ()							\
    has such a limitation, you should define STRING_LIMIT to reflect that
    limit.  Note that at least some svr4 assemblers have a limit on the
    actual number of bytes in the double-quoted string, and that they
-   count each chanacter in an escape sequence as one byte.  Thus, an
+   count each character in an escape sequence as one byte.  Thus, an
    escape sequence like \377 would count as four bytes.
 
    If your target assembler doesn't support the .string directive, you
@@ -665,3 +814,6 @@ dtors_section ()							\
         fprintf ((FILE), "\"\n");					\
     }									\
   while (0)
+
+/* All SVR4 targets use the ELF object file format.  */
+#define OBJECT_FORMAT_ELF
diff --git a/config/t-linux b/config/t-linux
new file mode 100644
index 0000000..843fa1b
--- /dev/null
+++ b/config/t-linux
@@ -0,0 +1,10 @@
+# Don't run fixproto
+STMP_FIXPROTO =
+
+# Don't install "assert.h" in gcc. We use the one in glibc.
+INSTALL_ASSERT_H =
+
+# Compile crtbeginS.o and crtendS.o with pic.
+CRTSTUFF_T_CFLAGS_S = -fPIC
+# Compile libgcc2.a with pic.
+TARGET_LIBGCC2_CFLAGS = -fPIC
diff --git a/config/unx386.h b/config/unx386.h
index 6f517e5..7209176 100644
--- a/config/unx386.h
+++ b/config/unx386.h
@@ -38,10 +38,16 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #define AS3(a,b,c,d) "a b,c,d"
 #endif  
 
+/* Define macro used to output shift-double opcodes when the shift
+   count is in %cl.  Some assemblers require %cl as an argument;
+   some don't.  This macro controls what to do: by default, don't
+   print %cl.  */
+#define AS3_SHIFT_DOUBLE(a,b,c,d) AS2 (a,c,d)
+
 /* Output the size-letter for an opcode.
    CODE is the letter used in an operand spec (L, B, W, S or Q).
    CH is the corresponding lower case letter
-     (except if CODE is L then CH is `l').  */
+     (except if CODE is `Q' then CH is `l', unless GAS_MNEMONICS).  */
 #define PUT_OP_SIZE(CODE,CH,FILE) putc (CH,(FILE))
 
 /* Opcode suffix for fullword insn.  */
@@ -119,3 +125,21 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 #define ASM_GLOBALIZE_LABEL(FILE,NAME)	\
   (fputs (".globl ", FILE), assemble_name (FILE, NAME), fputs ("\n", FILE))
+
+/* By default, target has a 80387, uses IEEE compatible arithmetic,
+   and returns float values in the 387, ie,
+   (TARGET_80387 | TARGET_IEEE_FP | TARGET_FLOAT_RETURNS_IN_80387) */
+
+#define TARGET_DEFAULT 0301
+
+/* Floating-point return values come in the FP register.  */
+
+#define VALUE_REGNO(MODE) \
+  (GET_MODE_CLASS (MODE) == MODE_FLOAT				\
+   && TARGET_FLOAT_RETURNS_IN_80387 ? FIRST_FLOAT_REG : 0)
+
+/* 1 if N is a possible register number for a function value. */
+
+#define FUNCTION_VALUE_REGNO_P(N) \
+  ((N) == 0 || ((N)== FIRST_FLOAT_REG && TARGET_FLOAT_RETURNS_IN_80387))
+
diff --git a/config/x-linux b/config/x-linux
new file mode 100644
index 0000000..db1539e
--- /dev/null
+++ b/config/x-linux
@@ -0,0 +1,3 @@
+X_CFLAGS=-DPOSIX
+# we are native.
+prefix=/usr
diff --git a/config/xm-i386.h b/config/xm-i386.h
index b617d9b..eb90681 100644
--- a/config/xm-i386.h
+++ b/config/xm-i386.h
@@ -38,6 +38,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 /* If compiled with GNU C, use the built-in alloca */
 #ifdef __GNUC__
+#undef alloca
 #define alloca __builtin_alloca
 #endif
 
diff --git a/config/xm-i386linux.h b/config/xm-i386linux.h
new file mode 100644
index 0000000..5b7f67f
--- /dev/null
+++ b/config/xm-i386linux.h
@@ -0,0 +1,23 @@
+/* Configuration for GCC for Intel i386 running Linux.
+   Copyright (C) 1995 Free Software Foundation, Inc.
+   Contributed by H.J. Lu (hjl@nynexst.com)
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include "xm-i386.h"
+#include "xm-linux.h"
diff --git a/config/xm-linux.h b/config/xm-linux.h
new file mode 100644
index 0000000..168fe9d
--- /dev/null
+++ b/config/xm-linux.h
@@ -0,0 +1,21 @@
+#define HAVE_VPRINTF
+
+#define HAVE_STRERROR
+
+#ifndef POSIX
+#define POSIX
+#endif
+
+#define DONT_DECLARE_SYS_SIGLIST
+
+/* We do have one, but I'd like to use the one come with gcc since
+   we have been doing that for a long time with USG defined.  H.J. */
+#define NO_STAB_H
+
+#undef BSTRING
+#define BSTRING
+#undef bcmp
+#undef bcopy
+#undef bzero
+#undef index
+#undef rindex
diff --git a/configure b/configure
index 25660fd..71c2c73 100755
--- a/configure
+++ b/configure
@@ -174,6 +174,8 @@ for machine in $host $target; do
 	tm_file=
 	xmake_file=
 	tmake_file=
+	extra_parts=
+	target_cpu_default=
 
 	case $machine in
 	# Support site-specific machine types.
@@ -246,6 +248,24 @@ for machine in $host $target; do
 		xm_file=xm-i386sun.h
 		tm_file=i386sun.h
 		;;
+	i[3456]86-*-linux*aout)         # Intel 80386's running Linux
+		cpu_type=i386
+		xm_file=xm-i386linux.h
+		xmake_file=x-linux
+		tm_file=i386linux-aout.h
+		fixincludes=Makefile.in
+		broken_install=yes
+		;;
+	i[3456]86-*-linux*)             # Intel 80386's running Linux
+		cpu_type=i386           # with ELF support
+		xm_file=xm-i386linux.h
+		xmake_file=x-linux
+		tm_file=i386linux.h
+		tmake_file=t-linux
+		fixincludes=Makefile.in
+		broken_install=yes
+		extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
+		;;
 	i386-*-sysv4*)			# Intel 80386's running system V.4
 		xm_file=xm-i38v4.h
 		xmake_file=x-i386v4
@@ -606,6 +626,13 @@ for machine in $host $target; do
 		;;
 	esac
 
+	# Distinguish i386 from i486.
+	case $machine in
+	i486-*-*)
+		target_cpu_default=2
+		;;
+	esac
+
 # Default certain vars that apply to both host and target in turn.
 	if [ x$cpu_type = x ]
 	then cpu_type=`echo $machine | sed 's/-.*$//'`
@@ -724,6 +751,29 @@ else
 	mv Makefile.xx Makefile.tem
 fi
 
+# Set EXTRA_PARTS according to extra_parts.
+# This substitutes for lots of t-* files.
+if [ "x$extra_parts" = x ]
+then true
+else
+	rm -f Makefile.xx
+	sed "s/^EXTRA_PARTS =/EXTRA_PARTS = $extra_parts/" Makefile.tem > Makefile.xx
+	rm -f Makefile.tem
+	mv Makefile.xx Makefile.tem
+fi
+
+# Add -DTARGET_CPU_DEFAULT for toplev.c if system wants one.
+# This substitutes for lots of *.h files.
+if [ x$target_cpu_default = x ]
+then true
+else
+	rm -f Makefile.xx
+	(echo "MAYBE_TARGET_DEFAULT = -DTARGET_CPU_DEFAULT=$target_cpu_default")\
+ 	   | cat - Makefile.tem > Makefile.xx
+	rm -f Makefile.tem
+	mv Makefile.xx Makefile.tem
+fi
+
 # Conditionalize the makefile for this target machine.
 if [ -f ${srcdir}/config/${tmake_file} ]
 then
diff --git a/crtstuff.c b/crtstuff.c
index c72c391..0a30340 100644
--- a/crtstuff.c
+++ b/crtstuff.c
@@ -1,9 +1,9 @@
 /* Specialized bits of code needed to support construction and
    destruction of file-scope objects in C++ code.
 
-   Written by Ron Guilmette (rfg@ncd.com) with help from Richard Stallman.
+   Written by Ron Guilmette (rfg@netcom.com) with help from Richard Stallman.
 
-Copyright (C) 1991 Free Software Foundation, Inc.
+Copyright (C) 1991, 1994, 1995 Free Software Foundation, Inc.
 
 This file is part of GNU CC.
 
@@ -19,7 +19,8 @@ GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with GNU CC; see the file COPYING.  If not, write to
-the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
 
 /* As a special exception, if you link this library with files
    compiled with GCC to produce an executable, this does not cause
@@ -41,8 +42,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
    this file *will* make use of the .init section.  If that symbol is
    not defined however, then the .init section will not be used.
 
-   Currently, only ELF is actually supported.
-   The other formats probably need just alternative macro definitions.
+   Currently, only ELF and COFF are supported.  It is likely however that
+   ROSE could also be supported, if someone was willing to do the work to
+   make whatever (small?) adaptations are needed.  (Some work may be
+   needed on the ROSE assembler and linker also.)
 
    This file must be compiled with gcc.  */
 
@@ -52,52 +55,200 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 #include "tm.h"
 
+/* Provide default definitions for the pseudo-ops used to switch to the
+   .ctors and .dtors sections.
+ 
+   Note that we want to give these sections the SHF_WRITE attribute
+   because these sections will actually contain data (i.e. tables of
+   addresses of functions in the current root executable or shared library
+   file) and, in the case of a shared library, the relocatable addresses
+   will have to be properly resolved/relocated (and then written into) by
+   the dynamic linker when it actually attaches the given shared library
+   to the executing process.  (Note that on SVR4, you may wish to use the
+   `-z text' option to the ELF linker, when building a shared library, as
+   an additional check that you are doing everything right.  But if you do
+   use the `-z text' option when building a shared library, you will get
+   errors unless the .ctors and .dtors sections are marked as writable
+   via the SHF_WRITE attribute.)  */
+
 #ifndef CTORS_SECTION_ASM_OP
-#define CTORS_SECTION_ASM_OP	"\t.section\t.ctors,\"a\",@progbits"
+#define CTORS_SECTION_ASM_OP	".section\t.ctors,\"aw\""
 #endif
 #ifndef DTORS_SECTION_ASM_OP
-#define DTORS_SECTION_ASM_OP	"\t.section\t.dtors,\"a\",@progbits"
+#define DTORS_SECTION_ASM_OP	".section\t.dtors,\"aw\""
 #endif
 
+#ifdef OBJECT_FORMAT_ELF
+
+/*  Declare a pointer to void function type.  */
+typedef void (*func_ptr) (void);
+#define STATIC static
+
+#else  /* OBJECT_FORMAT_ELF */
+
 #include "gbl-ctors.h"
 
-#ifndef ON_EXIT /* DO_GLOBAL_CTORS_BODY uses ON_EXIT */
+#ifndef ON_EXIT
 #define ON_EXIT(a, b)
 #endif
+#define STATIC
+
+#endif /* OBJECT_FORMAT_ELF */
 
 #ifdef CRT_BEGIN
 
 #ifdef INIT_SECTION_ASM_OP
 
-/* Force cc1 to switch to .text section.  */
-static void force_to_text () { }
+#ifdef OBJECT_FORMAT_ELF
+
+/* Declare the __dso_handle variable.  It should have a unique value
+   in every shared-object; in a main program its value is zero.  The
+   object should in any case be protected.  This means the instance
+   in one DSO or the main program is not used in another object.  The
+   dynamic linker takes care of this.  */
+
+/* XXX Ideally the following should be implemented using
+   __attribute__ ((__visibility__ ("hidden")))
+   but the __attribute__ support is not yet there.  */
+#define HAVE_GAS_HIDDEN 1
+#ifdef HAVE_GAS_HIDDEN
+asm (".hidden\t__dso_handle");
+#endif
+
+#ifdef CRTSTUFFS_O
+void *__dso_handle = &__dso_handle;
+#else
+void *__dso_handle = 0;
+#endif
+
+/* The __cxa_finalize function may not be available so we use only a
+   weak declaration.  */
+extern void __cxa_finalize (void *);
+
+/* Run all the global destructors on exit from the program.  */
+/* Run all the global destructors on exit from the program.  */
+ 
+/* Some systems place the number of pointers in the first word of the
+   table.  On SVR4 however, that word is -1.  In all cases, the table is
+   null-terminated.  On SVR4, we start from the beginning of the list and
+   invoke each per-compilation-unit destructor routine in order
+   until we find that null.
+
+   Note that this function MUST be static.  There will be one of these
+   functions in each root executable and one in each shared library, but
+   although they all have the same code, each one is unique in that it
+   refers to one particular associated `__DTOR_LIST__' which belongs to the
+   same particular root executable or shared library file.  */
+
+static func_ptr __DTOR_LIST__[1];
+static void
+__do_global_dtors_aux ()
+{
+  func_ptr *p;
+
+#ifdef CRTSTUFFS_O
+  if (__cxa_finalize)
+    __cxa_finalize (__dso_handle);
+#endif
+
+  for (p = __DTOR_LIST__ + 1; *p; p++)
+    (*p) ();
+}
+
+/* Stick a call to __do_global_dtors_aux into the .fini section.  */
+static void
+fini_dummy ()
+{
+  asm (FINI_SECTION_ASM_OP);
+  __do_global_dtors_aux ();
+#ifdef FORCE_FINI_SECTION_ALIGN
+  FORCE_FINI_SECTION_ALIGN;
+#endif
+  asm (TEXT_SECTION_ASM_OP);
+}
+
+#else  /* OBJECT_FORMAT_ELF */
+
+/* The function __do_global_ctors_aux is compiled twice (once in crtbegin.o
+   and once in crtend.o).  It must be declared static to avoid a link
+   error.  Here, we define __do_global_ctors as an externally callable
+   function.  It is externally callable so that __main can invoke it when
+   INVOKE__main is defined.  This has the additional effect of forcing cc1
+   to switch to the .text section.  */
+static void __do_global_ctors_aux ();
+void __do_global_ctors ()
+{
+#ifdef INVOKE__main  /* If __main won't actually call __do_global_ctors
+			then it doesn't matter what's inside the function.
+			The inside of __do_global_ctors_aux is called
+			automatically in that case.
+			And the Alliant fx2800 linker crashes
+			on this reference.  So prevent the crash.  */
+  __do_global_ctors_aux ();
+#endif
+}
 
 asm (INIT_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
 
+/* On some svr4 systems, the initial .init section preamble code provided in
+   crti.o may do something, such as bump the stack, which we have to 
+   undo before we reach the function prologue code for __do_global_ctors 
+   (directly below).  For such systems, define the macro INIT_SECTION_PREAMBLE
+   to expand into the code needed to undo the actions of the crti.o file. */
+
+#ifdef INIT_SECTION_PREAMBLE
+  INIT_SECTION_PREAMBLE;
+#endif
+
 /* A routine to invoke all of the global constructors upon entry to the
    program.  We put this into the .init section (for systems that have
    such a thing) so that we can properly perform the construction of
    file-scope static-storage C++ objects within shared libraries.   */
 
 static void
-__do_global_ctors ()		/* prologue goes in .init section */
+__do_global_ctors_aux ()	/* prologue goes in .init section */
 {
+#ifdef FORCE_INIT_SECTION_ALIGN
+  FORCE_INIT_SECTION_ALIGN;	/* Explicit align before switch to .text */
+#endif
   asm (TEXT_SECTION_ASM_OP);	/* don't put epilogue and body in .init */
   DO_GLOBAL_CTORS_BODY;
+  ON_EXIT (__do_global_dtors, 0);
 }
 
+#endif /* OBJECT_FORMAT_ELF */
 #endif /* defined(INIT_SECTION_ASM_OP) */
 
 /* Force cc1 to switch to .data section.  */
 static func_ptr force_to_data[0] = { };
 
+/* NOTE:  In order to be able to support SVR4 shared libraries, we arrange
+   to have one set of symbols { __CTOR_LIST__, __DTOR_LIST__, __CTOR_END__,
+   __DTOR_END__ } per root executable and also one set of these symbols
+   per shared library.  So in any given whole process image, we may have
+   multiple definitions of each of these symbols.  In order to prevent
+   these definitions from conflicting with one another, and in order to
+   ensure that the proper lists are used for the initialization/finalization
+   of each individual shared library (respectively), we give these symbols
+   only internal (i.e. `static') linkage, and we also make it a point to
+   refer to only the __CTOR_END__ symbol in crtend.o and the __DTOR_LIST__
+   symbol in crtbegin.o, where they are defined.  */
+
 /* The -1 is a flag to __do_global_[cd]tors
    indicating that this table does not start with a count of elements.  */
+#ifdef CTOR_LIST_BEGIN
+CTOR_LIST_BEGIN;
+#else
 asm (CTORS_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
-func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) };
+STATIC func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) };
+#endif
 
+#ifdef DTOR_LIST_BEGIN
+DTOR_LIST_BEGIN;
+#else
 asm (DTORS_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
-func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) };
+STATIC func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) };
+#endif
 
 #endif /* defined(CRT_BEGIN) */
 
@@ -105,34 +256,100 @@ func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) };
 
 #ifdef INIT_SECTION_ASM_OP
 
-/* A routine to invoke all of the global constructors upon entry to the
-   program.  We put this into the .init section (for systems that have
-   such a thing) so that we can properly perform the construction of
-   file-scope static-storage C++ objects within shared libraries.
+#ifdef OBJECT_FORMAT_ELF
+
+static func_ptr __CTOR_END__[1];
+static void
+__do_global_ctors_aux ()
+{
+  func_ptr *p;
+  for (p = __CTOR_END__ - 1; *p != (func_ptr) -1; p--)
+    (*p) ();
+}
+
+/* Stick a call to __do_global_ctors_aux into the .init section.  */
+static void
+init_dummy ()
+{
+  asm (INIT_SECTION_ASM_OP);
+  __do_global_ctors_aux ();
+#ifdef FORCE_INIT_SECTION_ALIGN
+  FORCE_INIT_SECTION_ALIGN;
+#endif
+  asm (TEXT_SECTION_ASM_OP);
+
+/* This is a kludge. The Linux dynamic linker needs  ___brk_addr, __environ
+   and atexit (). We have to make sure they are in the .dynsym section. We
+   accomplish it by making a dummy call here. This
+   code is never reached. */
+ 
+#if defined(__linux__) && defined(__PIC__)
+  {
+    extern void *___brk_addr;
+    extern char **__environ;
+
+    ___brk_addr = __environ;
+    atexit ();
+  }
+#endif
+}
+
+#else  /* OBJECT_FORMAT_ELF */
 
-   This must be virtually identical to the one above so that we can
-   insure that the function prologue from the one above works correctly
-   with the epilogue from this one.  (They will both go into the .init
-   section as the first and last things (respectively) that the linker
-   will put in that section.)
-*/
+/* Stick the real initialization code, followed by a normal sort of
+   function epilogue at the very end of the .init section for this
+   entire root executable file or for this entire shared library file.
+
+   Note that we use some tricks here to get *just* the body and just
+   a function epilogue (but no function prologue) into the .init
+   section of the crtend.o file.  Specifically, we switch to the .text
+   section, start to define a function, and then we switch to the .init
+   section just before the body code.
+
+   Earlier on, we put the corresponding function prologue into the .init
+   section of the crtbegin.o file (which will be linked in first).
+
+   Note that we want to invoke all constructors for C++ file-scope static-
+   storage objects AFTER any other possible initialization actions which
+   may be performed by the code in the .init section contributions made by
+   other libraries, etc.  That's because those other initializations may
+   include setup operations for very primitive things (e.g. initializing
+   the state of the floating-point coprocessor, etc.) which should be done
+   before we start to execute any of the user's code. */
 
 static void
-__do_global_ctors ()		/* prologue goes in .text section */
+__do_global_ctors_aux ()	/* prologue goes in .text section */
 {
   asm (INIT_SECTION_ASM_OP);
   DO_GLOBAL_CTORS_BODY;
+  ON_EXIT (__do_global_dtors, 0);
 }				/* epilogue and body go in .init section */
 
+#endif /* OBJECT_FORMAT_ELF */
+
 #endif /* defined(INIT_SECTION_ASM_OP) */
 
 /* Force cc1 to switch to .data section.  */
 static func_ptr force_to_data[0] = { };
 
+/* Put a word containing zero at the end of each of our two lists of function
+   addresses.  Note that the words defined here go into the .ctors and .dtors
+   sections of the crtend.o file, and since that file is always linked in
+   last, these words naturally end up at the very ends of the two lists
+   contained in these two sections.  */
+
+#ifdef CTOR_LIST_END
+CTOR_LIST_END;
+#else
 asm (CTORS_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
-func_ptr __CTOR_END__[1] = { (func_ptr) 0 };
+STATIC func_ptr __CTOR_END__[1] = { (func_ptr) 0 };
+#endif
 
+#ifdef DTOR_LIST_END
+DTOR_LIST_END;
+#else
 asm (DTORS_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
-func_ptr __DTOR_END__[1] = { (func_ptr) 0 };
+STATIC func_ptr __DTOR_END__[1] = { (func_ptr) 0 };
+#endif
 
 #endif /* defined(CRT_END) */
diff --git a/dwarfout.c b/dwarfout.c
index 4357629..20f302c 100644
--- a/dwarfout.c
+++ b/dwarfout.c
@@ -48,14 +48,6 @@ extern time_t time ();
 #endif /* !defined(POSIX) */
 #endif /* defined(DWARF_TIMESTAMPS) */
 
-#if defined(USG) || defined(POSIX)
-#include <string.h>
-#else
-#include <strings.h>
-#define strrchr rindex
-#define getcwd(s,len) getwd(s)
-#endif
-
 /* IMPORTANT NOTE: Please see the file README.DWARF for important details
    regarding the GNU implementation of Dwarf.  */
 
diff --git a/emit-rtl.c b/emit-rtl.c
index fd6de5d..1939532 100644
--- a/emit-rtl.c
+++ b/emit-rtl.c
@@ -34,8 +34,12 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
    is the kind of rtx's they make and what arguments they use.  */
 
 #include "config.h"
-#include <stdio.h>
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
+#include <stdio.h>
 #include "rtl.h"
 #include "flags.h"
 #include "function.h"
@@ -231,19 +235,23 @@ void init_emit ();
 
 /*VARARGS2*/
 rtx
-gen_rtx (va_alist)
-     va_dcl
+gen_rtx VPROTO((enum rtx_code code, enum machine_mode mode, ...))
 {
-  va_list p;
+#ifndef __STDC__
   enum rtx_code code;
   enum machine_mode mode;
+#endif
+  va_list p;
   register int i;		/* Array indices...			*/
   register char *fmt;		/* Current rtx's format...		*/
   register rtx rt_val;		/* RTX to return to caller...		*/
 
-  va_start (p);
+  VA_START (p, mode);
+
+#ifndef __STDC__
   code = va_arg (p, enum rtx_code);
   mode = va_arg (p, enum machine_mode);
+#endif
 
   if (code == CONST_INT)
     {
@@ -336,15 +344,20 @@ gen_rtx (va_alist)
 
 /*VARARGS1*/
 rtvec
-gen_rtvec (va_alist)
-     va_dcl
+gen_rtvec VPROTO((int n, ...))
 {
-  int n, i;
+#ifndef __STDC__
+  int n;
+#endif
+  int i;
   va_list p;
   rtx *vector;
 
-  va_start (p);
+  VA_START (p, n);
+
+#ifndef __STDC__
   n = va_arg (p, int);
+#endif
 
   if (n == 0)
     return NULL_RTVEC;		/* Don't allocate an empty rtvec...	*/
diff --git a/expr.c b/expr.c
index 74fb5a2..787fafb 100644
--- a/expr.c
+++ b/expr.c
@@ -29,7 +29,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include "insn-config.h"
 #include "recog.h"
 #include "output.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
 #include "typeclass.h"
 
 #define CEIL(x,y) (((x) + (y) - 1) / (y))
@@ -1659,16 +1663,19 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,
    to the variable is_const in expand_call.  */
 
 void
-emit_library_call (va_alist)
-     va_dcl
+emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,
+                          int nargs, ...))
 {
+#ifndef __STDC__
+  rtx orgfun;
+  int no_queue;
+  enum machine_mode outmode;
+  int nargs;
+#endif
   va_list p;
   struct args_size args_size;
   register int argnum;
-  enum machine_mode outmode;
-  int nargs;
   rtx fun;
-  rtx orgfun;
   int inc;
   int count;
   rtx argblock = 0;
@@ -1677,14 +1684,18 @@ emit_library_call (va_alist)
 	       struct args_size offset; struct args_size size; };
   struct arg *argvec;
   int old_inhibit_defer_pop = inhibit_defer_pop;
-  int no_queue = 0;
   rtx use_insns;
 
-  va_start (p);
-  orgfun = fun = va_arg (p, rtx);
+  VA_START (p, nargs);
+
+#ifndef __STDC__
+  orgfun = va_arg (p, rtx);
   no_queue = va_arg (p, int);
   outmode = va_arg (p, enum machine_mode);
   nargs = va_arg (p, int);
+#endif
+
+  fun = orgfun;
 
   /* Copy all the libcall-arguments out of the varargs data
      and into a vector ARGVEC.
diff --git a/expr.h b/expr.h
index 68c9221..7f65015 100644
--- a/expr.h
+++ b/expr.h
@@ -457,7 +457,8 @@ extern rtx convert_to_mode ();
 /* Emit code to push some arguments and call a library routine,
    storing the value in a specified place.  Calling sequence is
    complicated.  */
-extern void emit_library_call ();
+extern void emit_library_call PVPROTO((rtx orgfun, int no_queue,
+  enum machine_mode outmode, int nargs, ...));
 
 /* Given an rtx that may include add and multiply operations,
    generate them as insns and return a pseudo-reg containing the value.
diff --git a/final.c b/final.c
index 7fbe8ce..cec09e9 100644
--- a/final.c
+++ b/final.c
@@ -43,9 +43,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
    directly as assembler code by the macros FUNCTION_PROLOGUE and
    FUNCTION_EPILOGUE.  Those instructions never exist as rtl.  */
 
-#include <stdio.h>
 #include "config.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
+#include <stdio.h>
 #include "rtl.h"
 #include "regs.h"
 #include "insn-config.h"
@@ -2085,18 +2089,23 @@ output_addr_const (file, x)
    Also supported are %d, %x, %s, %e, %f, %g and %%.  */
 
 void
-asm_fprintf (va_alist)
-     va_dcl
+asm_fprintf VPROTO((FILE *file, char *p, ...))
 {
-  va_list argptr;
+#ifndef __STDC__
   FILE *file;
+  char *p;
+#endif
+  va_list argptr;
   char buf[10];
-  char *p, *q, c;
+  char *q, c;
 
-  va_start (argptr);
+  VA_START (argptr, p);
 
+#ifndef __STDC__
   file = va_arg (argptr, FILE *);
   p = va_arg (argptr, char *);
+#endif
+
   buf[0] = '%';
 
   while (c = *p++)
diff --git a/g++ b/g++
index db72410..ae9e5d2 100755
--- a/g++
+++ b/g++
@@ -66,10 +66,4 @@ then
   exit 1
 fi
 
-progname=`echo $0 |sed -e 's|/[^/]*$|/gcc|'`
-if [ -f ${progname} ]
-then
-exec ${progname} $newargs $library
-else
-exec gcc $newargs $library
-fi
+exec gcc-2.0 $newargs $library
diff --git a/gcc.c b/gcc.c
index 98e103d..4ad4f0d 100644
--- a/gcc.c
+++ b/gcc.c
@@ -39,7 +39,25 @@ compilation is specified by a string called a "spec".  */
 
 #include "config.h"
 #include "obstack.h"
+#include <errno.h>
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
+#include <stdio.h>
+
+#ifndef VPROTO
+#ifdef __STDC__
+#define PVPROTO(ARGS)           ARGS
+#define VPROTO(ARGS)            ARGS
+#define VA_START(va_list,var)   va_start(va_list,var)
+#else
+#define PVPROTO(ARGS)           ()
+#define VPROTO(ARGS)            (va_alist) va_dcl
+#define VA_START(va_list,var)   va_start(va_list)
+#endif
+#endif
 
 #ifdef USG
 #ifndef R_OK
@@ -51,6 +69,24 @@ compilation is specified by a string called a "spec".  */
 #define vfork fork
 #endif /* USG */
 
+/* Define a generic NULL if one hasn't already been defined.  */
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#ifndef GENERIC_PTR
+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
+#define GENERIC_PTR void *
+#else
+#define GENERIC_PTR char *
+#endif
+#endif
+
+#ifndef NULL_PTR
+#define NULL_PTR ((GENERIC_PTR)0)
+#endif
+
 /* On MSDOS, write temp files in current dir
    because there's no place else we can expect to use.  */
 #if __MSDOS__
@@ -136,8 +172,8 @@ static void give_switch ();
 static void pfatal_with_name ();
 static void perror_with_name ();
 static void perror_exec ();
-static void fatal ();
-static void error ();
+static void fatal PVPROTO((char *, ...));
+static void error PVPROTO((char *, ...));
 void fancy_abort ();
 char *xmalloc ();
 char *xrealloc ();
@@ -380,7 +416,7 @@ static struct compiler default_compilers[] =
    "cpp -lang-c %{nostdinc} %{C} %{v} %{A*} %{D*} %{U*} %{I*} %{i*} %{P}\
 	%{C:%{!E:%eGNU C does not support -C without using -E}}\
 	%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d}\
-        -undef -D__GNUC__=2 %{ansi:-trigraphs -$ -D__STRICT_ANSI__}\
+        -undef -D__GNUC__=2 -D__GNUC_MINOR__=0 %{ansi:-trigraphs -$ -D__STRICT_ANSI__}\
 	%{!undef:%{!ansi:%p} %P} %{trigraphs}\
         %c %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\
         %{traditional-cpp:-traditional}\
@@ -399,7 +435,7 @@ static struct compiler default_compilers[] =
    "%{E:cpp -lang-c %{nostdinc} %{C} %{v} %{A*} %{D*} %{U*} %{I*} %{i*} %{P}\
 	%{C:%{!E:%eGNU C does not support -C without using -E}}\
 	%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d}\
-        -undef -D__GNUC__=2 %{ansi:-trigraphs -$ -D__STRICT_ANSI__}\
+        -undef -D__GNUC__=2 -D__GNUC_MINOR__=0 %{ansi:-trigraphs -$ -D__STRICT_ANSI__}\
 	%{!undef:%{!ansi:%p} %P} %{trigraphs}\
         %c %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\
         %{traditional-cpp:-traditional}\
@@ -411,7 +447,7 @@ static struct compiler default_compilers[] =
    "cpp -lang-objc %{nostdinc} %{C} %{v} %{A*} %{D*} %{U*} %{I*} %{i*} %{P}\
 	%{C:%{!E:%eGNU C does not support -C without using -E}}\
 	%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d}\
-        -undef -D__OBJC__ -D__GNUC__=2 %{ansi:-trigraphs -$ -D__STRICT_ANSI__}\
+        -undef -D__OBJC__ -D__GNUC__=2 -D__GNUC_MINOR__=0 %{ansi:-trigraphs -$ -D__STRICT_ANSI__}\
 	%{!undef:%{!ansi:%p} %P} %{trigraphs}\
         %c %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\
         %{traditional-cpp:-traditional}\
@@ -433,7 +469,7 @@ static struct compiler default_compilers[] =
     cpp %{nostdinc} %{C} %{v} %{A*} %{D*} %{U*} %{I*} %{i*} %{P}\
 	%{C:%{!E:%eGNU C does not support -C without using -E}}\
 	 %{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} \
-        -undef -D__GNUC__=2 %{ansi:-trigraphs -$ -D__STRICT_ANSI__}\
+        -undef -D__GNUC__=2 -D__GNUC_MINOR__=0 %{ansi:-trigraphs -$ -D__STRICT_ANSI__}\
 	%{!undef:%{!ansi:%p} %P} %{trigraphs}\
         %c %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\
         %{traditional-cpp:-traditional}\
@@ -446,7 +482,7 @@ static struct compiler default_compilers[] =
    "cpp -lang-c++ %{nostdinc} %{C} %{v} %{A*} %{D*} %{U*} %{I*} %{i*} %{P}\
 	%{C:%{!E:%eGNU C++ does not support -C without using -E}}\
 	%{M} %{MM} %{MD:-MD %b.d} %{MMD:-MMD %b.d} \
-	-undef -D__GNUC__=2 -D__GNUG__=2 -D__cplusplus \
+	-undef -D__GNUC__=2 -D__GNUC_MINOR__=0 -D__GNUG__=2 -D__cplusplus \
 	%{ansi:-trigraphs -$ -D__STRICT_ANSI__} %{!undef:%{!ansi:%p} %P}\
         %c %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\
         %{traditional-cpp:-traditional} %{trigraphs}\
@@ -812,7 +848,7 @@ static int machine_explicit;
 #endif
 
 #ifndef STANDARD_EXEC_PREFIX
-#define STANDARD_EXEC_PREFIX "/usr/local/lib/gcc/"
+#define STANDARD_EXEC_PREFIX "/usr/local/lib/gcc-lib/"
 #endif /* !defined STANDARD_EXEC_PREFIX */
 
 static char *standard_exec_prefix = STANDARD_EXEC_PREFIX;
@@ -832,6 +868,12 @@ static char *standard_startfile_prefix = STANDARD_STARTFILE_PREFIX;
 static char *standard_startfile_prefix_1 = "/lib/";
 static char *standard_startfile_prefix_2 = "/usr/lib/";
 
+#ifndef TOOLDIR_BASE_PREFIX
+#define TOOLDIR_BASE_PREFIX "/usr/local/"
+#endif
+static char *tooldir_base_prefix = TOOLDIR_BASE_PREFIX;
+static char *tooldir_prefix;
+
 /* Clear out the vector of arguments (after a command is executed).  */
 
 static void
@@ -1549,7 +1591,7 @@ process_command (argc, argv)
      char **argv;
 {
   register int i;
-  char *temp;
+  char *temp, *gcc_exec_prefix;
   char *spec_lang = 0;
   int last_language_n_infiles;
 
@@ -1559,11 +1601,11 @@ process_command (argc, argv)
 
   /* Set up the default search paths.  */
 
-  temp = getenv ("GCC_EXEC_PREFIX");
-  if (temp)
+  gcc_exec_prefix = getenv ("GCC_EXEC_PREFIX");
+  if (gcc_exec_prefix)
     {
-      add_prefix (&exec_prefix, temp, 0, 0, 0);
-      add_prefix (&startfile_prefix, temp, 0, 0, 0);
+      add_prefix (&exec_prefix, gcc_exec_prefix, 0, 0, 0);
+      add_prefix (&startfile_prefix, gcc_exec_prefix, 0, 0, 0);
     }
 
   /* COMPILER_PATH and LIBRARY_PATH have values
@@ -1793,6 +1835,40 @@ process_command (argc, argv)
   add_prefix (&startfile_prefix, standard_exec_prefix, 0, 1, 0);
   add_prefix (&startfile_prefix, standard_exec_prefix_1, 0, 1, 0);
 
+  tooldir_prefix = concat (tooldir_base_prefix, spec_machine, "/");
+
+  /* If tooldir is relative, base it on exec_prefix.  A relative
+     tooldir lets us move the installed tree as a unit.
+
+     If GCC_EXEC_PREFIX is defined, then we want to add two relative
+     directories, so that we can search both the user specified directory
+     and the standard place.  */
+
+  if (*tooldir_prefix != '/')
+    {
+      if (gcc_exec_prefix)
+	{
+	  char *gcc_exec_tooldir_prefix
+	    = concat (concat (gcc_exec_prefix, spec_machine, "/"),
+		      concat (spec_version, "/", tooldir_prefix),
+		      "");
+
+	  add_prefix (&exec_prefix, concat (gcc_exec_tooldir_prefix, "bin", "/"),
+		      0, 0, NULL_PTR);
+	  add_prefix (&startfile_prefix, concat (gcc_exec_tooldir_prefix, "lib", "/"),
+		      0, 0, NULL_PTR);
+	}
+
+      tooldir_prefix = concat (concat (standard_exec_prefix, spec_machine, "/"),
+			       concat (spec_version, "/", tooldir_prefix),
+			       "");
+    }
+
+  add_prefix (&exec_prefix, concat (tooldir_prefix, "bin", "/"),
+	      0, 0, NULL_PTR);
+  add_prefix (&startfile_prefix, concat (tooldir_prefix, "lib", "/"),
+	      0, 0, NULL_PTR);
+
   /* Use the md prefixes only if not cross-compiling.  */
   if (!strcmp (spec_machine, DEFAULT_TARGET_MACHINE))
     {
@@ -2517,6 +2593,9 @@ do_spec_1 (spec, inswitch, soft_matched_part)
 		      do_spec_1 (buf, 0, NULL);
 		    }
 		}
+	       /* Discard the closing paren or bracket.  */
+	       if (*p)
+		 p++;
 	    }
 	    break;
 
@@ -3106,44 +3185,47 @@ save_string (s, len)
   return result;
 }
 
+char *
+my_strerror(e)
+     int e;
+{
+
+#ifdef HAVE_STRERROR
+  return strerror(e);
+
+#else
+
+  static char buffer[30];
+  if (!e)
+    return "";
+
+  if (e > 0 && e < sys_nerr)
+    return sys_errlist[e];
+
+  sprintf (buffer, "Unknown error %d", e);
+  return buffer;
+#endif
+}
+
 static void
 pfatal_with_name (name)
      char *name;
 {
-  char *s;
-
-  if (errno < sys_nerr)
-    s = concat ("%s: ", sys_errlist[errno], "");
-  else
-    s = "cannot open %s";
-  fatal (s, name);
+  fatal ("%s: %s", name, my_strerror (errno));
 }
 
 static void
 perror_with_name (name)
      char *name;
 {
-  char *s;
-
-  if (errno < sys_nerr)
-    s = concat ("%s: ", sys_errlist[errno], "");
-  else
-    s = "cannot open %s";
-  error (s, name);
+  error ("%s: %s", name, my_strerror (errno));
 }
 
 static void
 perror_exec (name)
      char *name;
 {
-  char *s;
-
-  if (errno < sys_nerr)
-    s = concat ("installation problem, cannot exec %s: ",
-		sys_errlist[errno], "");
-  else
-    s = "installation problem, cannot exec %s";
-  error (s, name);
+  error ("%s: %s", name, my_strerror (errno));
 }
 
 /* More 'friendly' abort that prints the line and file.
@@ -3160,14 +3242,19 @@ fancy_abort ()
 /* Output an error message and exit */
 
 static void
-fatal (va_alist)
-     va_dcl
+fatal VPROTO((char *format, ...))
 {
-  va_list ap;
+#ifndef __STDC__
   char *format;
+#endif
+  va_list ap;
+
+  VA_START (ap, format);
 
-  va_start (ap);
+#ifndef __STDC__
   format = va_arg (ap, char *);
+#endif
+
   fprintf (stderr, "%s: ", programname);
   vfprintf (stderr, format, ap);
   va_end (ap);
@@ -3177,14 +3264,19 @@ fatal (va_alist)
 }
 
 static void
-error (va_alist)
-     va_dcl
+error VPROTO((char *format, ...))
 {
-  va_list ap;
+#ifndef __STDC__
   char *format;
+#endif
+  va_list ap;
 
-  va_start (ap);
+  VA_START (ap, format);
+
+#ifndef __STDC__
   format = va_arg (ap, char *);
+#endif
+
   fprintf (stderr, "%s: ", programname);
   vfprintf (stderr, format, ap);
   va_end (ap);
diff --git a/gstdarg.h b/gstdarg.h
index 1382168..18b6042 100644
--- a/gstdarg.h
+++ b/gstdarg.h
@@ -27,13 +27,23 @@
 #undef _VA_LIST
 #endif
 
+/* Define __gnuc_va_list.  */
+
+#ifndef __GNUC_VA_LIST
+#define __GNUC_VA_LIST
+typedef char *__gnuc_va_list;
+#endif
+
 /* The macro _VA_LIST_ is the same thing used by this file in Ultrix.  */
 #ifndef _VA_LIST_
 /* The macro _VA_LIST is used in SCO Unix 3.2.  */
 #ifndef _VA_LIST
 #define _VA_LIST_
 #define _VA_LIST
-typedef char *va_list;
+#ifndef _VA_LIST_DEFINED
+typedef __gnuc_va_list va_list;
+#define _VA_LIST_DEFINED
+#endif
 #endif /* _VA_LIST */
 #endif /* _VA_LIST_ */
 
@@ -45,14 +55,14 @@ typedef char *va_list;
 
 #ifndef __sparc__
 #define va_start(AP, LASTARG) 						\
- (AP = ((char *) __builtin_next_arg ()))
+ (AP = ((__gnuc_va_list) __builtin_next_arg ()))
 #else
 #define va_start(AP, LASTARG) 						\
  (__builtin_saveregs (),						\
-  AP = ((char *) __builtin_next_arg ()))
+  AP = ((__gnuc_va_list) __builtin_next_arg ()))
 #endif
 
-void va_end (va_list);		/* Defined in libgcc.a */
+void va_end (__gnuc_va_list);		/* Defined in libgcc.a */
 #define va_end(AP)
 
 #define va_arg(AP, TYPE)						\
diff --git a/limitx.h b/limitx.h
index d261e94..76525b9 100644
--- a/limitx.h
+++ b/limitx.h
@@ -1,5 +1,12 @@
 /* This administrivia gets added to the beginning of limits.h
    if the system has its own version of limits.h.  */
 
-#include_next <limits.h>
+/* We use _GCC_LIMITS_H_ because we want this not to match
+   any macros that the system's limits.h uses for its own purposes.  */
+#ifndef _GCC_LIMITS_H_  /* Terminated in limity.h.  */
+#define _GCC_LIMITS_H_
 
+#ifndef _LIBC_LIMITS_H_
+/* Use <...> so that we find syslimits.h only in system include dirs.  */
+#include_next <limits.h>
+#endif
diff --git a/limity.h b/limity.h
new file mode 100644
index 0000000..5492553
--- /dev/null
+++ b/limity.h
@@ -0,0 +1,4 @@
+/* This administrivia gets added to the end of limits.h
+   if the system has its own version of limits.h.  */
+
+#endif /* not _GCC_LIMITS_H_ */
diff --git a/output.h b/output.h
index edf68ff..660ab01 100644
--- a/output.h
+++ b/output.h
@@ -18,13 +18,33 @@ You should have received a copy of the GNU General Public License
 along with GNU CC; see the file COPYING.  If not, write to
 the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
+#ifndef STDIO_PROTO
+#ifdef BUFSIZ
+#define STDIO_PROTO(ARGS) PROTO(ARGS)
+#else
+#define STDIO_PROTO(ARGS) ()
+#endif
+#endif
+
+#ifndef VPROTO
+#ifdef __STDC__
+#define PVPROTO(ARGS)           ARGS
+#define VPROTO(ARGS)            ARGS
+#define VA_START(va_list,var)   va_start(va_list,var)
+#else
+#define PVPROTO(ARGS)           ()
+#define VPROTO(ARGS)            (va_alist) va_dcl
+#define VA_START(va_list,var)   va_start(va_list)
+#endif
+#endif
+
 /* Output a string of assembler code, substituting insn operands.
    Defined in final.c.  */
 extern void output_asm_insn ();
 
 /* Output a string of assembler code, substituting numbers, strings
    and fixed syntactic prefixes.  */
-extern void asm_fprintf ();
+extern void asm_fprintf STDIO_PROTO(PVPROTO((FILE *file, char *p, ...)));
 
 /* Replace a SUBREG with a REG or a MEM, based on the thing it is a
    subreg of.  */
diff --git a/protoize.c b/protoize.c
index 67e51dd..a951f44 100644
--- a/protoize.c
+++ b/protoize.c
@@ -309,13 +309,25 @@ struct default_include { char *fname; int cplusplus; } include_defaults[]
   = {
     /* Pick up GNU C++ specific include files.  */
     { GPLUSPLUS_INCLUDE_DIR, 1},
-    { GCC_INCLUDE_DIR, 0},
 #ifdef CROSS_COMPILE
+    /* This is the dir for fixincludes.  Put it just before
+       the files that we fix.  */
+    { GCC_INCLUDE_DIR, 0},
     /* For cross-compilation, this dir name is generated
        automatically in Makefile.in.  */
     { CROSS_INCLUDE_DIR, 0 },
+    /* This is another place that the target system's headers might be.  */
+    { TOOL_INCLUDE_DIR, 0},
 #else /* not CROSS_COMPILE */
+    /* This should be /use/local/include and should come before
+       the fixincludes-fixed header files.  */
     { LOCAL_INCLUDE_DIR, 0},
+    /* This is here ahead of GCC_INCLUDE_DIR because assert.h goes here.
+       Likewise, behind LOCAL_INCLUDE_DIR, where glibc puts its assert.h.  */
+    { TOOL_INCLUDE_DIR, 0},
+    /* This is the dir for fixincludes.  Put it just before
+       the files that we fix.  */
+    { GCC_INCLUDE_DIR, 0},
     /* Some systems have an extra dir of include files.  */
 #ifdef SYSTEM_INCLUDE_DIR
     { SYSTEM_INCLUDE_DIR, 0},
diff --git a/rtl.h b/rtl.h
index 798111a..c7f4c92 100644
--- a/rtl.h
+++ b/rtl.h
@@ -130,6 +130,27 @@ typedef struct rtx_def
   rtunion fld[1];
 } *rtx;
 
+/* Add prototype support.  */
+#ifndef PROTO
+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
+#define PROTO(ARGS) ARGS
+#else
+#define PROTO(ARGS) ()
+#endif
+#endif
+
+#ifndef VPROTO
+#ifdef __STDC__
+#define PVPROTO(ARGS)           ARGS
+#define VPROTO(ARGS)            ARGS
+#define VA_START(va_list,var)   va_start(va_list,var)
+#else
+#define PVPROTO(ARGS)           ()
+#define VPROTO(ARGS)            (va_alist) va_dcl
+#define VA_START(va_list,var)   va_start(va_list)
+#endif
+#endif
+
 #define NULL_RTX (rtx) 0
 
 /* Define macros to access the `code' field of the rtx.  */
@@ -534,12 +555,12 @@ extern int get_integer_term ();
 extern rtx get_related_value ();
 extern rtx single_set ();
 extern rtx find_last_value ();
-extern rtx gen_rtx ();
+extern rtx gen_rtx PVPROTO((enum rtx_code, enum machine_mode, ...));
 extern rtx copy_rtx ();
 extern rtx copy_rtx_if_shared ();
 extern rtx copy_most_rtx ();
 extern rtx replace_rtx ();
-extern rtvec gen_rtvec ();
+extern rtvec gen_rtvec PVPROTO((int, ...));
 extern rtvec gen_rtvec_v ();
 extern rtx read_rtx ();
 extern rtx gen_reg_rtx ();
diff --git a/stdarg.h b/stdarg.h
new file mode 120000
index 0000000..883f582
--- /dev/null
+++ b/stdarg.h
@@ -0,0 +1 @@
+gstdarg.h
\ No newline at end of file
diff --git a/stddef.h b/stddef.h
new file mode 120000
index 0000000..4d44230
--- /dev/null
+++ b/stddef.h
@@ -0,0 +1 @@
+gstddef.h
\ No newline at end of file
diff --git a/tree.c b/tree.c
index e67b093..21e8946 100644
--- a/tree.c
+++ b/tree.c
@@ -33,12 +33,16 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
    by all passes of the compiler.  */
 
 #include "config.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
+#include "gvarargs.h"
+#endif
 #include <stdio.h>
 #include "flags.h"
 #include "function.h"
 #include "tree.h"
 #include "obstack.h"
-#include "gvarargs.h"
 
 #define obstack_chunk_alloc xmalloc
 #define obstack_chunk_free free
@@ -1904,21 +1908,27 @@ stabilize_reference_1 (e)
    Constants, decls, types and misc nodes cannot be.  */
 
 tree
-build (va_alist)
-     va_dcl
+build VPROTO((enum tree_code code, tree tt, ...))
 {
-  va_list p;
+#ifndef __STDC__
   enum tree_code code;
+  tree tt;
+#endif
+  va_list p;
   register tree t;
   register int length;
   register int i;
 
-  va_start (p);
+  VA_START (p, tt);
 
+#ifndef __STDC__
   code = va_arg (p, enum tree_code);
+  tt = va_arg (p, tree);
+#endif
+
   t = make_node (code);
   length = tree_code_length[(int) code];
-  TREE_TYPE (t) = va_arg (p, tree);
+  TREE_TYPE (t) = tt;
 
   if (length == 2)
     {
@@ -2025,18 +2035,22 @@ build1 (code, type, node)
    or even garbage if their values do not matter.  */
 
 tree
-build_nt (va_alist)
-     va_dcl
+build_nt VPROTO((enum tree_code code, ...))
 {
+#ifndef __STDC__
+  enum tree_code code;
+#endif
   va_list p;
-  register enum tree_code code;
   register tree t;
   register int length;
   register int i;
 
-  va_start (p);
+  VA_START (p, code);
 
+#ifndef __STDC__
   code = va_arg (p, enum tree_code);
+#endif
+
   t = make_node (code);
   length = tree_code_length[(int) code];
 
@@ -2051,21 +2065,24 @@ build_nt (va_alist)
    on the temp_decl_obstack, regardless.  */
 
 tree
-build_parse_node (va_alist)
-     va_dcl
+build_parse_node VPROTO((enum tree_code code, ...))
 {
+#ifndef __STDC__
+  enum tree_code code;
+#endif
   register struct obstack *ambient_obstack = expression_obstack;
   va_list p;
-  register enum tree_code code;
   register tree t;
   register int length;
   register int i;
 
-  expression_obstack = &temp_decl_obstack;
-
-  va_start (p);
+  VA_START (p, code);
 
+#ifndef __STDC__
   code = va_arg (p, enum tree_code);
+#endif
+
+  expression_obstack = &temp_decl_obstack;
   t = make_node (code);
   length = tree_code_length[(int) code];
 
diff --git a/tree.h b/tree.h
index 909a7b3..4488805 100644
--- a/tree.h
+++ b/tree.h
@@ -829,6 +829,45 @@ union tree_node
   struct tree_exp exp;
  };
 
+/* Add prototype support.  */
+#ifndef PROTO
+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
+#define PROTO(ARGS) ARGS
+#else
+#define PROTO(ARGS) ()
+#endif
+#endif
+
+#ifndef VPROTO
+#ifdef __STDC__
+#define PVPROTO(ARGS)           ARGS
+#define VPROTO(ARGS)            ARGS
+#define VA_START(va_list,var)   va_start(va_list,var)
+#else
+#define PVPROTO(ARGS)           ()
+#define VPROTO(ARGS)            (va_alist) va_dcl
+#define VA_START(va_list,var)   va_start(va_list)
+#endif
+#endif
+
+/* Define a generic NULL if one hasn't already been defined.  */
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#ifndef GENERIC_PTR
+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
+#define GENERIC_PTR void *
+#else
+#define GENERIC_PTR char *
+#endif
+#endif
+
+#ifndef NULL_PTR
+#define NULL_PTR ((GENERIC_PTR)0)
+#endif
+
 /* Format for global names of constructor and destructor functions.  */
 #ifndef NO_DOLLAR_IN_LABEL
 #define CONSTRUCTOR_NAME_FORMAT "_GLOBAL_$I$%s"
@@ -873,8 +912,10 @@ extern tree build_real_from_string ();
 extern tree build_real_from_int_cst ();
 extern tree build_complex ();
 extern tree build_string ();
-extern tree build (), build1 ();
-extern tree build_nt (), build_parse_node ();
+extern tree build1 ();
+extern tree build PVPROTO((enum tree_code, tree, ...));
+extern tree build_nt PVPROTO((enum tree_code, ...));
+extern tree build_parse_node PVPROTO((enum tree_code, ...));
 extern tree build_tree_list (), build_decl_list ();
 extern tree build_op_identifier ();
 extern tree build_decl ();
diff --git a/varasm.c b/varasm.c
index b6b218b..588a639 100644
--- a/varasm.c
+++ b/varasm.c
@@ -501,7 +501,7 @@ assemble_start_function (decl, fnname)
 #ifdef DBX_DEBUGGING_INFO
   /* Output SDB definition of the function.  */
   if (write_symbols == DBX_DEBUG)
-    dbxout_begin_function ();
+    dbxout_begin_function (decl);
 #endif
 
   /* Make function name accessible from other files, if appropriate.  */
