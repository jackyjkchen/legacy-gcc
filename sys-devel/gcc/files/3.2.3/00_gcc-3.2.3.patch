diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 76d7c35..a6e456c 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,30 @@
+2003-05-06  Richard Henderson  <rth@redhat.com>
+
+        * unwind-dw2.c (uw_update_context_1): Only set cfa as sp if 
+        previous frame didn't save sp.  Clear sp for next frame.
+        (uw_install_context_1): Honor saved sp from frame.
+
+2003-05-03  Richard Henderson  <rth@redhat.com>
+
+        * builtins.c (expand_builtin) <BUILT_IN_DWARF_FP_REGNUM>: Remove.
+        <BUILT_IN_DWARF_SP_COLUMN>: New.
+        * builtins.def (BUILT_IN_DWARF_FP_REGNUM): Remove.
+        (BUILT_IN_DWARF_SP_COLUMN): New.
+        * dwarf2out.c (expand_builtin_dwarf_fp_regnum): Remove.
+        (expand_builtin_dwarf_sp_column): New.
+        * except.h: Update to match.
+        * unwind-dw2.c (execute_stack_op): Correct stack push typo.
+        (execute_cfa_program): Record location expression address
+        before extracting length.
+        (uw_update_context_1): Install old CFA into stack pointer column.
+        (uw_init_context_1): Set cfa_reg to stack pointer column.
+
+2003-04-29  Jason Merrill  <jason@redhat.com>
+
+	PR middle-end/10336
+	* jump.c (never_reached_warning): Really stop looking if we reach 
+	the beginning of the function.
+
 2003-04-22  Release Manager
 
 	* GCC 3.2.3 Released.
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index e7c29b9..72a12f1 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -290,8 +290,12 @@ exec_prefix = @exec_prefix@
 bindir = @bindir@
 # Directory in which to put the directories used by the compiler.
 libdir = @libdir@
+# Directory in which GCC puts its executables.
+libexecdir = @libexecdir@
 # Directory in which the compiler finds executables, libraries, etc.
 libsubdir = $(libdir)/gcc-lib/$(target_alias)/$(version)
+# Directory in which the compiler finds executables
+libexecsubdir = $(libexecdir)/gcc/$(target_alias)/$(version)
 # Used to produce a relative $(gcc_tooldir) in gcc.o
 unlibsubdir = ../../..
 # Directory in which to find other cross-compilation tools and headers.
@@ -1137,23 +1141,6 @@ c-parse.o : $(srcdir)/c-parse.c $(CONFIG_H) $(TREE_H) c-lex.h $(GGC_H) intl.h \
 	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
 	       -c $(srcdir)/c-parse.c $(OUTPUT_OPTION)
 
-$(srcdir)/c-parse.c: $(srcdir)/c-parse.y
-	cd $(srcdir) && \
-	if $(BISON) $(BISONFLAGS) -o c-p$$$$.c c-parse.y; then \
-	  test -f c-p$$$$.output && mv -f c-p$$$$.output c-parse.output ; \
-	  mv -f c-p$$$$.c c-parse.c ; \
-	else \
-	  rm -f c-p$$$$.* ; \
-	  false ; \
-	fi
-
-$(srcdir)/c-parse.y: c-parse.in
-	echo '/*WARNING: This file is automatically generated!*/' >tmp-c-parse.y
-	sed -e "/^ifobjc$$/,/^end ifobjc$$/d" \
-	  -e "/^ifc$$/d" -e "/^end ifc$$/d" \
-	  $(srcdir)/c-parse.in >>tmp-c-parse.y
-	$(SHELL) $(srcdir)/move-if-change tmp-c-parse.y $(srcdir)/c-parse.y
-
 c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) $(C_TREE_H) \
     $(GGC_H) $(TARGET_H) c-lex.h flags.h function.h output.h $(EXPR_H) \
     debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) c-pragma.h
@@ -1238,6 +1225,7 @@ c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \
 DRIVER_DEFINES = \
   -DSTANDARD_STARTFILE_PREFIX=\"$(unlibsubdir)/\" \
   -DSTANDARD_EXEC_PREFIX=\"$(libdir)/gcc-lib/\" \
+  -DSTANDARD_LIBEXEC_PREFIX=\"$(libexecdir)/gcc/\" \
   -DDEFAULT_TARGET_VERSION=\"$(version)\" \
   -DDEFAULT_TARGET_MACHINE=\"$(target_alias)\" \
   -DSTANDARD_BINDIR_PREFIX=\"$(bindir)/\" \
@@ -2154,6 +2142,12 @@ fixinc.sh: $(FIXINCSRCDIR)/mkfixinc.sh $(FIXINCSRCDIR)/fixincl.c \
 
 # Build fixed copies of system files.
 stmp-fixinc: fixinc.sh gsyslimits.h
+	@if test ! -d ${SYSTEM_HEADER_DIR}; then \
+	  echo The directory that should contain system headers does not exist: >&2 ; \
+	  echo "  ${SYSTEM_HEADER_DIR}" >&2 ; \
+	  if test "x${SYSTEM_HEADER_DIR}" = "x${gcc_tooldir}/sys-include"; \
+	  then sleep 1; else exit 1; fi; \
+	fi
 	rm -rf include; mkdir include
 	-chmod a+rx include
 	(TARGET_MACHINE='$(target)'; srcdir=`cd $(srcdir); pwd`; \
@@ -2167,20 +2161,6 @@ stmp-fixinc: fixinc.sh gsyslimits.h
 	  cp $(srcdir)/gsyslimits.h include/syslimits.h; \
 	fi; \
 	chmod a+r include/syslimits.h)
-# If $(SYSTEM_HEADER_DIR) is $(build_tooldir)/sys-include, and
-# that directory exists, then make sure that $(libsubdir) exists.
-# This is because cpp is compiled to find $(gcc_tooldir)/include via
-# $(libsubdir)/$(unlibsubdir), which will only work if $(libsubdir)
-# exists.
-# ??? Better would be to use -isystem $(build_tooldir)/sys-include,
-# but fixincludes does not take such arguments.
-	if [ "$(SYSTEM_HEADER_DIR)" = "$(build_tooldir)/sys-include" ] \
-	   && [ -d $(build_tooldir)/sys-include ]; then \
-	  if [ -d $(libdir) ] ; then true ; else mkdir $(libdir) ; fi; \
-	  if [ -d $(libdir)/gcc-lib ] ; then true ; else mkdir $(libdir)/gcc-lib; fi; \
-	  if [ -d $(libdir)/gcc-lib/$(target_alias) ] ; then true ; else mkdir $(libdir)/gcc-lib/$(target_alias) ; fi; \
-	  if [ -d $(libdir)/gcc-lib/$(target_alias)/$(version) ] ; then true ; else mkdir $(libdir)/gcc-lib/$(target_alias)/$(version) ; fi; \
-	else true; fi
 	$(STAMP) stmp-fixinc
 
 # Files related to the fixproto script.
diff --git a/gcc/builtins.c b/gcc/builtins.c
index ca39c0b..dd61baf 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -3952,8 +3952,8 @@ expand_builtin (exp, target, subtarget, mode, ignore)
     case BUILT_IN_DWARF_CFA:
       return virtual_cfa_rtx;
 #ifdef DWARF2_UNWIND_INFO
-    case BUILT_IN_DWARF_FP_REGNUM:
-      return expand_builtin_dwarf_fp_regnum ();
+    case BUILT_IN_DWARF_SP_COLUMN:
+      return expand_builtin_dwarf_sp_column ();
     case BUILT_IN_INIT_DWARF_REG_SIZES:
       expand_builtin_init_dwarf_reg_sizes (TREE_VALUE (arglist));
       return const0_rtx;
diff --git a/gcc/builtins.def b/gcc/builtins.def
index c6f6dc4..af2f43e 100644
--- a/gcc/builtins.def
+++ b/gcc/builtins.def
@@ -446,8 +446,8 @@ DEF_GCC_BUILTIN(BUILT_IN_UNWIND_INIT,
 DEF_GCC_BUILTIN(BUILT_IN_DWARF_CFA,
 		"__builtin_dwarf_cfa",
 		BT_FN_PTR)
-DEF_GCC_BUILTIN(BUILT_IN_DWARF_FP_REGNUM,
-		"__builtin_dwarf_fp_regnum",
+DEF_GCC_BUILTIN(BUILT_IN_DWARF_SP_COLUMN,
+		"__builtin_dwarf_sp_column",
 		BT_FN_UNSIGNED)
 DEF_GCC_BUILTIN(BUILT_IN_INIT_DWARF_REG_SIZES,
 		"__builtin_init_dwarf_reg_size_table",
diff --git a/gcc/config/alpha/linux-elf.h b/gcc/config/alpha/linux-elf.h
index 6430059..0f9ba8a 100644
--- a/gcc/config/alpha/linux-elf.h
+++ b/gcc/config/alpha/linux-elf.h
@@ -41,3 +41,10 @@ Boston, MA 02111-1307, USA.  */
 #define LIB_SPEC \
 "%{shared:-lc}%{!shared:%{pthread:-lpthread }%{profile:-lc_p}%{!profile:-lc}} "
 #endif
+
+#define ASM_FILE_END(FILE) \
+  do {									\
+    named_section_flags (".note.GNU-stack",				\
+			 SECTION_DEBUG					\
+			 | (trampolines_created ? SECTION_CODE : 0));	\
+  } while (0)
diff --git a/gcc/config/alpha/linux.h b/gcc/config/alpha/linux.h
index 912d7b2..7e87e66 100644
--- a/gcc/config/alpha/linux.h
+++ b/gcc/config/alpha/linux.h
@@ -78,7 +78,7 @@ SUB_CPP_PREDEFINES
     else if (pc_[1] == 0x201f015f)	/* lda $0,NR_rt_sigreturn */	\
       {									\
 	struct rt_sigframe {						\
-	  struct siginfo info;						\
+	  siginfo_t info;						\
 	  struct ucontext uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = &rt_->uc.uc_mcontext;					\
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 3856927..62453ec 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -3900,7 +3900,7 @@ ix86_asm_file_end (file)
   rtx xops[2];
 
   if (! TARGET_DEEP_BRANCH_PREDICTION || pic_label_name[0] == 0)
-    return;
+    goto end;
 
   /* ??? Binutils 2.10 and earlier has a linkonce elimination bug related
      to updating relocations to a section being discarded such that this
@@ -3940,6 +3940,11 @@ ix86_asm_file_end (file)
   xops[1] = gen_rtx_MEM (SImode, stack_pointer_rtx);
   output_asm_insn ("mov{l}\t{%1, %0|%0, %1}", xops);
   output_asm_insn ("ret", xops);
+
+end:
+#ifdef SUBTARGET_FILE_END
+  SUBTARGET_FILE_END (file);
+#endif
 }
 
 void
diff --git a/gcc/config/i386/linux.h b/gcc/config/i386/linux.h
index 08407e1..5aeb0b3 100644
--- a/gcc/config/i386/linux.h
+++ b/gcc/config/i386/linux.h
@@ -217,6 +217,13 @@ Boston, MA 02111-1307, USA.  */
 	   : "=d"(BASE))
 #endif
 
+#define SUBTARGET_FILE_END(FILE) \
+  do {									\
+    named_section_flags (".note.GNU-stack",				\
+			 SECTION_DEBUG					\
+			 | (trampolines_created ? SECTION_CODE : 0));	\
+  } while (0)
+
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  
    Don't use this at all if inhibit_libc is used.  */
@@ -245,9 +252,9 @@ Boston, MA 02111-1307, USA.  */
       {									\
 	struct rt_sigframe {						\
 	  int sig;							\
-	  struct siginfo *pinfo;					\
+	  siginfo_t *pinfo;					\
 	  void *puc;							\
-	  struct siginfo info;						\
+	  siginfo_t info;						\
 	  struct ucontext uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
diff --git a/gcc/config/i386/linux64.h b/gcc/config/i386/linux64.h
index b858644..f1fea2b 100644
--- a/gcc/config/i386/linux64.h
+++ b/gcc/config/i386/linux64.h
@@ -68,6 +68,13 @@ Boston, MA 02111-1307, USA.  */
 
 #define MULTILIB_DEFAULTS { "m64" }
 
+#define SUBTARGET_FILE_END(FILE) \
+  do {									\
+    named_section_flags (".note.GNU-stack",				\
+			 SECTION_DEBUG					\
+			 | (trampolines_created ? SECTION_CODE : 0));	\
+  } while (0)
+
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  
    Don't use this at all if inhibit_libc is used.  */
@@ -154,9 +161,9 @@ Boston, MA 02111-1307, USA.  */
       {									\
 	struct rt_sigframe {						\
 	  int sig;							\
-	  struct siginfo *pinfo;					\
+	  siginfo_t *pinfo;					\
 	  void *puc;							\
-	  struct siginfo info;						\
+	  siginfo_t info;						\
 	  struct ucontext uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
diff --git a/gcc/config/i386/t-linux64 b/gcc/config/i386/t-linux64
index 31b6ad4..95901b4 100644
--- a/gcc/config/i386/t-linux64
+++ b/gcc/config/i386/t-linux64
@@ -12,3 +12,5 @@ LIBGCC = stmp-multilib
 INSTALL_LIBGCC = install-multilib
 
 EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
+CRTSTUFF_T_CFLAGS = -fno-omit-frame-pointer -fno-asynchronous-unwind-tables
diff --git a/gcc/config/ia64/linux.h b/gcc/config/ia64/linux.h
index 07882cd..9dbf9df 100644
--- a/gcc/config/ia64/linux.h
+++ b/gcc/config/ia64/linux.h
@@ -67,7 +67,7 @@
       struct sigframe {							\
 	char scratch[16];						\
 	unsigned long sig_number;					\
-	struct siginfo *info;						\
+	siginfo_t *info;						\
 	struct sigcontext *sc;						\
       } *frame_ = (struct sigframe *)(CONTEXT)->psp;			\
       struct sigcontext *sc_ = frame_->sc;				\
diff --git a/gcc/config/m68k/linux.h b/gcc/config/m68k/linux.h
index c5a2cbc..d3641c9 100644
--- a/gcc/config/m68k/linux.h
+++ b/gcc/config/m68k/linux.h
@@ -396,3 +396,10 @@ do {									\
       fprintf (FILE, "\n");						\
     }									\
 } while (0)
+
+#define ASM_FILE_END(FILE) \
+  do {									\
+    named_section_flags (".note.GNU-stack",				\
+			 SECTION_DEBUG					\
+			 | (trampolines_created ? SECTION_CODE : 0));	\
+  } while (0)
diff --git a/gcc/config/m68k/m68k.h b/gcc/config/m68k/m68k.h
index de871e0..539370e 100644
--- a/gcc/config/m68k/m68k.h
+++ b/gcc/config/m68k/m68k.h
@@ -1758,6 +1758,16 @@ __transfer_from_trampoline ()					\
 /* Before the prologue, the top of the frame is at 4(%sp).  */
 #define INCOMING_FRAME_SP_OFFSET 4
 
+/* Describe how we implement __builtin_eh_return.  */
+#define EH_RETURN_DATA_REGNO(N) \
+  ((N) < 2 ? (N) : INVALID_REGNUM)
+#define EH_RETURN_STACKADJ_RTX	gen_rtx_REG (Pmode, 8)
+#define EH_RETURN_HANDLER_RTX					    \
+  gen_rtx_MEM (Pmode,						    \
+	       gen_rtx_PLUS (Pmode, arg_pointer_rtx,		    \
+			     plus_constant (EH_RETURN_STACKADJ_RTX, \
+					    UNITS_PER_WORD)))
+
 /* This is how to output the definition of a user-level label named NAME,
    such as the label on a static function or variable NAME.  */
 
diff --git a/gcc/config/rs6000/linux.h b/gcc/config/rs6000/linux.h
index f5cbd7a..5b02d01 100644
--- a/gcc/config/rs6000/linux.h
+++ b/gcc/config/rs6000/linux.h
@@ -74,6 +74,13 @@ Boston, MA 02111-1307, USA.  */
 #undef DRAFT_V4_STRUCT_RET
 #define DRAFT_V4_STRUCT_RET 1
 
+#define ASM_FILE_END(FILE) \
+  do {									\
+    named_section_flags (".note.GNU-stack",				\
+			 SECTION_DEBUG					\
+			 | (trampolines_created ? SECTION_CODE : 0));	\
+  } while (0)
+
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
@@ -112,9 +119,9 @@ enum { SIGNAL_FRAMESIZE = 64 };
 	struct rt_sigframe {						\
 	  char gap[SIGNAL_FRAMESIZE];					\
 	  unsigned long _unused[2];					\
-	  struct siginfo *pinfo;					\
+	  siginfo_t *pinfo;					\
 	  void *puc;							\
-	  struct siginfo info;						\
+	  siginfo_t info;						\
 	  struct ucontext uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = &rt_->uc.uc_mcontext;					\
diff --git a/gcc/config/rs6000/linux64.h b/gcc/config/rs6000/linux64.h
index ce8f7ac..5674d0d 100644
--- a/gcc/config/rs6000/linux64.h
+++ b/gcc/config/rs6000/linux64.h
@@ -148,11 +148,11 @@ Boston, MA 02111-1307, USA.  */
 #ifndef CROSS_COMPILE
 #define LINK_OS_LINUX_SPEC "-m elf64ppc %{!shared: %{!static: \
   %{rdynamic:-export-dynamic} \
-  %{!dynamic-linker:-dynamic-linker /lib64/ld.so.1}}}"
+  %{!dynamic-linker:-dynamic-linker /lib64/ld64.so.1}}}"
 #else
 #define LINK_OS_LINUX_SPEC "-m elf64ppc %{!shared: %{!static: \
   %{rdynamic:-export-dynamic} \
-  %{!dynamic-linker:-dynamic-linker ld.so.1}}}"
+  %{!dynamic-linker:-dynamic-linker ld64.so.1}}}"
 #endif
 
 #ifndef CROSS_COMPILE
@@ -205,6 +205,18 @@ Boston, MA 02111-1307, USA.  */
 #undef  RS6000_MCOUNT
 #define RS6000_MCOUNT "_mcount"
 
+#ifdef __powerpc64__
+/* _init and _fini functions are built from bits spread across many
+   object files, each potentially with a different TOC pointer.  For
+   that reason, place a nop after the call so that the linker can
+   restore the TOC pointer if a TOC adjusting call stub is needed.  */
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)	\
+  asm (SECTION_OP "\n"					\
+"	bl ." #FUNC "\n"				\
+"	nop\n"						\
+"	.previous");
+#endif
+
 /* FP save and restore routines.  */
 #undef  SAVE_FP_PREFIX
 #define SAVE_FP_PREFIX "._savef"
@@ -380,3 +392,12 @@ while (0)
 #undef	ASM_PREFERRED_EH_DATA_FORMAT
 #define	ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
   (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_udata8)
+
+#define ASM_FILE_END(FILE) \
+  do {									\
+    if (! TARGET_64BIT)							\
+      named_section_flags (".note.GNU-stack",				\
+			   SECTION_DEBUG				\
+			   | (trampolines_created ? SECTION_CODE : 0));	\
+  } while (0)
+
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index 55612be..5a608a0 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -7718,7 +7718,7 @@
    mt%0 %1
    mt%0 %1
    mt%0 %1
-   cror 0,0,0"
+   {cror 0,0,0|nop}"
   [(set_attr "type" "*,*,load,store,*,*,*,*,*,*,mtjmpr,*,*")
    (set_attr "length" "4,4,4,4,4,4,8,4,4,4,4,4,4")])
 
@@ -7771,7 +7771,7 @@
   ""
   "{ rs6000_emit_move (operands[0], operands[1], HImode); DONE; }")
 
-(define_insn ""
+(define_insn "*movhi_internal"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,m,r,r,*q,*c*l,*h")
 	(match_operand:HI 1 "input_operand" "r,m,r,i,*h,r,r,0"))]
   "gpc_reg_operand (operands[0], HImode)
@@ -7784,7 +7784,7 @@
    mf%1 %0
    mt%0 %1
    mt%0 %1
-   cror 0,0,0"
+   {cror 0,0,0|nop}"
   [(set_attr "type" "*,load,store,*,*,*,mtjmpr,*")])
 
 (define_expand "movqi"
@@ -7793,7 +7793,7 @@
   ""
   "{ rs6000_emit_move (operands[0], operands[1], QImode); DONE; }")
 
-(define_insn ""
+(define_insn "*movqi_internal"
   [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,m,r,r,*q,*c*l,*h")
 	(match_operand:QI 1 "input_operand" "r,m,r,i,*h,r,r,0"))]
   "gpc_reg_operand (operands[0], QImode)
@@ -7806,7 +7806,7 @@
    mf%1 %0
    mt%0 %1
    mt%0 %1
-   cror 0,0,0"
+   {cror 0,0,0|nop}"
   [(set_attr "type" "*,load,store,*,*,*,mtjmpr,*")])
 
 ;; Here is how to move condition codes around.  When we store CC data in
@@ -8484,7 +8484,7 @@
    stfd%U0%X0 %1,%0
    mf%1 %0
    mt%0 %1
-   cror 0,0,0"
+   {cror 0,0,0|nop}"
   [(set_attr "type" "*,load,store,*,*,*,*,fp,fpload,fpstore,*,mtjmpr,*")
    (set_attr "length" "4,4,4,4,4,20,4,4,4,4,4,4,4")])
 
@@ -9723,7 +9723,7 @@
 	(match_operand:SI 1 "immediate_operand" "s"))
    (unspec [(match_dup 1)] 7)]
   "TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2"
-  "bl %1\\n%1:"
+  "bcl 20,31,%1\\n%1:"
   [(set_attr "type" "branch")
    (set_attr "length" "4")])
 
@@ -9732,7 +9732,7 @@
 	(match_operand:SI 1 "immediate_operand" "s"))
    (unspec [(match_dup 1) (match_operand 2 "immediate_operand" "s")] 6)]
   "TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2"
-  "bl %1\\n\\t.long %2-%1+4\\n%1:"
+  "bcl 20,31,%1\\n\\t.long %2-%1+4\\n%1:"
   [(set_attr "type" "branch")
    (set_attr "length" "8")])
 
diff --git a/gcc/config/s390/linux.h b/gcc/config/s390/linux.h
index a0336bf..d46dbdd 100644
--- a/gcc/config/s390/linux.h
+++ b/gcc/config/s390/linux.h
@@ -66,9 +66,11 @@ Boston, MA 02111-1307, USA.  */
 #ifdef DEFAULT_TARGET_64BIT
 #undef  CPP_SPEC
 #define CPP_SPEC "%{m31:%(cpp_arch31)} %{!m31:%(cpp_arch64)}"
+#define MULTILIB_DEFAULTS { "m64" }
 #else
 #undef  CPP_SPEC
 #define CPP_SPEC "%{m64:%(cpp_arch64)} %{!m64:%(cpp_arch31)}"
+#define MULTILIB_DEFAULTS { "m31" }
 #endif
 
 
@@ -120,6 +122,12 @@ Boston, MA 02111-1307, USA.  */
 #define LINK_SPEC "%{m64:%(link_arch64)} %{!m64:%(link_arch31)}"
 #endif
 
+#define ASM_FILE_END(FILE) \
+  do {									\
+    named_section_flags (".note.GNU-stack",				\
+			 SECTION_DEBUG					\
+			 | (trampolines_created ? SECTION_CODE : 0));	\
+  } while (0)
 
 /* This macro defines names of additional specifications to put in the specs
    that can be used in various specifications like CC1_SPEC.  Its definition
diff --git a/gcc/config/s390/t-linux b/gcc/config/s390/t-linux
index bc8d519..619b7f9 100644
--- a/gcc/config/s390/t-linux
+++ b/gcc/config/s390/t-linux
@@ -1,6 +1,6 @@
 # The crtbegin and crtend must not depend on a small GOT
-CRTSTUFF_T_CFLAGS = -O2 -fPIC
-CRTSTUFF_T_CFLAGS_S = -O2 -fPIC
+CRTSTUFF_T_CFLAGS = -O2 -fPIC -fno-asynchronous-unwind-tables
+CRTSTUFF_T_CFLAGS_S = -O2 -fPIC -fno-asynchronous-unwind-tables
 
 # Compile libgcc2.a with pic.
 TARGET_LIBGCC2_CFLAGS = -fPIC -include $(srcdir)/config/s390/fixdfdi.h
diff --git a/gcc/config/s390/t-linux64 b/gcc/config/s390/t-linux64
index d5a9278..db839c6 100644
--- a/gcc/config/s390/t-linux64
+++ b/gcc/config/s390/t-linux64
@@ -1,3 +1,12 @@
+MULTILIB_OPTIONS = m64/m31
+MULTILIB_DIRNAMES = 64 32
+MULTILIB_OSDIRNAMES = ../lib64 ../lib
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
+
+EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
 # Override t-slibgcc-elf-ver to export some libgcc symbols with
 # the symbol versions that glibc used.
 SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver $(srcdir)/config/s390/libgcc-glibc.ver
diff --git a/gcc/config/sh/linux.h b/gcc/config/sh/linux.h
index a1ed770..8949b3c 100644
--- a/gcc/config/sh/linux.h
+++ b/gcc/config/sh/linux.h
@@ -53,7 +53,7 @@ Boston, MA 02111-1307, USA.  */
    %{!mb:-D__LITTLE_ENDIAN__}"
 
 #undef CPP_DEFAULT_CPU_SPEC
-#define CPP_DEFAULT_CPU_SPEC "-D__SH3__ -D__sh3__"
+#define CPP_DEFAULT_CPU_SPEC "-D__SH4__"
 
 
 #undef CPP_PREDEFINES
diff --git a/gcc/config/sparc/linux.h b/gcc/config/sparc/linux.h
index b93b46c..2a0bbae 100644
--- a/gcc/config/sparc/linux.h
+++ b/gcc/config/sparc/linux.h
@@ -256,6 +256,13 @@ do {									\
 #undef CTORS_SECTION_ASM_OP
 #undef DTORS_SECTION_ASM_OP
 
+#define ASM_FILE_END(FILE) \
+  do {									\
+    named_section_flags (".note.GNU-stack",				\
+			 SECTION_DEBUG					\
+			 | (trampolines_created ? SECTION_CODE : 0));	\
+  } while (0)
+
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
diff --git a/gcc/config/sparc/linux64.h b/gcc/config/sparc/linux64.h
index c7d8f49..3166d17 100644
--- a/gcc/config/sparc/linux64.h
+++ b/gcc/config/sparc/linux64.h
@@ -323,6 +323,13 @@ do {									\
 #undef CTORS_SECTION_ASM_OP
 #undef DTORS_SECTION_ASM_OP
 
+#define ASM_FILE_END(FILE) \
+  do {									\
+    named_section_flags (".note.GNU-stack",				\
+			 SECTION_DEBUG					\
+			 | (trampolines_created ? SECTION_CODE : 0));	\
+  } while (0)
+
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index 8a3f613..bbeb557 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -382,9 +382,9 @@ static void def_cfa_1		 	PARAMS ((const char *,
 /* Hook used by __throw.  */
 
 rtx
-expand_builtin_dwarf_fp_regnum ()
+expand_builtin_dwarf_sp_column ()
 {
-  return GEN_INT (DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM));
+  return GEN_INT (DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM));
 }
 
 /* Return a pointer to a copy of the section string name S with all
diff --git a/gcc/except.h b/gcc/except.h
index 883a2b1..df48477 100644
--- a/gcc/except.h
+++ b/gcc/except.h
@@ -128,7 +128,7 @@ extern rtx expand_builtin_eh_return_data_regno	PARAMS ((tree));
 extern rtx expand_builtin_extract_return_addr	PARAMS ((tree));
 extern void expand_builtin_init_dwarf_reg_sizes PARAMS ((tree));
 extern rtx expand_builtin_frob_return_addr	PARAMS ((tree));
-extern rtx expand_builtin_dwarf_fp_regnum	PARAMS ((void));
+extern rtx expand_builtin_dwarf_sp_column	PARAMS ((void));
 extern void expand_builtin_eh_return		PARAMS ((tree, tree));
 extern void expand_eh_return			PARAMS ((void));
 extern rtx get_exception_pointer		PARAMS ((struct function *));
diff --git a/gcc/function.c b/gcc/function.c
index 2f63ecc..d011f5b 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -124,6 +124,9 @@ int current_function_uses_only_leaf_regs;
    post-instantiation libcalls.  */
 int virtuals_instantiated;
 
+/* Nonzero if at least one trampoline has been created.  */
+int trampolines_created;
+
 /* Assign unique numbers to labels generated for profiling.  */
 static int profile_label_no;
 
@@ -6874,6 +6877,7 @@ expand_function_end (filename, line, end_bindings)
       emit_block_move (blktramp, initial_trampoline,
 		       GEN_INT (TRAMPOLINE_SIZE));
 #endif
+      trampolines_created = 1;
       INITIALIZE_TRAMPOLINE (tramp, XEXP (DECL_RTL (function), 0), context);
       seq = get_insns ();
       end_sequence ();
diff --git a/gcc/function.h b/gcc/function.h
index cddfce5..32f2514 100644
--- a/gcc/function.h
+++ b/gcc/function.h
@@ -486,6 +486,9 @@ extern struct function *cfun;
 /* Nonzero if we've already converted virtual regs to hard regs.  */
 extern int virtuals_instantiated;
 
+/* Nonzero if at least one trampoline has been created.  */
+extern int trampolines_created;
+
 /* For backward compatibility... eventually these should all go away.  */
 #define current_function_name (cfun->name)
 #define current_function_pops_args (cfun->pops_args)
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 7845fc3..ef38b48 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -1335,6 +1335,8 @@ static const char *const standard_exec_prefix = STANDARD_EXEC_PREFIX;
 static const char *const standard_exec_prefix_1 = "/usr/lib/gcc/";
 static const char *md_exec_prefix = MD_EXEC_PREFIX;
 
+static const char *standard_libexec_prefix = STANDARD_LIBEXEC_PREFIX;
+
 static const char *md_startfile_prefix = MD_STARTFILE_PREFIX;
 static const char *md_startfile_prefix_1 = MD_STARTFILE_PREFIX_1;
 static const char *const standard_startfile_prefix = STANDARD_STARTFILE_PREFIX;
@@ -3811,6 +3813,8 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
 	      PREFIX_PRIORITY_LAST, 2, warn_std_ptr, 0);
   add_prefix (&exec_prefixes, standard_exec_prefix_1, "BINUTILS",
 	      PREFIX_PRIORITY_LAST, 2, warn_std_ptr, 0);
+  add_prefix (&exec_prefixes, standard_libexec_prefix, "BINUTILS",
+	      PREFIX_PRIORITY_LAST, 2, warn_std_ptr, 0);
 #endif
 
   add_prefix (&startfile_prefixes, standard_exec_prefix, "BINUTILS",
diff --git a/gcc/jump.c b/gcc/jump.c
index c668374..3fac7a5 100644
--- a/gcc/jump.c
+++ b/gcc/jump.c
@@ -1957,13 +1957,15 @@ never_reached_warning (avoided_insn, finish)
   /* Back up to the first of any NOTEs preceding avoided_insn; flow passes
      us the head of a block, a NOTE_INSN_BASIC_BLOCK, which often follows
      the line note.  */
-  for (insn = PREV_INSN (avoided_insn); ; insn = PREV_INSN (insn))
-    if (GET_CODE (insn) != NOTE
-	|| NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)
-      {
-	insn = NEXT_INSN (insn);
+  insn = avoided_insn;
+  while (1)
+    {
+      rtx prev = PREV_INSN (insn);
+      if (prev == NULL_RTX
+	  || GET_CODE (prev) != NOTE)
 	break;
-      }
+      insn = prev;
+    }
 
   /* Scan forwards, looking at LINE_NUMBER notes, until we hit a LABEL
      in case FINISH is NULL, otherwise until we run out of insns.  */
diff --git a/gcc/mklibgcc.in b/gcc/mklibgcc.in
index cde9443..309f2cc 100644
--- a/gcc/mklibgcc.in
+++ b/gcc/mklibgcc.in
@@ -282,11 +282,15 @@ for ml in $MULTILIBS; do
   if [ "@libgcc_visibility@" = yes -a "$SHLIB_LINK" ]; then
     libgcc_a_objs=
     echo ""
+    echo "libgcc/${dir}/stacknote.s: stmp-dirs"
+    echo '	@( echo | $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) '${flags}' -S -o - -xc - | grep .note.GNU-stack || : ) > $@.tmp'
+    echo '	@mv -f $@.tmp $@'
+    echo ""
     for o in $libgcc_objs $libgcc_st_objs; do
       # .oS objects will have all non-local symbol definitions .hidden
       oS=`echo ${o} | sed s~${objext}'$~.oS~g'`
-      echo "${oS}: stmp-dirs ${o}"
-      echo '	@$(NM_FOR_TARGET) '${SHLIB_NM_FLAGS} ${o}' | $(AWK) '\''NF == 3 { print "\t.hidden", $$3 }'\'' | $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) '${flags}' -r -nostdinc -nostdlib -o $@ '${o}' -xassembler -'
+      echo "${oS}: stmp-dirs libgcc/${dir}/stacknote.s ${o}"
+      echo '	@( $(NM_FOR_TARGET) '${SHLIB_NM_FLAGS} ${o}' | $(AWK) '\''NF == 3 { print "\t.hidden", $$3 }'\''; cat libgcc/${dir}/stacknote.s ) | $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) '${flags}' -r -nostdinc -nostdlib -o $@ '${o}' -xassembler -'
       libgcc_a_objs="${libgcc_a_objs} ${oS}"
     done
   fi
@@ -371,6 +375,7 @@ echo '	  if [ -d $(stage)/$$dir ]; then true; else mkdir $(stage)/$$dir; fi; \'
 echo '	done'
 echo '	-for dir in '"${dirs}"'; do \'
 echo '	  mv $$dir/*'"${objext}"' $(stage)/$$dir; \'
+echo '	  test ! -f $$dir/stacknote.s || mv $$dir/stacknote.s $(stage)/$$dir; \'
 echo '	done'
 
 echo ""
diff --git a/gcc/unwind-dw2.c b/gcc/unwind-dw2.c
index 8151d69..e6a6b4e 100644
--- a/gcc/unwind-dw2.c
+++ b/gcc/unwind-dw2.c
@@ -679,7 +679,7 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,
       /* Most things push a result value.  */
       if ((size_t) stack_elt >= sizeof(stack)/sizeof(*stack))
 	abort ();
-      stack[++stack_elt] = result;
+      stack[stack_elt++] = result;
     no_push:;
     }
 
@@ -829,17 +829,17 @@ execute_cfa_program (const unsigned char *insn_ptr,
 	  break;
 
 	case DW_CFA_def_cfa_expression:
-	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
 	  fs->cfa_exp = insn_ptr;
 	  fs->cfa_how = CFA_EXP;
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
 	  insn_ptr += utmp;
 	  break;
 
 	case DW_CFA_expression:
 	  insn_ptr = read_uleb128 (insn_ptr, &reg);
-	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
 	  fs->regs.reg[reg].how = REG_SAVED_EXP;
 	  fs->regs.reg[reg].loc.exp = insn_ptr;
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
 	  insn_ptr += utmp;
 	  break;
 
@@ -906,17 +906,7 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)
   fde = _Unwind_Find_FDE (context->ra - 1, &context->bases);
   if (fde == NULL)
     {
-      /* Couldn't find frame unwind info for this function.  Try a
-	 target-specific fallback mechanism.  This will necessarily
-	 not provide a personality routine or LSDA.  */
-#ifdef MD_FALLBACK_FRAME_STATE_FOR
-      MD_FALLBACK_FRAME_STATE_FOR (context, fs, success);
       return _URC_END_OF_STACK;
-    success:
-      return _URC_NO_REASON;
-#else
-      return _URC_END_OF_STACK;
-#endif
     }
 
   fs->pc = context->bases.func;
@@ -1020,37 +1010,47 @@ static void
 uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)
 {
   struct _Unwind_Context orig_context = *context;
+  _Unwind_Word tmp_sp;
   void *cfa;
   long i;
 
+  /* Special handling here: Many machines do not use a frame pointer,
+     and track the CFA only through offsets from the stack pointer from
+     one frame to the next.  In this case, the stack pointer is never
+     stored, so it has no saved address in the context.  What we do
+     have is the CFA from the previous stack frame.
+
+     In very special situations (such as unwind info for signal return),
+     there may be location expressions that use the stack pointer as well.
+
+     Do this conditionally for one frame.  This allows the unwind info
+     for one frame to save a copy of the stack pointer from the previous
+     frame, and be able to use much easier CFA mechanisms to do it.
+     Always zap the saved stack pointer value for the next frame; carrying
+     the value over from one frame to another doesn't make sense.  */
+  if (!orig_context.reg[__builtin_dwarf_sp_column ()])
+    {
+      tmp_sp = (_Unwind_Ptr) context->cfa;
+      orig_context.reg[__builtin_dwarf_sp_column ()] = &tmp_sp;
+    }
+  context->reg[__builtin_dwarf_sp_column ()] = NULL;
+
   /* Compute this frame's CFA.  */
   switch (fs->cfa_how)
     {
     case CFA_REG_OFFSET:
-      /* Special handling here: Many machines do not use a frame pointer,
-	 and track the CFA only through offsets from the stack pointer from
-	 one frame to the next.  In this case, the stack pointer is never
-	 stored, so it has no saved address in the context.  What we do 
-	 have is the CFA from the previous stack frame.  */
-      if (context->reg[fs->cfa_reg] == NULL)
-	cfa = context->cfa;
-      else
-	cfa = (void *) (_Unwind_Ptr) _Unwind_GetGR (context, fs->cfa_reg);
+      cfa = (void *) (_Unwind_Ptr) _Unwind_GetGR (&orig_context, fs->cfa_reg);
       cfa += fs->cfa_offset;
       break;
 
     case CFA_EXP:
-      /* ??? No way of knowing what register number is the stack pointer
-	 to do the same sort of handling as above.  Assume that if the
-	 CFA calculation is so complicated as to require a stack program
-	 that this will not be a problem.  */
       {
 	const unsigned char *exp = fs->cfa_exp;
 	_Unwind_Word len;
 
 	exp = read_uleb128 (exp, &len);
 	cfa = (void *) (_Unwind_Ptr)
-	  execute_stack_op (exp, exp + len, context, 0);
+	  execute_stack_op (exp, exp + len, &orig_context, 0);
 	break;
       }
 
@@ -1065,12 +1065,15 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)
       {
       case REG_UNSAVED:
 	break;
+
       case REG_SAVED_OFFSET:
 	context->reg[i] = cfa + fs->regs.reg[i].loc.offset;
 	break;
+
       case REG_SAVED_REG:
 	context->reg[i] = orig_context.reg[fs->regs.reg[i].loc.reg];
 	break;
+
       case REG_SAVED_EXP:
 	{
 	  const unsigned char *exp = fs->regs.reg[i].loc.exp;
@@ -1127,7 +1130,7 @@ uw_init_context_1 (struct _Unwind_Context *context,
   /* Force the frame state to use the known cfa value.  */
   context->cfa = outer_cfa;
   fs.cfa_how = CFA_REG_OFFSET;
-  fs.cfa_reg = 0;
+  fs.cfa_reg = __builtin_dwarf_sp_column ();
   fs.cfa_offset = 0;
 
   uw_update_context_1 (context, &fs);
@@ -1163,6 +1166,7 @@ uw_install_context_1 (struct _Unwind_Context *current,
 		      struct _Unwind_Context *target)
 {
   long i;
+  void *target_cfa;
 
 #if __GTHREADS
   {
@@ -1184,11 +1188,18 @@ uw_install_context_1 (struct _Unwind_Context *current,
 	memcpy (c, t, dwarf_reg_size_table[i]);
     }
 
+  /* If the last frame records a saved stack pointer, use it.  */
+  if (target->reg[__builtin_dwarf_sp_column ()])
+    target_cfa = (void *)(_Unwind_Ptr)
+      _Unwind_GetGR (target, __builtin_dwarf_sp_column ());
+  else
+    target_cfa = target->cfa;
+
   /* We adjust SP by the difference between CURRENT and TARGET's CFA.  */
   if (STACK_GROWS_DOWNWARD)
-    return target->cfa - current->cfa + target->args_size;
+    return target_cfa - current->cfa + target->args_size;
   else
-    return current->cfa - target->cfa - target->args_size;
+    return current->cfa - target_cfa - target->args_size;
 }
 
 static inline _Unwind_Ptr
