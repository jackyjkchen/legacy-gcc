diff --git a/Makefile.def b/Makefile.def
index dc7d612..0c35b39 100644
--- a/Makefile.def
+++ b/Makefile.def
@@ -431,7 +431,9 @@ dependencies = { module=all-target-libjava; on=all-target-zlib; };
 dependencies = { module=all-target-libjava; on=all-target-boehm-gc; };
 dependencies = { module=all-target-libjava; on=all-target-qthreads; };
 dependencies = { module=all-target-libjava; on=all-target-libffi; };
+dependencies = { module=configure-target-libobjc; on=configure-target-boehm-gc; };
 dependencies = { module=all-target-libobjc; on=all-target-libiberty; };
+dependencies = { module=all-target-libobjc; on=all-target-boehm-gc; };
 dependencies = { module=all-target-libstdc++-v3; on=all-target-libiberty; };
 
 // Target modules in the 'src' repository.
diff --git a/Makefile.in b/Makefile.in
index b982ecc..c553e6b 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -36691,7 +36691,9 @@ all-target-libjava: maybe-all-target-zlib
 all-target-libjava: maybe-all-target-boehm-gc
 all-target-libjava: maybe-all-target-qthreads
 all-target-libjava: maybe-all-target-libffi
+configure-target-libobjc: maybe-configure-target-boehm-gc
 all-target-libobjc: maybe-all-target-libiberty
+all-target-libobjc: maybe-all-target-boehm-gc
 all-target-libstdc++-v3: maybe-all-target-libiberty
 all-target-libgloss: maybe-configure-target-newlib
 all-target-winsup: maybe-all-target-libiberty
diff --git a/boehm-gc/ia64_save_regs_in_stack.S b/boehm-gc/ia64_save_regs_in_stack.S
new file mode 100644
index 0000000..632913d
--- /dev/null
+++ b/boehm-gc/ia64_save_regs_in_stack.S
@@ -0,0 +1,15 @@
+        .text
+        .align 16
+        .global GC_save_regs_in_stack
+        .proc GC_save_regs_in_stack
+GC_save_regs_in_stack:
+        .body
+        flushrs
+        ;;
+        mov r8=ar.bsp
+        br.ret.sptk.few rp
+        .endp GC_save_regs_in_stack
+
+#ifdef __linux__
+	.section .note.GNU-stack,"",@progbits
+#endif
diff --git a/boehm-gc/ia64_save_regs_in_stack.s b/boehm-gc/ia64_save_regs_in_stack.s
index 3b18c08..e69de29 100644
--- a/boehm-gc/ia64_save_regs_in_stack.s
+++ b/boehm-gc/ia64_save_regs_in_stack.s
@@ -1,12 +0,0 @@
-        .text
-        .align 16
-        .global GC_save_regs_in_stack
-        .proc GC_save_regs_in_stack
-GC_save_regs_in_stack:
-        .body
-        flushrs
-        ;;
-        mov r8=ar.bsp
-        br.ret.sptk.few rp
-        .endp GC_save_regs_in_stack
-
diff --git a/configure b/configure
index 1afdeb4..6bc5516 100755
--- a/configure
+++ b/configure
@@ -15,6 +15,9 @@ ac_help="$ac_help
   --enable-libada        Builds libada directory"
 ac_help="$ac_help
   --enable-libssp        Builds libssp directory"
+ac_help="$ac_help
+  --enable-objc-gc       enable the use of Boehm's garbage collector with
+                          the GNU Objective-C runtime."
 ac_help="$ac_help
   --with-mpfr-dir=PATH    Specify source directory for MPFR library"
 ac_help="$ac_help
@@ -1123,6 +1126,21 @@ no)
   ;;
 esac
 
+# Check whether --enable-objc-gc or --disable-objc-gc was given.
+if test "${enable_objc_gc+set}" = set; then
+  enableval="$enable_objc_gc"
+  case $enable_objc_gc in
+  yes)
+    # reenable boehm-gc if it is needed for objc
+    noconfigdirs=`echo " ${noconfigdirs} " | sed -e 's/target-boehm-gc //'`
+    libgcj=`echo " ${libgcj} " | sed -e 's/target-boehm-gc //'`
+    libgcj_saved=`echo " ${libgcj_saved} " | sed -e 's/target-boehm-gc //'`
+    ;;
+  no)
+    ;;
+esac
+fi
+
 
 # Allow --disable-libmudflap to exclude target-libmudflap
 case $enable_libmudflap in
diff --git a/configure.in b/configure.in
index 7e77b86..ee85a4b 100644
--- a/configure.in
+++ b/configure.in
@@ -331,6 +331,19 @@ no)
   ;;
 esac
 
+AC_ARG_ENABLE(objc-gc,
+[  --enable-objc-gc       enable the use of Boehm's garbage collector with
+                          the GNU Objective-C runtime.],
+[case $enable_objc_gc in
+  yes)
+    # reenable boehm-gc if it is needed for objc
+    noconfigdirs=`echo " ${noconfigdirs} " | sed -e 's/target-boehm-gc //'`
+    libgcj=`echo " ${libgcj} " | sed -e 's/target-boehm-gc //'`
+    libgcj_saved=`echo " ${libgcj_saved} " | sed -e 's/target-boehm-gc //'`
+    ;;
+  no)
+    ;;
+esac])
 
 # Allow --disable-libmudflap to exclude target-libmudflap
 case $enable_libmudflap in
diff --git a/gcc/builtins.c b/gcc/builtins.c
index c51291b..88ecc60 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -541,12 +541,16 @@ expand_builtin_return_addr (enum built_in_function fndecl_code, int count)
 #else
   rtx tem;
 
-  /* For a zero count, we don't care what frame address we return, so frame
-     pointer elimination is OK, and using the soft frame pointer is OK.
-     For a non-zero count, we require a stable offset from the current frame
-     pointer to the previous one, so we must use the hard frame pointer, and
+  /* For a zero count with __builtin_return_address, we don't care what
+     frame address we return, because target-specific definitions will
+     override us.  Therefore frame pointer elimination is OK, and using
+     the soft frame pointer is OK.
+
+     For a non-zero count, or a zero count with __builtin_frame_address,
+     we require a stable offset from the current frame pointer to the
+     previous one, so we must use the hard frame pointer, and
      we must disable frame pointer elimination.  */
-  if (count == 0)
+  if (count == 0 && fndecl_code == BUILT_IN_RETURN_ADDRESS)
     tem = frame_pointer_rtx;
   else 
     {
diff --git a/gcc/c-tree.h b/gcc/c-tree.h
index 0894317..f867963 100644
--- a/gcc/c-tree.h
+++ b/gcc/c-tree.h
@@ -610,7 +610,7 @@ extern void c_write_global_declarations (void);
 /* In order for the format checking to accept the C frontend
    diagnostic framework extensions, you must include this file before
    toplev.h, not after.  */
-#if GCC_VERSION >= 4001
+#if (GCC_VERSION >= 4001) && (__GNUC__ != 9) /* gcc-9 is buggy: https://gcc.gnu.org/PR90677  */
 #define ATTRIBUTE_GCC_CDIAG(m, n) __attribute__ ((__format__ (GCC_DIAG_STYLE, m ,n))) ATTRIBUTE_NONNULL(m)
 #else
 #define ATTRIBUTE_GCC_CDIAG(m, n) ATTRIBUTE_NONNULL(m)
diff --git a/gcc/config.gcc b/gcc/config.gcc
index b4c8259..d53dd62 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -672,6 +672,11 @@ arm*-*-netbsd*)
 	;;
 arm*-*-linux*)			# ARM GNU/Linux with ELF
 	tm_file="dbxelf.h elfos.h linux.h arm/elf.h arm/linux-gas.h arm/linux-elf.h" 
+	case $target in
+	arm*b-*)
+		tm_defines="${tm_defines} TARGET_BIG_ENDIAN_DEFAULT=1"
+		;;
+	esac
 	tmake_file="${tmake_file} t-linux arm/t-arm"
 	case ${target} in
 	arm*-*-linux-gnueabi)
@@ -1987,7 +1992,7 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \
 	sh_multilibs=${with_multilib_list}
 	if test x${sh_multilibs} = x ; then
 		case ${target} in
-		sh[1234]*)	sh_multilibs=${sh_cpu_target} ;;
+		sh[1234]*)	sh_multilibs=`cd ${srcdir}/config/sh ; echo t-mlib-sh[1-4]* | sed 's:t-mlib-sh:,m:g;s: ::g'` ;;
 		sh64* | sh5*)	sh_multilibs=m5-32media,m5-32media-nofpu,m5-compact,m5-compact-nofpu,m5-64media,m5-64media-nofpu ;;
 		sh-superh-*)	sh_multilibs=m4,m4-single,m4-single-only,m4-nofpu ;;
 		sh*-*-linux*)	sh_multilibs=m1,m3e,m4 ;;
diff --git a/gcc/config/alpha/alpha.h b/gcc/config/alpha/alpha.h
index 91689fb..2755f63 100644
--- a/gcc/config/alpha/alpha.h
+++ b/gcc/config/alpha/alpha.h
@@ -96,7 +96,7 @@ Boston, MA 02110-1301, USA.  */
   while (0)
 #endif
 
-#define CPP_SPEC "%(cpp_subtarget)"
+#define CPP_SPEC "%(cpp_subtarget) %{!no-ieee:-mieee}"
 
 #ifndef CPP_SUBTARGET_SPEC
 #define CPP_SUBTARGET_SPEC ""
diff --git a/gcc/config/alpha/alpha.opt b/gcc/config/alpha/alpha.opt
index a29f58e..51fc663 100644
--- a/gcc/config/alpha/alpha.opt
+++ b/gcc/config/alpha/alpha.opt
@@ -40,7 +40,7 @@ Target RejectNegative Mask(IEEE_CONFORMANT)
 Request IEEE-conformant math library routines (OSF/1)
 
 mieee
-Target Report RejectNegative Mask(IEEE)
+Target Report Mask(IEEE)
 Emit IEEE-conformant code, without inexact exceptions
 
 mieee-with-inexact
diff --git a/gcc/config/alpha/elf.h b/gcc/config/alpha/elf.h
index 43449f5..fbfd692 100644
--- a/gcc/config/alpha/elf.h
+++ b/gcc/config/alpha/elf.h
@@ -47,7 +47,7 @@ Boston, MA 02110-1301, USA.  */
 #define CC1_SPEC  "%{G*}"
 
 #undef  ASM_SPEC
-#define ASM_SPEC  "%{G*} %{relax:-relax} %{!gstabs*:-no-mdebug}%{gstabs*:-mdebug}"
+#define ASM_SPEC  "%{G*} %{relax:-relax} %{!gstabs*:-no-mdebug}%{gstabs*:-mdebug} %{mcpu=*:-m%*}"
 
 #undef  IDENT_ASM_OP
 #define IDENT_ASM_OP "\t.ident\t"
diff --git a/gcc/config/alpha/linux-unwind.h b/gcc/config/alpha/linux-unwind.h
index 1f1c2af..198bdac 100644
--- a/gcc/config/alpha/linux-unwind.h
+++ b/gcc/config/alpha/linux-unwind.h
@@ -52,8 +52,8 @@ alpha_fallback_frame_state (struct _Unwind_Context *context,
   else if (pc[1] == 0x201f015f)	/* lda $0,NR_rt_sigreturn */
     {
       struct rt_sigframe {
-	struct siginfo info;
-	struct ucontext uc;
+	siginfo_t info;
+	ucontext_t uc;
       } *rt_ = context->cfa;
       sc = &rt_->uc.uc_mcontext;
     }
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 355e433..4967fda 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -15371,6 +15371,15 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)
 	  /* Move from sp to reg.  */
 	  asm_fprintf (asm_out_file, "\t.movsp %r\n", REGNO (e0));
 	}
+     else if (GET_CODE (e1) == PLUS
+	      && GET_CODE (XEXP (e1, 0)) == REG
+	      && REGNO (XEXP (e1, 0)) == SP_REGNUM
+	      && GET_CODE (XEXP (e1, 1)) == CONST_INT)
+	{
+	  /* Set reg to offset from sp.  */
+	  asm_fprintf (asm_out_file, "\t.movsp %r, #%d\n",
+		       REGNO (e0), (int)INTVAL(XEXP (e1, 1)));
+	}
       else
 	abort ();
       break;
diff --git a/gcc/config/arm/linux-eabi.h b/gcc/config/arm/linux-eabi.h
index 6cd0989..59a4519 100644
--- a/gcc/config/arm/linux-eabi.h
+++ b/gcc/config/arm/linux-eabi.h
@@ -20,6 +20,17 @@
    the Free Software Foundation, 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.  */
 
+/*
+ * 'config.gcc' defines TARGET_BIG_ENDIAN_DEFAULT as 1 for arm*b-*
+ * (big endian) configurations.
+ */
+#undef TARGET_LINKER_EMULATION
+#if TARGET_BIG_ENDIAN_DEFAULT
+#define TARGET_LINKER_EMULATION "armelfb_linux_eabi"
+#else
+#define TARGET_LINKER_EMULATION "armelf_linux_eabi"
+#endif
+
 /* On EABI GNU/Linux, we want both the BPABI builtins and the
    GNU/Linux builtins.  */
 #undef TARGET_OS_CPP_BUILTINS
@@ -45,10 +56,10 @@
    The ARM10TDMI core is the default for armv5t, so set
    SUBTARGET_CPU_DEFAULT to achieve this.  */
 #undef SUBTARGET_CPU_DEFAULT
-#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm10tdmi
+#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm9tdmi
 
 #undef SUBTARGET_EXTRA_LINK_SPEC
-#define SUBTARGET_EXTRA_LINK_SPEC " -m armelf_linux_eabi"
+#define SUBTARGET_EXTRA_LINK_SPEC " -m " TARGET_LINKER_EMULATION
 
 /* Use ld-linux.so.3 so that it will be possible to run "classic"
    GNU/Linux binaries on an EABI system.  */
diff --git a/gcc/config/arm/linux-elf.h b/gcc/config/arm/linux-elf.h
index 15354e5..d81b7dc 100644
--- a/gcc/config/arm/linux-elf.h
+++ b/gcc/config/arm/linux-elf.h
@@ -28,19 +28,33 @@
 #undef  TARGET_VERSION
 #define TARGET_VERSION  fputs (" (ARM GNU/Linux with ELF)", stderr);
 
+/*
+ * 'config.gcc' defines TARGET_BIG_ENDIAN_DEFAULT as 1 for arm*b-*
+ * (big endian) configurations.
+ */
+#if TARGET_BIG_ENDIAN_DEFAULT
+#define TARGET_ENDIAN_DEFAULT MASK_BIG_END
+#define TARGET_ENDIAN_OPTION "mbig-endian"
+#define TARGET_LINKER_EMULATION "armelfb_linux"
+#else
+#define TARGET_ENDIAN_DEFAULT 0
+#define TARGET_ENDIAN_OPTION "mlittle-endian"
+#define TARGET_LINKER_EMULATION "armelf_linux"
+#endif
+
 #undef  TARGET_DEFAULT_FLOAT_ABI
 #define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_HARD
 
 #undef  TARGET_DEFAULT
-#define TARGET_DEFAULT (0)
+#define TARGET_DEFAULT (TARGET_ENDIAN_DEFAULT)
 
 #define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm6
 
-#define SUBTARGET_EXTRA_LINK_SPEC " -m armelf_linux -p"
+#define SUBTARGET_EXTRA_LINK_SPEC " -m " TARGET_LINKER_EMULATION " -p"
 
 #undef  MULTILIB_DEFAULTS
 #define MULTILIB_DEFAULTS \
-	{ "marm", "mlittle-endian", "mhard-float", "mno-thumb-interwork" }
+	{ "marm", TARGET_ENDIAN_OPTION, "mhard-float", "mno-thumb-interwork" }
 
 /* Now we define the strings used to build the spec file.  */
 #undef  LIB_SPEC
@@ -61,7 +75,7 @@
    %{rdynamic:-export-dynamic} \
    %{!dynamic-linker:-dynamic-linker " LINUX_TARGET_INTERPRETER "} \
    -X \
-   %{mbig-endian:-EB}" \
+   %{mbig-endian:-EB} %{mlittle-endian:-EL}" \
    SUBTARGET_EXTRA_LINK_SPEC
 
 #undef  LINK_SPEC
diff --git a/gcc/config/avr/avr.c b/gcc/config/avr/avr.c
index 5367bd1..108c026 100644
--- a/gcc/config/avr/avr.c
+++ b/gcc/config/avr/avr.c
@@ -123,20 +123,26 @@ int avr_enhanced_p = 0;
 /* Assembler only.  */
 int avr_asm_only_p = 0;
 
+/* Usually holds the value 2, but could be 3 for the larger devices with a
+   3-byte program counter.  */
+int avr_pc_size = 2;
+
 struct base_arch_s {
   int asm_only;
   int enhanced;
   int mega;
+  int three_byte_pc;
   const char *const macro;
 };
 
 static const struct base_arch_s avr_arch_types[] = {
-  { 1, 0, 0, NULL },  /* unknown device specified */
-  { 1, 0, 0, "__AVR_ARCH__=1" },
-  { 0, 0, 0, "__AVR_ARCH__=2" },
-  { 0, 0, 1, "__AVR_ARCH__=3" },
-  { 0, 1, 0, "__AVR_ARCH__=4" },
-  { 0, 1, 1, "__AVR_ARCH__=5" }
+  { 1, 0, 0, 0, NULL },  /* unknown device specified */
+  { 1, 0, 0, 0, "__AVR_ARCH__=1" },
+  { 0, 0, 0, 0, "__AVR_ARCH__=2" },
+  { 0, 0, 1, 0, "__AVR_ARCH__=3" },
+  { 0, 1, 0, 0, "__AVR_ARCH__=4" },
+  { 0, 1, 1, 0, "__AVR_ARCH__=5" },
+  { 0, 1, 1, 1, "__AVR_ARCH__=6" }
 };
 
 struct mcu_type_s {
@@ -169,10 +175,19 @@ static const struct mcu_type_s avr_mcu_types[] = {
   { "at90s8515", 2, "__AVR_AT90S8515__" },
   { "at90c8534", 2, "__AVR_AT90C8534__" },
   { "at90s8535", 2, "__AVR_AT90S8535__" },
-  { "at86rf401", 2, "__AVR_AT86RF401__" },
     /* Classic + MOVW, <= 8K.  */
   { "attiny13",   2, "__AVR_ATtiny13__" },
   { "attiny2313", 2, "__AVR_ATtiny2313__" },
+  { "attiny24", 2, "__AVR_ATtiny24__" },
+  { "attiny44", 2, "__AVR_ATtiny44__" },
+  { "attiny84", 2, "__AVR_ATtiny84__" },
+  { "attiny25", 2, "__AVR_ATtiny25__" },
+  { "attiny45", 2, "__AVR_ATtiny45__" },
+  { "attiny85", 2, "__AVR_ATtiny85__" },
+  { "attiny261", 2, "__AVR_ATtiny261__" },
+  { "attiny461", 2, "__AVR_ATtiny461__" },
+  { "attiny861", 2, "__AVR_ATtiny861__" },
+  { "at86rf401", 2, "__AVR_AT86RF401__" },
     /* Classic, > 8K.  */
   { "avr3",      3, NULL },
   { "atmega103", 3, "__AVR_ATmega103__" },
@@ -187,25 +202,58 @@ static const struct mcu_type_s avr_mcu_types[] = {
   { "atmega88",   4, "__AVR_ATmega88__" },
   { "atmega8515", 4, "__AVR_ATmega8515__" },
   { "atmega8535", 4, "__AVR_ATmega8535__" },
+  { "at90pwm1",  4, "__AVR_AT90PWM1__" },
+  { "at90pwm2",  4, "__AVR_AT90PWM2__" },
+  { "at90pwm3",  4, "__AVR_AT90PWM3__" },
+  { "at90usb82",   4, "__AVR_AT90USB82__" },
     /* Enhanced, > 8K.  */
   { "avr5",      5, NULL },
   { "atmega16",  5, "__AVR_ATmega16__" },
   { "atmega161", 5, "__AVR_ATmega161__" },
   { "atmega162", 5, "__AVR_ATmega162__" },
   { "atmega163", 5, "__AVR_ATmega163__" },
+  { "atmega164p",5, "__AVR_ATmega164P__" },
   { "atmega165", 5, "__AVR_ATmega165__" },
+  { "atmega165p",5, "__AVR_ATmega165P__" },
   { "atmega168", 5, "__AVR_ATmega168__" },
   { "atmega169", 5, "__AVR_ATmega169__" },
+  { "atmega169p",5, "__AVR_ATmega169P__" },
   { "atmega32",  5, "__AVR_ATmega32__" },
   { "atmega323", 5, "__AVR_ATmega323__" },
+  { "atmega324p",5, "__AVR_ATmega324P__" },
   { "atmega325", 5, "__AVR_ATmega325__" },
+  { "atmega325p", 5, "__AVR_ATmega325P__" },
   { "atmega3250", 5, "__AVR_ATmega3250__" },
+  { "atmega3250p", 5, "__AVR_ATmega3250P__" },
+  { "atmega329", 5, "__AVR_ATmega329__" },
+  { "atmega329p", 5, "__AVR_ATmega329P__" },
+  { "atmega3290", 5, "__AVR_ATmega3290__" },
+  { "atmega3290p", 5, "__AVR_ATmega3290P__" },
+  { "atmega406", 5, "__AVR_ATmega406__" },
   { "atmega64",  5, "__AVR_ATmega64__" },
+  { "atmega640", 5, "__AVR_ATmega640__" },
+  { "atmega644", 5, "__AVR_ATmega644__" },
+  { "atmega644p",5, "__AVR_ATmega644P__" },
   { "atmega645", 5, "__AVR_ATmega645__" },
   { "atmega6450", 5, "__AVR_ATmega6450__" },
+  { "atmega649", 5, "__AVR_ATmega649__" },
+  { "atmega6490", 5, "__AVR_ATmega6490__" },
   { "atmega128", 5, "__AVR_ATmega128__" },
+  { "atmega1280",5, "__AVR_ATmega1280__" },
+  { "atmega1281",5, "__AVR_ATmega1281__" },
+  { "at90can32", 5, "__AVR_AT90CAN32__" },
+  { "at90can64", 5, "__AVR_AT90CAN64__" },
   { "at90can128", 5, "__AVR_AT90CAN128__" },
+  { "at90usb162",  5, "__AVR_AT90USB162__" },
+  { "at90usb646", 5, "__AVR_AT90USB646__" },
+  { "at90usb647", 5, "__AVR_AT90USB647__" },
+  { "at90usb1286", 5, "__AVR_AT90USB1286__" },
+  { "at90usb1287", 5, "__AVR_AT90USB1287__" },
   { "at94k",     5, "__AVR_AT94K__" },
+    /* 3-Byte PC */
+  { "avr6",      6, NULL },
+  { "atmega2560",     6, "__AVR_ATmega2560__" },
+  { "atmega2561",     6, "__AVR_ATmega2561__" },
     /* Assembler only.  */
   { "avr1",      1, NULL },
   { "at90s1200", 1, "__AVR_AT90S1200__" },
@@ -288,6 +336,11 @@ avr_override_options (void)
   avr_base_arch_macro = base->macro;
   avr_extra_arch_macro = t->macro;
 
+  if (base->three_byte_pc)
+    avr_pc_size = 3;
+  else
+    avr_pc_size = 2;
+
   if (optimize && !TARGET_NO_TABLEJUMP)
     avr_case_values_threshold = (!AVR_MEGA || TARGET_CALL_PROLOGUES) ? 8 : 17;
 
@@ -445,7 +498,7 @@ initial_elimination_offset (int from, int to)
       int offset = frame_pointer_needed ? 2 : 0;
 
       offset += avr_regs_to_save (NULL);
-      return get_frame_size () + 2 + 1 + offset;
+      return get_frame_size () + (avr_pc_size) + 1 + offset;
     }
 }
 
@@ -629,7 +682,6 @@ avr_output_function_prologue (FILE *file, HOST_WIDE_INT size)
   int reg;
   int interrupt_func_p;
   int signal_func_p;
-  int main_p;
   int live_seq;
   int minimize;
 
@@ -647,7 +699,6 @@ avr_output_function_prologue (FILE *file, HOST_WIDE_INT size)
 
   interrupt_func_p = interrupt_function_p (current_function_decl);
   signal_func_p = signal_function_p (current_function_decl);
-  main_p = MAIN_NAME_P (DECL_NAME (current_function_decl));
   live_seq = sequent_regs_live ();
   minimize = (TARGET_CALL_PROLOGUES
 	      && !interrupt_func_p && !signal_func_p && live_seq);
@@ -667,25 +718,14 @@ avr_output_function_prologue (FILE *file, HOST_WIDE_INT size)
 	       AS1 (clr,__zero_reg__)    "\n");
       prologue_size += 5;
     }
-  if (main_p)
-    {
-      fprintf (file, ("\t" 
-		      AS1 (ldi,r28) ",lo8(%s - " HOST_WIDE_INT_PRINT_DEC ")" CR_TAB
-		      AS1 (ldi,r29) ",hi8(%s - " HOST_WIDE_INT_PRINT_DEC ")" CR_TAB
-		      AS2 (out,__SP_H__,r29)     CR_TAB
-		      AS2 (out,__SP_L__,r28) "\n"),
-	       avr_init_stack, size, avr_init_stack, size);
-      
-      prologue_size += 4;
-    }
-  else if (minimize && (frame_pointer_needed || live_seq > 6)) 
+  if (minimize && (frame_pointer_needed || live_seq > 6)) 
     {
       fprintf (file, ("\t"
 		      AS1 (ldi, r26) ",lo8(" HOST_WIDE_INT_PRINT_DEC ")" CR_TAB
 		      AS1 (ldi, r27) ",hi8(" HOST_WIDE_INT_PRINT_DEC ")" CR_TAB), size, size);
 
-      fputs ((AS2 (ldi,r30,pm_lo8(1f)) CR_TAB
-	      AS2 (ldi,r31,pm_hi8(1f)) CR_TAB), file);
+      fputs ((AS2 (ldi,r30,lo8(gs(1f))) CR_TAB
+	      AS2 (ldi,r31,hi8(gs(1f))) CR_TAB), file);
       
       prologue_size += 4;
       
@@ -756,7 +796,6 @@ avr_output_function_epilogue (FILE *file, HOST_WIDE_INT size)
   int reg;
   int interrupt_func_p;
   int signal_func_p;
-  int main_p;
   int function_size;
   int live_seq;
   int minimize;
@@ -788,27 +827,12 @@ avr_output_function_epilogue (FILE *file, HOST_WIDE_INT size)
 
   interrupt_func_p = interrupt_function_p (current_function_decl);
   signal_func_p = signal_function_p (current_function_decl);
-  main_p = MAIN_NAME_P (DECL_NAME (current_function_decl));
+
   live_seq = sequent_regs_live ();
   minimize = (TARGET_CALL_PROLOGUES
 	      && !interrupt_func_p && !signal_func_p && live_seq);
   
-  if (main_p)
-    {
-      /* Return value from main() is already in the correct registers
-	 (r25:r24) as the exit() argument.  */
-      if (AVR_MEGA)
-	{
-	  fputs ("\t" AS1 (jmp,exit) "\n", file);
-	  epilogue_size += 2;
-	}
-      else
-	{
-	  fputs ("\t" AS1 (rjmp,exit) "\n", file);
-	  ++epilogue_size;
-	}
-    }
-  else if (minimize && (frame_pointer_needed || live_seq > 4))
+  if (minimize && (frame_pointer_needed || live_seq > 4))
     {
       fprintf (file, ("\t" AS2 (ldi, r30, %d) CR_TAB), live_seq);
       ++epilogue_size;
@@ -1066,7 +1090,7 @@ print_operand_address (FILE *file, rtx addr)
 	  && ((GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (addr))
 	      || GET_CODE (addr) == LABEL_REF))
 	{
-	  fprintf (file, "pm(");
+	  fprintf (file, "gs(");
 	  output_addr_const (file,addr);
 	  fprintf (file ,")");
 	}
@@ -4487,7 +4511,7 @@ avr_assemble_integer (rtx x, unsigned int size, int aligned_p)
       && ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (x))
 	  || GET_CODE (x) == LABEL_REF))
     {
-      fputs ("\t.word\tpm(", asm_out_file);
+      fputs ("\t.word\tgs(", asm_out_file);
       output_addr_const (asm_out_file, x);
       fputs (")\n", asm_out_file);
       return true;
@@ -5849,7 +5873,7 @@ avr_output_addr_vec_elt (FILE *stream, int value)
 {
   progmem_section ();
   if (AVR_MEGA)
-    fprintf (stream, "\t.word pm(.L%d)\n", value);
+    fprintf (stream, "\t.word gs(.L%d)\n", value);
   else
     fprintf (stream, "\trjmp .L%d\n", value);
 
diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
index bcd651b..17d1fe0 100644
--- a/gcc/config/avr/avr.h
+++ b/gcc/config/avr/avr.h
@@ -33,6 +33,10 @@ Boston, MA 02110-1301, USA.  */
 	builtin_define (avr_extra_arch_macro);	\
       if (avr_asm_only_p)			\
 	builtin_define ("__AVR_ASM_ONLY__");	\
+      if (avr_pc_size == 2)			\
+	builtin_define ("__AVR_2_BYTE_PC__");	\
+      if (avr_pc_size == 3)			\
+	builtin_define ("__AVR_3_BYTE_PC__");	\
       if (avr_enhanced_p)			\
 	builtin_define ("__AVR_ENHANCED__");	\
       if (avr_mega_p)				\
@@ -47,10 +51,14 @@ extern const char *avr_extra_arch_macro;
 extern int avr_mega_p;
 extern int avr_enhanced_p;
 extern int avr_asm_only_p;
+extern int avr_pc_size;
 
 #define AVR_MEGA (avr_mega_p && !TARGET_SHORT_CALLS)
 #define AVR_ENHANCED (avr_enhanced_p)
 
+#define AVR_3_BYTE_PC (avr_pc_size == 3)
+#define AVR_2_BYTE_PC (avr_pc_size == 2)
+
 #define TARGET_VERSION fprintf (stderr, " (GNU assembler syntax)");
 
 #define OVERRIDE_OPTIONS avr_override_options ()
@@ -634,6 +642,8 @@ do {									 \
 /* Globalizing directive for a label.  */
 #define GLOBAL_ASM_OP ".global\t"
 
+#define SET_ASM_OP    "\t.set\t"
+
 #define ASM_WEAKEN_LABEL(FILE, NAME)	\
   do					\
     {					\
@@ -750,23 +760,81 @@ extern int avr_case_values_threshold;
 
 #define CPP_SPEC "%{posix:-D_POSIX_SOURCE}"
 
-#define CC1_SPEC "%{profile:-p}"
+#define CC1_SPEC "%{profile:-p} -fno-delete-null-pointer-checks"
 
 #define CC1PLUS_SPEC "%{!frtti:-fno-rtti} \
     %{!fenforce-eh-specs:-fno-enforce-eh-specs} \
-    %{!fexceptions:-fno-exceptions}"
-/* A C string constant that tells the GCC drvier program options to
+    %{!fexceptions:-fno-exceptions} \
+    -fno-delete-null-pointer-checks"
+/* A C string constant that tells the GCC driver program options to
    pass to `cc1plus'.  */
 
 #define ASM_SPEC "%{mmcu=*:-mmcu=%*}"
 
 #define LINK_SPEC " %{!mmcu*:-m avr2}\
-%{mmcu=at90s1200|mmcu=attiny11|mmcu=attiny12|mmcu=attiny15|mmcu=attiny28:-m avr1} \
-%{mmcu=attiny22|mmcu=attiny26|mmcu=at90s2*|mmcu=at90s4*|mmcu=at90s8*|mmcu=at90c8*|mmcu=at86rf401|mmcu=attiny13|mmcu=attiny2313:-m avr2}\
-%{mmcu=atmega103|mmcu=atmega603|mmcu=at43*|mmcu=at76*:-m avr3}\
-%{mmcu=atmega8*|mmcu=atmega48:-m avr4}\
-%{mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega64*|mmcu=atmega128|mmcu=at90can128|mmcu=at94k:-m avr5}\
-%{mmcu=atmega325|mmcu=atmega3250|mmcu=atmega48|mmcu=atmega88|mmcu=atmega64|mmcu=atmega645|mmcu=atmega6450|mmcu=atmega128|mmcu=at90can128|mmcu=at90can128|mmcu=atmega162|mmcu=atmega165|mmcu=atmega168|mmcu=atmega169: -Tdata 0x800100} "
+%{mmcu=at90s1200|\
+  mmcu=attiny11|\
+  mmcu=attiny12|\
+  mmcu=attiny15|\
+  mmcu=attiny28:-m avr1}\
+%{mmcu=attiny22|\
+  mmcu=attiny26|\
+  mmcu=at90s2*|\
+  mmcu=at90s4*|\
+  mmcu=at90s8*|\
+  mmcu=at90c8*|\
+  mmcu=at86rf401|\
+  mmcu=attiny13|\
+  mmcu=attiny2313|\
+  mmcu=attiny24|\
+  mmcu=attiny25|\
+  mmcu=attiny261|\
+  mmcu=attiny4*|\
+  mmcu=attiny8*:-m avr2}\
+%{mmcu=atmega103|\
+  mmcu=atmega603|\
+  mmcu=at43*|\
+  mmcu=at76*:-m avr3}\
+%{mmcu=atmega8*|\
+  mmcu=atmega48|\
+  mmcu=at90pwm*|\
+  mmcu=at90usb82:-m avr4}\
+%{mmcu=atmega16*|\
+  mmcu=atmega32*|\
+  mmcu=atmega406|\
+  mmcu=atmega64*|\
+  mmcu=atmega128*|\
+  mmcu=at90can*|\
+  mmcu=at90usb162|\
+  mmcu=at90usb64*|\
+  mmcu=at90usb128*|\
+  mmcu=at94k:-m avr5}\
+%{mmcu=atmega256*:-m avr6}\
+%{mmcu=atmega324*|\
+  mmcu=atmega325*|\
+  mmcu=atmega329*|\
+  mmcu=atmega406|\
+  mmcu=atmega48|\
+  mmcu=atmega88|\
+  mmcu=atmega64|\
+  mmcu=atmega644*|\
+  mmcu=atmega645|\
+  mmcu=atmega6450|\
+  mmcu=atmega649|\
+  mmcu=atmega6490|\
+  mmcu=atmega128|\
+  mmcu=atmega162|\
+  mmcu=atmega164*|\
+  mmcu=atmega165*|\
+  mmcu=atmega168|\
+  mmcu=atmega169*|\
+  mmcu=at90can*|\
+  mmcu=at90pwm*|\
+  mmcu=at90usb*: -Tdata 0x800100}\
+%{mmcu=atmega640|\
+  mmcu=atmega1280|\
+  mmcu=atmega1281|\
+  mmcu=atmega256*: -Tdata 0x800200} "
 
 #define LIB_SPEC \
   "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lc }}}}}"
@@ -802,6 +870,15 @@ extern int avr_case_values_threshold;
 %{mmcu=at86rf401:crt86401.o%s} \
 %{mmcu=attiny13:crttn13.o%s} \
 %{mmcu=attiny2313:crttn2313.o%s} \
+%{mmcu=attiny24:crttn24.o%s} \
+%{mmcu=attiny44:crttn44.o%s} \
+%{mmcu=attiny84:crttn84.o%s} \
+%{mmcu=attiny25:crttn25.o%s} \
+%{mmcu=attiny45:crttn45.o%s} \
+%{mmcu=attiny85:crttn85.o%s} \
+%{mmcu=attiny261:crttn261.o%s} \
+%{mmcu=attiny461:crttn461.o%s} \
+%{mmcu=attiny861:crttn861.o%s} \
 %{mmcu=atmega103|mmcu=avr3:crtm103.o%s} \
 %{mmcu=atmega603:crtm603.o%s} \
 %{mmcu=at43usb320:crt43320.o%s} \
@@ -812,22 +889,53 @@ extern int avr_case_values_threshold;
 %{mmcu=atmega88:crtm88.o%s} \
 %{mmcu=atmega8515:crtm8515.o%s} \
 %{mmcu=atmega8535:crtm8535.o%s} \
+%{mmcu=at90pwm1:crt90pwm1.o%s} \
+%{mmcu=at90pwm2:crt90pwm2.o%s} \
+%{mmcu=at90pwm3:crt90pwm3.o%s} \
 %{mmcu=atmega16:crtm16.o%s} \
 %{mmcu=atmega161|mmcu=avr5:crtm161.o%s} \
 %{mmcu=atmega162:crtm162.o%s} \
 %{mmcu=atmega163:crtm163.o%s} \
+%{mmcu=atmega164p:crtm164p.o%s} \
 %{mmcu=atmega165:crtm165.o%s} \
+%{mmcu=atmega165p:crtm165p.o%s} \
 %{mmcu=atmega168:crtm168.o%s} \
 %{mmcu=atmega169:crtm169.o%s} \
+%{mmcu=atmega169p:crtm169p.o%s} \
 %{mmcu=atmega32:crtm32.o%s} \
 %{mmcu=atmega323:crtm323.o%s} \
+%{mmcu=atmega324p:crtm324p.o%s} \
 %{mmcu=atmega325:crtm325.o%s} \
+%{mmcu=atmega325p:crtm325p.o%s} \
 %{mmcu=atmega3250:crtm3250.o%s} \
+%{mmcu=atmega3250p:crtm3250p.o%s} \
+%{mmcu=atmega329:crtm329.o%s} \
+%{mmcu=atmega329p:crtm329p.o%s} \
+%{mmcu=atmega3290:crtm3290.o%s} \
+%{mmcu=atmega3290p:crtm3290p.o%s} \
+%{mmcu=atmega406:crtm406.o%s} \
 %{mmcu=atmega64:crtm64.o%s} \
-%{mmcu=atmega645:crtm6450.o%s} \
+%{mmcu=atmega640:crtm640.o%s} \
+%{mmcu=atmega644:crtm644.o%s} \
+%{mmcu=atmega644p:crtm644p.o%s} \
+%{mmcu=atmega645:crtm645.o%s} \
 %{mmcu=atmega6450:crtm6450.o%s} \
+%{mmcu=atmega649:crtm649.o%s} \
+%{mmcu=atmega6490:crtm6490.o%s} \
 %{mmcu=atmega128:crtm128.o%s} \
+%{mmcu=atmega1280:crtm1280.o%s} \
+%{mmcu=atmega1281:crtm1281.o%s} \
+%{mmcu=atmega2560:crtm2560.o%s} \
+%{mmcu=atmega2561:crtm2561.o%s} \
+%{mmcu=at90can32:crtcan32.o%s} \
+%{mmcu=at90can64:crtcan64.o%s} \
 %{mmcu=at90can128:crtcan128.o%s} \
+%{mmcu=at90usb82:crtusb82.o%s} \
+%{mmcu=at90usb162:crtusb162.o%s} \
+%{mmcu=at90usb646:crtusb646.o%s} \
+%{mmcu=at90usb647:crtusb647.o%s} \
+%{mmcu=at90usb1286:crtusb1286.o%s} \
+%{mmcu=at90usb1287:crtusb1287.o%s} \
 %{mmcu=at94k:crtat94k.o%s}"
 
 #define EXTRA_SPECS {"crt_binutils", CRT_BINUTILS_SPECS},
@@ -865,8 +973,12 @@ extern int avr_case_values_threshold;
 /* zero register r1 */
 #define ZERO_REGNO 1
 
+#define DWARF2_DEBUGGING_INFO 1
 #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG
 
+/* Offset from the frame pointer register value to the top of the stack.  */
+#define FRAME_POINTER_CFA_OFFSET(FNDECL) 0
+
 #define DWARF2_DEBUGGING_INFO 1
 
 #define OBJECT_FORMAT_ELF
diff --git a/gcc/config/avr/avr.md b/gcc/config/avr/avr.md
index 59d35f0..b609ee6 100644
--- a/gcc/config/avr/avr.md
+++ b/gcc/config/avr/avr.md
@@ -2087,22 +2087,47 @@
   "(register_operand (operands[0], HImode) || CONSTANT_P (operands[0]))"
   "*{
   if (which_alternative==0)
-     return \"icall\";
+    {
+      if (AVR_3_BYTE_PC)
+        return \"eicall\";
+      else
+        return \"icall\";
+    }
   else if (which_alternative==1)
     {
       if (AVR_ENHANCED)
-	return (AS2 (movw, r30, %0) CR_TAB
-		\"icall\");
+        {
+          if (AVR_3_BYTE_PC)
+            return (AS2 (movw, r30, %0) CR_TAB
+                    \"eicall\");
+          else
+            return (AS2 (movw, r30, %0) CR_TAB
+                    \"icall\");
+        }
       else
-	return (AS2 (mov, r30, %A0) CR_TAB
-		AS2 (mov, r31, %B0) CR_TAB
-		\"icall\");
+        {
+          if (AVR_3_BYTE_PC)
+	    return (AS2 (mov, r30, %A0) CR_TAB
+                    AS2 (mov, r31, %B0) CR_TAB
+                    \"eicall\");
+          else
+	    return (AS2 (mov, r30, %A0) CR_TAB
+                    AS2 (mov, r31, %B0) CR_TAB
+                    \"icall\");
+        }
     }
   else if (which_alternative==2)
     return AS1(%~call,%c0);
-  return (AS2 (ldi,r30,lo8(%0)) CR_TAB
-          AS2 (ldi,r31,hi8(%0)) CR_TAB
-          \"icall\");
+
+
+  if (AVR_3_BYTE_PC)
+    return (AS2 (ldi,r30,lo8(%0)) CR_TAB
+            AS2 (ldi,r31,hi8(%0)) CR_TAB
+            \"eicall\");
+  else
+    return (AS2 (ldi,r30,lo8(%0)) CR_TAB
+            AS2 (ldi,r31,hi8(%0)) CR_TAB
+            \"icall\");
 }"
   [(set_attr "cc" "clobber,clobber,clobber,clobber")
    (set_attr_alternative "length"
@@ -2124,22 +2149,46 @@
   "(register_operand (operands[0], VOIDmode) || CONSTANT_P (operands[0]))"
   "*{
   if (which_alternative==0)
-     return \"icall\";
+    {
+      if (AVR_3_BYTE_PC)
+        return \"eicall\";
+      else
+        return \"icall\";
+    }
   else if (which_alternative==1)
     {
       if (AVR_ENHANCED)
-	return (AS2 (movw, r30, %1) CR_TAB
-		\"icall\");
+        {
+          if (AVR_3_BYTE_PC)
+            return (AS2 (movw, r30, %1) CR_TAB
+                    \"eicall\");
+          else
+            return (AS2 (movw, r30, %1) CR_TAB
+                    \"icall\");
+        }
       else
-	return (AS2 (mov, r30, %A1) CR_TAB
-		AS2 (mov, r31, %B1) CR_TAB
-		\"icall\");
+        {
+          if (AVR_3_BYTE_PC)
+            return (AS2 (mov, r30, %A1) CR_TAB
+                    AS2 (mov, r31, %B1) CR_TAB
+                    \"eicall\");
+          else
+            return (AS2 (mov, r30, %A1) CR_TAB
+                    AS2 (mov, r31, %B1) CR_TAB
+                    \"icall\");
+        }
     }
   else if (which_alternative==2)
     return AS1(%~call,%c1);
-  return (AS2 (ldi, r30, lo8(%1)) CR_TAB
-          AS2 (ldi, r31, hi8(%1)) CR_TAB
-          \"icall\");
+
+  if (AVR_3_BYTE_PC)
+    return (AS2 (ldi, r30, lo8(%1)) CR_TAB
+            AS2 (ldi, r31, hi8(%1)) CR_TAB
+            \"eicall\");
+  else
+    return (AS2 (ldi, r30, lo8(%1)) CR_TAB
+            AS2 (ldi, r31, hi8(%1)) CR_TAB
+            \"icall\");
 }"
   [(set_attr "cc" "clobber,clobber,clobber,clobber")
    (set_attr_alternative "length"
@@ -2169,13 +2218,20 @@
 ; indirect jump
 (define_insn "indirect_jump"
   [(set (pc) (match_operand:HI 0 "register_operand" "!z,*r"))]
-  ""
+  "AVR_2_BYTE_PC"
   "@
 	ijmp
 	push %A0\;push %B0\;ret"
   [(set_attr "length" "1,3")
    (set_attr "cc" "none,none")])
 
+(define_insn "*indirect_jump_avr6"
+  [(set (pc) (match_operand:HI 0 "register_operand" "z"))]
+  "AVR_3_BYTE_PC"
+  "eijmp"
+  [(set_attr "length" "1")
+   (set_attr "cc" "none")])
+
 ;; table jump
 
 ;; Table made from "rjmp" instructions for <=8K devices.
@@ -2183,7 +2239,7 @@
   [(set (pc) (unspec:HI [(match_operand:HI 0 "register_operand" "!z,*r")] 1))
    (use (label_ref (match_operand 1 "" "")))
    (clobber (match_dup 0))]
-  "!AVR_MEGA"
+  "(!AVR_MEGA) && (AVR_2_BYTE_PC)"
   "@
 	ijmp
 	push %A0\;push %B0\;ret"
@@ -2200,11 +2256,26 @@
   [(set_attr "length" "2")
    (set_attr "cc" "clobber")])
 
+(define_insn "*tablejump_avr6"
+  [(set (pc) (unspec:HI [(match_operand:HI 0 "register_operand" "z")]
+                        1))
+   (use (label_ref (match_operand 1 "" "")))
+   (clobber (match_dup 0))]
+  "AVR_MEGA && AVR_ENHANCED && AVR_3_BYTE_PC"
+  "lsl r30
+	rol r31
+	lpm __tmp_reg__,Z+
+	lpm r31,Z
+	mov r30,__tmp_reg__
+	eijmp"
+  [(set_attr "length" "6")
+   (set_attr "cc" "clobber")])
+
 (define_insn "*tablejump_enh"
   [(set (pc) (unspec:HI [(match_operand:HI 0 "register_operand" "z")] 1))
    (use (label_ref (match_operand 1 "" "")))
    (clobber (match_dup 0))]
-  "AVR_MEGA && AVR_ENHANCED"
+  "AVR_MEGA && AVR_ENHANCED && AVR_2_BYTE_PC"
   "lsl r30
 	rol r31
 	lpm __tmp_reg__,Z+
@@ -2218,7 +2289,7 @@
   [(set (pc) (unspec:HI [(match_operand:HI 0 "register_operand" "z")] 1))
    (use (label_ref (match_operand 1 "" "")))
    (clobber (match_dup 0))]
-  "AVR_MEGA"
+  "AVR_MEGA && AVR_2_BYTE_PC"
   "lsl r30
 	rol r31
 	lpm
diff --git a/gcc/config/avr/libgcc.S b/gcc/config/avr/libgcc.S
index b5ef337..3170fca 100644
--- a/gcc/config/avr/libgcc.S
+++ b/gcc/config/avr/libgcc.S
@@ -593,7 +593,12 @@ __prologue_saves__:
 	out	__SP_H__,r29
 	out	__SREG__,__tmp_reg__
 	out	__SP_L__,r28
+#if defined (__AVR_3_BYTE_PC__)
+	eijmp
+#else
 	ijmp
+#endif
+
 .endfunc
 #endif /* defined (L_prologue) */
 
@@ -672,13 +677,22 @@ __tablejump__:
 	lpm	__tmp_reg__, Z+
 	lpm	r31, Z
 	mov	r30, __tmp_reg__
+
+#if defined (__AVR_3_BYTE_PC__)
+	eijmp
+#else
 	ijmp
+#endif
+
 #else
 	lpm
 	adiw	r30, 1
 	push	r0
 	lpm
 	push	r0
+#if defined (__AVR_3_BYTE_PC__)
+        push    __zero_reg__
+#endif
 	ret
 #endif
 	.endfunc
diff --git a/gcc/config/avr/t-avr b/gcc/config/avr/t-avr
index 4209e9c..4091893 100644
--- a/gcc/config/avr/t-avr
+++ b/gcc/config/avr/t-avr
@@ -37,26 +37,69 @@ fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/avr/t-avr
 
 FPBIT = fp-bit.c
 
-MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr3/mmcu=avr4/mmcu=avr5
-MULTILIB_DIRNAMES = avr2 avr3 avr4 avr5
+MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr3/mmcu=avr4/mmcu=avr5/mmcu=avr6
+MULTILIB_DIRNAMES = avr2 avr3 avr4 avr5 avr6
 
 # The many avr2 matches are not listed here - this is the default.
 MULTILIB_MATCHES = \
-	mmcu?avr3=mmcu?atmega103 mmcu?avr3=mmcu?atmega603 \
-	mmcu?avr3=mmcu?at43usb320 mmcu?avr3=mmcu?at43usb355 \
+	mmcu?avr3=mmcu?atmega103 \
+	mmcu?avr3=mmcu?atmega603 \
+	mmcu?avr3=mmcu?at43usb320 \
+	mmcu?avr3=mmcu?at43usb355 \
 	mmcu?avr3=mmcu?at76c711 \
-	mmcu?avr4=mmcu?atmega8515 mmcu?avr4=mmcu?atmega8535 \
-	mmcu?avr4=mmcu?atmega8 mmcu?avr4=mmcu?atmega48 \
+	mmcu?avr4=mmcu?atmega48 \
+	mmcu?avr4=mmcu?atmega8 \
+	mmcu?avr4=mmcu?atmega8515 \
+	mmcu?avr4=mmcu?atmega8535 \
 	mmcu?avr4=mmcu?atmega88 \
-	mmcu?avr5=mmcu?atmega161 mmcu?avr5=mmcu?atmega162 \
-	mmcu?avr5=mmcu?atmega163 mmcu?avr5=mmcu?atmega169 \
-	mmcu?avr5=mmcu?atmega16 mmcu?avr5=mmcu?atmega168 \
+	mmcu?avr4=mmcu?at90pwm1 \
+	mmcu?avr4=mmcu?at90pwm2 \
+	mmcu?avr4=mmcu?at90pwm3 \
+	mmcu?avr4=mmcu?at90usb82 \
+	mmcu?avr5=mmcu?atmega16 \
+	mmcu?avr5=mmcu?atmega161 \
+	mmcu?avr5=mmcu?atmega162 \
+	mmcu?avr5=mmcu?atmega163 \
+	mmcu?avr5=mmcu?atmega164p \
 	mmcu?avr5=mmcu?atmega165 \
-	mmcu?avr5=mmcu?atmega323 mmcu?avr5=mmcu?atmega32 \
-	mmcu?avr5=mmcu?atmega325 mmcu?avr5=mmcu?atmega3250 \
-	mmcu?avr5=mmcu?atmega64  mmcu?avr5=mmcu?atmega128 \
-	mmcu?avr5=mmcu?atmega645 mmcu?avr5=mmcu?atmega6450 \
-	mmcu?avr5=mmcu?at94k mmcu?avr5=mmcu?at90can128
+	mmcu?avr5=mmcu?atmega165p \
+	mmcu?avr5=mmcu?atmega168 \
+	mmcu?avr5=mmcu?atmega169 \
+	mmcu?avr5=mmcu?atmega169p \
+	mmcu?avr5=mmcu?atmega32 \
+	mmcu?avr5=mmcu?atmega323 \
+	mmcu?avr5=mmcu?atmega324p \
+	mmcu?avr5=mmcu?atmega325 \
+	mmcu?avr5=mmcu?atmega325p \
+	mmcu?avr5=mmcu?atmega3250 \
+	mmcu?avr5=mmcu?atmega3250p \
+	mmcu?avr5=mmcu?atmega329 \
+	mmcu?avr5=mmcu?atmega329p \
+	mmcu?avr5=mmcu?atmega3290 \
+	mmcu?avr5=mmcu?atmega3290p \
+	mmcu?avr5=mmcu?atmega406 \
+	mmcu?avr5=mmcu?atmega64  \
+	mmcu?avr5=mmcu?atmega640 \
+	mmcu?avr5=mmcu?atmega644 \
+	mmcu?avr5=mmcu?atmega644p \
+	mmcu?avr5=mmcu?atmega645 \
+	mmcu?avr5=mmcu?atmega6450 \
+	mmcu?avr5=mmcu?atmega649 \
+	mmcu?avr5=mmcu?atmega6490 \
+	mmcu?avr5=mmcu?atmega128 \
+	mmcu?avr5=mmcu?atmega1280 \
+	mmcu?avr5=mmcu?atmega1281 \
+	mmcu?avr5=mmcu?at90can32 \
+	mmcu?avr5=mmcu?at90can64 \
+	mmcu?avr5=mmcu?at90can128 \
+	mmcu?avr5=mmcu?at90usb162 \
+	mmcu?avr5=mmcu?at90usb646 \
+	mmcu?avr5=mmcu?at90usb647 \
+	mmcu?avr5=mmcu?at90usb1286 \
+	mmcu?avr5=mmcu?at90usb1287 \
+	mmcu?avr5=mmcu?at94k \
+	mmcu?avr6=mmcu?atmega2560 \
+	mmcu?avr6=mmcu?atmega2561
 
 MULTILIB_EXCEPTIONS =
 
diff --git a/gcc/config/cris/t-linux b/gcc/config/cris/t-linux
index 31acfc4..65c3000 100644
--- a/gcc/config/cris/t-linux
+++ b/gcc/config/cris/t-linux
@@ -1,6 +1,2 @@
 TARGET_LIBGCC2_CFLAGS += -fPIC
 CRTSTUFF_T_CFLAGS_S = $(TARGET_LIBGCC2_CFLAGS)
-
-# We *know* we have a limits.h in the glibc library, with extra
-# definitions needed for e.g. libgfortran.
-LIMITS_H_TEST = :
diff --git a/gcc/config/i386/crtfastmath.c b/gcc/config/i386/crtfastmath.c
index fad1d57..f7f7f85 100644
--- a/gcc/config/i386/crtfastmath.c
+++ b/gcc/config/i386/crtfastmath.c
@@ -37,6 +37,23 @@
 #define FXSAVE	(1 << 24)
 #define SSE	(1 << 25)
 
+struct
+{
+	unsigned short int cwd;
+	unsigned short int swd;
+	unsigned short int twd;
+	unsigned short int fop;
+	long int fip;
+	long int fcs;
+	long int foo;
+	long int fos;
+	long int mxcsr;
+	long int mxcsr_mask;
+	long int st_space[32];
+	long int xmm_space[32];
+	long int padding[56];
+} __attribute__ ((aligned (16))) fxsave;
+
 static void __attribute__((constructor))
 set_fast_math (void)
 {
@@ -75,22 +92,6 @@ set_fast_math (void)
       if (edx & FXSAVE)
 	{
 	  /* Check if DAZ is available.  */
-	  struct
-	    {
-	      unsigned short int cwd;
-	      unsigned short int swd;
-	      unsigned short int twd;
-	      unsigned short int fop;
-	      long int fip;
-	      long int fcs;
-	      long int foo;
-	      long int fos;
-	      long int mxcsr;
-	      long int mxcsr_mask;
-	      long int st_space[32];
-	      long int xmm_space[32];
-	      long int padding[56];
-	    } __attribute__ ((aligned (16))) fxsave;
 
 	  __builtin_memset (&fxsave, 0, sizeof (fxsave));
 
diff --git a/gcc/config/i386/linux-unwind.h b/gcc/config/i386/linux-unwind.h
index 6ca1309..a62ef54 100644
--- a/gcc/config/i386/linux-unwind.h
+++ b/gcc/config/i386/linux-unwind.h
@@ -51,7 +51,7 @@ x86_64_fallback_frame_state (struct _Unwind_Context *context,
   if (*(unsigned char *)(pc+0) == 0x48
       && *(unsigned long *)(pc+1) == 0x050f0000000fc0c7)
     {
-      struct ucontext *uc_ = context->cfa;
+      ucontext_t *uc_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
          The aliasing warning is correct, but should not be a problem
          because it does not alias anything.  */
@@ -136,10 +136,10 @@ x86_fallback_frame_state (struct _Unwind_Context *context,
     {
       struct rt_sigframe {
 	int sig;
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
-	struct siginfo info;
-	struct ucontext uc;
+	siginfo_t info;
+	ucontext_t uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
          The aliasing warning is correct, but should not be a problem
diff --git a/gcc/config/ia64/crtbegin.asm b/gcc/config/ia64/crtbegin.asm
index e040916..c17ecb8 100644
--- a/gcc/config/ia64/crtbegin.asm
+++ b/gcc/config/ia64/crtbegin.asm
@@ -255,3 +255,7 @@ __do_jv_register_classes:
 .weak __cxa_finalize
 #endif
 .weak _Jv_RegisterClasses
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crtend.asm b/gcc/config/ia64/crtend.asm
index 66eaa01..1068af7 100644
--- a/gcc/config/ia64/crtend.asm
+++ b/gcc/config/ia64/crtend.asm
@@ -122,3 +122,7 @@ __do_global_ctors_aux:
 
 	br.ret.sptk.many rp
 	.endp __do_global_ctors_aux
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crti.asm b/gcc/config/ia64/crti.asm
index a2d1e12..d44fec8 100644
--- a/gcc/config/ia64/crti.asm
+++ b/gcc/config/ia64/crti.asm
@@ -64,3 +64,7 @@ _fini:
 	.body
 
 # end of crti.asm
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crtn.asm b/gcc/config/ia64/crtn.asm
index 52ec47c..badc56a 100644
--- a/gcc/config/ia64/crtn.asm
+++ b/gcc/config/ia64/crtn.asm
@@ -54,3 +54,7 @@
 	br.ret.sptk.many b0
 
 # end of crtn.asm
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/lib1funcs.asm b/gcc/config/ia64/lib1funcs.asm
index 245a8bb..f3af11b 100644
--- a/gcc/config/ia64/lib1funcs.asm
+++ b/gcc/config/ia64/lib1funcs.asm
@@ -792,3 +792,7 @@ __floattitf:
 	}
 	.endp __floattitf
 #endif
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/linux-unwind.h b/gcc/config/ia64/linux-unwind.h
index 8b2878e..bbc77e6 100644
--- a/gcc/config/ia64/linux-unwind.h
+++ b/gcc/config/ia64/linux-unwind.h
@@ -51,7 +51,7 @@ ia64_fallback_frame_state (struct _Unwind_Context *context,
       struct sigframe {
 	char scratch[16];
 	unsigned long sig_number;
-	struct siginfo *info;
+	siginfo_t *info;
 	struct sigcontext *sc;
       } *frame_ = (struct sigframe *)context->psp;
       struct sigcontext *sc = frame_->sc;
@@ -130,7 +130,7 @@ ia64_handle_unwabi (struct _Unwind_Context *context, _Unwind_FrameState *fs)
       struct sigframe {
 	char scratch[16];
 	unsigned long sig_number;
-	struct siginfo *info;
+	siginfo_t *info;
 	struct sigcontext *sc;
       } *frame = (struct sigframe *)context->psp;
       struct sigcontext *sc = frame->sc;
diff --git a/gcc/config/ia64/linux.h b/gcc/config/ia64/linux.h
index d933437..3cc7b00 100644
--- a/gcc/config/ia64/linux.h
+++ b/gcc/config/ia64/linux.h
@@ -5,6 +5,8 @@
 
 #define TARGET_VERSION fprintf (stderr, " (IA-64) Linux");
 
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
 /* This is for -profile to use -lc_p instead of -lc.  */
 #undef CC1_SPEC
 #define CC1_SPEC "%{profile:-p} %{G*}"
diff --git a/gcc/config/mips/linux-unwind.h b/gcc/config/mips/linux-unwind.h
index 4152138..d3bcc70 100644
--- a/gcc/config/mips/linux-unwind.h
+++ b/gcc/config/mips/linux-unwind.h
@@ -73,7 +73,7 @@ mips_fallback_frame_state (struct _Unwind_Context *context,
     {
       struct rt_sigframe {
 	u_int32_t  trampoline[2];
-	struct siginfo info;
+	siginfo_t info;
 	_sig_ucontext_t uc;
       } *rt_ = context->ra;
       sc = &rt_->uc.uc_mcontext;
diff --git a/gcc/config/mips/linux.h b/gcc/config/mips/linux.h
index d2a30bd..01617b7 100644
--- a/gcc/config/mips/linux.h
+++ b/gcc/config/mips/linux.h
@@ -172,7 +172,7 @@ Boston, MA 02110-1301, USA.  */
 #undef LIB_SPEC
 #define LIB_SPEC "\
 %{shared: -lc} \
-%{!shared: %{pthread:-lpthread} \
-  %{profile:-lc_p} %{!profile: -lc}}"
+%{pthread:-lpthread} \
+%{!shared: %{profile:-lc_p} %{!profile: -lc}}"
 
 #define MD_UNWIND_SUPPORT "config/mips/linux-unwind.h"
diff --git a/gcc/config/mips/linux64.h b/gcc/config/mips/linux64.h
index 25455b4..49e36dc 100644
--- a/gcc/config/mips/linux64.h
+++ b/gcc/config/mips/linux64.h
@@ -33,8 +33,8 @@ Boston, MA 02110-1301, USA.  */
 #undef LIB_SPEC
 #define LIB_SPEC "\
 %{shared: -lc} \
-%{!shared: %{pthread:-lpthread} \
-  %{profile:-lc_p} %{!profile: -lc}}"
+%{pthread:-lpthread} \
+%{!shared: %{profile:-lc_p} %{!profile: -lc}}"
 
 #undef LINK_SPEC
 #define LINK_SPEC "\
@@ -58,11 +58,6 @@ Boston, MA 02110-1301, USA.  */
 #undef LOCAL_LABEL_PREFIX
 #define LOCAL_LABEL_PREFIX (TARGET_OLDABI ? "$" : ".")
 
-/* The size in bytes of a DWARF field indicating an offset or length
-   relative to a debug info section, specified to be 4 bytes in the DWARF-2
-   specification.  The SGI/MIPS ABI defines it to be the same as PTR_SIZE.  */
-#define DWARF_OFFSET_SIZE PTR_SIZE
-
 /* GNU/Linux doesn't use the same floating-point format that IRIX uses
    for long double.  There's no need to override this here, since
    ieee_quad_format is the default, but let's put this here to make
diff --git a/gcc/config/netbsd-elf.h b/gcc/config/netbsd-elf.h
index 9a56de2..cdb5fa2 100644
--- a/gcc/config/netbsd-elf.h
+++ b/gcc/config/netbsd-elf.h
@@ -83,6 +83,7 @@ Boston, MA 02110-1301, USA.  */
 #define NETBSD_LINK_SPEC_ELF \
   "%{assert*} %{R*} %{rpath*} \
    %{shared:-shared} \
+   %{symbolic:-Bsymbolic} \
    %{!shared: \
      -dc -dp \
      %{!nostdlib: \
diff --git a/gcc/config/pa/linux-unwind.h b/gcc/config/pa/linux-unwind.h
index 36b9b38..7474468 100644
--- a/gcc/config/pa/linux-unwind.h
+++ b/gcc/config/pa/linux-unwind.h
@@ -63,8 +63,8 @@ pa32_fallback_frame_state (struct _Unwind_Context *context,
   int i;
   struct sigcontext *sc;
   struct rt_sigframe {
-    struct siginfo info;
-    struct ucontext uc;
+    siginfo_t info;
+    ucontext_t uc;
   } *frame;
 
   /* rt_sigreturn trampoline:
diff --git a/gcc/config/pa/pa-modes.def b/gcc/config/pa/pa-modes.def
index d9602fd..b85d3ba 100644
--- a/gcc/config/pa/pa-modes.def
+++ b/gcc/config/pa/pa-modes.def
@@ -1,5 +1,5 @@
 /* Definitions of target machine for GNU compiler, for the HP Spectrum.
-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003, 2006 Free Software Foundation, Inc.
    Contributed by Michael Tiemann (tiemann@cygnus.com) of Cygnus Support
    and Tim Moore (moore@defmacro.cs.utah.edu) of the Center for
    Software Science at the University of Utah.
@@ -21,8 +21,13 @@ along with GCC; see the file COPYING.  If not, write to
 the Free Software Foundation, 51 Franklin Street, Fifth Floor,
 Boston, MA 02110-1301, USA.  */
 
+/* PA-RISC has the same reversed quiet bit as MIPS.
+   ??? Why is this called the MIPS format.  */
+RESET_FLOAT_FORMAT (SF, mips_single_format);
+RESET_FLOAT_FORMAT (DF, mips_double_format);
+
 /* TFmode: IEEE quad floating point (software).  */
-FLOAT_MODE (TF, 16, ieee_quad_format);
+FLOAT_MODE (TF, 16, mips_quad_format);
 
 /* HPPA floating comparisons produce distinct condition codes.  */
 CC_MODE (CCFP);
diff --git a/gcc/config/pa/pa-protos.h b/gcc/config/pa/pa-protos.h
index 7422cd9..e4c160a 100644
--- a/gcc/config/pa/pa-protos.h
+++ b/gcc/config/pa/pa-protos.h
@@ -42,14 +42,14 @@ extern const char *output_move_double (rtx *);
 extern const char *output_fp_move_double (rtx *);
 extern const char *output_block_move (rtx *, int);
 extern const char *output_block_clear (rtx *, int);
-extern const char *output_cbranch (rtx *, int, int, int, rtx);
-extern const char *output_lbranch (rtx, rtx);
-extern const char *output_bb (rtx *, int, int, int, rtx, int);
-extern const char *output_bvb (rtx *, int, int, int, rtx, int);
+extern const char *output_cbranch (rtx *, int, rtx);
+extern const char *output_lbranch (rtx, rtx, int);
+extern const char *output_bb (rtx *, int, rtx, int);
+extern const char *output_bvb (rtx *, int, rtx, int);
 extern const char *output_dbra (rtx *, rtx, int);
 extern const char *output_movb (rtx *, rtx, int, int);
-extern const char *output_parallel_movb (rtx *, int);
-extern const char *output_parallel_addb (rtx *, int);
+extern const char *output_parallel_movb (rtx *, rtx);
+extern const char *output_parallel_addb (rtx *, rtx);
 extern const char *output_call (rtx, rtx, int);
 extern const char *output_indirect_call (rtx, rtx);
 extern const char *output_millicode_call (rtx, rtx);
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
index c23df87..7584b84 100644
--- a/gcc/config/pa/pa.c
+++ b/gcc/config/pa/pa.c
@@ -5934,11 +5934,13 @@ pa_scalar_mode_supported_p (enum machine_mode mode)
    parameters.  */
 
 const char *
-output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)
+output_cbranch (rtx *operands, int negated, rtx insn)
 {
   static char buf[100];
   int useskip = 0;
-  rtx xoperands[5];
+  int nullify = INSN_ANNULLED_BRANCH_P (insn);
+  int length = get_attr_length (insn);
+  int xdelay;
 
   /* A conditional branch to the following instruction (e.g. the delay slot)
      is asking for a disaster.  This can happen when not optimizing and
@@ -6008,7 +6010,7 @@ output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)
 	with an unfilled delay slot.  */
       case 8:
 	/* Handle weird backwards branch with a filled delay slot
-	   with is nullified.  */
+	   which is nullified.  */
 	if (dbr_sequence_length () != 0
 	    && ! forward_branch_p (insn)
 	    && nullify)
@@ -6055,19 +6057,24 @@ output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)
 	  }
 	break;
 
-      case 20:
-      case 28:
-	xoperands[0] = operands[0];
-	xoperands[1] = operands[1];
-	xoperands[2] = operands[2];
-	xoperands[3] = operands[3];
-
+      default:
 	/* The reversed conditional branch must branch over one additional
-	   instruction if the delay slot is filled.  If the delay slot
-	   is empty, the instruction after the reversed condition branch
-	   must be nullified.  */
-	nullify = dbr_sequence_length () == 0;
-	xoperands[4] = nullify ? GEN_INT (length) : GEN_INT (length + 4);
+	   instruction if the delay slot is filled and needs to be extracted
+	   by output_lbranch.  If the delay slot is empty or this is a
+	   nullified forward branch, the instruction after the reversed
+	   condition branch must be nullified.  */
+	if (dbr_sequence_length () == 0
+	    || (nullify && forward_branch_p (insn)))
+	  {
+	    nullify = 1;
+	    xdelay = 0;
+	    operands[4] = GEN_INT (length);
+	  }
+	else
+	  {
+	    xdelay = 1;
+	    operands[4] = GEN_INT (length + 4);
+	  }
 
 	/* Create a reversed conditional branch which branches around
 	   the following insns.  */
@@ -6114,27 +6121,38 @@ output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)
 	      }
 	  }
 
-	output_asm_insn (buf, xoperands);
-	return output_lbranch (operands[0], insn);
-
-      default:
-	gcc_unreachable ();
+	output_asm_insn (buf, operands);
+	return output_lbranch (operands[0], insn, xdelay);
     }
   return buf;
 }
 
-/* This routine handles long unconditional branches that exceed the
-   maximum range of a simple branch instruction.  */
+/* This routine handles output of long unconditional branches that
+   exceed the maximum range of a simple branch instruction.  Since
+   we don't have a register available for the branch, we save register
+   %r1 in the frame marker, load the branch destination DEST into %r1,
+   execute the branch, and restore %r1 in the delay slot of the branch.
+
+   Since long branches may have an insn in the delay slot and the
+   delay slot is used to restore %r1, we in general need to extract
+   this insn and execute it before the branch.  However, to facilitate
+   use of this function by conditional branches, we also provide an
+   option to not extract the delay insn so that it will be emitted
+   after the long branch.  So, if there is an insn in the delay slot,
+   it is extracted if XDELAY is nonzero.
+
+   The lengths of the various long-branch sequences are 20, 16 and 24
+   bytes for the portable runtime, non-PIC and PIC cases, respectively.  */
 
 const char *
-output_lbranch (rtx dest, rtx insn)
+output_lbranch (rtx dest, rtx insn, int xdelay)
 {
   rtx xoperands[2];
  
   xoperands[0] = dest;
 
   /* First, free up the delay slot.  */
-  if (dbr_sequence_length () != 0)
+  if (xdelay && dbr_sequence_length () != 0)
     {
       /* We can't handle a jump in the delay slot.  */
       gcc_assert (GET_CODE (NEXT_INSN (insn)) != JUMP_INSN);
@@ -6244,11 +6262,13 @@ output_lbranch (rtx dest, rtx insn)
    above.  it returns the appropriate output template to emit the branch.  */
 
 const char *
-output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,
-	   int negated, rtx insn, int which)
+output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)
 {
   static char buf[100];
   int useskip = 0;
+  int nullify = INSN_ANNULLED_BRANCH_P (insn);
+  int length = get_attr_length (insn);
+  int xdelay;
 
   /* A conditional branch to the following instruction (e.g. the delay slot) is
      asking for a disaster.  I do not think this can happen as this pattern
@@ -6315,7 +6335,7 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,
 	with an unfilled delay slot.  */
       case 8:
 	/* Handle weird backwards branch with a filled delay slot
-	   with is nullified.  */
+	   which is nullified.  */
 	if (dbr_sequence_length () != 0
 	    && ! forward_branch_p (insn)
 	    && nullify)
@@ -6357,9 +6377,10 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,
 	  }
 	else
 	  {
-	    strcpy (buf, "{extrs,|extrw,s,}");
 	    if (GET_MODE (operands[0]) == DImode)
 	      strcpy (buf, "extrd,s,*");
+	    else
+	      strcpy (buf, "{extrs,|extrw,s,}");
 	    if ((which == 0 && negated)
 		|| (which == 1 && ! negated))
 	      strcat (buf, "<");
@@ -6377,7 +6398,40 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,
 	break;
 
       default:
-	gcc_unreachable ();
+	/* The reversed conditional branch must branch over one additional
+	   instruction if the delay slot is filled and needs to be extracted
+	   by output_lbranch.  If the delay slot is empty or this is a
+	   nullified forward branch, the instruction after the reversed
+	   condition branch must be nullified.  */
+	if (dbr_sequence_length () == 0
+	    || (nullify && forward_branch_p (insn)))
+	  {
+	    nullify = 1;
+	    xdelay = 0;
+	    operands[4] = GEN_INT (length - 8);
+	  }
+	else
+	  {
+	    xdelay = 1;
+	    operands[4] = GEN_INT (length - 4);
+	  }
+
+	if (GET_MODE (operands[0]) == DImode)
+	  strcpy (buf, "extrd,s,*");
+	else
+	  strcpy (buf, "{extrs,|extrw,s,}");
+	if ((which == 0 && negated)
+	    || (which == 1 && !negated))
+	  strcat (buf, ">= %0,%1,1,%%r0\n\t");
+	else
+	  strcat (buf, "< %0,%1,1,%%r0\n\t");
+	if (nullify)
+	  strcat (buf, "b,n .+%4");
+	else
+	  strcat (buf, "b .+%4");
+	output_asm_insn (buf, operands);
+	return output_lbranch (negated ? operands[3] : operands[2],
+			       insn, xdelay);
     }
   return buf;
 }
@@ -6389,11 +6443,13 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,
    branch.  */
 
 const char *
-output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,
-	    int negated, rtx insn, int which)
+output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)
 {
   static char buf[100];
   int useskip = 0;
+  int nullify = INSN_ANNULLED_BRANCH_P (insn);
+  int length = get_attr_length (insn);
+  int xdelay;
 
   /* A conditional branch to the following instruction (e.g. the delay slot) is
      asking for a disaster.  I do not think this can happen as this pattern
@@ -6460,7 +6516,7 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,
 	with an unfilled delay slot.  */
       case 8:
 	/* Handle weird backwards branch with a filled delay slot
-	   with is nullified.  */
+	   which is nullified.  */
 	if (dbr_sequence_length () != 0
 	    && ! forward_branch_p (insn)
 	    && nullify)
@@ -6522,7 +6578,40 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,
 	break;
 
       default:
-	gcc_unreachable ();
+	/* The reversed conditional branch must branch over one additional
+	   instruction if the delay slot is filled and needs to be extracted
+	   by output_lbranch.  If the delay slot is empty or this is a
+	   nullified forward branch, the instruction after the reversed
+	   condition branch must be nullified.  */
+	if (dbr_sequence_length () == 0
+	    || (nullify && forward_branch_p (insn)))
+	  {
+	    nullify = 1;
+	    xdelay = 0;
+	    operands[4] = GEN_INT (length - 8);
+	  }
+	else
+	  {
+	    xdelay = 1;
+	    operands[4] = GEN_INT (length - 4);
+	  }
+
+	if (GET_MODE (operands[0]) == DImode)
+	  strcpy (buf, "extrd,s,*");
+	else
+	  strcpy (buf, "{extrs,|extrw,s,}");
+	if ((which == 0 && negated)
+	    || (which == 1 && !negated))
+	  strcat (buf, ">= {%0,%1,1,%%r0|%0,%%sar,1,%%r0}\n\t");
+	else
+	  strcat (buf, "< {%0,%1,1,%%r0|%0,%%sar,1,%%r0}\n\t");
+	if (nullify)
+	  strcat (buf, "b,n .+%4");
+	else
+	  strcat (buf, "b .+%4");
+	output_asm_insn (buf, operands);
+	return output_lbranch (negated ? operands[3] : operands[2],
+			       insn, xdelay);
     }
   return buf;
 }
@@ -6534,6 +6623,7 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,
 const char *
 output_dbra (rtx *operands, rtx insn, int which_alternative)
 {
+  int length = get_attr_length (insn);
 
   /* A conditional branch to the following instruction (e.g. the delay slot) is
      asking for a disaster.  Be prepared!  */
@@ -6559,7 +6649,7 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)
   if (which_alternative == 0)
     {
       int nullify = INSN_ANNULLED_BRANCH_P (insn);
-      int length = get_attr_length (insn);
+      int xdelay;
 
       /* If this is a long branch with its delay slot unfilled, set `nullify'
 	 as it can nullify the delay slot and save a nop.  */
@@ -6603,7 +6693,30 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)
 	    return "addi,%N2 %1,%0,%0\n\tb %3";
 
 	default:
-	  gcc_unreachable ();
+	  /* The reversed conditional branch must branch over one additional
+	     instruction if the delay slot is filled and needs to be extracted
+	     by output_lbranch.  If the delay slot is empty or this is a
+	     nullified forward branch, the instruction after the reversed
+	     condition branch must be nullified.  */
+	  if (dbr_sequence_length () == 0
+	      || (nullify && forward_branch_p (insn)))
+	    {
+	      nullify = 1;
+	      xdelay = 0;
+	      operands[4] = GEN_INT (length);
+	    }
+	  else
+	    {
+	      xdelay = 1;
+	      operands[4] = GEN_INT (length + 4);
+	    }
+
+	  if (nullify)
+	    output_asm_insn ("addib,%N2,n %1,%0,.+%4", operands);
+	  else
+	    output_asm_insn ("addib,%N2 %1,%0,.+%4", operands);
+
+	  return output_lbranch (operands[3], insn, xdelay);
 	}
       
     }
@@ -6616,10 +6729,17 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)
       output_asm_insn ("{fstws|fstw} %0,-16(%%r30)\n\tldw -16(%%r30),%4",
 		       operands);
       output_asm_insn ("ldo %1(%4),%4\n\tstw %4,-16(%%r30)", operands);
-      if (get_attr_length (insn) == 24)
+      if (length == 24)
 	return "{comb|cmpb},%S2 %%r0,%4,%3\n\t{fldws|fldw} -16(%%r30),%0";
-      else
+      else if (length == 28)
 	return "{comclr|cmpclr},%B2 %%r0,%4,%%r0\n\tb %3\n\t{fldws|fldw} -16(%%r30),%0";
+      else
+	{
+	  operands[4] = GEN_INT (length - 24);
+	  output_asm_insn ("addib,%N2 %1,%0,.+%4", operands);
+	  output_asm_insn ("{fldws|fldw} -16(%%r30),%0", operands);
+	  return output_lbranch (operands[3], insn, 0);
+	}
     }
   /* Deal with gross reload from memory case.  */
   else
@@ -6627,14 +6747,20 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)
       /* Reload loop counter from memory, the store back to memory
 	 happens in the branch's delay slot.  */
       output_asm_insn ("ldw %0,%4", operands);
-      if (get_attr_length (insn) == 12)
+      if (length == 12)
 	return "addib,%C2 %1,%4,%3\n\tstw %4,%0";
-      else
+      else if (length == 16)
 	return "addi,%N2 %1,%4,%4\n\tb %3\n\tstw %4,%0";
+      else
+	{
+	  operands[5] = GEN_INT (length - 12);
+	  output_asm_insn ("addib,%N2 %1,%0,.+%5\n\tstw %4,%0", operands);
+	  return output_lbranch (operands[3], insn, 0);
+	}
     }
 }
 
-/* Return the output template for emitting a dbra type insn.
+/* Return the output template for emitting a movb type insn.
 
    Note it may perform some output operations on its own before
    returning the final output string.  */
@@ -6642,6 +6768,7 @@ const char *
 output_movb (rtx *operands, rtx insn, int which_alternative,
 	     int reverse_comparison)
 {
+  int length = get_attr_length (insn);
 
   /* A conditional branch to the following instruction (e.g. the delay slot) is
      asking for a disaster.  Be prepared!  */
@@ -6668,7 +6795,7 @@ output_movb (rtx *operands, rtx insn, int which_alternative,
   if (which_alternative == 0)
     {
       int nullify = INSN_ANNULLED_BRANCH_P (insn);
-      int length = get_attr_length (insn);
+      int xdelay;
 
       /* If this is a long branch with its delay slot unfilled, set `nullify'
 	 as it can nullify the delay slot and save a nop.  */
@@ -6712,38 +6839,80 @@ output_movb (rtx *operands, rtx insn, int which_alternative,
 	    return "or,%N2 %1,%%r0,%0\n\tb %3";
 
 	default:
-	  gcc_unreachable ();
+	  /* The reversed conditional branch must branch over one additional
+	     instruction if the delay slot is filled and needs to be extracted
+	     by output_lbranch.  If the delay slot is empty or this is a
+	     nullified forward branch, the instruction after the reversed
+	     condition branch must be nullified.  */
+	  if (dbr_sequence_length () == 0
+	      || (nullify && forward_branch_p (insn)))
+	    {
+	      nullify = 1;
+	      xdelay = 0;
+	      operands[4] = GEN_INT (length);
+	    }
+	  else
+	    {
+	      xdelay = 1;
+	      operands[4] = GEN_INT (length + 4);
+	    }
+
+	  if (nullify)
+	    output_asm_insn ("movb,%N2,n %1,%0,.+%4", operands);
+	  else
+	    output_asm_insn ("movb,%N2 %1,%0,.+%4", operands);
+
+	  return output_lbranch (operands[3], insn, xdelay);
 	}
     }
-  /* Deal with gross reload from FP register case.  */
+  /* Deal with gross reload for FP destination register case.  */
   else if (which_alternative == 1)
     {
-      /* Move loop counter from FP register to MEM then into a GR,
-	 increment the GR, store the GR into MEM, and finally reload
-	 the FP register from MEM from within the branch's delay slot.  */
+      /* Move source register to MEM, perform the branch test, then
+	 finally load the FP register from MEM from within the branch's
+	 delay slot.  */
       output_asm_insn ("stw %1,-16(%%r30)", operands);
-      if (get_attr_length (insn) == 12)
+      if (length == 12)
 	return "{comb|cmpb},%S2 %%r0,%1,%3\n\t{fldws|fldw} -16(%%r30),%0";
-      else
+      else if (length == 16)
 	return "{comclr|cmpclr},%B2 %%r0,%1,%%r0\n\tb %3\n\t{fldws|fldw} -16(%%r30),%0";
+      else
+	{
+	  operands[4] = GEN_INT (length - 12);
+	  output_asm_insn ("movb,%N2 %1,%0,.+%4", operands);
+	  output_asm_insn ("{fldws|fldw} -16(%%r30),%0", operands);
+	  return output_lbranch (operands[3], insn, 0);
+	}
     }
   /* Deal with gross reload from memory case.  */
   else if (which_alternative == 2)
     {
       /* Reload loop counter from memory, the store back to memory
 	 happens in the branch's delay slot.  */
-      if (get_attr_length (insn) == 8)
+      if (length == 8)
 	return "{comb|cmpb},%S2 %%r0,%1,%3\n\tstw %1,%0";
-      else
+      else if (length == 12)
 	return "{comclr|cmpclr},%B2 %%r0,%1,%%r0\n\tb %3\n\tstw %1,%0";
+      else
+	{
+	  operands[4] = GEN_INT (length - 8);
+	  output_asm_insn ("movb,%N2 %1,%0,.+%4\n\tstw %1,%0", operands);
+	  return output_lbranch (operands[3], insn, 0);
+	}
     }
   /* Handle SAR as a destination.  */
   else
     {
-      if (get_attr_length (insn) == 8)
+      if (length == 8)
 	return "{comb|cmpb},%S2 %%r0,%1,%3\n\tmtsar %r1";
-      else
+      else if (length == 12)
 	return "{comclr|cmpclr},%B2 %%r0,%1,%%r0\n\tb %3\n\tmtsar %r1";
+      else
+	{
+	  operands[4] = GEN_INT (length - 8);
+	  output_asm_insn ("movb,%N2 %1,%0,.+%4\n\tmtsar %r1", operands);
+	  return output_lbranch (operands[3], insn, 0);
+	}
     }
 }
 
@@ -8206,37 +8375,50 @@ jump_in_call_delay (rtx insn)
 /* Output an unconditional move and branch insn.  */
 
 const char *
-output_parallel_movb (rtx *operands, int length)
+output_parallel_movb (rtx *operands, rtx insn)
 {
+  int length = get_attr_length (insn);
+
   /* These are the cases in which we win.  */
   if (length == 4)
     return "mov%I1b,tr %1,%0,%2";
 
-  /* None of these cases wins, but they don't lose either.  */
-  if (dbr_sequence_length () == 0)
+  /* None of the following cases win, but they don't lose either.  */
+  if (length == 8)
     {
-      /* Nothing in the delay slot, fake it by putting the combined
-	 insn (the copy or add) in the delay slot of a bl.  */
-      if (GET_CODE (operands[1]) == CONST_INT)
-	return "b %2\n\tldi %1,%0";
+      if (dbr_sequence_length () == 0)
+	{
+	  /* Nothing in the delay slot, fake it by putting the combined
+	     insn (the copy or add) in the delay slot of a bl.  */
+	  if (GET_CODE (operands[1]) == CONST_INT)
+	    return "b %2\n\tldi %1,%0";
+	  else
+	    return "b %2\n\tcopy %1,%0";
+	}
       else
-	return "b %2\n\tcopy %1,%0";
+	{
+	  /* Something in the delay slot, but we've got a long branch.  */
+	  if (GET_CODE (operands[1]) == CONST_INT)
+	    return "ldi %1,%0\n\tb %2";
+	  else
+	    return "copy %1,%0\n\tb %2";
+	}
     }
+
+  if (GET_CODE (operands[1]) == CONST_INT)
+    output_asm_insn ("ldi %1,%0", operands);
   else
-    {
-      /* Something in the delay slot, but we've got a long branch.  */
-      if (GET_CODE (operands[1]) == CONST_INT)
-	return "ldi %1,%0\n\tb %2";
-      else
-	return "copy %1,%0\n\tb %2";
-    }
+    output_asm_insn ("copy %1,%0", operands);
+  return output_lbranch (operands[2], insn, 1);
 }
 
 /* Output an unconditional add and branch insn.  */
 
 const char *
-output_parallel_addb (rtx *operands, int length)
+output_parallel_addb (rtx *operands, rtx insn)
 {
+  int length = get_attr_length (insn);
+
   /* To make life easy we want operand0 to be the shared input/output
      operand and operand1 to be the readonly operand.  */
   if (operands[0] == operands[1])
@@ -8246,18 +8428,20 @@ output_parallel_addb (rtx *operands, int length)
   if (length == 4)
     return "add%I1b,tr %1,%0,%3";
 
-  /* None of these cases win, but they don't lose either.  */
-  if (dbr_sequence_length () == 0)
+  /* None of the following cases win, but they don't lose either.  */
+  if (length == 8)
     {
-      /* Nothing in the delay slot, fake it by putting the combined
-	 insn (the copy or add) in the delay slot of a bl.  */
-      return "b %3\n\tadd%I1 %1,%0,%0";
-    }
-  else
-    {
-      /* Something in the delay slot, but we've got a long branch.  */
-      return "add%I1 %1,%0,%0\n\tb %3";
+      if (dbr_sequence_length () == 0)
+	/* Nothing in the delay slot, fake it by putting the combined
+	   insn (the copy or add) in the delay slot of a bl.  */
+	return "b %3\n\tadd%I1 %1,%0,%0";
+      else
+	/* Something in the delay slot, but we've got a long branch.  */
+	return "add%I1 %1,%0,%0\n\tb %3";
     }
+
+  output_asm_insn ("add%I1 %1,%0,%0", operands);
+  return output_lbranch (operands[3], insn, 1);
 }
 
 /* Return nonzero if INSN (a jump insn) immediately follows a call
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index 95893eb..6ac6786 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -1,6 +1,6 @@
 ;;- Machine description for HP PA-RISC architecture for GCC compiler
 ;;   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-;;   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+;;   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 ;;   Contributed by the Center for Software Science at the University
 ;;   of Utah.
 
@@ -52,6 +52,16 @@
    (UNSPECV_LONGJMP	5)	; builtin_longjmp
   ])
 
+;; Maximum pc-relative branch offsets.
+
+;; These numbers are a bit smaller than the maximum allowable offsets
+;; so that a few instructions may be inserted before the actual branch.
+
+(define_constants
+  [(MAX_12BIT_OFFSET     8184)	; 12-bit branch
+   (MAX_17BIT_OFFSET   262100)	; 17-bit branch
+  ])
+
 ;; Insn type.  Used to default other attribute values.
 
 ;; type "unary" insns have one input operand (1) and one output operand (0)
@@ -139,7 +149,7 @@
 (define_delay (eq_attr "type" "btable_branch,branch,parallel_branch")
   [(eq_attr "in_branch_delay" "true") (nil) (nil)])
 
-;; Floating point conditional branch delay slot description and
+;; Floating point conditional branch delay slot description.
 (define_delay (eq_attr "type" "fbranch")
   [(eq_attr "in_branch_delay" "true")
    (eq_attr "in_nullified_branch_delay" "true")
@@ -1708,17 +1718,18 @@
   ""
   "*
 {
-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 0, insn);
+  return output_cbranch (operands, 0, insn);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
     (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 8184))
+	       (const_int MAX_12BIT_OFFSET))
 	   (const_int 4)
 	   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 262100))
+	       (const_int MAX_17BIT_OFFSET))
 	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
 	   (eq (symbol_ref "flag_pic") (const_int 0))
 	   (const_int 20)]
 	  (const_int 28)))])
@@ -1736,17 +1747,18 @@
   ""
   "*
 {
-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 1, insn);
+  return output_cbranch (operands, 1, insn);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
     (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 8184))
+	       (const_int MAX_12BIT_OFFSET))
 	   (const_int 4)
 	   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 262100))
+	       (const_int MAX_17BIT_OFFSET))
 	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
 	   (eq (symbol_ref "flag_pic") (const_int 0))
 	   (const_int 20)]
 	  (const_int 28)))])
@@ -1762,17 +1774,18 @@
   "TARGET_64BIT"
   "*
 {
-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 0, insn);
+  return output_cbranch (operands, 0, insn);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
     (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 8184))
+	       (const_int MAX_12BIT_OFFSET))
 	   (const_int 4)
 	   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 262100))
+	       (const_int MAX_17BIT_OFFSET))
 	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
 	   (eq (symbol_ref "flag_pic") (const_int 0))
 	   (const_int 20)]
 	  (const_int 28)))])
@@ -1790,17 +1803,18 @@
   "TARGET_64BIT"
   "*
 {
-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 1, insn);
+  return output_cbranch (operands, 1, insn);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
     (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 8184))
+	       (const_int MAX_12BIT_OFFSET))
 	   (const_int 4)
 	   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 262100))
+	       (const_int MAX_17BIT_OFFSET))
 	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
 	   (eq (symbol_ref "flag_pic") (const_int 0))
 	   (const_int 20)]
 	  (const_int 28)))])
@@ -1815,17 +1829,18 @@
   "TARGET_64BIT"
   "*
 {
-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 0, insn);
+  return output_cbranch (operands, 0, insn);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
     (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 8184))
+	       (const_int MAX_12BIT_OFFSET))
 	   (const_int 4)
 	   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 262100))
+	       (const_int MAX_17BIT_OFFSET))
 	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
 	   (eq (symbol_ref "flag_pic") (const_int 0))
 	   (const_int 20)]
 	  (const_int 28)))])
@@ -1843,17 +1858,18 @@
   "TARGET_64BIT"
   "*
 {
-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 1, insn);
+  return output_cbranch (operands, 1, insn);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
     (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 8184))
+	       (const_int MAX_12BIT_OFFSET))
 	   (const_int 4)
 	   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 262100))
+	       (const_int MAX_17BIT_OFFSET))
 	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
 	   (eq (symbol_ref "flag_pic") (const_int 0))
 	   (const_int 20)]
 	  (const_int 28)))])
@@ -1871,15 +1887,21 @@
   ""
   "*
 {
-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 0, insn, 0);
+  return output_bb (operands, 0, insn, 0);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -1893,15 +1915,21 @@
   "TARGET_64BIT"
   "*
 {
-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 0, insn, 0);
+  return output_bb (operands, 0, insn, 0);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -1915,15 +1943,21 @@
   ""
   "*
 {
-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 1, insn, 0);
+  return output_bb (operands, 1, insn, 0);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -1937,15 +1971,21 @@
   "TARGET_64BIT"
   "*
 {
-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 1, insn, 0);
+  return output_bb (operands, 1, insn, 0);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -1959,15 +1999,21 @@
   ""
   "*
 {
-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 0, insn, 1);
+  return output_bb (operands, 0, insn, 1);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -1981,15 +2027,21 @@
   "TARGET_64BIT"
   "*
 {
-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 0, insn, 1);
+  return output_bb (operands, 0, insn, 1);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -2003,15 +2055,21 @@
   ""
   "*
 {
-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 1, insn, 1);
+  return output_bb (operands, 1, insn, 1);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -2025,15 +2083,21 @@
   "TARGET_64BIT"
   "*
 {
-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),
-			 get_attr_length (insn), 1, insn, 1);
+  return output_bb (operands, 1, insn, 1);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 ;; Branch on Variable Bit patterns.
 (define_insn ""
@@ -2048,15 +2112,21 @@
   ""
   "*
 {
-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),
-		     get_attr_length (insn), 0, insn, 0);
+  return output_bvb (operands, 0, insn, 0);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -2070,15 +2140,21 @@
   "TARGET_64BIT"
   "*
 {
-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),
-		     get_attr_length (insn), 0, insn, 0);
+  return output_bvb (operands, 0, insn, 0);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -2092,15 +2168,21 @@
   ""
   "*
 {
-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),
-		     get_attr_length (insn), 1, insn, 0);
+  return output_bvb (operands, 1, insn, 0);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -2114,15 +2196,21 @@
   "TARGET_64BIT"
   "*
 {
-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),
-		     get_attr_length (insn), 1, insn, 0);
+  return output_bvb (operands, 1, insn, 0);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -2136,15 +2224,21 @@
   ""
   "*
 {
-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),
-		     get_attr_length (insn), 0, insn, 1);
+  return output_bvb (operands, 0, insn, 1);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -2158,15 +2252,21 @@
   "TARGET_64BIT"
   "*
 {
-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),
-		     get_attr_length (insn), 0, insn, 1);
+  return output_bvb (operands, 0, insn, 1);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -2180,15 +2280,21 @@
   ""
   "*
 {
-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),
-		     get_attr_length (insn), 1, insn, 1);
+  return output_bvb (operands, 1, insn, 1);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 (define_insn ""
   [(set (pc)
@@ -2202,46 +2308,114 @@
   "TARGET_64BIT"
   "*
 {
-  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),
-		     get_attr_length (insn), 1, insn, 1);
+  return output_bvb (operands, 1, insn, 1);
 }"
 [(set_attr "type" "cbranch")
  (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 ;; Floating point branches
+
+;; ??? Nullification is handled differently from other branches.
+;; If nullification is specified, the delay slot is nullified on any
+;; taken branch regardless of branch direction.
 (define_insn ""
   [(set (pc) (if_then_else (ne (reg:CCFP 0) (const_int 0))
 			   (label_ref (match_operand 0 "" ""))
 			   (pc)))]
-  "! TARGET_SOFT_FLOAT"
+  "!TARGET_SOFT_FLOAT"
   "*
 {
-  if (INSN_ANNULLED_BRANCH_P (insn))
-    return \"ftest\;b,n %0\";
+  int length = get_attr_length (insn);
+  rtx xoperands[1];
+  int nullify, xdelay;
+
+  if (length < 16)
+    return \"ftest\;b%* %l0\";
+
+  if (dbr_sequence_length () == 0 || INSN_ANNULLED_BRANCH_P (insn))
+    {
+      nullify = 1;
+      xdelay = 0;
+      xoperands[0] = GEN_INT (length - 8);
+    }
   else
-    return \"ftest\;b%* %0\";
+    {
+      nullify = 0;
+      xdelay = 1;
+      xoperands[0] = GEN_INT (length - 4);
+    }
+
+  if (nullify)
+    output_asm_insn (\"ftest\;add,tr %%r0,%%r0,%%r0\;b,n .+%0\", xoperands);
+  else
+    output_asm_insn (\"ftest\;add,tr %%r0,%%r0,%%r0\;b .+%0\", xoperands);
+  return output_lbranch (operands[0], insn, xdelay);
 }"
-  [(set_attr "type" "fbranch")
-   (set_attr "length" "8")])
+[(set_attr "type" "fbranch")
+ (set (attr "length")
+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 32)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 28)]
+	  (const_int 36)))])
 
 (define_insn ""
   [(set (pc) (if_then_else (ne (reg:CCFP 0) (const_int 0))
 			   (pc)
 			   (label_ref (match_operand 0 "" ""))))]
-  "! TARGET_SOFT_FLOAT"
+  "!TARGET_SOFT_FLOAT"
   "*
 {
-  if (INSN_ANNULLED_BRANCH_P (insn))
-    return \"ftest\;add,tr %%r0,%%r0,%%r0\;b,n %0\";
-  else
+  int length = get_attr_length (insn);
+  rtx xoperands[1];
+  int nullify, xdelay;
+
+  if (length < 16)
     return \"ftest\;add,tr %%r0,%%r0,%%r0\;b%* %0\";
+
+  if (dbr_sequence_length () == 0 || INSN_ANNULLED_BRANCH_P (insn))
+    {
+      nullify = 1;
+      xdelay = 0;
+      xoperands[0] = GEN_INT (length - 4);
+    }
+  else
+    {
+      nullify = 0;
+      xdelay = 1;
+      xoperands[0] = GEN_INT (length);
+    }
+
+  if (nullify)
+    output_asm_insn (\"ftest\;b,n .+%0\", xoperands);
+  else
+    output_asm_insn (\"ftest\;b .+%0\", xoperands);
+  return output_lbranch (operands[0], insn, xdelay);
 }"
-  [(set_attr "type" "fbranch")
-   (set_attr "length" "12")])
+[(set_attr "type" "fbranch")
+ (set (attr "length")
+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 12)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 28)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 24)]
+	  (const_int 32)))])
 
 ;; Move instructions
 
@@ -6980,11 +7154,10 @@
   "*
 {
   /* An unconditional branch which can reach its target.  */
-  if (get_attr_length (insn) != 24
-      && get_attr_length (insn) != 16)
+  if (get_attr_length (insn) < 16)
     return \"b%* %l0\";
 
-  return output_lbranch (operands[0], insn);
+  return output_lbranch (operands[0], insn, 1);
 }"
   [(set_attr "type" "uncond_branch")
    (set_attr "pa_combine_type" "uncond_branch")
@@ -6992,15 +7165,17 @@
     (cond [(eq (symbol_ref "jump_in_call_delay (insn)") (const_int 1))
 	   (if_then_else (lt (abs (minus (match_dup 0)
 					 (plus (pc) (const_int 8))))
-			     (const_int 8184))
-			 (const_int 4)
-			 (const_int 8))
-	   (ge (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
-	       (const_int 262100))
-	   (if_then_else (eq (symbol_ref "flag_pic") (const_int 0))
-			 (const_int 16)
-			 (const_int 24))]
-	  (const_int 4)))])
+			     (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (const_int 8))
+	   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 4)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 20)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 16)]
+	  (const_int 24)))])
 
 ;;; Hope this is only within a function...
 (define_insn "indirect_jump"
@@ -8814,39 +8989,71 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
       (if_then_else (eq_attr "alternative" "0")
 ;; Loop counter in register case
 ;; Short branch has length of 4
-;; Long branch has length of 8
-	(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8))
+;; Long branch has length of 8, 20, 24 or 28
+	(cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 20)]
+	  (const_int 28))
 
 ;; Loop counter in FP reg case.
 ;; Extra goo to deal with additional reload insns.
 	(if_then_else (eq_attr "alternative" "1")
 	  (if_then_else (lt (match_dup 3) (pc))
-	    (if_then_else
-	      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))
-		  (const_int 8184))
-	      (const_int 24)
-	      (const_int 28))
-	    (if_then_else
-	      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
-		  (const_int 8184))
-	      (const_int 24)
-	      (const_int 28)))
+	     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))
+		      (const_int MAX_12BIT_OFFSET))
+		    (const_int 24)
+		    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))
+		      (const_int MAX_17BIT_OFFSET))
+		    (const_int 28)
+		    (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+		    (const_int 44)
+		    (eq (symbol_ref "flag_pic") (const_int 0))
+		    (const_int 40)]
+		  (const_int 48))
+	     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		      (const_int MAX_12BIT_OFFSET))
+		    (const_int 24)
+		    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		      (const_int MAX_17BIT_OFFSET))
+		    (const_int 28)
+		    (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+		    (const_int 44)
+		    (eq (symbol_ref "flag_pic") (const_int 0))
+		    (const_int 40)]
+		  (const_int 48)))
+
 ;; Loop counter in memory case.
 ;; Extra goo to deal with additional reload insns.
 	(if_then_else (lt (match_dup 3) (pc))
-	  (if_then_else
-	    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))
-		(const_int 8184))
-	    (const_int 12)
-	    (const_int 16))
-	  (if_then_else
-	    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
-		(const_int 8184))
-	    (const_int 12)
-	    (const_int 16))))))])
+	     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))
+		      (const_int MAX_12BIT_OFFSET))
+		    (const_int 12)
+		    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))
+		      (const_int MAX_17BIT_OFFSET))
+		    (const_int 16)
+		    (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+		    (const_int 32)
+		    (eq (symbol_ref "flag_pic") (const_int 0))
+		    (const_int 28)]
+		  (const_int 36))
+	     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		      (const_int MAX_12BIT_OFFSET))
+		    (const_int 12)
+		    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		      (const_int MAX_17BIT_OFFSET))
+		    (const_int 16)
+		    (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+		    (const_int 32)
+		    (eq (symbol_ref "flag_pic") (const_int 0))
+		    (const_int 28)]
+		  (const_int 36))))))])
 
 (define_insn ""
   [(set (pc)
@@ -8865,33 +9072,59 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
       (if_then_else (eq_attr "alternative" "0")
 ;; Loop counter in register case
 ;; Short branch has length of 4
-;; Long branch has length of 8
-	(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8))
+;; Long branch has length of 8, 20, 24 or 28
+        (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 20)]
+	  (const_int 28))
 
 ;; Loop counter in FP reg case.
 ;; Extra goo to deal with additional reload insns.
 	(if_then_else (eq_attr "alternative" "1")
 	  (if_then_else (lt (match_dup 3) (pc))
-	    (if_then_else
-	      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))
-		  (const_int 8184))
-	      (const_int 12)
-	      (const_int 16))
-	    (if_then_else
-	      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
-		  (const_int 8184))
-	      (const_int 12)
-	      (const_int 16)))
+	     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))
+		      (const_int MAX_12BIT_OFFSET))
+		    (const_int 12)
+		    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))
+		      (const_int MAX_17BIT_OFFSET))
+		    (const_int 16)
+		    (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+		    (const_int 32)
+		    (eq (symbol_ref "flag_pic") (const_int 0))
+		    (const_int 28)]
+		  (const_int 36))
+	     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		      (const_int MAX_12BIT_OFFSET))
+		    (const_int 12)
+		    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		      (const_int MAX_17BIT_OFFSET))
+		    (const_int 16)
+		    (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+		    (const_int 32)
+		    (eq (symbol_ref "flag_pic") (const_int 0))
+		    (const_int 28)]
+		  (const_int 36)))
+
 ;; Loop counter in memory or sar case.
 ;; Extra goo to deal with additional reload insns.
-	(if_then_else
-	  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
-	      (const_int 8184))
-	  (const_int 8)
-	  (const_int 12)))))])
+	(cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		   (const_int MAX_12BIT_OFFSET))
+		(const_int 8)
+		(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		  (const_int MAX_17BIT_OFFSET))
+		(const_int 12)
+		(ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+		(const_int 28)
+		(eq (symbol_ref "flag_pic") (const_int 0))
+		(const_int 24)]
+	      (const_int 32)))))])
 
 ;; Handle negated branch.
 (define_insn ""
@@ -8912,32 +9145,58 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
 ;; Loop counter in register case
 ;; Short branch has length of 4
 ;; Long branch has length of 8
-	(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8))
+        (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 20)]
+	  (const_int 28))
 
 ;; Loop counter in FP reg case.
 ;; Extra goo to deal with additional reload insns.
 	(if_then_else (eq_attr "alternative" "1")
 	  (if_then_else (lt (match_dup 3) (pc))
-	    (if_then_else
-	      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))
-		  (const_int 8184))
-	      (const_int 12)
-	      (const_int 16))
-	    (if_then_else
-	      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
-		  (const_int 8184))
-	      (const_int 12)
-	      (const_int 16)))
+	     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))
+		      (const_int MAX_12BIT_OFFSET))
+		    (const_int 12)
+		    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))
+		      (const_int MAX_17BIT_OFFSET))
+		    (const_int 16)
+		    (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+		    (const_int 32)
+		    (eq (symbol_ref "flag_pic") (const_int 0))
+		    (const_int 28)]
+		  (const_int 36))
+	     (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		      (const_int MAX_12BIT_OFFSET))
+		    (const_int 12)
+		    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		      (const_int MAX_17BIT_OFFSET))
+		    (const_int 16)
+		    (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+		    (const_int 32)
+		    (eq (symbol_ref "flag_pic") (const_int 0))
+		    (const_int 28)]
+		  (const_int 36)))
+
 ;; Loop counter in memory or SAR case.
 ;; Extra goo to deal with additional reload insns.
-	(if_then_else
-	  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
-	      (const_int 8184))
-	  (const_int 8)
-	  (const_int 12)))))])
+	(cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		   (const_int MAX_12BIT_OFFSET))
+		(const_int 8)
+		(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+		  (const_int MAX_17BIT_OFFSET))
+		(const_int 12)
+		(ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+		(const_int 28)
+		(eq (symbol_ref "flag_pic") (const_int 0))
+		(const_int 24)]
+	      (const_int 32)))))])
 
 (define_insn ""
   [(set (pc) (label_ref (match_operand 3 "" "" )))
@@ -8947,14 +9206,21 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
   "(reload_completed && operands[0] == operands[1]) || operands[0] == operands[2]"
   "*
 {
-  return output_parallel_addb (operands, get_attr_length (insn));
+  return output_parallel_addb (operands, insn);
 }"
-  [(set_attr "type" "parallel_branch")
-   (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+[(set_attr "type" "parallel_branch")
+ (set (attr "length")
+    (cond [(lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 20)]
+	  (const_int 28)))])
 
 (define_insn ""
   [(set (pc) (label_ref (match_operand 2 "" "" )))
@@ -8963,14 +9229,21 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
   "reload_completed"
   "*
 {
-  return output_parallel_movb (operands, get_attr_length (insn));
+  return output_parallel_movb (operands, insn);
 }"
-  [(set_attr "type" "parallel_branch")
-   (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+[(set_attr "type" "parallel_branch")
+ (set (attr "length")
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 20)]
+	  (const_int 28)))])
 
 (define_insn ""
   [(set (pc) (label_ref (match_operand 2 "" "" )))
@@ -8979,14 +9252,21 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
   "reload_completed"
   "*
 {
-  return output_parallel_movb (operands, get_attr_length (insn));
+  return output_parallel_movb (operands, insn);
 }"
-  [(set_attr "type" "parallel_branch")
-   (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+[(set_attr "type" "parallel_branch")
+ (set (attr "length")
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 20)]
+	  (const_int 28)))])
 
 (define_insn ""
   [(set (pc) (label_ref (match_operand 2 "" "" )))
@@ -8995,14 +9275,21 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
   "reload_completed"
   "*
 {
-  return output_parallel_movb (operands, get_attr_length (insn));
+  return output_parallel_movb (operands, insn);
 }"
-  [(set_attr "type" "parallel_branch")
-   (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+[(set_attr "type" "parallel_branch")
+ (set (attr "length")
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 20)]
+	  (const_int 28)))])
 
 (define_insn ""
   [(set (pc) (label_ref (match_operand 2 "" "" )))
@@ -9011,14 +9298,21 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
   "reload_completed"
   "*
 {
-  return output_parallel_movb (operands, get_attr_length (insn));
+  return output_parallel_movb (operands, insn);
 }"
-  [(set_attr "type" "parallel_branch")
-   (set (attr "length")
-    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
-		      (const_int 8184))
-           (const_int 4)
-	   (const_int 8)))])
+[(set_attr "type" "parallel_branch")
+ (set (attr "length")
+    (cond [(lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_12BIT_OFFSET))
+	   (const_int 4)
+	   (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))
+	       (const_int MAX_17BIT_OFFSET))
+	   (const_int 8)
+	   (ne (symbol_ref "TARGET_PORTABLE_RUNTIME") (const_int 0))
+	   (const_int 24)
+	   (eq (symbol_ref "flag_pic") (const_int 0))
+	   (const_int 20)]
+	  (const_int 28)))])
 
 (define_insn ""
   [(set (match_operand 0 "register_operand" "=f")
diff --git a/gcc/config/rs6000/ppc-asm.h b/gcc/config/rs6000/ppc-asm.h
index 74e1483..47547f6 100644
--- a/gcc/config/rs6000/ppc-asm.h
+++ b/gcc/config/rs6000/ppc-asm.h
@@ -158,7 +158,7 @@ GLUE(.L,name): \
 	.size FUNC_NAME(name),GLUE(.L,name)-FUNC_NAME(name)
 #endif
 
-#if defined __linux__ && !defined __powerpc64__
+#if defined __linux__
 	.section .note.GNU-stack
 	.previous
 #endif
diff --git a/gcc/config/rs6000/t-linux64 b/gcc/config/rs6000/t-linux64
index 2c30a89..3200045 100644
--- a/gcc/config/rs6000/t-linux64
+++ b/gcc/config/rs6000/t-linux64
@@ -6,13 +6,13 @@ LIB2FUNCS_EXTRA = tramp.S $(srcdir)/config/rs6000/ppc64-fp.c \
 
 TARGET_LIBGCC2_CFLAGS += -mno-minimal-toc
 
-MULTILIB_OPTIONS        = m64/m32 msoft-float
-MULTILIB_DIRNAMES       = 64 32 nof
+MULTILIB_OPTIONS        = m64/m32
+MULTILIB_DIRNAMES       = 64 32
 MULTILIB_EXTRA_OPTS     = fPIC mstrict-align
-MULTILIB_EXCEPTIONS     = m64/msoft-float
-MULTILIB_EXCLUSIONS     = m64/!m32/msoft-float
-MULTILIB_OSDIRNAMES	= ../lib64 ../lib nof
-MULTILIB_MATCHES        = $(MULTILIB_MATCHES_FLOAT)
+MULTILIB_EXCEPTIONS     =
+MULTILIB_EXCLUSIONS     =
+MULTILIB_OSDIRNAMES	= ../lib64 ../lib
+MULTILIB_MATCHES        =
 
 # We want fine grained libraries, so use the new code to build the
 # floating point emulation libraries.
diff --git a/gcc/config/sh/linux-unwind.h b/gcc/config/sh/linux-unwind.h
index 3ba9436..0c20396 100644
--- a/gcc/config/sh/linux-unwind.h
+++ b/gcc/config/sh/linux-unwind.h
@@ -80,9 +80,9 @@ shmedia_fallback_frame_state (struct _Unwind_Context *context,
 	   && (*(unsigned long *) (pc+11)  == 0x6ff0fff0))
     {
       struct rt_sigframe {
-	struct siginfo *pinfo;
+	siginfo_t *pinfo;
 	void *puc;
-	struct siginfo info;
+	siginfo_t info;
 	struct ucontext uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
@@ -178,8 +178,8 @@ sh_fallback_frame_state (struct _Unwind_Context *context,
 		&& (*(unsigned short *) (pc+14)  == 0x00ad))))
     {
       struct rt_sigframe {
-	struct siginfo info;
-	struct ucontext uc;
+	siginfo_t info;
+	ucontext_t uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
          The aliasing warning is correct, but should not be a problem
diff --git a/gcc/config/sparc/freebsd.h b/gcc/config/sparc/freebsd.h
index 9e432a3..7978a7a 100644
--- a/gcc/config/sparc/freebsd.h
+++ b/gcc/config/sparc/freebsd.h
@@ -26,9 +26,22 @@ Boston, MA 02110-1301, USA.  */
 /* FreeBSD needs the platform name (sparc64) defined.
    Emacs needs to know if the arch is 64 or 32-bits.  */
 
-#undef  CPP_CPU64_DEFAULT_SPEC
-#define CPP_CPU64_DEFAULT_SPEC \
-  "-D__sparc64__ -D__sparc_v9__ -D__sparcv9 -D__arch64__"
+#undef  FBSD_TARGET_CPU_CPP_BUILTINS
+#define FBSD_TARGET_CPU_CPP_BUILTINS()                  \
+  do                                                    \
+    {                                                   \
+      if (TARGET_ARCH64)                                \
+        {                                               \
+          builtin_define ("__sparc64__");               \
+          builtin_define ("__sparc_v9__");              \
+          builtin_define ("__sparcv9");                 \
+        }                                               \
+      else                                              \
+        builtin_define ("__sparc");                     \
+      builtin_define ("__sparc__");                     \
+    }                                                   \
+  while (0)
+
 
 #define LINK_SPEC "%(link_arch)						\
   %{!mno-relax:%{!r:-relax}}						\
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 201a425..497de5b 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -3709,7 +3709,10 @@ sparc_output_scratch_registers (FILE *file ATTRIBUTE_UNUSED)
 	  && ! sparc_hard_reg_printed [i])
 	{
 	  sparc_hard_reg_printed [i] = 1;
-	  fprintf (file, "\t.register\t%%g%d, #scratch\n", i);
+	  /* %g7 is used as TLS base register, use #ignore
+	     for it instead of #scratch.  */
+	  fprintf (file, "\t.register\t%%g%d, #%s\n", i,
+		   i == 7 ? "ignore" : "scratch");
 	}
       if (i == 3) i = 5;
     }
diff --git a/gcc/config/sparc/sparc.h b/gcc/config/sparc/sparc.h
index bb4647c..2e5810e 100644
--- a/gcc/config/sparc/sparc.h
+++ b/gcc/config/sparc/sparc.h
@@ -681,6 +681,10 @@ if (TARGET_ARCH64				\
    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode	\
    && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))
 
+/* Make local arrays of chars word-aligned for the same reasons.  */
+/* Patched from gentoo bug #195717 */
+#define LOCAL_ALIGNMENT(TYPE, ALIGN) DATA_ALIGNMENT (TYPE, ALIGN)
+
 /* Set this nonzero if move instructions will actually fail to work
    when given unaligned data.  */
 #define STRICT_ALIGNMENT 1
diff --git a/gcc/configure b/gcc/configure
index 550a7c5..6dd8bd5 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -12736,7 +12736,7 @@ then
 	    | powerpc*-*-*,powerpc64*-*-*)
 		CROSS="$CROSS -DNATIVE_CROSS" ;;
 	esac
-elif test "x$TARGET_SYSTEM_ROOT" != x; then
+elif test "x$TARGET_SYSTEM_ROOT" != x -o $build != $host; then
         SYSTEM_HEADER_DIR=$build_system_header_dir
 fi
 
@@ -14762,7 +14762,7 @@ foo:	.long	25
 	tls_first_minor=14
 	tls_as_opt="-m64 -Aesame --fatal-warnings"
 	;;
-  sh-*-* | sh[34]-*-*)
+  sh-*-* | sh[34]*-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
 foo:	.long	25
diff --git a/gcc/configure.ac b/gcc/configure.ac
index da97fca..b073f35 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -1688,7 +1688,7 @@ then
 	    | powerpc*-*-*,powerpc64*-*-*)
 		CROSS="$CROSS -DNATIVE_CROSS" ;;
 	esac
-elif test "x$TARGET_SYSTEM_ROOT" != x; then
+elif test "x$TARGET_SYSTEM_ROOT" != x -o $build != $host; then
         SYSTEM_HEADER_DIR=$build_system_header_dir 
 fi
 
@@ -2435,7 +2435,7 @@ foo:	.long	25
 	tls_first_minor=14
 	tls_as_opt="-m64 -Aesame --fatal-warnings"
 	;;
-  sh-*-* | sh[34]-*-*)
+  sh-*-* | sh[34]*-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
 foo:	.long	25
diff --git a/gcc/diagnostic.c b/gcc/diagnostic.c
index 7f4d814..d659b48 100644
--- a/gcc/diagnostic.c
+++ b/gcc/diagnostic.c
@@ -255,14 +255,14 @@ diagnostic_action_after_output (diagnostic_context *context,
       fnotice (stderr, "Please submit a full bug report,\n"
 	       "with preprocessed source if appropriate.\n"
 	       "See %s for instructions.\n", bug_report_url);
-      exit (FATAL_EXIT_CODE);
+      exit (ICE_EXIT_CODE);
 
     case DK_FATAL:
       if (context->abort_on_error)
 	real_abort ();
 
       fnotice (stderr, "compilation terminated.\n");
-      exit (FATAL_EXIT_CODE);
+      exit (ICE_EXIT_CODE);
 
     default:
       gcc_unreachable ();
diff --git a/gcc/dwarf2.h b/gcc/dwarf2.h
index d1b3b1b..e70474d 100644
--- a/gcc/dwarf2.h
+++ b/gcc/dwarf2.h
@@ -702,6 +702,7 @@ enum dwarf_call_frame_info
   };
 
 #define DW_CIE_ID	  0xffffffff
+#define DW64_CIE_ID	  0xffffffffffffffffULL
 #define DW_CIE_VERSION	  1
 
 #define DW_CFA_extended   0
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index c57eff9..8326ff0 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -329,6 +329,14 @@ dw_fde_node;
 #endif
 #endif
 
+/* CIE identifier.  */
+#if HOST_BITS_PER_WIDE_INT >= 64
+#define DWARF_CIE_ID \
+  (unsigned HOST_WIDE_INT) (DWARF_OFFSET_SIZE == 4 ? DW_CIE_ID : DW64_CIE_ID)
+#else
+#define DWARF_CIE_ID DW_CIE_ID
+#endif
+
 /* A pointer to the base of a table that contains frame description
    information for each routine.  */
 static GTY((length ("fde_table_allocated"))) dw_fde_ref fde_table;
@@ -2214,6 +2222,9 @@ output_call_frame_info (int for_eh)
   /* Output the CIE.  */
   ASM_GENERATE_INTERNAL_LABEL (l1, CIE_AFTER_SIZE_LABEL, for_eh);
   ASM_GENERATE_INTERNAL_LABEL (l2, CIE_END_LABEL, for_eh);
+  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)
+    dw2_asm_output_data (4, 0xffffffff,
+      "Initial length escape value indicating 64-bit DWARF extension");
   dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,
 			"Length of Common Information Entry");
   ASM_OUTPUT_LABEL (asm_out_file, l1);
@@ -2221,7 +2232,7 @@ output_call_frame_info (int for_eh)
   /* Now that the CIE pointer is PC-relative for EH,
      use 0 to identify the CIE.  */
   dw2_asm_output_data ((for_eh ? 4 : DWARF_OFFSET_SIZE),
-		       (for_eh ? 0 : DW_CIE_ID),
+		       (for_eh ? 0 : DWARF_CIE_ID),
 		       "CIE Identifier Tag");
 
   dw2_asm_output_data (1, DW_CIE_VERSION, "CIE Version");
@@ -2346,6 +2357,9 @@ output_call_frame_info (int for_eh)
       targetm.asm_out.internal_label (asm_out_file, FDE_LABEL, for_eh + i * 2);
       ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + i * 2);
       ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + i * 2);
+      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)
+	dw2_asm_output_data (4, 0xffffffff,
+			     "Initial length escape value indicating 64-bit DWARF extension");
       dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,
 			    "FDE Length");
       ASM_OUTPUT_LABEL (asm_out_file, l1);
@@ -6765,6 +6779,7 @@ value_format (dw_attr_ref a)
       return DW_FORM_addr;
     case dw_val_class_range_list:
     case dw_val_class_offset:
+    case dw_val_class_loc_list:
       switch (DWARF_OFFSET_SIZE)
 	{
 	case 4:
@@ -6774,10 +6789,6 @@ value_format (dw_attr_ref a)
 	default:
 	  gcc_unreachable ();
 	}
-    case dw_val_class_loc_list:
-      /* FIXME: Could be DW_FORM_data8, with a > 32 bit size
-	 .debug_loc section */
-      return DW_FORM_data4;
     case dw_val_class_loc:
       switch (constant_size (size_of_locs (AT_loc (a))))
 	{
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index 1ef981b..0e9a6c3 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -1783,6 +1783,13 @@ gfc_type_for_size (unsigned bits, int unsignedp)
 	  if (type && bits == TYPE_PRECISION (type))
 	    return type;
 	}
+
+      /* Handle TImode as a special case because it is used by some backends
+         (eg. ARM) even though it is not available for normal use.  */
+#if HOST_BITS_PER_WIDE_INT >= 64
+      if (bits == TYPE_PRECISION (intTI_type_node))
+	return intTI_type_node;
+#endif
     }
   else
     {
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 08fc3a8..74d805a 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -287,10 +287,12 @@ static char *load_specs (const char *);
 static void read_specs (const char *, int);
 static void set_spec (const char *, const char *);
 static struct compiler *lookup_compiler (const char *, size_t, const char *);
-static char *build_search_list (struct path_prefix *, const char *, int);
-static void putenv_from_prefixes (struct path_prefix *, const char *);
+static char *build_search_list (const struct path_prefix *, const char *,
+				bool, bool);
+static void putenv_from_prefixes (const struct path_prefix *, const char *,
+				  bool);
 static int access_check (const char *, int);
-static char *find_a_file (struct path_prefix *, const char *, int, int);
+static char *find_a_file (const struct path_prefix *, const char *, int, bool);
 static void add_prefix (struct path_prefix *, const char *, const char *,
 			int, int, int);
 static void add_sysrooted_prefix (struct path_prefix *, const char *,
@@ -313,13 +315,12 @@ static const char *eval_spec_function (const char *, const char *);
 static const char *handle_spec_function (const char *);
 static char *save_string (const char *, int);
 static void set_collect_gcc_options (void);
-static void do_spec_path (struct prefix_list *, const char *, int, int, int, const char *, const char *);
 static int do_spec_1 (const char *, int, const char *);
 static int do_spec_2 (const char *);
 static void do_option_spec (const char *, const char *);
 static void do_self_spec (const char *);
 static const char *find_file (const char *);
-static int is_directory (const char *, const char *, int);
+static int is_directory (const char *, bool);
 static const char *validate_switches (const char *);
 static void validate_all_switches (void);
 static inline void validate_switches_from_spec (const char *);
@@ -346,6 +347,9 @@ static void init_gcc_specs (struct obstack *, const char *, const char *,
 #if defined(HAVE_TARGET_OBJECT_SUFFIX) || defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
 static const char *convert_filename (const char *, int, int);
 #endif
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+static void retry_ice (const char *prog, const char **argv);
+#endif
 
 static const char *if_exists_spec_function (int, const char **);
 static const char *if_exists_else_spec_function (int, const char **);
@@ -2036,7 +2040,7 @@ read_specs (const char *filename, int main_p)
 		       (long) (p1 - buffer + 1));
 
 	      p[-2] = '\0';
-	      new_filename = find_a_file (&startfile_prefixes, p1, R_OK, 0);
+	      new_filename = find_a_file (&startfile_prefixes, p1, R_OK, true);
 	      read_specs (new_filename ? new_filename : p1, FALSE);
 	      continue;
 	    }
@@ -2055,7 +2059,7 @@ read_specs (const char *filename, int main_p)
 		       (long) (p1 - buffer + 1));
 
 	      p[-2] = '\0';
-	      new_filename = find_a_file (&startfile_prefixes, p1, R_OK, 0);
+	      new_filename = find_a_file (&startfile_prefixes, p1, R_OK, true);
 	      if (new_filename)
 		read_specs (new_filename, FALSE);
 	      else if (verbose_flag)
@@ -2352,64 +2356,213 @@ clear_failure_queue (void)
   failure_delete_queue = 0;
 }
 
-/* Build a list of search directories from PATHS.
-   PREFIX is a string to prepend to the list.
-   If CHECK_DIR_P is nonzero we ensure the directory exists.
-   This is used mostly by putenv_from_prefixes so we use `collect_obstack'.
-   It is also used by the --print-search-dirs flag.  */
-
-static char *
-build_search_list (struct path_prefix *paths, const char *prefix,
-		   int check_dir_p)
+/* Call CALLBACK for each path in PATHS, breaking out early if CALLBACK
+   returns non-NULL.
+   If DO_MULTI is true iterate over the paths twice, first with multilib
+   suffix then without, otherwise iterate over the paths once without
+   adding a multilib suffix.  When DO_MULTI is true, some attempt is made
+   to avoid visiting the same path twice, but we could do better.  For
+   instance, /usr/lib/../lib is considered different from /usr/lib.
+   At least EXTRA_SPACE chars past the end of the path passed to
+   CALLBACK are available for use by the callback.
+   CALLBACK_INFO allows extra parameters to be passed to CALLBACK.
+
+   Returns the value returned by CALLBACK.  */
+
+static void *
+for_each_path (const struct path_prefix *paths,
+	       bool do_multi,
+	       size_t extra_space,
+	       void *(*callback) (char *, void *),
+	       void *callback_info)
 {
-  int suffix_len = (machine_suffix) ? strlen (machine_suffix) : 0;
-  int just_suffix_len
-    = (just_machine_suffix) ? strlen (just_machine_suffix) : 0;
-  int first_time = TRUE;
-  struct prefix_list *pprefix;
-
-  obstack_grow (&collect_obstack, prefix, strlen (prefix));
-  obstack_1grow (&collect_obstack, '=');
-
-  for (pprefix = paths->plist; pprefix != 0; pprefix = pprefix->next)
+  struct prefix_list *pl;
+  const char *multi_dir = NULL;
+  const char *multi_os_dir = NULL;
+  const char *multi_suffix;
+  const char *just_multi_suffix;
+  char *path = NULL;
+  void *ret = NULL;
+  bool skip_multi_dir = false;
+  bool skip_multi_os_dir = false;
+
+  multi_suffix = machine_suffix;
+  just_multi_suffix = just_machine_suffix;
+  if (do_multi && multilib_dir && strcmp (multilib_dir, ".") != 0)
     {
-      int len = strlen (pprefix->prefix);
+      multi_dir = concat (multilib_dir, dir_separator_str, NULL);
+      multi_suffix = concat (multi_suffix, multi_dir, NULL);
+      just_multi_suffix = concat (just_multi_suffix, multi_dir, NULL);
+    }
+  if (do_multi && multilib_os_dir && strcmp (multilib_os_dir, ".") != 0)
+    multi_os_dir = concat (multilib_os_dir, dir_separator_str, NULL);
 
-      if (machine_suffix
-	  && (! check_dir_p
-	      || is_directory (pprefix->prefix, machine_suffix, 0)))
+  while (1)
+    {
+      size_t multi_dir_len = 0;
+      size_t multi_os_dir_len = 0;
+      size_t suffix_len;
+      size_t just_suffix_len;
+      size_t len;
+
+      if (multi_dir)
+	multi_dir_len = strlen (multi_dir);
+      if (multi_os_dir)
+	multi_os_dir_len = strlen (multi_os_dir);
+      suffix_len = strlen (multi_suffix);
+      just_suffix_len = strlen (just_multi_suffix);
+
+      if (path == NULL)
 	{
-	  if (!first_time)
-	    obstack_1grow (&collect_obstack, PATH_SEPARATOR);
-
-	  first_time = FALSE;
-	  obstack_grow (&collect_obstack, pprefix->prefix, len);
-	  obstack_grow (&collect_obstack, machine_suffix, suffix_len);
+	  len = paths->max_len + extra_space + 1;
+	  if (suffix_len > multi_os_dir_len)
+	    len += suffix_len;
+	  else
+	    len += multi_os_dir_len;
+	  path = xmalloc (len);
 	}
 
-      if (just_machine_suffix
-	  && pprefix->require_machine_suffix == 2
-	  && (! check_dir_p
-	      || is_directory (pprefix->prefix, just_machine_suffix, 0)))
+      for (pl = paths->plist; pl != 0; pl = pl->next)
 	{
-	  if (! first_time)
-	    obstack_1grow (&collect_obstack, PATH_SEPARATOR);
+	  len = strlen (pl->prefix);
+	  memcpy (path, pl->prefix, len);
+
+	  /* Look first in MACHINE/VERSION subdirectory.  */
+	  if (!skip_multi_dir)
+	    {
+	      memcpy (path + len, multi_suffix, suffix_len + 1);
+	      ret = callback (path, callback_info);
+	      if (ret)
+		break;
+	    }
+
+	  /* Some paths are tried with just the machine (ie. target)
+	     subdir.  This is used for finding as, ld, etc.  */
+	  if (!skip_multi_dir
+	      && pl->require_machine_suffix == 2)
+	    {
+	      memcpy (path + len, just_multi_suffix, just_suffix_len + 1);
+	      ret = callback (path, callback_info);
+	      if (ret)
+		break;
+	    }
+
+	  /* Now try the base path.  */
+	  if (!pl->require_machine_suffix
+	      && !(pl->os_multilib ? skip_multi_os_dir : skip_multi_dir))
+	    {
+	      const char *this_multi;
+	      size_t this_multi_len;
+
+	      if (pl->os_multilib)
+		{
+		  this_multi = multi_os_dir;
+		  this_multi_len = multi_os_dir_len;
+		}
+	      else
+		{
+		  this_multi = multi_dir;
+		  this_multi_len = multi_dir_len;
+		}
+
+	      if (this_multi_len)
+		memcpy (path + len, this_multi, this_multi_len + 1);
+	      else
+		path[len] = '\0';
 
-	  first_time = FALSE;
-	  obstack_grow (&collect_obstack, pprefix->prefix, len);
-	  obstack_grow (&collect_obstack, just_machine_suffix,
-			just_suffix_len);
+	      ret = callback (path, callback_info);
+	      if (ret)
+		break;
+	    }
 	}
+      if (pl)
+	break;
 
-      if (! pprefix->require_machine_suffix)
-	{
-	  if (! first_time)
-	    obstack_1grow (&collect_obstack, PATH_SEPARATOR);
+      if (multi_dir == NULL && multi_os_dir == NULL)
+	break;
 
-	  first_time = FALSE;
-	  obstack_grow (&collect_obstack, pprefix->prefix, len);
+      /* Run through the paths again, this time without multilibs.
+	 Don't repeat any we have already seen.  */
+      if (multi_dir)
+	{
+	  free ((char *) multi_dir);
+	  multi_dir = NULL;
+	  free ((char *) multi_suffix);
+	  multi_suffix = machine_suffix;
+	  free ((char *) just_multi_suffix);
+	  just_multi_suffix = just_machine_suffix;
+	}
+      else
+	skip_multi_dir = true;
+      if (multi_os_dir)
+	{
+	  free ((char *) multi_os_dir);
+	  multi_os_dir = NULL;
 	}
+      else
+	skip_multi_os_dir = true;
+    }
+
+  if (multi_dir)
+    {
+      free ((char *) multi_dir);
+      free ((char *) multi_suffix);
+      free ((char *) just_multi_suffix);
     }
+  if (multi_os_dir)
+    free ((char *) multi_os_dir);
+  if (ret != path)
+    free (path);
+  return ret;
+}
+
+/* Callback for build_search_list.  Adds path to obstack being built.  */
+
+struct add_to_obstack_info {
+  struct obstack *ob;
+  bool check_dir;
+  bool first_time;
+};
+
+static void *
+add_to_obstack (char *path, void *data)
+{
+  struct add_to_obstack_info *info = data;
+
+  if (info->check_dir && !is_directory (path, false))
+    return NULL;
+
+  if (!info->first_time)
+    obstack_1grow (info->ob, PATH_SEPARATOR);
+
+  obstack_grow (info->ob, path, strlen (path));
+
+  info->first_time = false;
+  return NULL;
+}
+
+/* Build a list of search directories from PATHS.
+   PREFIX is a string to prepend to the list.
+   If CHECK_DIR_P is true we ensure the directory exists.
+   If DO_MULTI is true, multilib paths are output first, then
+   non-multilib paths.
+   This is used mostly by putenv_from_prefixes so we use `collect_obstack'.
+   It is also used by the --print-search-dirs flag.  */
+
+static char *
+build_search_list (const struct path_prefix *paths, const char *prefix,
+		   bool check_dir, bool do_multi)
+{
+  struct add_to_obstack_info info;
+
+  info.ob = &collect_obstack;
+  info.check_dir = check_dir;
+  info.first_time = true;
+
+  obstack_grow (&collect_obstack, prefix, strlen (prefix));
+  obstack_1grow (&collect_obstack, '=');
+
+  for_each_path (paths, do_multi, 0, add_to_obstack, &info);
 
   obstack_1grow (&collect_obstack, '\0');
   return XOBFINISH (&collect_obstack, char *);
@@ -2419,9 +2572,10 @@ build_search_list (struct path_prefix *paths, const char *prefix,
    for collect.  */
 
 static void
-putenv_from_prefixes (struct path_prefix *paths, const char *env_var)
+putenv_from_prefixes (const struct path_prefix *paths, const char *env_var,
+		      bool do_multi)
 {
-  putenv (build_search_list (paths, env_var, 1));
+  putenv (build_search_list (paths, env_var, true, do_multi));
 }
 
 /* Check whether NAME can be accessed in MODE.  This is like access,
@@ -2442,20 +2596,53 @@ access_check (const char *name, int mode)
   return access (name, mode);
 }
 
+/* Callback for find_a_file.  Appends the file name to the directory
+   path.  If the resulting file exists in the right mode, return the
+   full pathname to the file.  */
+
+struct file_at_path_info {
+  const char *name;
+  const char *suffix;
+  int name_len;
+  int suffix_len;
+  int mode;
+};
+
+static void *
+file_at_path (char *path, void *data)
+{
+  struct file_at_path_info *info = data;
+  size_t len = strlen (path);
+
+  memcpy (path + len, info->name, info->name_len);
+  len += info->name_len;
+
+  /* Some systems have a suffix for executable files.
+     So try appending that first.  */
+  if (info->suffix_len)
+    {
+      memcpy (path + len, info->suffix, info->suffix_len + 1);
+      if (access_check (path, info->mode) == 0)
+	return path;
+    }
+
+  path[len] = '\0';
+  if (access_check (path, info->mode) == 0)
+    return path;
+
+  return NULL;
+}
+
 /* Search for NAME using the prefix list PREFIXES.  MODE is passed to
-   access to check permissions.
+   access to check permissions.  If DO_MULTI is true, search multilib
+   paths then non-multilib paths, otherwise do not search multilib paths.
    Return 0 if not found, otherwise return its name, allocated with malloc.  */
 
 static char *
-find_a_file (struct path_prefix *pprefix, const char *name, int mode,
-	     int multilib)
+find_a_file (const struct path_prefix *pprefix, const char *name, int mode,
+	     bool do_multi)
 {
-  char *temp;
-  const char *const file_suffix =
-    ((mode & X_OK) != 0 ? HOST_EXECUTABLE_SUFFIX : "");
-  struct prefix_list *pl;
-  int len = pprefix->max_len + strlen (name) + strlen (file_suffix) + 1;
-  const char *multilib_name, *multilib_os_name;
+  struct file_at_path_info info;
 
 #ifdef DEFAULT_ASSEMBLER
   if (! strcmp (name, "as") && access (DEFAULT_ASSEMBLER, mode) == 0)
@@ -2467,112 +2654,24 @@ find_a_file (struct path_prefix *pprefix, const char *name, int mode,
     return xstrdup (DEFAULT_LINKER);
 #endif
 
-  if (machine_suffix)
-    len += strlen (machine_suffix);
-
-  multilib_name = name;
-  multilib_os_name = name;
-  if (multilib && multilib_os_dir)
-    {
-      int len1 = multilib_dir ? strlen (multilib_dir) + 1 : 0;
-      int len2 = strlen (multilib_os_dir) + 1;
-
-      len += len1 > len2 ? len1 : len2;
-      if (multilib_dir)
-	multilib_name = ACONCAT ((multilib_dir, dir_separator_str, name,
-				  NULL));
-      if (strcmp (multilib_os_dir, ".") != 0)
-	multilib_os_name = ACONCAT ((multilib_os_dir, dir_separator_str, name,
-				    NULL));
-    }
-
-  temp = xmalloc (len);
-
   /* Determine the filename to execute (special case for absolute paths).  */
 
   if (IS_ABSOLUTE_PATH (name))
     {
       if (access (name, mode) == 0)
-	{
-	  strcpy (temp, name);
-	  return temp;
-	}
-    }
-  else
-    for (pl = pprefix->plist; pl; pl = pl->next)
-      {
-	const char *this_name
-	  = pl->os_multilib ? multilib_os_name : multilib_name;
-
-	if (machine_suffix)
-	  {
-	    /* Some systems have a suffix for executable files.
-	       So try appending that first.  */
-	    if (file_suffix[0] != 0)
-	      {
-		strcpy (temp, pl->prefix);
-		strcat (temp, machine_suffix);
-		strcat (temp, multilib_name);
-		strcat (temp, file_suffix);
-		if (access_check (temp, mode) == 0)
-		  return temp;
-	      }
-
-	    /* Now try just the multilib_name.  */
-	    strcpy (temp, pl->prefix);
-	    strcat (temp, machine_suffix);
-	    strcat (temp, multilib_name);
-	    if (access_check (temp, mode) == 0)
-	      return temp;
-	  }
-
-	/* Certain prefixes are tried with just the machine type,
-	   not the version.  This is used for finding as, ld, etc.  */
-	if (just_machine_suffix && pl->require_machine_suffix == 2)
-	  {
-	    /* Some systems have a suffix for executable files.
-	       So try appending that first.  */
-	    if (file_suffix[0] != 0)
-	      {
-		strcpy (temp, pl->prefix);
-		strcat (temp, just_machine_suffix);
-		strcat (temp, multilib_name);
-		strcat (temp, file_suffix);
-		if (access_check (temp, mode) == 0)
-		  return temp;
-	      }
-
-	    strcpy (temp, pl->prefix);
-	    strcat (temp, just_machine_suffix);
-	    strcat (temp, multilib_name);
-	    if (access_check (temp, mode) == 0)
-	      return temp;
-	  }
+	return xstrdup (name);
 
-	/* Certain prefixes can't be used without the machine suffix
-	   when the machine or version is explicitly specified.  */
-	if (! pl->require_machine_suffix)
-	  {
-	    /* Some systems have a suffix for executable files.
-	       So try appending that first.  */
-	    if (file_suffix[0] != 0)
-	      {
-		strcpy (temp, pl->prefix);
-		strcat (temp, this_name);
-		strcat (temp, file_suffix);
-		if (access_check (temp, mode) == 0)
-		  return temp;
-	      }
+      return NULL;
+    }
 
-	    strcpy (temp, pl->prefix);
-	    strcat (temp, this_name);
-	    if (access_check (temp, mode) == 0)
-	      return temp;
-	  }
-      }
+  info.name = name;
+  info.suffix = (mode & X_OK) != 0 ? HOST_EXECUTABLE_SUFFIX : "";
+  info.name_len = strlen (info.name);
+  info.suffix_len = strlen (info.suffix);
+  info.mode = mode;
 
-  free (temp);
-  return 0;
+  return for_each_path (pprefix, do_multi, info.name_len + info.suffix_len,
+			file_at_path, &info);
 }
 
 /* Ranking of prefixes in the sort list. -B prefixes are put before
@@ -2691,7 +2790,7 @@ execute (void)
 
   commands[0].prog = argbuf[0]; /* first command.  */
   commands[0].argv = &argbuf[0];
-  string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, 0);
+  string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, false);
 
   if (string)
     commands[0].argv[0] = string;
@@ -2706,7 +2805,7 @@ execute (void)
 	commands[n_commands].prog = argbuf[i + 1];
 	commands[n_commands].argv = &argbuf[i + 1];
 	string = find_a_file (&exec_prefixes, commands[n_commands].prog,
-			      X_OK, 0);
+			      X_OK, false);
 	if (string)
 	  commands[n_commands].argv[0] = string;
 	n_commands++;
@@ -2830,7 +2929,7 @@ execute (void)
 	    }
 	}
 
-      if (string != commands[i].prog)
+      if (i && string != commands[i].prog)
 	free ((void *) string);
     }
 
@@ -2886,6 +2985,17 @@ See %s for instructions.",
 	else if (WIFEXITED (status)
 		 && WEXITSTATUS (status) >= MIN_FATAL_STATUS)
 	  {
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+	    /* For ICEs in cc1, cc1obj, cc1plus see if it is
+	       reproducible or not.  */
+	    char *p;
+	    if (getenv("GCC_RETRY_ICE") == NULL
+		&& WEXITSTATUS (status) == ICE_EXIT_CODE
+		&& i == 0
+		&& (p = strrchr (commands[0].argv[0], DIR_SEPARATOR))
+		&& ! strncmp (p + 1, "cc1", 3))
+	      retry_ice (commands[0].prog, commands[0].argv);
+#endif
 	    if (WEXITSTATUS (status) > greatest_status)
 	      greatest_status = WEXITSTATUS (status);
 	    ret_code = -1;
@@ -2906,6 +3016,9 @@ See %s for instructions.",
 	  }
       }
 
+    if (commands[0].argv[0] != commands[0].prog)
+      free ((PTR) commands[0].argv[0]);
+
     return ret_code;
   }
 }
@@ -3646,7 +3759,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
 		   if appending a directory separator actually makes a
 		   valid directory name.  */
 		if (! IS_DIR_SEPARATOR (value [len - 1])
-		    && is_directory (value, "", 0))
+		    && is_directory (value, false))
 		  {
 		    char *tmp = xmalloc (len + 2);
 		    strcpy (tmp, value);
@@ -4394,108 +4507,55 @@ do_self_spec (const char *spec)
     }
 }
 
-void
-do_spec_path (struct prefix_list *pl, const char *option,
-	      int omit_if_relative, int separate_options,
-	      int only_subdir,
-	      const char *dir_for_machine_suffix,
-	      const char *dir_for_no_suffix)
+/* Callback for processing %D and %I specs.  */
+
+struct spec_path_info {
+  const char *option;
+  const char *append;
+  size_t append_len;
+  bool omit_relative;
+  bool separate_options;
+};
+
+static void *
+spec_path (char *path, void *data)
 {
-  static size_t bufsize = 0;
-  static char *buffer;
-  int idx;
-  bool multilib_p = false;
-
-  /* Used on systems which record the specified -L dirs
-     and use them to search for dynamic linking.  */
-  /* Relative directories always come from -B,
-     and it is better not to use them for searching
-     at run time.  In particular, stage1 loses.  */
-  if (omit_if_relative
-      && !IS_ABSOLUTE_PATH (pl->prefix))
-    return;
+  struct spec_path_info *info = data;
+  size_t len = 0;
+  char save = 0;
 
-  /* Try subdirectory if there is one.  */
-  if (machine_suffix && dir_for_machine_suffix)
-    {
-      if (strlen (pl->prefix) + strlen (machine_suffix)
-	  >= bufsize)
-	bufsize = (strlen (pl->prefix)
-		  + strlen (machine_suffix)) * 2 + 1;
-      buffer = xrealloc (buffer, bufsize);
-      strcpy (buffer, pl->prefix);
-      strcat (buffer, machine_suffix);
-      if (is_directory (buffer, dir_for_machine_suffix, 1))
-	{
-	  multilib_p = true;
-	  do_spec_1 (option, separate_options, NULL);
-	  if (separate_options)
-	    do_spec_1 (" ", 0, NULL);
-	  do_spec_1 (buffer, 1, NULL);
-	  do_spec_1 (dir_for_machine_suffix, 1, NULL);
-	  /* Make this a separate argument.  */
-	  do_spec_1 (" ", 0, NULL);
-	}
-    }
-  if (!pl->require_machine_suffix && dir_for_no_suffix)
+  if (info->omit_relative && !IS_ABSOLUTE_PATH (path))
+    return NULL;
+
+  if (info->append_len != 0)
     {
-      if (is_directory (pl->prefix, dir_for_no_suffix, 1))
-	{
-	  multilib_p = true;
-	  do_spec_1 (option, separate_options, NULL);
-	  if (separate_options)
-	    do_spec_1 (" ", 0, NULL);
-	  do_spec_1 (pl->prefix, 1, NULL);
-	  do_spec_1 (dir_for_no_suffix, 1, NULL);
-	  /* Make this a separate argument.  */
-	  do_spec_1 (" ", 0, NULL);
-	}
+      len = strlen (path);
+      memcpy (path + len, info->append, info->append_len + 1);
     }
 
-  if (only_subdir || multilib_p)
-    return;
+  if (!is_directory (path, true))
+    return NULL;
 
-  if (machine_suffix)
-    {
-      if (is_directory (pl->prefix, machine_suffix, 1))
-	{
-	  do_spec_1 (option, separate_options, NULL);
-	  if (separate_options)
-	    do_spec_1 (" ", 0, NULL);
-	  do_spec_1 (pl->prefix, 1, NULL);
-	  /* Remove slash from machine_suffix.  */
-	  if (strlen (machine_suffix) >= bufsize)
-	    bufsize = strlen (machine_suffix) * 2 + 1;
-	  buffer = xrealloc (buffer, bufsize);
-	  strcpy (buffer, machine_suffix);
-	  idx = strlen (buffer);
-	  if (IS_DIR_SEPARATOR (buffer[idx - 1]))
-	    buffer[idx - 1] = 0;
-	  do_spec_1 (buffer, 1, NULL);
-	  /* Make this a separate argument.  */
-	  do_spec_1 (" ", 0, NULL);
-	}
-    }
-  if (!pl->require_machine_suffix)
+  do_spec_1 (info->option, 1, NULL);
+  if (info->separate_options)
+    do_spec_1 (" ", 0, NULL);
+
+  if (info->append_len == 0)
     {
-      if (is_directory (pl->prefix, "", 1))
-	{
-	  do_spec_1 (option, separate_options, NULL);
-	  if (separate_options)
-	    do_spec_1 (" ", 0, NULL);
-	  /* Remove slash from pl->prefix.  */
-	  if (strlen (pl->prefix) >= bufsize)
-	    bufsize = strlen (pl->prefix) * 2 + 1;
-	  buffer = xrealloc (buffer, bufsize);
-	  strcpy (buffer, pl->prefix);
-	  idx = strlen (buffer);
-	  if (IS_DIR_SEPARATOR (buffer[idx - 1]))
-	    buffer[idx - 1] = 0;
-	  do_spec_1 (buffer, 1, NULL);
-	  /* Make this a separate argument.  */
-	  do_spec_1 (" ", 0, NULL);
-	}
+      len = strlen (path);
+      save = path[len - 1];
+      if (IS_DIR_SEPARATOR (path[len - 1]))
+	path[len - 1] = '\0';
     }
+
+  do_spec_1 (path, 1, NULL);
+  do_spec_1 (" ", 0, NULL);
+
+  /* Must not damage the original path.  */
+  if (info->append_len == 0)
+    path[len - 1] = save;
+
+  return NULL;
 }
 
 /* Process the sub-spec SPEC as a portion of a larger spec.
@@ -4633,23 +4693,23 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)
 	     that we search for startfiles.  */
 	  case 'D':
 	    {
-	      struct prefix_list *pl = startfile_prefixes.plist;
+	      struct spec_path_info info;
 
-	      for (; pl; pl = pl->next)
-		{
-		  const char *no_suffix_multilib_dir;
-
-		  no_suffix_multilib_dir = pl->os_multilib ? multilib_os_dir
-					   : multilib_dir;
-		  /* Do not separate options, include non-multilibbed variant.  */
-		  do_spec_path (pl, "-L",
+	      info.option = "-L";
+	      info.append_len = 0;
 #ifdef RELATIVE_PREFIX_NOT_LINKDIR
-				1,
+	      /* Used on systems which record the specified -L dirs
+		 and use them to search for dynamic linking.
+		 Relative directories always come from -B,
+		 and it is better not to use them for searching
+		 at run time.  In particular, stage1 loses.  */
+	      info.omit_relative = true;
 #else
-				0,
+	      info.omit_relative = false;
 #endif
-				0, 0, multilib_dir, no_suffix_multilib_dir);
-		}
+	      info.separate_options = false;
+
+	      for_each_path (&startfile_prefixes, true, 0, spec_path, &info);
 	    }
 	    break;
 
@@ -4886,7 +4946,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)
 
 	  case 'I':
 	    {
-	      struct prefix_list *pl = include_prefixes.plist;
+	      struct spec_path_info info;
 
 	      if (gcc_exec_prefix)
 		{
@@ -4909,9 +4969,14 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)
 		  do_spec_1 (" ", 0, NULL);
 		}
 
-	      for (; pl; pl = pl->next)
-		/* Separate options, don't include non-suffixed variant.  */
-		do_spec_path (pl, "-isystem", 0, 1, 1, "include", "include");
+	      info.option = "-isystem";
+	      info.append = "include";
+	      info.append_len = strlen (info.append);
+	      info.omit_relative = false;
+	      info.separate_options = true;
+
+	      for_each_path (&include_prefixes, false, info.append_len,
+			     spec_path, &info);
 	    }
 	    break;
 
@@ -5890,55 +5955,252 @@ give_switch (int switchnum, int omit_first_word)
   switches[switchnum].validated = 1;
 }
 
-/* Search for a file named NAME trying various prefixes including the
-   user's -B prefix and some standard ones.
-   Return the absolute file name found.  If nothing is found, return NAME.  */
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+#define RETRY_ICE_ATTEMPTS 2
 
-static const char *
-find_file (const char *name)
+static void
+retry_ice (const char *prog, const char **argv)
 {
-  char *newname;
+  int nargs, out_arg = -1, quiet = 0, attempt;
+  int pid, retries, sleep_interval;
+  const char **new_argv;
+  char *temp_filenames[RETRY_ICE_ATTEMPTS * 2 + 2];
+
+  if (input_filename == NULL || ! strcmp (input_filename, "-"))
+    return;
+
+  for (nargs = 0; argv[nargs] != NULL; ++nargs)
+    /* Only retry compiler ICEs, not preprocessor ones.  */
+    if (! strcmp (argv[nargs], "-E"))
+      return;
+    else if (argv[nargs][0] == '-' && argv[nargs][1] == 'o')
+      {
+	if (out_arg == -1)
+	  out_arg = nargs;
+	else
+	  return;
+      }
+    /* If the compiler is going to output any time information,
+       it might vary between invocations.  */
+    else if (! strcmp (argv[nargs], "-quiet"))
+      quiet = 1;
+    else if (! strcmp (argv[nargs], "-ftime-report"))
+      return;
+
+  if (out_arg == -1 || !quiet)
+    return;
+
+  memset (temp_filenames, '\0', sizeof (temp_filenames));
+  new_argv = alloca ((nargs + 3) * sizeof (const char *));
+  memcpy (new_argv, argv, (nargs + 1) * sizeof (const char *));
+  new_argv[nargs++] = "-frandom-seed=0";
+  new_argv[nargs] = NULL;
+  if (new_argv[out_arg][2] == '\0')
+    new_argv[out_arg + 1] = "-";
+  else
+    new_argv[out_arg] = "-o-";
 
-  /* Try multilib_dir if it is defined.  */
-  if (multilib_os_dir != NULL)
+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS + 1; ++attempt)
     {
-      newname = find_a_file (&startfile_prefixes, name, R_OK, 1);
+      int fd = -1;
+      int status;
+
+      temp_filenames[attempt * 2] = make_temp_file (".out");
+      temp_filenames[attempt * 2 + 1] = make_temp_file (".err");
+
+      if (attempt == RETRY_ICE_ATTEMPTS)
+        {
+	  int i;
+	  int fd1, fd2;
+	  struct stat st1, st2;
+	  size_t n, len;
+	  char *buf;
 
-      /* If we don't find it in the multi library dir, then fall
-	 through and look for it in the normal places.  */
-      if (newname != NULL)
-	return newname;
+	  buf = xmalloc (8192);
+
+	  for (i = 0; i < 2; ++i)
+	    {
+	      fd1 = open (temp_filenames[i], O_RDONLY);
+	      fd2 = open (temp_filenames[2 + i], O_RDONLY);
+
+	      if (fd1 < 0 || fd2 < 0)
+		{
+		  i = -1;
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      if (fstat (fd1, &st1) < 0 || fstat (fd2, &st2) < 0)
+		{
+		  i = -1;
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      if (st1.st_size != st2.st_size)
+		{
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      len = 0;
+	      for (n = st1.st_size; n; n -= len)
+		{
+		  len = n;
+		  if (len > 4096)
+		    len = 4096;
+
+		  if (read (fd1, buf, len) != (int) len
+		      || read (fd2, buf + 4096, len) != (int) len)
+		    {
+		      i = -1;
+		      break;
+		    }
+
+		  if (memcmp (buf, buf + 4096, len) != 0)
+		    break;
+		}
+
+	      close (fd1);
+	      close (fd2);
+
+	      if (n)
+		break;
+	    }
+
+	  free (buf);
+	  if (i == -1)
+	    break;
+
+	  if (i != 2)
+	    {
+	      notice ("The bug is not reproducible, so it is likely a hardware or OS problem.\n");
+	      break;
+	    }
+
+          fd = open (temp_filenames[attempt * 2], O_RDWR);
+	  if (fd < 0)
+	    break;
+	  write (fd, "//", 2);
+	  for (i = 0; i < nargs; i++)
+	    {
+	      write (fd, " ", 1);
+	      write (fd, new_argv[i], strlen (new_argv[i]));
+	    }
+	  write (fd, "\n", 1);
+	  new_argv[nargs] = "-E";
+	  new_argv[nargs + 1] = NULL;
+        }
+
+      /* Fork a subprocess; wait and retry if it fails.  */
+      sleep_interval = 1;
+      pid = -1;
+      for (retries = 0; retries < 4; retries++)
+	{
+	  pid = fork ();
+	  if (pid >= 0)
+	    break;
+	  sleep (sleep_interval);
+	  sleep_interval *= 2;
+	}
+
+      if (pid < 0)
+	break;
+      else if (pid == 0)
+	{
+	  if (attempt != RETRY_ICE_ATTEMPTS)
+	    fd = open (temp_filenames[attempt * 2], O_RDWR);
+	  if (fd < 0)
+	    exit (-1);
+	  if (fd != 1)
+	    {
+	      close (1);
+	      dup (fd);
+	      close (fd);
+	    }
+
+	  fd = open (temp_filenames[attempt * 2 + 1], O_RDWR);
+	  if (fd < 0)
+	    exit (-1);
+	  if (fd != 2)
+	    {
+	      close (2);
+	      dup (fd);
+	      close (fd);
+	    }
+
+	  if (prog == new_argv[0])
+	    execvp (prog, (char *const *) new_argv);
+	  else
+	    execv (new_argv[0], (char *const *) new_argv);
+	  exit (-1);
+	}
+
+      if (waitpid (pid, &status, 0) < 0)
+	break;
+
+      if (attempt < RETRY_ICE_ATTEMPTS
+	  && (! WIFEXITED (status) || WEXITSTATUS (status) != ICE_EXIT_CODE))
+	{
+	  notice ("The bug is not reproducible, so it is likely a hardware or OS problem.\n");
+	  break;
+	}
+      else if (attempt == RETRY_ICE_ATTEMPTS)
+	{
+	  close (fd);
+	  if (WIFEXITED (status)
+	      && WEXITSTATUS (status) == SUCCESS_EXIT_CODE)
+	    {
+	      notice ("Preprocessed source stored into %s file, please attach this to your bugreport.\n",
+		      temp_filenames[attempt * 2]);
+	      /* Make sure it is not deleted.  */
+	      free (temp_filenames[attempt * 2]);
+	      temp_filenames[attempt * 2] = NULL;
+	      break;
+	    }
+	}
     }
 
-  newname = find_a_file (&startfile_prefixes, name, R_OK, 0);
+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS * 2 + 2; attempt++)
+    if (temp_filenames[attempt])
+      {
+	unlink (temp_filenames[attempt]);
+	free (temp_filenames[attempt]);
+      }
+}
+#endif
+
+/* Search for a file named NAME trying various prefixes including the
+   user's -B prefix and some standard ones.
+   Return the absolute file name found.  If nothing is found, return NAME.  */
+
+static const char *
+find_file (const char *name)
+{
+  char *newname = find_a_file (&startfile_prefixes, name, R_OK, true);
   return newname ? newname : name;
 }
 
 /* Determine whether a directory exists.  If LINKER, return 0 for
-   certain fixed names not needed by the linker.  If not LINKER, it is
-   only important to return 0 if the host machine has a small ARG_MAX
-   limit.  */
+   certain fixed names not needed by the linker.  */
 
 static int
-is_directory (const char *path1, const char *path2, int linker)
+is_directory (const char *path1, bool linker)
 {
-  int len1 = strlen (path1);
-  int len2 = strlen (path2);
-  char *path = alloca (3 + len1 + len2);
+  int len1;
+  char *path;
   char *cp;
   struct stat st;
 
-#ifndef SMALL_ARG_MAX
-  if (! linker)
-    return 1;
-#endif
-
-  /* Construct the path from the two parts.  Ensure the string ends with "/.".
-     The resulting path will be a directory even if the given path is a
-     symbolic link.  */
+  /* Ensure the string ends with "/.".  The resulting path will be a
+     directory even if the given path is a symbolic link.  */
+  len1 = strlen (path1);
+  path = alloca (3 + len1);
   memcpy (path, path1, len1);
-  memcpy (path + len1, path2, len2);
-  cp = path + len1 + len2;
+  cp = path + len1;
   if (!IS_DIR_SEPARATOR (cp[-1]))
     *cp++ = DIR_SEPARATOR;
   *cp++ = '.';
@@ -5946,13 +6208,13 @@ is_directory (const char *path1, const char *path2, int linker)
 
   /* Exclude directories that the linker is known to search.  */
   if (linker
+      && IS_DIR_SEPARATOR (path[0])
       && ((cp - path == 6
-	   && strcmp (path, concat (dir_separator_str, "lib",
-				    dir_separator_str, ".", NULL)) == 0)
+	   && strncmp (path + 1, "lib", 3) == 0)
 	  || (cp - path == 10
-	      && strcmp (path, concat (dir_separator_str, "usr",
-				       dir_separator_str, "lib",
-				       dir_separator_str, ".", NULL)) == 0)))
+	      && strncmp (path + 1, "usr", 3) == 0
+	      && IS_DIR_SEPARATOR (path[4])
+	      && strncmp (path + 5, "lib", 3) == 0)))
     return 0;
 
   return (stat (path, &st) >= 0 && S_ISDIR (st.st_mode));
@@ -6142,7 +6404,7 @@ main (int argc, const char **argv)
 			   spec_version, dir_separator_str, NULL);
   just_machine_suffix = concat (spec_machine, dir_separator_str, NULL);
 
-  specs_file = find_a_file (&startfile_prefixes, "specs", R_OK, 0);
+  specs_file = find_a_file (&startfile_prefixes, "specs", R_OK, true);
   /* Read the specs file unless it is a default one.  */
   if (specs_file != 0 && strcmp (specs_file, "specs"))
     read_specs (specs_file, TRUE);
@@ -6278,7 +6540,7 @@ main (int argc, const char **argv)
   for (uptr = user_specs_head; uptr; uptr = uptr->next)
     {
       char *filename = find_a_file (&startfile_prefixes, uptr->filename,
-				    R_OK, 0);
+				    R_OK, true);
       read_specs (filename ? filename : uptr->filename, FALSE);
     }
 
@@ -6307,8 +6569,10 @@ main (int argc, const char **argv)
   if (print_search_dirs)
     {
       printf (_("install: %s%s\n"), standard_exec_prefix, machine_suffix);
-      printf (_("programs: %s\n"), build_search_list (&exec_prefixes, "", 0));
-      printf (_("libraries: %s\n"), build_search_list (&startfile_prefixes, "", 0));
+      printf (_("programs: %s\n"),
+	      build_search_list (&exec_prefixes, "", false, false));
+      printf (_("libraries: %s\n"),
+	      build_search_list (&startfile_prefixes, "", false, true));
       return (0);
     }
 
@@ -6625,14 +6889,14 @@ main (int argc, const char **argv)
       /* We'll use ld if we can't find collect2.  */
       if (! strcmp (linker_name_spec, "collect2"))
 	{
-	  char *s = find_a_file (&exec_prefixes, "collect2", X_OK, 0);
+	  char *s = find_a_file (&exec_prefixes, "collect2", X_OK, false);
 	  if (s == NULL)
 	    linker_name_spec = "ld";
 	}
       /* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables
 	 for collect.  */
-      putenv_from_prefixes (&exec_prefixes, "COMPILER_PATH");
-      putenv_from_prefixes (&startfile_prefixes, LIBRARY_PATH_ENV);
+      putenv_from_prefixes (&exec_prefixes, "COMPILER_PATH", false);
+      putenv_from_prefixes (&startfile_prefixes, LIBRARY_PATH_ENV, true);
 
       value = do_spec (link_command_spec);
       if (value < 0)
diff --git a/gcc/po/ca.po b/gcc/po/ca.po
index 3eefccf..bd078a5 100644
--- a/gcc/po/ca.po
+++ b/gcc/po/ca.po
@@ -31162,7 +31162,7 @@ msgstr "s'ignora l'atribut \"%s\""
 #~ msgstr "passant el valor negatiu `%E' per a %s %P de \"%D\""
 
 #~ msgid "%s of negative value `%E' to `%T'"
-#~ msgstr "%s de valor negatiu `%I' a \"%T\""
+#~ msgstr "%s de valor negatiu `%E' a \"%T\""
 
 #~ msgid "initializing array with parameter list"
 #~ msgstr "inicialitzant una matriu amb una llista de parmetres"
diff --git a/gcc/pretty-print.h b/gcc/pretty-print.h
index b2c6772..0bdfa23 100644
--- a/gcc/pretty-print.h
+++ b/gcc/pretty-print.h
@@ -301,7 +301,7 @@ extern void pp_base_append_text (pretty_printer *, const char *, const char *);
 
 /* This header may be included before toplev.h, hence the duplicate
    definitions to allow for GCC-specific formats.  */
-#if GCC_VERSION >= 3005
+#if (GCC_VERSION >= 3005) && (__GNUC__ != 9) /* gcc-9 is buggy: https://gcc.gnu.org/PR90677  */
 #define ATTRIBUTE_GCC_PPDIAG(m, n) __attribute__ ((__format__ (__gcc_diag__, m ,n))) ATTRIBUTE_NONNULL(m)
 #else
 #define ATTRIBUTE_GCC_PPDIAG(m, n) ATTRIBUTE_NONNULL(m)
diff --git a/gcc/system.h b/gcc/system.h
index 34c9009..10290e6 100644
--- a/gcc/system.h
+++ b/gcc/system.h
@@ -227,6 +227,10 @@ extern int errno;
 # endif
 #endif
 
+#ifndef ICE_EXIT_CODE
+# define ICE_EXIT_CODE 27
+#endif
+
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
diff --git a/gcc/toplev.c b/gcc/toplev.c
index 77e5d29..d5ea855 100644
--- a/gcc/toplev.c
+++ b/gcc/toplev.c
@@ -517,6 +517,12 @@ read_integral_parameter (const char *p, const char *pname, const int  defval)
   return atoi (p);
 }
 
+#if GCC_VERSION < 3004
+
+/* The functions floor_log2 and exact_log2 are defined as inline
+   functions in toplev.h if GCC_VERSION >= 3004.  The definitions here
+   are used for older versions of gcc.  */
+
 /* Given X, an unsigned number, return the largest int Y such that 2**Y <= X.
    If X is 0, return -1.  */
 
@@ -528,9 +534,6 @@ floor_log2 (unsigned HOST_WIDE_INT x)
   if (x == 0)
     return -1;
 
-#ifdef CLZ_HWI
-  t = HOST_BITS_PER_WIDE_INT - 1 - (int) CLZ_HWI (x);
-#else
   if (HOST_BITS_PER_WIDE_INT > 64)
     if (x >= (unsigned HOST_WIDE_INT) 1 << (t + 64))
       t += 64;
@@ -547,7 +550,6 @@ floor_log2 (unsigned HOST_WIDE_INT x)
     t += 2;
   if (x >= ((unsigned HOST_WIDE_INT) 1) << (t + 1))
     t += 1;
-#endif
 
   return t;
 }
@@ -560,13 +562,11 @@ exact_log2 (unsigned HOST_WIDE_INT x)
 {
   if (x != (x & -x))
     return -1;
-#ifdef CTZ_HWI
-  return x ? CTZ_HWI (x) : -1;
-#else
   return floor_log2 (x);
-#endif
 }
 
+#endif /* GCC_VERSION < 3004 */
+
 /* Handler for fatal signals, such as SIGSEGV.  These are transformed
    into ICE messages, which is much more user friendly.  In case the
    error printer crashes, reset the signal to prevent infinite recursion.  */
diff --git a/gcc/toplev.h b/gcc/toplev.h
index 35d53eb..5d99d9e 100644
--- a/gcc/toplev.h
+++ b/gcc/toplev.h
@@ -49,7 +49,7 @@ extern void _fatal_insn (const char *, rtx, const char *, int, const char *)
 /* None of these functions are suitable for ATTRIBUTE_PRINTF, because
    each language front end can extend them with its own set of format
    specifiers.  We must use custom format checks.  */
-#if GCC_VERSION >= 4001
+#if (GCC_VERSION >= 4001) && (__GNUC__ != 9) /* gcc-9 is buggy: https://gcc.gnu.org/PR90677  */
 #define ATTRIBUTE_GCC_DIAG(m, n) __attribute__ ((__format__ (GCC_DIAG_STYLE, m, n))) ATTRIBUTE_NONNULL(m)
 #else
 #define ATTRIBUTE_GCC_DIAG(m, n) ATTRIBUTE_NONNULL(m)
@@ -152,14 +152,17 @@ extern void decode_d_option		(const char *);
 /* Return true iff flags are set as if -ffast-math.  */
 extern bool fast_math_flags_set_p	(void);
 
+/* Inline versions of the above for speed.  */
+#if GCC_VERSION < 3004
+
 /* Return log2, or -1 if not exact.  */
 extern int exact_log2                  (unsigned HOST_WIDE_INT);
 
 /* Return floor of log2, with -1 for zero.  */
 extern int floor_log2                  (unsigned HOST_WIDE_INT);
 
-/* Inline versions of the above for speed.  */
-#if GCC_VERSION >= 3004
+#else /* GCC_VERSION >= 3004 */
+
 # if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG
 #  define CLZ_HWI __builtin_clzl
 #  define CTZ_HWI __builtin_ctzl
@@ -171,13 +174,13 @@ extern int floor_log2                  (unsigned HOST_WIDE_INT);
 #  define CTZ_HWI __builtin_ctz
 # endif
 
-extern inline int
+static inline int
 floor_log2 (unsigned HOST_WIDE_INT x)
 {
   return x ? HOST_BITS_PER_WIDE_INT - 1 - (int) CLZ_HWI (x) : -1;
 }
 
-extern inline int
+static inline int
 exact_log2 (unsigned HOST_WIDE_INT x)
 {
   return x == (x & -x) && x ? (int) CTZ_HWI (x) : -1;
diff --git a/gcc/unwind-dw2.c b/gcc/unwind-dw2.c
index 930f02f..1ebc50f 100644
--- a/gcc/unwind-dw2.c
+++ b/gcc/unwind-dw2.c
@@ -252,9 +252,11 @@ _Unwind_GetTextRelBase (struct _Unwind_Context *context)
 }
 #endif
 
+#ifndef inhibit_libc
 #ifdef MD_UNWIND_SUPPORT
 #include MD_UNWIND_SUPPORT
 #endif
+#endif
 
 /* Extract any interesting information from the CIE for the translation
    unit F belongs to.  Return a pointer to the byte after the augmentation,
diff --git a/libffi/src/alpha/osf.S b/libffi/src/alpha/osf.S
index 2f03d62..36052b3 100644
--- a/libffi/src/alpha/osf.S
+++ b/libffi/src/alpha/osf.S
@@ -356,4 +356,8 @@ $LASFDE3:
 	.byte	16		# uleb128 offset 16*-8
 	.align 3
 $LEFDE3:
+
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
 #endif
diff --git a/libffi/src/arm/sysv.S b/libffi/src/arm/sysv.S
index c3471a8..c79d2aa 100644
--- a/libffi/src/arm/sysv.S
+++ b/libffi/src/arm/sysv.S
@@ -207,3 +207,6 @@ LSYM(Lepilogue):
 .ffi_call_SYSV_end:
         .size    CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)
 
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",%progbits
+#endif
diff --git a/libffi/src/ia64/unix.S b/libffi/src/ia64/unix.S
index 45dabb7..45d0c5d 100644
--- a/libffi/src/ia64/unix.S
+++ b/libffi/src/ia64/unix.S
@@ -553,3 +553,7 @@ ffi_closure_unix:
 	data8	@pcrel(.Lld_hfa_float)		// FFI_IA64_TYPE_HFA_FLOAT
 	data8	@pcrel(.Lld_hfa_double)		// FFI_IA64_TYPE_HFA_DOUBLE
 	data8	@pcrel(.Lld_hfa_ldouble)	// FFI_IA64_TYPE_HFA_LDOUBLE
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/m68k/sysv.S b/libffi/src/m68k/sysv.S
index d019a37..24bb081 100644
--- a/libffi/src/m68k/sysv.S
+++ b/libffi/src/m68k/sysv.S
@@ -95,3 +95,7 @@ epilogue:
 	unlk	%a6
 	rts
 	.size	ffi_call_SYSV,.-ffi_call_SYSV
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/linux64.S b/libffi/src/powerpc/linux64.S
index 25b2c4f..c93e893 100644
--- a/libffi/src/powerpc/linux64.S
+++ b/libffi/src/powerpc/linux64.S
@@ -178,3 +178,7 @@ ffi_call_LINUX64:
 	.align 3
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/linux64_closure.S b/libffi/src/powerpc/linux64_closure.S
index b19bc71..c45c8ef 100644
--- a/libffi/src/powerpc/linux64_closure.S
+++ b/libffi/src/powerpc/linux64_closure.S
@@ -204,3 +204,7 @@ ffi_closure_LINUX64:
 	.align 3
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/ppc_closure.S b/libffi/src/powerpc/ppc_closure.S
index 3703813..74ac088 100644
--- a/libffi/src/powerpc/ppc_closure.S
+++ b/libffi/src/powerpc/ppc_closure.S
@@ -321,3 +321,7 @@ END(ffi_closure_SYSV)
 .LEFDE1:
 
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/sysv.S b/libffi/src/powerpc/sysv.S
index 6d5a707..a669522 100644
--- a/libffi/src/powerpc/sysv.S
+++ b/libffi/src/powerpc/sysv.S
@@ -215,3 +215,7 @@ END(ffi_call_SYSV)
       .align 2
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/s390/sysv.S b/libffi/src/s390/sysv.S
index e9cbed9..09cdec1 100644
--- a/libffi/src/s390/sysv.S
+++ b/libffi/src/s390/sysv.S
@@ -427,3 +427,6 @@ ffi_closure_SYSV:
 
 #endif
 
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/sparc/v8.S b/libffi/src/sparc/v8.S
index 709423c..1d7bfa5 100644
--- a/libffi/src/sparc/v8.S
+++ b/libffi/src/sparc/v8.S
@@ -265,3 +265,7 @@ done2:
 	.byte	0x1f	! uleb128 0x1f
 	.align	WS
 .LLEFDE2:
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/sparc/v9.S b/libffi/src/sparc/v9.S
index d640e02..a8e8bf9 100644
--- a/libffi/src/sparc/v9.S
+++ b/libffi/src/sparc/v9.S
@@ -300,3 +300,7 @@ longdouble1:
 	.align 8
 .LLEFDE2:
 #endif
+
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/x86/sysv.S b/libffi/src/x86/sysv.S
index 46759f4..dc5f756 100644
--- a/libffi/src/x86/sysv.S
+++ b/libffi/src/x86/sysv.S
@@ -376,3 +376,7 @@ ffi_closure_raw_SYSV:
 #endif
 
 #endif /* ifndef __x86_64__ */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/x86/unix64.S b/libffi/src/x86/unix64.S
index 831e1d7..a338881 100644
--- a/libffi/src/x86/unix64.S
+++ b/libffi/src/x86/unix64.S
@@ -410,3 +410,7 @@ ffi_closure_unix64:
 .LEFDE3:
 
 #endif /* __x86_64__ */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libiberty/Makefile.in b/libiberty/Makefile.in
index aad0acc..5fdb9bf 100644
--- a/libiberty/Makefile.in
+++ b/libiberty/Makefile.in
@@ -232,6 +232,7 @@ $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS)
 	  $(AR) $(AR_FLAGS) $(TARGETLIB) \
 	    $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS); \
 	  $(RANLIB) $(TARGETLIB); \
+	  cp $(TARGETLIB) ../ ; \
 	  cd ..; \
 	else true; fi
 
diff --git a/libjava/classpath/configure b/libjava/classpath/configure
index 509a866..7bddc2e 100755
--- a/libjava/classpath/configure
+++ b/libjava/classpath/configure
@@ -4252,7 +4252,12 @@ if test "${with_native_libdir+set}" = set; then
 
 else
 
-	     nativelibdir='${libdir}/${PACKAGE}'
+multi_os_directory=`$CC -print-multi-os-directory`
+case $multi_os_directory in
+	.) toolexeclibdir=${libdir} ;; # Avoid trailing /.
+	*) toolexeclibdir=${libdir}/${multi_os_directory} ;;
+esac
+nativelibdir="${toolexeclibdir}/gcj-"`cat ${srcdir}/../../gcc/BASE-VER`
 
 fi;
 
diff --git a/libjava/configure b/libjava/configure
index 94013f0..623da27 100755
--- a/libjava/configure
+++ b/libjava/configure
@@ -10017,9 +10017,6 @@ echo "${ECHO_T}$ac_cv_func_backtrace" >&6
 if test $ac_cv_func_backtrace = yes; then
 
      case "$host" in
-       ia64-*-linux*)
-	 # Has broken backtrace()
-	 ;;
        mips*-*-linux*)
          # Has broken backtrace(), but we supply our own.
          if test -d sysdep; then true; else mkdir -p sysdep; fi
diff --git a/libjava/configure.ac b/libjava/configure.ac
index b806c1c..be13a59 100644
--- a/libjava/configure.ac
+++ b/libjava/configure.ac
@@ -903,9 +903,6 @@ else
    AC_CHECK_HEADERS(execinfo.h unistd.h dlfcn.h) 
    AC_CHECK_FUNC(backtrace, [
      case "$host" in
-       ia64-*-linux*)
-	 # Has broken backtrace()
-	 ;;
        mips*-*-linux*)
          # Has broken backtrace(), but we supply our own.
          if test -d sysdep; then true; else mkdir -p sysdep; fi
diff --git a/libjava/configure.host b/libjava/configure.host
index 5dc3903..3716b44 100644
--- a/libjava/configure.host
+++ b/libjava/configure.host
@@ -187,6 +187,7 @@ case "${host}" in
   sh-linux* | sh[34]*-linux*)
   	can_unwind_signal=yes
 	libgcj_ld_symbolic='-Wl,-Bsymbolic'
+	slow_pthread_self=
 	if test x$slow_pthread_self = xyes \
 	   && test x$cross_compiling != xyes; then
 	  cat > conftest.c <<EOF
diff --git a/libjava/include/pa-signal.h b/libjava/include/pa-signal.h
index 0f7c054..997de17 100644
--- a/libjava/include/pa-signal.h
+++ b/libjava/include/pa-signal.h
@@ -24,7 +24,7 @@ static void _Jv_##_name (int _dummy, siginfo_t *_info, void *arg)
 #define MAKE_THROW_FRAME(_exception)				\
 do								\
 {								\
-  struct ucontext *uc = (struct ucontext *)arg;			\
+  ucontext_t *uc = (ucontext_t *)arg;				\
   struct sigcontext *sc = &uc->uc_mcontext;			\
   (void)_dummy;							\
   (void)_info;							\
diff --git a/libjava/include/x86_64-signal.h b/libjava/include/x86_64-signal.h
index 1e769f4..9fa4b05 100644
--- a/libjava/include/x86_64-signal.h
+++ b/libjava/include/x86_64-signal.h
@@ -40,7 +40,7 @@ do									     \
   /* Advance the program counter so that it is after the start of the	     \
      instruction:  the x86_64 exception handler expects			     \
      the PC to point to the instruction after a call. */		     \
-  struct ucontext *_uc = (struct ucontext *)_p;				     \
+  ucontext_t *_uc = (ucontext_t *)_p;					     \
   volatile struct sigcontext *_sc = (struct sigcontext *) &_uc->uc_mcontext; \
   _sc->rip += 2;							     \
 }									     \
diff --git a/libjava/libltdl/acinclude.m4 b/libjava/libltdl/acinclude.m4
index 47312e1..41db02c 100644
--- a/libjava/libltdl/acinclude.m4
+++ b/libjava/libltdl/acinclude.m4
@@ -1434,6 +1434,24 @@ linux*)
   # people can always --disable-shared, the test was removed, and we
   # assume the GNU/Linux dynamic linker is in use.
   dynamic_linker='GNU/Linux ld.so'
+
+  # Find out which ABI we are using.
+  case "$host_cpu" in
+  x86_64*|s390*|sparc*|ppc*|powerpc*)
+    AC_LANG_PUSH(C)
+    lt_linux_biarch_save_CC="$CC"
+    CC="${LTCC-$CC}"
+    echo 'int i;' > conftest.$ac_ext
+    if AC_TRY_EVAL(ac_compile); then
+      case "`/usr/bin/file conftest.o`" in
+      *64-bit*) sys_lib_dlsearch_path_spec="/lib64 /usr/lib64";;
+      esac
+    fi
+    rm -rf conftest*
+    CC="$lt_linux_biarch_save_CC"
+    AC_LANG_POP
+    ;;
+  esac
   ;;
 
 netbsd*)
diff --git a/libjava/libltdl/configure b/libjava/libltdl/configure
index e0d830d..0116569 100755
--- a/libjava/libltdl/configure
+++ b/libjava/libltdl/configure
@@ -8421,6 +8421,38 @@ linux*)
   # people can always --disable-shared, the test was removed, and we
   # assume the GNU/Linux dynamic linker is in use.
   dynamic_linker='GNU/Linux ld.so'
+
+  # Find out which ABI we are using.
+  case "$host_cpu" in
+  x86_64*|s390*|sparc*|ppc*|powerpc*)
+    ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+    lt_linux_biarch_save_CC="$CC"
+    CC="${LTCC-$CC}"
+    echo 'int i;' > conftest.$ac_ext
+    if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+      case "`/usr/bin/file conftest.o`" in
+      *64-bit*) sys_lib_dlsearch_path_spec="/lib64 /usr/lib64";;
+      esac
+    fi
+    rm -rf conftest*
+    CC="$lt_linux_biarch_save_CC"
+    ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+    ;;
+  esac
   ;;
 
 netbsd*)
@@ -12071,6 +12103,38 @@ linux*)
   # people can always --disable-shared, the test was removed, and we
   # assume the GNU/Linux dynamic linker is in use.
   dynamic_linker='GNU/Linux ld.so'
+
+  # Find out which ABI we are using.
+  case "$host_cpu" in
+  x86_64*|s390*|sparc*|ppc*|powerpc*)
+    ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+    lt_linux_biarch_save_CC="$CC"
+    CC="${LTCC-$CC}"
+    echo 'int i;' > conftest.$ac_ext
+    if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+      case "`/usr/bin/file conftest.o`" in
+      *64-bit*) sys_lib_dlsearch_path_spec="/lib64 /usr/lib64";;
+      esac
+    fi
+    rm -rf conftest*
+    CC="$lt_linux_biarch_save_CC"
+    ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+    ;;
+  esac
   ;;
 
 netbsd*)
@@ -15156,6 +15220,37 @@ linux*)
   # people can always --disable-shared, the test was removed, and we
   # assume the GNU/Linux dynamic linker is in use.
   dynamic_linker='GNU/Linux ld.so'
+
+  # Find out which ABI we are using.
+  case "$host_cpu" in
+  x86_64*|s390*|sparc*|ppc*|powerpc*)
+    ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+    lt_linux_biarch_save_CC="$CC"
+    CC="${LTCC-$CC}"
+    echo 'int i;' > conftest.$ac_ext
+    if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+      case "`/usr/bin/file conftest.o`" in
+      *64-bit*) sys_lib_dlsearch_path_spec="/lib64 /usr/lib64";;
+      esac
+    fi
+    rm -rf conftest*
+    CC="$lt_linux_biarch_save_CC"
+    ac_ext=f
+ac_compile='$F77 -c $FFLAGS conftest.$ac_ext >&5'
+ac_link='$F77 -o conftest$ac_exeext $FFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_f77_compiler_gnu
+
+    ;;
+  esac
   ;;
 
 netbsd*)
@@ -17441,6 +17536,38 @@ linux*)
   # people can always --disable-shared, the test was removed, and we
   # assume the GNU/Linux dynamic linker is in use.
   dynamic_linker='GNU/Linux ld.so'
+
+  # Find out which ABI we are using.
+  case "$host_cpu" in
+  x86_64*|s390*|sparc*|ppc*|powerpc*)
+    ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+    lt_linux_biarch_save_CC="$CC"
+    CC="${LTCC-$CC}"
+    echo 'int i;' > conftest.$ac_ext
+    if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; then
+      case "`/usr/bin/file conftest.o`" in
+      *64-bit*) sys_lib_dlsearch_path_spec="/lib64 /usr/lib64";;
+      esac
+    fi
+    rm -rf conftest*
+    CC="$lt_linux_biarch_save_CC"
+    ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+    ;;
+  esac
   ;;
 
 netbsd*)
diff --git a/libjava/prims.cc b/libjava/prims.cc
index 04fdbc6..4faf9e7 100644
--- a/libjava/prims.cc
+++ b/libjava/prims.cc
@@ -33,7 +33,6 @@ details.  */
 #endif
 
 #ifndef DISABLE_GETENV_PROPERTIES
-#include <ctype.h>
 #include <java-props.h>
 #define PROCESS_GCJ_PROPERTIES process_gcj_properties()
 #else
@@ -805,6 +804,8 @@ static java::lang::Thread *main_thread;
 
 #ifndef DISABLE_GETENV_PROPERTIES
 
+#define c_isspace(c) (memchr (" \t\n\r\v\f", c, 6) != NULL)
+
 static char *
 next_property_key (char *s, size_t *length)
 {
@@ -813,7 +814,7 @@ next_property_key (char *s, size_t *length)
   JvAssert (s);
 
   // Skip over whitespace
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   // If we've reached the end, return NULL.  Also return NULL if for
@@ -825,7 +826,7 @@ next_property_key (char *s, size_t *length)
 
   // Determine the length of the property key.
   while (s[l] != 0
-	 && ! isspace (s[l])
+	 && ! c_isspace (s[l])
 	 && s[l] != ':'
 	 && s[l] != '=')
     {
@@ -847,19 +848,19 @@ next_property_value (char *s, size_t *length)
 
   JvAssert (s);
 
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   if (*s == ':'
       || *s == '=')
     s++;
 
-  while (isspace (*s))
+  while (c_isspace (*s))
     s++;
 
   // Determine the length of the property value.
   while (s[l] != 0
-	 && ! isspace (s[l])
+	 && ! c_isspace (s[l])
 	 && s[l] != ':'
 	 && s[l] != '=')
     {
diff --git a/libobjc/Makefile.in b/libobjc/Makefile.in
index 6704be1..aec11f7 100644
--- a/libobjc/Makefile.in
+++ b/libobjc/Makefile.in
@@ -1,6 +1,6 @@
 # Makefile for GNU Objective C runtime library.
-# Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004
-# Free Software Foundation, Inc.
+# Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004,
+# 2005, 2006 Free Software Foundation, Inc.
 
 #This file is part of GCC.
 
@@ -91,14 +91,17 @@ LIBTOOL_INSTALL = $(LIBTOOL) --mode=install
 LIBTOOL_CLEAN   = $(LIBTOOL) --mode=clean
 #LIBTOOL_UNINSTALL = $(LIBTOOL) --mode=uninstall
 
+OBJC_GCFLAGS=-DOBJC_WITH_GC=1
+OBJC_THREAD_FILE=thr-objc
+OBJC_BOEHM_GC=@OBJC_BOEHM_GC@
+OBJC_BOEHM_GC_INCLUDES=@OBJC_BOEHM_GC_INCLUDES@
+
 INCLUDES = -I$(srcdir)/objc  -I$(srcdir)/$(MULTISRCTOP)../gcc \
   -I$(srcdir)/$(MULTISRCTOP)../gcc/config \
   -I$(MULTIBUILDTOP)../../$(host_subdir)/gcc \
-  -I$(srcdir)/$(MULTISRCTOP)../include
+  -I$(srcdir)/$(MULTISRCTOP)../include \
+  $(OBJC_BOEHM_GC_INCLUDES)
 
-OBJC_GCFLAGS=-DOBJC_WITH_GC=1
-OBJC_THREAD_FILE=thr-objc
-OBJC_BOEHM_GC=@OBJC_BOEHM_GC@
 
 .SUFFIXES:
 .SUFFIXES: .c .m .lo
diff --git a/libobjc/configure b/libobjc/configure
index f28e0c4..ca1bfe9 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -309,7 +309,7 @@ ac_includes_default="\
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os build_subdir host_subdir target_subdir VERSION OBJC_BOEHM_GC toplevel_srcdir host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical glibcpp_srcdir toolexecdir toolexeclibdir includedirname libext CC ac_ct_CC EXEEXT OBJEXT extra_ldflags_libobjc CFLAGS AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LN_S STRIP ac_ct_STRIP LIBTOOL SET_MAKE CPP CPPFLAGS EGREP LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os build_subdir host_subdir target_subdir VERSION OBJC_BOEHM_GC OBJC_BOEHM_GC_INCLUDES toplevel_srcdir host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical glibcpp_srcdir toolexecdir toolexeclibdir includedirname libext CC ac_ct_CC EXEEXT OBJEXT extra_ldflags_libobjc CFLAGS AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LN_S STRIP ac_ct_STRIP LIBTOOL SET_MAKE CPP CPPFLAGS EGREP LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -1467,14 +1467,21 @@ echo "${ECHO_T}$version_specific_libs" >&6
 if test "${enable_objc_gc+set}" = set; then
   enableval="$enable_objc_gc"
   case $enable_objc_gc in
-  no) OBJC_BOEHM_GC='' ;;
-  *) OBJC_BOEHM_GC=libobjc_gc.la ;;
+  no)
+    OBJC_BOEHM_GC=''
+    OBJC_BOEHM_GC_INCLUDES=''
+    ;;
+  *)
+    OBJC_BOEHM_GC=libobjc_gc.la
+    OBJC_BOEHM_GC_INCLUDES='-I$(top_srcdir)/../boehm-gc/include -I../boehm-gc/include'
+    ;;
 esac
 else
-  OBJC_BOEHM_GC=''
+  OBJC_BOEHM_GC=''; OBJC_BOEHM_GC_INCLUDES=''
 fi;
 
 
+
 # -----------
 # Directories
 # -----------
@@ -5906,6 +5913,7 @@ s,@host_subdir@,$host_subdir,;t t
 s,@target_subdir@,$target_subdir,;t t
 s,@VERSION@,$VERSION,;t t
 s,@OBJC_BOEHM_GC@,$OBJC_BOEHM_GC,;t t
+s,@OBJC_BOEHM_GC_INCLUDES@,$OBJC_BOEHM_GC_INCLUDES,;t t
 s,@toplevel_srcdir@,$toplevel_srcdir,;t t
 s,@host@,$host,;t t
 s,@host_cpu@,$host_cpu,;t t
diff --git a/libobjc/configure.ac b/libobjc/configure.ac
index caf2f8d..86d9726 100644
--- a/libobjc/configure.ac
+++ b/libobjc/configure.ac
@@ -73,11 +73,18 @@ AC_ARG_ENABLE(objc-gc,
 [  --enable-objc-gc       enable the use of Boehm's garbage collector with
                           the GNU Objective-C runtime.],
 [case $enable_objc_gc in
-  no) OBJC_BOEHM_GC='' ;;
-  *) OBJC_BOEHM_GC=libobjc_gc.la ;;
+  no)
+    OBJC_BOEHM_GC=''
+    OBJC_BOEHM_GC_INCLUDES=''
+    ;;
+  *)
+    OBJC_BOEHM_GC=libobjc_gc.la
+    OBJC_BOEHM_GC_INCLUDES='-I$(top_srcdir)/../boehm-gc/include -I../boehm-gc/include'
+    ;;
 esac],
-[OBJC_BOEHM_GC=''])
+[OBJC_BOEHM_GC=''; OBJC_BOEHM_GC_INCLUDES=''])
 AC_SUBST(OBJC_BOEHM_GC)
+AC_SUBST(OBJC_BOEHM_GC_INCLUDES)
 
 # -----------
 # Directories
diff --git a/libstdc++-v3/include/c_std/std_cassert.h b/libstdc++-v3/include/c_std/std_cassert.h
index ae2f498..7b5fea7 100644
--- a/libstdc++-v3/include/c_std/std_cassert.h
+++ b/libstdc++-v3/include/c_std/std_cassert.h
@@ -45,5 +45,8 @@
 // No include guards on this header...
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <assert.h>
+
+#pragma GCC visibility pop
diff --git a/libstdc++-v3/include/c_std/std_cctype.h b/libstdc++-v3/include/c_std/std_cctype.h
index 008f706..335f63e 100644
--- a/libstdc++-v3/include/c_std/std_cctype.h
+++ b/libstdc++-v3/include/c_std/std_cctype.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CCTYPE 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <ctype.h>
@@ -82,4 +83,6 @@ namespace std
   using ::toupper;
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_cerrno.h b/libstdc++-v3/include/c_std/std_cerrno.h
index 5d4b9d7..77c3dd0 100644
--- a/libstdc++-v3/include/c_std/std_cerrno.h
+++ b/libstdc++-v3/include/c_std/std_cerrno.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CERRNO 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <errno.h>
 
@@ -54,4 +55,6 @@
 #define errno errno
 #endif
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_cfloat.h b/libstdc++-v3/include/c_std/std_cfloat.h
index e28b649..fc09d43 100644
--- a/libstdc++-v3/include/c_std/std_cfloat.h
+++ b/libstdc++-v3/include/c_std/std_cfloat.h
@@ -46,7 +46,10 @@
 #define _GLIBCXX_CFLOAT 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <float.h>
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_climits.h b/libstdc++-v3/include/c_std/std_climits.h
index ddd53a3..926455c 100644
--- a/libstdc++-v3/include/c_std/std_climits.h
+++ b/libstdc++-v3/include/c_std/std_climits.h
@@ -46,7 +46,9 @@
 #define _GLIBCXX_CLIMITS 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <limits.h>
 
+#pragma GCC visibility pop
 #endif
diff --git a/libstdc++-v3/include/c_std/std_clocale.h b/libstdc++-v3/include/c_std/std_clocale.h
index 9a3e516..87cc6f9 100644
--- a/libstdc++-v3/include/c_std/std_clocale.h
+++ b/libstdc++-v3/include/c_std/std_clocale.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CLOCALE 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <locale.h>
 
@@ -60,4 +61,6 @@ namespace std
   using ::localeconv;
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_cmath.h b/libstdc++-v3/include/c_std/std_cmath.h
index 115fe47..7114026 100644
--- a/libstdc++-v3/include/c_std/std_cmath.h
+++ b/libstdc++-v3/include/c_std/std_cmath.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CMATH 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <bits/cpp_type_traits.h>
@@ -575,4 +576,6 @@ namespace std
 # include <bits/cmath.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_csetjmp.h b/libstdc++-v3/include/c_std/std_csetjmp.h
index 290f2e9..7caf67c 100644
--- a/libstdc++-v3/include/c_std/std_csetjmp.h
+++ b/libstdc++-v3/include/c_std/std_csetjmp.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CSETJMP 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <setjmp.h>
 
@@ -63,4 +64,6 @@ namespace std
   using ::longjmp;
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_csignal.h b/libstdc++-v3/include/c_std/std_csignal.h
index 0db1c11..786616a 100644
--- a/libstdc++-v3/include/c_std/std_csignal.h
+++ b/libstdc++-v3/include/c_std/std_csignal.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CSIGNAL 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <signal.h>
 
@@ -59,4 +60,6 @@ namespace std
   using ::raise;
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_cstdarg.h b/libstdc++-v3/include/c_std/std_cstdarg.h
index c98b5db..cc89e06 100644
--- a/libstdc++-v3/include/c_std/std_cstdarg.h
+++ b/libstdc++-v3/include/c_std/std_cstdarg.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CSTDARG 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <stdarg.h>
 
@@ -59,4 +60,6 @@ namespace std
   using ::va_list;
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_cstddef.h b/libstdc++-v3/include/c_std/std_cstddef.h
index f1860a7..ff88899 100644
--- a/libstdc++-v3/include/c_std/std_cstddef.h
+++ b/libstdc++-v3/include/c_std/std_cstddef.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CSTDDEF 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <stddef.h>
 
@@ -55,4 +56,6 @@ namespace std
   using ::size_t;
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_cstdio.h b/libstdc++-v3/include/c_std/std_cstdio.h
index 9f5f7dd..89fc103 100644
--- a/libstdc++-v3/include/c_std/std_cstdio.h
+++ b/libstdc++-v3/include/c_std/std_cstdio.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CSTDIO 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <cstddef>
@@ -184,4 +185,6 @@ namespace std
 }
 #endif
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_cstdlib.h b/libstdc++-v3/include/c_std/std_cstdlib.h
index 2139092..444af79 100644
--- a/libstdc++-v3/include/c_std/std_cstdlib.h
+++ b/libstdc++-v3/include/c_std/std_cstdlib.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CSTDLIB 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <cstddef>
@@ -220,4 +221,6 @@ namespace std
 
 #endif // !_GLIBCXX_HOSTED
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_cstring.h b/libstdc++-v3/include/c_std/std_cstring.h
index 7efbf8f..83a7af3 100644
--- a/libstdc++-v3/include/c_std/std_cstring.h
+++ b/libstdc++-v3/include/c_std/std_cstring.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CSTRING 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <cstddef>
 
@@ -126,4 +127,6 @@ namespace std
   { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_ctime.h b/libstdc++-v3/include/c_std/std_ctime.h
index ef3307e..7cd9706 100644
--- a/libstdc++-v3/include/c_std/std_ctime.h
+++ b/libstdc++-v3/include/c_std/std_ctime.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CTIME 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <cstddef>
 
@@ -79,4 +80,6 @@ namespace std
   using ::strftime;
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_cwchar.h b/libstdc++-v3/include/c_std/std_cwchar.h
index 5e3ab90..2683a06 100644
--- a/libstdc++-v3/include/c_std/std_cwchar.h
+++ b/libstdc++-v3/include/c_std/std_cwchar.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CWCHAR 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <cstddef>
@@ -271,4 +272,6 @@ namespace std
 
 #endif //_GLIBCXX_USE_WCHAR_T
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/c_std/std_cwctype.h b/libstdc++-v3/include/c_std/std_cwctype.h
index 9f297c4..2daccd9 100644
--- a/libstdc++-v3/include/c_std/std_cwctype.h
+++ b/libstdc++-v3/include/c_std/std_cwctype.h
@@ -46,6 +46,7 @@
 #define _GLIBCXX_CWCTYPE 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 
@@ -106,4 +107,6 @@ namespace std
 }
 #endif //_GLIBCXX_USE_WCHAR_T
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/debug/bitset b/libstdc++-v3/include/debug/bitset
index 2bdca18..183e313 100644
--- a/libstdc++-v3/include/debug/bitset
+++ b/libstdc++-v3/include/debug/bitset
@@ -31,6 +31,8 @@
 #ifndef _GLIBCXX_DEBUG_BITSET
 #define _GLIBCXX_DEBUG_BITSET
 
+#pragma GCC visibility push(default)
+
 #include <bitset>
 #include <debug/safe_sequence.h>
 #include <debug/safe_iterator.h>
@@ -318,4 +320,6 @@ namespace __gnu_debug_def
     { return __os << __x._M_base(); }
 } // namespace __gnu_debug_def
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/debug/deque b/libstdc++-v3/include/debug/deque
index a69ce62..3f2d33f 100644
--- a/libstdc++-v3/include/debug/deque
+++ b/libstdc++-v3/include/debug/deque
@@ -31,6 +31,8 @@
 #ifndef _GLIBCXX_DEBUG_DEQUE
 #define _GLIBCXX_DEBUG_DEQUE 1
 
+#pragma GCC visibility push(default)
+
 #include <deque>
 #include <debug/safe_sequence.h>
 #include <debug/safe_iterator.h>
@@ -383,4 +385,6 @@ namespace __gnu_debug_def
     { __lhs.swap(__rhs); }
 } // namespace __gnu_debug_def
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/debug/hash_map b/libstdc++-v3/include/debug/hash_map
index fe2af59..4ef3635 100644
--- a/libstdc++-v3/include/debug/hash_map
+++ b/libstdc++-v3/include/debug/hash_map
@@ -31,8 +31,12 @@
 #ifndef _GLIBCXX_DEBUG_HASH_MAP
 #define _GLIBCXX_DEBUG_HASH_MAP 1
 
+#pragma GCC visibility push(default)
+
 #include <ext/hash_map>
 #include <debug/hash_map.h>
 #include <debug/hash_multimap.h>
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/debug/hash_set b/libstdc++-v3/include/debug/hash_set
index fad5bdd..94cb19e 100644
--- a/libstdc++-v3/include/debug/hash_set
+++ b/libstdc++-v3/include/debug/hash_set
@@ -31,8 +31,12 @@
 #ifndef _GLIBCXX_DEBUG_HASH_SET
 #define _GLIBCXX_DEBUG_HASH_SET 1
 
+#pragma GCC visibility push(default)
+
 #include <ext/hash_set>
 #include <debug/hash_set.h>
 #include <debug/hash_multiset.h>
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/debug/list b/libstdc++-v3/include/debug/list
index 2e6d0fa..bdfe99d 100644
--- a/libstdc++-v3/include/debug/list
+++ b/libstdc++-v3/include/debug/list
@@ -31,6 +31,8 @@
 #ifndef _GLIBCXX_DEBUG_LIST
 #define _GLIBCXX_DEBUG_LIST 1
 
+#pragma GCC visibility push(default)
+
 #include <list>
 #include <bits/stl_algo.h>
 #include <debug/safe_sequence.h>
@@ -502,4 +504,6 @@ namespace __gnu_debug_def
     { __lhs.swap(__rhs); }
 } // namespace __gnu_debug_def
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/debug/map b/libstdc++-v3/include/debug/map
index ae74e7e..b43a76f 100644
--- a/libstdc++-v3/include/debug/map
+++ b/libstdc++-v3/include/debug/map
@@ -1,6 +1,6 @@
 // Debugging map/multimap implementation -*- C++ -*-
 
-// Copyright (C) 2003
+// Copyright (C) 2003, 2005
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -31,8 +31,12 @@
 #ifndef _GLIBCXX_DEBUG_MAP
 #define _GLIBCXX_DEBUG_MAP 1
 
+#pragma GCC visibility push(default)
+
 #include <map>
 #include <debug/map.h>
 #include <debug/multimap.h>
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/debug/set b/libstdc++-v3/include/debug/set
index 002b324..ac06477 100644
--- a/libstdc++-v3/include/debug/set
+++ b/libstdc++-v3/include/debug/set
@@ -1,6 +1,6 @@
 // Debugging set/multiset implementation -*- C++ -*-
 
-// Copyright (C) 2003
+// Copyright (C) 2003, 2005
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -31,8 +31,12 @@
 #ifndef _GLIBCXX_DEBUG_SET
 #define _GLIBCXX_DEBUG_SET 1
 
+#pragma GCC visibility push(default)
+
 #include <set>
 #include <debug/set.h>
 #include <debug/multiset.h>
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/debug/string b/libstdc++-v3/include/debug/string
index 18f90d0..28f5792 100644
--- a/libstdc++-v3/include/debug/string
+++ b/libstdc++-v3/include/debug/string
@@ -31,6 +31,8 @@
 #ifndef _GLIBCXX_DEBUG_STRING
 #define _GLIBCXX_DEBUG_STRING 1
 
+#pragma GCC visibility push(default)
+
 #include <string>
 #include <debug/safe_sequence.h>
 #include <debug/safe_iterator.h>
@@ -1015,4 +1017,6 @@ template<typename _CharT, typename _Traits = std::char_traits<_CharT>,
 
 } // namespace __gnu_debug
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/debug/vector b/libstdc++-v3/include/debug/vector
index f2b3618..9eea546 100644
--- a/libstdc++-v3/include/debug/vector
+++ b/libstdc++-v3/include/debug/vector
@@ -31,6 +31,8 @@
 #ifndef _GLIBCXX_DEBUG_VECTOR
 #define _GLIBCXX_DEBUG_VECTOR 1
 
+#pragma GCC visibility push(default)
+
 #include <vector>
 #include <utility>
 #include <debug/safe_sequence.h>
@@ -413,4 +415,6 @@ namespace __gnu_debug_def
     { __lhs.swap(__rhs); }
 } // namespace __gnu_debug_def
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/algorithm b/libstdc++-v3/include/ext/algorithm
index 4402620..7bf1038 100644
--- a/libstdc++-v3/include/ext/algorithm
+++ b/libstdc++-v3/include/ext/algorithm
@@ -1,6 +1,6 @@
 // Algorithm extensions -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -62,6 +62,7 @@
 #define _EXT_ALGORITHM 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <algorithm>
 
@@ -523,4 +524,6 @@ namespace __gnu_cxx
     }
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif /* _EXT_ALGORITHM */
diff --git a/libstdc++-v3/include/ext/array_allocator.h b/libstdc++-v3/include/ext/array_allocator.h
index 9553648..1bb1be3 100644
--- a/libstdc++-v3/include/ext/array_allocator.h
+++ b/libstdc++-v3/include/ext/array_allocator.h
@@ -34,6 +34,8 @@
 #ifndef _ARRAY_ALLOCATOR_H
 #define _ARRAY_ALLOCATOR_H 1
 
+#pragma GCC visibility push(default)
+
 #include <cstddef>
 #include <new>
 #include <bits/functexcept.h>
@@ -142,4 +144,6 @@ namespace __gnu_cxx
     { return false; }
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/bitmap_allocator.h b/libstdc++-v3/include/ext/bitmap_allocator.h
index 7860b6d..8669042 100644
--- a/libstdc++-v3/include/ext/bitmap_allocator.h
+++ b/libstdc++-v3/include/ext/bitmap_allocator.h
@@ -34,6 +34,8 @@
 #ifndef _BITMAP_ALLOCATOR_H
 #define _BITMAP_ALLOCATOR_H 1
 
+#pragma GCC visibility push(default)
+
 // For std::size_t, and ptrdiff_t.
 #include <cstddef>
 
@@ -1289,6 +1291,8 @@ namespace __gnu_cxx
 
 }
 
+#pragma GCC visibility pop
+
 #endif 
 
 //  LocalWords:  namespace GTHREADS bool const gthread endif Mutex mutex
diff --git a/libstdc++-v3/include/ext/debug_allocator.h b/libstdc++-v3/include/ext/debug_allocator.h
index a0187a0..c09f2f0 100644
--- a/libstdc++-v3/include/ext/debug_allocator.h
+++ b/libstdc++-v3/include/ext/debug_allocator.h
@@ -48,6 +48,8 @@
 #ifndef _DEBUG_ALLOCATOR_H
 #define _DEBUG_ALLOCATOR_H 1
 
+#pragma GCC visibility push(default)
+
 #include <stdexcept>
 
 namespace __gnu_cxx
@@ -122,4 +124,6 @@ namespace __gnu_cxx
     };
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/functional b/libstdc++-v3/include/ext/functional
index 18132c3..cd4beb1 100644
--- a/libstdc++-v3/include/ext/functional
+++ b/libstdc++-v3/include/ext/functional
@@ -1,6 +1,6 @@
 // Functional extensions -*- C++ -*-
 
-// Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2002, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -62,6 +62,7 @@
 #define _EXT_FUNCTIONAL 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <functional>
 
@@ -421,5 +422,8 @@ namespace __gnu_cxx
     mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)
     { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
 } // namespace __gnu_cxx
+
+#pragma GCC visibility pop
+
 #endif
 
diff --git a/libstdc++-v3/include/ext/hash_map b/libstdc++-v3/include/ext/hash_map
index 3340cc3..5d5d8a6 100644
--- a/libstdc++-v3/include/ext/hash_map
+++ b/libstdc++-v3/include/ext/hash_map
@@ -61,6 +61,8 @@
 #ifndef _HASH_MAP
 #define _HASH_MAP 1
 
+#pragma GCC visibility push(default)
+
 #include <ext/hashtable.h>
 #include <bits/concept_check.h>
 
@@ -622,4 +624,6 @@ namespace std
 # include <debug/hash_map>
 #endif
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/hash_set b/libstdc++-v3/include/ext/hash_set
index 1179e88..316ed27 100644
--- a/libstdc++-v3/include/ext/hash_set
+++ b/libstdc++-v3/include/ext/hash_set
@@ -61,6 +61,8 @@
 #ifndef _HASH_SET
 #define _HASH_SET 1
 
+#pragma GCC visibility push(default)
+
 #include <ext/hashtable.h>
 #include <bits/concept_check.h>
 
@@ -588,4 +590,6 @@ namespace std
 # include <debug/hash_set>
 #endif
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/iterator b/libstdc++-v3/include/ext/iterator
index e6334ad..e47a0fd 100644
--- a/libstdc++-v3/include/ext/iterator
+++ b/libstdc++-v3/include/ext/iterator
@@ -1,6 +1,6 @@
 // HP/SGI iterator extensions -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -62,6 +62,7 @@
 #define _EXT_ITERATOR 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/concept_check.h>
 #include <iterator>
@@ -113,5 +114,7 @@ namespace __gnu_cxx
     }
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
 
diff --git a/libstdc++-v3/include/ext/malloc_allocator.h b/libstdc++-v3/include/ext/malloc_allocator.h
index 6d66c26..a5f62f2 100644
--- a/libstdc++-v3/include/ext/malloc_allocator.h
+++ b/libstdc++-v3/include/ext/malloc_allocator.h
@@ -1,6 +1,7 @@
 // Allocator that wraps "C" malloc -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2004, 2005
+// Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -34,6 +35,8 @@
 #ifndef _MALLOC_ALLOCATOR_H
 #define _MALLOC_ALLOCATOR_H 1
 
+#pragma GCC visibility push(default)
+
 #include <cstdlib>
 #include <new>
 #include <bits/functexcept.h>
@@ -122,4 +125,6 @@ namespace __gnu_cxx
     { return false; }
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/memory b/libstdc++-v3/include/ext/memory
index deb77f8..32f43ec 100644
--- a/libstdc++-v3/include/ext/memory
+++ b/libstdc++-v3/include/ext/memory
@@ -1,6 +1,6 @@
 // Memory extensions -*- C++ -*-
 
-// Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2002, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -62,6 +62,7 @@
 #define _EXT_MEMORY 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <memory>
 #include <bits/stl_tempbuf.h>
@@ -194,5 +195,7 @@ namespace __gnu_cxx
     };
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
 
diff --git a/libstdc++-v3/include/ext/mt_allocator.h b/libstdc++-v3/include/ext/mt_allocator.h
index 8ca2df7..ad30466 100644
--- a/libstdc++-v3/include/ext/mt_allocator.h
+++ b/libstdc++-v3/include/ext/mt_allocator.h
@@ -34,6 +34,8 @@
 #ifndef _MT_ALLOCATOR_H
 #define _MT_ALLOCATOR_H 1
 
+#pragma GCC visibility push(default)
+
 #include <new>
 #include <cstdlib>
 #include <bits/functexcept.h>
@@ -735,4 +737,6 @@ namespace __gnu_cxx
 #undef __thread_default
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/new_allocator.h b/libstdc++-v3/include/ext/new_allocator.h
index 40122c2..7146068 100644
--- a/libstdc++-v3/include/ext/new_allocator.h
+++ b/libstdc++-v3/include/ext/new_allocator.h
@@ -1,6 +1,6 @@
 // Allocator that wraps operator new -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -34,6 +34,8 @@
 #ifndef _NEW_ALLOCATOR_H
 #define _NEW_ALLOCATOR_H 1
 
+#pragma GCC visibility push(default)
+
 #include <new>
 #include <bits/functexcept.h>
 
@@ -118,4 +120,6 @@ namespace __gnu_cxx
     { return false; }
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/numeric b/libstdc++-v3/include/ext/numeric
index 0f112c2..8c0bc71 100644
--- a/libstdc++-v3/include/ext/numeric
+++ b/libstdc++-v3/include/ext/numeric
@@ -1,6 +1,6 @@
 // Numeric extensions -*- C++ -*-
 
-// Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2002, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -62,6 +62,7 @@
 #define _EXT_NUMERIC 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/concept_check.h>
 #include <numeric>
@@ -146,5 +147,7 @@ namespace __gnu_cxx
     }
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
 
diff --git a/libstdc++-v3/include/ext/pod_char_traits.h b/libstdc++-v3/include/ext/pod_char_traits.h
index 8b9a568..0667b2f 100644
--- a/libstdc++-v3/include/ext/pod_char_traits.h
+++ b/libstdc++-v3/include/ext/pod_char_traits.h
@@ -37,6 +37,8 @@
 #ifndef _POD_CHAR_TRAITS_H
 #define _POD_CHAR_TRAITS_H 1
 
+#pragma GCC visibility push(default)
+
 #include <string>
 
 namespace __gnu_cxx
@@ -182,4 +184,6 @@ namespace std
     };
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/pool_allocator.h b/libstdc++-v3/include/ext/pool_allocator.h
index d8bca1c..70e2912 100644
--- a/libstdc++-v3/include/ext/pool_allocator.h
+++ b/libstdc++-v3/include/ext/pool_allocator.h
@@ -1,6 +1,6 @@
 // Allocators -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -47,6 +47,8 @@
 #ifndef _POOL_ALLOCATOR_H
 #define _POOL_ALLOCATOR_H 1
 
+#pragma GCC visibility push(default)
+
 #include <bits/c++config.h>
 #include <cstdlib>
 #include <new>
@@ -252,4 +254,6 @@ namespace __gnu_cxx
     }
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/rb_tree b/libstdc++-v3/include/ext/rb_tree
index 31c8431..982b084 100644
--- a/libstdc++-v3/include/ext/rb_tree
+++ b/libstdc++-v3/include/ext/rb_tree
@@ -1,6 +1,6 @@
 // rb_tree extension -*- C++ -*-
 
-// Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -62,6 +62,7 @@
 #define _RB_TREE 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/stl_tree.h>
 
@@ -94,4 +95,6 @@ namespace __gnu_cxx
     };
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/rope b/libstdc++-v3/include/ext/rope
index e4ad50d..f4b505f 100644
--- a/libstdc++-v3/include/ext/rope
+++ b/libstdc++-v3/include/ext/rope
@@ -48,6 +48,8 @@
 #ifndef _ROPE
 #define _ROPE 1
 
+#pragma GCC visibility push(default)
+
 #include <bits/stl_algobase.h>
 #include <bits/stl_construct.h>
 #include <bits/stl_uninitialized.h>
@@ -2898,4 +2900,6 @@ protected:
 
 # include <ext/ropeimpl.h>
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/slist b/libstdc++-v3/include/ext/slist
index 49ce77e..51707e2 100644
--- a/libstdc++-v3/include/ext/slist
+++ b/libstdc++-v3/include/ext/slist
@@ -49,6 +49,8 @@
 #ifndef _SLIST
 #define _SLIST 1
 
+#pragma GCC visibility push(default)
+
 #include <bits/stl_algobase.h>
 #include <bits/allocator.h>
 #include <bits/stl_construct.h>
@@ -1076,4 +1078,7 @@ namespace std
 };
 
 } // namespace std
+
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/stdio_filebuf.h b/libstdc++-v3/include/ext/stdio_filebuf.h
index 5a6d22a..b46d951 100644
--- a/libstdc++-v3/include/ext/stdio_filebuf.h
+++ b/libstdc++-v3/include/ext/stdio_filebuf.h
@@ -1,6 +1,6 @@
 // File descriptor layer for filebuf -*- C++ -*-
 
-// Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -35,6 +35,7 @@
 #define _STDIO_FILEBUF_H 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <fstream>
 
@@ -158,4 +159,6 @@ namespace __gnu_cxx
     }
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/ext/stdio_sync_filebuf.h b/libstdc++-v3/include/ext/stdio_sync_filebuf.h
index c51c678..8b54703 100644
--- a/libstdc++-v3/include/ext/stdio_sync_filebuf.h
+++ b/libstdc++-v3/include/ext/stdio_sync_filebuf.h
@@ -1,6 +1,6 @@
 // Iostreams wrapper for stdio FILE* -*- C++ -*-
 
-// Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -35,6 +35,7 @@
 #define _STDIO_SYNC_FILEBUF_H 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <streambuf>
 #include <unistd.h>
@@ -279,4 +280,6 @@ namespace __gnu_cxx
 #endif
 } // namespace __gnu_cxx
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/std/std_algorithm.h b/libstdc++-v3/include/std/std_algorithm.h
index 3b27a8e..0c98401 100644
--- a/libstdc++-v3/include/std/std_algorithm.h
+++ b/libstdc++-v3/include/std/std_algorithm.h
@@ -1,6 +1,6 @@
 // <algorithm> -*- C++ -*-
 
-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,10 +61,13 @@
 #define _GLIBCXX_ALGORITHM 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/stl_algobase.h>
 #include <bits/stl_construct.h>
 #include <bits/stl_uninitialized.h>
 #include <bits/stl_algo.h>
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_ALGORITHM */
diff --git a/libstdc++-v3/include/std/std_bitset.h b/libstdc++-v3/include/std/std_bitset.h
index a32af6b..bd68d2d 100644
--- a/libstdc++-v3/include/std/std_bitset.h
+++ b/libstdc++-v3/include/std/std_bitset.h
@@ -48,6 +48,7 @@
 #define _GLIBCXX_BITSET 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <cstddef>     // For size_t
 #include <cstring>     // For memset
@@ -1300,4 +1301,6 @@ namespace _GLIBCXX_STD
 # include <debug/bitset>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_BITSET */
diff --git a/libstdc++-v3/include/std/std_complex.h b/libstdc++-v3/include/std/std_complex.h
index c7aab0e..52f23b2 100644
--- a/libstdc++-v3/include/std/std_complex.h
+++ b/libstdc++-v3/include/std/std_complex.h
@@ -43,6 +43,7 @@
 #define _GLIBCXX_COMPLEX 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <bits/cpp_type_traits.h>
@@ -1485,4 +1486,6 @@ namespace std
   : _M_value(__z.__rep()) { }
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif	/* _GLIBCXX_COMPLEX */
diff --git a/libstdc++-v3/include/std/std_deque.h b/libstdc++-v3/include/std/std_deque.h
index b82d45e..d24d294 100644
--- a/libstdc++-v3/include/std/std_deque.h
+++ b/libstdc++-v3/include/std/std_deque.h
@@ -1,6 +1,6 @@
 // <deque> -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,6 +61,7 @@
 #define _GLIBCXX_DEQUE 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/functexcept.h>
 #include <bits/stl_algobase.h>
@@ -77,4 +78,6 @@
 # include <debug/deque>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_DEQUE */
diff --git a/libstdc++-v3/include/std/std_fstream.h b/libstdc++-v3/include/std/std_fstream.h
index a93f9a4..3bf0680 100644
--- a/libstdc++-v3/include/std/std_fstream.h
+++ b/libstdc++-v3/include/std/std_fstream.h
@@ -40,6 +40,7 @@
 #define _GLIBCXX_FSTREAM 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <istream>
 #include <ostream>
@@ -782,4 +783,6 @@ namespace std
 # include <bits/fstream.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_FSTREAM */
diff --git a/libstdc++-v3/include/std/std_functional.h b/libstdc++-v3/include/std/std_functional.h
index 7afa31c..c0d6c65 100644
--- a/libstdc++-v3/include/std/std_functional.h
+++ b/libstdc++-v3/include/std/std_functional.h
@@ -1,6 +1,6 @@
 // <functional> -*- C++ -*-
 
-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -49,9 +49,12 @@
 #define _GLIBCXX_FUNCTIONAL 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <cstddef>
 #include <bits/stl_function.h>
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_FUNCTIONAL */
diff --git a/libstdc++-v3/include/std/std_iomanip.h b/libstdc++-v3/include/std/std_iomanip.h
index 6363df6..19fe723 100644
--- a/libstdc++-v3/include/std/std_iomanip.h
+++ b/libstdc++-v3/include/std/std_iomanip.h
@@ -1,6 +1,6 @@
 // Standard stream manipulators -*- C++ -*-
 
-// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003
+// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2005
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -40,6 +40,7 @@
 #define _GLIBCXX_IOMANIP 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <istream>
@@ -296,4 +297,6 @@ namespace std
 #endif
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_IOMANIP */
diff --git a/libstdc++-v3/include/std/std_ios.h b/libstdc++-v3/include/std/std_ios.h
index 756e514..456882a 100644
--- a/libstdc++-v3/include/std/std_ios.h
+++ b/libstdc++-v3/include/std/std_ios.h
@@ -1,6 +1,7 @@
 // Iostreams base classes -*- C++ -*-
 
-// Copyright (C) 1997, 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2005
+// Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -39,6 +40,7 @@
 #define _GLIBCXX_IOS 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <iosfwd>
 #include <exception> 		// For ios_base::failure
@@ -49,4 +51,6 @@
 #include <streambuf> 
 #include <bits/basic_ios.h>
 
+#pragma GCC visibility pop
+
 #endif	/* _GLIBCXX_IOS */
diff --git a/libstdc++-v3/include/std/std_iosfwd.h b/libstdc++-v3/include/std/std_iosfwd.h
index 5dfd641..db03c04 100644
--- a/libstdc++-v3/include/std/std_iosfwd.h
+++ b/libstdc++-v3/include/std/std_iosfwd.h
@@ -1,6 +1,6 @@
 // Forwarding declarations -*- C++ -*-
 
-// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003
+// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003, 2005
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -40,6 +40,7 @@
 #define _GLIBCXX_IOSFWD 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <bits/c++locale.h> 
@@ -164,4 +165,6 @@ namespace std
   /** @}  */
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_IOSFWD */
diff --git a/libstdc++-v3/include/std/std_iostream.h b/libstdc++-v3/include/std/std_iostream.h
index 33ed4cf..69e2790 100644
--- a/libstdc++-v3/include/std/std_iostream.h
+++ b/libstdc++-v3/include/std/std_iostream.h
@@ -1,6 +1,7 @@
 // Standard iostream objects -*- C++ -*-
 
-// Copyright (C) 1997, 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 1997, 1998, 1999, 2001, 2002, 2005
+// Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -39,6 +40,7 @@
 #define _GLIBCXX_IOSTREAM 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <ostream>
@@ -76,4 +78,6 @@ namespace std
   static ios_base::Init __ioinit;
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_IOSTREAM */
diff --git a/libstdc++-v3/include/std/std_istream.h b/libstdc++-v3/include/std/std_istream.h
index dd1189e..9c9b712 100644
--- a/libstdc++-v3/include/std/std_istream.h
+++ b/libstdc++-v3/include/std/std_istream.h
@@ -40,6 +40,7 @@
 #define _GLIBCXX_ISTREAM 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <ios>
 #include <limits> // For numeric_limits
@@ -819,4 +820,6 @@ namespace std
 # include <bits/istream.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif	/* _GLIBCXX_ISTREAM */
diff --git a/libstdc++-v3/include/std/std_iterator.h b/libstdc++-v3/include/std/std_iterator.h
index 00bc983..67f9b45 100644
--- a/libstdc++-v3/include/std/std_iterator.h
+++ b/libstdc++-v3/include/std/std_iterator.h
@@ -1,6 +1,6 @@
 // <iterator> -*- C++ -*-
 
-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,6 +61,7 @@
 #define _GLIBCXX_ITERATOR 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <cstddef>
@@ -72,4 +73,6 @@
 #include <bits/stream_iterator.h>
 #include <bits/streambuf_iterator.h>
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_ITERATOR */
diff --git a/libstdc++-v3/include/std/std_limits.h b/libstdc++-v3/include/std/std_limits.h
index e7c33e5..2a54866 100644
--- a/libstdc++-v3/include/std/std_limits.h
+++ b/libstdc++-v3/include/std/std_limits.h
@@ -1,6 +1,7 @@
 // The template and inlines for the -*- C++ -*- numeric_limits classes.
 
-// Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2005
+// Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -43,6 +44,7 @@
 #define _GLIBCXX_NUMERIC_LIMITS 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 
@@ -1156,4 +1158,6 @@ namespace std
 #undef __glibcxx_digits
 #undef __glibcxx_digits10
 
+#pragma GCC visibility pop
+
 #endif // _GLIBCXX_NUMERIC_LIMITS
diff --git a/libstdc++-v3/include/std/std_list.h b/libstdc++-v3/include/std/std_list.h
index ee2105f..470cc8f 100644
--- a/libstdc++-v3/include/std/std_list.h
+++ b/libstdc++-v3/include/std/std_list.h
@@ -1,6 +1,6 @@
 // <list> -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,6 +61,7 @@
 #define _GLIBCXX_LIST 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/functexcept.h>
 #include <bits/stl_algobase.h>
@@ -77,5 +78,7 @@
 # include <debug/list>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_LIST */
 
diff --git a/libstdc++-v3/include/std/std_locale.h b/libstdc++-v3/include/std/std_locale.h
index 5223f90..895d76c 100644
--- a/libstdc++-v3/include/std/std_locale.h
+++ b/libstdc++-v3/include/std/std_locale.h
@@ -1,6 +1,7 @@
 // Locale support -*- C++ -*-
 
-// Copyright (C) 1997, 1998, 1999, 2002, 2003 Free Software Foundation, Inc.
+// Copyright (C) 1997, 1998, 1999, 2002, 2003, 2005
+// Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -39,10 +40,13 @@
 #define _GLIBCXX_LOCALE	1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/localefwd.h>
 #include <bits/locale_classes.h>
 #include <bits/locale_facets.h>
 #include <bits/locale_facets.tcc>
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_LOCALE */
diff --git a/libstdc++-v3/include/std/std_map.h b/libstdc++-v3/include/std/std_map.h
index 86ff432..db10398 100644
--- a/libstdc++-v3/include/std/std_map.h
+++ b/libstdc++-v3/include/std/std_map.h
@@ -1,6 +1,6 @@
 // <map> -*- C++ -*-
 
-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,6 +61,7 @@
 #define _GLIBCXX_MAP 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/stl_tree.h>
 #include <bits/stl_map.h>
@@ -70,4 +71,6 @@
 # include <debug/map>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_MAP */
diff --git a/libstdc++-v3/include/std/std_memory.h b/libstdc++-v3/include/std/std_memory.h
index 006912d..b46de07 100644
--- a/libstdc++-v3/include/std/std_memory.h
+++ b/libstdc++-v3/include/std/std_memory.h
@@ -1,6 +1,6 @@
 // <memory> -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -49,6 +49,7 @@
 #define _GLIBCXX_MEMORY 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/stl_algobase.h>
 #include <bits/allocator.h>
@@ -370,4 +371,6 @@ namespace std
   };
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_MEMORY */
diff --git a/libstdc++-v3/include/std/std_numeric.h b/libstdc++-v3/include/std/std_numeric.h
index 2e93812..26bbd3e 100644
--- a/libstdc++-v3/include/std/std_numeric.h
+++ b/libstdc++-v3/include/std/std_numeric.h
@@ -1,6 +1,6 @@
 // <numeric> -*- C++ -*-
 
-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,6 +61,7 @@
 #define _GLIBCXX_NUMERIC 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <cstddef>
@@ -68,4 +69,6 @@
 #include <bits/stl_function.h>
 #include <bits/stl_numeric.h>
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_NUMERIC */
diff --git a/libstdc++-v3/include/std/std_ostream.h b/libstdc++-v3/include/std/std_ostream.h
index ffc1a28..96f09bc 100644
--- a/libstdc++-v3/include/std/std_ostream.h
+++ b/libstdc++-v3/include/std/std_ostream.h
@@ -1,6 +1,6 @@
 // Output streams -*- C++ -*-
 
-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003
+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -40,6 +40,7 @@
 #define _GLIBCXX_OSTREAM 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <ios>
 
@@ -525,4 +526,6 @@ namespace std
 # include <bits/ostream.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif	/* _GLIBCXX_OSTREAM */
diff --git a/libstdc++-v3/include/std/std_queue.h b/libstdc++-v3/include/std/std_queue.h
index d232676..2fa2102 100644
--- a/libstdc++-v3/include/std/std_queue.h
+++ b/libstdc++-v3/include/std/std_queue.h
@@ -1,6 +1,6 @@
 // <queue> -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,6 +61,7 @@
 #define _GLIBCXX_QUEUE 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <bits/functexcept.h>
@@ -74,4 +75,6 @@
 #include <vector>
 #include <bits/stl_queue.h>
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_QUEUE */
diff --git a/libstdc++-v3/include/std/std_set.h b/libstdc++-v3/include/std/std_set.h
index d01681b..4db3610 100644
--- a/libstdc++-v3/include/std/std_set.h
+++ b/libstdc++-v3/include/std/std_set.h
@@ -1,6 +1,6 @@
 // <set> -*- C++ -*-
 
-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,7 +61,8 @@
 #define _GLIBCXX_SET 1
 
 #pragma GCC system_header
-
+#pragma GCC visibility push(default)
+ 
 #include <bits/stl_tree.h>
 #include <bits/stl_set.h>
 #include <bits/stl_multiset.h>
@@ -70,4 +71,6 @@
 # include <debug/set>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_SET */
diff --git a/libstdc++-v3/include/std/std_sstream.h b/libstdc++-v3/include/std/std_sstream.h
index 9d24764..5301215 100644
--- a/libstdc++-v3/include/std/std_sstream.h
+++ b/libstdc++-v3/include/std/std_sstream.h
@@ -40,6 +40,7 @@
 #define _GLIBCXX_SSTREAM 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <istream>
 #include <ostream>
@@ -587,4 +588,6 @@ namespace std
 # include <bits/sstream.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_SSTREAM */
diff --git a/libstdc++-v3/include/std/std_stack.h b/libstdc++-v3/include/std/std_stack.h
index 4112b2d..19937eb 100644
--- a/libstdc++-v3/include/std/std_stack.h
+++ b/libstdc++-v3/include/std/std_stack.h
@@ -1,6 +1,6 @@
 // <stack> -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,6 +61,7 @@
 #define _GLIBCXX_STACK 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/stl_algobase.h>
 #include <bits/allocator.h>
@@ -69,4 +70,6 @@
 #include <deque>
 #include <bits/stl_stack.h>
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_STACK */
diff --git a/libstdc++-v3/include/std/std_stdexcept.h b/libstdc++-v3/include/std/std_stdexcept.h
index 4ecc53e..f83c49e 100644
--- a/libstdc++-v3/include/std/std_stdexcept.h
+++ b/libstdc++-v3/include/std/std_stdexcept.h
@@ -1,6 +1,6 @@
 // Standard exception classes  -*- C++ -*-
 
-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -39,6 +39,7 @@
 #define _GLIBCXX_STDEXCEPT 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <exception>
 #include <string>
@@ -144,4 +145,6 @@ namespace std
   };
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_STDEXCEPT */
diff --git a/libstdc++-v3/include/std/std_streambuf.h b/libstdc++-v3/include/std/std_streambuf.h
index b20bd63..63bcda8 100644
--- a/libstdc++-v3/include/std/std_streambuf.h
+++ b/libstdc++-v3/include/std/std_streambuf.h
@@ -40,6 +40,7 @@
 #define _GLIBXX_STREAMBUF 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <iosfwd>
@@ -806,4 +807,6 @@ namespace std
 # include <bits/streambuf.tcc>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_STREAMBUF */
diff --git a/libstdc++-v3/include/std/std_string.h b/libstdc++-v3/include/std/std_string.h
index a75f448..210d358 100644
--- a/libstdc++-v3/include/std/std_string.h
+++ b/libstdc++-v3/include/std/std_string.h
@@ -40,6 +40,7 @@
 #define _GLIBCXX_STRING	1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <bits/stringfwd.h>
@@ -56,4 +57,6 @@
 # include <bits/basic_string.tcc> 
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_STRING */
diff --git a/libstdc++-v3/include/std/std_utility.h b/libstdc++-v3/include/std/std_utility.h
index 7b74486..8154a2d 100644
--- a/libstdc++-v3/include/std/std_utility.h
+++ b/libstdc++-v3/include/std/std_utility.h
@@ -1,6 +1,6 @@
 // <utility> -*- C++ -*-
 
-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,9 +61,12 @@
 #define _GLIBCXX_UTILITY 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <bits/stl_relops.h>
 #include <bits/stl_pair.h>
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_UTILITY */
diff --git a/libstdc++-v3/include/std/std_valarray.h b/libstdc++-v3/include/std/std_valarray.h
index 512f533..96e3df8 100644
--- a/libstdc++-v3/include/std/std_valarray.h
+++ b/libstdc++-v3/include/std/std_valarray.h
@@ -1,6 +1,6 @@
 // The template and inlines for the -*- C++ -*- valarray class.
 
-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2004
+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005
 // Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
@@ -38,6 +38,7 @@
 #define _GLIBCXX_VALARRAY 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/c++config.h>
 #include <cstddef>
@@ -1007,4 +1008,6 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
 
 } // namespace std
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_VALARRAY */
diff --git a/libstdc++-v3/include/std/std_vector.h b/libstdc++-v3/include/std/std_vector.h
index 7b4db35..a88390f 100644
--- a/libstdc++-v3/include/std/std_vector.h
+++ b/libstdc++-v3/include/std/std_vector.h
@@ -1,6 +1,6 @@
 // <vector> -*- C++ -*-
 
-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+// Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -61,6 +61,7 @@
 #define _GLIBCXX_VECTOR 1
 
 #pragma GCC system_header
+#pragma GCC visibility push(default)
 
 #include <bits/functexcept.h>
 #include <bits/stl_algobase.h>
@@ -78,5 +79,7 @@
 # include <debug/vector>
 #endif
 
+#pragma GCC visibility pop
+
 #endif /* _GLIBCXX_VECTOR */
 
diff --git a/libstdc++-v3/include/tr1/array b/libstdc++-v3/include/tr1/array
index aa31111..25e910f 100644
--- a/libstdc++-v3/include/tr1/array
+++ b/libstdc++-v3/include/tr1/array
@@ -34,6 +34,8 @@
 #ifndef _ARRAY
 #define _ARRAY 1
 
+#pragma GCC visibility push(default)
+
 #include <new>
 #include <iterator>
 #include <algorithm>
@@ -258,4 +260,6 @@ namespace tr1
 } // namespace std::tr1
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/tr1/functional b/libstdc++-v3/include/tr1/functional
index 3775438..2e979f0 100644
--- a/libstdc++-v3/include/tr1/functional
+++ b/libstdc++-v3/include/tr1/functional
@@ -36,6 +36,8 @@
 
 #pragma GCC system_header
 
+#pragma GCC visibility push(default)
+
 #include "../functional"
 #include <typeinfo>
 #include <tr1/type_traits>
@@ -1277,4 +1279,6 @@ namespace tr1
 }
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/tr1/memory b/libstdc++-v3/include/tr1/memory
index 498fbe6..1ca44d4 100644
--- a/libstdc++-v3/include/tr1/memory
+++ b/libstdc++-v3/include/tr1/memory
@@ -30,6 +30,8 @@
 #ifndef _TR1_MEMORY
 #define _TR1_MEMORY 1
 
+#pragma GCC visibility push(default)
+
 #include "../memory"
 #include <functional>       // std::less
 #include <exception>        // std::exception
@@ -48,4 +50,6 @@
 
 #include <tr1/boost_shared_ptr.h>
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/tr1/tuple b/libstdc++-v3/include/tr1/tuple
index ea7bb23..237dbfa 100644
--- a/libstdc++-v3/include/tr1/tuple
+++ b/libstdc++-v3/include/tr1/tuple
@@ -36,6 +36,8 @@
 #ifndef _TUPLE
 #define _TUPLE 1
 
+#pragma GCC visibility push(default)
+
 #include <tr1/utility>
 #include <tr1/ref_fwd.h>
 
@@ -272,4 +274,6 @@ namespace tr1
 
 #include <tr1/functional>
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/tr1/type_traits b/libstdc++-v3/include/tr1/type_traits
index 72fd2b0..2cd8664 100644
--- a/libstdc++-v3/include/tr1/type_traits
+++ b/libstdc++-v3/include/tr1/type_traits
@@ -34,6 +34,8 @@
 #ifndef _TYPE_TRAITS
 #define _TYPE_TRAITS 1
 
+#pragma GCC visibility push(default)
+
 #include <bits/c++config.h>
 #include <tr1/type_traits_fwd.h>
 
@@ -693,4 +695,6 @@ namespace tr1
 }
 }
 
+#pragma GCC visibility pop
+
 #endif
diff --git a/libstdc++-v3/include/tr1/unordered_map b/libstdc++-v3/include/tr1/unordered_map
index 2f789c8..b765a1a 100644
--- a/libstdc++-v3/include/tr1/unordered_map
+++ b/libstdc++-v3/include/tr1/unordered_map
@@ -34,6 +34,8 @@
 #ifndef GNU_LIBSTDCXX_TR1_UNORDERED_MAP_
 #define GNU_LIBSTDCXX_TR1_UNORDERED_MAP_
 
+#pragma GCC visibility push(default)
+
 #include <tr1/hashtable>
 #include <tr1/functional>
 #include <tr1/functional>
@@ -167,4 +169,6 @@ namespace tr1
 }
 }
 
+#pragma GCC visibility pop
+
 #endif /* GNU_LIBSTDCXX_TR1_UNORDERED_MAP_ */
diff --git a/libstdc++-v3/include/tr1/unordered_set b/libstdc++-v3/include/tr1/unordered_set
index 6a4881a..961699c 100644
--- a/libstdc++-v3/include/tr1/unordered_set
+++ b/libstdc++-v3/include/tr1/unordered_set
@@ -34,6 +34,8 @@
 #ifndef GNU_LIBSTDCXX_TR1_UNORDERED_SET_
 #define GNU_LIBSTDCXX_TR1_UNORDERED_SET_
 
+#pragma GCC visibility push(default)
+
 #include <tr1/hashtable>
 #include <tr1/functional>
 #include <memory>
@@ -162,4 +164,6 @@ namespace tr1
 }
 }
 
+#pragma GCC visibility pop
+
 #endif /* GNU_LIBSTDCXX_TR1_UNORDERED_SET_ */
diff --git a/libstdc++-v3/include/tr1/utility b/libstdc++-v3/include/tr1/utility
index 246a6fa..61ce827 100644
--- a/libstdc++-v3/include/tr1/utility
+++ b/libstdc++-v3/include/tr1/utility
@@ -34,6 +34,8 @@
 #ifndef _TR1_UTILITY
 #define _TR1_UTILITY 1
 
+#pragma GCC visibility push(default)
+
 #include "../utility"
 
 namespace std
@@ -93,6 +95,8 @@ namespace tr1
      get(const pair<_Tp1, _Tp2>& __in)
      { return __pair_get<_Int>::__const_get(__in); }
 }
-} 
+}
+
+#pragma GCC visibility pop
 
 #endif
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index bc7f505..63c5070 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -234,6 +234,13 @@ CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \
 	  $(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LDFLAGS) -o $@
 
 
+install-exec-local:
+	pic_objs=`sed -n "s:'::g;s:^pic_object=::p" *.lo | grep -v '^none$$'`; \
+	if [ x"$$pic_objs" != x ]; then \
+		$(AR) cru libstdc++_pic.a $$pic_objs $(top_builddir)/libsupc++/*.o || exit 1; \
+		$(INSTALL_DATA) libstdc++_pic.a $(DESTDIR)$(toolexeclibdir) || exit 1; \
+	fi
+
 # Added bits to build debug library.
 if GLIBCXX_BUILD_DEBUG
 all-local: build_debug
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index cf58c42..5570846 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -627,7 +627,7 @@ info-am:
 
 install-data-am: install-data-local
 
-install-exec-am: install-toolexeclibLTLIBRARIES
+install-exec-am: install-toolexeclibLTLIBRARIES install-exec-local
 
 install-info: install-info-am
 
@@ -666,7 +666,7 @@ uninstall-am: uninstall-info-am uninstall-toolexeclibLTLIBRARIES
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
 	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-toolexeclibLTLIBRARIES
+	uninstall-toolexeclibLTLIBRARIES install-exec-local
 
 
 # Symbol versioning for shared libraries.
@@ -760,6 +760,14 @@ build_debug: stamp-debug
 install_debug:
 	(cd ${debugdir} && $(MAKE) \
 	toolexeclibdir=$(glibcxx_toolexeclibdir)/debug install)
+
+install-exec-local:
+	pic_objs=`sed -n "s:'::g;s:^pic_object=::p" *.lo | grep -v '^none$$'`; \
+	if [ x"$$pic_objs" != x ]; then \
+		$(AR) cru libstdc++_pic.a $$pic_objs $(top_builddir)/libsupc++/*.o || exit 1; \
+		$(INSTALL_DATA) libstdc++_pic.a $(DESTDIR)$(toolexeclibdir) || exit 1; \
+	fi
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff --git a/libstdc++-v3/testsuite/20_util/memory/auto_ptr/assign_neg.cc b/libstdc++-v3/testsuite/20_util/memory/auto_ptr/assign_neg.cc
index cf4041d..ac842bd 100644
--- a/libstdc++-v3/testsuite/20_util/memory/auto_ptr/assign_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/memory/auto_ptr/assign_neg.cc
@@ -46,5 +46,5 @@ main()
   test01();
   return 0;
 }
-// { dg-error "candidates" "" { target *-*-* } 223 } 
-// { dg-error "std::auto_ptr" "" { target *-*-* } 353 } 
+// { dg-error "candidates" "" { target *-*-* } 224 } 
+// { dg-error "std::auto_ptr" "" { target *-*-* } 354 } 
