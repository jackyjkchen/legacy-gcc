diff --git a/ChangeLog b/ChangeLog
index 71d931e8941..25ed362c431 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,17 @@
+2007-09-15  Alan Modra  <amodra@bigpond.net.au>
+
+	* configure.in: Correct makeinfo version check.
+	* configure: Regenerate.
+
+2007-07-05  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* MAINTAINERS (OS Port Maintainers): Add myself as IRIX, Tru64 UNIX
+	maintainer.
+
+2007-02-16  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* ltconfig (freebsd*): Default to elf.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/MAINTAINERS b/MAINTAINERS
index df7499b372c..4e166839fdd 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -95,6 +95,7 @@ darwin port		Mike Stump		mrs@apple.com
 darwin port		Stan Shebs		shebs@apple.com
 DJGPP			DJ Delorie		dj@delorie.com
 freebsd			Loren J. Rittle		ljrittle@acm.org
+irix, osf		Rainer Orth		ro@TechFak.Uni-Bielefeld.DE
 netbsd			Jason Thorpe		thorpej@netbsd.org
 sco5, unixware, sco udk	Kean Johnston		jkj@sco.com
 sh-linux-gnu		Kaz Kojima		kkojima@gcc.gnu.org
@@ -301,7 +302,6 @@ Dan Nicolaescu					dann@ics.uci.edu
 David O'Brien					obrien@FreeBSD.org
 Turly O'Connor					turly@apple.com
 Jeffrey D. Oldham				oldham@codesourcery.com
-Rainer Orth					ro@TechFak.Uni-Bielefeld.DE
 Devang Patel					dpatel@apple.com
 Graeme Peterson					gp@qnx.com
 Alexandre Petit-Bianco				apbianco@redhat.com
diff --git a/boehm-gc/ChangeLog b/boehm-gc/ChangeLog
index c8ddffbca27..0be3c582e1b 100644
--- a/boehm-gc/ChangeLog
+++ b/boehm-gc/ChangeLog
@@ -1,3 +1,24 @@
+2007-07-02  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	PR boehm-gc/21940
+	PR boehm-gc/21942
+	* configure.ac (GC_SOLARIS_THREADS): Don't define on *-*-solaris*.
+	Use alternate thread library in /usr/lib/lwp.
+	* configure: Regenerate.
+	* dyn_load.c: Use GC_SOLARIS_PTHREADS.
+	* include/gc_config_macros.h (GC_SOLARIS_THREADS): Don't define.
+	* include/private/gcconfig.h: Handle 64-bit Solaris 2/x86.
+	(GC_SOLARIS_THREADS): Don't define.
+	* include/private/solaris_threads.h: Remove.
+	* pthread_support.c (GC_thr_init) [GC_SOLARIS_PTHREADS]: Determine
+	GC_nprocs via sysconf().
+	* Makefile.am (libgcjgc_la_SOURCES): Remove solaris_pthreads.c and
+	solaris_threads.c.
+	(gctest_LDADD): Use THREADLIBS instead of THREADDLLIBS.
+	* Makefile.in: Regenerate.	 
+	* solaris_pthreads.c: Remove.
+	* solaris_threads.c: Remove.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/boehm-gc/Makefile.am b/boehm-gc/Makefile.am
index c87d8c52cc0..83fba100c68 100644
--- a/boehm-gc/Makefile.am
+++ b/boehm-gc/Makefile.am
@@ -21,7 +21,7 @@ GC_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \
 dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c aix_irix_threads.c \
 malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \
 obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \
-solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \
+specific.c stubborn.c typd_mlc.c \
 backgraph.c win32_threads.c \
 pthread_support.c pthread_stop_world.c darwin_stop_world.c \
 $(asm_libgc_sources)
diff --git a/boehm-gc/Makefile.in b/boehm-gc/Makefile.in
index 6f842205efe..3b92ce3ffcf 100644
--- a/boehm-gc/Makefile.in
+++ b/boehm-gc/Makefile.in
@@ -64,8 +64,7 @@ DIST_COMMON = $(srcdir)/../config.guess $(srcdir)/../config.sub \
 	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
 	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
 	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
-	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
-	$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \
+	$(srcdir)/../compile $(srcdir)/../compile \
 	$(srcdir)/../ltmain.sh $(srcdir)/../config.guess \
 	$(srcdir)/../config.sub
 subdir = .
@@ -88,9 +87,9 @@ am__objects_2 = allchblk.lo alloc.lo blacklst.lo checksums.lo \
 	headers.lo aix_irix_threads.lo malloc.lo mallocx.lo mark.lo \
 	mark_rts.lo misc.lo new_hblk.lo obj_map.lo os_dep.lo \
 	pcr_interface.lo ptr_chck.lo real_malloc.lo reclaim.lo \
-	solaris_pthreads.lo solaris_threads.lo specific.lo stubborn.lo \
-	typd_mlc.lo backgraph.lo win32_threads.lo pthread_support.lo \
-	pthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)
+	specific.lo stubborn.lo typd_mlc.lo backgraph.lo \
+	win32_threads.lo pthread_support.lo pthread_stop_world.lo \
+	darwin_stop_world.lo $(am__objects_1)
 am_libgcjgc_la_OBJECTS = $(am__objects_2)
 libgcjgc_la_OBJECTS = $(am_libgcjgc_la_OBJECTS)
 am_libgcjgc_convenience_la_OBJECTS = $(am__objects_2)
@@ -258,7 +257,7 @@ GC_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \
 dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c aix_irix_threads.c \
 malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \
 obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \
-solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c \
+specific.c stubborn.c typd_mlc.c \
 backgraph.c win32_threads.c \
 pthread_support.c pthread_stop_world.c darwin_stop_world.c \
 $(asm_libgc_sources)
diff --git a/boehm-gc/configure b/boehm-gc/configure
index d1ba87617e1..5dbc9af4734 100755
--- a/boehm-gc/configure
+++ b/boehm-gc/configure
@@ -5447,15 +5447,15 @@ _ACEOF
       	;;
      *-*-solaris*)
 
-cat >>confdefs.h <<\_ACEOF
-#define GC_SOLARIS_THREADS 1
-_ACEOF
-
-
 cat >>confdefs.h <<\_ACEOF
 #define GC_SOLARIS_PTHREADS 1
 _ACEOF
 
+	# Need to use alternate thread library, otherwise gctest hangs
+	# on Solaris 8.
+	multi_os_directory=`$CC -print-multi-os-directory`
+	THREADLIBS="-L/usr/lib/lwp/$multi_os_directory \
+		    -R/usr/lib/lwp/$multi_os_directory -lpthread -lthread -lrt"
 	;;
      *-*-irix*)
 
diff --git a/boehm-gc/configure.ac b/boehm-gc/configure.ac
index ef1e831a4b5..727f2d676d9 100644
--- a/boehm-gc/configure.ac
+++ b/boehm-gc/configure.ac
@@ -157,8 +157,12 @@ case "$THREADS" in
 	THREADLIBS=-pthread
       	;;
      *-*-solaris*)
-	AC_DEFINE(GC_SOLARIS_THREADS,1,[support for Solaris (thr_) threads])
 	AC_DEFINE(GC_SOLARIS_PTHREADS,1,[support for Solaris pthreads])
+	# Need to use alternate thread library, otherwise gctest hangs
+	# on Solaris 8.
+	multi_os_directory=`$CC -print-multi-os-directory`
+	THREADLIBS="-L/usr/lib/lwp/$multi_os_directory \
+		    -R/usr/lib/lwp/$multi_os_directory -lpthread -lthread -lrt"
 	;;
      *-*-irix*)
 	AC_DEFINE(GC_IRIX_THREADS,1,[support for Irix pthreads])
diff --git a/boehm-gc/dyn_load.c b/boehm-gc/dyn_load.c
index c5139aa80a8..0ae6e78836d 100644
--- a/boehm-gc/dyn_load.c
+++ b/boehm-gc/dyn_load.c
@@ -206,7 +206,7 @@ static ptr_t GC_first_common()
 
 # if defined(SUNOS4) || defined(SUNOS5DL)
 /* Add dynamic library data sections to the root set.		*/
-# if !defined(PCR) && !defined(GC_SOLARIS_THREADS) && defined(THREADS)
+# if !defined(PCR) && !defined(GC_SOLARIS_PTHREADS) && defined(THREADS)
 #   ifndef SRC_M3
 	--> fix mutual exclusion with dlopen
 #   endif  /* We assume M3 programs don't call dlopen for now */
diff --git a/boehm-gc/include/gc_config_macros.h b/boehm-gc/include/gc_config_macros.h
index 90c574ed43c..07897c867e0 100644
--- a/boehm-gc/include/gc_config_macros.h
+++ b/boehm-gc/include/gc_config_macros.h
@@ -68,10 +68,6 @@
 # define GC_WIN32_THREADS
 #endif
 
-#if defined(GC_SOLARIS_PTHREADS) && !defined(GC_SOLARIS_THREADS)
-#   define GC_SOLARIS_THREADS
-#endif
-
 # define __GC
 # ifndef _WIN32_WCE
 #   include <stddef.h>
diff --git a/boehm-gc/include/private/gcconfig.h b/boehm-gc/include/private/gcconfig.h
index deed0f5de98..d1444b7ea37 100644
--- a/boehm-gc/include/private/gcconfig.h
+++ b/boehm-gc/include/private/gcconfig.h
@@ -146,6 +146,11 @@
 #    define SUNOS5
 #    define mach_type_known
 # endif
+# if defined(sun) && defined(__amd64)
+#    define X86_64
+#    define SUNOS5
+#    define mach_type_known
+# endif
 # if (defined(__OS2__) || defined(__EMX__)) && defined(__32BIT__)
 #    define I386
 #    define OS2
@@ -1932,6 +1937,36 @@
 	extern char etext[];
 #	define SEARCH_FOR_DATA_START
 #   endif
+#   ifdef SUNOS5
+#	define ELF_CLASS ELFCLASS64
+#	define OS_TYPE "SUNOS5"
+        extern int _etext[], _end[];
+  	extern ptr_t GC_SysVGetDataStart();
+#       define DATASTART GC_SysVGetDataStart(0x1000, _etext)
+#	define DATAEND (_end)
+/*	# define STACKBOTTOM ((ptr_t)(_start)) worked through 2.7,  	*/
+/*      but reportedly breaks under 2.8.  It appears that the stack	*/
+/* 	base is a property of the executable, so this should not break	*/
+/* 	old executables.						*/
+/*  	HEURISTIC2 probably works, but this appears to be preferable.	*/
+/* #       include <sys/vm.h> */
+/* #	define STACKBOTTOM USRSTACK */
+#	define HEURISTIC2
+#	define PROC_VDB
+#	define DYNAMIC_LOADING
+#	if !defined(USE_MMAP) && defined(REDIRECT_MALLOC)
+#	    define USE_MMAP
+	    /* Otherwise we now use calloc.  Mmap may result in the	*/
+	    /* heap interleaved with thread stacks, which can result in	*/
+	    /* excessive blacklisting.  Sbrk is unusable since it	*/
+	    /* doesn't interact correctly with the system malloc.	*/
+#	endif
+#       ifdef USE_MMAP
+#         define HEAP_START (ptr_t)0x40000000
+#       else
+#	  define HEAP_START DATAEND
+#       endif
+#   endif
 # endif
 
 #if defined(LINUX) && defined(USE_MMAP)
@@ -2077,11 +2112,6 @@
 		((word*)x)[1] = 0;
 # endif /* CLEAR_DOUBLE */
 
-	/* Internally we use GC_SOLARIS_THREADS to test for either old or pthreads. */
-# if defined(GC_SOLARIS_PTHREADS) && !defined(GC_SOLARIS_THREADS)
-#   define GC_SOLARIS_THREADS
-# endif
-
 # if defined(GC_IRIX_THREADS) && !defined(IRIX5)
 	--> inconsistent configuration
 # endif
diff --git a/boehm-gc/include/private/solaris_threads.h b/boehm-gc/include/private/solaris_threads.h
deleted file mode 100644
index b1f62620bd7..00000000000
--- a/boehm-gc/include/private/solaris_threads.h
+++ /dev/null
@@ -1,37 +0,0 @@
-#ifdef GC_SOLARIS_THREADS
-
-/* The set of all known threads.  We intercept thread creation and     */
-/* joins.  We never actually create detached threads.  We allocate all */
-/* new thread stacks ourselves.  These allow us to maintain this       */
-/* data structure.                                                     */
-/* Protected by GC_thr_lock.                                           */
-/* Some of this should be declared volatile, but that's incosnsistent  */
-/* with some library routine declarations.  In particular, the 	       */
-/* definition of cond_t doesn't mention volatile!                      */
-  typedef struct GC_Thread_Rep {
-    struct GC_Thread_Rep * next;
-    thread_t id;
-    word flags;
-#      define FINISHED 1       /* Thread has exited.   */
-#      define DETACHED 2       /* Thread is intended to be detached.   */
-#      define CLIENT_OWNS_STACK        4
-                               /* Stack was supplied by client.        */
-#      define SUSPNDED 8       /* Currently suspended.			*/
-    			       /* SUSPENDED is used insystem header.	*/
-    ptr_t stack;
-    size_t stack_size;
-    cond_t join_cv;
-    void * status;
-  } * GC_thread;
-  extern GC_thread GC_new_thread(thread_t id);
-
-  extern GC_bool GC_thr_initialized;
-  extern volatile GC_thread GC_threads[];
-  extern size_t GC_min_stack_sz;
-  extern size_t GC_page_sz;
-  extern void GC_thr_init(void);
-  extern ptr_t GC_stack_alloc(size_t * stack_size);
-  extern void GC_stack_free(ptr_t stack, size_t size);
-
-# endif /* GC_SOLARIS_THREADS */
-
diff --git a/boehm-gc/pthread_support.c b/boehm-gc/pthread_support.c
index 4b32afef4bd..73def039c4f 100644
--- a/boehm-gc/pthread_support.c
+++ b/boehm-gc/pthread_support.c
@@ -881,7 +881,7 @@ void GC_thr_init()
 #       if defined(GC_HPUX_THREADS)
 	  GC_nprocs = pthread_num_processors_np();
 #       endif
-#	if defined(GC_OSF1_THREADS)
+#	if defined(GC_OSF1_THREADS) || defined(GC_SOLARIS_PTHREADS)
 	  GC_nprocs = sysconf(_SC_NPROCESSORS_ONLN);
 	  if (GC_nprocs <= 0) GC_nprocs = 1;
 #	endif
diff --git a/boehm-gc/solaris_pthreads.c b/boehm-gc/solaris_pthreads.c
deleted file mode 100644
index 90f60058f6d..00000000000
--- a/boehm-gc/solaris_pthreads.c
+++ /dev/null
@@ -1,179 +0,0 @@
-/* 
- * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.
- *
- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
- *
- * Permission is hereby granted to use or copy this program
- * for any purpose,  provided the above notices are retained on all copies.
- * Permission to modify the code and to distribute modified code is granted,
- * provided the above notices are retained, and a notice that the code was
- * modified is included with the above copyright notice.
- */
-/*
- * Support code for Solaris threads.  Provides functionality we wish Sun
- * had provided.  Relies on some information we probably shouldn't rely on.
- * Modified by Peter C. for Solaris Posix Threads.
- */
-
-#include "private/gc_priv.h"
-
-# if defined(GC_SOLARIS_PTHREADS)
-# include <pthread.h>
-# include <thread.h>
-# include <signal.h>
-# include <fcntl.h>
-# include <sys/types.h>
-# include <sys/mman.h>
-# include <sys/time.h>
-# include <sys/resource.h>
-# include <sys/stat.h>
-# include <sys/syscall.h>
-# include <sys/procfs.h>
-# include <sys/lwp.h>
-# include <sys/reg.h>
-# define _CLASSIC_XOPEN_TYPES
-# include <unistd.h>
-# include <errno.h>
-# include "private/solaris_threads.h"
-# include <stdio.h>
-
-#undef pthread_join
-#undef pthread_create
-
-pthread_cond_t GC_prom_join_cv;		/* Broadcast when any thread terminates	*/
-pthread_cond_t GC_create_cv;		/* Signalled when a new undetached	*/
-				/* thread starts.			*/
-				
-extern GC_bool GC_multithreaded;
-
-/* We use the allocation lock to protect thread-related data structures. */
-
-/* We stop the world using /proc primitives.  This makes some	*/
-/* minimal assumptions about the threads implementation.	*/
-/* We don't play by the rules, since the rules make this	*/
-/* impossible (as of Solaris 2.3).  Also note that as of	*/
-/* Solaris 2.3 the various thread and lwp suspension		*/
-/* primitives failed to stop threads by the time the request	*/
-/* is completed.						*/
-
-
-
-int GC_pthread_join(pthread_t wait_for, void **status)
-{
-	return GC_thr_join((thread_t)wait_for, NULL, status);
-}
-
-
-int
-GC_pthread_create(pthread_t *new_thread,
-          const pthread_attr_t *attr_in,
-          void * (*thread_execp)(void *), void *arg)
-{
-    int result;
-    GC_thread t;
-    pthread_t my_new_thread;
-    pthread_attr_t  attr;
-    word my_flags = 0;
-    int  flag;
-    void * stack = 0;
-    size_t stack_size = 0;
-    int    n;
-    struct sched_param schedparam;
-   
-    (void)pthread_attr_init(&attr);
-    if (attr_in != 0) {
-	(void)pthread_attr_getstacksize(attr_in, &stack_size);
-	(void)pthread_attr_getstackaddr(attr_in, &stack);
-    }
-
-    LOCK();
-    if (!GC_is_initialized) {
-	    GC_init_inner();
-    }
-    GC_multithreaded++;
-	    
-    if (stack == 0) {
-     	if (stack_size == 0)
-		stack_size = 1048576;
-			  /* ^-- 1 MB (this was GC_min_stack_sz, but that
-			   * violates the pthread_create documentation which
-			   * says the default value if none is supplied is
-			   * 1MB) */
-	else
-		stack_size += thr_min_stack();
-
-     	stack = (void *)GC_stack_alloc(&stack_size);
-     	if (stack == 0) {
-	    GC_multithreaded--;
-     	    UNLOCK();
-	    errno = ENOMEM;
-     	    return -1;
-     	}
-    } else {
-    	my_flags |= CLIENT_OWNS_STACK;
-    }
-    (void)pthread_attr_setstacksize(&attr, stack_size);
-    (void)pthread_attr_setstackaddr(&attr, stack);
-    if (attr_in != 0) {
-	(void)pthread_attr_getscope(attr_in, &n);
-	(void)pthread_attr_setscope(&attr, n);
-	(void)pthread_attr_getschedparam(attr_in, &schedparam);
-	(void)pthread_attr_setschedparam(&attr, &schedparam);
-	(void)pthread_attr_getschedpolicy(attr_in, &n);
-	(void)pthread_attr_setschedpolicy(&attr, n);
-	(void)pthread_attr_getinheritsched(attr_in, &n);
-	(void)pthread_attr_setinheritsched(&attr, n);
-
-	(void)pthread_attr_getdetachstate(attr_in, &flag);
-	if (flag == PTHREAD_CREATE_DETACHED) {
-		my_flags |= DETACHED;
-	}
-	(void)pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
-    }
-    /*
-     * thr_create can call malloc(), which if redirected will
-     * attempt to acquire the allocation lock.
-     * Unlock here to prevent deadlock.
-     */
-
-
-#if 0
-#ifdef I386
-    UNLOCK();
-#endif
-#endif
-    result = 
-	    pthread_create(&my_new_thread, &attr, thread_execp, arg);
-#if 0
-#ifdef I386
-    LOCK();
-#endif
-#endif
-    if (result == 0) {
-        t = GC_new_thread(my_new_thread);
-        t -> flags = my_flags;
-        if (!(my_flags & DETACHED)) cond_init(&(t->join_cv), USYNC_THREAD, 0);
-        t -> stack = stack;
-        t -> stack_size = stack_size;
-        if (new_thread != 0) *new_thread = my_new_thread;
-        pthread_cond_signal(&GC_create_cv);
-    } else {
-	    if (!(my_flags & CLIENT_OWNS_STACK)) {
-		    GC_stack_free(stack, stack_size);
-	    }        
-	    GC_multithreaded--;
-    }
-    UNLOCK();
-    pthread_attr_destroy(&attr);
-    return(result);
-}
-
-# else
-
-#ifndef LINT
-  int GC_no_sunOS_pthreads;
-#endif
-
-# endif /* GC_SOLARIS_PTHREADS */
-
diff --git a/boehm-gc/solaris_threads.c b/boehm-gc/solaris_threads.c
deleted file mode 100644
index b599c5816ad..00000000000
--- a/boehm-gc/solaris_threads.c
+++ /dev/null
@@ -1,959 +0,0 @@
-/* 
- * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.
- *
- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
- *
- * Permission is hereby granted to use or copy this program
- * for any purpose,  provided the above notices are retained on all copies.
- * Permission to modify the code and to distribute modified code is granted,
- * provided the above notices are retained, and a notice that the code was
- * modified is included with the above copyright notice.
- */
-/*
- * Support code for Solaris threads.  Provides functionality we wish Sun
- * had provided.  Relies on some information we probably shouldn't rely on.
- */
-/* Boehm, September 14, 1994 4:44 pm PDT */
-
-#include "private/gc_priv.h"
-
-# if defined(GC_SOLARIS_THREADS) || defined(GC_SOLARIS_PTHREADS)
-# include "private/solaris_threads.h"
-# include <thread.h>
-# include <synch.h>
-# include <signal.h>
-# include <fcntl.h>
-# include <sys/types.h>
-# include <sys/mman.h>
-# include <sys/time.h>
-# include <sys/resource.h>
-# include <sys/stat.h>
-# include <sys/syscall.h>
-# include <sys/procfs.h>
-# include <sys/lwp.h>
-# include <sys/reg.h>
-# define _CLASSIC_XOPEN_TYPES
-# include <unistd.h>
-# include <errno.h>
-
-#ifdef HANDLE_FORK
-  --> Not yet supported.  Try porting the code from linux_threads.c.
-#endif
-
-/*
- * This is the default size of the LWP arrays. If there are more LWPs
- * than this when a stop-the-world GC happens, set_max_lwps will be
- * called to cope.
- * This must be higher than the number of LWPs at startup time.
- * The threads library creates a thread early on, so the min. is 3
- */
-# define DEFAULT_MAX_LWPS	4
-
-#undef thr_join
-#undef thr_create
-#undef thr_suspend
-#undef thr_continue
-
-cond_t GC_prom_join_cv;		/* Broadcast when any thread terminates	*/
-cond_t GC_create_cv;		/* Signalled when a new undetached	*/
-				/* thread starts.			*/
-				
-
-#ifdef MMAP_STACKS
-static int GC_zfd;
-#endif /* MMAP_STACKS */
-
-/* We use the allocation lock to protect thread-related data structures. */
-
-/* We stop the world using /proc primitives.  This makes some	*/
-/* minimal assumptions about the threads implementation.	*/
-/* We don't play by the rules, since the rules make this	*/
-/* impossible (as of Solaris 2.3).  Also note that as of	*/
-/* Solaris 2.3 the various thread and lwp suspension		*/
-/* primitives failed to stop threads by the time the request	*/
-/* is completed.						*/
-
-
-static sigset_t old_mask;
-
-/* Sleep for n milliseconds, n < 1000	*/
-void GC_msec_sleep(int n)
-{
-    struct timespec ts;
-                            
-    ts.tv_sec = 0;
-    ts.tv_nsec = 1000000*n;
-    if (syscall(SYS_nanosleep, &ts, 0) < 0) {
-	ABORT("nanosleep failed");
-    }
-}
-/* Turn off preemption;  gross but effective.  		*/
-/* Caller has allocation lock.				*/
-/* Actually this is not needed under Solaris 2.3 and	*/
-/* 2.4, but hopefully that'll change.			*/
-void preempt_off()
-{
-    sigset_t set;
-
-    (void)sigfillset(&set);
-    sigdelset(&set, SIGABRT);
-    syscall(SYS_sigprocmask, SIG_SETMASK, &set, &old_mask);
-}
-
-void preempt_on()
-{
-    syscall(SYS_sigprocmask, SIG_SETMASK, &old_mask, NULL);
-}
-
-int GC_main_proc_fd = -1;
-
-
-struct lwp_cache_entry {
-    lwpid_t lc_id;
-    int lc_descr;	/* /proc file descriptor.	*/
-}  GC_lwp_cache_default[DEFAULT_MAX_LWPS];
-
-static int max_lwps = DEFAULT_MAX_LWPS;
-static struct lwp_cache_entry *GC_lwp_cache = GC_lwp_cache_default;
-
-static prgregset_t GC_lwp_registers_default[DEFAULT_MAX_LWPS];
-static prgregset_t *GC_lwp_registers = GC_lwp_registers_default;
-
-/* Return a file descriptor for the /proc entry corresponding	*/
-/* to the given lwp.  The file descriptor may be stale if the	*/
-/* lwp exited and a new one was forked.				*/
-static int open_lwp(lwpid_t id)
-{
-    int result;
-    static int next_victim = 0;
-    register int i;
-    
-    for (i = 0; i < max_lwps; i++) {
-    	if (GC_lwp_cache[i].lc_id == id) return(GC_lwp_cache[i].lc_descr);
-    }
-    result = syscall(SYS_ioctl, GC_main_proc_fd, PIOCOPENLWP, &id);
-    /*
-     * If PIOCOPENLWP fails, try closing fds in the cache until it succeeds.
-     */
-    if (result < 0 && errno == EMFILE) {
-	    for (i = 0; i < max_lwps; i++) {
-		if (GC_lwp_cache[i].lc_id != 0) {
-        		(void)syscall(SYS_close, GC_lwp_cache[i].lc_descr);
-			result = syscall(SYS_ioctl, GC_main_proc_fd, PIOCOPENLWP, &id);
-			if (result >= 0 || (result < 0 && errno != EMFILE))
-				break;
-		}
-	    }
-    }
-    if (result < 0) {
-	if (errno == EMFILE) {
-		ABORT("Too many open files");
-	}
-        return(-1) /* exited? */;
-    }
-    if (GC_lwp_cache[next_victim].lc_id != 0)
-        (void)syscall(SYS_close, GC_lwp_cache[next_victim].lc_descr);
-    GC_lwp_cache[next_victim].lc_id = id;
-    GC_lwp_cache[next_victim].lc_descr = result;
-    if (++next_victim >= max_lwps)
-	next_victim = 0;
-    return(result);
-}
-
-static void uncache_lwp(lwpid_t id)
-{
-    register int i;
-    
-    for (i = 0; i < max_lwps; i++) {
-    	if (GC_lwp_cache[i].lc_id == id) {
-    	    (void)syscall(SYS_close, GC_lwp_cache[id].lc_descr);
-    	    GC_lwp_cache[i].lc_id = 0;
-    	    break;
-    	}
-    }
-}
-	/* Sequence of current lwp ids	*/
-static lwpid_t GC_current_ids_default[DEFAULT_MAX_LWPS + 1];
-static lwpid_t *GC_current_ids = GC_current_ids_default;
-
-	/* Temporary used below (can be big if large number of LWPs) */
-static lwpid_t last_ids_default[DEFAULT_MAX_LWPS + 1];
-static lwpid_t *last_ids = last_ids_default;
-
-
-#define ROUNDUP(n)    WORDS_TO_BYTES(ROUNDED_UP_WORDS(n))
-
-static void set_max_lwps(GC_word n)
-{
-    char *mem;
-    char *oldmem;
-    int required_bytes = ROUNDUP(n * sizeof(struct lwp_cache_entry))
-	+ ROUNDUP(n * sizeof(prgregset_t))
-	+ ROUNDUP((n + 1) * sizeof(lwpid_t))
-	+ ROUNDUP((n + 1) * sizeof(lwpid_t));
-
-    GC_expand_hp_inner(divHBLKSZ((word)required_bytes));
-    oldmem = mem = GC_scratch_alloc(required_bytes);
-    if (0 == mem) ABORT("No space for lwp data structures");
-
-    /*
-     * We can either flush the old lwp cache or copy it over. Do the latter.
-     */
-    memcpy(mem, GC_lwp_cache, max_lwps * sizeof(struct lwp_cache_entry));
-    GC_lwp_cache = (struct lwp_cache_entry*)mem;
-    mem += ROUNDUP(n * sizeof(struct lwp_cache_entry));
-
-    BZERO(GC_lwp_registers, max_lwps * sizeof(GC_lwp_registers[0]));
-    GC_lwp_registers = (prgregset_t *)mem;
-    mem += ROUNDUP(n * sizeof(prgregset_t));
-
-
-    GC_current_ids = (lwpid_t *)mem;
-    mem += ROUNDUP((n + 1) * sizeof(lwpid_t));
-
-    last_ids = (lwpid_t *)mem;
-    mem += ROUNDUP((n + 1)* sizeof(lwpid_t));
-
-    if (mem > oldmem + required_bytes)
-	ABORT("set_max_lwps buffer overflow");
-
-    max_lwps = n;
-}
-
-
-/* Stop all lwps in process.  Assumes preemption is off.	*/
-/* Caller has allocation lock (and any other locks he may	*/
-/* need).							*/
-static void stop_all_lwps()
-{
-    int lwp_fd;
-    char buf[30];
-    prstatus_t status;
-    register int i;
-    GC_bool changed;
-    lwpid_t me = _lwp_self();
-
-    if (GC_main_proc_fd == -1) {
-    	sprintf(buf, "/proc/%d", getpid());
-    	GC_main_proc_fd = syscall(SYS_open, buf, O_RDONLY);
-        if (GC_main_proc_fd < 0) {
-		if (errno == EMFILE)
-			ABORT("/proc open failed: too many open files");
-		GC_printf1("/proc open failed: errno %d", errno);
-		abort();
-        }
-    }
-    BZERO(GC_lwp_registers, sizeof (prgregset_t) * max_lwps);
-    for (i = 0; i < max_lwps; i++)
-	last_ids[i] = 0;
-    for (;;) {
-    if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCSTATUS, &status) < 0)
-    	ABORT("Main PIOCSTATUS failed");
-    	if (status.pr_nlwp < 1)
-    		ABORT("Invalid number of lwps returned by PIOCSTATUS");
-    	if (status.pr_nlwp >= max_lwps) {
-    		set_max_lwps(status.pr_nlwp*2 + 10);
-		/*
-		 * The data in the old GC_current_ids and
-		 * GC_lwp_registers has been trashed. Cleaning out last_ids
-		 * will make sure every LWP gets re-examined.
-		 */
-        	for (i = 0; i < max_lwps; i++)
-			last_ids[i] = 0;
-		continue;
-    }
-        if (syscall(SYS_ioctl, GC_main_proc_fd, PIOCLWPIDS, GC_current_ids) < 0)
-            ABORT("PIOCLWPIDS failed");
-        changed = FALSE;
-        for (i = 0; GC_current_ids[i] != 0 && i < max_lwps; i++) {
-            if (GC_current_ids[i] != last_ids[i]) {
-                changed = TRUE;
-                if (GC_current_ids[i] != me) {
-		    /* PIOCSTOP doesn't work without a writable		*/
-		    /* descriptor.  And that makes the process		*/
-		    /* undebuggable.					*/
-                    if (_lwp_suspend(GC_current_ids[i]) < 0) {
-                        /* Could happen if the lwp exited */
-                        uncache_lwp(GC_current_ids[i]);
-                        GC_current_ids[i] = me; /* ignore */
-                    }
-                }
-            }
-        }
-        /*
-         * In the unlikely event something does a fork between the
-	 * PIOCSTATUS and the PIOCLWPIDS. 
-         */
-        if (i >= max_lwps)
-		continue;
-        /* All lwps in GC_current_ids != me have been suspended.  Note	*/
-        /* that _lwp_suspend is idempotent.				*/
-        for (i = 0; GC_current_ids[i] != 0; i++) {
-            if (GC_current_ids[i] != last_ids[i]) {
-                if (GC_current_ids[i] != me) {
-                    lwp_fd = open_lwp(GC_current_ids[i]);
-		    if (lwp_fd == -1)
-		    {
-			    GC_current_ids[i] = me;
-			    continue;
-		    }
-		    /* LWP should be stopped.  Empirically it sometimes	*/
-		    /* isn't, and more frequently the PR_STOPPED flag	*/
-		    /* is not set.  Wait for PR_STOPPED.		*/
-                    if (syscall(SYS_ioctl, lwp_fd,
-                                PIOCSTATUS, &status) < 0) {
-			/* Possible if the descriptor was stale, or */
-			/* we encountered the 2.3 _lwp_suspend bug. */
-			uncache_lwp(GC_current_ids[i]);
-                        GC_current_ids[i] = me; /* handle next time. */
-                    } else {
-                        while (!(status.pr_flags & PR_STOPPED)) {
-                            GC_msec_sleep(1);
-			    if (syscall(SYS_ioctl, lwp_fd,
-				    	PIOCSTATUS, &status) < 0) {
-                            	ABORT("Repeated PIOCSTATUS failed");
-			    }
-			    if (status.pr_flags & PR_STOPPED) break;
-			    
-			    GC_msec_sleep(20);
-			    if (syscall(SYS_ioctl, lwp_fd,
-				    	PIOCSTATUS, &status) < 0) {
-                            	ABORT("Repeated PIOCSTATUS failed");
-			    }
-                        }
-                        if (status.pr_who !=  GC_current_ids[i]) {
-				/* can happen if thread was on death row */
-				uncache_lwp(GC_current_ids[i]);
-				GC_current_ids[i] = me; /* handle next time. */
-				continue;	
-                        }
-                        /* Save registers where collector can */
-			/* find them.			  */
-			    BCOPY(status.pr_reg, GC_lwp_registers[i],
-				  sizeof (prgregset_t));
-                    }
-                }
-            }
-        }
-        if (!changed) break;
-        for (i = 0; i < max_lwps; i++) last_ids[i] = GC_current_ids[i];
-    }
-}
-
-/* Restart all lwps in process.  Assumes preemption is off.	*/
-static void restart_all_lwps()
-{
-    int lwp_fd;
-    register int i;
-    GC_bool changed;
-    lwpid_t me = _lwp_self();
-#   define PARANOID
-
-    for (i = 0; GC_current_ids[i] != 0; i++) {
-#	ifdef PARANOID
-	  if (GC_current_ids[i] != me) {
-	    int lwp_fd = open_lwp(GC_current_ids[i]);
-	    prstatus_t status;
-	    
-	    if (lwp_fd < 0) ABORT("open_lwp failed");
-	    if (syscall(SYS_ioctl, lwp_fd,
-			PIOCSTATUS, &status) < 0) {
-                ABORT("PIOCSTATUS failed in restart_all_lwps");
-	    }
-	    if (memcmp(status.pr_reg, GC_lwp_registers[i],
-		       sizeof (prgregset_t)) != 0) {
-		    int j;
-
-		    for(j = 0; j < NPRGREG; j++)
-		    {
-			    GC_printf3("%i: %x -> %x\n", j,
-				       GC_lwp_registers[i][j],
-				       status.pr_reg[j]);
-		    }
-		ABORT("Register contents changed");
-	    }
-	    if (!status.pr_flags & PR_STOPPED) {
-	    	ABORT("lwp no longer stopped");
-	    }
-#ifdef SPARC
-	    {
-		    gwindows_t windows;
-	      if (syscall(SYS_ioctl, lwp_fd,
-			PIOCGWIN, &windows) < 0) {
-                ABORT("PIOCSTATUS failed in restart_all_lwps");
-	      }
-	      if (windows.wbcnt > 0) ABORT("unsaved register windows");
-	    }
-#endif
-	  }
-#	endif /* PARANOID */
-	if (GC_current_ids[i] == me) continue;
-        if (_lwp_continue(GC_current_ids[i]) < 0) {
-            ABORT("Failed to restart lwp");
-        }
-    }
-    if (i >= max_lwps) ABORT("Too many lwps");
-}
-
-GC_bool GC_multithreaded = 0;
-
-void GC_stop_world()
-{
-    preempt_off();
-    if (GC_multithreaded)
-        stop_all_lwps();
-}
-
-void GC_start_world()
-{
-    if (GC_multithreaded)
-        restart_all_lwps();
-    preempt_on();
-}
-
-void GC_thr_init(void);
-
-GC_bool GC_thr_initialized = FALSE;
-
-size_t GC_min_stack_sz;
-
-
-/*
- * stack_head is stored at the top of free stacks
- */
-struct stack_head {
-	struct stack_head	*next;
-	ptr_t			base;
-	thread_t		owner;
-};
-
-# define N_FREE_LISTS 25
-struct stack_head *GC_stack_free_lists[N_FREE_LISTS] = { 0 };
-		/* GC_stack_free_lists[i] is free list for stacks of 	*/
-		/* size GC_min_stack_sz*2**i.				*/
-		/* Free lists are linked through stack_head stored	*/			/* at top of stack.					*/
-
-/* Return a stack of size at least *stack_size.  *stack_size is	*/
-/* replaced by the actual stack size.				*/
-/* Caller holds allocation lock.				*/
-ptr_t GC_stack_alloc(size_t * stack_size)
-{
-    register size_t requested_sz = *stack_size;
-    register size_t search_sz = GC_min_stack_sz;
-    register int index = 0;	/* = log2(search_sz/GC_min_stack_sz) */
-    register ptr_t base;
-    register struct stack_head *result;
-    
-    while (search_sz < requested_sz) {
-        search_sz *= 2;
-        index++;
-    }
-    if ((result = GC_stack_free_lists[index]) == 0
-        && (result = GC_stack_free_lists[index+1]) != 0) {
-        /* Try next size up. */
-        search_sz *= 2; index++;
-    }
-    if (result != 0) {
-        base =  GC_stack_free_lists[index]->base;
-        GC_stack_free_lists[index] = GC_stack_free_lists[index]->next;
-    } else {
-#ifdef MMAP_STACKS
-        base = (ptr_t)mmap(0, search_sz + GC_page_size,
-			     PROT_READ|PROT_WRITE, MAP_PRIVATE |MAP_NORESERVE,
-			     GC_zfd, 0);
-	if (base == (ptr_t)-1)
-	{
-		*stack_size = 0;
-		return NULL;
-	}
-
-	mprotect(base, GC_page_size, PROT_NONE);
-	/* Should this use divHBLKSZ(search_sz + GC_page_size) ? -- cf */
-	GC_is_fresh((struct hblk *)base, divHBLKSZ(search_sz));
-	base += GC_page_size;
-
-#else
-        base = (ptr_t) GC_scratch_alloc(search_sz + 2*GC_page_size);
-	if (base == NULL)
-	{
-		*stack_size = 0;
-		return NULL;
-	}
-
-        base = (ptr_t)(((word)base + GC_page_size) & ~(GC_page_size - 1));
-        /* Protect hottest page to detect overflow. */
-#	ifdef SOLARIS23_MPROTECT_BUG_FIXED
-            mprotect(base, GC_page_size, PROT_NONE);
-#	endif
-        GC_is_fresh((struct hblk *)base, divHBLKSZ(search_sz));
-
-        base += GC_page_size;
-#endif
-    }
-    *stack_size = search_sz;
-    return(base);
-}
-
-/* Caller holds  allocationlock.					*/
-void GC_stack_free(ptr_t stack, size_t size)
-{
-    register int index = 0;
-    register size_t search_sz = GC_min_stack_sz;
-    register struct stack_head *head;
-    
-#ifdef MMAP_STACKS
-    /* Zero pointers */
-    mmap(stack, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_NORESERVE|MAP_FIXED,
-	 GC_zfd, 0);
-#endif
-    while (search_sz < size) {
-        search_sz *= 2;
-        index++;
-    }
-    if (search_sz != size) ABORT("Bad stack size");
-
-    head = (struct stack_head *)(stack + search_sz - sizeof(struct stack_head));
-    head->next = GC_stack_free_lists[index];
-    head->base = stack;
-    GC_stack_free_lists[index] = head;
-}
-
-void GC_my_stack_limits();
-
-/* Notify virtual dirty bit implementation that known empty parts of	*/
-/* stacks do not contain useful data.					*/ 
-/* Caller holds allocation lock.					*/
-void GC_old_stacks_are_fresh()
-{
-/* No point in doing this for MMAP stacks - and pointers are zero'd out */
-/* by the mmap in GC_stack_free */
-#ifndef MMAP_STACKS
-    register int i;
-    register struct stack_head *s;
-    register ptr_t p;
-    register size_t sz;
-    register struct hblk * h;
-    int dummy;
-    
-    for (i = 0, sz= GC_min_stack_sz; i < N_FREE_LISTS;
-         i++, sz *= 2) {
-         for (s = GC_stack_free_lists[i]; s != 0; s = s->next) {
-             p = s->base;
-             h = (struct hblk *)(((word)p + HBLKSIZE-1) & ~(HBLKSIZE-1));
-             if ((ptr_t)h == p) {
-                 GC_is_fresh((struct hblk *)p, divHBLKSZ(sz));
-             } else {
-                 GC_is_fresh((struct hblk *)p, divHBLKSZ(sz) - 1);
-                 BZERO(p, (ptr_t)h - p);
-             }
-         }
-    }
-#endif /* MMAP_STACKS */
-    GC_my_stack_limits();
-}
-
-/* The set of all known threads.  We intercept thread creation and 	*/
-/* joins.  We never actually create detached threads.  We allocate all 	*/
-/* new thread stacks ourselves.  These allow us to maintain this	*/
-/* data structure.							*/
-
-# define THREAD_TABLE_SZ 128	/* Must be power of 2	*/
-volatile GC_thread GC_threads[THREAD_TABLE_SZ];
-
-void GC_push_thread_structures GC_PROTO((void))
-{
-    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));
-}
-
-/* Add a thread to GC_threads.  We assume it wasn't already there.	*/
-/* Caller holds allocation lock.					*/
-GC_thread GC_new_thread(thread_t id)
-{
-    int hv = ((word)id) % THREAD_TABLE_SZ;
-    GC_thread result;
-    static struct GC_Thread_Rep first_thread;
-    static GC_bool first_thread_used = FALSE;
-    
-    if (!first_thread_used) {
-    	result = &first_thread;
-    	first_thread_used = TRUE;
-    	/* Dont acquire allocation lock, since we may already hold it. */
-    } else {
-        result = (struct GC_Thread_Rep *)
-        	 GC_INTERNAL_MALLOC(sizeof(struct GC_Thread_Rep), NORMAL);
-    }
-    if (result == 0) return(0);
-    result -> id = id;
-    result -> next = GC_threads[hv];
-    GC_threads[hv] = result;
-    /* result -> finished = 0; */
-    (void) cond_init(&(result->join_cv), USYNC_THREAD, 0);
-    return(result);
-}
-
-/* Delete a thread from GC_threads.  We assume it is there.	*/
-/* (The code intentionally traps if it wasn't.)			*/
-/* Caller holds allocation lock.				*/
-void GC_delete_thread(thread_t id)
-{
-    int hv = ((word)id) % THREAD_TABLE_SZ;
-    register GC_thread p = GC_threads[hv];
-    register GC_thread prev = 0;
-    
-    while (p -> id != id) {
-        prev = p;
-        p = p -> next;
-    }
-    if (prev == 0) {
-        GC_threads[hv] = p -> next;
-    } else {
-        prev -> next = p -> next;
-    }
-}
-
-/* Return the GC_thread correpsonding to a given thread_t.	*/
-/* Returns 0 if it's not there.					*/
-/* Caller holds  allocation lock.				*/
-GC_thread GC_lookup_thread(thread_t id)
-{
-    int hv = ((word)id) % THREAD_TABLE_SZ;
-    register GC_thread p = GC_threads[hv];
-    
-    while (p != 0 && p -> id != id) p = p -> next;
-    return(p);
-}
-
-/* Solaris 2/Intel uses an initial stack size limit slightly bigger than the
-   SPARC default of 8 MB.  Account for this to warn only if the user has
-   raised the limit beyond the default.
-
-   This is identical to DFLSSIZ defined in <sys/vm_machparam.h>.  This file
-   is installed in /usr/platform/`uname -m`/include, which is not in the
-   default include directory list, so copy the definition here.  */
-#ifdef I386
-# define MAX_ORIG_STACK_SIZE (8 * 1024 * 1024 + ((USRSTACK) & 0x3FFFFF))
-#else
-# define MAX_ORIG_STACK_SIZE (8 * 1024 * 1024)
-#endif
-
-word GC_get_orig_stack_size() {
-    struct rlimit rl;
-    static int warned = 0;
-    int result;
-
-    if (getrlimit(RLIMIT_STACK, &rl) != 0) ABORT("getrlimit failed");
-    result = (word)rl.rlim_cur & ~(HBLKSIZE-1);
-    if (result > MAX_ORIG_STACK_SIZE) {
-	if (!warned) {
-	    WARN("Large stack limit(%ld): only scanning 8 MB\n", result);
-	    warned = 1;
-	}
-	result = MAX_ORIG_STACK_SIZE;
-    }
-    return result;
-}
-
-/* Notify dirty bit implementation of unused parts of my stack. */
-/* Caller holds allocation lock.				*/
-void GC_my_stack_limits()
-{
-    int dummy;
-    register ptr_t hottest = (ptr_t)((word)(&dummy) & ~(HBLKSIZE-1));
-    register GC_thread me = GC_lookup_thread(thr_self());
-    register size_t stack_size = me -> stack_size;
-    register ptr_t stack;
-    
-    if (stack_size == 0) {
-      /* original thread */
-        /* Empirically, what should be the stack page with lowest	*/
-        /* address is actually inaccessible.				*/
-        stack_size = GC_get_orig_stack_size() - GC_page_size;
-        stack = GC_stackbottom - stack_size + GC_page_size;
-    } else {
-        stack = me -> stack;
-    }
-    if (stack > hottest || stack + stack_size < hottest) {
-    	ABORT("sp out of bounds");
-    }
-    GC_is_fresh((struct hblk *)stack, divHBLKSZ(hottest - stack));
-}
-
-
-/* We hold allocation lock.  Should do exactly the right thing if the	*/
-/* world is stopped.  Should not fail if it isn't.			*/
-void GC_push_all_stacks()
-{
-    register int i;
-    register GC_thread p;
-    register ptr_t sp = GC_approx_sp();
-    register ptr_t bottom, top;
-    struct rlimit rl;
-    
-#   define PUSH(bottom,top) \
-      if (GC_dirty_maintained) { \
-	GC_push_selected((bottom), (top), GC_page_was_ever_dirty, \
-		      GC_push_all_stack); \
-      } else { \
-        GC_push_all_stack((bottom), (top)); \
-      }
-    GC_push_all_stack((ptr_t)GC_lwp_registers,
-		      (ptr_t)GC_lwp_registers
-		      + max_lwps * sizeof(GC_lwp_registers[0]));
-    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-      for (p = GC_threads[i]; p != 0; p = p -> next) {
-        if (p -> stack_size != 0) {
-            bottom = p -> stack;
-            top = p -> stack + p -> stack_size;
-        } else {
-            /* The original stack. */
-            bottom = GC_stackbottom - GC_get_orig_stack_size() + GC_page_size;
-            top = GC_stackbottom;
-        }
-        if ((word)sp > (word)bottom && (word)sp < (word)top) bottom = sp;
-        PUSH(bottom, top);
-      }
-    }
-}
-
-
-int GC_is_thread_stack(ptr_t addr)
-{
-    register int i;
-    register GC_thread p;
-    register ptr_t bottom, top;
-    
-    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-      for (p = GC_threads[i]; p != 0; p = p -> next) {
-        if (p -> stack_size != 0) {
-            if (p -> stack <= addr &&
-		addr < p -> stack + p -> stack_size)
-		    return 1;
-	}
-      }
-    }
-    return 0;
-}
-
-/* The only thread that ever really performs a thr_join.	*/
-void * GC_thr_daemon(void * dummy)
-{
-    void *status;
-    thread_t departed;
-    register GC_thread t;
-    register int i;
-    register int result;
-    
-    for(;;) {
-      start:
-        result = thr_join((thread_t)0, &departed, &status);
-    	LOCK();
-    	if (result != 0) {
-    	    /* No more threads; wait for create. */
-    	    for (i = 0; i < THREAD_TABLE_SZ; i++) {
-    	        for (t = GC_threads[i]; t != 0; t = t -> next) {
-                    if (!(t -> flags & (DETACHED | FINISHED))) {
-                      UNLOCK();
-                      goto start; /* Thread started just before we */
-                      		  /* acquired the lock.		   */
-                    }
-                }
-            }
-            cond_wait(&GC_create_cv, &GC_allocate_ml);
-            UNLOCK();
-    	} else {
-    	    t = GC_lookup_thread(departed);
-	    GC_multithreaded--;
-    	    if (!(t -> flags & CLIENT_OWNS_STACK)) {
-    	    	GC_stack_free(t -> stack, t -> stack_size);
-    	    }
-    	    if (t -> flags & DETACHED) {
-    	    	GC_delete_thread(departed);
-    	    } else {
-    	        t -> status = status;
-    	    	t -> flags |= FINISHED;
-    	    	cond_signal(&(t -> join_cv));
-    	    	cond_broadcast(&GC_prom_join_cv);
-    	    }
-    	    UNLOCK();
-    	}
-    }
-}
-
-/* We hold the allocation lock, or caller ensures that 2 instances	*/
-/* cannot be invoked concurrently.					*/
-void GC_thr_init(void)
-{
-    GC_thread t;
-    thread_t tid;
-    int ret;
-
-    if (GC_thr_initialized)
-	    return;
-    GC_thr_initialized = TRUE;
-    GC_min_stack_sz = ((thr_min_stack() + 32*1024 + HBLKSIZE-1)
-    		       & ~(HBLKSIZE - 1));
-#ifdef MMAP_STACKS
-    GC_zfd = open("/dev/zero", O_RDONLY);
-    if (GC_zfd == -1)
-	    ABORT("Can't open /dev/zero");
-#endif /* MMAP_STACKS */
-    cond_init(&GC_prom_join_cv, USYNC_THREAD, 0);
-    cond_init(&GC_create_cv, USYNC_THREAD, 0);
-    /* Add the initial thread, so we can stop it.	*/
-      t = GC_new_thread(thr_self());
-      t -> stack_size = 0;
-      t -> flags = DETACHED | CLIENT_OWNS_STACK;
-    ret = thr_create(0 /* stack */, 0 /* stack_size */, GC_thr_daemon,
-    		     0 /* arg */, THR_DETACHED | THR_DAEMON,
-    		     &tid /* thread_id */);
-    if (ret != 0) {
-	GC_err_printf1("Thr_create returned %ld\n", ret);
-    	ABORT("Cant fork daemon");
-    }
-    thr_setprio(tid, 126);
-}
-
-/* We acquire the allocation lock to prevent races with 	*/
-/* stopping/starting world.					*/
-/* This is no more correct than the underlying Solaris 2.X	*/
-/* implementation.  Under 2.3 THIS IS BROKEN.			*/
-int GC_thr_suspend(thread_t target_thread)
-{
-    GC_thread t;
-    int result;
-    
-    LOCK();
-    result = thr_suspend(target_thread);
-    if (result == 0) {
-    	t = GC_lookup_thread(target_thread);
-    	if (t == 0) ABORT("thread unknown to GC");
-        t -> flags |= SUSPNDED;
-    }
-    UNLOCK();
-    return(result);
-}
-
-int GC_thr_continue(thread_t target_thread)
-{
-    GC_thread t;
-    int result;
-    
-    LOCK();
-    result = thr_continue(target_thread);
-    if (result == 0) {
-    	t = GC_lookup_thread(target_thread);
-    	if (t == 0) ABORT("thread unknown to GC");
-        t -> flags &= ~SUSPNDED;
-    }
-    UNLOCK();
-    return(result);
-}
-
-int GC_thr_join(thread_t wait_for, thread_t *departed, void **status)
-{
-    register GC_thread t;
-    int result = 0;
-    
-    LOCK();
-    if (wait_for == 0) {
-        register int i;
-        register GC_bool thread_exists;
-    
-    	for (;;) {
-    	  thread_exists = FALSE;
-    	  for (i = 0; i < THREAD_TABLE_SZ; i++) {
-    	    for (t = GC_threads[i]; t != 0; t = t -> next) {
-              if (!(t -> flags & DETACHED)) {
-                if (t -> flags & FINISHED) {
-                  goto found;
-                }
-                thread_exists = TRUE;
-              }
-            }
-          }
-          if (!thread_exists) {
-              result = ESRCH;
-    	      goto out;
-          }
-          cond_wait(&GC_prom_join_cv, &GC_allocate_ml);
-        }
-    } else {
-        t = GC_lookup_thread(wait_for);
-    	if (t == 0 || t -> flags & DETACHED) {
-    	    result = ESRCH;
-    	    goto out;
-    	}
-    	if (wait_for == thr_self()) {
-    	    result = EDEADLK;
-    	    goto out;
-    	}
-    	while (!(t -> flags & FINISHED)) {
-            cond_wait(&(t -> join_cv), &GC_allocate_ml);
-    	}
-    	
-    }
-  found:
-    if (status) *status = t -> status;
-    if (departed) *departed = t -> id;
-    cond_destroy(&(t -> join_cv));
-    GC_delete_thread(t -> id);
-  out:
-    UNLOCK();
-    return(result);
-}
-
-
-int
-GC_thr_create(void *stack_base, size_t stack_size,
-              void *(*start_routine)(void *), void *arg, long flags,
-              thread_t *new_thread)
-{
-    int result;
-    GC_thread t;
-    thread_t my_new_thread;
-    word my_flags = 0;
-    void * stack = stack_base;
-   
-    LOCK();
-    if (!GC_is_initialized) GC_init_inner();
-    GC_multithreaded++;
-    if (stack == 0) {
-     	if (stack_size == 0) stack_size = 1024*1024;
-     	stack = (void *)GC_stack_alloc(&stack_size);
-     	if (stack == 0) {
-	    GC_multithreaded--;
-     	    UNLOCK();
-     	    return(ENOMEM);
-     	}
-    } else {
-    	my_flags |= CLIENT_OWNS_STACK;
-    }
-    if (flags & THR_DETACHED) my_flags |= DETACHED;
-    if (flags & THR_SUSPENDED) my_flags |= SUSPNDED;
-    result = thr_create(stack, stack_size, start_routine,
-   		        arg, flags & ~THR_DETACHED, &my_new_thread);
-    if (result == 0) {
-        t = GC_new_thread(my_new_thread);
-        t -> flags = my_flags;
-        if (!(my_flags & DETACHED)) cond_init(&(t -> join_cv), USYNC_THREAD, 0);
-        t -> stack = stack;
-        t -> stack_size = stack_size;
-        if (new_thread != 0) *new_thread = my_new_thread;
-        cond_signal(&GC_create_cv);
-    } else {
-	GC_multithreaded--;
-        if (!(my_flags & CLIENT_OWNS_STACK)) {
-      	    GC_stack_free(stack, stack_size);
-	}
-    }        
-    UNLOCK();  
-    return(result);
-}
-
-# else /* !GC_SOLARIS_THREADS */
-
-#ifndef LINT
-  int GC_no_sunOS_threads;
-#endif
-#endif
diff --git a/compile b/compile
old mode 100644
new mode 100755
diff --git a/configure b/configure
index 1afdeb4f237..72eb1118cf2 100755
--- a/configure
+++ b/configure
@@ -3549,7 +3549,7 @@ case " $build_configdirs " in
     # For an installed makeinfo, we require it to be from texinfo 4.2 or
     # higher, else we use the "missing" dummy.
     if ${MAKEINFO} --version \
-       | egrep 'texinfo[^0-9]*([1-3][0-9]|4\.[2-9]|[5-9])' >/dev/null 2>&1; then
+       | egrep 'texinfo[^0-9]*(4\.([2-9]|[1-9][0-9])|[5-9]|[1-9][0-9])' >/dev/null 2>&1; then
       :
     else
       MAKEINFO="$MISSING makeinfo"
diff --git a/configure.in b/configure.in
index 7e77b86162a..6179fb7f550 100644
--- a/configure.in
+++ b/configure.in
@@ -2134,7 +2134,7 @@ changequote(,)
     # For an installed makeinfo, we require it to be from texinfo 4.2 or
     # higher, else we use the "missing" dummy.
     if ${MAKEINFO} --version \
-       | egrep 'texinfo[^0-9]*([1-3][0-9]|4\.[2-9]|[5-9])' >/dev/null 2>&1; then
+       | egrep 'texinfo[^0-9]*(4\.([2-9]|[1-9][0-9])|[5-9]|[1-9][0-9])' >/dev/null 2>&1; then
       :
     else
       MAKEINFO="$MISSING makeinfo"
diff --git a/fixincludes/ChangeLog b/fixincludes/ChangeLog
index 42eaa1e011d..b3fe5e6e26a 100644
--- a/fixincludes/ChangeLog
+++ b/fixincludes/ChangeLog
@@ -1,3 +1,25 @@
+2008-03-17  Dave Korn  <dave.korn@artimi.com>
+
+	* fixincl.x: Revert last change, restoring GPLv2 status.
+
+2008-02-04  Ismail Dönmez  <ismail@pardus.org.tr>
+
+	* inclhack.def: (bsd_stdio_attrs_conflict, freebsd_gcc3_breakage,
+	freebsd_gcc4_breakage, hpux11_abs, netbsd_extra_semicolon):  Add
+	quotes around mach entries.
+	* fixincl.x: Regenerate with latest autogen (5.9.4), updating license
+	to GPLv3.
+
+2007-07-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	PR target/32641
+
+	* inclhack.def (solaris_math_4, solaris_math_5, solaris_math_6,
+	solaris_math_7): Constify and make FP exception-safe.
+	* tests/base/iso/math_c99.h: Update.
+
+	* fixincl.x: Regenerate.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/fixincludes/fixincl.x b/fixincludes/fixincl.x
index ef4fb90e208..5eaad7edfb8 100644
--- a/fixincludes/fixincl.x
+++ b/fixincludes/fixincl.x
@@ -2,11 +2,11 @@
  * 
  * DO NOT EDIT THIS FILE   (fixincl.x)
  * 
- * It has been AutoGen-ed  Thursday November  2, 2006 at 04:07:02 PM PST
+ * It has been AutoGen-ed  Thursday July  5, 2007 at 01:42:35 PM EDT
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT CVS-MERGE THIS FILE, EITHER Thu Nov  2 16:07:02 PST 2006
+/* DO NOT CVS-MERGE THIS FILE, EITHER Thu Jul  5 13:42:35 EDT 2007
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -5289,7 +5289,7 @@ static tTestDesc aSolaris_Math_4Tests[] = {
 static const char* apzSolaris_Math_4Patch[] = {
     "format",
     "#define\tfpclassify(x) \\\n\
-  __extension__ ({ __typeof(x) __x_fp = (x); \\\n\
+  __extension__ ({ const __typeof(x) __x_fp = (x); \\\n\
 \t\t   isnan(__x_fp) \\\n\
 \t\t     ? FP_NAN \\\n\
 \t\t     : isinf(__x_fp) \\\n\
@@ -5342,8 +5342,12 @@ static tTestDesc aSolaris_Math_5Tests[] = {
 static const char* apzSolaris_Math_5Patch[] = {
     "format",
     "#define\tisfinite(x) \\\n\
-  __extension__ ({ __typeof (x) __x_f = (x); \\\n\
-\t\t   __builtin_expect(!isnan(__x_f - __x_f), 1); })",
+  __extension__ ({ const __typeof (x) __x_f = (x); \\\n\
+\t\t    __builtin_expect(sizeof(__x_f) == sizeof(float) \\\n\
+\t\t\t  ? islessequal(__builtin_fabsf(__x_f),__FLT_MAX__) \\\n\
+\t\t\t  : sizeof(__x_f) == sizeof(long double) \\\n\
+\t\t\t    ? islessequal(__builtin_fabsl(__x_f),__LDBL_MAX__) \\\n\
+\t\t\t    : islessequal(__builtin_fabs(__x_f),__DBL_MAX__), 1); })",
     "^#define[ \t]+isfinite\\(x\\)[ \t]+__builtin_isfinite\\(x\\)",
     (char*)NULL };
 
@@ -5387,8 +5391,12 @@ static tTestDesc aSolaris_Math_6Tests[] = {
 static const char* apzSolaris_Math_6Patch[] = {
     "format",
     "#define\tisinf(x) \\\n\
-  __extension__ ({ __typeof (x) __x_i = (x); \\\n\
-\t\t   __builtin_expect(!isnan(__x_i) && !isfinite(__x_i), 0); })",
+  __extension__ ({ const __typeof (x) __x_i = (x); \\\n\
+\t\t    __builtin_expect(sizeof(__x_i) == sizeof(float) \\\n\
+\t\t\t  ? isgreater(__builtin_fabsf(__x_i),__FLT_MAX__) \\\n\
+\t\t\t  : sizeof(__x_i) == sizeof(long double) \\\n\
+\t\t\t    ? isgreater(__builtin_fabsl(__x_i),__LDBL_MAX__) \\\n\
+\t\t\t    : isgreater(__builtin_fabs(__x_i),__DBL_MAX__), 0); })",
     "^#define[ \t]+isinf\\(x\\)[ \t]+__builtin_isinf\\(x\\)",
     (char*)NULL };
 
@@ -5432,14 +5440,13 @@ static tTestDesc aSolaris_Math_7Tests[] = {
 static const char* apzSolaris_Math_7Patch[] = {
     "format",
     "#define\tisnormal(x) \\\n\
-  __extension__ ({ __typeof(x) __x_n = (x); \\\n\
-\t\t   if (__x_n < 0.0) __x_n = -__x_n; \\\n\
+  __extension__ ({ const __typeof(x) __x_n = (x); \\\n\
 \t\t   __builtin_expect(isfinite(__x_n) \\\n\
 \t\t\t\t    && (sizeof(__x_n) == sizeof(float) \\\n\
-\t\t\t\t\t  ? __x_n >= __FLT_MIN__ \\\n\
+\t\t\t\t\t  ? isgreaterequal(__builtin_fabsf(__x_n),__FLT_MIN__) \\\n\
 \t\t\t\t\t  : sizeof(__x_n) == sizeof(long double) \\\n\
-\t\t\t\t\t    ? __x_n >= __LDBL_MIN__ \\\n\
-\t\t\t\t\t    : __x_n >= __DBL_MIN__), 1); })",
+\t\t\t\t\t    ? isgreaterequal(__builtin_fabsl(__x_n),__LDBL_MIN__) \\\n\
+\t\t\t\t\t    : isgreaterequal(__builtin_fabs(__x_n),__DBL_MIN__)), 1); })",
     "^#define[ \t]+isnormal\\(x\\)[ \t]+__builtin_isnormal\\(x\\)",
     (char*)NULL };
 
diff --git a/fixincludes/inclhack.def b/fixincludes/inclhack.def
index adafcbba1ae..c72c787973a 100644
--- a/fixincludes/inclhack.def
+++ b/fixincludes/inclhack.def
@@ -1050,8 +1050,8 @@ fix = {
  */
 fix = {
     hackname  = bsd_stdio_attrs_conflict;
-    mach      = *-*-*bsd*;
-    mach      = *-*-*darwin*;
+    mach      = "*-*-*bsd*";
+    mach      = "*-*-*darwin*";
     files     = stdio.h;
     select    = "^#define[ \t]*vfscanf[ \t]*__svfscanf[ \t]*$";
     c_fix     = format;
@@ -1242,7 +1242,7 @@ fix = {
  */
 fix = {
     hackname  = freebsd_gcc3_breakage;
-    mach      = *-*-freebsd*;
+    mach      = "*-*-freebsd*";
     files     = sys/cdefs.h;
     select    = '^#if __GNUC__ == 2 && __GNUC_MINOR__ >= 7$';
     bypass    = '__GNUC__[ \t]*([>=]=[ \t]*[3-9]|>[ \t]*2)';
@@ -1259,7 +1259,7 @@ fix = {
  */
 fix = {
     hackname  = freebsd_gcc4_breakage;
-    mach      = *-*-freebsd*; 
+    mach      = "*-*-freebsd*"; 
     files     = sys/cdefs.h;
     select    = '^#if __GNUC__ == 2 && __GNUC_MINOR__ >= 7 \|\| __GNUC__ == 3$';
     c_fix     = format;
@@ -1534,7 +1534,7 @@ fix = {
  */
 fix = {
     hackname  = hpux11_abs;
-    mach      = ia64-hp-hpux11*;
+    mach      = "ia64-hp-hpux11*";
     files     = stdlib.h;
     select    = "ifndef _MATH_INCLUDED";
     c_fix     = format;
@@ -2450,7 +2450,7 @@ fix = {
  */
 fix = {
     hackname  = netbsd_extra_semicolon;
-    mach      = *-*-netbsd*;
+    mach      = "*-*-netbsd*";
     files     = sys/cdefs.h;
     select    = "#define[ \t]*__END_DECLS[ \t]*};";
 
@@ -2932,7 +2932,7 @@ fix = {
     files = iso/math_c99.h;
     c_fix = format;
     c_fix_arg = "#define\tfpclassify(x) \\\n"
-                "  __extension__ ({ __typeof(x) __x_fp = (x); \\\n"
+                "  __extension__ ({ const __typeof(x) __x_fp = (x); \\\n"
                 "\t\t   isnan(__x_fp) \\\n"
                 "\t\t     ? FP_NAN \\\n"
                 "\t\t     : isinf(__x_fp) \\\n"
@@ -2956,8 +2956,12 @@ fix = {
     files = iso/math_c99.h;
     c_fix = format;
     c_fix_arg = "#define\tisfinite(x) \\\n"
-                "  __extension__ ({ __typeof (x) __x_f = (x); \\\n"
-                "\t\t   __builtin_expect(!isnan(__x_f - __x_f), 1); })";
+                "  __extension__ ({ const __typeof (x) __x_f = (x); \\\n"
+                "\t\t    __builtin_expect(sizeof(__x_f) == sizeof(float) \\\n"
+                "\t\t\t  ? islessequal(__builtin_fabsf(__x_f),__FLT_MAX__) \\\n"
+                "\t\t\t  : sizeof(__x_f) == sizeof(long double) \\\n"
+                "\t\t\t    ? islessequal(__builtin_fabsl(__x_f),__LDBL_MAX__) \\\n"
+                "\t\t\t    : islessequal(__builtin_fabs(__x_f),__DBL_MAX__), 1); })";
     c_fix_arg = "^#define[ \t]+isfinite\\(x\\)[ \t]+__builtin_isfinite\\(x\\)";
     test_text =
     '#ident	"@(#)math_c99.h	1.9	04/11/01 SMI"'"\n"
@@ -2972,8 +2976,12 @@ fix = {
     files = iso/math_c99.h;
     c_fix = format;
     c_fix_arg = "#define\tisinf(x) \\\n"
-                "  __extension__ ({ __typeof (x) __x_i = (x); \\\n"
-                "\t\t   __builtin_expect(!isnan(__x_i) && !isfinite(__x_i), 0); })";
+                "  __extension__ ({ const __typeof (x) __x_i = (x); \\\n"
+                "\t\t    __builtin_expect(sizeof(__x_i) == sizeof(float) \\\n"
+                "\t\t\t  ? isgreater(__builtin_fabsf(__x_i),__FLT_MAX__) \\\n"
+                "\t\t\t  : sizeof(__x_i) == sizeof(long double) \\\n"
+                "\t\t\t    ? isgreater(__builtin_fabsl(__x_i),__LDBL_MAX__) \\\n"
+                "\t\t\t    : isgreater(__builtin_fabs(__x_i),__DBL_MAX__), 0); })";
     c_fix_arg = "^#define[ \t]+isinf\\(x\\)[ \t]+__builtin_isinf\\(x\\)";
     test_text =
     '#ident	"@(#)math_c99.h	1.9	04/11/01 SMI"'"\n"
@@ -2988,14 +2996,13 @@ fix = {
     files = iso/math_c99.h;
     c_fix = format;
     c_fix_arg = "#define\tisnormal(x) \\\n"
-                "  __extension__ ({ __typeof(x) __x_n = (x); \\\n"
-                "\t\t   if (__x_n < 0.0) __x_n = -__x_n; \\\n"
+                "  __extension__ ({ const __typeof(x) __x_n = (x); \\\n"
                 "\t\t   __builtin_expect(isfinite(__x_n) \\\n"
                 "\t\t\t\t    && (sizeof(__x_n) == sizeof(float) \\\n"
-                "\t\t\t\t\t  ? __x_n >= __FLT_MIN__ \\\n"
+                "\t\t\t\t\t  ? isgreaterequal(__builtin_fabsf(__x_n),__FLT_MIN__) \\\n"
                 "\t\t\t\t\t  : sizeof(__x_n) == sizeof(long double) \\\n"
-                "\t\t\t\t\t    ? __x_n >= __LDBL_MIN__ \\\n"
-                "\t\t\t\t\t    : __x_n >= __DBL_MIN__), 1); })";
+                "\t\t\t\t\t    ? isgreaterequal(__builtin_fabsl(__x_n),__LDBL_MIN__) \\\n"
+                "\t\t\t\t\t    : isgreaterequal(__builtin_fabs(__x_n),__DBL_MIN__)), 1); })";
     c_fix_arg = "^#define[ \t]+isnormal\\(x\\)[ \t]+__builtin_isnormal\\(x\\)";
     test_text =
     '#ident	"@(#)math_c99.h	1.9	04/11/01 SMI"'"\n"
diff --git a/fixincludes/tests/base/iso/math_c99.h b/fixincludes/tests/base/iso/math_c99.h
index 86b6c20504f..bc2b653424d 100644
--- a/fixincludes/tests/base/iso/math_c99.h
+++ b/fixincludes/tests/base/iso/math_c99.h
@@ -38,7 +38,7 @@
 #ident	"@(#)math_c99.h	1.9	04/11/01 SMI"
 #undef	fpclassify
 #define	fpclassify(x) \
-  __extension__ ({ __typeof(x) __x_fp = (x); \
+  __extension__ ({ const __typeof(x) __x_fp = (x); \
 		   isnan(__x_fp) \
 		     ? FP_NAN \
 		     : isinf(__x_fp) \
@@ -55,8 +55,12 @@
 #ident	"@(#)math_c99.h	1.9	04/11/01 SMI"
 #undef	isfinite
 #define	isfinite(x) \
-  __extension__ ({ __typeof (x) __x_f = (x); \
-		   __builtin_expect(!isnan(__x_f - __x_f), 1); })
+  __extension__ ({ const __typeof (x) __x_f = (x); \
+		    __builtin_expect(sizeof(__x_f) == sizeof(float) \
+			  ? islessequal(__builtin_fabsf(__x_f),__FLT_MAX__) \
+			  : sizeof(__x_f) == sizeof(long double) \
+			    ? islessequal(__builtin_fabsl(__x_f),__LDBL_MAX__) \
+			    : islessequal(__builtin_fabs(__x_f),__DBL_MAX__), 1); })
 #endif  /* SOLARIS_MATH_5_CHECK */
 
 
@@ -64,8 +68,12 @@
 #ident	"@(#)math_c99.h	1.9	04/11/01 SMI"
 #undef	isinf
 #define	isinf(x) \
-  __extension__ ({ __typeof (x) __x_i = (x); \
-		   __builtin_expect(!isnan(__x_i) && !isfinite(__x_i), 0); })
+  __extension__ ({ const __typeof (x) __x_i = (x); \
+		    __builtin_expect(sizeof(__x_i) == sizeof(float) \
+			  ? isgreater(__builtin_fabsf(__x_i),__FLT_MAX__) \
+			  : sizeof(__x_i) == sizeof(long double) \
+			    ? isgreater(__builtin_fabsl(__x_i),__LDBL_MAX__) \
+			    : isgreater(__builtin_fabs(__x_i),__DBL_MAX__), 0); })
 #endif  /* SOLARIS_MATH_6_CHECK */
 
 
@@ -73,14 +81,13 @@
 #ident	"@(#)math_c99.h	1.9	04/11/01 SMI"
 #undef	isnormal
 #define	isnormal(x) \
-  __extension__ ({ __typeof(x) __x_n = (x); \
-		   if (__x_n < 0.0) __x_n = -__x_n; \
+  __extension__ ({ const __typeof(x) __x_n = (x); \
 		   __builtin_expect(isfinite(__x_n) \
 				    && (sizeof(__x_n) == sizeof(float) \
-					  ? __x_n >= __FLT_MIN__ \
+					  ? isgreaterequal(__builtin_fabsf(__x_n),__FLT_MIN__) \
 					  : sizeof(__x_n) == sizeof(long double) \
-					    ? __x_n >= __LDBL_MIN__ \
-					    : __x_n >= __DBL_MIN__), 1); })
+					    ? isgreaterequal(__builtin_fabsl(__x_n),__LDBL_MIN__) \
+					    : isgreaterequal(__builtin_fabs(__x_n),__DBL_MIN__)), 1); })
 #endif  /* SOLARIS_MATH_7_CHECK */
 
 
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 97ec80c27b1..13992a005d4 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,940 @@
+2009-01-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/linux.h (DBX_REGISTER_NUMBER): Delete.
+	* config/sparc/linux64.h (DBX_REGISTER_NUMBER): Likewise.
+	* config/sparc/sysv4.h (DBX_REGISTER_NUMBER): Likewise.
+
+2008-11-30  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/38287
+	* config/sparc/sparc.md (divsi3 expander): Remove constraints.
+	(divsi3_sp32): Add new alternative with 'K' for operand #2.
+	(cmp_sdiv_cc_set): Factor common string.
+	(udivsi3_sp32): Add new alternative with 'K' for operand #2.
+	Add TARGET_V9 case.
+	(cmp_udiv_cc_set): Factor common string.
+
+2008-06-05  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	* config/mips/mips.c (mips_emit_loadgp): Emit a blockage if
+	current_function_profile.
+	* config/mips/mips.md (loadgp_blockage): Use SI rather than DI.
+
+2008-05-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-nested.c (check_for_nested_with_variably_modified): Fix typo.
+
+2008-04-08  Richard Guenther  <rguenther@suse.de>
+
+	* fold-const.c (fold_widened_comparison): Do not allow
+	sign-changes that change the result.
+
+2008-03-25  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2008-02-12  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/35163
+	* fold-const.c (fold_widened_comparison): Use get_unwidened in
+	value-preserving mode.  Disallow final truncation.
+
+2008-02-14  Alan Modra  <amodra@bigpond.net.au>
+
+	PR target/34393
+	* config/rs6000/rs6000.md (restore_stack_block): Force operands[1]
+	to a reg.
+
+2008-02-09  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR middle_end/34150
+	* pa.c (legitimize_pic_address): Add REG_EQUAL note on sets with a
+	pic_label_operand source.  Similarly, add a REG_LABEL note and
+	update LABEL_NUSES during and after reload.
+
+2008-02-08  Steven Bosscher  <stevenb.gcc@gmail.com>
+
+	PR middle-end/34627
+	* combine.c (simplify_if_then_else): Make sure the comparison is
+	against const0_rtx when simplifying to (abs x) or (neg (abs X)).
+
+2008-02-04  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/33631
+	* expr.c (count_type_elements): Give for unions instead of
+	guessing.
+
+2008-02-01  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2007-08-02  Nathan Froyd  <froydnj@codesourcery.com>
+
+	PR middle-end/25445
+	* varasm.c (default_binds_local_p_1): Consult flag_whole_program
+	if we are compiling with -fPIC.
+
+2008-01-31  Richard Henderson  <rth@redhat.com>
+
+        PR c/34993
+        * tree.c (build_type_attribute_qual_variant): Skip TYPE_DOMAIN
+        for unbounded arrays.
+
+2008-01-31  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	* config/s390/fixdfdi.h (__fixunstfdi, __fixtfdi): Rearrange
+	the overflow check to make it easier to read.
+	(__fixtfdi): Change the type of the ll member in union
+	long_double to UDItype_x.
+
+2008-01-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2007-11-07  Kenneth Zadeck <zadeck@naturalbridge.com>
+	
+	PR middle-end/33826
+	* ipa-pure-const (static_execute): Added code to keep recursive
+	functions from being marked as pure or const.
+	* ipa-utils (searchc): Fixed comment.
+	
+2008-01-16  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR libgfortran/34699
+	* pa-hpux.h (LINK_SPEC): Only search /lib/pa1.1 and /usr/lib/pa1.1 on
+	static links.
+	* pa-hpux10.h (LINK_SPEC): Likewise.
+	* pa-hpux11.h (LINK_SPEC): Don't search /lib/pa1.1 and /usr/lib/pa1.1.
+
+2008-01-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/31944
+	* cse.c (remove_pseudo_from_table): New function.
+	(merge_equiv_classes): Use above function to remove pseudo-registers.
+	(invalidate): Likewise.
+
+2007-12-31  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR driver/33772
+	* collect2.c (SHLIB_SUFFIX): Define if not defined.
+	(write_c_file_stat): Use SHLIB_SUFFIX.
+	* som.h (SHLIB_SUFFIX): Define.
+	* doc/tm.texi (SHLIB_SUFFIX): Document.
+
+2007-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/34003
+	* c-decl.c (merge_decls): Copy RTL from olddecl to newdecl.
+	* config/pa/pa.c (pa_encode_section_info): If !first, preserve
+	SYMBOL_FLAG_REFERENCED flag.
+
+2007-12-19  Kaz Kylheku  <kaz@zeugmasystems.com>
+
+	PR rtl-optimization/34456
+	* resource.c (mark_set_resources): Use regs_invalidated_by_call
+	rather than call_used_regs and global_regs.
+
+2007-11-29  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from mainline:
+	2007-11-17  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/34130
+	* fold-const.c (extract_muldiv_1): Do not move negative
+	constants inside ABS_EXPR.
+
+2007-11-16  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/34030
+	* fold-const.c (fold_binary): Use correct types for folding
+	1 << X & Y to Y >> X & 1.
+
+2007-11-07  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR rtl-optimization/33822
+	* rtl.h (REG_OFFSET): Fix comment.
+	* var-tracking.c (INT_MEM_OFFSET): New macro.
+	(var_mem_set): Use it.
+	(var_mem_delete_and_set): Likewise.
+	(var_mem_delete): Likewise.
+	(vt_get_decl_and_offset): Likewise.
+	(offset_valid_for_tracked_p): New predicate.
+	(count_uses): Do not track locations with invalid offsets.
+	(add_uses): Likewise.
+	(add_stores): Likewise.
+
+2007-11-04  Hirohisa Yamaguchi  <umq@ueo.co.jp>
+
+	* config/freebsd-spec.h (FBSD_TARGET_OS_CPP_BUILTINS): Fix
+	broken else-if chain.
+
+2007-11-04  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* config.gcc: Proactively add FreeBSD 10 and FreeBSD 11.
+	* config/freebsd-spec.h (FBSD_TARGET_OS_CPP_BUILTINS): Ditto.
+
+2007-11-02  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	Backport from mainline:
+	2006-12-11  Zdenek Dvorak  <dvorakz@suse.cz>
+
+	PR rtl-optimization/30113
+	* loop-iv.c (implies_p): Require the mode of the operands to be
+	scalar.
+
+2007-10-30  Ian Lance Taylor  <iant@google.com>
+
+	* ifcvt.c (noce_can_store_speculate_p): New static function.
+	(noce_process_if_block): Call it.
+	(find_if_header): Only call find_if_case_1 and find_if_case_2 if
+	life_data_ok is set.
+	(if_convert): Always compute postdominators.
+
+2007-10-29  Janis Johnson  <janis187@us.ibm.com>
+
+	* doc/invoke.texi (Option Summary, optimizations): Remove
+	-fbounds-check.  Show that the value for options -falign-jumps,
+	-falign-labels, -falign-loops, -falign-functions,
+	-fsched-stalled-insns, and -fsched-stalled-insns-dep is optional.
+	Break up a long line.  Add -ftree-vrp and -funit-at-a-time.
+	(Option Summary, code gen options)  Add -fno-stack-limit.
+	* doc/invoke.texi (Option Summary, optimizations):
+	(Optimization Options): Remove -fbounds-check, which is also
+	documented under Code Generation Options.  In the descriptions for
+	-fsched-stalled-insns and -fsched-stalled-insns-dep, show the
+	options with and without values.  Change -fno-cprop-registers
+	to -fcprop-registers to match other options, and say when it is
+	enabled rather than disabled.  Remove extra index entry for
+	-fno-cx-limited-range.  Add opindex for several optimization
+	options, and fix typos in the opindex commands for several others.
+	(Code Gen Options): Add index entry for -ftls-model.
+
+2007-10-23  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* doc/rtl.texi (Flags): Fix MEM_SCALAR_P entry.
+	Document MEM_POINTER.  Replace mentions of "integrated"
+	field with "return_val".  Delete outdated stuff.
+
+2007-10-20  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/rs6000/linux-unwind.h (ppc_fallback_frame_state): Point
+	saved CR2 offset to low 32 bits of regs->ccr rather than the whole
+	64-bit register in 64-bit libgcc.
+
+2007-09-23  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure.ac (ld_vers): Support GNU linker version xx.xx.*
+	* configure: Regenerated.
+
+2007-09-23  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.ac (MAKEINFO): Handle makeinfo version 4.10 and above.
+	* configure: Regenerated.
+
+2007-09-13  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR bootstrap/33418
+	* configure.ac (ld_vers): Support Linux linker.
+	* configure: Regenerated.
+
+2007-09-06  Richard Sandiford  <richard@codesourcery.com>
+
+	PR target/33256
+	* config/mips/mips.c (mips_classify_symbolic_expression): New function.
+	(mips_classify_address): Use it instead of mips_symbolic_constant_p.
+	(print_operand_reloc): Likewise.
+
+2007-08-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/32912
+	* fold-const.c (fold_binary): Only optimize X | ~X and X ^ ~X for
+	integral types.
+
+2007-08-22  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/33142
+	* tree-vrp.c (extract_range_from_unary_expr): Compare with
+	TYPE_MIN/MAX_VALUE using tree_int_cst_equal.
+
+2007-08-21  Adam Nemet  <anemet@caviumnetworks.com>
+
+	* config/mips/predicates.md (const_call_insn_operand): Invoke
+	SYMBOL_REF_LONG_CALL_P only on SYMBOL_REFs.
+
+2007-08-02  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	* config/s390/s390.md ("*xordi3_cconly"): Change xr to xg.
+
+2007-08-01  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	* config/s390/s390.md (TF in GPR splitter): Change operand_subword
+	parameter to TFmode.
+
+2007-07-16  Richard Guenther  <rguenther@suse.de>
+	    Uros Bizjak  <ubizjak@gmail.com>
+
+	* tree-if-conv.c (find_phi_replacement_condition): Unshare "*cond"
+	before forcing it to gimple operand.
+
+2007-07-13  Paolo Bonzini  <bonzini@gnu.org>
+
+	Revert these patches:
+
+	2007-07-09  Paolo Bonzini  <bonzini@gnu.org>
+
+        PR middle-end/32004
+        * function.c (rest_of_match_asm_constraints): Pass PROP_REG_INFO.
+
+	2007-07-06  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR middle-end/32004
+	* function.c (match_asm_constraints_1, rest_of_match_asm_constraints,
+	pass_match_asm_constraints): New.
+	* passes.c (init_optimization_passes): Add new pass.
+	* stmt.c (expand_asm_operands): Set cfun->has_asm_statement.
+	* function.h (struct function): Add has_asm_statement bit.
+	(current_function_has_asm_statement): New.
+	* tree-pass.h (pass_match_asm_constraints): New.
+
+2007-07-09  Paolo Bonzini  <bonzini@gnu.org>
+
+        PR middle-end/32004
+        * function.c (rest_of_match_asm_constraints): Pass PROP_REG_INFO.
+
+2007-07-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR tree-optimization/32681
+	* tree-if-conv.c (find_phi_replacement_condition): Use the condition
+	saved in second_edge->aux when first_bb is a loop header.
+
+2007-07-07 Anatoly Sokolov <aesok@post.ru>
+
+	PR target/31331
+	* config/avr/avr.c (avr_naked_function_p): Handle receiving a type
+	rather than a decl. 
+	(avr_attribute_table): Make "naked" attribute apply to function types
+	rather than to decls.
+	(avr_handle_fntype_attribute): New function.
+
+2007-07-07  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/32660
+	Backport from mainline.
+	* config/i386/sse.md (*vec_extractv2di_1_sse2): New.
+	(*vec_extractv2di_1_sse): New.
+
+2007-07-06  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR middle-end/32004
+	* function.c (match_asm_constraints_1, rest_of_match_asm_constraints,
+	pass_match_asm_constraints): New.
+	* passes.c (init_optimization_passes): Add new pass.
+	* stmt.c (expand_asm_operands): Set cfun->has_asm_statement.
+	* function.h (struct function): Add has_asm_statement bit.
+	(current_function_has_asm_statement): New.
+	* tree-pass.h (pass_match_asm_constraints): New.
+
+2007-07-06  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/32450
+	* function.c (thread_prologue_and_epilogue_insns): Emit blockage insn
+	to ensure that instructions are not moved into the prologue when
+	profiling is on.
+
+2007-07-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR tree-optimization/31966
+	PR tree-optimization/32533
+	* tree-if-conv.c (add_to_dst_predicate_list): Use "edge", not
+	"basic_block" description as its third argument.  Update function
+	calls to get destination bb from "edge" argument.  Save "cond" into
+	aux field of the edge.  Update prototype for changed arguments.
+	(if_convertible_loop_p): Clear aux field of incoming edges if bb
+	contains phi node.
+	(find_phi_replacement_condition): Operate on incoming edges, not
+	on predecessor blocks.  If there is a condition saved in the
+	incoming edge aux field, AND it with incoming bb predicate.
+	Return source bb of the first edge.
+	(clean_predicate_lists): Clean aux field of outgoing node edges.
+	(tree_if_conversion): Do not initialize cond variable. Move
+	variable declaration into the loop.
+	(replace_phi_with_cond_gimple_modify_stmt): Remove unneded
+	initializations of new_stmt, arg0 and arg1 variables.
+
+2007-07-04  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/32506
+	Backport from mainline.
+	* config/sh/sh.md (udivsi3_i1_media): Use target_reg_operand
+	predicate instead of target_operand.
+	(divsi3_i1_media, divsi3_media_2): Likewise.
+
+2007-07-03  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	PR target/28307
+	* gthr-posix.h [SUPPORTS_WEAK && GTHREAD_USE_WEAK]
+	(__gthrw_pragma): Provide default definition.
+	(__gthrw2): Use it.
+	* gthr-posix.c (__gthrw_pragma): Define.
+
+2007-06-30  Alexandre Oliva  <aoliva@redhat.com>
+
+	* dwarf2out.c (dwarf2out_finish): Accept namespaces as context of
+	limbo die nodes.
+
+2007-06-28  Seongbae Park  <seongbae.park@gmail.com>
+
+	* config/arm/arm.c (arm_get_frame_offsets): Set
+	offsets->locals_base to avoid negative stack size.
+	(thumb1_expand_prologue): Assert on negative stack size.
+
+2007-06-28  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/rs6000/rs6000.c (rs6000_function_ok_for_sibcall): Ensure
+	decl is non-external for AIX ABI.
+
+2007-06-28  David Edelsohn  <edelsohn@gnu.org>
+
+	* config/rs6000/predicates.md (current_file_function_operand):
+	Ensure the symbol is non-external for AIX ABI.
+
+2007-06-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/32389
+	* config/i386/i386.h (enum ix86_stack_slot): Add SLOT_VIRTUAL.
+	* config/i386/i386.c (assign_386_stack_local): Assert that
+	SLOT_VIRTUAL is valid only before virtual regs are instantiated.
+	(ix86_expand_builtin) [IX86_BUILTIN_LDMXCSR, IX86_BUILTIN_STMXCSR]:
+	Use SLOT_VIRTUAL stack slot instead of SLOT_TEMP.
+	* config/i386/i386.md (truncdfsf2, truncxfsf2, truncxfdf2): Ditto.
+
+2007-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/32109
+	* gimplify.c (gimplify_asm_expr): Issue error if type is addressable
+	and !allows_mem.
+
+	PR middle-end/32285
+	* calls.c (precompute_arguments): Also precompute CALL_EXPR arguments
+	if ACCUMULATE_OUTGOING_ARGS.
+
+2007-06-20  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR rtl-optimization/28011
+	Backport from mainline.
+	* reload.c (push_reload): Set dont_share if IN appears in OUT
+	also when IN is a PLUS rtx.
+	(reg_overlap_mentioned_for_reload_p): Return true if X and IN
+	are same PLUS rtx.
+
+2007-06-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/32353
+	* tree-ssa-structalias.c (set_uids_in_ptset): Also handle RESULT_DECL.
+
+2007-06-13  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* config/sparc/sparc.c (sparc_override_options): Initialize
+	fpu mask correctly.
+
+2007-06-08  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/32163
+	Backport from mainline.
+	* config/sh/sh.md (symGOT_load): Don't schedule insns when
+	the symbol is generated with the stack protector.
+
+2007-05-31  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2007-05-05  Aurelien Jarno  <aurelien@aurel32.net>
+
+	* config/pa/pa.md: Split tgd_load, tld_load and tie_load
+	into pic and non-pic versions. Mark r19 as used for 
+	tgd_load_pic, tld_load_pic and tie_load_pic. Mark r27 as used 
+	for tgd_load, tld_load and tie_load .
+	* config/pa/pa.c (legitimize_tls_address): Emit pic or non-pic
+	version of tgd_load, tld_load and tie_load depending on the 
+	value of flag_pic.
+
+2007-05-20  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/31701
+	Backport from mainline.
+	* config/sh/sh.c (output_stack_adjust): Avoid using the frame
+	register itself to hold the offset constant.  Tell flow the use
+	of r4 and r5 when they are used.
+
+2007-05-20  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/31480
+	Backport from mainline.
+	* config/sh/sh.md (length): Check if prev_nonnote_insn (insn)
+	is null.
+
+2007-05-20  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/31022
+	Backport from mainline.
+	* config/sh/sh.c (sh_adjust_cost): Use the result of single_set
+	instead of PATTERN.
+
+2007-05-17  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR rtl-optimization/31691
+	* combine.c (simplify_set): Build a new src pattern instead of
+	substituting its operands in the COMPARE case.
+
+2007-05-16  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2006-06-09  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/26998
+	* tree-vrp.c (extract_range_from_unary_expr): For NEGATE_EXPR
+	of signed types, only TYPE_MIN_VALUE is special, but for both,
+	minimum and maximum value.  Likewise VR_ANTI_RANGE is special
+	in this case, as is -fwrapv.
+
+2007-05-11  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	PR target/31876
+	* config/sh/sh.md (andsi3): Avoid calling gen_lowpart on
+        a SImode SUBREG of a floating point register.
+
+2007-05-08  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	* loop.c (move_movables): Remove REG_EQUAL notes for conditional
+	invariants as well.
+
+2007-04-29  Bernd Schmidt  <bernd.schmidt@analog.com>
+
+	* reload.c (combine_reloads): When trying to use a dying register,
+	check whether it's uninitialized and don't use if so.
+
+2007-04-27  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	PR middle-end/30761
+	* reload1.c (eliminate_regs_in_insn): In the single_set special
+	case, attempt to re-recognize the insn before falling back to
+	having reload fix it up.
+
+2007-04-26  Ian Lance Taylor  <iant@google.com>
+
+	PR target/28675
+	* reload.c (find_reloads_subreg_address): If the address was valid
+	in the original mode but not in the new mode, reload the whole
+	address.
+
+2007-04-25  Anatoly Sokolov <aesok@post.ru>
+
+	PR target/18989
+ 	* config/avr/avr.h (ASM_OUTPUT_ALIGN): Redefine.
+
+2007-04-25  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2006-10-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/29446
+	* tree-vrp.c (fix_equivalence_set): Remove.
+	(extract_range_from_assert): Do not call fix_equivalence_set.
+	(debug_value_range): Print a newline.
+	(compare_name_with_value): For equivalence sets with
+	inconsistent value ranges conservatively bail out.
+	(compare_names): Likewise.
+
+2007-04-24  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	PR target/31641
+	* config/s390/s390.c (s390_expand_setmem): Don't ICE for constant length
+	argument of 0 for memset.
+	(s390_expand_movmem, s390_expand_setmem, s390_expand_cmpmem): Use
+	unsigned shift instead of the signed variant.
+
+2007-04-22  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR middle-end/31448
+	* expr.c (reduce_to_bit_field_precision): Handle
+	CONST_INT rtx's.
+
+2007-04-20  Richard Henderson  <rth@redhat.com>
+
+	PR target/28623
+	* config/alpha/alpha.c (get_unaligned_address): Remove extra_offset
+	argument; update all callers.
+	(get_unaligned_offset): New.
+	* config/alpha/alpha.md (extendqidi2, extendhidi2): Don't use
+	get_unaligned_address, just pass on the address directly.
+	(unaligned_extendqidi): Use gen_lowpart instead of open-coding
+	the subreg in the helper patterns.
+	(unaligned_extendqidi_le): Use get_unaligned_offset.
+	(unaligned_extendqidi_be, unaligned_extendhidi_le): Likewise.
+	(unaligned_extendhidi_be): Likewise.
+	(unaligned_extendhidi): Tidy.
+	* config/alpha/alpha-protos.h: Update.
+
+2007-04-20  Richard Henderson  <rth@redhat.com>
+
+	* config/alpha/linux.h (CPP_SPEC): Undef before redefine.
+
+2007-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/i386/i386.c (bdesc_2arg): Use ORDERED rather than UNORDERED
+	for __builtin_ia32_cmpordss.
+
+	PR tree-optimization/31632
+	* fold-const.c (fold_binary): Use op0 and op1 instead of arg0
+	and arg1 for optimizations of comparison against min/max values.
+	Fold arg0 to arg1's type for optimizations of comparison against
+	min+1 and max-1 values.
+
+2007-04-18  Anatoly Sokolov <aesok@post.ru>
+
+	* config/avr/avr.c (ptrreg_to_str): Replace error() with
+	output_operand_lossage().
+
+2007-04-17  Anatoly Sokolov <aesok@post.ru>
+
+	PR target/30483
+	* config/avr/avr.c (ptrreg_to_str): Replace gcc_unreachable() with
+	error().
+
+2007-04-16  Matthias Klose  <doko@debian.org>
+
+	* config/alpha/linux.h (CPP_SPEC): Define.
+	* config/arm/linux-gas.h (SUBTARGET_CPP_SPEC): Extend.
+
+2007-04-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Backport from mainline:
+	2007-04-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/31582
+	* config/i386/i386.c (ix86_expand_vec_set_builtin): Make a
+	copy of source, pass it to ix86_expand_vector_set and return
+	it as target.
+
+2007-04-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR tree-opt/30045
+	* tree-vrp.c (nonnull_arg_p): Treat the static decl as always
+	non null.
+
+2007-04-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR middle-end/30729
+	* stmt.c (warn_if_unused_value): VA_ARG_EXPR has side
+	effects unknown to this function, return early.
+
+2007-04-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR c/31520
+	* c-decl.c (finish_decl): Grab the type of the decl after the call
+	to store_init_value.
+
+2007-04-07  Anatoly Sokolov <aesok@post.ru>
+
+	PR target/30289
+	* config/avr/avr.md (*clrmemqi, *clrmemhi): Mark operand 4 as 
+	earlyclobber.
+
+2007-04-05  Anatoly Sokolov <aesok@post.ru>
+
+	PR target/25448
+	* config/avr/avr.c (avr_handle_fndecl_attribute): Use the 
+	DECL_ASSEMBLER_NAME, not the DECL_NAME.
+
+2007-04-04  Richard Henderson  <rth@redhat.com>
+
+	PR target/31361
+	* config/i386/i386.c (ix86_init_mmx_sse_builtins): Remove
+	v8hi_ftype_v8hi_v2di, v4si_ftype_v4si_v2di.  Use like-types for
+	the variable shift builtins.
+	(ix86_expand_builtin): Properly expand the variable shift builtins.
+	* config/i386/sse.md (ashr<mode>3, lshr<mode>3, ashl<mode>3): Make
+	operand 2 be TImode.
+	* config/i386/emmintrin.h (_mm_slli_epi16, _mm_slli_epi32,
+	_mm_slli_epi64, _mm_srai_epi16, _mm_srai_epi32, _mm_srli_epi16,
+	_mm_srli_epi32, _mm_srli_epi64): Turn into macros.
+	(_mm_srli_si128, _mm_srli_si128): Fix disabled inline versions.
+	(_mm_sll_epi16, _mm_sll_epi32, _mm_sll_epi64, _mm_sra_epi16,
+	_mm_sra_epi32, _mm_srl_epi16, _mm_srl_epi32, _mm_srl_epi64): Use
+	two-vector shift builtins.
+
+2007-04-02  Anatoly Sokolov <aesok@post.ru>
+
+	PR target/31137
+	* config/avr/avr.c (avr_rtx_costs): Add missing 'break' statements.
+
+2007-04-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Backport from mainline:
+	2007-03-28  Grigory Zagorodnev <grigory_zagorodnev@linux.intel.com>
+
+	PR target/31380
+	* config/i386/sse.md (uminv16qi3): Use UMIN instead of UMAX.
+
+2007-03-30  Anatoly Sokolov <aesok@post.ru>
+
+	* config/avr/avr.c (avr_override_options): Clear 
+	'flag_delete_null_pointer_checks'.
+
+2007-03-21  Richard Henderson  <rth@redhat.com>
+
+	PR target/31245
+	* config/i386/emmintrin.h (__m128i, __m128d): Mark may_alias.
+	* config/i386/mmintrin.h (__m64): Likewise.
+	* config/i386/xmmintrin.h (__m128): Likewise.
+
+2007-03-19  Seongbae Park <seongbae.park@gmail.com>
+
+	PR tree-optimization/30590
+	* tree-nrv.c (tree_nrv): Check for the partial update
+	of the return value.
+
+2007-03-19  Jeff Law  <law@redhat.com>
+
+	* tree-cfg.c (find_taken_edge): Tighten conditions for
+	optimizing computed gotos.
+
+2007-03-19  Brooks Moses  <brooks.moses@codesourcery.com>
+
+	* doc/extend.texi: Edit "gnu_inline" documentation.
+	* doc/invoke.texi: Edit "-fgnu89-inline" documentation.
+
+2007-03-19  Ian Lance Taylor  <iant@google.com>
+
+	* c.opt (fgnu89-inline): New option.
+	* c-opts.c (c_common_post_options): Warn about -fno-gnu89-inline.
+	* c-common.c (c_common_attributes): Add gnu_inline attribyte.
+	(handle_gnu_inline_attribute): New static function.
+	* c-cppbuiltin.c (c_cpp_builtins): Define __GNUC_GNU_INLINE__.
+	* doc/invoke.texi (Option Summary): Mention -fgnu89-inline.
+	(C Dialect Options): Document -fgnu89-inline.
+	* doc/extend.texi (Function Attributes): Document gnu_inline.
+	(Inline): Mention that C99 inline will be implemented in 4.3.
+	Refer to ways to get the old handling.
+	* doc/cpp.texi (Common Predefined Macros): Document
+	__GNUC_GNU_INLINE__ and __GNUC_STDC_INLINE__.
+
+2007-03-17  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/29906
+	* dwarf2out.c (force_type_die): Adjust comment.
+	(dwarf2out_imported_module_or_decl): Handle base AT_import types.
+
+2007-03-16  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* pa.c (attr_length_call): Partially revert change of 2007-03-09.
+	(output_call): Likewise.
+
+2007-03-15  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2007-02-28  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/30364
+	* fold-const.c (fold_binary): Do not associate expressions
+	with more than one variable for integer types that do not wrap.
+
+2007-03-13  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/31123
+	* pa.md (vdepi_ior): Don't allow zero length deposit.  Likewise for
+	two unamed patterns.
+	
+2007-03-12  Roger Sayle  <roger@eyesopen.com>
+	    Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR middle-end/30433
+	* fold-const.c (fold_relational_const): Add back compile-time
+	evaluation of complex constant equality/inequality comparisons.
+
+2007-03-12  Richard Henderson  <rth@redhat.com>
+
+	PR target/26090
+	* config/alpha/alpha.c (alpha_elf_select_section): New.
+	(alpha_elf_unique_section, alpha_elf_section_type_flags): New.
+	(alpha_elf_select_rtx_section): Force flag_pic true.
+	(TARGET_ASM_SELECT_SECTION, TARGET_ASM_UNIQUE_SECTION): New.
+	(TARGET_SECTION_TYPE_FLAGS): New.
+
+2007-03-12  Ira Rosen  <irar@il.ibm.com>
+
+	PR tree-optimization/29925
+	* tree-data-ref.c (analyze_offset): Add a return value (bool) to
+	indicate success/failure of the analysis. Add negation to subtrahend
+	in case of subtraction. Fail if both operands contain constants.
+	(create_data_ref): Fail if analyze_offset fails.
+
+2007-03-09  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* pa.c (attr_length_call): Revise condition for long pc-relative branch.
+	(output_call): Use "LONG_PIC_SDIFF" instruction sequence for long local
+	calls on the SOM target.  Don't use "LONG_PIC_PCREL" call sequence on
+	SOM target.
+
+2007-03-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR rtl-optimization/30643
+	* cse.c (cse_insn): Recompute dest_hash after insert_regs for
+	dest_addr_elt.
+
+2007-03-08  Andreas Schwab  <schwab@suse.de>
+
+	* c-common.c (fold_offsetof_1): Remove extra argument in recursive
+	call.
+
+2007-03-08  Volker Reichelt  <reichelt@netcologne.de>
+
+	PR c++/30852
+	* c-common.c (fold_offsetof_1): Handle COMPOUND_EXPR.
+
+2007-03-07  Richard Henderson  <rth@redhat.com>
+
+	PR target/30848
+	* reg-stack.c (emit_swap_insn): If a malformed asm was seen,
+	silently fix up the stack in the case of a missing register.
+
+2007-03-06  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* convert.c (convert_to_integer): Fix nearbyint/rint -> *lrint
+	conversion.
+	
+2007-03-05  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* pa.md: In unamed move patterns, disparge copies between general
+	and floating point registers using '?' modifier.  Don't include 'f'
+	constraint for register preferences in DImode, SImode, HImode and
+	QImode patterns.  Likewise for 'r' in DFmode and SFmode patterns.
+	Remove constraints for copies between general and floating registers
+	in soft-float DFmode pattern.
+	(movdf): Fail if operand1 is a CONST_DOUBLE and operand0 is a hard
+	floating register.
+	(movsf): Likewise. 
+
+2007-02-27  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* pa/predicates.md (move_src_operand): Allow zero for mode.
+	* pa/pa.md: Fix constraints for zero CONST_DOUBLE in 64-bit DFmode
+	move pattern.
+
+2007-02-27  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR rtl-optimization/30931
+	* loop.c (combine_givs_p): Return false if either GIV is not
+	always executed.
+
+2007-02-21 Ira Rosen  <irar@il.ibm.com>
+
+	* Makefile.in (tree-ssa-alias.o): Depend on pointer-set.h.
+
+2007-02-20 Ira Rosen  <irar@il.ibm.com>
+
+	* tree-ssa-alias.c: Include pointer-set.h. 
+	(may_aliases_intersect): Use the correct type (varray) for
+	may_aliases sets.
+
+2007-02-18  Kaz Kojima  <kkojima@gcc.gnu.org>
+
+	Backport from mainline.
+	PR rtl-optimization/29599
+	* reload1.c (eliminate_regs_in_insn): Take the destination
+	mode into account when computing the offset.
+
+2007-02-18  Roger Sayle  <roger@eyesopen.com>
+
+	Backport from mainline.
+	PR middle-end/24427
+	PR rtl-optimization/28173
+	* fold-const.c (fold_binary) <BIT_IOR_EXPR>: Transform (X&C1)|C2
+	into (X,C2) if C1 is a subset of the bits of C2.  Transform
+	(X&C1)|C2 into X|C2 if C1|C2 == ~0.  Canonicalize (X&C1)|C2 as
+	(X&(C1&~C2))|C2.
+	<BIT_AND_EXPR>: Canonicalize (X|C1)&C2 as (X&C2)|(C1&C2).
+
+2007-02-18 Ira Rosen  <irar@il.ibm.com>
+
+	* tree-ssa-alias.c (may_aliases_intersect): New function.
+	* tree-data-ref.c (ptr_ptr_may_alias_p): Call may_aliases_intersect 
+	for different tags.
+	* tree-flow.h (may_aliases_intersect): Add function declaration.
+
+2007-02-17  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR tree-optimization/30823
+	* tree-sra.c (sra_build_assignment): Drop type-checking assert.
+
+2007-02-16  Guy Martin  <gmsoft@gentoo.org>
+
+	* pa.md (tp_load): Correct mfctl instruction syntax.
+
+2007-02-16  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR rtl-optimization/30787
+	* loop.c (strength_reduce): Don't reduce giv that is not always
+	executed and where add_val or mult_val can trap.
+
+2007-02-16  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	PR other/27843
+	* Makefile.in (SYSTEM_HEADER_DIR): Use single quotes to avoid
+	nested double- and backquotes.
+
+2007-02-15  Anatoly Sokolov <aesok@post.ru>
+
+	PR target/19087
+	* config/avr/avr.c (DWARF2_ADDR_SIZE): Define.
+	
+2007-02-15  Bob Wilson  <bob.wilson@acm.org>
+
+	* config/xtensa/xtensa.c (constantpool_mem_p): Skip over SUBREGs.
+
+2007-02-15  Alexandre Oliva  <aoliva@redhat.com>
+
+	* tree-sra.c (instantiate_missing_elements): Canonicalize
+	bit-field types.
+	(sra_build_assignment): New.
+	(generate_copy_inout, generate_element_copy,
+	generate_element_zero, generate_one_element_init): Use it.
+
+2007-02-15  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/30189
+	* dwarf2out.c (modified_type_die): Follow DECL_ORIGINAL_TYPE
+	even if cv-qualification is the same.
+
+2007-02-14  Eric Botcazou  <ebotcazou@adacore.com>
+	    Maxim Kuvyrkov <mkuvyrkov@ispras.ru>
+
+	PR rtl-optimization/28772
+	* Makefile.in (haifa-sched.o): Add dependency on $(PARAMS_H).
+
+	Backport from mainline:
+	2006-04-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* params.def (PARAM_MAX_SCHED_READY_INSNS): New parameter,
+	defaulting to 100.
+	* params.h (MAX_SCHED_READY_INSNS): New macro.
+	* haifa-sched.c: (queue_to_ready): Re-queue insns for the next cycle
+	past MAX_SCHED_READY_INSNS during the first scheduling pass.
+	(schedule_block): Delay insns past MAX_SCHED_READY_INSNS in
+	the ready list for 1 cycle during the first scheduling pass.
+	* doc/invoke.texi (--param): New parameter max-sched-ready-insns.
+
+2007-02-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/30473
+	* builtins.c (fold_builtin_sprintf): Do not attempt to optimize
+	sprintf (str, "%s").  Do not optimize sprintf (str, "nopercent", p++).
+
+2007-02-14  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2007-01-30  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/30313
+	* passes.c (execute_one_pass): Reset in_gimple_form to not
+	confuse non-unit-at-a-time mode.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
@@ -15,11 +966,11 @@
 
 2007-01-29  Josh Conner  <jconner@apple.com>
 
-        PR middle-end/29683
-        * calls.c (compute_argument_addresses): Set stack and stack_slot
-        for partial args, too.
-        (store_one_arg): Use locate.size.constant for the size when
-        generating a save_area.
+	PR middle-end/29683
+	* calls.c (compute_argument_addresses): Set stack and stack_slot
+	for partial args, too.
+	(store_one_arg): Use locate.size.constant for the size when
+	generating a save_area.
 
 2007-01-28  Ralf Wildenhalf Wildenhues  <Ralf.Wildenhues@gmx.de>
 
@@ -100,7 +1051,7 @@
 
 2007-01-05  Richard Guenther  <rguenther@suse.de>
 
-        PR tree-optimization/30212
+	PR tree-optimization/30212
 	* tree-vrp.c (adjust_range_with_scev): Do not adjust invalid
 	ranges by using TYPE_MIN_VALUE or TYPE_MAX_VALUE.
 
@@ -195,10 +1146,10 @@
 2006-12-17  Matthias Klose  <doko@debian.org>
 
 	PR libstdc++/11953
-	* gcc/config/mips/linux.h (SUBTARGET_CPP_SPEC): Extend.
+	* config/mips/linux.h (SUBTARGET_CPP_SPEC): Extend.
 
 2006-12-16  Joseph Myers  <joseph@codesourcery.com>
-            David Edelsohn  <edelsohn@gnu.org>
+	    David Edelsohn  <edelsohn@gnu.org>
 
 	PR target/24036
 	* doc/tm.texi (HARD_REGNO_NREGS_HAS_PADDING,
@@ -276,7 +1227,7 @@
 	inside start_sequence / end_sequence pair.
 
 2006-11-27  Michael Matz  <matz@suse.de>
-            Andreas Krebbel  <krebbel1@de.ibm.com>
+	    Andreas Krebbel  <krebbel1@de.ibm.com>
 
 	PR target/29319
 	* config/s390/predicates.md (larl_operand): Check addend of larl
@@ -498,7 +1449,7 @@
 2006-11-02  Eric Botcazou  <ebotcazou@libertysurf.fr>
 
 	* doc/install.texi (sparc-sun-solaris2*): Update GMP/MPFR build
-	instructions.
+
 	(sparc64-sun-solaris2*): Likewise.
 
 2006-11-02  Zdenek Dvorak <dvorakz@suse.cz>
@@ -646,7 +1597,7 @@
 	2006-08-23  Stuart Hastings  <stuart@apple.com>
 
 	PR target/28825
-	* gcc/config/i386/i386.c (ix86_expand_vector_init_duplicate,
+	* config/i386/i386.c (ix86_expand_vector_init_duplicate,
 	ix86_expand_vector_init_one_nonzero): Remove TARGET_SSE test.
 
 2006-10-16  Richard Guenther  <rguenther@suse.de>
@@ -2091,16 +3042,16 @@
 
 2006-04-19  Jeff Law  <law@redhat.com>
 
-        PR tree-optimization/26854
+	PR tree-optimization/26854
 	* tree-ssa-dse.c (dse_optimize_stmt): Use has_single_use rather
 	than num_imm_uses.
 	* tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): Similarly.
 
 2006-04-18  Jeff Law  <law@redhat.com>
 
-        PR tree-optimization/27087
-        * tree-ssa-copy.c (may_propagate_copy): Test flow sensitive
-        alias information too.
+	PR tree-optimization/27087
+	* tree-ssa-copy.c (may_propagate_copy): Test flow sensitive
+	alias information too.
 
 2006-04-18  Andreas Krebbel  <krebbel1@de.ibm.com>
 
@@ -2109,14 +3060,14 @@
 
 2006-04-18  Paolo Bonzini  <bonzini@gnu.org>
 
-        PR tree-optimization/26643
+	PR tree-optimization/26643
 
 	Backport from mainline:
 	2006-03-29  Zdenek Dvorak <dvorakz@suse.cz>
 
-        PR tree-optimization/26643
-        * tree-ssa-loop-ivopts.c (find_interesting_uses_address): Do not handle
-        bit_field_refs.
+	PR tree-optimization/26643
+	* tree-ssa-loop-ivopts.c (find_interesting_uses_address): Do not handle
+	bit_field_refs.
 
 2006-04-18  Paolo Bonzini  <bonzini@gnu.org>
 
@@ -2131,7 +3082,7 @@
 	(insert_reciprocals): Use it.
 
 	2006-02-02  Paolo Bonzini  <bonzini@gnu.org>
-            
+	    
 	* tree-flow-inline.h (bsi_after_labels): Rewrite, return
 	what its name says.
 	* lambda-code.c (perfect_nestify): Use bsi_insert_before on
@@ -2155,7 +3106,7 @@
 	to expand fallback builtin function call.
 
 2006-04-14  Alexey Starovoytov  <alexey.starovoytov@sun.com>
-            Eric Botcazou  <ebotcazou@libertysurf.fr>
+	    Eric Botcazou  <ebotcazou@libertysurf.fr>
 
 	* config/sparc/sparc.c (emit_and_preserve): Allocate space for the
 	register save area.
@@ -2229,7 +3180,7 @@
 
 2006-04-08  Matthias Klose  <doko@debian.org>
 
-        * Makefile.in (unprotoize.o): Same dependencies as for protoize.o.
+	* Makefile.in (unprotoize.o): Same dependencies as for protoize.o.
 
 2006-04-07  Richard Guenther  <rguenther@suse.de>
 
@@ -2287,7 +3238,7 @@
 	* tree-cfg.c (tree_duplicate_sese_region): Do not update SSA.
 	* tree-ssa-loop-ch.c (copy_loop_headers): Count successfully duplicated
 	headers and, if there was any, update SSA at the end.
-        
+	
 	Backport from mainline:
 	2006-03-30  Paolo Bonzini  <bonzini@gnu.org>
 
@@ -2404,7 +3355,7 @@
 2006-03-16  Paul Brook  <paul@codesourcery.com>
 
 	Backport from mainline.
-	* gcc/config/arm/arm.c (minipool_pad): New.
+	* config/arm/arm.c (minipool_pad): New.
 	(add_minipool_forward_ref): Include pool alignment padding in address
 	calculation.
 	(push_minipool_fix): Set minipool_pad.
@@ -3072,14 +4023,14 @@
 
 2006-01-31  Nathan Sidwell  <nathan@codesourcery.com>
 
-	* gcc/config/m68k/lb1sf68.asm: Use moveq to load small constants.
+	* config/m68k/lb1sf68.asm: Use moveq to load small constants.
 
 2006-01-31  Richard Guenther  <rguenther@suse.de>
 
 	Backport
 	2006-01-03  Adrian Straetling  <straetling@de.ibm.com>
 
-	* gcc/builtins.c (get_builtin_sync_mem): New function.
+	* builtins.c (get_builtin_sync_mem): New function.
 	(expand_builtin_sync_operation, expand_builtin_compare_and_swap,
 	expand_builtin_lock_test_and_set, expand_builtin_lock_release):
 	Call get_builtin_sync_mem to generate mem rtx.
@@ -3250,7 +4201,7 @@
 
 2006-01-19  Paul Brook  <paul@codesourcery.com>
 
-	* gcc/config/arm/arm.c (arm_compute_func_type): Treat all functions
+	* config/arm/arm.c (arm_compute_func_type): Treat all functions
 	as nothrow when unwinding tables are disabled.
 
 2006-01-19  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
@@ -4398,7 +5349,7 @@
 	(_Unwind_Stop_Fn): New typedef.
 	(_Unwind_ForcedUnwind): Declare.
 	(_Unwind_Resume_or_Rethrow): Declare.
-	* gcc/config/arm/libunwind.S (UNWIND_WRAPER): Add nargs
+	* config/arm/libunwind.S (UNWIND_WRAPER): Add nargs
 	argument.  Adjust.
 	(_Unwind_Resume_or_Rethrow, _Unwind_ForcedUnwind): New.
 	* config/arm/unwind-arm.c (UCB_FORCED_STOP_FN)
@@ -5266,8 +6217,8 @@
 2005-11-04  Francois-Xavier Coudert  <coudert@clipper.ens.fr>
 
 	PR fortran/18452
-	* gcc/c.opt: Add a -lang-fortran option.
-	* gcc/c-opts.c: Add a lang_fortran flag.
+	* c.opt: Add a -lang-fortran option.
+	* c-opts.c: Add a lang_fortran flag.
 	(c_common_init_options): Handling the -lang-fortran option.
 	(c_common_handle_option): Add a case for Fortran options in
 	preprocessing. Remove cases for -ffixed-form and
diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
index 4ac23d4e4d7..1c2bd7cba60 100644
--- a/gcc/DATESTAMP
+++ b/gcc/DATESTAMP
@@ -1 +1 @@
-20070214
+20080704
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 96a55ad6999..5cadef2af9d 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -391,7 +391,9 @@ CROSS_SYSTEM_HEADER_DIR = @CROSS_SYSTEM_HEADER_DIR@
 # Purge it of unneccessary internal relative paths
 # to directories that might not exist yet.
 # The sed idiom for this is to repeat the search-and-replace until it doesn't match, using :a ... ta.
-SYSTEM_HEADER_DIR = `echo @SYSTEM_HEADER_DIR@ | sed -e :a -e "s,[^/]*/\.\.\/,," -e ta`
+# Use single quotes here to avoid nested double- and backquotes, this
+# macro is also used in a double-quoted context.
+SYSTEM_HEADER_DIR = `echo @SYSTEM_HEADER_DIR@ | sed -e :a -e 's,[^/]*/\.\.\/,,' -e ta`
 
 # Control whether to run fixproto and fixincludes.
 STMP_FIXPROTO = @STMP_FIXPROTO@
@@ -1933,7 +1935,7 @@ tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
    function.h $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \
    $(TREE_DUMP_H) tree-pass.h $(PARAMS_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \
    hard-reg-set.h $(TREE_GIMPLE_H) vec.h tree-ssa-structalias.h \
-   $(IPA_TYPE_ESCAPE_H)
+   $(IPA_TYPE_ESCAPE_H) pointer-set.h
 tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \
    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TIMEVAR_H) \
    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) tree-iterator.h\
@@ -2420,7 +2422,7 @@ modulo-sched.o : modulo-sched.c $(DDG_H) $(CONFIG_H) $(CONFIG_H) $(SYSTEM_H) \
    cfghooks.h $(DF_H) $(GCOV_IO_H) hard-reg-set.h $(TM_H) timevar.h tree-pass.h
 haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h function.h \
-   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H)
+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H) $(PARAMS_H)
 sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
    function.h $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h cselib.h \
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index 1904e671c9a..8fb60d2b6ef 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,32 @@
+2008-02-20  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	PR documentation/15479
+	* gnat_ugn.texi: In non-code, avoid space before colon.
+	(Regular Expressions in gnatfind and gnatxref): Fix indentation.
+	(Examples of gnatxref Usage): Use @command{vi} instead of
+	@file{vi}.
+	(Character Set Control): Do not use @code for UTF-8.
+	(Validity Checking): Fix typo "NaNs" instead of "NaN's".  Do not
+	use @code for IEEE.
+	* gnat_rm.texi (Aggregates with static bounds): Fix typo in code
+	sample.
+	* gnat_rm.texi, gnat_ugn.texi: Fix typos.  Bump copyright years.
+
+2007-02-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/30684
+	Backport from 4.2 branch:
+	2006-11-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* ada-tree.h (DECL_READONLY_ONCE_ELAB): New macro.
+	* decl.c (elaborate_expression_1): Test the DECL_READONLY_ONCE_ELAB
+	flag in addition to TREE_READONLY to assert the constantness of
+	variables for elaboration purposes.
+	* trans.c (add_decl_expr): Do not dynamically elaborate padded objects
+	if the initializer takes into account the padding.
+	Set DECL_READONLY_ONCE_ELAB flag on variables originally TREE_READONLY
+	but whose elaboration cannot be performed statically.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
@@ -24,8 +53,8 @@
 
 2006-06-06  Laurent GUERBY  <laurent@guerby.net>
 
-        PR ada/27769
-        mlib-utl.adb: Use Program_Name.
+	PR ada/27769
+	* mlib-utl.adb: Use Program_Name.
 
 2006-05-24  Release Manager
 
@@ -48,20 +77,19 @@
 
 	Backport:
 	2005-12-05  Paolo Bonzini  <bonzini@gnu.org>
-        * Makefile.in (gnatlib): Fix regex, using \. instead of . when a
+	* Makefile.in (gnatlib): Fix regex, using \. instead of . when a
 	period is meant.
-	
+
 2006-02-17  Eric Botcazou  <ebotcazou@adacore.com>
 
 	Backport from mainline:
 	2006-02-13  Geert Bosch  <bosch@adacore.com>
-	            Gary Dismukes  <dismukes@adacore.com>
+		    Gary Dismukes  <dismukes@adacore.com>
 
 	* a-tifiio.adb (Put_Digits): Test Last against To'First - 1 instead of
 	0, since the lower bound of the actual string may be greater than one.
 
 	PR ada/20753
-
 	(Put): Fix condition to raise Layout_Error when invalid
 	layout is requested.
 
@@ -123,8 +151,8 @@
 
 2005-11-18  Laurent GUERBY  <laurent@guerby.net>
 
-        PR ada/24857
-        * Makefile.in: Use s-auxdec-empty for RTEMS.
+	PR ada/24857
+	* Makefile.in: Use s-auxdec-empty for RTEMS.
 
 2005-11-17  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>
 
@@ -138,15 +166,15 @@
 
 	PR ada/24857
 	* s-auxdec-empty.ads, s-auxdec-empty.adb: New files.
-	
+
 2005-11-16  Richard Guenther  <rguenther@suse.de>
 
 	* Makefile.in: Add EH_MECHANISM=-gcc to s390(x) linux.
 
 2005-11-16  Joel Sherrill <joel.sherrill@oarcorp.com>
 
-        PR ada/24855
-        * raise-gcc.c: Add missing stdarg.h include.
+	PR ada/24855
+	* raise-gcc.c: Add missing stdarg.h include.
  
 2005-11-16  Richard Guenther  <rguenther@suse.de>
 
@@ -214,7 +242,6 @@
 	    Ed Schonberg  <schonberg@adacore.com>
 
 	PR ada/18434
-
 	* types.ads: Include All_Checks in Suppress_Array
 
 	* checks.adb (Check_Needed): Remove kludge for a/=b rewritten as
@@ -337,7 +364,7 @@
 	(Save_Occurrence_And_Private): Move GCC EH related code to
 	a-exexpr-gcc.adb
 	(Raise_Current_Excep): Add new variable Id with pragma
-        volatile, to ensure that the variable lives on stack.
+	volatile, to ensure that the variable lives on stack.
 
 	* a-exexpr-gcc.adb, raise-gcc.c: New file.
 
@@ -1142,7 +1169,6 @@
 	    Javier Miranda  <miranda@adacore.com>
 
 	PR ada/15604
-
 	* sem_type.adb (Covers): In an inlined body, a composite type matches
 	a private type whose full view is a composite type.
 	(Interface_Present_In_Ancestor): Protect the frontend against
@@ -2449,9 +2475,9 @@
 	subprogram Complete_Subprograms_Derivation already does the
 	job associated with the second call.
 
-        * exp_strm.adb (Build_Elementary_Input_Call): Add an explicit
-        conversion to the full view when generating an operation for a
-        discriminant whose type may currently be private.
+	* exp_strm.adb (Build_Elementary_Input_Call): Add an explicit
+	conversion to the full view when generating an operation for a
+	discriminant whose type may currently be private.
 
 2005-09-01  Ed Schonberg  <schonberg@adacore.com>
 	    Javier Miranda  <miranda@adacore.com>
@@ -2836,7 +2862,6 @@
 2005-07-07  Olivier Hainque  <hainque@adacore.com>
 
 	PR ada/22301
-
 	* raise.c: Only include unwind.h if IN_RTS, and provide dummy type
 	definitions for the Unwind wrappers in the compiler case.
 
@@ -2948,10 +2973,10 @@
 	N_Object_Declaration, only perform the checks if the Object_Definition
 	is not an Access_Definition.
 
-        * sem_ch3.adb (Access_Subprogram_Declaration): Add test for the case
-        where the parent of an the access definition is an N_Object_Declaration
-        when determining the Associated_Node_For_Itype and scope of an
-        anonymous access-to-subprogram type.
+	* sem_ch3.adb (Access_Subprogram_Declaration): Add test for the case
+	where the parent of an the access definition is an N_Object_Declaration
+	when determining the Associated_Node_For_Itype and scope of an
+	anonymous access-to-subprogram type.
 
 	* exp_ch6.adb (Expand_N_Subprogram_Declaration): Set the
 	Corresponding_Spec on the body created for a null procedure. Add ???
@@ -3134,7 +3159,6 @@
 2005-07-04  Robert Dewar  <dewar@adacore.com>
 
 	PR ada/22039
-
 	* s-sopco3.ads, s-sopco4.ads, s-sopco5.ads: Minor documentation fix
 
 2005-07-04  Matthew Gingell  <gingell@adacore.com>
@@ -3186,19 +3210,19 @@
 
 2005-07-04  Sergey Rybin  <rybin@adacore.com>
 
-        * gnat_ugn.texi: Add description of --eol gnatpp option
+	* gnat_ugn.texi: Add description of --eol gnatpp option
 
 2005-07-04  Eric Botcazou  <ebotcazou@adacore.com>
 	    Thomas Quinot  <quinot@adacore.com>
 
-        * gnat_rm.texi: Add a note that pragma Unreferenced is not appropriate
+	* gnat_rm.texi: Add a note that pragma Unreferenced is not appropriate
 	if the user wants all calls of a subprogram to be flagged,
 	independently of whether they are made from within the same unit or
 	another unit.
-        Mention restriction for pragma Linker_Alias on some platforms.
-        Document pragma Linker_Constructor and Linker_Destructor.
-        Rewrite documentation of Weak_External, Linker_Section and
-        Linker_Alias pragmas.
+	Mention restriction for pragma Linker_Alias on some platforms.
+	Document pragma Linker_Constructor and Linker_Destructor.
+	Rewrite documentation of Weak_External, Linker_Section and
+	Linker_Alias pragmas.
 
 2005-07-04  Arnaud Charlet  <charlet@adacore.com>
 
@@ -4165,8 +4189,8 @@
 	s-valwch.ads, s-widwch.adb, s-widwch.ads, s-wwdcha.adb, s-wwdwch.adb:
 	Rewrite to correspond to new wide character names in AI-395
 
-        * par-ch12.adb (P_Formal_Subprogram_Declaration): Recognize null
-        default procedures.
+	* par-ch12.adb (P_Formal_Subprogram_Declaration): Recognize null
+	default procedures.
 
 2005-06-14  Ed Schonberg  <schonberg@adacore.com>
 	    Robert Dewar  <dewar@adacore.com>
@@ -4255,7 +4279,6 @@
 2005-06-14  Thomas Quinot  <quinot@adacore.com>
 
 	PR ada/6717
-
 	* g-socket.ads, g-socket.adb (Inet_Addr): Special case the all-ones
 	broadcast address.
 	(Create_Selector): Bind listening socket used to create the signalling
@@ -4327,15 +4350,15 @@
 	For objects and parameters of a generic private type, retain the '*'
 	indicator to distinguish such an entity from its type.
 
-        * ali.ads (Xref_Entity_Record): New fields Iref_File_Num and Iref_Line,
-        to store information about instantiated entities.
+	* ali.ads (Xref_Entity_Record): New fields Iref_File_Num and Iref_Line,
+	to store information about instantiated entities.
 
-        * ali.adb (Scan_ALI): Add support for parsing the reference to the
-        generic parent
+	* ali.adb (Scan_ALI): Add support for parsing the reference to the
+	generic parent
 
-        * xref_lib.adb (Skip_To_Matching_Closing_Bracket): New subprogram
-        (Parse_Identifier_Info, Parse_Token): Add support for the generic parent
-        information.
+	* xref_lib.adb (Skip_To_Matching_Closing_Bracket): New subprogram
+	(Parse_Identifier_Info, Parse_Token): Add support for the generic parent
+	information.
 
 2005-06-10  Doug Rupp  <rupp@adacore.com>
 	    Arnaud Charlet  <charlet@adacore.com>
@@ -4398,7 +4421,6 @@
 2005-06-14  Robert Dewar  <dewar@adacore.com>
 
 	PR ada/15613
-
 	* par-ch2.adb (Scan_Pragma_Argument): New procedure
 	(P_Pragma): Implement RM 2.8(4) check for no pos args after named args
 
@@ -4444,11 +4466,11 @@
 	characters are now considered graphic characters and hence yield false
 	in this call.
 
-        * nmake.adt: Modify header so that xnmake does not generate output
-        files with multiple blank lines.
+	* nmake.adt: Modify header so that xnmake does not generate output
+	files with multiple blank lines.
 
-        * treeprs.adt: Remove a blank line so that output from xtreeprs does
-        not have an extra blank line
+	* treeprs.adt: Remove a blank line so that output from xtreeprs does
+	not have an extra blank line
 
 2005-06-14  Gary Dismukes  <dismukes@adacore.com>
 
@@ -4480,7 +4502,6 @@
 	    Ed Schonberg  <schonberg@adacore.com>
 
 	PR ada/10671
-
 	* sem_prag.adb: Implement pragma Persistent_BSS
 	Remove obsolete pragma Persistent_Data, Persistent_Object
 	Set Ada_Version_Explicit, for implementation of AI-362
@@ -4545,8 +4566,8 @@
 	* nmake.adt: Modify header so that xnmake does not generate output
 	files with multiple blank lines.
 
-        * treeprs.adt: Remove a blank line so that output from xtreeprs does
-        not have an extra blank line
+	* treeprs.adt: Remove a blank line so that output from xtreeprs does
+	not have an extra blank line
 
 2005-06-14  Sergey Rybin  <rybin@adacore.com>
 
@@ -4570,7 +4591,7 @@
 	Add UNNECESSARY_BLANK_LINES for -gnatyu
 	Add qualifiers /ALL_PROJECTS (-U) for GNAT PRETTY and GNAT METRIC
 
-        * ug_words: Add entry for -gnaty/Y [NO]ADA_2005_COMPATIBILITY
+	* ug_words: Add entry for -gnaty/Y [NO]ADA_2005_COMPATIBILITY
 
 2005-06-14  Vincent Celier  <celier@adacore.com>
 
@@ -4671,7 +4692,7 @@
 	object directories of project files before directories in ADA_*_PATH
 	environment variables.
 
-        * g-trasym.ads: Document that IRIX is supported
+	* g-trasym.ads: Document that IRIX is supported
 
 2005-06-10  Arnaud Charlet  <charlet@adacore.com>
 
@@ -4766,9 +4787,9 @@
 
 2005-04-16  Laurent GUERBY  <laurent@guerby.net>
 
-        PR ada/18847
-        * a-nudira.adb (Value): Check for valid string.
-        * a-nuflra.adb (Value): Likewise.
+	PR ada/18847
+	* a-nudira.adb (Value): Check for valid string.
+	* a-nuflra.adb (Value): Likewise.
 
 2005-04-11  Richard Sandiford  <rsandifo@redhat.com>
 
@@ -4941,7 +4962,6 @@
 	Generic_Dispatching_Constructor.
 
 	PR ada/20300
-
 	* sem_ch8.adb (Find_Direct_Name): Go to root type for check of
 	character type cases.
 	(Analyze_Subprogram_Renaming): Add special handling for
@@ -5241,13 +5261,12 @@
 
 	* Makefile.in: (ia64-hp-*vms*): Use s-crtl-vms64.ads.
 
-        * 5xcrtl.ads: Renamed to...
-        * s-crtl-vms64.ads: ...this new file
+	* 5xcrtl.ads: Renamed to...
+	* s-crtl-vms64.ads: ...this new file
 
 2005-03-17  Robert Dewar  <dewar@adacore.com>
 
 	PR ada/19519
-
 	* namet.adb (Copy_One_Character): Set proper wide character encoding
 	for upper half character if we have upper half encoding.
 
@@ -5623,7 +5642,6 @@
 2005-03-15  Robert Dewar  <dewar@adacore.com>
 
 	PR ada/13470
-
 	* a-stunau.ads, a-stunau.adb:
 	Change interface to allow efficient (and correct) implementation
 	The previous changes to allow extra space in unbounded strings had
@@ -5786,7 +5804,6 @@
 	PR ada/19408
 	PR ada/19140
 	PR ada/20255
-
 	* decl.c (gnat_to_gnu_field): Reject aliased components with a
 	representation clause that prescribes a size not equal to the rounded
 	size of their types.
@@ -5945,7 +5962,6 @@
 
 	PR ada/20226
 	PR ada/20344
-
 	* init.c (__gnat_initialize): Do not call __gnat_install_SEH_handler()
 	when IN_RTS. This is to work around a bootstrap path problem.
 
@@ -6656,8 +6672,7 @@
 2005-02-09  Eric Botcazou  <ebotcazou@adacore.com>
 	    Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>
 
-	Fix for c330001 - PR ada/19386
-
+	PR ada/19386
 	* decl.c:
 	(gnat_to_gnu_field): Do not necessarily invoke make_packable_type
 	on the field if Pragma Component_Alignment (Storage_Unit).
@@ -6757,7 +6772,6 @@
 2005-02-09  Arnaud Charlet  <charlet@adacore.com>
 
 	PR ada/16592
-
 	* Makefile.in: Link all gnat tools with -static-libgcc, since
 	-shared-libgcc is now used by default on some systems (e.g. linux with
 	recent binutils).
@@ -8547,7 +8561,6 @@
 2004-10-04  Bernard Banner  <banner@gnat.com>
 
 	PR ada/13897
-
 	* Makefile.in: Add section for powerpc linux
 	Add variant i-vxwork-x86.ads
 
@@ -8823,7 +8836,6 @@
 2004-09-23  Robert Dewar  <dewar@gnat.com>
 
 	PR ada/17540
-
 	* sem_prag.adb (Process_Import_Or_Interface): Don't set Is_Public here,
 	instead do this at freeze time (we won't do it if there is an address
 	clause).
@@ -8868,7 +8880,6 @@
 2004-09-20  Robert Dewar  <dewar@gnat.com>
 
 	PR ada/17540
-
 	* freeze.adb (Check_Address_Clause): Reset Is_Imported and Is_Public
 	if an address clause is present, since that means that the Import
 	should be ignored.
@@ -9547,7 +9558,6 @@
 2004-08-09  Ed Schonberg  <schonberg@gnat.com>
 
 	PR ada/15408
-
 	* sem_ch7.adb (Install_Private_Declarations): In the body of the
 	package or of a child, private entities are both immediately_visible
 	and not hidden.
@@ -11085,7 +11095,6 @@
 2004-06-11  Hristian Kirtchev  <kirtchev@gnat.com>
 
 	PR ada/15587
-
 	* einfo.ads: Minor comment updates for Has_Completion and
 	E_Constant list of flags.
 
@@ -11168,7 +11177,6 @@
 2004-06-11  Ed Schonberg  <schonberg@gnat.com>
 
 	PR ada/15403
-
 	* sem_ch12.adb (Save_References): If operator node has been folded to
 	enumeration literal, associated_node must be discarded.
 
@@ -11180,7 +11188,6 @@
 2004-06-08  Arnaud Charlet  <charlet@act-europe.fr>
 
 	PR ada/15568
-
 	* Makefile.in: Remove target specific SO_OPT on IRIX
 
 2004-06-07  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>
@@ -12395,7 +12402,6 @@
 2004-05-03  Olivier Hainque  <hainque@act-europe.fr>
 
 	PR ada/15152
-
 	* exp_ch2.adb (Expand_Current_Value): Leave Machine_Code Asm arguments
 	alone. Replacing object references by literals is inappropriate in a
 	so low level context.
@@ -14726,7 +14732,8 @@
 2004-02-10  Arnaud Charlet  <charlet@act-europe.fr>,
 	    Nathanael Nerode  <neroden@gcc.gnu.org>
 
-	PR ada/6637, PR ada/5911
+	PR ada/6637
+	PR ada/5911
 	Merge with libada-branch:
 	* config-lang.in: Build libada only when ada is built.
 
@@ -15858,7 +15865,6 @@
 	 Fixes ACATS regressions.
 
 	PR ada/13353
-
 	* sem_prag.adb (Back_End_Cannot_Inline): A renaming_as_body can always
 	be inlined.
 
@@ -16095,7 +16101,6 @@
 2003-12-03  Thomas Quinot  <quinot@act-europe.fr>
 
 	PR ada/11724
-
 	* adaint.h, adaint.c, g-os_lib.ads:
 	Do not assume that the offset argument to lseek(2) is a 32 bit integer,
 	on some platforms (including FreeBSD), it is a 64 bit value.
@@ -17119,7 +17124,6 @@
 2003-11-04  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>
 
 	Part of PR ada/12806
-
 	* ada-tree.h (TYPE_DIGITS_VALUE, SET_TYPE_DIGITS_VALUE): Save count as
 	tree, not integer.
 
@@ -17433,7 +17437,7 @@
 
 	* Makefile.generic: Add missing substitution on object_deps handling.
 
-	PR ada/5909:
+	PR ada/5909
 	* Make-lang.in (check-ada): Enable ACATS test suite.
 
 2003-10-27  Robert Dewar  <dewar@gnat.com>
@@ -17502,13 +17506,13 @@
 
 2003-10-24  Pascal Obry  <obry@gnat.com>
 
+	PR ada/12014
 	* adadecode.c (ostrcpy): New function.
 	(__gnat_decode): Use ostrcpy of strcpy.
 	(has_prefix): Set first parameter a const.
 	(has_suffix): Set first parameter a const.
 	Update copyright notice. Fix source name in header.
 	Removes a trailing space.
-	PR ada/12014.
 
 2003-10-24  Jose Ruiz  <ruiz@act-europe.fr>
 
@@ -17583,13 +17587,13 @@
 
 2003-10-23  Thomas Quinot  <quinot@act-europe.fr>
 
-	PR ada/11978:
+	PR ada/11978
 	* exp_ch13.adb (Expand_N_Freeze_Entity): Do not consider inherited
 	External_Tag attribute definition clauses.
 
 2003-10-23  Ed Schonberg  <schonberg@gnat.com>
 
-	PR ada/7613:
+	PR ada/7613
 	* exp_dbug.adb (Debug_Renaming_Declaration): For the renaming of a
 	child unit, generate a fully qualified name to avoid spurious errors
 	when the context contains renamings of different child units with
@@ -17652,7 +17656,8 @@
 
 2003-10-22  Arnaud Charlet  <charlet@act-europe.fr>
 
-	* Makefile.in: Disable build of gnatpsta. PR ada/10110.
+	PR ada/10110
+	* Makefile.in: Disable build of gnatpsta.
 	* cstreams.c (__gnat_full_name): Minor improvements and clean up
 	of previous change.
 
@@ -18187,7 +18192,7 @@
 
 2003-06-04  Olivier Hainque  <hainque@act-europe.fr>
 
-	PR ada/9953:
+	PR ada/9953
 	* 5hsystem.ads: Remove pragma Linker_Option for pthreads library,
 	and turn ZCX_By_Default back to False since the underlying support
 	is not quite there yet.
@@ -18640,7 +18645,7 @@
 
 2003-02-18  Ben Elliston  <bje@redhat.com>
 
-	Part of fix for PR ada/9406
+	Part of PR ada/9406
 	* gnat_ug.texi (Binder output file): Grammar fix.
 
 2003-02-18  Ben Elliston  <bje@redhat.com>
@@ -18749,9 +18754,10 @@
 
 2002-12-14   Geert Bosch <bosch@gnat.com>
 
+	PR ada/5690
 	* sem_ch6.adb (Analyze_Subprogram_Body): Recognize additional
 	case of a body created for a Renaming_As_Body, on which
-	conformance checks are not performed. Fixes PR ada/5690.
+	conformance checks are not performed.
 
 2002-11-30  Zack Weinberg  <zack@codesourcery.com>
 
@@ -18765,7 +18771,9 @@
 	solution to buffer overflow bug on GNU/Linux.
 
 2002-11-14  Nathanael Nerode  <neroden@gcc.gnu.org>
-	Closes PR ada/5856 and PR ada/6919 !
+
+	PR ada/5856
+	PR ada/6919
 	* bindgen.adb: Remove all references to Public_Version.
 	* comperr.adb: Remove all references to Public_Version and
 	GNATPRO_Version; correct bug reporting instructions.
@@ -18774,6 +18782,7 @@
 	GNATPRO version.
 
 2002-11-13  Nathanael Nerode  <neroden@gcc.gnu.org>
+
 	PR ada/6919
 	* adaint.c (__gnat_tmp_name): Remove buffer overflow bug on
 	GNU/Linux.
@@ -18782,21 +18791,25 @@
 	* config-lang.in: Remove diff_excludes.
 
 2002-11-05  Graham Stott  <graham.stott@btinternet.com>
+
 	PR ada/8358
 	* trans.c (gnu_pending_elaboration_lists): New GC root.
 	(build_unit_elab): Use..
 
 2002-10-30   Geert Bosch <bosch@gnat.com>
+
 	PR ada/6558
 	* misc.c : Include optabs.h
 
 	* Make-lang.in (misc.o): Add dependency on optabs.h
 
 2002-10-29   Geert Bosch <bosch@gnat.com>
+
 	PR ada/6558
 	* Make-lang.in (gnatbind): Depend on CONFIG_H
 
 2002-10-29  Geert bosch  <bosch@gnat.com>
+
 	PR ada/6558
 	* misc.c: Unrevert misc.c (1.13)
 
@@ -18806,6 +18819,7 @@
 	maintainership comments.
 
 2002-09-25  Nathanael Nerode  <neroden@gcc.gnu.org>
+
 	PR ada/5904
 	* 5ataprop.adb 5atpopsp.adb 5bosinte.adb 5ftaprop.adb
 	5gtaprop.adb 5htaprop.adb 5rosinte.ads 5staprop.adb
diff --git a/gcc/ada/ada-tree.h b/gcc/ada/ada-tree.h
index befe25a6de0..e1db14d9d0f 100644
--- a/gcc/ada/ada-tree.h
+++ b/gcc/ada/ada-tree.h
@@ -235,6 +235,10 @@ struct lang_type GTY(()) {tree t; };
    discriminant.  */
 #define DECL_STUBBED_P(NODE) DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))
 
+/* Nonzero in a VAR_DECL if it is guaranteed to be constant after having
+   been elaborated and TREE_READONLY is not set on it.  */
+#define DECL_READONLY_ONCE_ELAB(NODE) DECL_LANG_FLAG_0 (VAR_DECL_CHECK (NODE))
+
 /* Nonzero if this decl is always used by reference; i.e., an INDIRECT_REF
    is needed to access the object.  */
 #define DECL_BY_REF_P(NODE) DECL_LANG_FLAG_1 (NODE)
diff --git a/gcc/ada/decl.c b/gcc/ada/decl.c
index bbbb471a3ae..cb0df9cc227 100644
--- a/gcc/ada/decl.c
+++ b/gcc/ada/decl.c
@@ -4732,7 +4732,8 @@ elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,
 
   expr_variable = (!CONSTANT_CLASS_P (gnu_expr)
 		   && !(TREE_CODE (gnu_inner_expr) == VAR_DECL
-			&& TREE_READONLY (gnu_inner_expr))
+			&& (TREE_READONLY (gnu_inner_expr)
+			    || DECL_READONLY_ONCE_ELAB (gnu_inner_expr)))
 		   && !CONTAINS_PLACEHOLDER_P (gnu_expr));
 
   /* If this is a static expression or contains a discriminant, we don't
diff --git a/gcc/ada/gnat_rm.texi b/gcc/ada/gnat_rm.texi
index 9baa081a703..73845ed294e 100644
--- a/gcc/ada/gnat_rm.texi
+++ b/gcc/ada/gnat_rm.texi
@@ -32,7 +32,7 @@
 @end direntry
 
 @copying
-Copyright @copyright{} 1995-2004, Free Software Foundation
+Copyright @copyright{} 1995-2004, 2005, 2008 Free Software Foundation, Inc.
 
 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.2
@@ -1657,7 +1657,7 @@ region as the function to which they apply.
 pragma applies.  If more than one function name exists of this name in
 the declarative part you must use the @code{Parameter_Types} and
 @code{Result_Type} parameters is mandatory to achieve the required
-unique designation.  @var{subtype_ mark}s in these parameters must
+unique designation.  @var{subtype_mark}s in these parameters must
 exactly match the subtypes in the corresponding function specification,
 using positional notation to match parameters with subtype marks.
 The form with an @code{'Access} attribute can be used to match an
@@ -6750,7 +6750,7 @@ See separate section on source representation.
 length.  See 2.2(15).
 @end cartouche
 @noindent
-The maximum line length is 255 characters an the maximum length of a
+The maximum line length is 255 characters and the maximum length of a
 lexical element is also 255 characters.
 
 @sp 1
@@ -7854,7 +7854,7 @@ pragma Linker_Options ("-labc" & ASCII.Nul & "-ldef");
 causes two separate arguments @code{-labc} and @code{-ldef} to be passed to the
 linker. The order of linker options is preserved for a given unit. The final
 list of options passed to the linker is in reverse order of the elaboration
-order. For example, linker options fo a body always appear before the options
+order. For example, linker options for a body always appear before the options
 from the corresponding package spec.
 
 @sp 1
@@ -14068,7 +14068,7 @@ generate the equivalent of
        Cr_Var1 (4) := 11;
 
        for I in Cr_Var2'range loop
-          Cr_Var2 (I) := =-1;
+          Cr_Var2 (I) := -1;
        end loop;
 @end smallexample
 
diff --git a/gcc/ada/gnat_ugn.texi b/gcc/ada/gnat_ugn.texi
index 4f4e5852b30..68eb5675426 100644
--- a/gcc/ada/gnat_ugn.texi
+++ b/gcc/ada/gnat_ugn.texi
@@ -111,7 +111,8 @@
 @c %**end of header
 
 @copying
-Copyright @copyright{} 1995-2005, Free Software Foundation
+Copyright @copyright{} 1995-2005, 2008 Free Software
+Foundation, Inc.
 
 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.2
@@ -5190,9 +5191,9 @@ overwriting may occur.
 @cindex @option{-gnatVf} (@command{gcc})
 In the absence of this switch, validity checking occurs only for discrete
 values. If @option{-gnatVf} is specified, then validity checking also applies
-for floating-point values, and NaN's and infinities are considered invalid,
+for floating-point values, and NaNs and infinities are considered invalid,
 as well as out of range values for constrained types. Note that this means
-that standard @code{IEEE} infinity mode is not allowed. The exact contexts
+that standard IEEE infinity mode is not allowed. The exact contexts
 in which floating-point values are checked depends on the setting of other
 options. For example,
 @option{^-gnatVif^VALIDITY_CHECKING=(IN_PARAMS,FLOATS)^} or
@@ -6159,7 +6160,7 @@ For full details on the these encoding
 methods see @ref{Wide Character Encodings}.
 Note that brackets coding is always accepted, even if one of the other
 options is specified, so for example @option{-gnatW8} specifies that both
-brackets and @code{UTF-8} encodings will be recognized. The units that are
+brackets and UTF-8 encodings will be recognized. The units that are
 with'ed directly or indirectly will be scanned using the specified
 representation scheme, and so if one of the non-brackets scheme is
 used, it must be used consistently throughout the program. However,
@@ -8787,7 +8788,7 @@ $ gnatmake /SOURCE_SEARCH=@i{[INCLUDE_DIR]}
 @item
 Using @command{gnatmake} along with the
 @option{^-m (minimal recompilation)^/MINIMAL_RECOMPILATION^}
-switch provides a mechanism for avoiding unnecessary rcompilations. Using
+switch provides a mechanism for avoiding unnecessary recompilations. Using
 this switch,
 you can update the comments/format of your
 source files without having to recompile everything. Note, however, that
@@ -11393,7 +11394,7 @@ reserved words currently used in project file syntax are:
 @end itemize
 
 @noindent
-Comments in project files have the same syntax as in Ada, two consecutives
+Comments in project files have the same syntax as in Ada, two consecutive
 hyphens through the end of the line.
 
 @node Packages
@@ -14049,7 +14050,7 @@ the source path. If you specify directories, no result is produced.
 @end table
 
 @noindent
-The switches can be :
+The switches can be:
 @table @option
 @c !sort!
 @item ^-a^/ALL_FILES^
@@ -14418,14 +14419,14 @@ specifies the command used to debug the application
 @noindent
 As specified in the section about @command{gnatfind}, the pattern can be a
 regular expression. Actually, there are to set of regular expressions
-which are recognized by the program :
+which are recognized by the program:
 
 @table @code
 @item globbing patterns
 These are the most usual regular expression. They are the same that you
 generally used in a Unix shell command line, or in a DOS session.
 
-Here is a more formal grammar :
+Here is a more formal grammar:
 @smallexample
 @group
 @iftex
@@ -14436,7 +14437,7 @@ term   ::= elmt            -- matches elmt
 term   ::= elmt elmt       -- concatenation (elmt then elmt)
 term   ::= *               -- any string of 0 or more characters
 term   ::= ?               -- matches any character
-term   ::= [char @{char@}] -- matches any character listed
+term   ::= [char @{char@}]   -- matches any character listed
 term   ::= [char - char]   -- matches any character in range
 @end group
 @end smallexample
@@ -14453,9 +14454,9 @@ reference manual style BNF is as follows
 @leftskip=.5cm
 @end iftex
 @group
-regexp ::= term @{| term@} -- alternation (term or term ...)
+regexp ::= term @{| term@}   -- alternation (term or term ...)
 
-term ::= item @{item@}     -- concatenation (item then item)
+term ::= item @{item@}       -- concatenation (item then item)
 
 item ::= elmt              -- match elmt
 item ::= elmt *            -- zero or more elmt's
@@ -14476,7 +14477,7 @@ nschar ::= any character except ()[].*+?^^^
 @end group
 @end smallexample
 
-Following are a few examples :
+Following are a few examples:
 
 @table @samp
 @item abcde|fghi
@@ -14487,7 +14488,7 @@ will match any string like 'abd', 'abcd', 'abccd', 'abcccd', and so on
 
 @item [a-z]+
 will match any string which has only lowercase characters in it (and at
-least one character
+least one character.
 
 @end table
 @end table
@@ -14498,7 +14499,7 @@ least one character
 @subsection General Usage
 
 @noindent
-For the following examples, we will consider the following units :
+For the following examples, we will consider the following units:
 
 @smallexample @c ada
 @group
@@ -14594,9 +14595,9 @@ of these.
 @subsection Using gnatxref with vi
 
 @code{gnatxref} can generate a tags file output, which can be used
-directly from @file{vi}. Note that the standard version of @file{vi}
+directly from @command{vi}. Note that the standard version of @command{vi}
 will not work properly with overloaded symbols. Consider using another
-free implementation of @file{vi}, such as @file{vim}.
+free implementation of @command{vi}, such as @command{vim}.
 
 @smallexample
 $ gnatxref -v gnatfind.adb > tags
@@ -14606,7 +14607,7 @@ $ gnatxref -v gnatfind.adb > tags
 will generate the tags file for @code{gnatfind} itself (if the sources
 are in the search path!).
 
-From @file{vi}, you can then use the command @samp{:tag @i{entity}}
+From @command{vi}, you can then use the command @samp{:tag @i{entity}}
 (replacing @i{entity} by whatever you are looking for), and vi will
 display a new file with the corresponding declaration of entity.
 @end ifclear
@@ -17880,7 +17881,7 @@ GLIB=...
 
 # The directories for the libraries
 # (This macro expands the list of CSC to the list of shared libraries, you
-# could simply use the expanded form :
+# could simply use the expanded form:
 # LIB_DIR=aa/lib/libaa.so bb/lib/libbb.so cc/lib/libcc.so
 LIB_DIR=$@{foreach dir,$@{CSC_LIST@},$@{dir@}/lib/lib$@{dir@}.so@}
 
@@ -19051,7 +19052,7 @@ You can pass it as many Ada files as you want. @code{gnathtml} will generate
 an html file for every ada file, and a global file called @file{index.htm}.
 This file is an index of every identifier defined in the files.
 
-The available switches are the following ones :
+The available switches are the following ones:
 
 @table @option
 @item -83
@@ -19140,7 +19141,7 @@ Operating System via the Internet.
 
 On Unix systems, you  may want to modify  the  first line of  the script
 @code{gnathtml},  to explicitly  tell  the Operating  system  where Perl
-is. The syntax of this line is :
+is. The syntax of this line is:
 @smallexample
 #!full_path_name_to_perl
 @end smallexample
diff --git a/gcc/ada/misc.c b/gcc/ada/misc.c
index 802c739fef2..de99222da18 100644
--- a/gcc/ada/misc.c
+++ b/gcc/ada/misc.c
@@ -370,6 +370,9 @@ gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)
   if (flag_inline_functions)
     flag_inline_trees = 2;
 
+  /* The structural alias analysis machinery essentially assumes that
+     everything is addressable (modulo bit-fields) by disregarding
+     the TYPE_NONALIASED_COMPONENT and DECL_NONADDRESSABLE_P macros.  */
   flag_tree_salias = 0;
 
   /* Do not enable Tree-SRA unless specifically requested as it
diff --git a/gcc/ada/trans.c b/gcc/ada/trans.c
index aadfd6586a1..b90031e304c 100644
--- a/gcc/ada/trans.c
+++ b/gcc/ada/trans.c
@@ -4315,7 +4315,8 @@ add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node)
 void
 add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)
 {
-  tree gnu_stmt;
+  tree type = TREE_TYPE (gnu_decl);
+  tree gnu_stmt, gnu_init, gnu_lhs;
 
   /* If this is a variable that Gigi is to ignore, we may have been given
      an ERROR_MARK.  So test for it.  We also might have been given a
@@ -4323,7 +4324,7 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)
      ignore a TYPE_DECL for an UNCONSTRAINED_ARRAY_TYPE.  */
   if (!DECL_P (gnu_decl)
       || (TREE_CODE (gnu_decl) == TYPE_DECL
-	  && TREE_CODE (TREE_TYPE (gnu_decl)) == UNCONSTRAINED_ARRAY_TYPE))
+	  && TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE))
     return;
 
   /* If we are global, we don't want to actually output the DECL_EXPR for
@@ -4345,41 +4346,32 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)
 	}
     }
 
-  /* If this is a DECL_EXPR for a variable with DECL_INITIAL set,
-     there are two cases we need to handle here.  */
-  if (TREE_CODE (gnu_decl) == VAR_DECL && DECL_INITIAL (gnu_decl))
+  /* If this is a variable and an initializer is attached to it, it must be
+     valid for the context.  Similar to init_const in create_var_decl_1.  */ 
+  if (TREE_CODE (gnu_decl) == VAR_DECL
+      && (gnu_init = DECL_INITIAL (gnu_decl)) != NULL_TREE
+      && (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (gnu_init))
+	  || (TREE_STATIC (gnu_decl)
+	      && !initializer_constant_valid_p (gnu_init,
+						TREE_TYPE (gnu_init)))))
     {
-      tree gnu_init = DECL_INITIAL (gnu_decl);
-      tree gnu_lhs = NULL_TREE;
-
-      /* If this is a DECL_EXPR for a variable with DECL_INITIAL set
-	 and decl has a padded type, convert it to the unpadded type so the
-	 assignment is done properly.  */
-      if (TREE_CODE (TREE_TYPE (gnu_decl)) == RECORD_TYPE
-	  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_decl)))
-	gnu_lhs
-	  = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_decl))), gnu_decl);
-
-      /* Otherwise, if this is going into memory and the initializer isn't
-	 valid for the assembler and loader.  Gimplification could do this,
-	 but would be run too late if -fno-unit-at-a-time.  */
-      else if (TREE_STATIC (gnu_decl)
-	       && !initializer_constant_valid_p (gnu_init,
-						 TREE_TYPE (gnu_decl)))
+      /* If GNU_DECL has a padded type, convert it to the unpadded
+	 type so the assignment is done properly.  */
+      if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))
+	gnu_lhs = convert (TREE_TYPE (TYPE_FIELDS (type)), gnu_decl);
+      else
 	gnu_lhs = gnu_decl;
 
-      if (gnu_lhs)
-	{
-	  tree gnu_assign_stmt
-	    = build_binary_op (MODIFY_EXPR, NULL_TREE,
-			       gnu_lhs, DECL_INITIAL (gnu_decl));
+      gnu_stmt = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_init);
 
-	  DECL_INITIAL (gnu_decl) = 0;
+      DECL_INITIAL (gnu_decl) = NULL_TREE;
+      if (TREE_READONLY (gnu_decl))
+	{
 	  TREE_READONLY (gnu_decl) = 0;
-	  annotate_with_locus (gnu_assign_stmt,
-			       DECL_SOURCE_LOCATION (gnu_decl));
-	  add_stmt (gnu_assign_stmt);
+	  DECL_READONLY_ONCE_ELAB (gnu_decl) = 1;
 	}
+
+      add_stmt_with_node (gnu_stmt, gnat_entity);
     }
 }
 
diff --git a/gcc/builtins.c b/gcc/builtins.c
index c51291b30a4..6fdbc030c24 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -9935,6 +9935,7 @@ fold_builtin_sprintf (tree arglist, int ignored)
   /* Get the destination string and the format specifier.  */
   dest = TREE_VALUE (arglist);
   fmt = TREE_VALUE (TREE_CHAIN (arglist));
+  arglist = TREE_CHAIN (TREE_CHAIN (arglist));
 
   /* Check whether the format is a literal string constant.  */
   fmt_str = c_getstr (fmt);
@@ -9955,6 +9956,10 @@ fold_builtin_sprintf (tree arglist, int ignored)
       if (!fn)
 	return NULL_TREE;
 
+      /* Don't optimize sprintf (buf, "abc", ptr++).  */
+      if (arglist)
+	return NULL_TREE;
+
       /* Convert sprintf (str, fmt) into strcpy (str, fmt) when
 	 'format' is known to contain no % formats.  */
       arglist = build_tree_list (NULL_TREE, fmt);
@@ -9973,8 +9978,12 @@ fold_builtin_sprintf (tree arglist, int ignored)
       if (!fn)
 	return NULL_TREE;
 
+      /* Don't crash on sprintf (str1, "%s").  */
+      if (!arglist)
+	return NULL_TREE;
+
       /* Convert sprintf (str1, "%s", str2) into strcpy (str1, str2).  */
-      orig = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));
+      orig = TREE_VALUE (arglist);
       arglist = build_tree_list (NULL_TREE, orig);
       arglist = tree_cons (NULL_TREE, dest, arglist);
       if (!ignored)
diff --git a/gcc/c-common.c b/gcc/c-common.c
index 9b935f9b9f2..03c855fa0d7 100644
--- a/gcc/c-common.c
+++ b/gcc/c-common.c
@@ -1,6 +1,6 @@
 /* Subroutines shared by all languages that are variants of C.
    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   2001, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -505,6 +505,8 @@ static tree handle_noreturn_attribute (tree *, tree, tree, int, bool *);
 static tree handle_noinline_attribute (tree *, tree, tree, int, bool *);
 static tree handle_always_inline_attribute (tree *, tree, tree, int,
 					    bool *);
+static tree handle_gnu_inline_attribute (tree *, tree, tree, int,
+					 bool *);
 static tree handle_flatten_attribute (tree *, tree, tree, int, bool *);
 static tree handle_used_attribute (tree *, tree, tree, int, bool *);
 static tree handle_unused_attribute (tree *, tree, tree, int, bool *);
@@ -573,6 +575,8 @@ const struct attribute_spec c_common_attribute_table[] =
 			      handle_noinline_attribute },
   { "always_inline",          0, 0, true,  false, false,
 			      handle_always_inline_attribute },
+  { "gnu_inline",             0, 0, true,  false, false,
+			      handle_gnu_inline_attribute },
   { "flatten",                0, 0, true,  false, false,
                               handle_flatten_attribute },
   { "used",                   0, 0, true,  false, false,
@@ -4216,6 +4220,29 @@ handle_always_inline_attribute (tree *node, tree name,
   return NULL_TREE;
 }
 
+/* Handle a "gnu_inline" attribute; arguments as in
+   struct attribute_spec.handler.  */
+
+static tree
+handle_gnu_inline_attribute (tree *node, tree name,
+			     tree ARG_UNUSED (args),
+			     int ARG_UNUSED (flags),
+			     bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (*node))
+    {
+      /* Do nothing else, just set the attribute.  We'll get at
+	 it later with lookup_attribute.  */
+    }
+  else
+    {
+      warning (OPT_Wattributes, "%qE attribute ignored", name);
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
 /* Handle a "flatten" attribute; arguments as in
    struct attribute_spec.handler.  */
 
@@ -5999,6 +6026,12 @@ fold_offsetof_1 (tree expr)
       off = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (TREE_TYPE (expr)), t);
       break;
 
+    case COMPOUND_EXPR:
+      /* Handle static members of volatile structs.  */
+      t = TREE_OPERAND (expr, 1);
+      gcc_assert (TREE_CODE (t) == VAR_DECL);
+      return fold_offsetof_1 (t);
+
     default:
       gcc_unreachable ();
     }
diff --git a/gcc/c-cppbuiltin.c b/gcc/c-cppbuiltin.c
index 9020e0b49f9..261056449de 100644
--- a/gcc/c-cppbuiltin.c
+++ b/gcc/c-cppbuiltin.c
@@ -393,6 +393,8 @@ c_cpp_builtins (cpp_reader *pfile)
   /* Misc.  */
   builtin_define_with_value ("__VERSION__", version_string, 1);
 
+  cpp_define (pfile, "__GNUC_GNU_INLINE__");
+
   /* Definitions for LP64 model.  */
   if (TYPE_PRECISION (long_integer_type_node) == 64
       && POINTER_SIZE == 64
diff --git a/gcc/c-decl.c b/gcc/c-decl.c
index 4ac1031a302..eb69acace4a 100644
--- a/gcc/c-decl.c
+++ b/gcc/c-decl.c
@@ -1644,6 +1644,9 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)
 	  }
     }
 
+  /* Keep the old rtl since we can safely use it.  */
+  if (HAS_RTL_P (olddecl))
+    COPY_DECL_RTL (olddecl, newdecl);
 
   /* Merge the type qualifiers.  */
   if (TREE_READONLY (newdecl))
@@ -3284,7 +3287,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,
 void
 finish_decl (tree decl, tree init, tree asmspec_tree)
 {
-  tree type = TREE_TYPE (decl);
+  tree type;
   int was_incomplete = (DECL_SIZE (decl) == 0);
   const char *asmspec = 0;
 
@@ -3311,6 +3314,8 @@ finish_decl (tree decl, tree init, tree asmspec_tree)
 			    || TREE_CODE (decl) == FIELD_DECL))
     objc_check_decl (decl);
 
+  type = TREE_TYPE (decl);
+
   /* Deduce size of array from initialization, if not already known.  */
   if (TREE_CODE (type) == ARRAY_TYPE
       && TYPE_DOMAIN (type) == 0
diff --git a/gcc/c-opts.c b/gcc/c-opts.c
index 551893f0c1f..4f5f734a59f 100644
--- a/gcc/c-opts.c
+++ b/gcc/c-opts.c
@@ -990,6 +990,12 @@ c_common_post_options (const char **pfilename)
   if (flag_inline_functions)
     flag_inline_trees = 2;
 
+  /* We recognize -fgnu89-inline in preparation for 4.3 where the
+     option will be meaningful.  Here we just reject
+     -fno-gnu89-inline, since we don't support it.  */
+  if (!flag_gnu89_inline)
+    error ("-fno-gnu89-inline is not supported");
+
   /* If we are given more than one input file, we must use
      unit-at-a-time mode.  */
   if (num_in_fnames > 1)
diff --git a/gcc/c.opt b/gcc/c.opt
index 2956847d9c0..2b9b0a0e5f1 100644
--- a/gcc/c.opt
+++ b/gcc/c.opt
@@ -532,6 +532,10 @@ fgnu-runtime
 ObjC ObjC++
 Generate code for GNU runtime environment
 
+fgnu89-inline
+C Var(flag_gnu89_inline) Init(-1)
+Use traditional GNU semantics for inline functions
+
 fguiding-decls
 C++ ObjC++
 
diff --git a/gcc/calls.c b/gcc/calls.c
index df6699a29bd..45001c08ee7 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -1239,13 +1239,25 @@ precompute_arguments (int flags, int num_actuals, struct arg_data *args)
 
   /* If this is a libcall, then precompute all arguments so that we do not
      get extraneous instructions emitted as part of the libcall sequence.  */
-  if ((flags & ECF_LIBCALL_BLOCK) == 0)
+
+  /* If we preallocated the stack space, and some arguments must be passed
+     on the stack, then we must precompute any parameter which contains a
+     function call which will store arguments on the stack.
+     Otherwise, evaluating the parameter may clobber previous parameters
+     which have already been stored into the stack.  (we have code to avoid
+     such case by saving the outgoing stack arguments, but it results in
+     worse code)  */
+  if ((flags & ECF_LIBCALL_BLOCK) == 0 && !ACCUMULATE_OUTGOING_ARGS)
     return;
 
   for (i = 0; i < num_actuals; i++)
     {
       enum machine_mode mode;
 
+      if ((flags & ECF_LIBCALL_BLOCK) == 0
+	  && TREE_CODE (args[i].tree_value) != CALL_EXPR)
+	continue;
+
       /* If this is an addressable type, we cannot pre-evaluate it.  */
       gcc_assert (!TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value)));
 
diff --git a/gcc/collect2.c b/gcc/collect2.c
index f4cc46aad50..b39e61eb961 100644
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -130,6 +130,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
 #define SCAN_LIBRARIES
 #endif
 
+#ifndef SHLIB_SUFFIX
+#define SHLIB_SUFFIX ".so"
+#endif
+
 #ifdef USE_COLLECT2
 int do_collecting = 1;
 #else
@@ -1791,9 +1795,9 @@ write_c_file_stat (FILE *stream, const char *name ATTRIBUTE_UNUSED)
 	}
       else
 	{
-	  if (strncmp (q, ".so", 3) == 0)
+	  if (strncmp (q, SHLIB_SUFFIX, strlen (SHLIB_SUFFIX)) == 0)
 	    {
-	      q += 3;
+	      q += strlen (SHLIB_SUFFIX);
 	      break;
 	    }
 	  else
diff --git a/gcc/combine.c b/gcc/combine.c
index 370b89dcd98..7a732657fed 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -5067,9 +5067,10 @@ simplify_if_then_else (rtx x)
   /* Look for cases where we have (abs x) or (neg (abs X)).  */
 
   if (GET_MODE_CLASS (mode) == MODE_INT
+      && comparison_p
+      && XEXP (cond, 1) == const0_rtx
       && GET_CODE (false_rtx) == NEG
       && rtx_equal_p (true_rtx, XEXP (false_rtx, 0))
-      && comparison_p
       && rtx_equal_p (true_rtx, XEXP (cond, 0))
       && ! side_effects_p (true_rtx))
     switch (true_code)
@@ -5440,14 +5441,14 @@ simplify_set (rtx x)
 	}
       else if (GET_MODE (op0) == compare_mode && op1 == const0_rtx)
 	{
-	  SUBST(SET_SRC (x), op0);
+	  SUBST (SET_SRC (x), op0);
 	  src = SET_SRC (x);
-        }
-      else
+	}
+      /* Otherwise, update the COMPARE if needed.  */
+      else if (XEXP (src, 0) != op0 || XEXP (src, 1) != op1)
 	{
-	  /* Otherwise, update the COMPARE if needed.  */
-	  SUBST (XEXP (src, 0), op0);
-	  SUBST (XEXP (src, 1), op1);
+	  SUBST (SET_SRC (x), gen_rtx_COMPARE (compare_mode, op0, op1));
+	  src = SET_SRC (x);
 	}
     }
   else
diff --git a/gcc/config.gcc b/gcc/config.gcc
index b4c8259b934..3fdfdf52189 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -412,6 +412,10 @@ case ${target} in
       tm_defines="${tm_defines} FBSD_MAJOR=8" ;;
     *-*-freebsd9 | *-*-freebsd[9].*)
       tm_defines="${tm_defines} FBSD_MAJOR=9" ;;
+    *-*-freebsd10 | *-*-freebsd10.*)
+      tm_defines="${tm_defines} FBSD_MAJOR=10" ;;
+    *-*-freebsd11 | *-*-freebsd11.*)
+      tm_defines="${tm_defines} FBSD_MAJOR=11" ;;
     *)
       echo 'Please update *-*-freebsd* in gcc/config.gcc'
       exit 1
diff --git a/gcc/config/alpha/alpha-protos.h b/gcc/config/alpha/alpha-protos.h
index 5dd57343c58..4ead6b3a7dc 100644
--- a/gcc/config/alpha/alpha-protos.h
+++ b/gcc/config/alpha/alpha-protos.h
@@ -51,7 +51,8 @@ extern rtx alpha_legitimize_reload_address (rtx, enum machine_mode,
 extern rtx split_small_symbolic_operand (rtx);
 
 extern void get_aligned_mem (rtx, rtx *, rtx *);
-extern rtx get_unaligned_address (rtx, int);
+extern rtx get_unaligned_address (rtx);
+extern rtx get_unaligned_offset (rtx, HOST_WIDE_INT);
 extern enum reg_class alpha_preferred_reload_class (rtx, enum reg_class);
 extern enum reg_class secondary_reload_class (enum reg_class,
 					      enum machine_mode, rtx, int);
diff --git a/gcc/config/alpha/alpha.c b/gcc/config/alpha/alpha.c
index d8b02361f7e..042bfadd508 100644
--- a/gcc/config/alpha/alpha.c
+++ b/gcc/config/alpha/alpha.c
@@ -1544,7 +1544,7 @@ get_aligned_mem (rtx ref, rtx *paligned_mem, rtx *pbitnum)
    Add EXTRA_OFFSET to the address we return.  */
 
 rtx
-get_unaligned_address (rtx ref, int extra_offset)
+get_unaligned_address (rtx ref)
 {
   rtx base;
   HOST_WIDE_INT offset = 0;
@@ -1564,7 +1564,23 @@ get_unaligned_address (rtx ref, int extra_offset)
   if (GET_CODE (base) == PLUS)
     offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);
 
-  return plus_constant (base, offset + extra_offset);
+  return plus_constant (base, offset);
+}
+
+/* Compute a value X, such that X & 7 == (ADDR + OFS) & 7.
+   X is always returned in a register.  */
+
+rtx
+get_unaligned_offset (rtx addr, HOST_WIDE_INT ofs)
+{
+  if (GET_CODE (addr) == PLUS)
+    {
+      ofs += INTVAL (XEXP (addr, 1));
+      addr = XEXP (addr, 0);
+    }
+
+  return expand_simple_binop (Pmode, PLUS, addr, GEN_INT (ofs & 7),
+			      NULL_RTX, 1, OPTAB_LIB_WIDEN);
 }
 
 /* On the Alpha, all (non-symbolic) constants except zero go into
@@ -2313,7 +2329,7 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)
 	  seq = ((mode == QImode
 		  ? gen_unaligned_loadqi
 		  : gen_unaligned_loadhi)
-		 (subtarget, get_unaligned_address (operands[1], 0),
+		 (subtarget, get_unaligned_address (operands[1]),
 		  temp1, temp2));
 	  alpha_set_memflags (seq, operands[1]);
 	  emit_insn (seq);
@@ -2352,7 +2368,7 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)
 	  rtx seq = ((mode == QImode
 		      ? gen_unaligned_storeqi
 		      : gen_unaligned_storehi)
-		     (get_unaligned_address (operands[0], 0),
+		     (get_unaligned_address (operands[0]),
 		      operands[1], temp1, temp2, temp3));
 
 	  alpha_set_memflags (seq, operands[0]);
@@ -9372,6 +9388,20 @@ alpha_file_start (void)
 #endif
 
 #ifdef OBJECT_FORMAT_ELF
+/* Since we've no .dynbss section, pretend flag_pic is always set, so that
+   we don't wind up with dynamic relocations in .rodata.  */
+
+static void
+alpha_elf_select_section (tree exp, int reloc, unsigned HOST_WIDE_INT align)
+{
+  default_elf_select_section_1 (exp, reloc, align, true);
+}
+
+static void
+alpha_elf_unique_section (tree decl, int reloc)
+{
+  default_unique_section_1 (decl, reloc, true);
+}
 
 /* Switch to the section to which we should output X.  The only thing
    special we do here is to honor small data.  */
@@ -9384,9 +9414,30 @@ alpha_elf_select_rtx_section (enum machine_mode mode, rtx x,
     /* ??? Consider using mergeable sdata sections.  */
     sdata_section ();
   else
-    default_elf_select_rtx_section (mode, x, align);
+    {
+      int save_pic = flag_pic;
+      flag_pic = 1;
+      default_elf_select_rtx_section (mode, x, align);
+      flag_pic = save_pic;
+    }
 }
 
+static unsigned int
+alpha_elf_section_type_flags (tree decl, const char *name, int reloc)
+{
+  unsigned int flags = 0;
+
+  if (strcmp (name, ".sdata") == 0
+      || strncmp (name, ".sdata.", 7) == 0
+      || strncmp (name, ".gnu.linkonce.s.", 16) == 0
+      || strcmp (name, ".sbss") == 0
+      || strncmp (name, ".sbss.", 6) == 0
+      || strncmp (name, ".gnu.linkonce.sb.", 17) == 0)
+    flags = SECTION_SMALL;
+
+  flags |= default_section_type_flags_1 (decl, name, reloc, true);
+  return flags;
+}
 #endif /* OBJECT_FORMAT_ELF */
 
 /* Structure to collect function names for final output in link section.  */
@@ -10601,8 +10652,14 @@ alpha_init_libfuncs (void)
 #endif
 
 #ifdef OBJECT_FORMAT_ELF
+#undef  TARGET_ASM_SELECT_SECTION
+#define TARGET_ASM_SELECT_SECTION  alpha_elf_select_section
+#undef  TARGET_ASM_UNIQUE_SECTION
+#define TARGET_ASM_UNIQUE_SECTION  alpha_elf_unique_section
 #undef	TARGET_ASM_SELECT_RTX_SECTION
 #define	TARGET_ASM_SELECT_RTX_SECTION  alpha_elf_select_rtx_section
+#undef  TARGET_SECTION_TYPE_FLAGS
+#define TARGET_SECTION_TYPE_FLAGS  alpha_elf_section_type_flags
 #endif
 
 #undef TARGET_ASM_FUNCTION_END_PROLOGUE
diff --git a/gcc/config/alpha/alpha.md b/gcc/config/alpha/alpha.md
index d9f9e09e808..6cc25e79671 100644
--- a/gcc/config/alpha/alpha.md
+++ b/gcc/config/alpha/alpha.md
@@ -1607,10 +1607,7 @@
 
   if (unaligned_memory_operand (operands[1], QImode))
     {
-      rtx seq
-	= gen_unaligned_extendqidi (operands[0],
-				    get_unaligned_address (operands[1], 1));
-
+      rtx seq = gen_unaligned_extendqidi (operands[0], XEXP (operands[1], 0));
       alpha_set_memflags (seq, operands[1]);
       emit_insn (seq);
       DONE;
@@ -1670,9 +1667,7 @@
 
   if (unaligned_memory_operand (operands[1], HImode))
     {
-      rtx seq
-	= gen_unaligned_extendhidi (operands[0],
-				    get_unaligned_address (operands[1], 2));
+      rtx seq = gen_unaligned_extendhidi (operands[0], XEXP (operands[1], 0));
 
       alpha_set_memflags (seq, operands[1]);
       emit_insn (seq);
@@ -1687,12 +1682,13 @@
 ;; as a pattern saves one instruction.  The code is similar to that for
 ;; the unaligned loads (see below).
 ;;
-;; Operand 1 is the address + 1 (+2 for HI), operand 0 is the result.
+;; Operand 1 is the address, operand 0 is the result.
 (define_expand "unaligned_extendqidi"
   [(use (match_operand:QI 0 "register_operand" ""))
    (use (match_operand:DI 1 "address_operand" ""))]
   ""
 {
+  operands[0] = gen_lowpart (DImode, operands[0]);
   if (WORDS_BIG_ENDIAN)
     emit_insn (gen_unaligned_extendqidi_be (operands[0], operands[1]));
   else
@@ -1701,48 +1697,40 @@
 })
 
 (define_expand "unaligned_extendqidi_le"
-  [(set (match_dup 2) (match_operand:DI 1 "address_operand" ""))
-   (set (match_dup 3)
-	(mem:DI (and:DI (plus:DI (match_dup 2) (const_int -1))
-			(const_int -8))))
+  [(set (match_dup 3)
+	(mem:DI (and:DI (match_operand:DI 1 "" "") (const_int -8))))
    (set (match_dup 4)
 	(ashift:DI (match_dup 3)
 		   (minus:DI (const_int 64)
 			     (ashift:DI
 			      (and:DI (match_dup 2) (const_int 7))
 			      (const_int 3)))))
-   (set (subreg:DI (match_operand:QI 0 "register_operand" "") 0)
+   (set (match_operand:DI 0 "register_operand" "")
 	(ashiftrt:DI (match_dup 4) (const_int 56)))]
   "! WORDS_BIG_ENDIAN"
 {
-  operands[2] = gen_reg_rtx (DImode);
+  operands[2] = get_unaligned_offset (operands[1], 1);
   operands[3] = gen_reg_rtx (DImode);
   operands[4] = gen_reg_rtx (DImode);
 })
 
 (define_expand "unaligned_extendqidi_be"
-  [(set (match_dup 2) (match_operand:DI 1 "address_operand" ""))
-   (set (match_dup 3) (plus:DI (match_dup 2) (const_int -1)))
+  [(set (match_dup 3)
+	(mem:DI (and:DI (match_operand:DI 1 "" "") (const_int -8))))
    (set (match_dup 4)
-	(mem:DI (and:DI (match_dup 3)
-			(const_int -8))))
-   (set (match_dup 5) (plus:DI (match_dup 2) (const_int -2)))
-   (set (match_dup 6)
-	(ashift:DI (match_dup 4)
+	(ashift:DI (match_dup 3)
 		   (ashift:DI
 		     (and:DI
-		       (plus:DI (match_dup 5) (const_int 1))
+		       (plus:DI (match_dup 2) (const_int 1))
 		       (const_int 7))
 		     (const_int 3))))
-   (set (subreg:DI (match_operand:QI 0 "register_operand" "") 0)
-	(ashiftrt:DI (match_dup 6) (const_int 56)))]
+   (set (match_operand:DI 0 "register_operand" "")
+	(ashiftrt:DI (match_dup 4) (const_int 56)))]
   "WORDS_BIG_ENDIAN"
 {
-  operands[2] = gen_reg_rtx (DImode);
+  operands[2] = get_unaligned_offset (operands[1], -1);
   operands[3] = gen_reg_rtx (DImode);
   operands[4] = gen_reg_rtx (DImode);
-  operands[5] = gen_reg_rtx (DImode);
-  operands[6] = gen_reg_rtx (DImode);
 })
 
 (define_expand "unaligned_extendhidi"
@@ -1751,17 +1739,16 @@
   ""
 {
   operands[0] = gen_lowpart (DImode, operands[0]);
-  emit_insn ((WORDS_BIG_ENDIAN
-	      ? gen_unaligned_extendhidi_be
-	      : gen_unaligned_extendhidi_le) (operands[0], operands[1]));
+  if (WORDS_BIG_ENDIAN)
+    emit_insn (gen_unaligned_extendhidi_be (operands[0], operands[1]));
+  else
+    emit_insn (gen_unaligned_extendhidi_le (operands[0], operands[1]));
   DONE;
 })
 
 (define_expand "unaligned_extendhidi_le"
-  [(set (match_dup 2) (match_operand:DI 1 "address_operand" ""))
-   (set (match_dup 3)
-	(mem:DI (and:DI (plus:DI (match_dup 2) (const_int -2))
-			(const_int -8))))
+  [(set (match_dup 3)
+	(mem:DI (and:DI (match_operand:DI 1 "" "") (const_int -8))))
    (set (match_dup 4)
 	(ashift:DI (match_dup 3)
 		   (minus:DI (const_int 64)
@@ -1772,34 +1759,28 @@
 	(ashiftrt:DI (match_dup 4) (const_int 48)))]
   "! WORDS_BIG_ENDIAN"
 {
-  operands[2] = gen_reg_rtx (DImode);
+  operands[2] = get_unaligned_offset (operands[1], 2);
   operands[3] = gen_reg_rtx (DImode);
   operands[4] = gen_reg_rtx (DImode);
 })
 
 (define_expand "unaligned_extendhidi_be"
-  [(set (match_dup 2) (match_operand:DI 1 "address_operand" ""))
-   (set (match_dup 3) (plus:DI (match_dup 2) (const_int -2)))
+  [(set (match_dup 3)
+	(mem:DI (and:DI (match_operand:DI 1 "" "") (const_int -8))))
    (set (match_dup 4)
-	(mem:DI (and:DI (match_dup 3)
-			(const_int -8))))
-   (set (match_dup 5) (plus:DI (match_dup 2) (const_int -3)))
-   (set (match_dup 6)
-	(ashift:DI (match_dup 4)
+	(ashift:DI (match_dup 3)
 		   (ashift:DI
 		     (and:DI
-		       (plus:DI (match_dup 5) (const_int 1))
+		       (plus:DI (match_dup 2) (const_int 1))
 		       (const_int 7))
 		     (const_int 3))))
    (set (match_operand:DI 0 "register_operand" "")
-	(ashiftrt:DI (match_dup 6) (const_int 48)))]
+	(ashiftrt:DI (match_dup 4) (const_int 48)))]
   "WORDS_BIG_ENDIAN"
 {
-  operands[2] = gen_reg_rtx (DImode);
+  operands[2] = get_unaligned_offset (operands[1], -1);
   operands[3] = gen_reg_rtx (DImode);
   operands[4] = gen_reg_rtx (DImode);
-  operands[5] = gen_reg_rtx (DImode);
-  operands[6] = gen_reg_rtx (DImode);
 })
 
 (define_insn "*extxl_const"
@@ -5997,7 +5978,7 @@
       else
 	scratch = gen_rtx_REG (DImode, REGNO (operands[2]));
 
-      addr = get_unaligned_address (operands[1], 0);
+      addr = get_unaligned_address (operands[1]);
       operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));
       seq = gen_unaligned_loadqi (operands[0], addr, scratch, operands[0]);
       alpha_set_memflags (seq, operands[1]);
@@ -6031,7 +6012,7 @@
       else
 	scratch = gen_rtx_REG (DImode, REGNO (operands[2]));
 
-      addr = get_unaligned_address (operands[1], 0);
+      addr = get_unaligned_address (operands[1]);
       operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));
       seq = gen_unaligned_loadhi (operands[0], addr, scratch, operands[0]);
       alpha_set_memflags (seq, operands[1]);
@@ -6055,7 +6036,7 @@
     }
   else
     {
-      rtx addr = get_unaligned_address (operands[0], 0);
+      rtx addr = get_unaligned_address (operands[0]);
       rtx scratch1 = gen_rtx_REG (DImode, REGNO (operands[2]));
       rtx scratch2 = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);
       rtx scratch3 = scratch1;
@@ -6087,7 +6068,7 @@
     }
   else
     {
-      rtx addr = get_unaligned_address (operands[0], 0);
+      rtx addr = get_unaligned_address (operands[0]);
       rtx scratch1 = gen_rtx_REG (DImode, REGNO (operands[2]));
       rtx scratch2 = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);
       rtx scratch3 = scratch1;
diff --git a/gcc/config/alpha/linux.h b/gcc/config/alpha/linux.h
index d082e873c60..d97934be0bd 100644
--- a/gcc/config/alpha/linux.h
+++ b/gcc/config/alpha/linux.h
@@ -49,6 +49,9 @@ Boston, MA 02110-1301, USA.  */
    %{shared:-lc} \
    %{!shared: %{profile:-lc_p}%{!profile:-lc}}"
 
+#undef CPP_SPEC
+#define CPP_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}"
+
 /* Show that we need a GP when profiling.  */
 #undef TARGET_PROFILING_NEEDS_GP
 #define TARGET_PROFILING_NEEDS_GP 1
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 355e433cbf0..a74d5139332 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -10453,6 +10453,7 @@ arm_get_frame_offsets (void)
   if (leaf && frame_size == 0)
     {
       offsets->outgoing_args = offsets->soft_frame;
+      offsets->locals_base = offsets->soft_frame;
       return offsets;
     }
 
@@ -13782,6 +13783,7 @@ thumb_expand_epilogue (void)
       amount = offsets->locals_base - offsets->saved_regs;
     }
 
+  gcc_assert (amount >= 0);
   if (amount)
     {
       if (amount < 512)
diff --git a/gcc/config/arm/linux-gas.h b/gcc/config/arm/linux-gas.h
index 0544eb04187..a04e0506667 100644
--- a/gcc/config/arm/linux-gas.h
+++ b/gcc/config/arm/linux-gas.h
@@ -28,7 +28,7 @@
 #define DEFAULT_SIGNED_CHAR 0
 
 #undef  SUBTARGET_CPP_SPEC
-#define SUBTARGET_CPP_SPEC  "%{posix:-D_POSIX_SOURCE}"
+#define SUBTARGET_CPP_SPEC  "%{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}"
 
 #undef  SIZE_TYPE
 #define SIZE_TYPE "unsigned int"
diff --git a/gcc/config/avr/avr.c b/gcc/config/avr/avr.c
index 5367bd1fdb2..6833f3558c0 100644
--- a/gcc/config/avr/avr.c
+++ b/gcc/config/avr/avr.c
@@ -1,5 +1,5 @@
 /* Subroutines for insn-output.c for ATMEL AVR micro controllers
-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005
+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2007
    Free Software Foundation, Inc.
    Contributed by Denis Chertykov (denisc@overta.ru)
 
@@ -62,6 +62,7 @@ static RTX_CODE compare_condition (rtx insn);
 static int compare_sign_p (rtx insn);
 static tree avr_handle_progmem_attribute (tree *, tree, tree, int, bool *);
 static tree avr_handle_fndecl_attribute (tree *, tree, tree, int, bool *);
+static tree avr_handle_fntype_attribute (tree *, tree, tree, int, bool *);
 const struct attribute_spec avr_attribute_table[];
 static bool avr_assemble_integer (rtx, unsigned int, int);
 static void avr_file_start (void);
@@ -269,6 +270,8 @@ avr_override_options (void)
   const struct mcu_type_s *t;
   const struct base_arch_s *base;
 
+  flag_delete_null_pointer_checks = 0;
+
   for (t = avr_mcu_types; t->name; t++)
     if (strcmp (t->name, avr_mcu_name) == 0)
       break;
@@ -359,7 +362,7 @@ avr_naked_function_p (tree func)
 
   gcc_assert (TREE_CODE (func) == FUNCTION_DECL);
   
-  a = lookup_attribute ("naked", DECL_ATTRIBUTES (func));
+  a = lookup_attribute ("naked", TYPE_ATTRIBUTES (TREE_TYPE (func)));
   return a != NULL_TREE;
 }
 
@@ -1006,7 +1009,7 @@ ptrreg_to_str (int regno)
     case REG_Y: return "Y";
     case REG_Z: return "Z";
     default:
-      gcc_unreachable ();
+      output_operand_lossage ("address operand requires constraint for X, Y, or Z register");
     }
   return NULL;
 }
@@ -4615,7 +4618,7 @@ const struct attribute_spec avr_attribute_table[] =
   { "progmem",   0, 0, false, false, false,  avr_handle_progmem_attribute },
   { "signal",    0, 0, true,  false, false,  avr_handle_fndecl_attribute },
   { "interrupt", 0, 0, true,  false, false,  avr_handle_fndecl_attribute },
-  { "naked",     0, 0, true,  false, false,  avr_handle_fndecl_attribute },
+  { "naked",     0, 0, false, true,  true,   avr_handle_fntype_attribute },
   { NULL,        0, 0, false, false, false, NULL }
 };
 
@@ -4679,7 +4682,7 @@ avr_handle_fndecl_attribute (tree *node, tree name,
     }
   else
     {
-      const char *func_name = IDENTIFIER_POINTER (DECL_NAME (*node));
+      const char *func_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (*node));
       const char *attr = IDENTIFIER_POINTER (name);
 
       /* If the function has the 'signal' or 'interrupt' attribute, test to
@@ -4707,6 +4710,22 @@ avr_handle_fndecl_attribute (tree *node, tree name,
   return NULL_TREE;
 }
 
+static tree
+avr_handle_fntype_attribute (tree *node, tree name,
+                             tree args ATTRIBUTE_UNUSED,
+                             int flags ATTRIBUTE_UNUSED,
+                             bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) != FUNCTION_TYPE)
+    {
+      warning (OPT_Wattributes, "%qs attribute only applies to functions",
+	       IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
 /* Look for attribute `progmem' in DECL
    if found return 1, otherwise 0.  */
 
@@ -5050,6 +5069,7 @@ avr_rtx_costs (rtx x, int code, int outer_code, int *total)
 	    *total = COSTS_N_INSNS (AVR_MEGA ? 2 : 1);
 	  else
 	    return false;
+	  break;
 
 	case HImode:
 	  if (AVR_ENHANCED)
@@ -5058,6 +5078,7 @@ avr_rtx_costs (rtx x, int code, int outer_code, int *total)
 	    *total = COSTS_N_INSNS (AVR_MEGA ? 2 : 1);
 	  else
 	    return false;
+	  break;
 
 	default:
 	  return false;
diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
index bcd651bb1ed..6975d01395c 100644
--- a/gcc/config/avr/avr.h
+++ b/gcc/config/avr/avr.h
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GNU compiler,
    for ATMEL AVR at90s8515, ATmega103/103L, ATmega603/603L microcontrollers.
-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
    Free Software Foundation, Inc.
    Contributed by Denis Chertykov (denisc@overta.ru)
 
@@ -690,7 +690,11 @@ sprintf (STRING, "*.%s%lu", PREFIX, (unsigned long)(NUM))
 #define ASM_OUTPUT_SKIP(STREAM, N)		\
 fprintf (STREAM, "\t.skip %lu,0\n", (unsigned long)(N))
 
-#define ASM_OUTPUT_ALIGN(STREAM, POWER)
+#define ASM_OUTPUT_ALIGN(STREAM, POWER)			\
+  do {							\
+      if ((POWER) > 1)					\
+          fprintf (STREAM, "\t.p2align\t%d\n", POWER);	\
+  } while (0)
 
 #define CASE_VECTOR_MODE HImode
 
@@ -869,4 +873,6 @@ extern int avr_case_values_threshold;
 
 #define DWARF2_DEBUGGING_INFO 1
 
+#define DWARF2_ADDR_SIZE 4 
+
 #define OBJECT_FORMAT_ELF
diff --git a/gcc/config/avr/avr.md b/gcc/config/avr/avr.md
index 59d35f050e1..c382e824c57 100644
--- a/gcc/config/avr/avr.md
+++ b/gcc/config/avr/avr.md
@@ -448,7 +448,7 @@
    (use (match_operand:QI 1 "register_operand" "r"))
    (use (match_operand:QI 2 "const_int_operand" "n"))
    (clobber (match_scratch:HI 3 "=0"))
-   (clobber (match_scratch:QI 4 "=1"))]
+   (clobber (match_scratch:QI 4 "=&1"))]
   ""
   "st %a0+,__zero_reg__
         dec %1
@@ -462,7 +462,7 @@
    (use (match_operand:HI 1 "register_operand" "!w,d"))
    (use (match_operand:HI 2 "const_int_operand" "n,n"))
    (clobber (match_scratch:HI 3 "=0,0"))
-   (clobber (match_scratch:HI 4 "=1,1"))]
+   (clobber (match_scratch:HI 4 "=&1,&1"))]
   ""
   "*{
      if (which_alternative==0)
diff --git a/gcc/config/freebsd-spec.h b/gcc/config/freebsd-spec.h
index f0e0bcd2e13..e57c2fb06c0 100644
--- a/gcc/config/freebsd-spec.h
+++ b/gcc/config/freebsd-spec.h
@@ -51,11 +51,15 @@ Boston, MA 02110-1301, USA.  */
 #define FBSD_TARGET_OS_CPP_BUILTINS()					\
   do									\
     {									\
-	if (FBSD_MAJOR == 9)						\
-	  builtin_define ("__FreeBSD__=9");			       	\
+	if (FBSD_MAJOR == 11)						\
+	  builtin_define ("__FreeBSD__=11");				\
+	else if (FBSD_MAJOR == 10)					\
+	  builtin_define ("__FreeBSD__=10");				\
+	else if (FBSD_MAJOR == 9)					\
+	  builtin_define ("__FreeBSD__=9");				\
 	else if (FBSD_MAJOR == 8)					\
 	  builtin_define ("__FreeBSD__=8");			       	\
-	if (FBSD_MAJOR == 7)						\
+	else if (FBSD_MAJOR == 7)                                       \
 	  builtin_define ("__FreeBSD__=7");			       	\
 	else if (FBSD_MAJOR == 6)					\
 	  builtin_define ("__FreeBSD__=6");			       	\
diff --git a/gcc/config/i386/emmintrin.h b/gcc/config/i386/emmintrin.h
index 9ee58b6b9b3..d421abb8126 100644
--- a/gcc/config/i386/emmintrin.h
+++ b/gcc/config/i386/emmintrin.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+/* Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
 
    This file is part of GCC.
 
@@ -40,8 +40,10 @@ typedef int __v4si __attribute__ ((__vector_size__ (16)));
 typedef short __v8hi __attribute__ ((__vector_size__ (16)));
 typedef char __v16qi __attribute__ ((__vector_size__ (16)));
 
-typedef __v2di __m128i;
-typedef __v2df __m128d;
+/* The Intel API is flexible enough that we must allow aliasing with other
+   vector types, and their scalar components.  */
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
 
 /* Create a selector for use with the SHUFPD instruction.  */
 #define _MM_SHUFFLE2(fp1,fp0) \
@@ -1060,6 +1062,7 @@ _mm_mul_epu32 (__m128i __A, __m128i __B)
   return (__m128i)__builtin_ia32_pmuludq128 ((__v4si)__A, (__v4si)__B);
 }
 
+#if 0
 static __inline __m128i __attribute__((__always_inline__))
 _mm_slli_epi16 (__m128i __A, int __B)
 {
@@ -1077,7 +1080,16 @@ _mm_slli_epi64 (__m128i __A, int __B)
 {
   return (__m128i)__builtin_ia32_psllqi128 ((__v2di)__A, __B);
 }
+#else
+#define _mm_slli_epi16(__A, __B) \
+  ((__m128i)__builtin_ia32_psllwi128 ((__v8hi)(__A), __B))
+#define _mm_slli_epi32(__A, __B) \
+  ((__m128i)__builtin_ia32_pslldi128 ((__v8hi)(__A), __B))
+#define _mm_slli_epi64(__A, __B) \
+  ((__m128i)__builtin_ia32_psllqi128 ((__v8hi)(__A), __B))
+#endif
 
+#if 0
 static __inline __m128i __attribute__((__always_inline__))
 _mm_srai_epi16 (__m128i __A, int __B)
 {
@@ -1089,18 +1101,24 @@ _mm_srai_epi32 (__m128i __A, int __B)
 {
   return (__m128i)__builtin_ia32_psradi128 ((__v4si)__A, __B);
 }
+#else
+#define _mm_srai_epi16(__A, __B) \
+  ((__m128i)__builtin_ia32_psrawi128 ((__v8hi)(__A), __B))
+#define _mm_srai_epi32(__A, __B) \
+  ((__m128i)__builtin_ia32_psradi128 ((__v8hi)(__A), __B))
+#endif
 
 #if 0
 static __m128i __attribute__((__always_inline__))
-_mm_srli_si128 (__m128i __A, const int __B)
+_mm_srli_si128 (__m128i __A, int __B)
 {
-  return ((__m128i)__builtin_ia32_psrldqi128 (__A, __B))
+  return ((__m128i)__builtin_ia32_psrldqi128 (__A, __B * 8));
 }
 
 static __m128i __attribute__((__always_inline__))
-_mm_srli_si128 (__m128i __A, const int __B)
+_mm_srli_si128 (__m128i __A, int __B)
 {
-  return ((__m128i)__builtin_ia32_pslldqi128 (__A, __B))
+  return ((__m128i)__builtin_ia32_pslldqi128 (__A, __B * 8));
 }
 #else
 #define _mm_srli_si128(__A, __B) \
@@ -1109,6 +1127,7 @@ _mm_srli_si128 (__m128i __A, const int __B)
   ((__m128i)__builtin_ia32_pslldqi128 (__A, (__B) * 8))
 #endif
 
+#if 0
 static __inline __m128i __attribute__((__always_inline__))
 _mm_srli_epi16 (__m128i __A, int __B)
 {
@@ -1126,53 +1145,61 @@ _mm_srli_epi64 (__m128i __A, int __B)
 {
   return (__m128i)__builtin_ia32_psrlqi128 ((__v2di)__A, __B);
 }
+#else
+#define _mm_srli_epi16(__A, __B) \
+  ((__m128i)__builtin_ia32_psrlwi128 ((__v8hi)(__A), __B))
+#define _mm_srli_epi32(__A, __B) \
+  ((__m128i)__builtin_ia32_psrldi128 ((__v4si)(__A), __B))
+#define _mm_srli_epi64(__A, __B) \
+  ((__m128i)__builtin_ia32_psrlqi128 ((__v4si)(__A), __B))
+#endif
 
 static __inline __m128i __attribute__((__always_inline__))
 _mm_sll_epi16 (__m128i __A, __m128i __B)
 {
-  return _mm_slli_epi16 (__A, _mm_cvtsi128_si32 (__B));
+  return (__m128i)__builtin_ia32_psllw128((__v8hi)__A, (__v8hi)__B);
 }
 
 static __inline __m128i __attribute__((__always_inline__))
 _mm_sll_epi32 (__m128i __A, __m128i __B)
 {
-  return _mm_slli_epi32 (__A, _mm_cvtsi128_si32 (__B));
+  return (__m128i)__builtin_ia32_pslld128((__v4si)__A, (__v4si)__B);
 }
 
 static __inline __m128i __attribute__((__always_inline__))
 _mm_sll_epi64 (__m128i __A, __m128i __B)
 {
-  return _mm_slli_epi64 (__A, _mm_cvtsi128_si32 (__B));
+  return (__m128i)__builtin_ia32_psllq128((__v2di)__A, (__v2di)__B);
 }
 
 static __inline __m128i __attribute__((__always_inline__))
 _mm_sra_epi16 (__m128i __A, __m128i __B)
 {
-  return _mm_srai_epi16 (__A, _mm_cvtsi128_si32 (__B));
+  return (__m128i)__builtin_ia32_psraw128 ((__v8hi)__A, (__v8hi)__B);
 }
 
 static __inline __m128i __attribute__((__always_inline__))
 _mm_sra_epi32 (__m128i __A, __m128i __B)
 {
-  return _mm_srai_epi32 (__A, _mm_cvtsi128_si32 (__B));
+  return (__m128i)__builtin_ia32_psrad128 ((__v4si)__A, (__v4si)__B);
 }
 
 static __inline __m128i __attribute__((__always_inline__))
 _mm_srl_epi16 (__m128i __A, __m128i __B)
 {
-  return _mm_srli_epi16 (__A, _mm_cvtsi128_si32 (__B));
+  return (__m128i)__builtin_ia32_psrlw128 ((__v8hi)__A, (__v8hi)__B);
 }
 
 static __inline __m128i __attribute__((__always_inline__))
 _mm_srl_epi32 (__m128i __A, __m128i __B)
 {
-  return _mm_srli_epi32 (__A, _mm_cvtsi128_si32 (__B));
+  return (__m128i)__builtin_ia32_psrld128 ((__v4si)__A, (__v4si)__B);
 }
 
 static __inline __m128i __attribute__((__always_inline__))
 _mm_srl_epi64 (__m128i __A, __m128i __B)
 {
-  return _mm_srli_epi64 (__A, _mm_cvtsi128_si32 (__B));
+  return (__m128i)__builtin_ia32_psrlq128 ((__v2di)__A, (__v2di)__B);
 }
 
 static __inline __m128i __attribute__((__always_inline__))
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 82e5e1bc9fd..af43c4761db 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -12865,6 +12865,9 @@ assign_386_stack_local (enum machine_mode mode, enum ix86_stack_slot n)
 
   gcc_assert (n < MAX_386_STACK_LOCALS);
 
+  /* Virtual slot is valid only before vregs are instantiated.  */
+  gcc_assert ((n == SLOT_VIRTUAL) == !virtuals_instantiated);
+
   for (s = ix86_stack_locals; s; s = s->next)
     if (s->mode == mode && s->n == n)
       return s->rtl;
@@ -14033,7 +14036,7 @@ static const struct builtin_description bdesc_2arg[] =
     BUILTIN_DESC_SWAP_OPERANDS },
   { MASK_SSE, CODE_FOR_sse_vmmaskcmpv4sf3, "__builtin_ia32_cmpngess", IX86_BUILTIN_CMPNGESS, UNGT,
     BUILTIN_DESC_SWAP_OPERANDS },
-  { MASK_SSE, CODE_FOR_sse_vmmaskcmpv4sf3, "__builtin_ia32_cmpordss", IX86_BUILTIN_CMPORDSS, UNORDERED, 0 },
+  { MASK_SSE, CODE_FOR_sse_vmmaskcmpv4sf3, "__builtin_ia32_cmpordss", IX86_BUILTIN_CMPORDSS, ORDERED, 0 },
 
   { MASK_SSE, CODE_FOR_sminv4sf3, "__builtin_ia32_minps", IX86_BUILTIN_MINPS, 0, 0 },
   { MASK_SSE, CODE_FOR_smaxv4sf3, "__builtin_ia32_maxps", IX86_BUILTIN_MAXPS, 0, 0 },
@@ -14576,12 +14579,6 @@ ix86_init_mmx_sse_builtins (void)
   tree v8hi_ftype_v8hi_int
     = build_function_type_list (V8HI_type_node,
 				V8HI_type_node, integer_type_node, NULL_TREE);
-  tree v8hi_ftype_v8hi_v2di
-    = build_function_type_list (V8HI_type_node,
-				V8HI_type_node, V2DI_type_node, NULL_TREE);
-  tree v4si_ftype_v4si_v2di
-    = build_function_type_list (V4SI_type_node,
-				V4SI_type_node, V2DI_type_node, NULL_TREE);
   tree v4si_ftype_v8hi_v8hi
     = build_function_type_list (V4SI_type_node,
 				V8HI_type_node, V8HI_type_node, NULL_TREE);
@@ -14852,16 +14849,16 @@ ix86_init_mmx_sse_builtins (void)
   def_builtin (MASK_SSE2, "__builtin_ia32_pmuludq", di_ftype_v2si_v2si, IX86_BUILTIN_PMULUDQ);
   def_builtin (MASK_SSE2, "__builtin_ia32_pmuludq128", v2di_ftype_v4si_v4si, IX86_BUILTIN_PMULUDQ128);
 
-  def_builtin (MASK_SSE2, "__builtin_ia32_psllw128", v8hi_ftype_v8hi_v2di, IX86_BUILTIN_PSLLW128);
-  def_builtin (MASK_SSE2, "__builtin_ia32_pslld128", v4si_ftype_v4si_v2di, IX86_BUILTIN_PSLLD128);
+  def_builtin (MASK_SSE2, "__builtin_ia32_psllw128", v8hi_ftype_v8hi_v8hi, IX86_BUILTIN_PSLLW128);
+  def_builtin (MASK_SSE2, "__builtin_ia32_pslld128", v4si_ftype_v4si_v4si, IX86_BUILTIN_PSLLD128);
   def_builtin (MASK_SSE2, "__builtin_ia32_psllq128", v2di_ftype_v2di_v2di, IX86_BUILTIN_PSLLQ128);
 
-  def_builtin (MASK_SSE2, "__builtin_ia32_psrlw128", v8hi_ftype_v8hi_v2di, IX86_BUILTIN_PSRLW128);
-  def_builtin (MASK_SSE2, "__builtin_ia32_psrld128", v4si_ftype_v4si_v2di, IX86_BUILTIN_PSRLD128);
+  def_builtin (MASK_SSE2, "__builtin_ia32_psrlw128", v8hi_ftype_v8hi_v8hi, IX86_BUILTIN_PSRLW128);
+  def_builtin (MASK_SSE2, "__builtin_ia32_psrld128", v4si_ftype_v4si_v4si, IX86_BUILTIN_PSRLD128);
   def_builtin (MASK_SSE2, "__builtin_ia32_psrlq128", v2di_ftype_v2di_v2di, IX86_BUILTIN_PSRLQ128);
 
-  def_builtin (MASK_SSE2, "__builtin_ia32_psraw128", v8hi_ftype_v8hi_v2di, IX86_BUILTIN_PSRAW128);
-  def_builtin (MASK_SSE2, "__builtin_ia32_psrad128", v4si_ftype_v4si_v2di, IX86_BUILTIN_PSRAD128);
+  def_builtin (MASK_SSE2, "__builtin_ia32_psraw128", v8hi_ftype_v8hi_v8hi, IX86_BUILTIN_PSRAW128);
+  def_builtin (MASK_SSE2, "__builtin_ia32_psrad128", v4si_ftype_v4si_v4si, IX86_BUILTIN_PSRAD128);
 
   def_builtin (MASK_SSE2, "__builtin_ia32_pslldqi128", v2di_ftype_v2di_int, IX86_BUILTIN_PSLLDQI128);
   def_builtin (MASK_SSE2, "__builtin_ia32_psllwi128", v8hi_ftype_v8hi_int, IX86_BUILTIN_PSLLWI128);
@@ -15341,7 +15338,7 @@ ix86_expand_vec_set_builtin (tree arglist)
   enum machine_mode tmode, mode1;
   tree arg0, arg1, arg2;
   int elt;
-  rtx op0, op1;
+  rtx op0, op1, target;
 
   arg0 = TREE_VALUE (arglist);
   arg1 = TREE_VALUE (TREE_CHAIN (arglist));
@@ -15361,9 +15358,13 @@ ix86_expand_vec_set_builtin (tree arglist)
   op0 = force_reg (tmode, op0);
   op1 = force_reg (mode1, op1);
 
-  ix86_expand_vector_set (true, op0, op1, elt);
+  /* OP0 is the source of these builtin functions and shouldn't be
+     modified.  Create a copy, use it and return it as target.  */
+  target = gen_reg_rtx (tmode);
+  emit_move_insn (target, op0);
+  ix86_expand_vector_set (true, target, op1, elt);
 
-  return op0;
+  return target;
 }
 
 /* Expand an expression EXP that calls a built-in function,
@@ -15496,13 +15497,13 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
 
     case IX86_BUILTIN_LDMXCSR:
       op0 = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);
-      target = assign_386_stack_local (SImode, SLOT_TEMP);
+      target = assign_386_stack_local (SImode, SLOT_VIRTUAL);
       emit_move_insn (target, op0);
       emit_insn (gen_sse_ldmxcsr (target));
       return 0;
 
     case IX86_BUILTIN_STMXCSR:
-      target = assign_386_stack_local (SImode, SLOT_TEMP);
+      target = assign_386_stack_local (SImode, SLOT_VIRTUAL);
       emit_insn (gen_sse_stmxcsr (target));
       return copy_to_mode_reg (SImode, target);
 
@@ -15577,9 +15578,106 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
       emit_insn (pat);
       return target;
 
+    case IX86_BUILTIN_PSLLWI128:
+      icode = CODE_FOR_ashlv8hi3;
+      goto do_pshifti;
+    case IX86_BUILTIN_PSLLDI128:
+      icode = CODE_FOR_ashlv4si3;
+      goto do_pshifti;
+    case IX86_BUILTIN_PSLLQI128:
+      icode = CODE_FOR_ashlv2di3;
+      goto do_pshifti;
+    case IX86_BUILTIN_PSRAWI128:
+      icode = CODE_FOR_ashrv8hi3;
+      goto do_pshifti;
+    case IX86_BUILTIN_PSRADI128:
+      icode = CODE_FOR_ashrv4si3;
+      goto do_pshifti;
+    case IX86_BUILTIN_PSRLWI128:
+      icode = CODE_FOR_lshrv8hi3;
+      goto do_pshifti;
+    case IX86_BUILTIN_PSRLDI128:
+      icode = CODE_FOR_lshrv4si3;
+      goto do_pshifti;
+    case IX86_BUILTIN_PSRLQI128:
+      icode = CODE_FOR_lshrv2di3;
+      goto do_pshifti;
+    do_pshifti:
+      arg0 = TREE_VALUE (arglist);
+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));
+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);
+
+      if (GET_CODE (op1) != CONST_INT)
+	{
+	  error ("shift must be an immediate");
+	  return const0_rtx;
+	}
+      if (INTVAL (op1) < 0 || INTVAL (op1) > 255)
+	op1 = GEN_INT (255);
+
+      tmode = insn_data[icode].operand[0].mode;
+      mode1 = insn_data[icode].operand[1].mode;
+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode1))
+	op0 = copy_to_reg (op0);
+
+      target = gen_reg_rtx (tmode);
+      pat = GEN_FCN (icode) (target, op0, op1);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return target;
+
+    case IX86_BUILTIN_PSLLW128:
+      icode = CODE_FOR_ashlv8hi3;
+      goto do_pshift;
+    case IX86_BUILTIN_PSLLD128:
+      icode = CODE_FOR_ashlv4si3;
+      goto do_pshift;
+    case IX86_BUILTIN_PSLLQ128:
+      icode = CODE_FOR_ashlv2di3;
+      goto do_pshift;
+    case IX86_BUILTIN_PSRAW128:
+      icode = CODE_FOR_ashrv8hi3;
+      goto do_pshift;
+    case IX86_BUILTIN_PSRAD128:
+      icode = CODE_FOR_ashrv4si3;
+      goto do_pshift;
+    case IX86_BUILTIN_PSRLW128:
+      icode = CODE_FOR_lshrv8hi3;
+      goto do_pshift;
+    case IX86_BUILTIN_PSRLD128:
+      icode = CODE_FOR_lshrv4si3;
+      goto do_pshift;
+    case IX86_BUILTIN_PSRLQ128:
+      icode = CODE_FOR_lshrv2di3;
+      goto do_pshift;
+    do_pshift:
+      arg0 = TREE_VALUE (arglist);
+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));
+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);
+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);
+
+      tmode = insn_data[icode].operand[0].mode;
+      mode1 = insn_data[icode].operand[1].mode;
+
+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode1))
+	op0 = copy_to_reg (op0);
+
+      op1 = simplify_gen_subreg (TImode, op1, GET_MODE (op1), 0);
+      if (! (*insn_data[icode].operand[2].predicate) (op1, TImode))
+	op1 = copy_to_reg (op1);
+
+      target = gen_reg_rtx (tmode);
+      pat = GEN_FCN (icode) (target, op0, op1);
+      if (!pat)
+	return 0;
+      emit_insn (pat);
+      return target;
+
     case IX86_BUILTIN_PSLLDQI128:
     case IX86_BUILTIN_PSRLDQI128:
-      icode = (  fcode == IX86_BUILTIN_PSLLDQI128 ? CODE_FOR_sse2_ashlti3
+      icode = (fcode == IX86_BUILTIN_PSLLDQI128 ? CODE_FOR_sse2_ashlti3
 	       : CODE_FOR_sse2_lshrti3);
       arg0 = TREE_VALUE (arglist);
       arg1 = TREE_VALUE (TREE_CHAIN (arglist));
@@ -15600,7 +15698,8 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
 	  return const0_rtx;
 	}
       target = gen_reg_rtx (V2DImode);
-      pat = GEN_FCN (icode) (simplify_gen_subreg (tmode, target, V2DImode, 0), op0, op1);
+      pat = GEN_FCN (icode) (simplify_gen_subreg (tmode, target, V2DImode, 0),
+			     op0, op1);
       if (! pat)
 	return 0;
       emit_insn (pat);
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index 15e3f429500..737fae71aaf 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -2206,7 +2206,8 @@ enum ix86_entity
 
 enum ix86_stack_slot 
 {
-  SLOT_TEMP = 0,
+  SLOT_VIRTUAL = 0,
+  SLOT_TEMP,
   SLOT_CW_STORED,
   SLOT_CW_TRUNC,
   SLOT_CW_FLOOR,
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 6350b501813..4ba03270498 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -3684,7 +3684,7 @@
     ;
   else
     {
-      rtx temp = assign_386_stack_local (SFmode, SLOT_TEMP);
+      rtx temp = assign_386_stack_local (SFmode, SLOT_VIRTUAL);
       emit_insn (gen_truncdfsf2_with_temp (operands[0], operands[1], temp));
       DONE;
     }
@@ -3836,7 +3836,7 @@
       DONE;
     }
   else
-    operands[2] = assign_386_stack_local (SFmode, SLOT_TEMP);
+    operands[2] = assign_386_stack_local (SFmode, SLOT_VIRTUAL);
 })
 
 (define_insn "*truncxfsf2_mixed"
@@ -3934,7 +3934,7 @@
       DONE;
     }
   else
-    operands[2] = assign_386_stack_local (DFmode, SLOT_TEMP);
+    operands[2] = assign_386_stack_local (DFmode, SLOT_VIRTUAL);
 })
 
 (define_insn "*truncxfdf2_mixed"
diff --git a/gcc/config/i386/mmintrin.h b/gcc/config/i386/mmintrin.h
index 252364b803e..e2cf58ed696 100644
--- a/gcc/config/i386/mmintrin.h
+++ b/gcc/config/i386/mmintrin.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
 
    This file is part of GCC.
 
@@ -33,8 +33,9 @@
 #ifndef __MMX__
 # error "MMX instruction set not enabled"
 #else
-/* The data type intended for user use.  */
-typedef int __m64 __attribute__ ((__vector_size__ (8)));
+/* The Intel API is flexible enough that we must allow aliasing with other
+   vector types, and their scalar components.  */
+typedef int __m64 __attribute__ ((__vector_size__ (8), __may_alias__));
 
 /* Internal data types for implementing the intrinsics.  */
 typedef int __v2si __attribute__ ((__vector_size__ (8)));
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 6535d687b3b..7bd8d469be6 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -2723,7 +2723,7 @@
   [(set (match_operand:SSEMODE24 0 "register_operand" "=x")
 	(ashiftrt:SSEMODE24
 	  (match_operand:SSEMODE24 1 "register_operand" "0")
-	  (match_operand:SI 2 "nonmemory_operand" "xi")))]
+	  (match_operand:TI 2 "nonmemory_operand" "xn")))]
   "TARGET_SSE2"
   "psra<ssevecsize>\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseishft")
@@ -2733,7 +2733,7 @@
   [(set (match_operand:SSEMODE248 0 "register_operand" "=x")
 	(lshiftrt:SSEMODE248
 	  (match_operand:SSEMODE248 1 "register_operand" "0")
-	  (match_operand:SI 2 "nonmemory_operand" "xi")))]
+	  (match_operand:TI 2 "nonmemory_operand" "xn")))]
   "TARGET_SSE2"
   "psrl<ssevecsize>\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseishft")
@@ -2743,7 +2743,7 @@
   [(set (match_operand:SSEMODE248 0 "register_operand" "=x")
 	(ashift:SSEMODE248
 	  (match_operand:SSEMODE248 1 "register_operand" "0")
-	  (match_operand:SI 2 "nonmemory_operand" "xi")))]
+	  (match_operand:TI 2 "nonmemory_operand" "xn")))]
   "TARGET_SSE2"
   "psll<ssevecsize>\t{%2, %0|%0, %2}"
   [(set_attr "type" "sseishft")
@@ -2887,7 +2887,7 @@
 	(umin:V16QI (match_operand:V16QI 1 "nonimmediate_operand" "")
 		    (match_operand:V16QI 2 "nonimmediate_operand" "")))]
   "TARGET_SSE2"
-  "ix86_fixup_binary_operands_no_copy (UMAX, V16QImode, operands);")
+  "ix86_fixup_binary_operands_no_copy (UMIN, V16QImode, operands);")
 
 (define_insn "*uminv16qi3"
   [(set (match_operand:V16QI 0 "register_operand" "=x")
@@ -3483,6 +3483,35 @@
   operands[1] = gen_rtx_REG (DImode, REGNO (operands[1]));
 })
 
+(define_insn "*vec_extractv2di_1_sse2"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=m,x,x")
+	(vec_select:DI
+	  (match_operand:V2DI 1 "nonimmediate_operand" "x,0,o")
+	  (parallel [(const_int 1)])))]
+  "TARGET_SSE2 && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
+  "@
+   movhps\t{%1, %0|%0, %1}
+   psrldq\t{$8, %0|%0, 8}
+   movq\t{%H1, %0|%0, %H1}"
+  [(set_attr "type" "ssemov,sseishft,ssemov")
+   (set_attr "memory" "*,none,*")
+   (set_attr "mode" "V2SF,TI,TI")])
+
+;; Not sure this is ever used, but it doesn't hurt to have it. -aoliva
+(define_insn "*vec_extractv2di_1_sse"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=m,x,x")
+	(vec_select:DI
+	  (match_operand:V2DI 1 "nonimmediate_operand" "x,x,o")
+	  (parallel [(const_int 1)])))]
+  "!TARGET_SSE2 && TARGET_SSE
+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
+  "@
+   movhps\t{%1, %0|%0, %1}
+   movhlps\t{%1, %0|%0, %1}
+   movlps\t{%H1, %0|%0, %H1}"
+  [(set_attr "type" "ssemov")
+   (set_attr "mode" "V2SF,V4SF,V2SF")])
+
 (define_insn "*vec_dupv4si"
   [(set (match_operand:V4SI 0 "register_operand" "=Y,x")
 	(vec_duplicate:V4SI
diff --git a/gcc/config/i386/xmmintrin.h b/gcc/config/i386/xmmintrin.h
index b80d6b58ec7..56c15eda291 100644
--- a/gcc/config/i386/xmmintrin.h
+++ b/gcc/config/i386/xmmintrin.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
 
    This file is part of GCC.
 
@@ -40,8 +40,9 @@
 /* Get _mm_malloc () and _mm_free ().  */
 #include <mm_malloc.h>
 
-/* The data type intended for user use.  */
-typedef float __m128 __attribute__ ((__vector_size__ (16)));
+/* The Intel API is flexible enough that we must allow aliasing with other
+   vector types, and their scalar components.  */
+typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));
 
 /* Internal data types for implementing the intrinsics.  */
 typedef float __v4sf __attribute__ ((__vector_size__ (16)));
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index 3355ff6ebd7..9cf221b3365 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -1252,6 +1252,20 @@ mips_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)
   *base = x;
 }
 
+/* Classify symbolic expression X, given that it appears in context
+   CONTEXT.  */
+
+static enum mips_symbol_type
+mips_classify_symbolic_expression (rtx x)
+{
+  HOST_WIDE_INT offset;
+
+  mips_split_const (x, &x, &offset);
+  if (UNSPEC_ADDRESS_P (x))
+    return UNSPEC_ADDRESS_TYPE (x);
+
+  return mips_classify_symbol (x);
+}
 
 /* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points
    to the same object as SYMBOL.  */
@@ -1493,8 +1507,17 @@ mips_classify_address (struct mips_address_info *info, rtx x,
       info->type = ADDRESS_LO_SUM;
       info->reg = XEXP (x, 0);
       info->offset = XEXP (x, 1);
+      /* We have to trust the creator of the LO_SUM to do something vaguely
+	 sane.  Target-independent code that creates a LO_SUM should also
+	 create and verify the matching HIGH.  Target-independent code that
+	 adds an offset to a LO_SUM must prove that the offset will not
+	 induce a carry.  Failure to do either of these things would be
+	 a bug, and we are not required to check for it here.  The MIPS
+	 backend itself should only create LO_SUMs for valid symbolic
+	 constants, with the high part being either a HIGH or a copy
+	 of _gp. */
+      info->symbol_type = mips_classify_symbolic_expression (info->offset);
       return (mips_valid_base_register_p (info->reg, mode, strict)
-	      && mips_symbolic_constant_p (info->offset, &info->symbol_type)
 	      && mips_symbolic_address_p (info->symbol_type, mode)
 	      && mips_lo_relocs[info->symbol_type] != 0);
 
@@ -5575,7 +5598,8 @@ print_operand_reloc (FILE *file, rtx op, const char **relocs)
   rtx base;
   HOST_WIDE_INT offset;
 
-  if (!mips_symbolic_constant_p (op, &symbol_type) || relocs[symbol_type] == 0)
+  symbol_type = mips_classify_symbolic_expression (op);
+  if (relocs[symbol_type] == 0)
     fatal_insn ("PRINT_OPERAND, invalid operand for relocation", op);
 
   /* If OP uses an UNSPEC address, we want to print the inner symbol.  */
@@ -6510,7 +6534,7 @@ mips_emit_loadgp (void)
       offset = mips_unspec_address (addr, SYMBOL_GOTOFF_LOADGP);
       incoming_address = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);
       emit_insn (gen_loadgp (offset, incoming_address));
-      if (!TARGET_EXPLICIT_RELOCS)
+      if (!TARGET_EXPLICIT_RELOCS || current_function_profile)
 	emit_insn (gen_loadgp_blockage ());
     }
 }
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index e2ab7fdb999..2c7922ef789 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -3947,12 +3947,11 @@
 }
   [(set_attr "length" "12")])
 
-;; The use of gp is hidden when not using explicit relocations.
 ;; This blockage instruction prevents the gp load from being
 ;; scheduled after an implicit use of gp.  It also prevents
 ;; the load from being deleted as dead.
 (define_insn "loadgp_blockage"
-  [(unspec_volatile [(reg:DI 28)] UNSPEC_BLOCKAGE)]
+  [(unspec_volatile [(reg:SI 28)] UNSPEC_BLOCKAGE)]
   ""
   ""
   [(set_attr "type"	"unknown")
diff --git a/gcc/config/mips/predicates.md b/gcc/config/mips/predicates.md
index a96e0172149..509657e9f0f 100644
--- a/gcc/config/mips/predicates.md
+++ b/gcc/config/mips/predicates.md
@@ -106,7 +106,9 @@
       /* If -mlong-calls, force all calls to use register addressing.  Also,
 	 if this function has the long_call attribute, we must use register
 	 addressing.  */
-      return !TARGET_LONG_CALLS && !SYMBOL_REF_LONG_CALL_P (op);
+      return (!TARGET_LONG_CALLS
+	      && !(GET_CODE (op) == SYMBOL_REF
+		   && SYMBOL_REF_LONG_CALL_P (op)));
 
     case SYMBOL_GOT_GLOBAL:
       /* Without explicit relocs, there is no special syntax for
diff --git a/gcc/config/pa/pa-hpux.h b/gcc/config/pa/pa-hpux.h
index 4b6c91092f3..8c85dc89f02 100644
--- a/gcc/config/pa/pa-hpux.h
+++ b/gcc/config/pa/pa-hpux.h
@@ -98,7 +98,7 @@ Boston, MA 02110-1301, USA.  */
 #undef LINK_SPEC
 #if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & MASK_PA_11)
 #define LINK_SPEC \
-  "%{!mpa-risc-1-0:%{!march=1.0:%{!shared:-L/lib/pa1.1 -L/usr/lib/pa1.1 }}}%{mlinker-opt:-O} %{!shared:-u main} %{static:-a archive} %{g*:-a archive} %{shared:-b}"
+  "%{!mpa-risc-1-0:%{!march=1.0:%{static:-L/lib/pa1.1 -L/usr/lib/pa1.1 }}}%{mlinker-opt:-O} %{!shared:-u main} %{static:-a archive} %{g*:-a archive} %{shared:-b}"
 #else
 #define LINK_SPEC \
   "%{mlinker-opt:-O} %{!shared:-u main} %{static:-a archive} %{g*:-a archive} %{shared:-b}"
diff --git a/gcc/config/pa/pa-hpux10.h b/gcc/config/pa/pa-hpux10.h
index bc07e5b391a..94429b31863 100644
--- a/gcc/config/pa/pa-hpux10.h
+++ b/gcc/config/pa/pa-hpux10.h
@@ -85,7 +85,7 @@ Boston, MA 02110-1301, USA.  */
 #undef LINK_SPEC
 #if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & MASK_PA_11)
 #define LINK_SPEC \
-  "%{!mpa-risc-1-0:%{!march=1.0:%{!shared:-L/lib/pa1.1 -L/usr/lib/pa1.1 }}}\
+  "%{!mpa-risc-1-0:%{!march=1.0:%{static:-L/lib/pa1.1 -L/usr/lib/pa1.1 }}}\
    %{!shared:%{p:-L/lib/libp %{!static:\
      %nWarning: consider linking with `-static' as system libraries with\n\
      %n  profiling support are only provided in archive format}}}\
diff --git a/gcc/config/pa/pa-hpux11.h b/gcc/config/pa/pa-hpux11.h
index ad16bb41e3f..7a783f8a035 100644
--- a/gcc/config/pa/pa-hpux11.h
+++ b/gcc/config/pa/pa-hpux11.h
@@ -106,18 +106,6 @@ Boston, MA 02110-1301, USA.  */
 /* We can debug dynamically linked executables on hpux11; we also
    want dereferencing of a NULL pointer to cause a SEGV.  */
 #undef LINK_SPEC
-#if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & MASK_PA_11)
-#define LINK_SPEC \
-  "%{!mpa-risc-1-0:%{!march=1.0:%{!shared:-L/lib/pa1.1 -L/usr/lib/pa1.1 }}}\
-   %{!shared:%{p:-L/lib/libp -L/usr/lib/libp %{!static:\
-     %nWarning: consider linking with `-static' as system libraries with\n\
-     %n  profiling support are only provided in archive format}}}\
-   %{!shared:%{pg:-L/lib/libp -L/usr/lib/libp %{!static:\
-     %nWarning: consider linking with `-static' as system libraries with\n\
-     %n  profiling support are only provided in archive format}}}\
-   -z %{mlinker-opt:-O} %{!shared:-u main -u __gcc_plt_call}\
-   %{static:-a archive} %{shared:-b}"
-#else
 #define LINK_SPEC \
   "%{!shared:%{p:-L/lib/libp -L/usr/lib/libp %{!static:\
      %nWarning: consider linking with `-static' as system libraries with\n\
@@ -127,7 +115,6 @@ Boston, MA 02110-1301, USA.  */
      %n  profiling support are only provided in archive format}}}\
    -z %{mlinker-opt:-O} %{!shared:-u main -u __gcc_plt_call}\
    %{static:-a archive} %{shared:-b}"
-#endif
 
 /* hpux 11 has posix threads.  */
 #undef LIB_SPEC
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
index c23df872863..2602c94a0f7 100644
--- a/gcc/config/pa/pa.c
+++ b/gcc/config/pa/pa.c
@@ -607,6 +607,8 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)
   /* Labels need special handling.  */
   if (pic_label_operand (orig, mode))
     {
+      rtx insn;
+
       /* We do not want to go through the movXX expanders here since that
 	 would create recursion.
 
@@ -617,7 +619,24 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)
 	 So instead we just emit the raw set, which avoids the movXX
 	 expanders completely.  */
       mark_reg_pointer (reg, BITS_PER_UNIT);
-      emit_insn (gen_rtx_SET (VOIDmode, reg, orig));
+      insn = emit_insn (gen_rtx_SET (VOIDmode, reg, orig));
+
+      /* Put a REG_EQUAL note on this insn, so that it can be optimized.  */
+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, orig, REG_NOTES (insn));
+
+      /* During and after reload, we need to generate a REG_LABEL note and
+	 update LABEL_NUSES because this is not done automatically.  */
+      if (reload_in_progress || reload_completed)
+	{
+	  /* Extract LABEL_REF.  */
+	  if (GET_CODE (orig) == CONST)
+	    orig = XEXP (XEXP (orig, 0), 0);
+	  /* Extract CODE_LABEL.  */
+	  orig = XEXP (orig, 0);
+	  REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL, orig,
+						REG_NOTES (insn));
+	  LABEL_NUSES (orig)++;
+	}
       current_function_uses_pic_offset_table = 1;
       return reg;
     }
@@ -712,7 +731,10 @@ legitimize_tls_address (rtx addr)
     {
       case TLS_MODEL_GLOBAL_DYNAMIC:
 	tmp = gen_reg_rtx (Pmode);
-	emit_insn (gen_tgd_load (tmp, addr));
+	if (flag_pic)
+	  emit_insn (gen_tgd_load_pic (tmp, addr));
+	else
+	  emit_insn (gen_tgd_load (tmp, addr));
 	ret = hppa_tls_call (tmp);
 	break;
 
@@ -720,7 +742,10 @@ legitimize_tls_address (rtx addr)
 	ret = gen_reg_rtx (Pmode);
 	tmp = gen_reg_rtx (Pmode);
 	start_sequence ();
-	emit_insn (gen_tld_load (tmp, addr));
+	if (flag_pic)
+	  emit_insn (gen_tld_load_pic (tmp, addr));
+	else
+	  emit_insn (gen_tld_load (tmp, addr));
 	t1 = hppa_tls_call (tmp);
 	insn = get_insns ();
 	end_sequence ();
@@ -736,7 +761,10 @@ legitimize_tls_address (rtx addr)
 	tmp = gen_reg_rtx (Pmode);
 	ret = gen_reg_rtx (Pmode);
 	emit_insn (gen_tp_load (tp));
-	emit_insn (gen_tie_load (tmp, addr));
+	if (flag_pic)
+	  emit_insn (gen_tie_load_pic (tmp, addr));
+	else
+	  emit_insn (gen_tie_load (tmp, addr));
 	emit_move_insn (ret, gen_rtx_PLUS (Pmode, tp, tmp));
 	break;
 
@@ -7074,7 +7102,8 @@ attr_length_call (rtx insn, int sibcall)
   /* long pc-relative branch sequence.  */
   else if ((TARGET_SOM && TARGET_LONG_PIC_SDIFF_CALL)
 	   || (TARGET_64BIT && !TARGET_GAS)
-	   || (TARGET_GAS && (TARGET_LONG_PIC_PCREL_CALL || local_call)))
+	   || (TARGET_GAS && !TARGET_SOM
+	       && (TARGET_LONG_PIC_PCREL_CALL || local_call)))
     {
       length += 20;
 
@@ -7185,7 +7214,8 @@ output_call (rtx insn, rtx call_dest, int sibcall)
              they don't allow an instruction in the delay slot.  */
 	  if (!((TARGET_LONG_ABS_CALL || local_call) && !flag_pic)
 	      && !(TARGET_SOM && TARGET_LONG_PIC_SDIFF_CALL)
-	      && !(TARGET_GAS && (TARGET_LONG_PIC_PCREL_CALL || local_call))
+	      && !(TARGET_GAS && !TARGET_SOM
+		   && (TARGET_LONG_PIC_PCREL_CALL || local_call))
 	      && !TARGET_64BIT)
 	    indirect_call = 1;
 
@@ -7245,7 +7275,8 @@ output_call (rtx insn, rtx call_dest, int sibcall)
 					     CODE_LABEL_NUMBER (xoperands[1]));
 		  output_asm_insn ("ldo R'%0-%l1(%%r1),%%r1", xoperands);
 		}
-	      else if (TARGET_GAS && (TARGET_LONG_PIC_PCREL_CALL || local_call))
+	      else if (TARGET_GAS && !TARGET_SOM
+		       && (TARGET_LONG_PIC_PCREL_CALL || local_call))
 		{
 		  /*  GAS currently can't generate the relocations that
 		      are needed for the SOM linker under HP-UX using this
@@ -7533,6 +7564,12 @@ hppa_encode_label (rtx sym)
 static void
 pa_encode_section_info (tree decl, rtx rtl, int first)
 {
+  int old_referenced = 0;
+
+  if (!first && MEM_P (rtl) && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF)
+    old_referenced
+      = SYMBOL_REF_FLAGS (XEXP (rtl, 0)) & SYMBOL_FLAG_REFERENCED;
+
   default_encode_section_info (decl, rtl, first);
 
   if (first && TEXT_SPACE_P (decl))
@@ -7541,6 +7578,8 @@ pa_encode_section_info (tree decl, rtx rtl, int first)
       if (TREE_CODE (decl) == FUNCTION_DECL)
 	hppa_encode_label (XEXP (rtl, 0));
     }
+  else if (old_referenced)
+    SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= old_referenced;
 }
 
 /* This is sort of inverse to pa_encode_section_info.  */
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index 95893ebef4e..9a4bc47d67b 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -39,6 +39,9 @@
    (UNSPEC_TLSLDBASE	7)
    (UNSPEC_TLSIE	8)
    (UNSPEC_TLSLE 	9)
+   (UNSPEC_TLSGD_PIC   10)
+   (UNSPEC_TLSLDM_PIC  11)
+   (UNSPEC_TLSIE_PIC   12)
   ])
 
 ;; UNSPEC_VOLATILE:
@@ -2290,9 +2293,9 @@
 
 (define_insn ""
   [(set (match_operand:SI 0 "move_dest_operand"
-			  "=r,r,r,r,r,r,Q,!*q,!r,!*f,*f,T,!r,!f")
+			  "=r,r,r,r,r,r,Q,!*q,!r,!*f,*f,T,?r,?*f")
 	(match_operand:SI 1 "move_src_operand"
-			  "A,r,J,N,K,RQ,rM,!rM,!*q,!*fM,RT,*f,!f,!r"))]
+			  "A,r,J,N,K,RQ,rM,!rM,!*q,!*fM,RT,*f,*f,r"))]
   "(register_operand (operands[0], SImode)
     || reg_or_0_operand (operands[1], SImode))
    && !TARGET_SOFT_FLOAT
@@ -2932,9 +2935,9 @@
 
 (define_insn ""
   [(set (match_operand:HI 0 "move_dest_operand"
-	 		  "=r,r,r,r,r,Q,!*q,!r,!*f,!r,!f")
+	 		  "=r,r,r,r,r,Q,!*q,!r,!*f,?r,?*f")
 	(match_operand:HI 1 "move_src_operand"
-			  "r,J,N,K,RQ,rM,!rM,!*q,!*fM,!f,!r"))]
+			  "r,J,N,K,RQ,rM,!rM,!*q,!*fM,*f,r"))]
   "(register_operand (operands[0], HImode)
     || reg_or_0_operand (operands[1], HImode))
    && !TARGET_SOFT_FLOAT
@@ -3105,9 +3108,9 @@
 
 (define_insn ""
   [(set (match_operand:QI 0 "move_dest_operand"
-			  "=r,r,r,r,r,Q,!*q,!r,!*f,!r,!f")
+			  "=r,r,r,r,r,Q,!*q,!r,!*f,?r,?*f")
 	(match_operand:QI 1 "move_src_operand"
-			  "r,J,N,K,RQ,rM,!rM,!*q,!*fM,!f,!r"))]
+			  "r,J,N,K,RQ,rM,!rM,!*q,!*fM,*f,r"))]
   "(register_operand (operands[0], QImode)
     || reg_or_0_operand (operands[1], QImode))
    && !TARGET_SOFT_FLOAT
@@ -3907,8 +3910,20 @@
   ""
   "
 {
-  if (GET_CODE (operands[1]) == CONST_DOUBLE && TARGET_64BIT)
-    operands[1] = force_const_mem (DFmode, operands[1]);
+  if (GET_CODE (operands[1]) == CONST_DOUBLE
+      && operands[1] != CONST0_RTX (DFmode))
+    {
+      /* Reject CONST_DOUBLE loads to all hard registers when
+	 generating 64-bit code and to floating point registers
+	 when generating 32-bit code.  */
+      if (REG_P (operands[0])
+	  && HARD_REGISTER_P (operands[0])
+	  && (TARGET_64BIT || REGNO (operands[0]) >= 32))
+	FAIL;
+
+      if (TARGET_64BIT)
+	operands[1] = force_const_mem (DFmode, operands[1]);
+    }
 
   if (emit_move_sequence (operands, DFmode, 0))
     DONE;
@@ -3949,9 +3964,9 @@
 
 (define_insn ""
   [(set (match_operand:DF 0 "move_dest_operand"
-			  "=f,*r,Q,?o,?Q,f,*r,*r,!r,!f")
+			  "=f,*r,Q,?o,?Q,f,*r,*r,?*r,?f")
 	(match_operand:DF 1 "reg_or_0_or_nonsymb_mem_operand"
-			  "fG,*rG,f,*r,*r,RQ,o,RQ,!f,!r"))]
+			  "fG,*rG,f,*r,*r,RQ,o,RQ,f,*r"))]
   "(register_operand (operands[0], DFmode)
     || reg_or_0_operand (operands[1], DFmode))
    && !(GET_CODE (operands[1]) == CONST_DOUBLE
@@ -4123,9 +4138,9 @@
 
 (define_insn ""
   [(set (match_operand:DF 0 "move_dest_operand"
-			  "=r,?o,?Q,r,r,!r,!f")
+			  "=r,?o,?Q,r,r")
 	(match_operand:DF 1 "reg_or_0_or_nonsymb_mem_operand"
-			  "rG,r,r,o,RQ,!f,!r"))]
+			  "rG,r,r,o,RQ"))]
   "(register_operand (operands[0], DFmode)
     || reg_or_0_operand (operands[1], DFmode))
    && !TARGET_64BIT
@@ -4134,14 +4149,14 @@
 {
   return output_move_double (operands);
 }"
-  [(set_attr "type" "move,store,store,load,load,move,move")
-   (set_attr "length" "8,8,16,8,16,12,12")])
+  [(set_attr "type" "move,store,store,load,load")
+   (set_attr "length" "8,8,16,8,16")])
 
 (define_insn ""
   [(set (match_operand:DF 0 "move_dest_operand"
 			  "=!*r,*r,*r,*r,*r,Q,f,f,T")
 	(match_operand:DF 1 "move_src_operand"
-			  "!*r,J,N,K,RQ,*rM,fM,RT,f"))]
+			  "!*r,J,N,K,RQ,*rG,fG,RT,f"))]
   "(register_operand (operands[0], DFmode)
     || reg_or_0_operand (operands[1], DFmode))
    && !TARGET_SOFT_FLOAT && TARGET_64BIT"
@@ -4255,9 +4270,9 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "move_dest_operand"
-			  "=r,o,Q,r,r,r,*f,*f,T,!r,!f")
+			  "=r,o,Q,r,r,r,*f,*f,T,?r,?*f")
 	(match_operand:DI 1 "general_operand"
-			  "rM,r,r,o*R,Q,i,*fM,RT,*f,!f,!r"))]
+			  "rM,r,r,o*R,Q,i,*fM,RT,*f,*f,r"))]
   "(register_operand (operands[0], DImode)
     || reg_or_0_operand (operands[1], DImode))
    && !TARGET_64BIT
@@ -4447,6 +4462,14 @@
   ""
   "
 {
+  /* Reject CONST_DOUBLE loads to floating point registers.  */
+  if (GET_CODE (operands[1]) == CONST_DOUBLE
+      && operands[1] != CONST0_RTX (SFmode)
+      && REG_P (operands[0])
+      && HARD_REGISTER_P (operands[0])
+      && REGNO (operands[0]) >= 32)
+    FAIL;
+
   if (emit_move_sequence (operands, SFmode, 0))
     DONE;
 }")
@@ -4486,9 +4509,9 @@
 
 (define_insn ""
   [(set (match_operand:SF 0 "move_dest_operand"
-			  "=f,!*r,f,*r,Q,Q,!r,!f")
+			  "=f,!*r,f,*r,Q,Q,?*r,?f")
 	(match_operand:SF 1 "reg_or_0_or_nonsymb_mem_operand"
-			  "fG,!*rG,RQ,RQ,f,*rG,!f,!r"))]
+			  "fG,!*rG,RQ,RQ,f,*rG,f,*r"))]
   "(register_operand (operands[0], SFmode)
     || reg_or_0_operand (operands[1], SFmode))
    && !TARGET_SOFT_FLOAT
@@ -6529,7 +6552,7 @@
 				     (match_operand:SI 2 "register_operand" "q")))
 		(match_operand:SI 3 "register_operand" "0")))]
   ; accept ...0001...1, can this be generalized?
-  "exact_log2 (INTVAL (operands[1]) + 1) >= 0"
+  "exact_log2 (INTVAL (operands[1]) + 1) > 0"
   "*
 {
   int x = INTVAL (operands[1]);
@@ -6628,7 +6651,7 @@
 				     (match_operand:DI 2 "register_operand" "q")))
 		(match_operand:DI 3 "register_operand" "0")))]
   ; accept ...0001...1, can this be generalized?
-  "TARGET_64BIT && exact_log2 (INTVAL (operands[1]) + 1) >= 0"
+  "TARGET_64BIT && exact_log2 (INTVAL (operands[1]) + 1) > 0"
   "*
 {
   int x = INTVAL (operands[1]);
@@ -6824,7 +6847,7 @@
 	(and:SI (ashift:SI (match_operand:SI 1 "register_operand" "r")
 			   (match_operand:SI 2 "const_int_operand" ""))
 		(match_operand:SI 3 "const_int_operand" "")))]
-  "exact_log2 (1 + (INTVAL (operands[3]) >> (INTVAL (operands[2]) & 31))) >= 0"
+  "exact_log2 (1 + (INTVAL (operands[3]) >> (INTVAL (operands[2]) & 31))) > 0"
   "*
 {
   int cnt = INTVAL (operands[2]) & 31;
@@ -9528,14 +9551,25 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
 (define_insn "tgd_load"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (unspec:SI [(match_operand 1 "tgd_symbolic_operand" "")] UNSPEC_TLSGD))
-  (clobber (reg:SI 1))]
+  (clobber (reg:SI 1))
+  (use (reg:SI 27))]
   ""
   "*
 {
-  if (flag_pic)
-    return \"addil LT'%1-$tls_gdidx$,%%r19\;ldo RT'%1-$tls_gdidx$(%%r1),%0\";
-  else
-    return \"addil LR'%1-$tls_gdidx$,%%r27\;ldo RR'%1-$tls_gdidx$(%%r1),%0\";
+  return \"addil LR'%1-$tls_gdidx$,%%r27\;ldo RR'%1-$tls_gdidx$(%%r1),%0\";
+}"
+  [(set_attr "type" "multi")
+   (set_attr "length" "8")])
+
+(define_insn "tgd_load_pic"
+ [(set (match_operand:SI 0 "register_operand" "=r")
+       (unspec:SI [(match_operand 1 "tgd_symbolic_operand" "")] UNSPEC_TLSGD_PIC))
+  (clobber (reg:SI 1))
+  (use (reg:SI 19))]
+  ""
+  "*
+{
+  return \"addil LT'%1-$tls_gdidx$,%%r19\;ldo RT'%1-$tls_gdidx$(%%r1),%0\";
 }"
   [(set_attr "type" "multi")
    (set_attr "length" "8")])
@@ -9543,14 +9577,25 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
 (define_insn "tld_load"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (unspec:SI [(match_operand 1 "tld_symbolic_operand" "")] UNSPEC_TLSLDM))
-  (clobber (reg:SI 1))]
+  (clobber (reg:SI 1))
+  (use (reg:SI 27))]
   ""
   "*
 {
-  if (flag_pic)
-    return \"addil LT'%1-$tls_ldidx$,%%r19\;ldo RT'%1-$tls_ldidx$(%%r1),%0\";
-  else
-    return \"addil LR'%1-$tls_ldidx$,%%r27\;ldo RR'%1-$tls_ldidx$(%%r1),%0\";
+  return \"addil LR'%1-$tls_ldidx$,%%r27\;ldo RR'%1-$tls_ldidx$(%%r1),%0\";
+}"
+  [(set_attr "type" "multi")
+   (set_attr "length" "8")])
+
+(define_insn "tld_load_pic"
+ [(set (match_operand:SI 0 "register_operand" "=r")
+       (unspec:SI [(match_operand 1 "tld_symbolic_operand" "")] UNSPEC_TLSLDM_PIC))
+  (clobber (reg:SI 1))
+  (use (reg:SI 19))]
+  ""
+  "*
+{
+  return \"addil LT'%1-$tls_ldidx$,%%r19\;ldo RT'%1-$tls_ldidx$(%%r1),%0\";
 }"
   [(set_attr "type" "multi")
    (set_attr "length" "8")])
@@ -9573,21 +9618,32 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(unspec:SI [(const_int 0)] UNSPEC_TP))]
   ""
-  "{mfctl|mfctl,w} %%cr27,%0"
+  "mfctl %%cr27,%0"
   [(set_attr "type" "multi")
    (set_attr "length" "4")])
 
 (define_insn "tie_load"
   [(set (match_operand:SI 0 "register_operand" "=r")
         (unspec:SI [(match_operand 1 "tie_symbolic_operand" "")] UNSPEC_TLSIE))
-   (clobber (reg:SI 1))]
+   (clobber (reg:SI 1))
+   (use (reg:SI 27))]
   ""
   "*
 {
-  if (flag_pic)
-    return \"addil LT'%1-$tls_ieoff$,%%r19\;ldw RT'%1-$tls_ieoff$(%%r1),%0\";
-  else
-    return \"addil LR'%1-$tls_ieoff$,%%r27\;ldw RR'%1-$tls_ieoff$(%%r1),%0\";
+  return \"addil LR'%1-$tls_ieoff$,%%r27\;ldw RR'%1-$tls_ieoff$(%%r1),%0\";
+}"
+  [(set_attr "type" "multi")
+   (set_attr "length" "8")])
+
+(define_insn "tie_load_pic"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (unspec:SI [(match_operand 1 "tie_symbolic_operand" "")] UNSPEC_TLSIE_PIC))
+   (clobber (reg:SI 1))
+   (use (reg:SI 19))]
+  ""
+  "*
+{
+  return \"addil LT'%1-$tls_ieoff$,%%r19\;ldw RT'%1-$tls_ieoff$(%%r1),%0\";
 }"
   [(set_attr "type" "multi")
    (set_attr "length" "8")])
diff --git a/gcc/config/pa/predicates.md b/gcc/config/pa/predicates.md
index b3835699a8e..219c16c2d57 100644
--- a/gcc/config/pa/predicates.md
+++ b/gcc/config/pa/predicates.md
@@ -206,11 +206,14 @@
 ;; instruction.
 
 (define_predicate "move_src_operand"
-  (match_code "subreg,reg,const_int,mem")
+  (match_code "subreg,reg,const_int,const_double,mem")
 {
   if (register_operand (op, mode))
     return 1;
 
+  if (op == CONST0_RTX (mode))
+    return 1;
+
   if (GET_CODE (op) == CONST_INT)
     return cint_ok_for_move (INTVAL (op));
 
diff --git a/gcc/config/pa/som.h b/gcc/config/pa/som.h
index e397b9dfd8e..9754490d3d8 100644
--- a/gcc/config/pa/som.h
+++ b/gcc/config/pa/som.h
@@ -360,3 +360,7 @@ do {						\
 /* We can't handle weak aliases, and therefore can't support pragma weak.
    Suppress the use of pragma weak in gthr-dce.h and gthr-posix.h.  */
 #define GTHREAD_USE_WEAK 0
+
+/* Shared library suffix.  Collect2 strips the version string after
+   this suffix when generating constructor/destructor names.  */ 
+#define SHLIB_SUFFIX ".sl"
diff --git a/gcc/config/rs6000/linux-unwind.h b/gcc/config/rs6000/linux-unwind.h
index 6e822bde0e2..3e931030d59 100644
--- a/gcc/config/rs6000/linux-unwind.h
+++ b/gcc/config/rs6000/linux-unwind.h
@@ -264,7 +264,10 @@ ppc_fallback_frame_state (struct _Unwind_Context *context,
       }
 
   fs->regs.reg[CR2_REGNO].how = REG_SAVED_OFFSET;
-  fs->regs.reg[CR2_REGNO].loc.offset = (long) &regs->ccr - new_cfa;
+  /* CR? regs are always 32-bit and PPC is big-endian, so in 64-bit
+     libgcc loc.offset needs to point to the low 32 bits of regs->ccr.  */
+  fs->regs.reg[CR2_REGNO].loc.offset = (long) &regs->ccr - new_cfa
+				       + sizeof (long) - 4;
 
   fs->regs.reg[LINK_REGISTER_REGNUM].how = REG_SAVED_OFFSET;
   fs->regs.reg[LINK_REGISTER_REGNUM].loc.offset = (long) &regs->link - new_cfa;
diff --git a/gcc/config/rs6000/predicates.md b/gcc/config/rs6000/predicates.md
index 258eccc54d7..0cf30138ce8 100644
--- a/gcc/config/rs6000/predicates.md
+++ b/gcc/config/rs6000/predicates.md
@@ -691,7 +691,9 @@
 (define_predicate "current_file_function_operand"
   (and (match_code "symbol_ref")
        (match_test "(DEFAULT_ABI != ABI_AIX || SYMBOL_REF_FUNCTION_P (op))
-		    && (SYMBOL_REF_LOCAL_P (op)
+		    && ((SYMBOL_REF_LOCAL_P (op)
+			 && (DEFAULT_ABI != ABI_AIX
+			     || !SYMBOL_REF_EXTERNAL_P (op)))
 		        || (op == XEXP (DECL_RTL (current_function_decl),
 						  0)))")))
 
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 0f76f4562d0..c775552b1a1 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -13327,7 +13327,8 @@ rs6000_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)
 	    }
 	}
       if (DEFAULT_ABI == ABI_DARWIN
-	  || (*targetm.binds_local_p) (decl))
+	  || ((*targetm.binds_local_p) (decl)
+	      && (DEFAULT_ABI != ABI_AIX || !DECL_EXTERNAL (decl))))
 	{
 	  tree attr_list = TYPE_ATTRIBUTES (TREE_TYPE (decl));
 
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index 05c72853f08..11964ddf334 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -9545,6 +9545,7 @@
   ""
   "
 {
+  operands[1] = force_reg (Pmode, operands[1]);
   operands[2] = gen_reg_rtx (Pmode);
   operands[3] = gen_frame_mem (Pmode, operands[0]);
   operands[4] = gen_frame_mem (Pmode, operands[1]);
diff --git a/gcc/config/s390/fixdfdi.h b/gcc/config/s390/fixdfdi.h
index fd12243a381..95a5eef0173 100644
--- a/gcc/config/s390/fixdfdi.h
+++ b/gcc/config/s390/fixdfdi.h
@@ -78,13 +78,15 @@ __fixunstfdi (long double a1)
     if ((EXPD(dl1) == 0x7fff) && !FRACD_ZERO_P (dl1))
       return 0x0ULL;
 
-    /* If the upper ll part of the mantissa isn't
-       zeroed out after shifting the number would be to large.  */
-    if (exp >= -HIGH_LL_FRAC_BITS)
-      return 0xFFFFFFFFFFFFFFFFULL;
-
+    /* One extra bit is needed for the unit bit which is appended by
+       MANTD_HIGH_LL on the left of the matissa.  */
     exp += HIGH_LL_FRAC_BITS + 1;
 
+    /* If the result would still need a left shift it will be to large
+       to be represented.  */
+    if (exp > 0)
+      return 0xFFFFFFFFFFFFFFFFULL;
+
     l = MANTD_LOW_LL (dl1) >> (HIGH_LL_FRAC_BITS + 1)
         | MANTD_HIGH_LL (dl1) << (64 - (HIGH_LL_FRAC_BITS + 1));
 
@@ -118,7 +120,7 @@ union double_long {
   struct {
       SItype_x i[4]; /* 32 bit parts: 0 upper ... 3 lowest */
     } l;
-  DItype_x ll[2];   /* 64 bit parts: 0 upper, 1 lower */
+  UDItype_x ll[2];   /* 64 bit parts: 0 upper, 1 lower */
 };
 
 DItype_x __fixtfdi (long double a1);
@@ -150,17 +152,21 @@ __fixtfdi (long double a1)
     if ((EXPD(dl1) == 0x7fff) && !FRACD_ZERO_P (dl1))
       return 0x8000000000000000ULL;
 
-    /* If the upper ll part of the mantissa isn't
-       zeroed out after shifting the number would be to large.  */
-    if (exp >= -HIGH_LL_FRAC_BITS)
+    /* One extra bit is needed for the unit bit which is appended by
+       MANTD_HIGH_LL on the left of the matissa.  */
+    exp += HIGH_LL_FRAC_BITS + 1;
+
+    /* If the result would still need a left shift it will be to large
+       to be represented.  Compared to the unsigned variant we have to
+       take care that there is still space for the sign bit to be
+       applied.  So we can only go on if there is a right-shift by one
+       or more.  */
+    if (exp >= 0)
       {
-	l = (long long)1 << 63; /* long int min */
+	l = (long long)1 << 63; /* long long int min */
 	return SIGND (dl1) ? l : l - 1;
       }
 
-    /* The extra bit is needed for the sign bit.  */
-    exp += HIGH_LL_FRAC_BITS + 1;
-
     l = MANTD_LOW_LL (dl1) >> (HIGH_LL_FRAC_BITS + 1)
         | MANTD_HIGH_LL (dl1) << (64 - (HIGH_LL_FRAC_BITS + 1));
 
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
index c898378d332..290a3d9937b 100644
--- a/gcc/config/s390/s390.c
+++ b/gcc/config/s390/s390.c
@@ -3540,7 +3540,7 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)
       if (temp != count)
         emit_move_insn (count, temp);
 
-      temp = expand_binop (mode, ashr_optab, count, GEN_INT (8), blocks, 1, 0);
+      temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1, 0);
       if (temp != blocks)
         emit_move_insn (blocks, temp);
 
@@ -3577,10 +3577,12 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)
 void
 s390_expand_setmem (rtx dst, rtx len, rtx val)
 {
-  gcc_assert (GET_CODE (len) != CONST_INT || INTVAL (len) > 0);
+  if (GET_CODE (len) == CONST_INT && INTVAL (len) == 0)
+    return;
+
   gcc_assert (GET_CODE (val) == CONST_INT || GET_MODE (val) == QImode);
   
-  if (GET_CODE (len) == CONST_INT && INTVAL (len) <= 257)
+  if (GET_CODE (len) == CONST_INT && INTVAL (len) > 0 && INTVAL (len) <= 257)
     {
       if (val == const0_rtx && INTVAL (len) <= 256)
         emit_insn (gen_clrmem_short (dst, GEN_INT (INTVAL (len) - 1)));
@@ -3654,7 +3656,7 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)
       if (temp != count)
         emit_move_insn (count, temp);
 
-      temp = expand_binop (mode, ashr_optab, count, GEN_INT (8), blocks, 1, 0);
+      temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1, 0);
       if (temp != blocks)
         emit_move_insn (blocks, temp);
 
@@ -3746,7 +3748,7 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)
       if (temp != count)
         emit_move_insn (count, temp);
 
-      temp = expand_binop (mode, ashr_optab, count, GEN_INT (8), blocks, 1, 0);
+      temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1, 0);
       if (temp != blocks)
         emit_move_insn (blocks, temp);
 
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index 6d994c87944..910fd2bab60 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -1578,7 +1578,7 @@
    && !s_operand (operands[1], VOIDmode)"
   [(set (match_dup 0) (match_dup 1))]
 {
-  rtx addr = operand_subword (operands[0], 1, 0, DFmode);
+  rtx addr = operand_subword (operands[0], 1, 0, TFmode);
   s390_load_address (addr, XEXP (operands[1], 0));
   operands[1] = replace_equiv_address (operands[1], addr);
 })
@@ -5902,7 +5902,7 @@
   "s390_match_ccmode(insn, CCTmode) && TARGET_64BIT"
   "@
    xgr\t%0,%2
-   xr\t%0,%2"
+   xg\t%0,%2"
   [(set_attr "op_type"  "RRE,RXY")])
 
 (define_insn "*xordi3_extimm"
diff --git a/gcc/config/sh/sh.c b/gcc/config/sh/sh.c
index 216bbab447d..df9e146ba7f 100644
--- a/gcc/config/sh/sh.c
+++ b/gcc/config/sh/sh.c
@@ -5154,7 +5154,13 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,
 	      temp = scavenge_reg (&temps);
 	    }
 	  if (temp < 0 && live_regs_mask)
-	    temp = scavenge_reg (live_regs_mask);
+	    {
+	      HARD_REG_SET temps;
+
+	      COPY_HARD_REG_SET (temps, *live_regs_mask);
+	      CLEAR_HARD_REG_BIT (temps, REGNO (reg));
+	      temp = scavenge_reg (&temps);
+	    }
 	  if (temp < 0)
 	    {
 	      rtx adj_reg, tmp_reg, mem;
@@ -5203,6 +5209,9 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,
 	      emit_move_insn (adj_reg, mem);
 	      mem = gen_tmp_stack_mem (Pmode, gen_rtx_POST_INC (Pmode, reg));
 	      emit_move_insn (tmp_reg, mem);
+	      /* Tell flow the insns that pop r4/r5 aren't dead.  */
+	      emit_insn (gen_rtx_USE (VOIDmode, tmp_reg));
+	      emit_insn (gen_rtx_USE (VOIDmode, adj_reg));
 	      return;
 	    }
 	  const_reg = gen_rtx_REG (GET_MODE (reg), temp);
@@ -8477,7 +8486,7 @@ sh_adjust_cost (rtx insn, rtx link ATTRIBUTE_UNUSED, rtx dep_insn, int cost)
       else if (TARGET_SH4
 	       && get_attr_type (insn) == TYPE_DYN_SHIFT
 	       && get_attr_any_int_load (dep_insn) == ANY_INT_LOAD_YES
-	       && reg_overlap_mentioned_p (SET_DEST (PATTERN (dep_insn)),
+	       && reg_overlap_mentioned_p (SET_DEST (single_set (dep_insn)),
 					   XEXP (SET_SRC (single_set (insn)),
 						 1)))
 	cost++;
diff --git a/gcc/config/sh/sh.md b/gcc/config/sh/sh.md
index f4e13c34115..17b76e6b98a 100644
--- a/gcc/config/sh/sh.md
+++ b/gcc/config/sh/sh.md
@@ -412,10 +412,12 @@
 	 (eq_attr "type" "jump")
 	 (cond [(eq_attr "med_branch_p" "yes")
 		(const_int 2)
-		(and (eq (symbol_ref "GET_CODE (prev_nonnote_insn (insn))")
-                         (symbol_ref "INSN"))
-                     (eq (symbol_ref "INSN_CODE (prev_nonnote_insn (insn))")
-                         (symbol_ref "code_for_indirect_jump_scratch")))
+		(and (ne (symbol_ref "prev_nonnote_insn (insn)")
+			 (const_int 0))
+		     (and (eq (symbol_ref "GET_CODE (prev_nonnote_insn (insn))")
+			      (symbol_ref "INSN"))
+			  (eq (symbol_ref "INSN_CODE (prev_nonnote_insn (insn))")
+			      (symbol_ref "code_for_indirect_jump_scratch"))))
                 (cond [(eq_attr "braf_branch_p" "yes")
                        (const_int 6)
                        (eq (symbol_ref "flag_pic") (const_int 0))
@@ -1675,7 +1677,7 @@
    (clobber (reg:DI TR0_REG))
    (clobber (reg:DI TR1_REG))
    (clobber (reg:DI TR2_REG))
-   (use (match_operand 1 "target_operand" "b"))]
+   (use (match_operand 1 "target_reg_operand" "b"))]
   "TARGET_SHMEDIA && (! TARGET_SHMEDIA_FPU || ! TARGET_DIVIDE_FP)"
   "blink	%1, r18"
   [(set_attr "type" "sfunc")
@@ -1841,7 +1843,7 @@
    (clobber (reg:SI R20_REG))
    (clobber (reg:SI R21_REG))
    (clobber (reg:SI TR0_REG))
-   (use (match_operand 1 "target_operand" "b"))]
+   (use (match_operand 1 "target_reg_operand" "b"))]
   "TARGET_SHMEDIA && (! TARGET_SHMEDIA_FPU || ! TARGET_DIVIDE_FP)"
   "blink	%1, r18"
   [(set_attr "type" "sfunc")])
@@ -1855,7 +1857,7 @@
    (clobber (reg:SI R21_REG))
    (clobber (reg:SI TR0_REG))
    (use (reg:SI R20_REG))
-   (use (match_operand 1 "target_operand" "b"))]
+   (use (match_operand 1 "target_reg_operand" "b"))]
   "TARGET_SHMEDIA && (! TARGET_SHMEDIA_FPU || ! TARGET_DIVIDE_FP)"
   "blink	%1, r18"
   [(set_attr "type" "sfunc")])
@@ -3018,7 +3020,9 @@ label:
   "
 {
   if (TARGET_SH1
-      && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 255)
+      && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 255
+      && (GET_CODE (operands[1]) != SUBREG
+	  || SCALAR_INT_MODE_P (GET_MODE (XEXP (operands[1], 0)))))
     {
       emit_insn (gen_zero_extendqisi2 (operands[0],
 				       gen_lowpart (QImode, operands[1])));
@@ -8283,6 +8287,20 @@ label:
 					     operands[2],
 					     gen_rtx_REG (Pmode, PIC_REG)));
 
+  /* When stack protector inserts codes after the result is set to
+     R0, @(rX, r12) will cause a spill failure for R0.  Don't schedule
+     insns to avoid combining (set A (plus rX r12)) and (set op0 (mem A))
+     when rX is a GOT address for the guard symbol.  Ugly but doesn't
+     matter because this is a rare situation.  */
+  if (!TARGET_SHMEDIA
+      && flag_stack_protect
+      && GET_CODE (operands[1]) == CONST
+      && GET_CODE (XEXP (operands[1], 0)) == UNSPEC
+      && GET_CODE (XVECEXP (XEXP (operands[1], 0), 0, 0)) == SYMBOL_REF
+      && strcmp (XSTR (XVECEXP (XEXP (operands[1], 0), 0, 0), 0),
+		 \"__stack_chk_guard\") == 0)
+    emit_insn (gen_blockage ());
+
   /* N.B. This is not constant for a GOTPLT relocation.  */
   mem = gen_rtx_MEM (Pmode, operands[3]);
   MEM_NOTRAP_P (mem) = 1;
diff --git a/gcc/config/sparc/linux.h b/gcc/config/sparc/linux.h
index 9b465fdf3b0..534a76de085 100644
--- a/gcc/config/sparc/linux.h
+++ b/gcc/config/sparc/linux.h
@@ -142,10 +142,6 @@ Boston, MA 02110-1301, USA.  */
   "%{V} %{v:%{!V:-V}} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Wa,*:%*} -s \
    %{fpic|fPIC|fpie|fPIE:-K PIC} %(asm_cpu) %(asm_relax)"
 
-/* Same as sparc.h */
-#undef DBX_REGISTER_NUMBER
-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)
-
 #undef ASM_OUTPUT_ALIGNED_LOCAL
 #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
 do {									\
diff --git a/gcc/config/sparc/linux64.h b/gcc/config/sparc/linux64.h
index d025eb7b862..ef4b854f3d7 100644
--- a/gcc/config/sparc/linux64.h
+++ b/gcc/config/sparc/linux64.h
@@ -280,10 +280,6 @@ Boston, MA 02110-1301, USA.  */
 %{mlittle-endian:-EL} \
 %(asm_cpu) %(asm_arch) %(asm_relax)"
 
-/* Same as sparc.h */
-#undef DBX_REGISTER_NUMBER
-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)
-
 #undef ASM_OUTPUT_ALIGNED_LOCAL
 #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)		\
 do {									\
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 201a425f10c..1360594bb9b 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -675,7 +675,7 @@ sparc_override_options (void)
 	error ("-mcmodel= is not supported on 32 bit systems");
     }
 
-  fpu = TARGET_FPU; /* save current -mfpu status */
+  fpu = target_flags & MASK_FPU; /* save current -mfpu status */
 
   /* Set the default CPU.  */
   for (def = &cpu_default[0]; def->name; ++def)
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index db0348888b0..a4002e304e7 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -5074,14 +5074,11 @@
   [(set_attr "type" "multi")
    (set_attr "length" "2")])
 
-;; The V8 architecture specifies that there must be 3 instructions between
-;; a Y register write and a use of it for correct results.
-
 (define_expand "divsi3"
-  [(parallel [(set (match_operand:SI 0 "register_operand" "=r,r")
-		   (div:SI (match_operand:SI 1 "register_operand" "r,r")
-			   (match_operand:SI 2 "input_operand" "rI,m")))
-	      (clobber (match_scratch:SI 3 "=&r,&r"))])]
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (div:SI (match_operand:SI 1 "register_operand" "")
+			   (match_operand:SI 2 "input_operand" "")))
+	      (clobber (match_scratch:SI 3 ""))])]
   "TARGET_V8 || TARGET_DEPRECATED_V8_INSNS"
 {
   if (TARGET_ARCH64)
@@ -5094,24 +5091,40 @@
     }
 })
 
+;; The V8 architecture specifies that there must be at least 3 instructions
+;; between a write to the Y register and a use of it for correct results.
+;; We try to fill one of them with a simple constant or a memory load.
+
 (define_insn "divsi3_sp32"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(div:SI (match_operand:SI 1 "register_operand" "r,r")
-		(match_operand:SI 2 "input_operand" "rI,m")))
-   (clobber (match_scratch:SI 3 "=&r,&r"))]
-  "(TARGET_V8 || TARGET_DEPRECATED_V8_INSNS)
-   && TARGET_ARCH32"
-{
-  if (which_alternative == 0)
-    if (TARGET_V9)
-      return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tsdiv\t%1, %2, %0";
-    else
-      return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tnop\n\tnop\n\tnop\n\tsdiv\t%1, %2, %0";
-  else
-    if (TARGET_V9)
-      return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tld\t%2, %3\n\tsdiv\t%1, %3, %0";
-    else
-      return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tld\t%2, %3\n\tnop\n\tnop\n\tsdiv\t%1, %3, %0";
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
+	(div:SI (match_operand:SI 1 "register_operand" "r,r,r")
+		(match_operand:SI 2 "input_operand" "rI,K,m")))
+   (clobber (match_scratch:SI 3 "=&r,&r,&r"))]
+  "(TARGET_V8 || TARGET_DEPRECATED_V8_INSNS) && TARGET_ARCH32"
+{
+  output_asm_insn ("sra\t%1, 31, %3", operands);
+  output_asm_insn ("wr\t%3, 0, %%y", operands);
+
+  switch (which_alternative)
+    {
+    case 0:
+      if (TARGET_V9)
+	return "sdiv\t%1, %2, %0";
+      else
+	return "nop\n\tnop\n\tnop\n\tsdiv\t%1, %2, %0";
+    case 1:
+      if (TARGET_V9)
+	return "sethi\t%%hi(%a2), %3\n\tsdiv\t%1, %3, %0";
+      else
+	return "sethi\t%%hi(%a2), %3\n\tnop\n\tnop\n\tsdiv\t%1, %3, %0";
+    case 2:
+      if (TARGET_V9)
+	return "ld\t%2, %3\n\tsdiv\t%1, %3, %0";
+      else
+	return "ld\t%2, %3\n\tnop\n\tnop\n\tsdiv\t%1, %3, %0";
+    default:
+      gcc_unreachable ();
+    }
 }
   [(set_attr "type" "multi")
    (set (attr "length")
@@ -5146,10 +5159,13 @@
    (clobber (match_scratch:SI 3 "=&r"))]
   "TARGET_V8 || TARGET_DEPRECATED_V8_INSNS"
 {
+  output_asm_insn ("sra\t%1, 31, %3", operands);
+  output_asm_insn ("wr\t%3, 0, %%y", operands);
+
   if (TARGET_V9)
-    return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tsdivcc\t%1, %2, %0";
+    return "sdivcc\t%1, %2, %0";
   else
-    return "sra\t%1, 31, %3\n\twr\t%3, 0, %%y\n\tnop\n\tnop\n\tnop\n\tsdivcc\t%1, %2, %0";
+    return "nop\n\tnop\n\tnop\n\tsdivcc\t%1, %2, %0";
 }
   [(set_attr "type" "multi")
    (set (attr "length")
@@ -5164,29 +5180,48 @@
   "TARGET_V8 || TARGET_DEPRECATED_V8_INSNS"
   "")
 
-;; The V8 architecture specifies that there must be 3 instructions between
-;; a Y register write and a use of it for correct results.
+;; The V8 architecture specifies that there must be at least 3 instructions
+;; between a write to the Y register and a use of it for correct results.
+;; We try to fill one of them with a simple constant or a memory load.
 
 (define_insn "udivsi3_sp32"
-  [(set (match_operand:SI 0 "register_operand" "=r,&r,&r")
-	(udiv:SI (match_operand:SI 1 "nonimmediate_operand" "r,r,m")
-		 (match_operand:SI 2 "input_operand" "rI,m,r")))]
-  "(TARGET_V8 || TARGET_DEPRECATED_V8_INSNS)
-   && TARGET_ARCH32"
+  [(set (match_operand:SI 0 "register_operand" "=r,&r,&r,&r")
+	(udiv:SI (match_operand:SI 1 "nonimmediate_operand" "r,r,r,m")
+		 (match_operand:SI 2 "input_operand" "rI,K,m,r")))]
+  "(TARGET_V8 || TARGET_DEPRECATED_V8_INSNS) && TARGET_ARCH32"
 {
-  output_asm_insn ("wr\t%%g0, %%g0, %%y", operands);
+  output_asm_insn ("wr\t%%g0, 0, %%y", operands);
+
   switch (which_alternative)
     {
-    default:
-      return "nop\n\tnop\n\tnop\n\tudiv\t%1, %2, %0";
+    case 0:
+      if (TARGET_V9)
+	return "udiv\t%1, %2, %0";
+      else
+	return "nop\n\tnop\n\tnop\n\tudiv\t%1, %2, %0";
     case 1:
-      return "ld\t%2, %0\n\tnop\n\tnop\n\tudiv\t%1, %0, %0";
+      if (TARGET_V9)
+	return "sethi\t%%hi(%a2), %0\n\tudiv\t%1, %0, %0";
+      else
+	return "sethi\t%%hi(%a2), %0\n\tnop\n\tnop\n\tudiv\t%1, %0, %0";
     case 2:
-      return "ld\t%1, %0\n\tnop\n\tnop\n\tudiv\t%0, %2, %0";
+      if (TARGET_V9)
+	return "ld\t%2, %0\n\tudiv\t%1, %0, %0";
+      else
+	return "ld\t%2, %0\n\tnop\n\tnop\n\tudiv\t%1, %0, %0";
+    case 3:
+      if (TARGET_V9)
+	return "ld\t%1, %0\n\tudiv\t%0, %2, %0";
+      else
+	return "ld\t%1, %0\n\tnop\n\tnop\n\tudiv\t%0, %2, %0";
+    default:
+      gcc_unreachable ();
     }
 }
   [(set_attr "type" "multi")
-   (set_attr "length" "5")])
+   (set (attr "length")
+	(if_then_else (eq_attr "isa" "v9")
+		      (const_int 3) (const_int 5)))])
 
 (define_insn "udivsi3_sp64"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -5212,13 +5247,14 @@
 		    (const_int 0)))
    (set (match_operand:SI 0 "register_operand" "=r")
 	(udiv:SI (match_dup 1) (match_dup 2)))]
-  "TARGET_V8
-   || TARGET_DEPRECATED_V8_INSNS"
+  "TARGET_V8 || TARGET_DEPRECATED_V8_INSNS"
 {
+  output_asm_insn ("wr\t%%g0, 0, %%y", operands);
+
   if (TARGET_V9)
-    return "wr\t%%g0, %%g0, %%y\n\tudivcc\t%1, %2, %0";
+    return "udivcc\t%1, %2, %0";
   else
-    return "wr\t%%g0, %%g0, %%y\n\tnop\n\tnop\n\tnop\n\tudivcc\t%1, %2, %0";
+    return "nop\n\tnop\n\tnop\n\tudivcc\t%1, %2, %0";
 }
   [(set_attr "type" "multi")
    (set (attr "length")
diff --git a/gcc/config/sparc/sysv4.h b/gcc/config/sparc/sysv4.h
index 0c0c8e0d055..bc014e7379b 100644
--- a/gcc/config/sparc/sysv4.h
+++ b/gcc/config/sparc/sysv4.h
@@ -101,22 +101,6 @@ do { ASM_OUTPUT_ALIGN ((FILE), Pmode == SImode ? 2 : 3);		\
 	fprintf (FILE, "\n");						\
   } while (0)
 
-/* Define how the SPARC registers should be numbered for Dwarf output.
-   The numbering provided here should be compatible with the native
-   svr4 SDB debugger in the SPARC/svr4 reference port.  The numbering
-   is as follows:
-
-   Assembly name	gcc internal regno	Dwarf regno
-   ----------------------------------------------------------
-   g0-g7		0-7			0-7
-   o0-o7		8-15			8-15
-   l0-l7		16-23			16-23
-   i0-i7		24-31			24-31
-   f0-f31		32-63			40-71
-*/
-
-#define DBX_REGISTER_NUMBER(REGNO) ((REGNO) < 32 ? (REGNO) : (REGNO) + 8)
-
 /* A set of symbol definitions for assembly pseudo-ops which will
    get us switched to various sections of interest.  These are used
    in all places where we simply want to switch to a section, and
diff --git a/gcc/config/xtensa/xtensa.c b/gcc/config/xtensa/xtensa.c
index 32cb94d0320..177970b92f0 100644
--- a/gcc/config/xtensa/xtensa.c
+++ b/gcc/config/xtensa/xtensa.c
@@ -528,6 +528,8 @@ constantpool_address_p (rtx addr)
 int
 constantpool_mem_p (rtx op)
 {
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
   if (GET_CODE (op) == MEM)
     return constantpool_address_p (XEXP (op, 0));
   return FALSE;
diff --git a/gcc/configure b/gcc/configure
index 550a7c5b445..ed2eb5006bf 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -7495,7 +7495,7 @@ else
   echo "configure:7495: version of makeinfo is $ac_prog_version" >&5
   case $ac_prog_version in
     '')     gcc_cv_prog_makeinfo_modern=no;;
-    4.[2-9]*)
+    4.[2-9]*|4.[1-9][0-9]*|[5-9]*|[1-9][0-9]*)
             gcc_cv_prog_makeinfo_modern=yes;;
     *)      gcc_cv_prog_makeinfo_modern=no;;
   esac
@@ -14138,9 +14138,7 @@ else
   ld_ver=`$gcc_cv_ld --version 2>/dev/null | sed 1q`
   if echo "$ld_ver" | grep GNU > /dev/null; then
     ld_vers=`echo $ld_ver | sed -n \
-	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
-	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
-	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*.*\)$,\1,p' \
 	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\)[	 ].*$,\1,p' \
 	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[	 ].*$,\1,p' \
 	-e 's,^.*[ 	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[ 	].*$,\1,p' \
diff --git a/gcc/configure.ac b/gcc/configure.ac
index da97fcab3a0..709130ffd60 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -833,7 +833,7 @@ MISSING="${CONFIG_SHELL-/bin/sh} $srcdir/../missing"
 # that we can use it.
 gcc_AC_CHECK_PROG_VER(MAKEINFO, makeinfo, --version,
   [GNU texinfo.* \([0-9][0-9.]*\)],
-  [4.[2-9]*])
+  [4.[2-9]*|4.[1-9][0-9]*|[5-9]*|[1-9][0-9]*])
 if test $gcc_cv_prog_makeinfo_modern = no; then
   MAKEINFO="$MISSING makeinfo"
   AC_MSG_WARN([
@@ -1994,9 +1994,7 @@ else
   if echo "$ld_ver" | grep GNU > /dev/null; then
 changequote(,)dnl
     ld_vers=`echo $ld_ver | sed -n \
-	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
-	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
-	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)$,\1,p' \
+	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*.*\)$,\1,p' \
 	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\)[	 ].*$,\1,p' \
 	-e 's,^.*[	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[	 ].*$,\1,p' \
 	-e 's,^.*[ 	 ]\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[ 	].*$,\1,p' \
diff --git a/gcc/convert.c b/gcc/convert.c
index a04d19bfb54..e0c24a6954d 100644
--- a/gcc/convert.c
+++ b/gcc/convert.c
@@ -389,14 +389,14 @@ convert_to_integer (tree type, tree expr)
 	    fn = mathfn_built_in (s_intype, BUILT_IN_LLROUND);
 	  break;
 
-	case BUILT_IN_RINT: case BUILT_IN_RINTF: case BUILT_IN_RINTL:
-	  /* Only convert rint* if we can ignore math exceptions.  */
-	  if (flag_trapping_math)
-	    break;
-	  /* ... Fall through ...  */
 	case BUILT_IN_NEARBYINT:
 	case BUILT_IN_NEARBYINTF:
 	case BUILT_IN_NEARBYINTL:
+	  /* Only convert nearbyint* if we can ignore math exceptions.  */
+	  if (flag_trapping_math)
+	    break;
+	  /* ... Fall through ...  */
+	case BUILT_IN_RINT: case BUILT_IN_RINTF: case BUILT_IN_RINTL:
 	  if (outprec < TYPE_PRECISION (long_integer_type_node)
 	      || (outprec == TYPE_PRECISION (long_integer_type_node)
 		  && !TYPE_UNSIGNED (type)))
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 161dfd29081..e8cd07455f1 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,161 @@
+2008-02-19  Jason Merrill  <jason@redhat.com>
+
+	PR c++/34950
+	* pt.c (resolve_overloaded_unification): Set processing_template_decl
+	while we look for possible bindings.
+
+2008-02-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/34774
+	* pt.c (value_dependent_expression_p): Look into DECL_INITIAL
+	of enumerators, too.
+
+2008-01-28  Jason Merrill  <jason@redhat.com>
+
+	PR c++/35007
+	* class.c (build_base_path): Fix !want_pointer case.
+
+2008-01-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/27177
+	* class.c (build_base_path): Fix previous change.
+
+	PR c++/27177
+	* class.c (build_base_path): Don't mess with virtual access if
+	skip_evaluation.
+	* call.c (standard_conversion): Don't check whether source type
+	is complete.
+
+	PR c++/33959
+	* pt.c (tsubst_aggr_type): Make sure our context is complete.
+
+2007-10-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/33744
+	* parser.c (cp_parser_parenthesized_expression_list): Set
+	greater_than_is_operator_p to true in between the parens.
+
+2007-08-31  Paolo Carlini  <pcarlini@suse.de>
+
+	PR c++/32113
+	* search.c (lookup_member): Check the name argument for
+	error_mark_node.
+
+2007-08-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/31941
+	* error.c (resolve_virtual_fun_from_obj_type_ref): Handle
+	TARGET_VTABLE_USES_DESCRIPTORS targets properly.
+
+2007-08-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/32992
+	* typeck.c (check_return_expr): Don't NRV optimize vars in
+	anonymous unions.
+	* decl.c (finish_function): Comment fix.
+
+2007-08-18  Paolo Carlini  <pcarlini@suse.de>
+
+	PR c++/32112
+	* error.c (dump_decl): Deal with UNBOUND_CLASS_TEMPLATE.
+	* cxx-pretty-print.c (pp_cxx_unqualified_id): Likewise.
+
+2007-08-10  Paolo Carlini  <pcarlini@suse.de>
+
+	PR c++/17763
+	* error.c (dump_expr): Consistently use the *_cxx_*
+	variants of the pretty-print functions.
+
+2007-06-20  Dirk Mueller  <dmueller@suse.de>
+
+	PR c++/31809
+	PR c++/31806
+	Backport from mainline:
+	2007-05-31  Jakub Jelinek  <jakub@redhat.com>
+
+	* decl.c (cp_finish_decl): Also clear was_readonly if a static var
+	needs runtime initialization.
+
+	2007-05-30  Jakub Jelinek  <jakub@redhat.com>
+
+	* decl.c (cp_finish_decl): Clear TREE_READONLY flag on TREE_STATIC
+	variables that need runtime initialization.
+
+2007-04-28  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR C++/30221
+	* decl.c (reshape_init_r): Don't reshape the first element if it
+	is a pointer to member function.
+
+2007-04-26  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR C++/30016
+	* typeck.c (build_reinterpret_cast_1): Only allow conversion to
+	integeral types from vectors types.
+
+2007-04-17  Simon Martin  <simartin@users.sourceforge.net>
+
+	PR c++/31517
+	* pt.c (value_dependent_expression_p): Handle MODOP_EXPRs.
+
+2007-04-14  Andrew Pinski  <pinskia@gmail.com> 
+
+	PR C++/30168
+	* optimize.c (update_cloned_parm): Copy DECL_COMPLEX_GIMPLE_REG_P also.
+
+2007-04-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/31074
+	* call.c (reference_binding): Add c_cast_p parm.  If true,
+	add quals to TO as needed to make it reference-compatible.
+
+2007-04-09  Mark Mitchell  <mark@codesourcery.com>
+
+	PR c++/31449
+	* class.c (build_base_path): Ensure that the converted pointer has
+	the same cv-qualification as the input.
+
+2007-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/30847
+	* typeck.c (build_modify_expr): For COND_EXPR on LHS, if RHS has void
+	type issue error and return early.
+
+2007-03-08  Volker Reichelt  <reichelt@netcologne.de>
+
+	PR c++/30852
+	* semantics.c (finish_offsetof): Handle COMPOUND_EXPR.
+
+2007-03-05  Simon Martin  <simartin@users.sourceforge.net>
+
+	PR c++/30895
+	* tree.c (cp_tree_equal): Properly handle COMPLEX_CST trees.
+
+2007-02-19  Mark Mitchell  <mark@codesourcery.com>
+
+	* call.c (build_new_method_call): Ensure that explicit calls of
+	destructors have type "void".
+
+2007-02-19  Mark Mitchell  <mark@codesourcery.com>
+
+	* decl2.c (import_export_decl): Reverse sense of 
+	DECL_VISIBILITY_SPECIFIED test for target-specific visibility
+	rules.
+
+	Backport of:
+	2006-07-20  Jason Merrill  <jason@redhat.com>
+	* decl2.c (determine_visibility_from_class): Reverse sense of 
+	DECL_VISIBILITY_SPECIFIED test for target-specific visibility
+	rules.
+
+2007-02-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/30536
+	* decl.c (grokdeclarator): If __thread is used together with
+	a storage class other than extern and static, clear thread_p
+	after issuing diagnostics and fall through to checking the
+	storage class.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 12315901c41..508982d3e4c 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -171,7 +171,7 @@ static struct z_candidate *add_function_candidate
 	(struct z_candidate **, tree, tree, tree, tree, tree, int);
 static conversion *implicit_conversion (tree, tree, tree, bool, int);
 static conversion *standard_conversion (tree, tree, tree, bool, int);
-static conversion *reference_binding (tree, tree, tree, int);
+static conversion *reference_binding (tree, tree, tree, bool, int);
 static conversion *build_conv (conversion_kind, tree, conversion *);
 static bool is_subseq (conversion *, conversion *);
 static tree maybe_handle_ref_bind (conversion **);
@@ -714,19 +714,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,
 		  that necessitates this conversion is ill-formed.
 		  Therefore, we use DERIVED_FROM_P, and do not check
 		  access or uniqueness.  */
-	       && DERIVED_FROM_P (TREE_TYPE (to), TREE_TYPE (from))
-	       /* If FROM is not yet complete, then we must be parsing
-		  the body of a class.  We know what's derived from
-		  what, but we can't actually perform a
-		  derived-to-base conversion.  For example, in:
-
-		     struct D : public B { 
-                       static const int i = sizeof((B*)(D*)0);
-                     };
-
-                  the D*-to-B* conversion is a reinterpret_cast, not a
-		  static_cast.  */
-	       && COMPLETE_TYPE_P (TREE_TYPE (from)))
+	       && DERIVED_FROM_P (TREE_TYPE (to), TREE_TYPE (from)))
 	{
 	  from =
 	    cp_build_qualified_type (TREE_TYPE (to),
@@ -1072,10 +1060,11 @@ direct_reference_binding (tree type, conversion *conv)
    purposes of reference binding.  For lvalue binding, either pass a
    reference type to FROM or an lvalue expression to EXPR.  If the
    reference will be bound to a temporary, NEED_TEMPORARY_P is set for
-   the conversion returned.  */
+   the conversion returned.  If C_CAST_P is true, this
+   conversion is coming from a C-style cast.  */
 
 static conversion *
-reference_binding (tree rto, tree rfrom, tree expr, int flags)
+reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)
 {
   conversion *conv = NULL;
   tree to = TREE_TYPE (rto);
@@ -1105,6 +1094,11 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)
      reference compatible.  We have do do this after stripping
      references from FROM.  */
   related_p = reference_related_p (to, from);
+  /* If this is a C cast, first convert to an appropriately qualified
+     type, so that we can later do a const_cast to the desired type.  */
+  if (related_p && c_cast_p
+      && !at_least_as_qualified_p (to, from))
+    to = build_qualified_type (to, cp_type_quals (from));
   compatible_p = reference_compatible_p (to, from);
 
   if (lvalue_p && compatible_p)
@@ -1214,7 +1208,7 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags)
   if (related_p && !at_least_as_qualified_p (to, from))
     return NULL;
 
-  conv = implicit_conversion (to, from, expr, /*c_cast_p=*/false, 
+  conv = implicit_conversion (to, from, expr, c_cast_p,
 			      flags);
   if (!conv)
     return NULL;
@@ -1244,7 +1238,7 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,
     return NULL;
 
   if (TREE_CODE (to) == REFERENCE_TYPE)
-    conv = reference_binding (to, from, expr, flags);
+    conv = reference_binding (to, from, expr, c_cast_p, flags);
   else
     conv = standard_conversion (to, from, expr, c_cast_p, flags);
 
@@ -5481,6 +5475,20 @@ build_new_method_call (tree instance, tree fns, tree args,
 		  && TREE_SIDE_EFFECTS (instance_ptr))
 		call = build2 (COMPOUND_EXPR, TREE_TYPE (call),
 			       instance_ptr, call);
+	      else if (call != error_mark_node
+		       && DECL_DESTRUCTOR_P (cand->fn)
+		       && !VOID_TYPE_P (TREE_TYPE (call)))
+		/* An explicit call of the form "x->~X()" has type
+		   "void".  However, on platforms where destructors
+		   return "this" (i.e., those where
+		   targetm.cxx.cdtor_returns_this is true), such calls
+		   will appear to have a return value of pointer type
+		   to the low-level call machinery.  We do not want to
+		   change the low-level machinery, since we want to be
+		   able to optimize "delete f()" on such platforms as
+		   "operator delete(~X(f()))" (rather than generating
+		   "t = f(), ~X(t), operator delete (t)").  */
+		call = build_nop (void_type_node, call);
 	    }
 	}
     }
@@ -6514,7 +6522,8 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)
   /* Get the high-water mark for the CONVERSION_OBSTACK.  */
   p = conversion_obstack_alloc (0);
 
-  conv = reference_binding (type, TREE_TYPE (expr), expr, LOOKUP_NORMAL);
+  conv = reference_binding (type, TREE_TYPE (expr), expr, /*c_cast_p=*/false,
+			    LOOKUP_NORMAL);
   if (!conv || conv->bad_p)
     {
       if (!(TYPE_QUALS (TREE_TYPE (type)) & TYPE_QUAL_CONST)
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index 8fa46f6b6ff..6cb040dbea5 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -294,6 +294,16 @@ build_base_path (enum tree_code code,
   /* Do we need to look in the vtable for the real offset?  */
   virtual_access = (v_binfo && fixed_type_p <= 0);
 
+  /* Don't bother with the calculations inside sizeof; they'll ICE if the
+     source type is incomplete and the pointer value doesn't matter.  */
+  if (skip_evaluation)
+    {
+      expr = build_nop (build_pointer_type (target_type), expr);
+      if (!want_pointer)
+	expr = build_indirect_ref (expr, NULL);
+      return expr;
+    }
+
   /* Do we need to check for a null pointer?  */
   if (want_pointer && !nonnull)
     {
@@ -303,7 +313,18 @@ build_base_path (enum tree_code code,
 	 field, because other parts of the compiler know that such
 	 expressions are always non-NULL.  */
       if (!virtual_access && integer_zerop (offset))
-	return build_nop (build_pointer_type (target_type), expr);
+	{
+	  tree class_type;
+	  /* TARGET_TYPE has been extracted from BINFO, and, is
+	     therefore always cv-unqualified.  Extract the
+	     cv-qualifiers from EXPR so that the expression returned
+	     matches the input.  */
+	  class_type = TREE_TYPE (TREE_TYPE (expr));
+	  target_type
+	    = cp_build_qualified_type (target_type,
+				       cp_type_quals (class_type));
+	  return build_nop (build_pointer_type (target_type), expr);
+	}
       null_test = error_mark_node;
     }
 
diff --git a/gcc/cp/cxx-pretty-print.c b/gcc/cp/cxx-pretty-print.c
index cdaf470ce26..43cf5819bf0 100644
--- a/gcc/cp/cxx-pretty-print.c
+++ b/gcc/cp/cxx-pretty-print.c
@@ -204,6 +204,10 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)
       pp_cxx_unqualified_id (pp, TEMPLATE_PARM_DECL (t));
       break;
 
+    case UNBOUND_CLASS_TEMPLATE:
+      pp_cxx_unqualified_id (pp, TYPE_NAME (t));
+      break;
+
     default:
       pp_unsupported_tree (pp, t);
       break;
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index f29c689b773..4aac4eebef3 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -4510,19 +4510,24 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)
     {
       if (TREE_CODE (init) == CONSTRUCTOR)
 	{
+	  if (TREE_TYPE (init) && TYPE_PTRMEMFUNC_P (TREE_TYPE (init)))
+	    /* There is no need to reshape pointer-to-member function
+	       initializers, as they are always constructed correctly
+	       by the front end.  */
+           ;
+	  else if (COMPOUND_LITERAL_P (init))
 	  /* For a nested compound literal, there is no need to reshape since
 	     brace elision is not allowed. Even if we decided to allow it,
 	     we should add a call to reshape_init in finish_compound_literal,
 	     before calling digest_init, so changing this code would still
 	     not be necessary.  */
-	  if (!COMPOUND_LITERAL_P (init))
+	    gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (init));
+	  else
 	    {
 	      ++d->cur;
 	      gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));
 	      return reshape_init (type, init);
 	    }
-	  else
-	    gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (init));
 	}
 
       warning (OPT_Wmissing_braces, "missing braces around initializer for %qT",
@@ -5235,7 +5240,15 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
 	     initializer.  It is not legal to redeclare a static data
 	     member, so this issue does not arise in that case.  */
 	  if (var_definition_p && TREE_STATIC (decl))
-	    expand_static_init (decl, init);
+            {
+              if (init)
+                {
+                  if (TREE_READONLY (decl))
+                      TREE_READONLY (decl) = 0;
+                  was_readonly = 0;
+                }
+	      expand_static_init (decl, init);
+            }
 	}
     }
 
@@ -7288,19 +7301,20 @@ grokdeclarator (const cp_declarator *declarator,
 
   /* Warn about storage classes that are invalid for certain
      kinds of declarations (parameters, typenames, etc.).  */
-  if (declspecs->multiple_storage_classes_p)
+  if (thread_p
+      && ((storage_class
+	   && storage_class != sc_extern
+	   && storage_class != sc_static)
+	  || declspecs->specs[(int)ds_typedef]))
     {
-      error ("multiple storage classes in declaration of %qs", name);
-      storage_class = sc_none;
+      if (!declspecs->multiple_storage_classes_p)
+	error ("multiple storage classes in declaration of %qs", name);
+      thread_p = false;
     }
-  else if (thread_p
-	   && ((storage_class
-		&& storage_class != sc_extern
-		&& storage_class != sc_static)
-	       || declspecs->specs[(int)ds_typedef]))
+  if (declspecs->multiple_storage_classes_p)
     {
       error ("multiple storage classes in declaration of %qs", name);
-      thread_p = false;
+      storage_class = sc_none;
     }
   else if (decl_context != NORMAL
 	   && ((storage_class != sc_none
@@ -11044,7 +11058,7 @@ finish_function (int flags)
   gcc_assert (stmts_are_full_exprs_p ());
 
   /* Set up the named return value optimization, if we can.  Candidate
-     variables are selected in check_return_value.  */
+     variables are selected in check_return_expr.  */
   if (current_function_return_value)
     {
       tree r = current_function_return_value;
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 7afaa028a1e..88c920ac0e9 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -1905,8 +1905,8 @@ import_export_decl (tree decl)
       comdat_linkage (decl);
     }
 
-  /* Give the target a chance to override the visibility associated
-     with DECL.  */
+  /* Give the target a chance to override the visibility of class
+     data, like virtual tables.  */
   if (TREE_CODE (decl) == VAR_DECL
       && (DECL_TINFO_P (decl)
 	  || (DECL_VTABLE_OR_VTT_P (decl)
@@ -1914,9 +1914,16 @@ import_export_decl (tree decl)
 		 they cannot be referred to from other object files;
 		 their name is not standardized by the ABI.  */
 	      && !DECL_CONSTRUCTION_VTABLE_P (decl)))
-      && TREE_PUBLIC (decl)
+      /* Visibility only applies to objects with external linkage.  */
+      && TREE_PUBLIC (decl) 
+      /* Visibility is specified by the definition of the object, not
+	 its declaration.  */
       && !DECL_REALLY_EXTERN (decl)
-      && DECL_VISIBILITY_SPECIFIED (decl)
+      /* Respect any explicit specification of visibility for the
+	 class data itself.  */
+      && !DECL_VISIBILITY_SPECIFIED (decl)
+      /* If the visibility of the class has been explicitly specified,
+	 that visibility applies to class data as well.  */
       && (!class_type || !CLASSTYPE_VISIBILITY_SPECIFIED (class_type)))
     targetm.cxx.determine_class_data_visibility (decl);
 
diff --git a/gcc/cp/error.c b/gcc/cp/error.c
index be4563265d7..1953d7de3d9 100644
--- a/gcc/cp/error.c
+++ b/gcc/cp/error.c
@@ -895,6 +895,10 @@ dump_decl (tree t, int flags)
 	pp_type_id (cxx_pp, t);
       break;
 
+    case UNBOUND_CLASS_TEMPLATE:
+      dump_type (t, flags);
+      break;
+
     default:
       pp_unsupported_tree (cxx_pp, t);
       /* Fall through to error.  */
@@ -1287,10 +1291,14 @@ static tree
 resolve_virtual_fun_from_obj_type_ref (tree ref)
 {
   tree obj_type = TREE_TYPE (OBJ_TYPE_REF_OBJECT (ref));
-  int index = tree_low_cst (OBJ_TYPE_REF_TOKEN (ref), 1);
+  HOST_WIDE_INT index = tree_low_cst (OBJ_TYPE_REF_TOKEN (ref), 1);
   tree fun = BINFO_VIRTUALS (TYPE_BINFO (TREE_TYPE (obj_type)));
-    while (index--)
+  while (index)
+    {
       fun = TREE_CHAIN (fun);
+      index -= (TARGET_VTABLE_USES_DESCRIPTORS
+		? TARGET_VTABLE_USES_DESCRIPTORS : 1);
+    }
 
   return BV_FN (fun);
 }
@@ -1413,13 +1421,13 @@ dump_expr (tree t, int flags)
 	    if (TREE_CODE (ob) == ADDR_EXPR)
 	      {
 		dump_expr (TREE_OPERAND (ob, 0), flags | TFF_EXPR_IN_PARENS);
-		pp_dot (cxx_pp);
+		pp_cxx_dot (cxx_pp);
 	      }
 	    else if (TREE_CODE (ob) != PARM_DECL
 		     || strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), "this"))
 	      {
 		dump_expr (ob, flags | TFF_EXPR_IN_PARENS);
-		pp_arrow (cxx_pp);
+		pp_cxx_arrow (cxx_pp);
 	      }
 	    args = TREE_CHAIN (args);
 	  }
diff --git a/gcc/cp/optimize.c b/gcc/cp/optimize.c
index 7ac24376ed1..59ae916db22 100644
--- a/gcc/cp/optimize.c
+++ b/gcc/cp/optimize.c
@@ -69,6 +69,8 @@ update_cloned_parm (tree parm, tree cloned_parm, bool first)
   DECL_NAME (cloned_parm) = DECL_NAME (parm);
   DECL_SOURCE_LOCATION (cloned_parm) = DECL_SOURCE_LOCATION (parm);
   TREE_TYPE (cloned_parm) = TREE_TYPE (parm);
+
+  DECL_COMPLEX_GIMPLE_REG_P (cloned_parm) = DECL_COMPLEX_GIMPLE_REG_P (parm);
 }
 
 /* FN is a function that has a complete body.  Clone the body as
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index fdc60347f80..63566c0972d 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -4700,6 +4700,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,
   tree expression_list = NULL_TREE;
   bool fold_expr_p = is_attribute_list;
   tree identifier = NULL_TREE;
+  bool saved_greater_than_is_operator_p;
 
   /* Assume all the expressions will be constant.  */
   if (non_constant_p)
@@ -4708,6 +4709,12 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,
   if (!cp_parser_require (parser, CPP_OPEN_PAREN, "`('"))
     return error_mark_node;
 
+  /* Within a parenthesized expression, a `>' token is always
+     the greater-than operator.  */
+  saved_greater_than_is_operator_p
+    = parser->greater_than_is_operator_p;
+  parser->greater_than_is_operator_p = true;
+
   /* Consume expressions until there are no more.  */
   if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))
     while (true)
@@ -4781,9 +4788,16 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,
       if (ending < 0)
 	goto get_comma;
       if (!ending)
-	return error_mark_node;
+	{
+	  parser->greater_than_is_operator_p
+	    = saved_greater_than_is_operator_p;
+	  return error_mark_node;
+	}
     }
 
+  parser->greater_than_is_operator_p
+    = saved_greater_than_is_operator_p;
+
   /* We built up the list in reverse order so we must reverse it now.  */
   expression_list = nreverse (expression_list);
   if (identifier)
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index c817880971b..10517f17b78 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -6164,8 +6164,14 @@ tsubst_aggr_type (tree t,
 	     up.  */
 	  context = TYPE_CONTEXT (t);
 	  if (context)
-	    context = tsubst_aggr_type (context, args, complain,
-					in_decl, /*entering_scope=*/1);
+	    {
+	      context = tsubst_aggr_type (context, args, complain,
+					  in_decl, /*entering_scope=*/1);
+	      /* If context is a nested class inside a class template,
+	         it may still need to be instantiated (c++/33959).  */
+	      if (TYPE_P (context))
+		complete_type (context);
+	    }
 
 	  /* Then, figure out what arguments are appropriate for the
 	     type we are trying to find.  For example, given:
@@ -9784,6 +9790,7 @@ resolve_overloaded_unification (tree tparms,
 	  if (TREE_CODE (fn) != TEMPLATE_DECL)
 	    continue;
 
+	  ++processing_template_decl;
 	  subargs = get_bindings (fn, DECL_TEMPLATE_RESULT (fn),
 				  expl_subargs, /*check_ret=*/false);
 	  if (subargs)
@@ -9792,6 +9799,7 @@ resolve_overloaded_unification (tree tparms,
 	      good += try_one_overload (tparms, targs, tempargs, parm,
 					elem, strict, sub_strict, addr_p);
 	    }
+	  --processing_template_decl;
 	}
     }
   else
@@ -12556,7 +12564,7 @@ value_dependent_expression_p (tree expression)
       /* A non-type template parm.  */
       if (DECL_TEMPLATE_PARM_P (expression))
 	return true;
-      return false;
+      return value_dependent_expression_p (DECL_INITIAL (expression));
 
     case VAR_DECL:
        /* A constant with integral or enumeration type and is initialized
@@ -12626,6 +12634,10 @@ value_dependent_expression_p (tree expression)
 	 such calls are value-dependent.  */
       return true;
 
+    case MODOP_EXPR:
+      return ((value_dependent_expression_p (TREE_OPERAND (expression, 0)))
+	      || (value_dependent_expression_p (TREE_OPERAND (expression, 2))));
+
     default:
       /* A constant expression is value-dependent if any subexpression is
 	 value-dependent.  */
diff --git a/gcc/cp/search.c b/gcc/cp/search.c
index 0cfd5139452..259ec66205f 100644
--- a/gcc/cp/search.c
+++ b/gcc/cp/search.c
@@ -1200,6 +1200,9 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)
 
   const char *errstr = 0;
 
+  if (name == error_mark_node)
+    return NULL_TREE;
+
   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);
 
   if (TREE_CODE (xbasetype) == TREE_BINFO)
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index eaebdd8f493..11f7ab9a1e7 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -2892,7 +2892,8 @@ finish_offsetof (tree expr)
       || TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE
       || TREE_CODE (TREE_TYPE (expr)) == UNKNOWN_TYPE)
     {
-      if (TREE_CODE (expr) == COMPONENT_REF)
+      if (TREE_CODE (expr) == COMPONENT_REF
+	  || TREE_CODE (expr) == COMPOUND_EXPR)
 	expr = TREE_OPERAND (expr, 1);
       error ("cannot apply %<offsetof%> to member function %qD", expr);
       return error_mark_node;
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index 76315a77604..312d534946d 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -1442,6 +1442,10 @@ cp_tree_equal (tree t1, tree t2)
 	&& !memcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),
 		    TREE_STRING_LENGTH (t1));
 
+    case COMPLEX_CST:
+      return cp_tree_equal (TREE_REALPART (t1), TREE_REALPART (t2))
+	&& cp_tree_equal (TREE_IMAGPART (t1), TREE_IMAGPART (t2));
+
     case CONSTRUCTOR:
       /* We need to do this when determining whether or not two
 	 non-type pointer to member function template arguments
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index fefc1193d2c..07fc4768b99 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -5094,7 +5094,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,
     }
   else if (TREE_CODE (type) == VECTOR_TYPE)
     return fold_if_not_in_template (convert_to_vector (type, expr));
-  else if (TREE_CODE (intype) == VECTOR_TYPE)
+  else if (TREE_CODE (intype) == VECTOR_TYPE && INTEGRAL_TYPE_P (type))
     return fold_if_not_in_template (convert_to_integer (type, expr));
   else
     {
@@ -5450,6 +5450,12 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)
 	tree cond;
 	tree preeval = NULL_TREE;
 
+	if (VOID_TYPE_P (TREE_TYPE (rhs)))
+	  {
+	    error ("void value not ignored as it ought to be");
+	    return error_mark_node;
+	  }
+
 	rhs = stabilize_expr (rhs, &preeval);
 
 	/* Check this here to avoid odd errors when trying to convert
@@ -6433,6 +6439,7 @@ check_return_expr (tree retval, bool *no_warning)
 	  && TREE_CODE (retval) == VAR_DECL
 	  && DECL_CONTEXT (retval) == current_function_decl
 	  && ! TREE_STATIC (retval)
+	  && ! DECL_HAS_VALUE_EXPR_P (retval)
 	  && (DECL_ALIGN (retval)
 	      >= DECL_ALIGN (DECL_RESULT (current_function_decl)))
 	  && same_type_p ((TYPE_MAIN_VARIANT
diff --git a/gcc/cse.c b/gcc/cse.c
index 8b406e6842c..a35c41c8a0d 100644
--- a/gcc/cse.c
+++ b/gcc/cse.c
@@ -583,7 +583,8 @@ static void delete_reg_equiv (unsigned int);
 static int mention_regs (rtx);
 static int insert_regs (rtx, struct table_elt *, int);
 static void remove_from_table (struct table_elt *, unsigned);
-static struct table_elt *lookup	(rtx, unsigned, enum machine_mode);
+static void remove_pseudo_from_table (rtx, unsigned);
+static struct table_elt *lookup (rtx, unsigned, enum machine_mode);
 static struct table_elt *lookup_for_remove (rtx, unsigned, enum machine_mode);
 static rtx lookup_as_function (rtx, enum rtx_code);
 static struct table_elt *insert (rtx, struct table_elt *, unsigned,
@@ -1382,6 +1383,19 @@ remove_from_table (struct table_elt *elt, unsigned int hash)
   table_size--;
 }
 
+/* Same as above, but X is a pseudo-register.  */
+
+static void
+remove_pseudo_from_table (rtx x, unsigned int hash)
+{
+  struct table_elt *elt;
+
+  /* Because a pseudo-register can be referenced in more than one
+     mode, we might have to remove more than one table entry.  */
+  while ((elt = lookup_for_remove (x, hash, VOIDmode)))
+    remove_from_table (elt, hash);
+}
+
 /* Look up X in the hash table and return its table element,
    or 0 if X is not in the table.
 
@@ -1708,7 +1722,10 @@ merge_equiv_classes (struct table_elt *class1, struct table_elt *class2)
 	      delete_reg_equiv (REGNO (exp));
 	    }
 
-	  remove_from_table (elt, hash);
+	  if (REG_P (exp) && REGNO (exp) >= FIRST_PSEUDO_REGISTER)
+	    remove_pseudo_from_table (exp, hash);
+	  else
+	    remove_from_table (elt, hash);
 
 	  if (insert_regs (exp, class1, 0) || need_rehash)
 	    {
@@ -1804,14 +1821,7 @@ invalidate (rtx x, enum machine_mode full_mode)
 	SUBREG_TICKED (regno) = -1;
 
 	if (regno >= FIRST_PSEUDO_REGISTER)
-	  {
-	    /* Because a register can be referenced in more than one mode,
-	       we might have to remove more than one table entry.  */
-	    struct table_elt *elt;
-
-	    while ((elt = lookup_for_remove (x, hash, GET_MODE (x))))
-	      remove_from_table (elt, hash);
-	  }
+	  remove_pseudo_from_table (x, hash);
 	else
 	  {
 	    HOST_WIDE_INT in_table
@@ -6016,8 +6026,11 @@ cse_insn (rtx insn, rtx libcall_insn)
 		{
 		  if (insert_regs (x, NULL, 0))
 		    {
+		      rtx dest = SET_DEST (sets[i].rtl);
+
 		      rehash_using_reg (x);
 		      hash = HASH (x, mode);
+		      sets[i].dest_hash = HASH (dest, GET_MODE (dest));
 		    }
 		  elt = insert (x, NULL, hash, mode);
 		}
diff --git a/gcc/doc/cpp.texi b/gcc/doc/cpp.texi
index 671ed1430da..a4ddec8f5e2 100644
--- a/gcc/doc/cpp.texi
+++ b/gcc/doc/cpp.texi
@@ -2019,6 +2019,28 @@ functions.  You should not use these macros in any way unless you make
 sure that programs will execute with the same effect whether or not they
 are defined.  If they are defined, their value is 1.
 
+@item __GNUC_GNU_INLINE__
+GCC defines this macro if functions declared @code{inline} will be
+handled in GCC's traditional gnu89 mode.  In this mode an @code{extern
+inline} function will never be compiled as a standalone function, and
+an @code{inline} function which is neither @code{extern} nor
+@code{static} will always be compiled as a standalone function.
+
+@item __GNUC_STDC_INLINE__
+GCC defines this macro if functions declared @code{inline} will be
+handled according to the ISO C99 standard.  In this mode an
+@code{extern inline} function will always be compiled as a standalone
+externally visible function, and an @code{inline} function which is
+neither @code{extern} nor @code{static} will never be compiled as a
+standalone function.
+
+If this macro is defined, GCC supports the @code{gnu_inline} function
+attribute as a way to always get the gnu89 behaviour.  Support for
+this and @code{__GNUC_GNU_INLINE__} was added in GCC 4.1.3.  If
+neither macro is defined, an older version of GCC is being used:
+@code{inline} functions will be compiled in gnu89 mode, and the
+@code{gnu_inline} function attribute will not be recognized.
+
 @item __CHAR_UNSIGNED__
 GCC defines this macro if and only if the data type @code{char} is
 unsigned on the target machine.  It exists to cause the standard header
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index bed6e1e10a3..f7b6f4a1ec6 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -1527,8 +1527,8 @@ attributes are currently defined for functions on all targets:
 @code{format}, @code{format_arg}, @code{no_instrument_function},
 @code{section}, @code{constructor}, @code{destructor}, @code{used},
 @code{unused}, @code{deprecated}, @code{weak}, @code{malloc},
-@code{alias}, @code{warn_unused_result}, @code{nonnull}
-and @code{externally_visible}.  Several other
+@code{alias}, @code{warn_unused_result}, @code{nonnull},
+@code{gnu_inline} and @code{externally_visible}.  Several other
 attributes are defined for functions on particular target systems.  Other
 attributes, including @code{section} are supported for variables declarations
 (@pxref{Variable Attributes}) and for types (@pxref{Type Attributes}).
@@ -1566,6 +1566,46 @@ Generally, functions are not inlined unless optimization is specified.
 For functions declared inline, this attribute inlines the function even
 if no optimization level was specified.
 
+@item gnu_inline
+@cindex @code{gnu_inline} function attribute
+This attribute should be used with a function which is also declared
+with the @code{inline} keyword.  It directs GCC to treat the function
+as if it were defined in gnu89 mode even when compiling in C99 or
+gnu99 mode.
+
+If the function is declared @code{extern}, then this definition of the
+function is used only for inlining.  In no case is the function
+compiled as a standalone function, not even if you take its address
+explicitly.  Such an address becomes an external reference, as if you
+had only declared the function, and had not defined it.  This has
+almost the effect of a macro.  The way to use this is to put a
+function definition in a header file with this attribute, and put
+another copy of the function, without @code{extern}, in a library
+file.  The definition in the header file will cause most calls to the
+function to be inlined.  If any uses of the function remain, they will
+refer to the single copy in the library.  Note that the two
+definitions of the functions need not be precisely the same, although
+if they do not have the same effect your program may behave oddly.
+
+If the function is neither @code{extern} nor @code{static}, then the
+function is compiled as a standalone function, as well as being
+inlined where possible.
+
+This is how GCC traditionally handled functions declared
+@code{inline}.  Since ISO C99 specifies a different semantics for
+@code{inline}, this function attribute is provided as a transition
+measure and as a useful feature in its own right.  This attribute is
+available in GCC 4.1.3 and later.  It is available if either of the
+preprocessor macros @code{__GNUC_GNU_INLINE__} or
+@code{__GNUC_STDC_INLINE__} are defined.  @xref{Inline,,An Inline
+Function is As Fast As a Macro}.
+
+Note that since the first version of GCC to support C99 inline semantics
+is 4.3, earlier versions of GCC which accept this attribute effectively
+assume that it is always present, whether or not it is given explicitly.
+In versions prior to 4.3, the only effect of explicitly including it is
+to disable warnings about using inline functions in C99 mode.
+
 @cindex @code{flatten} function attribute
 @item flatten
 Generally, inlining into a function is limited.  For a function marked with
@@ -3518,7 +3558,15 @@ you don't use @option{-O}, no function is really inline.
 
 Inline functions are included in the ISO C99 standard, but there are
 currently substantial differences between what GCC implements and what
-the ISO C99 standard requires.
+the ISO C99 standard requires.  GCC will fully support C99 inline
+functions in version 4.3.  The traditional GCC handling of inline
+functions will still be available with @option{-std=gnu89},
+@option{-fgnu89-inline} or when @code{gnu_inline} attribute is present
+on all inline declarations.  The preprocessor macros
+@code{__GNUC_GNU_INLINE__} and @code{__GNUC_STDC_INLINE__} may be used
+to determine the handling of @code{inline} during a particular
+compilation (@pxref{Common Predefined Macros,,,cpp.info,The C
+Preprocessor}).
 
 To declare a function inline, use the @code{inline} keyword in its
 declaration, like this:
@@ -3594,12 +3642,15 @@ The definition in the header file will cause most calls to the function
 to be inlined.  If any uses of the function remain, they will refer to
 the single copy in the library.
 
-Since GCC eventually will implement ISO C99 semantics for
-inline functions, it is best to use @code{static inline} only
+Since GCC 4.3 will implement ISO C99 semantics for
+inline functions, it is simplest to use @code{static inline} only
 to guarantee compatibility.  (The
 existing semantics will remain available when @option{-std=gnu89} is
-specified, but eventually the default will be @option{-std=gnu99} and
-that will implement the C99 semantics, though it does not do so yet.)
+specified, but eventually the default will be @option{-std=gnu99};
+that will implement the C99 semantics, though it does not do so in
+versions of GCC before 4.3.  After the default changes, the existing
+semantics will still be available via the @option{-fgnu89-inline}
+option or the @code{gnu_inline} function attribute.)
 
 GCC does not inline any functions when not optimizing unless you specify
 the @samp{always_inline} attribute for the function, like this:
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 910f438d68c..f8f389809e0 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -160,7 +160,8 @@ in the following sections.
 
 @item C Language Options
 @xref{C Dialect Options,,Options Controlling C Dialect}.
-@gccoptlist{-ansi  -std=@var{standard}  -aux-info @var{filename} @gol
+@gccoptlist{-ansi  -std=@var{standard}  -fgnu89-inline @gol
+-aux-info @var{filename} @gol
 -fno-asm  -fno-builtin  -fno-builtin-@var{function} @gol
 -fhosted  -ffreestanding  -fms-extensions @gol
 -trigraphs  -no-integrated-cpp  -traditional  -traditional-cpp @gol
@@ -294,10 +295,11 @@ Objective-C and Objective-C++ Dialects}.
 
 @item Optimization Options
 @xref{Optimize Options,,Options that Control Optimization}.
-@gccoptlist{-falign-functions=@var{n}  -falign-jumps=@var{n} @gol
--falign-labels=@var{n}  -falign-loops=@var{n}  @gol
--fbounds-check -fmudflap -fmudflapth -fmudflapir @gol
--fbranch-probabilities -fprofile-values -fvpt -fbranch-target-load-optimize @gol
+@gccoptlist{-falign-functions[=@var{n}]  -falign-jumps[=@var{n}] @gol
+-falign-labels[=@var{n}]  -falign-loops[=@var{n}]  @gol
+-fmudflap -fmudflapth -fmudflapir @gol
+-fbranch-probabilities -fprofile-values -fvpt @gol
+-fbranch-target-load-optimize @gol
 -fbranch-target-load-optimize2 -fbtr-bb-exclusive @gol
 -fcaller-saves  -fcprop-registers  -fcse-follow-jumps @gol
 -fcse-skip-blocks  -fcx-limited-range  -fdata-sections @gol
@@ -324,7 +326,7 @@ Objective-C and Objective-C++ Dialects}.
 -frounding-math -fschedule-insns  -fschedule-insns2 @gol
 -fno-sched-interblock  -fno-sched-spec  -fsched-spec-load @gol
 -fsched-spec-load-dangerous  @gol
--fsched-stalled-insns=@var{n} -fsched-stalled-insns-dep=@var{n} @gol
+-fsched-stalled-insns[=@var{n}] -fsched-stalled-insns-dep[=@var{n}] @gol
 -fsched2-use-superblocks @gol
 -fsched2-use-traces -freschedule-modulo-scheduled-loops @gol
 -fsignaling-nans -fsingle-precision-constant  @gol
@@ -338,7 +340,8 @@ Objective-C and Objective-C++ Dialects}.
 -ftree-dominator-opts -ftree-dse -ftree-copyrename -ftree-sink @gol
 -ftree-ch -ftree-sra -ftree-ter -ftree-lrs -ftree-fre -ftree-vectorize @gol
 -ftree-vect-loop-version -ftree-salias -fweb @gol
--ftree-copy-prop -ftree-store-ccp -ftree-store-copy-prop -fwhole-program @gol
+-ftree-copy-prop -ftree-store-ccp -ftree-store-copy-prop -ftree-vrp @gol
+-funit-at-a-time -fwhole-program @gol
 --param @var{name}=@var{value}
 -O  -O0  -O1  -O2  -O3  -Os}
 
@@ -754,7 +757,7 @@ See S/390 and zSeries Options.
 -fshort-double  -fshort-wchar @gol
 -fverbose-asm  -fpack-struct[=@var{n}]  -fstack-check @gol
 -fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol
--fargument-alias  -fargument-noalias @gol
+-fno-stack-limit  -fargument-alias  -fargument-noalias @gol
 -fargument-noalias-global  -fleading-underscore @gol
 -ftls-model=@var{model} @gol
 -ftrapv  -fwrapv  -fbounds-check @gol
@@ -1186,6 +1189,28 @@ the @code{inline} keyword in ISO C99) are not disabled.
 @xref{Standards,,Language Standards Supported by GCC}, for details of
 these standard versions.
 
+@item -fgnu89-inline
+@opindex fgnu89-inline
+The option @option{-fgnu89-inline} tells GCC to use the traditional
+GNU semantics for @code{inline} functions when in C99 mode.
+@xref{Inline,,An Inline Function is As Fast As a Macro}.  Using this
+option is roughly equivalent to adding the @code{gnu_inline} function
+attribute to all inline functions (@pxref{Function Attributes}).
+
+This option is accepted by GCC versions 4.1.3 and up.  In GCC versions
+prior to 4.3, C99 inline semantics are not supported, and thus this
+option is effectively assumed to be present regardless of whether or not
+it is specified; the only effect of specifying it explicitly is to
+disable warnings about using inline functions in C99 mode.  Likewise,
+the option @option{-fno-gnu89-inline} is not supported in versions of
+GCC before 4.3.  It will be supported only in C99 or gnu99 mode, not in
+C89 or gnu89 mode.
+
+The preprocesor macros @code{__GNUC_GNU_INLINE__} and
+@code{__GNUC_STDC_INLINE__} may be used to check which semantics are
+in effect for @code{inline} functions.  @xref{Common Predefined
+Macros,,,cpp,The C Preprocessor}.
+
 @item -aux-info @var{filename}
 @opindex aux-info
 Output to the given filename prototyped declarations for all functions
@@ -4587,6 +4612,7 @@ check if the variable was referenced, regardless of whether or not
 optimization is turned on, use the @option{-fno-keep-static-consts} option.
 
 @item -fmerge-constants
+@opindex fmerge-constants
 Attempt to merge identical constants (string constants and floating point
 constants) across compilation units.
 
@@ -4597,6 +4623,7 @@ behavior.
 Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
 
 @item -fmerge-all-constants
+@opindex fmerge-all-constants
 Attempt to merge identical constants and identical variables.
 
 This option implies @option{-fmerge-constants}.  In addition to
@@ -4647,13 +4674,6 @@ assumptions based on that.
 
 The default is @option{-fzero-initialized-in-bss}.
 
-@item -fbounds-check
-@opindex fbounds-check
-For front-ends that support it, generate additional code to check that
-indices used to access arrays are within the declared range.  This is
-currently only supported by the Java and Fortran front-ends, where
-this option defaults to true and false respectively.
-
 @item -fmudflap -fmudflapth -fmudflapir
 @opindex fmudflap
 @opindex fmudflapth
@@ -4798,14 +4818,14 @@ Using @option{-Wunsafe-loop-optimizations}, the compiler will warn you
 if it finds this kind of loop.
 
 @item -fcrossjumping
-@opindex crossjumping
+@opindex fcrossjumping
 Perform cross-jumping transformation.  This transformation unifies equivalent code and save code size.  The
 resulting code may or may not perform better than without cross-jumping.
 
 Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
 
 @item -fif-conversion
-@opindex if-conversion
+@opindex fif-conversion
 Attempt to transform conditional jumps into branch-less equivalents.  This
 include use of conditional moves, min, max, set flags and abs instructions, and
 some tricks doable by standard arithmetics.  The use of conditional execution
@@ -4814,7 +4834,7 @@ on chips where it is available is controlled by @code{if-conversion2}.
 Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
 
 @item -fif-conversion2
-@opindex if-conversion2
+@opindex fif-conversion2
 Use conditional execution (where available) to transform conditional jumps into
 branch-less equivalents.
 
@@ -4905,17 +4925,27 @@ Allow speculative motion of more load instructions.  This only makes
 sense when scheduling before register allocation, i.e.@: with
 @option{-fschedule-insns} or at @option{-O2} or higher.
 
-@item -fsched-stalled-insns=@var{n}
+@item -fsched-stalled-insns
+@itemx -fsched-stalled-insns=@var{n}
 @opindex fsched-stalled-insns
 Define how many insns (if any) can be moved prematurely from the queue
 of stalled insns into the ready list, during the second scheduling pass.
+@option{-fno-fsched-stalled-insns} and @option{-fsched-stalled-insns=0}
+are equivalent and mean that no insns will be moved prematurely.
+If @var{n} is unspecified then there is no limit on how many queued
+insns can be moved prematurely.
 
-@item -fsched-stalled-insns-dep=@var{n}
+@item -fsched-stalled-insns-dep
+@itemx -fsched-stalled-insns-dep=@var{n}
 @opindex fsched-stalled-insns-dep
 Define how many insn groups (cycles) will be examined for a dependency
 on a stalled insn that is candidate for premature removal from the queue
-of stalled insns.  Has an effect only during the second scheduling pass,
+of stalled insns.  This has an effect only during the second scheduling pass,
 and only if @option{-fsched-stalled-insns} is used and its value is not zero.
++@option{-fno-sched-stalled-insns-dep} is equivalent to
++@option{-fsched-stalled-insns-dep=0}.
++@option{-fsched-stalled-insns-dep} without a value is equivalent to
++@option{-fsched-stalled-insns-dep=1}.
 
 @item -fsched2-use-superblocks
 @opindex fsched2-use-superblocks
@@ -4942,7 +4972,7 @@ sense when scheduling after register allocation, i.e.@: with
 @option{-fschedule-insns2} or at @option{-O2} or higher.
 
 @item -freschedule-modulo-scheduled-loops
-@opindex fscheduling-in-modulo-scheduled-loops
+@opindex freschedule-modulo-scheduled-loops
 The modulo scheduling comes before the traditional scheduling, if a loop was modulo scheduled
 we may want to prevent the later scheduling passes from changing its schedule, we use this
 option to control that.
@@ -4960,10 +4990,12 @@ those which have no call-preserved registers to use instead.
 Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
 
 @item -ftree-pre
+@opindex ftree-pre
 Perform Partial Redundancy Elimination (PRE) on trees.  This flag is
 enabled by default at @option{-O2} and @option{-O3}.
 
 @item -ftree-fre
+@opindex ftree-fre
 Perform Full Redundancy Elimination (FRE) on trees.  The difference
 between FRE and PRE is that FRE only considers expressions
 that are computed on all paths leading to the redundant computation.
@@ -4971,40 +5003,48 @@ This analysis faster than PRE, though it exposes fewer redundancies.
 This flag is enabled by default at @option{-O} and higher.
 
 @item -ftree-copy-prop
+@opindex ftree-copy-prop
 Perform copy propagation on trees.  This pass eliminates unnecessary
 copy operations.  This flag is enabled by default at @option{-O} and
 higher.
 
 @item -ftree-store-copy-prop
+@opindex ftree-store-copy-prop
 Perform copy propagation of memory loads and stores.  This pass
 eliminates unnecessary copy operations in memory references
 (structures, global variables, arrays, etc).  This flag is enabled by
 default at @option{-O2} and higher.
 
 @item -ftree-salias
+@opindex ftree-salias
 Perform structural alias analysis on trees.  This flag
 is enabled by default at @option{-O} and higher.
 
 @item -ftree-sink
+@opindex ftree-sink
 Perform forward store motion  on trees.  This flag is
 enabled by default at @option{-O} and higher.
 
 @item -ftree-ccp
+@opindex ftree-ccp
 Perform sparse conditional constant propagation (CCP) on trees.  This
 pass only operates on local scalar variables and is enabled by default
 at @option{-O} and higher.
 
 @item -ftree-store-ccp
+@opindex ftree-store-ccp
 Perform sparse conditional constant propagation (CCP) on trees.  This
 pass operates on both local scalar variables and memory stores and
 loads (global variables, structures, arrays, etc).  This flag is
 enabled by default at @option{-O2} and higher.
 
 @item -ftree-dce
+@opindex ftree-dce
 Perform dead code elimination (DCE) on trees.  This flag is enabled by
 default at @option{-O} and higher.
 
 @item -ftree-dominator-opts
+@opindex ftree-dominator-opts
 Perform a variety of simple scalar cleanups (constant/copy
 propagation, redundancy elimination, range propagation and expression
 simplification) based on a dominator tree traversal.  This also
@@ -5012,20 +5052,24 @@ performs jump threading (to reduce jumps to jumps). This flag is
 enabled by default at @option{-O} and higher.
 
 @item -ftree-ch
+@opindex ftree-ch
 Perform loop header copying on trees.  This is beneficial since it increases
 effectiveness of code motion optimizations.  It also saves one jump.  This flag
 is enabled by default at @option{-O} and higher.  It is not enabled
 for @option{-Os}, since it usually increases code size.
 
 @item -ftree-loop-optimize
+@opindex ftree-loop-optimize
 Perform loop optimizations on trees.  This flag is enabled by default
 at @option{-O} and higher.
 
 @item -ftree-loop-linear
+@opindex ftree-loop-linear
 Perform linear loop transformations on tree.  This flag can improve cache
 performance and allow further loop optimizations to take place.
 
 @item -ftree-loop-im
+@opindex ftree-loop-im
 Perform loop invariant motion on trees.  This pass moves only invariants that
 would be hard to handle at RTL level (function calls, operations that expand to
 nontrivial sequences of insns).  With @option{-funswitch-loops} it also moves
@@ -5034,27 +5078,32 @@ just trivial invariantness analysis in loop unswitching.  The pass also includes
 store motion.
 
 @item -ftree-loop-ivcanon
+@opindex ftree-loop-ivcanon
 Create a canonical counter for number of iterations in the loop for that
 determining number of iterations requires complicated analysis.  Later
 optimizations then may determine the number easily.  Useful especially
 in connection with unrolling.
 
 @item -fivopts
+@opindex fivopts
 Perform induction variable optimizations (strength reduction, induction
 variable merging and induction variable elimination) on trees.
 
 @item -ftree-sra
+@opindex ftree-sra
 Perform scalar replacement of aggregates.  This pass replaces structure
 references with scalars to prevent committing structures to memory too
 early.  This flag is enabled by default at @option{-O} and higher.
 
 @item -ftree-copyrename
+@opindex ftree-copyrename
 Perform copy renaming on trees.  This pass attempts to rename compiler
 temporaries to other variables at copy locations, usually resulting in
 variable names which more closely resemble the original variables.  This flag
 is enabled by default at @option{-O} and higher.
 
 @item -ftree-ter
+@opindex ftree-ter
 Perform temporary expression replacement during the SSA->normal phase.  Single
 use/single def temporaries are replaced at their use location with their
 defining expression.  This results in non-GIMPLE code, but gives the expanders
@@ -5062,11 +5111,13 @@ much more complex trees to work on resulting in better RTL generation.  This is
 enabled by default at @option{-O} and higher.
 
 @item -ftree-lrs
+@opindex ftree-lrs
 Perform live range splitting during the SSA->normal phase.  Distinct live
 ranges of a variable are split into unique variables, allowing for better
 optimization later.  This is enabled by default at @option{-O} and higher.
 
 @item -ftree-vectorize
+@opindex ftree-vectorize
 Perform loop vectorization on trees.
 
 @item -ftree-vect-loop-version
@@ -5079,6 +5130,7 @@ to control which version is executed.  This option is enabled by default
 except at level @option{-Os} where it is disabled.
 
 @item -ftree-vrp
+@opindex ftree-vrp
 Perform Value Range Propagation on trees.  This is similar to the
 constant propagation pass, but instead of values, ranges of values are
 propagated.  This allows the optimizers to remove unnecessary range
@@ -5108,7 +5160,7 @@ the loop is entered.  This usually makes programs run more slowly.
 @option{-funroll-loops},
 
 @item -fsplit-ivs-in-unroller
-@opindex -fsplit-ivs-in-unroller
+@opindex fsplit-ivs-in-unroller
 Enables expressing of values of induction variables in later iterations
 of the unrolled loop using the value in the first iteration.  This breaks
 long dependency chains, thus improving efficiency of the scheduling passes.
@@ -5121,7 +5173,7 @@ on some of the architectures due to restrictions in the CSE pass.
 This optimization is enabled by default.
 
 @item -fvariable-expansion-in-unroller
-@opindex -fvariable-expansion-in-unroller
+@opindex fvariable-expansion-in-unroller
 With this option, the compiler will create multiple copies of some
 local variables when unrolling a loop which can result in superior code.
 
@@ -5368,13 +5420,13 @@ programs since the functions and variables become local for the whole combined
 compilation unit, not for the single source file itself.
 
 
-@item -fno-cprop-registers
-@opindex fno-cprop-registers
+@item -fcprop-registers
+@opindex fcprop-registers
 After register allocation and post-register allocation instruction splitting,
 we perform a copy-propagation pass to try to reduce scheduling dependencies
 and occasionally eliminate the copy.
 
-Disabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
 
 @item -fprofile-generate
 @opindex fprofile-generate
@@ -5531,9 +5583,7 @@ Treat floating point constant as single precision constant instead of
 implicitly converting it to double precision constant.
 
 @item -fcx-limited-range
-@itemx -fno-cx-limited-range
 @opindex fcx-limited-range
-@opindex fno-cx-limited-range
 When enabled, this option states that a range reduction step is not
 needed when performing complex division.  The default is
 @option{-fno-cx-limited-range}, but is enabled by @option{-ffast-math}.
@@ -5693,6 +5743,7 @@ When performing branch target register load optimization, don't reuse
 branch target registers in within any basic block.
 
 @item -fstack-protector
+@opindex fstack-protector
 Emit extra code to check for buffer overflows, such as stack smashing
 attacks.  This is done by adding a guard variable to functions with
 vulnerable objects.  This includes functions that call alloca, and
@@ -5701,6 +5752,7 @@ when a function is entered and then checked when the function exits.
 If a guard check fails, an error message is printed and the program exits.
 
 @item -fstack-protector-all
+@opindex fstack-protector-all
 Like @option{-fstack-protector} except that all functions are protected.
 
 @item --param @var{name}=@var{value}
@@ -6082,6 +6134,12 @@ feedback is available and may be set to higher values than
 @option{reorder-block-duplicate} since information about the hot spots is more
 accurate.
 
+@item max-sched-ready-insns
+The maximum number of instructions ready to be issued the scheduler should
+consider at any given time during the first scheduling pass.  Increasing
+values mean more thorough searches, making the compilation time increase
+with probably little benefit.  The default value is 100.
+
 @item max-sched-region-blocks
 The maximum number of blocks in a region to be considered for
 interblock scheduling.  The default value is 10.
@@ -13083,6 +13141,7 @@ switch.  Use it to conform to a non-default application binary interface.
 Not all targets provide complete support for this switch.
 
 @item -ftls-model=@var{model}
+@opindex ftls-model=@var{model}
 Alter the thread-local storage model to be used (@pxref{Thread-Local}).
 The @var{model} argument should be one of @code{global-dynamic},
 @code{local-dynamic}, @code{initial-exec} or @code{local-exec}.
diff --git a/gcc/doc/rtl.texi b/gcc/doc/rtl.texi
index ea4ded7aa83..5fc134dc11b 100644
--- a/gcc/doc/rtl.texi
+++ b/gcc/doc/rtl.texi
@@ -616,8 +616,8 @@ are already in a non-addressable component of an aggregate.
 Stored in the @code{jump} field and printed as @samp{/j}.
 
 @findex MEM_SCALAR_P
-@cindex @code{mem} and @samp{/f}
-@cindex @code{frame_related}, in @code{mem}
+@cindex @code{mem} and @samp{/i}
+@cindex @code{return_val}, in @code{mem}
 @item MEM_SCALAR_P (@var{x})
 In @code{mem} expressions, nonzero for reference to a scalar known not
 to be a member of a structure, union, or array.  Zero for such
@@ -625,7 +625,7 @@ references and for indirections through pointers, even pointers pointing
 to scalar types.  If both this flag and @code{MEM_IN_STRUCT_P} are clear,
 then we don't know whether this @code{mem} is in a structure or not.
 Both flags should never be simultaneously set.
-Stored in the @code{frame_related} field and printed as @samp{/f}.
+Stored in the @code{return_val} field and printed as @samp{/i}.
 
 @findex MEM_VOLATILE_P
 @cindex @code{mem} and @samp{/v}
@@ -644,13 +644,20 @@ Stored in the @code{volatil} field and printed as @samp{/v}.
 In @code{mem}, nonzero for memory references that will not trap.
 Stored in the @code{call} field and printed as @samp{/c}.
 
+@findex MEM_POINTER
+@cindex @code{mem} and @samp{/f}
+@cindex @code{frame_related}, in @code{mem}
+@item MEM_POINTER (@var{x})
+Nonzero in a @code{mem} if the memory reference holds a pointer.
+Stored in the @code{frame_related} field and printed as @samp{/f}.
+
 @findex REG_FUNCTION_VALUE_P
 @cindex @code{reg} and @samp{/i}
-@cindex @code{integrated}, in @code{reg}
+@cindex @code{return_val}, in @code{reg}
 @item REG_FUNCTION_VALUE_P (@var{x})
 Nonzero in a @code{reg} if it is the place in which this function's
 value is going to be returned.  (This happens only in a hard
-register.)  Stored in the @code{integrated} field and printed as
+register.)  Stored in the @code{return_val} field and printed as
 @samp{/i}.
 
 @findex REG_POINTER
@@ -707,19 +714,6 @@ computation performed by this instruction, i.e., one that
 This flag is required for exception handling support on targets with RTL
 prologues.
 
-@cindex @code{insn} and @samp{/i}
-@cindex @code{call_insn} and @samp{/i}
-@cindex @code{jump_insn} and @samp{/i}
-@cindex @code{barrier} and @samp{/i}
-@cindex @code{code_label} and @samp{/i}
-@cindex @code{insn_list} and @samp{/i}
-@cindex @code{const} and @samp{/i}
-@cindex @code{note} and @samp{/i}
-@cindex @code{integrated}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{barrier}, @code{code_label}, @code{insn_list}, @code{const}, and @code{note}
-@code{code_label}, @code{insn_list}, @code{const}, or @code{note} if it
-resulted from an in-line function call.
-Stored in the @code{integrated} field and printed as @samp{/i}.
-
 @findex MEM_READONLY_P
 @cindex @code{mem} and @samp{/u}
 @cindex @code{unchanging}, in @code{mem}
@@ -818,10 +812,10 @@ once.  Stored in the @code{used} field.
 
 @findex SYMBOL_REF_WEAK
 @cindex @code{symbol_ref} and @samp{/i}
-@cindex @code{integrated}, in @code{symbol_ref}
+@cindex @code{return_val}, in @code{symbol_ref}
 @item SYMBOL_REF_WEAK (@var{x})
 In a @code{symbol_ref}, indicates that @var{x} has been declared weak.
-Stored in the @code{integrated} field and printed as @samp{/i}.
+Stored in the @code{return_val} field and printed as @samp{/i}.
 
 @findex SYMBOL_REF_FLAG
 @cindex @code{symbol_ref} and @samp{/v}
@@ -855,11 +849,11 @@ frame pointer.
 
 In @code{reg} expressions, 1 means that the register holds a pointer.
 
+In @code{mem} expressions, 1 means that the memory reference holds a pointer.
+
 In @code{symbol_ref} expressions, 1 means that the reference addresses
 this function's string constant pool.
 
-In @code{mem} expressions, 1 means that the reference is to a scalar.
-
 In an RTL dump, this flag is represented as @samp{/f}.
 
 @findex in_struct
@@ -898,18 +892,18 @@ must be scheduled as part of a group together with the previous insn.
 
 In an RTL dump, this flag is represented as @samp{/s}.
 
-@findex integrated
+@findex return_val
 @cindex @samp{/i} in RTL dump
-@item integrated
-In an @code{insn}, @code{insn_list}, or @code{const}, 1 means the RTL was
-produced by procedure integration.
-
+@item return_val
 In @code{reg} expressions, 1 means the register contains
 the value to be returned by the current function.  On
 machines that pass parameters in registers, the same register number
 may be used for parameters as well, but this flag is not set on such
 uses.
 
+In @code{mem} expressions, 1 means the memory reference is to a scalar
+known not to be a member of a structure, union, or array.
+
 In @code{symbol_ref} expressions, 1 means the referenced symbol is weak.
 
 In an RTL dump, this flag is represented as @samp{/i}.
diff --git a/gcc/doc/tm.texi b/gcc/doc/tm.texi
index 07c3ce1ff88..c5a3d240c64 100644
--- a/gcc/doc/tm.texi
+++ b/gcc/doc/tm.texi
@@ -7314,6 +7314,14 @@ code must advance @var{ptr} to the beginning of the filename on that
 line.  Otherwise, it must set @var{ptr} to @code{NULL}.
 @end defmac
 
+@defmac SHLIB_SUFFIX
+Define this macro to a C string constant containing the default shared
+library extension of the target (e.g., @samp{".so"}).  @command{collect2}
+strips version information after this suffix when generating global
+constructor and destructor names.  This define is only needed on targets
+that use @command{collect2} to process constructors and destructors.
+@end defmac
+
 @node Instruction Output
 @subsection Output of Assembler Instructions
 
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index c57eff99fd1..0eaf18d7902 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -8407,7 +8407,10 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,
 	      mod_type_die = lookup_type_die (qualified_type);
 	    }
 	  else if (is_const_type < TYPE_READONLY (dtype)
-		   || is_volatile_type < TYPE_VOLATILE (dtype))
+		   || is_volatile_type < TYPE_VOLATILE (dtype)
+		   || (is_const_type <= TYPE_READONLY (dtype)
+		       && is_volatile_type <= TYPE_VOLATILE (dtype)
+		       && DECL_ORIGINAL_TYPE (type_name) != type))
 	    /* cv-unqualified version of named type.  Just use the unnamed
 	       type to which it refers.  */
 	    mod_type_die
@@ -12890,7 +12893,8 @@ force_decl_die (tree decl)
   return decl_die;
 }
 
-/* Returns the DIE for TYPE.  A DIE is always returned.  */
+/* Returns the DIE for TYPE, that must not be a base type.  A DIE is
+   always returned.  */
 
 static dw_die_ref
 force_type_die (tree type)
@@ -13241,7 +13245,12 @@ dwarf2out_imported_module_or_decl (tree decl, tree context)
 
   /* For TYPE_DECL or CONST_DECL, lookup TREE_TYPE.  */
   if (TREE_CODE (decl) == TYPE_DECL || TREE_CODE (decl) == CONST_DECL)
-    at_import_die = force_type_die (TREE_TYPE (decl));
+    {
+      if (is_base_type (TREE_TYPE (decl)))
+	at_import_die = base_type_die (TREE_TYPE (decl));
+      else
+	at_import_die = force_type_die (TREE_TYPE (decl));
+    }
   else
     {
       at_import_die = lookup_decl_die (decl);
@@ -14142,7 +14151,9 @@ dwarf2out_finish (const char *filename)
 	      else if (TYPE_P (node->created_for))
 		context = TYPE_CONTEXT (node->created_for);
 
-	      gcc_assert (context && TREE_CODE (context) == FUNCTION_DECL);
+	      gcc_assert (context
+			  && (TREE_CODE (context) == FUNCTION_DECL
+			      || TREE_CODE (context) == NAMESPACE_DECL));
 
 	      origin = lookup_decl_die (context);
 	      if (origin)
diff --git a/gcc/expr.c b/gcc/expr.c
index 82df27e5e14..a32caddd285 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -4614,14 +4614,7 @@ count_type_elements (tree type, bool allow_flexarr)
 
     case UNION_TYPE:
     case QUAL_UNION_TYPE:
-      {
-	/* Ho hum.  How in the world do we guess here?  Clearly it isn't
-	   right to count the fields.  Guess based on the number of words.  */
-        HOST_WIDE_INT n = int_size_in_bytes (type);
-	if (n < 0)
-	  return -1;
-	return n / UNITS_PER_WORD;
-      }
+      return -1;
 
     case COMPLEX_TYPE:
       return 2;
@@ -8569,7 +8562,14 @@ reduce_to_bit_field_precision (rtx exp, rtx target, tree type)
   HOST_WIDE_INT prec = TYPE_PRECISION (type);
   if (target && GET_MODE (target) != GET_MODE (exp))
     target = 0;
-  if (TYPE_UNSIGNED (type))
+  /* For constant values, reduce using build_int_cst_type. */
+  if (GET_CODE (exp) == CONST_INT)
+    {
+      HOST_WIDE_INT value = INTVAL (exp);
+      tree t = build_int_cst_type (type, value);
+      return expand_expr (t, target, VOIDmode, EXPAND_NORMAL);
+    }
+  else if (TYPE_UNSIGNED (type))
     {
       rtx mask;
       if (prec < HOST_BITS_PER_WIDE_INT)
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index f87cc871996..c394e5509e2 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -1,6 +1,7 @@
 /* Fold a constant sub-tree into a single node for C-compiler
    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -5339,6 +5340,9 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)
             }
           break;
         }
+      /* If the constant is negative, we cannot simplify this.  */
+      if (tree_int_cst_sgn (c) == -1)
+        break;
       /* FALLTHROUGH */
     case NEGATE_EXPR:
       if ((t1 = extract_muldiv (op0, c, code, wide_type)) != 0)
@@ -6297,12 +6301,18 @@ fold_widened_comparison (enum tree_code code, tree type, tree arg0, tree arg1)
   if (TYPE_PRECISION (TREE_TYPE (arg0)) <= TYPE_PRECISION (shorter_type))
     return NULL_TREE;
 
-  arg1_unw = get_unwidened (arg1, shorter_type);
+  arg1_unw = get_unwidened (arg1, NULL_TREE);
 
   /* If possible, express the comparison in the shorter mode.  */
   if ((code == EQ_EXPR || code == NE_EXPR
        || TYPE_UNSIGNED (TREE_TYPE (arg0)) == TYPE_UNSIGNED (shorter_type))
       && (TREE_TYPE (arg1_unw) == shorter_type
+	  || (TYPE_PRECISION (shorter_type)
+	      > TYPE_PRECISION (TREE_TYPE (arg1_unw)))
+	  || ((TYPE_PRECISION (shorter_type)
+	       == TYPE_PRECISION (TREE_TYPE (arg1_unw)))
+	      && (TYPE_UNSIGNED (shorter_type)
+		  == TYPE_UNSIGNED (TREE_TYPE (arg1_unw))))
 	  || (TREE_CODE (arg1_unw) == INTEGER_CST
 	      && (TREE_CODE (shorter_type) == INTEGER_TYPE
 		  || TREE_CODE (shorter_type) == BOOLEAN_TYPE)
@@ -7551,6 +7561,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 	{
 	  tree var0, con0, lit0, minus_lit0;
 	  tree var1, con1, lit1, minus_lit1;
+	  bool ok = true;
 
 	  /* Split both trees into variables, constants, and literals.  Then
 	     associate each group together, the constants with literals,
@@ -7561,12 +7572,33 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 	  var1 = split_tree (arg1, code, &con1, &lit1, &minus_lit1,
 			     code == MINUS_EXPR);
 
+	  /* With undefined overflow we can only associate constants
+	     with one variable.  */
+	  if ((POINTER_TYPE_P (type)
+	       || (INTEGRAL_TYPE_P (type)
+		   && !(TYPE_UNSIGNED (type) || flag_wrapv)))
+	      && var0 && var1)
+	    {
+	      tree tmp0 = var0;
+	      tree tmp1 = var1;
+
+	      if (TREE_CODE (tmp0) == NEGATE_EXPR)
+	        tmp0 = TREE_OPERAND (tmp0, 0);
+	      if (TREE_CODE (tmp1) == NEGATE_EXPR)
+	        tmp1 = TREE_OPERAND (tmp1, 0);
+	      /* The only case we can still associate with two variables
+		 is if they are the same, modulo negation.  */
+	      if (!operand_equal_p (tmp0, tmp1, 0))
+	        ok = false;
+	    }
+
 	  /* Only do something if we found more than two objects.  Otherwise,
 	     nothing has changed and we risk infinite recursion.  */
-	  if (2 < ((var0 != 0) + (var1 != 0)
-		   + (con0 != 0) + (con1 != 0)
-		   + (lit0 != 0) + (lit1 != 0)
-		   + (minus_lit0 != 0) + (minus_lit1 != 0)))
+	  if (ok
+	      && (2 < ((var0 != 0) + (var1 != 0)
+		       + (con0 != 0) + (con1 != 0)
+		       + (lit0 != 0) + (lit1 != 0)
+		       + (minus_lit0 != 0) + (minus_lit1 != 0))))
 	    {
 	      /* Recombine MINUS_EXPR operands by using PLUS_EXPR.  */
 	      if (code == MINUS_EXPR)
@@ -8052,6 +8084,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 
       /* ~X | X is -1.  */
       if (TREE_CODE (arg0) == BIT_NOT_EXPR
+	  && INTEGRAL_TYPE_P (TREE_TYPE (arg1))
 	  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))
 	{
 	  t1 = build_int_cst (type, -1);
@@ -8061,6 +8094,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 
       /* X | ~X is -1.  */
       if (TREE_CODE (arg1) == BIT_NOT_EXPR
+	  && INTEGRAL_TYPE_P (TREE_TYPE (arg0))
 	  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))
 	{
 	  t1 = build_int_cst (type, -1);
@@ -8068,6 +8102,53 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 	  return omit_one_operand (type, t1, arg0);
 	}
 
+      /* Canonicalize (X & C1) | C2.  */
+      if (TREE_CODE (arg0) == BIT_AND_EXPR
+	  && TREE_CODE (arg1) == INTEGER_CST
+	  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)
+	{
+	  unsigned HOST_WIDE_INT hi1, lo1, hi2, lo2, mlo, mhi;
+	  int width = TYPE_PRECISION (type);
+	  hi1 = TREE_INT_CST_HIGH (TREE_OPERAND (arg0, 1));
+	  lo1 = TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1));
+	  hi2 = TREE_INT_CST_HIGH (arg1);
+	  lo2 = TREE_INT_CST_LOW (arg1);
+
+	  /* If (C1&C2) == C1, then (X&C1)|C2 becomes (X,C2).  */
+	  if ((hi1 & hi2) == hi1 && (lo1 & lo2) == lo1)
+	    return omit_one_operand (type, arg1, TREE_OPERAND (arg0, 0));
+
+	  if (width > HOST_BITS_PER_WIDE_INT)
+	    {
+	      mhi = (unsigned HOST_WIDE_INT) -1 
+		    >> (2 * HOST_BITS_PER_WIDE_INT - width);
+	      mlo = -1;
+	    }
+	  else
+	    {
+	      mhi = 0;
+	      mlo = (unsigned HOST_WIDE_INT) -1
+		    >> (HOST_BITS_PER_WIDE_INT - width);
+	    }
+
+	  /* If (C1|C2) == ~0 then (X&C1)|C2 becomes X|C2.  */
+	  if ((~(hi1 | hi2) & mhi) == 0 && (~(lo1 | lo2) & mlo) == 0)
+	    return fold_build2 (BIT_IOR_EXPR, type,
+				TREE_OPERAND (arg0, 0), arg1);
+
+	  /* Minimize the number of bits set in C1, i.e. C1 := C1 & ~C2.  */
+	  hi1 &= mhi;
+	  lo1 &= mlo;
+	  if ((hi1 & ~hi2) != hi1 || (lo1 & ~lo2) != lo1)
+	    return fold_build2 (BIT_IOR_EXPR, type,
+				fold_build2 (BIT_AND_EXPR, type,
+					     TREE_OPERAND (arg0, 0),
+					     build_int_cst_wide (type,
+								 lo1 & ~lo2,
+								 hi1 & ~hi2)),
+				arg1);
+	}
+
       t1 = distribute_bit_expr (code, type, arg0, arg1);
       if (t1 != NULL_TREE)
 	return t1;
@@ -8101,6 +8182,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 
       /* ~X ^ X is -1.  */
       if (TREE_CODE (arg0) == BIT_NOT_EXPR
+	  && INTEGRAL_TYPE_P (TREE_TYPE (arg1))
 	  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))
 	{
 	  t1 = build_int_cst (type, -1);
@@ -8110,6 +8192,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 
       /* X ^ ~X is -1.  */
       if (TREE_CODE (arg1) == BIT_NOT_EXPR
+	  && INTEGRAL_TYPE_P (TREE_TYPE (arg0))
 	  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))
 	{
 	  t1 = build_int_cst (type, -1);
@@ -8210,6 +8293,16 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 	  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))
 	return omit_one_operand (type, integer_zero_node, arg0);
 
+      /* Canonicalize (X | C1) & C2 as (X & C2) | (C1 & C2).  */
+      if (TREE_CODE (arg0) == BIT_IOR_EXPR
+	  && TREE_CODE (arg1) == INTEGER_CST
+	  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)
+	return fold_build2 (BIT_IOR_EXPR, type,
+			    fold_build2 (BIT_AND_EXPR, type,
+					 TREE_OPERAND (arg0, 0), arg1),
+			    fold_build2 (BIT_AND_EXPR, type,
+					 TREE_OPERAND (arg0, 1), arg1));
+
       t1 = distribute_bit_expr (code, type, arg0, arg1);
       if (t1 != NULL_TREE)
 	return t1;
@@ -9279,13 +9372,13 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 		  return omit_one_operand (type, integer_zero_node, arg0);
 
 		case GE_EXPR:
-		  return fold_build2 (EQ_EXPR, type, arg0, arg1);
+		  return fold_build2 (EQ_EXPR, type, op0, op1);
 
 		case LE_EXPR:
 		  return omit_one_operand (type, integer_one_node, arg0);
 
 		case LT_EXPR:
-		  return fold_build2 (NE_EXPR, type, arg0, arg1);
+		  return fold_build2 (NE_EXPR, type, op0, op1);
 
 		/* The GE_EXPR and LT_EXPR cases above are not normally
 		   reached because of previous transformations.  */
@@ -9300,10 +9393,14 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 		{
 		case GT_EXPR:
 		  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);
-		  return fold_build2 (EQ_EXPR, type, arg0, arg1);
+		  return fold_build2 (EQ_EXPR, type,
+				      fold_convert (TREE_TYPE (arg1), arg0),
+				      arg1);
 		case LE_EXPR:
 		  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);
-		  return fold_build2 (NE_EXPR, type, arg0, arg1);
+		  return fold_build2 (NE_EXPR, type,
+				      fold_convert (TREE_TYPE (arg1), arg0),
+				      arg1);
 		default:
 		  break;
 		}
@@ -9316,7 +9413,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 		  return omit_one_operand (type, integer_zero_node, arg0);
 
 		case LE_EXPR:
-		  return fold_build2 (EQ_EXPR, type, arg0, arg1);
+		  return fold_build2 (EQ_EXPR, type, op0, op1);
 
 		case GE_EXPR:
 		  return omit_one_operand (type, integer_one_node, arg0);
@@ -9334,10 +9431,14 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 		{
 		case GE_EXPR:
 		  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);
-		  return fold_build2 (NE_EXPR, type, arg0, arg1);
+		  return fold_build2 (NE_EXPR, type,
+				      fold_convert (TREE_TYPE (arg1), arg0),
+				      arg1);
 		case LT_EXPR:
 		  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);
-		  return fold_build2 (EQ_EXPR, type, arg0, arg1);
+		  return fold_build2 (EQ_EXPR, type,
+				      fold_convert (TREE_TYPE (arg1), arg0),
+				      arg1);
 		default:
 		  break;
 		}
@@ -9353,12 +9454,11 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 		   and X >= signed_max+1 because previous transformations.  */
 		if (code == LE_EXPR || code == GT_EXPR)
 		  {
-		    tree st0, st1;
-		    st0 = lang_hooks.types.signed_type (TREE_TYPE (arg0));
-		    st1 = lang_hooks.types.signed_type (TREE_TYPE (arg1));
-		    return fold_build2 (code == LE_EXPR ? GE_EXPR: LT_EXPR,
-			       		type, fold_convert (st0, arg0),
-			       		build_int_cst (st1, 0));
+		    tree st;
+		    st = lang_hooks.types.signed_type (TREE_TYPE (arg1));
+		    return fold_build2 (code == LE_EXPR ? GE_EXPR : LT_EXPR,
+					type, fold_convert (st, arg0),
+					build_int_cst (st, 0));
 		  }
 	      }
 	  }
@@ -9475,24 +9575,24 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)
 	  tree arg01 = TREE_OPERAND (arg0, 1);
 	  if (TREE_CODE (arg00) == LSHIFT_EXPR
 	      && integer_onep (TREE_OPERAND (arg00, 0)))
-	    return
-	      fold_build2 (code, type,
-			   build2 (BIT_AND_EXPR, TREE_TYPE (arg0),
-				   build2 (RSHIFT_EXPR, TREE_TYPE (arg00),
-					   arg01, TREE_OPERAND (arg00, 1)),
-				   fold_convert (TREE_TYPE (arg0),
-						 integer_one_node)),
-			   arg1);
-	  else if (TREE_CODE (TREE_OPERAND (arg0, 1)) == LSHIFT_EXPR
-		   && integer_onep (TREE_OPERAND (TREE_OPERAND (arg0, 1), 0)))
-	    return
-	      fold_build2 (code, type,
-			   build2 (BIT_AND_EXPR, TREE_TYPE (arg0),
-				   build2 (RSHIFT_EXPR, TREE_TYPE (arg01),
-					   arg00, TREE_OPERAND (arg01, 1)),
-				   fold_convert (TREE_TYPE (arg0),
-						 integer_one_node)),
-			   arg1);
+	    {
+	      tree tem = fold_build2 (RSHIFT_EXPR, TREE_TYPE (arg00),
+				      arg01, TREE_OPERAND (arg00, 1));
+	      tem = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg0), tem,
+				 build_int_cst (TREE_TYPE (arg0), 1));
+	      return fold_build2 (code, type,
+				  fold_convert (TREE_TYPE (arg1), tem), arg1);
+	    }
+	  else if (TREE_CODE (arg01) == LSHIFT_EXPR
+		   && integer_onep (TREE_OPERAND (arg01, 0)))
+	    {
+	      tree tem = fold_build2 (RSHIFT_EXPR, TREE_TYPE (arg01),
+				      arg00, TREE_OPERAND (arg01, 1));
+	      tem = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg0), tem,
+				 build_int_cst (TREE_TYPE (arg0), 1));
+	      return fold_build2 (code, type,
+				  fold_convert (TREE_TYPE (arg1), tem), arg1);
+	    }
 	}
 
       /* If this is an NE or EQ comparison of zero against the result of a
@@ -11491,6 +11591,23 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)
       return constant_boolean_node (real_compare (code, c0, c1), type);
     }
 
+  /* Handle equality/inequality of complex constants.  */
+  if (TREE_CODE (op0) == COMPLEX_CST && TREE_CODE (op1) == COMPLEX_CST)
+    {
+      tree rcond = fold_relational_const (code, type,
+					  TREE_REALPART (op0),
+					  TREE_REALPART (op1));
+      tree icond = fold_relational_const (code, type,
+					  TREE_IMAGPART (op0),
+					  TREE_IMAGPART (op1));
+      if (code == EQ_EXPR)
+	return fold_build2 (TRUTH_ANDIF_EXPR, type, rcond, icond);
+      else if (code == NE_EXPR)
+	return fold_build2 (TRUTH_ORIF_EXPR, type, rcond, icond);
+      else
+	return NULL_TREE;
+    }
+
   /* From here on we only handle LT, LE, GT, GE, EQ and NE.
 
      To compute GT, swap the arguments and do LT.
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index 45b11a8a9be..0df5548053a 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,66 @@
+2007-03-17  Francois-Xavier Coudert  <coudert@clipper.ens.fr>
+
+	PR fortran/31184
+	* invoke.texi: Fix typo.
+
+2007-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	* module.c (mio_typespec): Don't look at ts->cl if not BT_CHARACTER.
+
+2007-03-05  Brooks Moses  <brooks.moses@codesourcery.com>
+
+	PR 31050
+	* gfortranspec.c (lang_specific_driver): Update program
+	name and copyright date.
+
+2007-03-01  Tobias Schlueter  <tobi@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/29441
+	* intrinsic.c (gfc_intrinsic_func_interface): Always check if
+	intrinsic is allowed in initialization expression.
+
+2006-02-27  Tobias Schlüter  <tobias.schlueter@physik.uni-muenchen.de>
+
+	PR fortran/25392
+	* trans-stmt.c (gfc_trans_return): Fix comment formatting.
+	* trans-types.c (gfc_sym_type): Don't return early for functions.
+	Remove special handling for -ff2c.
+	(gfc_get_function_type): Add special handling for -ff2c.
+	* trans-decl.c (gfc_create_function_decl): Fix comment formatting.
+	(gfc_get_fake_result_decl): Make sure we get the right type for
+	functions.
+	(gfc_generate_function_code): Convert type of result variable to
+	type of function.
+
+2007-02-25  Roger Sayle  <roger@eyesopen.com>
+	    Paul Thomas <pault@gcc.gnu.org>
+
+        PR fortran/30400
+        * match.c (match_forall_iterator): Use gfc_match_expr instead
+	of gfc_match_variable to match the iterator variable.  Return
+	MATCH_NO if not a variable.  Remove the reset of the symbol's
+	flavor in cleanup.
+
+2007-02-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/30799
+	* primary.c (match_logical_constant): Return MATCH_ERROR on invalid
+	kind.
+
+2007-02-15  Tobias Schlueter  <tobi@gcc.gnu.org>
+
+	PR fortran/30478
+	* decl.c (create_enum_history, gfc_free_enum_history): Formatting
+	fixes.
+	(add_init_expr_to_sym): Remove ENUM-specific code-path.
+	(variable_decl): Likewise.  Formatting fix.
+	(match_attr_spec): Remove ENUM-specific codepath.
+	(gfc_match_enum): Fix typo in error message.
+	(enumerator_decl): New.
+	(gfc_match_enumerator_def): Strip down to code necessary for
+	ENUMs, use enumerator_decl.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index e69ae3cbe28..df362014668 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -758,7 +758,7 @@ gfc_set_constant_character_len (int len, gfc_expr * expr)
    INIT points to its enumerator value.   */
 
 static void 
-create_enum_history(gfc_symbol *sym, gfc_expr *init)
+create_enum_history (gfc_symbol *sym, gfc_expr *init)
 {
   enumerator_history *new_enum_history;
   gcc_assert (sym != NULL && init != NULL);
@@ -789,7 +789,7 @@ create_enum_history(gfc_symbol *sym, gfc_expr *init)
 /* Function to free enum kind history.  */ 
 
 void 
-gfc_free_enum_history(void)
+gfc_free_enum_history (void)
 {
   enumerator_history *current = enum_history;  
   enumerator_history *next;  
@@ -805,7 +805,7 @@ gfc_free_enum_history(void)
 }
 
 
-/* Function called by variable_decl() that adds an initialization
+/* Function called by variabl_decl() that adds an initialization
    expression to a symbol.  */
 
 static try
@@ -911,10 +911,6 @@ add_init_expr_to_sym (const char *name, gfc_expr ** initp,
       *initp = NULL;
     }
 
-  /* Maintain enumerator history.  */
-  if (gfc_current_state () == COMP_ENUM)
-    create_enum_history (sym, init);
-
   return SUCCESS;
 }
 
@@ -1073,14 +1069,6 @@ variable_decl (int elem)
 
   if (m == MATCH_NO)
     as = gfc_copy_array_spec (current_as);
-  else if (gfc_current_state () == COMP_ENUM)
-    {
-      gfc_error ("Enumerator cannot be array at %C");
-      gfc_free_enum_history ();
-      m = MATCH_ERROR;
-      goto cleanup;
-    }
-
 
   char_len = NULL;
   cl = NULL;
@@ -1179,10 +1167,11 @@ variable_decl (int elem)
       goto cleanup;
     }
 
-  /* An interface body specifies all of the procedure's characteristics and these
-     shall be consistent with those specified in the procedure definition, except
-     that the interface may specify a procedure that is not pure if the procedure
-     is defined to be pure(12.3.2).  */
+  /* An interface body specifies all of the procedure's
+     characteristics and these shall be consistent with those
+     specified in the procedure definition, except that the interface
+     may specify a procedure that is not pure if the procedure is
+     defined to be pure(12.3.2).  */
   if (current_ts.type == BT_DERIVED
 	&& gfc_current_ns->proc_name->attr.if_source == IFSRC_IFBODY
 	&& current_ts.derived->ns != gfc_current_ns)
@@ -1288,30 +1277,6 @@ variable_decl (int elem)
 	}
     }
 
-  /* Check if we are parsing an enumeration and if the current enumerator
-     variable has an initializer or not. If it does not have an
-     initializer, the initialization value of the previous enumerator 
-     (stored in last_initializer) is incremented by 1 and is used to
-     initialize the current enumerator.  */
-  if (gfc_current_state () == COMP_ENUM)
-    {
-      if (initializer == NULL)
-        initializer = gfc_enum_initializer (last_initializer, old_locus);
- 
-      if (initializer == NULL || initializer->ts.type != BT_INTEGER)
-        {
-          gfc_error("ENUMERATOR %L not initialized with integer expression",
-		    &var_locus);
-          m = MATCH_ERROR; 
-          gfc_free_enum_history ();
-          goto cleanup;
-        }
-
-      /* Store this current initializer, for the next enumerator
-	 variable to be parsed.  */
-      last_initializer = initializer;
-    }
-
   /* Add the initializer.  Note that it is fine if initializer is
      NULL here, because we sometimes also need to check if a
      declaration *must* have an initialization expression.  */
@@ -2033,12 +1998,6 @@ match_attr_spec (void)
       if (d == DECL_NONE || d == DECL_COLON)
 	break;
        
-      if (gfc_current_state () == COMP_ENUM)
-        {
-          gfc_error ("Enumerator cannot have attributes %C");
-          return MATCH_ERROR;
-        }
-
       seen[d]++;
       seen_at[d] = gfc_current_locus;
 
@@ -2057,18 +2016,6 @@ match_attr_spec (void)
 	}
     }
 
-  /* If we are parsing an enumeration and have ensured that no other
-     attributes are present we can now set the parameter attribute.  */
-  if (gfc_current_state () == COMP_ENUM)
-    {
-      t = gfc_add_flavor (&current_attr, FL_PARAMETER, NULL, NULL);
-      if (t == FAILURE)
-        {
-          m = MATCH_ERROR;
-          goto cleanup;
-        }
-    }
-
   /* No double colon, so assume that we've been looking at something
      else the whole time.  */
   if (d == DECL_NONE)
@@ -4081,7 +4028,7 @@ gfc_match_enum (void)
     return m;
 
   if (gfc_notify_std (GFC_STD_F2003, 
-		      "New in Fortran 2003: ENUM AND ENUMERATOR at %C")
+		      "New in Fortran 2003: ENUM and ENUMERATOR at %C")
       == FAILURE)
     return MATCH_ERROR;
 
@@ -4089,19 +4036,116 @@ gfc_match_enum (void)
 }
 
 
+/* Match a variable name with an optional initializer.  When this
+   subroutine is called, a variable is expected to be parsed next.
+   Depending on what is happening at the moment, updates either the
+   symbol table or the current interface.  */
+
+static match
+enumerator_decl (void)
+{
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  gfc_expr *initializer;
+  gfc_array_spec *as = NULL;
+  gfc_symbol *sym;
+  locus var_locus;
+  match m;
+  try t;
+  locus old_locus;
+
+  initializer = NULL;
+  old_locus = gfc_current_locus;
+
+  /* When we get here, we've just matched a list of attributes and
+     maybe a type and a double colon.  The next thing we expect to see
+     is the name of the symbol.  */
+  m = gfc_match_name (name);
+  if (m != MATCH_YES)
+    goto cleanup;
+
+  var_locus = gfc_current_locus;
+
+  /* OK, we've successfully matched the declaration.  Now put the
+     symbol in the current namespace. If we fail to create the symbol,
+     bail out.  */
+  if (build_sym (name, NULL, &as, &var_locus) == FAILURE)
+    {
+      m = MATCH_ERROR;
+      goto cleanup;
+    }
+
+  /* The double colon must be present in order to have initializers.
+     Otherwise the statement is ambiguous with an assignment statement.  */
+  if (colon_seen)
+    {
+      if (gfc_match_char ('=') == MATCH_YES)
+	{
+	  m = gfc_match_init_expr (&initializer);
+	  if (m == MATCH_NO)
+	    {
+	      gfc_error ("Expected an initialization expression at %C");
+	      m = MATCH_ERROR;
+	    }
+
+	  if (m != MATCH_YES)
+	    goto cleanup;
+	}
+    }
+
+  /* If we do not have an initializer, the initialization value of the
+     previous enumerator (stored in last_initializer) is incremented
+     by 1 and is used to initialize the current enumerator.  */
+  if (initializer == NULL)
+    initializer = gfc_enum_initializer (last_initializer, old_locus);
+ 
+  if (initializer == NULL || initializer->ts.type != BT_INTEGER)
+    {
+      gfc_error("ENUMERATOR %L not initialized with integer expression",
+		&var_locus);
+      m = MATCH_ERROR; 
+      gfc_free_enum_history ();
+      goto cleanup;
+    }
+
+  /* Store this current initializer, for the next enumerator variable
+     to be parsed.  add_init_expr_to_sym() zeros initializer, so we
+     use last_initializer below.  */
+  last_initializer = initializer;
+  t = add_init_expr_to_sym (name, &initializer, &var_locus);
+
+  /* Maintain enumerator history.  */
+  gfc_find_symbol (name, NULL, 0, &sym);
+  create_enum_history (sym, last_initializer);
+
+  return (t == SUCCESS) ? MATCH_YES : MATCH_ERROR;
+
+cleanup:
+  /* Free stuff up and return.  */
+  gfc_free_expr (initializer);
+
+  return m;
+}
+
+
 /* Match the enumerator definition statement. */
 
 match
 gfc_match_enumerator_def (void)
 {
   match m;
-  int elem; 
+  try t;
   
   gfc_clear_ts (&current_ts);
   
   m = gfc_match (" enumerator");
   if (m != MATCH_YES)
     return m;
+
+  m = gfc_match (" :: ");
+  if (m == MATCH_ERROR)
+    return m;
+
+  colon_seen = (m == MATCH_YES);
   
   if (gfc_current_state () != COMP_ENUM)
     {
@@ -4113,17 +4157,17 @@ gfc_match_enumerator_def (void)
   (&current_ts)->type = BT_INTEGER;
   (&current_ts)->kind = gfc_c_int_kind;
   
-  m = match_attr_spec ();
-  if (m == MATCH_ERROR)
+  gfc_clear_attr (&current_attr);
+  t = gfc_add_flavor (&current_attr, FL_PARAMETER, NULL, NULL);
+  if (t == FAILURE)
     {
-      m = MATCH_NO;
+      m = MATCH_ERROR;
       goto cleanup;
     }
 
-  elem = 1;
   for (;;)
     {
-      m = variable_decl (elem++);
+      m = enumerator_decl ();
       if (m == MATCH_ERROR)
 	goto cleanup;
       if (m == MATCH_NO)
diff --git a/gcc/fortran/gfortranspec.c b/gcc/fortran/gfortranspec.c
index 0037f2aaf6b..a3d11426a5a 100644
--- a/gcc/fortran/gfortranspec.c
+++ b/gcc/fortran/gfortranspec.c
@@ -346,8 +346,8 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,
 	  break;
 
 	case OPTION_version:
-	  printf ("GNU Fortran 95 (GCC) %s\n", version_string);
-	  printf ("Copyright %s 2006 Free Software Foundation, Inc.\n\n",
+	  printf ("GNU Fortran (GCC) %s\n", version_string);
+	  printf ("Copyright %s 2007 Free Software Foundation, Inc.\n\n",
 	          _("(C)"));
 	  printf (_("GNU Fortran comes with NO WARRANTY, to the extent permitted by law.\n\
 You may redistribute copies of GNU Fortran\n\
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index 63ee49cab04..92e245bae88 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -3269,8 +3269,7 @@ got_specific:
   /* TODO: We should probably only allow elemental functions here.  */
   flag |= (expr->ts.type != BT_INTEGER && expr->ts.type != BT_CHARACTER);
 
-  if (pedantic && gfc_init_expr
-      && flag && gfc_init_expr_extensions (specific))
+  if (gfc_init_expr && flag && gfc_init_expr_extensions (specific))
     {
       if (gfc_notify_std (GFC_STD_GNU, "Extension: Evaluation of "
 	    "nonstandard initialization expression at %L", &expr->where)
diff --git a/gcc/fortran/invoke.texi b/gcc/fortran/invoke.texi
index ba9867df2a6..283dc40b519 100644
--- a/gcc/fortran/invoke.texi
+++ b/gcc/fortran/invoke.texi
@@ -196,7 +196,7 @@ older Fortran programs.
 @cindex option, -fd-lines-as-comments
 @cindex -fd-lines-as-comments, option
 @item -fd-lines-as-code
-@item -fd-lines-as-comment
+@item -fd-lines-as-comments
 Enables special treating for lines with @samp{d} or @samp{D} in fixed
 form sources.  If the @option{-fd-lines-as-code} option is given
 they are treated as if the first column contained a blank.  If the
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index 53a71ee14cb..06265e4dbd6 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -1,5 +1,5 @@
 /* Matching subroutines in all sizes, shapes and colors.
-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
    Free Software Foundation, Inc.
    Contributed by Andy Vaught
 
@@ -3328,7 +3328,10 @@ gfc_free_forall_iterator (gfc_forall_iterator * iter)
 
 /* Match an iterator as part of a FORALL statement.  The format is:
 
-     <var> = <start>:<end>[:<stride>][, <scalar mask>]  */
+     <var> = <start>:<end>[:<stride>]
+
+   On MATCH_NO, the caller tests for the possibility that there is a
+   scalar mask expression.  */
 
 static match
 match_forall_iterator (gfc_forall_iterator ** result)
@@ -3340,11 +3343,12 @@ match_forall_iterator (gfc_forall_iterator ** result)
   where = gfc_current_locus;
   iter = gfc_getmem (sizeof (gfc_forall_iterator));
 
-  m = gfc_match_variable (&iter->var, 0);
+  m = gfc_match_expr (&iter->var);
   if (m != MATCH_YES)
     goto cleanup;
 
-  if (gfc_match_char ('=') != MATCH_YES)
+  if (gfc_match_char ('=') != MATCH_YES
+	|| iter->var->expr_type != EXPR_VARIABLE)
     {
       m = MATCH_NO;
       goto cleanup;
@@ -3382,13 +3386,6 @@ syntax:
   m = MATCH_ERROR;
 
 cleanup:
-  /* Make sure that potential internal function references in the
-     mask do not get messed up.  */
-  if (iter->var
-	&& iter->var->expr_type == EXPR_VARIABLE
-	&& iter->var->symtree->n.sym->refs == 1)
-    iter->var->symtree->n.sym->attr.flavor = FL_UNKNOWN;
-
   gfc_current_locus = where;
   gfc_free_forall_iterator (iter);
   return m;
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
index 24c7f99067a..af06361f142 100644
--- a/gcc/fortran/module.c
+++ b/gcc/fortran/module.c
@@ -1726,7 +1726,14 @@ mio_typespec (gfc_typespec * ts)
   else
     mio_symbol_ref (&ts->derived);
 
-  mio_charlen (&ts->cl);
+  if (ts->type != BT_CHARACTER)
+    {
+      /* ts->cl is only valid for BT_CHARACTER.  */
+      mio_lparen ();
+      mio_rparen ();
+    }
+  else
+    mio_charlen (&ts->cl);
 
   mio_rparen ();
 }
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index 182cb4c47e8..e5bdd79c74e 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -1039,7 +1039,10 @@ match_logical_constant (gfc_expr ** result)
     kind = gfc_default_logical_kind;
 
   if (gfc_validate_kind (BT_LOGICAL, kind, true) < 0)
-    gfc_error ("Bad kind for logical constant at %C");
+    {
+      gfc_error ("Bad kind for logical constant at %C");
+      return MATCH_ERROR;
+    }
 
   e = gfc_get_expr ();
 
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 78dc24fb512..32a9b4278e2 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -1670,7 +1670,8 @@ gfc_create_function_decl (gfc_namespace * ns)
   create_function_arglist (ns->proc_name);
 }
 
-/* Return the decl used to hold the function return value.  */
+/* Return the decl used to hold the function return value.  If
+   parent_flag is set, the context is the parent_scope.  */
 
 tree
 gfc_get_fake_result_decl (gfc_symbol * sym)
@@ -1735,9 +1736,12 @@ gfc_get_fake_result_decl (gfc_symbol * sym)
       sprintf (name, "__result_%.20s",
 	       IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));
 
-      decl = build_decl (VAR_DECL, get_identifier (name),
-			 TREE_TYPE (TREE_TYPE (current_function_decl)));
-
+      if (!sym->attr.mixed_entry_master && sym->attr.function)
+	decl = build_decl (VAR_DECL, get_identifier (name),
+			   gfc_sym_type (sym));
+      else
+	decl = build_decl (VAR_DECL, get_identifier (name),
+			   TREE_TYPE (TREE_TYPE (current_function_decl)));
       DECL_ARTIFICIAL (decl) = 1;
       DECL_EXTERNAL (decl) = 0;
       TREE_PUBLIC (decl) = 0;
@@ -2858,9 +2862,12 @@ gfc_generate_function_code (gfc_namespace * ns)
 	warning (0, "Function return value not set");
       else
 	{
-	  /* Set the return value to the dummy result variable.  */
-	  tmp = build2 (MODIFY_EXPR, TREE_TYPE (result),
-			DECL_RESULT (fndecl), result);
+	  /* Set the return value to the dummy result variable.  The
+	     types may be different for scalar default REAL functions
+	     with -ff2c, therefore we have to convert.  */
+	  tmp = convert (TREE_TYPE (DECL_RESULT (fndecl)), result);
+	  tmp = build2 (MODIFY_EXPR, TREE_TYPE (tmp),
+			DECL_RESULT (fndecl), tmp);
 	  tmp = build1_v (RETURN_EXPR, tmp);
 	  gfc_add_expr_to_block (&block, tmp);
 	}
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index 7141ec57621..d633ef8d80a 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -437,7 +437,7 @@ gfc_trans_return (gfc_code * code ATTRIBUTE_UNUSED)
       tree tmp;
       tree result;
 
-      /* if code->expr is not NULL, this return statement must appear
+      /* If code->expr is not NULL, this return statement must appear
          in a subroutine and current_fake_result_decl has already
 	 been generated.  */
 
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index 1ef981b0bb9..cfff7e0569a 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -1289,27 +1289,13 @@ gfc_sym_type (gfc_symbol * sym)
   if (sym->attr.flavor == FL_PROCEDURE && !sym->attr.function)
     return void_type_node;
 
-  if (sym->backend_decl)
-    {
-      if (sym->attr.function)
-	return TREE_TYPE (TREE_TYPE (sym->backend_decl));
-      else
-	return TREE_TYPE (sym->backend_decl);
-    }
+  /* In the case of a function the fake result variable may have a
+     type different from the function type, so don't return early in
+     that case.  */
+  if (sym->backend_decl && !sym->attr.function)
+    return TREE_TYPE (sym->backend_decl);
 
   type = gfc_typenode_for_spec (&sym->ts);
-  if (gfc_option.flag_f2c
-      && sym->attr.function
-      && sym->ts.type == BT_REAL
-      && sym->ts.kind == gfc_default_real_kind
-      && !sym->attr.always_explicit)
-    {
-      /* Special case: f2c calling conventions require that (scalar) 
-	 default REAL functions return the C type double instead.  */
-      sym->ts.kind = gfc_default_double_kind;
-      type = gfc_typenode_for_spec (&sym->ts);
-      sym->ts.kind = gfc_default_real_kind;
-    }
 
   if (sym->attr.dummy && !sym->attr.function)
     byref = 1;
@@ -1758,6 +1744,20 @@ gfc_get_function_type (gfc_symbol * sym)
     type = void_type_node;
   else if (sym->attr.mixed_entry_master)
     type = gfc_get_mixed_entry_union (sym->ns);
+  else if (gfc_option.flag_f2c
+	   && sym->ts.type == BT_REAL
+	   && sym->ts.kind == gfc_default_real_kind
+	   && !sym->attr.always_explicit)
+    {
+      /* Special case: f2c calling conventions require that (scalar) 
+	 default REAL functions return the C type double instead.  f2c
+	 compatibility is only an issue with functions that don't
+	 require an explicit interface, as only these could be
+	 implemented in Fortran 77.  */
+      sym->ts.kind = gfc_default_double_kind;
+      type = gfc_typenode_for_spec (&sym->ts);
+      sym->ts.kind = gfc_default_real_kind;
+    }
   else
     type = gfc_sym_type (sym);
 
diff --git a/gcc/function.c b/gcc/function.c
index e9fdb66214b..46408da0b21 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -5103,6 +5103,14 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)
       /* Retain a map of the prologue insns.  */
       record_insns (seq, &prologue);
       prologue_end = emit_note (NOTE_INSN_PROLOGUE_END);
+ 
+#ifndef PROFILE_BEFORE_PROLOGUE
+      /* Ensure that instructions are not moved into the prologue when
+	 profiling is on.  The call to the profiling routine can be
+	 emitted within the live range of a call-clobbered register.  */
+      if (current_function_profile)
+	emit_insn (gen_rtx_ASM_INPUT (VOIDmode, ""));
+#endif
 
       seq = get_insns ();
       end_sequence ();
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index e10b33d55bd..ce1d3b038d7 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -3790,6 +3790,19 @@ gimplify_asm_expr (tree *expr_p, tree *pre_p, tree *post_p)
       parse_input_constraint (&constraint, 0, 0, noutputs, 0,
 			      oconstraints, &allows_mem, &allows_reg);
 
+      /* If we can't make copies, we can only accept memory.  */
+      if (TREE_ADDRESSABLE (TREE_TYPE (TREE_VALUE (link))))
+	{
+	  if (allows_mem)
+	    allows_reg = 0;
+	  else
+	    {
+	      error ("impossible constraint in %<asm%>");
+	      error ("non-memory input %d must stay in memory", i);
+	      return GS_ERROR;
+	    }
+	}
+
       /* If the operand is a memory input, it should be an lvalue.  */
       if (!allows_reg && allows_mem)
 	{
diff --git a/gcc/gthr-posix.c b/gcc/gthr-posix.c
index a8922c0c16b..e2d731ae407 100644
--- a/gcc/gthr-posix.c
+++ b/gcc/gthr-posix.c
@@ -1,6 +1,6 @@
 /* POSIX threads dummy routines for systems without weak definitions.  */
 /* Compile this one with gcc.  */
-/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+/* Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -28,6 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
 
 #include "tconfig.h"
 #include "tm.h"
+# define __gthrw_pragma(pragma) _Pragma (#pragma)
 /* Define so we provide weak definitions of functions used by libobjc only.  */
 #define _LIBOBJC_WEAK
 #include "gthr.h"
@@ -75,7 +76,7 @@ pthread_create (pthread_t *thread ATTRIBUTE_UNUSED,
 }
 
 int
-pthread_cancel(pthread_t thread ATTRIBUTE_UNUSED)
+pthread_cancel (pthread_t thread ATTRIBUTE_UNUSED)
 {
   return 0;
 }
diff --git a/gcc/gthr-posix.h b/gcc/gthr-posix.h
index 5b295197c42..a092c4b9463 100644
--- a/gcc/gthr-posix.h
+++ b/gcc/gthr-posix.h
@@ -1,6 +1,6 @@
 /* Threads compatibility routines for libgcc2 and libobjc.  */
 /* Compile this one with gcc.  */
-/* Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+/* Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -59,8 +59,12 @@ typedef pthread_mutex_t __gthread_recursive_mutex_t;
 #endif
 
 #if SUPPORTS_WEAK && GTHREAD_USE_WEAK
+# ifndef __gthrw_pragma
+#  define __gthrw_pragma(pragma)
+# endif
 # define __gthrw2(name,name2,type) \
-  extern __typeof(type) name __attribute__ ((__weakref__(#name2)));
+  extern __typeof(type) name __attribute__ ((__weakref__(#name2))); \
+  __gthrw_pragma(weak type)
 # define __gthrw_(name) __gthrw_ ## name
 #else
 # define __gthrw2(name,name2,type)
diff --git a/gcc/haifa-sched.c b/gcc/haifa-sched.c
index 5713e9a2cfb..6a94f77b852 100644
--- a/gcc/haifa-sched.c
+++ b/gcc/haifa-sched.c
@@ -142,6 +142,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
 #include "recog.h"
 #include "sched-int.h"
 #include "target.h"
+#include "params.h"
 
 #ifdef INSN_SCHEDULING
 
@@ -1379,9 +1380,22 @@ queue_to_ready (struct ready_list *ready)
 	fprintf (sched_dump, ";;\t\tQ-->Ready: insn %s: ",
 		 (*current_sched_info->print_insn) (insn, 0));
 
-      ready_add (ready, insn);
-      if (sched_verbose >= 2)
-	fprintf (sched_dump, "moving to ready without stalls\n");
+      /* If the ready list is full, delay the insn for 1 cycle.
+	 See the comment in schedule_block for the rationale.  */
+      if (!reload_completed
+	  && ready->n_ready > MAX_SCHED_READY_INSNS
+	  && !SCHED_GROUP_P (insn))
+	{
+	  if (sched_verbose >= 2)
+	    fprintf (sched_dump, "requeued because ready full\n");
+	  queue_insn (insn, 1);
+	}
+      else
+	{
+	  ready_add (ready, insn);
+	  if (sched_verbose >= 2)
+	    fprintf (sched_dump, "moving to ready without stalls\n");
+        }
     }
   insn_queue[q_ptr] = 0;
 
@@ -1903,6 +1917,31 @@ schedule_block (int b, int rgn_n_insns)
   memset (insn_queue, 0, (max_insn_queue_index + 1) * sizeof (rtx));
   last_clock_var = -1;
 
+  /* The algorithm is O(n^2) in the number of ready insns at any given
+     time in the worst case.  Before reload we are more likely to have
+     big lists so truncate them to a reasonable size.  */
+  if (!reload_completed && ready.n_ready > MAX_SCHED_READY_INSNS)
+    {
+      ready_sort (&ready);
+
+      /* Find first free-standing insn past MAX_SCHED_READY_INSNS.  */
+      for (i = MAX_SCHED_READY_INSNS; i < ready.n_ready; i++)
+	if (!SCHED_GROUP_P (ready_element (&ready, i)))
+	  break;
+
+      if (sched_verbose >= 2)
+	{
+	  fprintf (sched_dump,
+		   ";;\t\tReady list on entry: %d insns\n", ready.n_ready);
+	  fprintf (sched_dump,
+		   ";;\t\t before reload => truncated to %d insns\n", i);
+	}
+
+      /* Delay all insns past it for 1 cycle.  */
+      while (i < ready.n_ready)
+	queue_insn (ready_remove (&ready, i), 1);
+    }
+
   /* Start just before the beginning of time.  */
   clock_var = -1;
   advance = 0;
diff --git a/gcc/ifcvt.c b/gcc/ifcvt.c
index d6c3dd6ea32..2d5bc66c21f 100644
--- a/gcc/ifcvt.c
+++ b/gcc/ifcvt.c
@@ -2116,6 +2116,46 @@ noce_mem_write_may_trap_or_fault_p (rtx mem)
   return false;
 }
 
+/* Return whether we can use store speculation for MEM.  TOP_BB is the
+   basic block above the conditional block where we are considering
+   doing the speculative store.  We look for whether MEM is set
+   unconditionally later in the function.  */
+
+static bool
+noce_can_store_speculate_p (basic_block top_bb, rtx mem)
+{
+  basic_block dominator;
+
+  for (dominator = get_immediate_dominator (CDI_POST_DOMINATORS, top_bb);
+       dominator != NULL && dominator != EXIT_BLOCK_PTR;
+       dominator = get_immediate_dominator (CDI_POST_DOMINATORS, dominator))
+    {
+      rtx insn;
+
+      FOR_BB_INSNS (dominator, insn)
+	{
+	  /* If we see something that might be a memory barrier, we
+	     have to stop looking.  Even if the MEM is set later in
+	     the function, we still don't want to set it
+	     unconditionally before the barrier.  */
+	  if (INSN_P (insn)
+	      && (volatile_insn_p (PATTERN (insn))
+		  || (CALL_P (insn)
+		      && (!CONST_OR_PURE_CALL_P (insn)
+			  || pure_call_p (insn)))))
+	    return false;
+
+	  if (memory_modified_in_insn_p (mem, insn))
+	    return true;
+	  if (modified_in_p (XEXP (mem, 0), insn))
+	    return false;
+
+	}
+    }
+
+  return false;
+}
+
 /* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it
    without using conditional execution.  Return TRUE if we were
    successful at converting the block.  */
@@ -2299,17 +2339,31 @@ noce_process_if_block (struct ce_if_block * ce_info)
       goto success;
     }
 
-  /* Disallow the "if (...) x = a;" form (with an implicit "else x = x;")
-     for optimizations if writing to x may trap or fault, i.e. it's a memory
-     other than a static var or a stack slot, is misaligned on strict
-     aligned machines or is read-only.
-     If x is a read-only memory, then the program is valid only if we
-     avoid the store into it.  If there are stores on both the THEN and
-     ELSE arms, then we can go ahead with the conversion; either the
-     program is broken, or the condition is always false such that the
-     other memory is selected.  */
-  if (!set_b && MEM_P (orig_x) && noce_mem_write_may_trap_or_fault_p (orig_x))
-    return FALSE;
+  if (!set_b && MEM_P (orig_x))
+    {
+      /* Disallow the "if (...) x = a;" form (implicit "else x = x;")
+	 for optimizations if writing to x may trap or fault,
+	 i.e. it's a memory other than a static var or a stack slot,
+	 is misaligned on strict aligned machines or is read-only.  If
+	 x is a read-only memory, then the program is valid only if we
+	 avoid the store into it.  If there are stores on both the
+	 THEN and ELSE arms, then we can go ahead with the conversion;
+	 either the program is broken, or the condition is always
+	 false such that the other memory is selected.  */
+      if (noce_mem_write_may_trap_or_fault_p (orig_x))
+	return FALSE;
+
+      /* Avoid store speculation: given "if (...) x = a" where x is a
+	 MEM, we only want to do the store if x is always set
+	 somewhere in the function.  This avoids cases like
+	   if (pthread_mutex_trylock(mutex))
+	     ++global_variable;
+	 where we only want global_variable to be changed if the mutex
+	 is held.  FIXME: This should ideally be expressed directly in
+	 RTL somehow.  */
+      if (!noce_can_store_speculate_p (test_bb, orig_x))
+	return FALSE;
+    }
 
   if (noce_try_move (&if_info))
     goto success;
@@ -2584,7 +2638,8 @@ find_if_header (basic_block test_bb, int pass)
       && find_cond_trap (test_bb, then_edge, else_edge))
     goto success;
 
-  if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY
+  if (life_data_ok
+      && dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY
       && (! HAVE_conditional_execution || reload_completed))
     {
       if (find_if_case_1 (test_bb, then_edge, else_edge))
@@ -3592,9 +3647,8 @@ if_convert (int x_life_data_ok)
       free_dominance_info (CDI_DOMINATORS);
     }
 
-  /* Compute postdominators if we think we'll use them.  */
-  if (HAVE_conditional_execution || life_data_ok)
-    calculate_dominance_info (CDI_POST_DOMINATORS);
+  /* Compute postdominators.  */
+  calculate_dominance_info (CDI_POST_DOMINATORS);
 
   if (life_data_ok)
     clear_bb_flags ();
diff --git a/gcc/ipa-pure-const.c b/gcc/ipa-pure-const.c
index ae92e7e3af0..ac45705cb0d 100644
--- a/gcc/ipa-pure-const.c
+++ b/gcc/ipa-pure-const.c
@@ -639,6 +639,7 @@ static_execute (void)
   for (i = 0; i < order_pos; i++ )
     {
       enum pure_const_state_e pure_const_state = IPA_CONST;
+      int count = 0;
       node = order[i];
 
       /* Find the worst state for any node in the cycle.  */
@@ -655,11 +656,40 @@ static_execute (void)
 	  if (!w_l->state_set_in_source)
 	    {
 	      struct cgraph_edge *e;
+	      count++;
+
+	      /* FIXME!!!  Because of pr33826, we cannot have either
+		 immediate or transitive recursive functions marked as
+		 pure or const because dce can delete a function that
+		 is in reality an infinite loop.  A better solution
+		 than just outlawing them is to add another bit the
+		 functions to distinguish recursive from non recursive
+		 pure and const function.  This would allow the
+		 recursive ones to be cse'd but not dce'd.  In this
+		 same vein, we could allow functions with loops to
+		 also be cse'd but not dce'd.
+
+		 Unfortunately we are late in stage 3, and the fix
+		 described above is is not appropriate.  */
+	      if (count > 1)
+		{
+		  pure_const_state = IPA_NEITHER;
+		  break;
+		}
+		    
 	      for (e = w->callees; e; e = e->next_callee) 
 		{
 		  struct cgraph_node *y = e->callee;
 		  /* Only look at the master nodes and skip external nodes.  */
 		  y = cgraph_master_clone (y);
+
+		  /* Check for immediate recursive functions.  See the
+		     FIXME above.  */
+		  if (w == y)
+		    {
+		      pure_const_state = IPA_NEITHER;
+		      break;
+		    }
 		  if (y)
 		    {
 		      funct_state y_l = get_function_state (y);
diff --git a/gcc/ipa-utils.c b/gcc/ipa-utils.c
index 76f0f601c16..cd707455b76 100644
--- a/gcc/ipa-utils.c
+++ b/gcc/ipa-utils.c
@@ -78,7 +78,7 @@ struct searchc_env {
    has been customized for cgraph_nodes.  The env parameter is because
    it is recursive and there are no nested functions here.  This
    function should only be called from itself or
-   cgraph_reduced_inorder.  ENV is a stack env and would be
+   ipa_utils_reduced_inorder.  ENV is a stack env and would be
    unnecessary if C had nested functions.  V is the node to start
    searching from.  */
 
diff --git a/gcc/loop-iv.c b/gcc/loop-iv.c
index 8e915a04b23..675abeb90ae 100644
--- a/gcc/loop-iv.c
+++ b/gcc/loop-iv.c
@@ -1497,7 +1497,7 @@ implies_p (rtx a, rtx b)
 	    mode = VOIDmode;
 	}
 
-      if (mode != VOIDmode
+      if (SCALAR_INT_MODE_P (mode)
 	  && rtx_equal_p (op1, opb1)
 	  && simplify_gen_binary (MINUS, mode, opb0, op0) == const1_rtx)
 	return true;
diff --git a/gcc/loop.c b/gcc/loop.c
index f9d7493a03b..43c3d92d2e4 100644
--- a/gcc/loop.c
+++ b/gcc/loop.c
@@ -2561,7 +2561,7 @@ move_movables (struct loop *loop, struct loop_movables *movables,
 			     like this as a result of record_jump_cond.  */
 
 			  if ((temp = find_reg_note (i1, REG_EQUAL, NULL_RTX))
-			      && ! loop_invariant_p (loop, XEXP (temp, 0)))
+			      && loop_invariant_p (loop, XEXP (temp, 0)) != 1)
 			    remove_note (i1, temp);
 			}
 
@@ -6493,13 +6493,13 @@ strength_reduce (struct loop *loop, int flags)
 	      v->ignore = 1;
 	      bl->all_reduced = 0;
 	    }
-	  else if (!v->always_computable
+	  else if (! v->always_executed
 		   && (may_trap_or_fault_p (v->add_val)
 		       || may_trap_or_fault_p (v->mult_val)))
 	    {
 	      if (loop_dump_stream)
 		fprintf (loop_dump_stream,
-			 "giv of insn %d: not always computable.\n",
+			 "giv of insn %d: not always executed.\n",
 			 INSN_UID (v->insn));
 	      v->ignore = 1;
 	      bl->all_reduced = 0;
@@ -8700,6 +8700,10 @@ combine_givs_p (struct induction *g1, struct induction *g2)
 {
   rtx comb, ret;
 
+  /* We cannot combine givs that are not always in sync.  */
+  if (!g1->always_executed || !g2->always_executed)
+    return NULL_RTX;
+
   /* With the introduction of ext dependent givs, we must care for modes.
      G2 must not use a wider mode than G1.  */
   if (GET_MODE_SIZE (g1->mode) < GET_MODE_SIZE (g2->mode))
@@ -8708,6 +8712,7 @@ combine_givs_p (struct induction *g1, struct induction *g2)
   ret = comb = express_from (g1, g2);
   if (comb == NULL_RTX)
     return NULL_RTX;
+
   if (g1->mode != g2->mode)
     ret = gen_lowpart (g2->mode, comb);
 
@@ -8718,9 +8723,7 @@ combine_givs_p (struct induction *g1, struct induction *g2)
      combination to be the other way round.  */
   if (comb == g1->dest_reg
       && (g1->giv_type == DEST_REG || g2->giv_type == DEST_ADDR))
-    {
-      return ret;
-    }
+    return ret;
 
   /* If G2 can be expressed as a function of G1 and that function is valid
      as an address and no more expensive than using a register for G2,
diff --git a/gcc/params.def b/gcc/params.def
index a9f5c8b9fdd..23b3113d63a 100644
--- a/gcc/params.def
+++ b/gcc/params.def
@@ -560,6 +560,12 @@ DEFPARAM (PARAM_MAX_FIELDS_FOR_FIELD_SENSITIVE,
           "max-fields-for-field-sensitive",
 	  "Maximum number of fields in a structure before pointer analysis treats the structure as a single variable",
 	  100, 0, 0)
+
+DEFPARAM(PARAM_MAX_SCHED_READY_INSNS,
+	 "max-sched-ready-insns",
+	 "The maximum number of instructions ready to be issued to be considered by the scheduler during the first scheduling pass",
+	 100, 0, 0)
+
 /*
 Local variables:
 mode:c
diff --git a/gcc/params.h b/gcc/params.h
index 90ccabb2556..bb5f097c548 100644
--- a/gcc/params.h
+++ b/gcc/params.h
@@ -147,4 +147,6 @@ typedef enum compiler_param
   PARAM_VALUE (PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO)
 #define MAX_FIELDS_FOR_FIELD_SENSITIVE \
   ((size_t) PARAM_VALUE (PARAM_MAX_FIELDS_FOR_FIELD_SENSITIVE))
+#define MAX_SCHED_READY_INSNS \
+  PARAM_VALUE (PARAM_MAX_SCHED_READY_INSNS)
 #endif /* ! GCC_PARAMS_H */
diff --git a/gcc/passes.c b/gcc/passes.c
index e3a8213d334..8a844a890f7 100644
--- a/gcc/passes.c
+++ b/gcc/passes.c
@@ -848,6 +848,9 @@ execute_one_pass (struct tree_opt_pass *pass)
       dump_file = NULL;
     }
 
+  /* Reset in_gimple_form to not break non-unit-at-a-time mode.  */
+  in_gimple_form = false;
+
   return true;
 }
 
diff --git a/gcc/reg-stack.c b/gcc/reg-stack.c
index 131f7b0c1ff..1002d690804 100644
--- a/gcc/reg-stack.c
+++ b/gcc/reg-stack.c
@@ -807,9 +807,19 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)
 
   hard_regno = get_hard_regnum (regstack, reg);
 
-  gcc_assert (hard_regno >= FIRST_STACK_REG);
   if (hard_regno == FIRST_STACK_REG)
     return;
+  if (hard_regno == -1)
+    {
+      /* Something failed if the register wasn't on the stack.  If we had
+	 malformed asms, we zapped the instruction itself, but that didn't
+	 produce the same pattern of register sets as before.  To prevent
+	 further failure, adjust REGSTACK to include REG at TOP.  */
+      gcc_assert (any_malformed_asm);
+      regstack->reg[++regstack->top] = REGNO (reg);
+      return;
+    }
+  gcc_assert (hard_regno >= FIRST_STACK_REG);
 
   other_reg = regstack->top - (hard_regno - FIRST_STACK_REG);
 
diff --git a/gcc/reload.c b/gcc/reload.c
index 39a2f06caf7..eea9cc738a1 100644
--- a/gcc/reload.c
+++ b/gcc/reload.c
@@ -1210,7 +1210,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,
 
   /* If IN appears in OUT, we can't share any input-only reload for IN.  */
   if (in != 0 && out != 0 && MEM_P (out)
-      && (REG_P (in) || MEM_P (in))
+      && (REG_P (in) || MEM_P (in) || GET_CODE (in) == PLUS)
       && reg_overlap_mentioned_for_reload_p (in, XEXP (out, 0)))
     dont_share = 1;
 
@@ -1867,7 +1867,12 @@ combine_reloads (void)
 		    ||  ! (TEST_HARD_REG_BIT
 			   (reg_class_contents[(int) rld[secondary_out].class],
 			    REGNO (XEXP (note, 0)))))))
-	&& ! fixed_regs[REGNO (XEXP (note, 0))])
+	&& ! fixed_regs[REGNO (XEXP (note, 0))]
+	/* Check that we don't use a hardreg for an uninitialized
+	   pseudo.  See also find_dummy_reload().  */
+	&& (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER
+	    || ! bitmap_bit_p (ENTRY_BLOCK_PTR->il.rtl->global_live_at_end,
+			       ORIGINAL_REGNO (XEXP (note, 0)))))
       {
 	rld[output_reload].reg_rtx
 	  = gen_rtx_REG (rld[output_reload].outmode,
@@ -5962,6 +5967,8 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,
 	      unsigned outer_size = GET_MODE_SIZE (GET_MODE (x));
 	      unsigned inner_size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));
 	      int offset;
+	      enum machine_mode orig_mode = GET_MODE (tem);
+	      int reloaded;
 
 	      /* For big-endian paradoxical subregs, SUBREG_BYTE does not
 		 hold the correct (negative) byte offset.  */
@@ -5994,9 +6001,28 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,
 		    return x;
 		}
 
-	      find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),
-				    &XEXP (tem, 0), opnum, type,
-				    ind_levels, insn);
+	      reloaded = find_reloads_address (GET_MODE (tem), &tem,
+					       XEXP (tem, 0), &XEXP (tem, 0),
+					       opnum, type, ind_levels, insn);
+
+	      /* For some processors an address may be valid in the
+		 original mode but not in a smaller mode.  For
+		 example, ARM accepts a scaled index register in
+		 SImode but not in HImode.  find_reloads_address
+		 assumes that we pass it a valid address, and doesn't
+		 force a reload.  This will probably be fine if
+		 find_reloads_address finds some reloads.  But if it
+		 doesn't find any, then we may have just converted a
+		 valid address into an invalid one.  Check for that
+		 here.  */
+	      if (reloaded != 1
+		  && strict_memory_address_p (orig_mode, XEXP (tem, 0))
+		  && !strict_memory_address_p (GET_MODE (tem),
+					       XEXP (tem, 0)))
+		push_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,
+			     MODE_BASE_REG_CLASS (GET_MODE (tem)),
+			     GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0,
+			     opnum, type);
 
 	      /* If this is not a toplevel operand, find_reloads doesn't see
 		 this substitution.  We have to emit a USE of the pseudo so
@@ -6438,7 +6464,8 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)
       if (REG_P (in))
 	return 0;
       else if (GET_CODE (in) == PLUS)
-	return (reg_overlap_mentioned_for_reload_p (x, XEXP (in, 0))
+	return (rtx_equal_p (x, in)
+		|| reg_overlap_mentioned_for_reload_p (x, XEXP (in, 0))
 		|| reg_overlap_mentioned_for_reload_p (x, XEXP (in, 1)));
       else return (reg_overlap_mentioned_for_reload_p (XEXP (x, 0), in)
 		   || reg_overlap_mentioned_for_reload_p (XEXP (x, 1), in));
diff --git a/gcc/reload1.c b/gcc/reload1.c
index 42f186f7bc8..861cbaa5ab9 100644
--- a/gcc/reload1.c
+++ b/gcc/reload1.c
@@ -1,6 +1,7 @@
 /* Reload pseudo regs into hard regs for insns that require hard regs.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
+   Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -3054,39 +3055,20 @@ eliminate_regs_in_insn (rtx insn, int replace)
 	  {
 	    rtx to_rtx = ep->to_rtx;
 	    offset += ep->offset;
+	    offset = trunc_int_for_mode (offset, GET_MODE (reg));
 
 	    if (GET_CODE (XEXP (plus_cst_src, 0)) == SUBREG)
 	      to_rtx = gen_lowpart (GET_MODE (XEXP (plus_cst_src, 0)),
 				    to_rtx);
-	    if (offset == 0)
-	      {
-		int num_clobbers;
-		/* We assume here that if we need a PARALLEL with
-		   CLOBBERs for this assignment, we can do with the
-		   MATCH_SCRATCHes that add_clobbers allocates.
-		   There's not much we can do if that doesn't work.  */
-		PATTERN (insn) = gen_rtx_SET (VOIDmode,
-					      SET_DEST (old_set),
-					      to_rtx);
-		num_clobbers = 0;
-		INSN_CODE (insn) = recog (PATTERN (insn), insn, &num_clobbers);
-		if (num_clobbers)
-		  {
-		    rtvec vec = rtvec_alloc (num_clobbers + 1);
-
-		    vec->elem[0] = PATTERN (insn);
-		    PATTERN (insn) = gen_rtx_PARALLEL (VOIDmode, vec);
-		    add_clobbers (PATTERN (insn), INSN_CODE (insn));
-		  }
-		gcc_assert (INSN_CODE (insn) >= 0);
-	      }
 	    /* If we have a nonzero offset, and the source is already
 	       a simple REG, the following transformation would
 	       increase the cost of the insn by replacing a simple REG
 	       with (plus (reg sp) CST).  So try only when we already
 	       had a PLUS before.  */
-	    else if (plus_src)
+	    if (offset == 0 || plus_src)
 	      {
+		rtx new_src = plus_constant (to_rtx, offset);
+
 		new_body = old_body;
 		if (! replace)
 		  {
@@ -3097,8 +3079,20 @@ eliminate_regs_in_insn (rtx insn, int replace)
 		PATTERN (insn) = new_body;
 		old_set = single_set (insn);
 
-		XEXP (SET_SRC (old_set), 0) = to_rtx;
-		XEXP (SET_SRC (old_set), 1) = GEN_INT (offset);
+		/* First see if this insn remains valid when we make the
+		   change.  If not, try to replace the whole pattern with
+		   a simple set (this may help if the original insn was a
+		   PARALLEL that was only recognized as single_set due to 
+		   REG_UNUSED notes).  If this isn't valid either, keep
+		   the INSN_CODE the same and let reload fix it up.  */
+		if (!validate_change (insn, &SET_SRC (old_set), new_src, 0))
+		  {
+		    rtx new_pat = gen_rtx_SET (VOIDmode,
+					       SET_DEST (old_set), new_src);
+
+		    if (!validate_change (insn, &PATTERN (insn), new_pat, 0))
+		      SET_SRC (old_set) = new_src;
+		  }
 	      }
 	    else
 	      break;
diff --git a/gcc/resource.c b/gcc/resource.c
index 95f1628a006..4eefab6c90b 100644
--- a/gcc/resource.c
+++ b/gcc/resource.c
@@ -664,9 +664,8 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,
 	  rtx link;
 
 	  res->cc = res->memory = 1;
-	  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)
-	    if (call_used_regs[r] || global_regs[r])
-	      SET_HARD_REG_BIT (res->regs, r);
+
+	  IOR_HARD_REG_SET (res->regs, regs_invalidated_by_call);
 
 	  for (link = CALL_INSN_FUNCTION_USAGE (x);
 	       link; link = XEXP (link, 1))
diff --git a/gcc/rtl.h b/gcc/rtl.h
index ceb23941b88..55da6728e41 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -1117,8 +1117,8 @@ do {						\
    refer to part of a DECL.  */
 #define REG_EXPR(RTX) (REG_ATTRS (RTX) == 0 ? 0 : REG_ATTRS (RTX)->decl)
 
-/* For a MEM rtx, the offset from the start of MEM_DECL, if known, as a
-   RTX that is always a CONST_INT.  */
+/* For a REG rtx, the offset from the start of REG_EXPR, if known, as an
+   HOST_WIDE_INT.  */
 #define REG_OFFSET(RTX) (REG_ATTRS (RTX) == 0 ? 0 : REG_ATTRS (RTX)->offset)
 
 /* Copy the attributes that apply to memory locations from RHS to LHS.  */
diff --git a/gcc/stmt.c b/gcc/stmt.c
index 7eb77d20f60..e08eab051f9 100644
--- a/gcc/stmt.c
+++ b/gcc/stmt.c
@@ -1419,6 +1419,7 @@ warn_if_unused_value (tree exp, location_t locus)
     case TRY_CATCH_EXPR:
     case WITH_CLEANUP_EXPR:
     case EXIT_EXPR:
+    case VA_ARG_EXPR:
       return 0;
 
     case BIND_EXPR:
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 98bd406363c..47a7b2c78af 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,571 @@
+2008-05-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/nested-func-6.c: New test.
+
+2008-04-08  Richard Guenther  <rguenther@suse.de>
+
+	* gcc.c-torture/execute/20080408-1.c: New testcase.
+
+2008-03-25  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2008-02-12  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/35163
+	* gcc.c-torture/execute/pr35163.c: New testcase.
+
+2008-02-13  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2005-11-30  Richard Guenther  <rguenther@suse.de>
+	
+	PR tree-optimization/21655
+	* g++.dg/tree-ssa/pr14814.C: Remove XFAIL.
+
+2008-02-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* obj-c++.dg/bitfield-1.mm: Expect failures.
+	* obj-c++.dg/bitfield-4.mm: Likewise.
+	* obj-c++.dg/cxx-ivars-2.mm: Likewise.
+	* obj-c++.dg/encode-8.mm: Likewise.
+	* obj-c++.dg/isa-field-1.mm: Likewise.
+	* obj-c++.dg/layout-1.mm: Likewise.
+	* obj-c++.dg/lookup-2.mm: Likewise.
+	* obj-c++.dg/try-catch-2.mm: Likewise.
+	* obj-c++.dg/try-catch-9.mm: Likewise.
+
+2008-02-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	PR objc++/34193
+	* obj-c++.dg/gnu-runtime-2.mm: Fix signature of function main().
+
+2008-02-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	PR objc++/27232
+
+	Backport:
+	2006-09-22  Mike Stump  <mrs@apple.com>
+	
+	* obj-c++.dg/encode-3.mm: Fix for 64-bit support.
+
+2008-02-04  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/33631
+	* gcc.c-torture/execute/pr33631.c: New testcase.
+
+2008-01-31  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	* gcc.dg/tf_to_di-1.c: New testcase.
+
+2008-01-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2008-01-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.dg/pr33826.c: Require nonpic.
+	
+	2007-11-08  Kenneth Zadeck <zadeck@naturalbridge.com>
+	
+	PR middle-end/33826
+	* gcc.dg/pr33826.c: New.
+	* gcc.dg/tree-ssa/20030714-1.c: Removed two tests that depend on 
+	recursive functions being marked pure or const.
+
+2008-01-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.dg/vect/vect-ifcvt-9.c: Use inline.
+
+2008-01-19  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* g++.dg/eh/ia64-2.C: Add "dg-require-weak" statement.  Place
+	"dg-do run" statement before "dg-require-weak" statement.
+	* g++.dg/eh/weak1.C: Likewise.
+
+2008-01-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2007-03-21  Richard Sandiford  <richard@codesourcery.com>
+	 
+	* gcc.target/i386/pr21291.c: Require nonpic or ! ilp32.
+
+2008-01-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/compile/20080114-1.c: Use empty asm statements.
+
+2008-01-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/compile/20080114-1.c: New test.
+
+2008-01-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.c-torture/execute/builtins/chk.h: Don't check !__PIE__.
+	Also check __pic__.
+	* lib/target-supports.exp (check_effective_target_nonpic): Likewise.
+	* gcc.dg/assign-warn-3.c: Use "static inline" instead of "inline".
+	
+	Backport:
+	
+	2007-03-21  Richard Sandiford  <richard@codesourcery.com>
+	* gcc.c-torture/execute/builtins/chk.h (LOCAL): Define.
+	* gcc.c-torture/execute/builtins/sprintf-chk.c (s1): Make LOCAL.
+	* gcc.c-torture/execute/builtins/stpcpy-chk.c (s1): Likewise.
+	* gcc.c-torture/execute/builtins/strcpy-chk.c (s1): Likewise.
+
+	2007-07-26  Nathan Froyd  <froydnj@codesourcery.com>
+	PR/19232
+	* gcc.dg/assign-warn-3.c (f0): Declare as inline.
+	(f1): Likewise.
+
+	2007-01-15  Dale Johannesen  <dalej@apple.com>
+	* gcc.dg/tree-ssa/loop-3.c:  Disable with -fpic or -fPIC.
+	
+	2007-03-21  Richard Sandiford  <richard@codesourcery.com>
+	* lib/target-supports.exp (check_effective_target_nonpic): New
+	procedure.
+
+2007-12-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/34003
+	* gcc.dg/pr34003-1.c: New test.
+	* gcc.dg/pr34003-2.c: New.
+
+2007-12-19  Richard Sandiford  <rsandifo@nildram.co.uk>
+
+	PR rtl-optimization/34456
+	* gcc.c-torture/execute/pr34456.c: New test.
+
+2007-11-29  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from mainline:
+	2007-11-17  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/34130
+	* gcc.c-torture/execute/pr34130.c: New testcase.
+
+2007-11-16  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/34030
+	* gcc.c-torture/compile/pr34030.c: New testcase.
+
+2007-11-07  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* gcc.dg/out-of-bounds-1.c: New test.
+
+2007-11-02  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR rtl-optimization/28062
+	* gcc.c-torture/compile/20071102-1.c: New test.
+
+2007-10-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/33744
+	* g++.dg/template/arg6.C: New test.
+
+2007-09-06  David Daney  <ddaney@avtrex.com>
+	    Richard Sandiford  <richard@codesourcery.com>
+
+	PR target/33256
+	* gcc.target/mips/mips.exp (setup_mips_tests): Set mips_forced_le.
+	(dg-mips-options): Skip -EB and -meb tests when $mips_forced_le.
+	* gcc.target/mips/pr33256.c: New test.
+
+2007-08-31  Paolo Carlini  <pcarlini@suse.de>
+
+	PR c++/32113
+	* g++.dg/template/crash70.C: New.
+
+2007-08-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/32912
+	* gcc.dg/pr32912-1.c: New test.
+	* gcc.dg/pr32912-2.c: New test.
+
+	PR c++/31941
+	* g++.dg/parse/crash37.C: New test.
+
+2007-08-22  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/33142
+	* gcc.c-torture/execute/pr33142.c: New testcase.
+
+2007-08-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/32992
+	* g++.dg/opt/nrv14.C: New test.
+
+2007-08-18  Paolo Carlini  <pcarlini@suse.de>
+
+	PR c++/32112
+	* g++.dg/template/error26.C: New.
+
+2007-08-10  Paolo Carlini  <pcarlini@suse.de>
+
+	PR c++/17763
+	* g++.dg/other/error16.C: New.
+
+2007-08-01  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	* gcc.dg/20070801-1.c: New testcase.
+
+2007-07-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.dg/c99-math-double-1.c: Mark test variables as volatile.
+	Test negative numbers also.
+	* gcc.dg/c99-math-float-1.c: Likewise.
+	* gcc.dg/c99-math-long-double-1.c: Likewise.
+	* gcc.dg/c99-math.h: Check for FP exceptions.  Update for negative
+	test inputs.
+
+2007-07-08  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.dg/c99-math-double-1.c, gcc.dg/c99-math-float-1.c,
+	c99-math-long-double-1.c, c99-math.h: Test subnormals.
+
+2007-07-06  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/32450
+	* gcc.dg/pr32450.c: New runtime test.
+
+2007-07-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR tree-optimization/31966
+	PR tree-optimization/32533
+	* gcc.dg/tree-ssa/pr31966.c: New runtime test.
+	* gfortran.dg/pr32533.f90: Ditto.
+
+2007-07-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* gcc.dg/c99-math.h: Fix typo.
+
+2007-06-30  Alexandre Oliva  <aoliva@redhat.com>
+
+	* g++.dg/ext/interface4.C, g++.dg/ext/interface4.h: New.
+
+2007-06-28  Seongbae Park  <seongbae.park@gmail.com>
+
+	* gcc.target/arm/stack-corruption.c: New test.
+
+2007-06-21  Uros Bizjak  <ubizjak@gmail.com>
+ 
+	PR target/32389
+	* gcc.target/i386/pr32389.c New test.
+
+2007-06-20  Dirk Mueller  <dmueller@suse.de>
+
+	PR c++/31806
+	PR c++/31809
+	* g++.dg/opt/static5.C: New test.
+	* g++.dg/opt/static6.C: New test.
+
+2007-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/32109
+	* g++.dg/ext/asm10.C: New test.
+
+	PR middle-end/32285
+	* gcc.c-torture/execute/20070614-1.c: New test.
+
+2007-06-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/32353
+	* g++.dg/opt/nrv13.C: New test.
+
+2007-06-17  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* gcc.target/sparc/align.c: Use 'unsigned char' as element type.
+	* gcc.target/sparc/combined-2.c: Likewise.
+	* gcc.target/sparc/fexpand.c : Likewise.
+	* gcc.target/sparc/fnot.c: Likewise.  Fix a couple of prototypes.
+	* gcc.target/sparc/fpack16.c : Likewise.
+	* gcc.target/sparc/fpmerge.c : Likewise.
+	* gcc.target/sparc/fpmul.c : Likewise.
+	* gcc.target/sparc/noresult.c : Likewise.
+	* gcc.target/sparc/pdist.c: Likewise.
+
+2007-06-13  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* gcc.target/sparc/mfpu.c: New test.
+
+2007-05-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/31964
+	* gfortran.fortran-torture/execute/intrinsic_bitops.f90: Update.
+
+2007-05-17  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* gcc.c-torture/execute/20070517-1.c: New test.
+
+2007-05-16  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2006-06-09  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/26998
+	* gcc.dg/torture/pr26998.c: New testcase.
+	* gcc.dg/tree-ssa/vrp29.c: New testcase.
+
+2007-05-10  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/31880
+	* gfortran.dg/unf_read_corrupted_2.f90: New test.
+
+2007-05-10  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	* gcc.dg/20070507-1.c: Disable for non-pic targets.
+
+2007-05-08  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	* gcc.dg/20070507-1.c: New testcase.
+
+2007-04-28  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR C++/30221
+	* g++.dg/init/ptrfn2.C: New test.
+	* g++.dg/init/ptrfn3.C: New test.
+
+2007-04-26  Ian Lance Taylor  <iant@google.com>
+
+	PR target/28675
+	* gcc.c-torture/compile/pr28675.c: New test.
+
+2007-04-26  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR C++/30016
+	* g++.dg/ext/vector6.C: New test.
+
+2007-04-25  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/31698
+	* g++.dg/other/pr31698.C: New testcase.
+
+	Backport from mainline:
+	2006-10-13  Richard Guenther  <rguenther@suse.de>
+
+	PR tree-optimization/29446
+	* gcc.dg/torture/pr29446.c: New testcase.
+
+2007-04-24  Andreas Krebbel  <krebbel1@de.ibm.com>
+
+	PR target/31641
+	* gcc.c-torture/compile/pr31641.c: New testcase.
+
+2007-04-22  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR middle-end/31448
+	* gcc.c-torture/execute/pr31448.c: New testcase.
+
+2007-04-20  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc.target/i386/ordcmp-1.c: New test.
+	* gcc.target/i386/unordcmp-1.c: New test.
+
+	PR tree-optimization/31632
+	* gcc.c-torture/compile/20070419-1.c: New test.
+
+2007-04-17  Simon Martin  <simartin@users.sourceforge.net>
+
+	PR c++/31517
+	* g++.dg/template/init7.C: New test.
+
+2007-04-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR testsuite/31578
+	* gcc.dg/gnu89-init-4.c: Change to a compile only test.
+
+2007-04-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR tree-opt/30045
+	* gcc.dg/pr30045.c: New test.
+
+2007-04-14  Andrew Pinski  <pinskia@gmail.com>
+
+	PR middle-end/30729
+	* gcc.dg/Wunused-value-2.c: New testcase.
+
+2007-04-14  Andrew Pinski  <pinskia@gmail.com>
+
+	PR C++/30168
+	* g++.dg/opt/complex6.C: New test.
+
+2007-04-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR C/31520
+	* gcc.dg/gnu89-init-4.c: New testcase.
+
+2007-04-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/31074
+	* conv3.C: New test.
+
+2007-04-09  Mark Mitchell  <mark@codesourcery.com>
+
+	PR c++/31449
+	* g++.dg/init/const5.C: New test.
+
+2007-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/30847
+	* g++.dg/parse/cond3.C: New test.
+
+2007-03-20  Seongbae Park <seongbae.park@gmail.com>
+
+	PR tree-optimization/30590
+	* g++.dg/opt/pr30590.C: New testcase.
+
+2007-03-19  Jeff Law  <law@redhat.com>
+
+	* PR tree-optimization/30984
+	* gcc.c-torture/pr30984.c: New test.
+
+2007-03-19  Ian Lance Taylor  <iant@google.com>
+
+	* gcc.dg/inline-7.c: Add -fgnu89-inline.
+	* gcc.dg/inline-17.c: New test.
+	* gcc.dg/inline-18.c: New test.
+	* gcc.dg/inline-19.c: New test.
+	* gcc.dg/inline-21.c: New test.
+
+2007-03-17  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/29906
+	* g++.dg/debug/pr29906.C: New
+
+2007-03-15  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2007-02-28  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/30364
+	* gcc.dg/torture/pr30364-1.c: New testcase.
+	* gcc.dg/torture/pr30364-2.c: Likewise.
+	* gcc.dg/torture/pr30364-3.c: Likewise.
+
+2007-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	* gfortran.dg/module_implicit_conversion.f90: New test.
+
+2007-03-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR middle-end/30433
+	* gcc.c-torture/compile/pr30433.c: New testcase to check
+	that complex constant comparisions are folded.
+
+2007-03-12  Ira Rosen  <irar@il.ibm.com>
+
+	PR tree-optimization/29925
+	* gcc.dg/vect/fast-math-vect-pr29925.c: New test.
+
+2007-03-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR rtl-optimization/30643
+	* gcc.dg/pr30643.c: New.
+
+2007-03-08  Volker Reichelt  <reichelt@netcologne.de>
+
+	PR c++/30852
+	* g++.dg/ext/offsetof1.C: Add cases with volatile.
+
+2007-03-05  Simon Martin  <simartin@users.sourceforge.net>
+
+	PR c++/30895
+	* g++.dg/parse/template23.C: New test.
+
+2007-03-01  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>
+
+	Backport from trunk
+	PR fortran/29441
+	* gfortran.dg/initialization_4.f90: New test.
+
+2007-02-27  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* gcc.c-torture/execute/20070227-1.c: New test.
+
+2007-02-27  Tobias Schlüter  <tobias.schlueter@physik.uni-muenchen.de>
+
+	PR fortran/25392
+	* gfortran.dg/f2c_8.f90: New test.
+
+2007-02-25  Roger Sayle  <roger@eyesopen.com>
+
+        PR fortran/30400
+        * gfortran.dg/forall_10.f90: New test case.
+
+2007-02-24  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/30918
+	* gfortran.dg/namelist_26.f90: New test.
+
+2007-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/30910	
+	* gfortran.dg/fmt_zero_precision.f90: New test.
+
+2007-02-21  Mark Mitchell  <mark@codesourcery.com>
+
+	* lib/wrapper.exp (${tool}_maybe_build_wrapper): Allow the caller
+	to set options for compiling testglue.
+	* lib/g++.exp (g++_init): Compile testglue with -fexceptions.
+	* lib/obj-c++.exp (obj-c++_init): Likewise.
+
+2007-02-20 Ira Rosen  <irar@il.ibm.com>
+
+	* gfortran.dg/vect/vect-2.f90: Xfail to vectorize one of the loops
+	because of aliasing.
+
+2007-02-18  Roger Sayle  <roger@eyesopen.com>
+
+	PR middle-end/24427
+	PR rtl-optimization/28173
+	* gcc.dg/tree-ssa/andor-1.c: New test case.
+
+2007-02-18 Ira Rosen  <irar@il.ibm.com>
+
+	* gcc.dg/vect/vect-106-alias.c: New test.
+
+2007-02-16  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* gcc.c-torture/execute/20070216-1.c: New test.
+
+2007-02-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/30799
+	* gfortran.dg/logical_2.f90: New test.
+
+2007-02-15  Alexandre Oliva  <aoliva@redhat.com>
+
+	* g++.dg/tree-ssa/sra-1.C: New.
+
+2007-02-10  Tobias Schlueter  <tobi@gcc.gnu.org>
+
+	PR fortran/30478
+	* gfortran.dg/enum_4.f90: Update expected error message.
+
+2007-02-15  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR debug/30189
+	* gcc.dg/pr30189.c: New test.
+
+2007-02-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* g++.dg/tree-ssa/nothrow-1.C: Skip test if -fpic/-fPIC is used.
+
+2007-02-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/30536
+	* g++.dg/tls/diag-5.C: New test.
+
+	PR middle-end/30473
+	* gcc.dg/pr30473.c: New test.
+	* gcc.c-torture/execute/20070201-1.c: New test.
+
+2007-02-14  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2007-01-30  Richard Guenther  <rguenther@suse.de>
+
+	PR middle-end/30313
+	* gcc.dg/torture/pr30313.c: New testcase.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/gcc/testsuite/g++.dg/debug/pr29906.C b/gcc/testsuite/g++.dg/debug/pr29906.C
new file mode 100644
index 00000000000..d277fb8e638
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/pr29906.C
@@ -0,0 +1,10 @@
+// { dg-do compile }
+// { dg-options "-g" }
+
+struct A{
+  typedef int T;
+  virtual ~A();
+};
+struct B:public A{
+  using A::T;
+};
diff --git a/gcc/testsuite/g++.dg/eh/ia64-2.C b/gcc/testsuite/g++.dg/eh/ia64-2.C
index 0390bc88305..aa005d8ed36 100644
--- a/gcc/testsuite/g++.dg/eh/ia64-2.C
+++ b/gcc/testsuite/g++.dg/eh/ia64-2.C
@@ -5,8 +5,9 @@
 // But br.call returns to the start of the next bundlem so during
 // unwinding the call was considered to be outside of the EH region
 // while it should have been inside.
-// { dg-options "-O2" }
 // { dg-do run }
+// { dg-require-weak "" }
+// { dg-options "-O2" }
 
 struct A {};
 struct B { virtual ~B(); };
diff --git a/gcc/testsuite/g++.dg/eh/weak1.C b/gcc/testsuite/g++.dg/eh/weak1.C
index 09f2fcba4df..3034e809ea7 100644
--- a/gcc/testsuite/g++.dg/eh/weak1.C
+++ b/gcc/testsuite/g++.dg/eh/weak1.C
@@ -1,6 +1,6 @@
 // PR target/29487
-// { dg-require-weak "" }
 // { dg-do run { xfail "hppa*-hp-hpux11.*" } }
+// { dg-require-weak "" }
 // { dg-additional-sources "weak1-a.cc" }
 // { dg-options "-O2" }
 
diff --git a/gcc/testsuite/g++.dg/ext/asm10.C b/gcc/testsuite/g++.dg/ext/asm10.C
new file mode 100644
index 00000000000..b95027c8cac
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/asm10.C
@@ -0,0 +1,14 @@
+// PR inline-asm/32109
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct A { int i[3]; ~A (); };
+struct A a;
+struct B { struct A c; int i; B (); } b;
+
+B::B ()
+{
+  __asm ("" : : "r" (a));	// { dg-error "impossible constraint|non-memory input" }
+  __asm ("" : : "r" (b.c));	// { dg-error "impossible constraint|non-memory input" }
+  __asm ("" : : "r" (c));	// { dg-error "impossible constraint|non-memory input" }
+}
diff --git a/gcc/testsuite/g++.dg/ext/interface4.C b/gcc/testsuite/g++.dg/ext/interface4.C
new file mode 100644
index 00000000000..85bb912839a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/interface4.C
@@ -0,0 +1,13 @@
+/* https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=227376 */
+
+/* { dg-do compile } */
+/* { dg-options "-g2" } */
+
+/* We used to crash when emitting debug info for type N::A because its
+   context was a namespace, not a function.  */
+
+#include "interface4.h"
+
+void f ( ) {
+        g ( );
+}
diff --git a/gcc/testsuite/g++.dg/ext/interface4.h b/gcc/testsuite/g++.dg/ext/interface4.h
new file mode 100644
index 00000000000..0971b372217
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/interface4.h
@@ -0,0 +1,8 @@
+#pragma interface
+namespace N {
+        typedef int A;
+}
+inline void g ( ) {
+        static N :: A a = 0;
+        a = a;
+}
diff --git a/gcc/testsuite/g++.dg/ext/offsetof1.C b/gcc/testsuite/g++.dg/ext/offsetof1.C
index 123a9e3efeb..1468c0a7c06 100644
--- a/gcc/testsuite/g++.dg/ext/offsetof1.C
+++ b/gcc/testsuite/g++.dg/ext/offsetof1.C
@@ -8,8 +8,10 @@ struct bar {
 };
 
 int a = __builtin_offsetof(bar, foo);  // { dg-error "static data member" }
+int av = __builtin_offsetof(volatile bar, foo);  // { dg-error "static data member" }
 int b = __builtin_offsetof(bar, baz);  // { dg-error "member function" }
 int b0 = __builtin_offsetof(bar, baz[0]);  // { dg-error "function" }
+int bv0 = __builtin_offsetof(volatile bar, baz[0]);  // { dg-error "function" }
 int c = __builtin_offsetof(bar, ~bar);  // { dg-error "member function" }
 
 typedef int I;
diff --git a/gcc/testsuite/g++.dg/ext/vector6.C b/gcc/testsuite/g++.dg/ext/vector6.C
new file mode 100644
index 00000000000..9caf8c2f69a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/vector6.C
@@ -0,0 +1,12 @@
+// { dg-options "" }
+// { dg-do compile }
+// C++/30016, we were allowing conversion between vector types
+// and union types which is invalid.
+
+typedef float __v_4F __attribute__ ((vector_size (16)));
+typedef union {__v_4F v; float a[4];} __v4F;
+void f(void)
+{
+      __v_4F b;
+      (reinterpret_cast<__v4F>(b).a)[1] = 1; // { dg-error "" }
+}
diff --git a/gcc/testsuite/g++.dg/inherit/conv3.C b/gcc/testsuite/g++.dg/inherit/conv3.C
new file mode 100644
index 00000000000..73d8c20f143
--- /dev/null
+++ b/gcc/testsuite/g++.dg/inherit/conv3.C
@@ -0,0 +1,31 @@
+// PR 31074
+// Bug: The reference cast wasn't finding the desired static_cast followed by
+// const_cast interpretation.
+
+struct Shape
+{
+  Shape() {}
+  virtual ~Shape() {}
+};
+
+struct Loop
+{
+  Loop() {}
+  virtual ~Loop() {}
+  virtual void func() {}
+};
+
+struct Rect :
+  public Shape,
+  public Loop
+{
+  Rect() {}
+  virtual ~Rect() {}
+};
+
+int main ()
+{
+  const Rect* rect = new Rect();
+  Loop &l = ((Loop&)(*rect));
+  return (&l != (const Loop *)rect);
+}
diff --git a/gcc/testsuite/g++.dg/init/const5.C b/gcc/testsuite/g++.dg/init/const5.C
new file mode 100644
index 00000000000..fa8d8fc2390
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/const5.C
@@ -0,0 +1,11 @@
+// PR c++/31449
+
+class Foo {};
+class Bar : public Foo {};
+static const Foo *foo = 0;
+
+static Bar *bar = static_cast<const Bar*>(foo); // { dg-error "conversion" }
+
+void func(const Foo *foo) {
+  Bar *bar = static_cast<const Bar*>(foo);  // { dg-error "conversion" }
+}
diff --git a/gcc/testsuite/g++.dg/init/ptrfn2.C b/gcc/testsuite/g++.dg/init/ptrfn2.C
new file mode 100644
index 00000000000..0ca922b9c38
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/ptrfn2.C
@@ -0,0 +1,14 @@
+// { dg-options "" }
+// { dg-do compile }
+// C++/30221
+// We would ICE while trying to reshape the pointer to
+// member function element which is not needed.
+
+
+class abstract {};
+typedef void (abstract::*fptr1) (short & s ) const;
+struct s {};
+s array[] =
+{
+ (fptr1)0 
+};// { dg-error "" }
diff --git a/gcc/testsuite/g++.dg/init/ptrfn3.C b/gcc/testsuite/g++.dg/init/ptrfn3.C
new file mode 100644
index 00000000000..960085063cf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/ptrfn3.C
@@ -0,0 +1,14 @@
+// { dg-options "" }
+// { dg-do compile }
+// C++/30221
+// We would ICE while trying to reshape the pointer to
+// member function element which is not needed.
+
+
+class abstract {};
+typedef void (abstract::*fptr1) (short & s ) const;
+struct s {fptr1 f;};
+s array[] =
+{
+ (fptr1)0
+};
diff --git a/gcc/testsuite/g++.dg/opt/complex6.C b/gcc/testsuite/g++.dg/opt/complex6.C
new file mode 100644
index 00000000000..bedb3ed5ffa
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/complex6.C
@@ -0,0 +1,14 @@
+// PR 30168
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct aaa
+{
+      aaa(_Complex float __z) ;
+      _Complex float _M_value;
+};
+aaa::aaa(_Complex float __z)
+{
+  __z*=2.0f;
+  _M_value = __z;
+}
diff --git a/gcc/testsuite/g++.dg/opt/nrv13.C b/gcc/testsuite/g++.dg/opt/nrv13.C
new file mode 100644
index 00000000000..bb49a3a6e4f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/nrv13.C
@@ -0,0 +1,42 @@
+// PR tree-optimization/32353
+// { dg-do run }
+// { dg-options "-O2" }
+
+extern "C" void abort ();
+
+struct A
+{
+  int f;
+  A (int x) : f (x) {}
+};
+
+A
+foo (const A &x, const A &y)
+{
+  A r (0);
+  r = x.f == -111 ? y : (y.f == -111 || x.f > y.f) ? x : y;
+  A s (0);
+  r = r.f == -111 ? s : (r.f > s.f) ? r : s;
+  return r;
+}
+
+int
+main ()
+{
+  if (foo (A (0), A (1)).f != 1)
+    abort ();
+  if (foo (A (1), A (9)).f != 9)
+    abort ();
+  if (foo (A (9), A (1)).f != 9)
+    abort ();
+  if (foo (A (-4), A (-5)).f != 0)
+    abort ();
+  if (foo (A (-111), A (-111)).f != 0)
+    abort ();
+  if (foo (A (2), A (-111)).f != 2)
+    abort ();
+  if (foo (A (-111), A (6)).f != 6)
+    abort ();
+  if (foo (A (-111), A (-4)).f != 0)
+    abort ();
+}
diff --git a/gcc/testsuite/g++.dg/opt/nrv14.C b/gcc/testsuite/g++.dg/opt/nrv14.C
new file mode 100644
index 00000000000..22526d6b59a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/nrv14.C
@@ -0,0 +1,39 @@
+// PR c++/32992
+// { dg-do run }
+// { dg-options "-O2" }
+
+extern "C" void abort (void);
+
+struct A
+{
+  long int a1;
+  long int a2;
+  long int a3;
+};
+
+struct B
+{
+  long int f[3];
+  operator A ()
+  {
+    union
+    {
+      long int t[3];
+      A a;
+    };
+    for (int i = 0; i < 3; i++)
+      t[i] = f[i];
+    return a;
+  }
+};
+
+int
+main ()
+{
+  B b = { {1, 3, 5} };
+  A a = b;
+
+  if (a.a1 != b.f[0] || a.a2 != b.f[1] || a.a3 != b.f[2])
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr30590.C b/gcc/testsuite/g++.dg/opt/pr30590.C
new file mode 100644
index 00000000000..42ae046db81
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr30590.C
@@ -0,0 +1,40 @@
+/* { dg-do run } */
+/* { dg-options "-O" } */
+struct test
+{
+  int type;
+  char buffer[4242]; /* should trigger pass-by-reference */
+};
+
+int flag = 0;
+
+struct test
+reset (void)
+{
+  struct test retval;
+  retval.type = 1;
+  return retval;
+}
+
+struct test
+test (void)
+{
+  struct test result;
+  result.type = 0;
+
+  for (int i = 0; i < 2; ++i)
+    {
+      struct test candidate = reset ();
+      if (flag)
+        result = candidate;
+    }
+
+  return result;
+}
+
+int
+main (void)
+{
+  struct test result = test ();
+  return result.type;
+}
diff --git a/gcc/testsuite/g++.dg/opt/static5.C b/gcc/testsuite/g++.dg/opt/static5.C
new file mode 100644
index 00000000000..1daca6d7194
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/static5.C
@@ -0,0 +1,29 @@
+// PR c++/31809
+// { dg-do run }
+// { dg-options "-O2" }
+
+struct S
+{
+  unsigned v;
+  static inline S f (unsigned a);
+};
+
+inline S
+S::f (unsigned a)
+{
+  static S t = { a };
+  return t;
+}
+
+const static S s = S::f (26);
+
+extern "C" void abort (void);
+
+int
+main ()
+{
+  S t = s;
+  if (t.v != 26)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/opt/static6.C b/gcc/testsuite/g++.dg/opt/static6.C
new file mode 100644
index 00000000000..00e76fb7350
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/static6.C
@@ -0,0 +1,35 @@
+// PR c++/31806
+// { dg-do run }
+// { dg-options "-O2 -fno-inline -fno-threadsafe-statics" }
+
+extern "C" void abort(void);
+
+struct A
+{
+    void *d;
+};
+
+static const A& staticA()
+{
+    static A s_static;
+    return s_static;
+}
+
+void assert_failed()
+{
+    abort();
+}
+
+A testMethod()
+{
+    static const A& s = staticA( );
+    if (&s == 0)
+        assert_failed();
+    return s;
+}
+
+int main()
+{
+    testMethod();
+    return 0;
+}
diff --git a/gcc/testsuite/g++.dg/other/error16.C b/gcc/testsuite/g++.dg/other/error16.C
new file mode 100644
index 00000000000..1e34647145d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/error16.C
@@ -0,0 +1,14 @@
+// PR c++/17763
+
+template <typename U> struct Outer {
+    struct Inner {};
+    Inner foo();
+};
+
+typedef int X;
+typedef Outer<X> XOuter;
+
+int main() {
+  Outer<int>  ab;
+  ab.foo() == 1; // { dg-error "ab.Outer" }
+}
diff --git a/gcc/testsuite/g++.dg/other/pr31698.C b/gcc/testsuite/g++.dg/other/pr31698.C
new file mode 100644
index 00000000000..b231ec0f691
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/pr31698.C
@@ -0,0 +1,47 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef long unsigned int size_t;
+
+template<class X>
+class A {
+public:
+        typedef size_t tySize;
+        inline void ResizeFast(const tySize & nSize)  {
+                if((nSize > m_nAllocSize) && (nSize > 0))   {
+                        m_nAllocSize = nSize;
+        }
+        }
+        inline void ResizeFast(const int & nSize) {
+        ResizeFast((tySize) nSize);
+        }
+        tySize m_nAllocSize;
+};
+
+class B {
+public:
+        B *GetNext(void) { };
+};
+
+class C  {
+public:
+        inline void Resize(void) {
+                array.ResizeFast(0);
+        }
+        A<int> array;
+};
+
+class D {
+private:
+        void Do(B * pB, C * pC);
+};
+
+void D::Do(B * pB, C * pC)
+{
+        pC->Resize();
+        B * pL = 0;
+        for(pL = pB;
+                pL != 0;
+                pL = pL->GetNext());
+}
+
diff --git a/gcc/testsuite/g++.dg/parse/cond3.C b/gcc/testsuite/g++.dg/parse/cond3.C
new file mode 100644
index 00000000000..96d9c1e3b5f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/parse/cond3.C
@@ -0,0 +1,15 @@
+// PR c++/30847
+// { dg-do compile }
+// { dg-options "" }
+
+int j, k, l;
+extern void baz ();
+
+void
+foo (int i)
+{
+  (i ? j : k) = ({ l++; (void) l; });	// { dg-error "void value not ignored" }
+  (i ? j : k) += ({ l++; (void) l; });	// { dg-error "void value not ignored" }
+  (i ? j : k) = baz ();			// { dg-error "void value not ignored" }
+  (i ? j : k) *= baz ();		// { dg-error "void value not ignored" }
+}
diff --git a/gcc/testsuite/g++.dg/parse/crash37.C b/gcc/testsuite/g++.dg/parse/crash37.C
new file mode 100644
index 00000000000..8320dfaa50f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/parse/crash37.C
@@ -0,0 +1,15 @@
+// PR c++/31941
+// { dg-do compile }
+
+struct S
+{
+  S() throw () { }
+  virtual ~S () throw ();
+  virtual const char* what () const throw ();
+};
+
+const char *
+foo (S &e)
+{
+  return e.what ().c_str ();	// { dg-error "c_str.*S::what.*which is of non-class type" }
+}
diff --git a/gcc/testsuite/g++.dg/parse/template23.C b/gcc/testsuite/g++.dg/parse/template23.C
new file mode 100644
index 00000000000..795457b68da
--- /dev/null
+++ b/gcc/testsuite/g++.dg/parse/template23.C
@@ -0,0 +1,10 @@
+/* PR c++/30895 This used to ICE.  */
+/* { dg-do "compile" } */
+
+template<int> struct A {};
+
+template<typename T> struct B
+{
+  A<T(0i)> a1; /* { dg-error "imaginary constants are a GCC extension" } */
+  A<T(0i)> a2; /* { dg-error "imaginary constants are a GCC extension" } */
+};
diff --git a/gcc/testsuite/g++.dg/template/arg6.C b/gcc/testsuite/g++.dg/template/arg6.C
new file mode 100644
index 00000000000..ef05abaeeda
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/arg6.C
@@ -0,0 +1,15 @@
+// PR c++/33744
+// { dg-do run }
+
+template <bool B> struct A { bool b; A() : b(B) {}; };
+A<bool(1)> a;
+A<bool(1<2)> b;
+A<(bool)(2>1)> c;
+A<bool((2>1))> d;
+A<bool(2>1)> e;
+
+int
+main ()
+{
+  return (a.b && b.b && c.b && d.b && e.b) ? 0 : 1;
+}
diff --git a/gcc/testsuite/g++.dg/template/crash70.C b/gcc/testsuite/g++.dg/template/crash70.C
new file mode 100644
index 00000000000..742f77b2225
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/crash70.C
@@ -0,0 +1,7 @@
+// PR c++/32113
+
+template<int> struct A;
+
+template<typename T> void foo (A<&T::template i>); // { dg-error "not a template" }
+
+template void foo<A<0> > (A<0>); // { dg-error "does not match" }
diff --git a/gcc/testsuite/g++.dg/template/error26.C b/gcc/testsuite/g++.dg/template/error26.C
new file mode 100644
index 00000000000..7545762bf34
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/error26.C
@@ -0,0 +1,5 @@
+// PR c++/32112
+
+template<typename> struct A;
+
+template<typename T> void foo (A<&T::template i>); // { dg-error "T::template i|mismatch|& T::i" }
diff --git a/gcc/testsuite/g++.dg/template/init7.C b/gcc/testsuite/g++.dg/template/init7.C
new file mode 100644
index 00000000000..e2267767b89
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/init7.C
@@ -0,0 +1,9 @@
+/* PR c++/31517. This used to ICE.  */
+/* { dg-do "compile" } */
+
+template<typename> struct A
+{
+  static const int i=0;
+};
+
+template<typename T> const int A<T>::i = 0=0; /* { dg-error "duplicate initialization" } */
diff --git a/gcc/testsuite/g++.dg/tls/diag-5.C b/gcc/testsuite/g++.dg/tls/diag-5.C
new file mode 100644
index 00000000000..ca92b307428
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tls/diag-5.C
@@ -0,0 +1,5 @@
+// PR c++/30536
+// Invalid __thread specifiers.
+// { dg-require-effective-target tls }
+
+struct A { __thread register int i; }; // { dg-error "multiple storage classes|storage class specified" }
diff --git a/gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C b/gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C
index 6dbf1393a39..4bb71589de3 100644
--- a/gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C
+++ b/gcc/testsuite/g++.dg/tree-ssa/nothrow-1.C
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O1 -fdump-tree-cfg" } */
+/* { dg-skip-if "" { "*-*-*" } { "-fpic" "-fPIC" } { "" } } */
 double a;
 void t()
 {
diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr14814.C b/gcc/testsuite/g++.dg/tree-ssa/pr14814.C
index c793f88f22f..add6e11635a 100644
--- a/gcc/testsuite/g++.dg/tree-ssa/pr14814.C
+++ b/gcc/testsuite/g++.dg/tree-ssa/pr14814.C
@@ -14,7 +14,7 @@ int foo(XX& r) {
   if (r.direction().y() < 0.000001) return 0;
   return 1; }
 
-/* { dg-final { scan-tree-dump-times "&this" 0 "forwprop2" { xfail *-*-* } } }*/
+/* { dg-final { scan-tree-dump-times "&this" 0 "forwprop2" } }*/
 /* { dg-final { scan-tree-dump-times "&r" 0 "forwprop2" } } */
 /* { dg-final { cleanup-tree-dump "forwprop2" } } */
 
diff --git a/gcc/testsuite/g++.dg/tree-ssa/sra-1.C b/gcc/testsuite/g++.dg/tree-ssa/sra-1.C
new file mode 100644
index 00000000000..e3e3918eb78
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-ssa/sra-1.C
@@ -0,0 +1,29 @@
+/* https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=223576 */
+
+/* SRA failed to canonicalize bit-field types, introducing type
+   mismatches.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct A
+{
+  int a:16;
+  /* These dummy bit-fields are here to prevent GCC 4.2+ from merging
+     the bit-field compares into a single word compare, which disables
+     SRA.  */
+  int a2:16;
+  int a3:16;
+  int a4:16;
+  int b:8;
+  bool operator==(A const x) const
+  {
+    return (this->a == x.a && this->b == x.b);
+  }
+};
+
+bool
+foo (A const x, A const y)
+{
+  return x == y;
+}
diff --git a/gcc/testsuite/g++.old-deja/g++.warn/flow1.C b/gcc/testsuite/g++.old-deja/g++.warn/flow1.C
index 61f6a554970..e69de29bb2d 100644
--- a/gcc/testsuite/g++.old-deja/g++.warn/flow1.C
+++ b/gcc/testsuite/g++.old-deja/g++.warn/flow1.C
@@ -1,14 +0,0 @@
-// { dg-do assemble  }
-// { dg-options "-Wreturn-type" }
-// Test that we don't get a warning about flowing off the end.
-
-struct A {
-  ~A ();
-};
-
-int f()
-{
-  A a1[2];
-  A a2[2];
-  return 1234567;
-}
diff --git a/gcc/testsuite/gcc.c-torture/compile/20070419-1.c b/gcc/testsuite/gcc.c-torture/compile/20070419-1.c
new file mode 100644
index 00000000000..ea23bf8bdc0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/20070419-1.c
@@ -0,0 +1,17 @@
+/* PR tree-optimization/31632 */
+
+struct S
+{
+  long int l;
+  void *m;
+};
+
+int
+foo (struct S *x)
+{
+  unsigned long a;
+  a = x->l;
+  if (a <= ((void *) 0))
+    x->m = 0;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/20071102-1.c b/gcc/testsuite/gcc.c-torture/compile/20071102-1.c
new file mode 100644
index 00000000000..03b015628cd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/20071102-1.c
@@ -0,0 +1,32 @@
+/* PR rtl-optimization/28062 */
+/* Original testcase by Martin Michlmayr <tbm@cyrius.com> */
+/* C testcase by Andrew Pinski <pinskia@gcc.gnu.org> */
+
+struct _NSPoint
+{
+  float x;
+  float y;
+};
+
+typedef struct _NSPoint NSPoint;
+
+static inline NSPoint
+NSMakePoint (float x, float y)
+{
+  NSPoint point;
+  point.x = x;
+  point.y = y;
+  return point;
+}
+
+static inline NSPoint
+RelativePoint (NSPoint point, NSPoint refPoint)
+{
+  return NSMakePoint (refPoint.x + point.x, refPoint.y + point.y);
+}
+
+NSPoint g(NSPoint refPoint)
+{
+  float pointA, pointB;
+  return RelativePoint (NSMakePoint (0, pointA), refPoint);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/20080114-1.c b/gcc/testsuite/gcc.c-torture/compile/20080114-1.c
new file mode 100644
index 00000000000..f251c22b96e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/20080114-1.c
@@ -0,0 +1,14 @@
+/* PR rtl-optimization/31944 */
+/* Origin: Aurelien Jarno <aurelien@aurel32.net> */
+
+int type;
+
+void stuck(int res)
+{
+  if (type == 1) {
+    if (res == 0) asm volatile("");
+  }
+  else if (type == 0) {
+    if (res == 0) asm volatile("" : : "i" (0));
+  }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr28675.c b/gcc/testsuite/gcc.c-torture/compile/pr28675.c
new file mode 100644
index 00000000000..0d78353739c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr28675.c
@@ -0,0 +1,38 @@
+struct fb_cmap {
+ unsigned int start;
+ unsigned int len;
+ unsigned short *red;
+ unsigned short *green;
+ unsigned short *blue;
+ unsigned short *transp;
+};
+
+typedef struct {
+    int r;
+    int g;
+    int b;
+    int a;
+} rgba_t;
+
+static unsigned int cmap_len;
+
+extern unsigned int red_len, green_len, blue_len, alpha_len;
+extern struct fb_cmap fb_cmap;
+extern rgba_t *clut;
+extern int fb_set_cmap(void);
+
+void directcolor_update_cmap(void)
+{
+    unsigned int i;
+
+    for (i = 0; i < cmap_len; i++) {
+      if (i < red_len)
+	fb_cmap.red[i] = clut[i].r;
+      if (i < green_len)
+	fb_cmap.green[i] = clut[i].g;
+      if (i < blue_len)
+	fb_cmap.blue[i] = clut[i].b;
+      if (fb_cmap.transp && i < alpha_len)
+	fb_cmap.transp[i] = clut[i].a;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr30433.c b/gcc/testsuite/gcc.c-torture/compile/pr30433.c
new file mode 100644
index 00000000000..1f0edd0794d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr30433.c
@@ -0,0 +1,2 @@
+int f = (_Complex float)(0.5) == 0.5;
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr30984.c b/gcc/testsuite/gcc.c-torture/compile/pr30984.c
new file mode 100644
index 00000000000..265a6f3616b
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr30984.c
@@ -0,0 +1,7 @@
+int fs_exec(int ino)
+{
+ void *src = 0;
+ if (ino)
+   src = (void*)0xe000;
+ goto *src;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr34030.c b/gcc/testsuite/gcc.c-torture/compile/pr34030.c
new file mode 100644
index 00000000000..f4f9e176d3f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr34030.c
@@ -0,0 +1,8 @@
+int myvar;
+
+int foo(int mynum)
+{
+  if ((((void *)0) == (myvar & ((1U<<0) << mynum))) && (mynum > 0))
+    return 1;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr34993.c b/gcc/testsuite/gcc.c-torture/compile/pr34993.c
new file mode 100644
index 00000000000..ced4d5646c1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr34993.c
@@ -0,0 +1,5 @@
+/* PR c/34993 */
+
+/* { dg-do compile } */
+
+typedef int x[] __attribute((may_alias));
diff --git a/gcc/testsuite/gcc.c-torture/execute/20070201-1.c b/gcc/testsuite/gcc.c-torture/execute/20070201-1.c
new file mode 100644
index 00000000000..c676c3475a1
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20070201-1.c
@@ -0,0 +1,20 @@
+/* PR middle-end/30473 */
+
+extern int sprintf (char *, const char *, ...);
+extern void abort (void);
+
+char *
+foo (char *buf, char *p)
+{
+  sprintf (buf, "abcde", p++);
+  return p;
+}
+
+int
+main (void)
+{
+  char buf[6];
+  if (foo (buf, &buf[2]) != &buf[3])
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20070216-1.c b/gcc/testsuite/gcc.c-torture/execute/20070216-1.c
new file mode 100644
index 00000000000..fc235606926
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20070216-1.c
@@ -0,0 +1,23 @@
+/* PR rtl-optimization/30787 */
+/* Testcase by Jakub Jelinek <jakub@gcc.gnu.org> */
+
+struct S
+{
+  int *s;
+};
+
+void test (int x, struct S *y)
+{
+  int i;
+  for (i = 0; i < x; i++)
+    {
+      if (y)
+        y->s[i] += 1;
+    }
+}
+
+int main (void)
+{
+  test (1, (void *) 0);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20070227-1.c b/gcc/testsuite/gcc.c-torture/execute/20070227-1.c
new file mode 100644
index 00000000000..1432b8701bf
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20070227-1.c
@@ -0,0 +1,31 @@
+/* PR rtl-optimization/30931 */
+/* Testcase by Peter Bergner <bergner@gcc.gnu.org> */
+
+struct s
+{
+  int first;
+  int done;
+};
+
+void bug (struct s *p)
+{
+  int i;
+  for (i=0; i < 2; i++)
+    {
+      while (p[i].first && p[i].done)
+        p[i].first = 0;
+    }
+}
+
+int main (void)
+{
+  struct s array[2];
+  array[0].first = 1;
+  array[0].done = 1;
+  array[1].first = 0;
+  array[1].done = 0;
+
+  bug (array);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20070517-1.c b/gcc/testsuite/gcc.c-torture/execute/20070517-1.c
new file mode 100644
index 00000000000..c81cbc639be
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20070517-1.c
@@ -0,0 +1,41 @@
+/* PR rtl-optimization/31691 */
+/* Origin: Chi-Hua Chen <stephaniechc-gccbug@yahoo.com> */
+
+extern void abort (void);
+
+static int get_kind(int) __attribute__ ((noinline));
+
+static int get_kind(int v)
+{
+  volatile int k = v;
+  return k;
+}
+
+static int some_call(void) __attribute__ ((noinline));
+
+static int some_call(void)
+{
+  return 0;
+}
+
+static void example (int arg)
+{
+  int tmp, kind = get_kind (arg);
+
+  if (kind == 9 || kind == 10 || kind == 5)
+    {
+      if (some_call() == 0)
+        {
+          if (kind == 9 || kind == 10)
+            tmp = arg;
+          else
+            abort();
+        }
+    }
+} 
+
+int main(void)
+{
+  example(10);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20070614-1.c b/gcc/testsuite/gcc.c-torture/execute/20070614-1.c
new file mode 100644
index 00000000000..fa44f7fa3ec
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20070614-1.c
@@ -0,0 +1,33 @@
+extern void abort (void);
+
+_Complex v = 3.0 + 1.0iF;
+
+void
+foo (_Complex z, int *x)
+{
+  if (z != v)
+    abort ();
+}
+
+_Complex bar (_Complex z) __attribute__ ((pure));
+_Complex
+bar (_Complex z)
+{
+  return v;
+}
+
+int
+baz (void)
+{
+  int a, i;
+  for (i = 0; i < 6; i++)
+    foo (bar (1.0iF * i), &a);
+  return 0;
+}
+
+int
+main ()
+{
+  baz ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20080408-1.c b/gcc/testsuite/gcc.c-torture/execute/20080408-1.c
new file mode 100644
index 00000000000..9e1ff639517
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20080408-1.c
@@ -0,0 +1,11 @@
+extern void abort (void);
+int main ()
+{
+  short ssi = 126;
+  unsigned short usi = 65280;
+  int fail = !(ssi < usi);
+  if (fail)
+    abort ();
+  return 0;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/builtins/chk.h b/gcc/testsuite/gcc.c-torture/execute/builtins/chk.h
index dfef410c61b..f91ec78c4ec 100644
--- a/gcc/testsuite/gcc.c-torture/execute/builtins/chk.h
+++ b/gcc/testsuite/gcc.c-torture/execute/builtins/chk.h
@@ -79,3 +79,11 @@ extern volatile int memset_disallowed, strcpy_disallowed, stpcpy_disallowed;
 extern volatile int strncpy_disallowed, strcat_disallowed, strncat_disallowed;
 extern volatile int sprintf_disallowed, vsprintf_disallowed;
 extern volatile int snprintf_disallowed, vsnprintf_disallowed;
+
+/* A storage class that ensures that declarations bind locally.  We want
+   to test non-static declarations where we know it is safe to do so.  */
+#if __PIC__ || __pic__
+#define LOCAL static
+#else
+#define LOCAL
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/execute/builtins/sprintf-chk.c b/gcc/testsuite/gcc.c-torture/execute/builtins/sprintf-chk.c
index 95d2a9d2826..2862ab6dc91 100644
--- a/gcc/testsuite/gcc.c-torture/execute/builtins/sprintf-chk.c
+++ b/gcc/testsuite/gcc.c-torture/execute/builtins/sprintf-chk.c
@@ -13,7 +13,7 @@ extern int sprintf (char *, const char *, ...);
 
 #include "chk.h"
 
-const char s1[] = "123";
+LOCAL const char s1[] = "123";
 char p[32] = "";
 char *s2 = "defg";
 char *s3 = "FGH";
diff --git a/gcc/testsuite/gcc.c-torture/execute/builtins/stpcpy-chk.c b/gcc/testsuite/gcc.c-torture/execute/builtins/stpcpy-chk.c
index b292c0aec87..6091f129359 100644
--- a/gcc/testsuite/gcc.c-torture/execute/builtins/stpcpy-chk.c
+++ b/gcc/testsuite/gcc.c-torture/execute/builtins/stpcpy-chk.c
@@ -11,7 +11,7 @@ extern int memcmp (const void *, const void *, size_t);
 
 #include "chk.h"
 
-const char s1[] = "123";
+LOCAL const char s1[] = "123";
 char p[32] = "";
 char *s2 = "defg";
 char *s3 = "FGH";
diff --git a/gcc/testsuite/gcc.c-torture/execute/builtins/strcpy-chk.c b/gcc/testsuite/gcc.c-torture/execute/builtins/strcpy-chk.c
index 002dd19500e..b3c1a3899d9 100644
--- a/gcc/testsuite/gcc.c-torture/execute/builtins/strcpy-chk.c
+++ b/gcc/testsuite/gcc.c-torture/execute/builtins/strcpy-chk.c
@@ -11,7 +11,7 @@ extern int memcmp (const void *, const void *, size_t);
 
 #include "chk.h"
 
-const char s1[] = "123";
+LOCAL const char s1[] = "123";
 char p[32] = "";
 char *s2 = "defg";
 char *s3 = "FGH";
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr31448.c b/gcc/testsuite/gcc.c-torture/execute/pr31448.c
new file mode 100644
index 00000000000..720ba926eaa
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr31448.c
@@ -0,0 +1,36 @@
+/* PR middle-end/31448, this used to ICE during expand because
+   reduce_to_bit_field_precision was not ready to handle constants. */
+
+typedef struct _st {
+    int iIndex : 24;
+    int iIndex1 : 24;
+} st;
+st *next;
+void g(void)
+{
+    st *next = 0;
+    int nIndx;
+    const static int constreg[] = { 0,};
+    nIndx = 0;
+    next->iIndex = constreg[nIndx];
+}
+void f(void)
+{
+    int nIndx;
+    const static int constreg[] = { 0xFEFEFEFE,};
+    nIndx = 0;
+    next->iIndex = constreg[nIndx];
+    next->iIndex1 = constreg[nIndx];
+}
+int main(void)
+{
+  st a;
+  next = &a;
+  f();
+  if (next->iIndex != 0xFFFEFEFE)
+    __builtin_abort ();
+  if (next->iIndex1 != 0xFFFEFEFE)
+    __builtin_abort ();
+  return 0;
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr33142.c b/gcc/testsuite/gcc.c-torture/execute/pr33142.c
new file mode 100644
index 00000000000..7bfc5b584db
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr33142.c
@@ -0,0 +1,16 @@
+int abs(int j);
+extern void abort(void);
+
+__attribute__((noinline)) int lisp_atan2(long dy, long dx) {
+    if (dx <= 0)
+        if (dy > 0)
+            return abs(dx) <= abs(dy);
+    return 0;
+}
+
+int main() {   
+    volatile long dy = 63, dx = -77;
+    if (lisp_atan2(dy, dx))
+        abort();
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr33631.c b/gcc/testsuite/gcc.c-torture/execute/pr33631.c
new file mode 100644
index 00000000000..840fd0dc482
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr33631.c
@@ -0,0 +1,14 @@
+typedef union
+{
+  int __lock;
+} pthread_mutex_t;
+
+extern void abort (void);
+
+int main()
+{
+    struct { int c; pthread_mutex_t m; } r = { .m = 0 };
+    if (r.c != 0)
+      abort ();
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr34130.c b/gcc/testsuite/gcc.c-torture/execute/pr34130.c
new file mode 100644
index 00000000000..b528ff22b8a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr34130.c
@@ -0,0 +1,12 @@
+extern void abort (void);
+int foo (int i)
+{
+  return -2 * __builtin_abs(i - 2);
+}
+int main()
+{
+  if (foo(1) != -2
+      || foo(3) != -2)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr34456.c b/gcc/testsuite/gcc.c-torture/execute/pr34456.c
new file mode 100644
index 00000000000..526c954e55a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr34456.c
@@ -0,0 +1,30 @@
+#include <stdlib.h>
+
+int __attribute__ ((noinline)) debug (void) { return 1; }
+int errors;
+
+struct s { int elt; int (*compare) (int); };
+
+static int
+compare (const void *x, const void *y)
+{
+  const struct s *s1 = x, *s2 = y;
+  int (*compare1) (int);
+  int elt2;
+
+  compare1 = s1->compare;
+  elt2 = s2->elt;
+  if (elt2 != 0 && debug () && compare1 (s1->elt) != 0)
+    errors++;
+  return compare1 (elt2);
+}
+
+int bad_compare (int x) { return -x; }
+struct s array[2] = { { 1, bad_compare }, { -1, bad_compare } };
+
+int
+main (void)
+{
+  qsort (array, 2, sizeof (struct s), compare);
+  return errors == 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr35163.c b/gcc/testsuite/gcc.c-torture/execute/pr35163.c
new file mode 100644
index 00000000000..4950d6d2027
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr35163.c
@@ -0,0 +1,11 @@
+extern void abort(void);
+
+int main()
+{
+  signed char a = -30;
+  signed char b = -31;
+  if (a > (unsigned short)b)
+    abort ();
+  return 0;
+}
+
diff --git a/gcc/testsuite/gcc.dg/20070507-1.c b/gcc/testsuite/gcc.dg/20070507-1.c
new file mode 100644
index 00000000000..2884d1aa8d8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/20070507-1.c
@@ -0,0 +1,103 @@
+/* This failed on s390x due to bug in loop.c.
+   loop.c failed to remove a REG_EQUAL note when
+   hoisting an insn from a loop body.  */
+
+/* { dg-options "-O3 -fPIC" } */
+/* { dg-do run { target fpic } } */
+
+typedef __SIZE_TYPE__ size_t;
+int memcmp(const void *s1, const void *s2, size_t n);
+
+typedef struct
+{
+  char name[30];
+  int a;
+} LOCAL;
+
+int global = 0;
+int sy = 1;
+int subroutine_offset;
+
+LOCAL local = { "local", 0 };
+LOCAL keywords = { "keywords", 1 };
+int local_table = 0;
+int keywords_table = 0;
+
+void __attribute__((noinline)) bar (char *p_buffer)
+{
+  p_buffer[255] = 1;
+}
+
+int __attribute__((noinline)) foo (char *p_str1)
+{
+  global = 1;
+  return 1;
+}
+
+int __attribute__((noinline)) loop_next (int *p_table, char *p_table_head)
+{
+  static loop_next = 0;
+
+  if (loop_next == 1)
+    return 1;
+
+  loop_next = 1;
+  return 0;
+}
+
+int
+main ()
+{
+  char buffer[256];
+  int ende = 0;
+  int index;
+  int local_base = 2;
+
+  keywords.a = 1;
+  for (sy = 0;; sy++)
+    {
+      for (index = 1;;)
+	{
+	  bar (buffer);
+	  if (buffer[sy] != 0)
+	    {
+	      ende = 1;
+	      break;
+	    };
+	  if (foo (buffer))
+	    {
+	      keywords.a += index - 1;
+	      break;
+	    }
+	  index++;
+	}
+      if (ende)
+	break;
+    }
+
+  subroutine_offset = 0;
+
+  for (;;)
+    {
+      if (loop_next (&keywords_table, (char*)&keywords))
+	break;
+
+      if ((!memcmp (keywords.name, "+++", 3)))
+	local_base = 100;
+      else
+	local_base = 0;
+
+      if ((!memcmp (keywords.name, "+++", 3)))
+	subroutine_offset += local_table;
+
+      for (;;)
+	{
+	  if (loop_next (&local_table, (char*)&local))
+	    break;;
+	  if ((local.a == 0))
+	    continue;;
+	  foo (local.name);
+	}
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/20070801-1.c b/gcc/testsuite/gcc.dg/20070801-1.c
new file mode 100644
index 00000000000..d6a034cd13d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/20070801-1.c
@@ -0,0 +1,62 @@
+/* This failed on s390x due to a back end bug.  */
+
+/* { dg-do compile { target fpic } } */
+/* { dg-options "-O2 -fpic" } */
+
+typedef long unsigned int size_t;
+typedef enum
+{
+  TYPE_SCHAR, TYPE_LONGDOUBLE
+}
+arg_type;
+
+typedef struct
+{
+  arg_type type;
+  union
+  {
+    signed char a_schar;
+    long double a_longdouble;
+  }
+  a;
+}
+argument;
+
+typedef struct
+{
+  argument *arg;
+}
+arguments;
+
+int ind;
+
+extern void foo (arguments *a);
+
+void
+bar ()
+{
+  arguments a;
+  char *buf;
+  char *result;
+  int uninitialized;
+  int count, i;
+  int retcount;
+
+  foo (&a);
+
+  switch (a.arg[ind].type)
+    {
+    case TYPE_SCHAR:
+      {
+	if (uninitialized == 0)
+	  __builtin___snprintf_chk (result, 10, 1, 10, buf, 1, &count);
+      }
+    case TYPE_LONGDOUBLE:
+      {
+	long double arg = a.arg[ind].a.a_longdouble;
+
+	if (uninitialized == 0)
+	  __builtin___snprintf_chk (result, 10, 1, 10, buf, arg, &count);
+      }
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/Wunused-value-2.c b/gcc/testsuite/gcc.dg/Wunused-value-2.c
new file mode 100644
index 00000000000..4858bfade72
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Wunused-value-2.c
@@ -0,0 +1,18 @@
+/* Test -Wunused-value.  Bug 30729.  */
+/* { dg-do compile } */
+/* { dg-options "-Wunused-value" } */
+/* Make sure va_arg does not cause a value computed is not used warning
+   because it has side effects.   */
+#include <stdarg.h>
+
+int f(int t, ...)
+{
+  va_list a;
+  va_start (a, t);
+  va_arg(a, int);/* { dg-bogus "value computed is not used" } */
+  int t1 = va_arg(a, int);
+  va_end(a);
+  return t1;
+}
+
+
diff --git a/gcc/testsuite/gcc.dg/assign-warn-3.c b/gcc/testsuite/gcc.dg/assign-warn-3.c
index 1463fce0f68..4ff7b88fa5f 100644
--- a/gcc/testsuite/gcc.dg/assign-warn-3.c
+++ b/gcc/testsuite/gcc.dg/assign-warn-3.c
@@ -5,9 +5,9 @@
 /* { dg-options "-O3 -std=c99 -pedantic-errors" } */
 
 /* This is valid to execute, so maybe shouldn't warn at all.  */
-void f0(x) signed char *x; { }
+static inline void f0(x) signed char *x; { }
 void g0(unsigned char *x) { f0(x); } /* { dg-warning "warning: pointer targets in passing argument 1 of 'f0' differ in signedness" } */
 
 /* This is undefined on execution but still must compile.  */
-void f1(x) int *x; { }
+static inline void f1(x) int *x; { }
 void g1(unsigned int *x) { f1(x); } /* { dg-warning "warning: pointer targets in passing argument 1 of 'f1' differ in signedness" } */
diff --git a/gcc/testsuite/gcc.dg/c99-math-double-1.c b/gcc/testsuite/gcc.dg/c99-math-double-1.c
index 54bdf60dfe7..6441a59fe1c 100644
--- a/gcc/testsuite/gcc.dg/c99-math-double-1.c
+++ b/gcc/testsuite/gcc.dg/c99-math-double-1.c
@@ -6,13 +6,17 @@
 
 int main(void)
 {
-  double nan = NAN;
-  double inf = INFINITY;
-  double huge = HUGE_VAL;
-  double norm = __DBL_MIN__;
-  double zero = 0.0;
+  volatile double nan = NAN;
+  volatile double inf = INFINITY;
+  volatile double huge = HUGE_VAL;
+  volatile double norm1 = __DBL_MIN__;
+  volatile double norm2 = 1;
+  volatile double norm3 = __DBL_MAX__;
+  volatile double sub = __DBL_MIN__ / 2;
+  volatile double zero = 0.0;
 
-  C99_MATH_TESTS (nan, inf, huge, norm, zero)
+  C99_MATH_TESTS (nan, inf, huge, norm1, norm2, norm3, sub, zero, /*neg=*/0)
+  C99_MATH_TESTS (-nan, -inf, -huge, -norm1, -norm2, -norm3, -sub, -zero, /*neg=*/1)
 
   return 0;
 }
diff --git a/gcc/testsuite/gcc.dg/c99-math-float-1.c b/gcc/testsuite/gcc.dg/c99-math-float-1.c
index ba27a710bde..36a73960266 100644
--- a/gcc/testsuite/gcc.dg/c99-math-float-1.c
+++ b/gcc/testsuite/gcc.dg/c99-math-float-1.c
@@ -6,13 +6,17 @@
 
 int main(void)
 {
-  float nan = NAN;
-  float inf = INFINITY;
-  float huge = HUGE_VALF;
-  float norm = __FLT_MIN__;
-  float zero = 0.0f;
+  volatile float nan = NAN;
+  volatile float inf = INFINITY;
+  volatile float huge = HUGE_VALF;
+  volatile float norm1 = __FLT_MIN__;
+  volatile float norm2 = 1;
+  volatile float norm3 = __FLT_MAX__;
+  volatile float sub = __FLT_MIN__ / 2;
+  volatile float zero = 0.0f;
 
-  C99_MATH_TESTS (nan, inf, huge, norm, zero)
+  C99_MATH_TESTS (nan, inf, huge, norm1, norm2, norm3, sub, zero, /*neg=*/0)
+  C99_MATH_TESTS (-nan, -inf, -huge, -norm1, -norm2, -norm3, -sub, -zero, /*neg=*/1)
 
   return 0;
 }
diff --git a/gcc/testsuite/gcc.dg/c99-math-long-double-1.c b/gcc/testsuite/gcc.dg/c99-math-long-double-1.c
index a8fa4d21fc1..d8146c28a5a 100644
--- a/gcc/testsuite/gcc.dg/c99-math-long-double-1.c
+++ b/gcc/testsuite/gcc.dg/c99-math-long-double-1.c
@@ -6,13 +6,17 @@
 
 int main(void)
 {
-  long double nan = NAN;
-  long double inf = INFINITY;
-  long double huge = HUGE_VALL;
-  long double norm = __LDBL_MIN__;
-  long double zero = 0.0l;
+  volatile long double nan = NAN;
+  volatile long double inf = INFINITY;
+  volatile long double huge = HUGE_VALL;
+  volatile long double norm1 = __LDBL_MIN__;
+  volatile long double norm2 = 1;
+  volatile long double norm3 = __LDBL_MAX__;
+  volatile long double sub = __LDBL_MIN__ / 2;
+  volatile long double zero = 0.0l;
 
-  C99_MATH_TESTS (nan, inf, huge, norm, zero)
+  C99_MATH_TESTS (nan, inf, huge, norm1, norm2, norm3, sub, zero, /*neg=*/0)
+  C99_MATH_TESTS (-nan, -inf, -huge, -norm1, -norm2, -norm3, -sub, -zero, /*neg=*/1)
 
   return 0;
 }
diff --git a/gcc/testsuite/gcc.dg/c99-math.h b/gcc/testsuite/gcc.dg/c99-math.h
index 3f42f67319d..81f2e6ddb43 100644
--- a/gcc/testsuite/gcc.dg/c99-math.h
+++ b/gcc/testsuite/gcc.dg/c99-math.h
@@ -1,9 +1,14 @@
 #include <math.h>
+#include <fenv.h>
 
 extern void abort(void);
 
-#define C99_MATH_TESTS(nan, inf, huge, norm, zero)	\
+#define C99_MATH_TESTS(nan, inf, huge, norm1, norm2, norm3, sub, zero, neg) \
 {							\
+  if (feclearexcept (FE_ALL_EXCEPT) != 0)		\
+    abort();						\
+							\
+							\
   if (fpclassify (nan) != FP_NAN)			\
     abort ();						\
 							\
@@ -13,7 +18,16 @@ extern void abort(void);
   if (fpclassify (huge) != FP_INFINITE)			\
     abort ();						\
 							\
-  if (fpclassify (norm) != FP_NORMAL)			\
+  if (fpclassify (norm1) != FP_NORMAL)			\
+    abort ();						\
+							\
+  if (fpclassify (norm2) != FP_NORMAL)			\
+    abort ();						\
+							\
+  if (fpclassify (norm3) != FP_NORMAL)			\
+    abort ();						\
+							\
+  if (fpclassify (sub) != FP_SUBNORMAL)			\
     abort ();						\
 							\
   if (fpclassify (zero) != FP_ZERO)			\
@@ -29,7 +43,16 @@ extern void abort(void);
   if (isnan (huge))					\
     abort ();						\
 							\
-  if (isnan (norm))					\
+  if (isnan (norm1))					\
+    abort ();						\
+							\
+  if (isnan (norm2))					\
+    abort ();						\
+							\
+  if (isnan (norm3))					\
+    abort ();						\
+							\
+  if (isnan (sub))					\
     abort ();						\
 							\
   if (isnan (zero))					\
@@ -45,7 +68,16 @@ extern void abort(void);
   if (!isinf (huge))					\
     abort ();						\
 							\
-  if (isnan (norm))					\
+  if (isinf (norm1))					\
+    abort ();						\
+							\
+  if (isinf (norm2))					\
+    abort ();						\
+							\
+  if (isinf (norm3))					\
+    abort ();						\
+							\
+  if (isinf (sub))					\
     abort ();						\
 							\
   if (isinf (zero))					\
@@ -61,7 +93,16 @@ extern void abort(void);
   if (isfinite (huge))					\
     abort ();						\
 							\
-  if (!isfinite (norm))					\
+  if (!isfinite (norm1))				\
+    abort ();						\
+							\
+  if (!isfinite (norm2))				\
+    abort ();						\
+							\
+  if (!isfinite (norm3))				\
+    abort ();						\
+							\
+  if (!isfinite (sub))					\
     abort ();						\
 							\
   if (!isfinite (zero))					\
@@ -77,35 +118,119 @@ extern void abort(void);
   if (isnormal (huge))					\
     abort ();						\
 							\
-  if (!isnormal (norm))					\
+  if (!isnormal (norm1))				\
+    abort ();						\
+							\
+  if (!isnormal (norm2))				\
+    abort ();						\
+							\
+  if (!isnormal (norm3))				\
+    abort ();						\
+							\
+  if (isnormal (sub))					\
     abort ();						\
 							\
   if (isnormal (zero))					\
     abort ();						\
 							\
 							\
-  if (signbit (norm))					\
+  if (!!signbit (nan) != neg)				\
+    abort ();						\
+							\
+  if (!!signbit (inf) != neg)				\
+    abort ();						\
+							\
+  if (!!signbit (huge) != neg)				\
+    abort ();						\
+							\
+  if (!!signbit (norm1) != neg)				\
     abort ();						\
 							\
-  if (!signbit (-(norm)))				\
+  if (!!signbit (norm2) != neg)				\
     abort ();						\
 							\
+  if (!!signbit (norm3) != neg)				\
+    abort ();						\
+							\
+  if (!!signbit (sub) != neg)				\
+    abort ();						\
+							\
+  if (!!signbit (zero) != neg)				\
+    abort ();						\
+							\
+							\
+  if (neg)						\
+  {							\
+    if (!isless ((inf), (norm1)))			\
+      abort ();						\
+							\
+    if (!isless ((inf), (norm2)))			\
+      abort ();						\
 							\
-  if (!isgreater ((inf), (norm)))			\
+    if (!isless ((inf), (norm3)))			\
+      abort ();						\
+							\
+    if (!islessequal ((inf), (huge)))			\
+      abort ();						\
+							\
+    if (!isgreater ((norm1), (inf)))			\
+      abort ();						\
+							\
+    if (!isgreater ((norm2), (inf)))			\
+      abort ();						\
+							\
+    if (!isgreater ((norm3), (inf)))			\
+      abort ();						\
+							\
+    if (!isgreaterequal ((huge), (inf)))		\
+      abort ();						\
+  }							\
+  else							\
+  {							\
+    if (!isgreater ((inf), (norm1)))			\
+      abort ();						\
+							\
+    if (!isgreater ((inf), (norm2)))			\
+      abort ();						\
+							\
+    if (!isgreater ((inf), (norm3)))			\
+      abort ();						\
+							\
+    if (!isgreaterequal ((inf), (huge)))		\
+      abort ();						\
+							\
+    if (!isless ((norm1), (inf)))			\
+      abort ();						\
+							\
+    if (!isless ((norm2), (inf)))			\
+      abort ();						\
+							\
+    if (!isless ((norm3), (inf)))			\
+      abort ();						\
+							\
+    if (!islessequal ((huge), (inf)))			\
+      abort ();						\
+  }							\
+							\
+  if (!islessgreater ((inf), (norm1)))			\
     abort ();						\
 							\
-  if (!isgreaterequal ((inf), (huge)))			\
+  if (!islessgreater ((inf), (norm2)))			\
     abort ();						\
 							\
-  if (!isless ((norm), (inf)))				\
+  if (!islessgreater ((inf), (norm3)))			\
     abort ();						\
 							\
-  if (!islessequal ((huge), (inf)))			\
+  if (!isunordered ((nan), (norm1)))			\
     abort ();						\
 							\
-  if (!islessgreater ((inf), (norm)))			\
+  if (!isunordered ((nan), (norm2)))			\
     abort ();						\
 							\
-  if (!isunordered ((nan), (norm)))			\
+  if (!isunordered ((nan), (norm3)))			\
     abort ();						\
+							\
+							\
+  if (fetestexcept (FE_ALL_EXCEPT) != 0)		\
+    abort();						\
 }
diff --git a/gcc/testsuite/gcc.dg/gnu89-init-4.c b/gcc/testsuite/gcc.dg/gnu89-init-4.c
new file mode 100644
index 00000000000..15e9cdb35e6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/gnu89-init-4.c
@@ -0,0 +1,12 @@
+/* Test for GNU extensions to compound literals are giving the correct array bounds */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu89 -W -Wall -O2" } */
+
+int a[] = (int[4]){1, 1, 2};
+int f(void)
+{
+  int sum = 0; int i;
+  for(i = 0;i<4;i++)
+    sum = a[i];
+  return sum;
+}
diff --git a/gcc/testsuite/gcc.dg/inline-17.c b/gcc/testsuite/gcc.dg/inline-17.c
new file mode 100644
index 00000000000..235ad8b001e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/inline-17.c
@@ -0,0 +1,24 @@
+/* Test __attribute__((gnu_inline)).  */
+/* { dg-do compile } */
+/* { dg-options "-std=c99" } */
+/* { dg-final { scan-assembler "func1" } } */
+/* { dg-final { scan-assembler-not "func2" } } */
+/* { dg-final { scan-assembler "func3" } } */
+/* { dg-final { scan-assembler "func4" } } */
+
+#if __STDC_VERSION__ >= 199901L
+# define inline __attribute__((gnu_inline)) inline
+#endif
+
+extern inline int func1 (void) { return 0; }
+inline int func1 (void) { return 1; }
+
+extern int func2 (void);
+extern inline int func2 (void) { return 2; }
+
+inline int func3 (void);
+inline int func3 (void) { return 3; }
+
+extern int func4 (void);
+extern inline int func4 (void) { return 4; }
+int func4 (void) { return 5; }
diff --git a/gcc/testsuite/gcc.dg/inline-18.c b/gcc/testsuite/gcc.dg/inline-18.c
new file mode 100644
index 00000000000..5a37195be94
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/inline-18.c
@@ -0,0 +1,28 @@
+/* Test -fgnu89-extern-inline.  */
+/* { dg-do compile } */
+/* { dg-options "-std=c99 -fgnu89-inline" } */
+/* { dg-final { scan-assembler "func1" } } */
+/* { dg-final { scan-assembler-not "func2" } } */
+/* { dg-final { scan-assembler "func3" } } */
+/* { dg-final { scan-assembler "func4" } } */
+
+#ifndef __GNUC_GNU_INLINE__
+#error __GNUC_GNU_INLINE__ is not defined
+#endif
+
+#ifdef __GNUC_STDC_INLINE__
+#error __GNUC_STDC_INLINE__ is defined
+#endif
+
+extern inline int func1 (void) { return 0; }
+inline int func1 (void) { return 1; }
+
+extern int func2 (void);
+extern inline int func2 (void) { return 2; }
+
+inline int func3 (void);
+inline int func3 (void) { return 3; }
+
+extern int func4 (void);
+extern inline int func4 (void) { return 4; }
+int func4 (void) { return 5; }
diff --git a/gcc/testsuite/gcc.dg/inline-19.c b/gcc/testsuite/gcc.dg/inline-19.c
new file mode 100644
index 00000000000..96dceb43356
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/inline-19.c
@@ -0,0 +1,28 @@
+/* Test -fgnu89-extern-inline.  */
+/* { dg-do compile } */
+/* { dg-options "-fgnu89-inline" } */
+/* { dg-final { scan-assembler "func1" } } */
+/* { dg-final { scan-assembler-not "func2" } } */
+/* { dg-final { scan-assembler "func3" } } */
+/* { dg-final { scan-assembler "func4" } } */
+
+#ifndef __GNUC_GNU_INLINE__
+#error __GNUC_GNU_INLINE__ is not defined
+#endif
+
+#ifdef __GNUC_STDC_INLINE__
+#error __GNUC_STDC_INLINE__ is defined
+#endif
+
+extern inline int func1 (void) { return 0; }
+inline int func1 (void) { return 1; }
+
+extern int func2 (void);
+extern inline int func2 (void) { return 2; }
+
+inline int func3 (void);
+inline int func3 (void) { return 3; }
+
+extern int func4 (void);
+extern inline int func4 (void) { return 4; }
+int func4 (void) { return 5; }
diff --git a/gcc/testsuite/gcc.dg/inline-21.c b/gcc/testsuite/gcc.dg/inline-21.c
new file mode 100644
index 00000000000..8961ce493a8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/inline-21.c
@@ -0,0 +1,4 @@
+/* Test -fno-gnu89-inline.  */
+/* { dg-do compile } */
+/* { dg-options "-fno-gnu89-inline" } */
+/* { dg-error "is not supported" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/inline-7.c b/gcc/testsuite/gcc.dg/inline-7.c
index b239a20461c..508aaa4bf99 100644
--- a/gcc/testsuite/gcc.dg/inline-7.c
+++ b/gcc/testsuite/gcc.dg/inline-7.c
@@ -1,6 +1,6 @@
 /* Test duplicate inline, gnu99 mode.  */
 /* Origin: Joseph Myers <jsm@polyomino.org.uk> */
 /* { dg-do compile } */
-/* { dg-options "-std=gnu99" } */
+/* { dg-options "-std=gnu99 -fgnu89-inline" } */
 
 inline inline void f (void) {}
diff --git a/gcc/testsuite/gcc.dg/nested-func-6.c b/gcc/testsuite/gcc.dg/nested-func-6.c
new file mode 100644
index 00000000000..3bae4db352e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/nested-func-6.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O -Winline" } */
+
+static inline int foo1 (int a)
+{                       /* { dg-bogus "function not inlinable" } */
+  void bar1 (int b)
+  {}
+  return a;
+}
+
+int foo2 (int a)
+{
+  return foo1 (a);
+}
diff --git a/gcc/testsuite/gcc.dg/out-of-bounds-1.c b/gcc/testsuite/gcc.dg/out-of-bounds-1.c
new file mode 100644
index 00000000000..14c4591a40a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/out-of-bounds-1.c
@@ -0,0 +1,13 @@
+/* PR rtl-optimization/33822 */
+/* Origin: Andrew Pinski <pinskia@gcc.gnu.org> */
+
+/* { dg-do compile } */
+/* { dg-options "-O -g" } */
+/* { dg-options "-O -g -mstrict-align" { target powerpc*-*-* } } */
+
+void ProjectOverlay(const float localTextureAxis[2], char *lump)
+{
+   const void *d = &localTextureAxis;
+   int size = sizeof(float)*8 ;
+   __builtin_memcpy( &lump[ 0 ], d, size );  
+}
diff --git a/gcc/testsuite/gcc.dg/pr30045.c b/gcc/testsuite/gcc.dg/pr30045.c
new file mode 100644
index 00000000000..6dd22a1df7a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr30045.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-inline" }  */
+int f(int *a)
+{
+  int  __attribute__((nonnull(1))) g(int *b)
+  {
+    int **c = &a;
+    if (b)
+      return *a + **c;
+    return *b;
+  }
+  if (a)
+    return g(a);
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.dg/pr30189.c b/gcc/testsuite/gcc.dg/pr30189.c
new file mode 100644
index 00000000000..6aa963e7a10
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr30189.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-g -O" } */
+
+extern void foo (void);
+
+static
+void baz (int i)
+{
+  foo ();
+  typedef char A[i];
+  struct { A b; } *x = 0;
+}
+
+void
+bar (i)
+{
+  baz (i);
+}
diff --git a/gcc/testsuite/gcc.dg/pr30473.c b/gcc/testsuite/gcc.dg/pr30473.c
new file mode 100644
index 00000000000..f01c1cc4a7c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr30473.c
@@ -0,0 +1,13 @@
+/* PR middle-end/30473 */
+/* Make sure this doesn't ICE.  */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+extern int sprintf (char *, const char *, ...);
+
+void
+foo (char *buf1, char *buf2)
+{
+  sprintf (buf1, "%s", "abcde");
+  sprintf (buf2, "%s");
+}
diff --git a/gcc/testsuite/gcc.dg/pr30643.c b/gcc/testsuite/gcc.dg/pr30643.c
new file mode 100644
index 00000000000..67fe111a77f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr30643.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-not "undefined" } } */
+
+/* Make sure we optimize all calls away.  */
+
+extern void undefined (void);
+struct s { int a, b; };
+void bar (struct s *ps,  int *p, int *__restrict__ rp, int *__restrict__ rq)
+{
+  ps->a = 0;
+  ps->b = 1;
+  if (ps->a != 0)
+    undefined ();
+  p[0] = 0;
+  p[1] = 1;
+  if (p[0] != 0)
+    undefined ();
+  rp[0] = 0;
+  rq[0] = 1;
+  if (rp[0] != 0)
+    undefined ();
+}
+int main (void) {
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr32450.c b/gcc/testsuite/gcc.dg/pr32450.c
new file mode 100644
index 00000000000..9b36ce42d8b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr32450.c
@@ -0,0 +1,33 @@
+/* Contributed by Joost VandeVondele  <jv244@cam.ac.uk> */
+
+/* { dg-do run } */
+/* { dg-require-profiling "-pg" } */
+/* { dg-options "-O2 -pg" } */
+/* { dg-options "-O2 -pg -static" { target hppa*-*-hpux* } } */
+
+extern void abort (void);
+
+int stack_pointer;
+
+void
+__attribute__((noinline))
+mystop ()
+{
+  abort ();
+}
+
+void
+__attribute__((noinline))
+add ()
+{
+  if (stack_pointer + 1 > 10)
+    mystop ();
+
+  stack_pointer = stack_pointer + 1;
+}
+
+int main ()
+{
+  add ();
+  return stack_pointer - 1;
+}
diff --git a/gcc/testsuite/gcc.dg/pr32912-1.c b/gcc/testsuite/gcc.dg/pr32912-1.c
new file mode 100644
index 00000000000..2f9e8593e29
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr32912-1.c
@@ -0,0 +1,44 @@
+/* PR middle-end/32912 */
+/* { dg-do run } */
+/* { dg-options "-O2 -w" } */
+
+extern void abort (void);
+
+typedef int __m128i __attribute__ ((__vector_size__ (16)));
+
+__m128i a, b, c, d, e, f;
+
+void
+foo (__m128i x)
+{
+  a = x ^ ~x;
+  b = ~x ^ x;
+  c = x | ~x;
+  d = ~x | x;
+  e = x & ~x;
+  f = ~x & x;
+}
+
+int
+main (void)
+{
+  union { __m128i v; int i[sizeof (__m128i) / sizeof (int)]; } u;
+  int i;
+
+  for (i = 0; i < sizeof (u.i) / sizeof (u.i[0]); i++)
+    u.i[i] = i * 49 - 36;
+  foo (u.v);
+#define check(x, val) \
+  u.v = (x); \
+  for (i = 0; i < sizeof (u.i) / sizeof (u.i[0]); i++) \
+    if (u.i[i] != (val)) \
+      abort ()
+
+  check (a, ~0);
+  check (b, ~0);
+  check (c, ~0);
+  check (d, ~0);
+  check (e, 0);
+  check (f, 0);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr32912-2.c b/gcc/testsuite/gcc.dg/pr32912-2.c
new file mode 100644
index 00000000000..3ea81da789c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr32912-2.c
@@ -0,0 +1,45 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -w" } */
+
+extern void abort (void);
+
+typedef int __m128i __attribute__ ((__vector_size__ (16)));
+
+__m128i a, b, c, d, e, f;
+
+__m128i
+foo (void)
+{
+  __m128i x = { 0x11111111, 0x22222222, 0x44444444 };
+  return x;
+}
+
+__m128i
+bar (void)
+{
+  __m128i x = { 0x11111111, 0x22222222, 0x44444444 };
+  return ~x;
+}
+
+int
+main (void)
+{
+  union { __m128i v; int i[sizeof (__m128i) / sizeof (int)]; } u, v;
+  int i;
+
+  u.v = foo ();
+  v.v = bar ();
+  for (i = 0; i < sizeof (u.i) / sizeof (u.i[0]); i++)
+    {
+      if (u.i[i] != ~v.i[i])
+	abort ();
+      if (i < 3)
+	{
+	  if (u.i[i] != (0x11111111 << i))
+	    abort ();
+	}
+      else if (u.i[i])
+	abort ();
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr33826.c b/gcc/testsuite/gcc.dg/pr33826.c
new file mode 100644
index 00000000000..3e08b14fa97
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr33826.c
@@ -0,0 +1,41 @@
+/* Regression test for PR middle-end/33826 */
+/* Verify that recursive functions cannot be pure or const.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target nonpic } */
+/* { dg-options "-O1 -fdump-ipa-pure-const" } */
+
+int recurese1 (int i)
+{
+  return recurse1 (i+1);
+}
+
+int recurse2a (int i)
+{
+  return recurse2b (i+1);
+}
+
+int recurse2b (int i)
+{
+  return recurse2a (i+1);
+}
+
+int norecurse1a (int i)
+{
+  return norecurse1b (i+1);
+}
+
+int norecurse1b (int i)
+{
+  return i+1;
+}
+
+/* { dg-final { scan-ipa-dump "found to be const: norecurse1a" "pure-const" } } */
+/* { dg-final { scan-ipa-dump "found to be const: norecurse1b" "pure-const" } } */
+/* { dg-final { scan-ipa-dump-not "found to be pure: recurse1" "pure-const" } } */
+/* { dg-final { scan-ipa-dump-not "found to be pure: recurse2a" "pure-const" } } */
+/* { dg-final { scan-ipa-dump-not "found to be pure: recurse2b" "pure-const" } } */
+/* { dg-final { scan-ipa-dump-not "found to be const: recurse1" "pure-const" } } */
+/* { dg-final { scan-ipa-dump-not "found to be const: recurse2a" "pure-const" } } */
+/* { dg-final { scan-ipa-dump-not "found to be const: recurse2b" "pure-const" } } */
+/* { dg-final { cleanup-ipa-dump "pure-const" } } */
diff --git a/gcc/testsuite/gcc.dg/pr34003-1.c b/gcc/testsuite/gcc.dg/pr34003-1.c
new file mode 100644
index 00000000000..ff97fe6d23e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr34003-1.c
@@ -0,0 +1,8 @@
+/* PR bootstrap/34003 */
+/* { dg-do link } */
+/* { dg-options "-O0" } */
+/* { dg-additional-sources "pr34003-2.c" } */
+
+extern void foo (void);
+int bar (void) { foo (); return 1; }
+extern void foo (void);
diff --git a/gcc/testsuite/gcc.dg/pr34003-2.c b/gcc/testsuite/gcc.dg/pr34003-2.c
new file mode 100644
index 00000000000..a5330567f50
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr34003-2.c
@@ -0,0 +1,20 @@
+/* PR bootstrap/34003 */
+/* { dg-do compile } */
+/* { dg-options "-O0" } */
+
+extern void abort (void);
+
+int seen = 0;
+
+void foo (void)
+{
+  ++seen;
+}
+
+int main (void)
+{
+  extern int bar (void);
+  if (bar () != 1 || seen != 1)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tf_to_di-1.c b/gcc/testsuite/gcc.dg/tf_to_di-1.c
new file mode 100644
index 00000000000..f4f478a0f7c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tf_to_di-1.c
@@ -0,0 +1,47 @@
+/* { dg-do run { target s390*-*-* } } */
+/* { dg-options "-O0 -mlong-double-128" } */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+void
+check_ll (long double ld, long long ll)
+{
+  if ((long long)ld != ll)
+    {
+      printf ("ld: %Lf expect: %lld result: %lld\n",
+	      ld, ll, (long long)ld);
+      abort ();
+    }
+}
+
+void
+check_ull (long double ld, unsigned long long ull)
+{
+  if ((unsigned long long)ld != ull)
+    {
+      printf ("ld: %Lf expect: %llu result: %llu\n",
+	      ld, ull, (unsigned long long)ld);
+      abort ();
+    }
+}
+
+int
+main ()
+{
+  const long long ll_max = (long long)((1ULL << 63) - 1);
+  const long long ll_min = -ll_max - 1;
+
+  check_ll (206.23253, 206LL);
+  check_ull (206.23253, 206ULL);
+  check_ll ((long double)ll_max, ll_max);
+  check_ull ((long double)ll_max, ll_max);
+  check_ll ((long double)ll_min, ll_min);
+  check_ll (0.0, 0);
+  check_ull (0.0, 0);
+  check_ll (-1.0, -1);
+  check_ll ((long double)0xffffffffffffffffULL, ll_max);
+  check_ull ((long double)0xffffffffffffffffULL, 0xffffffffffffffffULL);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr26998.c b/gcc/testsuite/gcc.dg/torture/pr26998.c
new file mode 100644
index 00000000000..d50c344734e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr26998.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+
+int decCompareOp (int result)
+{
+    if (result != (int)0x80000000)
+    {
+        result = -result;
+        return (result > 0);
+    }
+    return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr29446.c b/gcc/testsuite/gcc.dg/torture/pr29446.c
new file mode 100644
index 00000000000..5571c71e82a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr29446.c
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+
+void f(_Bool D917, int j0, int ubound1, int ubound5)
+{
+  int i, j = j0;
+  int (*abc)[3];
+  i = 1;
+  while (1)
+    {
+       if (j <= 3)
+         while (1)
+           {
+              if (i != j)
+                {
+                  if (ubound1 <= 0)
+                    return;
+                  (*abc)[1] = 0;
+                }
+               else
+                 {
+                    if (j > ubound1)
+                      return;
+                    if (ubound5 <= 0)
+                      return;
+                  }
+               j = j + 1;
+               if (D917)
+                 break;
+           }
+    i = i + 1;
+  }
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr30313.c b/gcc/testsuite/gcc.dg/torture/pr30313.c
new file mode 100644
index 00000000000..1df85f7edc2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr30313.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+
+static inline void bar(){}
+
+struct S
+{
+  signed int i: 32;
+};
+
+int main()
+{
+  struct S x = {32};
+  sizeof(x.i+0);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr30364-1.c b/gcc/testsuite/gcc.dg/torture/pr30364-1.c
new file mode 100644
index 00000000000..09506c21c1c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr30364-1.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+int f(int a, int b)
+{
+  if (a > 0x7FFFFFF0) return 0;
+  if (b > 0x7FFFFFF0) return 0;
+
+  int c = (a - 20) + (b - 20);
+  return c > 0x7FFFFFF0;
+}
+
+int main()
+{
+  if (f (0x7FFFFFF0, 41) != 1)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr30364-2.c b/gcc/testsuite/gcc.dg/torture/pr30364-2.c
new file mode 100644
index 00000000000..20450f55557
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr30364-2.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+int f(unsigned int a, unsigned int b)
+{
+  if (a > 0x7FFFFFF0) return 0;
+  if (b > 0x7FFFFFF0) return 0;
+
+  int c = (a - 20) + (b - 20);
+  return c > 0x7FFFFFF0;
+}
+
+int main()
+{
+  if (f (0x7FFFFFF0, 41) != 1)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr30364-3.c b/gcc/testsuite/gcc.dg/torture/pr30364-3.c
new file mode 100644
index 00000000000..4365679a8e0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr30364-3.c
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+/* { dg-options "-fwrapv" } */
+
+extern void abort (void);
+
+int f(int a, int b)
+{
+  if (a > 0x7FFFFFF0) return 0;
+  if (b > 0x7FFFFFF0) return 0;
+
+  int c = (a - 20) + (b - 20);
+  return c > 0x7FFFFFF0;
+}
+
+int main()
+{
+  if (f (0x7FFFFFF0, 41) != 1)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/20030714-1.c b/gcc/testsuite/gcc.dg/tree-ssa/20030714-1.c
index 34fb26697d3..a48cfdb7596 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/20030714-1.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/20030714-1.c
@@ -34,13 +34,6 @@ find_base_value (src)
 }
 
 
-/* There should be four IF conditionals.  */
-/* { dg-final { scan-tree-dump-times "if " 4 "dom3"} } */
-
 /* There should be no casts to short unsigned int.  */
 /* { dg-final { scan-tree-dump-times "\\(short unsigned int\\)" 0 "dom3"} } */
 
-/* There should be two loads of ->code.  */
-/* { dg-final { scan-tree-dump-times "->code" 2 "dom3"} } */
-
-/* { dg-final { cleanup-tree-dump "dom3" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/andor-1.c b/gcc/testsuite/gcc.dg/tree-ssa/andor-1.c
new file mode 100644
index 00000000000..1a53857401c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/andor-1.c
@@ -0,0 +1,65 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-original" } */
+
+unsigned int test1(unsigned int a)
+{
+  return (a & 1) | 1;
+}
+
+int test2(int b)
+{
+  return (b & 1) | 1;
+}
+
+unsigned int test3(unsigned int c)
+{
+  return (c | 1) & 1;
+}
+
+int test4(int d)
+{
+  return (d | 1) & 1;
+}
+
+unsigned int test5(unsigned int e)
+{
+  return (e | 4) & 6;
+}
+
+int test6(int f)
+{
+  return (f | 4) & 6;
+}
+
+unsigned int test7(unsigned int g)
+{
+  return (g & -2) | 1;
+}
+
+int test8(int h)
+{
+  return (h & -2) | 1;
+}
+
+unsigned int test9(unsigned int i)
+{
+  return (i & 3) | 1;
+}
+
+int test10(int j)
+{
+  return (j & 3) | 1;
+}
+
+/* { dg-final { scan-tree-dump-times "a \& 1 \\| 1" 0 "original" } } */
+/* { dg-final { scan-tree-dump-times "b \& 1 \\| 1" 0 "original" } } */
+/* { dg-final { scan-tree-dump-times "\\(c \\| 1\\) \& 1" 0 "original" } } */
+/* { dg-final { scan-tree-dump-times "\\(d \\| 1\\) \& 1" 0 "original" } } */
+/* { dg-final { scan-tree-dump-times "e \& 2 \\| 4" 1 "original" } } */
+/* { dg-final { scan-tree-dump-times "f \& 2 \\| 4" 1 "original" } } */
+/* { dg-final { scan-tree-dump-times "g \\| 1" 1 "original" } } */
+/* { dg-final { scan-tree-dump-times "h \\| 1" 1 "original" } } */
+/* { dg-final { scan-tree-dump-times "i \& 2 \\| 1" 1 "original" } } */
+/* { dg-final { scan-tree-dump-times "j \& 2 \\| 1" 1 "original" } } */
+/* { dg-final { cleanup-tree-dump "original" } } */
+
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/loop-3.c b/gcc/testsuite/gcc.dg/tree-ssa/loop-3.c
index 82d1d2d73c5..c71791480c6 100644
--- a/gcc/testsuite/gcc.dg/tree-ssa/loop-3.c
+++ b/gcc/testsuite/gcc.dg/tree-ssa/loop-3.c
@@ -3,7 +3,8 @@
    assume something about memory addressing modes.  */
 
 /* { dg-do compile { target i?86-*-* x86_64-*-* } } */
-/* { dg-options "-O1 -fdump-tree-vars" } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-fpic" "-fPIC" } { "" } } */
+/* { dg-options "-O1 -fno-pic -fno-PIC -fdump-tree-vars" } */
 
 int arr_base[100];
 
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr31966.c b/gcc/testsuite/gcc.dg/tree-ssa/pr31966.c
new file mode 100644
index 00000000000..a18f9d041ee
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr31966.c
@@ -0,0 +1,50 @@
+/* Contributed by Jack Lloyd  <lloyd@randombit.net> */
+
+/* { dg-options "-O2 -ftree-vectorize" } */
+/* { dg-options "-O2 -ftree-vectorize -march=nocona" { target { i?86-*-* x86_64-*-* } } } */
+
+typedef unsigned long long word;
+
+const unsigned int MP_WORD_BITS = 64;
+const word MP_WORD_MASK = ~((word)0);
+const word MP_WORD_TOP_BIT = (word)1 << (8*sizeof(word) - 1);
+
+extern void abort (void);
+
+word do_div(word n1, word n0, word d)
+{
+  word high = n1 % d, quotient = 0;
+  unsigned int j;
+
+  for(j = 0; j != MP_WORD_BITS; ++j)
+    {
+      word high_top_bit = (high & MP_WORD_TOP_BIT);
+
+      high <<= 1;
+      high |= (n0 >> (MP_WORD_BITS-1-j)) & 1;
+      quotient <<= 1;
+
+      if(high_top_bit || high >= d)
+	{
+	  high -= d;
+	  quotient |= 1;
+	}
+    }
+
+  return quotient;
+}
+
+int main()
+{
+  word result;
+
+  result = do_div(0x0000000000200000ll,
+		  0x0000000000000000ll,
+		  0x86E53497CE000000ll);
+
+  
+  if (result != 0x3CBA83)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/vrp29.c b/gcc/testsuite/gcc.dg/tree-ssa/vrp29.c
new file mode 100644
index 00000000000..bace4ffcadf
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/vrp29.c
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern void abort(void);
+
+void decCompareOp (int result)
+{
+  if (result != (int)0x80000000)
+    {
+      result = -result;
+      if (result != (int)0x80000001)
+        abort ();
+    }
+}
+
+int main()
+{
+  decCompareOp (0x7fffffff);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/fast-math-vect-pr29925.c b/gcc/testsuite/gcc.dg/vect/fast-math-vect-pr29925.c
new file mode 100644
index 00000000000..caa6a3ca67d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/fast-math-vect-pr29925.c
@@ -0,0 +1,39 @@
+/* { dg-require-effective-target vect_float } */
+
+#include <stdlib.h>
+#include "tree-vect.h"
+
+void interp_pitch(float *exc, float *interp, int pitch, int len)
+{
+   int i,k;
+   int maxj;
+
+   maxj=3;
+   for (i=0;i<len;i++)
+   {
+      float tmp = 0;
+      for (k=0;k<7;k++)
+      {
+         tmp += exc[i-pitch+k+maxj-6];
+      }
+      interp[i] = tmp;
+   }
+}
+
+int main()
+{
+   float *exc = calloc(126,sizeof(float));
+   float *interp = calloc(80,sizeof(float));
+   int pitch = -35;
+
+   check_vect ();
+
+   interp_pitch(exc, interp, pitch, 80);
+   free(exc);
+   free(interp);
+   return 0;
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
+
diff --git a/gcc/testsuite/gcc.dg/vect/vect-106-alias.c b/gcc/testsuite/gcc.dg/vect/vect-106-alias.c
new file mode 100755
index 00000000000..011e7e4c2e7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/vect-106-alias.c
@@ -0,0 +1,51 @@
+/* { dg-require-effective-target vect_int } */
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include "tree-vect.h"
+
+#define N 9
+
+static int a[N] = {1,2,3,4,5,6,7,8,9};
+static int b[N] = {2,3,4,5,6,7,8,9,0};
+
+int main1 () {
+  int i;
+  int *p, *q, *p1, *q1;
+  p = (unsigned int *) malloc (sizeof (unsigned int) * N);
+  q = (unsigned int *) malloc (sizeof (unsigned int) * N);
+
+  p1 = p; q1 = q;
+
+  /* Not vectorizable: because of the redundant cast (caused by ponter
+     arithmetics), alias analysis fails to distinguish between 
+     the pointers.  */
+  for (i = 0; i < N; i++)
+    {
+      *(q + i) = a[i];
+      *(p + i) = b[i];
+    }
+
+  /* check results: */
+  for (i = 0; i < N; i++)
+    {
+       if (*q != a[i] || *p != b[i])
+         abort();
+       q++; 
+       p++;
+    }
+  
+  return 0; 
+}
+
+int main (void)
+{ 
+  check_vect ();
+
+  return main1 ();
+}
+
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" } } */
+/* { dg-final { scan-tree-dump-times "can't determine dependence" 1 "vect" } } */
+/* { dg-final { cleanup-tree-dump "vect" } } */
+
diff --git a/gcc/testsuite/gcc.dg/vect/vect-ifcvt-9.c b/gcc/testsuite/gcc.dg/vect/vect-ifcvt-9.c
index 75941d7f10f..b4a74cf9b44 100644
--- a/gcc/testsuite/gcc.dg/vect/vect-ifcvt-9.c
+++ b/gcc/testsuite/gcc.dg/vect/vect-ifcvt-9.c
@@ -11,7 +11,7 @@ extern void abort(void);
 
 int A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};
 int B[N] = {0,0,42,42,42,0,0,0,0,0,42,42,42,42,42,0};
-void foo ()  __attribute__((always_inline));
+inline void foo ()  __attribute__((always_inline));
 void foo ()
 {  
   int i, j;
diff --git a/gcc/testsuite/gcc.target/arm/stack-corruption.c b/gcc/testsuite/gcc.target/arm/stack-corruption.c
new file mode 100644
index 00000000000..3a63950cc53
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/stack-corruption.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O -mthumb -fno-omit-frame-pointer" } */
+
+int main() {
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not "\tadd\tr7, sp, #8\n" } } */
diff --git a/gcc/testsuite/gcc.target/i386/ordcmp-1.c b/gcc/testsuite/gcc.target/i386/ordcmp-1.c
new file mode 100644
index 00000000000..1a70e19192d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/ordcmp-1.c
@@ -0,0 +1,36 @@
+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-O2 -msse2" } */
+/* { dg-final { scan-assembler "cmpordss" } } */
+/* { dg-final { scan-assembler "cmpordps" } } */
+/* { dg-final { scan-assembler "cmpordsd" } } */
+/* { dg-final { scan-assembler "cmpordpd" } } */
+/* { dg-final { scan-assembler-not "cmpunordss" } } */
+/* { dg-final { scan-assembler-not "cmpunordps" } } */
+/* { dg-final { scan-assembler-not "cmpunordsd" } } */
+/* { dg-final { scan-assembler-not "cmpunordpd" } } */
+
+#include <emmintrin.h>
+
+__m128
+f1 (__m128 x, __m128 y)
+{
+  return _mm_cmpord_ss (x, y);
+}
+
+__m128
+f2 (__m128 x, __m128 y)
+{
+  return _mm_cmpord_ps (x, y);
+}
+
+__m128d
+f3 (__m128d x, __m128d y)
+{
+  return _mm_cmpord_sd (x, y);
+}
+
+__m128d
+f4 (__m128d x, __m128d y)
+{
+  return _mm_cmpord_pd (x, y);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr21291.c b/gcc/testsuite/gcc.target/i386/pr21291.c
index acfc43df67f..f7348bdf6e1 100644
--- a/gcc/testsuite/gcc.target/i386/pr21291.c
+++ b/gcc/testsuite/gcc.target/i386/pr21291.c
@@ -1,4 +1,9 @@
-/* { dg-do compile } */
+/* The asm has 2 "r" in/out operands, 1 earlyclobber "r" output, 1 "r"
+   input and 2 fixed "r" clobbers (eax and edx), so there are a total of
+   6 registers that must not conflict.  Add to that the PIC register,
+   the frame pointer, and the stack pointer, and we've run out of
+   registers on 32-bit targets.  */
+/* { dg-do compile { target { { ! ilp32 } || nonpic } } } */
 /* { dg-options "-O" } */
 
 typedef unsigned long bngdigit;
diff --git a/gcc/testsuite/gcc.target/i386/pr30848.c b/gcc/testsuite/gcc.target/i386/pr30848.c
new file mode 100644
index 00000000000..2a92851516c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr30848.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+
+void foo(double d)
+{
+  __asm__ ("" : "=u" (d));  /* { dg-error "output regs" } */
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr32389.c b/gcc/testsuite/gcc.target/i386/pr32389.c
new file mode 100644
index 00000000000..3f4cb3e6228
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr32389.c
@@ -0,0 +1,10 @@
+/* Testcase by Mike Frysinger <vapier@gentoo.org>  */
+
+/* { dg-do compile { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */
+/* { dg-options "-msse" } */
+
+double f1();
+int f2() {
+  __builtin_ia32_stmxcsr();
+  return f1();
+}
diff --git a/gcc/testsuite/gcc.target/i386/unordcmp-1.c b/gcc/testsuite/gcc.target/i386/unordcmp-1.c
new file mode 100644
index 00000000000..3123fe9ada2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/unordcmp-1.c
@@ -0,0 +1,36 @@
+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-O2 -msse2" } */
+/* { dg-final { scan-assembler "cmpunordss" } } */
+/* { dg-final { scan-assembler "cmpunordps" } } */
+/* { dg-final { scan-assembler "cmpunordsd" } } */
+/* { dg-final { scan-assembler "cmpunordpd" } } */
+/* { dg-final { scan-assembler-not "cmpordss" } } */
+/* { dg-final { scan-assembler-not "cmpordps" } } */
+/* { dg-final { scan-assembler-not "cmpordsd" } } */
+/* { dg-final { scan-assembler-not "cmpordpd" } } */
+
+#include <emmintrin.h>
+
+__m128
+f1 (__m128 x, __m128 y)
+{
+  return _mm_cmpunord_ss (x, y);
+}
+
+__m128
+f2 (__m128 x, __m128 y)
+{
+  return _mm_cmpunord_ps (x, y);
+}
+
+__m128d
+f3 (__m128d x, __m128d y)
+{
+  return _mm_cmpunord_sd (x, y);
+}
+
+__m128d
+f4 (__m128d x, __m128d y)
+{
+  return _mm_cmpunord_pd (x, y);
+}
diff --git a/gcc/testsuite/gcc.target/mips/mips.exp b/gcc/testsuite/gcc.target/mips/mips.exp
index d88a867db1b..a00f7b6631d 100644
--- a/gcc/testsuite/gcc.target/mips/mips.exp
+++ b/gcc/testsuite/gcc.target/mips/mips.exp
@@ -37,6 +37,7 @@ load_lib gcc-dg.exp
 #    $mips_forced_isa:	 true if the command line uses -march=* or -mips*
 #    $mips_forced_abi:	 true if the command line uses -mabi=* or -mgp*
 #    $mips_forced_float: true if the command line uses -mhard/soft-float
+#    $mips_forced_le	 true if the command line uses -EL or -mel
 proc setup_mips_tests {} {
     global mips_isa
     global mips_arch
@@ -47,6 +48,7 @@ proc setup_mips_tests {} {
     global mips_forced_isa
     global mips_forced_abi
     global mips_forced_float
+    global mips_forced_le
 
     global compiler_flags
     global tool
@@ -81,6 +83,7 @@ proc setup_mips_tests {} {
     set mips_forced_isa [regexp -- {(-mips|-march)} $compiler_flags]
     set mips_forced_abi [regexp -- {(-mgp|-mabi)} $compiler_flags]
     set mips_forced_float [regexp -- {-m(hard|soft)-float} $compiler_flags]
+    set mips_forced_le [regexp -- {-(EL|mel)[[:>:]]} $compiler_flags]
 }
 
 # Return true if command-line option FLAG forces 32-bit code.
@@ -116,6 +119,10 @@ proc is_gp32_flag {flag} {
 #    -mhard-float
 #	Select the given floating-point mode.  Skip the test if the
 #	multilib flags force a different selection.
+#
+#    -EB
+#	Select big-endian code.  Skip the test if the multilib flags
+#	force a little-endian target.
 proc dg-mips-options {args} {
     upvar dg-extra-tool-flags extra_tool_flags
     upvar dg-do-what do_what
@@ -129,6 +136,7 @@ proc dg-mips-options {args} {
     global mips_forced_isa
     global mips_forced_abi
     global mips_forced_float
+    global mips_forced_le
 
     set flags [lindex $args 1]
     set matches 1
@@ -170,6 +178,10 @@ proc dg-mips-options {args} {
 	    if {$mips_float != $float && $mips_forced_float} {
 		set matches 0
 	    }
+	} elseif {[regexp -- {^-(EB|meb)$} $flag]} {
+	    if {$mips_forced_le} {
+		set matches 0
+	    }
 	}
     }
     if {$matches} {
diff --git a/gcc/testsuite/gcc.target/mips/pr33256.c b/gcc/testsuite/gcc.target/mips/pr33256.c
new file mode 100644
index 00000000000..d5db110fba5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/mips/pr33256.c
@@ -0,0 +1,11 @@
+/* GCC used to report an ICE for this test because we generated a LO_SUM
+   for an illegitimate constant.  */
+/* { dg-mips-options "-mabi=64 -mips3 -msym32 -O2 -EB -mno-abicalls" } */
+extern unsigned long a[];
+int b (int);
+
+int
+c (void)
+{
+  return b (a[0]);
+}
diff --git a/gcc/testsuite/gcc.target/sparc/align.c b/gcc/testsuite/gcc.target/sparc/align.c
index d9cc162e828..804ca9397f3 100644
--- a/gcc/testsuite/gcc.target/sparc/align.c
+++ b/gcc/testsuite/gcc.target/sparc/align.c
@@ -1,10 +1,9 @@
 /* { dg-do compile } */
 /* { dg-options "-mcpu=ultrasparc -mvis" } */
-
 typedef long long int64_t;
 typedef int vec32 __attribute__((vector_size(8)));
 typedef short vec16 __attribute__((vector_size(8)));
-typedef char vec8 __attribute__((vector_size(8)));
+typedef unsigned char vec8 __attribute__((vector_size(8)));
 
 vec16 foo1 (vec16 a, vec16 b) {
   return __builtin_vis_faligndatav4hi (a, b);
diff --git a/gcc/testsuite/gcc.target/sparc/combined-2.c b/gcc/testsuite/gcc.target/sparc/combined-2.c
index 016e4fa6a6c..c4b70a55a2d 100644
--- a/gcc/testsuite/gcc.target/sparc/combined-2.c
+++ b/gcc/testsuite/gcc.target/sparc/combined-2.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -mcpu=ultrasparc -mvis" } */
-typedef char pixel __attribute__((vector_size(4)));
-typedef char vec8 __attribute__((vector_size(8)));
+typedef unsigned char pixel __attribute__((vector_size(4)));
+typedef unsigned char vec8 __attribute__((vector_size(8)));
 typedef short vec16 __attribute__((vector_size(8)));
 
 vec16 foo (pixel a, pixel b) {
diff --git a/gcc/testsuite/gcc.target/sparc/fexpand.c b/gcc/testsuite/gcc.target/sparc/fexpand.c
index 2483f4f7235..21aeafff0b1 100644
--- a/gcc/testsuite/gcc.target/sparc/fexpand.c
+++ b/gcc/testsuite/gcc.target/sparc/fexpand.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-mcpu=ultrasparc -mvis" } */
 typedef short vec16 __attribute__((vector_size(8)));
-typedef char vec8 __attribute__((vector_size(4)));
+typedef unsigned char vec8 __attribute__((vector_size(4)));
 
 vec16 foo (vec8 a) {
   return __builtin_vis_fexpand (a);
diff --git a/gcc/testsuite/gcc.target/sparc/fnot.c b/gcc/testsuite/gcc.target/sparc/fnot.c
index e6f98d412a6..dceee52f7da 100644
--- a/gcc/testsuite/gcc.target/sparc/fnot.c
+++ b/gcc/testsuite/gcc.target/sparc/fnot.c
@@ -1,8 +1,8 @@
 /* { dg-do compile } */
 /* { dg-options "-O -mcpu=ultrasparc -mvis" } */
-typedef char  vec8 __attribute__((vector_size(8)));
+typedef unsigned char vec8 __attribute__((vector_size(8)));
 typedef short vec16 __attribute__((vector_size(8)));
-typedef int   vec32 __attribute__((vector_size(8)));
+typedef int vec32 __attribute__((vector_size(8)));
 
 extern vec8 foo1_8(void);
 extern void foo2_8(vec8);
@@ -21,7 +21,7 @@ vec8 fun8_2(vec8 a)
 #endif
 
 extern vec16 foo1_16(void);
-extern void foo2_16(vec8);
+extern void foo2_16(vec16);
 
 
 vec16 fun16(void)
@@ -38,7 +38,7 @@ vec16 fun16_2(vec16 a)
 #endif
 
 extern vec32 foo1_32(void);
-extern void foo2_32(vec8);
+extern void foo2_32(vec32);
 
 vec32 fun32(void)
 {
diff --git a/gcc/testsuite/gcc.target/sparc/fpack16.c b/gcc/testsuite/gcc.target/sparc/fpack16.c
index 2f7aac56171..79e0c4c1577 100644
--- a/gcc/testsuite/gcc.target/sparc/fpack16.c
+++ b/gcc/testsuite/gcc.target/sparc/fpack16.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-mcpu=ultrasparc -mvis" } */
 typedef short vec16 __attribute__((vector_size(8)));
-typedef char vec8 __attribute__((vector_size(4)));
+typedef unsigned char vec8 __attribute__((vector_size(4)));
 
 vec8 foo (vec16 a) {
   return __builtin_vis_fpack16 (a);
diff --git a/gcc/testsuite/gcc.target/sparc/fpmerge.c b/gcc/testsuite/gcc.target/sparc/fpmerge.c
index 013795cc6d7..4d6a9c02382 100644
--- a/gcc/testsuite/gcc.target/sparc/fpmerge.c
+++ b/gcc/testsuite/gcc.target/sparc/fpmerge.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-mcpu=ultrasparc -mvis" } */
-typedef char pixel __attribute__((vector_size(8)));
-typedef char vec8 __attribute__((vector_size(4)));
+typedef unsigned char pixel __attribute__((vector_size(8)));
+typedef unsigned char vec8 __attribute__((vector_size(4)));
 
 pixel foo (vec8 a, vec8 b) {
   return __builtin_vis_fpmerge (a, b);
diff --git a/gcc/testsuite/gcc.target/sparc/fpmul.c b/gcc/testsuite/gcc.target/sparc/fpmul.c
index 991cc75d661..71b3b17ac57 100644
--- a/gcc/testsuite/gcc.target/sparc/fpmul.c
+++ b/gcc/testsuite/gcc.target/sparc/fpmul.c
@@ -2,9 +2,9 @@
 /* { dg-options "-mcpu=ultrasparc -mvis" } */
 typedef int vec32 __attribute__((vector_size(8)));
 typedef short vec16 __attribute__((vector_size(8)));
-typedef char pixel __attribute__((vector_size(4)));
+typedef unsigned char pixel __attribute__((vector_size(4)));
 typedef short pixel16 __attribute__((vector_size(4)));
-typedef char vec8 __attribute__((vector_size(8)));
+typedef unsigned char vec8 __attribute__((vector_size(8)));
 
 vec16 foo1 (pixel a, vec16 b) {
   return __builtin_vis_fmul8x16 (a, b);
diff --git a/gcc/testsuite/gcc.target/sparc/mfpu.c b/gcc/testsuite/gcc.target/sparc/mfpu.c
new file mode 100644
index 00000000000..e95754c5d6b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/mfpu.c
@@ -0,0 +1,11 @@
+/* Reported by Peter A. Krauss <peter.a.krauss@web.de> */
+
+/* { dg-do compile } */
+/* { dg-options "-mfpu" } */
+
+float square(float x)
+{
+  return x * x;
+}
+
+/* { dg-final { scan-assembler "fmuls" } } */
diff --git a/gcc/testsuite/gcc.target/sparc/noresult.c b/gcc/testsuite/gcc.target/sparc/noresult.c
index f32805d3547..1be7458d2be 100644
--- a/gcc/testsuite/gcc.target/sparc/noresult.c
+++ b/gcc/testsuite/gcc.target/sparc/noresult.c
@@ -1,7 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mcpu=ultrasparc -mvis" } */
 typedef short vec16 __attribute__((vector_size(8)));
-typedef char vec8 __attribute__((vector_size(4)));
 
 void foo (vec16 a) {
   __builtin_vis_fpack16 (a);
diff --git a/gcc/testsuite/gcc.target/sparc/pdist.c b/gcc/testsuite/gcc.target/sparc/pdist.c
index 48ca0dbf139..6ecc20aa178 100644
--- a/gcc/testsuite/gcc.target/sparc/pdist.c
+++ b/gcc/testsuite/gcc.target/sparc/pdist.c
@@ -1,8 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-mcpu=ultrasparc -mvis" } */
-
 typedef long long int64_t;
-typedef char vec8 __attribute__((vector_size(8)));
+typedef unsigned char vec8 __attribute__((vector_size(8)));
 
 int64_t foo (vec8 a, vec8 b) {
   int64_t d = 0;
diff --git a/gcc/testsuite/gfortran.dg/enum_4.f90 b/gcc/testsuite/gfortran.dg/enum_4.f90
index 99acda0c818..be506b400db 100644
--- a/gcc/testsuite/gfortran.dg/enum_4.f90
+++ b/gcc/testsuite/gfortran.dg/enum_4.f90
@@ -5,12 +5,12 @@ program main
   implicit none
   enum, bind (c)
     enumerator :: red, black = 2     
-    enumerator :: blue = 1, red  ! { dg-error "already" }
+    enumerator :: blue = 1, red  ! { dg-error "already has basic type" }
   end enum
 
   enum, bind (c)
-    enumerator :: r, b(10) = 2  ! { dg-error "cannot be array" }
-    enumerator , save :: g = 1  ! { dg-error "cannot have attributes" }  
+    enumerator :: r, b(10) = 2  ! { dg-error "Syntax error" }
+    enumerator , save :: g = 1  ! { dg-error "Syntax error" }  
   end  ! { dg-error " END ENUM" } 
 
 end program main  ! { dg-excess-errors "" }
diff --git a/gcc/testsuite/gfortran.dg/f2c_8.f90 b/gcc/testsuite/gfortran.dg/f2c_8.f90
new file mode 100644
index 00000000000..03baa36be53
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/f2c_8.f90
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! { dg-options "-ff2c" }
+! PR 25392
+! Verify that the type of the result variable matches the declared
+! type of the function.  The actual type of the function may be
+! different for f2c calling conventions.
+real function goo () result (foo)
+  real x
+  foo = sign(foo, x)
+end
+
+real function foo ()
+  real x
+  foo = sign(foo, x)
+end
+
diff --git a/gcc/testsuite/gfortran.dg/fmt_zero_precision.f90 b/gcc/testsuite/gfortran.dg/fmt_zero_precision.f90
new file mode 100644
index 00000000000..6ecd499b68c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/fmt_zero_precision.f90
@@ -0,0 +1,85 @@
+! { dg-do run }
+! PR28354 Incorrect rounding of .99999 with f3.0 format specifier
+! PR30910 ES format not quite right...
+! Test case derived from PR. Submitted by Jerry DeLisle <jvdelisle@gcc.gnu.org>
+  write(*,50) -0.99999
+  write(*,50) 0.99999
+  write(*,50) -9.0
+  write(*,50) -0.99
+  write(*,50) -0.999
+  write(*,50) -0.999
+  write(*,50) -0.59
+  write(*,50) -0.49
+  write(*,100) 37.99999
+  write(*,100) 10345.0
+  write(*,100) 333.678
+  write(*,100) 333.499
+  50   format(f3.0,"<")
+ 100   format(f8.0,"<")
+  write(6,'(es6.0)') 1.0e-1
+  write(*,150) -0.99999
+  write(*,150) 0.99999
+  write(*,150) -9.0
+  write(*,150) -0.99
+  write(*,150) -0.999
+  write(*,150) -0.999
+  write(*,150) -0.59
+  write(*,150) -0.49
+  write(*,200) 37.99999
+  write(*,200) 10345.0
+  write(*,200) 333.678
+  write(*,200) 333.499
+ 150   format(es7.0,"<")
+ 200   format(es8.0,"<")
+  write(*,250) -0.99999
+  write(*,250) 0.99999
+  write(*,250) -9.0
+  write(*,250) -0.99
+  write(*,250) -0.999
+  write(*,250) -0.999
+  write(*,250) -0.59
+  write(*,250) -0.49
+  write(*,300) 37.99999
+  write(*,300) 10345.0
+  write(*,300) 333.678
+  write(*,300) 333.499
+ 250   format(1pe7.0,"<")
+ 300   format(1pe6.0,"<")
+  end
+! {dg-output "-1.<"
+! {dg-output " 1.<"
+! {dg-output "-9.<"
+! {dg-output "-1.<"
+! {dg-output "-1.<"
+! {dg-output "-1.<"
+! {dg-output "-1.<"
+! {dg-output " 0.<"
+! {dg-output "     38.<"
+! {dg-output "  10345.<"
+! {dg-output "    334.<"
+! {dg-output "    333.<"
+! {dg-output "1.E-01"
+! {dg-output "-1.E+00<"
+! {dg-output " 1.E+00<"
+! {dg-output "-9.E+00<"
+! {dg-output "-1.E+00<"
+! {dg-output "-1.E+00<"
+! {dg-output "-1.E+00<"
+! {dg-output "-6.E-01<"
+! {dg-output "-5.E-01<"
+! {dg-output "  4.E+01<"
+! {dg-output "  1.E+04<"
+! {dg-output "  3.E+02<"
+! {dg-output "  3.E+02<"
+! {dg-output "-1.E+00<"
+! {dg-output " 1.E+00<"
+! {dg-output "-9.E+00<"
+! {dg-output "-1.E+00<"
+! {dg-output "-1.E+00<"
+! {dg-output "-1.E+00<"
+! {dg-output "-6.E-01<"
+! {dg-output "-5.E-01<"
+! {dg-output "4.E+01<"
+! {dg-output "1.E+04<"
+! {dg-output "3.E+02<"
+! {dg-output "3.E+02<"
diff --git a/gcc/testsuite/gfortran.dg/forall_10.f90 b/gcc/testsuite/gfortran.dg/forall_10.f90
new file mode 100644
index 00000000000..1b16840e643
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/forall_10.f90
@@ -0,0 +1,25 @@
+! { dg-do run }
+! { dg-options "-O" }
+! Tests the fix for PR30400, in which the use of ANY in the
+! FORALL mask was rejected.
+!
+! Contributed by Dominique d'Humieres <dominiq@lps.ens.fr>
+!
+program pr30400_1
+  real, dimension (5, 5, 5, 5) :: a
+
+  a (:, :, :,  :)  = 4
+  a (:, 2, :, 4) = 10
+  a (:, 2, :, 1) = 0
+
+  forall (i = 1:5, j = 1:5, k = 1:5, any (a (i, j, k,  :)  .gt. 6))
+    forall (l = 1:5, any (a (:, :, :, l) .lt. 2))
+      a (i, j, k, l) = i - j + k - l
+    end forall
+  end forall
+  if (sum (a) .ne. 2625.0) call abort ()
+
+ ! Check that the fix has not broken the treatment of the '=='
+  forall (i = 1:5, i == 3) a(i, i, i, i) = -5
+  if (sum (a) .ne. 2616.0) call abort ()
+end
diff --git a/gcc/testsuite/gfortran.dg/initialization_4.f90 b/gcc/testsuite/gfortran.dg/initialization_4.f90
new file mode 100644
index 00000000000..b0f24311bdb
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/initialization_4.f90
@@ -0,0 +1,6 @@
+! PR 29441 : No error was given for disallowed function in
+! initialization expression, even if -std=f95 was used
+! { dg-do compile }
+! { dg-options "-std=f95" }
+real, parameter :: pi = 4.0*Atan(1.0) ! { dg-error "Evaluation of nonstandard initialization expression" }
+end
diff --git a/gcc/testsuite/gfortran.dg/logical_2.f90 b/gcc/testsuite/gfortran.dg/logical_2.f90
new file mode 100644
index 00000000000..1a28fefd50c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/logical_2.f90
@@ -0,0 +1,26 @@
+! { dg-do compile }
+! PR fortran/30799
+! Inconsistent handling of bad (invalid) LOGICAL kinds
+! Reporter: Harald Anlauf <anlauf@gmx.de>
+! Testcase altered by Steven G. Kargl
+program gfcbug57
+  implicit none
+  !
+  ! These are logical kinds known by gfortran and many other compilers:
+  !
+  print *, kind (.true._1) ! This prints "1"
+  print *, kind (.true._2) ! This prints "2"
+  print *, kind (.true._4) ! This prints "4"
+  print *, kind (.true._8) ! This prints "8"
+  !
+  ! These are very strange (read: bad (invalid?)) logical kinds,
+  ! handled inconsistently by gfortran (there's no logical(kind=0) etc.)
+  !
+  print *, kind (.true._0)   ! { dg-error "kind for logical constant" }
+  print *, kind (.true._3)   ! { dg-error "kind for logical constant" }
+  print *, kind (.true._123) ! { dg-error "kind for logical constant" }
+  !
+  ! Here gfortran bails out with a runtime error:
+  !
+  print *, .true._3   ! { dg-error "kind for logical constant" }
+end program gfcbug57
diff --git a/gcc/testsuite/gfortran.dg/module_implicit_conversion.f90 b/gcc/testsuite/gfortran.dg/module_implicit_conversion.f90
new file mode 100644
index 00000000000..d7835a7f961
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/module_implicit_conversion.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+
+module module_implicit_conversion
+  ! double complex :: s = (1.0D0, 0D0) 
+  double complex :: s = (1.0, 0D0)
+end module module_implicit_conversion
+
+! { dg-final { cleanup-modules "module_implicit_conversion" } }
diff --git a/gcc/testsuite/gfortran.dg/namelist_26.f90 b/gcc/testsuite/gfortran.dg/namelist_26.f90
new file mode 100644
index 00000000000..2c1b26062e1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/namelist_26.f90
@@ -0,0 +1,48 @@
+! { dg-do run }
+! PR30918 Failure to skip commented out NAMELIST
+! Before the patch, this read the commented out namelist and iuse would
+! equal 2 when done.  Test case from PR.
+program gfcbug58
+  implicit none
+  integer            :: iuse = 0, ios
+  integer, parameter :: nmlunit = 10    ! Namelist unit
+  !------------------
+  ! Namelist 'REPORT'
+  !------------------
+  character(len=12) :: type, use
+  integer           :: max_proc
+  namelist /REPORT/ type, use, max_proc
+  !------------------
+  ! Set up the test file
+  !------------------
+  open(unit=nmlunit, status="scratch")
+  write(nmlunit, '(a)') "!================"
+  write(nmlunit, '(a)') "! Namelist REPORT"
+  write(nmlunit, '(a)') "!================"
+  write(nmlunit, '(a)') "!      &REPORT use      = 'ignore'   / ! Comment"
+  write(nmlunit, '(a)') "!"
+  write(nmlunit, '(a)') " &REPORT type     = 'SYNOP'"
+  write(nmlunit, '(a)') "         use      = 'active'"
+  write(nmlunit, '(a)') "         max_proc = 20"
+  write(nmlunit, '(a)') " /"
+  rewind(nmlunit)
+  !-------------------------------------
+  ! Loop to read namelist multiple times
+  !-------------------------------------
+  do
+     !----------------------------------------
+     ! Preset namelist variables with defaults
+     !----------------------------------------
+     type      = ''
+     use       = ''
+     max_proc  = -1
+     !--------------
+     ! Read namelist
+     !--------------
+     read (nmlunit, nml=REPORT, iostat=ios)
+     if (ios /= 0) exit
+     iuse = iuse + 1
+  end do
+  if (iuse /= 1) call abort()
+
+end program gfcbug58
diff --git a/gcc/testsuite/gfortran.dg/pr32533.f90 b/gcc/testsuite/gfortran.dg/pr32533.f90
new file mode 100644
index 00000000000..c312415eb02
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr32533.f90
@@ -0,0 +1,18 @@
+! { dg-do run }
+! { dg-options "-O2 -ftree-vectorize -ffast-math" }
+!
+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>
+!
+SUBROUTINE T(nsubcell,sab_max,subcells)
+  INTEGER, PARAMETER :: dp=KIND(0.0D0)
+  REAL(dp) :: sab_max(3), subcells,nsubcell(3)
+  nsubcell(:) = MIN(MAX(1,NINT(0.5_dp*subcells/sab_max(:))),20)
+END SUBROUTINE T
+
+INTEGER, PARAMETER :: dp=KIND(0.0D0)
+REAL(dp) :: sab_max(3), subcells,nsubcell(3)
+subcells=2.0_dp
+sab_max=0.590060749244805_dp
+CALL T(nsubcell,sab_max,subcells)
+IF (ANY(nsubcell.NE.2.0_dp)) CALL ABORT()
+END
diff --git a/gcc/testsuite/gfortran.dg/unf_read_corrupted_2.f90 b/gcc/testsuite/gfortran.dg/unf_read_corrupted_2.f90
new file mode 100644
index 00000000000..1788b457d19
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/unf_read_corrupted_2.f90
@@ -0,0 +1,27 @@
+! { dg-do run }
+! PR31880 silent data corruption in gfortran read statement
+! Test from PR.
+      program r3
+
+      integer(kind=4) :: a(1025),b(1025),c(1025),d(2048),e(1022)
+      
+      a = 5
+      b = 6
+      c = 7
+      e = 8
+
+      do i=1,2048
+         d(i)=i
+      end do
+
+      open  (3,form='unformatted', status="scratch")
+      write (3) a,b,c,d,e
+      rewind 3
+      d = 0
+      read  (3) a,b,c,d
+      close (3)
+
+      if (d(1).ne.1) call abort
+      if (d(2048).ne.2048) call abort
+
+      end
diff --git a/gcc/testsuite/gfortran.dg/vect/vect-2.f90 b/gcc/testsuite/gfortran.dg/vect/vect-2.f90
index a881d9726d3..c7f0ad07c53 100644
--- a/gcc/testsuite/gfortran.dg/vect/vect-2.f90
+++ b/gcc/testsuite/gfortran.dg/vect/vect-2.f90
@@ -14,9 +14,7 @@ END
 ! support unaligned loads) or using peeling to align the store (on targets that 
 ! support unaligned loads).
 
-! { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" } }
-! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 3 "vect" { xfail vect_no_align } } }
-! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { target vect_no_align } } }
-! { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 2 "vect" { xfail vect_no_align } } }
-! { dg-final { scan-tree-dump-times "Alignment of access forced using versioning." 3 "vect" {target vect_no_align } } }
+! { dg-final { scan-tree-dump-times "vectorized 3 loops" 1 "vect" { xfail *-*-* } } }
+! { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" } }
+! { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect"  } }
 ! { dg-final { cleanup-tree-dump "vect" } }
diff --git a/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_bitops.f90 b/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_bitops.f90
index 95ff44c999e..7dcda255b96 100644
--- a/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_bitops.f90
+++ b/gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_bitops.f90
@@ -8,7 +8,8 @@ program intrinsic_bitops
    i = 2
    j = 3
    k = 12
-
+   a = 5
+   
    if (.not. btest (i, o+1)) call abort
    if (btest (i, o+2)) call abort
    if (iand (i, j) .ne. 2) call abort
@@ -26,4 +27,6 @@ program intrinsic_bitops
    if (ishftc (k, o-30) .ne. 48) call abort
    if (ishftc (k, o+1, o+3) .ne. 9) call abort
    if (not (i) .ne. -3) call abort
+   if (ishftc (a, 1, bit_size(a)) .ne. 10) call abort
+   if (ishftc (1, 1, 32) .ne. 2) call abort
 end program
diff --git a/gcc/testsuite/lib/g++.exp b/gcc/testsuite/lib/g++.exp
index 69635fb5541..6d60878c14e 100644
--- a/gcc/testsuite/lib/g++.exp
+++ b/gcc/testsuite/lib/g++.exp
@@ -221,7 +221,7 @@ proc g++_init { args } {
 	unset gluefile
     }
 
-    g++_maybe_build_wrapper "${tmpdir}/g++-testglue.o"
+    g++_maybe_build_wrapper "${tmpdir}/g++-testglue.o" "-fexceptions"
 
     if {![info exists CXXFLAGS]} {
 	set CXXFLAGS ""
diff --git a/gcc/testsuite/lib/obj-c++.exp b/gcc/testsuite/lib/obj-c++.exp
index d5ddda7c076..96bd60ad401 100644
--- a/gcc/testsuite/lib/obj-c++.exp
+++ b/gcc/testsuite/lib/obj-c++.exp
@@ -239,7 +239,7 @@ proc obj-c++_init { args } {
 	unset gluefile
     }
 
-    obj-c++_maybe_build_wrapper "${tmpdir}/obj-c++-testglue.o"
+    obj-c++_maybe_build_wrapper "${tmpdir}/obj-c++-testglue.o" "-fexceptions"
 
     set ALWAYS_OBJCXXFLAGS ""
 
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index 01120ab6bdf..c473826b00c 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -490,6 +490,16 @@ proc check_effective_target_fpic { } {
     return 0
 }
 
+# Return 1 if the current multilib does not generate PIC by default.
+
+proc check_effective_target_nonpic { } {
+    return [check_no_compiler_messages nonpic assembly {
+	#if __PIC__ || __pic__
+	#error FOO
+	#endif
+    }]
+}
+
 # Return true if iconv is supported on the target. In particular IBM1047.
 
 proc check_iconv_available { test_what } {
diff --git a/gcc/testsuite/lib/wrapper.exp b/gcc/testsuite/lib/wrapper.exp
index 48c31e68ebe..b50c447c01e 100644
--- a/gcc/testsuite/lib/wrapper.exp
+++ b/gcc/testsuite/lib/wrapper.exp
@@ -18,18 +18,20 @@
 
 # ${tool}_maybe_build_wrapper -- Build wrapper object if the target needs it.
 
-proc ${tool}_maybe_build_wrapper { filename } {
+proc ${tool}_maybe_build_wrapper { filename args } {
     global gluefile wrap_flags
 
     if { [target_info needs_status_wrapper] != "" \
  	 && [target_info needs_status_wrapper] != "0" \
 	 && ![info exists gluefile] } {
 	set saved_wrap_compile_flags [target_info wrap_compile_flags]
+	set flags [join $args " "]
 	# The wrapper code may contain code that gcc objects on.  This
 	# became true for dejagnu-1.4.4.  The set of warnings and code
 	# that gcc objects on may change, so just make sure -w is always
 	# passed to turn off all warnings.
-	set_currtarget_info wrap_compile_flags "$saved_wrap_compile_flags -w"
+	set_currtarget_info wrap_compile_flags \
+	    "$saved_wrap_compile_flags -w $flags"
 	set result [build_wrapper $filename]
 	set_currtarget_info wrap_compile_flags "$saved_wrap_compile_flags"
 	if { $result != "" } {
diff --git a/gcc/testsuite/obj-c++.dg/bitfield-1.mm b/gcc/testsuite/obj-c++.dg/bitfield-1.mm
index c7920251d06..8633b854db7 100644
--- a/gcc/testsuite/obj-c++.dg/bitfield-1.mm
+++ b/gcc/testsuite/obj-c++.dg/bitfield-1.mm
@@ -111,3 +111,13 @@ int main(void)
   
   return 0;
 }
+
+/* { dg-bogus "included from <built-in>" "PR23610" { xfail lp64 } 0 } */
+/* { dg-bogus "padding struct to align" "PR23610" { xfail lp64 } 0 } */
+
+/* { dg-bogus "padding struct size" "PR23610" { xfail lp64 } 40 } */
+/* { dg-bogus "padding struct size" "PR23610" { xfail lp64 } 43 } */
+/* { dg-bogus "padding struct size" "PR23610" { xfail lp64 } 57 } */
+/* { dg-bogus "padding struct size" "PR23610" { xfail lp64 } 60 } */
+/* { dg-bogus "padding struct size" "PR23610" { xfail lp64 } 75 } */
+/* { dg-bogus "padding struct size" "PR23610" { xfail lp64 } 76 } */
diff --git a/gcc/testsuite/obj-c++.dg/bitfield-4.mm b/gcc/testsuite/obj-c++.dg/bitfield-4.mm
index d7617bf106c..ef336f44834 100644
--- a/gcc/testsuite/obj-c++.dg/bitfield-4.mm
+++ b/gcc/testsuite/obj-c++.dg/bitfield-4.mm
@@ -48,3 +48,9 @@ int main(void)
 
   return 0;
 }
+
+/* { dg-bogus "included from <built-in>" "PR23610" { xfail lp64 } 0 } */
+/* { dg-bogus "padding struct to align" "PR23610" { xfail lp64 } 0 } */
+
+/* { dg-bogus "padding struct size" "PR23610" { xfail lp64 } 28 } */
+/* { dg-bogus "padding struct size" "PR23610" { xfail lp64 } 34 } */
diff --git a/gcc/testsuite/obj-c++.dg/cxx-ivars-2.mm b/gcc/testsuite/obj-c++.dg/cxx-ivars-2.mm
index bf9ca6af44a..3a6df79ab4c 100644
--- a/gcc/testsuite/obj-c++.dg/cxx-ivars-2.mm
+++ b/gcc/testsuite/obj-c++.dg/cxx-ivars-2.mm
@@ -1,7 +1,7 @@
 // Check if the '- .cxx_construct' and '-.cxx_destruct' methods get called
 // and if they perform their desired function.
 
-// { dg-do run }
+// { dg-do run { xfail { "*-*-*" } } } PR27247/PR23681
 // { dg-options "-fobjc-call-cxx-cdtors" }
 
 #include <objc/Object.h>
diff --git a/gcc/testsuite/obj-c++.dg/encode-3.mm b/gcc/testsuite/obj-c++.dg/encode-3.mm
index c67a972ddce..842a0bf37e5 100644
--- a/gcc/testsuite/obj-c++.dg/encode-3.mm
+++ b/gcc/testsuite/obj-c++.dg/encode-3.mm
@@ -14,16 +14,22 @@ Vec<double> dd;
 const char *enc = @encode(Vec<float>);
 const char *enc2 = @encode(Vec<double>);
 
+#ifdef __LP64__
+#define L "q"
+#else
+#define L "l"
+#endif
+
 int main(void) {
-  char *encode = @encode(long);
+  const char *encode = @encode(long);
 
-  if (strcmp (encode, "l"))
+  if (strcmp (encode, L))
     abort();
 
-  if (strcmp (enc, "{Vec<float>=fflq}"))
+  if (strcmp (enc, "{Vec<float>=ff" L "q}"))
     abort();
 
-  if (strcmp (enc2, "{Vec<double>=ddlq}"))
+  if (strcmp (enc2, "{Vec<double>=dd" L "q}"))
     abort();
 
   return 0;
diff --git a/gcc/testsuite/obj-c++.dg/encode-8.mm b/gcc/testsuite/obj-c++.dg/encode-8.mm
index 5f61cb87be4..bfd34754ff4 100644
--- a/gcc/testsuite/obj-c++.dg/encode-8.mm
+++ b/gcc/testsuite/obj-c++.dg/encode-8.mm
@@ -3,7 +3,7 @@
    should be encoded as '*').  */
 /* Contributed by Ziemowit Laski <zlaski@apple.com>.  */
 /* { dg-options "-lobjc" } */
-/* { dg-do run } */
+/* { dg-do run { xfail { "*-*-*" } } } PR27249 */
 
 #include <string.h>           
 #include <stdlib.h>
diff --git a/gcc/testsuite/obj-c++.dg/gnu-runtime-2.mm b/gcc/testsuite/obj-c++.dg/gnu-runtime-2.mm
index 2ead2883537..e6a1d181d90 100644
--- a/gcc/testsuite/obj-c++.dg/gnu-runtime-2.mm
+++ b/gcc/testsuite/obj-c++.dg/gnu-runtime-2.mm
@@ -22,7 +22,7 @@
 -(unsigned int) length  { return len; }
 @end
 
-int main(int argc, void **args)
+int main(int argc, const char **args)
 {
   if (strcmp ([@"this is a string" cString], "this is a string"))
     abort ();
diff --git a/gcc/testsuite/obj-c++.dg/isa-field-1.mm b/gcc/testsuite/obj-c++.dg/isa-field-1.mm
index ce1d9ff2d8f..f6d3e6a475c 100644
--- a/gcc/testsuite/obj-c++.dg/isa-field-1.mm
+++ b/gcc/testsuite/obj-c++.dg/isa-field-1.mm
@@ -1,5 +1,6 @@
 /* Ensure there are no bizarre difficulties with accessing the 'isa' field of objects.  */
 /* { dg-do compile } */
+/* { dg-xfail-if "PR23613" { "*-*-*" } { "*" } { "" } } */
 
 #include <objc/Object.h>
 
diff --git a/gcc/testsuite/obj-c++.dg/layout-1.mm b/gcc/testsuite/obj-c++.dg/layout-1.mm
index fe8ab3d083d..6972d12539f 100644
--- a/gcc/testsuite/obj-c++.dg/layout-1.mm
+++ b/gcc/testsuite/obj-c++.dg/layout-1.mm
@@ -13,3 +13,5 @@
 - (id) foo;
 @end
 
+/* { dg-bogus "included from <built-in>" "PR23610" { xfail lp64 } 0 } */
+/* { dg-bogus "padding struct to align" "PR23610" { xfail lp64 } 0 } */
diff --git a/gcc/testsuite/obj-c++.dg/lookup-2.mm b/gcc/testsuite/obj-c++.dg/lookup-2.mm
index f694ec9301c..a14860af51c 100644
--- a/gcc/testsuite/obj-c++.dg/lookup-2.mm
+++ b/gcc/testsuite/obj-c++.dg/lookup-2.mm
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-xfail-if "PR23614" { "*-*-*" } { "*" } { "" } } */
 
 #include <objc/Object.h>
 #include <stdlib.h>
diff --git a/gcc/testsuite/obj-c++.dg/try-catch-2.mm b/gcc/testsuite/obj-c++.dg/try-catch-2.mm
index 9352260ab26..7809b890db9 100644
--- a/gcc/testsuite/obj-c++.dg/try-catch-2.mm
+++ b/gcc/testsuite/obj-c++.dg/try-catch-2.mm
@@ -3,6 +3,7 @@
 /* Developed by Ziemowit Laski <zlaski@apple.com>.  */
 
 /* { dg-options "-fobjc-exceptions" } */
+/* { dg-xfail-if "PR23616" { "*-*-*" } { "*" } { "" } } */
 /* { dg-do run } */
 
 #include <objc/Object.h>
diff --git a/gcc/testsuite/obj-c++.dg/try-catch-9.mm b/gcc/testsuite/obj-c++.dg/try-catch-9.mm
index 18721b4ee43..56bbdd1e554 100644
--- a/gcc/testsuite/obj-c++.dg/try-catch-9.mm
+++ b/gcc/testsuite/obj-c++.dg/try-catch-9.mm
@@ -3,6 +3,7 @@
 /* Developed by Ziemowit Laski <zlaski@apple.com>.  */
 
 /* { dg-options "-fobjc-exceptions -O2" } */
+/* { dg-xfail-if "PR23616" { "*-*-*" } { "*" } { "" } } */
 /* { dg-do run } */
 
 #include <objc/Object.h>
diff --git a/gcc/tree-cfg.c b/gcc/tree-cfg.c
index 462c73de472..b17ba4b17dd 100644
--- a/gcc/tree-cfg.c
+++ b/gcc/tree-cfg.c
@@ -2115,7 +2115,18 @@ find_taken_edge (basic_block bb, tree val)
     return find_taken_edge_switch_expr (bb, val);
 
   if (computed_goto_p (stmt))
-    return find_taken_edge_computed_goto (bb, TREE_OPERAND( val, 0));
+    {
+      /* Only optimize if the argument is a label, if the argument is
+	 not a label then we can not construct a proper CFG.
+
+         It may be the case that we only need to allow the LABEL_REF to
+         appear inside an ADDR_EXPR, but we also allow the LABEL_REF to
+         appear inside a LABEL_EXPR just to be safe.  */
+      if ((TREE_CODE (val) == ADDR_EXPR || TREE_CODE (val) == LABEL_EXPR)
+	  && TREE_CODE (TREE_OPERAND (val, 0)) == LABEL_DECL)
+	return find_taken_edge_computed_goto (bb, TREE_OPERAND (val, 0));
+      return NULL;
+    }
 
   gcc_unreachable ();
 }
diff --git a/gcc/tree-data-ref.c b/gcc/tree-data-ref.c
index 10a223e2251..16e939d5f85 100644
--- a/gcc/tree-data-ref.c
+++ b/gcc/tree-data-ref.c
@@ -146,7 +146,12 @@ ptr_ptr_may_alias_p (tree ptr_a, tree ptr_b,
     tag_b = DR_MEMTAG (drb);
   if (!tag_b)
     return false;
-  *aliased = (tag_a == tag_b);
+  
+  if (tag_a == tag_b)
+    *aliased = true;
+  else
+    *aliased = may_aliases_intersect (tag_a, tag_b);
+
   return true;
 }
 
@@ -1720,7 +1725,7 @@ object_analysis (tree memref, tree stmt, bool is_read,
    Extract INVARIANT and CONSTANT parts from OFFSET. 
 
 */
-static void 
+static bool 
 analyze_offset (tree offset, tree *invariant, tree *constant)
 {
   tree op0, op1, constant_0, constant_1, invariant_0, invariant_1;
@@ -1736,23 +1741,36 @@ analyze_offset (tree offset, tree *invariant, tree *constant)
 	*constant = offset;
       else
 	*invariant = offset;
-      return;
+      return true;
     }
 
   op0 = TREE_OPERAND (offset, 0);
   op1 = TREE_OPERAND (offset, 1);
 
   /* Recursive call with the operands.  */
-  analyze_offset (op0, &invariant_0, &constant_0);
-  analyze_offset (op1, &invariant_1, &constant_1);
+  if (!analyze_offset (op0, &invariant_0, &constant_0)
+      || !analyze_offset (op1, &invariant_1, &constant_1))
+    return false;
 
-  /* Combine the results.  */
+  /* Combine the results.  Add negation to the subtrahend in case of 
+     subtraction.  */
+  if (constant_0 && constant_1)
+    return false;
   *constant = constant_0 ? constant_0 : constant_1;
+  if (code == MINUS_EXPR && constant_1)
+    *constant = fold_build1 (NEGATE_EXPR, TREE_TYPE (*constant), *constant);
+
   if (invariant_0 && invariant_1)
     *invariant = 
       fold_build2 (code, TREE_TYPE (invariant_0), invariant_0, invariant_1);
   else
-    *invariant = invariant_0 ? invariant_0 : invariant_1;
+    {
+      *invariant = invariant_0 ? invariant_0 : invariant_1;
+      if (code == MINUS_EXPR && invariant_1)
+        *invariant = 
+           fold_build1 (NEGATE_EXPR, TREE_TYPE (*invariant), *invariant);
+    }
+  return true;
 }
 
 
@@ -1828,7 +1846,17 @@ create_data_ref (tree memref, tree stmt, bool is_read)
 
       /* Extract CONSTANT and INVARIANT from OFFSET, and put them in DR_INIT and
 	 DR_OFFSET fields of DR.  */
-      analyze_offset (offset, &invariant, &constant); 
+      if (!analyze_offset (offset, &invariant, &constant))
+        {
+          if (dump_file && (dump_flags & TDF_DETAILS))
+            {
+              fprintf (dump_file, "\ncreate_data_ref: failed to analyze dr's");
+              fprintf (dump_file, " offset for ");
+              print_generic_expr (dump_file, memref, TDF_SLIM);
+              fprintf (dump_file, "\n");
+            }
+          return NULL;
+        }
       if (constant)
 	{
 	  DR_INIT (dr) = fold_convert (ssizetype, constant);
diff --git a/gcc/tree-flow.h b/gcc/tree-flow.h
index b4150732197..0facf698679 100644
--- a/gcc/tree-flow.h
+++ b/gcc/tree-flow.h
@@ -610,6 +610,7 @@ extern void dump_points_to_info_for (FILE *, tree);
 extern void debug_points_to_info_for (tree);
 extern bool may_be_aliased (tree);
 extern bool is_aliased_with (tree, tree);
+extern bool may_aliases_intersect (tree, tree);
 extern struct ptr_info_def *get_ptr_info (tree);
 extern void add_type_alias (tree, tree);
 extern void new_type_alias (tree, tree);
diff --git a/gcc/tree-if-conv.c b/gcc/tree-if-conv.c
index 6643d5b65ad..18e6de50e24 100644
--- a/gcc/tree-if-conv.c
+++ b/gcc/tree-if-conv.c
@@ -113,7 +113,8 @@ static bool if_convertible_stmt_p (struct loop *, basic_block, tree);
 static bool if_convertible_bb_p (struct loop *, basic_block, basic_block);
 static bool if_convertible_loop_p (struct loop *, bool);
 static void add_to_predicate_list (basic_block, tree);
-static tree add_to_dst_predicate_list (struct loop * loop, basic_block, tree, tree,
+static tree add_to_dst_predicate_list (struct loop * loop, edge,
+				       tree, tree,
 				       block_stmt_iterator *);
 static void clean_predicate_lists (struct loop *loop);
 static basic_block find_phi_replacement_condition (struct loop *loop,
@@ -143,7 +144,6 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)
 {
   basic_block bb;
   block_stmt_iterator itr;
-  tree cond;
   unsigned int i;
 
   ifc_bbs = NULL;
@@ -163,11 +163,11 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)
       return false;
     }
 
-  cond = NULL_TREE;
-
   /* Do actual work now.  */
   for (i = 0; i < loop->num_nodes; i++)
     {
+      tree cond;
+
       bb = ifc_bbs [i];
 
       /* Update condition using predicate list.  */
@@ -191,7 +191,6 @@ tree_if_conversion (struct loop *loop, bool for_vectorizer)
 	  basic_block bb_n = single_succ (bb);
 	  if (cond != NULL_TREE)
 	    add_to_predicate_list (bb_n, cond);
-	  cond = NULL_TREE;
 	}
     }
 
@@ -275,12 +274,12 @@ tree_if_convert_cond_expr (struct loop *loop, tree stmt, tree cond,
   /* Add new condition into destination's predicate list.  */
 
   /* If 'c' is true then TRUE_EDGE is taken.  */
-  add_to_dst_predicate_list (loop, true_edge->dest, cond,
+  add_to_dst_predicate_list (loop, true_edge, cond,
 			     unshare_expr (c), bsi);
 
   /* If 'c' is false then FALSE_EDGE is taken.  */
   c2 = invert_truthvalue (unshare_expr (c));
-  add_to_dst_predicate_list (loop, false_edge->dest, cond, c2, bsi);
+  add_to_dst_predicate_list (loop, false_edge, cond, c2, bsi);
 
   /* Now this conditional statement is redundant. Remove it.
      But, do not remove exit condition! Update exit condition
@@ -565,7 +564,15 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)
       /* ??? Check data dependency for vectorizer.  */
 
       /* What about phi nodes ? */
-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))
+      phi = phi_nodes (bb);
+
+      /* Clear aux field of incoming edges to a bb with a phi node.  */
+      if (phi)
+	FOR_EACH_EDGE (e, ei, bb->preds)
+	  e->aux = NULL;
+
+      /* Check statements.  */
+      for (; phi; phi = PHI_CHAIN (phi))
 	if (!if_convertible_phi_p (loop, bb, phi))
 	  return false;
 
@@ -602,13 +609,13 @@ add_to_predicate_list (basic_block bb, tree new_cond)
    existing condition.  */
 
 static tree
-add_to_dst_predicate_list (struct loop * loop, basic_block bb,
+add_to_dst_predicate_list (struct loop * loop, edge e,
 			   tree prev_cond, tree cond,
 			   block_stmt_iterator *bsi)
 {
   tree new_cond = NULL_TREE;
 
-  if (!flow_bb_inside_loop_p (loop, bb))
+  if (!flow_bb_inside_loop_p (loop, e->dest))
     return NULL_TREE;
 
   if (prev_cond == boolean_true_node || !prev_cond)
@@ -629,6 +636,11 @@ add_to_dst_predicate_list (struct loop * loop, basic_block bb,
       if (tmp_stmts2)
         bsi_insert_before (bsi, tmp_stmts2, BSI_SAME_STMT);
 
+      /* Add the condition to aux field of the edge.  In case edge
+	 destination is a PHI node, this condition will be ANDed with
+	 block predicate to construct complete condition.  */
+      e->aux = cond;
+
       /* new_cond == prev_cond AND cond */
       tmp = build (TRUTH_AND_EXPR, boolean_type_node,
 		   unshare_expr (prev_cond), cond);
@@ -636,22 +648,30 @@ add_to_dst_predicate_list (struct loop * loop, basic_block bb,
       bsi_insert_before (bsi, tmp_stmt, BSI_SAME_STMT);
       new_cond = TREE_OPERAND (tmp_stmt, 0);
     }
-  add_to_predicate_list (bb, new_cond);
+  add_to_predicate_list (e->dest, new_cond);
   return new_cond;
 }
 
-/* During if-conversion aux field from basic block is used to hold predicate
-   list. Clean each basic block's predicate list for the given LOOP.  */
+/* During if-conversion aux field from basic block structure is used to hold
+   predicate list. Clean each basic block's predicate list for the given LOOP.
+   Also clean aux field of succesor edges, used to hold true and false
+   condition from conditional expression.  */
 
 static void
 clean_predicate_lists (struct loop *loop)
 {
   basic_block *bb;
   unsigned int i;
+  edge e;
+  edge_iterator ei;
+
   bb = get_loop_body (loop);
   for (i = 0; i < loop->num_nodes; i++)
-    bb[i]->aux = NULL;
-
+    {
+      bb[i]->aux = NULL;
+      FOR_EACH_EDGE (e, ei, bb[i]->succs)
+	e->aux = NULL;
+    }
   free (bb);
 }
 
@@ -664,13 +684,12 @@ find_phi_replacement_condition (struct loop *loop,
 				basic_block bb, tree *cond,
                                 block_stmt_iterator *bsi)
 {
-  basic_block first_bb = NULL;
-  basic_block second_bb = NULL;
+  edge first_edge, second_edge;
   tree tmp_cond, new_stmts;
 
   gcc_assert (EDGE_COUNT (bb->preds) == 2);
-  first_bb = (EDGE_PRED (bb, 0))->src;
-  second_bb = (EDGE_PRED (bb, 1))->src;
+  first_edge = EDGE_PRED (bb, 0);
+  second_edge = EDGE_PRED (bb, 1);
 
   /* Use condition based on following criteria:
      1)
@@ -691,48 +710,63 @@ find_phi_replacement_condition (struct loop *loop,
        S3: x = (c == d) ? b : a;
 
        S3 is preferred over S1 and S2*, Make 'b' first_bb and use 
-       its condition.  
+       its condition.
 
      4) If  pred B is dominated by pred A then use pred B's condition.
         See PR23115.  */
 
   /* Select condition that is not TRUTH_NOT_EXPR.  */
-  tmp_cond = first_bb->aux;
+  tmp_cond = (first_edge->src)->aux;
   if (TREE_CODE (tmp_cond) == TRUTH_NOT_EXPR)
     {
-      basic_block tmp_bb;
-      tmp_bb = first_bb;
-      first_bb = second_bb;
-      second_bb = tmp_bb;
+      edge tmp_edge;
+
+      tmp_edge = first_edge;
+      first_edge = second_edge;
+      second_edge = tmp_edge;
     }
 
   /* Check if FIRST_BB is loop header or not and make sure that
      FIRST_BB does not dominate SECOND_BB.  */
-  if (first_bb == loop->header
-      || dominated_by_p (CDI_DOMINATORS, second_bb, first_bb))
+  if (first_edge->src == loop->header
+      || dominated_by_p (CDI_DOMINATORS,
+			 second_edge->src, first_edge->src))
     {
-      tmp_cond = second_bb->aux;
-      if (TREE_CODE (tmp_cond) == TRUTH_NOT_EXPR)
-	{
-	  /* Select non loop header condition but do not switch basic blocks.  */
-	  *cond = invert_truthvalue (unshare_expr (tmp_cond));
-	}
+      *cond = (second_edge->src)->aux;
+
+      /* If there is a condition on an incoming edge,
+	 AND it with the incoming bb predicate.  */
+      if (second_edge->aux)
+	*cond = build2 (TRUTH_AND_EXPR, boolean_type_node,
+			*cond, second_edge->aux);
+
+      if (TREE_CODE (*cond) == TRUTH_NOT_EXPR)
+	/* We can be smart here and choose inverted
+	   condition without switching bbs.  */
+	*cond = invert_truthvalue (*cond);
       else
-	{
-	  /* Select non loop header condition.  */
-	  first_bb = second_bb;
-	  *cond = first_bb->aux;
-	}
+	/* Select non loop header bb.  */
+	first_edge = second_edge;
     }
   else
-    /* FIRST_BB is not loop header */
-    *cond = first_bb->aux;
+    {
+      /* FIRST_BB is not loop header */
+      *cond = (first_edge->src)->aux;
+
+      /* If there is a condition on an incoming edge,
+	 AND it with the incoming bb predicate.  */
+      if (first_edge->aux)
+	*cond = build2 (TRUTH_AND_EXPR, boolean_type_node,
+			*cond, first_edge->aux);
+    }
 
   /* Create temp. for the condition. Vectorizer prefers to have gimple
      value as condition. Various targets use different means to communicate
-     condition in vector compare operation. Using gimple value allows compiler
-     to emit vector compare and select RTL without exposing compare's result.  */
-  *cond = force_gimple_operand (*cond, &new_stmts, false, NULL_TREE);
+     condition in vector compare operation. Using gimple value allows
+     compiler to emit vector compare and select RTL without exposing
+     compare's result.  */
+  *cond = force_gimple_operand (unshare_expr (*cond), &new_stmts,
+				false, NULL_TREE);
   if (new_stmts)
     bsi_insert_before (bsi, new_stmts, BSI_SAME_STMT);
   if (!is_gimple_reg (*cond) && !is_gimple_condexpr (*cond))
@@ -746,7 +780,7 @@ find_phi_replacement_condition (struct loop *loop,
 
   gcc_assert (*cond);
 
-  return first_bb;
+  return first_edge->src;
 }
 
 
@@ -777,10 +811,6 @@ replace_phi_with_cond_modify_expr (tree phi, tree cond, basic_block true_bb,
   /* Find basic block and initialize iterator.  */
   bb = bb_for_stmt (phi);
 
-  new_stmt = NULL_TREE;
-  arg_0 = NULL_TREE;
-  arg_1 = NULL_TREE;
-
   /* Use condition that is not TRUTH_NOT_EXPR in conditional modify expr.  */
   if (EDGE_PRED (bb, 1)->src == true_bb)
     {
diff --git a/gcc/tree-nested.c b/gcc/tree-nested.c
index e2d8c5cb658..0f8049ebf61 100644
--- a/gcc/tree-nested.c
+++ b/gcc/tree-nested.c
@@ -693,7 +693,7 @@ check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)
   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)
     {
       for (arg = DECL_ARGUMENTS (cgn->decl); arg; arg = TREE_CHAIN (arg))
-	if (variably_modified_type_p (TREE_TYPE (arg), 0), orig_fndecl)
+	if (variably_modified_type_p (TREE_TYPE (arg), orig_fndecl))
 	  return true;
 
       if (check_for_nested_with_variably_modified (cgn->decl, orig_fndecl))
diff --git a/gcc/tree-nrv.c b/gcc/tree-nrv.c
index e0b59eb1d91..7265ebc7e7a 100644
--- a/gcc/tree-nrv.c
+++ b/gcc/tree-nrv.c
@@ -163,6 +163,14 @@ tree_nrv (void)
 						     result_type))
 		return;
 	    }
+	  else if (TREE_CODE (stmt) == MODIFY_EXPR)
+	    {
+	      tree addr = get_base_address (TREE_OPERAND (stmt, 0));
+	       /* If there's any MODIFY of component of RESULT, 
+		  then bail out.  */
+	      if (addr && addr == result)
+		return;
+	    }
 	}
     }
 
diff --git a/gcc/tree-pass.h b/gcc/tree-pass.h
index 1f45ffd5719..3478d1a16b8 100644
--- a/gcc/tree-pass.h
+++ b/gcc/tree-pass.h
@@ -335,7 +335,6 @@ extern struct tree_opt_pass pass_life;
 extern struct tree_opt_pass pass_combine;
 extern struct tree_opt_pass pass_if_after_combine;
 extern struct tree_opt_pass pass_partition_blocks;
-extern struct tree_opt_pass pass_partition_blocks;
 extern struct tree_opt_pass pass_regmove;
 extern struct tree_opt_pass pass_split_all_insns;
 extern struct tree_opt_pass pass_mode_switching;
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index c25632020ea..5537ba08c8f 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -1,7 +1,7 @@
 /* Scalar Replacement of Aggregates (SRA) converts some structure
    references into scalar references, exposing them to the scalar
    optimizers.
-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
    Contributed by Diego Novillo <dnovillo@redhat.com>
 
 This file is part of GCC.
@@ -1246,7 +1246,23 @@ instantiate_missing_elements (struct sra_elt *elt)
 	tree f;
 	for (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))
 	  if (TREE_CODE (f) == FIELD_DECL)
-	    instantiate_missing_elements_1 (elt, f, TREE_TYPE (f));
+	    {
+	      tree field_type = TREE_TYPE (f);
+
+	      /* canonicalize_component_ref() unwidens some bit-field
+		 types (not marked as DECL_BIT_FIELD in C++), so we
+		 must do the same, lest we may introduce type
+		 mismatches.  */
+	      if (INTEGRAL_TYPE_P (field_type)
+		  && DECL_MODE (f) != TYPE_MODE (field_type))
+		field_type = TREE_TYPE (get_unwidened (build3 (COMPONENT_REF,
+							       field_type,
+							       elt->element,
+							       f, NULL_TREE),
+						       NULL_TREE));
+
+	      instantiate_missing_elements_1 (elt, f, field_type);
+	    }
 	break;
       }
 
@@ -1539,6 +1555,14 @@ generate_element_ref (struct sra_elt *elt)
     return elt->element;
 }
 
+static tree
+sra_build_assignment (tree dst, tree src)
+{
+  /* We need TYPE_CANONICAL to compare the types of dst and src
+     efficiently, but that's only introduced in GCC 4.3.  */
+  return build (MODIFY_EXPR, void_type_node, dst, src);
+}
+
 /* Generate a set of assignment statements in *LIST_P to copy all
    instantiated elements under ELT to or from the equivalent structure
    rooted at EXPR.  COPY_OUT controls the direction of the copy, with
@@ -1562,16 +1586,16 @@ generate_copy_inout (struct sra_elt *elt, bool copy_out, tree expr,
       i = c->replacement;
 
       t = build (COMPLEX_EXPR, elt->type, r, i);
-      t = build (MODIFY_EXPR, void_type_node, expr, t);
+      t = sra_build_assignment (expr, t);
       SSA_NAME_DEF_STMT (expr) = t;
       append_to_statement_list (t, list_p);
     }
   else if (elt->replacement)
     {
       if (copy_out)
-	t = build (MODIFY_EXPR, void_type_node, elt->replacement, expr);
+	t = sra_build_assignment (elt->replacement, expr);
       else
-	t = build (MODIFY_EXPR, void_type_node, expr, elt->replacement);
+	t = sra_build_assignment (expr, elt->replacement);
       append_to_statement_list (t, list_p);
     }
   else
@@ -1606,8 +1630,7 @@ generate_element_copy (struct sra_elt *dst, struct sra_elt *src, tree *list_p)
 
       gcc_assert (src->replacement);
 
-      t = build (MODIFY_EXPR, void_type_node, dst->replacement,
-		 src->replacement);
+      t = sra_build_assignment (dst->replacement, src->replacement);
       append_to_statement_list (t, list_p);
     }
 }
@@ -1638,7 +1661,7 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)
       gcc_assert (elt->is_scalar);
       t = fold_convert (elt->type, integer_zero_node);
 
-      t = build (MODIFY_EXPR, void_type_node, elt->replacement, t);
+      t = sra_build_assignment (elt->replacement, t);
       append_to_statement_list (t, list_p);
     }
 }
@@ -1650,7 +1673,9 @@ static void
 generate_one_element_init (tree var, tree init, tree *list_p)
 {
   /* The replacement can be almost arbitrarily complex.  Gimplify.  */
-  tree stmt = build (MODIFY_EXPR, void_type_node, var, init);
+  tree stmt;
+
+  stmt = sra_build_assignment (var, init);
   gimplify_and_add (stmt, list_p);
 }
 
diff --git a/gcc/tree-ssa-alias.c b/gcc/tree-ssa-alias.c
index e8803722445..2dac169cf09 100644
--- a/gcc/tree-ssa-alias.c
+++ b/gcc/tree-ssa-alias.c
@@ -46,6 +46,7 @@ Boston, MA 02110-1301, USA.  */
 #include "ipa-type-escape.h"
 #include "vec.h"
 #include "bitmap.h"
+#include "pointer-set.h"
 
 /* Obstack used to hold grouping bitmaps and other temporary bitmaps used by
    aliasing  */
@@ -2231,6 +2232,38 @@ is_aliased_with (tree tag, tree sym)
 }
 
 
+/* Given two tags return TRUE if their may-alias sets intersect.  */
+
+bool 
+may_aliases_intersect (tree tag1, tree tag2)
+{ 
+  struct pointer_set_t *set1 = pointer_set_create ();
+  unsigned i;
+  varray_type may_aliases1 = var_ann (tag1)->may_aliases; 
+  varray_type may_aliases2 = var_ann (tag2)->may_aliases;
+
+  if (may_aliases1 == NULL || may_aliases2 == NULL)
+    return false;
+ 
+  /* Insert all the symbols from the first may-alias set into the
+     pointer-set.  */
+  for (i = 0; i < VARRAY_ACTIVE_SIZE (may_aliases1); i++)
+    pointer_set_insert (set1, VARRAY_TREE (may_aliases1, i));
+
+  /* Go through the second may-alias set and check if it contains symbols that
+     are common with the first set.  */
+  for (i = 0; i < VARRAY_ACTIVE_SIZE (may_aliases2); i++)
+    if (pointer_set_contains (set1, VARRAY_TREE (may_aliases2, i)))
+      {
+       pointer_set_destroy (set1); 
+       return true;
+      }
+  
+  pointer_set_destroy (set1);
+  return false;
+}
+
+
 /* Add VAR to the list of may-aliases of PTR's type tag.  If PTR
    doesn't already have a type tag, create one.  */
 
diff --git a/gcc/tree-ssa-structalias.c b/gcc/tree-ssa-structalias.c
index 0bc5ecaabc6..bcc1dac3e0e 100644
--- a/gcc/tree-ssa-structalias.c
+++ b/gcc/tree-ssa-structalias.c
@@ -3405,7 +3405,8 @@ set_uids_in_ptset (bitmap into, bitmap from)
 	    bitmap_set_bit (into, DECL_UID (sv->var));
 	}
       else if (TREE_CODE (vi->decl) == VAR_DECL 
-	       || TREE_CODE (vi->decl) == PARM_DECL)
+	       || TREE_CODE (vi->decl) == PARM_DECL
+	       || TREE_CODE (vi->decl) == RESULT_DECL)
 	{
 	  if (found_anyoffset
 	      && var_can_have_subvars (vi->decl)
diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
index 7dc41382e9c..8d479c1eed3 100644
--- a/gcc/tree-vrp.c
+++ b/gcc/tree-vrp.c
@@ -106,6 +106,10 @@ nonnull_arg_p (tree arg)
 
   gcc_assert (TREE_CODE (arg) == PARM_DECL && POINTER_TYPE_P (TREE_TYPE (arg)));
 
+  /* The static chain decl is always non null.  */
+  if (arg == cfun->static_chain_decl)
+    return true;
+
   fntype = TREE_TYPE (current_function_decl);
   attrs = lookup_attribute ("nonnull", TYPE_ATTRIBUTES (fntype));
 
@@ -649,81 +653,6 @@ range_includes_zero_p (value_range_t *vr)
 }
 
 
-/* When extracting ranges from X_i = ASSERT_EXPR <Y_j, pred>, we will
-   initially consider X_i and Y_j equivalent, so the equivalence set
-   of Y_j is added to the equivalence set of X_i.  However, it is
-   possible to have a chain of ASSERT_EXPRs whose predicates are
-   actually incompatible.  This is usually the result of nesting of
-   contradictory if-then-else statements.  For instance, in PR 24670:
-
-   	count_4 has range [-INF, 63]
-
-   	if (count_4 != 0)
-	  {
-	    count_19 = ASSERT_EXPR <count_4, count_4 != 0>
-	    if (count_19 > 63)
-	      {
-	        count_18 = ASSERT_EXPR <count_19, count_19 > 63>
-		if (count_18 <= 63)
-		  ...
-	      }
-	  }
-
-   Notice that 'if (count_19 > 63)' is trivially false and will be
-   folded out at the end.  However, during propagation, the flowgraph
-   is not cleaned up and so, VRP will evaluate predicates more
-   predicates than necessary, so it must support these
-   inconsistencies.  The problem here is that because of the chaining
-   of ASSERT_EXPRs, the equivalency set for count_18 includes count_4.
-   Since count_4 has an incompatible range, we ICE when evaluating the
-   ranges in the equivalency set.  So, we need to remove count_4 from
-   it.  */
-
-static void
-fix_equivalence_set (value_range_t *vr_p)
-{
-  bitmap_iterator bi;
-  unsigned i;
-  bitmap e = vr_p->equiv;
-  bitmap to_remove = BITMAP_ALLOC (NULL);
-
-  /* Only detect inconsistencies on numeric ranges.  */
-  if (vr_p->type == VR_VARYING
-      || vr_p->type == VR_UNDEFINED
-      || symbolic_range_p (vr_p))
-    return;
-
-  EXECUTE_IF_SET_IN_BITMAP (e, 0, i, bi)
-    {
-      value_range_t *equiv_vr = vr_value[i];
-
-      if (equiv_vr->type == VR_VARYING
-	  || equiv_vr->type == VR_UNDEFINED
-	  || symbolic_range_p (equiv_vr))
-	continue;
-
-      if (equiv_vr->type == VR_RANGE
-	  && vr_p->type == VR_RANGE
-	  && !value_ranges_intersect_p (vr_p, equiv_vr))
-	bitmap_set_bit (to_remove, i);
-      else if ((equiv_vr->type == VR_RANGE && vr_p->type == VR_ANTI_RANGE)
-	       || (equiv_vr->type == VR_ANTI_RANGE && vr_p->type == VR_RANGE))
-	{
-	  /* A range and an anti-range have an empty intersection if
-	     their end points are the same.  FIXME,
-	     value_ranges_intersect_p should handle this
-	     automatically.  */
-	  if (compare_values (equiv_vr->min, vr_p->min) == 0
-	      && compare_values (equiv_vr->max, vr_p->max) == 0)
-	    bitmap_set_bit (to_remove, i);
-	}
-    }
-
-  bitmap_and_compl_into (vr_p->equiv, to_remove);
-  BITMAP_FREE (to_remove);
-}
-
-
 /* Extract value range information from an ASSERT_EXPR EXPR and store
    it in *VR_P.  */
 
@@ -1020,7 +949,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)
       || var_vr->type == VR_UNDEFINED
       || symbolic_range_p (vr_p)
       || symbolic_range_p (var_vr))
-    goto done;
+    return;
 
   if (var_vr->type == VR_RANGE && vr_p->type == VR_RANGE)
     {
@@ -1064,11 +993,6 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)
 	  && compare_values (var_vr->max, vr_p->max) == 0)
 	set_value_range_to_varying (vr_p);
     }
-
-  /* Remove names from the equivalence set that have ranges
-     incompatible with VR_P.  */
-done:
-  fix_equivalence_set (vr_p);
 }
 
 
@@ -1593,14 +1517,21 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)
   if (code == NEGATE_EXPR
       && !TYPE_UNSIGNED (TREE_TYPE (expr)))
     {
-      /* NEGATE_EXPR flips the range around.  */
-      min = (vr0.max == TYPE_MAX_VALUE (TREE_TYPE (expr)) && !flag_wrapv)
-	     ? TYPE_MIN_VALUE (TREE_TYPE (expr))
-	     : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);
-
-      max = (vr0.min == TYPE_MIN_VALUE (TREE_TYPE (expr)) && !flag_wrapv)
-	     ? TYPE_MAX_VALUE (TREE_TYPE (expr))
-	     : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);
+      /* NEGATE_EXPR flips the range around.  We need to treat
+	 TYPE_MIN_VALUE specially dependent on wrapping, range type
+	 and if it was used as minimum or maximum value:  
+	  -~[MIN, MIN] == ~[MIN, MIN]
+	  -[MIN, 0] == [0, MAX]  for -fno-wrapv
+	  -[MIN, 0] == [0, MIN]  for -fwrapv (will be set to varying later)  */
+      min = tree_int_cst_equal (vr0.max, TYPE_MIN_VALUE (TREE_TYPE (expr)))
+	    ? TYPE_MIN_VALUE (TREE_TYPE (expr))
+	    : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);
+
+      max = tree_int_cst_equal (vr0.min, TYPE_MIN_VALUE (TREE_TYPE (expr)))
+	    ? (vr0.type == VR_ANTI_RANGE || flag_wrapv
+	       ? TYPE_MIN_VALUE (TREE_TYPE (expr))
+	       : TYPE_MAX_VALUE (TREE_TYPE (expr)))
+	    : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);
     }
   else if (code == ABS_EXPR
            && !TYPE_UNSIGNED (TREE_TYPE (expr)))
@@ -1609,9 +1540,9 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)
          useful range.  */
       if (flag_wrapv
 	  && ((vr0.type == VR_RANGE
-	       && vr0.min == TYPE_MIN_VALUE (TREE_TYPE (expr)))
+	       && tree_int_cst_equal (vr0.min, TYPE_MIN_VALUE (TREE_TYPE (expr))))
 	      || (vr0.type == VR_ANTI_RANGE
-	          && vr0.min != TYPE_MIN_VALUE (TREE_TYPE (expr))
+	          && !tree_int_cst_equal (vr0.min, TYPE_MIN_VALUE (TREE_TYPE (expr)))
 		  && !range_includes_zero_p (&vr0))))
 	{
 	  set_value_range_to_varying (vr);
@@ -1620,7 +1551,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)
 	
       /* ABS_EXPR may flip the range around, if the original range
 	 included negative values.  */
-      min = (vr0.min == TYPE_MIN_VALUE (TREE_TYPE (expr)))
+      min = (tree_int_cst_equal (vr0.min, TYPE_MIN_VALUE (TREE_TYPE (expr))))
 	    ? TYPE_MAX_VALUE (TREE_TYPE (expr))
 	    : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);
 
@@ -1644,7 +1575,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)
 	         or ~[-INF + 1, min (abs(MIN), abs(MAX))] when
 		 flag_wrapv is set and the original anti-range doesn't include
 	         TYPE_MIN_VALUE, remember -TYPE_MIN_VALUE = TYPE_MIN_VALUE.  */
-	      min = (flag_wrapv && vr0.min != type_min_value
+	      min = (flag_wrapv && !tree_int_cst_equal (vr0.min, type_min_value)
 		     ? int_const_binop (PLUS_EXPR,
 					type_min_value,
 					integer_one_node, 0)
@@ -2153,6 +2084,7 @@ void
 debug_value_range (value_range_t *vr)
 {
   dump_value_range (stderr, vr);
+  fprintf (stderr, "\n");
 }
 
 
@@ -3267,8 +3199,16 @@ compare_name_with_value (enum tree_code comp, tree var, tree val)
       t = compare_range_with_value (comp, &equiv_vr, val);
       if (t)
 	{
-	  /* All the ranges should compare the same against VAL.  */
-	  gcc_assert (retval == NULL || t == retval);
+	  /* If we get different answers from different members
+	     of the equivalence set this check must be in a dead
+	     code region.  Folding it to a trap representation
+	     would be correct here.  For now just return don't-know.  */
+	  if (retval != NULL
+	      && t != retval)
+	    {
+	      retval = NULL_TREE;
+	      break;
+	    }
 	  retval = t;
 	}
     }
@@ -3350,9 +3290,17 @@ compare_names (enum tree_code comp, tree n1, tree n2)
 	  t = compare_ranges (comp, &vr1, &vr2);
 	  if (t)
 	    {
-	      /* All the ranges in the equivalent sets should compare
-		 the same.  */
-	      gcc_assert (retval == NULL || t == retval);
+	      /* If we get different answers from different members
+		 of the equivalence set this check must be in a dead
+		 code region.  Folding it to a trap representation
+		 would be correct here.  For now just return don't-know.  */
+	      if (retval != NULL
+		  && t != retval)
+		{
+		  bitmap_clear_bit (e1, SSA_NAME_VERSION (n1));
+		  bitmap_clear_bit (e2, SSA_NAME_VERSION (n2));
+		  return NULL_TREE;
+		}
 	      retval = t;
 	    }
 	}
diff --git a/gcc/tree.c b/gcc/tree.c
index e537e9cd314..6541344f2e5 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -3288,8 +3288,9 @@ build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)
 	  hashcode = type_hash_list (TYPE_ARG_TYPES (ntype), hashcode);
 	  break;
 	case ARRAY_TYPE:
-	  hashcode = iterative_hash_object (TYPE_HASH (TYPE_DOMAIN (ntype)),
-					    hashcode);
+	  if (TYPE_DOMAIN (ntype))
+	    hashcode = iterative_hash_object (TYPE_HASH (TYPE_DOMAIN (ntype)),
+					      hashcode);
 	  break;
 	case INTEGER_TYPE:
 	  hashcode = iterative_hash_object
diff --git a/gcc/var-tracking.c b/gcc/var-tracking.c
index fb4a1813218..c94c6670a0e 100644
--- a/gcc/var-tracking.c
+++ b/gcc/var-tracking.c
@@ -253,6 +253,9 @@ typedef struct variable_def
 /* Pointer to the BB's information specific to variable tracking pass.  */
 #define VTI(BB) ((variable_tracking_info) (BB)->aux)
 
+/* Macro to access MEM_OFFSET as an HOST_WIDE_INT.  Evaluates MEM twice.  */
+#define INT_MEM_OFFSET(mem) (MEM_OFFSET (mem) ? INTVAL (MEM_OFFSET (mem)) : 0)
+
 /* Alloc pool for struct attrs_def.  */
 static alloc_pool attrs_pool;
 
@@ -866,7 +869,7 @@ static void
 var_mem_delete_and_set (dataflow_set *set, rtx loc)
 {
   tree decl = MEM_EXPR (loc);
-  HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;
+  HOST_WIDE_INT offset = INT_MEM_OFFSET (loc);
 
   set_variable_part (set, loc, decl, offset);
 }
@@ -878,7 +881,7 @@ static void
 var_mem_delete (dataflow_set *set, rtx loc)
 {
   tree decl = MEM_EXPR (loc);
-  HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;
+  HOST_WIDE_INT offset = INT_MEM_OFFSET (loc);
 
   delete_variable_part (set, loc, decl, offset);
 }
@@ -1452,6 +1455,18 @@ track_expr_p (tree expr)
   return 1;
 }
 
+/* Return true if OFFSET is a valid offset for a register or memory
+   access we want to track.  This is used to reject out-of-bounds
+   accesses that can cause assertions to fail later.  Note that we
+   don't reject negative offsets because they can be generated for
+   paradoxical subregs on big-endian architectures.  */
+
+static inline bool
+offset_valid_for_tracked_p (HOST_WIDE_INT offset)
+{
+  return (-MAX_VAR_PARTS < offset) && (offset < MAX_VAR_PARTS);
+}
+
 /* Count uses (register and memory references) LOC which will be tracked.
    INSN is instruction which the LOC is part of.  */
 
@@ -1467,7 +1482,8 @@ count_uses (rtx *loc, void *insn)
     }
   else if (MEM_P (*loc)
 	   && MEM_EXPR (*loc)
-	   && track_expr_p (MEM_EXPR (*loc)))
+	   && track_expr_p (MEM_EXPR (*loc))
+	   && offset_valid_for_tracked_p (INT_MEM_OFFSET (*loc)))
     {
       VTI (bb)->n_mos++;
     }
@@ -1503,14 +1519,19 @@ add_uses (rtx *loc, void *insn)
       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);
       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;
 
-      mo->type = ((REG_EXPR (*loc) && track_expr_p (REG_EXPR (*loc)))
-		  ? MO_USE : MO_USE_NO_VAR);
+      if (REG_EXPR (*loc)
+	  && track_expr_p (REG_EXPR (*loc))
+	  && offset_valid_for_tracked_p (REG_OFFSET (*loc)))
+	mo->type = MO_USE;
+      else
+	mo->type = MO_USE_NO_VAR;
       mo->u.loc = *loc;
       mo->insn = (rtx) insn;
     }
   else if (MEM_P (*loc)
 	   && MEM_EXPR (*loc)
-	   && track_expr_p (MEM_EXPR (*loc)))
+	   && track_expr_p (MEM_EXPR (*loc))
+	   && offset_valid_for_tracked_p (INT_MEM_OFFSET (*loc)))
     {
       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);
       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;
@@ -1543,15 +1564,20 @@ add_stores (rtx loc, rtx expr, void *insn)
       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);
       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;
 
-      mo->type = ((GET_CODE (expr) != CLOBBER && REG_EXPR (loc)
-		   && track_expr_p (REG_EXPR (loc)))
-		  ? MO_SET : MO_CLOBBER);
+      if (GET_CODE (expr) != CLOBBER
+	  && REG_EXPR (loc)
+	  && track_expr_p (REG_EXPR (loc))
+	  && offset_valid_for_tracked_p (REG_OFFSET (loc)))
+	mo->type = MO_SET;
+      else
+	mo->type = MO_CLOBBER;
       mo->u.loc = loc;
       mo->insn = (rtx) insn;
     }
   else if (MEM_P (loc)
 	   && MEM_EXPR (loc)
-	   && track_expr_p (MEM_EXPR (loc)))
+	   && track_expr_p (MEM_EXPR (loc))
+	   && offset_valid_for_tracked_p (INT_MEM_OFFSET (loc)))
     {
       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);
       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;
@@ -2450,7 +2476,7 @@ vt_get_decl_and_offset (rtx rtl, tree *declp, HOST_WIDE_INT *offsetp)
       if (MEM_ATTRS (rtl))
 	{
 	  *declp = MEM_EXPR (rtl);
-	  *offsetp = MEM_OFFSET (rtl) ? INTVAL (MEM_OFFSET (rtl)) : 0;
+	  *offsetp = INT_MEM_OFFSET (rtl);
 	  return true;
 	}
     }
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 3e317e5c0fb..007ae85c21a 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -5662,9 +5662,10 @@ default_binds_local_p_1 (tree exp, int shlib)
   else if (DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)
     local_p = true;
   /* If PIC, then assume that any global name can be overridden by
-     symbols resolved from other modules.  */
+     symbols resolved from other modules, unless we are compiling with
+     -fwhole-program, which assumes that names are local.  */
   else if (shlib)
-    local_p = false;
+    local_p = flag_whole_program;
   /* Uninitialized COMMON variable may be unified with symbols
      resolved from other modules.  */
   else if (DECL_COMMON (exp)
diff --git a/include/ChangeLog b/include/ChangeLog
index 8d17f23b1db..30184c93ca0 100644
--- a/include/ChangeLog
+++ b/include/ChangeLog
@@ -1,3 +1,7 @@
+2007-05-04  Mark Mitchell  <mark@codesourcery.com>
+
+	* demangle.h: Change license to LGPL + exception.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/include/demangle.h b/include/demangle.h
index 304a4c4e472..c050e1c0a18 100644
--- a/include/demangle.h
+++ b/include/demangle.h
@@ -1,21 +1,30 @@
 /* Defs for interface to demanglers.
    Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002,
-   2003, 2004 Free Software Foundation, Inc.
+   2003, 2004, 2005, 2007 Free Software Foundation, Inc.
    
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License
+   as published by the Free Software Foundation; either version 2, or
+   (at your option) any later version.
+
+   In addition to the permissions in the GNU Library General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Library Public License restrictions do apply in other
+   respects; for example, they cover modification of the file, and
+   distribution when not linked into a combined executable.)
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
 
 
 #if !defined (DEMANGLE_H)
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index 3b123585c03..7bf1838eb2e 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,9 @@
+2007-04-23  Tom Tromey  <tromey@redhat.com>
+
+	PR preprocessor/30468:
+	* mkdeps.c (apply_vpath): Strip successive '/'s if we stripped
+	'./'.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/libcpp/mkdeps.c b/libcpp/mkdeps.c
index 3e2c4d82e96..8aa96c529e3 100644
--- a/libcpp/mkdeps.c
+++ b/libcpp/mkdeps.c
@@ -1,5 +1,5 @@
 /* Dependency generator for Makefile fragments.
-   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2003, 2007 Free Software Foundation, Inc.
    Contributed by Zack Weinberg, Mar 2000
 
 This program is free software; you can redistribute it and/or modify it
@@ -141,7 +141,13 @@ apply_vpath (struct deps *d, const char *t)
 
   /* Remove leading ./ in any case.  */
   while (t[0] == '.' && IS_DIR_SEPARATOR (t[1]))
-    t += 2;
+    {
+      t += 2;
+      /* If we removed a leading ./, then also remove any /s after the
+	 first.  */
+      while (IS_DIR_SEPARATOR (t[0]))
+	++t;
+    }
 
   return t;
 }
diff --git a/libffi/ChangeLog b/libffi/ChangeLog
index 03ff1b24fdc..460fbd19059 100644
--- a/libffi/ChangeLog
+++ b/libffi/ChangeLog
@@ -1,3 +1,16 @@
+2007-04-20  Richard Henderson  <rth@redhat.com>
+
+	* configure.ac (alpha*-*-*): Define HAVE_LONG_DOUBLE.
+	* configure: Regenerate.
+	* include/ffi.h.in (ffi_type_longdouble): Define as ffi_type_double
+	if HAVE_LONG_DOUBLE is false.
+	* src/alpha/ffi.c (ffi_prep_cif_machdep): Support the 128-bit
+	long double type.
+	(ffi_call_osf, ffi_closure_osf): Likewise.
+	* src/alpha/osf.S (ffi_call_osf, ffi_closure_osf): Mark hidden.
+	* src/types.c (ffi_type_longdouble): For alpha, always generate
+	for the 128-bit long double type.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/libffi/configure b/libffi/configure
index a6a6e09d06c..928509ec51d 100755
--- a/libffi/configure
+++ b/libffi/configure
@@ -5393,7 +5393,11 @@ sparc*-sun-*) TARGET=SPARC; TARGETDIR=sparc;;
 sparc-*-linux* | sparc-*-netbsdelf* | sparc-*-knetbsd*-gnu) TARGET=SPARC; TARGETDIR=sparc;;
 sparc*-*-rtems*) TARGET=SPARC; TARGETDIR=sparc;;
 sparc64-*-linux* | sparc64-*-netbsd* | sparc64-*-knetbsd*-gnu) TARGET=SPARC; TARGETDIR=sparc;;
-alpha*-*-linux* | alpha*-*-osf* | alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu | alpha*-*-netbsd* | alpha*-*-knetbsd*-gnu) TARGET=ALPHA; TARGETDIR=alpha;;
+alpha*-*-linux* | alpha*-*-osf* | alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu | alpha*-*-netbsd* | alpha*-*-knetbsd*-gnu)
+	TARGET=ALPHA; TARGETDIR=alpha
+	# Support 128-bit long double, changable via command-line switch.
+	HAVE_LONG_DOUBLE='defined(__LONG_DOUBLE_128__)'
+	;;
 ia64*-*-*) TARGET=IA64; TARGETDIR=ia64;;
 m32r*-*-linux* ) TARGET=M32R; TARGETDIR=m32r;;
 m68k-*-linux*) TARGET=M68K; TARGETDIR=m68k;;
@@ -7102,15 +7106,17 @@ _ACEOF
 
 
 # Also AC_SUBST this variable for ffi.h.
-HAVE_LONG_DOUBLE=0
-if test $ac_cv_sizeof_double != $ac_cv_sizeof_long_double; then
-  if test $ac_cv_sizeof_long_double != 0; then
-    HAVE_LONG_DOUBLE=1
+if test -z "$HAVE_LONG_DOUBLE"; then
+  HAVE_LONG_DOUBLE=0
+  if test $ac_cv_sizeof_double != $ac_cv_sizeof_long_double; then
+    if test $ac_cv_sizeof_long_double != 0; then
+      HAVE_LONG_DOUBLE=1
 
 cat >>confdefs.h <<\_ACEOF
 #define HAVE_LONG_DOUBLE 1
 _ACEOF
 
+    fi
   fi
 fi
 
diff --git a/libffi/configure.ac b/libffi/configure.ac
index eac8e8fe42e..1052e49a172 100644
--- a/libffi/configure.ac
+++ b/libffi/configure.ac
@@ -58,7 +58,11 @@ sparc*-sun-*) TARGET=SPARC; TARGETDIR=sparc;;
 sparc-*-linux* | sparc-*-netbsdelf* | sparc-*-knetbsd*-gnu) TARGET=SPARC; TARGETDIR=sparc;;
 sparc*-*-rtems*) TARGET=SPARC; TARGETDIR=sparc;;
 sparc64-*-linux* | sparc64-*-netbsd* | sparc64-*-knetbsd*-gnu) TARGET=SPARC; TARGETDIR=sparc;;
-alpha*-*-linux* | alpha*-*-osf* | alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu | alpha*-*-netbsd* | alpha*-*-knetbsd*-gnu) TARGET=ALPHA; TARGETDIR=alpha;;
+alpha*-*-linux* | alpha*-*-osf* | alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu | alpha*-*-netbsd* | alpha*-*-knetbsd*-gnu)
+	TARGET=ALPHA; TARGETDIR=alpha
+	# Support 128-bit long double, changable via command-line switch.
+	HAVE_LONG_DOUBLE='defined(__LONG_DOUBLE_128__)'
+	;;
 ia64*-*-*) TARGET=IA64; TARGETDIR=ia64;;
 m32r*-*-linux* ) TARGET=M32R; TARGETDIR=m32r;;
 m68k-*-linux*) TARGET=M68K; TARGETDIR=m68k;;
@@ -126,11 +130,13 @@ AC_CHECK_SIZEOF(double)
 AC_CHECK_SIZEOF(long double)
 
 # Also AC_SUBST this variable for ffi.h.
-HAVE_LONG_DOUBLE=0
-if test $ac_cv_sizeof_double != $ac_cv_sizeof_long_double; then
-  if test $ac_cv_sizeof_long_double != 0; then
-    HAVE_LONG_DOUBLE=1
-    AC_DEFINE(HAVE_LONG_DOUBLE, 1, [Define if you have the long double type and it is bigger than a double])
+if test -z "$HAVE_LONG_DOUBLE"; then
+  HAVE_LONG_DOUBLE=0
+  if test $ac_cv_sizeof_double != $ac_cv_sizeof_long_double; then
+    if test $ac_cv_sizeof_long_double != 0; then
+      HAVE_LONG_DOUBLE=1
+      AC_DEFINE(HAVE_LONG_DOUBLE, 1, [Define if you have the long double type and it is bigger than a double])
+    fi
   fi
 fi
 AC_SUBST(HAVE_LONG_DOUBLE)
diff --git a/libffi/include/ffi.h.in b/libffi/include/ffi.h.in
index 42600458689..dfa153c0ae7 100644
--- a/libffi/include/ffi.h.in
+++ b/libffi/include/ffi.h.in
@@ -145,9 +145,13 @@ extern ffi_type ffi_type_uint64;
 extern ffi_type ffi_type_sint64;
 extern ffi_type ffi_type_float;
 extern ffi_type ffi_type_double;
-extern ffi_type ffi_type_longdouble;
 extern ffi_type ffi_type_pointer;
 
+#if @HAVE_LONG_DOUBLE@
+extern ffi_type ffi_type_longdouble;
+#else
+#define ffi_type_longdouble ffi_type_double
+#endif
 
 typedef enum {
   FFI_OK = 0,
diff --git a/libffi/src/alpha/ffi.c b/libffi/src/alpha/ffi.c
index 00d33790109..b1336c68d25 100644
--- a/libffi/src/alpha/ffi.c
+++ b/libffi/src/alpha/ffi.c
@@ -25,11 +25,22 @@
 
 #include <ffi.h>
 #include <ffi_common.h>
-
 #include <stdlib.h>
 
-extern void ffi_call_osf(void *, unsigned long, unsigned, void *, void (*)());
-extern void ffi_closure_osf(void);
+/* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;
+   all further uses in this file will refer to the 128-bit type.  */
+#if defined(__LONG_DOUBLE_128__)
+# if FFI_TYPE_LONGDOUBLE != 4
+#  error FFI_TYPE_LONGDOUBLE out of date
+# endif
+#else
+# undef FFI_TYPE_LONGDOUBLE
+# define FFI_TYPE_LONGDOUBLE 4
+#endif
+
+extern void ffi_call_osf(void *, unsigned long, unsigned, void *, void (*)())
+  FFI_HIDDEN;
+extern void ffi_closure_osf(void) FFI_HIDDEN;
 
 
 ffi_status
@@ -49,6 +60,11 @@ ffi_prep_cif_machdep(ffi_cif *cif)
       cif->flags = cif->rtype->type;
       break;
 
+    case FFI_TYPE_LONGDOUBLE:
+      /* 128-bit long double is returned in memory, like a struct.  */
+      cif->flags = FFI_TYPE_STRUCT;
+      break;
+
     default:
       cif->flags = FFI_TYPE_INT;
       break;
@@ -57,6 +73,7 @@ ffi_prep_cif_machdep(ffi_cif *cif)
   return FFI_OK;
 }
 
+
 void
 ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 {
@@ -64,8 +81,6 @@ ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
   long i, avn;
   ffi_type **arg_types;
   
-  FFI_ASSERT (cif->abi == FFI_OSF);
-
   /* If the return value is a struct and we don't have a return
      value address then we need to make one.  */
   if (rvalue == NULL && cif->flags == FFI_TYPE_STRUCT)
@@ -84,6 +99,8 @@ ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 
   while (i < avn)
     {
+      size_t size = (*arg_types)->size;
+
       switch ((*arg_types)->type)
 	{
 	case FFI_TYPE_SINT8:
@@ -129,6 +146,12 @@ ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 	  *(double *) argp = *(double *)(* avalue);
 	  break;
 
+	case FFI_TYPE_LONGDOUBLE:
+	  /* 128-bit long double is passed by reference.  */
+	  *(long double **) argp = (long double *)(* avalue);
+	  size = sizeof (long double *);
+	  break;
+
 	case FFI_TYPE_STRUCT:
 	  memcpy(argp, *avalue, (*arg_types)->size);
 	  break;
@@ -137,7 +160,7 @@ ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)
 	  FFI_ASSERT(0);
 	}
 
-      argp += ALIGN((*arg_types)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
+      argp += ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
       i++, arg_types++, avalue++;
     }
 
@@ -153,8 +176,6 @@ ffi_prep_closure (ffi_closure* closure,
 {
   unsigned int *tramp;
 
-  FFI_ASSERT (cif->abi == FFI_OSF);
-
   tramp = (unsigned int *) &closure->tramp[0];
   tramp[0] = 0x47fb0401;	/* mov $27,$1		*/
   tramp[1] = 0xa77b0010;	/* ldq $27,16($27)	*/
@@ -177,7 +198,8 @@ ffi_prep_closure (ffi_closure* closure,
   return FFI_OK;
 }
 
-int
+
+long FFI_HIDDEN
 ffi_closure_osf_inner(ffi_closure *closure, void *rvalue, unsigned long *argp)
 {
   ffi_cif *cif;
@@ -205,6 +227,8 @@ ffi_closure_osf_inner(ffi_closure *closure, void *rvalue, unsigned long *argp)
   /* Grab the addresses of the arguments from the stack frame.  */
   while (i < avn)
     {
+      size_t size = arg_types[i]->size;
+
       switch (arg_types[i]->type)
 	{
 	case FFI_TYPE_SINT8:
@@ -236,16 +260,22 @@ ffi_closure_osf_inner(ffi_closure *closure, void *rvalue, unsigned long *argp)
 	  avalue[i] = &argp[argn - (argn < 6 ? 6 : 0)];
 	  break;
 
+	case FFI_TYPE_LONGDOUBLE:
+	  /* 128-bit long double is passed by reference.  */
+	  avalue[i] = (long double *) argp[argn];
+	  size = sizeof (long double *);
+	  break;
+
 	default:
-	  FFI_ASSERT(0);
+	  abort ();
 	}
 
-      argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
+      argn += ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
       i++;
     }
 
   /* Invoke the closure.  */
-  (closure->fun) (cif, rvalue, avalue, closure->user_data);
+  closure->fun (cif, rvalue, avalue, closure->user_data);
 
   /* Tell ffi_closure_osf how to perform return type promotions.  */
   return cif->rtype->type;
diff --git a/libffi/src/alpha/osf.S b/libffi/src/alpha/osf.S
index 2f03d627aa2..aba6782e794 100644
--- a/libffi/src/alpha/osf.S
+++ b/libffi/src/alpha/osf.S
@@ -1,10 +1,8 @@
 /* -----------------------------------------------------------------------
-   osf.S - Copyright (c) 1998, 2001 Red Hat
+   osf.S - Copyright (c) 1998, 2001, 2007 Red Hat
    
    Alpha/OSF Foreign Function Interface 
 
-   $Id: osf.S,v 1.1.1.1 1998/11/29 16:48:16 green Exp $
-
    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    ``Software''), to deal in the Software without restriction, including
@@ -42,6 +40,8 @@
 	.align	3
 	.globl	ffi_call_osf
 	.ent	ffi_call_osf
+	FFI_HIDDEN(ffi_call_osf)
+
 ffi_call_osf:
 	.frame	$15, 32, $26, 0
 	.mask   0x4008000, -32
@@ -129,6 +129,8 @@ $LFE1:
 	.align	3
 	.globl	ffi_closure_osf
 	.ent	ffi_closure_osf
+	FFI_HIDDEN(ffi_closure_osf)
+
 ffi_closure_osf:
 	.frame	$30, 16*8, $26, 0
 	.mask	0x4000000, -16*8
@@ -265,7 +267,7 @@ $load_table:
 	.gprel32 $load_32	# FFI_TYPE_INT
 	.gprel32 $load_float	# FFI_TYPE_FLOAT
 	.gprel32 $load_double	# FFI_TYPE_DOUBLE
-	.gprel32 $load_double	# FFI_TYPE_LONGDOUBLE
+	.gprel32 $load_none	# FFI_TYPE_LONGDOUBLE
 	.gprel32 $load_u8	# FFI_TYPE_UINT8
 	.gprel32 $load_s8	# FFI_TYPE_SINT8
 	.gprel32 $load_u16	# FFI_TYPE_UINT16
diff --git a/libffi/src/types.c b/libffi/src/types.c
index b65787359fe..ad7ef6044a2 100644
--- a/libffi/src/types.c
+++ b/libffi/src/types.c
@@ -57,4 +57,17 @@ FFI_TYPEDEF(pointer, void*, FFI_TYPE_POINTER);
 
 FFI_TYPEDEF(float, float, FFI_TYPE_FLOAT);
 FFI_TYPEDEF(double, double, FFI_TYPE_DOUBLE);
+
+#ifdef __alpha__
+/* Even if we're not configured to default to 128-bit long double, 
+   maintain binary compatibility, as -mlong-double-128 can be used
+   at any time.  */
+/* Validate the hard-coded number below.  */
+# if defined(__LONG_DOUBLE_128__) && FFI_TYPE_LONGDOUBLE != 4
+#  error FFI_TYPE_LONGDOUBLE out of date
+# endif
+# undef ffi_type_longdouble
+ffi_type ffi_type_longdouble = { 16, 16, 4, NULL };
+#elif FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
 FFI_TYPEDEF(longdouble, long double, FFI_TYPE_LONGDOUBLE);
+#endif
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index a8fe3fc5d2a..b60bfe33484 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,45 @@
+2008-01-21  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR libfortran/34699
+	Backport:
+	2007-09-21  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR libfortran/26253
+	* intrinsics/c99_functions.c (scalbn): Use ldexp if appopriate.
+
+2007-05-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/31964
+	Backport from trunk.
+	* intrinsics/ishftc.c (ishftc4, ishftc8, ishftc16): Fix mask to handle
+	shift of bit-size number of bits.
+
+2007-05-10  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/31409
+	* io/transfer.c (read_block_direct): Backport from 4.3 trunk.
+
+2007-05-10  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/31880
+	* io/unix.c (fd_alloc_r_at): Fix calculation of physical offset.
+
+2007-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	* io/unix.c (regular_file): For ACTION_UNSPECIFIED retry with
+	O_RDONLY even if errno is EROFS.
+
+2007-02-24  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/30918
+	* io/listread.c (namelist_read): Eat comment line.
+
+2007-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/30910
+	* io/write.c (output_float): Add condition of format F only for
+	special case rounding with zero precision.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/libgfortran/intrinsics/c99_functions.c b/libgfortran/intrinsics/c99_functions.c
index 3eabd0dc5a7..40e0ba76346 100644
--- a/libgfortran/intrinsics/c99_functions.c
+++ b/libgfortran/intrinsics/c99_functions.c
@@ -226,7 +226,11 @@ log10f(float x)
 double
 scalbn(double x, int y)
 {
+#if (FLT_RADIX == 2) && defined(HAVE_LDEXP)
+  return ldexp (x, y);
+#else
   return x * pow(FLT_RADIX, y);
+#endif
 }
 #endif
 
diff --git a/libgfortran/intrinsics/ishftc.c b/libgfortran/intrinsics/ishftc.c
index a147b968389..91e0db2048d 100644
--- a/libgfortran/intrinsics/ishftc.c
+++ b/libgfortran/intrinsics/ishftc.c
@@ -36,8 +36,7 @@ export_proto(ishftc4);
 GFC_INTEGER_4
 ishftc4 (GFC_INTEGER_4 i, GFC_INTEGER_4 shift, GFC_INTEGER_4 size)
 {
-  GFC_INTEGER_4 mask;
-  GFC_UINTEGER_4 bits;
+  GFC_UINTEGER_4 mask, bits;
 
   if (shift < 0)
     shift = shift + size;
@@ -45,9 +44,14 @@ ishftc4 (GFC_INTEGER_4 i, GFC_INTEGER_4 shift, GFC_INTEGER_4 size)
   if (shift == 0 || shift == size)
     return i;
 
-  mask = (~(GFC_INTEGER_4)0) << size;
-  bits = i & ~mask;
-  return (i & mask) | (bits >> (size - shift)) | ((i << shift) & ~mask);
+  /* In C, the result of the shift operator is undefined if the right operand
+     is greater than or equal to the number of bits in the left operand. So we
+     have to special case it for fortran.  */
+  mask = ~((size == 32) ? 0 : (~0 << size));
+
+  bits = i & mask;
+  
+  return (i & ~mask) | ((bits << shift) & mask) | (bits >> (size - shift));
 }
 
 extern GFC_INTEGER_8 ishftc8 (GFC_INTEGER_8, GFC_INTEGER_4, GFC_INTEGER_4);
@@ -56,8 +60,7 @@ export_proto(ishftc8);
 GFC_INTEGER_8
 ishftc8 (GFC_INTEGER_8 i, GFC_INTEGER_4 shift, GFC_INTEGER_4 size)
 {
-  GFC_INTEGER_8 mask;
-  GFC_UINTEGER_8 bits;
+  GFC_UINTEGER_8 mask, bits;
 
   if (shift < 0)
     shift = shift + size;
@@ -65,9 +68,14 @@ ishftc8 (GFC_INTEGER_8 i, GFC_INTEGER_4 shift, GFC_INTEGER_4 size)
   if (shift == 0 || shift == size)
     return i;
 
-  mask = (~(GFC_INTEGER_8)0) << size;
-  bits = i & ~mask;
-  return (i & mask) | (bits >> (size - shift)) | ((i << shift) & ~mask);
+  /* In C, the result of the shift operator is undefined if the right operand
+     is greater than or equal to the number of bits in the left operand. So we
+     have to special case it for fortran.  */
+  mask = ~((size == 64) ? 0 : (~0 << size));
+
+  bits = i & mask;
+  
+  return (i & ~mask) | ((bits << shift) & mask) | (bits >> (size - shift));
 }
 
 #ifdef HAVE_GFC_INTEGER_16
@@ -77,8 +85,7 @@ export_proto(ishftc16);
 GFC_INTEGER_16
 ishftc16 (GFC_INTEGER_16 i, GFC_INTEGER_4 shift, GFC_INTEGER_4 size)
 {
-  GFC_INTEGER_16 mask;
-  GFC_UINTEGER_16 bits;
+  GFC_UINTEGER_16 mask, bits;
 
   if (shift < 0)
     shift = shift + size;
@@ -86,8 +93,13 @@ ishftc16 (GFC_INTEGER_16 i, GFC_INTEGER_4 shift, GFC_INTEGER_4 size)
   if (shift == 0 || shift == size)
     return i;
 
-  mask = (~(GFC_INTEGER_16)0) << size;
-  bits = i & ~mask;
-  return (i & mask) | (bits >> (size - shift)) | ((i << shift) & ~mask);
+  /* In C, the result of the shift operator is undefined if the right operand
+     is greater than or equal to the number of bits in the left operand. So we
+     have to special case it for fortran.  */
+  mask = ~((size == 128) ? 0 : (~0 << size));
+
+  bits = i & mask;
+  
+  return (i & ~mask) | ((bits << shift) & mask) | (bits >> (size - shift));
 }
 #endif
diff --git a/libgfortran/io/list_read.c b/libgfortran/io/list_read.c
index 4552d2f7869..729e565d88d 100644
--- a/libgfortran/io/list_read.c
+++ b/libgfortran/io/list_read.c
@@ -2567,6 +2567,10 @@ find_nml_name:
     case '&':
           break;
 
+    case '!':
+      eat_line (dtp);
+      goto find_nml_name;
+
     case '=':
       c = next_char (dtp);
       if (c == '?')
diff --git a/libgfortran/io/transfer.c b/libgfortran/io/transfer.c
index a3b337c789f..124c33dfc00 100644
--- a/libgfortran/io/transfer.c
+++ b/libgfortran/io/transfer.c
@@ -347,6 +347,8 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)
 
   if (short_record)
     {
+      dtp->u.p.current_unit->current_record = 0;
+      next_record (dtp, 0);
       generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);
       return;
     }
diff --git a/libgfortran/io/unix.c b/libgfortran/io/unix.c
index 560047f88f8..7c51caa2e83 100644
--- a/libgfortran/io/unix.c
+++ b/libgfortran/io/unix.c
@@ -465,7 +465,7 @@ fd_alloc_r_at (unix_stream * s, int *len, gfc_offset where)
       if (n < 0)
 	return NULL;
 
-      s->physical_offset = where + n;
+      s->physical_offset = m + n;
       s->active += n;
     }
   else
@@ -476,7 +476,7 @@ fd_alloc_r_at (unix_stream * s, int *len, gfc_offset where)
       if (do_read (s, s->buffer + s->active, &n) != 0)
 	return NULL;
 
-      s->physical_offset = where + n;
+      s->physical_offset = m + n;
       s->active += n;
     }
 
@@ -1169,7 +1169,7 @@ regular_file (st_parameter_open *opp, unit_flags *flags)
       break;
 
     case STATUS_REPLACE:
-        crflag = O_CREAT | O_TRUNC;
+      crflag = O_CREAT | O_TRUNC;
       break;
 
     default:
@@ -1185,14 +1185,14 @@ regular_file (st_parameter_open *opp, unit_flags *flags)
   mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
   fd = open (path, rwflag | crflag, mode);
   if (flags->action != ACTION_UNSPECIFIED)
-      return fd;
+    return fd;
 
   if (fd >= 0)
     {
       flags->action = ACTION_READWRITE;
       return fd;
     }
-  if (errno != EACCES)
+  if (errno != EACCES && errno != EROFS)
      return fd;
 
   /* retry for read-only access */
diff --git a/libgfortran/io/write.c b/libgfortran/io/write.c
index bee367c49ae..b20702197b2 100644
--- a/libgfortran/io/write.c
+++ b/libgfortran/io/write.c
@@ -426,6 +426,15 @@ output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)
   if (value < 0)
     value = -value;
 
+  /* Special case when format specifies no digits after the decimal point.  */
+  if (d == 0 && ft == FMT_F)
+    {
+      if (value < 0.5)
+	value = 0.0;
+      else if (value < 1.0)
+	value = value + 0.5;
+    }
+
   /* Printf always prints at least two exponent digits.  */
   if (value == 0)
     edigits = 2;
diff --git a/libjava/ChangeLog b/libjava/ChangeLog
index 5fb6562b4de..e0162ca7d71 100644
--- a/libjava/ChangeLog
+++ b/libjava/ChangeLog
@@ -1,3 +1,12 @@
+2007-09-09  Richard Guenther  <rguenther@suse.de>
+
+	Backport from mainline:
+	2007-05-07  Ian Lance Taylor  <iant@google.com>
+
+	PR java/31842
+	* java/lang/natString.cc (_Jv_FormatInt): Avoid undefined signed
+	overflow.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/libjava/java/lang/natString.cc b/libjava/java/lang/natString.cc
index 3f630812d5e..3cca5176d0b 100644
--- a/libjava/java/lang/natString.cc
+++ b/libjava/java/lang/natString.cc
@@ -371,11 +371,11 @@ _Jv_FormatInt (jchar* bufend, jint num)
   if (num < 0)
     {
       isNeg = true;
-      num = -(num);
-      if (num < 0)
+      if (num != (jint) -2147483648U)
+	num = -(num);
+      else
 	{
-	  // Must be MIN_VALUE, so handle this special case.
-	  // FIXME use 'unsigned jint' for num.
+	  // Handle special case of MIN_VALUE.
 	  *--ptr = '8';
 	  num = 214748364;
 	}
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index fcaeadc6179..7787c8b6164 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,34 @@
+2008-04-08  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	Backport:
+	2006-03-24  Mark Mitchell  <mark@codesourcery.com>
+	            Joseph S. Myers  <joseph@codesourcery.com>
+
+	PR libstdc++/20448
+	PR libstdc++/20451
+	* scripts/testsuite_flags.in (--cxxflags): Don't define LOCALEDIR.
+	* testsuite/lib/libstdc++.exp (libstdc++_init): Always define
+	LOCALEDIR to ".".
+	(v3-build_support): Build MO files.
+
+2008-02-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* testsuite/27_io/fpos/14320-1.cc: Check for "long long" and
+	remove XFAIL.
+
+2007-04-23  Matthias Klose  <doko@debian.org>
+
+	Backport from mainline:
+	2007-02-27  Richard Guenther  <rguenther@suse.de>
+
+	* acinclude.m4: Adjust regular expression for ld version extraction.
+	* configure: Regenerate.
+
+2007-02-21  Mark Mitchell  <mark@codesourcery.com>
+
+	* testsuite/lib/libstdc++.exp (libstdc++_init): Compile testglue
+	with -fexceptions.
+
 2007-02-13  Release Manager
 
 	* GCC 4.1.2 released.
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index 597270f7f02..3c059d4acfe 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -225,7 +225,7 @@ AC_DEFUN([GLIBCXX_CHECK_LINKER_FEATURES], [
   if test x"$with_gnu_ld" = x"yes"; then
     changequote(,)
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
     changequote([,])
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 6f205dd0b45..0c0a5d3d377 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -8281,7 +8281,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -53122,7 +53122,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -74456,7 +74456,7 @@ done
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -75953,7 +75953,7 @@ done
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -77326,7 +77326,7 @@ done
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -79486,7 +79486,7 @@ done
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -80305,7 +80305,7 @@ done
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -81680,7 +81680,7 @@ done
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -83447,7 +83447,7 @@ echo "${ECHO_T}$glibcxx_cv_WRITEV" >&6
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -84664,7 +84664,7 @@ _ACEOF
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -85665,7 +85665,7 @@ done
   if test x"$with_gnu_ld" = x"yes"; then
 
     ldver=`$LD --version 2>/dev/null | head -1 | \
-           sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+           sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
     glibcxx_gnu_ld_version=`echo $ldver | \
            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
diff --git a/libstdc++-v3/scripts/testsuite_flags.in b/libstdc++-v3/scripts/testsuite_flags.in
index 6f70002bcd4..8301375b332 100755
--- a/libstdc++-v3/scripts/testsuite_flags.in
+++ b/libstdc++-v3/scripts/testsuite_flags.in
@@ -49,7 +49,7 @@ case ${query} in
     --cxxflags)
       CXXFLAGS_save="-g -O2 -D_GLIBCXX_ASSERT"
       CXXFLAGS_config='@SECTION_FLAGS@ @SECTION_LDFLAGS@ -fmessage-length=0 
- 		      @EXTRA_CXX_FLAGS@ -DLOCALEDIR="@glibcxx_localedir@" '
+ 		      @EXTRA_CXX_FLAGS@ '
       echo ${CXXFLAGS_save} ${CXXFLAGS_config}
       ;;
     --cxxpchflags)
diff --git a/libstdc++-v3/testsuite/27_io/fpos/14320-1.cc b/libstdc++-v3/testsuite/27_io/fpos/14320-1.cc
index 85e1d432eb3..1e492d06d03 100644
--- a/libstdc++-v3/testsuite/27_io/fpos/14320-1.cc
+++ b/libstdc++-v3/testsuite/27_io/fpos/14320-1.cc
@@ -20,7 +20,7 @@
 
 // 27.4.3 fpos
 
-// { dg-do run { xfail *-*-* } }
+// { dg-do run }
 
 #include <typeinfo>
 #include <limits>
@@ -36,6 +36,11 @@ void test01()
   typedef istreambuf_iterator<char>::difference_type Distance;
 
   bool found = false;
+  // The C++ standard didn't originally have "long long", however that
+  // type will be in the C++0x standard and testing for it allows
+  // ilp32 targets to pass this test when `Distance' is 64 bits.
+  if (typeid(Distance) == typeid(long long int))
+    found = true;
   if (typeid(Distance) == typeid(long int))
     found = true;
   if (typeid(Distance) == typeid(int))
diff --git a/libstdc++-v3/testsuite/lib/libstdc++.exp b/libstdc++-v3/testsuite/lib/libstdc++.exp
index 3368c242070..86be3a4d1ee 100644
--- a/libstdc++-v3/testsuite/lib/libstdc++.exp
+++ b/libstdc++-v3/testsuite/lib/libstdc++.exp
@@ -190,17 +190,12 @@ proc libstdc++_init { testfile } {
             set cxx [transform "g++"]
             set cxxflags "-g -O2 -D_GLIBCXX_ASSERT -fmessage-length=0" 
             set includes "-I${srcdir}"
-	    # Guess at the location of the installed locale files.
-	    # (It would be nice if "gcc --print-file-name" could find
-	    # message files, but it cannot.)
-	    set absolute_cxx [which $cxx]
-	    if { $absolute_cxx != "" } {
-		set localedir "[file dirname $absolute_cxx]/../share/locale"
-	    }
-	    set cxxflags "$cxxflags -DLOCALEDIR=\"$localedir\""
         }
     }
 
+    # Always use MO files built by this test harness.
+    set cxxflags "$cxxflags -DLOCALEDIR=\".\""
+
     # If a PCH file is available, use it.  We must delay performing
     # this check until $cxx and such have been initialized because we
     # perform a test compilation.  (Ideally, gcc --print-file-name would
@@ -223,7 +218,7 @@ proc libstdc++_init { testfile } {
 	v3track PCH_CXXFLAGS 2
     }
 
-    libstdc++_maybe_build_wrapper "${objdir}/testglue.o"
+    libstdc++_maybe_build_wrapper "${objdir}/testglue.o" "-fexceptions"
 }
 
 # Callback for cleanup routines.
@@ -390,6 +385,20 @@ proc v3-build_support { } {
 	set v3-threads 1
     }
 
+    # Try to build the MO files that are used by some of the locale
+    # tests.  If we can't build them, that's OK; it just means that
+    # those tests will fail.
+    foreach lang [list "fr" "de"] {
+	catch {
+	    file mkdir "$lang/LC_MESSAGES"
+	    remote_exec "build" "msgfmt" "-o $lang/LC_MESSAGES/libstdc++.mo $srcdir/../po/$lang.po"
+	    if [is_remote host] {
+		remote_exec "host" "mkdir" "-p $lang/LC_MESSAGES"
+		remote_download "host" "$lang/LC_MESSAGES/libstdc++.mo" "$lang/LC_MESSAGES/libstdc++.mo"
+	    }
+	}
+    }
+
     # Build the support objects.
     set source_files \
 	[list testsuite_abi.cc testsuite_allocator.cc testsuite_character.cc testsuite_hooks.cc ]
diff --git a/ltconfig b/ltconfig
index 839b980fdb2..cfbfda85dad 100755
--- a/ltconfig
+++ b/ltconfig
@@ -1133,7 +1133,7 @@ freebsd1*)
   ;;
 
 freebsd*)
-  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
