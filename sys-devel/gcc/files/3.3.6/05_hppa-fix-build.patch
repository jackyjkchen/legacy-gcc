diff --git a/gcc/config/pa/pa-linux.h b/gcc/config/pa/pa-linux.h
index 495046e..202f79e 100644
--- a/gcc/config/pa/pa-linux.h
+++ b/gcc/config/pa/pa-linux.h
@@ -101,7 +101,7 @@ Boston, MA 02111-1307, USA.  */
    file which includes this one.  */
 
 #undef STRING_ASM_OP
-#define STRING_ASM_OP   ".stringz"
+#define STRING_ASM_OP   "\t.stringz\t"
 
 #define TEXT_SECTION_ASM_OP "\t.text"
 #define DATA_SECTION_ASM_OP "\t.data"
diff --git a/libffi/Makefile.am b/libffi/Makefile.am
index 8cae053..1ab013c 100644
--- a/libffi/Makefile.am
+++ b/libffi/Makefile.am
@@ -18,7 +18,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \
 		src/powerpc/darwin_closure.S src/powerpc/aix_closures.S \
 		src/arm/ffi.c src/arm/sysv.S \
 		src/s390/ffi.c src/s390/sysv.S \
-		src/sh/ffi.c src/sh/sysv.S
+		src/sh/ffi.c src/sh/sysv.S \
+		src/pa/ffi.c src/pa/linux.S
 
 VPATH = @srcdir@:@srcdir@/src:@srcdir@/src/@TARGETDIR@
 
@@ -79,11 +80,7 @@ MULTICLEAN = true
 toolexeclib_LTLIBRARIES = libffi.la
 noinst_LTLIBRARIES = libffi_convenience.la
 
-noinst_PROGRAMS = ffitest
-
-ffitest_OBJECTS = ffitest.lo
-ffitest_LDADD = libffi.la
-ffitest_LDFLAGS = -shared-libgcc
+noinst_PROGRAMS = 
 
 TARGET_SRC_MIPS_GCC = src/mips/ffi.c src/mips/o32.S src/mips/n32.S
 TARGET_SRC_MIPS_LINUX = src/mips/ffi.c src/mips/o32.S
@@ -101,6 +98,7 @@ TARGET_SRC_ARM =  src/arm/sysv.S src/arm/ffi.c
 TARGET_SRC_S390 =  src/s390/sysv.S src/s390/ffi.c
 TARGET_SRC_X86_64 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S
 TARGET_SRC_SH =  src/sh/sysv.S src/sh/ffi.c
+TARGET_SRC_PA =  src/pa/linux.S src/pa/ffi.c
 
 ##libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c $(TARGET_SRC_@TARGET@)
 ## Work around automake deficiency
@@ -170,6 +168,10 @@ if SH
 libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_SH)
 libfficonvenience_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_SH)
 endif
+if PA
+libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_PA)
+libffi_convenience_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_PA)
+endif
 
 AM_CFLAGS = -fexceptions
 
diff --git a/libffi/Makefile.in b/libffi/Makefile.in
index 598d683..93ef8b6 100644
--- a/libffi/Makefile.in
+++ b/libffi/Makefile.in
@@ -94,6 +94,7 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \
 		src/x86/ffi64.c src/x86/unix64.S \
 		src/alpha/ffi.c src/alpha/osf.S \
 		src/m68k/ffi.c src/m68k/sysv.S \
+		src/pa/ffi.c src/pa/linux.S \
 		src/powerpc/ffi.c src/powerpc/sysv.S \
 		src/powerpc/ppc_closure.S src/powerpc/asm.h \
 		src/powerpc/ffi_darwin.c \
@@ -158,11 +159,7 @@ MULTICLEAN = true
 toolexeclib_LTLIBRARIES = libffi.la
 noinst_LTLIBRARIES = libffi_convenience.la
 
-noinst_PROGRAMS = ffitest
-
-ffitest_OBJECTS = ffitest.lo
-ffitest_LDADD = libffi.la
-ffitest_LDFLAGS = -shared-libgcc
+noinst_PROGRAMS = 
 
 TARGET_SRC_MIPS_GCC = src/mips/ffi.c src/mips/o32.S src/mips/n32.S
 TARGET_SRC_MIPS_LINUX = src/mips/ffi.c src/mips/o32.S
@@ -180,6 +177,7 @@ TARGET_SRC_ARM = src/arm/sysv.S src/arm/ffi.c
 TARGET_SRC_S390 = src/s390/sysv.S src/s390/ffi.c
 TARGET_SRC_X86_64 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S
 TARGET_SRC_SH = src/sh/sysv.S src/sh/ffi.c
+TARGET_SRC_PA = src/pa/linux.S src/pa/ffi.c
 
 libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \
 		src/raw_api.c src/java_raw_api.c
@@ -200,6 +198,7 @@ libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \
 @S390_TRUE@libffi_la_SOURCES = @S390_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_S390)
 @X86_64_TRUE@libffi_la_SOURCES = @X86_64_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_X86_64)
 @SH_TRUE@libffi_la_SOURCES = @SH_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_SH)
+@PA_TRUE@libffi_la_SOURCES = @PA_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_PA)
 @MIPS_GCC_TRUE@libffi_convenience_la_SOURCES = @MIPS_GCC_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_GCC)
 @MIPS_LINUX_TRUE@libffi_convenience_la_SOURCES = @MIPS_LINUX_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_LINUX)
 @MIPS_SGI_TRUE@libffi_convenience_la_SOURCES = @MIPS_SGI_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_SGI)
@@ -216,6 +215,7 @@ libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \
 @S390_TRUE@libffi_convenience_la_SOURCES = @S390_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_S390)
 @X86_64_TRUE@libffi_convenience_la_SOURCES = @X86_64_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_X86_64)
 @SH_TRUE@libfficonvenience_la_SOURCES = @SH_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_SH)
+@PA_TRUE@libffi_convenience_la_SOURCES = @PA_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_PA)
 
 AM_CFLAGS = -fexceptions
 
@@ -238,6 +238,9 @@ libffi_convenience_la_LIBADD =
 @ALPHA_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \
 @ALPHA_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \
 @ALPHA_TRUE@src/java_raw_api.lo src/alpha/ffi.lo src/alpha/osf.lo
+@PA_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \
+@PA_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \
+@PA_TRUE@src/pa/linux.lo src/pa/ffi.lo
 @IA64_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \
 @IA64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \
 @IA64_TRUE@src/ia64/ffi.lo src/ia64/unix.lo
@@ -292,6 +295,9 @@ libffi_la_LIBADD =
 @SH_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \
 @SH_TRUE@src/raw_api.lo src/java_raw_api.lo src/sh/sysv.lo \
 @SH_TRUE@src/sh/ffi.lo
+@PA_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \
+@PA_TRUE@src/raw_api.lo src/java_raw_api.lo \
+@PA_TRUE@src/pa/linux.lo src/pa/ffi.lo
 @IA64_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \
 @IA64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \
 @IA64_TRUE@src/ia64/ffi.lo src/ia64/unix.lo
@@ -341,10 +347,9 @@ libffi_la_LIBADD =
 @POWERPC_DARWIN_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \
 @POWERPC_DARWIN_TRUE@src/powerpc/ffi_darwin.lo src/powerpc/darwin.lo \
 @POWERPC_DARWIN_TRUE@src/powerpc/darwin_closure.lo
-noinst_PROGRAMS =  ffitest$(EXEEXT)
+noinst_PROGRAMS =  
 PROGRAMS =  $(noinst_PROGRAMS)
 
-ffitest_DEPENDENCIES =  libffi.la
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
@@ -483,10 +488,6 @@ distclean-noinstPROGRAMS:
 
 maintainer-clean-noinstPROGRAMS:
 
-ffitest$(EXEEXT): $(ffitest_OBJECTS) $(ffitest_DEPENDENCIES)
-	@rm -f ffitest$(EXEEXT)
-	$(LINK) $(ffitest_LDFLAGS) $(ffitest_OBJECTS) $(ffitest_LDADD) $(LIBS)
-
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
 # To change the values of `make' variables: instead of editing Makefiles,
@@ -615,7 +616,7 @@ distdir: $(DISTFILES)
 	mkdir $(distdir)
 	-chmod 777 $(distdir)
 	$(mkinstalldirs) $(distdir)/src/alpha $(distdir)/src/arm \
-	   $(distdir)/src/m68k $(distdir)/src/mips \
+	   $(distdir)/src/m68k $(distdir)/src/mips $(distdir)/src/pa \
 	   $(distdir)/src/powerpc $(distdir)/src/s390 $(distdir)/src/sh \
 	   $(distdir)/src/sparc $(distdir)/src/x86
 	@for file in $(DISTFILES); do \
diff --git a/libffi/configure b/libffi/configure
index 2bd5165..7c6816a 100755
--- a/libffi/configure
+++ b/libffi/configure
@@ -2473,6 +2473,7 @@ s390-*-linux-*) TARGET=S390; TARGETDIR=s390;;
 s390x-*-linux-*) TARGET=S390; TARGETDIR=s390;;
 x86_64-*-linux*) TARGET=X86_64; TARGETDIR=x86;;
 sh-*-linux* | sh[34]*-*-linux*) TARGET=SH; TARGETDIR=sh;;
+hppa*-*-linux* | parisc-*-linux*) TARGET=PA; TARGETDIR=pa;;
 esac
 
 if test $TARGETDIR = unknown; then
diff --git a/libffi/configure.in b/libffi/configure.in
index 704b353..1c1a9e9 100644
--- a/libffi/configure.in
+++ b/libffi/configure.in
@@ -75,6 +75,7 @@ s390-*-linux-*) TARGET=S390; TARGETDIR=s390;;
 s390x-*-linux-*) TARGET=S390; TARGETDIR=s390;;
 x86_64-*-linux*) TARGET=X86_64; TARGETDIR=x86;;
 sh-*-linux* | sh[[34]]*-*-linux*) TARGET=SH; TARGETDIR=sh;;
+hppa*-*-linux* | parisc-*-linux*) TARGET=PA; TARGETDIR=pa;;
 esac
 
 if test $TARGETDIR = unknown; then
@@ -97,6 +98,7 @@ AM_CONDITIONAL(ARM, test x$TARGET = xARM)
 AM_CONDITIONAL(S390, test x$TARGET = xS390)
 AM_CONDITIONAL(X86_64, test x$TARGET = xX86_64)
 AM_CONDITIONAL(SH, test x$TARGET = xSH)
+AM_CONDITIONAL(PA, test x$TARGET = xPA)
 
 if test x$TARGET = xMIPS_LINUX; then
   TARGET=MIPS
diff --git a/libffi/include/ffi.h.in b/libffi/include/ffi.h.in
index fe91ecd..8c26156 100644
--- a/libffi/include/ffi.h.in
+++ b/libffi/include/ffi.h.in
@@ -283,6 +283,12 @@ typedef enum ffi_abi {
   FFI_DEFAULT_ABI = FFI_SYSV,
 #endif
 
+  /* ---- PA ------------------- */
+#ifdef PA
+  FFI_LINUX,
+  FFI_DEFAULT_ABI = FFI_LINUX,
+#endif
+
   /* Leave this for debugging purposes */
   FFI_LAST_ABI
 
@@ -432,6 +438,16 @@ struct ffi_ia64_trampoline_struct {
 #define FFI_TRAMPOLINE_SIZE 24
 #define FFI_NATIVE_RAW_API 0
 
+#elif defined(PA)
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+
+#define FFI_TRAMPOLINE_SIZE 32
+
+#define FFI_TYPE_SMALL_STRUCT1 -1
+#define FFI_TYPE_SMALL_STRUCT2 -2
+
 #elif defined(POWERPC)
 
 #define FFI_CLOSURES 1
diff --git a/libffi/src/ffitest.c b/libffi/src/ffitest.c
deleted file mode 100644
index a05b746..0000000
--- a/libffi/src/ffitest.c
+++ /dev/null
@@ -1,1306 +0,0 @@
-/* -----------------------------------------------------------------------
-   ffitest.c - Copyright (c) 1996, 1997, 1998, 2002, 2003  Red Hat, Inc.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   ``Software''), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be included
-   in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
-   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
-   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-   OTHER DEALINGS IN THE SOFTWARE.
-   ----------------------------------------------------------------------- */
-
-#include <ffi.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <float.h>
-
-/* This is lame. Long double support is barely there under SunOS 4.x  */
-#if defined(SPARC) && (SIZEOF_LONG_DOUBLE != 16)
-#define BROKEN_LONG_DOUBLE
-#endif
-
-#define CHECK(x) !(x) ? fail(__FILE__, __LINE__) : 0 
-
-static int fail(char *file, int line)
-{
-  fprintf(stderr, "Test failure: %s line %d\n", file, line);
-  exit(EXIT_FAILURE);
-  /*@notreached@*/
-  return 0;
-}
-
-#define MAX_ARGS 256
-
-static size_t my_strlen(char *s)
-{
-  return (strlen(s));
-}
-
-#ifdef X86_WIN32
-static size_t __attribute__((stdcall)) my_stdcall_strlen(char *s)
-{
-  return (strlen(s));
-}
-#endif /* X86_WIN32 */
-
-static int promotion(signed char sc, signed short ss, 
-		     unsigned char uc, unsigned short us)
-{
-  int r = (int) sc + (int) ss + (int) uc + (int) us;
-
-  return r;
-}
-
-static signed char return_sc(signed char sc)
-{
-  return sc;
-}
-
-static unsigned char return_uc(unsigned char uc)
-{
-  return uc;
-}
-
-static long long return_ll(long long ll)
-{
-  return ll;
-}
-
-static int floating(int a, float b, double c, long double d, int e)
-{
-  int i;
-
-#if 0
-  /* This is ifdef'd out for now. long double support under SunOS/gcc
-     is pretty much non-existent.  You'll get the odd bus error in library
-     routines like printf().  */
-  printf("%d %f %f %Lf %d\n", a, (double)b, c, d, e);
-#endif
-
-  i = (int) ((float)a/b + ((float)c/(float)d));
-
-  return i;
-}
-
-static float many(float f1,
-		  float f2,
-		  float f3,
-		  float f4,
-		  float f5,
-		  float f6,
-		  float f7,
-		  float f8,
-		  float f9,
-		  float f10,
-		  float f11,
-		  float f12,
-		  float f13)
-{
-#if 0
-  printf("%f %f %f %f %f %f %f %f %f %f %f %f %f\n",
-	 (double) f1, (double) f2, (double) f3, (double) f4, (double) f5, 
-	 (double) f6, (double) f7, (double) f8, (double) f9, (double) f10,
-	 (double) f11, (double) f12, (double) f13);
-#endif
-
-  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);
-}
-
-#ifdef X86_WIN32
-static float __attribute__((stdcall)) stdcall_many(float f1,
-						   float f2,
-						   float f3,
-						   float f4,
-						   float f5,
-						   float f6,
-						   float f7,
-						   float f8,
-						   float f9,
-						   float f10,
-						   float f11,
-						   float f12,
-						   float f13)
-{
-  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);
-}
-#endif /* X86_WIN32 */
-
-static double dblit(float f)
-{
-  return f/3.0;
-}
-
-static long double ldblit(float f)
-{
-  return (long double) (((long double) f)/ (long double) 3.0);
-}
-
-typedef struct
-{
-  unsigned char uc;
-  double d;
-  unsigned int ui;
-} test_structure_1;
-
-typedef struct
-{
-  double d1;
-  double d2;
-} test_structure_2;
-
-typedef struct
-{
-  int si;
-} test_structure_3;
-
-typedef struct
-{
-  unsigned ui1;
-  unsigned ui2;
-  unsigned ui3;
-} test_structure_4;
-
-typedef struct
-{
-  char c1;
-  char c2;
-} test_structure_5;
-
-typedef struct
-{
-  float f;
-  double d;
-} test_structure_6;
-
-typedef struct
-{
-  float f1;
-  float f2;
-  double d;
-} test_structure_7;
-
-typedef struct
-{
-  float f1;
-  float f2;
-  float f3;
-  float f4;
-} test_structure_8;
-
-typedef struct
-{
-  float f;
-  int i;
-} test_structure_9;
-
-static test_structure_1 struct1(test_structure_1 ts)
-{
-  /*@-type@*/
-  ts.uc++;
-  /*@=type@*/
-  ts.d--;
-  ts.ui++;
-
-  return ts;
-}
-
-static test_structure_2 struct2(test_structure_2 ts)
-{
-  ts.d1--;
-  ts.d2--;
-
-  return ts;
-}
-
-static test_structure_3 struct3(test_structure_3 ts)
-{
-  ts.si = -(ts.si*2);
-
-  return ts;
-}
-
-static test_structure_4 struct4(test_structure_4 ts)
-{
-  ts.ui3 = ts.ui1 * ts.ui2 * ts.ui3;
-
-  return ts;
-}
-
-static test_structure_5 struct5(test_structure_5 ts1, test_structure_5 ts2)
-{
-  ts1.c1 += ts2.c1;
-  ts1.c2 -= ts2.c2;
-
-  return ts1;
-}
-
-static test_structure_6 struct6 (test_structure_6 ts)
-{
-  ts.f += 1;
-  ts.d += 1;
-
-  return ts;
-}
-
-static test_structure_7 struct7 (test_structure_7 ts)
-{
-  ts.f1 += 1;
-  ts.f2 += 1;
-  ts.d += 1;
-
-  return ts;
-}
-
-static test_structure_8 struct8 (test_structure_8 ts)
-{
-  ts.f1 += 1;
-  ts.f2 += 1;
-  ts.f3 += 1;
-  ts.f4 += 1;
-
-  return ts;
-}
-
-static test_structure_9 struct9 (test_structure_9 ts)
-{
-  ts.f += 1;
-  ts.i += 1;
-
-  return ts;
-}
-
-/* Take an int and a float argument, together with int userdata, and 	*/
-/* return the sum.							*/
-#if FFI_CLOSURES
-static void
-closure_test_fn(ffi_cif* cif,void* resp,void** args, void* userdata)
-{
-  *(ffi_arg*)resp =
-    (int)*(unsigned long long *)args[0] + (int)(*(int *)args[1]) +
-    (int)(*(unsigned long long *)args[2]) + (int)*(int *)args[3] +
-    (int)(*(signed short *)args[4]) +
-    (int)(*(unsigned long long *)args[5]) +
-    (int)*(int *)args[6] + (int)(*(int *)args[7]) +
-    (int)(*(double *)args[8]) + (int)*(int *)args[9] +
-    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +
-    (int)*(int *)args[12] + (int)(*(int *)args[13]) +
-    (int)(*(int *)args[14]) +  *(int *)args[15] + (int)(long)userdata;
-
-    	printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
-	       (int)*(unsigned long long *)args[0], (int)(*(int *)args[1]), 
-	       (int)(*(unsigned long long *)args[2]),
-	       (int)*(int *)args[3], (int)(*(signed short *)args[4]), 
-	       (int)(*(unsigned long long *)args[5]),
-	       (int)*(int *)args[6], (int)(*(int *)args[7]), 
-	       (int)(*(double *)args[8]), (int)*(int *)args[9],
-	       (int)(*(int *)args[10]), (int)(*(float *)args[11]),
-	       (int)*(int *)args[12], (int)(*(int *)args[13]), 
-	       (int)(*(int *)args[14]),*(int *)args[15],
-	       (int)(long)userdata, *(int*)resp);
-}
-
-typedef int (*closure_test_type)(unsigned long long, int, unsigned long long, 
-				 int, signed short, unsigned long long, int, 
-				 int, double, int, int, float, int, int, 
-				 int, int);
-
-static void closure_test_fn1(ffi_cif* cif,void* resp,void** args, 
-			     void* userdata)
- {
-    *(ffi_arg*)resp =
-      (int)*(float *)args[0] +(int)(*(float *)args[1]) + 
-      (int)(*(float *)args[2]) + (int)*(float *)args[3] +
-      (int)(*(signed short *)args[4]) + (int)(*(float *)args[5]) +
-      (int)*(float *)args[6] + (int)(*(int *)args[7]) + 
-      (int)(*(double*)args[8]) + (int)*(int *)args[9] + 
-      (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + 
-      (int)*(int *)args[12] + (int)(*(int *)args[13]) + 
-      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;
-
-    printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
-	   (int)*(float *)args[0], (int)(*(float *)args[1]), 
-	   (int)(*(float *)args[2]), (int)*(float *)args[3], 
-	   (int)(*(signed short *)args[4]), (int)(*(float *)args[5]),
-	   (int)*(float *)args[6], (int)(*(int *)args[7]),
-	   (int)(*(double *)args[8]), (int)*(int *)args[9],
-	   (int)(*(int *)args[10]), (int)(*(float *)args[11]),
-	   (int)*(int *)args[12], (int)(*(int *)args[13]),
-	   (int)(*(int *)args[14]), *(int *)args[15],
-	   (int)(long)userdata, *(int*)resp);
-}
-
-typedef int (*closure_test_type1)(float, float, float, float, signed short, 
-				  float, float, int, double, int, int, float,
-				  int, int, int, int);
-
-static void closure_test_fn2(ffi_cif* cif,void* resp,void** args, 
-			     void* userdata)
- {
-    *(ffi_arg*)resp =
-      (int)*(double *)args[0] +(int)(*(double *)args[1]) + 
-      (int)(*(double *)args[2]) + (int)*(double *)args[3] +
-      (int)(*(signed short *)args[4]) + (int)(*(double *)args[5]) +
-      (int)*(double *)args[6] + (int)(*(int *)args[7]) + 
-      (int)(*(double *)args[8]) + (int)*(int *)args[9] +
-      (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + 
-      (int)*(int *)args[12] + (int)(*(float *)args[13]) +
-      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;
-
-    printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
-	   (int)*(double *)args[0], (int)(*(double *)args[1]), 
-	   (int)(*(double *)args[2]), (int)*(double *)args[3], 
-	   (int)(*(signed short *)args[4]), (int)(*(double *)args[5]),
-	   (int)*(double *)args[6], (int)(*(int *)args[7]), 
-	   (int)(*(double*)args[8]), (int)*(int *)args[9], 
-	   (int)(*(int *)args[10]), (int)(*(float *)args[11]),
-	   (int)*(int *)args[12], (int)(*(float *)args[13]), 
-	   (int)(*(int *)args[14]), *(int *)args[15], (int)(long)userdata, 
-	   *(int*)resp);
- }
-
-typedef int (*closure_test_type2)(double, double, double, double, signed short,
-				  double, double, int, double, int, int, float,
-				  int, float, int, int);
-
-static void closure_test_fn3(ffi_cif* cif,void* resp,void** args,
-			     void* userdata)
- {
-    *(ffi_arg*)resp =
-      (int)*(float *)args[0] +(int)(*(float *)args[1]) + 
-      (int)(*(float *)args[2]) + (int)*(float *)args[3] +
-      (int)(*(float *)args[4]) + (int)(*(float *)args[5]) +
-      (int)*(float *)args[6] + (int)(*(float *)args[7]) + 
-      (int)(*(double *)args[8]) + (int)*(int *)args[9] +
-      (int)(*(float *)args[10]) + (int)(*(float *)args[11]) + 
-      (int)*(int *)args[12] + (int)(*(float *)args[13]) +
-      (int)(*(float *)args[14]) +  *(int *)args[15] + (int)(long)userdata;
-
-    printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\n",
-	   (int)*(float *)args[0], (int)(*(float *)args[1]), 
-	   (int)(*(float *)args[2]), (int)*(float *)args[3], 
-	   (int)(*(float *)args[4]), (int)(*(float *)args[5]),
-	   (int)*(float *)args[6], (int)(*(float *)args[7]), 
-	   (int)(*(double *)args[8]), (int)*(int *)args[9], 
-	   (int)(*(float *)args[10]), (int)(*(float *)args[11]),
-	   (int)*(int *)args[12], (int)(*(float *)args[13]), 
-	   (int)(*(float *)args[14]), *(int *)args[15], (int)(long)userdata,
-	   *(int*)resp);
- }
-
-typedef int (*closure_test_type3)(float, float, float, float, float, float,
-				  float, float, double, int, float, float, int,
-				  float, float, int);
-#endif
-
-int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])
-{
-  ffi_cif cif;
-  ffi_type *args[MAX_ARGS];
-  void *values[MAX_ARGS];
-  char *s;
-  signed char sc;
-  unsigned char uc;
-  signed short ss;
-  unsigned short us;
-  unsigned long ul;
-  long long ll;
-  float f;
-  double d;
-  long double ld;
-  signed int si1;
-  signed int si2;
-
-  ffi_arg rint;
-  long long rlonglong;
-
-# if FFI_CLOSURES
-  /* The closure must not be an automatic variable on
-     platforms (Solaris) that forbid stack execution by default. */
-  static ffi_closure cl;
-#endif
-
-  ffi_type * cl_arg_types[17];
-
-  ffi_type ts1_type;
-  ffi_type ts2_type;
-  ffi_type ts3_type;
-  ffi_type ts4_type;  
-  ffi_type ts5_type;
-  ffi_type ts6_type;
-  ffi_type ts7_type;
-  ffi_type ts8_type;
-  ffi_type ts9_type;
-  ffi_type *ts1_type_elements[4];
-  ffi_type *ts2_type_elements[3];
-  ffi_type *ts3_type_elements[2];
-  ffi_type *ts4_type_elements[4];
-  ffi_type *ts5_type_elements[3];
-  ffi_type *ts6_type_elements[3];
-  ffi_type *ts7_type_elements[4];
-  ffi_type *ts8_type_elements[5];
-  ffi_type *ts9_type_elements[3];
-
-  ts1_type.size = 0;
-  ts1_type.alignment = 0;
-  ts1_type.type = FFI_TYPE_STRUCT;
-
-  ts2_type.size = 0;
-  ts2_type.alignment = 0;
-  ts2_type.type = FFI_TYPE_STRUCT;
-
-  ts3_type.size = 0;
-  ts3_type.alignment = 0;
-  ts3_type.type = FFI_TYPE_STRUCT;
-
-  ts4_type.size = 0;
-  ts4_type.alignment = 0;
-  ts4_type.type = FFI_TYPE_STRUCT;
-
-  ts5_type.size = 0;
-  ts5_type.alignment = 0;
-  ts5_type.type = FFI_TYPE_STRUCT;
-
-  ts6_type.size = 0;
-  ts6_type.alignment = 0;
-  ts6_type.type = FFI_TYPE_STRUCT;
-
-  ts7_type.size = 0;
-  ts7_type.alignment = 0;
-  ts7_type.type = FFI_TYPE_STRUCT;
-
-  ts8_type.size = 0;
-  ts8_type.alignment = 0;
-  ts8_type.type = FFI_TYPE_STRUCT;
-
-  ts9_type.size = 0;
-  ts9_type.alignment = 0;
-  ts9_type.type = FFI_TYPE_STRUCT;
-
-  /*@-immediatetrans@*/
-  ts1_type.elements = ts1_type_elements;
-  ts2_type.elements = ts2_type_elements;
-  ts3_type.elements = ts3_type_elements;
-  ts4_type.elements = ts4_type_elements;
-  ts5_type.elements = ts5_type_elements;
-  ts6_type.elements = ts6_type_elements;
-  ts7_type.elements = ts7_type_elements;
-  ts8_type.elements = ts8_type_elements;
-  ts9_type.elements = ts9_type_elements;
-  /*@=immediatetrans@*/
-  
-  ts1_type_elements[0] = &ffi_type_uchar;
-  ts1_type_elements[1] = &ffi_type_double;
-  ts1_type_elements[2] = &ffi_type_uint;
-  ts1_type_elements[3] = NULL;
-  
-  ts2_type_elements[0] = &ffi_type_double;
-  ts2_type_elements[1] = &ffi_type_double;
-  ts2_type_elements[2] = NULL;
-
-  ts3_type_elements[0] = &ffi_type_sint;
-  ts3_type_elements[1] = NULL;
-
-  ts4_type_elements[0] = &ffi_type_uint;
-  ts4_type_elements[1] = &ffi_type_uint;
-  ts4_type_elements[2] = &ffi_type_uint;
-  ts4_type_elements[3] = NULL;
-
-  ts5_type_elements[0] = &ffi_type_schar;
-  ts5_type_elements[1] = &ffi_type_schar;
-  ts5_type_elements[2] = NULL;
-
-  ts6_type_elements[0] = &ffi_type_float;
-  ts6_type_elements[1] = &ffi_type_double;
-  ts6_type_elements[2] = NULL;
-
-  ts7_type_elements[0] = &ffi_type_float;
-  ts7_type_elements[1] = &ffi_type_float;
-  ts7_type_elements[2] = &ffi_type_double;
-  ts7_type_elements[3] = NULL;
-
-  ts8_type_elements[0] = &ffi_type_float;
-  ts8_type_elements[1] = &ffi_type_float;
-  ts8_type_elements[2] = &ffi_type_float;
-  ts8_type_elements[3] = &ffi_type_float;
-  ts8_type_elements[4] = NULL;
-
-  ts9_type_elements[0] = &ffi_type_float;
-  ts9_type_elements[1] = &ffi_type_sint;
-  ts9_type_elements[2] = NULL;
-
-  ul = 0;
-
-  /* return value tests */
-  {
-#if defined(MIPS) /* || defined(ARM) */
-    puts ("long long tests not run. This is a known bug on this architecture.");
-#else
-    args[0] = &ffi_type_sint64;
-    values[0] = &ll;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_sint64, args) == FFI_OK);
-
-    for (ll = 0LL; ll < 100LL; ll++)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
-	CHECK(rlonglong == ll);
-      }
-
-    for (ll = 55555555555000LL; ll < 55555555555100LL; ll++)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
-	CHECK(rlonglong == ll);
-      }
-#endif
-
-    args[0] = &ffi_type_schar;
-    values[0] = &sc;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_schar, args) == FFI_OK);
-
-    for (sc = (signed char) -127; 
-	 sc < (signed char) 127; /*@-type@*/ sc++ /*@=type@*/)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_sc), &rint, values);
-	CHECK(rint == (ffi_arg) sc);
-      }
-
-    args[0] = &ffi_type_uchar;
-    values[0] = &uc;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_uchar, args) == FFI_OK);
-
-    for (uc = (unsigned char) '\x00'; 
-	 uc < (unsigned char) '\xff'; /*@-type@*/ uc++ /*@=type@*/)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_uc), &rint, values);
-	CHECK(rint == (signed int) uc);
-      }
-
-    printf("%lu return value tests run\n", ul);
-  }
-
-#ifdef BROKEN_LONG_DOUBLE
-  printf ("This architecture has broken `long double' support. No floating point\ntests have been run.\n");
-#else
-  /* float arg tests */
-  {
-    args[0] = &ffi_type_float;
-    values[0] = &f;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_longdouble, args) == FFI_OK);
-
-    f = 3.14159;
-
-#if 0
-  /* This is ifdef'd out for now. long double support under SunOS/gcc
-     is pretty much non-existent.  You'll get the odd bus error in library
-     routines like printf().  */
-    printf ("%Lf\n", ldblit(f));
-#endif
-    ld = 666;
-    ffi_call(&cif, FFI_FN(ldblit), &ld, values);
-
-#if 0
-  /* This is ifdef'd out for now. long double support under SunOS/gcc
-     is pretty much non-existent.  You'll get the odd bus error in library
-     routines like printf().  */
-    printf ("%Lf, %Lf, %Lf, %Lf\n", ld, ldblit(f), ld - ldblit(f), LDBL_EPSILON);
-#endif
-
-    /* These are not always the same!! Check for a reasonable delta */
-    /*@-realcompare@*/
-    if (ld - ldblit(f) < LDBL_EPSILON)
-    /*@=realcompare@*/
-	puts("long double return value tests ok!");
-    else
-        CHECK(0);
-  }
-
-  /* float arg tests */
-  {
-    args[0] = &ffi_type_sint;
-    values[0] = &si1;
-    args[1] = &ffi_type_float;
-    values[1] = &f;
-    args[2] = &ffi_type_double;
-    values[2] = &d;
-    args[3] = &ffi_type_longdouble;
-    values[3] = &ld;
-    args[4] = &ffi_type_sint;
-    values[4] = &si2;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,
-		       &ffi_type_sint, args) == FFI_OK);
-
-    si1 = 6;
-    f = 3.14159;
-    d = (double)1.0/(double)3.0;
-    ld = 2.71828182846L;
-    si2 = 10;
-
-    floating (si1, f, d, ld, si2);
-
-    ffi_call(&cif, FFI_FN(floating), &rint, values);
-
-    printf ("%d vs %d\n", (int)rint, floating (si1, f, d, ld, si2));
-
-    CHECK(rint == floating(si1, f, d, ld, si2));
-
-    printf("float arg tests ok!\n");
-  }
-#endif
-
-  /* strlen tests */
-  {
-    args[0] = &ffi_type_pointer;
-    values[0] = (void*) &s;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_sint, args) == FFI_OK);
-
-    s = "a";
-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
-    CHECK(rint == 1);
-
-    s = "1234567";
-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
-    CHECK(rint == 7);
-
-    s = "1234567890123456789012345";
-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
-    CHECK(rint == 25);
-
-    printf("strlen tests passed\n");
-  }
-
-  /* float arg tests */
-  {
-    args[0] = &ffi_type_float;
-    values[0] = &f;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_double, args) == FFI_OK);
-
-    f = 3.14159;
-
-    ffi_call(&cif, FFI_FN(dblit), &d, values);
-
-    /* These are not always the same!! Check for a reasonable delta */
-    /*@-realcompare@*/
-    CHECK(d - dblit(f) < DBL_EPSILON);
-    /*@=realcompare@*/
-
-    printf("double return value tests ok!\n");
-  }
-
-  /* many arg tests */
-  {
-    float ff;
-    float fa[13];
-    
-    for (ul = 0; ul < 13; ul++)
-      {
-	args[ul] = &ffi_type_float;
-	values[ul] = &fa[ul];
-	fa[ul] = (float) ul;
-      }
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, 
-		       &ffi_type_float, args) == FFI_OK);
-
-    /*@-usedef@*/
-    ff = many (fa[0], fa[1],
-	       fa[2], fa[3],
-	       fa[4], fa[5],
-	       fa[6], fa[7],
-	       fa[8], fa[9],
-	       fa[10],fa[11],fa[12]);
-    /*@=usedef@*/
-
-    ffi_call(&cif, FFI_FN(many), &f, values);
-
-    /*@-realcompare@*/
-    if (f - ff < FLT_EPSILON)
-    /*@=realcompare@*/
-	printf("many arg tests ok!\n");
-    else
-#ifdef POWERPC
-	printf("many arg tests failed!  This is a gcc bug.\n");
-#else
-        CHECK(0);
-#endif
-  }
-
-  /* promotion tests */
-  {
-    args[0] = &ffi_type_schar;
-    args[1] = &ffi_type_sshort;
-    args[2] = &ffi_type_uchar;
-    args[3] = &ffi_type_ushort;
-    values[0] = &sc;
-    values[1] = &ss;
-    values[2] = &uc;
-    values[3] = &us;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, 
-		       &ffi_type_sint, args) == FFI_OK);
-
-    us = 0;
-    ul = 0;
-
-    for (sc = (signed char) -127; 
-	 sc <= (signed char) 120; /*@-type@*/ sc += 1 /*@=type@*/)
-      for (ss = -30000; ss <= 30000; ss += 10000)
-	for (uc = (unsigned char) 0; 
-	     uc <= (unsigned char) 200; /*@-type@*/ uc += 20 /*@=type@*/)
-	  for (us = 0; us <= 60000; us += 10000)
-	    {
-	      ul++;
-	      ffi_call(&cif, FFI_FN(promotion), &rint, values);
-	      CHECK((int)rint == (signed char) sc + (signed short) ss +
-		    (unsigned char) uc + (unsigned short) us);
-	    }
-    printf("%lu promotion tests run\n", ul);
-  }
-
-#ifndef X86_WIN32 /* Structures dont work on Win32 */
-
-  /* struct tests */
-  {
-    test_structure_1 ts1_arg;
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_1 *ts1_result = 
-      (test_structure_1 *) malloc (sizeof(test_structure_1));
-
-    args[0] = &ts1_type;
-    values[0] = &ts1_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ts1_type, args) == FFI_OK);
-
-    ts1_arg.uc = '\x01';
-    ts1_arg.d = 3.14159;
-    ts1_arg.ui = 555;
-
-    ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
-
-    CHECK(ts1_result->ui == 556);
-    CHECK(ts1_result->d == 3.14159 - 1);
-
-    puts ("structure test 1 ok!\n");
-
-    free (ts1_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_2 ts2_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_2 *ts2_result = 
-      (test_structure_2 *) malloc (sizeof(test_structure_2));
-
-    args[0] = &ts2_type;
-    values[0] = &ts2_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts2_type, args) == FFI_OK);
-
-    ts2_arg.d1 = 5.55;
-    ts2_arg.d2 = 6.66;
-
-    printf ("%g\n", ts2_result->d1);
-    printf ("%g\n", ts2_result->d2);
-
-    ffi_call(&cif, FFI_FN(struct2), ts2_result, values);
-
-    printf ("%g\n", ts2_result->d1);
-    printf ("%g\n", ts2_result->d2);
-    
-    CHECK(ts2_result->d1 == 5.55 - 1);
-    CHECK(ts2_result->d2 == 6.66 - 1);
-
-    printf("structure test 2 ok!\n");
-
-    free (ts2_result);
-  }
-
-  /* struct tests */
-  {
-    int compare_value;
-    test_structure_3 ts3_arg;
-    test_structure_3 *ts3_result = 
-      (test_structure_3 *) malloc (sizeof(test_structure_3));
-
-    args[0] = &ts3_type;
-    values[0] = &ts3_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ts3_type, args) == FFI_OK);
-
-    ts3_arg.si = -123;
-    compare_value = ts3_arg.si;
-
-    ffi_call(&cif, FFI_FN(struct3), ts3_result, values);
-
-    printf ("%d %d\n", ts3_result->si, -(compare_value*2));
-
-    if (ts3_result->si == -(ts3_arg.si*2))
-	puts ("structure test 3 ok!");
-    else
-      {
-	puts ("Structure test 3 found structure passing bug.");
-	puts ("  Current versions of GCC are not 100% compliant with the");
-	puts ("  n32 ABI.  There is a known problem related to passing");
-	puts ("  small structures.  Send a bug report to the gcc maintainers.");
-      }
-
-    free (ts3_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_4 ts4_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_4 *ts4_result = 
-      (test_structure_4 *) malloc (sizeof(test_structure_4));
-
-    args[0] = &ts4_type;
-    values[0] = &ts4_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts4_type, args) == FFI_OK);
-
-    ts4_arg.ui1 = 2;
-    ts4_arg.ui2 = 3;
-    ts4_arg.ui3 = 4;
-
-    ffi_call (&cif, FFI_FN(struct4), ts4_result, values);
-    
-    if (ts4_result->ui3 == 2U * 3U * 4U)
-      puts ("structure test 4 ok!");
-    else
-      puts ("Structure test 4 found GCC's structure passing bug.");
-
-    free (ts4_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_5 ts5_arg1, ts5_arg2;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_5 *ts5_result = 
-      (test_structure_5 *) malloc (sizeof(test_structure_5));
-
-    args[0] = &ts5_type;
-    args[1] = &ts5_type;
-    values[0] = &ts5_arg1;
-    values[1] = &ts5_arg2;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ts5_type, args) == FFI_OK);
-
-    ts5_arg1.c1 = 2;
-    ts5_arg1.c2 = 6;
-    ts5_arg2.c1 = 5;
-    ts5_arg2.c2 = 3;
-
-    ffi_call (&cif, FFI_FN(struct5), ts5_result, values);
-    
-    if (ts5_result->c1 == 7 
-	&& ts5_result->c2 == 3)
-      puts ("structure test 5 ok!");
-    else
-      puts ("Structure test 5 found GCC's structure passing bug.");
-
-    free (ts5_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_6 ts6_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_6 *ts6_result = 
-      (test_structure_6 *) malloc (sizeof(test_structure_6));
-
-    args[0] = &ts6_type;
-    values[0] = &ts6_arg;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts6_type, args) == FFI_OK);
-
-    ts6_arg.f = 5.55f;
-    ts6_arg.d = 6.66;
-
-    printf ("%g\n", ts6_arg.f);
-    printf ("%g\n", ts6_arg.d);
-
-    ffi_call(&cif, FFI_FN(struct6), ts6_result, values);
-
-    printf ("%g\n", ts6_result->f);
-    printf ("%g\n", ts6_result->d);
-
-    CHECK(ts6_result->f == 5.55f + 1);
-    CHECK(ts6_result->d == 6.66 + 1);
-
-    printf("structure test 6 ok!\n");
-
-    free (ts6_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_7 ts7_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_7 *ts7_result = 
-      (test_structure_7 *) malloc (sizeof(test_structure_7));
-
-    args[0] = &ts7_type;
-    values[0] = &ts7_arg;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts7_type, args) == FFI_OK);
-
-    ts7_arg.f1 = 5.55f;
-    ts7_arg.f2 = 55.5f;
-    ts7_arg.d = 6.66;
-
-    printf ("%g\n", ts7_arg.f1);
-    printf ("%g\n", ts7_arg.f2);
-    printf ("%g\n", ts7_arg.d);
-
-    ffi_call(&cif, FFI_FN(struct7), ts7_result, values);
-
-    printf ("%g\n", ts7_result->f1);
-    printf ("%g\n", ts7_result->f2);
-    printf ("%g\n", ts7_result->d);
-
-    CHECK(ts7_result->f1 == 5.55f + 1);
-    CHECK(ts7_result->f2 == 55.5f + 1);
-    CHECK(ts7_result->d == 6.66 + 1);
-
-    printf("structure test 7 ok!\n");
-
-    free (ts7_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_8 ts8_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_8 *ts8_result = 
-      (test_structure_8 *) malloc (sizeof(test_structure_8));
-
-    args[0] = &ts8_type;
-    values[0] = &ts8_arg;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts8_type, args) == FFI_OK);
-
-    ts8_arg.f1 = 5.55f;
-    ts8_arg.f2 = 55.5f;
-    ts8_arg.f3 = -5.55f;
-    ts8_arg.f4 = -55.5f;
-
-    printf ("%g\n", ts8_arg.f1);
-    printf ("%g\n", ts8_arg.f2);
-    printf ("%g\n", ts8_arg.f3);
-    printf ("%g\n", ts8_arg.f4);
-
-    ffi_call(&cif, FFI_FN(struct8), ts8_result, values);
-
-    printf ("%g\n", ts8_result->f1);
-    printf ("%g\n", ts8_result->f2);
-    printf ("%g\n", ts8_result->f3);
-    printf ("%g\n", ts8_result->f4);
-
-    CHECK(ts8_result->f1 == 5.55f + 1);
-    CHECK(ts8_result->f2 == 55.5f + 1);
-    CHECK(ts8_result->f3 == -5.55f + 1);
-    CHECK(ts8_result->f4 == -55.5f + 1);
-
-    printf("structure test 8 ok!\n");
-
-    free (ts8_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_9 ts9_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_9 *ts9_result = 
-      (test_structure_9 *) malloc (sizeof(test_structure_9));
-
-    args[0] = &ts9_type;
-    values[0] = &ts9_arg;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts9_type, args) == FFI_OK);
-
-    ts9_arg.f = 5.55f;
-    ts9_arg.i = 5;
-
-    printf ("%g\n", ts9_arg.f);
-    printf ("%d\n", ts9_arg.i);
-
-    ffi_call(&cif, FFI_FN(struct9), ts9_result, values);
-
-    printf ("%g\n", ts9_result->f);
-    printf ("%d\n", ts9_result->i);
-
-    CHECK(ts9_result->f == 5.55f + 1);
-    CHECK(ts9_result->i == 5 + 1);
-
-    printf("structure test 9 ok!\n");
-
-    free (ts9_result);
-  }
-
-#else
-  printf("Structure passing doesn't work on Win32.\n");
-#endif /* X86_WIN32 */
-
-#ifdef X86_WIN32
-  /* stdcall strlen tests */
-  {
-    args[0] = &ffi_type_pointer;
-    values[0] = (void*) &s;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 1,
-		       &ffi_type_sint, args) == FFI_OK);
-
-    s = "a";
-    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);
-    CHECK(rint == 1);
-
-    s = "1234567";
-    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);
-    CHECK(rint == 7);
-
-    s = "1234567890123456789012345";
-    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);
-    CHECK(rint == 25);
-
-    printf("stdcall strlen tests passed\n");
-  }
-
-  /* stdcall many arg tests */
-  {
-    float ff;
-    float fa[13];
-
-    for (ul = 0; ul < 13; ul++)
-      {
-	args[ul] = &ffi_type_float;
-	values[ul] = &fa[ul];
-	fa[ul] = (float) ul;
-      }
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 13,
-		       &ffi_type_float, args) == FFI_OK);
-
-    /*@-usedef@*/
-    ff =  stdcall_many(fa[0], fa[1],
-	       fa[2], fa[3],
-	       fa[4], fa[5],
-	       fa[6], fa[7],
-	       fa[8], fa[9],
-	       fa[10],fa[11],fa[12]);
-    /*@=usedef@*/
-
-    ffi_call(&cif, FFI_FN(stdcall_many), &f, values);
-
-    /*@-realcompare@*/
-    if (f - ff < FLT_EPSILON)
-    /*@=realcompare@*/
-	printf("stdcall many arg tests ok!\n");
-    else
-        CHECK(0);
-  }
-#endif /* X86_WIN32 */
-
-# if FFI_CLOSURES
-  /* A simple closure test */
-    {
-      (void) puts("\nEnter FFI_CLOSURES\n");
-
-      cl_arg_types[0] = &ffi_type_uint64;
-      cl_arg_types[1] = &ffi_type_uint;
-      cl_arg_types[2] = &ffi_type_uint64;
-      cl_arg_types[3] = &ffi_type_uint;
-      cl_arg_types[4] = &ffi_type_sshort;
-      cl_arg_types[5] = &ffi_type_uint64;
-      cl_arg_types[6] = &ffi_type_uint;
-      cl_arg_types[7] = &ffi_type_uint;
-      cl_arg_types[8] = &ffi_type_double;
-      cl_arg_types[9] = &ffi_type_uint;
-      cl_arg_types[10] = &ffi_type_uint;
-      cl_arg_types[11] = &ffi_type_float;
-      cl_arg_types[12] = &ffi_type_uint;
-      cl_arg_types[13] = &ffi_type_uint;
-      cl_arg_types[14] = &ffi_type_uint;
-      cl_arg_types[15] = &ffi_type_uint;
-      cl_arg_types[16] = NULL;   
-
-      /* Initialize the cif */
-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
-			 &ffi_type_sint, cl_arg_types) == FFI_OK);
-
-      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn,
-			     (void *) 3 /* userdata */) == FFI_OK);
-      
-      CHECK((*((closure_test_type)(&cl)))
-	    (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13, 
-	     19, 21, 1) == 680);
-    }
-
-    {
-
-      cl_arg_types[0] = &ffi_type_float;
-      cl_arg_types[1] = &ffi_type_float;
-      cl_arg_types[2] = &ffi_type_float;
-      cl_arg_types[3] = &ffi_type_float;
-      cl_arg_types[4] = &ffi_type_sshort;
-      cl_arg_types[5] = &ffi_type_float;
-      cl_arg_types[6] = &ffi_type_float;
-      cl_arg_types[7] = &ffi_type_uint;
-      cl_arg_types[8] = &ffi_type_double;
-      cl_arg_types[9] = &ffi_type_uint;
-      cl_arg_types[10] = &ffi_type_uint;
-      cl_arg_types[11] = &ffi_type_float;
-      cl_arg_types[12] = &ffi_type_uint;
-      cl_arg_types[13] = &ffi_type_uint;
-      cl_arg_types[14] = &ffi_type_uint;
-      cl_arg_types[15] = &ffi_type_uint;
-      cl_arg_types[16] = NULL;
-      
-      /* Initialize the cif */
-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
-			 &ffi_type_sint, cl_arg_types) == FFI_OK);
-
-      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn1,
-			     (void *) 3 /* userdata */)  == FFI_OK);
-      
-      CHECK((*((closure_test_type1)(&cl)))
-	    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,
-	     19, 21, 1) == 255);
-    }
-
-    {
-
-      cl_arg_types[0] = &ffi_type_double;
-      cl_arg_types[1] = &ffi_type_double;
-      cl_arg_types[2] = &ffi_type_double;
-      cl_arg_types[3] = &ffi_type_double;
-      cl_arg_types[4] = &ffi_type_sshort;
-      cl_arg_types[5] = &ffi_type_double;
-      cl_arg_types[6] = &ffi_type_double;
-      cl_arg_types[7] = &ffi_type_uint;
-      cl_arg_types[8] = &ffi_type_double;
-      cl_arg_types[9] = &ffi_type_uint;
-      cl_arg_types[10] = &ffi_type_uint;
-      cl_arg_types[11] = &ffi_type_float;
-      cl_arg_types[12] = &ffi_type_uint;
-      cl_arg_types[13] = &ffi_type_float;
-      cl_arg_types[14] = &ffi_type_uint;
-      cl_arg_types[15] = &ffi_type_uint;
-      cl_arg_types[16] = NULL;
-      
-      /* Initialize the cif */
-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
-			 &ffi_type_sint, cl_arg_types) == FFI_OK);
-
-      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn2,
-			     (void *) 3 /* userdata */) == FFI_OK);
-
-      CHECK((*((closure_test_type2)(&cl)))
-	    (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,
-	     19.0, 21, 1) == 255);
-
-    }
-
-    {
-
-      cl_arg_types[0] = &ffi_type_float;
-      cl_arg_types[1] = &ffi_type_float;
-      cl_arg_types[2] = &ffi_type_float;
-      cl_arg_types[3] = &ffi_type_float;
-      cl_arg_types[4] = &ffi_type_float;
-      cl_arg_types[5] = &ffi_type_float;
-      cl_arg_types[6] = &ffi_type_float;
-      cl_arg_types[7] = &ffi_type_float;
-      cl_arg_types[8] = &ffi_type_double;
-      cl_arg_types[9] = &ffi_type_uint;
-      cl_arg_types[10] = &ffi_type_float;
-      cl_arg_types[11] = &ffi_type_float;
-      cl_arg_types[12] = &ffi_type_uint;
-      cl_arg_types[13] = &ffi_type_float;
-      cl_arg_types[14] = &ffi_type_float;
-      cl_arg_types[15] = &ffi_type_uint;
-      cl_arg_types[16] = NULL;
-      
-      /* Initialize the cif */
-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
-			 &ffi_type_sint, cl_arg_types) == FFI_OK);
-
-      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn3,
-			     (void *) 3 /* userdata */)  == FFI_OK);
-      
-      CHECK((*((closure_test_type3)(&cl)))
-	    (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,
-	     19.19, 21.21, 1) == 135);
-    }
-
-    (void) puts("\nFinished FFI_CLOSURES\n");
-
-# endif
-
-  /* If we arrived here, all is good */
-  (void) puts("\nLooks good. No surprises.\n");
-
-  /*@-compdestroy@*/
-
-  return 0;
-}
-
diff --git a/libffi/src/pa/ffi.c b/libffi/src/pa/ffi.c
new file mode 100644
index 0000000..5c21fb1
--- /dev/null
+++ b/libffi/src/pa/ffi.c
@@ -0,0 +1,608 @@
+/* -----------------------------------------------------------------------
+   ffi.c - (c) 2003 Randolph Chung <tausq@debian.org>
+
+   HPPA Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+#define ROUND_UP(v, a)  (((size_t)(v) + (a) - 1) & ~((a) - 1))
+#define ROUND_DOWN(v, a)  (((size_t)(v) - (a) + 1) & ~((a) - 1))
+#define MIN_STACK_SIZE  64
+#define FIRST_ARG_SLOT  9
+#define DEBUG_LEVEL   0
+
+#define fldw(addr, fpreg) asm volatile ("fldw 0(%0), %%" #fpreg "L" : : "r"(addr) : #fpreg)
+#define fstw(fpreg, addr) asm volatile ("fstw %%" #fpreg "L, 0(%0)" : : "r"(addr))
+#define fldd(addr, fpreg) asm volatile ("fldd 0(%0), %%" #fpreg : : "r"(addr) : #fpreg)
+#define fstd(fpreg, addr) asm volatile ("fstd %%" #fpreg "L, 0(%0)" : : "r"(addr))
+
+#define debug(lvl, x...) do { if (lvl <= DEBUG_LEVEL) { printf(x); } } while (0)
+
+static inline int ffi_struct_type(ffi_type *t)
+{
+  size_t sz = t->size;
+
+  /* Small structure results are passed in registers,
+   * larger ones are passed by pointer.
+   */
+
+  if (sz <= 1)
+    return FFI_TYPE_UINT8;
+  else if (sz == 2)
+    return FFI_TYPE_UINT16;
+  else if (sz == 3)
+    return FFI_TYPE_SMALL_STRUCT1;
+  else if (sz == 4)
+    return FFI_TYPE_UINT32;
+  else if (sz <= 6)
+    return FFI_TYPE_SMALL_STRUCT2;
+  else if (sz <= 8)
+    return FFI_TYPE_UINT64;
+  else
+    return FFI_TYPE_STRUCT; /* else, we pass it by pointer.. */
+}
+
+/* PA has a downward growing stack, which looks like this:
+ *
+ * Offset
+ *      [ Variable args ]
+ * SP = (4*(n+9))       arg word N
+ * ...
+ * SP-52                arg word 4
+ *      [ Fixed args ]
+ * SP-48                arg word 3
+ * SP-44                arg word 2
+ * SP-40                arg word 1
+ * SP-36                arg word 0
+ *      [ Frame marker ]
+ * ...
+ * SP-20                RP
+ * SP-4                 previous SP
+ *
+ * First 4 non-FP 32-bit args are passed in gr26, gr25, gr24 and gr23
+ * First 2 non-FP 64-bit args are passed in register pairs, starting
+ *   on an even numbered register (i.e. r26/r25 and r24+r23)
+ * First 4 FP 32-bit arguments are passed in fr4L, fr5L, fr6L and fr7L
+ * First 2 FP 64-bit arguments are passed in fr5 and fr7
+ * The rest are passed on the stack starting at SP-52, but 64-bit
+ *   arguments need to be aligned to an 8-byte boundary
+ *
+ * This means we can have holes either in the register allocation,
+ * or in the stack.
+ */
+
+/* ffi_prep_args is called by the assembly routine once stack space
+ * has been allocated for the function's arguments
+ *
+ * The following code will put everything into the stack frame
+ * (which was allocated by the asm routine), and on return
+ * the asm routine will load the arguments that should be
+ * passed by register into the appropriate registers
+ *
+ * NOTE: We load floating point args in this function... that means we
+ * assume gcc will not mess with fp regs in here.
+ */
+
+/*@-exportheader@*/
+void ffi_prep_args_LINUX(UINT32 *stack, extended_cif *ecif, unsigned bytes)
+/*@=exportheader@*/
+{
+  register unsigned int i;
+  register ffi_type **p_arg;
+  register void **p_argv;
+  unsigned int slot = FIRST_ARG_SLOT - 1;
+  char *dest_cpy;
+
+  debug(1, "%s: stack = %p, ecif = %p, bytes = %u\n", __FUNCTION__, stack, ecif, bytes);
+
+  p_arg = ecif->cif->arg_types;
+  p_argv = ecif->avalue;
+
+  for (i = 0; i < ecif->cif->nargs; i++)
+    {
+      int type = (*p_arg)->type;
+
+      switch (type)
+	{
+	case FFI_TYPE_SINT8:
+	  slot++;
+	  *(SINT32 *)(stack - slot) = *(SINT8 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT8:
+	  slot++;
+	  *(UINT32 *)(stack - slot) = *(UINT8 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_SINT16:
+	  slot++;
+	  *(SINT32 *)(stack - slot) = *(SINT16 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT16:
+	  slot++;
+	  *(UINT32 *)(stack - slot) = *(UINT16 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_POINTER:
+	  slot++;
+	  debug(3, "Storing UINT32 %u in slot %u\n", *(UINT32 *)(*p_argv), slot);
+	  *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  slot += 2;
+	  if (slot & 1)
+	    slot++;
+
+	  *(UINT32 *)(stack - slot) = (*(UINT64 *)(*p_argv)) >> 32;
+	  *(UINT32 *)(stack - slot + 1) = (*(UINT64 *)(*p_argv)) & 0xffffffffUL;
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  /* First 4 args go in fr4L - fr7L */
+	  slot++;
+	  switch (slot - FIRST_ARG_SLOT)
+	    {
+	    case 0: fldw(*p_argv, fr4); break;
+	    case 1: fldw(*p_argv, fr5); break;
+	    case 2: fldw(*p_argv, fr6); break;
+	    case 3: fldw(*p_argv, fr7); break;
+	    default:
+	      /* other ones are just passed on the stack */
+	      debug(3, "Storing UINT32(float) in slot %u\n", slot);
+	      *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);
+	      break;
+	    }
+	    break;
+
+	case FFI_TYPE_DOUBLE:
+	  slot += 2;
+	  if (slot & 1)
+	    slot++;
+	  switch (slot - FIRST_ARG_SLOT + 1)
+	    {
+	      /* First 2 args go in fr5, fr7 */
+	    case 2: fldd(*p_argv, fr5); break;
+	    case 4: fldd(*p_argv, fr7); break;
+	    default:
+	      debug(3, "Storing UINT64(double) at slot %u\n", slot);
+	      *(UINT64 *)(stack - slot) = *(UINT64 *)(*p_argv);
+	      break;
+	    }
+	  break;
+
+	case FFI_TYPE_STRUCT:
+
+	  /* Structs smaller or equal than 4 bytes are passed in one
+	     register. Structs smaller or equal 8 bytes are passed in two
+	     registers. Larger structures are passed by pointer.  */
+
+	  if((*p_arg)->size <= 4) {
+	    slot++;
+	    dest_cpy = (char *)(stack - slot);
+	    dest_cpy += 4 - (*p_arg)->size;
+	    memcpy((char *)dest_cpy, (char *)*p_argv, (*p_arg)->size);
+	  } else if ((*p_arg)->size <= 8) {
+	    slot += 2;
+	    if (slot & 1)
+	      slot++;
+	    dest_cpy = (char *)(stack - slot);
+	    dest_cpy += 8 - (*p_arg)->size;
+	    memcpy((char *)dest_cpy, (char *)*p_argv, (*p_arg)->size);
+	  } else {
+	    slot++;
+	    *(UINT32 *)(stack - slot) = (UINT32)(*p_argv);
+	  }
+	  break;
+
+	default:
+	  FFI_ASSERT(0);
+	}
+
+      p_arg++;
+      p_argv++;
+    }
+
+  /* Make sure we didn't mess up and scribble on the stack */
+#if 1
+  {
+    int n;
+
+    debug(5, "Stack setup:\n");
+    for (n = 0; n < (bytes + 3) / 4; n++)
+      {
+	if ((n%4) == 0) { debug(5, "\n%08x: ", (unsigned int)(stack - n)); }
+	debug(5, "%08x ", *(stack - n));
+      }
+    debug(5, "\n");
+  }
+#endif
+
+  FFI_ASSERT(slot * 4 <= bytes);
+
+  return;
+}
+
+static void ffi_size_stack_LINUX(ffi_cif *cif)
+{
+  ffi_type **ptr;
+  int i;
+  int z = 0; /* # stack slots */
+
+  for (ptr = cif->arg_types, i = 0; i < cif->nargs; ptr++, i++)
+    {
+      int type = (*ptr)->type;
+
+      switch (type)
+	{
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  z += 2 + (z & 1); /* must start on even regs, so we may waste one */
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  z += 1; /* pass by ptr, callee will copy */
+	  break;
+
+	default: /* <= 32-bit values */
+	  z++;
+	}
+    }
+
+  /* We can fit up to 6 args in the default 64-byte stack frame,
+   * if we need more, we need more stack
+   */
+  if (z <= 6)
+    cif->bytes = MIN_STACK_SIZE; /* min stack size */
+  else
+    cif->bytes = 64 + ROUND_UP((z - 6) * sizeof(UINT32), MIN_STACK_SIZE);
+
+  debug(3, "Calculated stack size is %u bytes\n", cif->bytes);
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+    case FFI_TYPE_STRUCT:
+      /* For the return type we have to check the size of the structures.
+	 If the size is smaller or equal 4 bytes, the result is given back
+	 in one register. If the size is smaller or equal 8 bytes than we
+	 return the result in two registers. But if the size is bigger than
+	 8 bytes, we work with pointers.  */
+      cif->flags = ffi_struct_type(cif->rtype);
+      break;
+
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      cif->flags = FFI_TYPE_UINT64;
+      break;
+
+    default:
+      cif->flags = FFI_TYPE_INT;
+      break;
+    }
+
+  /* Lucky us, because of the weird PA ABI we get to do our
+   * own stack sizing....
+   */
+  switch (cif->abi)
+    {
+    case FFI_LINUX:
+      ffi_size_stack_LINUX(cif);
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+
+  return FFI_OK;
+}
+
+/*@-declundef@*/
+/*@-exportheader@*/
+extern void ffi_call_LINUX(void (*)(UINT32 *, extended_cif *, unsigned),
+			   /*@out@*/ extended_cif *,
+			   unsigned, unsigned,
+			   /*@out@*/ unsigned *,
+			   void (*fn)());
+/*@=declundef@*/
+/*@=exportheader@*/
+
+void ffi_call(/*@dependent@*/ ffi_cif *cif,
+	      void (*fn)(),
+	      /*@out@*/ void *rvalue,
+	      /*@dependent@*/ void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If the return value is a struct and we don't have a return */
+  /* value address then we need to make one                     */
+
+  if ((rvalue == NULL) &&
+      (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      /*@-sysunrecog@*/
+      ecif.rvalue = alloca(cif->rtype->size);
+      /*@=sysunrecog@*/
+    }
+  else
+    ecif.rvalue = rvalue;
+
+
+  switch (cif->abi)
+    {
+    case FFI_LINUX:
+      /*@-usedef@*/
+      debug(2, "Calling ffi_call_LINUX: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\n", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);
+      ffi_call_LINUX(ffi_prep_args_LINUX, &ecif, cif->bytes,
+		     cif->flags, ecif.rvalue, fn);
+      /*@=usedef@*/
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+#if FFI_CLOSURES
+/*
+ * This is more-or-less an inverse of ffi_call -- we have arguments on
+ * the stack, and we need to fill them into a cif structure and invoke
+ * the user function. This really ought to be in asm to make sure
+ * the compiler doesn't do things we don't expect...
+ */
+UINT32 ffi_closure_inner_LINUX(ffi_closure *closure, UINT32 *stack)
+{
+  ffi_cif *cif;
+  void **avalue;
+  void *rvalue;
+  UINT32 ret[2]; /* function can return up to 64-bits in registers */
+  ffi_type **p_arg;
+  char *tmp;
+  int i, avn, slot = FIRST_ARG_SLOT - 1;
+  register UINT32 r28 asm("r28");
+
+  cif = closure->cif;
+
+  /* if returning via structure, callee will write to our pointer */
+  if (cif->flags == FFI_TYPE_STRUCT)
+    rvalue = (void *)r28;
+  else
+    rvalue = &ret[0];
+
+  avalue = (void **)alloca(cif->nargs * sizeof(void *));
+  avn = cif->nargs;
+  p_arg = cif->arg_types;
+
+  for (i = 0; i < avn; i++)
+    {
+      int type = (*p_arg)->type;
+
+      switch (type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_POINTER:
+	  slot++;
+	  avalue[i] = (char *)(stack - slot) + sizeof(UINT32) - (*p_arg)->size;
+	  break;
+
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	  slot += 2;
+	  if (slot & 1)
+	    slot++;
+	  avalue[i] = (void *)(stack - slot);
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  slot++;
+	  switch (slot - FIRST_ARG_SLOT)
+	    {
+	    case 0: fstw(fr4, (void *)(stack - slot)); break;
+	    case 1: fstw(fr5, (void *)(stack - slot)); break;
+	    case 2: fstw(fr6, (void *)(stack - slot)); break;
+	    case 3: fstw(fr7, (void *)(stack - slot)); break;
+	    }
+	  avalue[i] = (void *)(stack - slot);
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  slot += 2;
+	  if (slot & 1)
+	    slot++;
+	  switch (slot - FIRST_ARG_SLOT + 1)
+	    {
+	    case 2: fstd(fr5, (void *)(stack - slot)); break;
+	    case 4: fstd(fr7, (void *)(stack - slot)); break;
+	    }
+	  avalue[i] = (void *)(stack - slot);
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  /* Structs smaller or equal than 4 bytes are passed in one
+	     register. Structs smaller or equal 8 bytes are passed in two
+	     registers. Larger structures are passed by pointer.  */
+	  if((*p_arg)->size <= 4) {
+	    slot++;
+	    avalue[i] = (void *)(stack - slot) + sizeof(UINT32) -
+	      (*p_arg)->size;
+	  } else if ((*p_arg)->size <= 8) {
+	    slot += 2;
+	    if (slot & 1)
+	      slot++;
+	    avalue[i] = (void *)(stack - slot) + sizeof(UINT64) -
+	      (*p_arg)->size;
+	  } else {
+	    slot++;
+	    avalue[i] = (void *) *(stack - slot);
+	  }
+	  break;
+
+	default:
+	  FFI_ASSERT(0);
+	}
+
+      p_arg++;
+    }
+
+  /* Invoke the closure.  */
+  (closure->fun) (cif, rvalue, avalue, closure->user_data);
+
+  debug(3, "after calling function, ret[0] = %d, ret[1] = %d\n", ret[0], ret[1]);
+
+  /* Store the result */
+  switch (cif->flags)
+    {
+    case FFI_TYPE_UINT8:
+      *(stack - FIRST_ARG_SLOT) = *(UINT8 *)&ret[0];
+      break;
+    case FFI_TYPE_SINT8:
+      *(stack - FIRST_ARG_SLOT) = *(SINT8 *)&ret[0];
+      break;
+    case FFI_TYPE_UINT16:
+      *(stack - FIRST_ARG_SLOT) = *(UINT16 *)&ret[0];
+      break;
+    case FFI_TYPE_SINT16:
+      *(stack - FIRST_ARG_SLOT) = *(SINT16 *)&ret[0];
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_UINT32:
+      *(stack - FIRST_ARG_SLOT) = *(UINT32 *)&ret[0];
+      break;
+    case FFI_TYPE_SINT32:
+      *(stack - FIRST_ARG_SLOT) = *(SINT32 *)&ret[0];
+      break;
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      *(stack - FIRST_ARG_SLOT) = *(UINT32 *)&ret[0];
+      *(stack - FIRST_ARG_SLOT - 1) = *(UINT32 *)&ret[1];
+      break;
+
+    case FFI_TYPE_DOUBLE:
+      fldd(rvalue, fr4);
+      break;
+
+    case FFI_TYPE_FLOAT:
+      fldw(rvalue, fr4);
+      break;
+
+    case FFI_TYPE_STRUCT:
+      /* Don't need a return value, done by caller.  */
+      break;
+
+    case FFI_TYPE_SMALL_STRUCT1:
+      tmp = (void*)(stack -  FIRST_ARG_SLOT);
+      tmp += 4 - cif->rtype->size;
+      memcpy((void*)tmp, &ret[0], cif->rtype->size);
+      break;
+
+    case FFI_TYPE_SMALL_STRUCT2:
+      *(stack - FIRST_ARG_SLOT) = ret[0];
+      *(stack - FIRST_ARG_SLOT - 1) = ret[1];
+      break;
+
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_VOID:
+      break;
+
+    default:
+      debug(0, "assert with cif->flags: %d\n",cif->flags);
+      FFI_ASSERT(0);
+      break;
+    }
+  return FFI_OK;
+}
+
+/* Fill in a closure to refer to the specified fun and user_data.  */
+/* cif specifies the argument and result types for fun.  */
+/* the cif must already be prep'ed */
+
+void ffi_closure_LINUX(void);
+
+ffi_status
+ffi_prep_closure (ffi_closure* closure,
+		  ffi_cif* cif,
+		  void (*fun)(ffi_cif*,void*,void**,void*),
+		  void *user_data)
+{
+  UINT32 *tramp = (UINT32 *)(closure->tramp);
+
+  FFI_ASSERT (cif->abi == FFI_LINUX);
+
+  /* Make a small trampoline that will branch to our
+   * handler function. Use PC-relative addressing.
+   */
+  tramp[0] = 0xeaa00000; /* b,l .+8, %r21     ; %r21 <- pc+8             */
+  tramp[1] = 0xd6a01c1e; /* depi 0,31,2,%r21  ; mask priv bits           */
+  tramp[2] = 0x4aa10028; /* ldw  20(%r21),%r1 ; load plabel              */
+  tramp[3] = 0x36b53ff1; /* ldo -8(%r21),%r21 ; get closure addr         */
+  tramp[4] = 0x0c201096; /* ldw  0(%r1),%r22  ; address of handler       */
+  tramp[5] = 0xeac0c000; /* bv	 %r0(%r22)    ; branch to handler        */
+  tramp[6] = 0x0c281093; /* ldw  4(%r1),%r19  ; GP of handler            */
+  tramp[7] = ((UINT32)(ffi_closure_LINUX) & ~2);
+
+  /* Flush d/icache -- have to flush up 2 two lines because of
+   * alignment
+   */
+  asm volatile (
+		"fdc 0(%0)\n"
+		"fdc %1(%0)\n"
+		"fic 0(%%sr4, %0)\n"
+		"fic %1(%%sr4, %0)\n"
+		: : "r"((unsigned long)tramp & ~31), "r"(32 /* stride */));
+
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+
+  return FFI_OK;
+}
+#endif
+
diff --git a/libffi/src/pa/linux.S b/libffi/src/pa/linux.S
new file mode 100644
index 0000000..b1974a8
--- /dev/null
+++ b/libffi/src/pa/linux.S
@@ -0,0 +1,310 @@
+/* -----------------------------------------------------------------------
+   linux.S - (c) 2003 Randolph Chung <tausq@debian.org>
+
+   HPPA Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+#define FFI_TYPE_SMALL_STRUCT1 -1
+#define FFI_TYPE_SMALL_STRUCT2 -2
+
+	.text
+	.align 4
+
+	/* void ffi_call_LINUX(void (*)(char *, extended_cif *),
+			       extended_cif *ecif,
+			       unsigned bytes,
+			       unsigned flags,
+			       unsigned *rvalue,
+			       void (*fn)());
+	 */
+
+	.export ffi_call_LINUX,code
+	.import ffi_prep_args_LINUX,code
+
+	.type ffi_call_LINUX, @function
+.LFB1:
+ffi_call_LINUX:
+	.proc
+	.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4
+	.entry
+	stw %rp, -20(%sp)
+	copy %r3, %r1
+.LCFI11:
+
+	copy %sp, %r3
+.LCFI12:
+
+	/* Setup the stack for calling prep_args...
+	   We want the stack to look like this:
+
+	   [ Previous stack                            ] <- %r3
+
+	   [ 64-bytes register save area               ] <- %r4
+
+	   [ Stack space for actual call, passed as    ] <- %arg0
+	   [     arg0 to ffi_prep_args_LINUX           ]
+
+	   [ Stack for calling prep_args               ] <- %sp
+	 */
+
+	stwm %r1, 64(%sp)
+	stw %r4, 12(%r3)
+.LCFI13:
+	copy %sp, %r4
+
+	addl %arg2, %r4, %arg0                  /* arg stack */
+	stw %arg3, -48(%r3)                     /* save flags; we need it later */
+
+	/* Call prep_args:
+	   %arg0(stack) -- set up above
+	   %arg1(ecif) -- same as incoming param
+	   %arg2(bytes) -- same as incoming param */
+	bl ffi_prep_args_LINUX,%r2
+	ldo 64(%arg0), %sp
+	ldo -64(%sp), %sp
+
+	/* now %sp should point where %arg0 was pointing */
+
+	/* Load the arguments that should be passed in registers */
+	/* The fp args were loaded by the prep_args function */
+	ldw -36(%sp), %arg0
+	ldw -40(%sp), %arg1
+	ldw -44(%sp), %arg2
+	ldw -48(%sp), %arg3
+
+	/* in case the function is going to return a structure
+	 * we need to give it a place to put the result...
+	 */
+	ldw -52(%r3), %ret0                     /* %ret0 <- rvalue */
+	ldw -56(%r3), %r22                      /* %r22 <- function to call */
+	bl $$dyncall, %r31                      /* Call the user function */
+	copy %r31, %rp
+
+	/* Prepare to store the result; we need to recover flags and rvalue */
+	ldw -48(%r3), %r21                      /* r21 <- flags */
+	ldw -52(%r3), %r20                      /* r20 <- rvalue */
+
+	/* Store the result according to the return type... */
+
+checksmst1:
+	comib,<>,n FFI_TYPE_SMALL_STRUCT1, %r21, checksmst2
+	/* There is maybe a better way to handle 3 byte structs.  */
+	SH2ADD %ret0,0,%ret0
+	SH2ADD %ret0,0,%ret0
+	SH2ADD %ret0,0,%ret0
+	SH2ADD %ret0,0,%ret0
+	b done
+	stw %ret0, 0(%r20)
+
+checksmst2:
+	comib,<>,n FFI_TYPE_SMALL_STRUCT2, %r21, checkint8
+	/* Up to now I don't have a way to handle 6/7 byte structs.
+	   The values are left bounded in the registers. In the struct
+	   itself they are left bounded.  */
+	stw %ret0, 0(%r20)
+	b done
+	stw %ret1, 4(%r20)
+
+checkint8:
+	comib,<>,n FFI_TYPE_UINT8, %r21, checkint16
+	b done
+	stb %ret0, 0(%r20)
+
+checkint16:
+	comib,<>,n FFI_TYPE_UINT16, %r21, checkint32
+	b done
+	sth %ret0, 0(%r20)
+
+checkint32:
+	comib,<>,n FFI_TYPE_UINT32, %r21, checkint
+	b done
+	stw %ret0, 0(%r20)
+
+checkint:
+	comib,<>,n FFI_TYPE_INT, %r21, checkll
+	b done
+	stw %ret0, 0(%r20)
+
+checkll:
+	comib,<>,n FFI_TYPE_UINT64, %r21, checkdbl
+	stw %ret0, 0(%r20)
+	b done
+	stw %ret1, 4(%r20)
+
+checkdbl:
+	comib,<>,n FFI_TYPE_DOUBLE, %r21, checkfloat
+	b done
+	fstd %fr4,0(%r20)
+
+checkfloat:
+	comib,<>,n FFI_TYPE_FLOAT, %r21, done
+	fstw %fr4L,0(%r20)
+
+	/* structure returns are either handled by one of the
+	 * INT/UINT64 cases above, or, if passed by pointer,
+	 * is handled by the callee
+	 */
+
+done:
+	/* all done, return */
+	copy %r4, %sp                           /* pop arg stack */
+	ldw 12(%r3), %r4
+	ldwm -64(%sp), %r3                      /* .. and pop stack */
+	ldw -20(%sp), %rp
+	bv %r0(%rp)
+	nop
+	.exit
+	.procend
+.LFE1:
+
+	/* void ffi_closure_LINUX(void);
+	 * Called with closure argument in %r21
+	 */
+	.export ffi_closure_LINUX,code
+	.import ffi_closure_inner_LINUX,code
+
+	.type ffi_closure_LINUX, @function
+.LFB2:
+ffi_closure_LINUX:
+	.proc
+	.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3
+	.entry
+
+	stw %rp, -20(%sp)
+.LCFI20:
+	copy %r3, %r1
+.LCFI21:
+	copy %sp, %r3
+.LCFI22:
+	stwm %r1, 64(%sp)
+
+	/* Put arguments onto the stack and call ffi_closure_inner */
+	stw %arg0, -36(%r3)
+	stw %arg1, -40(%r3)
+	stw %arg2, -44(%r3)
+	stw %arg3, -48(%r3)
+
+	copy %r21, %arg0
+	bl ffi_closure_inner_LINUX, %r2
+	copy %r3, %arg1
+
+	ldwm -64(%sp), %r3
+	ldw -20(%sp), %rp
+	ldw -36(%sp), %ret0
+	bv %r0(%r2)
+	ldw -40(%sp), %ret1
+
+	.exit
+	.procend
+.LFE2:
+
+	.section        ".eh_frame","aw",@progbits
+.Lframe1:
+	.word   .LECIE1-.LSCIE1 ;# Length of Common Information Entry
+.LSCIE1:
+	.word   0x0     ;# CIE Identifier Tag
+	.byte   0x1     ;# CIE Version
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.ascii "zR\0"   ;# CIE Augmentation
+#else
+	.ascii "\0"     ;# CIE Augmentation
+#endif
+	.uleb128 0x1    ;# CIE Code Alignment Factor
+	.sleb128 4      ;# CIE Data Alignment Factor
+	.byte   0x2     ;# CIE RA Column
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.uleb128  0x1   ;# Augmentation size
+	.byte	0x1b    ;# FDE Encoding (pcrel sdata4)
+#endif
+	.byte   0xc     ;# DW_CFA_def_cfa
+	.uleb128 0x1e
+	.uleb128 0x0
+	.align 4
+.LECIE1:
+.LSFDE1:
+	.word   .LEFDE1-.LASFDE1        ;# FDE Length
+.LASFDE1:
+	.word   .LASFDE1-.Lframe1       ;# FDE CIE offset
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.word   .LFB1-. ;# FDE initial location
+#else
+	.word   .LFB1   ;# FDE initial location
+#endif
+	.word   .LFE1-.LFB1     ;# FDE address range
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.uleb128 0x0    ;# Augmentation size
+#endif
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI11-.LFB1
+	.byte	0x83	;# DW_CFA_offset, column 0x3
+	.uleb128 0x0
+	.byte   0x11    ;# DW_CFA_offset_extended_sf; save r2 at [r30-20]
+	.uleb128 0x2
+	.sleb128 -5
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI12-.LCFI11
+	.byte   0xd     ;# DW_CFA_def_cfa_register = r3
+	.uleb128 0x3
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI13-.LCFI12
+	.byte	0x84	;# DW_CFA_offset, column 0x4
+	.uleb128 0x3
+
+	.align 4
+.LEFDE1:
+
+.LSFDE2:
+	.word   .LEFDE2-.LASFDE2        ;# FDE Length
+.LASFDE2:
+	.word   .LASFDE2-.Lframe1       ;# FDE CIE offset
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.word   .LFB2-. ;# FDE initial location
+#else
+	.word   .LFB2   ;# FDE initial location
+#endif
+	.word   .LFE2-.LFB2     ;# FDE address range
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.uleb128 0x0    ;# Augmentation size
+#endif
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI21-.LFB2
+	.byte   0x83    ;# DW_CFA_offset, column 0x3
+	.uleb128 0x0
+	.byte   0x11    ;# DW_CFA_offset_extended_sf
+	.uleb128 0x2
+	.sleb128 -5
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI12-.LCFI11
+	.byte   0xd     ;# DW_CFA_def_cfa_register = r3
+	.uleb128 0x3
+
+	.align 4
+.LEFDE2:
+
diff --git a/libffi/src/prep_cif.c b/libffi/src/prep_cif.c
index d3c89c3..06c45a4 100644
--- a/libffi/src/prep_cif.c
+++ b/libffi/src/prep_cif.c
@@ -104,7 +104,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,
   FFI_ASSERT(ffi_type_test(cif->rtype));
 
   /* x86-64 and s390 stack space allocation is handled in prep_machdep.  */
-#if !defined M68K && !defined __x86_64__ && !defined S390
+#if !defined M68K && !defined __x86_64__ && !defined S390 && !defined PA
   /* Make space for the return structure pointer */
   if (cif->rtype->type == FFI_TYPE_STRUCT
 #ifdef SPARC
@@ -123,7 +123,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,
       if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))
 	return FFI_BAD_TYPEDEF;
 
-#if !defined __x86_64__ && !defined S390
+#if !defined __x86_64__ && !defined S390 && !defined PA
 #ifdef SPARC
       if (((*ptr)->type == FFI_TYPE_STRUCT
 	   && ((*ptr)->size > 16 || cif->abi != FFI_V9))
