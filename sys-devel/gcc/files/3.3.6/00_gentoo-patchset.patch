diff --git a/ChangeLog b/ChangeLog
index 5e51807..a947665 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -8517,7 +8517,7 @@ Tue Dec 29 15:06:00 1992  Ian Lance Taylor  (ian@cygnus.com)
 	to i386-sco3.2v4.  Set TARGETS and CFLAGS for i386-sco3.2v4.
 	(all-cygnus, native, build-cygnus): Make
 	$(canonhost)-stamp-3stage-done, not $(host)....
-	* test-build.mk (stamp-3stage-compared): Use tail +10c for
+	* test-build.mk (stamp-3stage-compared): Use tail -c +10 for
 	i386-sco3.2v4.  Added else true to if command.
 
 Mon Dec 28 12:08:56 1992  Ken Raeburn  (raeburn@cygnus.com)
diff --git a/boehm-gc/config.guess b/boehm-gc/config.guess
index aa6ea3f..b789a16 100755
--- a/boehm-gc/config.guess
+++ b/boehm-gc/config.guess
@@ -340,7 +340,7 @@ EOF
 	echo m68k-sun-sunos${UNAME_RELEASE}
 	exit 0 ;;
     sun*:*:4.2BSD:*)
-	UNAME_RELEASE=`(head -1 /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	UNAME_RELEASE=`(head -n 1 /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
 	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
@@ -509,7 +509,7 @@ EOF
 	fi
 	exit 0 ;;
     *:AIX:*:[45])
-	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | head -1 | awk '{ print $1 }'`
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | head -n 1 | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
diff --git a/boehm-gc/configure b/boehm-gc/configure
index c0e262a..30c2526 100755
--- a/boehm-gc/configure
+++ b/boehm-gc/configure
@@ -1930,14 +1930,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
@@ -3097,7 +3090,11 @@ else
   toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
   toolexeclibdir='$(libdir)'
 fi
-toolexeclibdir=$toolexeclibdir/`$CC -print-multi-os-directory`
+multi_os_directory=`$CC -print-multi-os-directory`
+case $multi_os_directory in
+  .) ;; # Avoid trailing /.
+  *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;
+esac
 
 
 
diff --git a/boehm-gc/configure.in b/boehm-gc/configure.in
index caef479..fa95b58 100644
--- a/boehm-gc/configure.in
+++ b/boehm-gc/configure.in
@@ -278,7 +278,11 @@ else
   toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
   toolexeclibdir='$(libdir)'
 fi
-toolexeclibdir=$toolexeclibdir/`$CC -print-multi-os-directory`
+multi_os_directory=`$CC -print-multi-os-directory`
+case $multi_os_directory in
+  .) ;; # Avoid trailing /.
+  *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;
+esac
 AC_SUBST(toolexecdir)
 AC_SUBST(toolexeclibdir)
 
diff --git a/configure b/configure
index ce3b638..808f1a9 100755
--- a/configure
+++ b/configure
@@ -820,7 +820,7 @@ if [ -z "${CC}" ] && [ -r Makefile ]; then
 s/\\\n//g
 t loop
 /^CC[ 	]*=/ s/CC[ 	]*=[ 	]*\(.*\)/\1/p' < Makefile > Makefile.cc
-  CC=`tail -1 Makefile.cc`
+  CC=`tail -n 1 Makefile.cc`
   rm -f Makefile.cc
 fi
 
@@ -830,7 +830,7 @@ if [ -z "${CFLAGS}" ] && [ -r Makefile ]; then
 s/\\\n//g
 t loop
 /^CFLAGS[ 	]*=/ s/CFLAGS[ 	]*=[ 	]*\(.*\)/\1/p' < Makefile > Makefile.cc
-  CFLAGS=`tail -1 Makefile.cc`
+  CFLAGS=`tail -n 1 Makefile.cc`
   rm -f Makefile.cc
 fi
 
@@ -840,7 +840,7 @@ if [ -z "${CXX}" ] && [ -r Makefile ]; then
 s/\\\n//g
 t loop
 /^CXX[ 	]*=/ s/CXX[ 	]*=[ 	]*\(.*\)/\1/p' < Makefile > Makefile.cc
-  CXX=`tail -1 Makefile.cc`
+  CXX=`tail -n 1 Makefile.cc`
   rm -f Makefile.cc
 fi
 
@@ -850,7 +850,7 @@ if [ -z "${CXXFLAGS}" ] && [ -r Makefile ]; then
 s/\\\n//g
 t loop
 /^CXXFLAGS[ 	]*=/ s/CXXFLAGS[ 	]*=[ 	]*\(.*\)/\1/p' < Makefile > Makefile.cc
-  CXXFLAGS=`tail -1 Makefile.cc`
+  CXXFLAGS=`tail -n 1 Makefile.cc`
   rm -f Makefile.cc
 fi
 
@@ -931,7 +931,7 @@ s/\\\n//g
 t loop
 /^'"${var}"'[ 	]*=/ s/'"${var}"'[ 	]*=[ 	]*\(.*\)/\1/p' \
 	< Makefile > Makefile.v
-      t=`tail -1 Makefile.v`
+      t=`tail -n 1 Makefile.v`
       if [ -n "${t}" ]; then
 	eval "${var}=\${t}"
       fi
diff --git a/configure.in b/configure.in
index c72233e..3b0f2b5 100644
--- a/configure.in
+++ b/configure.in
@@ -902,36 +902,6 @@ if test x"${with_libs}" != x ; then
   fi
 fi
 
-# Handle ${copy_dirs}
-set fnord ${copy_dirs}
-shift
-while test $# != 0 ; do
-  if test -f $2/COPIED && test x"`cat $2/COPIED`" = x"$1" ; then
-    :
-  else
-    echo Copying $1 to $2
-
-    # Use the install script to create the directory and all required
-    # parent directories.
-    if test -d $2 ; then
-      :
-    else
-      echo >config.temp
-      ${srcdir}/install-sh -c -m 644 config.temp $2/COPIED
-    fi
-
-    # Copy the directory, assuming we have tar.
-    # FIXME: Should we use B in the second tar?  Not all systems support it.
-    (cd $1; tar -cf - .) | (cd $2; tar -xpf -)
-
-    # It is the responsibility of the user to correctly adjust all
-    # symlinks.  If somebody can figure out how to handle them correctly
-    # here, feel free to add the code.
-
-    echo $1 > $2/COPIED
-  fi
-  shift; shift
-done
 
 # Work in distributions that contain no compiler tools, like Autoconf.
 tentative_cc=""
diff --git a/contrib/test_summary b/contrib/test_summary
index 427a461..c964df9 100755
--- a/contrib/test_summary
+++ b/contrib/test_summary
@@ -98,7 +98,7 @@ $1 ~ /\/configure$/ {
     srcdir = $1;
     gsub(/\/configure$/, "", srcdir);
     printf "LAST_UPDATED: ";
-    system("tail -1 " srcdir "/LAST_UPDATED");
+    system("tail -n 1 " srcdir "/LAST_UPDATED");
     print "";
 
     $1 = "configure flags:"; configflags = $0;
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 4d10ffb..b63bd7f 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -323,8 +323,13 @@ exec_prefix = @exec_prefix@
 bindir = @bindir@
 # Directory in which to put the directories used by the compiler.
 libdir = @libdir@
+# Directory in which GCC puts its executables.
+libexecdir = @libexecdir@
+
 # Directory in which the compiler finds executables, libraries, etc.
 libsubdir = $(libdir)/gcc-lib/$(target_alias)/$(version)
+# Directory in which the compiler finds executables
+libexecsubdir = $(libexecdir)/gcc/$(target_alias)/$(version)
 # Used to produce a relative $(gcc_tooldir) in gcc.o
 unlibsubdir = ../../..
 # Directory in which to find other cross-compilation tools and headers.
@@ -408,8 +413,16 @@ CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \
 # Additional sources to handle exceptions; overridden by targets as needed.
 LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \
   $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c
+LIB2ADDEHSTATIC = $(LIB2ADDEH)
+LIB2ADDEHSHARED = $(LIB2ADDEH)
 LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h
 
+# Don't build libunwind by default.
+LIBUNWIND =
+LIBUNWINDDEP =
+SHLIBUNWIND_LINK =
+SHLIBUNWIND_INSTALL =
+
 # nm flags to list global symbols in libgcc object files.
 SHLIB_NM_FLAGS = -pg
 
@@ -718,6 +731,7 @@ ORDINARY_FLAGS_TO_PASS = \
 	"gcc_tooldir=$(gcc_tooldir)" \
 	"bindir=$(bindir)" \
 	"libsubdir=$(libsubdir)" \
+	"libexecsubdir=$(libsubdir)" \
 	"datadir=$(datadir)" \
 	"localedir=$(localedir)"
 FLAGS_TO_PASS = $(ORDINARY_FLAGS_TO_PASS) "CC=@cc_set_by_configure@" \
@@ -1034,7 +1048,13 @@ libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) $(LIB2ADD_ST) xgcc$(exeext
 	LIB2ADD='$(LIB2ADD)' \
 	LIB2ADD_ST='$(LIB2ADD_ST)' \
 	LIB2ADDEH='$(LIB2ADDEH)' \
+	LIB2ADDEHSTATIC='$(LIB2ADDEHSTATIC)' \
+	LIB2ADDEHSHARED='$(LIB2ADDEHSHARED)' \
 	LIB2ADDEHDEP='$(LIB2ADDEHDEP)' \
+	LIBUNWIND='$(LIBUNWIND)' \
+	LIBUNWINDDEP='$(LIBUNWINDDEP)' \
+	SHLIBUNWIND_LINK='$(SHLIBUNWIND_LINK)' \
+	SHLIBUNWIND_INSTALL='$(SHLIBUNWIND_INSTALL)' \
 	FPBIT='$(FPBIT)' \
 	FPBIT_FUNCS='$(FPBIT_FUNCS)' \
 	LIB2_DIVMOD_FUNCS='$(LIB2_DIVMOD_FUNCS)' \
@@ -1254,7 +1274,8 @@ tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) \
 c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(OBSTACK_H) \
 	$(C_COMMON_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \
 	$(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def $(TARGET_H) \
-	diagnostic.h except.h gt-c-common.h real.h langhooks.h c-tree.h
+	diagnostic.h except.h gt-c-common.h real.h langhooks.h c-tree.h \
+	input.h
 c-pretty-print.o : c-pretty-print.c c-pretty-print.h pretty-print.h \
 	$(C_COMMON_H) $(CONFIG_H) $(SYSTEM_H) real.h
 
@@ -1282,6 +1303,7 @@ c-dump.o : c-dump.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) tree-dump.h
 DRIVER_DEFINES = \
   -DSTANDARD_STARTFILE_PREFIX=\"$(unlibsubdir)/\" \
   -DSTANDARD_EXEC_PREFIX=\"$(libdir)/gcc-lib/\" \
+  -DSTANDARD_LIBEXEC_PREFIX=\"$(libexecdir)/gcc/\" \
   -DDEFAULT_TARGET_VERSION=\"$(version)\" \
   -DDEFAULT_TARGET_MACHINE=\"$(target_alias)\" \
   -DSTANDARD_BINDIR_PREFIX=\"$(bindir)/\" \
@@ -1453,7 +1475,7 @@ except.o : except.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \
 expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h \
    $(REGS_H) $(EXPR_H) $(OPTABS_H) libfuncs.h insn-attr.h insn-config.h \
    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \
-   except.h reload.h $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h
+   except.h reload.h $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h input.h
 builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \
    $(TARGET_H) function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) insn-config.h \
    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \
@@ -2341,6 +2363,9 @@ stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) xlimits.h
 	rm -f include/limits.h
 	cp xlimits.h include/limits.h
 	chmod a+r include/limits.h
+	if [ x"$(STMP_FIXINC)" = x ]; then \
+	  cp $(srcdir)/gsyslimits.h include/syslimits.h; \
+	fi
 # Install the README
 	rm -f include/README
 	cp $(srcdir)/README-fixinc include/README
@@ -2365,6 +2390,7 @@ fixinc.sh: $(FIXINCSRCDIR)/mkfixinc.sh $(FIXINCSRCDIR)/fixincl.c \
 	(MAKE="$(MAKE)"; srcdir=`cd $(srcdir)/fixinc && ${PWD_COMMAND}` ; \
 	CC="$(HOST_CC)"; CFLAGS="$(HOST_CFLAGS)"; LDFLAGS="$(HOST_LDFLAGS)"; \
 	WARN_CFLAGS="$(WARN_CFLAGS)"; LIBERTY=`pwd`/"$(BUILD_LIBIBERTY)"; \
+	SHELL="$(SHELL)"; export SHELL; \
 	export MAKE srcdir CC CFLAGS LDFLAGS WARN_CFLAGS LIBERTY; \
 	cd ./fixinc && \
 	$(SHELL) $${srcdir}/mkfixinc.sh $(build_canonical) $(target))
@@ -2664,7 +2690,9 @@ mostlyclean: $(INTL_MOSTLYCLEAN) lang.mostlyclean
 # that don't exist in the distribution.
 INTL_CLEAN = intl.clean
 clean: mostlyclean $(INTL_CLEAN) lang.clean
-	-rm -f libgcc.a libgcc_eh.a libgcc_s$(SHLIB_EXT) libgcc_s$(SHLIB_EXT).1
+	-rm -f libgcc.a libgcc_eh.a
+	-rm -f libunwind*
+	-rm -f libgcc_s*
 	-rm -f config.h tconfig.h hconfig.h tm_p.h
 	-rm -f cs-*
 	-rm -rf libgcc
@@ -2810,7 +2838,7 @@ install-common: native $(EXTRA_PARTS) lang.install-common
 	  else true; fi; \
 	done
 # Don't mess with specs if it doesn't exist yet.
-	-if [ -f specs ] ; then \
+	-if [ -f specs ] && [ x"$(STMP_FIXINC)" != x ] ; then \
 	  rm -f $(DESTDIR)$(libsubdir)/specs; \
 	  $(INSTALL_DATA) specs $(DESTDIR)$(libsubdir)/specs; \
 	  chmod a-x $(DESTDIR)$(libsubdir)/specs; \
@@ -3486,16 +3514,16 @@ compare compare3 compare4 compare-lean compare3-lean compare4-lean: force
 	-rm -f .bad_compare
 	case "$@" in compare | compare-lean ) stage=2 ;; * ) stage=`echo $@ | sed -e 's,^compare\([0-9][0-9]*\).*,\1,'` ;; esac; \
 	for file in *$(objext); do \
-	  tail +16c ./$$file > tmp-foo1; \
-	  tail +16c stage$$stage/$$file > tmp-foo2 \
+	  tail -c +16 ./$$file > tmp-foo1; \
+	  tail -c +16 stage$$stage/$$file > tmp-foo2 \
 	    && (cmp tmp-foo1 tmp-foo2 > /dev/null 2>&1 || echo $$file differs >> .bad_compare) || true; \
 	done
 	case "$@" in compare | compare-lean ) stage=2 ;; * ) stage=`echo $@ | sed -e 's,^compare\([0-9][0-9]*\).*,\1,'` ;; esac; \
 	for dir in tmp-foo intl $(SUBDIRS); do \
 	  if [ "`echo $$dir/*$(objext)`" != "$$dir/*$(objext)" ] ; then \
 	    for file in $$dir/*$(objext); do \
-	      tail +16c ./$$file > tmp-foo1; \
-	      tail +16c stage$$stage/$$file > tmp-foo2 \
+	      tail -c +16 ./$$file > tmp-foo1; \
+	      tail -c +16 stage$$stage/$$file > tmp-foo2 \
 	        && (cmp tmp-foo1 tmp-foo2 > /dev/null 2>&1 || echo $$file differs >> .bad_compare) || true; \
 	    done; \
 	  else true; fi; \
@@ -3561,6 +3589,7 @@ stage1-start:
 	-if [ -f ld$(exeext) ] ; then (cd stage1 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
 	-if [ -f collect-ld$(exeext) ] ; then (cd stage1 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
 	-rm -f stage1/libgcc.a stage1/libgcc_eh.a stage1/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage1/libunwind.a stage1/libunwind*$(SHLIB_EXT)
 	-cp libgcc.a stage1
 	-if $(RANLIB_TEST_FOR_TARGET) ; then \
 	  $(RANLIB_FOR_TARGET) stage1/libgcc.a; \
@@ -3570,6 +3599,7 @@ stage1-start:
 	   $(RANLIB_FOR_TARGET) stage1/libgcc_eh.a; \
 	  else true; fi; fi
 	-cp libgcc_s*$(SHLIB_EXT) stage1/
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage1
 	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
 	  cp stage1/$${f} . ; \
 	else true; \
@@ -3591,6 +3621,7 @@ stage2-start:
 	-if [ -f ld$(exeext) ] ; then (cd stage2 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
 	-if [ -f collect-ld$(exeext) ] ; then (cd stage2 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
 	-rm -f stage2/libgcc.a stage2/libgcc_eh.a stage2/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage2/libunwind.a stage2/libunwind*$(SHLIB_EXT)
 	-cp libgcc.a stage2
 	-if $(RANLIB_TEST_FOR_TARGET) ; then \
 	  $(RANLIB_FOR_TARGET) stage2/libgcc.a; \
@@ -3600,6 +3631,7 @@ stage2-start:
 	   $(RANLIB_FOR_TARGET) stage2/libgcc_eh.a; \
 	  else true; fi; fi
 	-cp libgcc_s*$(SHLIB_EXT) stage2/
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage2
 	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
 	  cp stage2/$${f} . ; \
 	else true; \
@@ -3621,6 +3653,7 @@ stage3-start:
 	-if [ -f ld$(exeext) ] ; then (cd stage3 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
 	-if [ -f collect-ld$(exeext) ] ; then (cd stage3 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
 	-rm -f stage3/libgcc.a stage3/libgcc_eh.a stage3/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage3/libunwind.a stage3/libunwind*$(SHLIB_EXT)
 	-cp libgcc.a stage3
 	-if $(RANLIB_TEST_FOR_TARGET) ; then \
 	  $(RANLIB_FOR_TARGET) stage3/libgcc.a; \
@@ -3630,6 +3663,7 @@ stage3-start:
 	   $(RANLIB_FOR_TARGET) stage3/libgcc_eh.a; \
 	  else true; fi; fi
 	-cp libgcc_s*$(SHLIB_EXT) stage3/
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage3
 	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
 	  cp stage3/$${f} . ; \
 	else true; \
@@ -3651,6 +3685,7 @@ stage4-start:
 	-if [ -f ld$(exeext) ] ; then (cd stage4 && $(LN_S) ../ld$(exeext) .) ; else true ; fi
 	-if [ -f collect-ld$(exeext) ] ; then (cd stage4 && $(LN_S) ../collect-ld$(exeext) .) ; else true ; fi
 	-rm -f stage4/libgcc.a stage4/libgcc_eh.a stage4/libgcc_s*$(SHLIB_EXT)
+	-rm -f stage4/libunwind.a stage4/libunwind*$(SHLIB_EXT)
 	-cp libgcc.a stage4
 	-if $(RANLIB_TEST_FOR_TARGET) ; then \
 	  $(RANLIB_FOR_TARGET) stage4/libgcc.a; \
@@ -3660,6 +3695,7 @@ stage4-start:
 	   $(RANLIB_FOR_TARGET) stage4/libgcc_eh.a; \
 	  else true; fi; fi
 	-cp libgcc_s*$(SHLIB_EXT) stage4/
+	-cp libunwind.a libunwind*$(SHLIB_EXT) stage4
 	-for f in .. $(EXTRA_MULTILIB_PARTS); do if [ x$${f} != x.. ]; then \
 	  cp stage4/$${f} . ; \
 	else true; \
diff --git a/gcc/c-common.c b/gcc/c-common.c
index b40a35a..6ec6764 100644
--- a/gcc/c-common.c
+++ b/gcc/c-common.c
@@ -40,6 +40,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 #include "except.h"		/* For USING_SJLJ_EXCEPTIONS.  */
 #include "tree-inline.h"
 #include "c-tree.h"
+#include "input.h"
 
 cpp_reader *parse_in;		/* Declared in c-pragma.h.  */
 
@@ -771,6 +772,8 @@ static tree handle_nothrow_attribute	PARAMS ((tree *, tree, tree, int,
 						 bool *));
 static tree handle_cleanup_attribute	PARAMS ((tree *, tree, tree, int,
 						 bool *));
+static tree handle_warn_unused_result_attribute  PARAMS ((tree *, tree, tree,
+							  int, bool *));
 static tree vector_size_helper PARAMS ((tree, tree));
 
 static void check_function_nonnull	PARAMS ((tree, tree));
@@ -861,6 +864,8 @@ const struct attribute_spec c_common_attribute_table[] =
   { "may_alias",	      0, 0, false, true, false, NULL },
   { "cleanup",		      1, 1, true, false, false,
 			      handle_cleanup_attribute },
+  { "warn_unused_result",     0, 0, false, true, true,
+			      handle_warn_unused_result_attribute },
   { NULL,                     0, 0, false, false, false, NULL }
 };
 
@@ -4246,6 +4251,26 @@ c_expand_expr (exp, target, tmode, modifier)
 	bool preserve_result = false;
 	bool return_target = false;
 
+	if (STMT_EXPR_WARN_UNUSED_RESULT (exp) && target == const0_rtx)
+	  {
+	    tree stmt = STMT_EXPR_STMT (exp);
+	    tree scope;
+
+	    for (scope = COMPOUND_BODY (stmt);
+		 scope && TREE_CODE (scope) != SCOPE_STMT;
+		 scope = TREE_CHAIN (scope));
+
+	    if (scope && SCOPE_STMT_BLOCK (scope))
+	      warning_with_file_and_line (expr_wfl_stack->name,
+					  expr_wfl_stack->line, "\
+ignoring return value of `%D', declared with attribute warn_unused_result",
+			BLOCK_ABSTRACT_ORIGIN (SCOPE_STMT_BLOCK (scope)));
+	    else
+	      warning_with_file_and_line (expr_wfl_stack->name,
+					  expr_wfl_stack->line, "\
+ignoring return value of function declared with attribute warn_unused_result");
+	  }
+
 	/* Since expand_expr_stmt calls free_temp_slots after every
 	   expression statement, we must call push_temp_slots here.
 	   Otherwise, any temporaries in use now would be considered
@@ -6190,6 +6215,26 @@ handle_deprecated_attribute (node, name, args, flags, no_add_attrs)
   return NULL_TREE;
 }
 
+/* Handle a "warn_unused_result" attribute.  No special handling.  */
+
+static tree
+handle_warn_unused_result_attribute (node, name, args, flags, no_add_attrs)
+     tree *node;
+     tree name;
+     tree args ATTRIBUTE_UNUSED;
+     int flags ATTRIBUTE_UNUSED;
+     bool *no_add_attrs;
+{
+  /* Ignore the attribute for functions not returning any value.  */
+  if (VOID_TYPE_P (TREE_TYPE (*node)))
+    {
+      warning ("`%s' attribute ignored", IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
 /* Keep a list of vector type nodes we created in handle_vector_size_attribute,
    to prevent us from duplicating type nodes unnecessarily.
    The normal mechanism to prevent duplicates is to use type_hash_canon, but
diff --git a/gcc/c-common.h b/gcc/c-common.h
index 1f59ebd..7bd19fe 100644
--- a/gcc/c-common.h
+++ b/gcc/c-common.h
@@ -39,6 +39,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
    2: STMT_LINENO_FOR_FN_P (in _STMT)
    3: SCOPE_NO_CLEANUPS_P (in SCOPE_STMT)
       COMPOUND_STMT_BODY_BLOCK (in COMPOUND_STMT)
+      STMT_EXPR_WARN_UNUSED_RESULT (in STMT_EXPR)
    4: SCOPE_PARTIAL_P (in SCOPE_STMT)
 */
 
@@ -1028,6 +1029,11 @@ extern tree strip_array_types                   PARAMS ((tree));
 #define STMT_EXPR_NO_SCOPE(NODE) \
    TREE_LANG_FLAG_0 (STMT_EXPR_CHECK (NODE))
 
+/* Nonzero if this statement-expression should cause warning if its result
+   is not used.  */
+#define STMT_EXPR_WARN_UNUSED_RESULT(NODE) \
+   TREE_LANG_FLAG_3 (STMT_EXPR_CHECK (NODE))
+
 /* LABEL_STMT accessor. This gives access to the label associated with
    the given label statement.  */
 #define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (LABEL_STMT_CHECK (NODE), 0)
diff --git a/gcc/c-parse.in b/gcc/c-parse.in
index 2912541..ac7947b 100644
--- a/gcc/c-parse.in
+++ b/gcc/c-parse.in
@@ -58,6 +58,11 @@ end ifobjc
 /* Like YYERROR but do call yyerror.  */
 #define YYERROR1 { yyerror ("syntax error"); YYERROR; }
 
+/* Newer bison doesn't define YYLEX anymore.  */
+#ifndef YYLEX
+# define YYLEX yylex()
+#endif
+
 /* Like the default stack expander, except (1) use realloc when possible,
    (2) impose no hard maxiumum on stack size, (3) REALLY do not use alloca.
 
diff --git a/gcc/calls.c b/gcc/calls.c
index 675674e..17092f6 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -2273,13 +2273,27 @@ expand_call (exp, target, ignore)
 	  (*lang_hooks.mark_addressable) (fndecl);
 	}
 
+      if (ignore
+	  && lookup_attribute ("warn_unused_result",
+			       TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))
+	warning ("\
+ignoring return value of `%D', declared with attribute warn_unused_result",
+		 fndecl);
+
       flags |= flags_from_decl_or_type (fndecl);
     }
 
   /* If we don't have specific function to call, see if we have a
      attributes set in the type.  */
   else
-    flags |= flags_from_decl_or_type (TREE_TYPE (TREE_TYPE (p)));
+    {
+      if (ignore
+	  && lookup_attribute ("warn_unused_result",
+			       TYPE_ATTRIBUTES (TREE_TYPE (TREE_TYPE (p)))))
+	warning ("\
+ignoring return value of function declared with attribute warn_unused_result");
+	flags |= flags_from_decl_or_type (TREE_TYPE (TREE_TYPE (p)));
+    }
 
 #ifdef REG_PARM_STACK_SPACE
 #ifdef MAYBE_REG_PARM_STACK_SPACE
diff --git a/gcc/collect2.c b/gcc/collect2.c
index c901179..c2806a7 100644
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -32,6 +32,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 #if ! defined( SIGCHLD ) && defined( SIGCLD )
 #  define SIGCHLD SIGCLD
 #endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
 
 #ifdef vfork /* Autoconf may define this to fork for us.  */
 # define VFORK_STRING "fork"
@@ -1572,7 +1578,7 @@ collect_execute (prog, argv, redir)
   if (redir)
     {
       /* Open response file.  */
-      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT);
+      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR);
 
       /* Duplicate the stdout and stderr file handles
 	 so they can be restored later.  */
@@ -1615,15 +1621,25 @@ fork_execute (prog, argv)
   do_wait (prog);
 }
 
-/* Unlink a file unless we are debugging.  */
-
+/* Unlink a file unless we are debugging or file is not normal.  */
+#ifndef S_ISLNK
+#ifdef S_IFLNK
+#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#else
+#define S_ISLNK(m) 0
+#define lstat stat
+#endif
+#endif
 static void
 maybe_unlink (file)
      const char *file;
 {
-  if (!debug)
-    unlink (file);
-  else
+  if (!debug) {
+    struct stat st;
+    if (lstat (file, &st) == 0
+        && (S_ISREG (st.st_mode) || S_ISLNK (st.st_mode)))
+      unlink (file);
+  } else
     notice ("[Leaving %s]\n", file);
 }
 
diff --git a/gcc/combine.c b/gcc/combine.c
index ff18634..cdee0d0 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -10863,7 +10863,7 @@ simplify_comparison (code, pop0, pop1)
 		      /* (A - C1) always sign-extends, like C2.  */
 		      && num_sign_bit_copies (a, inner_mode)
 			 > (unsigned int) (GET_MODE_BITSIZE (inner_mode)
-					   - mode_width - 1)))
+					   - (mode_width - 1))))
 		{
 		  op0 = SUBREG_REG (op0);
 		  continue;
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 7b242e9..a5e659a 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -699,6 +699,11 @@ arm*-*-netbsd*)
 	;;
 arm*-*-linux*)			# ARM GNU/Linux with ELF
 	tm_file="dbxelf.h elfos.h arm/elf.h arm/linux-gas.h arm/linux-elf.h arm/aout.h arm/arm.h"
+	case $target in
+	arm*b-*)
+		tm_defines="TARGET_BIG_ENDIAN_DEFAULT=1 $tm_defines"
+		;;
+	esac
 	tmake_file="t-slibgcc-elf-ver t-linux arm/t-linux"
 	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
 	gnu_ld=yes
@@ -1475,12 +1480,12 @@ ia64*-*-freebsd*)
 	;;
 ia64*-*-linux*)
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h ia64/sysv4.h ia64/linux.h"
-	tmake_file="t-slibgcc-elf-ver t-linux ia64/t-ia64 ia64/t-glibc"
+	tmake_file="t-slibgcc-elf-ver t-linux ia64/t-ia64 t-libunwind ia64/t-glibc"
+	if test x$with_system_libunwind != xyes ; then
+	  tmake_file="t-slibgcc-elf-ver t-linux ia64/t-ia64 t-libunwind-elf ia64/t-glibc-libunwind"
+	fi
 	target_cpu_default="MASK_GNU_AS|MASK_GNU_LD"
 	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtfastmath.o"
-	if test x"$use_libunwind_exceptions" = xyes; then
-	  tmake_file="$tmake_file t-libunwind"
-	fi
 	;;
 ia64*-*-hpux*)
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h ia64/sysv4.h ia64/hpux.h ia64/hpux_longdouble.h"
diff --git a/gcc/config.in b/gcc/config.in
index 748e7af..9ca4d49 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -228,6 +228,9 @@
 /* Define if you have the <langinfo.h> header file.  */
 #undef HAVE_LANGINFO_H
 
+/* Define if your linker supports -Bstatic/-Bdynamic option. */
+#undef HAVE_LD_STATIC_DYNAMIC
+
 /* Define if you have the <limits.h> header file.  */
 #undef HAVE_LIMITS_H
 
@@ -507,9 +510,6 @@
 /* Define 0/1 to force the choice for exception handling model. */
 #undef CONFIG_SJLJ_EXCEPTIONS
 
-/* Define if gcc should use -lunwind. */
-#undef USE_LIBUNWIND_EXCEPTIONS
-
 /* Define to the name of a file containing a list of extra machine modes
    for this architecture. */
 #undef EXTRA_MODES_FILE
diff --git a/gcc/config/alpha/alpha.h b/gcc/config/alpha/alpha.h
index 62e9f7b..f21e367 100644
--- a/gcc/config/alpha/alpha.h
+++ b/gcc/config/alpha/alpha.h
@@ -96,7 +96,7 @@ Boston, MA 02111-1307, USA.  */
   while (0)
 #endif
 
-#define CPP_SPEC "%(cpp_subtarget)"
+#define CPP_SPEC "%(cpp_subtarget) %{!no-ieee:-mieee}"
 
 #ifndef CPP_SUBTARGET_SPEC
 #define CPP_SUBTARGET_SPEC ""
@@ -294,6 +294,8 @@ extern int alpha_tls_size;
      N_("Request IEEE-conformant math library routines (OSF/1)")},	\
     {"ieee", MASK_IEEE|MASK_IEEE_CONFORMANT,				\
      N_("Emit IEEE-conformant code, without inexact exceptions")},	\
+    {"no-ieee", - (MASK_IEEE|MASK_IEEE_CONFORMANT),				\
+     N_("Do not emit IEEE-conformant code, without inexact exceptions")},	\
     {"ieee-with-inexact", MASK_IEEE_WITH_INEXACT|MASK_IEEE_CONFORMANT,	\
      N_("Emit IEEE-conformant code, with inexact exceptions")},		\
     {"build-constants", MASK_BUILD_CONSTANTS,				\
diff --git a/gcc/config/alpha/linux.h b/gcc/config/alpha/linux.h
index 3a2940c..c456b15 100644
--- a/gcc/config/alpha/linux.h
+++ b/gcc/config/alpha/linux.h
@@ -67,6 +67,7 @@ Boston, MA 02111-1307, USA.  */
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
+#ifndef inhibit_libc
 #ifdef IN_LIBGCC2
 #include <signal.h>
 #include <sys/ucontext.h>
@@ -88,8 +89,8 @@ Boston, MA 02111-1307, USA.  */
     else if (pc_[1] == 0x201f015f)	/* lda $0,NR_rt_sigreturn */	\
       {									\
 	struct rt_sigframe {						\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = &rt_->uc.uc_mcontext;					\
       }									\
@@ -116,3 +117,4 @@ Boston, MA 02111-1307, USA.  */
     (FS)->retaddr_column = 64;						\
     goto SUCCESS;							\
   } while (0)
+#endif /* inhibit_libc */
diff --git a/gcc/config/alpha/t-osf4 b/gcc/config/alpha/t-osf4
index 0525d61..ae0fdad 100644
--- a/gcc/config/alpha/t-osf4
+++ b/gcc/config/alpha/t-osf4
@@ -11,9 +11,13 @@ SHLIB_SONAME = @shlib_base_name@.so.1
 SHLIB_OBJS = @shlib_objs@
 
 SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
-	-Wl,-msym -Wl,-set_version,gcc.1 -Wl,-soname,$(SHLIB_SONAME) \
+	-Wl,-msym -Wl,-set_version,gcc.1 -Wl,-soname,$(SHLIB_SONAME).tmp \
 	-o $(SHLIB_NAME) @multilib_flags@ $(SHLIB_OBJS) -lc && \
 	rm -f $(SHLIB_SONAME) && \
+	if [ -f $(SHLIB_NAME) ]; then \
+	  mv -f $(SHLIB_NAME) $(SHLIB_NAME).backup; \
+	else true; fi && \
+	mv $(SHLIB_NAME).tmp $(SHLIB_NAME) && \
 	$(LN_S) $(SHLIB_NAME) $(SHLIB_SONAME)
 # $(slibdir) double quoted to protect it from expansion while building
 # libgcc.mk.  We want this delayed until actual install time.
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 9a70ab3..d64e1df 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -2368,6 +2368,40 @@ legitimate_pic_operand_p (x)
   return 1;
 }
 
+/* Return true if OP is a symbolic operand that resolves locally.  */
+
+static int
+local_symbolic_operand (op, mode)
+     rtx op;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+  if (GET_CODE (op) == CONST
+      && GET_CODE (XEXP (op, 0)) == PLUS
+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)
+    op = XEXP (XEXP (op, 0), 0);
+
+  if (GET_CODE (op) == LABEL_REF)
+    return 1;
+
+  if (GET_CODE (op) != SYMBOL_REF)
+    return 0;
+
+  /* These we've been told are local by varasm and encode_section_info
+     respectively.  */
+  if (CONSTANT_POOL_ADDRESS_P (op) || ENCODED_LOCAL_BINDING_ATTR_P (XSTR (op, 0)))
+    return 1;
+
+  /* There is, however, a not insubstantial body of code in the rest of
+     the compiler that assumes it can just stick the results of
+     ASM_GENERATE_INTERNAL_LABEL in a symbol_ref and have done.  */
+  /* ??? This is a hack.  Should update the body of the compiler to
+     always create a DECL an invoke targetm.encode_section_info.  */
+  if (strncmp (arm_strip_name_encoding (XSTR (op, 0)), ".L", 2) == 0)
+    return 1;
+
+  return 0;
+}
+
 rtx
 legitimize_pic_address (orig, mode, reg)
      rtx orig;
@@ -2408,10 +2442,7 @@ legitimize_pic_address (orig, mode, reg)
       else
 	emit_insn (gen_pic_load_addr_thumb (address, orig));
 
-      if ((GET_CODE (orig) == LABEL_REF
-	   || (GET_CODE (orig) == SYMBOL_REF && 
-	       ENCODED_SHORT_CALL_ATTR_P (XSTR (orig, 0))))
-	  && NEED_GOT_RELOC)
+      if (local_symbolic_operand (orig, Pmode) && NEED_GOT_RELOC)
 	pic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, address);
       else
 	{
@@ -7572,6 +7603,26 @@ arm_output_function_prologue (f, frame_size)
   return_used_this_function = 0;  
 }
 
+/* Return the number (counting from 0) of
+   the least significant set bit in MASK.  */
+
+#ifdef __GNUC__
+inline
+#endif
+static int
+number_of_first_bit_set (mask)
+     int mask;
+{
+  int bit;
+
+  for (bit = 0;
+       (mask & (1 << bit)) == 0;
+       ++bit)
+    continue;
+
+  return bit;
+}
+
 const char *
 arm_output_epilogue (really_return)
      int really_return;
@@ -7762,27 +7813,47 @@ arm_output_epilogue (really_return)
 	  saved_regs_mask |=   (1 << PC_REGNUM);
 	}
 
-      /* Load the registers off the stack.  If we only have one register
-	 to load use the LDR instruction - it is faster.  */
-      if (saved_regs_mask == (1 << LR_REGNUM))
+      if (saved_regs_mask)
 	{
-	  /* The exception handler ignores the LR, so we do
-	     not really need to load it off the stack.  */
-	  if (eh_ofs)
-	    asm_fprintf (f, "\tadd\t%r, %r, #4\n", SP_REGNUM, SP_REGNUM);
-	  else
-	    asm_fprintf (f, "\tldr\t%r, [%r], #4\n", LR_REGNUM, SP_REGNUM);
-	}
-      else if (saved_regs_mask)
-	{
-	  if (saved_regs_mask & (1 << SP_REGNUM))
-	    /* Note - write back to the stack register is not enabled
-	       (ie "ldmfd sp!...").  We know that the stack pointer is
-	       in the list of registers and if we add writeback the
-	       instruction becomes UNPREDICTABLE.  */
-	    print_multi_reg (f, "ldmfd\t%r", SP_REGNUM, saved_regs_mask);
+	  /* Load the registers off the stack.  If we only have one register
+	     to load use the LDR instruction - it is faster.  */
+	  if (bit_count (saved_regs_mask) == 1)
+	    {
+	      int reg = number_of_first_bit_set (saved_regs_mask);
+
+	      switch (reg)
+		{
+		case SP_REGNUM:
+		  /* Mustn't use base writeback when loading SP.  */
+		  asm_fprintf (f, "\tldr\t%r, [%r]\n", SP_REGNUM, SP_REGNUM);
+		  break;
+		  
+		case LR_REGNUM:
+		  if (eh_ofs)
+		    {
+		      /* The exception handler ignores the LR, so we do
+			 not really need to load it off the stack.  */
+		      asm_fprintf (f, "\tadd\t%r, %r, #4\n", SP_REGNUM, SP_REGNUM);
+		      break;
+		    }
+		  /* else fall through */
+		  
+		default:
+		  asm_fprintf (f, "\tldr\t%r, [%r], #4\n", reg, SP_REGNUM);
+		  break;
+		}
+	    }
 	  else
-	    print_multi_reg (f, "ldmfd\t%r!", SP_REGNUM, saved_regs_mask);
+	    {
+	      if (saved_regs_mask & (1 << SP_REGNUM))
+		/* Note - write back to the stack register is not enabled
+		   (ie "ldmfd sp!...").  We know that the stack pointer is
+		   in the list of registers and if we add writeback the
+		   instruction becomes UNPREDICTABLE.  */
+		print_multi_reg (f, "ldmfd\t%r", SP_REGNUM, saved_regs_mask);
+	      else
+		print_multi_reg (f, "ldmfd\t%r!", SP_REGNUM, saved_regs_mask);
+	    }
 	}
 
       if (current_function_pretend_args_size)
@@ -8814,11 +8885,7 @@ arm_assemble_integer (x, size, aligned_p)
       if (NEED_GOT_RELOC && flag_pic && making_const_table &&
 	  (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF))
 	{
-	  if (GET_CODE (x) == SYMBOL_REF
-	      && (CONSTANT_POOL_ADDRESS_P (x)
-		  || ENCODED_SHORT_CALL_ATTR_P (XSTR (x, 0))))
-	    fputs ("(GOTOFF)", asm_out_file);
-	  else if (GET_CODE (x) == LABEL_REF)
+	  if (local_symbolic_operand (x, Pmode))
 	    fputs ("(GOTOFF)", asm_out_file);
 	  else
 	    fputs ("(GOT)", asm_out_file);
@@ -9584,26 +9651,6 @@ replace_symbols_in_block (block, orig, new)
     }
 }
 
-/* Return the number (counting from 0) of
-   the least significant set bit in MASK.  */
-
-#ifdef __GNUC__
-inline
-#endif
-static int
-number_of_first_bit_set (mask)
-     int mask;
-{
-  int bit;
-
-  for (bit = 0;
-       (mask & (1 << bit)) == 0;
-       ++bit)
-    continue;
-
-  return bit;
-}
-
 /* Generate code to return from a thumb function.
    If 'reg_containing_return_addr' is -1, then the return address is
    actually on the stack, at the stack pointer.  */
@@ -11345,6 +11392,11 @@ arm_encode_section_info (decl, first)
       else if (! TREE_PUBLIC (decl))
         arm_encode_call_attribute (decl, SHORT_CALL_FLAG_CHAR);
     }
+
+  if (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd' 
+      && flag_pic 
+      && (*targetm.binds_local_p) (decl))
+    arm_encode_call_attribute (decl, LOCAL_BINDING_FLAG_CHAR);
 }
 #endif /* !ARM_PE */
 
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index 039960c..257eb9d 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -1870,6 +1870,7 @@ typedef struct
    Note, '@' and '*' have already been taken.  */
 #define SHORT_CALL_FLAG_CHAR	'^'
 #define LONG_CALL_FLAG_CHAR	'#'
+#define LOCAL_BINDING_FLAG_CHAR '%'
 
 #define ENCODED_SHORT_CALL_ATTR_P(SYMBOL_NAME)	\
   (*(SYMBOL_NAME) == SHORT_CALL_FLAG_CHAR)
@@ -1877,6 +1878,9 @@ typedef struct
 #define ENCODED_LONG_CALL_ATTR_P(SYMBOL_NAME)	\
   (*(SYMBOL_NAME) == LONG_CALL_FLAG_CHAR)
 
+#define ENCODED_LOCAL_BINDING_ATTR_P(SYMBOL_NAME) \
+  (*(SYMBOL_NAME) == LOCAL_BINDING_FLAG_CHAR)
+
 #ifndef SUBTARGET_NAME_ENCODING_LENGTHS
 #define SUBTARGET_NAME_ENCODING_LENGTHS
 #endif
@@ -1888,6 +1892,7 @@ typedef struct
 #define ARM_NAME_ENCODING_LENGTHS		\
   case SHORT_CALL_FLAG_CHAR: return 1;		\
   case LONG_CALL_FLAG_CHAR:  return 1;		\
+  case LOCAL_BINDING_FLAG_CHAR: return 1;	\
   case '*':  return 1;				\
   SUBTARGET_NAME_ENCODING_LENGTHS		
 
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index b6f5d64..fa62064 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -4275,7 +4275,7 @@
    (set (match_dup 2)
 	(ashiftrt:SI (match_operand 0 "" "") (const_int 8)))
    ;; store the high byte
-   (set (match_dup 4) (subreg:QI (match_dup 2) 0))]	;explicit subreg safe
+   (set (match_dup 4) (match_dup 5))]
   "TARGET_ARM"
   "
   {
@@ -4291,7 +4291,8 @@
     operands[1] = adjust_address (operands[1], QImode, 0);
     operands[3] = gen_lowpart (QImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
-    operands[2] = gen_reg_rtx (SImode); 
+    operands[2] = gen_reg_rtx (SImode);
+    operands[5] = gen_lowpart (QImode, operands[2]);
   }"
 )
 
@@ -4299,7 +4300,7 @@
   [(set (match_dup 4) (match_dup 3))
    (set (match_dup 2)
 	(ashiftrt:SI (match_operand 0 "" "") (const_int 8)))
-   (set (match_operand 1 "" "")	(subreg:QI (match_dup 2) 3))]
+   (set (match_operand 1 "" "")	(match_dup 5))]
   "TARGET_ARM"
   "
   {
@@ -4316,13 +4317,14 @@
     operands[3] = gen_lowpart (QImode, operands[0]);
     operands[0] = gen_lowpart (SImode, operands[0]);
     operands[2] = gen_reg_rtx (SImode);
+    operands[5] = gen_lowpart (QImode, operands[2]);
   }"
 )
 
 ;; Subroutine to store a half word integer constant into memory.
 (define_expand "storeinthi"
   [(set (match_operand 0 "" "")
-	(subreg:QI (match_operand 1 "" "") 0))
+	(match_operand 1 "" ""))
    (set (match_dup 3) (match_dup 2))]
   "TARGET_ARM"
   "
@@ -4363,6 +4365,7 @@
     operands[3] = adjust_address (op0, QImode, 1);
     operands[0] = adjust_address (operands[0], QImode, 0);
     operands[2] = gen_lowpart (QImode, operands[2]);
+    operands[1] = gen_lowpart (QImode, operands[1]);
   }"
 )
 
@@ -4682,11 +4685,12 @@
    (set (match_dup 3)
 	(ashiftrt:SI (match_dup 2) (const_int 16)))
    (set (match_operand:HI 0 "s_register_operand" "")
-	(subreg:HI (match_dup 3) 0))]
+	(match_dup 4))]
   "TARGET_ARM"
   "
   operands[2] = gen_reg_rtx (SImode);
   operands[3] = gen_reg_rtx (SImode);
+  operands[4] = gen_lowpart (HImode, operands[3]);
   "
 )
 
diff --git a/gcc/config/arm/linux-elf.h b/gcc/config/arm/linux-elf.h
index c63bbc1..9f9dc59 100644
--- a/gcc/config/arm/linux-elf.h
+++ b/gcc/config/arm/linux-elf.h
@@ -30,17 +30,34 @@ Boston, MA 02111-1307, USA.  */
 /* Do not assume anything about header files.  */
 #define NO_IMPLICIT_EXTERN_C
 
+/*
+ * 'config.gcc' defines TARGET_BIG_ENDIAN_DEFAULT as 1 for arm*b-*
+ * (big endian) configurations.
+ */
+#if TARGET_BIG_ENDIAN_DEFAULT
+#define TARGET_ENDIAN_DEFAULT ARM_FLAG_BIG_END
+#define TARGET_ENDIAN_OPTION "mbig-endian"
+#define TARGET_LINKER_EMULATION "armelfb_linux"
+#else
+#define TARGET_ENDIAN_DEFAULT 0
+#define TARGET_ENDIAN_OPTION "mlittle-endian"
+#define TARGET_LINKER_EMULATION "armelf_linux"
+#endif
+
 /* Default is to use APCS-32 mode.  */
 #undef  TARGET_DEFAULT
-#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_MMU_TRAPS)
+#define TARGET_DEFAULT \
+		( ARM_FLAG_APCS_32 | \
+		  ARM_FLAG_MMU_TRAPS | \
+		  TARGET_ENDIAN_DEFAULT )
 
 #define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm6
 
-#define SUBTARGET_EXTRA_LINK_SPEC " -m armelf_linux -p"
+#define SUBTARGET_EXTRA_LINK_SPEC " -m " TARGET_LINKER_EMULATION " -p"
 
 #undef  MULTILIB_DEFAULTS
 #define MULTILIB_DEFAULTS \
-	{ "marm", "mlittle-endian", "mhard-float", "mapcs-32", "mno-thumb-interwork" }
+	{ "marm", TARGET_ENDIAN_OPTION, "mhard-float", "mapcs-32", "mno-thumb-interwork" }
 
 #define CPP_APCS_PC_DEFAULT_SPEC "-D__APCS_32__"
 
@@ -88,7 +105,7 @@ Boston, MA 02111-1307, USA.  */
    %{rdynamic:-export-dynamic} \
    %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2} \
    -X \
-   %{mbig-endian:-EB}" \
+   %{mbig-endian:-EB} %{mlittle-endian:-EL}" \
    SUBTARGET_EXTRA_LINK_SPEC
 
 #define TARGET_OS_CPP_BUILTINS()		\
diff --git a/gcc/config/arm/t-netbsd b/gcc/config/arm/t-netbsd
index 76e431b..67c49b9 100644
--- a/gcc/config/arm/t-netbsd
+++ b/gcc/config/arm/t-netbsd
@@ -11,8 +11,12 @@ SHLIB_OBJS = @shlib_objs@
 
 SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
 	-Wl,-soname,$(SHLIB_SONAME) \
-	-o $(SHLIB_NAME) @multilib_flags@ $(SHLIB_OBJS) -lc && \
+	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) -lc && \
 	rm -f $(SHLIB_SONAME) && \
+	if [ -f $(SHLIB_NAME) ]; then \
+	  mv -f $(SHLIB_NAME) $(SHLIB_NAME).backup; \
+	else true; fi && \
+	mv $(SHLIB_NAME).tmp $(SHLIB_NAME) && \
 	$(LN_S) $(SHLIB_NAME) $(SHLIB_SONAME)
 # $(slibdir) double quoted to protect it from expansion while building
 # libgcc.mk.  We want this delayed until actual install time.
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 1f93ce6..664cdad 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -1754,11 +1754,11 @@ classify_argument (mode, type, classes, bit_offset)
 	    {
 	      tree bases = TYPE_BINFO_BASETYPES (type);
 	      int n_bases = TREE_VEC_LENGTH (bases);
-	      int i;
+	      int basenum;
 
-	      for (i = 0; i < n_bases; ++i)
+	      for (basenum = 0; basenum < n_bases; ++basenum)
 		{
-		   tree binfo = TREE_VEC_ELT (bases, i);
+		   tree binfo = TREE_VEC_ELT (bases, basenum);
 		   int num;
 		   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;
 		   tree type = BINFO_TYPE (binfo);
@@ -1842,11 +1842,11 @@ classify_argument (mode, type, classes, bit_offset)
 	    {
 	      tree bases = TYPE_BINFO_BASETYPES (type);
 	      int n_bases = TREE_VEC_LENGTH (bases);
-	      int i;
+	      int basenum;
 
-	      for (i = 0; i < n_bases; ++i)
+	      for (basenum = 0; basenum < n_bases; ++basenum)
 		{
-		   tree binfo = TREE_VEC_ELT (bases, i);
+		   tree binfo = TREE_VEC_ELT (bases, basenum);
 		   int num;
 		   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;
 		   tree type = BINFO_TYPE (binfo);
diff --git a/gcc/config/i386/linux.h b/gcc/config/i386/linux.h
index 48c77d9..03cb486 100644
--- a/gcc/config/i386/linux.h
+++ b/gcc/config/i386/linux.h
@@ -230,6 +230,7 @@ Boston, MA 02111-1307, USA.  */
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
+#ifndef inhibit_libc
 #ifdef IN_LIBGCC2
 /* There's no sys/ucontext.h for some (all?) libc1, so no
    signal-turned-exceptions for them.  There's also no configure-run for
@@ -257,10 +258,10 @@ Boston, MA 02111-1307, USA.  */
       {									\
 	struct rt_sigframe {						\
 	  int sig;							\
-	  struct siginfo *pinfo;					\
+	  siginfo_t *pinfo;						\
 	  void *puc;							\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
       }									\
@@ -294,3 +295,4 @@ Boston, MA 02111-1307, USA.  */
   } while (0)
 #endif /* not USE_GNULIBC_1 */
 #endif /* IN_LIBGCC2 */
+#endif /* inhibit_libc */
diff --git a/gcc/config/i386/linux64.h b/gcc/config/i386/linux64.h
index fbfaa58..9d2fe58 100644
--- a/gcc/config/i386/linux64.h
+++ b/gcc/config/i386/linux64.h
@@ -112,7 +112,7 @@ Boston, MA 02111-1307, USA.  */
     if (*(unsigned char *)(pc_+0) == 0x48				\
 	&& *(unsigned long *)(pc_+1) == 0x050f0000000fc0c7)		\
       {									\
-	struct ucontext *uc_ = (CONTEXT)->cfa;				\
+	ucontext_t *uc_ = (CONTEXT)->cfa;				\
 	sc_ = (struct sigcontext *) &uc_->uc_mcontext;			\
       }									\
     else								\
@@ -179,10 +179,10 @@ Boston, MA 02111-1307, USA.  */
       {									\
 	struct rt_sigframe {						\
 	  int sig;							\
-	  struct siginfo *pinfo;					\
+	  siginfo_t *pinfo;						\
 	  void *puc;							\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
       }									\
diff --git a/gcc/config/ia64/linux.h b/gcc/config/ia64/linux.h
index fe5b558..b8506a6 100644
--- a/gcc/config/ia64/linux.h
+++ b/gcc/config/ia64/linux.h
@@ -72,7 +72,7 @@ do {						\
       struct sigframe {							\
 	char scratch[16];						\
 	unsigned long sig_number;					\
-	struct siginfo *info;						\
+	siginfo_t *info;						\
 	struct sigcontext *sc;						\
       } *frame_ = (struct sigframe *)(CONTEXT)->psp;			\
       struct sigcontext *sc_ = frame_->sc;				\
@@ -130,7 +130,7 @@ do {						\
       struct sigframe {							\
 	char scratch[16];						\
 	unsigned long sig_number;					\
-	struct siginfo *info;						\
+	siginfo_t *info;						\
 	struct sigcontext *sc;						\
       } *frame_ = (struct sigframe *)(CONTEXT)->psp;			\
       struct sigcontext *sc_ = frame_->sc;				\
diff --git a/gcc/config/ia64/t-glibc b/gcc/config/ia64/t-glibc
index a105662..df4fe9c 100644
--- a/gcc/config/ia64/t-glibc
+++ b/gcc/config/ia64/t-glibc
@@ -1 +1,3 @@
-LIB2ADDEH += $(srcdir)/config/ia64/fde-glibc.c
+# Use system libunwind library on IA-64 GLIBC based system.
+LIB2ADDEH = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c \
+  $(srcdir)/unwind-compat.c
diff --git a/gcc/config/ia64/t-glibc-libunwind b/gcc/config/ia64/t-glibc-libunwind
new file mode 100644
index 0000000..df78f1d
--- /dev/null
+++ b/gcc/config/ia64/t-glibc-libunwind
@@ -0,0 +1,4 @@
+# Build libunwind for IA-64 GLIBC based system.
+LIBUNWIND = $(srcdir)/config/ia64/fde-glibc.c \
+  $(srcdir)/config/ia64/unwind-ia64.c
+LIBUNWINDDEP = unwind.inc
diff --git a/gcc/config/ia64/t-hpux b/gcc/config/ia64/t-hpux
index 7b42fe5..e331b1d 100644
--- a/gcc/config/ia64/t-hpux
+++ b/gcc/config/ia64/t-hpux
@@ -30,6 +30,8 @@ STMP_FIXPROTO =
 # We do not want to include the EH stuff that linux uses, we want to use
 # the HP-UX libunwind library.
 
+T_CFLAGS += -DUSE_LIBUNWIND_EXCEPTIONS
+
 LIB2ADDEH =
 
 SHLIB_EXT = .so
diff --git a/gcc/config/ia64/unwind-ia64.c b/gcc/config/ia64/unwind-ia64.c
index e8e2fc0..f166abf 100644
--- a/gcc/config/ia64/unwind-ia64.c
+++ b/gcc/config/ia64/unwind-ia64.c
@@ -35,6 +35,7 @@
 #include "tsystem.h"
 #include "unwind.h"
 #include "unwind-ia64.h"
+#include "unwind-compat.h"
 #include "ia64intrin.h"
 
 /* This isn't thread safe, but nice for occasional tests.  */
@@ -2286,4 +2287,24 @@ uw_identify_context (struct _Unwind_Context *context)
 }
 
 #include "unwind.inc"
+
+#if defined (USE_GAS_SYMVER) && defined (SHARED) && defined (USE_LIBUNWIND_EXCEPTIONS)
+alias (_Unwind_Backtrace);
+alias (_Unwind_DeleteException);
+alias (_Unwind_FindEnclosingFunction);
+alias (_Unwind_FindTableEntry);
+alias (_Unwind_ForcedUnwind);
+alias (_Unwind_GetBSP);
+alias (_Unwind_GetCFA);
+alias (_Unwind_GetGR);
+alias (_Unwind_GetIP);
+alias (_Unwind_GetLanguageSpecificData);
+alias (_Unwind_GetRegionStart);
+alias (_Unwind_RaiseException);
+alias (_Unwind_Resume);
+alias (_Unwind_Resume_or_Rethrow);
+alias (_Unwind_SetGR);
+alias (_Unwind_SetIP);
+#endif
+
 #endif
diff --git a/gcc/config/ia64/unwind-ia64.h b/gcc/config/ia64/unwind-ia64.h
index a6b850d..e845746 100644
--- a/gcc/config/ia64/unwind-ia64.h
+++ b/gcc/config/ia64/unwind-ia64.h
@@ -28,4 +28,5 @@ struct unw_table_entry
 
 extern struct unw_table_entry *
 _Unwind_FindTableEntry (void *pc, unsigned long *segment_base,
-			unsigned long *gp);
+			unsigned long *gp)
+			__attribute__ ((__visibility__ ("hidden")));
diff --git a/gcc/config/m68k/m68k.md b/gcc/config/m68k/m68k.md
index 3451b9e..dc2effa 100644
--- a/gcc/config/m68k/m68k.md
+++ b/gcc/config/m68k/m68k.md
@@ -675,7 +675,7 @@
 
 (define_insn ""
   [(set (cc0)
-	(compare (match_operand:DF 0 "general_operand" "f,mG")
+	(compare (match_operand:DF 0 "general_operand" "f,fmG")
 		 (match_operand:DF 1 "general_operand" "fmG,f")))]
   "TARGET_68881"
   "*
diff --git a/gcc/config/mips/t-iris5-6 b/gcc/config/mips/t-iris5-6
index 4321b52..4dc7320 100644
--- a/gcc/config/mips/t-iris5-6
+++ b/gcc/config/mips/t-iris5-6
@@ -9,8 +9,12 @@ SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual@
 
 SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
         -Wl,-soname,$(SHLIB_SONAME) \
-	-o $(SHLIB_NAME) @multilib_flags@ $(SHLIB_OBJS) -lc && \
+	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) -lc && \
 	rm -f $(SHLIB_SOLINK) && \
+	if [ -f $(SHLIB_NAME) ]; then \
+	  mv -f $(SHLIB_NAME) $(SHLIB_NAME).`basename $(STAGE_PREFIX)`; \
+	else true; fi && \
+	mv $(SHLIB_NAME).tmp $(SHLIB_NAME) && \
 	$(LN_S) $(SHLIB_NAME) $(SHLIB_SOLINK)
 # ??? Irix 6.5 seems to eat the option fine (if we somehow remove the
 # -hidden_symbol option, which is documented to be ignored in conjunction
diff --git a/gcc/config/pa/t-hpux-shlib b/gcc/config/pa/t-hpux-shlib
index 1c92449..5183b06 100644
--- a/gcc/config/pa/t-hpux-shlib
+++ b/gcc/config/pa/t-hpux-shlib
@@ -5,8 +5,12 @@ SHLIB_SONAME = @shlib_base_name@.1
 SHLIB_OBJS = @shlib_objs@
 
 SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared  -nodefaultlibs \
-	-o $(SHLIB_NAME) @multilib_flags@ $(SHLIB_OBJS) -lc && \
+	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) -lc && \
         rm -f $(SHLIB_SONAME) && \
+	if [ -f $(SHLIB_NAME) ]; then \
+	  mv -f $(SHLIB_NAME) $(SHLIB_NAME).backup; \
+	else true; fi && \
+	mv $(SHLIB_NAME).tmp $(SHLIB_NAME) && \
         $(LN_S) $(SHLIB_NAME) $(SHLIB_SONAME)
 
 
diff --git a/gcc/config/rs6000/linux.h b/gcc/config/rs6000/linux.h
index ba70ec1..792bcfe 100644
--- a/gcc/config/rs6000/linux.h
+++ b/gcc/config/rs6000/linux.h
@@ -101,7 +101,7 @@ Boston, MA 02111-1307, USA.  */
 
 struct kernel_old_ucontext {
   unsigned long     uc_flags;
-  struct ucontext  *uc_link;
+  ucontext_t       *uc_link;
   stack_t           uc_stack;
   struct sigcontext_struct uc_mcontext;
   sigset_t          uc_sigmask;
@@ -138,9 +138,9 @@ enum { SIGNAL_FRAMESIZE = 64 };
 	struct rt_sigframe {						\
 	  char gap[SIGNAL_FRAMESIZE];					\
 	  unsigned long _unused[2];					\
-	  struct siginfo *pinfo;					\
+	  siginfo_t *pinfo;						\
 	  void *puc;							\
-	  struct siginfo info;						\
+	  siginfo_t info;						\
 	  struct kernel_old_ucontext uc;				\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = &rt_->uc.uc_mcontext;					\
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 009e1e7..0c71c1c 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -9185,7 +9185,7 @@ rs6000_stack_info ()
   info_ptr->varargs_size = RS6000_VARARGS_AREA;
   info_ptr->vars_size    = RS6000_ALIGN (get_frame_size (), 8);
   info_ptr->parm_size    = RS6000_ALIGN (current_function_outgoing_args_size,
-					 8);
+					 TARGET_ALTIVEC ? 16 : 8);
 
   if (TARGET_SPE_ABI)
     info_ptr->spe_gp_size = 8 * (32 - info_ptr->first_gp_reg_save);
diff --git a/gcc/config/sh/t-linux b/gcc/config/sh/t-linux
index 3dd63fc..4fe3819 100644
--- a/gcc/config/sh/t-linux
+++ b/gcc/config/sh/t-linux
@@ -25,8 +25,12 @@ SHLIB_MAPFILES =  $(srcdir)/config/sh/libgcc-std.ver \
 SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
 	-Wl,--soname=$(SHLIB_SONAME) \
 	-Wl,--version-script=$(SHLIB_MAP) \
-	-o $(SHLIB_NAME) @multilib_flags@ $(SHLIB_OBJS) $(SHLIB_LC) && \
+	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) $(SHLIB_LC) && \
 	rm -f $(SHLIB_SOLINK) && \
+	if [ -f $(SHLIB_NAME) ]; then \
+	  mv -f $(SHLIB_NAME) $(SHLIB_NAME).backup; \
+	else true; fi && \
+	mv $(SHLIB_NAME).tmp $(SHLIB_NAME) && \
 	(echo "/* GNU ld script"; \
 	 echo "   Use the shared library, but some functions are only in"; \
 	 echo "   the static library.  */"; \
diff --git a/gcc/config/sparc/linux.h b/gcc/config/sparc/linux.h
index 78ab2a9..62ff6fc 100644
--- a/gcc/config/sparc/linux.h
+++ b/gcc/config/sparc/linux.h
@@ -252,6 +252,13 @@ do {									\
 #define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
 #endif
 
+#ifdef HAVE_AS_TLS
+#undef TARGET_SUN_TLS
+#undef TARGET_GNU_TLS
+#define TARGET_SUN_TLS 0
+#define TARGET_GNU_TLS 1
+#endif
+
 /* Don't be different from other Linux platforms in this regard.  */
 #define HANDLE_PRAGMA_PACK_PUSH_POP
 
diff --git a/gcc/config/sparc/linux64.h b/gcc/config/sparc/linux64.h
index a3fee41..8443df8 100644
--- a/gcc/config/sparc/linux64.h
+++ b/gcc/config/sparc/linux64.h
@@ -315,6 +315,13 @@ do {									\
 #define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
 #endif
 
+#ifdef HAVE_AS_TLS
+#undef TARGET_SUN_TLS
+#undef TARGET_GNU_TLS
+#define TARGET_SUN_TLS 0
+#define TARGET_GNU_TLS 1
+#endif
+
 /* Don't be different from other Linux platforms in this regard.  */
 #define HANDLE_PRAGMA_PACK_PUSH_POP
 
diff --git a/gcc/config/sparc/sparc-protos.h b/gcc/config/sparc/sparc-protos.h
index 8f7c987..e70d8e8 100644
--- a/gcc/config/sparc/sparc-protos.h
+++ b/gcc/config/sparc/sparc-protos.h
@@ -81,7 +81,13 @@ extern void emit_tfmode_cvt PARAMS ((enum rtx_code, rtx *));
 extern int gen_v9_scc PARAMS ((enum rtx_code, rtx *));
 extern void sparc_initialize_trampoline PARAMS ((rtx, rtx, rtx));
 extern void sparc64_initialize_trampoline PARAMS ((rtx, rtx, rtx));
+extern bool legitimate_constant_p PARAMS ((rtx));
+extern bool constant_address_p PARAMS ((rtx));
+extern bool legitimate_pic_operand_p PARAMS ((rtx));
+extern int legitimate_address_p PARAMS ((enum machine_mode, rtx, int));
 extern rtx legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));
+extern rtx legitimize_tls_address PARAMS ((rtx));
+extern rtx legitimize_address PARAMS ((rtx, rtx, enum machine_mode));
 extern void sparc_defer_case_vector PARAMS ((rtx, rtx, int));
 extern void sparc_emit_set_const32 PARAMS ((rtx, rtx));
 extern void sparc_emit_set_const64 PARAMS ((rtx, rtx));
@@ -101,9 +107,11 @@ extern int arith_4096_operand PARAMS ((rtx, enum machine_mode));
 extern int zero_operand PARAMS ((rtx, enum machine_mode));
 extern int fp_zero_operand PARAMS ((rtx, enum machine_mode));
 extern int reg_or_0_operand PARAMS ((rtx, enum machine_mode));
+extern int tls_symbolic_operand PARAMS ((rtx));
 extern int empty_delay_slot PARAMS ((rtx));
 extern int eligible_for_epilogue_delay PARAMS ((rtx, int));
 extern int eligible_for_sibcall_delay PARAMS ((rtx));
+extern int tls_call_delay PARAMS ((rtx));
 extern int emit_move_sequence PARAMS ((rtx, enum machine_mode));
 extern int fp_sethi_p PARAMS ((rtx));
 extern int fp_mov_p PARAMS ((rtx));
@@ -122,6 +130,7 @@ extern int sparc_check_64 PARAMS ((rtx, rtx));
 extern rtx gen_df_reg PARAMS ((rtx, int));
 extern int sparc_extra_constraint_check PARAMS ((rtx, int, int));
 extern int sparc_rtx_costs PARAMS ((rtx, enum rtx_code, enum rtx_code));
+extern void sparc_output_dwarf_dtprel PARAMS ((FILE*, int, rtx));
 #endif /* RTX_CODE */
 
 #endif /* __SPARC_PROTOS_H__ */
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 4c62709..25f05fa 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -76,6 +76,9 @@ static int num_gfregs;
    generate a scc or bcc insn.  */
 rtx sparc_compare_op0, sparc_compare_op1;
 
+/* The encoding characters for the four TLS models present in ELF.  */
+static char const tls_model_chars[] = " GLil";
+
 /* Coordinate with the md file wrt special insns created by
    sparc_nonflat_function_epilogue.  */
 bool sparc_emitting_epilogue;
@@ -117,6 +120,12 @@ char sparc_leaf_regs[] =
   1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1};
 
+struct machine_function GTY(())
+{
+  /* Some local-dynamic TLS symbol name.  */
+  const char *some_ld_name;
+};
+
 /* Name of where we pretend to think the frame pointer points.
    Normally, this is "%fp", but if we are in a leaf procedure,
    this is "%sp+something".  We record "something" separately as it may be
@@ -176,8 +185,15 @@ static void emit_soft_tfmode_cvt PARAMS ((enum rtx_code, rtx *));
 static void emit_hard_tfmode_operation PARAMS ((enum rtx_code, rtx *));
 
 static void sparc_encode_section_info PARAMS ((tree, int));
+static const char *sparc_strip_name_encoding PARAMS ((const char *));
 static void sparc_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,
 					   HOST_WIDE_INT, tree));
+static struct machine_function * sparc_init_machine_status PARAMS ((void));
+static bool sparc_cannot_force_const_mem PARAMS ((rtx));
+static rtx sparc_tls_get_addr PARAMS ((void));
+static rtx sparc_tls_got PARAMS ((void));
+static const char *get_some_local_dynamic_name PARAMS ((void));
+static int get_some_local_dynamic_name_1 PARAMS ((rtx *, void *));
 static bool sparc_can_output_mi_thunk PARAMS ((tree, HOST_WIDE_INT,
 					       HOST_WIDE_INT, tree));
 
@@ -242,6 +258,15 @@ enum processor_type sparc_cpu;
 
 #undef TARGET_ENCODE_SECTION_INFO
 #define TARGET_ENCODE_SECTION_INFO sparc_encode_section_info
+#undef  TARGET_STRIP_NAME_ENCODING
+#define TARGET_STRIP_NAME_ENCODING sparc_strip_name_encoding
+
+#ifdef HAVE_AS_TLS
+#undef TARGET_HAVE_TLS
+#define TARGET_HAVE_TLS true
+#endif
+#undef TARGET_CANNOT_FORCE_CONST_MEM
+#define TARGET_CANNOT_FORCE_CONST_MEM sparc_cannot_force_const_mem
 
 #undef TARGET_ASM_OUTPUT_MI_THUNK
 #define TARGET_ASM_OUTPUT_MI_THUNK sparc_output_mi_thunk
@@ -446,6 +471,9 @@ sparc_override_options ()
 
   /* Do various machine dependent initializations.  */
   sparc_init_modes ();
+
+  /* Set up function hooks.  */
+  init_machine_status = sparc_init_machine_status;
 }
 
 /* Miscellaneous utilities.  */
@@ -711,6 +739,56 @@ call_operand_address (op, mode)
   return (symbolic_operand (op, mode) || memory_address_p (Pmode, op));
 }
 
+/* If OP is a SYMBOL_REF of a thread-local symbol, return its TLS mode,
+   otherwise return 0.  */
+
+int
+tls_symbolic_operand (op)
+     rtx op;
+{
+  const char *symbol_str;
+
+  if (GET_CODE (op) != SYMBOL_REF)
+    return 0;
+  symbol_str = XSTR (op, 0);
+
+  if (symbol_str[0] != '%')
+    return 0;
+  return strchr (tls_model_chars, symbol_str[1]) - tls_model_chars;
+}
+
+int
+tgd_symbolic_operand (op, mode)
+     rtx op;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+  return tls_symbolic_operand (op) == TLS_MODEL_GLOBAL_DYNAMIC;
+}
+
+int
+tld_symbolic_operand (op, mode)
+     rtx op;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+  return tls_symbolic_operand (op) == TLS_MODEL_LOCAL_DYNAMIC;
+}
+
+int
+tie_symbolic_operand (op, mode)
+     rtx op;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+  return tls_symbolic_operand (op) == TLS_MODEL_INITIAL_EXEC;
+}
+
+int
+tle_symbolic_operand (op, mode)
+     rtx op;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+  return tls_symbolic_operand (op) == TLS_MODEL_LOCAL_EXEC;
+}
+
 /* Returns 1 if OP is either a symbol reference or a sum of a symbol
    reference and a constant.  */
 
@@ -727,12 +805,15 @@ symbolic_operand (op, mode)
   switch (GET_CODE (op))
     {
     case SYMBOL_REF:
+      return !tls_symbolic_operand (op);
+
     case LABEL_REF:
       return 1;
 
     case CONST:
       op = XEXP (op, 0);
-      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF
+      return (((GET_CODE (XEXP (op, 0)) == SYMBOL_REF
+		&& !tls_symbolic_operand (XEXP (op, 0)))
 	       || GET_CODE (XEXP (op, 0)) == LABEL_REF)
 	      && GET_CODE (XEXP (op, 1)) == CONST_INT);
 
@@ -754,8 +835,9 @@ symbolic_memory_operand (op, mode)
   if (GET_CODE (op) != MEM)
     return 0;
   op = XEXP (op, 0);
-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST
-	  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);
+  return ((GET_CODE (op) == SYMBOL_REF && !tls_symbolic_operand (op))
+	  || GET_CODE (op) == CONST || GET_CODE (op) == HIGH
+	  || GET_CODE (op) == LABEL_REF);
 }
 
 /* Return truth value of statement that OP is a LABEL_REF of mode MODE.  */
@@ -2969,6 +3051,33 @@ eligible_for_epilogue_delay (trial, slot)
   return 0;
 }
 
+/* Return nonzero if TRIAL can go into the call delay slot.  */
+int
+tls_call_delay (trial)
+     rtx trial;
+{
+  rtx pat, unspec;
+
+  /* Binutils allows
+     call __tls_get_addr, %tgd_call (foo)
+      add %l7, %o0, %o0, %tgd_add (foo)
+     while Sun as/ld does not.  */
+  if (TARGET_GNU_TLS || !TARGET_TLS)
+    return 1;
+
+  pat = PATTERN (trial);
+  if (GET_CODE (pat) != SET || GET_CODE (SET_DEST (pat)) != PLUS)
+    return 1;
+
+  unspec = XEXP (SET_DEST (pat), 1);
+  if (GET_CODE (unspec) != UNSPEC
+      || (XINT (unspec, 1) != UNSPEC_TLSGD
+	  && XINT (unspec, 1) != UNSPEC_TLSLDM))
+    return 1;
+
+  return 0;
+}
+
 /* Return nonzero if TRIAL can go into the sibling call
    delay slot.  */
 
@@ -3146,6 +3255,46 @@ reg_unused_after (reg, insn)
   return 1;
 }
 
+/* Determine if it's legal to put X into the constant pool.  This
+   is not possible if X contains the address of a symbol that is
+   not constant (TLS) or not known at final link time (PIC).  */
+
+static bool
+sparc_cannot_force_const_mem (x)
+     rtx x;
+{
+  switch (GET_CODE (x))
+    {
+    case CONST_INT:
+    case CONST_DOUBLE:
+      /* Accept all non-symbolic constants.  */
+      return false;
+
+    case LABEL_REF:
+      /* Labels are OK iff we are non-PIC.  */
+      return flag_pic != 0;
+
+    case SYMBOL_REF:
+      /* 'Naked' TLS symbol references are never OK,
+	 non-TLS symbols are OK iff we are non-PIC.  */
+      if (tls_symbolic_operand (x))
+	return true;
+      else
+	return flag_pic != 0;
+
+    case CONST:
+      return sparc_cannot_force_const_mem (XEXP (x, 0));
+    case PLUS:
+    case MINUS:
+      return sparc_cannot_force_const_mem (XEXP (x, 0))
+         || sparc_cannot_force_const_mem (XEXP (x, 1));
+    case UNSPEC:
+      return true;
+    default:
+      abort ();
+    }
+}
+
 /* The table we use to reference PIC data.  */
 static GTY(()) rtx global_offset_table;
 
@@ -3193,6 +3342,398 @@ pic_address_needs_scratch (x)
   return 0;
 }
 
+/* Determine if a given RTX is a valid constant.  We already know this
+   satisfies CONSTANT_P.  */
+
+bool
+legitimate_constant_p (x)
+     rtx x;
+{
+  rtx inner;
+
+  switch (GET_CODE (x))
+    {
+    case SYMBOL_REF:
+      /* TLS symbols are not constant.  */
+      if (tls_symbolic_operand (x))
+	return false;
+      break;
+
+    case CONST:
+      inner = XEXP (x, 0);
+
+      /* Offsets of TLS symbols are never valid.
+	 Discourage CSE from creating them.  */
+      if (GET_CODE (inner) == PLUS
+	  && tls_symbolic_operand (XEXP (inner, 0)))
+	return false;
+      break;
+
+    case CONST_DOUBLE:
+      if (GET_MODE (x) == VOIDmode)
+        return true;
+
+      /* Floating point constants are generally not ok.
+	 The only exception is 0.0 in VIS.  */
+      if (TARGET_VIS
+	  && (GET_MODE (x) == SFmode
+	      || GET_MODE (x) == DFmode
+	      || GET_MODE (x) == TFmode)
+	  && fp_zero_operand (x, GET_MODE (x)))
+	return true;
+
+      return false;
+
+    default:
+      break;
+    }
+
+  return true;
+}
+
+/* Determine if a given RTX is a valid constant address.  */
+
+bool
+constant_address_p (x)
+     rtx x;
+{
+  switch (GET_CODE (x))
+    {
+    case LABEL_REF:
+    case CONST_INT:
+    case HIGH:
+      return true;
+
+    case CONST:
+      if (flag_pic && pic_address_needs_scratch (x))
+	return false;
+      return legitimate_constant_p (x);
+
+    case SYMBOL_REF:
+      return !flag_pic && legitimate_constant_p (x);
+
+    default:
+      return false;
+    }
+}
+
+/* Nonzero if the constant value X is a legitimate general operand
+   when generating PIC code.  It is given that flag_pic is on and
+   that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
+
+bool
+legitimate_pic_operand_p (x)
+     rtx x;
+{
+  if (pic_address_needs_scratch (x))
+    return false;
+  if (tls_symbolic_operand (x)
+      || (GET_CODE (x) == CONST
+	  && GET_CODE (XEXP (x, 0)) == PLUS
+	  && tls_symbolic_operand (XEXP (XEXP (x, 0), 0))))
+    return false;
+  return true;
+}
+
+/* Return nonzero if ADDR is a valid memory address.
+   STRICT specifies whether strict register checking applies.  */
+   
+int
+legitimate_address_p (mode, addr, strict)
+     enum machine_mode mode;
+     register rtx addr;
+     int strict;
+{
+  rtx rs1 = NULL, rs2 = NULL, imm1 = NULL, imm2;
+
+  if (REG_P (addr) || GET_CODE (addr) == SUBREG)
+    rs1 = addr;
+  else if (GET_CODE (addr) == PLUS)
+    {
+      rs1 = XEXP (addr, 0);
+      rs2 = XEXP (addr, 1);
+
+      /* Canonicalize.  REG comes first, if there are no regs,
+	 LO_SUM comes first.  */
+      if (!REG_P (rs1)
+	  && GET_CODE (rs1) != SUBREG
+	  && (REG_P (rs2)
+	      || GET_CODE (rs2) == SUBREG
+	      || (GET_CODE (rs2) == LO_SUM && GET_CODE (rs1) != LO_SUM)))
+	{
+	  rs1 = XEXP (addr, 1);
+	  rs2 = XEXP (addr, 0);
+	}
+
+      if ((flag_pic == 1
+	   && rs1 == pic_offset_table_rtx
+	   && !REG_P (rs2)
+	   && GET_CODE (rs2) != SUBREG
+	   && GET_CODE (rs2) != LO_SUM
+	   && GET_CODE (rs2) != MEM
+	   && !tls_symbolic_operand (rs2)
+	   && (! symbolic_operand (rs2, VOIDmode) || mode == Pmode)
+	   && (GET_CODE (rs2) != CONST_INT || SMALL_INT (rs2)))
+	  || ((REG_P (rs1)
+	       || GET_CODE (rs1) == SUBREG)
+	      && RTX_OK_FOR_OFFSET_P (rs2)))
+	{
+	  imm1 = rs2;
+	  rs2 = NULL;
+	}
+      else if ((REG_P (rs1) || GET_CODE (rs1) == SUBREG)
+	       && (REG_P (rs2) || GET_CODE (rs2) == SUBREG))
+	{
+	  /* We prohibit REG + REG for TFmode when there are no instructions
+	     which accept REG+REG instructions.  We do this because REG+REG
+	     is not an offsetable address.  If we get the situation in reload
+	     where source and destination of a movtf pattern are both MEMs with
+	     REG+REG address, then only one of them gets converted to an
+	     offsetable address.  */
+	  if (mode == TFmode
+	      && !(TARGET_FPU && TARGET_ARCH64 && TARGET_V9
+		   && TARGET_HARD_QUAD))
+	    return 0;
+
+	  /* We prohibit REG + REG on ARCH32 if not optimizing for
+	     DFmode/DImode because then mem_min_alignment is likely to be zero
+	     after reload and the  forced split would lack a matching splitter
+	     pattern.  */
+	  if (TARGET_ARCH32 && !optimize
+	      && (mode == DFmode || mode == DImode))
+	    return 0;
+	}
+      else if (USE_AS_OFFSETABLE_LO10
+	       && GET_CODE (rs1) == LO_SUM
+	       && TARGET_ARCH64
+	       && ! TARGET_CM_MEDMID
+	       && RTX_OK_FOR_OLO10_P (rs2))
+	{
+	  imm2 = rs2;
+	  rs2 = NULL;
+	  imm1 = XEXP (rs1, 1);
+	  rs1 = XEXP (rs1, 0);
+	  if (! CONSTANT_P (imm1) || tls_symbolic_operand (rs1))
+	    return 0;
+	}
+    }
+  else if (GET_CODE (addr) == LO_SUM)
+    {
+      rs1 = XEXP (addr, 0);
+      imm1 = XEXP (addr, 1);
+
+      if (! CONSTANT_P (imm1) || tls_symbolic_operand (rs1))
+	return 0;
+
+      /* We can't allow TFmode, because an offset greater than or equal to the
+         alignment (8) may cause the LO_SUM to overflow if !v9.  */
+      if (mode == TFmode && !TARGET_V9)
+	return 0;
+    }
+  else if (GET_CODE (addr) == CONST_INT && SMALL_INT (addr))
+    return 1;
+  else
+    return 0;
+
+  if (GET_CODE (rs1) == SUBREG)
+    rs1 = SUBREG_REG (rs1);
+  if (!REG_P (rs1))
+    return 0;
+
+  if (rs2)
+    {
+      if (GET_CODE (rs2) == SUBREG)
+	rs2 = SUBREG_REG (rs2);
+      if (!REG_P (rs2))
+	return 0;
+    }
+
+  if (strict)
+    {
+      if (!REGNO_OK_FOR_BASE_P (REGNO (rs1))
+	  || (rs2 && !REGNO_OK_FOR_BASE_P (REGNO (rs2))))
+	return 0;
+    }
+  else
+    {
+      if ((REGNO (rs1) >= 32
+	   && REGNO (rs1) != FRAME_POINTER_REGNUM
+	   && REGNO (rs1) < FIRST_PSEUDO_REGISTER)
+	  || (rs2
+	      && (REGNO (rs2) >= 32
+		  && REGNO (rs2) != FRAME_POINTER_REGNUM
+		  && REGNO (rs2) < FIRST_PSEUDO_REGISTER)))
+	return 0;
+    }
+  return 1;
+}
+
+/* Construct the SYMBOL_REF for the tls_get_offset function.  */
+
+static GTY(()) rtx sparc_tls_symbol;
+static rtx
+sparc_tls_get_addr ()
+{
+  if (!sparc_tls_symbol)
+    sparc_tls_symbol = gen_rtx_SYMBOL_REF (Pmode, "__tls_get_addr");
+
+  return sparc_tls_symbol;
+}
+
+static rtx
+sparc_tls_got ()
+{
+  rtx temp;
+  if (flag_pic)
+    {
+      current_function_uses_pic_offset_table = 1;
+      return pic_offset_table_rtx;
+    }
+
+  if (!global_offset_table)
+    global_offset_table = gen_rtx_SYMBOL_REF (Pmode, "_GLOBAL_OFFSET_TABLE_");
+  temp = gen_reg_rtx (Pmode);
+  emit_move_insn (temp, global_offset_table);
+  return temp;
+}
+
+
+/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute
+   this (thread-local) address.  */
+
+rtx
+legitimize_tls_address (addr)
+     rtx addr;
+{
+  rtx temp1, temp2, temp3, ret, o0, got, insn;
+
+  if (no_new_pseudos)
+    abort ();
+
+  if (GET_CODE (addr) == SYMBOL_REF)
+    switch (tls_symbolic_operand (addr))
+      {
+      case TLS_MODEL_GLOBAL_DYNAMIC:
+	start_sequence ();
+	temp1 = gen_reg_rtx (SImode);
+	temp2 = gen_reg_rtx (SImode);
+	ret = gen_reg_rtx (Pmode);
+	o0 = gen_rtx_REG (Pmode, 8);
+	got = sparc_tls_got ();
+	emit_insn (gen_tgd_hi22 (temp1, addr));
+	emit_insn (gen_tgd_lo10 (temp2, temp1, addr));
+	if (TARGET_ARCH32)
+	  {
+	    emit_insn (gen_tgd_add32 (o0, got, temp2, addr));
+	    insn = emit_call_insn (gen_tgd_call32 (o0, sparc_tls_get_addr (),
+						   addr, const1_rtx));
+	  }
+	else
+	  {
+	    emit_insn (gen_tgd_add64 (o0, got, temp2, addr));
+	    insn = emit_call_insn (gen_tgd_call64 (o0, sparc_tls_get_addr (),
+						   addr, const1_rtx));
+	  }
+        CALL_INSN_FUNCTION_USAGE (insn)
+	  = gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_USE (VOIDmode, o0),
+			       CALL_INSN_FUNCTION_USAGE (insn));
+	insn = get_insns ();
+	end_sequence ();
+	emit_libcall_block (insn, ret, o0, addr);
+	break;
+
+      case TLS_MODEL_LOCAL_DYNAMIC:
+	start_sequence ();
+	temp1 = gen_reg_rtx (SImode);
+	temp2 = gen_reg_rtx (SImode);
+	temp3 = gen_reg_rtx (Pmode);
+	ret = gen_reg_rtx (Pmode);
+	o0 = gen_rtx_REG (Pmode, 8);
+	got = sparc_tls_got ();
+	emit_insn (gen_tldm_hi22 (temp1));
+	emit_insn (gen_tldm_lo10 (temp2, temp1));
+	if (TARGET_ARCH32)
+	  {
+	    emit_insn (gen_tldm_add32 (o0, got, temp2));
+	    insn = emit_call_insn (gen_tldm_call32 (o0, sparc_tls_get_addr (),
+						    const1_rtx));
+	  }
+	else
+	  {
+	    emit_insn (gen_tldm_add64 (o0, got, temp2));
+	    insn = emit_call_insn (gen_tldm_call64 (o0, sparc_tls_get_addr (),
+						    const1_rtx));
+	  }
+        CALL_INSN_FUNCTION_USAGE (insn)
+	  = gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_USE (VOIDmode, o0),
+			       CALL_INSN_FUNCTION_USAGE (insn));
+	insn = get_insns ();
+	end_sequence ();
+	emit_libcall_block (insn, temp3, o0,
+			    gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),
+					    UNSPEC_TLSLD_BASE));
+	temp1 = gen_reg_rtx (SImode);
+	temp2 = gen_reg_rtx (SImode);
+	emit_insn (gen_tldo_hix22 (temp1, addr));
+	emit_insn (gen_tldo_lox10 (temp2, temp1, addr));
+	if (TARGET_ARCH32)
+	  emit_insn (gen_tldo_add32 (ret, temp3, temp2, addr));
+	else
+	  emit_insn (gen_tldo_add64 (ret, temp3, temp2, addr));
+	break;
+
+      case TLS_MODEL_INITIAL_EXEC:
+	temp1 = gen_reg_rtx (SImode);
+	temp2 = gen_reg_rtx (SImode);
+	temp3 = gen_reg_rtx (Pmode);
+	got = sparc_tls_got ();
+	emit_insn (gen_tie_hi22 (temp1, addr));
+	emit_insn (gen_tie_lo10 (temp2, temp1, addr));
+	if (TARGET_ARCH32)
+	  emit_insn (gen_tie_ld32 (temp3, got, temp2, addr));
+	else
+	  emit_insn (gen_tie_ld64 (temp3, got, temp2, addr));
+        if (TARGET_SUN_TLS)
+	  {
+	    ret = gen_reg_rtx (Pmode);
+	    if (TARGET_ARCH32)
+	      emit_insn (gen_tie_add32 (ret, gen_rtx_REG (Pmode, 7),
+					temp3, addr));
+	    else
+	      emit_insn (gen_tie_add64 (ret, gen_rtx_REG (Pmode, 7),
+					temp3, addr));
+	  }
+	else
+	  ret = gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, 7), temp3);
+	break;
+
+      case TLS_MODEL_LOCAL_EXEC:
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
+	if (TARGET_ARCH32)
+	  {
+	    emit_insn (gen_tle_hix22_sp32 (temp1, addr));
+	    emit_insn (gen_tle_lox10_sp32 (temp2, temp1, addr));
+	  }
+	else
+	  {
+	    emit_insn (gen_tle_hix22_sp64 (temp1, addr));
+	    emit_insn (gen_tle_lox10_sp64 (temp2, temp1, addr));
+	  }
+	ret = gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, 7), temp2);
+	break;
+
+      default:
+	abort ();
+      }
+
+  else
+    abort ();  /* for now ... */
+
+  return ret;
+}
+
+
 /* Legitimize PIC addresses.  If the address is already position-independent,
    we return ORIG.  Newly generated position-independent addresses go into a
    reg.  This is REG if nonzero, otherwise we allocate register(s) as
@@ -3302,6 +3843,55 @@ legitimize_pic_address (orig, mode, reg)
   return orig;
 }
 
+/* Try machine-dependent ways of modifying an illegitimate address X
+   to be legitimate.  If we find one, return the new, valid address.
+
+   OLDX is the address as it was before break_out_memory_refs was called.
+   In some cases it is useful to look at this to decide what needs to be done.
+
+   MODE is the mode of the operand pointed to by X.  */
+
+rtx
+legitimize_address (x, oldx, mode)
+     register rtx x;
+     register rtx oldx ATTRIBUTE_UNUSED;
+     enum machine_mode mode;
+{
+  rtx orig_x = x;
+
+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT)
+    x = gen_rtx_PLUS (Pmode, XEXP (x, 1),
+		      force_operand (XEXP (x, 0), NULL_RTX));
+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == MULT)
+    x = gen_rtx_PLUS (Pmode, XEXP (x, 0),
+		      force_operand (XEXP (x, 1), NULL_RTX));
+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == PLUS)
+    x = gen_rtx_PLUS (Pmode, force_operand (XEXP (x, 0), NULL_RTX),
+		      XEXP (x, 1));
+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == PLUS)
+    x = gen_rtx_PLUS (Pmode, XEXP (x, 0),
+		      force_operand (XEXP (x, 1), NULL_RTX));
+
+  if (x != orig_x && legitimate_address_p (mode, x, FALSE))
+    return x;
+
+  if (tls_symbolic_operand (x))
+    x = legitimize_tls_address (x);
+  else if (flag_pic)
+    x = legitimize_pic_address (x, mode, 0);
+  else if (GET_CODE (x) == PLUS && CONSTANT_ADDRESS_P (XEXP (x, 1)))
+    x = gen_rtx_PLUS (Pmode, XEXP (x, 0),
+		      copy_to_mode_reg (Pmode, XEXP (x, 1)));
+  else if (GET_CODE (x) == PLUS && CONSTANT_ADDRESS_P (XEXP (x, 0)))
+    x = gen_rtx_PLUS (Pmode, XEXP (x, 1),
+		      copy_to_mode_reg (Pmode, XEXP (x, 0)));
+  else if (GET_CODE (x) == SYMBOL_REF
+	   || GET_CODE (x) == CONST
+           || GET_CODE (x) == LABEL_REF)
+    x = copy_to_suggested_reg (x, NULL_RTX, Pmode);
+  return x;
+}
+
 /* Emit special PIC prologues.  */
 
 void
@@ -6428,6 +7018,10 @@ print_operand (file, x, code)
       /* ??? What if offset is too big? Perhaps the caller knows it isn't? */
       fprintf (file, "%s+%d", frame_base_name, frame_base_offset);
       return;
+    case '&':
+      /* Print some local dynamic TLS name.  */
+      assemble_name (file, get_some_local_dynamic_name ());
+      return;
     case 'Y':
       /* Adjust the operand to take into account a RESTORE operation.  */
       if (GET_CODE (x) == CONST_INT)
@@ -8622,6 +9216,47 @@ sparc_encode_section_info (decl, first)
 {
   if (TARGET_CM_EMBMEDANY && TREE_CODE (decl) == FUNCTION_DECL)
     SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;
+
+  /* Encode thread-local data with %[GLil] for "global dynamic",
+     "local dynamic", "initial exec" or "local exec" TLS models,
+     respectively.  */
+
+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))
+    {
+      rtx symbol = XEXP (DECL_RTL (decl), 0);
+      const char *symbol_str = XSTR (symbol, 0);
+      char *newstr;
+      size_t len;
+      enum tls_model kind = decl_tls_model (decl);
+
+      if (symbol_str[0] == '%')
+	{
+	  if (symbol_str[1] == tls_model_chars[kind])
+	    return;
+	  symbol_str += 2;
+	}
+      len = strlen (symbol_str) + 1;
+      newstr = alloca (len + 2);
+
+      newstr[0] = '%';
+      newstr[1] = tls_model_chars[kind];
+      memcpy (newstr + 2, symbol_str, len);
+
+      XSTR (symbol, 0) = ggc_alloc_string (newstr, len + 2 - 1);
+    }
+}
+
+/* Undo the above when printing symbol names.  */
+
+static const char *
+sparc_strip_name_encoding (str)
+     const char *str;
+{
+  if (str[0] == '%')
+    str += 2;
+  if (str[0] == '*')
+    str += 1;
+  return str;
 }
 
 /* Output the assembler code for a thunk function.  THUNK_DECL is the
@@ -8763,4 +9398,73 @@ sparc_can_output_mi_thunk (thunk_fndecl, delta, vcall_offset, function)
   return (vcall_offset >= -32768 || ! fixed_regs[5]);
 }
 
+/* How to allocate a 'struct machine_function'.  */
+
+static struct machine_function *
+sparc_init_machine_status ()
+{
+  return ggc_alloc_cleared (sizeof (struct machine_function));
+}
+
+/* Locate some local-dynamic symbol still in use by this function
+   so that we can print its name in local-dynamic base patterns.  */
+
+static const char *
+get_some_local_dynamic_name ()
+{
+  rtx insn;
+
+  if (cfun->machine->some_ld_name)
+    return cfun->machine->some_ld_name;
+
+  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))
+    if (INSN_P (insn)
+	&& for_each_rtx (&PATTERN (insn), get_some_local_dynamic_name_1, 0))
+      return cfun->machine->some_ld_name;
+
+  abort ();
+}
+
+static int
+get_some_local_dynamic_name_1 (px, data)
+     rtx *px;
+     void *data ATTRIBUTE_UNUSED;
+{
+  rtx x = *px;
+
+  if (x
+      && GET_CODE (x) == SYMBOL_REF
+      && tls_symbolic_operand (x) == TLS_MODEL_LOCAL_DYNAMIC)
+    {
+      cfun->machine->some_ld_name = XSTR (x, 0);
+      return 1;
+    }
+
+  return 0;
+}
+
+/* This is called from dwarf2out.c via ASM_OUTPUT_DWARF_DTPREL.
+   We need to emit DTP-relative relocations.  */
+
+void
+sparc_output_dwarf_dtprel (file, size, x)
+     FILE *file;
+     int size;
+     rtx x;
+{
+  switch (size)
+    {
+    case 4:
+      fputs ("\t.word\t%r_tls_dtpoff32(", file);
+      break;
+    case 8:
+      fputs ("\t.xword\t%r_tls_dtpoff64(", file);
+      break;
+    default:
+      abort ();
+    }
+  output_addr_const (file, x);
+  fputs (")", file);
+}
+
 #include "gt-sparc.h"
diff --git a/gcc/config/sparc/sparc.h b/gcc/config/sparc/sparc.h
index 9f5911c..a801cad 100644
--- a/gcc/config/sparc/sparc.h
+++ b/gcc/config/sparc/sparc.h
@@ -2115,27 +2115,18 @@ do {									\
    When PIC, we do not accept an address that would require a scratch reg
    to load into a register.  */
 
-#define CONSTANT_ADDRESS_P(X)   \
-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF		\
-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH			\
-   || (GET_CODE (X) == CONST						\
-       && ! (flag_pic && pic_address_needs_scratch (X))))
+#define CONSTANT_ADDRESS_P(X) constant_address_p (X)
 
 /* Define this, so that when PIC, reload won't try to reload invalid
    addresses which require two reload registers.  */
 
-#define LEGITIMATE_PIC_OPERAND_P(X)  (! pic_address_needs_scratch (X))
+#define LEGITIMATE_PIC_OPERAND_P(X) legitimate_pic_operand_p (X)
 
 /* Nonzero if the constant value X is a legitimate general operand.
    Anything can be made to work except floating point constants.
    If TARGET_VIS, 0.0 can be made to work as well.  */
 
-#define LEGITIMATE_CONSTANT_P(X) 					\
-  (GET_CODE (X) != CONST_DOUBLE || GET_MODE (X) == VOIDmode || 		\
-   (TARGET_VIS &&							\
-    (GET_MODE (X) == SFmode || GET_MODE (X) == DFmode ||		\
-     GET_MODE (X) == TFmode) &&						\
-    fp_zero_operand (X, GET_MODE (X))))
+#define LEGITIMATE_CONSTANT_P(X) legitimate_constant_p (X)
 
 /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx
    and check its validity for a certain class.
@@ -2242,110 +2233,19 @@ do {									\
 #define RTX_OK_FOR_OLO10_P(X)						\
   (GET_CODE (X) == CONST_INT && INTVAL (X) >= -0x1000 && INTVAL (X) < 0xc00 - 8)
 
+#ifdef REG_OK_STRICT
 #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)		\
-{ if (RTX_OK_FOR_BASE_P (X))				\
+{							\
+  if (legitimate_address_p (MODE, X, 1))		\
     goto ADDR;						\
-  else if (GET_CODE (X) == PLUS)			\
-    {							\
-      register rtx op0 = XEXP (X, 0);			\
-      register rtx op1 = XEXP (X, 1);			\
-      if (flag_pic && op0 == pic_offset_table_rtx)	\
-	{						\
-	  if (RTX_OK_FOR_BASE_P (op1))			\
-	    goto ADDR;					\
-	  else if (flag_pic == 1			\
-		   && GET_CODE (op1) != REG		\
-		   && GET_CODE (op1) != LO_SUM		\
-		   && GET_CODE (op1) != MEM		\
-		   && (! SYMBOLIC_CONST (op1)		\
-		       || MODE == Pmode)		\
-		   && (GET_CODE (op1) != CONST_INT	\
-		       || SMALL_INT (op1)))		\
-	    goto ADDR;					\
-	}						\
-      else if (RTX_OK_FOR_BASE_P (op0))			\
-	{						\
-	  if ((RTX_OK_FOR_INDEX_P (op1)			\
- 	      /* We prohibit REG + REG for TFmode when	\
-		 there are no instructions which accept	\
-		 REG+REG instructions.  We do this	\
-		 because REG+REG is not an offsetable	\
-		 address.  If we get the situation	\
-		 in reload where source and destination	\
-		 of a movtf pattern are both MEMs with	\
-		 REG+REG address, then only one of them	\
-		 gets converted to an offsetable	\
-		 address.  */				\
- 	       && (MODE != TFmode			\
-		   || (TARGET_FPU && TARGET_ARCH64	\
-		       && TARGET_V9			\
-		       && TARGET_HARD_QUAD))		\
-	      /* We prohibit REG + REG on ARCH32 if	\
-		 not optimizing for DFmode/DImode	\
-		 because then mem_min_alignment is	\
-		 likely to be zero after reload and the \
-		 forced split would lack a matching	\
-		 splitter pattern.  */			\
-	       && (TARGET_ARCH64 || optimize		\
-		   || (MODE != DFmode			\
-		       && MODE != DImode)))		\
-	      || RTX_OK_FOR_OFFSET_P (op1))		\
-	    goto ADDR;					\
-	}						\
-      else if (RTX_OK_FOR_BASE_P (op1))			\
-	{						\
-	  if ((RTX_OK_FOR_INDEX_P (op0)			\
- 	      /* See the previous comment.  */		\
- 	       && (MODE != TFmode			\
-		  || (TARGET_FPU && TARGET_ARCH64	\
-		      && TARGET_V9			\
-		      && TARGET_HARD_QUAD))		\
-	       && (TARGET_ARCH64 || optimize		\
-		   || (MODE != DFmode			\
-		       && MODE != DImode)))		\
-	      || RTX_OK_FOR_OFFSET_P (op0))		\
-	    goto ADDR;					\
-	}						\
-      else if (USE_AS_OFFSETABLE_LO10			\
-	       && GET_CODE (op0) == LO_SUM		\
-	       && TARGET_ARCH64				\
-	       && ! TARGET_CM_MEDMID			\
-	       && RTX_OK_FOR_OLO10_P (op1))		\
-	{						\
-	  register rtx op00 = XEXP (op0, 0);		\
-	  register rtx op01 = XEXP (op0, 1);		\
-	  if (RTX_OK_FOR_BASE_P (op00)			\
-	      && CONSTANT_P (op01))			\
-	    goto ADDR;					\
-	}						\
-      else if (USE_AS_OFFSETABLE_LO10			\
-	       && GET_CODE (op1) == LO_SUM		\
-	       && TARGET_ARCH64				\
-	       && ! TARGET_CM_MEDMID			\
-	       && RTX_OK_FOR_OLO10_P (op0))		\
-	{						\
-	  register rtx op10 = XEXP (op1, 0);		\
-	  register rtx op11 = XEXP (op1, 1);		\
-	  if (RTX_OK_FOR_BASE_P (op10)			\
-	      && CONSTANT_P (op11))			\
-	    goto ADDR;					\
-	}						\
-    }							\
-  else if (GET_CODE (X) == LO_SUM)			\
-    {							\
-      register rtx op0 = XEXP (X, 0);			\
-      register rtx op1 = XEXP (X, 1);			\
-      if (RTX_OK_FOR_BASE_P (op0)			\
-	  && CONSTANT_P (op1)				\
-	  /* We can't allow TFmode, because an offset	\
-	     greater than or equal to the alignment (8)	\
-	     may cause the LO_SUM to overflow if !v9.  */\
-	  && (MODE != TFmode || TARGET_V9))		\
-	goto ADDR;					\
-    }							\
-  else if (GET_CODE (X) == CONST_INT && SMALL_INT (X))	\
+}
+#else
+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)		\
+{							\
+  if (legitimate_address_p (MODE, X, 0))		\
     goto ADDR;						\
 }
+#endif
 
 /* Go to LABEL if ADDR (a legitimate address expression)
    has an effect that depends on the machine mode it is used for.
@@ -2390,33 +2290,11 @@ do {									\
 
 /* On SPARC, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */
 #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)	\
-{ rtx sparc_x = (X);						\
-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)	\
-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 1),			\
-			force_operand (XEXP (X, 0), NULL_RTX));	\
-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)	\
-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),			\
-			force_operand (XEXP (X, 1), NULL_RTX));	\
-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)	\
-    (X) = gen_rtx_PLUS (Pmode, force_operand (XEXP (X, 0), NULL_RTX),\
-			XEXP (X, 1));				\
-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)	\
-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),			\
-			force_operand (XEXP (X, 1), NULL_RTX));	\
-  if (sparc_x != (X) && memory_address_p (MODE, X))		\
-    goto WIN;							\
-  if (flag_pic) (X) = legitimize_pic_address (X, MODE, 0);	\
-  else if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))	\
-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),			\
-			copy_to_mode_reg (Pmode, XEXP (X, 1)));	\
-  else if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))	\
-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 1),			\
-			copy_to_mode_reg (Pmode, XEXP (X, 0)));	\
-  else if (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST	\
-	   || GET_CODE (X) == LABEL_REF)			\
-    (X) = copy_to_suggested_reg (X, NULL_RTX, Pmode); 		\
-  if (memory_address_p (MODE, X))				\
-    goto WIN; }
+{						\
+  (X) = legitimize_address (X, OLDX, MODE);	\
+  if (memory_address_p (MODE, X))		\
+    goto WIN;					\
+}
 
 /* Try a machine-dependent way of reloading an illegitimate address
    operand.  If we find one, push the reload and jump to WIN.  This
@@ -2794,6 +2672,20 @@ case LABEL_REF: case SYMBOL_REF: case CONST_DOUBLE:
 
 #define USER_LABEL_PREFIX "_"
 
+/* Output a reference to a user-level label named NAME.  */
+
+#define ASM_OUTPUT_LABELREF(FILE,NAME)		\
+  do {						\
+    const char *xname = (NAME);			\
+   if (xname[0] == '%')				\
+     xname += 2;				\
+   if (xname[0] == '*')				\
+     xname += 1;				\
+   else						\
+     fputs (user_label_prefix, FILE);		\
+   fputs (xname, FILE);				\
+  } while (0)
+
 /* This is how to output a definition of an internal numbered label where
    PREFIX is the class of label and NUM is the number within the class.  */
 
@@ -2925,8 +2817,16 @@ do {									\
 #define ASM_OUTPUT_IDENT(FILE, NAME) \
   fprintf (FILE, "%s\"%s\"\n", IDENT_ASM_OP, NAME);
 
+/* Emit a dtp-relative reference to a TLS variable.  */
+
+#ifdef HAVE_AS_TLS
+#define ASM_OUTPUT_DWARF_DTPREL(FILE, SIZE, X) \
+  sparc_output_dwarf_dtprel (FILE, SIZE, X)
+#endif
+
 #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \
-  ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR) == '(' || (CHAR) == '_')
+  ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^'		\
+   || (CHAR) == '(' || (CHAR) == '_' || (CHAR) == '&')
 
 /* Print operand X (an rtx) in assembler syntax to file FILE.
    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.
@@ -3013,6 +2913,14 @@ do {									\
     }								\
 }
 
+#ifdef HAVE_AS_TLS
+#define TARGET_TLS 1
+#else
+#define TARGET_TLS 0
+#endif
+#define TARGET_SUN_TLS TARGET_TLS
+#define TARGET_GNU_TLS 0
+
 /* Define the codes that are matched by predicates in sparc.c.  */
 
 #define PREDICATE_CODES							\
@@ -3061,7 +2969,11 @@ do {									\
 {"input_operand", {SUBREG, REG, CONST_INT, MEM, CONST}},		\
 {"compare_operand", {SUBREG, REG, ZERO_EXTRACT}},			\
 {"const64_operand", {CONST_INT, CONST_DOUBLE}},				\
-{"const64_high_operand", {CONST_INT, CONST_DOUBLE}},
+{"const64_high_operand", {CONST_INT, CONST_DOUBLE}},			\
+{"tgd_symbolic_operand", {SYMBOL_REF}},					\
+{"tld_symbolic_operand", {SYMBOL_REF}},					\
+{"tie_symbolic_operand", {SYMBOL_REF}},					\
+{"tle_symbolic_operand", {SYMBOL_REF}},
 
 /* The number of Pmode words for the setjmp buffer.  */
 #define JMP_BUF_SIZE 12
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 3c566f1..832ed8d 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -38,6 +38,13 @@
    (UNSPEC_EMB_TEXTHI		14)
    (UNSPEC_EMB_TEXTULO		15)
    (UNSPEC_EMB_SETHM		18)
+
+   (UNSPEC_TLSGD		30)
+   (UNSPEC_TLSLDM		31)
+   (UNSPEC_TLSLDO		32)
+   (UNSPEC_TLSIE		33)
+   (UNSPEC_TLSLE		34)
+   (UNSPEC_TLSLD_BASE		35)
   ])
 
 (define_constants
@@ -201,6 +208,9 @@
 
 ;; Attributes for instruction and branch scheduling
 
+(define_attr "tls_call_delay" "false,true"
+  (symbol_ref "tls_call_delay (insn)"))
+
 (define_attr "in_call_delay" "false,true"
   (cond [(eq_attr "type" "uncond_branch,branch,call,sibcall,call_no_delay_slot,multi")
 	 	(const_string "false")
@@ -208,7 +218,8 @@
 	 	(if_then_else (eq_attr "length" "1")
 			      (const_string "true")
 			      (const_string "false"))]
-	(if_then_else (eq_attr "length" "1")
+	(if_then_else (and (eq_attr "length" "1")
+			   (eq_attr "tls_call_delay" "true"))
 		      (const_string "true")
 		      (const_string "false"))))
 
@@ -1693,6 +1704,10 @@
 	}
     }
 
+  /* Fixup TLS cases.  */
+  if (tls_symbolic_operand (operands [1]))
+    operands[1] = legitimize_tls_address (operands[1]);
+
   /* Fixup PIC cases.  */
   if (flag_pic)
     {
@@ -1752,6 +1767,10 @@
 	}
     }
 
+  /* Fixup TLS cases.  */
+  if (tls_symbolic_operand (operands [1]))
+    operands[1] = legitimize_tls_address (operands[1]);
+
   /* Fixup PIC cases.  */
   if (flag_pic)
     {
@@ -1834,6 +1853,10 @@
 	}
     }
 
+  /* Fixup TLS cases.  */
+  if (tls_symbolic_operand (operands [1]))
+    operands[1] = legitimize_tls_address (operands[1]);
+
   /* Fixup PIC cases.  */
   if (flag_pic)
     {
@@ -2010,6 +2033,10 @@
 	}
     }
 
+  /* Fixup TLS cases.  */
+  if (tls_symbolic_operand (operands [1]))
+    operands[1] = legitimize_tls_address (operands[1]);
+
   if (flag_pic)
     {
       if (CONSTANT_P (operands[1])
@@ -8356,3 +8383,566 @@
   "TARGET_V9"
   "t%C0\t%%xcc, %1"
   [(set_attr "type" "trap")])
+
+;; TLS support
+(define_insn "tgd_hi22"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (high:SI (unspec:SI [(match_operand 1 "tgd_symbolic_operand" "")]
+			    UNSPEC_TLSGD)))]
+  "TARGET_TLS"
+  "sethi\\t%%tgd_hi22(%a1), %0")
+
+(define_insn "tgd_lo10"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+		   (unspec:SI [(match_operand 2 "tgd_symbolic_operand" "")]
+			      UNSPEC_TLSGD)))]
+  "TARGET_TLS"
+  "add\\t%1, %%tgd_lo10(%a2), %0")
+
+(define_insn "tgd_add32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(plus:SI (match_operand:SI 1 "register_operand" "r")
+		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+			     (match_operand 3 "tgd_symbolic_operand" "")]
+			    UNSPEC_TLSGD)))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "add\\t%1, %2, %0, %%tgd_add(%a3)")
+
+(define_insn "tgd_add64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(plus:DI (match_operand:DI 1 "register_operand" "r")
+		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+			     (match_operand 3 "tgd_symbolic_operand" "")]
+			    UNSPEC_TLSGD)))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "add\\t%1, %2, %0, %%tgd_add(%a3)")
+
+(define_insn "tgd_call32"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:SI (unspec:SI [(match_operand:SI 1 "symbolic_operand" "s")
+				  (match_operand 2 "tgd_symbolic_operand" "")]
+				 UNSPEC_TLSGD))
+	      (match_operand 3 "" "")))
+   (clobber (reg:SI 15))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "call\t%a1, %%tgd_call(%a2)%#"
+  [(set_attr "type" "call")])
+
+(define_insn "tgd_call64"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:DI (unspec:DI [(match_operand:DI 1 "symbolic_operand" "s")
+				  (match_operand 2 "tgd_symbolic_operand" "")]
+				 UNSPEC_TLSGD))
+	      (match_operand 3 "" "")))
+   (clobber (reg:DI 15))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "call\t%a1, %%tgd_call(%a2)%#"
+  [(set_attr "type" "call")])
+
+(define_insn "tldm_hi22"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (high:SI (unspec:SI [(const_int 0)] UNSPEC_TLSLDM)))]
+  "TARGET_TLS"
+  "sethi\\t%%tldm_hi22(%&), %0")
+
+(define_insn "tldm_lo10"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+		    (unspec:SI [(const_int 0)] UNSPEC_TLSLDM)))]
+  "TARGET_TLS"
+  "add\\t%1, %%tldm_lo10(%&), %0")
+
+(define_insn "tldm_add32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(plus:SI (match_operand:SI 1 "register_operand" "r")
+		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")]
+			    UNSPEC_TLSLDM)))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "add\\t%1, %2, %0, %%tldm_add(%&)")
+
+(define_insn "tldm_add64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(plus:DI (match_operand:DI 1 "register_operand" "r")
+		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")]
+			    UNSPEC_TLSLDM)))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "add\\t%1, %2, %0, %%tldm_add(%&)")
+
+(define_insn "tldm_call32"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:SI (unspec:SI [(match_operand:SI 1 "symbolic_operand" "s")]
+				 UNSPEC_TLSLDM))
+	      (match_operand 2 "" "")))
+   (clobber (reg:SI 15))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "call\t%a1, %%tldm_call(%&)%#"
+  [(set_attr "type" "call")])
+
+(define_insn "tldm_call64"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:DI (unspec:DI [(match_operand:DI 1 "symbolic_operand" "s")]
+				 UNSPEC_TLSLDM))
+	      (match_operand 2 "" "")))
+   (clobber (reg:DI 15))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "call\t%a1, %%tldm_call(%&)%#"
+  [(set_attr "type" "call")])
+
+(define_insn "tldo_hix22"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (high:SI (unspec:SI [(match_operand 1 "tld_symbolic_operand" "")]
+			    UNSPEC_TLSLDO)))]
+  "TARGET_TLS"
+  "sethi\\t%%tldo_hix22(%a1), %0")
+
+(define_insn "tldo_lox10"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+		   (unspec:SI [(match_operand 2 "tld_symbolic_operand" "")]
+			      UNSPEC_TLSLDO)))]
+  "TARGET_TLS"
+  "xor\\t%1, %%tldo_lox10(%a2), %0")
+
+(define_insn "tldo_add32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(plus:SI (match_operand:SI 1 "register_operand" "r")
+		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+			     (match_operand 3 "tld_symbolic_operand" "")]
+			    UNSPEC_TLSLDO)))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "add\\t%1, %2, %0, %%tldo_add(%a3)")
+
+(define_insn "tldo_add64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(plus:DI (match_operand:DI 1 "register_operand" "r")
+		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+			     (match_operand 3 "tld_symbolic_operand" "")]
+			    UNSPEC_TLSLDO)))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "add\\t%1, %2, %0, %%tldo_add(%a3)")
+
+(define_insn "tie_hi22"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (high:SI (unspec:SI [(match_operand 1 "tie_symbolic_operand" "")]
+			    UNSPEC_TLSIE)))]
+  "TARGET_TLS"
+  "sethi\\t%%tie_hi22(%a1), %0")
+
+(define_insn "tie_lo10"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+		   (unspec:SI [(match_operand 2 "tie_symbolic_operand" "")]
+			      UNSPEC_TLSIE)))]
+  "TARGET_TLS"
+  "add\\t%1, %%tie_lo10(%a2), %0")
+
+(define_insn "tie_ld32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "register_operand" "r")
+		    (match_operand:SI 2 "register_operand" "r")
+		    (match_operand 3 "tie_symbolic_operand" "")]
+		   UNSPEC_TLSIE))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "ld\\t[%1 + %2], %0, %%tie_ld(%a3)"
+  [(set_attr "type" "load")])
+
+(define_insn "tie_ld64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(unspec:DI [(match_operand:DI 1 "register_operand" "r")
+		    (match_operand:SI 2 "register_operand" "r")
+		    (match_operand 3 "tie_symbolic_operand" "")]
+		   UNSPEC_TLSIE))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldx\\t[%1 + %2], %0, %%tie_ldx(%a3)"
+  [(set_attr "type" "load")])
+
+(define_insn "tie_add32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(plus:SI (match_operand:SI 1 "register_operand" "r")
+		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+			     (match_operand 3 "tld_symbolic_operand" "")]
+			    UNSPEC_TLSIE)))]
+  "TARGET_SUN_TLS && TARGET_ARCH32"
+  "add\\t%1, %2, %0, %%tie_add(%a3)")
+
+(define_insn "tie_add64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(plus:DI (match_operand:DI 1 "register_operand" "r")
+		 (unspec:DI [(match_operand:DI 2 "register_operand" "r")
+			     (match_operand 3 "tld_symbolic_operand" "")]
+			    UNSPEC_TLSIE)))]
+  "TARGET_SUN_TLS && TARGET_ARCH64"
+  "add\\t%1, %2, %0, %%tie_add(%a3)")
+
+(define_insn "tle_hix22_sp32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (high:SI (unspec:SI [(match_operand 1 "tle_symbolic_operand" "")]
+			    UNSPEC_TLSLE)))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "sethi\\t%%tle_hix22(%a1), %0")
+
+(define_insn "tle_lox10_sp32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+		   (unspec:SI [(match_operand 2 "tle_symbolic_operand" "")]
+			      UNSPEC_TLSLE)))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "xor\\t%1, %%tle_lox10(%a2), %0")
+
+(define_insn "tle_hix22_sp64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (high:DI (unspec:DI [(match_operand 1 "tle_symbolic_operand" "")]
+			    UNSPEC_TLSLE)))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "sethi\\t%%tle_hix22(%a1), %0")
+
+(define_insn "tle_lox10_sp64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(lo_sum:DI (match_operand:DI 1 "register_operand" "r")
+		   (unspec:DI [(match_operand 2 "tle_symbolic_operand" "")]
+			      UNSPEC_TLSLE)))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "xor\\t%1, %%tle_lox10(%a2), %0")
+
+;; Now patterns combinding tldo_add{32,64} with some integer loads or stores
+(define_insn "*tldo_ldub_sp32"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:SI 1 "register_operand" "r"))))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldub1_sp32"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(zero_extend:HI (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:SI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldub2_sp32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:SI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldsb1_sp32"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(sign_extend:HI (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:SI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldsb2_sp32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:SI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldub_sp64"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:DI 1 "register_operand" "r"))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldub1_sp64"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(zero_extend:HI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldub2_sp64"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldub3_sp64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldsb1_sp64"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(sign_extend:HI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldsb2_sp64"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldsb3_sp64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(sign_extend:DI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_lduh_sp32"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:SI 1 "register_operand" "r"))))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_lduh1_sp32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:SI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldsh1_sp32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:SI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "ldsh\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_lduh_sp64"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:DI 1 "register_operand" "r"))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_lduh1_sp64"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_lduh2_sp64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldsh1_sp64"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldsh\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldsh2_sp64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(sign_extend:DI (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldsh\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_lduw_sp32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mem:SI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:SI 1 "register_operand" "r"))))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "ld\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")])
+
+(define_insn "*tldo_lduw_sp64"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:DI 1 "register_operand" "r"))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "lduw\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")])
+
+(define_insn "*tldo_lduw1_sp64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "lduw\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")])
+
+(define_insn "*tldo_ldsw1_sp64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(sign_extend:DI (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+						     (match_operand 3 "tld_symbolic_operand" "")]
+						    UNSPEC_TLSLDO)
+					 (match_operand:DI 1 "register_operand" "r")))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldsw\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
+   (set_attr "us3load_type" "3cycle")])
+
+(define_insn "*tldo_ldx_sp64"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(mem:DI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:DI 1 "register_operand" "r"))))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "ldx\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "load")])
+
+(define_insn "*tldo_stb_sp32"
+  [(set (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:SI 1 "register_operand" "r")))
+	(match_operand:QI 0 "register_operand" "=r"))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "stb\t%0, [%1 + %2], %%tldo_add(%3)"
+  [(set_attr "type" "store")])
+
+(define_insn "*tldo_stb_sp64"
+  [(set (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:DI 1 "register_operand" "r")))
+	(match_operand:QI 0 "register_operand" "=r"))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "stb\t%0, [%1 + %2], %%tldo_add(%3)"
+  [(set_attr "type" "store")])
+
+(define_insn "*tldo_sth_sp32"
+  [(set (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:SI 1 "register_operand" "r")))
+	(match_operand:HI 0 "register_operand" "=r"))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "sth\t%0, [%1 + %2], %%tldo_add(%3)"
+  [(set_attr "type" "store")])
+
+(define_insn "*tldo_sth_sp64"
+  [(set (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:DI 1 "register_operand" "r")))
+	(match_operand:HI 0 "register_operand" "=r"))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "sth\t%0, [%1 + %2], %%tldo_add(%3)"
+  [(set_attr "type" "store")])
+
+(define_insn "*tldo_stw_sp32"
+  [(set (mem:SI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:SI 1 "register_operand" "r")))
+	(match_operand:SI 0 "register_operand" "=r"))]
+  "TARGET_TLS && TARGET_ARCH32"
+  "st\t%0, [%1 + %2], %%tldo_add(%3)"
+  [(set_attr "type" "store")])
+
+(define_insn "*tldo_stw_sp64"
+  [(set (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:DI 1 "register_operand" "r")))
+	(match_operand:SI 0 "register_operand" "=r"))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "stw\t%0, [%1 + %2], %%tldo_add(%3)"
+  [(set_attr "type" "store")])
+
+(define_insn "*tldo_stx_sp64"
+  [(set (mem:DI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			 (match_operand:DI 1 "register_operand" "r")))
+	(match_operand:DI 0 "register_operand" "=r"))]
+  "TARGET_TLS && TARGET_ARCH64"
+  "stx\t%0, [%1 + %2], %%tldo_add(%3)"
+  [(set_attr "type" "store")])
diff --git a/gcc/config/t-libunwind b/gcc/config/t-libunwind
index 53ba327..694565f 100644
--- a/gcc/config/t-libunwind
+++ b/gcc/config/t-libunwind
@@ -1,6 +1,14 @@
+# Use the system libunwind library.
+#
 # Override the default value from t-slibgcc-elf-ver and mention -lunwind
 # so that the resulting libgcc_s.so has the necessary DT_NEEDED entry for
 # libunwind.
 SHLIB_LC = -lunwind -lc
 LIB2ADDEH = $(srcdir)/unwind-libunwind.c $(srcdir)/unwind-sjlj.c \
 	    $(srcdir)/unwind-c.c
+LIB2ADDEH = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c \
+  $(srcdir)/unwind-compat.c $(srcdir)/unwind-dw2-fde-compat.c
+LIB2ADDEHSTATIC = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c
+
+T_CFLAGS += -DUSE_LIBUNWIND_EXCEPTIONS
+TARGET_LIBGCC2_CFLAGS += -DUSE_GAS_SYMVER
diff --git a/gcc/config/t-libunwind-elf b/gcc/config/t-libunwind-elf
new file mode 100644
index 0000000..a9609e7
--- /dev/null
+++ b/gcc/config/t-libunwind-elf
@@ -0,0 +1,30 @@
+# Build libunwind for ELF with the GNU linker.
+
+# Use unwind-dw2-fde-glibc
+LIBUNWIND = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde-glibc.c
+LIBUNWINDDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c
+
+SHLIBUNWIND_SOVERSION = 7
+SHLIBUNWIND_SONAME = @shlib_so_name@.so.$(SHLIBUNWIND_SOVERSION)
+SHLIBUNWIND_NAME = @shlib_dir@@shlib_so_name@.so.$(SHLIBUNWIND_SOVERSION)
+
+SHLIBUNWIND_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared \
+	-nodefaultlibs -Wl,-h,$(SHLIBUNWIND_SONAME) \
+	-Wl,-z,text -Wl,-z,defs -o $(SHLIBUNWIND_NAME).tmp \
+	@multilib_flags@ $(SHLIB_OBJS) -lc && \
+	rm -f $(SHLIB_SOLINK) && \
+	if [ -f $(SHLIBUNWIND_NAME) ]; then \
+	  mv -f $(SHLIBUNWIND_NAME) $(SHLIBUNWIND_NAME).backup; \
+	else true; fi && \
+	mv $(SHLIBUNWIND_NAME).tmp $(SHLIBUNWIND_NAME) && \
+	$(LN_S) $(SHLIBUNWIND_NAME) $(SHLIB_SOLINK)
+
+# $(slibdir) double quoted to protect it from expansion while building
+# libgcc.mk.  We want this delayed until actual install time.
+SHLIBUNWIND_INSTALL = \
+	$$(SHELL) $$(srcdir)/mkinstalldirs $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL); \
+	$(INSTALL_DATA) $(SHLIBUNWIND_NAME) \
+	  $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIBUNWIND_SONAME); \
+	rm -f $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SOLINK); \
+	$(LN_S) $(SHLIBUNWIND_SONAME) \
+	  $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SOLINK)
diff --git a/gcc/config/t-slibgcc-elf-ver b/gcc/config/t-slibgcc-elf-ver
index a176b10..a9f4010 100644
--- a/gcc/config/t-slibgcc-elf-ver
+++ b/gcc/config/t-slibgcc-elf-ver
@@ -13,8 +13,12 @@ SHLIB_LC = -lc
 SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
 	-Wl,--soname=$(SHLIB_SONAME) \
 	-Wl,--version-script=$(SHLIB_MAP) \
-	-o $(SHLIB_NAME) @multilib_flags@ $(SHLIB_OBJS) $(SHLIB_LC) && \
+	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) $(SHLIB_LC) && \
 	rm -f $(SHLIB_SOLINK) && \
+	if [ -f $(SHLIB_NAME) ]; then \
+	  mv -f $(SHLIB_NAME) $(SHLIB_NAME).backup; \
+	else true; fi && \
+	mv $(SHLIB_NAME).tmp $(SHLIB_NAME) && \
 	$(LN_S) $(SHLIB_NAME) $(SHLIB_SOLINK)
 # $(slibdir) double quoted to protect it from expansion while building
 # libgcc.mk.  We want this delayed until actual install time.
diff --git a/gcc/config/t-slibgcc-sld b/gcc/config/t-slibgcc-sld
index 6bdd521..44e7f18 100644
--- a/gcc/config/t-slibgcc-sld
+++ b/gcc/config/t-slibgcc-sld
@@ -10,9 +10,13 @@ SHLIB_SLIBDIR_QUAL = @shlib_slibdir_qual@
 
 SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
 	-Wl,-h,$(SHLIB_SONAME) -Wl,-z,text -Wl,-z,defs \
-	-Wl,-M,$(SHLIB_MAP) -o $(SHLIB_NAME) \
+	-Wl,-M,$(SHLIB_MAP) -o $(SHLIB_NAME).tmp \
 	@multilib_flags@ $(SHLIB_OBJS) -lc && \
 	rm -f $(SHLIB_SOLINK) && \
+	if [ -f $(SHLIB_NAME) ]; then \
+	  mv -f $(SHLIB_NAME) $(SHLIB_NAME).backup; \
+	else true; fi && \
+	mv $(SHLIB_NAME).tmp $(SHLIB_NAME) && \
 	$(LN_S) $(SHLIB_NAME) $(SHLIB_SOLINK)
 # $(slibdir) double quoted to protect it from expansion while building
 # libgcc.mk.  We want this delayed until actual install time.
diff --git a/gcc/configure b/gcc/configure
index fc53e88..7c3fdee 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -6854,8 +6854,9 @@ fi
 # This prevents libgcc2 from containing any code which requires libc
 # support.
 inhibit_libc=
-if { test x$host != x$target && test "x$with_headers" = x &&
-     test "x$with_sysroot" = x ; } || test x$with_newlib = xyes ; then
+if { { test x$host != x$target && test "x$with_sysroot" = x ; } ||
+       test x$with_newlib = xyes ; } &&
+     { test "x$with_headers" = x || test "x$with_headers" = xno ; } ; then
        inhibit_libc=-Dinhibit_libc
 fi
 
@@ -7277,7 +7278,7 @@ elif test x$gcc_cv_as != x; then
  	# GNU LD versions before 2.12.1 have buggy support for STV_HIDDEN.
 	# This is irritatingly difficult to feature test for.  Look for 
 	# the date string after the version number.
-	ld_ver=`$gcc_cv_ld --version 2>/dev/null | head -1`
+	ld_ver=`$gcc_cv_ld --version 2>/dev/null | head -n 1`
 	if echo "$ld_ver" | grep GNU > /dev/null; then
                ld_vers=`echo $ld_ver | sed -n 's,^.*[  ]\([0-9][0-9]*\.[0-9][0-9]*\(\|\.[0-9][0-9]*\(\|\.[0-9][0-9]*\)\)\)\([  ].*\|\)$,\1,p'`
                ld_date=`echo $ld_ver | sed -n 's,^.*\([2-9][0-9][0-9][0-9]\)[-]*\([01][0-9]\)[-]*\([0-3][0-9]\).*$,\1\2\3,p'`
@@ -7343,7 +7344,7 @@ EOF
 		# ??? There exists an elf-specific test that will crash
 		# the assembler.  Perhaps it's better to figure out whether
 		# arbitrary sections are supported and try the test.
-		as_ver=`$gcc_cv_as --version 2>/dev/null | head -1`
+		as_ver=`$gcc_cv_as --version 2>/dev/null | head -n 1`
 		if echo "$as_ver" | grep GNU > /dev/null; then
 			as_ver=`echo $as_ver | sed -e 's/GNU assembler \([0-9.][0-9.]*\).*/\1/'`
 			as_major=`echo $as_ver | sed 's/\..*//'`
@@ -7372,7 +7373,7 @@ if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then
   fi
 elif test x$gcc_cv_as != x; then
 	# Check if this is GAS.
-	as_ver=`$gcc_cv_as --version < /dev/null 2> /dev/null | head -1`
+	as_ver=`$gcc_cv_as --version < /dev/null 2> /dev/null | head -n 1`
 	rm -f a.out 2> /dev/null
 	if echo "$as_ver" | grep GNU > /dev/null; then
 		# Versions up to and including 2.11.0 may mis-optimize
@@ -7425,7 +7426,7 @@ EOF
 		# and we got the correct data, then succeed.
 		if $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1 \
 		   && $gcc_cv_objdump -s -j .eh_frame conftest.o 2>/dev/null \
-		      | tail -3 > conftest.got \
+		      | tail -n 3 > conftest.got \
 		   && { cmp conftest.lit conftest.got > /dev/null 2>&1 \
 		        || cmp conftest.big conftest.got > /dev/null 2>&1; }
 		then
@@ -7581,6 +7582,33 @@ foo:	.long	25
 	tls_first_major=2
 	tls_first_minor=14
 	;;
+  sparc*-*-*)
+    conftest_s='
+	.section ".tdata","awT",@progbits
+foo:	.long	25
+	.text
+	sethi	%tgd_hi22(foo), %o0
+	add	%o0, %tgd_lo10(foo), %o1
+	add	%l7, %o1, %o0, %tgd_add(foo)
+	call	__tls_get_addr, %tgd_call(foo)
+	sethi	%tldm_hi22(foo), %l1
+	add	%l1, %tldm_lo10(foo), %l2
+	add	%l7, %l2, %o0, %tldm_add(foo)
+	call	__tls_get_addr, %tldm_call(foo)
+	sethi	%tldo_hix22(foo), %l3
+	xor	%l3, %tldo_lox10(foo), %l4
+	add	%o0, %l4, %l5, %tldo_add(foo)
+	sethi	%tie_hi22(foo), %o3
+	add	%o3, %tie_lo10(foo), %o3
+	ld	[%l7 + %o3], %o2, %tie_ld(foo)
+	add	%g7, %o2, %o4, %tie_add(foo)
+	sethi	%tle_hix22(foo), %l1
+	xor	%l1, %tle_lox10(foo), %o5
+	ld	[%g7 + %o5], %o1'
+	tls_first_major=2
+	tls_first_minor=14
+	tls_as_opt=-32
+	;;
 esac
 if test -z "$tls_first_major"; then
   :
diff --git a/gcc/configure.in b/gcc/configure.in
index d3f0484..f63d475 100644
--- a/gcc/configure.in
+++ b/gcc/configure.in
@@ -854,16 +854,10 @@ AC_ARG_ENABLE(sjlj-exceptions,
 AC_DEFINE_UNQUOTED(CONFIG_SJLJ_EXCEPTIONS, $sjlj,
   [Define 0/1 to force the choice for exception handling model.])])
 
-AC_CHECK_LIB(unwind, main, use_libunwind_default=yes, use_libunwind_default=no)
-# Use libunwind based exception handling.
-AC_ARG_ENABLE(libunwind-exceptions,
-[  --enable-libunwind-exceptions  force use libunwind for exceptions],
-use_libunwind_exceptions=$enableval,
-use_libunwind_exceptions=$use_libunwind_default)
-if test x"$use_libunwind_exceptions" = xyes; then
-   AC_DEFINE(USE_LIBUNWIND_EXCEPTIONS, 1,
-	[Define if gcc should use -lunwind.])
-fi
+# For platforms with the unwind ABI which includes an unwind library,
+# libunwind, we can choose to use the system libunwind.
+AC_ARG_WITH(system-libunwind,
+[  --with-system-libunwind use installed libunwind])
 
 target_gtfiles=
 build_xm_file=
@@ -1276,8 +1270,9 @@ fi
 # This prevents libgcc2 from containing any code which requires libc
 # support.
 inhibit_libc=
-if { test x$host != x$target && test "x$with_headers" = x &&
-     test "x$with_sysroot" = x ; } || test x$with_newlib = xyes ; then
+if { { test x$host != x$target && test "x$with_sysroot" = x ; } ||
+       test x$with_newlib = xyes ; } &&
+     { test "x$with_headers" = x || test "x$with_headers" = xno ; } ; then
        inhibit_libc=-Dinhibit_libc
 fi
 AC_SUBST(inhibit_libc)
@@ -1683,7 +1678,7 @@ elif test x$gcc_cv_as != x; then
  	# GNU LD versions before 2.12.1 have buggy support for STV_HIDDEN.
 	# This is irritatingly difficult to feature test for.  Look for 
 	# the date string after the version number.
-	ld_ver=`$gcc_cv_ld --version 2>/dev/null | head -1`
+	ld_ver=`$gcc_cv_ld --version 2>/dev/null | head -n 1`
 	if echo "$ld_ver" | grep GNU > /dev/null; then
 changequote(,)dnl
                ld_vers=`echo $ld_ver | sed -n 's,^.*[  ]\([0-9][0-9]*\.[0-9][0-9]*\(\|\.[0-9][0-9]*\(\|\.[0-9][0-9]*\)\)\)\([  ].*\|\)$,\1,p'`
@@ -1748,7 +1743,7 @@ EOF
 		# ??? There exists an elf-specific test that will crash
 		# the assembler.  Perhaps it's better to figure out whether
 		# arbitrary sections are supported and try the test.
-		as_ver=`$gcc_cv_as --version 2>/dev/null | head -1`
+		as_ver=`$gcc_cv_as --version 2>/dev/null | head -n 1`
 		if echo "$as_ver" | grep GNU > /dev/null; then
 changequote(,)dnl
 			as_ver=`echo $as_ver | sed -e 's/GNU assembler \([0-9.][0-9.]*\).*/\1/'`
@@ -1776,7 +1771,7 @@ if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then
   fi
 elif test x$gcc_cv_as != x; then
 	# Check if this is GAS.
-	as_ver=`$gcc_cv_as --version < /dev/null 2> /dev/null | head -1`
+	as_ver=`$gcc_cv_as --version < /dev/null 2> /dev/null | head -n 1`
 	rm -f a.out 2> /dev/null
 	if echo "$as_ver" | grep GNU > /dev/null; then
 		# Versions up to and including 2.11.0 may mis-optimize
@@ -1829,7 +1824,7 @@ EOF
 		# and we got the correct data, then succeed.
 		if $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1 \
 		   && $gcc_cv_objdump -s -j .eh_frame conftest.o 2>/dev/null \
-		      | tail -3 > conftest.got \
+		      | tail -n 3 > conftest.got \
 		   && { cmp conftest.lit conftest.got > /dev/null 2>&1 \
 		        || cmp conftest.big conftest.got > /dev/null 2>&1; }
 		then
@@ -1896,7 +1891,6 @@ foo:	.long	25
 	tls_first_minor=13
 	;;
   i[34567]86-*-*)
-changequote([,])dnl
     conftest_s='
 	.section ".tdata","awT",@progbits
 foo:	.long	25
@@ -1981,6 +1975,34 @@ foo:	.long	25
 	tls_first_major=2
 	tls_first_minor=14
 	;;
+  sparc*-*-*)
+    conftest_s='
+	.section ".tdata","awT",@progbits
+foo:	.long	25
+	.text
+	sethi	%tgd_hi22(foo), %o0
+	add	%o0, %tgd_lo10(foo), %o1
+	add	%l7, %o1, %o0, %tgd_add(foo)
+	call	__tls_get_addr, %tgd_call(foo)
+	sethi	%tldm_hi22(foo), %l1
+	add	%l1, %tldm_lo10(foo), %l2
+	add	%l7, %l2, %o0, %tldm_add(foo)
+	call	__tls_get_addr, %tldm_call(foo)
+	sethi	%tldo_hix22(foo), %l3
+	xor	%l3, %tldo_lox10(foo), %l4
+	add	%o0, %l4, %l5, %tldo_add(foo)
+	sethi	%tie_hi22(foo), %o3
+	add	%o3, %tie_lo10(foo), %o3
+	ld	[%l7 + %o3], %o2, %tie_ld(foo)
+	add	%g7, %o2, %o4, %tie_add(foo)
+	sethi	%tle_hix22(foo), %l1
+	xor	%l1, %tle_lox10(foo), %o5
+	ld	[%g7 + %o5], %o1'
+	tls_first_major=2
+	tls_first_minor=14
+	tls_as_opt=-32
+	;;
+changequote([,])dnl
 esac
 if test -z "$tls_first_major"; then
   :
@@ -2438,6 +2460,25 @@ if test x"$gcc_cv_ld_eh_frame_hdr" = xyes; then
 fi
 AC_MSG_RESULT($gcc_cv_ld_eh_frame_hdr)
 
+AC_MSG_CHECKING(linker -Bstatic/-Bdynamic option)
+gcc_cv_ld_static_dynamic=no
+if test $in_tree_ld = yes ; then
+  if test "$gcc_cv_gld_major_version" -eq 2 -a "$gcc_cv_gld_minor_version" -ge 10; then
+    gcc_cv_ld_static_dynamic=yes
+  fi
+elif test x$gcc_cv_ld != x; then
+	# Check if linker supports -Bstatic/-Bdynamic option
+	if $gcc_cv_ld --help 2>/dev/null | grep -- -Bstatic > /dev/null \
+	  && $gcc_cv_ld --help 2>/dev/null | grep -- -Bdynamic > /dev/null; then
+		gcc_cv_ld_static_dynamic=yes
+	fi
+fi
+if test x"$gcc_cv_ld_static_dynamic" = xyes; then
+	AC_DEFINE(HAVE_LD_STATIC_DYNAMIC, 1,
+[Define if your linker supports -Bstatic/-Bdynamic option.])
+fi
+AC_MSG_RESULT($gcc_cv_ld_static_dynamic)
+
 AC_MSG_CHECKING(linker --as-needed support)
 gcc_cv_ld_as_needed=no
 if test x$gcc_cv_gld_major_version != x -a x$gcc_cv_gld_minor_version != x; then
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index ee7f7db..b39cdde 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -5171,6 +5171,8 @@ tsubst_friend_class (friend_tmpl, args)
       DECL_USE_TEMPLATE (tmpl) = 0;
       DECL_TEMPLATE_INFO (tmpl) = NULL_TREE;
       CLASSTYPE_USE_TEMPLATE (TREE_TYPE (tmpl)) = 0;
+      CLASSTYPE_TI_ARGS (TREE_TYPE (tmpl))
+	= INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (TREE_TYPE (tmpl)));
 
       /* Inject this template into the global scope.  */
       friend_type = TREE_TYPE (pushdecl_top_level (tmpl));
diff --git a/gcc/cppexp.c b/gcc/cppexp.c
index 12919f6..ee34d1e 100644
--- a/gcc/cppexp.c
+++ b/gcc/cppexp.c
@@ -173,7 +173,8 @@ cpp_classify_number (pfile, token)
       str++;
 
       /* Require at least one hex digit to classify it as hex.  */
-      if ((*str == 'x' || *str == 'X') && ISXDIGIT (str[1]))
+      if ((*str == 'x' || *str == 'X')
+	  && (str[1] == '.' || ISXDIGIT (str[1])))
 	{
 	  radix = 16;
 	  str++;
diff --git a/gcc/cselib.c b/gcc/cselib.c
index d88c638..2a6ea27 100644
--- a/gcc/cselib.c
+++ b/gcc/cselib.c
@@ -1,6 +1,6 @@
 /* Common subexpression elimination library for GNU compiler.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001 Free Software Foundation, Inc.
+   1999, 2000, 2001, 2003 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -123,9 +123,16 @@ static GTY((deletable (""))) cselib_val *empty_vals;
 static GTY((deletable (""))) struct elt_list *empty_elt_lists;
 static GTY((deletable (""))) struct elt_loc_list *empty_elt_loc_lists;
 
+/* An unknown VALUE to be used which replaces any VALUE after it has
+   been garbage collected as useless.  */
+static GTY(()) rtx unknown_addr;
+
 /* Set by discard_useless_locs if it deleted the last location of any
    value.  */
 static int values_became_useless;
+
+static cselib_discard_callback discard_callback;
+static void *discard_callback_arg;
 
 
 /* Allocate a struct elt_list and fill in its two elements with the
@@ -205,6 +212,9 @@ unchain_one_value (v)
   while (v->addr_list)
     unchain_one_elt_list (&v->addr_list);
 
+  if (discard_callback)
+    (*discard_callback) (discard_callback_arg, v->u.val_rtx);
+
   v->u.next_free = empty_vals;
   empty_vals = v;
 }
@@ -1407,6 +1417,9 @@ cselib_init ()
   if (! callmem)
     callmem = gen_rtx_MEM (BLKmode, const0_rtx);
 
+  discard_callback = NULL;
+  discard_callback_arg = NULL;
+
   cselib_nregs = max_reg_num ();
   if (reg_values_old != NULL && VARRAY_SIZE (reg_values_old) >= cselib_nregs)
     {
@@ -1426,6 +1439,31 @@ cselib_init ()
   cselib_current_insn_in_libcall = false;
 }
 
+/* Register a callback for freeing useless VALUEs.  */
+
+void
+cselib_register_discard_callback (callback, arg)
+     cselib_discard_callback callback;
+     void *arg;
+{
+  discard_callback = callback;
+  discard_callback_arg = arg;
+}
+
+/* Return a VALUE that can replace a VALUE which became
+   useless and is to be discarded.  */
+
+rtx
+cselib_unknown_addr ()
+{
+  if (! unknown_addr)
+    {
+      cselib_val *v = new_cselib_val (-1, Pmode);
+      unknown_addr = v->u.val_rtx;
+    }
+  return unknown_addr;
+}
+
 /* Called when the current user is done with cselib.  */
 
 void
diff --git a/gcc/cselib.h b/gcc/cselib.h
index 877d804..8f6ffd5 100644
--- a/gcc/cselib.h
+++ b/gcc/cselib.h
@@ -1,6 +1,6 @@
 /* Common subexpression elimination for GNU compiler.
    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999 Free Software Foundation, Inc.
+   1999, 2003 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -60,6 +60,8 @@ struct elt_list GTY(())
   cselib_val *elt;
 };
 
+typedef void (*cselib_discard_callback) PARAMS ((void *, rtx));
+
 extern cselib_val *cselib_lookup	PARAMS ((rtx, enum machine_mode, int));
 extern void cselib_update_varray_sizes	PARAMS ((void));
 extern void cselib_init			PARAMS ((void));
@@ -69,3 +71,6 @@ extern int rtx_equal_for_cselib_p	PARAMS ((rtx, rtx));
 extern int references_value_p		PARAMS ((rtx, int));
 extern rtx cselib_subst_to_values	PARAMS ((rtx));
 extern void cselib_invalidate_rtx	PARAMS ((rtx));
+extern void cselib_register_discard_callback
+     PARAMS ((cselib_discard_callback, void *));
+extern rtx cselib_unknown_addr		PARAMS ((void));
diff --git a/gcc/diagnostic.c b/gcc/diagnostic.c
index a7f2d2c..cdda0f5 100644
--- a/gcc/diagnostic.c
+++ b/gcc/diagnostic.c
@@ -1208,7 +1208,7 @@ internal_error VPARAMS ((const char *msgid, ...))
 "Please submit a full bug report,\n\
 with preprocessed source if appropriate.\n\
 See %s for instructions.\n", bug_report_url);
-  exit (FATAL_EXIT_CODE);
+  exit (ICE_EXIT_CODE);
 }
 
 void
@@ -1316,7 +1316,7 @@ error_recursion (context)
 "Please submit a full bug report,\n\
 with preprocessed source if appropriate.\n\
 See %s for instructions.\n", bug_report_url);
-  exit (FATAL_EXIT_CODE);
+  exit (ICE_EXIT_CODE);
 }
 
 /* Given a partial pathname as input, return another pathname that
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 5d7479e..6cbaa10 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -1944,10 +1944,11 @@ attributes are currently defined for functions on all targets:
 @code{format}, @code{format_arg}, @code{no_instrument_function},
 @code{section}, @code{constructor}, @code{destructor}, @code{used},
 @code{unused}, @code{deprecated}, @code{weak}, @code{malloc},
-@code{alias}, and @code{nonnull}.  Several other attributes are defined
-for functions on particular target systems.  Other attributes, including
-@code{section} are supported for variables declarations
-(@pxref{Variable Attributes}) and for types (@pxref{Type Attributes}).
+@code{alias}, @code{warn_unused_result} and @code{nonnull}.
+Several other attributes are defined for functions on particular
+target systems.  Other attributes, including @code{section} are
+supported for variables declarations (@pxref{Variable Attributes})
+and for types (@pxref{Type Attributes}).
 
 You may also specify attributes with @samp{__} preceding and following
 each keyword.  This allows you to use them in header files without
@@ -2277,6 +2278,26 @@ results in a warning on line 3 but not line 2.
 The @code{deprecated} attribute can also be used for variables and
 types (@pxref{Variable Attributes}, @pxref{Type Attributes}.)
 
+@item warn_unused_result
+@cindex @code{warn_unused_result} attribute
+The @code{warn_unused_result} attribute causes a warning to be emitted
+if a caller of the function with this attribute does not use its
+return value.  This is useful for functions where not checking
+the result is either a security problem or always a bug, such as
+@code{realloc}.
+
+@smallexample
+int fn () __attribute__ ((warn_unused_result));
+int foo ()
+@{
+  if (fn () < 0) return -1;
+  fn ();
+  return 0;
+@}
+@end smallexample
+
+results in warning on line 5.
+
 @item weak
 @cindex @code{weak} attribute
 The @code{weak} attribute causes the declaration to be emitted as a weak
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 978d34a..8261d8c 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -2433,6 +2433,10 @@ have installed.
 IA-64 processor (also known as IPF, or Itanium Processor Family)
 running GNU/Linux.
 
+If you are using the installed system libunwind library with
+@option{--with-system-libunwind}, then you must use libunwind 0.98 or
+later.
+
 The toolchain is not completely finished, so requirements will continue
 to change.
 GCC 3.0.1 and later require glibc 2.2.4.
@@ -2461,6 +2465,8 @@ the option @option{--with-gnu-as} may be necessary.
 The GCC libunwind library has not been ported to HPUX. This means that for
 GCC versions 3.2.3 and earlier, @option{--enable-libunwind-exceptions}
 is required to build GCC. For GCC 3.3 and later, this is the default.
+For gcc 3.4.3 and later, @option{--enable-libunwind-exceptions} is
+removed and the system libunwind library will always be used.
 
 @html
 <hr />
diff --git a/gcc/expr.c b/gcc/expr.c
index 78b35db..28e17cf 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -45,6 +45,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 #include "langhooks.h"
 #include "intl.h"
 #include "tm_p.h"
+#include "input.h"
 
 /* Decide whether a function's arguments should be processed
    from first to last or from last to first.
@@ -192,6 +193,9 @@ static char direct_store[NUM_MACHINE_MODES];
 
 static bool float_extend_from_mem[NUM_MACHINE_MODES][NUM_MACHINE_MODES];
 
+/* Stack of EXPR_WITH_FILE_LOCATION nested expressions.  */
+struct file_stack *expr_wfl_stack;
+
 /* If a memory-to-memory move would take MOVE_RATIO or more simple
    move-instruction sequences, we will do a movstr or libcall instead.  */
 
@@ -6892,16 +6896,24 @@ expand_expr (exp, target, tmode, modifier)
     case EXPR_WITH_FILE_LOCATION:
       {
 	rtx to_return;
-	const char *saved_input_filename = input_filename;
-	int saved_lineno = lineno;
+	struct file_stack fs;
+	fs.name = input_filename;
+	fs.line = lineno;
+	fs.next = expr_wfl_stack;
+	expr_wfl_stack = &fs;
 	input_filename = EXPR_WFL_FILENAME (exp);
 	lineno = EXPR_WFL_LINENO (exp);
 	if (EXPR_WFL_EMIT_LINE_NOTE (exp))
 	  emit_line_note (input_filename, lineno);
 	/* Possibly avoid switching back and forth here.  */
-	to_return = expand_expr (EXPR_WFL_NODE (exp), target, tmode, modifier);
-	input_filename = saved_input_filename;
-	lineno = saved_lineno;
+	to_return = expand_expr (EXPR_WFL_NODE (exp),
+				 (ignore ? const0_rtx : target),
+				 tmode, modifier);
+	if (expr_wfl_stack != &fs)
+	  abort ();
+	input_filename = fs.name;
+	lineno = fs.line;
+	expr_wfl_stack = fs.next;
 	return to_return;
       }
 
diff --git a/gcc/f/com.h b/gcc/f/com.h
index b58e5ba..baba53c 100644
--- a/gcc/f/com.h
+++ b/gcc/f/com.h
@@ -233,7 +233,7 @@ void ffecom_finish_decl (tree decl, tree init, bool is_top_level);
 void ffecom_finish_progunit (void);
 tree ffecom_get_invented_identifier (const char *pattern, ...)
   ATTRIBUTE_PRINTF_1;
-ffeinfoKindtype ffecom_gfrt_basictype (ffecomGfrt ix);
+ffeinfoBasictype ffecom_gfrt_basictype (ffecomGfrt ix);
 ffeinfoKindtype ffecom_gfrt_kindtype (ffecomGfrt ix);
 void ffecom_init_0 (void);
 void ffecom_init_2 (void);
diff --git a/gcc/final.c b/gcc/final.c
index f0c78e3..925a612 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -2909,7 +2909,15 @@ alter_subreg (xp)
   /* simplify_subreg does not remove subreg from volatile references.
      We are required to.  */
   if (GET_CODE (y) == MEM)
-    *xp = adjust_address (y, GET_MODE (x), SUBREG_BYTE (x));
+    {
+      register int offset = SUBREG_BYTE (x);
+
+      if (BYTES_BIG_ENDIAN)
+	if (GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (GET_MODE (y)))
+	  offset -= GET_MODE_SIZE (GET_MODE (x)) - GET_MODE_SIZE (GET_MODE (y));
+
+      *xp = adjust_address (y, GET_MODE (x), offset);
+    }
   else
     {
       rtx new = simplify_subreg (GET_MODE (x), y, GET_MODE (y),
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 8753cd6..40f27c6 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -109,6 +109,10 @@ extern int getrusage PARAMS ((int, struct rusage *));
 #define TARGET_OBJECT_SUFFIX ".o"
 #endif
 
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+static void retry_ice PARAMS ((const char *, const char **));
+#endif
+
 #ifndef VMS
 /* FIXME: the location independence code for VMS is hairier than this,
    and hasn't been written.  */
@@ -1342,6 +1346,8 @@ static const char *const standard_exec_prefix = STANDARD_EXEC_PREFIX;
 static const char *const standard_exec_prefix_1 = "/usr/lib/gcc/";
 static const char *md_exec_prefix = MD_EXEC_PREFIX;
 
+static const char *standard_libexec_prefix = STANDARD_LIBEXEC_PREFIX;
+
 static const char *md_startfile_prefix = MD_STARTFILE_PREFIX;
 static const char *md_startfile_prefix_1 = MD_STARTFILE_PREFIX_1;
 static const char *const standard_startfile_prefix = STANDARD_STARTFILE_PREFIX;
@@ -1576,12 +1582,19 @@ init_spec ()
 			    "-lgcc_s"
 #else
 			    "-lgcc_s%M"
+#endif
+#ifdef USE_LIBUNWIND_EXCEPTIONS
+			    " -lunwind"
 #endif
 			    ,
 			    "-lgcc",
 			    "-lgcc_eh"
 #ifdef USE_LIBUNWIND_EXCEPTIONS
+# ifdef HAVE_LD_STATIC_DYNAMIC
+			    " %{!static:-Bstatic} -lunwind %{!static:-Bdynamic}"
+# else
 			    " -lunwind"
+# endif
 #endif
 			    );
 
@@ -2727,7 +2740,7 @@ execute ()
       if (commands[i].pid == -1)
 	pfatal_pexecute (errmsg_fmt, errmsg_arg);
 
-      if (string != commands[i].prog)
+      if (i && string != commands[i].prog)
 	free ((PTR) string);
     }
 
@@ -2805,6 +2818,18 @@ See %s for instructions.",
 	      else if (WIFEXITED (status)
 		       && WEXITSTATUS (status) >= MIN_FATAL_STATUS)
 		{
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+		  /* For ICEs in cc1, cc1obj, cc1plus see if it is
+		     reproducible or not.  */
+		  char *p;
+		  if (getenv("GCC_RETRY_ICE") == NULL
+		      && WEXITSTATUS (status) == ICE_EXIT_CODE
+		      && j == 0
+		      && (p = strrchr (commands[j].argv[0], DIR_SEPARATOR))
+		      && ! strncmp (p + 1, "cc1", 3))
+		    retry_ice (commands[j].prog, commands[j].argv);
+#endif
+
 		  if (WEXITSTATUS (status) > greatest_status)
 		    greatest_status = WEXITSTATUS (status);
 		  ret_code = -1;
@@ -2816,6 +2841,10 @@ See %s for instructions.",
 	      break;
 	    }
       }
+
+    if (commands[0].argv[0] != commands[0].prog)
+      free ((PTR) commands[0].argv[0]);
+
     return ret_code;
   }
 }
@@ -3691,6 +3720,8 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
 	      PREFIX_PRIORITY_LAST, 2, warn_std_ptr, 0);
   add_prefix (&exec_prefixes, standard_exec_prefix_1, "BINUTILS",
 	      PREFIX_PRIORITY_LAST, 2, warn_std_ptr, 0);
+  add_prefix (&exec_prefixes, standard_libexec_prefix, "BINUTILS",
+	      PREFIX_PRIORITY_LAST, 2, warn_std_ptr, 0);
 #endif
 
   add_prefix (&startfile_prefixes, standard_exec_prefix, "BINUTILS",
@@ -5795,6 +5826,226 @@ give_switch (switchnum, omit_first_word, include_blanks)
   switches[switchnum].validated = 1;
 }
 
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+#define RETRY_ICE_ATTEMPTS 2
+
+static void
+retry_ice (prog, argv)
+     const char *prog;
+     const char **argv;
+{
+  int nargs, out_arg = -1, quiet = 0, attempt;
+  int pid, retries, sleep_interval;
+  const char **new_argv;
+  char *temp_filenames[RETRY_ICE_ATTEMPTS * 2 + 2];
+
+  if (input_filename == NULL || ! strcmp (input_filename, "-"))
+    return;
+
+  for (nargs = 0; argv[nargs] != NULL; ++nargs)
+    /* Only retry compiler ICEs, not preprocessor ones.  */
+    if (! strcmp (argv[nargs], "-E"))
+      return;
+    else if (argv[nargs][0] == '-' && argv[nargs][1] == 'o')
+      {
+	if (out_arg == -1)
+	  out_arg = nargs;
+	else
+	  return;
+      }
+    /* If the compiler is going to output any time information,
+       it might varry between invocations.  */
+    else if (! strcmp (argv[nargs], "-quiet"))
+      quiet = 1;
+    else if (! strcmp (argv[nargs], "-ftime-report"))
+      return;
+
+  if (out_arg == -1 || !quiet)
+    return;
+
+  memset (temp_filenames, '\0', sizeof (temp_filenames));
+  new_argv = alloca ((nargs + 3) * sizeof (const char *));
+  memcpy (new_argv, argv, (nargs + 1) * sizeof (const char *));
+  new_argv[nargs++] = "-frandom-seed=0";
+  new_argv[nargs] = NULL;
+  if (new_argv[out_arg][2] == '\0')
+    new_argv[out_arg + 1] = "-";
+  else
+    new_argv[out_arg] = "-o-";
+
+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS + 1; ++attempt)
+    {
+      int fd;
+      int status;
+
+      temp_filenames[attempt * 2] = make_temp_file (".out");
+      temp_filenames[attempt * 2 + 1] = make_temp_file (".err");
+
+      if (attempt == RETRY_ICE_ATTEMPTS)
+        {
+	  int i;
+	  int fd1, fd2;
+	  struct stat st1, st2;
+	  size_t n, len;
+	  char *buf;
+
+	  buf = xmalloc (8192);
+
+	  for (i = 0; i < 2; ++i)
+	    {
+	      fd1 = open (temp_filenames[i], O_RDONLY);
+	      fd2 = open (temp_filenames[2 + i], O_RDONLY);
+
+	      if (fd1 < 0 || fd2 < 0)
+		{
+		  i = -1;
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      if (fstat (fd1, &st1) < 0 || fstat (fd2, &st2) < 0)
+		{
+		  i = -1;
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      if (st1.st_size != st2.st_size)
+		{
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      len = 0;
+	      for (n = st1.st_size; n; n -= len)
+		{
+		  len = n;
+		  if (len > 4096)
+		    len = 4096;
+
+		  if (read (fd1, buf, len) != (int) len
+		      || read (fd2, buf + 4096, len) != (int) len)
+		    {
+		      i = -1;
+		      break;
+		    }
+
+		  if (memcmp (buf, buf + 4096, len) != 0)
+		    break;
+		}
+
+	      close (fd1);
+	      close (fd2);
+
+	      if (n)
+		break;
+	    }
+
+	  free (buf);
+	  if (i == -1)
+	    break;
+
+	  if (i != 2)
+	    {
+	      notice ("The bug is not reproducible, so it is likely a hardware or OS problem.\n");
+	      break;
+	    }
+
+          fd = open (temp_filenames[attempt * 2], O_RDWR);
+	  if (fd < 0)
+	    break;
+	  write (fd, "//", 2);
+	  for (i = 0; i < nargs; i++)
+	    {
+	      write (fd, " ", 1);
+	      write (fd, new_argv[i], strlen (new_argv[i]));
+	    }
+	  write (fd, "\n", 1);
+	  new_argv[nargs] = "-E";
+	  new_argv[nargs + 1] = NULL;
+        }
+
+      /* Fork a subprocess; wait and retry if it fails.  */
+      sleep_interval = 1;
+      pid = -1;
+      for (retries = 0; retries < 4; retries++)
+	{
+	  pid = fork ();
+	  if (pid >= 0)
+	    break;
+	  sleep (sleep_interval);
+	  sleep_interval *= 2;
+	}
+
+      if (pid < 0)
+	break;
+      else if (pid == 0)
+	{
+	  if (attempt != RETRY_ICE_ATTEMPTS)
+	    fd = open (temp_filenames[attempt * 2], O_RDWR);
+	  if (fd < 0)
+	    exit (-1);
+	  if (fd != 1)
+	    {
+	      close (1);
+	      dup (fd);
+	      close (fd);
+	    }
+
+	  fd = open (temp_filenames[attempt * 2 + 1], O_RDWR);
+	  if (fd < 0)
+	    exit (-1);
+	  if (fd != 2)
+	    {
+	      close (2);
+	      dup (fd);
+	      close (fd);
+	    }
+
+	  if (prog == new_argv[0])
+	    execvp (prog, (char *const *) new_argv);
+	  else
+	    execv (new_argv[0], (char *const *) new_argv);
+	  exit (-1);
+	}
+
+      if (waitpid (pid, &status, 0) < 0)
+	break;
+
+      if (attempt < RETRY_ICE_ATTEMPTS
+	  && (! WIFEXITED (status) || WEXITSTATUS (status) != ICE_EXIT_CODE))
+	{
+	  notice ("The bug is not reproducible, so it is likely a hardware or OS problem.\n");
+	  break;
+	}
+      else if (attempt == RETRY_ICE_ATTEMPTS)
+	{
+	  close (fd);
+	  if (WIFEXITED (status)
+	      && WEXITSTATUS (status) == SUCCESS_EXIT_CODE)
+	    {
+	      notice ("Preprocessed source stored into %s file, please attach this to your bugreport.\n",
+		      temp_filenames[attempt * 2]);
+	      /* Make sure it is not deleted.  */
+	      free (temp_filenames[attempt * 2]);
+	      temp_filenames[attempt * 2] = NULL;
+	      break;
+	    }
+	}
+    }
+
+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS * 2 + 2; attempt++)
+    if (temp_filenames[attempt])
+      {
+	unlink (temp_filenames[attempt]);
+	free (temp_filenames[attempt]);
+      }
+}
+#endif
+
 /* Search for a file named NAME trying various prefixes including the
    user's -B prefix and some standard ones.
    Return the absolute file name found.  If nothing is found, return NAME.  */
diff --git a/gcc/input.h b/gcc/input.h
index 28bb648..b0c5691 100644
--- a/gcc/input.h
+++ b/gcc/input.h
@@ -42,6 +42,9 @@ struct file_stack
    The line member is not accurate for the innermost file on the stack.  */
 extern struct file_stack *input_file_stack;
 
+/* Stack of EXPR_WITH_FILE_LOCATION nested expressions.  */
+extern struct file_stack *expr_wfl_stack;
+
 /* Incremented on each change to input_file_stack.  */
 extern int input_file_stack_tick;
 
diff --git a/gcc/java/Make-lang.in b/gcc/java/Make-lang.in
index 745c175..191fade 100644
--- a/gcc/java/Make-lang.in
+++ b/gcc/java/Make-lang.in
@@ -325,6 +325,11 @@ java/xref.o: java/xref.c java/xref.h $(CONFIG_H) $(JAVA_TREE_H) toplev.h \
   $(SYSTEM_H)
 java/zextract.o: java/zextract.c $(CONFIG_H) $(SYSTEM_H) java/zipfile.h
 
+# jcf-parse.o needs -save-temps on m68k-linux, else it segfaults
+java/jcf-parse.o: java/jcf-parse.c $(CONFIG_H) $(SYSTEM_H) $(JAVA_TREE_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+		$(srcdir)/java/jcf-parse.c $(OUTPUT_OPTION)
+
 # jcf-io.o needs $(ZLIBINC) added to cflags.
 java/jcf-io.o: java/jcf-io.c $(CONFIG_H) $(SYSTEM_H) $(JAVA_TREE_H)
 	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(ZLIBINC) \
diff --git a/gcc/java/gjavah.c b/gcc/java/gjavah.c
index dc05673..741107d 100644
--- a/gcc/java/gjavah.c
+++ b/gcc/java/gjavah.c
@@ -46,7 +46,7 @@ FILE *out = NULL;
 static int found_error = 0;
 
 /* Nonzero if we're generating JNI output.  */
-static int flag_jni = 0;
+int flag_jni = 0;
 
 /* When nonzero, warn when source file is newer than matching class
    file.  */
diff --git a/gcc/java/keyword.gperf b/gcc/java/keyword.gperf
index 1087d3b..7e672b5 100644
--- a/gcc/java/keyword.gperf
+++ b/gcc/java/keyword.gperf
@@ -33,7 +33,7 @@ static unsigned int hash		PARAMS ((const char *, unsigned int));
 #ifdef __GNUC__
 __inline
 #endif
-const struct java_keyword *java_keyword	PARAMS ((const char *, unsigned int));
+static const struct java_keyword *java_keyword	PARAMS ((const char *, unsigned int));
 %%
 abstract, ABSTRACT_TK
 default, DEFAULT_TK
diff --git a/gcc/java/keyword.h b/gcc/java/keyword.h
index 24fcef5..e3fd92e 100644
--- a/gcc/java/keyword.h
+++ b/gcc/java/keyword.h
@@ -33,7 +33,7 @@ static unsigned int hash		PARAMS ((const char *, unsigned int));
 #ifdef __GNUC__
 __inline
 #endif
-const struct java_keyword *java_keyword	PARAMS ((const char *, unsigned int));
+static const struct java_keyword *java_keyword	PARAMS ((const char *, unsigned int));
 
 #define TOTAL_KEYWORDS 52
 #define MIN_WORD_LENGTH 2
diff --git a/gcc/loop.c b/gcc/loop.c
index 6dee48f..7cfb8ba 100644
--- a/gcc/loop.c
+++ b/gcc/loop.c
@@ -906,6 +906,7 @@ scan_loop (loop, flags)
 			  || (! (GET_CODE (SET_SRC (set)) == REG
 				 && (REGNO (SET_SRC (set))
 				     < FIRST_PSEUDO_REGISTER))))
+		      && regno >= FIRST_PSEUDO_REGISTER 
 		      /* This test is not redundant; SET_SRC (set) might be
 			 a call-clobbered register and the life of REGNO
 			 might span a call.  */
@@ -1160,7 +1161,7 @@ scan_loop (loop, flags)
 
   /* Now that we've moved some things out of the loop, we might be able to
      hoist even more memory references.  */
-  load_mems (loop);
+  /*load_mems (loop);*/
 
   /* Recalculate regs->array if load_mems has created new registers.  */
   if (max_reg_num () > regs->num)
diff --git a/gcc/mklibgcc.in b/gcc/mklibgcc.in
index 5164ce2..1448f38 100644
--- a/gcc/mklibgcc.in
+++ b/gcc/mklibgcc.in
@@ -15,7 +15,13 @@
 # LIB2ADD
 # LIB2ADD_ST 
 # LIB2ADDEH
+# LIB2ADDEHSTATIC
+# LIB2ADDEHSHARED
 # LIB2ADDEHDEP
+# LIBUNWIND
+# LIBUNWINDDEP
+# SHLIBUNWIND_LINK
+# SHLIBUNWIND_INSTALL
 # FPBIT
 # FPBIT_FUNCS
 # LIB2_DIVMOD_FUNCS
@@ -105,7 +111,8 @@ done
 
 libgcc2_objs=""
 libgcc2_st_objs=""
-libgcc2_eh_objs=""
+libgcc2_eh_static_objs=""
+libgcc2_eh_shared_objs=""
 
 for name in $LIB2FUNCS_1 $LIB2FUNCS_2; do
   for ml in $MULTILIBS; do
@@ -224,13 +231,27 @@ for file in $LIB2ADDEH; do
     echo $out: stmp-dirs $file
     echo "	$gcc_compile" $flags -fexceptions -c $file -o $out
   done
-  if [ "$SHLIB_LINK" ]; then
-    libgcc2_eh_objs="$libgcc2_eh_objs ${oname}${objext}"
-  else
+  if [ -z "$SHLIB_LINK" ]; then
     libgcc2_objs="$libgcc2_objs ${oname}${objext}"
   fi
 done
 
+if [ "$SHLIB_LINK" ]; then
+  # Those should be in libgcc_eh.a.
+  for file in $LIB2ADDEHSTATIC; do
+    name=`echo $file | sed -e 's/[.][cSo]$//' -e 's/[.]asm$//' -e 's/[.]txt$//'`
+    oname=`echo $name | sed -e 's,.*/,,'`
+    libgcc2_eh_static_objs="$libgcc2_eh_static_objs ${oname}${objext}"
+  done
+
+  # Those should be in libgcc.so.
+  for file in $LIB2ADDEHSHARED; do
+    name=`echo $file | sed -e 's/[.][cSo]$//' -e 's/[.]asm$//' -e 's/[.]txt$//'`
+    oname=`echo $name | sed -e 's,.*/,,'`
+    libgcc2_eh_shared_objs="$libgcc2_eh_shared_objs ${oname}${objext}"
+  done
+fi
+
 for file in $LIB2ADD_ST; do
   name=`echo $file | sed -e 's/[.][cSo]$//' -e 's/[.]asm$//' -e 's/[.]txt$//'`
   oname=`echo $name | sed -e 's,.*/,,'`
@@ -249,6 +270,31 @@ for file in $LIB2ADD_ST; do
   libgcc2_st_objs="$libgcc2_st_objs ${oname}${objext}"
 done
 
+if [ "$LIBUNWIND" ]; then
+  libunwind_static_objs=""
+  libunwind_shared_objs=""
+  for file in $LIBUNWIND; do
+    name=`echo $file | sed -e 's/[.][cSo]$//' -e 's/[.]asm$//' -e 's/[.]txt$//'`
+    oname=`echo $name | sed -e 's,.*/,,'`
+
+    for ml in $MULTILIBS; do
+      dir=`echo ${ml} | sed -e 's/;.*$//' -e 's/=/$(EQ)/g'`
+      flags=`echo ${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`;
+      out="libgcc/${dir}/${oname}${objext}"
+      if [ ${name}.asm = ${file} ]; then
+	flags="$flags -xassembler-with-cpp"
+      fi
+
+      echo $out: stmp-dirs $file $LIBUNWINDDEP
+      echo "	$gcc_compile" $flags -fexceptions -c $file -o $out
+      echo ${out}s: stmp-dirs $file $LIBUNWINDDEP
+      echo "	$gcc_compile" $flags -fexceptions -DSHARED -c $file -o ${out}s
+    done
+    libunwind_static_objs="$libunwind_static_objs ${oname}${objext}"
+    libunwind_shared_objs="$libunwind_shared_objs ${oname}${objext}s"
+  done
+fi
+
 # SHLIB_MKMAP
 # SHLIB_MKMAP_OPTS
 # SHLIB_MAPFILES
@@ -257,17 +303,21 @@ for ml in $MULTILIBS; do
   flags=`echo ${ml} | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`;
 
   libgcc_objs=""
-  libgcc_eh_objs=""
+  libgcc_eh_static_objs=""
+  libgcc_eh_shared_objs=""
   for o in $libgcc1_objs; do
     libgcc_objs="$libgcc_objs libgcc/${dir}/$o"
   done
   for o in $libgcc2_objs; do
     libgcc_objs="$libgcc_objs libgcc/${dir}/$o"
   done
-  for o in $libgcc2_eh_objs; do
-    libgcc_eh_objs="$libgcc_eh_objs libgcc/${dir}/$o"
+  for o in $libgcc2_eh_static_objs; do
+    libgcc_eh_static_objs="$libgcc_eh_static_objs libgcc/${dir}/$o"
   done
-  libgcc_sh_objs="$libgcc_objs $libgcc_eh_objs"
+  for o in $libgcc2_eh_shared_objs; do
+    libgcc_eh_shared_objs="$libgcc_eh_shared_objs libgcc/${dir}/$o"
+  done
+  libgcc_sh_objs="$libgcc_objs $libgcc_eh_shared_objs"
   shlib_deps="$libgcc_sh_objs"
 
   libgcc_st_objs=""
@@ -275,6 +325,18 @@ for ml in $MULTILIBS; do
     libgcc_st_objs="$libgcc_st_objs libgcc/${dir}/$o"
   done
 
+  if [ "$LIBUNWIND" ]; then
+    libunwind_a_objs=""
+    for o in $libunwind_static_objs; do
+      libunwind_a_objs="$libunwind_a_objs libgcc/${dir}/$o"
+    done
+    libunwind_sh_objs=""
+    for o in $libunwind_shared_objs; do
+      libunwind_sh_objs="$libunwind_sh_objs libgcc/${dir}/$o"
+    done
+    shlibunwind_deps="$libunwind_sh_objs"
+  fi
+
   if [ "$SHLIB_LINK" -a "$SHLIB_MKMAP" ]; then
     mapfile="libgcc/${dir}/libgcc.map"
     tmpmapfile="libgcc/${dir}/tmp-libgcc.map"
@@ -326,12 +388,22 @@ for ml in $MULTILIBS; do
   echo '	  $(RANLIB_FOR_TARGET)' ${dir}/libgcc.a ';' \\
   echo '	else true; fi;'
 
+  if [ "$LIBUNWIND" ]; then
+    echo ""
+    echo "${dir}/libunwind.a: stmp-dirs $libunwind_a_objs"
+    echo "	-rm -rf ${dir}/libunwind.a"
+    echo '	$(AR_CREATE_FOR_TARGET)' ${dir}/libunwind.a $libunwind_a_objs
+    echo '	$(RANLIB_FOR_TARGET)' ${dir}/libunwind.a
+    echo ""
+    echo "${dir}/libgcc.a: ${dir}/libunwind.a"
+  fi
+
   if [ "$SHLIB_LINK" ]; then
 
     echo ""
-    echo "${dir}/libgcc_eh.a: stmp-dirs $libgcc_eh_objs"
+    echo "${dir}/libgcc_eh.a: stmp-dirs $libgcc_eh_static_objs"
     echo "	-rm -rf ${dir}/libgcc_eh.a"
-    echo '	$(AR_CREATE_FOR_TARGET)' ${dir}/libgcc_eh.a $libgcc_eh_objs
+    echo '	$(AR_CREATE_FOR_TARGET)' ${dir}/libgcc_eh.a $libgcc_eh_static_objs
     echo '	if $(RANLIB_TEST_FOR_TARGET) ; then' \\
     echo '	  $(RANLIB_FOR_TARGET)' ${dir}/libgcc_eh.a ';' \\
     echo '	else true; fi;'
@@ -339,10 +411,16 @@ for ml in $MULTILIBS; do
     if [ -z "$SHLIB_MULTILIB" ]; then
       if [ "$dir" = . ]; then
 	shlib_base_name=libgcc_s
+	shlibunwind_base_name=libunwind
       else
 	shlib_base_name=libgcc_s_`echo $dir | sed s,/,_,g`
+	shlibunwind_base_name=libunwind_`echo $dir | sed s,/,_,g`
       fi
       shlib_so_name="$shlib_base_name"
+      shlibunwind_so_name="$shlibunwind_base_name"
+      if [ "$LIBUNWIND" ]; then
+	shlib_deps="$shlib_deps ${dir}/${shlibunwind_base_name}${SHLIB_EXT}"
+      fi
       shlib_dir=
       if [ -n "$MULTILIB_OSDIRNAMES" ]; then
 	if [ "$dir" != . ]; then
@@ -353,8 +431,10 @@ for ml in $MULTILIBS; do
 	  os_multilib_base=`echo $os_multilib_dir | sed -n "s~/${gcc_multilib_sup}\$~~p"`
 	  if [ -z "$os_multilib_base" ]; then
 	    shlib_so_name=libgcc_s
+	    shlibunwind_so_name=libunwind
 	  else
 	    shlib_so_name=libgcc_s_`echo $gcc_multilib_sup | sed s,/,_,g`
+	    shlibunwind_so_name=libunwind_`echo $gcc_multilib_sup | sed s,/,_,g`
 	  fi
 	fi
       fi
@@ -368,8 +448,21 @@ for ml in $MULTILIBS; do
 	       -e "s%@shlib_map_file@%$mapfile%g" \
 	       -e "s%@shlib_so_name@%$shlib_so_name%g" \
 	       -e "s%@shlib_dir@%$shlib_dir%g"
+      if [ "$LIBUNWIND" ]; then
+	echo ""
+	echo "${dir}/${shlibunwind_base_name}${SHLIB_EXT}: $shlibunwind_deps"
+	echo "	$SHLIBUNWIND_LINK" \
+	   | sed -e "s%@multilib_flags@%$flags%g" \
+		 -e "s%@multilib_dir@%$dir%g" \
+		 -e "s%@shlib_objs@%$libunwind_sh_objs%g" \
+		 -e "s%@shlib_base_name@%$shlibunwind_base_name%g" \
+		 -e "s%@shlib_so_name@%$shlibunwind_so_name%g" \
+		 -e "s%@shlib_dir@%$shlib_dir%g" \
+		 -e "s%@shlib_slibdir_qual@%%g"
+      fi
     elif [ "$SHLIB_MULTILIB" = "$dir" ]; then
       shlib_base_name="libgcc_s";
+      shlibunwind_base_name="libunwind";
       echo ""
       echo "${shlib_base_name}${SHLIB_EXT}: $shlib_deps"
       echo "	$SHLIB_LINK" \
@@ -380,6 +473,18 @@ for ml in $MULTILIBS; do
 	       -e "s%@shlib_map_file@%$mapfile%g" \
 	       -e "s%@shlib_so_name@%$shlib_base_name%g" \
 	       -e "s%@shlib_dir@%%g"
+      if [ "$LIBUNWIND" ]; then
+	echo ""
+	echo "${shlibunwind_base_name}${SHLIB_EXT}: $shlibunwind_deps"
+	echo "	$SHLIBUNWIND_LINK" \
+	   | sed -e "s%@multilib_flags@%$flags%g" \
+		 -e "s%@multilib_dir@%$dir%g" \
+		 -e "s%@shlib_objs@%$libgcc_sh_objs%g" \
+		 -e "s%@shlib_base_name@%$shlibunwind_base_name%g" \
+		 -e "s%@shlib_so_name@%$shlibunwind_base_name%g" \
+		 -e "s%@shlib_dir@%%g" \
+		 -e "s%@shlib_slibdir_qual@%%g"
+      fi
     fi
   fi
 done
@@ -398,6 +503,7 @@ echo '	  if [ -d $(stage)/$$dir ]; then true; else '$mkinstalldirs' $(stage)/$$d
 echo '	done'
 echo '	-for dir in '"${dirs}"'; do \'
 echo '	  mv $$dir/*'"${objext}"' $(stage)/$$dir; \'
+echo '	  mv $$dir/*'"${objext}s"' $(stage)/$$dir || true; \'
 echo '	  test ! -f $$dir/stacknote.s || mv $$dir/stacknote.s $(stage)/$$dir; \'
 echo '	done'
 
@@ -411,6 +517,9 @@ for ml in $MULTILIBS; do
     dirs="$dirs ${dir} libgcc/${dir}"
   fi
   all="$all ${dir}/libgcc.a"
+  if [ "$LIBUNWIND" ]; then
+    all="$all ${dir}/libunwind.a"
+  fi
   if [ "$SHLIB_LINK" ]; then
     all="$all ${dir}/libgcc_eh.a"
     if [ -z "$SHLIB_MULTILIB" ]; then
@@ -420,8 +529,14 @@ for ml in $MULTILIBS; do
 	suff=_`echo $dir | sed s,/,_,g`
       fi
       all="$all ${dir}/libgcc_s${suff}${SHLIB_EXT}"
+      if [ "$LIBUNWIND" ]; then
+	all="$all ${dir}/${dir}/libunwind${suff}${SHLIB_EXT}"
+      fi
     elif [ "$SHLIB_MULTILIB" = "$dir" ]; then
       all="$all libgcc_s${SHLIB_EXT}"
+      if [ "$LIBUNWIND" ]; then
+	all="$all ${dir}/${dir}/libunwind${SHLIB_EXT}"
+      fi
     fi
   fi
 done
@@ -479,10 +594,13 @@ for ml in $MULTILIBS; do
     if [ -z "$SHLIB_MULTILIB" ]; then
       if [ "$dir" = . ]; then
 	shlib_base_name=libgcc_s
+	shlibunwind_base_name=libunwind
       else
 	shlib_base_name=libgcc_s_`echo $dir | sed s,/,_,g`
+	shlibunwind_base_name=libunwind_`echo $dir | sed s,/,_,g`
       fi
       shlib_so_name="$shlib_base_name"
+      shlibunwind_so_name="$shlibunwind_base_name"
       shlib_dir=
       shlib_slibdir_qual=
       if [ -n "$MULTILIB_OSDIRNAMES" ]; then
@@ -495,11 +613,13 @@ for ml in $MULTILIBS; do
 	os_multilib_base=`echo $os_multilib_dir | sed -n "s~/${gcc_multilib_sup}\$~~p"`
 	if [ -z "$os_multilib_base" ]; then
 	  shlib_so_name=libgcc_s
+	  shlibunwind_so_name=libunwind
 	  if [ "$os_multilib_dir" != "." ]; then
 	    shlib_slibdir_qual="/$os_multilib_dir"
 	  fi
 	else
 	  shlib_so_name=libgcc_s_`echo $gcc_multilib_sup | sed s,/,_,g`
+	  shlibunwind_so_name=libunwind_`echo $gcc_multilib_sup | sed s,/,_,g`
 	  shlib_slibdir_qual="/$os_multilib_base"
 	fi
       fi
@@ -508,6 +628,16 @@ for ml in $MULTILIBS; do
 	      -e "s%@shlib_so_name@%$shlib_so_name%g" \
 	      -e "s%@shlib_dir@%$shlib_dir%g" \
 	      -e "s%@shlib_slibdir_qual@%$shlib_slibdir_qual%g"
+      if [ "$LIBUNWIND" ]; then
+	echo "	$SHLIBUNWIND_INSTALL" \
+	   | sed -e "s%@shlib_base_name@%$shlibunwind_base_name%g" \
+		 -e "s%@shlib_so_name@%$shlibunwind_so_name%g" \
+		 -e "s%@shlib_dir@%$shlib_dir%g" \
+		 -e "s%@shlib_slibdir_qual@%$shlib_slibdir_qual%g"
+	libunwinddir='$(DESTDIR)$(slibdir)$(shlib_slibdir_qual)/$(shlib_dir)'
+	echo '	$(INSTALL_DATA)' ${dir}/libunwind.a ${libunwinddir}/
+	echo '	$(RANLIB_FOR_TARGET)' ${libunwinddir}/libunwind.a
+      fi
     elif [ "$SHLIB_MULTILIB" = "$dir" ]; then
       shlib_base_name="libgcc_s";
       echo "	$SHLIB_INSTALL" \
@@ -515,6 +645,16 @@ for ml in $MULTILIBS; do
 	      -e "s%@shlib_so_name@%$shlib_base_name%g" \
 	      -e "s%@shlib_dir@%%g" \
 	      -e "s%@shlib_slibdir_qual@%%g"
+      if [ "$LIBUNWIND" ]; then
+	echo "	$SHLIBUNWIND_INSTALL" \
+	   | sed -e "s%@shlib_base_name@%$shlibunwind_base_name%g" \
+		 -e "s%@shlib_so_name@%$shlibunwind_base_name%g" \
+		 -e "s%@shlib_dir@%%g" \
+		 -e "s%@shlib_slibdir_qual@%%g"
+	libunwinddir='$(DESTDIR)$(slibdir)'
+	echo '	$(INSTALL_DATA)' ${dir}/libunwind.a ${libunwinddir}/
+	echo '	$(RANLIB_FOR_TARGET)' ${libunwinddir}/libunwind.a
+      fi
     fi
   fi
 done
diff --git a/gcc/po/ca.po b/gcc/po/ca.po
index 082c1a5..b81a626 100644
--- a/gcc/po/ca.po
+++ b/gcc/po/ca.po
@@ -17745,7 +17745,7 @@ msgstr "passant el valor negatiu `%E' per a %s %P de \"%D\""
 
 #: cp/typeck.c:5887
 msgid "%s of negative value `%E' to `%T'"
-msgstr "%s de valor negatiu `%I' a \"%T\""
+msgstr "%s de valor negatiu `%E' a \"%T\""
 
 #: cp/typeck.c:5982
 msgid "cannot convert `%T' to `%T' for argument `%P' to `%D'"
diff --git a/gcc/po/es.po b/gcc/po/es.po
index d2e9bd0..070084b 100644
--- a/gcc/po/es.po
+++ b/gcc/po/es.po
@@ -1933,12 +1933,12 @@ msgstr "se desconoce el car
 #: c-format.c:1927
 #, c-format
 msgid "%s does not support the `%%%c' %s format"
-msgstr "%1$s no tiene soporte para el formato %3$s `%%%2$c'"
+msgstr "%s no tiene soporte para el formato `%%%c' %s"
 
 #: c-format.c:1943
 #, c-format
 msgid "%s used with `%%%c' %s format"
-msgstr "se us %1$s con el formato %3$s `%%%2$c'"
+msgstr "se us %s con el formato `%%%c' %s"
 
 #: c-format.c:1952
 #, c-format
@@ -1948,12 +1948,12 @@ msgstr "%s no tiene soporte para %s"
 #: c-format.c:1961
 #, c-format
 msgid "%s does not support %s with the `%%%c' %s format"
-msgstr "%1$s no tiene soporte para %2$s con el formato %4$s `%%%3$c'"
+msgstr "%s no tiene soporte para %s con el formato `%%%c' %s"
 
 #: c-format.c:1994
 #, c-format
 msgid "%s ignored with %s and `%%%c' %s format"
-msgstr "se ignora %1$s con %2$s y el formato %4$s `%%%3$c'"
+msgstr "se ignora %s con %s y el formato `%%%c' %s"
 
 #: c-format.c:1998
 #, c-format
@@ -1963,7 +1963,7 @@ msgstr "se ignora %s con %s en el formato %s"
 #: c-format.c:2004
 #, c-format
 msgid "use of %s and %s together with `%%%c' %s format"
-msgstr "uso de %1$s y %2$s junto con el formato %4$s `%%%3$c'"
+msgstr "uso de %s y %s junto con el formato `%%%c' %s"
 
 #: c-format.c:2008
 #, c-format
@@ -1994,7 +1994,7 @@ msgstr "uso del modificador de longitud `%s' con el car
 #: c-format.c:2080
 #, c-format
 msgid "%s does not support the `%%%s%c' %s format"
-msgstr "%1$s no tiene soporte para el formato %4$s `%%%2$s%3$c'"
+msgstr "%s no tiene soporte para el formato `%%%s%c' %s"
 
 #: c-format.c:2095
 msgid "operand number specified with suppressed assignment"
diff --git a/gcc/reload1.c b/gcc/reload1.c
index 5e85f14..71dab34 100644
--- a/gcc/reload1.c
+++ b/gcc/reload1.c
@@ -6934,6 +6934,10 @@ do_input_reload (chain, rl, j)
      actually no need to store the old value in it.  */
 
   if (optimize
+      /* Only attempt this for input reloads; for RELOAD_OTHER we miss
+	 that there may be multiple uses of the previous output reload.
+	 Restricting to RELOAD_FOR_INPUT is mostly paranoia.  */
+      && rl->when_needed == RELOAD_FOR_INPUT
       && (reload_inherited[j] || reload_override_in[j])
       && rl->reg_rtx
       && GET_CODE (rl->reg_rtx) == REG
diff --git a/gcc/sched-deps.c b/gcc/sched-deps.c
index 1befd3d..b5a3c58 100644
--- a/gcc/sched-deps.c
+++ b/gcc/sched-deps.c
@@ -1,7 +1,7 @@
 /* Instruction scheduling pass.  This file computes dependencies between
    instructions.
    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,
    and currently maintained by, Jim Wilson (wilson@cygnus.com)
 
@@ -87,6 +87,7 @@ static void sched_analyze_1 PARAMS ((struct deps *, rtx, rtx));
 static void sched_analyze_2 PARAMS ((struct deps *, rtx, rtx));
 static void sched_analyze_insn PARAMS ((struct deps *, rtx, rtx, rtx));
 static rtx group_leader PARAMS ((rtx));
+static void sched_discard_callback PARAMS ((void *, rtx));
 
 static rtx get_condition PARAMS ((rtx));
 static int conditions_mutex_p PARAMS ((rtx, rtx));
@@ -998,12 +999,10 @@ sched_analyze_insn (deps, x, insn, loop_notes)
 	     the result is needed by the above register used mask.  */
 
 	  pending = deps->pending_write_insns;
-	  pending_mem = deps->pending_write_mems;
 	  while (pending)
 	    {
 	      add_dependence (insn, XEXP (pending, 0), REG_DEP_OUTPUT);
 	      pending = XEXP (pending, 1);
-	      pending_mem = XEXP (pending_mem, 1);
 	    }
 
 	  pending = deps->pending_read_insns;
@@ -1238,6 +1237,45 @@ sched_analyze_insn (deps, x, insn, loop_notes)
     }
 }
 
+/* Called when cselib is about to discard a VALUE
+   (which can be reused from that point onwards).
+   This function replaces such VALUEs with a special
+   VALUE which can stand for any address.
+   sched_analyze needs to ensure it never calls
+   *_dependence functions with this VALUE in both
+   MEM expressions.  */
+
+static void
+sched_discard_callback (arg, value)
+     void *arg;
+     rtx value;
+{
+  struct deps *deps = (struct deps *) arg;
+  rtx pending_mem;
+
+  pending_mem = deps->pending_read_mems;
+  while (pending_mem)
+    {
+      rtx mem = XEXP (pending_mem, 0);
+
+      if (XEXP (mem, 0) == value)
+	XEXP (mem, 0) = cselib_unknown_addr ();
+
+      pending_mem = XEXP (pending_mem, 1);
+    }
+
+  pending_mem = deps->pending_write_mems;
+  while (pending_mem)
+    {
+      rtx mem = XEXP (pending_mem, 0);
+
+      if (XEXP (mem, 0) == value)
+	XEXP (mem, 0) = cselib_unknown_addr ();
+
+      pending_mem = XEXP (pending_mem, 1);
+    }
+}
+
 /* Analyze every insn between HEAD and TAIL inclusive, creating LOG_LINKS
    for every dependency.  */
 
@@ -1250,7 +1288,10 @@ sched_analyze (deps, head, tail)
   rtx loop_notes = 0;
 
   if (current_sched_info->use_cselib)
-    cselib_init ();
+    {
+      cselib_init ();
+      cselib_register_discard_callback (sched_discard_callback, deps);
+    }
 
   for (insn = head;; insn = NEXT_INSN (insn))
     {
diff --git a/gcc/system.h b/gcc/system.h
index 654c85f..d1776b4 100644
--- a/gcc/system.h
+++ b/gcc/system.h
@@ -148,6 +148,10 @@ extern int errno;
 # endif
 #endif
 
+#ifndef ICE_EXIT_CODE
+# define ICE_EXIT_CODE 27
+#endif
+
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
diff --git a/gcc/testsuite/g++.dg/template/friend24.C b/gcc/testsuite/g++.dg/template/friend24.C
new file mode 100644
index 0000000..5db4d31
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/friend24.C
@@ -0,0 +1,27 @@
+// { dg-do compile }
+
+// Origin: Wolfgang Bangerth <bangerth@ticam.utexas.edu>
+
+// PR c++/495: Fail to locate primary class template that is
+// injected by friend declaration.
+
+template <int N> struct X
+{
+  template <int dim> friend struct Y;
+};
+
+X<2> x;
+
+template <int dim> struct Y
+{
+  void f (Y);
+  void g (Y);
+};
+
+template <int dim> void Y<dim>::f (Y)
+{
+}
+
+template <int dim> void Y<dim>::g (Y<dim>)
+{
+}
diff --git a/gcc/testsuite/gcc.dg/attr-warn-unused-result.c b/gcc/testsuite/gcc.dg/attr-warn-unused-result.c
new file mode 100644
index 0000000..0404cec
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/attr-warn-unused-result.c
@@ -0,0 +1,188 @@
+/* warn_unused_result attribute tests.  */
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#define WUR __attribute__((warn_unused_result))
+#define WURAI __attribute__((warn_unused_result, always_inline)) inline
+typedef WUR int (*fnt) (void);
+
+typedef struct { long i; } A;
+typedef struct { long i; long j; } B;
+typedef struct { char big[1024]; fnt fn; } C;
+
+WUR int check1 (void);
+WUR void check2 (void); /* { dg-warning "attribute ignored" } */
+int foo WUR;	  /* { dg-warning "only applies" } */
+int bar (void);
+extern WURAI int check3 (void) { return bar (); }
+WUR A check4 (void);
+WUR B check5 (void);
+WUR C check6 (void);
+A bar7 (void);
+B bar8 (void);
+C bar9 (void);
+extern WURAI A check7 (void) { return bar7 (); }
+extern WURAI B check8 (void) { return bar8 (); }
+extern WURAI C check9 (void) { return bar9 (); }
+/* This is useful for checking whether return value of statement
+   expressions (returning int in this case) is used.  */
+extern WURAI int check_int_result (int res) { return res; }
+#define GU(v) ({ int e = 0; (v) = bar (); if ((v) < 23) e = 14; e; })
+fnt fnptr;
+WUR int check10 (void);
+int baz (void);
+extern WURAI int check11 (void) { return baz (); }
+int k;
+
+void
+test (void)
+{
+  int i = 0, j;
+  const fnt pcheck1 = check1;
+  const fnt pcheck3 = check3;
+  A a;
+  B b;
+  C c;
+  if (check1 ())
+    return;
+  i += check1 ();
+  i += ({ check1 (); });
+  check1 ();		/* { dg-warning "ignoring return value of" } */
+  (void) check1 ();	/* { dg-warning "ignoring return value of" } */
+  check1 (), bar ();	/* { dg-warning "ignoring return value of" } */
+  check2 ();
+  (void) check2 ();
+  check2 (), bar ();
+  if (check3 ())
+    return;
+  i += check3 ();
+  i += ({ check3 (); });
+  check3 ();		/* { dg-warning "ignoring return value of" } */
+  (void) check3 ();	/* { dg-warning "ignoring return value of" } */
+  check3 (), bar ();	/* { dg-warning "ignoring return value of" } */
+  a = check4 ();
+  if (a.i)
+    return;
+  if (check4 ().i)
+    return;
+  if (({ check4 (); }).i)
+    return;
+  check4 ();		/* { dg-warning "ignoring return value of" } */
+  (void) check4 ();	/* { dg-warning "ignoring return value of" } */
+  check4 (), bar ();	/* { dg-warning "ignoring return value of" } */
+  b = check5 ();
+  if (b.i + b.j)
+    return;
+  if (check5 ().j)
+    return;
+  if (({ check5 (); }).j)
+    return;
+  check5 ();		/* { dg-warning "ignoring return value of" } */
+  (void) check5 ();	/* { dg-warning "ignoring return value of" } */
+  check5 (), bar ();	/* { dg-warning "ignoring return value of" } */
+  c = check6 ();
+  if (c.big[12] + c.big[29])
+    return;
+  if (check6 ().big[27])
+    return;
+  if (({ check6 (); }).big[0])
+    return;
+  check6 ();		/* { dg-warning "ignoring return value of" } */
+  (void) check6 ();	/* { dg-warning "ignoring return value of" } */
+  check6 (), bar ();	/* { dg-warning "ignoring return value of" } */
+  a = check7 ();
+  if (a.i)
+    return;
+  if (check7 ().i)
+    return;
+  if (({ check7 (); }).i)
+    return;
+  check7 ();		/* { dg-warning "ignoring return value of" } */
+  (void) check7 ();	/* { dg-warning "ignoring return value of" } */
+  check7 (), bar ();	/* { dg-warning "ignoring return value of" } */
+  b = check8 ();
+  if (b.i + b.j)
+    return;
+  if (check8 ().j)
+    return;
+  if (({ check8 (); }).j)
+    return;
+  check8 ();		/* { dg-warning "ignoring return value of" } */
+  (void) check8 ();	/* { dg-warning "ignoring return value of" } */
+  check8 (), bar ();	/* { dg-warning "ignoring return value of" } */
+  c = check9 ();
+  if (c.big[12] + c.big[29])
+    return;
+  if (check9 ().big[27])
+    return;
+  if (({ check9 (); }).big[0])
+    return;
+  check9 ();		/* { dg-warning "ignoring return value of" } */
+  (void) check9 ();	/* { dg-warning "ignoring return value of" } */
+  check9 (), bar ();	/* { dg-warning "ignoring return value of" } */
+  if (check_int_result (GU (j)))
+    return;
+  i += check_int_result (GU (j));
+  i += ({ check_int_result (GU (j)); });
+  check_int_result (GU (j)); /* { dg-warning "ignoring return value of" } */
+  (void) check_int_result (GU (j)); /* { dg-warning "ignoring return value of" } */
+  check_int_result (GU (j)), bar (); /* { dg-warning "ignoring return value of" } */
+  if (fnptr ())
+    return;
+  i += fnptr ();
+  i += ({ fnptr (); });
+  fnptr ();		/* { dg-warning "ignoring return value of" } */
+  (void) fnptr ();	/* { dg-warning "ignoring return value of" } */
+  fnptr (), bar ();	/* { dg-warning "ignoring return value of" } */
+  fnptr = check1;
+  if (fnptr ())
+    return;
+  i += fnptr ();
+  i += ({ fnptr (); });
+  fnptr ();		/* { dg-warning "ignoring return value of" } */
+  (void) fnptr ();	/* { dg-warning "ignoring return value of" } */
+  fnptr (), bar ();	/* { dg-warning "ignoring return value of" } */
+  fnptr = check3;
+  if (fnptr ())
+    return;
+  i += fnptr ();
+  i += ({ fnptr (); });
+  fnptr ();		/* { dg-warning "ignoring return value of" } */
+  (void) fnptr ();	/* { dg-warning "ignoring return value of" } */
+  fnptr (), bar ();	/* { dg-warning "ignoring return value of" } */
+  if (bar9 ().fn ())
+    return;
+  i += bar9 ().fn ();
+  i += ({ bar9 ().fn (); });
+  bar9 ().fn ();	/* { dg-warning "ignoring return value of" } */
+  (void) bar9 ().fn ();	/* { dg-warning "ignoring return value of" } */
+  bar9 ().fn (), bar (); /* { dg-warning "ignoring return value of" } */
+  if ((k ? check1 : check10) ())
+    return;
+  i += (k ? check1 : check10) ();
+  i += ({ (k ? check1 : check10) (); });
+  (k ? check1 : check10) (); /* { dg-warning "ignoring return value of" } */
+  (void) (k ? check1 : check10) (); /* { dg-warning "ignoring return value of" } */
+  (k ? check1 : check10) (), bar (); /* { dg-warning "ignoring return value of" } */
+  if ((k ? check3 : check11) ())
+    return;
+  i += (k ? check3 : check11) ();
+  i += ({ (k ? check3 : check11) (); });
+  (k ? check3 : check11) (); /* { dg-warning "ignoring return value of" } */
+  (void) (k ? check3 : check11) (); /* { dg-warning "ignoring return value of" } */
+  (k ? check3 : check11) (), bar (); /* { dg-warning "ignoring return value of" } */
+  if (pcheck1 ())
+    return;
+  i += pcheck1 ();
+  i += ({ pcheck1 (); });
+  pcheck1 ();		/* { dg-warning "ignoring return value of" } */
+  (void) pcheck1 ();	/* { dg-warning "ignoring return value of" } */
+  pcheck1 (), bar ();	/* { dg-warning "ignoring return value of" } */
+  if (pcheck3 ())
+    return;
+  i += pcheck3 ();
+  i += ({ pcheck3 (); });
+  pcheck3 ();		/* { dg-warning "ignoring return value of" } */
+  (void) pcheck3 ();	/* { dg-warning "ignoring return value of" } */
+  pcheck3 (), bar ();	/* { dg-warning "ignoring return value of" } */
+}
diff --git a/gcc/tree-inline.c b/gcc/tree-inline.c
index a4da29a..e920b84 100644
--- a/gcc/tree-inline.c
+++ b/gcc/tree-inline.c
@@ -1201,6 +1201,9 @@ expand_call_inline (tp, walk_subtrees, data)
   expr = build1 (STMT_EXPR, TREE_TYPE (TREE_TYPE (fn)), make_node (COMPOUND_STMT));
   /* There is no scope associated with the statement-expression.  */
   STMT_EXPR_NO_SCOPE (expr) = 1;
+  if (lookup_attribute ("warn_unused_result",
+			TYPE_ATTRIBUTES (TREE_TYPE (fn))))
+    STMT_EXPR_WARN_UNUSED_RESULT (expr) = 1;
   stmt = STMT_EXPR_STMT (expr);
 #else /* INLINER_FOR_JAVA */
   /* Build a block containing code to initialize the arguments, the
diff --git a/gcc/treelang/Make-lang.in b/gcc/treelang/Make-lang.in
index 3cb3743..f11d19b 100644
--- a/gcc/treelang/Make-lang.in
+++ b/gcc/treelang/Make-lang.in
@@ -56,7 +56,7 @@ GCC_EXTRAS = -B./ -B$(build_tooldir)/bin/ -isystem $(build_tooldir)/include
 
 # GCC_FOR_TREELANG = ./xgcc $(GCC_EXTRAS)
 
-TREE_GENERATED = $(srcdir)/treelang/lex.c $(srcdir)/treelang/parse.c\
+TREE_GENERATED = $(srcdir)/treelang/lex.c $(srcdir)/treelang/parse.c \
 	$(srcdir)/treelang/parse.h $(srcdir)/treelang/parse.output $(srcdir)/treelang/TAGS
 
 TREE_SOURCE = ${srcdir}/treelang/parse.y ${srcdir}/treelang/lex.l ${srcdir}/treelang/tree1.c ${srcdir}/treelang/treelang.h ${srcdir}/treelang/treetree.c $(srcdir)/treelang/treetree.h
@@ -79,10 +79,10 @@ treelang.done: tree1$(exeext)
 # no preprocessor
 
 # core compiler 
-tree1$(exeext): treelang/tree1.o treelang/treetree.o treelang/lex.o treelang/parse.o\
+tree1$(exeext): treelang/tree1.o treelang/treetree.o treelang/lex.o treelang/parse.o \
 	$(TREE_BE_LIBS) c-convert.o c-typeck.o c-common.o c-decl.o attribs.o
 	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \
-	treelang/tree1.o treelang/treetree.o treelang/lex.o treelang/parse.o c-convert.o\
+	treelang/tree1.o treelang/treetree.o treelang/lex.o treelang/parse.o c-convert.o \
 	c-typeck.o c-common.o c-decl.o attribs.o $(TREE_BE_LIBS)
 
 #
@@ -115,7 +115,7 @@ $(srcdir)/treelang/lex.c: $(srcdir)/treelang/lex.l
 	$(LEX) $(LEXFLAGS) -o$(srcdir)/treelang/lex.c $(srcdir)/treelang/lex.l
 
 $(srcdir)/treelang/parse.c $(srcdir)/treelang/parse.h: $(srcdir)/treelang/parse.y
-	$(BISON) $(BISONFLAGS) -v $(srcdir)/treelang/parse.y\
+	$(BISON) $(BISONFLAGS) -v $(srcdir)/treelang/parse.y \
 	--output=$(srcdir)/treelang/parse.c --defines
 # -v
 
diff --git a/gcc/treelang/parse.y b/gcc/treelang/parse.y
index 7d7400f..0f4d949 100644
--- a/gcc/treelang/parse.y
+++ b/gcc/treelang/parse.y
@@ -51,6 +51,7 @@ typedef void *rtx;
 
 #include <stdio.h>
 #include <stdlib.h>
+#define __USE_GNU
 #include <string.h>
 
 #include "ansidecl.h"
diff --git a/gcc/unwind-compat.c b/gcc/unwind-compat.c
new file mode 100644
index 0000000..26f45ac
--- /dev/null
+++ b/gcc/unwind-compat.c
@@ -0,0 +1,206 @@
+/* Backward compatibility unwind routines.
+   Copyright (C) 2004
+   Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   In addition to the permissions in the GNU General Public License, the
+   Free Software Foundation gives you unlimited permission to link the
+   compiled version of this file into combinations with other programs,
+   and to distribute those combinations without any restriction coming
+   from the use of this file.  (The General Public License restrictions
+   do apply in other respects; for example, they cover modification of
+   the file, and distribution when not linked into a combined
+   executable.)
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#if defined (USE_GAS_SYMVER) && defined (USE_LIBUNWIND_EXCEPTIONS)
+#include "unwind.h"
+#include "unwind-dw2-fde.h"
+#include "unwind-compat.h"
+
+extern _Unwind_Reason_Code __libunwind_Unwind_Backtrace
+  (_Unwind_Trace_Fn, void *);
+
+_Unwind_Reason_Code
+_Unwind_Backtrace (_Unwind_Trace_Fn trace, void *trace_argument)
+{
+  return __libunwind_Unwind_Backtrace (trace, trace_argument);
+}
+symver (_Unwind_Backtrace, GCC_3.3);
+
+extern void __libunwind_Unwind_DeleteException
+  (struct _Unwind_Exception *);
+
+void
+_Unwind_DeleteException (struct _Unwind_Exception *exc)
+{
+  return __libunwind_Unwind_DeleteException (exc);
+}
+symver (_Unwind_DeleteException, GCC_3.0);
+
+extern void * __libunwind_Unwind_FindEnclosingFunction (void *);
+
+void *
+_Unwind_FindEnclosingFunction (void *pc)
+{
+  return __libunwind_Unwind_FindEnclosingFunction (pc);
+}
+symver (_Unwind_FindEnclosingFunction, GCC_3.3);
+
+extern _Unwind_Reason_Code __libunwind_Unwind_ForcedUnwind
+  (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);
+
+_Unwind_Reason_Code
+_Unwind_ForcedUnwind (struct _Unwind_Exception *exc,
+		      _Unwind_Stop_Fn stop, void * stop_argument)
+{
+  return __libunwind_Unwind_ForcedUnwind (exc, stop, stop_argument);
+}
+symver (_Unwind_ForcedUnwind, GCC_3.0);
+
+extern _Unwind_Word __libunwind_Unwind_GetCFA
+  (struct _Unwind_Context *);
+
+_Unwind_Word
+_Unwind_GetCFA (struct _Unwind_Context *context)
+{
+  return __libunwind_Unwind_GetCFA (context);
+}
+symver (_Unwind_GetCFA, GCC_3.3);
+
+#ifdef __ia64__
+extern _Unwind_Word __libunwind_Unwind_GetBSP
+  (struct _Unwind_Context *);
+
+_Unwind_Word
+_Unwind_GetBSP (struct _Unwind_Context * context)
+{
+  return __libunwind_Unwind_GetBSP (context);
+}
+symver (_Unwind_GetBSP, GCC_3.3.2);
+#else
+extern _Unwind_Ptr __libunwind_Unwind_GetDataRelBase
+  (struct _Unwind_Context *);
+
+_Unwind_Ptr
+_Unwind_GetDataRelBase (struct _Unwind_Context *context)
+{
+  return __libunwind_Unwind_GetDataRelBase (context);
+}
+symver (_Unwind_GetDataRelBase, GCC_3.0);
+
+extern _Unwind_Ptr __libunwind_Unwind_GetTextRelBase
+  (struct _Unwind_Context *);
+
+_Unwind_Ptr
+_Unwind_GetTextRelBase (struct _Unwind_Context *context)
+{
+  return __libunwind_Unwind_GetTextRelBase (context);
+}
+symver (_Unwind_GetTextRelBase, GCC_3.0);
+#endif
+
+extern _Unwind_Word __libunwind_Unwind_GetGR
+  (struct _Unwind_Context *, int );
+
+_Unwind_Word
+_Unwind_GetGR (struct _Unwind_Context *context, int index)
+{
+  return __libunwind_Unwind_GetGR (context, index);
+}
+symver (_Unwind_GetGR, GCC_3.0);
+
+extern _Unwind_Ptr __libunwind_Unwind_GetIP (struct _Unwind_Context *);
+
+_Unwind_Ptr
+_Unwind_GetIP (struct _Unwind_Context *context)
+{
+  return __libunwind_Unwind_GetIP (context);
+}
+symver (_Unwind_GetIP, GCC_3.0);
+
+extern void *__libunwind_Unwind_GetLanguageSpecificData
+  (struct _Unwind_Context *);
+
+void *
+_Unwind_GetLanguageSpecificData (struct _Unwind_Context *context)
+{
+  return __libunwind_Unwind_GetLanguageSpecificData (context);
+}
+symver (_Unwind_GetLanguageSpecificData, GCC_3.0);
+
+extern _Unwind_Ptr __libunwind_Unwind_GetRegionStart
+  (struct _Unwind_Context *);
+
+_Unwind_Ptr
+_Unwind_GetRegionStart (struct _Unwind_Context *context)
+{
+  return __libunwind_Unwind_GetRegionStart (context);
+}
+symver (_Unwind_GetRegionStart, GCC_3.0);
+
+extern _Unwind_Reason_Code __libunwind_Unwind_RaiseException
+  (struct _Unwind_Exception *);
+
+_Unwind_Reason_Code
+_Unwind_RaiseException(struct _Unwind_Exception *exc)
+{
+  return __libunwind_Unwind_RaiseException (exc);
+}
+symver (_Unwind_RaiseException, GCC_3.0);
+
+extern void __libunwind_Unwind_Resume (struct _Unwind_Exception *);
+
+void
+_Unwind_Resume (struct _Unwind_Exception *exc)
+{
+  __libunwind_Unwind_Resume (exc);
+}
+symver (_Unwind_Resume, GCC_3.0);
+
+extern _Unwind_Reason_Code __libunwind_Unwind_Resume_or_Rethrow
+   (struct _Unwind_Exception *);
+
+_Unwind_Reason_Code
+_Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exc)
+{
+  return __libunwind_Unwind_Resume_or_Rethrow (exc);
+}
+symver (_Unwind_Resume_or_Rethrow, GCC_3.3);
+
+extern void __libunwind_Unwind_SetGR
+  (struct _Unwind_Context *, int, _Unwind_Word);
+
+void
+_Unwind_SetGR (struct _Unwind_Context *context, int index,
+	       _Unwind_Word val) 
+{
+  __libunwind_Unwind_SetGR (context, index, val);
+}
+symver (_Unwind_SetGR, GCC_3.0);
+
+extern void __libunwind_Unwind_SetIP
+  (struct _Unwind_Context *, _Unwind_Ptr);
+
+void
+_Unwind_SetIP (struct _Unwind_Context *context, _Unwind_Ptr val)
+{
+  return __libunwind_Unwind_SetIP (context, val);
+}
+symver (_Unwind_SetIP, GCC_3.0);
+#endif
diff --git a/gcc/unwind-compat.h b/gcc/unwind-compat.h
new file mode 100644
index 0000000..051cea1
--- /dev/null
+++ b/gcc/unwind-compat.h
@@ -0,0 +1,35 @@
+/* Backward compatibility unwind routines.
+   Copyright (C) 2004
+   Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   In addition to the permissions in the GNU General Public License, the
+   Free Software Foundation gives you unlimited permission to link the
+   compiled version of this file into combinations with other programs,
+   and to distribute those combinations without any restriction coming
+   from the use of this file.  (The General Public License restrictions
+   do apply in other respects; for example, they cover modification of
+   the file, and distribution when not linked into a combined
+   executable.)
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#define symver(name, version) \
+  __asm__ (".symver " #name"," #name "@" #version)
+
+#define alias(name) \
+  __typeof(name) __libunwind##name __attribute__ ((alias (#name)))
diff --git a/gcc/unwind-dw2-fde-compat.c b/gcc/unwind-dw2-fde-compat.c
new file mode 100644
index 0000000..5e8c0a3
--- /dev/null
+++ b/gcc/unwind-dw2-fde-compat.c
@@ -0,0 +1,46 @@
+/* Backward compatibility unwind routines.
+   Copyright (C) 2004
+   Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   In addition to the permissions in the GNU General Public License, the
+   Free Software Foundation gives you unlimited permission to link the
+   compiled version of this file into combinations with other programs,
+   and to distribute those combinations without any restriction coming
+   from the use of this file.  (The General Public License restrictions
+   do apply in other respects; for example, they cover modification of
+   the file, and distribution when not linked into a combined
+   executable.)
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#if defined (USE_GAS_SYMVER) && defined (USE_LIBUNWIND_EXCEPTIONS)
+#include "unwind.h"
+#include "unwind-dw2-fde.h"
+#include "unwind-compat.h"
+
+extern const fde * __libunwind__Unwind_Find_FDE
+  (void *, struct dwarf_eh_bases *);
+
+const fde *
+_Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)
+{
+  __libunwind__Unwind_Find_FDE (pc, bases);
+}
+
+symver (_Unwind_Find_FDE, GCC_3.0);
+#endif
diff --git a/gcc/unwind-dw2-fde-glibc.c b/gcc/unwind-dw2-fde-glibc.c
index 21b3321..0f9e957 100644
--- a/gcc/unwind-dw2-fde-glibc.c
+++ b/gcc/unwind-dw2-fde-glibc.c
@@ -46,6 +46,7 @@
 #define NO_BASE_OF_ENCODED_VALUE
 #include "unwind-pe.h"
 #include "unwind-dw2-fde.h"
+#include "unwind-compat.h"
 #include "gthr.h"
 
 #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
@@ -297,3 +298,7 @@ _Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)
 #define _Unwind_Find_FDE _Unwind_Find_FDE
 #include "unwind-dw2-fde.c"
 #endif
+
+#if defined (USE_GAS_SYMVER) && defined (SHARED) && defined (USE_LIBUNWIND_EXCEPTIONS)
+alias (_Unwind_Find_FDE);
+#endif
diff --git a/gcc/unwind-dw2.c b/gcc/unwind-dw2.c
index 58cc3cc..dd85212 100644
--- a/gcc/unwind-dw2.c
+++ b/gcc/unwind-dw2.c
@@ -1280,4 +1280,23 @@ uw_identify_context (struct _Unwind_Context *context)
 
 #include "unwind.inc"
 
+#if defined (USE_GAS_SYMVER) && defined (SHARED) && defined (USE_LIBUNWIND_EXCEPTIONS)
+alias (_Unwind_Backtrace);
+alias (_Unwind_DeleteException);
+alias (_Unwind_FindEnclosingFunction);
+alias (_Unwind_ForcedUnwind);
+alias (_Unwind_GetDataRelBase);
+alias (_Unwind_GetTextRelBase);
+alias (_Unwind_GetCFA);
+alias (_Unwind_GetGR);
+alias (_Unwind_GetIP);
+alias (_Unwind_GetLanguageSpecificData);
+alias (_Unwind_GetRegionStart);
+alias (_Unwind_RaiseException);
+alias (_Unwind_Resume);
+alias (_Unwind_Resume_or_Rethrow);
+alias (_Unwind_SetGR);
+alias (_Unwind_SetIP);
+#endif
+
 #endif /* !USING_SJLJ_EXCEPTIONS */
diff --git a/libf2c/aclocal.m4 b/libf2c/aclocal.m4
index 5d39edc..9c513b6 100644
--- a/libf2c/aclocal.m4
+++ b/libf2c/aclocal.m4
@@ -212,7 +212,11 @@ if test x"$glibcpp_toolexecdir" = x"no"; then
     glibcpp_toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
     glibcpp_toolexeclibdir='$(libdir)'
   fi
-  glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/`$CC -print-multi-os-directory`
+  multi_os_directory=`$CC -print-multi-os-directory`
+  case $multi_os_directory in
+    .) ;; # Avoid trailing /.
+    *) glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/$multi_os_directory ;;
+  esac
 fi
 
 AC_SUBST(glibcpp_prefixdir)
diff --git a/libf2c/libI77/fio.h b/libf2c/libI77/fio.h
index 7734f0c..4515bbe 100644
--- a/libf2c/libI77/fio.h
+++ b/libf2c/libI77/fio.h
@@ -86,7 +86,7 @@ extern unit f__units[];
 #define errfl(f,m,s) do {return err__fl((int)f,m,s);} while(0)
 
 /*Table sizes*/
-#define MXUNIT 100
+#define MXUNIT 512
 
 extern int f__recpos;		/*position in current record */
 extern int f__cursor;		/* offset to move to */
diff --git a/libffi/configure b/libffi/configure
index 5434a22..2bd5165 100755
--- a/libffi/configure
+++ b/libffi/configure
@@ -1275,14 +1275,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/libiberty/Makefile.in b/libiberty/Makefile.in
index d936928..fdc8a00 100644
--- a/libiberty/Makefile.in
+++ b/libiberty/Makefile.in
@@ -217,6 +217,7 @@ $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS)
 	  $(AR) $(AR_FLAGS) $(TARGETLIB) \
 	    $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS); \
 	  $(RANLIB) $(TARGETLIB); \
+	  cp $(TARGETLIB) ../ ; \
 	  cd ..; \
 	else true; fi
 
diff --git a/libjava/acinclude.m4 b/libjava/acinclude.m4
index ab3b2f1..bac2da5 100644
--- a/libjava/acinclude.m4
+++ b/libjava/acinclude.m4
@@ -279,8 +279,8 @@ AC_DEFUN([CHECK_FOR_BROKEN_MINGW_LD],
 AC_MSG_CHECKING(whether 'ld' is at least 2.13)
 LD_PROG=`$CC --print-prog-name=ld`
 LD_VERSION=`$LD_PROG --version`
-LD_VERSION_MAJOR=`echo "$LD_VERSION" | head -1 | cut -d '.' -f 1 | cut -d ' ' -f 4`
-LD_VERSION_MINOR=`echo "$LD_VERSION" | head -1 | cut -d '.' -f 2`
+LD_VERSION_MAJOR=`echo "$LD_VERSION" | head -n 1 | cut -d '.' -f 1 | cut -d ' ' -f 4`
+LD_VERSION_MINOR=`echo "$LD_VERSION" | head -n 1 | cut -d '.' -f 2`
 if expr "$LD_VERSION_MAJOR" \> 2 > /dev/null; then
   LD_OK="ok"
 else
diff --git a/libjava/aclocal.m4 b/libjava/aclocal.m4
index 5748eba..91291ae 100644
--- a/libjava/aclocal.m4
+++ b/libjava/aclocal.m4
@@ -291,8 +291,8 @@ AC_DEFUN([CHECK_FOR_BROKEN_MINGW_LD],
 AC_MSG_CHECKING(whether 'ld' is at least 2.13)
 LD_PROG=`$CC --print-prog-name=ld`
 LD_VERSION=`$LD_PROG --version`
-LD_VERSION_MAJOR=`echo "$LD_VERSION" | head -1 | cut -d '.' -f 1 | cut -d ' ' -f 4`
-LD_VERSION_MINOR=`echo "$LD_VERSION" | head -1 | cut -d '.' -f 2`
+LD_VERSION_MAJOR=`echo "$LD_VERSION" | head -n 1 | cut -d '.' -f 1 | cut -d ' ' -f 4`
+LD_VERSION_MINOR=`echo "$LD_VERSION" | head -n 1 | cut -d '.' -f 2`
 if expr "$LD_VERSION_MAJOR" \> 2 > /dev/null; then
   LD_OK="ok"
 else
diff --git a/libjava/configure b/libjava/configure
index 810bb4a..9169372 100755
--- a/libjava/configure
+++ b/libjava/configure
@@ -2035,14 +2035,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
@@ -2965,8 +2958,8 @@ echo $ac_n "checking whether 'ld' is at least 2.13""... $ac_c" 1>&6
 echo "configure:2966: checking whether 'ld' is at least 2.13" >&5
 LD_PROG=`$CC --print-prog-name=ld`
 LD_VERSION=`$LD_PROG --version`
-LD_VERSION_MAJOR=`echo "$LD_VERSION" | head -1 | cut -d '.' -f 1 | cut -d ' ' -f 4`
-LD_VERSION_MINOR=`echo "$LD_VERSION" | head -1 | cut -d '.' -f 2`
+LD_VERSION_MAJOR=`echo "$LD_VERSION" | head -n 1 | cut -d '.' -f 1 | cut -d ' ' -f 4`
+LD_VERSION_MINOR=`echo "$LD_VERSION" | head -n 1 | cut -d '.' -f 2`
 if expr "$LD_VERSION_MAJOR" \> 2 > /dev/null; then
   LD_OK="ok"
 else
@@ -5775,7 +5768,11 @@ else
   toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
   toolexecmainlibdir='$(libdir)'
 fi
-toolexeclibdir=$toolexecmainlibdir/`$CC -print-multi-os-directory`
+multi_os_directory=`$CC -print-multi-os-directory`
+case $multi_os_directory in
+  .) toolexeclibdir=$toolexecmainlibdir ;; # Avoid trailing /.
+  *) toolexeclibdir=$toolexecmainlibdir/$multi_os_directory ;;
+esac
 
 
 
diff --git a/libjava/configure.in b/libjava/configure.in
index 6f482b2..502aeab 100644
--- a/libjava/configure.in
+++ b/libjava/configure.in
@@ -805,7 +805,11 @@ else
   toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
   toolexecmainlibdir='$(libdir)'
 fi
-toolexeclibdir=$toolexecmainlibdir/`$CC -print-multi-os-directory`
+multi_os_directory=`$CC -print-multi-os-directory`
+case $multi_os_directory in
+  .) toolexeclibdir=$toolexecmainlibdir ;; # Avoid trailing /.
+  *) toolexeclibdir=$toolexecmainlibdir/$multi_os_directory ;;
+esac
 AC_SUBST(toolexecdir)
 AC_SUBST(toolexecmainlibdir)
 AC_SUBST(toolexeclibdir)
diff --git a/libjava/include/x86_64-signal.h b/libjava/include/x86_64-signal.h
index fed55d1..28e473e 100644
--- a/libjava/include/x86_64-signal.h
+++ b/libjava/include/x86_64-signal.h
@@ -40,7 +40,7 @@ do									\
   /* Advance the program counter so that it is after the start of the	\
      instruction:  the x86_64 exception handler expects			\
      the PC to point to the instruction after a call. */		\
-  struct ucontext *_uc = (struct ucontext *)_p;				\
+  ucontext_t *_uc = (ucontext_t *)_p;				\
   volatile struct sigcontext *_sc = (struct sigcontext *) &_uc->uc_mcontext; \
   _sc->rip += 2;							\
 }									\
diff --git a/libobjc/aclocal.m4 b/libobjc/aclocal.m4
index ed643f6..83707ce 100644
--- a/libobjc/aclocal.m4
+++ b/libobjc/aclocal.m4
@@ -212,7 +212,11 @@ if test x"$glibcpp_toolexecdir" = x"no"; then
     glibcpp_toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
     glibcpp_toolexeclibdir='$(libdir)'
   fi
-  glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/`$CC -print-multi-os-directory`
+  multi_os_directory=`$CC -print-multi-os-directory`
+  case $multi_os_directory in
+  .) ;; # Avoid trailing /.
+  *) glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/$multi_os_directory ;;
+  esac
 fi
 
 AC_SUBST(glibcpp_prefixdir)
diff --git a/libobjc/configure b/libobjc/configure
index d7afae5..51a27d0 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -1270,7 +1270,11 @@ if test x"$glibcpp_toolexecdir" = x"no"; then
     glibcpp_toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
     glibcpp_toolexeclibdir='$(libdir)'
   fi
-  glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/`$CC -print-multi-os-directory`
+  multi_os_directory=`$CC -print-multi-os-directory`
+  case $multi_os_directory in
+  .) ;; # Avoid trailing /.
+  *) glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/$multi_os_directory ;;
+  esac
 fi
 
 
@@ -1641,14 +1645,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index b6a1156..f04584a 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -317,7 +317,7 @@ AC_DEFUN(GLIBCPP_CHECK_LINKER_FEATURES, [
   # Start by getting the version number.  I think the libtool test already
   # does some of this, but throws away the result.
   changequote(,)
-  ldver=`$LD --version 2>/dev/null | head -1 | \
+  ldver=`$LD --version 2>/dev/null | head -n 1 | \
          sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
   changequote([,])
   glibcpp_gnu_ld_version=`echo $ldver | \
@@ -1970,7 +1970,11 @@ if test x"$glibcpp_toolexecdir" = x"no"; then
     glibcpp_toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
     glibcpp_toolexeclibdir='$(libdir)'
   fi
-  glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/`$CC -print-multi-os-directory`
+  multi_os_directory=`$CC -print-multi-os-directory`
+  case $multi_os_directory in
+  .) ;; # Avoid trailing /.
+  *) glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/$multi_os_directory ;;
+  esac
 fi
 
 AC_MSG_CHECKING([for install location])
@@ -2294,6 +2298,23 @@ if test $enable_symvers != no; then
   CFLAGS=' -lgcc_s'
   AC_TRY_LINK(, [return 0], glibcpp_shared_libgcc=yes, glibcpp_shared_libgcc=no)
   CFLAGS="$ac_save_CFLAGS"
+  if test $glibcpp_shared_libgcc = no; then
+    cat > conftest.c <<EOF
+int main (void) { return 0; }
+EOF
+changequote(,)dnl
+    glibcpp_libgcc_s_suffix=`${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS \
+			     -shared -shared-libgcc -o conftest.so \
+			     conftest.c -v 2>&1 >/dev/null \
+			     | sed -n 's/^.* -lgcc_s\([^ ]*\) .*$/\1/p'`
+changequote([,])dnl
+    rm -f conftest.c conftest.so
+    if test x${glibcpp_libgcc_s_suffix+set} = xset; then
+      CFLAGS=" -lgcc_s$glibcpp_libgcc_s_suffix"
+      AC_TRY_LINK(, [return 0;], glibcpp_shared_libgcc=yes)
+      CFLAGS="$ac_save_CFLAGS"
+    fi
+  fi
   AC_MSG_RESULT($glibcpp_shared_libgcc)
 fi
 
diff --git a/libstdc++-v3/aclocal.m4 b/libstdc++-v3/aclocal.m4
index 74f3de0..0d87218 100644
--- a/libstdc++-v3/aclocal.m4
+++ b/libstdc++-v3/aclocal.m4
@@ -329,7 +329,7 @@ AC_DEFUN(GLIBCPP_CHECK_LINKER_FEATURES, [
   # Start by getting the version number.  I think the libtool test already
   # does some of this, but throws away the result.
   changequote(,)
-  ldver=`$LD --version 2>/dev/null | head -1 | \
+  ldver=`$LD --version 2>/dev/null | head -n 1 | \
          sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
   changequote([,])
   glibcpp_gnu_ld_version=`echo $ldver | \
@@ -1982,7 +1982,11 @@ if test x"$glibcpp_toolexecdir" = x"no"; then
     glibcpp_toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
     glibcpp_toolexeclibdir='$(libdir)'
   fi
-  glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/`$CC -print-multi-os-directory`
+  multi_os_directory=`$CC -print-multi-os-directory`
+  case $multi_os_directory in
+  .) ;; # Avoid trailing /.
+  *) glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/$multi_os_directory ;;
+  esac
 fi
 
 AC_MSG_CHECKING([for install location])
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 9ff891d..ff926a5 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -2008,14 +2008,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
@@ -4292,7 +4285,7 @@ done
   # Start by getting the version number.  I think the libtool test already
   # does some of this, but throws away the result.
   
-  ldver=`$LD --version 2>/dev/null | head -1 | \
+  ldver=`$LD --version 2>/dev/null | head -n 1 | \
          sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
   
   glibcpp_gnu_ld_version=`echo $ldver | \
@@ -5431,7 +5424,7 @@ done
   # Start by getting the version number.  I think the libtool test already
   # does some of this, but throws away the result.
   
-  ldver=`$LD --version 2>/dev/null | head -1 | \
+  ldver=`$LD --version 2>/dev/null | head -n 1 | \
          sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
   
   glibcpp_gnu_ld_version=`echo $ldver | \
@@ -6411,7 +6404,7 @@ done
   # Start by getting the version number.  I think the libtool test already
   # does some of this, but throws away the result.
   
-  ldver=`$LD --version 2>/dev/null | head -1 | \
+  ldver=`$LD --version 2>/dev/null | head -n 1 | \
          sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
   
   glibcpp_gnu_ld_version=`echo $ldver | \
@@ -7401,7 +7394,7 @@ done
   # Start by getting the version number.  I think the libtool test already
   # does some of this, but throws away the result.
   
-  ldver=`$LD --version 2>/dev/null | head -1 | \
+  ldver=`$LD --version 2>/dev/null | head -n 1 | \
          sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
   
   glibcpp_gnu_ld_version=`echo $ldver | \
@@ -8405,7 +8398,7 @@ done
   # Start by getting the version number.  I think the libtool test already
   # does some of this, but throws away the result.
   
-  ldver=`$LD --version 2>/dev/null | head -1 | \
+  ldver=`$LD --version 2>/dev/null | head -n 1 | \
          sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
   
   glibcpp_gnu_ld_version=`echo $ldver | \
@@ -9300,7 +9293,7 @@ fi
   # Start by getting the version number.  I think the libtool test already
   # does some of this, but throws away the result.
   
-  ldver=`$LD --version 2>/dev/null | head -1 | \
+  ldver=`$LD --version 2>/dev/null | head -n 1 | \
          sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
   
   glibcpp_gnu_ld_version=`echo $ldver | \
@@ -10788,7 +10781,7 @@ cross_compiling=$ac_cv_prog_cc_cross
   # Start by getting the version number.  I think the libtool test already
   # does some of this, but throws away the result.
   
-  ldver=`$LD --version 2>/dev/null | head -1 | \
+  ldver=`$LD --version 2>/dev/null | head -n 1 | \
          sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
   
   glibcpp_gnu_ld_version=`echo $ldver | \
@@ -23563,6 +23556,36 @@ else
 fi
 rm -f conftest*
   CFLAGS="$ac_save_CFLAGS"
+  if test $glibcpp_shared_libgcc = no; then
+    cat > conftest.c <<EOF
+int main (void) { return 0; }
+EOF
+    glibcpp_libgcc_s_suffix=`${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS \
+			     -shared -shared-libgcc -o conftest.so \
+			     conftest.c -v 2>&1 >/dev/null \
+			     | sed -n 's/^.* -lgcc_s\([^ ]*\) .*$/\1/p'`
+    rm -f conftest.c conftest.so
+    if test x${glibcpp_libgcc_s_suffix+set} = xset; then
+      CFLAGS=" -lgcc_s$glibcpp_libgcc_s_suffix"
+      cat > conftest.$ac_ext <<EOF
+#line 23545 "configure"
+#include "confdefs.h"
+
+int main() {
+return 0;
+; return 0; }
+EOF
+if { (eval echo configure:23552: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+  rm -rf conftest*
+  glibcpp_shared_libgcc=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+fi
+rm -f conftest*
+      CFLAGS="$ac_save_CFLAGS"
+    fi
+  fi
   echo "$ac_t""$glibcpp_shared_libgcc" 1>&6
 fi
 
@@ -24134,7 +24157,11 @@ if test x"$glibcpp_toolexecdir" = x"no"; then
     glibcpp_toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
     glibcpp_toolexeclibdir='$(libdir)'
   fi
-  glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/`$CC -print-multi-os-directory`
+  multi_os_directory=`$CC -print-multi-os-directory`
+  case $multi_os_directory in
+  .) ;; # Avoid trailing /.
+  *) glibcpp_toolexeclibdir=$glibcpp_toolexeclibdir/$multi_os_directory ;;
+  esac
 fi
 
 echo $ac_n "checking for install location""... $ac_c" 1>&6
diff --git a/libstdc++-v3/docs/doxygen/filter b/libstdc++-v3/docs/doxygen/filter
index 4ea2d41..9ef4e6c 100755
--- a/libstdc++-v3/docs/doxygen/filter
+++ b/libstdc++-v3/docs/doxygen/filter
@@ -1,5 +1,7 @@
 #!/bin/sh
 
+export LC_ALL=C
+
 script=$1
 file=$2
 
diff --git a/libstdc++-v3/mkcheck.in b/libstdc++-v3/mkcheck.in
index c856b05..6d02187 100755
--- a/libstdc++-v3/mkcheck.in
+++ b/libstdc++-v3/mkcheck.in
@@ -181,9 +181,9 @@ setup_size_command()
     function size_command()
     {
       case $1 in
-        TEXT)  TEXT=$(size -B $EXENAME | tail -1 | awk '{print $1}')  ;;
-        DATA)  DATA=$(size -B $EXENAME | tail -1 | awk '{print $2}')  ;;
-        SIZE)  SIZE=$(size -B $EXENAME | tail -1 | awk '{print $4}')  ;;
+        TEXT)  TEXT=$(size -B $EXENAME | tail -n 1 | awk '{print $1}')  ;;
+        DATA)  DATA=$(size -B $EXENAME | tail -n 1 | awk '{print $2}')  ;;
+        SIZE)  SIZE=$(size -B $EXENAME | tail -n 1 | awk '{print $4}')  ;;
       esac
     }
   else
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index 199bb65..329ea5c 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -225,6 +225,13 @@ CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \
 	  @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@
 
 
+install-exec-local:
+	pic_objs=`sed -n "s:'::g;s:^pic_object=::p" *.lo | grep -v '^none$$'`; \
+	if [ x"$$pic_objs" != x ]; then \
+		$(AR) cru libstdc++_pic.a $$pic_objs $(top_builddir)/libsupc++/*.o || exit 1; \
+		$(INSTALL_DATA) libstdc++_pic.a $(DESTDIR)$(toolexeclibdir) || exit 1; \
+	fi
+
 # Added bits to build debug library.
 if GLIBCPP_BUILD_DEBUG
 all-local: build_debug
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index 50aa125..4340810 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -473,7 +473,7 @@ installcheck-am:
 installcheck: installcheck-am
 install-info-am: 
 install-info: install-info-am
-install-exec-am: install-toolexeclibLTLIBRARIES
+install-exec-am: install-toolexeclibLTLIBRARIES install-exec-local
 install-exec: install-exec-am
 
 install-data-am: install-data-local
@@ -537,7 +537,7 @@ maintainer-clean-compile mostlyclean-libtool distclean-libtool \
 clean-libtool maintainer-clean-libtool tags mostlyclean-tags \
 distclean-tags clean-tags maintainer-clean-tags distdir info-am info \
 dvi-am dvi check check-am installcheck-am installcheck install-info-am \
-install-info install-exec-am install-exec install-data-local \
+install-info install-exec-local install-exec-am install-exec install-data-local \
 install-data-am install-data install-am install uninstall-am uninstall \
 all-local all-redirect all-am all installdirs mostlyclean-generic \
 distclean-generic clean-generic maintainer-clean-generic clean \
@@ -585,6 +585,13 @@ concept-inst.lo: concept-inst.cc
 concept-inst.o: concept-inst.cc
 	$(CXXCOMPILE) -D_GLIBCPP_CONCEPT_CHECKS -fimplicit-templates -c $<
 
+install-exec-local:
+	pic_objs=`sed -n "s:'::g;s:^pic_object=::p" *.lo | grep -v '^none$$'`; \
+	if [ x"$$pic_objs" != x ]; then \
+		$(AR) cru libstdc++_pic.a $$pic_objs $(top_builddir)/libsupc++/*.o || exit 1; \
+		$(INSTALL_DATA) libstdc++_pic.a $(DESTDIR)$(toolexeclibdir) || exit 1; \
+	fi
+
 # Added bits to build debug library.
 @GLIBCPP_BUILD_DEBUG_TRUE@all-local: build_debug
 @GLIBCPP_BUILD_DEBUG_TRUE@install-data-local: install_debug
diff --git a/libtool.m4 b/libtool.m4
index 21d0424..21ace3b 100644
--- a/libtool.m4
+++ b/libtool.m4
@@ -677,14 +677,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method=['file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'] ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/ltcf-c.sh b/ltcf-c.sh
index ea6a31f..4fb259b 100644
--- a/ltcf-c.sh
+++ b/ltcf-c.sh
@@ -153,7 +153,7 @@ EOF
     # If the export-symbols file already is a .def file (1st line
     # is EXPORTS), use it as is.
     # If DATA tags from a recent dlltool are present, honour them!
-    archive_expsym_cmds='if test "x`head -1 $export_symbols`" = xEXPORTS; then
+    archive_expsym_cmds='if test "x`head -n 1 $export_symbols`" = xEXPORTS; then
         cp $export_symbols $output_objdir/$soname-def;
       else
         echo EXPORTS > $output_objdir/$soname-def;
diff --git a/ltcf-gcj.sh b/ltcf-gcj.sh
index 0ae9e16..269074f 100644
--- a/ltcf-gcj.sh
+++ b/ltcf-gcj.sh
@@ -156,7 +156,7 @@ EOF
     # If the export-symbols file already is a .def file (1st line
     # is EXPORTS), use it as is.
     # If DATA tags from a recent dlltool are present, honour them!
-    archive_expsym_cmds='if test "x`head -1 $export_symbols`" = xEXPORTS; then
+    archive_expsym_cmds='if test "x`head -n 1 $export_symbols`" = xEXPORTS; then
         cp $export_symbols $output_objdir/$soname-def;
       else
         echo EXPORTS > $output_objdir/$soname-def;
diff --git a/zlib/configure b/zlib/configure
index 4d92a73..99a5fa8 100755
--- a/zlib/configure
+++ b/zlib/configure
@@ -1579,14 +1579,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
@@ -2752,6 +2745,9 @@ else
 fi
 if test "$GCC" = yes && $CC -print-multi-os-directory > /dev/null 2>&1; then
   multiosdir=/`$CC -print-multi-os-directory`
+  case $multiosdir in
+    /.) multiosdir= ;; # Avoid trailing /.
+  esac
 else
   multiosdir=
 fi
diff --git a/zlib/configure.in b/zlib/configure.in
index 224f1de..0d5588d 100644
--- a/zlib/configure.in
+++ b/zlib/configure.in
@@ -123,6 +123,9 @@ else
 fi
 if test "$GCC" = yes && $CC -print-multi-os-directory > /dev/null 2>&1; then
   multiosdir=/`$CC -print-multi-os-directory`
+  case $multiosdir in
+    /.) multiosdir= ;; # Avoid trailing /.
+  esac
 else
   multiosdir=
 fi
