diff --git a/gcc/testsuite/gcc.dg/pr81192.c b/gcc/testsuite/gcc.dg/pr81192.c
index 0049f371b..87a7a7a19 100644
--- a/gcc/testsuite/gcc.dg/pr81192.c
+++ b/gcc/testsuite/gcc.dg/pr81192.c
@@ -1,4 +1,4 @@
-/* { dg-options "-Os -fdump-tree-pre-details" } */
+/* { dg-options "-Os -fgimple -fdump-tree-pre-details -fdisable-tree-evrp -fno-tree-dse" } */
 
 #if __SIZEOF_INT__ == 2
 #define unsigned __UINT32_TYPE__
@@ -8,6 +8,73 @@
 unsigned a;
 int b, c;
 
+void __GIMPLE(ssa, startwith("pre")) fn2   ()
+{
+  int b_lsm6;
+  int j;
+  int c0_1;
+  int iftmp2_8;
+
+  __BB(2):
+  a = _Literal (unsigned)30;
+  c0_1 = c;
+  b_lsm6_9 = b;
+  goto __BB7;
+
+  __BB(3):
+  if (j_6(D) != _Literal (int)2147483647)
+    goto __BB4;
+  else
+    goto __BB9;
+
+  __BB(4):
+  iftmp2_8 = j_6(D) + _Literal (int)1;
+  goto __BB5;
+
+  __BB(9):
+  iftmp2_8 = j_6(D) + _Literal (int)1;
+  goto __BB5;
+
+  __BB(5):
+  b_lsm6_10 = _Literal (int)2147483647;
+  goto __BB6;
+
+  __BB(6):
+  if (c0_1 != _Literal (int) 0)
+    goto __BB3;
+  else
+    goto __BB8;
+
+  __BB(8):
+  goto __BB7;
+
+  __BB(7):
+  goto __BB6;
+
+}
+
+#if 0
+/* This used to be a C based testcase but ccp3 would now would remove
+   the setting of iftmp2_8 (in the above gimple) which would cause PRE
+   not to test what PRE was doing incorrectly. The original code is below. */
+/* Disable tree-evrp because the new version of evrp sees
+<bb 3> :
+  if (j_8(D) != 2147483647)
+    goto <bb 4>; [50.00%]
+  else
+    goto <bb 5>; [50.00%]
+<bb 4> :
+  iftmp.2_11 = j_8(D) + 1;
+<bb 5> :
+  # iftmp.2_12 = PHI <j_8(D)(3), iftmp.2_11(4)>
+
+EVRP now recognizes a constant can be propagated into the 3->5 edge and
+produces
+  # iftmp.2_12 = PHI <2147483647(3), iftmp.2_11(4)> 
+which causes the situation being tested to dissapear before we get to PRE.  */
+
+/* Likewise disable DSE which also elides the tail merging "opportunity".  */
+
 static int
 fn1 (int p1, int p2)
 {
@@ -23,5 +90,6 @@ fn2 (void)
     for (; c; b = fn1 (j, 1))
       ;
 }
+#endif
 
 /* { dg-final { scan-tree-dump-times "(?n)find_duplicates: <bb .*> duplicate of <bb .*>" 1 "pre" } } */
diff --git a/gcc/testsuite/gcc.dg/pr98845.c b/gcc/testsuite/gcc.dg/pr98845.c
new file mode 100644
index 000000000..074c97967
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr98845.c
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-tree-dce -fno-tree-dse" } */
+
+int n;
+
+__attribute__ ((returns_twice)) void
+foo (void);
+
+void
+bar (void);
+
+void
+quux (int x)
+{
+  if (x)
+    ++x;
+  else
+    {
+      if (n)
+        {
+          x = 1;
+          foo ();
+        }
+      else
+        bar ();
+
+      if (n)
+        {
+          ++x;
+          ++n;
+        }
+    }
+}
diff --git a/gcc/tree-ssa-tail-merge.c b/gcc/tree-ssa-tail-merge.c
index 7361e0b8c..9c61f538a 100644
--- a/gcc/tree-ssa-tail-merge.c
+++ b/gcc/tree-ssa-tail-merge.c
@@ -336,10 +336,13 @@ stmt_local_def (gimple *stmt)
 
   def_bb = gimple_bb (stmt);
 
+  bool any_use = false;
   FOR_EACH_IMM_USE_FAST (use_p, iter, val)
     {
       if (is_gimple_debug (USE_STMT (use_p)))
 	continue;
+
+      any_use = true;
       bb = gimple_bb (USE_STMT (use_p));
       if (bb == def_bb)
 	continue;
@@ -351,6 +354,11 @@ stmt_local_def (gimple *stmt)
       return false;
     }
 
+  /* When there is no use avoid making the stmt live on other paths.
+     This can happen with DCE disabled or not done as seen in PR98845.  */
+  if (!any_use)
+    return false;
+
   return true;
 }
 
