diff --git a/Makefile.in b/Makefile.in
index c1860db..f6bbad3 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -50,7 +50,7 @@ T_CFLAGS =
 X_CPPFLAGS =
 T_CPPFLAGS =
 
-CC = cc
+CC = @CC@
 BISON = bison
 BISONFLAGS =
 AR = ar
@@ -80,7 +80,7 @@ RANLIB_TEST = [ -f /usr/bin/ranlib -o -f /bin/ranlib ]
 # OLDCC should not be the GNU C compiler,
 # since that would compile typical libgcc1.a functions such as mulsi3
 # into infinite recursions.
-OLDCC = cc
+OLDCC = ${CC}
 
 # CFLAGS for use with OLDCC, for compiling libgcc1.a.
 # NOTE: -O does not work on some Unix systems!
@@ -237,6 +237,10 @@ EXTRA_OBJS =
 # Often this is edited directly by `configure'.
 EXTRA_HEADERS =
 
+# Target to use whe installing assert.h.  Some systems may
+# want to set this empty.
+INSTALL_ASSERT_H = install-assert-h
+
 # Set this to `ld' to enable use of collect2.
 # USE_COLLECT2 =
 # It is convenient for configure to add the assignment at the beginning,
@@ -597,7 +601,7 @@ enquire.o: $(srcdir)/enquire.c $(GCC_PASSES)
 #	-if [ "$(srcdir)" != "." ]; then rm -f ./enquire.c; else true; fi
 #	-cp $(srcdir)/enquire.c . > /dev/null 2>&1
 # Breaking this line caused a problem with one version of GNU make.
-	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) $(ENQUIRE_CFLAGS) -I. -c $(srcdir)/enquire.c
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) $(ENQUIRE_CFLAGS) -I. -I$(srcdir) -c $(srcdir)/enquire.c
 
 # Build the version of limits.h that we will install.
 xlimits.h: glimits.h limitx.h limity.h
@@ -797,6 +801,17 @@ crtend.o:	crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h
 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) -DCRT_END \
 	  -finhibit-size-directive -fno-inline-functions \
 	  -g0 -c $(srcdir)/crtstuff.c -o crtend.o
+
+crtbeginS.o:	crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) -DCRT_BEGIN \
+	  -DCRTSTUFFS_O -finhibit-size-directive -fno-inline-functions \
+	  -g0 -c $(srcdir)/crtstuff.c -o crtbeginS.o -fPIC
+
+crtendS.o:	crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) -DCRT_END \
+	  -DCRTSTUFFS_O -finhibit-size-directive -fno-inline-functions \
+	  -g0 -c $(srcdir)/crtstuff.c -o crtendS.o -fPIC
+
 
 # Compiling object files from source files.
 
@@ -1004,7 +1019,7 @@ reload1.o : reload1.c $(CONFIG_H) $(RTL_H) flags.h expr.h \
    reload.h regs.h hard-reg-set.h insn-config.h insn-flags.h insn-codes.h \
    basic-block.h recog.h output.h
 caller-save.o : caller-save.c $(CONFIG_H) $(RTL_H) flags.h \
-   regs.h hard-reg-set.h insn-config.h basic-block.h recog.h reload.h expr.h
+   regs.h hard-reg-set.h insn-codes.h insn-config.h basic-block.h recog.h reload.h expr.h
 reorg.o : reorg.c $(CONFIG_H) $(RTL_H) conditions.h hard-reg-set.h \
    basic-block.h regs.h insn-config.h insn-attr.h insn-flags.h recog.h \
    flags.h output.h
@@ -1785,167 +1800,169 @@ install-float-h-cross: install-dir
 #	if [ -f enquire ] ; then true; else false; fi
 # Note: don't use -.  We should fail right away if enquire was not made.
 	./enquire -f > $(tmpdir)/float.h
-	-rm -f $(libsubdir)/include/float.h
-	$(INSTALL_DATA) $(tmpdir)/float.h $(libsubdir)/include/float.h
+	-rm -f $(DESTDIR)$(libsubdir)/include/float.h
+	$(INSTALL_DATA) $(tmpdir)/float.h $(DESTDIR)$(libsubdir)/include/float.h
 	-rm -f $(tmpdir)/float.h
-	chmod a-x $(libsubdir)/include/float.h
+	chmod a-x $(DESTDIR)$(libsubdir)/include/float.h
 
 # Create the installation directory.
 install-dir:
-	-if [ -d $(libdir) ] ; then true ; else mkdir $(libdir) ; fi
-	-if [ -d $(libdir)/gcc-lib ] ; then true ; else mkdir $(libdir)/gcc-lib ; fi
+	-if [ -d $(DESTDIR)$(libdir) ] ; then true ; else mkdir -p $(DESTDIR)$(libdir) ; fi
+	-if [ -d $(DESTDIR)$(libdir)/gcc-lib ] ; then true ; else mkdir -p $(DESTDIR)$(libdir)/gcc-lib ; fi
 # This dir isn't currently searched by cpp.
-#	-if [ -d $(libdir)/gcc-lib/include ] ; then true ; else mkdir $(libdir)/gcc-lib/include ; fi
-	-if [ -d $(libdir)/gcc-lib/$(target) ] ; then true ; else mkdir $(libdir)/gcc-lib/$(target) ; fi
-	-if [ -d $(libdir)/gcc-lib/$(target)/$(version) ] ; then true ; else mkdir $(libdir)/gcc-lib/$(target)/$(version) ; fi
-	-if [ -d $(libdir)/gcc-lib/$(target)/$(version)/include ] ; then true ; else mkdir $(libdir)/gcc-lib/$(target)/$(version)/include ; fi
-	-if [ -d $(bindir) ] ; then true ; else mkdir $(bindir) ; fi
-	-if [ -d $(includedir) ] ; then true ; else mkdir $(includedir) ; fi
-	-if [ -d $(tooldir) ] ; then true ; else mkdir $(tooldir) ; fi
-	-if [ -d $(assertdir) ] ; then true ; else mkdir $(assertdir) ; fi
-	-if [ -d $(infodir) ] ; then true ; else mkdir $(infodir) ; fi
+#	-if [ -d $(DESTDIR)$(libdir)/gcc-lib/include ] ; then true ; else mkdir -p $(DESTDIR)$(libdir)/gcc-lib/include ; fi
+	-if [ -d $(DESTDIR)$(libdir)/gcc-lib/$(target) ] ; then true ; else mkdir -p $(DESTDIR)$(libdir)/gcc-lib/$(target) ; fi
+	-if [ -d $(DESTDIR)$(libdir)/gcc-lib/$(target)/$(version) ] ; then true ; else mkdir -p $(DESTDIR)$(libdir)/gcc-lib/$(target)/$(version) ; fi
+	-if [ -d $(DESTDIR)$(libdir)/gcc-lib/$(target)/$(version)/include ] ; then true ; else mkdir -p $(DESTDIR)$(libdir)/gcc-lib/$(target)/$(version)/include ; fi
+	-if [ -d $(DESTDIR)$(bindir) ] ; then true ; else mkdir -p $(DESTDIR)$(bindir) ; fi
+	-if [ -d $(DESTDIR)$(includedir) ] ; then true ; else mkdir -p $(DESTDIR)$(includedir) ; fi
+	-if [ -d $(DESTDIR)$(tooldir) ] ; then true ; else mkdir -p $(DESTDIR)$(tooldir) ; fi
+	-if [ -d $(DESTDIR)$(assertdir) ] ; then true ; else mkdir -p $(DESTDIR)$(assertdir) ; fi
+	-if [ -d $(DESTDIR)$(infodir) ] ; then true ; else mkdir -p $(DESTDIR)$(infodir) ; fi
 # We don't use mkdir -p to create the parents of mandir,
 # because some systems don't support it.
 # Instead, we use this technique to create the immediate parent of mandir.
-	-parent=`echo $(mandir)|sed -e 's@/[^/]*$$@@'`; \
-	if [ -d $$parent ] ; then true ; else mkdir $$parent ; fi
-	-if [ -d $(mandir) ] ; then true ; else mkdir $(mandir) ; fi
+	-parent=`echo $(DESTDIR)$(mandir)|sed -e 's@/[^/]*$$@@'`; \
+	if [ -d $$parent ] ; then true ; else mkdir -p $$parent ; fi
+	-if [ -d $(DESTDIR)$(mandir) ] ; then true ; else mkdir -p $(DESTDIR)$(mandir) ; fi
 
 # Install the compiler executables built during cross compilation.
 install-common: native install-dir xgcc $(EXTRA_PARTS)
 	for file in $(COMPILERS); do \
 	  if [ -f $$file ] ; then \
-	    rm -f $(libsubdir)/$$file; \
-	    $(INSTALL_PROGRAM) $$file $(libsubdir)/$$file; \
+	    rm -f $(DESTDIR)$(libsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libsubdir)/$$file; \
 	  else true; \
 	  fi; \
 	done
 	for file in $(EXTRA_PASSES) $(EXTRA_PARTS) $(EXTRA_PROGRAMS) $(USE_COLLECT2) ..; do \
 	  if [ x"$$file" != x.. ]; then \
-	    rm -f $(libsubdir)/$$file; \
-	    $(INSTALL_PROGRAM) $$file $(libsubdir)/$$file; \
+	    rm -f $(DESTDIR)$(libsubdir)/$$file; \
+	    $(INSTALL_PROGRAM) $$file $(DESTDIR)$(libsubdir)/$$file; \
 	  else true; fi; \
 	done
 # Don't mess with specs if it doesn't exist yet.
 	-if [ -f specs ] ; then \
-	  rm -f $(libsubdir)/specs; \
-	  $(INSTALL_DATA) specs $(libsubdir)/specs; \
+	  rm -f $(DESTDIR)$(libsubdir)/specs; \
+	  $(INSTALL_DATA) specs $(DESTDIR)$(libsubdir)/specs; \
 	fi
 # Install the driver program as $(target)-gcc
 # and also as either gcc (if native) or $(tooldir)/bin/gcc.
 	-if [ -f gcc-cross ] ; then \
-	  rm -f $(bindir)/$(target)-gcc; \
-	  $(INSTALL_PROGRAM) gcc-cross $(bindir)/$(target)-gcc; \
-	  if [ -d $(tooldir)/bin/. ] ; then \
-	    rm -f $(tooldir)/bin/gcc; \
-	    $(INSTALL_PROGRAM) gcc-cross $(tooldir)/bin/gcc; \
+	  rm -f $(DESTDIR)$(bindir)/$(target)-gcc; \
+	  $(INSTALL_PROGRAM) gcc-cross $(DESTDIR)$(bindir)/$(target)-gcc; \
+	  if [ -d $(DESTDIR)$(tooldir)/bin/. ] ; then \
+	    rm -f $(DESTDIR)$(tooldir)/bin/gcc; \
+	    $(INSTALL_PROGRAM) gcc-cross $(DESTDIR)$(tooldir)/bin/gcc; \
 	  else true; fi; \
 	  if [ -f cc1plus ] ; then \
-	    rm -f $(bindir)/$(target)-g++; \
-	    $(INSTALL_PROGRAM) g++-cross $(bindir)/$(target)-g++; \
-	    chmod a+x $(bindir)/$(target)-g++; \
-	    rm -f $(bindir)/$(target)-c++; \
-	    ln $(bindir)/$(target)-g++ $(bindir)/$(target)-c++; \
+	    rm -f $(DESTDIR)$(bindir)/$(target)-g++; \
+	    $(INSTALL_PROGRAM) g++-cross $(DESTDIR)$(bindir)/$(target)-g++; \
+	    chmod a+x $(DESTDIR)$(bindir)/$(target)-g++; \
+	    rm -f $(DESTDIR)$(bindir)/$(target)-c++; \
+	    ln $(DESTDIR)$(bindir)/$(target)-g++ $(DESTDIR)$(bindir)/$(target)-c++; \
 	  fi ; \
 	else \
-	  rm -f $(bindir)/gcc; \
-	  $(INSTALL_PROGRAM) xgcc $(bindir)/gcc; \
-	  rm -f $(bindir)/$(target)-gcc-1; \
-	  ln $(bindir)/gcc $(bindir)/$(target)-gcc-1; \
-	  mv $(bindir)/$(target)-gcc-1 $(bindir)/$(target)-gcc; \
+	  rm -f $(DESTDIR)$(bindir)/gcc; \
+	  $(INSTALL_PROGRAM) xgcc $(DESTDIR)$(bindir)/gcc; \
+	  rm -f $(DESTDIR)$(bindir)/$(target)-gcc-1; \
+	  ln $(DESTDIR)$(bindir)/gcc $(DESTDIR)$(bindir)/$(target)-gcc-1; \
+	  mv $(DESTDIR)$(bindir)/$(target)-gcc-1 $(DESTDIR)$(bindir)/$(target)-gcc; \
 	  if [ -f cc1plus ] ; then \
-	    rm -f $(bindir)/g++; \
-	    $(INSTALL_PROGRAM) g++ $(bindir)/g++; \
-	    chmod a+x $(bindir)/g++; \
-	    rm -f $(bindir)/c++; \
-	    ln $(bindir)/g++ $(bindir)/c++; \
+	    rm -f $(DESTDIR)$(bindir)/g++; \
+	    $(INSTALL_PROGRAM) g++ $(DESTDIR)$(bindir)/g++; \
+	    chmod a+x $(DESTDIR)$(bindir)/g++; \
+	    rm -f $(DESTDIR)$(bindir)/c++; \
+	    ln $(DESTDIR)$(bindir)/g++ $(DESTDIR)$(bindir)/c++; \
 	  fi ; \
 	fi
 # Install protoize if it was compiled.
 	-if [ -f protoize ]; \
 	then \
-	    rm -f $(bindir)/protoize; \
-	    $(INSTALL_PROGRAM) protoize $(bindir)/protoize; \
-	    rm -f $(bindir)/unprotoize; \
-	    $(INSTALL_PROGRAM) unprotoize $(bindir)/unprotoize; \
-	    rm -f $(libsubdir)/SYSCALLS.c.X; \
-	    $(INSTALL_DATA) SYSCALLS.c.X $(libsubdir)/SYSCALLS.c.X; \
-	    chmod a-x $(libsubdir)/SYSCALLS.c.X; \
+	    rm -f $(DESTDIR)$(bindir)/protoize; \
+	    $(INSTALL_PROGRAM) protoize $(DESTDIR)$(bindir)/protoize; \
+	    rm -f $(DESTDIR)$(bindir)/unprotoize; \
+	    $(INSTALL_PROGRAM) unprotoize $(DESTDIR)$(bindir)/unprotoize; \
+	    rm -f $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	    $(INSTALL_DATA) SYSCALLS.c.X $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
+	    chmod a-x $(DESTDIR)$(libsubdir)/SYSCALLS.c.X; \
 	fi
-	-rm -f $(libsubdir)/cpp
-	$(INSTALL_PROGRAM) cpp $(libsubdir)/cpp
+	-rm -f $(DESTDIR)$(libsubdir)/cpp
+	$(INSTALL_PROGRAM) cpp $(DESTDIR)$(libsubdir)/cpp
 
 # Install the info files.
 install-info: doc install-dir
-	-rm -f $(infodir)/cpp.info* $(infodir)/gcc.info*
+	-rm -f $(DESTDIR)$(infodir)/cpp.info* $(DESTDIR)$(infodir)/gcc.info*
 	cd $(srcdir); for f in cpp.info* gcc.info*; \
-	do $(INSTALL_DATA) $$f $(infodir)/$$f; done
-	-chmod a-x $(infodir)/cpp.info* $(infodir)/gcc.info*
+	do $(INSTALL_DATA) $$f $(DESTDIR)$(infodir)/$$f; done
+	-chmod a-x $(DESTDIR)$(infodir)/cpp.info* $(DESTDIR)$(infodir)/gcc.info*
 
 # Install the man pages.
 install-man: install-dir $(srcdir)/gcc.1 $(srcdir)/cccp.1 $(srcdir)/g++.1
-	-rm -f $(mandir)/gcc$(manext)
-	-$(INSTALL_DATA) $(srcdir)/gcc.1 $(mandir)/gcc$(manext)
-	-chmod a-x $(mandir)/gcc$(manext)
-	-rm -f $(mandir)/cccp$(manext)
-	-$(INSTALL_DATA) $(srcdir)/cccp.1 $(mandir)/cccp$(manext)
-	-chmod a-x $(mandir)/cccp$(manext)
-	-$(INSTALL_DATA) $(srcdir)/g++.1 $(mandir)/g++$(manext)
-	-chmod a-x $(mandir)/g++$(manext)
+	-rm -f $(DESTDIR)$(mandir)/gcc$(manext)
+	-$(INSTALL_DATA) $(srcdir)/gcc.1 $(DESTDIR)$(mandir)/gcc$(manext)
+	-chmod a-x $(DESTDIR)$(mandir)/gcc$(manext)
+	-rm -f $(DESTDIR)$(mandir)/cccp$(manext)
+	-$(INSTALL_DATA) $(srcdir)/cccp.1 $(DESTDIR)$(mandir)/cccp$(manext)
+	-chmod a-x $(DESTDIR)$(mandir)/cccp$(manext)
+	-if [ -f cc1plus ] ; then \
+	  $(INSTALL_DATA) $(srcdir)/g++.1 $(DESTDIR)$(mandir)/g++$(manext); \
+	  chmod a-x $(DESTDIR)$(mandir)/g++$(manext); \
+	fi
 
 # Install the library.
 install-libgcc: libgcc.a install-dir
 	-if [ -f libgcc.a ] ; then \
-	  rm -f $(libsubdir)/libgcc.a; \
-	  $(INSTALL_DATA) libgcc.a $(libsubdir)/libgcc.a; \
+	  rm -f $(DESTDIR)$(libsubdir)/libgcc.a; \
+	  $(INSTALL_DATA) libgcc.a $(DESTDIR)$(libsubdir)/libgcc.a; \
 	  if $(RANLIB_TEST) ; then \
-	    (cd $(libsubdir); $(RANLIB) libgcc.a); else true; fi; \
-	  chmod a-x $(libsubdir)/libgcc.a; \
+	    (cd $(DESTDIR)$(libsubdir); $(RANLIB) libgcc.a); else true; fi; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/libgcc.a; \
 	else true; fi
 
 # Install the objc run time library.
 install-libobjc: libobjc.a install-dir
 	-if [ -f libobjc.a ] ; then \
-	  rm -f $(libsubdir)/libobjc.a; \
-	  $(INSTALL_DATA) libobjc.a $(libsubdir)/libobjc.a; \
+	  rm -f $(DESTDIR)$(libsubdir)/libobjc.a; \
+	  $(INSTALL_DATA) libobjc.a $(DESTDIR)$(libsubdir)/libobjc.a; \
 	  if $(RANLIB_TEST) ; then \
-	    (cd $(libsubdir); $(RANLIB) libobjc.a); else true; fi; \
-	  chmod a-x $(libsubdir)/libobjc.a; \
+	    (cd $(DESTDIR)$(libsubdir); $(RANLIB) libobjc.a); else true; fi; \
+	  chmod a-x $(DESTDIR)$(libsubdir)/libobjc.a; \
 	else true; fi
 
 # Install all the header files built in the include subdirectory.
-install-headers: install-include-dir $(INSTALL_HEADERS_DIR) install-assert-h
+install-headers: install-include-dir $(INSTALL_HEADERS_DIR) $(INSTALL_ASSERT_H)
 # Fix symlinks to absolute paths in the installed include directory to
 # point to the installed directory, not the build directory.
-	-files=`cd $(libsubdir)/include; find . -type l -print 2>/dev/null`; \
+	-files=`cd $(DESTDIR)$(libsubdir)/include; find . -type l -print 2>/dev/null`; \
 	if [ $$? -eq 0 ]; then \
 	  dir=`cd include; pwd`; \
 	  for i in $$files; do \
-	    dest=`ls -ld $(libsubdir)/include/$$i | sed -n 's/.*-> //p'`; \
+	    dest=`ls -ld $(DESTDIR)$(libsubdir)/include/$$i | sed -n 's/.*-> //p'`; \
 	    if expr "$$dest" : "$$dir.*" > /dev/null; then \
-	      rm -f $(libsubdir)/include/$$i; \
-	      ln -s `echo $$i | sed "s|/[^/]*|/..|g" | sed 's|/..$$||'``echo "$$dest" | sed "s|$$dir||"` $(libsubdir)/include/$$i; \
+	      rm -f $(DESTDIR)$(libsubdir)/include/$$i; \
+	      ln -s `echo $$i | sed "s|/[^/]*|/..|g" | sed 's|/..$$||'``echo "$$dest" | sed "s|$$dir||"` $(DESTDIR)$(libsubdir)/include/$$i; \
 	    fi; \
 	  done; \
 	fi
 
 # Create or recreate the gcc private include file directory.
 install-include-dir: install-dir
-	-rm -rf $(libsubdir)/include
-	mkdir $(libsubdir)/include
-	-chmod a+rx $(libsubdir)/include
+	-rm -rf $(DESTDIR)$(libsubdir)/include
+	mkdir $(DESTDIR)$(libsubdir)/include
+	-chmod a+rx $(DESTDIR)$(libsubdir)/include
 
 # Install the include directory using tar.
 install-headers-tar: stmp-headers $(STMP_FIXPROTO) install-include-dir
 	cd include; \
-	 (tar cf - .; exit 0) | (cd $(libsubdir)/include; tar $(TAROUTOPTS) - )
+	 (tar cf - .; exit 0) | (cd $(DESTDIR)$(libsubdir)/include; tar $(TAROUTOPTS) - )
 # /bin/sh on some systems returns the status of the first tar,
 # and that can lose with GNU tar which always writes a full block.
 # So use `exit 0' to ignore its exit status.
 
 # Install the include directory using cpio.
 install-headers-cpio: stmp-headers $(STMP_FIXPROTO) install-include-dir
-	cd include; find . -print | cpio -pdum $(libsubdir)/include
+	cd include; find . -print | cpio -pdum $(DESTDIR)$(libsubdir)/include
 
 # Put assert.h where it won't override GNU libc's assert.h.
 # It goes in a dir that is searched after GNU libc's headers;
@@ -1955,38 +1972,38 @@ install-headers-cpio: stmp-headers $(STMP_FIXPROTO) install-include-dir
 ## This code would be simpler if it tested for -f ... && ! grep ...
 ## but supposedly the ! operator is missing in sh on some systems.
 install-assert-h: assert.h install-dir
-	if [ -f $(assertdir)/assert.h ]; \
+	if [ -f $(DESTDIR)$(assertdir)/assert.h ]; \
 	then \
-	  if grep "__eprintf" $(assertdir)/assert.h >/dev/null; \
+	  if grep "__eprintf" $(DESTDIR)$(assertdir)/assert.h >/dev/null; \
 	    then \
-	    rm -f $(assertdir)/assert.h; \
-	    $(INSTALL_DATA) $(srcdir)/assert.h $(assertdir)/assert.h; \
-	    chmod a-x $(assertdir)/assert.h; \
+	    rm -f $(DESTDIR)$(assertdir)/assert.h; \
+	    $(INSTALL_DATA) $(srcdir)/assert.h $(DESTDIR)$(assertdir)/assert.h; \
+	    chmod a-x $(DESTDIR)$(assertdir)/assert.h; \
 	  else true; \
 	  fi; \
 	else \
-	  rm -f $(assertdir)/assert.h; \
-	  $(INSTALL_DATA) $(srcdir)/assert.h $(assertdir)/assert.h; \
-	  chmod a-x $(assertdir)/assert.h; \
+	  rm -f $(DESTDIR)$(assertdir)/assert.h; \
+	  $(INSTALL_DATA) $(srcdir)/assert.h $(DESTDIR)$(assertdir)/assert.h; \
+	  chmod a-x $(DESTDIR)$(assertdir)/assert.h; \
 	fi
 
 # Use this target to install the program `collect2' under the name `ld'.
 install-collect2: collect2 install-dir
-	$(INSTALL_PROGRAM) collect2 $(libsubdir)/ld
+	$(INSTALL_PROGRAM) collect2 $(DESTDIR)$(libsubdir)/ld
 # Install the driver program as $(libsubdir)/gcc for collect2.
-	$(INSTALL_PROGRAM) xgcc $(libsubdir)/gcc
+	$(INSTALL_PROGRAM) xgcc $(DESTDIR)$(libsubdir)/gcc
 
 # Cancel installation by deleting the installed files.
 uninstall:
-	-rm -rf $(libsubdir)
-	-rm -rf $(bindir)/gcc
-	-rm -rf $(bindir)/protoize
-	-rm -rf $(bindir)/unprotoize
-	-rm -rf $(mandir)/gcc$(manext)
-	-rm -rf $(mandir)/g++$(manext)
-	-rm -rf $(mandir)/cccp$(manext)
-	-rm -rf $(mandir)/protoize$(manext)
-	-rm -rf $(mandir)/unprotoize$(manext)
+	-rm -rf $(DESTDIR)$(libsubdir)
+	-rm -rf $(DESTDIR)$(bindir)/gcc
+	-rm -rf $(DESTDIR)$(bindir)/protoize
+	-rm -rf $(DESTDIR)$(bindir)/unprotoize
+	-rm -rf $(DESTDIR)$(mandir)/gcc$(manext)
+	-rm -rf $(DESTDIR)$(mandir)/g++$(manext)
+	-rm -rf $(DESTDIR)$(mandir)/cccp$(manext)
+	-rm -rf $(DESTDIR)$(mandir)/protoize$(manext)
+	-rm -rf $(DESTDIR)$(mandir)/unprotoize$(manext)
 
 # These exist for maintenance purposes.
 
diff --git a/bc-emit.c b/bc-emit.c
index 62cc533..1717865 100644
--- a/bc-emit.c
+++ b/bc-emit.c
@@ -19,7 +19,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 
 #include "config.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
 #include "machmode.h"
 #include "rtl.h"
 #include "real.h"
@@ -906,18 +910,21 @@ bc_emit_bytecode (bytecode)
    of literal values in the call.  First argument is the instruction, the
    remaining arguments are literals of size HOST_WIDE_INT or smaller. */
 void
-bc_emit_instruction (va_alist)
-     va_dcl
+bc_emit_instruction VPROTO((enum bytecode_opcode opcode, ...))
 {
-  va_list arguments;
+#ifndef __STDC__
   enum bytecode_opcode opcode;
+#endif
+  va_list arguments;
   int nliteral, instruction;
 
+  VA_START (arguments, opcode);
 
-  va_start (arguments);
+#ifndef __STDC__
+  opcode = va_arg (arguments, enum bytecode_opcode);
+#endif
 
   /* Emit instruction bytecode */
-  opcode = va_arg (arguments, enum bytecode_opcode);
   bc_emit_bytecode (opcode);
   instruction = (int) opcode;
 
diff --git a/calls.c b/calls.c
index 2f13dcb..f8566cd 100644
--- a/calls.c
+++ b/calls.c
@@ -22,7 +22,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include "tree.h"
 #include "flags.h"
 #include "expr.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
 #include "insn-flags.h"
 
 /* Decide whether a function's arguments should be processed
@@ -2066,19 +2070,22 @@ expand_call (exp, target, ignore)
    move memory references across the non-const call.  */
 
 void
-emit_library_call (va_alist)
-     va_dcl
+emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,
+                          int nargs, ...))
 {
+#ifndef __STDC__
+  rtx orgfun;
+  int no_queue;
+  enum machine_mode outmode;
+  int nargs;
+#endif
   va_list p;
   /* Total size in bytes of all the stack-parms scanned so far.  */
   struct args_size args_size;
   /* Size of arguments before any adjustments (such as rounding).  */
   struct args_size original_args_size;
   register int argnum;
-  enum machine_mode outmode;
-  int nargs;
   rtx fun;
-  rtx orgfun;
   int inc;
   int count;
   rtx argblock = 0;
@@ -2087,16 +2094,20 @@ emit_library_call (va_alist)
 	       struct args_size offset; struct args_size size; };
   struct arg *argvec;
   int old_inhibit_defer_pop = inhibit_defer_pop;
-  int no_queue = 0;
   rtx use_insns;
   /* library calls are never indirect calls.  */
   int current_call_is_indirect = 0;
 
-  va_start (p);
-  orgfun = fun = va_arg (p, rtx);
+  VA_START (p, nargs);
+
+#ifndef __STDC__
+  orgfun = va_arg (p, rtx);
   no_queue = va_arg (p, int);
   outmode = va_arg (p, enum machine_mode);
   nargs = va_arg (p, int);
+#endif
+
+  fun = orgfun;
 
   /* Copy all the libcall-arguments out of the varargs data
      and into a vector ARGVEC.
@@ -2335,19 +2346,23 @@ emit_library_call (va_alist)
    If VALUE is nonzero, VALUE is returned.  */
 
 rtx
-emit_library_call_value (va_alist)
-     va_dcl
+emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,
+                                enum machine_mode outmode, int nargs, ...))
 {
+#ifndef __STDC__
+  rtx orgfun;
+  rtx value;
+  int no_queue;
+  enum machine_mode outmode;
+  int nargs;
+#endif
   va_list p;
   /* Total size in bytes of all the stack-parms scanned so far.  */
   struct args_size args_size;
   /* Size of arguments before any adjustments (such as rounding).  */
   struct args_size original_args_size;
   register int argnum;
-  enum machine_mode outmode;
-  int nargs;
   rtx fun;
-  rtx orgfun;
   int inc;
   int count;
   rtx argblock = 0;
@@ -2356,21 +2371,24 @@ emit_library_call_value (va_alist)
 	       struct args_size offset; struct args_size size; };
   struct arg *argvec;
   int old_inhibit_defer_pop = inhibit_defer_pop;
-  int no_queue = 0;
   rtx use_insns;
-  rtx value;
   rtx mem_value = 0;
   int pcc_struct_value = 0;
   int struct_value_size = 0;
   /* library calls are never indirect calls.  */
   int current_call_is_indirect = 0;
 
-  va_start (p);
-  orgfun = fun = va_arg (p, rtx);
+  VA_START (p, nargs);
+
+#ifndef __STDC__
+  orgfun = va_arg (p, rtx);
   value = va_arg (p, rtx);
   no_queue = va_arg (p, int);
   outmode = va_arg (p, enum machine_mode);
   nargs = va_arg (p, int);
+#endif
+
+  fun = orgfun;
 
   /* If this kind of value comes back in memory,
      decide where in memory it should come back.  */
diff --git a/cccp.c b/cccp.c
index 77ecb76..80e3e74 100644
--- a/cccp.c
+++ b/cccp.c
@@ -79,8 +79,12 @@ typedef unsigned char U_CHAR;
 
 #ifndef VMS
 #ifndef USG
-#include <sys/time.h>		/* for __DATE__ and __TIME__ */
-#include <sys/resource.h>
+#ifndef RLIMIT_STACK
+# include <time.h>
+#else
+# include <sys/time.h>
+# include <sys/resource.h>
+#endif
 #else
 #include <time.h>
 #include <fcntl.h>
@@ -185,13 +189,16 @@ void warning ();
 extern char *getenv ();
 extern FILE *fdopen ();
 extern char *version_string;
-extern struct tm *localtime ();
+#ifndef HAVE_STRERROR
 extern int sys_nerr;
 #if defined(bsd4_4)
 extern const char *const sys_errlist[];
 #else
 extern char *sys_errlist[];
 #endif
+#else   /* HAVE_STERRROR */
+char *strerror ();
+#endif
 extern int parse_escape ();
 
 #ifndef errno
@@ -3812,8 +3819,8 @@ special_symbol (hp, op)
 
   case T_DATE:
   case T_TIME:
-    buf = (char *) alloca (20);
     timebuf = timestamp ();
+    buf = (char *) alloca (20);
     if (hp->type == T_DATE)
       sprintf (buf, "\"%s %2d %4d\"", monthnames[timebuf->tm_mon],
 	      timebuf->tm_mday, timebuf->tm_year + 1900);
@@ -8015,6 +8022,27 @@ change_newlines (start, length)
   return obp - start;
 }
 
+/*
+ * my_strerror - return the descriptive text associated with an `errno' code.
+ */
+
+char *
+my_strerror (errnum)
+     int errnum;
+{
+  char *result;
+
+#ifndef HAVE_STRERROR
+  result = (char *) ((errnum < sys_nerr) ? sys_errlist[errnum] : 0);
+#else
+  result = strerror (errnum);
+#endif
+  if (!result)
+    result = "undocumented I/O error";
+
+  return result;
+}
+
 /*
  * error - print error message and increment count of errors.
  */
@@ -8062,10 +8090,7 @@ error_from_errno (name)
   if (ip != NULL)
     fprintf (stderr, "%s:%d: ", ip->nominal_fname, ip->lineno);
 
-  if (errno < sys_nerr)
-    fprintf (stderr, "%s: %s\n", name, sys_errlist[errno]);
-  else
-    fprintf (stderr, "%s: undocumented I/O error\n", name);
+  fprintf (stderr, "%s: %s\n", name, my_strerror (errno));
 
   errors++;
 }
@@ -9018,10 +9043,7 @@ perror_with_name (name)
      char *name;
 {
   fprintf (stderr, "%s: ", progname);
-  if (errno < sys_nerr)
-    fprintf (stderr, "%s: %s\n", name, sys_errlist[errno]);
-  else
-    fprintf (stderr, "%s: undocumented I/O error\n", name);
+  fprintf (stderr, "%s: %s\n", name, my_strerror (errno));
   errors++;
 }
 
diff --git a/collect2.c b/collect2.c
index ae7f070..4adae08 100644
--- a/collect2.c
+++ b/collect2.c
@@ -290,6 +290,11 @@ char *
 my_strerror (e)
      int e;
 {
+#ifdef HAVE_STRERROR
+  return strerror (e);
+
+#else
+
   static char buffer[30];
 
   if (!e)
@@ -300,6 +305,7 @@ my_strerror (e)
 
   sprintf (buffer, "Unknown error %d", e);
   return buffer;
+#endif
 }
 
 /* Delete tempfiles and exit function.  */
diff --git a/combine.c b/combine.c
index eab4587..699756e 100644
--- a/combine.c
+++ b/combine.c
@@ -74,7 +74,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
    combine anyway.  */
 
 #include "config.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
 
 /* Must precede rtl.h for FFS.  */
 #include <stdio.h>
@@ -391,7 +395,7 @@ static rtx simplify_shift_const	PROTO((rtx, enum rtx_code, enum machine_mode,
 				       rtx, int));
 static int recog_for_combine	PROTO((rtx *, rtx, rtx *));
 static rtx gen_lowpart_for_combine  PROTO((enum machine_mode, rtx));
-static rtx gen_rtx_combine ();  /* This is varargs.  */
+static rtx gen_rtx_combine PVPROTO((enum rtx_code code, enum machine_mode mode, ...));  /* This is varargs.  */
 static rtx gen_binary		PROTO((enum rtx_code, enum machine_mode,
 				       rtx, rtx));
 static rtx gen_unary		PROTO((enum rtx_code, enum machine_mode, rtx));
@@ -8149,21 +8153,26 @@ gen_lowpart_for_combine (mode, x)
 
 /*VARARGS2*/
 static rtx
-gen_rtx_combine (va_alist)
-     va_dcl
+gen_rtx_combine VPROTO((enum rtx_code code, enum machine_mode mode, ...))
 {
-  va_list p;
+#ifndef __STDC__
   enum rtx_code code;
   enum machine_mode mode;
+#endif
+  va_list p;
   int n_args;
   rtx args[3];
   int i, j;
   char *fmt;
   rtx rt;
 
-  va_start (p);
+  VA_START (p, mode);
+
+#ifndef __STDC__
   code = va_arg (p, enum rtx_code);
   mode = va_arg (p, enum machine_mode);
+#endif
+
   n_args = GET_RTX_LENGTH (code);
   fmt = GET_RTX_FORMAT (code);
 
diff --git a/config/i386/linux-aout.h b/config/i386/linux-aout.h
new file mode 100644
index 0000000..7e46c68
--- /dev/null
+++ b/config/i386/linux-aout.h
@@ -0,0 +1,76 @@
+/* Definitions for Intel 386 running Linux
+   Copyright (C) 1992, 1994, 1995 Free Software Foundation, Inc.
+   Contributed by H.J. Lu (hjl@nynexst.com)
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This is tested by i386/gas.h.  */
+#define YES_UNDERSCORES
+
+#include <i386/gstabs.h>
+#include <linux-aout.h>	/* some common stuff */
+
+/* Specify predefined symbols in preprocessor.  */
+
+#undef CPP_PREDEFINES
+#define CPP_PREDEFINES "-Dunix -Di386 -Dlinux -Asystem(unix) -Asystem(posix) -Acpu(i386) -Amachine(i386)"
+
+#undef CPP_SPEC
+#if TARGET_CPU_DEFAULT == 2
+#define CPP_SPEC "%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{!m386:-D__i486__} %{posix:-D_POSIX_SOURCE}"
+#else
+#define CPP_SPEC "%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{m486:-D__i486__} %{posix:-D_POSIX_SOURCE}"
+#endif
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "long int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+/* Don't default to pcc-struct-return, because gcc is the only compiler,
+   and we want to retain compatibility with older gcc versions.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+#undef LIB_SPEC
+
+#if 1
+/* We no longer link with libc_p.a or libg.a by default. If you
+ * want to profile or debug the Linux C library, please add
+ * -lc_p or -ggdb to LDFLAGS at the link time, respectively.
+ */
+#define LIB_SPEC \
+"%{mieee-fp:-lieee} %{p:-lgmon} %{pg:-lgmon} %{!ggdb:-lc} %{ggdb:-lg}"
+#else    
+#define LIB_SPEC \
+"%{mieee-fp:-lieee} %{p:-lgmon -lc_p} %{pg:-lgmon -lc_p} \
+ %{!p:%{!pg:%{!g*:-lc} %{g*:-lg -static}}}" 
+#endif
+
+
+#undef LINK_SPEC
+#define LINK_SPEC	"-m i386linux"
+
+/* Get perform_* macros to build libgcc.a.  */
+#include "i386/perform.h"
diff --git a/config/i386/linux.h b/config/i386/linux.h
index ac88de2..92207d1 100644
--- a/config/i386/linux.h
+++ b/config/i386/linux.h
@@ -1,40 +1,139 @@
-/* Definitions for Intel 386 running Linux
- * Copyright (C) 1992 Free Software Foundation, Inc.
- *
- * Written by H.J. Lu (hlu@eecs.wsu.edu)
- *
- * Linux is a POSIX.1 compatible UNIX clone for i386, which uses GNU
- * stuffs as the native stuffs.
- */
-
-#if 0	/* The FSF has fixed the known bugs. But ....... */
-
-/* Linux has a hacked gas 1.38.1, which can handle repz, repnz
- * and fildll.
- */
-
-#define GOOD_GAS
-
-#endif
-
-/* This is tested by i386/gas.h.  */
-#define YES_UNDERSCORES
-
-#ifndef LINUX_ELF
-#include "i386/gstabs.h"
-#endif
-
-/* Specify predefined symbols in preprocessor.  */
-
-#undef CPP_PREDEFINES
-#define CPP_PREDEFINES "-Dunix -Di386 -Dlinux -Asystem(unix) -Asystem(posix) -Acpu(i386) -Amachine(i386)"
-
-#undef CPP_SPEC
-#if TARGET_CPU_DEFAULT == 2
-#define CPP_SPEC "%{!m386:-D__i486__} %{posix:-D_POSIX_SOURCE}"
-#else
-#define CPP_SPEC "%{m486:-D__i486__} %{posix:-D_POSIX_SOURCE}"
-#endif
+/* Definitions for Intel 386 running Linux with ELF format
+   Copyright (C) 1994, 1995 Free Software Foundation, Inc.
+   Contributed by Eric Youngdale.
+   Modified for stabs-in-ELF by H.J. Lu.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#define LINUX_DEFAULT_ELF
+
+/* A lie, I guess, but the general idea behind linux/ELF is that we are
+   supposed to be outputting something that will assemble under SVr4.
+   This gets us pretty close.  */
+#include <i386/i386.h>	/* Base i386 target machine definitions */
+#include <i386/att.h>	/* Use the i386 AT&T assembler syntax */
+#include <linux.h>	/* some common stuff */
+
+#undef TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (i386 Linux/ELF)");
+
+/* The svr4 ABI for the i386 says that records and unions are returned
+   in memory.  */
+#undef DEFAULT_PCC_STRUCT_RETURN
+#define DEFAULT_PCC_STRUCT_RETURN 1
+
+/* This is how to output an element of a case-vector that is relative.
+   This is only used for PIC code.  See comments by the `casesi' insn in
+   i386.md for an explanation of the expression this outputs. */
+#undef ASM_OUTPUT_ADDR_DIFF_ELT
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \
+  fprintf (FILE, "\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\n", LPREFIX, VALUE)
+
+/* Indicate that jump tables go in the text section.  This is
+   necessary when compiling PIC code.  */
+#define JUMP_TABLES_IN_TEXT_SECTION
+
+/* Copy this from the svr4 specifications... */
+/* Define the register numbers to be used in Dwarf debugging information.
+   The SVR4 reference port C compiler uses the following register numbers
+   in its Dwarf output code:
+	0 for %eax (gnu regno = 0)
+	1 for %ecx (gnu regno = 2)
+	2 for %edx (gnu regno = 1)
+	3 for %ebx (gnu regno = 3)
+	4 for %esp (gnu regno = 7)
+	5 for %ebp (gnu regno = 6)
+	6 for %esi (gnu regno = 4)
+	7 for %edi (gnu regno = 5)
+   The following three DWARF register numbers are never generated by
+   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4
+   believes these numbers have these meanings.
+	8  for %eip    (no gnu equivalent)
+	9  for %eflags (no gnu equivalent)
+	10 for %trapno (no gnu equivalent)
+   It is not at all clear how we should number the FP stack registers
+   for the x86 architecture.  If the version of SDB on x86/svr4 were
+   a bit less brain dead with respect to floating-point then we would
+   have a precedent to follow with respect to DWARF register numbers
+   for x86 FP registers, but the SDB on x86/svr4 is so completely
+   broken with respect to FP registers that it is hardly worth thinking
+   of it as something to strive for compatibility with.
+   The version of x86/svr4 SDB I have at the moment does (partially)
+   seem to believe that DWARF register number 11 is associated with
+   the x86 register %st(0), but that's about all.  Higher DWARF
+   register numbers don't seem to be associated with anything in
+   particular, and even for DWARF regno 11, SDB only seems to under-
+   stand that it should say that a variable lives in %st(0) (when
+   asked via an `=' command) if we said it was in DWARF regno 11,
+   but SDB still prints garbage when asked for the value of the
+   variable in question (via a `/' command).
+   (Also note that the labels SDB prints for various FP stack regs
+   when doing an `x' command are all wrong.)
+   Note that these problems generally don't affect the native SVR4
+   C compiler because it doesn't allow the use of -O with -g and
+   because when it is *not* optimizing, it allocates a memory
+   location for each floating-point variable, and the memory
+   location is what gets described in the DWARF AT_location
+   attribute for the variable in question.
+   Regardless of the severe mental illness of the x86/svr4 SDB, we
+   do something sensible here and we use the following DWARF
+   register numbers.  Note that these are all stack-top-relative
+   numbers.
+	11 for %st(0) (gnu regno = 8)
+	12 for %st(1) (gnu regno = 9)
+	13 for %st(2) (gnu regno = 10)
+	14 for %st(3) (gnu regno = 11)
+	15 for %st(4) (gnu regno = 12)
+	16 for %st(5) (gnu regno = 13)
+	17 for %st(6) (gnu regno = 14)
+	18 for %st(7) (gnu regno = 15)
+*/
+#undef DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(n) \
+((n) == 0 ? 0 \
+ : (n) == 1 ? 2 \
+ : (n) == 2 ? 1 \
+ : (n) == 3 ? 3 \
+ : (n) == 4 ? 6 \
+ : (n) == 5 ? 7 \
+ : (n) == 6 ? 5 \
+ : (n) == 7 ? 4 \
+ : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \
+ : (-1))
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry.  */
+
+#undef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(FILE, LABELNO)  \
+{									\
+  if (flag_pic)								\
+    {									\
+      fprintf (FILE, "\tleal %sP%d@GOTOFF(%%ebx),%%edx\n",		\
+	       LPREFIX, (LABELNO));					\
+      fprintf (FILE, "\tcall *mcount@GOT(%%ebx)\n");			\
+    }									\
+  else									\
+    {									\
+      fprintf (FILE, "\tmovl $%sP%d,%%edx\n", LPREFIX, (LABELNO));	\
+      fprintf (FILE, "\tcall mcount\n");				\
+    }									\
+}
 
 #undef SIZE_TYPE
 #define SIZE_TYPE "unsigned int"
@@ -48,73 +147,90 @@
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE BITS_PER_WORD
 
-#undef HAVE_ATEXIT
-#define HAVE_ATEXIT
+#undef CPP_PREDEFINES
+#define CPP_PREDEFINES "-D__ELF__ -Dunix -Di386 -Dlinux -Asystem(unix) -Asystem(posix) -Acpu(i386) -Amachine(i386)"
 
-/* Linux uses ctype from glibc.a. I am not sure how complete it is.
- * For now, we play safe. It may change later.
- */
-#if 0
-#undef MULTIBYTE_CHARS
-#define MULTIBYTE_CHARS	1
+#undef CPP_SPEC
+#ifdef USE_GNULIBC_1
+#if TARGET_CPU_DEFAULT == 2
+#define CPP_SPEC "%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{!m386:-D__i486__} %{posix:-D_POSIX_SOURCE}"
+#else
+#define CPP_SPEC "%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{m486:-D__i486__} %{posix:-D_POSIX_SOURCE}"
 #endif
-
-#undef LIB_SPEC
-#define LIB_SPEC "%{mieee-fp:-lieee} %{p:-lgmon -lc_p} %{pg:-lgmon -lc_p} %{!p:%{!pg:%{!g*:-lc} %{g*:-lg}}}"
-
-
-#undef STARTFILE_SPEC
-#undef GPLUSPLUS_INCLUDE_DIR
-
-#ifdef CROSS_COMPILE
-
-/*
- * For cross-compile, we just need to search `$(tooldir)/lib'
+#else /* not USE_GNULIBC_1 */
+#define CPP_SPEC "%(cpp_cpu) %{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}"
+#endif /* not USE_GNULIBC_1 */
+
+#undef LIBGCC_SPEC
+#define LIBGCC_SPEC "-lgcc"
+
+#undef	LIB_SPEC
+#ifdef USE_GNULIBC_1
+#if 1
+/* We no longer link with libc_p.a or libg.a by default. If you
+ * want to profile or debug the Linux C library, please add
+ * -lc_p or -ggdb to LDFLAGS at the link time, respectively.
  */
-
-#define STARTFILE_SPEC  \
-  "%{pg:gcrt0.o%s -static} %{!pg:%{p:gcrt0.o%s -static} %{!p:crt0.o%s %{g*:-static} %{!static:%{nojump:-nojump}} %{static:-static}}} -L"TOOLDIR"/lib"
-
-/*
- *The cross-compile uses this.
- */
-#define GPLUSPLUS_INCLUDE_DIR TOOLDIR"/g++-include"
-
+#define LIB_SPEC \
+  "%{!shared: %{mieee-fp:-lieee} %{p:-lgmon} %{pg:-lgmon} \
+     %{!ggdb:-lc} %{ggdb:-lg}}"
 #else
-
-#define STARTFILE_SPEC  \
-  "%{pg:gcrt0.o%s -static} %{!pg:%{p:gcrt0.o%s -static} %{!p:crt0.o%s %{g*:-static}%{!static:%{nojump:-nojump}} %{static:-static}}}"
-
-/*
- *The native Linux system uses this.
- */
-#define GPLUSPLUS_INCLUDE_DIR "/usr/g++-include"
-
+#define LIB_SPEC \
+  "%{!shared: \
+     %{mieee-fp:-lieee} %{p:-lgmon -lc_p} %{pg:-lgmon -lc_p} \
+       %{!p:%{!pg:%{!g*:-lc} %{g*:-lg}}}}"
 #endif
-
-/* There are conflicting reports about whether this system uses
-   a different assembler syntax.  wilson@cygnus.com says # is right.  */
-#undef COMMENT_BEGIN
-#define COMMENT_BEGIN "#"
-
-#undef ASM_APP_ON
-#define ASM_APP_ON "#APP\n"
-
-#undef ASM_APP_OFF
-#define ASM_APP_OFF "#NO_APP\n"
-
-/* Don't default to pcc-struct-return, because gcc is the only compiler, and
-   we want to retain compatibility with older gcc versions.  */
-#define DEFAULT_PCC_STRUCT_RETURN 0
-
-/* We need that too. */
-#define HANDLE_SYSV_PRAGMA
-
-#undef LINK_SPEC
-
-/* We want to pass -v to linker */
-#if TARGET_CPU_DEFAULT == 2
-#define LINK_SPEC	"%{v:-dll-verbose} %{!m386:-m486}"
 #else
-#define LINK_SPEC	"%{v:-dll-verbose} %{m486:-m486}"
+#define LIB_SPEC \
+  "%{shared: -lc} \
+   %{!shared: %{mieee-fp:-lieee} %{pthread:-lpthread} \
+	%{profile:-lc_p} %{!profile: -lc}}"
+#endif /* not USE_GNULIBC_1 */
+
+/* Provide a LINK_SPEC appropriate for Linux.  Here we provide support
+   for the special GCC options -static and -shared, which allow us to
+   link things in one of these three modes by applying the appropriate
+   combinations of options at link-time. We like to support here for
+   as many of the other GNU linker options as possible. But I don't
+   have the time to search for those flags. I am sure how to add
+   support for -soname shared_object_name. H.J.
+
+   I took out %{v:%{!V:-V}}. It is too much :-(. They can use
+   -Wl,-V.
+
+   When the -shared link option is used a final link is not being
+   done.  */
+
+/* If ELF is the default format, we should not use /lib/elf. */
+
+#undef	LINK_SPEC
+#ifdef USE_GNULIBC_1
+#ifndef LINUX_DEFAULT_ELF
+#define LINK_SPEC "-m elf_i386 %{shared:-shared} \
+  %{!shared: \
+    %{!ibcs: \
+      %{!static: \
+	%{rdynamic:-export-dynamic} \
+	%{!dynamic-linker:-dynamic-linker /lib/elf/ld-linux.so.1} \
+	%{!rpath:-rpath /lib/elf/}} %{static:-static}}}"
+#else
+#define LINK_SPEC "-m elf_i386 %{shared:-shared} \
+  %{!shared: \
+    %{!ibcs: \
+      %{!static: \
+	%{rdynamic:-export-dynamic} \
+	%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.1}} \
+	%{static:-static}}}"
 #endif
+#else /* not USE_GNULIBC_1 */
+#define LINK_SPEC "-m elf_i386 %{shared:-shared} \
+  %{!shared: \
+    %{!ibcs: \
+      %{!static: \
+	%{rdynamic:-export-dynamic} \
+	%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \
+	%{static:-static}}}"
+#endif /* not USE_GNULIBC_1 */
+
+/* Get perform_* macros to build libgcc.a.  */
+#include "i386/perform.h"
diff --git a/config/i386/linuxelf.h b/config/i386/linuxelf.h
deleted file mode 100644
index cb27b7b..0000000
--- a/config/i386/linuxelf.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/* Definitions for Intel 386 running Linux with ELF format
-   Written by Eric Youngdale.  */
-
-/* A lie, I guess, but the general idea behind linux/ELF is that we are
-   supposed to be outputting something that will assemble under SVr4.
-   This gets us pretty close.  */
-#include "i386/i386.h"	/* Base i386 target machine definitions */
-#include "i386/att.h"	/* Use the i386 AT&T assembler syntax */
-#include "svr4.h"
-#undef MD_EXEC_PREFIX
-#undef MD_STARTFILE_PREFIX
-#undef TARGET_VERSION
-#define TARGET_VERSION fprintf (stderr, " (i386 Linux/ELF)");
-/* Output at beginning of assembler file.  */
-/* The .file command should always begin the output.  */
-#undef ASM_FILE_START
-#define ASM_FILE_START(FILE)						\
-  do {									\
-	output_file_directive (FILE, main_input_filename);		\
-	fprintf (FILE, "\t.version\t\"01.01\"\n");			\
-  } while (0)
-/* The svr4 ABI for the i386 says that records and unions are returned
-   in memory.  */
-#undef RETURN_IN_MEMORY
-#define RETURN_IN_MEMORY(TYPE) \
-  (TYPE_MODE (TYPE) == BLKmode)
-/* This is how to output an element of a case-vector that is relative.
-   This is only used for PIC code.  See comments by the `casesi' insn in
-   i386.md for an explanation of the expression this outputs. */
-#undef ASM_OUTPUT_ADDR_DIFF_ELT
-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \
-  fprintf (FILE, "\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\n", LPREFIX, VALUE)
-/* Indicate that jump tables go in the text section.  This is
-   necessary when compiling PIC code.  */
-#define JUMP_TABLES_IN_TEXT_SECTION
-/* Copy this from the svr4 specifications... */
-/* Define the register numbers to be used in Dwarf debugging information.
-   The SVR4 reference port C compiler uses the following register numbers
-   in its Dwarf output code:
-	0 for %eax (gnu regno = 0)
-	1 for %ecx (gnu regno = 2)
-	2 for %edx (gnu regno = 1)
-	3 for %ebx (gnu regno = 3)
-	4 for %esp (gnu regno = 7)
-	5 for %ebp (gnu regno = 6)
-	6 for %esi (gnu regno = 4)
-	7 for %edi (gnu regno = 5)
-   The following three DWARF register numbers are never generated by
-   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4
-   believes these numbers have these meanings.
-	8  for %eip    (no gnu equivalent)
-	9  for %eflags (no gnu equivalent)
-	10 for %trapno (no gnu equivalent)
-   It is not at all clear how we should number the FP stack registers
-   for the x86 architecture.  If the version of SDB on x86/svr4 were
-   a bit less brain dead with respect to floating-point then we would
-   have a precedent to follow with respect to DWARF register numbers
-   for x86 FP registers, but the SDB on x86/svr4 is so completely
-   broken with respect to FP registers that it is hardly worth thinking
-   of it as something to strive for compatibility with.
-   The verison of x86/svr4 SDB I have at the moment does (partially)
-   seem to believe that DWARF register number 11 is associated with
-   the x86 register %st(0), but that's about all.  Higher DWARF
-   register numbers don't seem to be associated with anything in
-   particular, and even for DWARF regno 11, SDB only seems to under-
-   stand that it should say that a variable lives in %st(0) (when
-   asked via an `=' command) if we said it was in DWARF regno 11,
-   but SDB still prints garbage when asked for the value of the
-   variable in question (via a `/' command).
-   (Also note that the labels SDB prints for various FP stack regs
-   when doing an `x' command are all wrong.)
-   Note that these problems generally don't affect the native SVR4
-   C compiler because it doesn't allow the use of -O with -g and
-   because when it is *not* optimizing, it allocates a memory
-   location for each floating-point variable, and the memory
-   location is what gets described in the DWARF AT_location
-   attribute for the variable in question.
-   Regardless of the severe mental illness of the x86/svr4 SDB, we
-   do something sensible here and we use the following DWARF
-   register numbers.  Note that these are all stack-top-relative
-   numbers.
-	11 for %st(0) (gnu regno = 8)
-	12 for %st(1) (gnu regno = 9)
-	13 for %st(2) (gnu regno = 10)
-	14 for %st(3) (gnu regno = 11)
-	15 for %st(4) (gnu regno = 12)
-	16 for %st(5) (gnu regno = 13)
-	17 for %st(6) (gnu regno = 14)
-	18 for %st(7) (gnu regno = 15)
-*/
-#undef DBX_REGISTER_NUMBER
-#define DBX_REGISTER_NUMBER(n) \
-((n) == 0 ? 0 \
- : (n) == 1 ? 2 \
- : (n) == 2 ? 1 \
- : (n) == 3 ? 3 \
- : (n) == 4 ? 6 \
- : (n) == 5 ? 7 \
- : (n) == 6 ? 5 \
- : (n) == 7 ? 4 \
- : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \
- : (-1))
-#define LINUX_ELF
-#include "i386/linux.h"
-
-#undef YES_UNDERSCORE
-#undef DBX_DEBUGGING_INFO
-#define DWARF_DEBUGGING_INFO
diff --git a/config/i386/xm-linux.h b/config/i386/xm-linux.h
index 89d4aaa..42f097d 100644
--- a/config/i386/xm-linux.h
+++ b/config/i386/xm-linux.h
@@ -1,23 +1,24 @@
 /* Configuration for GCC for Intel i386 running Linux.
- *
- * Written by H.J. Lu (hlu@eecs.wsu.edu)
- */
+   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.
+   Contributed by H.J. Lu (hjl@nynexst.com)
 
-#include "i386/xm-i386.h"
-#include "xm-svr3.h"
+This file is part of GNU CC.
 
-#undef BSTRING
-#define BSTRING
-#undef bcmp
-#undef bcopy
-#undef bzero
-#undef index
-#undef rindex
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include <i386/xm-i386.h>
+#include <xm-linux.h>
 
-#if 0 /* These conflict with stdlib.h in protoize, it is said,
-	 and there's no evidence they are actually needed.  */
-#undef malloc(n)
-#define malloc(n)	malloc ((n) ? (n) : 1)
-#undef calloc(n,e)
-#define calloc(n,e)	calloc (((n) ? (n) : 1), ((e) ? (e) : 1))
-#endif
diff --git a/config/linux-aout.h b/config/linux-aout.h
new file mode 100644
index 0000000..29fb8e9
--- /dev/null
+++ b/config/linux-aout.h
@@ -0,0 +1,51 @@
+/* Definitions for Linux
+   Copyright (C) 1995 Free Software Foundation, Inc.
+   Contributed by H.J. Lu (hjl@nynexst.com)
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Don't assume anything about the header files. */
+#define NO_IMPLICIT_EXTERN_C
+
+#undef HAVE_ATEXIT
+#define HAVE_ATEXIT
+
+/* Linux uses ctype from glibc.a. I am not sure how complete it is.
+   For now, we play safe. It may change later. */
+
+#if 0
+#undef MULTIBYTE_CHARS
+#define MULTIBYTE_CHARS	1
+#endif
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC  "%{pg:gcrt0.o%s} %{!pg:%{p:gcrt0.o%s} %{!p:crt0.o%s}} %{static:-static}"
+
+/* There are conflicting reports about whether this system uses
+   a different assembler syntax.  wilson@cygnus.com says # is right.  */
+#undef COMMENT_BEGIN
+#define COMMENT_BEGIN "#"
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+/* We need that too. */
+#define HANDLE_SYSV_PRAGMA
diff --git a/config/linux.h b/config/linux.h
new file mode 100644
index 0000000..c82cfe2
--- /dev/null
+++ b/config/linux.h
@@ -0,0 +1,88 @@
+/* Definitions for Linux with ELF format
+   Copyright (C) 1995 Free Software Foundation, Inc.
+   Contributed by Eric Youngdale.
+   Modified for stabs-in-ELF by H.J. Lu.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Don't assume anything about the header files. */
+#define NO_IMPLICIT_EXTERN_C
+
+#undef HAVE_ATEXIT
+#define HAVE_ATEXIT
+
+/* Linux uses ctype from glibc.a. I am not sure how complete it is.
+   For now, we play safe. It may change later. */
+
+#if 0
+#undef MULTIBYTE_CHARS
+#define MULTIBYTE_CHARS 1
+#endif
+
+/* There are conflicting reports about whether this system uses
+   a different assembler syntax.  wilson@cygnus.com says # is right.  */
+#undef COMMENT_BEGIN
+#define COMMENT_BEGIN "#"
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+/* Use stabs instead of DWARF debug format.  */
+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG
+#include "svr4.h"
+
+#undef MD_EXEC_PREFIX
+#undef MD_STARTFILE_PREFIX
+
+/* Output at beginning of assembler file.  */
+/* The .file command should always begin the output.  */
+#undef ASM_FILE_START
+#define ASM_FILE_START(FILE)						\
+  do {									\
+	output_file_directive (FILE, main_input_filename);		\
+	fprintf (FILE, "\t.version\t\"01.01\"\n");			\
+  } while (0)
+
+#undef	LIBGCC_SPEC
+#define LIBGCC_SPEC \
+  "%{!shared:-lgcc}"
+
+
+/* Provide a STARTFILE_SPEC appropriate for Linux.  Here we add
+   the Linux magical crtbegin.o file (see crtstuff.c) which
+   provides part of the support for getting C++ file-scope static
+   object constructed before entering `main'. */
+   
+#undef	STARTFILE_SPEC
+#define STARTFILE_SPEC \
+  "%{!shared: \
+     %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}}\
+   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+
+/* Provide a ENDFILE_SPEC appropriate for Linux.  Here we tack on
+   the Linux magical crtend.o file (see crtstuff.c) which
+   provides part of the support for getting C++ file-scope static
+   object constructed before entering `main', followed by a normal
+   Linux "finalizer" file, `crtn.o'.  */
+
+#undef	ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s"
diff --git a/config/svr4.h b/config/svr4.h
index e895751..96ce9a3 100644
--- a/config/svr4.h
+++ b/config/svr4.h
@@ -1,8 +1,7 @@
-/* svr4.h  --  operating system specific defines to be used when
-   targeting GCC for some generic System V Release 4 system.
-   Copyright (C) 1991 Free Software Foundation, Inc.
-
-   Written by Ron Guilmette (rfg@ncd.com).
+/* Operating system specific defines to be used when targeting GCC for some
+   generic System V Release 4 system.
+   Copyright (C) 1991, 1994, 1995 Free Software Foundation, Inc.
+   Contributed by Ron Guilmette (rfg@segfault.us.com).
 
 This file is part of GNU CC.
 
@@ -18,7 +17,8 @@ GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with GNU CC; see the file COPYING.  If not, write to
-the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
 
    To use this file, make up a file with a name like:
 
@@ -123,17 +123,25 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 #define MD_STARTFILE_PREFIX "/usr/ccs/lib/"
 
 /* Provide a LIB_SPEC appropriate for svr4.  Here we tack on the default
-   standard C library (unless we are building a shared library) followed by
-   our own magical crtend.o file (see crtstuff.c) which provides part of
-   the support for getting C++ file-scope static object constructed before
+   standard C library (unless we are building a shared library).  */
+
+#undef	LIB_SPEC
+#define LIB_SPEC "%{!shared:%{!symbolic:-lc}}"
+
+/* Provide a LIBGCC_SPEC appropriate for svr4.  We also want to exclude
+   libgcc when -symbolic.  */
+
+#undef  LIBGCC_SPEC
+#define LIBGCC_SPEC "%{!shared:%{!symbolic:-lgcc}}"
+
+/* Provide an ENDFILE_SPEC appropriate for svr4.  Here we tack on our own
+   magical crtend.o file (see crtstuff.c) which provides part of the
+   support for getting C++ file-scope static object constructed before
    entering `main', followed by the normal svr3/svr4 "finalizer" file,
    which is either `gcrtn.o' or `crtn.o'.  */
 
-#undef	LIB_SPEC
-#define LIB_SPEC \
-  "%{!shared:%{!symbolic:-lc}} \
-  crtend.o%s \
-  %{!shared:%{!symbolic:%{pg:gcrtn.o}%{!pg:crtn.o%s}}}"
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "crtend.o%s %{pg:gcrtn.o}%{!pg:crtn.o%s}"
 
 /* Provide a LINK_SPEC appropriate for svr4.  Here we provide support
    for the special GCC options -static, -shared, and -symbolic which
@@ -162,8 +170,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 #define LINK_SPEC "%{h*} %{V} %{v:%{!V:-V}} \
 		   %{b} %{Wl,*:%*} \
 		   %{static:-dn -Bstatic} \
-		   %{shared:-G -dy} \
-		   %{symbolic:-Bsymbolic -G -dy} \
+		   %{shared:-G -dy -z text %{!h*:%{o*:-h %*}}} \
+		   %{symbolic:-Bsymbolic -G -dy -z text %{!h*:%{o*:-h %*}}} \
 		   %{G:-G} \
 		   %{YP,*} \
 		   %{!YP,*:%{p:-Y P,/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \
@@ -185,12 +193,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 #undef	STARTFILE_SPEC
 #define STARTFILE_SPEC "%{!shared: \
 			 %{!symbolic: \
-			  %{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}} \
-			  %{pg:gcrti.o%s}%{!pg:crti.o%s} \
-			  %{ansi:values-Xc.o%s} \
-			  %{!ansi: \
-			   %{traditional:values-Xt.o%s} \
-			   %{!traditional:values-Xa.o%s}}}} crtbegin.o%s"
+			  %{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}}}}\
+			%{pg:gcrti.o%s}%{!pg:crti.o%s} \
+			%{ansi:values-Xc.o%s} \
+			%{!ansi: \
+			 %{traditional:values-Xt.o%s} \
+			 %{!traditional:values-Xa.o%s}} \
+ 			crtbegin.o%s"
 
 /* Attach a special .ident directive to the end of the file to identify
    the version of GCC which compiled this code.  The format of the
@@ -245,6 +254,75 @@ do {				 				\
 
 #undef DBX_REGISTER_NUMBER
 
+/* gas on SVR4 supports the use of .stabs.  Permit -gstabs to be used
+   in general, although it will only work when using gas.  */
+
+#define DBX_DEBUGGING_INFO
+
+/* Use DWARF debugging info by default.  */
+
+#ifndef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG
+#endif
+
+/* Make LBRAC and RBRAC addresses relative to the start of the
+   function.  The native Solaris stabs debugging format works this
+   way, gdb expects it, and it reduces the number of relocation
+   entries.  */
+
+#define DBX_BLOCKS_FUNCTION_RELATIVE 1
+
+/* When using stabs, gcc2_compiled must be a stabs entry, not an
+   ordinary symbol, or gdb won't see it.  Furthermore, since gdb reads
+   the input piecemeal, starting with each N_SO, it's a lot easier if
+   the gcc2 flag symbol is *after* the N_SO rather than before it.  So
+   we emit an N_OPT stab there.  */
+
+#define ASM_IDENTIFY_GCC(FILE)						\
+do									\
+  {									\
+    if (write_symbols != DBX_DEBUG)					\
+      fputs ("gcc2_compiled.:\n", FILE);				\
+  }									\
+while (0)
+
+#define ASM_IDENTIFY_GCC_AFTER_SOURCE(FILE)				\
+do									\
+  {									\
+    if (write_symbols == DBX_DEBUG)					\
+      fputs ("\t.stabs\t\"gcc2_compiled.\", 0x3c, 0, 0, 0\n", FILE);	\
+  }									\
+while (0)
+
+/* Like block addresses, stabs line numbers are relative to the
+   current function.  */
+
+#define ASM_OUTPUT_SOURCE_LINE(file, line)				\
+do									\
+  {									\
+    static int sym_lineno = 1;						\
+    fprintf (file, ".stabn 68,0,%d,.LM%d-",				\
+	     line, sym_lineno);						\
+    assemble_name (file,						\
+		   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\
+    fprintf (file, "\n.LM%d:\n", sym_lineno);				\
+    sym_lineno += 1;							\
+  }									\
+while (0)
+
+/* In order for relative line numbers to work, we must output the
+   stabs entry for the function name first.  */
+
+#define DBX_FUNCTION_FIRST
+
+/* Generate a blank trailing N_SO to mark the end of the .o file, since
+   we can't depend upon the linker to mark .o file boundaries with
+   embedded stabs.  */
+
+#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)			\
+  fprintf (FILE,							\
+	   "\t.text\n\t.stabs \"\",%d,0,0,.Letext\n.Letext:\n", N_SO)
+
 /* Define the actual types of some ANSI-mandated types.  (These
    definitions should work for most SVR4 systems).  */
 
@@ -409,16 +487,33 @@ do {									\
 #define USE_CONST_SECTION	1
 
 #define CONST_SECTION_ASM_OP	".section\t.rodata"
-#define CTORS_SECTION_ASM_OP	".section\t.ctors,\"a\",@progbits"
-#define DTORS_SECTION_ASM_OP	".section\t.dtors,\"a\",@progbits"
 
-/* On svr4, we *do* have support for the .init section, and we can put
-   stuff in there to be executed before `main'.  We let crtstuff.c and
-   other files know this by defining the following symbol.  The definition
-   says how to change sections to the .init section.  This is the same
-   for all know svr4 assemblers.  */
+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.
+
+   Note that we want to give these sections the SHF_WRITE attribute
+   because these sections will actually contain data (i.e. tables of
+   addresses of functions in the current root executable or shared library
+   file) and, in the case of a shared library, the relocatable addresses
+   will have to be properly resolved/relocated (and then written into) by
+   the dynamic linker when it actually attaches the given shared library
+   to the executing process.  (Note that on SVR4, you may wish to use the
+   `-z text' option to the ELF linker, when building a shared library, as
+   an additional check that you are doing everything right.  But if you do
+   use the `-z text' option when building a shared library, you will get
+   errors unless the .ctors and .dtors sections are marked as writable
+   via the SHF_WRITE attribute.)  */
+
+#define CTORS_SECTION_ASM_OP	".section\t.ctors,\"aw\""
+#define DTORS_SECTION_ASM_OP	".section\t.dtors,\"aw\""
+
+/* On svr4, we *do* have support for the .init and .fini sections, and we
+   can put stuff in there to be executed before and after `main'.  We let
+   crtstuff.c and other files know this by defining the following symbols.
+   The definitions say how to change sections to the .init and .fini
+   sections.  This is the same for all known svr4 assemblers.  */
 
 #define INIT_SECTION_ASM_OP	".section\t.init"
+#define FINI_SECTION_ASM_OP	".section\t.fini"
 
 /* A default list of other sections which we might be "in" at any given
    time.  For targets that use additional sections (e.g. .tdesc) you
@@ -514,7 +609,10 @@ dtors_section ()							\
   else if (TREE_CODE (DECL) == VAR_DECL)				\
     {									\
       if ((flag_pic && RELOC)						\
-	  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL))		\
+	  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)		\
+	  || !DECL_INITIAL (DECL)					\
+	  || (DECL_INITIAL (DECL) != error_mark_node			\
+	      && !TREE_CONSTANT (DECL_INITIAL (DECL))))			\
 	data_section ();						\
       else								\
 	const_section ();						\
@@ -540,7 +638,12 @@ dtors_section ()							\
 
 #define TYPE_ASM_OP	".type"
 #define SIZE_ASM_OP	".size"
-#define WEAK_ASM_OP	".weak"
+
+/* This is how we tell the assembler that a symbol is weak.  */
+
+#define ASM_WEAKEN_LABEL(FILE,NAME) \
+  do { fputs ("\t.weak\t", FILE); assemble_name (FILE, NAME); \
+       fputc ('\n', FILE); } while (0)
 
 /* The following macro defines the format used to output the second
    operand of the .type assembler directive.  Different svr4 assemblers
@@ -612,6 +715,7 @@ do {									 \
 	 && DECL_INITIAL (DECL) == error_mark_node			 \
 	 && !size_directive_output)					 \
        {								 \
+	 size_directive_output = 1;					 \
 	 fprintf (FILE, "\t%s\t ", SIZE_ASM_OP);			 \
 	 assemble_name (FILE, name);					 \
 	 fprintf (FILE, ",%d\n",  int_size_in_bytes (TREE_TYPE (DECL))); \
@@ -650,10 +754,11 @@ do {									 \
    in the table.  Note that we can use standard UN*X escape
    sequences for many control characters, but we don't use
    \a to represent BEL because some svr4 assemblers (e.g. on
-   the i386) don't know about that.   */
+   the i386) don't know about that.  Also, we don't use \v
+   since some versions of gas, such as 2.2 did not accept it.  */
 
 #define ESCAPES \
-"\1\1\1\1\1\1\1\1btnvfr\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+"\1\1\1\1\1\1\1\1btn\1fr\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
 \0\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\0\0\
 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\
@@ -774,3 +879,6 @@ do {									 \
         fprintf ((FILE), "\"\n");					\
     }									\
   while (0)
+
+/* All SVR4 targets use the ELF object file format.  */
+#define OBJECT_FORMAT_ELF
diff --git a/config/t-linux b/config/t-linux
new file mode 100644
index 0000000..843fa1b
--- /dev/null
+++ b/config/t-linux
@@ -0,0 +1,10 @@
+# Don't run fixproto
+STMP_FIXPROTO =
+
+# Don't install "assert.h" in gcc. We use the one in glibc.
+INSTALL_ASSERT_H =
+
+# Compile crtbeginS.o and crtendS.o with pic.
+CRTSTUFF_T_CFLAGS_S = -fPIC
+# Compile libgcc2.a with pic.
+TARGET_LIBGCC2_CFLAGS = -fPIC
diff --git a/config/xm-linux.h b/config/xm-linux.h
new file mode 100644
index 0000000..a842299
--- /dev/null
+++ b/config/xm-linux.h
@@ -0,0 +1,42 @@
+/* Configuration for GCC for Intel i386 running Linux.
+   Copyright (C) 1995 Free Software Foundation, Inc.
+   Contributed by H.J. Lu (hjl@nynexst.com)
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#define HAVE_VPRINTF
+
+#define HAVE_STRERROR
+
+#ifndef POSIX
+#define POSIX
+#endif
+
+#define DONT_DECLARE_SYS_SIGLIST
+
+/* We do have one, but I'd like to use the one come with gcc since
+   we have been doing that for a long time with USG defined.  H.J. */
+#define NO_STAB_H
+
+#undef BSTRING
+#define BSTRING
+#undef bcmp
+#undef bcopy
+#undef bzero
+#undef index
+#undef rindex
diff --git a/configure b/configure
index 64a8cc3..a74b77b 100755
--- a/configure
+++ b/configure
@@ -293,6 +293,7 @@ for machine in $canon_build $canon_host $canon_target; do
 	tmake_file=
 	header_files=
 	extra_passes=
+	extra_parts=
 	# Set this to force installation and use of collect2.
 	use_collect2=
 	# Set this to override the default target model.
@@ -480,15 +481,17 @@ for machine in $canon_build $canon_host $canon_target; do
 		tm_file=i386/sun.h
 		use_collect2=yes
 		;;
-	i[34]86-*-linux*)               # Intel 80386's running Linux
+	i[3456]86-*-linux*)             # Intel 80386's running Linux
 		cpu_type=i386
 		xm_file=i386/xm-linux.h
 		xmake_file=i386/x-linux
                 if [ x$elf = xyes ]
 		then
-			tm_file=i386/linuxelf.h
-		else
 			tm_file=i386/linux.h
+			tmake_file=t-linux
+			extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
+		else
+			tm_file=i386/linux-aout.h
 		fi
 		fixincludes=Makefile.in #On Linux, the headers are ok already.
 		broken_install=yes
@@ -1791,6 +1794,17 @@ else
 	mv Makefile.xx Makefile.tem
 fi
 
+# Set EXTRA_PARTS according to extra_parts.
+# This substitutes for lots of t-* files.
+if [ "x$extra_parts" = x ]
+then true
+else
+	rm -f Makefile.xx
+	sed "s/^EXTRA_PARTS =/EXTRA_PARTS = $extra_parts/" Makefile.tem > Makefile.xx
+	rm -f Makefile.tem
+	mv Makefile.xx Makefile.tem
+fi
+
 # Add a definition of USE_COLLECT2 if system wants one.
 # Also tell toplev.c what to do.
 # This substitutes for lots of t-* files.
diff --git a/crtstuff.c b/crtstuff.c
index a0ecbbe..b795a72 100644
--- a/crtstuff.c
+++ b/crtstuff.c
@@ -1,9 +1,9 @@
 /* Specialized bits of code needed to support construction and
    destruction of file-scope objects in C++ code.
 
-   Written by Ron Guilmette (rfg@ncd.com) with help from Richard Stallman.
+   Written by Ron Guilmette (rfg@netcom.com) with help from Richard Stallman.
 
-Copyright (C) 1991 Free Software Foundation, Inc.
+Copyright (C) 1991, 1994, 1995 Free Software Foundation, Inc.
 
 This file is part of GNU CC.
 
@@ -19,7 +19,8 @@ GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with GNU CC; see the file COPYING.  If not, write to
-the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
 
 /* As a special exception, if you link this library with files
    compiled with GCC to produce an executable, this does not cause
@@ -54,23 +55,120 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 #include "tm.h"
 
+/* Provide default definitions for the pseudo-ops used to switch to the
+   .ctors and .dtors sections.
+ 
+   Note that we want to give these sections the SHF_WRITE attribute
+   because these sections will actually contain data (i.e. tables of
+   addresses of functions in the current root executable or shared library
+   file) and, in the case of a shared library, the relocatable addresses
+   will have to be properly resolved/relocated (and then written into) by
+   the dynamic linker when it actually attaches the given shared library
+   to the executing process.  (Note that on SVR4, you may wish to use the
+   `-z text' option to the ELF linker, when building a shared library, as
+   an additional check that you are doing everything right.  But if you do
+   use the `-z text' option when building a shared library, you will get
+   errors unless the .ctors and .dtors sections are marked as writable
+   via the SHF_WRITE attribute.)  */
+
 #ifndef CTORS_SECTION_ASM_OP
-#define CTORS_SECTION_ASM_OP	".section\t.ctors,\"a\",@progbits"
+#define CTORS_SECTION_ASM_OP	".section\t.ctors,\"aw\""
 #endif
 #ifndef DTORS_SECTION_ASM_OP
-#define DTORS_SECTION_ASM_OP	".section\t.dtors,\"a\",@progbits"
+#define DTORS_SECTION_ASM_OP	".section\t.dtors,\"aw\""
 #endif
 
+#ifdef OBJECT_FORMAT_ELF
+
+/*  Declare a pointer to void function type.  */
+typedef void (*func_ptr) (void);
+#define STATIC static
+
+#else  /* OBJECT_FORMAT_ELF */
+
 #include "gbl-ctors.h"
 
 #ifndef ON_EXIT
 #define ON_EXIT(a, b)
 #endif
+#define STATIC
+
+#endif /* OBJECT_FORMAT_ELF */
 
 #ifdef CRT_BEGIN
 
 #ifdef INIT_SECTION_ASM_OP
 
+#ifdef OBJECT_FORMAT_ELF
+
+/* Declare the __dso_handle variable.  It should have a unique value
+   in every shared-object; in a main program its value is zero.  The
+   object should in any case be protected.  This means the instance
+   in one DSO or the main program is not used in another object.  The
+   dynamic linker takes care of this.  */
+
+/* XXX Ideally the following should be implemented using
+   __attribute__ ((__visibility__ ("hidden")))
+   but the __attribute__ support is not yet there.  */
+#define HAVE_GAS_HIDDEN 1
+#ifdef HAVE_GAS_HIDDEN
+asm (".hidden\t__dso_handle");
+#endif
+
+#ifdef CRTSTUFFS_O
+void *__dso_handle = &__dso_handle;
+#else
+void *__dso_handle = 0;
+#endif
+
+/* The __cxa_finalize function may not be available so we use only a
+   weak declaration.  */
+extern void __cxa_finalize (void *);
+
+/* Run all the global destructors on exit from the program.  */
+/* Run all the global destructors on exit from the program.  */
+ 
+/* Some systems place the number of pointers in the first word of the
+   table.  On SVR4 however, that word is -1.  In all cases, the table is
+   null-terminated.  On SVR4, we start from the beginning of the list and
+   invoke each per-compilation-unit destructor routine in order
+   until we find that null.
+
+   Note that this function MUST be static.  There will be one of these
+   functions in each root executable and one in each shared library, but
+   although they all have the same code, each one is unique in that it
+   refers to one particular associated `__DTOR_LIST__' which belongs to the
+   same particular root executable or shared library file.  */
+
+static func_ptr __DTOR_LIST__[];
+static void
+__do_global_dtors_aux ()
+{
+  func_ptr *p;
+
+#ifdef CRTSTUFFS_O
+  if (__cxa_finalize)
+    __cxa_finalize (__dso_handle);
+#endif
+
+  for (p = __DTOR_LIST__ + 1; *p; p++)
+    (*p) ();
+}
+
+/* Stick a call to __do_global_dtors_aux into the .fini section.  */
+static void
+fini_dummy ()
+{
+  asm (FINI_SECTION_ASM_OP);
+  __do_global_dtors_aux ();
+#ifdef FORCE_FINI_SECTION_ALIGN
+  FORCE_FINI_SECTION_ALIGN;
+#endif
+  asm (TEXT_SECTION_ASM_OP);
+}
+
+#else  /* OBJECT_FORMAT_ELF */
+
 /* The function __do_global_ctors_aux is compiled twice (once in crtbegin.o
    and once in crtend.o).  It must be declared static to avoid a link
    error.  Here, we define __do_global_ctors as an externally callable
@@ -92,12 +190,12 @@ void __do_global_ctors ()
 
 asm (INIT_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
 
-/* On some svr4 systems, the .init section preamble code provided in
-   crti.o may do some evil things which we have to undo before we reach
-   the function prologue code for __do_global_ctors (directly below).
-   For such systems, define the macro INIT_SECTION_PREAMBLE to
-   expand into the code needed to undo the actions of the crti.o file.  */
-   
+/* On some svr4 systems, the initial .init section preamble code provided in
+   crti.o may do something, such as bump the stack, which we have to 
+   undo before we reach the function prologue code for __do_global_ctors 
+   (directly below).  For such systems, define the macro INIT_SECTION_PREAMBLE
+   to expand into the code needed to undo the actions of the crti.o file. */
+
 #ifdef INIT_SECTION_PREAMBLE
   INIT_SECTION_PREAMBLE;
 #endif
@@ -118,25 +216,38 @@ __do_global_ctors_aux ()	/* prologue goes in .init section */
   ON_EXIT (__do_global_dtors, 0);
 }
 
+#endif /* OBJECT_FORMAT_ELF */
 #endif /* defined(INIT_SECTION_ASM_OP) */
 
 /* Force cc1 to switch to .data section.  */
 static func_ptr force_to_data[0] = { };
 
+/* NOTE:  In order to be able to support SVR4 shared libraries, we arrange
+   to have one set of symbols { __CTOR_LIST__, __DTOR_LIST__, __CTOR_END__,
+   __DTOR_END__ } per root executable and also one set of these symbols
+   per shared library.  So in any given whole process image, we may have
+   multiple definitions of each of these symbols.  In order to prevent
+   these definitions from conflicting with one another, and in order to
+   ensure that the proper lists are used for the initialization/finalization
+   of each individual shared library (respectively), we give these symbols
+   only internal (i.e. `static') linkage, and we also make it a point to
+   refer to only the __CTOR_END__ symbol in crtend.o and the __DTOR_LIST__
+   symbol in crtbegin.o, where they are defined.  */
+
 /* The -1 is a flag to __do_global_[cd]tors
    indicating that this table does not start with a count of elements.  */
 #ifdef CTOR_LIST_BEGIN
 CTOR_LIST_BEGIN;
 #else
 asm (CTORS_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
-func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) };
+STATIC func_ptr __CTOR_LIST__[1] = { (func_ptr) (-1) };
 #endif
 
 #ifdef DTOR_LIST_BEGIN
 DTOR_LIST_BEGIN;
 #else
 asm (DTORS_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
-func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) };
+STATIC func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) };
 #endif
 
 #endif /* defined(CRT_BEGIN) */
@@ -145,17 +256,66 @@ func_ptr __DTOR_LIST__[1] = { (func_ptr) (-1) };
 
 #ifdef INIT_SECTION_ASM_OP
 
-/* A routine to invoke all of the global constructors upon entry to the
-   program.  We put this into the .init section (for systems that have
-   such a thing) so that we can properly perform the construction of
-   file-scope static-storage C++ objects within shared libraries.
+#ifdef OBJECT_FORMAT_ELF
+
+static func_ptr __CTOR_END__[];
+static void
+__do_global_ctors_aux ()
+{
+  func_ptr *p;
+  for (p = __CTOR_END__ - 1; *p != (func_ptr) -1; p--)
+    (*p) ();
+}
+
+/* Stick a call to __do_global_ctors_aux into the .init section.  */
+static void
+init_dummy ()
+{
+  asm (INIT_SECTION_ASM_OP);
+  __do_global_ctors_aux ();
+#ifdef FORCE_INIT_SECTION_ALIGN
+  FORCE_INIT_SECTION_ALIGN;
+#endif
+  asm (TEXT_SECTION_ASM_OP);
+
+/* This is a kludge. The Linux dynamic linker needs  ___brk_addr, __environ
+   and atexit (). We have to make sure they are in the .dynsym section. We
+   accomplish it by making a dummy call here. This
+   code is never reached. */
+ 
+#if defined(__linux__) && defined(__PIC__)
+  {
+    extern void *___brk_addr;
+    extern char **__environ;
+
+    ___brk_addr = __environ;
+    atexit ();
+  }
+#endif
+}
 
-   This must be virtually identical to the one above so that we can
-   insure that the function prologue from the one above works correctly
-   with the epilogue from this one.  (They will both go into the .init
-   section as the first and last things (respectively) that the linker
-   will put in that section.)
-*/
+#else  /* OBJECT_FORMAT_ELF */
+
+/* Stick the real initialization code, followed by a normal sort of
+   function epilogue at the very end of the .init section for this
+   entire root executable file or for this entire shared library file.
+
+   Note that we use some tricks here to get *just* the body and just
+   a function epilogue (but no function prologue) into the .init
+   section of the crtend.o file.  Specifically, we switch to the .text
+   section, start to define a function, and then we switch to the .init
+   section just before the body code.
+
+   Earlier on, we put the corresponding function prologue into the .init
+   section of the crtbegin.o file (which will be linked in first).
+
+   Note that we want to invoke all constructors for C++ file-scope static-
+   storage objects AFTER any other possible initialization actions which
+   may be performed by the code in the .init section contributions made by
+   other libraries, etc.  That's because those other initializations may
+   include setup operations for very primitive things (e.g. initializing
+   the state of the floating-point coprocessor, etc.) which should be done
+   before we start to execute any of the user's code. */
 
 static void
 __do_global_ctors_aux ()	/* prologue goes in .text section */
@@ -165,23 +325,31 @@ __do_global_ctors_aux ()	/* prologue goes in .text section */
   ON_EXIT (__do_global_dtors, 0);
 }				/* epilogue and body go in .init section */
 
+#endif /* OBJECT_FORMAT_ELF */
+
 #endif /* defined(INIT_SECTION_ASM_OP) */
 
 /* Force cc1 to switch to .data section.  */
 static func_ptr force_to_data[0] = { };
 
+/* Put a word containing zero at the end of each of our two lists of function
+   addresses.  Note that the words defined here go into the .ctors and .dtors
+   sections of the crtend.o file, and since that file is always linked in
+   last, these words naturally end up at the very ends of the two lists
+   contained in these two sections.  */
+
 #ifdef CTOR_LIST_END
 CTOR_LIST_END;
 #else
 asm (CTORS_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
-func_ptr __CTOR_END__[1] = { (func_ptr) 0 };
+STATIC func_ptr __CTOR_END__[1] = { (func_ptr) 0 };
 #endif
 
 #ifdef DTOR_LIST_END
 DTOR_LIST_END;
 #else
 asm (DTORS_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
-func_ptr __DTOR_END__[1] = { (func_ptr) 0 };
+STATIC func_ptr __DTOR_END__[1] = { (func_ptr) 0 };
 #endif
 
 #endif /* defined(CRT_END) */
diff --git a/emit-rtl.c b/emit-rtl.c
index 1270521..fff05b2 100644
--- a/emit-rtl.c
+++ b/emit-rtl.c
@@ -34,7 +34,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
    is the kind of rtx's they make and what arguments they use.  */
 
 #include "config.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
 #include "rtl.h"
 #include "tree.h"
 #include "flags.h"
@@ -277,19 +281,23 @@ extern int max_stack_depth;
 
 /*VARARGS2*/
 rtx
-gen_rtx (va_alist)
-     va_dcl
+gen_rtx VPROTO((enum rtx_code code, enum machine_mode mode, ...))
 {
-  va_list p;
+#ifndef __STDC__
   enum rtx_code code;
   enum machine_mode mode;
+#endif
+  va_list p;
   register int i;		/* Array indices...			*/
   register char *fmt;		/* Current rtx's format...		*/
   register rtx rt_val;		/* RTX to return to caller...		*/
 
-  va_start (p);
+  VA_START (p, mode);
+
+#ifndef __STDC__
   code = va_arg (p, enum rtx_code);
   mode = va_arg (p, enum machine_mode);
+#endif
 
   if (code == CONST_INT)
     {
@@ -397,15 +405,20 @@ gen_rtx (va_alist)
 
 /*VARARGS1*/
 rtvec
-gen_rtvec (va_alist)
-     va_dcl
+gen_rtvec VPROTO((int n, ...))
 {
-  int n, i;
+#ifndef __STDC__
+  int n;
+#endif
+  int i;
   va_list p;
   rtx *vector;
 
-  va_start (p);
+  VA_START (p, n);
+
+#ifndef __STDC__
   n = va_arg (p, int);
+#endif
 
   if (n == 0)
     return NULL_RTVEC;		/* Don't allocate an empty rtvec...	*/
diff --git a/expr.h b/expr.h
index 1b65867..7b71a18 100644
--- a/expr.h
+++ b/expr.h
@@ -625,8 +625,10 @@ extern void emit_push_insn PROTO((rtx, enum machine_mode, tree, rtx, int,
 
 /* Emit library call.  These cannot have accurate prototypes since they have
    a variable number of args.  */
-extern void emit_library_call ();
-extern rtx emit_library_call_value ();
+extern void emit_library_call PVPROTO((rtx orgfun, int no_queue,
+  enum machine_mode outmode, int nargs, ...));
+extern rtx emit_library_call_value PVPROTO((rtx orgfun, rtx value, int no_queue,
+  enum machine_mode outmode, int nargs, ...));
 
 /* Expand an assignment that stores the value of FROM into TO. */
 extern rtx expand_assignment PROTO((tree, tree, int, int));
diff --git a/final.c b/final.c
index c7a1580..26d6583 100644
--- a/final.c
+++ b/final.c
@@ -44,7 +44,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
    FUNCTION_EPILOGUE.  Those instructions never exist as rtl.  */
 
 #include "config.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
+#include <stdio.h>
+#include <ctype.h>
 #include "tree.h"
 #include "rtl.h"
 #include "regs.h"
@@ -59,9 +65,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include "hard-reg-set.h"
 #include "defaults.h"
 
-#include <stdio.h>
-#include <ctype.h>
-
 #include "output.h"
 
 /* Get N_SLINE and N_SOL from stab.h if we can expect the file to exist.  */
@@ -2679,19 +2682,24 @@ output_addr_const (file, x)
    We handle alternate assembler dialects here, just like output_asm_insn.  */
 
 void
-asm_fprintf (va_alist)
-     va_dcl
+asm_fprintf VPROTO((FILE *file, char *p, ...))
 {
-  va_list argptr;
+#ifndef __STDC__
   FILE *file;
+  char *p;
+#endif
+  va_list argptr;
   char buf[10];
-  char *p, *q, c;
+  char *q, c;
   int i;
 
-  va_start (argptr);
+  VA_START (argptr, p);
 
+#ifndef __STDC__
   file = va_arg (argptr, FILE *);
   p = va_arg (argptr, char *);
+#endif
+
   buf[0] = '%';
 
   while (c = *p++)
diff --git a/g++.c b/g++.c
index 1ae3157..aee9edd 100644
--- a/g++.c
+++ b/g++.c
@@ -32,16 +32,33 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
    performance hit.  With this program, we never search the PATH at all.  */
 
 #include "config.h"
-#include "gvarargs.h"
-#include <stdio.h>
 #include <sys/types.h>
 #include <sys/file.h>   /* May get R_OK, etc. on some systems.  */
+#include <errno.h>
+#ifdef __STDC__
+#include <stdarg.h>
+#else
+#include "gvarargs.h"
+#endif
+#include <stdio.h>
+
+#ifndef VPROTO
+#ifdef __STDC__
+#define PVPROTO(ARGS)           ARGS
+#define VPROTO(ARGS)            ARGS
+#define VA_START(va_list,var)   va_start(va_list,var)
+#else
+#define PVPROTO(ARGS)           ()
+#define VPROTO(ARGS)            (va_alist) va_dcl
+#define VA_START(va_list,var)   va_start(va_list)
+#endif
+#endif
 
 /* Defined to the name of the compiler; if using a cross compiler, the
    Makefile should compile this file with the proper name
    (e.g., "i386-aout-gcc").  */
 #ifndef GCC_NAME
-#define GCC_NAME "gcc"
+#define GCC_NAME "gcc-2.5.8"
 #endif
 
 /* This bit is set if we saw a `-xfoo' language specification.  */
@@ -62,7 +79,12 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #endif
 #endif
 
-extern int errno, sys_nerr;
+
+#ifndef errno
+extern int errno;
+#endif
+
+extern int sys_nerr;
 #if defined(bsd4_4)
 extern const char *const sys_errlist[];
 #else
@@ -76,14 +98,19 @@ static char *programname;
 /* Output an error message and exit */
 
 static void
-fatal (va_alist)
-     va_dcl
+fatal VPROTO((char *format, ...))
 {
-  va_list ap;
+#ifndef __STDC__
   char *format;
+#endif
+  va_list ap;
+
+  VA_START (ap, format);
 
-  va_start (ap);
+#ifndef __STDC__
   format = va_arg (ap, char *);
+#endif
+
   fprintf (stderr, "%s: ", programname);
   vfprintf (stderr, format, ap);
   va_end (ap);
@@ -96,14 +123,19 @@ fatal (va_alist)
 }
 
 static void
-error (va_alist)
-     va_dcl
+error VPROTO((char *format, ...))
 {
-  va_list ap;
+#ifndef __STDC__
   char *format;
+#endif
+  va_list ap;
+
+  VA_START (ap, format);
 
-  va_start (ap);
+#ifndef __STDC__
   format = va_arg (ap, char *);
+#endif
+
   fprintf (stderr, "%s: ", programname);
   vfprintf (stderr, format, ap);
   va_end (ap);
@@ -172,17 +204,33 @@ concat (s1, s2, s3)
   return result;
 }
 
+char *
+my_strerror(e)
+     int e;
+{
+
+#ifdef HAVE_STRERROR
+  return strerror(e);
+
+#else
+
+  static char buffer[30];
+  if (!e)
+    return "";
+
+  if (e > 0 && e < sys_nerr)
+    return sys_errlist[e];
+
+  sprintf (buffer, "Unknown error %d", e);
+  return buffer;
+#endif
+}
+
 static void
 pfatal_with_name (name)
      char *name;
 {
-  char *s;
-
-  if (errno < sys_nerr)
-    s = concat ("%s: ", sys_errlist[errno], "");
-  else
-    s = "cannot open %s";
-  fatal (s, name);
+  fatal ("%s: %s", name, my_strerror (errno));
 }
 
 #ifdef __MSDOS__
@@ -248,14 +296,7 @@ static void
 perror_exec (name)
      char *name;
 {
-  char *s;
-
-  if (errno < sys_nerr)
-    s = concat ("installation problem, cannot exec %s: ",
-		sys_errlist[errno], "");
-  else
-    s = "installation problem, cannot exec %s";
-  error (s, name);
+  error ("%s: %s", name, my_strerror (errno));
 }
 
 /* This is almost exactly what's in gcc.c:pexecute for MSDOS.  */
diff --git a/gcc.c b/gcc.c
index 21fa1f7..43e210a 100644
--- a/gcc.c
+++ b/gcc.c
@@ -35,12 +35,29 @@ compilation is specified by a string called a "spec".  */
 #include <signal.h>
 #include <sys/stat.h>
 #include <sys/file.h>   /* May get R_OK, etc. on some systems.  */
+#include <errno.h>
 
 #include "config.h"
 #include "obstack.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
 #include <stdio.h>
 
+#ifndef VPROTO
+#ifdef __STDC__
+#define PVPROTO(ARGS)           ARGS
+#define VPROTO(ARGS)            ARGS
+#define VA_START(va_list,var)   va_start(va_list,var)
+#else
+#define PVPROTO(ARGS)           ()
+#define VPROTO(ARGS)            (va_alist) va_dcl
+#define VA_START(va_list,var)   va_start(va_list)
+#endif
+#endif
+
 #ifndef R_OK
 #define R_OK 4
 #define W_OK 2
@@ -103,7 +120,11 @@ compilation is specified by a string called a "spec".  */
 extern void free ();
 extern char *getenv ();
 
-extern int errno, sys_nerr;
+#ifndef errno
+extern int errno;
+#endif
+
+extern int sys_nerr;
 #if defined(bsd4_4)
 extern const char *const sys_errlist[];
 #else
@@ -184,8 +205,8 @@ static void give_switch ();
 static void pfatal_with_name ();
 static void perror_with_name ();
 static void perror_exec ();
-static void fatal ();
-static void error ();
+static void fatal PVPROTO((char *, ...));
+static void error PVPROTO((char *, ...));
 void fancy_abort ();
 char *xmalloc ();
 char *xrealloc ();
@@ -4098,44 +4119,47 @@ save_string (s, len)
   return result;
 }
 
+char *
+my_strerror(e)
+     int e;
+{
+
+#ifdef HAVE_STRERROR
+  return strerror(e);
+
+#else
+
+  static char buffer[30];
+  if (!e)
+    return "";
+
+  if (e > 0 && e < sys_nerr)
+    return sys_errlist[e];
+
+  sprintf (buffer, "Unknown error %d", e);
+  return buffer;
+#endif
+}
+
 static void
 pfatal_with_name (name)
      char *name;
 {
-  char *s;
-
-  if (errno < sys_nerr)
-    s = concat ("%s: ", sys_errlist[errno], "");
-  else
-    s = "cannot open %s";
-  fatal (s, name);
+  fatal ("%s: %s", name, my_strerror (errno));
 }
 
 static void
 perror_with_name (name)
      char *name;
 {
-  char *s;
-
-  if (errno < sys_nerr)
-    s = concat ("%s: ", sys_errlist[errno], "");
-  else
-    s = "cannot open %s";
-  error (s, name);
+  error ("%s: %s", name, my_strerror (errno));
 }
 
 static void
 perror_exec (name)
      char *name;
 {
-  char *s;
-
-  if (errno < sys_nerr)
-    s = concat ("installation problem, cannot exec %s: ",
-		sys_errlist[errno], "");
-  else
-    s = "installation problem, cannot exec %s";
-  error (s, name);
+  error ("%s: %s", name, my_strerror (errno));
 }
 
 /* More 'friendly' abort that prints the line and file.
@@ -4152,14 +4176,19 @@ fancy_abort ()
 /* Output an error message and exit */
 
 static void
-fatal (va_alist)
-     va_dcl
+fatal VPROTO((char *format, ...))
 {
-  va_list ap;
+#ifndef __STDC__
   char *format;
+#endif
+  va_list ap;
 
-  va_start (ap);
+  VA_START (ap, format);
+
+#ifndef __STDC__
   format = va_arg (ap, char *);
+#endif
+
   fprintf (stderr, "%s: ", programname);
   vfprintf (stderr, format, ap);
   va_end (ap);
@@ -4169,14 +4198,19 @@ fatal (va_alist)
 }
 
 static void
-error (va_alist)
-     va_dcl
+error VPROTO((char *format, ...))
 {
-  va_list ap;
+#ifndef __STDC__
   char *format;
+#endif
+  va_list ap;
+
+  VA_START (ap, format);
 
-  va_start (ap);
+#ifndef __STDC__
   format = va_arg (ap, char *);
+#endif
+
   fprintf (stderr, "%s: ", programname);
   vfprintf (stderr, format, ap);
   va_end (ap);
diff --git a/genattrtab.c b/genattrtab.c
index 7e93348..b5e1d43 100644
--- a/genattrtab.c
+++ b/genattrtab.c
@@ -96,7 +96,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 #include "hconfig.h"
 /* gvarargs must always be included after *config.h.  */
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
 #include "rtl.h"
 #include "insn-config.h"	/* For REGISTER_CONSTRAINTS */
 #include <stdio.h>
@@ -355,13 +359,8 @@ static char *alternative_name;
 rtx frame_pointer_rtx, hard_frame_pointer_rtx, stack_pointer_rtx;
 rtx arg_pointer_rtx;
 
-#if 0
-static rtx attr_rtx		PROTO((enum rtx_code, ...));
-static char *attr_printf	PROTO((int, char *, ...));
-#else
-static rtx attr_rtx ();
-static char *attr_printf ();
-#endif
+static rtx attr_rtx		PVPROTO((enum rtx_code, ...));
+static char *attr_printf	PVPROTO((int, char *, ...));
 
 static char *attr_string        PROTO((char *, int));
 static rtx check_attr_test	PROTO((rtx, int));
@@ -524,11 +523,12 @@ attr_hash_add_string (hashcode, str)
 
 /*VARARGS1*/
 static rtx
-attr_rtx (va_alist)
-     va_dcl
+attr_rtx VPROTO((enum rtx_code code, ...))
 {
-  va_list p;
+#ifndef __STDC__
   enum rtx_code code;
+#endif
+  va_list p;
   register int i;		/* Array indices...			*/
   register char *fmt;		/* Current rtx's format...		*/
   register rtx rt_val;		/* RTX to return to caller...		*/
@@ -536,8 +536,11 @@ attr_rtx (va_alist)
   register struct attr_hash *h;
   struct obstack *old_obstack = rtl_obstack;
 
-  va_start (p);
+  VA_START (p, code);
+
+#ifndef __STDC__
   code = va_arg (p, enum rtx_code);
+#endif
 
   /* For each of several cases, search the hash table for an existing entry.
      Use that entry if one is found; otherwise create a new RTL and add it
@@ -719,19 +722,24 @@ attr_rtx (va_alist)
 
 /*VARARGS2*/
 static char *
-attr_printf (va_alist)
-     va_dcl
+attr_printf VPROTO((register int len, char *fmt, ...))
 {
-  va_list p;
+#ifndef __STDC__
   register int len;
   register char *fmt;
+#endif
+  va_list p;
   register char *str;
 
-  /* Print the string into a temporary location.  */
-  va_start (p);
+  VA_START (p, fmt);
+
+#ifndef __STDC__
   len = va_arg (p, int);
-  str = (char *) alloca (len);
   fmt = va_arg (p, char *);
+#endif
+
+  /* Print the string into a temporary location.  */
+  str = (char *) alloca (len);
   vsprintf (str, fmt, p);
   va_end (p);
 
diff --git a/gstdarg.h b/gstdarg.h
index 00ed696..f785543 100644
--- a/gstdarg.h
+++ b/gstdarg.h
@@ -137,19 +137,29 @@ typedef __gnuc_va_list va_list;
    (Note that the comments in NET 2's ansi.h
    are incorrect for _VA_LIST_--see stdio.h!)  */
 #if !defined (_VA_LIST_) || defined (__BSD_NET2__) || defined (____386BSD____) || defined (__bsdi__)
+#ifndef _VA_LIST_DEFINED
 /* The macro _VA_LIST is used in SCO Unix 3.2.  */
 #ifndef _VA_LIST
 /* The macro _VA_LIST_T_H is used in the Bull dpx2  */
 #ifndef _VA_LIST_T_H
-#define _VA_LIST_T_H
-#if !(defined (__BSD_NET2__) || defined (____386BSD____) || defined (__bsdi__))
-#define _VA_LIST_
-#endif
-#define _VA_LIST
 typedef __gnuc_va_list va_list;
 #endif /* not _VA_LIST_T_H */
 #endif /* not _VA_LIST */
-#endif /* not _VA_LIST_ */
+#endif /* not _VA_LIST_DEFINED */
+#if !(defined (__BSD_NET2__) || defined (____386BSD____) || defined (__bsdi__) || defined (__sequent__) || defined (__FreeBSD__))
+#define _VA_LIST_
+#endif
+#ifndef _VA_LIST
+#define _VA_LIST
+#endif
+#ifndef _VA_LIST_DEFINED
+#define _VA_LIST_DEFINED
+#endif
+#ifndef _VA_LIST_T_H
+#define _VA_LIST_T_H
+#endif
+
+#endif /* not _VA_LIST_, except on certain systems */
 
 #endif /* not __svr4__ */
 
diff --git a/output.h b/output.h
index 7e5d03e..4e6940e 100644
--- a/output.h
+++ b/output.h
@@ -32,7 +32,7 @@ extern void output_asm_insn PROTO((char *, rtx *));
 
 /* Output a string of assembler code, substituting numbers, strings
    and fixed syntactic prefixes.  */
-extern void asm_fprintf ();
+extern void asm_fprintf STDIO_PROTO(PVPROTO((FILE *file, char *p, ...)));
 
 /* Print an integer constant expression in assembler syntax.
    Addition and subtraction are the only arithmetic
diff --git a/rtl.h b/rtl.h
index a8a6399..98f5ddc 100644
--- a/rtl.h
+++ b/rtl.h
@@ -151,6 +151,18 @@ typedef struct rtx_def
 #endif
 #endif
 
+#ifndef VPROTO
+#ifdef __STDC__
+#define PVPROTO(ARGS)           ARGS
+#define VPROTO(ARGS)            ARGS
+#define VA_START(va_list,var)   va_start(va_list,var)
+#else
+#define PVPROTO(ARGS)           ()
+#define VPROTO(ARGS)            (va_alist) va_dcl
+#define VA_START(va_list,var)   va_start(va_list)
+#endif
+#endif
+
 #define NULL_RTX (rtx) 0
 
 /* Define a generic NULL if one hasn't already been defined.  */
@@ -643,19 +655,9 @@ extern rtx plus_constant_for_output_wide PROTO((rtx, HOST_WIDE_INT));
 
 #define GEN_INT(N) gen_rtx (CONST_INT, VOIDmode, (HOST_WIDE_INT) (N))
 
-#if 0
-/* We cannot define prototypes for the variable argument functions,
-   since they have not been ANSI-fied, and an ANSI compiler would
-   complain when compiling the definition of these functions.  */
-
-extern rtx gen_rtx			PROTO((enum rtx_code, enum machine_mode, ...));
-extern rtvec gen_rtvec			PROTO((int, ...));
-
-#else
 extern rtx bc_gen_rtx ();
-extern rtx gen_rtx ();
-extern rtvec gen_rtvec ();
-#endif
+extern rtx gen_rtx			PVPROTO((enum rtx_code, enum machine_mode, ...));
+extern rtvec gen_rtvec			PVPROTO((int, ...));
 
 #ifdef BUFSIZ			/* stdio.h has been included */
 extern rtx read_rtx			PROTO((FILE *));
diff --git a/stdarg.h b/stdarg.h
new file mode 120000
index 0000000..883f582
--- /dev/null
+++ b/stdarg.h
@@ -0,0 +1 @@
+gstdarg.h
\ No newline at end of file
diff --git a/stddef.h b/stddef.h
new file mode 120000
index 0000000..4d44230
--- /dev/null
+++ b/stddef.h
@@ -0,0 +1 @@
+gstddef.h
\ No newline at end of file
diff --git a/tree.c b/tree.c
index a293a43..1b0556f 100644
--- a/tree.c
+++ b/tree.c
@@ -37,7 +37,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include "tree.h"
 #include "function.h"
 #include "obstack.h"
+#ifdef __STDC__
+#include <stdarg.h>
+#else
 #include "gvarargs.h"
+#endif
 #include <stdio.h>
 
 #define obstack_chunk_alloc xmalloc
@@ -2374,21 +2378,27 @@ stabilize_reference_1 (e)
    Constants, decls, types and misc nodes cannot be.  */
 
 tree
-build (va_alist)
-     va_dcl
+build VPROTO((enum tree_code code, tree tt, ...))
 {
-  va_list p;
+#ifndef __STDC__
   enum tree_code code;
+  tree tt;
+#endif
+  va_list p;
   register tree t;
   register int length;
   register int i;
 
-  va_start (p);
+  VA_START (p, tt);
 
+#ifndef __STDC__
   code = va_arg (p, enum tree_code);
+  tt = va_arg (p, tree);
+#endif
+
   t = make_node (code);
   length = tree_code_length[(int) code];
-  TREE_TYPE (t) = va_arg (p, tree);
+  TREE_TYPE (t) = tt;
 
   if (length == 2)
     {
@@ -2492,18 +2502,22 @@ build1 (code, type, node)
    or even garbage if their values do not matter.  */
 
 tree
-build_nt (va_alist)
-     va_dcl
+build_nt VPROTO((enum tree_code code, ...))
 {
+#ifndef __STDC__
+  enum tree_code code;
+#endif
   va_list p;
-  register enum tree_code code;
   register tree t;
   register int length;
   register int i;
 
-  va_start (p);
+  VA_START (p, code);
 
+#ifndef __STDC__
   code = va_arg (p, enum tree_code);
+#endif
+
   t = make_node (code);
   length = tree_code_length[(int) code];
 
@@ -2518,21 +2532,25 @@ build_nt (va_alist)
    on the temp_decl_obstack, regardless.  */
 
 tree
-build_parse_node (va_alist)
-     va_dcl
+build_parse_node VPROTO((enum tree_code code, ...))
 {
+#ifndef __STDC__
+  enum tree_code code;
+#endif
   register struct obstack *ambient_obstack = expression_obstack;
   va_list p;
-  register enum tree_code code;
   register tree t;
   register int length;
   register int i;
 
-  expression_obstack = &temp_decl_obstack;
-
-  va_start (p);
+  VA_START (p, code);
 
+#ifndef __STDC__
   code = va_arg (p, enum tree_code);
+#endif
+
+  expression_obstack = &temp_decl_obstack;
+
   t = make_node (code);
   length = tree_code_length[(int) code];
 
diff --git a/tree.h b/tree.h
index 50b4d7e..5773da3 100644
--- a/tree.h
+++ b/tree.h
@@ -981,6 +981,17 @@ union tree_node
 #endif
 #endif
 
+#ifndef VPROTO
+#ifdef __STDC__
+#define PVPROTO(ARGS)           ARGS
+#define VPROTO(ARGS)            ARGS
+#define VA_START(va_list,var)   va_start(va_list,var)
+#else
+#define PVPROTO(ARGS)           ()
+#define VPROTO(ARGS)            (va_alist) va_dcl
+#define VA_START(va_list,var)   va_start(va_list)
+#endif
+#endif
 
 #define NULL_TREE (tree) NULL
 
@@ -1057,19 +1068,9 @@ extern tree get_identifier		PROTO((char *));
 #define build_int_2(LO,HI)  \
   build_int_2_wide ((HOST_WIDE_INT) (LO), (HOST_WIDE_INT) (HI))
 
-#if 0
-/* We cannot define prototypes for the variable argument functions,
-   since they have not been ANSI-fied, and an ANSI compiler would
-   complain when compiling the definition of these functions.  */
-
-extern tree build			PROTO((enum tree_code, tree, ...));
-extern tree build_nt			PROTO((enum tree_code, ...));
-extern tree build_parse_node		PROTO((enum tree_code, ...));
-#else
-extern tree build ();
-extern tree build_nt ();
-extern tree build_parse_node ();
-#endif
+extern tree build			PVPROTO((enum tree_code, tree, ...));
+extern tree build_nt			PVPROTO((enum tree_code, ...));
+extern tree build_parse_node		PVPROTO((enum tree_code, ...));
 
 extern tree build_int_2_wide		PROTO((HOST_WIDE_INT, HOST_WIDE_INT));
 extern tree build_real			PROTO((tree, REAL_VALUE_TYPE));
