diff --git a/config.rpath b/config.rpath
index 9316b9197..e108a09db 100755
--- a/config.rpath
+++ b/config.rpath
@@ -441,7 +441,7 @@ case "$host_os" in
   bsdi4*)
     ;;
   cygwin* | mingw* | pw32*)
-    shrext=.dll
+    shrext=.dll.a
     ;;
   darwin* | rhapsody*)
     shrext=.dylib
diff --git a/gcc/ada/a-intnam-cygwin.ads b/gcc/ada/a-intnam-cygwin.ads
new file mode 100644
index 000000000..eb516d5f4
--- /dev/null
+++ b/gcc/ada/a-intnam-cygwin.ads
@@ -0,0 +1,168 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   A D A . I N T E R R U P T S . N A M E S                --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--          Copyright (C) 1991-2005, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNARL; see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is a Cygwin version of this package but really it's a copy of the
+--  Linux version, so the below comments are probably irrelevant:
+
+--  The following signals are reserved by the run time (FSU threads):
+
+--  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,
+--  SIGALRM, SIGVTALRM, SIGUNUSED, SIGSTOP, SIGKILL
+
+--  The following signals are reserved by the run time (LinuxThreads):
+
+--  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,
+--  SIGUSR1, SIGUSR2, SIGVTALRM, SIGUNUSED, SIGSTOP, SIGKILL
+
+--  The pragma Unreserve_All_Interrupts affects the following signal(s):
+
+--  SIGINT: made available for Ada handler
+
+--  This target-dependent package spec contains names of interrupts
+--  supported by the local system.
+
+with System.OS_Interface;
+--  used for names of interrupts
+
+package Ada.Interrupts.Names is
+
+   --  Beware that the mapping of names to signals may be many-to-one. There
+   --  may be aliases. Also, for all signal names that are not supported on the
+   --  current system the value of the corresponding constant will be zero.
+
+   SIGHUP : constant Interrupt_ID :=
+     System.OS_Interface.SIGHUP;      --  hangup
+
+   SIGINT : constant Interrupt_ID :=
+     System.OS_Interface.SIGINT;      --  interrupt (rubout)
+
+   SIGQUIT : constant Interrupt_ID :=
+     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)
+
+   SIGILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)
+
+   SIGTRAP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)
+
+   SIGIOT : constant Interrupt_ID :=
+     System.OS_Interface.SIGIOT;      --  IOT instruction
+
+   SIGABRT : constant Interrupt_ID := --  used by abort,
+     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future
+
+   SIGFPE : constant Interrupt_ID :=
+     System.OS_Interface.SIGFPE;      --  floating point exception
+
+   SIGKILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)
+
+   SIGBUS : constant Interrupt_ID :=
+     System.OS_Interface.SIGBUS;      --  bus error
+
+   SIGSEGV : constant Interrupt_ID :=
+     System.OS_Interface.SIGSEGV;     --  segmentation violation
+
+   SIGPIPE : constant Interrupt_ID := --  write on a pipe with
+     System.OS_Interface.SIGPIPE;     --  no one to read it
+
+   SIGALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGALRM;     --  alarm clock
+
+   SIGTERM : constant Interrupt_ID :=
+     System.OS_Interface.SIGTERM;     --  software termination signal from kill
+
+   SIGUSR1 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR1;     --  user defined signal 1
+
+   SIGUSR2 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR2;     --  user defined signal 2
+
+   SIGCLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCLD;      --  child status change
+
+   SIGCHLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD
+
+   SIGWINCH : constant Interrupt_ID :=
+     System.OS_Interface.SIGWINCH;    --  window size change
+
+   SIGURG : constant Interrupt_ID :=
+     System.OS_Interface.SIGURG;      --  urgent condition on IO channel
+
+   SIGPOLL : constant Interrupt_ID :=
+     System.OS_Interface.SIGPOLL;     --  pollable event occurred
+
+   SIGIO : constant Interrupt_ID :=   --  input/output possible,
+     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)
+
+   SIGSTOP : constant Interrupt_ID :=
+     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)
+
+   SIGTSTP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTSTP;     --  user stop requested from tty
+
+   SIGCONT : constant Interrupt_ID :=
+     System.OS_Interface.SIGCONT;     --  stopped process has been continued
+
+   SIGTTIN : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTIN;     --  background tty read attempted
+
+   SIGTTOU : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTOU;     --  background tty write attempted
+
+   SIGVTALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGVTALRM;   --  virtual timer expired
+
+   SIGPROF : constant Interrupt_ID :=
+     System.OS_Interface.SIGPROF;     --  profiling timer expired
+
+   SIGXCPU : constant Interrupt_ID :=
+     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded
+
+   SIGXFSZ : constant Interrupt_ID :=
+     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded
+
+   SIGUNUSED : constant Interrupt_ID :=
+     System.OS_Interface.SIGUNUSED;     --  unused signal
+
+   SIGSTKFLT : constant Interrupt_ID :=
+     System.OS_Interface.SIGSTKFLT;     --  stack fault on coprocessor
+
+   SIGLOST : constant Interrupt_ID :=
+     System.OS_Interface.SIGLOST;       --  Linux alias for SIGIO
+
+   SIGPWR : constant Interrupt_ID :=
+     System.OS_Interface.SIGPWR;        --  Power failure
+
+end Ada.Interrupts.Names;
diff --git a/gcc/ada/g-soccon-cygwin.ads b/gcc/ada/g-soccon-cygwin.ads
new file mode 100644
index 000000000..f0f94fd99
--- /dev/null
+++ b/gcc/ada/g-soccon-cygwin.ads
@@ -0,0 +1,196 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--               G N A T . S O C K E T S . C O N S T A N T S                --
+--                                                                          --
+--                                 S p e c                                  --
+--                                                                          --
+--          Copyright (C) 2000-2007, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This package provides target dependent definitions of constant for use
+--  by the GNAT.Sockets package (g-socket.ads). This package should not be
+--  directly with'ed by an applications program.
+
+--  This is the version for Cygwin
+--  This file is generated automatically, do not modify it by hand! Instead,
+--  make changes to gen-soccon.c and re-run it on each target.
+
+package GNAT.Sockets.Constants is
+
+   --------------
+   -- Families --
+   --------------
+
+   AF_INET            : constant :=           2; --  IPv4 address family
+   AF_INET6           : constant :=          23; --  IPv6 address family
+
+   -----------
+   -- Modes --
+   -----------
+
+   SOCK_STREAM        : constant :=           1; --  Stream socket
+   SOCK_DGRAM         : constant :=           2; --  Datagram socket
+
+   -------------------
+   -- Socket errors --
+   -------------------
+
+   EACCES             : constant :=          13; --  Permission denied
+   EADDRINUSE         : constant :=         112; --  Address already in use
+   EADDRNOTAVAIL      : constant :=         125; --  Cannot assign address
+   EAFNOSUPPORT       : constant :=         106; --  Addr family not supported
+   EALREADY           : constant :=         120; --  Operation in progress
+   EBADF              : constant :=           9; --  Bad file descriptor
+   ECONNABORTED       : constant :=         113; --  Connection aborted
+   ECONNREFUSED       : constant :=         111; --  Connection refused
+   ECONNRESET         : constant :=         104; --  Connection reset by peer
+   EDESTADDRREQ       : constant :=         121; --  Destination addr required
+   EFAULT             : constant :=          14; --  Bad address
+   EHOSTDOWN          : constant :=         117; --  Host is down
+   EHOSTUNREACH       : constant :=         118; --  No route to host
+   EINPROGRESS        : constant :=         119; --  Operation now in progress
+   EINTR              : constant :=           4; --  Interrupted system call
+   EINVAL             : constant :=          22; --  Invalid argument
+   EIO                : constant :=           5; --  Input output error
+   EISCONN            : constant :=         127; --  Socket already connected
+   ELOOP              : constant :=          92; --  Too many symbolic lynks
+   EMFILE             : constant :=          24; --  Too many open files
+   EMSGSIZE           : constant :=         122; --  Message too long
+   ENAMETOOLONG       : constant :=          91; --  Name too long
+   ENETDOWN           : constant :=         115; --  Network is down
+   ENETRESET          : constant :=         126; --  Disconn. on network reset
+   ENETUNREACH        : constant :=         114; --  Network is unreachable
+   ENOBUFS            : constant :=         105; --  No buffer space available
+   ENOPROTOOPT        : constant :=         109; --  Protocol not available
+   ENOTCONN           : constant :=         128; --  Socket not connected
+   ENOTSOCK           : constant :=         108; --  Operation on non socket
+   EOPNOTSUPP         : constant :=          95; --  Operation not supported
+   EPFNOSUPPORT       : constant :=          96; --  Unknown protocol family
+   EPROTONOSUPPORT    : constant :=         123; --  Unknown protocol
+   EPROTOTYPE         : constant :=         107; --  Unknown protocol type
+   ESHUTDOWN          : constant :=         110; --  Cannot send once shutdown
+   ESOCKTNOSUPPORT    : constant :=         124; --  Socket type not supported
+   ETIMEDOUT          : constant :=         116; --  Connection timed out
+   ETOOMANYREFS       : constant :=         129; --  Too many references
+   EWOULDBLOCK        : constant :=          11; --  Operation would block
+
+   -----------------
+   -- Host errors --
+   -----------------
+
+   HOST_NOT_FOUND     : constant :=           1; --  Unknown host
+   TRY_AGAIN          : constant :=           2; --  Host name lookup failure
+   NO_DATA            : constant :=           4; --  No data record for name
+   NO_RECOVERY        : constant :=           3; --  Non recoverable errors
+
+   -------------------
+   -- Control flags --
+   -------------------
+
+   FIONBIO            : constant := -2147195266; --  Set/clear non-blocking io
+   FIONREAD           : constant :=  1074030207; --  How many bytes to read
+
+   --------------------
+   -- Shutdown modes --
+   --------------------
+
+   SHUT_RD            : constant :=           0; --  No more recv
+   SHUT_WR            : constant :=           1; --  No more send
+   SHUT_RDWR          : constant :=           2; --  No more recv/send
+
+   ---------------------
+   -- Protocol levels --
+   ---------------------
+
+   SOL_SOCKET         : constant :=       65535; --  Options for socket level
+   IPPROTO_IP         : constant :=           0; --  Dummy protocol for IP
+   IPPROTO_UDP        : constant :=          17; --  UDP
+   IPPROTO_TCP        : constant :=           6; --  TCP
+
+   -------------------
+   -- Request flags --
+   -------------------
+
+   MSG_OOB            : constant :=           1; --  Process out-of-band data
+   MSG_PEEK           : constant :=           2; --  Peek at incoming data
+   MSG_EOR            : constant :=          -1; --  Send end of record
+   MSG_WAITALL        : constant :=           8; --  Wait for full reception
+   MSG_NOSIGNAL       : constant :=          32; --  No SIGPIPE on send
+   MSG_Forced_Flags   : constant :=           0;
+   --  Flags set on all send(2) calls
+
+   --------------------
+   -- Socket options --
+   --------------------
+
+   TCP_NODELAY        : constant :=           1; --  Do not coalesce packets
+   SO_REUSEADDR       : constant :=           4; --  Bind reuse local address
+   SO_REUSEPORT       : constant :=          -1; --  Bind reuse port number
+   SO_KEEPALIVE       : constant :=           8; --  Enable keep-alive msgs
+   SO_LINGER          : constant :=         128; --  Defer close to flush data
+   SO_BROADCAST       : constant :=          32; --  Can send broadcast msgs
+   SO_SNDBUF          : constant :=        4097; --  Set/get send buffer size
+   SO_RCVBUF          : constant :=        4098; --  Set/get recv buffer size
+   SO_SNDTIMEO        : constant :=        4101; --  Emission timeout
+   SO_RCVTIMEO        : constant :=        4102; --  Reception timeout
+   SO_ERROR           : constant :=        4103; --  Get/clear error status
+   IP_MULTICAST_IF    : constant :=           9; --  Set/get mcast interface
+   IP_MULTICAST_TTL   : constant :=          10; --  Set/get multicast TTL
+   IP_MULTICAST_LOOP  : constant :=          11; --  Set/get mcast loopback
+   IP_ADD_MEMBERSHIP  : constant :=          12; --  Join a multicast group
+   IP_DROP_MEMBERSHIP : constant :=          13; --  Leave a multicast group
+   IP_PKTINFO         : constant :=          19; --  Get datagram info
+
+   -------------------
+   -- System limits --
+   -------------------
+
+   IOV_MAX            : constant :=        1024; --  Maximum writev iovcnt
+
+   ----------------------
+   -- Type definitions --
+   ----------------------
+
+   --  Sizes (in bytes) of the components of struct timeval
+
+   SIZEOF_tv_sec      : constant :=           4; --  tv_sec
+   SIZEOF_tv_usec     : constant :=           4; --  tv_usec
+
+   ----------------------------------------
+   -- Properties of supported interfaces --
+   ----------------------------------------
+
+   Need_Netdb_Buffer  : constant :=           0; --  Need buffer for Netdb ops
+
+   ----------------------
+   -- Additional flags --
+   ----------------------
+
+   Thread_Blocking_IO : constant Boolean := True;
+   --  Set False for contexts where socket i/o are process blocking
+
+end GNAT.Sockets.Constants;
diff --git a/gcc/ada/gcc-interface/Makefile.in b/gcc/ada/gcc-interface/Makefile.in
index 2dad96bae..07e103b13 100644
--- a/gcc/ada/gcc-interface/Makefile.in
+++ b/gcc/ada/gcc-interface/Makefile.in
@@ -186,6 +186,13 @@ TARGET_ADA_SRCS =
 # Type of tools build we are doing; default is not compiling tools.
 TOOLSCASE =
 
+# Which install goal to use.
+INSTALL_GNATLIB_MAIN  = install-gnatlib
+INSTALL_GNATLIB_WIN32 = unused-install-gnatlib
+
+# Set shared lib prefix (lib on all systems but cygwin, which uses cyg)
+LIBGNAT_SHARED_LIB_PREFIX=lib
+
 # Multilib handling
 MULTISUBDIR =
 RTSDIR = rts$(subst /,_,$(MULTISUBDIR))
@@ -1594,7 +1601,15 @@ ifeq ($(strip $(filter-out avr none powerpc% eabispe leon% erc32% unknown elf,$(
   indepsw.adb<indepsw-gnu.adb
 endif
 
-ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)
+ifeq ($(strip $(filter-out cygwin% mingw32% pe,$(osys))),)
+
+  # Set target pair suffix for mingw or cygwin
+  W32_TARG=mingw
+  ifneq ($(strip $(filter cygwin%,$(osys))),)
+    W32_TARG=cygwin
+    LIBGNAT_SHARED_LIB_PREFIX=cyg
+  endif
+
   LIBGNAT_TARGET_PAIRS = \
   a-dirval.adb<a-dirval-mingw.adb \
   a-excpol.adb<a-excpol-abort.adb \
@@ -1607,8 +1622,6 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)
   s-tasinf.adb<s-tasinf-mingw.adb \
   s-tasinf.ads<s-tasinf-mingw.ads \
   g-bytswa.adb<g-bytswa-x86.adb \
-  g-socthi.ads<g-socthi-mingw.ads \
-  g-socthi.adb<g-socthi-mingw.adb \
   g-stsifd.adb<g-stsifd-sockets.adb \
   g-soliop.ads<g-soliop-mingw.ads
 
@@ -1659,7 +1672,7 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)
 	  system.ads<system-mingw-x86_64.ads
       else
 	LIBGNAT_TARGET_PAIRS += \
-	  system.ads<system-mingw.ads
+	  system.ads<system-$(W32_TARG).ads
       endif
     endif
 
@@ -1667,7 +1680,17 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)
 	s-win32.o s-winext.o g-regist.o g-sse.o g-ssvety.o
     EXTRA_GNATRTL_TASKING_OBJS = a-exetim.o
 
-    MISCLIB = -lws2_32
+    # Which install goal to use.
+    INSTALL_GNATLIB_MAIN  = unused-install-gnatlib
+    INSTALL_GNATLIB_WIN32 = install-gnatlib
+
+    # Mingw uses winsock-based sockets; cygwin uses POSIX sockets.
+    ifneq ($(strip $(filter-out cygwin%,$(osys))),)
+      LIBGNAT_TARGET_PAIRS += \
+      g-socthi.ads<g-socthi-mingw.ads \
+      g-socthi.adb<g-socthi-mingw.adb
+      MISCLIB = -lwsock32
+    endif
 
     # ??? This will be replaced by gnatlib-shared-dual-win32 when GNAT
     # auto-import support for array/record will be done.
@@ -1675,10 +1698,11 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)
   endif
 
   TOOLS_TARGET_PAIRS= \
-  mlib-tgt-specific.adb<mlib-tgt-specific-mingw.adb \
+  mlib-tgt-specific.adb<mlib-tgt-specific-$(W32_TARG).adb \
   indepsw.adb<indepsw-mingw.adb
 
   GMEM_LIB = gmemlib
+  EH_MECHANISM=-gcc
   EXTRA_GNATTOOLS = ../../gnatdll$(exeext)
   EXTRA_GNATMAKE_OBJS = mdll.o mdll-utl.o mdll-fil.o
   soext = .dll
@@ -2349,7 +2373,7 @@ gnatlink-re:  link.o targext.o
 	  true; \
 	fi
 
-install-gnatlib: ../stamp-gnatlib-$(RTSDIR)
+$(INSTALL_GNATLIB_MAIN): ../stamp-gnatlib-$(RTSDIR)
 #	Create the directory before deleting it, in case the directory is
 #	a list of directories (as it may be on VMS). This ensures we are
 #	deleting the right one.
@@ -2397,6 +2421,46 @@ install-gnatlib: ../stamp-gnatlib-$(RTSDIR)
 	cd $(DESTDIR)$(ADA_INCLUDE_DIR); $(CHMOD) a-wx *.adb
 	cd $(DESTDIR)$(ADA_INCLUDE_DIR); $(CHMOD) a-wx *.ads
 
+$(INSTALL_GNATLIB_WIN32): ../stamp-gnatlib-$(RTSDIR)
+#	Create the directory before deleting it, in case the directory is
+#	a list of directories (as it may be on VMS). This ensures we are
+#	deleting the right one.
+	-$(MKDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)
+	-$(MKDIR) $(DESTDIR)$(ADA_INCLUDE_DIR)
+	$(RMDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)
+	$(RMDIR) $(DESTDIR)$(ADA_INCLUDE_DIR)
+	-$(MKDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)
+	-$(MKDIR) $(DESTDIR)$(ADA_INCLUDE_DIR)
+	for file in $(RTSDIR)/*.ali; do \
+	    $(INSTALL_DATA_DATE) $$file $(DESTDIR)$(ADA_RTL_OBJ_DIR); \
+	done
+	-$(INSTALL_DATA) $(RTSDIR)/g-trasym$(objext) $(DESTDIR)$(ADA_RTL_OBJ_DIR)
+	-cd $(RTSDIR); for file in *$(arext);do \
+	    $(INSTALL_DATA) $$file $(DESTDIR)$(ADA_RTL_OBJ_DIR); \
+	    $(RANLIB_FOR_TARGET) $(DESTDIR)$(ADA_RTL_OBJ_DIR)/$$file; \
+	done
+	-$(foreach file, $(EXTRA_ADALIB_FILES), \
+	    $(INSTALL_DATA_DATE) $(RTSDIR)/$(file) $(DESTDIR)$(ADA_RTL_OBJ_DIR) && \
+	) true
+#     Install the shared libraries, if any, using $(INSTALL) instead
+#     of $(INSTALL_DATA). The latter may force a mode inappropriate
+#     for shared libraries on some targets, e.g. on HP-UX where the x
+#     permission is required.  We are win32 here.
+	for file in gnat gnarl; do \
+	   if [ -f $(RTSDIR)/$(LIBGNAT_SHARED_LIB_PREFIX)$${file}$(hyphen)$(LIBRARY_VERSION)$(soext) ]; then \
+	      $(INSTALL) $(RTSDIR)/$(LIBGNAT_SHARED_LIB_PREFIX)$${file}$(hyphen)$(LIBRARY_VERSION)$(soext) \
+			 $(DESTDIR)$(bindir); \
+	      $(LN_S) $(bindir)/$(LIBGNAT_SHARED_LIB_PREFIX)$${file}$(hyphen)$(LIBRARY_VERSION)$(soext) \
+	      $(DESTDIR)$(ADA_RTL_OBJ_DIR)/lib$${file}$(hyphen)$(LIBRARY_VERSION).dll.a; \
+	   fi; \
+	done
+# This copy must be done preserving the date on the original file.
+	for file in $(RTSDIR)/*.ad?; do \
+	    $(INSTALL_DATA_DATE) $$file $(DESTDIR)$(ADA_INCLUDE_DIR); \
+	done
+	cd $(DESTDIR)$(ADA_INCLUDE_DIR); $(CHMOD) a-wx *.adb
+	cd $(DESTDIR)$(ADA_INCLUDE_DIR); $(CHMOD) a-wx *.ads
+
 ../stamp-gnatlib2-$(RTSDIR):
 	$(RM) $(RTSDIR)/s-*.ali
 	$(RM) $(RTSDIR)/s-*$(objext)
@@ -2561,16 +2625,16 @@ gnatlib-shared-win32:
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
-	$(RM) $(RTSDIR)/libgna*$(soext)
+	$(RM) $(RTSDIR)/$(LIBGNAT_SHARED_LIB_PREFIX)gna*$(soext)
 	cd $(RTSDIR); ../../xgcc -B../../ -shared $(TARGET_LIBGCC2_CFLAGS) \
-		-o libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \
+		-o $(LIBGNAT_SHARED_LIB_PREFIX)gnat$(hyphen)$(LIBRARY_VERSION)$(soext) \
 		$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS) \
-		$(SO_OPTS)libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) $(MISCLIB)
+		$(SO_OPTS)$(LIBGNAT_SHARED_LIB_PREFIX)gnat$(hyphen)$(LIBRARY_VERSION)$(soext) $(MISCLIB)
 	cd $(RTSDIR); ../../xgcc -B../../ -shared $(TARGET_LIBGCC2_CFLAGS) \
-		-o libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \
+		-o $(LIBGNAT_SHARED_LIB_PREFIX)gnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \
 		$(GNATRTL_TASKING_OBJS) \
-		$(SO_OPTS)libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \
-		$(THREADSLIB) -Wl,libgnat$(hyphen)$(LIBRARY_VERSION)$(soext)
+		$(SO_OPTS)$(LIBGNAT_SHARED_LIB_PREFIX)gnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \
+		$(THREADSLIB) -Wl,$(LIBGNAT_SHARED_LIB_PREFIX)gnat$(hyphen)$(LIBRARY_VERSION)$(soext)
 
 gnatlib-shared-darwin:
 	$(MAKE) $(FLAGS_TO_PASS) \
diff --git a/gcc/ada/gsocket.h b/gcc/ada/gsocket.h
index 24928a1f9..91c91305c 100644
--- a/gcc/ada/gsocket.h
+++ b/gcc/ada/gsocket.h
@@ -212,7 +212,7 @@
  * VxWorks and VMS).
  */
 
-#if defined (_AIX) || defined (__FreeBSD__) || defined (__hpux__) || defined (__osf__) || defined (_WIN32) || defined (__APPLE__)
+#if defined (_AIX) || defined (__FreeBSD__) || defined (__hpux__) || defined (__osf__) || defined (__CYGWIN__) || defined (_WIN32) || defined (__APPLE__)
 # define HAVE_THREAD_SAFE_GETxxxBYyyy 1
 #elif defined (sgi) || defined (linux) || defined (__GLIBC__) || (defined (sun) && defined (__SVR4) && !defined (__vxworks)) || defined(__rtems__)
 # define HAVE_GETxxxBYyyy_R 1
diff --git a/gcc/ada/indepsw-cygwin.adb b/gcc/ada/indepsw-cygwin.adb
new file mode 100644
index 000000000..4e324838e
--- /dev/null
+++ b/gcc/ada/indepsw-cygwin.adb
@@ -0,0 +1,69 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                              I N D E P S W                               --
+--                                                                          --
+--                                 B o d y                                  --
+--                            (Windows version)                             --
+--                                                                          --
+--            Copyright (C) 2004 Free Software Foundation, Inc.             --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the Windows version
+
+package body Indepsw is
+
+   Map_Switch : aliased constant String := "-Wl,-Map,";
+
+   -------------
+   -- Convert --
+   -------------
+
+   procedure Convert
+     (Switch   : Switch_Kind;
+      Argument : String;
+      To       : out String_List_Access)
+   is
+   begin
+      case Switch is
+         when Map_File =>
+            To := new Argument_List'(1 => new String'(Map_Switch & Argument));
+      end case;
+   end Convert;
+
+   ------------------
+   -- Is_Supported --
+   ------------------
+
+   function Is_Supported (Switch : Switch_Kind) return Boolean is
+   begin
+      case Switch is
+         when Map_File =>
+            return True;
+      end case;
+   end Is_Supported;
+
+end Indepsw;
diff --git a/gcc/ada/initialize.c b/gcc/ada/initialize.c
index fbbdf6052..81a2b4381 100644
--- a/gcc/ada/initialize.c
+++ b/gcc/ada/initialize.c
@@ -348,6 +348,40 @@ __gnat_initialize (void *eh ATTRIBUTE_UNUSED)
   __main ();
 }
 
+#elif defined (__CYGWIN__)
+
+/***************************************/
+/* __gnat_initialize (Cygwin Version) */
+/***************************************/
+
+extern void __main (void);
+
+void
+__gnat_initialize (void *eh ATTRIBUTE_UNUSED)
+{
+#ifdef IN_RTS
+  /* We must call __main to run the static ctors, or DW2 EH, amongst
+     other things, will fail.  */
+  __main ();
+#endif
+   /* Initialize floating-point coprocessor. This call is needed because
+      the MS libraries default to 64-bit precision instead of 80-bit
+      precision, and we require the full precision for proper operation,
+      given that we have set Max_Digits etc with this in mind */
+   __gnat_init_float ();
+
+   /* Note that we do not activate this for the compiler itself to avoid a
+      bootstrap path problem.  Older version of gnatbind will generate a call
+      to __gnat_initialize() without argument. Therefore we cannot use eh in
+      this case.  It will be possible to remove the following #ifdef at some
+      point.  */
+#ifdef IN_RTS
+   /* Install the Structured Exception handler.  */
+   if (eh)
+     __gnat_install_SEH_handler (eh);
+#endif
+}
+
 #else
 
 /* For all other versions of GNAT, the initialize routine and handler
diff --git a/gcc/ada/mlib-tgt-cygwin.adb b/gcc/ada/mlib-tgt-cygwin.adb
new file mode 100644
index 000000000..c60fa0f92
--- /dev/null
+++ b/gcc/ada/mlib-tgt-cygwin.adb
@@ -0,0 +1,160 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                    M L I B . T G T . S P E C I F I C                     --
+--                            (Cygwin  Version)                             --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--          Copyright (C) 2002-2009, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --
+-- http://www.gnu.org/licenses for a complete copy of the license.          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the Windows version of the body. Works only with GCC versions
+--  supporting the "-shared" option.
+
+with Opt;
+with Output; use Output;
+
+with MLib.Fil;
+with MLib.Utl;
+
+package body MLib.Tgt.Specific is
+
+   package Files renames MLib.Fil;
+   package Tools renames MLib.Utl;
+
+   --  Non default subprograms
+
+   procedure Build_Dynamic_Library
+     (Ofiles       : Argument_List;
+      Options      : Argument_List;
+      Interfaces   : Argument_List;
+      Lib_Filename : String;
+      Lib_Dir      : String;
+      Symbol_Data  : Symbol_Record;
+      Driver_Name  : Name_Id := No_Name;
+      Lib_Version  : String  := "";
+      Auto_Init    : Boolean := False);
+
+   function DLL_Ext return String;
+
+   function DLL_Prefix return String;
+
+   function Is_Archive_Ext (Ext : String) return Boolean;
+
+   function Library_Major_Minor_Id_Supported return Boolean;
+
+   function PIC_Option return String;
+
+   No_Argument_List : constant String_List := (1 .. 0 => null);
+   --  Used as value of parameter Options or Options2 in calls to Gcc
+
+   ---------------------------
+   -- Build_Dynamic_Library --
+   ---------------------------
+
+   procedure Build_Dynamic_Library
+     (Ofiles       : Argument_List;
+      Options      : Argument_List;
+      Interfaces   : Argument_List;
+      Lib_Filename : String;
+      Lib_Dir      : String;
+      Symbol_Data  : Symbol_Record;
+      Driver_Name  : Name_Id := No_Name;
+      Lib_Version  : String  := "";
+      Auto_Init    : Boolean := False)
+   is
+      pragma Unreferenced (Symbol_Data);
+      pragma Unreferenced (Interfaces);
+      pragma Unreferenced (Lib_Version);
+      pragma Unreferenced (Auto_Init);
+
+      Lib_File : constant String :=
+                   Lib_Dir & Directory_Separator &
+                   DLL_Prefix & Files.Append_To (Lib_Filename, DLL_Ext);
+
+   --  Start of processing for Build_Dynamic_Library
+
+   begin
+      if Opt.Verbose_Mode then
+         Write_Str ("building relocatable shared library ");
+         Write_Line (Lib_File);
+      end if;
+
+      Tools.Gcc
+        (Output_File => Lib_File,
+         Objects     => Ofiles,
+         Options     => No_Argument_List,
+         Options_2   => Options,
+         Driver_Name => Driver_Name);
+   end Build_Dynamic_Library;
+
+   -------------
+   -- DLL_Ext --
+   -------------
+
+   function DLL_Ext return String is
+   begin
+      return "dll";
+   end DLL_Ext;
+
+   ----------------
+   -- DLL_Prefix --
+   ----------------
+
+   function DLL_Prefix return String is
+   begin
+      return "cyg";
+   end DLL_Prefix;
+
+   --------------------
+   -- Is_Archive_Ext --
+   --------------------
+
+   function Is_Archive_Ext (Ext : String) return Boolean is
+   begin
+      return Ext = ".a" or else Ext = ".dll";
+   end Is_Archive_Ext;
+
+   --------------------------------------
+   -- Library_Major_Minor_Id_Supported --
+   --------------------------------------
+
+   function Library_Major_Minor_Id_Supported return Boolean is
+   begin
+      return False;
+   end Library_Major_Minor_Id_Supported;
+
+   ----------------
+   -- PIC_Option --
+   ----------------
+
+   function PIC_Option return String is
+   begin
+      return "";
+   end PIC_Option;
+
+begin
+   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;
+   DLL_Ext_Ptr               := DLL_Ext'Access;
+   DLL_Prefix_Ptr            := DLL_Prefix'Access;
+   Is_Archive_Ext_Ptr        := Is_Archive_Ext'Access;
+   PIC_Option_Ptr            := PIC_Option'Access;
+   Library_Major_Minor_Id_Supported_Ptr :=
+                                Library_Major_Minor_Id_Supported'Access;
+end MLib.Tgt.Specific;
diff --git a/gcc/ada/s-gloloc-cygwin.adb b/gcc/ada/s-gloloc-cygwin.adb
new file mode 100644
index 000000000..e30a9b8de
--- /dev/null
+++ b/gcc/ada/s-gloloc-cygwin.adb
@@ -0,0 +1,113 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                  S Y S T E M . G L O B A L _ L O C K S                   --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 1999-2007, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This implementation is specific to NT
+
+with System.Task_Lock;
+
+with Interfaces.C.Strings;
+with System.OS_Interface;
+
+package body System.Global_Locks is
+
+   package TSL renames System.Task_Lock;
+   package OSI renames System.OS_Interface;
+   package ICS renames Interfaces.C.Strings;
+
+   subtype Lock_File_Entry is OSI.HANDLE;
+
+   Last_Lock  : Lock_Type := Null_Lock;
+   Lock_Table : array (Lock_Type range 1 .. 15) of Lock_File_Entry;
+
+   -----------------
+   -- Create_Lock --
+   -----------------
+
+   procedure Create_Lock
+     (Lock : out Lock_Type;
+      Name : String)
+   is
+      L : Lock_Type;
+
+   begin
+      TSL.Lock;
+      Last_Lock := Last_Lock + 1;
+      L := Last_Lock;
+      TSL.Unlock;
+
+      if L > Lock_Table'Last then
+         raise Lock_Error;
+      end if;
+
+      Lock_Table (L) :=
+        OSI.CreateMutex (null, OSI.BOOL (False), ICS.New_String (Name));
+      Lock := L;
+   end Create_Lock;
+
+   ------------------
+   -- Acquire_Lock --
+   ------------------
+
+   procedure Acquire_Lock
+     (Lock : in out Lock_Type)
+   is
+      use type OSI.DWORD;
+
+      Res : OSI.DWORD;
+   begin
+      Res := OSI.WaitForSingleObject (Lock_Table (Lock), OSI.Wait_Infinite);
+
+      if Res = OSI.WAIT_FAILED then
+         raise Lock_Error;
+      end if;
+   end Acquire_Lock;
+
+   ------------------
+   -- Release_Lock --
+   ------------------
+
+   procedure Release_Lock
+     (Lock : in out Lock_Type)
+   is
+      use type OSI.BOOL;
+
+      Res : OSI.BOOL;
+   begin
+      Res := OSI.ReleaseMutex (Lock_Table (Lock));
+
+      if Res = OSI.False then
+         raise Lock_Error;
+      end if;
+   end Release_Lock;
+
+end System.Global_Locks;
diff --git a/gcc/ada/s-osinte-cygwin.ads b/gcc/ada/s-osinte-cygwin.ads
new file mode 100644
index 000000000..bfb34b968
--- /dev/null
+++ b/gcc/ada/s-osinte-cygwin.ads
@@ -0,0 +1,952 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--             Copyright (C) 1991-1994, Florida State University            --
+--          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNARL; see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is a GNU/Linux (GNU/LinuxThreads) version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by children of System.
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Interfaces.C;
+with Interfaces.C.Strings;
+with Ada.Unchecked_Conversion;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   subtype int            is Interfaces.C.int;
+   subtype char           is Interfaces.C.char;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function errno return int;
+   pragma Import (C, errno, "__get_errno");
+
+   EAGAIN    : constant := 11;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   EPERM     : constant := 1;
+   ETIMEDOUT : constant := 110;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 63;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 7; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGUSR1    : constant := 10; --  user defined signal 1
+   SIGUSR2    : constant := 12; --  user defined signal 2
+   SIGCLD     : constant := 17; --  alias for SIGCHLD
+   SIGCHLD    : constant := 17; --  child status change
+   SIGPWR     : constant := 30; --  power-fail restart
+   SIGWINCH   : constant := 28; --  window size change
+   SIGURG     : constant := 23; --  urgent condition on IO channel
+   SIGPOLL    : constant := 29; --  pollable event occurred
+   SIGIO      : constant := 29; --  I/O now possible (4.2 BSD)
+   SIGLOST    : constant := 29; --  File lock lost
+   SIGSTOP    : constant := 19; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 20; --  user stop requested from tty
+   SIGCONT    : constant := 18; --  stopped process has been continued
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGUNUSED  : constant := 31; --  unused signal (GNU/Linux)
+   SIGSTKFLT  : constant := 16; --  coprocessor stack fault (Linux)
+   SIGLTHRRES : constant := 32; --  GNU/LinuxThreads restart signal
+   SIGLTHRCAN : constant := 33; --  GNU/LinuxThreads cancel signal
+   SIGLTHRDBG : constant := 34; --  GNU/LinuxThreads debugger signal
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   Unmasked    : constant Signal_Set := (
+      SIGTRAP,
+      --  To enable debugging on multithreaded applications, mark SIGTRAP to
+      --  be kept unmasked.
+
+      SIGBUS,
+
+      SIGTTIN, SIGTTOU, SIGTSTP,
+      --  Keep these three signals unmasked so that background processes
+      --  and IO behaves as normal "C" applications
+
+      SIGPROF,
+      --  To avoid confusing the profiler
+
+      SIGKILL, SIGSTOP,
+      --  These two signals actually cannot be masked;
+      --  POSIX simply won't allow it.
+
+      SIGLTHRRES, SIGLTHRCAN, SIGLTHRDBG);
+      --  These three signals are used by GNU/LinuxThreads starting from
+      --  glibc 2.1 (future 2.2).
+
+   Reserved    : constant Signal_Set :=
+   --  I am not sure why the following two signals are reserved.
+   --  I guess they are not supported by this version of GNU/Linux.
+     (SIGVTALRM, SIGUNUSED);
+
+   type sigset_t is private;
+
+   function sigaddset (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigaddset, "sigaddset");
+
+   function sigdelset (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigdelset, "sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "sigfillset");
+
+   function sigismember (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigismember, "sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "sigemptyset");
+
+   type union_type_3 is new String (1 .. 116);
+   type siginfo_t is record
+      si_signo : int;
+      si_code  : int;
+      si_errno : int;
+      X_data   : union_type_3;
+   end record;
+   pragma Convention (C, siginfo_t);
+
+   type struct_sigaction is record
+      sa_handler   : System.Address;
+      sa_mask      : sigset_t;
+      sa_flags     : unsigned_long;
+      sa_restorer  : System.Address;
+   end record;
+   pragma Convention (C, struct_sigaction);
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   type Machine_State is record
+      eip : unsigned_long;
+      ebx : unsigned_long;
+      esp : unsigned_long;
+      ebp : unsigned_long;
+      esi : unsigned_long;
+      edi : unsigned_long;
+   end record;
+   type Machine_State_Ptr is access all Machine_State;
+
+   SA_SIGINFO  : constant := 16#04#;
+
+   SIG_BLOCK   : constant := 0;
+   SIG_UNBLOCK : constant := 1;
+   SIG_SETMASK : constant := 2;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   type timespec is private;
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timeval is private;
+
+   function To_Duration (TV : struct_timeval) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timeval (D : Duration) return struct_timeval;
+   pragma Inline (To_Timeval);
+
+   function gettimeofday
+     (tv : access struct_timeval;
+      tz : System.Address := System.Null_Address) return int;
+   pragma Import (C, gettimeofday, "gettimeofday");
+
+   function sysconf (name : int) return long;
+   pragma Import (C, sysconf);
+
+   SC_CLK_TCK          : constant := 2;
+   SC_NPROCESSORS_ONLN : constant := 84;
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_OTHER : constant := 0;
+   SCHED_FIFO  : constant := 1;
+   SCHED_RR    : constant := 2;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t is new unsigned_long;
+   subtype Thread_Id        is pthread_t;
+
+   function To_pthread_t is new Ada.Unchecked_Conversion
+     (unsigned_long, pthread_t);
+
+   type pthread_mutex_t     is limited private;
+   type pthread_cond_t      is limited private;
+   type pthread_attr_t      is limited private;
+   type pthread_mutexattr_t is limited private;
+   type pthread_condattr_t  is limited private;
+   type pthread_key_t       is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+
+   -----------
+   -- Stack --
+   -----------
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  This is a dummy procedure to share some GNULLI files
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   procedure pthread_init;
+   pragma Inline (pthread_init);
+   --  This is a dummy procedure to share some GNULLI files
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait (set : access sigset_t; sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill (thread : pthread_t; sig : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   type struct_sched_param is record
+      sched_priority : int;  --  scheduling priority
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import
+     (C, pthread_attr_setschedpolicy, "pthread_attr_setschedpolicy");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "sched_yield");
+
+   ---------------------------
+   -- P1003.1c - Section 16 --
+   ---------------------------
+
+   function pthread_attr_init
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   CPU_SETSIZE : constant := 1_024;
+
+   type bit_field is array (1 .. CPU_SETSIZE) of Boolean;
+   for bit_field'Size use CPU_SETSIZE;
+   pragma Pack (bit_field);
+   pragma Convention (C, bit_field);
+
+   type cpu_set_t is record
+      bits : bit_field;
+   end record;
+   pragma Convention (C, cpu_set_t);
+
+   function pthread_setaffinity_np
+     (thread     : pthread_t;
+      cpusetsize : size_t;
+      cpuset     : access cpu_set_t) return int;
+   pragma Import (C, pthread_setaffinity_np, "__gnat_pthread_setaffinity_np");
+
+   -------------------
+   -- Win32 compat  --
+   -------------------
+
+   -------------------
+   -- General Types --
+   -------------------
+
+   type DWORD is new Interfaces.C.unsigned_long;
+   type WORD  is new Interfaces.C.unsigned_short;
+
+   --  The LARGE_INTEGER type is actually a fixed point type
+   --  that only can represent integers. The reason for this is
+   --  easier conversion to Duration or other fixed point types.
+   --  (See Operations.Clock)
+
+   type LARGE_INTEGER is delta 1.0 range -2.0**63 .. 2.0**63 - 1.0;
+
+   subtype PSZ   is Interfaces.C.Strings.chars_ptr;
+   subtype PCHAR is Interfaces.C.Strings.chars_ptr;
+
+   subtype PVOID is System.Address;
+
+   Null_Void : constant PVOID := System.Null_Address;
+
+   type PLONG  is access all Interfaces.C.long;
+   type PDWORD is access all DWORD;
+
+   type BOOL is new Boolean;
+   for BOOL'Size use Interfaces.C.unsigned_long'Size;
+
+   -------------------------
+   -- Handles for objects --
+   -------------------------
+
+   type HANDLE is new Interfaces.C.long;
+   type PHANDLE is access all HANDLE;
+
+   subtype Win32_Thread_Id is HANDLE;
+
+   ------------------------
+   -- System Information --
+   ------------------------
+
+   type SYSTEM_INFO is record
+      dwOemId                     : DWORD;
+      dwPageSize                  : DWORD;
+      lpMinimumApplicationAddress : PVOID;
+      lpMaximumApplicationAddress : PVOID;
+      dwActiveProcessorMask       : DWORD;
+      dwNumberOfProcessors        : DWORD;
+      dwProcessorType             : DWORD;
+      dwAllocationGranularity     : DWORD;
+      dwReserved                  : DWORD;
+   end record;
+
+   procedure GetSystemInfo (SI : access SYSTEM_INFO);
+   pragma Import (Stdcall, GetSystemInfo, "GetSystemInfo");
+
+   ---------------------
+   -- Time Management --
+   ---------------------
+
+   procedure Sleep (dwMilliseconds : DWORD);
+   pragma Import (Stdcall, Sleep, External_Name => "Sleep");
+
+   type SYSTEMTIME is record
+      wYear         : WORD;
+      wMonth        : WORD;
+      wDayOfWeek    : WORD;
+      wDay          : WORD;
+      wHour         : WORD;
+      wMinute       : WORD;
+      wSecond       : WORD;
+      wMilliseconds : WORD;
+   end record;
+
+   procedure GetSystemTime (pSystemTime : access SYSTEMTIME);
+   pragma Import (Stdcall, GetSystemTime, "GetSystemTime");
+
+   procedure GetSystemTimeAsFileTime (lpFileTime : access Long_Long_Integer);
+   pragma Import (Stdcall, GetSystemTimeAsFileTime, "GetSystemTimeAsFileTime");
+
+   function SetSystemTime (pSystemTime : access SYSTEMTIME) return BOOL;
+   pragma Import (Stdcall, SetSystemTime, "SetSystemTime");
+
+   function FileTimeToSystemTime
+     (lpFileTime   : access Long_Long_Integer;
+      lpSystemTime : access SYSTEMTIME) return BOOL;
+   pragma Import (Stdcall, FileTimeToSystemTime, "FileTimeToSystemTime");
+
+   function SystemTimeToFileTime
+     (lpSystemTime : access SYSTEMTIME;
+      lpFileTime   : access Long_Long_Integer) return BOOL;
+   pragma Import (Stdcall, SystemTimeToFileTime, "SystemTimeToFileTime");
+
+   function FileTimeToLocalFileTime
+     (lpFileTime      : access Long_Long_Integer;
+      lpLocalFileTime : access Long_Long_Integer) return BOOL;
+   pragma Import (Stdcall, FileTimeToLocalFileTime, "FileTimeToLocalFileTime");
+
+   function LocalFileTimeToFileTime
+     (lpFileTime      : access Long_Long_Integer;
+      lpLocalFileTime : access Long_Long_Integer) return BOOL;
+   pragma Import (Stdcall, LocalFileTimeToFileTime, "LocalFileTimeToFileTime");
+
+   function QueryPerformanceCounter
+     (lpPerformanceCount : access LARGE_INTEGER) return BOOL;
+   pragma Import
+     (Stdcall, QueryPerformanceCounter, "QueryPerformanceCounter");
+
+   function QueryPerformanceFrequency
+     (lpFrequency : access LARGE_INTEGER) return BOOL;
+   pragma Import
+     (Stdcall, QueryPerformanceFrequency, "QueryPerformanceFrequency");
+
+   -------------
+   -- Threads --
+   -------------
+
+--   type Win32_Thread_Body is access
+--     function (arg : System.Address) return System.Address;
+--   pragma Convention (C, Thread_Body);
+
+--   function Win32_Thread_Body_Access is new
+--     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   procedure SwitchToThread;
+   pragma Import (Stdcall, SwitchToThread, "SwitchToThread");
+
+   function GetThreadTimes
+     (hThread        : HANDLE;
+      lpCreationTime : access Long_Long_Integer;
+      lpExitTime     : access Long_Long_Integer;
+      lpKernelTime   : access Long_Long_Integer;
+      lpUserTime     : access Long_Long_Integer) return BOOL;
+   pragma Import (Stdcall, GetThreadTimes, "GetThreadTimes");
+
+   -----------------------
+   -- Critical sections --
+   -----------------------
+
+   type CRITICAL_SECTION is private;
+
+   procedure InitializeCriticalSection
+     (pCriticalSection : access CRITICAL_SECTION);
+   pragma Import
+     (Stdcall, InitializeCriticalSection, "InitializeCriticalSection");
+
+   procedure EnterCriticalSection
+     (pCriticalSection : access CRITICAL_SECTION);
+   pragma Import (Stdcall, EnterCriticalSection, "EnterCriticalSection");
+
+   procedure LeaveCriticalSection
+     (pCriticalSection : access CRITICAL_SECTION);
+   pragma Import (Stdcall, LeaveCriticalSection, "LeaveCriticalSection");
+
+   procedure DeleteCriticalSection
+     (pCriticalSection : access CRITICAL_SECTION);
+   pragma Import (Stdcall, DeleteCriticalSection, "DeleteCriticalSection");
+
+   -------------------------------------------------------------
+   -- Thread Creation, Activation, Suspension And Termination --
+   -------------------------------------------------------------
+
+   subtype ProcessorId is DWORD;
+
+   type PTHREAD_START_ROUTINE is access function
+     (pThreadParameter : PVOID) return DWORD;
+   pragma Convention (Stdcall, PTHREAD_START_ROUTINE);
+
+   function To_PTHREAD_START_ROUTINE is new
+     Ada.Unchecked_Conversion (System.Address, PTHREAD_START_ROUTINE);
+
+   type SECURITY_ATTRIBUTES is record
+      nLength              : DWORD;
+      pSecurityDescriptor  : PVOID;
+      bInheritHandle       : BOOL;
+   end record;
+
+   type PSECURITY_ATTRIBUTES is access all SECURITY_ATTRIBUTES;
+
+   function CreateThread
+     (pThreadAttributes    : PSECURITY_ATTRIBUTES;
+      dwStackSize          : DWORD;
+      pStartAddress        : PTHREAD_START_ROUTINE;
+      pParameter           : PVOID;
+      dwCreationFlags      : DWORD;
+      pThreadId            : PDWORD) return HANDLE;
+   pragma Import (Stdcall, CreateThread, "CreateThread");
+
+   function BeginThreadEx
+     (pThreadAttributes    : PSECURITY_ATTRIBUTES;
+      dwStackSize          : DWORD;
+      pStartAddress        : PTHREAD_START_ROUTINE;
+      pParameter           : PVOID;
+      dwCreationFlags      : DWORD;
+      pThreadId            : PDWORD) return HANDLE;
+   pragma Import (C, BeginThreadEx, "_beginthreadex");
+
+   Debug_Process                     : constant := 16#00000001#;
+   Debug_Only_This_Process           : constant := 16#00000002#;
+   Create_Suspended                  : constant := 16#00000004#;
+   Detached_Process                  : constant := 16#00000008#;
+   Create_New_Console                : constant := 16#00000010#;
+
+   Create_New_Process_Group          : constant := 16#00000200#;
+
+   Create_No_window                  : constant := 16#08000000#;
+
+   Profile_User                      : constant := 16#10000000#;
+   Profile_Kernel                    : constant := 16#20000000#;
+   Profile_Server                    : constant := 16#40000000#;
+
+   Stack_Size_Param_Is_A_Reservation : constant := 16#00010000#;
+
+   function GetExitCodeThread
+     (hThread   : HANDLE;
+      pExitCode : PDWORD) return BOOL;
+   pragma Import (Stdcall, GetExitCodeThread, "GetExitCodeThread");
+
+   function ResumeThread (hThread : HANDLE) return DWORD;
+   pragma Import (Stdcall, ResumeThread, "ResumeThread");
+
+   function SuspendThread (hThread : HANDLE) return DWORD;
+   pragma Import (Stdcall, SuspendThread, "SuspendThread");
+
+   procedure ExitThread (dwExitCode : DWORD);
+   pragma Import (Stdcall, ExitThread, "ExitThread");
+
+   procedure EndThreadEx (dwExitCode : DWORD);
+   pragma Import (C, EndThreadEx, "_endthreadex");
+
+   function TerminateThread
+     (hThread    : HANDLE;
+      dwExitCode : DWORD) return BOOL;
+   pragma Import (Stdcall, TerminateThread, "TerminateThread");
+
+   function GetCurrentThread return HANDLE;
+   pragma Import (Stdcall, GetCurrentThread, "GetCurrentThread");
+
+   function GetCurrentProcess return HANDLE;
+   pragma Import (Stdcall, GetCurrentProcess, "GetCurrentProcess");
+
+   function GetCurrentThreadId return DWORD;
+   pragma Import (Stdcall, GetCurrentThreadId, "GetCurrentThreadId");
+
+   function TlsAlloc return DWORD;
+   pragma Import (Stdcall, TlsAlloc, "TlsAlloc");
+
+   function TlsGetValue (dwTlsIndex : DWORD) return PVOID;
+   pragma Import (Stdcall, TlsGetValue, "TlsGetValue");
+
+   function TlsSetValue (dwTlsIndex : DWORD; pTlsValue : PVOID) return BOOL;
+   pragma Import (Stdcall, TlsSetValue, "TlsSetValue");
+
+   function TlsFree (dwTlsIndex : DWORD) return BOOL;
+   pragma Import (Stdcall, TlsFree, "TlsFree");
+
+   TLS_Nothing : constant := DWORD'Last;
+
+   procedure ExitProcess (uExitCode : Interfaces.C.unsigned);
+   pragma Import (Stdcall, ExitProcess, "ExitProcess");
+
+   function WaitForSingleObject
+     (hHandle        : HANDLE;
+      dwMilliseconds : DWORD) return DWORD;
+   pragma Import (Stdcall, WaitForSingleObject, "WaitForSingleObject");
+
+   function WaitForSingleObjectEx
+     (hHandle        : HANDLE;
+      dwMilliseconds : DWORD;
+      fAlertable     : BOOL) return DWORD;
+   pragma Import (Stdcall, WaitForSingleObjectEx, "WaitForSingleObjectEx");
+
+   function SetThreadIdealProcessor
+     (hThread          : HANDLE;
+      dwIdealProcessor : ProcessorId) return DWORD;
+   pragma Import (Stdcall, SetThreadIdealProcessor, "SetThreadIdealProcessor");
+
+   Wait_Infinite : constant := DWORD'Last;
+   WAIT_TIMEOUT  : constant := 16#0000_0102#;
+   WAIT_FAILED   : constant := 16#FFFF_FFFF#;
+
+   ------------------------------------
+   -- Semaphores, Events and Mutexes --
+   ------------------------------------
+
+   function CloseHandle (hObject : HANDLE) return BOOL;
+   pragma Import (Stdcall, CloseHandle, "CloseHandle");
+
+   function CreateSemaphore
+     (pSemaphoreAttributes : PSECURITY_ATTRIBUTES;
+      lInitialCount        : Interfaces.C.long;
+      lMaximumCount        : Interfaces.C.long;
+      pName                : PSZ) return HANDLE;
+   pragma Import (Stdcall, CreateSemaphore, "CreateSemaphoreA");
+
+   function OpenSemaphore
+     (dwDesiredAccess : DWORD;
+      bInheritHandle  : BOOL;
+      pName           : PSZ) return HANDLE;
+   pragma Import (Stdcall, OpenSemaphore, "OpenSemaphoreA");
+
+   function ReleaseSemaphore
+     (hSemaphore     : HANDLE;
+      lReleaseCount  : Interfaces.C.long;
+      pPreviousCount : PLONG) return BOOL;
+   pragma Import (Stdcall, ReleaseSemaphore, "ReleaseSemaphore");
+
+   function CreateEvent
+     (pEventAttributes : PSECURITY_ATTRIBUTES;
+      bManualReset     : BOOL;
+      bInitialState    : BOOL;
+      pName            : PSZ) return HANDLE;
+   pragma Import (Stdcall, CreateEvent, "CreateEventA");
+
+   function OpenEvent
+     (dwDesiredAccess : DWORD;
+      bInheritHandle  : BOOL;
+      pName           : PSZ) return HANDLE;
+   pragma Import (Stdcall, OpenEvent, "OpenEventA");
+
+   function SetEvent (hEvent : HANDLE) return BOOL;
+   pragma Import (Stdcall, SetEvent, "SetEvent");
+
+   function ResetEvent (hEvent : HANDLE) return BOOL;
+   pragma Import (Stdcall, ResetEvent, "ResetEvent");
+
+   function PulseEvent (hEvent : HANDLE) return BOOL;
+   pragma Import (Stdcall, PulseEvent, "PulseEvent");
+
+   function CreateMutex
+     (pMutexAttributes : PSECURITY_ATTRIBUTES;
+      bInitialOwner    : BOOL;
+      pName            : PSZ) return HANDLE;
+   pragma Import (Stdcall, CreateMutex, "CreateMutexA");
+
+   function OpenMutex
+     (dwDesiredAccess : DWORD;
+      bInheritHandle  : BOOL;
+      pName           : PSZ) return HANDLE;
+   pragma Import (Stdcall, OpenMutex, "OpenMutexA");
+
+   function ReleaseMutex (hMutex : HANDLE) return BOOL;
+   pragma Import (Stdcall, ReleaseMutex, "ReleaseMutex");
+
+   ---------------------------------------------------
+   -- Accessing properties of Threads and Processes --
+   ---------------------------------------------------
+
+   -----------------
+   --  Priorities --
+   -----------------
+
+   function SetThreadPriority
+     (hThread   : HANDLE;
+      nPriority : Interfaces.C.int) return BOOL;
+   pragma Import (Stdcall, SetThreadPriority, "SetThreadPriority");
+
+   function GetThreadPriority (hThread : HANDLE) return Interfaces.C.int;
+   pragma Import (Stdcall, GetThreadPriority, "GetThreadPriority");
+
+   function SetPriorityClass
+     (hProcess        : HANDLE;
+      dwPriorityClass : DWORD) return BOOL;
+   pragma Import (Stdcall, SetPriorityClass, "SetPriorityClass");
+
+   procedure SetThreadPriorityBoost
+     (hThread              : HANDLE;
+      DisablePriorityBoost : BOOL);
+   pragma Import (Stdcall, SetThreadPriorityBoost, "SetThreadPriorityBoost");
+
+   Normal_Priority_Class   : constant := 16#00000020#;
+   Idle_Priority_Class     : constant := 16#00000040#;
+   High_Priority_Class     : constant := 16#00000080#;
+   Realtime_Priority_Class : constant := 16#00000100#;
+
+   Thread_Priority_Idle          : constant := -15;
+   Thread_Priority_Lowest        : constant := -2;
+   Thread_Priority_Below_Normal  : constant := -1;
+   Thread_Priority_Normal        : constant := 0;
+   Thread_Priority_Above_Normal  : constant := 1;
+   Thread_Priority_Highest       : constant := 2;
+   Thread_Priority_Time_Critical : constant := 15;
+   Thread_Priority_Error_Return  : constant := Interfaces.C.long'Last;
+
+   function GetLastError return DWORD;
+   pragma Import (Stdcall, GetLastError, "GetLastError");
+
+private
+
+   type sigset_t is array (0 .. 127) of unsigned_char;
+   pragma Convention (C, sigset_t);
+   for sigset_t'Alignment use unsigned_long'Alignment;
+
+   type pid_t is new int;
+
+   type time_t is new long;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type struct_timeval is record
+      tv_sec  : time_t;
+      tv_usec : time_t;
+   end record;
+   pragma Convention (C, struct_timeval);
+
+   type pthread_attr_t is record
+      detachstate   : int;
+      schedpolicy   : int;
+      schedparam    : struct_sched_param;
+      inheritsched  : int;
+      scope         : int;
+      guardsize     : size_t;
+      stackaddr_set : int;
+      stackaddr     : System.Address;
+      stacksize     : size_t;
+   end record;
+   pragma Convention (C, pthread_attr_t);
+
+   type pthread_condattr_t is record
+      dummy : int;
+   end record;
+   pragma Convention (C, pthread_condattr_t);
+
+   type pthread_mutexattr_t is record
+      mutexkind : int;
+   end record;
+   pragma Convention (C, pthread_mutexattr_t);
+
+   type struct_pthread_fast_lock is record
+      status   : long;
+      spinlock : int;
+   end record;
+   pragma Convention (C, struct_pthread_fast_lock);
+
+   type pthread_mutex_t is record
+      m_reserved : int;
+      m_count    : int;
+      m_owner    : System.Address;
+      m_kind     : int;
+      m_lock     : struct_pthread_fast_lock;
+   end record;
+   pragma Convention (C, pthread_mutex_t);
+
+   type pthread_cond_t is array (0 .. 47) of unsigned_char;
+   pragma Convention (C, pthread_cond_t);
+
+   type pthread_key_t is new unsigned;
+
+   -------------------
+   -- Win32 private --
+   -------------------
+
+   type CRITICAL_SECTION is record
+      DebugInfo      : System.Address;
+      --  The following three fields control entering and
+      --  exiting the critical section for the resource
+      LockCount      : Long_Integer;
+      RecursionCount : Long_Integer;
+      OwningThread   : HANDLE;
+      LockSemaphore  : HANDLE;
+      Reserved       : DWORD;
+   end record;
+
+end System.OS_Interface;
diff --git a/gcc/ada/s-taprop-cygwin.adb b/gcc/ada/s-taprop-cygwin.adb
new file mode 100644
index 000000000..0d13c308a
--- /dev/null
+++ b/gcc/ada/s-taprop-cygwin.adb
@@ -0,0 +1,1339 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --
+--                                                                          --
+--     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --
+--                                                                          --
+--                                  B o d y                                 --
+--                                                                          --
+--         Copyright (C) 1992-2007, Free Software Foundation, Inc.          --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNARL; see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is a GNU/Linux (GNU/LinuxThreads) version of this package
+
+--  This package contains all the GNULL primitives that interface directly
+--  with the underlying OS.
+
+pragma Polling (Off);
+--  Turn off polling, we do not want ATC polling to take place during
+--  tasking operations. It causes infinite loops and other problems.
+
+with Interfaces.C;
+--  used for int
+--           size_t
+
+with System.Task_Info;
+--  used for Unspecified_Task_Info
+
+with System.Tasking.Debug;
+--  used for Known_Tasks
+
+with System.Interrupt_Management;
+--  used for Keep_Unmasked
+--           Abort_Task_Interrupt
+--           Interrupt_ID
+
+with System.OS_Primitives;
+--  used for Delay_Modes
+
+with System.Soft_Links;
+--  used for Abort_Defer/Undefer
+
+--  We use System.Soft_Links instead of System.Tasking.Initialization
+--  because the later is a higher level package that we shouldn't depend on.
+--  For example when using the restricted run time, it is replaced by
+--  System.Tasking.Restricted.Stages.
+
+with System.Storage_Elements;
+with System.Stack_Checking.Operations;
+--  Used for Invalidate_Stack_Cache and Notify_Stack_Attributes;
+
+with Ada.Exceptions;
+--  used for Raise_Exception
+--           Raise_From_Signal_Handler
+--           Exception_Id
+
+with Ada.Unchecked_Conversion;
+with Ada.Unchecked_Deallocation;
+
+package body System.Task_Primitives.Operations is
+
+   package SSL renames System.Soft_Links;
+   package SC renames System.Stack_Checking.Operations;
+
+   use System.Tasking.Debug;
+   use System.Tasking;
+   use Interfaces.C;
+   use System.OS_Interface;
+   use System.Parameters;
+   use System.OS_Primitives;
+   use System.Storage_Elements;
+   use System.Task_Info;
+
+   ----------------
+   -- Local Data --
+   ----------------
+
+   --  The followings are logically constants, but need to be initialized
+   --  at run time.
+
+   Single_RTS_Lock : aliased RTS_Lock;
+   --  This is a lock to allow only one thread of control in the RTS at
+   --  a time; it is used to execute in mutual exclusion from all other tasks.
+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List
+
+   ATCB_Key : aliased pthread_key_t;
+   --  Key used to find the Ada Task_Id associated with a thread
+
+   Environment_Task_Id : Task_Id;
+   --  A variable to hold Task_Id for the environment task
+
+   Unblocked_Signal_Mask : aliased sigset_t;
+   --  The set of signals that should be unblocked in all tasks
+
+   --  The followings are internal configuration constants needed
+
+   Next_Serial_Number : Task_Serial_Number := 100;
+   --  We start at 100 (reserve some special values for using in error checks)
+
+   Time_Slice_Val : Integer;
+   pragma Import (C, Time_Slice_Val, "__gl_time_slice_val");
+
+   Dispatching_Policy : Character;
+   pragma Import (C, Dispatching_Policy, "__gl_task_dispatching_policy");
+
+   --  The following are effectively constants, but they need to be initialized
+   --  by calling a pthread_ function.
+
+   Mutex_Attr   : aliased pthread_mutexattr_t;
+   Cond_Attr    : aliased pthread_condattr_t;
+
+   Foreign_Task_Elaborated : aliased Boolean := True;
+   --  Used to identified fake tasks (i.e., non-Ada Threads)
+
+   --------------------
+   -- Local Packages --
+   --------------------
+
+   package Specific is
+
+      procedure Initialize (Environment_Task : Task_Id);
+      pragma Inline (Initialize);
+      --  Initialize various data needed by this package
+
+      function Is_Valid_Task return Boolean;
+      pragma Inline (Is_Valid_Task);
+      --  Does executing thread have a TCB?
+
+      procedure Set (Self_Id : Task_Id);
+      pragma Inline (Set);
+      --  Set the self id for the current task
+
+      function Self return Task_Id;
+      pragma Inline (Self);
+      --  Return a pointer to the Ada Task Control Block of the calling task
+
+   end Specific;
+
+   package body Specific is separate;
+   --  The body of this package is target specific
+
+   ---------------------------------
+   -- Support for foreign threads --
+   ---------------------------------
+
+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;
+   --  Allocate and Initialize a new ATCB for the current Thread
+
+   function Register_Foreign_Thread
+     (Thread : Thread_Id) return Task_Id is separate;
+
+   -----------------------
+   -- Local Subprograms --
+   -----------------------
+
+   subtype unsigned_long is Interfaces.C.unsigned_long;
+
+   procedure Abort_Handler (signo : Signal);
+
+   function To_pthread_t is new Ada.Unchecked_Conversion
+     (unsigned_long, System.OS_Interface.pthread_t);
+
+   procedure Get_Stack_Attributes
+     (T    : Task_Id;
+      ISP  : out System.Address;
+      Size : out Storage_Offset);
+   --  Fill ISP and Size with the Initial Stack Pointer value and the
+   --  thread stack size for task T.
+
+   -------------------
+   -- Abort_Handler --
+   -------------------
+
+   procedure Abort_Handler (signo : Signal) is
+      pragma Unreferenced (signo);
+
+      Self_Id : constant Task_Id := Self;
+      Result  : Interfaces.C.int;
+      Old_Set : aliased sigset_t;
+
+   begin
+      if ZCX_By_Default and then GCC_ZCX_Support then
+         return;
+      end if;
+
+      if Self_Id.Deferral_Level = 0
+        and then Self_Id.Pending_ATC_Level < Self_Id.ATC_Nesting_Level
+        and then not Self_Id.Aborting
+      then
+         Self_Id.Aborting := True;
+
+         --  Make sure signals used for RTS internal purpose are unmasked
+
+         Result :=
+           pthread_sigmask
+             (SIG_UNBLOCK,
+              Unblocked_Signal_Mask'Access,
+              Old_Set'Access);
+         pragma Assert (Result = 0);
+
+         raise Standard'Abort_Signal;
+      end if;
+   end Abort_Handler;
+
+   --------------
+   -- Lock_RTS --
+   --------------
+
+   procedure Lock_RTS is
+   begin
+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);
+   end Lock_RTS;
+
+   ----------------
+   -- Unlock_RTS --
+   ----------------
+
+   procedure Unlock_RTS is
+   begin
+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);
+   end Unlock_RTS;
+
+   -----------------
+   -- Stack_Guard --
+   -----------------
+
+   --  The underlying thread system extends the memory (up to 2MB) when needed
+
+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is
+      pragma Unreferenced (T);
+      pragma Unreferenced (On);
+   begin
+      null;
+   end Stack_Guard;
+
+   --------------------
+   -- Get_Thread_Id  --
+   --------------------
+
+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is
+   begin
+      return T.Common.LL.Thread;
+   end Get_Thread_Id;
+
+   ----------
+   -- Self --
+   ----------
+
+   function Self return Task_Id renames Specific.Self;
+
+   ---------------------
+   -- Initialize_Lock --
+   ---------------------
+
+   --  Note: mutexes and cond_variables needed per-task basis are
+   --  initialized in Initialize_TCB and the Storage_Error is
+   --  handled. Other mutexes (such as RTS_Lock, Memory_Lock...)
+   --  used in RTS is initialized before any status change of RTS.
+   --  Therefore rasing Storage_Error in the following routines
+   --  should be able to be handled safely.
+
+   procedure Initialize_Lock
+     (Prio : System.Any_Priority;
+      L    : not null access Lock)
+   is
+      pragma Unreferenced (Prio);
+
+      Result : Interfaces.C.int;
+
+   begin
+      Result := pthread_mutex_init (L, Mutex_Attr'Access);
+
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result = ENOMEM then
+         Ada.Exceptions.Raise_Exception (Storage_Error'Identity,
+           "Failed to allocate a lock");
+      end if;
+   end Initialize_Lock;
+
+   procedure Initialize_Lock
+     (L     : not null access RTS_Lock;
+      Level : Lock_Level)
+   is
+      pragma Unreferenced (Level);
+
+      Result : Interfaces.C.int;
+
+   begin
+      Result := pthread_mutex_init (L, Mutex_Attr'Access);
+
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result = ENOMEM then
+         raise Storage_Error;
+      end if;
+   end Initialize_Lock;
+
+   -------------------
+   -- Finalize_Lock --
+   -------------------
+
+   procedure Finalize_Lock (L : not null access Lock) is
+      Result : Interfaces.C.int;
+   begin
+      Result := pthread_mutex_destroy (L);
+      pragma Assert (Result = 0);
+   end Finalize_Lock;
+
+   procedure Finalize_Lock (L : not null access RTS_Lock) is
+      Result : Interfaces.C.int;
+   begin
+      Result := pthread_mutex_destroy (L);
+      pragma Assert (Result = 0);
+   end Finalize_Lock;
+
+   ----------------
+   -- Write_Lock --
+   ----------------
+
+   procedure Write_Lock
+     (L                 : not null access Lock;
+      Ceiling_Violation : out Boolean)
+   is
+      Result : Interfaces.C.int;
+   begin
+      Result := pthread_mutex_lock (L);
+      Ceiling_Violation := Result = EINVAL;
+
+      --  Assume the cause of EINVAL is a priority ceiling violation
+
+      pragma Assert (Result = 0 or else Result = EINVAL);
+   end Write_Lock;
+
+   procedure Write_Lock
+     (L           : not null access RTS_Lock;
+      Global_Lock : Boolean := False)
+   is
+      Result : Interfaces.C.int;
+   begin
+      if not Single_Lock or else Global_Lock then
+         Result := pthread_mutex_lock (L);
+         pragma Assert (Result = 0);
+      end if;
+   end Write_Lock;
+
+   procedure Write_Lock (T : Task_Id) is
+      Result : Interfaces.C.int;
+   begin
+      if not Single_Lock then
+         Result := pthread_mutex_lock (T.Common.LL.L'Access);
+         pragma Assert (Result = 0);
+      end if;
+   end Write_Lock;
+
+   ---------------
+   -- Read_Lock --
+   ---------------
+
+   procedure Read_Lock
+     (L                 : not null access Lock;
+      Ceiling_Violation : out Boolean)
+   is
+   begin
+      Write_Lock (L, Ceiling_Violation);
+   end Read_Lock;
+
+   ------------
+   -- Unlock --
+   ------------
+
+   procedure Unlock (L : not null access Lock) is
+      Result : Interfaces.C.int;
+   begin
+      Result := pthread_mutex_unlock (L);
+      pragma Assert (Result = 0);
+   end Unlock;
+
+   procedure Unlock
+     (L           : not null access RTS_Lock;
+      Global_Lock : Boolean := False)
+   is
+      Result : Interfaces.C.int;
+   begin
+      if not Single_Lock or else Global_Lock then
+         Result := pthread_mutex_unlock (L);
+         pragma Assert (Result = 0);
+      end if;
+   end Unlock;
+
+   procedure Unlock (T : Task_Id) is
+      Result : Interfaces.C.int;
+   begin
+      if not Single_Lock then
+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);
+         pragma Assert (Result = 0);
+      end if;
+   end Unlock;
+
+   -----------------
+   -- Set_Ceiling --
+   -----------------
+
+   --  Dynamic priority ceilings are not supported by the underlying system
+
+   procedure Set_Ceiling
+     (L    : not null access Lock;
+      Prio : System.Any_Priority)
+   is
+      pragma Unreferenced (L, Prio);
+   begin
+      null;
+   end Set_Ceiling;
+
+   -----------
+   -- Sleep --
+   -----------
+
+   procedure Sleep
+     (Self_ID  : Task_Id;
+      Reason   : System.Tasking.Task_States)
+   is
+      pragma Unreferenced (Reason);
+
+      Result : Interfaces.C.int;
+
+   begin
+      pragma Assert (Self_ID = Self);
+
+      if Single_Lock then
+         Result :=
+           pthread_cond_wait
+             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);
+      else
+         Result :=
+           pthread_cond_wait
+             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);
+      end if;
+
+      --  EINTR is not considered a failure
+
+      pragma Assert (Result = 0 or else Result = EINTR);
+   end Sleep;
+
+   -----------------
+   -- Timed_Sleep --
+   -----------------
+
+   --  This is for use within the run-time system, so abort is
+   --  assumed to be already deferred, and the caller should be
+   --  holding its own ATCB lock.
+
+   procedure Timed_Sleep
+     (Self_ID  : Task_Id;
+      Time     : Duration;
+      Mode     : ST.Delay_Modes;
+      Reason   : System.Tasking.Task_States;
+      Timedout : out Boolean;
+      Yielded  : out Boolean)
+   is
+      pragma Unreferenced (Reason);
+
+      Base_Time  : constant Duration := Monotonic_Clock;
+      Check_Time : Duration := Base_Time;
+      Abs_Time   : Duration;
+      Request    : aliased timespec;
+      Result     : Interfaces.C.int;
+
+   begin
+      Timedout := True;
+      Yielded := False;
+
+      if Mode = Relative then
+         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;
+      else
+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);
+      end if;
+
+      if Abs_Time > Check_Time then
+         Request := To_Timespec (Abs_Time);
+
+         loop
+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;
+
+            if Single_Lock then
+               Result :=
+                 pthread_cond_timedwait
+                   (Self_ID.Common.LL.CV'Access,
+                    Single_RTS_Lock'Access,
+                    Request'Access);
+
+            else
+               Result :=
+                 pthread_cond_timedwait
+                   (Self_ID.Common.LL.CV'Access,
+                    Self_ID.Common.LL.L'Access,
+                    Request'Access);
+            end if;
+
+            Check_Time := Monotonic_Clock;
+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;
+
+            if Result = 0 or else Result = EINTR then
+
+               --  Somebody may have called Wakeup for us
+
+               Timedout := False;
+               exit;
+            end if;
+
+            pragma Assert (Result = ETIMEDOUT);
+         end loop;
+      end if;
+   end Timed_Sleep;
+
+   -----------------
+   -- Timed_Delay --
+   -----------------
+
+   --  This is for use in implementing delay statements, so we assume the
+   --  caller is abort-deferred but is holding no locks.
+
+   procedure Timed_Delay
+     (Self_ID : Task_Id;
+      Time    : Duration;
+      Mode    : ST.Delay_Modes)
+   is
+      Base_Time  : constant Duration := Monotonic_Clock;
+      Check_Time : Duration := Base_Time;
+      Abs_Time   : Duration;
+      Request    : aliased timespec;
+
+      Result : Interfaces.C.int;
+      pragma Warnings (Off, Result);
+
+   begin
+      if Single_Lock then
+         Lock_RTS;
+      end if;
+
+      Write_Lock (Self_ID);
+
+      if Mode = Relative then
+         Abs_Time := Time + Check_Time;
+      else
+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);
+      end if;
+
+      if Abs_Time > Check_Time then
+         Request := To_Timespec (Abs_Time);
+         Self_ID.Common.State := Delay_Sleep;
+
+         loop
+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;
+
+            if Single_Lock then
+               Result := pthread_cond_timedwait
+                           (Self_ID.Common.LL.CV'Access,
+                            Single_RTS_Lock'Access,
+                            Request'Access);
+            else
+               Result := pthread_cond_timedwait
+                           (Self_ID.Common.LL.CV'Access,
+                            Self_ID.Common.LL.L'Access,
+                            Request'Access);
+            end if;
+
+            Check_Time := Monotonic_Clock;
+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;
+
+            pragma Assert (Result = 0 or else
+              Result = ETIMEDOUT or else
+              Result = EINTR);
+         end loop;
+
+         Self_ID.Common.State := Runnable;
+      end if;
+
+      Unlock (Self_ID);
+
+      if Single_Lock then
+         Unlock_RTS;
+      end if;
+
+      Result := sched_yield;
+   end Timed_Delay;
+
+   ---------------------
+   -- Monotonic_Clock --
+   ---------------------
+
+   function Monotonic_Clock return Duration is
+      TV     : aliased struct_timeval;
+      Result : Interfaces.C.int;
+   begin
+      Result := gettimeofday (TV'Access, System.Null_Address);
+      pragma Assert (Result = 0);
+      return To_Duration (TV);
+   end Monotonic_Clock;
+
+   -------------------
+   -- RT_Resolution --
+   -------------------
+
+   function RT_Resolution return Duration is
+   begin
+      return 10#1.0#E-6;
+   end RT_Resolution;
+
+   ------------
+   -- Wakeup --
+   ------------
+
+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is
+      pragma Unreferenced (Reason);
+      Result : Interfaces.C.int;
+   begin
+      Result := pthread_cond_signal (T.Common.LL.CV'Access);
+      pragma Assert (Result = 0);
+   end Wakeup;
+
+   -----------
+   -- Yield --
+   -----------
+
+   procedure Yield (Do_Yield : Boolean := True) is
+      Result : Interfaces.C.int;
+      pragma Unreferenced (Result);
+   begin
+      if Do_Yield then
+         Result := sched_yield;
+      end if;
+   end Yield;
+
+   ------------------
+   -- Set_Priority --
+   ------------------
+
+   procedure Set_Priority
+     (T                   : Task_Id;
+      Prio                : System.Any_Priority;
+      Loss_Of_Inheritance : Boolean := False)
+   is
+      pragma Unreferenced (Loss_Of_Inheritance);
+
+      Result : Interfaces.C.int;
+      Param  : aliased struct_sched_param;
+
+      function Get_Policy (Prio : System.Any_Priority) return Character;
+      pragma Import (C, Get_Policy, "__gnat_get_specific_dispatching");
+      --  Get priority specific dispatching policy
+
+      Priority_Specific_Policy : constant Character := Get_Policy (Prio);
+      --  Upper case first character of the policy name corresponding to the
+      --  task as set by a Priority_Specific_Dispatching pragma.
+
+   begin
+      T.Common.Current_Priority := Prio;
+
+      --  Priorities on Cygwin follow Win32 standards, we use the
+      --  MinGW conversion table.
+
+      Param.sched_priority := Interfaces.C.int (Underlying_Priorities (Prio));
+
+      if Dispatching_Policy = 'R'
+        or else Priority_Specific_Policy = 'R'
+        or else Time_Slice_Val > 0
+      then
+         Result :=
+           pthread_setschedparam
+             (T.Common.LL.Thread, SCHED_RR, Param'Access);
+
+      elsif Dispatching_Policy = 'F'
+        or else Priority_Specific_Policy = 'F'
+        or else Time_Slice_Val = 0
+      then
+         Result :=
+           pthread_setschedparam
+             (T.Common.LL.Thread, SCHED_FIFO, Param'Access);
+
+      else
+         Param.sched_priority := 0;
+         Result :=
+           pthread_setschedparam
+             (T.Common.LL.Thread,
+              SCHED_OTHER, Param'Access);
+      end if;
+
+      pragma Assert (Result = 0 or else Result = EPERM);
+   end Set_Priority;
+
+   ------------------
+   -- Get_Priority --
+   ------------------
+
+   function Get_Priority (T : Task_Id) return System.Any_Priority is
+   begin
+      return T.Common.Current_Priority;
+   end Get_Priority;
+
+   --------------------------
+   -- Get_Stack_Attributes --
+   --------------------------
+
+   procedure Get_Stack_Attributes
+     (T    : Task_Id;
+      ISP  : out System.Address;
+      Size : out Storage_Offset)
+   is
+      function pthread_getattr_np
+        (thread : pthread_t;
+         attr   : System.Address) return Interfaces.C.int;
+      pragma Import (C, pthread_getattr_np, "pthread_getattr_np");
+
+      function pthread_attr_getstack
+        (attr : System.Address;
+         base : System.Address;
+         size : System.Address) return Interfaces.C.int;
+      pragma Import (C, pthread_attr_getstack, "pthread_attr_getstack");
+
+      Result : Interfaces.C.int;
+
+      Attributes : aliased pthread_attr_t;
+      Stack_Base : aliased System.Address;
+      Stack_Size : aliased Storage_Offset;
+
+   begin
+      Result :=
+        pthread_getattr_np
+          (T.Common.LL.Thread, Attributes'Address);
+      pragma Assert (Result = 0);
+
+      Result :=
+        pthread_attr_getstack
+          (Attributes'Address, Stack_Base'Address, Stack_Size'Address);
+      pragma Assert (Result = 0);
+
+      Result := pthread_attr_destroy (Attributes'Access);
+      pragma Assert (Result = 0);
+
+      ISP  := Stack_Base + Stack_Size;
+      Size := Stack_Size;
+   end Get_Stack_Attributes;
+
+   ----------------
+   -- Enter_Task --
+   ----------------
+
+   procedure Enter_Task (Self_ID : Task_Id) is
+   begin
+      if Self_ID.Common.Task_Info /= null
+        and then
+          Self_ID.Common.Task_Info.CPU_Affinity = No_CPU
+      then
+         raise Invalid_CPU_Number;
+      end if;
+
+      Self_ID.Common.LL.Thread := pthread_self;
+
+      Specific.Set (Self_ID);
+
+      Lock_RTS;
+
+      for J in Known_Tasks'Range loop
+         if Known_Tasks (J) = null then
+            Known_Tasks (J) := Self_ID;
+            Self_ID.Known_Tasks_Index := J;
+            exit;
+         end if;
+      end loop;
+
+      Unlock_RTS;
+
+      --  Determine where the task stack starts, how large it is, and let the
+      --  stack checking engine know about it.
+
+      declare
+         Initial_SP : System.Address;
+         Stack_Size : Storage_Offset;
+      begin
+         Get_Stack_Attributes (Self_ID, Initial_SP, Stack_Size);
+         System.Stack_Checking.Operations.Notify_Stack_Attributes
+           (Initial_SP, Stack_Size);
+      end;
+   end Enter_Task;
+
+   --------------
+   -- New_ATCB --
+   --------------
+
+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is
+   begin
+      return new Ada_Task_Control_Block (Entry_Num);
+   end New_ATCB;
+
+   -------------------
+   -- Is_Valid_Task --
+   -------------------
+
+   function Is_Valid_Task return Boolean renames Specific.Is_Valid_Task;
+
+   -----------------------------
+   -- Register_Foreign_Thread --
+   -----------------------------
+
+   function Register_Foreign_Thread return Task_Id is
+   begin
+      if Is_Valid_Task then
+         return Self;
+      else
+         return Register_Foreign_Thread (pthread_self);
+      end if;
+   end Register_Foreign_Thread;
+
+   --------------------
+   -- Initialize_TCB --
+   --------------------
+
+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is
+      Result : Interfaces.C.int;
+
+   begin
+      --  Give the task a unique serial number
+
+      Self_ID.Serial_Number := Next_Serial_Number;
+      Next_Serial_Number := Next_Serial_Number + 1;
+      pragma Assert (Next_Serial_Number /= 0);
+
+      Self_ID.Common.LL.Thread := To_pthread_t (-1);
+
+      if not Single_Lock then
+         Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,
+           Mutex_Attr'Access);
+         pragma Assert (Result = 0 or else Result = ENOMEM);
+
+         if Result /= 0 then
+            Succeeded := False;
+            return;
+         end if;
+      end if;
+
+      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,
+        Cond_Attr'Access);
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result = 0 then
+         Succeeded := True;
+      else
+         if not Single_Lock then
+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);
+            pragma Assert (Result = 0);
+         end if;
+
+         Succeeded := False;
+      end if;
+   end Initialize_TCB;
+
+   -----------------
+   -- Create_Task --
+   -----------------
+
+   procedure Create_Task
+     (T          : Task_Id;
+      Wrapper    : System.Address;
+      Stack_Size : System.Parameters.Size_Type;
+      Priority   : System.Any_Priority;
+      Succeeded  : out Boolean)
+   is
+      Attributes : aliased pthread_attr_t;
+      Result     : Interfaces.C.int;
+
+   begin
+      Result := pthread_attr_init (Attributes'Access);
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result /= 0 then
+         Succeeded := False;
+         return;
+      end if;
+
+      Result :=
+        pthread_attr_setstacksize
+          (Attributes'Access, Interfaces.C.size_t (Stack_Size));
+      pragma Assert (Result = 0);
+
+      Result :=
+        pthread_attr_setdetachstate
+          (Attributes'Access, PTHREAD_CREATE_DETACHED);
+      pragma Assert (Result = 0);
+
+      --  Since the initial signal mask of a thread is inherited from the
+      --  creator, and the Environment task has all its signals masked, we
+      --  do not need to manipulate caller's signal mask at this point.
+      --  All tasks in RTS will have All_Tasks_Mask initially.
+
+      Result := pthread_create
+        (T.Common.LL.Thread'Access,
+         Attributes'Access,
+         Thread_Body_Access (Wrapper),
+         To_Address (T));
+      pragma Assert (Result = 0 or else Result = EAGAIN);
+
+      Succeeded := Result = 0;
+
+      --  Handle Task_Info
+
+      if T.Common.Task_Info /= null then
+         if T.Common.Task_Info.CPU_Affinity /= Task_Info.Any_CPU then
+            Result :=
+              pthread_setaffinity_np
+                (T.Common.LL.Thread,
+                 CPU_SETSIZE / 8,
+                 T.Common.Task_Info.CPU_Affinity'Access);
+            pragma Assert (Result = 0);
+         end if;
+      end if;
+
+      Result := pthread_attr_destroy (Attributes'Access);
+      pragma Assert (Result = 0);
+
+      Set_Priority (T, Priority);
+   end Create_Task;
+
+   ------------------
+   -- Finalize_TCB --
+   ------------------
+
+   procedure Finalize_TCB (T : Task_Id) is
+      Result  : Interfaces.C.int;
+      Tmp     : Task_Id := T;
+      Is_Self : constant Boolean := T = Self;
+
+      procedure Free is new
+        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);
+
+   begin
+      if not Single_Lock then
+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);
+         pragma Assert (Result = 0);
+      end if;
+
+      Result := pthread_cond_destroy (T.Common.LL.CV'Access);
+      pragma Assert (Result = 0);
+
+      if T.Known_Tasks_Index /= -1 then
+         Known_Tasks (T.Known_Tasks_Index) := null;
+      end if;
+      SC.Invalidate_Stack_Cache (T.Common.Compiler_Data.Pri_Stack_Info'Access);
+      Free (Tmp);
+
+      if Is_Self then
+         Specific.Set (null);
+      end if;
+   end Finalize_TCB;
+
+   ---------------
+   -- Exit_Task --
+   ---------------
+
+   procedure Exit_Task is
+   begin
+      Specific.Set (null);
+   end Exit_Task;
+
+   ----------------
+   -- Abort_Task --
+   ----------------
+
+   procedure Abort_Task (T : Task_Id) is
+      Result : Interfaces.C.int;
+   begin
+      Result :=
+        pthread_kill
+          (T.Common.LL.Thread,
+           Signal (System.Interrupt_Management.Abort_Task_Interrupt));
+      pragma Assert (Result = 0);
+   end Abort_Task;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize (S : in out Suspension_Object) is
+      Result : Interfaces.C.int;
+
+   begin
+      --  Initialize internal state (always to False (RM D.10(6)))
+
+      S.State := False;
+      S.Waiting := False;
+
+      --  Initialize internal mutex
+
+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);
+
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result = ENOMEM then
+         raise Storage_Error;
+      end if;
+
+      --  Initialize internal condition variable
+
+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);
+
+      pragma Assert (Result = 0 or else Result = ENOMEM);
+
+      if Result /= 0 then
+         Result := pthread_mutex_destroy (S.L'Access);
+         pragma Assert (Result = 0);
+
+         if Result = ENOMEM then
+            raise Storage_Error;
+         end if;
+      end if;
+   end Initialize;
+
+   --------------
+   -- Finalize --
+   --------------
+
+   procedure Finalize (S : in out Suspension_Object) is
+      Result : Interfaces.C.int;
+
+   begin
+      --  Destroy internal mutex
+
+      Result := pthread_mutex_destroy (S.L'Access);
+      pragma Assert (Result = 0);
+
+      --  Destroy internal condition variable
+
+      Result := pthread_cond_destroy (S.CV'Access);
+      pragma Assert (Result = 0);
+   end Finalize;
+
+   -------------------
+   -- Current_State --
+   -------------------
+
+   function Current_State (S : Suspension_Object) return Boolean is
+   begin
+      --  We do not want to use lock on this read operation. State is marked
+      --  as Atomic so that we ensure that the value retrieved is correct.
+
+      return S.State;
+   end Current_State;
+
+   ---------------
+   -- Set_False --
+   ---------------
+
+   procedure Set_False (S : in out Suspension_Object) is
+      Result : Interfaces.C.int;
+
+   begin
+      SSL.Abort_Defer.all;
+
+      Result := pthread_mutex_lock (S.L'Access);
+      pragma Assert (Result = 0);
+
+      S.State := False;
+
+      Result := pthread_mutex_unlock (S.L'Access);
+      pragma Assert (Result = 0);
+
+      SSL.Abort_Undefer.all;
+   end Set_False;
+
+   --------------
+   -- Set_True --
+   --------------
+
+   procedure Set_True (S : in out Suspension_Object) is
+      Result : Interfaces.C.int;
+
+   begin
+      SSL.Abort_Defer.all;
+
+      Result := pthread_mutex_lock (S.L'Access);
+      pragma Assert (Result = 0);
+
+      --  If there is already a task waiting on this suspension object then
+      --  we resume it, leaving the state of the suspension object to False,
+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves
+      --  the state to True.
+
+      if S.Waiting then
+         S.Waiting := False;
+         S.State := False;
+
+         Result := pthread_cond_signal (S.CV'Access);
+         pragma Assert (Result = 0);
+
+      else
+         S.State := True;
+      end if;
+
+      Result := pthread_mutex_unlock (S.L'Access);
+      pragma Assert (Result = 0);
+
+      SSL.Abort_Undefer.all;
+   end Set_True;
+
+   ------------------------
+   -- Suspend_Until_True --
+   ------------------------
+
+   procedure Suspend_Until_True (S : in out Suspension_Object) is
+      Result : Interfaces.C.int;
+
+   begin
+      SSL.Abort_Defer.all;
+
+      Result := pthread_mutex_lock (S.L'Access);
+      pragma Assert (Result = 0);
+
+      if S.Waiting then
+
+         --  Program_Error must be raised upon calling Suspend_Until_True
+         --  if another task is already waiting on that suspension object
+         --  (RM D.10(10)).
+
+         Result := pthread_mutex_unlock (S.L'Access);
+         pragma Assert (Result = 0);
+
+         SSL.Abort_Undefer.all;
+
+         raise Program_Error;
+      else
+         --  Suspend the task if the state is False. Otherwise, the task
+         --  continues its execution, and the state of the suspension object
+         --  is set to False (ARM D.10 par. 9).
+
+         if S.State then
+            S.State := False;
+         else
+            S.Waiting := True;
+            Result := pthread_cond_wait (S.CV'Access, S.L'Access);
+         end if;
+
+         Result := pthread_mutex_unlock (S.L'Access);
+         pragma Assert (Result = 0);
+
+         SSL.Abort_Undefer.all;
+      end
+      if;
+   end Suspend_Until_True;
+
+   ----------------
+   -- Check_Exit --
+   ----------------
+
+   --  Dummy version
+
+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is
+      pragma Unreferenced (Self_ID);
+   begin
+      return True;
+   end Check_Exit;
+
+   --------------------
+   -- Check_No_Locks --
+   --------------------
+
+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is
+      pragma Unreferenced (Self_ID);
+   begin
+      return True;
+   end Check_No_Locks;
+
+   ----------------------
+   -- Environment_Task --
+   ----------------------
+
+   function Environment_Task return Task_Id is
+   begin
+      return Environment_Task_Id;
+   end Environment_Task;
+
+   ------------------
+   -- Suspend_Task --
+   ------------------
+
+   function Suspend_Task
+     (T           : ST.Task_Id;
+      Thread_Self : Thread_Id) return Boolean
+   is
+   begin
+      if T.Common.LL.Thread /= Thread_Self then
+         return pthread_kill (T.Common.LL.Thread, SIGSTOP) = 0;
+      else
+         return True;
+      end if;
+   end Suspend_Task;
+
+   -----------------
+   -- Resume_Task --
+   -----------------
+
+   function Resume_Task
+     (T           : ST.Task_Id;
+      Thread_Self : Thread_Id) return Boolean
+   is
+   begin
+      if T.Common.LL.Thread /= Thread_Self then
+         return pthread_kill (T.Common.LL.Thread, SIGCONT) = 0;
+      else
+         return True;
+      end if;
+   end Resume_Task;
+
+   --------------------
+   -- Stop_All_Tasks --
+   --------------------
+
+   procedure Stop_All_Tasks is
+   begin
+      null;
+   end Stop_All_Tasks;
+
+   ---------------
+   -- Stop_Task --
+   ---------------
+
+   function Stop_Task (T : ST.Task_Id) return Boolean is
+      pragma Unreferenced (T);
+   begin
+      return False;
+   end Stop_Task;
+
+   -------------------
+   -- Continue_Task --
+   -------------------
+
+   function Continue_Task (T : ST.Task_Id) return Boolean is
+      pragma Unreferenced (T);
+   begin
+      return False;
+   end Continue_Task;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize (Environment_Task : Task_Id) is
+      act     : aliased struct_sigaction;
+      old_act : aliased struct_sigaction;
+      Tmp_Set : aliased sigset_t;
+      Result  : Interfaces.C.int;
+
+      function State
+        (Int : System.Interrupt_Management.Interrupt_ID) return Character;
+      pragma Import (C, State, "__gnat_get_interrupt_state");
+      --  Get interrupt state.  Defined in a-init.c
+      --  The input argument is the interrupt number,
+      --  and the result is one of the following:
+
+      Default : constant Character := 's';
+      --    'n'   this interrupt not set by any Interrupt_State pragma
+      --    'u'   Interrupt_State pragma set state to User
+      --    'r'   Interrupt_State pragma set state to Runtime
+      --    's'   Interrupt_State pragma set state to System (use "default"
+      --           system handler)
+
+   begin
+      Environment_Task_Id := Environment_Task;
+
+      Interrupt_Management.Initialize;
+
+      --  Prepare the set of signals that should be unblocked in all tasks
+
+      Result := sigemptyset (Unblocked_Signal_Mask'Access);
+      pragma Assert (Result = 0);
+
+      for J in Interrupt_Management.Interrupt_ID loop
+         if System.Interrupt_Management.Keep_Unmasked (J) then
+            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));
+            pragma Assert (Result = 0);
+         end if;
+      end loop;
+
+      Result := pthread_mutexattr_init (Mutex_Attr'Access);
+      pragma Assert (Result = 0);
+
+      Result := pthread_condattr_init (Cond_Attr'Access);
+      pragma Assert (Result = 0);
+
+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);
+
+      --  Initialize the global RTS lock
+
+      Specific.Initialize (Environment_Task);
+
+      Enter_Task (Environment_Task);
+
+      --  Install the abort-signal handler
+
+      if State
+          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default
+      then
+         act.sa_flags := 0;
+         act.sa_handler := Abort_Handler'Address;
+
+         Result := sigemptyset (Tmp_Set'Access);
+         pragma Assert (Result = 0);
+         act.sa_mask := Tmp_Set;
+
+         Result :=
+           sigaction
+           (Signal (Interrupt_Management.Abort_Task_Interrupt),
+            act'Unchecked_Access,
+            old_act'Unchecked_Access);
+         pragma Assert (Result = 0);
+      end if;
+   end Initialize;
+
+end System.Task_Primitives.Operations;
diff --git a/gcc/ada/sysdep.c b/gcc/ada/sysdep.c
index 5af4299e8..ef1f8ca16 100644
--- a/gcc/ada/sysdep.c
+++ b/gcc/ada/sysdep.c
@@ -405,7 +405,7 @@ getc_immediate_common (FILE *stream,
 {
 #if defined (linux) || defined (sun) || defined (sgi) || defined (__EMX__) \
     || (defined (__osf__) && ! defined (__alpha_vxworks)) \
-    || defined (__CYGWIN32__) || defined (__MACHTEN__) || defined (__hpux__) \
+    || defined (__CYGWIN__) || defined (__MACHTEN__) || defined (__hpux__) \
     || defined (_AIX) || (defined (__svr4__) && defined (i386)) \
     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
     || defined (__GLIBC__) || defined (__APPLE__)
@@ -694,6 +694,40 @@ rts_get_nShowCmd (void)
 }
 
 #endif /* WINNT */
+
+#ifdef __CYGWIN__
+
+size_t _msize(void *memblock)
+{
+  return (size_t) malloc_usable_size (memblock);
+}
+
+#include <windows.h>
+
+int
+__gnat_is_windows_xp (void)
+{
+  static int is_win_xp=0, is_win_xp_checked=0;
+
+  if (!is_win_xp_checked)
+    {
+      OSVERSIONINFO version;
+
+      is_win_xp_checked = 1;
+
+      memset (&version, 0, sizeof (version));
+      version.dwOSVersionInfoSize = sizeof (version);
+
+      is_win_xp = GetVersionEx (&version)
+        && version.dwPlatformId == VER_PLATFORM_WIN32_NT
+        && (version.dwMajorVersion > 5
+            || (version.dwMajorVersion == 5 && version.dwMinorVersion >= 1));
+    }
+  return is_win_xp;
+}
+
+#endif /* __CYGWIN__ */
+
 #ifdef VMS
 
 /* This gets around a problem with using the old threads library on VMS 7.0. */
diff --git a/gcc/ada/system-cygwin.ads b/gcc/ada/system-cygwin.ads
new file mode 100644
index 000000000..3dca1fa72
--- /dev/null
+++ b/gcc/ada/system-cygwin.ads
@@ -0,0 +1,199 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                            (Cygwin  Version)                             --
+--                                                                          --
+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.01;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 32;
+   Memory_Size  : constant := 2 ** 32;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := Low_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := False;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_64_Bit_Divides    : constant Boolean := True;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := True;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := True;
+   GCC_ZCX_Support           : constant Boolean := True;
+
+   ---------------------------
+   -- Underlying Priorities --
+   ---------------------------
+
+   --  Important note: this section of the file must come AFTER the
+   --  definition of the system implementation parameters to ensure
+   --  that the value of these parameters is available for analysis
+   --  of the declarations here (using Rtsfind at compile time).
+
+   --  The underlying priorities table provides a generalized mechanism
+   --  for mapping from Ada priorities to system priorities. In some
+   --  cases a 1-1 mapping is not the convenient or optimal choice.
+
+   type Priorities_Mapping is array (Any_Priority) of Integer;
+   pragma Suppress_Initialization (Priorities_Mapping);
+   --  Suppress initialization in case gnat.adc specifies Normalize_Scalars
+
+   Underlying_Priorities : constant Priorities_Mapping :=
+     (Priority'First ..
+      Default_Priority - 8    => -15,
+      Default_Priority - 7    => -7,
+      Default_Priority - 6    => -6,
+      Default_Priority - 5    => -5,
+      Default_Priority - 4    => -4,
+      Default_Priority - 3    => -3,
+      Default_Priority - 2    => -2,
+      Default_Priority - 1    => -1,
+      Default_Priority        => 0,
+      Default_Priority + 1    => 1,
+      Default_Priority + 2    => 2,
+      Default_Priority + 3    => 3,
+      Default_Priority + 4    => 4,
+      Default_Priority + 5    => 5,
+      Default_Priority + 6 ..
+      Priority'Last           => 6,
+      Interrupt_Priority      => 15);
+   --  The default mapping preserves the standard 31 priorities of the Ada
+   --  model, but maps them using compression onto the 7 priority levels
+   --  available in NT and on the 16 priority levels available in 2000/XP.
+
+   --  To replace the default values of the Underlying_Priorities mapping,
+   --  copy this source file into your build directory, edit the file to
+   --  reflect your desired behavior, and recompile using Makefile.adalib
+   --  which can be found under the adalib directory of your gnat installation
+
+   pragma Linker_Options ("-Wl,--stack=0x2000000");
+   --  This is used to change the default stack (32 MB) size for non tasking
+   --  programs. We change this value for GNAT on Windows here because the
+   --  binutils on this platform have switched to a too low value for Ada
+   --  programs. Note that we also set the stack size for tasking programs in
+   --  System.Task_Primitives.Operations.
+
+end System;
diff --git a/gcc/ada/system-mingw.ads b/gcc/ada/system-mingw.ads
index 6a9131a30..b9ab72407 100644
--- a/gcc/ada/system-mingw.ads
+++ b/gcc/ada/system-mingw.ads
@@ -139,7 +139,7 @@ private
    Always_Compatible_Rep     : constant Boolean := False;
    Suppress_Standard_Library : constant Boolean := False;
    Use_Ada_Main_Program_Name : constant Boolean := False;
-   ZCX_By_Default            : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := True;
    GCC_ZCX_Support           : constant Boolean := True;
 
    ---------------------------
diff --git a/gcc/config.gcc b/gcc/config.gcc
index e184febea..ce58f4926 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -1346,8 +1346,8 @@ i[34567]86-*-pe | i[34567]86-*-cygwin*)
 	target_gtfiles="\$(srcdir)/config/i386/winnt.c"
 	extra_options="${extra_options} i386/cygming.opt"
 	extra_objs="winnt.o winnt-stubs.o"
-	c_target_objs="${c_target_objs} cygwin2.o msformat-c.o"
-	cxx_target_objs="${cxx_target_objs} cygwin2.o winnt-cxx.o msformat-c.o"
+	c_target_objs="${c_target_objs} msformat-c.o"
+	cxx_target_objs="${cxx_target_objs} winnt-cxx.o msformat-c.o"
 	extra_gcc_objs=cygwin1.o
 	if test x$enable_threads = xyes; then
 		thread_file='posix'
diff --git a/gcc/config/i386/cygwin.h b/gcc/config/i386/cygwin.h
index c365f6603..05eeb5fc8 100644
--- a/gcc/config/i386/cygwin.h
+++ b/gcc/config/i386/cygwin.h
@@ -126,7 +126,8 @@ along with GCC; see the file COPYING3.  If not see
   %{shared|mdll: --enable-auto-image-base -e \
     %{mno-cygwin:_DllMainCRTStartup@12} \
     %{!mno-cygwin:__cygwin_dll_entry@12}}\
-  %{!mno-cygwin:--dll-search-prefix=cyg -tsaware}"
+  %{!mno-cygwin:--dll-search-prefix=cyg \
+    %{!shared: %{!mdll: --large-address-aware --tsaware}}}"
 
 /* Allocate space for all of the machine-spec-specific stuff.
    Allocate enough space for cygwin -> mingw32  munging plus
@@ -303,3 +304,23 @@ while (0)
 /* We should find a way to not have to update this manually.  */
 #define LIBGCJ_SONAME "cyggcj" /*LIBGCC_EH_EXTN*/ "-11.dll"
 
+/* Make stack executable to avoid DEP problems with trampolines.  */
+#undef CYGWIN_ENABLE_EXECUTE_STACK
+#define CYGWIN_ENABLE_EXECUTE_STACK     \
+extern void __enable_execute_stack (void *);    \
+void         \
+__enable_execute_stack (void *addr)					\
+{									\
+  MEMORY_BASIC_INFORMATION b;						\
+  if (!VirtualQuery (addr, &b, sizeof(b)))				\
+    abort ();								\
+  VirtualProtect (b.BaseAddress, b.RegionSize, PAGE_EXECUTE_READWRITE,	\
+		  &b.Protect);						\
+}
+
+#undef ENABLE_EXECUTE_STACK
+#define ENABLE_EXECUTE_STACK CYGWIN_ENABLE_EXECUTE_STACK
+
+#ifdef IN_LIBGCC2
+#include <windows.h>
+#endif
diff --git a/gcc/config/i386/cygwin1.c b/gcc/config/i386/cygwin1.c
index 7de34d24b..5cfed752f 100644
--- a/gcc/config/i386/cygwin1.c
+++ b/gcc/config/i386/cygwin1.c
@@ -38,16 +38,8 @@ mingw_scan (int argc ATTRIBUTE_UNUSED,
       putenv (xstrdup ("GCC_CYGWIN_WIN32=1"));
     else if (strcmp (*argv, "-mno-cygwin") == 0)
       {
-	char *p = strstr (*spec_machine, "-cygwin");
-	if (p)
-	  {
-	    int len = p - *spec_machine;
-	    char *s = XNEWVEC (char, strlen (*spec_machine) + 3);
-	    memcpy (s, *spec_machine, len);
-	    strcpy (s + len, "-mingw32");
-	    *spec_machine = s;
-	  }
-	putenv (xstrdup ("GCC_CYGWIN_MINGW=1"));
+	fatal ("The -mno-cygwin flag has been removed; use a "
+	  "mingw-targeted cross-compiler.\n");
       }
   return;
 }
diff --git a/gcc/config/i386/cygwin2.c b/gcc/config/i386/cygwin2.c
deleted file mode 100644
index c48e2a52c..000000000
--- a/gcc/config/i386/cygwin2.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/* Helper routines for cygwin-specific command-line parsing.
-   Contributed by Christopher Faylor (cgf@redhat.com)
-   Copyright 2003, 2007 Free Software Foundation, Inc.
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 3, or (at your option)
-any later version.
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
-
-#include "config.h"
-#include "system.h"
-#include "coretypes.h"
-#include "tm.h"
-
-#include "safe-ctype.h"
-#include <string.h>
-
-/*
-static void remove_w32api (void);
-*/
-static void add_mingw (void);
-static void set_mingw (void) __attribute__ ((constructor));
-
-static void
-add_mingw (void)
-{
-  char **av;
-  char *p;
-  for (av = cvt_to_mingw; *av; av++)
-    {
-      int sawcygwin = 0;
-      while ((p = strstr (*av, "-cygwin")))
-	{
-	  char *over = p + sizeof ("-cygwin") - 1;
-	  memmove (over + 1, over, strlen (over));
-	  memcpy (p, "-mingw32", sizeof("-mingw32") - 1);
-	  p = ++over;
-	  while (ISALNUM (*p))
-	    p++;
-	  strcpy (over, p);
-	  sawcygwin = 1;
-	}
-      if (!sawcygwin && !strstr (*av, "mingw"))
-	strcat (*av, CYGWIN_MINGW_SUBDIR);
-    }
-}
-
-
-static void
-set_mingw (void)
-{
-  char *env = getenv ("GCC_CYGWIN_MINGW");
-  if (env && *env == '1')
-    add_mingw ();
-}
diff --git a/gcc/config/i386/t-cygwin b/gcc/config/i386/t-cygwin
index 8fec6f761..ba37ec832 100644
--- a/gcc/config/i386/t-cygwin
+++ b/gcc/config/i386/t-cygwin
@@ -28,10 +28,6 @@ cygwin1.o: $(srcdir)/config/i386/cygwin1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
 	$(srcdir)/config/i386/cygwin1.c
 
-cygwin2.o: $(srcdir)/config/i386/cygwin2.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
-  $(TM_H) $(TM_P_H)
-	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
-	$(srcdir)/config/i386/cygwin2.c
 
 # Cygwin-specific parts of LIB_SPEC
 SHLIB_LC = -lcygwin -luser32 -lkernel32 -ladvapi32 -lshell32
diff --git a/gcc/config/i386/w32-unwind.h b/gcc/config/i386/w32-unwind.h
index ce8be2369..449e9a9c5 100644
--- a/gcc/config/i386/w32-unwind.h
+++ b/gcc/config/i386/w32-unwind.h
@@ -1,5 +1,5 @@
-/* Definitions for Dwarf2 EH unwind support for Windows32 targets 
-   Copyright (C) 2007, 2009
+/* Definitions for Dwarf2 EH unwind support for Windows32 targets
+   Copyright (C) 2007, 2009, 2010
    Free Software Foundation, Inc.
    Contributed by Pascal Obry  <obry@adacore.com>
 
@@ -129,7 +129,6 @@ i386_w32_fallback_frame_state (struct _Unwind_Context *context,
 
   /* In the test below we look for two specific patterns found
      experimentally to be in the Windows signal handler.  */
-
   if (SIG_PAT1 || SIG_PAT2 || SIG_SEH1 || SIG_SEH2)
     {
       PEXCEPTION_POINTERS weinfo_;
@@ -147,14 +146,12 @@ i386_w32_fallback_frame_state (struct _Unwind_Context *context,
 	}
 
       /* The new context frame address is the stack pointer.  */
-
       new_cfa_ = proc_ctx_->Esp;
       fs->regs.cfa_how = CFA_REG_OFFSET;
       fs->regs.cfa_reg = __builtin_dwarf_sp_column();
       fs->regs.cfa_offset = new_cfa_ - (long) ctx_cfa_;
 
-      /* Save some registers.  */
-
+      /* Restore registers.  */
       fs->regs.reg[0].how = REG_SAVED_OFFSET;
       fs->regs.reg[0].loc.offset = (long)&proc_ctx_->Eax - new_cfa_;
       fs->regs.reg[3].how = REG_SAVED_OFFSET;
@@ -167,18 +164,13 @@ i386_w32_fallback_frame_state (struct _Unwind_Context *context,
       fs->regs.reg[6].loc.offset = (long)&proc_ctx_->Esi - new_cfa_;
       fs->regs.reg[7].how = REG_SAVED_OFFSET;
       fs->regs.reg[7].loc.offset = (long)&proc_ctx_->Edi - new_cfa_;
-      fs->regs.reg[9].how = REG_SAVED_OFFSET;
-      fs->regs.reg[9].loc.offset = (long)&proc_ctx_->Eip - new_cfa_;
-      fs->regs.reg[4].how = REG_SAVED_OFFSET;
-      fs->regs.reg[4].loc.offset = (long)&proc_ctx_->Ebp - new_cfa_;
-
-      /* Set the return address to Eip + 1. As we can be called multiple
-	 times we use another register for this.  */
-      
-      proc_ctx_->Dr0 = proc_ctx_->Eip + 1;
+      fs->regs.reg[5].how = REG_SAVED_OFFSET;
+      fs->regs.reg[5].loc.offset = (long)&proc_ctx_->Ebp - new_cfa_;
       fs->regs.reg[8].how = REG_SAVED_OFFSET;
-      fs->regs.reg[8].loc.offset = (long)&proc_ctx_->Dr0 - new_cfa_;
+      fs->regs.reg[8].loc.offset = (long)&proc_ctx_->Eip - new_cfa_;
       fs->retaddr_column = 8;
+      fs->signal_frame = 1;
+
       return _URC_NO_REASON;
     }
 
@@ -186,7 +178,6 @@ i386_w32_fallback_frame_state (struct _Unwind_Context *context,
      one of it's probes prior to the real SP adjustment. The only
      operations of interest performed is "pushl %ecx", followed by
      ecx clobbering.  */
-
   else if (SIG_ALLOCA) 
     {
       /* Only one push between entry in _alloca and the probe trap.  */ 
@@ -204,7 +195,8 @@ i386_w32_fallback_frame_state (struct _Unwind_Context *context,
       fs->retaddr_column = 8;
       fs->regs.reg[8].how = REG_SAVED_OFFSET;
       fs->regs.reg[8].loc.offset = 0;
- 
+      fs->signal_frame = 1;
+
       return _URC_NO_REASON;
     }
   else
diff --git a/gcc/cppdefault.c b/gcc/cppdefault.c
index 5024f48c9..8669a2061 100644
--- a/gcc/cppdefault.c
+++ b/gcc/cppdefault.c
@@ -39,6 +39,8 @@
 # undef STANDARD_INCLUDE_DIR
 #else
 # undef CROSS_INCLUDE_DIR
+# undef CROSS_INCLUDE_DIR_1
+# undef CROSS_INCLUDE_DIR_2
 #endif
 
 const struct default_include cpp_include_defaults[]
@@ -85,6 +87,14 @@ const struct default_include cpp_include_defaults[]
     /* One place the target system's headers might be.  */
     { CROSS_INCLUDE_DIR, "GCC", 0, 0, 0, 0 },
 #endif
+#ifdef CROSS_INCLUDE_DIR_1
+    /* One more place the target system's headers might be.  */
+    { CROSS_INCLUDE_DIR_1, "GCC", 0, 0, 0, 0 },
+#endif
+#ifdef CROSS_INCLUDE_DIR_2
+    /* One more place the target system's headers might be.  */
+    { CROSS_INCLUDE_DIR_2, "GCC", 0, 0, 0, 0 },
+#endif
 #ifdef TOOL_INCLUDE_DIR
     /* Another place the target system's headers might be.  */
     { TOOL_INCLUDE_DIR, "BINUTILS", 0, 1, 0, 0 },
diff --git a/gcc/testsuite/gcc.target/i386/pr25993.c b/gcc/testsuite/gcc.target/i386/pr25993.c
index b079e257f..c30eaf546 100644
--- a/gcc/testsuite/gcc.target/i386/pr25993.c
+++ b/gcc/testsuite/gcc.target/i386/pr25993.c
@@ -1,5 +1,5 @@
 /* { dg-do assemble } */
-/* { dg-skip-if "" { "*-*-darwin*" "*-*-mingw*" } { "*" } { "" } } */
+/* { dg-skip-if "" { "*-*-darwin*" "*-*-mingw*" "*-*-cygwin*" } { "*" } { "" } } */
 /* { dg-options "-std=c99 -x assembler-with-cpp" } */
 
 #ifndef __ASSEMBLER__
diff --git a/gcc/unwind-dw2-fde.c b/gcc/unwind-dw2-fde.c
index 60535cfd7..980edf7d9 100644
--- a/gcc/unwind-dw2-fde.c
+++ b/gcc/unwind-dw2-fde.c
@@ -37,6 +37,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "gthr.h"
 #endif
 
+#define __debug_unwind_enabled (0)
+
 /* The unseen_objects list contains objects that have been registered
    but not yet categorized in any way.  The seen_objects list has had
    its pc_begin and count fields initialized at minimum, and is sorted
@@ -840,6 +842,8 @@ binary_search_unencoded_fdes (struct object *ob, void *pc)
   struct fde_vector *vec = ob->u.sort;
   size_t lo, hi;
 
+  if (__debug_unwind_enabled) printf ("search fdes ob %p: vec %p count %d\n", ob, vec, vec->count);
+
   for (lo = 0, hi = vec->count; lo < hi; )
     {
       size_t i = (lo + hi) / 2;
@@ -849,6 +853,8 @@ binary_search_unencoded_fdes (struct object *ob, void *pc)
       memcpy (&pc_begin, (const void * const *) f->pc_begin, sizeof (void *));
       memcpy (&pc_range, (const uaddr *) f->pc_begin + 1, sizeof (uaddr));
 
+if (__debug_unwind_enabled) printf ("fde#%d (%p): pc_begin %p pc_range %p\n", i, f, pc_begin, (void *)pc_range);
+
       if (pc < pc_begin)
 	hi = i;
       else if (pc >= pc_begin + pc_range)
@@ -856,7 +862,7 @@ binary_search_unencoded_fdes (struct object *ob, void *pc)
       else
 	return f;
     }
-
+if (__debug_unwind_enabled) printf ("**not found\n");
   return NULL;
 }
 
@@ -977,6 +983,8 @@ _Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)
   /* Linear search through the classified objects, to find the one
      containing the pc.  Note that pc_begin is sorted descending, and
      we expect objects to be non-overlapping.  */
+  if (__debug_unwind_enabled) printf ("Search seen obs for pc %p: Bases t %p, d %p, func %p\n", 
+	pc, bases->tbase, bases->dbase, bases->func);
   for (ob = seen_objects; ob; ob = ob->next)
     if (pc >= ob->pc_begin)
       {
@@ -987,6 +995,8 @@ _Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)
       }
 
   /* Classify and search the objects we've not yet processed.  */
+  if (__debug_unwind_enabled) printf ("Search unseen obs for pc %p: Bases t %p, d %p, func %p\n", 
+	pc, bases->tbase, bases->dbase, bases->func);
   while ((ob = unseen_objects))
     {
       struct object **p;
@@ -1022,6 +1032,15 @@ _Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)
       read_encoded_value_with_base (encoding, base_from_object (encoding, ob),
 				    f->pc_begin, &func);
       bases->func = (void *) func;
+
+  if (__debug_unwind_enabled) printf ("Found fde %p: Bases t %p, d %p, func %p\n", 
+	f, bases->tbase, bases->dbase, bases->func);
+
+    }
+    else
+    {
+  if (__debug_unwind_enabled) printf ("No fde %p: Bases t %p, d %p, func %p\n", 
+	f, bases->tbase, bases->dbase, bases->func);
     }
 
   return f;
diff --git a/gcc/unwind-dw2.c b/gcc/unwind-dw2.c
index 2c0b363dc..24ab5b327 100644
--- a/gcc/unwind-dw2.c
+++ b/gcc/unwind-dw2.c
@@ -79,6 +79,7 @@ struct _Unwind_Context
 
 /* Byte size of every register managed by these routines.  */
 static unsigned char dwarf_reg_size_table[DWARF_FRAME_REGISTERS+1];
+#define __debug_unwind_enabled (0)
 
 
 /* Read unaligned data from the instruction buffer.  */
@@ -372,7 +373,7 @@ extract_cie_info (const struct dwarf_cie *cie, struct _Unwind_Context *context,
       fs->retaddr_column = (_Unwind_Word)utmp;
     }
   fs->lsda_encoding = DW_EH_PE_omit;
-
+if (__debug_unwind_enabled) printf ("extract cie: augmentation '%c'\n", *aug);
   /* If the augmentation starts with 'z', then a uleb128 immediately
      follows containing the length of the augmentation field following
      the size.  */
@@ -388,6 +389,7 @@ extract_cie_info (const struct dwarf_cie *cie, struct _Unwind_Context *context,
   /* Iterate over recognized augmentation subsequences.  */
   while (*aug != '\0')
     {
+if (__debug_unwind_enabled) printf ("handle augmentation '%c'\n", *aug);
       /* "L" indicates a byte showing how the LSDA pointer is encoded.  */
       if (aug[0] == 'L')
 	{
@@ -425,6 +427,7 @@ extract_cie_info (const struct dwarf_cie *cie, struct _Unwind_Context *context,
 	return ret;
     }
 
+if (__debug_unwind_enabled) printf ("extract cie: augmentation done\n");
   return ret ? ret : p;
 }
 
@@ -1571,9 +1574,25 @@ uw_identify_context (struct _Unwind_Context *context)
     return _Unwind_GetCFA (context) + _Unwind_IsSignalFrame (context);
 }
 
+static _Unwind_Reason_Code 
+debug_unwind_trace (struct _Unwind_Context *ctx, void *arg)
+{
+  fflush (NULL);
+  printf ("_Unwind_Context %p\n", ctx);
+  printf ("    cfa %p  ra %p  lsda %p\n", ctx->cfa, ctx->ra, ctx->lsda);
+  printf (" bases: t %p d %p func %p\n", ctx->bases.tbase, ctx->bases.dbase, ctx->bases.func);
+  printf ("\n");
+  fflush (NULL);
+  return _URC_NO_REASON;
+}
 
 #include "unwind.inc"
 
+void debug_dump_stack_trace (void *arg)
+{
+  _Unwind_Backtrace (debug_unwind_trace, arg);
+}
+
 #if defined (USE_GAS_SYMVER) && defined (SHARED) && defined (USE_LIBUNWIND_EXCEPTIONS)
 alias (_Unwind_Backtrace);
 alias (_Unwind_DeleteException);
diff --git a/gcc/unwind.inc b/gcc/unwind.inc
index 5e2ec29c7..6d7b30c75 100644
--- a/gcc/unwind.inc
+++ b/gcc/unwind.inc
@@ -96,8 +96,9 @@ _Unwind_RaiseException(struct _Unwind_Exception *exc)
 
       /* Set up fs to describe the FDE for the caller of cur_context.  The
 	 first time through the loop, that means __cxa_throw.  */
+if (__debug_unwind_enabled) printf ("Ctx: ra %p\n", cur_context.ra);
       code = uw_frame_state_for (&cur_context, &fs);
-
+if (__debug_unwind_enabled) printf ("... code %d, perso %p\n", code, fs.personality);
       if (code == _URC_END_OF_STACK)
 	/* Hit end of stack with no handler found.  */
 	return _URC_END_OF_STACK;
@@ -112,6 +113,7 @@ _Unwind_RaiseException(struct _Unwind_Exception *exc)
 	{
 	  code = (*fs.personality) (1, _UA_SEARCH_PHASE, exc->exception_class,
 				    exc, &cur_context);
+if (__debug_unwind_enabled) printf ("perso returns code %d\n", code);
 	  if (code == _URC_HANDLER_FOUND)
 	    break;
 	  else if (code != _URC_CONTINUE_UNWIND)
diff --git a/libffi/Makefile.am b/libffi/Makefile.am
index 23e002e96..c2923393c 100644
--- a/libffi/Makefile.am
+++ b/libffi/Makefile.am
@@ -32,6 +32,11 @@ EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host \
 	src/pa/ffitarget.h src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S \
 	src/frv/ffi.c src/frv/eabi.S src/frv/ffitarget.h src/dlmalloc.c
 
+# Where generated headers like ffitarget.h get installed.
+gcc_version   := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
+# There's probably already some other name for this directory.
+toollibffidir := $(libdir)/gcc/$(target_alias)/$(gcc_version)
+
 ## ################################################################
 
 ##
diff --git a/libffi/Makefile.in b/libffi/Makefile.in
index c02ee31e5..ac620bc40 100644
--- a/libffi/Makefile.in
+++ b/libffi/Makefile.in
@@ -417,6 +417,11 @@ EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host \
 	src/frv/ffi.c src/frv/eabi.S src/frv/ffitarget.h src/dlmalloc.c
 
 
+# Where generated headers like ffitarget.h get installed.
+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
+# There's probably already some other name for this directory.
+toollibffidir := $(libdir)/gcc/$(target_alias)/$(gcc_version)
+
 # Work around what appears to be a GNU make bug handling MAKEFLAGS
 # values defined in terms of make variables, as is the case for CC and
 # friends when we are called from the top level Makefile.
diff --git a/libffi/configure.ac b/libffi/configure.ac
index de08613b4..ee86e2d6a 100644
--- a/libffi/configure.ac
+++ b/libffi/configure.ac
@@ -83,7 +83,7 @@ case "$host" in
   i?86-win32* | i?86-*-cygwin* | i?86-*-mingw*)
 	TARGET=X86_WIN32; TARGETDIR=x86
 	# All mingw/cygwin/win32 builds require this for sharedlib
-	AM_LTLDFLAGS="-no-undefined"
+	AM_LTLDFLAGS='-no-undefined -bindir $(bindir)'
 	;;
   i?86-*-darwin*)
 	TARGET=X86_DARWIN; TARGETDIR=x86
@@ -416,7 +416,7 @@ if test -n "$with_cross_host" &&
   toolexeclibdir='$(toolexecdir)/lib'
 else
   toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
-  toolexeclibdir='$(libdir)'
+  toolexeclibdir="${host__toolexeclibdir:-\$(libdir)}"
 fi
 multi_os_directory=`$CC -print-multi-os-directory`
 case $multi_os_directory in
diff --git a/libffi/configure.host b/libffi/configure.host
index f52457b39..d1c0a2716 100644
--- a/libffi/configure.host
+++ b/libffi/configure.host
@@ -8,4 +8,8 @@ case "${host}" in
   frv*-elf)
     LDFLAGS=`echo $LDFLAGS | sed "s/\-B[^ ]*libgloss\/frv\///"`\ -B`pwd`/../libgloss/frv/
     ;;
+  i?86-*-cygwin*)
+    # Redirect installation to gcc private dir.
+    host__toolexeclibdir='$(toollibffidir)'
+    ;;
 esac
diff --git a/libjava/classpath/configure.ac b/libjava/classpath/configure.ac
index da6a35561..dabaa4a3d 100644
--- a/libjava/classpath/configure.ac
+++ b/libjava/classpath/configure.ac
@@ -63,7 +63,7 @@ case "$host_os" in
 	cp_module=""
 	;;
 	*)
-	cp_module="-module"
+	cp_module="-module -avoid-version"
 	;;
 esac
 
diff --git a/libjava/classpath/doc/api/Makefile.am b/libjava/classpath/doc/api/Makefile.am
index 76b35c5f8..a20e3bb9f 100644
--- a/libjava/classpath/doc/api/Makefile.am
+++ b/libjava/classpath/doc/api/Makefile.am
@@ -36,7 +36,6 @@ clean-local:
 
 create_html:
 	-$(MKDIR) html > /dev/null 2>&1
-if CREATE_API_DOCS
 	$(GJDOC) \
 	-use \
 	-sourcepath "$(sourcepath)" \
@@ -52,4 +51,3 @@ if CREATE_API_DOCS
 	-header $(classpathbox) -footer $(classpathbox) \
 	-subpackages java:javax:org
 	touch create_html
-endif
diff --git a/libjava/classpath/examples/gnu/classpath/examples/awt/HintingDemo.java b/libjava/classpath/examples/gnu/classpath/examples/awt/HintingDemo.java
index 99c262b71..5a8ed1ea3 100644
--- a/libjava/classpath/examples/gnu/classpath/examples/awt/HintingDemo.java
+++ b/libjava/classpath/examples/gnu/classpath/examples/awt/HintingDemo.java
@@ -211,7 +211,7 @@ public class HintingDemo extends JFrame {
 
   HintingDemo()
   {
-    File file = new File("/usr/share/fonts/truetype/freefont/FreeSans.ttf");
+    File file = new File("/usr/share/fonts/TTF/Vera.ttf");
     loadFont(file);
     setLayout(new BorderLayout());
     chooser = new Chooser();
diff --git a/libjava/classpath/gnu/java/awt/peer/ClasspathDesktopPeer.java b/libjava/classpath/gnu/java/awt/peer/ClasspathDesktopPeer.java
index bef42dcea..71a08b3e1 100644
--- a/libjava/classpath/gnu/java/awt/peer/ClasspathDesktopPeer.java
+++ b/libjava/classpath/gnu/java/awt/peer/ClasspathDesktopPeer.java
@@ -58,7 +58,7 @@ public class ClasspathDesktopPeer
     implements DesktopPeer
 {
   /** This is the fallback browser, if no desktop was detected. */
-  protected static final String _DEFAULT_BROWSER = "firefox";
+  protected static final String _DEFAULT_BROWSER = "xdg-open";
   
   /** gnu.java.awt.peer.Desktop.html.command */
   protected static final String _BROWSE = "html";
diff --git a/libjava/classpath/gnu/java/awt/peer/ClasspathFontPeer.java b/libjava/classpath/gnu/java/awt/peer/ClasspathFontPeer.java
index e43e5f284..048360c6a 100644
--- a/libjava/classpath/gnu/java/awt/peer/ClasspathFontPeer.java
+++ b/libjava/classpath/gnu/java/awt/peer/ClasspathFontPeer.java
@@ -158,6 +158,8 @@ public abstract class ClasspathFontPeer
 
   protected static boolean isLogicalFontName(String name)
   {
+    return false;
+/*
     String uname = name.toUpperCase ();
     return (uname.equals ("SANSSERIF") ||
             uname.equals ("SERIF") ||
@@ -165,6 +167,7 @@ public abstract class ClasspathFontPeer
             uname.equals ("DIALOG") ||
             uname.equals ("DIALOGINPUT") ||
             uname.equals ("DEFAULT"));
+*/
   }
 
   protected static String logicalFontNameToFaceName (String name)
diff --git a/libjava/classpath/resource/gnu/java/awt/font/fonts.properties b/libjava/classpath/resource/gnu/java/awt/font/fonts.properties
index 4fc0b10b8..1370469cf 100644
--- a/libjava/classpath/resource/gnu/java/awt/font/fonts.properties
+++ b/libjava/classpath/resource/gnu/java/awt/font/fonts.properties
@@ -36,20 +36,20 @@
 # exception statement from your version.
 
 # List of available fonts.
-FreeMono/p=/usr/share/fonts/truetype/freefont/FreeMono.ttf
-FreeMono/b=/usr/share/fonts/truetype/freefont/FreeMonoBold.ttf
-FreeMono/bi=/usr/share/fonts/truetype/freefont/FreeMonoBoldOblique.ttf
-FreeMono/i=/usr/share/fonts/truetype/freefont/FreeMonoOblique.ttf
+FreeMono/p=/usr/share/fonts/TTF/VeraMono.ttf
+FreeMono/b=/usr/share/fonts/TTF/VeraMoBd.ttf
+FreeMono/bi=/usr/share/fonts/TTF/VeraMoBI.ttf
+FreeMono/i=/usr/share/fonts/TTF/VeraMoIt.ttf
 
-FreeSans/p=/usr/share/fonts/truetype/freefont/FreeSans.ttf
-FreeSans/b=/usr/share/fonts/truetype/freefont/FreeSansBold.ttf
-FreeSans/bi=/usr/share/fonts/truetype/freefont/FreeSansBoldOblique.ttf
-FreeSans/i=/usr/share/fonts/truetype/freefont/FreeSansOblique.ttf
+FreeSans/p=/usr/share/fonts/TTF/Vera.ttf
+FreeSans/b=/usr/share/fonts/TTF/VeraBd.ttf
+FreeSans/bi=/usr/share/fonts/TTF/VeraBI.ttf
+FreeSans/i=/usr/share/fonts/TTF/VeraIt.ttf
 
-FreeSerif/p=/usr/share/fonts/truetype/freefont/FreeSerif.ttf
-FreeSerif/b=/usr/share/fonts/truetype/freefont/FreeSerifBold.ttf
-FreeSerif/bi=/usr/share/fonts/truetype/freefont/FreeSerifBoldOblique.ttf
-FreeSerif/i=/usr/share/fonts/truetype/freefont/FreeSerifOblique.ttf
+FreeSerif/p=/usr/share/fonts/TTF/VeraSe.ttf
+FreeSerif/b=/usr/share/fonts/TTF/VeraSeBd.ttf
+FreeSerif/bi=/usr/share/fonts/TTF/VeraSeBd.ttf
+FreeSerif/i=/usr/share/fonts/TTF/VeraSe.ttf
 
 # List of aliases.
 Dialog/a=FreeSans
diff --git a/libjava/gnu/java/nio/channels/natFileChannelPosix.cc b/libjava/gnu/java/nio/channels/natFileChannelPosix.cc
index e05904c50..0a2569cef 100644
--- a/libjava/gnu/java/nio/channels/natFileChannelPosix.cc
+++ b/libjava/gnu/java/nio/channels/natFileChannelPosix.cc
@@ -386,7 +386,7 @@ FileChannelImpl::available (void)
 
 #if defined (FIONREAD)
   r = ::ioctl (fd, FIONREAD, &num);
-  if (r == -1 && errno == ENOTTY)
+  if (r == -1 && (errno == ENOTTY || errno == EINVAL))
     {
       // If the ioctl doesn't work, we don't care.
       r = 0;
diff --git a/libstdc++-v3/config/os/mingw32/os_defines.h b/libstdc++-v3/config/os/mingw32/os_defines.h
index 5435ce9ae..f572ea282 100644
--- a/libstdc++-v3/config/os/mingw32/os_defines.h
+++ b/libstdc++-v3/config/os/mingw32/os_defines.h
@@ -60,4 +60,10 @@
 // See  libstdc++/37522.
 #define _GLIBCXX_HAVE_BROKEN_VSWPRINTF 1
 
+#ifdef _DLL
+#define _GLIBCXX_IMPORT __attribute__((dllimport))
+#else
+#define _GLIBCXX_IMPORT
+#endif
+
 #endif
diff --git a/libstdc++-v3/config/os/newlib/os_defines.h b/libstdc++-v3/config/os/newlib/os_defines.h
index 1ff3d4846..670f34c94 100644
--- a/libstdc++-v3/config/os/newlib/os_defines.h
+++ b/libstdc++-v3/config/os/newlib/os_defines.h
@@ -35,6 +35,8 @@
 
 #ifdef __CYGWIN__
 #define _GLIBCXX_GTHREAD_USE_WEAK 0
+#define __GXX_MERGED_TYPEINFO_NAMES 0
+#define __GXX_TYPEINFO_EQUALITY_INLINE 0
 
 #if defined (_GLIBCXX_DLL)
 #define _GLIBCXX_PSEUDO_VISIBILITY_default __attribute__ ((__dllimport__))
@@ -47,6 +49,13 @@
 
 // See libstdc++/20806.
 #define _GLIBCXX_HAVE_DOS_BASED_FILESYSTEM 1
+
+#ifdef _DLL
+#define _GLIBCXX_IMPORT __attribute__((dllimport))
+#else
+#define _GLIBCXX_IMPORT
+#endif
+
 #endif
 
 #endif
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 69f6b5d42..31d62ee11 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -15659,8 +15659,8 @@ else
       #endif
       int main()
       {
-	const char __one[] = "uglein Augmen";
-        const char __two[] = "uglein";
+	const char __one[] = "?uglein Augmen";
+        const char __two[] = "?uglein";
        	int i;
         int j;
         __locale_t        loc;
@@ -44576,7 +44576,7 @@ $as_echo "#define HAVE_TLS 1" >>confdefs.h
 	;;
     esac
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu | *-cygwin*)
 
   # All these tests are for C++; save the language and the compiler flags.
   # The CXXFLAGS thing is suspicious, but based on similar bits previously
diff --git a/libstdc++-v3/configure.host b/libstdc++-v3/configure.host
index 4b4e2423c..8f0e31c02 100644
--- a/libstdc++-v3/configure.host
+++ b/libstdc++-v3/configure.host
@@ -209,6 +209,7 @@ case "${host_os}" in
     ;;
   cygwin*)
     os_include_dir="os/newlib"
+    OPT_LDFLAGS="-Wl,--exclude-modules-for-implib=\`cd ../libsupc++; ls *type_inf*.o -1  | tr '\012' ':'\`tinfo.o:tinfo2.o"
     OPT_LDFLAGS="${OPT_LDFLAGS} -no-undefined -bindir \$(bindir)"
     ;;
   darwin | darwin[1-7] | darwin[1-7].*)
diff --git a/libstdc++-v3/crossconfig.m4 b/libstdc++-v3/crossconfig.m4
index fdaa9d6d0..7dea17fab 100644
--- a/libstdc++-v3/crossconfig.m4
+++ b/libstdc++-v3/crossconfig.m4
@@ -141,7 +141,7 @@ case "${host}" in
 	;;
     esac
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu | *-cygwin*)
     GLIBCXX_CHECK_COMPILER_FEATURES
     GLIBCXX_CHECK_LINKER_FEATURES
     GLIBCXX_CHECK_MATH_SUPPORT
diff --git a/libstdc++-v3/include/backward/strstream b/libstdc++-v3/include/backward/strstream
index 3221ba93d..a2378c89f 100644
--- a/libstdc++-v3/include/backward/strstream
+++ b/libstdc++-v3/include/backward/strstream
@@ -55,7 +55,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
 
   // Class strstreambuf, a streambuf class that manages an array of char.
   // Note that this class is not a template.
-  class strstreambuf : public basic_streambuf<char, char_traits<char> >
+  class _GLIBCXX_IMPORT strstreambuf : public basic_streambuf<char, char_traits<char> >
   {
   public:
     // Types.
@@ -117,7 +117,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   };
 
   // Class istrstream, an istream that manages a strstreambuf.
-  class istrstream : public basic_istream<char>
+  class _GLIBCXX_IMPORT istrstream : public basic_istream<char>
   {
   public:
     explicit istrstream(char*);
@@ -134,7 +134,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   };
 
   // Class ostrstream
-  class ostrstream : public basic_ostream<char>
+  class _GLIBCXX_IMPORT ostrstream : public basic_ostream<char>
   {
   public:
     ostrstream();
@@ -151,7 +151,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   };
 
   // Class strstream
-  class strstream : public basic_iostream<char>
+  class _GLIBCXX_IMPORT strstream : public basic_iostream<char>
   {
   public:
     typedef char                        char_type;
diff --git a/libstdc++-v3/include/bits/basic_ios.tcc b/libstdc++-v3/include/bits/basic_ios.tcc
index a0dc67e54..795dda07d 100644
--- a/libstdc++-v3/include/bits/basic_ios.tcc
+++ b/libstdc++-v3/include/bits/basic_ios.tcc
@@ -175,10 +175,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   // which are defined via explicit instantiations elsewhere.
   // NB:  This syntax is a GNU extension.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_ios<char>;
+  extern template class _GLIBCXX_IMPORT basic_ios<char>;
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_ios<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_ios<wchar_t>;
 #endif
 #endif
 
diff --git a/libstdc++-v3/include/bits/c++config b/libstdc++-v3/include/bits/c++config
index 374669645..2624f141f 100644
--- a/libstdc++-v3/include/bits/c++config
+++ b/libstdc++-v3/include/bits/c++config
@@ -376,4 +376,8 @@ _GLIBCXX_END_NAMESPACE
 # endif
 #endif
 
+#ifndef _GLIBCXX_IMPORT
+#define _GLIBCXX_IMPORT
+#endif
+
 // End of prewritten config; the discovered settings follow.
diff --git a/libstdc++-v3/include/bits/codecvt.h b/libstdc++-v3/include/bits/codecvt.h
index 98ca3ae32..258655aea 100644
--- a/libstdc++-v3/include/bits/codecvt.h
+++ b/libstdc++-v3/include/bits/codecvt.h
@@ -476,7 +476,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   // which are defined via explicit instantiations elsewhere.
   // NB: This syntax is a GNU extension.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class codecvt_byname<char, char, mbstate_t>;
+  extern template class _GLIBCXX_IMPORT codecvt_byname<char, char, mbstate_t>;
 
   extern template
     const codecvt<char, char, mbstate_t>&
@@ -487,7 +487,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
     has_facet<codecvt<char, char, mbstate_t> >(const locale&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
+  extern template class _GLIBCXX_IMPORT codecvt_byname<wchar_t, char, mbstate_t>;
 
   extern template
     const codecvt<wchar_t, char, mbstate_t>&
diff --git a/libstdc++-v3/include/bits/fstream.tcc b/libstdc++-v3/include/bits/fstream.tcc
index c5f7f8c52..bb8311ac4 100644
--- a/libstdc++-v3/include/bits/fstream.tcc
+++ b/libstdc++-v3/include/bits/fstream.tcc
@@ -908,16 +908,16 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   // which are defined via explicit instantiations elsewhere.
   // NB:  This syntax is a GNU extension.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_filebuf<char>;
-  extern template class basic_ifstream<char>;
-  extern template class basic_ofstream<char>;
-  extern template class basic_fstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_filebuf<char>;
+  extern template class _GLIBCXX_IMPORT basic_ifstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_ofstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_fstream<char>;
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_filebuf<wchar_t>;
-  extern template class basic_ifstream<wchar_t>;
-  extern template class basic_ofstream<wchar_t>;
-  extern template class basic_fstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_filebuf<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_ifstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_ofstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_fstream<wchar_t>;
 #endif
 #endif
 
diff --git a/libstdc++-v3/include/bits/ios_base.h b/libstdc++-v3/include/bits/ios_base.h
index 0ac3d6926..c3991aaad 100644
--- a/libstdc++-v3/include/bits/ios_base.h
+++ b/libstdc++-v3/include/bits/ios_base.h
@@ -204,7 +204,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
    *  people will only see @c ios_base when they need to specify the full
    *  name of the various I/O flags (e.g., the openmodes).
   */
-  class ios_base
+  class _GLIBCXX_IMPORT ios_base
   {
   public:
 
@@ -214,7 +214,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
      *
      *  27.4.2.1.1  Class ios_base::failure
      */
-    class failure : public exception
+    class _GLIBCXX_IMPORT failure : public exception
     {
     public:
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
@@ -529,7 +529,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
     // Used to initialize standard streams. In theory, g++ could use
     // -finit-priority to order this stuff correctly without going
     // through these machinations.
-    class Init
+    class _GLIBCXX_IMPORT Init
     {
       friend class ios_base;
     public:
diff --git a/libstdc++-v3/include/bits/istream.tcc b/libstdc++-v3/include/bits/istream.tcc
index d005f736f..f85ce4e4a 100644
--- a/libstdc++-v3/include/bits/istream.tcc
+++ b/libstdc++-v3/include/bits/istream.tcc
@@ -1018,7 +1018,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   // which are defined via explicit instantiations elsewhere.
   // NB:  This syntax is a GNU extension.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_istream<char>;
+  extern template class _GLIBCXX_IMPORT basic_istream<char>;
   extern template istream& ws(istream&);
   extern template istream& operator>>(istream&, char&);
   extern template istream& operator>>(istream&, char*);
@@ -1041,10 +1041,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   extern template istream& istream::_M_extract(long double&);
   extern template istream& istream::_M_extract(void*&);
 
-  extern template class basic_iostream<char>;
+  extern template class _GLIBCXX_IMPORT basic_iostream<char>;
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_istream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_istream<wchar_t>;
   extern template wistream& ws(wistream&);
   extern template wistream& operator>>(wistream&, wchar_t&);
   extern template wistream& operator>>(wistream&, wchar_t*);
@@ -1063,7 +1063,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   extern template wistream& wistream::_M_extract(long double&);
   extern template wistream& wistream::_M_extract(void*&);
 
-  extern template class basic_iostream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_iostream<wchar_t>;
 #endif
 #endif
 
diff --git a/libstdc++-v3/include/bits/locale_classes.h b/libstdc++-v3/include/bits/locale_classes.h
index 347e76124..9bd0bbc92 100644
--- a/libstdc++-v3/include/bits/locale_classes.h
+++ b/libstdc++-v3/include/bits/locale_classes.h
@@ -59,7 +59,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
    *  This library supports efficient construction and copying of locales
    *  through a reference counting implementation of the locale class.
   */
-  class locale
+  class _GLIBCXX_IMPORT locale
   {
   public:
     // Types:
@@ -67,9 +67,9 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
     typedef int	category;
 
     // Forward decls and friends:
-    class facet;
-    class id;
-    class _Impl;
+    class _GLIBCXX_IMPORT facet;
+    class _GLIBCXX_IMPORT id;
+    class _GLIBCXX_IMPORT _Impl;
 
     friend class facet;
     friend class _Impl;
@@ -334,7 +334,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
    *
    *  Facets may not be copied or assigned.
   */
-  class locale::facet
+  class _GLIBCXX_IMPORT locale::facet
   {
   private:
     friend class locale;
@@ -429,7 +429,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
    *  cannot be used in a locale.  The locale::id ensures that each class
    *  type gets a unique identifier.
   */
-  class locale::id
+  class _GLIBCXX_IMPORT locale::id
   {
   private:
     friend class locale;
@@ -468,7 +468,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
 
 
   // Implementation object for locale.
-  class locale::_Impl
+  class _GLIBCXX_IMPORT locale::_Impl
   {
   public:
     // Friends.
diff --git a/libstdc++-v3/include/bits/locale_classes.tcc b/libstdc++-v3/include/bits/locale_classes.tcc
index 5dcf20576..882746e26 100644
--- a/libstdc++-v3/include/bits/locale_classes.tcc
+++ b/libstdc++-v3/include/bits/locale_classes.tcc
@@ -241,8 +241,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   // which are defined via explicit instantiations elsewhere.
   // NB: This syntax is a GNU extension.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class collate<char>;
-  extern template class collate_byname<char>;
+  extern template class _GLIBCXX_IMPORT collate<char>;
+  extern template class _GLIBCXX_IMPORT collate_byname<char>;
 
   extern template
     const collate<char>&
@@ -253,8 +253,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
     has_facet<collate<char> >(const locale&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class collate<wchar_t>;
-  extern template class collate_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT collate<wchar_t>;
+  extern template class _GLIBCXX_IMPORT collate_byname<wchar_t>;
 
   extern template
     const collate<wchar_t>&
diff --git a/libstdc++-v3/include/bits/locale_facets.h b/libstdc++-v3/include/bits/locale_facets.h
index 2e18f7da8..97a2110ef 100644
--- a/libstdc++-v3/include/bits/locale_facets.h
+++ b/libstdc++-v3/include/bits/locale_facets.h
@@ -670,7 +670,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
    *  optimizations as well.
   */
   template<>
-    class ctype<char> : public locale::facet, public ctype_base
+    class _GLIBCXX_IMPORT ctype<char> : public locale::facet, public ctype_base
     {
     public:
       // Types:
@@ -1171,7 +1171,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
    *  __ctype_abstract_base<wchar_t>.
   */
   template<>
-    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
+    class _GLIBCXX_IMPORT ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
     {
     public:
       // Types:
diff --git a/libstdc++-v3/include/bits/locale_facets.tcc b/libstdc++-v3/include/bits/locale_facets.tcc
index 1608e2c42..2cbe1325e 100644
--- a/libstdc++-v3/include/bits/locale_facets.tcc
+++ b/libstdc++-v3/include/bits/locale_facets.tcc
@@ -1276,11 +1276,11 @@ _GLIBCXX_END_LDBL_NAMESPACE
   // which are defined via explicit instantiations elsewhere.
   // NB: This syntax is a GNU extension.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class numpunct<char>;
-  extern template class numpunct_byname<char>;
-  extern template class _GLIBCXX_LDBL_NAMESPACE num_get<char>;
-  extern template class _GLIBCXX_LDBL_NAMESPACE num_put<char>;
-  extern template class ctype_byname<char>;
+  extern template class _GLIBCXX_IMPORT numpunct<char>;
+  extern template class _GLIBCXX_IMPORT numpunct_byname<char>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_LDBL_NAMESPACE num_get<char>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_LDBL_NAMESPACE num_put<char>;
+  extern template class _GLIBCXX_IMPORT ctype_byname<char>;
 
   extern template
     const ctype<char>&
@@ -1315,11 +1315,11 @@ _GLIBCXX_END_LDBL_NAMESPACE
     has_facet<num_get<char> >(const locale&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class numpunct<wchar_t>;
-  extern template class numpunct_byname<wchar_t>;
-  extern template class _GLIBCXX_LDBL_NAMESPACE num_get<wchar_t>;
-  extern template class _GLIBCXX_LDBL_NAMESPACE num_put<wchar_t>;
-  extern template class ctype_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT numpunct<wchar_t>;
+  extern template class _GLIBCXX_IMPORT numpunct_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_LDBL_NAMESPACE num_get<wchar_t>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_LDBL_NAMESPACE num_put<wchar_t>;
+  extern template class _GLIBCXX_IMPORT ctype_byname<wchar_t>;
 
   extern template
     const ctype<wchar_t>&
diff --git a/libstdc++-v3/include/bits/locale_facets_nonio.tcc b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
index 48a913901..ec5843c00 100644
--- a/libstdc++-v3/include/bits/locale_facets_nonio.tcc
+++ b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
@@ -1214,19 +1214,19 @@ _GLIBCXX_END_LDBL_NAMESPACE
   // which are defined via explicit instantiations elsewhere.
   // NB: This syntax is a GNU extension.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class moneypunct<char, false>;
-  extern template class moneypunct<char, true>;
-  extern template class moneypunct_byname<char, false>;
-  extern template class moneypunct_byname<char, true>;
-  extern template class _GLIBCXX_LDBL_NAMESPACE money_get<char>;
-  extern template class _GLIBCXX_LDBL_NAMESPACE money_put<char>;
-  extern template class __timepunct<char>;
-  extern template class time_put<char>;
-  extern template class time_put_byname<char>;
-  extern template class time_get<char>;
-  extern template class time_get_byname<char>;
-  extern template class messages<char>;
-  extern template class messages_byname<char>;
+  extern template class _GLIBCXX_IMPORT moneypunct<char, false>;
+  extern template class _GLIBCXX_IMPORT moneypunct<char, true>;
+  extern template class _GLIBCXX_IMPORT moneypunct_byname<char, false>;
+  extern template class _GLIBCXX_IMPORT moneypunct_byname<char, true>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_LDBL_NAMESPACE money_get<char>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_LDBL_NAMESPACE money_put<char>;
+  extern template class _GLIBCXX_IMPORT __timepunct<char>;
+  extern template class _GLIBCXX_IMPORT time_put<char>;
+  extern template class _GLIBCXX_IMPORT time_put_byname<char>;
+  extern template class _GLIBCXX_IMPORT time_get<char>;
+  extern template class _GLIBCXX_IMPORT time_get_byname<char>;
+  extern template class _GLIBCXX_IMPORT messages<char>;
+  extern template class _GLIBCXX_IMPORT messages_byname<char>;
 
   extern template
     const moneypunct<char, true>&
@@ -1289,19 +1289,19 @@ _GLIBCXX_END_LDBL_NAMESPACE
     has_facet<messages<char> >(const locale&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class moneypunct<wchar_t, false>;
-  extern template class moneypunct<wchar_t, true>;
-  extern template class moneypunct_byname<wchar_t, false>;
-  extern template class moneypunct_byname<wchar_t, true>;
-  extern template class _GLIBCXX_LDBL_NAMESPACE money_get<wchar_t>;
-  extern template class _GLIBCXX_LDBL_NAMESPACE money_put<wchar_t>;
-  extern template class __timepunct<wchar_t>;
-  extern template class time_put<wchar_t>;
-  extern template class time_put_byname<wchar_t>;
-  extern template class time_get<wchar_t>;
-  extern template class time_get_byname<wchar_t>;
-  extern template class messages<wchar_t>;
-  extern template class messages_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT moneypunct<wchar_t, false>;
+  extern template class _GLIBCXX_IMPORT moneypunct<wchar_t, true>;
+  extern template class _GLIBCXX_IMPORT moneypunct_byname<wchar_t, false>;
+  extern template class _GLIBCXX_IMPORT moneypunct_byname<wchar_t, true>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_LDBL_NAMESPACE money_get<wchar_t>;
+  extern template class _GLIBCXX_IMPORT _GLIBCXX_LDBL_NAMESPACE money_put<wchar_t>;
+  extern template class _GLIBCXX_IMPORT __timepunct<wchar_t>;
+  extern template class _GLIBCXX_IMPORT time_put<wchar_t>;
+  extern template class _GLIBCXX_IMPORT time_put_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT time_get<wchar_t>;
+  extern template class _GLIBCXX_IMPORT time_get_byname<wchar_t>;
+  extern template class _GLIBCXX_IMPORT messages<wchar_t>;
+  extern template class _GLIBCXX_IMPORT messages_byname<wchar_t>;
 
   extern template
     const moneypunct<wchar_t, true>&
diff --git a/libstdc++-v3/include/bits/ostream.tcc b/libstdc++-v3/include/bits/ostream.tcc
index 1147212aa..4293b9cc9 100644
--- a/libstdc++-v3/include/bits/ostream.tcc
+++ b/libstdc++-v3/include/bits/ostream.tcc
@@ -357,7 +357,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   // which are defined via explicit instantiations elsewhere.
   // NB:  This syntax is a GNU extension.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_ostream<char>;
+  extern template class _GLIBCXX_IMPORT basic_ostream<char>;
   extern template ostream& endl(ostream&);
   extern template ostream& ends(ostream&);
   extern template ostream& flush(ostream&);
@@ -380,7 +380,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   extern template ostream& ostream::_M_insert(const void*);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_ostream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_ostream<wchar_t>;
   extern template wostream& endl(wostream&);
   extern template wostream& ends(wostream&);
   extern template wostream& flush(wostream&);
diff --git a/libstdc++-v3/include/bits/sstream.tcc b/libstdc++-v3/include/bits/sstream.tcc
index 0f9db8e93..f0f03d1ca 100644
--- a/libstdc++-v3/include/bits/sstream.tcc
+++ b/libstdc++-v3/include/bits/sstream.tcc
@@ -255,16 +255,16 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   // which are defined via explicit instantiations elsewhere.
   // NB:  This syntax is a GNU extension.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_stringbuf<char>;
-  extern template class basic_istringstream<char>;
-  extern template class basic_ostringstream<char>;
-  extern template class basic_stringstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_stringbuf<char>;
+  extern template class _GLIBCXX_IMPORT basic_istringstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_ostringstream<char>;
+  extern template class _GLIBCXX_IMPORT basic_stringstream<char>;
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_stringbuf<wchar_t>;
-  extern template class basic_istringstream<wchar_t>;
-  extern template class basic_ostringstream<wchar_t>;
-  extern template class basic_stringstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_stringbuf<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_istringstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_ostringstream<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_stringstream<wchar_t>;
 #endif
 #endif
 
diff --git a/libstdc++-v3/include/bits/streambuf.tcc b/libstdc++-v3/include/bits/streambuf.tcc
index f3e6ce749..4858f7b72 100644
--- a/libstdc++-v3/include/bits/streambuf.tcc
+++ b/libstdc++-v3/include/bits/streambuf.tcc
@@ -146,7 +146,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   // which are defined via explicit instantiations elsewhere.
   // NB:  This syntax is a GNU extension.
 #if _GLIBCXX_EXTERN_TEMPLATE
-  extern template class basic_streambuf<char>;
+  extern template class _GLIBCXX_IMPORT basic_streambuf<char>;
   extern template
     streamsize
     __copy_streambufs(basic_streambuf<char>*,
@@ -157,7 +157,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
 			  basic_streambuf<char>*, bool&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern template class basic_streambuf<wchar_t>;
+  extern template class _GLIBCXX_IMPORT basic_streambuf<wchar_t>;
   extern template
     streamsize
     __copy_streambufs(basic_streambuf<wchar_t>*,
diff --git a/libstdc++-v3/include/ext/concurrence.h b/libstdc++-v3/include/ext/concurrence.h
index 71f8cd0a7..d772c8746 100644
--- a/libstdc++-v3/include/ext/concurrence.h
+++ b/libstdc++-v3/include/ext/concurrence.h
@@ -60,7 +60,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)
 
   // NB: As this is used in libsupc++, need to only depend on
   // exception. No stdexception classes, no use of std::string.
-  class __concurrence_lock_error : public std::exception
+  class _GLIBCXX_IMPORT __concurrence_lock_error : public std::exception
   {
   public:
     virtual char const*
@@ -68,7 +68,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)
     { return "__gnu_cxx::__concurrence_lock_error"; }
   };
 
-  class __concurrence_unlock_error : public std::exception
+  class _GLIBCXX_IMPORT __concurrence_unlock_error : public std::exception
   {
   public:
     virtual char const*
diff --git a/libstdc++-v3/include/std/iostream b/libstdc++-v3/include/std/iostream
index 9212ea828..ecd40b2cf 100644
--- a/libstdc++-v3/include/std/iostream
+++ b/libstdc++-v3/include/std/iostream
@@ -56,16 +56,16 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
    *  linked to above.
   */
   //@{
-  extern istream cin;		///< Linked to standard input
-  extern ostream cout;		///< Linked to standard output
-  extern ostream cerr;		///< Linked to standard error (unbuffered)
-  extern ostream clog;		///< Linked to standard error (buffered)
+  extern _GLIBCXX_IMPORT istream cin;		///< Linked to standard input
+  extern _GLIBCXX_IMPORT ostream cout;		///< Linked to standard output
+  extern _GLIBCXX_IMPORT ostream cerr;		///< Linked to standard error (unbuffered)
+  extern _GLIBCXX_IMPORT ostream clog;		///< Linked to standard error (buffered)
 
 #ifdef _GLIBCXX_USE_WCHAR_T
-  extern wistream wcin;		///< Linked to standard input
-  extern wostream wcout;	///< Linked to standard output
-  extern wostream wcerr;	///< Linked to standard error (unbuffered)
-  extern wostream wclog;	///< Linked to standard error (buffered)
+  extern _GLIBCXX_IMPORT wistream wcin;		///< Linked to standard input
+  extern _GLIBCXX_IMPORT wostream wcout;	///< Linked to standard output
+  extern _GLIBCXX_IMPORT wostream wcerr;	///< Linked to standard error (unbuffered)
+  extern _GLIBCXX_IMPORT wostream wclog;	///< Linked to standard error (buffered)
 #endif
   //@}
 
diff --git a/libstdc++-v3/include/std/stdexcept b/libstdc++-v3/include/std/stdexcept
index 9f5c9761c..1d1db62f0 100644
--- a/libstdc++-v3/include/std/stdexcept
+++ b/libstdc++-v3/include/std/stdexcept
@@ -50,7 +50,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
    *  program runs (e.g., violations of class invariants).
    *  @brief One of two subclasses of exception.
    */
-  class logic_error : public exception 
+  class _GLIBCXX_IMPORT logic_error : public exception
   {
     string _M_msg;
 
@@ -70,14 +70,14 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
 
   /** Thrown by the library, or by you, to report domain errors (domain in
    *  the mathematical sense).  */
-  class domain_error : public logic_error 
+  class _GLIBCXX_IMPORT domain_error : public logic_error
   {
   public:
     explicit domain_error(const string& __arg);
   };
 
   /** Thrown to report invalid arguments to functions.  */
-  class invalid_argument : public logic_error 
+  class _GLIBCXX_IMPORT invalid_argument : public logic_error
   {
   public:
     explicit invalid_argument(const string& __arg);
@@ -85,7 +85,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
 
   /** Thrown when an object is constructed that would exceed its maximum
    *  permitted size (e.g., a basic_string instance).  */
-  class length_error : public logic_error 
+  class _GLIBCXX_IMPORT length_error : public logic_error
   {
   public:
     explicit length_error(const string& __arg);
@@ -93,7 +93,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
 
   /** This represents an argument whose value is not within the expected
    *  range (e.g., boundary checks in basic_string).  */
-  class out_of_range : public logic_error 
+  class _GLIBCXX_IMPORT out_of_range : public logic_error
   {
   public:
     explicit out_of_range(const string& __arg);
@@ -104,7 +104,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
    *  the program executes.
    *  @brief One of two subclasses of exception.
    */
-  class runtime_error : public exception 
+  class _GLIBCXX_IMPORT runtime_error : public exception
   {
     string _M_msg;
 
@@ -123,7 +123,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   };
 
   /** Thrown to indicate range errors in internal computations.  */
-  class range_error : public runtime_error 
+  class _GLIBCXX_IMPORT range_error : public runtime_error
   {
   public:
     explicit range_error(const string& __arg);
@@ -137,7 +137,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)
   };
 
   /** Thrown to indicate arithmetic underflow.  */
-  class underflow_error : public runtime_error 
+  class _GLIBCXX_IMPORT underflow_error : public runtime_error
   {
   public:
     explicit underflow_error(const string& __arg);
diff --git a/libstdc++-v3/libsupc++/Makefile.am b/libstdc++-v3/libsupc++/Makefile.am
index 0b2fd0bc7..53419472d 100644
--- a/libstdc++-v3/libsupc++/Makefile.am
+++ b/libstdc++-v3/libsupc++/Makefile.am
@@ -154,7 +154,8 @@ LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared $(LIBTOOLFLAGS) \
 	       --mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \
 	       $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) 
 
-LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS)) \
+		-no-undefined -bindir $(bindir)
 
 # 3) We'd have a problem when building the shared libstdc++ object if
 # the rules automake generates would be used.  We cannot allow g++ to
diff --git a/libstdc++-v3/libsupc++/Makefile.in b/libstdc++-v3/libsupc++/Makefile.in
index a535d49cd..5517d0c9f 100644
--- a/libstdc++-v3/libsupc++/Makefile.in
+++ b/libstdc++-v3/libsupc++/Makefile.in
@@ -466,7 +466,9 @@ LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared $(LIBTOOLFLAGS) \
 	       --mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \
 	       $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) 
 
-LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS)) \
+		-no-undefined -bindir $(bindir)
+
 
 # 3) We'd have a problem when building the shared libstdc++ object if
 # the rules automake generates would be used.  We cannot allow g++ to
diff --git a/libstdc++-v3/libsupc++/exception b/libstdc++-v3/libsupc++/exception
index 857b2022b..df30ea36c 100644
--- a/libstdc++-v3/libsupc++/exception
+++ b/libstdc++-v3/libsupc++/exception
@@ -58,7 +58,7 @@ namespace std
    *  your own %exception classes, or use a different hierarchy, or to
    *  throw non-class data (e.g., fundamental types).
    */
-  class exception
+  class _GLIBCXX_IMPORT exception
   {
   public:
     exception() throw() { }
@@ -71,7 +71,7 @@ namespace std
 
   /** If an %exception is thrown which is not listed in a function's
    *  %exception specification, one of these may be thrown.  */
-  class bad_exception : public exception
+  class _GLIBCXX_IMPORT bad_exception : public exception
   {
   public:
     bad_exception() throw() { }
diff --git a/libstdc++-v3/libsupc++/new b/libstdc++-v3/libsupc++/new
index 7b515311c..b1411749c 100644
--- a/libstdc++-v3/libsupc++/new
+++ b/libstdc++-v3/libsupc++/new
@@ -53,7 +53,7 @@ namespace std
    *
    *  @c bad_alloc (or classes derived from it) is used to report allocation
    *  errors from the throwing forms of @c new.  */
-  class bad_alloc : public exception 
+  class _GLIBCXX_IMPORT bad_alloc : public exception
   {
   public:
     bad_alloc() throw() { }
diff --git a/libstdc++-v3/libsupc++/typeinfo b/libstdc++-v3/libsupc++/typeinfo
index 1a4736e1c..fefff89c7 100644
--- a/libstdc++-v3/libsupc++/typeinfo
+++ b/libstdc++-v3/libsupc++/typeinfo
@@ -84,7 +84,7 @@ namespace std
    *  The @c type_info class describes type information generated by
    *  an implementation.
   */
-  class type_info 
+  class _GLIBCXX_IMPORT type_info 
   {
   public:
     /** Destructor first. Being the first non-inline virtual function, this
@@ -171,7 +171,7 @@ namespace std
    *
    *  If you attempt an invalid @c dynamic_cast expression, an instance of
    *  this class (or something derived from this class) is thrown.  */
-  class bad_cast : public exception 
+  class _GLIBCXX_IMPORT bad_cast : public exception 
   {
   public:
     bad_cast() throw() { }
@@ -188,7 +188,7 @@ namespace std
    *  @brief Thrown when a NULL pointer in a @c typeid expression is used.
    *  @ingroup exceptions
    */
-  class bad_typeid : public exception 
+  class _GLIBCXX_IMPORT bad_typeid : public exception 
   {
   public:
     bad_typeid () throw() { }
diff --git a/libstdc++-v3/scripts/testsuite_flags.in b/libstdc++-v3/scripts/testsuite_flags.in
index 457adaf4d..aa31e3a98 100755
--- a/libstdc++-v3/scripts/testsuite_flags.in
+++ b/libstdc++-v3/scripts/testsuite_flags.in
@@ -27,6 +27,7 @@ EOF
 BUILD_DIR=@glibcxx_builddir@
 SRC_DIR=@glibcxx_srcdir@
 PREFIX_DIR=@glibcxx_prefixdir@
+target=@target@
 query=$1
 
 case ${query} in
@@ -71,6 +72,12 @@ case ${query} in
       ;;
     --cxxldflags)
       SECTIONLDFLAGS="@SECTION_LDFLAGS@ @LIBICONV@"
+      case ${target} in
+	  *cygwin*)
+	  SECTIONLDFLAGS="${SECTIONLDFLAGS} -Wl,--enable-auto-import"
+	  ;;
+      esac
+
       echo ${SECTIONLDFLAGS}
       ;;
     *)
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index 9b1e830ee..a652599a2 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -210,7 +210,8 @@ libstdc___la_DEPENDENCIES = \
 	$(top_builddir)/libsupc++/libsupc++convenience.la
 
 libstdc___la_LDFLAGS = \
-	-version-info $(libtool_VERSION) ${version_arg} -lm 
+	-version-info $(libtool_VERSION) ${version_arg} -lm \
+	-no-undefined -bindir $(bindir)
 
 libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)
 
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index a385e4c6d..abc5732ad 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -452,7 +452,8 @@ libstdc___la_DEPENDENCIES = \
 	$(top_builddir)/libsupc++/libsupc++convenience.la
 
 libstdc___la_LDFLAGS = \
-	-version-info $(libtool_VERSION) ${version_arg} -lm 
+	-version-info $(libtool_VERSION) ${version_arg} -lm \
+	-no-undefined -bindir $(bindir)
 
 libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)
 
diff --git a/libstdc++-v3/testsuite/lib/libstdc++.exp b/libstdc++-v3/testsuite/lib/libstdc++.exp
index e749d2236..ff529fec1 100644
--- a/libstdc++-v3/testsuite/lib/libstdc++.exp
+++ b/libstdc++-v3/testsuite/lib/libstdc++.exp
@@ -124,6 +124,9 @@ proc libstdc++_init { testfile } {
 	if { [string match "powerpc-*-darwin*" $target_triplet] } {
 	    append DEFAULT_CXXFLAGS " -multiply_defined suppress"
 	} 
+	if { [string match "*-*-cygwin*" $target_triplet] } {
+	    append DEFAULT_CXXFLAGS " -Wl,--enable-auto-import"
+	} 
     }
     v3track DEFAULT_CXXFLAGS 2
 
@@ -144,6 +147,9 @@ proc libstdc++_init { testfile } {
         set gccdir [file dirname $gccdir]
 	append ld_library_path_tmp ":${gccdir}"
     }
+    if { [string match "*-*-cygwin*" $target_triplet] } {
+	append ld_library_path_tmp ":${blddir}/../libgcc"
+    }
     v3track gccdir 3
 
     # Locate libgomp. This is only required for parallel mode.
