diff --git a/gcc/config/pa/fptr.c b/gcc/config/pa/fptr.c
new file mode 100644
index 0000000..36ed49c
--- /dev/null
+++ b/gcc/config/pa/fptr.c
@@ -0,0 +1,127 @@
+/* Subroutine for function pointer canonicalization on PA-RISC with ELF32.
+   Copyright 2002 Free Software Foundation, Inc.
+   Contributed by John David Anglin (dave.anglin@nrc.ca).
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* WARNING: The code is this function depends on internal and undocumented
+   details of the GNU linker and dynamic loader as implemented for parisc
+   linux.  */
+
+/* This MUST match the defines sysdeps/hppa/dl-machine.h and
+   bfd/elf32-hppa.c.  */
+#define GOT_FROM_PLT_STUB (4*4)
+
+/* List of byte offsets in _dl_runtime_resolve to search for "bl" branches.
+   The first "bl" branch instruction found MUST be a call to fixup.  See
+   the define for TRAMPOLINE_TEMPLATE in sysdeps/hppa/dl-machine.h.  If
+   the trampoline template is changed, the list must be appropriately
+   updated.  The offset of -4 allows for a magic branch at the start of
+   the template should it be necessary to change the current branch
+   position.  */
+#define NOFFSETS 2
+static int fixup_branch_offset[NOFFSETS] = { 32, -4 };
+
+#define GET_FIELD(X, FROM, TO) \
+  ((X) >> (31 - (TO)) & ((1 << ((TO) - (FROM) + 1)) - 1))
+#define SIGN_EXTEND(VAL,BITS) \
+  ((int) ((VAL) >> ((BITS) - 1) ? (-1 << (BITS)) | (VAL) : (VAL)))
+
+struct link_map;
+typedef int (*fptr_t) (void);
+typedef int (*fixup_t) (struct link_map *, unsigned int);
+extern unsigned int _GLOBAL_OFFSET_TABLE_;
+
+/* __canonicalize_funcptr_for_compare must be hidden so that it is not
+   placed in the dynamic symbol table.  Like millicode functions, it
+   must be linked into all binaries in order access the got table of 
+   that binary.  However, we don't use the millicode calling convention
+   and the routine must be a normal function so that it can be compiled
+   as pic code.  */
+unsigned int __canonicalize_funcptr_for_compare (fptr_t)
+      __attribute__ ((visibility ("hidden")));
+
+unsigned int
+__canonicalize_funcptr_for_compare (fptr)
+     fptr_t fptr;
+{
+  static unsigned int fixup_plabel[2];
+  static fixup_t fixup;
+  unsigned int *plabel, *got;
+
+  /* -1 and page 0 are special.  -1 is used in crtend to mark the end of
+     a list of function pointers.  Also return immediately if the plabel
+     bit is not set in the function pointer.  In this case, the function
+     pointer points directly to the function.  */
+  if ((int) fptr == -1 || (unsigned int) fptr < 4096 || !((int) fptr & 2))
+    return (unsigned int) fptr;
+
+  /* The function pointer points to a function descriptor (plabel).  If
+     the plabel hasn't been resolved, the first word of the plabel points
+     to the entry of the PLT stub just before the global offset table.
+     The second word in the plabel contains the relocation offset for the
+     function.  */
+  plabel = (unsigned int *) ((unsigned int) fptr & ~3);
+  got = (unsigned int *) (plabel[0] + GOT_FROM_PLT_STUB);
+
+  /* Return the address of the function if the plabel has been resolved.  */
+  if (got !=  &_GLOBAL_OFFSET_TABLE_)
+    return plabel[0];
+
+  /* Initialize our plabel for calling fixup if we haven't done so already.
+     This code needs to be thread safe but we don't have to be too careful
+     as the result is invariant.  */
+  if (!fixup)
+    {
+      int i;
+      unsigned int *iptr;
+
+      /* Find the first "bl" branch in the offset search list.  This is a
+	 call to fixup or a magic branch to fixup at the beginning of the
+	 trampoline template.  The fixup function does the actual runtime
+	 resolution of function decriptors.  We only look for "bl" branches
+	 with a 17-bit pc-relative displacement.  */
+      for (i = 0; i < NOFFSETS; i++)
+	{
+	  iptr = (unsigned int *) (got[-2] + fixup_branch_offset[i]);
+	  if ((*iptr & 0xfc00e000) == 0xe8000000)
+	    break;
+	}
+
+      /* This should not happen... */
+      if (i == NOFFSETS)
+	return ~0;
+
+      /* Extract the 17-bit displacement from the instruction.  */
+      iptr += SIGN_EXTEND (GET_FIELD (*iptr, 19, 28) |
+			   GET_FIELD (*iptr, 29, 29) << 10 |
+			   GET_FIELD (*iptr, 11, 15) << 11 |
+			   GET_FIELD (*iptr, 31, 31) << 16, 17);
+
+      /* Build a plabel for an indirect call to fixup.  */
+      fixup_plabel[0] = (unsigned int) iptr + 8;  /* address of fixup */
+      fixup_plabel[1] = got[-1];		  /* ltp for fixup */
+      fixup = (fixup_t) ((int) fixup_plabel | 3);
+    }
+
+  /* Call fixup to resolve the function address.  got[1] contains the
+     link_map pointer and plabel[1] the relocation offset.  */
+  fixup ((struct link_map *) got[1], plabel[1]);
+
+  return plabel[0];
+}
diff --git a/gcc/config/pa/pa-linux.h b/gcc/config/pa/pa-linux.h
index 81e807c..17f2762 100644
--- a/gcc/config/pa/pa-linux.h
+++ b/gcc/config/pa/pa-linux.h
@@ -81,7 +81,7 @@ Boston, MA 02111-1307, USA.  */
    file which includes this one.  */
 
 #undef STRING_ASM_OP
-#define STRING_ASM_OP   ".stringz"
+#define STRING_ASM_OP   "\t.stringz\t"
 
 #define TEXT_SECTION_ASM_OP "\t.text"
 #define DATA_SECTION_ASM_OP "\t.data"
diff --git a/gcc/config/pa/pa.h b/gcc/config/pa/pa.h
index f311d6b..19ad9e3 100644
--- a/gcc/config/pa/pa.h
+++ b/gcc/config/pa/pa.h
@@ -2030,3 +2030,7 @@ while (0)
   {"cmpib_comparison_operator", {EQ, NE, LT, LE, LEU,			\
    GT, GTU, GE}},							\
   {"movb_comparison_operator", {EQ, NE, LT, GE}},
+
+/* We need a libcall to canonicalize function pointers on TARGET_ELF32.  */
+#define CANONICALIZE_FUNCPTR_FOR_COMPARE_LIBCALL \
+  "__canonicalize_funcptr_for_compare"
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index a0e3d80..7b8e4ba 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -7117,9 +7117,20 @@
 	      (clobber (reg:SI 31))])
    (set (match_operand:SI 0 "register_operand" "")
 	(reg:SI 29))]
-  "! TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && !TARGET_ELF32"
+  "!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT"
   "
 {
+  if (TARGET_ELF32)
+    {
+      rtx canonicalize_funcptr_for_compare_libfunc
+        = init_one_libfunc (CANONICALIZE_FUNCPTR_FOR_COMPARE_LIBCALL);
+
+      emit_library_call_value (canonicalize_funcptr_for_compare_libfunc,
+      			       operands[0], LCT_NORMAL, Pmode,
+			       1, operands[1], Pmode);
+      DONE;
+    }
+
   operands[2] = gen_reg_rtx (SImode);
   if (GET_CODE (operands[1]) != REG)
     {
diff --git a/gcc/config/pa/pa32-linux.h b/gcc/config/pa/pa32-linux.h
index 81f6452..8652122 100644
--- a/gcc/config/pa/pa32-linux.h
+++ b/gcc/config/pa/pa32-linux.h
@@ -24,3 +24,17 @@ Boston, MA 02111-1307, USA.  */
 
 #undef CPP_SPEC
 #define CPP_SPEC "%{fPIC:-D__PIC__ -D__pic__} %{fpic:-D__PIC__ -D__pic__} %{mhppa:-D__hppa__} %{posix:-D_POSIX_SOURCE} -D_PA_RISC1_1"
+
+/* The libcall __canonicalize_funcptr_for_compare is referenced in
+   crtend.o and the reference isn't resolved in objects that don't
+   compare function pointers.  Thus, we need to play games to provide
+   a reference in crtbegin.o.  The rest of the define is the same
+   as that in crtstuff.c  */
+#define CTOR_LIST_BEGIN \
+  asm (".type __canonicalize_funcptr_for_compare,@function\n"		\
+"	.text\n"							\
+"	.word __canonicalize_funcptr_for_compare-$PIC_pcrel$0");	\
+  STATIC func_ptr __CTOR_LIST__[1]					\
+    __attribute__ ((__unused__, section(".ctors"),			\
+		    aligned(sizeof(func_ptr))))				\
+    = { (func_ptr) (-1) }
diff --git a/gcc/config/pa/t-linux b/gcc/config/pa/t-linux
index 400b800..601f779 100644
--- a/gcc/config/pa/t-linux
+++ b/gcc/config/pa/t-linux
@@ -9,6 +9,12 @@ LIB1ASMFUNCS =  _divI _divU _remI _remU _multiply \
 
 LIB1ASMSRC = pa/milli32.S
 
+LIB2FUNCS_EXTRA=fptr.c
+
+fptr.c: $(srcdir)/config/pa/fptr.c
+	rm -f fptr.c
+	cp $(srcdir)/config/pa/fptr.c .
+
 # Compile crtbeginS.o and crtendS.o as PIC.
 CRTSTUFF_T_CFLAGS_S = -fPIC
 
diff --git a/libffi/Makefile.am b/libffi/Makefile.am
index 4d1120d..fd6b748 100644
--- a/libffi/Makefile.am
+++ b/libffi/Makefile.am
@@ -15,7 +15,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \
 		src/powerpc/ffi_darwin.c \
 		src/powerpc/darwin.S src/powerpc/aix.S \
 		src/powerpc/darwin_closure.S src/powerpc/aix_closures.S \
-		src/arm/ffi.c src/arm/sysv.S
+		src/arm/ffi.c src/arm/sysv.S \
+		src/pa/ffi.c src/pa/linux.S
 
 VPATH = @srcdir@:@srcdir@/src:@srcdir@/src/@TARGETDIR@
 
@@ -85,11 +86,7 @@ endif
 toolexeclib_LTLIBRARIES = libffi.la
 noinst_LTLIBRARIES = libffi_convenience.la
 
-noinst_PROGRAMS = ffitest
-
-ffitest_OBJECTS = ffitest.lo
-ffitest_LDADD = libffi.la
-ffitest_LDFLAGS = -shared-libgcc
+noinst_PROGRAMS = 
 
 TARGET_SRC_MIPS_GCC = src/mips/ffi.c src/mips/o32.S src/mips/n32.S
 TARGET_SRC_MIPS_SGI = src/mips/ffi.c src/mips/o32.s src/mips/n32.s
@@ -103,6 +100,7 @@ TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closur
 TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closures.S
 TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S
 TARGET_SRC_ARM =  src/arm/sysv.S src/arm/ffi.c
+TARGET_SRC_PA =  src/pa/linux.S src/pa/ffi.c
 
 ##libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c $(TARGET_SRC_@TARGET@)
 ## Work around automake deficiency
@@ -156,6 +154,10 @@ if ARM
 libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)
 libffi_convenience_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)
 endif
+if PA
+libffi_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_PA)
+libffi_convenience_la_SOURCES = $(libffi_la_common_SOURCES) $(TARGET_SRC_PA)
+endif
 
 AM_CFLAGS = -fexceptions
 
diff --git a/libffi/Makefile.in b/libffi/Makefile.in
index 24f2930..17ae980 100644
--- a/libffi/Makefile.in
+++ b/libffi/Makefile.in
@@ -91,6 +91,7 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \
 		src/x86/ffi.c src/x86/sysv.S src/x86/win32.S \
 		src/alpha/ffi.c src/alpha/osf.S \
 		src/m68k/ffi.c src/m68k/sysv.S \
+		src/pa/ffi.c src/pa/linux.S \
 		src/powerpc/ffi.c src/powerpc/sysv.S \
 		src/powerpc/ppc_closure.S src/powerpc/asm.h \
 		src/powerpc/ffi_darwin.c \
@@ -156,11 +157,7 @@ MULTICLEAN = true
 toolexeclib_LTLIBRARIES = libffi.la
 noinst_LTLIBRARIES = libffi_convenience.la
 
-noinst_PROGRAMS = ffitest
-
-ffitest_OBJECTS = ffitest.lo
-ffitest_LDADD = libffi.la
-ffitest_LDFLAGS = -shared-libgcc
+noinst_PROGRAMS = 
 
 TARGET_SRC_MIPS_GCC = src/mips/ffi.c src/mips/o32.S src/mips/n32.S
 TARGET_SRC_MIPS_SGI = src/mips/ffi.c src/mips/o32.s src/mips/n32.s
@@ -174,6 +171,7 @@ TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closur
 TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closures.S
 TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S
 TARGET_SRC_ARM = src/arm/sysv.S src/arm/ffi.c
+TARGET_SRC_PA = src/pa/linux.S src/pa/ffi.c
 
 libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \
 		src/raw_api.c src/java_raw_api.c
@@ -190,6 +188,7 @@ libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \
 @POWERPC_AIX_TRUE@libffi_la_SOURCES = @POWERPC_AIX_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC_AIX)
 @POWERPC_DARWIN_TRUE@libffi_la_SOURCES = @POWERPC_DARWIN_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC_DARWIN)
 @ARM_TRUE@libffi_la_SOURCES = @ARM_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)
+@PA_TRUE@libffi_la_SOURCES = @PA_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_PA)
 @MIPS_GCC_TRUE@libffi_convenience_la_SOURCES = @MIPS_GCC_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_GCC)
 @MIPS_SGI_TRUE@libffi_convenience_la_SOURCES = @MIPS_SGI_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_MIPS_SGI)
 @X86_TRUE@libffi_convenience_la_SOURCES = @X86_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_X86)
@@ -202,6 +201,7 @@ libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \
 @POWERPC_AIX_TRUE@libffi_convenience_la_SOURCES = @POWERPC_AIX_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC_AIX)
 @POWERPC_DARWIN_TRUE@libffi_convenience_la_SOURCES = @POWERPC_DARWIN_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_POWERPC_DARWIN)
 @ARM_TRUE@libffi_convenience_la_SOURCES = @ARM_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_ARM)
+@PA_TRUE@libffi_convenience_la_SOURCES = @PA_TRUE@$(libffi_la_common_SOURCES) $(TARGET_SRC_PA)
 
 AM_CFLAGS = -fexceptions
 
@@ -232,6 +232,9 @@ libffi_convenience_la_LIBADD =
 @ALPHA_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \
 @ALPHA_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \
 @ALPHA_TRUE@src/java_raw_api.lo src/alpha/ffi.lo src/alpha/osf.lo
+@PA_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \
+@PA_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \
+@PA_TRUE@src/pa/linux.lo src/pa/ffi.lo
 @IA64_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \
 @IA64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \
 @IA64_TRUE@src/ia64/ffi.lo src/ia64/unix.lo
@@ -275,6 +278,9 @@ libffi_la_LIBADD =
 @ALPHA_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \
 @ALPHA_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \
 @ALPHA_TRUE@src/alpha/ffi.lo src/alpha/osf.lo
+@PA_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \
+@PA_TRUE@src/raw_api.lo src/java_raw_api.lo \
+@PA_TRUE@src/pa/linux.lo src/pa/ffi.lo
 @IA64_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \
 @IA64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \
 @IA64_TRUE@src/ia64/ffi.lo src/ia64/unix.lo
@@ -304,10 +310,9 @@ libffi_la_LIBADD =
 @M68K_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \
 @M68K_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \
 @M68K_TRUE@src/m68k/ffi.lo src/m68k/sysv.lo
-noinst_PROGRAMS =  ffitest$(EXEEXT)
+noinst_PROGRAMS = 
 PROGRAMS =  $(noinst_PROGRAMS)
 
-ffitest_DEPENDENCIES =  libffi.la
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
@@ -446,10 +451,6 @@ distclean-noinstPROGRAMS:
 
 maintainer-clean-noinstPROGRAMS:
 
-ffitest$(EXEEXT): $(ffitest_OBJECTS) $(ffitest_DEPENDENCIES)
-	@rm -f ffitest$(EXEEXT)
-	$(LINK) $(ffitest_LDFLAGS) $(ffitest_OBJECTS) $(ffitest_LDADD) $(LIBS)
-
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
 # To change the values of `make' variables: instead of editing Makefiles,
@@ -578,7 +579,7 @@ distdir: $(DISTFILES)
 	mkdir $(distdir)
 	-chmod 777 $(distdir)
 	$(mkinstalldirs) $(distdir)/src/alpha $(distdir)/src/arm \
-	   $(distdir)/src/m68k $(distdir)/src/mips \
+	   $(distdir)/src/m68k $(distdir)/src/mips $(distdir)/src/pa \
 	   $(distdir)/src/powerpc $(distdir)/src/sparc \
 	   $(distdir)/src/x86
 	@for file in $(DISTFILES); do \
diff --git a/libffi/configure b/libffi/configure
index e114a3f..0351103 100755
--- a/libffi/configure
+++ b/libffi/configure
@@ -2403,6 +2403,7 @@ powerpc-*-darwin*) TARGET=POWERPC_DARWIN; TARGETDIR=powerpc;;
 powerpc-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;
 rs6000-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;
 arm*-*-linux-*) TARGET=ARM; TARGETDIR=arm;;
+hppa*-*-linux* | parisc-*-linux*) TARGET=PA; TARGETDIR=pa;;
 esac
 
 if test $TARGETDIR = unknown; then
diff --git a/libffi/configure.in b/libffi/configure.in
index e8ee826..12b23ad 100644
--- a/libffi/configure.in
+++ b/libffi/configure.in
@@ -67,6 +67,7 @@ powerpc-*-darwin*) TARGET=POWERPC_DARWIN; TARGETDIR=powerpc;;
 powerpc-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;
 rs6000-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;
 arm*-*-linux-*) TARGET=ARM; TARGETDIR=arm;;
+hppa*-*-linux* | parisc-*-linux*) TARGET=PA; TARGETDIR=pa;;
 esac
 
 if test $TARGETDIR = unknown; then
@@ -85,6 +86,7 @@ AM_CONDITIONAL(POWERPC, test x$TARGET = xPOWERPC)
 AM_CONDITIONAL(POWERPC_AIX, test x$TARGET = xPOWERPC_AIX)
 AM_CONDITIONAL(POWERPC_DARWIN, test x$TARGET = xPOWERPC_DARWIN)
 AM_CONDITIONAL(ARM, test x$TARGET = xARM)
+AM_CONDITIONAL(PA, test x$TARGET = xPA)
 
 AC_HEADER_STDC
 AC_CHECK_FUNCS(memcpy)
diff --git a/libffi/include/ffi.h.in b/libffi/include/ffi.h.in
index 8097917..e19d2f5 100644
--- a/libffi/include/ffi.h.in
+++ b/libffi/include/ffi.h.in
@@ -251,6 +251,12 @@ typedef enum ffi_abi {
   FFI_DEFAULT_ABI = FFI_SYSV,
 #endif
 
+  /* ---- PA ------------------- */
+#ifdef PA
+  FFI_LINUX,
+  FFI_DEFAULT_ABI = FFI_LINUX,
+#endif
+
   /* Leave this for debugging purposes */
   FFI_LAST_ABI
 
@@ -406,6 +412,16 @@ struct ffi_ia64_trampoline_struct {
 #define FFI_TRAMPOLINE_SIZE 24
 #define FFI_NATIVE_RAW_API 0
 
+#elif defined(PA)
+
+#define FFI_CLOSURES 1
+#define FFI_NATIVE_RAW_API 0
+
+#define FFI_TRAMPOLINE_SIZE 32
+
+#define FFI_TYPE_SMALL_STRUCT1 -1
+#define FFI_TYPE_SMALL_STRUCT2 -2
+
 #elif defined(POWERPC)
 
 #define FFI_CLOSURES 1
diff --git a/libffi/src/ffitest.c b/libffi/src/ffitest.c
deleted file mode 100644
index ba47ba4..0000000
--- a/libffi/src/ffitest.c
+++ /dev/null
@@ -1,732 +0,0 @@
-/* -----------------------------------------------------------------------
-   ffitest.c - Copyright (c) 1996, 1997, 1998  Cygnus Solutions
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   ``Software''), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be included
-   in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
-   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
-   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-   OTHER DEALINGS IN THE SOFTWARE.
-   ----------------------------------------------------------------------- */
-
-#include <ffi.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <float.h>
-
-/* This is lame. Long double support is barely there under SunOS 4.x  */
-#if defined(SPARC) && (SIZEOF_LONG_DOUBLE != 16)
-#define BROKEN_LONG_DOUBLE
-#endif
-
-#define CHECK(x) !(x) ? fail(__FILE__, __LINE__) : 0 
-
-static int fail(char *file, int line)
-{
-  fprintf(stderr, "Test failure: %s line %d\n", file, line);
-  exit(EXIT_FAILURE);
-  /*@notreached@*/
-  return 0;
-}
-
-#define MAX_ARGS 256
-
-static size_t my_strlen(char *s)
-{
-  return (strlen(s));
-}
-
-static int promotion(signed char sc, signed short ss, 
-		     unsigned char uc, unsigned short us)
-{
-  int r = (int) sc + (int) ss + (int) uc + (int) us;
-
-  return r;
-}
-
-static signed char return_sc(signed char sc)
-{
-  return sc;
-}
-
-static unsigned char return_uc(unsigned char uc)
-{
-  return uc;
-}
-
-static long long return_ll(long long ll)
-{
-  return ll;
-}
-
-static int floating(int a, float b, double c, long double d, int e)
-{
-  int i;
-
-#if 0
-  /* This is ifdef'd out for now. long double support under SunOS/gcc
-     is pretty much non-existent.  You'll get the odd bus error in library
-     routines like printf().  */
-  printf("%d %f %f %Lf %d\n", a, (double)b, c, d, e);
-#endif
-
-  i = (int) ((float)a/b + ((float)c/(float)d));
-
-  return i;
-}
-
-static float many(float f1,
-		  float f2,
-		  float f3,
-		  float f4,
-		  float f5,
-		  float f6,
-		  float f7,
-		  float f8,
-		  float f9,
-		  float f10,
-		  float f11,
-		  float f12,
-		  float f13)
-{
-#if 0
-  printf("%f %f %f %f %f %f %f %f %f %f %f %f %f\n",
-	 (double) f1, (double) f2, (double) f3, (double) f4, (double) f5, 
-	 (double) f6, (double) f7, (double) f8, (double) f9, (double) f10,
-	 (double) f11, (double) f12, (double) f13);
-#endif
-
-  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);
-}
-
-static double dblit(float f)
-{
-  return f/3.0;
-}
-
-static long double ldblit(float f)
-{
-  return (long double) (((long double) f)/ (long double) 3.0);
-}
-
-typedef struct
-{
-  unsigned char uc;
-  double d;
-  unsigned int ui;
-} test_structure_1;
-
-typedef struct
-{
-  double d1;
-  double d2;
-} test_structure_2;
-
-typedef struct
-{
-  int si;
-} test_structure_3;
-
-typedef struct
-{
-  unsigned ui1;
-  unsigned ui2;
-  unsigned ui3;
-} test_structure_4;
-
-typedef struct
-{
-  char c1;
-  char c2;
-} test_structure_5;
-
-static test_structure_1 struct1(test_structure_1 ts)
-{
-  /*@-type@*/
-  ts.uc++;
-  /*@=type@*/
-  ts.d--;
-  ts.ui++;
-
-  return ts;
-}
-
-static test_structure_2 struct2(test_structure_2 ts)
-{
-  ts.d1--;
-  ts.d2--;
-
-  return ts;
-}
-
-static test_structure_3 struct3(test_structure_3 ts)
-{
-  ts.si = -(ts.si*2);
-
-  return ts;
-}
-
-static test_structure_4 struct4(test_structure_4 ts)
-{
-  ts.ui3 = ts.ui1 * ts.ui2 * ts.ui3;
-
-  return ts;
-}
-
-static test_structure_5 struct5(test_structure_5 ts1, test_structure_5 ts2)
-{
-  ts1.c1 += ts2.c1;
-  ts1.c2 -= ts2.c2;
-
-  return ts1;
-}
-
-/* Take an int and a float argument, together with int userdata, and 	*/
-/* return the sum.							*/
-static void closure_test_fn(ffi_cif* cif,void* resp,void** args, void* userdata)
-{
-    *(int*)resp =
-	 *(int *)args[0] + (int)(*(float *)args[1]) + (int)(long)userdata;
-}
-
-typedef int (*closure_test_type)(int, float);
-
-int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])
-{
-  ffi_cif cif;
-  ffi_type *args[MAX_ARGS];
-  void *values[MAX_ARGS];
-  char *s;
-  signed char sc;
-  unsigned char uc;
-  signed short ss;
-  unsigned short us;
-  unsigned long ul;
-  long long ll;
-  float f;
-  double d;
-  long double ld;
-  signed int si1;
-  signed int si2;
-
-  ffi_arg rint;
-  long long rlonglong;
-
-  ffi_type ts1_type;
-  ffi_type ts2_type;
-  ffi_type ts3_type;
-  ffi_type ts4_type;  
-  ffi_type ts5_type;
-  ffi_type *ts1_type_elements[4];
-  ffi_type *ts2_type_elements[3];
-  ffi_type *ts3_type_elements[2];
-  ffi_type *ts4_type_elements[4];
-  ffi_type *ts5_type_elements[3];
-
-  ts1_type.size = 0;
-  ts1_type.alignment = 0;
-  ts1_type.type = FFI_TYPE_STRUCT;
-
-  ts2_type.size = 0;
-  ts2_type.alignment = 0;
-  ts2_type.type = FFI_TYPE_STRUCT;
-
-  ts3_type.size = 0;
-  ts3_type.alignment = 0;
-  ts3_type.type = FFI_TYPE_STRUCT;
-
-  ts4_type.size = 0;
-  ts4_type.alignment = 0;
-  ts4_type.type = FFI_TYPE_STRUCT;
-
-  ts5_type.size = 0;
-  ts5_type.alignment = 0;
-  ts5_type.type = FFI_TYPE_STRUCT;
-
-  /*@-immediatetrans@*/
-  ts1_type.elements = ts1_type_elements;
-  ts2_type.elements = ts2_type_elements;
-  ts3_type.elements = ts3_type_elements;
-  ts4_type.elements = ts4_type_elements;
-  ts5_type.elements = ts5_type_elements;
-  /*@=immediatetrans@*/
-  
-  ts1_type_elements[0] = &ffi_type_uchar;
-  ts1_type_elements[1] = &ffi_type_double;
-  ts1_type_elements[2] = &ffi_type_uint;
-  ts1_type_elements[3] = NULL;
-  
-  ts2_type_elements[0] = &ffi_type_double;
-  ts2_type_elements[1] = &ffi_type_double;
-  ts2_type_elements[2] = NULL;
-
-  ts3_type_elements[0] = &ffi_type_sint;
-  ts3_type_elements[1] = NULL;
-
-  ts4_type_elements[0] = &ffi_type_uint;
-  ts4_type_elements[1] = &ffi_type_uint;
-  ts4_type_elements[2] = &ffi_type_uint;
-  ts4_type_elements[3] = NULL;
-
-  ts5_type_elements[0] = &ffi_type_schar;
-  ts5_type_elements[1] = &ffi_type_schar;
-  ts5_type_elements[2] = NULL;
-
-  ul = 0;
-
-  /* return value tests */
-  {
-#if defined(MIPS) /* || defined(ARM) */
-    puts ("long long tests not run. This is a known bug on this architecture.");
-#else
-    args[0] = &ffi_type_sint64;
-    values[0] = &ll;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_sint64, args) == FFI_OK);
-
-    for (ll = 0LL; ll < 100LL; ll++)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
-	CHECK(rlonglong == ll);
-      }
-
-    for (ll = 55555555555000LL; ll < 55555555555100LL; ll++)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
-	CHECK(rlonglong == ll);
-      }
-#endif
-
-    args[0] = &ffi_type_schar;
-    values[0] = &sc;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_schar, args) == FFI_OK);
-
-    for (sc = (signed char) -127; 
-	 sc < (signed char) 127; /*@-type@*/ sc++ /*@=type@*/)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_sc), &rint, values);
-	CHECK(rint == (int) sc);
-      }
-
-    args[0] = &ffi_type_uchar;
-    values[0] = &uc;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_uchar, args) == FFI_OK);
-
-    for (uc = (unsigned char) '\x00'; 
-	 uc < (unsigned char) '\xff'; /*@-type@*/ uc++ /*@=type@*/)
-      {
-	ul++;
-	ffi_call(&cif, FFI_FN(return_uc), &rint, values);
-	CHECK(rint == (signed int) uc);
-      }
-
-    printf("%lu return value tests run\n", ul);
-  }
-
-#ifdef BROKEN_LONG_DOUBLE
-  printf ("This architecture has broken `long double' support. No floating point\ntests have been run.\n");
-#else
-  /* float arg tests */
-  {
-    args[0] = &ffi_type_float;
-    values[0] = &f;
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_longdouble, args) == FFI_OK);
-
-    f = 3.14159;
-
-#if 0
-  /* This is ifdef'd out for now. long double support under SunOS/gcc
-     is pretty much non-existent.  You'll get the odd bus error in library
-     routines like printf().  */
-    printf ("%Lf\n", ldblit(f));
-#endif
-    ld = 666;
-    ffi_call(&cif, FFI_FN(ldblit), &ld, values);
-
-#if 0
-  /* This is ifdef'd out for now. long double support under SunOS/gcc
-     is pretty much non-existent.  You'll get the odd bus error in library
-     routines like printf().  */
-    printf ("%Lf, %Lf, %Lf, %Lf\n", ld, ldblit(f), ld - ldblit(f), LDBL_EPSILON);
-#endif
-
-    /* These are not always the same!! Check for a reasonable delta */
-    /*@-realcompare@*/
-    if (ld - ldblit(f) < LDBL_EPSILON)
-    /*@=realcompare@*/
-	puts("long double return value tests ok!");
-    else
-        CHECK(0);
-  }
-
-  /* float arg tests */
-  {
-    args[0] = &ffi_type_sint;
-    values[0] = &si1;
-    args[1] = &ffi_type_float;
-    values[1] = &f;
-    args[2] = &ffi_type_double;
-    values[2] = &d;
-    args[3] = &ffi_type_longdouble;
-    values[3] = &ld;
-    args[4] = &ffi_type_sint;
-    values[4] = &si2;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,
-		       &ffi_type_sint, args) == FFI_OK);
-
-    si1 = 6;
-    f = 3.14159;
-    d = (double)1.0/(double)3.0;
-    ld = 2.71828182846L;
-    si2 = 10;
-
-    floating (si1, f, d, ld, si2);
-
-    ffi_call(&cif, FFI_FN(floating), &rint, values);
-
-    printf ("%d vs %d\n", rint, floating (si1, f, d, ld, si2));
-
-    CHECK(rint == floating(si1, f, d, ld, si2));
-
-    printf("float arg tests ok!\n");
-  }
-#endif
-
-  /* strlen tests */
-  {
-    args[0] = &ffi_type_pointer;
-    values[0] = (void*) &s;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_sint, args) == FFI_OK);
-
-    s = "a";
-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
-    CHECK(rint == 1);
-
-    s = "1234567";
-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
-    CHECK(rint == 7);
-
-    s = "1234567890123456789012345";
-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
-    CHECK(rint == 25);
-
-    printf("strlen tests passed\n");
-  }
-
-  /* float arg tests */
-  {
-    args[0] = &ffi_type_float;
-    values[0] = &f;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ffi_type_double, args) == FFI_OK);
-
-    f = 3.14159;
-
-    ffi_call(&cif, FFI_FN(dblit), &d, values);
-
-    /* These are not always the same!! Check for a reasonable delta */
-    /*@-realcompare@*/
-    CHECK(d - dblit(f) < DBL_EPSILON);
-    /*@=realcompare@*/
-
-    printf("double return value tests ok!\n");
-  }
-
-  /* many arg tests */
-  {
-    float ff;
-    float fa[13];
-    
-    for (ul = 0; ul < 13; ul++)
-      {
-	args[ul] = &ffi_type_float;
-	values[ul] = &fa[ul];
-	fa[ul] = (float) ul;
-      }
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, 
-		       &ffi_type_float, args) == FFI_OK);
-
-    /*@-usedef@*/
-    ff =  many(fa[0], fa[1],
-	       fa[2], fa[3],
-	       fa[4], fa[5],
-	       fa[6], fa[7],
-	       fa[8], fa[9],
-	       fa[10],fa[11],fa[12]);
-    /*@=usedef@*/
-
-    ffi_call(&cif, FFI_FN(many), &f, values);
-
-    /*@-realcompare@*/
-    if (f - ff < FLT_EPSILON)
-    /*@=realcompare@*/
-	printf("many arg tests ok!\n");
-    else
-#ifdef POWERPC
-	printf("many arg tests failed!  This is a gcc bug.\n");
-#else
-        CHECK(0);
-#endif
-  }
-
-  /* promotion tests */
-  {
-    args[0] = &ffi_type_schar;
-    args[1] = &ffi_type_sshort;
-    args[2] = &ffi_type_uchar;
-    args[3] = &ffi_type_ushort;
-    values[0] = &sc;
-    values[1] = &ss;
-    values[2] = &uc;
-    values[3] = &us;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, 
-		       &ffi_type_sint, args) == FFI_OK);
-
-    us = 0;
-    ul = 0;
-
-    for (sc = (signed char) -127; 
-	 sc <= (signed char) 120; /*@-type@*/ sc += 1 /*@=type@*/)
-      for (ss = -30000; ss <= 30000; ss += 10000)
-	for (uc = (unsigned char) 0; 
-	     uc <= (unsigned char) 200; /*@-type@*/ uc += 20 /*@=type@*/)
-	  for (us = 0; us <= 60000; us += 10000)
-	    {
-	      ul++;
-	      ffi_call(&cif, FFI_FN(promotion), &rint, values);
-	      CHECK(rint == (int) sc + (int) ss + (int) uc + (int) us);
-	    }
-    printf("%lu promotion tests run\n", ul);
-  }
-
-#ifndef X86_WIN32 /* Structures dont work on Win32 */
-
-  /* struct tests */
-  {
-    test_structure_1 ts1_arg;
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_1 *ts1_result = 
-      (test_structure_1 *) malloc (sizeof(test_structure_1));
-
-    args[0] = &ts1_type;
-    values[0] = &ts1_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ts1_type, args) == FFI_OK);
-
-    ts1_arg.uc = '\x01';
-    ts1_arg.d = 3.14159;
-    ts1_arg.ui = 555;
-
-    ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
-
-    CHECK(ts1_result->ui == 556);
-    CHECK(ts1_result->d == 3.14159 - 1);
-
-    puts ("structure test 1 ok!\n");
-
-    free (ts1_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_2 ts2_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_2 *ts2_result = 
-      (test_structure_2 *) malloc (sizeof(test_structure_2));
-
-    args[0] = &ts2_type;
-    values[0] = &ts2_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ts2_type, args) == FFI_OK);
-
-    ts2_arg.d1 = 5.55;
-    ts2_arg.d2 = 6.66;
-
-    printf ("%g\n", ts2_result->d1);
-    printf ("%g\n", ts2_result->d2);
-
-    ffi_call(&cif, FFI_FN(struct2), ts2_result, values);
-
-    printf ("%g\n", ts2_result->d1);
-    printf ("%g\n", ts2_result->d2);
-    
-    CHECK(ts2_result->d1 == 5.55 - 1);
-    CHECK(ts2_result->d2 == 6.66 - 1);
-
-    printf("structure test 2 ok!\n");
-
-    free (ts2_result);
-  }
-
-  /* struct tests */
-  {
-    int compare_value;
-    test_structure_3 ts3_arg;
-    test_structure_3 *ts3_result = 
-      (test_structure_3 *) malloc (sizeof(test_structure_3));
-
-    args[0] = &ts3_type;
-    values[0] = &ts3_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ts3_type, args) == FFI_OK);
-
-    ts3_arg.si = -123;
-    compare_value = ts3_arg.si;
-
-    ffi_call(&cif, FFI_FN(struct3), ts3_result, values);
-
-    printf ("%d %d\n", ts3_result->si, -(compare_value*2));
-
-    if (ts3_result->si == -(ts3_arg.si*2))
-	puts ("structure test 3 ok!");
-    else
-      {
-	puts ("Structure test 3 found structure passing bug.");
-	puts ("  Current versions of GCC are not 100% compliant with the");
-	puts ("  n32 ABI.  There is a known problem related to passing");
-	puts ("  small structures.  Send a bug report to the gcc maintainers.");
-      }
-
-    free (ts3_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_4 ts4_arg;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_4 *ts4_result = 
-      (test_structure_4 *) malloc (sizeof(test_structure_4));
-
-    args[0] = &ts4_type;
-    values[0] = &ts4_arg;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
-		       &ts4_type, args) == FFI_OK);
-
-    ts4_arg.ui1 = 2;
-    ts4_arg.ui2 = 3;
-    ts4_arg.ui3 = 4;
-
-    ffi_call (&cif, FFI_FN(struct4), ts4_result, values);
-    
-    if (ts4_result->ui3 == 2U * 3U * 4U)
-      puts ("structure test 4 ok!");
-    else
-      puts ("Structure test 4 found GCC's structure passing bug.");
-
-    free (ts4_result);
-  }
-
-  /* struct tests */
-  {
-    test_structure_5 ts5_arg1, ts5_arg2;
-
-    /* This is a hack to get a properly aligned result buffer */
-    test_structure_5 *ts5_result = 
-      (test_structure_5 *) malloc (sizeof(test_structure_5));
-
-    args[0] = &ts5_type;
-    args[1] = &ts5_type;
-    values[0] = &ts5_arg1;
-    values[1] = &ts5_arg2;
-    
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, 
-		       &ts5_type, args) == FFI_OK);
-
-    ts5_arg1.c1 = 2;
-    ts5_arg1.c2 = 6;
-    ts5_arg2.c1 = 5;
-    ts5_arg2.c2 = 3;
-
-    ffi_call (&cif, FFI_FN(struct5), ts5_result, values);
-    
-    if (ts5_result->c1 == 7 
-	&& ts5_result->c2 == 3)
-      puts ("structure test 5 ok!");
-    else
-      puts ("Structure test 5 found GCC's structure passing bug.");
-
-    free (ts5_result);
-  }
-
-#else
-  printf("Structure passing doesn't work on Win32.\n");
-#endif /* X86_WIN32 */
-
-# if FFI_CLOSURES
-  /* A simple closure test */
-    {
-      ffi_closure cl;
-      ffi_type * cl_arg_types[3];
-
-      cl_arg_types[0] = &ffi_type_sint;
-      cl_arg_types[1] = &ffi_type_float;
-      cl_arg_types[2] = NULL;
-      
-      /* Initialize the cif */
-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, 
-	    	         &ffi_type_sint, cl_arg_types) == FFI_OK);
-
-      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn,
-			     (void *) 3 /* userdata */)
-	    == FFI_OK);
-      CHECK((*((closure_test_type)(&cl)))(1, 2.0) == 6);
-    }
-# endif
-
-  /* If we arrived here, all is good */
-  (void) puts("\nLooks good. No surprises.\n");
-
-  /*@-compdestroy@*/
-
-  return 0;
-}
-
diff --git a/libffi/src/pa/ffi.c b/libffi/src/pa/ffi.c
new file mode 100644
index 0000000..5c21fb1
--- /dev/null
+++ b/libffi/src/pa/ffi.c
@@ -0,0 +1,608 @@
+/* -----------------------------------------------------------------------
+   ffi.c - (c) 2003 Randolph Chung <tausq@debian.org>
+
+   HPPA Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+#define ROUND_UP(v, a)  (((size_t)(v) + (a) - 1) & ~((a) - 1))
+#define ROUND_DOWN(v, a)  (((size_t)(v) - (a) + 1) & ~((a) - 1))
+#define MIN_STACK_SIZE  64
+#define FIRST_ARG_SLOT  9
+#define DEBUG_LEVEL   0
+
+#define fldw(addr, fpreg) asm volatile ("fldw 0(%0), %%" #fpreg "L" : : "r"(addr) : #fpreg)
+#define fstw(fpreg, addr) asm volatile ("fstw %%" #fpreg "L, 0(%0)" : : "r"(addr))
+#define fldd(addr, fpreg) asm volatile ("fldd 0(%0), %%" #fpreg : : "r"(addr) : #fpreg)
+#define fstd(fpreg, addr) asm volatile ("fstd %%" #fpreg "L, 0(%0)" : : "r"(addr))
+
+#define debug(lvl, x...) do { if (lvl <= DEBUG_LEVEL) { printf(x); } } while (0)
+
+static inline int ffi_struct_type(ffi_type *t)
+{
+  size_t sz = t->size;
+
+  /* Small structure results are passed in registers,
+   * larger ones are passed by pointer.
+   */
+
+  if (sz <= 1)
+    return FFI_TYPE_UINT8;
+  else if (sz == 2)
+    return FFI_TYPE_UINT16;
+  else if (sz == 3)
+    return FFI_TYPE_SMALL_STRUCT1;
+  else if (sz == 4)
+    return FFI_TYPE_UINT32;
+  else if (sz <= 6)
+    return FFI_TYPE_SMALL_STRUCT2;
+  else if (sz <= 8)
+    return FFI_TYPE_UINT64;
+  else
+    return FFI_TYPE_STRUCT; /* else, we pass it by pointer.. */
+}
+
+/* PA has a downward growing stack, which looks like this:
+ *
+ * Offset
+ *      [ Variable args ]
+ * SP = (4*(n+9))       arg word N
+ * ...
+ * SP-52                arg word 4
+ *      [ Fixed args ]
+ * SP-48                arg word 3
+ * SP-44                arg word 2
+ * SP-40                arg word 1
+ * SP-36                arg word 0
+ *      [ Frame marker ]
+ * ...
+ * SP-20                RP
+ * SP-4                 previous SP
+ *
+ * First 4 non-FP 32-bit args are passed in gr26, gr25, gr24 and gr23
+ * First 2 non-FP 64-bit args are passed in register pairs, starting
+ *   on an even numbered register (i.e. r26/r25 and r24+r23)
+ * First 4 FP 32-bit arguments are passed in fr4L, fr5L, fr6L and fr7L
+ * First 2 FP 64-bit arguments are passed in fr5 and fr7
+ * The rest are passed on the stack starting at SP-52, but 64-bit
+ *   arguments need to be aligned to an 8-byte boundary
+ *
+ * This means we can have holes either in the register allocation,
+ * or in the stack.
+ */
+
+/* ffi_prep_args is called by the assembly routine once stack space
+ * has been allocated for the function's arguments
+ *
+ * The following code will put everything into the stack frame
+ * (which was allocated by the asm routine), and on return
+ * the asm routine will load the arguments that should be
+ * passed by register into the appropriate registers
+ *
+ * NOTE: We load floating point args in this function... that means we
+ * assume gcc will not mess with fp regs in here.
+ */
+
+/*@-exportheader@*/
+void ffi_prep_args_LINUX(UINT32 *stack, extended_cif *ecif, unsigned bytes)
+/*@=exportheader@*/
+{
+  register unsigned int i;
+  register ffi_type **p_arg;
+  register void **p_argv;
+  unsigned int slot = FIRST_ARG_SLOT - 1;
+  char *dest_cpy;
+
+  debug(1, "%s: stack = %p, ecif = %p, bytes = %u\n", __FUNCTION__, stack, ecif, bytes);
+
+  p_arg = ecif->cif->arg_types;
+  p_argv = ecif->avalue;
+
+  for (i = 0; i < ecif->cif->nargs; i++)
+    {
+      int type = (*p_arg)->type;
+
+      switch (type)
+	{
+	case FFI_TYPE_SINT8:
+	  slot++;
+	  *(SINT32 *)(stack - slot) = *(SINT8 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT8:
+	  slot++;
+	  *(UINT32 *)(stack - slot) = *(UINT8 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_SINT16:
+	  slot++;
+	  *(SINT32 *)(stack - slot) = *(SINT16 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT16:
+	  slot++;
+	  *(UINT32 *)(stack - slot) = *(UINT16 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_POINTER:
+	  slot++;
+	  debug(3, "Storing UINT32 %u in slot %u\n", *(UINT32 *)(*p_argv), slot);
+	  *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);
+	  break;
+
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  slot += 2;
+	  if (slot & 1)
+	    slot++;
+
+	  *(UINT32 *)(stack - slot) = (*(UINT64 *)(*p_argv)) >> 32;
+	  *(UINT32 *)(stack - slot + 1) = (*(UINT64 *)(*p_argv)) & 0xffffffffUL;
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  /* First 4 args go in fr4L - fr7L */
+	  slot++;
+	  switch (slot - FIRST_ARG_SLOT)
+	    {
+	    case 0: fldw(*p_argv, fr4); break;
+	    case 1: fldw(*p_argv, fr5); break;
+	    case 2: fldw(*p_argv, fr6); break;
+	    case 3: fldw(*p_argv, fr7); break;
+	    default:
+	      /* other ones are just passed on the stack */
+	      debug(3, "Storing UINT32(float) in slot %u\n", slot);
+	      *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);
+	      break;
+	    }
+	    break;
+
+	case FFI_TYPE_DOUBLE:
+	  slot += 2;
+	  if (slot & 1)
+	    slot++;
+	  switch (slot - FIRST_ARG_SLOT + 1)
+	    {
+	      /* First 2 args go in fr5, fr7 */
+	    case 2: fldd(*p_argv, fr5); break;
+	    case 4: fldd(*p_argv, fr7); break;
+	    default:
+	      debug(3, "Storing UINT64(double) at slot %u\n", slot);
+	      *(UINT64 *)(stack - slot) = *(UINT64 *)(*p_argv);
+	      break;
+	    }
+	  break;
+
+	case FFI_TYPE_STRUCT:
+
+	  /* Structs smaller or equal than 4 bytes are passed in one
+	     register. Structs smaller or equal 8 bytes are passed in two
+	     registers. Larger structures are passed by pointer.  */
+
+	  if((*p_arg)->size <= 4) {
+	    slot++;
+	    dest_cpy = (char *)(stack - slot);
+	    dest_cpy += 4 - (*p_arg)->size;
+	    memcpy((char *)dest_cpy, (char *)*p_argv, (*p_arg)->size);
+	  } else if ((*p_arg)->size <= 8) {
+	    slot += 2;
+	    if (slot & 1)
+	      slot++;
+	    dest_cpy = (char *)(stack - slot);
+	    dest_cpy += 8 - (*p_arg)->size;
+	    memcpy((char *)dest_cpy, (char *)*p_argv, (*p_arg)->size);
+	  } else {
+	    slot++;
+	    *(UINT32 *)(stack - slot) = (UINT32)(*p_argv);
+	  }
+	  break;
+
+	default:
+	  FFI_ASSERT(0);
+	}
+
+      p_arg++;
+      p_argv++;
+    }
+
+  /* Make sure we didn't mess up and scribble on the stack */
+#if 1
+  {
+    int n;
+
+    debug(5, "Stack setup:\n");
+    for (n = 0; n < (bytes + 3) / 4; n++)
+      {
+	if ((n%4) == 0) { debug(5, "\n%08x: ", (unsigned int)(stack - n)); }
+	debug(5, "%08x ", *(stack - n));
+      }
+    debug(5, "\n");
+  }
+#endif
+
+  FFI_ASSERT(slot * 4 <= bytes);
+
+  return;
+}
+
+static void ffi_size_stack_LINUX(ffi_cif *cif)
+{
+  ffi_type **ptr;
+  int i;
+  int z = 0; /* # stack slots */
+
+  for (ptr = cif->arg_types, i = 0; i < cif->nargs; ptr++, i++)
+    {
+      int type = (*ptr)->type;
+
+      switch (type)
+	{
+	case FFI_TYPE_DOUBLE:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  z += 2 + (z & 1); /* must start on even regs, so we may waste one */
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  z += 1; /* pass by ptr, callee will copy */
+	  break;
+
+	default: /* <= 32-bit values */
+	  z++;
+	}
+    }
+
+  /* We can fit up to 6 args in the default 64-byte stack frame,
+   * if we need more, we need more stack
+   */
+  if (z <= 6)
+    cif->bytes = MIN_STACK_SIZE; /* min stack size */
+  else
+    cif->bytes = 64 + ROUND_UP((z - 6) * sizeof(UINT32), MIN_STACK_SIZE);
+
+  debug(3, "Calculated stack size is %u bytes\n", cif->bytes);
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+  /* Set the return type flag */
+  switch (cif->rtype->type)
+    {
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+      cif->flags = (unsigned) cif->rtype->type;
+      break;
+
+    case FFI_TYPE_STRUCT:
+      /* For the return type we have to check the size of the structures.
+	 If the size is smaller or equal 4 bytes, the result is given back
+	 in one register. If the size is smaller or equal 8 bytes than we
+	 return the result in two registers. But if the size is bigger than
+	 8 bytes, we work with pointers.  */
+      cif->flags = ffi_struct_type(cif->rtype);
+      break;
+
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      cif->flags = FFI_TYPE_UINT64;
+      break;
+
+    default:
+      cif->flags = FFI_TYPE_INT;
+      break;
+    }
+
+  /* Lucky us, because of the weird PA ABI we get to do our
+   * own stack sizing....
+   */
+  switch (cif->abi)
+    {
+    case FFI_LINUX:
+      ffi_size_stack_LINUX(cif);
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+
+  return FFI_OK;
+}
+
+/*@-declundef@*/
+/*@-exportheader@*/
+extern void ffi_call_LINUX(void (*)(UINT32 *, extended_cif *, unsigned),
+			   /*@out@*/ extended_cif *,
+			   unsigned, unsigned,
+			   /*@out@*/ unsigned *,
+			   void (*fn)());
+/*@=declundef@*/
+/*@=exportheader@*/
+
+void ffi_call(/*@dependent@*/ ffi_cif *cif,
+	      void (*fn)(),
+	      /*@out@*/ void *rvalue,
+	      /*@dependent@*/ void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+
+  /* If the return value is a struct and we don't have a return */
+  /* value address then we need to make one                     */
+
+  if ((rvalue == NULL) &&
+      (cif->rtype->type == FFI_TYPE_STRUCT))
+    {
+      /*@-sysunrecog@*/
+      ecif.rvalue = alloca(cif->rtype->size);
+      /*@=sysunrecog@*/
+    }
+  else
+    ecif.rvalue = rvalue;
+
+
+  switch (cif->abi)
+    {
+    case FFI_LINUX:
+      /*@-usedef@*/
+      debug(2, "Calling ffi_call_LINUX: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\n", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);
+      ffi_call_LINUX(ffi_prep_args_LINUX, &ecif, cif->bytes,
+		     cif->flags, ecif.rvalue, fn);
+      /*@=usedef@*/
+      break;
+
+    default:
+      FFI_ASSERT(0);
+      break;
+    }
+}
+
+#if FFI_CLOSURES
+/*
+ * This is more-or-less an inverse of ffi_call -- we have arguments on
+ * the stack, and we need to fill them into a cif structure and invoke
+ * the user function. This really ought to be in asm to make sure
+ * the compiler doesn't do things we don't expect...
+ */
+UINT32 ffi_closure_inner_LINUX(ffi_closure *closure, UINT32 *stack)
+{
+  ffi_cif *cif;
+  void **avalue;
+  void *rvalue;
+  UINT32 ret[2]; /* function can return up to 64-bits in registers */
+  ffi_type **p_arg;
+  char *tmp;
+  int i, avn, slot = FIRST_ARG_SLOT - 1;
+  register UINT32 r28 asm("r28");
+
+  cif = closure->cif;
+
+  /* if returning via structure, callee will write to our pointer */
+  if (cif->flags == FFI_TYPE_STRUCT)
+    rvalue = (void *)r28;
+  else
+    rvalue = &ret[0];
+
+  avalue = (void **)alloca(cif->nargs * sizeof(void *));
+  avn = cif->nargs;
+  p_arg = cif->arg_types;
+
+  for (i = 0; i < avn; i++)
+    {
+      int type = (*p_arg)->type;
+
+      switch (type)
+	{
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_POINTER:
+	  slot++;
+	  avalue[i] = (char *)(stack - slot) + sizeof(UINT32) - (*p_arg)->size;
+	  break;
+
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_UINT64:
+	  slot += 2;
+	  if (slot & 1)
+	    slot++;
+	  avalue[i] = (void *)(stack - slot);
+	  break;
+
+	case FFI_TYPE_FLOAT:
+	  slot++;
+	  switch (slot - FIRST_ARG_SLOT)
+	    {
+	    case 0: fstw(fr4, (void *)(stack - slot)); break;
+	    case 1: fstw(fr5, (void *)(stack - slot)); break;
+	    case 2: fstw(fr6, (void *)(stack - slot)); break;
+	    case 3: fstw(fr7, (void *)(stack - slot)); break;
+	    }
+	  avalue[i] = (void *)(stack - slot);
+	  break;
+
+	case FFI_TYPE_DOUBLE:
+	  slot += 2;
+	  if (slot & 1)
+	    slot++;
+	  switch (slot - FIRST_ARG_SLOT + 1)
+	    {
+	    case 2: fstd(fr5, (void *)(stack - slot)); break;
+	    case 4: fstd(fr7, (void *)(stack - slot)); break;
+	    }
+	  avalue[i] = (void *)(stack - slot);
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  /* Structs smaller or equal than 4 bytes are passed in one
+	     register. Structs smaller or equal 8 bytes are passed in two
+	     registers. Larger structures are passed by pointer.  */
+	  if((*p_arg)->size <= 4) {
+	    slot++;
+	    avalue[i] = (void *)(stack - slot) + sizeof(UINT32) -
+	      (*p_arg)->size;
+	  } else if ((*p_arg)->size <= 8) {
+	    slot += 2;
+	    if (slot & 1)
+	      slot++;
+	    avalue[i] = (void *)(stack - slot) + sizeof(UINT64) -
+	      (*p_arg)->size;
+	  } else {
+	    slot++;
+	    avalue[i] = (void *) *(stack - slot);
+	  }
+	  break;
+
+	default:
+	  FFI_ASSERT(0);
+	}
+
+      p_arg++;
+    }
+
+  /* Invoke the closure.  */
+  (closure->fun) (cif, rvalue, avalue, closure->user_data);
+
+  debug(3, "after calling function, ret[0] = %d, ret[1] = %d\n", ret[0], ret[1]);
+
+  /* Store the result */
+  switch (cif->flags)
+    {
+    case FFI_TYPE_UINT8:
+      *(stack - FIRST_ARG_SLOT) = *(UINT8 *)&ret[0];
+      break;
+    case FFI_TYPE_SINT8:
+      *(stack - FIRST_ARG_SLOT) = *(SINT8 *)&ret[0];
+      break;
+    case FFI_TYPE_UINT16:
+      *(stack - FIRST_ARG_SLOT) = *(UINT16 *)&ret[0];
+      break;
+    case FFI_TYPE_SINT16:
+      *(stack - FIRST_ARG_SLOT) = *(SINT16 *)&ret[0];
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_UINT32:
+      *(stack - FIRST_ARG_SLOT) = *(UINT32 *)&ret[0];
+      break;
+    case FFI_TYPE_SINT32:
+      *(stack - FIRST_ARG_SLOT) = *(SINT32 *)&ret[0];
+      break;
+    case FFI_TYPE_SINT64:
+    case FFI_TYPE_UINT64:
+      *(stack - FIRST_ARG_SLOT) = *(UINT32 *)&ret[0];
+      *(stack - FIRST_ARG_SLOT - 1) = *(UINT32 *)&ret[1];
+      break;
+
+    case FFI_TYPE_DOUBLE:
+      fldd(rvalue, fr4);
+      break;
+
+    case FFI_TYPE_FLOAT:
+      fldw(rvalue, fr4);
+      break;
+
+    case FFI_TYPE_STRUCT:
+      /* Don't need a return value, done by caller.  */
+      break;
+
+    case FFI_TYPE_SMALL_STRUCT1:
+      tmp = (void*)(stack -  FIRST_ARG_SLOT);
+      tmp += 4 - cif->rtype->size;
+      memcpy((void*)tmp, &ret[0], cif->rtype->size);
+      break;
+
+    case FFI_TYPE_SMALL_STRUCT2:
+      *(stack - FIRST_ARG_SLOT) = ret[0];
+      *(stack - FIRST_ARG_SLOT - 1) = ret[1];
+      break;
+
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_VOID:
+      break;
+
+    default:
+      debug(0, "assert with cif->flags: %d\n",cif->flags);
+      FFI_ASSERT(0);
+      break;
+    }
+  return FFI_OK;
+}
+
+/* Fill in a closure to refer to the specified fun and user_data.  */
+/* cif specifies the argument and result types for fun.  */
+/* the cif must already be prep'ed */
+
+void ffi_closure_LINUX(void);
+
+ffi_status
+ffi_prep_closure (ffi_closure* closure,
+		  ffi_cif* cif,
+		  void (*fun)(ffi_cif*,void*,void**,void*),
+		  void *user_data)
+{
+  UINT32 *tramp = (UINT32 *)(closure->tramp);
+
+  FFI_ASSERT (cif->abi == FFI_LINUX);
+
+  /* Make a small trampoline that will branch to our
+   * handler function. Use PC-relative addressing.
+   */
+  tramp[0] = 0xeaa00000; /* b,l .+8, %r21     ; %r21 <- pc+8             */
+  tramp[1] = 0xd6a01c1e; /* depi 0,31,2,%r21  ; mask priv bits           */
+  tramp[2] = 0x4aa10028; /* ldw  20(%r21),%r1 ; load plabel              */
+  tramp[3] = 0x36b53ff1; /* ldo -8(%r21),%r21 ; get closure addr         */
+  tramp[4] = 0x0c201096; /* ldw  0(%r1),%r22  ; address of handler       */
+  tramp[5] = 0xeac0c000; /* bv	 %r0(%r22)    ; branch to handler        */
+  tramp[6] = 0x0c281093; /* ldw  4(%r1),%r19  ; GP of handler            */
+  tramp[7] = ((UINT32)(ffi_closure_LINUX) & ~2);
+
+  /* Flush d/icache -- have to flush up 2 two lines because of
+   * alignment
+   */
+  asm volatile (
+		"fdc 0(%0)\n"
+		"fdc %1(%0)\n"
+		"fic 0(%%sr4, %0)\n"
+		"fic %1(%%sr4, %0)\n"
+		: : "r"((unsigned long)tramp & ~31), "r"(32 /* stride */));
+
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+
+  return FFI_OK;
+}
+#endif
+
diff --git a/libffi/src/pa/linux.S b/libffi/src/pa/linux.S
new file mode 100644
index 0000000..b1974a8
--- /dev/null
+++ b/libffi/src/pa/linux.S
@@ -0,0 +1,310 @@
+/* -----------------------------------------------------------------------
+   linux.S - (c) 2003 Randolph Chung <tausq@debian.org>
+
+   HPPA Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+#define FFI_TYPE_SMALL_STRUCT1 -1
+#define FFI_TYPE_SMALL_STRUCT2 -2
+
+	.text
+	.align 4
+
+	/* void ffi_call_LINUX(void (*)(char *, extended_cif *),
+			       extended_cif *ecif,
+			       unsigned bytes,
+			       unsigned flags,
+			       unsigned *rvalue,
+			       void (*fn)());
+	 */
+
+	.export ffi_call_LINUX,code
+	.import ffi_prep_args_LINUX,code
+
+	.type ffi_call_LINUX, @function
+.LFB1:
+ffi_call_LINUX:
+	.proc
+	.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4
+	.entry
+	stw %rp, -20(%sp)
+	copy %r3, %r1
+.LCFI11:
+
+	copy %sp, %r3
+.LCFI12:
+
+	/* Setup the stack for calling prep_args...
+	   We want the stack to look like this:
+
+	   [ Previous stack                            ] <- %r3
+
+	   [ 64-bytes register save area               ] <- %r4
+
+	   [ Stack space for actual call, passed as    ] <- %arg0
+	   [     arg0 to ffi_prep_args_LINUX           ]
+
+	   [ Stack for calling prep_args               ] <- %sp
+	 */
+
+	stwm %r1, 64(%sp)
+	stw %r4, 12(%r3)
+.LCFI13:
+	copy %sp, %r4
+
+	addl %arg2, %r4, %arg0                  /* arg stack */
+	stw %arg3, -48(%r3)                     /* save flags; we need it later */
+
+	/* Call prep_args:
+	   %arg0(stack) -- set up above
+	   %arg1(ecif) -- same as incoming param
+	   %arg2(bytes) -- same as incoming param */
+	bl ffi_prep_args_LINUX,%r2
+	ldo 64(%arg0), %sp
+	ldo -64(%sp), %sp
+
+	/* now %sp should point where %arg0 was pointing */
+
+	/* Load the arguments that should be passed in registers */
+	/* The fp args were loaded by the prep_args function */
+	ldw -36(%sp), %arg0
+	ldw -40(%sp), %arg1
+	ldw -44(%sp), %arg2
+	ldw -48(%sp), %arg3
+
+	/* in case the function is going to return a structure
+	 * we need to give it a place to put the result...
+	 */
+	ldw -52(%r3), %ret0                     /* %ret0 <- rvalue */
+	ldw -56(%r3), %r22                      /* %r22 <- function to call */
+	bl $$dyncall, %r31                      /* Call the user function */
+	copy %r31, %rp
+
+	/* Prepare to store the result; we need to recover flags and rvalue */
+	ldw -48(%r3), %r21                      /* r21 <- flags */
+	ldw -52(%r3), %r20                      /* r20 <- rvalue */
+
+	/* Store the result according to the return type... */
+
+checksmst1:
+	comib,<>,n FFI_TYPE_SMALL_STRUCT1, %r21, checksmst2
+	/* There is maybe a better way to handle 3 byte structs.  */
+	SH2ADD %ret0,0,%ret0
+	SH2ADD %ret0,0,%ret0
+	SH2ADD %ret0,0,%ret0
+	SH2ADD %ret0,0,%ret0
+	b done
+	stw %ret0, 0(%r20)
+
+checksmst2:
+	comib,<>,n FFI_TYPE_SMALL_STRUCT2, %r21, checkint8
+	/* Up to now I don't have a way to handle 6/7 byte structs.
+	   The values are left bounded in the registers. In the struct
+	   itself they are left bounded.  */
+	stw %ret0, 0(%r20)
+	b done
+	stw %ret1, 4(%r20)
+
+checkint8:
+	comib,<>,n FFI_TYPE_UINT8, %r21, checkint16
+	b done
+	stb %ret0, 0(%r20)
+
+checkint16:
+	comib,<>,n FFI_TYPE_UINT16, %r21, checkint32
+	b done
+	sth %ret0, 0(%r20)
+
+checkint32:
+	comib,<>,n FFI_TYPE_UINT32, %r21, checkint
+	b done
+	stw %ret0, 0(%r20)
+
+checkint:
+	comib,<>,n FFI_TYPE_INT, %r21, checkll
+	b done
+	stw %ret0, 0(%r20)
+
+checkll:
+	comib,<>,n FFI_TYPE_UINT64, %r21, checkdbl
+	stw %ret0, 0(%r20)
+	b done
+	stw %ret1, 4(%r20)
+
+checkdbl:
+	comib,<>,n FFI_TYPE_DOUBLE, %r21, checkfloat
+	b done
+	fstd %fr4,0(%r20)
+
+checkfloat:
+	comib,<>,n FFI_TYPE_FLOAT, %r21, done
+	fstw %fr4L,0(%r20)
+
+	/* structure returns are either handled by one of the
+	 * INT/UINT64 cases above, or, if passed by pointer,
+	 * is handled by the callee
+	 */
+
+done:
+	/* all done, return */
+	copy %r4, %sp                           /* pop arg stack */
+	ldw 12(%r3), %r4
+	ldwm -64(%sp), %r3                      /* .. and pop stack */
+	ldw -20(%sp), %rp
+	bv %r0(%rp)
+	nop
+	.exit
+	.procend
+.LFE1:
+
+	/* void ffi_closure_LINUX(void);
+	 * Called with closure argument in %r21
+	 */
+	.export ffi_closure_LINUX,code
+	.import ffi_closure_inner_LINUX,code
+
+	.type ffi_closure_LINUX, @function
+.LFB2:
+ffi_closure_LINUX:
+	.proc
+	.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3
+	.entry
+
+	stw %rp, -20(%sp)
+.LCFI20:
+	copy %r3, %r1
+.LCFI21:
+	copy %sp, %r3
+.LCFI22:
+	stwm %r1, 64(%sp)
+
+	/* Put arguments onto the stack and call ffi_closure_inner */
+	stw %arg0, -36(%r3)
+	stw %arg1, -40(%r3)
+	stw %arg2, -44(%r3)
+	stw %arg3, -48(%r3)
+
+	copy %r21, %arg0
+	bl ffi_closure_inner_LINUX, %r2
+	copy %r3, %arg1
+
+	ldwm -64(%sp), %r3
+	ldw -20(%sp), %rp
+	ldw -36(%sp), %ret0
+	bv %r0(%r2)
+	ldw -40(%sp), %ret1
+
+	.exit
+	.procend
+.LFE2:
+
+	.section        ".eh_frame","aw",@progbits
+.Lframe1:
+	.word   .LECIE1-.LSCIE1 ;# Length of Common Information Entry
+.LSCIE1:
+	.word   0x0     ;# CIE Identifier Tag
+	.byte   0x1     ;# CIE Version
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.ascii "zR\0"   ;# CIE Augmentation
+#else
+	.ascii "\0"     ;# CIE Augmentation
+#endif
+	.uleb128 0x1    ;# CIE Code Alignment Factor
+	.sleb128 4      ;# CIE Data Alignment Factor
+	.byte   0x2     ;# CIE RA Column
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.uleb128  0x1   ;# Augmentation size
+	.byte	0x1b    ;# FDE Encoding (pcrel sdata4)
+#endif
+	.byte   0xc     ;# DW_CFA_def_cfa
+	.uleb128 0x1e
+	.uleb128 0x0
+	.align 4
+.LECIE1:
+.LSFDE1:
+	.word   .LEFDE1-.LASFDE1        ;# FDE Length
+.LASFDE1:
+	.word   .LASFDE1-.Lframe1       ;# FDE CIE offset
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.word   .LFB1-. ;# FDE initial location
+#else
+	.word   .LFB1   ;# FDE initial location
+#endif
+	.word   .LFE1-.LFB1     ;# FDE address range
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.uleb128 0x0    ;# Augmentation size
+#endif
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI11-.LFB1
+	.byte	0x83	;# DW_CFA_offset, column 0x3
+	.uleb128 0x0
+	.byte   0x11    ;# DW_CFA_offset_extended_sf; save r2 at [r30-20]
+	.uleb128 0x2
+	.sleb128 -5
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI12-.LCFI11
+	.byte   0xd     ;# DW_CFA_def_cfa_register = r3
+	.uleb128 0x3
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI13-.LCFI12
+	.byte	0x84	;# DW_CFA_offset, column 0x4
+	.uleb128 0x3
+
+	.align 4
+.LEFDE1:
+
+.LSFDE2:
+	.word   .LEFDE2-.LASFDE2        ;# FDE Length
+.LASFDE2:
+	.word   .LASFDE2-.Lframe1       ;# FDE CIE offset
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.word   .LFB2-. ;# FDE initial location
+#else
+	.word   .LFB2   ;# FDE initial location
+#endif
+	.word   .LFE2-.LFB2     ;# FDE address range
+#if 0 // defined _RELOCATABLE || defined __PIC__
+	.uleb128 0x0    ;# Augmentation size
+#endif
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI21-.LFB2
+	.byte   0x83    ;# DW_CFA_offset, column 0x3
+	.uleb128 0x0
+	.byte   0x11    ;# DW_CFA_offset_extended_sf
+	.uleb128 0x2
+	.sleb128 -5
+
+	.byte   0x4     ;# DW_CFA_advance_loc4
+	.word   .LCFI12-.LCFI11
+	.byte   0xd     ;# DW_CFA_def_cfa_register = r3
+	.uleb128 0x3
+
+	.align 4
+.LEFDE2:
+
diff --git a/libffi/src/prep_cif.c b/libffi/src/prep_cif.c
index d53981a..8feb66d 100644
--- a/libffi/src/prep_cif.c
+++ b/libffi/src/prep_cif.c
@@ -103,7 +103,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,
   /* Perform a sanity check on the return type */
   FFI_ASSERT(ffi_type_test(cif->rtype));
 
-#ifndef M68K
+#if !defined M68K && !defined __x86_64__ && !defined S390 && !defined PA
   /* Make space for the return structure pointer */
   if (cif->rtype->type == FFI_TYPE_STRUCT
 #ifdef SPARC
@@ -122,6 +122,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,
       if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))
 	return FFI_BAD_TYPEDEF;
 
+#if !defined __x86_64__ && !defined S390 && !defined PA
 #ifdef SPARC
       if (((*ptr)->type == FFI_TYPE_STRUCT
 	   && ((*ptr)->size > 16 || cif->abi != FFI_V9))
@@ -137,6 +138,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,
 	  
 	  bytes += STACK_ARG_SIZE((*ptr)->size);
 	}
+#endif
     }
 
   cif->bytes = bytes;
