diff --git a/config/gxx-include-dir.m4 b/config/gxx-include-dir.m4
index 4f54d427f..74bb09ffe 100644
--- a/config/gxx-include-dir.m4
+++ b/config/gxx-include-dir.m4
@@ -8,15 +8,26 @@ dnl If you change the default here, you'll need to change the gcc and
 dnl libstdc++-v3 subdirectories too.
 AC_DEFUN([TL_AC_GXX_INCLUDE_DIR],
 [
+case "$host" in
+  *-msdosdjgpp*)
+    libstdcxx_incdir_base=cxx
+    gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+    ;;
+  *)
+    libstdcxx_incdir_base=c++
+    gcc_version_dir='$(gcc_version)'
+    ;;
+esac
+
 case "${with_gxx_include_dir}" in
   yes)
     AC_MSG_ERROR([--with-gxx-include-dir=[[dir]] requires a directory])
     ;;
   no | "")
     case "${enable_version_specific_runtime_libs}" in
-      yes) gxx_include_dir='$(libsubdir)/include/c++' ;;
+      yes) gxx_include_dir='$(libsubdir)/include/'${libstdcxx_incdir_base} ;;
       *)
-	libstdcxx_incdir='c++/$(gcc_version)'
+	libstdcxx_incdir=${libstdcxx_incdir_base}/${gcc_version_dir}
 	gxx_include_dir='include/$(libstdcxx_incdir)'
 	if test -n "$with_cross_host" && 
            test x"$with_cross_host" != x"no"; then	
diff --git a/configure b/configure
index 80cf60626..ed4abe084 100755
--- a/configure
+++ b/configure
@@ -6292,7 +6292,7 @@ if test $target_elf = yes; then :
 else
   if test x"$default_enable_lto" = x"yes" ; then
     case $target in
-      *-apple-darwin9* | *-cygwin* | *-mingw*) ;;
+      *-apple-darwin9* | *-cygwin* | *-mingw* | *djgpp*) ;;
       # On other non-ELF platforms, LTO has yet to be validated.
       *) enable_lto=no ;;
     esac
@@ -6303,7 +6303,7 @@ else
   # warn during gcc/ subconfigure; unless you're bootstrapping with
   # -flto it won't be needed until after installation anyway.
     case $target in
-      *-cygwin* | *-mingw* | *-apple-darwin*) ;;
+      *-cygwin* | *-mingw* | *-apple-darwin* | *djgpp*) ;;
       *) if test x"$enable_lto" = x"yes"; then
 	as_fn_error "LTO support is not enabled for this target." "$LINENO" 5
         fi
diff --git a/configure.ac b/configure.ac
index 90221a706..15f2b101f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1688,7 +1688,7 @@ ACX_ELF_TARGET_IFELSE([# ELF platforms build the lto-plugin always.
   build_lto_plugin=yes
 ],[if test x"$default_enable_lto" = x"yes" ; then
     case $target in
-      *-apple-darwin9* | *-cygwin* | *-mingw*) ;;
+      *-apple-darwin9* | *-cygwin* | *-mingw* | *djgpp*) ;;
       # On other non-ELF platforms, LTO has yet to be validated.
       *) enable_lto=no ;;
     esac
@@ -1699,7 +1699,7 @@ ACX_ELF_TARGET_IFELSE([# ELF platforms build the lto-plugin always.
   # warn during gcc/ subconfigure; unless you're bootstrapping with
   # -flto it won't be needed until after installation anyway.
     case $target in
-      *-cygwin* | *-mingw* | *-apple-darwin*) ;;
+      *-cygwin* | *-mingw* | *-apple-darwin* | *djgpp*) ;;
       *) if test x"$enable_lto" = x"yes"; then
 	AC_MSG_ERROR([LTO support is not enabled for this target.])
         fi
diff --git a/fixincludes/Makefile.in b/fixincludes/Makefile.in
index ce850ffc7..9949fa9f4 100644
--- a/fixincludes/Makefile.in
+++ b/fixincludes/Makefile.in
@@ -41,6 +41,8 @@ VPATH = $(srcdir)
 libdir = @libdir@
 # Directory in which GCC puts its executables.
 libexecdir = @libexecdir@
+# GCC version for subdirectory names (editted if host requires it)
+gcc_version_dir = @gcc_version_dir@
 
 # End of variables for you to override.
 
@@ -52,9 +54,9 @@ target_noncanonical:=@target_noncanonical@
 gcc_version := $(shell cat $(srcdir)/../gcc/BASE-VER)
 
 # Directory in which the compiler finds libraries etc.
-libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)
+libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version_dir)
 # Directory in which the compiler finds executables
-libexecsubdir = $(libexecdir)/gcc/$(target_noncanonical)/$(gcc_version)
+libexecsubdir = $(libexecdir)/gcc/$(target_noncanonical)/$(gcc_version_dir)
 # Where our executable files go
 itoolsdir = $(libexecsubdir)/install-tools
 # Where our data files go
diff --git a/fixincludes/configure b/fixincludes/configure
index 4836cd886..c990ea3af 100755
--- a/fixincludes/configure
+++ b/fixincludes/configure
@@ -590,6 +590,7 @@ ac_includes_default="\
 
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+gcc_version_dir
 MAINT
 TARGET
 target_noncanonical
@@ -5354,6 +5355,19 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+case $host in
+	i?86-*-msdosdjgpp*)
+		gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+		;;
+
+	* )
+		gcc_version_dir='$(gcc_version)'
+		;;
+esac
+
+
 ac_config_headers="$ac_config_headers config.h"
 
 ac_config_files="$ac_config_files Makefile mkheaders.almost:mkheaders.in"
diff --git a/fixincludes/configure.ac b/fixincludes/configure.ac
index f8f352fb7..95eeb9f42 100644
--- a/fixincludes/configure.ac
+++ b/fixincludes/configure.ac
@@ -114,6 +114,19 @@ AC_SUBST(MAINT)
 AC_DEFINE_UNQUOTED([SED_PROGRAM], "${SED}",
    [Defined to the best working sed program on the host system])
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+[case $host in
+	i?86-*-msdosdjgpp*)
+		gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+		;;
+
+	* )
+		gcc_version_dir='$(gcc_version)'
+		;;
+esac]
+AC_SUBST(gcc_version_dir)
+
 AC_CONFIG_HEADERS(config.h, [echo timestamp > stamp-h])
 AC_CONFIG_FILES(Makefile mkheaders.almost:mkheaders.in)
 AC_OUTPUT
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 2a4475b75..48b810111 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -638,6 +638,7 @@ man7ext = .7
 objext = .o
 exeext = @host_exeext@
 build_exeext = @build_exeext@
+libstdcxx_incdir_base=@libstdcxx_incdir_base@
 
 # Directory in which to put man pages.
 mandir = @mandir@
@@ -4187,7 +4188,7 @@ s-fixinc_list : $(GCC_PASSES)
 # Abort if no system headers available, unless building a crosscompiler.
 # FIXME: abort unless building --without-headers would be more accurate and less ugly
 stmp-fixinc: gsyslimits.h macro_list fixinc_list \
-  $(build_objdir)/fixincludes/fixincl \
+  $(build_objdir)/fixincludes/fixincl$(EXEEXT) \
   $(build_objdir)/fixincludes/fixinc.sh
 	rm -rf include-fixed; mkdir include-fixed
 	-chmod a+rx include-fixed
diff --git a/gcc/ada/adaint.c b/gcc/ada/adaint.c
index dc94d63d5..b7ec98083 100644
--- a/gcc/ada/adaint.c
+++ b/gcc/ada/adaint.c
@@ -107,7 +107,18 @@
 extern "C" {
 #endif
 
-#if defined (__MINGW32__)
+#if defined (__DJGPP__)
+
+/* For isalpha-like tests in the compiler, we're expected to resort to
+   safe-ctype.h/ISALPHA.  This isn't available for the runtime library
+   build, so we fallback on ctype.h/isalpha there.  */
+
+#ifdef IN_RTS
+#include <ctype.h>
+#define ISALPHA isalpha
+#endif
+
+#elif defined (__MINGW32__)
 
 #if defined (RTX)
 #include <windows.h>
@@ -218,7 +229,7 @@ extern int LIB$GETSYI (int *, unsigned int *);
 #include <utime.h>
 #endif
 
-#if defined (_WIN32)
+#if defined(MSDOS) || defined (_WIN32)
 #include <process.h>
 #endif
 
@@ -501,7 +512,10 @@ __gnat_readlink (char *path ATTRIBUTE_UNUSED,
 		 char *buf ATTRIBUTE_UNUSED,
 		 size_t bufsiz ATTRIBUTE_UNUSED)
 {
-#if defined (_WIN32) || defined (VMS) \
+#if defined (__DJGPP__) && (__DJGPP__>2 || (__DJGPP__==2 && __DJGPP_MINOR__>=4))
+  /* Symbolic links are supported for DJGPP beginning with version 2.04pre */
+  return readlink (path, buf, bufsiz);
+#elif defined(MSDOS) || defined (_WIN32) || defined (VMS)     \
     || defined(__vxworks) || defined (__nucleus__)
   return -1;
 #else
@@ -517,7 +531,10 @@ int
 __gnat_symlink (char *oldpath ATTRIBUTE_UNUSED,
 		char *newpath ATTRIBUTE_UNUSED)
 {
-#if defined (_WIN32) || defined (VMS) \
+#if defined (__DJGPP__) && (__DJGPP__>2 || (__DJGPP__==2 && __DJGPP_MINOR__>=4))
+  /* Symbolic links are supported for DJGPP beginning with version 2.04pre */
+  return symlink (oldpath, newpath);
+#elif defined(MSDOS) || defined (_WIN32) || defined (VMS)   \
     || defined(__vxworks) || defined (__nucleus__)
   return -1;
 #else
@@ -600,7 +617,13 @@ __gnat_try_lock (char *dir, char *file)
 int
 __gnat_get_maximum_file_name_length (void)
 {
-#if defined (VMS)
+#if defined (MSDOS)
+#ifdef __DJGPP__
+  return (_use_lfn(".")) ? -1 : 8;
+#else
+  return 8;
+#endif
+#elif defined (VMS)
   if (getenv ("GNAT$EXTENDED_FILE_SPECIFICATIONS"))
     return -1;
   else
@@ -626,7 +649,7 @@ __gnat_get_file_names_case_sensitive (void)
           && sensitive[1] == '\0')
         file_names_case_sensitive_cache = sensitive[0] - '0';
       else
-#if defined (VMS) || defined (WINNT) || defined (__APPLE__)
+#if defined (VMS) || defined(MSDOS) || defined (WINNT) || defined (__APPLE__)
         file_names_case_sensitive_cache = 0;
 #else
         file_names_case_sensitive_cache = 1;
@@ -640,7 +663,7 @@ __gnat_get_file_names_case_sensitive (void)
 int
 __gnat_get_env_vars_case_sensitive (void)
 {
-#if defined (VMS) || defined (WINNT)
+#if defined (VMS) || defined (MSDOS) || defined (WINNT)
  return 0;
 #else
  return 1;
@@ -650,7 +673,11 @@ __gnat_get_env_vars_case_sensitive (void)
 char
 __gnat_get_default_identifier_character_set (void)
 {
+#if defined (MSDOS)
+  return 'p';
+#else
   return '1';
+#endif
 }
 
 /* Return the current working directory.  */
@@ -1859,7 +1886,7 @@ __gnat_is_absolute_path (char *name, int length)
 #else
   return (length != 0) &&
      (*name == '/' || *name == DIR_SEPARATOR
-#if defined (WINNT)
+#if defined(MSDOS) || defined (WINNT)
       || (length > 1 && ISALPHA (name[0]) && name[1] == ':')
 #endif
 	  );
@@ -2338,6 +2365,8 @@ __gnat_is_symbolic_link_attr (char* name ATTRIBUTE_UNUSED,
 #if defined (__vxworks) || defined (__nucleus__)
       attr->symbolic_link = 0;
 
+#elif defined (__DJGPP__) && (__DJGPP__ < 2 || (__DJGPP__==2) && (__DJGPP_MINOR__<4))
+      return 0;
 #elif defined (_AIX) || defined (__APPLE__) || defined (__unix__)
       int ret;
       GNAT_STRUCT_STAT statbuf;
@@ -2376,7 +2405,7 @@ __gnat_portable_spawn (char *args[])
 #if defined (__vxworks) || defined(__nucleus__) || defined(RTX)
   return -1;
 
-#elif defined (_WIN32)
+#elif defined (MSDOS) || defined (_WIN32)
   /* args[0] must be quotes as it could contain a full pathname with spaces */
   char *args_0 = args[0];
   args[0] = (char *)xmalloc (strlen (args_0) + 3);
@@ -2494,6 +2523,7 @@ __gnat_number_of_cpus (void)
 
   cores = vxCpuConfiguredGet ();
 
+#elif defined (MSDOS)
 #endif
 
   return cores;
@@ -2705,6 +2735,20 @@ __gnat_portable_no_block_spawn (char *args[])
 #if defined (__vxworks) || defined (__nucleus__) || defined (RTX)
   return -1;
 
+#elif defined(MSDOS)
+  /* ??? For PC machines I (Franco) don't know the system calls to implement
+     this routine. So I'll fake it as follows. This routine will behave
+     exactly like the blocking portable_spawn and will systematically return
+     a pid of 0 unless the spawned task did not complete successfully, in
+     which case we return a pid of -1.  To synchronize with this the
+     portable_wait below systematically returns a pid of 0 and reports that
+     the subprocess terminated successfully. */
+
+  if (spawnvp (P_WAIT, args[0], args) != 0)
+    return -1;
+  else
+    return 0;
+
 #elif defined (_WIN32)
 
   HANDLE h = NULL;
@@ -2752,6 +2796,9 @@ __gnat_portable_wait (int *process_status)
 
   pid = win32_wait (&status);
 
+#elif defined (MSDOS)
+  /* ??? See corresponding comment in portable_no_block_spawn.  */
+
 #else
 
   pid = waitpid (-1, &status, 0);
diff --git a/gcc/ada/ctrl_c.c b/gcc/ada/ctrl_c.c
index a860b767c..af7a68677 100644
--- a/gcc/ada/ctrl_c.c
+++ b/gcc/ada/ctrl_c.c
@@ -75,7 +75,7 @@ __gnat_install_int_handler (void (*proc) (void))
   if (sigint_intercepted == 0)
     {
       act.sa_handler = __gnat_int_handler;
-#if defined (__Lynx__)
+#if defined (__Lynx__) || defined(__DJGPP__)
       /* LynxOS does not support SA_RESTART. */
       act.sa_flags = 0;
 #else
diff --git a/gcc/ada/env.c b/gcc/ada/env.c
index 800d20748..de95fa7b9 100644
--- a/gcc/ada/env.c
+++ b/gcc/ada/env.c
@@ -277,6 +277,8 @@ void __gnat_unsetenv (char *name) {
   sprintf (expression, "%s=", name);
   putenv (expression);
   free (expression);
+#elif defined (__DJGPP__) && __DJGPP__==2 && __DJGPP_MINOR__<4
+  putenv(name);
 #else
   unsetenv (name);
 #endif
@@ -301,7 +303,8 @@ void __gnat_clearenv (void) {
   }
 #elif defined (__MINGW32__) || defined (__FreeBSD__) || defined (__APPLE__) \
    || (defined (__vxworks) && defined (__RTP__)) || defined (__CYGWIN__) \
-   || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__rtems__)
+   || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__rtems__) \
+   || defined (__DJGPP__)
   /* On Windows, FreeBSD and MacOS there is no function to clean all the
      environment but there is a "clean" way to unset a variable. So go
      through the environ table and call __gnat_unsetenv on all entries */
diff --git a/gcc/ada/gcc-interface/Makefile.in b/gcc/ada/gcc-interface/Makefile.in
index ee610f789..3d34207f1 100644
--- a/gcc/ada/gcc-interface/Makefile.in
+++ b/gcc/ada/gcc-interface/Makefile.in
@@ -1598,6 +1598,14 @@ ifeq ($(strip $(filter-out avr none powerpc% eabispe leon% erc32% unknown elf,$(
   indepsw.adb<indepsw-gnu.adb
 endif
 
+ifeq ($(strip $(filter-out %djgpp,$(osys))),)
+  GNATRTL_SOCKETS_OBJS =
+  LIBGNAT_TARGET_PAIRS += $(DUMMY_SOCKETS_TARGET_PAIRS) s-taprop.adb<s-taprop-dummy.adb
+
+  LIBGNAT_TARGET_PAIRS += system.ads<system-djgpp.ads
+  LIBGNAT_TARGET_PAIRS += s-os_lib.adb<s-os_lib-djgpp.adb
+endif
+
 # Cygwin/Mingw32
 ifeq ($(strip $(filter-out cygwin% mingw32% pe,$(osys))),)
   # Cygwin provides a full Posix environment, and so we use the default
diff --git a/gcc/ada/gsocket.h b/gcc/ada/gsocket.h
index 1d9235f4a..1f25096a8 100644
--- a/gcc/ada/gsocket.h
+++ b/gcc/ada/gsocket.h
@@ -29,7 +29,7 @@
  *                                                                          *
  ****************************************************************************/
 
-#if defined(__nucleus__) || defined(VTHREADS) || defined(__ANDROID__)
+#if defined(__nucleus__) || defined(VTHREADS) || defined(__DJGPP__) || defined(__ANDROID__)
 
 #warning Sockets not supported on these platforms
 #undef HAVE_SOCKETS
diff --git a/gcc/ada/init.c b/gcc/ada/init.c
index f5c3a8144..e18e8df39 100644
--- a/gcc/ada/init.c
+++ b/gcc/ada/init.c
@@ -2226,6 +2226,37 @@ __gnat_install_handler (void)
   __gnat_handler_installed = 1;
 }
 
+#elif defined (__DJGPP__)
+
+/***************************************/
+/* FIXME: this is only a draft version */
+/***************************************/
+
+struct timestruc_t
+{
+   time_t  tv_sec;
+   long    tv_nsec;
+};
+
+
+int
+nanosleep (struct timestruc_t *Rqtp, struct timestruc_t *Rmtp);
+
+int
+nanosleep (struct timestruc_t *Rqtp, struct timestruc_t *Rmtp)
+{
+    usleep (1000000*Rqtp->tv_sec+Rqtp->tv_nsec/1000);
+    if (Rmtp) { Rmtp->tv_sec = Rmtp->tv_nsec=0; }
+    return 0;
+}
+
+
+void
+__gnat_install_handler ()
+{
+  __gnat_handler_installed = 1;
+}
+
 #else
 
 /* For all other versions of GNAT, the handler does nothing.  */
diff --git a/gcc/ada/s-os_lib-djgpp.adb b/gcc/ada/s-os_lib-djgpp.adb
new file mode 100644
index 000000000..0269b5e61
--- /dev/null
+++ b/gcc/ada/s-os_lib-djgpp.adb
@@ -0,0 +1,2738 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                        S Y S T E M . O S _ L I B                         --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 1995-2012, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+pragma Compiler_Unit;
+
+with Ada.Unchecked_Conversion;
+with Ada.Unchecked_Deallocation;
+with System; use System;
+with System.Case_Util;
+with System.CRTL;
+with System.Soft_Links;
+
+package body System.OS_Lib is
+
+   --  Imported procedures Dup and Dup2 are used in procedures Spawn and
+   --  Non_Blocking_Spawn.
+
+   function Dup (Fd : File_Descriptor) return File_Descriptor;
+   pragma Import (C, Dup, "__gnat_dup");
+
+   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);
+   pragma Import (C, Dup2, "__gnat_dup2");
+
+   On_Windows : constant Boolean := Directory_Separator = '\';
+   --  An indication that we are on Windows. Used in Normalize_Pathname, to
+   --  deal with drive letters in the beginning of absolute paths.
+
+   package SSL renames System.Soft_Links;
+
+   --  The following are used by Create_Temp_File
+
+   First_Temp_File_Name : constant String := "GA000000.TMP";
+   --  Used to initialize Current_Temp_File_Name and Temp_File_Name_Last_Digit
+
+   Current_Temp_File_Name : String := First_Temp_File_Name;
+   --  Name of the temp file last created
+
+   Temp_File_Name_Last_Digit : constant Positive :=
+                                 First_Temp_File_Name'Last - 4;
+   --  Position of the last digit in Current_Temp_File_Name
+
+   Max_Attempts : constant := 100;
+   --  The maximum number of attempts to create a new temp file
+
+   -----------------------
+   -- Local Subprograms --
+   -----------------------
+
+   function Args_Length (Args : Argument_List) return Natural;
+   --  Returns total number of characters needed to create a string of all Args
+   --  terminated by ASCII.NUL characters.
+
+   procedure Create_Temp_File_Internal
+     (FD     : out File_Descriptor;
+      Name   : out String_Access;
+      Stdout : Boolean);
+   --  Internal routine to implement two Create_Temp_File routines. If Stdout
+   --  is set to True the created descriptor is stdout-compatible, otherwise
+   --  it might not be depending on the OS (VMS is one example). The first two
+   --  parameters are as in Create_Temp_File.
+
+   function C_String_Length (S : Address) return Integer;
+   --  Returns the length of a C string. Does check for null address
+   --  (returns 0).
+
+   procedure Spawn_Internal
+     (Program_Name : String;
+      Args         : Argument_List;
+      Result       : out Integer;
+      Pid          : out Process_Id;
+      Blocking     : Boolean);
+   --  Internal routine to implement the two Spawn (blocking/non blocking)
+   --  routines. If Blocking is set to True then the spawn is blocking
+   --  otherwise it is non blocking. In this latter case the Pid contains the
+   --  process id number. The first three parameters are as in Spawn. Note that
+   --  Spawn_Internal normalizes the argument list before calling the low level
+   --  system spawn routines (see Normalize_Arguments).
+   --
+   --  Note: Normalize_Arguments is designed to do nothing if it is called more
+   --  than once, so calling Normalize_Arguments before calling one of the
+   --  spawn routines is fine.
+
+   function To_Path_String_Access
+     (Path_Addr : Address;
+      Path_Len  : Integer) return String_Access;
+   --  Converts a C String to an Ada String. We could do this making use of
+   --  Interfaces.C.Strings but we prefer not to import that entire package
+
+   ---------
+   -- "<" --
+   ---------
+
+   function "<"  (X, Y : OS_Time) return Boolean is
+   begin
+      return Long_Integer (X) < Long_Integer (Y);
+   end "<";
+
+   ----------
+   -- "<=" --
+   ----------
+
+   function "<="  (X, Y : OS_Time) return Boolean is
+   begin
+      return Long_Integer (X) <= Long_Integer (Y);
+   end "<=";
+
+   ---------
+   -- ">" --
+   ---------
+
+   function ">"  (X, Y : OS_Time) return Boolean is
+   begin
+      return Long_Integer (X) > Long_Integer (Y);
+   end ">";
+
+   ----------
+   -- ">=" --
+   ----------
+
+   function ">="  (X, Y : OS_Time) return Boolean is
+   begin
+      return Long_Integer (X) >= Long_Integer (Y);
+   end ">=";
+
+   -----------------
+   -- Args_Length --
+   -----------------
+
+   function Args_Length (Args : Argument_List) return Natural is
+      Len : Natural := 0;
+
+   begin
+      for J in Args'Range loop
+         Len := Len + Args (J)'Length + 1; --  One extra for ASCII.NUL
+      end loop;
+
+      return Len;
+   end Args_Length;
+
+   -----------------------------
+   -- Argument_String_To_List --
+   -----------------------------
+
+   function Argument_String_To_List
+     (Arg_String : String) return Argument_List_Access
+   is
+      Max_Args : constant Integer := Arg_String'Length;
+      New_Argv : Argument_List (1 .. Max_Args);
+      New_Argc : Natural := 0;
+      Idx      : Integer;
+
+   begin
+      Idx := Arg_String'First;
+
+      loop
+         exit when Idx > Arg_String'Last;
+
+         declare
+            Quoted  : Boolean := False;
+            Backqd  : Boolean := False;
+            Old_Idx : Integer;
+
+         begin
+            Old_Idx := Idx;
+
+            loop
+               --  An unquoted space is the end of an argument
+
+               if not (Backqd or Quoted)
+                 and then Arg_String (Idx) = ' '
+               then
+                  exit;
+
+               --  Start of a quoted string
+
+               elsif not (Backqd or Quoted)
+                 and then Arg_String (Idx) = '"'
+               then
+                  Quoted := True;
+
+               --  End of a quoted string and end of an argument
+
+               elsif (Quoted and not Backqd)
+                 and then Arg_String (Idx) = '"'
+               then
+                  Idx := Idx + 1;
+                  exit;
+
+               --  Following character is backquoted
+
+               elsif Arg_String (Idx) = '\' then
+                  Backqd := True;
+
+               --  Turn off backquoting after advancing one character
+
+               elsif Backqd then
+                  Backqd := False;
+
+               end if;
+
+               Idx := Idx + 1;
+               exit when Idx > Arg_String'Last;
+            end loop;
+
+            --  Found an argument
+
+            New_Argc := New_Argc + 1;
+            New_Argv (New_Argc) :=
+              new String'(Arg_String (Old_Idx .. Idx - 1));
+
+            --  Skip extraneous spaces
+
+            while Idx <= Arg_String'Last and then Arg_String (Idx) = ' ' loop
+               Idx := Idx + 1;
+            end loop;
+         end;
+      end loop;
+
+      return new Argument_List'(New_Argv (1 .. New_Argc));
+   end Argument_String_To_List;
+
+   ---------------------
+   -- C_String_Length --
+   ---------------------
+
+   function C_String_Length (S : Address) return Integer is
+      function Strlen (S : Address) return Integer;
+      pragma Import (C, Strlen, "strlen");
+   begin
+      if S = Null_Address then
+         return 0;
+      else
+         return Strlen (S);
+      end if;
+   end C_String_Length;
+
+   -----------
+   -- Close --
+   -----------
+
+   procedure Close (FD : File_Descriptor) is
+      procedure C_Close (FD : File_Descriptor);
+      pragma Import (C, C_Close, "close");
+   begin
+      C_Close (FD);
+   end Close;
+
+   procedure Close (FD : File_Descriptor; Status : out Boolean) is
+      function C_Close (FD : File_Descriptor) return Integer;
+      pragma Import (C, C_Close, "close");
+   begin
+      Status := (C_Close (FD) = 0);
+   end Close;
+
+   ---------------
+   -- Copy_File --
+   ---------------
+
+   procedure Copy_File
+     (Name     : String;
+      Pathname : String;
+      Success  : out Boolean;
+      Mode     : Copy_Mode := Copy;
+      Preserve : Attribute := Time_Stamps)
+   is
+      From : File_Descriptor;
+      To   : File_Descriptor;
+
+      Copy_Error : exception;
+      --  Internal exception raised to signal error in copy
+
+      function Build_Path (Dir : String; File : String) return String;
+      --  Returns pathname Dir concatenated with File adding the directory
+      --  separator only if needed.
+
+      procedure Copy (From, To : File_Descriptor);
+      --  Read data from From and place them into To. In both cases the
+      --  operations uses the current file position. Raises Constraint_Error
+      --  if a problem occurs during the copy.
+
+      procedure Copy_To (To_Name : String);
+      --  Does a straight copy from source to designated destination file
+
+      ----------------
+      -- Build_Path --
+      ----------------
+
+      function Build_Path (Dir : String; File : String) return String is
+         Res : String (1 .. Dir'Length + File'Length + 1);
+
+         Base_File_Ptr : Integer;
+         --  The base file name is File (Base_File_Ptr + 1 .. File'Last)
+
+         function Is_Dirsep (C : Character) return Boolean;
+         pragma Inline (Is_Dirsep);
+         --  Returns True if C is a directory separator. On Windows we
+         --  handle both styles of directory separator.
+
+         ---------------
+         -- Is_Dirsep --
+         ---------------
+
+         function Is_Dirsep (C : Character) return Boolean is
+         begin
+            return C = Directory_Separator or else C = '/';
+         end Is_Dirsep;
+
+      --  Start of processing for Build_Path
+
+      begin
+         --  Find base file name
+
+         Base_File_Ptr := File'Last;
+         while Base_File_Ptr >= File'First loop
+            exit when Is_Dirsep (File (Base_File_Ptr));
+            Base_File_Ptr := Base_File_Ptr - 1;
+         end loop;
+
+         declare
+            Base_File : String renames
+                          File (Base_File_Ptr + 1 .. File'Last);
+
+         begin
+            Res (1 .. Dir'Length) := Dir;
+
+            if Is_Dirsep (Dir (Dir'Last)) then
+               Res (Dir'Length + 1 .. Dir'Length + Base_File'Length) :=
+                 Base_File;
+               return Res (1 .. Dir'Length + Base_File'Length);
+
+            else
+               Res (Dir'Length + 1) := Directory_Separator;
+               Res (Dir'Length + 2 .. Dir'Length + 1 + Base_File'Length) :=
+                 Base_File;
+               return Res (1 .. Dir'Length + 1 + Base_File'Length);
+            end if;
+         end;
+      end Build_Path;
+
+      ----------
+      -- Copy --
+      ----------
+
+      procedure Copy (From, To : File_Descriptor) is
+         Buf_Size : constant := 200_000;
+         type Buf is array (1 .. Buf_Size) of Character;
+         type Buf_Ptr is access Buf;
+
+         Buffer : Buf_Ptr;
+         R      : Integer;
+         W      : Integer;
+
+         Status_From : Boolean;
+         Status_To   : Boolean;
+         --  Statuses for the calls to Close
+
+         procedure Free is new Ada.Unchecked_Deallocation (Buf, Buf_Ptr);
+
+      begin
+         --  Check for invalid descriptors, making sure that we do not
+         --  accidentally leave an open file descriptor around.
+
+         if From = Invalid_FD then
+            if To /= Invalid_FD then
+               Close (To, Status_To);
+            end if;
+
+            raise Copy_Error;
+
+         elsif To = Invalid_FD then
+            Close (From, Status_From);
+            raise Copy_Error;
+         end if;
+
+         --  Allocate the buffer on the heap
+
+         Buffer := new Buf;
+
+         loop
+            R := Read (From, Buffer (1)'Address, Buf_Size);
+
+            --  For VMS, the buffer may not be full. So, we need to try again
+            --  until there is nothing to read.
+
+            exit when R = 0;
+
+            W := Write (To, Buffer (1)'Address, R);
+
+            if W < R then
+
+               --  Problem writing data, could be a disk full. Close files
+               --  without worrying about status, since we are raising a
+               --  Copy_Error exception in any case.
+
+               Close (From, Status_From);
+               Close (To, Status_To);
+
+               Free (Buffer);
+
+               raise Copy_Error;
+            end if;
+         end loop;
+
+         Close (From, Status_From);
+         Close (To, Status_To);
+
+         Free (Buffer);
+
+         if not (Status_From and Status_To) then
+            raise Copy_Error;
+         end if;
+      end Copy;
+
+      -------------
+      -- Copy_To --
+      -------------
+
+      procedure Copy_To (To_Name : String) is
+
+         function Copy_Attributes
+           (From, To : System.Address;
+            Mode     : Integer) return Integer;
+         pragma Import (C, Copy_Attributes, "__gnat_copy_attribs");
+         --  Mode = 0 - copy only time stamps.
+         --  Mode = 1 - copy time stamps and read/write/execute attributes
+
+         C_From : String (1 .. Name'Length + 1);
+         C_To   : String (1 .. To_Name'Length + 1);
+
+      begin
+         From := Open_Read (Name, Binary);
+
+         --  Do not clobber destination file if source file could not be opened
+
+         if From /= Invalid_FD then
+            To := Create_File (To_Name, Binary);
+         end if;
+
+         Copy (From, To);
+
+         --  Copy attributes
+
+         C_From (1 .. Name'Length) := Name;
+         C_From (C_From'Last) := ASCII.NUL;
+
+         C_To (1 .. To_Name'Length) := To_Name;
+         C_To (C_To'Last) := ASCII.NUL;
+
+         case Preserve is
+
+            when Time_Stamps =>
+               if Copy_Attributes (C_From'Address, C_To'Address, 0) = -1 then
+                  raise Copy_Error;
+               end if;
+
+            when Full =>
+               if Copy_Attributes (C_From'Address, C_To'Address, 1) = -1 then
+                  raise Copy_Error;
+               end if;
+
+            when None =>
+               null;
+         end case;
+
+      end Copy_To;
+
+   --  Start of processing for Copy_File
+
+   begin
+      Success := True;
+
+      --  The source file must exist
+
+      if not Is_Regular_File (Name) then
+         raise Copy_Error;
+      end if;
+
+      --  The source file exists
+
+      case Mode is
+
+         --  Copy case, target file must not exist
+
+         when Copy =>
+
+            --  If the target file exists, we have an error
+
+            if Is_Regular_File (Pathname) then
+               raise Copy_Error;
+
+            --  Case of target is a directory
+
+            elsif Is_Directory (Pathname) then
+               declare
+                  Dest : constant String := Build_Path (Pathname, Name);
+
+               begin
+                  --  If target file exists, we have an error, else do copy
+
+                  if Is_Regular_File (Dest) then
+                     raise Copy_Error;
+                  else
+                     Copy_To (Dest);
+                  end if;
+               end;
+
+            --  Case of normal copy to file (destination does not exist)
+
+            else
+               Copy_To (Pathname);
+            end if;
+
+         --  Overwrite case (destination file may or may not exist)
+
+         when Overwrite =>
+            if Is_Directory (Pathname) then
+               Copy_To (Build_Path (Pathname, Name));
+            else
+               Copy_To (Pathname);
+            end if;
+
+         --  Append case (destination file may or may not exist)
+
+         when Append =>
+
+            --  Appending to existing file
+
+            if Is_Regular_File (Pathname) then
+
+               --  Append mode and destination file exists, append data at the
+               --  end of Pathname. But if we fail to open source file, do not
+               --  touch destination file at all.
+
+               From := Open_Read (Name, Binary);
+               if From /= Invalid_FD then
+                  To := Open_Read_Write (Pathname, Binary);
+               end if;
+
+               Lseek (To, 0, Seek_End);
+
+               Copy (From, To);
+
+            --  Appending to directory, not allowed
+
+            elsif Is_Directory (Pathname) then
+               raise Copy_Error;
+
+            --  Appending when target file does not exist
+
+            else
+               Copy_To (Pathname);
+            end if;
+      end case;
+
+   --  All error cases are caught here
+
+   exception
+      when Copy_Error =>
+         Success := False;
+   end Copy_File;
+
+   procedure Copy_File
+     (Name     : C_File_Name;
+      Pathname : C_File_Name;
+      Success  : out Boolean;
+      Mode     : Copy_Mode := Copy;
+      Preserve : Attribute := Time_Stamps)
+   is
+      Ada_Name     : String_Access :=
+                       To_Path_String_Access
+                         (Name, C_String_Length (Name));
+      Ada_Pathname : String_Access :=
+                       To_Path_String_Access
+                         (Pathname, C_String_Length (Pathname));
+   begin
+      Copy_File (Ada_Name.all, Ada_Pathname.all, Success, Mode, Preserve);
+      Free (Ada_Name);
+      Free (Ada_Pathname);
+   end Copy_File;
+
+   ----------------------
+   -- Copy_Time_Stamps --
+   ----------------------
+
+   procedure Copy_Time_Stamps (Source, Dest : String; Success : out Boolean) is
+
+      function Copy_Attributes
+        (From, To : System.Address;
+         Mode     : Integer) return Integer;
+      pragma Import (C, Copy_Attributes, "__gnat_copy_attribs");
+      --  Mode = 0 - copy only time stamps.
+      --  Mode = 1 - copy time stamps and read/write/execute attributes
+
+   begin
+      if Is_Regular_File (Source) and then Is_Writable_File (Dest) then
+         declare
+            C_Source : String (1 .. Source'Length + 1);
+            C_Dest   : String (1 .. Dest'Length + 1);
+
+         begin
+            C_Source (1 .. Source'Length) := Source;
+            C_Source (C_Source'Last)      := ASCII.NUL;
+
+            C_Dest (1 .. Dest'Length) := Dest;
+            C_Dest (C_Dest'Last)      := ASCII.NUL;
+
+            if Copy_Attributes (C_Source'Address, C_Dest'Address, 0) = -1 then
+               Success := False;
+            else
+               Success := True;
+            end if;
+         end;
+
+      else
+         Success := False;
+      end if;
+   end Copy_Time_Stamps;
+
+   procedure Copy_Time_Stamps
+     (Source, Dest : C_File_Name;
+      Success      : out Boolean)
+   is
+      Ada_Source : String_Access :=
+                     To_Path_String_Access
+                       (Source, C_String_Length (Source));
+      Ada_Dest   : String_Access :=
+                     To_Path_String_Access
+                       (Dest, C_String_Length (Dest));
+   begin
+      Copy_Time_Stamps (Ada_Source.all, Ada_Dest.all, Success);
+      Free (Ada_Source);
+      Free (Ada_Dest);
+   end Copy_Time_Stamps;
+
+   -----------------
+   -- Create_File --
+   -----------------
+
+   function Create_File
+     (Name  : C_File_Name;
+      Fmode : Mode) return File_Descriptor
+   is
+      function C_Create_File
+        (Name  : C_File_Name;
+         Fmode : Mode) return File_Descriptor;
+      pragma Import (C, C_Create_File, "__gnat_open_create");
+
+   begin
+      return C_Create_File (Name, Fmode);
+   end Create_File;
+
+   function Create_File
+     (Name  : String;
+      Fmode : Mode) return File_Descriptor
+   is
+      C_Name : String (1 .. Name'Length + 1);
+
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+      return Create_File (C_Name (C_Name'First)'Address, Fmode);
+   end Create_File;
+
+   ---------------------
+   -- Create_New_File --
+   ---------------------
+
+   function Create_New_File
+     (Name  : C_File_Name;
+      Fmode : Mode) return File_Descriptor
+   is
+      function C_Create_New_File
+        (Name  : C_File_Name;
+         Fmode : Mode) return File_Descriptor;
+      pragma Import (C, C_Create_New_File, "__gnat_open_new");
+
+   begin
+      return C_Create_New_File (Name, Fmode);
+   end Create_New_File;
+
+   function Create_New_File
+     (Name  : String;
+      Fmode : Mode) return File_Descriptor
+   is
+      C_Name : String (1 .. Name'Length + 1);
+
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+      return Create_New_File (C_Name (C_Name'First)'Address, Fmode);
+   end Create_New_File;
+
+   -----------------------------
+   -- Create_Output_Text_File --
+   -----------------------------
+
+   function Create_Output_Text_File (Name : String) return File_Descriptor is
+      function C_Create_File
+        (Name : C_File_Name) return File_Descriptor;
+      pragma Import (C, C_Create_File, "__gnat_create_output_file");
+
+      C_Name : String (1 .. Name'Length + 1);
+
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+      return C_Create_File (C_Name (C_Name'First)'Address);
+   end Create_Output_Text_File;
+
+   ----------------------
+   -- Create_Temp_File --
+   ----------------------
+
+   procedure Create_Temp_File
+     (FD   : out File_Descriptor;
+      Name : out Temp_File_Name)
+   is
+      function Open_New_Temp
+        (Name  : System.Address;
+         Fmode : Mode) return File_Descriptor;
+      pragma Import (C, Open_New_Temp, "__gnat_open_new_temp");
+
+   begin
+      FD := Open_New_Temp (Name'Address, Binary);
+   end Create_Temp_File;
+
+   procedure Create_Temp_File
+     (FD   : out File_Descriptor;
+      Name : out String_Access)
+   is
+   begin
+      Create_Temp_File_Internal (FD, Name, Stdout => False);
+   end Create_Temp_File;
+
+   procedure Create_Temp_Output_File
+     (FD   : out File_Descriptor;
+      Name : out String_Access)
+   is
+   begin
+      Create_Temp_File_Internal (FD, Name, Stdout => True);
+   end Create_Temp_Output_File;
+
+   -------------------------------
+   -- Create_Temp_File_Internal --
+   -------------------------------
+
+   procedure Create_Temp_File_Internal
+     (FD        : out File_Descriptor;
+      Name      : out String_Access;
+      Stdout    : Boolean)
+   is
+      Pos      : Positive;
+      Attempts : Natural := 0;
+      Current  : String (Current_Temp_File_Name'Range);
+
+      ---------------------------------
+      -- Create_New_Output_Text_File --
+      ---------------------------------
+
+      function Create_New_Output_Text_File
+        (Name : String) return File_Descriptor;
+      --  Similar to Create_Output_Text_File, except it fails if the file
+      --  already exists. We need this behavior to ensure we don't accidentally
+      --  open a temp file that has just been created by a concurrently running
+      --  process. There is no point exposing this function, as it's generally
+      --  not particularly useful.
+
+      function Create_New_Output_Text_File
+        (Name : String) return File_Descriptor is
+         function C_Create_File
+           (Name : C_File_Name) return File_Descriptor;
+         pragma Import (C, C_Create_File, "__gnat_create_output_file_new");
+
+         C_Name : String (1 .. Name'Length + 1);
+
+      begin
+         C_Name (1 .. Name'Length) := Name;
+         C_Name (C_Name'Last)      := ASCII.NUL;
+         return C_Create_File (C_Name (C_Name'First)'Address);
+      end Create_New_Output_Text_File;
+
+   begin
+      --  Loop until a new temp file can be created
+
+      File_Loop : loop
+         Locked : begin
+            --  We need to protect global variable Current_Temp_File_Name
+            --  against concurrent access by different tasks.
+
+            SSL.Lock_Task.all;
+
+            --  Start at the last digit
+
+            Pos := Temp_File_Name_Last_Digit;
+
+            Digit_Loop :
+            loop
+               --  Increment the digit by one
+
+               case Current_Temp_File_Name (Pos) is
+                  when '0' .. '8' =>
+                     Current_Temp_File_Name (Pos) :=
+                       Character'Succ (Current_Temp_File_Name (Pos));
+                     exit Digit_Loop;
+
+                  when '9' =>
+
+                     --  For 9, set the digit to 0 and go to the previous digit
+
+                     Current_Temp_File_Name (Pos) := '0';
+                     Pos := Pos - 1;
+
+                  when others =>
+
+                     --  If it is not a digit, then there are no available
+                     --  temp file names. Return Invalid_FD. There is almost
+                     --  no chance that this code will be ever be executed,
+                     --  since it would mean that there are one million temp
+                     --  files in the same directory!
+
+                     SSL.Unlock_Task.all;
+                     FD := Invalid_FD;
+                     Name := null;
+                     exit File_Loop;
+               end case;
+            end loop Digit_Loop;
+
+            Current := Current_Temp_File_Name;
+
+            --  We can now release the lock, because we are no longer
+            --  accessing Current_Temp_File_Name.
+
+            SSL.Unlock_Task.all;
+
+         exception
+            when others =>
+               SSL.Unlock_Task.all;
+               raise;
+         end Locked;
+
+         --  Attempt to create the file
+
+         if Stdout then
+            FD := Create_New_Output_Text_File (Current);
+         else
+            FD := Create_New_File (Current, Binary);
+         end if;
+
+         if FD /= Invalid_FD then
+            Name := new String'(Current);
+            exit File_Loop;
+         end if;
+
+         if not Is_Regular_File (Current) then
+
+            --  If the file does not already exist and we are unable to create
+            --  it, we give up after Max_Attempts. Otherwise, we try again with
+            --  the next available file name.
+
+            Attempts := Attempts + 1;
+
+            if Attempts >= Max_Attempts then
+               FD := Invalid_FD;
+               Name := null;
+               exit File_Loop;
+            end if;
+         end if;
+      end loop File_Loop;
+   end Create_Temp_File_Internal;
+
+   -----------------
+   -- Delete_File --
+   -----------------
+
+   procedure Delete_File (Name : Address; Success : out Boolean) is
+      R : Integer;
+   begin
+      R := System.CRTL.unlink (Name);
+      Success := (R = 0);
+   end Delete_File;
+
+   procedure Delete_File (Name : String; Success : out Boolean) is
+      C_Name : String (1 .. Name'Length + 1);
+
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+
+      Delete_File (C_Name'Address, Success);
+   end Delete_File;
+
+   ---------------------
+   -- File_Time_Stamp --
+   ---------------------
+
+   function File_Time_Stamp (FD : File_Descriptor) return OS_Time is
+      function File_Time (FD : File_Descriptor) return OS_Time;
+      pragma Import (C, File_Time, "__gnat_file_time_fd");
+   begin
+      return File_Time (FD);
+   end File_Time_Stamp;
+
+   function File_Time_Stamp (Name : C_File_Name) return OS_Time is
+      function File_Time (Name : Address) return OS_Time;
+      pragma Import (C, File_Time, "__gnat_file_time_name");
+   begin
+      return File_Time (Name);
+   end File_Time_Stamp;
+
+   function File_Time_Stamp (Name : String) return OS_Time is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return File_Time_Stamp (F_Name'Address);
+   end File_Time_Stamp;
+
+   ---------------------------
+   -- Get_Debuggable_Suffix --
+   ---------------------------
+
+   function Get_Debuggable_Suffix return String_Access is
+      procedure Get_Suffix_Ptr (Length, Ptr : Address);
+      pragma Import (C, Get_Suffix_Ptr, "__gnat_get_debuggable_suffix_ptr");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      Suffix_Ptr    : Address;
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Debuggable_Suffix;
+
+   ---------------------------
+   -- Get_Executable_Suffix --
+   ---------------------------
+
+   function Get_Executable_Suffix return String_Access is
+      procedure Get_Suffix_Ptr (Length, Ptr : Address);
+      pragma Import (C, Get_Suffix_Ptr, "__gnat_get_executable_suffix_ptr");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      Suffix_Ptr    : Address;
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Executable_Suffix;
+
+   -----------------------
+   -- Get_Object_Suffix --
+   -----------------------
+
+   function Get_Object_Suffix return String_Access is
+      procedure Get_Suffix_Ptr (Length, Ptr : Address);
+      pragma Import (C, Get_Suffix_Ptr, "__gnat_get_object_suffix_ptr");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      Suffix_Ptr    : Address;
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Object_Suffix;
+
+   ----------------------------------
+   -- Get_Target_Debuggable_Suffix --
+   ----------------------------------
+
+   function Get_Target_Debuggable_Suffix return String_Access is
+      Target_Exec_Ext_Ptr : Address;
+      pragma Import
+        (C, Target_Exec_Ext_Ptr, "__gnat_target_debuggable_extension");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      function Strlen (Cstring : Address) return Integer;
+      pragma Import (C, Strlen, "strlen");
+
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Target_Exec_Ext_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Target_Debuggable_Suffix;
+
+   ----------------------------------
+   -- Get_Target_Executable_Suffix --
+   ----------------------------------
+
+   function Get_Target_Executable_Suffix return String_Access is
+      Target_Exec_Ext_Ptr : Address;
+      pragma Import
+        (C, Target_Exec_Ext_Ptr, "__gnat_target_executable_extension");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      function Strlen (Cstring : Address) return Integer;
+      pragma Import (C, Strlen, "strlen");
+
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Target_Exec_Ext_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Target_Executable_Suffix;
+
+   ------------------------------
+   -- Get_Target_Object_Suffix --
+   ------------------------------
+
+   function Get_Target_Object_Suffix return String_Access is
+      Target_Object_Ext_Ptr : Address;
+      pragma Import
+        (C, Target_Object_Ext_Ptr, "__gnat_target_object_extension");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      function Strlen (Cstring : Address) return Integer;
+      pragma Import (C, Strlen, "strlen");
+
+      Suffix_Length : Integer;
+      Result        : String_Access;
+
+   begin
+      Suffix_Length := Strlen (Target_Object_Ext_Ptr);
+
+      Result := new String (1 .. Suffix_Length);
+
+      if Suffix_Length > 0 then
+         Strncpy (Result.all'Address, Target_Object_Ext_Ptr, Suffix_Length);
+      end if;
+
+      return Result;
+   end Get_Target_Object_Suffix;
+
+   ------------
+   -- Getenv --
+   ------------
+
+   function Getenv (Name : String) return String_Access is
+      procedure Get_Env_Value_Ptr (Name, Length, Ptr : Address);
+      pragma Import (C, Get_Env_Value_Ptr, "__gnat_getenv");
+
+      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);
+      pragma Import (C, Strncpy, "strncpy");
+
+      Env_Value_Ptr    : aliased Address;
+      Env_Value_Length : aliased Integer;
+      F_Name           : aliased String (1 .. Name'Length + 1);
+      Result           : String_Access;
+
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+
+      Get_Env_Value_Ptr
+        (F_Name'Address, Env_Value_Length'Address, Env_Value_Ptr'Address);
+
+      Result := new String (1 .. Env_Value_Length);
+
+      if Env_Value_Length > 0 then
+         Strncpy (Result.all'Address, Env_Value_Ptr, Env_Value_Length);
+      end if;
+
+      return Result;
+   end Getenv;
+
+   ------------
+   -- GM_Day --
+   ------------
+
+   function GM_Day (Date : OS_Time) return Day_Type is
+      D  : Day_Type;
+
+      pragma Warnings (Off);
+      Y  : Year_Type;
+      Mo : Month_Type;
+      H  : Hour_Type;
+      Mn : Minute_Type;
+      S  : Second_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return D;
+   end GM_Day;
+
+   -------------
+   -- GM_Hour --
+   -------------
+
+   function GM_Hour (Date : OS_Time) return Hour_Type is
+      H  : Hour_Type;
+
+      pragma Warnings (Off);
+      Y  : Year_Type;
+      Mo : Month_Type;
+      D  : Day_Type;
+      Mn : Minute_Type;
+      S  : Second_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return H;
+   end GM_Hour;
+
+   ---------------
+   -- GM_Minute --
+   ---------------
+
+   function GM_Minute (Date : OS_Time) return Minute_Type is
+      Mn : Minute_Type;
+
+      pragma Warnings (Off);
+      Y  : Year_Type;
+      Mo : Month_Type;
+      D  : Day_Type;
+      H  : Hour_Type;
+      S  : Second_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return Mn;
+   end GM_Minute;
+
+   --------------
+   -- GM_Month --
+   --------------
+
+   function GM_Month (Date : OS_Time) return Month_Type is
+      Mo : Month_Type;
+
+      pragma Warnings (Off);
+      Y  : Year_Type;
+      D  : Day_Type;
+      H  : Hour_Type;
+      Mn : Minute_Type;
+      S  : Second_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return Mo;
+   end GM_Month;
+
+   ---------------
+   -- GM_Second --
+   ---------------
+
+   function GM_Second (Date : OS_Time) return Second_Type is
+      S  : Second_Type;
+
+      pragma Warnings (Off);
+      Y  : Year_Type;
+      Mo : Month_Type;
+      D  : Day_Type;
+      H  : Hour_Type;
+      Mn : Minute_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return S;
+   end GM_Second;
+
+   --------------
+   -- GM_Split --
+   --------------
+
+   procedure GM_Split
+     (Date   : OS_Time;
+      Year   : out Year_Type;
+      Month  : out Month_Type;
+      Day    : out Day_Type;
+      Hour   : out Hour_Type;
+      Minute : out Minute_Type;
+      Second : out Second_Type)
+   is
+      procedure To_GM_Time
+        (P_Time_T, P_Year, P_Month, P_Day, P_Hours, P_Mins, P_Secs : Address);
+      pragma Import (C, To_GM_Time, "__gnat_to_gm_time");
+
+      T  : OS_Time := Date;
+      Y  : Integer;
+      Mo : Integer;
+      D  : Integer;
+      H  : Integer;
+      Mn : Integer;
+      S  : Integer;
+
+   begin
+      --  Use the global lock because To_GM_Time is not thread safe
+
+      Locked_Processing : begin
+         SSL.Lock_Task.all;
+         To_GM_Time
+           (T'Address, Y'Address, Mo'Address, D'Address,
+            H'Address, Mn'Address, S'Address);
+         SSL.Unlock_Task.all;
+
+      exception
+         when others =>
+            SSL.Unlock_Task.all;
+            raise;
+      end Locked_Processing;
+
+      Year   := Y + 1900;
+      Month  := Mo + 1;
+      Day    := D;
+      Hour   := H;
+      Minute := Mn;
+      Second := S;
+   end GM_Split;
+
+   -------------
+   -- GM_Year --
+   -------------
+
+   function GM_Year (Date : OS_Time) return Year_Type is
+      Y  : Year_Type;
+
+      pragma Warnings (Off);
+      Mo : Month_Type;
+      D  : Day_Type;
+      H  : Hour_Type;
+      Mn : Minute_Type;
+      S  : Second_Type;
+      pragma Warnings (On);
+
+   begin
+      GM_Split (Date, Y, Mo, D, H, Mn, S);
+      return Y;
+   end GM_Year;
+
+   ----------------------
+   -- Is_Absolute_Path --
+   ----------------------
+
+   function Is_Absolute_Path (Name : String) return Boolean is
+      function Is_Absolute_Path
+        (Name   : Address;
+         Length : Integer) return Integer;
+      pragma Import (C, Is_Absolute_Path, "__gnat_is_absolute_path");
+   begin
+      return Is_Absolute_Path (Name'Address, Name'Length) /= 0;
+   end Is_Absolute_Path;
+
+   ------------------
+   -- Is_Directory --
+   ------------------
+
+   function Is_Directory (Name : C_File_Name) return Boolean is
+      function Is_Directory (Name : Address) return Integer;
+      pragma Import (C, Is_Directory, "__gnat_is_directory");
+   begin
+      return Is_Directory (Name) /= 0;
+   end Is_Directory;
+
+   function Is_Directory (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Directory (F_Name'Address);
+   end Is_Directory;
+
+   ----------------------
+   -- Is_Readable_File --
+   ----------------------
+
+   function Is_Readable_File (Name : C_File_Name) return Boolean is
+      function Is_Readable_File (Name : Address) return Integer;
+      pragma Import (C, Is_Readable_File, "__gnat_is_readable_file");
+   begin
+      return Is_Readable_File (Name) /= 0;
+   end Is_Readable_File;
+
+   function Is_Readable_File (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Readable_File (F_Name'Address);
+   end Is_Readable_File;
+
+   ------------------------
+   -- Is_Executable_File --
+   ------------------------
+
+   function Is_Executable_File (Name : C_File_Name) return Boolean is
+      function Is_Executable_File (Name : Address) return Integer;
+      pragma Import (C, Is_Executable_File, "__gnat_is_executable_file");
+   begin
+      return Is_Executable_File (Name) /= 0;
+   end Is_Executable_File;
+
+   function Is_Executable_File (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Executable_File (F_Name'Address);
+   end Is_Executable_File;
+
+   ---------------------
+   -- Is_Regular_File --
+   ---------------------
+
+   function Is_Regular_File (Name : C_File_Name) return Boolean is
+      function Is_Regular_File (Name : Address) return Integer;
+      pragma Import (C, Is_Regular_File, "__gnat_is_regular_file");
+   begin
+      return Is_Regular_File (Name) /= 0;
+   end Is_Regular_File;
+
+   function Is_Regular_File (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Regular_File (F_Name'Address);
+   end Is_Regular_File;
+
+   ----------------------
+   -- Is_Symbolic_Link --
+   ----------------------
+
+   function Is_Symbolic_Link (Name : C_File_Name) return Boolean is
+      function Is_Symbolic_Link (Name : Address) return Integer;
+      pragma Import (C, Is_Symbolic_Link, "__gnat_is_symbolic_link");
+   begin
+      return Is_Symbolic_Link (Name) /= 0;
+   end Is_Symbolic_Link;
+
+   function Is_Symbolic_Link (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Symbolic_Link (F_Name'Address);
+   end Is_Symbolic_Link;
+
+   ----------------------
+   -- Is_Writable_File --
+   ----------------------
+
+   function Is_Writable_File (Name : C_File_Name) return Boolean is
+      function Is_Writable_File (Name : Address) return Integer;
+      pragma Import (C, Is_Writable_File, "__gnat_is_writable_file");
+   begin
+      return Is_Writable_File (Name) /= 0;
+   end Is_Writable_File;
+
+   function Is_Writable_File (Name : String) return Boolean is
+      F_Name : String (1 .. Name'Length + 1);
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+      return Is_Writable_File (F_Name'Address);
+   end Is_Writable_File;
+
+   -------------------------
+   -- Locate_Exec_On_Path --
+   -------------------------
+
+   function Locate_Exec_On_Path
+     (Exec_Name : String) return String_Access
+   is
+      function Locate_Exec_On_Path (C_Exec_Name : Address) return Address;
+      pragma Import (C, Locate_Exec_On_Path, "__gnat_locate_exec_on_path");
+
+      procedure Free (Ptr : System.Address);
+      pragma Import (C, Free, "free");
+
+      C_Exec_Name  : String (1 .. Exec_Name'Length + 1);
+      Path_Addr    : Address;
+      Path_Len     : Integer;
+      Result       : String_Access;
+
+   begin
+      C_Exec_Name (1 .. Exec_Name'Length)   := Exec_Name;
+      C_Exec_Name (C_Exec_Name'Last)        := ASCII.NUL;
+
+      Path_Addr := Locate_Exec_On_Path (C_Exec_Name'Address);
+      Path_Len  := C_String_Length (Path_Addr);
+
+      if Path_Len = 0 then
+         return null;
+
+      else
+         Result := To_Path_String_Access (Path_Addr, Path_Len);
+         Free (Path_Addr);
+
+         --  Always return an absolute path name
+
+         if not Is_Absolute_Path (Result.all) then
+            declare
+               Absolute_Path : constant String :=
+                                 Normalize_Pathname (Result.all);
+            begin
+               Free (Result);
+               Result := new String'(Absolute_Path);
+            end;
+         end if;
+
+         return Result;
+      end if;
+   end Locate_Exec_On_Path;
+
+   -------------------------
+   -- Locate_Regular_File --
+   -------------------------
+
+   function Locate_Regular_File
+     (File_Name : C_File_Name;
+      Path      : C_File_Name) return String_Access
+   is
+      function Locate_Regular_File
+        (C_File_Name, Path_Val : Address) return Address;
+      pragma Import (C, Locate_Regular_File, "__gnat_locate_regular_file");
+
+      procedure Free (Ptr : System.Address);
+      pragma Import (C, Free, "free");
+
+      Path_Addr    : Address;
+      Path_Len     : Integer;
+      Result       : String_Access;
+
+   begin
+      Path_Addr := Locate_Regular_File (File_Name, Path);
+      Path_Len  := C_String_Length (Path_Addr);
+
+      if Path_Len = 0 then
+         return null;
+
+      else
+         Result := To_Path_String_Access (Path_Addr, Path_Len);
+         Free (Path_Addr);
+         return Result;
+      end if;
+   end Locate_Regular_File;
+
+   function Locate_Regular_File
+     (File_Name : String;
+      Path      : String) return String_Access
+   is
+      C_File_Name : String (1 .. File_Name'Length + 1);
+      C_Path      : String (1 .. Path'Length + 1);
+      Result      : String_Access;
+
+   begin
+      C_File_Name (1 .. File_Name'Length)   := File_Name;
+      C_File_Name (C_File_Name'Last)        := ASCII.NUL;
+
+      C_Path    (1 .. Path'Length)          := Path;
+      C_Path    (C_Path'Last)               := ASCII.NUL;
+
+      Result := Locate_Regular_File (C_File_Name'Address, C_Path'Address);
+
+      --  Always return an absolute path name
+
+      if Result /= null and then not Is_Absolute_Path (Result.all) then
+         declare
+            Absolute_Path : constant String := Normalize_Pathname (Result.all);
+         begin
+            Free (Result);
+            Result := new String'(Absolute_Path);
+         end;
+      end if;
+
+      return Result;
+   end Locate_Regular_File;
+
+   ------------------------
+   -- Non_Blocking_Spawn --
+   ------------------------
+
+   function Non_Blocking_Spawn
+     (Program_Name : String;
+      Args         : Argument_List) return Process_Id
+   is
+      Pid  : Process_Id;
+      Junk : Integer;
+      pragma Warnings (Off, Junk);
+   begin
+      Spawn_Internal (Program_Name, Args, Junk, Pid, Blocking => False);
+      return Pid;
+   end Non_Blocking_Spawn;
+
+   function Non_Blocking_Spawn
+     (Program_Name           : String;
+      Args                   : Argument_List;
+      Output_File_Descriptor : File_Descriptor;
+      Err_To_Out             : Boolean := True) return Process_Id
+   is
+      Saved_Output : File_Descriptor;
+      Saved_Error  : File_Descriptor := Invalid_FD; -- prevent warning
+      Pid          : Process_Id;
+
+   begin
+      if Output_File_Descriptor = Invalid_FD then
+         return Invalid_Pid;
+      end if;
+
+      --  Set standard output and, if specified, error to the temporary file
+
+      Saved_Output := Dup (Standout);
+      Dup2 (Output_File_Descriptor, Standout);
+
+      if Err_To_Out then
+         Saved_Error  := Dup (Standerr);
+         Dup2 (Output_File_Descriptor, Standerr);
+      end if;
+
+      --  Spawn the program
+
+      Pid := Non_Blocking_Spawn (Program_Name, Args);
+
+      --  Restore the standard output and error
+
+      Dup2 (Saved_Output, Standout);
+
+      if Err_To_Out then
+         Dup2 (Saved_Error, Standerr);
+      end if;
+
+      --  And close the saved standard output and error file descriptors
+
+      Close (Saved_Output);
+
+      if Err_To_Out then
+         Close (Saved_Error);
+      end if;
+
+      return Pid;
+   end Non_Blocking_Spawn;
+
+   function Non_Blocking_Spawn
+     (Program_Name : String;
+      Args         : Argument_List;
+      Output_File  : String;
+      Err_To_Out   : Boolean := True) return Process_Id
+   is
+      Output_File_Descriptor : constant File_Descriptor :=
+                                 Create_Output_Text_File (Output_File);
+      Result : Process_Id;
+
+   begin
+      --  Do not attempt to spawn if the output file could not be created
+
+      if Output_File_Descriptor = Invalid_FD then
+         return Invalid_Pid;
+
+      else
+         Result := Non_Blocking_Spawn
+                     (Program_Name, Args, Output_File_Descriptor, Err_To_Out);
+
+         --  Close the file just created for the output, as the file descriptor
+         --  cannot be used anywhere, being a local value. It is safe to do
+         --  that, as the file descriptor has been duplicated to form
+         --  standard output and error of the spawned process.
+
+         Close (Output_File_Descriptor);
+
+         return Result;
+      end if;
+   end Non_Blocking_Spawn;
+
+   -------------------------
+   -- Normalize_Arguments --
+   -------------------------
+
+   procedure Normalize_Arguments (Args : in out Argument_List) is
+
+      procedure Quote_Argument (Arg : in out String_Access);
+      --  Add quote around argument if it contains spaces
+
+      C_Argument_Needs_Quote : Integer;
+      pragma Import (C, C_Argument_Needs_Quote, "__gnat_argument_needs_quote");
+      Argument_Needs_Quote : constant Boolean := C_Argument_Needs_Quote /= 0;
+
+      --------------------
+      -- Quote_Argument --
+      --------------------
+
+      procedure Quote_Argument (Arg : in out String_Access) is
+         Res          : String (1 .. Arg'Length * 2);
+         J            : Positive := 1;
+         Quote_Needed : Boolean  := False;
+
+      begin
+         if Arg (Arg'First) /= '"' or else Arg (Arg'Last) /= '"' then
+
+            --  Starting quote
+
+            Res (J) := '"';
+
+            for K in Arg'Range loop
+
+               J := J + 1;
+
+               if Arg (K) = '"' then
+                  Res (J) := '\';
+                  J := J + 1;
+                  Res (J) := '"';
+                  Quote_Needed := True;
+
+               elsif Arg (K) = ' ' then
+                  Res (J) := Arg (K);
+                  Quote_Needed := True;
+
+               else
+                  Res (J) := Arg (K);
+               end if;
+            end loop;
+
+            if Quote_Needed then
+
+               --  Case of null terminated string
+
+               if Res (J) = ASCII.NUL then
+
+                  --  If the string ends with \, double it
+
+                  if Res (J - 1) = '\' then
+                     Res (J) := '\';
+                     J := J + 1;
+                  end if;
+
+                  --  Put a quote just before the null at the end
+
+                  Res (J) := '"';
+                  J := J + 1;
+                  Res (J) := ASCII.NUL;
+
+               --  If argument is terminated by '\', then double it. Otherwise
+               --  the ending quote will be taken as-is. This is quite strange
+               --  spawn behavior from Windows, but this is what we see!
+
+               else
+                  if Res (J) = '\' then
+                     J := J + 1;
+                     Res (J) := '\';
+                  end if;
+
+                  --  Ending quote
+
+                  J := J + 1;
+                  Res (J) := '"';
+               end if;
+
+               declare
+                  Old : String_Access := Arg;
+
+               begin
+                  Arg := new String'(Res (1 .. J));
+                  Free (Old);
+               end;
+            end if;
+
+         end if;
+      end Quote_Argument;
+
+   --  Start of processing for Normalize_Arguments
+
+   begin
+      if Argument_Needs_Quote then
+         for K in Args'Range loop
+            if Args (K) /= null and then Args (K)'Length /= 0 then
+               Quote_Argument (Args (K));
+            end if;
+         end loop;
+      end if;
+   end Normalize_Arguments;
+
+   ------------------------
+   -- Normalize_Pathname --
+   ------------------------
+
+   function Normalize_Pathname
+     (Name           : String;
+      Directory      : String  := "";
+      Resolve_Links  : Boolean := True;
+      Case_Sensitive : Boolean := True) return String
+   is
+      Max_Path : Integer;
+      pragma Import (C, Max_Path, "__gnat_max_path_len");
+      --  Maximum length of a path name
+
+      procedure Get_Current_Dir
+        (Dir    : System.Address;
+         Length : System.Address);
+      pragma Import (C, Get_Current_Dir, "__gnat_get_current_dir");
+
+      Path_Buffer : String (1 .. Max_Path + Max_Path + 2);
+      End_Path    : Natural := 0;
+      Link_Buffer : String (1 .. Max_Path + 2);
+      Status      : Integer;
+      Last        : Positive;
+      Start       : Natural;
+      Finish      : Positive;
+
+      Max_Iterations : constant := 500;
+
+      function Get_File_Names_Case_Sensitive return Integer;
+      pragma Import
+        (C, Get_File_Names_Case_Sensitive,
+         "__gnat_get_file_names_case_sensitive");
+
+      Fold_To_Lower_Case : constant Boolean :=
+                             not Case_Sensitive
+                               and then Get_File_Names_Case_Sensitive = 0;
+
+      function Readlink
+        (Path   : System.Address;
+         Buf    : System.Address;
+         Bufsiz : Integer) return Integer;
+      pragma Import (C, Readlink, "__gnat_readlink");
+
+      function To_Canonical_File_Spec
+        (Host_File : System.Address) return System.Address;
+      pragma Import
+        (C, To_Canonical_File_Spec, "__gnat_to_canonical_file_spec");
+
+      The_Name : String (1 .. Name'Length + 1);
+      Canonical_File_Addr : System.Address;
+      Canonical_File_Len  : Integer;
+
+      function Strlen (S : System.Address) return Integer;
+      pragma Import (C, Strlen, "strlen");
+
+      function Final_Value (S : String) return String;
+      --  Make final adjustment to the returned string. This function strips
+      --  trailing directory separators, and folds returned string to lower
+      --  case if required.
+
+      function Get_Directory  (Dir : String) return String;
+      --  If Dir is not empty, return it, adding a directory separator
+      --  if not already present, otherwise return current working directory
+      --  with terminating directory separator.
+
+      -----------------
+      -- Final_Value --
+      -----------------
+
+      function Final_Value (S : String) return String is
+         S1 : String := S;
+         --  We may need to fold S to lower case, so we need a variable
+
+         Last : Natural;
+
+      begin
+         if Fold_To_Lower_Case then
+            System.Case_Util.To_Lower (S1);
+         end if;
+
+         --  Remove trailing directory separator, if any
+
+         Last := S1'Last;
+
+         if Last > 1
+           and then (S1 (Last) = '/'
+                       or else
+                     S1 (Last) = Directory_Separator)
+         then
+            --  Special case for Windows: C:\
+
+            if Last = 3
+              and then S1 (1) /= Directory_Separator
+              and then S1 (2) = ':'
+            then
+               null;
+
+            else
+               Last := Last - 1;
+            end if;
+         end if;
+
+         return S1 (1 .. Last);
+      end Final_Value;
+
+      -------------------
+      -- Get_Directory --
+      -------------------
+
+      function Get_Directory (Dir : String) return String is
+         Result : String (1 .. Dir'Length + 1);
+         Length : constant Natural := Dir'Length;
+
+      begin
+         --  Directory given, add directory separator if needed
+
+         if Length > 0 then
+            Result (1 .. Length) := Dir;
+
+            --  On Windows, change all '/' to '\'
+
+            if On_Windows then
+               for J in 1 .. Length loop
+                  if Result (J) = '/' then
+                     Result (J) := Directory_Separator;
+                  end if;
+               end loop;
+            end if;
+
+            --  Add directory separator, if needed
+
+            if Result (Length) = Directory_Separator then
+               return Result (1 .. Length);
+            else
+               Result (Result'Length) := Directory_Separator;
+               return Result;
+            end if;
+
+         --  Directory name not given, get current directory
+
+         else
+            declare
+               Buffer   : String (1 .. Max_Path + 2);
+               Path_Len : Natural := Max_Path;
+
+            begin
+               Get_Current_Dir (Buffer'Address, Path_Len'Address);
+
+               if Buffer (Path_Len) /= Directory_Separator then
+                  Path_Len := Path_Len + 1;
+                  Buffer (Path_Len) := Directory_Separator;
+               end if;
+
+               --  By default, the drive letter on Windows is in upper case
+
+               if On_Windows
+                 and then Path_Len >= 2
+                 and then Buffer (2) = ':'
+               then
+                  System.Case_Util.To_Upper (Buffer (1 .. 1));
+               end if;
+
+               return Buffer (1 .. Path_Len);
+            end;
+         end if;
+      end Get_Directory;
+
+   --  Start of processing for Normalize_Pathname
+
+   begin
+      --  Special case, if name is null, then return null
+
+      if Name'Length = 0 then
+         return "";
+      end if;
+
+      --  First, convert VMS file spec to Unix file spec.
+      --  If Name is not in VMS syntax, then this is equivalent
+      --  to put Name at the beginning of Path_Buffer.
+
+      VMS_Conversion : begin
+         The_Name (1 .. Name'Length) := Name;
+         The_Name (The_Name'Last) := ASCII.NUL;
+
+         Canonical_File_Addr := To_Canonical_File_Spec (The_Name'Address);
+         Canonical_File_Len  := Strlen (Canonical_File_Addr);
+
+         --  If VMS syntax conversion has failed, return an empty string
+         --  to indicate the failure.
+
+         if Canonical_File_Len = 0 then
+            return "";
+         end if;
+
+         declare
+            subtype Path_String is String (1 .. Canonical_File_Len);
+            type    Path_String_Access is access Path_String;
+
+            function Address_To_Access is new
+               Ada.Unchecked_Conversion (Source => Address,
+                                     Target => Path_String_Access);
+
+            Path_Access : constant Path_String_Access :=
+                            Address_To_Access (Canonical_File_Addr);
+
+         begin
+            Path_Buffer (1 .. Canonical_File_Len) := Path_Access.all;
+            End_Path := Canonical_File_Len;
+            Last := 1;
+         end;
+      end VMS_Conversion;
+
+      --  Replace all '/' by Directory Separators (this is for Windows)
+
+      if Directory_Separator /= '/' then
+         for Index in 1 .. End_Path loop
+            if Path_Buffer (Index) = '/' then
+               Path_Buffer (Index) := Directory_Separator;
+            end if;
+         end loop;
+      end if;
+
+      --  Resolve directory names for Windows (formerly also VMS)
+
+      --  On VMS, if we have a Unix path such as /temp/..., and TEMP is a
+      --  logical name, we must not try to resolve this logical name, because
+      --  it may have multiple equivalences and if resolved we will only
+      --  get the first one.
+
+      if On_Windows then
+
+         --  On Windows, if we have an absolute path starting with a directory
+         --  separator, we need to have the drive letter appended in front.
+
+         --  On Windows, Get_Current_Dir will return a suitable directory name
+         --  (path starting with a drive letter on Windows). So we take this
+         --  drive letter and prepend it to the current path.
+
+         if Path_Buffer (1) = Directory_Separator
+           and then Path_Buffer (2) /= Directory_Separator
+         then
+            declare
+               Cur_Dir : constant String := Get_Directory ("");
+               --  Get the current directory to get the drive letter
+
+            begin
+               if Cur_Dir'Length > 2
+                 and then Cur_Dir (Cur_Dir'First + 1) = ':'
+               then
+                  Path_Buffer (3 .. End_Path + 2) :=
+                    Path_Buffer (1 .. End_Path);
+                  Path_Buffer (1 .. 2) :=
+                    Cur_Dir (Cur_Dir'First .. Cur_Dir'First + 1);
+                  End_Path := End_Path + 2;
+               end if;
+            end;
+
+         --  We have a drive letter, ensure it is upper-case
+
+         elsif Path_Buffer (1) in 'a' .. 'z'
+           and then Path_Buffer (2) = ':'
+         then
+            System.Case_Util.To_Upper (Path_Buffer (1 .. 1));
+         end if;
+      end if;
+
+      --  On Windows, remove all double-quotes that are possibly part of the
+      --  path but can cause problems with other methods.
+
+      if On_Windows then
+         declare
+            Index : Natural;
+
+         begin
+            Index := Path_Buffer'First;
+            for Current in Path_Buffer'First .. End_Path loop
+               if Path_Buffer (Current) /= '"' then
+                  Path_Buffer (Index) := Path_Buffer (Current);
+                  Index := Index + 1;
+               end if;
+            end loop;
+
+            End_Path := Index - 1;
+         end;
+      end if;
+
+      --  Start the conversions
+
+      --  If this is not finished after Max_Iterations, give up and return an
+      --  empty string.
+
+      for J in 1 .. Max_Iterations loop
+
+         --  If we don't have an absolute pathname, prepend the directory
+         --  Reference_Dir.
+
+         if Last = 1
+           and then not Is_Absolute_Path (Path_Buffer (1 .. End_Path))
+         then
+            declare
+               Reference_Dir : constant String  := Get_Directory (Directory);
+               Ref_Dir_Len   : constant Natural := Reference_Dir'Length;
+               --  Current directory name specified and its length
+
+            begin
+               Path_Buffer (Ref_Dir_Len + 1 .. Ref_Dir_Len + End_Path) :=
+                 Path_Buffer (1 .. End_Path);
+               End_Path := Ref_Dir_Len + End_Path;
+               Path_Buffer (1 .. Ref_Dir_Len) := Reference_Dir;
+               Last := Ref_Dir_Len;
+            end;
+         end if;
+
+         Start  := Last + 1;
+         Finish := Last;
+
+         --  Ensure that Windows network drives are kept, e.g: \\server\drive-c
+
+         if Start = 2
+           and then Directory_Separator = '\'
+           and then Path_Buffer (1 .. 2) = "\\"
+         then
+            Start := 3;
+         end if;
+
+         --  If we have traversed the full pathname, return it
+
+         if Start > End_Path then
+            return Final_Value (Path_Buffer (1 .. End_Path));
+         end if;
+
+         --  Remove duplicate directory separators
+
+         while Path_Buffer (Start) = Directory_Separator loop
+            if Start = End_Path then
+               return Final_Value (Path_Buffer (1 .. End_Path - 1));
+
+            else
+               Path_Buffer (Start .. End_Path - 1) :=
+                 Path_Buffer (Start + 1 .. End_Path);
+               End_Path := End_Path - 1;
+            end if;
+         end loop;
+
+         --  Find the end of the current field: last character or the one
+         --  preceding the next directory separator.
+
+         while Finish < End_Path
+           and then Path_Buffer (Finish + 1) /= Directory_Separator
+         loop
+            Finish := Finish + 1;
+         end loop;
+
+         --  Remove "." field
+
+         if Start = Finish and then Path_Buffer (Start) = '.' then
+            if Start = End_Path then
+               if Last = 1 then
+                  return (1 => Directory_Separator);
+               else
+
+                  if Fold_To_Lower_Case then
+                     System.Case_Util.To_Lower (Path_Buffer (1 .. Last - 1));
+                  end if;
+
+                  return Path_Buffer (1 .. Last - 1);
+
+               end if;
+
+            else
+               Path_Buffer (Last + 1 .. End_Path - 2) :=
+                 Path_Buffer (Last + 3 .. End_Path);
+               End_Path := End_Path - 2;
+            end if;
+
+         --  Remove ".." fields
+
+         elsif Finish = Start + 1
+           and then Path_Buffer (Start .. Finish) = ".."
+         then
+            Start := Last;
+            loop
+               Start := Start - 1;
+               exit when Start < 1
+                 or else Path_Buffer (Start) = Directory_Separator;
+            end loop;
+
+            if Start <= 1 then
+               if Finish = End_Path then
+                  return (1 => Directory_Separator);
+
+               else
+                  Path_Buffer (1 .. End_Path - Finish) :=
+                    Path_Buffer (Finish + 1 .. End_Path);
+                  End_Path := End_Path - Finish;
+                  Last := 1;
+               end if;
+
+            else
+               if Finish = End_Path then
+                  return Final_Value (Path_Buffer (1 .. Start - 1));
+
+               else
+                  Path_Buffer (Start + 1 .. Start + End_Path - Finish - 1) :=
+                    Path_Buffer (Finish + 2 .. End_Path);
+                  End_Path := Start + End_Path - Finish - 1;
+                  Last := Start;
+               end if;
+            end if;
+
+         --  Check if current field is a symbolic link
+
+         elsif Resolve_Links then
+            declare
+               Saved : constant Character := Path_Buffer (Finish + 1);
+
+            begin
+               Path_Buffer (Finish + 1) := ASCII.NUL;
+               Status := Readlink (Path_Buffer'Address,
+                                   Link_Buffer'Address,
+                                   Link_Buffer'Length);
+               Path_Buffer (Finish + 1) := Saved;
+            end;
+
+            --  Not a symbolic link, move to the next field, if any
+
+            if Status <= 0 then
+               Last := Finish + 1;
+
+            --  Replace symbolic link with its value
+
+            else
+               if Is_Absolute_Path (Link_Buffer (1 .. Status)) then
+                  Path_Buffer (Status + 1 .. End_Path - (Finish - Status)) :=
+                  Path_Buffer (Finish + 1 .. End_Path);
+                  End_Path := End_Path - (Finish - Status);
+                  Path_Buffer (1 .. Status) := Link_Buffer (1 .. Status);
+                  Last := 1;
+
+               else
+                  Path_Buffer
+                    (Last + Status + 1 .. End_Path - Finish + Last + Status) :=
+                    Path_Buffer (Finish + 1 .. End_Path);
+                  End_Path := End_Path - Finish + Last + Status;
+                  Path_Buffer (Last + 1 .. Last + Status) :=
+                    Link_Buffer (1 .. Status);
+               end if;
+            end if;
+
+         else
+            Last := Finish + 1;
+         end if;
+      end loop;
+
+      --  Too many iterations: give up
+
+      --  This can happen when there is a circularity in the symbolic links: A
+      --  is a symbolic link for B, which itself is a symbolic link, and the
+      --  target of B or of another symbolic link target of B is A. In this
+      --  case, we return an empty string to indicate failure to resolve.
+
+      return "";
+   end Normalize_Pathname;
+
+   ---------------
+   -- Open_Read --
+   ---------------
+
+   function Open_Read
+     (Name  : C_File_Name;
+      Fmode : Mode) return File_Descriptor
+   is
+      function C_Open_Read
+        (Name  : C_File_Name;
+         Fmode : Mode) return File_Descriptor;
+      pragma Import (C, C_Open_Read, "__gnat_open_read");
+   begin
+      return C_Open_Read (Name, Fmode);
+   end Open_Read;
+
+   function Open_Read
+     (Name  : String;
+      Fmode : Mode) return File_Descriptor
+   is
+      C_Name : String (1 .. Name'Length + 1);
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+      return Open_Read (C_Name (C_Name'First)'Address, Fmode);
+   end Open_Read;
+
+   ---------------------
+   -- Open_Read_Write --
+   ---------------------
+
+   function Open_Read_Write
+     (Name  : C_File_Name;
+      Fmode : Mode) return File_Descriptor
+   is
+      function C_Open_Read_Write
+        (Name  : C_File_Name;
+         Fmode : Mode) return File_Descriptor;
+      pragma Import (C, C_Open_Read_Write, "__gnat_open_rw");
+   begin
+      return C_Open_Read_Write (Name, Fmode);
+   end Open_Read_Write;
+
+   function Open_Read_Write
+     (Name  : String;
+      Fmode : Mode) return File_Descriptor
+   is
+      C_Name : String (1 .. Name'Length + 1);
+   begin
+      C_Name (1 .. Name'Length) := Name;
+      C_Name (C_Name'Last)      := ASCII.NUL;
+      return Open_Read_Write (C_Name (C_Name'First)'Address, Fmode);
+   end Open_Read_Write;
+
+   -------------
+   -- OS_Exit --
+   -------------
+
+   procedure OS_Exit (Status : Integer) is
+   begin
+      OS_Exit_Ptr (Status);
+      raise Program_Error;
+   end OS_Exit;
+
+   ---------------------
+   -- OS_Exit_Default --
+   ---------------------
+
+   procedure OS_Exit_Default (Status : Integer) is
+      procedure GNAT_OS_Exit (Status : Integer);
+      pragma Import (C, GNAT_OS_Exit, "__gnat_os_exit");
+      pragma No_Return (GNAT_OS_Exit);
+   begin
+      GNAT_OS_Exit (Status);
+   end OS_Exit_Default;
+
+   --------------------
+   -- Pid_To_Integer --
+   --------------------
+
+   function Pid_To_Integer (Pid : Process_Id) return Integer is
+   begin
+      return Integer (Pid);
+   end Pid_To_Integer;
+
+   ----------
+   -- Read --
+   ----------
+
+   function Read
+     (FD : File_Descriptor;
+      A  : System.Address;
+      N  : Integer) return Integer
+   is
+   begin
+      return
+        Integer (System.CRTL.read
+                   (System.CRTL.int (FD),
+                    System.CRTL.chars (A),
+                    System.CRTL.size_t (N)));
+   end Read;
+
+   -----------------
+   -- Rename_File --
+   -----------------
+
+   procedure Rename_File
+     (Old_Name : C_File_Name;
+      New_Name : C_File_Name;
+      Success  : out Boolean)
+   is
+      function rename (From, To : Address) return Integer;
+      pragma Import (C, rename, "__gnat_rename");
+      R : Integer;
+   begin
+      R := rename (Old_Name, New_Name);
+      Success := (R = 0);
+   end Rename_File;
+
+   procedure Rename_File
+     (Old_Name : String;
+      New_Name : String;
+      Success  : out Boolean)
+   is
+      C_Old_Name : String (1 .. Old_Name'Length + 1);
+      C_New_Name : String (1 .. New_Name'Length + 1);
+   begin
+      C_Old_Name (1 .. Old_Name'Length) := Old_Name;
+      C_Old_Name (C_Old_Name'Last)      := ASCII.NUL;
+      C_New_Name (1 .. New_Name'Length) := New_Name;
+      C_New_Name (C_New_Name'Last)      := ASCII.NUL;
+      Rename_File (C_Old_Name'Address, C_New_Name'Address, Success);
+   end Rename_File;
+
+   -----------------------
+   -- Set_Close_On_Exec --
+   -----------------------
+
+   procedure Set_Close_On_Exec
+     (FD            : File_Descriptor;
+      Close_On_Exec : Boolean;
+      Status        : out Boolean)
+   is
+      function C_Set_Close_On_Exec
+        (FD : File_Descriptor; Close_On_Exec : System.CRTL.int)
+         return System.CRTL.int;
+      pragma Import (C, C_Set_Close_On_Exec, "__gnat_set_close_on_exec");
+   begin
+      Status := C_Set_Close_On_Exec (FD, Boolean'Pos (Close_On_Exec)) = 0;
+   end Set_Close_On_Exec;
+
+   --------------------
+   -- Set_Executable --
+   --------------------
+
+   procedure Set_Executable (Name : String) is
+      procedure C_Set_Executable (Name : C_File_Name);
+      pragma Import (C, C_Set_Executable, "__gnat_set_executable");
+      C_Name : aliased String (Name'First .. Name'Last + 1);
+   begin
+      C_Name (Name'Range)  := Name;
+      C_Name (C_Name'Last) := ASCII.NUL;
+      C_Set_Executable (C_Name (C_Name'First)'Address);
+   end Set_Executable;
+
+   ----------------------
+   -- Set_Non_Readable --
+   ----------------------
+
+   procedure Set_Non_Readable (Name : String) is
+      procedure C_Set_Non_Readable (Name : C_File_Name);
+      pragma Import (C, C_Set_Non_Readable, "__gnat_set_non_readable");
+      C_Name : aliased String (Name'First .. Name'Last + 1);
+   begin
+      C_Name (Name'Range)  := Name;
+      C_Name (C_Name'Last) := ASCII.NUL;
+      C_Set_Non_Readable (C_Name (C_Name'First)'Address);
+   end Set_Non_Readable;
+
+   ----------------------
+   -- Set_Non_Writable --
+   ----------------------
+
+   procedure Set_Non_Writable (Name : String) is
+      procedure C_Set_Non_Writable (Name : C_File_Name);
+      pragma Import (C, C_Set_Non_Writable, "__gnat_set_non_writable");
+      C_Name : aliased String (Name'First .. Name'Last + 1);
+   begin
+      C_Name (Name'Range)  := Name;
+      C_Name (C_Name'Last) := ASCII.NUL;
+      C_Set_Non_Writable (C_Name (C_Name'First)'Address);
+   end Set_Non_Writable;
+
+   ------------------
+   -- Set_Readable --
+   ------------------
+
+   procedure Set_Readable (Name : String) is
+      procedure C_Set_Readable (Name : C_File_Name);
+      pragma Import (C, C_Set_Readable, "__gnat_set_readable");
+      C_Name : aliased String (Name'First .. Name'Last + 1);
+   begin
+      C_Name (Name'Range)  := Name;
+      C_Name (C_Name'Last) := ASCII.NUL;
+      C_Set_Readable (C_Name (C_Name'First)'Address);
+   end Set_Readable;
+
+   --------------------
+   -- Set_Writable --
+   --------------------
+
+   procedure Set_Writable (Name : String) is
+      procedure C_Set_Writable (Name : C_File_Name);
+      pragma Import (C, C_Set_Writable, "__gnat_set_writable");
+      C_Name : aliased String (Name'First .. Name'Last + 1);
+   begin
+      C_Name (Name'Range)  := Name;
+      C_Name (C_Name'Last) := ASCII.NUL;
+      C_Set_Writable (C_Name (C_Name'First)'Address);
+   end Set_Writable;
+
+   ------------
+   -- Setenv --
+   ------------
+
+   procedure Setenv (Name : String; Value : String) is
+      F_Name  : String (1 .. Name'Length + 1);
+      F_Value : String (1 .. Value'Length + 1);
+
+      procedure Set_Env_Value (Name, Value : System.Address);
+      pragma Import (C, Set_Env_Value, "__gnat_setenv");
+
+   begin
+      F_Name (1 .. Name'Length) := Name;
+      F_Name (F_Name'Last)      := ASCII.NUL;
+
+      F_Value (1 .. Value'Length) := Value;
+      F_Value (F_Value'Last)      := ASCII.NUL;
+
+      Set_Env_Value (F_Name'Address, F_Value'Address);
+   end Setenv;
+
+   -----------
+   -- Spawn --
+   -----------
+
+   function Spawn
+     (Program_Name : String;
+      Args         : Argument_List) return Integer
+   is
+      Result : Integer;
+      Junk   : Process_Id;
+      pragma Warnings (Off, Junk);
+   begin
+      Spawn_Internal (Program_Name, Args, Result, Junk, Blocking => True);
+      return Result;
+   end Spawn;
+
+   procedure Spawn
+     (Program_Name : String;
+      Args         : Argument_List;
+      Success      : out Boolean)
+   is
+   begin
+      Success := (Spawn (Program_Name, Args) = 0);
+   end Spawn;
+
+   procedure Spawn
+     (Program_Name           : String;
+      Args                   : Argument_List;
+      Output_File_Descriptor : File_Descriptor;
+      Return_Code            : out Integer;
+      Err_To_Out             : Boolean := True)
+   is
+      Saved_Output : File_Descriptor;
+      Saved_Error  : File_Descriptor := Invalid_FD; -- prevent compiler warning
+
+   begin
+      --  Set standard output and error to the temporary file
+
+      Saved_Output := Dup (Standout);
+      Dup2 (Output_File_Descriptor, Standout);
+
+      if Err_To_Out then
+         Saved_Error  := Dup (Standerr);
+         Dup2 (Output_File_Descriptor, Standerr);
+      end if;
+
+      --  Spawn the program
+
+      Return_Code := Spawn (Program_Name, Args);
+
+      --  Restore the standard output and error
+
+      Dup2 (Saved_Output, Standout);
+
+      if Err_To_Out then
+         Dup2 (Saved_Error, Standerr);
+      end if;
+
+      --  And close the saved standard output and error file descriptors
+
+      Close (Saved_Output);
+
+      if Err_To_Out then
+         Close (Saved_Error);
+      end if;
+   end Spawn;
+
+   procedure Spawn
+     (Program_Name : String;
+      Args         : Argument_List;
+      Output_File  : String;
+      Success      : out Boolean;
+      Return_Code  : out Integer;
+      Err_To_Out   : Boolean := True)
+   is
+      FD : File_Descriptor;
+
+   begin
+      Success := True;
+      Return_Code := 0;
+
+      FD := Create_Output_Text_File (Output_File);
+
+      if FD = Invalid_FD then
+         Success := False;
+         return;
+      end if;
+
+      Spawn (Program_Name, Args, FD, Return_Code, Err_To_Out);
+
+      Close (FD, Success);
+   end Spawn;
+
+   --------------------
+   -- Spawn_Internal --
+   --------------------
+
+   procedure Spawn_Internal
+     (Program_Name : String;
+      Args         : Argument_List;
+      Result       : out Integer;
+      Pid          : out Process_Id;
+      Blocking     : Boolean)
+   is
+
+      procedure Spawn (Args : Argument_List);
+      --  Call Spawn with given argument list
+
+      N_Args : Argument_List (Args'Range);
+      --  Normalized arguments
+
+      -----------
+      -- Spawn --
+      -----------
+
+      procedure Spawn (Args : Argument_List) is
+         type Chars is array (Positive range <>) of aliased Character;
+         type Char_Ptr is access constant Character;
+
+         Command_Len  : constant Positive := Program_Name'Length + 1
+                                               + Args_Length (Args);
+         Command_Last : Natural := 0;
+         Command      : aliased Chars (1 .. Command_Len);
+         --  Command contains all characters of the Program_Name and Args, all
+         --  terminated by ASCII.NUL characters.
+
+         Arg_List_Len  : constant Positive := Args'Length + 2;
+         Arg_List_Last : Natural := 0;
+         Arg_List      : aliased array (1 .. Arg_List_Len) of Char_Ptr;
+         --  List with pointers to NUL-terminated strings of the Program_Name
+         --  and the Args and terminated with a null pointer. We rely on the
+         --  default initialization for the last null pointer.
+
+         procedure Add_To_Command (S : String);
+         --  Add S and a NUL character to Command, updating Last
+
+         function Portable_Spawn (Args : Address) return Integer;
+         pragma Import (C, Portable_Spawn, "__gnat_portable_spawn");
+
+         function Portable_No_Block_Spawn (Args : Address) return Process_Id;
+         pragma Import
+           (C, Portable_No_Block_Spawn, "__gnat_portable_no_block_spawn");
+
+         --------------------
+         -- Add_To_Command --
+         --------------------
+
+         procedure Add_To_Command (S : String) is
+            First : constant Natural := Command_Last + 1;
+
+         begin
+            Command_Last := Command_Last + S'Length;
+
+            --  Move characters one at a time, because Command has aliased
+            --  components.
+
+            --  But not volatile, so why is this necessary ???
+
+            for J in S'Range loop
+               Command (First + J - S'First) := S (J);
+            end loop;
+
+            Command_Last := Command_Last + 1;
+            Command (Command_Last) := ASCII.NUL;
+
+            Arg_List_Last := Arg_List_Last + 1;
+            Arg_List (Arg_List_Last) := Command (First)'Access;
+         end Add_To_Command;
+
+      --  Start of processing for Spawn
+
+      begin
+         Add_To_Command (Program_Name);
+
+         for J in Args'Range loop
+            Add_To_Command (Args (J).all);
+         end loop;
+
+         if Blocking then
+            Pid     := Invalid_Pid;
+            Result  := Portable_Spawn (Arg_List'Address);
+         else
+            Pid     := Portable_No_Block_Spawn (Arg_List'Address);
+            Result  := Boolean'Pos (Pid /= Invalid_Pid);
+         end if;
+      end Spawn;
+
+   --  Start of processing for Spawn_Internal
+
+   begin
+      --  Copy arguments into a local structure
+
+      for K in N_Args'Range loop
+         N_Args (K) := new String'(Args (K).all);
+      end loop;
+
+      --  Normalize those arguments
+
+      Normalize_Arguments (N_Args);
+
+      --  Call spawn using the normalized arguments
+
+      Spawn (N_Args);
+
+      --  Free arguments list
+
+      for K in N_Args'Range loop
+         Free (N_Args (K));
+      end loop;
+   end Spawn_Internal;
+
+   ---------------------------
+   -- To_Path_String_Access --
+   ---------------------------
+
+   function To_Path_String_Access
+     (Path_Addr : Address;
+      Path_Len  : Integer) return String_Access
+   is
+      subtype Path_String is String (1 .. Path_Len);
+      type    Path_String_Access is access Path_String;
+
+      function Address_To_Access is new Ada.Unchecked_Conversion
+        (Source => Address, Target => Path_String_Access);
+
+      Path_Access : constant Path_String_Access :=
+                      Address_To_Access (Path_Addr);
+
+      Return_Val  : String_Access;
+
+   begin
+      Return_Val := new String (1 .. Path_Len);
+
+      for J in 1 .. Path_Len loop
+         Return_Val (J) := Path_Access (J);
+      end loop;
+
+      return Return_Val;
+   end To_Path_String_Access;
+
+   ------------------
+   -- Wait_Process --
+   ------------------
+
+   procedure Wait_Process (Pid : out Process_Id; Success : out Boolean) is
+      Status : Integer;
+
+      function Portable_Wait (S : Address) return Process_Id;
+      pragma Import (C, Portable_Wait, "__gnat_portable_wait");
+
+   begin
+      Pid := Portable_Wait (Status'Address);
+      Success := (Status = 0);
+   end Wait_Process;
+
+   -----------
+   -- Write --
+   -----------
+
+   function Write
+     (FD : File_Descriptor;
+      A  : System.Address;
+      N  : Integer) return Integer
+   is
+   begin
+      return
+        Integer (System.CRTL.write
+                   (System.CRTL.int (FD),
+                    System.CRTL.chars (A),
+                    System.CRTL.size_t (N)));
+   end Write;
+
+end System.OS_Lib;
diff --git a/gcc/ada/sysdep.c b/gcc/ada/sysdep.c
index 1eec8b96f..2731dd305 100644
--- a/gcc/ada/sysdep.c
+++ b/gcc/ada/sysdep.c
@@ -124,7 +124,7 @@ extern struct tm *localtime_r(const time_t *, struct tm *);
 
 */
 
-#if defined (WINNT) || defined (__CYGWIN__)
+#if defined (WINNT) || defined (__CYGWIN__) || defined(__DJGPP__)
 
 const char __gnat_text_translation_required = 1;
 
@@ -135,6 +135,11 @@ const char __gnat_text_translation_required = 1;
 #define WIN_SETMODE _setmode
 #endif
 
+#if defined(__DJGPP__)
+#include <io.h>
+#define _setmode setmode
+#endif /* __DJGPP__ */
+
 void
 __gnat_set_binary_mode (int handle)
 {
@@ -621,7 +626,29 @@ long __gnat_invalid_tzoff = 259273;
 
 /* Definition of __gnat_localtime_r used by a-calend.adb */
 
-#if defined (__MINGW32__)
+#if defined (__DJGPP__)
+
+/* FIXME: this is draft version only. Fix me if that is not correct  */
+/*        or not complete (AP)                                       */
+
+extern void
+__gnat_localtime_tzoff (const time_t *, long *);
+
+void
+__gnat_localtime_tzoff (const time_t *timer, long *off)
+{
+  struct tm *tmp;
+
+  tmp = localtime (timer);
+  *off = (long) -tmp->tm_gmtoff;
+
+  /* Correct the offset if Daylight Saving Time is in effect */
+
+  if (tmp->tm_isdst > 0)
+    *off = *off + 3600;
+}
+
+#elif defined (__MINGW32__)
 
 #ifdef CERT
 
diff --git a/gcc/ada/system-djgpp.ads b/gcc/ada/system-djgpp.ads
new file mode 100644
index 000000000..a311b948a
--- /dev/null
+++ b/gcc/ada/system-djgpp.ads
@@ -0,0 +1,160 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                            (Compiler Version)                            --
+--                                                                          --
+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This version of System is a generic version that is used in building the
+--  compiler. Right now, we have a host/target problem if we try to use the
+--  "proper" System, and since the compiler itself does not care about most
+--  System parameters, this generic version works fine.
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.01;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   --  Note that we do NOT add pragma Preelaborable_Initialization in this
+   --  version of System, since it is used for the compiler only, and typical
+   --  earlier bootstrap compilers don't support this pragma. We don't need
+   --  it in this context, so there is no problem in omitting it.
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := Standard'Storage_Unit;
+   Word_Size    : constant := Standard'Word_Size;
+   Memory_Size  : constant := 2 ** Standard'Address_Size;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order :=
+                         Bit_Order'Val (Standard'Default_Bit_Order);
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used by
+   --  the compiler. They are in the private part of System, where they can be
+   --  accessed using the special circuitry in the Targparm unit whose source
+   --  should be consulted for more detailed descriptions of the individual
+   --  switch values.
+
+   --  This version of system.ads is used only for building the compiler.
+   --  We really ought to use the proper target system (i.e. the one that
+   --  corresponds to the host for the compiler), but that causes as yet
+   --  unsolved makefile problems. For the most part the setting of these
+   --  parameters is not too critical for the compiler version (e.g. we
+   --  do not use floating-point anyway in the compiler).
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := False;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := False;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Atomic_Primitives : constant Boolean := False;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := True;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := False;
+
+end System;
diff --git a/gcc/ada/terminals.c b/gcc/ada/terminals.c
index 36b97a6f1..298553804 100644
--- a/gcc/ada/terminals.c
+++ b/gcc/ada/terminals.c
@@ -31,7 +31,7 @@
 
 /* First all usupported platforms. Add stubs for exported routines. */
 
-#if defined (VMS) || defined (__vxworks) || defined (__Lynx__) || \
+#if defined (VMS) || defined(__DJGPP__) || defined (__vxworks) || defined (__Lynx__) || \
     defined (__ANDROID__)
 
 void * __gnat_new_tty (void) { return (void*)0; }
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index a9108e790..adea09a7e 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -1713,8 +1713,10 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,
 	      /* If types don't match for a built-in, throw away the
 		 built-in.  No point in calling locate_old_decl here, it
 		 won't print anything.  */
+#ifndef __DJGPP__
 	      warning (0, "conflicting types for built-in function %q+D",
 		       newdecl);
+#endif
 	      return false;
 	    }
 	}
diff --git a/gcc/config.gcc b/gcc/config.gcc
index b09a763d5..b41638d27 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -3759,6 +3759,12 @@ case ${target} in
 	i[34567]86-*-gnu*)
 		tmake_file="$tmake_file i386/t-gnu"
 		;;
+	i[34567]86-*-msdosdjgpp*)
+		tmake_file="${tmake_file} i386/t-djgpp i386/t-fprules-softfp soft-fp/t-softfp"
+		;;
+	i[34567]86-*-msdosdjgpp*)
+		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp"
+		;;
 	i[34567]86-*-solaris2* | x86_64-*-solaris2.1[0-9]*)
 		;;
 	i[34567]86-*-cygwin* | i[34567]86-*-mingw* | x86_64-*-mingw*)
diff --git a/gcc/config.host b/gcc/config.host
index 1196ec523..4393fb9d3 100644
--- a/gcc/config.host
+++ b/gcc/config.host
@@ -207,12 +207,17 @@ case ${host} in
   i[34567]86-pc-msdosdjgpp*)
     host_xm_file=i386/xm-djgpp.h
     host_exeext=.exe
+    host_xmake_file="${host_xmake_file} i386/x-djgpp"
     # Shorten $target_noncanonical for 8.3 filename conventions.
+    # Also update C++ include directory name
+    # due to the same restrictions
     case ${target} in
       *pc-msdosdjgpp*)
         target_noncanonical=djgpp
+	libstdcxx_incdir_base=cxx
         ;;
     esac
+	
     ;;
   i[34567]86-*-cygwin*)
     host_xm_file=i386/xm-cygwin.h
diff --git a/gcc/config/i386/djgpp-stack.c b/gcc/config/i386/djgpp-stack.c
new file mode 100644
index 000000000..893b5037a
--- /dev/null
+++ b/gcc/config/i386/djgpp-stack.c
@@ -0,0 +1,10 @@
+/*
+
+The default stack size (512KB) for DJGPP applications is not
+sufficient for several GCC executables like
+cc1.exe, cc1plus.exe, etc.
+
+Redefine it to larger value (2MB).
+
+*/
+int _stklen = 2097152;
diff --git a/gcc/config/i386/djgpp-stdint.h b/gcc/config/i386/djgpp-stdint.h
index 3bc465f0c..5a33f7742 100644
--- a/gcc/config/i386/djgpp-stdint.h
+++ b/gcc/config/i386/djgpp-stdint.h
@@ -22,21 +22,21 @@ along with GCC; see the file COPYING3.  If not see
 /* Exact-width integer types */
 
 #define INT8_TYPE "signed char"
-#define INT16_TYPE "signed short int"
-#define INT32_TYPE "signed long int"
-#define INT64_TYPE "signed long long int"
+#define INT16_TYPE "short int"
+#define INT32_TYPE "int"
+#define INT64_TYPE "long long int"
 
 #define UINT8_TYPE "unsigned char"
 #define UINT16_TYPE "short unsigned int"
-#define UINT32_TYPE "long unsigned int"
+#define UINT32_TYPE "unsigned int"
 #define UINT64_TYPE "long long unsigned int"
 
 /* Minimum-width integer types */
 
 #define INT_LEAST8_TYPE "signed char"
-#define INT_LEAST16_TYPE "signed short int"
-#define INT_LEAST32_TYPE "signed int"
-#define INT_LEAST64_TYPE "signed long long int"
+#define INT_LEAST16_TYPE "short int"
+#define INT_LEAST32_TYPE "int"
+#define INT_LEAST64_TYPE "long long int"
 
 #define UINT_LEAST8_TYPE "unsigned char"
 #define UINT_LEAST16_TYPE "short unsigned int"
@@ -46,12 +46,12 @@ along with GCC; see the file COPYING3.  If not see
 /* Fastest minimum-width integer types */
 
 #define INT_FAST8_TYPE "signed char"
-#define INT_FAST16_TYPE "signed int"
-#define INT_FAST32_TYPE "signed int"
-#define INT_FAST64_TYPE "long long signed int"
+#define INT_FAST16_TYPE "short int"
+#define INT_FAST32_TYPE "int"
+#define INT_FAST64_TYPE "long long int"
 
 #define UINT_FAST8_TYPE "unsigned char"
-#define UINT_FAST16_TYPE "unsigned int"
+#define UINT_FAST16_TYPE "short unsigned int"
 #define UINT_FAST32_TYPE "unsigned int"
 #define UINT_FAST64_TYPE "long long unsigned int"
 
diff --git a/gcc/config/i386/djgpp.c b/gcc/config/i386/djgpp.c
new file mode 100644
index 000000000..be1b723ba
--- /dev/null
+++ b/gcc/config/i386/djgpp.c
@@ -0,0 +1,62 @@
+/* Subroutines for DJGPP.
+   Contributed by Andris Pavenis <andris.pavenis@iki.fi>
+   Copyright (C) 2013 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "output.h"
+#include "tree.h"
+#include "flags.h"
+#include "tm_p.h"
+#include "diagnostic-core.h"
+#include "hashtab.h"
+#include "langhooks.h"
+#include "ggc.h"
+#include "target.h"
+#include "except.h"
+#include "lto-streamer.h"
+
+void
+i386_djgpp_asm_named_section(const char *name, unsigned int flags,
+			     tree decl)
+{
+  char flagchars[8], *f = flagchars;
+
+(void)decl; /* silence warning. */
+
+  if (flags & SECTION_WRITE)
+    *f++ = 'w';
+  if (flags & SECTION_CODE)
+    *f++ = 'x';
+
+  /* LTO sections need 1-byte alignment to avoid confusing the
+     zlib decompression algorithm with trailing zero pad bytes.  */
+  if (strncmp (name, LTO_SECTION_NAME_PREFIX,
+			strlen (LTO_SECTION_NAME_PREFIX)) == 0)
+    *f++ = '0';
+
+  *f++ = '\0';
+
+  fprintf (asm_out_file, "\t.section\t%s,\"%s\"\n", name, flagchars);
+}
diff --git a/gcc/config/i386/djgpp.h b/gcc/config/i386/djgpp.h
index 05f9dfda7..6e0de0150 100644
--- a/gcc/config/i386/djgpp.h
+++ b/gcc/config/i386/djgpp.h
@@ -17,12 +17,27 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#define DBX_DEBUGGING_INFO 1
+#define SDB_DEBUGGING_INFO 1
+
 /* Support generation of DWARF2 debugging info.  */
 #define DWARF2_DEBUGGING_INFO 1
 
+/* Use DWARF2 debugging info by default: comment out following  */
+/* 2 lines to default to COFF debugging info  */
+#undef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+
 /* Don't assume anything about the header files.  */
 #define NO_IMPLICIT_EXTERN_C
 
+/* If defined, a C expression whose value is a string containing the
+   assembler operation to identify the following data as
+   uninitialized global data.  If not defined, and neither
+   `ASM_OUTPUT_BSS' nor `ASM_OUTPUT_ALIGNED_BSS' are defined,
+   uninitialized global data will be output in the data section if
+   `-fno-common' is passed, otherwise `ASM_OUTPUT_COMMON' will be
+   used.  */
 #undef BSS_SECTION_ASM_OP
 #define BSS_SECTION_ASM_OP "\t.section\t.bss"
 
@@ -39,55 +54,26 @@ along with GCC; see the file COPYING3.  If not see
 #undef TEXT_SECTION_ASM_OP
 #define TEXT_SECTION_ASM_OP "\t.section .text"
 
-/* Define standard DJGPP installation paths.  */
-/* We override default /usr or /usr/local part with /dev/env/DJDIR which */
-/* points to actual DJGPP installation directory.  */
-
-/* Search for as.exe and ld.exe in DJGPP's binary directory.  */ 
-#undef MD_EXEC_PREFIX
-#define MD_EXEC_PREFIX "/dev/env/DJDIR/bin/"
-
-/* Standard DJGPP library and startup files */
-#undef MD_STARTFILE_PREFIX
-#define MD_STARTFILE_PREFIX "/dev/env/DJDIR/lib/"
-
-/* Correctly handle absolute filename detection in cp/xref.c */
-#define FILE_NAME_ABSOLUTE_P(NAME) \
-        (((NAME)[0] == '/') || ((NAME)[0] == '\\') || \
-        (((NAME)[0] >= 'A') && ((NAME)[0] <= 'z') && ((NAME)[1] == ':')))
-
 #define TARGET_OS_CPP_BUILTINS()		\
   do						\
     {						\
+        if (!flag_iso)                          \
+	   builtin_define_with_int_value ("DJGPP",2);  \
+	builtin_define_with_int_value ("__DJGPP",2);   \
+	builtin_define_with_int_value ("__DJGPP__",2); \
 	builtin_define_std ("MSDOS");		\
 	builtin_define_std ("GO32");		\
+	builtin_define_std ("unix");		\
 	builtin_assert ("system=msdos");	\
     }						\
   while (0)
 
 /* Include <sys/version.h> so __DJGPP__ and __DJGPP_MINOR__ are defined.  */
 #undef CPP_SPEC
-#define CPP_SPEC "-remap %{posix:-D_POSIX_SOURCE} \
-  -imacros %s../include/sys/version.h"
-
-/* We need to override link_command_spec in gcc.c so support -Tdjgpp.djl.
-   This cannot be done in LINK_SPECS as that LINK_SPECS is processed
-   before library search directories are known by the linker.
-   This avoids problems when specs file is not available. An alternate way,
-   suggested by Robert Hoehne, is to use SUBTARGET_EXTRA_SPECS instead.
-*/ 
-
-#undef LINK_COMMAND_SPEC
-#define LINK_COMMAND_SPEC \
-"%{!fsyntax-only: \
-%{!c:%{!M:%{!MM:%{!E:%{!S:%(linker) %l %X %{o*} %{e*} %{N} %{n} \
-\t%{r} %{s} %{t} %{u*} %{z} %{Z}\
-\t%{!nostdlib:%{!nostartfiles:%S}}\
-\t%{static:} %{L*} %D %o\
-\t%{!nostdlib:%{!nodefaultlibs:%G %L %G}}\
-\t%{!nostdlib:%{!nostartfiles:%E}}\
-\t-Tdjgpp.djl %{T*}}}}}}}\n\
-%{!c:%{!M:%{!MM:%{!E:%{!S:stubify %{v} %{o*:%*} %{!o*:a.out} }}}}}"
+#define CPP_SPEC "-remap %{posix:-D_POSIX_SOURCE}"
+
+#undef POST_LINK_SPEC
+#define POST_LINK_SPEC "stubify %{v} %{o*:%*} %{!o*:a.out}"
 
 /* Always just link in 'libc.a'.  */
 #undef LIB_SPEC
@@ -97,12 +83,8 @@ along with GCC; see the file COPYING3.  If not see
 #undef STARTFILE_SPEC
 #define STARTFILE_SPEC "%{pg:gcrt0.o%s}%{!pg:crt0.o%s}"
 
-/* Make sure that gcc will not look for .h files in /usr/local/include 
-   unless user explicitly requests it.  */
-#undef LOCAL_INCLUDE_DIR
-
 /* Switch into a generic section.  */
-#define TARGET_ASM_NAMED_SECTION  default_coff_asm_named_section
+#define TARGET_ASM_NAMED_SECTION  i386_djgpp_asm_named_section
 
 /* This is how to output an assembler line
    that says to advance the location counter
@@ -117,12 +99,18 @@ along with GCC; see the file COPYING3.  If not see
 #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
   asm_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))
 
-/* This is how to tell assembler that a symbol is weak  */ 
+/* This is how to tell assembler that a symbol is weak  */
 #undef ASM_WEAKEN_LABEL
 #define ASM_WEAKEN_LABEL(FILE,NAME) \
   do { fputs ("\t.weak\t", FILE); assemble_name (FILE, NAME); \
        fputc ('\n', FILE); } while (0)
 
+#undef ASM_DECLARE_FUNCTION_NAME
+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)                     \
+  do {                                                                  \
+    ASM_OUTPUT_FUNCTION_LABEL (FILE, NAME, DECL);                       \
+  } while (0)
+
 /* djgpp automatically calls its own version of __main, so don't define one
    in libgcc, nor call one in main().  */
 #define HAS_INIT_SECTION
@@ -144,21 +132,43 @@ along with GCC; see the file COPYING3.  If not see
 #undef PTRDIFF_TYPE
 #define PTRDIFF_TYPE "int"
 
-/* Used to be defined in xm-djgpp.h, but moved here for cross-compilers.  */
-#define LIBSTDCXX "stdcxx"
-
-/* Warn that -mbnu210 is now obsolete.  */
-#undef  SUBTARGET_OVERRIDE_OPTIONS
-#define SUBTARGET_OVERRIDE_OPTIONS \
-do \
-  { \
-    if (TARGET_BNU210) \
-      {	\
-        warning (0, "-mbnu210 is ignored (option is obsolete)"); \
-      }	\
-  } \
-while (0)
-
 /* Support for C++ templates.  */
 #undef MAKE_DECL_ONE_ONLY
 #define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)
+
+#undef DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(n) svr4_dbx_register_map[n]
+
+/* Default to pcc-struct-return.  */
+#define DEFAULT_PCC_STRUCT_RETURN 1
+
+/* Put all *tf routines in libgcc.  */
+#undef LIBGCC2_HAS_TF_MODE
+#define LIBGCC2_HAS_TF_MODE 1
+#define LIBGCC2_TF_CEXT q
+#define TF_SIZE 113
+
+/* Ignore (with warning) -fPIC for DJGPP */
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS                                      \
+    do {                                                                \
+        if (flag_pic)                                                   \
+        {                                                               \
+            fnotice(stdout, "-f%s ignored (not supported for DJGPP)\n", \
+                (flag_pic > 1) ? "PIC" : "pic");                        \
+            flag_pic = 0;                                               \
+        }                                                               \
+                                                                        \
+        /* Don't emit DWARF3/4 unless specifically selected. */         \
+        /* DWARF3/4 currently does not work for DJGPP.  */              \
+        if (!global_options_set.x_dwarf_version)                        \
+            dwarf_version = 2;                                          \
+                                                                        \
+        }                                                               \
+    while (0)
+
+/* Function protypes for gcc/i486/djgpp.c */
+
+void
+i386_djgpp_asm_named_section(const char *name, unsigned int flags,
+			     tree decl);
diff --git a/gcc/config/i386/djgpp.opt b/gcc/config/i386/djgpp.opt
index 8213fc3be..05d77960a 100644
--- a/gcc/config/i386/djgpp.opt
+++ b/gcc/config/i386/djgpp.opt
@@ -18,11 +18,5 @@
 ; along with GCC; see the file COPYING3.  If not see
 ; <http://www.gnu.org/licenses/>.
 
-;; -mbnu210 is now ignored and obsolete.  It was used to enable support for
-;; weak symbols, and .gnu.linkonce support.
-mbnu210
-Target Var(TARGET_BNU210)
-Ignored (obsolete)
-
 posix
 Driver
diff --git a/gcc/config/i386/nmalloc/cokusmt.c b/gcc/config/i386/nmalloc/cokusmt.c
new file mode 100644
index 000000000..d9685b756
--- /dev/null
+++ b/gcc/config/i386/nmalloc/cokusmt.c
@@ -0,0 +1,185 @@
+/* FILE cokusmt.c */
+/* This is a miniscule cleanup of the source downloaded from:  */
+/*       http://www.math.keio.ac.jp/~matumoto/ver980409.html   */
+
+/* This is the "Mersenne Twister" random number generator MT19937,
+// which generates pseudorandom integers uniformly distributed in
+// 0..(2^32 - 1) starting from any odd seed in 0..(2^32 - 1).  This
+// version is a recode by Shawn Cokus (Cokus@math.washington.edu) on
+// March 8, 1998 of a version by Takuji Nishimura (who had suggestions
+// from Topher Cooper and Marc Rieffel in July-August 1997).
+//
+// Effectiveness of the recoding (on Goedel2.math.washington.edu, a
+// DEC Alpha running OSF/1) using GCC -O3 as a compiler: before
+// recoding: 51.6 sec. to generate 300 million random numbers; after
+// recoding: 24.0 sec. for the same (i.e., 46.5% of original time),
+// so speed is now about 12.5 million random number generations per
+// second on this machine.
+//
+// According to URL <http://www.math.keio.ac.jp/~matumoto/emt.html>
+// (and paraphrasing a bit in places), the Mersenne Twister is
+// "designed with consideration of the flaws of various existing
+// generators," has a period of 2^19937 - 1, gives a sequence that
+// is 623-dimensionally equidistributed, and "has passed many
+// stringent tests, including the die-hard test of G. Marsaglia and
+// the load test of P. Hellekalek and S. Wegenkittl."  It is efficient
+// in memory usage (typically using 2506 to 5012 bytes of static data,
+// depending on data type sizes, and the code is quite short as well).
+// It generates random numbers in batches of 624 at a time, so the
+// caching and pipelining of modern systems is exploited. It is also
+// divide- and mod-free.
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public License
+// as published by the Free Software Foundation (either version 2 of
+// the License or, at your option, any later version).  This library
+// is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY, without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General
+// Public License for more details.  You should have received a copy
+// of the GNU Library General Public License along with this library;
+// if not, write to the Free Software Foundation, Inc., 59 Temple
+// Place, Suite 330, Boston, MA 02111-1307, USA.
+//
+// The code as Shawn received it included the following notice:
+//
+//  Copyright (C) 1997 Makoto Matsumoto and Takuji Nishimura.  When
+//  you use this, send an e-mail to <matumoto@math.keio.ac.jp> with
+//  an appropriate reference to your work.
+//
+// It would be nice to CC: <Cokus@math.washington.edu> when you write.
+*/
+
+/* uint32 must be an unsigned integer type capable of holding at least
+// 32 bits; exactly 32 should be fastest, but 64 is better on an Alpha
+// with GCC at -O3 optimization so try your options and see what's
+// best for you.
+*/
+
+#include "cokusmt.h"
+
+typedef unsigned long uint32;
+
+
+#define N             (624)               /* length of state vector */
+#define M             (397)                 /*   a period parameter */
+#define K             (0x9908B0DFU)         /*     a magic constant */
+#define hiBit(u)      ((u) & 0x80000000U)   /* mask all but highest */
+                                            /*            bit of u  */
+#define loBit(u)      ((u) & 0x00000001U)   /* mask all but lowest  */
+                                            /*            bit of u  */
+#define loBits(u)     ((u) & 0x7FFFFFFFU)   /* mask off the highest */
+                                            /*            bit of u  */
+#define mixBits(u, v) (hiBit(u) | loBits(v))  /* move hi bit of u   */
+                                              /*   to hi bit of v */
+
+static uint32 state[N+1]; /* state vector+1 to not violate ANSI C */
+static uint32 *next;      /* next random value computed from here */
+static int     left = -1; /* can *next++ this many times before */
+                          /* reloading */
+
+
+/* We initialize state[0..(N-1)] via the generator
+//
+//   x_new = (69069 * x_old) mod 2^32
+//
+// from Line 15 of Table 1, p. 106, Sec. 3.3.4 of Knuth's
+// _The Art of Computer Programming_, Volume 2, 3rd ed.
+//
+// Notes (SJC): I do not know what the initial state requirements
+// of the Mersenne Twister are, but it seems this seeding generator
+// could be better.  It achieves the maximum period for its modulus
+// (2^30) iff x_initial is odd (p. 20-21, Sec. 3.2.1.2, Knuth); if
+// x_initial can be even, you have sequences like 0, 0, 0, ...;
+// 2^31, 2^31, 2^31, ...; 2^30, 2^30, 2^30, ...; 2^29, 2^29 + 2^31,
+// 2^29, 2^29 + 2^31, ..., etc. so I force seed to be odd below.
+//
+// Even if x_initial is odd, if x_initial is 1 mod 4 then
+//
+//            low bit of x is always 1,
+//    next-to-low bit of x is always 0,
+//   2nd-from-low bit of x alternates   ... 0 1 0 1 0 1 0 1 ... ,
+//   3rd-from-low bit of x 4-cycles     ... 0 1 1 0 0 1 1 0 ... ,
+//   4th-from-low bit of x has 8-cycle  ... 0 0 0 1 1 1 1 0 ... ,
+//    ...
+//
+// and if x_initial is 3 mod 4 then
+//
+//            low bit of x is always 1,
+//    next-to-low bit of x is always 1,
+//   2nd-from-low bit of x alternates   ... 0 1 0 1 0 1 0 1 ... ,
+//   3rd-from-low bit of x 4-cycles     ... 0 0 1 1 0 0 1 1 ... ,
+//   4th-from-low bit of x has 8-cycle  ... 0 0 1 1 1 1 0 0 ... ,
+//    ...
+//
+// The generator's potency (min. s>=0 with (69069-1)^s = 0
+// mod 2^32) is 16, which seems to be alright by p. 25, Sec.
+// 3.2.1.3 of Knuth.  It also does well in the dimension 2..5
+// spectral tests, but it could be better in dimension 6
+// (Line 15, Table 1, p. 106, Sec. 3.3.4, Knuth).
+//
+// Note that the random number user does not see the values
+// generated here directly since reloadMT() will always munge
+// them first, so maybe none of all of this matters.  In fact,
+// the seed values made here could even be extra-special
+// desirable if the Mersenne Twister theory says so-- that's
+// why the only change I made is to restrict to odd seeds.
+*/
+void seedMT(uint32 seed)
+{
+   register uint32  x = (seed | 1U) & 0xFFFFFFFFU,
+                   *s = state;
+   register int     j;
+
+   for (left = 0, *s++ = x, j = N;
+        --j;
+        *s++ = (x *= 69069U) & 0xFFFFFFFFU);
+} /* seedMT */
+
+
+static uint32 reloadMT(void)
+{
+   register  uint32
+            *p0    = state,
+            *p2    = state + 2,
+            *pM    = state + M,
+            s0,
+            s1;
+   register int    j;
+
+   if (left < -1)  seedMT(4357U);        /* Autoseed on first use */
+
+   left = N - 1; next = state + 1;
+   for (s0 = state[0], s1 = state[1], j = N - M + 1;
+             --j;
+             s0 = s1, s1 = *p2++)
+      *p0++ = *pM++ ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);
+
+   for (pM = state, j = M;
+             --j;
+             s0 = s1, s1 = *p2++)
+      *p0++ = *pM++ ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);
+
+   s1 = state[0];
+   *p0 = *pM ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);
+   s1 ^= (s1 >> 11);
+   s1 ^= (s1 <<  7) & 0x9D2C5680U;
+   s1 ^= (s1 << 15) & 0xEFC60000U;
+   return (s1 ^ (s1 >> 18));
+} /* reloadMT */
+
+
+uint32 randomMT(void)
+{
+   uint32 y;
+
+   if (--left < 0)
+      return(reloadMT());
+
+   y  = *next++;
+   y ^= (y >> 11);
+   y ^= (y <<  7) & 0x9D2C5680U;
+   y ^= (y << 15) & 0xEFC60000U;
+   return (y ^ (y >> 18));
+} /* randomMT */
+
diff --git a/gcc/config/i386/nmalloc/cokusmt.h b/gcc/config/i386/nmalloc/cokusmt.h
new file mode 100644
index 000000000..c6df7d70c
--- /dev/null
+++ b/gcc/config/i386/nmalloc/cokusmt.h
@@ -0,0 +1,17 @@
+/* file cokusMT.h */
+
+#ifndef cokus_h
+#define cokus_h
+
+#include <limits.h>
+
+#if ULONG_MAX != 4294967295UL
+   #error System long word size not suitable for cokusMT
+#endif
+
+#define ranMTMAX ULONG_MAX
+
+void seedMT(unsigned long seed);
+unsigned long randomMT(void);
+
+#endif /* cokus_h */
diff --git a/gcc/config/i386/nmalloc/evilalg2.c b/gcc/config/i386/nmalloc/evilalg2.c
new file mode 100644
index 000000000..18b740a8e
--- /dev/null
+++ b/gcc/config/i386/nmalloc/evilalg2.c
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+int main(void)
+{
+   char    *p;
+   unsigned int i;
+
+   puts("Testing calloc(i, i).  Be patient");
+   for (i = 65535; i > 0; i--) {
+      if ((p = calloc(i,i))) {
+         printf("\n%d appears to be the largest succesful integer\n",
+                   i);
+         break;
+      }
+      if (0 == (i % 500)) {
+         if (0 == (i % 5000)) printf(" %8d\n", i);
+         else printf("\r%8d", i);
+         fflush(stdout);
+      }
+   }
+   return 0;
+}
diff --git a/gcc/config/i386/nmalloc/evilalgo.c b/gcc/config/i386/nmalloc/evilalgo.c
new file mode 100644
index 000000000..107c8c9ce
--- /dev/null
+++ b/gcc/config/i386/nmalloc/evilalgo.c
@@ -0,0 +1,35 @@
+/* From djgpp mail list - an evil algorithm */
+/* This shows up the difference between DJGPP2.03 malloc and
+   nmalloc, both in speed and in efficiency of memory use.
+   Snaffled/cleaned up for testing use by C.B. Falconer.
+
+   To use the new malloc, simply link it with the object module.
+*/
+#include <stdio.h>
+#include <stdlib.h>
+
+typedef struct {
+   char af[10];
+   char name[10];
+} record;
+
+record **dt, *d;
+
+int main(int argc, char ** argv)
+{
+   unsigned long n = 1000;  /* was 200000L */
+   unsigned int  count;
+   void         *v;
+
+   if (argc > 1) n = strtoul(argv[1], NULL, 10);
+
+   dt = NULL;
+   for (count = 0; count < n; count++){
+      if ((v = realloc(dt, (count + 1) * sizeof *dt))) dt = v;
+      else break;
+      if (!(d = dt[count] = calloc(10, sizeof *d))) break;
+      if (!(count & 0xfff)) putc('*', stderr);
+   }
+   printf("\ncount=%d\n", count);
+   return(0);
+} /* evilalgo */
diff --git a/gcc/config/i386/nmalloc/fakesbrk.h b/gcc/config/i386/nmalloc/fakesbrk.h
new file mode 100644
index 000000000..50bae6aa7
--- /dev/null
+++ b/gcc/config/i386/nmalloc/fakesbrk.h
@@ -0,0 +1 @@
+void *fakesbrk(int delta);
diff --git a/gcc/config/i386/nmalloc/makefile b/gcc/config/i386/nmalloc/makefile
new file mode 100644
index 000000000..e476dae2b
--- /dev/null
+++ b/gcc/config/i386/nmalloc/makefile
@@ -0,0 +1,88 @@
+# nmalloc makefile
+# This makefile was tested under W98 and DJGPP 2.03/gcc 2.953
+# and is a mess.  Feel free to create a better one.
+
+objects = nmalloc.o cokusmt.o
+sources = tnmalloc.c nmalloc.c nmalloc.h nmalloc.lst \
+          cokusmt.c cokusmt.h fakesbrk.h sysquery.h \
+          malldbg.c malldbg.h tmalldbg.c \
+	  makefile evilalgo.c nmalloc.txh
+utils   = xref.exe
+
+CFLAGS  = -W -Wall -gstabs+ -Dinline= 
+
+tnmalloc.exe : $(objects) tnmalloc.o
+	gcc -o tnmalloc.exe tnmalloc.o $(objects)
+	
+# this shows up all use of magic numbers	
+nmalloc.xrf : nmalloc.lst nmalloc.c nmalloc.h sysquery.h \
+              malldbg.h malldbg.c tmalldbg.c tnmalloc.c
+	xref -cfn8 nmalloc.lst nmalloc.xrf
+
+# profileable version. 50% slowdown
+mallocp.o   : nmalloc.c sysquery.h
+	gcc -W -Wall -pg -gstabs+ -O2 -o mallocp.o \
+	    -c nmalloc.c
+
+# production version	
+malloc.o    : nmalloc.c sysquery.h
+	gcc -W -Wall -gstabs+ -O2 -o malloc.o \
+	    -c nmalloc.c
+	    
+# production debug system
+malldbg.o   : malldbg.c sysquery.h malldbg.h
+	gcc -W -Wall -O1 -gstabs+ -c malldbg.c
+	
+# testing production debug version
+tmalldbg.o  : tmalldbg.c sysquery.h malldbg.h
+	gcc -W -Wall -gstabs+ -O1 -c tmalldbg.c
+	
+# testing production debug version
+tmalldbg.exe : tmalldbg.o malldbg.o malloc.o
+	gcc -o tmalldbg.exe tmalldbg.o malldbg.o malloc.o
+
+# profilable	
+tmallocp.o : tnmalloc.c nmalloc.h fakesbrk.h sysquery.h
+	gcc -W -Wall -pg -gstabs+ -O2 -o tmallocp.o \
+	    -c tnmalloc.c
+	
+# Use this to profile malloc under various tests. 50% slowdown
+tmallocp.exe : tmallocp.o cokusmt.o mallocp.o
+	gcc -pg -o tmallocp.exe tmallocp.o cokusmt.o mallocp.o
+
+tnmalloc.o  : tnmalloc.c cokusmt.h nmalloc.h fakesbrk.h sysquery.h
+cokusmt.o   : cokusmt.c cokusmt.h
+evilalgo.o  : evilalgo.c malloc.o
+
+# Development debug version
+nmalloc.o   : nmalloc.c nmalloc.h fakesbrk.h sysquery.h
+	gcc -W -Wall -DNEWMALLDBG -gstabs+ -O1 -c nmalloc.c
+
+# pack it all up for shipping
+nmalloc.zip   : $(sources) $(utils) readme.txt
+	zip -o -u nmalloc.zip $(sources) $(utils) readme.txt
+	
+#create a profile
+profile	: tmallocp.exe
+	tmallocp 5 100000 quiet > profile
+	gprof -b tmallocp.exe >> profile
+
+.PHONY : clean zip tnmalloc tmallocp tmalldbg all xrf
+
+clean :
+	rm -f tnmalloc.exe $(objects) tnmalloc.o malloc.o \
+	      mallocp.o nmalloc.xrf tmallocp.exe tmallocp.o \
+	      gmon.out evilalgo.o
+
+zip : nmalloc.zip
+
+tnmalloc : tnmalloc.exe
+
+tmallocp : tmallocp.exe
+
+tmalldbg : tmalldbg.exe
+
+# elide "zip" from this, to avoid destroying a backup
+all : tnmalloc malloc.o mallocp.o tmallocp tmalldbg
+
+xrf : nmalloc.xrf
diff --git a/gcc/config/i386/nmalloc/malldbg.c b/gcc/config/i386/nmalloc/malldbg.c
new file mode 100644
index 000000000..edf6cbf1a
--- /dev/null
+++ b/gcc/config/i386/nmalloc/malldbg.c
@@ -0,0 +1,429 @@
+/* -------- malldbg.c --------- */
+
+/* Copyright (c) 2003 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@worldnet.att.net>
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <signal.h>   /* raise, SIGABRT */
+#include "malldbg.h"  /* and sysquery.h */
+
+/* This is to be used in conjunction with a version of
+   nmalloc.c compiled with:
+
+     gcc -DNDEBUG -o malloc.o -c nmalloc.c
+*/
+
+static int   dbglevel;
+static FILE *dumpfile;
+static int   initialized;
+
+/* array of hook function pointers, for cleaner interface */
+/* This is purely a record of values set by sethook()     */
+static M_HOOKFN hookptr[HKCOUNT];
+
+/* Number of free lists in system */
+#define NFLISTS ((int)(CHAR_BIT * sizeof(size_t)))
+
+/* Loaded by initsysinfo() to access nmalloc guts */
+static struct _sysquery sysinfo;
+
+/* freehdrsp is pointer to array[NFLISTS] of void* */
+/* These are the headers of the actual free lists  */
+/* also loaded by initsysinfo() call               */
+static void          *(*freehdrsp)[NFLISTS];
+
+#define NONE          sysinfo.nilp
+#define lastsbrk      freehdrs[0]
+#define memblockp     void*
+typedef unsigned int  ulong;
+typedef unsigned char byte;
+
+/* conversion and access macros */
+#define DATAOFFSET sysinfo.data
+
+#define MEMBLKp(p) (memblockp)((byte*)(p) - DATAOFFSET)
+#define PTR(m)     (void*)((byte*)(m) + DATAOFFSET)
+
+/* This accesses the list of discrete memory chains     */
+/* which are created when sbrk returns unexpected value */
+#define SBRKBGN    ((void **)(sysinfo.anchors))
+
+/* field access macros (AFTER sysinfo loaded)    */
+/* Examples - replace "m->prv" by "fld(m, prv)"  */
+/*            replace "m->sz"  by "szof(m)"      */
+/* where field is prvf, nxtf, prv, nxt           */
+#define fld(m, field)   *((void**)((char*)m + sysinfo.field))
+#define szof(m)         *(ulong*)((char*)m + sysinfo.sz)
+#define freehdrs        (*freehdrsp)
+
+/* ----------------- */
+
+/* Set up the access to the nmalloc module */
+static void initsysinfo(void)
+{
+   sysinfo   = _sysmalloc();
+   freehdrsp = (void*)((byte*)(sysinfo.nilp)-sizeof(void*));
+   if (!dumpfile) dumpfile = stderr;
+   initialized = 1;
+} /* initsysinfo */
+
+/* 1------------------1 */
+
+/* m is the allocated ptr treated by MEMBLKp    */
+/* Fouls if sysinfo has not been initialized    */
+/* Display info about a particular memory block */
+static void xshowblock(FILE *f, void *m, const char *id)
+{
+   if (NULL == f) return;
+   if (m) {
+      fprintf(f, " %s %p", id, m);
+      fprintf(f, " sz=%u nxt=%p prv=%p nxtf=",
+             szof(m), fld(m, nxt), fld(m, prv));
+      if (fld(m, nxtf)) {
+         if (NONE == fld(m, nxtf))
+            fprintf(f, "NONE prvf=");
+         else
+            fprintf(f, "%p prvf=", fld(m, nxtf));
+         if (NONE == fld(m, prvf))
+            fprintf(f, "NONE");
+         else
+            fprintf(f, "%p", fld(m, prvf));
+      }
+      else fprintf(f, "0");
+   }
+   else
+      fprintf(f, " %s NULL", id);
+   fflush(f);  /* to coexist with internal debuggery */
+} /* xshowblock */
+
+/* 1------------------1 */
+
+/* dump the entire free chain group             */
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+static void xdumpfree(FILE *f)
+{
+   int       i;
+   memblockp m;
+   ulong     totfree;
+
+   if (NULL == f) return;
+   totfree = 0;
+   for (i = 0; i < NFLISTS; i++) {
+      if ((m = freehdrs[i])) {
+         fprintf(f, "\n%2d: ", i);
+         do {
+            fprintf(f, "%p(%u)->", m, szof(m));
+            totfree += szof(m);
+            m = fld(m, nxtf);
+         } while (m && (NONE != m));
+         fprintf(f, "0");
+         m = freehdrs[i];
+         while (m && (NONE !=m )) {
+            xshowblock(f, m, "\n     ");
+            m = fld(m, nxtf);
+         }
+      }
+   }
+   fprintf(f, "\nTotal Free = %u\n", totfree);
+   fflush(f);  /* to coexist with internal debuggery */
+} /* xdumpfree */
+
+/* ----------------- */
+
+/* show the content of a block, flag it as BAD */
+static void showbad(FILE *f, void * m)
+{
+   void *n;
+
+   if ((dbglevel >= 3) && (NULL == f)) f = dumpfile;
+   if (f) {
+      n = fld(m, nxt);
+      xshowblock(f, m, "\n BAD?:");
+      xshowblock(f, n, "\n BAD?:");
+      putc('\n', f);
+      fflush(f);
+   }
+} /* showbad */
+
+/* ----------------- */
+
+/* scans the complete malloc structures to collect
+   info.  If f is non-NULL outputs a detailed listing
+   returns NULL unless a bad block is found.
+   Any bad blocks are displayed on dumpfile */
+static void * mallocscan(FILE *f, struct mallinfo *mi)
+{
+   unsigned long totalmem, totalfree, blks, freeblks;
+   void *m, *n, *badblk;
+   int   i, valid;
+
+   valid = 1; badblk = NULL;
+   if (!initialized) initsysinfo();
+   mi->smblks = mi->hblks = mi->hblkhd = mi->usmblks = 0;
+   mi->fsmblks = mi->keepcost = 0;
+
+   /* this initialization accounts for the fact that
+      the lastsbrk field will be counted as used */
+   blks = 0; totalmem = 0;
+   mi->hblkhd = totalfree = szof(freehdrs[0]);
+   freeblks = 1;
+
+   for (i = 0; (m = SBRKBGN[i]); i++) {
+      if (f) fprintf(f, "\n\nGroup %d:", i);
+      do {
+         n = fld(m, nxt);
+         if (f) xshowblock(f, m, "\n ");
+         totalmem += szof(m);
+         blks++;
+         if (dbglevel && n)
+            if (m != fld(n, prv)) {
+               valid = 0; badblk = m;
+               showbad(dumpfile, m);
+               if (dbglevel >= 3) {
+                  fflush(dumpfile);
+                  raise(SIGABRT);
+               }
+            }
+         if (fld(m, nxtf)) { /* a free block */
+            freeblks++;
+            totalfree += szof(m);
+         }
+      } while ((m = n));
+   }
+   if (f) fprintf(f, "\n");
+
+   /* return the collected info in struct mi */
+   mi->arena    = totalmem;
+   mi->ordblks  = blks;
+   mi->hblks    = freeblks;
+   mi->uordblks = totalmem - totalfree
+                       - DATAOFFSET * (blks - freeblks);
+   mi->fordblks = totalfree;
+   mi->keepcost = DATAOFFSET * blks;
+   return badblk;
+} /* mallocscan */
+
+/* ----------------- */
+
+/* Return summary details about the arena */
+struct mallinfo mallinfo(void)
+{
+   struct mallinfo mi;
+   int    valid;
+
+   if (!initialized) initsysinfo();
+   valid = (NULL == mallocscan(NULL, &mi));
+   return mi;
+} /* mallinfo */
+
+/* ----------------- */
+
+/* Verify the integrity of the arena */
+int malloc_verify(void)
+{
+   struct mallinfo mi;
+   void  *badblk;
+
+   if (!initialized) initsysinfo();
+   badblk = mallocscan(NULL, &mi);
+   if (badblk) showbad(dumpfile, badblk);
+   return (NULL == badblk);
+} /* malloc_verify */
+
+/* ----------------- */
+
+/* dump a complete map of the arena */
+void mallocmap(void)
+{
+   struct mallinfo mi;
+   void  *badblk;
+
+   if (!initialized) initsysinfo();
+   fprintf(dumpfile, "\nmallocmap at level %d\n", dbglevel);
+   xdumpfree(dumpfile);
+   badblk = mallocscan(dumpfile, &mi);
+} /* mallocmap */
+
+/* ----------------- */
+
+/* Set the file on which to display results */
+FILE *malldbgdumpfile(FILE *fp)
+{
+   FILE *tmp;
+
+   if (!initialized) initsysinfo();
+   tmp = dumpfile;
+   if (fp) dumpfile = fp;
+   else dumpfile = stderr;
+   return tmp;
+} /* malldbgdumpfile */
+
+/* ----------------- */
+
+/* The following three functions are called by hooks */
+
+/* Do malloc_verify function via hook ptr */
+/* No output unless a bad block found     */
+/* This is suitable for setting hooks.    */
+static void checkarena(size_t sz, void *bk)
+{
+   struct mallinfo mi;
+   void  *badblk;
+
+   if (bk) sz = sz; /* anti warn */
+   if (dbglevel > 1) {  /* else ignore, safety */
+      if ((badblk = mallocscan(NULL, &mi)))
+         showbad(dumpfile, badblk);
+   }
+} /* checkarena */
+
+/* ----------------- */
+
+static void freenullalert(size_t sz, void *bk)
+{
+   if (bk) sz = sz; /* anti warn */
+   fputs("\n***Freeing NULL\n", dumpfile);
+} /* freenullalert */
+
+/* ----------------- */
+
+static void mallocfailalert(size_t sz, void *bk)
+{
+   if (bk)
+      fprintf(dumpfile,
+              "\n***realloc failed expanding %p to %lu bytes\n",
+              bk, (unsigned long)sz);
+   else
+      fprintf(dumpfile,
+              "\n***malloc failed allocating %lu bytes\n",
+              (unsigned long)sz);
+} /* mallocfailalert */
+
+/* ----------------- */
+
+/* Check that no hooks are presently in use */
+/* uses the locally stored copy of hooks so */
+/* mistakes are possible.  Maybe sysinfo    */
+/* should contain a pointer to the real tbl */
+/* Our own hooks are allowable              */
+static int somehookinuse(void)
+{
+   enum m_hook_kind hk;
+
+   for (hk = malloc_HK; hk < HKCOUNT; hk++) {
+      /* structured for ease of modification */
+      if (NULL            == hookptr[hk]) continue;
+      if (checkarena      == hookptr[hk]) continue;
+      if (freenullalert   == hookptr[hk]) continue;
+      if (mallocfailalert == hookptr[hk]) continue;
+      return 1;
+   }
+   return 0;
+} /* somehookinuse */
+
+/* ----------------- */
+
+/* sethook, bypassing validity checks */
+static M_HOOKFN sethook(enum m_hook_kind which,
+                        M_HOOKFN newhook)
+{
+   M_HOOKFN tmp;
+
+   hookptr[which] = newhook; /* keep local record */
+   tmp = (*sysinfo.hookset)(which, newhook);
+   return tmp;
+} /* sethook */
+
+/* ----------------- */
+
+M_HOOKFN mallsethook(enum m_hook_kind which,
+                     M_HOOKFN newhook)
+{
+   if (!initialized) initsysinfo();
+   if (which >= HKCOUNT) return NULL; /* validity check */
+   if (dbglevel != 1) return NULL;    /* in use, refuse */
+
+   return sethook(which, newhook);
+} /* mallsethook */
+
+/* ----------------- */
+
+static void releaseallhooks(void)
+{
+   enum m_hook_kind hk;
+
+   for (hk = malloc_HK; hk < HKCOUNT; hk++)
+      sethook(hk, NULL);
+} /* freeallhooks */
+
+/* ----------------- */
+
+static inline void setfreenullhook(void)
+{
+   sethook(free_null_HK, freenullalert);
+} /* setfreenullhook */
+
+/* ----------------- */
+
+static inline void setmallocfailhook(void)
+{
+   sethook(malloc_fail_HK, mallocfailalert);
+} /* setmallocfailhook */
+
+/* ----------------- */
+
+static inline void setverifyhooks(void)
+{
+   sethook(malloc_HK,  checkarena);
+   sethook(free_HK,    checkarena);
+   sethook(realloc_HK, checkarena);
+} /* setverifyhooks */
+
+/* ----------------- */
+
+/* level  action
+      0   Only passive checks
+      1   Passive checks, hook setting enabled
+      2   Checks on each alloc/realloc, no hooks allowed
+      3   Same, but aborts if fault found, signals malloc_fail
+      4   Same, but signals on free(NULL)
+
+   A level value outside 0..4 is rejected.
+   Returns current debug_level (before any change).
+*/
+int malloc_debug(int level)
+{
+   int oldlevel;
+
+   if (!initialized) initsysinfo();
+   oldlevel = dbglevel;
+   if ((level >= 0) && (level <= 4) && (level != oldlevel)) {
+      if ((oldlevel < 2) && (level >= 2)) {
+         if (somehookinuse()) { /* refuse */
+            fprintf(dumpfile, "\n***malldbglvl refused\n");
+            return oldlevel;
+         }
+      }
+      /* Either all hooks free or our own, or level < 2 */
+      /* The change is feasible, level is changed and valid */
+      dbglevel = level;
+      releaseallhooks();
+      switch (level) { /* falling through */
+case 4:  setfreenullhook();
+case 3:  setmallocfailhook();
+case 2:  setverifyhooks();
+default: break;
+      } /* switch (level) */
+   } /* valid level change */
+   return oldlevel;
+} /* malloc_debug */
+
+/* -------- malldbg.c ----------- */
diff --git a/gcc/config/i386/nmalloc/malldbg.h b/gcc/config/i386/nmalloc/malldbg.h
new file mode 100644
index 000000000..4bad8f425
--- /dev/null
+++ b/gcc/config/i386/nmalloc/malldbg.h
@@ -0,0 +1,50 @@
+/* -------- malldbg.h ----------- */
+
+/* Copyright (c) 2003 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@worldnet.att.net>
+*/
+
+#ifndef malldbg_h
+#define malldbg_h
+
+/* This is to be used in conjunction with a version of
+   nmalloc.c compiled with:
+
+     gcc -DNDEBUG -o malloc.o -c nmalloc.c
+
+   after which linking malldbg.o and malloc.o will
+   provide the usual malloc, free, realloc calls.
+   Both malloc.o and malldbg.o can be components
+   of the normal run time library.
+*/
+
+#include <stddef.h>
+#include "sysquery.h"
+
+struct mallinfo {
+   int arena;           /* Total space being managed */
+   int ordblks;         /* Count of allocated & free blocks */
+   int smblks;
+   int hblks;           /* Count of free blocks */
+   int hblkhd;          /* Size of the 'lastsbrk' block */
+   int usmblks;
+   int fsmblks;
+   int uordblks;        /* Heap space in use w/o overhead */
+   int fordblks;        /* Total space in free lists */
+   int keepcost;        /* Overhead in tracking storage */
+};
+
+struct mallinfo mallinfo(void);
+int             malloc_verify(void);
+int             malloc_debug(int level);
+void            mallocmap(void);
+FILE           *malldbgdumpfile(FILE *fp);
+M_HOOKFN        mallsethook(enum m_hook_kind which,
+                            M_HOOKFN newhook);
+
+#endif
+/* -------- malldbg.h ----------- */
diff --git a/gcc/config/i386/nmalloc/memalign.c b/gcc/config/i386/nmalloc/memalign.c
new file mode 100644
index 000000000..2f2364e94
--- /dev/null
+++ b/gcc/config/i386/nmalloc/memalign.c
@@ -0,0 +1,137 @@
+
+/* 1------------------1 */
+
+/* The remaining code is an attempt to graft on the
+   memalign function.  It can do with improvement.
+   The idea is to do this without disturbing the
+   already checked and debugged package.
+
+   In units of ALIGN (== 8 here) bytes.  The value of
+   DATAOFFSET depends on SAVEMEMORY, either 2 or 3.  The
+   following assumes SAVEMEMORY is set and DATAOFFSET = 2.
+
+   Initial malloc block (alignment > ALIGN):
+    ____________________________________________________
+   |          |            |              |             |
+   |          |            |              |             |
+   |DATAOFFSET|   size     |  xtra for    |             |
+   | control  |            | realignment  |             |
+   |__________|____________|______________|_____________|
+              ^
+              ^
+A: If this point is aligned, then we simply cut the assignment.
+   Immediate use of realloc will avoid any data movement.
+
+B: Worst case when this is 1 (DELTA) above an alignment point.
+   becomes (since alignment > ALIGN and thus
+                  alignment >= DATAOFFSET):
+    ____________________________________________________
+   |          |            |              |             |
+   |alignment |DATAOFFSET  |              |     0       |
+   | - DELTA  |   for      |    size      |  nothing    |
+   |to freespc| control    |              | needed BUT: |
+   |________ _|____________|______________|_____________|
+                           ^              ^
+                           ^              ^
+   Now this point is suitably aligned     ^
+    ALIGNMENT - DELTA >= DATAOFFSET       ^
+                                          ^
+   For the intermediate cases make sure this block to be moved
+   to free space is at least 3 units long.  Easiest is to set
+   the initial extra value so that this worst case is 3, not 0
+ ?  This makes the initial extra size alignment+4 ??
+
+C: The initial alignment point is 1 low.  (DELTA = -1)
+    ____________________________________________________
+   |          |            |              |             |
+   |    3     |            |              |             |
+   |control+1 |    2       |    size      |  xtra-3     |
+   |to freespc|  control   |              |to freespc   |
+   |__________|____________|______________|_____________|
+                           ^              ^
+                           ^              ^
+   This point is aligned --^     This goes to freespace
+
+D: The initial alignment point is 2 low.  (DELTA = -2)
+    ____________________________________________________
+   |          |            |              |             |
+   |          |            |              |             |
+   |          |    2       |    size      |             |
+   |          |  control   |              |to freespc   |
+   |__________|____________|______________|_____________|
+                           ^              ^
+                           ^              ^
+   This point is aligned --^     This goes to freespace
+
+   The minimum of 3 units to freespace is because 2 are
+   required for control, and without further space the
+   block is useless.  In fact it needs the further space
+   to implement the free block linking mechanism.
+*/
+
+/* 1------------------1 */
+
+/* Check alignment is a non-zero power of two <= 65536. */
+/* Return 0 if so, else non-zero                        */
+static inline int invalid(size_t alignment)
+{
+   if (alignment && (alignment <= 65536))
+      return (alignment & (alignment - 1));
+   else return 1;  /* 0 is invalid */
+} /* invalid */
+
+/* 1------------------1 */
+
+/* define the XTRA storage needed to assure chopping up feasible
+   and that chopped off storage is large enough to be usable.
+   XTRA is always a multiple of ALIGN.
+*/
+
+#define XTRA (alignment + 3 * ALIGN)
+
+/* 1------------------1 */
+
+/* return memory aligned so that the return value is a */
+/* multiple of alignment.  Otherwise similar to malloc */
+/* alignment MUST be a power of two, max 65536.        */
+void *nmemalign(size_t alignment, size_t size)
+{
+   memblockp m = NULL, m1;
+   void     *minit;
+   ulong     misalign;
+   size_t    szneed, sz = size; /* preserve arg for hooks */
+
+   /* compute the rounded up size needed */
+   if (!sz) sz++;     /* avoid any 0 space allocation */
+   szneed = roundup(sz);
+   DBGPRTM("memalign(%5lu) [%5lu] %5lu", sz, szneed, alignment);
+   DBGEOLN;
+
+   if (size < ((ulong)(INT_MAX - 65536)) &&
+       !invalid(alignment)) {
+      /* parameters seem to be valid */
+      if (alignment <= ALIGN) {
+         DBGPRTM("  alignment value ignored"); DBGEOLN;
+         return nmalloc(szneed);                      /* EXIT */
+      }
+      else if ((minit = nmalloc(szneed + XTRA))) {
+         /* alignment >= 2*ALIGN and power of 2 if here */
+         misalign = (ulong)minit % alignment;
+         DBGPRTM("  misalignment = %d", misalign);
+         if (0 == misalign) { /* aligned, just return XTRA */
+            DBGPRTM(" Just realloc the block."); DBGEOLN;
+            return nrealloc(minit, size);             /* EXIT */
+         }
+         else {
+            /* two or more chunks to release */
+            /* for now, just return NULL and have a leak */
+            DBGPRTM("  Complex case, release multiple chunks");
+            DBGEOLN;
+         }
+      } /* alignment > ALIGN */
+   } /* valid parameters */
+   if (m) return PTR(m);
+   else return NULL;
+} /* nmemalign */
+
+/* --------- nmalloc.c ----------- */
diff --git a/gcc/config/i386/nmalloc/nmalloc.c b/gcc/config/i386/nmalloc/nmalloc.c
new file mode 100644
index 000000000..ecaf4eb80
--- /dev/null
+++ b/gcc/config/i386/nmalloc/nmalloc.c
@@ -0,0 +1,1032 @@
+/* --------- nmalloc.c ----------- */
+
+/* Copyright (c) 2003, 2007 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@maineline.net>
+     (html mail will probably be summarily ignored)
+
+   Revised 2007-01-04 to include calloc.
+   Revised 2007-01-28 per bug report by Florian Xaver. *f1*
+*/
+
+/* A re-implementation of malloc and friends for DJGPP 2.03/2.04
+   This includes many bits modeled after DJs original scheme.
+   This is NOT portable - it builds in knowledge of int size etc.
+   i.e. unsigned ints and pointers are both 32 bits (size 4)
+
+   The system is NOT thread and interrupt safe, although use of a
+   suitable critical section call could make it such.  Nothing
+   herein executes for any unusual length of time (with NDEBUG).
+*/
+
+/* Some critical tuning constants. Search for them:
+   MINSBRK    controls minimal access to sbrk
+   ALIGN      controls alignment of pointers
+   SAVEMEMORY reduces overhead at expense of checkability
+   INT_MAX    (system) controls maximum allocation quantum.
+*/
+
+/* To avoid unexpected problems, the default has been changed
+   so we now require NEWMALLDBG to enable the original action
+*/
+
+#ifndef NEWMALLDBG
+#  undef  NDEBUG
+#  define NDEBUG
+#else
+#  undef  NDEBUG
+#endif
+
+#ifndef NDEBUG
+   /* diddle these to control areas debugged */
+#  define DEBUGM 1     /* malloc */
+#  define DEBUGF 1     /* free */
+#  define DEBUGR 1     /* realloc */
+#else
+#  define DEBUGM 0
+#  define DEBUGF 0
+#  define DEBUGR 0
+   /* the HOOKABLE variant is only for development   */
+   /* It allows some other package to define malloc, */
+   /* free, realloc, and to call this package.       */
+#  ifndef HOOKABLE
+#     define nmalloc  malloc
+#     define nfree    free
+#     define nrealloc realloc
+#     define nmemalign memalign
+#     define ncalloc  calloc
+#  else
+#     define nmalloc  _malloc
+#     define nfree    _free
+#     define nrealloc _realloc
+#     define nmemalign _memalign
+#     define ncalloc   calloc  /* can't hook this */
+#  endif
+#  define fakesbrk sbrk
+#endif
+
+#define SAVEMEMORY 1  /* 0/1 to use/eliminate extra storage */
+
+typedef unsigned char byte;
+typedef unsigned int  ulong;
+
+#include <stddef.h> /* offsetof() */
+#include <stdlib.h> /* malloc, free, realloc, exit, EXIT_FAILURE */
+#include <unistd.h> /* sbrk, write */
+#include <signal.h> /* raise, SIGABRT */
+#include <string.h> /* strlen, memmove, memcpy, memset */
+#include <limits.h> /* CHAR_BIT, INT_MAX */
+#include "sysquery.h" /* available debugger linkages */
+
+/* system dependant magic.  Only STDIN, STDERR used */
+enum {STDIN = 0, STDOUT, STDERR, STDAUX, STDPRN}; /* handles */
+
+/* Incorporation into the system should require deleting the
+   following <nmalloc.h>, changing all references to nmalloc
+   to malloc, nfree to free, nrealloc to realloc.  Change the
+   single call to fakesbrk to sbrk.  Also normally set all
+   DEBUGx values above to 0 in place of 1.  Later many
+   routines will be made inline.  For debugging compilations
+   are done with "/Dinline= " switch.  For production use
+   the "/DNDEBUG=1" switch, which does all the above except
+   the inlining. But see NEWMALLDBG above.
+*/
+#ifndef NDEBUG
+#  include "nmalloc.h" /* while testing before name changes */
+#else
+#  ifdef HOOKABLE
+#     include "hookmem.h"
+#  endif
+#endif
+
+/* ============================================================
+   Macros and storage for debugging, works before init on DJGPP
+   WARNING - GNU extensions used here!!
+   Note: many messages are designed for easy search with grep
+         and also serve as comments.
+*/
+#if DEBUGM || DEBUGF || DEBUGR
+#  include <stdio.h>     /* sprintf, for DEBUG only */
+#  include "fakesbrk.h"  /* repeatable sbrk */
+#  define EOL "\n"       /* for DEBUG printouts only, allow crlf */
+   static char  dbgbuff[1024];
+   static char *dbgbp = dbgbuff;
+#  define DBGFLUSH do {if (dbgbp != dbgbuff) { \
+                         /* write it out */ \
+                         write(STDOUT, dbgbuff, strlen(dbgbuff)); \
+                         dbgbp = dbgbuff; \
+                      } \
+                   } while (0)
+#  define DBGEOLN do { \
+                     DBGPRT(EOL); \
+                     DBGFLUSH; \
+                  } while (0)
+#  define DBGPRT(msg, args...) do { \
+                    if ((dbgbp - dbgbuff) > 924) DBGFLUSH; \
+                    dbgbp +=sprintf(dbgbp, msg , ## args); \
+                 } while (0)
+#  define SHOWBLK(m, id) showblock(m, id)
+#  if DEBUGM
+#     define DBGPRTM(msg, args...) \
+                     dbgbp +=sprintf(dbgbp, msg , ## args)
+#     define SHOWBLKM(m, id) showblock(m, id)
+#  else
+#     define DBGPRTM(msg, args...)
+#     define SHOWBLKM(m, id)
+#  endif
+#  if DEBUGF
+#     define DBGPRTF(msg, args...) \
+                     dbgbp +=sprintf(dbgbp, msg , ## args)
+#     define SHOWBLKF(m, id) showblock(m, id)
+#  else
+#     define DBGPRTF(msg, args...)
+#     define SHOWBLKF(m, id)
+#  endif
+#  if DEBUGR
+#     define DBGPRTR(msg, args...) \
+                     dbgbp +=sprintf(dbgbp, msg , ## args)
+#     define SHOWBLKR(m, id) showblock(m, id)
+#  else
+#     define DBGPRTR(msg, args...)
+#     define SHOWBLKR(m, id)
+#  endif
+#else
+#  define DBGFLUSH
+#  define DBGEOLN
+#  define DBGPRT(msg, args...)
+#  define SHOWBLK(m, id)
+#  define DBGPRTM(msg, args...)
+#  define SHOWBLKM(m, id)
+#  define DBGPRTF(msg, args...)
+#  define SHOWBLKF(m, id)
+#  define DBGPRTR(msg, args...)
+#  define SHOWBLKR(m, id)
+#endif
+
+/* This is intended to allow finding the header area from
+   the address of the immediately adjacent memblocks.
+   The guardxx avoid destruction by an off by one pointer
+   and serve no real logical purpose.  Note that in some
+   cases sz may be recovered from next or next may be
+   recovered from sz.
+*/
+typedef struct memblock {
+   struct memblock *prev;   /* 1st, protect against overrun */
+   struct memblock *next;   /* makes this less clobberable  */
+   ulong            sz;                 /* of this memblock */
+   /* An allocated block has the next two (1) fields NULL */
+   /* A free block has them both non-NULL  */
+   struct memblock *nextfree;
+   struct memblock *prevfree; /* actually data w/SAVEMEMORY */
+#if SAVEMEMORY == 0
+   ulong            guardlo;     /* may hold size requested */
+#endif
+   /* here lies the actual assigned storage                 */
+   /* so the following must be addressed by adding offset   */
+   /* storage must always be a multiple of 8 in size        */
+   /* thus these items are fictional, i.e. for zero data    */
+} memblock, *memblockp;
+
+/* Notice that with SAVEMEMORY the prevfree field only
+   exists for free blocks; it reuses data space.  This
+   is why we cannot allow 0 sized blocks.
+*/
+#if SAVEMEMORY
+#  define DATAOFFSET (offsetof(memblock, prevfree))
+#else
+#  define DATAOFFSET sizeof(memblock)
+#endif
+
+/* conversion and access macros */
+#define MEMBLKp(p) (memblockp)((byte*)(p) - DATAOFFSET)
+#define PTR(m)     (void*)((byte*)(m) + DATAOFFSET)
+
+#define ALIGN 8
+#define ALIGNMASK (ALIGN-1)
+
+/* We can never use an allocation smaller than this */
+#define MINSAVE   (ALIGN + DATAOFFSET)
+
+/* Alternate form of NULL to distinguish free lists
+   This is self protection, because freehdrs[1] is otherwise
+   unused.  freehdrs[0] is reserved to hold lastsbrk.  In turn
+   this means that ALIGN must be >= 4.
+*/
+#define NONE (memblockp)&freehdrs[1]
+
+/* Magic constants.  MINSBRK must be MINSAVE or larger */
+enum {NFLISTS = (int)(CHAR_BIT * sizeof(size_t)), MINSBRK = 1024};
+
+/* ============== Globals ============= */
+
+/* Headers of lists holding free blocks of 2**2 thru 2**31 size */
+/* freehdr[n] holds items sized 2**n thru 2**(n+1) - 1          */
+
+static memblockp freehdrs[NFLISTS]; /* yes, low indices are waste */
+#define lastsbrk freehdrs[0]
+
+/* keep track of the bases of each new sbrk block */
+#define MAXSBRKS 100     /* I have never seen more than 5 needed */
+static int   lastsbrkbgn;       /* zeroed on load */
+static void *sbrkbgn[MAXSBRKS]; /* NULLS on load */
+
+/* This holds pointers to hooks, initialized to NULLs */
+/* see enum m_hook_kind for actual identifiers in sysquery.h */
+static M_HOOKFN hookptr[HKCOUNT];
+
+/* Forward declaration to allow sysquery init below */
+static M_HOOKFN sethook(enum m_hook_kind which,
+                        M_HOOKFN         newhook);
+
+/* This allows a clean connection to debugging software */
+static struct _sysquery sysquery = {
+        DATAOFFSET,
+#if SAVEMEMORY
+        0xff,
+#else
+        offsetof(memblock, guardlo),
+#endif
+        offsetof(memblock, sz),
+        offsetof(memblock, prevfree),
+        offsetof(memblock, nextfree),
+        offsetof(memblock, next),
+        offsetof(memblock, prev),
+        sizeof(memblock),
+        NONE,         /* also &freehds[1] */
+        &sbrkbgn,     /* anchors field */
+        sethook       /* hookset field */
+};
+
+/* 1------------------1 */
+
+/* This can return the above values, hopefully in a register */
+/* The use of NONE in nextfree, prevfree may cause confusion */
+struct _sysquery _sysmalloc(void)
+{
+   return sysquery;
+} /* _sysmalloc */
+
+/* 1------------------1 */
+
+#if DEBUGM || DEBUGF || DEBUGR
+
+/* These two routines are actually available in any user  */
+/* application by use of the _sysmalloc call above.  They */
+/* are retained here to show the derivation of user code, */
+/* and in case needed during system initialization.       */
+
+static void showblock(memblockp m, char *id)
+{
+   if (m) {
+      DBGPRT(" %s %p sz=%u nxt=%p prv=%p nxtf=",
+             id, m, m->sz, m->next, m->prev);
+      if (m->nextfree) {
+         if (NONE == m->nextfree)
+            DBGPRT("NONE prvf=");
+         else
+            DBGPRT("%p prvf=", m->nextfree);
+         if (NONE == m->prevfree)
+            DBGPRT("NONE");
+         else
+            DBGPRT("%p", m->prevfree);
+      }
+      else DBGPRT("0");
+   }
+   else
+      DBGPRT(" %s NULL", id);
+} /* showblock */
+
+/* 1------------------1 */
+
+/* dump the entire free chain group */
+static void dumpfree(void)
+{
+   int       i;
+   memblockp m;
+
+   for (i = 0; i < NFLISTS; i++) {
+      if ((m = freehdrs[i])) {
+         DBGPRT(EOL "%2d: ", i);
+         do {
+            DBGPRT("%p(%u)->", m, m->sz);
+            m = m->nextfree;
+         } while (m && (NONE != m));
+         DBGPRT("0");
+         m = freehdrs[i];
+         while (m && (NONE !=m )) {
+            SHOWBLK(m, EOL "     ");
+            m = m->nextfree;
+         }
+      }
+   }
+   DBGEOLN;
+} /* dumpfree */
+#endif
+
+/* 1------------------1 */
+
+/* This is accessible only through the pointer    */
+/* returned in the sysquery record by _sysmalloc. */
+/* Only of use in the malldbg package.            */
+/* No safeties implemented here - see malldbg     */
+static M_HOOKFN sethook(enum m_hook_kind which,
+                        M_HOOKFN         newhook)
+{
+   M_HOOKFN tmp = NULL;
+
+   if (which < HKCOUNT) {
+      tmp = hookptr[which];
+      hookptr[which] = newhook;
+   }
+   return tmp;
+} /* sethook */
+
+/* 1------------------1 */
+
+/* inserts bases of sbrk chains in sbrkbgn array  */
+/* This ensures we can find all controlled memory */
+/* gets called when we find an unexpected sbrk.   */
+/* Note that if the sbrk was unaligned bk has now */
+/* been aligned, and we have no record of wastage */
+/* As long as nothing is returned to sbrk this is */
+/* not a problem.  This only for the malldbg pkg. */
+static void recordnewsbrk(memblockp bk)
+{
+   int i;
+
+   if (lastsbrkbgn < MAXSBRKS - 1) {
+      /* This check for a previous entry is probably not
+         needed, but it is a rare occurance, so safety */
+      for (i = 0; i < lastsbrkbgn; i++) {
+         if (bk == sbrkbgn[i]) return;
+      }
+      sbrkbgn[lastsbrkbgn++] = bk;
+   }
+/* else we abandon trying to keep track */
+} /* recordnewsbrk */
+
+/* 1------------------1 */
+
+static inline ulong roundup(size_t sz)
+{
+   ulong size;
+
+   size = ((sz + ALIGNMASK) & ~ALIGNMASK) + DATAOFFSET;
+   return size;
+} /* roundup */
+
+/* 1------------------1 */
+
+static inline int size2bucket(ulong sz)
+{
+   int b;
+
+   for (b = 0; sz; sz >>= 1, b++) continue;
+   return b;
+} /* size2bucket */
+
+/* 1------------------1 */
+
+static void badcallabort(const char *msg, int lgh, memblockp m)
+{
+#if DEBUGM || DEBUGF || DEBUGR
+   DBGEOLN;
+#endif
+   write(STDERR, msg, lgh);
+   write(STDERR, ": memory fouled\n", 16);
+#if DEBUGM || DEBUGF || DEBUGR
+   SHOWBLK(m, "");
+   dumpfree();
+#else
+   (void)m;  /* anti unused warning */
+#endif
+   raise(SIGABRT);
+} /* badcallabort */
+
+/* 1------------------1 */
+
+#define ISFREE(m) (m && (m != NONE) && m->nextfree && m->prevfree)
+#if SAVEMEMORY
+#define FOULED(m) (!lastsbrk || m->nextfree)
+#else
+#define FOULED(m) (!lastsbrk || (m->guardlo != 0xDEADBEEF))
+#endif
+
+/* 1------------------1 */
+
+/* Unlike rmvfromfree, this extracts a block that */
+/* may be buried deep within the free list by     */
+/* unlinking.  m is already known a free block    */
+static void extractfree(memblockp m)
+{
+   int       b;
+   memblockp mnxtf, mprvf;
+
+   if (m) {
+      b = size2bucket(m->sz);
+      SHOWBLKF(m, EOL "  extractfree blk");
+
+      /* ease further tests */
+      if (NONE == (mnxtf = m->nextfree)) m->nextfree = NULL;
+      if (NONE == (mprvf = m->prevfree)) m->prevfree = NULL;
+
+      if      (m->nextfree) m->nextfree->prevfree = mprvf;
+
+      if      (m->prevfree) m->prevfree->nextfree = mnxtf;
+      else if (m->nextfree) freehdrs[b] = mnxtf;
+      else                  freehdrs[b] = NULL;
+
+      /* mark the block non-free */
+      m->nextfree = m->prevfree = NULL;
+
+      DBGPRTF(EOL "  freehdrs %d", b);
+      SHOWBLKF(freehdrs[b], "is blk");
+   }
+} /* extractfree */
+
+/* 1------------------1 */
+
+static inline memblockp combinelo(memblockp m)
+{
+   memblockp m1;
+
+   m1 = m;
+   if (ISFREE(m->prev)) {
+      if (m->prev->next != m) {
+         badcallabort("combinelo", 9, m);
+         exit(EXIT_FAILURE);  /* prevent user trapping SIGABRT */
+      }
+      m1 = m->prev;
+      extractfree(m1);
+      if (NULL != (m1->next = m->next))
+         m1->next->prev = m1;
+      m1->sz += m->sz;
+   }
+   return m1;
+} /* combinelo */
+
+/* 1------------------1 */
+
+/* used to combine with lastsbrk, so no ISFREE test */
+/* because lastsbrk is not kept in the free lists   */
+static memblockp combinehi(memblockp m)
+{
+   memblockp m1;
+
+   if (m && m->next) {
+      SHOWBLK(m,       EOL "  combinehi");
+      SHOWBLK(m->next, EOL "  with");
+      if (m->next->prev != m) {
+         badcallabort("combinehi", 9, m);
+         exit(EXIT_FAILURE);  /* prevent user trapping SIGABRT */
+      }
+      m1 = m->next;
+      if (m1 != lastsbrk) extractfree(m1);
+      if (NULL != (m->next = m->next->next))
+         m->next->prev = m;
+      m->sz += m1->sz;
+      SHOWBLK(m,       EOL "  giving");
+   }
+   return m;
+} /* combinehi */
+
+/* 1------------------1 */
+
+/* This takes care of marking the block as free */
+static void mv2freelist(memblockp m)
+{
+   int       b;
+
+   if (m) {
+      if (ISFREE(m->next)) m = combinehi(m);
+      b = size2bucket(m->sz);
+      DBGPRT(EOL "  mv2freelist %d", b); SHOWBLK(m, "blk");
+      if (lastsbrk && (m->next == lastsbrk)) {
+         SHOWBLKF(lastsbrk, EOL "  Combine with lastsbrk");
+         lastsbrk = combinehi(m);
+         lastsbrk->nextfree = lastsbrk->prevfree = NULL;
+         SHOWBLKF(lastsbrk, EOL "  Resulting in lastsbrk");
+         return;
+      }
+      else if (freehdrs[b]) {
+         m->nextfree = freehdrs[b];
+         freehdrs[b]->prevfree = m;
+      }
+      else {
+         m->nextfree = NONE;
+      }
+      m->prevfree = NONE;
+      if (freehdrs[b]) freehdrs[b]->prevfree = m;
+      freehdrs[b] = m;
+      DBGPRT(EOL "  Exit mv2freelist");
+   }
+} /* mv2freelist */
+
+/* 1------------------1 */
+
+/* this always marks the block as non-free */
+static inline void rmvfromfree(memblockp m)
+{
+   int b;
+
+   if (m) {
+      b = size2bucket(m->sz);
+      DBGPRTM(EOL "  rmvfromfree %d", b); SHOWBLKM(m, "blk");
+      if (m != freehdrs[b]) {
+         DBGPRTM(" NOT FREE");
+         badcallabort("rmvfromfree", 11, m);
+         exit(EXIT_FAILURE);  /* prevent user trapping SIGABRT */
+      }
+      else {
+         if (NONE == m->nextfree)
+            freehdrs[b] = NULL;
+         else {
+            freehdrs[b] = m->nextfree;
+            freehdrs[b]->prevfree = NONE;
+         }
+#if SAVEMEMORY
+         m->nextfree = NULL;
+#else
+         m->nextfree = m->prevfree = NULL;
+#endif
+         DBGPRTM(EOL "  freehdrs %d", b);
+         SHOWBLKM(freehdrs[b], "is blk");
+      }
+   }
+} /* rmvfromfree */
+
+/* 1------------------1 */
+
+static int searchfree(ulong szneed)
+{
+   int b;
+
+   b = size2bucket(szneed);
+   DBGPRT(EOL "  freelist search from bucket %d", b);
+
+   if (! freehdrs[b] || (freehdrs[b]->sz < szneed)) {
+      do {
+         b++;
+      } while ((b < NFLISTS) && ! freehdrs[b]);
+   }
+   /* if found we will break off a piece and housekeep */
+   if (b < NFLISTS)
+      DBGPRT(", using %d", b);
+   else {
+      b = 0;
+      DBGPRT(", none found");
+   }
+   return b;
+} /* searchfree */
+
+/* 1------------------1 */
+
+/* The higher portion is returned in *mp,     */
+/* the lower portion via the function return. */
+/* and the lower portion is marked non-free   */
+static memblockp split(memblockp *mp, ulong sz)
+{
+   memblockp m1, m;
+
+   m = *mp;
+   m1 = (memblockp)((char *)m + sz);
+   if (m->sz < (sz + DATAOFFSET)) {
+      badcallabort("memblockpsz", 11, m);
+      exit(EXIT_FAILURE);  /* prevent user trapping SIGABRT */
+   }
+   memcpy(m1, m, DATAOFFSET);
+   m1->prev = m;
+   m1->sz = m->sz - sz;
+   m->next = m1;
+   m->sz = sz;
+   m->nextfree = NULL;
+#if SAVEMEMORY
+#else
+   m->prevfree = NULL;
+#endif
+   *mp = m1;
+   if (m1->next) {
+      if (m1->next->prev != m) {
+         badcallabort("memblockpnxt", 12, m1);
+         exit(EXIT_FAILURE);  /* prevent user trapping SIGABRT */
+      }
+      m1->next->prev = m1;
+   }
+   SHOWBLKM(m, EOL "  split returns");
+   return m;
+} /* split */
+
+/* 1------------------1 */
+
+/* Get the memory, see if it extends the present lastsbrk
+   If not, put the old lastsbrk into the appropriate freelist
+      and replace lastsbrk by the new, setting the headers up
+   else update the size markers in lastsbrk.  When done either
+   lastsbrk can supply the memory szextra, or NULL is returned.
+   A revised lastsbrk block is marked as non-free.
+*/
+static memblockp extendsbrk(ulong szxtra)
+{
+   memblockp  m;
+   byte      *expected;
+   int        alignerr;
+   int        aligndelta;
+
+   DBGPRTM(", extending sbrk");
+
+   /* we have to ensure that the new lastsbrk always has    */
+   /* room to both realign and to leave a header when split */
+   szxtra += (2 * ALIGN + DATAOFFSET);
+   if (szxtra < MINSBRK) szxtra = MINSBRK;
+
+   if (lastsbrk)
+      expected = ((byte*)lastsbrk) + lastsbrk->sz;
+   else expected = NULL;
+
+   if ((aligndelta = (ulong)expected & ALIGNMASK)) {
+      /* lastsbrk end was misaligned, try to align end of this */
+      szxtra += ALIGN - aligndelta;
+      aligndelta = 0;
+   }
+
+   m = fakesbrk(szxtra);
+   if (-1 == (int)m) return NULL;
+   else {
+      if ((byte*)m == expected) {  /* Extending size of lastsbrk */
+         DBGPRTM(EOL "  sbrk(%4u=0x%05x) got expected %p"
+                     " lastsbrk %p sz %d",
+                       szxtra, szxtra, expected,
+                       lastsbrk, expected - (byte*)lastsbrk);
+         lastsbrk->sz += szxtra;
+         m = lastsbrk;
+      }
+      else {
+         /* Here we have to check & fix alignment */
+         DBGPRTM(EOL "=>sbrk(%4u=0x%05x) got UNEXPECTED %p/%p"
+                     " lastsbrk %p sz %d",
+                       szxtra, szxtra, m, expected,
+                       lastsbrk, expected - (byte*)lastsbrk);
+         if ((alignerr = (ALIGNMASK & (ulong)m))) {
+/*f1*/      m = (memblockp)((char*)m +
+                            (aligndelta = ALIGN - alignerr));
+            DBGPRTM(", szerr %d/%d", aligndelta, alignerr);
+         }
+         m->sz = szxtra - aligndelta; /* discard alignerr bytes */
+         m->prev = m->next = NULL;
+#if SAVEMEMORY
+         m->nextfree = NULL;
+#else
+         m->nextfree = m->prevfree = NULL;
+         m->guardlo    = 0xDEADBEEF;
+#endif
+         mv2freelist(lastsbrk);
+         lastsbrk = m;
+         recordnewsbrk(m); /* save in list of chains */
+      }
+   }
+   return m;
+} /* extendsbrk */
+
+/* 1------------------1 */
+
+/* The mechanism:
+   All available memory is kept on the free list, and all adjacent
+   blocks, assigned or free, are linked by next/prev fields in order
+   of address.  Freehdrs[n] holds the first of a list of free blocks
+   of sizes between 2**n and 2**n+1. A pointer to the free portion
+   of the block last acquired via sbrk is held in lastsbrk.
+
+   All blocks on the freelist are marked by having a non-NULL value
+   in the nextfree or prevfree fields.  The special value NONE is
+   used to replace NULL to terminate these lists.  Because of the
+   misalignment possibilities it is necessary to keep accurate byte
+   count lengths in the sz component of lastsbrk.
+
+   1.  An allocation is made from the first fit freehdrs list. Note
+   that there MAY be a usable piece in the next lower freehdr, but
+   that is ignored because we do not want to search possibly long
+   lists.  The block is removed from the freelist, and any excess
+   space is broken off (if large enough to be usable) and assigned
+   to the appropriate free list.
+
+   2.  If no suitable free block is found, allocation is attempted
+   from the last block created by an sbrk call.  Such a block must
+   be large enough to maintain an sbrk pointer after splitting off
+   the desired allocation.
+
+   3.  If this fails a new block is created (or extended) via an
+   sbrk call.  If possible, the previous lastsbrk block is extended.
+   If extension is not possible the remains of the old block alone
+   is placed in the freelist.  This (non-extension) case results in
+   the prev field of the lastsbrk block being NULL.  The next field
+   of the lastsbrk block is always NULL. In this case only it is
+   necessary to check and correct memory alignment.
+
+   Insertion is always done into the start of any given freelist.
+   Thus there is no list walking needed.  Similarly, any block is
+   always removed from the head of the appropriate freelist.
+
+   It is assumed that sbrk will never return a lower address than
+   did a previous sbrk.  I am not sure if this affects anything. I
+   believe it does not.
+*/
+void *nmalloc(size_t size)
+{
+   memblockp m = NULL, m1;
+   ulong     szneed;
+   int       b;
+   void     *p = NULL;
+   size_t    sz = size; /* preserve arg for hooks */
+
+   /* compute the rounded up size needed */
+   if (!sz) sz++;     /* avoid any 0 space allocation */
+   szneed = roundup(sz);
+   DBGPRTM("malloc(%5lu) [%5u]", sz, szneed);
+   SHOWBLKM(lastsbrk, EOL "  lastsbrk");
+
+   /* Check for oversize allocation request */
+   if (szneed < ((ulong)(INT_MAX - 65536))) {
+      /* search the free lists for one */
+      b = searchfree(szneed);
+
+      if (b) {
+         rmvfromfree(m1 = freehdrs[b]);
+         if (m1->sz < szneed + MINSAVE)
+            m = m1;
+         else {
+            m = split(&m1, szneed);
+            mv2freelist(m1);
+         }
+      }
+      else if (lastsbrk &&
+              (lastsbrk->sz >= (szneed + DATAOFFSET))) {
+         m = split(&lastsbrk, szneed);
+      }
+      /* if not found get more from system */
+      else if ((m1 = extendsbrk(szneed))) {
+         if (m1->sz < szneed + MINSAVE) {
+            m = m1;
+            DBGPRTM(EOL "**FOULED lastsbrk\a");
+         }
+         else {
+            m = split(&lastsbrk, szneed);
+         }
+      }
+   /* else abject_failure(); */
+   /* abject_failure COULD check the first possible freehdrs */
+   /* list as a last chance to find some suitable memory     */
+
+      if (m) p = PTR(m);
+      else {
+         DBGPRTM(dbgbp, ", FAILURE");
+         p = NULL;
+      }
+   }
+/* else m and p are NULL for oversize; */
+
+#if DEBUGM
+   DBGPRTM(EOL "returns %p", p);
+   if (m) DBGPRTM("(%lu)", m->sz - DATAOFFSET);
+   DBGEOLN;
+#endif
+
+   if (hookptr[malloc_HK]) hookptr[malloc_HK](size, p);
+   if (!p && hookptr[malloc_fail_HK])
+      hookptr[malloc_fail_HK](size, NULL);
+
+   return p;
+} /* nmalloc */
+
+/* 1------------------1 */
+
+static void dofree(memblockp m)
+{
+   /* mark the block free */
+   m->nextfree = m->prevfree = NONE;
+
+   /* try to combine with lower or higher blocks in memory */
+   if (ISFREE(m->next)) m = combinehi(m);
+   if (ISFREE(m->prev)) m = combinelo(m);
+
+   if (lastsbrk && (lastsbrk == m->prev) )
+      DBGPRTF(EOL "**Found decreasing sbrk!! FOUL");
+   else mv2freelist(m);
+} /* dofree */
+
+/* 1------------------1 */
+
+void nfree(void *ptr)
+{
+   memblockp m;
+
+   if (hookptr[free_HK]) hookptr[free_HK](0, ptr);
+
+   if (ptr) {
+      m = MEMBLKp(ptr);
+      DBGPRTF("free(%p)", ptr); SHOWBLKF(m, "");
+      if (ISFREE(m) ||     /* bad, refreeing block */
+          FOULED(m) ) {    /* block is fouled */
+         badcallabort("free", 4, m);
+         return;           /* he can trap this SIGABRT */
+      }
+      dofree(m);
+#if DEBUGF
+      DBGEOLN;
+#endif
+   }
+   else if (hookptr[free_null_HK])
+      hookptr[free_null_HK](0, NULL);
+} /* nfree */
+
+/* 1------------------1 */
+
+static memblockp mv2lastsbrk(memblockp m, ulong szneed)
+{
+   memblockp m1;
+
+   m1 = split(&lastsbrk, szneed);
+
+   /* Now m1 is the proposed new block, of the right size */
+   /* links are already revised so copy data from m to m2 */
+   memcpy(PTR(m1), PTR(m), m->sz - DATAOFFSET);
+
+   dofree(m);
+   return m1;
+} /* mv2lastsbrk */
+
+/* 1------------------1 */
+
+void *nrealloc(void *ptr, size_t size)
+{
+   memblockp m, m1, m2;
+   void     *p;
+   ulong     szneed;
+   int       b;
+   size_t    sz = size;
+
+   if (hookptr[realloc_HK]) hookptr[realloc_HK](sz, ptr);
+
+   if (!ptr) {
+      p = nmalloc(sz);
+      if (hookptr[realloc_exit_HK])
+         hookptr[realloc_exit_HK](size, p);
+      return p;
+   }
+
+   m = m1 = MEMBLKp(ptr);
+   if (!sz) sz++;     /* avoid any 0 space allocation */
+   szneed = roundup(sz);
+   DBGPRTR("realloc(%p:%lu[%u])", ptr, sz, szneed);
+   SHOWBLKR(m, EOL "  was");
+   if (ISFREE(m) ||     /* bad, realloc of free block */
+       FOULED(m) ) {    /* storage fouled */
+      badcallabort("realloc", 7, m);
+      p = NULL;
+      goto exeunt;      /* he can trap this SIGABRT */
+   }
+   SHOWBLKR(lastsbrk, EOL "  lastsbrk");
+
+   /* if decreasing simply reduce size and move excess to free */
+   if (szneed <= m->sz) {
+      DBGPRTR(EOL "  Realloc is reducing");
+      if ((m->sz - szneed) >= MINSAVE) {
+         m = split(&m1, szneed);
+         mv2freelist(m1);
+      }
+   /* else just return old pointer, i.e. NOP */
+   }
+   else if (szneed > ((ulong)(INT_MAX - 65536))) {
+      /* reject excessive size request */
+      p = NULL; goto exeunt;
+   }
+   else if (ISFREE(m->next) &&
+            (szneed <= (m->sz + m->next->sz)) ) {
+      /* the 'next' block is free and adequate so use it */
+      DBGPRTR(EOL "  Realloc is combining, next is free");
+      m = m1 = combinehi(m);
+      /* now split off the excess, if any */
+      if ((m->sz - szneed) >= MINSAVE) {
+         m = split(&m1, szneed);
+         mv2freelist(m1);
+      }
+   /* else m is the oversized return block */
+   }
+   else if ((lastsbrk == m->next)  &&
+            ((szneed + MINSAVE) <= (m->sz + lastsbrk->sz)) ) {
+      /* lastsbrk is adequate and adjacent so use it */
+      DBGPRTR(EOL "  Realloc is using lastsbrk to extend");
+      m = m1 = combinehi(m1);
+      m = split(&m1, szneed);
+      lastsbrk = m1;
+   }
+   else if (ISFREE(m->prev) &&
+            (szneed <= (m->sz + m->prev->sz)) ) {
+      /* the 'prev' block is free and adequate so use it */
+      DBGPRTR(EOL "  Realloc is combining low free, moving data");
+      m1 = m->prev;
+      extractfree(m1);
+      m1->sz += m->sz;     /* revise the links */
+      if ((m1->next = m->next)) m1->next->prev = m1;
+      /* we are now done with m links, except sz */
+
+      /* This involves copying the data, overlapping */
+      memmove(PTR(m1), PTR(m), m->sz - DATAOFFSET);
+
+      m = m1;        /* done with the old m value */
+      /* Is there something leftover */
+      if ((m->sz - szneed) >= MINSAVE) {
+         m = split(&m1, szneed);
+         mv2freelist(m1);
+      }
+   }
+   else if ((b = searchfree(szneed))) {
+      /* An adequate free block exists, copy over, free old */
+      DBGPRTR(EOL "  Realloc is using free block, copying");
+      rmvfromfree(m1 = freehdrs[b]);
+      if (m1->sz < szneed + MINSAVE) {
+         m2 = m1;
+      }
+      else {
+         m2 = split(&m1, szneed);
+         mv2freelist(m1);
+      }
+      /* Now m2 is the proposed new block, of the right size */
+      /* links are already revised so copy data from m to m2 */
+      memcpy(PTR(m2), PTR(m), m->sz - DATAOFFSET);
+
+      dofree(m);
+      m = m2;
+   }
+   else if (lastsbrk &&
+            ((szneed + MINSAVE) <= lastsbrk->sz) ) {
+      DBGPRTR(EOL "  Realloc is copying into lastsbrk");
+      m = mv2lastsbrk(m, szneed);
+   }
+   /* else malloc new size, copy data, and free old */
+   else if ((m1 = extendsbrk(szneed))) {
+      if (lastsbrk == m->next) {
+         DBGPRTR(EOL "  Realloc is now using lastsbrk extended");
+         /* last chance to avoid copying */
+         m = m1 = combinehi(m);
+         m = split(&m1, szneed);
+         lastsbrk = m1;
+      }
+      else {
+         /* At this point lastsbrk is adequate size */
+         /* split off, copy over, and free old      */
+         DBGPRTR(EOL "  Realloc is making complete new copy");
+         m = mv2lastsbrk(m, szneed);
+      }
+   }
+   else m = NULL;  /* failure */
+
+   if (m) p = PTR(m);
+   else {
+      DBGPRTR(dbgbp, ", FAILURE");
+      p = NULL;
+   }
+
+#if DEBUGR
+   DBGPRTR(EOL "returns %p", p);
+   if (m) DBGPRTR("(%lu)", m->sz - DATAOFFSET);
+   DBGEOLN;
+#endif
+
+exeunt:       /* label used on realloc of free block */
+              /* and on trap of oversize request */
+   if (!p && ptr && hookptr[malloc_fail_HK])
+      hookptr[malloc_fail_HK](size, ptr);
+   if (hookptr[realloc_exit_HK])
+      hookptr[realloc_exit_HK](size, p);
+
+   return p;
+} /* nrealloc */
+
+/* 1------------------1 */
+
+/* calloc included here to ensure that it handles the
+   same range of sizes (s * n) as does malloc.  The
+   multiplication n*s can wrap, yielding a too small
+   value, so we must ensure calloc rejects this.
+*/
+void *ncalloc(size_t n, size_t s)
+{
+   void   *result;
+   size_t  sz;
+
+   result = NULL;
+   if (!n || (((size_t)-1) / n) > s) {
+      sz = n * s;
+      if ((result = nmalloc(sz))) memset(result, 0, sz);
+      }
+   return result;
+} /* ncalloc */
+
+/* 1------------------1 */
+
+#ifdef MEMALIGN
+#  include "memalign.c"  /* further extension, when done */
+#endif
diff --git a/gcc/config/i386/nmalloc/nmalloc.h b/gcc/config/i386/nmalloc/nmalloc.h
new file mode 100644
index 000000000..8becf3bd2
--- /dev/null
+++ b/gcc/config/i386/nmalloc/nmalloc.h
@@ -0,0 +1,25 @@
+/* -------- nmalloc.h ----------- */
+
+/* Copyright (c) 2003, 2006 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@maineline.net>
+*/
+
+#ifndef nmalloc_h
+#define nmalloc_h
+
+#include <stddef.h>
+
+void *nmalloc(size_t sz);
+void nfree(void *ptr);
+void *nrealloc(void *ptr, size_t sz);
+void *ncalloc(size_t n, size_t s);
+#ifdef MEMALIGN
+void *nmemalign(size_t alignment, size_t sz);
+#endif
+
+#endif
+/* -------- nmalloc.h ----------- */
diff --git a/gcc/config/i386/nmalloc/nmalloc.lst b/gcc/config/i386/nmalloc/nmalloc.lst
new file mode 100644
index 000000000..d7e89d5f3
--- /dev/null
+++ b/gcc/config/i386/nmalloc/nmalloc.lst
@@ -0,0 +1,8 @@
+nmalloc.h
+sysquery.h
+malldbg.h
+malldbg.c
+nmalloc.c
+tmalldbg.c
+tnmalloc.c
+
diff --git a/gcc/config/i386/nmalloc/nmalloc.txh b/gcc/config/i386/nmalloc/nmalloc.txh
new file mode 100644
index 000000000..e35c7d659
--- /dev/null
+++ b/gcc/config/i386/nmalloc/nmalloc.txh
@@ -0,0 +1,636 @@
+@node malloc, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+
+void *malloc(size_t size);
+@end example
+
+@subheading Description
+
+This function allocates a chunk of memory from the heap large
+enough to hold any object that is @var{size} bytes in length.
+This memory must be returned to the heap with @code{free}
+(@pxref{free}).
+
+Note: excessively large requests are rejected.  At present
+excessively large means over @code(INT_MAX) - 65536.
+
+Note: this version of malloc is designed to reduce memory usage.
+A faster but less efficient version is available in the libc
+sources (@file{djlsr*.zip}) in the file
+@file{src/libc/ansi/stdlib/fmalloc.c}.
+
+@subheading Return Value
+
+A pointer to the allocated memory, or @code{NULL} if there isn't
+enough free memory to satisfy the request.
+
+@subheading Portability
+
+@portability ansi, posix
+
+@subheading Example
+
+@example
+char *c = malloc(100);
+@end example
+
+@c -------------------------------------------------------------
+
+@node free, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+
+void free(void *ptr);
+@end example
+
+@subheading Description
+
+Returns the allocated memory to the heap (@pxref{malloc}).  If
+the @var{ptr} is @code{NULL}, @code{free} does nothing.
+
+@subheading Return Value
+
+None.
+
+@subheading Portability
+
+@portability ansi, posix
+
+@subheading Example
+
+@example
+char *q = malloc(20);
+free(q);
+@end example
+
+@c -------------------------------------------------------------
+
+@node realloc, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+
+void *realloc(void *ptr, size_t size);
+@end example
+
+@subheading Description
+
+This function changes the size of the region pointed to by
+@var{ptr}. If it can, it will reuse the same memory space, but
+it may have to allocate a new memory space to satisfy the
+request.  In either case, it will return the pointer that you
+should use to refer to the (possibly new) memory area.  The
+pointer passed may be @code{NULL}, in which case this function
+acts just like @code{malloc} (@pxref{malloc}).
+
+An application that wants to be robust in the face of a possible
+failure of @code{realloc} to enlarge a buffer should save a copy
+of the old pointer in a local variable, to be able to use the
+original buffer in case @code{realloc} returns @code{NULL}.  See
+the example below for details.
+
+Note: excessively large requests are rejected.  At present
+excessively large means over @code(INT_MAX) - 65536.
+
+@subheading Return Value
+
+On success, a pointer is returned to the memory you should now
+refer to.  On failure, @code{NULL} is returned and the memory
+pointed to by @var{ptr} prior to the call is not freed.
+
+@subheading Portability
+
+@portability ansi, posix
+
+@subheading Example
+
+@example
+if (now + new > max)
+@{
+  char *old = p;
+
+  oldmax = max;
+  max = now + new;
+  p = realloc(p, max);
+  if (p == NULL) @{
+    p = old;  /* retain the old pointer */
+    max = oldmax;
+  @}
+@}
+@end example
+
+@c -------------------------------------------------------------
+
+@node mallinfo, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> /* on non-DJGPP systems */
+
+struct mallinfo mallinfo(void);
+@end example
+
+@subheading Description
+
+This function returns information about heap space usage.  It is
+intended to be used for debugging dynamic memory allocation and
+tracking heap usage.  The @code{struct mallinfo} structure is
+defined by @file{stdlib.h} as follows:
+
+@example
+ struct mallinfo @{
+   int arena;
+   int ordblks;
+   int smblks;
+   int hblks;
+   int hblkhd;
+   int usmblks;
+   int fsmblks;
+   int uordblks;
+   int fordblks;
+   int keepcost;
+ @};
+@end example
+
+@noindent
+whose members are:
+
+@table @code
+@item arena
+The total amount of space, in bytes, handed by @code{sbrk} to
+@code{malloc}.  Note that this is not the same as
+@code{sbrk(0)}, since @code{sbrk} allocates memory in large
+chunks and then subdivides them and passes them to @code{malloc}
+as required.  In particular, the result of @code{sbrk(0)} might
+be much larger than the @code{arena} member of @code{struct
+mallinfo} when the DPMI host allocates memory in non-contiguous
+regions (happens on MS-Windows).
+
+@item ordblks
+The number of ``ordinary blocks'': the total number of allocated
+and free blocks maintained by @code{malloc}.
+
+@item smblks
+The number of ``small blocks''.  This is normally zero, unless
+a special version of @code{malloc} was installed.
+
+@item hblks
+The count of freeblocks maintained in the malloc arena.  This
+is normally much smaller than the number of freed blocks, since
+such blocks have been combined into larger blocks.
+
+@itemx hblkhd
+The size of the currently available top portion of the memory
+assigned by @code(sbrk).  Sometimes known as @dfn(slop).
+
+@item usmblks
+The space (in bytes) in ``small blocks'' that are in use.  This
+is always zero in the DJGPP implementation.
+
+@item fsmblks
+The space in free ``small blocks''.  Normally zero in the DJGPP
+implementation.
+
+@item uordblks
+The amount of space, in bytes, in the heap space currently used
+by the application.  This does not include the small overhead
+used by @code{malloc} to maintain its hidden information in each
+allocated block.
+
+@item fordblks
+The amount of free heap space maintained by @code{malloc} in its
+free list of hblks chunks.
+
+@item keepcost
+The total overhead used by @code(malloc) in maintaining the
+currently allocated blocks.
+@end table
+
+@subheading Return Value
+
+The @code{mallinfo} structure filled with information.
+
+@subheading Portability
+
+@port-note posix This function is available on many Unix systems.
+@portability !ansi, !posix
+
+@subheading Example
+
+@example
+ struct mallinfo info = mallinfo();
+
+ printf("Memory in use: %d bytes\n",
+        info.usmblks + info.uordblks);
+ printf("Total heap size: %d bytes\n", info.arena);
+@end example
+
+@c -------------------------------------------------------------
+
+@node malloc_verify, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> /* on non-DJGPP systems */
+
+int malloc_verify(void);
+@end example
+
+@subheading Description
+This function attempts to determine if the heap has been
+corrupted.  It scans all the blocks allocated by @code{malloc}
+and handed to the application, and also all the free blocks
+maintained by @code{malloc} and @code{free} in the internal free
+list.  Each block is checked for consistency of the hidden
+bookkeeping information recorded in it by @code{malloc} and
+@code{free}.
+
+What happens when a bad block is found depends on the current
+@dfn{malloc diagnostics level}: for example, the block can be
+reported, or the program may be aborted.  @xref{malloc_debug},
+for the details.
+
+@subheading Return Value
+If the program isn't aborted during the function's run (this
+depends on the current diagnostics level), @code{malloc_verify}
+returns 1 if the heap passes all tests, or zero of some of the
+tests failed.
+
+@subheading Portability
+
+@port-note posix This function is available on many Unix systems.
+@portability !ansi, !posix
+
+@subheading Example
+
+@example
+ if (malloc_verify() == 0)
+   printf ("Heap corruption detected!\n");
+@end example
+
+@c -------------------------------------------------------------
+
+@node malloc_debug, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> /* on non-DJGPP systems */
+
+int malloc_debug(int level);
+@end example
+
+@subheading Description
+This function sets the level of error diagnosis and reporting
+during subsequent calls to @code{malloc}, @code{free},
+@code{realloc}, and all functions which call them internally.
+The argument @var{level} is interpreted as follows:
+
+@table @asis 
+@item Level 0
+The memory allocation functions behave as they do if
+@code{malloc_debug} was never called.  Only passive checks are
+allowed, including @code(malloc_verify), @code(mallocmap), and
+@code(malldbgdumpfile) (to set the output file).  In particular
+@code(mallsethook) is disabled, to avoid accidents.  The actual
+functioning of the malloc system remains unaffected.  Any malloc
+hooks @xref(mallsethook) are reset. If errors are detected by
+@code{malloc_verify}, it prints diagnostic messages to the
+@defn(dumpfile) (default standard error stream), with address
+and size of the offending block and other pertinent information.
+
+@item Level 1
+All the passive checks of level 0 are allowed.  In addition
+@code(mallsethook) is enabled, thus allowing construction of
+custom debugging packages.
+
+@item Level 2
+Similar to level 1, but the consistency of the entire heap is
+also verified (by calling @code{malloc_verify}) on every call to
+the memory allocation functions.  @emph{Warning: this may
+significantly slow down the application.}  Since the malloc
+hooks are in use to connect to this system, @code(mallsethook)
+is disabled.  If there are hooks already in use the change to
+level 2 or above is rejected.
+
+@item Level 3
+Similar to level 2, except that the program is aborted whenever
+a heap corruption is detected.  In addition, failed allocations
+(i.e.@: when @code{malloc} or @code(realloc) returns @code{NULL}
+because it cannot satisfy a request) are reported to the
+dumpfile (default standard error).
+
+@item Level 4
+Similar to level 3, but calls to @code{free} with a @code{NULL}
+pointer as an argument are also reported.
+
+@item Level -1
+Does not alter the debug level, but returns the current value.
+@end table
+
+@subheading Return Value
+
+@code{malloc_debug} returns the previous error diagnostic level.  The
+default level is 0.
+
+@subheading Portability
+
+@port-note posix This function is available on many Unix systems.
+@portability !ansi, !posix
+
+@subheading Example
+
+@example
+ malloc_debug(2);
+ ...
+ malloc_verify();
+@end example
+
+@c -------------------------------------------------------------
+
+@node mallocmap, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> /* on non-DJGPP systems */
+
+void mallocmap(void);
+@end example
+
+@subheading Description
+
+This function prints a map of the heap storage to the selected
+@file(dumpfile). @xref(malldbgdumpfile). For each block, its
+address and size are printed, as well as an indication whether
+it is free or in use, together with pointers to adjacent blocks.
+
+@subheading Return Value
+
+None.
+
+@subheading Portability
+
+@port-note posix This function is available on many Unix systems.
+@portability !ansi, !posix
+
+@c -------------------------------------------------------------
+
+@node mallsethook, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> /* on non-DJGPP systems */
+
+M_HOOKFN mallsethook(enum m_hook_kind which,
+                     M_HOOKFN newhook);
+@end example
+
+@subheading Description
+Several @defn(hooks) are provided for building custom
+@code{malloc} debugging packages.  Such packages typically need
+to be notified when memory is allocated and freed by the
+application, in order to be able to find memory leaks, code that
+writes beyond the limits of allocated buffers or attempts to
+@code(free) buffers which were not allocated by @code{malloc},
+etc. These hooks can be used to define callback functions which
+will be called by the library at strategic points.  Each
+callback is only called if it is non-@code{NULL}; by default,
+all of them are initialized to a @code{NULL} value.
+
+The actual hook to be set is described by the following
+constants, enumerated in @file(stdlib.h):
+
+@table @code
+@item malloc_HK = 0    
+on entry to malloc
+
+@item malloc_fail_HK   
+when malloc or realloc fails
+
+@item free_HK          
+on entry to free
+
+@item free_null_HK     
+when free is called with a NULL pointer
+
+@item realloc_HK       
+on entry to realloc
+
+@item realloc_exit_HK  
+when realloc exits.
+
+@item HKCOUNT          
+The first invalid value for a hook descriptor.
+@end @table
+
+@noindent
+and each ``callback'' function is described by:
+
+@example
+   typedef void (*M_HOOKFN)(size_t sz, void *ptr);
+@end
+
+@noindent
+in @file(stdlib.h).  Note that in some cases the parameters
+supplied to the ``callback'' function will be meaningless, in
+which case they will be zero or @code(NULL) as appropriate.  The
+callback function must @strong(NOT) call any of @code(malloc),
+@code(free), or @code(realloc).
+
+@code(mallsethook) action is disabled unless the debug_level is
+set to 1.  This interlock avoids accidental use before enabling
+the package, and avoids altering hooks that are already in use
+for debug_level of 2 or higher.
+
+For access to the internal storage of the malloc arena, see the
+@code(_sysmalloc) call and the @code(_sysinfo) struct.
+
+@table @code
+
+@item malloc_HK
+Called just before a chunk of memory is about to be returned to
+the application in response to an allocation request.
+@var{sz} is the size requested by the application
+(@strong{not} the actual size of the allocated buffer, which may
+be larger).  @var{ptr} is a pointer to the block that was
+allocated.
+
+@item malloc_fail_HK
+Called if @code{malloc} failed to find a free block large enough
+to satisfy a request, and also failed to obtain additional
+memory from @code{sbrk}.  @var{sz} is the requested allocation
+size.
+
+@item free_HK
+Called when a buffer is about to be freed.  @var{ptr} is a
+pointer to the block to be freed.  Its validity has not been
+checked.
+
+@item free_null_HK
+Called whenever a @code{NULL} pointer is passed to @code{free}.
+@acronym{ANSI} C specifically rules that this is allowed and
+should have no effect, but you might want to catch such cases if
+your program needs to be portable to old compilers whose
+libraries don't like @code{NULL} pointers in @code{free}.
+
+@item realloc_HK
+Called at entry to @code{realloc}, before the actual
+reallocation. @var{ptr} is the pointer whose contents are to be
+reallocated.  @var{sz} is the new size requested by the
+application.  (This hook is called @emph{in addition} to the
+other hooks which may be called by @code{malloc} if and when
+@code{realloc} calls them.)
+
+@item realloc_exit_HK
+Called at exit from @code(realloc).  @var(sz) is the requested
+size, and @var(ptr) is the (possibly) revised value of the user
+pointer which will be returned by @code(realloc).  This may be
+@code(NULL) if realloc was unable to allocate the space, in
+which case @emph(ONLY) the original value of @var(ptr) (as
+reported by @code(realloc_HK)) remains valid.
+
+@end table
+
+@subheading Return Value
+
+@code{mallsethook} returns the previous hook pointer, (usually
+@code(NULL)). If @code(mallsethook) is disabled it will also
+return @code(NULL).
+
+@subheading Portability
+
+@portability !ansi, !posix
+
+These hooks and the function are specific to DJGPP.
+
+@subheading Example
+
+@example
+
+ static void mallocfailalert(size_t sz, void *ptr)
+ @{
+    printf("Failed to malloc %lu bytes\n", (unsigned long)sz);
+ @}
+
+ malloc_debug(1);
+ mallsethook(malloc_fail_HK, mallocfailalert);
+ ...
+ /* any malloc failure will result in a message */
+ 
+@end example
+
+@c -------------------------------------------------------------
+
+@node malldbgdmpfile, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h> (on non-DJGPP systems)
+
+FILE *malldbgdmpfile(FILE *fp);
+@end example
+
+@subheading Description
+
+This function allows diverting the output of the malldbg package
+to any suitable text file, known as the @defn(dumpfile).  By
+default the package uses @code(stderr).
+
+@subheading Return Value
+
+The previous identity of the dumpfile.
+
+@subheading Portability
+
+@portability !ansi, !posix
+
+This function is specific to DJGPP.
+
+@subheading Example
+
+@example
+FILE *oldfile = malldbgdmpfile(stdout);
+@end example
+
+@c -------------------------------------------------------------
+
+@node _sysmalloc, memory
+@subheading Syntax
+
+@example
+#include <stdlib.h>
+#include <malldbg.h>  /* on non-DJGPP systems */
+#include <sysquery.h> /* alternative on non-DJGPP systems */
+
+struct _sysquery _sysmalloc(void);
+@end example
+
+@subheading Description
+
+This function exports the internal structure of the malloc arena
+and thus allows construction of such packages as malldbg.  It 
+avoids accidental exposure of system critical values, and also
+permits such values to be changed and reflected in external
+packages.
+
+@subheading Return Value
+
+A @code(struct _sysquery), described as follows:
+
+@example
+struct _sysquery @{
+  unsigned char data, gdlo, sz, prvf, nxtf, nxt, prv, ohead;
+  void         *nilp;
+  void         *anchors;
+  set_m_hook    hookset;
+@};
+@end example
+
+Any unsigned char field set to 255 signifies the value is
+meaningless.  The @code(ohead) value is not useful in the
+present implementation.  The remaining values are small offsets
+from the internal pointers to the appropriate fields.  In
+particular @code(data) is the offset between the internal
+pointer and the user pointers.  @code(nxt) and @code(prv) link
+all allocated memory blocks, while @code(nxtf) and @code(prvf)
+are used only to link free blocks. @code(sz) is the internal
+size of the block, not the user size, and is normally rounded
+upward.  Thus the @code(nxt) field is redundant to the @code(sz)
+field (except when no @code(nxt) exists) and is used in validity
+checking. A @code(NULL) value in @code(nxtf) field signifies
+that the block is not free. The special value @code(nilp) is
+used in @code(nxtf) and @code(prvf) as a @code(NULL) value
+distinguishable from @code(NULL).
+
+@code(anchors) points to a @code(NULL) terminated list of sets
+of chains of memory blocks.  These were allocated by @code(sbrk)
+and were not contiguous to any previous allocations.
+
+@code(hookset) is a pointer to a function that can set malloc
+hooks, as described in @code(mallsethook).  It is only available
+through this link.
+
+@subheading Portability
+
+@portability !ansi, !posix
+
+This function is specific to DJGPP.
+
+@subheading Example
+
+@example
+struct _sysquery sysinfo = _sysmalloc();
+@end example
+
+@c -------------------------------------------------------------
diff --git a/gcc/config/i386/nmalloc/readme.txt b/gcc/config/i386/nmalloc/readme.txt
new file mode 100644
index 000000000..0beffbee6
--- /dev/null
+++ b/gcc/config/i386/nmalloc/readme.txt
@@ -0,0 +1,56 @@
+This is intended to be prepared via the makefile.
+
+To create a testable debug version, enter "make tnmalloc".
+
+To create an object module for use in actual systems, enter 
+"make malloc.o".  This will have the normal names, malloc, free,
+realloc.
+
+To create a version for profiling, enter "make tmallocp".  The
+module mallocp.o created is generally suitable for profiling, 
+and has the usual names.
+
+To create a cross-reference, enter "make xrf" (under DOS boxes
+only)
+
+The various compile time flags are set up appropriately.  In
+particular malloc.o should be immediately ready for inclusion
+in a library.  It may be desirable to "strip" debugging
+information from the module.
+
+"make all" creates everything, "make clean" wipes them out.
+
+The little test 'evilalgo' can be linked to either the stock
+malloc system, or to the malloc.o generated above.  Then time
+execution for an argument of 200000.  The original library will
+probably fail where nmalloc will succeed, and nmalloc will do it
+a lot faster.
+
+To create the modules for the malloc_debug system, enter
+"make tmalldbg.exe".  Once this is done other systems with the
+debug mechanism can be created by linking malldbg and hookmem 
+(.o) ahead of the normal runtime library.  The system using it
+must #include malldbg.h.
+
+make zip doesn't work properly.
+
+The integration of the malldbg system is not complete, but
+should function correctly.  Future changes are expected to be
+fairly cosmetic, and improve performance slightly.  The
+hookmem.h file will disappear and the sysquery action will be 
+modified.
+
+2003-05-01
+
+The malldbg system now appears complete.  Documentation in
+info source form is included in nmalloc.txh.  I find the 
+following command useful for creating a viewable or printable
+(but imperfect) .htm doc file:
+
+makeinfo --force --no-split --no-validate --html
+         -o nmalloc.htm nmalloc.txh
+         
+(Above is all one line)         
+
+
+Bug reports to cbfalconer@worldnet.att.net.
diff --git a/gcc/config/i386/nmalloc/sysquery.h b/gcc/config/i386/nmalloc/sysquery.h
new file mode 100644
index 000000000..041ef13f0
--- /dev/null
+++ b/gcc/config/i386/nmalloc/sysquery.h
@@ -0,0 +1,53 @@
+/* -------- sysquery.h ------------ */
+
+/* Copyright (c) 2003 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@worldnet.att.net>
+*/
+
+#ifndef sysquery_h
+#define sysquery_h
+#ifdef __cplusplus
+   extern "C" {
+#endif
+
+/* The settable hooks, identifiers */
+/* HKCOUNT is illegal value */
+enum m_hook_kind {malloc_HK,  malloc_fail_HK,
+                  free_HK,    free_null_HK,
+                  realloc_HK, realloc_exit_HK,
+                  HKCOUNT};
+
+/* Depending on kind, some params may be meaningless */
+typedef void (*M_HOOKFN)(size_t sz, void *bk);
+
+/* returns previous value of the appropriate function */
+typedef M_HOOKFN (*set_m_hook)(enum m_hook_kind which,
+                               M_HOOKFN newhook);
+
+/* This allows a clean connection to debugging software      */
+/* NOTE: ANY value equivalent to -1 means data not available */
+/*       for the unsigned chars this means 0xffh.            */
+struct _sysquery {
+   unsigned char data, gdlo, sz, prvf, nxtf, nxt, prv, ohead;
+   void *        nilp;    /* dummy NULL, &freeptrs[1] */
+   void *        anchors; /* of memory chains */
+   set_m_hook    hookset; /* how to set a hook */
+};
+
+/* This can return the above values, hopefully in a register    */
+/* NONE is used in nextfree, prevfree as the equivalent of NULL */
+/* With the unclean knowledge that nil is actually a pointer to */
+/* freehdrs[1], and that lastsbrk is actually freehdrs[0], the  */
+/* entire malloc structure is open to debuggery.                */
+struct _sysquery _sysmalloc(void);
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif
+/* -------- sysquery.h ------------ */
diff --git a/gcc/config/i386/nmalloc/tmalldbg.c b/gcc/config/i386/nmalloc/tmalldbg.c
new file mode 100644
index 000000000..fb1e1e7ad
--- /dev/null
+++ b/gcc/config/i386/nmalloc/tmalldbg.c
@@ -0,0 +1,416 @@
+/* ------- tmalldbg -------- */
+
+/* Copyright (c) 2003 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@worldnet.att.net>
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+#include "malldbg.h"
+#include "sysquery.h"
+
+/*#include <string.h>
+#include <math.h>
+#include "cokusMT.h"
+*/
+
+/* Number of free lists in system */
+#define NFLISTS ((int)(CHAR_BIT * sizeof(size_t)))
+
+typedef struct testnode {
+   struct testnode *next;
+   char             string[30];
+} testnode;
+
+testnode *root;
+
+int notquiet;
+
+/* 1------------------1 */
+
+/* Build something to display the structure of */
+/* a linked list headed by the global var 'root' */
+static testnode *buildlist(int items, testnode *root)
+{
+   testnode *this;
+
+   while (items) {
+      this = malloc(items + sizeof *this);
+      this->next = root;
+      root = this;
+      sprintf(this->string, "item #%d", items);
+      items--;
+   }
+   return root;
+} /* buildlist */
+
+/* 1------------------1 */
+
+/* retains 1 in three of original list,
+   Ex: a -> b -> c -> d ::= a -> d, b & c freed
+   This allows exercizing the free list compaction */
+static void prunelist(testnode *root)
+{
+   testnode *this, *keep;
+
+   while (root) {
+      keep = root;
+      this = root->next;
+      if ((root = this)) {
+         this = root->next;
+         free(root);
+         if ((root = this)) {
+            this = root->next;
+            free(root);
+            root = this;
+         }
+      }
+      keep->next = root;
+   }
+} /* prunelist */
+
+/* 1------------------1 */
+
+static struct _sysquery sysinfo;
+void                 *(*freehdrsp)[NFLISTS];
+
+
+#define NONE          sysinfo.nilp
+#define lastsbrk      freehdrs[0]
+#define memblockp     void*
+typedef unsigned int  ulong;
+typedef unsigned char byte;
+
+/* conversion and access macros */
+#define DATAOFFSET sysinfo.data
+
+#define MEMBLKp(p) (memblockp)((byte*)(p) - DATAOFFSET)
+#define PTR(m)     (void*)((byte*)(m) + DATAOFFSET)
+
+/* field access macros (AFTER sysinfo loaded)    */
+/* Examples - replace "m->prv" by "fld(m, prv)"  */
+/*            replace "m->sz"  by "szof(m)"      */
+/* where field is prvf, nxtf, prv, nxt           */
+#define fld(m, field)   *((void**)((char*)m + sysinfo.field))
+#define szof(m)         *(ulong*)((char*)m + sysinfo.sz)
+#define freehdrs        (*freehdrsp)
+
+/* 1------------------1 */
+
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+void showsysquery(void)
+{
+   printf("sysinfo is: NONE = %p\n"
+          "     DATAOFFSET  = %d\n"
+          "     gdlo offset = %d\n"
+          "     sz   offset = %d\n"
+          "     prvf offset = %d\n"
+          "     nxtf offset = %d\n"
+          "     nxt  offset = %d\n"
+          "     prv  offset = %d\n"
+          "     ohead       = %d\n"
+          "     &freehdrs   = %p\n"
+          "     &anchors    = %p\n"
+          "     &hookset()  = %p\n",
+          sysinfo.nilp, sysinfo.data, sysinfo.gdlo,
+          sysinfo.sz,  sysinfo.prvf, sysinfo.nxtf,
+          sysinfo.nxt, sysinfo.prv,  sysinfo.ohead,
+          freehdrs, sysinfo.anchors, sysinfo.hookset);
+
+
+} /* showsysquery */
+
+/* 1------------------1 */
+
+/* m is the allocated ptr treated by MEMBLKp    */
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+static void xshowblock(void *m, char *id)
+{
+   if (m) {
+      printf(" %s %p", id, m);
+      printf(" sz=%u nxt=%p prv=%p nxtf=",
+             szof(m), fld(m, nxt), fld(m, prv));
+      if (fld(m, nxtf)) {
+         if (NONE == fld(m, nxtf))
+            printf("NONE prvf=");
+         else
+            printf("%p prvf=", fld(m, nxtf));
+         if (NONE == fld(m, prvf))
+            printf("NONE");
+         else
+            printf("%p", fld(m, prvf));
+      }
+      else printf("0");
+   }
+   else
+      printf(" %s NULL", id);
+   fflush(stdout);  /* to coexist with internal debuggery */
+} /* xshowblock */
+
+/* ========== End of debuggery examples ============= */
+/* ============== Start of tests ==================== */
+
+struct blkspace {
+   unsigned long totspace;
+   unsigned long blkcount;
+};
+
+/* 1------------------1 */
+
+struct blkspace freeblocks()
+{
+   struct blkspace blksp;
+   int             i;
+   memblockp       m;
+
+   blksp.totspace = blksp.blkcount = 0;
+   for (i = 0; i < NFLISTS; i++) {
+      if ((m = freehdrs[i])) {
+         while (m && (NONE !=m )) {
+            blksp.totspace += szof(m);
+            blksp.blkcount++;
+            m = fld(m, nxtf);
+         }
+      }
+   }
+   return blksp;
+} /* freeblocks */
+
+/* 1------------------1 */
+
+void printinfo(struct mallinfo *info)
+{
+   printf("   arena = %d\n", info->arena);
+   printf(" ordblks = %d\n", info->ordblks);
+   printf("  smblks = %d\n", info->smblks);
+   printf("   hblks = %d\n", info->hblks);
+   printf("  hblkhd = %d\n", info->hblkhd);
+   printf(" usmblks = %d\n", info->usmblks);
+   printf(" fsmblks = %d\n", info->fsmblks);
+   printf("uordblks = %d\n", info->uordblks);
+   printf("fordblks = %d\n", info->fordblks); /* free space */
+   printf("keepcost = %d\n", info->keepcost);
+} /* printinfo */
+
+/* 1------------------1 */
+
+void foul2ndlast(testnode *root)
+{
+   testnode *this, *prev;
+   void     *m;
+
+   this = prev = NULL;
+   while (root) {
+      prev = this; this = root; root = root->next;
+   }
+   /* Now prev=>this=>NULL */
+   m = MEMBLKp(prev);
+
+   xshowblock(m, "Fouling block: ");
+   puts("");
+
+   /* acts like a write past the previous block */
+   (*(char*)m)--;
+
+   xshowblock(m, " which became: ");
+   puts("\n");
+
+} /* foul2ndlast */
+
+/* 1------------------1 */
+
+void test01(unsigned long n)
+{
+   struct mallinfo info;
+   struct blkspace blkspace;
+   void  *m;
+
+   root = buildlist(n, root);
+   m = MEMBLKp(root);
+   xshowblock(m, "\nLAST allocated:");
+   puts("");
+
+   blkspace = freeblocks();
+   info = mallinfo();
+   printinfo(&info);
+
+   printf("\nnfreeblk = %lu\n", blkspace.blkcount);
+   printf(" holding ( %lu )\n", blkspace.totspace);
+} /* test01 */
+
+/* 1------------------1 */
+
+void test02(unsigned long n)
+{
+   root = buildlist(n, root);
+   mallocmap();
+} /* test02 */
+
+/* 1------------------1 */
+
+void test03(unsigned long n)
+{
+   struct mallinfo info;
+
+   root = buildlist(n, root);
+   info = mallinfo();
+   puts("\nBefore pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter repruning:");
+   printinfo(&info);
+   puts("\nComplete map:");
+   mallocmap();
+} /* test03 */
+
+/* 1------------------1 */
+
+void test04(unsigned long n)
+{
+   struct mallinfo info;
+   testnode       *this;
+
+   info = mallinfo();
+   puts("\nAt startup:");
+   printinfo(&info);
+   root = buildlist(n, root);
+   info = mallinfo();
+   puts("\nBefore pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter repruning:");
+   printinfo(&info);
+   free(NULL);         /* to check the alert */
+   while ((this = root)) {
+      root = root->next;
+      free(this);
+   }
+   info = mallinfo();
+   puts("\nAfter freeing all:");
+   printinfo(&info);
+   puts("\nComplete map:");
+   mallocmap();
+} /* test04 */
+
+/* 1------------------1 */
+
+void test06(unsigned long n)
+{
+   root = buildlist(n, root);
+   printf("malloc_verify() returns %d\n", malloc_verify());
+   mallocmap();
+} /* test06 */
+
+/* 1------------------1 */
+
+void test07(unsigned long n)
+{
+   root = buildlist(n, root);
+   foul2ndlast(root);
+   printf("malloc_verify() returns %d\n", malloc_verify());
+   mallocmap();
+} /* test07 */
+
+/* 1------------------1 */
+
+void test08(unsigned long n)
+{
+   struct mallinfo info;
+   void  *p, *p1;
+
+   info = mallinfo();
+   puts("\nAt startup:");
+   printinfo(&info);
+   root = buildlist(n, root);
+   info = mallinfo();
+   puts("\nBefore pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter pruning:");
+   printinfo(&info);
+   prunelist(root);
+   info = mallinfo();
+   puts("\nAfter repruning:");
+   printinfo(&info);
+   puts("\nAfter attempting malloc/realloc(INT_MAX):");
+   p = malloc(INT_MAX);
+   p = malloc(2);
+   if (p && (p1 = realloc(p, INT_MAX))) {
+      p = p1; /* shouldn't happen */
+      puts("\nSomething is wrong");
+   }
+   info = mallinfo();
+   printinfo(&info);
+   puts("\nComplete map:");
+   mallocmap();
+} /* test08 */
+
+/* 1------------------1 */
+
+int main(int argc, char *argv[])
+{
+   unsigned long t = 0, n = 0, dbglvl = 0;
+
+   if (argc > 1) t = strtoul(argv[1], NULL, 10);
+   if (argc > 2) n = strtoul(argv[2], NULL, 10);
+   if (argc > 3) dbglvl = strtoul(argv[3], NULL, 10);
+
+   if (0 == n) n = 10;
+
+   printf("test%02lu-%lu (%lu)\n", t, n, dbglvl);
+
+   sysinfo   = _sysmalloc();
+   freehdrsp = (void*)((byte*)(sysinfo.nilp)-sizeof(void*));
+   malloc_debug(dbglvl);
+   if (t != 5) malldbgdumpfile(stdout);
+
+   switch (t) {
+case 1: test01(n); break;
+case 2: test02(n); break;
+case 3: test03(n); break;
+case 4: test04(n); break;
+case 5: test04(n); break; /* see malldbgdumfile call above */
+case 6: test06(n); break;
+case 7: test07(n); break;
+case 8: test08(n); break;
+default:
+        printf("Usage: tmalldbg [testnumber [quantity [level]]]\n");
+        printf("CHAR_BIT * sizeof(size_t) = %lu\n",
+                (unsigned long)(CHAR_BIT * sizeof(size_t)));
+        showsysquery();
+        printf(
+           "\n"
+           "Test Purpose (usually to stdout)\n"
+           "  1  Allocate items, execute/show mallinfo\n"
+           "  2  Allocate items, execute mallocmap\n"
+           "  3  Allocate/prune items, do mallocmap & info\n"
+           "  4  As test 3, but all freed and free(NULL)\n"
+           "  5  As test 4, but dumps to stderr\n"
+           "  6  Allocate items, call malloc_verify / map\n"
+           "  7  As 6, but deliberately foul 2nd last malloc\n"
+           "  8  As 3, but attempt to malloc INT_MAX items\n"
+           );
+        break;
+   } /* switch (t) */
+   return 0;
+} /* main */
+
+/* ------- tmalldbg -------- */
diff --git a/gcc/config/i386/nmalloc/tnmalloc.c b/gcc/config/i386/nmalloc/tnmalloc.c
new file mode 100644
index 000000000..ed25c64d5
--- /dev/null
+++ b/gcc/config/i386/nmalloc/tnmalloc.c
@@ -0,0 +1,618 @@
+/* ------- tstmalloc -------- */
+
+/* Copyright (c) 2003 by Charles B. Falconer
+   Licensed under the terms of the GNU LIBRARY GENERAL PUBLIC
+   LICENSE and/or the terms of COPYING.DJ, all available at
+   <http://www.delorie.com>.
+
+   Bug reports to <mailto:cbfalconer@worldnet.att.net>
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <math.h>
+#include "fakesbrk.h"
+#include "cokusMT.h"
+#include "sysquery.h"
+#include <unistd.h>     /* write */
+
+/* NDEBUG allows this to be used for profiling malloc.o */
+#ifndef NDEBUG
+#  include "nmalloc.h"
+#  define  INTERVAL 10  /* for emitting free list dumps */
+#else
+#  define nmalloc   malloc
+#  define nfree     free
+#  define nrealloc  realloc
+#  define nmemalign memalign
+#  define INTERVAL  1000 /* for emitting free list dumps */
+#endif
+
+/* Magic 1500 below must be > MINSBRK in nmalloc.c */
+enum {FAKESIZE = 1234567,
+      HIFAKESZ = 1500,
+      HIFAKE   = FAKESIZE - HIFAKESZ,
+      NFLISTS  = (int)(CHAR_BIT * sizeof(size_t))
+     };
+
+char fakearea[FAKESIZE];
+
+int notquiet;   /* 0 suppresses most output in this module */
+
+/* 1------------------1 */
+
+/* we can fool with this to generate test cases      */
+/* If I could only figure a way to peg the addresses */
+/* the test runs would be a good regression test.    */
+void *fakesbrk(int delta)
+{
+static char *unused = fakearea;
+static char *hiarea = fakearea + HIFAKE;
+char        *next, *p;
+
+   if (hiarea && (delta >= 32) && (delta < HIFAKESZ)) {
+      /* return something above normal use to test
+         action under decreasing sbrk values */
+      p = hiarea;
+      hiarea = 0;
+      return (void *)p;
+   }
+   /* otherwise just act normally */
+   next = unused + delta;
+   if ((unsigned) next > HIFAKE) return (void *)-1;
+   else {
+      p = unused;
+      unused = next;
+      return (void *)p;
+   }
+} /* fakesbrk */
+
+/* =====================================================
+   This portion is an example of using the _sysmalloc()
+   call to access the inner workings of the malloc pkg.
+   Note the exact parallel between these routines and
+   the corresponding ones in nmalloc.c.
+   =====================================================
+*/
+
+/* 1------------------1 */
+
+static struct _sysquery sysinfo;
+void                 *(*freehdrsp)[NFLISTS];
+
+
+#define NONE          sysinfo.nilp
+#define lastsbrk      freehdrs[0]
+#define memblockp     void*
+typedef unsigned int  ulong;
+typedef unsigned char byte;
+
+/* conversion and access macros */
+#define DATAOFFSET sysinfo.data
+
+#define MEMBLKp(p) (memblockp)((byte*)(p) - DATAOFFSET)
+#define PTR(m)     (void*)((byte*)(m) + DATAOFFSET)
+
+/* field access macros (AFTER sysinfo loaded)    */
+/* Examples - replace "m->prv" by "fld(m, prv)"  */
+/*            replace "m->sz"  by "szof(m)"      */
+/* where field is prvf, nxtf, prv, nxt           */
+#define fld(m, field)   *((void**)((char*)m + sysinfo.field))
+#define szof(m)         *(ulong*)((char*)m + sysinfo.sz)
+#define freehdrs        (*freehdrsp)
+
+/* 1------------------1 */
+
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+void showsysquery(void)
+{
+   printf("sysinfo is: nil = %p\n"
+          "    DATAOFFSET  = %d\n"
+          "    gdlo offset = %d\n"
+          "    sz   offset = %d\n"
+          "    prvf offset = %d\n"
+          "    nxtf offset = %d\n"
+          "    nxt  offset = %d\n"
+          "    prv  offset = %d\n"
+          "    ohead       = %d\n"
+          "    &freehdrs   = %p\n"
+          "    &anchors    = %p\n"
+          "    &hookset()  = %p\n",
+          sysinfo.nilp, sysinfo.data, sysinfo.gdlo,
+          sysinfo.sz,  sysinfo.prvf, sysinfo.nxtf,
+          sysinfo.nxt, sysinfo.prv,  sysinfo.ohead,
+          freehdrs, sysinfo.anchors, sysinfo.hookset);
+
+} /* showsysquery */
+
+/* 1------------------1 */
+
+/* m is the allocated ptr treated by MEMBLKp    */
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+static void xshowblock(void *m, char *id)
+{
+   if (m) {
+      printf(" %s %p", id, m);
+      printf(" sz=%u nxt=%p prv=%p nxtf=",
+             szof(m), fld(m, nxt), fld(m, prv));
+      if (fld(m, nxtf)) {
+         if (NONE == fld(m, nxtf))
+            printf("NONE prvf=");
+         else
+            printf("%p prvf=", fld(m, nxtf));
+         if (NONE == fld(m, prvf))
+            printf("NONE");
+         else
+            printf("%p", fld(m, prvf));
+      }
+      else printf("0");
+   }
+   else
+      printf(" %s NULL", id);
+   fflush(stdout);  /* to coexist with internal debuggery */
+} /* xshowblock */
+
+/* 1------------------1 */
+
+/* dump the entire free chain group             */
+/* Fouls if sysinfo has not been initialized    */
+/* See main for sysinfo initialization sequence */
+static void xdumpfree(void)
+{
+   int       i;
+   memblockp m;
+   ulong     totfree;
+
+   totfree = 0;
+   for (i = 0; i < NFLISTS; i++) {
+      if ((m = freehdrs[i])) {
+         printf("\n%2d: ", i);
+         do {
+            printf("%p(%u)->", m, szof(m));
+            totfree += szof(m);
+            m = fld(m, nxtf);
+         } while (m && (NONE != m));
+         printf("0");
+         m = freehdrs[i];
+         while (m && (NONE !=m )) {
+            xshowblock(m, "\n     ");
+            m = fld(m, nxtf);
+         }
+      }
+   }
+   printf("\nTotal Free = %u\n", totfree);
+   fflush(stdout);  /* to coexist with internal debuggery */
+} /* xdumpfree */
+
+/* ========== End of debuggery examples ============= */
+/* ============== Start of tests ==================== */
+
+/* Just allocate increasing sizes */
+void test01(int n)
+{
+   int   i;
+   void *m;
+
+   for (i = 0; i < n; i++) m = nmalloc(65 * i);
+} /* test01 */
+
+/* 1------------------1 */
+
+/* allocate increasing sizes, freeing what was allocated
+   10 items earlier.  Monitor free list every 10th.  Free
+   everything at end.  Perturb sbrk return values.
+*/
+void test02(int n)
+{
+   int   i;
+   void *m[10] = {0};
+
+   for (i = 0; i < n; i++) {
+      nfree(m[i % 10]);
+      m[i % 10] = nmalloc(15 * i);
+      if (0 == (i % 30)) (void)fakesbrk(3);
+      if ( (INTERVAL - 1) == (i % INTERVAL )
+          && notquiet)
+         xdumpfree();
+   }
+   for (i = 0; i < 10; i++) nfree(m[i]);
+   xdumpfree();
+} /* test02 */
+
+/* 1------------------1 */
+
+enum {STDIN = 0, STDOUT, STDERR, STDAUX, STDPRN}; /* handles */
+
+/* made to be compatible with nmalloc internal debugger */
+void inject(int i)
+{
+   char buf[20];
+
+#ifndef NDEBUG
+   sprintf(buf, "%03d: ", i);
+   write(STDOUT, buf, strlen(buf));
+#endif
+} /* inject */
+
+/* 1------------------1 */
+
+/* allocate random sizes, free, finally abort. Perturb sbrk */
+void test03(int n)
+{
+   int   i;
+   void *m[10] = {0};
+
+   if (0 == n) n = 10;
+
+   for (i = 0; i < n; i++) {
+      if (m[i % 10]) inject(i);
+      nfree(m[i % 10]);
+      if (notquiet) inject(i);
+      m[i % 10] = nmalloc(randomMT() % 10000);
+
+      if (0 == i) xshowblock(MEMBLKp(m[0]), "\n*testing*");
+
+      if (0 == (i % 30)) (void)fakesbrk(3);
+      if ( (INTERVAL - 1) == (i % INTERVAL )
+          && notquiet)
+         xdumpfree();
+   }
+   for (i = 0; i < 10; i++) {
+      if (m[i] && notquiet) inject(i);
+      nfree(m[i]);
+   }
+   xdumpfree();
+   if (n & 1) {
+      printf("\nDeliberately refreeing pointer, should abort\n\n");
+      fflush(stdout);
+      nfree(m[0]);
+   }
+} /* test03 */
+
+/* 1------------------1 */
+
+/* allocate random sizes, realloc, free. Perturb sbrk */
+void test04(int n)
+{
+   int   i;
+   void *m[10] = {0};
+   void *temp;
+
+   for (i = 0; i < n; i++) {
+      if (m[i % 10]) inject(i);
+      nfree(m[i % 10]);
+      if (notquiet) inject(i);
+      m[i % 10] = nmalloc(randomMT() % 10000);
+      if (notquiet) inject(i);
+      temp = nrealloc(m[i % 10], randomMT() % 10000);
+      if (temp) m[i % 10] = temp;
+      if (0 == (i % 30)) (void)fakesbrk(3);
+      if ( (INTERVAL - 1) == (i % INTERVAL)
+           && notquiet)
+         xdumpfree();
+   }
+   for (i = 0; i < 10; i++) {
+      if (m[i] && notquiet) inject(i);
+      nfree(m[i]);
+   }
+   xdumpfree();
+} /* test04 */
+
+/* 1------------------1 */
+
+/* made to be compatible with nmalloc internal debugger */
+void showijk(int i, int j, int k)
+{
+   char buf[20];
+
+#ifndef NDEBUG
+   sprintf(buf, "%03d:%d:%d ", i, j, k);
+   write(STDOUT, buf, strlen(buf));
+#endif
+} /* showijk */
+
+/* 1------------------1 */
+
+/* free 10 items, allocate 10 random sizes, realloc 10 random  */
+/* Much like test 4, but a different sequence. No sbrk perturb */
+void test05(int n)
+{
+   int   i, j, k, ix;
+   void *m[10] = {0};
+   void *temp;
+
+   for (i = 0; i < n; i++) {
+      j = (i / 10) % 3;   /* 0, 1, or 2 */
+      k = (i % 10);
+      ix = k + 10 * (i / 30);
+      if (0 == j) {
+         if (notquiet) showijk(i, j, k);
+         temp = nrealloc(m[k], randomMT() % 10000);
+         if (temp) m[k] = temp;
+         if ( (INTERVAL - 1) == (i % INTERVAL)
+             && notquiet)
+            xdumpfree();
+      }
+      if (1 == j) {
+         if (m[k]) {
+            if (notquiet) showijk(i, j, k);
+            nfree(m[k]);
+            m[k] = NULL;
+         }
+         if ( (INTERVAL - 1) == (i % INTERVAL)
+              && notquiet)
+            xdumpfree();
+      }
+      if (2 == j) {
+         if (notquiet) showijk(i, j, k);
+         m[k] = nmalloc(randomMT() % 10000);
+         if ( (INTERVAL - 1) == (i % INTERVAL)
+              && notquiet)
+            xdumpfree();
+      }
+      if (0 == i) (void)fakesbrk(3); /* make 2 blocks */
+   }
+   for (i = 0; i < 10; i++) {
+      if (m[i]) {
+         if (notquiet) inject(i);
+         nfree(m[i]);
+      }
+   }
+   xdumpfree();
+} /* test05 */
+
+/* 1------------------1 */
+
+/* reallocate random sizes continuously */
+void test06(int n)
+{
+   int   i;
+   void *m[10] = {0};
+   void *temp;
+
+   for (i = 0; i < n; i++) {
+      if (notquiet) inject(i);
+      temp = nrealloc(m[i % 10], randomMT() % 10000);
+      if (temp) m[i % 10] = temp;
+      if ( (INTERVAL - 1) == (i % INTERVAL)
+           && notquiet)
+         xdumpfree();
+   }
+   for (i = 0; i < 10; i++) {
+      if (m[i] && notquiet) inject(i);
+      nfree(m[i]);
+   }
+   xdumpfree();
+} /* test06 */
+
+/* 1------------------1 */
+
+/* reallocate random sizes continuously, check data unharmed */
+/* This writes over all allocated memory, so it is a fairly  */
+/* good test that nothing is out of place.                   */
+void test07(int n)
+{
+   int             i, j, k;
+   void           *m[10] = {0};
+   int             sz[10] = {0};
+   int             newsz, minsz;
+   unsigned char  *p;
+
+   void *temp;
+
+   for (i = 0; i < n; i++) {
+      if (notquiet) inject(i);
+      k = i % 10;
+      minsz = newsz = randomMT() % 10000;
+      if (sz[k] < minsz) minsz = sz[k];
+      if (m[k]) {
+         p = m[k];
+         for (j = 0; j < sz[k]; j++) {
+            /* null loop for initial access */
+            p[j] = j & 0xff;
+         }
+      }
+      temp = nrealloc(m[k], newsz);
+      if (temp) {
+         p = m[k] = temp;
+         sz[k] = newsz;
+         for (j = 0; j < minsz; j++) {
+            /* null loop for initial access */
+            if (p[j] != (j & 0xff)) {
+               printf("Data failure at index %d!!\n", j);
+               printf("is %d should be %d\n",
+                       p[j], j & 0xff);
+               fflush(stdout);
+               exit(EXIT_FAILURE);
+            }
+         }
+      }
+      if ( (INTERVAL - 1) == (i % INTERVAL)
+           && notquiet)
+         xdumpfree();
+   }
+   for (i = 0; i < 10; i++) {
+      if (m[i] && notquiet) inject(i);
+      nfree(m[i]);
+   }
+   xdumpfree();
+} /* test07 */
+
+/* 1------------------1 */
+
+/* From the C-FAQ, slightly modified
+ * Most likely value is 0, + or - 5 are rare
+ */
+double gaussrand(void)
+{
+   static double V2, X;
+   static int    phase = 0;
+   double        Y, U1, U2, V1, S;
+
+   if (phase) Y = V2 * X;
+   else {
+      do {
+         U1 = (double)randomMT() / ranMTMAX;
+         U2 = (double)randomMT() / ranMTMAX;
+
+         V1 = 2 * U1 - 1;
+         V2 = 2 * U2 - 1;
+         S = V1 * V1 + V2 * V2;
+      } while (S >= 1 || S == 0);
+
+      Y = V1 * (X = sqrt(-2 * log(S) / S));
+   }
+   phase = 1 - phase;
+   return Y;
+} /* gaussrand */
+
+/* 1------------------1 */
+
+/* maps gaussrand -inf .. 0 into 0..1 and
+ *                0 .. +inf into 1..inf.
+ * Most likely value is slightly less than 1
+ * 5.0 is fairly rare, 120.0 extremely rare
+ */
+double gausspos(void)
+{
+#define GAUSSLIMIT 10.0
+   double r;
+
+   if (GAUSSLIMIT < (r = gaussrand()))  /* limit */
+      r = GAUSSLIMIT;
+   return exp(r);
+} /* gausspos */
+
+/* 1------------------1 */
+
+typedef struct node {
+   struct node *next;
+   char        *wastage;
+} node, *nodeptr;
+
+/* Under development for long term thrashing */
+void test08(int n, int reps)
+{
+   int     i, j;
+   nodeptr root, temp;
+   size_t  sz, totalsz;
+
+   printf("Under development\n"); fflush(stdout);
+   j = 0;
+   do {
+      if (reps) {
+         printf("Repetion %d\n", j + 1); fflush(stdout);
+      }
+      root = NULL; totalsz = 0;
+      for (i = 0; i < n; i++) {
+         /* form singly linked list of various sizes */
+         if (!(temp = nmalloc(sizeof *temp))) {
+            fprintf(stderr, "malloc node failed\n");
+            exit(EXIT_FAILURE);
+         }
+         else {
+            sz = (1 + gausspos()) * 32.0;
+            if (!(temp->wastage = nmalloc(sz))) {
+               fprintf(stderr, "malloc wastage failed\n");
+               exit(EXIT_FAILURE);
+            }
+            else {
+               temp->next = root;
+               root = temp;
+               totalsz += sz;
+            }
+         }
+      } /* for, formed base list */
+
+      xdumpfree();
+
+      /* liberate it all */
+      while (root) {
+         nfree(root->wastage);
+         temp = root->next;
+         nfree(root);
+         root = temp;
+      } /* while */
+
+      xdumpfree();
+   } while (++j < reps);
+} /* test08 */
+
+/* 1------------------1 */
+
+/* Under development for memalign exercise */
+void test09(int n, int reps)
+{
+   int   i;
+   void *p;
+
+   printf("Under development\n"); fflush(stdout);
+   if (!reps) reps = 512;
+   for (i = 0; i < n; i++) {
+     p = nmemalign(reps, 65 * i);
+   }
+} /* test09 */
+
+/* 1------------------1 */
+
+int main(int argc, char *argv[])
+{
+   unsigned long t = 0, n = 0, reps = 0;
+
+   if (argc > 1) t = strtoul(argv[1], NULL, 10);
+   if (argc > 2) n = strtoul(argv[2], NULL, 10);
+   if (argc < 4) notquiet = 1;
+   else {
+      reps = strtoul(argv[3], NULL, 10);
+      notquiet = !(reps & 1);
+   }
+
+   if (0 == n) n = 10;
+
+   printf("test%02lu-%lu (%lu)\n", t, n, reps);
+   fflush(stdout);  /* Needed to coexist with debug pkg */
+
+   sysinfo   = _sysmalloc();
+   freehdrsp = (void*)((byte*)(sysinfo.nilp)-sizeof(void*));
+
+   (void) fakesbrk(1);  /* start it off on odds */
+   switch (t) {
+case 1: test01(n); break;
+case 2: test02(n); break;
+case 3: test03(n); break;
+case 4: test04(n); break;
+case 5: test05(n); break;
+case 6: test06(n); break;
+case 7: test07(n); break;
+case 8: test08(n, reps); break;
+case 9: test09(n, reps); break;
+default:
+        printf("Usage: tnmalloc [testnumber [quantity [reps]]]\n");
+        printf("fakearea at %p through %p (was f594)\n",
+               &fakearea, &fakearea[FAKESIZE-1]);
+        printf("CHAR_BIT * sizeof(size_t) = %lu\n",
+                (unsigned long)(CHAR_BIT * sizeof(size_t)));
+        showsysquery();
+        printf(
+           "Test Purpose\n"
+           "  1  malloc only\n"
+           "  2  malloc and free\n"
+           "  3  malloc(random), free, aborts for odd quantity\n"
+           "  4  malloc(random), realloc(random), and free\n"
+           "  5  malloc(10 random), realloc(10 random) and free 10\n"
+           "  6  realloc(random), monitor free lists\n"
+           "  7  realloc(random), check data unharmed\n"
+           "  8  run a long faked sequence, not complete\n"
+           "  9  test memalign operation\n"
+           "Any odd entry for reps suppresses free list dumps\n"
+           );
+        break;
+   } /* switch (t) */
+   return 0;
+} /* main */
+
+/* ------- tstmalloc -------- */
diff --git a/gcc/config/i386/nmalloc/xref.exe b/gcc/config/i386/nmalloc/xref.exe
new file mode 100644
index 000000000..0823aa85c
Binary files /dev/null and b/gcc/config/i386/nmalloc/xref.exe differ
diff --git a/gcc/config/i386/t-djgpp b/gcc/config/i386/t-djgpp
new file mode 100644
index 000000000..dd3b32ac3
--- /dev/null
+++ b/gcc/config/i386/t-djgpp
@@ -0,0 +1,8 @@
+
+EXTRA_OBJS += djgpp.o
+
+djgpp.o:    $(srcdir)/config/i386/djgpp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+  $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h output.h $(TREE_H) flags.h \
+  $(TM_P_H) $(HASH_TABLE_H) $(GGC_H) $(LTO_STREAMER_H)
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	$(srcdir)/config/i386/djgpp.c
diff --git a/gcc/config/i386/x-djgpp b/gcc/config/i386/x-djgpp
new file mode 100644
index 000000000..932c4a83c
--- /dev/null
+++ b/gcc/config/i386/x-djgpp
@@ -0,0 +1,48 @@
+#-----------------------------------------------------------------------------
+# The following code is copied from config/mh-djgpp as one may 
+# want to run make in gcc build directory instead of toplevel 
+# one (for example 'make restage2' or similar which are not available
+# from top level makefile and we should have the same substitutions 
+# in this case)           
+#-----------------------------------------------------------------------------
+
+# Shorten the target alias so when it is used to set 'libsubdir'
+# the name will work in both short and long filename environments.
+ifeq ($(findstring -pc-msdosdjgpp,$(target_alias)),-pc-msdosdjgpp)
+target_alias=djgpp
+endif
+
+# The version string must be modified to contain just one dot
+# because DOS filenames can only have one dot when long filenames
+# are not available.
+#
+version := $(shell echo $(version) | sed -e 's:\.::2g')
+
+# on DJGPP the 'ln -s' does not work correctly
+LN = cp -p
+LN_S = cp -p
+
+# Replace DJGPP malloc with nmalloc
+EXTRA_OBJS += malloc.o djgpp-stack.o
+EXTRA_GCC_OBJS += malloc.o
+
+# Use a larger stack for CC1, CC1PLUS, etc.
+# EXTRA_OBJS is not sufficient as djgpp-stack.o only contains data definition (_stklen)
+# and as result including it into static library does not help
+BACKEND += djgpp-stack.o
+
+# Some build tools also require larger stack (different object file name
+# used as djgpp-stack.o and djgpp-stack-tools.o may be built with compilers
+# for different targets in case of cross-compiling
+BUILD_RTL += djgpp-stack-tools.o
+
+malloc.o: $(srcdir)/config/i386/nmalloc/nmalloc.c $(srcdir)/config/i386/nmalloc/memalign.c \
+		$(srcdir)/config/i386/nmalloc/sysquery.h
+	$(CC) -c -O2 -W -Wall -DMEMALIGN $< -o $@
+
+djgpp-stack.o: $(srcdir)/config/i386/djgpp-stack.c
+	$(CC) -c -O2 -W -Wall $< -o $@
+
+
+djgpp-stack-tools.o: $(srcdir)/config/i386/djgpp-stack.c
+	$(CC_FOR_BUILD) -c -O2 -W -Wall $< -o $@
diff --git a/gcc/config/i386/xm-djgpp.h b/gcc/config/i386/xm-djgpp.h
index 84470510b..fa337e37d 100644
--- a/gcc/config/i386/xm-djgpp.h
+++ b/gcc/config/i386/xm-djgpp.h
@@ -22,6 +22,28 @@ along with GCC; see the file COPYING3.  If not see
 
 #define HOST_EXECUTABLE_SUFFIX ".exe"
 
+/* Define standard DJGPP installation paths.  */
+/* We override default /usr or /usr/local part with /dev/env/DJDIR which */
+/* points to actual DJGPP installation directory.  */
+
+/* Native system include directory */
+#undef NATIVE_SYSTEM_HEADER_DIR
+#define NATIVE_SYSTEM_HEADER_DIR "/dev/env/DJDIR/include/"
+
+#undef PREFIX_INCLUDE_DIR
+
+/* Search for as.exe and ld.exe in DJGPP's binary directory.  */ 
+#undef MD_EXEC_PREFIX
+#define MD_EXEC_PREFIX "/dev/env/DJDIR/bin/"
+
+/* Standard DJGPP library and startup files */
+#undef MD_STARTFILE_PREFIX
+#define MD_STARTFILE_PREFIX "/dev/env/DJDIR/lib/"
+
+/* Make sure that gcc will not look for .h files in /usr/local/include 
+   unless user explicitly requests it.  */
+#undef LOCAL_INCLUDE_DIR
+
 /* System dependent initialization for collect2
    to tell system() to act like Unix.  */
 #define COLLECT2_HOST_INITIALIZATION \
@@ -57,12 +79,12 @@ along with GCC; see the file COPYING3.  If not see
            to try and figure out what's wrong.  */ \
         char *djgpp = getenv ("DJGPP"); \
         if (djgpp == NULL) \
-          fatal ("environment variable DJGPP not defined"); \
+          fatal_error ("environment variable DJGPP not defined"); \
         else if (access (djgpp, R_OK) == 0) \
-          fatal ("environment variable DJGPP points to missing file '%s'", \
+          fatal_error ("environment variable DJGPP points to missing file '%s'", \
                  djgpp); \
         else \
-          fatal ("environment variable DJGPP points to corrupt file '%s'", \
+          fatal_error ("environment variable DJGPP points to corrupt file '%s'", \
                   djgpp); \
       } \
   } while (0)
@@ -81,3 +103,15 @@ along with GCC; see the file COPYING3.  If not see
       strcat (fixed_path, "/");			\
       (PATH) = xstrdup (fixed_path);		\
     } 
+
+/* Rename libstdc++ to libstdcxx as the first name is not valid for DOS */
+#define LIBSTDCXX "stdcxx"
+#define LIBSTDCXX_PROFILE "stdcxx"
+#define LIBSTDCXX_STATIC "stdcxx"
+
+/* Definition is missing in DJGPP headers. That broke building
+   GNU Fortran compiler in GCC-4.1 */
+typedef unsigned int uint;
+
+#undef MAX_OFILE_ALIGNMENT
+#define MAX_OFILE_ALIGNMENT 128
diff --git a/gcc/configure b/gcc/configure
index f247c8a35..02be91f1f 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -801,6 +801,7 @@ LDFLAGS
 CFLAGS
 CC
 GENINSRC
+libstdcxx_incdir_base
 target_subdir
 host_subdir
 build_subdir
@@ -3315,11 +3316,14 @@ fi
 
 
 # This logic must match libstdc++-v3/acinclude.m4:GLIBCXX_EXPORT_INSTALL_INFO.
+libstdcxx_incdir_base=c++
+
+
 if test x${gcc_gxx_include_dir} = x; then
   if test x${enable_version_specific_runtime_libs} = xyes; then
-    gcc_gxx_include_dir='${libsubdir}/include/c++'
+    gcc_gxx_include_dir='${libsubdir}/include/$(libstdcxx_incdir_base)'
   else
-    libstdcxx_incdir='include/c++/$(version)'
+    libstdcxx_incdir='include/$(libstdcxx_incdir_base)/$(version)'
     if test x$host != x$target; then
        libstdcxx_incdir="$target_alias/$libstdcxx_incdir"
     fi
@@ -17847,7 +17851,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17850 "configure"
+#line 17854 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -17953,7 +17957,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17956 "configure"
+#line 17960 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 2c4f3461e..d26bdd2b3 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -132,11 +132,14 @@ no)	;;
 esac])
 
 # This logic must match libstdc++-v3/acinclude.m4:GLIBCXX_EXPORT_INSTALL_INFO.
+libstdcxx_incdir_base=c++
+AC_SUBST(libstdcxx_incdir_base)
+
 if test x${gcc_gxx_include_dir} = x; then
   if test x${enable_version_specific_runtime_libs} = xyes; then
-    gcc_gxx_include_dir='${libsubdir}/include/c++'
+    gcc_gxx_include_dir='${libsubdir}/include/$(libstdcxx_incdir_base)'
   else
-    libstdcxx_incdir='include/c++/$(version)'
+    libstdcxx_incdir='include/$(libstdcxx_incdir_base)/$(version)'
     if test x$host != x$target; then
        libstdcxx_incdir="$target_alias/$libstdcxx_incdir"
     fi
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 74f88a751..8965ce7d7 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -722,6 +722,14 @@ proper position among the other output files.  */
     %{!pie:%{!shared:%e-fsanitize=thread linking must be done with -pie or -shared}}}}}"
 #endif
 
+#ifndef POST_LINK_SPEC
+#define POST_LINK_SPEC ""
+#endif
+
+#ifndef POST_LINK_SPEC
+#define POST_LINK_SPEC ""
+#endif
+
 /* -u* was put back because both BSD and SysV seem to support it.  */
 /* %{static:} simply prevents an error message if the target machine
    doesn't handle -static.  */
@@ -747,7 +755,7 @@ proper position among the other output files.  */
     %(mflib) " STACK_SPLIT_SPEC "\
     %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} " SANITIZER_SPEC " \
     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
-    %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}"
+    %{!nostdlib:%{!nostartfiles:%E}} %{T*}  \n%(post_link) }}}}}}"
 #endif
 
 #ifndef LINK_LIBGCC_SPEC
@@ -791,6 +799,7 @@ static const char *linker_name_spec = LINKER_NAME;
 static const char *linker_plugin_file_spec = "";
 static const char *lto_wrapper_spec = "";
 static const char *lto_gcc_spec = "";
+static const char *post_link_spec = POST_LINK_SPEC;
 static const char *link_command_spec = LINK_COMMAND_SPEC;
 static const char *link_libgcc_spec = LINK_LIBGCC_SPEC;
 static const char *startfile_prefix_spec = STARTFILE_PREFIX_SPEC;
@@ -1202,10 +1211,12 @@ static const char *const standard_startfile_prefix = STANDARD_STARTFILE_PREFIX;
 static const char *md_exec_prefix = MD_EXEC_PREFIX;
 static const char *md_startfile_prefix = MD_STARTFILE_PREFIX;
 static const char *md_startfile_prefix_1 = MD_STARTFILE_PREFIX_1;
+#ifndef __DJGPP__
 static const char *const standard_startfile_prefix_1
   = STANDARD_STARTFILE_PREFIX_1;
 static const char *const standard_startfile_prefix_2
   = STANDARD_STARTFILE_PREFIX_2;
+#endif
 
 /* A relative path to be used in finding the location of tools
    relative to the driver.  */
@@ -1288,6 +1299,7 @@ static struct spec_list static_specs[] =
   INIT_STATIC_SPEC ("linker_plugin_file",	&linker_plugin_file_spec),
   INIT_STATIC_SPEC ("lto_wrapper",		&lto_wrapper_spec),
   INIT_STATIC_SPEC ("lto_gcc",			&lto_gcc_spec),
+  INIT_STATIC_SPEC ("post_link",                &post_link_spec),
   INIT_STATIC_SPEC ("link_libgcc",		&link_libgcc_spec),
   INIT_STATIC_SPEC ("md_exec_prefix",		&md_exec_prefix),
   INIT_STATIC_SPEC ("md_startfile_prefix",	&md_startfile_prefix),
@@ -6525,6 +6537,7 @@ main (int argc, char **argv)
 		      NULL, PREFIX_PRIORITY_LAST, 0, 1);
 	}
 
+#ifndef __DJGPP__
       /* Sysrooted prefixes are relocated because target_system_root is
 	 also relocated by gcc_exec_prefix.  */
       if (*standard_startfile_prefix_1)
@@ -6535,6 +6548,7 @@ main (int argc, char **argv)
 	add_sysrooted_prefix (&startfile_prefixes,
 			      standard_startfile_prefix_2, "BINUTILS",
 			      PREFIX_PRIORITY_LAST, 0, 1);
+#endif
     }
 
   /* Process any user specified specs in the order given on the command
diff --git a/gcc/ginclude/float.h b/gcc/ginclude/float.h
index dd461d7c8..4916975d9 100644
--- a/gcc/ginclude/float.h
+++ b/gcc/ginclude/float.h
@@ -25,6 +25,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  * ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>
  */
 
+#ifdef __DJGPP__
+#include_next <float.h>
+#endif
+
 #ifndef _FLOAT_H___
 #define _FLOAT_H___
 
diff --git a/gcc/ginclude/stdint-wrap.h b/gcc/ginclude/stdint-wrap.h
index 83b6f70c8..3d628338d 100644
--- a/gcc/ginclude/stdint-wrap.h
+++ b/gcc/ginclude/stdint-wrap.h
@@ -6,7 +6,16 @@
 #  undef __STDC_CONSTANT_MACROS
 #  define __STDC_CONSTANT_MACROS
 # endif
-# include_next <stdint.h>
+# if defined(__DJGPP__)
+#  include <sys/version.h>
+#  if __DJGPP__<2 || (__DJGPP__==2 && __DJGPP_MINOR__<=3)
+#   include "stdint-gcc.h"
+#  else
+#   include_next <stdint.h>
+#  endif   	
+# else
+#  include_next <stdint.h>
+# endif
 #else
 # include "stdint-gcc.h"
 #endif
diff --git a/gcc/lto-streamer-out.c b/gcc/lto-streamer-out.c
index c898c23d6..6cf6876bc 100644
--- a/gcc/lto-streamer-out.c
+++ b/gcc/lto-streamer-out.c
@@ -1081,7 +1081,7 @@ write_global_references (struct output_block *ob,
 
   for (index = 0; index < size; index++)
     {
-      uint32_t slot_num;
+      unsigned slot_num;
 
       t = lto_tree_ref_encoder_get_tree (encoder, index);
       streamer_tree_cache_lookup (ob->writer_cache, t, &slot_num);
@@ -1114,7 +1114,7 @@ lto_output_decl_state_refs (struct output_block *ob,
 			    struct lto_out_decl_state *state)
 {
   unsigned i;
-  uint32_t ref;
+  unsigned ref;
   tree decl;
 
   /* Write reference to FUNCTION_DECL.  If there is not function,
diff --git a/include/libiberty.h b/include/libiberty.h
index cacde800e..013859dfe 100644
--- a/include/libiberty.h
+++ b/include/libiberty.h
@@ -106,7 +106,7 @@ extern int countargv (char**);
    to find the declaration so provide a fully prototyped one.  If it
    is 1, we found it so don't provide any declaration at all.  */
 #if !HAVE_DECL_BASENAME
-#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) || defined (HAVE_DECL_BASENAME)
+#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) || defined (__DJGPP__) || defined (HAVE_DECL_BASENAME)
 extern char *basename (const char *);
 #else
 /* Do not allow basename to be used if there is no prototype seen.  We
diff --git a/libada/Makefile.in b/libada/Makefile.in
index ca02e8db2..90e6bdff6 100644
--- a/libada/Makefile.in
+++ b/libada/Makefile.in
@@ -68,6 +68,12 @@ GCC_DIR=$(MULTIBUILDTOP)../../$(host_subdir)/gcc
 
 target_noncanonical:=@target_noncanonical@
 version := $(shell cat $(srcdir)/../gcc/BASE-VER)
+
+ifneq ($(findstring djgpp, $(build)),)
+tmp_version := $(shell echo $(version) | sed -e 's:\.::2g')
+version := $(tmp_version)
+endif
+
 libsubdir := $(libdir)/gcc/$(target_noncanonical)/$(version)$(MULTISUBDIR)
 ADA_RTS_DIR=$(GCC_DIR)/ada/rts$(subst /,_,$(MULTISUBDIR))
 ADA_RTS_SUBDIR=./rts$(subst /,_,$(MULTISUBDIR))
diff --git a/libbacktrace/mmapio.c b/libbacktrace/mmapio.c
index 60c68c66c..2eddc6ad4 100644
--- a/libbacktrace/mmapio.c
+++ b/libbacktrace/mmapio.c
@@ -47,6 +47,33 @@ POSSIBILITY OF SUCH DAMAGE.  */
 /* This file implements file views and memory allocation when mmap is
    available.  */
 
+#ifdef __DJGPP__
+
+#define MAP_PRIVATE 0
+
+static void *mmap(void *addr, size_t length, int prot, int flags,
+           int fd, off_t offset)
+{
+    (void)addr;
+    (void)length;
+    (void)prot;
+    (void)flags;
+    (void)fd;
+    (void)offset;
+    errno = EINVAL;
+    return MAP_FAILED;
+}
+
+static int munmap(void *addr, size_t length)
+{
+    (void)addr;
+    (void)length;
+    errno = EINVAL;
+    return -1;
+}
+
+#endif
+
 /* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  */
 
 int
diff --git a/libcpp/files.c b/libcpp/files.c
index f4b425645..f222206cb 100644
--- a/libcpp/files.c
+++ b/libcpp/files.c
@@ -718,6 +718,10 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)
     cpp_error (pfile, CPP_DL_WARNING,
 	       "%s is shorter than expected", file->path);
 
+/* For DOS we should handle DOS EOF character (0x1A, ^Z). It is
+   only done if it is really the last character of the file  */
+  if (total>0 && buf[total-1]==0x1A) total--;
+
   file->buffer = _cpp_convert_input (pfile,
 				     CPP_OPTION (pfile, input_charset),
 				     buf, size + 16, total,
diff --git a/libgcc/Makefile.in b/libgcc/Makefile.in
index 990cd4927..ea8e48cad 100644
--- a/libgcc/Makefile.in
+++ b/libgcc/Makefile.in
@@ -179,7 +179,7 @@ STRIP = @STRIP@
 STRIP_FOR_TARGET = $(STRIP)
 
 # Directory in which the compiler finds libraries etc.
-libsubdir = $(libdir)/gcc/$(host_noncanonical)/$(version)
+libsubdir = $(libdir)/gcc/$(host_noncanonical)/@gcc_version_alias@
 # Used to install the shared libgcc.
 slibdir = @slibdir@
 # Maybe used for DLLs on Windows targets.
@@ -207,7 +207,7 @@ export slibdir
 export toolexecdir
 export toolexeclibdir
 
-version := $(shell cat $(srcdir)/../gcc/BASE-VER)
+gcc_version := $(shell cat $(srcdir)/../gcc/BASE-VER)
 
 ifeq ($(decimal_float),yes)
 ifeq ($(enable_decimal_float),bid)
diff --git a/libgcc/config.host b/libgcc/config.host
index 4a7699858..78d297108 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -1145,6 +1145,7 @@ case ${host} in
 i[34567]86-*-darwin* | x86_64-*-darwin* | \
   i[34567]86-*-kfreebsd*-gnu | x86_64-*-kfreebsd*-gnu | \
   i[34567]86-*-linux* | x86_64-*-linux* | \
+  i[34567]86-*-msdosdjgpp* | \
   i[34567]86-*-gnu* | \
   i[34567]86-*-solaris2* | x86_64-*-solaris2.1[0-9]* | \
   i[34567]86-*-cygwin* | i[34567]86-*-mingw* | x86_64-*-mingw* | \
diff --git a/libgcc/configure b/libgcc/configure
index 1425df6c0..4d3b8712b 100644
--- a/libgcc/configure
+++ b/libgcc/configure
@@ -587,6 +587,7 @@ LIPO
 AR
 toolexeclibdir
 toolexecdir
+gcc_version_alias
 target_subdir
 host_subdir
 build_subdir
@@ -2528,6 +2529,19 @@ fi
 target_subdir=${target_noncanonical}
 
 
+# Convert GCC version string (to be used as directory name)
+# Does nothing except for DJGPP
+case "$build" in
+  *-msdosdjgpp*)
+     gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+     ;;
+  *)
+     gcc_version_alias='$(gcc_version)'
+     ;;
+esac
+
+
+
 # Calculate toolexeclibdir
 # Also toolexecdir, though it's only used in toolexeclibdir
 case ${version_specific_libs} in
@@ -2536,7 +2550,7 @@ case ${version_specific_libs} in
     # and header files if --enable-version-specific-runtime-libs option
     # is selected.
     toolexecdir='$(libdir)/gcc/$(target_noncanonical)'
-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version_alias)$(MULTISUBDIR)'
     ;;
   no)
     if test -n "$with_cross_host" &&
diff --git a/libgcc/configure.ac b/libgcc/configure.ac
index 8b7aba582..724accf81 100644
--- a/libgcc/configure.ac
+++ b/libgcc/configure.ac
@@ -120,6 +120,19 @@ ACX_NONCANONICAL_HOST
 ACX_NONCANONICAL_TARGET
 GCC_TOPLEV_SUBDIRS
 
+# Convert GCC version string (to be used as directory name)
+# Does nothing except for DJGPP
+case "$build" in
+  *-msdosdjgpp*)
+     gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+     ;;
+  *)
+     gcc_version_alias='$(gcc_version)'
+     ;; 
+esac
+
+AC_SUBST(gcc_version_alias)
+
 # Calculate toolexeclibdir
 # Also toolexecdir, though it's only used in toolexeclibdir
 case ${version_specific_libs} in
@@ -128,7 +141,7 @@ case ${version_specific_libs} in
     # and header files if --enable-version-specific-runtime-libs option
     # is selected.
     toolexecdir='$(libdir)/gcc/$(target_noncanonical)'
-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version_alias)$(MULTISUBDIR)'
     ;;
   no)
     if test -n "$with_cross_host" &&
diff --git a/libgfortran/Makefile.am b/libgfortran/Makefile.am
index abc23cd1e..9ef21ebf5 100644
--- a/libgfortran/Makefile.am
+++ b/libgfortran/Makefile.am
@@ -41,14 +41,24 @@ libgfortran_la_LDFLAGS = -version-info `grep -v '^\#' $(srcdir)/libtool-version`
 	$(version_arg) -Wc,-shared-libgcc
 libgfortran_la_DEPENDENCIES = $(version_dep) libgfortran.spec $(LIBQUADLIB_DEP)
 
+if DJGPP
+myexeclib_LTLIBRARIES = libgf95begin.la
+else
 myexeclib_LTLIBRARIES = libgfortranbegin.la
-myexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)
+endif
+myexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version_alias)$(MULTISUBDIR)
+if DJGPP
+libgf95begin_la_SOURCES = fmain.c
+libgf95begin_la_LDFLAGS = -static
+libgf95begin_la_LINK = $(LINK) $(libgf95begin_la_LDFLAGS)
+else
 libgfortranbegin_la_SOURCES = fmain.c
 libgfortranbegin_la_LDFLAGS = -static
 libgfortranbegin_la_LINK = $(LINK) $(libgfortranbegin_la_LDFLAGS)
+endif
 
 cafexeclib_LTLIBRARIES = libcaf_single.la
-cafexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)
+cafexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version_alias)$(MULTISUBDIR)
 libcaf_single_la_SOURCES = caf/single.c
 libcaf_single_la_LDFLAGS = -static
 libcaf_single_la_DEPENDENCIES = caf/libcaf.h
diff --git a/libgfortran/Makefile.in b/libgfortran/Makefile.in
index 62b9f7abf..560d943b1 100644
--- a/libgfortran/Makefile.in
+++ b/libgfortran/Makefile.in
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.3 from Makefile.am.
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
-# Foundation, Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -87,12 +87,6 @@ am__nobase_list = $(am__nobase_strip_setup); \
 am__base_list = \
   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
   sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__uninstall_files_from_dir = { \
-  test -z "$$files" \
-    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
-    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
-         $(am__cd) "$$dir" && rm -f $$files; }; \
-  }
 am__installdirs = "$(DESTDIR)$(cafexeclibdir)" \
 	"$(DESTDIR)$(myexeclibdir)" "$(DESTDIR)$(toolexeclibdir)" \
 	"$(DESTDIR)$(toolexeclibdir)"
@@ -101,6 +95,10 @@ LTLIBRARIES = $(cafexeclib_LTLIBRARIES) $(myexeclib_LTLIBRARIES) \
 libcaf_single_la_LIBADD =
 am_libcaf_single_la_OBJECTS = single.lo
 libcaf_single_la_OBJECTS = $(am_libcaf_single_la_OBJECTS)
+libgf95begin_la_LIBADD =
+@DJGPP_TRUE@am_libgf95begin_la_OBJECTS = fmain.lo
+libgf95begin_la_OBJECTS = $(am_libgf95begin_la_OBJECTS)
+@DJGPP_TRUE@am_libgf95begin_la_rpath = -rpath $(myexeclibdir)
 libgfortran_la_LIBADD =
 am__objects_1 = backtrace.lo bounds.lo compile_options.lo \
 	convert_char.lo environ.lo error.lo fpu.lo main.lo memory.lo \
@@ -300,8 +298,9 @@ am__objects_48 = $(am__objects_1) $(am__objects_40) $(am__objects_41) \
 @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo
 libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)
 libgfortranbegin_la_LIBADD =
-am_libgfortranbegin_la_OBJECTS = fmain.lo
+@DJGPP_FALSE@am_libgfortranbegin_la_OBJECTS = fmain.lo
 libgfortranbegin_la_OBJECTS = $(am_libgfortranbegin_la_OBJECTS)
+@DJGPP_FALSE@am_libgfortranbegin_la_rpath = -rpath $(myexeclibdir)
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp = $(SHELL) $(top_srcdir)/../depcomp
 am__depfiles_maybe = depfiles
@@ -327,8 +326,8 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 FCCOMPILE = $(FC) $(AM_FCFLAGS) $(FCFLAGS)
 LTFCCOMPILE = $(LIBTOOL) --tag=FC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=compile $(FC) $(AM_FCFLAGS) $(FCFLAGS)
-SOURCES = $(libcaf_single_la_SOURCES) $(libgfortran_la_SOURCES) \
-	$(libgfortranbegin_la_SOURCES)
+SOURCES = $(libcaf_single_la_SOURCES) $(libgf95begin_la_SOURCES) \
+	$(libgfortran_la_SOURCES) $(libgfortranbegin_la_SOURCES)
 MULTISRCTOP = 
 MULTIBUILDTOP = 
 MULTIDIRS = 
@@ -446,6 +445,7 @@ enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
 extra_ldflags_libgfortran = @extra_ldflags_libgfortran@
+gcc_version_alias = @gcc_version_alias@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
@@ -505,13 +505,17 @@ libgfortran_la_LDFLAGS = -version-info `grep -v '^\#' $(srcdir)/libtool-version`
 	$(version_arg) -Wc,-shared-libgcc
 
 libgfortran_la_DEPENDENCIES = $(version_dep) libgfortran.spec $(LIBQUADLIB_DEP)
-myexeclib_LTLIBRARIES = libgfortranbegin.la
-myexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)
-libgfortranbegin_la_SOURCES = fmain.c
-libgfortranbegin_la_LDFLAGS = -static
-libgfortranbegin_la_LINK = $(LINK) $(libgfortranbegin_la_LDFLAGS)
+@DJGPP_FALSE@myexeclib_LTLIBRARIES = libgfortranbegin.la
+@DJGPP_TRUE@myexeclib_LTLIBRARIES = libgf95begin.la
+myexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version_alias)$(MULTISUBDIR)
+@DJGPP_TRUE@libgf95begin_la_SOURCES = fmain.c
+@DJGPP_TRUE@libgf95begin_la_LDFLAGS = -static
+@DJGPP_TRUE@libgf95begin_la_LINK = $(LINK) $(libgf95begin_la_LDFLAGS)
+@DJGPP_FALSE@libgfortranbegin_la_SOURCES = fmain.c
+@DJGPP_FALSE@libgfortranbegin_la_LDFLAGS = -static
+@DJGPP_FALSE@libgfortranbegin_la_LINK = $(LINK) $(libgfortranbegin_la_LDFLAGS)
 cafexeclib_LTLIBRARIES = libcaf_single.la
-cafexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version)$(MULTISUBDIR)
+cafexeclibdir = $(libdir)/gcc/$(target_alias)/$(gcc_version_alias)$(MULTISUBDIR)
 libcaf_single_la_SOURCES = caf/single.c
 libcaf_single_la_LDFLAGS = -static
 libcaf_single_la_DEPENDENCIES = caf/libcaf.h
@@ -1282,7 +1286,7 @@ all: $(BUILT_SOURCES) config.h
 
 .SUFFIXES:
 .SUFFIXES: .F90 .c .f90 .lo .o .obj
-am--refresh: Makefile
+am--refresh:
 	@:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
@@ -1318,8 +1322,10 @@ $(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
 $(am__aclocal_m4_deps):
 
 config.h: stamp-h1
-	@if test ! -f $@; then rm -f stamp-h1; else :; fi
-	@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) stamp-h1; else :; fi
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
+	else :; fi
 
 stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
 	@rm -f stamp-h1
@@ -1426,12 +1432,14 @@ clean-toolexeclibLTLIBRARIES:
 	  echo "rm -f \"$${dir}/so_locations\""; \
 	  rm -f "$${dir}/so_locations"; \
 	done
-libcaf_single.la: $(libcaf_single_la_OBJECTS) $(libcaf_single_la_DEPENDENCIES) $(EXTRA_libcaf_single_la_DEPENDENCIES) 
+libcaf_single.la: $(libcaf_single_la_OBJECTS) $(libcaf_single_la_DEPENDENCIES) 
 	$(libcaf_single_la_LINK) -rpath $(cafexeclibdir) $(libcaf_single_la_OBJECTS) $(libcaf_single_la_LIBADD) $(LIBS)
-libgfortran.la: $(libgfortran_la_OBJECTS) $(libgfortran_la_DEPENDENCIES) $(EXTRA_libgfortran_la_DEPENDENCIES) 
+libgf95begin.la: $(libgf95begin_la_OBJECTS) $(libgf95begin_la_DEPENDENCIES) 
+	$(libgf95begin_la_LINK) $(am_libgf95begin_la_rpath) $(libgf95begin_la_OBJECTS) $(libgf95begin_la_LIBADD) $(LIBS)
+libgfortran.la: $(libgfortran_la_OBJECTS) $(libgfortran_la_DEPENDENCIES) 
 	$(libgfortran_la_LINK) -rpath $(toolexeclibdir) $(libgfortran_la_OBJECTS) $(libgfortran_la_LIBADD) $(LIBS)
-libgfortranbegin.la: $(libgfortranbegin_la_OBJECTS) $(libgfortranbegin_la_DEPENDENCIES) $(EXTRA_libgfortranbegin_la_DEPENDENCIES) 
-	$(libgfortranbegin_la_LINK) -rpath $(myexeclibdir) $(libgfortranbegin_la_OBJECTS) $(libgfortranbegin_la_LIBADD) $(LIBS)
+libgfortranbegin.la: $(libgfortranbegin_la_OBJECTS) $(libgfortranbegin_la_DEPENDENCIES) 
+	$(libgfortranbegin_la_LINK) $(am_libgfortranbegin_la_rpath) $(libgfortranbegin_la_OBJECTS) $(libgfortranbegin_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -5690,7 +5698,9 @@ uninstall-toolexeclibDATA:
 	@$(NORMAL_UNINSTALL)
 	@list='$(toolexeclib_DATA)'; test -n "$(toolexeclibdir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	dir='$(DESTDIR)$(toolexeclibdir)'; $(am__uninstall_files_from_dir)
+	test -n "$$files" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(toolexeclibdir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(toolexeclibdir)" && rm -f $$files
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -5762,15 +5772,10 @@ install-am: all-am
 
 installcheck: installcheck-am
 install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
 clean-generic:
diff --git a/libgfortran/aclocal.m4 b/libgfortran/aclocal.m4
index 351be9d25..8673daa1a 100644
--- a/libgfortran/aclocal.m4
+++ b/libgfortran/aclocal.m4
@@ -1,8 +1,7 @@
-# generated automatically by aclocal 1.11.3 -*- Autoconf -*-
+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,
-# Inc.
+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -20,15 +19,12 @@ You have another version of autoconf.  It may work, but is not guaranteed to.
 If you have problems, you may need to regenerate the build system entirely.
 To do so, use the procedure documented by the package, typically `autoreconf'.])])
 
-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # AM_AUTOMAKE_VERSION(VERSION)
 # ----------------------------
 # Automake X.Y traces this macro to ensure aclocal.m4 has been
@@ -38,7 +34,7 @@ AC_DEFUN([AM_AUTOMAKE_VERSION],
 [am__api_version='1.11'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.11.3], [],
+m4_if([$1], [1.11.1], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -54,21 +50,19 @@ m4_define([_AM_AUTOCONF_VERSION], [])
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.11.3])dnl
+[AM_AUTOMAKE_VERSION([1.11.1])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
 # $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
 # `$srcdir', `$srcdir/..', or `$srcdir/../..'.
@@ -150,14 +144,14 @@ AC_CONFIG_COMMANDS_PRE(
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009,
-# 2010, 2011 Free Software Foundation, Inc.
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009
+# Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 12
+# serial 10
 
 # There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
 # written in clear, in which case automake, when reading aclocal.m4,
@@ -197,7 +191,6 @@ AC_CACHE_CHECK([dependency style of $depcc],
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
@@ -262,7 +255,7 @@ AC_CACHE_CHECK([dependency style of $depcc],
 	break
       fi
       ;;
-    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
+    msvisualcpp | msvcmsys)
       # This compiler won't grok `-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
@@ -327,13 +320,10 @@ AC_DEFUN([AM_DEP_TRACK],
 if test "x$enable_dependency_tracking" != xno; then
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
-  am__nodep='_no'
 fi
 AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
 AC_SUBST([AMDEPBACKSLASH])dnl
 _AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
-AC_SUBST([am__nodep])dnl
-_AM_SUBST_NOTMAKE([am__nodep])dnl
 ])
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
@@ -555,15 +545,12 @@ for _am_header in $config_headers :; do
 done
 echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
 
-# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,
-# Inc.
+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # AM_PROG_INSTALL_SH
 # ------------------
 # Define $install_sh.
@@ -582,8 +569,8 @@ AC_SUBST(install_sh)])
 # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
 # From Jim Meyering
 
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,
-# 2011 Free Software Foundation, Inc.
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008
+# Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -603,7 +590,7 @@ AC_DEFUN([AM_MAINTAINER_MODE],
        [disable], [m4_define([am_maintainer_other], [enable])],
        [m4_define([am_maintainer_other], [enable])
         m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])
-AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
+AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])
   dnl maintainer-mode's default is 'disable' unless 'enable' is passed
   AC_ARG_ENABLE([maintainer-mode],
 [  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful
@@ -749,15 +736,12 @@ else
 fi
 ])
 
-# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,
-# Inc.
+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # AM_PROG_MKDIR_P
 # ---------------
 # Check for `mkdir -p'.
@@ -780,14 +764,13 @@ esac
 
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software
-# Foundation, Inc.
+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
+# serial 4
 
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
@@ -795,13 +778,13 @@ AC_DEFUN([_AM_MANGLE_OPTION],
 [[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
 
 # _AM_SET_OPTION(NAME)
-# --------------------
+# ------------------------------
 # Set option NAME.  Presently that only means defining a flag for this option.
 AC_DEFUN([_AM_SET_OPTION],
 [m4_define(_AM_MANGLE_OPTION([$1]), 1)])
 
 # _AM_SET_OPTIONS(OPTIONS)
-# ------------------------
+# ----------------------------------
 # OPTIONS is a space-separated list of Automake options.
 AC_DEFUN([_AM_SET_OPTIONS],
 [m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
@@ -877,14 +860,12 @@ Check your system clock])
 fi
 AC_MSG_RESULT(yes)])
 
-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
-
 # AM_PROG_INSTALL_STRIP
 # ---------------------
 # One issue with vendor `install' (even GNU) is that you can't
@@ -907,13 +888,13 @@ fi
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.
+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 3
+# serial 2
 
 # _AM_SUBST_NOTMAKE(VARIABLE)
 # ---------------------------
@@ -922,13 +903,13 @@ AC_SUBST([INSTALL_STRIP_PROGRAM])])
 AC_DEFUN([_AM_SUBST_NOTMAKE])
 
 # AM_SUBST_NOTMAKE(VARIABLE)
-# --------------------------
+# ---------------------------
 # Public sister of _AM_SUBST_NOTMAKE.
 AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -950,11 +931,10 @@ AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
 # a tarball read from stdin.
 #     $(am__untar) < result.tar
 AC_DEFUN([_AM_PROG_TAR],
-[# Always define AMTAR for backward compatibility.  Yes, it's still used
-# in the wild :-(  We should find a proper way to deprecate it ...
-AC_SUBST([AMTAR], ['$${TAR-tar}'])
+[# Always define AMTAR for backward compatibility.
+AM_MISSING_PROG([AMTAR], [tar])
 m4_if([$1], [v7],
-     [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],
+     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
      [m4_case([$1], [ustar],, [pax],,
               [m4_fatal([Unknown tar format])])
 AC_MSG_CHECKING([how to create a $1 tar archive])
diff --git a/libgfortran/configure b/libgfortran/configure
index d26b379db..da2816d0f 100755
--- a/libgfortran/configure
+++ b/libgfortran/configure
@@ -647,13 +647,13 @@ AM_CFLAGS
 AM_FCFLAGS
 toolexeclibdir
 toolexecdir
+gcc_version_alias
 EGREP
 GREP
 CPP
 am__fastdepCC_FALSE
 am__fastdepCC_TRUE
 CCDEPMODE
-am__nodep
 AMDEPBACKSLASH
 AMDEP_FALSE
 AMDEP_TRUE
@@ -667,6 +667,8 @@ CPPFLAGS
 LDFLAGS
 CFLAGS
 CC
+DJGPP_FALSE
+DJGPP_TRUE
 multi_basedir
 MAINT
 MAINTAINER_MODE_FALSE
@@ -3386,11 +3388,11 @@ MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
 
 # We need awk for the "check" target.  The system "awk" is bad on
 # some platforms.
-# Always define AMTAR for backward compatibility.  Yes, it's still used
-# in the wild :-(  We should find a proper way to deprecate it ...
-AMTAR='$${TAR-tar}'
+# Always define AMTAR for backward compatibility.
 
-am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
+AMTAR=${AMTAR-"${am_missing_run}tar"}
+
+am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
 
 
 
@@ -3458,6 +3460,16 @@ fi
 ac_config_commands="$ac_config_commands default-1"
 
 
+# Add test for DJGPP
+ if echo $build | grep msdosdjgpp; then
+  DJGPP_TRUE=
+  DJGPP_FALSE='#'
+else
+  DJGPP_TRUE='#'
+  DJGPP_FALSE=
+fi
+
+
 # Handy for debugging:
 #AC_MSG_NOTICE($build / $host / $target / $host_alias / $target_alias); sleep 5
 
@@ -3523,7 +3535,6 @@ fi
 if test "x$enable_dependency_tracking" != xno; then
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
-  am__nodep='_no'
 fi
  if test "x$enable_dependency_tracking" != xno; then
   AMDEP_TRUE=
@@ -4341,7 +4352,6 @@ else
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
@@ -4401,7 +4411,7 @@ else
 	break
       fi
       ;;
-    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
+    msvisualcpp | msvcmsys)
       # This compiler won't grok `-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
@@ -4917,6 +4927,19 @@ $as_echo "$ac_cv_safe_to_define___extensions__" >&6; }
 
 
 
+# Convert GCC version string (to be used as directory name)
+# Does nothing except for DJGPP
+case "$build" in
+  *-msdosdjgpp*)
+     gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+     ;;
+  *)
+     gcc_version_alias='$(gcc_version)'
+     ;;
+esac
+
+
+
 # Calculate toolexeclibdir
 # Also toolexecdir, though it's only used in toolexeclibdir
 case ${version_specific_libs} in
@@ -4925,7 +4948,7 @@ case ${version_specific_libs} in
     # and header files if --enable-version-specific-runtime-libs option
     # is selected.
     toolexecdir='$(libdir)/gcc/$(target_alias)'
-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version_alias)$(MULTISUBDIR)'
     ;;
   no)
     if test -n "$with_cross_host" &&
@@ -5517,7 +5540,6 @@ else
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
-  rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
@@ -5577,7 +5599,7 @@ else
 	break
       fi
       ;;
-    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
+    msvisualcpp | msvcmsys)
       # This compiler won't grok `-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
@@ -12340,7 +12362,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 12343 "configure"
+#line 12365 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -12446,7 +12468,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 12449 "configure"
+#line 12471 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -26592,6 +26614,10 @@ if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
   as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${DJGPP_TRUE}" && test -z "${DJGPP_FALSE}"; then
+  as_fn_error "conditional \"DJGPP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
   as_fn_error "conditional \"AMDEP\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
diff --git a/libgfortran/configure.ac b/libgfortran/configure.ac
index bdb71ff3d..a837cd87f 100644
--- a/libgfortran/configure.ac
+++ b/libgfortran/configure.ac
@@ -72,6 +72,9 @@ AM_INIT_AUTOMAKE([1.9.6 no-define foreign no-dist -Wall -Wno-portability])
 AM_MAINTAINER_MODE
 AM_ENABLE_MULTILIB(, ..)
 
+# Add test for DJGPP
+AM_CONDITIONAL(DJGPP,echo $build | grep msdosdjgpp)
+
 # Handy for debugging:
 #AC_MSG_NOTICE($build / $host / $target / $host_alias / $target_alias); sleep 5
 
@@ -87,6 +90,19 @@ fi
 
 AC_USE_SYSTEM_EXTENSIONS
 
+# Convert GCC version string (to be used as directory name)
+# Does nothing except for DJGPP
+case "$build" in
+  *-msdosdjgpp*)
+     gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+     ;;
+  *)
+     gcc_version_alias='$(gcc_version)'
+     ;; 
+esac
+
+AC_SUBST(gcc_version_alias)
+
 # Calculate toolexeclibdir
 # Also toolexecdir, though it's only used in toolexeclibdir
 case ${version_specific_libs} in
@@ -95,7 +111,7 @@ case ${version_specific_libs} in
     # and header files if --enable-version-specific-runtime-libs option
     # is selected.
     toolexecdir='$(libdir)/gcc/$(target_alias)'
-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version_alias)$(MULTISUBDIR)'
     ;;
   no)
     if test -n "$with_cross_host" &&
diff --git a/libgfortran/intrinsics/chmod.c b/libgfortran/intrinsics/chmod.c
index 363d80315..98c0cc3d3 100644
--- a/libgfortran/intrinsics/chmod.c
+++ b/libgfortran/intrinsics/chmod.c
@@ -464,7 +464,7 @@ clause_done:
 	if ((ugo[2] || honor_umask) && !rwxXstugo[8])
 	  file_mode = (file_mode & ~(S_IROTH | S_IWOTH | S_IXOTH))
 		      | (new_mode & (S_IROTH | S_IWOTH | S_IXOTH));
-#ifndef __VXWORKS__
+#if !defined(__VXWORKS__) && !defined(__DJGPP__)
 	if (is_dir && rwxXstugo[5])
 	  file_mode |= S_ISVTX;
 	else if (!is_dir)
@@ -476,7 +476,7 @@ clause_done:
       {
 	/* Clear '-'.  */
 	file_mode &= ~new_mode;
-#if !defined( __MINGW32__) && !defined (__VXWORKS__)
+#if !defined( __MINGW32__) && !defined (__VXWORKS__) && !defined(__DJGPP__)
 	if (rwxXstugo[5] || !is_dir)
 	  file_mode &= ~S_ISVTX;
 #endif
@@ -484,7 +484,7 @@ clause_done:
     else if (set_mode == 3)
       {
 	file_mode |= new_mode;
-#if !defined (__MINGW32__) && !defined (__VXWORKS__)
+#if !defined (__MINGW32__) && !defined (__VXWORKS__) && !defined(__DJGPP__)
 	if (rwxXstugo[5] && is_dir)
 	  file_mode |= S_ISVTX;
 	else if (!is_dir)
diff --git a/libgfortran/io/unix.c b/libgfortran/io/unix.c
index 185d0dca1..148f958c3 100644
--- a/libgfortran/io/unix.c
+++ b/libgfortran/io/unix.c
@@ -215,6 +215,9 @@ typedef struct
 }
 unix_stream;
 
+#ifdef __DJGPP__
+#include <io.h>
+#endif
 
 /* fix_fd()-- Given a file descriptor, make sure it is not one of the
  * standard descriptors, returning a non-standard descriptor.  If the
@@ -1083,8 +1086,13 @@ tempfile_open (const char *tempdir, char **fname)
   char * template = xmalloc (tempdirlen + 23);
 
 #ifdef HAVE_MKSTEMP
+#ifdef __DJGPP__
+  /* Default filename is too long for DOS. */
+  snprintf (template, tempdirlen + 23, "%s/gfXXXXXX", tempdir);
+#else
   snprintf (template, tempdirlen + 23, "%s%sgfortrantmpXXXXXX", 
 	    tempdir, slash);
+#endif
 
 #ifdef HAVE_UMASK
   /* Temporarily set the umask such that the file has 0600 permissions.  */
@@ -1374,6 +1382,13 @@ open_external (st_parameter_open *opp, unit_flags *flags)
     return NULL;
   fd = fix_fd (fd);
 
+#ifdef __DJGPP__
+  if (flags->form == FORM_UNFORMATTED)
+    {
+      setmode (fd, O_BINARY);
+    }
+#endif
+
   return fd_to_stream (fd);
 }
 
diff --git a/libiberty/config/mh-djgpp b/libiberty/config/mh-djgpp
new file mode 100644
index 000000000..829a268b6
--- /dev/null
+++ b/libiberty/config/mh-djgpp
@@ -0,0 +1,3 @@
+EXTRA_OFILES=asprintf.o mempcpy.o mkstemps.o sigsetmask.o strndup.o strverscmp.o vasprintf.o
+# Only DJGPP v2.04pre have snprinf() and vsnprintf(). Therefore take also them
+EXTRA_OFILES+=snprintf.o vsnprintf.o
diff --git a/libiberty/configure b/libiberty/configure
index 536702742..a9fa606be 100755
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -4842,6 +4842,7 @@ case "${host}" in
   *-*-freebsd2.2.[012])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[34567]86-*-windows*)	frag=mh-windows ;;
+  i[34567]86-*-msdosdjgpp)	frag=mh-djgpp ;;
 esac
 
 if [ -n "${frag}" ]; then
diff --git a/libiberty/configure.ac b/libiberty/configure.ac
index c76389426..25ce8ce58 100644
--- a/libiberty/configure.ac
+++ b/libiberty/configure.ac
@@ -185,6 +185,7 @@ case "${host}" in
   *-*-freebsd2.2.[[012]])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[[34567]]86-*-windows*)	frag=mh-windows ;;
+  i[[34567]]86-*-msdosdjgpp)	frag=mh-djgpp ;;
 esac
 
 if [[ -n "${frag}" ]]; then
diff --git a/libiberty/make-relative-prefix.c b/libiberty/make-relative-prefix.c
index fe639d18b..88d3be025 100644
--- a/libiberty/make-relative-prefix.c
+++ b/libiberty/make-relative-prefix.c
@@ -82,6 +82,7 @@ relative prefix can be found, return @code{NULL}.
 #  define HAVE_DOS_BASED_FILE_SYSTEM
 #  define HAVE_HOST_EXECUTABLE_SUFFIX
 #  define HOST_EXECUTABLE_SUFFIX ".exe"
+#  define FILENAME_COMPARE strcasecmp
 #  ifndef DIR_SEPARATOR_2 
 #    define DIR_SEPARATOR_2 '\\'
 #  endif
@@ -97,6 +98,10 @@ relative prefix can be found, return @code{NULL}.
 	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
 #endif
 
+#ifndef FILENAME_COMPARE
+#  define FILENAME_COMPARE strcmp
+#endif
+
 #define DIR_UP ".."
 
 static char *save_string (const char *, int);
@@ -334,7 +339,7 @@ make_relative_prefix_1 (const char *progname, const char *bin_prefix,
     {
       for (i = 0; i < bin_num; i++)
 	{
-	  if (strcmp (prog_dirs[i], bin_dirs[i]) != 0)
+	  if (FILENAME_COMPARE (prog_dirs[i], bin_dirs[i]) != 0)
 	    break;
 	}
 
@@ -350,7 +355,7 @@ make_relative_prefix_1 (const char *progname, const char *bin_prefix,
   n = (prefix_num < bin_num) ? prefix_num : bin_num;
   for (common = 0; common < n; common++)
     {
-      if (strcmp (bin_dirs[common], prefix_dirs[common]) != 0)
+      if (FILENAME_COMPARE (bin_dirs[common], prefix_dirs[common]) != 0)
 	break;
     }
 
diff --git a/libiberty/make-temp-file.c b/libiberty/make-temp-file.c
index 7b74f8179..9272dccda 100644
--- a/libiberty/make-temp-file.c
+++ b/libiberty/make-temp-file.c
@@ -55,6 +55,29 @@ extern int mkstemps (char *, int);
 #define DIR_SEPARATOR '/'
 #endif
 
+#if defined (_WIN32) || defined (__MSDOS__) \
+    || defined (__DJGPP__) || defined (__OS2__)
+#  define HAVE_DOS_BASED_FILE_SYSTEM
+#  ifndef DIR_SEPARATOR_2 
+#    define DIR_SEPARATOR_2 '\\'
+#  endif
+#endif
+
+/* Define IS_DIR_SEPARATOR. VMS uses '::', ':', '[...]' and '<...>' to
+   separate the different components of a file specification.  It's a
+   bit of a stretch to call ':', ']' and '>' directory separators, so
+   just define the test to find the file name component.  */
+#ifdef VMS
+#  define IS_DIR_SEPARATOR(ch) ((ch) == ':' || (ch) == ']' || (ch) == '>')
+#else
+#  ifndef DIR_SEPARATOR_2
+#    define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
+#  else
+#    define IS_DIR_SEPARATOR(ch) \
+	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
+#  endif
+#endif
+
 /* Name of temporary file.
    mktemp requires 6 trailing X's.  */
 #define TEMP_FILE "ccXXXXXX"
@@ -143,7 +166,8 @@ choose_tmpdir (void)
       len = strlen (base);
       tmpdir = XNEWVEC (char, len + 2);
       strcpy (tmpdir, base);
-      tmpdir[len] = DIR_SEPARATOR;
+      if (len>0 && !IS_DIR_SEPARATOR(tmpdir[len-1]))   
+          tmpdir[len] = DIR_SEPARATOR;
       tmpdir[len+1] = '\0';
       memoized_tmpdir = tmpdir;
 #else /* defined(_WIN32) && !defined(__CYGWIN__) */
diff --git a/libobjc/Makefile.in b/libobjc/Makefile.in
index 4f11c9284..5b501b79b 100644
--- a/libobjc/Makefile.in
+++ b/libobjc/Makefile.in
@@ -38,6 +38,8 @@ multi_basedir = @multi_basedir@
 toolexecdir = @toolexecdir@
 # Toolexecdir is used only by toolexeclibdir
 toolexeclibdir = @toolexeclibdir@
+# Editted (if neccessary) GCC version string
+gcc_version_dir = @gcc_version_dir@
 
 includedirname = @includedirname@
 libsuffix = @libsuffix@
@@ -50,7 +52,7 @@ top_builddir = .
 -include ../boehm-gc/threads.mk
 
 libdir = $(exec_prefix)/lib
-libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)
+libsubdir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version_dir)
 
 # Multilib support variables.
 MULTISRCTOP =
diff --git a/libobjc/configure b/libobjc/configure
index dd39d7ec8..ee5db88e3 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -600,6 +600,7 @@ ac_includes_default="\
 
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+gcc_version_dir
 SET_MAKE
 CPP
 OTOOL64
@@ -10601,7 +10602,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10604 "configure"
+#line 10605 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10707,7 +10708,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10710 "configure"
+#line 10711 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11478,7 +11479,7 @@ if test "${enable_sjlj_exceptions+set}" = set; then :
   enableval=$enable_sjlj_exceptions; :
 else
   cat > conftest.$ac_ext << EOF
-#line 11481 "configure"
+#line 11482 "configure"
 @interface Frob
 @end
 @implementation Frob
@@ -11530,6 +11531,19 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_exception_model_name" >&5
 $as_echo "$ac_exception_model_name" >&6; }
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+case $build in
+	i?86-*-msdosdjgpp*)
+		gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+		;;
+
+	* )
+		gcc_version_dir='$(gcc_version)'
+		;;
+esac
+
+
 # ------
 # Output
 # ------
diff --git a/libobjc/configure.ac b/libobjc/configure.ac
index 53e5f70ab..dc206b332 100644
--- a/libobjc/configure.ac
+++ b/libobjc/configure.ac
@@ -266,6 +266,19 @@ fi
 AC_LANG_POP(C)
 AC_MSG_RESULT($ac_exception_model_name)
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+[case $build in
+	i?86-*-msdosdjgpp*)
+		gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+		;;
+
+	* )
+		gcc_version_dir='$(gcc_version)'
+		;;
+esac]
+AC_SUBST(gcc_version_dir)
+
 # ------
 # Output
 # ------
diff --git a/libquadmath/Makefile.am b/libquadmath/Makefile.am
index 6c97ee81c..c1456eee5 100644
--- a/libquadmath/Makefile.am
+++ b/libquadmath/Makefile.am
@@ -40,7 +40,7 @@ libquadmath_la_LDFLAGS = -version-info `grep -v '^\#' $(srcdir)/libtool-version`
 libquadmath_la_DEPENDENCIES = $(version_dep) $(libquadmath_la_LIBADD)
 
 nodist_libsubinclude_HEADERS = quadmath.h quadmath_weak.h
-libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include
+libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version_alias)/include
 
 libquadmath_la_SOURCES = \
   math/x2y2m1q.c math/isinf_nsq.c math/acoshq.c math/fmodq.c \
diff --git a/libquadmath/Makefile.in b/libquadmath/Makefile.in
index 92c5d256d..a0afb377b 100644
--- a/libquadmath/Makefile.in
+++ b/libquadmath/Makefile.in
@@ -271,6 +271,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
@@ -324,7 +325,7 @@ AUTOMAKE_OPTIONS = 1.8 foreign
 
 @BUILD_LIBQUADMATH_TRUE@libquadmath_la_DEPENDENCIES = $(version_dep) $(libquadmath_la_LIBADD)
 @BUILD_LIBQUADMATH_TRUE@nodist_libsubinclude_HEADERS = quadmath.h quadmath_weak.h
-@BUILD_LIBQUADMATH_TRUE@libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include
+@BUILD_LIBQUADMATH_TRUE@libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version_alias)/include
 @BUILD_LIBQUADMATH_TRUE@libquadmath_la_SOURCES = \
 @BUILD_LIBQUADMATH_TRUE@  math/x2y2m1q.c math/isinf_nsq.c math/acoshq.c math/fmodq.c \
 @BUILD_LIBQUADMATH_TRUE@  math/acosq.c math/frexpq.c \
diff --git a/libquadmath/configure b/libquadmath/configure
index 8b8ca499d..20db7bcfc 100755
--- a/libquadmath/configure
+++ b/libquadmath/configure
@@ -613,6 +613,7 @@ LIBQUAD_USE_SYMVER_FALSE
 LIBQUAD_USE_SYMVER_TRUE
 toolexeclibdir
 toolexecdir
+gcc_version_alias
 MAINT
 MAINTAINER_MODE_FALSE
 MAINTAINER_MODE_TRUE
@@ -10565,7 +10566,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10568 "configure"
+#line 10569 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10671,7 +10672,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10674 "configure"
+#line 10675 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11909,6 +11910,19 @@ ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
+# Convert GCC version string (to be used as directory name)
+# Does nothing except for DJGPP
+case "$build" in
+  *-msdosdjgpp*)
+     gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+     ;;
+  *)
+     gcc_version_alias='$(gcc_version)'
+     ;;
+esac
+
+
+
 # Calculate toolexeclibdir
 # Also toolexecdir, though it's only used in toolexeclibdir
 case ${version_specific_libs} in
@@ -11917,7 +11931,7 @@ case ${version_specific_libs} in
     # and header files if --enable-version-specific-runtime-libs option
     # is selected.
     toolexecdir='$(libdir)/gcc/$(target_alias)'
-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version_alias)$(MULTISUBDIR)'
     ;;
   no)
     if test -n "$with_cross_host" &&
diff --git a/libquadmath/configure.ac b/libquadmath/configure.ac
index eb4fe8c8d..e1441fa53 100644
--- a/libquadmath/configure.ac
+++ b/libquadmath/configure.ac
@@ -83,6 +83,19 @@ if test "x$GCC" != "xyes"; then
 fi
 AC_PROG_CPP
 
+# Convert GCC version string (to be used as directory name)
+# Does nothing except for DJGPP
+case "$build" in
+  *-msdosdjgpp*)
+     gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+     ;;
+  *)
+     gcc_version_alias='$(gcc_version)'
+     ;; 
+esac
+
+AC_SUBST(gcc_version_alias)
+
 # Calculate toolexeclibdir
 # Also toolexecdir, though it's only used in toolexeclibdir
 case ${version_specific_libs} in
@@ -91,7 +104,7 @@ case ${version_specific_libs} in
     # and header files if --enable-version-specific-runtime-libs option
     # is selected.
     toolexecdir='$(libdir)/gcc/$(target_alias)'
-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+    toolexeclibdir='$(toolexecdir)/$(gcc_version_alias)$(MULTISUBDIR)'
     ;;
   no)
     if test -n "$with_cross_host" &&
diff --git a/libquadmath/printf/printf_fphex.c b/libquadmath/printf/printf_fphex.c
index fc960f38e..c460a8339 100644
--- a/libquadmath/printf/printf_fphex.c
+++ b/libquadmath/printf/printf_fphex.c
@@ -30,6 +30,11 @@
 #include "_itoa.h"
 #include "_itowa.h"
 
+#if defined(__DJGPP__) && __DJGPP__==2 && __DJGPP_MINOR__<4
+/* Have to somehow pull in ssize_t from sys/djtypes.h */
+#include <unistd.h>
+#endif
+
 
 /* Macros for doing the actual output.  */
 
diff --git a/libquadmath/printf/quadmath-printf.c b/libquadmath/printf/quadmath-printf.c
index b70f432cc..f0ddd91f0 100644
--- a/libquadmath/printf/quadmath-printf.c
+++ b/libquadmath/printf/quadmath-printf.c
@@ -24,6 +24,11 @@ Boston, MA 02110-1301, USA.  */
 #include <stdio.h>
 #include "quadmath-printf.h"
 
+#if defined(__DJGPP__) && __DJGPP__==2 && __DJGPP_MINOR__<4
+/* Have to somehow pull in ssize_t from sys/djtypes.h */
+#include <unistd.h>
+#endif
+
 /* Read a simple integer from a string and update the string pointer.
    It is assumed that the first character is a digit.  */
 static unsigned int
diff --git a/libquadmath/printf/quadmath-printf.h b/libquadmath/printf/quadmath-printf.h
index 32ebcec92..96498b7c4 100644
--- a/libquadmath/printf/quadmath-printf.h
+++ b/libquadmath/printf/quadmath-printf.h
@@ -29,7 +29,8 @@ Boston, MA 02110-1301, USA.  */
 #ifdef HAVE_CTYPE_H
 #include <ctype.h>
 #endif
-#ifdef HAVE_WCHAR_H
+#if defined(HAVE_WCHAR_H) && !defined(__DJGPP__)
+/* DJGPP wchar.h is not good enough */
 #include <wchar.h>
 #endif
 #ifdef HAVE_WCTYPE_H
@@ -44,7 +45,7 @@ Boston, MA 02110-1301, USA.  */
 #include "quadmath-imp.h"
 #include "gmp-impl.h"
 
-#ifdef HAVE_WCHAR_H
+#if defined(HAVE_WCHAR_H) && !defined(__DJGPP__)
 #define L_(x) L##x
 #else
 #define L_(x) x
diff --git a/libssp/Makefile.am b/libssp/Makefile.am
index 5a2ecac1f..3a5c240f0 100644
--- a/libssp/Makefile.am
+++ b/libssp/Makefile.am
@@ -39,7 +39,7 @@ AM_CFLAGS = -Wall
 toolexeclib_LTLIBRARIES = libssp.la libssp_nonshared.la
 
 target_noncanonical = @target_noncanonical@
-libsubincludedir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include
+libsubincludedir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version_dir)/include
 nobase_libsubinclude_HEADERS = ssp/ssp.h ssp/string.h ssp/stdio.h ssp/unistd.h
 
 libssp_la_SOURCES = \
diff --git a/libssp/Makefile.in b/libssp/Makefile.in
index a7db7a9c0..58551a20b 100644
--- a/libssp/Makefile.in
+++ b/libssp/Makefile.in
@@ -207,6 +207,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_dir = @gcc_version_dir@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
@@ -259,7 +260,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
 @LIBSSP_USE_SYMVER_SUN_TRUE@@LIBSSP_USE_SYMVER_TRUE@version_dep = ssp.map-sun
 AM_CFLAGS = -Wall
 toolexeclib_LTLIBRARIES = libssp.la libssp_nonshared.la
-libsubincludedir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include
+libsubincludedir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version_dir)/include
 nobase_libsubinclude_HEADERS = ssp/ssp.h ssp/string.h ssp/stdio.h ssp/unistd.h
 libssp_la_SOURCES = \
 	ssp.c gets-chk.c memcpy-chk.c memmove-chk.c mempcpy-chk.c \
diff --git a/libssp/configure b/libssp/configure
index b26c0b335..db019f6eb 100755
--- a/libssp/configure
+++ b/libssp/configure
@@ -602,6 +602,7 @@ ac_subst_vars='am__EXEEXT_FALSE
 am__EXEEXT_TRUE
 LTLIBOBJS
 LIBOBJS
+gcc_version_dir
 toolexeclibdir
 toolexecdir
 enable_static
@@ -10664,7 +10665,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10667 "configure"
+#line 10668 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10770,7 +10771,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10773 "configure"
+#line 10774 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11068,6 +11069,19 @@ else
   multilib_arg=
 fi
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+case $build in
+       i?86-*-msdosdjgpp*)
+               gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+               ;;
+
+       * )
+               gcc_version_dir='$(gcc_version)'
+               ;;
+esac
+
+
 ac_config_files="$ac_config_files Makefile ssp/ssp.h"
 
 cat >confcache <<\_ACEOF
diff --git a/libssp/configure.ac b/libssp/configure.ac
index 93dfa8da4..2b252d43d 100644
--- a/libssp/configure.ac
+++ b/libssp/configure.ac
@@ -195,5 +195,18 @@ else
   multilib_arg=
 fi
 
+# For DJGPP there should not be more than 1 dot. Therefore edit
+# version in case of DJGPP
+[case $build in
+       i?86-*-msdosdjgpp*)
+               gcc_version_dir='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+               ;;
+
+       * )
+               gcc_version_dir='$(gcc_version)'
+               ;;
+esac]
+AC_SUBST(gcc_version_dir)
+
 AC_CONFIG_FILES([Makefile ssp/ssp.h])
 AC_OUTPUT
diff --git a/libstdc++-v3/Makefile.in b/libstdc++-v3/Makefile.in
index ab7caafed..c362f50df 100644
--- a/libstdc++-v3/Makefile.in
+++ b/libstdc++-v3/Makefile.in
@@ -235,6 +235,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -259,6 +260,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index 655422289..1481eed53 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -813,9 +813,22 @@ AC_DEFUN([GLIBCXX_EXPORT_INSTALL_INFO], [
     [version_specific_libs=no])
   AC_MSG_RESULT($version_specific_libs)
 
+  # Convert GCC version string (to be used as directory name)
+  # Does nothing except for DJGPP
+  case "$build" in
+    *-msdosdjgpp*)
+       libstdcxx_incdir_base=cxx
+       gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+       ;;
+    *)
+       libstdcxx_incdir_base=c++
+       gcc_version_alias='$(gcc_version)'
+       ;; 
+  esac
+
   # Default case for install directory for include files.
   if test $version_specific_libs = no && test $gxx_include_dir = no; then
-    gxx_include_dir='include/c++/${gcc_version}'
+    gxx_include_dir='include/$(libstdcxx_incdir_base)/${gcc_version_alias}'
     if test -n "$with_cross_host" &&
        test x"$with_cross_host" != x"no"; then
       gxx_include_dir='${prefix}/${target_alias}/'"$gxx_include_dir"
@@ -831,10 +844,10 @@ AC_DEFUN([GLIBCXX_EXPORT_INSTALL_INFO], [
     # is selected.  FIXME: these variables are misnamed, there are
     # no executables installed in _toolexecdir or _toolexeclibdir.
     if test x"$gxx_include_dir" = x"no"; then
-      gxx_include_dir='${libdir}/gcc/${host_alias}/${gcc_version}/include/c++'
+      gxx_include_dir='${libdir}/gcc/${host_alias}/${gcc_version_alias}/include/${libstdcxx_incdir_base}'
     fi
     glibcxx_toolexecdir='${libdir}/gcc/${host_alias}'
-    glibcxx_toolexeclibdir='${toolexecdir}/${gcc_version}$(MULTISUBDIR)'
+    glibcxx_toolexeclibdir='${toolexecdir}/${gcc_version_alias}$(MULTISUBDIR)'
   fi
 
   # Calculate glibcxx_toolexecdir, glibcxx_toolexeclibdir
@@ -862,6 +875,8 @@ AC_DEFUN([GLIBCXX_EXPORT_INSTALL_INFO], [
   AC_SUBST(gxx_include_dir)
   AC_SUBST(glibcxx_toolexecdir)
   AC_SUBST(glibcxx_toolexeclibdir)
+  AC_SUBST(libstdcxx_incdir_base)
+  AC_SUBST(gcc_version_alias)
 ])
 
 
diff --git a/libstdc++-v3/config/os/djgpp/error_constants.h b/libstdc++-v3/config/os/djgpp/error_constants.h
index 58cf9b8d0..be256d2f5 100644
--- a/libstdc++-v3/config/os/djgpp/error_constants.h
+++ b/libstdc++-v3/config/os/djgpp/error_constants.h
@@ -1,6 +1,6 @@
-// Specific definitions for DJGPP platform  -*- C++ -*-
+// Specific definitions for generic platforms  -*- C++ -*-
 
-// Copyright (C) 2010-2013 Free Software Foundation, Inc.
+// Copyright (C) 2007-2013 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -37,26 +37,28 @@ namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-// Most of the commented-out error codes are socket-related and could be
-// replaced by Winsock WSA-prefixed equivalents.
   enum class errc
     {
-//    address_family_not_supported = 		EAFNOSUPPORT,
-//    address_in_use = 				EADDRINUSE,
-//    address_not_available = 			EADDRNOTAVAIL,
-//    already_connected = 			EISCONN,
+      //address_family_not_supported = 		EAFNOSUPPORT,
+      //address_in_use = 			EADDRINUSE,
+      //address_not_available = 		EADDRNOTAVAIL,
+      //already_connected = 			EISCONN,
       argument_list_too_long = 			E2BIG,
       argument_out_of_domain = 			EDOM,
       bad_address = 				EFAULT,
       bad_file_descriptor = 			EBADF,
-//    bad_message = 				EBADMSG,
+
+#ifdef _GLIBCXX_HAVE_EBADMSG
+      bad_message = 				EBADMSG,
+#endif
+
       broken_pipe = 				EPIPE,
-//    connection_aborted = 			ECONNABORTED,
-//    connection_already_in_progress = 		EALREADY,
-//    connection_refused = 			ECONNREFUSED,
-//    connection_reset = 			ECONNRESET,
-//    cross_device_link = 			EXDEV,
-//    destination_address_required = 		EDESTADDRREQ,
+      //connection_aborted = 			ECONNABORTED,
+      //connection_already_in_progress = 	EALREADY,
+      //connection_refused = 			ECONNREFUSED,
+      //connection_reset = 			ECONNRESET,
+      cross_device_link = 			EXDEV,
+      //destination_address_required = 		EDESTADDRREQ,
       device_or_resource_busy = 		EBUSY,
       directory_not_empty = 			ENOTEMPTY,
       executable_format_error = 		ENOEXEC,
@@ -64,8 +66,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       file_too_large = 				EFBIG,
       filename_too_long = 			ENAMETOOLONG,
       function_not_supported = 			ENOSYS,
-//    host_unreachable = 			EHOSTUNREACH,
-//    identifier_removed = 			EIDRM,
+      //host_unreachable = 			EHOSTUNREACH,
+
+#ifdef _GLIBCXX_HAVE_EIDRM
+      identifier_removed = 			EIDRM,
+#endif
+
       illegal_byte_sequence = 			EILSEQ,
       inappropriate_io_control_operation = 	ENOTTY,
       interrupted = 				EINTR,
@@ -73,53 +79,98 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       invalid_seek = 				ESPIPE,
       io_error = 				EIO,
       is_a_directory = 				EISDIR,
-//    message_size = 				EMSGSIZE,
-//    network_down = 				ENETDOWN,
-//    network_reset = 				ENETRESET,
-//    network_unreachable = 			ENETUNREACH,
-//    no_buffer_space = 			ENOBUFS,
-//    no_child_process = 			ECHILD,
-//    no_link = 				ENOLINK,
+      //message_size = 				EMSGSIZE,
+      //network_down = 				ENETDOWN,
+      //network_reset = 			ENETRESET,
+      //network_unreachable = 			ENETUNREACH,
+      //no_buffer_space = 			ENOBUFS,
+      no_child_process = 			ECHILD,
+
+#ifdef _GLIBCXX_HAVE_ENOLINK
+      no_link = 				ENOLINK,
+#endif
+
       no_lock_available = 			ENOLCK,
-//    no_message_available = 			ENODATA, 
-//    no_message = 				ENOMSG, 
-//    no_protocol_option = 			ENOPROTOOPT,
-//    no_space_on_device = 			ENOSPC,
-//    no_stream_resources = 			ENOSR,
+
+#ifdef _GLIBCXX_HAVE_ENODATA
+      no_message_available = 			ENODATA, 
+#endif
+
+      //no_message = 				ENOMSG, 
+      //no_protocol_option = 			ENOPROTOOPT,
+      no_space_on_device = 			ENOSPC,
+
+#ifdef _GLIBCXX_HAVE_ENOSR
+      no_stream_resources = 			ENOSR,
+#endif
+
       no_such_device_or_address = 		ENXIO,
       no_such_device = 				ENODEV,
       no_such_file_or_directory = 		ENOENT,
       no_such_process = 			ESRCH,
       not_a_directory = 			ENOTDIR,
-//    not_a_socket = 				ENOTSOCK,
-//    not_a_stream = 				ENOSTR,
-//    not_connected = 				ENOTCONN,
+      //not_a_socket = 				ENOTSOCK,
+
+#ifdef _GLIBCXX_HAVE_ENOSTR
+      not_a_stream = 				ENOSTR,
+#endif
+
+      //not_connected = 			ENOTCONN,
       not_enough_memory = 			ENOMEM,
-//    not_supported = 				ENOTSUP,
-//    operation_canceled = 			ECANCELED,
-//    operation_in_progress = 			EINPROGRESS,
-//    operation_not_permitted = 		EPERM,
-//    operation_not_supported = 		EOPNOTSUPP,
-//    operation_would_block = 			EWOULDBLOCK,
-//    owner_dead = 				EOWNERDEAD,
+
+#ifdef _GLIBCXX_HAVE_ENOTSUP
+      not_supported = 				ENOTSUP,
+#endif
+
+#ifdef _GLIBCXX_HAVE_ECANCELED
+      operation_canceled = 			ECANCELED,
+#endif
+
+      //operation_in_progress = 		EINPROGRESS,
+      operation_not_permitted = 		EPERM,
+      //operation_not_supported = 		EOPNOTSUPP,
+      //operation_would_block = 		EWOULDBLOCK,
+
+#ifdef _GLIBCXX_HAVE_EOWNERDEAD
+      owner_dead = 				EOWNERDEAD,
+#endif
+
       permission_denied = 			EACCES,
-//    protocol_error = 				EPROTO,
-//    protocol_not_supported = 			EPROTONOSUPPORT,
+
+#ifdef _GLIBCXX_HAVE_EPROTO
+      protocol_error = 				EPROTO,
+#endif
+
+      //protocol_not_supported = 		EPROTONOSUPPORT,
       read_only_file_system = 			EROFS,
       resource_deadlock_would_occur = 		EDEADLK,
       resource_unavailable_try_again = 		EAGAIN,
       result_out_of_range = 			ERANGE,
-//    state_not_recoverable = 			ENOTRECOVERABLE,
-//    stream_timeout = 				ETIME,
-//    text_file_busy = 				ETXTBSY,
-//    timed_out = 				ETIMEDOUT,
+
+#ifdef _GLIBCXX_HAVE_ENOTRECOVERABLE
+      state_not_recoverable = 			ENOTRECOVERABLE,
+#endif
+
+#ifdef _GLIBCXX_HAVE_ETIME
+      stream_timeout = 				ETIME,
+#endif
+
+#ifdef _GLIBCXX_HAVE_ETXTBSY
+      text_file_busy = 				ETXTBSY,
+#endif
+
+      //timed_out = 				ETIMEDOUT,
       too_many_files_open_in_system = 		ENFILE,
       too_many_files_open = 			EMFILE,
-      too_many_links = 				EMLINK
- //   too_many_symbolic_link_levels = 		ELOOP,
- //   value_too_large = 			EOVERFLOW,
- //   wrong_protocol_type = 			EPROTOTYPE
-   };
+      too_many_links = 				EMLINK,
+      too_many_symbolic_link_levels = 		ELOOP,
+
+#ifdef _GLIBCXX_HAVE_EOVERFLOW
+      value_too_large = 			EOVERFLOW,
+#endif
+
+      //wrong_protocol_type = 			EPROTOTYPE
+    };
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 4ab39e02f..9f344951e 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -606,6 +606,8 @@ WARN_FLAGS
 OPTIMIZE_CXXFLAGS
 TOPLEVEL_INCLUDES
 GLIBCXX_INCLUDES
+gcc_version_alias
+libstdcxx_incdir_base
 glibcxx_toolexeclibdir
 glibcxx_toolexecdir
 gxx_include_dir
@@ -748,6 +750,8 @@ toplevel_srcdir
 toplevel_builddir
 glibcxx_srcdir
 glibcxx_builddir
+DJGPP_FALSE
+DJGPP_TRUE
 ac_ct_CXX
 CXXFLAGS
 CXX
@@ -4601,6 +4605,16 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 CXXFLAGS="$save_CXXFLAGS"
 
+# Add test for DJGPP environment
+ if echo $build | grep msdosdjgpp; then
+  DJGPP_TRUE=
+  DJGPP_FALSE='#'
+else
+  DJGPP_TRUE='#'
+  DJGPP_FALSE=
+fi
+
+
 # Runs configure.host, and assorted other critical bits.  Sets
 # up critical shell variables.
 
@@ -11519,7 +11533,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11522 "configure"
+#line 11536 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11625,7 +11639,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11628 "configure"
+#line 11642 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15039,7 +15053,7 @@ fi
     #
     # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.
     cat > conftest.$ac_ext << EOF
-#line 15042 "configure"
+#line 15056 "configure"
 struct S { ~S(); };
 void bar();
 void foo()
@@ -15389,7 +15403,7 @@ $as_echo "$glibcxx_cv_atomic_long_long" >&6; }
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15392 "configure"
+#line 15406 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15424,7 +15438,7 @@ $as_echo "$glibcxx_cv_atomic_bool" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15427 "configure"
+#line 15441 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15459,7 +15473,7 @@ $as_echo "$glibcxx_cv_atomic_short" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15462 "configure"
+#line 15476 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15495,7 +15509,7 @@ $as_echo "$glibcxx_cv_atomic_int" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15498 "configure"
+#line 15512 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15574,7 +15588,7 @@ $as_echo "$as_me: WARNING: Performance of certain classes will degrade as a resu
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15577 "configure"
+#line 15591 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15616,7 +15630,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15619 "configure"
+#line 15633 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15650,7 +15664,7 @@ $as_echo "$enable_int128" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15653 "configure"
+#line 15667 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -73090,9 +73104,22 @@ fi
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $version_specific_libs" >&5
 $as_echo "$version_specific_libs" >&6; }
 
+  # Convert GCC version string (to be used as directory name)
+  # Does nothing except for DJGPP
+  case "$build" in
+    *-msdosdjgpp*)
+       libstdcxx_incdir_base=cxx
+       gcc_version_alias='$(shell echo $(gcc_version) | sed -e "s:\.::2g")'
+       ;;
+    *)
+       libstdcxx_incdir_base=c++
+       gcc_version_alias='$(gcc_version)'
+       ;;
+  esac
+
   # Default case for install directory for include files.
   if test $version_specific_libs = no && test $gxx_include_dir = no; then
-    gxx_include_dir='include/c++/${gcc_version}'
+    gxx_include_dir='include/$(libstdcxx_incdir_base)/${gcc_version_alias}'
     if test -n "$with_cross_host" &&
        test x"$with_cross_host" != x"no"; then
       gxx_include_dir='${prefix}/${target_alias}/'"$gxx_include_dir"
@@ -73108,10 +73135,10 @@ $as_echo "$version_specific_libs" >&6; }
     # is selected.  FIXME: these variables are misnamed, there are
     # no executables installed in _toolexecdir or _toolexeclibdir.
     if test x"$gxx_include_dir" = x"no"; then
-      gxx_include_dir='${libdir}/gcc/${host_alias}/${gcc_version}/include/c++'
+      gxx_include_dir='${libdir}/gcc/${host_alias}/${gcc_version_alias}/include/${libstdcxx_incdir_base}'
     fi
     glibcxx_toolexecdir='${libdir}/gcc/${host_alias}'
-    glibcxx_toolexeclibdir='${toolexecdir}/${gcc_version}$(MULTISUBDIR)'
+    glibcxx_toolexeclibdir='${toolexecdir}/${gcc_version_alias}$(MULTISUBDIR)'
   fi
 
   # Calculate glibcxx_toolexecdir, glibcxx_toolexeclibdir
@@ -73143,6 +73170,8 @@ $as_echo "$gxx_include_dir" >&6; }
 
 
 
+
+
 # Export all the include and flag information to Makefiles.
 
   # Used for every C++ compile we perform.
@@ -73304,6 +73333,10 @@ else
   am__EXEEXT_FALSE=
 fi
 
+if test -z "${DJGPP_TRUE}" && test -z "${DJGPP_FALSE}"; then
+  as_fn_error "conditional \"DJGPP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
   as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
index 73d430ac1..222472ae0 100644
--- a/libstdc++-v3/configure.ac
+++ b/libstdc++-v3/configure.ac
@@ -84,6 +84,9 @@ AC_PROG_CC
 AC_PROG_CXX
 CXXFLAGS="$save_CXXFLAGS"
 
+# Add test for DJGPP environment
+AM_CONDITIONAL(DJGPP,echo $build | grep msdosdjgpp)
+
 # Runs configure.host, and assorted other critical bits.  Sets
 # up critical shell variables.
 GLIBCXX_CONFIGURE
diff --git a/libstdc++-v3/doc/Makefile.in b/libstdc++-v3/doc/Makefile.in
index 9816fc802..6fd266e1f 100644
--- a/libstdc++-v3/doc/Makefile.in
+++ b/libstdc++-v3/doc/Makefile.in
@@ -209,6 +209,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -237,6 +238,7 @@ infodir = "$(DESTDIR)@infodir@"
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
index d16ca12ac..9d7c46bc3 100644
--- a/libstdc++-v3/include/Makefile.in
+++ b/libstdc++-v3/include/Makefile.in
@@ -207,6 +207,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -231,6 +232,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/libsupc++/Makefile.in b/libstdc++-v3/libsupc++/Makefile.in
index 8bf86f35a..d9c5ca4fa 100644
--- a/libstdc++-v3/libsupc++/Makefile.in
+++ b/libstdc++-v3/libsupc++/Makefile.in
@@ -267,6 +267,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -291,6 +292,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/po/Makefile.in b/libstdc++-v3/po/Makefile.in
index bb0f59084..90a0e48b0 100644
--- a/libstdc++-v3/po/Makefile.in
+++ b/libstdc++-v3/po/Makefile.in
@@ -207,6 +207,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -231,6 +232,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/python/Makefile.am b/libstdc++-v3/python/Makefile.am
index 6f8f01a1c..15c581181 100644
--- a/libstdc++-v3/python/Makefile.am
+++ b/libstdc++-v3/python/Makefile.am
@@ -26,7 +26,7 @@ include $(top_srcdir)/fragment.am
 if ENABLE_PYTHONDIR
 pythondir = $(prefix)/$(python_mod_dir)
 else
-pythondir = $(datadir)/gcc-$(gcc_version)/python
+pythondir = $(datadir)/gcc-$(gcc_version_alias)/python
 endif
 
 all-local: gdb.py
@@ -36,6 +36,12 @@ nobase_python_DATA = \
     libstdcxx/v6/__init__.py \
     libstdcxx/__init__.py
 
+if DJGPP
+name_base=libstdcxx
+else
+name_base=libstdc++
+endif
+
 gdb.py: hook.in Makefile
 	sed -e 's,@pythondir@,$(pythondir),' \
 	    -e 's,@toolexeclibdir@,$(toolexeclibdir),' < $(srcdir)/hook.in > $@
@@ -48,7 +54,7 @@ install-data-local: gdb.py
 ## fragile, but there does not seem to be a better option, because
 ## libtool hides the real names from us.
 	@here=`pwd`; cd $(DESTDIR)$(toolexeclibdir); \
-	  for file in libstdc++*; do \
+	  for file in $(name_base)*; do \
 	    case $$file in \
 	      *-gdb.py) ;; \
 	      *.la) ;; \
diff --git a/libstdc++-v3/python/Makefile.in b/libstdc++-v3/python/Makefile.in
index 49f71a117..8c6b427d4 100644
--- a/libstdc++-v3/python/Makefile.in
+++ b/libstdc++-v3/python/Makefile.in
@@ -231,6 +231,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -255,6 +256,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
@@ -307,13 +309,15 @@ WARN_CXXFLAGS = \
 
 # -I/-D flags to pass when compiling.
 AM_CPPFLAGS = $(GLIBCXX_INCLUDES)
-@ENABLE_PYTHONDIR_FALSE@pythondir = $(datadir)/gcc-$(gcc_version)/python
+@ENABLE_PYTHONDIR_FALSE@pythondir = $(datadir)/gcc-$(gcc_version_alias)/python
 @ENABLE_PYTHONDIR_TRUE@pythondir = $(prefix)/$(python_mod_dir)
 nobase_python_DATA = \
     libstdcxx/v6/printers.py \
     libstdcxx/v6/__init__.py \
     libstdcxx/__init__.py
 
+@DJGPP_FALSE@name_base = libstdc++
+@DJGPP_TRUE@name_base = libstdcxx
 all: all-am
 
 .SUFFIXES:
@@ -505,7 +509,7 @@ gdb.py: hook.in Makefile
 install-data-local: gdb.py
 	@$(mkdir_p) $(DESTDIR)$(toolexeclibdir)
 	@here=`pwd`; cd $(DESTDIR)$(toolexeclibdir); \
-	  for file in libstdc++*; do \
+	  for file in $(name_base)*; do \
 	    case $$file in \
 	      *-gdb.py) ;; \
 	      *.la) ;; \
diff --git a/libstdc++-v3/scripts/create_testsuite_files b/libstdc++-v3/scripts/create_testsuite_files
index a427eef2d..aea2a5c5e 100755
--- a/libstdc++-v3/scripts/create_testsuite_files
+++ b/libstdc++-v3/scripts/create_testsuite_files
@@ -33,8 +33,20 @@ cd $srcdir
 # what has to happen when find(1) doesn't support -mindepth, or -xtype.
 dlist=`echo [0-9][0-9]*`
 dlist="$dlist abi backward ext performance tr1 tr2 decimal"
-find $dlist "(" -type f -o -type l ")" -name "*.cc" -print > $tmp.01
-find $dlist "(" -type f -o -type l ")" -name "*.c" -print > $tmp.02
+#find $dlist "(" -type f -o -type l ")" -name "*.cc" -print > $tmp.01
+#find $dlist "(" -type f -o -type l ")" -name "*.c" -print > $tmp.02
+
+case $OSTYPE in
+  msdos*)
+     find $dlist "(" -type f ")" -name "*.cc" -print > $tmp.01
+     find $dlist "(" -type f ")" -name "*.c" -print > $tmp.02
+     ;;
+  *)
+     find $dlist "(" -type f -o -type l ")" -name "*.cc" -print > $tmp.01
+     find $dlist "(" -type f -o -type l ")" -name "*.c" -print > $tmp.02
+     ;;
+esac
+
 cat  $tmp.01 $tmp.02 | sort > $tmp.1
 if test ! -s "$tmp.1"; then
   exit 1
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index 092fd1bd5..7df301c16 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -25,7 +25,11 @@ include $(top_srcdir)/fragment.am
 SUBDIRS = c++98 c++11
 
 # Cross compiler support.
+if DJGPP
+toolexeclib_LTLIBRARIES = libstdcxx.la
+else
 toolexeclib_LTLIBRARIES = libstdc++.la
+endif
 
 vpath % $(top_srcdir)/src/c++98
 vpath % $(top_srcdir)/src/c++11
@@ -53,14 +57,38 @@ cxx11_sources = \
 	compatibility-thread-c++0x.cc \
 	compatibility-chrono.cc
 
+if DJGPP
+libstdcxx_la_SOURCES = $(cxx98_sources) $(cxx11_sources)
+else
 libstdc___la_SOURCES = $(cxx98_sources) $(cxx11_sources)
+endif
 
+if DJGPP
+libstdcxx_la_LIBADD = \
+	$(GLIBCXX_LIBS) \
+	$(top_builddir)/libsupc++/libsupc++convenience.la \
+	$(top_builddir)/src/c++98/libc++98convenience.la \
+	$(top_builddir)/src/c++11/libc++11convenience.la
+else
 libstdc___la_LIBADD = \
 	$(GLIBCXX_LIBS) \
 	$(top_builddir)/libsupc++/libsupc++convenience.la \
 	$(top_builddir)/src/c++98/libc++98convenience.la \
 	$(top_builddir)/src/c++11/libc++11convenience.la
+endif
 
+if DJGPP
+libstdcxx_la_DEPENDENCIES = \
+	${version_dep} \
+	$(top_builddir)/libsupc++/libsupc++convenience.la \
+	$(top_builddir)/src/c++98/libc++98convenience.la \
+	$(top_builddir)/src/c++11/libc++11convenience.la
+
+libstdcxx_la_LDFLAGS = \
+	-version-info $(libtool_VERSION) ${version_arg} -lm
+
+libstdcxx_la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)
+else
 libstdc___la_DEPENDENCIES = \
 	${version_dep} \
 	$(top_builddir)/libsupc++/libsupc++convenience.la \
@@ -71,6 +99,7 @@ libstdc___la_LDFLAGS = \
 	-version-info $(libtool_VERSION) ${version_arg} -lm
 
 libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)
+endif
 
 
 # Use special rules for compatibility-ldbl.cc compilation, as we need to
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index a7b3404d0..19f593799 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -94,15 +94,21 @@ am__objects_2 = compatibility.lo compatibility-debug_list.lo \
 	compatibility-debug_list-2.lo $(am__objects_1)
 am__objects_3 = compatibility-c++0x.lo compatibility-atomic-c++0x.lo \
 	compatibility-thread-c++0x.lo compatibility-chrono.lo
-am_libstdc___la_OBJECTS = $(am__objects_2) $(am__objects_3)
+@DJGPP_FALSE@am_libstdc___la_OBJECTS = $(am__objects_2) \
+@DJGPP_FALSE@	$(am__objects_3)
 libstdc___la_OBJECTS = $(am_libstdc___la_OBJECTS)
+@DJGPP_FALSE@am_libstdc___la_rpath = -rpath $(toolexeclibdir)
+@DJGPP_TRUE@am_libstdcxx_la_OBJECTS = $(am__objects_2) \
+@DJGPP_TRUE@	$(am__objects_3)
+libstdcxx_la_OBJECTS = $(am_libstdcxx_la_OBJECTS)
+@DJGPP_TRUE@am_libstdcxx_la_rpath = -rpath $(toolexeclibdir)
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp =
 am__depfiles_maybe =
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 CXXLD = $(CXX)
-SOURCES = $(libstdc___la_SOURCES)
+SOURCES = $(libstdc___la_SOURCES) $(libstdcxx_la_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	html-recursive info-recursive install-data-recursive \
 	install-dvi-recursive install-exec-recursive \
@@ -257,6 +263,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -281,6 +288,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
@@ -334,9 +342,10 @@ WARN_CXXFLAGS = \
 # -I/-D flags to pass when compiling.
 AM_CPPFLAGS = $(GLIBCXX_INCLUDES)
 SUBDIRS = c++98 c++11
+@DJGPP_FALSE@toolexeclib_LTLIBRARIES = libstdc++.la
 
 # Cross compiler support.
-toolexeclib_LTLIBRARIES = libstdc++.la
+@DJGPP_TRUE@toolexeclib_LTLIBRARIES = libstdcxx.la
 @GLIBCXX_LDBL_COMPAT_FALSE@ldbl_compat_sources = 
 @GLIBCXX_LDBL_COMPAT_TRUE@ldbl_compat_sources = compatibility-ldbl.cc
 parallel_compat_sources = \
@@ -354,23 +363,40 @@ cxx11_sources = \
 	compatibility-thread-c++0x.cc \
 	compatibility-chrono.cc
 
-libstdc___la_SOURCES = $(cxx98_sources) $(cxx11_sources)
-libstdc___la_LIBADD = \
-	$(GLIBCXX_LIBS) \
-	$(top_builddir)/libsupc++/libsupc++convenience.la \
-	$(top_builddir)/src/c++98/libc++98convenience.la \
-	$(top_builddir)/src/c++11/libc++11convenience.la
-
-libstdc___la_DEPENDENCIES = \
-	${version_dep} \
-	$(top_builddir)/libsupc++/libsupc++convenience.la \
-	$(top_builddir)/src/c++98/libc++98convenience.la \
-	$(top_builddir)/src/c++11/libc++11convenience.la
-
-libstdc___la_LDFLAGS = \
-	-version-info $(libtool_VERSION) ${version_arg} -lm
-
-libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)
+@DJGPP_TRUE@libstdcxx_la_SOURCES = $(cxx98_sources) $(cxx11_sources)
+@DJGPP_FALSE@libstdc___la_SOURCES = $(cxx98_sources) $(cxx11_sources)
+@DJGPP_TRUE@libstdcxx_la_LIBADD = \
+@DJGPP_TRUE@	$(GLIBCXX_LIBS) \
+@DJGPP_TRUE@	$(top_builddir)/libsupc++/libsupc++convenience.la \
+@DJGPP_TRUE@	$(top_builddir)/src/c++98/libc++98convenience.la \
+@DJGPP_TRUE@	$(top_builddir)/src/c++11/libc++11convenience.la
+
+@DJGPP_FALSE@libstdc___la_LIBADD = \
+@DJGPP_FALSE@	$(GLIBCXX_LIBS) \
+@DJGPP_FALSE@	$(top_builddir)/libsupc++/libsupc++convenience.la \
+@DJGPP_FALSE@	$(top_builddir)/src/c++98/libc++98convenience.la \
+@DJGPP_FALSE@	$(top_builddir)/src/c++11/libc++11convenience.la
+
+@DJGPP_TRUE@libstdcxx_la_DEPENDENCIES = \
+@DJGPP_TRUE@	${version_dep} \
+@DJGPP_TRUE@	$(top_builddir)/libsupc++/libsupc++convenience.la \
+@DJGPP_TRUE@	$(top_builddir)/src/c++98/libc++98convenience.la \
+@DJGPP_TRUE@	$(top_builddir)/src/c++11/libc++11convenience.la
+
+@DJGPP_TRUE@libstdcxx_la_LDFLAGS = \
+@DJGPP_TRUE@	-version-info $(libtool_VERSION) ${version_arg} -lm
+
+@DJGPP_TRUE@libstdcxx_la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)
+@DJGPP_FALSE@libstdc___la_DEPENDENCIES = \
+@DJGPP_FALSE@	${version_dep} \
+@DJGPP_FALSE@	$(top_builddir)/libsupc++/libsupc++convenience.la \
+@DJGPP_FALSE@	$(top_builddir)/src/c++98/libc++98convenience.la \
+@DJGPP_FALSE@	$(top_builddir)/src/c++11/libc++11convenience.la
+
+@DJGPP_FALSE@libstdc___la_LDFLAGS = \
+@DJGPP_FALSE@	-version-info $(libtool_VERSION) ${version_arg} -lm
+
+@DJGPP_FALSE@libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)
 
 # A note on compatibility and static libraries.
 # 
@@ -542,7 +568,9 @@ clean-toolexeclibLTLIBRARIES:
 	  rm -f "$${dir}/so_locations"; \
 	done
 libstdc++.la: $(libstdc___la_OBJECTS) $(libstdc___la_DEPENDENCIES) 
-	$(libstdc___la_LINK) -rpath $(toolexeclibdir) $(libstdc___la_OBJECTS) $(libstdc___la_LIBADD) $(LIBS)
+	$(libstdc___la_LINK) $(am_libstdc___la_rpath) $(libstdc___la_OBJECTS) $(libstdc___la_LIBADD) $(LIBS)
+libstdcxx.la: $(libstdcxx_la_OBJECTS) $(libstdcxx_la_DEPENDENCIES) 
+	$(libstdcxx_la_LINK) $(am_libstdcxx_la_rpath) $(libstdcxx_la_OBJECTS) $(libstdcxx_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
diff --git a/libstdc++-v3/src/c++11/Makefile.in b/libstdc++-v3/src/c++11/Makefile.in
index a410748a4..63679706a 100644
--- a/libstdc++-v3/src/c++11/Makefile.in
+++ b/libstdc++-v3/src/c++11/Makefile.in
@@ -224,6 +224,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -248,6 +249,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/src/c++98/Makefile.in b/libstdc++-v3/src/c++98/Makefile.in
index d154b9839..7da94e532 100644
--- a/libstdc++-v3/src/c++98/Makefile.in
+++ b/libstdc++-v3/src/c++98/Makefile.in
@@ -240,6 +240,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -264,6 +265,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/libstdc++-v3/testsuite/Makefile.in b/libstdc++-v3/testsuite/Makefile.in
index 96b3f9f4b..79eca87b7 100644
--- a/libstdc++-v3/testsuite/Makefile.in
+++ b/libstdc++-v3/testsuite/Makefile.in
@@ -207,6 +207,7 @@ dvidir = @dvidir@
 enable_shared = @enable_shared@
 enable_static = @enable_static@
 exec_prefix = @exec_prefix@
+gcc_version_alias = @gcc_version_alias@
 glibcxx_MOFILES = @glibcxx_MOFILES@
 glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
 glibcxx_POFILES = @glibcxx_POFILES@
@@ -231,6 +232,7 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+libstdcxx_incdir_base = @libstdcxx_incdir_base@
 libtool_VERSION = @libtool_VERSION@
 localedir = @localedir@
 localstatedir = @localstatedir@
diff --git a/readme.DJGPP b/readme.DJGPP
new file mode 100644
index 000000000..bd2e62026
--- /dev/null
+++ b/readme.DJGPP
@@ -0,0 +1,299 @@
+This is the DJGPP port of gcc-4.8.5
+
+Please read this file up to end (maybe skipping sections You don't need,
+for example You don't need to read how to build gcc-4.8.5 from sources
+if You only intend to use binary archives). Also consult DJGPP documentation
+and FAQ where needed.
+
+
+Requirements to use this binary release:
+    -  DJGPP-@DJVER@.
+    -  binutils-2.22 or above (Earlier versions may NOT work and are not tested)
+
+Requirements to build gcc-4.8.5 from sources:
+
+Source archives
+===============
+
+
+Archive djcross-gcc-4.8.5.tar.bz2 contains script which modifies
+original gcc-4.8.5 sources for DJGPP. You don't need it unless You
+want to recreate GCC source archive for DJGPP. If You are using this
+archive and original sources of gcc-4.8.5.tar.gz, then You don't
+need gcc485s.zip. Running these scripts under DJGPP has not been
+tested for a long time and is unlikely to succeed.
+    
+The source archive gcc485s.zip contains all the sources to build
+all compilers (C, C++, Objective C, Objective C++, GNU Fortran) and also C++
+and Fortran libraries (libstdcxx.a, libgpp.a and libg2c.a). 
+
+Most users don't need source archives at all.
+
+Binary archives
+================
+
+Binary archives are split into 5 parts:
+
+  gcc485b.zip  : The gcc.exe driver program and the C compiler.
+                 It also contains the documentation.
+
+  gpp485b.zip  : The C++ compiler and libstdcxx.a together 
+                 with needed header files. Please note that one must
+                 recompile all C++ sources built with any earlier GCC version
+
+  objc485b.zip : The Objective C and Objective C++ compilers and 
+                 libobjc.a and the needed header files.
+
+  gfor485b.zip : GNU Fortran compiler
+
+  ada485b.zip  : GNU Ada compiler
+
+The archive gcc485b.zip is required by all other binary packages
+
+Binary packages includes following documentation files:
+  
+  Archive gcc485b.zip:  
+        info/gcc.info - the use and the internals of the GNU compiler
+        info/cpp.info - documentation of the GNU C preprocessor.
+        info/cppinternals.info  - internals of the GNU C Preprocessor.
+        info/gccinstall.info
+        info/gccint.info
+                (NEW: use install-info to add it to info/dir)
+  Archive gpp485b.zip:
+        gnu/gcc-4.85/libstdcxx/* - some documentation of libstdc++-v3
+                (HTML and text formats)
+  Archive gfor485b.zip:
+        info/gfortran.info - documentation of the GNU Fortran compiler
+
+
+Installing binaries of gcc-4.8.5
+=================================
+
+Needed archives for different programming languages
+        C                       : gcc485b.zip
+
+        C++                     : gcc485b.zip, gpp485b.zip
+
+        Fortran 95              : gcc485b.zip, gfor485b.zip
+
+        Objective C             : gcc485b.zip, objc485b.zip
+
+        Objective C++           : gcc485b.zip, objc485b.zip
+
+        Ada                     : gcc485b.zip, ada485b.zip
+
+Of course for ALL languages You also need at least binutils (bnu222b.zip
+or newer) and @DJDEV@.zip (or newer when it will be released)
+
+Unzip all the zip files from that directory, preserving the
+directory structure.  For example:
+
+        pkunzip -d @DJDEV@
+or
+        unzip386 @DJDEV@
+
+
+NOTE:   For debugging GDB version 7.7.1 or newer is recommended. 
+        (gdb-6.3 is not released for DJGPP yet though).
+
+
+1. Only long filenames
+----------------------
+
+Unzip the binaries with an unzip program, which can restore the long filenames
+stored in the zip archive.
+
+2. Only short filenames
+-----------------------
+
+Unzip the binaries with an unzip program which doesn't know about long
+filenames, or if your unzipper knows about them, please follow first
+the steps described in the DJGPP FAQ in the section 
+about setting the NameNumericTail to 0 __BEFORE__!!! unzipping the archives.
+
+3. Long and short filenames at the same time
+--------------------------------------------
+
+Use an unzip program which can restore the long filenames and follow
+the instructions under 2. when the unzipper knows about long filenames.
+
+
+Note for users of C++ IO classes fstream, ifstream, ofstream
+============================================================
+
+There is a regression against earlier versions of GCC (gcc-2.95.3 and
+earlier): Member functions tellp(), tellg(), seekp() and seekg()
+are broken when stream is opened not in binary mode. If You are going
+to use any similar functions You should open stream in binary mode.
+
+Don't ask me when it will be fixed as I don't know that. I'm also 
+not sure I'll spend much time trying to fix that.
+
+
+Rebuilding gcc-4.8.5 from the sources
+======================================
+
+Requirements
+------------
+
+-  Long filename support. I built it in DOS session under Windows Vista
+   Business SP3. Other 32 bit Windows versions beginning with Win95
+   should be hopefully OK. I have not however tested that myself.
+
+-  plenty of physical RAM available. I guess that 1 GB should
+   be enough (I had more on build machine)
+
+-  Much of free disk space: the total size of all directories after build
+   was about 3 GB. Perhaps one need more to be safe.
+
+-  Amount of available DPMI memory for DOS session should
+   be set to auto.
+
+-  On windows Vista (and perhaps later versions) a registry hack to
+   allow DPMI clients to use more that 32 MB of memory must be used
+
+-  DJGPP version v2.05 or above
+
+-  many GNU utilities and libraries (the list may be incomplete)
+
+        last version of DJGPP port of bash-2.0.5b
+        GNU Diffutils 2.8 or above
+        GNU Fileutils-4.1
+        GNU Find 4.1.7 or above
+        GNU grep 2.5.1 or above
+        GNU Awk 3.1.1 or above
+        GNU Make 3.80 or above
+        GNU Sed 4.0.7 or above
+        GNU shell utils 2.0.11
+        GNU Textutils 2.0
+        GNU Texinfo 4.8 or above
+        GNU tar 1.1.2 or above
+        GNU binutils 2.22 (required, older versions cannot be used!!!)
+        recent GNU GMP 5.0.1 version (versions 5.0.X or newer are OK)
+        recent MPFR versions (versions 3.0.0 or newer are OK)
+        recent MPC versions (versions 1.0.0 or newer are OK)
+        Zlib-1.2.5 or above (Warning configure does not check for presence
+             one only gets build error later)
+        working GNU C compiler (perhaps not earlier than gcc-4.1). 
+
+-  one may need to increase DOS transfer buffer size to 24 KB or
+   32 KB for some executables (GNU Make and ld) to optimize lower
+   memory use as having to allocate additional lower memory block
+   for long parameter lists when invoking child process wastes
+   much of memory. I had transfer buffer size increased to 24 KB
+   for GNU Make only 
+
+-  INFO-ZIP binary (compiled with DJGPP v2!!!) is needed for using build.sh 
+   to create binary distribution archives. There is no problems to compile 
+   it. See http://www.info-zip.org for additional information
+   about INFO-ZIP. You can find DJGPP compiled binary there. 
+
+-  Working DJGPP installation of course:
+   -  DJGPP v2.05 require
+
+Earlier requirement to have rebuilt stubify.exe with default stack size
+increased to 1.5 MB or more is no more required as the stack size
+reserving is now done using _stklen where required. 
+
+If You modify some source files You may also need
+        autoconf-2.64
+        automake-1.11
+        (No ports available for DJGPP yet. I did all patching GCC sources
+        and updating autoconf and automake related stuff in Linux)
+        
+Building using using DJGPP v2.03 patchlevel 2 is not supported and is expected
+to fail.
+
+-  You should have sh.exe in DJGPP bin directory as symbolic link to  
+   bash.exe (type 'ln -s bash.exe sh.exe' in that directory)
+
+
+Extracting the sources
+----------------------
+
+At first you should unzip the archive gcc485s.zip. The sources are _NOT_
+the complete sources like the original gcc-4.8.5 distribution. I have
+removed many files to save disk space which are not needed for the DJGPP
+port. However I left configuration of other machines in to make archives
+usable to build cross-to-DJGPP compilers and DJGPP hosted cross-compilers
+(I haven't tested it).
+
+
+Compiling gcc
+-------------
+
+Directory gnu/gcc-4.85 contains all sources of gcc-4.8.5
+
+Sources are NOT configured. 
+        
+Change to directory gnu/build.gcc and configure sources
+by running script djconfig.sh. 
+
+        sh djconfig.sh
+
+When this is done You can build gcc-4.8.5 by running script djmake.sh
+Under Win9X You'll have to restart it some times when it will crash 
+due to Win9X DPMI descriptor leaks. You may use redir to get output in file.
+
+        sh djmake.sh bootstrap
+
+When this successfully ends run script djinsttmp.sh which installs
+all into directory gnu/install.gcc
+
+After that change to this directory and run script makepkg.sh
+to create binary distribution packages
+
+
+Installing newly compiled gcc
+-----------------------------
+
+It's recommended to install binary packages which are generated 
+by makepkg.sh
+
+
+
+Available resources
+===================
+
+See following URL for additional information:
+gcc:              http://gcc.gnu.org
+
+
+
+Reporting bugs
+==============
+
+If you found a bug in gcc-4.8.5 (gcc, gfortran, libstdc++, etc) please report it to 
+the GCC bug addresses and to the DJGPP mailing list (djgpp@delorie.com). We may not
+notice bug reports sent to GCC bug reporting system only due to large amount of
+other bugs there. 
+
+But if you think you found a bug in the DJGPP related things, then please 
+report it in comp.os.msdos.djgpp (the news group) or mail it to 
+djgpp@delorie.com, which is the gateway to the news group.
+
+Some possible situations:
+  - gcc says 'Internal compiler error' (or something similar)
+       more likely it is error of gcc if it is reproducible. It would 
+       be nice to test on some other system (e.g. Linux) and also with 
+       different version of compiler if possible and submit report to 
+       gcc bug address. 
+  - gcc crashes or freezes. 
+       In this situation it's hard to guess where is the problem. It may be
+       problem with gcc itself but it may be also DJGPP specific one.
+
+Please email me directly only in rare cases, if you think it is only of
+interest to me, since I'll see the reports in DJGPP mailing list.
+
+
+Thanks to
+=========
+
+To all who have contributed new features, test results, bug-fixes to GCC
+(see http://gcc.gnu.org/thanks.html) and also who helped with DJGPP port of 
+gcc-4.8.5
+
+
+Have fun with gcc
+
+Andris Pavenis <andris.pavenis@iki.fi>
