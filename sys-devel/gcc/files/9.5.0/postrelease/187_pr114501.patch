diff --git a/gcc/testsuite/g++.dg/pr114501_0.C b/gcc/testsuite/g++.dg/pr114501_0.C
new file mode 100644
index 000000000..0439ee5f6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr114501_0.C
@@ -0,0 +1,20 @@
+// { dg-do compile }
+// { dg-require-effective-target c++17 }
+// { dg-require-effective-target lto }
+// { dg-options "-flto" }
+
+typedef long unsigned int size_t;
+struct basic_string_view {
+  typedef long unsigned int size_type;
+  constexpr size_type size() const { return 0; }
+};
+struct array {
+  char _M_elems[1];
+};
+inline constexpr auto make_it() {
+  constexpr basic_string_view view;
+  array arr{};
+  arr._M_elems[view.size()] = 'a';
+  return arr;
+}
+auto bar = make_it();
diff --git a/gcc/tree.c b/gcc/tree.c
index 813482007..15408ace6 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -5977,6 +5977,20 @@ find_decls_types_r (tree *tp, int *ws, void *data)
 	fld_worklist_push (tem, fld);
       fld_worklist_push (BLOCK_ABSTRACT_ORIGIN (t), fld);
     }
+  /* walk_tree does not visit ce->index which can be a FIELD_DECL, pulling
+     in otherwise unused structure fields so handle CTORs explicitly.  */
+  else if (TREE_CODE (t) == CONSTRUCTOR)
+    {
+      unsigned HOST_WIDE_INT idx;
+      constructor_elt *ce;
+      for (idx = 0; vec_safe_iterate (CONSTRUCTOR_ELTS (t), idx, &ce); idx++)
+	{
+	  if (ce->index)
+	    fld_worklist_push (ce->index, fld);
+	  fld_worklist_push (ce->value, fld);
+	}
+      *ws = 0;
+    }
 
   if (TREE_CODE (t) != IDENTIFIER_NODE
       && CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_TYPED))
