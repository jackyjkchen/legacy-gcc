diff --git a/boehm-gc/configure b/boehm-gc/configure
index 3ff5861b..930ca892 100755
--- a/boehm-gc/configure
+++ b/boehm-gc/configure
@@ -1937,14 +1937,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/boehm-gc/ia64_save_regs_in_stack.S b/boehm-gc/ia64_save_regs_in_stack.S
new file mode 100644
index 00000000..632913db
--- /dev/null
+++ b/boehm-gc/ia64_save_regs_in_stack.S
@@ -0,0 +1,15 @@
+        .text
+        .align 16
+        .global GC_save_regs_in_stack
+        .proc GC_save_regs_in_stack
+GC_save_regs_in_stack:
+        .body
+        flushrs
+        ;;
+        mov r8=ar.bsp
+        br.ret.sptk.few rp
+        .endp GC_save_regs_in_stack
+
+#ifdef __linux__
+	.section .note.GNU-stack,"",@progbits
+#endif
diff --git a/boehm-gc/ia64_save_regs_in_stack.s b/boehm-gc/ia64_save_regs_in_stack.s
index 3b18c084..e69de29b 100644
--- a/boehm-gc/ia64_save_regs_in_stack.s
+++ b/boehm-gc/ia64_save_regs_in_stack.s
@@ -1,12 +0,0 @@
-        .text
-        .align 16
-        .global GC_save_regs_in_stack
-        .proc GC_save_regs_in_stack
-GC_save_regs_in_stack:
-        .body
-        flushrs
-        ;;
-        mov r8=ar.bsp
-        br.ret.sptk.few rp
-        .endp GC_save_regs_in_stack
-
diff --git a/contrib/gcc_update b/contrib/gcc_update
index b89a9af6..3eaa3e4d 100755
--- a/contrib/gcc_update
+++ b/contrib/gcc_update
@@ -123,7 +123,16 @@ touch_files () {
     chat '	echo Touching $@... 1>&2; \' >> Makefile.$$
     echo '	touch $@' >> Makefile.$$
     files_and_dependencies | sed 's,[^ ]* ,,;s,$, :,' >> Makefile.$$
-    while ${MAKE-make} -s -f Makefile.$$ all | grep . > /dev/null; do
+
+    # We would have to explicitly shut off the "Entering... Leaving..."
+    # messages through "--no-print-directory" to handle the case when
+    # we were called from a recursive invocation (i.e. "$(MAKE)" in a
+    # Makefile, not just make).  Passing only "-s" doesn't help then,
+    # because make has helpfully added "-w" to MAKEFLAGS automatically.
+    # Unfortunately we do not require GNU make other than for building
+    # and testing, so let's just grep known text explicitly echoed by
+    # the rule.
+    while ${MAKE-make} -s -f Makefile.$$ all | grep Touching > /dev/null; do
       sleep 1
     done 2>&1
     rm -f Makefile.$$
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 30815af4..7bd26009 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -1185,6 +1185,7 @@ libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) $(LIB2ADD_ST) $(LIB2ADD_SH
 	SHLIB_MAPFILES='$(SHLIB_MAPFILES)' \
 	SHLIB_NM_FLAGS='$(SHLIB_NM_FLAGS)' \
 	MULTILIB_OSDIRNAMES='$(MULTILIB_OSDIRNAMES)' \
+	GCC_FOR_TARGET='$(GCC_FOR_TARGET)' \
 	mkinstalldirs='$(SHELL) $(srcdir)/mkinstalldirs' \
 	  $(SHELL) mklibgcc > tmp-libgcc.mk
 	mv tmp-libgcc.mk libgcc.mk
@@ -2409,8 +2410,8 @@ protoize.o: protoize.c $(srcdir)/../include/getopt.h $(CONFIG_H) $(SYSTEM_H) \
 	  $(DRIVER_DEFINES) \
 	  $(srcdir)/protoize.c $(OUTPUT_OPTION))
 
-unprotoize.o: protoize.c $(srcdir)/../include/getopt.h \
-   $(CONFIG_H) $(SYSTEM_H) Makefile version.h
+unprotoize.o: protoize.c $(srcdir)/../include/getopt.h $(CONFIG_H) \
+    $(SYSTEM_H) coretypes.h $(TM_H) Makefile version.h cppdefault.h intl.h
 	(SHLIB_LINK='$(SHLIB_LINK)' \
 	SHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \
 	$(CC) -c -DUNPROTOIZE $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
@@ -2504,6 +2505,9 @@ stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) xlimits.h
 	rm -f include/limits.h
 	cp xlimits.h include/limits.h
 	chmod a+r include/limits.h
+	if [ x"$(STMP_FIXINC)" = x ]; then \
+	  cp $(srcdir)/gsyslimits.h include/syslimits.h; \
+	fi
 # Install the README
 	rm -f include/README
 	cp $(srcdir)/README-fixinc include/README
@@ -2532,6 +2536,7 @@ fixinc.sh: $(FIXINCSRCDIR)/mkfixinc.sh $(FIXINCSRCDIR)/fixincl.c \
 	(MAKE="$(MAKE)"; srcdir=`cd $(srcdir)/fixinc && ${PWD_COMMAND}` ; \
 	CC="$(CC_FOR_BUILD)"; CFLAGS="$(BUILD_CFLAGS)"; LDFLAGS="$(BUILD_LDFLAGS)"; \
 	WARN_CFLAGS="$(WARN_CFLAGS)"; LIBERTY=`${PWD_COMMAND}`/"$(BUILD_LIBIBERTY)"; \
+	SHELL="$(SHELL)"; export SHELL; \
 	export MAKE srcdir CC CFLAGS LDFLAGS WARN_CFLAGS LIBERTY; \
 	cd ./fixinc && \
 	$(SHELL) $${srcdir}/mkfixinc.sh $(build) $(target))
@@ -2916,7 +2921,7 @@ install-common: native $(EXTRA_PARTS) lang.install-common installdirs
 	  else true; fi; \
 	done
 # Don't mess with specs if it doesn't exist yet.
-	-if [ -f specs ] ; then \
+	-if [ -f specs ] && [ x"$(STMP_FIXINC)" != x ] ; then \
 	  rm -f $(DESTDIR)$(libsubdir)/specs; \
 	  $(INSTALL_DATA) $(SPECS) $(DESTDIR)$(libsubdir)/specs; \
 	  chmod a-x $(DESTDIR)$(libsubdir)/specs; \
diff --git a/gcc/c-decl.c b/gcc/c-decl.c
index 66e0fd7d..c8c6e3c6 100644
--- a/gcc/c-decl.c
+++ b/gcc/c-decl.c
@@ -2820,7 +2820,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)
 	{
 	  tree builtin = built_in_decls [DECL_FUNCTION_CODE (decl)];
 	  SET_DECL_RTL (builtin, NULL_RTX);
-	  SET_DECL_ASSEMBLER_NAME (builtin, get_identifier (starred));
+	  change_decl_assembler_name (builtin, get_identifier (starred));
 #ifdef TARGET_MEM_FUNCTIONS
 	  if (DECL_FUNCTION_CODE (decl) == BUILT_IN_MEMCPY)
 	    init_block_move_fn (starred);
diff --git a/gcc/c-parse.in b/gcc/c-parse.in
index 66d27ac0..8d359725 100644
--- a/gcc/c-parse.in
+++ b/gcc/c-parse.in
@@ -57,6 +57,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 /* Like YYERROR but do call yyerror.  */
 #define YYERROR1 { yyerror ("syntax error"); YYERROR; }
 
+/* Newer bison doesn't define YYLEX anymore.  */
+#ifndef YYLEX
+# define YYLEX yylex()
+#endif
+
 /* Like the default stack expander, except (1) use realloc when possible,
    (2) impose no hard maxiumum on stack size, (3) REALLY do not use alloca.
 
@@ -1730,7 +1735,7 @@ enum_head:
 
 structsp_attr:
 	  struct_head identifier '{'
-		{ $$ = start_struct (RECORD_TYPE, $2);
+		{ $<ttype>$ = start_struct (RECORD_TYPE, $2);
 		  /* Start scope of tag before parsing components.  */
 		}
 	  component_decl_list '}' maybe_attribute
@@ -1741,7 +1746,7 @@ structsp_attr:
 				      nreverse ($3), chainon ($1, $5));
 		}
 	| union_head identifier '{'
-		{ $$ = start_struct (UNION_TYPE, $2); }
+		{ $<ttype>$ = start_struct (UNION_TYPE, $2); }
 	  component_decl_list '}' maybe_attribute
 		{ $$ = finish_struct ($<ttype>4, nreverse ($5),
 				      chainon ($1, $7)); }
@@ -1750,12 +1755,12 @@ structsp_attr:
 				      nreverse ($3), chainon ($1, $5));
 		}
 	| enum_head identifier '{'
-		{ $$ = start_enum ($2); }
+		{ $<ttype>$ = start_enum ($2); }
 	  enumlist maybecomma_warn '}' maybe_attribute
 		{ $$ = finish_enum ($<ttype>4, nreverse ($5),
 				    chainon ($1, $8)); }
 	| enum_head '{'
-		{ $$ = start_enum (NULL_TREE); }
+		{ $<ttype>$ = start_enum (NULL_TREE); }
 	  enumlist maybecomma_warn '}' maybe_attribute
 		{ $$ = finish_enum ($<ttype>3, nreverse ($4),
 				    chainon ($1, $7)); }
diff --git a/gcc/collect2.c b/gcc/collect2.c
index 33206f5c..2d2d34ec 100644
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -34,6 +34,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 #if ! defined( SIGCHLD ) && defined( SIGCLD )
 #  define SIGCHLD SIGCLD
 #endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
 
 #ifdef vfork /* Autoconf may define this to fork for us.  */
 # define VFORK_STRING "fork"
@@ -1534,7 +1540,7 @@ collect_execute (const char *prog, char **argv, const char *redir)
   if (redir)
     {
       /* Open response file.  */
-      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT);
+      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR);
 
       /* Duplicate the stdout and stderr file handles
 	 so they can be restored later.  */
@@ -1574,14 +1580,24 @@ fork_execute (const char *prog, char **argv)
   do_wait (prog);
 }
 
-/* Unlink a file unless we are debugging.  */
-
+/* Unlink a file unless we are debugging or file is not normal.  */
+#ifndef S_ISLNK
+#ifdef S_IFLNK
+#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#else
+#define S_ISLNK(m) 0
+#define lstat stat
+#endif
+#endif
 static void
 maybe_unlink (const char *file)
 {
-  if (!debug)
-    unlink (file);
-  else
+  if (!debug) {
+    struct stat st;
+    if (lstat (file, &st) == 0
+        && (S_ISREG (st.st_mode) || S_ISLNK (st.st_mode)))
+      unlink (file);
+  } else
     notice ("[Leaving %s]\n", file);
 }
 
diff --git a/gcc/config.gcc b/gcc/config.gcc
index d22f34bc..a14e18c3 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -321,7 +321,7 @@ s390*-*-*)
 	need_64bit_hwint=yes
 	;;
 # Note the 'l'; we need to be able to match e.g. "shle" or "shl".
-sh[123456789l]*-*-*)
+sh[123456789lbe]*-*-*)
 	cpu_type=sh
 	need_64bit_hwint=yes
 	;;
@@ -678,6 +678,11 @@ arm*-*-netbsd*)
 	;;
 arm*-*-linux*)			# ARM GNU/Linux with ELF
 	tm_file="dbxelf.h elfos.h linux.h arm/elf.h  arm/linux-gas.h arm/linux-elf.h arm/aout.h arm/arm.h"
+	case $target in
+	arm*b-*)
+		tm_defines="TARGET_BIG_ENDIAN_DEFAULT=1 $tm_defines"
+		;;
+	esac
 	tmake_file="t-slibgcc-elf-ver t-linux arm/t-linux"
 	extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
 	gnu_ld=yes
@@ -977,11 +982,11 @@ x86_64-*-netbsd*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h"
 	;;
 i[34567]86-*-openbsd*)
-	tm_file="i386/i386.h i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h openbsd-oldgas.h openbsd.h i386/openbsd.h"
-	# needed to unconfuse gdb
-	tmake_file="t-libc-ok t-openbsd i386/t-openbsd"
-	# we need collect2 until our bug is fixed...
-	use_collect2=yes
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h"
+	tm_file="${tm_file} openbsd.h i386/openbsdelf.h"
+	gas=yes
+	gnu_ld=yes
+	stabs=yes
 	;;
 i[34567]86-*-coff*)
 	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/i386-coff.h"
@@ -1273,9 +1278,16 @@ ia64*-*-freebsd*)
 	;;
 ia64*-*-linux*)
 	tm_file="${tm_file} dbxelf.h elfos.h svr4.h linux.h ia64/sysv4.h ia64/linux.h"
-	tmake_file="t-slibgcc-elf-ver t-linux ia64/t-ia64 t-libunwind ia64/t-glibc"
-	if test x$with_system_libunwind != xyes ; then
-		tmake_file="${tmake_file} t-libunwind-elf ia64/t-glibc-libunwind"
+	tmake_file="t-slibgcc-elf-ver t-linux ia64/t-ia64"
+	if test x${target} = x${host} && test x${target} = x${build} \
+	   && grep gelf_getverdef /usr/include/gelf.h > /dev/null 2>&1 \
+	   && test -f /usr/lib/libelf.so; then
+		tmake_file="${tmake_file} ia64/t-glibc-no-libunwind"
+	else
+		tmake_file="${tmake_file} t-libunwind ia64/t-glibc"
+		if test x$with_system_libunwind != xyes ; then
+			tmake_file="${tmake_file} t-libunwind-elf ia64/t-glibc-libunwind"
+		fi
 	fi
 	target_cpu_default="MASK_GNU_AS|MASK_GNU_LD"
 	extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtfastmath.o"
@@ -2019,7 +2031,8 @@ sparc-*-netbsdelf*)
 	;;
 sparc-*-openbsd*)
 	tm_defines=OBSD_OLD_GAS
-	tm_file="sparc/sparc.h openbsd.h sparc/openbsd.h"
+	tm_file="sparc/sparc.h elfos.h svr4.h sparc/sysv4.h ${tm_file}"
+	tm_file="${tm_file} exec-stack.h"
 	# needed to unconfuse gdb
 	tmake_file="t-libc-ok t-openbsd sparc/t-openbsd"
 	# we need collect2 until our bug is fixed...
diff --git a/gcc/config/alpha/alpha.h b/gcc/config/alpha/alpha.h
index ae3a349f..bcaeda69 100644
--- a/gcc/config/alpha/alpha.h
+++ b/gcc/config/alpha/alpha.h
@@ -96,7 +96,7 @@ Boston, MA 02111-1307, USA.  */
   while (0)
 #endif
 
-#define CPP_SPEC "%(cpp_subtarget)"
+#define CPP_SPEC "%(cpp_subtarget) %{!no-ieee:-mieee}"
 
 #ifndef CPP_SUBTARGET_SPEC
 #define CPP_SUBTARGET_SPEC ""
@@ -301,6 +301,8 @@ extern int alpha_tls_size;
      N_("Request IEEE-conformant math library routines (OSF/1)")},	\
     {"ieee", MASK_IEEE|MASK_IEEE_CONFORMANT,				\
      N_("Emit IEEE-conformant code, without inexact exceptions")},	\
+    {"no-ieee", - (MASK_IEEE|MASK_IEEE_CONFORMANT),				\
+     N_("Do not emit IEEE-conformant code, without inexact exceptions")},	\
     {"ieee-with-inexact", MASK_IEEE_WITH_INEXACT|MASK_IEEE_CONFORMANT,	\
      N_("Emit IEEE-conformant code, with inexact exceptions")},		\
     {"build-constants", MASK_BUILD_CONSTANTS,				\
diff --git a/gcc/config/alpha/linux.h b/gcc/config/alpha/linux.h
index a4bc3d3e..9e991140 100644
--- a/gcc/config/alpha/linux.h
+++ b/gcc/config/alpha/linux.h
@@ -73,6 +73,7 @@ Boston, MA 02111-1307, USA.  */
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
+#ifndef inhibit_libc
 #ifdef IN_LIBGCC2
 #include <signal.h>
 #include <sys/ucontext.h>
@@ -94,8 +95,8 @@ Boston, MA 02111-1307, USA.  */
     else if (pc_[1] == 0x201f015f)	/* lda $0,NR_rt_sigreturn */	\
       {									\
 	struct rt_sigframe {						\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = &rt_->uc.uc_mcontext;					\
       }									\
@@ -122,3 +123,4 @@ Boston, MA 02111-1307, USA.  */
     (FS)->retaddr_column = 64;						\
     goto SUCCESS;							\
   } while (0)
+#endif /* inhibit_libc */
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 2f0eaedb..9a2c4791 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -4572,6 +4572,10 @@ minmax_code (rtx x)
 int
 adjacent_mem_locations (rtx a, rtx b)
 {
+  /* We don't guarantee to preserve the order of these memory refs.  */
+  if (volatile_refs_p (a) || volatile_refs_p (b))
+    return 0;
+
   if ((GET_CODE (XEXP (a, 0)) == REG
        || (GET_CODE (XEXP (a, 0)) == PLUS
 	   && GET_CODE (XEXP (XEXP (a, 0), 1)) == CONST_INT))
@@ -4611,6 +4615,17 @@ adjacent_mem_locations (rtx a, rtx b)
 	return 0;
 
       val_diff = val1 - val0;
+
+      if (arm_ld_sched)
+	{
+	  /* If the target has load delay slots, then there's no benefit
+	     to using an ldm instruction unless the offset is zero and
+	     we are optimizing for size.  */
+	  return (optimize_size && (REGNO (reg0) == REGNO (reg1))
+		  && (val0 == 0 || val1 == 0 || val0 == 4 || val1 == 4)
+		  && (val_diff == 4 || val_diff == -4));
+	}
+
       return ((REGNO (reg0) == REGNO (reg1))
 	      && (val_diff == 4 || val_diff == -4));
     }
@@ -4857,6 +4872,11 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,
       *load_offset = unsorted_offsets[order[0]];
     }
 
+  /* For XScale a two-word LDM is a performance loss, so only do this if
+     size is more important.  See comments in arm_gen_load_multiple.  */
+  if (nops == 2 && arm_tune_xscale && !optimize_size)
+    return 0;
+
   if (unsorted_offsets[order[0]] == 0)
     return 1; /* ldmia */
 
@@ -5083,6 +5103,11 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,
       *load_offset = unsorted_offsets[order[0]];
     }
 
+  /* For XScale a two-word LDM is a performance loss, so only do this if
+     size is more important.  See comments in arm_gen_load_multiple.  */
+  if (nops == 2 && arm_tune_xscale && !optimize_size)
+    return 0;
+
   if (unsorted_offsets[order[0]] == 0)
     return 1; /* stmia */
 
@@ -8514,6 +8539,26 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)
   return_used_this_function = 0;  
 }
 
+/* Return the number (counting from 0) of
+   the least significant set bit in MASK.  */
+
+#ifdef __GNUC__
+inline
+#endif
+static int
+number_of_first_bit_set (mask)
+     int mask;
+{
+  int bit;
+
+  for (bit = 0;
+       (mask & (1 << bit)) == 0;
+       ++bit)
+    continue;
+
+  return bit;
+}
+
 const char *
 arm_output_epilogue (rtx sibling)
 {
@@ -8747,27 +8792,47 @@ arm_output_epilogue (rtx sibling)
 	  saved_regs_mask |=   (1 << PC_REGNUM);
 	}
 
-      /* Load the registers off the stack.  If we only have one register
-	 to load use the LDR instruction - it is faster.  */
-      if (saved_regs_mask == (1 << LR_REGNUM))
-	{
-	  /* The exception handler ignores the LR, so we do
-	     not really need to load it off the stack.  */
-	  if (eh_ofs)
-	    asm_fprintf (f, "\tadd\t%r, %r, #4\n", SP_REGNUM, SP_REGNUM);
-	  else
-	    asm_fprintf (f, "\tldr\t%r, [%r], #4\n", LR_REGNUM, SP_REGNUM);
-	}
-      else if (saved_regs_mask)
+      if (saved_regs_mask)
 	{
-	  if (saved_regs_mask & (1 << SP_REGNUM))
-	    /* Note - write back to the stack register is not enabled
-	       (ie "ldmfd sp!...").  We know that the stack pointer is
-	       in the list of registers and if we add writeback the
-	       instruction becomes UNPREDICTABLE.  */
-	    print_multi_reg (f, "ldmfd\t%r", SP_REGNUM, saved_regs_mask);
+	  /* Load the registers off the stack.  If we only have one register
+	     to load use the LDR instruction - it is faster.  */
+	  if (bit_count (saved_regs_mask) == 1)
+	    {
+	      int reg = number_of_first_bit_set (saved_regs_mask);
+
+	      switch (reg)
+		{
+		case SP_REGNUM:
+		  /* Mustn't use base writeback when loading SP.  */
+		  asm_fprintf (f, "\tldr\t%r, [%r]\n", SP_REGNUM, SP_REGNUM);
+		  break;
+		  
+		case LR_REGNUM:
+		  if (eh_ofs)
+		    {
+		      /* The exception handler ignores the LR, so we do
+			 not really need to load it off the stack.  */
+		      asm_fprintf (f, "\tadd\t%r, %r, #4\n", SP_REGNUM, SP_REGNUM);
+		      break;
+		    }
+		  /* else fall through */
+		  
+		default:
+		  asm_fprintf (f, "\tldr\t%r, [%r], #4\n", reg, SP_REGNUM);
+		  break;
+		}
+	    }
 	  else
-	    print_multi_reg (f, "ldmfd\t%r!", SP_REGNUM, saved_regs_mask);
+	    {
+	      if (saved_regs_mask & (1 << SP_REGNUM))
+		/* Note - write back to the stack register is not enabled
+		   (ie "ldmfd sp!...").  We know that the stack pointer is
+		   in the list of registers and if we add writeback the
+		   instruction becomes UNPREDICTABLE.  */
+		print_multi_reg (f, "ldmfd\t%r", SP_REGNUM, saved_regs_mask);
+	      else
+		print_multi_reg (f, "ldmfd\t%r!", SP_REGNUM, saved_regs_mask);
+	    }
 	}
 
       if (current_function_pretend_args_size)
@@ -11395,22 +11460,6 @@ replace_symbols_in_block (tree block, rtx orig, rtx new)
     }
 }
 
-/* Return the number (counting from 0) of
-   the least significant set bit in MASK.  */
-
-inline static int
-number_of_first_bit_set (int mask)
-{
-  int bit;
-
-  for (bit = 0;
-       (mask & (1 << bit)) == 0;
-       ++bit)
-    continue;
-
-  return bit;
-}
-
 /* Generate code to return from a thumb function.
    If 'reg_containing_return_addr' is -1, then the return address is
    actually on the stack, at the stack pointer.  */
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index 0a5e647a..730248d9 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -8811,13 +8811,16 @@
    (set_attr "length" "4,8,8")]
 )
 
+; Try to convert LDR+LDR+arith into [add+]LDM+arith
+; On XScale, LDM is always slower than two LDRs, so only do this if
+; optimising for size.
 (define_insn "*arith_adjacentmem"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(match_operator:SI 1 "shiftable_operator"
 	 [(match_operand:SI 2 "memory_operand" "m")
 	  (match_operand:SI 3 "memory_operand" "m")]))
    (clobber (match_scratch:SI 4 "=r"))]
-  "TARGET_ARM && adjacent_mem_locations (operands[2], operands[3])"
+  "TARGET_ARM && (!arm_tune_xscale || optimize_size) && adjacent_mem_locations (operands[2], operands[3])"
   "*
   {
     rtx ldm[3];
@@ -8852,6 +8855,8 @@
       }
    if (val1 && val2)
       {
+	/* This would be a loss on a Harvard core, but adjacent_mem_locations()
+	   will prevent it from happening.  */
 	rtx ops[3];
 	ldm[0] = ops[0] = operands[4];
 	ops[1] = XEXP (XEXP (operands[2], 0), 0);
diff --git a/gcc/config/arm/linux-elf.h b/gcc/config/arm/linux-elf.h
index 9f291c0b..9958d40e 100644
--- a/gcc/config/arm/linux-elf.h
+++ b/gcc/config/arm/linux-elf.h
@@ -30,17 +30,34 @@
 /* Do not assume anything about header files.  */
 #define NO_IMPLICIT_EXTERN_C
 
+/*
+ * 'config.gcc' defines TARGET_BIG_ENDIAN_DEFAULT as 1 for arm*b-*
+ * (big endian) configurations.
+ */
+#if TARGET_BIG_ENDIAN_DEFAULT
+#define TARGET_ENDIAN_DEFAULT ARM_FLAG_BIG_END
+#define TARGET_ENDIAN_OPTION "mbig-endian"
+#define TARGET_LINKER_EMULATION "armelfb_linux"
+#else
+#define TARGET_ENDIAN_DEFAULT 0
+#define TARGET_ENDIAN_OPTION "mlittle-endian"
+#define TARGET_LINKER_EMULATION "armelf_linux"
+#endif
+
 /* Default is to use APCS-32 mode.  */
 #undef  TARGET_DEFAULT
-#define TARGET_DEFAULT (ARM_FLAG_APCS_32 | ARM_FLAG_MMU_TRAPS)
+#define TARGET_DEFAULT \
+		( ARM_FLAG_APCS_32 | \
+		  ARM_FLAG_MMU_TRAPS | \
+		  TARGET_ENDIAN_DEFAULT )
 
 #define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm6
 
-#define SUBTARGET_EXTRA_LINK_SPEC " -m armelf_linux -p"
+#define SUBTARGET_EXTRA_LINK_SPEC " -m " TARGET_LINKER_EMULATION " -p"
 
 #undef  MULTILIB_DEFAULTS
 #define MULTILIB_DEFAULTS \
-	{ "marm", "mlittle-endian", "mhard-float", "mapcs-32", "mno-thumb-interwork" }
+	{ "marm", TARGET_ENDIAN_OPTION, "mhard-float", "mapcs-32", "mno-thumb-interwork" }
 
 #define CPP_APCS_PC_DEFAULT_SPEC "-D__APCS_32__"
 
@@ -89,7 +106,7 @@
    %{rdynamic:-export-dynamic} \
    %{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2} \
    -X \
-   %{mbig-endian:-EB}" \
+   %{mbig-endian:-EB} %{mlittle-endian:-EL}" \
    SUBTARGET_EXTRA_LINK_SPEC
 
 #define TARGET_OS_CPP_BUILTINS() LINUX_TARGET_OS_CPP_BUILTINS()
diff --git a/gcc/config/avr/avr.c b/gcc/config/avr/avr.c
index e65a98b4..e29a4877 100644
--- a/gcc/config/avr/avr.c
+++ b/gcc/config/avr/avr.c
@@ -175,6 +175,18 @@ static const struct mcu_type_s avr_mcu_types[] = {
   { "at90c8534", 2, "__AVR_AT90C8534__" },
   { "at90s8535", 2, "__AVR_AT90S8535__" },
   { "at86rf401", 2, "__AVR_AT86RF401__" },
+    /* Classic + MOVW, <= 8K.  */
+  { "attiny13",   2, "__AVR_ATtiny13__" },
+  { "attiny2313", 2, "__AVR_ATtiny2313__" },  
+  { "attiny24", 2, "__AVR_ATtiny24__" },
+  { "attiny25", 2, "__AVR_ATtiny25__" },
+  { "attiny261", 2, "__AVR_ATtiny261__" },
+  { "attiny44", 2, "__AVR_ATtiny44__" },
+  { "attiny45", 2, "__AVR_ATtiny45__" },
+  { "attiny461", 2, "__AVR_ATtiny461__" },
+  { "attiny84", 2, "__AVR_ATtiny84__" },
+  { "attiny85", 2, "__AVR_ATtiny85__" },
+  { "attiny861", 2, "__AVR_ATtiny861__" },
     /* Classic, > 8K.  */
   { "avr3",      3, NULL },
   { "atmega103", 3, "__AVR_ATmega103__" },
@@ -185,6 +197,8 @@ static const struct mcu_type_s avr_mcu_types[] = {
     /* Enhanced, <= 8K.  */
   { "avr4",      4, NULL },
   { "atmega8",   4, "__AVR_ATmega8__" },
+  { "atmega48",   4, "__AVR_ATmega48__" },
+  { "atmega88",   4, "__AVR_ATmega88__" },
   { "atmega8515", 4, "__AVR_ATmega8515__" },
   { "atmega8535", 4, "__AVR_ATmega8535__" },
     /* Enhanced, > 8K.  */
@@ -193,11 +207,35 @@ static const struct mcu_type_s avr_mcu_types[] = {
   { "atmega161", 5, "__AVR_ATmega161__" },
   { "atmega162", 5, "__AVR_ATmega162__" },
   { "atmega163", 5, "__AVR_ATmega163__" },
+  { "atmega164", 5, "__AVR_ATmega164__" },
+  { "atmega165", 5, "__AVR_ATmega165__" },
+  { "atmega168", 5, "__AVR_ATmega168__" },
   { "atmega169", 5, "__AVR_ATmega169__" },
   { "atmega32",  5, "__AVR_ATmega32__" },
   { "atmega323", 5, "__AVR_ATmega323__" },
+  { "atmega324", 5, "__AVR_ATmega324__" },
+  { "atmega325", 5, "__AVR_ATmega325__" },
+  { "atmega3250", 5, "__AVR_ATmega3250__" },
+  { "atmega329", 5, "__AVR_ATmega329__" },
+  { "atmega3290", 5, "__AVR_ATmega3290__" },
+  { "atmega406", 5, "__AVR_ATmega406__" },
   { "atmega64",  5, "__AVR_ATmega64__" },
+  { "atmega640", 5, "__AVR_ATmega640__" },
+  { "atmega644", 5, "__AVR_ATmega644__" },
+  { "atmega645", 5, "__AVR_ATmega645__" },
+  { "atmega6450", 5, "__AVR_ATmega6450__" },
+  { "atmega649", 5, "__AVR_ATmega649__" },
+  { "atmega6490", 5, "__AVR_ATmega6490__" },
   { "atmega128", 5, "__AVR_ATmega128__" },
+  { "atmega1280",5, "__AVR_ATmega1280__" },
+  { "atmega1281",5, "__AVR_ATmega1281__" },
+  { "at90usb646", 5, "__AVR_AT90USB646__" },
+  { "at90usb647", 5, "__AVR_AT90USB647__" },
+  { "at90usb1286", 5, "__AVR_AT90USB1286__" },
+  { "at90usb1287", 5, "__AVR_AT90USB1287__" },
+  { "at90can32", 5, "__AVR_AT90CAN32__" },
+  { "at90can64", 5, "__AVR_AT90CAN64__" },
+  { "at90can128", 5, "__AVR_AT90CAN128__" },
   { "at94k",     5, "__AVR_AT94K__" },
     /* Assembler only.  */
   { "avr1",      1, NULL },
diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
index 4a2db2c2..8ba77c51 100644
--- a/gcc/config/avr/avr.h
+++ b/gcc/config/avr/avr.h
@@ -2351,12 +2351,12 @@ extern int avr_case_values_threshold;
    Do not define this macro if it does not need to do anything.  */
 
 #define LINK_SPEC " %{!mmcu*:-m avr2}\
-%{mmcu=at90s1200|mmcu=attiny1*|mmcu=attiny28:-m avr1} \
-%{mmcu=attiny22|mmcu=attiny26|mmcu=at90s2*|mmcu=at90s4*|mmcu=at90s8*|mmcu=at90c8*|mmcu=at86rf401:-m avr2}\
+%{mmcu=at90s1200|mmcu=attiny11|mmcu=attiny12|mmcu=attiny15|mmcu=attiny28:-m avr1} \
+%{mmcu=attiny22|mmcu=attiny26|mmcu=at90s2*|mmcu=at90s4*|mmcu=at90s8*|mmcu=at90c8*|mmcu=at86rf401|mmcu=attiny13|mmcu=attiny2313|mmcu=attiny25|mmcu=attiny45|mmcu=attiny85|mmcu=attiny24|mmcu=attiny44|mmcu=attiny84|mmcu=attiny261|mmcu=attiny461|mmcu=attiny861:-m avr2}\
 %{mmcu=atmega103|mmcu=atmega603|mmcu=at43*|mmcu=at76*:-m avr3}\
-%{mmcu=atmega8*:-m avr4}\
-%{mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega64|mmcu=atmega128|mmcu=at94k:-m avr5}\
-%{mmcu=atmega64|mmcu=atmega128|mmcu=atmega162|mmcu=atmega169: -Tdata 0x800100} "
+%{mmcu=atmega8*|mmcu=atmega48:-m avr4}\
+%{mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega406|mmcu=atmega64*|mmcu=atmega128*|mmcu=at90can*|mmcu=at90usb*|mmcu=at94k:-m avr5}\
+%{mmcu=atmega48|mmcu=atmega88|mmcu=atmega128*|mmcu=at90can*|mmcu=at90usb*|mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega406|mmcu=atmega64*: -Tdata 0x800100} "
 
 /* A C string constant that tells the GCC driver program options to
    pass to the linker.  It can also specify how to translate options
@@ -2365,7 +2365,7 @@ extern int avr_case_values_threshold;
    Do not define this macro if it does not need to do anything.  */
 
 #define LIB_SPEC \
-  "%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lc }}}"
+  "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lc }}}}}"
 /* Another C string constant used much like `LINK_SPEC'.  The
    difference between the two is that `LIB_SPEC' is used at the end
    of the command given to the linker.
@@ -2377,7 +2377,7 @@ extern int avr_case_values_threshold;
 /* No libstdc++ for now.  Empty string doesn't work.  */
 
 #define LIBGCC_SPEC \
-  "%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lgcc }}}"
+  "%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lgcc }}}}}"
 /* Another C string constant that tells the GCC driver program how
    and when to place a reference to `libgcc.a' into the linker
    command line.  This constant is placed both before and after the
@@ -2421,23 +2421,60 @@ extern int avr_case_values_threshold;
 %{mmcu=at90c8534:crtc8534.o%s} \
 %{mmcu=at90s8535:crts8535.o%s} \
 %{mmcu=at86rf401:crt86401.o%s} \
+%{mmcu=attiny13:crttn13.o%s} \
+%{mmcu=attiny2313:crttn2313.o%s} \
+%{mmcu=attiny24:crttn24.o%s} \
+%{mmcu=attiny44:crttn44.o%s} \
+%{mmcu=attiny85:crttn84.o%s} \
+%{mmcu=attiny25:crttn25.o%s} \
+%{mmcu=attiny45:crttn45.o%s} \
+%{mmcu=attiny85:crttn85.o%s} \
+%{mmcu=attiny261:crttn261.o%s} \
+%{mmcu=attiny461:crttn461.o%s} \
+%{mmcu=attiny861:crttn861.o%s} \
 %{mmcu=atmega103|mmcu=avr3:crtm103.o%s} \
 %{mmcu=atmega603:crtm603.o%s} \
 %{mmcu=at43usb320:crt43320.o%s} \
 %{mmcu=at43usb355:crt43355.o%s} \
 %{mmcu=at76c711:crt76711.o%s} \
 %{mmcu=atmega8|mmcu=avr4:crtm8.o%s} \
+%{mmcu=atmega48:crtm48.o%s} \
+%{mmcu=atmega88:crtm88.o%s} \
 %{mmcu=atmega8515:crtm8515.o%s} \
 %{mmcu=atmega8535:crtm8535.o%s} \
 %{mmcu=atmega16:crtm16.o%s} \
 %{mmcu=atmega161|mmcu=avr5:crtm161.o%s} \
 %{mmcu=atmega162:crtm162.o%s} \
 %{mmcu=atmega163:crtm163.o%s} \
+%{mmcu=atmega164:crtm164.o%s} \
+%{mmcu=atmega165:crtm165.o%s} \
+%{mmcu=atmega168:crtm168.o%s} \
 %{mmcu=atmega169:crtm169.o%s} \
 %{mmcu=atmega32:crtm32.o%s} \
 %{mmcu=atmega323:crtm323.o%s} \
+%{mmcu=atmega324:crtm324.o%s} \
+%{mmcu=atmega325:crtm325.o%s} \
+%{mmcu=atmega3250:crtm3250.o%s} \
+%{mmcu=atmega329:crtm329.o%s} \
+%{mmcu=atmega3290:crtm3290.o%s} \
+%{mmcu=atmega406:crtm406.o%s} \
 %{mmcu=atmega64:crtm64.o%s} \
+%{mmcu=atmega640:crtm640.o%s} \
+%{mmcu=atmega644:crtm644.o%s} \
+%{mmcu=atmega645:crtm645.o%s} \
+%{mmcu=atmega6450:crtm6450.o%s} \
+%{mmcu=atmega649:crtm649.o%s} \
+%{mmcu=atmega6490:crtm6490.o%s} \
 %{mmcu=atmega128:crtm128.o%s} \
+%{mmcu=atmega1280:crtm1280.o%s} \
+%{mmcu=atmega1281:crtm1281.o%s} \
+%{mmcu=at90usb646:crtusb646.o%s} \
+%{mmcu=at90usb647:crtusb647.o%s} \
+%{mmcu=at90usb1286:crtusb1286.o%s} \
+%{mmcu=at90usb1287:crtusb1287.o%s} \
+%{mmcu=at90can32:crtcan32.o%s} \
+%{mmcu=at90can64:crtcan64.o%s} \
+%{mmcu=at90can128:crtcan128.o%s} \
 %{mmcu=at94k:crtat94k.o%s}"
 
 #define EXTRA_SPECS {"crt_binutils", CRT_BINUTILS_SPECS},
diff --git a/gcc/config/avr/t-avr b/gcc/config/avr/t-avr
index bb2733eb..9d308cfa 100644
--- a/gcc/config/avr/t-avr
+++ b/gcc/config/avr/t-avr
@@ -46,13 +46,25 @@ MULTILIB_MATCHES = \
 	mmcu?avr3=mmcu?at43usb320 mmcu?avr3=mmcu?at43usb355 \
 	mmcu?avr3=mmcu?at76c711 \
 	mmcu?avr4=mmcu?atmega8515 mmcu?avr4=mmcu?atmega8535 \
-	mmcu?avr4=mmcu?atmega8 \
+	mmcu?avr4=mmcu?atmega8 mmcu?avr4=mmcu?atmega48 \
+	mmcu?avr4=mmcu?atmega88 \
 	mmcu?avr5=mmcu?atmega161 mmcu?avr5=mmcu?atmega162 \
-	mmcu?avr5=mmcu?atmega163 mmcu?avr5=mmcu?atmega169 \
-	mmcu?avr5=mmcu?atmega16 \
+	mmcu?avr5=mmcu?atmega163 mmcu?avr5=mmcu?atmega164 \
+	mmcu?avr=mmcu?atmega165 mmcu?avr5=mmcu?atmega168 \
+	mmcu?avr5=mmcu?atmega169 mmcu?avr5=mmcu?atmega16 \
 	mmcu?avr5=mmcu?atmega323 mmcu?avr5=mmcu?atmega32 \
+	mmcu?avr=mmcu?atmega329 mmcu?avr5=mmcu?atmega3290 \
+	mmcu?avr5=mmcu?atmega324 mmcu?avr5=mmcu?atmega644 \
+	mmcu?avr5=mmcu?atmega406 mmcu?avr5=mmcu?atmega640 \
+	mmcu?avr5=mmcu?atmega649 mmcu?avr5=mmcu?atmega6490 \
 	mmcu?avr5=mmcu?atmega64  mmcu?avr5=mmcu?atmega128 \
-	mmcu?avr5=mmcu?at94k
+	mmcu?avr5=mmcu?atmega1280 mmcu?avr5=mmcu?atmega1281 \
+	mmcu?avr5=mmcu?atmega325 mmcu?avr5=mmcu?atmega3250 \
+	mmcu?avr5=mmcu?atmega645 mmcu?avr5=mmcu?atmega6450 \
+	mmcu?avr5=mmcu?at90can32 mmcu?avr5=mmcu?at90can64 \
+	mmcu?avr5=mmcu?at90usb646 mmcu?avr5=mmcu?at90usb647 \
+	mmcu?avr5=mmcu?at90usb1286 mmcu?avr5=mmcu?at90usb1287 \
+	mmcu?avr5=mmcu?at94k mmcu?avr5=mmcu?at90can128
 
 MULTILIB_EXCEPTIONS =
 
diff --git a/gcc/config/freebsd-spec.h b/gcc/config/freebsd-spec.h
index 8acf0cad..20128156 100644
--- a/gcc/config/freebsd-spec.h
+++ b/gcc/config/freebsd-spec.h
@@ -154,8 +154,4 @@ is built with the --enable-threads configure-time option.}		\
 #endif
 #endif
 
-#if FBSD_MAJOR < 6
-#define FBSD_DYNAMIC_LINKER "/usr/libexec/ld-elf.so.1"
-#else
 #define FBSD_DYNAMIC_LINKER "/libexec/ld-elf.so.1"
-#endif
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index e6f71b46..a5339cf4 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -2026,11 +2026,11 @@ classify_argument (enum machine_mode mode, tree type,
 	    {
 	      tree bases = TYPE_BINFO_BASETYPES (type);
 	      int n_bases = TREE_VEC_LENGTH (bases);
-	      int i;
+	      int basenum;
 
-	      for (i = 0; i < n_bases; ++i)
+	      for (basenum = 0; basenum < n_bases; ++basenum)
 		{
-		   tree binfo = TREE_VEC_ELT (bases, i);
+		   tree binfo = TREE_VEC_ELT (bases, basenum);
 		   int num;
 		   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;
 		   tree type = BINFO_TYPE (binfo);
@@ -2114,11 +2114,11 @@ classify_argument (enum machine_mode mode, tree type,
 	    {
 	      tree bases = TYPE_BINFO_BASETYPES (type);
 	      int n_bases = TREE_VEC_LENGTH (bases);
-	      int i;
+	      int basenum;
 
-	      for (i = 0; i < n_bases; ++i)
+	      for (basenum = 0; basenum < n_bases; ++basenum)
 		{
-		   tree binfo = TREE_VEC_ELT (bases, i);
+		   tree binfo = TREE_VEC_ELT (bases, basenum);
 		   int num;
 		   int offset = tree_low_cst (BINFO_OFFSET (binfo), 0) * 8;
 		   tree type = BINFO_TYPE (binfo);
@@ -3820,6 +3820,21 @@ const_0_to_255_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)
   return (GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 256);
 }
 
+/* Match exactly one bit in 4-bit mask. */
+int
+const_pow2_1_to_8_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  unsigned int log = exact_log2 (INTVAL (op));
+  return log <= 3;
+}
+
+/* Match exactly one bit in 8-bit mask. */
+int
+const_pow2_1_to_128_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  unsigned int log = exact_log2 (INTVAL (op));
+  return log <= 7;
+}
 
 /* True if this is a constant appropriate for an increment or decrement.  */
 
@@ -14199,7 +14214,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,
       if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))
 	{
 	  error ("selector must be an integer constant in the range 0..%i",
-		  fcode == IX86_BUILTIN_PINSRW ? 15:255);
+		  fcode == IX86_BUILTIN_PINSRW ? 3:7);
 	  return const0_rtx;
 	}
       if (target == 0
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index 8a912d5f..35a881af 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -2944,6 +2944,8 @@ do {						\
   {"const_0_to_7_operand", {CONST_INT}},				\
   {"const_0_to_15_operand", {CONST_INT}},				\
   {"const_0_to_255_operand", {CONST_INT}},				\
+  {"const_pow2_1_to_8_operand", {CONST_INT}}, \
+  {"const_pow2_1_to_128_operand", {CONST_INT}}, \
   {"incdec_operand", {CONST_INT}},					\
   {"mmx_reg_operand", {REG}},						\
   {"reg_no_sp_operand", {SUBREG, REG}},					\
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 0fbe00b6..ee933267 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -20440,14 +20440,31 @@
 
 ;; MMX insert/extract/shuffle
 
-(define_insn "mmx_pinsrw"
+(define_expand "mmx_pinsrw"
+  [(set (match_operand:V4HI 0 "register_operand" "")
+        (vec_merge:V4HI
+	  (match_operand:V4HI 1 "register_operand" "")
+          (vec_duplicate:V4HI
+            (match_operand:SI 2 "nonimmediate_operand" ""))
+          (match_operand:SI 3 "const_0_to_3_operand" "")))]
+  "TARGET_SSE || TARGET_3DNOW_A"
+{
+  operands[2] = gen_lowpart (HImode, operands[2]);
+  operands[3] = GEN_INT (1 << INTVAL (operands[3]));
+})
+
+(define_insn "*mmx_pinsrw"
   [(set (match_operand:V4HI 0 "register_operand" "=y")
-        (vec_merge:V4HI (match_operand:V4HI 1 "register_operand" "0")
-			(vec_duplicate:V4HI
-			 (truncate:HI (match_operand:SI 2 "nonimmediate_operand" "rm")))
-			(match_operand:SI 3 "const_0_to_15_operand" "N")))]
+        (vec_merge:V4HI
+	  (match_operand:V4HI 1 "register_operand" "0")
+          (vec_duplicate:V4HI
+            (match_operand:HI 2 "nonimmediate_operand" "rm"))
+          (match_operand:SI 3 "const_pow2_1_to_8_operand" "N")))]
   "TARGET_SSE || TARGET_3DNOW_A"
-  "pinsrw\t{%3, %2, %0|%0, %2, %3}"
+{
+  operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
+  return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
+}
   [(set_attr "type" "mmxcvt")
    (set_attr "mode" "DI")])
 
@@ -22135,15 +22152,31 @@
 
 ;; MMX insert/extract/shuffle
 
-(define_insn "sse2_pinsrw"
+(define_expand "sse2_pinsrw"
+  [(set (match_operand:V8HI 0 "register_operand" "")
+        (vec_merge:V8HI
+	  (match_operand:V8HI 1 "register_operand" "")
+          (vec_duplicate:V8HI
+            (match_operand:SI 2 "nonimmediate_operand" ""))
+          (match_operand:SI 3 "const_0_to_7_operand" "")))]
+  "TARGET_SSE2"
+{
+  operands[2] = gen_lowpart (HImode, operands[2]);
+  operands[3] = GEN_INT (1 << INTVAL (operands[3]));
+})
+
+(define_insn "*sse2_pinsrw"
   [(set (match_operand:V8HI 0 "register_operand" "=x")
-        (vec_merge:V8HI (match_operand:V8HI 1 "register_operand" "0")
-			(vec_duplicate:V8HI
-			 (truncate:HI
-			   (match_operand:SI 2 "nonimmediate_operand" "rm")))
-			(match_operand:SI 3 "const_0_to_255_operand" "N")))]
+        (vec_merge:V8HI
+	  (match_operand:V8HI 1 "register_operand" "0")
+          (vec_duplicate:V8HI
+            (match_operand:HI 2 "nonimmediate_operand" "rm"))
+          (match_operand:SI 3 "const_pow2_1_to_128_operand" "N")))]
   "TARGET_SSE2"
-  "pinsrw\t{%3, %2, %0|%0, %2, %3}"
+{
+  operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
+  return "pinsrw\t{%3, %k2, %0|%0, %k2, %3}";
+}
   [(set_attr "type" "ssecvt")
    (set_attr "mode" "TI")])
 
diff --git a/gcc/config/i386/linux.h b/gcc/config/i386/linux.h
index e7d19ec1..d5bdb1ef 100644
--- a/gcc/config/i386/linux.h
+++ b/gcc/config/i386/linux.h
@@ -208,6 +208,7 @@ Boston, MA 02111-1307, USA.  */
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
+#ifndef inhibit_libc
 #ifdef IN_LIBGCC2
 /* There's no sys/ucontext.h for some (all?) libc1, so no
    signal-turned-exceptions for them.  There's also no configure-run for
@@ -235,10 +236,10 @@ Boston, MA 02111-1307, USA.  */
       {									\
 	struct rt_sigframe {						\
 	  int sig;							\
-	  struct siginfo *pinfo;					\
+	  siginfo_t *pinfo;						\
 	  void *puc;							\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
       }									\
@@ -272,3 +273,4 @@ Boston, MA 02111-1307, USA.  */
   } while (0)
 #endif /* not USE_GNULIBC_1 */
 #endif /* IN_LIBGCC2 */
+#endif /* inhibit_libc */
diff --git a/gcc/config/i386/linux64.h b/gcc/config/i386/linux64.h
index 98536c19..59d9ffa0 100644
--- a/gcc/config/i386/linux64.h
+++ b/gcc/config/i386/linux64.h
@@ -90,7 +90,7 @@ Boston, MA 02111-1307, USA.  */
     if (*(unsigned char *)(pc_+0) == 0x48				\
 	&& *(unsigned long *)(pc_+1) == 0x050f0000000fc0c7)		\
       {									\
-	struct ucontext *uc_ = (CONTEXT)->cfa;				\
+	ucontext_t *uc_ = (CONTEXT)->cfa;				\
 	sc_ = (struct sigcontext *) &uc_->uc_mcontext;			\
       }									\
     else								\
@@ -157,10 +157,10 @@ Boston, MA 02111-1307, USA.  */
       {									\
 	struct rt_sigframe {						\
 	  int sig;							\
-	  struct siginfo *pinfo;					\
+	  siginfo_t *pinfo;						\
 	  void *puc;							\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
       }									\
diff --git a/gcc/config/i386/openbsdelf.h b/gcc/config/i386/openbsdelf.h
new file mode 100644
index 00000000..25d6a3ef
--- /dev/null
+++ b/gcc/config/i386/openbsdelf.h
@@ -0,0 +1,135 @@
+
+/* Configuration for an OpenBSD i386 target.
+   
+   Copyright (C) 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This gets defined in tm.h->linux.h->svr4.h, and keeps us from using
+   libraries compiled with the native cc, so undef it. */
+#undef NO_DOLLAR_IN_LABEL
+
+/* Override the default comment-starter of "/".  */
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
+
+/* This goes away when the math-emulator is fixed */
+#undef TARGET_DEFAULT
+#define TARGET_DEFAULT \
+  (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_NO_FANCY_MATH_387)
+
+/* Run-time target specifications */
+
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+    	OPENBSD_OS_CPP_BUILTINS_ELF();		\
+    }						\
+  while (0)
+
+/* As an elf system, we need crtbegin/crtend stuff.  */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "\
+	%{!shared: %{pg:gcrt0%O%s} %{!pg:%{p:gcrt0%O%s} %{!p:crt0%O%s}} \
+	crtbegin%O%s} %{shared:crtbeginS%O%s}"
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{!shared:crtend%O%s} %{shared:crtendS%O%s}"
+
+/* Layout of source language data types.  */
+
+/* This must agree with <machine/ansi.h> */
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+/* Assembler format: overall framework.  */
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef SET_ASM_OP
+#define SET_ASM_OP	"\t.set\t"
+
+/* The following macros were originally stolen from i386v4.h.
+   These have to be defined to get PIC code correct.  */
+
+/* Assembler format: dispatch tables.  */
+
+/* Assembler format: sections.  */
+
+/* Stack & calling: aggregate returns.  */
+
+/* Don't default to pcc-struct-return, because gcc is the only compiler, and
+   we want to retain compatibility with older gcc versions.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* Assembler format: alignment output.  */
+
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP) \
+  if ((LOG) != 0) {\
+    if ((MAX_SKIP) == 0) fprintf ((FILE), "\t.p2align %d\n", (LOG)); \
+    else fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP)); \
+  }
+#endif
+
+/* Stack & calling: profiling.  */
+
+/* OpenBSD's profiler recovers all information from the stack pointer.
+   The icky part is not here, but in machine/profile.h.  */
+#undef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(FILE, LABELNO)  \
+  fputs (flag_pic ? "\tcall __mcount@PLT\n": "\tcall __mcount\n", FILE);
+
+/* Assembler format: exception region output.  */
+
+/* our configuration still doesn't handle dwarf2 correctly */
+#define DWARF2_UNWIND_INFO 0
+
+/* Assembler format: alignment output.  */
+
+/* Note that we pick up ASM_OUTPUT_MAX_SKIP_ALIGN from i386/gas.h */
+
+/* Note that we pick up ASM_OUTPUT_MI_THUNK from unix.h.  */
+
+#undef LINK_SPEC
+#define LINK_SPEC \
+  "%{!shared:%{!nostdlib:%{!r*:%{!e*:-e __start}}}} \
+   %{shared:-shared} %{R*} \
+   %{static:-Bstatic} \
+   %{!static:-Bdynamic} \
+   %{assert*} \
+   %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.so}"
+
+#define OBSD_HAS_CORRECT_SPECS
+
+/* pick up defines for mprotect (used in TRANSFER_FROM_TRANPOLINE) */
+#include <sys/types.h>
+#include <sys/mman.h>
diff --git a/gcc/config/ia64/change-symver.c b/gcc/config/ia64/change-symver.c
new file mode 100644
index 00000000..fc195950
--- /dev/null
+++ b/gcc/config/ia64/change-symver.c
@@ -0,0 +1,211 @@
+#define _GNU_SOURCE 1
+#define _FILE_OFFSET_BITS 64
+#include <endian.h>
+#include <errno.h>
+#include <error.h>
+#include <fcntl.h>
+#include <fnmatch.h>
+#include <gelf.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+int
+compute_veridx (const char *name, Elf *elf, Elf_Data *verd, GElf_Shdr *verd_shdr)
+{
+  if (strcmp (name, "_GLOBAL_") == 0)
+    return 1;
+
+  int cnt;
+  size_t offset = 0;
+  for (cnt = verd_shdr->sh_info; --cnt >= 0; )
+    {
+      GElf_Verdef defmem;
+      GElf_Verdef *def;
+      GElf_Verdaux auxmem;
+      GElf_Verdaux *aux;
+      unsigned int auxoffset;
+
+      /* Get the data at the next offset.  */
+      def = gelf_getverdef (verd, offset, &defmem);
+      if (def == NULL)
+	break;
+
+      auxoffset = offset + def->vd_aux;
+      aux = gelf_getverdaux (verd, auxoffset, &auxmem);
+      if (aux == NULL)
+	break;
+
+      if (strcmp (name, elf_strptr (elf, verd_shdr->sh_link,
+		  aux->vda_name)) == 0)
+	return def->vd_ndx;
+
+      /* Find the next offset.  */
+      offset += def->vd_next;
+    }
+
+  return -1;
+}
+
+int
+main (int argc, char **argv)
+{
+  if (argc < 4)
+    error (1, 0, "Usage: change_symver library from_symver to_symver symbol...\nExample: change_symver libfoo.so FOO_1.0 *global* bar baz");
+
+  const char *fname = argv[1];
+
+  /* Open the file.  */
+  int fd;
+  fd = open (fname, O_RDWR);
+  if (fd == -1)
+    error (1, errno, fname);
+
+  elf_version (EV_CURRENT);
+
+  /* Now get the ELF descriptor.  */
+  Elf *elf = elf_begin (fd, ELF_C_READ_MMAP, NULL);
+  if (elf == NULL || elf_kind (elf) != ELF_K_ELF)
+    error (1, 0, "Couldn't open %s: %s", fname, elf_errmsg (-1));
+
+  size_t shstrndx;
+  /* Get the section header string table index.  */
+  if (elf_getshstrndx (elf, &shstrndx) < 0)
+    error (1, 0, "cannot get shstrndx from %s", fname);
+
+  GElf_Ehdr ehdr_mem;
+  GElf_Ehdr *ehdr;
+
+  /* We need the ELF header in a few places.  */
+  ehdr = gelf_getehdr (elf, &ehdr_mem);
+  if (ehdr == NULL)
+    error (1, 0, "couldn't get ELF headers %s: %s", fname, elf_errmsg (-1));
+
+  Elf_Scn *scn = NULL;
+  GElf_Shdr shdr_mem, verd_shdr, ver_shdr, dynsym_shdr;
+  Elf_Data *ver = NULL, *verd = NULL, *dynsym = NULL;
+
+  while ((scn = elf_nextscn (elf, scn)) != NULL)
+    {
+      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
+
+      if (shdr == NULL)
+	error (1, 0, "couldn't get shdr from %s", fname);
+
+      if ((shdr->sh_flags & SHF_ALLOC) != 0)
+	{
+	  const char *name = elf_strptr (elf, shstrndx, shdr->sh_name);
+	  Elf_Data **p;
+
+	  if (strcmp (name, ".gnu.version") == 0)
+	    {
+	      p = &ver;
+	      ver_shdr = *shdr;
+	    }
+	  else if (strcmp (name, ".gnu.version_d") == 0)
+	    {
+	      p = &verd;
+	      verd_shdr = *shdr;
+	    }
+	  else if (strcmp (name, ".dynsym") == 0)
+	    {
+	      p = &dynsym;
+	      dynsym_shdr = *shdr;
+	    }
+	  else
+	    continue;
+
+	  if (*p != NULL)
+	    error (1, 0, "Two %s sections in %s", name, fname);
+	  *p = elf_getdata (scn, NULL);
+	  if (*p == NULL || elf_getdata (scn, *p) != NULL)
+	    error (1, 0, "No data or non-contiguous data in %s section in %s",
+		   name, fname);
+	}
+    }
+
+  if (ver == NULL || verd == NULL || dynsym == NULL)
+    error (1, 0, "Couldn't find one of the needed sections in %s", fname);
+
+  int from_idx = compute_veridx (argv[2], elf, verd, &verd_shdr);
+  if (from_idx == -1)
+    error (1, 0, "Could not find symbol version %s in %s", argv[2], fname);
+
+  int to_idx = compute_veridx (argv[3], elf, verd, &verd_shdr);
+  if (to_idx == -1)
+    error (1, 0, "Could not find symbol version %s in %s", argv[3], fname);
+
+  if (dynsym_shdr.sh_entsize != gelf_fsize (elf, ELF_T_SYM, 1, ehdr->e_version)
+      || dynsym_shdr.sh_size % dynsym_shdr.sh_entsize
+      || ver_shdr.sh_entsize != 2
+      || (ver_shdr.sh_size & 1)
+      || dynsym_shdr.sh_size / dynsym_shdr.sh_entsize != ver_shdr.sh_size / 2)
+    error (1, 0, "Unexpected sh_size or sh_entsize in %s", fname);
+
+  size_t nentries = ver_shdr.sh_size / 2;
+  size_t cnt;
+  GElf_Versym array[nentries];
+  for (cnt = 0; cnt < nentries; ++cnt)
+    {
+      GElf_Versym vsymmem;
+      GElf_Versym *vsym;
+
+      vsym = gelf_getversym (ver, cnt, &vsymmem);
+      if (vsym == NULL)
+	error (1, 0, "gelt_getversym failed in %s: %s", fname, elf_errmsg (-1));
+
+      array[cnt] = *vsym;
+      if (*vsym != from_idx)
+	continue;
+
+      GElf_Sym sym_mem;
+      GElf_Sym *sym;
+      sym = gelf_getsym (dynsym, cnt, &sym_mem);
+      if (sym == NULL)
+	error (1, 0, "gelt_getsym failed in %s: %s", fname, elf_errmsg (-1));
+
+      const char *name = elf_strptr (elf, dynsym_shdr.sh_link, sym->st_name);
+
+      int argn;
+      for (argn = 4; argn < argc; ++argn)
+	if (fnmatch (argv[argn], name, 0) == 0)
+	  {
+	    array[cnt] = to_idx;
+	    break;
+	  }
+    }
+
+  if (sizeof (array[0]) != 2)
+    abort ();
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+  if (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)
+    ;
+  else if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)
+#elif __BYTE_ORDER == __BIG_ENDIAN
+  if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)
+    ;
+  else if (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)
+#else
+# error Unsupported endianity
+#endif
+    {
+      for (cnt = 0; cnt < nentries; ++cnt)
+	array[cnt] = ((array[cnt] & 0xff) << 8) | ((array[cnt] & 0xff00) >> 8);
+    }
+  else
+    error (1, 0, "Unknown EI_DATA %d in %s", ehdr->e_ident[EI_DATA], fname);
+
+  if (elf_end (elf) != 0)
+    error (1, 0, "couldn't close %s: %s", fname, elf_errmsg (-1));
+
+  if (lseek (fd, ver_shdr.sh_offset, SEEK_SET) != (off_t) ver_shdr.sh_offset)
+    error (1, 0, "failed to seek to %zd in %s", (size_t) ver_shdr.sh_offset,
+	   fname);
+
+  if (write (fd, array, 2 * nentries) != (ssize_t) (2 * nentries))
+    error (1, 0, "failed to write .gnu.version section into %s", fname);
+
+  close (fd);
+  return 0;
+}
diff --git a/gcc/config/ia64/crtbegin.asm b/gcc/config/ia64/crtbegin.asm
index 494def7f..1878b193 100644
--- a/gcc/config/ia64/crtbegin.asm
+++ b/gcc/config/ia64/crtbegin.asm
@@ -246,3 +246,7 @@ __do_jv_register_classes:
 .weak __cxa_finalize
 #endif
 .weak _Jv_RegisterClasses
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crtend.asm b/gcc/config/ia64/crtend.asm
index 8984d88f..b6cdd7bd 100644
--- a/gcc/config/ia64/crtend.asm
+++ b/gcc/config/ia64/crtend.asm
@@ -113,3 +113,7 @@ __do_global_ctors_aux:
 
 	br.ret.sptk.many rp
 	.endp __do_global_ctors_aux
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crti.asm b/gcc/config/ia64/crti.asm
index 4b48e3d4..b0f1ca77 100644
--- a/gcc/config/ia64/crti.asm
+++ b/gcc/config/ia64/crti.asm
@@ -64,3 +64,7 @@ _fini:
 	.body
 
 # end of crti.asm
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/crtn.asm b/gcc/config/ia64/crtn.asm
index 48a9a03f..9edda910 100644
--- a/gcc/config/ia64/crtn.asm
+++ b/gcc/config/ia64/crtn.asm
@@ -54,3 +54,7 @@
 	br.ret.sptk.many b0
 
 # end of crtn.asm
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/ia64.h b/gcc/config/ia64/ia64.h
index 9f7dd055..886ff72b 100644
--- a/gcc/config/ia64/ia64.h
+++ b/gcc/config/ia64/ia64.h
@@ -173,6 +173,8 @@ extern int ia64_tls_size;
 
 #define TARGET_SWITCHES							\
 {									\
+  { "64",		0,						\
+      N_("Generate 64-bit code") },					\
   { "big-endian",	MASK_BIG_ENDIAN,				\
       N_("Generate big endian code") },					\
   { "little-endian",	-MASK_BIG_ENDIAN,				\
diff --git a/gcc/config/ia64/lib1funcs.asm b/gcc/config/ia64/lib1funcs.asm
index e3d348ba..fdd66b96 100644
--- a/gcc/config/ia64/lib1funcs.asm
+++ b/gcc/config/ia64/lib1funcs.asm
@@ -741,3 +741,7 @@ __floattitf:
 	.endp __floattitf
 
 #endif
+
+#ifdef __linux__
+.section .note.GNU-stack; .previous
+#endif
diff --git a/gcc/config/ia64/libgcc-ia64-no-libunwind.ver b/gcc/config/ia64/libgcc-ia64-no-libunwind.ver
new file mode 100644
index 00000000..750b08f6
--- /dev/null
+++ b/gcc/config/ia64/libgcc-ia64-no-libunwind.ver
@@ -0,0 +1,17 @@
+GCC_3.4.2 {
+  _Unwind_GetGR
+  _Unwind_RaiseException
+  _Unwind_GetRegionStart
+  _Unwind_SetIP
+  _Unwind_GetIP
+  _Unwind_GetLanguageSpecificData
+  _Unwind_Resume
+  _Unwind_DeleteException
+  _Unwind_SetGR
+  _Unwind_ForcedUnwind
+  _Unwind_Backtrace
+  _Unwind_FindEnclosingFunction
+  _Unwind_GetCFA
+  _Unwind_Resume_or_Rethrow
+  _Unwind_GetBSP
+}
diff --git a/gcc/config/ia64/linux.h b/gcc/config/ia64/linux.h
index 5c73b0c2..0e6190d5 100644
--- a/gcc/config/ia64/linux.h
+++ b/gcc/config/ia64/linux.h
@@ -5,6 +5,8 @@
 
 #define TARGET_VERSION fprintf (stderr, " (IA-64) Linux");
 
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
 /* This is for -profile to use -lc_p instead of -lc.  */
 #undef CC1_SPEC
 #define CC1_SPEC "%{profile:-p} %{G*}"
@@ -55,6 +57,8 @@ do {						\
 #undef LINK_EH_SPEC
 #define LINK_EH_SPEC ""
 
+#define MULTILIB_DEFAULTS { "m64" }
+
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
@@ -77,7 +81,7 @@ do {						\
       struct sigframe {							\
 	char scratch[16];						\
 	unsigned long sig_number;					\
-	struct siginfo *info;						\
+	siginfo_t *info;						\
 	struct sigcontext *sc;						\
       } *frame_ = (struct sigframe *)(CONTEXT)->psp;			\
       struct sigcontext *sc_ = frame_->sc;				\
@@ -150,7 +154,7 @@ do {						\
       struct sigframe {							\
 	char scratch[16];						\
 	unsigned long sig_number;					\
-	struct siginfo *info;						\
+	siginfo_t *info;						\
 	struct sigcontext *sc;						\
       } *frame_ = (struct sigframe *)(CONTEXT)->psp;			\
       struct sigcontext *sc_ = frame_->sc;				\
diff --git a/gcc/config/ia64/mkmap-symver-multi.awk b/gcc/config/ia64/mkmap-symver-multi.awk
new file mode 100644
index 00000000..5ee18e07
--- /dev/null
+++ b/gcc/config/ia64/mkmap-symver-multi.awk
@@ -0,0 +1,133 @@
+# Generate an ELF symbol version map a-la Solaris and GNU ld.
+#	Contributed by Richard Henderson <rth@cygnus.com>
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2, or (at your option) any later
+# version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+# License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING.  If not, write to the Free
+# Software Foundation, 59 Temple Place - Suite 330, Boston MA
+# 02111-1307, USA.
+
+BEGIN {
+  state = "nm";
+  sawsymbol = 0;
+}
+
+# Remove comment and blank lines.
+/^ *#/ || /^ *$/ {
+  next;
+}
+
+# We begin with nm input.  Collect the set of symbols that are present
+# so that we can not emit them into the final version script -- Solaris
+# complains at us if we do.
+
+state == "nm" && /^%%/ {
+  state = "ver";
+  next;
+}
+
+state == "nm" && ($1 == "U" || $2 == "U") {
+  next;
+}
+
+state == "nm" && NF == 3 {
+  if ($3 ~ /^[^@]*@GCC_[0-9.]*$/) {
+    def[$3] = 1
+    tl=$3
+    sub(/^.*@/,"",tl)
+    ver[$3] = tl
+  } else {
+    sub(/@@?GCC_[0-9.]*$/,"",$3)
+    def[$3] = 1;
+  }
+  sawsymbol = 1;
+  next;
+}
+
+state == "nm" {
+  next;
+}
+
+# Now we process a simplified variant of the Solaris symbol version
+# script.  We have one symbol per line, no semicolons, simple markers
+# for beginning and ending each section, and %inherit markers for
+# describing version inheritence.  A symbol may appear in more than
+# one symbol version, and the last seen takes effect.
+
+NF == 3 && $1 == "%inherit" {
+  inherit[$2] = $3;
+  next;
+}
+
+NF == 2 && $2 == "{" {
+  libs[$1] = 1;
+  thislib = $1;
+  next;
+}
+
+$1 == "}" {
+  thislib = "";
+  next;
+}
+
+{
+  ver[$1] = thislib;
+  next;
+}
+
+END {
+  if (!sawsymbol)
+    {
+      print "No symbols seen -- broken or mis-installed nm?" | "cat 1>&2";
+      exit 1;
+    }
+  for (l in libs)
+    output(l);
+}
+
+function output(lib) {
+  if (done[lib])
+    return;
+  done[lib] = 1;
+  if (inherit[lib])
+    output(inherit[lib]);
+
+  empty=1
+  for (sym in ver)
+    if ((ver[sym] == lib) && (sym in def))
+      {
+	if (empty)
+	  {
+	    printf("%s {\n", lib);
+	    printf("  global:\n");
+	    empty = 0;
+	  }
+	symp = sym;
+	sub(/@GCC_[0-9.]*$/,"",symp);
+	printf("\t%s;\n", symp);
+	if (dotsyms)
+	  printf("\t.%s;\n", symp);
+      }
+
+  if (empty)
+    {
+      for (l in libs)
+	if (inherit[l] == lib)
+	  inherit[l] = inherit[lib];
+    }
+  else if (inherit[lib])
+    printf("} %s;\n", inherit[lib]);
+  else
+    printf ("\n  local:\n\t*;\n};\n");
+}
diff --git a/gcc/config/ia64/t-glibc b/gcc/config/ia64/t-glibc
index df4fe9c4..b224282f 100644
--- a/gcc/config/ia64/t-glibc
+++ b/gcc/config/ia64/t-glibc
@@ -1,3 +1,8 @@
 # Use system libunwind library on IA-64 GLIBC based system.
+
+MULTILIB_OPTIONS = m64/m32
+MULTILIB_DIRNAMES = 64 32
+MULTILIB_EXCEPTIONS = m32
+MULTILIB_OSDIRNAMES = ../lib64 ../lib
 LIB2ADDEH = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c \
   $(srcdir)/unwind-compat.c
diff --git a/gcc/config/ia64/t-glibc-no-libunwind b/gcc/config/ia64/t-glibc-no-libunwind
new file mode 100644
index 00000000..c9658776
--- /dev/null
+++ b/gcc/config/ia64/t-glibc-no-libunwind
@@ -0,0 +1,32 @@
+# Don't use system libunwind library on IA-64 GLIBC based system,
+# but make _Unwind_* symbols unversioned, so that created programs
+# are usable even when libgcc_s uses libunwind.
+LIB2ADDEH += $(srcdir)/config/ia64/fde-glibc.c
+LIB2ADDEH += $(srcdir)/config/ia64/unwind-shared-ia64.c
+LIB2ADDEHSTATIC = $(srcdir)/config/ia64/unwind-ia64.c $(srcdir)/unwind-sjlj.c \
+  $(srcdir)/unwind-c.c $(srcdir)/gthr-gnat.c $(srcdir)/config/ia64/fde-glibc.c
+LIB2ADDEHSHARED = $(srcdir)/config/ia64/unwind-shared-ia64.c $(srcdir)/unwind-sjlj.c \
+  $(srcdir)/unwind-c.c $(srcdir)/gthr-gnat.c $(srcdir)/config/ia64/fde-glibc.c
+SHLIB_MAPFILES += $(srcdir)/config/ia64/libgcc-ia64-no-libunwind.ver
+SHLIB_MKMAP = $(srcdir)/config/ia64/mkmap-symver-multi.awk
+
+SHLIB_LINK = $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) -shared -nodefaultlibs \
+	-Wl,--soname=$(SHLIB_SONAME) \
+	-Wl,--version-script=$(SHLIB_MAP) \
+	-o $(SHLIB_NAME).tmp @multilib_flags@ $(SHLIB_OBJS) -lc && \
+	rm -f $(SHLIB_SOLINK) && \
+	if [ -f $(SHLIB_NAME) ]; then \
+	  mv -f $(SHLIB_NAME) $(SHLIB_NAME).`basename $(STAGE_PREFIX)`; \
+	else true; fi && \
+	gcc -O2 -o $(SHLIB_NAME).tweak $(srcdir)/config/ia64/change-symver.c -lelf && \
+	./$(SHLIB_NAME).tweak $(SHLIB_NAME).tmp GCC_3.4.2 _GLOBAL_ \
+	_Unwind_GetGR _Unwind_RaiseException _Unwind_GetRegionStart _Unwind_SetIP \
+	_Unwind_GetIP _Unwind_GetLanguageSpecificData _Unwind_Resume \
+	_Unwind_DeleteException _Unwind_SetGR _Unwind_ForcedUnwind \
+	_Unwind_Backtrace _Unwind_FindEnclosingFunction _Unwind_GetCFA \
+	_Unwind_Resume_or_Rethrow _Unwind_GetBSP && \
+	rm -f $(SHLIB_NAME).tweak && \
+	mv $(SHLIB_NAME).tmp $(SHLIB_NAME) && \
+	$(LN_S) $(SHLIB_NAME) $(SHLIB_SOLINK)
+
+TARGET_LIBGCC2_CFLAGS += -DUSE_SYMVER_GLOBAL
diff --git a/gcc/config/ia64/unwind-ia64.c b/gcc/config/ia64/unwind-ia64.c
index a49652e9..dd7bd612 100644
--- a/gcc/config/ia64/unwind-ia64.c
+++ b/gcc/config/ia64/unwind-ia64.c
@@ -51,6 +51,51 @@
 #define UNW_FLAG_UHANDLER(x)	((x) & 0x0000000200000000L)
 #define UNW_LENGTH(x)		((x) & 0x00000000ffffffffL)
 
+#if defined (USE_SYMVER_GLOBAL) && defined (SHARED)
+extern _Unwind_Reason_Code __symverglobal_Unwind_Backtrace
+  (_Unwind_Trace_Fn, void *);
+extern void __symverglobal_Unwind_DeleteException
+  (struct _Unwind_Exception *);
+extern void * __symverglobal_Unwind_FindEnclosingFunction (void *);
+extern _Unwind_Reason_Code __symverglobal_Unwind_ForcedUnwind
+  (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);
+extern _Unwind_Word __symverglobal_Unwind_GetCFA
+  (struct _Unwind_Context *);
+extern _Unwind_Word __symverglobal_Unwind_GetBSP
+  (struct _Unwind_Context *);
+extern _Unwind_Word __symverglobal_Unwind_GetGR
+  (struct _Unwind_Context *, int );
+extern _Unwind_Ptr __symverglobal_Unwind_GetIP (struct _Unwind_Context *);
+extern void *__symverglobal_Unwind_GetLanguageSpecificData
+  (struct _Unwind_Context *);
+extern _Unwind_Ptr __symverglobal_Unwind_GetRegionStart
+  (struct _Unwind_Context *);
+extern _Unwind_Reason_Code __symverglobal_Unwind_RaiseException
+  (struct _Unwind_Exception *);
+extern void __symverglobal_Unwind_Resume (struct _Unwind_Exception *);
+extern _Unwind_Reason_Code __symverglobal_Unwind_Resume_or_Rethrow
+   (struct _Unwind_Exception *);
+extern void __symverglobal_Unwind_SetGR
+  (struct _Unwind_Context *, int, _Unwind_Word);
+extern void __symverglobal_Unwind_SetIP
+  (struct _Unwind_Context *, _Unwind_Ptr);
+#define _Unwind_Backtrace __symverglobal_Unwind_Backtrace
+#define _Unwind_DeleteException __symverglobal_Unwind_DeleteException
+#define _Unwind_FindEnclosingFunction __symverglobal_Unwind_FindEnclosingFunction
+#define _Unwind_ForcedUnwind __symverglobal_Unwind_ForcedUnwind
+#define _Unwind_GetBSP __symverglobal_Unwind_GetBSP
+#define _Unwind_GetCFA __symverglobal_Unwind_GetCFA
+#define _Unwind_GetGR __symverglobal_Unwind_GetGR
+#define _Unwind_GetIP __symverglobal_Unwind_GetIP
+#define _Unwind_GetLanguageSpecificData __symverglobal_Unwind_GetLanguageSpecificData
+#define _Unwind_GetRegionStart __symverglobal_Unwind_GetRegionStart
+#define _Unwind_RaiseException __symverglobal_Unwind_RaiseException
+#define _Unwind_Resume __symverglobal_Unwind_Resume
+#define _Unwind_Resume_or_Rethrow __symverglobal_Unwind_Resume_or_Rethrow
+#define _Unwind_SetGR __symverglobal_Unwind_SetGR
+#define _Unwind_SetIP __symverglobal_Unwind_SetIP
+#endif
+
 enum unw_application_register
 {
   UNW_AR_BSP,
@@ -2404,4 +2449,44 @@ alias (_Unwind_SetGR);
 alias (_Unwind_SetIP);
 #endif
 
+#if defined (USE_SYMVER_GLOBAL) && defined (SHARED)
+#undef alias
+#define symverglobal(name, version) \
+__typeof (__symverglobal##name) __symverlocal##name		\
+  __attribute__ ((alias ("__symverglobal" #name)));		\
+__asm__ (".symver __symverglobal" #name"," #name "@@GCC_3.4.2");\
+__asm__ (".symver __symverlocal" #name"," #name "@" #version)
+
+#undef _Unwind_Backtrace
+#undef _Unwind_DeleteException
+#undef _Unwind_FindEnclosingFunction
+#undef _Unwind_ForcedUnwind
+#undef _Unwind_GetBSP
+#undef _Unwind_GetCFA
+#undef _Unwind_GetGR
+#undef _Unwind_GetIP
+#undef _Unwind_GetLanguageSpecificData
+#undef _Unwind_GetRegionStart
+#undef _Unwind_RaiseException
+#undef _Unwind_Resume
+#undef _Unwind_Resume_or_Rethrow
+#undef _Unwind_SetGR
+#undef _Unwind_SetIP
+symverglobal (_Unwind_Backtrace, GCC_3.3);
+symverglobal (_Unwind_DeleteException, GCC_3.0);
+symverglobal (_Unwind_FindEnclosingFunction, GCC_3.3);
+symverglobal (_Unwind_ForcedUnwind, GCC_3.0);
+symverglobal (_Unwind_GetBSP, GCC_3.3.2);
+symverglobal (_Unwind_GetCFA, GCC_3.3);
+symverglobal (_Unwind_GetGR, GCC_3.0);
+symverglobal (_Unwind_GetIP, GCC_3.0);
+symverglobal (_Unwind_GetLanguageSpecificData, GCC_3.0);
+symverglobal (_Unwind_GetRegionStart, GCC_3.0);
+symverglobal (_Unwind_RaiseException, GCC_3.0);
+symverglobal (_Unwind_Resume, GCC_3.0);
+symverglobal (_Unwind_Resume_or_Rethrow, GCC_3.3);
+symverglobal (_Unwind_SetGR, GCC_3.0);
+symverglobal (_Unwind_SetIP, GCC_3.0);
+#endif
+
 #endif
diff --git a/gcc/config/ia64/unwind-shared-ia64.c b/gcc/config/ia64/unwind-shared-ia64.c
new file mode 100644
index 00000000..b1d9fd15
--- /dev/null
+++ b/gcc/config/ia64/unwind-shared-ia64.c
@@ -0,0 +1,2 @@
+#define SHARED
+#include "unwind-ia64.c"
diff --git a/gcc/config/m68k/m68k.md b/gcc/config/m68k/m68k.md
index 68ea9330..a65618c6 100644
--- a/gcc/config/m68k/m68k.md
+++ b/gcc/config/m68k/m68k.md
@@ -1454,11 +1454,20 @@
   ""
 {
   CC_STATUS_INIT;
-  operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);
-  if (TARGET_68020 || TARGET_COLDFIRE)
-    return "move%.b %1,%2\;extb%.l %2\;smi %0\;extb%.l %0";
+  if (ADDRESS_REG_P(operands[1]))
+    {
+      if (TARGET_68020 || TARGET_COLDFIRE)
+        return "move%.w %1,%R0\;extb%.l %R0\;smi %0\;extb%.l %0";
+      else
+        return "move%.w %1,%R0\;ext%.w %R0\;ext%.l %R0\;move%.l %R0,%0\;smi %0";
+    }
   else
-    return "move%.b %1,%2\;ext%.w %0\;ext%.l %2\;move%.l %2,%0\;smi %0";
+    {
+      if (TARGET_68020 || TARGET_COLDFIRE)
+        return "move%.b %1,%R0\;extb%.l %R0\;smi %0\;extb%.l %0";
+      else
+        return "move%.b %1,%R0\;ext%.w %R0\;ext%.l %R0\;move%.l %R0,%0\;smi %0";
+    }
 })
 
 (define_insn "extendhidi2"
@@ -4834,8 +4843,8 @@
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
 	(sign_extract:SI (match_operand:QI 1 "memory_operand" "o")
-			 (match_operand:SI 2 "general_operand" "di")
-			 (match_operand:SI 3 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")
+			 (match_operand:SI 3 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
   "bfexts %1{%b3:%b2},%0")
 
@@ -4850,8 +4859,8 @@
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d,d")
 	(zero_extract:SI (match_operand:QI 1 "memory_operand" "o,d")
-			 (match_operand:SI 2 "general_operand" "di,di")
-			 (match_operand:SI 3 "general_operand" "di,di")))]
+			 (match_operand:SI 2 "general_operand" "dn,dn")
+			 (match_operand:SI 3 "general_operand" "dn,dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (GET_CODE (operands[2]) == CONST_INT)
@@ -4868,8 +4877,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
         (xor:SI (zero_extract:SI (match_dup 0) (match_dup 1) (match_dup 2))
 		(match_operand 3 "const_int_operand" "n")))]
   "TARGET_68020 && TARGET_BITFIELD
@@ -4883,8 +4892,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int 0))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4894,8 +4903,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int -1))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4913,8 +4922,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(match_operand:SI 3 "register_operand" "d"))]
   "TARGET_68020 && TARGET_BITFIELD"
   "bfins %3,%0{%b2:%b1}")
@@ -4925,16 +4934,16 @@
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
 	(sign_extract:SI (match_operand:SI 1 "register_operand" "d")
-			 (match_operand:SI 2 "general_operand" "di")
-			 (match_operand:SI 3 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")
+			 (match_operand:SI 3 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
   "bfexts %1{%b3:%b2},%0")
 
 (define_insn ""
   [(set (match_operand:SI 0 "nonimmediate_operand" "=d")
 	(zero_extract:SI (match_operand:SI 1 "register_operand" "d")
-			 (match_operand:SI 2 "general_operand" "di")
-			 (match_operand:SI 3 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")
+			 (match_operand:SI 3 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (GET_CODE (operands[2]) == CONST_INT)
@@ -4951,8 +4960,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+d")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int 0))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4962,8 +4971,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+d")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int -1))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4973,8 +4982,8 @@
 
 (define_insn ""
   [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+d")
-			 (match_operand:SI 1 "general_operand" "di")
-			 (match_operand:SI 2 "general_operand" "di"))
+			 (match_operand:SI 1 "general_operand" "dn")
+			 (match_operand:SI 2 "general_operand" "dn"))
 	(match_operand:SI 3 "register_operand" "d"))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
@@ -4996,7 +5005,7 @@
   [(set (cc0)
 	(zero_extract:SI (match_operand:QI 0 "memory_operand" "o")
 			 (match_operand:SI 1 "const_int_operand" "n")
-			 (match_operand:SI 2 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (operands[1] == const1_rtx
@@ -5021,7 +5030,7 @@
   [(set (cc0)
 	(zero_extract:SI (match_operand:SI 0 "register_operand" "d")
 			 (match_operand:SI 1 "const_int_operand" "n")
-			 (match_operand:SI 2 "general_operand" "di")))]
+			 (match_operand:SI 2 "general_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
 {
   if (operands[1] == const1_rtx
diff --git a/gcc/config/mips/linux.h b/gcc/config/mips/linux.h
index eee298f8..ec48292b 100644
--- a/gcc/config/mips/linux.h
+++ b/gcc/config/mips/linux.h
@@ -228,7 +228,7 @@ typedef struct _sig_ucontext {
       {                                                              \
         struct rt_sigframe {                                         \
           u_int32_t  trampoline[2];                                \
-          struct siginfo info;                                       \
+          siginfo_t info;                                       \
           _sig_ucontext_t uc;                                        \
         } *rt_ = (CONTEXT)->ra;                                      \
         sc_ = &rt_->uc.uc_mcontext;                                  \
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
index 0aa24f6a..b907b483 100644
--- a/gcc/config/mips/mips.c
+++ b/gcc/config/mips/mips.c
@@ -707,6 +707,7 @@ const struct mips_cpu_info mips_cpu_info_table[] = {
 
   /* MIPS IV */
   { "r8000", PROCESSOR_R8000, 4 },
+  { "r10000", PROCESSOR_R10000, 4 },
   { "vr5000", PROCESSOR_R5000, 4 },
   { "vr5400", PROCESSOR_R5400, 4 },
   { "vr5500", PROCESSOR_R5500, 4 },
@@ -9406,6 +9407,9 @@ mips_issue_rate (void)
 {
   switch (mips_tune)
     {
+    case PROCESSOR_R10000:
+      return 4;
+
     case PROCESSOR_R5400:
     case PROCESSOR_R5500:
     case PROCESSOR_R7000:
diff --git a/gcc/config/mips/mips.h b/gcc/config/mips/mips.h
index d087ed25..87562cba 100644
--- a/gcc/config/mips/mips.h
+++ b/gcc/config/mips/mips.h
@@ -66,6 +66,7 @@ enum processor_type {
   PROCESSOR_R7000,
   PROCESSOR_R8000,
   PROCESSOR_R9000,
+  PROCESSOR_R10000,
   PROCESSOR_SB1,
   PROCESSOR_SR71000
 };
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
index 50545423..32b3ba75 100644
--- a/gcc/config/mips/mips.md
+++ b/gcc/config/mips/mips.md
@@ -103,6 +103,7 @@
 ;; arith	integer arithmetic instruction
 ;; darith	double precision integer arithmetic instructions
 ;; const	load constant
+;; shift        integer shift
 ;; imul		integer multiply
 ;; imadd	integer multiply-add
 ;; idiv		integer divide
@@ -120,7 +121,7 @@
 ;; multi	multiword sequence (or user asm statements)
 ;; nop		no operation
 (define_attr "type"
-  "unknown,branch,jump,call,load,store,prefetch,prefetchx,move,condmove,xfer,hilo,const,arith,darith,imul,imadd,idiv,icmp,fadd,fmul,fmadd,fdiv,fabs,fneg,fcmp,fcvt,fsqrt,frsqrt,multi,nop"
+  "unknown,branch,jump,call,load,store,prefetch,prefetchx,move,condmove,xfer,hilo,const,arith,darith,shift,imul,imadd,idiv,icmp,fadd,fmul,fmadd,fdiv,fabs,fneg,fcmp,fcvt,fsqrt,frsqrt,multi,nop"
   (cond [(eq_attr "jal" "!unset") (const_string "call")
 	 (eq_attr "got" "load") (const_string "load")]
 	(const_string "unknown")))
@@ -214,7 +215,7 @@
 ;; Attribute describing the processor.  This attribute must match exactly
 ;; with the processor_type enumeration in mips.h.
 (define_attr "cpu"
-  "default,4kc,5kc,20kc,m4k,r3000,r3900,r6000,r4000,r4100,r4111,r4120,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,sb1,sr71000"
+  "default,4kc,5kc,20kc,m4k,r3000,r3900,r6000,r4000,r4100,r4111,r4120,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,r10000,sb1,sr71000"
   (const (symbol_ref "mips_tune")))
 
 ;; The type of hardware hazard associated with this instruction.
@@ -306,12 +307,12 @@
 
 (define_function_unit "memory" 1 0
   (and (eq_attr "type" "load")
-       (eq_attr "cpu" "!r3000,r3900,r4600,r4650,r4100,r4120,r4300,r5000"))
+       (eq_attr "cpu" "!r3000,r3900,r4600,r4650,r4100,r4120,r4300,r5000,r10000"))
   3 0)
 
 (define_function_unit "memory" 1 0
   (and (eq_attr "type" "load")
-       (eq_attr "cpu" "r3000,r3900,r4600,r4650,r4100,r4120,r4300,r5000"))
+       (eq_attr "cpu" "r3000,r3900,r4600,r4650,r4100,r4120,r4300,r5000,r10000"))
   2 0)
 
 (define_function_unit "memory"   1 0 (eq_attr "type" "store") 1 0)
@@ -324,7 +325,7 @@
 
 (define_function_unit "imuldiv"  1 0
   (and (eq_attr "type" "imul,imadd")
-       (eq_attr "cpu" "!r3000,r3900,r4000,r4600,r4650,r4100,r4120,r4300,r5000"))
+       (eq_attr "cpu" "!r3000,r3900,r4000,r4600,r4650,r4100,r4120,r4300,r5000,r10000"))
   17 17)
 
 ;; On them mips16, we want to stronly discourage a mult from appearing
@@ -376,7 +377,7 @@
 
 (define_function_unit "imuldiv"  1 0
   (and (eq_attr "type" "idiv")
-       (eq_attr "cpu" "!r3000,r3900,r4000,r4600,r4650,r4100,r4120,r4300,r5000"))
+       (eq_attr "cpu" "!r3000,r3900,r4000,r4600,r4650,r4100,r4120,r4300,r5000,r10000"))
   38 38)
 
 (define_function_unit "imuldiv"  1 0
@@ -425,6 +426,40 @@
        (and (eq_attr "mode" "DI") (eq_attr "cpu" "r5000")))
   68 68)
 
+;; R10000 has 2 integer ALUs
+(define_function_unit "alu" 2 0
+  (and (eq_attr "type" "arith,darith,shift")
+       (eq_attr "cpu" "r10000"))
+  1 0)
+
+;; Only ALU1 can do shifts.  We model shifts as an additional unit
+(define_function_unit "alu1" 1 0
+  (and (eq_attr "type" "shift")
+       (eq_attr "cpu" "r10000"))
+  1 0)
+
+;; only ALU2 does multiplications and divisions
+(define_function_unit "alu2"  1 0
+  (and (eq_attr "type" "imul")
+       (and (eq_attr "mode" "SI") (eq_attr "cpu" "r10000")))
+  6 6)
+
+(define_function_unit "alu2"  1 0
+  (and (eq_attr "type" "imul")
+       (and (eq_attr "mode" "DI") (eq_attr "cpu" "r10000")))
+  10 10)
+
+(define_function_unit "alu2"  1 0
+  (and (eq_attr "type" "idiv")
+       (and (eq_attr "mode" "SI") (eq_attr "cpu" "r10000")))
+  35 35)
+
+(define_function_unit "alu2"  1 0
+  (and (eq_attr "type" "idiv")
+       (and (eq_attr "mode" "DI") (eq_attr "cpu" "r10000")))
+  67 67)
+
+
 ;; The R4300 does *NOT* have a separate Floating Point Unit, instead
 ;; the FP hardware is part of the normal ALU circuitry.  This means FP
 ;; instructions affect the pipe-line, and no functional unit
@@ -433,11 +468,11 @@
 ;; instructions to be processed in the "imuldiv" unit.
 
 (define_function_unit "adder" 1 1
-  (and (eq_attr "type" "fcmp") (eq_attr "cpu" "!r3000,r3900,r6000,r4300,r5000"))
+  (and (eq_attr "type" "fcmp") (eq_attr "cpu" "!r3000,r3900,r6000,r4300,r5000,r10000"))
   3 0)
 
 (define_function_unit "adder" 1 1
-  (and (eq_attr "type" "fcmp") (eq_attr "cpu" "r3000,r3900,r6000"))
+  (and (eq_attr "type" "fcmp") (eq_attr "cpu" "r3000,r3900,r6000,r10000"))
   2 0)
 
 (define_function_unit "adder" 1 1
@@ -445,7 +480,7 @@
   1 0)
 
 (define_function_unit "adder" 1 1
-  (and (eq_attr "type" "fadd") (eq_attr "cpu" "!r3000,r3900,r6000,r4300"))
+  (and (eq_attr "type" "fadd") (eq_attr "cpu" "!r3000,r3900,r6000,r4300,r10000"))
   4 0)
 
 (define_function_unit "adder" 1 1
@@ -456,6 +491,10 @@
   (and (eq_attr "type" "fadd") (eq_attr "cpu" "r6000"))
   3 0)
 
+(define_function_unit "adder" 1 1
+  (and (eq_attr "type" "fadd,fmadd") (eq_attr "cpu" "r10000"))
+  2 0)
+
 (define_function_unit "adder" 1 1
   (and (eq_attr "type" "fabs,fneg")
        (eq_attr "cpu" "!r3000,r3900,r4600,r4650,r4300,r5000"))
@@ -468,7 +507,7 @@
 (define_function_unit "mult" 1 1
   (and (eq_attr "type" "fmul")
        (and (eq_attr "mode" "SF")
-	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300,r5000")))
+	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300,r5000,r10000")))
   7 0)
 
 (define_function_unit "mult" 1 1
@@ -488,7 +527,7 @@
 
 (define_function_unit "mult" 1 1
   (and (eq_attr "type" "fmul")
-       (and (eq_attr "mode" "DF") (eq_attr "cpu" "!r3000,r3900,r6000,r4300,r5000")))
+       (and (eq_attr "mode" "DF") (eq_attr "cpu" "!r3000,r3900,r6000,r4300,r5000,r10000")))
   8 0)
 
 (define_function_unit "mult" 1 1
@@ -501,10 +540,14 @@
        (and (eq_attr "mode" "DF") (eq_attr "cpu" "r6000")))
   6 0)
 
+(define_function_unit "mult" 1 1
+  (and (eq_attr "type" "fmul,fmadd") (eq_attr "cpu" "r10000"))
+  2 0)
+
 (define_function_unit "divide" 1 1
   (and (eq_attr "type" "fdiv")
        (and (eq_attr "mode" "SF")
-	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300,r5000")))
+	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300,r5000,r10000")))
   23 0)
 
 (define_function_unit "divide" 1 1
@@ -530,7 +573,7 @@
 (define_function_unit "divide" 1 1
   (and (eq_attr "type" "fdiv")
        (and (eq_attr "mode" "DF")
-	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300")))
+	    (eq_attr "cpu" "!r3000,r3900,r6000,r4600,r4650,r4300,r10000")))
   36 0)
 
 (define_function_unit "divide" 1 1
@@ -548,10 +591,21 @@
        (and (eq_attr "mode" "DF") (eq_attr "cpu" "r4600,r4650")))
   61 0)
 
+;; divisions keep multiplier busy on R10000
+(define_function_unit "mult" 1 1
+  (and (eq_attr "type" "fdiv") 
+       (and (eq_attr "mode" "SF") (eq_attr "cpu" "r10000")))
+  12 14)
+
+(define_function_unit "mult" 1 1
+  (and (eq_attr "type" "fdiv") 
+       (and (eq_attr "mode" "DF") (eq_attr "cpu" "r10000")))
+  19 21)
+
 ;;; ??? Is this number right?
 (define_function_unit "divide" 1 1
   (and (eq_attr "type" "fsqrt,frsqrt")
-       (and (eq_attr "mode" "SF") (eq_attr "cpu" "!r4600,r4650,r4300,r5000")))
+       (and (eq_attr "mode" "SF") (eq_attr "cpu" "!r4600,r4650,r4300,r5000,r10000")))
   54 0)
 
 (define_function_unit "divide" 1 1
@@ -567,7 +621,7 @@
 ;;; ??? Is this number right?
 (define_function_unit "divide" 1 1
   (and (eq_attr "type" "fsqrt,frsqrt")
-       (and (eq_attr "mode" "DF") (eq_attr "cpu" "!r4600,r4650,r4300,r5000")))
+       (and (eq_attr "mode" "DF") (eq_attr "cpu" "!r4600,r4650,r4300,r5000,r10000")))
   112 0)
 
 (define_function_unit "divide" 1 1
@@ -580,6 +634,17 @@
        (and (eq_attr "mode" "DF") (eq_attr "cpu" "r5000")))
   36 0)
 
+;; sqrt is executed by multiplier on R10000
+(define_function_unit "mult" 1 1
+  (and (eq_attr "type" "fsqrt")
+       (and (eq_attr "mode" "SF") (eq_attr "cpu" "r10000")))
+  18 20)
+
+(define_function_unit "mult" 1 1
+  (and (eq_attr "type" "fsqrt")
+       (and (eq_attr "mode" "DF") (eq_attr "cpu" "r10000")))
+  33 35)
+
 ;; R4300 FP instruction classes treated as part of the "imuldiv"
 ;; functional unit:
 
@@ -3158,7 +3223,7 @@ dsrl\t%3,%3,1\n\
   "@
     sll\t%0,%1,0
     sw\t%1,%0"
-  [(set_attr "type" "darith,store")
+  [(set_attr "type" "shift,store")
    (set_attr "mode" "SI")
    (set_attr "extended_mips16" "yes,*")])
 
@@ -3192,7 +3257,7 @@ dsrl\t%3,%3,1\n\
                                   (match_operand:DI 2 "small_int" "I"))))]
   "TARGET_64BIT && !TARGET_MIPS16 && INTVAL (operands[2]) >= 32"
   "dsra\t%0,%1,%2"
-  [(set_attr "type" "darith")
+  [(set_attr "type" "shift")
    (set_attr "mode" "SI")])
 
 (define_insn ""
@@ -3201,7 +3266,7 @@ dsrl\t%3,%3,1\n\
                                   (const_int 32))))]
   "TARGET_64BIT && !TARGET_MIPS16"
   "dsra\t%0,%1,32"
-  [(set_attr "type" "darith")
+  [(set_attr "type" "shift")
    (set_attr "mode" "SI")])
 
 
@@ -5246,7 +5311,7 @@ dsrl\t%3,%3,1\n\
 
   return "sll\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")])
 
 (define_insn "ashlsi3_internal1_extend"
@@ -5260,7 +5325,7 @@ dsrl\t%3,%3,1\n\
 
   return "sll\t%0,%1,%2";
 }
-  [(set_attr "type"    "arith")
+  [(set_attr "type"    "shift")
    (set_attr "mode"    "DI")])
 
 
@@ -5278,7 +5343,7 @@ dsrl\t%3,%3,1\n\
 
   return "sll\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")
    (set_attr_alternative "length"
 		[(const_int 4)
@@ -5379,7 +5444,7 @@ sll\t%L0,%L1,%2\n\
   operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);
   return "sll\t%M0,%L1,%2\;move\t%L0,%.";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"8")])
 
@@ -5434,7 +5499,7 @@ sll\t%L0,%L1,%2\n\
 
   return "sll\t%M0,%M1,%2\;srl\t%3,%L1,%4\;or\t%M0,%M0,%3\;sll\t%L0,%L1,%2";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"16")])
 
@@ -5518,7 +5583,7 @@ sll\t%L0,%L1,%2\n\
 
   return "dsll\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")])
 
 (define_insn ""
@@ -5535,7 +5600,7 @@ sll\t%L0,%L1,%2\n\
 
   return "dsll\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr_alternative "length"
 		[(const_int 4)
@@ -5596,7 +5661,7 @@ sll\t%L0,%L1,%2\n\
 
   return "sra\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")])
 
 (define_insn "ashrsi3_internal2"
@@ -5613,7 +5678,7 @@ sll\t%L0,%L1,%2\n\
 
   return "sra\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")
    (set_attr_alternative "length"
 		[(const_int 4)
@@ -5710,7 +5775,7 @@ sra\t%M0,%M1,%2\n\
   operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);
   return "sra\t%L0,%M1,%2\;sra\t%M0,%M1,31";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"8")])
 
@@ -5765,7 +5830,7 @@ sra\t%M0,%M1,%2\n\
 
   return "srl\t%L0,%L1,%2\;sll\t%3,%M1,%4\;or\t%L0,%L0,%3\;sra\t%M0,%M1,%2";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"16")])
 
@@ -5849,7 +5914,7 @@ sra\t%M0,%M1,%2\n\
 
   return "dsra\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")])
 
 (define_insn ""
@@ -5863,7 +5928,7 @@ sra\t%M0,%M1,%2\n\
 
   return "dsra\t%0,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr_alternative "length"
 		[(const_int 4)
@@ -5923,7 +5988,7 @@ sra\t%M0,%M1,%2\n\
 
   return "srl\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")])
 
 (define_insn "lshrsi3_internal2"
@@ -5940,7 +6005,7 @@ sra\t%M0,%M1,%2\n\
 
   return "srl\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"SI")
    (set_attr_alternative "length"
 		[(const_int 4)
@@ -6061,7 +6126,7 @@ srl\t%M0,%M1,%2\n\
   operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);
   return "srl\t%L0,%M1,%2\;move\t%M0,%.";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"8")])
 
@@ -6116,7 +6181,7 @@ srl\t%M0,%M1,%2\n\
 
   return "srl\t%L0,%L1,%2\;sll\t%3,%M1,%4\;or\t%L0,%L0,%3\;srl\t%M0,%M1,%2";
 }
-  [(set_attr "type"	"darith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr "length"	"16")])
 
@@ -6200,7 +6265,7 @@ srl\t%M0,%M1,%2\n\
 
   return "dsrl\t%0,%1,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")])
 
 (define_insn ""
@@ -6214,7 +6279,7 @@ srl\t%M0,%M1,%2\n\
 
   return "dsrl\t%0,%2";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"shift")
    (set_attr "mode"	"DI")
    (set_attr_alternative "length"
 		[(const_int 4)
diff --git a/gcc/config/netbsd-elf.h b/gcc/config/netbsd-elf.h
index a87699c3..0cbdb923 100644
--- a/gcc/config/netbsd-elf.h
+++ b/gcc/config/netbsd-elf.h
@@ -83,6 +83,7 @@ Boston, MA 02111-1307, USA.  */
 #define NETBSD_LINK_SPEC_ELF \
   "%{assert*} %{R*} %{rpath*} \
    %{shared:-shared} \
+   %{symbolic:-Bsymbolic} \
    %{!shared: \
      -dc -dp \
      %{!nostdlib: \
diff --git a/gcc/config/openbsd.h b/gcc/config/openbsd.h
index 670a0a08..0e3b4ecc 100644
--- a/gcc/config/openbsd.h
+++ b/gcc/config/openbsd.h
@@ -52,15 +52,14 @@ Boston, MA 02111-1307, USA.  */
 
 #ifdef OPENBSD_NATIVE
 
-#undef GCC_INCLUDE_DIR
-#define GCC_INCLUDE_DIR "/usr/include"
-
 /* The compiler is configured with ONLY the gcc/g++ standard headers.  */
 #undef INCLUDE_DEFAULTS
 #define INCLUDE_DEFAULTS			\
   {						\
     { GPLUSPLUS_INCLUDE_DIR, "G++", 1, 1 },	\
-    { GCC_INCLUDE_DIR, "GCC", 0, 0 },		\
+    { GPLUSPLUS_TOOL_INCLUDE_DIR, "G++", 1, 1 }, \
+    { GPLUSPLUS_BACKWARD_INCLUDE_DIR, "G++", 1, 1 }, \
+    { STANDARD_INCLUDE_DIR, STANDARD_INCLUDE_COMPONENT, 0, 0 }, \
     { 0, 0, 0, 0 }				\
   }
 
@@ -72,9 +71,39 @@ Boston, MA 02111-1307, USA.  */
 
 
 /* Controlling the compilation driver.  */
+/* TARGET_OS_CPP_BUILTINS() common to all OpenBSD targets.  */
+#define OPENBSD_OS_CPP_BUILTINS_COMMON()	\
+  do						\
+    {						\
+      builtin_define ("__OpenBSD__");		\
+      builtin_define ("__unix__");		\
+      builtin_define ("__ANSI_COMPAT");		\
+      builtin_assert ("system=unix");		\
+      builtin_assert ("system=bsd");		\
+      builtin_assert ("system=OpenBSD");	\
+    }						\
+  while (0)
+
+/* TARGET_OS_CPP_BUILTINS() common to all OpenBSD ELF targets.  */
+#define OPENBSD_OS_CPP_BUILTINS_ELF()		\
+  do						\
+    {						\
+      OPENBSD_OS_CPP_BUILTINS_COMMON();		\
+      builtin_define ("__ELF__");		\
+    }						\
+  while (0)
+
+/* TARGET_OS_CPP_BUILTINS() common to all LP64 OpenBSD targets.  */
+#define OPENBSD_OS_CPP_BUILTINS_LP64()		\
+  do						\
+    {						\
+      builtin_define ("_LP64");			\
+      builtin_define ("__LP64__");		\
+    }						\
+  while (0)
 
 /* CPP_SPEC appropriate for OpenBSD. We deal with -posix and -pthread.
-   XXX the way threads are handling currently is not very satisfying,
+   XXX the way threads are handled currently is not very satisfying,
    since all code must be compiled with -pthread to work. 
    This two-stage defines makes it easy to pick that for targets that
    have subspecs.  */
@@ -84,10 +113,9 @@ Boston, MA 02111-1307, USA.  */
 #define OBSD_CPP_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_POSIX_THREADS}"
 #endif
 
-/* LIB_SPEC appropriate for OpenBSD.  Select the appropriate libc, 
-   depending on profiling and threads.  Basically, 
-   -lc(_r)?(_p)?, select _r for threads, and _p for p or pg.  */
-#define OBSD_LIB_SPEC "%{!shared:-lc%{pthread:_r}%{p:_p}%{!p:%{pg:_p}}}"
+/* LIB_SPEC appropriate for OpenBSD.  Include -lpthread if -pthread is
+   specified on the command line. */
+#define OBSD_LIB_SPEC "%{!shared:%{pthread:-lpthread%{p:_p}%{!p:%{pg:_p}}}} %{!shared:-lc%{p:_p}%{!p:%{pg:_p}}}"
 
 #ifndef OBSD_HAS_CORRECT_SPECS
 
diff --git a/gcc/config/rs6000/ppc-asm.h b/gcc/config/rs6000/ppc-asm.h
index 74e14836..47547f6a 100644
--- a/gcc/config/rs6000/ppc-asm.h
+++ b/gcc/config/rs6000/ppc-asm.h
@@ -158,7 +158,7 @@ GLUE(.L,name): \
 	.size FUNC_NAME(name),GLUE(.L,name)-FUNC_NAME(name)
 #endif
 
-#if defined __linux__ && !defined __powerpc64__
+#if defined __linux__
 	.section .note.GNU-stack
 	.previous
 #endif
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index ea358433..6909ceff 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -1177,6 +1177,12 @@ rs6000_file_start (void)
       if (*start == '\0')
 	putc ('\n', file);
     }
+
+  if (DEFAULT_ABI == ABI_AIX || (TARGET_ELF && flag_pic == 2))
+    {
+      toc_section ();
+      text_section ();
+    }
 }
 
 /* Return nonzero if this function is known to have a null epilogue.  */
@@ -11452,13 +11458,6 @@ rs6000_emit_load_toc_table (int fromprolog)
 		   ? gen_rtx_REG (Pmode, 0)
 		   : gen_reg_rtx (Pmode));
 
-      /* possibly create the toc section */
-      if (! toc_initialized)
-	{
-	  toc_section ();
-	  function_section (current_function_decl);
-	}
-
       if (fromprolog)
 	{
 	  rtx symF, symL;
@@ -15920,7 +15919,6 @@ rs6000_xcoff_file_start (void)
   fputs ("\t.file\t", asm_out_file);
   output_quoted_string (asm_out_file, main_input_filename);
   fputc ('\n', asm_out_file);
-  toc_section ();
   if (write_symbols != NO_DEBUG)
     private_data_section ();
   text_section ();
diff --git a/gcc/config/rs6000/t-linux64 b/gcc/config/rs6000/t-linux64
index 6d1e6f46..84b99a83 100644
--- a/gcc/config/rs6000/t-linux64
+++ b/gcc/config/rs6000/t-linux64
@@ -9,13 +9,13 @@ TARGET_LIBGCC2_CFLAGS = -mno-minimal-toc -fPIC -specs=bispecs
 
 SHLIB_MAPFILES += $(srcdir)/config/rs6000/libgcc-ppc64.ver
 
-MULTILIB_OPTIONS        = m64/m32 msoft-float
-MULTILIB_DIRNAMES       = 64 32 nof
+MULTILIB_OPTIONS        = m64/m32
+MULTILIB_DIRNAMES       = 64 32
 MULTILIB_EXTRA_OPTS     = fPIC mstrict-align
-MULTILIB_EXCEPTIONS     = m64/msoft-float
-MULTILIB_EXCLUSIONS     = m64/!m32/msoft-float
-MULTILIB_OSDIRNAMES	= ../lib64 ../lib nof
-MULTILIB_MATCHES        = $(MULTILIB_MATCHES_FLOAT)
+MULTILIB_EXCEPTIONS     =
+MULTILIB_EXCLUSIONS     =
+MULTILIB_OSDIRNAMES	= ../lib64 ../lib
+MULTILIB_MATCHES        =
 
 # We want fine grained libraries, so use the new code to build the
 # floating point emulation libraries.
diff --git a/gcc/config/sh/lib1funcs.asm b/gcc/config/sh/lib1funcs.asm
index eebce2ec..1d58d099 100644
--- a/gcc/config/sh/lib1funcs.asm
+++ b/gcc/config/sh/lib1funcs.asm
@@ -37,9 +37,19 @@ Boston, MA 02111-1307, USA.  */
    ELF local label prefixes by J"orn Rennecke
    amylaar@cygnus.com  */
 
+#define ALIAS(X,Y)	.global GLOBAL(X); .set GLOBAL(X),GLOBAL(Y)
+
 #ifdef __ELF__
 #define LOCAL(X)	.L_##X
-#define FUNC(X)		.type X,@function
+
+#if 1 /* ??? The export list mechanism is broken, everything that is not
+	 hidden is exported.  */
+#undef FUNC
+#define FUNC(X)		.type X,@function; .hidden X
+#undef ALIAS
+#define ALIAS(X,Y)	.global GLOBAL(X); .set GLOBAL(X),GLOBAL(Y); .hidden GLOBAL(X)
+#endif
+
 #define ENDFUNC0(X)	.Lfe_##X: .size X,.Lfe_##X-X
 #define ENDFUNC(X)	ENDFUNC0(X)
 #else
diff --git a/gcc/config/sh/linux.h b/gcc/config/sh/linux.h
index b2ad064f..94c22934 100644
--- a/gcc/config/sh/linux.h
+++ b/gcc/config/sh/linux.h
@@ -145,6 +145,7 @@ do { \
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
+#ifndef inhibit_libc
 #ifdef IN_LIBGCC2
 #include <signal.h>
 #include <sys/ucontext.h>
@@ -244,8 +245,8 @@ do { \
 		 && (*(unsigned short *) (pc_+14)  == 0x00ad))))	\
       {									\
 	struct rt_sigframe {						\
-	  struct siginfo info;						\
-	  struct ucontext uc;						\
+	  siginfo_t info;						\
+	  ucontext_t uc;						\
 	} *rt_ = (CONTEXT)->cfa;					\
 	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
       }									\
@@ -295,6 +296,7 @@ do { \
 
 #endif /* defined (__SH5__) */
 #endif /* IN_LIBGCC2 */
+#endif /* inhibit_libc */
 
 /* For SH3 and SH4, we use a slot of the unwind frame which correspond
    to a fake register number 16 as a placeholder for the return address
diff --git a/gcc/config/sh/sh.c b/gcc/config/sh/sh.c
index 403c274a..847309a4 100644
--- a/gcc/config/sh/sh.c
+++ b/gcc/config/sh/sh.c
@@ -8999,6 +8999,9 @@ sh_register_move_cost (enum machine_mode mode,
       && REGCLASS_HAS_FP_REG (dstclass))
     return 4;
 
+  if (REGCLASS_HAS_FP_REG (dstclass) && srcclass == T_REGS)
+    return ((TARGET_HARD_SH4 && !optimize_size) ? 10 : 7);
+
   if ((REGCLASS_HAS_FP_REG (dstclass) && srcclass == MAC_REGS)
       || (dstclass== MAC_REGS && REGCLASS_HAS_FP_REG (srcclass)))
     return 9;
@@ -9107,6 +9110,15 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
     }
   this = FUNCTION_ARG (cum, Pmode, ptr_type_node, 1);
 
+  /* In PIC case, we set PIC register to compute the target address.  We
+     can use a scratch register to save and restore the original value  
+     except for SHcompact.  For SHcompact, use stack.  */
+  if (flag_pic && TARGET_SHCOMPACT)
+    {
+      push (PIC_OFFSET_TABLE_REGNUM);
+      emit_insn (gen_GOTaddr2picreg ());
+    }
+
   /* For SHcompact, we only have r0 for a scratch register: r1 is the
      static chain pointer (even if you can't have nested virtual functions
      right now, someone might implement them sometime), and the rest of the
@@ -9189,8 +9201,24 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
       assemble_external (function);
       TREE_USED (function) = 1;
     }
+  /* We can use scratch1 to save and restore the original value of
+     PIC register except for SHcompact.  */
+  if (flag_pic && ! TARGET_SHCOMPACT)
+    {
+      emit_move_insn (scratch1,
+		      gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM));
+      emit_insn (gen_GOTaddr2picreg ());
+    }
   funexp = XEXP (DECL_RTL (function), 0);
   emit_move_insn (scratch2, funexp);
+  if (flag_pic)
+    {
+      if (! TARGET_SHCOMPACT)
+	emit_move_insn (gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM),
+			scratch1);
+      else
+	pop (PIC_OFFSET_TABLE_REGNUM);
+    }
   funexp = gen_rtx_MEM (FUNCTION_MODE, scratch2);
   sibcall = emit_call_insn (gen_sibcall (funexp, const0_rtx, NULL_RTX));
   SIBLING_CALL_P (sibcall) = 1;
diff --git a/gcc/config/sh/sh.h b/gcc/config/sh/sh.h
index bfba34aa..58289742 100644
--- a/gcc/config/sh/sh.h
+++ b/gcc/config/sh/sh.h
@@ -422,6 +422,10 @@ extern int target_flags;
 do {									\
   if (LEVEL)								\
     flag_omit_frame_pointer = -1;					\
+  if (LEVEL <= 2)							\
+    {									\
+      flag_reorder_blocks = 0;						\
+    }									\
   if (SIZE)								\
     target_flags |= SPACE_BIT;						\
   if (TARGET_SHMEDIA && LEVEL > 1)					\
diff --git a/gcc/config/sparc/openbsd.h b/gcc/config/sparc/openbsd.h
index e36f51eb..2c35c957 100644
--- a/gcc/config/sparc/openbsd.h
+++ b/gcc/config/sparc/openbsd.h
@@ -22,10 +22,7 @@ Boston, MA 02111-1307, USA.  */
 #define TARGET_OS_CPP_BUILTINS()		\
   do						\
     {						\
-	builtin_define ("__unix__");		\
-	builtin_define ("__OpenBSD__");		\
-	builtin_assert ("system=unix");		\
-	builtin_assert ("system=OpenBSD");	\
+      OPENBSD_OS_CPP_BUILTINS_ELF();		\
     }						\
   while (0)
 
@@ -44,6 +41,23 @@ Boston, MA 02111-1307, USA.  */
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
+#undef LINK_SPEC
+#define LINK_SPEC \
+  "%{!shared:%{!nostdlib:%{!r*:%{!e*:-e __start}}}} \
+   %{shared:-shared} %{R*} \
+   %{static:-Bstatic} \
+   %{!static:-Bdynamic} \
+   %{assert*} \
+   %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.so}"
+
+/* As an elf system, we need crtbegin/crtend stuff.  */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "\
+	%{!shared: %{pg:gcrt0%O%s} %{!pg:%{p:gcrt0%O%s} %{!p:crt0%O%s}} \
+	crtbegin%O%s} %{shared:crtbeginS%O%s}"
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{!shared:crtend%O%s} %{shared:crtendS%O%s}"
+
 /* Specific options for DBX Output.  */
 
 /* This is BSD, so it wants DBX format.  */
diff --git a/gcc/configure.ac b/gcc/configure.ac
index d9151ddd..15262212 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -2218,7 +2218,7 @@ foo:	.long	25
 	tls_first_minor=14
 	tls_as_opt="-m64 -Aesame --fatal-warnings"
 	;;
-  sh-*-* | sh[34]-*-*)
+  sh-*-* | sh[34]*-*-*)
     conftest_s='
 	.section ".tdata","awT",@progbits
 foo:	.long	25
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index c14313c8..c9b96dcf 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -6808,7 +6808,6 @@ initialize_array (tree decl, tree inits)
   context = DECL_CONTEXT (decl);
   DECL_CONTEXT (decl) = NULL_TREE;
   DECL_INITIAL (decl) = build_constructor (NULL_TREE, inits);
-  TREE_HAS_CONSTRUCTOR (DECL_INITIAL (decl)) = 1;
   cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);
   DECL_CONTEXT (decl) = context;
 }
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index cc1f937e..aa98d86e 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -2440,13 +2440,17 @@ struct lang_decl GTY(())
    When appearing in a SAVE_EXPR, it means that underneath
    is a call to a constructor.
 
-   When appearing in a CONSTRUCTOR, it means that it was
-   a GNU C constructor expression.
+   When appearing in a CONSTRUCTOR, the expression is a
+   compound literal.
 
    When appearing in a FIELD_DECL, it means that this field
    has been duly initialized in its constructor.  */
 #define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4 (NODE))
 
+/* True if NODE is a brace-enclosed initializer.  */
+#define BRACE_ENCLOSED_INITIALIZER_P(NODE) \
+  (TREE_CODE (NODE) == CONSTRUCTOR && !TREE_TYPE (NODE))
+
 #define EMPTY_CONSTRUCTOR_P(NODE) (TREE_CODE (NODE) == CONSTRUCTOR	   \
 				   && CONSTRUCTOR_ELTS (NODE) == NULL_TREE \
 				   && ! TREE_HAS_CONSTRUCTOR (NODE))
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 451993eb..e52c81ac 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -4283,8 +4283,7 @@ reshape_init (tree type, tree *initp)
      enclosed elements.  Advance past the brace-enclosed initializer
      now.  */
   if (TREE_CODE (old_init_value) == CONSTRUCTOR
-      && TREE_TYPE (old_init_value) == NULL_TREE
-      && TREE_HAS_CONSTRUCTOR (old_init_value))
+      && BRACE_ENCLOSED_INITIALIZER_P (old_init_value))
     {
       *initp = TREE_CHAIN (old_init);
       TREE_CHAIN (old_init) = NULL_TREE;
@@ -4356,8 +4355,7 @@ reshape_init (tree type, tree *initp)
   else
     {
       /* Build a CONSTRUCTOR to hold the contents of the aggregate.  */  
-      new_init = build_constructor (type, NULL_TREE);
-      TREE_HAS_CONSTRUCTOR (new_init) = 1;
+      new_init = build_constructor (NULL_TREE, NULL_TREE);
 
       if (CLASS_TYPE_P (type))
 	{
@@ -4417,7 +4415,8 @@ reshape_init (tree type, tree *initp)
 		}
 	    }
 	}
-      else if ((TREE_CODE (type) == ARRAY_TYPE)|| (TREE_CODE (type) == VECTOR_TYPE))
+      else if (TREE_CODE (type) == ARRAY_TYPE
+	       || TREE_CODE (type) == VECTOR_TYPE)
 	{
 	  tree max_index;
 
@@ -4515,7 +4514,8 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)
     init = grok_reference_init (decl, type, init, cleanup);
   else if (init)
     {
-      if (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))
+      if (TREE_CODE (init) == CONSTRUCTOR 
+	  && BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  /* [dcl.init] paragraph 13,
 	     If T is a scalar type, then a declaration of the form
@@ -4540,15 +4540,13 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)
 	 array size from the initializer.  */
       maybe_deduce_size_from_array_init (decl, init);
       type = TREE_TYPE (decl);
-      if (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))
-	TREE_TYPE (init) = type;
 
       if (TYPE_HAS_CONSTRUCTOR (type) || TYPE_NEEDS_CONSTRUCTING (type))
 	{
 	  if (TREE_CODE (type) == ARRAY_TYPE)
 	    goto initialize_aggr;
 	  else if (TREE_CODE (init) == CONSTRUCTOR
-		   && TREE_HAS_CONSTRUCTOR (init))
+		   && BRACE_ENCLOSED_INITIALIZER_P (init))
 	    {
 	      if (TYPE_NON_AGGREGATE_CLASS (type))
 		{
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index 4e3cd4be..618d6184 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -341,8 +341,7 @@ perform_member_init (tree member, tree init)
 	  finish_expr_stmt (init);
 	}
     }
-  else if (TYPE_NEEDS_CONSTRUCTING (type)
-	   || (init && TYPE_HAS_CONSTRUCTOR (type)))
+  else if (TYPE_NEEDS_CONSTRUCTING (type))
     {
       if (explicit
 	  && TREE_CODE (type) == ARRAY_TYPE
@@ -1092,34 +1091,24 @@ build_aggr_init (tree exp, tree init, int flags)
 
   if (TREE_CODE (type) == ARRAY_TYPE)
     {
-      /* Must arrange to initialize each element of EXP
-	 from elements of INIT.  */
-      tree itype = init ? TREE_TYPE (init) : NULL_TREE;
-      
-      if (init && !itype)
+      tree itype;
+      /* An array may not be initialized use the parenthesized
+	 initialization form -- unless the initializer is "()".  */
+      if (init && TREE_CODE (init) == TREE_LIST)
 	{
-	  /* Handle bad initializers like:
-	     class COMPLEX {
-	     public:
-	       double re, im;
-	       COMPLEX(double r = 0.0, double i = 0.0) {re = r; im = i;};
-	       ~COMPLEX() {};
-	     };
-
-	     int main(int argc, char **argv) {
-	       COMPLEX zees(1.0, 0.0)[10];
-	     }
-	  */
 	  error ("bad array initializer");
 	  return error_mark_node;
 	}
+      /* Must arrange to initialize each element of EXP
+	 from elements of INIT.  */
+      itype = init ? TREE_TYPE (init) : NULL_TREE;
       if (cp_type_quals (type) != TYPE_UNQUALIFIED)
 	TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);
       if (itype && cp_type_quals (itype) != TYPE_UNQUALIFIED)
-	TREE_TYPE (init) = TYPE_MAIN_VARIANT (itype);
+	itype = TREE_TYPE (init) = TYPE_MAIN_VARIANT (itype);
       stmt_expr = build_vec_init (exp, NULL_TREE, init,
-				  init && same_type_p (TREE_TYPE (init),
-						       TREE_TYPE (exp)));
+				  itype && same_type_p (itype,
+							TREE_TYPE (exp)));
       TREE_READONLY (exp) = was_const;
       TREE_THIS_VOLATILE (exp) = was_volatile;
       TREE_TYPE (exp) = type;
@@ -1195,8 +1184,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)
 	   to run a new constructor; and catching an exception, where we
 	   have already built up the constructor call so we could wrap it
 	   in an exception region.  */;
-      else if (TREE_CODE (init) == CONSTRUCTOR 
-	       && TREE_HAS_CONSTRUCTOR (init))
+      else if (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  /* A brace-enclosed initializer for an aggregate.  */
 	  my_friendly_assert (CP_AGGREGATE_TYPE_P (type), 20021016);
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 032cbd7e..98bef32d 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -11610,10 +11610,6 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)
       cp_lexer_consume_token (parser->lexer);
       /* Create a CONSTRUCTOR to represent the braced-initializer.  */
       initializer = make_node (CONSTRUCTOR);
-      /* Mark it with TREE_HAS_CONSTRUCTOR.  This should not be
-	 necessary, but check_initializer depends upon it, for 
-	 now.  */
-      TREE_HAS_CONSTRUCTOR (initializer) = 1;
       /* If it's not a `}', then there is a non-trivial initializer.  */
       if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_BRACE))
 	{
diff --git a/gcc/cp/rtti.c b/gcc/cp/rtti.c
index e9c06160..337c6be9 100644
--- a/gcc/cp/rtti.c
+++ b/gcc/cp/rtti.c
@@ -807,7 +807,7 @@ tinfo_base_init (tree desc, tree target)
   init = tree_cons (NULL_TREE, decay_conversion (name_decl), init);
   
   init = build_constructor (NULL_TREE, nreverse (init));
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   init = tree_cons (NULL_TREE, init, NULL_TREE);
   
   return init;
@@ -823,7 +823,7 @@ generic_initializer (tree desc, tree target)
   tree init = tinfo_base_init (desc, target);
   
   init = build_constructor (NULL_TREE, init);
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;
 }
 
@@ -850,7 +850,7 @@ ptr_initializer (tree desc, tree target, bool *non_public_ptr)
                     init);
   
   init = build_constructor (NULL_TREE, nreverse (init));
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;
 }
 
@@ -887,7 +887,7 @@ ptm_initializer (tree desc, tree target, bool *non_public_ptr)
 		    init);  
   
   init = build_constructor (NULL_TREE, nreverse (init));
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;  
 }
 
@@ -955,7 +955,7 @@ class_initializer (tree desc, tree target, tree trail)
   
   TREE_CHAIN (init) = trail;
   init = build_constructor (NULL_TREE, init);
-  TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
+  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;
   return init;  
 }
 
@@ -1072,11 +1072,9 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)
               base_init = tree_cons (NULL_TREE, offset, base_init);
               base_init = tree_cons (NULL_TREE, tinfo, base_init);
               base_init = build_constructor (NULL_TREE, base_init);
-	      TREE_HAS_CONSTRUCTOR (base_init) = 1;
               base_inits = tree_cons (NULL_TREE, base_init, base_inits);
             }
 	  base_inits = build_constructor (NULL_TREE, base_inits);
-	  TREE_HAS_CONSTRUCTOR (base_inits) = 1;
 	  base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);
 	  /* Prepend the number of bases.  */
 	  base_inits = tree_cons (NULL_TREE,
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index b13fb857..f93322a3 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -1948,12 +1948,6 @@ finish_class_member_access_expr (tree object, tree name)
 	     or a BIT_NOT_EXPR.  */
 	  scope = TREE_OPERAND (name, 0);
 	  name = TREE_OPERAND (name, 1);
-	  my_friendly_assert ((CLASS_TYPE_P (scope) 
-			       || TREE_CODE (scope) == NAMESPACE_DECL),
-			      20020804);
-	  my_friendly_assert ((TREE_CODE (name) == IDENTIFIER_NODE
-			       || TREE_CODE (name) == BIT_NOT_EXPR),
-			      20020804);
 
 	  /* If SCOPE is a namespace, then the qualified name does not
 	     name a member of OBJECT_TYPE.  */
@@ -1964,6 +1958,10 @@ finish_class_member_access_expr (tree object, tree name)
 	      return error_mark_node;
 	    }
 
+	  my_friendly_assert (CLASS_TYPE_P (scope), 20020804);
+	  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE
+		      || TREE_CODE (name) == BIT_NOT_EXPR, 20020804);
+
 	  /* Find the base of OBJECT_TYPE corresponding to SCOPE.  */
 	  access_path = lookup_base (object_type, scope, ba_check, NULL);
 	  if (access_path == error_mark_node)
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index 780c3e7a..e305782b 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -479,8 +479,6 @@ digest_init (tree type, tree init, tree* tail)
   enum tree_code code = TREE_CODE (type);
   tree element = NULL_TREE;
   tree old_tail_contents = NULL_TREE;
-  /* Nonzero if INIT is a braced grouping.  */
-  int raw_constructor;
 
   /* By default, assume we use one element from a list.
      We correct this later in the sole case where it is not true.  */
@@ -510,10 +508,7 @@ digest_init (tree type, tree init, tree* tail)
   if (TREE_CODE (init) == NON_LVALUE_EXPR)
     init = TREE_OPERAND (init, 0);
 
-  raw_constructor = (TREE_CODE (init) == CONSTRUCTOR 
-		     && TREE_HAS_CONSTRUCTOR (init));
-
-  if (raw_constructor
+  if (BRACE_ENCLOSED_INITIALIZER_P (init)
       && CONSTRUCTOR_ELTS (init) != 0
       && TREE_CHAIN (CONSTRUCTOR_ELTS (init)) == 0)
     {
@@ -585,7 +580,7 @@ digest_init (tree type, tree init, tree* tail)
       || code == BOOLEAN_TYPE || code == COMPLEX_TYPE
       || TYPE_PTR_TO_MEMBER_P (type))
     {
-      if (raw_constructor)
+      if (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  if (element == 0)
 	    {
@@ -594,7 +589,7 @@ digest_init (tree type, tree init, tree* tail)
 	    }
 	  init = element;
 	}
-      while (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))
+      while (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
 	  pedwarn ("braces around scalar initializer for `%T'", type);
 	  init = CONSTRUCTOR_ELTS (init);
@@ -618,15 +613,16 @@ digest_init (tree type, tree init, tree* tail)
 
   if (code == ARRAY_TYPE || code == VECTOR_TYPE || IS_AGGR_TYPE_CODE (code))
     {
-      if (raw_constructor && TYPE_NON_AGGREGATE_CLASS (type)
-	  && TREE_HAS_CONSTRUCTOR (init))
+      if (BRACE_ENCLOSED_INITIALIZER_P (init))
 	{
-	  error ("subobject of type `%T' must be initialized by constructor, not by `%E'",
-		    type, init);
-	  return error_mark_node;
+	  if (TYPE_NON_AGGREGATE_CLASS (type))
+	    {
+	      error ("subobject of type `%T' must be initialized by constructor, not by `%E'",
+		     type, init);
+	      return error_mark_node;
+	    }
+	  return process_init_constructor (type, init, (tree *)0);
 	}
-      else if (raw_constructor)
-	return process_init_constructor (type, init, (tree *)0);
       else if (can_convert_arg (type, TREE_TYPE (init), init)
 	       || TYPE_NON_AGGREGATE_CLASS (type))
 	/* These are never initialized from multiple constructor elements.  */;
@@ -868,7 +864,7 @@ process_init_constructor (tree type, tree init, tree* elts)
 
 	      /* Warn when some struct elements are implicitly initialized.  */
 	      if (extra_warnings
-	          && (!init || TREE_HAS_CONSTRUCTOR (init)))
+	          && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))
 		warning ("missing initializer for member `%D'", field);
 	    }
 	  else
@@ -884,7 +880,7 @@ process_init_constructor (tree type, tree init, tree* elts)
 	      /* Warn when some struct elements are implicitly initialized
 		 to zero.  */
 	      if (extra_warnings
-	          && (!init || TREE_HAS_CONSTRUCTOR (init)))
+	          && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))
 		warning ("missing initializer for member `%D'", field);
 
 	      if (! zero_init_p (TREE_TYPE (field)))
diff --git a/gcc/diagnostic.c b/gcc/diagnostic.c
index c29867a6..ac553e39 100644
--- a/gcc/diagnostic.c
+++ b/gcc/diagnostic.c
@@ -272,14 +272,14 @@ diagnostic_action_after_output (diagnostic_context *context,
 	real_abort ();
 
       fnotice (stderr, bug_report_request, bug_report_url);
-      exit (FATAL_EXIT_CODE);
+      exit (ICE_EXIT_CODE);
 
     case DK_FATAL:
       if (context->abort_on_error)
 	real_abort ();
 
       fnotice (stderr, "compilation terminated.\n");
-      exit (FATAL_EXIT_CODE);
+      exit (ICE_EXIT_CODE);
 
     default:
       real_abort ();
@@ -571,7 +571,7 @@ error_recursion (diagnostic_context *context)
   fnotice (stderr,
 	   "Internal compiler error: Error reporting routines re-entered.\n");
   fnotice (stderr, bug_report_request, bug_report_url);
-  exit (FATAL_EXIT_CODE);
+  exit (ICE_EXIT_CODE);
 }
 
 /* Report an internal compiler error in a friendly manner.  This is
diff --git a/gcc/final.c b/gcc/final.c
index dd5b64ec..3ab428b2 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -1881,7 +1881,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,
 		{
 		  int log_align;
 
-		  readonly_data_section ();
+		  function_readonly_data_section (current_function_decl);
 
 #ifdef ADDR_VEC_ALIGN
 		  log_align = ADDR_VEC_ALIGN (NEXT_INSN (insn));
diff --git a/gcc/flow.c b/gcc/flow.c
index 9f1e1b79..a1b445e9 100644
--- a/gcc/flow.c
+++ b/gcc/flow.c
@@ -1884,6 +1884,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,
 	  rtx set_src = SET_SRC (pc_set (BB_END (bb)));
 	  rtx cond_true = XEXP (set_src, 0);
 	  rtx reg = XEXP (cond_true, 0);
+ 	  enum rtx_code inv_cond;
 
 	  if (GET_CODE (reg) == SUBREG)
 	    reg = SUBREG_REG (reg);
@@ -1892,11 +1893,13 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,
 	     in the form of a comparison of a register against zero.  
 	     If the condition is more complex than that, then it is safe
 	     not to record any information.  */
-	  if (GET_CODE (reg) == REG
+ 	  inv_cond = reversed_comparison_code (cond_true, BB_END (bb));
+ 	  if (inv_cond != UNKNOWN
+	      && GET_CODE (reg) == REG
 	      && XEXP (cond_true, 1) == const0_rtx)
 	    {
 	      rtx cond_false
-		= gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond_true)),
+		= gen_rtx_fmt_ee (inv_cond,
 				  GET_MODE (cond_true), XEXP (cond_true, 0),
 				  XEXP (cond_true, 1));
 	      if (GET_CODE (XEXP (set_src, 1)) == PC)
diff --git a/gcc/gcc.c b/gcc/gcc.c
index ee380ed9..997c37c3 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -354,6 +354,9 @@ static void init_gcc_specs (struct obstack *, const char *, const char *,
 #if defined(HAVE_TARGET_OBJECT_SUFFIX) || defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
 static const char *convert_filename (const char *, int, int);
 #endif
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+static void retry_ice (const char *prog, const char **argv);
+#endif
 
 static const char *if_exists_spec_function (int, const char **);
 static const char *if_exists_else_spec_function (int, const char **);
@@ -2770,7 +2773,7 @@ execute (void)
       if (commands[i].pid == -1)
 	pfatal_pexecute (errmsg_fmt, errmsg_arg);
 
-      if (string != commands[i].prog)
+      if (i && string != commands[i].prog)
 	free ((void *) string);
     }
 
@@ -2848,6 +2851,18 @@ See %s for instructions.",
 	      else if (WIFEXITED (status)
 		       && WEXITSTATUS (status) >= MIN_FATAL_STATUS)
 		{
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+		  /* For ICEs in cc1, cc1obj, cc1plus see if it is
+		     reproducible or not.  */
+		  char *p;
+		  if (getenv("GCC_RETRY_ICE") == NULL
+		      && WEXITSTATUS (status) == ICE_EXIT_CODE
+		      && j == 0
+		      && (p = strrchr (commands[j].argv[0], DIR_SEPARATOR))
+		      && ! strncmp (p + 1, "cc1", 3))
+		    retry_ice (commands[j].prog, commands[j].argv);
+#endif
+
 		  if (WEXITSTATUS (status) > greatest_status)
 		    greatest_status = WEXITSTATUS (status);
 		  ret_code = -1;
@@ -2859,6 +2874,10 @@ See %s for instructions.",
 	      break;
 	    }
       }
+
+    if (commands[0].argv[0] != commands[0].prog)
+      free ((PTR) commands[0].argv[0]);
+
     return ret_code;
   }
 }
@@ -5796,6 +5815,224 @@ give_switch (int switchnum, int omit_first_word)
   switches[switchnum].validated = 1;
 }
 
+#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS) || defined (WIN32))
+#define RETRY_ICE_ATTEMPTS 2
+
+static void
+retry_ice (const char *prog, const char **argv)
+{
+  int nargs, out_arg = -1, quiet = 0, attempt;
+  int pid, retries, sleep_interval;
+  const char **new_argv;
+  char *temp_filenames[RETRY_ICE_ATTEMPTS * 2 + 2];
+
+  if (input_filename == NULL || ! strcmp (input_filename, "-"))
+    return;
+
+  for (nargs = 0; argv[nargs] != NULL; ++nargs)
+    /* Only retry compiler ICEs, not preprocessor ones.  */
+    if (! strcmp (argv[nargs], "-E"))
+      return;
+    else if (argv[nargs][0] == '-' && argv[nargs][1] == 'o')
+      {
+	if (out_arg == -1)
+	  out_arg = nargs;
+	else
+	  return;
+      }
+    /* If the compiler is going to output any time information,
+       it might varry between invocations.  */
+    else if (! strcmp (argv[nargs], "-quiet"))
+      quiet = 1;
+    else if (! strcmp (argv[nargs], "-ftime-report"))
+      return;
+
+  if (out_arg == -1 || !quiet)
+    return;
+
+  memset (temp_filenames, '\0', sizeof (temp_filenames));
+  new_argv = alloca ((nargs + 3) * sizeof (const char *));
+  memcpy (new_argv, argv, (nargs + 1) * sizeof (const char *));
+  new_argv[nargs++] = "-frandom-seed=0";
+  new_argv[nargs] = NULL;
+  if (new_argv[out_arg][2] == '\0')
+    new_argv[out_arg + 1] = "-";
+  else
+    new_argv[out_arg] = "-o-";
+
+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS + 1; ++attempt)
+    {
+      int fd;
+      int status;
+
+      temp_filenames[attempt * 2] = make_temp_file (".out");
+      temp_filenames[attempt * 2 + 1] = make_temp_file (".err");
+
+      if (attempt == RETRY_ICE_ATTEMPTS)
+        {
+	  int i;
+	  int fd1, fd2;
+	  struct stat st1, st2;
+	  size_t n, len;
+	  char *buf;
+
+	  buf = xmalloc (8192);
+
+	  for (i = 0; i < 2; ++i)
+	    {
+	      fd1 = open (temp_filenames[i], O_RDONLY);
+	      fd2 = open (temp_filenames[2 + i], O_RDONLY);
+
+	      if (fd1 < 0 || fd2 < 0)
+		{
+		  i = -1;
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      if (fstat (fd1, &st1) < 0 || fstat (fd2, &st2) < 0)
+		{
+		  i = -1;
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      if (st1.st_size != st2.st_size)
+		{
+		  close (fd1);
+		  close (fd2);
+		  break;
+		}
+
+	      len = 0;
+	      for (n = st1.st_size; n; n -= len)
+		{
+		  len = n;
+		  if (len > 4096)
+		    len = 4096;
+
+		  if (read (fd1, buf, len) != (int) len
+		      || read (fd2, buf + 4096, len) != (int) len)
+		    {
+		      i = -1;
+		      break;
+		    }
+
+		  if (memcmp (buf, buf + 4096, len) != 0)
+		    break;
+		}
+
+	      close (fd1);
+	      close (fd2);
+
+	      if (n)
+		break;
+	    }
+
+	  free (buf);
+	  if (i == -1)
+	    break;
+
+	  if (i != 2)
+	    {
+	      notice ("The bug is not reproducible, so it is likely a hardware or OS problem.\n");
+	      break;
+	    }
+
+          fd = open (temp_filenames[attempt * 2], O_RDWR);
+	  if (fd < 0)
+	    break;
+	  write (fd, "//", 2);
+	  for (i = 0; i < nargs; i++)
+	    {
+	      write (fd, " ", 1);
+	      write (fd, new_argv[i], strlen (new_argv[i]));
+	    }
+	  write (fd, "\n", 1);
+	  new_argv[nargs] = "-E";
+	  new_argv[nargs + 1] = NULL;
+        }
+
+      /* Fork a subprocess; wait and retry if it fails.  */
+      sleep_interval = 1;
+      pid = -1;
+      for (retries = 0; retries < 4; retries++)
+	{
+	  pid = fork ();
+	  if (pid >= 0)
+	    break;
+	  sleep (sleep_interval);
+	  sleep_interval *= 2;
+	}
+
+      if (pid < 0)
+	break;
+      else if (pid == 0)
+	{
+	  if (attempt != RETRY_ICE_ATTEMPTS)
+	    fd = open (temp_filenames[attempt * 2], O_RDWR);
+	  if (fd < 0)
+	    exit (-1);
+	  if (fd != 1)
+	    {
+	      close (1);
+	      dup (fd);
+	      close (fd);
+	    }
+
+	  fd = open (temp_filenames[attempt * 2 + 1], O_RDWR);
+	  if (fd < 0)
+	    exit (-1);
+	  if (fd != 2)
+	    {
+	      close (2);
+	      dup (fd);
+	      close (fd);
+	    }
+
+	  if (prog == new_argv[0])
+	    execvp (prog, (char *const *) new_argv);
+	  else
+	    execv (new_argv[0], (char *const *) new_argv);
+	  exit (-1);
+	}
+
+      if (waitpid (pid, &status, 0) < 0)
+	break;
+
+      if (attempt < RETRY_ICE_ATTEMPTS
+	  && (! WIFEXITED (status) || WEXITSTATUS (status) != ICE_EXIT_CODE))
+	{
+	  notice ("The bug is not reproducible, so it is likely a hardware or OS problem.\n");
+	  break;
+	}
+      else if (attempt == RETRY_ICE_ATTEMPTS)
+	{
+	  close (fd);
+	  if (WIFEXITED (status)
+	      && WEXITSTATUS (status) == SUCCESS_EXIT_CODE)
+	    {
+	      notice ("Preprocessed source stored into %s file, please attach this to your bugreport.\n",
+		      temp_filenames[attempt * 2]);
+	      /* Make sure it is not deleted.  */
+	      free (temp_filenames[attempt * 2]);
+	      temp_filenames[attempt * 2] = NULL;
+	      break;
+	    }
+	}
+    }
+
+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS * 2 + 2; attempt++)
+    if (temp_filenames[attempt])
+      {
+	unlink (temp_filenames[attempt]);
+	free (temp_filenames[attempt]);
+      }
+}
+#endif
+
 /* Search for a file named NAME trying various prefixes including the
    user's -B prefix and some standard ones.
    Return the absolute file name found.  If nothing is found, return NAME.  */
diff --git a/gcc/genpeep.c b/gcc/genpeep.c
index 4c6e64b7..0bce1558 100644
--- a/gcc/genpeep.c
+++ b/gcc/genpeep.c
@@ -381,6 +381,7 @@ from the machine description file `md'.  */\n\n");
   printf ("#include \"recog.h\"\n");
   printf ("#include \"except.h\"\n\n");
   printf ("#include \"function.h\"\n\n");
+  printf ("#include \"flags.h\"\n\n");
 
   printf ("#ifdef HAVE_peephole\n");
   printf ("extern rtx peep_operand[];\n\n");
diff --git a/gcc/java/keyword.gperf b/gcc/java/keyword.gperf
index 4127588f..13162435 100644
--- a/gcc/java/keyword.gperf
+++ b/gcc/java/keyword.gperf
@@ -34,7 +34,7 @@ static unsigned int hash (const char *, unsigned int);
 #ifdef __GNUC__
 __inline
 #endif
-const struct java_keyword *java_keyword (const char *, unsigned int);
+static const struct java_keyword *java_keyword (const char *, unsigned int);
 %%
 abstract, ABSTRACT_TK
 default, DEFAULT_TK
diff --git a/gcc/java/keyword.h b/gcc/java/keyword.h
index 49eda19f..6236605e 100644
--- a/gcc/java/keyword.h
+++ b/gcc/java/keyword.h
@@ -34,7 +34,7 @@ static unsigned int hash (const char *, unsigned int);
 #ifdef __GNUC__
 __inline
 #endif
-const struct java_keyword *java_keyword (const char *, unsigned int);
+static const struct java_keyword *java_keyword (const char *, unsigned int);
 
 #define TOTAL_KEYWORDS 52
 #define MIN_WORD_LENGTH 2
diff --git a/gcc/mklibgcc.in b/gcc/mklibgcc.in
index 8fafce4b..7ac15d8c 100644
--- a/gcc/mklibgcc.in
+++ b/gcc/mklibgcc.in
@@ -41,6 +41,7 @@
 # SHLIB_NM_FLAGS
 # SHLIB_INSTALL
 # MULTILIB_OSDIRNAMES
+# GCC_FOR_TARGET
 
 # Make needs VPATH to be literal.
 echo 'srcdir = @srcdir@'
@@ -513,8 +514,8 @@ EOF
       shlib_slibdir_qual=
       if [ -n "$MULTILIB_OSDIRNAMES" ]; then
 	if [ "$dir" != . ]; then
-	  gcc_multilib_dir=`./xgcc -B./ $flags --print-multi-directory`
-	  os_multilib_dir=`./xgcc -B./ $flags --print-multi-os-directory`
+	  gcc_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-directory`
+	  os_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-os-directory`
 	  shlib_dir="$dir"/
 	  gcc_multilib_sup=`echo $gcc_multilib_dir | sed 's~^[^/]*/~~'`
 	  os_multilib_base=`echo $os_multilib_dir | sed -n "s~/${gcc_multilib_sup}\$~~p"`
@@ -707,8 +708,8 @@ for ml in $MULTILIBS; do
       shlib_dir=
       shlib_slibdir_qual=
       if [ -n "$MULTILIB_OSDIRNAMES" ]; then
-	gcc_multilib_dir=`./xgcc -B./ $flags --print-multi-directory`
-	os_multilib_dir=`./xgcc -B./ $flags --print-multi-os-directory`
+	gcc_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-directory`
+	os_multilib_dir=`$GCC_FOR_TARGET -B./ $flags --print-multi-os-directory`
 	if [ "$dir" != . ]; then
 	  shlib_dir="$dir"/
 	fi
diff --git a/gcc/output.h b/gcc/output.h
index 05a37437..20d70c31 100644
--- a/gcc/output.h
+++ b/gcc/output.h
@@ -213,6 +213,10 @@ extern void named_section (tree, const char *, int);
 /* Tell assembler to switch to the section for function DECL.  */
 extern void function_section (tree);
 
+/* Tell assembler to switch to the readonly data section associated
+   with function DECL.  */
+extern void function_readonly_data_section (tree);
+
 /* Tell assembler to switch to the section for string merging.  */
 extern void mergeable_string_section (tree, unsigned HOST_WIDE_INT,
 				      unsigned int);
diff --git a/gcc/po/ca.po b/gcc/po/ca.po
index e077d02f..17622e23 100644
--- a/gcc/po/ca.po
+++ b/gcc/po/ca.po
@@ -17340,7 +17340,7 @@ msgstr "passant el valor negatiu `%E' per a %s %P de \"%D\""
 
 #: cp/typeck.c:5684
 msgid "%s of negative value `%E' to `%T'"
-msgstr "%s de valor negatiu `%I' a \"%T\""
+msgstr "%s de valor negatiu `%E' a \"%T\""
 
 #: cp/typeck.c:5772
 msgid "cannot convert `%T' to `%T' for argument `%P' to `%D'"
diff --git a/gcc/po/es.po b/gcc/po/es.po
index 4887014a..523052ef 100644
--- a/gcc/po/es.po
+++ b/gcc/po/es.po
@@ -1882,7 +1882,7 @@ msgstr "precisi
 #: c-format.c:1956
 #, c-format
 msgid "%s does not support the `%s' %s length modifier"
-msgstr "%1$s no tiene soporte para el modificador de longitud %3$s `%2$s'"
+msgstr "%s no tiene soporte para el modificador de longitud `%s' %s"
 
 #: c-format.c:2006
 msgid "conversion lacks type at end of format"
@@ -1901,12 +1901,12 @@ msgstr "se desconoce el car
 #: c-format.c:2027
 #, c-format
 msgid "%s does not support the `%%%c' %s format"
-msgstr "%1$s no tiene soporte para el formato %3$s `%%%2$c'"
+msgstr "%s no tiene soporte para el formato `%%%c' %s"
 
 #: c-format.c:2043
 #, c-format
 msgid "%s used with `%%%c' %s format"
-msgstr "se us %1$s con el formato %3$s `%%%2$c'"
+msgstr "se us %s con el formato `%%%c' %s"
 
 #: c-format.c:2052
 #, c-format
@@ -1916,12 +1916,12 @@ msgstr "%s no tiene soporte para %s"
 #: c-format.c:2061
 #, c-format
 msgid "%s does not support %s with the `%%%c' %s format"
-msgstr "%1$s no tiene soporte para %2$s con el formato %4$s `%%%3$c'"
+msgstr "%s no tiene soporte para %s con el formato `%%%c' %s"
 
 #: c-format.c:2094
 #, c-format
 msgid "%s ignored with %s and `%%%c' %s format"
-msgstr "se ignora %1$s con %2$s y el formato %4$s `%%%3$c'"
+msgstr "se ignora %s con %s y el formato `%%%c' %s"
 
 #: c-format.c:2098
 #, c-format
@@ -1931,7 +1931,7 @@ msgstr "se ignora %s con %s en el formato %s"
 #: c-format.c:2104
 #, c-format
 msgid "use of %s and %s together with `%%%c' %s format"
-msgstr "uso de %1$s y %2$s junto con el formato %4$s `%%%3$c'"
+msgstr "uso de %s y %s junto con el formato `%%%c' %s"
 
 #: c-format.c:2108
 #, c-format
@@ -1962,7 +1962,7 @@ msgstr "uso del modificador de longitud `%s' con el car
 #: c-format.c:2180
 #, c-format
 msgid "%s does not support the `%%%s%c' %s format"
-msgstr "%1$s no tiene soporte para el formato %4$s `%%%2$s%3$c'"
+msgstr "%s no tiene soporte para el formato `%%%s%c' %s"
 
 #: c-format.c:2195
 msgid "operand number specified with suppressed assignment"
diff --git a/gcc/system.h b/gcc/system.h
index e19de3f8..d0a28186 100644
--- a/gcc/system.h
+++ b/gcc/system.h
@@ -154,6 +154,10 @@ extern int errno;
 # endif
 #endif
 
+#ifndef ICE_EXIT_CODE
+# define ICE_EXIT_CODE 27
+#endif
+
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
diff --git a/gcc/testsuite/g++.dg/ext/visibility/assign1.C b/gcc/testsuite/g++.dg/ext/visibility/assign1.C
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/g++.dg/ext/visibility/new1.C b/gcc/testsuite/g++.dg/ext/visibility/new1.C
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/g++.old-deja/g++.other/comdat4-aux.cc b/gcc/testsuite/g++.old-deja/g++.other/comdat4-aux.cc
new file mode 100644
index 00000000..e0556a52
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/comdat4-aux.cc
@@ -0,0 +1,40 @@
+extern void
+bar (int x);
+
+inline void
+foo (int i)
+{
+  switch (i)
+    {
+    case 3:
+    case 5:
+    case 6:
+    case 9:
+    case 15:
+      bar (1);
+      break;
+    case 2:
+    case 4:
+    case 7:
+    case 10:
+    case 11:
+    case 12:
+      bar (2);
+      break;
+    case 0:
+    case 1:
+    case 8:
+    case 13:
+    case 16:
+      bar (3);
+      break;
+    case 14:
+      bar (4);
+      break;
+    default:
+      bar (5);
+      break;
+    }
+}
+
+void *fooaddr2 = (void *) foo;
diff --git a/gcc/testsuite/g++.old-deja/g++.other/comdat4.C b/gcc/testsuite/g++.old-deja/g++.other/comdat4.C
new file mode 100644
index 00000000..28b26a1d
--- /dev/null
+++ b/gcc/testsuite/g++.old-deja/g++.other/comdat4.C
@@ -0,0 +1,57 @@
+// PR c++/16276
+// { dg-do link }
+// { dg-additional-sources " comdat4-aux.cc" }
+// { dg-options "-O2" }
+
+extern void
+bar (int x);
+
+inline void
+foo (int i)
+{
+  switch (i)
+    {
+    case 3:
+    case 5:
+    case 6:
+    case 9:
+    case 15:
+      bar (1);
+      break;
+    case 2:
+    case 4:
+    case 7:
+    case 10:
+    case 11:
+    case 12:
+      bar (2);
+      break;
+    case 0:
+    case 1:
+    case 8:
+    case 13:
+    case 16:
+      bar (3);
+      break;
+    case 14:
+      bar (4);
+      break;
+    default:
+      bar (5);
+      break;
+    }
+}
+
+void *fooaddr = (void *) foo;
+
+void
+bar (int x)
+{
+  __asm __volatile ("" : : "r" (x));
+}
+
+int
+main (void)
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/ppc64-toc.c b/gcc/testsuite/gcc.dg/ppc64-toc.c
new file mode 100644
index 00000000..747f137e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ppc64-toc.c
@@ -0,0 +1,22 @@
+/* { dg-do link } */
+/* { dg-options "-m64 -mminimal-toc" { target powerpc64-*-* } } */
+
+char *strchr (const char *, int);
+
+int
+foo (int a)
+{
+  int b;
+
+  b = 0;
+  if ("/"[1] != '\0')
+    if (strchr ("/", a))
+      b = 1;
+  return b;
+}
+
+int
+main (void)
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-1.cc b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-1.cc
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-1.x b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-1.x
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-2.cc b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-2.cc
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-2.x b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-2.x
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3.x b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3.x
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3a.cc b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3a.cc
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3b.cc b/gcc/testsuite/gcc/testsuite/g++.special/inline-hidden-3b.cc
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/g++.special/special.exp b/gcc/testsuite/gcc/testsuite/g++.special/special.exp
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1-dso.c b/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1-dso.c
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1-main.c b/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1-main.c
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1.x b/gcc/testsuite/gcc/testsuite/gcc.special/protfunc-1.x
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/gcc.special/special.exp b/gcc/testsuite/gcc/testsuite/gcc.special/special.exp
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/testsuite/gcc/testsuite/lib/gcc-special.exp b/gcc/testsuite/gcc/testsuite/lib/gcc-special.exp
new file mode 100644
index 00000000..e69de29b
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 33307e52..56cc5a74 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -535,6 +535,45 @@ function_section (tree decl)
     text_section ();
 }
 
+/* Switch to read-only data section associated with function DECL.
+
+   If DECL is NULL_TREE, switch to readonly_data_section ().  */
+
+void
+function_readonly_data_section (tree decl)
+{
+  if (decl != NULL_TREE && DECL_SECTION_NAME (decl))
+    {
+      const char *name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));
+
+      /* For .gnu.linkonce.t.foo we want to use .gnu.linkonce.r.foo.  */
+      if (DECL_ONE_ONLY (decl) && strncmp (name, ".gnu.linkonce.t.", 16) == 0)
+       {
+         size_t len = strlen (name) + 1;
+         char *rname = alloca (len);
+
+         memcpy (rname, name, len);
+         rname[14] = 'r';
+         named_section_flags (rname, SECTION_LINKONCE);
+         return;
+       }
+      /* For .text.foo we want to use .rodata.foo.  */
+      else if (flag_function_sections && flag_data_sections
+              && strncmp (name, ".text.", 6) == 0)
+       {
+         size_t len = strlen (name) + 1;
+         char *rname = alloca (len + 2);
+
+         memcpy (rname, ".rodata", 7);
+         memcpy (rname + 7, name + 5, len - 5);
+         named_section_flags (rname, 0);
+         return;
+       }
+    }
+
+  readonly_data_section ();
+}
+
 /* Switch to section for variable DECL.  RELOC is the same as the
    argument to SELECT_SECTION.  */
 
@@ -2066,6 +2105,11 @@ struct constant_descriptor_tree GTY(())
 
   /* The value of the constant.  */
   tree value;
+
+  /* Hash of value.  Computing the hash from value each time
+     hashfn is called can't work properly, as that means recursive
+     use of the hash table during hash table expansion.  */
+  hashval_t hash;
 };
 
 static GTY((param_is (struct constant_descriptor_tree)))
@@ -2079,7 +2123,7 @@ static void maybe_output_constant_def_contents (struct constant_descriptor_tree
 static hashval_t
 const_desc_hash (const void *ptr)
 {
-  return const_hash_1 (((struct constant_descriptor_tree *)ptr)->value);
+  return ((struct constant_descriptor_tree *)ptr)->hash;
 }
 
 static hashval_t
@@ -2193,8 +2237,11 @@ const_hash_1 (const tree exp)
 static int
 const_desc_eq (const void *p1, const void *p2)
 {
-  return compare_constant (((struct constant_descriptor_tree *)p1)->value,
-			   ((struct constant_descriptor_tree *)p2)->value);
+  const struct constant_descriptor_tree *c1 = p1;
+  const struct constant_descriptor_tree *c2 = p2;
+  if (c1->hash != c2->hash)
+    return 0;
+  return compare_constant (c1->value, c2->value);
 }
 
 /* Compare t1 and t2, and return 1 only if they are known to result in
@@ -2491,12 +2538,14 @@ output_constant_def (tree exp, int defer)
   /* Look up EXP in the table of constant descriptors.  If we didn't find
      it, create a new one.  */
   key.value = exp;
-  loc = htab_find_slot (const_desc_htab, &key, INSERT);
+  key.hash = const_hash_1 (exp);
+  loc = htab_find_slot_with_hash (const_desc_htab, &key, key.hash, INSERT);
 
   desc = *loc;
   if (desc == 0)
     {
       desc = build_constant_desc (exp);
+      desc->hash = key.hash;
       *loc = desc;
     }
 
@@ -2606,7 +2655,8 @@ lookup_constant_def (tree exp)
   struct constant_descriptor_tree key;
 
   key.value = exp;
-  desc = htab_find (const_desc_htab, &key);
+  key.hash = const_hash_1 (exp);
+  desc = htab_find_with_hash (const_desc_htab, &key, key.hash);
 
   return (desc ? desc->rtl : NULL_RTX);
 }
diff --git a/libf2c/libI77/fio.h b/libf2c/libI77/fio.h
index 7734f0c2..4515bbee 100644
--- a/libf2c/libI77/fio.h
+++ b/libf2c/libI77/fio.h
@@ -86,7 +86,7 @@ extern unit f__units[];
 #define errfl(f,m,s) do {return err__fl((int)f,m,s);} while(0)
 
 /*Table sizes*/
-#define MXUNIT 100
+#define MXUNIT 512
 
 extern int f__recpos;		/*position in current record */
 extern int f__cursor;		/* offset to move to */
diff --git a/libffi/configure b/libffi/configure
index 698ae01b..851859fc 100755
--- a/libffi/configure
+++ b/libffi/configure
@@ -1322,14 +1322,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/libffi/src/alpha/osf.S b/libffi/src/alpha/osf.S
index 2f03d627..36052b3d 100644
--- a/libffi/src/alpha/osf.S
+++ b/libffi/src/alpha/osf.S
@@ -356,4 +356,8 @@ $LASFDE3:
 	.byte	16		# uleb128 offset 16*-8
 	.align 3
 $LEFDE3:
+
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
 #endif
diff --git a/libffi/src/arm/sysv.S b/libffi/src/arm/sysv.S
index 0e418611..cf37b690 100644
--- a/libffi/src/arm/sysv.S
+++ b/libffi/src/arm/sysv.S
@@ -125,3 +125,6 @@ epilogue:
 .ffi_call_SYSV_end:
         .size    CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)
 
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",%progbits
+#endif
diff --git a/libffi/src/ia64/ffi.c b/libffi/src/ia64/ffi.c
index c846f6e1..8a7b8e0e 100644
--- a/libffi/src/ia64/ffi.c
+++ b/libffi/src/ia64/ffi.c
@@ -547,7 +547,7 @@ ffi_prep_incoming_args_UNIX(struct ia64_args *args, void **rvalue,
   register unsigned int i;
   register unsigned int avn;
   register void **p_argv;
-  register unsigned long *argp = args -> out_regs;
+  register long *argp = args -> out_regs;
   unsigned fp_reg_num = 0;
   register ffi_type **p_arg;
 
@@ -576,17 +576,15 @@ ffi_prep_incoming_args_UNIX(struct ia64_args *args, void **rvalue,
 	case FFI_TYPE_FLOAT:
 	  z = 1;
 	  /* Convert argument back to float in place from the saved value */
-	  if (fp_reg_num < 8) {
+	  if (argp - args->out_regs < 8 && fp_reg_num < 8) {
 	      *(float *)argp = args -> fp_regs[fp_reg_num++];
-	  } else {
-	      *(float *)argp = *(double *)argp;
 	  }
 	  *p_argv = (void *)argp;
 	  break;
 
 	case FFI_TYPE_DOUBLE:
 	  z = 1;
-	  if (fp_reg_num < 8) {
+	  if (argp - args->out_regs < 8 && fp_reg_num < 8) {
 	      *p_argv = args -> fp_regs + fp_reg_num++;
 	  } else {
 	      *p_argv = (void *)argp;
@@ -598,7 +596,8 @@ ffi_prep_incoming_args_UNIX(struct ia64_args *args, void **rvalue,
 	      size_t sz = (*p_arg)->size;
 	      unsigned short element_type;
               z = ((*p_arg)->size + FFI_SIZEOF_ARG - 1)/FFI_SIZEOF_ARG;
-	      if (is_homogeneous_fp_aggregate(*p_arg, 8, &element_type)) {
+	      if (argp - args->out_regs < 8
+		  && is_homogeneous_fp_aggregate(*p_arg, 8, &element_type)) {
 		int nelements = sz/float_type_size(element_type);
 		if (nelements + fp_reg_num >= 8) {
 		  /* hard case NYI.	*/
diff --git a/libffi/src/ia64/unix.S b/libffi/src/ia64/unix.S
index be267f60..52851ed1 100644
--- a/libffi/src/ia64/unix.S
+++ b/libffi/src/ia64/unix.S
@@ -325,3 +325,7 @@ ffi_closure_UNIX:
 	.endp ffi_closure_UNIX
 	
 
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/m68k/sysv.S b/libffi/src/m68k/sysv.S
index d019a377..24bb081b 100644
--- a/libffi/src/m68k/sysv.S
+++ b/libffi/src/m68k/sysv.S
@@ -95,3 +95,7 @@ epilogue:
 	unlk	%a6
 	rts
 	.size	ffi_call_SYSV,.-ffi_call_SYSV
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/linux64.S b/libffi/src/powerpc/linux64.S
index 11cf926b..b78d3199 100644
--- a/libffi/src/powerpc/linux64.S
+++ b/libffi/src/powerpc/linux64.S
@@ -174,3 +174,7 @@ ffi_call_LINUX64:
 	.align 3
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/linux64_closure.S b/libffi/src/powerpc/linux64_closure.S
index fa331dbe..5fb2f364 100644
--- a/libffi/src/powerpc/linux64_closure.S
+++ b/libffi/src/powerpc/linux64_closure.S
@@ -203,3 +203,7 @@ ffi_closure_LINUX64:
 	.align 3
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/ppc_closure.S b/libffi/src/powerpc/ppc_closure.S
index dce9daba..dda63a4e 100644
--- a/libffi/src/powerpc/ppc_closure.S
+++ b/libffi/src/powerpc/ppc_closure.S
@@ -248,3 +248,7 @@ END(ffi_closure_SYSV)
 .LEFDE1:
 
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/powerpc/sysv.S b/libffi/src/powerpc/sysv.S
index a7aaa3f8..b4b2ffdb 100644
--- a/libffi/src/powerpc/sysv.S
+++ b/libffi/src/powerpc/sysv.S
@@ -189,3 +189,7 @@ END(ffi_call_SYSV)
       .align 2
 .LEFDE1:
 #endif
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/s390/sysv.S b/libffi/src/s390/sysv.S
index e9cbed97..09cdec14 100644
--- a/libffi/src/s390/sysv.S
+++ b/libffi/src/s390/sysv.S
@@ -427,3 +427,6 @@ ffi_closure_SYSV:
 
 #endif
 
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/sparc/v8.S b/libffi/src/sparc/v8.S
index aaa7be7b..b2783062 100644
--- a/libffi/src/sparc/v8.S
+++ b/libffi/src/sparc/v8.S
@@ -255,3 +255,7 @@ done2:
 	.byte	0x1f	! uleb128 0x1f
 	.align	WS
 .LLEFDE2:
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/sparc/v9.S b/libffi/src/sparc/v9.S
index d640e023..a8e8bf98 100644
--- a/libffi/src/sparc/v9.S
+++ b/libffi/src/sparc/v9.S
@@ -300,3 +300,7 @@ longdouble1:
 	.align 8
 .LLEFDE2:
 #endif
+
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/x86/sysv.S b/libffi/src/x86/sysv.S
index 53a4c2b7..37e1e295 100644
--- a/libffi/src/x86/sysv.S
+++ b/libffi/src/x86/sysv.S
@@ -182,3 +182,7 @@ epilogue:
 .LEFDE1:
 
 #endif /* ifndef __x86_64__ */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libffi/src/x86/unix64.S b/libffi/src/x86/unix64.S
index 310fed71..9d75e7fa 100644
--- a/libffi/src/x86/unix64.S
+++ b/libffi/src/x86/unix64.S
@@ -301,3 +301,7 @@ ffi_closure_UNIX64:
 .LEFDE3:
 
 #endif /* __x86_64__  */
+
+#if defined __ELF__ && defined __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/libiberty/Makefile.in b/libiberty/Makefile.in
index fc86feb4..416948af 100644
--- a/libiberty/Makefile.in
+++ b/libiberty/Makefile.in
@@ -224,6 +224,7 @@ $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS)
 	  $(AR) $(AR_FLAGS) $(TARGETLIB) \
 	    $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS); \
 	  $(RANLIB) $(TARGETLIB); \
+	  cp $(TARGETLIB) ../ ; \
 	  cd ..; \
 	else true; fi
 
diff --git a/libiberty/splay-tree.c b/libiberty/splay-tree.c
index fc98db16..b1410aa3 100644
--- a/libiberty/splay-tree.c
+++ b/libiberty/splay-tree.c
@@ -59,18 +59,59 @@ splay_tree_delete_helper (sp, node)
      splay_tree sp;
      splay_tree_node node;
 {
+  splay_tree_node pending = 0;
+  splay_tree_node active = 0;
+
   if (!node)
     return;
 
-  splay_tree_delete_helper (sp, node->left);
-  splay_tree_delete_helper (sp, node->right);
+#define KDEL(x)  if (sp->delete_key) (*sp->delete_key)(x);
+#define VDEL(x)  if (sp->delete_value) (*sp->delete_value)(x);
+
+  KDEL (node->key);
+  VDEL (node->value);
+
+  /* We use the "key" field to hold the "next" pointer.  */
+  node->key = (splay_tree_key)pending;
+  pending = (splay_tree_node)node;
+
+  /* Now, keep processing the pending list until there aren't any
+     more.  This is a little more complicated than just recursing, but
+     it doesn't toast the stack for large trees.  */
+
+  while (pending)
+    {
+      active = pending;
+      pending = 0;
+      while (active)
+	{
+	  splay_tree_node temp;
+
+	  /* active points to a node which has its key and value
+	     deallocated, we just need to process left and right.  */
 
-  if (sp->delete_key)
-    (*sp->delete_key)(node->key);
-  if (sp->delete_value)
-    (*sp->delete_value)(node->value);
+	  if (active->left)
+	    {
+	      KDEL (active->left->key);
+	      VDEL (active->left->value);
+	      active->left->key = (splay_tree_key)pending;
+	      pending = (splay_tree_node)(active->left);
+	    }
+	  if (active->right)
+	    {
+	      KDEL (active->right->key);
+	      VDEL (active->right->value);
+	      active->right->key = (splay_tree_key)pending;
+	      pending = (splay_tree_node)(active->right);
+	    }
 
-  (*sp->deallocate) ((char*) node, sp->allocate_data);
+	  temp = active;
+	  active = (splay_tree_node)(temp->key);
+	  (*sp->deallocate) ((char*) temp, sp->allocate_data);
+	}
+    }
+#undef KDEL
+#undef VDEL
 }
 
 /* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent
diff --git a/libjava/configure b/libjava/configure
index 969bd910..5b72290e 100755
--- a/libjava/configure
+++ b/libjava/configure
@@ -2033,14 +2033,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
@@ -4128,6 +4121,9 @@ use_gtk_awt=""
 # The default toolkit to use is the first one specified.
 TOOLKIT=
 
+if test -n "${with_multisubdir}"; then
+  peerlibs=no
+fi
 
 for peer in $peerlibs ; do
   case $peer in
diff --git a/libjava/configure.in b/libjava/configure.in
index 26f39cc3..cbfc0b0d 100644
--- a/libjava/configure.in
+++ b/libjava/configure.in
@@ -367,6 +367,10 @@ use_gtk_awt=""
 TOOLKIT=
 AC_SUBST(TOOLKIT)
 
+if test -n "${with_multisubdir}"; then
+  peerlibs=no
+fi
+
 for peer in $peerlibs ; do
   case $peer in
     xlib)
diff --git a/libjava/include/x86_64-signal.h b/libjava/include/x86_64-signal.h
index f9c8e239..23f40119 100644
--- a/libjava/include/x86_64-signal.h
+++ b/libjava/include/x86_64-signal.h
@@ -40,7 +40,7 @@ do									     \
   /* Advance the program counter so that it is after the start of the	     \
      instruction:  the x86_64 exception handler expects			     \
      the PC to point to the instruction after a call. */		     \
-  struct ucontext *_uc = (struct ucontext *)_p;				     \
+  ucontext_t *_uc = (ucontext_t *)_p;				     \
   volatile struct sigcontext *_sc = (struct sigcontext *) &_uc->uc_mcontext; \
   _sc->rip += 2;							     \
 }									     \
diff --git a/libobjc/configure b/libobjc/configure
index 55eb9ce8..5b09e271 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -1612,14 +1612,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index cf541ed0..44c75591 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -274,7 +274,7 @@ AC_DEFUN([GLIBCXX_CHECK_LINKER_FEATURES], [
   # does some of this, but throws away the result.
   changequote(,)
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
   changequote([,])
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 4bb1ed39..b18c3003 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -4002,14 +4002,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
@@ -8169,7 +8162,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -53532,7 +53525,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -75202,7 +75195,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -77570,7 +77563,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -79814,7 +79807,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -82826,7 +82819,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -85023,7 +85016,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -87111,7 +87104,7 @@ _ACEOF
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
@@ -91166,7 +91159,7 @@ done
   # does some of this, but throws away the result.
 
   ldver=`$LD --version 2>/dev/null | head -1 | \
-         sed -e 's/GNU ld version \([0-9.][0-9.]*\).*/\1/'`
+         sed -e 's/GNU ld \(version \)\{0,1\}\(([^)]*) \)\{0,1\}\([0-9.][0-9.]*\).*/\3/'`
 
   glibcxx_gnu_ld_version=`echo $ldver | \
          $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`
diff --git a/libstdc++-v3/docs/doxygen/filter b/libstdc++-v3/docs/doxygen/filter
index 4ea2d41b..9ef4e6c9 100755
--- a/libstdc++-v3/docs/doxygen/filter
+++ b/libstdc++-v3/docs/doxygen/filter
@@ -1,5 +1,7 @@
 #!/bin/sh
 
+export LC_ALL=C
+
 script=$1
 file=$2
 
diff --git a/libtool.m4 b/libtool.m4
index 5afbd026..cfd02b46 100644
--- a/libtool.m4
+++ b/libtool.m4
@@ -679,14 +679,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method=['file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'] ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
diff --git a/zlib/configure b/zlib/configure
index 1f87a53f..06b517ef 100755
--- a/zlib/configure
+++ b/zlib/configure
@@ -1579,14 +1579,7 @@ irix5* | irix6*)
 
 # This must be Linux ELF.
 linux-gnu*)
-  case $host_cpu in
-  alpha* | mips* | hppa* | i*86 | powerpc* | sparc* | ia64* | sh* )
-    lt_cv_deplibs_check_method=pass_all ;;
-  *)
-    # glibc up to 2.1.1 does not perform some relocations on ARM
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )' ;;
-  esac
-  lt_cv_file_magic_test_file=`echo /lib/libc.so* /lib/libc-*.so`
+  lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
